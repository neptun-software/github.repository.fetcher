{
  "metadata": {
    "timestamp": 1736710052107,
    "page": 666,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TeamWin/Team-Win-Recovery-Project",
      "stars": 1973,
      "defaultBranch": "android-9.0",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.2998046875,
          "content": "BasedOnStyle: Google\nAllowShortBlocksOnASingleLine: false\nAllowShortFunctionsOnASingleLine: Empty\nAllowShortIfStatementsOnASingleLine: true\n\nColumnLimit: 100\nCommentPragmas: NOLINT:.*\nDerivePointerAlignment: false\nIndentWidth: 2\nPointerAlignment: Left\nTabWidth: 2\nUseTab: Never\n\nCpp11BracedListStyle: false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0146484375,
          "content": ".*.swp\n*~\ntags\n"
        },
        {
          "name": "Android.bp",
          "type": "blob",
          "size": 0.1240234375,
          "content": "subdirs = [\n//    \"applypatch\",\n    \"bootloader_message\",\n//    \"edify\",\n//    \"otafault\",\n//    \"otautil\",\n//    \"uncrypt\",\n]\n"
        },
        {
          "name": "Android.mk",
          "type": "blob",
          "size": 26.5625,
          "content": "# Copyright (C) 2007 The Android Open Source Project\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nLOCAL_PATH := $(call my-dir)\ncommands_TWRP_local_path := $(LOCAL_PATH)\n\nifdef project-path-for\n    ifeq ($(LOCAL_PATH),$(call project-path-for,recovery))\n        PROJECT_PATH_AGREES := true\n        BOARD_SEPOLICY_DIRS += $(call project-path-for,recovery)/sepolicy\n    endif\nelse\n    ifeq ($(LOCAL_PATH),bootable/recovery)\n        PROJECT_PATH_AGREES := true\n        BOARD_SEPOLICY_DIRS += bootable/recovery/sepolicy\n    endif\nendif\n\nifeq ($(PROJECT_PATH_AGREES),true)\n\nifneq (,$(filter $(PLATFORM_SDK_VERSION), 21 22))\n# Make recovery domain permissive for TWRP\n    BOARD_SEPOLICY_UNION += twrp.te\nendif\n\ninclude $(CLEAR_VARS)\n\nTWRES_PATH := /twres/\nTWHTCD_PATH := $(TWRES_PATH)htcd/\n\nTARGET_RECOVERY_GUI := true\n\nifneq ($(TW_DEVICE_VERSION),)\n    LOCAL_CFLAGS += -DTW_DEVICE_VERSION='\"-$(TW_DEVICE_VERSION)\"'\nelse\n    LOCAL_CFLAGS += -DTW_DEVICE_VERSION='\"-0\"'\nendif\n\nLOCAL_SRC_FILES := \\\n    twrp.cpp \\\n    fixContexts.cpp \\\n    twrpTar.cpp \\\n    exclude.cpp \\\n    find_file.cpp \\\n    infomanager.cpp \\\n    data.cpp \\\n    partition.cpp \\\n    partitionmanager.cpp \\\n    progresstracking.cpp \\\n    twinstall.cpp \\\n    twrp-functions.cpp \\\n    twrpDigestDriver.cpp \\\n    openrecoveryscript.cpp \\\n    tarWrite.c \\\n    twrpAdbBuFifo.cpp\n\nifneq ($(TARGET_RECOVERY_REBOOT_SRC),)\n  LOCAL_SRC_FILES += $(TARGET_RECOVERY_REBOOT_SRC)\nendif\n\nLOCAL_MODULE := recovery\n\n#LOCAL_FORCE_STATIC_EXECUTABLE := true\n\n#ifeq ($(TARGET_USERIMAGES_USE_F2FS),true)\n#ifeq ($(HOST_OS),linux)\n#LOCAL_REQUIRED_MODULES := mkfs.f2fs\n#endif\n#endif\n\nRECOVERY_API_VERSION := 3\nRECOVERY_FSTAB_VERSION := 2\nLOCAL_CFLAGS += -DRECOVERY_API_VERSION=$(RECOVERY_API_VERSION)\nLOCAL_CFLAGS += -Wno-unused-parameter\nLOCAL_CLANG := true\n\n#LOCAL_STATIC_LIBRARIES := \\\n#    libext4_utils_static \\\n#    libsparse_static \\\n#    libminzip \\\n#    libz \\\n#    libmtdutils \\\n#    libmincrypt \\\n#    libminadbd \\\n#    libminui \\\n#    libpixelflinger_static \\\n#    libpng \\\n#    libfs_mgr \\\n#    libcutils \\\n#    liblog \\\n#    libselinux \\\n#    libstdc++ \\\n#    libm \\\n#    libc\n\nLOCAL_C_INCLUDES += \\\n    system/vold \\\n    system/extras \\\n    system/core/adb \\\n    system/core/libsparse \\\n    external/zlib \\\n    $(LOCAL_PATH)/bootloader_message_twrp/include\n\nLOCAL_C_INCLUDES += bionic\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 23; echo $$?),0)\n    LOCAL_C_INCLUDES += external/stlport/stlport external/openssl/include\n    LOCAL_CFLAGS += -DUSE_FUSE_SIDELOAD22\nelse\n    LOCAL_C_INCLUDES += external/boringssl/include external/libcxx/include\nendif\n\nLOCAL_STATIC_LIBRARIES :=\nLOCAL_SHARED_LIBRARIES :=\n\nLOCAL_STATIC_LIBRARIES += libguitwrp\nLOCAL_SHARED_LIBRARIES += libaosprecovery libz libc libcutils libstdc++ libtar libblkid libminuitwrp libminadbd libmtdutils libtwadbbu libbootloader_message_twrp\nLOCAL_SHARED_LIBRARIES += libcrecovery libtwadbbu libtwrpdigest libc++\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 23; echo $$?),0)\n    LOCAL_SHARED_LIBRARIES += libstlport\n    LOCAL_CFLAGS += -DTW_NO_SHA2_LIBRARY\nendif\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?),0)\n    LOCAL_SHARED_LIBRARIES += libmincrypttwrp\n    LOCAL_C_INCLUDES += $(LOCAL_PATH)/libmincrypt/includes\n    LOCAL_CFLAGS += -DUSE_OLD_VERIFIER\nelse\n    LOCAL_SHARED_LIBRARIES += libcrypto\nendif\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 24; echo $$?),0)\n    LOCAL_SHARED_LIBRARIES += libbase\nendif\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 26; echo $$?),0)\n   LOCAL_SHARED_LIBRARIES += libziparchive\n   LOCAL_C_INCLUDES += $(LOCAL_PATH)/otautil/include\nelse\n    LOCAL_SHARED_LIBRARIES += libminzip\n    LOCAL_CFLAGS += -DUSE_MINZIP\nendif\n\nifneq ($(wildcard system/core/libsparse/Android.mk),)\nLOCAL_SHARED_LIBRARIES += libsparse\nendif\n\nifeq ($(TW_OEM_BUILD),true)\n    LOCAL_CFLAGS += -DTW_OEM_BUILD\n    BOARD_HAS_NO_REAL_SDCARD := true\n    TW_USE_TOOLBOX := true\n    TW_EXCLUDE_MTP := true\nendif\n\nifeq ($(TARGET_USERIMAGES_USE_EXT4), true)\n    ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 28; echo $$?),0)\n        LOCAL_CFLAGS += -DUSE_EXT4\n        LOCAL_C_INCLUDES += system/extras/ext4_utils\n        LOCAL_SHARED_LIBRARIES += libext4_utils\n        ifneq ($(wildcard external/lz4/Android.mk),)\n            #LOCAL_STATIC_LIBRARIES += liblz4\n        endif\n    endif\nendif\nLOCAL_C_INCLUDES += external/libselinux/include\nLOCAL_SHARED_LIBRARIES += libselinux\n#ifneq ($(TARGET_USERIMAGES_USE_EXT4), true)\n#    LOCAL_CFLAGS += -DUSE_EXT4\n#    LOCAL_C_INCLUDES += system/extras/ext4_utils\n#    LOCAL_SHARED_LIBRARIES += libext4_utils\n#    ifneq ($(wildcard external/lz4/Android.mk),)\n#        LOCAL_STATIC_LIBRARIES += liblz4\n#    endif\n#endif\n\nifeq ($(AB_OTA_UPDATER),true)\n    LOCAL_CFLAGS += -DAB_OTA_UPDATER=1\n    LOCAL_SHARED_LIBRARIES += libhardware\n    LOCAL_REQUIRED_MODULES += libhardware\nendif\n\nLOCAL_MODULE_PATH := $(TARGET_RECOVERY_ROOT_OUT)/sbin\n\n#ifeq ($(TARGET_RECOVERY_UI_LIB),)\n#  LOCAL_SRC_FILES += default_device.cpp\n#else\n#  LOCAL_STATIC_LIBRARIES += $(TARGET_RECOVERY_UI_LIB)\n#endif\n\nLOCAL_C_INCLUDES += system/extras/ext4_utils\n\ntw_git_revision := $(shell git -C $(LOCAL_PATH) rev-parse --short=8 HEAD 2>/dev/null)\nifeq ($(shell git -C $(LOCAL_PATH) diff --quiet; echo $$?),1)\n    tw_git_revision := $(tw_git_revision)-dirty\nendif\nLOCAL_CFLAGS += -DTW_GIT_REVISION='\"$(tw_git_revision)\"'\n\n#TWRP Build Flags\nifeq ($(TW_EXCLUDE_MTP),)\n    LOCAL_SHARED_LIBRARIES += libtwrpmtp\n    LOCAL_CFLAGS += -DTW_HAS_MTP\nendif\nifneq ($(TW_NO_SCREEN_TIMEOUT),)\n    LOCAL_CFLAGS += -DTW_NO_SCREEN_TIMEOUT\nendif\nifeq ($(BOARD_HAS_NO_REAL_SDCARD), true)\n    LOCAL_CFLAGS += -DBOARD_HAS_NO_REAL_SDCARD\nendif\nifneq ($(RECOVERY_SDCARD_ON_DATA),)\n\tLOCAL_CFLAGS += -DRECOVERY_SDCARD_ON_DATA\nendif\nifneq ($(TW_INCLUDE_DUMLOCK),)\n\tLOCAL_CFLAGS += -DTW_INCLUDE_DUMLOCK\nendif\nifneq ($(TW_INTERNAL_STORAGE_PATH),)\n\tLOCAL_CFLAGS += -DTW_INTERNAL_STORAGE_PATH=$(TW_INTERNAL_STORAGE_PATH)\nendif\nifneq ($(TW_INTERNAL_STORAGE_MOUNT_POINT),)\n\tLOCAL_CFLAGS += -DTW_INTERNAL_STORAGE_MOUNT_POINT=$(TW_INTERNAL_STORAGE_MOUNT_POINT)\nendif\nifneq ($(TW_EXTERNAL_STORAGE_PATH),)\n\tLOCAL_CFLAGS += -DTW_EXTERNAL_STORAGE_PATH=$(TW_EXTERNAL_STORAGE_PATH)\nendif\nifneq ($(TW_EXTERNAL_STORAGE_MOUNT_POINT),)\n\tLOCAL_CFLAGS += -DTW_EXTERNAL_STORAGE_MOUNT_POINT=$(TW_EXTERNAL_STORAGE_MOUNT_POINT)\nendif\nifeq ($(TW_HAS_NO_BOOT_PARTITION), true)\n    LOCAL_CFLAGS += -DTW_HAS_NO_BOOT_PARTITION\nendif\nifeq ($(TW_NO_REBOOT_BOOTLOADER), true)\n    LOCAL_CFLAGS += -DTW_NO_REBOOT_BOOTLOADER\nendif\nifeq ($(TW_NO_REBOOT_RECOVERY), true)\n    LOCAL_CFLAGS += -DTW_NO_REBOOT_RECOVERY\nendif\nifeq ($(TW_NO_BATT_PERCENT), true)\n    LOCAL_CFLAGS += -DTW_NO_BATT_PERCENT\nendif\nifeq ($(TW_NO_CPU_TEMP), true)\n    LOCAL_CFLAGS += -DTW_NO_CPU_TEMP\nendif\nifneq ($(TW_CUSTOM_POWER_BUTTON),)\n\tLOCAL_CFLAGS += -DTW_CUSTOM_POWER_BUTTON=$(TW_CUSTOM_POWER_BUTTON)\nendif\nifeq ($(TW_ALWAYS_RMRF), true)\n    LOCAL_CFLAGS += -DTW_ALWAYS_RMRF\nendif\nifeq ($(TW_NEVER_UNMOUNT_SYSTEM), true)\n    LOCAL_CFLAGS += -DTW_NEVER_UNMOUNT_SYSTEM\nendif\nifeq ($(TW_NO_USB_STORAGE), true)\n    LOCAL_CFLAGS += -DTW_NO_USB_STORAGE\nendif\nifeq ($(TW_INCLUDE_INJECTTWRP), true)\n    LOCAL_CFLAGS += -DTW_INCLUDE_INJECTTWRP\nendif\nifeq ($(TW_INCLUDE_BLOBPACK), true)\n    LOCAL_CFLAGS += -DTW_INCLUDE_BLOBPACK\nendif\nifneq ($(TARGET_USE_CUSTOM_LUN_FILE_PATH),)\n    LOCAL_CFLAGS += -DCUSTOM_LUN_FILE=\\\"$(TARGET_USE_CUSTOM_LUN_FILE_PATH)\\\"\nendif\nifneq ($(BOARD_UMS_LUNFILE),)\n    LOCAL_CFLAGS += -DCUSTOM_LUN_FILE=\\\"$(BOARD_UMS_LUNFILE)\\\"\nendif\nifeq ($(TW_HAS_DOWNLOAD_MODE), true)\n    LOCAL_CFLAGS += -DTW_HAS_DOWNLOAD_MODE\nendif\nifeq ($(TW_NO_SCREEN_BLANK), true)\n    LOCAL_CFLAGS += -DTW_NO_SCREEN_BLANK\nendif\nifeq ($(TW_SDEXT_NO_EXT4), true)\n    LOCAL_CFLAGS += -DTW_SDEXT_NO_EXT4\nendif\nifeq ($(TW_FORCE_CPUINFO_FOR_DEVICE_ID), true)\n    LOCAL_CFLAGS += -DTW_FORCE_CPUINFO_FOR_DEVICE_ID\nendif\nifeq ($(TW_NO_EXFAT_FUSE), true)\n    LOCAL_CFLAGS += -DTW_NO_EXFAT_FUSE\nendif\nifeq ($(TW_INCLUDE_JB_CRYPTO), true)\n    TW_INCLUDE_CRYPTO := true\nendif\nifeq ($(TW_INCLUDE_L_CRYPTO), true)\n    TW_INCLUDE_CRYPTO := true\nendif\nifeq ($(TW_INCLUDE_CRYPTO), true)\n    LOCAL_CFLAGS += -DTW_INCLUDE_CRYPTO\n    LOCAL_SHARED_LIBRARIES += libcryptfslollipop libgpt_twrp\n    LOCAL_C_INCLUDES += external/boringssl/src/include\n    ifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 24; echo $$?),0)\n        TW_INCLUDE_CRYPTO_FBE := true\n        LOCAL_CFLAGS += -DTW_INCLUDE_FBE\n        LOCAL_SHARED_LIBRARIES += libe4crypt\n    endif\n    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),)\n    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),false)\n        LOCAL_CFLAGS += -DTW_CRYPTO_USE_SYSTEM_VOLD\n        LOCAL_STATIC_LIBRARIES += libvolddecrypt\n    endif\n    endif\nendif\nWITH_CRYPTO_UTILS := \\\n    $(if $(wildcard system/core/libcrypto_utils/android_pubkey.c),true)\nifeq ($(TW_USE_MODEL_HARDWARE_ID_FOR_DEVICE_ID), true)\n    LOCAL_CFLAGS += -DTW_USE_MODEL_HARDWARE_ID_FOR_DEVICE_ID\nendif\nifneq ($(TW_BRIGHTNESS_PATH),)\n\tLOCAL_CFLAGS += -DTW_BRIGHTNESS_PATH=$(TW_BRIGHTNESS_PATH)\nendif\nifneq ($(TW_SECONDARY_BRIGHTNESS_PATH),)\n\tLOCAL_CFLAGS += -DTW_SECONDARY_BRIGHTNESS_PATH=$(TW_SECONDARY_BRIGHTNESS_PATH)\nendif\nifneq ($(TW_MAX_BRIGHTNESS),)\n\tLOCAL_CFLAGS += -DTW_MAX_BRIGHTNESS=$(TW_MAX_BRIGHTNESS)\nendif\nifneq ($(TW_DEFAULT_BRIGHTNESS),)\n\tLOCAL_CFLAGS += -DTW_DEFAULT_BRIGHTNESS=$(TW_DEFAULT_BRIGHTNESS)\nendif\nifneq ($(TW_CUSTOM_BATTERY_PATH),)\n\tLOCAL_CFLAGS += -DTW_CUSTOM_BATTERY_PATH=$(TW_CUSTOM_BATTERY_PATH)\nendif\nifneq ($(TW_CUSTOM_CPU_TEMP_PATH),)\n\tLOCAL_CFLAGS += -DTW_CUSTOM_CPU_TEMP_PATH=$(TW_CUSTOM_CPU_TEMP_PATH)\nendif\nifneq ($(TW_EXCLUDE_ENCRYPTED_BACKUPS), true)\n    LOCAL_SHARED_LIBRARIES += libopenaes\nelse\n    LOCAL_CFLAGS += -DTW_EXCLUDE_ENCRYPTED_BACKUPS\nendif\nifeq ($(TARGET_RECOVERY_QCOM_RTC_FIX),)\n  ifneq ($(filter msm8226 msm8x26 msm8610 msm8974 msm8x74 msm8084 msm8x84 apq8084 msm8909 msm8916 msm8992 msm8994 msm8952 msm8996 msm8937 msm8953 msm8998,$(TARGET_BOARD_PLATFORM)),)\n    LOCAL_CFLAGS += -DQCOM_RTC_FIX\n  else ifeq ($(TARGET_CPU_VARIANT),krait)\n    LOCAL_CFLAGS += -DQCOM_RTC_FIX\n  endif\nelse ifeq ($(TARGET_RECOVERY_QCOM_RTC_FIX),true)\n    LOCAL_CFLAGS += -DQCOM_RTC_FIX\nendif\nifneq ($(TW_NO_LEGACY_PROPS),)\n\tLOCAL_CFLAGS += -DTW_NO_LEGACY_PROPS\nendif\nifneq ($(wildcard bionic/libc/include/sys/capability.h),)\n    LOCAL_CFLAGS += -DHAVE_CAPABILITIES\nendif\nifneq ($(TARGET_RECOVERY_INITRC),)\n    TW_EXCLUDE_DEFAULT_USB_INIT := true\nendif\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -gt 22; echo $$?),0)\n    LOCAL_CFLAGS += -DTW_USE_NEW_MINADBD\nendif\nifneq ($(TW_DEFAULT_LANGUAGE),)\n    LOCAL_CFLAGS += -DTW_DEFAULT_LANGUAGE=$(TW_DEFAULT_LANGUAGE)\nelse\n    LOCAL_CFLAGS += -DTW_DEFAULT_LANGUAGE=en\nendif\nifneq ($(TW_CLOCK_OFFSET),)\n\tLOCAL_CFLAGS += -DTW_CLOCK_OFFSET=$(TW_CLOCK_OFFSET)\nendif\nLOCAL_REQUIRED_MODULES += \\\n    dump_image \\\n    erase_image \\\n    flash_image \\\n    mke2fs.conf \\\n    pigz \\\n    teamwin \\\n    toolbox_symlinks \\\n    twrp \\\n    fsck.fat \\\n    fatlabel \\\n    mkfs.fat \\\n    permissive.sh \\\n    simg2img_twrp \\\n    libbootloader_message_twrp \\\n    init.recovery.hlthchrg.rc \\\n    init.recovery.service.rc\n\nifneq ($(TARGET_ARCH), arm64)\n    ifneq ($(TARGET_ARCH), x86_64)\n        LOCAL_LDFLAGS += -Wl,-dynamic-linker,/sbin/linker\n    else\n        LOCAL_LDFLAGS += -Wl,-dynamic-linker,/sbin/linker64\n    endif\nelse\n    LOCAL_LDFLAGS += -Wl,-dynamic-linker,/sbin/linker64\nendif\nifneq ($(TW_USE_TOOLBOX), true)\n    ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?),0)\n        LOCAL_POST_INSTALL_CMD := \\\n            $(hide) mkdir -p $(TARGET_RECOVERY_ROOT_OUT)/sbin && \\\n            ln -sf /sbin/busybox $(TARGET_RECOVERY_ROOT_OUT)/sbin/sh\n    endif\nelse\n    ifneq ($(wildcard external/toybox/Android.mk),)\n        LOCAL_REQUIRED_MODULES += toybox_symlinks\n    endif\n    ifneq ($(wildcard external/zip/Android.mk),)\n        LOCAL_REQUIRED_MODULES += zip\n    endif\n    ifneq ($(wildcard external/unzip/Android.mk),)\n        LOCAL_REQUIRED_MODULES += unzip\n    endif\nendif\n\nifneq ($(TW_NO_EXFAT), true)\n    LOCAL_REQUIRED_MODULES += mkexfatfs fsckexfat\n    ifneq ($(TW_NO_EXFAT_FUSE), true)\n        LOCAL_REQUIRED_MODULES += exfat-fuse\n    endif\nendif\nifeq ($(BOARD_HAS_NO_REAL_SDCARD),)\n    ifeq ($(shell test $(PLATFORM_SDK_VERSION) -gt 22; echo $$?),0)\n        LOCAL_REQUIRED_MODULES += sgdisk\n    else\n        LOCAL_REQUIRED_MODULES += sgdisk_static\n    endif\nendif\nifneq ($(TW_EXCLUDE_ENCRYPTED_BACKUPS), true)\n    LOCAL_REQUIRED_MODULES += openaes openaes_license\nendif\nifeq ($(TW_INCLUDE_DUMLOCK), true)\n    LOCAL_REQUIRED_MODULES += \\\n        htcdumlock htcdumlocksys flash_imagesys dump_imagesys libbmlutils.so \\\n        libflashutils.so libmmcutils.so libmtdutils.so HTCDumlock.apk\nendif\nifeq ($(TW_INCLUDE_FB2PNG), true)\n    LOCAL_REQUIRED_MODULES += fb2png\nendif\nifneq ($(TW_OEM_BUILD),true)\n    LOCAL_REQUIRED_MODULES += orscmd\nendif\nifeq ($(BOARD_USES_BML_OVER_MTD),true)\n    LOCAL_REQUIRED_MODULES += bml_over_mtd\nendif\nifeq ($(TW_INCLUDE_INJECTTWRP), true)\n    LOCAL_REQUIRED_MODULES += injecttwrp\nendif\nifneq ($(TW_EXCLUDE_DEFAULT_USB_INIT), true)\n    LOCAL_REQUIRED_MODULES += init.recovery.usb.rc\nendif\nifeq ($(TWRP_INCLUDE_LOGCAT), true)\n    LOCAL_REQUIRED_MODULES += logcat\n    ifeq ($(TARGET_USES_LOGD), true)\n        LOCAL_REQUIRED_MODULES += logd libsysutils libnl init.recovery.logd.rc\n    endif\nendif\n# Allow devices to specify device-specific recovery dependencies\nifneq ($(TARGET_RECOVERY_DEVICE_MODULES),)\n    LOCAL_REQUIRED_MODULES += $(TARGET_RECOVERY_DEVICE_MODULES)\nendif\nLOCAL_CFLAGS += -DTWRES=\\\"$(TWRES_PATH)\\\"\nLOCAL_CFLAGS += -DTWHTCD_PATH=\\\"$(TWHTCD_PATH)\\\"\nifeq ($(TW_INCLUDE_NTFS_3G),true)\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -gt 22; echo $$?),0)\n    LOCAL_REQUIRED_MODULES += \\\n        mount.ntfs \\\n        fsck.ntfs \\\n        mkfs.ntfs\nelse\n    LOCAL_REQUIRED_MODULES += \\\n        ntfs-3g \\\n        ntfsfix \\\n        mkntfs\nendif\nendif\nifeq ($(TARGET_USERIMAGES_USE_F2FS), true)\nifeq ($(shell test $(CM_PLATFORM_SDK_VERSION) -ge 3; echo $$?),0)\n    LOCAL_REQUIRED_MODULES += \\\n        fsck.f2fs \\\n        mkfs.f2fs\nendif\nendif\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 25; echo $$?),0)\n    LOCAL_REQUIRED_MODULES += file_contexts_text\nendif\n\nifeq ($(BOARD_CACHEIMAGE_PARTITION_SIZE),)\nLOCAL_REQUIRED_MODULES := recovery-persist recovery-refresh\nendif\n\ninclude $(BUILD_EXECUTABLE)\n\n# Symlink for file_contexts\ninclude $(CLEAR_VARS)\n\nLOCAL_MODULE := file_contexts_text\nLOCAL_MODULE_TAGS := optional\nLOCAL_REQUIRED_MODULES := file_contexts.bin\nLOCAL_POST_INSTALL_CMD := \\\n    $(hide) cp -f $(PRODUCT_OUT)/obj/ETC/file_contexts.bin_intermediates/file_contexts.concat.tmp $(TARGET_RECOVERY_ROOT_OUT)/file_contexts\n\ninclude $(BUILD_PHONY_PACKAGE)\n\nifneq ($(TW_USE_TOOLBOX), true)\ninclude $(CLEAR_VARS)\n# Create busybox symlinks... gzip and gunzip are excluded because those need to link to pigz instead\nBUSYBOX_LINKS := $(shell cat external/busybox/busybox-full.links)\nexclude := tune2fs mke2fs mkdosfs mkfs.vfat gzip gunzip\n\n# Having /sbin/modprobe present on 32 bit devices with can cause a massive\n# performance problem if the kernel has CONFIG_MODULES=y\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -gt 22; echo $$?),0)\n    ifneq ($(TARGET_ARCH), arm64)\n        ifneq ($(TARGET_ARCH), x86_64)\n            exclude += modprobe\n        endif\n    endif\nendif\n\n# If busybox does not have restorecon, assume it does not have SELinux support.\n# Then, let toolbox provide 'ls' so -Z is available to list SELinux contexts.\nifeq ($(filter restorecon, $(notdir $(BUSYBOX_LINKS))),)\n    exclude += ls\nendif\n\nRECOVERY_BUSYBOX_TOOLS := $(filter-out $(exclude), $(notdir $(BUSYBOX_LINKS)))\nRECOVERY_BUSYBOX_SYMLINKS := $(addprefix $(TARGET_RECOVERY_ROOT_OUT)/sbin/, $(RECOVERY_BUSYBOX_TOOLS))\n$(RECOVERY_BUSYBOX_SYMLINKS): BUSYBOX_BINARY := busybox\n$(RECOVERY_BUSYBOX_SYMLINKS): $(LOCAL_INSTALLED_MODULE)\n\t@echo \"Symlink: $@ -> $(BUSYBOX_BINARY)\"\n\t@mkdir -p $(dir $@)\n\t@rm -rf $@\n\t$(hide) ln -sf $(BUSYBOX_BINARY) $@\n\ninclude $(CLEAR_VARS)\nLOCAL_MODULE := busybox_symlinks\nLOCAL_MODULE_TAGS := optional\nLOCAL_ADDITIONAL_DEPENDENCIES := $(RECOVERY_BUSYBOX_SYMLINKS)\nifneq (,$(filter $(PLATFORM_SDK_VERSION),16 17 18))\nALL_DEFAULT_INSTALLED_MODULES += $(RECOVERY_BUSYBOX_SYMLINKS)\nendif\ninclude $(BUILD_PHONY_PACKAGE)\nRECOVERY_BUSYBOX_SYMLINKS :=\nendif # !TW_USE_TOOLBOX\n\n# recovery-persist (system partition dynamic executable run after /data mounts)\n# ===============================\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 24; echo $$?),0)\n    include $(CLEAR_VARS)\n    LOCAL_SRC_FILES := \\\n        recovery-persist.cpp \\\n        rotate_logs.cpp\n    LOCAL_MODULE := recovery-persist\n    LOCAL_SHARED_LIBRARIES := liblog libbase\n    LOCAL_CFLAGS := -Werror\n    LOCAL_INIT_RC := recovery-persist.rc\n    include $(BUILD_EXECUTABLE)\nendif\n\n# recovery-refresh (system partition dynamic executable run at init)\n# ===============================\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 24; echo $$?),0)\n    include $(CLEAR_VARS)\n    LOCAL_SRC_FILES := \\\n        recovery-refresh.cpp \\\n        rotate_logs.cpp\n    LOCAL_MODULE := recovery-refresh\n    LOCAL_SHARED_LIBRARIES := liblog libbase\n    LOCAL_CFLAGS := -Werror\n    LOCAL_INIT_RC := recovery-refresh.rc\n    include $(BUILD_EXECUTABLE)\nendif\n\n# shared libfusesideload\n# ===============================\ninclude $(CLEAR_VARS)\nLOCAL_CLANG := true\nLOCAL_CFLAGS := -Wall -Werror -Wno-unused-parameter\nLOCAL_CFLAGS += -D_XOPEN_SOURCE -D_GNU_SOURCE\n\nLOCAL_MODULE_TAGS := optional\nLOCAL_MODULE := libfusesideload\nLOCAL_SHARED_LIBRARIES := libcutils libc\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?),0)\n    LOCAL_C_INCLUDES := $(LOCAL_PATH)/libmincrypt/includes\n    LOCAL_SHARED_LIBRARIES += libmincrypttwrp\n    LOCAL_CFLAGS += -DUSE_MINCRYPT\nelse\n    LOCAL_SHARED_LIBRARIES += libcrypto\nendif\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 23; echo $$?),0)\n    LOCAL_SRC_FILES := fuse_sideload22.cpp\n    LOCAL_CFLAGS += -DUSE_FUSE_SIDELOAD22\nelse\n    LOCAL_SRC_FILES := fuse_sideload.cpp\nendif\ninclude $(BUILD_SHARED_LIBRARY)\n\n# static libfusesideload\n# =============================== (required to fix build errors in 8.1 due to use by tests)\ninclude $(CLEAR_VARS)\nLOCAL_CLANG := true\nLOCAL_CFLAGS := -Wall -Werror -Wno-unused-parameter\nLOCAL_CFLAGS += -D_XOPEN_SOURCE -D_GNU_SOURCE\n\nLOCAL_MODULE_TAGS := optional\nLOCAL_MODULE := libfusesideload\nLOCAL_SHARED_LIBRARIES := libcutils libc\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?),0)\n    LOCAL_C_INCLUDES := $(LOCAL_PATH)/libmincrypt/includes\n    LOCAL_STATIC_LIBRARIES += libmincrypttwrp\n    LOCAL_CFLAGS += -DUSE_MINCRYPT\nelse\n    LOCAL_STATIC_LIBRARIES += libcrypto_static\nendif\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 23; echo $$?),0)\n    LOCAL_SRC_FILES := fuse_sideload22.cpp\n    LOCAL_CFLAGS += -DUSE_FUSE_SIDELOAD22\nelse\n    LOCAL_SRC_FILES := fuse_sideload.cpp\nendif\ninclude $(BUILD_STATIC_LIBRARY)\n\n# libmounts (static library)\n# ===============================\ninclude $(CLEAR_VARS)\nLOCAL_SRC_FILES := mounts.cpp\nLOCAL_CFLAGS := \\\n    -Wall \\\n    -Werror\nLOCAL_MODULE := libmounts\nLOCAL_STATIC_LIBRARIES := libbase\ninclude $(BUILD_STATIC_LIBRARY)\n\n# librecovery (static library)\n# ===============================\ninclude $(CLEAR_VARS)\nLOCAL_SRC_FILES := \\\n    install.cpp\nLOCAL_CFLAGS := -Wall -Werror\nLOCAL_CFLAGS += -DRECOVERY_API_VERSION=$(RECOVERY_API_VERSION)\n\nifeq ($(AB_OTA_UPDATER),true)\n    LOCAL_CFLAGS += -DAB_OTA_UPDATER=1\nendif\n\nLOCAL_MODULE := librecovery\nLOCAL_STATIC_LIBRARIES := \\\n    libminui \\\n    libotautil \\\n    libvintf_recovery \\\n    libcrypto_utils \\\n    libcrypto \\\n    libbase \\\n    libziparchive \\\n\ninclude $(BUILD_STATIC_LIBRARY)\n\n# shared libaosprecovery for Apache code\n# ===============================\ninclude $(CLEAR_VARS)\n\n\nLOCAL_MODULE := libaosprecovery\nLOCAL_MODULE_TAGS := eng optional\nLOCAL_CFLAGS := -std=gnu++0x\nLOCAL_SRC_FILES := adb_install.cpp legacy_property_service.cpp set_metadata.cpp tw_atomic.cpp installcommand.cpp zipwrap.cpp\nLOCAL_SHARED_LIBRARIES += libc liblog libcutils libmtdutils libfusesideload libselinux libminzip\nLOCAL_CFLAGS += -DRECOVERY_API_VERSION=$(RECOVERY_API_VERSION)\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 23; echo $$?),0)\n    LOCAL_SHARED_LIBRARIES += libstdc++ libstlport\n    LOCAL_C_INCLUDES += bionic external/stlport/stlport\n    LOCAL_CFLAGS += -DUSE_FUSE_SIDELOAD22\nelse\n    LOCAL_SHARED_LIBRARIES += libc++\nendif\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?),0)\n    LOCAL_SHARED_LIBRARIES += libmincrypttwrp\n    LOCAL_C_INCLUDES += $(LOCAL_PATH)/libmincrypt/includes\n    LOCAL_SRC_FILES += verifier24/verifier.cpp verifier24/asn1_decoder.cpp\n    LOCAL_CFLAGS += -DUSE_OLD_VERIFIER\nelse\n    LOCAL_SHARED_LIBRARIES += libcrypto libbase\n    LOCAL_SRC_FILES += verifier.cpp asn1_decoder.cpp\n    LOCAL_C_INCLUDES += $(LOCAL_PATH)/otautil/include\nendif\n\nifeq ($(AB_OTA_UPDATER),true)\n    LOCAL_CFLAGS += -DAB_OTA_UPDATER=1\nendif\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 26; echo $$?),0)\n    LOCAL_SRC_FILES += otautil/ZipUtil.cpp otautil/SysUtil.cpp otautil/DirUtil.cpp\n    LOCAL_SHARED_LIBRARIES += libziparchive libext4_utils libcrypto libcrypto_utils\n    LOCAL_STATIC_LIBRARIES += libvintf_recovery libfs_mgr liblogwrap libavb libvintf libtinyxml2 libz\n    LOCAL_C_INCLUDES += $(LOCAL_PATH)/otautil/include\n    ifeq ($(shell test $(PLATFORM_SDK_VERSION) -gt 27; echo $$?),0)\n        # Android 9.0 needs c++17 for libvintf\n        LOCAL_CPPFLAGS += -std=c++17\n        # Android 9.0's libvintf also needs this library\n        LOCAL_STATIC_LIBRARIES += libhidl-gen-utils\n    endif\nelse\n    LOCAL_CFLAGS += -DUSE_MINZIP\nendif\n\ninclude $(BUILD_SHARED_LIBRARY)\n# libverifier (static library)\n# ===============================\ninclude $(CLEAR_VARS)\nLOCAL_CLANG := true\nLOCAL_MODULE := libverifier\nLOCAL_SRC_FILES := \\\n    asn1_decoder.cpp \\\n    verifier.cpp\nLOCAL_STATIC_LIBRARIES := \\\n    libotautil \\\n    libcrypto_utils \\\n    libcrypto \\\n    libbase\nLOCAL_CFLAGS := -Wall -Werror\ninclude $(BUILD_STATIC_LIBRARY)\n\n# Wear default device\n# ===============================\ninclude $(CLEAR_VARS)\nLOCAL_SRC_FILES := wear_device.cpp\nLOCAL_CFLAGS := -Wall -Werror\n\n# Should match TARGET_RECOVERY_UI_LIB in BoardConfig.mk.\nLOCAL_MODULE := librecovery_ui_wear\n\ninclude $(BUILD_STATIC_LIBRARY)\n\n# vr headset default device\n# ===============================\ninclude $(CLEAR_VARS)\n\nLOCAL_SRC_FILES := vr_device.cpp\nLOCAL_CFLAGS := -Wall -Werror\n\n# should match TARGET_RECOVERY_UI_LIB set in BoardConfig.mk\nLOCAL_MODULE := librecovery_ui_vr\n\ninclude $(BUILD_STATIC_LIBRARY)\n\ncommands_recovery_local_path := $(LOCAL_PATH)\n\n#    $(LOCAL_PATH)/edify/Android.mk\n#    $(LOCAL_PATH)/otafault/Android.mk\n#    $(LOCAL_PATH)/bootloader_message/Android.mk\ninclude \\\n    $(commands_TWRP_local_path)/boot_control/Android.mk \\\n    $(commands_TWRP_local_path)/tests/Android.mk \\\n    $(commands_TWRP_local_path)/tools/Android.mk \\\n    $(commands_TWRP_local_path)/updater/Android.mk \\\n    $(commands_TWRP_local_path)/update_verifier/Android.mk \\\n    $(commands_TWRP_local_path)/bootloader_message_twrp/Android.mk\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -le 25; echo $$?),0)\ninclude $(commands_TWRP_local_path)/bootloader_message/Android.mk\nendif\n\nifeq ($(wildcard system/core/uncrypt/Android.mk),)\n    #include $(commands_TWRP_local_path)/uncrypt/Android.mk\nendif\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -gt 22; echo $$?),0)\n    ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 26; echo $$?),0)\n        TARGET_GLOBAL_CFLAGS += -DTW_USE_MINUI_WITH_DATA\n        CLANG_TARGET_GLOBAL_CFLAGS += -DTW_USE_MINUI_WITH_DATA\n    endif\n    include $(commands_TWRP_local_path)/minadbd/Android.mk \\\n        $(commands_TWRP_local_path)/minui/Android.mk\nelse\n    TARGET_GLOBAL_CFLAGS += -DTW_USE_MINUI_21\n    include $(commands_TWRP_local_path)/minadbd21/Android.mk \\\n        $(commands_TWRP_local_path)/minui21/Android.mk\nendif\n\n#$(commands_TWRP_local_path)/otautil/Android.mk\n#includes for TWRP\ninclude $(commands_TWRP_local_path)/injecttwrp/Android.mk \\\n    $(commands_TWRP_local_path)/htcdumlock/Android.mk \\\n    $(commands_TWRP_local_path)/gui/Android.mk \\\n    $(commands_TWRP_local_path)/mmcutils/Android.mk \\\n    $(commands_TWRP_local_path)/bmlutils/Android.mk \\\n    $(commands_TWRP_local_path)/prebuilt/Android.mk \\\n    $(commands_TWRP_local_path)/mtdutils/Android.mk \\\n    $(commands_TWRP_local_path)/flashutils/Android.mk \\\n    $(commands_TWRP_local_path)/pigz/Android.mk \\\n    $(commands_TWRP_local_path)/libtar/Android.mk \\\n    $(commands_TWRP_local_path)/libcrecovery/Android.mk \\\n    $(commands_TWRP_local_path)/libblkid/Android.mk \\\n    $(commands_TWRP_local_path)/minuitwrp/Android.mk \\\n    $(commands_TWRP_local_path)/openaes/Android.mk \\\n    $(commands_TWRP_local_path)/toolbox/Android.mk \\\n    $(commands_TWRP_local_path)/twrpTarMain/Android.mk \\\n    $(commands_TWRP_local_path)/mtp/Android.mk \\\n    $(commands_TWRP_local_path)/minzip/Android.mk \\\n    $(commands_TWRP_local_path)/dosfstools/Android.mk \\\n    $(commands_TWRP_local_path)/etc/Android.mk \\\n    $(commands_TWRP_local_path)/toybox/Android.mk \\\n    $(commands_TWRP_local_path)/simg2img/Android.mk \\\n    $(commands_TWRP_local_path)/adbbu/Android.mk \\\n    $(commands_TWRP_local_path)/libpixelflinger/Android.mk \\\n    $(commands_TWRP_local_path)/twrpDigest/Android.mk \\\n    $(commands_TWRP_local_path)/attr/Android.mk\n\nifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?),0)\n    include $(commands_TWRP_local_path)/libmincrypt/Android.mk\nendif\n\nifeq ($(TW_INCLUDE_CRYPTO), true)\n    include $(commands_TWRP_local_path)/crypto/lollipop/Android.mk\n    include $(commands_TWRP_local_path)/crypto/scrypt/Android.mk\n    ifeq ($(TW_INCLUDE_CRYPTO_FBE), true)\n        include $(commands_TWRP_local_path)/crypto/ext4crypt/Android.mk\n    endif\n    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),)\n    ifneq ($(TW_CRYPTO_USE_SYSTEM_VOLD),false)\n        include $(commands_TWRP_local_path)/crypto/vold_decrypt/Android.mk\n    endif\n    endif\n    include $(commands_TWRP_local_path)/gpt/Android.mk\nendif\nifeq ($(BUILD_ID), GINGERBREAD)\n    TW_NO_EXFAT := true\nendif\nifneq ($(TW_NO_EXFAT), true)\n    include $(commands_TWRP_local_path)/exfat/mkfs/Android.mk \\\n            $(commands_TWRP_local_path)/exfat/fsck/Android.mk \\\n            $(commands_TWRP_local_path)/fuse/Android.mk \\\n            $(commands_TWRP_local_path)/exfat/libexfat/Android.mk\n    ifneq ($(TW_NO_EXFAT_FUSE), true)\n        include $(commands_TWRP_local_path)/exfat/fuse/Android.mk\n    endif\nendif\nifneq ($(TW_OEM_BUILD),true)\n    include $(commands_TWRP_local_path)/orscmd/Android.mk\nendif\n\n# FB2PNG\nifeq ($(TW_INCLUDE_FB2PNG), true)\n    include $(commands_TWRP_local_path)/fb2png/Android.mk\nendif\n\nendif\n\ncommands_TWRP_local_path :=\n"
        },
        {
          "name": "CleanSpec.mk",
          "type": "blob",
          "size": 2.361328125,
          "content": "# Copyright (C) 2007 The Android Open Source Project\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n# If you don't need to do a full clean build but would like to touch\n# a file or delete some intermediate files, add a clean step to the end\n# of the list.  These steps will only be run once, if they haven't been\n# run before.\n#\n# E.g.:\n#     $(call add-clean-step, touch -c external/sqlite/sqlite3.h)\n#     $(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libz_intermediates)\n#\n# Always use \"touch -c\" and \"rm -f\" or \"rm -rf\" to gracefully deal with\n# files that are missing or have been moved.\n#\n# Use $(PRODUCT_OUT) to get to the \"out/target/product/blah/\" directory.\n# Use $(OUT_DIR) to refer to the \"out\" directory.\n#\n# If you need to re-do something that's already mentioned, just copy\n# the command and add it to the bottom of the list.  E.g., if a change\n# that you made last week required touching a file and a change you\n# made today requires touching the same file, just copy the old\n# touch step and add it to the end of the list.\n#\n# ************************************************\n# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST\n# ************************************************\n\n# For example:\n#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/APPS/AndroidTests_intermediates)\n#$(call add-clean-step, rm -rf $(OUT_DIR)/target/common/obj/JAVA_LIBRARIES/core_intermediates)\n#$(call add-clean-step, find $(OUT_DIR) -type f -name \"IGTalkSession*\" -print0 | xargs -0 rm -f)\n#$(call add-clean-step, rm -rf $(PRODUCT_OUT)/data/*)\n\n# ************************************************\n# NEWER CLEAN STEPS MUST BE AT THE END OF THE LIST\n# ************************************************\n$(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/EXECUTABLES/recovery_intermediates)\n$(call add-clean-step, rm -rf $(PRODUCT_OUT)/obj/STATIC_LIBRARIES/libminui_intermediates/import_includes)\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 32.265625,
          "content": "\n    Copyright (c) 2011-2016, Dees_Troy, bigbiff, Team Win\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n"
        },
        {
          "name": "OWNERS",
          "type": "blob",
          "size": 0.0498046875,
          "content": "enh@google.com\ntbao@google.com\nxunchang@google.com\n"
        },
        {
          "name": "PREUPLOAD.cfg",
          "type": "blob",
          "size": 0.166015625,
          "content": "[Builtin Hooks]\nclang_format = true\n\n[Builtin Hooks Options]\n# Handle native codes only.\nclang_format = --commit ${PREUPLOAD_COMMIT} --style file --extensions c,h,cc,cpp\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.1396484375,
          "content": "**Team Win Recovery Project (TWRP)**\n\nYou can find a compiling guide [here](http://forum.xda-developers.com/showthread.php?t=1943625 \"Guide\").\n"
        },
        {
          "name": "adb_install.cpp",
          "type": "blob",
          "size": 5.9609375,
          "content": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"adb_install.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"ui.h\"\n#include \"cutils/properties.h\"\n\n#include \"common.h\"\n#include \"fuse_sideload.h\"\n#ifdef USE_OLD_VERIFIER\n#include \"verifier24/verifier.h\"\n#else\n#include \"verifier.h\"\n#endif\n\nstatic void set_usb_driver(bool enabled) {\n  char configfs[PROPERTY_VALUE_MAX];\n  property_get(\"sys.usb.configfs\", configfs, \"false\");\n  if (strcmp(configfs, \"false\") == 0 || strcmp(configfs, \"0\") == 0)\n    return;\n\n  int fd = open(\"/sys/class/android_usb/android0/enable\", O_WRONLY);\n  if (fd < 0) {\n/*  These error messages show when built in older Android branches (e.g. Gingerbread)\n    It's not a critical error so we're disabling the error messages.\n    ui->Print(\"failed to open driver control: %s\\n\", strerror(errno));\n*/\n    printf(\"failed to open driver control: %s\\n\", strerror(errno));\n    return;\n  }\n\n  if (TEMP_FAILURE_RETRY(write(fd, enabled ? \"1\" : \"0\", 1)) == -1) {\n/*\n    ui->Print(\"failed to set driver control: %s\\n\", strerror(errno));\n*/\n    printf(\"failed to set driver control: %s\\n\", strerror(errno));\n  }\n  if (close(fd) < 0) {\n/*\n    ui->Print(\"failed to close driver control: %s\\n\", strerror(errno));\n*/\n    printf(\"failed to close driver control: %s\\n\", strerror(errno));\n  }\n}\n\n// On Android 8.0 for some reason init can't seem to completely stop adbd\n// so we have to kill it too if it doesn't die on its own.\nstatic void kill_adbd() {\n  DIR* dir = opendir(\"/proc\");\n  if (dir) {\n    struct dirent* de = 0;\n\n    while ((de = readdir(dir)) != 0) {\n      if (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\n        continue;\n\n      int pid = -1;\n      int ret = sscanf(de->d_name, \"%d\", &pid);\n\n      if (ret == 1) {\n        char cmdpath[PATH_MAX];\n        sprintf(cmdpath, \"/proc/%d/cmdline\", pid);\n\n        FILE* file = fopen(cmdpath, \"r\");\n        size_t task_size = PATH_MAX;\n        char task[PATH_MAX];\n        char* p = task;\n        if (getline(&p, &task_size, file) > 0) {\n          if (strstr(task, \"adbd\") != 0) {\n            printf(\"adbd pid %d found, sending kill.\\n\", pid);\n            kill(pid, SIGINT);\n            usleep(5000);\n            kill(pid, SIGKILL);\n          }\n        }\n        fclose(file);\n      }\n    }\n    closedir(dir);\n  }\n}\n\nstatic void stop_adbd() {\n  printf(\"Stopping adbd...\\n\");\n  property_set(\"ctl.stop\", \"adbd\");\n  usleep(5000);\n  kill_adbd();\n  set_usb_driver(false);\n}\n\nstatic bool is_ro_debuggable() {\n  char value[PROPERTY_VALUE_MAX+1];\n  return (property_get(\"ro.debuggable\", value, NULL) == 1 && value[0] == '1');\n}\n\nstatic void maybe_restart_adbd() {\n  if (is_ro_debuggable()) {\n    printf(\"Restarting adbd...\\n\");\n    set_usb_driver(true);\n    property_set(\"ctl.start\", \"adbd\");\n  }\n}\n\n// How long (in seconds) we wait for the host to start sending us a\n// package, before timing out.\n#define ADB_INSTALL_TIMEOUT 300\n\nint\napply_from_adb(const char* install_file, pid_t* child_pid) {\n\n  stop_adbd();\n  set_usb_driver(true);\n/*\nint apply_from_adb(RecoveryUI* ui, bool* wipe_cache, const char* install_file) {\n  modified_flash = true;\n\n  stop_adbd(ui);\n  set_usb_driver(ui, true);\n\n  ui->Print(\"\\n\\nNow send the package you want to apply\\n\"\n            \"to the device with \\\"adb sideload <filename>\\\"...\\n\");\n*/\n  pid_t child;\n  if ((child = fork()) == 0) {\n    execl(\"/sbin/recovery\", \"recovery\", \"--adbd\", install_file, NULL);\n    _exit(-1);\n  }\n\n  *child_pid = child;\n  // caller can now kill the child thread from another thread\n\n  // FUSE_SIDELOAD_HOST_PATHNAME will start to exist once the host\n  // connects and starts serving a package.  Poll for its\n  // appearance.  (Note that inotify doesn't work with FUSE.)\n  int result = INSTALL_ERROR;\n  int status;\n  bool waited = false;\n  struct stat st;\n  for (int i = 0; i < ADB_INSTALL_TIMEOUT; ++i) {\n    if (waitpid(child, &status, WNOHANG) != 0) {\n      result = -1;\n      waited = true;\n      break;\n    }\n\n    if (stat(FUSE_SIDELOAD_HOST_PATHNAME, &st) != 0) {\n      if (errno == ENOENT && i < ADB_INSTALL_TIMEOUT-1) {\n        sleep(1);\n        continue;\n      } else {\n        printf(\"\\nTimed out waiting for package: %s\\n\\n\", strerror(errno));\n        result = -1;\n        kill(child, SIGKILL);\n        break;\n      }\n    }\n    // Install is handled elsewhere in TWRP\n    //install_package(FUSE_SIDELOAD_HOST_PATHNAME, wipe_cache, install_file, false);\n    return 0;\n  }\n\n  // if we got here, something failed\n  *child_pid = 0;\n\n  if (!waited) {\n    // Calling stat() on this magic filename signals the minadbd\n    // subprocess to shut down.\n    stat(FUSE_SIDELOAD_HOST_EXIT_PATHNAME, &st);\n\n    // TODO(dougz): there should be a way to cancel waiting for a\n    // package (by pushing some button combo on the device).  For now\n    // you just have to 'adb sideload' a file that's not a valid\n    // package, like \"/dev/null\".\n    waitpid(child, &status, 0);\n  }\n\n  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n    if (WEXITSTATUS(status) == 3) {\n      printf(\"\\nYou need adb 1.0.32 or newer to sideload\\nto this device.\\n\\n\");\n      result = -2;\n    } else if (!WIFSIGNALED(status)) {\n      printf(\"adbd status %d\\n\", WEXITSTATUS(status));\n    }\n  }\n\n  set_usb_driver(false);\n  maybe_restart_adbd();\n\n  return result;\n}\n"
        },
        {
          "name": "adb_install.h",
          "type": "blob",
          "size": 0.8447265625,
          "content": "/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _ADB_INSTALL_H\n#define _ADB_INSTALL_H\n\n#include <sys/types.h>\n\n//class RecoveryUI;\n\n//static void set_usb_driver(bool enabled);\n//static void maybe_restart_adbd();\nint apply_from_adb(const char* install_file, pid_t* child_pid);\n\n#endif\n"
        },
        {
          "name": "adbbu",
          "type": "tree",
          "content": null
        },
        {
          "name": "applypatch",
          "type": "tree",
          "content": null
        },
        {
          "name": "asn1_decoder.cpp",
          "type": "blob",
          "size": 3.57421875,
          "content": "/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"asn1_decoder.h\"\n\n#include <stdint.h>\n\nint asn1_context::peek_byte() const {\n  if (length_ == 0) {\n    return -1;\n  }\n  return *p_;\n}\n\nint asn1_context::get_byte() {\n  if (length_ == 0) {\n    return -1;\n  }\n\n  int byte = *p_;\n  p_++;\n  length_--;\n  return byte;\n}\n\nbool asn1_context::skip_bytes(size_t num_skip) {\n  if (length_ < num_skip) {\n    return false;\n  }\n  p_ += num_skip;\n  length_ -= num_skip;\n  return true;\n}\n\nbool asn1_context::decode_length(size_t* out_len) {\n  int num_octets = get_byte();\n  if (num_octets == -1) {\n    return false;\n  }\n  if ((num_octets & 0x80) == 0x00) {\n    *out_len = num_octets;\n    return true;\n  }\n  num_octets &= kMaskTag;\n  if (static_cast<size_t>(num_octets) >= sizeof(size_t)) {\n    return false;\n  }\n  size_t length = 0;\n  for (int i = 0; i < num_octets; ++i) {\n    int byte = get_byte();\n    if (byte == -1) {\n      return false;\n    }\n    length <<= 8;\n    length += byte;\n  }\n  *out_len = length;\n  return true;\n}\n\n/**\n * Returns the constructed type and advances the pointer. E.g. A0 -> 0\n */\nasn1_context* asn1_context::asn1_constructed_get() {\n  int type = get_byte();\n  if (type == -1 || (type & kMaskConstructed) != kTagConstructed) {\n    return nullptr;\n  }\n  size_t length;\n  if (!decode_length(&length) || length > length_) {\n    return nullptr;\n  }\n  asn1_context* app_ctx = new asn1_context(p_, length);\n  app_ctx->app_type_ = type & kMaskAppType;\n  return app_ctx;\n}\n\nbool asn1_context::asn1_constructed_skip_all() {\n  int byte = peek_byte();\n  while (byte != -1 && (byte & kMaskConstructed) == kTagConstructed) {\n    skip_bytes(1);\n    size_t length;\n    if (!decode_length(&length) || !skip_bytes(length)) {\n      return false;\n    }\n    byte = peek_byte();\n  }\n  return byte != -1;\n}\n\nint asn1_context::asn1_constructed_type() const {\n  return app_type_;\n}\n\nasn1_context* asn1_context::asn1_sequence_get() {\n  if ((get_byte() & kMaskTag) != kTagSequence) {\n    return nullptr;\n  }\n  size_t length;\n  if (!decode_length(&length) || length > length_) {\n    return nullptr;\n  }\n  return new asn1_context(p_, length);\n}\n\nasn1_context* asn1_context::asn1_set_get() {\n  if ((get_byte() & kMaskTag) != kTagSet) {\n    return nullptr;\n  }\n  size_t length;\n  if (!decode_length(&length) || length > length_) {\n    return nullptr;\n  }\n  return new asn1_context(p_, length);\n}\n\nbool asn1_context::asn1_sequence_next() {\n  size_t length;\n  if (get_byte() == -1 || !decode_length(&length) || !skip_bytes(length)) {\n    return false;\n  }\n  return true;\n}\n\nbool asn1_context::asn1_oid_get(const uint8_t** oid, size_t* length) {\n  if (get_byte() != kTagOid) {\n    return false;\n  }\n  if (!decode_length(length) || *length == 0 || *length > length_) {\n    return false;\n  }\n  *oid = p_;\n  return true;\n}\n\nbool asn1_context::asn1_octet_string_get(const uint8_t** octet_string, size_t* length) {\n  if (get_byte() != kTagOctetString) {\n    return false;\n  }\n  if (!decode_length(length) || *length == 0 || *length > length_) {\n    return false;\n  }\n  *octet_string = p_;\n  return true;\n}\n"
        },
        {
          "name": "asn1_decoder.h",
          "type": "blob",
          "size": 1.6943359375,
          "content": "/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ASN1_DECODER_H_\n#define ASN1_DECODER_H_\n\n#include <stdint.h>\n\nclass asn1_context {\n public:\n  asn1_context(const uint8_t* buffer, size_t length) : p_(buffer), length_(length), app_type_(0) {}\n  int asn1_constructed_type() const;\n  asn1_context* asn1_constructed_get();\n  bool asn1_constructed_skip_all();\n  asn1_context* asn1_sequence_get();\n  asn1_context* asn1_set_get();\n  bool asn1_sequence_next();\n  bool asn1_oid_get(const uint8_t** oid, size_t* length);\n  bool asn1_octet_string_get(const uint8_t** octet_string, size_t* length);\n\n private:\n  static constexpr int kMaskConstructed = 0xE0;\n  static constexpr int kMaskTag = 0x7F;\n  static constexpr int kMaskAppType = 0x1F;\n\n  static constexpr int kTagOctetString = 0x04;\n  static constexpr int kTagOid = 0x06;\n  static constexpr int kTagSequence = 0x30;\n  static constexpr int kTagSet = 0x31;\n  static constexpr int kTagConstructed = 0xA0;\n\n  int peek_byte() const;\n  int get_byte();\n  bool skip_bytes(size_t num_skip);\n  bool decode_length(size_t* out_len);\n\n  const uint8_t* p_;\n  size_t length_;\n  int app_type_;\n};\n\n#endif /* ASN1_DECODER_H_ */\n"
        },
        {
          "name": "attr",
          "type": "tree",
          "content": null
        },
        {
          "name": "bmlutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "boot_control",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootloader.h",
          "type": "blob",
          "size": 0.7568359375,
          "content": "/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO: Remove this file once we remove all places that include this file.\n#include \"bootloader_message/include/bootloader_message/bootloader_message.h\"\n"
        },
        {
          "name": "bootloader_message",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootloader_message_twrp",
          "type": "tree",
          "content": null
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 1.91015625,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_COMMON_H\n#define RECOVERY_COMMON_H\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <string>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define LOGE(...) fprintf(stdout, \"E:\" __VA_ARGS__)\n#define LOGW(...) fprintf(stdout, \"W:\" __VA_ARGS__)\n#define LOGI(...) fprintf(stdout, \"I:\" __VA_ARGS__)\n\n#if 0\n#define LOGV(...) fprintf(stdout, \"V:\" __VA_ARGS__)\n#define LOGD(...) fprintf(stdout, \"D:\" __VA_ARGS__)\n#else\n#define LOGV(...) do {} while (0)\n#define LOGD(...) do {} while (0)\n#endif\n\n#define STRINGIFY(x) #x\n#define EXPAND(x) STRINGIFY(x)\n\n// Not using the command-line defined macro here because this header could be included by\n// device-specific recovery libraries. We static assert the value consistency in recovery.cpp.\n//static constexpr int kRecoveryApiVersion = 3;\n\nclass RecoveryUI;\n\nextern RecoveryUI* ui;\nextern bool modified_flash;\n//typedef struct fstab_rec Volume;\n\n// The current stage, e.g. \"1/2\".\nextern std::string stage;\n\n// The reason argument provided in \"--reason=\".\nextern const char* reason;\n\n// fopen a file, mounting volumes and making parent dirs as necessary.\nFILE* fopen_path(const char *path, const char *mode);\n\nvoid ui_print(const char* format, ...);\n\n//static bool is_ro_debuggable();\n\n#ifdef __cplusplus\n}\n#endif\n\nbool reboot(const std::string& command);\n\n#endif  // RECOVERY_COMMON_H\n"
        },
        {
          "name": "crypto",
          "type": "tree",
          "content": null
        },
        {
          "name": "data.cpp",
          "type": "blob",
          "size": 31.046875,
          "content": "/*\n\tCopyright 2012 to 2016 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <pthread.h>\n#include <time.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cctype>\n#include <cutils/properties.h>\n#include <unistd.h>\n\n#include \"variables.h\"\n#include \"data.hpp\"\n#include \"partitions.hpp\"\n#include \"twrp-functions.hpp\"\n#ifndef TW_NO_SCREEN_TIMEOUT\n#include \"gui/blanktimer.hpp\"\n#endif\n#include \"find_file.hpp\"\n#include \"set_metadata.h\"\n#include \"gui/gui.hpp\"\n#include \"infomanager.hpp\"\n\n#define DEVID_MAX 64\n#define HWID_MAX 32\n\nextern \"C\"\n{\n\t#include \"twcommon.h\"\n\t#include \"gui/pages.h\"\n\tvoid gui_notifyVarChange(const char *name, const char* value);\n}\n#include \"minuitwrp/minui.h\"\n\n#define FILE_VERSION 0x00010010 // Do not set to 0\n\nusing namespace std;\n\nstring                                  DataManager::mBackingFile;\nint                                     DataManager::mInitialized = 0;\nInfoManager                             DataManager::mPersist;  // Data that that is not constant and will be saved to the settings file\nInfoManager                             DataManager::mData;     // Data that is not constant and will not be saved to settings file\nInfoManager                             DataManager::mConst;    // Data that is constant and will not be saved to settings file\n\nextern bool datamedia;\n\n#ifndef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP\npthread_mutex_t DataManager::m_valuesLock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;\n#else\npthread_mutex_t DataManager::m_valuesLock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n#endif\n\n// Device ID functions\nvoid DataManager::sanitize_device_id(char* device_id) {\n\tconst char* whitelist =\"-._\";\n\tchar str[DEVID_MAX];\n\tchar* c = str;\n\n\tsnprintf(str, DEVID_MAX, \"%s\", device_id);\n\tmemset(device_id, 0, strlen(device_id));\n\twhile (*c) {\n\t\tif (isalnum(*c) || strchr(whitelist, *c))\n\t\t\tstrncat(device_id, c, 1);\n\t\tc++;\n\t}\n\treturn;\n}\n\n#define CMDLINE_SERIALNO\t\t\"androidboot.serialno=\"\n#define CMDLINE_SERIALNO_LEN\t(strlen(CMDLINE_SERIALNO))\n#define CPUINFO_SERIALNO\t\t\"Serial\"\n#define CPUINFO_SERIALNO_LEN\t(strlen(CPUINFO_SERIALNO))\n#define CPUINFO_HARDWARE\t\t\"Hardware\"\n#define CPUINFO_HARDWARE_LEN\t(strlen(CPUINFO_HARDWARE))\n\nvoid DataManager::get_device_id(void) {\n\tFILE *fp;\n\tchar line[2048];\n\tchar hardware_id[HWID_MAX] = { 0 };\n\tchar device_id[DEVID_MAX] = { 0 };\n\tchar* token;\n\n#ifdef TW_USE_MODEL_HARDWARE_ID_FOR_DEVICE_ID\n\t// Use (product_model)_(hardware_id) as device id\n\tchar model_id[PROPERTY_VALUE_MAX];\n\tproperty_get(\"ro.product.model\", model_id, \"error\");\n\tif (strcmp(model_id, \"error\") != 0) {\n\t\tLOGINFO(\"=> product model: '%s'\\n\", model_id);\n\t\t// Replace spaces with underscores\n\t\tfor (size_t i = 0; i < strlen(model_id); i++) {\n\t\t\tif (model_id[i] == ' ')\n\t\t\t\tmodel_id[i] = '_';\n\t\t}\n\t\tsnprintf(device_id, DEVID_MAX, \"%s\", model_id);\n\n\t\tif (strlen(device_id) < DEVID_MAX) {\n\t\t\tfp = fopen(\"proc_cpuinfo.txt\", \"rt\");\n\t\t\tif (fp != NULL) {\n\t\t\t\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\t\t\t\tif (memcmp(line, CPUINFO_HARDWARE,\n\t\t\t\t\t\t\tCPUINFO_HARDWARE_LEN) == 0) {\n\t\t\t\t\t\t// skip past \"Hardware\", spaces, and colon\n\t\t\t\t\t\ttoken = line + CPUINFO_HARDWARE_LEN;\n\t\t\t\t\t\twhile (*token && (!isgraph(*token) || *token == ':'))\n\t\t\t\t\t\t\ttoken++;\n\n\t\t\t\t\t\tif (*token && *token != '\\n'\n\t\t\t\t\t\t\t\t&& strcmp(\"UNKNOWN\\n\", token)) {\n\t\t\t\t\t\t\tsnprintf(hardware_id, HWID_MAX, \"%s\", token);\n\t\t\t\t\t\t\tif (hardware_id[strlen(hardware_id)-1] == '\\n')\n\t\t\t\t\t\t\t\thardware_id[strlen(hardware_id)-1] = 0;\n\t\t\t\t\t\t\tLOGINFO(\"=> hardware id from cpuinfo: '%s'\\n\",\n\t\t\t\t\t\t\t\t\thardware_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t}\n\n\t\tif (hardware_id[0] != 0)\n\t\t\tsnprintf(device_id, DEVID_MAX, \"%s_%s\", model_id, hardware_id);\n\n\t\tsanitize_device_id(device_id);\n\t\tmConst.SetValue(\"device_id\", device_id);\n\t\tLOGINFO(\"=> using device id: '%s'\\n\", device_id);\n\t\treturn;\n\t}\n#endif\n\n#ifndef TW_FORCE_CPUINFO_FOR_DEVICE_ID\n\t// Check the cmdline to see if the serial number was supplied\n\tfp = fopen(\"/proc/cmdline\", \"rt\");\n\tif (fp != NULL) {\n\t\tfgets(line, sizeof(line), fp);\n\t\tfclose(fp); // cmdline is only one line long\n\n\t\ttoken = strtok(line, \" \");\n\t\twhile (token) {\n\t\t\tif (memcmp(token, CMDLINE_SERIALNO, CMDLINE_SERIALNO_LEN) == 0) {\n\t\t\t\ttoken += CMDLINE_SERIALNO_LEN;\n\t\t\t\tsnprintf(device_id, DEVID_MAX, \"%s\", token);\n\t\t\t\tsanitize_device_id(device_id); // also removes newlines\n\t\t\t\tmConst.SetValue(\"device_id\", device_id);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttoken = strtok(NULL, \" \");\n\t\t}\n\t}\n#endif\n\t// Check cpuinfo for serial number; if found, use as device_id\n\t// If serial number is not found, fallback to hardware_id for the device_id\n\tfp = fopen(\"/proc/cpuinfo\", \"rt\");\n\tif (fp != NULL) {\n\t\twhile (fgets(line, sizeof(line), fp) != NULL) {\n\t\t\tif (memcmp(line, CPUINFO_SERIALNO, CPUINFO_SERIALNO_LEN) == 0) {\n\t\t\t\t// skip past \"Serial\", spaces, and colon\n\t\t\t\ttoken = line + CPUINFO_SERIALNO_LEN;\n\t\t\t\twhile (*token && (!isgraph(*token) || *token == ':'))\n\t\t\t\t\ttoken++;\n\n\t\t\t\tif (*token && *token != '\\n') {\n\t\t\t\t\tsnprintf(device_id, DEVID_MAX, \"%s\", token);\n\t\t\t\t\tsanitize_device_id(device_id); // also removes newlines\n\t\t\t\t\tLOGINFO(\"=> serial from cpuinfo: '%s'\\n\", device_id);\n\t\t\t\t\tmConst.SetValue(\"device_id\", device_id);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (memcmp(line, CPUINFO_HARDWARE,\n\t\t\t\t\tCPUINFO_HARDWARE_LEN) == 0) {\n\t\t\t\t// skip past \"Hardware\", spaces, and colon\n\t\t\t\ttoken = line + CPUINFO_HARDWARE_LEN;\n\t\t\t\twhile (*token && (!isgraph(*token) || *token == ':'))\n\t\t\t\t\ttoken++;\n\n\t\t\t\tif (*token && *token != '\\n') {\n\t\t\t\t\tsnprintf(hardware_id, HWID_MAX, \"%s\", token);\n\t\t\t\t\tif (hardware_id[strlen(hardware_id)-1] == '\\n')\n\t\t\t\t\t\thardware_id[strlen(hardware_id)-1] = 0;\n\t\t\t\t\tLOGINFO(\"=> hardware id from cpuinfo: '%s'\\n\", hardware_id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t}\n\n\tif (hardware_id[0] != 0) {\n\t\tLOGINFO(\"\\nusing hardware id for device id: '%s'\\n\", hardware_id);\n\t\tsnprintf(device_id, DEVID_MAX, \"%s\", hardware_id);\n\t\tsanitize_device_id(device_id);\n\t\tmConst.SetValue(\"device_id\", device_id);\n\t\treturn;\n\t}\n\n\tstrcpy(device_id, \"serialno\");\n\tLOGINFO(\"=> device id not found, using '%s'\\n\", device_id);\n\tmConst.SetValue(\"device_id\", device_id);\n\treturn;\n}\n\nint DataManager::ResetDefaults()\n{\n\tpthread_mutex_lock(&m_valuesLock);\n\tmPersist.Clear();\n\tmData.Clear();\n\tmConst.Clear();\n\tpthread_mutex_unlock(&m_valuesLock);\n\n\tSetDefaultValues();\n\treturn 0;\n}\n\nint DataManager::LoadValues(const string& filename)\n{\n\tstring dev_id;\n\n\tif (!mInitialized)\n\t\tSetDefaultValues();\n\n\tGetValue(\"device_id\", dev_id);\n\t// Save off the backing file for set operations\n\tmBackingFile = filename;\n\tmPersist.SetFile(filename);\n\tmPersist.SetFileVersion(FILE_VERSION);\n\n\t// Read in the file, if possible\n\tpthread_mutex_lock(&m_valuesLock);\n\tmPersist.LoadValues();\n\n#ifndef TW_NO_SCREEN_TIMEOUT\n\tblankTimer.setTime(mPersist.GetIntValue(\"tw_screen_timeout_secs\"));\n#endif\n\n\tpthread_mutex_unlock(&m_valuesLock);\n\tstring current = GetCurrentStoragePath();\n\tTWPartition* Part = PartitionManager.Find_Partition_By_Path(current);\n\tif (!Part)\n\t\tPart = PartitionManager.Get_Default_Storage_Partition();\n\tif (Part && current != Part->Storage_Path && Part->Mount(false)) {\n\t\tLOGINFO(\"LoadValues setting storage path to '%s'\\n\", Part->Storage_Path.c_str());\n\t\tSetValue(\"tw_storage_path\", Part->Storage_Path);\n\t} else {\n\t\tSetBackupFolder();\n\t}\n\treturn 0;\n}\n\nint DataManager::LoadPersistValues(void)\n{\n\tstatic bool loaded = false;\n\tstring dev_id;\n\n\t// Only run this function once, and make sure normal settings file has not yet been read\n\tif (loaded || !mBackingFile.empty() || !TWFunc::Path_Exists(PERSIST_SETTINGS_FILE))\n\t\treturn -1;\n\n\tLOGINFO(\"Attempt to load settings from /persist settings file...\\n\");\n\n\tif (!mInitialized)\n\t\tSetDefaultValues();\n\n\tGetValue(\"device_id\", dev_id);\n\tmPersist.SetFile(PERSIST_SETTINGS_FILE);\n\tmPersist.SetFileVersion(FILE_VERSION);\n\n\t// Read in the file, if possible\n\tpthread_mutex_lock(&m_valuesLock);\n\tmPersist.LoadValues();\n\n#ifndef TW_NO_SCREEN_TIMEOUT\n\tblankTimer.setTime(mPersist.GetIntValue(\"tw_screen_timeout_secs\"));\n#endif\n\n\tupdate_tz_environment_variables();\n\tTWFunc::Set_Brightness(GetStrValue(\"tw_brightness\"));\n\n\tpthread_mutex_unlock(&m_valuesLock);\n\n\t/* Don't set storage nor backup paths this early */\n\n\tloaded = true;\n\n\treturn 0;\n}\n\nint DataManager::Flush()\n{\n\treturn SaveValues();\n}\n\nint DataManager::SaveValues()\n{\n#ifndef TW_OEM_BUILD\n\tif (PartitionManager.Mount_By_Path(\"/persist\", false)) {\n\t\tmPersist.SetFile(PERSIST_SETTINGS_FILE);\n\t\tmPersist.SetFileVersion(FILE_VERSION);\n\t\tpthread_mutex_lock(&m_valuesLock);\n\t\tmPersist.SaveValues();\n\t\tpthread_mutex_unlock(&m_valuesLock);\n\t\tLOGINFO(\"Saved settings file values to %s\\n\", PERSIST_SETTINGS_FILE);\n\t}\n\n\tif (mBackingFile.empty())\n\t\treturn -1;\n\n\tstring mount_path = GetSettingsStoragePath();\n\tPartitionManager.Mount_By_Path(mount_path.c_str(), 1);\n\n\tmPersist.SetFile(mBackingFile);\n\tmPersist.SetFileVersion(FILE_VERSION);\n\tpthread_mutex_lock(&m_valuesLock);\n\tmPersist.SaveValues();\n\tpthread_mutex_unlock(&m_valuesLock);\n\n\ttw_set_default_metadata(mBackingFile.c_str());\n\tLOGINFO(\"Saved settings file values to '%s'\\n\", mBackingFile.c_str());\n#endif // ifdef TW_OEM_BUILD\n\treturn 0;\n}\n\nint DataManager::GetValue(const string& varName, string& value)\n{\n\tstring localStr = varName;\n\tint ret = 0;\n\n\tif (!mInitialized)\n\t\tSetDefaultValues();\n\n\t// Strip off leading and trailing '%' if provided\n\tif (localStr.length() > 2 && localStr[0] == '%' && localStr[localStr.length()-1] == '%')\n\t{\n\t\tlocalStr.erase(0, 1);\n\t\tlocalStr.erase(localStr.length() - 1, 1);\n\t}\n\n\t// Handle magic values\n\tif (GetMagicValue(localStr, value) == 0)\n\t\treturn 0;\n\n\t// Handle property\n\tif (localStr.length() > 9 && localStr.substr(0, 9) == \"property.\") {\n\t\tchar property_value[PROPERTY_VALUE_MAX];\n\t\tproperty_get(localStr.substr(9).c_str(), property_value, \"\");\n\t\tvalue = property_value;\n\t\treturn 0;\n\t}\n\n\tpthread_mutex_lock(&m_valuesLock);\n\tret = mConst.GetValue(localStr, value);\n\tif (ret == 0)\n\t\tgoto exit;\n\n\tret = mPersist.GetValue(localStr, value);\n\tif (ret == 0)\n\t\tgoto exit;\n\n\tret = mData.GetValue(localStr, value);\nexit:\n\tpthread_mutex_unlock(&m_valuesLock);\n\treturn ret;\n}\n\nint DataManager::GetValue(const string& varName, int& value)\n{\n\tstring data;\n\n\tif (GetValue(varName,data) != 0)\n\t\treturn -1;\n\n\tvalue = atoi(data.c_str());\n\treturn 0;\n}\n\nint DataManager::GetValue(const string& varName, float& value)\n{\n\tstring data;\n\n\tif (GetValue(varName,data) != 0)\n\t\treturn -1;\n\n\tvalue = atof(data.c_str());\n\treturn 0;\n}\n\nint DataManager::GetValue(const string& varName, unsigned long long& value)\n{\n\tstring data;\n\n\tif (GetValue(varName,data) != 0)\n\t\treturn -1;\n\n\tvalue = strtoull(data.c_str(), NULL, 10);\n\treturn 0;\n}\n\n// This function will return an empty string if the value doesn't exist\nstring DataManager::GetStrValue(const string& varName)\n{\n\tstring retVal;\n\n\tGetValue(varName, retVal);\n\treturn retVal;\n}\n\n// This function will return 0 if the value doesn't exist\nint DataManager::GetIntValue(const string& varName)\n{\n\tstring retVal;\n\n\tGetValue(varName, retVal);\n\treturn atoi(retVal.c_str());\n}\n\nint DataManager::SetValue(const string& varName, const string& value, const int persist /* = 0 */)\n{\n\tif (!mInitialized)\n\t\tSetDefaultValues();\n\n\t// Handle property\n\tif (varName.length() > 9 && varName.substr(0, 9) == \"property.\") {\n\t\tint ret = property_set(varName.substr(9).c_str(), value.c_str());\n\t\tif (ret)\n\t\t\tLOGERR(\"Error setting property '%s' to '%s'\\n\", varName.substr(9).c_str(), value.c_str());\n\t\treturn ret;\n\t}\n\n\t// Don't allow empty values or numerical starting values\n\tif (varName.empty() || (varName[0] >= '0' && varName[0] <= '9'))\n\t\treturn -1;\n\n\tstring test;\n\tpthread_mutex_lock(&m_valuesLock);\n\tint constChk = mConst.GetValue(varName, test);\n\tif (constChk == 0) {\n\t\tpthread_mutex_unlock(&m_valuesLock);\n\t\treturn -1;\n\t}\n\n\tif (persist) {\n\t\tmPersist.SetValue(varName, value);\n\t} else {\n\t\tint persistChk = mPersist.GetValue(varName, test);\n\t\tif (persistChk == 0) {\n\t\t\tmPersist.SetValue(varName, value);\n\t\t} else {\n\t\t\tmData.SetValue(varName, value);\n\t\t}\n\t}\n\n\tpthread_mutex_unlock(&m_valuesLock);\n\n#ifndef TW_NO_SCREEN_TIMEOUT\n\tif (varName == \"tw_screen_timeout_secs\") {\n\t\tblankTimer.setTime(atoi(value.c_str()));\n\t} else\n#endif\n\tif (varName == \"tw_storage_path\") {\n\t\tSetBackupFolder();\n\t}\n\tgui_notifyVarChange(varName.c_str(), value.c_str());\n\treturn 0;\n}\n\nint DataManager::SetValue(const string& varName, const int value, const int persist /* = 0 */)\n{\n\tostringstream valStr;\n\tvalStr << value;\n\treturn SetValue(varName, valStr.str(), persist);\n}\n\nint DataManager::SetValue(const string& varName, const float value, const int persist /* = 0 */)\n{\n\tostringstream valStr;\n\tvalStr << value;\n\treturn SetValue(varName, valStr.str(), persist);;\n}\n\nint DataManager::SetValue(const string& varName, const unsigned long long& value, const int persist /* = 0 */)\n{\n\tostringstream valStr;\n\tvalStr << value;\n\treturn SetValue(varName, valStr.str(), persist);\n}\n\nint DataManager::SetProgress(const float Fraction) {\n\treturn SetValue(\"ui_progress\", (float) (Fraction * 100.0));\n}\n\nint DataManager::ShowProgress(const float Portion, const float Seconds)\n{\n\tfloat Starting_Portion;\n\tGetValue(\"ui_progress_portion\", Starting_Portion);\n\tif (SetValue(\"ui_progress_portion\", (float)(Portion * 100.0) + Starting_Portion) != 0)\n\t\treturn -1;\n\tif (SetValue(\"ui_progress_frames\", Seconds * 30) != 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid DataManager::update_tz_environment_variables(void)\n{\n\tsetenv(\"TZ\", GetStrValue(TW_TIME_ZONE_VAR).c_str(), 1);\n\ttzset();\n}\n\nvoid DataManager::SetBackupFolder()\n{\n\tstring str = GetCurrentStoragePath();\n\tTWPartition* partition = PartitionManager.Find_Partition_By_Path(str);\n\tstr += \"/TWRP/BACKUPS/\";\n\n\tstring dev_id;\n\tGetValue(\"device_id\", dev_id);\n\n\tstr += dev_id;\n\tLOGINFO(\"Backup folder set to '%s'\\n\", str.c_str());\n\tSetValue(TW_BACKUPS_FOLDER_VAR, str, 0);\n\tif (partition != NULL) {\n\t\tSetValue(\"tw_storage_display_name\", partition->Storage_Name);\n\t\tchar free_space[255];\n\t\tsprintf(free_space, \"%llu\", partition->Free / 1024 / 1024);\n\t\tSetValue(\"tw_storage_free_size\", free_space);\n\t\tstring zip_path, zip_root, storage_path;\n\t\tGetValue(TW_ZIP_LOCATION_VAR, zip_path);\n\t\tif (partition->Has_Data_Media && !partition->Symlink_Mount_Point.empty())\n\t\t\tstorage_path = partition->Symlink_Mount_Point;\n\t\telse\n\t\t\tstorage_path = partition->Storage_Path;\n\t\tif (zip_path.size() < storage_path.size()) {\n\t\t\tSetValue(TW_ZIP_LOCATION_VAR, storage_path);\n\t\t} else {\n\t\t\tzip_root = TWFunc::Get_Root_Path(zip_path);\n\t\t\tif (zip_root != storage_path) {\n\t\t\t\tLOGINFO(\"DataManager::SetBackupFolder zip path was %s changing to %s, %s\\n\", zip_path.c_str(), storage_path.c_str(), zip_root.c_str());\n\t\t\t\tSetValue(TW_ZIP_LOCATION_VAR, storage_path);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (PartitionManager.Fstab_Processed() != 0) {\n\t\t\tLOGINFO(\"Storage partition '%s' not found\\n\", str.c_str());\n\t\t\tgui_err(\"unable_locate_storage=Unable to locate storage device.\");\n\t\t}\n\t}\n}\n\nvoid DataManager::SetDefaultValues()\n{\n\tstring str, path;\n\n\tmConst.SetConst();\n\n\tget_device_id();\n\n\tpthread_mutex_lock(&m_valuesLock);\n\n\tmInitialized = 1;\n\n\tmConst.SetValue(\"true\", \"1\");\n\tmConst.SetValue(\"false\", \"0\");\n\n\tmConst.SetValue(TW_VERSION_VAR, TW_VERSION_STR);\n\tmPersist.SetValue(\"tw_button_vibrate\", \"80\");\n\tmPersist.SetValue(\"tw_keyboard_vibrate\", \"40\");\n\tmPersist.SetValue(\"tw_action_vibrate\", \"160\");\n\n\tTWPartition *store = PartitionManager.Get_Default_Storage_Partition();\n\tif (store)\n\t\tmPersist.SetValue(\"tw_storage_path\", store->Storage_Path);\n\telse\n\t\tmPersist.SetValue(\"tw_storage_path\", \"/\");\n\n#ifdef TW_FORCE_CPUINFO_FOR_DEVICE_ID\n\tprintf(\"TW_FORCE_CPUINFO_FOR_DEVICE_ID := true\\n\");\n#endif\n\n#ifdef BOARD_HAS_NO_REAL_SDCARD\n\tprintf(\"BOARD_HAS_NO_REAL_SDCARD := true\\n\");\n\tmConst.SetValue(TW_ALLOW_PARTITION_SDCARD, \"0\");\n#else\n\tmConst.SetValue(TW_ALLOW_PARTITION_SDCARD, \"1\");\n#endif\n\n#ifdef TW_INCLUDE_DUMLOCK\n\tprintf(\"TW_INCLUDE_DUMLOCK := true\\n\");\n\tmConst.SetValue(TW_SHOW_DUMLOCK, \"1\");\n#else\n\tmConst.SetValue(TW_SHOW_DUMLOCK, \"0\");\n#endif\n\n\tstr = GetCurrentStoragePath();\n\tmPersist.SetValue(TW_ZIP_LOCATION_VAR, str);\n\tstr += \"/TWRP/BACKUPS/\";\n\n\tstring dev_id;\n\tmConst.GetValue(\"device_id\", dev_id);\n\n\tstr += dev_id;\n\tmData.SetValue(TW_BACKUPS_FOLDER_VAR, str);\n\n\tmConst.SetValue(TW_REBOOT_SYSTEM, \"1\");\n#ifdef TW_NO_REBOOT_RECOVERY\n\tprintf(\"TW_NO_REBOOT_RECOVERY := true\\n\");\n\tmConst.SetValue(TW_REBOOT_RECOVERY, \"0\");\n#else\n\tmConst.SetValue(TW_REBOOT_RECOVERY, \"1\");\n#endif\n\tmConst.SetValue(TW_REBOOT_POWEROFF, \"1\");\n#ifdef TW_NO_REBOOT_BOOTLOADER\n\tprintf(\"TW_NO_REBOOT_BOOTLOADER := true\\n\");\n\tmConst.SetValue(TW_REBOOT_BOOTLOADER, \"0\");\n#else\n\tmConst.SetValue(TW_REBOOT_BOOTLOADER, \"1\");\n#endif\n#ifdef RECOVERY_SDCARD_ON_DATA\n\tprintf(\"RECOVERY_SDCARD_ON_DATA := true\\n\");\n\tmConst.SetValue(TW_HAS_DATA_MEDIA, \"1\");\n\tdatamedia = true;\n#else\n\tmData.SetValue(TW_HAS_DATA_MEDIA, \"0\");\n#endif\n#ifdef TW_NO_BATT_PERCENT\n\tprintf(\"TW_NO_BATT_PERCENT := true\\n\");\n\tmConst.SetValue(TW_NO_BATTERY_PERCENT, \"1\");\n#else\n\tmConst.SetValue(TW_NO_BATTERY_PERCENT, \"0\");\n#endif\n#ifdef TW_NO_CPU_TEMP\n\tprintf(\"TW_NO_CPU_TEMP := true\\n\");\n\tmConst.SetValue(\"tw_no_cpu_temp\", \"1\");\n#else\n\tstring cpu_temp_file;\n#ifdef TW_CUSTOM_CPU_TEMP_PATH\n\tcpu_temp_file = EXPAND(TW_CUSTOM_CPU_TEMP_PATH);\n#else\n\tcpu_temp_file = \"/sys/class/thermal/thermal_zone0/temp\";\n#endif\n\tif (TWFunc::Path_Exists(cpu_temp_file)) {\n\t\tmConst.SetValue(\"tw_no_cpu_temp\", \"0\");\n\t} else {\n\t\tLOGINFO(\"CPU temperature file '%s' not found, disabling CPU temp.\\n\", cpu_temp_file.c_str());\n\t\tmConst.SetValue(\"tw_no_cpu_temp\", \"1\");\n\t}\n#endif\n#ifdef TW_CUSTOM_POWER_BUTTON\n\tprintf(\"TW_POWER_BUTTON := %s\\n\", EXPAND(TW_CUSTOM_POWER_BUTTON));\n\tmConst.SetValue(TW_POWER_BUTTON, EXPAND(TW_CUSTOM_POWER_BUTTON));\n#else\n\tmConst.SetValue(TW_POWER_BUTTON, \"0\");\n#endif\n#ifdef TW_ALWAYS_RMRF\n\tprintf(\"TW_ALWAYS_RMRF := true\\n\");\n\tmConst.SetValue(TW_RM_RF_VAR, \"1\");\n#endif\n#ifdef TW_NEVER_UNMOUNT_SYSTEM\n\tprintf(\"TW_NEVER_UNMOUNT_SYSTEM := true\\n\");\n\tmConst.SetValue(TW_DONT_UNMOUNT_SYSTEM, \"1\");\n#else\n\tmConst.SetValue(TW_DONT_UNMOUNT_SYSTEM, \"0\");\n#endif\n#ifdef TW_NO_USB_STORAGE\n\tprintf(\"TW_NO_USB_STORAGE := true\\n\");\n\tmConst.SetValue(TW_HAS_USB_STORAGE, \"0\");\n#else\n\tchar lun_file[255];\n\tstring Lun_File_str = CUSTOM_LUN_FILE;\n\tsize_t found = Lun_File_str.find(\"%\");\n\tif (found != string::npos) {\n\t\tsprintf(lun_file, CUSTOM_LUN_FILE, 0);\n\t\tLun_File_str = lun_file;\n\t}\n\tif (!TWFunc::Path_Exists(Lun_File_str)) {\n\t\tLOGINFO(\"Lun file '%s' does not exist, USB storage mode disabled\\n\", Lun_File_str.c_str());\n\t\tmConst.SetValue(TW_HAS_USB_STORAGE, \"0\");\n\t} else {\n\t\tLOGINFO(\"Lun file '%s'\\n\", Lun_File_str.c_str());\n\t\tmData.SetValue(TW_HAS_USB_STORAGE, \"1\");\n\t}\n#endif\n#ifdef TW_INCLUDE_INJECTTWRP\n\tprintf(\"TW_INCLUDE_INJECTTWRP := true\\n\");\n\tmConst.SetValue(TW_HAS_INJECTTWRP, \"1\");\n\tmPersist(TW_INJECT_AFTER_ZIP, \"1\");\n#else\n\tmConst.SetValue(TW_HAS_INJECTTWRP, \"0\");\n#endif\n#ifdef TW_HAS_DOWNLOAD_MODE\n\tprintf(\"TW_HAS_DOWNLOAD_MODE := true\\n\");\n\tmConst.SetValue(TW_DOWNLOAD_MODE, \"1\");\n#endif\n#ifdef TW_INCLUDE_CRYPTO\n\tmConst.SetValue(TW_HAS_CRYPTO, \"1\");\n\tprintf(\"TW_INCLUDE_CRYPTO := true\\n\");\n#endif\n#ifdef TW_SDEXT_NO_EXT4\n\tprintf(\"TW_SDEXT_NO_EXT4 := true\\n\");\n\tmConst.SetValue(TW_SDEXT_DISABLE_EXT4, \"1\");\n#else\n\tmConst.SetValue(TW_SDEXT_DISABLE_EXT4, \"0\");\n#endif\n\n#ifdef TW_HAS_NO_BOOT_PARTITION\n\tmPersist.SetValue(\"tw_backup_list\", \"/system;/data;\");\n#else\n\tmPersist.SetValue(\"tw_backup_list\", \"/system;/data;/boot;\");\n#endif\n\tmConst.SetValue(TW_MIN_SYSTEM_VAR, TW_MIN_SYSTEM_SIZE);\n\tmData.SetValue(TW_BACKUP_NAME, \"(Auto Generate)\");\n\n\tmPersist.SetValue(TW_INSTALL_REBOOT_VAR, \"0\");\n\tmPersist.SetValue(TW_SIGNED_ZIP_VERIFY_VAR, \"0\");\n\tmPersist.SetValue(TW_DISABLE_FREE_SPACE_VAR, \"0\");\n\tmPersist.SetValue(TW_FORCE_DIGEST_CHECK_VAR, \"0\");\n\tmPersist.SetValue(TW_USE_COMPRESSION_VAR, \"0\");\n\tmPersist.SetValue(TW_TIME_ZONE_VAR, \"CST6CDT,M3.2.0,M11.1.0\");\n\tmPersist.SetValue(TW_GUI_SORT_ORDER, \"1\");\n\tmPersist.SetValue(TW_RM_RF_VAR, \"0\");\n\tmPersist.SetValue(TW_SKIP_DIGEST_CHECK_VAR, \"0\");\n\tmPersist.SetValue(TW_SKIP_DIGEST_GENERATE_VAR, \"0\");\n\tmPersist.SetValue(TW_SDEXT_SIZE, \"0\");\n\tmPersist.SetValue(TW_SWAP_SIZE, \"0\");\n\tmPersist.SetValue(TW_SDPART_FILE_SYSTEM, \"ext3\");\n\tmPersist.SetValue(TW_TIME_ZONE_GUISEL, \"CST6;CDT,M3.2.0,M11.1.0\");\n\tmPersist.SetValue(TW_TIME_ZONE_GUIOFFSET, \"0\");\n\tmPersist.SetValue(TW_TIME_ZONE_GUIDST, \"1\");\n\tmData.SetValue(TW_ACTION_BUSY, \"0\");\n\tmData.SetValue(\"tw_wipe_cache\", \"0\");\n\tmData.SetValue(\"tw_wipe_dalvik\", \"0\");\n\tmData.SetValue(TW_ZIP_INDEX, \"0\");\n\tmData.SetValue(TW_ZIP_QUEUE_COUNT, \"0\");\n\tmData.SetValue(TW_FILENAME, \"/sdcard\");\n\tmData.SetValue(TW_SIMULATE_ACTIONS, \"0\");\n\tmData.SetValue(TW_SIMULATE_FAIL, \"0\");\n\tmData.SetValue(TW_IS_ENCRYPTED, \"0\");\n\tmData.SetValue(TW_IS_DECRYPTED, \"0\");\n\tmData.SetValue(TW_CRYPTO_PASSWORD, \"0\");\n\tmData.SetValue(\"tw_terminal_state\", \"0\");\n\tmData.SetValue(\"tw_background_thread_running\", \"0\");\n\tmData.SetValue(TW_RESTORE_FILE_DATE, \"0\");\n\tmPersist.SetValue(\"tw_military_time\", \"0\");\n\n#ifdef TW_INCLUDE_CRYPTO\n\tmConst.SetValue(TW_USE_SHA2, \"1\");\n\tmConst.SetValue(TW_NO_SHA2, \"0\");\n#else\n\tmConst.SetValue(TW_NO_SHA2, \"1\");\n#endif\n\n#ifdef TW_NO_SCREEN_TIMEOUT\n\tmConst.SetValue(\"tw_screen_timeout_secs\", \"0\");\n\tmConst.SetValue(\"tw_no_screen_timeout\", \"1\");\n#else\n\tmPersist.SetValue(\"tw_screen_timeout_secs\", \"60\");\n\tmPersist.SetValue(\"tw_no_screen_timeout\", \"0\");\n#endif\n\tmData.SetValue(\"tw_gui_done\", \"0\");\n\tmData.SetValue(\"tw_encrypt_backup\", \"0\");\n\tmData.SetValue(\"tw_sleep_total\", \"5\");\n\tmData.SetValue(\"tw_sleep\", \"5\");\n\n\t// Brightness handling\n\tstring findbright;\n#ifdef TW_BRIGHTNESS_PATH\n\tfindbright = EXPAND(TW_BRIGHTNESS_PATH);\n\tLOGINFO(\"TW_BRIGHTNESS_PATH := %s\\n\", findbright.c_str());\n\tif (!TWFunc::Path_Exists(findbright)) {\n\t\tLOGINFO(\"Specified brightness file '%s' not found.\\n\", findbright.c_str());\n\t\tfindbright = \"\";\n\t}\n#endif\n\tif (findbright.empty()) {\n\t\t// Attempt to locate the brightness file\n\t\tfindbright = Find_File::Find(\"brightness\", \"/sys/class/backlight\");\n\t\tif (findbright.empty()) findbright = Find_File::Find(\"brightness\", \"/sys/class/leds/lcd-backlight\");\n\t}\n\tif (findbright.empty()) {\n\t\tLOGINFO(\"Unable to locate brightness file\\n\");\n\t\tmConst.SetValue(\"tw_has_brightnesss_file\", \"0\");\n\t} else {\n\t\tLOGINFO(\"Found brightness file at '%s'\\n\", findbright.c_str());\n\t\tmConst.SetValue(\"tw_has_brightnesss_file\", \"1\");\n\t\tmConst.SetValue(\"tw_brightness_file\", findbright);\n\t\tstring maxBrightness;\n#ifdef TW_MAX_BRIGHTNESS\n\t\tostringstream maxVal;\n\t\tmaxVal << TW_MAX_BRIGHTNESS;\n\t\tmaxBrightness = maxVal.str();\n#else\n\t\t// Attempt to locate the max_brightness file\n\t\tstring maxbrightpath = findbright.insert(findbright.rfind('/') + 1, \"max_\");\n\t\tif (TWFunc::Path_Exists(maxbrightpath)) {\n\t\t\tifstream maxVal(maxbrightpath.c_str());\n\t\t\tif (maxVal >> maxBrightness) {\n\t\t\t\tLOGINFO(\"Got max brightness %s from '%s'\\n\", maxBrightness.c_str(), maxbrightpath.c_str());\n\t\t\t} else {\n\t\t\t\t// Something went wrong, set that to indicate error\n\t\t\t\tmaxBrightness = \"-1\";\n\t\t\t}\n\t\t}\n\t\tif (atoi(maxBrightness.c_str()) <= 0)\n\t\t{\n\t\t\t// Fallback into default\n\t\t\tostringstream maxVal;\n\t\t\tmaxVal << 255;\n\t\t\tmaxBrightness = maxVal.str();\n\t\t}\n#endif\n\t\tmConst.SetValue(\"tw_brightness_max\", maxBrightness);\n\t\tmPersist.SetValue(\"tw_brightness\", maxBrightness);\n\t\tmPersist.SetValue(\"tw_brightness_pct\", \"100\");\n#ifdef TW_SECONDARY_BRIGHTNESS_PATH\n\t\tstring secondfindbright = EXPAND(TW_SECONDARY_BRIGHTNESS_PATH);\n\t\tif (secondfindbright != \"\" && TWFunc::Path_Exists(secondfindbright)) {\n\t\t\tLOGINFO(\"Will use a second brightness file at '%s'\\n\", secondfindbright.c_str());\n\t\t\tmConst.SetValue(\"tw_secondary_brightness_file\", secondfindbright);\n\t\t} else {\n\t\t\tLOGINFO(\"Specified secondary brightness file '%s' not found.\\n\", secondfindbright.c_str());\n\t\t}\n#endif\n#ifdef TW_DEFAULT_BRIGHTNESS\n\t\tint defValInt = TW_DEFAULT_BRIGHTNESS;\n\t\tint maxValInt = atoi(maxBrightness.c_str());\n\t\t// Deliberately int so the % is always a whole number\n\t\tint defPctInt = ( ( (double)defValInt / maxValInt ) * 100 );\n\t\tostringstream defPct;\n\t\tdefPct << defPctInt;\n\t\tmPersist.SetValue(\"tw_brightness_pct\", defPct.str());\n\n\t\tostringstream defVal;\n\t\tdefVal << TW_DEFAULT_BRIGHTNESS;\n\t\tmPersist.SetValue(\"tw_brightness\", defVal.str());\n\t\tTWFunc::Set_Brightness(defVal.str());\n#else\n\t\tTWFunc::Set_Brightness(maxBrightness);\n#endif\n\t}\n\n#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS\n\tmConst.SetValue(\"tw_include_encrypted_backup\", \"1\");\n#else\n\tLOGINFO(\"TW_EXCLUDE_ENCRYPTED_BACKUPS := true\\n\");\n\tmConst.SetValue(\"tw_include_encrypted_backup\", \"0\");\n#endif\n#ifdef TW_HAS_MTP\n\tmConst.SetValue(\"tw_has_mtp\", \"1\");\n\tmPersist.SetValue(\"tw_mtp_enabled\", \"1\");\n\tmPersist.SetValue(\"tw_mtp_debug\", \"0\");\n#else\n\tLOGINFO(\"TW_EXCLUDE_MTP := true\\n\");\n\tmConst.SetValue(\"tw_has_mtp\", \"0\");\n\tmConst.SetValue(\"tw_mtp_enabled\", \"0\");\n#endif\n\tmPersist.SetValue(\"tw_mount_system_ro\", \"2\");\n\tmPersist.SetValue(\"tw_never_show_system_ro_page\", \"0\");\n\tmPersist.SetValue(\"tw_language\", EXPAND(TW_DEFAULT_LANGUAGE));\n\tLOGINFO(\"LANG: %s\\n\", EXPAND(TW_DEFAULT_LANGUAGE));\n\n\tmData.SetValue(\"tw_has_adopted_storage\", \"0\");\n\n#ifdef AB_OTA_UPDATER\n\tLOGINFO(\"AB_OTA_UPDATER := true\\n\");\n\tmConst.SetValue(\"tw_has_boot_slots\", \"1\");\n#else\n\tmConst.SetValue(\"tw_has_boot_slots\", \"0\");\n#endif\n\n#ifdef TW_NO_LEGACY_PROPS\n\tLOGINFO(\"TW_NO_LEGACY_PROPS := true\\n\");\n#endif\n\n#ifdef TW_OEM_BUILD\n\tLOGINFO(\"TW_OEM_BUILD := true\\n\");\n\tmConst.SetValue(\"tw_oem_build\", \"1\");\n#else\n\tmConst.SetValue(\"tw_oem_build\", \"0\");\n\tmPersist.SetValue(\"tw_app_prompt\", \"1\");\n\tmPersist.SetValue(\"tw_app_install_system\", \"1\");\n\tmData.SetValue(\"tw_app_install_status\", \"0\"); // 0 = no status, 1 = not installed, 2 = already installed\n#endif\n\n        mData.SetValue(\"tw_enable_adb_backup\", \"0\");\n\n\tpthread_mutex_unlock(&m_valuesLock);\n}\n\n// Magic Values\nint DataManager::GetMagicValue(const string& varName, string& value)\n{\n\t// Handle special dynamic cases\n\tif (varName == \"tw_time\")\n\t{\n\t\tchar tmp[32];\n\n\t\tstruct tm *current;\n\t\ttime_t now;\n\t\tint tw_military_time;\n\t\tnow = time(0);\n\t\tcurrent = localtime(&now);\n\t\tGetValue(TW_MILITARY_TIME, tw_military_time);\n\t\tif (current->tm_hour >= 12)\n\t\t{\n\t\t\tif (tw_military_time == 1)\n\t\t\t\tsprintf(tmp, \"%d:%02d\", current->tm_hour, current->tm_min);\n\t\t\telse\n\t\t\t\tsprintf(tmp, \"%d:%02d PM\", current->tm_hour == 12 ? 12 : current->tm_hour - 12, current->tm_min);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tw_military_time == 1)\n\t\t\t\tsprintf(tmp, \"%d:%02d\", current->tm_hour, current->tm_min);\n\t\t\telse\n\t\t\t\tsprintf(tmp, \"%d:%02d AM\", current->tm_hour == 0 ? 12 : current->tm_hour, current->tm_min);\n\t\t}\n\t\tvalue = tmp;\n\t\treturn 0;\n\t}\n\telse if (varName == \"tw_cpu_temp\")\n\t{\n\t\tint tw_no_cpu_temp;\n\t\tGetValue(\"tw_no_cpu_temp\", tw_no_cpu_temp);\n\t\tif (tw_no_cpu_temp == 1) return -1;\n\n\t\tstring cpu_temp_file;\n\t\tstatic unsigned long convert_temp = 0;\n\t\tstatic time_t cpuSecCheck = 0;\n\t\tstruct timeval curTime;\n\t\tstring results;\n\n\t\tgettimeofday(&curTime, NULL);\n\t\tif (curTime.tv_sec > cpuSecCheck)\n\t\t{\n#ifdef TW_CUSTOM_CPU_TEMP_PATH\n\t\t\tcpu_temp_file = EXPAND(TW_CUSTOM_CPU_TEMP_PATH);\n\t\t\tif (TWFunc::read_file(cpu_temp_file, results) != 0)\n\t\t\t\treturn -1;\n#else\n\t\t\tcpu_temp_file = \"/sys/class/thermal/thermal_zone0/temp\";\n\t\t\tif (TWFunc::read_file(cpu_temp_file, results) != 0)\n\t\t\t\treturn -1;\n#endif\n\t\t\tconvert_temp = strtoul(results.c_str(), NULL, 0) / 1000;\n\t\t\tif (convert_temp <= 0)\n\t\t\t\tconvert_temp = strtoul(results.c_str(), NULL, 0);\n\t\t\tif (convert_temp >= 150)\n\t\t\t\tconvert_temp = strtoul(results.c_str(), NULL, 0) / 10;\n\t\t\tcpuSecCheck = curTime.tv_sec + 5;\n\t\t}\n\t\tvalue = TWFunc::to_string(convert_temp);\n\t\treturn 0;\n\t}\n\telse if (varName == \"tw_battery\")\n\t{\n\t\tchar tmp[16];\n\t\tstatic char charging = ' ';\n\t\tstatic int lastVal = -1;\n\t\tstatic time_t nextSecCheck = 0;\n\t\tstruct timeval curTime;\n\t\tgettimeofday(&curTime, NULL);\n\t\tif (curTime.tv_sec > nextSecCheck)\n\t\t{\n\t\t\tchar cap_s[4];\n#ifdef TW_CUSTOM_BATTERY_PATH\n\t\t\tstring capacity_file = EXPAND(TW_CUSTOM_BATTERY_PATH);\n\t\t\tcapacity_file += \"/capacity\";\n\t\t\tFILE * cap = fopen(capacity_file.c_str(),\"rt\");\n#else\n\t\t\tFILE * cap = fopen(\"/sys/class/power_supply/battery/capacity\",\"rt\");\n#endif\n\t\t\tif (cap) {\n\t\t\t\tfgets(cap_s, 4, cap);\n\t\t\t\tfclose(cap);\n\t\t\t\tlastVal = atoi(cap_s);\n\t\t\t\tif (lastVal > 100)\tlastVal = 101;\n\t\t\t\tif (lastVal < 0)\tlastVal = 0;\n\t\t\t}\n#ifdef TW_CUSTOM_BATTERY_PATH\n\t\t\tstring status_file = EXPAND(TW_CUSTOM_BATTERY_PATH);\n\t\t\tstatus_file += \"/status\";\n\t\t\tcap = fopen(status_file.c_str(),\"rt\");\n#else\n\t\t\tcap = fopen(\"/sys/class/power_supply/battery/status\",\"rt\");\n#endif\n\t\t\tif (cap) {\n\t\t\t\tfgets(cap_s, 2, cap);\n\t\t\t\tfclose(cap);\n\t\t\t\tif (cap_s[0] == 'C')\n\t\t\t\t\tcharging = '+';\n\t\t\t\telse\n\t\t\t\t\tcharging = ' ';\n\t\t\t}\n\t\t\tnextSecCheck = curTime.tv_sec + 60;\n\t\t}\n\n\t\tsprintf(tmp, \"%i%%%c\", lastVal, charging);\n\t\tvalue = tmp;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nvoid DataManager::Output_Version(void)\n{\n#ifndef TW_OEM_BUILD\n\tstring Path;\n\tchar version[255];\n\n\tif (!PartitionManager.Mount_By_Path(\"/cache\", false)) {\n\t\tLOGINFO(\"Unable to mount '%s' to write version number.\\n\", Path.c_str());\n\t\treturn;\n\t}\n\tif (!TWFunc::Path_Exists(\"/cache/recovery/.\")) {\n\t\tLOGINFO(\"Recreating /cache/recovery folder.\\n\");\n\t\tif (mkdir(\"/cache/recovery\", S_IRWXU | S_IRWXG | S_IWGRP | S_IXGRP) != 0) {\n\t\t\tLOGERR(\"DataManager::Output_Version -- Unable to make /cache/recovery\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tPath = \"/cache/recovery/.version\";\n\tif (TWFunc::Path_Exists(Path)) {\n\t\tunlink(Path.c_str());\n\t}\n\tFILE *fp = fopen(Path.c_str(), \"w\");\n\tif (fp == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Path)(strerror(errno)));\n\t\treturn;\n\t}\n\tstrcpy(version, TW_VERSION_STR);\n\tfwrite(version, sizeof(version[0]), strlen(version) / sizeof(version[0]), fp);\n\tfclose(fp);\n\tTWFunc::copy_file(\"/etc/recovery.fstab\", \"/cache/recovery/recovery.fstab\", 0644);\n\tPartitionManager.Output_Storage_Fstab();\n\tsync();\n\tLOGINFO(\"Version number saved to '%s'\\n\", Path.c_str());\n#endif\n}\n\nvoid DataManager::ReadSettingsFile(void)\n{\n#ifndef TW_OEM_BUILD\n\t// Load up the values for TWRP - Sleep to let the card be ready\n\tchar mkdir_path[255], settings_file[255];\n\tint is_enc, has_data_media;\n\n\tGetValue(TW_IS_ENCRYPTED, is_enc);\n\tGetValue(TW_HAS_DATA_MEDIA, has_data_media);\n\tif (is_enc == 1 && has_data_media == 1) {\n\t\tLOGINFO(\"Cannot load settings -- encrypted.\\n\");\n\t\treturn;\n\t}\n\n\tmemset(mkdir_path, 0, sizeof(mkdir_path));\n\tmemset(settings_file, 0, sizeof(settings_file));\n\tsprintf(mkdir_path, \"%s/TWRP\", GetSettingsStoragePath().c_str());\n\tsprintf(settings_file, \"%s/.twrps\", mkdir_path);\n\n\tif (!PartitionManager.Mount_Settings_Storage(false))\n\t{\n\t\tusleep(500000);\n\t\tif (!PartitionManager.Mount_Settings_Storage(false))\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_mount=Unable to mount {1}\")(settings_file));\n\t}\n\n\tmkdir(mkdir_path, 0777);\n\n\tLOGINFO(\"Attempt to load settings from settings file...\\n\");\n\tLoadValues(settings_file);\n\tOutput_Version();\n#endif // ifdef TW_OEM_BUILD\n\tPartitionManager.Mount_All_Storage();\n\tupdate_tz_environment_variables();\n\tTWFunc::Set_Brightness(GetStrValue(\"tw_brightness\"));\n}\n\nstring DataManager::GetCurrentStoragePath(void)\n{\n\treturn GetStrValue(\"tw_storage_path\");\n}\n\nstring DataManager::GetSettingsStoragePath(void)\n{\n\treturn GetStrValue(\"tw_settings_path\");\n}\n\nvoid DataManager::Vibrate(const string& varName)\n{\n\tint vib_value = 0;\n\tGetValue(varName, vib_value);\n\tif (vib_value) {\n\t\tvibrate(vib_value);\n\t}\n}\n"
        },
        {
          "name": "data.hpp",
          "type": "blob",
          "size": 2.7646484375,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _DATAMANAGER_HPP_HEADER\n#define _DATAMANAGER_HPP_HEADER\n\n#include <string>\n#include <pthread.h>\n#include \"infomanager.hpp\"\n\n#define PERSIST_SETTINGS_FILE  \"/persist/.twrps\"\n\nusing namespace std;\n\nclass DataManager\n{\npublic:\n\tstatic int ResetDefaults();\n\tstatic int LoadValues(const string& filename);\n\tstatic int LoadPersistValues(void);\n\tstatic int Flush();\n\n\t// Core get routines\n\tstatic int GetValue(const string& varName, string& value);\n\tstatic int GetValue(const string& varName, int& value);\n\tstatic int GetValue(const string& varName, float& value);\n\tstatic int GetValue(const string& varName, unsigned long long& value);\n\n\t// Helper functions\n\tstatic string GetStrValue(const string& varName);\n\tstatic int GetIntValue(const string& varName);\n\n\t// Core set routines\n\tstatic int SetValue(const string& varName, const string& value, const int persist = 0);\n\tstatic int SetValue(const string& varName, const int value, const int persist = 0);\n\tstatic int SetValue(const string& varName, const float value, const int persist = 0);\n\tstatic int SetValue(const string& varName, const unsigned long long& value, const int persist = 0);\n\tstatic int SetProgress(const float Fraction);\n\tstatic int ShowProgress(const float Portion, const float Seconds);\n\n\tstatic void DumpValues();\n\tstatic void update_tz_environment_variables();\n\tstatic void Vibrate(const string& varName);\n\tstatic void SetBackupFolder();\n\tstatic void SetDefaultValues();\n\tstatic void Output_Version(void); // Outputs the version to a file in the TWRP folder\n\tstatic void ReadSettingsFile(void);\n\n\tstatic string GetCurrentStoragePath(void);\n\tstatic string GetSettingsStoragePath(void);\n\nprotected:\n\tstatic string mBackingFile;\n\tstatic int mInitialized;\n\tstatic InfoManager mPersist;\n\tstatic InfoManager mData;\n\tstatic InfoManager mConst;\n\n\tstatic map<string, string> mConstValues;\n\nprotected:\n\tstatic int SaveValues();\n\n\tstatic int GetMagicValue(const string& varName, string& value);\n\nprivate:\n\tstatic void sanitize_device_id(char* device_id);\n\tstatic void get_device_id(void);\n\n\tstatic pthread_mutex_t m_valuesLock;\n};\n\n#endif // _DATAMANAGER_HPP_HEADER\n\n"
        },
        {
          "name": "default_device.cpp",
          "type": "blob",
          "size": 0.716796875,
          "content": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"device.h\"\n#include \"screen_ui.h\"\n\nDevice* make_device() {\n  return new Device(new ScreenRecoveryUI);\n}\n"
        },
        {
          "name": "device.cpp",
          "type": "blob",
          "size": 2.34375,
          "content": "/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"device.h\"\n\nstatic const char* MENU_ITEMS[] = {\n  \"Reboot system now\",\n  \"Reboot to bootloader\",\n  \"Apply update from ADB\",\n  \"Apply update from SD card\",\n  \"Wipe data/factory reset\",\n#ifndef AB_OTA_UPDATER\n  \"Wipe cache partition\",\n#endif  // !AB_OTA_UPDATER\n  \"Mount /system\",\n  \"View recovery logs\",\n  \"Run graphics test\",\n  \"Run locale test\",\n  \"Power off\",\n  nullptr,\n};\n\nstatic const Device::BuiltinAction MENU_ACTIONS[] = {\n  Device::REBOOT,\n  Device::REBOOT_BOOTLOADER,\n  Device::APPLY_ADB_SIDELOAD,\n  Device::APPLY_SDCARD,\n  Device::WIPE_DATA,\n#ifndef AB_OTA_UPDATER\n  Device::WIPE_CACHE,\n#endif  // !AB_OTA_UPDATER\n  Device::MOUNT_SYSTEM,\n  Device::VIEW_RECOVERY_LOGS,\n  Device::RUN_GRAPHICS_TEST,\n  Device::RUN_LOCALE_TEST,\n  Device::SHUTDOWN,\n};\n\nstatic_assert(sizeof(MENU_ITEMS) / sizeof(MENU_ITEMS[0]) ==\n              sizeof(MENU_ACTIONS) / sizeof(MENU_ACTIONS[0]) + 1,\n              \"MENU_ITEMS and MENU_ACTIONS should have the same length, \"\n              \"except for the extra NULL entry in MENU_ITEMS.\");\n\nconst char* const* Device::GetMenuItems() {\n  return MENU_ITEMS;\n}\n\nDevice::BuiltinAction Device::InvokeMenuItem(int menu_position) {\n  return menu_position < 0 ? NO_ACTION : MENU_ACTIONS[menu_position];\n}\n\nint Device::HandleMenuKey(int key, bool visible) {\n  if (!visible) {\n    return kNoAction;\n  }\n\n  switch (key) {\n    case KEY_DOWN:\n    case KEY_VOLUMEDOWN:\n      return kHighlightDown;\n\n    case KEY_UP:\n    case KEY_VOLUMEUP:\n      return kHighlightUp;\n\n    case KEY_ENTER:\n    case KEY_POWER:\n      return kInvokeItem;\n\n    default:\n      // If you have all of the above buttons, any other buttons\n      // are ignored. Otherwise, any button cycles the highlight.\n      return ui_->HasThreeButtons() ? kNoAction : kHighlightDown;\n  }\n}\n"
        },
        {
          "name": "device.h",
          "type": "blob",
          "size": 4.2412109375,
          "content": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _RECOVERY_DEVICE_H\n#define _RECOVERY_DEVICE_H\n\n#include \"ui.h\"\n\nclass Device {\n public:\n  explicit Device(RecoveryUI* ui) : ui_(ui) {}\n  virtual ~Device() {}\n\n  // Called to obtain the UI object that should be used to display the recovery user interface for\n  // this device. You should not have called Init() on the UI object already, the caller will do\n  // that after this method returns.\n  virtual RecoveryUI* GetUI() {\n    return ui_;\n  }\n\n  // Called when recovery starts up (after the UI has been obtained and initialized and after the\n  // arguments have been parsed, but before anything else).\n  virtual void StartRecovery() {};\n\n  // Called from the main thread when recovery is at the main menu and waiting for input, and a key\n  // is pressed. (Note that \"at\" the main menu does not necessarily mean the menu is visible;\n  // recovery will be at the main menu with it invisible after an unsuccessful operation [ie OTA\n  // package failure], or if recovery is started with no command.)\n  //\n  // 'key' is the code of the key just pressed. (You can call IsKeyPressed() on the RecoveryUI\n  // object you returned from GetUI if you want to find out if other keys are held down.)\n  //\n  // 'visible' is true if the menu is visible.\n  //\n  // Returns one of the defined constants below in order to:\n  //\n  //   - move the menu highlight (kHighlight{Up,Down})\n  //   - invoke the highlighted item (kInvokeItem)\n  //   - do nothing (kNoAction)\n  //   - invoke a specific action (a menu position: any non-negative number)\n  virtual int HandleMenuKey(int key, bool visible);\n\n  enum BuiltinAction {\n    NO_ACTION = 0,\n    REBOOT = 1,\n    APPLY_SDCARD = 2,\n    // APPLY_CACHE was 3.\n    APPLY_ADB_SIDELOAD = 4,\n    WIPE_DATA = 5,\n    WIPE_CACHE = 6,\n    REBOOT_BOOTLOADER = 7,\n    SHUTDOWN = 8,\n    VIEW_RECOVERY_LOGS = 9,\n    MOUNT_SYSTEM = 10,\n    RUN_GRAPHICS_TEST = 11,\n    RUN_LOCALE_TEST = 12,\n  };\n\n  // Return the list of menu items (an array of strings, NULL-terminated). The menu_position passed\n  // to InvokeMenuItem will correspond to the indexes into this array.\n  virtual const char* const* GetMenuItems();\n\n  // Perform a recovery action selected from the menu. 'menu_position' will be the item number of\n  // the selected menu item, or a non-negative number returned from HandleMenuKey(). The menu will\n  // be hidden when this is called; implementations can call ui_print() to print information to the\n  // screen. If the menu position is one of the builtin actions, you can just return the\n  // corresponding enum value. If it is an action specific to your device, you actually perform it\n  // here and return NO_ACTION.\n  virtual BuiltinAction InvokeMenuItem(int menu_position);\n\n  static const int kNoAction = -1;\n  static const int kHighlightUp = -2;\n  static const int kHighlightDown = -3;\n  static const int kInvokeItem = -4;\n\n  // Called before and after we do a wipe data/factory reset operation, either via a reboot from the\n  // main system with the --wipe_data flag, or when the user boots into recovery image manually and\n  // selects the option from the menu, to perform whatever device-specific wiping actions as needed.\n  // Returns true on success; returning false from PreWipeData will prevent the regular wipe, and\n  // returning false from PostWipeData will cause the wipe to be considered a failure.\n  virtual bool PreWipeData() {\n    return true;\n  }\n\n  virtual bool PostWipeData() {\n    return true;\n  }\n\n private:\n  RecoveryUI* ui_;\n};\n\n// The device-specific library must define this function (or the default one will be used, if there\n// is no device-specific library). It returns the Device object that recovery should use.\nDevice* make_device();\n\n#endif  // _DEVICE_H\n"
        },
        {
          "name": "dosfstools",
          "type": "tree",
          "content": null
        },
        {
          "name": "edify",
          "type": "tree",
          "content": null
        },
        {
          "name": "etc",
          "type": "tree",
          "content": null
        },
        {
          "name": "exclude.cpp",
          "type": "blob",
          "size": 3.0322265625,
          "content": "/*\n\t\tCopyright 2013 to 2016 TeamWin\n\t\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\t\tTWRP is free software: you can redistribute it and/or modify\n\t\tit under the terms of the GNU General Public License as published by\n\t\tthe Free Software Foundation, either version 3 of the License, or\n\t\t(at your option) any later version.\n\n\t\tTWRP is distributed in the hope that it will be useful,\n\t\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\t\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t\tGNU General Public License for more details.\n\n\t\tYou should have received a copy of the GNU General Public License\n\t\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nextern \"C\" {\n\t#include \"libtar/libtar.h\"\n}\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <errno.h>\n#include <string>\n#include <vector>\n#include \"exclude.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"gui/gui.hpp\"\n#include \"twcommon.h\"\n\nusing namespace std;\n\nextern bool datamedia;\n\nTWExclude::TWExclude() {\n\tadd_relative_dir(\".\");\n\tadd_relative_dir(\"..\");\n\tadd_relative_dir(\"lost+found\");\n}\n\nvoid TWExclude::add_relative_dir(const string& dir) {\n\trelativedir.push_back(dir);\n}\n\nvoid TWExclude::clear_relative_dir(string dir) {\n\tvector<string>::iterator iter = relativedir.begin();\n\twhile (iter != relativedir.end()) {\n\t\tif (*iter == dir)\n\t\t\titer = relativedir.erase(iter);\n\t\telse\n\t\t\titer++;\n\t}\n}\n\nvoid TWExclude::add_absolute_dir(const string& dir) {\n\tabsolutedir.push_back(TWFunc::Remove_Trailing_Slashes(dir));\n}\n\nuint64_t TWExclude::Get_Folder_Size(const string& Path) {\n\tDIR* d;\n\tstruct dirent* de;\n\tstruct stat st;\n\tuint64_t dusize = 0;\n\tstring FullPath;\n\n\td = opendir(Path.c_str());\n\tif (d == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Path)(strerror(errno)));\n\t\treturn 0;\n\t}\n\n\twhile ((de = readdir(d)) != NULL) {\n\t\tFullPath = Path + \"/\";\n\t\tFullPath += de->d_name;\n\t\tif (lstat(FullPath.c_str(), &st)) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(FullPath)(strerror(errno)));\n\t\t\tLOGINFO(\"Real error: Unable to stat '%s'\\n\", FullPath.c_str());\n\t\t\tcontinue;\n\t\t}\n\t\tif ((st.st_mode & S_IFDIR) && !check_skip_dirs(FullPath) && de->d_type != DT_SOCK) {\n\t\t\tdusize += Get_Folder_Size(FullPath);\n\t\t} else if (st.st_mode & S_IFREG || st.st_mode & S_IFLNK) {\n\t\t\tdusize += (uint64_t)(st.st_size);\n\t\t}\n\t}\n\tclosedir(d);\n\treturn dusize;\n}\n\nbool TWExclude::check_relative_skip_dirs(const string& dir) {\n\treturn std::find(relativedir.begin(), relativedir.end(), dir) != relativedir.end();\n}\n\nbool TWExclude::check_absolute_skip_dirs(const string& path) {\n\treturn std::find(absolutedir.begin(), absolutedir.end(), path) != absolutedir.end();\n}\n\nbool TWExclude::check_skip_dirs(const string& path) {\n\tstring normalized = TWFunc::Remove_Trailing_Slashes(path);\n\tsize_t slashIdx = normalized.find_last_of('/');\n\tif (slashIdx != std::string::npos && slashIdx+1 < normalized.size()) {\n\t\tif (check_relative_skip_dirs(normalized.substr(slashIdx+1)))\n\t\t\treturn true;\n\t}\n\treturn check_absolute_skip_dirs(normalized);\n}\n"
        },
        {
          "name": "exclude.hpp",
          "type": "blob",
          "size": 1.322265625,
          "content": "/*\n        Copyright 2013 to 2016 TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef TWEXCLUDE_HPP\n#define TWEXCLUDE_HPP\n\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass TWExclude {\n\npublic:\n\tTWExclude();\n\tuint64_t Get_Folder_Size(const string& Path); // Gets the folder's size using stat\n\tvoid add_absolute_dir(const string& Path);\n\tvoid add_relative_dir(const string& Path);\n\tbool check_relative_skip_dirs(const string& dir);\n\tbool check_absolute_skip_dirs(const string& path);\n\tbool check_skip_dirs(const string& path);\n\tvoid clear_relative_dir(string dir);\nprivate:\n\tvector<string> absolutedir;\n\tvector<string> relativedir;\n};\n\n#endif\n"
        },
        {
          "name": "exfat",
          "type": "tree",
          "content": null
        },
        {
          "name": "fb2png",
          "type": "tree",
          "content": null
        },
        {
          "name": "find_file.cpp",
          "type": "blob",
          "size": 2.6533203125,
          "content": "/*\n\t\tCopyright 2014 TeamWin\n\t\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\t\tTWRP is free software: you can redistribute it and/or modify\n\t\tit under the terms of the GNU General Public License as published by\n\t\tthe Free Software Foundation, either version 3 of the License, or\n\t\t(at your option) any later version.\n\n\t\tTWRP is distributed in the hope that it will be useful,\n\t\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\t\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t\tGNU General Public License for more details.\n\n\t\tYou should have received a copy of the GNU General Public License\n\t\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <string>\n#include <vector>\n#include <dirent.h>\n#include <stdlib.h>\n#include \"find_file.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"twcommon.h\"\n\nusing namespace std;\n\nstring Find_File::Find(const string& file_name, const string& start_path) {\n\treturn Find_File().Find_Internal(file_name, start_path);\n}\n\nFind_File::Find_File() {\n}\n\nstring Find_File::Find_Internal(const string& filename, const string& starting_path) {\n\tDIR *d;\n\tstring new_path, return_path;\n\tvector<string> dirs;\n\tvector<string> symlinks;\n\tunsigned index;\n\n\t// Check to see if we have already searched this directory to prevent infinite loops\n\tif (std::find(searched_dirs.begin(), searched_dirs.end(), starting_path) != searched_dirs.end()) {\n\t\treturn \"\";\n\t}\n\tsearched_dirs.push_back(starting_path);\n\n\td = opendir(starting_path.c_str());\n\tif (d == NULL) {\n\t\tLOGINFO(\"Find_File: Error opening '%s'\\n\", starting_path.c_str());\n\t\treturn \"\";\n\t}\n\n\tstruct dirent *p;\n\twhile ((p = readdir(d))) {\n\t\tif (!strcmp(p->d_name, \".\") || !strcmp(p->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tnew_path = starting_path + \"/\";\n\t\tnew_path.append(p->d_name);\n\t\tif (p->d_type == DT_DIR) {\n\t\t\t// Add dir to search list for later\n\t\t\tdirs.push_back(new_path);\n\t\t} else if (p->d_type == DT_LNK) {\n\t\t\t// Add symlink to search list for later\n\t\t\tsymlinks.push_back(new_path);\n\t\t} else if (p->d_type == DT_REG && filename == p->d_name) {\n\t\t\t// We found a match!\n\t\t\tclosedir(d);\n\t\t\treturn new_path;\n\t\t}\n\t}\n\tclosedir(d);\n\n\t// Scan real directories first if no match found in this path\n\tfor (index = 0; index < dirs.size(); index++) {\n\t\treturn_path = Find_Internal(filename, dirs.at(index));\n\t\tif (!return_path.empty()) return return_path;\n\t}\n\t// Scan symlinks after scanning real directories\n\tfor (index = 0; index < symlinks.size(); index++) {\n\t\tchar buf[PATH_MAX];\n\t\t// Resolve symlink to a real path\n\t\tchar* ret = realpath(symlinks.at(index).c_str(), buf);\n\t\tif (ret) {\n\t\t\treturn_path = Find_Internal(filename, buf);\n\t\t\tif (!return_path.empty()) return return_path;\n\t\t}\n\t}\n\treturn \"\";\n}\n"
        },
        {
          "name": "find_file.hpp",
          "type": "blob",
          "size": 1.0849609375,
          "content": "/*\n        Copyright 2014 TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef Find_File_HPP\n#define Find_File_HPP\n\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Find_File {\n\npublic:\n\tstatic string Find(const string& file_name, const string& start_path);\nprivate:\n\tFind_File();\n\tstring Find_Internal(const string& filename, const string& starting_path);\n\tvector<string> searched_dirs;\n};\n\n#endif\n"
        },
        {
          "name": "fixContexts.cpp",
          "type": "blob",
          "size": 3.8505859375,
          "content": "/*\n\tCopyright 2012-2016 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <string>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <errno.h>\n#include <cctype>\n#include \"fixContexts.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"twcommon.h\"\n#include <selinux/selinux.h>\n#include <selinux/label.h>\n#include <selinux/android.h>\n#include <selinux/label.h>\n\nusing namespace std;\n\nstruct selabel_handle *sehandle;\nstruct selinux_opt selinux_options[] = {\n\t{ SELABEL_OPT_PATH, \"/file_contexts\" }\n};\n\nint fixContexts::restorecon(string entry, struct stat *sb) {\n\tchar *oldcontext, *newcontext;\n\n\tif (lgetfilecon(entry.c_str(), &oldcontext) < 0) {\n\t\tLOGINFO(\"Couldn't get selinux context for %s\\n\", entry.c_str());\n\t\treturn -1;\n\t}\n\tif (selabel_lookup(sehandle, &newcontext, entry.c_str(), sb->st_mode) < 0) {\n\t\tLOGINFO(\"Couldn't lookup selinux context for %s\\n\", entry.c_str());\n\t\treturn -1;\n\t}\n\tif (strcmp(oldcontext, newcontext) != 0) {\n\t\tLOGINFO(\"Relabeling %s from %s to %s\\n\", entry.c_str(), oldcontext, newcontext);\n\t\tif (lsetfilecon(entry.c_str(), newcontext) < 0) {\n\t\t\tLOGINFO(\"Couldn't label %s with %s: %s\\n\", entry.c_str(), newcontext, strerror(errno));\n\t\t}\n\t}\n\tfreecon(oldcontext);\n\tfreecon(newcontext);\n\treturn 0;\n}\n\nint fixContexts::fixContextsRecursively(string name, int level) {\n\tDIR *d;\n\tstruct dirent *de;\n\tstruct stat sb;\n\tstring path;\n\n\tif (!(d = opendir(name.c_str())))\n\t\treturn -1;\n\tif (!(de = readdir(d)))\n\t\treturn -1;\n\n\tdo {\n\t\tif (de->d_type ==  DT_DIR) {\n\t\t\tif (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\n\t\t\t\tcontinue;\n\t\t\tpath = name + \"/\" + de->d_name;\n\t\t\trestorecon(path, &sb);\n\t\t\tfixContextsRecursively(path, level + 1);\n\t\t}\n\t\telse {\n\t\t\tpath = name + \"/\" + de->d_name;\n\t\t\trestorecon(path, &sb);\n\t\t}\n\t} while ((de = readdir(d)));\n\tclosedir(d);\n\treturn 0;\n}\n\nint fixContexts::fixDataMediaContexts(string Mount_Point) {\n\tDIR *d;\n\tstruct dirent *de;\n\tstruct stat sb;\n\n\tLOGINFO(\"Fixing media contexts on '%s'\\n\", Mount_Point.c_str());\n\n\tsehandle = selabel_open(SELABEL_CTX_FILE, selinux_options, 1);\n\tif (!sehandle) {\n\t\tLOGINFO(\"Unable to open /file_contexts\\n\");\n\t\treturn 0;\n\t}\n\n\tif (TWFunc::Path_Exists(Mount_Point + \"/media/0\")) {\n\t\tstring dir = Mount_Point + \"/media\";\n\t\tif (!(d = opendir(dir.c_str()))) {\n\t\t\tLOGINFO(\"opendir failed (%s)\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(de = readdir(d))) {\n\t\t\tLOGINFO(\"readdir failed (%s)\\n\", strerror(errno));\n\t\t\tclosedir(d);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdo {\n\t\t\tif (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0 || de->d_type != DT_DIR)\n\t\t\t\tcontinue;\n\t\t\tsize_t len = strlen(de->d_name);\n\t\t\tbool is_numeric = true;\n\t\t\tchar* folder_name = de->d_name;\n\t\t\tfor (size_t i = 0; i < len; i++) {\n\t\t\t\tif (!isdigit(*folder_name)) {\n\t\t\t\t\tis_numeric = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfolder_name++;\n\t\t\t}\n\t\t\tif (is_numeric) {\n\t\t\t\tdir = Mount_Point + \"/media/\";\n\t\t\t\tdir += de->d_name;\n\t\t\t\trestorecon(dir, &sb);\n\t\t\t\tfixContextsRecursively(dir, 0);\n\t\t\t}\n\t\t} while ((de = readdir(d)));\n\t\tclosedir(d);\n\t} else if (TWFunc::Path_Exists(Mount_Point + \"/media\")) {\n\t\trestorecon(Mount_Point + \"/media\", &sb);\n\t\tfixContextsRecursively(Mount_Point + \"/media\", 0);\n\t} else {\n\t\tLOGINFO(\"fixDataMediaContexts: %s/media does not exist!\\n\", Mount_Point.c_str());\n\t\treturn 0;\n\t}\n\tselabel_close(sehandle);\n\treturn 0;\n}\n"
        },
        {
          "name": "fixContexts.hpp",
          "type": "blob",
          "size": 0.9990234375,
          "content": "/*\n\tCopyright 2012-2016 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef __FIXCONTEXTS_HPP\n#define __FIXCONTEXTS_HPP\n\n#include <string>\n\nusing namespace std;\n\nclass fixContexts {\n\tpublic:\n\t\tstatic int fixDataMediaContexts(string Mount_Point);\n\n\tprivate:\n\t\tstatic int restorecon(string entry, struct stat *sb);\n\t\tstatic int fixContextsRecursively(string path, int level);\n};\n\n#endif\n"
        },
        {
          "name": "flashutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "fonts",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuse.h",
          "type": "blob",
          "size": 17.8154296875,
          "content": "/****************************************************************************\n ****************************************************************************\n ***\n ***   This header was automatically generated from a Linux kernel header\n ***   of the same name, to make information necessary for userspace to\n ***   call into the kernel available to libc.  It contains only constants,\n ***   structures, and macros generated from the original header, and thus,\n ***   contains no copyrightable information.\n ***\n ***   To edit the content of this header, modify the corresponding\n ***   source file (e.g. under external/kernel-headers/original/) then\n ***   run bionic/libc/kernel/tools/update_all.py\n ***\n ***   Any manual change here will be lost the next time this script will\n ***   be run. You've been warned!\n ***\n ****************************************************************************\n ****************************************************************************/\n#ifndef _LINUX_FUSE_H\n#define _LINUX_FUSE_H\n#include <stdint.h>\n#define FUSE_KERNEL_VERSION 7\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_KERNEL_MINOR_VERSION 22\n#define FUSE_ROOT_ID 1\nstruct fuse_attr {\n uint64_t ino;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t size;\n uint64_t blocks;\n uint64_t atime;\n uint64_t mtime;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t ctime;\n uint32_t atimensec;\n uint32_t mtimensec;\n uint32_t ctimensec;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t mode;\n uint32_t nlink;\n uint32_t uid;\n uint32_t gid;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t rdev;\n uint32_t blksize;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_kstatfs {\n uint64_t blocks;\n uint64_t bfree;\n uint64_t bavail;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t files;\n uint64_t ffree;\n uint32_t bsize;\n uint32_t namelen;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t frsize;\n uint32_t padding;\n uint32_t spare[6];\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_file_lock {\n uint64_t start;\n uint64_t end;\n uint32_t type;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t pid;\n};\n#define FATTR_MODE (1 << 0)\n#define FATTR_UID (1 << 1)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FATTR_GID (1 << 2)\n#define FATTR_SIZE (1 << 3)\n#define FATTR_ATIME (1 << 4)\n#define FATTR_MTIME (1 << 5)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FATTR_FH (1 << 6)\n#define FATTR_ATIME_NOW (1 << 7)\n#define FATTR_MTIME_NOW (1 << 8)\n#define FATTR_LOCKOWNER (1 << 9)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FOPEN_DIRECT_IO (1 << 0)\n#define FOPEN_KEEP_CACHE (1 << 1)\n#define FOPEN_NONSEEKABLE (1 << 2)\n#define FUSE_ASYNC_READ (1 << 0)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_POSIX_LOCKS (1 << 1)\n#define FUSE_FILE_OPS (1 << 2)\n#define FUSE_ATOMIC_O_TRUNC (1 << 3)\n#define FUSE_EXPORT_SUPPORT (1 << 4)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_BIG_WRITES (1 << 5)\n#define FUSE_DONT_MASK (1 << 6)\n#define FUSE_SPLICE_WRITE (1 << 7)\n#define FUSE_SPLICE_MOVE (1 << 8)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_SPLICE_READ (1 << 9)\n#define FUSE_FLOCK_LOCKS (1 << 10)\n#define FUSE_HAS_IOCTL_DIR (1 << 11)\n#define FUSE_AUTO_INVAL_DATA (1 << 12)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_DO_READDIRPLUS (1 << 13)\n#define FUSE_READDIRPLUS_AUTO (1 << 14)\n#define FUSE_ASYNC_DIO (1 << 15)\n#define CUSE_UNRESTRICTED_IOCTL (1 << 0)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_RELEASE_FLUSH (1 << 0)\n#define FUSE_RELEASE_FLOCK_UNLOCK (1 << 1)\n#define FUSE_GETATTR_FH (1 << 0)\n#define FUSE_LK_FLOCK (1 << 0)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_WRITE_CACHE (1 << 0)\n#define FUSE_WRITE_LOCKOWNER (1 << 1)\n#define FUSE_READ_LOCKOWNER (1 << 1)\n#define FUSE_IOCTL_COMPAT (1 << 0)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_IOCTL_UNRESTRICTED (1 << 1)\n#define FUSE_IOCTL_RETRY (1 << 2)\n#define FUSE_IOCTL_32BIT (1 << 3)\n#define FUSE_IOCTL_DIR (1 << 4)\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_IOCTL_MAX_IOV 256\n#define FUSE_POLL_SCHEDULE_NOTIFY (1 << 0)\nenum fuse_opcode {\n FUSE_LOOKUP = 1,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_FORGET = 2,\n FUSE_GETATTR = 3,\n FUSE_SETATTR = 4,\n FUSE_READLINK = 5,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_SYMLINK = 6,\n FUSE_MKNOD = 8,\n FUSE_MKDIR = 9,\n FUSE_UNLINK = 10,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_RMDIR = 11,\n FUSE_RENAME = 12,\n FUSE_LINK = 13,\n FUSE_OPEN = 14,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_READ = 15,\n FUSE_WRITE = 16,\n FUSE_STATFS = 17,\n FUSE_RELEASE = 18,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_FSYNC = 20,\n FUSE_SETXATTR = 21,\n FUSE_GETXATTR = 22,\n FUSE_LISTXATTR = 23,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_REMOVEXATTR = 24,\n FUSE_FLUSH = 25,\n FUSE_INIT = 26,\n FUSE_OPENDIR = 27,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_READDIR = 28,\n FUSE_RELEASEDIR = 29,\n FUSE_FSYNCDIR = 30,\n FUSE_GETLK = 31,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_SETLK = 32,\n FUSE_SETLKW = 33,\n FUSE_ACCESS = 34,\n FUSE_CREATE = 35,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_INTERRUPT = 36,\n FUSE_BMAP = 37,\n FUSE_DESTROY = 38,\n FUSE_IOCTL = 39,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_POLL = 40,\n FUSE_NOTIFY_REPLY = 41,\n FUSE_BATCH_FORGET = 42,\n FUSE_FALLOCATE = 43,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_READDIRPLUS = 44,\n CUSE_INIT = 4096,\n};\nenum fuse_notify_code {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_NOTIFY_POLL = 1,\n FUSE_NOTIFY_INVAL_INODE = 2,\n FUSE_NOTIFY_INVAL_ENTRY = 3,\n FUSE_NOTIFY_STORE = 4,\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n FUSE_NOTIFY_RETRIEVE = 5,\n FUSE_NOTIFY_DELETE = 6,\n FUSE_NOTIFY_CODE_MAX,\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_MIN_READ_BUFFER 8192\n#define FUSE_COMPAT_ENTRY_OUT_SIZE 120\nstruct fuse_entry_out {\n uint64_t nodeid;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t generation;\n uint64_t entry_valid;\n uint64_t attr_valid;\n uint32_t entry_valid_nsec;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t attr_valid_nsec;\n struct fuse_attr attr;\n};\nstruct fuse_forget_in {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t nlookup;\n};\nstruct fuse_forget_one {\n uint64_t nodeid;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t nlookup;\n};\nstruct fuse_batch_forget_in {\n uint32_t count;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t dummy;\n};\nstruct fuse_getattr_in {\n uint32_t getattr_flags;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t dummy;\n uint64_t fh;\n};\n#define FUSE_COMPAT_ATTR_OUT_SIZE 96\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_attr_out {\n uint64_t attr_valid;\n uint32_t attr_valid_nsec;\n uint32_t dummy;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n struct fuse_attr attr;\n};\n#define FUSE_COMPAT_MKNOD_IN_SIZE 8\nstruct fuse_mknod_in {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t mode;\n uint32_t rdev;\n uint32_t umask;\n uint32_t padding;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_mkdir_in {\n uint32_t mode;\n uint32_t umask;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_rename_in {\n uint64_t newdir;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_link_in {\n uint64_t oldnodeid;\n};\nstruct fuse_setattr_in {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t valid;\n uint32_t padding;\n uint64_t fh;\n uint64_t size;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t lock_owner;\n uint64_t atime;\n uint64_t mtime;\n uint64_t unused2;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t atimensec;\n uint32_t mtimensec;\n uint32_t unused3;\n uint32_t mode;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t unused4;\n uint32_t uid;\n uint32_t gid;\n uint32_t unused5;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_open_in {\n uint32_t flags;\n uint32_t unused;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_create_in {\n uint32_t flags;\n uint32_t mode;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t umask;\n uint32_t padding;\n};\nstruct fuse_open_out {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t fh;\n uint32_t open_flags;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_release_in {\n uint64_t fh;\n uint32_t flags;\n uint32_t release_flags;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t lock_owner;\n};\nstruct fuse_flush_in {\n uint64_t fh;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t unused;\n uint32_t padding;\n uint64_t lock_owner;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_read_in {\n uint64_t fh;\n uint64_t offset;\n uint32_t size;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t read_flags;\n uint64_t lock_owner;\n uint32_t flags;\n uint32_t padding;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\n#define FUSE_COMPAT_WRITE_IN_SIZE 24\nstruct fuse_write_in {\n uint64_t fh;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t offset;\n uint32_t size;\n uint32_t write_flags;\n uint64_t lock_owner;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t flags;\n uint32_t padding;\n};\nstruct fuse_write_out {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t size;\n uint32_t padding;\n};\n#define FUSE_COMPAT_STATFS_SIZE 48\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_statfs_out {\n struct fuse_kstatfs st;\n};\nstruct fuse_fsync_in {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t fh;\n uint32_t fsync_flags;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_setxattr_in {\n uint32_t size;\n uint32_t flags;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_getxattr_in {\n uint32_t size;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_getxattr_out {\n uint32_t size;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_lk_in {\n uint64_t fh;\n uint64_t owner;\n struct fuse_file_lock lk;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t lk_flags;\n uint32_t padding;\n};\nstruct fuse_lk_out {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n struct fuse_file_lock lk;\n};\nstruct fuse_access_in {\n uint32_t mask;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t padding;\n};\nstruct fuse_init_in {\n uint32_t major;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t minor;\n uint32_t max_readahead;\n uint32_t flags;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_init_out {\n uint32_t major;\n uint32_t minor;\n uint32_t max_readahead;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t flags;\n uint16_t max_background;\n uint16_t congestion_threshold;\n uint32_t max_write;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\n#define CUSE_INIT_INFO_MAX 4096\nstruct cuse_init_in {\n uint32_t major;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t minor;\n uint32_t unused;\n uint32_t flags;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct cuse_init_out {\n uint32_t major;\n uint32_t minor;\n uint32_t unused;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t flags;\n uint32_t max_read;\n uint32_t max_write;\n uint32_t dev_major;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t dev_minor;\n uint32_t spare[10];\n};\nstruct fuse_interrupt_in {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t unique;\n};\nstruct fuse_bmap_in {\n uint64_t block;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t blocksize;\n uint32_t padding;\n};\nstruct fuse_bmap_out {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t block;\n};\nstruct fuse_ioctl_in {\n uint64_t fh;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t flags;\n uint32_t cmd;\n uint64_t arg;\n uint32_t in_size;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t out_size;\n};\nstruct fuse_ioctl_iovec {\n uint64_t base;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t len;\n};\nstruct fuse_ioctl_out {\n int32_t result;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t flags;\n uint32_t in_iovs;\n uint32_t out_iovs;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_poll_in {\n uint64_t fh;\n uint64_t kh;\n uint32_t flags;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t events;\n};\nstruct fuse_poll_out {\n uint32_t revents;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t padding;\n};\nstruct fuse_notify_poll_wakeup_out {\n uint64_t kh;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_fallocate_in {\n uint64_t fh;\n uint64_t offset;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t length;\n uint32_t mode;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_in_header {\n uint32_t len;\n uint32_t opcode;\n uint64_t unique;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t nodeid;\n uint32_t uid;\n uint32_t gid;\n uint32_t pid;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t padding;\n};\nstruct fuse_out_header {\n uint32_t len;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n int32_t error;\n uint64_t unique;\n};\nstruct fuse_dirent {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t ino;\n uint64_t off;\n uint32_t namelen;\n uint32_t type;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n char name[];\n};\n#define FUSE_NAME_OFFSET offsetof(struct fuse_dirent, name)\n#define FUSE_DIRENT_ALIGN(x)   (((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#define FUSE_DIRENT_SIZE(d)   FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)\nstruct fuse_direntplus {\n struct fuse_entry_out entry_out;\n struct fuse_dirent dirent;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\n#define FUSE_NAME_OFFSET_DIRENTPLUS   offsetof(struct fuse_direntplus, dirent.name)\n#define FUSE_DIRENTPLUS_SIZE(d)   FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET_DIRENTPLUS + (d)->dirent.namelen)\nstruct fuse_notify_inval_inode_out {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t ino;\n int64_t off;\n int64_t len;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_notify_inval_entry_out {\n uint64_t parent;\n uint32_t namelen;\n uint32_t padding;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_notify_delete_out {\n uint64_t parent;\n uint64_t child;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t namelen;\n uint32_t padding;\n};\nstruct fuse_notify_store_out {\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t nodeid;\n uint64_t offset;\n uint32_t size;\n uint32_t padding;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n};\nstruct fuse_notify_retrieve_out {\n uint64_t notify_unique;\n uint64_t nodeid;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint64_t offset;\n uint32_t size;\n uint32_t padding;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\nstruct fuse_notify_retrieve_in {\n uint64_t dummy1;\n uint64_t offset;\n uint32_t size;\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n uint32_t dummy2;\n uint64_t dummy3;\n uint64_t dummy4;\n};\n/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */\n#endif\n"
        },
        {
          "name": "fuse",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuse_sdcard_provider.cpp",
          "type": "blob",
          "size": 2.3818359375,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"fuse_sdcard_provider.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <functional>\n\n#include <android-base/file.h>\n\n#include \"fuse_sideload.h\"\n\nstruct file_data {\n  int fd;  // the underlying sdcard file\n\n  uint64_t file_size;\n  uint32_t block_size;\n};\n\nstatic int read_block_file(const file_data& fd, uint32_t block, uint8_t* buffer,\n                           uint32_t fetch_size) {\n  off64_t offset = static_cast<off64_t>(block) * fd.block_size;\n  if (TEMP_FAILURE_RETRY(lseek64(fd.fd, offset, SEEK_SET)) == -1) {\n    fprintf(stderr, \"seek on sdcard failed: %s\\n\", strerror(errno));\n    return -EIO;\n  }\n\n  if (!android::base::ReadFully(fd.fd, buffer, fetch_size)) {\n    fprintf(stderr, \"read on sdcard failed: %s\\n\", strerror(errno));\n    return -EIO;\n  }\n\n  return 0;\n}\n\nbool start_sdcard_fuse(const char* path) {\n  struct stat sb;\n  if (stat(path, &sb) == -1) {\n    fprintf(stderr, \"failed to stat %s: %s\\n\", path, strerror(errno));\n    return false;\n  }\n\n  file_data fd;\n  fd.fd = open(path, O_RDONLY);\n  if (fd.fd == -1) {\n    fprintf(stderr, \"failed to open %s: %s\\n\", path, strerror(errno));\n    return false;\n  }\n  fd.file_size = sb.st_size;\n  fd.block_size = 65536;\n\n  provider_vtab vtab;\n  vtab.read_block = std::bind(&read_block_file, fd, std::placeholders::_1, std::placeholders::_2,\n                              std::placeholders::_3);\n  vtab.close = [&fd]() { close(fd.fd); };\n\n  // The installation process expects to find the sdcard unmounted. Unmount it with MNT_DETACH so\n  // that our open file continues to work but new references see it as unmounted.\n  umount2(\"/sdcard\", MNT_DETACH);\n\n  return run_fuse_sideload(vtab, fd.file_size, fd.block_size) == 0;\n}\n"
        },
        {
          "name": "fuse_sdcard_provider.h",
          "type": "blob",
          "size": 0.720703125,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __FUSE_SDCARD_PROVIDER_H\n#define __FUSE_SDCARD_PROVIDER_H\n\nbool start_sdcard_fuse(const char* path);\n\n#endif\n"
        },
        {
          "name": "fuse_sideload.cpp",
          "type": "blob",
          "size": 16.154296875,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This module creates a special filesystem containing two files.\n//\n// \"/sideload/package.zip\" appears to be a normal file, but reading\n// from it causes data to be fetched from the adb host.  We can use\n// this to sideload packages over an adb connection without having to\n// store the entire package in RAM on the device.\n//\n// Because we may not trust the adb host, this filesystem maintains\n// the following invariant: each read of a given position returns the\n// same data as the first read at that position.  That is, once a\n// section of the file is read, future reads of that section return\n// the same data.  (Otherwise, a malicious adb host process could\n// return one set of bits when the package is read for signature\n// verification, and then different bits for when the package is\n// accessed by the installer.)  If the adb host returns something\n// different than it did on the first read, the reader of the file\n// will see their read fail with EINVAL.\n//\n// The other file, \"/sideload/exit\", is used to control the subprocess\n// that creates this filesystem.  Calling stat() on the exit file\n// causes the filesystem to be unmounted and the adb process on the\n// device shut down.\n//\n// Note that only the minimal set of file operations needed for these\n// two files is implemented.  In particular, you can't opendir() or\n// readdir() on the \"/sideload\" directory; ls on it won't work.\n\n#include \"fuse_sideload.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include \"fuse.h\"\n#include <pthread.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/param.h>  // MIN\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <unistd.h>\n\n#ifdef USE_MINCRYPT\n#include \"mincrypt/sha256.h\"\n#define  SHA256_DIGEST_LENGTH SHA256_DIGEST_SIZE\n#else\n#include <openssl/sha.h>\n#endif\n\n#include <array>\n#include <string>\n#include <vector>\n\n//#include <android-base/stringprintf.h>\n//#include <android-base/unique_fd.h>\n\nstatic constexpr uint64_t PACKAGE_FILE_ID = FUSE_ROOT_ID + 1;\nstatic constexpr uint64_t EXIT_FLAG_ID = FUSE_ROOT_ID + 2;\n\nstatic constexpr int NO_STATUS = 1;\nstatic constexpr int NO_STATUS_EXIT = 2;\n\nusing SHA256Digest = std::array<uint8_t, SHA256_DIGEST_LENGTH>;\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\nstruct fuse_data {\n  int ffd;  // file descriptor for the fuse socket\n\n  provider_vtab vtab;\n\n  uint64_t file_size;  // bytes\n\n  uint32_t block_size;   // block size that the adb host is using to send the file to us\n  uint32_t file_blocks;  // file size in block_size blocks\n\n  uid_t uid;\n  gid_t gid;\n\n  uint32_t curr_block;  // cache the block most recently read from the host\n  uint8_t* block_data;\n\n  uint8_t* extra_block;  // another block of storage for reads that span two blocks\n\n  uint8_t* hashes;        // SHA-256 hash of each block (all zeros\n                          // if block hasn't been read yet)\n};\n\nstatic void fuse_reply(const fuse_data* fd, uint64_t unique, const void* data, size_t len) {\n  fuse_out_header hdr;\n  hdr.len = len + sizeof(hdr);\n  hdr.error = 0;\n  hdr.unique = unique;\n\n  struct iovec vec[2];\n  vec[0].iov_base = &hdr;\n  vec[0].iov_len = sizeof(hdr);\n  vec[1].iov_base = const_cast<void*>(data);\n  vec[1].iov_len = len;\n\n  int res = writev(fd->ffd, vec, 2);\n  if (res == -1) {\n    printf(\"*** REPLY FAILED *** %s\\n\", strerror(errno));\n  }\n}\n\nstatic int handle_init(void* data, fuse_data* fd, const fuse_in_header* hdr) {\n  const fuse_init_in* req = static_cast<const fuse_init_in*>(data);\n\n  // Kernel 2.6.16 is the first stable kernel with struct fuse_init_out defined (fuse version 7.6).\n  // The structure is the same from 7.6 through 7.22. Beginning with 7.23, the structure increased\n  // in size and added new parameters.\n  if (req->major != FUSE_KERNEL_VERSION || req->minor < 6) {\n    printf(\"Fuse kernel version mismatch: Kernel version %d.%d, Expected at least %d.6\", req->major,\n           req->minor, FUSE_KERNEL_VERSION);\n    return -1;\n  }\n\n  fuse_init_out out;\n  out.minor = MIN(req->minor, FUSE_KERNEL_MINOR_VERSION);\n  size_t fuse_struct_size = sizeof(out);\n#if defined(FUSE_COMPAT_22_INIT_OUT_SIZE)\n  /* FUSE_KERNEL_VERSION >= 23. */\n\n  // If the kernel only works on minor revs older than or equal to 22, then use the older structure\n  // size since this code only uses the 7.22 version of the structure.\n  if (req->minor <= 22) {\n    fuse_struct_size = FUSE_COMPAT_22_INIT_OUT_SIZE;\n  }\n#endif\n\n  out.major = FUSE_KERNEL_VERSION;\n  out.max_readahead = req->max_readahead;\n  out.flags = 0;\n  out.max_background = 32;\n  out.congestion_threshold = 32;\n  out.max_write = 4096;\n  fuse_reply(fd, hdr->unique, &out, fuse_struct_size);\n\n  return NO_STATUS;\n}\n\nstatic void fill_attr(fuse_attr* attr, const fuse_data* fd, uint64_t nodeid, uint64_t size,\n                      uint32_t mode) {\n  memset(attr, 0, sizeof(*attr));\n  attr->nlink = 1;\n  attr->uid = fd->uid;\n  attr->gid = fd->gid;\n  attr->blksize = 4096;\n\n  attr->ino = nodeid;\n  attr->size = size;\n  attr->blocks = (size == 0) ? 0 : (((size - 1) / attr->blksize) + 1);\n  attr->mode = mode;\n}\n\nstatic int handle_getattr(void* /* data */, const fuse_data* fd, const fuse_in_header* hdr) {\n  struct fuse_attr_out out;\n  memset(&out, 0, sizeof(out));\n  out.attr_valid = 10;\n\n  if (hdr->nodeid == FUSE_ROOT_ID) {\n    fill_attr(&(out.attr), fd, hdr->nodeid, 4096, S_IFDIR | 0555);\n  } else if (hdr->nodeid == PACKAGE_FILE_ID) {\n    fill_attr(&(out.attr), fd, PACKAGE_FILE_ID, fd->file_size, S_IFREG | 0444);\n  } else if (hdr->nodeid == EXIT_FLAG_ID) {\n    fill_attr(&(out.attr), fd, EXIT_FLAG_ID, 0, S_IFREG | 0);\n  } else {\n    return -ENOENT;\n  }\n\n  fuse_reply(fd, hdr->unique, &out, sizeof(out));\n  return (hdr->nodeid == EXIT_FLAG_ID) ? NO_STATUS_EXIT : NO_STATUS;\n}\n\nstatic int handle_lookup(void* data, const fuse_data* fd, const fuse_in_header* hdr) {\n  if (data == nullptr) return -ENOENT;\n\n  struct fuse_entry_out out;\n  memset(&out, 0, sizeof(out));\n  out.entry_valid = 10;\n  out.attr_valid = 10;\n\n  std::string filename(static_cast<const char*>(data));\n  if (filename == FUSE_SIDELOAD_HOST_FILENAME) {\n    out.nodeid = PACKAGE_FILE_ID;\n    out.generation = PACKAGE_FILE_ID;\n    fill_attr(&(out.attr), fd, PACKAGE_FILE_ID, fd->file_size, S_IFREG | 0444);\n  } else if (filename == FUSE_SIDELOAD_HOST_EXIT_FLAG) {\n    out.nodeid = EXIT_FLAG_ID;\n    out.generation = EXIT_FLAG_ID;\n    fill_attr(&(out.attr), fd, EXIT_FLAG_ID, 0, S_IFREG | 0);\n  } else {\n    return -ENOENT;\n  }\n\n  fuse_reply(fd, hdr->unique, &out, sizeof(out));\n  return (out.nodeid == EXIT_FLAG_ID) ? NO_STATUS_EXIT : NO_STATUS;\n}\n\nstatic int handle_open(void* /* data */, const fuse_data* fd, const fuse_in_header* hdr) {\n  if (hdr->nodeid == EXIT_FLAG_ID) return -EPERM;\n  if (hdr->nodeid != PACKAGE_FILE_ID) return -ENOENT;\n\n  struct fuse_open_out out;\n  memset(&out, 0, sizeof(out));\n  out.fh = 10;  // an arbitrary number; we always use the same handle\n  fuse_reply(fd, hdr->unique, &out, sizeof(out));\n  return NO_STATUS;\n}\n\nstatic int handle_flush(void* /* data */, fuse_data* /* fd */, const fuse_in_header* /* hdr */) {\n  return 0;\n}\n\nstatic int handle_release(void* /* data */, fuse_data* /* fd */, const fuse_in_header* /* hdr */) {\n  return 0;\n}\n\n// Fetch a block from the host into fd->curr_block and fd->block_data.\n// Returns 0 on successful fetch, negative otherwise.\nstatic int fetch_block(fuse_data* fd, uint32_t block) {\n  if (block == fd->curr_block) {\n    return 0;\n  }\n\n  if (block >= fd->file_blocks) {\n    memset(fd->block_data, 0, fd->block_size);\n    fd->curr_block = block;\n    return 0;\n  }\n\n  size_t fetch_size = fd->block_size;\n  if (block * fd->block_size + fetch_size > fd->file_size) {\n    // If we're reading the last (partial) block of the file, expect a shorter response from the\n    // host, and pad the rest of the block with zeroes.\n    fetch_size = fd->file_size - (block * fd->block_size);\n    memset(fd->block_data + fetch_size, 0, fd->block_size - fetch_size);\n  }\n\n  int result = fd->vtab.read_block(block, fd->block_data, fetch_size);\n  if (result < 0) return result;\n\n  fd->curr_block = block;\n\n  // Verify the hash of the block we just got from the host.\n  //\n  // - If the hash of the just-received data matches the stored hash for the block, accept it.\n  // - If the stored hash is all zeroes, store the new hash and accept the block (this is the first\n  //   time we've read this block).\n  // - Otherwise, return -EINVAL for the read.\n\n  uint8_t hash[SHA256_DIGEST_LENGTH];\n#ifdef USE_MINCRYPT\n  SHA256_hash(fd->block_data, fd->block_size, hash);\n#else\n  SHA256(fd->block_data, fd->block_size, hash);\n#endif\n  uint8_t* blockhash = fd->hashes + block * SHA256_DIGEST_LENGTH;\n  if (memcmp(hash, blockhash, SHA256_DIGEST_LENGTH) == 0) {\n    return 0;\n  }\n\n  int i;\n  for (i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n    if (blockhash[i] != 0) {\n      fd->curr_block = -1;\n      return -EIO;\n    }\n  }\n\n  memcpy(blockhash, hash, SHA256_DIGEST_LENGTH);\n  return 0;\n}\n\nstatic int handle_read(void* data, fuse_data* fd, const fuse_in_header* hdr) {\n  if (hdr->nodeid != PACKAGE_FILE_ID) return -ENOENT;\n\n  const fuse_read_in* req = static_cast<const fuse_read_in*>(data);\n  uint64_t offset = req->offset;\n  uint32_t size = req->size;\n\n  // The docs on the fuse kernel interface are vague about what to do when a read request extends\n  // past the end of the file. We can return a short read -- the return structure does include a\n  // length field -- but in testing that caused the program using the file to segfault. (I\n  // speculate that this is due to the reading program accessing it via mmap; maybe mmap dislikes\n  // when you return something short of a whole page?) To fix this we zero-pad reads that extend\n  // past the end of the file so we're always returning exactly as many bytes as were requested.\n  // (Users of the mapped file have to know its real length anyway.)\n\n  fuse_out_header outhdr;\n  outhdr.len = sizeof(outhdr) + size;\n  outhdr.error = 0;\n  outhdr.unique = hdr->unique;\n\n  struct iovec vec[3];\n  vec[0].iov_base = &outhdr;\n  vec[0].iov_len = sizeof(outhdr);\n\n  uint32_t block = offset / fd->block_size;\n  int result = fetch_block(fd, block);\n  if (result != 0) return result;\n\n  // Two cases:\n  //\n  //   - the read request is entirely within this block. In this case we can reply immediately.\n  //\n  //   - the read request goes over into the next block. Note that since we mount the filesystem\n  //     with max_read=block_size, a read can never span more than two blocks. In this case we copy\n  //     the block to extra_block and issue a fetch for the following block.\n\n  uint32_t block_offset = offset - (block * fd->block_size);\n\n  int vec_used;\n  if (size + block_offset <= fd->block_size) {\n    // First case: the read fits entirely in the first block.\n\n    vec[1].iov_base = fd->block_data + block_offset;\n    vec[1].iov_len = size;\n    vec_used = 2;\n  } else {\n    // Second case: the read spills over into the next block.\n\n    memcpy(fd->extra_block, fd->block_data + block_offset, fd->block_size - block_offset);\n    vec[1].iov_base = fd->extra_block;\n    vec[1].iov_len = fd->block_size - block_offset;\n\n    result = fetch_block(fd, block + 1);\n    if (result != 0) return result;\n    vec[2].iov_base = fd->block_data;\n    vec[2].iov_len = size - vec[1].iov_len;\n    vec_used = 3;\n  }\n\n  if (writev(fd->ffd, vec, vec_used) == -1) {\n    printf(\"*** READ REPLY FAILED: %s ***\\n\", strerror(errno));\n  }\n  return NO_STATUS;\n}\n\nint run_fuse_sideload(const provider_vtab& vtab, uint64_t file_size, uint32_t block_size,\n                      const char* mount_point) {\n  // If something's already mounted on our mountpoint, try to remove it. (Mostly in case of a\n  // previous abnormal exit.)\n  umount2(mount_point, MNT_FORCE);\n\n  // fs/fuse/inode.c in kernel code uses the greater of 4096 and the passed-in max_read.\n  if (block_size < 4096) {\n    fprintf(stderr, \"block size (%u) is too small\\n\", block_size);\n    return -1;\n  }\n  if (block_size > (1 << 22)) {  // 4 MiB\n    fprintf(stderr, \"block size (%u) is too large\\n\", block_size);\n    return -1;\n  }\n\n  fuse_data fd;\n  memset(&fd, 0, sizeof(fd));\n  fd.vtab = vtab;\n  fd.file_size = file_size;\n  fd.block_size = block_size;\n  fd.file_blocks = (file_size == 0) ? 0 : (((file_size - 1) / block_size) + 1);\n\n  int result;\n  if (fd.file_blocks > (1 << 18)) {\n    fprintf(stderr, \"file has too many blocks (%u)\\n\", fd.file_blocks);\n    result = -1;\n    goto done;\n  }\n\n  fd.hashes = (uint8_t*)calloc(fd.file_blocks, SHA256_DIGEST_LENGTH);\n  if (fd.hashes == NULL) {\n    fprintf(stderr, \"failed to allocate %d bites for hashes\\n\",\n            fd.file_blocks * SHA256_DIGEST_LENGTH);\n    result = -1;\n    goto done;\n  }\n\n  fd.uid = getuid();\n  fd.gid = getgid();\n\n  fd.curr_block = -1;\n  fd.block_data = static_cast<uint8_t*>(malloc(block_size));\n  if (fd.block_data == nullptr) {\n    fprintf(stderr, \"failed to allocate %d bites for block_data\\n\", block_size);\n    result = -1;\n    goto done;\n  }\n  fd.extra_block = static_cast<uint8_t*>(malloc(block_size));\n  if (fd.extra_block == nullptr) {\n    fprintf(stderr, \"failed to allocate %d bites for extra_block\\n\", block_size);\n    result = -1;\n    goto done;\n  }\n\n  fd.ffd = open(\"/dev/fuse\", O_RDWR);\n  if (!fd.ffd) {\n    perror(\"open /dev/fuse\");\n    result = -1;\n    goto done;\n  }\n\n  {\n  char opts[256];\n  snprintf(opts, sizeof(opts),\n          (\"fd=%d,user_id=%d,group_id=%d,max_read=%u,\"\n           \"allow_other,rootmode=040000\"),\n           fd.ffd, fd.uid, fd.gid, block_size);\n\n  result = mount(\"/dev/fuse\", FUSE_SIDELOAD_HOST_MOUNTPOINT, \"fuse\",\n                 MS_NOSUID | MS_NODEV | MS_RDONLY | MS_NOEXEC, opts);\n  if (result < 0) {\n      perror(\"mount\");\n      goto done;\n    }\n  }\n\n  uint8_t request_buffer[sizeof(fuse_in_header) + PATH_MAX * 8];\n  for (;;) {\n    ssize_t len = TEMP_FAILURE_RETRY(read(fd.ffd, request_buffer, sizeof(request_buffer)));\n    if (len == -1) {\n      perror(\"read request\");\n      if (errno == ENODEV) {\n        result = -1;\n        break;\n      }\n      continue;\n    }\n\n    if (static_cast<size_t>(len) < sizeof(fuse_in_header)) {\n      fprintf(stderr, \"request too short: len=%zd\\n\", len);\n      continue;\n    }\n\n    fuse_in_header* hdr = reinterpret_cast<fuse_in_header*>(request_buffer);\n    void* data = request_buffer + sizeof(fuse_in_header);\n\n    result = -ENOSYS;\n\n    switch (hdr->opcode) {\n      case FUSE_INIT:\n        result = handle_init(data, &fd, hdr);\n        break;\n\n      case FUSE_LOOKUP:\n        result = handle_lookup(data, &fd, hdr);\n        break;\n\n      case FUSE_GETATTR:\n        result = handle_getattr(data, &fd, hdr);\n        break;\n\n      case FUSE_OPEN:\n        result = handle_open(data, &fd, hdr);\n        break;\n\n      case FUSE_READ:\n        result = handle_read(data, &fd, hdr);\n        break;\n\n      case FUSE_FLUSH:\n        result = handle_flush(data, &fd, hdr);\n        break;\n\n      case FUSE_RELEASE:\n        result = handle_release(data, &fd, hdr);\n        break;\n\n      default:\n        fprintf(stderr, \"unknown fuse request opcode %d\\n\", hdr->opcode);\n        break;\n    }\n\n    if (result == NO_STATUS_EXIT) {\n      result = 0;\n      break;\n    }\n\n    if (result != NO_STATUS) {\n      fuse_out_header outhdr;\n      outhdr.len = sizeof(outhdr);\n      outhdr.error = result;\n      outhdr.unique = hdr->unique;\n      TEMP_FAILURE_RETRY(write(fd.ffd, &outhdr, sizeof(outhdr)));\n    }\n  }\n\ndone:\n  fd.vtab.close();\n\n  if (umount2(mount_point, MNT_DETACH) == -1) {\n    fprintf(stderr, \"fuse_sideload umount failed: %s\\n\", strerror(errno));\n  }\n\n  free(fd.block_data);\n  free(fd.extra_block);\n\n  return result;\n}\n\nextern \"C\" int run_old_fuse_sideload(const struct provider_vtab& vtab, void* cookie __unused,\n                      uint64_t file_size, uint32_t block_size)\n{\n    return run_fuse_sideload(vtab, file_size, block_size, FUSE_SIDELOAD_HOST_MOUNTPOINT);\n}\n"
        },
        {
          "name": "fuse_sideload.h",
          "type": "blob",
          "size": 1.7421875,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __FUSE_SIDELOAD_H\n#define __FUSE_SIDELOAD_H\n\n#ifdef USE_FUSE_SIDELOAD22\n#include \"fuse_sideload22.h\"\n#else\n\n#include <functional>\n\n// Define the filenames created by the sideload FUSE filesystem.\nstatic constexpr const char* FUSE_SIDELOAD_HOST_MOUNTPOINT = \"/sideload\";\nstatic constexpr const char* FUSE_SIDELOAD_HOST_FILENAME = \"package.zip\";\nstatic constexpr const char* FUSE_SIDELOAD_HOST_PATHNAME = \"/sideload/package.zip\";\nstatic constexpr const char* FUSE_SIDELOAD_HOST_EXIT_FLAG = \"exit\";\nstatic constexpr const char* FUSE_SIDELOAD_HOST_EXIT_PATHNAME = \"/sideload/exit\";\n\nstruct provider_vtab {\n  // read a block\n  std::function<int(uint32_t block, uint8_t* buffer, uint32_t fetch_size)> read_block;\n\n  // close down\n  std::function<void(void)> close;\n};\n\nint run_fuse_sideload(const provider_vtab& vtab, uint64_t file_size, uint32_t block_size,\n                      const char* mount_point = FUSE_SIDELOAD_HOST_MOUNTPOINT);\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nint run_old_fuse_sideload(const struct provider_vtab& vtab, void* cookie,\n                      uint64_t file_size, uint32_t block_size);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#endif\n"
        },
        {
          "name": "fuse_sideload22.cpp",
          "type": "blob",
          "size": 17.4296875,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This module creates a special filesystem containing two files.\n//\n// \"/sideload/package.zip\" appears to be a normal file, but reading\n// from it causes data to be fetched from the adb host.  We can use\n// this to sideload packages over an adb connection without having to\n// store the entire package in RAM on the device.\n//\n// Because we may not trust the adb host, this filesystem maintains\n// the following invariant: each read of a given position returns the\n// same data as the first read at that position.  That is, once a\n// section of the file is read, future reads of that section return\n// the same data.  (Otherwise, a malicious adb host process could\n// return one set of bits when the package is read for signature\n// verification, and then different bits for when the package is\n// accessed by the installer.)  If the adb host returns something\n// different than it did on the first read, the reader of the file\n// will see their read fail with EINVAL.\n//\n// The other file, \"/sideload/exit\", is used to control the subprocess\n// that creates this filesystem.  Calling stat() on the exit file\n// causes the filesystem to be unmounted and the adb process on the\n// device shut down.\n//\n// Note that only the minimal set of file operations needed for these\n// two files is implemented.  In particular, you can't opendir() or\n// readdir() on the \"/sideload\" directory; ls on it won't work.\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include \"fuse.h\"\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/inotify.h>\n#include <sys/mount.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/statfs.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <unistd.h>\n\n#ifdef USE_MINCRYPT\n#include \"mincrypt/sha256.h\"\n#define  SHA256_DIGEST_LENGTH SHA256_DIGEST_SIZE\n#else\n#include <openssl/sha.h>\n#endif\n\n#include \"fuse_sideload.h\"\n\n#define PACKAGE_FILE_ID   (FUSE_ROOT_ID+1)\n#define EXIT_FLAG_ID      (FUSE_ROOT_ID+2)\n\n#define NO_STATUS         1\n#define NO_STATUS_EXIT    2\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\nstruct fuse_data {\n    int ffd;   // file descriptor for the fuse socket\n\n    struct provider_vtab* vtab;\n    void* cookie;\n\n    uint64_t file_size;     // bytes\n\n    uint32_t block_size;    // block size that the adb host is using to send the file to us\n    uint32_t file_blocks;   // file size in block_size blocks\n\n    uid_t uid;\n    gid_t gid;\n\n    uint32_t curr_block;    // cache the block most recently read from the host\n    uint8_t* block_data;\n\n    uint8_t* extra_block;   // another block of storage for reads that\n                            // span two blocks\n\n    uint8_t* hashes;        // SHA-256 hash of each block (all zeros\n                            // if block hasn't been read yet)\n};\n\nstatic void fuse_reply(struct fuse_data* fd, __u64 unique, const void *data, size_t len)\n{\n    struct fuse_out_header hdr;\n    struct iovec vec[2];\n    int res;\n\n    hdr.len = len + sizeof(hdr);\n    hdr.error = 0;\n    hdr.unique = unique;\n\n    vec[0].iov_base = &hdr;\n    vec[0].iov_len = sizeof(hdr);\n    vec[1].iov_base = /* const_cast */(void*)(data);\n    vec[1].iov_len = len;\n\n    res = writev(fd->ffd, vec, 2);\n    if (res < 0) {\n        printf(\"*** REPLY FAILED *** %s\\n\", strerror(errno));\n    }\n}\n\nstatic int handle_init(void* data, struct fuse_data* fd, const struct fuse_in_header* hdr) {\n    const struct fuse_init_in* req = reinterpret_cast<const struct fuse_init_in*>(data);\n    struct fuse_init_out out;\n    size_t fuse_struct_size;\n\n\n    /* Kernel 2.6.16 is the first stable kernel with struct fuse_init_out\n     * defined (fuse version 7.6). The structure is the same from 7.6 through\n     * 7.22. Beginning with 7.23, the structure increased in size and added\n     * new parameters.\n     */\n    if (req->major != FUSE_KERNEL_VERSION || req->minor < 6) {\n        printf(\"Fuse kernel version mismatch: Kernel version %d.%d, Expected at least %d.6\",\n               req->major, req->minor, FUSE_KERNEL_VERSION);\n        return -1;\n    }\n\n    out.minor = MIN(req->minor, FUSE_KERNEL_MINOR_VERSION);\n    fuse_struct_size = sizeof(out);\n#if defined(FUSE_COMPAT_22_INIT_OUT_SIZE)\n    /* FUSE_KERNEL_VERSION >= 23. */\n\n    /* If the kernel only works on minor revs older than or equal to 22,\n     * then use the older structure size since this code only uses the 7.22\n     * version of the structure. */\n    if (req->minor <= 22) {\n        fuse_struct_size = FUSE_COMPAT_22_INIT_OUT_SIZE;\n    }\n#endif\n\n    out.major = FUSE_KERNEL_VERSION;\n    out.max_readahead = req->max_readahead;\n    out.flags = 0;\n    out.max_background = 32;\n    out.congestion_threshold = 32;\n    out.max_write = 4096;\n    fuse_reply(fd, hdr->unique, &out, fuse_struct_size);\n\n    return NO_STATUS;\n}\n\nstatic void fill_attr(struct fuse_attr* attr, struct fuse_data* fd,\n                      uint64_t nodeid, uint64_t size, uint32_t mode) {\n    memset(attr, 0, sizeof(*attr));\n    attr->nlink = 1;\n    attr->uid = fd->uid;\n    attr->gid = fd->gid;\n    attr->blksize = 4096;\n\n    attr->ino = nodeid;\n    attr->size = size;\n    attr->blocks = (size == 0) ? 0 : (((size-1) / attr->blksize) + 1);\n    attr->mode = mode;\n}\n\nstatic int handle_getattr(void* /* data */, struct fuse_data* fd, const struct fuse_in_header* hdr) {\n    struct fuse_attr_out out;\n    memset(&out, 0, sizeof(out));\n    out.attr_valid = 10;\n\n    if (hdr->nodeid == FUSE_ROOT_ID) {\n        fill_attr(&(out.attr), fd, hdr->nodeid, 4096, S_IFDIR | 0555);\n    } else if (hdr->nodeid == PACKAGE_FILE_ID) {\n        fill_attr(&(out.attr), fd, PACKAGE_FILE_ID, fd->file_size, S_IFREG | 0444);\n    } else if (hdr->nodeid == EXIT_FLAG_ID) {\n        fill_attr(&(out.attr), fd, EXIT_FLAG_ID, 0, S_IFREG | 0);\n    } else {\n        return -ENOENT;\n    }\n\n    fuse_reply(fd, hdr->unique, &out, sizeof(out));\n    return (hdr->nodeid == EXIT_FLAG_ID) ? NO_STATUS_EXIT : NO_STATUS;\n}\n\nstatic int handle_lookup(void* data, struct fuse_data* fd,\n                         const struct fuse_in_header* hdr) {\n    struct fuse_entry_out out;\n    memset(&out, 0, sizeof(out));\n    out.entry_valid = 10;\n    out.attr_valid = 10;\n\n    if (strncmp(FUSE_SIDELOAD_HOST_FILENAME, reinterpret_cast<const char*>(data),\n                sizeof(FUSE_SIDELOAD_HOST_FILENAME)) == 0) {\n        out.nodeid = PACKAGE_FILE_ID;\n        out.generation = PACKAGE_FILE_ID;\n        fill_attr(&(out.attr), fd, PACKAGE_FILE_ID, fd->file_size, S_IFREG | 0444);\n    } else if (strncmp(FUSE_SIDELOAD_HOST_EXIT_FLAG, reinterpret_cast<const char*>(data),\n                       sizeof(FUSE_SIDELOAD_HOST_EXIT_FLAG)) == 0) {\n        out.nodeid = EXIT_FLAG_ID;\n        out.generation = EXIT_FLAG_ID;\n        fill_attr(&(out.attr), fd, EXIT_FLAG_ID, 0, S_IFREG | 0);\n    } else {\n        return -ENOENT;\n    }\n\n    fuse_reply(fd, hdr->unique, &out, sizeof(out));\n    return (out.nodeid == EXIT_FLAG_ID) ? NO_STATUS_EXIT : NO_STATUS;\n}\n\nstatic int handle_open(void* /* data */, struct fuse_data* fd, const struct fuse_in_header* hdr) {\n    if (hdr->nodeid == EXIT_FLAG_ID) return -EPERM;\n    if (hdr->nodeid != PACKAGE_FILE_ID) return -ENOENT;\n\n    struct fuse_open_out out;\n    memset(&out, 0, sizeof(out));\n    out.fh = 10;  // an arbitrary number; we always use the same handle\n    fuse_reply(fd, hdr->unique, &out, sizeof(out));\n    return NO_STATUS;\n}\n\nstatic int handle_flush(void* data, struct fuse_data* fd, const struct fuse_in_header* hdr) {\n    return 0;\n}\n\nstatic int handle_release(void* data, struct fuse_data* fd, const struct fuse_in_header* hdr) {\n    return 0;\n}\n\n// Fetch a block from the host into fd->curr_block and fd->block_data.\n// Returns 0 on successful fetch, negative otherwise.\nstatic int fetch_block(struct fuse_data* fd, uint32_t block) {\n    if (block == fd->curr_block) {\n        return 0;\n    }\n\n    if (block >= fd->file_blocks) {\n        memset(fd->block_data, 0, fd->block_size);\n        fd->curr_block = block;\n        return 0;\n    }\n\n    size_t fetch_size = fd->block_size;\n    if (block * fd->block_size + fetch_size > fd->file_size) {\n        // If we're reading the last (partial) block of the file,\n        // expect a shorter response from the host, and pad the rest\n        // of the block with zeroes.\n        fetch_size = fd->file_size - (block * fd->block_size);\n        memset(fd->block_data + fetch_size, 0, fd->block_size - fetch_size);\n    }\n\n    int result = fd->vtab->read_block(fd->cookie, block, fd->block_data, fetch_size);\n    if (result < 0) return result;\n\n    fd->curr_block = block;\n\n    // Verify the hash of the block we just got from the host.\n    //\n    // - If the hash of the just-received data matches the stored hash\n    //   for the block, accept it.\n    // - If the stored hash is all zeroes, store the new hash and\n    //   accept the block (this is the first time we've read this\n    //   block).\n    // - Otherwise, return -EINVAL for the read.\n\n    uint8_t hash[SHA256_DIGEST_LENGTH];\n#ifdef USE_MINCRYPT\n    SHA256_hash(fd->block_data, fd->block_size, hash);\n#else\n    SHA256(fd->block_data, fd->block_size, hash);\n#endif\n    uint8_t* blockhash = fd->hashes + block * SHA256_DIGEST_LENGTH;\n    if (memcmp(hash, blockhash, SHA256_DIGEST_LENGTH) == 0) {\n        return 0;\n    }\n\n    int i;\n    for (i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        if (blockhash[i] != 0) {\n            fd->curr_block = -1;\n            return -EIO;\n        }\n    }\n\n    memcpy(blockhash, hash, SHA256_DIGEST_LENGTH);\n    return 0;\n}\n\nstatic int handle_read(void* data, struct fuse_data* fd, const struct fuse_in_header* hdr) {\n    const struct fuse_read_in* req = reinterpret_cast<const struct fuse_read_in*>(data);\n    struct fuse_out_header outhdr;\n    struct iovec vec[3];\n    int vec_used;\n    int result;\n\n    if (hdr->nodeid != PACKAGE_FILE_ID) return -ENOENT;\n\n    uint64_t offset = req->offset;\n    uint32_t size = req->size;\n\n    // The docs on the fuse kernel interface are vague about what to\n    // do when a read request extends past the end of the file.  We\n    // can return a short read -- the return structure does include a\n    // length field -- but in testing that caused the program using\n    // the file to segfault.  (I speculate that this is due to the\n    // reading program accessing it via mmap; maybe mmap dislikes when\n    // you return something short of a whole page?)  To fix this we\n    // zero-pad reads that extend past the end of the file so we're\n    // always returning exactly as many bytes as were requested.\n    // (Users of the mapped file have to know its real length anyway.)\n\n    outhdr.len = sizeof(outhdr) + size;\n    outhdr.error = 0;\n    outhdr.unique = hdr->unique;\n    vec[0].iov_base = &outhdr;\n    vec[0].iov_len = sizeof(outhdr);\n\n    uint32_t block = offset / fd->block_size;\n    result = fetch_block(fd, block);\n    if (result != 0) return result;\n\n    // Two cases:\n    //\n    //   - the read request is entirely within this block.  In this\n    //     case we can reply immediately.\n    //\n    //   - the read request goes over into the next block.  Note that\n    //     since we mount the filesystem with max_read=block_size, a\n    //     read can never span more than two blocks.  In this case we\n    //     copy the block to extra_block and issue a fetch for the\n    //     following block.\n\n    uint32_t block_offset = offset - (block * fd->block_size);\n\n    if (size + block_offset <= fd->block_size) {\n        // First case: the read fits entirely in the first block.\n\n        vec[1].iov_base = fd->block_data + block_offset;\n        vec[1].iov_len = size;\n        vec_used = 2;\n    } else {\n        // Second case: the read spills over into the next block.\n\n        memcpy(fd->extra_block, fd->block_data + block_offset,\n               fd->block_size - block_offset);\n        vec[1].iov_base = fd->extra_block;\n        vec[1].iov_len = fd->block_size - block_offset;\n\n        result = fetch_block(fd, block+1);\n        if (result != 0) return result;\n        vec[2].iov_base = fd->block_data;\n        vec[2].iov_len = size - vec[1].iov_len;\n        vec_used = 3;\n    }\n\n    if (writev(fd->ffd, vec, vec_used) < 0) {\n        printf(\"*** READ REPLY FAILED: %s ***\\n\", strerror(errno));\n    }\n    return NO_STATUS;\n}\n\nint run_fuse_sideload(struct provider_vtab* vtab, void* cookie,\n                      uint64_t file_size, uint32_t block_size)\n{\n    int result;\n\n    // If something's already mounted on our mountpoint, try to remove\n    // it.  (Mostly in case of a previous abnormal exit.)\n    umount2(FUSE_SIDELOAD_HOST_MOUNTPOINT, MNT_FORCE);\n\n    if (block_size < 1024) {\n        fprintf(stderr, \"block size (%u) is too small\\n\", block_size);\n        return -1;\n    }\n    if (block_size > (1<<22)) {   // 4 MiB\n        fprintf(stderr, \"block size (%u) is too large\\n\", block_size);\n        return -1;\n    }\n\n    struct fuse_data fd;\n    memset(&fd, 0, sizeof(fd));\n    fd.vtab = vtab;\n    fd.cookie = cookie;\n    fd.file_size = file_size;\n    fd.block_size = block_size;\n    fd.file_blocks = (file_size == 0) ? 0 : (((file_size-1) / block_size) + 1);\n\n    if (fd.file_blocks > (1<<18)) {\n        fprintf(stderr, \"file has too many blocks (%u)\\n\", fd.file_blocks);\n        result = -1;\n        goto done;\n    }\n\n    fd.hashes = (uint8_t*)calloc(fd.file_blocks, SHA256_DIGEST_LENGTH);\n    if (fd.hashes == NULL) {\n        fprintf(stderr, \"failed to allocate %d bites for hashes\\n\",\n                fd.file_blocks * SHA256_DIGEST_LENGTH);\n        result = -1;\n        goto done;\n    }\n\n    fd.uid = getuid();\n    fd.gid = getgid();\n\n    fd.curr_block = -1;\n    fd.block_data = (uint8_t*)malloc(block_size);\n    if (fd.block_data == NULL) {\n        fprintf(stderr, \"failed to allocate %d bites for block_data\\n\", block_size);\n        result = -1;\n        goto done;\n    }\n    fd.extra_block = (uint8_t*)malloc(block_size);\n    if (fd.extra_block == NULL) {\n        fprintf(stderr, \"failed to allocate %d bites for extra_block\\n\", block_size);\n        result = -1;\n        goto done;\n    }\n\n    fd.ffd = open(\"/dev/fuse\", O_RDWR);\n    if (fd.ffd < 0) {\n        perror(\"open /dev/fuse\");\n        result = -1;\n        goto done;\n    }\n\n    char opts[256];\n    snprintf(opts, sizeof(opts),\n             (\"fd=%d,user_id=%d,group_id=%d,max_read=%u,\"\n              \"allow_other,rootmode=040000\"),\n             fd.ffd, fd.uid, fd.gid, block_size);\n\n    result = mount(\"/dev/fuse\", FUSE_SIDELOAD_HOST_MOUNTPOINT,\n                   \"fuse\", MS_NOSUID | MS_NODEV | MS_RDONLY | MS_NOEXEC, opts);\n    if (result < 0) {\n        perror(\"mount\");\n        goto done;\n    }\n    uint8_t request_buffer[sizeof(struct fuse_in_header) + PATH_MAX*8];\n    for (;;) {\n        ssize_t len = TEMP_FAILURE_RETRY(read(fd.ffd, request_buffer, sizeof(request_buffer)));\n        if (len == -1) {\n            perror(\"read request\");\n            if (errno == ENODEV) {\n                result = -1;\n                break;\n            }\n            continue;\n        }\n\n        if ((size_t)len < sizeof(struct fuse_in_header)) {\n            fprintf(stderr, \"request too short: len=%zu\\n\", (size_t)len);\n            continue;\n        }\n\n        struct fuse_in_header* hdr = (struct fuse_in_header*) request_buffer;\n        void* data = request_buffer + sizeof(struct fuse_in_header);\n\n        result = -ENOSYS;\n\n        switch (hdr->opcode) {\n             case FUSE_INIT:\n                result = handle_init(data, &fd, hdr);\n                break;\n\n             case FUSE_LOOKUP:\n                result = handle_lookup(data, &fd, hdr);\n                break;\n\n            case FUSE_GETATTR:\n                result = handle_getattr(data, &fd, hdr);\n                break;\n\n            case FUSE_OPEN:\n                result = handle_open(data, &fd, hdr);\n                break;\n\n            case FUSE_READ:\n                result = handle_read(data, &fd, hdr);\n                break;\n\n            case FUSE_FLUSH:\n                result = handle_flush(data, &fd, hdr);\n                break;\n\n            case FUSE_RELEASE:\n                result = handle_release(data, &fd, hdr);\n                break;\n\n            default:\n                fprintf(stderr, \"unknown fuse request opcode %d\\n\", hdr->opcode);\n                break;\n        }\n\n        if (result == NO_STATUS_EXIT) {\n            result = 0;\n            break;\n        }\n\n        if (result != NO_STATUS) {\n            struct fuse_out_header outhdr;\n            outhdr.len = sizeof(outhdr);\n            outhdr.error = result;\n            outhdr.unique = hdr->unique;\n            TEMP_FAILURE_RETRY(write(fd.ffd, &outhdr, sizeof(outhdr)));\n        }\n    }\n\n  done:\n    fd.vtab->close(fd.cookie);\n\n    result = umount2(FUSE_SIDELOAD_HOST_MOUNTPOINT, MNT_DETACH);\n    if (result < 0) {\n        printf(\"fuse_sideload umount failed: %s\\n\", strerror(errno));\n    }\n\n    if (fd.ffd) close(fd.ffd);\n    free(fd.hashes);\n    free(fd.block_data);\n    free(fd.extra_block);\n\n    return result;\n}\n\nextern \"C\" int run_old_fuse_sideload(struct provider_vtab* vtab, void* cookie,\n                      uint64_t file_size, uint32_t block_size)\n{\n    return run_fuse_sideload(vtab, cookie, file_size, block_size);\n}\n"
        },
        {
          "name": "fuse_sideload22.h",
          "type": "blob",
          "size": 1.5810546875,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __FUSE_SIDELOAD22_H\n#define __FUSE_SIDELOAD22_H\n\n// define the filenames created by the sideload FUSE filesystem\n#define FUSE_SIDELOAD_HOST_MOUNTPOINT \"/sideload\"\n#define FUSE_SIDELOAD_HOST_FILENAME \"package.zip\"\n#define FUSE_SIDELOAD_HOST_PATHNAME (FUSE_SIDELOAD_HOST_MOUNTPOINT \"/\" FUSE_SIDELOAD_HOST_FILENAME)\n#define FUSE_SIDELOAD_HOST_EXIT_FLAG \"exit\"\n#define FUSE_SIDELOAD_HOST_EXIT_PATHNAME (FUSE_SIDELOAD_HOST_MOUNTPOINT \"/\" FUSE_SIDELOAD_HOST_EXIT_FLAG)\n\nstruct provider_vtab {\n    // read a block\n    int (*read_block)(void* cookie, uint32_t block, uint8_t* buffer, uint32_t fetch_size);\n\n    // close down\n    void (*close)(void* cookie);\n};\n\nint run_fuse_sideload(struct provider_vtab* vtab, void* cookie,\n                      uint64_t file_size, uint32_t block_size);\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nint run_old_fuse_sideload(struct provider_vtab* vtab, void* cookie,\n                      uint64_t file_size, uint32_t block_size);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "gpt",
          "type": "tree",
          "content": null
        },
        {
          "name": "gui",
          "type": "tree",
          "content": null
        },
        {
          "name": "htcdumlock",
          "type": "tree",
          "content": null
        },
        {
          "name": "infomanager.cpp",
          "type": "blob",
          "size": 5.4658203125,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <string>\n#include <map>\n#include <fstream>\n#include <sstream>\n\n#include \"infomanager.hpp\"\n#include \"twcommon.h\"\n#include \"partitions.hpp\"\n#include \"set_metadata.h\"\n\nusing namespace std;\n\nInfoManager::InfoManager() {\n\tfile_version = 0;\n\tis_const = false;\n}\n\nInfoManager::InfoManager(const string& filename) {\n\tfile_version = 0;\n\tis_const = false;\n\tSetFile(filename);\n}\n\nInfoManager::~InfoManager(void) {\n\tClear();\n}\n\nvoid InfoManager::SetFile(const string& filename) {\n\tFile = filename;\n}\n\nvoid InfoManager::SetFileVersion(int version) {\n\tfile_version = version;\n}\n\nvoid InfoManager::SetConst(void) {\n\tis_const = true;\n}\n\nvoid InfoManager::Clear(void) {\n\tmValues.clear();\n}\n\nint InfoManager::LoadValues(void) {\n\tstring str;\n\n\t// Read in the file, if possible\n\tFILE* in = fopen(File.c_str(), \"rb\");\n\tif (!in) {\n\t\tLOGINFO(\"InfoManager file '%s' not found.\\n\", File.c_str());\n\t\treturn -1;\n\t} else {\n\t\tLOGINFO(\"InfoManager loading from '%s'.\\n\", File.c_str());\n\t}\n\n\tif (file_version) {\n\t\tint read_file_version;\n\t\tif (fread(&read_file_version, 1, sizeof(int), in) != sizeof(int))\n\t\t\tgoto error;\n\t\tif (read_file_version != file_version) {\n\t\t\tLOGINFO(\"InfoManager file version has changed, not reading file\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\twhile (!feof(in)) {\n\t\tstring Name;\n\t\tstring Value;\n\t\tunsigned short length;\n\t\tchar array[513];\n\n\t\tif (fread(&length, 1, sizeof(unsigned short), in) != sizeof(unsigned short))\tgoto error;\n\t\tif (length >= 512)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgoto error;\n\t\tif (fread(array, 1, length, in) != length)\t\t\t\t\t\t\t\t\t\tgoto error;\n\t\tarray[length+1] = '\\0';\n\t\tName = array;\n\n\t\tif (fread(&length, 1, sizeof(unsigned short), in) != sizeof(unsigned short))\tgoto error;\n\t\tif (length >= 512)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgoto error;\n\t\tif (fread(array, 1, length, in) != length)\t\t\t\t\t\t\t\t\t\tgoto error;\n\t\tarray[length+1] = '\\0';\n\t\tValue = array;\n\n\t\tmap<string, string>::iterator pos;\n\n\t\tpos = mValues.find(Name);\n\t\tif (pos != mValues.end()) {\n\t\t\tpos->second = Value;\n\t\t} else {\n\t\t\tmValues.insert(make_pair(Name, Value));\n\t\t}\n\t}\nerror:\n\tfclose(in);\n\treturn 0;\n}\n\nint InfoManager::SaveValues(void) {\n\tif (File.empty())\n\t\treturn -1;\n\n\tPartitionManager.Mount_By_Path(File, true);\n\tLOGINFO(\"InfoManager saving '%s'\\n\", File.c_str());\n\tFILE* out = fopen(File.c_str(), \"wb\");\n\tif (!out)\n\t\treturn -1;\n\n\tif (file_version) {\n\t\tfwrite(&file_version, 1, sizeof(int), out);\n\t}\n\n\tmap<string, string>::iterator iter;\n\tfor (iter = mValues.begin(); iter != mValues.end(); ++iter) {\n\t\tunsigned short length = (unsigned short) iter->first.length() + 1;\n\t\tfwrite(&length, 1, sizeof(unsigned short), out);\n\t\tfwrite(iter->first.c_str(), 1, length, out);\n\t\tlength = (unsigned short) iter->second.length() + 1;\n\t\tfwrite(&length, 1, sizeof(unsigned short), out);\n\t\tfwrite(iter->second.c_str(), 1, length, out);\n\t}\n\tfclose(out);\n\ttw_set_default_metadata(File.c_str());\n\treturn 0;\n}\n\nint InfoManager::GetValue(const string& varName, string& value) {\n\tstring localStr = varName;\n\n\tmap<string, string>::iterator pos;\n\tpos = mValues.find(localStr);\n\tif (pos == mValues.end())\n\t\treturn -1;\n\n\tvalue = pos->second;\n\treturn 0;\n}\n\nint InfoManager::GetValue(const string& varName, int& value) {\n\tstring data;\n\n\tif (GetValue(varName,data) != 0)\n\t\treturn -1;\n\n\tvalue = atoi(data.c_str());\n\treturn 0;\n}\n\nint InfoManager::GetValue(const string& varName, float& value) {\n\tstring data;\n\n\tif (GetValue(varName,data) != 0)\n\t\treturn -1;\n\n\tvalue = atof(data.c_str());\n\treturn 0;\n}\n\nunsigned long long InfoManager::GetValue(const string& varName, unsigned long long& value) {\n\tstring data;\n\n\tif (GetValue(varName,data) != 0)\n\t\treturn -1;\n\n\tvalue = strtoull(data.c_str(), NULL, 10);\n\treturn 0;\n}\n\n// This function will return an empty string if the value doesn't exist\nstring InfoManager::GetStrValue(const string& varName) {\n\tstring retVal;\n\n\tGetValue(varName, retVal);\n\treturn retVal;\n}\n\n// This function will return 0 if the value doesn't exist\nint InfoManager::GetIntValue(const string& varName) {\n\tstring retVal;\n\tGetValue(varName, retVal);\n\treturn atoi(retVal.c_str());\n}\n\nint InfoManager::SetValue(const string& varName, const string& value) {\n\t// Don't allow empty names or numerical starting values\n\tif (varName.empty() || (varName[0] >= '0' && varName[0] <= '9'))\n\t\treturn -1;\n\n\tmap<string, string>::iterator pos;\n\tpos = mValues.find(varName);\n\tif (pos == mValues.end())\n\t\tmValues.insert(make_pair(varName, value));\n\telse if (!is_const)\n\t\tpos->second = value;\n\n\treturn 0;\n}\n\nint InfoManager::SetValue(const string& varName, const int value) {\n\tostringstream valStr;\n\tvalStr << value;\n\treturn SetValue(varName, valStr.str());\n}\n\nint InfoManager::SetValue(const string& varName, const float value) {\n\tostringstream valStr;\n\tvalStr << value;\n\treturn SetValue(varName, valStr.str());\n}\n\nint InfoManager::SetValue(const string& varName, const unsigned long long& value) {\n\tostringstream valStr;\n\tvalStr << value;\n\treturn SetValue(varName, valStr.str());\n}\n"
        },
        {
          "name": "infomanager.hpp",
          "type": "blob",
          "size": 1.796875,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _INFOMANAGER_HPP_HEADER\n#define _INFOMANAGER_HPP_HEADER\n\n#include <string>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nclass InfoManager\n{\npublic:\n\tInfoManager();\n\texplicit InfoManager(const string& filename);\n\tvirtual ~InfoManager();\n\tvoid SetFile(const string& filename);\n\tvoid SetFileVersion(int version);\n\tvoid SetConst();\n\tvoid Clear();\n\tint LoadValues();\n\tint SaveValues();\n\n\t// Core get routines\n\tint GetValue(const string& varName, string& value);\n\tint GetValue(const string& varName, int& value);\n\tint GetValue(const string& varName, float& value);\n\tunsigned long long GetValue(const string& varName, unsigned long long& value);\n\n\tstring GetStrValue(const string& varName);\n\tint GetIntValue(const string& varName);\n\n\t// Core set routines\n\tint SetValue(const string& varName, const string& value);\n\tint SetValue(const string& varName, const int value);\n\tint SetValue(const string& varName, const float value);\n\tint SetValue(const string& varName, const unsigned long long& value);\n\nprivate:\n\tstring File;\n\tmap<string, string> mValues;\n\tint file_version;\n\tbool is_const;\n\n};\n\n#endif // _DATAMANAGER_HPP_HEADER\n\n"
        },
        {
          "name": "injecttwrp",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.cpp",
          "type": "blob",
          "size": 24.83203125,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"install.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <functional>\n#include <limits>\n#include <map>\n#include <mutex>\n#include <string>\n#include <thread>\n#include <vector>\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/parsedouble.h>\n#include <android-base/parseint.h>\n#include <android-base/properties.h>\n#include <android-base/stringprintf.h>\n#include <android-base/strings.h>\n#include <vintf/VintfObjectRecovery.h>\n#include <ziparchive/zip_archive.h>\n\n#include \"common.h\"\n#include \"otautil/SysUtil.h\"\n#include \"otautil/ThermalUtil.h\"\n#include \"otautil/error_code.h\"\n#include \"private/install.h\"\n#include \"roots.h\"\n#include \"ui.h\"\n#include \"verifier.h\"\n\nusing namespace std::chrono_literals;\n\n// Default allocation of progress bar segments to operations\nstatic constexpr int VERIFICATION_PROGRESS_TIME = 60;\nstatic constexpr float VERIFICATION_PROGRESS_FRACTION = 0.25;\n\nstatic std::condition_variable finish_log_temperature;\n\n// This function parses and returns the build.version.incremental\nstatic std::string parse_build_number(const std::string& str) {\n    size_t pos = str.find('=');\n    if (pos != std::string::npos) {\n        return android::base::Trim(str.substr(pos+1));\n    }\n\n    LOG(ERROR) << \"Failed to parse build number in \" << str;\n    return \"\";\n}\n\nbool read_metadata_from_package(ZipArchiveHandle zip, std::string* metadata) {\n  CHECK(metadata != nullptr);\n\n  static constexpr const char* METADATA_PATH = \"META-INF/com/android/metadata\";\n  ZipString path(METADATA_PATH);\n  ZipEntry entry;\n  if (FindEntry(zip, path, &entry) != 0) {\n    LOG(ERROR) << \"Failed to find \" << METADATA_PATH;\n    return false;\n  }\n\n  uint32_t length = entry.uncompressed_length;\n  metadata->resize(length, '\\0');\n  int32_t err = ExtractToMemory(zip, &entry, reinterpret_cast<uint8_t*>(&(*metadata)[0]), length);\n  if (err != 0) {\n    LOG(ERROR) << \"Failed to extract \" << METADATA_PATH << \": \" << ErrorCodeString(err);\n    return false;\n  }\n  return true;\n}\n\n// Read the build.version.incremental of src/tgt from the metadata and log it to last_install.\nstatic void read_source_target_build(ZipArchiveHandle zip, std::vector<std::string>* log_buffer) {\n  std::string metadata;\n  if (!read_metadata_from_package(zip, &metadata)) {\n    return;\n  }\n  // Examples of the pre-build and post-build strings in metadata:\n  //   pre-build-incremental=2943039\n  //   post-build-incremental=2951741\n  std::vector<std::string> lines = android::base::Split(metadata, \"\\n\");\n  for (const std::string& line : lines) {\n    std::string str = android::base::Trim(line);\n    if (android::base::StartsWith(str, \"pre-build-incremental\")) {\n      std::string source_build = parse_build_number(str);\n      if (!source_build.empty()) {\n        log_buffer->push_back(\"source_build: \" + source_build);\n      }\n    } else if (android::base::StartsWith(str, \"post-build-incremental\")) {\n      std::string target_build = parse_build_number(str);\n      if (!target_build.empty()) {\n        log_buffer->push_back(\"target_build: \" + target_build);\n      }\n    }\n  }\n}\n\n#ifdef AB_OTA_UPDATER\n\n// Parses the metadata of the OTA package in |zip| and checks whether we are\n// allowed to accept this A/B package. Downgrading is not allowed unless\n// explicitly enabled in the package and only for incremental packages.\nstatic int check_newer_ab_build(ZipArchiveHandle zip) {\n  std::string metadata_str;\n  if (!read_metadata_from_package(zip, &metadata_str)) {\n    return INSTALL_CORRUPT;\n  }\n  std::map<std::string, std::string> metadata;\n  for (const std::string& line : android::base::Split(metadata_str, \"\\n\")) {\n    size_t eq = line.find('=');\n    if (eq != std::string::npos) {\n      metadata[line.substr(0, eq)] = line.substr(eq + 1);\n    }\n  }\n\n  std::string value = android::base::GetProperty(\"ro.product.device\", \"\");\n  const std::string& pkg_device = metadata[\"pre-device\"];\n  if (pkg_device != value || pkg_device.empty()) {\n    LOG(ERROR) << \"Package is for product \" << pkg_device << \" but expected \" << value;\n    return INSTALL_ERROR;\n  }\n\n  // We allow the package to not have any serialno; and we also allow it to carry multiple serial\n  // numbers split by \"|\"; e.g. serialno=serialno1|serialno2|serialno3 ... We will fail the\n  // verification if the device's serialno doesn't match any of these carried numbers.\n  value = android::base::GetProperty(\"ro.serialno\", \"\");\n  const std::string& pkg_serial_no = metadata[\"serialno\"];\n  if (!pkg_serial_no.empty()) {\n    bool match = false;\n    for (const std::string& number : android::base::Split(pkg_serial_no, \"|\")) {\n      if (value == android::base::Trim(number)) {\n        match = true;\n        break;\n      }\n    }\n    if (!match) {\n      LOG(ERROR) << \"Package is for serial \" << pkg_serial_no;\n      return INSTALL_ERROR;\n    }\n  }\n\n  if (metadata[\"ota-type\"] != \"AB\") {\n    LOG(ERROR) << \"Package is not A/B\";\n    return INSTALL_ERROR;\n  }\n\n  // Incremental updates should match the current build.\n  value = android::base::GetProperty(\"ro.build.version.incremental\", \"\");\n  const std::string& pkg_pre_build = metadata[\"pre-build-incremental\"];\n  if (!pkg_pre_build.empty() && pkg_pre_build != value) {\n    LOG(ERROR) << \"Package is for source build \" << pkg_pre_build << \" but expected \" << value;\n    return INSTALL_ERROR;\n  }\n\n  value = android::base::GetProperty(\"ro.build.fingerprint\", \"\");\n  const std::string& pkg_pre_build_fingerprint = metadata[\"pre-build\"];\n  if (!pkg_pre_build_fingerprint.empty() && pkg_pre_build_fingerprint != value) {\n    LOG(ERROR) << \"Package is for source build \" << pkg_pre_build_fingerprint << \" but expected \"\n               << value;\n    return INSTALL_ERROR;\n  }\n\n  return 0;\n}\n\nint update_binary_command(const std::string& package, ZipArchiveHandle zip,\n                          const std::string& binary_path, int /* retry_count */, int status_fd,\n                          std::vector<std::string>* cmd) {\n  CHECK(cmd != nullptr);\n  int ret = check_newer_ab_build(zip);\n  if (ret != 0) {\n    return ret;\n  }\n\n  // For A/B updates we extract the payload properties to a buffer and obtain the RAW payload offset\n  // in the zip file.\n  static constexpr const char* AB_OTA_PAYLOAD_PROPERTIES = \"payload_properties.txt\";\n  ZipString property_name(AB_OTA_PAYLOAD_PROPERTIES);\n  ZipEntry properties_entry;\n  if (FindEntry(zip, property_name, &properties_entry) != 0) {\n    LOG(ERROR) << \"Failed to find \" << AB_OTA_PAYLOAD_PROPERTIES;\n    return INSTALL_CORRUPT;\n  }\n  uint32_t properties_entry_length = properties_entry.uncompressed_length;\n  std::vector<uint8_t> payload_properties(properties_entry_length);\n  int32_t err =\n      ExtractToMemory(zip, &properties_entry, payload_properties.data(), properties_entry_length);\n  if (err != 0) {\n    LOG(ERROR) << \"Failed to extract \" << AB_OTA_PAYLOAD_PROPERTIES << \": \" << ErrorCodeString(err);\n    return INSTALL_CORRUPT;\n  }\n\n  static constexpr const char* AB_OTA_PAYLOAD = \"payload.bin\";\n  ZipString payload_name(AB_OTA_PAYLOAD);\n  ZipEntry payload_entry;\n  if (FindEntry(zip, payload_name, &payload_entry) != 0) {\n    LOG(ERROR) << \"Failed to find \" << AB_OTA_PAYLOAD;\n    return INSTALL_CORRUPT;\n  }\n  long payload_offset = payload_entry.offset;\n  *cmd = {\n    binary_path,\n    \"--payload=file://\" + package,\n    android::base::StringPrintf(\"--offset=%ld\", payload_offset),\n    \"--headers=\" + std::string(payload_properties.begin(), payload_properties.end()),\n    android::base::StringPrintf(\"--status_fd=%d\", status_fd),\n  };\n  return 0;\n}\n\n#else  // !AB_OTA_UPDATER\n\nint update_binary_command(const std::string& package, ZipArchiveHandle zip,\n                          const std::string& binary_path, int retry_count, int status_fd,\n                          std::vector<std::string>* cmd) {\n  CHECK(cmd != nullptr);\n\n  // On traditional updates we extract the update binary from the package.\n  static constexpr const char* UPDATE_BINARY_NAME = \"META-INF/com/google/android/update-binary\";\n  ZipString binary_name(UPDATE_BINARY_NAME);\n  ZipEntry binary_entry;\n  if (FindEntry(zip, binary_name, &binary_entry) != 0) {\n    LOG(ERROR) << \"Failed to find update binary \" << UPDATE_BINARY_NAME;\n    return INSTALL_CORRUPT;\n  }\n\n  unlink(binary_path.c_str());\n  int fd = open(binary_path.c_str(), O_CREAT | O_WRONLY | O_TRUNC | O_CLOEXEC, 0755);\n  if (fd == -1) {\n    PLOG(ERROR) << \"Failed to create \" << binary_path;\n    return INSTALL_ERROR;\n  }\n\n  int32_t error = ExtractEntryToFile(zip, &binary_entry, fd);\n  close(fd);\n  if (error != 0) {\n    LOG(ERROR) << \"Failed to extract \" << UPDATE_BINARY_NAME << \": \" << ErrorCodeString(error);\n    return INSTALL_ERROR;\n  }\n\n  *cmd = {\n    binary_path,\n    std::to_string(kRecoveryApiVersion),\n    std::to_string(status_fd),\n    package,\n  };\n  if (retry_count > 0) {\n    cmd->push_back(\"retry\");\n  }\n  return 0;\n}\n#endif  // !AB_OTA_UPDATER\n\nstatic void log_max_temperature(int* max_temperature, const std::atomic<bool>& logger_finished) {\n  CHECK(max_temperature != nullptr);\n  std::mutex mtx;\n  std::unique_lock<std::mutex> lck(mtx);\n  while (!logger_finished.load() &&\n         finish_log_temperature.wait_for(lck, 20s) == std::cv_status::timeout) {\n    *max_temperature = std::max(*max_temperature, GetMaxValueFromThermalZone());\n  }\n}\n\n// If the package contains an update binary, extract it and run it.\nstatic int try_update_binary(const std::string& package, ZipArchiveHandle zip, bool* wipe_cache,\n                             std::vector<std::string>* log_buffer, int retry_count,\n                             int* max_temperature) {\n  read_source_target_build(zip, log_buffer);\n\n  int pipefd[2];\n  pipe(pipefd);\n\n  std::vector<std::string> args;\n#ifdef AB_OTA_UPDATER\n  int ret = update_binary_command(package, zip, \"/sbin/update_engine_sideload\", retry_count,\n                                  pipefd[1], &args);\n#else\n  int ret = update_binary_command(package, zip, \"/tmp/update-binary\", retry_count, pipefd[1],\n                                  &args);\n#endif\n  if (ret) {\n    close(pipefd[0]);\n    close(pipefd[1]);\n    log_buffer->push_back(android::base::StringPrintf(\"error: %d\", kUpdateBinaryCommandFailure));\n    return ret;\n  }\n\n  // When executing the update binary contained in the package, the\n  // arguments passed are:\n  //\n  //   - the version number for this interface\n  //\n  //   - an FD to which the program can write in order to update the\n  //     progress bar.  The program can write single-line commands:\n  //\n  //        progress <frac> <secs>\n  //            fill up the next <frac> part of of the progress bar\n  //            over <secs> seconds.  If <secs> is zero, use\n  //            set_progress commands to manually control the\n  //            progress of this segment of the bar.\n  //\n  //        set_progress <frac>\n  //            <frac> should be between 0.0 and 1.0; sets the\n  //            progress bar within the segment defined by the most\n  //            recent progress command.\n  //\n  //        ui_print <string>\n  //            display <string> on the screen.\n  //\n  //        wipe_cache\n  //            a wipe of cache will be performed following a successful\n  //            installation.\n  //\n  //        clear_display\n  //            turn off the text display.\n  //\n  //        enable_reboot\n  //            packages can explicitly request that they want the user\n  //            to be able to reboot during installation (useful for\n  //            debugging packages that don't exit).\n  //\n  //        retry_update\n  //            updater encounters some issue during the update. It requests\n  //            a reboot to retry the same package automatically.\n  //\n  //        log <string>\n  //            updater requests logging the string (e.g. cause of the\n  //            failure).\n  //\n  //   - the name of the package zip file.\n  //\n  //   - an optional argument \"retry\" if this update is a retry of a failed\n  //   update attempt.\n  //\n\n  // Convert the vector to a NULL-terminated char* array suitable for execv.\n  const char* chr_args[args.size() + 1];\n  chr_args[args.size()] = nullptr;\n  for (size_t i = 0; i < args.size(); i++) {\n    chr_args[i] = args[i].c_str();\n  }\n\n  pid_t pid = fork();\n\n  if (pid == -1) {\n    close(pipefd[0]);\n    close(pipefd[1]);\n    PLOG(ERROR) << \"Failed to fork update binary\";\n    log_buffer->push_back(android::base::StringPrintf(\"error: %d\", kForkUpdateBinaryFailure));\n    return INSTALL_ERROR;\n  }\n\n  if (pid == 0) {\n    umask(022);\n    close(pipefd[0]);\n    execv(chr_args[0], const_cast<char**>(chr_args));\n    // Bug: 34769056\n    // We shouldn't use LOG/PLOG in the forked process, since they may cause\n    // the child process to hang. This deadlock results from an improperly\n    // copied mutex in the ui functions.\n    fprintf(stdout, \"E:Can't run %s (%s)\\n\", chr_args[0], strerror(errno));\n    _exit(EXIT_FAILURE);\n  }\n  close(pipefd[1]);\n\n  std::atomic<bool> logger_finished(false);\n  std::thread temperature_logger(log_max_temperature, max_temperature, std::ref(logger_finished));\n\n  *wipe_cache = false;\n  bool retry_update = false;\n\n  char buffer[1024];\n  FILE* from_child = fdopen(pipefd[0], \"r\");\n  while (fgets(buffer, sizeof(buffer), from_child) != nullptr) {\n    std::string line(buffer);\n    size_t space = line.find_first_of(\" \\n\");\n    std::string command(line.substr(0, space));\n    if (command.empty()) continue;\n\n    // Get rid of the leading and trailing space and/or newline.\n    std::string args = space == std::string::npos ? \"\" : android::base::Trim(line.substr(space));\n\n    if (command == \"progress\") {\n      std::vector<std::string> tokens = android::base::Split(args, \" \");\n      double fraction;\n      int seconds;\n      if (tokens.size() == 2 && android::base::ParseDouble(tokens[0].c_str(), &fraction) &&\n          android::base::ParseInt(tokens[1], &seconds)) {\n        ui->ShowProgress(fraction * (1 - VERIFICATION_PROGRESS_FRACTION), seconds);\n      } else {\n        LOG(ERROR) << \"invalid \\\"progress\\\" parameters: \" << line;\n      }\n    } else if (command == \"set_progress\") {\n      std::vector<std::string> tokens = android::base::Split(args, \" \");\n      double fraction;\n      if (tokens.size() == 1 && android::base::ParseDouble(tokens[0].c_str(), &fraction)) {\n        ui->SetProgress(fraction);\n      } else {\n        LOG(ERROR) << \"invalid \\\"set_progress\\\" parameters: \" << line;\n      }\n    } else if (command == \"ui_print\") {\n      ui->PrintOnScreenOnly(\"%s\\n\", args.c_str());\n      fflush(stdout);\n    } else if (command == \"wipe_cache\") {\n      *wipe_cache = true;\n    } else if (command == \"clear_display\") {\n      ui->SetBackground(RecoveryUI::NONE);\n    } else if (command == \"enable_reboot\") {\n      // packages can explicitly request that they want the user\n      // to be able to reboot during installation (useful for\n      // debugging packages that don't exit).\n      ui->SetEnableReboot(true);\n    } else if (command == \"retry_update\") {\n      retry_update = true;\n    } else if (command == \"log\") {\n      if (!args.empty()) {\n        // Save the logging request from updater and write to last_install later.\n        log_buffer->push_back(args);\n      } else {\n        LOG(ERROR) << \"invalid \\\"log\\\" parameters: \" << line;\n      }\n    } else {\n      LOG(ERROR) << \"unknown command [\" << command << \"]\";\n    }\n  }\n  fclose(from_child);\n\n  int status;\n  waitpid(pid, &status, 0);\n\n  logger_finished.store(true);\n  finish_log_temperature.notify_one();\n  temperature_logger.join();\n\n  if (retry_update) {\n    return INSTALL_RETRY;\n  }\n  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n    LOG(ERROR) << \"Error in \" << package << \" (Status \" << WEXITSTATUS(status) << \")\";\n    return INSTALL_ERROR;\n  }\n\n  return INSTALL_SUCCESS;\n}\n\n// Verifes the compatibility info in a Treble-compatible package. Returns true directly if the\n// entry doesn't exist. Note that the compatibility info is packed in a zip file inside the OTA\n// package.\nbool verify_package_compatibility(ZipArchiveHandle package_zip) {\n  LOG(INFO) << \"Verifying package compatibility...\";\n\n  static constexpr const char* COMPATIBILITY_ZIP_ENTRY = \"compatibility.zip\";\n  ZipString compatibility_entry_name(COMPATIBILITY_ZIP_ENTRY);\n  ZipEntry compatibility_entry;\n  if (FindEntry(package_zip, compatibility_entry_name, &compatibility_entry) != 0) {\n    LOG(INFO) << \"Package doesn't contain \" << COMPATIBILITY_ZIP_ENTRY << \" entry\";\n    return true;\n  }\n\n  std::string zip_content(compatibility_entry.uncompressed_length, '\\0');\n  int32_t ret;\n  if ((ret = ExtractToMemory(package_zip, &compatibility_entry,\n                             reinterpret_cast<uint8_t*>(&zip_content[0]),\n                             compatibility_entry.uncompressed_length)) != 0) {\n    LOG(ERROR) << \"Failed to read \" << COMPATIBILITY_ZIP_ENTRY << \": \" << ErrorCodeString(ret);\n    return false;\n  }\n\n  ZipArchiveHandle zip_handle;\n  ret = OpenArchiveFromMemory(static_cast<void*>(const_cast<char*>(zip_content.data())),\n                              zip_content.size(), COMPATIBILITY_ZIP_ENTRY, &zip_handle);\n  if (ret != 0) {\n    LOG(ERROR) << \"Failed to OpenArchiveFromMemory: \" << ErrorCodeString(ret);\n    return false;\n  }\n\n  // Iterate all the entries inside COMPATIBILITY_ZIP_ENTRY and read the contents.\n  void* cookie;\n  ret = StartIteration(zip_handle, &cookie, nullptr, nullptr);\n  if (ret != 0) {\n    LOG(ERROR) << \"Failed to start iterating zip entries: \" << ErrorCodeString(ret);\n    CloseArchive(zip_handle);\n    return false;\n  }\n  std::unique_ptr<void, decltype(&EndIteration)> guard(cookie, EndIteration);\n\n  std::vector<std::string> compatibility_info;\n  ZipEntry info_entry;\n  ZipString info_name;\n  while (Next(cookie, &info_entry, &info_name) == 0) {\n    std::string content(info_entry.uncompressed_length, '\\0');\n    int32_t ret = ExtractToMemory(zip_handle, &info_entry, reinterpret_cast<uint8_t*>(&content[0]),\n                                  info_entry.uncompressed_length);\n    if (ret != 0) {\n      LOG(ERROR) << \"Failed to read \" << info_name.name << \": \" << ErrorCodeString(ret);\n      CloseArchive(zip_handle);\n      return false;\n    }\n    compatibility_info.emplace_back(std::move(content));\n  }\n  CloseArchive(zip_handle);\n\n  // VintfObjectRecovery::CheckCompatibility returns zero on success.\n  std::string err;\n  int result = android::vintf::VintfObjectRecovery::CheckCompatibility(compatibility_info, &err);\n  if (result == 0) {\n    return true;\n  }\n\n  LOG(ERROR) << \"Failed to verify package compatibility (result \" << result << \"): \" << err;\n  return false;\n}\n\nstatic int really_install_package(const std::string& path, bool* wipe_cache, bool needs_mount,\n                                  std::vector<std::string>* log_buffer, int retry_count,\n                                  int* max_temperature) {\n  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);\n  ui->Print(\"Finding update package...\\n\");\n  // Give verification half the progress bar...\n  ui->SetProgressType(RecoveryUI::DETERMINATE);\n  ui->ShowProgress(VERIFICATION_PROGRESS_FRACTION, VERIFICATION_PROGRESS_TIME);\n  LOG(INFO) << \"Update location: \" << path;\n\n  // Map the update package into memory.\n  ui->Print(\"Opening update package...\\n\");\n\n  if (needs_mount) {\n    if (path[0] == '@') {\n      ensure_path_mounted(path.substr(1).c_str());\n    } else {\n      ensure_path_mounted(path.c_str());\n    }\n  }\n\n  MemMapping map;\n  if (!map.MapFile(path)) {\n    LOG(ERROR) << \"failed to map file\";\n    log_buffer->push_back(android::base::StringPrintf(\"error: %d\", kMapFileFailure));\n    return INSTALL_CORRUPT;\n  }\n\n  // Verify package.\n  if (!verify_package(map.addr, map.length)) {\n    log_buffer->push_back(android::base::StringPrintf(\"error: %d\", kZipVerificationFailure));\n    return INSTALL_CORRUPT;\n  }\n\n  // Try to open the package.\n  ZipArchiveHandle zip;\n  int err = OpenArchiveFromMemory(map.addr, map.length, path.c_str(), &zip);\n  if (err != 0) {\n    LOG(ERROR) << \"Can't open \" << path << \" : \" << ErrorCodeString(err);\n    log_buffer->push_back(android::base::StringPrintf(\"error: %d\", kZipOpenFailure));\n\n    CloseArchive(zip);\n    return INSTALL_CORRUPT;\n  }\n\n  // Additionally verify the compatibility of the package.\n  if (!verify_package_compatibility(zip)) {\n    log_buffer->push_back(android::base::StringPrintf(\"error: %d\", kPackageCompatibilityFailure));\n    CloseArchive(zip);\n    return INSTALL_CORRUPT;\n  }\n\n  // Verify and install the contents of the package.\n  ui->Print(\"Installing update...\\n\");\n  if (retry_count > 0) {\n    ui->Print(\"Retry attempt: %d\\n\", retry_count);\n  }\n  ui->SetEnableReboot(false);\n  int result = try_update_binary(path, zip, wipe_cache, log_buffer, retry_count, max_temperature);\n  ui->SetEnableReboot(true);\n  ui->Print(\"\\n\");\n\n  CloseArchive(zip);\n  return result;\n}\n\nint install_package(const std::string& path, bool* wipe_cache, const std::string& install_file,\n                    bool needs_mount, int retry_count) {\n  CHECK(!path.empty());\n  CHECK(!install_file.empty());\n  CHECK(wipe_cache != nullptr);\n\n  modified_flash = true;\n  auto start = std::chrono::system_clock::now();\n\n  int start_temperature = GetMaxValueFromThermalZone();\n  int max_temperature = start_temperature;\n\n  int result;\n  std::vector<std::string> log_buffer;\n  if (setup_install_mounts() != 0) {\n    LOG(ERROR) << \"failed to set up expected mounts for install; aborting\";\n    result = INSTALL_ERROR;\n  } else {\n    result = really_install_package(path, wipe_cache, needs_mount, &log_buffer, retry_count,\n                                    &max_temperature);\n  }\n\n  // Measure the time spent to apply OTA update in seconds.\n  std::chrono::duration<double> duration = std::chrono::system_clock::now() - start;\n  int time_total = static_cast<int>(duration.count());\n\n  bool has_cache = volume_for_mount_point(\"/cache\") != nullptr;\n  // Skip logging the uncrypt_status on devices without /cache.\n  if (has_cache) {\n    static constexpr const char* UNCRYPT_STATUS = \"/cache/recovery/uncrypt_status\";\n    if (ensure_path_mounted(UNCRYPT_STATUS) != 0) {\n      LOG(WARNING) << \"Can't mount \" << UNCRYPT_STATUS;\n    } else {\n      std::string uncrypt_status;\n      if (!android::base::ReadFileToString(UNCRYPT_STATUS, &uncrypt_status)) {\n        PLOG(WARNING) << \"failed to read uncrypt status\";\n      } else if (!android::base::StartsWith(uncrypt_status, \"uncrypt_\")) {\n        LOG(WARNING) << \"corrupted uncrypt_status: \" << uncrypt_status;\n      } else {\n        log_buffer.push_back(android::base::Trim(uncrypt_status));\n      }\n    }\n  }\n\n  // The first two lines need to be the package name and install result.\n  std::vector<std::string> log_header = {\n    path,\n    result == INSTALL_SUCCESS ? \"1\" : \"0\",\n    \"time_total: \" + std::to_string(time_total),\n    \"retry: \" + std::to_string(retry_count),\n  };\n\n  int end_temperature = GetMaxValueFromThermalZone();\n  max_temperature = std::max(end_temperature, max_temperature);\n  if (start_temperature > 0) {\n    log_buffer.push_back(\"temperature_start: \" + std::to_string(start_temperature));\n  }\n  if (end_temperature > 0) {\n    log_buffer.push_back(\"temperature_end: \" + std::to_string(end_temperature));\n  }\n  if (max_temperature > 0) {\n    log_buffer.push_back(\"temperature_max: \" + std::to_string(max_temperature));\n  }\n\n  std::string log_content =\n      android::base::Join(log_header, \"\\n\") + \"\\n\" + android::base::Join(log_buffer, \"\\n\") + \"\\n\";\n  if (!android::base::WriteStringToFile(log_content, install_file)) {\n    PLOG(ERROR) << \"failed to write \" << install_file;\n  }\n\n  // Write a copy into last_log.\n  LOG(INFO) << log_content;\n\n  return result;\n}\n\nbool verify_package(const unsigned char* package_data, size_t package_size) {\n  static constexpr const char* PUBLIC_KEYS_FILE = \"/res/keys\";\n  std::vector<Certificate> loadedKeys;\n  if (!load_keys(PUBLIC_KEYS_FILE, loadedKeys)) {\n    LOG(ERROR) << \"Failed to load keys\";\n    return false;\n  }\n  LOG(INFO) << loadedKeys.size() << \" key(s) loaded from \" << PUBLIC_KEYS_FILE;\n\n  // Verify package.\n  ui->Print(\"Verifying update package...\\n\");\n  auto t0 = std::chrono::system_clock::now();\n  int err = verify_file(package_data, package_size, loadedKeys,\n                        std::bind(&RecoveryUI::SetProgress, ui, std::placeholders::_1));\n  std::chrono::duration<double> duration = std::chrono::system_clock::now() - t0;\n  ui->Print(\"Update package verification took %.1f s (result %d).\\n\", duration.count(), err);\n  if (err != VERIFY_SUCCESS) {\n    LOG(ERROR) << \"Signature verification failed\";\n    LOG(ERROR) << \"error: \" << kZipVerificationFailure;\n    return false;\n  }\n  return true;\n}\n"
        },
        {
          "name": "install.h",
          "type": "blob",
          "size": 1.73828125,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_INSTALL_H_\n#define RECOVERY_INSTALL_H_\n\n#include <string>\n#include <ziparchive/zip_archive.h>\n\nenum { INSTALL_SUCCESS, INSTALL_ERROR, INSTALL_CORRUPT, INSTALL_NONE, INSTALL_SKIPPED,\n        INSTALL_RETRY };\n\n// Installs the given update package. If INSTALL_SUCCESS is returned and *wipe_cache is true on\n// exit, caller should wipe the cache partition.\nint install_package(const std::string& package, bool* wipe_cache, const std::string& install_file,\n                    bool needs_mount, int retry_count);\n\n// Verify the package by ota keys. Return true if the package is verified successfully,\n// otherwise return false.\nbool verify_package(const unsigned char* package_data, size_t package_size);\n\n// Read meta data file of the package, write its content in the string pointed by meta_data.\n// Return true if succeed, otherwise return false.\nbool read_metadata_from_package(ZipArchiveHandle zip, std::string* metadata);\n\n// Verifies the compatibility info in a Treble-compatible package. Returns true directly if the\n// entry doesn't exist.\nbool verify_package_compatibility(ZipArchiveHandle package_zip);\n\n#endif  // RECOVERY_INSTALL_H_\n"
        },
        {
          "name": "installcommand.cpp",
          "type": "blob",
          "size": 11.26171875,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#ifdef AB_OTA_UPDATER\n#include <inttypes.h>\n#include <map>\n#include <android-base/parseint.h>\n#include <android-base/stringprintf.h>\n#include <android-base/strings.h>\n#endif\n#include <cutils/properties.h>\n\n#include \"common.h\"\n#include \"installcommand.h\"\n#include \"zipwrap.hpp\"\n#ifndef USE_MINZIP\n#include <ziparchive/zip_archive.h>\n#include <vintf/VintfObjectRecovery.h>\n#endif\n#ifdef USE_OLD_VERIFIER\n#include \"verifier24/verifier.h\"\n#else\n#include \"verifier.h\"\n#endif\n\n#ifdef AB_OTA_UPDATER\n\nstatic constexpr const char* AB_OTA_PAYLOAD_PROPERTIES = \"payload_properties.txt\";\nstatic constexpr const char* AB_OTA_PAYLOAD = \"payload.bin\";\nstatic constexpr const char* METADATA_PATH = \"META-INF/com/android/metadata\";\n\n// This function parses and returns the build.version.incremental\nstatic int parse_build_number(std::string str) {\n    size_t pos = str.find(\"=\");\n    if (pos != std::string::npos) {\n        std::string num_string = android::base::Trim(str.substr(pos+1));\n        int build_number;\n        if (android::base::ParseInt(num_string.c_str(), &build_number, 0)) {\n            return build_number;\n        }\n    }\n\n    printf(\"Failed to parse build number in %s.\\n\", str.c_str());\n    return -1;\n}\n\nbool read_metadata_from_package(ZipWrap* zip, std::string* meta_data) {\n    long size = zip->GetUncompressedSize(METADATA_PATH);\n    if (size <= 0)\n\t\treturn false;\n\n    meta_data->resize(size, '\\0');\n    if (!zip->ExtractToBuffer(METADATA_PATH, reinterpret_cast<uint8_t*>(&(*meta_data)[0]))) {\n        printf(\"Failed to read metadata in update package.\\n\");\n        return false;\n    }\n    return true;\n}\n\n// Read the build.version.incremental of src/tgt from the metadata and log it to last_install.\nvoid read_source_target_build(ZipWrap* zip/*, std::vector<std::string>& log_buffer*/) {\n    std::string meta_data;\n    if (!read_metadata_from_package(zip, &meta_data)) {\n        return;\n    }\n    // Examples of the pre-build and post-build strings in metadata:\n    // pre-build-incremental=2943039\n    // post-build-incremental=2951741\n    std::vector<std::string> lines = android::base::Split(meta_data, \"\\n\");\n    for (const std::string& line : lines) {\n        std::string str = android::base::Trim(line);\n        if (android::base::StartsWith(str, \"pre-build-incremental\")){\n            int source_build = parse_build_number(str);\n            if (source_build != -1) {\n                printf(\"source_build: %d\\n\", source_build);\n                /*log_buffer.push_back(android::base::StringPrintf(\"source_build: %d\",\n                        source_build));*/\n            }\n        } else if (android::base::StartsWith(str, \"post-build-incremental\")) {\n            int target_build = parse_build_number(str);\n            if (target_build != -1) {\n                printf(\"target_build: %d\\n\", target_build);\n                /*log_buffer.push_back(android::base::StringPrintf(\"target_build: %d\",\n                        target_build));*/\n            }\n        }\n    }\n}\n\n// Parses the metadata of the OTA package in |zip| and checks whether we are\n// allowed to accept this A/B package. Downgrading is not allowed unless\n// explicitly enabled in the package and only for incremental packages.\nstatic int check_newer_ab_build(ZipWrap* zip)\n{\n    std::string metadata_str;\n    if (!read_metadata_from_package(zip, &metadata_str)) {\n        return INSTALL_CORRUPT;\n    }\n    std::map<std::string, std::string> metadata;\n    for (const std::string& line : android::base::Split(metadata_str, \"\\n\")) {\n        size_t eq = line.find('=');\n        if (eq != std::string::npos) {\n            metadata[line.substr(0, eq)] = line.substr(eq + 1);\n        }\n    }\n    char value[PROPERTY_VALUE_MAX];\n\n    property_get(\"ro.product.device\", value, \"\");\n    const std::string& pkg_device = metadata[\"pre-device\"];\n    if (pkg_device != value || pkg_device.empty()) {\n        printf(\"Package is for product %s but expected %s\\n\",\n             pkg_device.c_str(), value);\n        return INSTALL_ERROR;\n    }\n\n    // We allow the package to not have any serialno, but if it has a non-empty\n    // value it should match.\n    property_get(\"ro.serialno\", value, \"\");\n    const std::string& pkg_serial_no = metadata[\"serialno\"];\n    if (!pkg_serial_no.empty() && pkg_serial_no != value) {\n        printf(\"Package is for serial %s\\n\", pkg_serial_no.c_str());\n        return INSTALL_ERROR;\n    }\n\n    if (metadata[\"ota-type\"] != \"AB\") {\n        printf(\"Package is not A/B\\n\");\n        return INSTALL_ERROR;\n    }\n\n    // Incremental updates should match the current build.\n    property_get(\"ro.build.version.incremental\", value, \"\");\n    const std::string& pkg_pre_build = metadata[\"pre-build-incremental\"];\n    if (!pkg_pre_build.empty() && pkg_pre_build != value) {\n        printf(\"Package is for source build %s but expected %s\\n\",\n             pkg_pre_build.c_str(), value);\n        return INSTALL_ERROR;\n    }\n    property_get(\"ro.build.fingerprint\", value, \"\");\n    const std::string& pkg_pre_build_fingerprint = metadata[\"pre-build\"];\n    if (!pkg_pre_build_fingerprint.empty() &&\n        pkg_pre_build_fingerprint != value) {\n        printf(\"Package is for source build %s but expected %s\\n\",\n             pkg_pre_build_fingerprint.c_str(), value);\n        return INSTALL_ERROR;\n    }\n\n    return 0;\n}\n\nint\nabupdate_binary_command(const char* path, ZipWrap* zip, int retry_count __unused,\n                      int status_fd, std::vector<std::string>* cmd)\n{\n    read_source_target_build(zip);\n    int ret = check_newer_ab_build(zip);\n    if (ret) {\n        return ret;\n    }\n\n    // For A/B updates we extract the payload properties to a buffer and obtain\n    // the RAW payload offset in the zip file.\n    if (!zip->EntryExists(AB_OTA_PAYLOAD_PROPERTIES)) {\n        printf(\"Can't find %s\\n\", AB_OTA_PAYLOAD_PROPERTIES);\n        return INSTALL_CORRUPT;\n    }\n    std::vector<unsigned char> payload_properties(\n            zip->GetUncompressedSize(AB_OTA_PAYLOAD_PROPERTIES));\n    if (!zip->ExtractToBuffer(AB_OTA_PAYLOAD_PROPERTIES, payload_properties.data())) {\n        printf(\"Can't extract %s\\n\", AB_OTA_PAYLOAD_PROPERTIES);\n        return INSTALL_CORRUPT;\n    }\n\n    if (!zip->EntryExists(AB_OTA_PAYLOAD)) {\n        printf(\"Can't find %s\\n\", AB_OTA_PAYLOAD);\n        return INSTALL_CORRUPT;\n    }\n    long payload_offset = zip->GetEntryOffset(AB_OTA_PAYLOAD);\n    *cmd = {\n        \"/sbin/update_engine_sideload\",\n        android::base::StringPrintf(\"--payload=file://%s\", path),\n        android::base::StringPrintf(\"--offset=%ld\", payload_offset),\n        \"--headers=\" + std::string(payload_properties.begin(),\n                                   payload_properties.end()),\n        android::base::StringPrintf(\"--status_fd=%d\", status_fd),\n    };\n    return INSTALL_SUCCESS;\n}\n\n#else\n\nvoid read_source_target_build(ZipWrap* zip __unused /*, std::vector<std::string>& log_buffer*/) {return;}\n\nint\nabupdate_binary_command(__unused const char* path, __unused ZipWrap* zip, __unused int retry_count,\n                      __unused int status_fd, __unused std::vector<std::string>* cmd)\n{\n    printf(\"No support for AB OTA zips included\\n\");\n    return INSTALL_CORRUPT;\n}\n\n#endif\n\nint\nupdate_binary_command(const char* path, int retry_count,\n                      int status_fd, std::vector<std::string>* cmd)\n{\n    char charfd[16];\n    sprintf(charfd, \"%i\", status_fd);\n    cmd->push_back(TMP_UPDATER_BINARY_PATH);\n    cmd->push_back(EXPAND(RECOVERY_API_VERSION));\n    cmd->push_back(charfd);\n    cmd->push_back(path);\n    /**cmd = {\n        TMP_UPDATER_BINARY_PATH,\n        EXPAND(RECOVERY_API_VERSION),   // defined in Android.mk\n        charfd,\n        path,\n    };*/\n    if (retry_count > 0)\n        cmd->push_back(\"retry\");\n    return 0;\n}\n\n#ifdef USE_MINZIP\nbool verify_package_compatibility(ZipWrap *package_zip) {\n  if (package_zip->EntryExists(\"compatibility.zip\"))\n    printf(\"Cannot verify treble package compatibility, must build TWRP in Oreo tree or higher.\\n\");\n  return true;\n}\n#else\n// Verifes the compatibility info in a Treble-compatible package. Returns true directly if the\n// entry doesn't exist. Note that the compatibility info is packed in a zip file inside the OTA\n// package.\nbool verify_package_compatibility(ZipWrap *zw) {\n  ZipArchiveHandle package_zip = zw->GetZipArchiveHandle();\n  printf(\"Verifying package compatibility...\\n\");\n\n  static constexpr const char* COMPATIBILITY_ZIP_ENTRY = \"compatibility.zip\";\n  ZipString compatibility_entry_name(COMPATIBILITY_ZIP_ENTRY);\n  ZipEntry compatibility_entry;\n  if (FindEntry(package_zip, compatibility_entry_name, &compatibility_entry) != 0) {\n    printf(\"Package doesn't contain %s entry\\n\", COMPATIBILITY_ZIP_ENTRY);\n    return true;\n  }\n\n  std::string zip_content(compatibility_entry.uncompressed_length, '\\0');\n  int32_t ret;\n  if ((ret = ExtractToMemory(package_zip, &compatibility_entry,\n                             reinterpret_cast<uint8_t*>(&zip_content[0]),\n                             compatibility_entry.uncompressed_length)) != 0) {\n    printf(\"Failed to read %s: %s\\n\", COMPATIBILITY_ZIP_ENTRY, ErrorCodeString(ret));\n    return false;\n  }\n\n  ZipArchiveHandle zip_handle;\n  ret = OpenArchiveFromMemory(static_cast<void*>(const_cast<char*>(zip_content.data())),\n                              zip_content.size(), COMPATIBILITY_ZIP_ENTRY, &zip_handle);\n  if (ret != 0) {\n    printf(\"Failed to OpenArchiveFromMemory: %s\\n\", ErrorCodeString(ret));\n    return false;\n  }\n\n  // Iterate all the entries inside COMPATIBILITY_ZIP_ENTRY and read the contents.\n  void* cookie;\n  ret = StartIteration(zip_handle, &cookie, nullptr, nullptr);\n  if (ret != 0) {\n    printf(\"Failed to start iterating zip entries: %s\\n\", ErrorCodeString(ret));\n    CloseArchive(zip_handle);\n    return false;\n  }\n  std::unique_ptr<void, decltype(&EndIteration)> guard(cookie, EndIteration);\n\n  std::vector<std::string> compatibility_info;\n  ZipEntry info_entry;\n  ZipString info_name;\n  while (Next(cookie, &info_entry, &info_name) == 0) {\n    std::string content(info_entry.uncompressed_length, '\\0');\n    int32_t ret = ExtractToMemory(zip_handle, &info_entry, reinterpret_cast<uint8_t*>(&content[0]),\n                                  info_entry.uncompressed_length);\n    if (ret != 0) {\n      printf(\"Failed to read %s: %s\\n\", info_name.name, ErrorCodeString(ret));\n      CloseArchive(zip_handle);\n      return false;\n    }\n    compatibility_info.emplace_back(std::move(content));\n  }\n  CloseArchive(zip_handle);\n\n  // VintfObjectRecovery::CheckCompatibility returns zero on success. TODO THIS CAUSES A WEIRD COMPILE ERROR\n  std::string err;\n  int result = android::vintf::VintfObjectRecovery::CheckCompatibility(compatibility_info, &err);\n  if (result == 0) {\n    return true;\n  }\n\n  printf(\"Failed to verify package compatibility (result %i): %s\\n\", result, err.c_str());\n  return false;\n}\n#endif\n"
        },
        {
          "name": "installcommand.h",
          "type": "blob",
          "size": 1.2880859375,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_INSTALL_COMMAND_H_\n#define RECOVERY_INSTALL_COMMAND_H_\n\n#define TMP_UPDATER_BINARY_PATH \"/tmp/updater\"\n\n#include <string>\n\n#include \"zipwrap.hpp\"\n\nbool read_metadata_from_package(ZipWrap* zip, std::string* meta_data);\n\nint\nabupdate_binary_command(const char* path, ZipWrap* zip, int retry_count,\n                      int status_fd, std::vector<std::string>* cmd);\nint\nupdate_binary_command(const char* path, int retry_count,\n                      int status_fd, std::vector<std::string>* cmd);\n\nbool verify_package_compatibility(ZipWrap *package_zip);\n\nvoid read_source_target_build(ZipWrap* zip/*, std::vector<std::string>& log_buffer*/);\n\n#endif  // RECOVERY_INSTALL_COMMAND_H_\n"
        },
        {
          "name": "interlace-frames.py",
          "type": "blob",
          "size": 3.52734375,
          "content": "#!/usr/bin/env python\n# Copyright (C) 2014 The Android Open Source Project\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nScript to take a set of frames (PNG files) for a recovery animation\nand turn it into a single output image which contains the input frames\ninterlaced by row.  Run with the names of all the input frames on the\ncommand line, in order, followed by the name of the output file.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport os.path\nimport sys\ntry:\n  import Image\n  import PngImagePlugin\nexcept ImportError:\n  print(\"This script requires the Python Imaging Library to be installed.\")\n  sys.exit(1)\n\n\ndef interlace(output, inputs):\n  frames = [Image.open(fn).convert(\"RGB\") for fn in inputs]\n  assert len(frames) > 0, \"Must have at least one input frame.\"\n  sizes = set()\n  for fr in frames:\n    sizes.add(fr.size)\n\n  assert len(sizes) == 1, \"All input images must have the same size.\"\n  w, h = sizes.pop()\n  N = len(frames)\n\n  out = Image.new(\"RGB\", (w, h*N))\n  for j in range(h):\n    for i in range(w):\n      for fn, f in enumerate(frames):\n        out.putpixel((i, j*N+fn), f.getpixel((i, j)))\n\n  # When loading this image, the graphics library expects to find a text\n  # chunk that specifies how many frames this animation represents.  If\n  # you post-process the output of this script with some kind of\n  # optimizer tool (eg pngcrush or zopflipng) make sure that your\n  # optimizer preserves this text chunk.\n\n  meta = PngImagePlugin.PngInfo()\n  meta.add_text(\"Frames\", str(N))\n\n  out.save(output, pnginfo=meta)\n\n\ndef deinterlace(output, input):\n  # Truncate the output filename extension if it's '.png'.\n  if os.path.splitext(output)[1].lower() == '.png':\n    output = output[:-4]\n\n  img2 = Image.open(input)\n  print(img2.mode)\n  palette = img2.getpalette()\n  img = img2.convert(\"RGB\")\n  num_frames = int(img.info.get('Frames', 1))\n  print('Found %d frames in %s.' % (num_frames, input))\n  assert num_frames > 0, 'Invalid Frames meta.'\n\n  # palette = img.getpalette()\n  print(palette)\n\n  width, height = img.size\n  height /= num_frames\n  for k in range(num_frames):\n    out = Image.new('RGB', (width, height))\n    out.info = img.info\n    for i in range(width):\n      for j in range(height):\n        out.putpixel((i, j), img.getpixel((i, j * num_frames + k)))\n    # out.putpalette(img.getpalette(), rawmode='RGB')\n    out2 = out.convert(mode='P', palette=palette)\n    #out2 = out\n    print(out2.mode)\n    # out2.putpalette(palette)\n    filename = '%s%02d.png' % (output, k)\n    out2.save(filename)\n    print('Frame %d written to %s.' % (k, filename))\n\n\ndef main(argv):\n  parser = argparse.ArgumentParser(description='Parse')\n  parser.add_argument('--deinterlace', '-d', action='store_true')\n  parser.add_argument('--output', '-o', required=True)\n  parser.add_argument('input', nargs='+')\n  args = parser.parse_args(argv)\n\n  if args.deinterlace:\n    # args.input is a list, and we only process the first when deinterlacing.\n    deinterlace(args.output, args.input[0])\n  else:\n    interlace(args.output, args.input)\n\n\nif __name__ == '__main__':\n  main(sys.argv[1:])\n"
        },
        {
          "name": "legacy_properties.h",
          "type": "blob",
          "size": 3.3388671875,
          "content": "/*\n * Copyright (C) 2008 The Android Open Source Project\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#ifndef _INCLUDE_LEGACY_PROPERTIES_H\n#define _INCLUDE_LEGACY_PROPERTIES_H\n\n#include <sys/system_properties.h>\n\ntypedef struct prop_area prop_area;\ntypedef struct prop_msg prop_msg;\n\n#define PROP_AREA_MAGIC   0x504f5250\n#define PROP_AREA_VERSION 0x45434f76\n\n#define PROP_SERVICE_NAME \"property_service\"\n\n/* #define PROP_MAX_ENTRIES 247 */\n/* 247 -> 32620 bytes (<32768) */\n\n#define TOC_NAME_LEN(toc)       ((toc) >> 24)\n#define TOC_TO_INFO(area, toc)  ((prop_info*) (((char*) area) + ((toc) & 0xFFFFFF)))\n\nstruct prop_area {\n    unsigned volatile count;\n    unsigned volatile serial;\n    unsigned magic;\n    unsigned version;\n    unsigned reserved[4];\n    unsigned toc[1];\n};\n\n#define SERIAL_VALUE_LEN(serial) ((serial) >> 24)\n#define SERIAL_DIRTY(serial) ((serial) & 1)\n\nstruct prop_info {\n    char name[PROP_NAME_MAX];\n    unsigned volatile serial;\n    char value[PROP_VALUE_MAX];\n};\n\nstruct prop_msg\n{\n    unsigned cmd;\n    char name[PROP_NAME_MAX];\n    char value[PROP_VALUE_MAX];\n};\n\n#define PROP_MSG_SETPROP 1\n\n/*\n** Rules:\n**\n** - there is only one writer, but many readers\n** - prop_area.count will never decrease in value\n** - once allocated, a prop_info's name will not change\n** - once allocated, a prop_info's offset will not change\n** - reading a value requires the following steps\n**   1. serial = pi->serial\n**   2. if SERIAL_DIRTY(serial), wait*, then goto 1\n**   3. memcpy(local, pi->value, SERIAL_VALUE_LEN(serial) + 1)\n**   4. if pi->serial != serial, goto 2\n**\n** - writing a value requires the following steps\n**   1. pi->serial = pi->serial | 1\n**   2. memcpy(pi->value, local_value, value_len)\n**   3. pi->serial = (value_len << 24) | ((pi->serial + 1) & 0xffffff)\n**\n** Improvements:\n** - maintain the toc sorted by pi->name to allow lookup\n**   by binary search\n**\n*/\n\n#define PROP_PATH_RAMDISK_DEFAULT  \"/default.prop\"\n#define PROP_PATH_SYSTEM_BUILD     \"/system/build.prop\"\n#define PROP_PATH_SYSTEM_DEFAULT   \"/system/default.prop\"\n#define PROP_PATH_LOCAL_OVERRIDE   \"/data/local.prop\"\n\n#endif\n"
        },
        {
          "name": "legacy_property_service.cpp",
          "type": "blob",
          "size": 4.9921875,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <fcntl.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <limits.h>\n#include <errno.h>\n\n#include \"../../bionic/libc/private/bionic_futex.h\"\n\n#include <cutils/properties.h>\n\n#include \"legacy_properties.h\"\n\n#include <sys/mman.h>\n// Not available in 5.0\n//#include <sys/atomics.h>\n#include \"legacy_property_service.h\"\n\n#ifndef INT32_MAX\n#define INT32_MAX\t(2147483647)\n#endif\n\nstatic int property_area_inited = 0;\n\ntypedef struct {\n    void *data;\n    size_t size;\n    int fd;\n} workspace;\n\nstatic int init_workspace(workspace *w, size_t size)\n{\n    void *data;\n    int fd;\n\n        /* dev is a tmpfs that we can use to carve a shared workspace\n         * out of, so let's do that...\n         */\n    fd = open(\"/dev/__legacy_properties__\", O_RDWR | O_CREAT, 0600);\n    if (fd < 0)\n        return -1;\n\n    if (ftruncate(fd, size) < 0)\n        goto out;\n\n    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(data == MAP_FAILED)\n        goto out;\n\n    close(fd);\n\n    fd = open(\"/dev/__legacy_properties__\", O_RDONLY);\n    if (fd < 0)\n        return -1;\n\n    unlink(\"/dev/__legacy_properties__\");\n\n    w->data = data;\n    w->size = size;\n    w->fd = fd;\n    return 0;\n\nout:\n    close(fd);\n    return -1;\n}\n\n/* (8 header words + 247 toc words) = 1020 bytes */\n/* 1024 bytes header and toc + 247 prop_infos @ 128 bytes = 32640 bytes */\n\n#define PA_COUNT_MAX  247\n#define PA_INFO_START 1024\n#define PA_SIZE       32768\n\nstatic workspace pa_workspace;\nstatic prop_info *pa_info_array;\n\nprop_area *__legacy_property_area__;\n\nstatic int init_property_area(void)\n{\n    prop_area *pa;\n\n    if(pa_info_array)\n        return -1;\n\n    if(init_workspace(&pa_workspace, PA_SIZE))\n        return -1;\n\n    fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC);\n\n    pa_info_array = (prop_info*) (((char*) pa_workspace.data) + PA_INFO_START);\n\n    pa = (prop_area*)(pa_workspace.data);\n    memset(pa, 0, PA_SIZE);\n    pa->magic = PROP_AREA_MAGIC;\n    pa->version = PROP_AREA_VERSION;\n\n    /* plug into the lib property services */\n    __legacy_property_area__ = pa;\n    property_area_inited = 1;\n    return 0;\n}\n\nstatic void update_prop_info(prop_info *pi, const char *value, unsigned len)\n{\n    pi->serial = pi->serial | 1;\n    memcpy(pi->value, value, len + 1);\n    pi->serial = (len << 24) | ((pi->serial + 1) & 0xffffff);\n    __futex_wake(&pi->serial, INT32_MAX);\n}\n\nstatic const prop_info *__legacy_property_find(const char *name)\n{\n    prop_area *pa = __legacy_property_area__;\n    unsigned count = pa->count;\n    unsigned *toc = pa->toc;\n    unsigned len = strlen(name);\n    prop_info *pi;\n\n    while(count--) {\n        unsigned entry = *toc++;\n        if(TOC_NAME_LEN(entry) != len) continue;\n\n        pi = TOC_TO_INFO(pa, entry);\n        if(memcmp(name, pi->name, len)) continue;\n\n        return pi;\n    }\n\n    return 0;\n}\n\nstatic int legacy_property_set(const char *name, const char *value)\n{\n    prop_area *pa;\n    prop_info *pi;\n\n    int namelen = strlen(name);\n    int valuelen = strlen(value);\n\n    if(namelen >= PROP_NAME_MAX) return -1;\n    if(valuelen >= PROP_VALUE_MAX) return -1;\n    if(namelen < 1) return -1;\n\n    pi = (prop_info*) __legacy_property_find(name);\n\n\n    if(pi != 0) {\n        /* ro.* properties may NEVER be modified once set */\n        if(!strncmp(name, \"ro.\", 3)) return -1;\n\n        pa = __legacy_property_area__;\n        update_prop_info(pi, value, valuelen);\n        pa->serial++;\n        __futex_wake(&pa->serial, INT32_MAX);\n    } else {\n        pa = __legacy_property_area__;\n        if(pa->count == PA_COUNT_MAX) return -1;\n\n        pi = pa_info_array + pa->count;\n        pi->serial = (valuelen << 24);\n        memcpy(pi->name, name, namelen + 1);\n        memcpy(pi->value, value, valuelen + 1);\n\n        pa->toc[pa->count] =\n            (namelen << 24) | (((unsigned long) pi) - ((unsigned long) pa));\n\n        pa->count++;\n        pa->serial++;\n        __futex_wake(&pa->serial, INT32_MAX);\n    }\n\n    return 0;\n}\n\nvoid legacy_get_property_workspace(int *fd, int *sz)\n{\n    *fd = pa_workspace.fd;\n    *sz = pa_workspace.size;\n}\n\nstatic void copy_property_to_legacy(const char *key, const char *value, void *cookie __unused)\n{\n    legacy_property_set(key, value);\n}\n\nint legacy_properties_init()\n{\n    if(init_property_area() != 0)\n        return -1;\n\n    if(property_list(copy_property_to_legacy, 0) != 0)\n        return -1;\n\n    return 0;\n}\n"
        },
        {
          "name": "legacy_property_service.h",
          "type": "blob",
          "size": 0.7958984375,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _LEGACY_PROPERTY_H\n#define _LEGACY_PROPERTY_H\n\n#include <stdbool.h>\n\nvoid legacy_get_property_workspace(int *fd, int *sz);\nint legacy_properties_init();\n\n#endif\t/* _LEGACY_PROPERTY_H */\n"
        },
        {
          "name": "libblkid",
          "type": "tree",
          "content": null
        },
        {
          "name": "libcrecovery",
          "type": "tree",
          "content": null
        },
        {
          "name": "libmincrypt",
          "type": "tree",
          "content": null
        },
        {
          "name": "libpixelflinger",
          "type": "tree",
          "content": null
        },
        {
          "name": "libtar",
          "type": "tree",
          "content": null
        },
        {
          "name": "minadbd",
          "type": "tree",
          "content": null
        },
        {
          "name": "minadbd21",
          "type": "tree",
          "content": null
        },
        {
          "name": "minui",
          "type": "tree",
          "content": null
        },
        {
          "name": "minui21",
          "type": "tree",
          "content": null
        },
        {
          "name": "minuitwrp",
          "type": "tree",
          "content": null
        },
        {
          "name": "minzip",
          "type": "tree",
          "content": null
        },
        {
          "name": "mmcutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "mounts.c",
          "type": "blob",
          "size": 5.8544921875,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/mount.h>\n\n#include \"mounts.h\"\n\ntypedef struct {\n    MountedVolume *volumes;\n    int volumes_allocd;\n    int volume_count;\n} MountsState;\n\nstatic MountsState g_mounts_state = {\n    NULL,   // volumes\n    0,      // volumes_allocd\n    0       // volume_count\n};\n\nstatic inline void\nfree_volume_internals(const MountedVolume *volume, int zero)\n{\n    free((char *)volume->device);\n    free((char *)volume->mount_point);\n    free((char *)volume->filesystem);\n    free((char *)volume->flags);\n    if (zero) {\n        memset((void *)volume, 0, sizeof(*volume));\n    }\n}\n\n#define PROC_MOUNTS_FILENAME   \"/proc/mounts\"\n\nint\nscan_mounted_volumes()\n{\n    char buf[2048];\n    const char *bufp;\n    int fd;\n    ssize_t nbytes;\n\n    if (g_mounts_state.volumes == NULL) {\n        const int numv = 32;\n        MountedVolume *volumes = malloc(numv * sizeof(*volumes));\n        if (volumes == NULL) {\n            errno = ENOMEM;\n            return -1;\n        }\n        g_mounts_state.volumes = volumes;\n        g_mounts_state.volumes_allocd = numv;\n        memset(volumes, 0, numv * sizeof(*volumes));\n    } else {\n        /* Free the old volume strings.\n         */\n        int i;\n        for (i = 0; i < g_mounts_state.volume_count; i++) {\n            free_volume_internals(&g_mounts_state.volumes[i], 1);\n        }\n    }\n    g_mounts_state.volume_count = 0;\n\n    /* Open and read the file contents.\n     */\n    fd = open(PROC_MOUNTS_FILENAME, O_RDONLY);\n    if (fd < 0) {\n        goto bail;\n    }\n    nbytes = read(fd, buf, sizeof(buf) - 1);\n    close(fd);\n    if (nbytes < 0) {\n        goto bail;\n    }\n    buf[nbytes] = '\\0';\n\n    /* Parse the contents of the file, which looks like:\n     *\n     *     # cat /proc/mounts\n     *     rootfs / rootfs rw 0 0\n     *     /dev/pts /dev/pts devpts rw 0 0\n     *     /proc /proc proc rw 0 0\n     *     /sys /sys sysfs rw 0 0\n     *     /dev/block/mtdblock4 /system yaffs2 rw,nodev,noatime,nodiratime 0 0\n     *     /dev/block/mtdblock5 /data yaffs2 rw,nodev,noatime,nodiratime 0 0\n     *     /dev/block/mmcblk0p1 /sdcard vfat rw,sync,dirsync,fmask=0000,dmask=0000,codepage=cp437,iocharset=iso8859-1,utf8 0 0\n     *\n     * The zeroes at the end are dummy placeholder fields to make the\n     * output match Linux's /etc/mtab, but don't represent anything here.\n     */\n    bufp = buf;\n    while (nbytes > 0) {\n        char device[64];\n        char mount_point[64];\n        char filesystem[64];\n        char flags[128];\n        int matches;\n\n        /* %as is a gnu extension that malloc()s a string for each field.\n         */\n        matches = sscanf(bufp, \"%63s %63s %63s %127s\",\n                device, mount_point, filesystem, flags);\n\n        if (matches == 4) {\n            device[sizeof(device)-1] = '\\0';\n            mount_point[sizeof(mount_point)-1] = '\\0';\n            filesystem[sizeof(filesystem)-1] = '\\0';\n            flags[sizeof(flags)-1] = '\\0';\n\n            MountedVolume *v =\n                    &g_mounts_state.volumes[g_mounts_state.volume_count++];\n            v->device = strdup(device);\n            v->mount_point = strdup(mount_point);\n            v->filesystem = strdup(filesystem);\n            v->flags = strdup(flags);\n        } else {\nprintf(\"matches was %d on <<%.40s>>\\n\", matches, bufp);\n        }\n\n        /* Eat the line.\n         */\n        while (nbytes > 0 && *bufp != '\\n') {\n            bufp++;\n            nbytes--;\n        }\n        if (nbytes > 0) {\n            bufp++;\n            nbytes--;\n        }\n    }\n\n    return 0;\n\nbail:\n//TODO: free the strings we've allocated.\n    g_mounts_state.volume_count = 0;\n    return -1;\n}\n\nconst MountedVolume *\nfind_mounted_volume_by_device(const char *device)\n{\n    if (g_mounts_state.volumes != NULL) {\n        int i;\n        for (i = 0; i < g_mounts_state.volume_count; i++) {\n            MountedVolume *v = &g_mounts_state.volumes[i];\n            /* May be null if it was unmounted and we haven't rescanned.\n             */\n            if (v->device != NULL) {\n                if (strcmp(v->device, device) == 0) {\n                    return v;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nconst MountedVolume *\nfind_mounted_volume_by_mount_point(const char *mount_point)\n{\n    if (g_mounts_state.volumes != NULL) {\n        int i;\n        for (i = 0; i < g_mounts_state.volume_count; i++) {\n            MountedVolume *v = &g_mounts_state.volumes[i];\n            /* May be null if it was unmounted and we haven't rescanned.\n             */\n            if (v->mount_point != NULL) {\n                if (strcmp(v->mount_point, mount_point) == 0) {\n                    return v;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nint\nunmount_mounted_volume(const MountedVolume *volume)\n{\n    /* Intentionally pass NULL to umount if the caller tries\n     * to unmount a volume they already unmounted using this\n     * function.\n     */\n    int ret = umount(volume->mount_point);\n    if (ret == 0) {\n        free_volume_internals(volume, 1);\n        return 0;\n    }\n    return ret;\n}\n\nint\nremount_read_only(const MountedVolume* volume)\n{\n    return mount(volume->device, volume->mount_point, volume->filesystem,\n                 MS_NOATIME | MS_NODEV | MS_NODIRATIME |\n                 MS_RDONLY | MS_REMOUNT, 0);\n}\n"
        },
        {
          "name": "mounts.cpp",
          "type": "blob",
          "size": 2.2646484375,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"mounts.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <mntent.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n\n#include <string>\n#include <vector>\n\n#include <android-base/logging.h>\n\nstruct MountedVolume {\n    std::string device;\n    std::string mount_point;\n    std::string filesystem;\n    std::string flags;\n};\n\nstd::vector<MountedVolume*> g_mounts_state;\n\nbool scan_mounted_volumes() {\n    for (size_t i = 0; i < g_mounts_state.size(); ++i) {\n        delete g_mounts_state[i];\n    }\n    g_mounts_state.clear();\n\n    // Open and read mount table entries.\n    FILE* fp = setmntent(\"/proc/mounts\", \"re\");\n    if (fp == NULL) {\n        return false;\n    }\n    mntent* e;\n    while ((e = getmntent(fp)) != NULL) {\n        MountedVolume* v = new MountedVolume;\n        v->device = e->mnt_fsname;\n        v->mount_point = e->mnt_dir;\n        v->filesystem = e->mnt_type;\n        v->flags = e->mnt_opts;\n        g_mounts_state.push_back(v);\n    }\n    endmntent(fp);\n    return true;\n}\n\nMountedVolume* find_mounted_volume_by_mount_point(const char* mount_point) {\n    for (size_t i = 0; i < g_mounts_state.size(); ++i) {\n        if (g_mounts_state[i]->mount_point == mount_point) return g_mounts_state[i];\n    }\n    return nullptr;\n}\n\nint unmount_mounted_volume(MountedVolume* volume) {\n  // Intentionally pass the empty string to umount if the caller tries to unmount a volume they\n  // already unmounted using this function.\n  std::string mount_point = volume->mount_point;\n  volume->mount_point.clear();\n  int result = umount(mount_point.c_str());\n  if (result == -1) {\n    PLOG(WARNING) << \"Failed to umount \" << mount_point;\n  }\n  return result;\n}\n"
        },
        {
          "name": "mounts.h",
          "type": "blob",
          "size": 0.8271484375,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef MOUNTS_H_\n#define MOUNTS_H_\n\nstruct MountedVolume;\n\nbool scan_mounted_volumes();\n\nMountedVolume* find_mounted_volume_by_mount_point(const char* mount_point);\n\nint unmount_mounted_volume(MountedVolume* volume);\n\n#endif\n"
        },
        {
          "name": "mounts.h~HEAD",
          "type": "blob",
          "size": 1.107421875,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef MTDUTILS_MOUNTS_H_\n#define MTDUTILS_MOUNTS_H_\n\ntypedef struct {\n const char *device;\n const char *mount_point;\n const char *filesystem;\n const char *flags;\n} MountedVolume;\n\nint scan_mounted_volumes(void);\n\nconst MountedVolume *find_mounted_volume_by_device(const char *device);\n\nconst MountedVolume *\nfind_mounted_volume_by_mount_point(const char *mount_point);\n\nint unmount_mounted_volume(const MountedVolume *volume);\n\nint remount_read_only(const MountedVolume* volume);\n\n#endif  // MTDUTILS_MOUNTS_H_\n"
        },
        {
          "name": "mtdutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "mtp",
          "type": "tree",
          "content": null
        },
        {
          "name": "openaes",
          "type": "tree",
          "content": null
        },
        {
          "name": "openrecoveryscript.cpp",
          "type": "blob",
          "size": 24.671875,
          "content": "/*\n\tCopyright 2003 to 2017 TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define __STDC_FORMAT_MACROS 1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <vector>\n#include <dirent.h>\n#include <time.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <iterator>\n#include <algorithm>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <zlib.h>\n\n#include \"twrp-functions.hpp\"\n#include \"partitions.hpp\"\n#include \"twcommon.h\"\n#include \"openrecoveryscript.hpp\"\n#include \"progresstracking.hpp\"\n#include \"variables.h\"\n#include \"adb_install.h\"\n#include \"data.hpp\"\n#include \"adb_install.h\"\n#include \"fuse_sideload.h\"\n#include \"gui/gui.hpp\"\n#include \"gui/pages.hpp\"\n#include \"orscmd/orscmd.h\"\n#include \"twinstall.h\"\nextern \"C\" {\n\t#include \"gui/gui.h\"\n\t#include \"cutils/properties.h\"\n}\n\nOpenRecoveryScript::VoidFunction OpenRecoveryScript::call_after_cli_command;\n\n#define SCRIPT_COMMAND_SIZE 512\n\nint OpenRecoveryScript::check_for_script_file(void) {\n\tif (!PartitionManager.Mount_By_Path(SCRIPT_FILE_CACHE, false)) {\n\t\tLOGINFO(\"Unable to mount /cache for OpenRecoveryScript support.\\n\");\n\t\tgui_msg(Msg(msg::kError, \"unable_to_mount=Unable to mount {1}\")(SCRIPT_FILE_CACHE));\n\t\treturn 0;\n\t}\n\tif (TWFunc::Path_Exists(SCRIPT_FILE_CACHE)) {\n\t\tLOGINFO(\"Script file found: '%s'\\n\", SCRIPT_FILE_CACHE);\n\t\t// Copy script file to /tmp\n\t\tTWFunc::copy_file(SCRIPT_FILE_CACHE, SCRIPT_FILE_TMP, 0755);\n\t\t// Delete the file from /cache\n\t\tunlink(SCRIPT_FILE_CACHE);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint OpenRecoveryScript::copy_script_file(string filename) {\n\tif (TWFunc::Path_Exists(filename)) {\n\t\tLOGINFO(\"Script file found: '%s'\\n\", filename.c_str());\n\t\tif (filename == SCRIPT_FILE_TMP)\n\t\t\treturn 1; // file is already in the right place\n\t\t// Copy script file to /tmp\n\t\tTWFunc::copy_file(filename, SCRIPT_FILE_TMP, 0755);\n\t\t// Delete the old file\n\t\tunlink(filename.c_str());\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint OpenRecoveryScript::run_script_file(void) {\n\tint ret_val = 0, cindex, line_len, i, remove_nl, install_cmd = 0, sideload = 0;\n\tchar script_line[SCRIPT_COMMAND_SIZE], command[SCRIPT_COMMAND_SIZE],\n\t     value[SCRIPT_COMMAND_SIZE], mount[SCRIPT_COMMAND_SIZE],\n\t     value1[SCRIPT_COMMAND_SIZE], value2[SCRIPT_COMMAND_SIZE];\n\tchar *val_start, *tok;\n\n\tFILE *fp = fopen(SCRIPT_FILE_TMP, \"r\");\n\tif (fp != NULL) {\n\t\tDataManager::SetValue(TW_SIMULATE_ACTIONS, 0);\n\t\tDataManager::SetValue(\"ui_progress\", 0); // Reset the progress bar\n\t\twhile (fgets(script_line, SCRIPT_COMMAND_SIZE, fp) != NULL && ret_val == 0) {\n\t\t\tcindex = 0;\n\t\t\tline_len = strlen(script_line);\n\t\t\tif (line_len < 2)\n\t\t\t\tcontinue; // there's a blank line or line is too short to contain a command\n\t\t\t//gui_print(\"script line: '%s'\\n\", script_line);\n\t\t\tfor (i=0; i<line_len; i++) {\n\t\t\t\tif ((int)script_line[i] == 32) {\n\t\t\t\t\tcindex = i;\n\t\t\t\t\ti = line_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(command, 0, sizeof(command));\n\t\t\tmemset(value, 0, sizeof(value));\n\t\t\tif ((int)script_line[line_len - 1] == 10)\n\t\t\t\tremove_nl = 2;\n\t\t\telse\n\t\t\t\tremove_nl = 1;\n\t\t\tif (cindex != 0) {\n\t\t\t\tstrncpy(command, script_line, cindex);\n\t\t\t\tLOGINFO(\"command is: '%s'\\n\", command);\n\t\t\t\tval_start = script_line;\n\t\t\t\tval_start += cindex + 1;\n\t\t\t\tif ((int) *val_start == 32)\n\t\t\t\t\tval_start++; //get rid of space\n\t\t\t\tif ((int) *val_start == 51)\n\t\t\t\t\tval_start++; //get rid of = at the beginning\n\t\t\t\tif ((int) *val_start == 32)\n\t\t\t\t\tval_start++; //get rid of space\n\t\t\t\tstrncpy(value, val_start, line_len - cindex - remove_nl);\n\t\t\t\tLOGINFO(\"value is: '%s'\\n\", value);\n\t\t\t} else {\n\t\t\t\tstrncpy(command, script_line, line_len - remove_nl + 1);\n\t\t\t\tgui_print(\"command is: '%s' and there is no value\\n\", command);\n\t\t\t}\n\t\t\tif (strcmp(command, \"install\") == 0) {\n\t\t\t\t// Install Zip\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", \"Installing Zip\");\n\t\t\t\tret_val = Install_Command(value);\n\t\t\t\tinstall_cmd = -1;\n\t\t\t} else if (strcmp(command, \"wipe\") == 0) {\n\t\t\t\t// Wipe\n\t\t\t\tif (strcmp(value, \"cache\") == 0 || strcmp(value, \"/cache\") == 0) {\n\t\t\t\t\tPartitionManager.Wipe_By_Path(\"/cache\");\n\t\t\t\t} else if (strcmp(value, \"system\") == 0 || strcmp(value, \"/system\") == 0) {\n\t\t\t\t\tPartitionManager.Wipe_By_Path(\"/system\");\n\t\t\t\t} else if (strcmp(value, \"dalvik\") == 0 || strcmp(value, \"dalvick\") == 0 || strcmp(value, \"dalvikcache\") == 0 || strcmp(value, \"dalvickcache\") == 0) {\n\t\t\t\t\tPartitionManager.Wipe_Dalvik_Cache();\n\t\t\t\t} else if (strcmp(value, \"data\") == 0 || strcmp(value, \"/data\") == 0 || strcmp(value, \"factory\") == 0 || strcmp(value, \"factoryreset\") == 0) {\n\t\t\t\t\tPartitionManager.Factory_Reset();\n\t\t\t\t} else {\n\t\t\t\t\tLOGERR(\"Error with wipe command value: '%s'\\n\", value);\n\t\t\t\t\tret_val = 1;\n\t\t\t\t}\n\t\t\t} else if (strcmp(command, \"backup\") == 0) {\n\t\t\t\t// Backup\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@backing}\"));\n\t\t\t\ttok = strtok(value, \" \");\n\t\t\t\tstrcpy(value1, tok);\n\t\t\t\ttok = strtok(NULL, \" \");\n\t\t\t\tif (tok != NULL) {\n\t\t\t\t\tmemset(value2, 0, sizeof(value2));\n\t\t\t\t\tstrcpy(value2, tok);\n\t\t\t\t\tline_len = strlen(tok);\n\t\t\t\t\tif ((int)value2[line_len - 1] == 10 || (int)value2[line_len - 1] == 13) {\n\t\t\t\t\t\tif ((int)value2[line_len - 1] == 10 || (int)value2[line_len - 1] == 13)\n\t\t\t\t\t\t\tremove_nl = 2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove_nl = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tremove_nl = 0;\n\t\t\t\t\tstrncpy(value2, tok, line_len - remove_nl);\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_NAME, value2);\n\t\t\t\t\tgui_msg(Msg(\"backup_folder_set=Backup folder set to '{1}'\")(value2));\n\t\t\t\t\tif (PartitionManager.Check_Backup_Name(true) != 0) {\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchar empt[50];\n\t\t\t\t\tstrcpy(empt, \"(Current Date)\");\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_NAME, empt);\n\t\t\t\t}\n\t\t\t\tret_val = Backup_Command(value1);\n\t\t\t} else if (strcmp(command, \"restore\") == 0) {\n\t\t\t\t// Restore\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@restore}\"));\n\t\t\t\tPartitionManager.Mount_All_Storage();\n\t\t\t\tDataManager::SetValue(TW_SKIP_DIGEST_CHECK_VAR, 0);\n\t\t\t\tchar folder_path[512], partitions[512];\n\n\t\t\t\tstring val = value, restore_folder, restore_partitions;\n\t\t\t\tsize_t pos = val.find_last_of(\" \");\n\t\t\t\tif (pos == string::npos) {\n\t\t\t\t\trestore_folder = value;\n\t\t\t\t\tpartitions[0] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\trestore_folder = val.substr(0, pos);\n\t\t\t\t\trestore_partitions = val.substr(pos + 1, val.size() - pos - 1);\n\t\t\t\t\tstrcpy(partitions, restore_partitions.c_str());\n\t\t\t\t}\n\t\t\t\tstrcpy(folder_path, restore_folder.c_str());\n\t\t\t\tLOGINFO(\"Restore folder is: '%s' and partitions: '%s'\\n\", folder_path, partitions);\n\t\t\t\tgui_msg(Msg(\"restoring=Restoring {1}...\")(folder_path));\n\n\t\t\t\tif (folder_path[0] != '/') {\n\t\t\t\t\tchar backup_folder[512];\n\t\t\t\t\tstring folder_var;\n\t\t\t\t\tstd::vector<PartitionList> Storage_List;\n\n\t\t\t\t\tPartitionManager.Get_Partition_List(\"storage\", &Storage_List);\n\t\t\t\t\tint listSize = Storage_List.size();\n\t\t\t\t\tfor (int i = 0; i < listSize; i++) {\n\t\t\t\t\t\tif (PartitionManager.Is_Mounted_By_Path(Storage_List.at(i).Mount_Point)) {\n\t\t\t\t\t\t\tDataManager::SetValue(\"tw_storage_path\", Storage_List.at(i).Mount_Point);\n\t\t\t\t\t\t\tDataManager::GetValue(TW_BACKUPS_FOLDER_VAR, folder_var);\n\t\t\t\t\t\t\tsprintf(backup_folder, \"%s/%s\", folder_var.c_str(), folder_path);\n\t\t\t\t\t\t\tif (TWFunc::Path_Exists(backup_folder)) {\n\t\t\t\t\t\t\t\tstrcpy(folder_path, backup_folder);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (folder_path[strlen(folder_path) - 1] == '/')\n\t\t\t\t\t\tstrcat(folder_path, \".\");\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcat(folder_path, \"/.\");\n\t\t\t\t}\n\t\t\t\tif (!TWFunc::Path_Exists(folder_path)) {\n\t\t\t\t\tgui_msg(Msg(msg::kError, \"locate_backup_err=Unable to locate backup '{1}'\")(folder_path));\n\t\t\t\t\tret_val = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tDataManager::SetValue(\"tw_restore\", folder_path);\n\n\t\t\t\tPartitionManager.Set_Restore_Files(folder_path);\n\t\t\t\tstring Partition_List;\n\t\t\t\tint is_encrypted = 0;\n\t\t\t\tDataManager::GetValue(\"tw_restore_encrypted\", is_encrypted);\n\t\t\t\tDataManager::GetValue(\"tw_restore_list\", Partition_List);\n\t\t\t\tif (strlen(partitions) != 0) {\n\t\t\t\t\tstring Restore_List;\n\n\t\t\t\t\tmemset(value2, 0, sizeof(value2));\n\t\t\t\t\tstrcpy(value2, partitions);\n\t\t\t\t\tgui_msg(Msg(\"set_restore_opt=Setting restore options: '{1}':\")(value2));\n\t\t\t\t\tline_len = strlen(value2);\n\t\t\t\t\tfor (i=0; i<line_len; i++) {\n\t\t\t\t\t\tif ((value2[i] == 'S' || value2[i] == 's') && Partition_List.find(\"/system;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/system;\";\n\t\t\t\t\t\t\tgui_msg(\"system=System\");\n\t\t\t\t\t\t} else if ((value2[i] == 'D' || value2[i] == 'd') && Partition_List.find(\"/data;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/data;\";\n\t\t\t\t\t\t\tgui_msg(\"data=Data\");\n\t\t\t\t\t\t} else if ((value2[i] == 'C' || value2[i] == 'c') && Partition_List.find(\"/cache;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/cache;\";\n\t\t\t\t\t\t\tgui_msg(\"cache=Cache\");\n\t\t\t\t\t\t} else if ((value2[i] == 'R' || value2[i] == 'r') && Partition_List.find(\"/recovery;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/recovery;\";\n\t\t\t\t\t\t\tgui_msg(\"recovery=Recovery\");\n\t\t\t\t\t\t} else if ((value2[i] == 'B' || value2[i] == 'b') && Partition_List.find(\"/boot;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/boot;\";\n\t\t\t\t\t\t\tgui_msg(\"boot=Boot\");\n\t\t\t\t\t\t} else if ((value2[i] == 'A' || value2[i] == 'a')  && Partition_List.find(\"/and-sec;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/and-sec;\";\n\t\t\t\t\t\t\tgui_msg(\"android_secure=Android Secure\");\n\t\t\t\t\t\t} else if ((value2[i] == 'E' || value2[i] == 'e')  && Partition_List.find(\"/sd-ext;\") != string::npos) {\n\t\t\t\t\t\t\tRestore_List += \"/sd-ext;\";\n\t\t\t\t\t\t\tgui_msg(\"sdext=SD-EXT\");\n\t\t\t\t\t\t} else if (value2[i] == 'M' || value2[i] == 'm') {\n\t\t\t\t\t\t\tDataManager::SetValue(TW_SKIP_DIGEST_CHECK_VAR, 1);\n\t\t\t\t\t\t\tgui_msg(\"digest_check_skip=Digest check skip is on\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tDataManager::SetValue(\"tw_restore_selected\", Restore_List);\n\t\t\t\t} else {\n\t\t\t\t\tDataManager::SetValue(\"tw_restore_selected\", Partition_List);\n\t\t\t\t}\n\t\t\t\tif (is_encrypted) {\n\t\t\t\t\tgui_err(\"ors_encrypt_restore_err=Unable to use OpenRecoveryScript to restore an encrypted backup.\");\n\t\t\t\t\tret_val = 1;\n\t\t\t\t} else if (!PartitionManager.Run_Restore(folder_path))\n\t\t\t\t\tret_val = 1;\n\t\t\t\telse\n\t\t\t\t\tgui_msg(\"done=Done.\");\n\t\t\t} else if (strcmp(command, \"remountrw\") == 0) {\n\t\t\t\tret_val = remountrw();\n\t\t\t} else if (strcmp(command, \"mount\") == 0) {\n\t\t\t\t// Mount\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@mounting}\"));\n\t\t\t\tif (value[0] != '/') {\n\t\t\t\t\tstrcpy(mount, \"/\");\n\t\t\t\t\tstrcat(mount, value);\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(mount, value);\n\t\t\t\tif (PartitionManager.Mount_By_Path(mount, true))\n\t\t\t\t\tgui_msg(Msg(\"mounted=Mounted '{1}'\")(mount));\n\t\t\t} else if (strcmp(command, \"unmount\") == 0 || strcmp(command, \"umount\") == 0) {\n\t\t\t\t// Unmount\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@unmounting}\"));\n\t\t\t\tif (value[0] != '/') {\n\t\t\t\t\tstrcpy(mount, \"/\");\n\t\t\t\t\tstrcat(mount, value);\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(mount, value);\n\t\t\t\tif (PartitionManager.UnMount_By_Path(mount, true))\n\t\t\t\t\tgui_msg(Msg(\"unmounted=Unounted '{1}'\")(mount));\n\t\t\t} else if (strcmp(command, \"set\") == 0) {\n\t\t\t\t// Set value\n\t\t\t\tsize_t len = strlen(value);\n\t\t\t\ttok = strtok(value, \" \");\n\t\t\t\tstrcpy(value1, tok);\n\t\t\t\tif (len > strlen(value1) + 1) {\n\t\t\t\t\tchar *val2 = value + strlen(value1) + 1;\n\t\t\t\t\tgui_msg(Msg(\"setting=Setting '{1}' to '{2}'\")(value1)(val2));\n\t\t\t\t\tDataManager::SetValue(value1, val2);\n\t\t\t\t} else {\n\t\t\t\t\tgui_msg(Msg(\"setting_empty=Setting '{1}' to empty\")(value1));\n\t\t\t\t\tDataManager::SetValue(value1, \"\");\n\t\t\t\t}\n\t\t\t} else if (strcmp(command, \"mkdir\") == 0) {\n\t\t\t\t// Make directory (recursive)\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@making_dir1}\"));\n\t\t\t\tgui_msg(Msg(\"making_dir2=Making directory: '{1}'\")(value));\n\t\t\t\tif (!TWFunc::Recursive_Mkdir(value)) {\n\t\t\t\t\t// error message already displayed by Recursive_Mkdir\n\t\t\t\t\tret_val = 1;\n\t\t\t\t}\n\t\t\t} else if (strcmp(command, \"reboot\") == 0) {\n\t\t\t\tif (strlen(value) && strcmp(value, \"recovery\") == 0)\n\t\t\t\t\tTWFunc::tw_reboot(rb_recovery);\n\t\t\t\telse if (strlen(value) && strcmp(value, \"poweroff\") == 0)\n\t\t\t\t\tTWFunc::tw_reboot(rb_poweroff);\n\t\t\t\telse if (strlen(value) && strcmp(value, \"bootloader\") == 0)\n\t\t\t\t\tTWFunc::tw_reboot(rb_bootloader);\n\t\t\t\telse if (strlen(value) && strcmp(value, \"download\") == 0)\n\t\t\t\t\tTWFunc::tw_reboot(rb_download);\n\t\t\t\telse\n\t\t\t\t\tTWFunc::tw_reboot(rb_system);\n\t\t\t} else if (strcmp(command, \"cmd\") == 0) {\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@running_command}\"));\n\t\t\t\tif (cindex != 0) {\n\t\t\t\t\tTWFunc::Exec_Cmd(value);\n\t\t\t\t} else {\n\t\t\t\t\tLOGERR(\"No value given for cmd\\n\");\n\t\t\t\t}\n\t\t\t} else if (strcmp(command, \"print\") == 0) {\n\t\t\t\tgui_print(\"%s\\n\", value);\n\t\t\t} else if (strcmp(command, \"sideload\") == 0) {\n\t\t\t\t// ADB Sideload\n\t\t\t\tDataManager::SetValue(\"tw_action_text2\", gui_parse_text(\"{@sideload}\"));\n\t\t\t\tinstall_cmd = -1;\n\n\t\t\t\tint wipe_cache = 0;\n\t\t\t\tstring result;\n\t\t\t\tpid_t sideload_child_pid;\n\n\t\t\t\tgui_msg(\"start_sideload=Starting ADB sideload feature...\");\n\t\t\t\tret_val = apply_from_adb(\"/\", &sideload_child_pid);\n\t\t\t\tif (ret_val != 0) {\n\t\t\t\t\tif (ret_val == -2)\n\t\t\t\t\t\tgui_err(\"need_new_adb=You need adb 1.0.32 or newer to sideload to this device.\");\n\t\t\t\t\tret_val = 1; // failure\n\t\t\t\t} else if (TWinstall_zip(FUSE_SIDELOAD_HOST_PATHNAME, &wipe_cache) == 0) {\n\t\t\t\t\tif (wipe_cache)\n\t\t\t\t\t\tPartitionManager.Wipe_By_Path(\"/cache\");\n\t\t\t\t} else {\n\t\t\t\t\tret_val = 1; // failure\n\t\t\t\t}\n\t\t\t\tsideload = 1; // Causes device to go to the home screen afterwards\n\t\t\t\tif (sideload_child_pid != 0) {\n\t\t\t\t\tLOGINFO(\"Signaling child sideload process to exit.\\n\");\n\t\t\t\t\tstruct stat st;\n\t\t\t\t\t// Calling stat() on this magic filename signals the minadbd\n\t\t\t\t\t// subprocess to shut down.\n\t\t\t\t\tstat(FUSE_SIDELOAD_HOST_EXIT_PATHNAME, &st);\n\t\t\t\t\tint status;\n\t\t\t\t\tLOGINFO(\"Waiting for child sideload process to exit.\\n\");\n\t\t\t\t\twaitpid(sideload_child_pid, &status, 0);\n\t\t\t\t}\n\t\t\t\tproperty_set(\"ctl.start\", \"adbd\");\n\t\t\t\tgui_msg(\"done=Done.\");\n\t\t\t} else if (strcmp(command, \"fixperms\") == 0 || strcmp(command, \"fixpermissions\") == 0 || strcmp(command, \"fixcontexts\") == 0) {\n\t\t\t\tret_val = PartitionManager.Fix_Contexts();\n\t\t\t\tif (ret_val != 0)\n\t\t\t\t\tret_val = 1; // failure\n\t\t\t} else if (strcmp(command, \"decrypt\") == 0) {\n\t\t\t\tif (*value) {\n\t\t\t\t\tret_val = PartitionManager.Decrypt_Device(value);\n\t\t\t\t\tif (ret_val != 0)\n\t\t\t\t\t\tret_val = 1; // failure\n\t\t\t\t} else {\n\t\t\t\t\tgui_err(\"no_pwd=No password provided.\");\n\t\t\t\t\tret_val = 1; // failure\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOGERR(\"Unrecognized script command: '%s'\\n\", command);\n\t\t\t\tret_val = 1;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t\tunlink(SCRIPT_FILE_TMP);\n\t\tgui_msg(\"done_ors=Done processing script file\");\n\t} else {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(SCRIPT_FILE_TMP)(strerror(errno)));\n\t\treturn 1;\n\t}\n\n\tif (install_cmd && DataManager::GetIntValue(TW_HAS_INJECTTWRP) == 1 && DataManager::GetIntValue(TW_INJECT_AFTER_ZIP) == 1) {\n\t\tgui_msg(\"injecttwrp=Injecting TWRP into boot image...\");\n\t\tTWPartition* Boot = PartitionManager.Find_Partition_By_Path(\"/boot\");\n\t\tif (Boot == NULL || Boot->Current_File_System != \"emmc\")\n\t\t\tTWFunc::Exec_Cmd(\"injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash\");\n\t\telse {\n\t\t\tstring injectcmd = \"injecttwrp --dump /tmp/backup_recovery_ramdisk.img /tmp/injected_boot.img --flash bd=\" + Boot->Actual_Block_Device;\n\t\t\tTWFunc::Exec_Cmd(injectcmd.c_str());\n\t\t}\n\t\tgui_msg(\"done=Done.\");\n\t}\n\tif (sideload)\n\t\tret_val = 1; // Forces booting to the home page after sideload\n\treturn ret_val;\n}\n\nint OpenRecoveryScript::Insert_ORS_Command(string Command) {\n\tofstream ORSfile(SCRIPT_FILE_TMP, ios_base::app | ios_base::out);\n\tif (ORSfile.is_open()) {\n\t\t//if (Command.substr(Command.size() - 1, 1) != \"\\n\")\n\t\t//\tCommand += \"\\n\";\n\t\tLOGINFO(\"Inserting '%s'\\n\", Command.c_str());\n\t\tORSfile << Command.c_str() << endl;\n\t\tORSfile.close();\n\t\treturn 1;\n\t}\n\tLOGERR(\"Unable to append '%s' to '%s'\\n\", Command.c_str(), SCRIPT_FILE_TMP);\n\treturn 0;\n}\n\nint OpenRecoveryScript::Install_Command(string Zip) {\n\t// Install zip\n\tstring ret_string;\n\tint ret_val = 0, wipe_cache = 0;\n\tstd::vector<PartitionList> Storage_List;\n\tstring Full_Path;\n\n\tif (Zip.substr(0, 1) == \"@\") {\n\t\t// This is a special file that contains a map of blocks on the data partition\n\t\tFull_Path = Zip.substr(1);\n\t\tif (!PartitionManager.Mount_By_Path(Full_Path, true) || !TWFunc::Path_Exists(Full_Path)) {\n\t\t\tLOGINFO(\"Unable to install via mapped zip '%s'\\n\", Full_Path.c_str());\n\t\t\tgui_msg(Msg(msg::kError, \"zip_err=Error installing zip file '{1}'\")(Zip));\n\t\t\treturn 1;\n\t\t}\n\t\tLOGINFO(\"Installing mapped zip file '%s'\\n\", Full_Path.c_str());\n\t\tgui_msg(Msg(\"installing_zip=Installing zip file '{1}'\")(Zip));\n\t} else if (!TWFunc::Path_Exists(Zip)) {\n\t\tPartitionManager.Mount_All_Storage();\n\t\tPartitionManager.Get_Partition_List(\"storage\", &Storage_List);\n\t\tint listSize = Storage_List.size();\n\t\tfor (int i = 0; i < listSize; i++) {\n\t\t\tif (PartitionManager.Is_Mounted_By_Path(Storage_List.at(i).Mount_Point)) {\n\t\t\t\tFull_Path = Storage_List.at(i).Mount_Point + \"/\" + Zip;\n\t\t\t\tif (TWFunc::Path_Exists(Full_Path)) {\n\t\t\t\t\tZip = Full_Path;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tFull_Path = Zip;\n\t\t\t\tLOGINFO(\"Trying to find zip '%s' on '%s'...\\n\", Full_Path.c_str(), Storage_List.at(i).Mount_Point.c_str());\n\t\t\t\tret_string = Locate_Zip_File(Full_Path, Storage_List.at(i).Mount_Point);\n\t\t\t\tif (!ret_string.empty()) {\n\t\t\t\t\tZip = ret_string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!TWFunc::Path_Exists(Zip)) {\n\t\t\t// zip file doesn't exist\n\t\t\tgui_print(\"Unable to locate zip file '%s'.\\n\", Zip.c_str());\n\t\t\tret_val = 1;\n\t\t} else\n\t\t\tgui_msg(Msg(\"installing_zip=Installing zip file '{1}'\")(Zip));\n\t}\n\n\tret_val = TWinstall_zip(Zip.c_str(), &wipe_cache);\n\tif (ret_val != 0) {\n\t\tgui_msg(Msg(msg::kError, \"zip_err=Error installing zip file '{1}'\")(Zip));\n\t\tret_val = 1;\n\t} else if (wipe_cache)\n\t\tPartitionManager.Wipe_By_Path(\"/cache\");\n\n\treturn ret_val;\n}\n\nstring OpenRecoveryScript::Locate_Zip_File(string Zip, string Storage_Root) {\n\tstring Path = TWFunc::Get_Path(Zip);\n\tstring File = TWFunc::Get_Filename(Zip);\n\tstring pathCpy = Path;\n\tstring wholePath;\n\tsize_t pos = Path.find(\"/\", 1);\n\n\twhile (pos != string::npos)\n\t{\n\t\tpathCpy = Path.substr(pos, Path.size() - pos);\n\t\twholePath = pathCpy + File;\n\t\tLOGINFO(\"Looking for zip at '%s'\\n\", wholePath.c_str());\n\t\tif (TWFunc::Path_Exists(wholePath))\n\t\t\treturn wholePath;\n\t\twholePath = Storage_Root + wholePath;\n\t\tLOGINFO(\"Looking for zip at '%s'\\n\", wholePath.c_str());\n\t\tif (TWFunc::Path_Exists(wholePath))\n\t\t\treturn wholePath;\n\n\t\tpos = Path.find(\"/\", pos + 1);\n\t}\n\treturn \"\";\n}\n\nint OpenRecoveryScript::Backup_Command(string Options) {\n\tchar value1[SCRIPT_COMMAND_SIZE];\n\tint line_len, i;\n\tstring Backup_List;\n\n\tstrcpy(value1, Options.c_str());\n\n\tDataManager::SetValue(TW_USE_COMPRESSION_VAR, 0);\n\tDataManager::SetValue(TW_SKIP_DIGEST_GENERATE_VAR, 0);\n\n\tgui_msg(\"select_backup_opt=Setting backup options:\");\n\tline_len = Options.size();\n\tfor (i=0; i<line_len; i++) {\n\t\tif (Options.substr(i, 1) == \"S\" || Options.substr(i, 1) == \"s\") {\n\t\t\tBackup_List += \"/system;\";\n\t\t\tgui_msg(\"system=System\");\n\t\t} else if (Options.substr(i, 1) == \"D\" || Options.substr(i, 1) == \"d\") {\n\t\t\tBackup_List += \"/data;\";\n\t\t\tgui_msg(\"data=Data\");\n\t\t} else if (Options.substr(i, 1) == \"C\" || Options.substr(i, 1) == \"c\") {\n\t\t\tBackup_List += \"/cache;\";\n\t\t\tgui_msg(\"cache=Cache\");\n\t\t} else if (Options.substr(i, 1) == \"R\" || Options.substr(i, 1) == \"r\") {\n\t\t\tBackup_List += \"/recovery;\";\n\t\t\tgui_msg(\"recovery=Recovery\");\n\t\t} else if (Options.substr(i, 1) == \"1\") {\n\t\t\tgui_print(\"%s\\n\", \"Special1 -- No Longer Supported...\");\n\t\t} else if (Options.substr(i, 1) == \"2\") {\n\t\t\tgui_print(\"%s\\n\", \"Special2 -- No Longer Supported...\");\n\t\t} else if (Options.substr(i, 1) == \"3\") {\n\t\t\tgui_print(\"%s\\n\", \"Special3 -- No Longer Supported...\");\n\t\t} else if (Options.substr(i, 1) == \"B\" || Options.substr(i, 1) == \"b\") {\n\t\t\tBackup_List += \"/boot;\";\n\t\t\tgui_msg(\"boot=Boot\");\n\t\t} else if (Options.substr(i, 1) == \"A\" || Options.substr(i, 1) == \"a\") {\n\t\t\tBackup_List += \"/and-sec;\";\n\t\t\tgui_msg(\"android_secure=Android Secure\");\n\t\t} else if (Options.substr(i, 1) == \"E\" || Options.substr(i, 1) == \"e\") {\n\t\t\tBackup_List += \"/sd-ext;\";\n\t\t\tgui_msg(\"sdext=SD-EXT\");\n\t\t} else if (Options.substr(i, 1) == \"O\" || Options.substr(i, 1) == \"o\") {\n\t\t\tDataManager::SetValue(TW_USE_COMPRESSION_VAR, 1);\n\t\t\tgui_msg(\"compression_on=Compression is on\");\n\t\t} else if (Options.substr(i, 1) == \"M\" || Options.substr(i, 1) == \"m\") {\n\t\t\tDataManager::SetValue(TW_SKIP_DIGEST_GENERATE_VAR, 1);\n\t\t\tgui_msg(\"digest_off=Digest Generation is off\");\n\t\t}\n\t}\n\tDataManager::SetValue(\"tw_backup_list\", Backup_List);\n\tif (!PartitionManager.Run_Backup(false)) {\n\t\tgui_err(\"backup_fail=Backup Failed\");\n\t\treturn 1;\n\t}\n\tgui_msg(\"backup_complete=Backup Complete\");\n\treturn 0;\n}\n\n// this is called by main()\nvoid OpenRecoveryScript::Run_OpenRecoveryScript(void) {\n\tDataManager::SetValue(\"tw_back\", \"main\");\n\tDataManager::SetValue(\"tw_action\", \"openrecoveryscript\");\n\tDataManager::SetValue(\"tw_action_param\", \"\");\n\tDataManager::SetValue(\"tw_has_action2\", \"0\");\n\tDataManager::SetValue(\"tw_action2\", \"\");\n\tDataManager::SetValue(\"tw_action2_param\", \"\");\n#ifdef TW_OEM_BUILD\n\tDataManager::SetValue(\"tw_action_text1\", gui_lookup(\"running_recovery_commands\", \"Running Recovery Commands\"));\n\tDataManager::SetValue(\"tw_complete_text1\", gui_lookup(\"recovery_commands_complete\", \"Recovery Commands Complete\"));\n#else\n\tDataManager::SetValue(\"tw_action_text1\", gui_lookup(\"running_ors\", \"Running OpenRecoveryScript\"));\n\tDataManager::SetValue(\"tw_complete_text1\", gui_lookup(\"ors_complete\", \"OpenRecoveryScript Complete\"));\n#endif\n\tDataManager::SetValue(\"tw_action_text2\", \"\");\n\tDataManager::SetValue(\"tw_has_cancel\", 0);\n\tDataManager::SetValue(\"tw_show_reboot\", 0);\n\tif (gui_startPage(\"action_page\", 0, 1) != 0) {\n\t\tLOGERR(\"Failed to load OpenRecoveryScript GUI page.\\n\");\n\t}\n}\n\n// this is called by the \"openrecoveryscript\" GUI action called via action page from Run_OpenRecoveryScript\nint OpenRecoveryScript::Run_OpenRecoveryScript_Action() {\n\tint op_status = 1;\n\t// Check for the SCRIPT_FILE_TMP first as these are AOSP recovery commands\n\t// that we converted to ORS commands during boot in recovery.cpp.\n\t// Run those first.\n\tint reboot = 0;\n\tif (TWFunc::Path_Exists(SCRIPT_FILE_TMP)) {\n\t\tgui_msg(\"running_recovery_commands=Running Recovery Commands\");\n\t\tif (OpenRecoveryScript::run_script_file() == 0) {\n\t\t\treboot = 1;\n\t\t\top_status = 0;\n\t\t}\n\t}\n\t// Check for the ORS file in /cache and attempt to run those commands.\n\tif (OpenRecoveryScript::check_for_script_file()) {\n\t\tgui_msg(\"running_ors=Running OpenRecoveryScript\");\n\t\tif (OpenRecoveryScript::run_script_file() == 0) {\n\t\t\treboot = 1;\n\t\t\top_status = 0;\n\t\t}\n\t}\n\tif (reboot) {\n\t\t// Disable stock recovery reflashing\n\t\tTWFunc::Disable_Stock_Recovery_Replace();\n\t\tusleep(2000000); // Sleep for 2 seconds before rebooting\n\t\tTWFunc::tw_reboot(rb_system);\n\t\tusleep(5000000); // Sleep for 5 seconds to allow reboot to occur\n\t} else {\n\t\tDataManager::SetValue(\"tw_page_done\", 1);\n\t}\n\treturn op_status;\n}\n\n// this is called by the \"twcmd\" GUI action when a command is received via FIFO from the \"twrp\" command line tool\nvoid OpenRecoveryScript::Run_CLI_Command(const char* command) {\n\tif (strlen(command) > 11 && strncmp(command, \"runscript\", 9) == 0) {\n\t\tconst char* filename = command + 10;\n\t\tif (OpenRecoveryScript::copy_script_file(filename) == 0) {\n\t\t\tLOGINFO(\"Unable to copy script file\\n\");\n\t\t} else {\n\t\t\tOpenRecoveryScript::run_script_file();\n\t\t}\n\t} else if (strlen(command) > 5 && strncmp(command, \"get\", 3) == 0) {\n\t\tconst char* varname = command + 4;\n\t\tstring value;\n\t\tDataManager::GetValue(varname, value);\n\t\tgui_print(\"%s = %s\\n\", varname, value.c_str());\n\t} else if (strlen(command) > 9 && strncmp(command, \"decrypt\", 7) == 0) {\n\t\tconst char* pass = command + 8;\n\t\tgui_msg(\"decrypt_cmd=Attempting to decrypt data partition via command line.\");\n\t\tif (PartitionManager.Decrypt_Device(pass) == 0) {\n\t\t\t// set_page_done = 1;  // done by singleaction_page anyway\n\t\t}\n\t} else if (OpenRecoveryScript::Insert_ORS_Command(command)) {\n\t\tOpenRecoveryScript::run_script_file();\n\t}\n\n\t// let the GUI close the output fd and restart the command listener\n\tcall_after_cli_command();\n\tLOGINFO(\"Done reading ORS command from command line\\n\");\n}\n\nint OpenRecoveryScript::remountrw(void)\n{\n\tbool remount_system = PartitionManager.Is_Mounted_By_Path(\"/system\");\n\tint op_status;\n\tTWPartition* Part;\n\n\tif (!PartitionManager.UnMount_By_Path(\"/system\", true)) {\n\t\top_status = 1; // fail\n\t} else {\n\t\tPart = PartitionManager.Find_Partition_By_Path(\"/system\");\n\t\tif (Part) {\n\t\t\tDataManager::SetValue(\"tw_mount_system_ro\", 0);\n\t\t\tPart->Change_Mount_Read_Only(false);\n\t\t}\n\t\tif (remount_system) {\n\t\t\tPart->Mount(true);\n\t\t}\n\t\top_status = 0; // success\n\t}\n\n\treturn op_status;\n}\n"
        },
        {
          "name": "openrecoveryscript.hpp",
          "type": "blob",
          "size": 2.3857421875,
          "content": "/*\n\tCopyright 2012 - 2017 TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _OPENRECOVERYSCRIPT_HPP\n#define _OPENRECOVERYSCRIPT_HPP\n\n#include <string>\n\nusing namespace std;\n\nclass OpenRecoveryScript\n{\n\ttypedef void (*VoidFunction)();\n\tstatic VoidFunction call_after_cli_command;                                    // callback to GUI after Run_CLI_Command\n\n\tstatic int check_for_script_file();                                            // Checks to see if the ORS file is present in /cache\n\tstatic int copy_script_file(string filename);                                  // Copies a script file to the temp folder\n\tstatic int run_script_file();                                                  // Executes the commands in the ORS file\n\tstatic int Install_Command(string Zip);                                        // Installs a zip\n\tstatic string Locate_Zip_File(string Path, string File);                       // Attempts to locate the zip file in storage\n\tstatic int Backup_Command(string Options);                                     // Runs a backup\npublic:\n\tstatic int Insert_ORS_Command(string Command);                                 // Inserts the Command into the SCRIPT_FILE_TMP file\n\tstatic void Run_OpenRecoveryScript();                                          // Starts the GUI Page for running OpenRecoveryScript\n\tstatic int Run_OpenRecoveryScript_Action();                                    // Actually runs the ORS scripts for the GUI action\n\tstatic void Call_After_CLI_Command(VoidFunction fn) { call_after_cli_command = fn; }\n\tstatic void Run_CLI_Command(const char* command);                              // Runs a command for orscmd (twrp binary)\n\tstatic int remountrw();                                                        // Remount system and vendor rw\n};\n\n#endif // _OPENRECOVERYSCRIPT_HPP\n"
        },
        {
          "name": "orscmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "otafault",
          "type": "tree",
          "content": null
        },
        {
          "name": "otautil",
          "type": "tree",
          "content": null
        },
        {
          "name": "partition.cpp",
          "type": "blob",
          "size": 95.0224609375,
          "content": "/*\n\tCopyright 2013 to 2017 TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <sys/mount.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <libgen.h>\n#include <zlib.h>\n#include <iostream>\n#include <sstream>\n#include <sys/param.h>\n#include <fcntl.h>\n\n#ifdef TW_INCLUDE_CRYPTO\n\t#include \"cutils/properties.h\"\n#endif\n\n#include \"libblkid/include/blkid.h\"\n#include \"variables.h\"\n#include \"twcommon.h\"\n#include \"partitions.hpp\"\n#include \"data.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"twrpTar.hpp\"\n#include \"exclude.hpp\"\n#include \"infomanager.hpp\"\n#include \"set_metadata.h\"\n#include \"gui/gui.hpp\"\n#include \"adbbu/libtwadbbu.hpp\"\nextern \"C\" {\n\t#include \"mtdutils/mtdutils.h\"\n\t#include \"mtdutils/mounts.h\"\n#ifdef USE_EXT4\n\t// #include \"make_ext4fs.h\" TODO need ifdef for android8\n\t#include <ext4_utils/make_ext4fs.h>\n#endif\n\n#ifdef TW_INCLUDE_CRYPTO\n\t#include \"crypto/lollipop/cryptfs.h\"\n\t#include \"gpt/gpt.h\"\n\t#ifdef TW_INCLUDE_FBE\n\t\t#include \"crypto/ext4crypt/Decrypt.h\"\n\t#endif\n#else\n\t#define CRYPT_FOOTER_OFFSET 0x4000\n#endif\n}\n#include <selinux/selinux.h>\n#include <selinux/label.h>\n#ifdef HAVE_CAPABILITIES\n#include <sys/capability.h>\n#include <sys/xattr.h>\n#include <linux/xattr.h>\n#endif\n#include <sparse_format.h>\n#include \"progresstracking.hpp\"\n\nusing namespace std;\n\nstatic int auto_index = 0; // v2 fstab allows you to specify a mount point of \"auto\" with no /. These items are given a mount point of /auto* where * == auto_index\n\nextern struct selabel_handle *selinux_handle;\nextern bool datamedia;\n\nstruct flag_list {\n\tconst char *name;\n\tunsigned long flag;\n};\n\nconst struct flag_list mount_flags[] = {\n\t{ \"noatime\",          MS_NOATIME },\n\t{ \"noexec\",           MS_NOEXEC },\n\t{ \"nosuid\",           MS_NOSUID },\n\t{ \"nodev\",            MS_NODEV },\n\t{ \"nodiratime\",       MS_NODIRATIME },\n\t{ \"ro\",               MS_RDONLY },\n\t{ \"rw\",               0 },\n\t{ \"remount\",          MS_REMOUNT },\n\t{ \"bind\",             MS_BIND },\n\t{ \"rec\",              MS_REC },\n#ifdef MS_UNBINDABLE\n\t{ \"unbindable\",       MS_UNBINDABLE },\n#endif\n#ifdef MS_PRIVATE\n\t{ \"private\",          MS_PRIVATE },\n#endif\n#ifdef MS_SLAVE\n\t{ \"slave\",            MS_SLAVE },\n#endif\n#ifdef MS_SHARED\n\t{ \"shared\",           MS_SHARED },\n#endif\n\t{ \"sync\",             MS_SYNCHRONOUS },\n\t{ 0,                  0 },\n};\n\nconst char *ignored_mount_items[] = {\n\t\"defaults=\",\n\t\"errors=\",\n\tNULL\n};\n\nenum TW_FSTAB_FLAGS {\n\tTWFLAG_DEFAULTS, // Retain position\n\tTWFLAG_ANDSEC,\n\tTWFLAG_BACKUP,\n\tTWFLAG_BACKUPNAME,\n\tTWFLAG_BLOCKSIZE,\n\tTWFLAG_CANBEWIPED,\n\tTWFLAG_CANENCRYPTBACKUP,\n\tTWFLAG_DISPLAY,\n\tTWFLAG_ENCRYPTABLE,\n\tTWFLAG_FLASHIMG,\n\tTWFLAG_FORCEENCRYPT,\n\tTWFLAG_FSFLAGS,\n\tTWFLAG_IGNOREBLKID,\n\tTWFLAG_LENGTH,\n\tTWFLAG_MOUNTTODECRYPT,\n\tTWFLAG_REMOVABLE,\n\tTWFLAG_RETAINLAYOUTVERSION,\n\tTWFLAG_SETTINGSSTORAGE,\n\tTWFLAG_STORAGE,\n\tTWFLAG_STORAGENAME,\n\tTWFLAG_SUBPARTITIONOF,\n\tTWFLAG_SYMLINK,\n\tTWFLAG_USERDATAENCRYPTBACKUP,\n\tTWFLAG_USERMRF,\n\tTWFLAG_WIPEDURINGFACTORYRESET,\n\tTWFLAG_WIPEINGUI,\n\tTWFLAG_SLOTSELECT,\n\tTWFLAG_WAIT,\n\tTWFLAG_VERIFY,\n\tTWFLAG_CHECK,\n\tTWFLAG_ALTDEVICE,\n\tTWFLAG_NOTRIM,\n\tTWFLAG_VOLDMANAGED,\n\tTWFLAG_FORMATTABLE,\n\tTWFLAG_RESIZE,\n};\n\n/* Flags without a trailing '=' are considered dual format flags and can be\n * written as either 'flagname' or 'flagname=', where the character following\n * the '=' is Y,y,1 for true and false otherwise.\n */\nconst struct flag_list tw_flags[] = {\n\t{ \"andsec\",                 TWFLAG_ANDSEC },\n\t{ \"backup\",                 TWFLAG_BACKUP },\n\t{ \"backupname=\",            TWFLAG_BACKUPNAME },\n\t{ \"blocksize=\",             TWFLAG_BLOCKSIZE },\n\t{ \"canbewiped\",             TWFLAG_CANBEWIPED },\n\t{ \"canencryptbackup\",       TWFLAG_CANENCRYPTBACKUP },\n\t{ \"defaults\",               TWFLAG_DEFAULTS },\n\t{ \"display=\",               TWFLAG_DISPLAY },\n\t{ \"encryptable=\",           TWFLAG_ENCRYPTABLE },\n\t{ \"flashimg\",               TWFLAG_FLASHIMG },\n\t{ \"forceencrypt=\",          TWFLAG_FORCEENCRYPT },\n\t{ \"fsflags=\",               TWFLAG_FSFLAGS },\n\t{ \"ignoreblkid\",            TWFLAG_IGNOREBLKID },\n\t{ \"length=\",                TWFLAG_LENGTH },\n\t{ \"mounttodecrypt\",         TWFLAG_MOUNTTODECRYPT },\n\t{ \"removable\",              TWFLAG_REMOVABLE },\n\t{ \"retainlayoutversion\",    TWFLAG_RETAINLAYOUTVERSION },\n\t{ \"settingsstorage\",        TWFLAG_SETTINGSSTORAGE },\n\t{ \"storage\",                TWFLAG_STORAGE },\n\t{ \"storagename=\",           TWFLAG_STORAGENAME },\n\t{ \"subpartitionof=\",        TWFLAG_SUBPARTITIONOF },\n\t{ \"symlink=\",               TWFLAG_SYMLINK },\n\t{ \"userdataencryptbackup\",  TWFLAG_USERDATAENCRYPTBACKUP },\n\t{ \"usermrf\",                TWFLAG_USERMRF },\n\t{ \"wipeduringfactoryreset\", TWFLAG_WIPEDURINGFACTORYRESET },\n\t{ \"wipeingui\",              TWFLAG_WIPEINGUI },\n\t{ \"slotselect\",             TWFLAG_SLOTSELECT },\n\t{ \"wait\",                   TWFLAG_WAIT },\n\t{ \"verify\",                 TWFLAG_VERIFY },\n\t{ \"check\",                  TWFLAG_CHECK },\n\t{ \"altdevice\",              TWFLAG_ALTDEVICE },\n\t{ \"notrim\",                 TWFLAG_NOTRIM },\n\t{ \"voldmanaged=\",           TWFLAG_VOLDMANAGED },\n\t{ \"formattable\",            TWFLAG_FORMATTABLE },\n\t{ \"resize\",                 TWFLAG_RESIZE },\n\t{ 0,                        0 },\n};\n\nTWPartition::TWPartition() {\n\tCan_Be_Mounted = false;\n\tCan_Be_Wiped = false;\n\tCan_Be_Backed_Up = false;\n\tUse_Rm_Rf = false;\n\tWipe_During_Factory_Reset = false;\n\tWipe_Available_in_GUI = false;\n\tIs_SubPartition = false;\n\tHas_SubPartition = false;\n\tSubPartition_Of = \"\";\n\tSymlink_Path = \"\";\n\tSymlink_Mount_Point = \"\";\n\tMount_Point = \"\";\n\tBackup_Path = \"\";\n\tWildcard_Block_Device = false;\n\tSysfs_Entry = \"\";\n\tActual_Block_Device = \"\";\n\tPrimary_Block_Device = \"\";\n\tAlternate_Block_Device = \"\";\n\tRemovable = false;\n\tIs_Present = false;\n\tLength = 0;\n\tSize = 0;\n\tUsed = 0;\n\tFree = 0;\n\tBackup_Size = 0;\n\tCan_Be_Encrypted = false;\n\tIs_Encrypted = false;\n\tIs_Decrypted = false;\n\tIs_FBE = false;\n\tMount_To_Decrypt = false;\n\tDecrypted_Block_Device = \"\";\n\tDisplay_Name = \"\";\n\tBackup_Display_Name = \"\";\n\tStorage_Name = \"\";\n\tBackup_Name = \"\";\n\tBackup_FileName = \"\";\n\tMTD_Name = \"\";\n\tBackup_Method = BM_NONE;\n\tCan_Encrypt_Backup = false;\n\tUse_Userdata_Encryption = false;\n\tHas_Data_Media = false;\n\tHas_Android_Secure = false;\n\tIs_Storage = false;\n\tIs_Settings_Storage = false;\n\tStorage_Path = \"\";\n\tCurrent_File_System = \"\";\n\tFstab_File_System = \"\";\n\tMount_Flags = 0;\n\tMount_Options = \"\";\n\tFormat_Block_Size = 0;\n\tIgnore_Blkid = false;\n\tRetain_Layout_Version = false;\n\tCrypto_Key_Location = \"footer\";\n\tMTP_Storage_ID = 0;\n\tCan_Flash_Img = false;\n\tMount_Read_Only = false;\n\tIs_Adopted_Storage = false;\n\tAdopted_GUID = \"\";\n\tSlotSelect = false;\n}\n\nTWPartition::~TWPartition(void) {\n\t// Do nothing\n}\n\nbool TWPartition::Process_Fstab_Line(const char *fstab_line, bool Display_Error, std::map<string, Flags_Map> *twrp_flags) {\n\tchar full_line[MAX_FSTAB_LINE_LENGTH];\n\tchar twflags[MAX_FSTAB_LINE_LENGTH] = \"\";\n\tchar* ptr;\n\tint line_len = strlen(fstab_line), index = 0, item_index = 0;\n\tbool skip = false;\n\tint fstab_version = 1, mount_point_index = 0, fs_index = 1, block_device_index = 2;\n\tTWPartition *additional_entry = NULL;\n\tstd::map<string, Flags_Map>::iterator it;\n\n\tstrlcpy(full_line, fstab_line, sizeof(full_line));\n\tfor (index = 0; index < line_len; index++) {\n\t\tif (full_line[index] == 34)\n\t\t\tskip = !skip;\n\t\tif (!skip && full_line[index] <= 32)\n\t\t\tfull_line[index] = '\\0';\n\t}\n\tif (line_len < 10)\n\t\treturn false; // There can't possibly be a valid fstab line that is less than 10 chars\n\tif (strncmp(fstab_line, \"/dev/\", strlen(\"/dev/\")) == 0 || strncmp(fstab_line, \"/devices/\", strlen(\"/devices/\")) == 0) {\n\t\tfstab_version = 2;\n\t\tblock_device_index = 0;\n\t\tmount_point_index = 1;\n\t\tfs_index = 2;\n\t}\n\n\tindex = 0;\n\twhile (index < line_len) {\n\t\twhile (index < line_len && full_line[index] == '\\0')\n\t\t\tindex++;\n\t\tif (index >= line_len)\n\t\t\tcontinue;\n\t\tptr = full_line + index;\n\t\tif (item_index == mount_point_index) {\n\t\t\tMount_Point = ptr;\n\t\t\tif (fstab_version == 2) {\n\t\t\t\tadditional_entry = PartitionManager.Find_Partition_By_Path(Mount_Point);\n\t\t\t\tif (additional_entry) {\n\t\t\t\t\tLOGINFO(\"Found an additional entry for '%s'\\n\", Mount_Point.c_str());\n\t\t\t\t}\n\t\t\t}\n\t\t\tLOGINFO(\"Processing '%s'\\n\", Mount_Point.c_str());\n\t\t\tBackup_Path = Mount_Point;\n\t\t\tStorage_Path = Mount_Point;\n\t\t\tDisplay_Name = ptr + 1;\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\titem_index++;\n\t\t} else if (item_index == fs_index) {\n\t\t\t// File System\n\t\t\tFstab_File_System = ptr;\n\t\t\tCurrent_File_System = ptr;\n\t\t\titem_index++;\n\t\t} else if (item_index == block_device_index) {\n\t\t\t// Primary Block Device\n\t\t\tif (Fstab_File_System == \"mtd\" || Fstab_File_System == \"yaffs2\") {\n\t\t\t\tMTD_Name = ptr;\n\t\t\t\tFind_MTD_Block_Device(MTD_Name);\n\t\t\t} else if (Fstab_File_System == \"bml\") {\n\t\t\t\tif (Mount_Point == \"/boot\")\n\t\t\t\t\tMTD_Name = \"boot\";\n\t\t\t\telse if (Mount_Point == \"/recovery\")\n\t\t\t\t\tMTD_Name = \"recovery\";\n\t\t\t\tPrimary_Block_Device = ptr;\n\t\t\t\tif (*ptr != '/')\n\t\t\t\t\tLOGERR(\"Until we get better BML support, you will have to find and provide the full block device path to the BML devices e.g. /dev/block/bml9 instead of the partition name\\n\");\n\t\t\t} else if (*ptr != '/') {\n\t\t\t\tif (Display_Error)\n\t\t\t\t\tLOGERR(\"Invalid block device '%s' in fstab line '%s'\", ptr, fstab_line);\n\t\t\t\telse\n\t\t\t\t\tLOGINFO(\"Invalid block device '%s' in fstab line '%s'\", ptr, fstab_line);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tPrimary_Block_Device = ptr;\n\t\t\t\tFind_Real_Block_Device(Primary_Block_Device, Display_Error);\n\t\t\t}\n\t\t\titem_index++;\n\t\t} else if (item_index > 2) {\n\t\t\tif (fstab_version == 2) {\n\t\t\t\tif (item_index == 3) {\n\t\t\t\t\tProcess_FS_Flags(ptr);\n\t\t\t\t\tif (additional_entry) {\n\t\t\t\t\t\tadditional_entry->Save_FS_Flags(Fstab_File_System, Mount_Flags, Mount_Options);\n\t\t\t\t\t\treturn false; // We save the extra fs flags in the other partition entry and by returning false, this entry will be deleted\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(twflags, ptr, sizeof(twflags));\n\t\t\t\t}\n\t\t\t\titem_index++;\n\t\t\t} else if (*ptr == '/') { // v2 fstab does not allow alternate block devices\n\t\t\t\t// Alternate Block Device\n\t\t\t\tAlternate_Block_Device = ptr;\n\t\t\t\tFind_Real_Block_Device(Alternate_Block_Device, Display_Error);\n\t\t\t} else if (strlen(ptr) > 7 && strncmp(ptr, \"length=\", 7) == 0) {\n\t\t\t\t// Partition length\n\t\t\t\tptr += 7;\n\t\t\t\tLength = atoi(ptr);\n\t\t\t} else if (strlen(ptr) > 6 && strncmp(ptr, \"flags=\", 6) == 0) {\n\t\t\t\t// Custom flags, save for later so that new values aren't overwritten by defaults\n\t\t\t\tptr += 6;\n\t\t\t\tstrlcpy(twflags, ptr, sizeof(twflags));\n\t\t\t} else if (strlen(ptr) == 4 && (strncmp(ptr, \"NULL\", 4) == 0 || strncmp(ptr, \"null\", 4) == 0 || strncmp(ptr, \"null\", 4) == 0)) {\n\t\t\t\t// Do nothing\n\t\t\t} else {\n\t\t\t\t// Unhandled data\n\t\t\t\tLOGINFO(\"Unhandled fstab information '%s' in fstab line '%s'\\n\", ptr, fstab_line);\n\t\t\t}\n\t\t}\n\t\twhile (index < line_len && full_line[index] != '\\0')\n\t\t\tindex++;\n\t}\n\n\t// override block devices from the v2 fstab with the ones we read from the twrp.flags file in case they are different\n\tif (fstab_version == 2 && twrp_flags && twrp_flags->size() > 0) {\n\t\tit = twrp_flags->find(Mount_Point);\n\t\tif (it != twrp_flags->end()) {\n\t\t\tif (!it->second.Primary_Block_Device.empty()) {\n\t\t\t\tPrimary_Block_Device = it->second.Primary_Block_Device;\n\t\t\t\tFind_Real_Block_Device(Primary_Block_Device, Display_Error);\n\t\t\t}\n\t\t\tif (!it->second.Alternate_Block_Device.empty()) {\n\t\t\t\tAlternate_Block_Device = it->second.Alternate_Block_Device;\n\t\t\t\tFind_Real_Block_Device(Alternate_Block_Device, Display_Error);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (strncmp(fstab_line, \"/devices/\", strlen(\"/devices/\")) == 0) {\n\t\tSysfs_Entry = Primary_Block_Device;\n\t\tPrimary_Block_Device = \"\";\n\t\tIs_Storage = true;\n\t\tRemovable = true;\n\t\tWipe_Available_in_GUI = true;\n\t\tWildcard_Block_Device = true;\n\t}\n\tif (Primary_Block_Device.find(\"*\") != string::npos)\n\t\tWildcard_Block_Device = true;\n\n\tif (Mount_Point == \"auto\") {\n\t\tMount_Point = \"/auto\";\n\t\tchar autoi[5];\n\t\tsprintf(autoi, \"%i\", auto_index);\n\t\tMount_Point += autoi;\n\t\tBackup_Path = Mount_Point;\n\t\tStorage_Path = Mount_Point;\n\t\tauto_index++;\n\t\tSetup_File_System(Display_Error);\n\t\tDisplay_Name = \"Storage\";\n\t\tBackup_Display_Name = Display_Name;\n\t\tStorage_Name = Display_Name;\n\t\tCan_Be_Backed_Up = false;\n\t\tWipe_Available_in_GUI = true;\n\t\tIs_Storage = true;\n\t\tRemovable = true;\n\t\tWipe_Available_in_GUI = true;\n\t} else if (!Is_File_System(Fstab_File_System) && !Is_Image(Fstab_File_System)) {\n\t\tif (Display_Error)\n\t\t\tLOGERR(\"Unknown File System: '%s'\\n\", Fstab_File_System.c_str());\n\t\telse\n\t\t\tLOGINFO(\"Unknown File System: '%s'\\n\", Fstab_File_System.c_str());\n\t\treturn false;\n\t} else if (Is_File_System(Fstab_File_System)) {\n\t\tFind_Actual_Block_Device();\n\t\tSetup_File_System(Display_Error);\n\t\tif (Mount_Point == \"/system\") {\n\t\t\tDisplay_Name = \"System\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\tWipe_Available_in_GUI = true;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t\tMount_Read_Only = true;\n\t\t} else if (Mount_Point == \"/data\") {\n\t\t\tDisplay_Name = \"Data\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\tWipe_Available_in_GUI = true;\n\t\t\tWipe_During_Factory_Reset = true;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t\tCan_Encrypt_Backup = true;\n\t\t\tUse_Userdata_Encryption = true;\n\t\t} else if (Mount_Point == \"/cache\") {\n\t\t\tDisplay_Name = \"Cache\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\tWipe_Available_in_GUI = true;\n\t\t\tWipe_During_Factory_Reset = true;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t} else if (Mount_Point == \"/datadata\") {\n\t\t\tWipe_During_Factory_Reset = true;\n\t\t\tDisplay_Name = \"DataData\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\tIs_SubPartition = true;\n\t\t\tSubPartition_Of = \"/data\";\n\t\t\tDataManager::SetValue(TW_HAS_DATADATA, 1);\n\t\t\tCan_Be_Backed_Up = true;\n\t\t\tCan_Encrypt_Backup = true;\n\t\t\tUse_Userdata_Encryption = false; // This whole partition should be encrypted\n\t\t} else if (Mount_Point == \"/sd-ext\") {\n\t\t\tWipe_During_Factory_Reset = true;\n\t\t\tDisplay_Name = \"SD-Ext\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\tWipe_Available_in_GUI = true;\n\t\t\tRemovable = true;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t\tCan_Encrypt_Backup = true;\n\t\t\tUse_Userdata_Encryption = true;\n\t\t} else if (Mount_Point == \"/boot\") {\n\t\t\tDisplay_Name = \"Boot\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tDataManager::SetValue(\"tw_boot_is_mountable\", 1);\n\t\t\tCan_Be_Backed_Up = true;\n\t\t} else if (Mount_Point == \"/vendor\") {\n\t\t\tDisplay_Name = \"Vendor\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tStorage_Name = Display_Name;\n\t\t\tMount_Read_Only = true;\n\t\t}\n#ifdef TW_EXTERNAL_STORAGE_PATH\n\t\tif (Mount_Point == EXPAND(TW_EXTERNAL_STORAGE_PATH)) {\n\t\t\tIs_Storage = true;\n\t\t\tStorage_Path = EXPAND(TW_EXTERNAL_STORAGE_PATH);\n\t\t\tRemovable = true;\n\t\t\tWipe_Available_in_GUI = true;\n#else\n\t\tif (Mount_Point == \"/sdcard\" || Mount_Point == \"/external_sd\" || Mount_Point == \"/external_sdcard\") {\n\t\t\tIs_Storage = true;\n\t\t\tRemovable = true;\n\t\t\tWipe_Available_in_GUI = true;\n#endif\n\t\t}\n#ifdef TW_INTERNAL_STORAGE_PATH\n\t\tif (Mount_Point == EXPAND(TW_INTERNAL_STORAGE_PATH)) {\n\t\t\tIs_Storage = true;\n\t\t\tIs_Settings_Storage = true;\n\t\t\tStorage_Path = EXPAND(TW_INTERNAL_STORAGE_PATH);\n\t\t\tWipe_Available_in_GUI = true;\n\t\t}\n#else\n\t\tif (Mount_Point == \"/emmc\" || Mount_Point == \"/internal_sd\" || Mount_Point == \"/internal_sdcard\") {\n\t\t\tIs_Storage = true;\n\t\t\tIs_Settings_Storage = true;\n\t\t\tWipe_Available_in_GUI = true;\n\t\t}\n#endif\n\t} else if (Is_Image(Fstab_File_System)) {\n\t\tFind_Actual_Block_Device();\n\t\tSetup_Image();\n\t\tif (Mount_Point == \"/boot\") {\n\t\t\tDisplay_Name = \"Boot\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t\tCan_Flash_Img = true;\n\t\t} else if (Mount_Point == \"/recovery\") {\n\t\t\tDisplay_Name = \"Recovery\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tCan_Flash_Img = true;\n\t\t} else if (Mount_Point == \"/system_image\") {\n\t\t\tDisplay_Name = \"System Image\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tCan_Flash_Img = true;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t} else if (Mount_Point == \"/vendor_image\") {\n\t\t\tDisplay_Name = \"Vendor Image\";\n\t\t\tBackup_Display_Name = Display_Name;\n\t\t\tCan_Flash_Img = true;\n\t\t\tCan_Be_Backed_Up = true;\n\t\t}\n\t}\n\n\t// Process TWRP fstab flags\n\tif (strlen(twflags) > 0) {\n\t\tstring Prev_Display_Name = Display_Name;\n\t\tstring Prev_Storage_Name = Storage_Name;\n\t\tstring Prev_Backup_Display_Name = Backup_Display_Name;\n\t\tDisplay_Name = \"\";\n\t\tStorage_Name = \"\";\n\t\tBackup_Display_Name = \"\";\n\n\t\tProcess_TW_Flags(twflags, (fstab_version == 1), fstab_version);\n\t\tSave_FS_Flags(Fstab_File_System, Mount_Flags, Mount_Options);\n\n\t\tbool has_display_name = !Display_Name.empty();\n\t\tbool has_storage_name = !Storage_Name.empty();\n\t\tbool has_backup_name = !Backup_Display_Name.empty();\n\t\tif (!has_display_name) Display_Name = Prev_Display_Name;\n\t\tif (!has_storage_name) Storage_Name = Prev_Storage_Name;\n\t\tif (!has_backup_name) Backup_Display_Name = Prev_Backup_Display_Name;\n\n\t\tif (has_display_name && !has_storage_name)\n\t\t\tStorage_Name = Display_Name;\n\t\tif (!has_display_name && has_storage_name)\n\t\t\tDisplay_Name = Storage_Name;\n\t\tif (has_display_name && !has_backup_name && Backup_Display_Name != \"Android Secure\")\n\t\t\tBackup_Display_Name = Display_Name;\n\t\tif (!has_display_name && has_backup_name)\n\t\t\tDisplay_Name = Backup_Display_Name;\n\t}\n\n\tif (fstab_version == 2 && twrp_flags && twrp_flags->size() > 0) {\n\t\tit = twrp_flags->find(Mount_Point);\n\t\tif (it != twrp_flags->end()) {\n\t\t\tchar twrpflags[MAX_FSTAB_LINE_LENGTH] = \"\";\n\t\t\tint skip = 0;\n\t\t\tstring Flags = it->second.Flags;\n\t\t\tstrcpy(twrpflags, Flags.c_str());\n\t\t\tif (strlen(twrpflags) > strlen(\"flags=\") && strncmp(twrpflags, \"flags=\", strlen(\"flags=\")) == 0)\n\t\t\t\tskip += strlen(\"flags=\");\n\t\t\tchar* flagptr = twrpflags;\n\t\t\tflagptr += skip;\n\t\t\tProcess_TW_Flags(flagptr, Display_Error, 1); // Forcing the fstab to ver 1 because this data is coming from the /etc/twrp.flags which should be using the TWRP v1 flags format\n\t\t}\n\t}\n\n\tif (Mount_Point == \"/persist\" && Can_Be_Mounted) {\n\t\tbool mounted = Is_Mounted();\n\t\tif (mounted || Mount(false)) {\n\t\t\t// Read the backup settings file\n\t\t\tDataManager::LoadPersistValues();\n\t\t\tTWFunc::Fixup_Time_On_Boot(\"/persist/time/\");\n\t\t\tif (!mounted)\n\t\t\t\tUnMount(false);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid TWPartition::Partition_Post_Processing(bool Display_Error) {\n\tif (Mount_Point == \"/data\")\n\t\tSetup_Data_Partition(Display_Error);\n\telse if (Mount_Point == \"/cache\")\n\t\tSetup_Cache_Partition(Display_Error);\n}\n\nvoid TWPartition::ExcludeAll(const string& path) {\n\tbackup_exclusions.add_absolute_dir(path);\n\twipe_exclusions.add_absolute_dir(path);\n}\n\nvoid TWPartition::Setup_Data_Partition(bool Display_Error) {\n\tif (Mount_Point != \"/data\")\n\t\treturn;\n\n\t// Ensure /data is not mounted as tmpfs for qcom hardware decrypt\n\tUnMount(false);\n\n#ifdef TW_INCLUDE_CRYPTO\n\tif (datamedia)\n\t\tSetup_Data_Media();\n\tCan_Be_Encrypted = true;\n\tchar crypto_blkdev[255];\n\tproperty_get(\"ro.crypto.fs_crypto_blkdev\", crypto_blkdev, \"error\");\n\tif (strcmp(crypto_blkdev, \"error\") != 0) {\n\t\tDataManager::SetValue(TW_IS_DECRYPTED, 1);\n\t\tIs_Encrypted = true;\n\t\tIs_Decrypted = true;\n\t\tIs_FBE = false;\n\t\tDataManager::SetValue(TW_IS_FBE, 0);\n\t\tDecrypted_Block_Device = crypto_blkdev;\n\t\tLOGINFO(\"Data already decrypted, new block device: '%s'\\n\", crypto_blkdev);\n\t} else if (!Mount(false)) {\n\t\tif (Is_Present) {\n\t\t\tset_partition_data(Actual_Block_Device.c_str(), Crypto_Key_Location.c_str(), Fstab_File_System.c_str());\n\t\t\tif (cryptfs_check_footer() == 0) {\n\t\t\t\tIs_Encrypted = true;\n\t\t\t\tIs_Decrypted = false;\n\t\t\t\tCan_Be_Mounted = false;\n\t\t\t\tCurrent_File_System = \"emmc\";\n\t\t\t\tSetup_Image();\n\t\t\t\tDataManager::SetValue(TW_IS_ENCRYPTED, 1);\n\t\t\t\tDataManager::SetValue(TW_CRYPTO_PWTYPE, cryptfs_get_password_type());\n\t\t\t\tDataManager::SetValue(TW_CRYPTO_PASSWORD, \"\");\n\t\t\t\tDataManager::SetValue(\"tw_crypto_display\", \"\");\n\t\t\t} else {\n\t\t\t\tgui_err(\"mount_data_footer=Could not mount /data and unable to find crypto footer.\");\n\t\t\t}\n\t\t} else {\n\t\t\tLOGERR(\"Primary block device '%s' for mount point '%s' is not present!\\n\", Primary_Block_Device.c_str(), Mount_Point.c_str());\n\t\t}\n\t} else {\n\t\tif (TWFunc::Path_Exists(\"/data/unencrypted/key/version\")) {\n\t\t\tLOGINFO(\"File Based Encryption is present\\n\");\n#ifdef TW_INCLUDE_FBE\n\t\t\tExcludeAll(Mount_Point + \"/convert_fbe\");\n\t\t\tExcludeAll(Mount_Point + \"/unencrypted\");\n\t\t\t//ExcludeAll(Mount_Point + \"/system/users/0\"); // we WILL need to retain some of this if multiple users are present or we just need to delete more folders for the extra users somewhere else\n\t\t\tExcludeAll(Mount_Point + \"/misc/vold/user_keys\");\n\t\t\t//ExcludeAll(Mount_Point + \"/system_ce\");\n\t\t\t//ExcludeAll(Mount_Point + \"/system_de\");\n\t\t\t//ExcludeAll(Mount_Point + \"/misc_ce\");\n\t\t\t//ExcludeAll(Mount_Point + \"/misc_de\");\n\t\t\tExcludeAll(Mount_Point + \"/system/gatekeeper.password.key\");\n\t\t\tExcludeAll(Mount_Point + \"/system/gatekeeper.pattern.key\");\n\t\t\tExcludeAll(Mount_Point + \"/system/locksettings.db\");\n\t\t\t//ExcludeAll(Mount_Point + \"/system/locksettings.db-shm\"); // don't seem to need this one, but the other 2 are needed\n\t\t\tExcludeAll(Mount_Point + \"/system/locksettings.db-wal\");\n\t\t\t//ExcludeAll(Mount_Point + \"/user_de\");\n\t\t\t//ExcludeAll(Mount_Point + \"/misc/profiles/cur/0\"); // might be important later\n\t\t\tExcludeAll(Mount_Point + \"/misc/gatekeeper\");\n\t\t\tExcludeAll(Mount_Point + \"/misc/keystore\");\n\t\t\tExcludeAll(Mount_Point + \"/drm/kek.dat\");\n\t\t\tExcludeAll(Mount_Point + \"/system_de/0/spblob\"); // contains data needed to decrypt pixel 2\n\t\t\tint retry_count = 3;\n\t\t\twhile (!Decrypt_DE() && --retry_count)\n\t\t\t\tusleep(2000);\n\t\t\tif (retry_count > 0) {\n\t\t\t\tproperty_set(\"ro.crypto.state\", \"encrypted\");\n\t\t\t\tIs_Encrypted = true;\n\t\t\t\tIs_Decrypted = false;\n\t\t\t\tIs_FBE = true;\n\t\t\t\tDataManager::SetValue(TW_IS_FBE, 1);\n\t\t\t\tDataManager::SetValue(TW_IS_ENCRYPTED, 1);\n\t\t\t\tstring filename;\n\t\t\t\tint pwd_type = Get_Password_Type(0, filename);\n\t\t\t\tif (pwd_type < 0) {\n\t\t\t\t\tLOGERR(\"This TWRP does not have synthetic password decrypt support\\n\");\n\t\t\t\t\tpwd_type = 0; // default password\n\t\t\t\t}\n\t\t\t\tDataManager::SetValue(TW_CRYPTO_PWTYPE, pwd_type);\n\t\t\t\tDataManager::SetValue(TW_CRYPTO_PASSWORD, \"\");\n\t\t\t\tDataManager::SetValue(\"tw_crypto_display\", \"\");\n\t\t\t}\n#else\n\t\t\tLOGERR(\"FBE found but FBE support not present in TWRP\\n\");\n#endif\n\t\t} else {\n\t\t\t// Filesystem is not encrypted and the mount succeeded, so return to\n\t\t\t// the original unmounted state\n\t\t\tUnMount(false);\n\t\t}\n\t}\n\tif (datamedia && (!Is_Encrypted || (Is_Encrypted && Is_Decrypted))) {\n\t\tSetup_Data_Media();\n\t\tRecreate_Media_Folder();\n\t}\n#else\n\tif (datamedia) {\n\t\tSetup_Data_Media();\n\t\tRecreate_Media_Folder();\n\t}\n#endif\n}\n\nvoid TWPartition::Setup_Cache_Partition(bool Display_Error __unused) {\n\tif (Mount_Point != \"/cache\")\n\t\treturn;\n\n\tif (!Mount(true))\n\t\treturn;\n\n\tif (!TWFunc::Path_Exists(\"/cache/recovery/.\")) {\n\t\tLOGINFO(\"Recreating /cache/recovery folder\\n\");\n\t\tif (mkdir(\"/cache/recovery\", S_IRWXU | S_IRWXG | S_IWGRP | S_IXGRP) != 0)\n\t\t\tLOGERR(\"Could not create /cache/recovery\\n\");\n\t}\n}\n\nvoid TWPartition::Process_FS_Flags(const char *str) {\n\tchar *options = strdup(str);\n\tchar *ptr, *savep;\n\n\tMount_Options = \"\";\n\n\t// Avoid issues with potentially nested strtok by using strtok_r\n\tfor (ptr = strtok_r(options, \",\", &savep); ptr; ptr = strtok_r(NULL, \",\", &savep)) {\n\t\tchar *equals = strstr(ptr, \"=\");\n\t\tsize_t name_len;\n\n\t\tif (!equals)\n\t\t\tname_len = strlen(ptr);\n\t\telse\n\t\t\tname_len = equals - ptr;\n\n\t\t// There are some flags that we want to ignore in TWRP\n\t\tbool found_match = false;\n\t\tfor (const char** ignored_mount_item = ignored_mount_items; *ignored_mount_item; ignored_mount_item++) {\n\t\t\tif (strncmp(ptr, *ignored_mount_item, name_len) == 0) {\n\t\t\t\tfound_match = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found_match)\n\t\t\tcontinue;\n\n\t\t// mount_flags are never postfixed by '='\n\t\tif (!equals) {\n\t\t\tconst struct flag_list* mount_flag = mount_flags;\n\t\t\tfor (; mount_flag->name; mount_flag++) {\n\t\t\t\tif (strcmp(ptr, mount_flag->name) == 0) {\n\t\t\t\t\tif (mount_flag->flag == MS_RDONLY)\n\t\t\t\t\t\tMount_Read_Only = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tMount_Flags |= (unsigned)mount_flag->flag;\n\t\t\t\t\tfound_match = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found_match)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t// If we aren't ignoring this flag and it's not a mount flag, then it must be a mount option\n\t\tif (!Mount_Options.empty())\n\t\t\tMount_Options += \",\";\n\t\tMount_Options += ptr;\n\t}\n\tfree(options);\n}\n\nvoid TWPartition::Save_FS_Flags(const string& local_File_System, int local_Mount_Flags, const string& local_Mount_Options) {\n\tpartition_fs_flags_struct flags;\n\tflags.File_System = local_File_System;\n\tflags.Mount_Flags = local_Mount_Flags;\n\tflags.Mount_Options = local_Mount_Options;\n\tfs_flags.push_back(flags);\n}\n\nvoid TWPartition::Apply_TW_Flag(const unsigned flag, const char* str, const bool val) {\n\tswitch (flag) {\n\t\tcase TWFLAG_ANDSEC:\n\t\t\tHas_Android_Secure = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_BACKUP:\n\t\t\tCan_Be_Backed_Up = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_BACKUPNAME:\n\t\t\tBackup_Display_Name = str;\n\t\t\tbreak;\n\t\tcase TWFLAG_BLOCKSIZE:\n\t\t\tFormat_Block_Size = (unsigned long)(atol(str));\n\t\t\tbreak;\n\t\tcase TWFLAG_CANBEWIPED:\n\t\t\tCan_Be_Wiped = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_CANENCRYPTBACKUP:\n\t\t\tCan_Encrypt_Backup = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_DEFAULTS:\n\t\tcase TWFLAG_WAIT:\n\t\tcase TWFLAG_VERIFY:\n\t\tcase TWFLAG_CHECK:\n\t\tcase TWFLAG_NOTRIM:\n\t\tcase TWFLAG_VOLDMANAGED:\n\t\tcase TWFLAG_RESIZE:\n\t\t\t// Do nothing\n\t\t\tbreak;\n\t\tcase TWFLAG_DISPLAY:\n\t\t\tDisplay_Name = str;\n\t\t\tbreak;\n\t\tcase TWFLAG_ENCRYPTABLE:\n\t\tcase TWFLAG_FORCEENCRYPT:\n\t\t\tCrypto_Key_Location = str;\n\t\t\tbreak;\n\t\tcase TWFLAG_FLASHIMG:\n\t\t\tCan_Flash_Img = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_FSFLAGS:\n\t\t\tProcess_FS_Flags(str);\n\t\t\tbreak;\n\t\tcase TWFLAG_IGNOREBLKID:\n\t\t\tIgnore_Blkid = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_LENGTH:\n\t\t\tLength = atoi(str);\n\t\t\tbreak;\n\t\tcase TWFLAG_MOUNTTODECRYPT:\n\t\t\tMount_To_Decrypt = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_REMOVABLE:\n\t\t\tRemovable = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_RETAINLAYOUTVERSION:\n\t\t\tRetain_Layout_Version = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_SETTINGSSTORAGE:\n\t\t\tIs_Settings_Storage = val;\n\t\t\tif (Is_Settings_Storage)\n\t\t\t\tIs_Storage = true;\n\t\t\tbreak;\n\t\tcase TWFLAG_STORAGE:\n\t\t\tIs_Storage = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_STORAGENAME:\n\t\t\tStorage_Name = str;\n\t\t\tbreak;\n\t\tcase TWFLAG_SUBPARTITIONOF:\n\t\t\tIs_SubPartition = true;\n\t\t\tSubPartition_Of = str;\n\t\t\tbreak;\n\t\tcase TWFLAG_SYMLINK:\n\t\t\tSymlink_Path = str;\n\t\t\tbreak;\n\t\tcase TWFLAG_USERDATAENCRYPTBACKUP:\n\t\t\tUse_Userdata_Encryption = val;\n\t\t\tif (Use_Userdata_Encryption)\n\t\t\t\tCan_Encrypt_Backup = true;\n\t\t\tbreak;\n\t\tcase TWFLAG_USERMRF:\n\t\t\tUse_Rm_Rf = val;\n\t\t\tbreak;\n\t\tcase TWFLAG_WIPEDURINGFACTORYRESET:\n\t\t\tWipe_During_Factory_Reset = val;\n\t\t\tif (Wipe_During_Factory_Reset) {\n\t\t\t\tCan_Be_Wiped = true;\n\t\t\t\tWipe_Available_in_GUI = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TWFLAG_WIPEINGUI:\n\t\tcase TWFLAG_FORMATTABLE:\n\t\t\tWipe_Available_in_GUI = val;\n\t\t\tif (Wipe_Available_in_GUI)\n\t\t\t\tCan_Be_Wiped = true;\n\t\t\tbreak;\n\t\tcase TWFLAG_SLOTSELECT:\n\t\t\tSlotSelect = true;\n\t\t\tbreak;\n\t\tcase TWFLAG_ALTDEVICE:\n\t\t\tAlternate_Block_Device = str;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Should not get here\n\t\t\tLOGINFO(\"Flag identified for processing, but later unmatched: %i\\n\", flag);\n\t\t\tbreak;\n\t}\n}\n\nvoid TWPartition::Process_TW_Flags(char *flags, bool Display_Error, int fstab_ver) {\n\tchar separator[2] = {'\\n', 0};\n\tchar *ptr, *savep;\n\tchar source_separator = ';';\n\n\tif (fstab_ver == 2)\n\t\tsource_separator = ',';\n\n\t// Semicolons within double-quotes are not forbidden, so replace\n\t// only the semicolons intended as separators with '\\n' for strtok\n\tfor (unsigned i = 0, skip = 0; i < strlen(flags); i++) {\n\t\tif (flags[i] == '\\\"')\n\t\t\tskip = !skip;\n\t\tif (!skip && flags[i] == source_separator)\n\t\t\tflags[i] = separator[0];\n\t}\n\n\t// Avoid issues with potentially nested strtok by using strtok_r\n\tptr = strtok_r(flags, separator, &savep);\n\twhile (ptr) {\n\t\tint ptr_len = strlen(ptr);\n\t\tconst struct flag_list* tw_flag = tw_flags;\n\n\t\tfor (; tw_flag->name; tw_flag++) {\n\t\t\tint flag_len = strlen(tw_flag->name);\n\n\t\t\tif (strncmp(ptr, tw_flag->name, flag_len) == 0) {\n\t\t\t\tbool flag_val = false;\n\n\t\t\t\tif (ptr_len > flag_len && (tw_flag->name)[flag_len-1] != '='\n\t\t\t\t\t\t&& ptr[flag_len] != '=') {\n\t\t\t\t\t// Handle flags with same starting string\n\t\t\t\t\t// (e.g. backup and backupname)\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ptr_len > flag_len && ptr[flag_len] == '=') {\n\t\t\t\t\t// Handle flags with dual format: Part 1\n\t\t\t\t\t// (e.g. backup and backup=y. backup=y handled here)\n\t\t\t\t\tptr += flag_len + 1;\n\t\t\t\t\tTWFunc::Strip_Quotes(ptr);\n\t\t\t\t\t// Skip flags with empty argument\n\t\t\t\t\t// (e.g. backup=)\n\t\t\t\t\tif (strlen(ptr) == 0) {\n\t\t\t\t\t\tLOGINFO(\"Flag missing argument or should not include '=': %s=\\n\", tw_flag->name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tflag_val = strchr(\"yY1\", *ptr) != NULL;\n\t\t\t\t} else if (ptr_len == flag_len\n\t\t\t\t\t\t&& (tw_flag->name)[flag_len-1] == '=') {\n\t\t\t\t\t// Skip flags missing argument after =\n\t\t\t\t\t// (e.g. backupname=)\n\t\t\t\t\tLOGINFO(\"Flag missing argument: %s\\n\", tw_flag->name);\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ptr_len > flag_len\n\t\t\t\t\t\t&& (tw_flag->name)[flag_len-1] == '=') {\n\t\t\t\t\t// Handle arguments to flags\n\t\t\t\t\t// (e.g. backupname=\"My Stuff\")\n\t\t\t\t\tptr += flag_len;\n\t\t\t\t\tTWFunc::Strip_Quotes(ptr);\n\t\t\t\t\t// Skip flags with empty argument\n\t\t\t\t\t// (e.g. backupname=\"\")\n\t\t\t\t\tif (strlen(ptr) == 0) {\n\t\t\t\t\t\tLOGINFO(\"Flag missing argument: %s\\n\", tw_flag->name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (ptr_len == flag_len) {\n\t\t\t\t\t// Handle flags with dual format: Part 2\n\t\t\t\t\t// (e.g. backup and backup=y. backup handled here)\n\t\t\t\t\tflag_val = true;\n\t\t\t\t} else {\n\t\t\t\t\tLOGINFO(\"Flag matched, but could not be processed: %s\\n\", ptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tApply_TW_Flag(tw_flag->flag, ptr, flag_val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (tw_flag->name == 0) {\n\t\t\tif (Display_Error)\n\t\t\t\tLOGERR(\"Unhandled flag: '%s'\\n\", ptr);\n\t\t\telse\n\t\t\t\tLOGINFO(\"Unhandled flag: '%s'\\n\", ptr);\n\t\t}\n\t\tptr = strtok_r(NULL, separator, &savep);\n\t}\n}\n\nbool TWPartition::Is_File_System(string File_System) {\n\tif (File_System == \"ext2\" ||\n\t\tFile_System == \"ext3\" ||\n\t\tFile_System == \"ext4\" ||\n\t\tFile_System == \"vfat\" ||\n\t\tFile_System == \"ntfs\" ||\n\t\tFile_System == \"yaffs2\" ||\n\t\tFile_System == \"exfat\" ||\n\t\tFile_System == \"f2fs\" ||\n\t\tFile_System == \"auto\")\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool TWPartition::Is_Image(string File_System) {\n\tif (File_System == \"emmc\" || File_System == \"mtd\" || File_System == \"bml\")\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool TWPartition::Make_Dir(string Path, bool Display_Error) {\n\tif (TWFunc::Get_D_Type_From_Stat(Path) != S_IFDIR)\n\t\tunlink(Path.c_str());\n\tif (!TWFunc::Path_Exists(Path)) {\n\t\tif (mkdir(Path.c_str(), 0777) == -1) {\n\t\t\tif (Display_Error)\n\t\t\t\tgui_msg(Msg(msg::kError, \"create_folder_strerr=Can not create '{1}' folder ({2}).\")(Path)(strerror(errno)));\n\t\t\telse\n\t\t\t\tLOGINFO(\"Can not create '%s' folder.\\n\", Path.c_str());\n\t\t\treturn false;\n\t\t} else {\n\t\t\tLOGINFO(\"Created '%s' folder.\\n\", Path.c_str());\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid TWPartition::Setup_File_System(bool Display_Error) {\n\tCan_Be_Mounted = true;\n\tCan_Be_Wiped = true;\n\n\t// Make the mount point folder if it doesn't exist\n\tMake_Dir(Mount_Point, Display_Error);\n\tDisplay_Name = Mount_Point.substr(1, Mount_Point.size() - 1);\n\tBackup_Name = Display_Name;\n\tBackup_Method = BM_FILES;\n}\n\nvoid TWPartition::Setup_Image() {\n\tDisplay_Name = Mount_Point.substr(1, Mount_Point.size() - 1);\n\tBackup_Name = Display_Name;\n\tif (Current_File_System == \"emmc\")\n\t\tBackup_Method = BM_DD;\n\telse if (Current_File_System == \"mtd\" || Current_File_System == \"bml\")\n\t\tBackup_Method = BM_FLASH_UTILS;\n\telse\n\t\tLOGINFO(\"Unhandled file system '%s' on image '%s'\\n\", Current_File_System.c_str(), Display_Name.c_str());\n}\n\nvoid TWPartition::Setup_AndSec(void) {\n\tBackup_Display_Name = \"Android Secure\";\n\tBackup_Name = \"and-sec\";\n\tCan_Be_Backed_Up = true;\n\tHas_Android_Secure = true;\n\tSymlink_Path = Mount_Point + \"/.android_secure\";\n\tSymlink_Mount_Point = \"/and-sec\";\n\tBackup_Path = Symlink_Mount_Point;\n\tMake_Dir(\"/and-sec\", true);\n\tRecreate_AndSec_Folder();\n\tMount_Storage_Retry(true);\n}\n\nvoid TWPartition::Setup_Data_Media() {\n\tLOGINFO(\"Setting up '%s' as data/media emulated storage.\\n\", Mount_Point.c_str());\n\tif (Storage_Name.empty() || Storage_Name == \"Data\")\n\t\tStorage_Name = \"Internal Storage\";\n\tHas_Data_Media = true;\n\tIs_Storage = true;\n\tStorage_Path = Mount_Point + \"/media\";\n\tSymlink_Path = Storage_Path;\n\tif (Mount_Point == \"/data\") {\n\t\tIs_Settings_Storage = true;\n\t\tif (strcmp(EXPAND(TW_EXTERNAL_STORAGE_PATH), \"/sdcard\") == 0) {\n\t\t\tMake_Dir(\"/emmc\", false);\n\t\t\tSymlink_Mount_Point = \"/emmc\";\n\t\t} else {\n\t\t\tMake_Dir(\"/sdcard\", false);\n\t\t\tSymlink_Mount_Point = \"/sdcard\";\n\t\t}\n\t\tif (Mount(false) && TWFunc::Path_Exists(Mount_Point + \"/media/0\")) {\n\t\t\tStorage_Path = Mount_Point + \"/media/0\";\n\t\t\tSymlink_Path = Storage_Path;\n\t\t\tDataManager::SetValue(TW_INTERNAL_PATH, Mount_Point + \"/media/0\");\n\t\t\tUnMount(true);\n\t\t}\n\t\tDataManager::SetValue(\"tw_has_internal\", 1);\n\t\tDataManager::SetValue(\"tw_has_data_media\", 1);\n\t\tbackup_exclusions.add_absolute_dir(\"/data/data/com.google.android.music/files\");\n\t\twipe_exclusions.add_absolute_dir(Mount_Point + \"/misc/vold\"); // adopted storage keys\n\t\tExcludeAll(Mount_Point + \"/.layout_version\");\n\t\tExcludeAll(Mount_Point + \"/system/storage.xml\");\n\t} else {\n\t\tif (Mount(true) && TWFunc::Path_Exists(Mount_Point + \"/media/0\")) {\n\t\t\tStorage_Path = Mount_Point + \"/media/0\";\n\t\t\tSymlink_Path = Storage_Path;\n\t\t\tUnMount(true);\n\t\t}\n\t}\n\tExcludeAll(Mount_Point + \"/media\");\n}\n\nvoid TWPartition::Find_Real_Block_Device(string& Block, bool Display_Error) {\n\tchar device[PATH_MAX], realDevice[PATH_MAX];\n\n\tstrcpy(device, Block.c_str());\n\tmemset(realDevice, 0, sizeof(realDevice));\n\twhile (readlink(device, realDevice, sizeof(realDevice)) > 0)\n\t{\n\t\tstrcpy(device, realDevice);\n\t\tmemset(realDevice, 0, sizeof(realDevice));\n\t}\n\n\tif (device[0] != '/') {\n\t\tif (Display_Error)\n\t\t\tLOGERR(\"Invalid symlink path '%s' found on block device '%s'\\n\", device, Block.c_str());\n\t\telse\n\t\t\tLOGINFO(\"Invalid symlink path '%s' found on block device '%s'\\n\", device, Block.c_str());\n\t\treturn;\n\t} else {\n\t\tBlock = device;\n\t\treturn;\n\t}\n}\n\nbool TWPartition::Mount_Storage_Retry(bool Display_Error) {\n\t// On some devices, storage doesn't want to mount right away, retry and sleep\n\tif (!Mount(Display_Error)) {\n\t\tint retry_count = 5;\n\t\twhile (retry_count > 0 && !Mount(false)) {\n\t\t\tusleep(500000);\n\t\t\tretry_count--;\n\t\t}\n\t\treturn Mount(Display_Error);\n\t}\n\treturn true;\n}\n\nbool TWPartition::Find_MTD_Block_Device(string MTD_Name) {\n\tFILE *fp = NULL;\n\tchar line[255];\n\n\tfp = fopen(\"/proc/mtd\", \"rt\");\n\tif (fp == NULL) {\n\t\tLOGERR(\"Device does not support /proc/mtd\\n\");\n\t\treturn false;\n\t}\n\n\twhile (fgets(line, sizeof(line), fp) != NULL)\n\t{\n\t\tchar device[32], label[32];\n\t\tunsigned long size = 0;\n\t\tint deviceId;\n\n\t\tsscanf(line, \"%s %lx %*s %*c%s\", device, &size, label);\n\n\t\t// Skip header and blank lines\n\t\tif ((strcmp(device, \"dev:\") == 0) || (strlen(line) < 8))\n\t\t\tcontinue;\n\n\t\t// Strip off the trailing \" from the label\n\t\tlabel[strlen(label)-1] = '\\0';\n\n\t\tif (strcmp(label, MTD_Name.c_str()) == 0) {\n\t\t\t// We found our device\n\t\t\t// Strip off the trailing : from the device\n\t\t\tdevice[strlen(device)-1] = '\\0';\n\t\t\tif (sscanf(device,\"mtd%d\", &deviceId) == 1) {\n\t\t\t\tsprintf(device, \"/dev/block/mtdblock%d\", deviceId);\n\t\t\t\tPrimary_Block_Device = device;\n\t\t\t\tfclose(fp);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfclose(fp);\n\n\treturn false;\n}\n\nbool TWPartition::Get_Size_Via_statfs(bool Display_Error) {\n\tstruct statfs st;\n\tstring Local_Path = Mount_Point + \"/.\";\n\n\tif (!Mount(Display_Error))\n\t\treturn false;\n\n\tif (statfs(Local_Path.c_str(), &st) != 0) {\n\t\tif (!Removable) {\n\t\t\tif (Display_Error)\n\t\t\t\tLOGERR(\"Unable to statfs '%s'\\n\", Local_Path.c_str());\n\t\t\telse\n\t\t\t\tLOGINFO(\"Unable to statfs '%s'\\n\", Local_Path.c_str());\n\t\t}\n\t\treturn false;\n\t}\n\tSize = (st.f_blocks * st.f_bsize);\n\tUsed = ((st.f_blocks - st.f_bfree) * st.f_bsize);\n\tFree = (st.f_bfree * st.f_bsize);\n\tBackup_Size = Used;\n\treturn true;\n}\n\nbool TWPartition::Get_Size_Via_df(bool Display_Error) {\n\tFILE* fp;\n\tchar command[255], line[512];\n\tint include_block = 1;\n\tunsigned int min_len;\n\n\tif (!Mount(Display_Error))\n\t\treturn false;\n\n\tmin_len = Actual_Block_Device.size() + 2;\n\tsprintf(command, \"df %s > /tmp/dfoutput.txt\", Mount_Point.c_str());\n\tTWFunc::Exec_Cmd(command);\n\tfp = fopen(\"/tmp/dfoutput.txt\", \"rt\");\n\tif (fp == NULL) {\n\t\tLOGINFO(\"Unable to open /tmp/dfoutput.txt.\\n\");\n\t\treturn false;\n\t}\n\n\twhile (fgets(line, sizeof(line), fp) != NULL)\n\t{\n\t\tunsigned long blocks, used, available;\n\t\tchar device[64];\n\t\tchar tmpString[64];\n\n\t\tif (strncmp(line, \"Filesystem\", 10) == 0)\n\t\t\tcontinue;\n\t\tif (strlen(line) < min_len) {\n\t\t\tinclude_block = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (include_block) {\n\t\t\tsscanf(line, \"%s %lu %lu %lu\", device, &blocks, &used, &available);\n\t\t} else {\n\t\t\t// The device block string is so long that the df information is on the next line\n\t\t\tint space_count = 0;\n\t\t\tsprintf(tmpString, \"/dev/block/%s\", Actual_Block_Device.c_str());\n\t\t\twhile (tmpString[space_count] == 32)\n\t\t\t\tspace_count++;\n\t\t\tsscanf(line + space_count, \"%lu %lu %lu\", &blocks, &used, &available);\n\t\t}\n\n\t\t// Adjust block size to byte size\n\t\tSize = blocks * 1024ULL;\n\t\tUsed = used * 1024ULL;\n\t\tFree = available * 1024ULL;\n\t\tBackup_Size = Used;\n\t}\n\tfclose(fp);\n\treturn true;\n}\n\nunsigned long long TWPartition::IOCTL_Get_Block_Size() {\n\tFind_Actual_Block_Device();\n\n\treturn TWFunc::IOCTL_Get_Block_Size(Actual_Block_Device.c_str());\n}\n\nbool TWPartition::Find_Partition_Size(void) {\n\tFILE* fp;\n\tchar line[512];\n\tstring tmpdevice;\n\n\tfp = fopen(\"/proc/dumchar_info\", \"rt\");\n\tif (fp != NULL) {\n\t\twhile (fgets(line, sizeof(line), fp) != NULL)\n\t\t{\n\t\t\tchar label[32], device[32];\n\t\t\tunsigned long size = 0;\n\n\t\t\tsscanf(line, \"%s %lx %*x %*u %s\", label, &size, device);\n\n\t\t\t// Skip header, annotation\tand blank lines\n\t\t\tif ((strncmp(device, \"/dev/\", 5) != 0) || (strlen(line) < 8))\n\t\t\t\tcontinue;\n\n\t\t\ttmpdevice = \"/dev/\";\n\t\t\ttmpdevice += label;\n\t\t\tif (tmpdevice == Primary_Block_Device || tmpdevice == Alternate_Block_Device) {\n\t\t\t\tSize = size;\n\t\t\t\tfclose(fp);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tunsigned long long ioctl_size = IOCTL_Get_Block_Size();\n\tif (ioctl_size) {\n\t\tSize = ioctl_size;\n\t\treturn true;\n\t}\n\n\t// In this case, we'll first get the partitions we care about (with labels)\n\tfp = fopen(\"/proc/partitions\", \"rt\");\n\tif (fp == NULL)\n\t\treturn false;\n\n\twhile (fgets(line, sizeof(line), fp) != NULL)\n\t{\n\t\tunsigned long major, minor, blocks;\n\t\tchar device[512];\n\n\t\tif (strlen(line) < 7 || line[0] == 'm')\t continue;\n\t\tsscanf(line + 1, \"%lu %lu %lu %s\", &major, &minor, &blocks, device);\n\n\t\ttmpdevice = \"/dev/block/\";\n\t\ttmpdevice += device;\n\t\tif (tmpdevice == Primary_Block_Device || tmpdevice == Alternate_Block_Device) {\n\t\t\t// Adjust block size to byte size\n\t\t\tSize = blocks * 1024ULL;\n\t\t\tfclose(fp);\n\t\t\treturn true;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn false;\n}\n\nbool TWPartition::Is_Mounted(void) {\n\tif (!Can_Be_Mounted)\n\t\treturn false;\n\n\tstruct stat st1, st2;\n\tstring test_path;\n\n\t// Check to see if the mount point directory exists\n\ttest_path = Mount_Point + \"/.\";\n\tif (stat(test_path.c_str(), &st1) != 0)  return false;\n\n\t// Check to see if the directory above the mount point exists\n\ttest_path = Mount_Point + \"/../.\";\n\tif (stat(test_path.c_str(), &st2) != 0)  return false;\n\n\t// Compare the device IDs -- if they match then we're (probably) using tmpfs instead of an actual device\n\tint ret = (st1.st_dev != st2.st_dev) ? true : false;\n\n\treturn ret;\n}\n\nbool TWPartition::Is_File_System_Writable(void) {\n\tif (!Is_File_System(Current_File_System) || !Is_Mounted())\n\t\treturn false;\n\n\tstring test_path = Mount_Point + \"/.\";\n\treturn (access(test_path.c_str(), W_OK) == 0);\n}\n\nbool TWPartition::Mount(bool Display_Error) {\n\tint exfat_mounted = 0;\n\tunsigned long flags = Mount_Flags;\n\n\tif (Is_Mounted()) {\n\t\treturn true;\n\t} else if (!Can_Be_Mounted) {\n\t\treturn false;\n\t}\n\n\tFind_Actual_Block_Device();\n\n\t// Check the current file system before mounting\n\tCheck_FS_Type();\n\tif (Current_File_System == \"exfat\" && TWFunc::Path_Exists(\"/sbin/exfat-fuse\")) {\n\t\tstring cmd = \"/sbin/exfat-fuse -o big_writes,max_read=131072,max_write=131072 \" + Actual_Block_Device + \" \" + Mount_Point;\n\t\tLOGINFO(\"cmd: %s\\n\", cmd.c_str());\n\t\tstring result;\n\t\tif (TWFunc::Exec_Cmd(cmd, result) != 0) {\n\t\t\tLOGINFO(\"exfat-fuse failed to mount with result '%s', trying vfat\\n\", result.c_str());\n\t\t\tCurrent_File_System = \"vfat\";\n\t\t} else {\n#ifdef TW_NO_EXFAT_FUSE\n\t\t\tUnMount(false);\n\t\t\t// We'll let the kernel handle it but using exfat-fuse to detect if the file system is actually exfat\n\t\t\t// Some kernels let us mount vfat as exfat which doesn't work out too well\n#else\n\t\t\texfat_mounted = 1;\n#endif\n\t\t}\n\t}\n\n\tif (Current_File_System == \"ntfs\" && (TWFunc::Path_Exists(\"/sbin/ntfs-3g\") || TWFunc::Path_Exists(\"/sbin/mount.ntfs\"))) {\n\t\tstring cmd;\n\t\tstring Ntfsmount_Binary = \"\";\n\n\t\tif (TWFunc::Path_Exists(\"/sbin/ntfs-3g\"))\n\t\t\tNtfsmount_Binary = \"ntfs-3g\";\n\t\telse if (TWFunc::Path_Exists(\"/sbin/mount.ntfs\"))\n\t\t\tNtfsmount_Binary = \"mount.ntfs\";\n\n\t\tif (Mount_Read_Only)\n\t\t\tcmd = \"/sbin/\" + Ntfsmount_Binary + \" -o ro \" + Actual_Block_Device + \" \" + Mount_Point;\n\t\telse\n\t\t\tcmd = \"/sbin/\" + Ntfsmount_Binary + \" \" + Actual_Block_Device + \" \" + Mount_Point;\n\t\tLOGINFO(\"cmd: '%s'\\n\", cmd.c_str());\n\n\t\tif (TWFunc::Exec_Cmd(cmd) == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tLOGINFO(\"ntfs-3g failed to mount, trying regular mount method.\\n\");\n\t\t}\n\t}\n\n\tif (Mount_Read_Only)\n\t\tflags |= MS_RDONLY;\n\n\tif (Fstab_File_System == \"yaffs2\") {\n\t\t// mount an MTD partition as a YAFFS2 filesystem.\n\t\tflags = MS_NOATIME | MS_NODEV | MS_NODIRATIME;\n\t\tif (Mount_Read_Only)\n\t\t\tflags |= MS_RDONLY;\n\t\tif (mount(Actual_Block_Device.c_str(), Mount_Point.c_str(), Fstab_File_System.c_str(), flags, NULL) < 0) {\n\t\t\tif (mount(Actual_Block_Device.c_str(), Mount_Point.c_str(), Fstab_File_System.c_str(), flags | MS_RDONLY, NULL) < 0) {\n\t\t\t\tif (Display_Error)\n\t\t\t\t\tgui_msg(Msg(msg::kError, \"fail_mount=Failed to mount '{1}' ({2})\")(Mount_Point)(strerror(errno)));\n\t\t\t\telse\n\t\t\t\t\tLOGINFO(\"Failed to mount '%s' (MTD)\\n\", Mount_Point.c_str());\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tLOGINFO(\"Mounted '%s' (MTD) as RO\\n\", Mount_Point.c_str());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct stat st;\n\t\t\tstring test_path = Mount_Point;\n\t\t\tif (stat(test_path.c_str(), &st) < 0) {\n\t\t\t\tif (Display_Error)\n\t\t\t\t\tgui_msg(Msg(msg::kError, \"fail_mount=Failed to mount '{1}' ({2})\")(Mount_Point)(strerror(errno)));\n\t\t\t\telse\n\t\t\t\t\tLOGINFO(\"Failed to mount '%s' (MTD)\\n\", Mount_Point.c_str());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmode_t new_mode = st.st_mode | S_IXUSR | S_IXGRP | S_IXOTH;\n\t\t\tif (new_mode != st.st_mode) {\n\t\t\t\tLOGINFO(\"Fixing execute permissions for %s\\n\", Mount_Point.c_str());\n\t\t\t\tif (chmod(Mount_Point.c_str(), new_mode) < 0) {\n\t\t\t\t\tif (Display_Error)\n\t\t\t\t\t\tLOGERR(\"Couldn't fix permissions for %s: %s\\n\", Mount_Point.c_str(), strerror(errno));\n\t\t\t\t\telse\n\t\t\t\t\t\tLOGINFO(\"Couldn't fix permissions for %s: %s\\n\", Mount_Point.c_str(), strerror(errno));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstring mount_fs = Current_File_System;\n\tif (Current_File_System == \"exfat\" && TWFunc::Path_Exists(\"/sys/module/texfat\"))\n\t\tmount_fs = \"texfat\";\n\n\tif (!exfat_mounted &&\n\t\tmount(Actual_Block_Device.c_str(), Mount_Point.c_str(), mount_fs.c_str(), flags, Mount_Options.c_str()) != 0 &&\n\t\tmount(Actual_Block_Device.c_str(), Mount_Point.c_str(), mount_fs.c_str(), flags, NULL) != 0) {\n#ifdef TW_NO_EXFAT_FUSE\n\t\tif (Current_File_System == \"exfat\") {\n\t\t\tLOGINFO(\"Mounting exfat failed, trying vfat...\\n\");\n\t\t\tif (mount(Actual_Block_Device.c_str(), Mount_Point.c_str(), \"vfat\", 0, NULL) != 0) {\n\t\t\t\tif (Display_Error)\n\t\t\t\t\tgui_msg(Msg(msg::kError, \"fail_mount=Failed to mount '{1}' ({2})\")(Mount_Point)(strerror(errno)));\n\t\t\t\telse\n\t\t\t\t\tLOGINFO(\"Unable to mount '%s'\\n\", Mount_Point.c_str());\n\t\t\t\tLOGINFO(\"Actual block device: '%s', current file system: '%s', flags: 0x%8x, options: '%s'\\n\", Actual_Block_Device.c_str(), Current_File_System.c_str(), flags, Mount_Options.c_str());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n#endif\n\t\t\tif (!Removable && Display_Error)\n\t\t\t\tgui_msg(Msg(msg::kError, \"fail_mount=Failed to mount '{1}' ({2})\")(Mount_Point)(strerror(errno)));\n\t\t\telse\n\t\t\t\tLOGINFO(\"Unable to mount '%s'\\n\", Mount_Point.c_str());\n\t\t\tLOGINFO(\"Actual block device: '%s', current file system: '%s'\\n\", Actual_Block_Device.c_str(), Current_File_System.c_str());\n\t\t\treturn false;\n#ifdef TW_NO_EXFAT_FUSE\n\t\t}\n#endif\n\t}\n\n\tif (Removable)\n\t\tUpdate_Size(Display_Error);\n\n\tif (!Symlink_Mount_Point.empty() && TWFunc::Path_Exists(Symlink_Path)) {\n\t\tstring Command = \"mount -o bind '\" + Symlink_Path + \"' '\" + Symlink_Mount_Point + \"'\";\n\t\tTWFunc::Exec_Cmd(Command);\n\t}\n\treturn true;\n}\n\nbool TWPartition::UnMount(bool Display_Error) {\n\tif (Is_Mounted()) {\n\t\tint never_unmount_system;\n\n\t\tDataManager::GetValue(TW_DONT_UNMOUNT_SYSTEM, never_unmount_system);\n\t\tif (never_unmount_system == 1 && Mount_Point == \"/system\")\n\t\t\treturn true; // Never unmount system if you're not supposed to unmount it\n\n\t\tif (Is_Storage && MTP_Storage_ID > 0)\n\t\t\tPartitionManager.Remove_MTP_Storage(MTP_Storage_ID);\n\n\t\tif (!Symlink_Mount_Point.empty())\n\t\t\tumount(Symlink_Mount_Point.c_str());\n\n\t\tumount(Mount_Point.c_str());\n\t\tif (Is_Mounted()) {\n\t\t\tif (Display_Error)\n\t\t\t\tgui_msg(Msg(msg::kError, \"fail_unmount=Failed to unmount '{1}' ({2})\")(Mount_Point)(strerror(errno)));\n\t\t\telse\n\t\t\t\tLOGINFO(\"Unable to unmount '%s'\\n\", Mount_Point.c_str());\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\treturn true;\n\t}\n}\n\nbool TWPartition::ReMount(bool Display_Error) {\n\tif (UnMount(Display_Error))\n\t\treturn Mount(Display_Error);\n\treturn false;\n}\n\nbool TWPartition::ReMount_RW(bool Display_Error) {\n\t// No need to remount if already mounted rw\n\tif (Is_File_System_Writable())\n\t\treturn true;\n\n\tbool ro = Mount_Read_Only;\n\tint flags = Mount_Flags;\n\n\tMount_Read_Only = false;\n\tMount_Flags &= ~MS_RDONLY;\n\n\tbool ret = ReMount(Display_Error);\n\n\tMount_Read_Only = ro;\n\tMount_Flags = flags;\n\n\treturn ret;\n}\n\nbool TWPartition::Wipe(string New_File_System) {\n\tbool wiped = false, update_crypt = false, recreate_media = true;\n\tint check;\n\tstring Layout_Filename = Mount_Point + \"/.layout_version\";\n\n\tif (!Can_Be_Wiped) {\n\t\tgui_msg(Msg(msg::kError, \"cannot_wipe=Partition {1} cannot be wiped.\")(Display_Name));\n\t\treturn false;\n\t}\n\n\tif (Mount_Point == \"/cache\")\n\t\tLog_Offset = 0;\n\n\tif (Retain_Layout_Version && Mount(false) && TWFunc::Path_Exists(Layout_Filename))\n\t\tTWFunc::copy_file(Layout_Filename, \"/.layout_version\", 0600);\n\telse\n\t\tunlink(\"/.layout_version\");\n\n\tif (Has_Data_Media && Current_File_System == New_File_System) {\n\t\twiped = Wipe_Data_Without_Wiping_Media();\n\t\trecreate_media = false;\n\t} else {\n\t\tDataManager::GetValue(TW_RM_RF_VAR, check);\n\n\t\tif (check || Use_Rm_Rf)\n\t\t\twiped = Wipe_RMRF();\n\t\telse if (New_File_System == \"ext4\")\n\t\t\twiped = Wipe_EXT4();\n\t\telse if (New_File_System == \"ext2\" || New_File_System == \"ext3\")\n\t\t\twiped = Wipe_EXT23(New_File_System);\n\t\telse if (New_File_System == \"vfat\")\n\t\t\twiped = Wipe_FAT();\n\t\telse if (New_File_System == \"exfat\")\n\t\t\twiped = Wipe_EXFAT();\n\t\telse if (New_File_System == \"yaffs2\")\n\t\t\twiped = Wipe_MTD();\n\t\telse if (New_File_System == \"f2fs\")\n\t\t\twiped = Wipe_F2FS();\n\t\telse if (New_File_System == \"ntfs\")\n\t\t\twiped = Wipe_NTFS();\n\t\telse {\n\t\t\tLOGERR(\"Unable to wipe '%s' -- unknown file system '%s'\\n\", Mount_Point.c_str(), New_File_System.c_str());\n\t\t\tunlink(\"/.layout_version\");\n\t\t\treturn false;\n\t\t}\n\t\tupdate_crypt = wiped;\n\t}\n\n\tif (wiped) {\n\t\tif (Mount_Point == \"/cache\")\n\t\t\tDataManager::Output_Version();\n\n\t\tif (TWFunc::Path_Exists(\"/.layout_version\") && Mount(false))\n\t\t\tTWFunc::copy_file(\"/.layout_version\", Layout_Filename, 0600);\n\n\t\tif (update_crypt) {\n\t\t\tSetup_File_System(false);\n\t\t\tif (Is_Encrypted && !Is_Decrypted) {\n\t\t\t\t// just wiped an encrypted partition back to its unencrypted state\n\t\t\t\tIs_Encrypted = false;\n\t\t\t\tIs_Decrypted = false;\n\t\t\t\tDecrypted_Block_Device = \"\";\n\t\t\t\tif (Mount_Point == \"/data\") {\n\t\t\t\t\tDataManager::SetValue(TW_IS_ENCRYPTED, 0);\n\t\t\t\t\tDataManager::SetValue(TW_IS_DECRYPTED, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Has_Data_Media && recreate_media) {\n\t\t\tRecreate_Media_Folder();\n\t\t}\n\t\tif (Is_Storage && Mount(false))\n\t\t\tPartitionManager.Add_MTP_Storage(MTP_Storage_ID);\n\t}\n\n\treturn wiped;\n}\n\nbool TWPartition::Wipe() {\n\tif (Is_File_System(Current_File_System))\n\t\treturn Wipe(Current_File_System);\n\telse\n\t\treturn Wipe(Fstab_File_System);\n}\n\nbool TWPartition::Wipe_AndSec(void) {\n\tif (!Has_Android_Secure)\n\t\treturn false;\n\n\tif (!Mount(true))\n\t\treturn false;\n\n\tgui_msg(Msg(\"wiping=Wiping {1}\")(Backup_Display_Name));\n\tTWFunc::removeDir(Mount_Point + \"/.android_secure/\", true);\n\treturn true;\n}\n\nbool TWPartition::Can_Repair() {\n\tif (Mount_Read_Only)\n\t\treturn false;\n\tif (Current_File_System == \"vfat\" && TWFunc::Path_Exists(\"/sbin/fsck.fat\"))\n\t\treturn true;\n\telse if ((Current_File_System == \"ext2\" || Current_File_System == \"ext3\" || Current_File_System == \"ext4\") && TWFunc::Path_Exists(\"/sbin/e2fsck\"))\n\t\treturn true;\n\telse if (Current_File_System == \"exfat\" && TWFunc::Path_Exists(\"/sbin/fsck.exfat\"))\n\t\treturn true;\n\telse if (Current_File_System == \"f2fs\" && TWFunc::Path_Exists(\"/sbin/fsck.f2fs\"))\n\t\treturn true;\n\telse if (Current_File_System == \"ntfs\" && (TWFunc::Path_Exists(\"/sbin/ntfsfix\") || TWFunc::Path_Exists(\"/sbin/fsck.ntfs\")))\n\t\treturn true;\n\treturn false;\n}\n\nbool TWPartition::Repair() {\n\tstring command;\n\n\tif (Current_File_System == \"vfat\") {\n\t\tif (!TWFunc::Path_Exists(\"/sbin/fsck.fat\")) {\n\t\t\tgui_msg(Msg(msg::kError, \"repair_not_exist={1} does not exist! Cannot repair!\")(\"fsck.fat\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\t\tgui_msg(Msg(\"repairing_using=Repairing {1} using {2}...\")(Display_Name)(\"fsck.fat\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"/sbin/fsck.fat -y \" + Actual_Block_Device;\n\t\tLOGINFO(\"Repair command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_repair=Unable to repair {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (Current_File_System == \"ext2\" || Current_File_System == \"ext3\" || Current_File_System == \"ext4\") {\n\t\tif (!TWFunc::Path_Exists(\"/sbin/e2fsck\")) {\n\t\t\tgui_msg(Msg(msg::kError, \"repair_not_exist={1} does not exist! Cannot repair!\")(\"e2fsck\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\t\tgui_msg(Msg(\"repairing_using=Repairing {1} using {2}...\")(Display_Name)(\"e2fsck\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"/sbin/e2fsck -fp \" + Actual_Block_Device;\n\t\tLOGINFO(\"Repair command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_repair=Unable to repair {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (Current_File_System == \"exfat\") {\n\t\tif (!TWFunc::Path_Exists(\"/sbin/fsck.exfat\")) {\n\t\t\tgui_msg(Msg(msg::kError, \"repair_not_exist={1} does not exist! Cannot repair!\")(\"fsck.exfat\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\t\tgui_msg(Msg(\"repairing_using=Repairing {1} using {2}...\")(Display_Name)(\"fsck.exfat\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"/sbin/fsck.exfat \" + Actual_Block_Device;\n\t\tLOGINFO(\"Repair command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_repair=Unable to repair {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (Current_File_System == \"f2fs\") {\n\t\tif (!TWFunc::Path_Exists(\"/sbin/fsck.f2fs\")) {\n\t\t\tgui_msg(Msg(msg::kError, \"repair_not_exist={1} does not exist! Cannot repair!\")(\"fsck.f2fs\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\t\tgui_msg(Msg(\"repairing_using=Repairing {1} using {2}...\")(Display_Name)(\"fsck.f2fs\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"/sbin/fsck.f2fs \" + Actual_Block_Device;\n\t\tLOGINFO(\"Repair command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_repair=Unable to repair {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (Current_File_System == \"ntfs\") {\n\t\tstring Ntfsfix_Binary;\n\t\tif (TWFunc::Path_Exists(\"/sbin/ntfsfix\"))\n\t\t\tNtfsfix_Binary = \"ntfsfix\";\n\t\telse if (TWFunc::Path_Exists(\"/sbin/fsck.ntfs\"))\n\t\t\tNtfsfix_Binary = \"fsck.ntfs\";\n\t\telse {\n\t\t\tgui_msg(Msg(msg::kError, \"repair_not_exist={1} does not exist! Cannot repair!\")(\"ntfsfix\"));\n\t\t\treturn false;\n\t\t}\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\t\tgui_msg(Msg(\"repairing_using=Repairing {1} using {2}...\")(Display_Name)(Ntfsfix_Binary));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"/sbin/\" + Ntfsfix_Binary + \" \" + Actual_Block_Device;\n\t\tLOGINFO(\"Repair command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_repair=Unable to repair {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool TWPartition::Can_Resize() {\n\tif (Mount_Read_Only)\n\t\treturn false;\n\tif ((Current_File_System == \"ext2\" || Current_File_System == \"ext3\" || Current_File_System == \"ext4\") && TWFunc::Path_Exists(\"/sbin/resize2fs\"))\n\t\treturn true;\n\treturn false;\n}\n\nbool TWPartition::Resize() {\n\tstring command;\n\n\tif (Current_File_System == \"ext2\" || Current_File_System == \"ext3\" || Current_File_System == \"ext4\") {\n\t\tif (!Can_Repair()) {\n\t\t\tLOGINFO(\"Cannot resize %s because %s cannot be repaired before resizing.\\n\", Display_Name.c_str(), Display_Name.c_str());\n\t\t\tgui_msg(Msg(msg::kError, \"cannot_resize=Cannot resize {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t\tif (!TWFunc::Path_Exists(\"/sbin/resize2fs\")) {\n\t\t\tLOGINFO(\"resize2fs does not exist! Cannot resize!\\n\");\n\t\t\tgui_msg(Msg(msg::kError, \"cannot_resize=Cannot resize {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t\t// Repair will unmount so no need to do it twice\n\t\tgui_msg(Msg(\"repair_resize=Repairing {1} before resizing.\")( Display_Name));\n\t\tif (!Repair())\n\t\t\treturn false;\n\t\tgui_msg(Msg(\"resizing=Resizing {1} using {2}...\")(Display_Name)(\"resize2fs\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"/sbin/resize2fs \" + Actual_Block_Device;\n\t\tif (Length != 0) {\n\t\t\tunsigned long long Actual_Size = IOCTL_Get_Block_Size();\n\t\t\tif (Actual_Size == 0)\n\t\t\t\treturn false;\n\n\t\t\tunsigned long long Block_Count;\n\t\t\tif (Length < 0) {\n\t\t\t\t// Reduce overall size by this length\n\t\t\t\tBlock_Count = (Actual_Size / 1024LLU) - ((unsigned long long)(Length * -1) / 1024LLU);\n\t\t\t} else {\n\t\t\t\t// This is the size, not a size reduction\n\t\t\t\tBlock_Count = ((unsigned long long)(Length) / 1024LLU);\n\t\t\t}\n\t\t\tchar temp[256];\n\t\t\tsprintf(temp, \"%llu\", Block_Count);\n\t\t\tcommand += \" \";\n\t\t\tcommand += temp;\n\t\t\tcommand += \"K\";\n\t\t}\n\t\tLOGINFO(\"Resize command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tUpdate_Size(true);\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tUpdate_Size(true);\n\t\t\tgui_msg(Msg(msg::kError, \"unable_resize=Unable to resize {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool TWPartition::Backup(PartitionSettings *part_settings, pid_t *tar_fork_pid) {\n\tif (Backup_Method == BM_FILES)\n\t\treturn Backup_Tar(part_settings, tar_fork_pid);\n\telse if (Backup_Method == BM_DD)\n\t\treturn Backup_Image(part_settings);\n\telse if (Backup_Method == BM_FLASH_UTILS)\n\t\treturn Backup_Dump_Image(part_settings);\n\tLOGERR(\"Unknown backup method for '%s'\\n\", Mount_Point.c_str());\n\treturn false;\n}\n\nbool TWPartition::Restore(PartitionSettings *part_settings) {\n\tTWFunc::GUI_Operation_Text(TW_RESTORE_TEXT, Display_Name, gui_parse_text(\"{@restoring_hdr}\"));\n\tLOGINFO(\"Restore filename is: %s/%s\\n\", part_settings->Backup_Folder.c_str(), Backup_FileName.c_str());\n\n\tstring Restore_File_System = Get_Restore_File_System(part_settings);\n\n\tif (Is_File_System(Restore_File_System))\n\t\treturn Restore_Tar(part_settings);\n\telse if (Is_Image(Restore_File_System))\n\t\treturn Restore_Image(part_settings);\n\n\tLOGERR(\"Unknown restore method for '%s'\\n\", Mount_Point.c_str());\n\treturn false;\n}\n\nstring TWPartition::Get_Restore_File_System(PartitionSettings *part_settings) {\n\tsize_t first_period, second_period;\n\tstring Restore_File_System;\n\n\t// Parse backup filename to extract the file system before wiping\n\tfirst_period = Backup_FileName.find(\".\");\n\tif (first_period == string::npos) {\n\t\tLOGERR(\"Unable to find file system (first period).\\n\");\n\t\treturn string();\n\t}\n\tRestore_File_System = Backup_FileName.substr(first_period + 1, Backup_FileName.size() - first_period - 1);\n\tsecond_period = Restore_File_System.find(\".\");\n\tif (second_period == string::npos) {\n\t\tLOGERR(\"Unable to find file system (second period).\\n\");\n\t\treturn string();\n\t}\n\tRestore_File_System.resize(second_period);\n\tLOGINFO(\"Restore file system is: '%s'.\\n\", Restore_File_System.c_str());\n\treturn Restore_File_System;\n}\n\nstring TWPartition::Backup_Method_By_Name() {\n\tif (Backup_Method == BM_NONE)\n\t\treturn \"none\";\n\telse if (Backup_Method == BM_FILES)\n\t\treturn \"files\";\n\telse if (Backup_Method == BM_DD)\n\t\treturn \"dd\";\n\telse if (Backup_Method == BM_FLASH_UTILS)\n\t\treturn \"flash_utils\";\n\telse\n\t\treturn \"undefined\";\n\treturn \"ERROR!\";\n}\n\nbool TWPartition::Decrypt(string Password) {\n\tLOGINFO(\"STUB TWPartition::Decrypt, password: '%s'\\n\", Password.c_str());\n\t// Is this needed?\n\treturn 1;\n}\n\nbool TWPartition::Wipe_Encryption() {\n\tbool Save_Data_Media = Has_Data_Media;\n\n\tif (!UnMount(true))\n\t\treturn false;\n\n\tHas_Data_Media = false;\n\tDecrypted_Block_Device = \"\";\n#ifdef TW_INCLUDE_CRYPTO\n\tif (Is_Decrypted && !Decrypted_Block_Device.empty()) {\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\t\tif (delete_crypto_blk_dev((char*)(\"userdata\")) != 0) {\n\t\t\tLOGERR(\"Error deleting crypto block device, continuing anyway.\\n\");\n\t\t}\n\t}\n#endif\n\tIs_Decrypted = false;\n\tIs_Encrypted = false;\n\tFind_Actual_Block_Device();\n\tif (Crypto_Key_Location == \"footer\") {\n\t\tint newlen, fd;\n\t\tif (Length != 0) {\n\t\t\tnewlen = Length;\n\t\t\tif (newlen < 0)\n\t\t\t\tnewlen = newlen * -1;\n\t\t} else {\n\t\t\tnewlen = CRYPT_FOOTER_OFFSET;\n\t\t}\n\t\tif ((fd = open(Actual_Block_Device.c_str(), O_RDWR)) < 0) {\n\t\t\tgui_print_color(\"warning\", \"Unable to open '%s' to wipe crypto key\\n\", Actual_Block_Device.c_str());\n\t\t} else {\n\t\t\tunsigned int block_count;\n\t\t\tif ((ioctl(fd, BLKGETSIZE, &block_count)) == -1) {\n\t\t\t\tgui_print_color(\"warning\", \"Unable to get block size for wiping crypto footer.\\n\");\n\t\t\t} else {\n\t\t\t\toff64_t offset = ((off64_t)block_count * 512) - newlen;\n\t\t\t\tif (lseek64(fd, offset, SEEK_SET) == -1) {\n\t\t\t\t\tgui_print_color(\"warning\", \"Unable to lseek64 for wiping crypto footer.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tvoid* buffer = malloc(newlen);\n\t\t\t\t\tif (!buffer) {\n\t\t\t\t\t\tgui_print_color(\"warning\", \"Failed to malloc for wiping crypto footer.\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemset(buffer, 0, newlen);\n\t\t\t\t\t\tint ret = write(fd, buffer, newlen);\n\t\t\t\t\t\tif (ret != newlen) {\n\t\t\t\t\t\t\tgui_print_color(\"warning\", \"Failed to wipe crypto footer.\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGINFO(\"Successfully wiped crypto footer.\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(buffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(fd);\n\t\t}\n\t} else {\n\t\tif (TWFunc::IOCTL_Get_Block_Size(Crypto_Key_Location.c_str()) >= 16384LLU) {\n\t\t\tstring Command = \"dd of='\" + Crypto_Key_Location + \"' if=/dev/zero bs=16384 count=1\";\n\t\t\tTWFunc::Exec_Cmd(Command);\n\t\t} else {\n\t\t\tLOGINFO(\"Crypto key location reports size < 16K so not wiping crypto footer.\\n\");\n\t\t}\n\t}\n\tif (Wipe(Fstab_File_System)) {\n\t\tHas_Data_Media = Save_Data_Media;\n\t\tif (Has_Data_Media && !Symlink_Mount_Point.empty()) {\n\t\t\tRecreate_Media_Folder();\n\t\t\tif (Mount(false))\n\t\t\t\tPartitionManager.Add_MTP_Storage(MTP_Storage_ID);\n\t\t}\n\t\tDataManager::SetValue(TW_IS_ENCRYPTED, 0);\n#ifndef TW_OEM_BUILD\n\t\tgui_msg(\"format_data_msg=You may need to reboot recovery to be able to use /data again.\");\n#endif\n\t\treturn true;\n\t} else {\n\t\tHas_Data_Media = Save_Data_Media;\n\t\tgui_err(\"format_data_err=Unable to format to remove encryption.\");\n\t\tif (Has_Data_Media && Mount(false))\n\t\t\tPartitionManager.Add_MTP_Storage(MTP_Storage_ID);\n\t\treturn false;\n\t}\n\treturn false;\n}\n\nvoid TWPartition::Check_FS_Type() {\n\tconst char* type;\n\tblkid_probe pr;\n\n\tif (Fstab_File_System == \"yaffs2\" || Fstab_File_System == \"mtd\" || Fstab_File_System == \"bml\" || Ignore_Blkid)\n\t\treturn; // Running blkid on some mtd devices causes a massive crash or needs to be skipped\n\n\tFind_Actual_Block_Device();\n\tif (!Is_Present)\n\t\treturn;\n\n\tpr = blkid_new_probe_from_filename(Actual_Block_Device.c_str());\n\tif (blkid_do_fullprobe(pr)) {\n\t\tblkid_free_probe(pr);\n\t\tLOGINFO(\"Can't probe device %s\\n\", Actual_Block_Device.c_str());\n\t\treturn;\n\t}\n\n\tif (blkid_probe_lookup_value(pr, \"TYPE\", &type, NULL) < 0) {\n\t\tblkid_free_probe(pr);\n\t\tLOGINFO(\"can't find filesystem on device %s\\n\", Actual_Block_Device.c_str());\n\t\treturn;\n\t}\n\n\tCurrent_File_System = type;\n\tblkid_free_probe(pr);\n\tif (fs_flags.size() > 1) {\n\t\tstd::vector<partition_fs_flags_struct>::iterator iter;\n\t\tstd::vector<partition_fs_flags_struct>::iterator found = fs_flags.begin();\n\n\t\tfor (iter = fs_flags.begin(); iter != fs_flags.end(); iter++) {\n\t\t\tif (iter->File_System == Current_File_System) {\n\t\t\t\tfound = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// If we don't find a match, we default the flags to the first set of flags that we received from the fstab\n\t\tif (Mount_Flags != found->Mount_Flags || Mount_Options != found->Mount_Options) {\n\t\t\tMount_Flags = found->Mount_Flags;\n\t\t\tMount_Options = found->Mount_Options;\n\t\t\tLOGINFO(\"Mount_Flags: %i, Mount_Options: %s\\n\", Mount_Flags, Mount_Options.c_str());\n\t\t}\n\t}\n}\n\nbool TWPartition::Wipe_EXT23(string File_System) {\n\tif (!UnMount(true))\n\t\treturn false;\n\n\tif (TWFunc::Path_Exists(\"/sbin/mke2fs\")) {\n\t\tstring command;\n\n\t\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"mke2fs\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"mke2fs -t \" + File_System + \" -m 0 \" + Actual_Block_Device;\n\t\tLOGINFO(\"mke2fs command: %s\\n\", command.c_str());\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tCurrent_File_System = File_System;\n\t\t\tRecreate_AndSec_Folder();\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\treturn Wipe_RMRF();\n\n\treturn false;\n}\n\nbool TWPartition::Wipe_EXT4() {\n\tFind_Actual_Block_Device();\n\tif (!Is_Present) {\n\t\tLOGINFO(\"Block device not present, cannot wipe %s.\\n\", Display_Name.c_str());\n\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\treturn false;\n\t}\n\tif (!UnMount(true))\n\t\treturn false;\n\n#if defined(USE_EXT4)\n\tint ret;\n\tchar *secontext = NULL;\n\n\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"make_ext4fs\"));\n\n\tif (!selinux_handle || selabel_lookup(selinux_handle, &secontext, Mount_Point.c_str(), S_IFDIR) < 0) {\n\t\tLOGINFO(\"Cannot lookup security context for '%s'\\n\", Mount_Point.c_str());\n\t\tret = make_ext4fs(Actual_Block_Device.c_str(), Length, Mount_Point.c_str(), NULL);\n\t} else {\n\t\tret = make_ext4fs(Actual_Block_Device.c_str(), Length, Mount_Point.c_str(), selinux_handle);\n\t}\n\tif (ret != 0) {\n\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\treturn false;\n\t} else {\n\t\tstring sedir = Mount_Point + \"/lost+found\";\n\t\tPartitionManager.Mount_By_Path(sedir.c_str(), true);\n\t\trmdir(sedir.c_str());\n\t\tmkdir(sedir.c_str(), S_IRWXU | S_IRWXG | S_IWGRP | S_IXGRP);\n\t\treturn true;\n\t}\n#else\n\tif (TWFunc::Path_Exists(\"/sbin/make_ext4fs\")) {\n\t\tstring Command;\n\n\t\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"make_ext4fs\"));\n\t\tFind_Actual_Block_Device();\n\t\tCommand = \"make_ext4fs\";\n\t\tif (!Is_Decrypted && Length != 0) {\n\t\t\t// Only use length if we're not decrypted\n\t\t\tchar len[32];\n\t\t\tsprintf(len, \"%i\", Length);\n\t\t\tCommand += \" -l \";\n\t\t\tCommand += len;\n\t\t}\n\t\tif (TWFunc::Path_Exists(\"/file_contexts\")) {\n\t\t\tCommand += \" -S /file_contexts\";\n\t\t}\n\t\tCommand += \" -a \" + Mount_Point + \" \" + Actual_Block_Device;\n\t\tLOGINFO(\"make_ext4fs command: %s\\n\", Command.c_str());\n\t\tif (TWFunc::Exec_Cmd(Command) == 0) {\n\t\t\tCurrent_File_System = \"ext4\";\n\t\t\tRecreate_AndSec_Folder();\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\treturn Wipe_EXT23(\"ext4\");\n#endif\n\treturn false;\n}\n\nbool TWPartition::Wipe_FAT() {\n\tstring command;\n\n\tif (TWFunc::Path_Exists(\"/sbin/mkfs.fat\")) {\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\n\t\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"mkfs.fat\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"mkfs.fat \" + Actual_Block_Device;\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tCurrent_File_System = \"vfat\";\n\t\t\tRecreate_AndSec_Folder();\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\telse\n\t\treturn Wipe_RMRF();\n\n\treturn false;\n}\n\nbool TWPartition::Wipe_EXFAT() {\n\tstring command;\n\n\tif (TWFunc::Path_Exists(\"/sbin/mkexfatfs\")) {\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\n\t\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"mkexfatfs\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"mkexfatfs \" + Actual_Block_Device;\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tRecreate_AndSec_Folder();\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool TWPartition::Wipe_MTD() {\n\tif (!UnMount(true))\n\t\treturn false;\n\n\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"MTD\"));\n\n\tmtd_scan_partitions();\n\tconst MtdPartition* mtd = mtd_find_partition_by_name(MTD_Name.c_str());\n\tif (mtd == NULL) {\n\t\tLOGERR(\"No mtd partition named '%s'\", MTD_Name.c_str());\n\t\treturn false;\n\t}\n\n\tMtdWriteContext* ctx = mtd_write_partition(mtd);\n\tif (ctx == NULL) {\n\t\tLOGERR(\"Can't write '%s', failed to format.\", MTD_Name.c_str());\n\t\treturn false;\n\t}\n\tif (mtd_erase_blocks(ctx, -1) == -1) {\n\t\tmtd_write_close(ctx);\n\t\tLOGERR(\"Failed to format '%s'\", MTD_Name.c_str());\n\t\treturn false;\n\t}\n\tif (mtd_write_close(ctx) != 0) {\n\t\tLOGERR(\"Failed to close '%s'\", MTD_Name.c_str());\n\t\treturn false;\n\t}\n\tCurrent_File_System = \"yaffs2\";\n\tRecreate_AndSec_Folder();\n\tgui_msg(\"done=Done.\");\n\treturn true;\n}\n\nbool TWPartition::Wipe_RMRF() {\n\tif (!Mount(true))\n\t\treturn false;\n\t// This is the only wipe that leaves the partition mounted, so we\n\t// must manually remove the partition from MTP if it is a storage\n\t// partition.\n\tif (Is_Storage)\n\t\tPartitionManager.Remove_MTP_Storage(MTP_Storage_ID);\n\n\tgui_msg(Msg(\"remove_all=Removing all files under '{1}'\")(Mount_Point));\n\tTWFunc::removeDir(Mount_Point, true);\n\tRecreate_AndSec_Folder();\n\treturn true;\n}\n\nbool TWPartition::Wipe_F2FS() {\n\tstring command;\n\n\tif (TWFunc::Path_Exists(\"/sbin/mkfs.f2fs\")) {\n\t\tif (!UnMount(true))\n\t\t\treturn false;\n\n\t\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(\"mkfs.f2fs\"));\n\t\tFind_Actual_Block_Device();\n\t\tcommand = \"mkfs.f2fs -t 0\";\n\t\tif (!Is_Decrypted && Length != 0) {\n\t\t\t// Only use length if we're not decrypted\n\t\t\tchar len[32];\n\t\t\tint mod_length = Length;\n\t\t\tif (Length < 0)\n\t\t\t\tmod_length *= -1;\n\t\t\tsprintf(len, \"%i\", mod_length);\n\t\t\tcommand += \" -r \";\n\t\t\tcommand += len;\n\t\t}\n\t\tcommand += \" \" + Actual_Block_Device;\n\t\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\t\tRecreate_AndSec_Folder();\n\t\t\tgui_msg(\"done=Done.\");\n\t\t\treturn true;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t} else {\n\t\tLOGINFO(\"mkfs.f2fs binary not found, using rm -rf to wipe.\\n\");\n\t\treturn Wipe_RMRF();\n\t}\n\treturn false;\n}\n\nbool TWPartition::Wipe_NTFS() {\n\tstring command;\n\tstring Ntfsmake_Binary;\n\n\tif (TWFunc::Path_Exists(\"/sbin/mkntfs\"))\n\t\tNtfsmake_Binary = \"mkntfs\";\n\telse if (TWFunc::Path_Exists(\"/sbin/mkfs.ntfs\"))\n\t\tNtfsmake_Binary = \"mkfs.ntfs\";\n\telse\n\t\treturn false;\n\n\tif (!UnMount(true))\n\t\treturn false;\n\n\tgui_msg(Msg(\"formatting_using=Formatting {1} using {2}...\")(Display_Name)(Ntfsmake_Binary));\n\tFind_Actual_Block_Device();\n\tcommand = \"/sbin/\" + Ntfsmake_Binary + \" \" + Actual_Block_Device;\n\tif (TWFunc::Exec_Cmd(command) == 0) {\n\t\tRecreate_AndSec_Folder();\n\t\tgui_msg(\"done=Done.\");\n\t\treturn true;\n\t} else {\n\t\tgui_msg(Msg(msg::kError, \"unable_to_wipe=Unable to wipe {1}.\")(Display_Name));\n\t\treturn false;\n\t}\n\treturn false;\n}\n\nbool TWPartition::Wipe_Data_Without_Wiping_Media() {\n#ifdef TW_OEM_BUILD\n\t// In an OEM Build we want to do a full format\n\treturn Wipe_Encryption();\n#else\n\tbool ret = false;\n\n\tif (!Mount(true))\n\t\treturn false;\n\n\tgui_msg(\"wiping_data=Wiping data without wiping /data/media ...\");\n\tret = Wipe_Data_Without_Wiping_Media_Func(Mount_Point + \"/\");\n\tif (ret)\n\t\tgui_msg(\"done=Done.\");\n\treturn ret;\n#endif // ifdef TW_OEM_BUILD\n}\n\nbool TWPartition::Wipe_Data_Without_Wiping_Media_Func(const string& parent __unused) {\n\tstring dir;\n\n\tDIR* d;\n\td = opendir(parent.c_str());\n\tif (d != NULL) {\n\t\tstruct dirent* de;\n\t\twhile ((de = readdir(d)) != NULL) {\n\t\t\tif (strcmp(de->d_name, \".\") == 0 || strcmp(de->d_name, \"..\") == 0)\t continue;\n\n\t\t\tdir = parent;\n\t\t\tdir.append(de->d_name);\n\t\t\tif (wipe_exclusions.check_skip_dirs(dir)) {\n\t\t\t\tLOGINFO(\"skipped '%s'\\n\", dir.c_str());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (de->d_type == DT_DIR) {\n\t\t\t\tdir.append(\"/\");\n\t\t\t\tif (!Wipe_Data_Without_Wiping_Media_Func(dir)) {\n\t\t\t\t\tclosedir(d);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\trmdir(dir.c_str());\n\t\t\t} else if (de->d_type == DT_REG || de->d_type == DT_LNK || de->d_type == DT_FIFO || de->d_type == DT_SOCK) {\n\t\t\t\tif (unlink(dir.c_str()) != 0)\n\t\t\t\t\tLOGINFO(\"Unable to unlink '%s': %s\\n\", dir.c_str(), strerror(errno));\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\n\t\treturn true;\n\t}\n\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Mount_Point)(strerror(errno)));\n\treturn false;\n}\n\nbool TWPartition::Backup_Tar(PartitionSettings *part_settings, pid_t *tar_fork_pid) {\n\tstring Full_FileName;\n\ttwrpTar tar;\n\n\tif (!Mount(true))\n\t\treturn false;\n\n\tTWFunc::GUI_Operation_Text(TW_BACKUP_TEXT, Backup_Display_Name, \"Backing Up\");\n\tgui_msg(Msg(\"backing_up=Backing up {1}...\")(Backup_Display_Name));\n\n\tDataManager::GetValue(TW_USE_COMPRESSION_VAR, tar.use_compression);\n\n#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS\n\tif (Can_Encrypt_Backup) {\n\t\tDataManager::GetValue(\"tw_encrypt_backup\", tar.use_encryption);\n\t\tif (tar.use_encryption) {\n\t\t\tif (Use_Userdata_Encryption)\n\t\t\t\ttar.userdata_encryption = tar.use_encryption;\n\t\t\tstring Password;\n\t\t\tDataManager::GetValue(\"tw_backup_password\", Password);\n\t\t\ttar.setpassword(Password);\n\t\t} else {\n\t\t\ttar.use_encryption = 0;\n\t\t}\n\t}\n#endif\n\n\tBackup_FileName = Backup_Name + \".\" + Current_File_System + \".win\";\n\tFull_FileName = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\tif (Has_Data_Media)\n\t\tgui_msg(Msg(msg::kWarning, \"backup_storage_warning=Backups of {1} do not include any files in internal storage such as pictures or downloads.\")(Display_Name));\n\ttar.part_settings = part_settings;\n\ttar.backup_exclusions = &backup_exclusions;\n\ttar.setdir(Backup_Path);\n\ttar.setfn(Full_FileName);\n\ttar.setsize(Backup_Size);\n\ttar.partition_name = Backup_Name;\n\ttar.backup_folder = part_settings->Backup_Folder;\n\tif (tar.createTarFork(tar_fork_pid) != 0)\n\t\treturn false;\n\treturn true;\n}\n\nbool TWPartition::Backup_Image(PartitionSettings *part_settings) {\n\tstring Full_FileName, adb_file_name;\n\n\tTWFunc::GUI_Operation_Text(TW_BACKUP_TEXT, Display_Name, gui_parse_text(\"{@backing}\"));\n\tgui_msg(Msg(\"backing_up=Backing up {1}...\")(Backup_Display_Name));\n\n\tBackup_FileName = Backup_Name + \".\" + Current_File_System + \".win\";\n\n\tif (part_settings->adbbackup) {\n\t\tFull_FileName = TW_ADB_BACKUP;\n\t\tadb_file_name  = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\t}\n\telse\n\t\tFull_FileName = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\n\tpart_settings->total_restore_size = Backup_Size;\n\n\tif (part_settings->adbbackup) {\n\t\tif (!twadbbu::Write_TWIMG(adb_file_name, Backup_Size))\n\t\t\treturn false;\n\t}\n\n\tif (!Raw_Read_Write(part_settings))\n\t\treturn false;\n\n\tif (part_settings->adbbackup) {\n\t\tif (!twadbbu::Write_TWEOF())\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool TWPartition::Raw_Read_Write(PartitionSettings *part_settings) {\n\tunsigned long long RW_Block_Size, Remain = Backup_Size;\n\tint src_fd = -1, dest_fd = -1;\n\tssize_t bs;\n\tbool ret = false;\n\tvoid* buffer = NULL;\n\tunsigned long long backedup_size = 0;\n\tstring srcfn, destfn;\n\n\tif (part_settings->PM_Method == PM_BACKUP) {\n\t\tsrcfn = Actual_Block_Device;\n\t\tif (part_settings->adbbackup)\n\t\t\tdestfn = TW_ADB_BACKUP;\n\t\telse {\n\t\t\tdestfn = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\t\t}\n\t}\n\telse {\n\t\tdestfn = Actual_Block_Device;\n\t\tif (part_settings->adbbackup) {\n\t\t\tsrcfn = TW_ADB_RESTORE;\n\t\t} else {\n\t\t\tsrcfn = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\t\t\tRemain = TWFunc::Get_File_Size(srcfn);\n\t\t}\n\t}\n\n\tsrc_fd = open(srcfn.c_str(), O_RDONLY | O_LARGEFILE);\n\tif (src_fd < 0) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(srcfn.c_str())(strerror(errno)));\n\t\treturn false;\n\t}\n\n\tdest_fd = open(destfn.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_LARGEFILE, S_IRUSR | S_IWUSR);\n\tif (dest_fd < 0) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(destfn.c_str())(strerror(errno)));\n\t\tgoto exit;\n\t}\n\n\tLOGINFO(\"Reading '%s', writing '%s'\\n\", srcfn.c_str(), destfn.c_str());\n\n\tif (part_settings->adbbackup) {\n\t\tRW_Block_Size = MAX_ADB_READ;\n\t\tbs = MAX_ADB_READ;\n\t}\n\telse {\n\t\tRW_Block_Size = 1048576LLU; // 1MB\n\t\tbs = (ssize_t)(RW_Block_Size);\n\t}\n\n\tbuffer = malloc((size_t)bs);\n\tif (!buffer) {\n\t\tLOGINFO(\"Raw_Read_Write failed to malloc\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (part_settings->progress)\n\t\tpart_settings->progress->SetPartitionSize(part_settings->total_restore_size);\n\n\twhile (Remain > 0) {\n\t\tif (Remain < RW_Block_Size)\n\t\t\tbs = (ssize_t)(Remain);\n\t\tif (read(src_fd, buffer, bs) != bs) {\n\t\t\tLOGINFO(\"Error reading source fd (%s)\\n\", strerror(errno));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (write(dest_fd, buffer, bs) != bs) {\n\t\t\tLOGINFO(\"Error writing destination fd (%s)\\n\", strerror(errno));\n\t\t\tgoto exit;\n\t\t}\n\t\tbackedup_size += (unsigned long long)(bs);\n\t\tRemain -= (unsigned long long)(bs);\n\t\tif (part_settings->progress)\n\t\t\tpart_settings->progress->UpdateSize(backedup_size);\n\t\tif (PartitionManager.Check_Backup_Cancel() != 0)\n\t\t\tgoto exit;\n\t}\n\tif (part_settings->progress)\n\t\tpart_settings->progress->UpdateDisplayDetails(true);\n\tfsync(dest_fd);\n\n\tif (!part_settings->adbbackup && part_settings->PM_Method == PM_BACKUP) {\n\t\ttw_set_default_metadata(destfn.c_str());\n\t\tLOGINFO(\"Restored default metadata for %s\\n\", destfn.c_str());\n\t}\n\n\tret = true;\nexit:\n\tif (src_fd >= 0)\n\t\tclose(src_fd);\n\tif (dest_fd >= 0)\n\t\tclose(dest_fd);\n\tif (buffer)\n\t\tfree(buffer);\n\treturn ret;\n}\n\nbool TWPartition::Backup_Dump_Image(PartitionSettings *part_settings) {\n\tstring Full_FileName, Command;\n\n\tTWFunc::GUI_Operation_Text(TW_BACKUP_TEXT, Display_Name, gui_parse_text(\"{@backing}\"));\n\tgui_msg(Msg(\"backing_up=Backing up {1}...\")(Backup_Display_Name));\n\n\tif (part_settings->progress)\n\t\tpart_settings->progress->SetPartitionSize(Backup_Size);\n\n\tBackup_FileName = Backup_Name + \".\" + Current_File_System + \".win\";\n\tFull_FileName = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\n\tCommand = \"dump_image \" + MTD_Name + \" '\" + Full_FileName + \"'\";\n\n\tLOGINFO(\"Backup command: '%s'\\n\", Command.c_str());\n\tTWFunc::Exec_Cmd(Command);\n\ttw_set_default_metadata(Full_FileName.c_str());\n\tif (TWFunc::Get_File_Size(Full_FileName) == 0) {\n\t\t// Actual size may not match backup size due to bad blocks on MTD devices so just check for 0 bytes\n\t\tgui_msg(Msg(msg::kError, \"backup_size=Backup file size for '{1}' is 0 bytes.\")(Full_FileName));\n\t\treturn false;\n\t}\n\tif (part_settings->progress)\n\t\tpart_settings->progress->UpdateSize(Backup_Size);\n\n\treturn true;\n}\n\nunsigned long long TWPartition::Get_Restore_Size(PartitionSettings *part_settings) {\n\tif (!part_settings->adbbackup) {\n\t\tInfoManager restore_info(part_settings->Backup_Folder + \"/\" + Backup_Name + \".info\");\n\t\tif (restore_info.LoadValues() == 0) {\n\t\t\tif (restore_info.GetValue(\"backup_size\", Restore_Size) == 0) {\n\t\t\t\tLOGINFO(\"Read info file, restore size is %llu\\n\", Restore_Size);\n\t\t\t\treturn Restore_Size;\n\t\t\t}\n\t\t}\n\t}\n\n\tstring Full_FileName = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\tstring Restore_File_System = Get_Restore_File_System(part_settings);\n\n\tif (Is_Image(Restore_File_System)) {\n\t\tRestore_Size = TWFunc::Get_File_Size(Full_FileName);\n\t\treturn Restore_Size;\n\t}\n\n\ttwrpTar tar;\n\ttar.setdir(Backup_Path);\n\ttar.setfn(Full_FileName);\n\ttar.backup_name = Full_FileName;\n#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS\n\tstring Password;\n\tDataManager::GetValue(\"tw_restore_password\", Password);\n\tif (!Password.empty())\n\t\ttar.setpassword(Password);\n#endif\n\ttar.partition_name = Backup_Name;\n\ttar.backup_folder = part_settings->Backup_Folder;\n\ttar.part_settings = part_settings;\n\tRestore_Size = tar.get_size();\n\treturn Restore_Size;\n}\n\nbool TWPartition::Restore_Tar(PartitionSettings *part_settings) {\n\tstring Full_FileName;\n\tbool ret = false;\n\tstring Restore_File_System = Get_Restore_File_System(part_settings);\n\n\tif (Has_Android_Secure) {\n\t\tif (!Wipe_AndSec())\n\t\t\treturn false;\n\t} else {\n\t\tgui_msg(Msg(\"wiping=Wiping {1}\")(Backup_Display_Name));\n\t\tif (Has_Data_Media && Mount_Point == \"/data\" && Restore_File_System != Current_File_System) {\n\t\t\tgui_msg(Msg(msg::kWarning, \"datamedia_fs_restore=WARNING: This /data backup was made with {1} file system! The backup may not boot unless you change back to {1}.\")(Restore_File_System));\n\t\t\tif (!Wipe_Data_Without_Wiping_Media())\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tif (!Wipe(Restore_File_System))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tTWFunc::GUI_Operation_Text(TW_RESTORE_TEXT, Backup_Display_Name, gui_parse_text(\"{@restoring_hdr}\"));\n\tgui_msg(Msg(\"restoring=Restoring {1}...\")(Backup_Display_Name));\n\n\t// Remount as read/write as needed so we can restore the backup\n\tif (!ReMount_RW(true))\n\t\treturn false;\n\n\tFull_FileName = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\ttwrpTar tar;\n\ttar.part_settings = part_settings;\n\ttar.setdir(Backup_Path);\n\ttar.setfn(Full_FileName);\n\ttar.backup_name = Backup_Name;\n#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS\n\tstring Password;\n\tDataManager::GetValue(\"tw_restore_password\", Password);\n\tif (!Password.empty())\n\t\ttar.setpassword(Password);\n#endif\n\tpart_settings->progress->SetPartitionSize(Get_Restore_Size(part_settings));\n\tif (tar.extractTarFork() != 0)\n\t\tret = false;\n\telse\n\t\tret = true;\n#ifdef HAVE_CAPABILITIES\n\t// Restore capabilities to the run-as binary\n\tif (Mount_Point == \"/system\" && Mount(true) && TWFunc::Path_Exists(\"/system/bin/run-as\")) {\n\t\tstruct vfs_cap_data cap_data;\n\t\tuint64_t capabilities = (1 << CAP_SETUID) | (1 << CAP_SETGID);\n\n\t\tmemset(&cap_data, 0, sizeof(cap_data));\n\t\tcap_data.magic_etc = VFS_CAP_REVISION | VFS_CAP_FLAGS_EFFECTIVE;\n\t\tcap_data.data[0].permitted = (uint32_t) (capabilities & 0xffffffff);\n\t\tcap_data.data[0].inheritable = 0;\n\t\tcap_data.data[1].permitted = (uint32_t) (capabilities >> 32);\n\t\tcap_data.data[1].inheritable = 0;\n\t\tif (setxattr(\"/system/bin/run-as\", XATTR_NAME_CAPS, &cap_data, sizeof(cap_data), 0) < 0) {\n\t\t\tLOGINFO(\"Failed to reset capabilities of /system/bin/run-as binary.\\n\");\n\t\t} else {\n\t\t\tLOGINFO(\"Reset capabilities of /system/bin/run-as binary successful.\\n\");\n\t\t}\n\t}\n#endif\n\tif (Mount_Read_Only || Mount_Flags & MS_RDONLY)\n\t\t// Remount as read only when restoration is complete\n\t\tReMount(true);\n\n\treturn ret;\n}\n\nbool TWPartition::Restore_Image(PartitionSettings *part_settings) {\n\tstring Full_FileName;\n\tstring Restore_File_System = Get_Restore_File_System(part_settings);\n\n\tTWFunc::GUI_Operation_Text(TW_RESTORE_TEXT, Backup_Display_Name, gui_parse_text(\"{@restoring_hdr}\"));\n\tgui_msg(Msg(\"restoring=Restoring {1}...\")(Backup_Display_Name));\n\n\tif (part_settings->adbbackup)\n\t\tFull_FileName = TW_ADB_RESTORE;\n\telse\n\t\tFull_FileName = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\n\tif (Restore_File_System == \"emmc\") {\n\t\tif (!part_settings->adbbackup)\n\t\t\tpart_settings->total_restore_size = (uint64_t)(TWFunc::Get_File_Size(Full_FileName));\n\t\tif (!Raw_Read_Write(part_settings))\n\t\t\treturn false;\n\t} else if (Restore_File_System == \"mtd\" || Restore_File_System == \"bml\") {\n\t\tif (!Flash_Image_FI(Full_FileName, part_settings->progress))\n\t\t\treturn false;\n\t}\n\n\tif (part_settings->adbbackup) {\n\t\tif (!twadbbu::Write_TWEOF())\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool TWPartition::Update_Size(bool Display_Error) {\n\tbool ret = false, Was_Already_Mounted = false;\n\n\tFind_Actual_Block_Device();\n\n\tif (!Can_Be_Mounted && !Is_Encrypted) {\n\t\tif (TWFunc::Path_Exists(Actual_Block_Device) && Find_Partition_Size()) {\n\t\t\tUsed = Size;\n\t\t\tBackup_Size = Size;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tWas_Already_Mounted = Is_Mounted();\n\tif (Removable || Is_Encrypted) {\n\t\tif (!Mount(false))\n\t\t\treturn true;\n\t} else if (!Mount(Display_Error))\n\t\treturn false;\n\n\tret = Get_Size_Via_statfs(Display_Error);\n\tif (!ret || Size == 0) {\n\t\tif (!Get_Size_Via_df(Display_Error)) {\n\t\t\tif (!Was_Already_Mounted)\n\t\t\t\tUnMount(false);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (Has_Data_Media) {\n\t\tif (Mount(Display_Error)) {\n\t\t\tUsed = backup_exclusions.Get_Folder_Size(Mount_Point);\n\t\t\tBackup_Size = Used;\n\t\t\tint bak = (int)(Used / 1048576LLU);\n\t\t\tint fre = (int)(Free / 1048576LLU);\n\t\t\tLOGINFO(\"Data backup size is %iMB, free: %iMB.\\n\", bak, fre);\n\t\t} else {\n\t\t\tif (!Was_Already_Mounted)\n\t\t\t\tUnMount(false);\n\t\t\treturn false;\n\t\t}\n\t} else if (Has_Android_Secure) {\n\t\tif (Mount(Display_Error))\n\t\t\tBackup_Size = backup_exclusions.Get_Folder_Size(Backup_Path);\n\t\telse {\n\t\t\tif (!Was_Already_Mounted)\n\t\t\t\tUnMount(false);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!Was_Already_Mounted)\n\t\tUnMount(false);\n\treturn true;\n}\n\nbool TWPartition::Find_Wildcard_Block_Devices(const string& Device) {\n\tint mount_point_index = 0; // we will need to create separate mount points for each partition found and we use this index to name each one\n\tstring Path = TWFunc::Get_Path(Device);\n\tstring Dev = TWFunc::Get_Filename(Device);\n\tsize_t wildcard_index = Dev.find(\"*\");\n\tif (wildcard_index != string::npos)\n\t\tDev = Dev.substr(0, wildcard_index);\n\twildcard_index = Dev.size();\n\tDIR* d = opendir(Path.c_str());\n\tif (d == NULL) {\n\t\tLOGINFO(\"Error opening '%s': %s\\n\", Path.c_str(), strerror(errno));\n\t\treturn false;\n\t}\n\tstruct dirent* de;\n\twhile ((de = readdir(d)) != NULL) {\n\t\tif (de->d_type != DT_BLK || strlen(de->d_name) <= wildcard_index || strncmp(de->d_name, Dev.c_str(), wildcard_index) != 0)\n\t\t\tcontinue;\n\n\t\tstring item = Path + \"/\";\n\t\titem.append(de->d_name);\n\t\tif (PartitionManager.Find_Partition_By_Block_Device(item))\n\t\t\tcontinue;\n\t\tTWPartition *part = new TWPartition;\n\t\tchar buffer[MAX_FSTAB_LINE_LENGTH];\n\t\tsprintf(buffer, \"%s %s-%i auto defaults defaults\", item.c_str(), Mount_Point.c_str(), ++mount_point_index);\n\t\tpart->Process_Fstab_Line(buffer, false, NULL);\n\t\tchar display[MAX_FSTAB_LINE_LENGTH];\n\t\tsprintf(display, \"%s %i\", Storage_Name.c_str(), mount_point_index);\n\t\tpart->Storage_Name = display;\n\t\tpart->Display_Name = display;\n\t\tpart->Primary_Block_Device = item;\n\t\tpart->Wildcard_Block_Device = false;\n\t\tpart->Is_SubPartition = true;\n\t\tpart->SubPartition_Of = Mount_Point;\n\t\tpart->Is_Storage = Is_Storage;\n\t\tpart->Can_Be_Mounted = true;\n\t\tpart->Removable = true;\n\t\tpart->Can_Be_Wiped = Can_Be_Wiped;\n\t\tpart->Wipe_Available_in_GUI = Wipe_Available_in_GUI;\n\t\tpart->Find_Actual_Block_Device();\n\t\tpart->Update_Size(false);\n\t\tHas_SubPartition = true;\n\t\tPartitionManager.Output_Partition(part);\n\t\tPartitionManager.Add_Partition(part);\n\t}\n\tclosedir(d);\n\treturn (mount_point_index > 0);\n}\n\nvoid TWPartition::Find_Actual_Block_Device(void) {\n\tif (!Sysfs_Entry.empty() && Primary_Block_Device.empty() && Decrypted_Block_Device.empty()) {\n\t\t/* Sysfs_Entry.empty() indicates if this is a sysfs entry that begins with /device/\n\t\t * If we have a syfs entry then we are looking for this device from a uevent add.\n\t\t * The uevent add will set the primary block device based on the data we receive from\n\t\t * after checking for adopted storage. If the device ends up being adopted, then the\n\t\t * decrypted block device will be set instead of the primary block device. */\n\t\tIs_Present = false;\n\t\treturn;\n\t}\n\tif (Wildcard_Block_Device && !Is_Adopted_Storage) {\n\t\tIs_Present = false;\n\t\tActual_Block_Device = \"\";\n\t\tCan_Be_Mounted = false;\n\t\tif (!Find_Wildcard_Block_Devices(Primary_Block_Device)) {\n\t\t\tstring Dev = Primary_Block_Device.substr(0, Primary_Block_Device.find(\"*\"));\n\t\t\tif (TWFunc::Path_Exists(Dev)) {\n\t\t\t\tIs_Present = true;\n\t\t\t\tCan_Be_Mounted = true;\n\t\t\t\tActual_Block_Device = Dev;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t} else if (Is_Decrypted && !Decrypted_Block_Device.empty()) {\n\t\tActual_Block_Device = Decrypted_Block_Device;\n\t\tif (TWFunc::Path_Exists(Decrypted_Block_Device)) {\n\t\t\tIs_Present = true;\n\t\t\treturn;\n\t\t}\n\t} else if (SlotSelect && TWFunc::Path_Exists(Primary_Block_Device + PartitionManager.Get_Active_Slot_Suffix())) {\n\t\tActual_Block_Device = Primary_Block_Device + PartitionManager.Get_Active_Slot_Suffix();\n\t\tunlink(Primary_Block_Device.c_str());\n\t\tsymlink(Actual_Block_Device.c_str(), Primary_Block_Device.c_str()); // we create a non-slot symlink pointing to the currently selected slot which may assist zips with installing\n\t\tIs_Present = true;\n\t\treturn;\n\t} else if (TWFunc::Path_Exists(Primary_Block_Device)) {\n\t\tIs_Present = true;\n\t\tActual_Block_Device = Primary_Block_Device;\n\t\treturn;\n\t}\n\tif (!Alternate_Block_Device.empty() && TWFunc::Path_Exists(Alternate_Block_Device)) {\n\t\tActual_Block_Device = Alternate_Block_Device;\n\t\tIs_Present = true;\n\t} else {\n\t\tIs_Present = false;\n\t}\n}\n\nvoid TWPartition::Recreate_Media_Folder(void) {\n\tstring Command;\n\tstring Media_Path = Mount_Point + \"/media\";\n\n\tif (Is_FBE) {\n\t\tLOGINFO(\"Not recreating media folder on FBE\\n\");\n\t\treturn;\n\t}\n\tif (!Mount(true)) {\n\t\tgui_msg(Msg(msg::kError, \"recreate_folder_err=Unable to recreate {1} folder.\")(Media_Path));\n\t} else if (!TWFunc::Path_Exists(Media_Path)) {\n\t\tPartitionManager.Mount_By_Path(Symlink_Mount_Point, true);\n\t\tLOGINFO(\"Recreating %s folder.\\n\", Media_Path.c_str());\n\t\tmkdir(Media_Path.c_str(), 0770);\n\t\tstring Internal_path = DataManager::GetStrValue(\"tw_internal_path\");\n\t\tif (!Internal_path.empty()) {\n\t\t\tLOGINFO(\"Recreating %s folder.\\n\", Internal_path.c_str());\n\t\t\tmkdir(Internal_path.c_str(), 0770);\n\t\t}\n#ifdef TW_INTERNAL_STORAGE_PATH\n\t\tmkdir(EXPAND(TW_INTERNAL_STORAGE_PATH), 0770);\n#endif\n\n\t\t// Afterwards, we will try to set the\n\t\t// default metadata that we were hopefully able to get during\n\t\t// early boot.\n\t\ttw_set_default_metadata(Media_Path.c_str());\n\t\tif (!Internal_path.empty())\n\t\t\ttw_set_default_metadata(Internal_path.c_str());\n\n\t\t// Toggle mount to ensure that \"internal sdcard\" gets mounted\n\t\tPartitionManager.UnMount_By_Path(Symlink_Mount_Point, true);\n\t\tPartitionManager.Mount_By_Path(Symlink_Mount_Point, true);\n\t}\n}\n\nvoid TWPartition::Recreate_AndSec_Folder(void) {\n\tif (!Has_Android_Secure)\n\t\treturn;\n\tLOGINFO(\"Creating %s: %s\\n\", Backup_Display_Name.c_str(), Symlink_Path.c_str());\n\tif (!Mount(true)) {\n\t\tgui_msg(Msg(msg::kError, \"recreate_folder_err=Unable to recreate {1} folder.\")(Backup_Name));\n\t} else if (!TWFunc::Path_Exists(Symlink_Path)) {\n\t\tLOGINFO(\"Recreating %s folder.\\n\", Backup_Name.c_str());\n\t\tPartitionManager.Mount_By_Path(Symlink_Mount_Point, true);\n\t\tmkdir(Symlink_Path.c_str(), S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tPartitionManager.UnMount_By_Path(Symlink_Mount_Point, true);\n\t}\n}\n\nuint64_t TWPartition::Get_Max_FileSize() {\n\tuint64_t maxFileSize = 0;\n\tconst uint64_t constGB = (uint64_t) 1024 * 1024 * 1024;\n\tconst uint64_t constTB = (uint64_t) constGB * 1024;\n\tconst uint64_t constPB = (uint64_t) constTB * 1024;\n\tif (Current_File_System == \"ext4\")\n\t\tmaxFileSize = 16 * constTB; //16 TB\n\telse if (Current_File_System == \"vfat\")\n\t\tmaxFileSize = 4 * constGB; //4 GB\n\telse if (Current_File_System == \"ntfs\")\n\t\tmaxFileSize = 256 * constTB; //256 TB\n\telse if (Current_File_System == \"exfat\")\n\t\tmaxFileSize = 16 * constPB; //16 PB\n\telse if (Current_File_System == \"ext3\")\n\t\tmaxFileSize = 2 * constTB; //2 TB\n\telse if (Current_File_System == \"f2fs\")\n\t\tmaxFileSize = 3.94 * constTB; //3.94 TB\n\telse\n\t\tmaxFileSize = 100000000L;\n\treturn maxFileSize - 1;\n}\n\nbool TWPartition::Flash_Image(PartitionSettings *part_settings) {\n\tstring Restore_File_System, full_filename;\n\n\tfull_filename = part_settings->Backup_Folder + \"/\" + Backup_FileName;\n\n\tLOGINFO(\"Image filename is: %s\\n\", Backup_FileName.c_str());\n\n\tif (Backup_Method == BM_FILES) {\n\t\tLOGERR(\"Cannot flash images to file systems\\n\");\n\t\treturn false;\n\t} else if (!Can_Flash_Img) {\n\t\tLOGERR(\"Cannot flash images to partitions %s\\n\", Display_Name.c_str());\n\t\treturn false;\n\t} else {\n\t\tif (!Find_Partition_Size()) {\n\t\t\tLOGERR(\"Unable to find partition size for '%s'\\n\", Mount_Point.c_str());\n\t\t\treturn false;\n\t\t}\n\t\tunsigned long long image_size = TWFunc::Get_File_Size(full_filename);\n\t\tif (image_size > Size) {\n\t\t\tLOGINFO(\"Size (%llu bytes) of image '%s' is larger than target device '%s' (%llu bytes)\\n\",\n\t\t\t\timage_size, Backup_FileName.c_str(), Actual_Block_Device.c_str(), Size);\n\t\t\tgui_err(\"img_size_err=Size of image is larger than target device\");\n\t\t\treturn false;\n\t\t}\n\t\tif (Backup_Method == BM_DD) {\n\t\t\tif (!part_settings->adbbackup) {\n\t\t\t\tif (Is_Sparse_Image(full_filename)) {\n\t\t\t\t\treturn Flash_Sparse_Image(full_filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Raw_Read_Write(part_settings);\n\t\t} else if (Backup_Method == BM_FLASH_UTILS) {\n\t\t\treturn Flash_Image_FI(full_filename, NULL);\n\t\t}\n\t}\n\n\tLOGERR(\"Unknown flash method for '%s'\\n\", Mount_Point.c_str());\n\treturn false;\n}\n\nbool TWPartition::Is_Sparse_Image(const string& Filename) {\n\tuint32_t magic = 0;\n\tint fd = open(Filename.c_str(), O_RDONLY);\n\tif (fd < 0) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Filename)(strerror(errno)));\n\t\treturn false;\n\t}\n\n\tif (read(fd, &magic, sizeof(magic)) != sizeof(magic)) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Filename)(strerror(errno)));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\tif (magic == SPARSE_HEADER_MAGIC)\n\t\treturn true;\n\treturn false;\n}\n\nbool TWPartition::Flash_Sparse_Image(const string& Filename) {\n\tstring Command;\n\n\tgui_msg(Msg(\"flashing=Flashing {1}...\")(Display_Name));\n\n\tCommand = \"simg2img '\" + Filename + \"' '\" + Actual_Block_Device + \"'\";\n\tLOGINFO(\"Flash command: '%s'\\n\", Command.c_str());\n\tTWFunc::Exec_Cmd(Command);\n\treturn true;\n}\n\nbool TWPartition::Flash_Image_FI(const string& Filename, ProgressTracking *progress) {\n\tstring Command;\n\tunsigned long long file_size;\n\n\tgui_msg(Msg(\"flashing=Flashing {1}...\")(Display_Name));\n\tif (progress) {\n\t\tfile_size = (unsigned long long)(TWFunc::Get_File_Size(Filename));\n\t\tprogress->SetPartitionSize(file_size);\n\t}\n\t// Sometimes flash image doesn't like to flash due to the first 2KB matching, so we erase first to ensure that it flashes\n\tCommand = \"erase_image \" + MTD_Name;\n\tLOGINFO(\"Erase command: '%s'\\n\", Command.c_str());\n\tTWFunc::Exec_Cmd(Command);\n\tCommand = \"flash_image \" + MTD_Name + \" '\" + Filename + \"'\";\n\tLOGINFO(\"Flash command: '%s'\\n\", Command.c_str());\n\tTWFunc::Exec_Cmd(Command);\n\tif (progress)\n\t\tprogress->UpdateSize(file_size);\n\treturn true;\n}\n\nvoid TWPartition::Change_Mount_Read_Only(bool new_value) {\n\tMount_Read_Only = new_value;\n}\n\nbool TWPartition::Is_Read_Only() {\n\treturn Mount_Read_Only;\n}\n\nint TWPartition::Check_Lifetime_Writes() {\n\tbool original_read_only = Mount_Read_Only;\n\tint ret = 1;\n\n\tMount_Read_Only = true;\n\tif (Mount(false)) {\n\t\tFind_Actual_Block_Device();\n\t\tstring block = basename(Actual_Block_Device.c_str());\n\t\tstring file = \"/sys/fs/\" + Current_File_System + \"/\" + block + \"/lifetime_write_kbytes\";\n\t\tstring result;\n\t\tif (TWFunc::Path_Exists(file)) {\n\t\t\tif (TWFunc::read_file(file, result) != 0) {\n\t\t\t\tLOGINFO(\"Check_Lifetime_Writes of '%s' failed to read_file\\n\", file.c_str());\n\t\t\t} else {\n\t\t\t\tLOGINFO(\"Check_Lifetime_Writes result: '%s'\\n\", result.c_str());\n\t\t\t\tif (result == \"0\") {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tLOGINFO(\"Check_Lifetime_Writes file does not exist '%s'\\n\", file.c_str());\n\t\t}\n\t\tUnMount(true);\n\t} else {\n\t\tLOGINFO(\"Check_Lifetime_Writes failed to mount '%s'\\n\", Mount_Point.c_str());\n\t}\n\tMount_Read_Only = original_read_only;\n\treturn ret;\n}\n\nint TWPartition::Decrypt_Adopted() {\n#ifdef TW_INCLUDE_CRYPTO\n\tint ret = 1;\n\tIs_Adopted_Storage = false;\n\tstring Adopted_Key_File = \"\";\n\n\tif (!Removable)\n\t\treturn ret;\n\n\tint fd = open(Alternate_Block_Device.c_str(), O_RDONLY);\n\tif (fd < 0) {\n\t\tLOGINFO(\"failed to open '%s'\\n\", Alternate_Block_Device.c_str());\n\t\treturn ret;\n\t}\n\tchar type_guid[80];\n\tchar part_guid[80];\n\n\tif (gpt_disk_get_partition_info(fd, 2, type_guid, part_guid) == 0) {\n\t\tLOGINFO(\"type: '%s'\\n\", type_guid);\n\t\tLOGINFO(\"part: '%s'\\n\", part_guid);\n\t\tAdopted_GUID = part_guid;\n\t\tLOGINFO(\"Adopted_GUID '%s'\\n\", Adopted_GUID.c_str());\n\t\tif (strcmp(type_guid, TWGptAndroidExpand) == 0) {\n\t\t\tLOGINFO(\"android_expand found\\n\");\n\t\t\tAdopted_Key_File = \"/data/misc/vold/expand_\";\n\t\t\tAdopted_Key_File += part_guid;\n\t\t\tAdopted_Key_File += \".key\";\n\t\t\tif (TWFunc::Path_Exists(Adopted_Key_File)) {\n\t\t\t\tIs_Adopted_Storage = true;\n\t\t\t\t/* Until we find a use case for this, I think it is safe\n\t\t\t\t * to disable USB Mass Storage whenever adopted storage\n\t\t\t\t * is present.\n\t\t\t\t */\n\t\t\t\tLOGINFO(\"Detected adopted storage, disabling USB mass storage mode\\n\");\n\t\t\t\tDataManager::SetValue(\"tw_has_usb_storage\", 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (Is_Adopted_Storage) {\n\t\tstring Adopted_Block_Device = Alternate_Block_Device + \"p2\";\n\t\tif (!TWFunc::Path_Exists(Adopted_Block_Device)) {\n\t\t\tAdopted_Block_Device = Alternate_Block_Device + \"2\";\n\t\t\tif (!TWFunc::Path_Exists(Adopted_Block_Device)) {\n\t\t\t\tLOGINFO(\"Adopted block device does not exist\\n\");\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tLOGINFO(\"key file is '%s', block device '%s'\\n\", Adopted_Key_File.c_str(), Adopted_Block_Device.c_str());\n\t\tchar crypto_blkdev[MAXPATHLEN];\n\t\tstd::string thekey;\n\t\tint fdkey = open(Adopted_Key_File.c_str(), O_RDONLY);\n\t\tif (fdkey < 0) {\n\t\t\tLOGINFO(\"failed to open key file\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t\tchar buf[512];\n\t\tssize_t n;\n\t\twhile ((n = read(fdkey, &buf[0], sizeof(buf))) > 0) {\n\t\t\tthekey.append(buf, n);\n\t\t}\n\t\tclose(fdkey);\n\t\tunsigned char* key = (unsigned char*) thekey.data();\n\t\tcryptfs_revert_ext_volume(part_guid);\n\n\t\tret = cryptfs_setup_ext_volume(part_guid, Adopted_Block_Device.c_str(), key, thekey.size(), crypto_blkdev);\n\t\tif (ret == 0) {\n\t\t\tLOGINFO(\"adopted storage new block device: '%s'\\n\", crypto_blkdev);\n\t\t\tDecrypted_Block_Device = crypto_blkdev;\n\t\t\tIs_Decrypted = true;\n\t\t\tIs_Encrypted = true;\n\t\t\tFind_Actual_Block_Device();\n\t\t\tif (!Mount_Storage_Retry(false)) {\n\t\t\t\tLOGERR(\"Failed to mount decrypted adopted storage device\\n\");\n\t\t\t\tIs_Decrypted = false;\n\t\t\t\tIs_Encrypted = false;\n\t\t\t\tcryptfs_revert_ext_volume(part_guid);\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tUnMount(false);\n\t\t\t\tHas_Android_Secure = false;\n\t\t\t\tSymlink_Path = \"\";\n\t\t\t\tSymlink_Mount_Point = \"\";\n\t\t\t\tBackup_Name = Mount_Point.substr(1);\n\t\t\t\tBackup_Path = Mount_Point;\n\t\t\t\tTWPartition* sdext = PartitionManager.Find_Partition_By_Path(\"/sd-ext\");\n\t\t\t\tif (sdext && sdext->Actual_Block_Device == Adopted_Block_Device) {\n\t\t\t\t\tLOGINFO(\"Removing /sd-ext from partition list due to adopted storage\\n\");\n\t\t\t\t\tPartitionManager.Remove_Partition_By_Path(\"/sd-ext\");\n\t\t\t\t}\n\t\t\t\tSetup_Data_Media();\n\t\t\t\tRecreate_Media_Folder();\n\t\t\t\tWipe_Available_in_GUI = true;\n\t\t\t\tWipe_During_Factory_Reset = true;\n\t\t\t\tCan_Be_Backed_Up = true;\n\t\t\t\tCan_Encrypt_Backup = true;\n\t\t\t\tUse_Userdata_Encryption = true;\n\t\t\t\tIs_Storage = true;\n\t\t\t\tStorage_Name = \"Adopted Storage\";\n\t\t\t\tIs_SubPartition = true;\n\t\t\t\tSubPartition_Of = \"/data\";\n\t\t\t\tPartitionManager.Add_MTP_Storage(MTP_Storage_ID);\n\t\t\t\tDataManager::SetValue(\"tw_has_adopted_storage\", 1);\n\t\t\t}\n\t\t} else {\n\t\t\tLOGERR(\"Failed to setup adopted storage decryption\\n\");\n\t\t}\n\t}\nexit:\n\tclose(fd);\n\treturn ret;\n#else\n\tLOGINFO(\"Decrypt_Adopted: no crypto support\\n\");\n\treturn 1;\n#endif\n}\n\nvoid TWPartition::Revert_Adopted() {\n#ifdef TW_INCLUDE_CRYPTO\n\tif (!Adopted_GUID.empty()) {\n\t\tPartitionManager.Remove_MTP_Storage(Mount_Point);\n\t\tUnMount(false);\n\t\tcryptfs_revert_ext_volume(Adopted_GUID.c_str());\n\t\tIs_Adopted_Storage = false;\n\t\tIs_Encrypted = false;\n\t\tIs_Decrypted = false;\n\t\tDecrypted_Block_Device = \"\";\n\t\tFind_Actual_Block_Device();\n\t\tWipe_During_Factory_Reset = false;\n\t\tCan_Be_Backed_Up = false;\n\t\tCan_Encrypt_Backup = false;\n\t\tUse_Userdata_Encryption = false;\n\t\tIs_SubPartition = false;\n\t\tSubPartition_Of = \"\";\n\t\tHas_Data_Media = false;\n\t\tStorage_Path = Mount_Point;\n\t\tif (!Symlink_Mount_Point.empty()) {\n\t\t\tTWPartition* Dat = PartitionManager.Find_Partition_By_Path(\"/data\");\n\t\t\tif (Dat) {\n\t\t\t\tDat->UnMount(false);\n\t\t\t\tDat->Symlink_Mount_Point = Symlink_Mount_Point;\n\t\t\t}\n\t\t\tSymlink_Mount_Point = \"\";\n\t\t}\n\t}\n#else\n\tLOGINFO(\"Revert_Adopted: no crypto support\\n\");\n#endif\n}\n\nvoid TWPartition::Set_Backup_FileName(string fname) {\n\tBackup_FileName = fname;\n}\n\nstring TWPartition::Get_Backup_Name() {\n\treturn Backup_Name;\n}\n"
        },
        {
          "name": "partitionmanager.cpp",
          "type": "blob",
          "size": 95.0361328125,
          "content": "/*\n\tCopyright 2014 to 2017 TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <unistd.h>\n#include <map>\n#include <vector>\n#include <dirent.h>\n#include <time.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <zlib.h>\n#include <iostream>\n#include <iomanip>\n#include <sys/wait.h>\n#include <linux/fs.h>\n#include <sys/mount.h>\n\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <linux/types.h>\n#include <linux/netlink.h>\n\n#include \"variables.h\"\n#include \"twcommon.h\"\n#include \"partitions.hpp\"\n#include \"data.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"fixContexts.hpp\"\n#include \"exclude.hpp\"\n#include \"set_metadata.h\"\n#include \"tw_atomic.hpp\"\n#include \"gui/gui.hpp\"\n#include \"progresstracking.hpp\"\n#include \"twrpDigestDriver.hpp\"\n#include \"adbbu/libtwadbbu.hpp\"\n\n#ifdef TW_HAS_MTP\n#include \"mtp/mtp_MtpServer.hpp\"\n#include \"mtp/twrpMtp.hpp\"\n#include \"mtp/MtpMessage.hpp\"\n#endif\n\nextern \"C\" {\n\t#include \"cutils/properties.h\"\n\t#include \"gui/gui.h\"\n}\n\n#ifdef TW_INCLUDE_CRYPTO\n\t#include \"crypto/lollipop/cryptfs.h\"\n\t#include \"gui/rapidxml.hpp\"\n\t#include \"gui/pages.hpp\"\n\t#ifdef TW_INCLUDE_FBE\n\t\t#include \"crypto/ext4crypt/Decrypt.h\"\n\t#endif\n\t#ifdef TW_CRYPTO_USE_SYSTEM_VOLD\n\t\t#include \"crypto/vold_decrypt/vold_decrypt.h\"\n\t#endif\n#endif\n\n#ifdef AB_OTA_UPDATER\n#include <hardware/hardware.h>\n#include <hardware/boot_control.h>\n#endif\n\nextern bool datamedia;\n\nTWPartitionManager::TWPartitionManager(void) {\n\tmtp_was_enabled = false;\n\tmtp_write_fd = -1;\n\tuevent_pfd.fd = -1;\n\tstop_backup.set_value(0);\n#ifdef AB_OTA_UPDATER\n\tchar slot_suffix[PROPERTY_VALUE_MAX];\n\tproperty_get(\"ro.boot.slot_suffix\", slot_suffix, \"error\");\n\tif (strcmp(slot_suffix, \"error\") == 0)\n\t\tproperty_get(\"ro.boot.slot\", slot_suffix, \"error\");\n\tActive_Slot_Display = \"\";\n\tif (strcmp(slot_suffix, \"_a\") == 0 || strcmp(slot_suffix, \"a\") == 0)\n\t\tSet_Active_Slot(\"A\");\n\telse\n\t\tSet_Active_Slot(\"B\");\n#endif\n}\n\nint TWPartitionManager::Process_Fstab(string Fstab_Filename, bool Display_Error) {\n\tFILE *fstabFile;\n\tchar fstab_line[MAX_FSTAB_LINE_LENGTH];\n\tTWPartition* settings_partition = NULL;\n\tTWPartition* andsec_partition = NULL;\n\tunsigned int storageid = 1 << 16;\t// upper 16 bits are for physical storage device, we pretend to have only one\n\tstd::map<string, Flags_Map> twrp_flags;\n\n\tfstabFile = fopen(\"/etc/twrp.flags\", \"rt\");\n\tif (fstabFile != NULL) {\n\t\tLOGINFO(\"reading /etc/twrp.flags\\n\");\n\t\twhile (fgets(fstab_line, sizeof(fstab_line), fstabFile) != NULL) {\n\t\t\tif (fstab_line[0] != '/')\n\t\t\t\tcontinue;\n\n\t\t\tsize_t line_size = strlen(fstab_line);\n\t\t\tif (fstab_line[line_size - 1] != '\\n')\n\t\t\t\tfstab_line[line_size] = '\\n';\n\t\t\tFlags_Map line_flags;\n\t\t\tline_flags.Primary_Block_Device = \"\";\n\t\t\tline_flags.Alternate_Block_Device = \"\";\n\t\t\tline_flags.fstab_line = (char*)malloc(MAX_FSTAB_LINE_LENGTH);\n\t\t\tif (!line_flags.fstab_line) {\n\t\t\t\tLOGERR(\"malloc error on line_flags.fstab_line\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tmemcpy(line_flags.fstab_line, fstab_line, MAX_FSTAB_LINE_LENGTH);\n\t\t\tbool found_separator = false;\n\t\t\tchar *fs_loc = NULL;\n\t\t\tchar *block_loc = NULL;\n\t\t\tchar *flags_loc = NULL;\n\t\t\tsize_t index, item_index = 0;\n\t\t\tfor (index = 0; index < line_size; index++) {\n\t\t\t\tif (fstab_line[index] <= 32) {\n\t\t\t\t\tfstab_line[index] = '\\0';\n\t\t\t\t\tfound_separator = true;\n\t\t\t\t} else if (found_separator) {\n\t\t\t\t\tif (item_index == 0) {\n\t\t\t\t\t\tfs_loc = fstab_line + index;\n\t\t\t\t\t} else if (item_index == 1) {\n\t\t\t\t\t\tblock_loc = fstab_line + index;\n\t\t\t\t\t} else if (item_index > 1) {\n\t\t\t\t\t\tchar *ptr = fstab_line + index;\n\t\t\t\t\t\tif (*ptr == '/') {\n\t\t\t\t\t\t\tline_flags.Alternate_Block_Device = ptr;\n\t\t\t\t\t\t} else if (strlen(ptr) > strlen(\"flags=\") && strncmp(ptr, \"flags=\", strlen(\"flags=\")) == 0) {\n\t\t\t\t\t\t\tflags_loc = ptr;\n\t\t\t\t\t\t\t// Once we find the flags=, we're done scanning the line\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfound_separator = false;\n\t\t\t\t\titem_index++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (block_loc)\n\t\t\t\tline_flags.Primary_Block_Device = block_loc;\n\t\t\tif (fs_loc)\n\t\t\t\tline_flags.File_System = fs_loc;\n\t\t\tif (flags_loc)\n\t\t\t\tline_flags.Flags = flags_loc;\n\t\t\tstring Mount_Point = fstab_line;\n\t\t\ttwrp_flags[Mount_Point] = line_flags;\n\t\t\tmemset(fstab_line, 0, sizeof(fstab_line));\n\t\t}\n\t\tfclose(fstabFile);\n\t}\n\n\tfstabFile = fopen(Fstab_Filename.c_str(), \"rt\");\n\tif (fstabFile == NULL) {\n\t\tLOGERR(\"Critical Error: Unable to open fstab at '%s'.\\n\", Fstab_Filename.c_str());\n\t\treturn false;\n\t} else\n\t\tLOGINFO(\"Reading %s\\n\", Fstab_Filename.c_str());\n\n\twhile (fgets(fstab_line, sizeof(fstab_line), fstabFile) != NULL) {\n\t\tif (fstab_line[0] != '/')\n\t\t\tcontinue;\n\n\t\tif (strstr(fstab_line, \"swap\"))\n\t\t\tcontinue; // Skip swap in recovery\n\n\t\tsize_t line_size = strlen(fstab_line);\n\t\tif (fstab_line[line_size - 1] != '\\n')\n\t\t\tfstab_line[line_size] = '\\n';\n\n\t\tTWPartition* partition = new TWPartition();\n\t\tif (partition->Process_Fstab_Line(fstab_line, Display_Error, &twrp_flags))\n\t\t\tPartitions.push_back(partition);\n\t\telse\n\t\t\tdelete partition;\n\n\t\tmemset(fstab_line, 0, sizeof(fstab_line));\n\t}\n\tfclose(fstabFile);\n\n\tif (twrp_flags.size() > 0) {\n\t\tLOGINFO(\"Processing remaining twrp.flags\\n\");\n\t\t// Add any items from twrp.flags that did not exist in the recovery.fstab\n\t\tfor (std::map<string, Flags_Map>::iterator mapit=twrp_flags.begin(); mapit!=twrp_flags.end(); mapit++) {\n\t\t\tif (Find_Partition_By_Path(mapit->first) == NULL) {\n\t\t\t\tTWPartition* partition = new TWPartition();\n\t\t\t\tif (partition->Process_Fstab_Line(mapit->second.fstab_line, Display_Error, NULL))\n\t\t\t\t\tPartitions.push_back(partition);\n\t\t\t\telse\n\t\t\t\t\tdelete partition;\n\t\t\t}\n\t\t\tif (mapit->second.fstab_line)\n\t\t\t\tfree(mapit->second.fstab_line);\n\t\t\tmapit->second.fstab_line = NULL;\n\t\t}\n\t}\n\tLOGINFO(\"Done processing fstab files\\n\");\n\n\tstd::vector<TWPartition*>::iterator iter;\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t(*iter)->Partition_Post_Processing(Display_Error);\n\n\t\tif ((*iter)->Is_Storage) {\n\t\t\t++storageid;\n\t\t\t(*iter)->MTP_Storage_ID = storageid;\n\t\t}\n\n\t\tif (!settings_partition && (*iter)->Is_Settings_Storage && (*iter)->Is_Present)\n\t\t\tsettings_partition = (*iter);\n\t\telse\n\t\t\t(*iter)->Is_Settings_Storage = false;\n\n\t\tif (!andsec_partition && (*iter)->Has_Android_Secure && (*iter)->Is_Present)\n\t\t\tandsec_partition = (*iter);\n\t\telse\n\t\t\t(*iter)->Has_Android_Secure = false;\n\t}\n\n\tif (!datamedia && !settings_partition && Find_Partition_By_Path(\"/sdcard\") == NULL && Find_Partition_By_Path(\"/internal_sd\") == NULL && Find_Partition_By_Path(\"/internal_sdcard\") == NULL && Find_Partition_By_Path(\"/emmc\") == NULL) {\n\t\t// Attempt to automatically identify /data/media emulated storage devices\n\t\tTWPartition* Dat = Find_Partition_By_Path(\"/data\");\n\t\tif (Dat) {\n\t\t\tLOGINFO(\"Using automatic handling for /data/media emulated storage device.\\n\");\n\t\t\tdatamedia = true;\n\t\t\tDat->Setup_Data_Media();\n\t\t\tsettings_partition = Dat;\n\t\t\t// Since /data was not considered a storage partition earlier, we still need to assign an MTP ID\n\t\t\t++storageid;\n\t\t\tDat->MTP_Storage_ID = storageid;\n\t\t}\n\t}\n\tif (!settings_partition) {\n\t\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Is_Storage) {\n\t\t\t\tsettings_partition = (*iter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!settings_partition)\n\t\t\tLOGERR(\"Unable to locate storage partition for storing settings file.\\n\");\n\t}\n\tif (!Write_Fstab()) {\n\t\tif (Display_Error)\n\t\t\tLOGERR(\"Error creating fstab\\n\");\n\t\telse\n\t\t\tLOGINFO(\"Error creating fstab\\n\");\n\t}\n\n\tif (andsec_partition) {\n\t\tSetup_Android_Secure_Location(andsec_partition);\n\t} else if (settings_partition) {\n\t\tSetup_Android_Secure_Location(settings_partition);\n\t}\n\tif (settings_partition) {\n\t\tSetup_Settings_Storage_Partition(settings_partition);\n\t}\n#ifdef TW_INCLUDE_CRYPTO\n\tTWPartition* Decrypt_Data = Find_Partition_By_Path(\"/data\");\n\tif (Decrypt_Data && Decrypt_Data->Is_Encrypted && !Decrypt_Data->Is_Decrypted) {\n\t\tif (Decrypt_Data->Is_FBE) {\n\t\t\tif (DataManager::GetIntValue(TW_CRYPTO_PWTYPE) == 0) {\n\t\t\t\tif (Decrypt_Device(\"!\") == 0) {\n\t\t\t\t\tgui_msg(\"decrypt_success=Successfully decrypted with default password.\");\n\t\t\t\t\tDataManager::SetValue(TW_IS_ENCRYPTED, 0);\n\t\t\t\t} else {\n\t\t\t\t\tgui_err(\"unable_to_decrypt=Unable to decrypt with default password.\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint password_type = cryptfs_get_password_type();\n\t\t\tif (password_type == CRYPT_TYPE_DEFAULT) {\n\t\t\t\tLOGINFO(\"Device is encrypted with the default password, attempting to decrypt.\\n\");\n\t\t\t\tif (Decrypt_Device(\"default_password\") == 0) {\n\t\t\t\t\tgui_msg(\"decrypt_success=Successfully decrypted with default password.\");\n\t\t\t\t\tDataManager::SetValue(TW_IS_ENCRYPTED, 0);\n\t\t\t\t} else {\n\t\t\t\t\tgui_err(\"unable_to_decrypt=Unable to decrypt with default password.\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDataManager::SetValue(\"TW_CRYPTO_TYPE\", password_type);\n\t\t\t}\n\t\t}\n\t}\n\tif (Decrypt_Data && (!Decrypt_Data->Is_Encrypted || Decrypt_Data->Is_Decrypted) && Decrypt_Data->Mount(false)) {\n\t\tDecrypt_Adopted();\n\t}\n#endif\n\tUpdate_System_Details();\n\tUnMount_Main_Partitions();\n#ifdef AB_OTA_UPDATER\n\tDataManager::SetValue(\"tw_active_slot\", Get_Active_Slot_Display());\n#endif\n\tsetup_uevent();\n\treturn true;\n}\n\nint TWPartitionManager::Write_Fstab(void) {\n\tFILE *fp;\n\tstd::vector<TWPartition*>::iterator iter;\n\tstring Line;\n\n\tfp = fopen(\"/etc/fstab\", \"w\");\n\tif (fp == NULL) {\n\t\tLOGINFO(\"Can not open /etc/fstab.\\n\");\n\t\treturn false;\n\t}\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Can_Be_Mounted) {\n\t\t\tLine = (*iter)->Actual_Block_Device + \" \" + (*iter)->Mount_Point + \" \" + (*iter)->Current_File_System + \" rw 0 0\\n\";\n\t\t\tfputs(Line.c_str(), fp);\n\t\t}\n\t\t// Handle subpartition tracking\n\t\tif ((*iter)->Is_SubPartition) {\n\t\t\tTWPartition* ParentPartition = Find_Partition_By_Path((*iter)->SubPartition_Of);\n\t\t\tif (ParentPartition)\n\t\t\t\tParentPartition->Has_SubPartition = true;\n\t\t\telse\n\t\t\t\tLOGERR(\"Unable to locate parent partition '%s' of '%s'\\n\", (*iter)->SubPartition_Of.c_str(), (*iter)->Mount_Point.c_str());\n\t\t}\n\t}\n\tfclose(fp);\n\treturn true;\n}\n\nvoid TWPartitionManager::Setup_Settings_Storage_Partition(TWPartition* Part) {\n\tDataManager::SetValue(\"tw_settings_path\", Part->Storage_Path);\n\tDataManager::SetValue(\"tw_storage_path\", Part->Storage_Path);\n\tLOGINFO(\"Settings storage is '%s'\\n\", Part->Storage_Path.c_str());\n}\n\nvoid TWPartitionManager::Setup_Android_Secure_Location(TWPartition* Part) {\n\tif (Part->Has_Android_Secure)\n\t\tPart->Setup_AndSec();\n\telse if (!datamedia)\n\t\tPart->Setup_AndSec();\n}\n\nvoid TWPartitionManager::Output_Partition_Logging(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tprintf(\"\\n\\nPartition Logs:\\n\");\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++)\n\t\tOutput_Partition((*iter));\n}\n\nvoid TWPartitionManager::Output_Partition(TWPartition* Part) {\n\tunsigned long long mb = 1048576;\n\n\tprintf(\"%s | %s | Size: %iMB\", Part->Mount_Point.c_str(), Part->Actual_Block_Device.c_str(), (int)(Part->Size / mb));\n\tif (Part->Can_Be_Mounted) {\n\t\tprintf(\" Used: %iMB Free: %iMB Backup Size: %iMB\", (int)(Part->Used / mb), (int)(Part->Free / mb), (int)(Part->Backup_Size / mb));\n\t}\n\tprintf(\"\\n   Flags: \");\n\tif (Part->Can_Be_Mounted)\n\t\tprintf(\"Can_Be_Mounted \");\n\tif (Part->Can_Be_Wiped)\n\t\tprintf(\"Can_Be_Wiped \");\n\tif (Part->Use_Rm_Rf)\n\t\tprintf(\"Use_Rm_Rf \");\n\tif (Part->Can_Be_Backed_Up)\n\t\tprintf(\"Can_Be_Backed_Up \");\n\tif (Part->Wipe_During_Factory_Reset)\n\t\tprintf(\"Wipe_During_Factory_Reset \");\n\tif (Part->Wipe_Available_in_GUI)\n\t\tprintf(\"Wipe_Available_in_GUI \");\n\tif (Part->Is_SubPartition)\n\t\tprintf(\"Is_SubPartition \");\n\tif (Part->Has_SubPartition)\n\t\tprintf(\"Has_SubPartition \");\n\tif (Part->Removable)\n\t\tprintf(\"Removable \");\n\tif (Part->Is_Present)\n\t\tprintf(\"IsPresent \");\n\tif (Part->Can_Be_Encrypted)\n\t\tprintf(\"Can_Be_Encrypted \");\n\tif (Part->Is_Encrypted)\n\t\tprintf(\"Is_Encrypted \");\n\tif (Part->Is_Decrypted)\n\t\tprintf(\"Is_Decrypted \");\n\tif (Part->Has_Data_Media)\n\t\tprintf(\"Has_Data_Media \");\n\tif (Part->Can_Encrypt_Backup)\n\t\tprintf(\"Can_Encrypt_Backup \");\n\tif (Part->Use_Userdata_Encryption)\n\t\tprintf(\"Use_Userdata_Encryption \");\n\tif (Part->Has_Android_Secure)\n\t\tprintf(\"Has_Android_Secure \");\n\tif (Part->Is_Storage)\n\t\tprintf(\"Is_Storage \");\n\tif (Part->Is_Settings_Storage)\n\t\tprintf(\"Is_Settings_Storage \");\n\tif (Part->Ignore_Blkid)\n\t\tprintf(\"Ignore_Blkid \");\n\tif (Part->Retain_Layout_Version)\n\t\tprintf(\"Retain_Layout_Version \");\n\tif (Part->Mount_To_Decrypt)\n\t\tprintf(\"Mount_To_Decrypt \");\n\tif (Part->Can_Flash_Img)\n\t\tprintf(\"Can_Flash_Img \");\n\tif (Part->Is_Adopted_Storage)\n\t\tprintf(\"Is_Adopted_Storage \");\n\tif (Part->SlotSelect)\n\t\tprintf(\"SlotSelect \");\n\tif (Part->Mount_Read_Only)\n\t\tprintf(\"Mount_Read_Only \");\n\tprintf(\"\\n\");\n\tif (!Part->SubPartition_Of.empty())\n\t\tprintf(\"   SubPartition_Of: %s\\n\", Part->SubPartition_Of.c_str());\n\tif (!Part->Symlink_Path.empty())\n\t\tprintf(\"   Symlink_Path: %s\\n\", Part->Symlink_Path.c_str());\n\tif (!Part->Symlink_Mount_Point.empty())\n\t\tprintf(\"   Symlink_Mount_Point: %s\\n\", Part->Symlink_Mount_Point.c_str());\n\tif (!Part->Primary_Block_Device.empty())\n\t\tprintf(\"   Primary_Block_Device: %s\\n\", Part->Primary_Block_Device.c_str());\n\tif (!Part->Alternate_Block_Device.empty())\n\t\tprintf(\"   Alternate_Block_Device: %s\\n\", Part->Alternate_Block_Device.c_str());\n\tif (!Part->Decrypted_Block_Device.empty())\n\t\tprintf(\"   Decrypted_Block_Device: %s\\n\", Part->Decrypted_Block_Device.c_str());\n\tif (!Part->Crypto_Key_Location.empty() && Part->Crypto_Key_Location != \"footer\")\n\t\tprintf(\"   Crypto_Key_Location: %s\\n\", Part->Crypto_Key_Location.c_str());\n\tif (Part->Length != 0)\n\t\tprintf(\"   Length: %i\\n\", Part->Length);\n\tif (!Part->Display_Name.empty())\n\t\tprintf(\"   Display_Name: %s\\n\", Part->Display_Name.c_str());\n\tif (!Part->Storage_Name.empty())\n\t\tprintf(\"   Storage_Name: %s\\n\", Part->Storage_Name.c_str());\n\tif (!Part->Backup_Path.empty())\n\t\tprintf(\"   Backup_Path: %s\\n\", Part->Backup_Path.c_str());\n\tif (!Part->Backup_Name.empty())\n\t\tprintf(\"   Backup_Name: %s\\n\", Part->Backup_Name.c_str());\n\tif (!Part->Backup_Display_Name.empty())\n\t\tprintf(\"   Backup_Display_Name: %s\\n\", Part->Backup_Display_Name.c_str());\n\tif (!Part->Backup_FileName.empty())\n\t\tprintf(\"   Backup_FileName: %s\\n\", Part->Backup_FileName.c_str());\n\tif (!Part->Storage_Path.empty())\n\t\tprintf(\"   Storage_Path: %s\\n\", Part->Storage_Path.c_str());\n\tif (!Part->Current_File_System.empty())\n\t\tprintf(\"   Current_File_System: %s\\n\", Part->Current_File_System.c_str());\n\tif (!Part->Fstab_File_System.empty())\n\t\tprintf(\"   Fstab_File_System: %s\\n\", Part->Fstab_File_System.c_str());\n\tif (Part->Format_Block_Size != 0)\n\t\tprintf(\"   Format_Block_Size: %lu\\n\", Part->Format_Block_Size);\n\tif (!Part->MTD_Name.empty())\n\t\tprintf(\"   MTD_Name: %s\\n\", Part->MTD_Name.c_str());\n\tprintf(\"   Backup_Method: %s\\n\", Part->Backup_Method_By_Name().c_str());\n\tif (Part->Mount_Flags || !Part->Mount_Options.empty())\n\t\tprintf(\"   Mount_Flags: %i, Mount_Options: %s\\n\", Part->Mount_Flags, Part->Mount_Options.c_str());\n\tif (Part->MTP_Storage_ID)\n\t\tprintf(\"   MTP_Storage_ID: %i\\n\", Part->MTP_Storage_ID);\n\tprintf(\"\\n\");\n}\n\nint TWPartitionManager::Mount_By_Path(string Path, bool Display_Error) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\tif (Local_Path == \"/tmp\" || Local_Path == \"/\")\n\t\treturn true;\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tret = (*iter)->Mount(Display_Error);\n\t\t\tfound = true;\n\t\t} else if ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Local_Path) {\n\t\t\t(*iter)->Mount(Display_Error);\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else if (Display_Error) {\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Local_Path));\n\t} else {\n\t\tLOGINFO(\"Mount: Unable to find partition for path '%s'\\n\", Local_Path.c_str());\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::UnMount_By_Path(string Path, bool Display_Error) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tret = (*iter)->UnMount(Display_Error);\n\t\t\tfound = true;\n\t\t} else if ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Local_Path) {\n\t\t\t(*iter)->UnMount(Display_Error);\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else if (Display_Error) {\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Local_Path));\n\t} else {\n\t\tLOGINFO(\"UnMount: Unable to find partition for path '%s'\\n\", Local_Path.c_str());\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::Is_Mounted_By_Path(string Path) {\n\tTWPartition* Part = Find_Partition_By_Path(Path);\n\n\tif (Part)\n\t\treturn Part->Is_Mounted();\n\telse\n\t\tLOGINFO(\"Is_Mounted: Unable to find partition for path '%s'\\n\", Path.c_str());\n\treturn false;\n}\n\nint TWPartitionManager::Mount_Current_Storage(bool Display_Error) {\n\tstring current_storage_path = DataManager::GetCurrentStoragePath();\n\n\tif (Mount_By_Path(current_storage_path, Display_Error)) {\n\t\tTWPartition* FreeStorage = Find_Partition_By_Path(current_storage_path);\n\t\tif (FreeStorage)\n\t\t\tDataManager::SetValue(TW_STORAGE_FREE_SIZE, (int)(FreeStorage->Free / 1048576LLU));\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::Mount_Settings_Storage(bool Display_Error) {\n\treturn Mount_By_Path(DataManager::GetSettingsStoragePath(), Display_Error);\n}\n\nTWPartition* TWPartitionManager::Find_Partition_By_Path(const string& Path) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path))\n\t\t\treturn (*iter);\n\t}\n\treturn NULL;\n}\n\nTWPartition* TWPartitionManager::Find_Partition_By_Block_Device(const string& Block_Device) {\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Primary_Block_Device == Block_Device || (!(*iter)->Actual_Block_Device.empty() && (*iter)->Actual_Block_Device == Block_Device))\n\t\t\treturn (*iter);\n\t}\n\treturn NULL;\n}\n\nint TWPartitionManager::Check_Backup_Name(bool Display_Error) {\n\t// Check the backup name to ensure that it is the correct size and contains only valid characters\n\t// and that a backup with that name doesn't already exist\n\tchar backup_name[MAX_BACKUP_NAME_LEN];\n\tchar backup_loc[255], tw_image_dir[255];\n\tint copy_size;\n\tint index, cur_char;\n\tstring Backup_Name, Backup_Loc;\n\n\tDataManager::GetValue(TW_BACKUP_NAME, Backup_Name);\n\tcopy_size = Backup_Name.size();\n\t// Check size\n\tif (copy_size > MAX_BACKUP_NAME_LEN) {\n\t\tif (Display_Error)\n\t\t\tgui_err(\"backup_name_len=Backup name is too long.\");\n\t\treturn -2;\n\t}\n\n\t// Check each character\n\tstrncpy(backup_name, Backup_Name.c_str(), copy_size);\n\tif (copy_size == 1 && strncmp(backup_name, \"0\", 1) == 0)\n\t\treturn 0; // A \"0\" (zero) means to use the current timestamp for the backup name\n\tfor (index=0; index<copy_size; index++) {\n\t\tcur_char = (int)backup_name[index];\n\t\tif (cur_char == 32 || (cur_char >= 48 && cur_char <= 57) || (cur_char >= 65 && cur_char <= 91) || cur_char == 93 || cur_char == 95 || (cur_char >= 97 && cur_char <= 123) || cur_char == 125 || cur_char == 45 || cur_char == 46) {\n\t\t\t// These are valid characters\n\t\t\t// Numbers\n\t\t\t// Upper case letters\n\t\t\t// Lower case letters\n\t\t\t// Space\n\t\t\t// and -_.{}[]\n\t\t} else {\n\t\t\tif (Display_Error)\n\t\t\t\tgui_msg(Msg(msg::kError, \"backup_name_invalid=Backup name '{1}' contains invalid character: '{1}'\")(Backup_Name)((char)cur_char));\n\t\t\treturn -3;\n\t\t}\n\t}\n\n\t// Check to make sure that a backup with this name doesn't already exist\n\tDataManager::GetValue(TW_BACKUPS_FOLDER_VAR, Backup_Loc);\n\tstrcpy(backup_loc, Backup_Loc.c_str());\n\tsprintf(tw_image_dir,\"%s/%s\", backup_loc, Backup_Name.c_str());\n\tif (TWFunc::Path_Exists(tw_image_dir)) {\n\t\tif (Display_Error)\n\t\t\tgui_err(\"backup_name_exists=A backup with that name already exists!\");\n\n\t\treturn -4;\n\t}\n\t// No problems found, return 0\n\treturn 0;\n}\n\nbool TWPartitionManager::Backup_Partition(PartitionSettings *part_settings) {\n\ttime_t start, stop;\n\tint use_compression;\n\tstring backup_log = part_settings->Backup_Folder + \"/recovery.log\";\n\n\tif (part_settings->Part == NULL)\n\t\treturn true;\n\n\tDataManager::GetValue(TW_USE_COMPRESSION_VAR, use_compression);\n\n\tTWFunc::SetPerformanceMode(true);\n\ttime(&start);\n\n\tif (part_settings->Part->Backup(part_settings, &tar_fork_pid)) {\n\t\tsync();\n\t\tsync();\n\t\tstring Full_Filename = part_settings->Backup_Folder + \"/\" + part_settings->Part->Backup_FileName;\n\t\tif (!part_settings->adbbackup && part_settings->generate_digest) {\n\t\t\tif (!twrpDigestDriver::Make_Digest(Full_Filename))\n\t\t\t\tgoto backup_error;\n\t\t}\n\n\t\tif (part_settings->Part->Has_SubPartition) {\n\t\t\tstd::vector<TWPartition*>::iterator subpart;\n\t\t\tTWPartition *parentPart = part_settings->Part;\n\n\t\t\tfor (subpart = Partitions.begin(); subpart != Partitions.end(); subpart++) {\n\t\t\t\tif ((*subpart)->Can_Be_Backed_Up && (*subpart)->Is_SubPartition && (*subpart)->SubPartition_Of == parentPart->Mount_Point) {\n\t\t\t\t\tpart_settings->Part = *subpart;\n\t\t\t\t\tif (!(*subpart)->Backup(part_settings, &tar_fork_pid)) {\n\t\t\t\t\t\tgoto backup_error;\n\t\t\t\t\t}\n\t\t\t\t\tsync();\n\t\t\t\t\tsync();\n\t\t\t\t\tif (!part_settings->adbbackup && part_settings->generate_digest) {\n\t\t\t\t\t\tif (!twrpDigestDriver::Make_Digest(Full_Filename)) {\n\t\t\t\t\t\t\tgoto backup_error;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime(&stop);\n\t\tint backup_time = (int) difftime(stop, start);\n\t\tLOGINFO(\"Partition Backup time: %d\\n\", backup_time);\n\n\t\tif (part_settings->Part->Backup_Method == BM_FILES) {\n\t\t\tpart_settings->file_time += backup_time;\n\t\t} else {\n\t\t\tpart_settings->img_time += backup_time;\n\n\t\t}\n\n\t\tTWFunc::SetPerformanceMode(false);\n\t\treturn true;\n\t}\nbackup_error:\n\tClean_Backup_Folder(part_settings->Backup_Folder);\n\tTWFunc::copy_file(\"/tmp/recovery.log\", backup_log, 0644);\n\ttw_set_default_metadata(backup_log.c_str());\n\tTWFunc::SetPerformanceMode(false);\n\treturn false;\n}\n\nvoid TWPartitionManager::Clean_Backup_Folder(string Backup_Folder) {\n\tDIR *d = opendir(Backup_Folder.c_str());\n\tstruct dirent *p;\n\tint r;\n\tvector<string> ext;\n\n\t//extensions we should delete when cleaning\n\text.push_back(\"win\");\n\text.push_back(\"md5\");\n\text.push_back(\"sha2\");\n\text.push_back(\"info\");\n\n\tgui_msg(\"backup_clean=Backup Failed. Cleaning Backup Folder.\");\n\n\tif (d == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Backup_Folder)(strerror(errno)));\n\t\treturn;\n\t}\n\n\twhile ((p = readdir(d))) {\n\t\tif (!strcmp(p->d_name, \".\") || !strcmp(p->d_name, \"..\"))\n\t\t\tcontinue;\n\n\t\tstring path = Backup_Folder + \"/\" + p->d_name;\n\n\t\tsize_t dot = path.find_last_of(\".\") + 1;\n\t\tfor (vector<string>::const_iterator i = ext.begin(); i != ext.end(); ++i) {\n\t\t\tif (path.substr(dot) == *i) {\n\t\t\t\tr = unlink(path.c_str());\n\t\t\t\tif (r != 0)\n\t\t\t\t\tLOGINFO(\"Unable to unlink '%s: %s'\\n\", path.c_str(), strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(d);\n}\n\nint TWPartitionManager::Check_Backup_Cancel() {\n\treturn stop_backup.get_value();\n}\n\nint TWPartitionManager::Cancel_Backup() {\n\tstring Backup_Folder, Backup_Name, Full_Backup_Path;\n\n\tstop_backup.set_value(1);\n\n\tif (tar_fork_pid != 0) {\n\t\tDataManager::GetValue(TW_BACKUP_NAME, Backup_Name);\n\t\tDataManager::GetValue(TW_BACKUPS_FOLDER_VAR, Backup_Folder);\n\t\tFull_Backup_Path = Backup_Folder + \"/\" + Backup_Name;\n\t\tLOGINFO(\"Killing pid: %d\\n\", tar_fork_pid);\n\t\tkill(tar_fork_pid, SIGUSR2);\n\t\twhile (kill(tar_fork_pid, 0) == 0) {\n\t\t\tusleep(1000);\n\t\t}\n\t\tLOGINFO(\"Backup_Run stopped and returning false, backup cancelled.\\n\");\n\t\tLOGINFO(\"Removing directory %s\\n\", Full_Backup_Path.c_str());\n\t\tTWFunc::removeDir(Full_Backup_Path, false);\n\t\ttar_fork_pid = 0;\n\t}\n\n\treturn 0;\n}\n\nint TWPartitionManager::Run_Backup(bool adbbackup) {\n\tPartitionSettings part_settings;\n\tint partition_count = 0, disable_free_space_check = 0, skip_digest = 0;\n\tstring Backup_Name, Backup_List, backup_path;\n\tunsigned long long total_bytes = 0, free_space = 0;\n\tTWPartition* storage = NULL;\n\tstd::vector<TWPartition*>::iterator subpart;\n\tstruct tm *t;\n\ttime_t seconds, total_start, total_stop;\n\tsize_t start_pos = 0, end_pos = 0;\n\tstop_backup.set_value(0);\n\tseconds = time(0);\n\tt = localtime(&seconds);\n\n\tpart_settings.img_bytes_remaining = 0;\n\tpart_settings.file_bytes_remaining = 0;\n\tpart_settings.img_time = 0;\n\tpart_settings.file_time = 0;\n\tpart_settings.img_bytes = 0;\n\tpart_settings.file_bytes = 0;\n\tpart_settings.PM_Method = PM_BACKUP;\n\n\tpart_settings.adbbackup = adbbackup;\n\ttime(&total_start);\n\n\tUpdate_System_Details();\n\n\tif (!Mount_Current_Storage(true))\n\t\treturn false;\n\n\tDataManager::GetValue(TW_SKIP_DIGEST_GENERATE_VAR, skip_digest);\n\tif (skip_digest == 0)\n\t\tpart_settings.generate_digest = true;\n\telse\n\t\tpart_settings.generate_digest = false;\n\n\tDataManager::GetValue(TW_BACKUPS_FOLDER_VAR, part_settings.Backup_Folder);\n\tDataManager::GetValue(TW_BACKUP_NAME, Backup_Name);\n\tif (Backup_Name == gui_lookup(\"curr_date\", \"(Current Date)\")) {\n\t\tBackup_Name = TWFunc::Get_Current_Date();\n\t} else if (Backup_Name == gui_lookup(\"auto_generate\", \"(Auto Generate)\") || Backup_Name == \"0\" || Backup_Name.empty()) {\n\t\tTWFunc::Auto_Generate_Backup_Name();\n\t\tDataManager::GetValue(TW_BACKUP_NAME, Backup_Name);\n\t}\n\n\tLOGINFO(\"Backup Name is: '%s'\\n\", Backup_Name.c_str());\n\tpart_settings.Backup_Folder = part_settings.Backup_Folder + \"/\" + Backup_Name;\n\n\tLOGINFO(\"Backup_Folder is: '%s'\\n\", part_settings.Backup_Folder.c_str());\n\n\tLOGINFO(\"Calculating backup details...\\n\");\n\tDataManager::GetValue(\"tw_backup_list\", Backup_List);\n\tif (!Backup_List.empty()) {\n\t\tend_pos = Backup_List.find(\";\", start_pos);\n\t\twhile (end_pos != string::npos && start_pos < Backup_List.size()) {\n\t\t\tbackup_path = Backup_List.substr(start_pos, end_pos - start_pos);\n\t\t\tpart_settings.Part = Find_Partition_By_Path(backup_path);\n\t\t\tif (part_settings.Part != NULL) {\n\t\t\t\tpartition_count++;\n\t\t\t\tif (part_settings.Part->Backup_Method == BM_FILES)\n\t\t\t\t\tpart_settings.file_bytes += part_settings.Part->Backup_Size;\n\t\t\t\telse\n\t\t\t\t\tpart_settings.img_bytes += part_settings.Part->Backup_Size;\n\t\t\t\tif (part_settings.Part->Has_SubPartition) {\n\t\t\t\t\tstd::vector<TWPartition*>::iterator subpart;\n\n\t\t\t\t\tfor (subpart = Partitions.begin(); subpart != Partitions.end(); subpart++) {\n\t\t\t\t\t\tif ((*subpart)->Can_Be_Backed_Up && (*subpart)->Is_Present && (*subpart)->Is_SubPartition && (*subpart)->SubPartition_Of == part_settings.Part->Mount_Point) {\n\t\t\t\t\t\t\tpartition_count++;\n\t\t\t\t\t\t\tif ((*subpart)->Backup_Method == BM_FILES)\n\t\t\t\t\t\t\t\tpart_settings.file_bytes += (*subpart)->Backup_Size;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tpart_settings.img_bytes += (*subpart)->Backup_Size;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgui_msg(Msg(msg::kError, \"unable_to_locate_partition=Unable to locate '{1}' partition for backup calculations.\")(backup_path));\n\t\t\t}\n\t\t\tstart_pos = end_pos + 1;\n\t\t\tend_pos = Backup_List.find(\";\", start_pos);\n\t\t}\n\t}\n\n\tif (partition_count == 0) {\n\t\tgui_msg(\"no_partition_selected=No partitions selected for backup.\");\n\t\treturn false;\n\t}\n\tif (adbbackup) {\n\t\tif (twadbbu::Write_ADB_Stream_Header(partition_count) == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\ttotal_bytes = part_settings.file_bytes + part_settings.img_bytes;\n\tProgressTracking progress(total_bytes);\n\tpart_settings.progress = &progress;\n\n\tgui_msg(Msg(\"total_partitions_backup= * Total number of partitions to back up: {1}\")(partition_count));\n\tgui_msg(Msg(\"total_backup_size= * Total size of all data: {1}MB\")(total_bytes / 1024 / 1024));\n\tstorage = Find_Partition_By_Path(DataManager::GetCurrentStoragePath());\n\tif (storage != NULL) {\n\t\tfree_space = storage->Free;\n\t\tgui_msg(Msg(\"available_space= * Available space: {1}MB\")(free_space / 1024 / 1024));\n\t} else {\n\t\tgui_err(\"unable_locate_storage=Unable to locate storage device.\");\n\t\treturn false;\n\t}\n\n\tDataManager::GetValue(TW_DISABLE_FREE_SPACE_VAR, disable_free_space_check);\n\n\tif (adbbackup)\n\t\tdisable_free_space_check = true;\n\n\tif (!disable_free_space_check) {\n\t\tif (free_space - (32 * 1024 * 1024) < total_bytes) {\n\t\t\t// We require an extra 32MB just in case\n\t\t\tgui_err(\"no_space=Not enough free space on storage.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tpart_settings.img_bytes_remaining = part_settings.img_bytes;\n\tpart_settings.file_bytes_remaining = part_settings.file_bytes;\n\n\tgui_msg(\"backup_started=[BACKUP STARTED]\");\n\tgui_msg(Msg(\"backup_folder= * Backup Folder: {1}\")(part_settings.Backup_Folder));\n\tif (!TWFunc::Recursive_Mkdir(part_settings.Backup_Folder)) {\n\t\tgui_err(\"fail_backup_folder=Failed to make backup folder.\");\n\t\treturn false;\n\t}\n\n\tDataManager::SetProgress(0.0);\n\n\tstart_pos = 0;\n\tend_pos = Backup_List.find(\";\", start_pos);\n\twhile (end_pos != string::npos && start_pos < Backup_List.size()) {\n\t\tif (stop_backup.get_value() != 0)\n\t\t\treturn -1;\n\t\tbackup_path = Backup_List.substr(start_pos, end_pos - start_pos);\n\t\tpart_settings.Part = Find_Partition_By_Path(backup_path);\n\t\tif (part_settings.Part != NULL) {\n\t\t\tif (!Backup_Partition(&part_settings))\n\t\t\t\treturn false;\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_locate_partition=Unable to locate '{1}' partition for backup calculations.\")(backup_path));\n\t\t}\n\t\tstart_pos = end_pos + 1;\n\t\tend_pos = Backup_List.find(\";\", start_pos);\n\t}\n\n\t// Average BPS\n\tif (part_settings.img_time == 0)\n\t\tpart_settings.img_time = 1;\n\tif (part_settings.file_time == 0)\n\t\tpart_settings.file_time = 1;\n\tint img_bps = (int)part_settings.img_bytes / (int)part_settings.img_time;\n\tunsigned long long file_bps = part_settings.file_bytes / (int)part_settings.file_time;\n\n\tif (part_settings.file_bytes != 0)\n\t\tgui_msg(Msg(\"avg_backup_fs=Average backup rate for file systems: {1} MB/sec\")(file_bps / (1024 * 1024)));\n\tif (part_settings.img_bytes != 0)\n\t\tgui_msg(Msg(\"avg_backup_img=Average backup rate for imaged drives: {1} MB/sec\")(img_bps / (1024 * 1024)));\n\n\ttime(&total_stop);\n\tint total_time = (int) difftime(total_stop, total_start);\n\n\tuint64_t actual_backup_size;\n\tif (!adbbackup) {\n\t\tTWExclude twe;\n\t\tactual_backup_size = twe.Get_Folder_Size(part_settings.Backup_Folder);\n\t} else\n\t\tactual_backup_size = part_settings.file_bytes + part_settings.img_bytes;\n\tactual_backup_size /= (1024LLU * 1024LLU);\n\n\tint prev_img_bps = 0, use_compression = 0;\n\tunsigned long long prev_file_bps = 0;\n\tDataManager::GetValue(TW_BACKUP_AVG_IMG_RATE, prev_img_bps);\n\timg_bps += (prev_img_bps * 4);\n\timg_bps /= 5;\n\n\tDataManager::GetValue(TW_USE_COMPRESSION_VAR, use_compression);\n\tif (use_compression)\n\t\tDataManager::GetValue(TW_BACKUP_AVG_FILE_COMP_RATE, prev_file_bps);\n\telse\n\t\tDataManager::GetValue(TW_BACKUP_AVG_FILE_RATE, prev_file_bps);\n\tfile_bps += (prev_file_bps * 4);\n\tfile_bps /= 5;\n\n\tDataManager::SetValue(TW_BACKUP_AVG_IMG_RATE, img_bps);\n\tif (use_compression)\n\t\tDataManager::SetValue(TW_BACKUP_AVG_FILE_COMP_RATE, file_bps);\n\telse\n\t\tDataManager::SetValue(TW_BACKUP_AVG_FILE_RATE, file_bps);\n\n\tgui_msg(Msg(\"total_backed_size=[{1} MB TOTAL BACKED UP]\")(actual_backup_size));\n\tUpdate_System_Details();\n\tUnMount_Main_Partitions();\n\tgui_msg(Msg(msg::kHighlight, \"backup_completed=[BACKUP COMPLETED IN {1} SECONDS]\")(total_time)); // the end\n\tstring backup_log = part_settings.Backup_Folder + \"/recovery.log\";\n\tTWFunc::copy_file(\"/tmp/recovery.log\", backup_log, 0644);\n\ttw_set_default_metadata(backup_log.c_str());\n\n\tif (part_settings.adbbackup) {\n\t\tif (twadbbu::Write_ADB_Stream_Trailer() == false) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tpart_settings.adbbackup = false;\n\tDataManager::SetValue(\"tw_enable_adb_backup\", 0);\n\n\treturn true;\n}\n\nbool TWPartitionManager::Restore_Partition(PartitionSettings *part_settings) {\n\ttime_t Start, Stop;\n\n\tif (part_settings->adbbackup) {\n\t\tstd::string partName = part_settings->Part->Backup_Name + \".\" + part_settings->Part->Current_File_System + \".win\";\n\t\tLOGINFO(\"setting backup name: %s\\n\", partName.c_str());\n\t\tpart_settings->Part->Set_Backup_FileName(part_settings->Part->Backup_Name + \".\" + part_settings->Part->Current_File_System + \".win\");\n\t}\n\n\tTWFunc::SetPerformanceMode(true);\n\n\ttime(&Start);\n\n\tif (!part_settings->Part->Restore(part_settings)) {\n\t\tTWFunc::SetPerformanceMode(false);\n\t\treturn false;\n\t}\n\tif (part_settings->Part->Has_SubPartition && !part_settings->adbbackup) {\n\t\tstd::vector<TWPartition*>::iterator subpart;\n\t\tTWPartition *parentPart = part_settings->Part;\n\n\t\tfor (subpart = Partitions.begin(); subpart != Partitions.end(); subpart++) {\n\t\t\tpart_settings->Part = *subpart;\n\t\t\tif ((*subpart)->Is_SubPartition && (*subpart)->SubPartition_Of == parentPart->Mount_Point) {\n\t\t\t\tpart_settings->Part = (*subpart);\n\t\t\t\tpart_settings->Part->Set_Backup_FileName(part_settings->Part->Backup_Name + \".\" + part_settings->Part->Current_File_System + \".win\");\n\t\t\t\tif (!(*subpart)->Restore(part_settings)) {\n\t\t\t\t\tTWFunc::SetPerformanceMode(false);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttime(&Stop);\n\tTWFunc::SetPerformanceMode(false);\n\tgui_msg(Msg(\"restore_part_done=[{1} done ({2} seconds)]\")(part_settings->Part->Backup_Display_Name)((int)difftime(Stop, Start)));\n\n\treturn true;\n}\n\nint TWPartitionManager::Run_Restore(const string& Restore_Name) {\n\tPartitionSettings part_settings;\n\tint check_digest;\n\n\ttime_t rStart, rStop;\n\ttime(&rStart);\n\tstring Restore_List, restore_path;\n\tsize_t start_pos = 0, end_pos;\n\n\tpart_settings.Backup_Folder = Restore_Name;\n\tpart_settings.Part = NULL;\n\tpart_settings.partition_count = 0;\n\tpart_settings.total_restore_size = 0;\n\tpart_settings.adbbackup = false;\n\tpart_settings.PM_Method = PM_RESTORE;\n\n\tgui_msg(\"restore_started=[RESTORE STARTED]\");\n\tgui_msg(Msg(\"restore_folder=Restore folder: '{1}'\")(Restore_Name));\n\n\tif (!Mount_Current_Storage(true))\n\t\treturn false;\n\n\tDataManager::GetValue(TW_SKIP_DIGEST_CHECK_VAR, check_digest);\n\tif (check_digest > 0) {\n\t\t// Check Digest files first before restoring to ensure that all of them match before starting a restore\n\t\tTWFunc::GUI_Operation_Text(TW_VERIFY_DIGEST_TEXT, gui_parse_text(\"{@verifying_digest}\"));\n\t\tgui_msg(\"verifying_digest=Verifying Digest\");\n\t} else {\n\t\tgui_msg(\"skip_digest=Skipping Digest check based on user setting.\");\n\t}\n\tgui_msg(\"calc_restore=Calculating restore details...\");\n\tDataManager::GetValue(\"tw_restore_selected\", Restore_List);\n\n\tif (!Restore_List.empty()) {\n\t\tend_pos = Restore_List.find(\";\", start_pos);\n\t\twhile (end_pos != string::npos && start_pos < Restore_List.size()) {\n\t\t\trestore_path = Restore_List.substr(start_pos, end_pos - start_pos);\n\t\t\tpart_settings.Part = Find_Partition_By_Path(restore_path);\n\t\t\tif (part_settings.Part != NULL) {\n\t\t\t\tif (part_settings.Part->Mount_Read_Only) {\n\t\t\t\t\tgui_msg(Msg(msg::kError, \"restore_read_only=Cannot restore {1} -- mounted read only.\")(part_settings.Part->Backup_Display_Name));\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstring Full_Filename = part_settings.Backup_Folder + \"/\" + part_settings.Part->Backup_FileName;\n\n\t\t\t\tif (check_digest > 0 && !twrpDigestDriver::Check_Digest(Full_Filename))\n\t\t\t\t\treturn false;\n\t\t\t\tpart_settings.partition_count++;\n\t\t\t\tpart_settings.total_restore_size += part_settings.Part->Get_Restore_Size(&part_settings);\n\t\t\t\tif (part_settings.Part->Has_SubPartition) {\n\t\t\t\t\tTWPartition *parentPart = part_settings.Part;\n\t\t\t\t\tstd::vector<TWPartition*>::iterator subpart;\n\n\t\t\t\t\tfor (subpart = Partitions.begin(); subpart != Partitions.end(); subpart++) {\n\t\t\t\t\t\tpart_settings.Part = *subpart;\n\t\t\t\t\t\tif ((*subpart)->Is_SubPartition && (*subpart)->SubPartition_Of == parentPart->Mount_Point) {\n\t\t\t\t\t\t\tif (check_digest > 0 && !twrpDigestDriver::Check_Digest(Full_Filename))\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\tpart_settings.total_restore_size += (*subpart)->Get_Restore_Size(&part_settings);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgui_msg(Msg(msg::kError, \"restore_unable_locate=Unable to locate '{1}' partition for restoring.\")(restore_path));\n\t\t\t}\n\t\t\tstart_pos = end_pos + 1;\n\t\t\tend_pos = Restore_List.find(\";\", start_pos);\n\t\t}\n\t}\n\n\tif (part_settings.partition_count == 0) {\n\t\tgui_err(\"no_part_restore=No partitions selected for restore.\");\n\t\treturn false;\n\t}\n\n\tgui_msg(Msg(\"restore_part_count=Restoring {1} partitions...\")(part_settings.partition_count));\n\tgui_msg(Msg(\"total_restore_size=Total restore size is {1}MB\")(part_settings.total_restore_size / 1048576));\n\tDataManager::SetProgress(0.0);\n\tProgressTracking progress(part_settings.total_restore_size);\n\tpart_settings.progress = &progress;\n\n\tstart_pos = 0;\n\tif (!Restore_List.empty()) {\n\t\tend_pos = Restore_List.find(\";\", start_pos);\n\t\twhile (end_pos != string::npos && start_pos < Restore_List.size()) {\n\t\t\trestore_path = Restore_List.substr(start_pos, end_pos - start_pos);\n\n\t\t\tpart_settings.Part = Find_Partition_By_Path(restore_path);\n\t\t\tif (part_settings.Part != NULL) {\n\t\t\t\tpart_settings.partition_count++;\n\t\t\t\tif (!Restore_Partition(&part_settings))\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tgui_msg(Msg(msg::kError, \"restore_unable_locate=Unable to locate '{1}' partition for restoring.\")(restore_path));\n\t\t\t}\n\t\t\tstart_pos = end_pos + 1;\n\t\t\tend_pos = Restore_List.find(\";\", start_pos);\n\t\t}\n\t}\n\tTWFunc::GUI_Operation_Text(TW_UPDATE_SYSTEM_DETAILS_TEXT, gui_parse_text(\"{@updating_system_details}\"));\n\tUnMount_By_Path(\"/system\", false);\n\tUpdate_System_Details();\n\tUnMount_Main_Partitions();\n\ttime(&rStop);\n\tgui_msg(Msg(msg::kHighlight, \"restore_completed=[RESTORE COMPLETED IN {1} SECONDS]\")((int)difftime(rStop,rStart)));\n\tDataManager::SetValue(\"tw_file_progress\", \"\");\n\n\treturn true;\n}\n\nvoid TWPartitionManager::Set_Restore_Files(string Restore_Name) {\n\t// Start with the default values\n\tstring Restore_List;\n\tbool get_date = true, check_encryption = true;\n\tbool adbbackup = false;\n\n\tDataManager::SetValue(\"tw_restore_encrypted\", 0);\n\tif (twadbbu::Check_ADB_Backup_File(Restore_Name)) {\n\t\tvector<string> adb_files;\n\t\tadb_files = twadbbu::Get_ADB_Backup_Files(Restore_Name);\n\t\tfor (unsigned int i = 0; i < adb_files.size(); ++i) {\n\t\t\tstring adb_restore_file = adb_files.at(i);\n\t\t\tstd::size_t pos = adb_restore_file.find_first_of(\".\");\n\t\t\tstd::string path = \"/\" + adb_restore_file.substr(0, pos);\n\t\t\tRestore_List = path + \";\";\n\t\t\tTWPartition* Part = Find_Partition_By_Path(path);\n\t\t\tPart->Backup_FileName = TWFunc::Get_Filename(adb_restore_file);\n\t\t\tadbbackup = true;\n\t\t}\n\t\tDataManager::SetValue(\"tw_enable_adb_backup\", 1);\n\t}\n\telse {\n\t\tDIR* d;\n\t\td = opendir(Restore_Name.c_str());\n\t\tif (d == NULL)\n\t\t{\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Restore_Name)(strerror(errno)));\n\t\t\treturn;\n\t\t}\n\n\t\tstruct dirent* de;\n\t\twhile ((de = readdir(d)) != NULL)\n\t\t{\n\t\t\t// Strip off three components\n\t\t\tchar str[256];\n\t\t\tchar* label;\n\t\t\tchar* fstype = NULL;\n\t\t\tchar* extn = NULL;\n\t\t\tchar* ptr;\n\n\t\t\tstrcpy(str, de->d_name);\n\t\t\tif (strlen(str) <= 2)\n\t\t\t\tcontinue;\n\n\t\t\tif (get_date) {\n\t\t\t\tchar file_path[255];\n\t\t\t\tstruct stat st;\n\n\t\t\t\tstrcpy(file_path, Restore_Name.c_str());\n\t\t\t\tstrcat(file_path, \"/\");\n\t\t\t\tstrcat(file_path, str);\n\t\t\t\tstat(file_path, &st);\n\t\t\t\tstring backup_date = ctime((const time_t*)(&st.st_mtime));\n\t\t\t\tDataManager::SetValue(TW_RESTORE_FILE_DATE, backup_date);\n\t\t\t\tget_date = false;\n\t\t\t}\n\n\t\t\tlabel = str;\n\t\t\tptr = label;\n\t\t\twhile (*ptr && *ptr != '.')\t ptr++;\n\t\t\tif (*ptr == '.')\n\t\t\t{\n\t\t\t\t*ptr = 0x00;\n\t\t\t\tptr++;\n\t\t\t\tfstype = ptr;\n\t\t\t}\n\t\t\twhile (*ptr && *ptr != '.')\t ptr++;\n\t\t\tif (*ptr == '.')\n\t\t\t{\n\t\t\t\t*ptr = 0x00;\n\t\t\t\tptr++;\n\t\t\t\textn = ptr;\n\t\t\t}\n\n\t\t\tif (fstype == NULL || extn == NULL || strcmp(fstype, \"log\") == 0) continue;\n\t\t\tint extnlength = strlen(extn);\n\t\t\tif (extnlength != 3 && extnlength != 6) continue;\n\t\t\tif (extnlength >= 3 && strncmp(extn, \"win\", 3) != 0) continue;\n\t\t\t//if (extnlength == 6 && strncmp(extn, \"win000\", 6) != 0) continue;\n\n\t\t\tif (check_encryption) {\n\t\t\t\tstring filename = Restore_Name + \"/\";\n\t\t\t\tfilename += de->d_name;\n\t\t\t\tif (TWFunc::Get_File_Type(filename) == 2) {\n\t\t\t\t\tLOGINFO(\"'%s' is encrypted\\n\", filename.c_str());\n\t\t\t\t\tDataManager::SetValue(\"tw_restore_encrypted\", 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (extnlength == 6 && strncmp(extn, \"win000\", 6) != 0) continue;\n\n\t\t\tTWPartition* Part = Find_Partition_By_Path(label);\n\t\t\tif (Part == NULL)\n\t\t\t{\n\t\t\t\tgui_msg(Msg(msg::kError, \"unable_locate_part_backup_name=Unable to locate partition by backup name: '{1}'\")(label));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPart->Backup_FileName = de->d_name;\n\t\t\tif (strlen(extn) > 3) {\n\t\t\t\tPart->Backup_FileName.resize(Part->Backup_FileName.size() - strlen(extn) + 3);\n\t\t\t}\n\n\t\t\tif (!Part->Is_SubPartition)\n\t\t\t\tRestore_List += Part->Backup_Path + \";\";\n\t\t}\n\t\tclosedir(d);\n\t}\n\n\tif (adbbackup) {\n\t\tRestore_List = \"ADB_Backup;\";\n\t\tadbbackup = false;\n\t}\n\n\t// Set the final value\n\tDataManager::SetValue(\"tw_restore_list\", Restore_List);\n\tDataManager::SetValue(\"tw_restore_selected\", Restore_List);\n\treturn;\n}\n\nint TWPartitionManager::Wipe_By_Path(string Path) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tif (Path == \"/and-sec\")\n\t\t\t\tret = (*iter)->Wipe_AndSec();\n\t\t\telse\n\t\t\t\tret = (*iter)->Wipe();\n\t\t\tfound = true;\n\t\t} else if ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Local_Path) {\n\t\t\t(*iter)->Wipe();\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Local_Path));\n\treturn false;\n}\n\nint TWPartitionManager::Wipe_By_Path(string Path, string New_File_System) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tif (Path == \"/and-sec\")\n\t\t\t\tret = (*iter)->Wipe_AndSec();\n\t\t\telse\n\t\t\t\tret = (*iter)->Wipe(New_File_System);\n\t\t\tfound = true;\n\t\t} else if ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Local_Path) {\n\t\t\t(*iter)->Wipe(New_File_System);\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Local_Path));\n\treturn false;\n}\n\nint TWPartitionManager::Factory_Reset(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = true;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Wipe_During_Factory_Reset && (*iter)->Is_Present) {\n#ifdef TW_OEM_BUILD\n\t\t\tif ((*iter)->Mount_Point == \"/data\") {\n\t\t\t\tif (!(*iter)->Wipe_Encryption())\n\t\t\t\t\tret = false;\n\t\t\t} else {\n#endif\n\t\t\t\tif (!(*iter)->Wipe())\n\t\t\t\t\tret = false;\n#ifdef TW_OEM_BUILD\n\t\t\t}\n#endif\n\t\t} else if ((*iter)->Has_Android_Secure) {\n\t\t\tif (!(*iter)->Wipe_AndSec())\n\t\t\t\tret = false;\n\t\t}\n\t}\n\tTWFunc::check_and_run_script(\"/sbin/factoryreset.sh\", \"Factory Reset Script\");\n\treturn ret;\n}\n\nint TWPartitionManager::Wipe_Dalvik_Cache(void) {\n\tstruct stat st;\n\tvector <string> dir;\n\n\tif (!Mount_By_Path(\"/data\", true))\n\t\treturn false;\n\n\tdir.push_back(\"/data/dalvik-cache\");\n\tif (Mount_By_Path(\"/cache\", false)) {\n\t\tdir.push_back(\"/cache/dalvik-cache\");\n\t\tdir.push_back(\"/cache/dc\");\n\t}\n\n\tTWPartition* sdext = Find_Partition_By_Path(\"/sd-ext\");\n\tif (sdext && sdext->Is_Present && sdext->Mount(false))\n\t{\n\t\tif (stat(\"/sd-ext/dalvik-cache\", &st) == 0)\n\t\t{\n\t\t\tdir.push_back(\"/sd-ext/dalvik-cache\");\n\t\t}\n\t}\n\n\tgui_msg(\"wiping_dalvik=Wiping Dalvik Cache Directories...\");\n\tfor (unsigned i = 0; i < dir.size(); ++i) {\n\t\tif (stat(dir.at(i).c_str(), &st) == 0) {\n\t\t\tTWFunc::removeDir(dir.at(i), false);\n\t\t\tgui_msg(Msg(\"cleaned=Cleaned: {1}...\")(dir.at(i)));\n\t\t}\n\t}\n\tgui_msg(\"dalvik_done=-- Dalvik Cache Directories Wipe Complete!\");\n\treturn true;\n}\n\nint TWPartitionManager::Wipe_Rotate_Data(void) {\n\tif (!Mount_By_Path(\"/data\", true))\n\t\treturn false;\n\n\tunlink(\"/data/misc/akmd*\");\n\tunlink(\"/data/misc/rild*\");\n\tgui_print(\"Rotation data wiped.\\n\");\n\treturn true;\n}\n\nint TWPartitionManager::Wipe_Battery_Stats(void) {\n\tstruct stat st;\n\n\tif (!Mount_By_Path(\"/data\", true))\n\t\treturn false;\n\n\tif (0 != stat(\"/data/system/batterystats.bin\", &st)) {\n\t\tgui_print(\"No Battery Stats Found. No Need To Wipe.\\n\");\n\t} else {\n\t\tremove(\"/data/system/batterystats.bin\");\n\t\tgui_print(\"Cleared battery stats.\\n\");\n\t}\n\treturn true;\n}\n\nint TWPartitionManager::Wipe_Android_Secure(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Has_Android_Secure) {\n\t\t\tret = (*iter)->Wipe_AndSec();\n\t\t\tfound = true;\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else {\n\t\tgui_err(\"no_andsec=No android secure partitions found.\");\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::Format_Data(void) {\n\tTWPartition* dat = Find_Partition_By_Path(\"/data\");\n\n\tif (dat != NULL) {\n\t\tif (!dat->UnMount(true))\n\t\t\treturn false;\n\n\t\treturn dat->Wipe_Encryption();\n\t} else {\n\t\tgui_msg(Msg(msg::kError, \"unable_to_locate=Unable to locate {1}.\")(\"/data\"));\n\t\treturn false;\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::Wipe_Media_From_Data(void) {\n\tTWPartition* dat = Find_Partition_By_Path(\"/data\");\n\n\tif (dat != NULL) {\n\t\tif (!dat->Has_Data_Media) {\n\t\t\tLOGERR(\"This device does not have /data/media\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!dat->Mount(true))\n\t\t\treturn false;\n\n\t\tgui_msg(\"wiping_datamedia=Wiping internal storage -- /data/media...\");\n\t\tRemove_MTP_Storage(dat->MTP_Storage_ID);\n\t\tTWFunc::removeDir(\"/data/media\", false);\n\t\tdat->Recreate_Media_Folder();\n\t\tAdd_MTP_Storage(dat->MTP_Storage_ID);\n\t\treturn true;\n\t} else {\n\t\tgui_msg(Msg(msg::kError, \"unable_to_locate=Unable to locate {1}.\")(\"/data\"));\n\t\treturn false;\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::Repair_By_Path(string Path, bool Display_Error) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\tif (Local_Path == \"/tmp\" || Local_Path == \"/\")\n\t\treturn true;\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tret = (*iter)->Repair();\n\t\t\tfound = true;\n\t\t} else if ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Local_Path) {\n\t\t\t(*iter)->Repair();\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else if (Display_Error) {\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Local_Path));\n\t} else {\n\t\tLOGINFO(\"Repair: Unable to find partition for path '%s'\\n\", Local_Path.c_str());\n\t}\n\treturn false;\n}\n\nint TWPartitionManager::Resize_By_Path(string Path, bool Display_Error) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint ret = false;\n\tbool found = false;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\tif (Local_Path == \"/tmp\" || Local_Path == \"/\")\n\t\treturn true;\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tret = (*iter)->Resize();\n\t\t\tfound = true;\n\t\t} else if ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Local_Path) {\n\t\t\t(*iter)->Resize();\n\t\t}\n\t}\n\tif (found) {\n\t\treturn ret;\n\t} else if (Display_Error) {\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Local_Path));\n\t} else {\n\t\tLOGINFO(\"Resize: Unable to find partition for path '%s'\\n\", Local_Path.c_str());\n\t}\n\treturn false;\n}\n\nvoid TWPartitionManager::Update_System_Details(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tint data_size = 0;\n\n\tgui_msg(\"update_part_details=Updating partition details...\");\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t(*iter)->Update_Size(true);\n\t\tif ((*iter)->Can_Be_Mounted) {\n\t\t\tif ((*iter)->Mount_Point == \"/system\") {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_SYSTEM_SIZE, backup_display_size);\n\t\t\t} else if ((*iter)->Mount_Point == \"/data\" || (*iter)->Mount_Point == \"/datadata\") {\n\t\t\t\tdata_size += (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t} else if ((*iter)->Mount_Point == \"/cache\") {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_CACHE_SIZE, backup_display_size);\n\t\t\t} else if ((*iter)->Mount_Point == \"/sd-ext\") {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_SDEXT_SIZE, backup_display_size);\n\t\t\t\tif ((*iter)->Backup_Size == 0) {\n\t\t\t\t\tDataManager::SetValue(TW_HAS_SDEXT_PARTITION, 0);\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_SDEXT_VAR, 0);\n\t\t\t\t} else\n\t\t\t\t\tDataManager::SetValue(TW_HAS_SDEXT_PARTITION, 1);\n\t\t\t} else if ((*iter)->Has_Android_Secure) {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_ANDSEC_SIZE, backup_display_size);\n\t\t\t\tif ((*iter)->Backup_Size == 0) {\n\t\t\t\t\tDataManager::SetValue(TW_HAS_ANDROID_SECURE, 0);\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_ANDSEC_VAR, 0);\n\t\t\t\t} else\n\t\t\t\t\tDataManager::SetValue(TW_HAS_ANDROID_SECURE, 1);\n\t\t\t} else if ((*iter)->Mount_Point == \"/boot\") {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_BOOT_SIZE, backup_display_size);\n\t\t\t\tif ((*iter)->Backup_Size == 0) {\n\t\t\t\t\tDataManager::SetValue(\"tw_has_boot_partition\", 0);\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_BOOT_VAR, 0);\n\t\t\t\t} else\n\t\t\t\t\tDataManager::SetValue(\"tw_has_boot_partition\", 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Handle unmountable partitions in case we reset defaults\n\t\t\tif ((*iter)->Mount_Point == \"/boot\") {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_BOOT_SIZE, backup_display_size);\n\t\t\t\tif ((*iter)->Backup_Size == 0) {\n\t\t\t\t\tDataManager::SetValue(TW_HAS_BOOT_PARTITION, 0);\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_BOOT_VAR, 0);\n\t\t\t\t} else\n\t\t\t\t\tDataManager::SetValue(TW_HAS_BOOT_PARTITION, 1);\n\t\t\t} else if ((*iter)->Mount_Point == \"/recovery\") {\n\t\t\t\tint backup_display_size = (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t\tDataManager::SetValue(TW_BACKUP_RECOVERY_SIZE, backup_display_size);\n\t\t\t\tif ((*iter)->Backup_Size == 0) {\n\t\t\t\t\tDataManager::SetValue(TW_HAS_RECOVERY_PARTITION, 0);\n\t\t\t\t\tDataManager::SetValue(TW_BACKUP_RECOVERY_VAR, 0);\n\t\t\t\t} else\n\t\t\t\t\tDataManager::SetValue(TW_HAS_RECOVERY_PARTITION, 1);\n\t\t\t} else if ((*iter)->Mount_Point == \"/data\") {\n\t\t\t\tdata_size += (int)((*iter)->Backup_Size / 1048576LLU);\n\t\t\t}\n\t\t}\n\t}\n\tgui_msg(\"update_part_details_done=...done\");\n\tDataManager::SetValue(TW_BACKUP_DATA_SIZE, data_size);\n\tstring current_storage_path = DataManager::GetCurrentStoragePath();\n\tTWPartition* FreeStorage = Find_Partition_By_Path(current_storage_path);\n\tif (FreeStorage != NULL) {\n\t\t// Attempt to mount storage\n\t\tif (!FreeStorage->Mount(false)) {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_mount_storage=Unable to mount storage\"));\n\t\t\tDataManager::SetValue(TW_STORAGE_FREE_SIZE, 0);\n\t\t} else {\n\t\t\tDataManager::SetValue(TW_STORAGE_FREE_SIZE, (int)(FreeStorage->Free / 1048576LLU));\n\t\t}\n\t} else {\n\t\tLOGINFO(\"Unable to find storage partition '%s'.\\n\", current_storage_path.c_str());\n\t}\n\tif (!Write_Fstab())\n\t\tLOGERR(\"Error creating fstab\\n\");\n\treturn;\n}\n\nvoid TWPartitionManager::Post_Decrypt(const string& Block_Device) {\n\tTWPartition* dat = Find_Partition_By_Path(\"/data\");\n\tif (dat != NULL) {\n\t\tDataManager::SetValue(TW_IS_DECRYPTED, 1);\n\t\tdat->Is_Decrypted = true;\n\t\tif (!Block_Device.empty()) {\n\t\t\tdat->Decrypted_Block_Device = Block_Device;\n\t\t\tgui_msg(Msg(\"decrypt_success_dev=Data successfully decrypted, new block device: '{1}'\")(Block_Device));\n\t\t} else {\n\t\t\tgui_msg(\"decrypt_success_nodev=Data successfully decrypted\");\n\t\t}\n\t\tdat->Setup_File_System(false);\n\t\tdat->Current_File_System = dat->Fstab_File_System; // Needed if we're ignoring blkid because encrypted devices start out as emmc\n\n\t\t// Sleep for a bit so that the device will be ready\n\t\tsleep(1);\n\t\tif (dat->Has_Data_Media && dat->Mount(false) && TWFunc::Path_Exists(\"/data/media/0\")) {\n\t\t\tdat->Storage_Path = \"/data/media/0\";\n\t\t\tdat->Symlink_Path = dat->Storage_Path;\n\t\t\tDataManager::SetValue(\"tw_storage_path\", \"/data/media/0\");\n\t\t\tDataManager::SetValue(\"tw_settings_path\", \"/data/media/0\");\n\t\t\tdat->UnMount(false);\n\t\t}\n\t\tUpdate_System_Details();\n\t\tOutput_Partition(dat);\n\t\tUnMount_Main_Partitions();\n\t} else\n\t\tLOGERR(\"Unable to locate data partition.\\n\");\n}\n\nint TWPartitionManager::Decrypt_Device(string Password) {\n#ifdef TW_INCLUDE_CRYPTO\n\tchar crypto_state[PROPERTY_VALUE_MAX], crypto_blkdev[PROPERTY_VALUE_MAX];\n\tstd::vector<TWPartition*>::iterator iter;\n\n\t// Mount any partitions that need to be mounted for decrypt\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_To_Decrypt) {\n\t\t\t(*iter)->Mount(true);\n\t\t}\n\t}\n\tproperty_set(\"twrp.mount_to_decrypt\", \"1\");\n\n\tproperty_get(\"ro.crypto.state\", crypto_state, \"error\");\n\tif (strcmp(crypto_state, \"error\") == 0) {\n\t\tproperty_set(\"ro.crypto.state\", \"encrypted\");\n\t\t// Sleep for a bit so that services can start if needed\n\t\tsleep(1);\n\t}\n\n\tif (DataManager::GetIntValue(TW_IS_FBE)) {\n#ifdef TW_INCLUDE_FBE\n\t\tif (!Mount_By_Path(\"/data\", true)) // /data has to be mounted for FBE\n\t\t\treturn -1;\n\t\tint retry_count = 10;\n\t\twhile (!TWFunc::Path_Exists(\"/data/system/users/gatekeeper.password.key\") && --retry_count)\n\t\t\tusleep(2000); // A small sleep is needed after mounting /data to ensure reliable decrypt... maybe because of DE?\n\t\tint user_id = DataManager::GetIntValue(\"tw_decrypt_user_id\");\n\t\tLOGINFO(\"Decrypting FBE for user %i\\n\", user_id);\n\t\tif (Decrypt_User(user_id, Password)) {\n\t\t\tPost_Decrypt(\"\");\n\t\t\treturn 0;\n\t\t}\n#else\n\t\tLOGERR(\"FBE support is not present\\n\");\n#endif\n\t\treturn -1;\n\t}\n\n\tint pwret = -1;\n\tpid_t pid = fork();\n\tif (pid < 0) {\n\t\tLOGERR(\"fork failed\\n\");\n\t\treturn -1;\n\t} else if (pid == 0) {\n\t\t// Child process\n\t\tchar cPassword[255];\n\t\tstrcpy(cPassword, Password.c_str());\n\t\tint ret = cryptfs_check_passwd(cPassword);\n\t\texit(ret);\n\t} else {\n\t\t// Parent\n\t\tint status;\n\t\tif (TWFunc::Wait_For_Child_Timeout(pid, &status, \"Decrypt\", 30))\n\t\t\tpwret = -1;\n\t\telse\n\t\t\tpwret = WEXITSTATUS(status) ? -1 : 0;\n\t}\n\n#ifdef TW_CRYPTO_USE_SYSTEM_VOLD\n\tif (pwret != 0) {\n\t\tpwret = vold_decrypt(Password);\n\t\tswitch (pwret) {\n\t\t\tcase VD_SUCCESS:\n\t\t\t\tbreak;\n\t\t\tcase VD_ERR_MISSING_VDC:\n\t\t\t\tgui_msg(Msg(msg::kError, \"decrypt_data_vold_os_missing=Missing files needed for vold decrypt: {1}\")(\"/system/bin/vdc\"));\n\t\t\t\tbreak;\n\t\t\tcase VD_ERR_MISSING_VOLD:\n\t\t\t\tgui_msg(Msg(msg::kError, \"decrypt_data_vold_os_missing=Missing files needed for vold decrypt: {1}\")(\"/system/bin/vold\"));\n\t\t\t\tbreak;\n\t\t}\n\t}\n#endif // TW_CRYPTO_USE_SYSTEM_VOLD\n\n\t// Unmount any partitions that were needed for decrypt\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_To_Decrypt) {\n\t\t\t(*iter)->UnMount(false);\n\t\t}\n\t}\n\tproperty_set(\"twrp.mount_to_decrypt\", \"0\");\n\n\tif (pwret != 0) {\n\t\tgui_err(\"fail_decrypt=Failed to decrypt data.\");\n\t\treturn -1;\n\t}\n\n\tproperty_get(\"ro.crypto.fs_crypto_blkdev\", crypto_blkdev, \"error\");\n\tif (strcmp(crypto_blkdev, \"error\") == 0) {\n\t\tLOGERR(\"Error retrieving decrypted data block device.\\n\");\n\t} else {\n\t\tPost_Decrypt(crypto_blkdev);\n\t}\n\treturn 0;\n#else\n\tgui_err(\"no_crypto_support=No crypto support was compiled into this build.\");\n\treturn -1;\n#endif\n\treturn 1;\n}\n\nint TWPartitionManager::Fix_Contexts(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Has_Data_Media) {\n\t\t\tif ((*iter)->Mount(true)) {\n\t\t\t\tif (fixContexts::fixDataMediaContexts((*iter)->Mount_Point) != 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tUnMount_Main_Partitions();\n\tgui_msg(\"done=Done.\");\n\treturn 0;\n}\n\nTWPartition* TWPartitionManager::Find_Next_Storage(string Path, bool Exclude_Data_Media) {\n\tstd::vector<TWPartition*>::iterator iter = Partitions.begin();\n\n\tif (!Path.empty()) {\n\t\tstring Search_Path = TWFunc::Get_Root_Path(Path);\n\t\tfor (; iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Mount_Point == Search_Path) {\n\t\t\t\titer++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (; iter != Partitions.end(); iter++) {\n\t\tif (Exclude_Data_Media && (*iter)->Has_Data_Media) {\n\t\t\t// do nothing, do not return this type of partition\n\t\t} else if ((*iter)->Is_Storage && (*iter)->Is_Present) {\n\t\t\treturn (*iter);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint TWPartitionManager::Open_Lun_File(string Partition_Path, string Lun_File) {\n\tTWPartition* Part = Find_Partition_By_Path(Partition_Path);\n\n\tif (Part == NULL) {\n\t\tLOGINFO(\"Unable to locate '%s' for USB storage mode.\", Partition_Path.c_str());\n\t\tgui_msg(Msg(msg::kError, \"unable_find_part_path=Unable to find partition for path '{1}'\")(Partition_Path));\n\t\treturn false;\n\t}\n\tLOGINFO(\"USB mount '%s', '%s' > '%s'\\n\", Partition_Path.c_str(), Part->Actual_Block_Device.c_str(), Lun_File.c_str());\n\tif (!Part->UnMount(true) || !Part->Is_Present)\n\t\treturn false;\n\n\tif (TWFunc::write_to_file(Lun_File, Part->Actual_Block_Device)) {\n\t\tLOGERR(\"Unable to write to ums lunfile '%s': (%s)\\n\", Lun_File.c_str(), strerror(errno));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint TWPartitionManager::usb_storage_enable(void) {\n\tchar lun_file[255];\n\tbool has_multiple_lun = false;\n\n\tstring Lun_File_str = CUSTOM_LUN_FILE;\n\tsize_t found = Lun_File_str.find(\"%\");\n\tif (found != string::npos) {\n\t\tsprintf(lun_file, CUSTOM_LUN_FILE, 1);\n\t\tif (TWFunc::Path_Exists(lun_file))\n\t\t\thas_multiple_lun = true;\n\t}\n\tmtp_was_enabled = TWFunc::Toggle_MTP(false); // Must disable MTP for USB Storage\n\tif (!has_multiple_lun) {\n\t\tLOGINFO(\"Device doesn't have multiple lun files, mount current storage\\n\");\n\t\tsprintf(lun_file, CUSTOM_LUN_FILE, 0);\n\t\tif (TWFunc::Get_Root_Path(DataManager::GetCurrentStoragePath()) == \"/data\") {\n\t\t\tTWPartition* Mount = Find_Next_Storage(\"\", true);\n\t\t\tif (Mount) {\n\t\t\t\tif (!Open_Lun_File(Mount->Mount_Point, lun_file)) {\n\t\t\t\t\tgoto error_handle;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgui_err(\"unable_locate_storage=Unable to locate storage device.\");\n\t\t\t\tgoto error_handle;\n\t\t\t}\n\t\t} else if (!Open_Lun_File(DataManager::GetCurrentStoragePath(), lun_file)) {\n\t\t\tgoto error_handle;\n\t\t}\n\t} else {\n\t\tLOGINFO(\"Device has multiple lun files\\n\");\n\t\tTWPartition* Mount1;\n\t\tTWPartition* Mount2;\n\t\tsprintf(lun_file, CUSTOM_LUN_FILE, 0);\n\t\tMount1 = Find_Next_Storage(\"\", true);\n\t\tif (Mount1) {\n\t\t\tif (!Open_Lun_File(Mount1->Mount_Point, lun_file)) {\n\t\t\t\tgoto error_handle;\n\t\t\t}\n\t\t\tsprintf(lun_file, CUSTOM_LUN_FILE, 1);\n\t\t\tMount2 = Find_Next_Storage(Mount1->Mount_Point, true);\n\t\t\tif (Mount2 && Mount2->Mount_Point != Mount1->Mount_Point) {\n\t\t\t\tOpen_Lun_File(Mount2->Mount_Point, lun_file);\n\t\t\t}\n\t\t} else {\n\t\t\tgui_err(\"unable_locate_storage=Unable to locate storage device.\");\n\t\t\tgoto error_handle;\n\t\t}\n\t}\n\tproperty_set(\"sys.storage.ums_enabled\", \"1\");\n\tproperty_set(\"sys.usb.config\", \"mass_storage,adb\");\n\treturn true;\nerror_handle:\n\tif (mtp_was_enabled)\n\t\tif (!Enable_MTP())\n\t\t\tDisable_MTP();\n\treturn false;\n}\n\nint TWPartitionManager::usb_storage_disable(void) {\n\tint index, ret;\n\tchar lun_file[255], ch[2] = {0, 0};\n\tstring str = ch;\n\n\tfor (index=0; index<2; index++) {\n\t\tsprintf(lun_file, CUSTOM_LUN_FILE, index);\n\t\tret = TWFunc::write_to_file(lun_file, str);\n\t\tif (ret < 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tMount_All_Storage();\n\tUpdate_System_Details();\n\tUnMount_Main_Partitions();\n\tproperty_set(\"sys.storage.ums_enabled\", \"0\");\n\tproperty_set(\"sys.usb.config\", \"adb\");\n\tif (mtp_was_enabled)\n\t\tif (!Enable_MTP())\n\t\t\tDisable_MTP();\n\tif (ret < 0 && index == 0) {\n\t\tLOGERR(\"Unable to write to ums lunfile '%s'.\", lun_file);\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n\treturn true;\n}\n\nvoid TWPartitionManager::Mount_All_Storage(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Is_Storage)\n\t\t\t(*iter)->Mount(false);\n\t}\n}\n\nvoid TWPartitionManager::UnMount_Main_Partitions(void) {\n\t// Unmounts system and data if data is not data/media\n\t// Also unmounts boot if boot is mountable\n\tLOGINFO(\"Unmounting main partitions...\\n\");\n\n\tTWPartition* Boot_Partition = Find_Partition_By_Path(\"/boot\");\n\n\tUnMount_By_Path(\"/system\", true);\n\tif (!datamedia)\n\t\tUnMount_By_Path(\"/data\", true);\n\n\tif (Boot_Partition != NULL && Boot_Partition->Can_Be_Mounted)\n\t\tBoot_Partition->UnMount(true);\n}\n\nint TWPartitionManager::Partition_SDCard(void) {\n\tchar temp[255];\n\tstring Storage_Path, Command, Device, fat_str, ext_str, start_loc, end_loc, ext_format, sd_path, tmpdevice;\n\tint ext, swap, total_size = 0, fat_size;\n\n\tgui_msg(\"start_partition_sd=Partitioning SD Card...\");\n\n\t// Locate and validate device to partition\n\tTWPartition* SDCard = Find_Partition_By_Path(DataManager::GetCurrentStoragePath());\n\n\tif (SDCard->Is_Adopted_Storage)\n\t\tSDCard->Revert_Adopted();\n\n\tif (SDCard == NULL || !SDCard->Removable || SDCard->Has_Data_Media) {\n\t\tgui_err(\"partition_sd_locate=Unable to locate device to partition.\");\n\t\treturn false;\n\t}\n\n\t// Unmount everything\n\tif (!SDCard->UnMount(true))\n\t\treturn false;\n\tTWPartition* SDext = Find_Partition_By_Path(\"/sd-ext\");\n\tif (SDext != NULL) {\n\t\tif (!SDext->UnMount(true))\n\t\t\treturn false;\n\t}\n\tchar* swappath = getenv(\"SWAPPATH\");\n\tif (swappath != NULL) {\n\t\tLOGINFO(\"Unmounting swap at '%s'\\n\", swappath);\n\t\tumount(swappath);\n\t}\n\n\t// Determine block device\n\tif (SDCard->Alternate_Block_Device.empty()) {\n\t\tSDCard->Find_Actual_Block_Device();\n\t\tDevice = SDCard->Actual_Block_Device;\n\t\t// Just use the root block device\n\t\tDevice.resize(strlen(\"/dev/block/mmcblkX\"));\n\t} else {\n\t\tDevice = SDCard->Alternate_Block_Device;\n\t}\n\n\t// Find the size of the block device:\n\ttotal_size = (int)(TWFunc::IOCTL_Get_Block_Size(Device.c_str()) / (1048576));\n\n\tDataManager::GetValue(\"tw_sdext_size\", ext);\n\tDataManager::GetValue(\"tw_swap_size\", swap);\n\tDataManager::GetValue(\"tw_sdpart_file_system\", ext_format);\n\tfat_size = total_size - ext - swap;\n\tLOGINFO(\"sd card mount point %s block device is '%s', sdcard size is: %iMB, fat size: %iMB, ext size: %iMB, ext system: '%s', swap size: %iMB\\n\", DataManager::GetCurrentStoragePath().c_str(), Device.c_str(), total_size, fat_size, ext, ext_format.c_str(), swap);\n\n\t// Determine partition sizes\n\tif (swap == 0 && ext == 0) {\n\t\tfat_str = \"-0\";\n\t} else {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tsprintf(temp, \"%i\", fat_size);\n\t\tfat_str = temp;\n\t\tfat_str += \"MB\";\n\t}\n\tif (swap == 0) {\n\t\text_str = \"-0\";\n\t} else {\n\t\tmemset(temp, 0, sizeof(temp));\n\t\tsprintf(temp, \"%i\", ext);\n\t\text_str = \"+\";\n\t\text_str += temp;\n\t\text_str += \"MB\";\n\t}\n\n\tif (ext + swap > total_size) {\n\t\tgui_err(\"ext_swap_size=EXT + Swap size is larger than sdcard size.\");\n\t\treturn false;\n\t}\n\n\tgui_msg(\"remove_part_table=Removing partition table...\");\n\tCommand = \"sgdisk --zap-all \" + Device;\n\tLOGINFO(\"Command is: '%s'\\n\", Command.c_str());\n\tif (TWFunc::Exec_Cmd(Command) != 0) {\n\t\tgui_err(\"unable_rm_part=Unable to remove partition table.\");\n\t\tUpdate_System_Details();\n\t\treturn false;\n\t}\n\tgui_msg(Msg(\"create_part=Creating {1} partition...\")(\"FAT32\"));\n\tCommand = \"sgdisk  --new=0:0:\" + fat_str + \" --change-name=0:\\\"Microsoft basic data\\\" --typecode=0:EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 \" + Device;\n\tLOGINFO(\"Command is: '%s'\\n\", Command.c_str());\n\tif (TWFunc::Exec_Cmd(Command) != 0) {\n\t\tgui_msg(Msg(msg::kError, \"unable_to_create_part=Unable to create {1} partition.\")(\"FAT32\"));\n\t\treturn false;\n\t}\n\tif (ext > 0) {\n\t\tgui_msg(Msg(\"create_part=Creating {1} partition...\")(\"EXT\"));\n\t\tCommand = \"sgdisk --new=0:0:\" + ext_str + \" --change-name=0:\\\"Linux filesystem\\\" \" + Device;\n\t\tLOGINFO(\"Command is: '%s'\\n\", Command.c_str());\n\t\tif (TWFunc::Exec_Cmd(Command) != 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_create_part=Unable to create {1} partition.\")(\"EXT\"));\n\t\t\tUpdate_System_Details();\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (swap > 0) {\n\t\tgui_msg(Msg(\"create_part=Creating {1} partition...\")(\"swap\"));\n\t\tCommand = \"sgdisk --new=0:0:-0 --change-name=0:\\\"Linux swap\\\" --typecode=0:0657FD6D-A4AB-43C4-84E5-0933C84B4F4F \" + Device;\n\t\tLOGINFO(\"Command is: '%s'\\n\", Command.c_str());\n\t\tif (TWFunc::Exec_Cmd(Command) != 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_create_part=Unable to create {1} partition.\")(\"swap\"));\n\t\t\tUpdate_System_Details();\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Convert GPT to MBR\n\tCommand = \"sgdisk --gpttombr \" + Device;\n\tif (TWFunc::Exec_Cmd(Command) != 0)\n\t\tLOGINFO(\"Failed to covert partition GPT to MBR\\n\");\n\n\t// Tell the kernel to rescan the partition table\n\tint fd = open(Device.c_str(), O_RDONLY);\n\tioctl(fd, BLKRRPART, 0);\n\tclose(fd);\n\n\tstring format_device = Device;\n\tif (Device.substr(0, 17) == \"/dev/block/mmcblk\")\n\t\tformat_device += \"p\";\n\n\t// Format new partitions to proper file system\n\tif (fat_size > 0) {\n\t\tCommand = \"mkfs.fat \" + format_device + \"1\";\n\t\tTWFunc::Exec_Cmd(Command);\n\t}\n\tif (ext > 0) {\n\t\tif (SDext == NULL) {\n\t\t\tCommand = \"mke2fs -t \" + ext_format + \" -m 0 \" + format_device + \"2\";\n\t\t\tgui_msg(Msg(\"format_sdext_as=Formatting sd-ext as {1}...\")(ext_format));\n\t\t\tLOGINFO(\"Formatting sd-ext after partitioning, command: '%s'\\n\", Command.c_str());\n\t\t\tTWFunc::Exec_Cmd(Command);\n\t\t} else {\n\t\t\tSDext->Wipe(ext_format);\n\t\t}\n\t}\n\tif (swap > 0) {\n\t\tCommand = \"mkswap \" + format_device;\n\t\tif (ext > 0)\n\t\t\tCommand += \"3\";\n\t\telse\n\t\t\tCommand += \"2\";\n\t\tTWFunc::Exec_Cmd(Command);\n\t}\n\n\t// recreate TWRP folder and rewrite settings - these will be gone after sdcard is partitioned\n\tif (SDCard->Mount(true)) {\n\t\tstring TWRP_Folder = SDCard->Mount_Point + \"/TWRP\";\n\t\tmkdir(TWRP_Folder.c_str(), 0777);\n\t\tDataManager::Flush();\n\t}\n\n\tUpdate_System_Details();\n\tgui_msg(\"part_complete=Partitioning complete.\");\n\treturn true;\n}\n\nvoid TWPartitionManager::Get_Partition_List(string ListType, std::vector<PartitionList> *Partition_List) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tif (ListType == \"mount\") {\n\t\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Can_Be_Mounted) {\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tpart.Display_Name = (*iter)->Display_Name;\n\t\t\t\tpart.Mount_Point = (*iter)->Mount_Point;\n\t\t\t\tpart.selected = (*iter)->Is_Mounted();\n\t\t\t\tPartition_List->push_back(part);\n\t\t\t}\n\t\t}\n\t} else if (ListType == \"storage\") {\n\t\tchar free_space[255];\n\t\tstring Current_Storage = DataManager::GetCurrentStoragePath();\n\t\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Is_Storage) {\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tsprintf(free_space, \"%llu\", (*iter)->Free / 1024 / 1024);\n\t\t\t\tpart.Display_Name = (*iter)->Storage_Name + \" (\";\n\t\t\t\tpart.Display_Name += free_space;\n\t\t\t\tpart.Display_Name += \"MB)\";\n\t\t\t\tpart.Mount_Point = (*iter)->Storage_Path;\n\t\t\t\tif ((*iter)->Storage_Path == Current_Storage)\n\t\t\t\t\tpart.selected = 1;\n\t\t\t\telse\n\t\t\t\t\tpart.selected = 0;\n\t\t\t\tPartition_List->push_back(part);\n\t\t\t}\n\t\t}\n\t} else if (ListType == \"backup\") {\n\t\tchar backup_size[255];\n\t\tunsigned long long Backup_Size;\n\t\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Can_Be_Backed_Up && !(*iter)->Is_SubPartition && (*iter)->Is_Present) {\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tBackup_Size = (*iter)->Backup_Size;\n\t\t\t\tif ((*iter)->Has_SubPartition) {\n\t\t\t\t\tstd::vector<TWPartition*>::iterator subpart;\n\n\t\t\t\t\tfor (subpart = Partitions.begin(); subpart != Partitions.end(); subpart++) {\n\t\t\t\t\t\tif ((*subpart)->Is_SubPartition && (*subpart)->Can_Be_Backed_Up && (*subpart)->Is_Present && (*subpart)->SubPartition_Of == (*iter)->Mount_Point)\n\t\t\t\t\t\t\tBackup_Size += (*subpart)->Backup_Size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprintf(backup_size, \"%llu\", Backup_Size / 1024 / 1024);\n\t\t\t\tpart.Display_Name = (*iter)->Backup_Display_Name + \" (\";\n\t\t\t\tpart.Display_Name += backup_size;\n\t\t\t\tpart.Display_Name += \"MB)\";\n\t\t\t\tpart.Mount_Point = (*iter)->Backup_Path;\n\t\t\t\tpart.selected = 0;\n\t\t\t\tPartition_List->push_back(part);\n\t\t\t}\n\t\t}\n\t} else if (ListType == \"restore\") {\n\t\tstring Restore_List, restore_path;\n\t\tTWPartition* restore_part = NULL;\n\n\t\tDataManager::GetValue(\"tw_restore_list\", Restore_List);\n\t\tif (!Restore_List.empty()) {\n\t\t\tsize_t start_pos = 0, end_pos = Restore_List.find(\";\", start_pos);\n\t\t\twhile (end_pos != string::npos && start_pos < Restore_List.size()) {\n\t\t\t\trestore_path = Restore_List.substr(start_pos, end_pos - start_pos);\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tif (restore_path.compare(\"ADB_Backup\") == 0) {\n\t\t\t\t\tpart.Display_Name = \"ADB Backup\";\n\t\t\t\t\tpart.Mount_Point = \"ADB Backup\";\n\t\t\t\t\tpart.selected = 1;\n\t\t\t\t\tPartition_List->push_back(part);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((restore_part = Find_Partition_By_Path(restore_path)) != NULL) {\n\t\t\t\t\tif ((restore_part->Backup_Name == \"recovery\" && !restore_part->Can_Be_Backed_Up) || restore_part->Is_SubPartition) {\n\t\t\t\t\t\t// Don't allow restore of recovery (causes problems on some devices)\n\t\t\t\t\t\t// Don't add subpartitions to the list of items\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpart.Display_Name = restore_part->Backup_Display_Name;\n\t\t\t\t\t\tpart.Mount_Point = restore_part->Backup_Path;\n\t\t\t\t\t\tpart.selected = 1;\n\t\t\t\t\t\tPartition_List->push_back(part);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgui_msg(Msg(msg::kError, \"restore_unable_locate=Unable to locate '{1}' partition for restoring.\")(restore_path));\n\t\t\t\t}\n\t\t\t\tstart_pos = end_pos + 1;\n\t\t\t\tend_pos = Restore_List.find(\";\", start_pos);\n\t\t\t}\n\t\t}\n\t} else if (ListType == \"wipe\") {\n\t\tstruct PartitionList dalvik;\n\t\tdalvik.Display_Name = gui_parse_text(\"{@dalvik}\");\n\t\tdalvik.Mount_Point = \"DALVIK\";\n\t\tdalvik.selected = 0;\n\t\tPartition_List->push_back(dalvik);\n\t\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Wipe_Available_in_GUI && !(*iter)->Is_SubPartition) {\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tpart.Display_Name = (*iter)->Display_Name;\n\t\t\t\tpart.Mount_Point = (*iter)->Mount_Point;\n\t\t\t\tpart.selected = 0;\n\t\t\t\tPartition_List->push_back(part);\n\t\t\t}\n\t\t\tif ((*iter)->Has_Android_Secure) {\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tpart.Display_Name = (*iter)->Backup_Display_Name;\n\t\t\t\tpart.Mount_Point = (*iter)->Backup_Path;\n\t\t\t\tpart.selected = 0;\n\t\t\t\tPartition_List->push_back(part);\n\t\t\t}\n\t\t\tif ((*iter)->Has_Data_Media) {\n\t\t\t\tstruct PartitionList datamedia;\n\t\t\t\tdatamedia.Display_Name = (*iter)->Storage_Name;\n\t\t\t\tdatamedia.Mount_Point = \"INTERNAL\";\n\t\t\t\tdatamedia.selected = 0;\n\t\t\t\tPartition_List->push_back(datamedia);\n\t\t\t}\n\t\t}\n\t} else if (ListType == \"flashimg\") {\n\t\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\t\tif ((*iter)->Can_Flash_Img && (*iter)->Is_Present) {\n\t\t\t\tstruct PartitionList part;\n\t\t\t\tpart.Display_Name = (*iter)->Backup_Display_Name;\n\t\t\t\tpart.Mount_Point = (*iter)->Backup_Path;\n\t\t\t\tpart.selected = 0;\n\t\t\t\tPartition_List->push_back(part);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tLOGERR(\"Unknown list type '%s' requested for TWPartitionManager::Get_Partition_List\\n\", ListType.c_str());\n\t}\n}\n\nint TWPartitionManager::Fstab_Processed(void) {\n\treturn Partitions.size();\n}\n\nvoid TWPartitionManager::Output_Storage_Fstab(void) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tchar storage_partition[255];\n\tstring Temp;\n\tFILE *fp = fopen(\"/cache/recovery/storage.fstab\", \"w\");\n\n\tif (fp == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"unable_to_open=Unable to open '{1}'.\")(\"/cache/recovery/storage.fstab\"));\n\t\treturn;\n\t}\n\n\t// Iterate through all partitions\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Is_Storage) {\n\t\t\tTemp = (*iter)->Storage_Path + \";\" + (*iter)->Storage_Name + \";\\n\";\n\t\t\tstrcpy(storage_partition, Temp.c_str());\n\t\t\tfwrite(storage_partition, sizeof(storage_partition[0]), strlen(storage_partition) / sizeof(storage_partition[0]), fp);\n\t\t}\n\t}\n\tfclose(fp);\n}\n\nTWPartition *TWPartitionManager::Get_Default_Storage_Partition()\n{\n\tTWPartition *res = NULL;\n\tfor (std::vector<TWPartition*>::iterator iter = Partitions.begin(); iter != Partitions.end(); ++iter) {\n\t\tif (!(*iter)->Is_Storage)\n\t\t\tcontinue;\n\n\t\tif ((*iter)->Is_Settings_Storage)\n\t\t\treturn *iter;\n\n\t\tif (!res)\n\t\t\tres = *iter;\n\t}\n\treturn res;\n}\n\nbool TWPartitionManager::Enable_MTP(void) {\n#ifdef TW_HAS_MTP\n\tif (mtppid) {\n\t\tgui_err(\"mtp_already_enabled=MTP already enabled\");\n\t\treturn true;\n\t}\n\n\tint mtppipe[2];\n\n\tif (pipe(mtppipe) < 0) {\n\t\tLOGERR(\"Error creating MTP pipe\\n\");\n\t\treturn false;\n\t}\n\n\tchar old_value[PROPERTY_VALUE_MAX];\n\tproperty_get(\"sys.usb.config\", old_value, \"\");\n\tif (strcmp(old_value, \"mtp,adb\") != 0) {\n\t\tchar vendor[PROPERTY_VALUE_MAX];\n\t\tchar product[PROPERTY_VALUE_MAX];\n\t\tproperty_set(\"sys.usb.config\", \"none\");\n\t\tproperty_get(\"usb.vendor\", vendor, \"18D1\");\n\t\tproperty_get(\"usb.product.mtpadb\", product, \"4EE2\");\n\t\tstring vendorstr = vendor;\n\t\tstring productstr = product;\n\t\tTWFunc::write_to_file(\"/sys/class/android_usb/android0/idVendor\", vendorstr);\n\t\tTWFunc::write_to_file(\"/sys/class/android_usb/android0/idProduct\", productstr);\n\t\tproperty_set(\"sys.usb.config\", \"mtp,adb\");\n\t}\n\t/* To enable MTP debug, use the twrp command line feature:\n\t * twrp set tw_mtp_debug 1\n\t */\n\ttwrpMtp *mtp = new twrpMtp(DataManager::GetIntValue(\"tw_mtp_debug\"));\n\tmtppid = mtp->forkserver(mtppipe);\n\tif (mtppid) {\n\t\tclose(mtppipe[0]); // Host closes read side\n\t\tmtp_write_fd = mtppipe[1];\n\t\tDataManager::SetValue(\"tw_mtp_enabled\", 1);\n\t\tAdd_All_MTP_Storage();\n\t\treturn true;\n\t} else {\n\t\tclose(mtppipe[0]);\n\t\tclose(mtppipe[1]);\n\t\tgui_err(\"mtp_fail=Failed to enable MTP\");\n\t\treturn false;\n\t}\n#else\n\tgui_err(\"no_mtp=MTP support not included\");\n#endif\n\tDataManager::SetValue(\"tw_mtp_enabled\", 0);\n\treturn false;\n}\n\nvoid TWPartitionManager::Add_All_MTP_Storage(void) {\n#ifdef TW_HAS_MTP\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tif (!mtppid)\n\t\treturn; // MTP is not enabled\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Is_Storage && (*iter)->Is_Present && (*iter)->Mount(false))\n\t\t\tAdd_Remove_MTP_Storage((*iter), MTP_MESSAGE_ADD_STORAGE);\n\t}\n#else\n\treturn;\n#endif\n}\n\nbool TWPartitionManager::Disable_MTP(void) {\n\tchar old_value[PROPERTY_VALUE_MAX];\n\tproperty_get(\"sys.usb.config\", old_value, \"\");\n\tif (strcmp(old_value, \"adb\") != 0) {\n\t\tchar vendor[PROPERTY_VALUE_MAX];\n\t\tchar product[PROPERTY_VALUE_MAX];\n\t\tproperty_set(\"sys.usb.config\", \"none\");\n\t\tproperty_get(\"usb.vendor\", vendor, \"18D1\");\n\t\tproperty_get(\"usb.product.adb\", product, \"D001\");\n\t\tstring vendorstr = vendor;\n\t\tstring productstr = product;\n\t\tTWFunc::write_to_file(\"/sys/class/android_usb/android0/idVendor\", vendorstr);\n\t\tTWFunc::write_to_file(\"/sys/class/android_usb/android0/idProduct\", productstr);\n\t\tusleep(2000);\n\t}\n#ifdef TW_HAS_MTP\n\tif (mtppid) {\n\t\tLOGINFO(\"Disabling MTP\\n\");\n\t\tint status;\n\t\tkill(mtppid, SIGKILL);\n\t\tmtppid = 0;\n\t\t// We don't care about the exit value, but this prevents a zombie process\n\t\twaitpid(mtppid, &status, 0);\n\t\tclose(mtp_write_fd);\n\t\tmtp_write_fd = -1;\n\t}\n#endif\n\tproperty_set(\"sys.usb.config\", \"adb\");\n#ifdef TW_HAS_MTP\n\tDataManager::SetValue(\"tw_mtp_enabled\", 0);\n\treturn true;\n#endif\n\treturn false;\n}\n\nTWPartition* TWPartitionManager::Find_Partition_By_MTP_Storage_ID(unsigned int Storage_ID) {\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->MTP_Storage_ID == Storage_ID)\n\t\t\treturn (*iter);\n\t}\n\treturn NULL;\n}\n\nbool TWPartitionManager::Add_Remove_MTP_Storage(TWPartition* Part, int message_type) {\n#ifdef TW_HAS_MTP\n\tstruct mtpmsg mtp_message;\n\n\tif (!mtppid)\n\t\treturn false; // MTP is disabled\n\n\tif (mtp_write_fd < 0) {\n\t\tLOGINFO(\"MTP: mtp_write_fd is not set\\n\");\n\t\treturn false;\n\t}\n\n\tif (Part) {\n\t\tif (Part->MTP_Storage_ID == 0)\n\t\t\treturn false;\n\t\tif (message_type == MTP_MESSAGE_REMOVE_STORAGE) {\n\t\t\tmtp_message.message_type = MTP_MESSAGE_REMOVE_STORAGE; // Remove\n\t\t\tLOGINFO(\"sending message to remove %i\\n\", Part->MTP_Storage_ID);\n\t\t\tmtp_message.storage_id = Part->MTP_Storage_ID;\n\t\t\tif (write(mtp_write_fd, &mtp_message, sizeof(mtp_message)) <= 0) {\n\t\t\t\tLOGINFO(\"error sending message to remove storage %i\\n\", Part->MTP_Storage_ID);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tLOGINFO(\"Message sent, remove storage ID: %i\\n\", Part->MTP_Storage_ID);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (message_type == MTP_MESSAGE_ADD_STORAGE && Part->Is_Mounted()) {\n\t\t\tmtp_message.message_type = MTP_MESSAGE_ADD_STORAGE; // Add\n\t\t\tmtp_message.storage_id = Part->MTP_Storage_ID;\n\t\t\tif (Part->Storage_Path.size() >= sizeof(mtp_message.path)) {\n\t\t\t\tLOGERR(\"Storage path '%s' too large for mtpmsg\\n\", Part->Storage_Path.c_str());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstrcpy(mtp_message.path, Part->Storage_Path.c_str());\n\t\t\tif (Part->Storage_Name.size() >= sizeof(mtp_message.display)) {\n\t\t\t\tLOGERR(\"Storage name '%s' too large for mtpmsg\\n\", Part->Storage_Name.c_str());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstrcpy(mtp_message.display, Part->Storage_Name.c_str());\n\t\t\tmtp_message.maxFileSize = Part->Get_Max_FileSize();\n\t\t\tLOGINFO(\"sending message to add %i '%s' '%s'\\n\", mtp_message.storage_id, mtp_message.path, mtp_message.display);\n\t\t\tif (write(mtp_write_fd, &mtp_message, sizeof(mtp_message)) <= 0) {\n\t\t\t\tLOGINFO(\"error sending message to add storage %i\\n\", Part->MTP_Storage_ID);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tLOGINFO(\"Message sent, add storage ID: %i '%s'\\n\", Part->MTP_Storage_ID, mtp_message.path);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tLOGERR(\"Unknown MTP message type: %i\\n\", message_type);\n\t\t}\n\t} else {\n\t\t// This hopefully never happens as the error handling should\n\t\t// occur in the calling function.\n\t\tLOGINFO(\"TWPartitionManager::Add_Remove_MTP_Storage NULL partition given\\n\");\n\t}\n\treturn true;\n#else\n\tgui_err(\"no_mtp=MTP support not included\");\n\tDataManager::SetValue(\"tw_mtp_enabled\", 0);\n\treturn false;\n#endif\n}\n\nbool TWPartitionManager::Add_MTP_Storage(string Mount_Point) {\n#ifdef TW_HAS_MTP\n\tTWPartition* Part = PartitionManager.Find_Partition_By_Path(Mount_Point);\n\tif (Part) {\n\t\treturn PartitionManager.Add_Remove_MTP_Storage(Part, MTP_MESSAGE_ADD_STORAGE);\n\t} else {\n\t\tLOGINFO(\"TWFunc::Add_MTP_Storage unable to locate partition for '%s'\\n\", Mount_Point.c_str());\n\t}\n#endif\n\treturn false;\n}\n\nbool TWPartitionManager::Add_MTP_Storage(unsigned int Storage_ID) {\n#ifdef TW_HAS_MTP\n\tTWPartition* Part = PartitionManager.Find_Partition_By_MTP_Storage_ID(Storage_ID);\n\tif (Part) {\n\t\treturn PartitionManager.Add_Remove_MTP_Storage(Part, MTP_MESSAGE_ADD_STORAGE);\n\t} else {\n\t\tLOGINFO(\"TWFunc::Add_MTP_Storage unable to locate partition for %i\\n\", Storage_ID);\n\t}\n#endif\n\treturn false;\n}\n\nbool TWPartitionManager::Remove_MTP_Storage(string Mount_Point) {\n#ifdef TW_HAS_MTP\n\tTWPartition* Part = PartitionManager.Find_Partition_By_Path(Mount_Point);\n\tif (Part) {\n\t\treturn PartitionManager.Add_Remove_MTP_Storage(Part, MTP_MESSAGE_REMOVE_STORAGE);\n\t} else {\n\t\tLOGINFO(\"TWFunc::Remove_MTP_Storage unable to locate partition for '%s'\\n\", Mount_Point.c_str());\n\t}\n#endif\n\treturn false;\n}\n\nbool TWPartitionManager::Remove_MTP_Storage(unsigned int Storage_ID) {\n#ifdef TW_HAS_MTP\n\tTWPartition* Part = PartitionManager.Find_Partition_By_MTP_Storage_ID(Storage_ID);\n\tif (Part) {\n\t\treturn PartitionManager.Add_Remove_MTP_Storage(Part, MTP_MESSAGE_REMOVE_STORAGE);\n\t} else {\n\t\tLOGINFO(\"TWFunc::Remove_MTP_Storage unable to locate partition for %i\\n\", Storage_ID);\n\t}\n#endif\n\treturn false;\n}\n\nbool TWPartitionManager::Flash_Image(string& path, string& filename) {\n\tint partition_count = 0;\n\tTWPartition* flash_part = NULL;\n\tstring Flash_List, flash_path, full_filename;\n\tsize_t start_pos = 0, end_pos = 0;\n\n\tfull_filename = path + \"/\" + filename;\n\n\tgui_msg(\"image_flash_start=[IMAGE FLASH STARTED]\");\n\tgui_msg(Msg(\"img_to_flash=Image to flash: '{1}'\")(full_filename));\n\n\tif (!TWFunc::Path_Exists(full_filename)) {\n\t\tif (!Mount_By_Path(full_filename, true)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!TWFunc::Path_Exists(full_filename)) {\n\t\t\tgui_msg(Msg(msg::kError, \"unable_to_locate=Unable to locate {1}.\")(full_filename));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tPartitionSettings part_settings;\n\tpart_settings.Backup_Folder = path;\n\tunsigned long long total_bytes = TWFunc::Get_File_Size(full_filename);\n\tProgressTracking progress(total_bytes);\n\tpart_settings.progress = &progress;\n\tpart_settings.adbbackup = false;\n\tpart_settings.PM_Method = PM_RESTORE;\n\n\tgui_msg(\"calc_restore=Calculating restore details...\");\n\tDataManager::GetValue(\"tw_flash_partition\", Flash_List);\n\tif (!Flash_List.empty()) {\n\t\tend_pos = Flash_List.find(\";\", start_pos);\n\t\twhile (end_pos != string::npos && start_pos < Flash_List.size()) {\n\t\t\tflash_path = Flash_List.substr(start_pos, end_pos - start_pos);\n\t\t\tflash_part = Find_Partition_By_Path(flash_path);\n\t\t\tif (flash_part != NULL) {\n\t\t\t\tpartition_count++;\n\t\t\t\tif (partition_count > 1) {\n\t\t\t\t\tgui_err(\"too_many_flash=Too many partitions selected for flashing.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgui_msg(Msg(msg::kError, \"flash_unable_locate=Unable to locate '{1}' partition for flashing.\")(flash_path));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tstart_pos = end_pos + 1;\n\t\t\tend_pos = Flash_List.find(\";\", start_pos);\n\t\t}\n\t}\n\n\tif (partition_count == 0) {\n\t\tgui_err(\"no_part_flash=No partitions selected for flashing.\");\n\t\treturn false;\n\t}\n\n\tDataManager::SetProgress(0.0);\n\tif (flash_part) {\n\t\tflash_part->Backup_FileName = filename;\n\t\tif (!flash_part->Flash_Image(&part_settings))\n\t\t\treturn false;\n\t} else {\n\t\tgui_err(\"invalid_flash=Invalid flash partition specified.\");\n\t\treturn false;\n\t}\n\tgui_highlight(\"flash_done=IMAGE FLASH COMPLETED]\");\n\treturn true;\n}\n\nvoid TWPartitionManager::Translate_Partition(const char* path, const char* resource_name, const char* default_value) {\n\tTWPartition* part = PartitionManager.Find_Partition_By_Path(path);\n\tif (part) {\n\t\tif (part->Is_Adopted_Storage) {\n\t\t\tpart->Display_Name = part->Display_Name + \" - \" + gui_lookup(\"data\", \"Data\");\n\t\t\tpart->Backup_Display_Name = part->Display_Name;\n\t\t\tpart->Storage_Name = part->Storage_Name + \" - \" + gui_lookup(\"adopted_storage\", \"Adopted Storage\");\n\t\t} else {\n\t\t\tpart->Display_Name = gui_lookup(resource_name, default_value);\n\t\t\tpart->Backup_Display_Name = part->Display_Name;\n\t\t}\n\t}\n}\n\nvoid TWPartitionManager::Translate_Partition(const char* path, const char* resource_name, const char* default_value, const char* storage_resource_name, const char* storage_default_value) {\n\tTWPartition* part = PartitionManager.Find_Partition_By_Path(path);\n\tif (part) {\n\t\tif (part->Is_Adopted_Storage) {\n\t\t\tpart->Backup_Display_Name = part->Display_Name + \" - \" + gui_lookup(\"data_backup\", \"Data (excl. storage)\");\n\t\t\tpart->Display_Name = part->Display_Name + \" - \" + gui_lookup(\"data\", \"Data\");\n\t\t\tpart->Storage_Name = part->Storage_Name + \" - \" + gui_lookup(\"adopted_storage\", \"Adopted Storage\");\n\t\t} else {\n\t\t\tpart->Display_Name = gui_lookup(resource_name, default_value);\n\t\t\tpart->Backup_Display_Name = part->Display_Name;\n\t\t\tif (part->Is_Storage)\n\t\t\t\tpart->Storage_Name = gui_lookup(storage_resource_name, storage_default_value);\n\t\t}\n\t}\n}\n\nvoid TWPartitionManager::Translate_Partition(const char* path, const char* resource_name, const char* default_value, const char* storage_resource_name, const char* storage_default_value, const char* backup_name, const char* backup_default) {\n\tTWPartition* part = PartitionManager.Find_Partition_By_Path(path);\n\tif (part) {\n\t\tif (part->Is_Adopted_Storage) {\n\t\t\tpart->Backup_Display_Name = part->Display_Name + \" - \" + gui_lookup(backup_name, backup_default);\n\t\t\tpart->Display_Name = part->Display_Name + \" - \" + gui_lookup(\"data\", \"Data\");\n\t\t\tpart->Storage_Name = part->Storage_Name + \" - \" + gui_lookup(\"adopted_storage\", \"Adopted Storage\");\n\t\t} else {\n\t\t\tpart->Display_Name = gui_lookup(resource_name, default_value);\n\t\t\tpart->Backup_Display_Name = gui_lookup(backup_name, backup_default);\n\t\t\tif (part->Is_Storage)\n\t\t\t\tpart->Storage_Name = gui_lookup(storage_resource_name, storage_default_value);\n\t\t}\n\t}\n}\n\nvoid TWPartitionManager::Translate_Partition_Display_Names() {\n\tLOGINFO(\"Translating partition display names\\n\");\n\tTranslate_Partition(\"/system\", \"system\", \"System\");\n\tTranslate_Partition(\"/system_image\", \"system_image\", \"System Image\");\n\tTranslate_Partition(\"/vendor\", \"vendor\", \"Vendor\");\n\tTranslate_Partition(\"/vendor_image\", \"vendor_image\", \"Vendor Image\");\n\tTranslate_Partition(\"/cache\", \"cache\", \"Cache\");\n\tTranslate_Partition(\"/boot\", \"boot\", \"Boot\");\n\tTranslate_Partition(\"/recovery\", \"recovery\", \"Recovery\");\n\tif (!datamedia) {\n\t\tTranslate_Partition(\"/data\", \"data\", \"Data\", \"internal\", \"Internal Storage\");\n\t\tTranslate_Partition(\"/sdcard\", \"sdcard\", \"SDCard\", \"sdcard\", \"SDCard\");\n\t\tTranslate_Partition(\"/internal_sd\", \"sdcard\", \"SDCard\", \"sdcard\", \"SDCard\");\n\t\tTranslate_Partition(\"/internal_sdcard\", \"sdcard\", \"SDCard\", \"sdcard\", \"SDCard\");\n\t\tTranslate_Partition(\"/emmc\", \"sdcard\", \"SDCard\", \"sdcard\", \"SDCard\");\n\t} else {\n\t\tTranslate_Partition(\"/data\", \"data\", \"Data\", \"internal\", \"Internal Storage\", \"data_backup\", \"Data (excl. storage)\");\n\t}\n\tTranslate_Partition(\"/external_sd\", \"microsd\", \"Micro SDCard\", \"microsd\", \"Micro SDCard\", \"data_backup\", \"Data (excl. storage)\");\n\tTranslate_Partition(\"/external_sdcard\", \"microsd\", \"Micro SDCard\", \"microsd\", \"Micro SDCard\", \"data_backup\", \"Data (excl. storage)\");\n\tTranslate_Partition(\"/usb-otg\", \"usbotg\", \"USB OTG\", \"usbotg\", \"USB OTG\");\n\tTranslate_Partition(\"/sd-ext\", \"sdext\", \"SD-EXT\");\n\n\t// Android secure is a special case\n\tTWPartition* part = PartitionManager.Find_Partition_By_Path(\"/and-sec\");\n\tif (part)\n\t\tpart->Backup_Display_Name = gui_lookup(\"android_secure\", \"Android Secure\");\n\n\tstd::vector<TWPartition*>::iterator sysfs;\n\tfor (sysfs = Partitions.begin(); sysfs != Partitions.end(); sysfs++) {\n\t\tif (!(*sysfs)->Sysfs_Entry.empty()) {\n\t\t\tTranslate_Partition((*sysfs)->Mount_Point.c_str(), \"autostorage\", \"Storage\", \"autostorage\", \"Storage\");\n\t\t}\n\t}\n\n\t// This updates the text on all of the storage selection buttons in the GUI\n\tDataManager::SetBackupFolder();\n}\n\nbool TWPartitionManager::Decrypt_Adopted() {\n#ifdef TW_INCLUDE_CRYPTO\n\tbool ret = false;\n\tif (!Mount_By_Path(\"/data\", false)) {\n\t\tLOGERR(\"Cannot decrypt adopted storage because /data will not mount\\n\");\n\t\treturn false;\n\t}\n\tLOGINFO(\"Decrypt adopted storage starting\\n\");\n\tchar* xmlFile = PageManager::LoadFileToBuffer(\"/data/system/storage.xml\", NULL);\n\txml_document<> *doc = NULL;\n\txml_node<>* volumes = NULL;\n\tstring Primary_Storage_UUID = \"\";\n\tif (xmlFile != NULL) {\n\t\tLOGINFO(\"successfully loaded storage.xml\\n\");\n\t\tdoc = new xml_document<>();\n\t\tdoc->parse<0>(xmlFile);\n\t\tvolumes = doc->first_node(\"volumes\");\n\t\tif (volumes) {\n\t\t\txml_attribute<>* psuuid = volumes->first_attribute(\"primaryStorageUuid\");\n\t\t\tif (psuuid) {\n\t\t\t\tPrimary_Storage_UUID = psuuid->value();\n\t\t\t}\n\t\t}\n\t} else {\n\t\tLOGINFO(\"No /data/system/storage.xml for adopted storage\\n\");\n\t\treturn false;\n\t}\n\tstd::vector<TWPartition*>::iterator adopt;\n\tfor (adopt = Partitions.begin(); adopt != Partitions.end(); adopt++) {\n\t\tif ((*adopt)->Removable && (*adopt)->Is_Present) {\n\t\t\tif ((*adopt)->Decrypt_Adopted() == 0) {\n\t\t\t\tret = true;\n\t\t\t\tif (volumes) {\n\t\t\t\t\txml_node<>* volume = volumes->first_node(\"volume\");\n\t\t\t\t\twhile (volume) {\n\t\t\t\t\t\txml_attribute<>* guid = volume->first_attribute(\"partGuid\");\n\t\t\t\t\t\tif (guid) {\n\t\t\t\t\t\t\tstring GUID = (*adopt)->Adopted_GUID.c_str();\n\t\t\t\t\t\t\tGUID.insert(8, \"-\");\n\t\t\t\t\t\t\tGUID.insert(13, \"-\");\n\t\t\t\t\t\t\tGUID.insert(18, \"-\");\n\t\t\t\t\t\t\tGUID.insert(23, \"-\");\n\n\t\t\t\t\t\t\tif (strcasecmp(GUID.c_str(), guid->value()) == 0) {\n\t\t\t\t\t\t\t\txml_attribute<>* attr = volume->first_attribute(\"nickname\");\n\t\t\t\t\t\t\t\tif (attr && attr->value() && strlen(attr->value()) > 0) {\n\t\t\t\t\t\t\t\t\t(*adopt)->Storage_Name = attr->value();\n\t\t\t\t\t\t\t\t\t(*adopt)->Display_Name = (*adopt)->Storage_Name;\n\t\t\t\t\t\t\t\t\t(*adopt)->Backup_Display_Name = (*adopt)->Storage_Name;\n\t\t\t\t\t\t\t\t\tLOGINFO(\"storage name from storage.xml is '%s'\\n\", attr->value());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tattr = volume->first_attribute(\"fsUuid\");\n\t\t\t\t\t\t\t\tif (attr && !Primary_Storage_UUID.empty() && strcmp(Primary_Storage_UUID.c_str(), attr->value()) == 0) {\n\t\t\t\t\t\t\t\t\tTWPartition* Dat = Find_Partition_By_Path(\"/data\");\n\t\t\t\t\t\t\t\t\tif (Dat) {\n\t\t\t\t\t\t\t\t\t\tLOGINFO(\"Internal storage is found on adopted storage '%s'\\n\", (*adopt)->Display_Name.c_str());\n\t\t\t\t\t\t\t\t\t\tLOGINFO(\"Changing '%s' to point to '%s'\\n\", Dat->Symlink_Mount_Point.c_str(), (*adopt)->Storage_Path.c_str());\n\t\t\t\t\t\t\t\t\t\t(*adopt)->Symlink_Mount_Point = Dat->Symlink_Mount_Point;\n\t\t\t\t\t\t\t\t\t\tDat->Symlink_Mount_Point = \"\";\n\t\t\t\t\t\t\t\t\t\t// Toggle mounts to ensure that the symlink mount point (probably /sdcard) is mounted to the right location\n\t\t\t\t\t\t\t\t\t\tDat->UnMount(false);\n\t\t\t\t\t\t\t\t\t\tDat->Mount(false);\n\t\t\t\t\t\t\t\t\t\t(*adopt)->UnMount(false);\n\t\t\t\t\t\t\t\t\t\t(*adopt)->Mount(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvolume = volume->next_sibling(\"volume\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tUpdate_System_Details();\n\t\t\t\tOutput_Partition((*adopt));\n\t\t\t}\n\t\t}\n\t}\n\tif (xmlFile) {\n\t\tdoc->clear();\n\t\tdelete doc;\n\t\tfree(xmlFile);\n\t}\n\treturn ret;\n#else\n\tLOGINFO(\"Decrypt_Adopted: no crypto support\\n\");\n\treturn false;\n#endif\n}\n\nvoid TWPartitionManager::Remove_Partition_By_Path(string Path) {\n\tstd::vector<TWPartition*>::iterator iter;\n\tstring Local_Path = TWFunc::Get_Root_Path(Path);\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif ((*iter)->Mount_Point == Local_Path || (!(*iter)->Symlink_Mount_Point.empty() && (*iter)->Symlink_Mount_Point == Local_Path)) {\n\t\t\tLOGINFO(\"Found and erasing '%s' from partition list\\n\", Local_Path.c_str());\n\t\t\tPartitions.erase(iter);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid TWPartitionManager::Set_Active_Slot(const string& Slot) {\n\tif (Slot != \"A\" && Slot != \"B\") {\n\t\tLOGERR(\"Set_Active_Slot invalid slot '%s'\\n\", Slot.c_str());\n\t\treturn;\n\t}\n\tif (Active_Slot_Display == Slot)\n\t\treturn;\n\tLOGINFO(\"Setting active slot %s\\n\", Slot.c_str());\n#ifdef AB_OTA_UPDATER\n\tif (!Active_Slot_Display.empty()) {\n\t\tconst hw_module_t *hw_module;\n\t\tboot_control_module_t *module;\n\t\tint ret;\n\t\tret = hw_get_module(\"bootctrl\", &hw_module);\n\t\tif (ret != 0) {\n\t\t\tLOGERR(\"Error getting bootctrl module.\\n\");\n\t\t} else {\n\t\t\tmodule = (boot_control_module_t*) hw_module;\n\t\t\tmodule->init(module);\n\t\t\tint slot_number = 0;\n\t\t\tif (Slot == \"B\")\n\t\t\t\tslot_number = 1;\n\t\t\tif (module->setActiveBootSlot(module, slot_number))\n\t\t\t\tgui_msg(Msg(msg::kError, \"unable_set_boot_slot=Error changing bootloader boot slot to {1}\")(Slot));\n\t\t}\n\t\tDataManager::SetValue(\"tw_active_slot\", Slot); // Doing this outside of this if block may result in a seg fault because the DataManager may not be ready yet\n\t}\n#else\n\tLOGERR(\"Boot slot feature not present\\n\");\n#endif\n\tActive_Slot_Display = Slot;\n\tif (Fstab_Processed())\n\t\tUpdate_System_Details();\n}\nstring TWPartitionManager::Get_Active_Slot_Suffix() {\n\tif (Active_Slot_Display == \"A\")\n\t\treturn \"_a\";\n\treturn \"_b\";\n}\nstring TWPartitionManager::Get_Active_Slot_Display() {\n\treturn Active_Slot_Display;\n}\n\nvoid TWPartitionManager::Remove_Uevent_Devices(const string& Mount_Point) {\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); ) {\n\t\tif ((*iter)->Is_SubPartition && (*iter)->SubPartition_Of == Mount_Point) {\n\t\t\tTWPartition *part = *iter;\n\t\t\tLOGINFO(\"%s was removed by uevent data\\n\", (*iter)->Mount_Point.c_str());\n\t\t\t(*iter)->UnMount(false);\n\t\t\trmdir((*iter)->Mount_Point.c_str());\n\t\t\titer = Partitions.erase(iter);\n\t\t\tdelete part;\n\t\t} else {\n\t\t\titer++;\n\t\t}\n\t}\n}\n\nvoid TWPartitionManager::Handle_Uevent(const Uevent_Block_Data& uevent_data) {\n\tstd::vector<TWPartition*>::iterator iter;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif (!(*iter)->Sysfs_Entry.empty()) {\n\t\t\tstring device;\n\t\t\tsize_t wildcard = (*iter)->Sysfs_Entry.find(\"*\");\n\t\t\tif (wildcard != string::npos) {\n\t\t\t\tdevice = (*iter)->Sysfs_Entry.substr(0, wildcard);\n\t\t\t} else {\n\t\t\t\tdevice = (*iter)->Sysfs_Entry;\n\t\t\t}\n\t\t\tif (device == uevent_data.sysfs_path.substr(0, device.size())) {\n\t\t\t\t// Found a match\n\t\t\t\tif (uevent_data.action == \"add\") {\n\t\t\t\t\t(*iter)->Primary_Block_Device = \"/dev/block/\" + uevent_data.block_device;\n\t\t\t\t\t(*iter)->Alternate_Block_Device = (*iter)->Primary_Block_Device;\n\t\t\t\t\t(*iter)->Is_Present = true;\n\t\t\t\t\tLOGINFO(\"Found a match '%s' '%s'\\n\", uevent_data.block_device.c_str(), device.c_str());\n\t\t\t\t\tif (!Decrypt_Adopted()) {\n\t\t\t\t\t\tLOGINFO(\"No adopted storage so finding actual block device\\n\");\n\t\t\t\t\t\t(*iter)->Find_Actual_Block_Device();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else if (uevent_data.action == \"remove\") {\n\t\t\t\t\t(*iter)->Is_Present = false;\n\t\t\t\t\t(*iter)->Primary_Block_Device = \"\";\n\t\t\t\t\t(*iter)->Actual_Block_Device = \"\";\n\t\t\t\t\tRemove_Uevent_Devices((*iter)->Mount_Point);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLOGINFO(\"Found no matching fstab entry for uevent device '%s' - %s\\n\", uevent_data.sysfs_path.c_str(), uevent_data.action.c_str());\n}\n\nvoid TWPartitionManager::setup_uevent() {\n\tstruct sockaddr_nl nls;\n\n\tif (uevent_pfd.fd >= 0) {\n\t\tLOGINFO(\"uevent already set up\\n\");\n\t\treturn;\n\t}\n\n\t// Open hotplug event netlink socket\n\tmemset(&nls,0,sizeof(struct sockaddr_nl));\n\tnls.nl_family = AF_NETLINK;\n\tnls.nl_pid = getpid();\n\tnls.nl_groups = -1;\n\tuevent_pfd.events = POLLIN;\n\tuevent_pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);\n\tif (uevent_pfd.fd==-1) {\n\t\tLOGERR(\"uevent not root\\n\");\n\t\treturn;\n\t}\n\n\t// Listen to netlink socket\n\tif (::bind(uevent_pfd.fd, (struct sockaddr *) &nls, sizeof(struct sockaddr_nl)) < 0) {\n\t\tLOGERR(\"Bind failed\\n\");\n\t\treturn;\n\t}\n\tset_select_fd();\n\tColdboot();\n}\n\nUevent_Block_Data TWPartitionManager::get_event_block_values(char *buf, int len) {\n\tUevent_Block_Data ret;\n\tret.subsystem = \"\";\n\tchar *ptr = buf;\n\tconst char *end = buf + len;\n\n\tbuf[len - 1] = '\\0';\n\twhile (ptr < end) {\n\t\tif (strncmp(ptr, \"ACTION=\", strlen(\"ACTION=\")) == 0) {\n\t\t\tptr += strlen(\"ACTION=\");\n\t\t\tret.action = ptr;\n\t\t} else if (strncmp(ptr, \"SUBSYSTEM=\", strlen(\"SUBSYSTEM=\")) == 0) {\n\t\t\tptr += strlen(\"SUBSYSTEM=\");\n\t\t\tret.subsystem = ptr;\n\t\t} else if (strncmp(ptr, \"DEVTYPE=\", strlen(\"DEVTYPE=\")) == 0) {\n\t\t\tptr += strlen(\"DEVTYPE=\");\n\t\t\tret.type = ptr;\n\t\t} else if (strncmp(ptr, \"DEVPATH=\", strlen(\"DEVPATH=\")) == 0) {\n\t\t\tptr += strlen(\"DEVPATH=\");\n\t\t\tret.sysfs_path += ptr;\n\t\t} else if (strncmp(ptr, \"DEVNAME=\", strlen(\"DEVNAME=\")) == 0) {\n\t\t\tptr += strlen(\"DEVNAME=\");\n\t\t\tret.block_device += ptr;\n\t\t} else if (strncmp(ptr, \"MAJOR=\", strlen(\"MAJOR=\")) == 0) {\n\t\t\tptr += strlen(\"MAJOR=\");\n\t\t\tret.major = atoi(ptr);\n\t\t} else if (strncmp(ptr, \"MINOR=\", strlen(\"MINOR=\")) == 0) {\n\t\t\tptr += strlen(\"MINOR=\");\n\t\t\tret.minor = atoi(ptr);\n\t\t}\n\t\tptr += strlen(ptr) + 1;\n\t}\n\treturn ret;\n}\n\nvoid TWPartitionManager::read_uevent() {\n\tchar buf[1024];\n\n\tint len = recv(uevent_pfd.fd, buf, sizeof(buf), MSG_DONTWAIT);\n\tif (len == -1) {\n\t\tLOGERR(\"recv error on uevent\\n\");\n\t\treturn;\n\t}\n\t/*int i = 0; // Print all uevent output for test /debug\n\twhile (i<len) {\n\t\tprintf(\"%s\\n\", buf+i);\n\t\ti += strlen(buf+i)+1;\n\t}*/\n\tUevent_Block_Data uevent_data = get_event_block_values(buf, len);\n\tif (uevent_data.subsystem == \"block\" && uevent_data.type == \"disk\") {\n\t\tPartitionManager.Handle_Uevent(uevent_data);\n\t}\n}\n\nvoid TWPartitionManager::close_uevent() {\n\tif (uevent_pfd.fd > 0)\n\t\tclose(uevent_pfd.fd);\n\tuevent_pfd.fd = -1;\n}\n\nvoid TWPartitionManager::Add_Partition(TWPartition* Part) {\n\tPartitions.push_back(Part);\n}\n\nvoid TWPartitionManager::Coldboot_Scan(std::vector<string> *sysfs_entries, const string& Path, int depth) {\n\tstring Real_Path = Path;\n\tchar real_path[PATH_MAX];\n\tif (realpath(Path.c_str(), &real_path[0])) {\n\t\tstring Real_Path = real_path;\n\t\tstd::vector<string>::iterator iter;\n\t\tfor (iter = sysfs_entries->begin(); iter != sysfs_entries->end(); iter++) {\n\t\t\tif (Real_Path.find((*iter)) != string::npos) {\n\t\t\t\tstring Write_Path = Real_Path + \"/uevent\";\n\t\t\t\tif (TWFunc::Path_Exists(Write_Path)) {\n\t\t\t\t\tconst char* write_val = \"add\\n\";\n\t\t\t\t\tTWFunc::write_to_file(Write_Path, write_val);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tDIR* d = opendir(Path.c_str());\n\tif (d != NULL) {\n\t\tstruct dirent* de;\n\t\twhile ((de = readdir(d)) != NULL) {\n\t\t\tif (de->d_name[0] == '.' || (de->d_type != DT_DIR && depth > 0))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(de->d_name) >= 4 && (strncmp(de->d_name, \"ram\", 3) == 0 || strncmp(de->d_name, \"loop\", 4) == 0))\n\t\t\t\tcontinue;\n\n\t\t\tstring item = Path + \"/\";\n\t\t\titem.append(de->d_name);\n\t\t\tColdboot_Scan(sysfs_entries, item, depth + 1);\n\t\t}\n\t\tclosedir(d);\n\t}\n}\n\nvoid TWPartitionManager::Coldboot() {\n\tstd::vector<TWPartition*>::iterator iter;\n\tstd::vector<string> sysfs_entries;\n\n\tfor (iter = Partitions.begin(); iter != Partitions.end(); iter++) {\n\t\tif (!(*iter)->Sysfs_Entry.empty()) {\n\t\t\tsize_t wildcard_pos = (*iter)->Sysfs_Entry.find(\"*\");\n\t\t\tif (wildcard_pos == string::npos)\n\t\t\t\twildcard_pos = (*iter)->Sysfs_Entry.size();\n\t\t\tsysfs_entries.push_back((*iter)->Sysfs_Entry.substr(0, wildcard_pos));\n\t\t}\n\t}\n\n\tif (sysfs_entries.size() > 0)\n\t\tColdboot_Scan(&sysfs_entries, \"/sys/block\", 0);\n}\n"
        },
        {
          "name": "partitions.hpp",
          "type": "blob",
          "size": 31.9228515625,
          "content": "/*\n\tCopyright 2014 to 2017 TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef __TWRP_Partition_Manager\n#define __TWRP_Partition_Manager\n\n#include <map>\n#include <vector>\n#include <string>\n#include <sys/poll.h>\n#include \"exclude.hpp\"\n#include \"tw_atomic.hpp\"\n#include \"progresstracking.hpp\"\n\n#define MAX_FSTAB_LINE_LENGTH 2048\n\nusing namespace std;\n\nstruct PartitionList {\n\tstd::string Display_Name;\n\tstd::string Mount_Point;\n\tunsigned int selected;\n};\n\nstruct Uevent_Block_Data {\n\tstd::string action;\n\tstd::string subsystem;\n\tstd::string block_device;\n\tstd::string type;\n\tstd::string sysfs_path;\n\tint major;\n\tint minor;\n};\n\nstruct Flags_Map {\n\tstd::string Primary_Block_Device;\n\tstd::string Alternate_Block_Device;\n\tstd::string File_System;\n\tstd::string Flags;\n\tchar* fstab_line;\n};\n\nenum PartitionManager_Op {                                                    // PartitionManager Restore Mode for Raw_Read_Write()\n\tPM_BACKUP = 0,\n\tPM_RESTORE = 1,\n};\n\nclass TWPartition;\n\nstruct PartitionSettings {                                                    // Settings for backup session\n\tTWPartition* Part;                                                        // Partition to pass to the partition backup loop\n\tstd::string Backup_Folder;                                                // Path to restore folder\n\tbool adbbackup;                                                           // tell the system we are backing up over adb\n\tbool adb_compression;                                                     // 0 == uncompressed, 1 == compressed\n\tbool generate_digest;                                                      // tell system to create digest for partitions\n\tbool generate_md5;                                                        // tell system to create md5 for partitions\n\tuint64_t total_restore_size;                                              // Total size of restored backup\n\tuint64_t img_bytes_remaining;                                             // remaining img/emmc bytes to backup for progress indicator\n\tuint64_t file_bytes_remaining;                                            // remaining file bytes to backup for progress indicator\n\tuint64_t img_time;                                                        // used to calculate how fast we backup images\n\tuint64_t file_time;                                                       // used to calculate how fast we backup files\n\tuint64_t img_bytes;                                                       // total image bytes of all emmc partitions\n\tuint64_t file_bytes;                                                      // total file bytes of all file based partitions\n\tint partition_count;                                                      // Number of partitions to restore\n\tProgressTracking *progress;                                               // Keep track of progress in GUI\n\tenum PartitionManager_Op PM_Method;                                       // Current operation of backup or restore\n};\n\nenum Backup_Method_enum {\n\tBM_NONE = 0,\n\tBM_FILES = 1,\n\tBM_DD = 2,\n\tBM_FLASH_UTILS = 3,\n};\n\n// Partition class\nclass TWPartition\n{\npublic:\n\tTWPartition();\n\tvirtual ~TWPartition();\n\npublic:\n\tbool Is_Mounted();                                                        // Checks mount to see if the partition is currently mounted\n\tbool Is_File_System_Writable();                                           // Checks if the root directory of the file system can be written to\n\tbool Mount(bool Display_Error);                                           // Mounts the partition if it is not mounted\n\tbool UnMount(bool Display_Error);                                         // Unmounts the partition if it is mounted\n\tbool ReMount(bool Display_Error);                                         // Remounts the partition\n\tbool ReMount_RW(bool Display_Error);                                      // Remounts the partition with read/write access\n\tbool Wipe(string New_File_System);                                        // Wipes the partition\n\tbool Wipe();                                                              // Wipes the partition\n\tbool Wipe_AndSec();                                                       // Wipes android secure\n\tbool Can_Repair();                                                        // Checks to see if we have everything needed to be able to repair the current file system\n\tuint64_t Get_Max_FileSize();                                              // get partition maxFileSie\n\tbool Repair();                                                            // Repairs the current file system\n\tbool Can_Resize();                                                        // Checks to see if we have everything needed to be able to resize the current file system\n\tbool Resize();                                                            // Resizes the current file system\n\tbool Backup(PartitionSettings *part_settings, pid_t *tar_fork_pid);       // Backs up the partition to the folder specified\n\tbool Restore(PartitionSettings *part_settings);                           // Restores the partition using the backup folder provided\n\tunsigned long long Get_Restore_Size(PartitionSettings *part_settings);    // Returns the overall restore size of the backup\n\tstring Backup_Method_By_Name();                                           // Returns a string of the backup method for human readable output\n\tbool Decrypt(string Password);                                            // Decrypts the partition, return 0 for failure and -1 for success\n\tbool Wipe_Encryption();                                                   // Ignores wipe commands for /data/media devices and formats the original block device\n\tvoid Check_FS_Type();                                                     // Checks the fs type using blkid, does not do anything on MTD / yaffs2 because this crashes on some devices\n\tbool Update_Size(bool Display_Error);                                     // Updates size information\n\tvoid Recreate_Media_Folder();                                             // Recreates the /data/media folder\n\tbool Flash_Image(PartitionSettings *part_settings);                                        // Flashes an image to the partition\n\tvoid Change_Mount_Read_Only(bool new_value);                              // Changes Mount_Read_Only to new_value\n\tbool Is_Read_Only();                                                      // Check if system is read-only in TWRP\n\tint Check_Lifetime_Writes();\n\tint Decrypt_Adopted();\n\tvoid Revert_Adopted();\n\tvoid Partition_Post_Processing(bool Display_Error);                       // Apply partition specific settings after fstab processed\n\tvoid Set_Backup_FileName(string fname);                                   // Set Backup_FileName for partition\n\tstring Get_Backup_Name();                                                 // Get Backup_Name for partition\n\npublic:\n\tstring Current_File_System;                                               // Current file system\n\tstring Actual_Block_Device;                                               // Actual block device (one of primary, alternate, or decrypted)\n\tstring Backup_Display_Name;                                               // Name displayed in the partition list for backup selection\n\tstring MTD_Name;                                                          // Name of the partition for MTD devices\n\tbool Is_Present;                                                          // Indicates if the partition is currently present as a block device\n\tstring Crypto_Key_Location;                                               // Location of the crypto key used for decrypting encrypted data partitions\n\tunsigned int MTP_Storage_ID;\n\tstring Adopted_GUID;\n\nprotected:\n\tbool Has_Data_Media;                                                      // Indicates presence of /data/media, may affect wiping and backup methods\n\tvoid Setup_Data_Media();                                                  // Sets up a partition as a /data/media emulated storage partition\n\nprivate:\n\tbool Process_Fstab_Line(const char *fstab_line, bool Display_Error, std::map<string, Flags_Map> *twrp_flags); // Processes a fstab line\n\tvoid Setup_Data_Partition(bool Display_Error);                            // Setup data partition after fstab processed\n\tvoid Setup_Cache_Partition(bool Display_Error);                           // Setup cache partition after fstab processed\n\tbool Find_Wildcard_Block_Devices(const string& Device);                   // Searches for and finds wildcard block devices\n\tvoid Find_Actual_Block_Device();                                          // Determines the correct block device and stores it in Actual_Block_Device\n\n\tvoid Apply_TW_Flag(const unsigned flag, const char* str, const bool val); // Apply custom twrp fstab flags\n\tvoid Process_TW_Flags(char *flags, bool Display_Error, int fstab_ver);    // Process custom twrp fstab flags\n\tvoid Process_FS_Flags(const char *str);                                   // Process standard fstab fs flags\n\tvoid Save_FS_Flags(const string& local_File_System, int local_Mount_Flags, const string& local_Mount_Options); // Saves fs flags to a vector in case there are multiple lines in a v2 fstab with different mount flags for different file systems\n\tbool Is_File_System(string File_System);                                  // Checks to see if the file system given is considered a file system\n\tbool Is_Image(string File_System);                                        // Checks to see if the file system given is considered an image\n\tvoid Setup_File_System(bool Display_Error);                               // Sets defaults for a file system partition\n\tvoid Setup_Image();                                                       // Sets defaults for an image partition\n\tvoid Setup_AndSec(void);                                                  // Sets up .android_secure settings\n\tvoid Find_Real_Block_Device(string& Block_Device, bool Display_Error);    // Checks the block device given and follows symlinks until it gets to the real block device\n\tunsigned long long IOCTL_Get_Block_Size();                                // Finds the partition size using ioctl\n\tbool Find_Partition_Size();                                               // Finds the partition size from /proc/partitions\n\tunsigned long long Get_Size_Via_du(string Path, bool Display_Error);      // Uses du to get sizes\n\tbool Wipe_EXT23(string File_System);                                      // Formats as ext3 or ext2\n\tbool Wipe_EXT4();                                                         // Formats using ext4, uses make_ext4fs when present\n\tbool Wipe_FAT();                                                          // Formats as FAT if mkfs.fat exits otherwise rm -rf wipe\n\tbool Wipe_EXFAT();                                                        // Formats as EXFAT\n\tbool Wipe_MTD();                                                          // Formats as yaffs2 for MTD memory types\n\tbool Wipe_RMRF();                                                         // Uses rm -rf to wipe\n\tbool Wipe_F2FS();                                                         // Uses mkfs.f2fs to wipe\n\tbool Wipe_NTFS();                                                         // Uses mkntfs to wipe\n\tbool Wipe_Data_Without_Wiping_Media();                                    // Uses rm -rf to wipe but does not wipe /data/media\n\tbool Wipe_Data_Without_Wiping_Media_Func(const string& parent);           // Uses rm -rf to wipe but does not wipe /data/media\n\tbool Backup_Tar(PartitionSettings *part_settings, pid_t *tar_fork_pid);   // Backs up using tar for file systems\n\tbool Backup_Image(PartitionSettings *part_settings);                      // Backs up using raw read/write for emmc memory types\n\tbool Raw_Read_Write(PartitionSettings *part_settings);\n\tbool Backup_Dump_Image(PartitionSettings *part_settings);                 // Backs up using dump_image for MTD memory types\n\tstring Get_Restore_File_System(PartitionSettings *part_settings);         // Returns the file system that was in place at the time of the backup\n\tbool Restore_Tar(PartitionSettings *part_settings);                       // Restore using tar for file systems\n\tbool Restore_Image(PartitionSettings *part_settings);                     // Restore using dd for images\n\tbool Check_Restore_File_MD5(const string& Filename);                      // Verifies MD5 matches for a file before restoration\n\tbool Get_Size_Via_statfs(bool Display_Error);                             // Get Partition size, used, and free space using statfs\n\tbool Get_Size_Via_df(bool Display_Error);                                 // Get Partition size, used, and free space using df command\n\tbool Make_Dir(string Path, bool Display_Error);                           // Creates a directory if it doesn't already exist\n\tbool Find_MTD_Block_Device(string MTD_Name);                              // Finds the mtd block device based on the name from the fstab\n\tvoid Recreate_AndSec_Folder(void);                                        // Recreates the .android_secure folder\n\tbool Mount_Storage_Retry(bool Display_Error);                             // Tries multiple times with a half second delay to mount a device in case storage is slow to mount\n\tbool Is_Sparse_Image(const string& Filename);                             // Determines if a file is in sparse image format\n\tbool Flash_Sparse_Image(const string& Filename);                          // Flashes a sparse image using simg2img\n\tbool Flash_Image_FI(const string& Filename, ProgressTracking *progress);  // Flashes an image to the partition using flash_image for mtd nand\n\tvoid ExcludeAll(const string& path);                                      // Adds an exclusion for path to both the backup and wipe exclusion lists\n\nprivate:\n\tbool Can_Be_Mounted;                                                      // Indicates that the partition can be mounted\n\tbool Can_Be_Wiped;                                                        // Indicates that the partition can be wiped\n\tbool Can_Be_Backed_Up;                                                    // Indicates that the partition will show up in the backup list\n\tbool Use_Rm_Rf;                                                           // Indicates that the partition will always be formatted w/ \"rm -rf *\"\n\tbool Wipe_During_Factory_Reset;                                           // Indicates that this partition is wiped during a factory reset\n\tbool Wipe_Available_in_GUI;                                               // Inidcates that the wipe can be user initiated in the GUI system\n\tbool Is_SubPartition;                                                     // Indicates that this partition is a sub-partition of another partition (e.g. datadata is a sub-partition of data)\n\tbool Has_SubPartition;                                                    // Indicates that this partition has a sub-partition\n\tstring SubPartition_Of;                                                   // Indicates which partition is the parent partition of this partition (e.g. /data is the parent partition of /datadata)\n\tstring Symlink_Path;                                                      // Symlink path (e.g. /data/media)\n\tstring Symlink_Mount_Point;                                               // /sdcard could be the symlink mount point for /data/media\n\tstring Mount_Point;                                                       // Mount point for this partition (e.g. /system or /data)\n\tstring Backup_Path;                                                       // Path for backup\n\tbool Wildcard_Block_Device;                                               // If the block device contains an asterisk, we set this flag\n\tstring Sysfs_Entry;                                                       // For v2 fstab, if the \"block device\" starts with /devices then it is a sysfs entry that is handled by uevents\n\tstring Primary_Block_Device;                                              // Block device (e.g. /dev/block/mmcblk1p1)\n\tstring Alternate_Block_Device;                                            // Alternate block device (e.g. /dev/block/mmcblk1)\n\tstring Decrypted_Block_Device;                                            // Decrypted block device available after decryption\n\tbool Removable;                                                           // Indicates if this partition is removable -- affects how often we check overall size, if present, etc.\n\tint Length;                                                               // Used by make_ext4fs to leave free space at the end of the partition block for things like a crypto footer\n\tunsigned long long Size;                                                  // Overall size of the partition\n\tunsigned long long Used;                                                  // Overall used space\n\tunsigned long long Free;                                                  // Overall free space\n\tunsigned long long Backup_Size;                                           // Backup size -- may be different than used space especially when /data/media is present\n\tunsigned long long Restore_Size;                                          // Restore size of the current restore operation\n\tbool Can_Be_Encrypted;                                                    // This partition might be encrypted, affects error handling, can only be true if crypto support is compiled in\n\tbool Is_Encrypted;                                                        // This partition is thought to be encrypted -- it wouldn't mount for some reason, only avialble with crypto support\n\tbool Is_Decrypted;                                                        // This partition has successfully been decrypted\n\tbool Is_FBE;                                                              // File Based Encryption is present\n\tbool Mount_To_Decrypt;                                                    // Mount this partition during decrypt (/vendor, /firmware, etc in case we need proprietary libs or firmware files)\n\tstring Display_Name;                                                      // Display name for the GUI\n\tstring Backup_Name;                                                       // Backup name -- used for backup filenames\n\tstring Storage_Name;                                                      // Name displayed in the partition list for storage selection\n\tstring Backup_FileName;                                                   // Actual backup filename\n\tBackup_Method_enum Backup_Method;                                         // Method used for backup\n\tbool Can_Encrypt_Backup;                                                  // Indicates if this item can be encrypted during backup\n\tbool Use_Userdata_Encryption;                                             // Indicates if we will use userdata encryption splitting on an encrypted backup\n\tbool Has_Android_Secure;                                                  // Indicates the presence of .android_secure on this partition\n\tbool Is_Storage;                                                          // Indicates if this partition is used for storage for backup, restore, and installing zips\n\tbool Is_Settings_Storage;                                                 // Indicates that this storage partition is the location of the .twrps settings file and the location that is used for custom themes\n\tstring Storage_Path;                                                      // Indicates the path to the storage -- root indicates mount point, media/ indicates e.g. /data/media\n\tstring Fstab_File_System;                                                 // File system from the recovery.fstab\n\tint Mount_Flags;                                                          // File system flags from recovery.fstab\n\tstring Mount_Options;                                                     // File system options from recovery.fstab\n\tunsigned long Format_Block_Size;                                          // Block size for formatting\n\tbool Ignore_Blkid;                                                        // Ignore blkid results due to superblocks lying to us on certain devices / partitions\n\tbool Retain_Layout_Version;                                               // Retains the .layout_version file during a wipe (needed on devices like Sony Xperia T where /data and /data/media are separate partitions)\n\tbool Can_Flash_Img;                                                       // Indicates if this partition can have images flashed to it via the GUI\n\tbool Mount_Read_Only;                                                     // Only mount this partition as read-only\n\tbool Is_Adopted_Storage;                                                  // Indicates that this partition is for adopted storage (android_expand)\n\tbool SlotSelect;                                                          // Partition has A/B slots\n\tTWExclude backup_exclusions;                                              // Exclusions for file based backups\n\tTWExclude wipe_exclusions;                                                // Exclusions for file based wipes (data/media devices only)\n\n\tstruct partition_fs_flags_struct {                                        // This struct is used to store mount flags and options for different file systems for the same partition\n\t\tstring File_System;\n\t\tint Mount_Flags;\n\t\tstring Mount_Options;\n\t};\n\n\tstd::vector<partition_fs_flags_struct> fs_flags;                          // This vector stores mount flags and options for different file systems for the same partition\n\nfriend class TWPartitionManager;\nfriend class DataManager;\nfriend class GUIPartitionList;\nfriend class GUIAction;\nfriend class PageManager;\n};\n\nclass TWPartitionManager\n{\npublic:\n\tTWPartitionManager();                                                     // Constructor for TWRPartionManager\n\t~TWPartitionManager() {}\n\npublic:\n\tint Process_Fstab(string Fstab_Filename, bool Display_Error);             // Parses the fstab and populates the partitions\n\tint Write_Fstab();                                                        // Creates /etc/fstab file that's used by the command line for mount commands\n\tvoid Output_Partition_Logging();                                          // Outputs partition information to the log\n\tvoid Output_Partition(TWPartition* Part);                                 // Outputs partition details to the log\n\tint Mount_By_Path(string Path, bool Display_Error);                       // Mounts partition based on path (e.g. /system)\n\tint UnMount_By_Path(string Path, bool Display_Error);                     // Unmounts partition based on path\n\tint Is_Mounted_By_Path(string Path);                                      // Checks if partition is mounted based on path\n\tint Mount_Current_Storage(bool Display_Error);                            // Mounts the current storage location\n\tint Mount_Settings_Storage(bool Display_Error);                           // Mounts the settings file storage location (usually internal)\n\tTWPartition* Find_Partition_By_Path(const string& Path);                  // Returns a pointer to a partition based on path\n\tTWPartition* Find_Partition_By_Block_Device(const string& Block_Device);  // Returns a pointer to a partition based on block device\n\tint Check_Backup_Name(bool Display_Error);                                // Checks the current backup name to ensure that it is valid\n\tint Run_Backup(bool adbbackup);                                           // Initiates a backup in the current storage\n\tint Run_Restore(const string& Restore_Name);                              // Restores a backup\n\tbool Write_ADB_Stream_Header(uint64_t partition_count);                   // Write ADB header over twrpbu FIFO\n\tbool Write_ADB_Stream_Trailer();                                          // Write ADB trailer over twrpbu FIFO\n\tvoid Set_Restore_Files(string Restore_Name);                              // Used to gather a list of available backup partitions for the user to select for a restore\n\tint Wipe_By_Path(string Path);                                            // Wipes a partition based on path\n\tint Wipe_By_Path(string Path, string New_File_System);                    // Wipes a partition based on path\n\tint Factory_Reset();                                                      // Performs a factory reset\n\tint Wipe_Dalvik_Cache();                                                  // Wipes dalvik cache\n\tint Wipe_Rotate_Data();                                                   // Wipes rotation data --\n\tint Wipe_Battery_Stats();                                                 // Wipe battery stats -- /data/system/batterystats.bin\n\tint Wipe_Android_Secure();                                                // Wipes android secure\n\tint Format_Data();                                                        // Really formats data on /data/media devices -- also removes encryption\n\tint Wipe_Media_From_Data();                                               // Removes and recreates the media folder on /data/media devices\n\tint Repair_By_Path(string Path, bool Display_Error);                      // Repairs a partition based on path\n\tint Resize_By_Path(string Path, bool Display_Error);                      // Resizes a partition based on path\n\tvoid Update_System_Details();                                             // Updates fstab, file systems, sizes, etc.\n\tint Decrypt_Device(string Password);                                      // Attempt to decrypt any encrypted partitions\n\tint usb_storage_enable(void);                                             // Enable USB storage mode\n\tint usb_storage_disable(void);                                            // Disable USB storage mode\n\tvoid Mount_All_Storage(void);                                             // Mounts all storage locations\n\tvoid UnMount_Main_Partitions(void);                                       // Unmounts system and data if not data/media and boot if boot is mountable\n\tint Partition_SDCard(void);                                               // Repartitions the sdcard\n\tTWPartition *Get_Default_Storage_Partition();                             // Returns a pointer to a default storage partition\n\tint Check_Backup_Cancel();                                                // Returns the value of stop_backup\n\tint Cancel_Backup();                                                      // Signals partition backup to cancel\n\tvoid Clean_Backup_Folder(string Backup_Folder);                           // Clean Backup Folder on Error\n\tint Fix_Contexts();\n\tvoid Get_Partition_List(string ListType, std::vector<PartitionList> *Partition_List);\n\tint Fstab_Processed();                                                    // Indicates if the fstab has been processed or not\n\tvoid Output_Storage_Fstab();                                              // Creates a /cache/recovery/storage.fstab file with a list of all potential storage locations for app use\n\tbool Enable_MTP();                                                        // Enables MTP\n\tvoid Add_All_MTP_Storage();                                               // Adds all storage objects for MTP\n\tbool Disable_MTP();                                                       // Disables MTP\n\tbool Add_MTP_Storage(string Mount_Point);                                 // Adds or removes an MTP Storage partition\n\tbool Add_MTP_Storage(unsigned int Storage_ID);                            // Adds or removes an MTP Storage partition\n\tbool Remove_MTP_Storage(string Mount_Point);                              // Adds or removes an MTP Storage partition\n\tbool Remove_MTP_Storage(unsigned int Storage_ID);                         // Adds or removes an MTP Storage partition\n\tvoid Translate_Partition(const char* path, const char* resource_name, const char* default_value);\n\tvoid Translate_Partition(const char* path, const char* resource_name, const char* default_value, const char* storage_resource_name, const char* storage_default_value);\n\tvoid Translate_Partition(const char* path, const char* resource_name, const char* default_value, const char* storage_resource_name, const char* storage_default_value, const char* backup_name, const char* backup_default);\n\tvoid Translate_Partition_Display_Names();                                 // Updates display names based on translations\n\tbool Decrypt_Adopted();                                                   // Attempt to identy and decrypt any adopted storage partitions\n\tvoid Remove_Partition_By_Path(string Path);                               // Removes / erases a partition entry from the partition list\n\n\tbool Flash_Image(string& path, string& filename);                         // Flashes an image to a selected partition from the partition list\n\tbool Restore_Partition(struct PartitionSettings *part_settings);          // Restore the partitions based on type\n\tTWAtomicInt stop_backup;\n\tvoid Set_Active_Slot(const string& Slot);                                 // Sets the active slot to A or B\n\tstring Get_Active_Slot_Suffix();                                          // Returns active slot _a or _b\n\tstring Get_Active_Slot_Display();                                         // Returns active slot A or B for display purposes\n\tstruct pollfd uevent_pfd;                                                 // Used for uevent code\n\tvoid Remove_Uevent_Devices(const string& sysfs_path);                     // Removes subpartitions from the Partitions vector for a matched uevent device\n\tvoid Handle_Uevent(const Uevent_Block_Data& uevent_data);                 // Handle uevent data\n\tvoid setup_uevent();                                                      // Opens the uevent netlink socket\n\tUevent_Block_Data get_event_block_values(char *buf, int len);             // Scans the buffer from uevent data and loads the appropriate data into a Uevent_Block_Data struct for processing\n\tvoid read_uevent();                                                       // Reads uevent data into a buffer\n\tvoid close_uevent();                                                      // Closes the uevent netlink socket\n\tvoid Add_Partition(TWPartition* Part);                                    // Adds a new partition to the Partitions vector\n\nprivate:\n\tvoid Setup_Settings_Storage_Partition(TWPartition* Part);                 // Sets up settings storage\n\tvoid Setup_Android_Secure_Location(TWPartition* Part);                    // Sets up .android_secure if needed\n\tbool Backup_Partition(struct PartitionSettings *part_settings);           // Backup the partitions based on type\n\tTWPartition* Find_Partition_By_MTP_Storage_ID(unsigned int Storage_ID);   // Returns a pointer to a partition based on MTP Storage ID\n\tbool Add_Remove_MTP_Storage(TWPartition* Part, int message_type);         // Adds or removes an MTP Storage partition\n\tTWPartition* Find_Next_Storage(string Path, bool Exclude_Data_Media);\n\tint Open_Lun_File(string Partition_Path, string Lun_File);\n\tvoid Post_Decrypt(const string& Block_Device);                            // Completes various post-decrypt tasks\n\tvoid Coldboot_Scan(std::vector<string> *sysfs_entries, const string& Path, int depth); // Scans subfolders to find matches to the paths stored in sysfs_entries so we can trigger the uevent system to \"re-add\" devices\n\tvoid Coldboot();                                                          // Starts the scan of the /sys/block folder\n\tpid_t mtppid;\n\tbool mtp_was_enabled;\n\tint mtp_write_fd;\n\tpid_t tar_fork_pid;                                                       // PID of twrpTar fork\n\tBackup_Method_enum Backup_Method;                                         // Method used for backup\n\nprivate:\n\tstd::vector<TWPartition*> Partitions;                                     // Vector list of all partitions\n\tstring Active_Slot_Display;                                               // Current Active Slot (A or B) for display purposes\n};\n\nextern TWPartitionManager PartitionManager;\n\n#endif // __TWRP_Partition_Manager\n"
        },
        {
          "name": "pigz",
          "type": "tree",
          "content": null
        },
        {
          "name": "prebuilt",
          "type": "tree",
          "content": null
        },
        {
          "name": "private",
          "type": "tree",
          "content": null
        },
        {
          "name": "progresstracking.cpp",
          "type": "blob",
          "size": 3.7333984375,
          "content": "/*\n        Copyright 2016 bigbiff/Dees_Troy TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// Progress tracking class for tracking backup progess and updating the progress bar as appropriate\n\n\n#include \"progresstracking.hpp\"\n#include \"twcommon.h\"\n#ifndef BUILD_TWRPTAR_MAIN\n#include \"gui/gui.hpp\"\n#include \"data.hpp\"\n#endif\n#include \"twrp-functions.hpp\"\n#include <time.h>\n\nconst int32_t update_interval_ms = 200; // Update interval in ms\n\nProgressTracking::ProgressTracking(const unsigned long long backup_size) {\n\ttotal_backup_size = backup_size;\n\tpartition_size = 0;\n\tfile_count = 0;\n\tcurrent_size = 0;\n\tcurrent_count = 0;\n\tprevious_partitions_size = 0;\n\tdisplay_file_count = false;\n\tclock_gettime(CLOCK_MONOTONIC, &last_update);\n}\n\nvoid ProgressTracking::SetPartitionSize(const unsigned long long part_size) {\n\tprevious_partitions_size += partition_size;\n\tpartition_size = part_size;\n\tUpdateDisplayDetails(true);\n}\n\nvoid ProgressTracking::SetSizeCount(const unsigned long long part_size, unsigned long long f_count) {\n\tprevious_partitions_size += partition_size;\n\tpartition_size = part_size;\n\tfile_count = f_count;\n\tdisplay_file_count = (file_count != 0);\n\tUpdateDisplayDetails(true);\n}\n\nvoid ProgressTracking::UpdateSize(const unsigned long long size) {\n\tcurrent_size = size;\n\tUpdateDisplayDetails(false);\n}\n\nvoid ProgressTracking::UpdateSizeCount(const unsigned long long size, const unsigned long long count) {\n\tcurrent_size = size;\n\tcurrent_count = count;\n\tUpdateDisplayDetails(false);\n}\n\nvoid ProgressTracking::DisplayFileCount(const bool display) {\n\tdisplay_file_count = display;\n\tUpdateDisplayDetails(true);\n}\n\nvoid ProgressTracking::UpdateDisplayDetails(const bool force) {\n#ifndef BUILD_TWRPTAR_MAIN\n\tif (!force) {\n\t\t// Do something to check the time frame and only update periodically to reduce the total number of GUI updates\n\t\ttimespec now;\n\t\tclock_gettime(CLOCK_MONOTONIC, &now);\n\n\t\tint32_t diff = TWFunc::timespec_diff_ms(last_update, now);\n\t\tif (diff < update_interval_ms)\n\t\t\treturn;\n\t}\n\tclock_gettime(CLOCK_MONOTONIC, &last_update);\n\tdouble display_percent = 0.0, progress_percent;\n\tstring size_prog = gui_lookup(\"size_progress\", \"%lluMB of %lluMB, %i%%\");\n\tchar size_progress[1024];\n\n\tif (total_backup_size != 0) // prevent division by 0\n\t\tdisplay_percent = (double)(current_size + previous_partitions_size) / (double)(total_backup_size) * 100;\n\tsprintf(size_progress, size_prog.c_str(), (current_size + previous_partitions_size) / 1048576, total_backup_size / 1048576, (int)(display_percent));\n\tDataManager::SetValue(\"tw_size_progress\", size_progress);\n\tprogress_percent = (display_percent / 100);\n\tDataManager::SetProgress((float)(progress_percent));\n\n\tif (!display_file_count || file_count == 0) {\n\t\tDataManager::SetValue(\"tw_file_progress\", \"\");\n\t} else {\n\t\tstring file_prog = gui_lookup(\"file_progress\", \"%llu of %llu files, %i%%\");\n\t\tchar file_progress[1024];\n\n\t\tdisplay_percent = (double)(current_count) / (double)(file_count) * 100;\n\t\tsprintf(file_progress, file_prog.c_str(), current_count, file_count, (int)(display_percent));\n\t\tDataManager::SetValue(\"tw_file_progress\", file_progress);\n\t}\n#endif\n}\n"
        },
        {
          "name": "progresstracking.hpp",
          "type": "blob",
          "size": 2.349609375,
          "content": "/*\n        Copyright 2016 bigbiff/Dees_Troy TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef __PROGRESSTRACKING_HPP\n#define __PROGRESSTRACKING_HPP\n\n#include <time.h>\n\n// Progress tracking class for tracking backup progess and updating the progress bar as appropriate\nclass ProgressTracking\n{\npublic:\n\tProgressTracking(const unsigned long long backup_size);\n\n\tvoid SetPartitionSize(const unsigned long long part_size);\n\tvoid SetSizeCount(const unsigned long long part_size, unsigned long long f_count);\n\n\tvoid UpdateSize(const unsigned long long size);\n\tvoid UpdateSizeCount(const unsigned long long size, const unsigned long long count);\n\n\tvoid DisplayFileCount(const bool display);\n\tvoid UpdateDisplayDetails(const bool force);\n\nprivate:\n\tunsigned long long total_backup_size;              // Overall size (for the progress bar)\n\n\tunsigned long long partition_size;                 // Size of the current partition\n\tunsigned long long file_count;                     // Count of files for the current partition (tar backup only, not restore)\n\n\tunsigned long long current_size;                   // Size of the current partition's already backed up data\n\tunsigned long long current_count;                  // Count of files that have already been backed up for the current partition\n\n\tunsigned long long previous_partitions_size;       // Total data already backed up from previous partitions (for the progress bar)\n\n\tbool display_file_count;                           // Inidicates if we will display the file count text\n\ttimespec last_update;                              // Tracks last update of the displayed progress (frequent updates tax the CPU and slow us down)\n};\n\n#endif //__PROGRESSTRACKING_HPP\n"
        },
        {
          "name": "recovery-persist.cpp",
          "type": "blob",
          "size": 5.0869140625,
          "content": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//\n// Strictly to deal with reboot into system after OTA after /data\n// mounts to pull the last pmsg file data and place it\n// into /data/misc/recovery/ directory, rotating it in.\n//\n// Usage: recovery-persist [--force-persist]\n//\n//    On systems without /cache mount, all file content representing in the\n//    recovery/ directory stored in /sys/fs/pstore/pmsg-ramoops-0 in logger\n//    format that reside in the LOG_ID_SYSTEM buffer at ANDROID_LOG_INFO\n//    priority or higher is transfered to the /data/misc/recovery/ directory.\n//    The content is matched and rotated in as need be.\n//\n//    --force-persist  ignore /cache mount, always rotate in the contents.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <string>\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <private/android_logger.h> /* private pmsg functions */\n\n#include \"rotate_logs.h\"\n\nstatic const char *LAST_LOG_FILE = \"/data/misc/recovery/last_log\";\nstatic const char *LAST_PMSG_FILE = \"/sys/fs/pstore/pmsg-ramoops-0\";\nstatic const char *LAST_KMSG_FILE = \"/data/misc/recovery/last_kmsg\";\nstatic const char *LAST_CONSOLE_FILE = \"/sys/fs/pstore/console-ramoops-0\";\nstatic const char *ALT_LAST_CONSOLE_FILE = \"/sys/fs/pstore/console-ramoops\";\n\n// close a file, log an error if the error indicator is set\nstatic void check_and_fclose(FILE *fp, const char *name) {\n    fflush(fp);\n    if (ferror(fp)) {\n        PLOG(ERROR) << \"Error in \" << name;\n    }\n    fclose(fp);\n}\n\nstatic void copy_file(const char* source, const char* destination) {\n  FILE* dest_fp = fopen(destination, \"we\");\n  if (dest_fp == nullptr) {\n    PLOG(ERROR) << \"Can't open \" << destination;\n  } else {\n    FILE* source_fp = fopen(source, \"re\");\n    if (source_fp != nullptr) {\n      char buf[4096];\n      size_t bytes;\n      while ((bytes = fread(buf, 1, sizeof(buf), source_fp)) != 0) {\n        fwrite(buf, 1, bytes, dest_fp);\n      }\n      check_and_fclose(source_fp, source);\n    }\n    check_and_fclose(dest_fp, destination);\n  }\n}\n\nstatic bool rotated = false;\n\nssize_t logsave(\n        log_id_t /* logId */,\n        char /* prio */,\n        const char *filename,\n        const char *buf, size_t len,\n        void * /* arg */) {\n\n    std::string destination(\"/data/misc/\");\n    destination += filename;\n\n    std::string buffer(buf, len);\n\n    {\n        std::string content;\n        android::base::ReadFileToString(destination, &content);\n\n        if (buffer.compare(content) == 0) {\n            return len;\n        }\n    }\n\n    // ToDo: Any others that match? Are we pulling in multiple\n    // already-rotated files? Algorithm thus far is KISS: one file,\n    // one rotation allowed.\n\n    rotate_logs(LAST_LOG_FILE, LAST_KMSG_FILE);\n    rotated = true;\n\n    return android::base::WriteStringToFile(buffer, destination.c_str());\n}\n\nint main(int argc, char **argv) {\n\n    /* Is /cache a mount?, we have been delivered where we are not wanted */\n    /*\n     * Following code halves the size of the executable as compared to:\n     *\n     *    load_volume_table();\n     *    has_cache = volume_for_path(CACHE_ROOT) != nullptr;\n     */\n    bool has_cache = false;\n    static const char mounts_file[] = \"/proc/mounts\";\n    FILE* fp = fopen(mounts_file, \"re\");\n    if (!fp) {\n        PLOG(ERROR) << \"failed to open \" << mounts_file;\n    } else {\n        char *line = NULL;\n        size_t len = 0;\n        ssize_t read;\n        while ((read = getline(&line, &len, fp)) != -1) {\n            if (strstr(line, \" /cache \")) {\n                has_cache = true;\n                break;\n            }\n        }\n        free(line);\n        fclose(fp);\n    }\n\n    if (has_cache) {\n        /*\n         * TBD: Future location to move content from\n         * /cache/recovery to /data/misc/recovery/\n         */\n        /* if --force-persist flag, then transfer pmsg data anyways */\n        if ((argc <= 1) || !argv[1] || strcmp(argv[1], \"--force-persist\")) {\n            return 0;\n        }\n    }\n\n    /* Is there something in pmsg? */\n    if (access(LAST_PMSG_FILE, R_OK)) {\n        return 0;\n    }\n\n    // Take last pmsg file contents and send it off to the logsave\n    __android_log_pmsg_file_read(\n        LOG_ID_SYSTEM, ANDROID_LOG_INFO, \"recovery/\", logsave, NULL);\n\n    /* Is there a last console log too? */\n    if (rotated) {\n        if (!access(LAST_CONSOLE_FILE, R_OK)) {\n            copy_file(LAST_CONSOLE_FILE, LAST_KMSG_FILE);\n        } else if (!access(ALT_LAST_CONSOLE_FILE, R_OK)) {\n            copy_file(ALT_LAST_CONSOLE_FILE, LAST_KMSG_FILE);\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "recovery-persist.rc",
          "type": "blob",
          "size": 0.1240234375,
          "content": "on post-fs-data\n    mkdir /data/misc/recovery 0770 system log\n    exec_background - system log -- /system/bin/recovery-persist\n"
        },
        {
          "name": "recovery-refresh.cpp",
          "type": "blob",
          "size": 2.5888671875,
          "content": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//\n// Strictly to deal with reboot into system after OTA, then\n// reboot while in system before boot complete landing us back\n// into recovery to continue with any mitigations with retained\n// log history. This simply refreshes the pmsg files from\n// the last pmsg file contents.\n//\n// Usage:\n//    recovery-refresh [--force-rotate|--rotate]\n//\n//    All file content representing in the recovery/ directory stored in\n//    /sys/fs/pstore/pmsg-ramoops-0 in logger format that reside in the\n//    LOG_ID_SYSTEM buffer at ANDROID_LOG_INFO priority or higher is\n//    refreshed into /dev/pmsg0. This ensures that an unexpected reboot\n//    before recovery-persist is run will still contain the associated\n//    pmsg Android Logger content.\n//\n//    --force-rotate  recovery/last_kmsg and recovery.last_log files are\n//                    rotated with .<number> suffixes upwards.\n//    --rotate        rotated only if rocovery/last_msg or recovery/last_log\n//                    exist, otherwise perform 1:1 refresh.\n//\n\n#include <string.h>\n#include <string>\n\n#include <private/android_logger.h> /* private pmsg functions */\n\n#include \"rotate_logs.h\"\n\nint main(int argc, char **argv) {\n    static const char filter[] = \"recovery/\";\n    static const char force_rotate_flag[] = \"--force-rotate\";\n    static const char rotate_flag[] = \"--rotate\";\n    ssize_t ret;\n    bool doRotate = false;\n    // Take last pmsg contents and rewrite it to the current pmsg session.\n    if ((argc <= 1) || !argv[1] ||\n            (((doRotate = strcmp(argv[1], rotate_flag))) &&\n                strcmp(argv[1], force_rotate_flag))) {\n        doRotate = false;\n    } else if (!doRotate) {\n        // Do we need to rotate?\n        __android_log_pmsg_file_read(\n            LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter,\n            logbasename, &doRotate);\n    }\n\n    // Take action to refresh pmsg contents\n    ret = __android_log_pmsg_file_read(\n        LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter,\n        logrotate, &doRotate);\n\n    return (ret < 0) ? ret : 0;\n}\n"
        },
        {
          "name": "recovery-refresh.rc",
          "type": "blob",
          "size": 0.07421875,
          "content": "on post-fs\n    exec_background - system log -- /system/bin/recovery-refresh\n"
        },
        {
          "name": "recovery.cpp",
          "type": "blob",
          "size": 56.59375,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <linux/fs.h>\n#include <linux/input.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/klog.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <chrono>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/parseint.h>\n#include <android-base/properties.h>\n#include <android-base/stringprintf.h>\n#include <android-base/strings.h>\n#include <android-base/unique_fd.h>\n#include <bootloader_message/bootloader_message.h>\n#include <cutils/android_reboot.h>\n#include <cutils/properties.h> /* for property_list */\n#include <health2/Health.h>\n#include <private/android_filesystem_config.h> /* for AID_SYSTEM */\n#include <private/android_logger.h>            /* private pmsg functions */\n#include <selinux/android.h>\n#include <selinux/label.h>\n#include <selinux/selinux.h>\n#include <ziparchive/zip_archive.h>\n\n#include \"adb_install.h\"\n#include \"common.h\"\n#include \"device.h\"\n#include \"fuse_sdcard_provider.h\"\n#include \"fuse_sideload.h\"\n#include \"install.h\"\n#include \"minadbd/minadbd.h\"\n#include \"minui/minui.h\"\n#include \"otautil/DirUtil.h\"\n#include \"otautil/error_code.h\"\n#include \"roots.h\"\n#include \"rotate_logs.h\"\n#include \"screen_ui.h\"\n#include \"stub_ui.h\"\n#include \"ui.h\"\n\nstatic const struct option OPTIONS[] = {\n  { \"update_package\", required_argument, NULL, 'u' },\n  { \"retry_count\", required_argument, NULL, 'n' },\n  { \"wipe_data\", no_argument, NULL, 'w' },\n  { \"wipe_cache\", no_argument, NULL, 'c' },\n  { \"show_text\", no_argument, NULL, 't' },\n  { \"sideload\", no_argument, NULL, 's' },\n  { \"sideload_auto_reboot\", no_argument, NULL, 'a' },\n  { \"just_exit\", no_argument, NULL, 'x' },\n  { \"locale\", required_argument, NULL, 'l' },\n  { \"shutdown_after\", no_argument, NULL, 'p' },\n  { \"reason\", required_argument, NULL, 'r' },\n  { \"security\", no_argument, NULL, 'e'},\n  { \"wipe_ab\", no_argument, NULL, 0 },\n  { \"wipe_package_size\", required_argument, NULL, 0 },\n  { \"prompt_and_wipe_data\", no_argument, NULL, 0 },\n  { NULL, 0, NULL, 0 },\n};\n\n// More bootreasons can be found in \"system/core/bootstat/bootstat.cpp\".\nstatic const std::vector<std::string> bootreason_blacklist {\n  \"kernel_panic\",\n  \"Panic\",\n};\n\nstatic const char *CACHE_LOG_DIR = \"/cache/recovery\";\nstatic const char *COMMAND_FILE = \"/cache/recovery/command\";\nstatic const char *LOG_FILE = \"/cache/recovery/log\";\nstatic const char *LAST_INSTALL_FILE = \"/cache/recovery/last_install\";\nstatic const char *LOCALE_FILE = \"/cache/recovery/last_locale\";\nstatic const char *CONVERT_FBE_DIR = \"/tmp/convert_fbe\";\nstatic const char *CONVERT_FBE_FILE = \"/tmp/convert_fbe/convert_fbe\";\nstatic const char *CACHE_ROOT = \"/cache\";\nstatic const char *DATA_ROOT = \"/data\";\nstatic const char* METADATA_ROOT = \"/metadata\";\nstatic const char *SDCARD_ROOT = \"/sdcard\";\nstatic const char *TEMPORARY_LOG_FILE = \"/tmp/recovery.log\";\nstatic const char *TEMPORARY_INSTALL_FILE = \"/tmp/last_install\";\nstatic const char *LAST_KMSG_FILE = \"/cache/recovery/last_kmsg\";\nstatic const char *LAST_LOG_FILE = \"/cache/recovery/last_log\";\n// We will try to apply the update package 5 times at most in case of an I/O error or\n// bspatch | imgpatch error.\nstatic const int RETRY_LIMIT = 4;\nstatic const int BATTERY_READ_TIMEOUT_IN_SEC = 10;\n// GmsCore enters recovery mode to install package when having enough battery\n// percentage. Normally, the threshold is 40% without charger and 20% with charger.\n// So we should check battery with a slightly lower limitation.\nstatic const int BATTERY_OK_PERCENTAGE = 20;\nstatic const int BATTERY_WITH_CHARGER_OK_PERCENTAGE = 15;\nstatic constexpr const char* RECOVERY_WIPE = \"/etc/recovery.wipe\";\nstatic constexpr const char* DEFAULT_LOCALE = \"en-US\";\n\n// We define RECOVERY_API_VERSION in Android.mk, which will be picked up by build system and packed\n// into target_files.zip. Assert the version defined in code and in Android.mk are consistent.\nstatic_assert(kRecoveryApiVersion == RECOVERY_API_VERSION, \"Mismatching recovery API versions.\");\n\nstatic std::string locale;\nstatic bool has_cache = false;\n\nRecoveryUI* ui = nullptr;\nbool modified_flash = false;\nstd::string stage;\nconst char* reason = nullptr;\nstruct selabel_handle* sehandle;\n\n/*\n * The recovery tool communicates with the main system through /cache files.\n *   /cache/recovery/command - INPUT - command line for tool, one arg per line\n *   /cache/recovery/log - OUTPUT - combined log file from recovery run(s)\n *\n * The arguments which may be supplied in the recovery.command file:\n *   --update_package=path - verify install an OTA package file\n *   --wipe_data - erase user data (and cache), then reboot\n *   --prompt_and_wipe_data - prompt the user that data is corrupt,\n *       with their consent erase user data (and cache), then reboot\n *   --wipe_cache - wipe cache (but not user data), then reboot\n *   --set_encrypted_filesystem=on|off - enables / diasables encrypted fs\n *   --just_exit - do nothing; exit and reboot\n *\n * After completing, we remove /cache/recovery/command and reboot.\n * Arguments may also be supplied in the bootloader control block (BCB).\n * These important scenarios must be safely restartable at any point:\n *\n * FACTORY RESET\n * 1. user selects \"factory reset\"\n * 2. main system writes \"--wipe_data\" to /cache/recovery/command\n * 3. main system reboots into recovery\n * 4. get_args() writes BCB with \"boot-recovery\" and \"--wipe_data\"\n *    -- after this, rebooting will restart the erase --\n * 5. erase_volume() reformats /data\n * 6. erase_volume() reformats /cache\n * 7. finish_recovery() erases BCB\n *    -- after this, rebooting will restart the main system --\n * 8. main() calls reboot() to boot main system\n *\n * OTA INSTALL\n * 1. main system downloads OTA package to /cache/some-filename.zip\n * 2. main system writes \"--update_package=/cache/some-filename.zip\"\n * 3. main system reboots into recovery\n * 4. get_args() writes BCB with \"boot-recovery\" and \"--update_package=...\"\n *    -- after this, rebooting will attempt to reinstall the update --\n * 5. install_package() attempts to install the update\n *    NOTE: the package install must itself be restartable from any point\n * 6. finish_recovery() erases BCB\n *    -- after this, rebooting will (try to) restart the main system --\n * 7. ** if install failed **\n *    7a. prompt_and_wait() shows an error icon and waits for the user\n *    7b. the user reboots (pulling the battery, etc) into the main system\n */\n\n// Open a given path, mounting partitions as necessary.\nFILE* fopen_path(const char* path, const char* mode) {\n  if (ensure_path_mounted(path) != 0) {\n    LOG(ERROR) << \"Can't mount \" << path;\n    return nullptr;\n  }\n\n  // When writing, try to create the containing directory, if necessary. Use generous permissions,\n  // the system (init.rc) will reset them.\n  if (strchr(\"wa\", mode[0])) {\n    mkdir_recursively(path, 0777, true, sehandle);\n  }\n  return fopen(path, mode);\n}\n\n// close a file, log an error if the error indicator is set\nstatic void check_and_fclose(FILE *fp, const char *name) {\n    fflush(fp);\n    if (fsync(fileno(fp)) == -1) {\n        PLOG(ERROR) << \"Failed to fsync \" << name;\n    }\n    if (ferror(fp)) {\n        PLOG(ERROR) << \"Error in \" << name;\n    }\n    fclose(fp);\n}\n\nbool is_ro_debuggable() {\n    return android::base::GetBoolProperty(\"ro.debuggable\", false);\n}\n\nbool reboot(const std::string& command) {\n    std::string cmd = command;\n    if (android::base::GetBoolProperty(\"ro.boot.quiescent\", false)) {\n        cmd += \",quiescent\";\n    }\n    return android::base::SetProperty(ANDROID_RB_PROPERTY, cmd);\n}\n\nstatic void redirect_stdio(const char* filename) {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        PLOG(ERROR) << \"pipe failed\";\n\n        // Fall back to traditional logging mode without timestamps.\n        // If these fail, there's not really anywhere to complain...\n        freopen(filename, \"a\", stdout); setbuf(stdout, NULL);\n        freopen(filename, \"a\", stderr); setbuf(stderr, NULL);\n\n        return;\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        PLOG(ERROR) << \"fork failed\";\n\n        // Fall back to traditional logging mode without timestamps.\n        // If these fail, there's not really anywhere to complain...\n        freopen(filename, \"a\", stdout); setbuf(stdout, NULL);\n        freopen(filename, \"a\", stderr); setbuf(stderr, NULL);\n\n        return;\n    }\n\n    if (pid == 0) {\n        /// Close the unused write end.\n        close(pipefd[1]);\n\n        auto start = std::chrono::steady_clock::now();\n\n        // Child logger to actually write to the log file.\n        FILE* log_fp = fopen(filename, \"ae\");\n        if (log_fp == nullptr) {\n            PLOG(ERROR) << \"fopen \\\"\" << filename << \"\\\" failed\";\n            close(pipefd[0]);\n            _exit(EXIT_FAILURE);\n        }\n\n        FILE* pipe_fp = fdopen(pipefd[0], \"r\");\n        if (pipe_fp == nullptr) {\n            PLOG(ERROR) << \"fdopen failed\";\n            check_and_fclose(log_fp, filename);\n            close(pipefd[0]);\n            _exit(EXIT_FAILURE);\n        }\n\n        char* line = nullptr;\n        size_t len = 0;\n        while (getline(&line, &len, pipe_fp) != -1) {\n            auto now = std::chrono::steady_clock::now();\n            double duration = std::chrono::duration_cast<std::chrono::duration<double>>(\n                    now - start).count();\n            if (line[0] == '\\n') {\n                fprintf(log_fp, \"[%12.6lf]\\n\", duration);\n            } else {\n                fprintf(log_fp, \"[%12.6lf] %s\", duration, line);\n            }\n            fflush(log_fp);\n        }\n\n        PLOG(ERROR) << \"getline failed\";\n\n        free(line);\n        check_and_fclose(log_fp, filename);\n        close(pipefd[0]);\n        _exit(EXIT_FAILURE);\n    } else {\n        // Redirect stdout/stderr to the logger process.\n        // Close the unused read end.\n        close(pipefd[0]);\n\n        setbuf(stdout, nullptr);\n        setbuf(stderr, nullptr);\n\n        if (dup2(pipefd[1], STDOUT_FILENO) == -1) {\n            PLOG(ERROR) << \"dup2 stdout failed\";\n        }\n        if (dup2(pipefd[1], STDERR_FILENO) == -1) {\n            PLOG(ERROR) << \"dup2 stderr failed\";\n        }\n\n        close(pipefd[1]);\n    }\n}\n\n// command line args come from, in decreasing precedence:\n//   - the actual command line\n//   - the bootloader control block (one per line, after \"recovery\")\n//   - the contents of COMMAND_FILE (one per line)\nstatic std::vector<std::string> get_args(const int argc, char** const argv) {\n  CHECK_GT(argc, 0);\n\n  bootloader_message boot = {};\n  std::string err;\n  if (!read_bootloader_message(&boot, &err)) {\n    LOG(ERROR) << err;\n    // If fails, leave a zeroed bootloader_message.\n    boot = {};\n  }\n  stage = std::string(boot.stage);\n\n  if (boot.command[0] != 0) {\n    std::string boot_command = std::string(boot.command, sizeof(boot.command));\n    LOG(INFO) << \"Boot command: \" << boot_command;\n  }\n\n  if (boot.status[0] != 0) {\n    std::string boot_status = std::string(boot.status, sizeof(boot.status));\n    LOG(INFO) << \"Boot status: \" << boot_status;\n  }\n\n  std::vector<std::string> args(argv, argv + argc);\n\n  // --- if arguments weren't supplied, look in the bootloader control block\n  if (args.size() == 1) {\n    boot.recovery[sizeof(boot.recovery) - 1] = '\\0';  // Ensure termination\n    std::string boot_recovery(boot.recovery);\n    std::vector<std::string> tokens = android::base::Split(boot_recovery, \"\\n\");\n    if (!tokens.empty() && tokens[0] == \"recovery\") {\n      for (auto it = tokens.begin() + 1; it != tokens.end(); it++) {\n        // Skip empty and '\\0'-filled tokens.\n        if (!it->empty() && (*it)[0] != '\\0') args.push_back(std::move(*it));\n      }\n      LOG(INFO) << \"Got \" << args.size() << \" arguments from boot message\";\n    } else if (boot.recovery[0] != 0) {\n      LOG(ERROR) << \"Bad boot message: \\\"\" << boot_recovery << \"\\\"\";\n    }\n  }\n\n  // --- if that doesn't work, try the command file (if we have /cache).\n  if (args.size() == 1 && has_cache) {\n    std::string content;\n    if (ensure_path_mounted(COMMAND_FILE) == 0 &&\n        android::base::ReadFileToString(COMMAND_FILE, &content)) {\n      std::vector<std::string> tokens = android::base::Split(content, \"\\n\");\n      // All the arguments in COMMAND_FILE are needed (unlike the BCB message,\n      // COMMAND_FILE doesn't use filename as the first argument).\n      for (auto it = tokens.begin(); it != tokens.end(); it++) {\n        // Skip empty and '\\0'-filled tokens.\n        if (!it->empty() && (*it)[0] != '\\0') args.push_back(std::move(*it));\n      }\n      LOG(INFO) << \"Got \" << args.size() << \" arguments from \" << COMMAND_FILE;\n    }\n  }\n\n  // Write the arguments (excluding the filename in args[0]) back into the\n  // bootloader control block. So the device will always boot into recovery to\n  // finish the pending work, until finish_recovery() is called.\n  std::vector<std::string> options(args.cbegin() + 1, args.cend());\n  if (!update_bootloader_message(options, &err)) {\n    LOG(ERROR) << \"Failed to set BCB message: \" << err;\n  }\n\n  return args;\n}\n\n// Set the BCB to reboot back into recovery (it won't resume the install from\n// sdcard though).\nstatic void set_sdcard_update_bootloader_message() {\n  std::vector<std::string> options;\n  std::string err;\n  if (!update_bootloader_message(options, &err)) {\n    LOG(ERROR) << \"Failed to set BCB message: \" << err;\n  }\n}\n\n// Read from kernel log into buffer and write out to file.\nstatic void save_kernel_log(const char* destination) {\n    int klog_buf_len = klogctl(KLOG_SIZE_BUFFER, 0, 0);\n    if (klog_buf_len <= 0) {\n        PLOG(ERROR) << \"Error getting klog size\";\n        return;\n    }\n\n    std::string buffer(klog_buf_len, 0);\n    int n = klogctl(KLOG_READ_ALL, &buffer[0], klog_buf_len);\n    if (n == -1) {\n        PLOG(ERROR) << \"Error in reading klog\";\n        return;\n    }\n    buffer.resize(n);\n    android::base::WriteStringToFile(buffer, destination);\n}\n\n// write content to the current pmsg session.\nstatic ssize_t __pmsg_write(const char *filename, const char *buf, size_t len) {\n    return __android_log_pmsg_file_write(LOG_ID_SYSTEM, ANDROID_LOG_INFO,\n                                         filename, buf, len);\n}\n\nstatic void copy_log_file_to_pmsg(const char* source, const char* destination) {\n    std::string content;\n    android::base::ReadFileToString(source, &content);\n    __pmsg_write(destination, content.c_str(), content.length());\n}\n\n// How much of the temp log we have copied to the copy in cache.\nstatic off_t tmplog_offset = 0;\n\nstatic void copy_log_file(const char* source, const char* destination, bool append) {\n  FILE* dest_fp = fopen_path(destination, append ? \"ae\" : \"we\");\n  if (dest_fp == nullptr) {\n    PLOG(ERROR) << \"Can't open \" << destination;\n  } else {\n    FILE* source_fp = fopen(source, \"re\");\n    if (source_fp != nullptr) {\n      if (append) {\n        fseeko(source_fp, tmplog_offset, SEEK_SET);  // Since last write\n      }\n      char buf[4096];\n      size_t bytes;\n      while ((bytes = fread(buf, 1, sizeof(buf), source_fp)) != 0) {\n        fwrite(buf, 1, bytes, dest_fp);\n      }\n      if (append) {\n        tmplog_offset = ftello(source_fp);\n      }\n      check_and_fclose(source_fp, source);\n    }\n    check_and_fclose(dest_fp, destination);\n  }\n}\n\nstatic void copy_logs() {\n    // We only rotate and record the log of the current session if there are\n    // actual attempts to modify the flash, such as wipes, installs from BCB\n    // or menu selections. This is to avoid unnecessary rotation (and\n    // possible deletion) of log files, if it does not do anything loggable.\n    if (!modified_flash) {\n        return;\n    }\n\n    // Always write to pmsg, this allows the OTA logs to be caught in logcat -L\n    copy_log_file_to_pmsg(TEMPORARY_LOG_FILE, LAST_LOG_FILE);\n    copy_log_file_to_pmsg(TEMPORARY_INSTALL_FILE, LAST_INSTALL_FILE);\n\n    // We can do nothing for now if there's no /cache partition.\n    if (!has_cache) {\n        return;\n    }\n\n    ensure_path_mounted(LAST_LOG_FILE);\n    ensure_path_mounted(LAST_KMSG_FILE);\n    rotate_logs(LAST_LOG_FILE, LAST_KMSG_FILE);\n\n    // Copy logs to cache so the system can find out what happened.\n    copy_log_file(TEMPORARY_LOG_FILE, LOG_FILE, true);\n    copy_log_file(TEMPORARY_LOG_FILE, LAST_LOG_FILE, false);\n    copy_log_file(TEMPORARY_INSTALL_FILE, LAST_INSTALL_FILE, false);\n    save_kernel_log(LAST_KMSG_FILE);\n    chmod(LOG_FILE, 0600);\n    chown(LOG_FILE, AID_SYSTEM, AID_SYSTEM);\n    chmod(LAST_KMSG_FILE, 0600);\n    chown(LAST_KMSG_FILE, AID_SYSTEM, AID_SYSTEM);\n    chmod(LAST_LOG_FILE, 0640);\n    chmod(LAST_INSTALL_FILE, 0644);\n    sync();\n}\n\n// Clear the recovery command and prepare to boot a (hopefully working) system,\n// copy our log file to cache as well (for the system to read). This function is\n// idempotent: call it as many times as you like.\nstatic void finish_recovery() {\n  // Save the locale to cache, so if recovery is next started up without a '--locale' argument\n  // (e.g., directly from the bootloader) it will use the last-known locale.\n  if (!locale.empty() && has_cache) {\n    LOG(INFO) << \"Saving locale \\\"\" << locale << \"\\\"\";\n    if (ensure_path_mounted(LOCALE_FILE) != 0) {\n      LOG(ERROR) << \"Failed to mount \" << LOCALE_FILE;\n    } else if (!android::base::WriteStringToFile(locale, LOCALE_FILE)) {\n      PLOG(ERROR) << \"Failed to save locale to \" << LOCALE_FILE;\n    }\n  }\n\n  copy_logs();\n\n  // Reset to normal system boot so recovery won't cycle indefinitely.\n  std::string err;\n  if (!clear_bootloader_message(&err)) {\n    LOG(ERROR) << \"Failed to clear BCB message: \" << err;\n  }\n\n  // Remove the command file, so recovery won't repeat indefinitely.\n  if (has_cache) {\n    if (ensure_path_mounted(COMMAND_FILE) != 0 || (unlink(COMMAND_FILE) && errno != ENOENT)) {\n      LOG(WARNING) << \"Can't unlink \" << COMMAND_FILE;\n    }\n    ensure_path_unmounted(CACHE_ROOT);\n  }\n\n  sync();  // For good measure.\n}\n\nstruct saved_log_file {\n  std::string name;\n  struct stat sb;\n  std::string data;\n};\n\nstatic bool erase_volume(const char* volume) {\n  bool is_cache = (strcmp(volume, CACHE_ROOT) == 0);\n  bool is_data = (strcmp(volume, DATA_ROOT) == 0);\n\n  ui->SetBackground(RecoveryUI::ERASING);\n  ui->SetProgressType(RecoveryUI::INDETERMINATE);\n\n  std::vector<saved_log_file> log_files;\n\n  if (is_cache) {\n    // If we're reformatting /cache, we load any past logs\n    // (i.e. \"/cache/recovery/last_*\") and the current log\n    // (\"/cache/recovery/log\") into memory, so we can restore them after\n    // the reformat.\n\n    ensure_path_mounted(volume);\n\n    struct dirent* de;\n    std::unique_ptr<DIR, decltype(&closedir)> d(opendir(CACHE_LOG_DIR), closedir);\n    if (d) {\n      while ((de = readdir(d.get())) != nullptr) {\n        if (strncmp(de->d_name, \"last_\", 5) == 0 || strcmp(de->d_name, \"log\") == 0) {\n          std::string path = android::base::StringPrintf(\"%s/%s\", CACHE_LOG_DIR, de->d_name);\n\n          struct stat sb;\n          if (stat(path.c_str(), &sb) == 0) {\n            // truncate files to 512kb\n            if (sb.st_size > (1 << 19)) {\n              sb.st_size = 1 << 19;\n            }\n\n            std::string data(sb.st_size, '\\0');\n            FILE* f = fopen(path.c_str(), \"rbe\");\n            fread(&data[0], 1, data.size(), f);\n            fclose(f);\n\n            log_files.emplace_back(saved_log_file{ path, sb, data });\n          }\n        }\n      }\n    } else {\n      if (errno != ENOENT) {\n        PLOG(ERROR) << \"Failed to opendir \" << CACHE_LOG_DIR;\n      }\n    }\n  }\n\n  ui->Print(\"Formatting %s...\\n\", volume);\n\n  ensure_path_unmounted(volume);\n\n  int result;\n\n  if (is_data && reason && strcmp(reason, \"convert_fbe\") == 0) {\n    // Create convert_fbe breadcrumb file to signal to init\n    // to convert to file based encryption, not full disk encryption\n    if (mkdir(CONVERT_FBE_DIR, 0700) != 0) {\n      ui->Print(\"Failed to make convert_fbe dir %s\\n\", strerror(errno));\n      return true;\n    }\n    FILE* f = fopen(CONVERT_FBE_FILE, \"wbe\");\n    if (!f) {\n      ui->Print(\"Failed to convert to file encryption %s\\n\", strerror(errno));\n      return true;\n    }\n    fclose(f);\n    result = format_volume(volume, CONVERT_FBE_DIR);\n    remove(CONVERT_FBE_FILE);\n    rmdir(CONVERT_FBE_DIR);\n  } else {\n    result = format_volume(volume);\n  }\n\n  if (is_cache) {\n    // Re-create the log dir and write back the log entries.\n    if (ensure_path_mounted(CACHE_LOG_DIR) == 0 &&\n        mkdir_recursively(CACHE_LOG_DIR, 0777, false, sehandle) == 0) {\n      for (const auto& log : log_files) {\n        if (!android::base::WriteStringToFile(log.data, log.name, log.sb.st_mode, log.sb.st_uid,\n                                              log.sb.st_gid)) {\n          PLOG(ERROR) << \"Failed to write to \" << log.name;\n        }\n      }\n    } else {\n      PLOG(ERROR) << \"Failed to mount / create \" << CACHE_LOG_DIR;\n    }\n\n    // Any part of the log we'd copied to cache is now gone.\n    // Reset the pointer so we copy from the beginning of the temp\n    // log.\n    tmplog_offset = 0;\n    copy_logs();\n  }\n\n  return (result == 0);\n}\n\n// Display a menu with the specified 'headers' and 'items'. Device specific HandleMenuKey() may\n// return a positive number beyond the given range. Caller sets 'menu_only' to true to ensure only\n// a menu item gets selected. 'initial_selection' controls the initial cursor location. Returns the\n// (non-negative) chosen item number, or -1 if timed out waiting for input.\nstatic int get_menu_selection(const char* const* headers, const char* const* items, bool menu_only,\n                              int initial_selection, Device* device) {\n  // Throw away keys pressed previously, so user doesn't accidentally trigger menu items.\n  ui->FlushKeys();\n\n  ui->StartMenu(headers, items, initial_selection);\n\n  int selected = initial_selection;\n  int chosen_item = -1;\n  while (chosen_item < 0) {\n    int key = ui->WaitKey();\n    if (key == -1) {  // WaitKey() timed out.\n      if (ui->WasTextEverVisible()) {\n        continue;\n      } else {\n        LOG(INFO) << \"Timed out waiting for key input; rebooting.\";\n        ui->EndMenu();\n        return -1;\n      }\n    }\n\n    bool visible = ui->IsTextVisible();\n    int action = device->HandleMenuKey(key, visible);\n\n    if (action < 0) {\n      switch (action) {\n        case Device::kHighlightUp:\n          selected = ui->SelectMenu(--selected);\n          break;\n        case Device::kHighlightDown:\n          selected = ui->SelectMenu(++selected);\n          break;\n        case Device::kInvokeItem:\n          chosen_item = selected;\n          break;\n        case Device::kNoAction:\n          break;\n      }\n    } else if (!menu_only) {\n      chosen_item = action;\n    }\n  }\n\n  ui->EndMenu();\n  return chosen_item;\n}\n\n// Returns the selected filename, or an empty string.\nstatic std::string browse_directory(const std::string& path, Device* device) {\n  ensure_path_mounted(path.c_str());\n\n  std::unique_ptr<DIR, decltype(&closedir)> d(opendir(path.c_str()), closedir);\n  if (!d) {\n    PLOG(ERROR) << \"error opening \" << path;\n    return \"\";\n  }\n\n  std::vector<std::string> dirs;\n  std::vector<std::string> zips = { \"../\" };  // \"../\" is always the first entry.\n\n  dirent* de;\n  while ((de = readdir(d.get())) != nullptr) {\n    std::string name(de->d_name);\n\n    if (de->d_type == DT_DIR) {\n      // Skip \".\" and \"..\" entries.\n      if (name == \".\" || name == \"..\") continue;\n      dirs.push_back(name + \"/\");\n    } else if (de->d_type == DT_REG && android::base::EndsWithIgnoreCase(name, \".zip\")) {\n      zips.push_back(name);\n    }\n  }\n\n  std::sort(dirs.begin(), dirs.end());\n  std::sort(zips.begin(), zips.end());\n\n  // Append dirs to the zips list.\n  zips.insert(zips.end(), dirs.begin(), dirs.end());\n\n  const char* entries[zips.size() + 1];\n  entries[zips.size()] = nullptr;\n  for (size_t i = 0; i < zips.size(); i++) {\n    entries[i] = zips[i].c_str();\n  }\n\n  const char* headers[] = { \"Choose a package to install:\", path.c_str(), nullptr };\n\n  int chosen_item = 0;\n  while (true) {\n    chosen_item = get_menu_selection(headers, entries, true, chosen_item, device);\n\n    const std::string& item = zips[chosen_item];\n    if (chosen_item == 0) {\n      // Go up but continue browsing (if the caller is browse_directory).\n      return \"\";\n    }\n\n    std::string new_path = path + \"/\" + item;\n    if (new_path.back() == '/') {\n      // Recurse down into a subdirectory.\n      new_path.pop_back();\n      std::string result = browse_directory(new_path, device);\n      if (!result.empty()) return result;\n    } else {\n      // Selected a zip file: return the path to the caller.\n      return new_path;\n    }\n  }\n\n  // Unreachable.\n}\n\nstatic bool yes_no(Device* device, const char* question1, const char* question2) {\n    const char* headers[] = { question1, question2, NULL };\n    const char* items[] = { \" No\", \" Yes\", NULL };\n\n    int chosen_item = get_menu_selection(headers, items, true, 0, device);\n    return (chosen_item == 1);\n}\n\nstatic bool ask_to_wipe_data(Device* device) {\n    return yes_no(device, \"Wipe all user data?\", \"  THIS CAN NOT BE UNDONE!\");\n}\n\n// Return true on success.\nstatic bool wipe_data(Device* device) {\n    modified_flash = true;\n\n    ui->Print(\"\\n-- Wiping data...\\n\");\n    bool success = device->PreWipeData();\n    if (success) {\n      success &= erase_volume(DATA_ROOT);\n      if (has_cache) {\n        success &= erase_volume(CACHE_ROOT);\n      }\n      if (volume_for_mount_point(METADATA_ROOT) != nullptr) {\n        success &= erase_volume(METADATA_ROOT);\n      }\n    }\n    if (success) {\n      success &= device->PostWipeData();\n    }\n    ui->Print(\"Data wipe %s.\\n\", success ? \"complete\" : \"failed\");\n    return success;\n}\n\nstatic bool prompt_and_wipe_data(Device* device) {\n  // Use a single string and let ScreenRecoveryUI handles the wrapping.\n  const char* const headers[] = {\n    \"Can't load Android system. Your data may be corrupt. \"\n    \"If you continue to get this message, you may need to \"\n    \"perform a factory data reset and erase all user data \"\n    \"stored on this device.\",\n    nullptr\n  };\n  const char* const items[] = {\n    \"Try again\",\n    \"Factory data reset\",\n    NULL\n  };\n  for (;;) {\n    int chosen_item = get_menu_selection(headers, items, true, 0, device);\n    if (chosen_item != 1) {\n      return true;  // Just reboot, no wipe; not a failure, user asked for it\n    }\n    if (ask_to_wipe_data(device)) {\n      return wipe_data(device);\n    }\n  }\n}\n\n// Return true on success.\nstatic bool wipe_cache(bool should_confirm, Device* device) {\n    if (!has_cache) {\n        ui->Print(\"No /cache partition found.\\n\");\n        return false;\n    }\n\n    if (should_confirm && !yes_no(device, \"Wipe cache?\", \"  THIS CAN NOT BE UNDONE!\")) {\n        return false;\n    }\n\n    modified_flash = true;\n\n    ui->Print(\"\\n-- Wiping cache...\\n\");\n    bool success = erase_volume(\"/cache\");\n    ui->Print(\"Cache wipe %s.\\n\", success ? \"complete\" : \"failed\");\n    return success;\n}\n\n// Secure-wipe a given partition. It uses BLKSECDISCARD, if supported. Otherwise, it goes with\n// BLKDISCARD (if device supports BLKDISCARDZEROES) or BLKZEROOUT.\nstatic bool secure_wipe_partition(const std::string& partition) {\n  android::base::unique_fd fd(TEMP_FAILURE_RETRY(open(partition.c_str(), O_WRONLY)));\n  if (fd == -1) {\n    PLOG(ERROR) << \"Failed to open \\\"\" << partition << \"\\\"\";\n    return false;\n  }\n\n  uint64_t range[2] = { 0, 0 };\n  if (ioctl(fd, BLKGETSIZE64, &range[1]) == -1 || range[1] == 0) {\n    PLOG(ERROR) << \"Failed to get partition size\";\n    return false;\n  }\n  LOG(INFO) << \"Secure-wiping \\\"\" << partition << \"\\\" from \" << range[0] << \" to \" << range[1];\n\n  LOG(INFO) << \"  Trying BLKSECDISCARD...\";\n  if (ioctl(fd, BLKSECDISCARD, &range) == -1) {\n    PLOG(WARNING) << \"  Failed\";\n\n    // Use BLKDISCARD if it zeroes out blocks, otherwise use BLKZEROOUT.\n    unsigned int zeroes;\n    if (ioctl(fd, BLKDISCARDZEROES, &zeroes) == 0 && zeroes != 0) {\n      LOG(INFO) << \"  Trying BLKDISCARD...\";\n      if (ioctl(fd, BLKDISCARD, &range) == -1) {\n        PLOG(ERROR) << \"  Failed\";\n        return false;\n      }\n    } else {\n      LOG(INFO) << \"  Trying BLKZEROOUT...\";\n      if (ioctl(fd, BLKZEROOUT, &range) == -1) {\n        PLOG(ERROR) << \"  Failed\";\n        return false;\n      }\n    }\n  }\n\n  LOG(INFO) << \"  Done\";\n  return true;\n}\n\n// Check if the wipe package matches expectation:\n// 1. verify the package.\n// 2. check metadata (ota-type, pre-device and serial number if having one).\nstatic bool check_wipe_package(size_t wipe_package_size) {\n    if (wipe_package_size == 0) {\n        LOG(ERROR) << \"wipe_package_size is zero\";\n        return false;\n    }\n    std::string wipe_package;\n    std::string err_str;\n    if (!read_wipe_package(&wipe_package, wipe_package_size, &err_str)) {\n        PLOG(ERROR) << \"Failed to read wipe package\";\n        return false;\n    }\n    if (!verify_package(reinterpret_cast<const unsigned char*>(wipe_package.data()),\n                        wipe_package.size())) {\n        LOG(ERROR) << \"Failed to verify package\";\n        return false;\n    }\n\n    // Extract metadata\n    ZipArchiveHandle zip;\n    int err = OpenArchiveFromMemory(static_cast<void*>(&wipe_package[0]), wipe_package.size(),\n                                    \"wipe_package\", &zip);\n    if (err != 0) {\n        LOG(ERROR) << \"Can't open wipe package : \" << ErrorCodeString(err);\n        return false;\n    }\n    std::string metadata;\n    if (!read_metadata_from_package(zip, &metadata)) {\n        CloseArchive(zip);\n        return false;\n    }\n    CloseArchive(zip);\n\n    // Check metadata\n    std::vector<std::string> lines = android::base::Split(metadata, \"\\n\");\n    bool ota_type_matched = false;\n    bool device_type_matched = false;\n    bool has_serial_number = false;\n    bool serial_number_matched = false;\n    for (const auto& line : lines) {\n        if (line == \"ota-type=BRICK\") {\n            ota_type_matched = true;\n        } else if (android::base::StartsWith(line, \"pre-device=\")) {\n            std::string device_type = line.substr(strlen(\"pre-device=\"));\n            std::string real_device_type = android::base::GetProperty(\"ro.build.product\", \"\");\n            device_type_matched = (device_type == real_device_type);\n        } else if (android::base::StartsWith(line, \"serialno=\")) {\n            std::string serial_no = line.substr(strlen(\"serialno=\"));\n            std::string real_serial_no = android::base::GetProperty(\"ro.serialno\", \"\");\n            has_serial_number = true;\n            serial_number_matched = (serial_no == real_serial_no);\n        }\n    }\n    return ota_type_matched && device_type_matched && (!has_serial_number || serial_number_matched);\n}\n\n// Wipe the current A/B device, with a secure wipe of all the partitions in\n// RECOVERY_WIPE.\nstatic bool wipe_ab_device(size_t wipe_package_size) {\n    ui->SetBackground(RecoveryUI::ERASING);\n    ui->SetProgressType(RecoveryUI::INDETERMINATE);\n\n    if (!check_wipe_package(wipe_package_size)) {\n        LOG(ERROR) << \"Failed to verify wipe package\";\n        return false;\n    }\n    std::string partition_list;\n    if (!android::base::ReadFileToString(RECOVERY_WIPE, &partition_list)) {\n        LOG(ERROR) << \"failed to read \\\"\" << RECOVERY_WIPE << \"\\\"\";\n        return false;\n    }\n\n    std::vector<std::string> lines = android::base::Split(partition_list, \"\\n\");\n    for (const std::string& line : lines) {\n        std::string partition = android::base::Trim(line);\n        // Ignore '#' comment or empty lines.\n        if (android::base::StartsWith(partition, \"#\") || partition.empty()) {\n            continue;\n        }\n\n        // Proceed anyway even if it fails to wipe some partition.\n        secure_wipe_partition(partition);\n    }\n    return true;\n}\n\nstatic void choose_recovery_file(Device* device) {\n  std::vector<std::string> entries;\n  if (has_cache) {\n    for (int i = 0; i < KEEP_LOG_COUNT; i++) {\n      auto add_to_entries = [&](const char* filename) {\n        std::string log_file(filename);\n        if (i > 0) {\n          log_file += \".\" + std::to_string(i);\n        }\n\n        if (ensure_path_mounted(log_file.c_str()) == 0 && access(log_file.c_str(), R_OK) == 0) {\n          entries.push_back(std::move(log_file));\n        }\n      };\n\n      // Add LAST_LOG_FILE + LAST_LOG_FILE.x\n      add_to_entries(LAST_LOG_FILE);\n\n      // Add LAST_KMSG_FILE + LAST_KMSG_FILE.x\n      add_to_entries(LAST_KMSG_FILE);\n    }\n  } else {\n    // If cache partition is not found, view /tmp/recovery.log instead.\n    if (access(TEMPORARY_LOG_FILE, R_OK) == -1) {\n      return;\n    } else {\n      entries.push_back(TEMPORARY_LOG_FILE);\n    }\n  }\n\n  entries.push_back(\"Back\");\n\n  std::vector<const char*> menu_entries(entries.size());\n  std::transform(entries.cbegin(), entries.cend(), menu_entries.begin(),\n                 [](const std::string& entry) { return entry.c_str(); });\n  menu_entries.push_back(nullptr);\n\n  const char* headers[] = { \"Select file to view\", nullptr };\n\n  int chosen_item = 0;\n  while (true) {\n    chosen_item = get_menu_selection(headers, menu_entries.data(), true, chosen_item, device);\n    if (entries[chosen_item] == \"Back\") break;\n\n    ui->ShowFile(entries[chosen_item].c_str());\n  }\n}\n\nstatic void run_graphics_test() {\n  // Switch to graphics screen.\n  ui->ShowText(false);\n\n  ui->SetProgressType(RecoveryUI::INDETERMINATE);\n  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);\n  sleep(1);\n\n  ui->SetBackground(RecoveryUI::ERROR);\n  sleep(1);\n\n  ui->SetBackground(RecoveryUI::NO_COMMAND);\n  sleep(1);\n\n  ui->SetBackground(RecoveryUI::ERASING);\n  sleep(1);\n\n  // Calling SetBackground() after SetStage() to trigger a redraw.\n  ui->SetStage(1, 3);\n  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);\n  sleep(1);\n  ui->SetStage(2, 3);\n  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);\n  sleep(1);\n  ui->SetStage(3, 3);\n  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);\n  sleep(1);\n\n  ui->SetStage(-1, -1);\n  ui->SetBackground(RecoveryUI::INSTALLING_UPDATE);\n\n  ui->SetProgressType(RecoveryUI::DETERMINATE);\n  ui->ShowProgress(1.0, 10.0);\n  float fraction = 0.0;\n  for (size_t i = 0; i < 100; ++i) {\n    fraction += .01;\n    ui->SetProgress(fraction);\n    usleep(100000);\n  }\n\n  ui->ShowText(true);\n}\n\n// How long (in seconds) we wait for the fuse-provided package file to\n// appear, before timing out.\n#define SDCARD_INSTALL_TIMEOUT 10\n\nstatic int apply_from_sdcard(Device* device, bool* wipe_cache) {\n    modified_flash = true;\n\n    if (ensure_path_mounted(SDCARD_ROOT) != 0) {\n        ui->Print(\"\\n-- Couldn't mount %s.\\n\", SDCARD_ROOT);\n        return INSTALL_ERROR;\n    }\n\n    std::string path = browse_directory(SDCARD_ROOT, device);\n    if (path.empty()) {\n        ui->Print(\"\\n-- No package file selected.\\n\");\n        ensure_path_unmounted(SDCARD_ROOT);\n        return INSTALL_ERROR;\n    }\n\n    ui->Print(\"\\n-- Install %s ...\\n\", path.c_str());\n    set_sdcard_update_bootloader_message();\n\n    // We used to use fuse in a thread as opposed to a process. Since accessing\n    // through fuse involves going from kernel to userspace to kernel, it leads\n    // to deadlock when a page fault occurs. (Bug: 26313124)\n    pid_t child;\n    if ((child = fork()) == 0) {\n        bool status = start_sdcard_fuse(path.c_str());\n\n        _exit(status ? EXIT_SUCCESS : EXIT_FAILURE);\n    }\n\n    // FUSE_SIDELOAD_HOST_PATHNAME will start to exist once the fuse in child\n    // process is ready.\n    int result = INSTALL_ERROR;\n    int status;\n    bool waited = false;\n    for (int i = 0; i < SDCARD_INSTALL_TIMEOUT; ++i) {\n        if (waitpid(child, &status, WNOHANG) == -1) {\n            result = INSTALL_ERROR;\n            waited = true;\n            break;\n        }\n\n        struct stat sb;\n        if (stat(FUSE_SIDELOAD_HOST_PATHNAME, &sb) == -1) {\n            if (errno == ENOENT && i < SDCARD_INSTALL_TIMEOUT-1) {\n                sleep(1);\n                continue;\n            } else {\n                LOG(ERROR) << \"Timed out waiting for the fuse-provided package.\";\n                result = INSTALL_ERROR;\n                kill(child, SIGKILL);\n                break;\n            }\n        }\n\n        result = install_package(FUSE_SIDELOAD_HOST_PATHNAME, wipe_cache,\n                                 TEMPORARY_INSTALL_FILE, false, 0/*retry_count*/);\n        break;\n    }\n\n    if (!waited) {\n        // Calling stat() on this magic filename signals the fuse\n        // filesystem to shut down.\n        struct stat sb;\n        stat(FUSE_SIDELOAD_HOST_EXIT_PATHNAME, &sb);\n\n        waitpid(child, &status, 0);\n    }\n\n    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n        LOG(ERROR) << \"Error exit from the fuse process: \" << WEXITSTATUS(status);\n    }\n\n    ensure_path_unmounted(SDCARD_ROOT);\n    return result;\n}\n\n// Returns REBOOT, SHUTDOWN, or REBOOT_BOOTLOADER. Returning NO_ACTION means to take the default,\n// which is to reboot or shutdown depending on if the --shutdown_after flag was passed to recovery.\nstatic Device::BuiltinAction prompt_and_wait(Device* device, int status) {\n  for (;;) {\n    finish_recovery();\n    switch (status) {\n      case INSTALL_SUCCESS:\n      case INSTALL_NONE:\n        ui->SetBackground(RecoveryUI::NO_COMMAND);\n        break;\n\n      case INSTALL_ERROR:\n      case INSTALL_CORRUPT:\n        ui->SetBackground(RecoveryUI::ERROR);\n        break;\n    }\n    ui->SetProgressType(RecoveryUI::EMPTY);\n\n    int chosen_item = get_menu_selection(nullptr, device->GetMenuItems(), false, 0, device);\n\n    // Device-specific code may take some action here. It may return one of the core actions\n    // handled in the switch statement below.\n    Device::BuiltinAction chosen_action =\n        (chosen_item == -1) ? Device::REBOOT : device->InvokeMenuItem(chosen_item);\n\n    bool should_wipe_cache = false;\n    switch (chosen_action) {\n      case Device::NO_ACTION:\n        break;\n\n      case Device::REBOOT:\n      case Device::SHUTDOWN:\n      case Device::REBOOT_BOOTLOADER:\n        return chosen_action;\n\n      case Device::WIPE_DATA:\n        if (ui->IsTextVisible()) {\n          if (ask_to_wipe_data(device)) {\n            wipe_data(device);\n          }\n        } else {\n          wipe_data(device);\n          return Device::NO_ACTION;\n        }\n        break;\n\n      case Device::WIPE_CACHE:\n        wipe_cache(ui->IsTextVisible(), device);\n        if (!ui->IsTextVisible()) return Device::NO_ACTION;\n        break;\n\n      case Device::APPLY_ADB_SIDELOAD:\n      case Device::APPLY_SDCARD:\n        {\n          bool adb = (chosen_action == Device::APPLY_ADB_SIDELOAD);\n          if (adb) {\n            status = apply_from_adb(&should_wipe_cache, TEMPORARY_INSTALL_FILE);\n          } else {\n            status = apply_from_sdcard(device, &should_wipe_cache);\n          }\n\n          if (status == INSTALL_SUCCESS && should_wipe_cache) {\n            if (!wipe_cache(false, device)) {\n              status = INSTALL_ERROR;\n            }\n          }\n\n          if (status != INSTALL_SUCCESS) {\n            ui->SetBackground(RecoveryUI::ERROR);\n            ui->Print(\"Installation aborted.\\n\");\n            copy_logs();\n          } else if (!ui->IsTextVisible()) {\n            return Device::NO_ACTION;  // reboot if logs aren't visible\n          } else {\n            ui->Print(\"\\nInstall from %s complete.\\n\", adb ? \"ADB\" : \"SD card\");\n          }\n        }\n        break;\n\n      case Device::VIEW_RECOVERY_LOGS:\n        choose_recovery_file(device);\n        break;\n\n      case Device::RUN_GRAPHICS_TEST:\n        run_graphics_test();\n        break;\n\n      case Device::RUN_LOCALE_TEST: {\n        ScreenRecoveryUI* screen_ui = static_cast<ScreenRecoveryUI*>(ui);\n        screen_ui->CheckBackgroundTextImages(locale);\n        break;\n      }\n      case Device::MOUNT_SYSTEM:\n        // For a system image built with the root directory (i.e. system_root_image == \"true\"), we\n        // mount it to /system_root, and symlink /system to /system_root/system to make adb shell\n        // work (the symlink is created through the build system). (Bug: 22855115)\n        if (android::base::GetBoolProperty(\"ro.build.system_root_image\", false)) {\n          if (ensure_path_mounted_at(\"/\", \"/system_root\") != -1) {\n            ui->Print(\"Mounted /system.\\n\");\n          }\n        } else {\n          if (ensure_path_mounted(\"/system\") != -1) {\n            ui->Print(\"Mounted /system.\\n\");\n          }\n        }\n        break;\n    }\n  }\n}\n\nstatic void print_property(const char* key, const char* name, void* /* cookie */) {\n  printf(\"%s=%s\\n\", key, name);\n}\n\nstatic std::string load_locale_from_cache() {\n    if (ensure_path_mounted(LOCALE_FILE) != 0) {\n        LOG(ERROR) << \"Can't mount \" << LOCALE_FILE;\n        return \"\";\n    }\n\n    std::string content;\n    if (!android::base::ReadFileToString(LOCALE_FILE, &content)) {\n        PLOG(ERROR) << \"Can't read \" << LOCALE_FILE;\n        return \"\";\n    }\n\n    return android::base::Trim(content);\n}\n\nvoid ui_print(const char* format, ...) {\n    std::string buffer;\n    va_list ap;\n    va_start(ap, format);\n    android::base::StringAppendV(&buffer, format, ap);\n    va_end(ap);\n\n    if (ui != nullptr) {\n        ui->Print(\"%s\", buffer.c_str());\n    } else {\n        fputs(buffer.c_str(), stdout);\n    }\n}\n\nstatic constexpr char log_characters[] = \"VDIWEF\";\n\nvoid UiLogger(android::base::LogId /* id */, android::base::LogSeverity severity,\n              const char* /* tag */, const char* /* file */, unsigned int /* line */,\n              const char* message) {\n  if (severity >= android::base::ERROR && ui != nullptr) {\n    ui->Print(\"E:%s\\n\", message);\n  } else {\n    fprintf(stdout, \"%c:%s\\n\", log_characters[severity], message);\n  }\n}\n\nstatic bool is_battery_ok() {\n  using android::hardware::health::V1_0::BatteryStatus;\n  using android::hardware::health::V2_0::Result;\n  using android::hardware::health::V2_0::toString;\n  using android::hardware::health::V2_0::implementation::Health;\n\n  struct healthd_config healthd_config = {\n    .batteryStatusPath = android::String8(android::String8::kEmptyString),\n    .batteryHealthPath = android::String8(android::String8::kEmptyString),\n    .batteryPresentPath = android::String8(android::String8::kEmptyString),\n    .batteryCapacityPath = android::String8(android::String8::kEmptyString),\n    .batteryVoltagePath = android::String8(android::String8::kEmptyString),\n    .batteryTemperaturePath = android::String8(android::String8::kEmptyString),\n    .batteryTechnologyPath = android::String8(android::String8::kEmptyString),\n    .batteryCurrentNowPath = android::String8(android::String8::kEmptyString),\n    .batteryCurrentAvgPath = android::String8(android::String8::kEmptyString),\n    .batteryChargeCounterPath = android::String8(android::String8::kEmptyString),\n    .batteryFullChargePath = android::String8(android::String8::kEmptyString),\n    .batteryCycleCountPath = android::String8(android::String8::kEmptyString),\n    .energyCounter = NULL,\n    .boot_min_cap = 0,\n    .screen_on = NULL\n  };\n\n  auto health =\n      android::hardware::health::V2_0::implementation::Health::initInstance(&healthd_config);\n\n  int wait_second = 0;\n  while (true) {\n    auto charge_status = BatteryStatus::UNKNOWN;\n    health\n        ->getChargeStatus([&charge_status](auto res, auto out_status) {\n          if (res == Result::SUCCESS) {\n            charge_status = out_status;\n          }\n        })\n        .isOk();  // should not have transport error\n\n    // Treat unknown status as charged.\n    bool charged = (charge_status != BatteryStatus::DISCHARGING &&\n                    charge_status != BatteryStatus::NOT_CHARGING);\n\n    Result res = Result::UNKNOWN;\n    int32_t capacity = INT32_MIN;\n    health\n        ->getCapacity([&res, &capacity](auto out_res, auto out_capacity) {\n          res = out_res;\n          capacity = out_capacity;\n        })\n        .isOk();  // should not have transport error\n\n    ui_print(\"charge_status %d, charged %d, status %s, capacity %\" PRId32 \"\\n\", charge_status,\n             charged, toString(res).c_str(), capacity);\n    // At startup, the battery drivers in devices like N5X/N6P take some time to load\n    // the battery profile. Before the load finishes, it reports value 50 as a fake\n    // capacity. BATTERY_READ_TIMEOUT_IN_SEC is set that the battery drivers are expected\n    // to finish loading the battery profile earlier than 10 seconds after kernel startup.\n    if (res == Result::SUCCESS && capacity == 50) {\n      if (wait_second < BATTERY_READ_TIMEOUT_IN_SEC) {\n        sleep(1);\n        wait_second++;\n        continue;\n      }\n    }\n    // If we can't read battery percentage, it may be a device without battery. In this\n    // situation, use 100 as a fake battery percentage.\n    if (res != Result::SUCCESS) {\n      capacity = 100;\n    }\n    return (charged && capacity >= BATTERY_WITH_CHARGER_OK_PERCENTAGE) ||\n           (!charged && capacity >= BATTERY_OK_PERCENTAGE);\n    }\n}\n\n// Set the retry count to |retry_count| in BCB.\nstatic void set_retry_bootloader_message(int retry_count, const std::vector<std::string>& args) {\n  std::vector<std::string> options;\n  for (const auto& arg : args) {\n    if (!android::base::StartsWith(arg, \"--retry_count\")) {\n      options.push_back(arg);\n    }\n  }\n\n  // Update the retry counter in BCB.\n  options.push_back(android::base::StringPrintf(\"--retry_count=%d\", retry_count));\n  std::string err;\n  if (!update_bootloader_message(options, &err)) {\n    LOG(ERROR) << err;\n  }\n}\n\nstatic bool bootreason_in_blacklist() {\n  std::string bootreason = android::base::GetProperty(\"ro.boot.bootreason\", \"\");\n  if (!bootreason.empty()) {\n    for (const auto& str : bootreason_blacklist) {\n      if (strcasecmp(str.c_str(), bootreason.c_str()) == 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nstatic void log_failure_code(ErrorCode code, const char *update_package) {\n    std::vector<std::string> log_buffer = {\n        update_package,\n        \"0\",  // install result\n        \"error: \" + std::to_string(code),\n    };\n    std::string log_content = android::base::Join(log_buffer, \"\\n\");\n    if (!android::base::WriteStringToFile(log_content, TEMPORARY_INSTALL_FILE)) {\n        PLOG(ERROR) << \"failed to write \" << TEMPORARY_INSTALL_FILE;\n    }\n\n    // Also write the info into last_log.\n    LOG(INFO) << log_content;\n}\n\nint main(int argc, char **argv) {\n  // We don't have logcat yet under recovery; so we'll print error on screen and\n  // log to stdout (which is redirected to recovery.log) as we used to do.\n  android::base::InitLogging(argv, &UiLogger);\n\n  // Take last pmsg contents and rewrite it to the current pmsg session.\n  static const char filter[] = \"recovery/\";\n  // Do we need to rotate?\n  bool doRotate = false;\n\n  __android_log_pmsg_file_read(LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter, logbasename, &doRotate);\n  // Take action to refresh pmsg contents\n  __android_log_pmsg_file_read(LOG_ID_SYSTEM, ANDROID_LOG_INFO, filter, logrotate, &doRotate);\n\n  // If this binary is started with the single argument \"--adbd\",\n  // instead of being the normal recovery binary, it turns into kind\n  // of a stripped-down version of adbd that only supports the\n  // 'sideload' command.  Note this must be a real argument, not\n  // anything in the command file or bootloader control block; the\n  // only way recovery should be run with this argument is when it\n  // starts a copy of itself from the apply_from_adb() function.\n  if (argc == 2 && strcmp(argv[1], \"--adbd\") == 0) {\n    minadbd_main();\n    return 0;\n  }\n\n  time_t start = time(nullptr);\n\n  // redirect_stdio should be called only in non-sideload mode. Otherwise\n  // we may have two logger instances with different timestamps.\n  redirect_stdio(TEMPORARY_LOG_FILE);\n\n  printf(\"Starting recovery (pid %d) on %s\", getpid(), ctime(&start));\n\n  load_volume_table();\n  has_cache = volume_for_mount_point(CACHE_ROOT) != nullptr;\n\n  std::vector<std::string> args = get_args(argc, argv);\n  std::vector<char*> args_to_parse(args.size());\n  std::transform(args.cbegin(), args.cend(), args_to_parse.begin(),\n                 [](const std::string& arg) { return const_cast<char*>(arg.c_str()); });\n\n  const char* update_package = nullptr;\n  bool should_wipe_data = false;\n  bool should_prompt_and_wipe_data = false;\n  bool should_wipe_cache = false;\n  bool should_wipe_ab = false;\n  size_t wipe_package_size = 0;\n  bool show_text = false;\n  bool sideload = false;\n  bool sideload_auto_reboot = false;\n  bool just_exit = false;\n  bool shutdown_after = false;\n  int retry_count = 0;\n  bool security_update = false;\n\n  int arg;\n  int option_index;\n  while ((arg = getopt_long(args_to_parse.size(), args_to_parse.data(), \"\", OPTIONS,\n                            &option_index)) != -1) {\n    switch (arg) {\n      case 'n':\n        android::base::ParseInt(optarg, &retry_count, 0);\n        break;\n      case 'u':\n        update_package = optarg;\n        break;\n      case 'w':\n        should_wipe_data = true;\n        break;\n      case 'c':\n        should_wipe_cache = true;\n        break;\n      case 't':\n        show_text = true;\n        break;\n      case 's':\n        sideload = true;\n        break;\n      case 'a':\n        sideload = true;\n        sideload_auto_reboot = true;\n        break;\n      case 'x':\n        just_exit = true;\n        break;\n      case 'l':\n        locale = optarg;\n        break;\n      case 'p':\n        shutdown_after = true;\n        break;\n      case 'r':\n        reason = optarg;\n        break;\n      case 'e':\n        security_update = true;\n        break;\n      case 0: {\n        std::string option = OPTIONS[option_index].name;\n        if (option == \"wipe_ab\") {\n          should_wipe_ab = true;\n        } else if (option == \"wipe_package_size\") {\n          android::base::ParseUint(optarg, &wipe_package_size);\n        } else if (option == \"prompt_and_wipe_data\") {\n          should_prompt_and_wipe_data = true;\n        }\n        break;\n      }\n      case '?':\n        LOG(ERROR) << \"Invalid command argument\";\n        continue;\n    }\n  }\n\n  if (locale.empty()) {\n    if (has_cache) {\n      locale = load_locale_from_cache();\n    }\n\n    if (locale.empty()) {\n      locale = DEFAULT_LOCALE;\n    }\n  }\n\n  printf(\"locale is [%s]\\n\", locale.c_str());\n  printf(\"stage is [%s]\\n\", stage.c_str());\n  printf(\"reason is [%s]\\n\", reason);\n\n  Device* device = make_device();\n  if (android::base::GetBoolProperty(\"ro.boot.quiescent\", false)) {\n    printf(\"Quiescent recovery mode.\\n\");\n    ui = new StubRecoveryUI();\n  } else {\n    ui = device->GetUI();\n\n    if (!ui->Init(locale)) {\n      printf(\"Failed to initialize UI, use stub UI instead.\\n\");\n      ui = new StubRecoveryUI();\n    }\n  }\n\n  // Set background string to \"installing security update\" for security update,\n  // otherwise set it to \"installing system update\".\n  ui->SetSystemUpdateText(security_update);\n\n  int st_cur, st_max;\n  if (!stage.empty() && sscanf(stage.c_str(), \"%d/%d\", &st_cur, &st_max) == 2) {\n    ui->SetStage(st_cur, st_max);\n  }\n\n  ui->SetBackground(RecoveryUI::NONE);\n  if (show_text) ui->ShowText(true);\n\n  sehandle = selinux_android_file_context_handle();\n  selinux_android_set_sehandle(sehandle);\n  if (!sehandle) {\n    ui->Print(\"Warning: No file_contexts\\n\");\n  }\n\n  device->StartRecovery();\n\n  printf(\"Command:\");\n  for (const auto& arg : args) {\n    printf(\" \\\"%s\\\"\", arg.c_str());\n  }\n  printf(\"\\n\\n\");\n\n  property_list(print_property, nullptr);\n  printf(\"\\n\");\n\n  ui->Print(\"Supported API: %d\\n\", kRecoveryApiVersion);\n\n  int status = INSTALL_SUCCESS;\n\n  if (update_package != nullptr) {\n    // It's not entirely true that we will modify the flash. But we want\n    // to log the update attempt since update_package is non-NULL.\n    modified_flash = true;\n\n    if (!is_battery_ok()) {\n      ui->Print(\"battery capacity is not enough for installing package, needed is %d%%\\n\",\n                BATTERY_OK_PERCENTAGE);\n      // Log the error code to last_install when installation skips due to\n      // low battery.\n      log_failure_code(kLowBattery, update_package);\n      status = INSTALL_SKIPPED;\n    } else if (bootreason_in_blacklist()) {\n      // Skip update-on-reboot when bootreason is kernel_panic or similar\n      ui->Print(\"bootreason is in the blacklist; skip OTA installation\\n\");\n      log_failure_code(kBootreasonInBlacklist, update_package);\n      status = INSTALL_SKIPPED;\n    } else {\n      // It's a fresh update. Initialize the retry_count in the BCB to 1; therefore we can later\n      // identify the interrupted update due to unexpected reboots.\n      if (retry_count == 0) {\n        set_retry_bootloader_message(retry_count + 1, args);\n      }\n\n      status = install_package(update_package, &should_wipe_cache, TEMPORARY_INSTALL_FILE, true,\n                               retry_count);\n      if (status == INSTALL_SUCCESS && should_wipe_cache) {\n        wipe_cache(false, device);\n      }\n      if (status != INSTALL_SUCCESS) {\n        ui->Print(\"Installation aborted.\\n\");\n        // When I/O error happens, reboot and retry installation RETRY_LIMIT\n        // times before we abandon this OTA update.\n        if (status == INSTALL_RETRY && retry_count < RETRY_LIMIT) {\n          copy_logs();\n          retry_count += 1;\n          set_retry_bootloader_message(retry_count, args);\n          // Print retry count on screen.\n          ui->Print(\"Retry attempt %d\\n\", retry_count);\n\n          // Reboot and retry the update\n          if (!reboot(\"reboot,recovery\")) {\n            ui->Print(\"Reboot failed\\n\");\n          } else {\n            while (true) {\n              pause();\n            }\n          }\n        }\n        // If this is an eng or userdebug build, then automatically\n        // turn the text display on if the script fails so the error\n        // message is visible.\n        if (is_ro_debuggable()) {\n          ui->ShowText(true);\n        }\n      }\n    }\n  } else if (should_wipe_data) {\n    if (!wipe_data(device)) {\n      status = INSTALL_ERROR;\n    }\n  } else if (should_prompt_and_wipe_data) {\n    ui->ShowText(true);\n    ui->SetBackground(RecoveryUI::ERROR);\n    if (!prompt_and_wipe_data(device)) {\n      status = INSTALL_ERROR;\n    }\n    ui->ShowText(false);\n  } else if (should_wipe_cache) {\n    if (!wipe_cache(false, device)) {\n      status = INSTALL_ERROR;\n    }\n  } else if (should_wipe_ab) {\n    if (!wipe_ab_device(wipe_package_size)) {\n      status = INSTALL_ERROR;\n    }\n  } else if (sideload) {\n    // 'adb reboot sideload' acts the same as user presses key combinations\n    // to enter the sideload mode. When 'sideload-auto-reboot' is used, text\n    // display will NOT be turned on by default. And it will reboot after\n    // sideload finishes even if there are errors. Unless one turns on the\n    // text display during the installation. This is to enable automated\n    // testing.\n    if (!sideload_auto_reboot) {\n      ui->ShowText(true);\n    }\n    status = apply_from_adb(&should_wipe_cache, TEMPORARY_INSTALL_FILE);\n    if (status == INSTALL_SUCCESS && should_wipe_cache) {\n      if (!wipe_cache(false, device)) {\n        status = INSTALL_ERROR;\n      }\n    }\n    ui->Print(\"\\nInstall from ADB complete (status: %d).\\n\", status);\n    if (sideload_auto_reboot) {\n      ui->Print(\"Rebooting automatically.\\n\");\n    }\n  } else if (!just_exit) {\n    // If this is an eng or userdebug build, automatically turn on the text display if no command\n    // is specified. Note that this should be called before setting the background to avoid\n    // flickering the background image.\n    if (is_ro_debuggable()) {\n      ui->ShowText(true);\n    }\n    status = INSTALL_NONE;  // No command specified\n    ui->SetBackground(RecoveryUI::NO_COMMAND);\n  }\n\n  if (status == INSTALL_ERROR || status == INSTALL_CORRUPT) {\n    ui->SetBackground(RecoveryUI::ERROR);\n    if (!ui->IsTextVisible()) {\n      sleep(5);\n    }\n  }\n\n  Device::BuiltinAction after = shutdown_after ? Device::SHUTDOWN : Device::REBOOT;\n  // 1. If the recovery menu is visible, prompt and wait for commands.\n  // 2. If the state is INSTALL_NONE, wait for commands. (i.e. In user build, manually reboot into\n  //    recovery to sideload a package.)\n  // 3. sideload_auto_reboot is an option only available in user-debug build, reboot the device\n  //    without waiting.\n  // 4. In all other cases, reboot the device. Therefore, normal users will observe the device\n  //    reboot after it shows the \"error\" screen for 5s.\n  if ((status == INSTALL_NONE && !sideload_auto_reboot) || ui->IsTextVisible()) {\n    Device::BuiltinAction temp = prompt_and_wait(device, status);\n    if (temp != Device::NO_ACTION) {\n      after = temp;\n    }\n  }\n\n  // Save logs and clean up before rebooting or shutting down.\n  finish_recovery();\n\n  switch (after) {\n    case Device::SHUTDOWN:\n      ui->Print(\"Shutting down...\\n\");\n      android::base::SetProperty(ANDROID_RB_PROPERTY, \"shutdown,\");\n      break;\n\n    case Device::REBOOT_BOOTLOADER:\n      ui->Print(\"Rebooting to bootloader...\\n\");\n      android::base::SetProperty(ANDROID_RB_PROPERTY, \"reboot,bootloader\");\n      break;\n\n    default:\n      ui->Print(\"Rebooting...\\n\");\n      reboot(\"reboot,\");\n      break;\n  }\n  while (true) {\n    pause();\n  }\n  // Should be unreachable.\n  return EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "recovery_ui.h",
          "type": "blob",
          "size": 3.345703125,
          "content": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _RECOVERY_UI_H\n#define _RECOVERY_UI_H\n\n// Called when recovery starts up.  Returns 0.\nextern int device_recovery_start();\n\n// Called in the input thread when a new key (key_code) is pressed.\n// *key_pressed is an array of KEY_MAX+1 bytes indicating which other\n// keys are already pressed.  Return true if the text display should\n// be toggled.\nextern int device_toggle_display(volatile char* key_pressed, int key_code);\n\n// Called in the input thread when a new key (key_code) is pressed.\n// *key_pressed is an array of KEY_MAX+1 bytes indicating which other\n// keys are already pressed.  Return true if the device should reboot\n// immediately.\nextern int device_reboot_now(volatile char* key_pressed, int key_code);\n\n// Called from the main thread when recovery is waiting for input and\n// a key is pressed.  key is the code of the key pressed; visible is\n// true if the recovery menu is being shown.  Implementations can call\n// ui_key_pressed() to discover if other keys are being held down.\n// Return one of the defined constants below in order to:\n//\n//   - move the menu highlight (HIGHLIGHT_*)\n//   - invoke the highlighted item (SELECT_ITEM)\n//   - do nothing (NO_ACTION)\n//   - invoke a specific action (a menu position: any non-negative number)\nextern int device_handle_key(int key, int visible);\n\n// Perform a recovery action selected from the menu.  'which' will be\n// the item number of the selected menu item, or a non-negative number\n// returned from device_handle_key().  The menu will be hidden when\n// this is called; implementations can call ui_print() to print\n// information to the screen.\nextern int device_perform_action(int which);\n\n// Called when we do a wipe data/factory reset operation (either via a\n// reboot from the main system with the --wipe_data flag, or when the\n// user boots into recovery manually and selects the option from the\n// menu.)  Can perform whatever device-specific wiping actions are\n// needed.  Return 0 on success.  The userdata and cache partitions\n// are erased after this returns (whether it returns success or not).\nint device_wipe_data();\n\n#define NO_ACTION           -1\n\n#define HIGHLIGHT_UP        -2\n#define HIGHLIGHT_DOWN      -3\n#define SELECT_ITEM         -4\n#define UP_A_LEVEL          -5\n#define HOME_MENU           -6\n#define MENU_MENU           -7\n\n// Again, just to keep custom recovery builds happy\n#define ITEM_APPLY_CACHE     4\n\n// Header text to display above the main menu.\nextern char* MENU_HEADERS[];\n\n// Text of menu items.\nextern char* MENU_ITEMS[];\n\n// NOTE: Main Menu index definitions moved to recovery.c\n\nint sdcard_directory(const char* path);\nint get_menu_selection(char** headers, char** items, int menu_only, int initial_selection);\nvoid prompt_and_wait();\nvoid finish_recovery(const char *send_intent);\n#endif\n"
        },
        {
          "name": "res-560dpi",
          "type": "blob",
          "size": 0.0107421875,
          "content": "res-xxxhdpi"
        },
        {
          "name": "res-hdpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "res-mdpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "res-xhdpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "res-xxhdpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "res-xxxhdpi",
          "type": "tree",
          "content": null
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "roots.cpp",
          "type": "blob",
          "size": 11.1845703125,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"roots.h\"\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <algorithm>\n#include <string>\n#include <vector>\n\n#include <android-base/logging.h>\n#include <android-base/properties.h>\n#include <android-base/stringprintf.h>\n#include <android-base/unique_fd.h>\n#include <cryptfs.h>\n#include <ext4_utils/wipe.h>\n#include <fs_mgr.h>\n\n#include \"mounts.h\"\n\nstatic struct fstab* fstab = nullptr;\n\nextern struct selabel_handle* sehandle;\n\nvoid load_volume_table() {\n  fstab = fs_mgr_read_fstab_default();\n  if (!fstab) {\n    LOG(ERROR) << \"Failed to read default fstab\";\n    return;\n  }\n\n  int ret = fs_mgr_add_entry(fstab, \"/tmp\", \"ramdisk\", \"ramdisk\");\n  if (ret == -1) {\n    LOG(ERROR) << \"Failed to add /tmp entry to fstab\";\n    fs_mgr_free_fstab(fstab);\n    fstab = nullptr;\n    return;\n  }\n\n  printf(\"recovery filesystem table\\n\");\n  printf(\"=========================\\n\");\n  for (int i = 0; i < fstab->num_entries; ++i) {\n    const Volume* v = &fstab->recs[i];\n    printf(\"  %d %s %s %s %lld\\n\", i, v->mount_point, v->fs_type, v->blk_device, v->length);\n  }\n  printf(\"\\n\");\n}\n\nVolume* volume_for_mount_point(const std::string& mount_point) {\n  return fs_mgr_get_entry_for_mount_point(fstab, mount_point);\n}\n\n// Finds the volume specified by the given path. fs_mgr_get_entry_for_mount_point() does exact match\n// only, so it attempts the prefixes recursively (e.g. \"/cache/recovery/last_log\",\n// \"/cache/recovery\", \"/cache\", \"/\" for a given path of \"/cache/recovery/last_log\") and returns the\n// first match or nullptr.\nstatic Volume* volume_for_path(const char* path) {\n  if (path == nullptr || path[0] == '\\0') return nullptr;\n  std::string str(path);\n  while (true) {\n    Volume* result = fs_mgr_get_entry_for_mount_point(fstab, str);\n    if (result != nullptr || str == \"/\") {\n      return result;\n    }\n    size_t slash = str.find_last_of('/');\n    if (slash == std::string::npos) return nullptr;\n    if (slash == 0) {\n      str = \"/\";\n    } else {\n      str = str.substr(0, slash);\n    }\n  }\n  return nullptr;\n}\n\n// Mount the volume specified by path at the given mount_point.\nint ensure_path_mounted_at(const char* path, const char* mount_point) {\n  Volume* v = volume_for_path(path);\n  if (v == nullptr) {\n    LOG(ERROR) << \"unknown volume for path [\" << path << \"]\";\n    return -1;\n  }\n  if (strcmp(v->fs_type, \"ramdisk\") == 0) {\n    // The ramdisk is always mounted.\n    return 0;\n  }\n\n  if (!scan_mounted_volumes()) {\n    LOG(ERROR) << \"Failed to scan mounted volumes\";\n    return -1;\n  }\n\n  if (!mount_point) {\n    mount_point = v->mount_point;\n  }\n\n  const MountedVolume* mv = find_mounted_volume_by_mount_point(mount_point);\n  if (mv != nullptr) {\n    // Volume is already mounted.\n    return 0;\n  }\n\n  mkdir(mount_point, 0755);  // in case it doesn't already exist\n\n  if (strcmp(v->fs_type, \"ext4\") == 0 || strcmp(v->fs_type, \"squashfs\") == 0 ||\n      strcmp(v->fs_type, \"vfat\") == 0) {\n    int result = mount(v->blk_device, mount_point, v->fs_type, v->flags, v->fs_options);\n    if (result == -1 && fs_mgr_is_formattable(v)) {\n      PLOG(ERROR) << \"Failed to mount \" << mount_point << \"; formatting\";\n      bool crypt_footer = fs_mgr_is_encryptable(v) && !strcmp(v->key_loc, \"footer\");\n      if (fs_mgr_do_format(v, crypt_footer) == 0) {\n        result = mount(v->blk_device, mount_point, v->fs_type, v->flags, v->fs_options);\n      } else {\n        PLOG(ERROR) << \"Failed to format \" << mount_point;\n        return -1;\n      }\n    }\n\n    if (result == -1) {\n      PLOG(ERROR) << \"Failed to mount \" << mount_point;\n      return -1;\n    }\n    return 0;\n  }\n\n  LOG(ERROR) << \"unknown fs_type \\\"\" << v->fs_type << \"\\\" for \" << mount_point;\n  return -1;\n}\n\nint ensure_path_mounted(const char* path) {\n  // Mount at the default mount point.\n  return ensure_path_mounted_at(path, nullptr);\n}\n\nint ensure_path_unmounted(const char* path) {\n  const Volume* v = volume_for_path(path);\n  if (v == nullptr) {\n    LOG(ERROR) << \"unknown volume for path [\" << path << \"]\";\n    return -1;\n  }\n  if (strcmp(v->fs_type, \"ramdisk\") == 0) {\n    // The ramdisk is always mounted; you can't unmount it.\n    return -1;\n  }\n\n  if (!scan_mounted_volumes()) {\n    LOG(ERROR) << \"Failed to scan mounted volumes\";\n    return -1;\n  }\n\n  MountedVolume* mv = find_mounted_volume_by_mount_point(v->mount_point);\n  if (mv == nullptr) {\n    // Volume is already unmounted.\n    return 0;\n  }\n\n  return unmount_mounted_volume(mv);\n}\n\nstatic int exec_cmd(const std::vector<std::string>& args) {\n  CHECK_NE(static_cast<size_t>(0), args.size());\n\n  std::vector<char*> argv(args.size());\n  std::transform(args.cbegin(), args.cend(), argv.begin(),\n                 [](const std::string& arg) { return const_cast<char*>(arg.c_str()); });\n  argv.push_back(nullptr);\n\n  pid_t child;\n  if ((child = fork()) == 0) {\n    execv(argv[0], argv.data());\n    _exit(EXIT_FAILURE);\n  }\n\n  int status;\n  waitpid(child, &status, 0);\n  if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n    LOG(ERROR) << args[0] << \" failed with status \" << WEXITSTATUS(status);\n  }\n  return WEXITSTATUS(status);\n}\n\nstatic int64_t get_file_size(int fd, uint64_t reserve_len) {\n  struct stat buf;\n  int ret = fstat(fd, &buf);\n  if (ret) return 0;\n\n  int64_t computed_size;\n  if (S_ISREG(buf.st_mode)) {\n    computed_size = buf.st_size - reserve_len;\n  } else if (S_ISBLK(buf.st_mode)) {\n    uint64_t block_device_size = get_block_device_size(fd);\n    if (block_device_size < reserve_len ||\n        block_device_size > std::numeric_limits<int64_t>::max()) {\n      computed_size = 0;\n    } else {\n      computed_size = block_device_size - reserve_len;\n    }\n  } else {\n    computed_size = 0;\n  }\n\n  return computed_size;\n}\n\nint format_volume(const char* volume, const char* directory) {\n  const Volume* v = volume_for_path(volume);\n  if (v == nullptr) {\n    LOG(ERROR) << \"unknown volume \\\"\" << volume << \"\\\"\";\n    return -1;\n  }\n  if (strcmp(v->fs_type, \"ramdisk\") == 0) {\n    LOG(ERROR) << \"can't format_volume \\\"\" << volume << \"\\\"\";\n    return -1;\n  }\n  if (strcmp(v->mount_point, volume) != 0) {\n    LOG(ERROR) << \"can't give path \\\"\" << volume << \"\\\" to format_volume\";\n    return -1;\n  }\n  if (ensure_path_unmounted(volume) != 0) {\n    LOG(ERROR) << \"format_volume: Failed to unmount \\\"\" << v->mount_point << \"\\\"\";\n    return -1;\n  }\n  if (strcmp(v->fs_type, \"ext4\") != 0 && strcmp(v->fs_type, \"f2fs\") != 0) {\n    LOG(ERROR) << \"format_volume: fs_type \\\"\" << v->fs_type << \"\\\" unsupported\";\n    return -1;\n  }\n\n  // If there's a key_loc that looks like a path, it should be a block device for storing encryption\n  // metadata. Wipe it too.\n  if (v->key_loc != nullptr && v->key_loc[0] == '/') {\n    LOG(INFO) << \"Wiping \" << v->key_loc;\n    int fd = open(v->key_loc, O_WRONLY | O_CREAT, 0644);\n    if (fd == -1) {\n      PLOG(ERROR) << \"format_volume: Failed to open \" << v->key_loc;\n      return -1;\n    }\n    wipe_block_device(fd, get_file_size(fd));\n    close(fd);\n  }\n\n  int64_t length = 0;\n  if (v->length > 0) {\n    length = v->length;\n  } else if (v->length < 0 ||\n             (v->key_loc != nullptr && strcmp(v->key_loc, \"footer\") == 0)) {\n    android::base::unique_fd fd(open(v->blk_device, O_RDONLY));\n    if (fd == -1) {\n      PLOG(ERROR) << \"format_volume: failed to open \" << v->blk_device;\n      return -1;\n    }\n    length =\n        get_file_size(fd.get(), v->length ? -v->length : CRYPT_FOOTER_OFFSET);\n    if (length <= 0) {\n      LOG(ERROR) << \"get_file_size: invalid size \" << length << \" for \"\n                 << v->blk_device;\n      return -1;\n    }\n  }\n\n  if (strcmp(v->fs_type, \"ext4\") == 0) {\n    static constexpr int kBlockSize = 4096;\n    std::vector<std::string> mke2fs_args = {\n      \"/sbin/mke2fs_static\", \"-F\", \"-t\", \"ext4\", \"-b\", std::to_string(kBlockSize),\n    };\n\n    int raid_stride = v->logical_blk_size / kBlockSize;\n    int raid_stripe_width = v->erase_blk_size / kBlockSize;\n    // stride should be the max of 8KB and logical block size\n    if (v->logical_blk_size != 0 && v->logical_blk_size < 8192) {\n      raid_stride = 8192 / kBlockSize;\n    }\n    if (v->erase_blk_size != 0 && v->logical_blk_size != 0) {\n      mke2fs_args.push_back(\"-E\");\n      mke2fs_args.push_back(\n          android::base::StringPrintf(\"stride=%d,stripe-width=%d\", raid_stride, raid_stripe_width));\n    }\n    mke2fs_args.push_back(v->blk_device);\n    if (length != 0) {\n      mke2fs_args.push_back(std::to_string(length / kBlockSize));\n    }\n\n    int result = exec_cmd(mke2fs_args);\n    if (result == 0 && directory != nullptr) {\n      std::vector<std::string> e2fsdroid_args = {\n        \"/sbin/e2fsdroid_static\",\n        \"-e\",\n        \"-f\",\n        directory,\n        \"-a\",\n        volume,\n        v->blk_device,\n      };\n      result = exec_cmd(e2fsdroid_args);\n    }\n\n    if (result != 0) {\n      PLOG(ERROR) << \"format_volume: Failed to make ext4 on \" << v->blk_device;\n      return -1;\n    }\n    return 0;\n  }\n\n  // Has to be f2fs because we checked earlier.\n  static constexpr int kSectorSize = 4096;\n  std::string cmd(\"/sbin/mkfs.f2fs\");\n  // clang-format off\n  std::vector<std::string> make_f2fs_cmd = {\n    cmd,\n    \"-d1\",\n    \"-f\",\n    \"-O\", \"encrypt\",\n    \"-O\", \"quota\",\n    \"-O\", \"verity\",\n    \"-w\", std::to_string(kSectorSize),\n    v->blk_device,\n  };\n  // clang-format on\n  if (length >= kSectorSize) {\n    make_f2fs_cmd.push_back(std::to_string(length / kSectorSize));\n  }\n\n  int result = exec_cmd(make_f2fs_cmd);\n  if (result == 0 && directory != nullptr) {\n    cmd = \"/sbin/sload.f2fs\";\n    // clang-format off\n    std::vector<std::string> sload_f2fs_cmd = {\n      cmd,\n      \"-f\", directory,\n      \"-t\", volume,\n      v->blk_device,\n    };\n    // clang-format on\n    result = exec_cmd(sload_f2fs_cmd);\n  }\n  if (result != 0) {\n    PLOG(ERROR) << \"format_volume: Failed \" << cmd << \" on \" << v->blk_device;\n    return -1;\n  }\n  return 0;\n}\n\nint format_volume(const char* volume) {\n  return format_volume(volume, nullptr);\n}\n\nint setup_install_mounts() {\n  if (fstab == nullptr) {\n    LOG(ERROR) << \"can't set up install mounts: no fstab loaded\";\n    return -1;\n  }\n  for (int i = 0; i < fstab->num_entries; ++i) {\n    const Volume* v = fstab->recs + i;\n\n    // We don't want to do anything with \"/\".\n    if (strcmp(v->mount_point, \"/\") == 0) {\n      continue;\n    }\n\n    if (strcmp(v->mount_point, \"/tmp\") == 0 || strcmp(v->mount_point, \"/cache\") == 0) {\n      if (ensure_path_mounted(v->mount_point) != 0) {\n        LOG(ERROR) << \"Failed to mount \" << v->mount_point;\n        return -1;\n      }\n    } else {\n      if (ensure_path_unmounted(v->mount_point) != 0) {\n        LOG(ERROR) << \"Failed to unmount \" << v->mount_point;\n        return -1;\n      }\n    }\n  }\n  return 0;\n}\n"
        },
        {
          "name": "roots.h",
          "type": "blob",
          "size": 2.0234375,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_ROOTS_H_\n#define RECOVERY_ROOTS_H_\n\n#include <string>\n\ntypedef struct fstab_rec Volume;\n\ntypedef struct fstab_rec Volume;\n\n// Load and parse volume data from /etc/recovery.fstab.\nvoid load_volume_table();\n\n// Return the Volume* record for this mount point (or nullptr).\nVolume* volume_for_mount_point(const std::string& mount_point);\n\n// Make sure that the volume 'path' is on is mounted.  Returns 0 on\n// success (volume is mounted).\nint ensure_path_mounted(const char* path);\n\n// Similar to ensure_path_mounted, but allows one to specify the mount_point.\nint ensure_path_mounted_at(const char* path, const char* mount_point);\n\n// Make sure that the volume 'path' is on is unmounted.  Returns 0 on\n// success (volume is unmounted);\nint ensure_path_unmounted(const char* path);\n\n// Reformat the given volume (must be the mount point only, eg\n// \"/cache\"), no paths permitted.  Attempts to unmount the volume if\n// it is mounted.\nint format_volume(const char* volume);\n\n// Reformat the given volume (must be the mount point only, eg\n// \"/cache\"), no paths permitted.  Attempts to unmount the volume if\n// it is mounted.\n// Copies 'directory' to root of the newly formatted volume\nint format_volume(const char* volume, const char* directory);\n\n// Ensure that all and only the volumes that packages expect to find\n// mounted (/tmp and /cache) are mounted.  Returns 0 on success.\nint setup_install_mounts();\n\n#endif  // RECOVERY_ROOTS_H_\n"
        },
        {
          "name": "rotate_logs.cpp",
          "type": "blob",
          "size": 3.458984375,
          "content": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"rotate_logs.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include <string>\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/parseint.h>\n#include <android-base/stringprintf.h>\n#include <private/android_logger.h> /* private pmsg functions */\n\nstatic const std::string LAST_KMSG_FILTER = \"recovery/last_kmsg\";\nstatic const std::string LAST_LOG_FILTER = \"recovery/last_log\";\n\nssize_t logbasename(log_id_t /* id */, char /* prio */, const char* filename, const char* /* buf */,\n                    size_t len, void* arg) {\n  bool* do_rotate = static_cast<bool*>(arg);\n  if (LAST_KMSG_FILTER.find(filename) != std::string::npos ||\n      LAST_LOG_FILTER.find(filename) != std::string::npos) {\n    *do_rotate = true;\n  }\n  return len;\n}\n\nssize_t logrotate(log_id_t id, char prio, const char* filename, const char* buf, size_t len,\n                  void* arg) {\n  bool* do_rotate = static_cast<bool*>(arg);\n  if (!*do_rotate) {\n    return __android_log_pmsg_file_write(id, prio, filename, buf, len);\n  }\n\n  std::string name(filename);\n  size_t dot = name.find_last_of('.');\n  std::string sub = name.substr(0, dot);\n\n  if (LAST_KMSG_FILTER.find(sub) == std::string::npos &&\n      LAST_LOG_FILTER.find(sub) == std::string::npos) {\n    return __android_log_pmsg_file_write(id, prio, filename, buf, len);\n  }\n\n  // filename rotation\n  if (dot == std::string::npos) {\n    name += \".1\";\n  } else {\n    std::string number = name.substr(dot + 1);\n    if (!isdigit(number[0])) {\n      name += \".1\";\n    } else {\n      size_t i;\n      if (!android::base::ParseUint(number.c_str(), &i)) {\n        LOG(ERROR) << \"failed to parse uint in \" << number;\n        return -1;\n      }\n      name = sub + \".\" + std::to_string(i + 1);\n    }\n  }\n\n  return __android_log_pmsg_file_write(id, prio, name.c_str(), buf, len);\n}\n\n// Rename last_log -> last_log.1 -> last_log.2 -> ... -> last_log.$max.\n// Similarly rename last_kmsg -> last_kmsg.1 -> ... -> last_kmsg.$max.\n// Overwrite any existing last_log.$max and last_kmsg.$max.\nvoid rotate_logs(const char* last_log_file, const char* last_kmsg_file) {\n  // Logs should only be rotated once.\n  static bool rotated = false;\n  if (rotated) {\n    return;\n  }\n  rotated = true;\n\n  for (int i = KEEP_LOG_COUNT - 1; i >= 0; --i) {\n    std::string old_log = android::base::StringPrintf(\"%s\", last_log_file);\n    if (i > 0) {\n      old_log += \".\" + std::to_string(i);\n    }\n    std::string new_log = android::base::StringPrintf(\"%s.%d\", last_log_file, i + 1);\n    // Ignore errors if old_log doesn't exist.\n    rename(old_log.c_str(), new_log.c_str());\n\n    std::string old_kmsg = android::base::StringPrintf(\"%s\", last_kmsg_file);\n    if (i > 0) {\n      old_kmsg += \".\" + std::to_string(i);\n    }\n    std::string new_kmsg = android::base::StringPrintf(\"%s.%d\", last_kmsg_file, i + 1);\n    rename(old_kmsg.c_str(), new_kmsg.c_str());\n  }\n}\n"
        },
        {
          "name": "rotate_logs.h",
          "type": "blob",
          "size": 1.3662109375,
          "content": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _ROTATE_LOGS_H\n#define _ROTATE_LOGS_H\n\n#include <stddef.h>\n#include <sys/types.h>\n\n//#include <log/log_id.h>\n#include <private/android_logger.h> /* private pmsg functions */\n\nstatic constexpr int KEEP_LOG_COUNT = 10;\n\nssize_t logbasename(log_id_t id, char prio, const char* filename, const char* buf, size_t len,\n                    void* arg);\n\nssize_t logrotate(log_id_t id, char prio, const char* filename, const char* buf, size_t len,\n                  void* arg);\n\n// Rename last_log -> last_log.1 -> last_log.2 -> ... -> last_log.$max.\n// Similarly rename last_kmsg -> last_kmsg.1 -> ... -> last_kmsg.$max.\n// Overwrite any existing last_log.$max and last_kmsg.$max.\nvoid rotate_logs(const char* last_log_file, const char* last_kmsg_file);\n\n#endif //_ROTATE_LOG_H\n"
        },
        {
          "name": "screen_ui.cpp",
          "type": "blob",
          "size": 28.611328125,
          "content": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"screen_ui.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/input.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#include <android-base/logging.h>\n#include <android-base/properties.h>\n#include <android-base/stringprintf.h>\n#include <android-base/strings.h>\n#include <minui/minui.h>\n\n#include \"common.h\"\n#include \"device.h\"\n#include \"ui.h\"\n\n// Return the current time as a double (including fractions of a second).\nstatic double now() {\n  struct timeval tv;\n  gettimeofday(&tv, nullptr);\n  return tv.tv_sec + tv.tv_usec / 1000000.0;\n}\n\nScreenRecoveryUI::ScreenRecoveryUI()\n    : kMarginWidth(RECOVERY_UI_MARGIN_WIDTH),\n      kMarginHeight(RECOVERY_UI_MARGIN_HEIGHT),\n      kAnimationFps(RECOVERY_UI_ANIMATION_FPS),\n      kDensity(static_cast<float>(android::base::GetIntProperty(\"ro.sf.lcd_density\", 160)) / 160.f),\n      currentIcon(NONE),\n      progressBarType(EMPTY),\n      progressScopeStart(0),\n      progressScopeSize(0),\n      progress(0),\n      pagesIdentical(false),\n      text_cols_(0),\n      text_rows_(0),\n      text_(nullptr),\n      text_col_(0),\n      text_row_(0),\n      show_text(false),\n      show_text_ever(false),\n      menu_headers_(nullptr),\n      show_menu(false),\n      menu_items(0),\n      menu_sel(0),\n      file_viewer_text_(nullptr),\n      intro_frames(0),\n      loop_frames(0),\n      current_frame(0),\n      intro_done(false),\n      stage(-1),\n      max_stage(-1),\n      locale_(\"\"),\n      rtl_locale_(false),\n      updateMutex(PTHREAD_MUTEX_INITIALIZER) {}\n\nGRSurface* ScreenRecoveryUI::GetCurrentFrame() const {\n  if (currentIcon == INSTALLING_UPDATE || currentIcon == ERASING) {\n    return intro_done ? loopFrames[current_frame] : introFrames[current_frame];\n  }\n  return error_icon;\n}\n\nGRSurface* ScreenRecoveryUI::GetCurrentText() const {\n  switch (currentIcon) {\n    case ERASING:\n      return erasing_text;\n    case ERROR:\n      return error_text;\n    case INSTALLING_UPDATE:\n      return installing_text;\n    case NO_COMMAND:\n      return no_command_text;\n    case NONE:\n      abort();\n  }\n}\n\nint ScreenRecoveryUI::PixelsFromDp(int dp) const {\n  return dp * kDensity;\n}\n\n// Here's the intended layout:\n\n//          | portrait    large        landscape      large\n// ---------+-------------------------------------------------\n//      gap |\n// icon     |                   (200dp)\n//      gap |    68dp      68dp             56dp      112dp\n// text     |                    (14sp)\n//      gap |    32dp      32dp             26dp       52dp\n// progress |                     (2dp)\n//      gap |\n\n// Note that \"baseline\" is actually the *top* of each icon (because that's how our drawing routines\n// work), so that's the more useful measurement for calling code. We use even top and bottom gaps.\n\nenum Layout { PORTRAIT = 0, PORTRAIT_LARGE = 1, LANDSCAPE = 2, LANDSCAPE_LARGE = 3, LAYOUT_MAX };\nenum Dimension { TEXT = 0, ICON = 1, DIMENSION_MAX };\nstatic constexpr int kLayouts[LAYOUT_MAX][DIMENSION_MAX] = {\n  { 32,  68, },  // PORTRAIT\n  { 32,  68, },  // PORTRAIT_LARGE\n  { 26,  56, },  // LANDSCAPE\n  { 52, 112, },  // LANDSCAPE_LARGE\n};\n\nint ScreenRecoveryUI::GetAnimationBaseline() const {\n  return GetTextBaseline() - PixelsFromDp(kLayouts[layout_][ICON]) - gr_get_height(loopFrames[0]);\n}\n\nint ScreenRecoveryUI::GetTextBaseline() const {\n  return GetProgressBaseline() - PixelsFromDp(kLayouts[layout_][TEXT]) -\n         gr_get_height(installing_text);\n}\n\nint ScreenRecoveryUI::GetProgressBaseline() const {\n  int elements_sum = gr_get_height(loopFrames[0]) + PixelsFromDp(kLayouts[layout_][ICON]) +\n                     gr_get_height(installing_text) + PixelsFromDp(kLayouts[layout_][TEXT]) +\n                     gr_get_height(progressBarFill);\n  int bottom_gap = (ScreenHeight() - elements_sum) / 2;\n  return ScreenHeight() - bottom_gap - gr_get_height(progressBarFill);\n}\n\n// Clear the screen and draw the currently selected background icon (if any).\n// Should only be called with updateMutex locked.\nvoid ScreenRecoveryUI::draw_background_locked() {\n  pagesIdentical = false;\n  gr_color(0, 0, 0, 255);\n  gr_clear();\n  if (currentIcon != NONE) {\n    if (max_stage != -1) {\n      int stage_height = gr_get_height(stageMarkerEmpty);\n      int stage_width = gr_get_width(stageMarkerEmpty);\n      int x = (ScreenWidth() - max_stage * gr_get_width(stageMarkerEmpty)) / 2;\n      int y = ScreenHeight() - stage_height - kMarginHeight;\n      for (int i = 0; i < max_stage; ++i) {\n        GRSurface* stage_surface = (i < stage) ? stageMarkerFill : stageMarkerEmpty;\n        DrawSurface(stage_surface, 0, 0, stage_width, stage_height, x, y);\n        x += stage_width;\n      }\n    }\n\n    GRSurface* text_surface = GetCurrentText();\n    int text_x = (ScreenWidth() - gr_get_width(text_surface)) / 2;\n    int text_y = GetTextBaseline();\n    gr_color(255, 255, 255, 255);\n    DrawTextIcon(text_x, text_y, text_surface);\n  }\n}\n\n// Draws the animation and progress bar (if any) on the screen. Does not flip pages. Should only be\n// called with updateMutex locked.\nvoid ScreenRecoveryUI::draw_foreground_locked() {\n  if (currentIcon != NONE) {\n    GRSurface* frame = GetCurrentFrame();\n    int frame_width = gr_get_width(frame);\n    int frame_height = gr_get_height(frame);\n    int frame_x = (ScreenWidth() - frame_width) / 2;\n    int frame_y = GetAnimationBaseline();\n    DrawSurface(frame, 0, 0, frame_width, frame_height, frame_x, frame_y);\n  }\n\n  if (progressBarType != EMPTY) {\n    int width = gr_get_width(progressBarEmpty);\n    int height = gr_get_height(progressBarEmpty);\n\n    int progress_x = (ScreenWidth() - width) / 2;\n    int progress_y = GetProgressBaseline();\n\n    // Erase behind the progress bar (in case this was a progress-only update)\n    gr_color(0, 0, 0, 255);\n    DrawFill(progress_x, progress_y, width, height);\n\n    if (progressBarType == DETERMINATE) {\n      float p = progressScopeStart + progress * progressScopeSize;\n      int pos = static_cast<int>(p * width);\n\n      if (rtl_locale_) {\n        // Fill the progress bar from right to left.\n        if (pos > 0) {\n          DrawSurface(progressBarFill, width - pos, 0, pos, height, progress_x + width - pos,\n                      progress_y);\n        }\n        if (pos < width - 1) {\n          DrawSurface(progressBarEmpty, 0, 0, width - pos, height, progress_x, progress_y);\n        }\n      } else {\n        // Fill the progress bar from left to right.\n        if (pos > 0) {\n          DrawSurface(progressBarFill, 0, 0, pos, height, progress_x, progress_y);\n        }\n        if (pos < width - 1) {\n          DrawSurface(progressBarEmpty, pos, 0, width - pos, height, progress_x + pos, progress_y);\n        }\n      }\n    }\n  }\n}\n\nvoid ScreenRecoveryUI::SetColor(UIElement e) const {\n  switch (e) {\n    case INFO:\n      gr_color(249, 194, 0, 255);\n      break;\n    case HEADER:\n      gr_color(247, 0, 6, 255);\n      break;\n    case MENU:\n    case MENU_SEL_BG:\n      gr_color(0, 106, 157, 255);\n      break;\n    case MENU_SEL_BG_ACTIVE:\n      gr_color(0, 156, 100, 255);\n      break;\n    case MENU_SEL_FG:\n      gr_color(255, 255, 255, 255);\n      break;\n    case LOG:\n      gr_color(196, 196, 196, 255);\n      break;\n    case TEXT_FILL:\n      gr_color(0, 0, 0, 160);\n      break;\n    default:\n      gr_color(255, 255, 255, 255);\n      break;\n  }\n}\n\nvoid ScreenRecoveryUI::SelectAndShowBackgroundText(const std::vector<std::string>& locales_entries,\n                                                   size_t sel) {\n  SetLocale(locales_entries[sel]);\n  std::vector<std::string> text_name = { \"erasing_text\", \"error_text\", \"installing_text\",\n                                         \"installing_security_text\", \"no_command_text\" };\n  std::unordered_map<std::string, std::unique_ptr<GRSurface, decltype(&free)>> surfaces;\n  for (const auto& name : text_name) {\n    GRSurface* text_image = nullptr;\n    LoadLocalizedBitmap(name.c_str(), &text_image);\n    if (!text_image) {\n      Print(\"Failed to load %s\\n\", name.c_str());\n      return;\n    }\n    surfaces.emplace(name, std::unique_ptr<GRSurface, decltype(&free)>(text_image, &free));\n  }\n\n  pthread_mutex_lock(&updateMutex);\n  gr_color(0, 0, 0, 255);\n  gr_clear();\n\n  int text_y = kMarginHeight;\n  int text_x = kMarginWidth;\n  int line_spacing = gr_sys_font()->char_height;  // Put some extra space between images.\n  // Write the header and descriptive texts.\n  SetColor(INFO);\n  std::string header = \"Show background text image\";\n  text_y += DrawTextLine(text_x, text_y, header.c_str(), true);\n  std::string locale_selection = android::base::StringPrintf(\n      \"Current locale: %s, %zu/%zu\", locales_entries[sel].c_str(), sel, locales_entries.size());\n  const char* instruction[] = { locale_selection.c_str(),\n                                \"Use volume up/down to switch locales and power to exit.\",\n                                nullptr };\n  text_y += DrawWrappedTextLines(text_x, text_y, instruction);\n\n  // Iterate through the text images and display them in order for the current locale.\n  for (const auto& p : surfaces) {\n    text_y += line_spacing;\n    SetColor(LOG);\n    text_y += DrawTextLine(text_x, text_y, p.first.c_str(), false);\n    gr_color(255, 255, 255, 255);\n    gr_texticon(text_x, text_y, p.second.get());\n    text_y += gr_get_height(p.second.get());\n  }\n  // Update the whole screen.\n  gr_flip();\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::CheckBackgroundTextImages(const std::string& saved_locale) {\n  // Load a list of locales embedded in one of the resource files.\n  std::vector<std::string> locales_entries = get_locales_in_png(\"installing_text\");\n  if (locales_entries.empty()) {\n    Print(\"Failed to load locales from the resource files\\n\");\n    return;\n  }\n  size_t selected = 0;\n  SelectAndShowBackgroundText(locales_entries, selected);\n\n  FlushKeys();\n  while (true) {\n    int key = WaitKey();\n    if (key == KEY_POWER || key == KEY_ENTER) {\n      break;\n    } else if (key == KEY_UP || key == KEY_VOLUMEUP) {\n      selected = (selected == 0) ? locales_entries.size() - 1 : selected - 1;\n      SelectAndShowBackgroundText(locales_entries, selected);\n    } else if (key == KEY_DOWN || key == KEY_VOLUMEDOWN) {\n      selected = (selected == locales_entries.size() - 1) ? 0 : selected + 1;\n      SelectAndShowBackgroundText(locales_entries, selected);\n    }\n  }\n\n  SetLocale(saved_locale);\n}\n\nint ScreenRecoveryUI::ScreenWidth() const {\n  return gr_fb_width();\n}\n\nint ScreenRecoveryUI::ScreenHeight() const {\n  return gr_fb_height();\n}\n\nvoid ScreenRecoveryUI::DrawSurface(GRSurface* surface, int sx, int sy, int w, int h, int dx,\n                                   int dy) const {\n  gr_blit(surface, sx, sy, w, h, dx, dy);\n}\n\nint ScreenRecoveryUI::DrawHorizontalRule(int y) const {\n  gr_fill(0, y + 4, ScreenWidth(), y + 6);\n  return 8;\n}\n\nvoid ScreenRecoveryUI::DrawHighlightBar(int x, int y, int width, int height) const {\n  gr_fill(x, y, x + width, y + height);\n}\n\nvoid ScreenRecoveryUI::DrawFill(int x, int y, int w, int h) const {\n  gr_fill(x, y, w, h);\n}\n\nvoid ScreenRecoveryUI::DrawTextIcon(int x, int y, GRSurface* surface) const {\n  gr_texticon(x, y, surface);\n}\n\nint ScreenRecoveryUI::DrawTextLine(int x, int y, const char* line, bool bold) const {\n  gr_text(gr_sys_font(), x, y, line, bold);\n  return char_height_ + 4;\n}\n\nint ScreenRecoveryUI::DrawTextLines(int x, int y, const char* const* lines) const {\n  int offset = 0;\n  for (size_t i = 0; lines != nullptr && lines[i] != nullptr; ++i) {\n    offset += DrawTextLine(x, y + offset, lines[i], false);\n  }\n  return offset;\n}\n\nint ScreenRecoveryUI::DrawWrappedTextLines(int x, int y, const char* const* lines) const {\n  int offset = 0;\n  for (size_t i = 0; lines != nullptr && lines[i] != nullptr; ++i) {\n    // The line will be wrapped if it exceeds text_cols_.\n    std::string line(lines[i]);\n    size_t next_start = 0;\n    while (next_start < line.size()) {\n      std::string sub = line.substr(next_start, text_cols_ + 1);\n      if (sub.size() <= text_cols_) {\n        next_start += sub.size();\n      } else {\n        // Line too long and must be wrapped to text_cols_ columns.\n        size_t last_space = sub.find_last_of(\" \\t\\n\");\n        if (last_space == std::string::npos) {\n          // No space found, just draw as much as we can\n          sub.resize(text_cols_);\n          next_start += text_cols_;\n        } else {\n          sub.resize(last_space);\n          next_start += last_space + 1;\n        }\n      }\n      offset += DrawTextLine(x, y + offset, sub.c_str(), false);\n    }\n  }\n  return offset;\n}\n\nstatic const char* REGULAR_HELP[] = {\n  \"Use volume up/down and power.\",\n  NULL\n};\n\nstatic const char* LONG_PRESS_HELP[] = {\n  \"Any button cycles highlight.\",\n  \"Long-press activates.\",\n  NULL\n};\n\n// Redraws everything on the screen. Does not flip pages. Should only be called with updateMutex\n// locked.\nvoid ScreenRecoveryUI::draw_screen_locked() {\n  if (!show_text) {\n    draw_background_locked();\n    draw_foreground_locked();\n    return;\n  }\n\n  gr_color(0, 0, 0, 255);\n  gr_clear();\n\n  int y = kMarginHeight;\n  if (show_menu) {\n    static constexpr int kMenuIndent = 4;\n    int x = kMarginWidth + kMenuIndent;\n\n    SetColor(INFO);\n    y += DrawTextLine(x, y, \"Android Recovery\", true);\n    std::string recovery_fingerprint =\n        android::base::GetProperty(\"ro.bootimage.build.fingerprint\", \"\");\n    for (const auto& chunk : android::base::Split(recovery_fingerprint, \":\")) {\n      y += DrawTextLine(x, y, chunk.c_str(), false);\n    }\n    y += DrawTextLines(x, y, HasThreeButtons() ? REGULAR_HELP : LONG_PRESS_HELP);\n\n    SetColor(HEADER);\n    // Ignore kMenuIndent, which is not taken into account by text_cols_.\n    y += DrawWrappedTextLines(kMarginWidth, y, menu_headers_);\n\n    SetColor(MENU);\n    y += DrawHorizontalRule(y) + 4;\n    for (int i = 0; i < menu_items; ++i) {\n      if (i == menu_sel) {\n        // Draw the highlight bar.\n        SetColor(IsLongPress() ? MENU_SEL_BG_ACTIVE : MENU_SEL_BG);\n        DrawHighlightBar(0, y - 2, ScreenWidth(), char_height_ + 4);\n        // Bold white text for the selected item.\n        SetColor(MENU_SEL_FG);\n        y += DrawTextLine(x, y, menu_[i].c_str(), true);\n        SetColor(MENU);\n      } else {\n        y += DrawTextLine(x, y, menu_[i].c_str(), false);\n      }\n    }\n    y += DrawHorizontalRule(y);\n  }\n\n  // Display from the bottom up, until we hit the top of the screen, the bottom of the menu, or\n  // we've displayed the entire text buffer.\n  SetColor(LOG);\n  int row = text_row_;\n  size_t count = 0;\n  for (int ty = ScreenHeight() - kMarginHeight - char_height_; ty >= y && count < text_rows_;\n       ty -= char_height_, ++count) {\n    DrawTextLine(kMarginWidth, ty, text_[row], false);\n    --row;\n    if (row < 0) row = text_rows_ - 1;\n  }\n}\n\n// Redraw everything on the screen and flip the screen (make it visible).\n// Should only be called with updateMutex locked.\nvoid ScreenRecoveryUI::update_screen_locked() {\n  draw_screen_locked();\n  gr_flip();\n}\n\n// Updates only the progress bar, if possible, otherwise redraws the screen.\n// Should only be called with updateMutex locked.\nvoid ScreenRecoveryUI::update_progress_locked() {\n  if (show_text || !pagesIdentical) {\n    draw_screen_locked();  // Must redraw the whole screen\n    pagesIdentical = true;\n  } else {\n    draw_foreground_locked();  // Draw only the progress bar and overlays\n  }\n  gr_flip();\n}\n\n// Keeps the progress bar updated, even when the process is otherwise busy.\nvoid* ScreenRecoveryUI::ProgressThreadStartRoutine(void* data) {\n  reinterpret_cast<ScreenRecoveryUI*>(data)->ProgressThreadLoop();\n  return nullptr;\n}\n\nvoid ScreenRecoveryUI::ProgressThreadLoop() {\n  double interval = 1.0 / kAnimationFps;\n  while (true) {\n    double start = now();\n    pthread_mutex_lock(&updateMutex);\n\n    bool redraw = false;\n\n    // update the installation animation, if active\n    // skip this if we have a text overlay (too expensive to update)\n    if ((currentIcon == INSTALLING_UPDATE || currentIcon == ERASING) && !show_text) {\n      if (!intro_done) {\n        if (current_frame == intro_frames - 1) {\n          intro_done = true;\n          current_frame = 0;\n        } else {\n          ++current_frame;\n        }\n      } else {\n        current_frame = (current_frame + 1) % loop_frames;\n      }\n\n      redraw = true;\n    }\n\n    // move the progress bar forward on timed intervals, if configured\n    int duration = progressScopeDuration;\n    if (progressBarType == DETERMINATE && duration > 0) {\n      double elapsed = now() - progressScopeTime;\n      float p = 1.0 * elapsed / duration;\n      if (p > 1.0) p = 1.0;\n      if (p > progress) {\n        progress = p;\n        redraw = true;\n      }\n    }\n\n    if (redraw) update_progress_locked();\n\n    pthread_mutex_unlock(&updateMutex);\n    double end = now();\n    // minimum of 20ms delay between frames\n    double delay = interval - (end - start);\n    if (delay < 0.02) delay = 0.02;\n    usleep(static_cast<useconds_t>(delay * 1000000));\n  }\n}\n\nvoid ScreenRecoveryUI::LoadBitmap(const char* filename, GRSurface** surface) {\n  int result = res_create_display_surface(filename, surface);\n  if (result < 0) {\n    LOG(ERROR) << \"couldn't load bitmap \" << filename << \" (error \" << result << \")\";\n  }\n}\n\nvoid ScreenRecoveryUI::LoadLocalizedBitmap(const char* filename, GRSurface** surface) {\n  int result = res_create_localized_alpha_surface(filename, locale_.c_str(), surface);\n  if (result < 0) {\n    LOG(ERROR) << \"couldn't load bitmap \" << filename << \" (error \" << result << \")\";\n  }\n}\n\nstatic char** Alloc2d(size_t rows, size_t cols) {\n  char** result = new char*[rows];\n  for (size_t i = 0; i < rows; ++i) {\n    result[i] = new char[cols];\n    memset(result[i], 0, cols);\n  }\n  return result;\n}\n\n// Choose the right background string to display during update.\nvoid ScreenRecoveryUI::SetSystemUpdateText(bool security_update) {\n  if (security_update) {\n    LoadLocalizedBitmap(\"installing_security_text\", &installing_text);\n  } else {\n    LoadLocalizedBitmap(\"installing_text\", &installing_text);\n  }\n  Redraw();\n}\n\nbool ScreenRecoveryUI::InitTextParams() {\n  if (gr_init() < 0) {\n    return false;\n  }\n\n  gr_font_size(gr_sys_font(), &char_width_, &char_height_);\n  text_rows_ = (ScreenHeight() - kMarginHeight * 2) / char_height_;\n  text_cols_ = (ScreenWidth() - kMarginWidth * 2) / char_width_;\n  return true;\n}\n\nbool ScreenRecoveryUI::Init(const std::string& locale) {\n  RecoveryUI::Init(locale);\n\n  if (!InitTextParams()) {\n    return false;\n  }\n\n  // Are we portrait or landscape?\n  layout_ = (gr_fb_width() > gr_fb_height()) ? LANDSCAPE : PORTRAIT;\n  // Are we the large variant of our base layout?\n  if (gr_fb_height() > PixelsFromDp(800)) ++layout_;\n\n  text_ = Alloc2d(text_rows_, text_cols_ + 1);\n  file_viewer_text_ = Alloc2d(text_rows_, text_cols_ + 1);\n\n  text_col_ = text_row_ = 0;\n\n  // Set up the locale info.\n  SetLocale(locale);\n\n  LoadBitmap(\"icon_error\", &error_icon);\n\n  LoadBitmap(\"progress_empty\", &progressBarEmpty);\n  LoadBitmap(\"progress_fill\", &progressBarFill);\n\n  LoadBitmap(\"stage_empty\", &stageMarkerEmpty);\n  LoadBitmap(\"stage_fill\", &stageMarkerFill);\n\n  // Background text for \"installing_update\" could be \"installing update\"\n  // or \"installing security update\". It will be set after UI init according\n  // to commands in BCB.\n  installing_text = nullptr;\n  LoadLocalizedBitmap(\"erasing_text\", &erasing_text);\n  LoadLocalizedBitmap(\"no_command_text\", &no_command_text);\n  LoadLocalizedBitmap(\"error_text\", &error_text);\n\n  LoadAnimation();\n\n  pthread_create(&progress_thread_, nullptr, ProgressThreadStartRoutine, this);\n\n  return true;\n}\n\nvoid ScreenRecoveryUI::LoadAnimation() {\n  std::unique_ptr<DIR, decltype(&closedir)> dir(opendir(\"/res/images\"), closedir);\n  dirent* de;\n  std::vector<std::string> intro_frame_names;\n  std::vector<std::string> loop_frame_names;\n\n  while ((de = readdir(dir.get())) != nullptr) {\n    int value, num_chars;\n    if (sscanf(de->d_name, \"intro%d%n.png\", &value, &num_chars) == 1) {\n      intro_frame_names.emplace_back(de->d_name, num_chars);\n    } else if (sscanf(de->d_name, \"loop%d%n.png\", &value, &num_chars) == 1) {\n      loop_frame_names.emplace_back(de->d_name, num_chars);\n    }\n  }\n\n  intro_frames = intro_frame_names.size();\n  loop_frames = loop_frame_names.size();\n\n  // It's okay to not have an intro.\n  if (intro_frames == 0) intro_done = true;\n  // But you must have an animation.\n  if (loop_frames == 0) abort();\n\n  std::sort(intro_frame_names.begin(), intro_frame_names.end());\n  std::sort(loop_frame_names.begin(), loop_frame_names.end());\n\n  introFrames = new GRSurface*[intro_frames];\n  for (size_t i = 0; i < intro_frames; i++) {\n    LoadBitmap(intro_frame_names.at(i).c_str(), &introFrames[i]);\n  }\n\n  loopFrames = new GRSurface*[loop_frames];\n  for (size_t i = 0; i < loop_frames; i++) {\n    LoadBitmap(loop_frame_names.at(i).c_str(), &loopFrames[i]);\n  }\n}\n\nvoid ScreenRecoveryUI::SetBackground(Icon icon) {\n  pthread_mutex_lock(&updateMutex);\n\n  currentIcon = icon;\n  update_screen_locked();\n\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::SetProgressType(ProgressType type) {\n  pthread_mutex_lock(&updateMutex);\n  if (progressBarType != type) {\n    progressBarType = type;\n  }\n  progressScopeStart = 0;\n  progressScopeSize = 0;\n  progress = 0;\n  update_progress_locked();\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::ShowProgress(float portion, float seconds) {\n  pthread_mutex_lock(&updateMutex);\n  progressBarType = DETERMINATE;\n  progressScopeStart += progressScopeSize;\n  progressScopeSize = portion;\n  progressScopeTime = now();\n  progressScopeDuration = seconds;\n  progress = 0;\n  update_progress_locked();\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::SetProgress(float fraction) {\n  pthread_mutex_lock(&updateMutex);\n  if (fraction < 0.0) fraction = 0.0;\n  if (fraction > 1.0) fraction = 1.0;\n  if (progressBarType == DETERMINATE && fraction > progress) {\n    // Skip updates that aren't visibly different.\n    int width = gr_get_width(progressBarEmpty);\n    float scale = width * progressScopeSize;\n    if ((int)(progress * scale) != (int)(fraction * scale)) {\n      progress = fraction;\n      update_progress_locked();\n    }\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::SetStage(int current, int max) {\n  pthread_mutex_lock(&updateMutex);\n  stage = current;\n  max_stage = max;\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::PrintV(const char* fmt, bool copy_to_stdout, va_list ap) {\n  std::string str;\n  android::base::StringAppendV(&str, fmt, ap);\n\n  if (copy_to_stdout) {\n    fputs(str.c_str(), stdout);\n  }\n\n  pthread_mutex_lock(&updateMutex);\n  if (text_rows_ > 0 && text_cols_ > 0) {\n    for (const char* ptr = str.c_str(); *ptr != '\\0'; ++ptr) {\n      if (*ptr == '\\n' || text_col_ >= text_cols_) {\n        text_[text_row_][text_col_] = '\\0';\n        text_col_ = 0;\n        text_row_ = (text_row_ + 1) % text_rows_;\n      }\n      if (*ptr != '\\n') text_[text_row_][text_col_++] = *ptr;\n    }\n    text_[text_row_][text_col_] = '\\0';\n    update_screen_locked();\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::Print(const char* fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  PrintV(fmt, true, ap);\n  va_end(ap);\n}\n\nvoid ScreenRecoveryUI::PrintOnScreenOnly(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  PrintV(fmt, false, ap);\n  va_end(ap);\n}\n\nvoid ScreenRecoveryUI::PutChar(char ch) {\n  pthread_mutex_lock(&updateMutex);\n  if (ch != '\\n') text_[text_row_][text_col_++] = ch;\n  if (ch == '\\n' || text_col_ >= text_cols_) {\n    text_col_ = 0;\n    ++text_row_;\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::ClearText() {\n  pthread_mutex_lock(&updateMutex);\n  text_col_ = 0;\n  text_row_ = 0;\n  for (size_t i = 0; i < text_rows_; ++i) {\n    memset(text_[i], 0, text_cols_ + 1);\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::ShowFile(FILE* fp) {\n  std::vector<off_t> offsets;\n  offsets.push_back(ftello(fp));\n  ClearText();\n\n  struct stat sb;\n  fstat(fileno(fp), &sb);\n\n  bool show_prompt = false;\n  while (true) {\n    if (show_prompt) {\n      PrintOnScreenOnly(\"--(%d%% of %d bytes)--\",\n                        static_cast<int>(100 * (double(ftello(fp)) / double(sb.st_size))),\n                        static_cast<int>(sb.st_size));\n      Redraw();\n      while (show_prompt) {\n        show_prompt = false;\n        int key = WaitKey();\n        if (key == KEY_POWER || key == KEY_ENTER) {\n          return;\n        } else if (key == KEY_UP || key == KEY_VOLUMEUP) {\n          if (offsets.size() <= 1) {\n            show_prompt = true;\n          } else {\n            offsets.pop_back();\n            fseek(fp, offsets.back(), SEEK_SET);\n          }\n        } else {\n          if (feof(fp)) {\n            return;\n          }\n          offsets.push_back(ftello(fp));\n        }\n      }\n      ClearText();\n    }\n\n    int ch = getc(fp);\n    if (ch == EOF) {\n      while (text_row_ < text_rows_ - 1) PutChar('\\n');\n      show_prompt = true;\n    } else {\n      PutChar(ch);\n      if (text_col_ == 0 && text_row_ >= text_rows_ - 1) {\n        show_prompt = true;\n      }\n    }\n  }\n}\n\nvoid ScreenRecoveryUI::ShowFile(const char* filename) {\n  FILE* fp = fopen_path(filename, \"re\");\n  if (fp == nullptr) {\n    Print(\"  Unable to open %s: %s\\n\", filename, strerror(errno));\n    return;\n  }\n\n  char** old_text = text_;\n  size_t old_text_col = text_col_;\n  size_t old_text_row = text_row_;\n\n  // Swap in the alternate screen and clear it.\n  text_ = file_viewer_text_;\n  ClearText();\n\n  ShowFile(fp);\n  fclose(fp);\n\n  text_ = old_text;\n  text_col_ = old_text_col;\n  text_row_ = old_text_row;\n}\n\nvoid ScreenRecoveryUI::StartMenu(const char* const* headers, const char* const* items,\n                                 int initial_selection) {\n  pthread_mutex_lock(&updateMutex);\n  if (text_rows_ > 0 && text_cols_ > 0) {\n    menu_headers_ = headers;\n    menu_.clear();\n    for (size_t i = 0; i < text_rows_ && items[i] != nullptr; ++i) {\n      menu_.emplace_back(std::string(items[i], strnlen(items[i], text_cols_ - 1)));\n    }\n    menu_items = static_cast<int>(menu_.size());\n    show_menu = true;\n    menu_sel = initial_selection;\n    update_screen_locked();\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nint ScreenRecoveryUI::SelectMenu(int sel) {\n  pthread_mutex_lock(&updateMutex);\n  if (show_menu) {\n    int old_sel = menu_sel;\n    menu_sel = sel;\n\n    // Wrap at top and bottom.\n    if (menu_sel < 0) menu_sel = menu_items - 1;\n    if (menu_sel >= menu_items) menu_sel = 0;\n\n    sel = menu_sel;\n    if (menu_sel != old_sel) update_screen_locked();\n  }\n  pthread_mutex_unlock(&updateMutex);\n  return sel;\n}\n\nvoid ScreenRecoveryUI::EndMenu() {\n  pthread_mutex_lock(&updateMutex);\n  if (show_menu && text_rows_ > 0 && text_cols_ > 0) {\n    show_menu = false;\n    update_screen_locked();\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nbool ScreenRecoveryUI::IsTextVisible() {\n  pthread_mutex_lock(&updateMutex);\n  int visible = show_text;\n  pthread_mutex_unlock(&updateMutex);\n  return visible;\n}\n\nbool ScreenRecoveryUI::WasTextEverVisible() {\n  pthread_mutex_lock(&updateMutex);\n  int ever_visible = show_text_ever;\n  pthread_mutex_unlock(&updateMutex);\n  return ever_visible;\n}\n\nvoid ScreenRecoveryUI::ShowText(bool visible) {\n  pthread_mutex_lock(&updateMutex);\n  show_text = visible;\n  if (show_text) show_text_ever = true;\n  update_screen_locked();\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::Redraw() {\n  pthread_mutex_lock(&updateMutex);\n  update_screen_locked();\n  pthread_mutex_unlock(&updateMutex);\n}\n\nvoid ScreenRecoveryUI::KeyLongPress(int) {\n  // Redraw so that if we're in the menu, the highlight\n  // will change color to indicate a successful long press.\n  Redraw();\n}\n\nvoid ScreenRecoveryUI::SetLocale(const std::string& new_locale) {\n  locale_ = new_locale;\n  rtl_locale_ = false;\n\n  if (!new_locale.empty()) {\n    size_t underscore = new_locale.find('_');\n    // lang has the language prefix prior to '_', or full string if '_' doesn't exist.\n    std::string lang = new_locale.substr(0, underscore);\n\n    // A bit cheesy: keep an explicit list of supported RTL languages.\n    if (lang == \"ar\" ||  // Arabic\n        lang == \"fa\" ||  // Persian (Farsi)\n        lang == \"he\" ||  // Hebrew (new language code)\n        lang == \"iw\" ||  // Hebrew (old language code)\n        lang == \"ur\") {  // Urdu\n      rtl_locale_ = true;\n    }\n  }\n}\n"
        },
        {
          "name": "screen_ui.h",
          "type": "blob",
          "size": 6.66796875,
          "content": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_SCREEN_UI_H\n#define RECOVERY_SCREEN_UI_H\n\n#include <pthread.h>\n#include <stdio.h>\n\n#include <string>\n#include <vector>\n\n#include \"ui.h\"\n\n// From minui/minui.h.\nstruct GRSurface;\n\n// Implementation of RecoveryUI appropriate for devices with a screen\n// (shows an icon + a progress bar, text logging, menu, etc.)\nclass ScreenRecoveryUI : public RecoveryUI {\n public:\n  enum UIElement {\n    HEADER,\n    MENU,\n    MENU_SEL_BG,\n    MENU_SEL_BG_ACTIVE,\n    MENU_SEL_FG,\n    LOG,\n    TEXT_FILL,\n    INFO\n  };\n\n  ScreenRecoveryUI();\n\n  bool Init(const std::string& locale) override;\n\n  // overall recovery state (\"background image\")\n  void SetBackground(Icon icon) override;\n  void SetSystemUpdateText(bool security_update) override;\n\n  // progress indicator\n  void SetProgressType(ProgressType type) override;\n  void ShowProgress(float portion, float seconds) override;\n  void SetProgress(float fraction) override;\n\n  void SetStage(int current, int max) override;\n\n  // text log\n  void ShowText(bool visible) override;\n  bool IsTextVisible() override;\n  bool WasTextEverVisible() override;\n\n  // printing messages\n  void Print(const char* fmt, ...) override __printflike(2, 3);\n  void PrintOnScreenOnly(const char* fmt, ...) override __printflike(2, 3);\n  void ShowFile(const char* filename) override;\n\n  // menu display\n  void StartMenu(const char* const* headers, const char* const* items,\n                 int initial_selection) override;\n  int SelectMenu(int sel) override;\n  void EndMenu() override;\n\n  void KeyLongPress(int) override;\n\n  void Redraw();\n\n  void SetColor(UIElement e) const;\n\n  // Check the background text image. Use volume up/down button to cycle through the locales\n  // embedded in the png file, and power button to go back to recovery main menu.\n  void CheckBackgroundTextImages(const std::string& saved_locale);\n\n protected:\n  // The margin that we don't want to use for showing texts (e.g. round screen, or screen with\n  // rounded corners).\n  const int kMarginWidth;\n  const int kMarginHeight;\n\n  // Number of frames per sec (default: 30) for both parts of the animation.\n  const int kAnimationFps;\n\n  // The scale factor from dp to pixels. 1.0 for mdpi, 4.0 for xxxhdpi.\n  const float kDensity;\n\n  virtual bool InitTextParams();\n\n  virtual void draw_background_locked();\n  virtual void draw_foreground_locked();\n  virtual void draw_screen_locked();\n  virtual void update_screen_locked();\n  virtual void update_progress_locked();\n\n  GRSurface* GetCurrentFrame() const;\n  GRSurface* GetCurrentText() const;\n\n  static void* ProgressThreadStartRoutine(void* data);\n  void ProgressThreadLoop();\n\n  virtual void ShowFile(FILE*);\n  virtual void PrintV(const char*, bool, va_list);\n  void PutChar(char);\n  void ClearText();\n\n  void LoadAnimation();\n  void LoadBitmap(const char* filename, GRSurface** surface);\n  void LoadLocalizedBitmap(const char* filename, GRSurface** surface);\n\n  int PixelsFromDp(int dp) const;\n  virtual int GetAnimationBaseline() const;\n  virtual int GetProgressBaseline() const;\n  virtual int GetTextBaseline() const;\n\n  // Returns pixel width of draw buffer.\n  virtual int ScreenWidth() const;\n  // Returns pixel height of draw buffer.\n  virtual int ScreenHeight() const;\n\n  // Draws a highlight bar at (x, y) - (x + width, y + height).\n  virtual void DrawHighlightBar(int x, int y, int width, int height) const;\n  // Draws a horizontal rule at Y. Returns the offset it should be moving along Y-axis.\n  virtual int DrawHorizontalRule(int y) const;\n  // Draws a line of text. Returns the offset it should be moving along Y-axis.\n  virtual int DrawTextLine(int x, int y, const char* line, bool bold) const;\n  // Draws surface portion (sx, sy, w, h) at screen location (dx, dy).\n  virtual void DrawSurface(GRSurface* surface, int sx, int sy, int w, int h, int dx, int dy) const;\n  // Draws rectangle at (x, y) - (x + w, y + h).\n  virtual void DrawFill(int x, int y, int w, int h) const;\n  // Draws given surface (surface->pixel_bytes = 1) as text at (x, y).\n  virtual void DrawTextIcon(int x, int y, GRSurface* surface) const;\n  // Draws multiple text lines. Returns the offset it should be moving along Y-axis.\n  int DrawTextLines(int x, int y, const char* const* lines) const;\n  // Similar to DrawTextLines() to draw multiple text lines, but additionally wraps long lines.\n  // Returns the offset it should be moving along Y-axis.\n  int DrawWrappedTextLines(int x, int y, const char* const* lines) const;\n\n  Icon currentIcon;\n\n  // The layout to use.\n  int layout_;\n\n  GRSurface* error_icon;\n\n  GRSurface* erasing_text;\n  GRSurface* error_text;\n  GRSurface* installing_text;\n  GRSurface* no_command_text;\n\n  GRSurface** introFrames;\n  GRSurface** loopFrames;\n\n  GRSurface* progressBarEmpty;\n  GRSurface* progressBarFill;\n  GRSurface* stageMarkerEmpty;\n  GRSurface* stageMarkerFill;\n\n  ProgressType progressBarType;\n\n  float progressScopeStart, progressScopeSize, progress;\n  double progressScopeTime, progressScopeDuration;\n\n  // true when both graphics pages are the same (except for the progress bar).\n  bool pagesIdentical;\n\n  size_t text_cols_, text_rows_;\n\n  // Log text overlay, displayed when a magic key is pressed.\n  char** text_;\n  size_t text_col_, text_row_;\n\n  bool show_text;\n  bool show_text_ever;  // has show_text ever been true?\n\n  std::vector<std::string> menu_;\n  const char* const* menu_headers_;\n  bool show_menu;\n  int menu_items, menu_sel;\n\n  // An alternate text screen, swapped with 'text_' when we're viewing a log file.\n  char** file_viewer_text_;\n\n  pthread_t progress_thread_;\n\n  // Number of intro frames and loop frames in the animation.\n  size_t intro_frames;\n  size_t loop_frames;\n\n  size_t current_frame;\n  bool intro_done;\n\n  int stage, max_stage;\n\n  int char_width_;\n  int char_height_;\n\n  // The locale that's used to show the rendered texts.\n  std::string locale_;\n  bool rtl_locale_;\n\n  pthread_mutex_t updateMutex;\n\n private:\n  void SetLocale(const std::string&);\n\n  // Display the background texts for \"erasing\", \"error\", \"no_command\" and \"installing\" for the\n  // selected locale.\n  void SelectAndShowBackgroundText(const std::vector<std::string>& locales_entries, size_t sel);\n};\n\n#endif  // RECOVERY_UI_H\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "sepolicy",
          "type": "tree",
          "content": null
        },
        {
          "name": "set_metadata.cpp",
          "type": "blob",
          "size": 2.818359375,
          "content": "/*\n * Copyright (C) 2014 The Team Win Recovery Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * The purpose of these functions is to try to get and set the proper\n * file permissions, SELinux contexts, owner, and group so that these\n * files are accessible when we boot up to normal Android via MTP and to\n * file manager apps. During early boot we try to read the contexts and\n * owner / group info from /data/media or from /data/media/0 and store\n * them in static variables. From there, we'll try to set the same\n * contexts, owner, and group information on most files we create during\n * operations like backups, copying the log, and MTP operations.\n */\n\n#include <sys/stat.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"selinux/selinux.h\"\n\nstatic security_context_t selinux_context;\nstruct stat s;\nstatic int has_stat = 0;\n\nint tw_get_context(const char* filename) {\n\tif (lgetfilecon(filename, &selinux_context) >= 0) {\n\t\tprintf(\"tw_get_context got selinux context: %s\\n\", selinux_context);\n\t\treturn 0;\n\t} else {\n\t\tprintf(\"tw_get_context failed to get selinux context\\n\");\n\t\tselinux_context = NULL;\n\t}\n\treturn -1;\n}\n\nint tw_get_stat(const char* filename) {\n\tif (lstat(filename, &s) == 0) {\n\t\thas_stat = 1;\n\t\treturn 0;\n\t}\n\tprintf(\"tw_get_stat failed to lstat '%s'\\n\", filename);\n\treturn -1;\n}\n\nint tw_get_default_metadata(const char* filename) {\n\tif (tw_get_context(filename) == 0 && tw_get_stat(filename) == 0)\n\t\treturn 0;\n\treturn -1;\n}\n\n// Most of this logging is disabled to prevent log spam if we are trying\n// to set contexts and permissions on file systems that do not support\n// these types of things (e.g. vfat / FAT / FAT32).\nint tw_set_default_metadata(const char* filename) {\n\tint ret = 0;\n\tstruct stat st;\n\n\tif (selinux_context == NULL) {\n\t\t//printf(\"selinux_context was null, '%s'\\n\", filename);\n\t\tret = -1;\n\t} else if (lsetfilecon(filename, selinux_context) < 0) {\n\t\t//printf(\"Failed to set default contexts on '%s'.\\n\", filename);\n\t\tret = -1;\n\t}\n\n\tif (lstat(filename, &st) == 0 && st.st_mode & S_IFREG && chmod(filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH) < 0) {\n\t\t//printf(\"Failed to chmod '%s'\\n\", filename);\n\t\tret = -1;\n\t}\n\n\tif (has_stat && chown(filename, s.st_uid, s.st_gid) < 0) {\n\t\t//printf(\"Failed to lchown '%s'.\\n\", filename);\n\t\tret = -1;\n\t}\n\t//printf(\"Done trying to set defaults on '%s'\\n\");\n\treturn ret;\n}\n"
        },
        {
          "name": "set_metadata.h",
          "type": "blob",
          "size": 1.41015625,
          "content": "/*\n * Copyright (C) 2014 The Team Win Recovery Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * The purpose of these functions is to try to get and set the proper\n * file permissions, SELinux contexts, owner, and group so that these\n * files are accessible when we boot up to normal Android via MTP and to\n * file manager apps. During early boot we try to read the contexts and\n * owner / group info from /data/media or from /data/media/0 and store\n * them in static variables. From there, we'll try to set the same\n * contexts, owner, and group information on most files we create during\n * operations like backups, copying the log, and MTP operations.\n */\n\n#ifndef _RECOVERY_SET_CONTEXTS_H\n#define _RECOVERY_SET_CONTEXTS_H\n\n#include <sys/stat.h>\n#include \"selinux/selinux.h\"\n\nint tw_get_default_metadata(const char* filename);\nint tw_set_default_metadata(const char* filename);\n\n#endif //_RECOVERY_SET_CONTEXTS_H\n"
        },
        {
          "name": "simg2img",
          "type": "tree",
          "content": null
        },
        {
          "name": "stub_ui.h",
          "type": "blob",
          "size": 1.9189453125,
          "content": "/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_STUB_UI_H\n#define RECOVERY_STUB_UI_H\n\n#include \"ui.h\"\n\n// Stub implementation of RecoveryUI for devices without screen.\nclass StubRecoveryUI : public RecoveryUI {\n public:\n  StubRecoveryUI() = default;\n\n  void SetBackground(Icon /* icon */) override {}\n  void SetSystemUpdateText(bool /* security_update */) override {}\n\n  // progress indicator\n  void SetProgressType(ProgressType /* type */) override {}\n  void ShowProgress(float /* portion */, float /* seconds */) override {}\n  void SetProgress(float /* fraction */) override {}\n\n  void SetStage(int /* current */, int /* max */) override {}\n\n  // text log\n  void ShowText(bool /* visible */) override {}\n  bool IsTextVisible() override {\n    return false;\n  }\n  bool WasTextEverVisible() override {\n    return false;\n  }\n\n  // printing messages\n  void Print(const char* fmt, ...) override {\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    va_end(ap);\n  }\n  void PrintOnScreenOnly(const char* /* fmt */, ...) override {}\n  void ShowFile(const char* /* filename */) override {}\n\n  // menu display\n  void StartMenu(const char* const* /* headers */, const char* const* /* items */,\n                 int /* initial_selection */) override {}\n  int SelectMenu(int sel) override {\n    return sel;\n  }\n  void EndMenu() override {}\n};\n\n#endif  // RECOVERY_STUB_UI_H\n"
        },
        {
          "name": "tarWrite.c",
          "type": "blob",
          "size": 2.7939453125,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"libtar/libtar.h\"\n#include \"twcommon.h\"\n\nint flush = 0, eot_count = -1;\nunsigned char *write_buffer;\nunsigned buffer_size = 4096;\nunsigned buffer_loc = 0;\nint buffer_status = 0;\nint prog_pipe = -1;\nconst unsigned long long progress_size = (unsigned long long)(T_BLOCKSIZE);\n\nvoid reinit_libtar_buffer(void) {\n\tflush = 0;\n\teot_count = -1;\n\tbuffer_loc = 0;\n\tbuffer_status = 1;\n}\n\nvoid init_libtar_buffer(unsigned new_buff_size, int pipe_fd) {\n\tif (new_buff_size != 0)\n\t\tbuffer_size = new_buff_size;\n\n\treinit_libtar_buffer();\n\twrite_buffer = (unsigned char*) malloc(sizeof(char *) * buffer_size);\n\tprog_pipe = pipe_fd;\n}\n\nvoid free_libtar_buffer(void) {\n\tif (buffer_status > 0)\n\t\tfree(write_buffer);\n\tbuffer_status = 0;\n\tprog_pipe = -1;\n}\n\nssize_t write_libtar_buffer(int fd, const void *buffer, size_t size) {\n\tvoid* ptr;\n\n\tif (flush == 0) {\n\t\tptr = write_buffer + buffer_loc;\n\t\tmemcpy(ptr, buffer, size);\n\t\tbuffer_loc += size;\n\t\tif (eot_count >= 0 && eot_count < 2)\n\t\t\teot_count++;\n\t\t\t/* At the end of the tar file, libtar will add 2 blank blocks.\n\t\t\t   Once we have received both EOT blocks, we will immediately\n\t\t\t   write anything in the buffer to the file.\n\t\t\t*/\n\n\t\tif (buffer_loc >= buffer_size || eot_count >= 2) {\n\t\t\tflush = 1;\n\t\t}\n\t}\n\tif (flush == 1) {\n\t\tflush = 0;\n\t\tif (buffer_loc == 0) {\n\t\t\t// nothing to write\n\t\t\treturn 0;\n\t\t}\n\t\tif (write(fd, write_buffer, buffer_loc) != (int)buffer_loc) {\n\t\t\tLOGERR(\"Error writing tar file!\\n\");\n\t\t\tbuffer_loc = 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tunsigned long long fs = (unsigned long long)(buffer_loc);\n\t\t\twrite(prog_pipe, &fs, sizeof(fs));\n\t\t\tbuffer_loc = 0;\n\t\t\treturn size;\n\t\t}\n\t} else {\n\t\treturn size;\n\t}\n\t// Shouldn't ever get here\n\treturn -1;\n}\n\nvoid flush_libtar_buffer(int fd) {\n\teot_count = 0;\n\tif (buffer_status)\n\t\tbuffer_status = 2;\n}\n\nvoid init_libtar_no_buffer(int pipe_fd) {\n\tbuffer_size = T_BLOCKSIZE;\n\tprog_pipe = pipe_fd;\n\tbuffer_status = 0;\n}\n\nssize_t write_libtar_no_buffer(int fd, const void *buffer, size_t size) {\n\twrite(prog_pipe, &progress_size, sizeof(progress_size));\n\treturn write(fd, buffer, size);\n}\n"
        },
        {
          "name": "tarWrite.h",
          "type": "blob",
          "size": 1.181640625,
          "content": "/*\n        Copyright 2013 bigbiff/Dees_Troy TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _TARWRITE_HEADER\n#define _TARWRITE_HEADER\n\nvoid reinit_libtar_buffer();\nvoid init_libtar_buffer(unsigned new_buff_size, int pipe_fd);\nvoid free_libtar_buffer();\nwritefunc_t write_libtar_buffer(int fd, const void *buffer, size_t size);\nvoid flush_libtar_buffer(int fd);\n\nvoid init_libtar_no_buffer(int pipe_fd);\nwritefunc_t write_libtar_no_buffer(int fd, const void *buffer, size_t size);\n\n#endif  // _TARWRITE_HEADER\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "toolbox",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "toybox",
          "type": "tree",
          "content": null
        },
        {
          "name": "tw_atomic.cpp",
          "type": "blob",
          "size": 1.8095703125,
          "content": "/*\n * Copyright (C) 2015 The Team Win Recovery Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <pthread.h>\n#include <stdio.h>\n#include \"tw_atomic.hpp\"\n\n/*\n * According to this documentation:\n * https://developer.android.com/training/articles/smp.html\n * it is recommended to use mutexes instead of atomics. This class\n * provides us with a wrapper to make \"atomic\" variables easy to use.\n */\n\nTWAtomicInt::TWAtomicInt(int initial_value /* = 0 */) {\n\tif (pthread_mutex_init(&mutex_lock, NULL) != 0) {\n\t\t// This should hopefully never happen. If it does, the\n\t\t// operations will not be atomic, but we will allow things to\n\t\t// continue anyway after logging the issue and just hope for\n\t\t// the best.\n\t\tprintf(\"TWAtomic error initializing mutex.\\n\");\n\t\tuse_mutex = false;\n\t} else {\n\t\tuse_mutex = true;\n\t}\n\tvalue = initial_value;\n}\n\nTWAtomicInt::~TWAtomicInt() {\n\tif (use_mutex)\n\t\tpthread_mutex_destroy(&mutex_lock);\n}\n\nvoid TWAtomicInt::set_value(int new_value) {\n\tif (use_mutex) {\n\t\tpthread_mutex_lock(&mutex_lock);\n\t\tvalue = new_value;\n\t\tpthread_mutex_unlock(&mutex_lock);\n\t} else {\n\t\tvalue = new_value;\n\t}\n}\n\nint TWAtomicInt::get_value(void) {\n\tint ret_val;\n\n\tif (use_mutex) {\n\t\tpthread_mutex_lock(&mutex_lock);\n\t\tret_val = value;\n\t\tpthread_mutex_unlock(&mutex_lock);\n\t} else {\n\t\tret_val = value;\n\t}\n\treturn ret_val;\n}\n"
        },
        {
          "name": "tw_atomic.hpp",
          "type": "blob",
          "size": 0.912109375,
          "content": "/*\n * Copyright (C) 2015 The Team Win Recovery Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _TWATOMIC_HPP_HEADER\n#define _TWATOMIC_HPP_HEADER\n\n#include <pthread.h>\n\nclass TWAtomicInt\n{\npublic:\n\tTWAtomicInt(int initial_value = 0);\n\t~TWAtomicInt();\n\tvoid set_value(int new_value);\n\tint get_value();\n\nprivate:\n\tint value;\n\tbool use_mutex;\n\tpthread_mutex_t mutex_lock;\n};\n\n#endif //_TWATOMIC_HPP_HEADER\n"
        },
        {
          "name": "twcommon.h",
          "type": "blob",
          "size": 1.216796875,
          "content": "/*\n    Copyright 2017 TeamWin\n    This file is part of TWRP/TeamWin Recovery Project.\n\n    TWRP is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    TWRP is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef TWCOMMON_HPP\n#define TWCOMMON_HPP\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef BUILD_TWRPTAR_MAIN\n#include \"gui/gui.h\"\n#define LOGERR(...) gui_print_color(\"error\", \"E:\" __VA_ARGS__)\n#define LOGINFO(...) fprintf(stdout, \"I:\" __VA_ARGS__)\n#else\n#include <stdio.h>\n#define LOGERR(...) printf(\"E:\" __VA_ARGS__)\n#define LOGINFO(...) printf(\"I:\" __VA_ARGS__)\n#define gui_print(...) printf( __VA_ARGS__ )\n#endif\n\n#define STRINGIFY(x) #x\n#define EXPAND(x) STRINGIFY(x)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // TWCOMMON_HPP\n"
        },
        {
          "name": "twinstall.cpp",
          "type": "blob",
          "size": 12.7861328125,
          "content": "/*\n\tCopyright 2012 to 2017 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <string.h>\n#include <stdio.h>\n\n#include \"twcommon.h\"\n#include \"mtdutils/mounts.h\"\n#include \"mtdutils/mtdutils.h\"\n\n#ifdef USE_MINZIP\n#include \"minzip/SysUtil.h\"\n#else\n#include \"otautil/SysUtil.h\"\n#include <ziparchive/zip_archive.h>\n#endif\n#include \"zipwrap.hpp\"\n#ifdef USE_OLD_VERIFIER\n#include \"verifier24/verifier.h\"\n#else\n#include \"verifier.h\"\n#endif\n#include \"variables.h\"\n#include \"data.hpp\"\n#include \"partitions.hpp\"\n#include \"twrpDigestDriver.hpp\"\n#include \"twrpDigest/twrpDigest.hpp\"\n#include \"twrpDigest/twrpMD5.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"gui/gui.hpp\"\n#include \"gui/pages.hpp\"\n#include \"legacy_property_service.h\"\n#include \"twinstall.h\"\n#include \"installcommand.h\"\nextern \"C\" {\n\t#include \"gui/gui.h\"\n}\n\n#define AB_OTA \"payload_properties.txt\"\n\nstatic const char* properties_path = \"/dev/__properties__\";\nstatic const char* properties_path_renamed = \"/dev/__properties_kk__\";\nstatic bool legacy_props_env_initd = false;\nstatic bool legacy_props_path_modified = false;\n\nenum zip_type {\n\tUNKNOWN_ZIP_TYPE = 0,\n\tUPDATE_BINARY_ZIP_TYPE,\n\tAB_OTA_ZIP_TYPE,\n\tTWRP_THEME_ZIP_TYPE\n};\n\n// to support pre-KitKat update-binaries that expect properties in the legacy format\nstatic int switch_to_legacy_properties()\n{\n\tif (!legacy_props_env_initd) {\n\t\tif (legacy_properties_init() != 0)\n\t\t\treturn -1;\n\n\t\tchar tmp[32];\n\t\tint propfd, propsz;\n\t\tlegacy_get_property_workspace(&propfd, &propsz);\n\t\tsprintf(tmp, \"%d,%d\", dup(propfd), propsz);\n\t\tsetenv(\"ANDROID_PROPERTY_WORKSPACE\", tmp, 1);\n\t\tlegacy_props_env_initd = true;\n\t}\n\n\tif (TWFunc::Path_Exists(properties_path)) {\n\t\t// hide real properties so that the updater uses the envvar to find the legacy format properties\n\t\tif (rename(properties_path, properties_path_renamed) != 0) {\n\t\t\tLOGERR(\"Renaming %s failed: %s\\n\", properties_path, strerror(errno));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tlegacy_props_path_modified = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int switch_to_new_properties()\n{\n\tif (TWFunc::Path_Exists(properties_path_renamed)) {\n\t\tif (rename(properties_path_renamed, properties_path) != 0) {\n\t\t\tLOGERR(\"Renaming %s failed: %s\\n\", properties_path_renamed, strerror(errno));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tlegacy_props_path_modified = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int Install_Theme(const char* path, ZipWrap *Zip) {\n#ifdef TW_OEM_BUILD // We don't do custom themes in OEM builds\n\tZip->Close();\n\treturn INSTALL_CORRUPT;\n#else\n\tif (!Zip->EntryExists(\"ui.xml\")) {\n\t\treturn INSTALL_CORRUPT;\n\t}\n\tZip->Close();\n\tif (!PartitionManager.Mount_Settings_Storage(true))\n\t\treturn INSTALL_ERROR;\n\tstring theme_path = DataManager::GetSettingsStoragePath();\n\ttheme_path += \"/TWRP/theme\";\n\tif (!TWFunc::Path_Exists(theme_path)) {\n\t\tif (!TWFunc::Recursive_Mkdir(theme_path)) {\n\t\t\treturn INSTALL_ERROR;\n\t\t}\n\t}\n\ttheme_path += \"/ui.zip\";\n\tif (TWFunc::copy_file(path, theme_path, 0644) != 0) {\n\t\treturn INSTALL_ERROR;\n\t}\n\tLOGINFO(\"Installing custom theme '%s' to '%s'\\n\", path, theme_path.c_str());\n\tPageManager::RequestReload();\n\treturn INSTALL_SUCCESS;\n#endif\n}\n\nstatic int Prepare_Update_Binary(const char *path, ZipWrap *Zip, int* wipe_cache) {\n\tif (!Zip->ExtractEntry(ASSUMED_UPDATE_BINARY_NAME, TMP_UPDATER_BINARY_PATH, 0755)) {\n\t\tZip->Close();\n\t\tLOGERR(\"Could not extract '%s'\\n\", ASSUMED_UPDATE_BINARY_NAME);\n\t\treturn INSTALL_ERROR;\n\t}\n\n\t// If exists, extract file_contexts from the zip file\n\tif (!Zip->EntryExists(\"file_contexts\")) {\n\t\tZip->Close();\n\t\tLOGINFO(\"Zip does not contain SELinux file_contexts file in its root.\\n\");\n\t} else {\n\t\tconst string output_filename = \"/file_contexts\";\n\t\tLOGINFO(\"Zip contains SELinux file_contexts file in its root. Extracting to %s\\n\", output_filename.c_str());\n\t\tif (!Zip->ExtractEntry(\"file_contexts\", output_filename, 0644)) {\n\t\t\tZip->Close();\n\t\t\tLOGERR(\"Could not extract '%s'\\n\", output_filename.c_str());\n\t\t\treturn INSTALL_ERROR;\n\t\t}\n\t}\n\tZip->Close();\n\treturn INSTALL_SUCCESS;\n}\n\nstatic bool update_binary_has_legacy_properties(const char *binary) {\n\tconst char str_to_match[] = \"ANDROID_PROPERTY_WORKSPACE\";\n\tint len_to_match = sizeof(str_to_match) - 1;\n\tbool found = false;\n\n\tint fd = open(binary, O_RDONLY);\n\tif (fd < 0) {\n\t\tLOGINFO(\"has_legacy_properties: Could not open %s: %s!\\n\", binary, strerror(errno));\n\t\treturn false;\n\t}\n\n\tstruct stat finfo;\n\tif (fstat(fd, &finfo) < 0) {\n\t\tLOGINFO(\"has_legacy_properties: Could not fstat %d: %s!\\n\", fd, strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tvoid *data = mmap(NULL, finfo.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (data == MAP_FAILED) {\n\t\tLOGINFO(\"has_legacy_properties: mmap (size=%zu) failed: %s!\\n\", finfo.st_size, strerror(errno));\n\t} else {\n\t\tif (memmem(data, finfo.st_size, str_to_match, len_to_match)) {\n\t\t\tLOGINFO(\"has_legacy_properties: Found legacy property match!\\n\");\n\t\t\tfound = true;\n\t\t}\n\t\tmunmap(data, finfo.st_size);\n\t}\n\tclose(fd);\n\n\treturn found;\n}\n\nstatic int Run_Update_Binary(const char *path, ZipWrap *Zip, int* wipe_cache, zip_type ztype) {\n\tint ret_val, pipe_fd[2], status, zip_verify;\n\tchar buffer[1024];\n\tFILE* child_data;\n\n#ifndef TW_NO_LEGACY_PROPS\n\tif (!update_binary_has_legacy_properties(TMP_UPDATER_BINARY_PATH)) {\n\t\tLOGINFO(\"Legacy property environment not used in updater.\\n\");\n\t} else if (switch_to_legacy_properties() != 0) { /* Set legacy properties */\n\t\tLOGERR(\"Legacy property environment did not initialize successfully. Properties may not be detected.\\n\");\n\t} else {\n\t\tLOGINFO(\"Legacy property environment initialized.\\n\");\n\t}\n#endif\n\n\tpipe(pipe_fd);\n\n\tstd::vector<std::string> args;\n    if (ztype == UPDATE_BINARY_ZIP_TYPE) {\n\t\tret_val = update_binary_command(path, 0, pipe_fd[1], &args);\n    } else if (ztype == AB_OTA_ZIP_TYPE) {\n\t\tret_val = abupdate_binary_command(path, Zip, 0, pipe_fd[1], &args);\n\t} else {\n\t\tLOGERR(\"Unknown zip type %i\\n\", ztype);\n\t\tret_val = INSTALL_CORRUPT;\n\t}\n    if (ret_val) {\n        close(pipe_fd[0]);\n        close(pipe_fd[1]);\n        return ret_val;\n    }\n\n\t// Convert the vector to a NULL-terminated char* array suitable for execv.\n\tconst char* chr_args[args.size() + 1];\n\tchr_args[args.size()] = NULL;\n\tfor (size_t i = 0; i < args.size(); i++)\n\t\tchr_args[i] = args[i].c_str();\n\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t\tclose(pipe_fd[0]);\n\t\texecve(chr_args[0], const_cast<char**>(chr_args), environ);\n\t\tprintf(\"E:Can't execute '%s': %s\\n\", chr_args[0], strerror(errno));\n\t\t_exit(-1);\n\t}\n\tclose(pipe_fd[1]);\n\n\t*wipe_cache = 0;\n\n\tDataManager::GetValue(TW_SIGNED_ZIP_VERIFY_VAR, zip_verify);\n\tchild_data = fdopen(pipe_fd[0], \"r\");\n\twhile (fgets(buffer, sizeof(buffer), child_data) != NULL) {\n\t\tchar* command = strtok(buffer, \" \\n\");\n\t\tif (command == NULL) {\n\t\t\tcontinue;\n\t\t} else if (strcmp(command, \"progress\") == 0) {\n\t\t\tchar* fraction_char = strtok(NULL, \" \\n\");\n\t\t\tchar* seconds_char = strtok(NULL, \" \\n\");\n\n\t\t\tfloat fraction_float = strtof(fraction_char, NULL);\n\t\t\tint seconds_float = strtol(seconds_char, NULL, 10);\n\n\t\t\tif (zip_verify)\n\t\t\t\tDataManager::ShowProgress(fraction_float * (1 - VERIFICATION_PROGRESS_FRAC), seconds_float);\n\t\t\telse\n\t\t\t\tDataManager::ShowProgress(fraction_float, seconds_float);\n\t\t} else if (strcmp(command, \"set_progress\") == 0) {\n\t\t\tchar* fraction_char = strtok(NULL, \" \\n\");\n\t\t\tfloat fraction_float = strtof(fraction_char, NULL);\n\t\t\tDataManager::SetProgress(fraction_float);\n\t\t} else if (strcmp(command, \"ui_print\") == 0) {\n\t\t\tchar* display_value = strtok(NULL, \"\\n\");\n\t\t\tif (display_value) {\n\t\t\t\tgui_print(\"%s\", display_value);\n\t\t\t} else {\n\t\t\t\tgui_print(\"\\n\");\n\t\t\t}\n\t\t} else if (strcmp(command, \"wipe_cache\") == 0) {\n\t\t\t*wipe_cache = 1;\n\t\t} else if (strcmp(command, \"clear_display\") == 0) {\n\t\t\t// Do nothing, not supported by TWRP\n\t\t} else if (strcmp(command, \"log\") == 0) {\n\t\t\tprintf(\"%s\\n\", strtok(NULL, \"\\n\"));\n\t\t} else {\n\t\t\tLOGERR(\"unknown command [%s]\\n\", command);\n\t\t}\n\t}\n\tfclose(child_data);\n\n\tint waitrc = TWFunc::Wait_For_Child(pid, &status, \"Updater\");\n\n#ifndef TW_NO_LEGACY_PROPS\n\t/* Unset legacy properties */\n\tif (legacy_props_path_modified) {\n\t\tif (switch_to_new_properties() != 0) {\n\t\t\tLOGERR(\"Legacy property environment did not disable successfully. Legacy properties may still be in use.\\n\");\n\t\t} else {\n\t\t\tLOGINFO(\"Legacy property environment disabled.\\n\");\n\t\t}\n\t}\n#endif\n\n\tif (waitrc != 0)\n\t\treturn INSTALL_ERROR;\n\n\treturn INSTALL_SUCCESS;\n}\n\nint TWinstall_zip(const char* path, int* wipe_cache) {\n\tint ret_val, zip_verify = 1;\n\n\tif (strcmp(path, \"error\") == 0) {\n\t\tLOGERR(\"Failed to get adb sideload file: '%s'\\n\", path);\n\t\treturn INSTALL_CORRUPT;\n\t}\n\n\tgui_msg(Msg(\"installing_zip=Installing zip file '{1}'\")(path));\n\tif (strlen(path) < 9 || strncmp(path, \"/sideload\", 9) != 0) {\n\t\tstring digest_str;\n\t\tstring Full_Filename = path;\n\t\tstring digest_file = path;\n\t\tstring defmd5file = digest_file + \".md5sum\";\n\n\t\tif (TWFunc::Path_Exists(defmd5file)) {\n\t\t\tdigest_file += \".md5sum\";\n\t\t}\n\t\telse {\n\t\t\tdigest_file += \".md5\";\n\t\t}\n\n\t\tgui_msg(\"check_for_digest=Checking for Digest file...\");\n\t\tif (!TWFunc::Path_Exists(digest_file)) {\n\t\t\tgui_msg(\"no_digest=Skipping Digest check: no Digest file found\");\n\t\t}\n\t\telse {\n\t\t\tif (TWFunc::read_file(digest_file, digest_str) != 0) {\n\t\t\t\tLOGERR(\"Skipping MD5 check: MD5 file unreadable\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttwrpDigest *digest = new twrpMD5();\n\t\t\t\tif (!twrpDigestDriver::stream_file_to_digest(Full_Filename, digest)) {\n\t\t\t\t\tdelete digest;\n\t\t\t\t\treturn INSTALL_CORRUPT;\n\t\t\t\t}\n\t\t\t\tstring digest_check = digest->return_digest_string();\n\t\t\t\tif (digest_str == digest_check) {\n\t\t\t\t\tgui_msg(Msg(\"digest_matched=Digest matched for '{1}'.\")(path));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOGERR(\"Aborting zip install: Digest verification failed\\n\");\n\t\t\t\t\tdelete digest;\n\t\t\t\t\treturn INSTALL_CORRUPT;\n\t\t\t\t}\n\t\t\t\tdelete digest;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef TW_OEM_BUILD\n\tDataManager::GetValue(TW_SIGNED_ZIP_VERIFY_VAR, zip_verify);\n#endif\n\tDataManager::SetProgress(0);\n\n\tMemMapping map;\n#ifdef USE_MINZIP\n\tif (sysMapFile(path, &map) != 0) {\n#else\n\tif (!map.MapFile(path)) {\n#endif\n\t\tgui_msg(Msg(msg::kError, \"fail_sysmap=Failed to map file '{1}'\")(path));\n\t\treturn -1;\n\t}\n\n\tif (zip_verify) {\n\t\tgui_msg(\"verify_zip_sig=Verifying zip signature...\");\n#ifdef USE_OLD_VERIFIER\n\t\tret_val = verify_file(map.addr, map.length);\n#else\n\t\tstd::vector<Certificate> loadedKeys;\n\t\tif (!load_keys(\"/res/keys\", loadedKeys)) {\n\t\t\tLOGINFO(\"Failed to load keys\");\n\t\t\tgui_err(\"verify_zip_fail=Zip signature verification failed!\");\n#ifdef USE_MINZIP\n\t\t\tsysReleaseMap(&map);\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tret_val = verify_file(map.addr, map.length, loadedKeys, std::bind(&DataManager::SetProgress, std::placeholders::_1));\n#endif\n\t\tif (ret_val != VERIFY_SUCCESS) {\n\t\t\tLOGINFO(\"Zip signature verification failed: %i\\n\", ret_val);\n\t\t\tgui_err(\"verify_zip_fail=Zip signature verification failed!\");\n#ifdef USE_MINZIP\n\t\t\tsysReleaseMap(&map);\n#endif\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tgui_msg(\"verify_zip_done=Zip signature verified successfully.\");\n\t\t}\n\t}\n\tZipWrap Zip;\n\tif (!Zip.Open(path, &map)) {\n\t\tgui_err(\"zip_corrupt=Zip file is corrupt!\");\n#ifdef USE_MINZIP\n\t\t\tsysReleaseMap(&map);\n#endif\n\t\treturn INSTALL_CORRUPT;\n\t}\n\n\ttime_t start, stop;\n\ttime(&start);\n\tif (Zip.EntryExists(ASSUMED_UPDATE_BINARY_NAME)) {\n\t\tLOGINFO(\"Update binary zip\\n\");\n\t\t// Additionally verify the compatibility of the package.\n\t\tif (!verify_package_compatibility(&Zip)) {\n\t\t\tgui_err(\"zip_compatible_err=Zip Treble compatibility error!\");\n\t\t\tZip.Close();\n#ifdef USE_MINZIP\n\t\t\tsysReleaseMap(&map);\n#endif\n\t\t\tret_val = INSTALL_CORRUPT;\n\t\t} else {\n\t\t\tret_val = Prepare_Update_Binary(path, &Zip, wipe_cache);\n\t\t\tif (ret_val == INSTALL_SUCCESS)\n\t\t\t\tret_val = Run_Update_Binary(path, &Zip, wipe_cache, UPDATE_BINARY_ZIP_TYPE);\n\t\t}\n\t} else {\n\t\tif (Zip.EntryExists(AB_OTA)) {\n\t\t\tLOGINFO(\"AB zip\\n\");\n\t\t\tret_val = Run_Update_Binary(path, &Zip, wipe_cache, AB_OTA_ZIP_TYPE);\n\t\t} else {\n\t\t\tif (Zip.EntryExists(\"ui.xml\")) {\n\t\t\t\tLOGINFO(\"TWRP theme zip\\n\");\n\t\t\t\tret_val = Install_Theme(path, &Zip);\n\t\t\t} else {\n\t\t\t\tZip.Close();\n\t\t\t\tret_val = INSTALL_CORRUPT;\n\t\t\t}\n\t\t}\n\t}\n\ttime(&stop);\n\tint total_time = (int) difftime(stop, start);\n\tif (ret_val == INSTALL_CORRUPT) {\n\t\tgui_err(\"invalid_zip_format=Invalid zip file format!\");\n\t} else {\n\t\tLOGINFO(\"Install took %i second(s).\\n\", total_time);\n\t}\n#ifdef USE_MINZIP\n\tsysReleaseMap(&map);\n#endif\n\treturn ret_val;\n}\n"
        },
        {
          "name": "twinstall.h",
          "type": "blob",
          "size": 0.1455078125,
          "content": "#ifndef RECOVERY_TWINSTALL_H_\n#define RECOVERY_TWINSTALL_H_\n\nint TWinstall_zip(const char* path, int* wipe_cache);\n\n#endif  // RECOVERY_TWINSTALL_H_\n"
        },
        {
          "name": "twinstallorig.cpp",
          "type": "blob",
          "size": 12.3603515625,
          "content": "/*\n\tCopyright 2012 to 2016 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <string.h>\n#include <stdio.h>\n\n#include \"twcommon.h\"\n#include \"mtdutils/mounts.h\"\n#include \"mtdutils/mtdutils.h\"\n#include \"minzip/SysUtil.h\"\n#include \"minzip/Zip.h\"\n#ifdef USE_OLD_VERIFIER\n#include \"verifier24/verifier.h\"\n#else\n#include \"verifier.h\"\n#endif\n#include \"variables.h\"\n#include \"data.hpp\"\n#include \"partitions.hpp\"\n#include \"twrpDigestDriver.hpp\"\n#include \"twrpDigest/twrpDigest.hpp\"\n#include \"twrpDigest/twrpMD5.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"gui/gui.hpp\"\n#include \"gui/pages.hpp\"\n#include \"legacy_property_service.h\"\n#include \"twinstall.h\"\n#include \"installcommand.h\"\nextern \"C\" {\n\t#include \"gui/gui.h\"\n}\n\n#define AB_OTA \"payload_properties.txt\"\n\nstatic const char* properties_path = \"/dev/__properties__\";\nstatic const char* properties_path_renamed = \"/dev/__properties_kk__\";\nstatic bool legacy_props_env_initd = false;\nstatic bool legacy_props_path_modified = false;\n\nenum zip_type {\n\tUNKNOWN_ZIP_TYPE = 0,\n\tUPDATE_BINARY_ZIP_TYPE,\n\tAB_OTA_ZIP_TYPE,\n\tTWRP_THEME_ZIP_TYPE\n};\n\n// to support pre-KitKat update-binaries that expect properties in the legacy format\nstatic int switch_to_legacy_properties()\n{\n\tif (!legacy_props_env_initd) {\n\t\tif (legacy_properties_init() != 0)\n\t\t\treturn -1;\n\n\t\tchar tmp[32];\n\t\tint propfd, propsz;\n\t\tlegacy_get_property_workspace(&propfd, &propsz);\n\t\tsprintf(tmp, \"%d,%d\", dup(propfd), propsz);\n\t\tsetenv(\"ANDROID_PROPERTY_WORKSPACE\", tmp, 1);\n\t\tlegacy_props_env_initd = true;\n\t}\n\n\tif (TWFunc::Path_Exists(properties_path)) {\n\t\t// hide real properties so that the updater uses the envvar to find the legacy format properties\n\t\tif (rename(properties_path, properties_path_renamed) != 0) {\n\t\t\tLOGERR(\"Renaming %s failed: %s\\n\", properties_path, strerror(errno));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tlegacy_props_path_modified = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int switch_to_new_properties()\n{\n\tif (TWFunc::Path_Exists(properties_path_renamed)) {\n\t\tif (rename(properties_path_renamed, properties_path) != 0) {\n\t\t\tLOGERR(\"Renaming %s failed: %s\\n\", properties_path_renamed, strerror(errno));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tlegacy_props_path_modified = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int Install_Theme(const char* path, ZipArchive *Zip) {\n#ifdef TW_OEM_BUILD // We don't do custom themes in OEM builds\n\tmzCloseZipArchive(Zip);\n\treturn INSTALL_CORRUPT;\n#else\n\tconst ZipEntry* xml_location = mzFindZipEntry(Zip, \"ui.xml\");\n\n\tmzCloseZipArchive(Zip);\n\tif (xml_location == NULL) {\n\t\treturn INSTALL_CORRUPT;\n\t}\n\tif (!PartitionManager.Mount_Settings_Storage(true))\n\t\treturn INSTALL_ERROR;\n\tstring theme_path = DataManager::GetSettingsStoragePath();\n\ttheme_path += \"/TWRP/theme\";\n\tif (!TWFunc::Path_Exists(theme_path)) {\n\t\tif (!TWFunc::Recursive_Mkdir(theme_path)) {\n\t\t\treturn INSTALL_ERROR;\n\t\t}\n\t}\n\ttheme_path += \"/ui.zip\";\n\tif (TWFunc::copy_file(path, theme_path, 0644) != 0) {\n\t\treturn INSTALL_ERROR;\n\t}\n\tLOGINFO(\"Installing custom theme '%s' to '%s'\\n\", path, theme_path.c_str());\n\tPageManager::RequestReload();\n\treturn INSTALL_SUCCESS;\n#endif\n}\n\nstatic int Prepare_Update_Binary(const char *path, ZipArchive *Zip, int* wipe_cache) {\n\tconst ZipEntry* binary_location = mzFindZipEntry(Zip, ASSUMED_UPDATE_BINARY_NAME);\n\tint binary_fd, ret_val;\n\n\tif (binary_location == NULL) {\n\t\treturn INSTALL_CORRUPT;\n\t}\n\n\t// Delete any existing updater\n\tif (TWFunc::Path_Exists(TMP_UPDATER_BINARY_PATH) && unlink(TMP_UPDATER_BINARY_PATH) != 0) {\n\t\tLOGINFO(\"Unable to unlink '%s': %s\\n\", TMP_UPDATER_BINARY_PATH, strerror(errno));\n\t}\n\n\tbinary_fd = creat(TMP_UPDATER_BINARY_PATH, 0755);\n\tif (binary_fd < 0) {\n\t\tLOGERR(\"Could not create file for updater extract in '%s': %s\\n\", TMP_UPDATER_BINARY_PATH, strerror(errno));\n\t\tmzCloseZipArchive(Zip);\n\t\treturn INSTALL_ERROR;\n\t}\n\n\tret_val = mzExtractZipEntryToFile(Zip, binary_location, binary_fd);\n\tclose(binary_fd);\n\n\tif (!ret_val) {\n\t\tmzCloseZipArchive(Zip);\n\t\tLOGERR(\"Could not extract '%s'\\n\", ASSUMED_UPDATE_BINARY_NAME);\n\t\treturn INSTALL_ERROR;\n\t}\n\n\t// If exists, extract file_contexts from the zip file\n\tconst ZipEntry* selinx_contexts = mzFindZipEntry(Zip, \"file_contexts\");\n\tif (selinx_contexts == NULL) {\n\t\tmzCloseZipArchive(Zip);\n\t\tLOGINFO(\"Zip does not contain SELinux file_contexts file in its root.\\n\");\n\t} else {\n\t\tstring output_filename = \"/file_contexts\";\n\t\tLOGINFO(\"Zip contains SELinux file_contexts file in its root. Extracting to %s\\n\", output_filename.c_str());\n\t\t// Delete any file_contexts\n\t\tif (TWFunc::Path_Exists(output_filename) && unlink(output_filename.c_str()) != 0) {\n\t\t\tLOGINFO(\"Unable to unlink '%s': %s\\n\", output_filename.c_str(), strerror(errno));\n\t\t}\n\n\t\tint file_contexts_fd = creat(output_filename.c_str(), 0644);\n\t\tif (file_contexts_fd < 0) {\n\t\t\tLOGERR(\"Could not extract to '%s': %s\\n\", output_filename.c_str(), strerror(errno));\n\t\t\tmzCloseZipArchive(Zip);\n\t\t\treturn INSTALL_ERROR;\n\t\t}\n\n\t\tret_val = mzExtractZipEntryToFile(Zip, selinx_contexts, file_contexts_fd);\n\t\tclose(file_contexts_fd);\n\n\t\tif (!ret_val) {\n\t\t\tmzCloseZipArchive(Zip);\n\t\t\tLOGERR(\"Could not extract '%s'\\n\", output_filename.c_str());\n\t\t\treturn INSTALL_ERROR;\n\t\t}\n\t}\n\tmzCloseZipArchive(Zip);\n\treturn INSTALL_SUCCESS;\n}\n\nstatic int Run_Update_Binary(const char *path, ZipArchive *Zip, int* wipe_cache, zip_type ztype) {\n\tint ret_val, pipe_fd[2], status, zip_verify;\n\tchar buffer[1024];\n\tFILE* child_data;\n\n#ifndef TW_NO_LEGACY_PROPS\n\t/* Set legacy properties */\n\tif (switch_to_legacy_properties() != 0) {\n\t\tLOGERR(\"Legacy property environment did not initialize successfully. Properties may not be detected.\\n\");\n\t} else {\n\t\tLOGINFO(\"Legacy property environment initialized.\\n\");\n\t}\n#endif\n\n\tpipe(pipe_fd);\n\n\tstd::vector<std::string> args;\n    if (ztype == UPDATE_BINARY_ZIP_TYPE) {\n\t\tret_val = update_binary_command(path, Zip, 0, pipe_fd[1], &args);\n    } else if (ztype == AB_OTA_ZIP_TYPE) {\n\t\tret_val = abupdate_binary_command(path, Zip, 0, pipe_fd[1], &args);\n\t} else {\n\t\tLOGERR(\"Unknown zip type %i\\n\", ztype);\n\t\tret_val = INSTALL_CORRUPT;\n\t}\n    if (ret_val) {\n        close(pipe_fd[0]);\n        close(pipe_fd[1]);\n        return ret_val;\n    }\n\n\t// Convert the vector to a NULL-terminated char* array suitable for execv.\n\tconst char* chr_args[args.size() + 1];\n\tchr_args[args.size()] = NULL;\n\tfor (size_t i = 0; i < args.size(); i++)\n\t\tchr_args[i] = args[i].c_str();\n\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t\tclose(pipe_fd[0]);\n\t\texecve(chr_args[0], const_cast<char**>(chr_args), environ);\n\t\tprintf(\"E:Can't execute '%s': %s\\n\", chr_args[0], strerror(errno));\n\t\t_exit(-1);\n\t}\n\tclose(pipe_fd[1]);\n\n\t*wipe_cache = 0;\n\n\tDataManager::GetValue(TW_SIGNED_ZIP_VERIFY_VAR, zip_verify);\n\tchild_data = fdopen(pipe_fd[0], \"r\");\n\twhile (fgets(buffer, sizeof(buffer), child_data) != NULL) {\n\t\tchar* command = strtok(buffer, \" \\n\");\n\t\tif (command == NULL) {\n\t\t\tcontinue;\n\t\t} else if (strcmp(command, \"progress\") == 0) {\n\t\t\tchar* fraction_char = strtok(NULL, \" \\n\");\n\t\t\tchar* seconds_char = strtok(NULL, \" \\n\");\n\n\t\t\tfloat fraction_float = strtof(fraction_char, NULL);\n\t\t\tint seconds_float = strtol(seconds_char, NULL, 10);\n\n\t\t\tif (zip_verify)\n\t\t\t\tDataManager::ShowProgress(fraction_float * (1 - VERIFICATION_PROGRESS_FRACTION), seconds_float);\n\t\t\telse\n\t\t\t\tDataManager::ShowProgress(fraction_float, seconds_float);\n\t\t} else if (strcmp(command, \"set_progress\") == 0) {\n\t\t\tchar* fraction_char = strtok(NULL, \" \\n\");\n\t\t\tfloat fraction_float = strtof(fraction_char, NULL);\n\t\t\tDataManager::SetProgress(fraction_float);\n\t\t} else if (strcmp(command, \"ui_print\") == 0) {\n\t\t\tchar* display_value = strtok(NULL, \"\\n\");\n\t\t\tif (display_value) {\n\t\t\t\tgui_print(\"%s\", display_value);\n\t\t\t} else {\n\t\t\t\tgui_print(\"\\n\");\n\t\t\t}\n\t\t} else if (strcmp(command, \"wipe_cache\") == 0) {\n\t\t\t*wipe_cache = 1;\n\t\t} else if (strcmp(command, \"clear_display\") == 0) {\n\t\t\t// Do nothing, not supported by TWRP\n\t\t} else if (strcmp(command, \"log\") == 0) {\n\t\t\tprintf(\"%s\\n\", strtok(NULL, \"\\n\"));\n\t\t} else {\n\t\t\tLOGERR(\"unknown command [%s]\\n\", command);\n\t\t}\n\t}\n\tfclose(child_data);\n\n\tint waitrc = TWFunc::Wait_For_Child(pid, &status, \"Updater\");\n\n#ifndef TW_NO_LEGACY_PROPS\n\t/* Unset legacy properties */\n\tif (legacy_props_path_modified) {\n\t\tif (switch_to_new_properties() != 0) {\n\t\t\tLOGERR(\"Legacy property environment did not disable successfully. Legacy properties may still be in use.\\n\");\n\t\t} else {\n\t\t\tLOGINFO(\"Legacy property environment disabled.\\n\");\n\t\t}\n\t}\n#endif\n\n\tif (waitrc != 0)\n\t\treturn INSTALL_ERROR;\n\n\treturn INSTALL_SUCCESS;\n}\n\nextern \"C\" int TWinstall_zip(const char* path, int* wipe_cache) {\n\tint ret_val, zip_verify = 1;\n\tZipArchive Zip;\n\n\tif (strcmp(path, \"error\") == 0) {\n\t\tLOGERR(\"Failed to get adb sideload file: '%s'\\n\", path);\n\t\treturn INSTALL_CORRUPT;\n\t}\n\n\tgui_msg(Msg(\"installing_zip=Installing zip file '{1}'\")(path));\n\tif (strlen(path) < 9 || strncmp(path, \"/sideload\", 9) != 0) {\n\t\tstring digest_str;\n\t\tstring Full_Filename = path;\n\t\tstring digest_file = path;\n\t\tdigest_file += \".md5\";\n\n\t\tgui_msg(\"check_for_digest=Checking for Digest file...\");\n\t\tif (!TWFunc::Path_Exists(digest_file)) {\n\t\t\tgui_msg(\"no_digest=Skipping Digest check: no Digest file found\");\n\t\t}\n\t\telse {\n\t\t\tif (TWFunc::read_file(digest_file, digest_str) != 0) {\n\t\t\t\tLOGERR(\"Skipping MD5 check: MD5 file unreadable\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttwrpDigest *digest = new twrpMD5();\n\t\t\t\tif (!twrpDigestDriver::stream_file_to_digest(Full_Filename, digest)) {\n\t\t\t\t\tdelete digest;\n\t\t\t\t\treturn INSTALL_CORRUPT;\n\t\t\t\t}\n\t\t\t\tstring digest_check = digest->return_digest_string();\n\t\t\t\tif (digest_str == digest_check) {\n\t\t\t\t\tgui_msg(Msg(\"digest_matched=Digest matched for '{1}'.\")(path));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tLOGERR(\"Aborting zip install: Digest verification failed\\n\");\n\t\t\t\t\tdelete digest;\n\t\t\t\t\treturn INSTALL_CORRUPT;\n\t\t\t\t}\n\t\t\t\tdelete digest;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef TW_OEM_BUILD\n\tDataManager::GetValue(TW_SIGNED_ZIP_VERIFY_VAR, zip_verify);\n#endif\n\tDataManager::SetProgress(0);\n\n\tMemMapping map;\n\tif (sysMapFile(path, &map) != 0) {\n\t\tgui_msg(Msg(msg::kError, \"fail_sysmap=Failed to map file '{1}'\")(path));\n\t\treturn -1;\n\t}\n\n\tif (zip_verify) {\n\t\tgui_msg(\"verify_zip_sig=Verifying zip signature...\");\n\t\tstd::vector<Certificate> loadedKeys;\n\t\tif (!load_keys(\"/res/keys\", loadedKeys)) {\n\t\t\tLOGINFO(\"Failed to load keys\");\n\t\t\tgui_err(\"verify_zip_fail=Zip signature verification failed!\");\n\t\t\treturn -1;\n\t\t}\n\t\tret_val = verify_file(map.addr, map.length, loadedKeys, NULL);\n\t\tif (ret_val != VERIFY_SUCCESS) {\n\t\t\tLOGINFO(\"Zip signature verification failed: %i\\n\", ret_val);\n\t\t\tgui_err(\"verify_zip_fail=Zip signature verification failed!\");\n\t\t\tsysReleaseMap(&map);\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tgui_msg(\"verify_zip_done=Zip signature verified successfully.\");\n\t\t}\n\t}\n\tret_val = mzOpenZipArchive(map.addr, map.length, &Zip);\n\tif (ret_val != 0) {\n\t\tgui_err(\"zip_corrupt=Zip file is corrupt!\");\n\t\tsysReleaseMap(&map);\n\t\treturn INSTALL_CORRUPT;\n\t}\n\n\ttime_t start, stop;\n\ttime(&start);\n\tconst ZipEntry* file_location = mzFindZipEntry(&Zip, ASSUMED_UPDATE_BINARY_NAME);\n\tif (file_location != NULL) {\n\t\tLOGINFO(\"Update binary zip\\n\");\n\t\tret_val = Prepare_Update_Binary(path, &Zip, wipe_cache);\n\t\tif (ret_val == INSTALL_SUCCESS)\n\t\t\tret_val = Run_Update_Binary(path, &Zip, wipe_cache, UPDATE_BINARY_ZIP_TYPE);\n\t} else {\n\t\tfile_location = mzFindZipEntry(&Zip, AB_OTA);\n\t\tif (file_location != NULL) {\n\t\t\tLOGINFO(\"AB zip\\n\");\n\t\t\tret_val = Run_Update_Binary(path, &Zip, wipe_cache, AB_OTA_ZIP_TYPE);\n\t\t} else {\n\t\t\tfile_location = mzFindZipEntry(&Zip, \"ui.xml\");\n\t\t\tif (file_location != NULL) {\n\t\t\t\tLOGINFO(\"TWRP theme zip\\n\");\n\t\t\t\tret_val = Install_Theme(path, &Zip);\n\t\t\t} else {\n\t\t\t\tmzCloseZipArchive(&Zip);\n\t\t\t\tret_val = INSTALL_CORRUPT;\n\t\t\t}\n\t\t}\n\t}\n\ttime(&stop);\n\tint total_time = (int) difftime(stop, start);\n\tif (ret_val == INSTALL_CORRUPT) {\n\t\tgui_err(\"invalid_zip_format=Invalid zip file format!\");\n\t} else {\n\t\tLOGINFO(\"Install took %i second(s).\\n\", total_time);\n\t}\n\tsysReleaseMap(&map);\n\treturn ret_val;\n}\n"
        },
        {
          "name": "twinstallorig.h",
          "type": "blob",
          "size": 0.212890625,
          "content": "#ifndef RECOVERY_TWINSTALL_H_\n#define RECOVERY_TWINSTALL_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint TWinstall_zip(const char* path, int* wipe_cache);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // RECOVERY_TWINSTALL_H_\n"
        },
        {
          "name": "twrp-functions.cpp",
          "type": "blob",
          "size": 32.392578125,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <unistd.h>\n#include <vector>\n#include <dirent.h>\n#include <time.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/mount.h>\n#include <sys/reboot.h>\n#include <sys/sendfile.h>\n#include <sys/stat.h>\n#include <sys/vfs.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cctype>\n#include <algorithm>\n#include \"twrp-functions.hpp\"\n#include \"twcommon.h\"\n#include \"gui/gui.hpp\"\n#ifndef BUILD_TWRPTAR_MAIN\n#include \"data.hpp\"\n#include \"partitions.hpp\"\n#include \"variables.h\"\n#include \"bootloader_message_twrp/include/bootloader_message_twrp/bootloader_message.h\"\n#include \"cutils/properties.h\"\n#include \"cutils/android_reboot.h\"\n#include <sys/reboot.h>\n#endif // ndef BUILD_TWRPTAR_MAIN\n#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS\n\t#include \"openaes/inc/oaes_lib.h\"\n#endif\n#include \"set_metadata.h\"\n\nextern \"C\" {\n\t#include \"libcrecovery/common.h\"\n}\n\n/* Execute a command */\nint TWFunc::Exec_Cmd(const string& cmd, string &result) {\n\tFILE* exec;\n\tchar buffer[130];\n\tint ret = 0;\n\texec = __popen(cmd.c_str(), \"r\");\n\tif (!exec) return -1;\n\twhile (!feof(exec)) {\n\t\tif (fgets(buffer, 128, exec) != NULL) {\n\t\t\tresult += buffer;\n\t\t}\n\t}\n\tret = __pclose(exec);\n\treturn ret;\n}\n\nint TWFunc::Exec_Cmd(const string& cmd) {\n\tpid_t pid;\n\tint status;\n\tswitch(pid = fork())\n\t{\n\t\tcase -1:\n\t\t\tLOGERR(\"Exec_Cmd(): vfork failed: %d!\\n\", errno);\n\t\t\treturn -1;\n\t\tcase 0: // child\n\t\t\texecl(\"/sbin/sh\", \"sh\", \"-c\", cmd.c_str(), NULL);\n\t\t\t_exit(127);\n\t\t\tbreak;\n\t\tdefault:\n\t\t{\n\t\t\tif (TWFunc::Wait_For_Child(pid, &status, cmd) != 0)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n// Returns \"file.name\" from a full /path/to/file.name\nstring TWFunc::Get_Filename(const string& Path) {\n\tsize_t pos = Path.find_last_of(\"/\");\n\tif (pos != string::npos) {\n\t\tstring Filename;\n\t\tFilename = Path.substr(pos + 1, Path.size() - pos - 1);\n\t\treturn Filename;\n\t} else\n\t\treturn Path;\n}\n\n// Returns \"/path/to/\" from a full /path/to/file.name\nstring TWFunc::Get_Path(const string& Path) {\n\tsize_t pos = Path.find_last_of(\"/\");\n\tif (pos != string::npos) {\n\t\tstring Pathonly;\n\t\tPathonly = Path.substr(0, pos + 1);\n\t\treturn Pathonly;\n\t} else\n\t\treturn Path;\n}\n\nint TWFunc::Wait_For_Child(pid_t pid, int *status, string Child_Name) {\n\tpid_t rc_pid;\n\n\trc_pid = waitpid(pid, status, 0);\n\tif (rc_pid > 0) {\n\t\tif (WIFSIGNALED(*status)) {\n\t\t\tgui_msg(Msg(msg::kError, \"pid_signal={1} process ended with signal: {2}\")(Child_Name)(WTERMSIG(*status))); // Seg fault or some other non-graceful termination\n\t\t\treturn -1;\n\t\t} else if (WEXITSTATUS(*status) == 0) {\n\t\t\tLOGINFO(\"%s process ended with RC=%d\\n\", Child_Name.c_str(), WEXITSTATUS(*status)); // Success\n\t\t} else {\n\t\t\tgui_msg(Msg(msg::kError, \"pid_error={1} process ended with ERROR: {2}\")(Child_Name)(WEXITSTATUS(*status))); // Graceful exit, but there was an error\n\t\t\treturn -1;\n\t\t}\n\t} else { // no PID returned\n\t\tif (errno == ECHILD)\n\t\t\tLOGERR(\"%s no child process exist\\n\", Child_Name.c_str());\n\t\telse {\n\t\t\tLOGERR(\"%s Unexpected error %d\\n\", Child_Name.c_str(), errno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint TWFunc::Wait_For_Child_Timeout(pid_t pid, int *status, const string& Child_Name, int timeout) {\n\tpid_t retpid = waitpid(pid, status, WNOHANG);\n\tfor (; retpid == 0 && timeout; --timeout) {\n\t\tsleep(1);\n\t\tretpid = waitpid(pid, status, WNOHANG);\n\t}\n\tif (retpid == 0 && timeout == 0) {\n\t\tLOGERR(\"%s took too long, killing process\\n\", Child_Name.c_str());\n\t\tkill(pid, SIGKILL);\n\t\tfor (timeout = 5; retpid == 0 && timeout; --timeout) {\n\t\t\tsleep(1);\n\t\t\tretpid = waitpid(pid, status, WNOHANG);\n\t\t}\n\t\tif (retpid)\n\t\t\tLOGINFO(\"Child process killed successfully\\n\");\n\t\telse\n\t\t\tLOGINFO(\"Child process took too long to kill, may be a zombie process\\n\");\n\t\treturn -1;\n\t} else if (retpid > 0) {\n\t\tif (WIFSIGNALED(*status)) {\n\t\t\tgui_msg(Msg(msg::kError, \"pid_signal={1} process ended with signal: {2}\")(Child_Name)(WTERMSIG(*status))); // Seg fault or some other non-graceful termination\n\t\t\treturn -1;\n\t\t}\n\t} else if (retpid < 0) { // no PID returned\n\t\tif (errno == ECHILD)\n\t\t\tLOGERR(\"%s no child process exist\\n\", Child_Name.c_str());\n\t\telse {\n\t\t\tLOGERR(\"%s Unexpected error %d\\n\", Child_Name.c_str(), errno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool TWFunc::Path_Exists(string Path) {\n\tstruct stat st;\n\tif (stat(Path.c_str(), &st) != 0)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nArchive_Type TWFunc::Get_File_Type(string fn) {\n\tstring::size_type i = 0;\n\tint firstbyte = 0, secondbyte = 0;\n\tchar header[3];\n\n\tifstream f;\n\tf.open(fn.c_str(), ios::in | ios::binary);\n\tf.get(header, 3);\n\tf.close();\n\tfirstbyte = header[i] & 0xff;\n\tsecondbyte = header[++i] & 0xff;\n\n\tif (firstbyte == 0x1f && secondbyte == 0x8b)\n\t\treturn COMPRESSED;\n\telse if (firstbyte == 0x4f && secondbyte == 0x41)\n\t\treturn ENCRYPTED;\n\treturn UNCOMPRESSED; // default\n}\n\nint TWFunc::Try_Decrypting_File(string fn, string password) {\n#ifndef TW_EXCLUDE_ENCRYPTED_BACKUPS\n\tOAES_CTX * ctx = NULL;\n\tuint8_t _key_data[32] = \"\";\n\tFILE *f;\n\tuint8_t buffer[4096];\n\tuint8_t *buffer_out = NULL;\n\tuint8_t *ptr = NULL;\n\tsize_t read_len = 0, out_len = 0;\n\tint firstbyte = 0, secondbyte = 0;\n\tsize_t _j = 0;\n\tsize_t _key_data_len = 0;\n\n\t// mostly kanged from OpenAES oaes.c\n\tfor ( _j = 0; _j < 32; _j++ )\n\t\t_key_data[_j] = _j + 1;\n\t_key_data_len = password.size();\n\tif ( 16 >= _key_data_len )\n\t\t_key_data_len = 16;\n\telse if ( 24 >= _key_data_len )\n\t\t_key_data_len = 24;\n\telse\n\t\t_key_data_len = 32;\n\tmemcpy(_key_data, password.c_str(), password.size());\n\n\tctx = oaes_alloc();\n\tif (ctx == NULL) {\n\t\tLOGERR(\"Failed to allocate OAES\\n\");\n\t\treturn -1;\n\t}\n\n\toaes_key_import_data(ctx, _key_data, _key_data_len);\n\n\tf = fopen(fn.c_str(), \"rb\");\n\tif (f == NULL) {\n\t\tLOGERR(\"Failed to open '%s' to try decrypt: %s\\n\", fn.c_str(), strerror(errno));\n\t\toaes_free(&ctx);\n\t\treturn -1;\n\t}\n\tread_len = fread(buffer, sizeof(uint8_t), 4096, f);\n\tif (read_len <= 0) {\n\t\tLOGERR(\"Read size during try decrypt failed: %s\\n\", strerror(errno));\n\t\tfclose(f);\n\t\toaes_free(&ctx);\n\t\treturn -1;\n\t}\n\tif (oaes_decrypt(ctx, buffer, read_len, NULL, &out_len) != OAES_RET_SUCCESS) {\n\t\tLOGERR(\"Error: Failed to retrieve required buffer size for trying decryption.\\n\");\n\t\tfclose(f);\n\t\toaes_free(&ctx);\n\t\treturn -1;\n\t}\n\tbuffer_out = (uint8_t *) calloc(out_len, sizeof(char));\n\tif (buffer_out == NULL) {\n\t\tLOGERR(\"Failed to allocate output buffer for try decrypt.\\n\");\n\t\tfclose(f);\n\t\toaes_free(&ctx);\n\t\treturn -1;\n\t}\n\tif (oaes_decrypt(ctx, buffer, read_len, buffer_out, &out_len) != OAES_RET_SUCCESS) {\n\t\tLOGERR(\"Failed to decrypt file '%s'\\n\", fn.c_str());\n\t\tfclose(f);\n\t\tfree(buffer_out);\n\t\toaes_free(&ctx);\n\t\treturn 0;\n\t}\n\tfclose(f);\n\toaes_free(&ctx);\n\tif (out_len < 2) {\n\t\tLOGINFO(\"Successfully decrypted '%s' but read length too small.\\n\", fn.c_str());\n\t\tfree(buffer_out);\n\t\treturn 1; // Decrypted successfully\n\t}\n\tptr = buffer_out;\n\tfirstbyte = *ptr & 0xff;\n\tptr++;\n\tsecondbyte = *ptr & 0xff;\n\tif (firstbyte == 0x1f && secondbyte == 0x8b) {\n\t\tLOGINFO(\"Successfully decrypted '%s' and file is compressed.\\n\", fn.c_str());\n\t\tfree(buffer_out);\n\t\treturn 3; // Compressed\n\t}\n\tif (out_len >= 262) {\n\t\tptr = buffer_out + 257;\n\t\tif (strncmp((char*)ptr, \"ustar\", 5) == 0) {\n\t\t\tLOGINFO(\"Successfully decrypted '%s' and file is tar format.\\n\", fn.c_str());\n\t\t\tfree(buffer_out);\n\t\t\treturn 2; // Tar\n\t\t}\n\t}\n\tfree(buffer_out);\n\tLOGINFO(\"No errors decrypting '%s' but no known file format.\\n\", fn.c_str());\n\treturn 1; // Decrypted successfully\n#else\n\tLOGERR(\"Encrypted backup support not included.\\n\");\n\treturn -1;\n#endif\n}\n\nunsigned long TWFunc::Get_File_Size(const string& Path) {\n\tstruct stat st;\n\n\tif (stat(Path.c_str(), &st) != 0)\n\t\treturn 0;\n\treturn st.st_size;\n}\n\nstd::string TWFunc::Remove_Trailing_Slashes(const std::string& path, bool leaveLast)\n{\n\tstd::string res;\n\tsize_t last_idx = 0, idx = 0;\n\n\twhile (last_idx != std::string::npos)\n\t{\n\t\tif (last_idx != 0)\n\t\t\tres += '/';\n\n\t\tidx = path.find_first_of('/', last_idx);\n\t\tif (idx == std::string::npos) {\n\t\t\tres += path.substr(last_idx, idx);\n\t\t\tbreak;\n\t\t}\n\n\t\tres += path.substr(last_idx, idx-last_idx);\n\t\tlast_idx = path.find_first_not_of('/', idx);\n\t}\n\n\tif (leaveLast)\n\t\tres += '/';\n\treturn res;\n}\n\nvoid TWFunc::Strip_Quotes(char* &str) {\n\tif (strlen(str) > 0 && str[0] == '\\\"')\n\t\tstr++;\n\tif (strlen(str) > 0 && str[strlen(str)-1] == '\\\"')\n\t\tstr[strlen(str)-1] = 0;\n}\n\nvector<string> TWFunc::split_string(const string &in, char del, bool skip_empty) {\n\tvector<string> res;\n\n\tif (in.empty() || del == '\\0')\n\t\treturn res;\n\n\tstring field;\n\tistringstream f(in);\n\tif (del == '\\n') {\n\t\twhile (getline(f, field)) {\n\t\t\tif (field.empty() && skip_empty)\n\t\t\t\tcontinue;\n\t\t\tres.push_back(field);\n\t\t}\n\t} else {\n\t\twhile (getline(f, field, del)) {\n\t\t\tif (field.empty() && skip_empty)\n\t\t\t\tcontinue;\n\t\t\tres.push_back(field);\n\t\t}\n\t}\n\treturn res;\n}\n\ntimespec TWFunc::timespec_diff(timespec& start, timespec& end)\n{\n\ttimespec temp;\n\tif ((end.tv_nsec-start.tv_nsec)<0) {\n\t\ttemp.tv_sec = end.tv_sec-start.tv_sec-1;\n\t\ttemp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;\n\t} else {\n\t\ttemp.tv_sec = end.tv_sec-start.tv_sec;\n\t\ttemp.tv_nsec = end.tv_nsec-start.tv_nsec;\n\t}\n\treturn temp;\n}\n\nint32_t TWFunc::timespec_diff_ms(timespec& start, timespec& end)\n{\n\treturn ((end.tv_sec * 1000) + end.tv_nsec/1000000) -\n\t\t\t((start.tv_sec * 1000) + start.tv_nsec/1000000);\n}\n\n#ifndef BUILD_TWRPTAR_MAIN\n\n// Returns \"/path\" from a full /path/to/file.name\nstring TWFunc::Get_Root_Path(const string& Path) {\n\tstring Local_Path = Path;\n\n\t// Make sure that we have a leading slash\n\tif (Local_Path.substr(0, 1) != \"/\")\n\t\tLocal_Path = \"/\" + Local_Path;\n\n\t// Trim the path to get the root path only\n\tsize_t position = Local_Path.find(\"/\", 2);\n\tif (position != string::npos) {\n\t\tLocal_Path.resize(position);\n\t}\n\treturn Local_Path;\n}\n\nvoid TWFunc::install_htc_dumlock(void) {\n\tint need_libs = 0;\n\n\tif (!PartitionManager.Mount_By_Path(\"/system\", true))\n\t\treturn;\n\n\tif (!PartitionManager.Mount_By_Path(\"/data\", true))\n\t\treturn;\n\n\tgui_msg(\"install_dumlock=Installing HTC Dumlock to system...\");\n\tcopy_file(TWHTCD_PATH \"htcdumlocksys\", \"/system/bin/htcdumlock\", 0755);\n\tif (!Path_Exists(\"/system/bin/flash_image\")) {\n\t\tLOGINFO(\"Installing flash_image...\\n\");\n\t\tcopy_file(TWHTCD_PATH \"flash_imagesys\", \"/system/bin/flash_image\", 0755);\n\t\tneed_libs = 1;\n\t} else\n\t\tLOGINFO(\"flash_image is already installed, skipping...\\n\");\n\tif (!Path_Exists(\"/system/bin/dump_image\")) {\n\t\tLOGINFO(\"Installing dump_image...\\n\");\n\t\tcopy_file(TWHTCD_PATH \"dump_imagesys\", \"/system/bin/dump_image\", 0755);\n\t\tneed_libs = 1;\n\t} else\n\t\tLOGINFO(\"dump_image is already installed, skipping...\\n\");\n\tif (need_libs) {\n\t\tLOGINFO(\"Installing libs needed for flash_image and dump_image...\\n\");\n\t\tcopy_file(TWHTCD_PATH \"libbmlutils.so\", \"/system/lib/libbmlutils.so\", 0644);\n\t\tcopy_file(TWHTCD_PATH \"libflashutils.so\", \"/system/lib/libflashutils.so\", 0644);\n\t\tcopy_file(TWHTCD_PATH \"libmmcutils.so\", \"/system/lib/libmmcutils.so\", 0644);\n\t\tcopy_file(TWHTCD_PATH \"libmtdutils.so\", \"/system/lib/libmtdutils.so\", 0644);\n\t}\n\tLOGINFO(\"Installing HTC Dumlock app...\\n\");\n\tmkdir(\"/data/app\", 0777);\n\tunlink(\"/data/app/com.teamwin.htcdumlock*\");\n\tcopy_file(TWHTCD_PATH \"HTCDumlock.apk\", \"/data/app/com.teamwin.htcdumlock.apk\", 0777);\n\tsync();\n\tgui_msg(\"done=Done.\");\n}\n\nvoid TWFunc::htc_dumlock_restore_original_boot(void) {\n\tif (!PartitionManager.Mount_By_Path(\"/sdcard\", true))\n\t\treturn;\n\n\tgui_msg(\"dumlock_restore=Restoring original boot...\");\n\tExec_Cmd(\"htcdumlock restore\");\n\tgui_msg(\"done=Done.\");\n}\n\nvoid TWFunc::htc_dumlock_reflash_recovery_to_boot(void) {\n\tif (!PartitionManager.Mount_By_Path(\"/sdcard\", true))\n\t\treturn;\n\tgui_msg(\"dumlock_reflash=Reflashing recovery to boot...\");\n\tExec_Cmd(\"htcdumlock recovery noreboot\");\n\tgui_msg(\"done=Done.\");\n}\n\nint TWFunc::Recursive_Mkdir(string Path) {\n\tstd::vector<std::string> parts = Split_String(Path, \"/\", true);\n\tstd::string cur_path;\n\tfor (size_t i = 0; i < parts.size(); ++i) {\n\t\tcur_path += \"/\" + parts[i];\n\t\tif (!TWFunc::Path_Exists(cur_path)) {\n\t\t\tif (mkdir(cur_path.c_str(), 0777)) {\n\t\t\t\tgui_msg(Msg(msg::kError, \"create_folder_strerr=Can not create '{1}' folder ({2}).\")(cur_path)(strerror(errno)));\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\ttw_set_default_metadata(cur_path.c_str());\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid TWFunc::GUI_Operation_Text(string Read_Value, string Default_Text) {\n\tstring Display_Text;\n\n\tDataManager::GetValue(Read_Value, Display_Text);\n\tif (Display_Text.empty())\n\t\tDisplay_Text = Default_Text;\n\n\tDataManager::SetValue(\"tw_operation\", Display_Text);\n\tDataManager::SetValue(\"tw_partition\", \"\");\n}\n\nvoid TWFunc::GUI_Operation_Text(string Read_Value, string Partition_Name, string Default_Text) {\n\tstring Display_Text;\n\n\tDataManager::GetValue(Read_Value, Display_Text);\n\tif (Display_Text.empty())\n\t\tDisplay_Text = Default_Text;\n\n\tDataManager::SetValue(\"tw_operation\", Display_Text);\n\tDataManager::SetValue(\"tw_partition\", Partition_Name);\n}\n\nvoid TWFunc::Copy_Log(string Source, string Destination) {\n\tPartitionManager.Mount_By_Path(Destination, false);\n\tFILE *destination_log = fopen(Destination.c_str(), \"a\");\n\tif (destination_log == NULL) {\n\t\tLOGERR(\"TWFunc::Copy_Log -- Can't open destination log file: '%s'\\n\", Destination.c_str());\n\t} else {\n\t\tFILE *source_log = fopen(Source.c_str(), \"r\");\n\t\tif (source_log != NULL) {\n\t\t\tfseek(source_log, Log_Offset, SEEK_SET);\n\t\t\tchar buffer[4096];\n\t\t\twhile (fgets(buffer, sizeof(buffer), source_log))\n\t\t\t\tfputs(buffer, destination_log); // Buffered write of log file\n\t\t\tLog_Offset = ftell(source_log);\n\t\t\tfflush(source_log);\n\t\t\tfclose(source_log);\n\t\t}\n\t\tfflush(destination_log);\n\t\tfclose(destination_log);\n\t}\n}\n\nvoid TWFunc::Update_Log_File(void) {\n\t// Copy logs to cache so the system can find out what happened.\n\tif (PartitionManager.Mount_By_Path(\"/cache\", false)) {\n\t\tif (!TWFunc::Path_Exists(\"/cache/recovery/.\")) {\n\t\t\tLOGINFO(\"Recreating /cache/recovery folder.\\n\");\n\t\t\tif (mkdir(\"/cache/recovery\", S_IRWXU | S_IRWXG | S_IWGRP | S_IXGRP) != 0)\n\t\t\t\tLOGINFO(\"Unable to create /cache/recovery folder.\\n\");\n\t\t}\n\t\tCopy_Log(TMP_LOG_FILE, \"/cache/recovery/log\");\n\t\tcopy_file(\"/cache/recovery/log\", \"/cache/recovery/last_log\", 600);\n\t\tchown(\"/cache/recovery/log\", 1000, 1000);\n\t\tchmod(\"/cache/recovery/log\", 0600);\n\t\tchmod(\"/cache/recovery/last_log\", 0640);\n\t} else if (PartitionManager.Mount_By_Path(\"/data\", false) && TWFunc::Path_Exists(\"/data/cache/recovery/.\")) {\n\t\tCopy_Log(TMP_LOG_FILE, \"/data/cache/recovery/log\");\n\t\tcopy_file(\"/data/cache/recovery/log\", \"/data/cache/recovery/last_log\", 600);\n\t\tchown(\"/data/cache/recovery/log\", 1000, 1000);\n\t\tchmod(\"/data/cache/recovery/log\", 0600);\n\t\tchmod(\"/data/cache/recovery/last_log\", 0640);\n\t} else {\n\t\tLOGINFO(\"Failed to mount /cache or find /data/cache for TWFunc::Update_Log_File\\n\");\n\t}\n\n\t// Reset bootloader message\n\tTWPartition* Part = PartitionManager.Find_Partition_By_Path(\"/misc\");\n\tif (Part != NULL) {\n\t\tstd::string err;\n\t\tif (!clear_bootloader_message((void*)&err)) {\n\t\t\tif (err == \"no misc device set\") {\n\t\t\t\tLOGINFO(\"%s\\n\", err.c_str());\n\t\t\t} else {\n\t\t\t\tLOGERR(\"%s\\n\", err.c_str());\n\t\t\t}\n\t\t}\n\t}\n\n\tif (PartitionManager.Mount_By_Path(\"/cache\", false)) {\n\t\tif (unlink(\"/cache/recovery/command\") && errno != ENOENT) {\n\t\t\tLOGINFO(\"Can't unlink %s\\n\", \"/cache/recovery/command\");\n\t\t}\n\t}\n\n\tsync();\n}\n\nvoid TWFunc::Update_Intent_File(string Intent) {\n\tif (PartitionManager.Mount_By_Path(\"/cache\", false) && !Intent.empty()) {\n\t\tTWFunc::write_to_file(\"/cache/recovery/intent\", Intent);\n\t}\n}\n\n// reboot: Reboot the system. Return -1 on error, no return on success\nint TWFunc::tw_reboot(RebootCommand command)\n{\n\tDataManager::Flush();\n\tUpdate_Log_File();\n\t// Always force a sync before we reboot\n\tsync();\n\n\tswitch (command) {\n\t\tcase rb_current:\n\t\tcase rb_system:\n\t\t\tUpdate_Intent_File(\"s\");\n\t\t\tsync();\n\t\t\tcheck_and_run_script(\"/sbin/rebootsystem.sh\", \"reboot system\");\n#ifdef ANDROID_RB_PROPERTY\n\t\t\treturn property_set(ANDROID_RB_PROPERTY, \"reboot,\");\n#elif defined(ANDROID_RB_RESTART)\n\t\t\treturn android_reboot(ANDROID_RB_RESTART, 0, 0);\n#else\n\t\t\treturn reboot(RB_AUTOBOOT);\n#endif\n\t\tcase rb_recovery:\n\t\t\tcheck_and_run_script(\"/sbin/rebootrecovery.sh\", \"reboot recovery\");\n#ifdef ANDROID_RB_PROPERTY\n\t\t\treturn property_set(ANDROID_RB_PROPERTY, \"reboot,recovery\");\n#else\n\t\t\treturn __reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, LINUX_REBOOT_CMD_RESTART2, (void*) \"recovery\");\n#endif\n\t\tcase rb_bootloader:\n\t\t\tcheck_and_run_script(\"/sbin/rebootbootloader.sh\", \"reboot bootloader\");\n#ifdef ANDROID_RB_PROPERTY\n\t\t\treturn property_set(ANDROID_RB_PROPERTY, \"reboot,bootloader\");\n#else\n\t\t\treturn __reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, LINUX_REBOOT_CMD_RESTART2, (void*) \"bootloader\");\n#endif\n\t\tcase rb_poweroff:\n\t\t\tcheck_and_run_script(\"/sbin/poweroff.sh\", \"power off\");\n#ifdef ANDROID_RB_PROPERTY\n\t\t\treturn property_set(ANDROID_RB_PROPERTY, \"shutdown,\");\n#elif defined(ANDROID_RB_POWEROFF)\n\t\t\treturn android_reboot(ANDROID_RB_POWEROFF, 0, 0);\n#else\n\t\t\treturn reboot(RB_POWER_OFF);\n#endif\n\t\tcase rb_download:\n\t\t\tcheck_and_run_script(\"/sbin/rebootdownload.sh\", \"reboot download\");\n#ifdef ANDROID_RB_PROPERTY\n\t\t\treturn property_set(ANDROID_RB_PROPERTY, \"reboot,download\");\n#else\n\t\t\treturn __reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, LINUX_REBOOT_CMD_RESTART2, (void*) \"download\");\n#endif\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\treturn -1;\n}\n\nvoid TWFunc::check_and_run_script(const char* script_file, const char* display_name)\n{\n\t// Check for and run startup script if script exists\n\tstruct stat st;\n\tif (stat(script_file, &st) == 0) {\n\t\tgui_msg(Msg(\"run_script=Running {1} script...\")(display_name));\n\t\tchmod(script_file, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tTWFunc::Exec_Cmd(script_file);\n\t\tgui_msg(\"done=Done.\");\n\t}\n}\n\nint TWFunc::removeDir(const string path, bool skipParent) {\n\tDIR *d = opendir(path.c_str());\n\tint r = 0;\n\tstring new_path;\n\n\tif (d == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(path)(strerror(errno)));\n\t\treturn -1;\n\t}\n\n\tif (d) {\n\t\tstruct dirent *p;\n\t\twhile (!r && (p = readdir(d))) {\n\t\t\tif (!strcmp(p->d_name, \".\") || !strcmp(p->d_name, \"..\"))\n\t\t\t\tcontinue;\n\t\t\tnew_path = path + \"/\";\n\t\t\tnew_path.append(p->d_name);\n\t\t\tif (p->d_type == DT_DIR) {\n\t\t\t\tr = removeDir(new_path, true);\n\t\t\t\tif (!r) {\n\t\t\t\t\tif (p->d_type == DT_DIR)\n\t\t\t\t\t\tr = rmdir(new_path.c_str());\n\t\t\t\t\telse\n\t\t\t\t\t\tLOGINFO(\"Unable to removeDir '%s': %s\\n\", new_path.c_str(), strerror(errno));\n\t\t\t\t}\n\t\t\t} else if (p->d_type == DT_REG || p->d_type == DT_LNK || p->d_type == DT_FIFO || p->d_type == DT_SOCK) {\n\t\t\t\tr = unlink(new_path.c_str());\n\t\t\t\tif (r != 0) {\n\t\t\t\t\tLOGINFO(\"Unable to unlink '%s: %s'\\n\", new_path.c_str(), strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir(d);\n\n\t\tif (!r) {\n\t\t\tif (skipParent)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tr = rmdir(path.c_str());\n\t\t}\n\t}\n\treturn r;\n}\n\nint TWFunc::copy_file(string src, string dst, int mode) {\n\tLOGINFO(\"Copying file %s to %s\\n\", src.c_str(), dst.c_str());\n\tifstream srcfile(src.c_str(), ios::binary);\n\tofstream dstfile(dst.c_str(), ios::binary);\n\tdstfile << srcfile.rdbuf();\n\tsrcfile.close();\n\tdstfile.close();\n\tif (chmod(dst.c_str(), mode) != 0)\n\t\treturn -1;\n\treturn 0;\n}\n\nunsigned int TWFunc::Get_D_Type_From_Stat(string Path) {\n\tstruct stat st;\n\n\tstat(Path.c_str(), &st);\n\tif (st.st_mode & S_IFDIR)\n\t\treturn DT_DIR;\n\telse if (st.st_mode & S_IFBLK)\n\t\treturn DT_BLK;\n\telse if (st.st_mode & S_IFCHR)\n\t\treturn DT_CHR;\n\telse if (st.st_mode & S_IFIFO)\n\t\treturn DT_FIFO;\n\telse if (st.st_mode & S_IFLNK)\n\t\treturn DT_LNK;\n\telse if (st.st_mode & S_IFREG)\n\t\treturn DT_REG;\n\telse if (st.st_mode & S_IFSOCK)\n\t\treturn DT_SOCK;\n\treturn DT_UNKNOWN;\n}\n\nint TWFunc::read_file(string fn, string& results) {\n\tifstream file;\n\tfile.open(fn.c_str(), ios::in);\n\n\tif (file.is_open()) {\n\t\tfile >> results;\n\t\tfile.close();\n\t\treturn 0;\n\t}\n\n\tLOGINFO(\"Cannot find file %s\\n\", fn.c_str());\n\treturn -1;\n}\n\nint TWFunc::read_file(string fn, vector<string>& results) {\n\tifstream file;\n\tstring line;\n\tfile.open(fn.c_str(), ios::in);\n\tif (file.is_open()) {\n\t\twhile (getline(file, line))\n\t\t\tresults.push_back(line);\n\t\tfile.close();\n\t\treturn 0;\n\t}\n\tLOGINFO(\"Cannot find file %s\\n\", fn.c_str());\n\treturn -1;\n}\n\nint TWFunc::read_file(string fn, uint64_t& results) {\n\tifstream file;\n\tfile.open(fn.c_str(), ios::in);\n\n\tif (file.is_open()) {\n\t\tfile >> results;\n\t\tfile.close();\n\t\treturn 0;\n\t}\n\n\tLOGINFO(\"Cannot find file %s\\n\", fn.c_str());\n\treturn -1;\n}\n\nint TWFunc::write_to_file(const string& fn, const string& line) {\n\tFILE *file;\n\tfile = fopen(fn.c_str(), \"w\");\n\tif (file != NULL) {\n\t\tfwrite(line.c_str(), line.size(), 1, file);\n\t\tfclose(file);\n\t\treturn 0;\n\t}\n\tLOGINFO(\"Cannot find file %s\\n\", fn.c_str());\n\treturn -1;\n}\n\nbool TWFunc::Try_Decrypting_Backup(string Restore_Path, string Password) {\n\tDIR* d;\n\n\tstring Filename;\n\tRestore_Path += \"/\";\n\td = opendir(Restore_Path.c_str());\n\tif (d == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Restore_Path)(strerror(errno)));\n\t\treturn false;\n\t}\n\n\tstruct dirent* de;\n\twhile ((de = readdir(d)) != NULL) {\n\t\tFilename = Restore_Path;\n\t\tFilename += de->d_name;\n\t\tif (TWFunc::Get_File_Type(Filename) == ENCRYPTED) {\n\t\t\tif (TWFunc::Try_Decrypting_File(Filename, Password) < 2) {\n\t\t\t\tDataManager::SetValue(\"tw_restore_password\", \"\"); // Clear the bad password\n\t\t\t\tDataManager::SetValue(\"tw_restore_display\", \"\");  // Also clear the display mask\n\t\t\t\tclosedir(d);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(d);\n\treturn true;\n}\n\nstring TWFunc::Get_Current_Date() {\n\tstring Current_Date;\n\ttime_t seconds = time(0);\n\tstruct tm *t = localtime(&seconds);\n\tchar timestamp[255];\n\tsprintf(timestamp,\"%04d-%02d-%02d--%02d-%02d-%02d\",t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);\n\tCurrent_Date = timestamp;\n\treturn Current_Date;\n}\n\nstring TWFunc::System_Property_Get(string Prop_Name) {\n\tbool mount_state = PartitionManager.Is_Mounted_By_Path(\"/system\");\n\tstd::vector<string> buildprop;\n\tstring propvalue;\n\tif (!PartitionManager.Mount_By_Path(\"/system\", true))\n\t\treturn propvalue;\n\tstring prop_file = \"/system/build.prop\";\n\tif (!TWFunc::Path_Exists(prop_file))\n\t\tprop_file = \"/system/system/build.prop\"; // for devices with system as a root file system (e.g. Pixel)\n\tif (TWFunc::read_file(prop_file, buildprop) != 0) {\n\t\tLOGINFO(\"Unable to open /system/build.prop for getting '%s'.\\n\", Prop_Name.c_str());\n\t\tDataManager::SetValue(TW_BACKUP_NAME, Get_Current_Date());\n\t\tif (!mount_state)\n\t\t\tPartitionManager.UnMount_By_Path(\"/system\", false);\n\t\treturn propvalue;\n\t}\n\tint line_count = buildprop.size();\n\tint index;\n\tsize_t start_pos = 0, end_pos;\n\tstring propname;\n\tfor (index = 0; index < line_count; index++) {\n\t\tend_pos = buildprop.at(index).find(\"=\", start_pos);\n\t\tpropname = buildprop.at(index).substr(start_pos, end_pos);\n\t\tif (propname == Prop_Name) {\n\t\t\tpropvalue = buildprop.at(index).substr(end_pos + 1, buildprop.at(index).size());\n\t\t\tif (!mount_state)\n\t\t\t\tPartitionManager.UnMount_By_Path(\"/system\", false);\n\t\t\treturn propvalue;\n\t\t}\n\t}\n\tif (!mount_state)\n\t\tPartitionManager.UnMount_By_Path(\"/system\", false);\n\treturn propvalue;\n}\n\nvoid TWFunc::Auto_Generate_Backup_Name() {\n\tstring propvalue = System_Property_Get(\"ro.build.display.id\");\n\tif (propvalue.empty()) {\n\t\tDataManager::SetValue(TW_BACKUP_NAME, Get_Current_Date());\n\t\treturn;\n\t}\n\telse {\n\t\t//remove periods from build display so it doesn't confuse the extension code\n\t\tpropvalue.erase(remove(propvalue.begin(), propvalue.end(), '.'), propvalue.end());\n\t}\n\tstring Backup_Name = Get_Current_Date();\n\tBackup_Name += \"_\" + propvalue;\n\tif (Backup_Name.size() > MAX_BACKUP_NAME_LEN)\n\t\tBackup_Name.resize(MAX_BACKUP_NAME_LEN);\n\t// Trailing spaces cause problems on some file systems, so remove them\n\tstring space_check, space = \" \";\n\tspace_check = Backup_Name.substr(Backup_Name.size() - 1, 1);\n\twhile (space_check == space) {\n\t\tBackup_Name.resize(Backup_Name.size() - 1);\n\t\tspace_check = Backup_Name.substr(Backup_Name.size() - 1, 1);\n\t}\n\treplace(Backup_Name.begin(), Backup_Name.end(), ' ', '_');\n\tDataManager::SetValue(TW_BACKUP_NAME, Backup_Name);\n\tif (PartitionManager.Check_Backup_Name(false) != 0) {\n\t\tLOGINFO(\"Auto generated backup name '%s' contains invalid characters, using date instead.\\n\", Backup_Name.c_str());\n\t\tDataManager::SetValue(TW_BACKUP_NAME, Get_Current_Date());\n\t}\n}\n\nvoid TWFunc::Fixup_Time_On_Boot(const string& time_paths /* = \"\" */)\n{\n#ifdef QCOM_RTC_FIX\n\tstatic bool fixed = false;\n\tif (fixed)\n\t\treturn;\n\n\tLOGINFO(\"TWFunc::Fixup_Time: Pre-fix date and time: %s\\n\", TWFunc::Get_Current_Date().c_str());\n\n\tstruct timeval tv;\n\tuint64_t offset = 0;\n\tstd::string sepoch = \"/sys/class/rtc/rtc0/since_epoch\";\n\n\tif (TWFunc::read_file(sepoch, offset) == 0) {\n\n\t\tLOGINFO(\"TWFunc::Fixup_Time: Setting time offset from file %s\\n\", sepoch.c_str());\n\n\t\ttv.tv_sec = offset;\n\t\ttv.tv_usec = 0;\n\t\tsettimeofday(&tv, NULL);\n\n\t\tgettimeofday(&tv, NULL);\n\n\t\tif (tv.tv_sec > 1517600000) { // Anything older then 2 Feb 2018 19:33:20 GMT will do nicely thank you ;)\n\n\t\t\tLOGINFO(\"TWFunc::Fixup_Time: Date and time corrected: %s\\n\", TWFunc::Get_Current_Date().c_str());\n\t\t\tfixed = true;\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\tLOGINFO(\"TWFunc::Fixup_Time: opening %s failed\\n\", sepoch.c_str());\n\n\t}\n\n\tLOGINFO(\"TWFunc::Fixup_Time: will attempt to use the ats files now.\\n\");\n\n\t// Devices with Qualcomm Snapdragon 800 do some shenanigans with RTC.\n\t// They never set it, it just ticks forward from 1970-01-01 00:00,\n\t// and then they have files /data/system/time/ats_* with 64bit offset\n\t// in miliseconds which, when added to the RTC, gives the correct time.\n\t// So, the time is: (offset_from_ats + value_from_RTC)\n\t// There are multiple ats files, they are for different systems? Bases?\n\t// Like, ats_1 is for modem and ats_2 is for TOD (time of day?).\n\t// Look at file time_genoff.h in CodeAurora, qcom-opensource/time-services\n\n\tstd::vector<std::string> paths; // space separated list of paths\n\tif (time_paths.empty()) {\n\t\tpaths = Split_String(\"/data/system/time/ /data/time/\", \" \");\n\t\tif (!PartitionManager.Mount_By_Path(\"/data\", false))\n\t\t\treturn;\n\t} else {\n\t\t// When specific path(s) are used, Fixup_Time needs those\n\t\t// partitions to already be mounted!\n\t\tpaths = Split_String(time_paths, \" \");\n\t}\n\n\tFILE *f;\n\toffset = 0;\n\tstruct dirent *dt;\n\tstd::string ats_path;\n\n\t// Prefer ats_2, it seems to be the one we want according to logcat on hammerhead\n\t// - it is the one for ATS_TOD (time of day?).\n\t// However, I never saw a device where the offset differs between ats files.\n\tfor (size_t i = 0; i < paths.size(); ++i)\n\t{\n\t\tDIR *d = opendir(paths[i].c_str());\n\t\tif (!d)\n\t\t\tcontinue;\n\n\t\twhile ((dt = readdir(d)))\n\t\t{\n\t\t\tif (dt->d_type != DT_REG || strncmp(dt->d_name, \"ats_\", 4) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (ats_path.empty() || strcmp(dt->d_name, \"ats_2\") == 0)\n\t\t\t\tats_path = paths[i] + dt->d_name;\n\t\t}\n\n\t\tclosedir(d);\n\t}\n\n\tif (ats_path.empty()) {\n\t\tLOGINFO(\"TWFunc::Fixup_Time: no ats files found, leaving untouched!\\n\");\n\t} else if ((f = fopen(ats_path.c_str(), \"r\")) == NULL) {\n\t\tLOGINFO(\"TWFunc::Fixup_Time: failed to open file %s\\n\", ats_path.c_str());\n\t} else if (fread(&offset, sizeof(offset), 1, f) != 1) {\n\t\tLOGINFO(\"TWFunc::Fixup_Time: failed load uint64 from file %s\\n\", ats_path.c_str());\n\t\tfclose(f);\n\t} else {\n\t\tfclose(f);\n\n\t\tLOGINFO(\"TWFunc::Fixup_Time: Setting time offset from file %s, offset %llu\\n\", ats_path.c_str(), (unsigned long long) offset);\n\t\tDataManager::SetValue(\"tw_qcom_ats_offset\", (unsigned long long) offset, 1);\n\t\tfixed = true;\n\t}\n\n\tif (!fixed) {\n\t\t// Failed to get offset from ats file, check twrp settings\n\t\tunsigned long long value;\n\t\tif (DataManager::GetValue(\"tw_qcom_ats_offset\", value) < 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\toffset = (uint64_t) value;\n\t\t\tLOGINFO(\"TWFunc::Fixup_Time: Setting time offset from twrp setting file, offset %llu\\n\", (unsigned long long) offset);\n\t\t\t// Do not consider the settings file as a definitive answer, keep fixed=false so next run will try ats files again\n\t\t}\n\t}\n\n\tgettimeofday(&tv, NULL);\n\n\ttv.tv_sec += offset/1000;\n#ifdef TW_CLOCK_OFFSET\n// Some devices are even quirkier and have ats files that are offset from the actual time\n\ttv.tv_sec = tv.tv_sec + TW_CLOCK_OFFSET;\n#endif\n\ttv.tv_usec += (offset%1000)*1000;\n\n\twhile (tv.tv_usec >= 1000000)\n\t{\n\t\t++tv.tv_sec;\n\t\ttv.tv_usec -= 1000000;\n\t}\n\n\tsettimeofday(&tv, NULL);\n\n\tLOGINFO(\"TWFunc::Fixup_Time: Date and time corrected: %s\\n\", TWFunc::Get_Current_Date().c_str());\n#endif\n}\n\nstd::vector<std::string> TWFunc::Split_String(const std::string& str, const std::string& delimiter, bool removeEmpty)\n{\n\tstd::vector<std::string> res;\n\tsize_t idx = 0, idx_last = 0;\n\n\twhile (idx < str.size())\n\t{\n\t\tidx = str.find_first_of(delimiter, idx_last);\n\t\tif (idx == std::string::npos)\n\t\t\tidx = str.size();\n\n\t\tif (idx-idx_last != 0 || !removeEmpty)\n\t\t\tres.push_back(str.substr(idx_last, idx-idx_last));\n\n\t\tidx_last = idx + delimiter.size();\n\t}\n\n\treturn res;\n}\n\nbool TWFunc::Create_Dir_Recursive(const std::string& path, mode_t mode, uid_t uid, gid_t gid)\n{\n\tstd::vector<std::string> parts = Split_String(path, \"/\");\n\tstd::string cur_path;\n\tstruct stat info;\n\tfor (size_t i = 0; i < parts.size(); ++i)\n\t{\n\t\tcur_path += \"/\" + parts[i];\n\t\tif (stat(cur_path.c_str(), &info) < 0 || !S_ISDIR(info.st_mode))\n\t\t{\n\t\t\tif (mkdir(cur_path.c_str(), mode) < 0)\n\t\t\t\treturn false;\n\t\t\tchown(cur_path.c_str(), uid, gid);\n\t\t}\n\t}\n\treturn true;\n}\n\nint TWFunc::Set_Brightness(std::string brightness_value)\n{\n\tint result = -1;\n\tstd::string secondary_brightness_file;\n\n\tif (DataManager::GetIntValue(\"tw_has_brightnesss_file\")) {\n\t\tLOGINFO(\"TWFunc::Set_Brightness: Setting brightness control to %s\\n\", brightness_value.c_str());\n\t\tresult = TWFunc::write_to_file(DataManager::GetStrValue(\"tw_brightness_file\"), brightness_value);\n\t\tDataManager::GetValue(\"tw_secondary_brightness_file\", secondary_brightness_file);\n\t\tif (!secondary_brightness_file.empty()) {\n\t\t\tLOGINFO(\"TWFunc::Set_Brightness: Setting secondary brightness control to %s\\n\", brightness_value.c_str());\n\t\t\tTWFunc::write_to_file(secondary_brightness_file, brightness_value);\n\t\t}\n\t}\n\treturn result;\n}\n\nbool TWFunc::Toggle_MTP(bool enable) {\n#ifdef TW_HAS_MTP\n\tstatic int was_enabled = false;\n\n\tif (enable && was_enabled) {\n\t\tif (!PartitionManager.Enable_MTP())\n\t\t\tPartitionManager.Disable_MTP();\n\t} else {\n\t\twas_enabled = DataManager::GetIntValue(\"tw_mtp_enabled\");\n\t\tPartitionManager.Disable_MTP();\n\t\tusleep(500);\n\t}\n\treturn was_enabled;\n#else\n\treturn false;\n#endif\n}\n\nvoid TWFunc::SetPerformanceMode(bool mode) {\n\tif (mode) {\n\t\tproperty_set(\"recovery.perf.mode\", \"1\");\n\t} else {\n\t\tproperty_set(\"recovery.perf.mode\", \"0\");\n\t}\n\t// Some time for events to catch up to init handlers\n\tusleep(500000);\n}\n\nstd::string TWFunc::to_string(unsigned long value) {\n\tstd::ostringstream os;\n\tos << value;\n\treturn os.str();\n}\n\nvoid TWFunc::Disable_Stock_Recovery_Replace(void) {\n\tif (PartitionManager.Mount_By_Path(\"/system\", false)) {\n\t\t// Disable flashing of stock recovery\n\t\tif (TWFunc::Path_Exists(\"/system/recovery-from-boot.p\")) {\n\t\t\trename(\"/system/recovery-from-boot.p\", \"/system/recovery-from-boot.bak\");\n\t\t\tgui_msg(\"rename_stock=Renamed stock recovery file in /system to prevent the stock ROM from replacing TWRP.\");\n\t\t\tsync();\n\t\t}\n\t\tPartitionManager.UnMount_By_Path(\"/system\", false);\n\t}\n}\n\nunsigned long long TWFunc::IOCTL_Get_Block_Size(const char* block_device) {\n\tunsigned long block_device_size;\n\tint ret = 0;\n\n\tint fd = open(block_device, O_RDONLY);\n\tif (fd < 0) {\n\t\tLOGINFO(\"Find_Partition_Size: Failed to open '%s', (%s)\\n\", block_device, strerror(errno));\n\t} else {\n\t\tret = ioctl(fd, BLKGETSIZE, &block_device_size);\n\t\tclose(fd);\n\t\tif (ret) {\n\t\t\tLOGINFO(\"Find_Partition_Size: ioctl error: (%s)\\n\", strerror(errno));\n\t\t} else {\n\t\t\treturn (unsigned long long)(block_device_size) * 512LLU;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid TWFunc::copy_kernel_log(string curr_storage) {\n\tstd::string dmesgDst = curr_storage + \"/dmesg.log\";\n\tstd::string dmesgCmd = \"/sbin/dmesg\";\n\n\tstd::string result;\n\tExec_Cmd(dmesgCmd, result);\n\twrite_to_file(dmesgDst, result);\n\tgui_msg(Msg(\"copy_kernel_log=Copied kernel log to {1}\")(dmesgDst));\n\ttw_set_default_metadata(dmesgDst.c_str());\n}\n\nbool TWFunc::isNumber(string strtocheck) {\n\tint num = 0;\n\tstd::istringstream iss(strtocheck);\n\n\tif (!(iss >> num).fail())\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint TWFunc::stream_adb_backup(string &Restore_Name) {\n\tstring cmd = \"/sbin/bu --twrp stream \" + Restore_Name;\n\tLOGINFO(\"stream_adb_backup: %s\\n\", cmd.c_str());\n\tint ret = TWFunc::Exec_Cmd(cmd);\n\tif (ret != 0)\n\t\treturn -1;\n\treturn ret;\n}\n#endif // ndef BUILD_TWRPTAR_MAIN\n"
        },
        {
          "name": "twrp-functions.hpp",
          "type": "blob",
          "size": 7.2587890625,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _TWRPFUNCTIONS_HPP\n#define _TWRPFUNCTIONS_HPP\n\n#include <string>\n#include <vector>\n\n#include \"twrpDigest/twrpDigest.hpp\"\n\nusing namespace std;\n\ntypedef enum\n{\n\trb_current = 0,\n\trb_system,\n\trb_recovery,\n\trb_poweroff,\n\trb_bootloader,     // May also be fastboot\n\trb_download,\n} RebootCommand;\n\nenum Archive_Type {\n\tUNCOMPRESSED = 0,\n\tCOMPRESSED,\n\tENCRYPTED,\n\tCOMPRESSED_ENCRYPTED\n};\n\n// Partition class\nclass TWFunc\n{\npublic:\n\tstatic string Get_Root_Path(const string& Path);                            // Trims any trailing folders or filenames from the path, also adds a leading / if not present\n\tstatic string Get_Path(const string& Path);                                 // Trims everything after the last / in the string\n\tstatic string Get_Filename(const string& Path);                             // Trims the path off of a filename\n\n\tstatic int Exec_Cmd(const string& cmd, string &result);                     //execute a command and return the result as a string by reference\n\tstatic int Exec_Cmd(const string& cmd);                                     //execute a command\n\tstatic int Wait_For_Child(pid_t pid, int *status, string Child_Name);       // Waits for pid to exit and checks exit status\n\tstatic int Wait_For_Child_Timeout(pid_t pid, int *status, const string& Child_Name, int timeout); // Waits for a pid to exit until the timeout is hit. If timeout is hit, kill the chilld.\n\tstatic bool Path_Exists(string Path);                                       // Returns true if the path exists\n\tstatic Archive_Type Get_File_Type(string fn);                               // Determines file type, 0 for unknown, 1 for gzip, 2 for OAES encrypted\n\tstatic int Try_Decrypting_File(string fn, string password); // -1 for some error, 0 for failed to decrypt, 1 for decrypted, 3 for decrypted and found gzip format\n\tstatic unsigned long Get_File_Size(const string& Path);                            // Returns the size of a file\n\tstatic std::string Remove_Trailing_Slashes(const std::string& path, bool leaveLast = false); // Normalizes the path, e.g /data//media/ -> /data/media\n\tstatic void Strip_Quotes(char* &str);                                       // Remove leading & trailing double-quotes from a string\n\tstatic vector<string> split_string(const string &in, char del, bool skip_empty);\n\tstatic timespec timespec_diff(timespec& start, timespec& end);\t            // Return a diff for 2 times\n\tstatic int32_t timespec_diff_ms(timespec& start, timespec& end);            // Returns diff in ms\n\n#ifndef BUILD_TWRPTAR_MAIN\n\tstatic void install_htc_dumlock(void);                                      // Installs HTC Dumlock\n\tstatic void htc_dumlock_restore_original_boot(void);                        // Restores the backup of boot from HTC Dumlock\n\tstatic void htc_dumlock_reflash_recovery_to_boot(void);                     // Reflashes the current recovery to boot\n\tstatic int Recursive_Mkdir(string Path);                                    // Recursively makes the entire path\n\tstatic void GUI_Operation_Text(string Read_Value, string Default_Text);     // Updates text for display in the GUI, e.g. Backing up %partition name%\n\tstatic void GUI_Operation_Text(string Read_Value, string Partition_Name, string Default_Text); // Same as above but includes partition name\n\tstatic void Update_Log_File(void);                                          // Writes the log to last_log\n\tstatic void Update_Intent_File(string Intent);                              // Updates intent file\n\tstatic int tw_reboot(RebootCommand command);                                // Prepares the device for rebooting\n\tstatic void check_and_run_script(const char* script_file, const char* display_name); // checks for the existence of a script, chmods it to 755, then runs it\n\tstatic int removeDir(const string path, bool removeParent); //recursively remove a directory\n\tstatic int copy_file(string src, string dst, int mode); //copy file from src to dst with mode permissions\n\tstatic unsigned int Get_D_Type_From_Stat(string Path);                      // Returns a dirent dt_type value using stat instead of dirent\n\tstatic int read_file(string fn, vector<string>& results); //read from file\n\tstatic int read_file(string fn, string& results); //read from file\n\tstatic int read_file(string fn, uint64_t& results); //read from file\n\tstatic int write_to_file(const string& fn, const string& line);             //write to file\n\tstatic bool Try_Decrypting_Backup(string Restore_Path, string Password); // true for success, false for failed to decrypt\n\tstatic string System_Property_Get(string Prop_Name);                // Returns value of Prop_Name from reading /system/build.prop\n\tstatic string Get_Current_Date(void);                               // Returns the current date in ccyy-m-dd--hh-nn-ss format\n\tstatic void Auto_Generate_Backup_Name();                            // Populates TW_BACKUP_NAME with a backup name based on current date and ro.build.display.id from /system/build.prop\n\tstatic void Fixup_Time_On_Boot(const string& time_paths = \"\"); // Fixes time on devices which need it (time_paths is a space separated list of paths to check for ats_* files)\n\tstatic std::vector<std::string> Split_String(const std::string& str, const std::string& delimiter, bool removeEmpty = true); // Splits string by delimiter\n\tstatic bool Create_Dir_Recursive(const std::string& path, mode_t mode = 0755, uid_t uid = -1, gid_t gid = -1);  // Create directory and it's parents, if they don't exist. mode, uid and gid are set to all _newly_ created folders. If whole path exists, do nothing.\n\tstatic int Set_Brightness(std::string brightness_value); // Well, you can read, it does what it says, passing return int from TWFunc::Write_File ;)\n\tstatic bool Toggle_MTP(bool enable);                                        // Disables MTP if enable is false and re-enables MTP if enable is true and it was enabled the last time it was toggled off\n\tstatic std::string to_string(unsigned long value); //convert ul to string\n\tstatic void SetPerformanceMode(bool mode); // support recovery.perf.mode\n\tstatic void Disable_Stock_Recovery_Replace(); // Disable stock ROMs from replacing TWRP with stock recovery\n\tstatic unsigned long long IOCTL_Get_Block_Size(const char* block_device);\n\tstatic void copy_kernel_log(string curr_storage); // Copy Kernel Log to Current Storage (PSTORE/KMSG)\n\tstatic bool isNumber(string strtocheck); // return true if number, false if not a number\n\tstatic int stream_adb_backup(string &Restore_Name); // Tell ADB Backup to Stream to TWRP from GUI selection\n\nprivate:\n\tstatic void Copy_Log(string Source, string Destination);\n\n};\n\nextern int Log_Offset;\n#else\n};\n#endif // ndef BUILD_TWRPTAR_MAIN\n\n#endif // _TWRPFUNCTIONS_HPP\n"
        },
        {
          "name": "twrp.cpp",
          "type": "blob",
          "size": 12.19140625,
          "content": "/*\n\t\tTWRP is free software: you can redistribute it and/or modify\n\t\tit under the terms of the GNU General Public License as published by\n\t\tthe Free Software Foundation, either version 3 of the License, or\n\t\t(at your option) any later version.\n\n\t\tTWRP is distributed in the hope that it will be useful,\n\t\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\t\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\t\tGNU General Public License for more details.\n\n\t\tYou should have received a copy of the GNU General Public License\n\t\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n#include <signal.h>\n#include \"gui/twmsg.h\"\n\n#include \"cutils/properties.h\"\n#include \"bootloader_message_twrp/include/bootloader_message_twrp/bootloader_message.h\"\n\n#ifdef ANDROID_RB_RESTART\n#include \"cutils/android_reboot.h\"\n#else\n#include <sys/reboot.h>\n#endif\n\nextern \"C\" {\n#include \"gui/gui.h\"\n}\n#include \"set_metadata.h\"\n#include \"gui/gui.hpp\"\n#include \"gui/pages.hpp\"\n#include \"gui/objects.hpp\"\n#include \"twcommon.h\"\n#include \"twrp-functions.hpp\"\n#include \"data.hpp\"\n#include \"partitions.hpp\"\n#include \"openrecoveryscript.hpp\"\n#include \"variables.h\"\n#include \"twrpAdbBuFifo.hpp\"\n#ifdef TW_USE_NEW_MINADBD\n#include \"minadbd/minadbd.h\"\n#else\nextern \"C\" {\n#include \"minadbd21/adb.h\"\n}\n#endif\n\n#include <selinux/label.h>\nstruct selabel_handle *selinux_handle;\n\n//extern int adb_server_main(int is_daemon, int server_port, int /* reply_fd */);\n\nTWPartitionManager PartitionManager;\nint Log_Offset;\nbool datamedia;\n\nstatic void Print_Prop(const char *key, const char *name, void *cookie) {\n\tprintf(\"%s=%s\\n\", key, name);\n}\n\nint main(int argc, char **argv) {\n\t// Recovery needs to install world-readable files, so clear umask\n\t// set by init\n\tumask(0);\n\n\tLog_Offset = 0;\n\n\t// Set up temporary log file (/tmp/recovery.log)\n\tfreopen(TMP_LOG_FILE, \"a\", stdout);\n\tsetbuf(stdout, NULL);\n\tfreopen(TMP_LOG_FILE, \"a\", stderr);\n\tsetbuf(stderr, NULL);\n\n\tsignal(SIGPIPE, SIG_IGN);\n\n\t// Handle ADB sideload\n\tif (argc == 3 && strcmp(argv[1], \"--adbd\") == 0) {\n\t\tproperty_set(\"ctl.stop\", \"adbd\");\n#ifdef TW_USE_NEW_MINADBD\n\t\t//adb_server_main(0, DEFAULT_ADB_PORT, -1); TODO fix this for android8\n\t\tminadbd_main();\n#else\n\t\tadb_main(argv[2]);\n#endif\n\t\treturn 0;\n\t}\n\n#ifdef RECOVERY_SDCARD_ON_DATA\n\tdatamedia = true;\n#endif\n\n\tchar crash_prop_val[PROPERTY_VALUE_MAX];\n\tint crash_counter;\n\tproperty_get(\"twrp.crash_counter\", crash_prop_val, \"-1\");\n\tcrash_counter = atoi(crash_prop_val) + 1;\n\tsnprintf(crash_prop_val, sizeof(crash_prop_val), \"%d\", crash_counter);\n\tproperty_set(\"twrp.crash_counter\", crash_prop_val);\n\tproperty_set(\"ro.twrp.boot\", \"1\");\n\tproperty_set(\"ro.twrp.version\", TW_VERSION_STR);\n\n\ttime_t StartupTime = time(NULL);\n\tprintf(\"Starting TWRP %s-%s on %s (pid %d)\\n\", TW_VERSION_STR, TW_GIT_REVISION, ctime(&StartupTime), getpid());\n\n\t// Load default values to set DataManager constants and handle ifdefs\n\tDataManager::SetDefaultValues();\n\tprintf(\"Starting the UI...\\n\");\n\tgui_init();\n\tprintf(\"=> Linking mtab\\n\");\n\tsymlink(\"/proc/mounts\", \"/etc/mtab\");\n\tstd::string fstab_filename = \"/etc/twrp.fstab\";\n\tif (!TWFunc::Path_Exists(fstab_filename)) {\n\t\tfstab_filename = \"/etc/recovery.fstab\";\n\t}\n\tprintf(\"=> Processing %s\\n\", fstab_filename.c_str());\n\tif (!PartitionManager.Process_Fstab(fstab_filename, 1)) {\n\t\tLOGERR(\"Failing out of recovery due to problem with fstab.\\n\");\n\t\treturn -1;\n\t}\n\tPartitionManager.Output_Partition_Logging();\n\t// Load up all the resources\n\tgui_loadResources();\n\n\tif (TWFunc::Path_Exists(\"/prebuilt_file_contexts\")) {\n\t\tif (TWFunc::Path_Exists(\"/file_contexts\")) {\n\t\t\tprintf(\"Renaming regular /file_contexts -> /file_contexts.bak\\n\");\n\t\t\trename(\"/file_contexts\", \"/file_contexts.bak\");\n\t\t}\n\t\tprintf(\"Moving /prebuilt_file_contexts -> /file_contexts\\n\");\n\t\trename(\"/prebuilt_file_contexts\", \"/file_contexts\");\n\t}\n\tstruct selinux_opt selinux_options[] = {\n\t\t{ SELABEL_OPT_PATH, \"/file_contexts\" }\n\t};\n\tselinux_handle = selabel_open(SELABEL_CTX_FILE, selinux_options, 1);\n\tif (!selinux_handle)\n\t\tprintf(\"No file contexts for SELinux\\n\");\n\telse\n\t\tprintf(\"SELinux contexts loaded from /file_contexts\\n\");\n\t{ // Check to ensure SELinux can be supported by the kernel\n\t\tchar *contexts = NULL;\n\n\t\tif (PartitionManager.Mount_By_Path(\"/cache\", false) && TWFunc::Path_Exists(\"/cache/recovery\")) {\n\t\t\tlgetfilecon(\"/cache/recovery\", &contexts);\n\t\t\tif (!contexts) {\n\t\t\t\tlsetfilecon(\"/cache/recovery\", \"test\");\n\t\t\t\tlgetfilecon(\"/cache/recovery\", &contexts);\n\t\t\t}\n\t\t} else {\n\t\t\tLOGINFO(\"Could not check /cache/recovery SELinux contexts, using /sbin/teamwin instead which may be inaccurate.\\n\");\n\t\t\tlgetfilecon(\"/sbin/teamwin\", &contexts);\n\t\t}\n\t\tif (!contexts) {\n\t\t\tgui_warn(\"no_kernel_selinux=Kernel does not have support for reading SELinux contexts.\");\n\t\t} else {\n\t\t\tfree(contexts);\n\t\t\tgui_msg(\"full_selinux=Full SELinux support is present.\");\n\t\t}\n\t}\n\n\tPartitionManager.Mount_By_Path(\"/cache\", false);\n\n\tbool Shutdown = false;\n\tbool SkipDecryption = false;\n\tstring Send_Intent = \"\";\n\t{\n\t\tTWPartition* misc = PartitionManager.Find_Partition_By_Path(\"/misc\");\n\t\tif (misc != NULL) {\n\t\t\tif (misc->Current_File_System == \"emmc\") {\n\t\t\t\tset_misc_device(misc->Actual_Block_Device.c_str());\n\t\t\t} else {\n\t\t\t\tLOGERR(\"Only emmc /misc is supported\\n\");\n\t\t\t}\n\t\t}\n\t\tget_args(&argc, &argv);\n\n\t\tint index, index2, len;\n\t\tchar* argptr;\n\t\tchar* ptr;\n\t\tprintf(\"Startup Commands: \");\n\t\tfor (index = 1; index < argc; index++) {\n\t\t\targptr = argv[index];\n\t\t\tprintf(\" '%s'\", argv[index]);\n\t\t\tlen = strlen(argv[index]);\n\t\t\tif (*argptr == '-') {argptr++; len--;}\n\t\t\tif (*argptr == '-') {argptr++; len--;}\n\t\t\tif (*argptr == 'u') {\n\t\t\t\tptr = argptr;\n\t\t\t\tindex2 = 0;\n\t\t\t\twhile (*ptr != '=' && *ptr != '\\n')\n\t\t\t\t\tptr++;\n\t\t\t\t// skip the = before grabbing Zip_File\n\t\t\t\twhile (*ptr == '=')\n\t\t\t\t\tptr++;\n\t\t\t\tif (*ptr) {\n\t\t\t\t\tstring ORSCommand = \"install \";\n\t\t\t\t\tORSCommand.append(ptr);\n\n\t\t\t\t\t// If we have a map of blocks we don't need to mount data.\n\t\t\t\t\tSkipDecryption = *ptr == '@';\n\n\t\t\t\t\tif (!OpenRecoveryScript::Insert_ORS_Command(ORSCommand))\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tLOGERR(\"argument error specifying zip file\\n\");\n\t\t\t} else if (*argptr == 'w') {\n\t\t\t\tif (len == 9) {\n\t\t\t\t\tif (!OpenRecoveryScript::Insert_ORS_Command(\"wipe data\\n\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (len == 10) {\n\t\t\t\t\tif (!OpenRecoveryScript::Insert_ORS_Command(\"wipe cache\\n\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Other 'w' items are wipe_ab and wipe_package_size which are related to bricking the device remotely. We will not bother to suppor these as having TWRP probably makes \"bricking\" the device in this manner useless\n\t\t\t} else if (*argptr == 'n') {\n\t\t\t\tDataManager::SetValue(TW_BACKUP_NAME, gui_parse_text(\"{@auto_generate}\"));\n\t\t\t\tif (!OpenRecoveryScript::Insert_ORS_Command(\"backup BSDCAE\\n\"))\n\t\t\t\t\tbreak;\n\t\t\t} else if (*argptr == 'p') {\n\t\t\t\tShutdown = true;\n\t\t\t} else if (*argptr == 's') {\n\t\t\t\tif (strncmp(argptr, \"send_intent\", strlen(\"send_intent\")) == 0) {\n\t\t\t\t\tptr = argptr + strlen(\"send_intent\") + 1;\n\t\t\t\t\tSend_Intent = *ptr;\n\t\t\t\t} else if (strncmp(argptr, \"security\", strlen(\"security\")) == 0) {\n\t\t\t\t\tLOGINFO(\"Security update\\n\");\n\t\t\t\t} else if (strncmp(argptr, \"sideload\", strlen(\"sideload\")) == 0) {\n\t\t\t\t\tif (!OpenRecoveryScript::Insert_ORS_Command(\"sideload\\n\"))\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (strncmp(argptr, \"stages\", strlen(\"stages\")) == 0) {\n\t\t\t\t\tLOGINFO(\"ignoring stages command\\n\");\n\t\t\t\t}\n\t\t\t} else if (*argptr == 'r') {\n\t\t\t\tif (strncmp(argptr, \"reason\", strlen(\"reason\")) == 0) {\n\t\t\t\t\tptr = argptr + strlen(\"reason\") + 1;\n\t\t\t\t\tgui_print(\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (crash_counter == 0) {\n\t\tproperty_list(Print_Prop, NULL);\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tprintf(\"twrp.crash_counter=%d\\n\", crash_counter);\n\t}\n\n\t// Check for and run startup script if script exists\n\tTWFunc::check_and_run_script(\"/sbin/runatboot.sh\", \"boot\");\n\tTWFunc::check_and_run_script(\"/sbin/postrecoveryboot.sh\", \"boot\");\n\n#ifdef TW_INCLUDE_INJECTTWRP\n\t// Back up TWRP Ramdisk if needed:\n\tTWPartition* Boot = PartitionManager.Find_Partition_By_Path(\"/boot\");\n\tLOGINFO(\"Backing up TWRP ramdisk...\\n\");\n\tif (Boot == NULL || Boot->Current_File_System != \"emmc\")\n\t\tTWFunc::Exec_Cmd(\"injecttwrp --backup /tmp/backup_recovery_ramdisk.img\");\n\telse {\n\t\tstring injectcmd = \"injecttwrp --backup /tmp/backup_recovery_ramdisk.img bd=\" + Boot->Actual_Block_Device;\n\t\tTWFunc::Exec_Cmd(injectcmd);\n\t}\n\tLOGINFO(\"Backup of TWRP ramdisk done.\\n\");\n#endif\n\n\tTWFunc::Update_Log_File();\n\t// Offer to decrypt if the device is encrypted\n\tif (DataManager::GetIntValue(TW_IS_ENCRYPTED) != 0) {\n\t\tif (SkipDecryption) {\n\t\t\tLOGINFO(\"Skipping decryption\\n\");\n\t\t} else {\n\t\t\tLOGINFO(\"Is encrypted, do decrypt page first\\n\");\n\t\t\tif (gui_startPage(\"decrypt\", 1, 1) != 0) {\n\t\t\t\tLOGERR(\"Failed to start decrypt GUI page.\\n\");\n\t\t\t} else {\n\t\t\t\t// Check for and load custom theme if present\n\t\t\t\tgui_loadCustomResources();\n\t\t\t}\n\t\t}\n\t} else if (datamedia) {\n\t\tif (tw_get_default_metadata(DataManager::GetSettingsStoragePath().c_str()) != 0) {\n\t\t\tLOGINFO(\"Failed to get default contexts and file mode for storage files.\\n\");\n\t\t} else {\n\t\t\tLOGINFO(\"Got default contexts and file mode for storage files.\\n\");\n\t\t}\n\t}\n\n\t// Read the settings file\n\tDataManager::ReadSettingsFile();\n\tPageManager::LoadLanguage(DataManager::GetStrValue(\"tw_language\"));\n\tGUIConsole::Translate_Now();\n\n\t// Fixup the RTC clock on devices which require it\n\tif (crash_counter == 0)\n\t\tTWFunc::Fixup_Time_On_Boot();\n\n\t// Run any outstanding OpenRecoveryScript\n\tif ((DataManager::GetIntValue(TW_IS_ENCRYPTED) == 0 || SkipDecryption) && (TWFunc::Path_Exists(SCRIPT_FILE_TMP) || TWFunc::Path_Exists(SCRIPT_FILE_CACHE))) {\n\t\tOpenRecoveryScript::Run_OpenRecoveryScript();\n\t}\n\n#ifdef TW_HAS_MTP\n\tchar mtp_crash_check[PROPERTY_VALUE_MAX];\n\tproperty_get(\"mtp.crash_check\", mtp_crash_check, \"0\");\n\tif (DataManager::GetIntValue(\"tw_mtp_enabled\")\n\t\t\t&& !strcmp(mtp_crash_check, \"0\") && !crash_counter\n\t\t\t&& (!DataManager::GetIntValue(TW_IS_ENCRYPTED) || DataManager::GetIntValue(TW_IS_DECRYPTED))) {\n\t\tproperty_set(\"mtp.crash_check\", \"1\");\n\t\tLOGINFO(\"Starting MTP\\n\");\n\t\tif (!PartitionManager.Enable_MTP())\n\t\t\tPartitionManager.Disable_MTP();\n\t\telse\n\t\t\tgui_msg(\"mtp_enabled=MTP Enabled\");\n\t\tproperty_set(\"mtp.crash_check\", \"0\");\n\t} else if (strcmp(mtp_crash_check, \"0\")) {\n\t\tgui_warn(\"mtp_crash=MTP Crashed, not starting MTP on boot.\");\n\t\tDataManager::SetValue(\"tw_mtp_enabled\", 0);\n\t\tPartitionManager.Disable_MTP();\n\t} else if (crash_counter == 1) {\n\t\tLOGINFO(\"TWRP crashed; disabling MTP as a precaution.\\n\");\n\t\tPartitionManager.Disable_MTP();\n\t}\n#endif\n\n#ifndef TW_OEM_BUILD\n\t// Check if system has never been changed\n\tTWPartition* sys = PartitionManager.Find_Partition_By_Path(\"/system\");\n\tTWPartition* ven = PartitionManager.Find_Partition_By_Path(\"/vendor\");\n\n\tif (sys) {\n\t\tif ((DataManager::GetIntValue(\"tw_mount_system_ro\") == 0 && sys->Check_Lifetime_Writes() == 0) || DataManager::GetIntValue(\"tw_mount_system_ro\") == 2) {\n\t\t\tif (DataManager::GetIntValue(\"tw_never_show_system_ro_page\") == 0) {\n\t\t\t\tDataManager::SetValue(\"tw_back\", \"main\");\n\t\t\t\tif (gui_startPage(\"system_readonly\", 1, 1) != 0) {\n\t\t\t\t\tLOGERR(\"Failed to start system_readonly GUI page.\\n\");\n\t\t\t\t}\n\t\t\t} else if (DataManager::GetIntValue(\"tw_mount_system_ro\") == 0) {\n\t\t\t\tsys->Change_Mount_Read_Only(false);\n\t\t\t\tif (ven)\n\t\t\t\t\tven->Change_Mount_Read_Only(false);\n\t\t\t}\n\t\t} else if (DataManager::GetIntValue(\"tw_mount_system_ro\") == 1) {\n\t\t\t// Do nothing, user selected to leave system read only\n\t\t} else {\n\t\t\tsys->Change_Mount_Read_Only(false);\n\t\t\tif (ven)\n\t\t\t\tven->Change_Mount_Read_Only(false);\n\t\t}\n\t}\n#endif\n\ttwrpAdbBuFifo *adb_bu_fifo = new twrpAdbBuFifo();\n\tadb_bu_fifo->threadAdbBuFifo();\n\n\t// Launch the main GUI\n\tgui_start();\n\n#ifndef TW_OEM_BUILD\n\t// Disable flashing of stock recovery\n\tTWFunc::Disable_Stock_Recovery_Replace();\n#endif\n\n\t// Reboot\n\tTWFunc::Update_Intent_File(Send_Intent);\n\tdelete adb_bu_fifo;\n\tTWFunc::Update_Log_File();\n\tgui_msg(Msg(\"rebooting=Rebooting...\"));\n\tstring Reboot_Arg;\n\tDataManager::GetValue(\"tw_reboot_arg\", Reboot_Arg);\n\tif (Reboot_Arg == \"recovery\")\n\t\tTWFunc::tw_reboot(rb_recovery);\n\telse if (Reboot_Arg == \"poweroff\")\n\t\tTWFunc::tw_reboot(rb_poweroff);\n\telse if (Reboot_Arg == \"bootloader\")\n\t\tTWFunc::tw_reboot(rb_bootloader);\n\telse if (Reboot_Arg == \"download\")\n\t\tTWFunc::tw_reboot(rb_download);\n\telse\n\t\tTWFunc::tw_reboot(rb_system);\n\n\treturn 0;\n}\n"
        },
        {
          "name": "twrpAdbBuFifo.cpp",
          "type": "blob",
          "size": 11.384765625,
          "content": "/*\n        Copyright 2013 to 2017 TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define __STDC_FORMAT_MACROS 1\n#include <string>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <zlib.h>\n#include <inttypes.h>\n#include \"twrpAdbBuFifo.hpp\"\n#include \"twcommon.h\"\n#include \"data.hpp\"\n#include \"variables.h\"\n#include \"partitions.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"gui/gui.hpp\"\n#include \"gui/objects.hpp\"\n#include \"gui/pages.hpp\"\n#include \"adbbu/twadbstream.h\"\n#include \"adbbu/libtwadbbu.hpp\"\n\ntwrpAdbBuFifo::twrpAdbBuFifo(void) {\n\tunlink(TW_ADB_FIFO);\n}\n\nvoid twrpAdbBuFifo::Check_Adb_Fifo_For_Events(void) {\n\tchar cmd[512];\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tif (read(adb_fifo_fd, &cmd, sizeof(cmd)) > 0) {\n\t\tLOGINFO(\"adb backup cmd: %s\\n\", cmd);\n\t\tstd::string cmdcheck(cmd);\n\t\tcmdcheck = cmdcheck.substr(0, strlen(ADB_BACKUP_OP));\n\t\tstd::string Options(cmd);\n\t\tOptions = Options.substr(strlen(ADB_BACKUP_OP) + 1, strlen(cmd));\n\t\tif (cmdcheck == ADB_BACKUP_OP)\n\t\t\tBackup_ADB_Command(Options);\n\t\telse {\n\t\t\tRestore_ADB_Backup();\n\t\t}\n\t}\n}\n\nbool twrpAdbBuFifo::start(void) {\n\tLOGINFO(\"Starting Adb Backup FIFO\\n\");\n\tunlink(TW_ADB_FIFO);\n\tif (mkfifo(TW_ADB_FIFO, 06660) != 0) {\n\t\tLOGINFO(\"Unable to mkfifo %s\\n\", TW_ADB_FIFO);\n\t\treturn false;\n\t}\n\tadb_fifo_fd = open(TW_ADB_FIFO, O_RDONLY | O_NONBLOCK);\n\tif (adb_fifo_fd < 0) {\n\t\tLOGERR(\"Unable to open TW_ADB_FIFO for reading.\\n\");\n\t\tclose(adb_fifo_fd);\n\t\treturn false;\n\t}\n\twhile (true) {\n\t\tCheck_Adb_Fifo_For_Events();\n\t\tusleep(8000);\n\t}\n\t//Shouldn't get here but cleanup anwyay\n\tclose(adb_fifo_fd);\n\treturn true;\n}\n\npthread_t twrpAdbBuFifo::threadAdbBuFifo(void) {\n\tpthread_t thread;\n\tThreadPtr adbfifo = &twrpAdbBuFifo::start;\n\tPThreadPtr p = *(PThreadPtr*)&adbfifo;\n\tpthread_create(&thread, NULL, p, this);\n\treturn thread;\n}\n\nbool twrpAdbBuFifo::Backup_ADB_Command(std::string Options) {\n\tstd::vector<std::string> args;\n\tstd::string Backup_List;\n\tbool adbbackup = true, ret = false;\n\tstd::string rmopt = \"--\";\n\n\tstd::replace(Options.begin(), Options.end(), ':', ' ');\n\targs = TWFunc::Split_String(Options, \" \");\n\n\tDataManager::SetValue(TW_USE_COMPRESSION_VAR, 0);\n\tDataManager::SetValue(TW_SKIP_DIGEST_GENERATE_VAR, 0);\n\n\tif (args[1].compare(\"--twrp\") != 0) {\n\t\tgui_err(\"twrp_adbbu_option=--twrp option is required to enable twrp adb backup\");\n\t\tif (!twadbbu::Write_TWERROR())\n\t\t\tLOGERR(\"Unable to write to ADB Backup\\n\");\n\t\tsleep(2);\n\t\treturn false;\n\t}\n\n\tfor (unsigned i = 2; i < args.size(); i++) {\n\t\tint compress;\n\n\t\tstd::string::size_type size = args[i].find(rmopt);\n\t\tif (size != std::string::npos)\n\t\t\targs[i].erase(size, rmopt.length());\n\n\t\tif (args[i].compare(\"compress\") == 0) {\n\t\t\tgui_msg(\"compression_on=Compression is on\");\n\t\t\tDataManager::SetValue(TW_USE_COMPRESSION_VAR, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tDataManager::GetValue(TW_USE_COMPRESSION_VAR, compress);\n\t\tgui_print(\"%s\\n\", args[i].c_str());\n\t\tstd::string path;\n\t\tpath = \"/\" + args[i];\n\t\tTWPartition* part = PartitionManager.Find_Partition_By_Path(path);\n\t\tif (part) {\n\t\t\tBackup_List += path;\n\t\t\tBackup_List += \";\";\n\t\t}\n\t\telse {\n\t\t\tgui_msg(Msg(msg::kError, \"partition_not_found=path: {1} not found in partition list\")(path));\n\t\t\tif (!twadbbu::Write_TWERROR())\n\t\t\t\tLOGERR(\"Unable to write to TWRP ADB Backup.\\n\");\n\t\treturn false;\n\t}\n}\n\n\tif (Backup_List.empty()) {\n\t\tDataManager::GetValue(\"tw_backup_list\", Backup_List);\n\t\tif (Backup_List.empty()) {\n\t\t\tgui_err(\"no_partition_selected=No partitions selected for backup.\");\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t\tDataManager::SetValue(\"tw_backup_list\", Backup_List);\n\n\tDataManager::SetValue(\"tw_action\", \"clear\");\n\tDataManager::SetValue(\"tw_action_text1\", gui_lookup(\"running_recovery_commands\", \"Running Recovery Commands\"));\n\tDataManager::SetValue(\"tw_action_text2\", \"\");\n\tgui_changePage(\"action_page\");\n\n\tret = PartitionManager.Run_Backup(adbbackup);\n\tDataManager::SetValue(TW_BACKUP_NAME, gui_lookup(\"auto_generate\", \"(Auto Generate)\"));\n\tif (!ret) {\n\t\tgui_err(\"backup_fail=Backup failed\");\n\t\treturn false;\n\t}\n\tgui_msg(\"backup_complete=Backup Complete\");\n\tDataManager::SetValue(\"ui_progress\", 100);\n\tsleep(2); //give time for user to see messages on console\n\tgui_changePage(\"main\");\n\treturn true;\n}\n\nbool twrpAdbBuFifo::Restore_ADB_Backup(void) {\n\tint partition_count = 0;\n\tstd::string Restore_Name;\n\tstruct AdbBackupFileTrailer adbmd5;\n\tstruct PartitionSettings part_settings;\n\tint adb_control_twrp_fd;\n\tint adb_control_bu_fd, ret = 0;\n\tchar cmd[512];\n\n\tpart_settings.total_restore_size = 0;\n\n\tPartitionManager.Mount_All_Storage();\n\tDataManager::SetValue(TW_SKIP_DIGEST_CHECK_VAR, 0);\n\tLOGINFO(\"opening TW_ADB_BU_CONTROL\\n\");\n\tadb_control_bu_fd = open(TW_ADB_BU_CONTROL, O_WRONLY | O_NONBLOCK);\n\tLOGINFO(\"opening TW_ADB_TWRP_CONTROL\\n\");\n\tadb_control_twrp_fd = open(TW_ADB_TWRP_CONTROL, O_RDONLY | O_NONBLOCK);\n\tmemset(&adbmd5, 0, sizeof(adbmd5));\n\n\tDataManager::SetValue(\"tw_action\", \"clear\");\n\tDataManager::SetValue(\"tw_action_text1\", gui_lookup(\"running_recovery_commands\", \"Running Recovery Commands\"));\n\tDataManager::SetValue(\"tw_action_text2\", \"\");\n\tgui_changePage(\"action_page\");\n\n\twhile (true) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tif (read(adb_control_twrp_fd, cmd, sizeof(cmd)) > 0) {\n\t\t\tstruct AdbBackupControlType cmdstruct;\n\n\t\t\tmemset(&cmdstruct, 0, sizeof(cmdstruct));\n\t\t\tmemcpy(&cmdstruct, cmd, sizeof(cmdstruct));\n\t\t\tstd::string cmdtype = cmdstruct.get_type();\n\t\t\tif (cmdtype == TWSTREAMHDR) {\n\t\t\t\tstruct AdbBackupStreamHeader twhdr;\n\t\t\t\tmemcpy(&twhdr, cmd, sizeof(cmd));\n\t\t\t\tLOGINFO(\"ADB Partition count: %\" PRIu64 \"\\n\", twhdr.partition_count);\n\t\t\t\tLOGINFO(\"ADB version: %\" PRIu64 \"\\n\", twhdr.version);\n\t\t\t\tif (twhdr.version != ADB_BACKUP_VERSION) {\n\t\t\t\t\tLOGERR(\"Incompatible adb backup version!\\n\");\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpartition_count = twhdr.partition_count;\n\t\t\t}\n\t\t\telse if (cmdtype == MD5TRAILER) {\n\t\t\t\tLOGINFO(\"Reading ADB Backup MD5TRAILER\\n\");\n\t\t\t\tmemcpy(&adbmd5, cmd, sizeof(cmd));\n\t\t\t}\n\t\t\telse if (cmdtype == TWMD5) {\n\t\t\t\tint check_digest;\n\n\t\t\t\tDataManager::GetValue(TW_SKIP_DIGEST_CHECK_VAR, check_digest);\n\t\t\t\tif (check_digest > 0) {\n\t\t\t\t\tTWFunc::GUI_Operation_Text(TW_VERIFY_DIGEST_TEXT, gui_parse_text(\"{@verifying_digest}\"));\n\t\t\t\t\tgui_msg(\"verifying_digest=Verifying Digest\");\n\t\t\t\t\tstruct AdbBackupFileTrailer md5check;\n\t\t\t\t\tLOGINFO(\"Verifying md5sums\\n\");\n\n\t\t\t\t\tmemset(&md5check, 0, sizeof(md5check));\n\t\t\t\t\tmemcpy(&md5check, cmd, sizeof(cmd));\n\t\t\t\t\tif (strcmp(md5check.md5, adbmd5.md5) != 0) {\n\t\t\t\t\t\tLOGERR(\"md5 doesn't match!\\n\");\n\t\t\t\t\t\tLOGERR(\"Stored file md5: %s\\n\", adbmd5.md5);\n\t\t\t\t\t\tLOGERR(\"ADB Backup check md5: %s\\n\", md5check.md5);\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tLOGINFO(\"ADB Backup md5 matches\\n\");\n\t\t\t\t\t\tLOGINFO(\"Stored file md5: %s\\n\", adbmd5.md5);\n\t\t\t\t\t\tLOGINFO(\"ADB Backup check md5: %s\\n\", md5check.md5);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgui_msg(\"skip_digest=Skipping Digest check based on user setting.\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (cmdtype == TWENDADB) {\n\t\t\t\tLOGINFO(\"received TWENDADB\\n\");\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstruct twfilehdr twimghdr;\n\t\t\t\tmemcpy(&twimghdr, cmd, sizeof(cmd));\n\t\t\t\tstd::string cmdstr(twimghdr.type);\n\t\t\t\tRestore_Name = twimghdr.name;\n\t\t\t\tpart_settings.total_restore_size = twimghdr.size;\n\t\t\t\tif (cmdtype == TWIMG) {\n\t\t\t\t\tLOGINFO(\"ADB Type: %s\\n\", twimghdr.type);\n\t\t\t\t\tLOGINFO(\"ADB Restore_Name: %s\\n\", Restore_Name.c_str());\n\t\t\t\t\tLOGINFO(\"ADB Restore_size: %\" PRIu64 \"\\n\", part_settings.total_restore_size);\n\t\t\t\t\tstring compression = (twimghdr.compressed == 1) ? \"compressed\" : \"uncompressed\";\n\t\t\t\t\tLOGINFO(\"ADB compression: %s\\n\", compression.c_str());\n\t\t\t\t\tstd::string Backup_FileName;\n\t\t\t\t\tstd::size_t pos = Restore_Name.find_last_of(\"/\");\n\t\t\t\t\tstd::string path = \"/\" + Restore_Name.substr(pos, Restore_Name.size());\n\t\t\t\t\tpos = path.find_first_of(\".\");\n\t\t\t\t\tpath = path.substr(0, pos);\n\t\t\t\t\tif (path.substr(0,1).compare(\"//\")) {\n\t\t\t\t\t\tpath = path.substr(1, path.size());\n\t\t\t\t\t}\n\n\t\t\t\t\tpos = Restore_Name.find_last_of(\"/\");\n\t\t\t\t\tBackup_FileName = Restore_Name.substr(pos + 1, Restore_Name.size());\n\t\t\t\t\tpart_settings.Part = PartitionManager.Find_Partition_By_Path(path);\n\t\t\t\t\tpart_settings.Backup_Folder = path;\n\t\t\t\t\tPartitionManager.Set_Restore_Files(path);\n\t\t\t\t\tpart_settings.partition_count = partition_count;\n\t\t\t\t\tpart_settings.adbbackup = true;\n\t\t\t\t\tpart_settings.adb_compression = twimghdr.compressed;\n\t\t\t\t\tpart_settings.PM_Method = PM_RESTORE;\n\t\t\t\t\tProgressTracking progress(part_settings.total_restore_size);\n\t\t\t\t\tpart_settings.progress = &progress;\n\t\t\t\t\tif (!PartitionManager.Restore_Partition(&part_settings)) {\n\t\t\t\t\t\tLOGERR(\"ADB Restore failed.\\n\");\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (cmdtype == TWFN) {\n\t\t\t\t\tLOGINFO(\"ADB Type: %s\\n\", twimghdr.type);\n\t\t\t\t\tLOGINFO(\"ADB Restore_Name: %s\\n\", Restore_Name.c_str());\n\t\t\t\t\tLOGINFO(\"ADB Restore_size: %\" PRIi64 \"\\n\", part_settings.total_restore_size);\n\t\t\t\t\tstring compression = (twimghdr.compressed == 1) ? \"compressed\" : \"uncompressed\";\n\t\t\t\t\tLOGINFO(\"ADB compression: %s\\n\", compression.c_str());\n\t\t\t\t\tstd::string Backup_FileName;\n\t\t\t\t\tstd::size_t pos = Restore_Name.find_last_of(\"/\");\n\t\t\t\t\tstd::string path = \"/\" + Restore_Name.substr(pos, Restore_Name.size());\n\t\t\t\t\tpos = path.find_first_of(\".\");\n\t\t\t\t\tpath = path.substr(0, pos);\n\t\t\t\t\tif (path.substr(0,1).compare(\"//\")) {\n\t\t\t\t\t\tpath = path.substr(1, path.size());\n\t\t\t\t\t}\n\n\t\t\t\t\tpos = Restore_Name.find_last_of(\"/\");\n\t\t\t\t\tBackup_FileName = Restore_Name.substr(pos + 1, Restore_Name.size());\n\t\t\t\t\tpos = Restore_Name.find_last_of(\"/\");\n\t\t\t\t\tpart_settings.Part = PartitionManager.Find_Partition_By_Path(path);\n\t\t\t\t\tpart_settings.Part->Set_Backup_FileName(Backup_FileName);\n\t\t\t\t\tPartitionManager.Set_Restore_Files(path);\n\n\t\t\t\t\tif (path.compare(\"/system\") == 0) {\n\t\t\t\t\t\tif (part_settings.Part->Is_Read_Only()) {\n\t\t\t\t\t\t\tif (!twadbbu::Write_TWERROR())\n\t\t\t\t\t\t\t\tLOGERR(\"Unable to write to TWRP ADB Backup.\\n\");\n\t\t\t\t\t\t\tgui_msg(Msg(msg::kError, \"restore_read_only=Cannot restore {1} -- mounted read only.\")(part_settings.Part->Backup_Display_Name));\n\t\t\t\t\t\t\tret = false;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpart_settings.partition_count = partition_count;\n\t\t\t\t\tpart_settings.adbbackup = true;\n\t\t\t\t\tpart_settings.adb_compression = twimghdr.compressed;\n\t\t\t\t\tpart_settings.total_restore_size += part_settings.Part->Get_Restore_Size(&part_settings);\n\t\t\t\t\tpart_settings.PM_Method = PM_RESTORE;\n\t\t\t\t\tProgressTracking progress(part_settings.total_restore_size);\n\t\t\t\t\tpart_settings.progress = &progress;\n\t\t\t\t\tif (!PartitionManager.Restore_Partition(&part_settings)) {\n\t\t\t\t\t\tLOGERR(\"ADB Restore failed.\\n\");\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret != false)\n\t\tgui_msg(\"restore_complete=Restore Complete\");\n\telse\n\t\tgui_err(\"restore_error=Error during restore process.\");\n\n\tif (!twadbbu::Write_TWENDADB())\n\t\tret = false;\n\tsleep(2); //give time for user to see messages on console\n\tDataManager::SetValue(\"ui_progress\", 100);\n\tgui_changePage(\"main\");\n\tclose(adb_control_bu_fd);\n\treturn ret;\n}\n"
        },
        {
          "name": "twrpAdbBuFifo.hpp",
          "type": "blob",
          "size": 1.23046875,
          "content": "/*\n        Copyright 2013 to 2017 TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef TWRPADBFIFO_HPP\n#define TWRPADBFIFO_HPP\n\n#include <string>\n#include <pthread.h>\n\n#define TW_ADB_FIFO \"/tmp/twadbfifo\"\n\nclass twrpAdbBuFifo {\n\tpublic:\n\t\ttwrpAdbBuFifo(void);\n\t\tpthread_t threadAdbBuFifo(void);\n\tprivate:\n\t\tbool start(void);\n\t\tbool Backup_ADB_Command(std::string Options);\n\t\tvoid Check_Adb_Fifo_For_Events(void);\n\t\tbool Restore_ADB_Backup(void);\n\t\ttypedef bool (twrpAdbBuFifo::*ThreadPtr)(void);\n\t\ttypedef void* (*PThreadPtr)(void *);\n\t\tint adb_fifo_fd;\n};\n#endif\n"
        },
        {
          "name": "twrpDigest",
          "type": "tree",
          "content": null
        },
        {
          "name": "twrpDigestDriver.cpp",
          "type": "blob",
          "size": 5.634765625,
          "content": "/*\n\tCopyright 2013 to 2017 TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n#include <fcntl.h>\n#include <string>\n#include <unistd.h>\n#include \"data.hpp\"\n#include \"partitions.hpp\"\n#include \"set_metadata.h\"\n#include \"twrpDigestDriver.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"twcommon.h\"\n#include \"variables.h\"\n#include \"gui/gui.hpp\"\n#include \"twrpDigest/twrpDigest.hpp\"\n#include \"twrpDigest/twrpMD5.hpp\"\n#include \"twrpDigest/twrpSHA.hpp\"\n\n\nbool twrpDigestDriver::Check_Restore_File_Digest(const string& Filename) {\n\ttwrpDigest *digest;\n\tstring digestfile = Filename, file_name = Filename;\n\tstring digest_str;\n\tbool use_sha2 = false;\n\n#ifndef TW_NO_SHA2_LIBRARY\n\n\tdigestfile += \".sha2\";\n\tif (TWFunc::Path_Exists(digestfile)) {\n\t\tdigest = new twrpSHA256();\n\t\tuse_sha2 = true;\n\t}\n\telse {\n\t\tdigest = new twrpMD5();\n\t\tdigestfile = Filename + \".md5\";\n\n\t}\n#else\n\tdigest = new twrpMD5();\n\tdigestfile = Filename + \".md5\";\n\n#endif\n\n\tif (!TWFunc::Path_Exists(digestfile)) {\n\t\tgui_msg(Msg(msg::kError, \"no_digest_found=No digest file found for '{1}'. Please unselect Enable Digest verification to restore.\")(Filename));\n\t\tdelete digest;\n\t\treturn false;\n\t}\n\n\n\tif (TWFunc::read_file(digestfile, digest_str) != 0) {\n\t\tgui_msg(\"digest_error=Digest Error!\");\n\t\tdelete digest;\n\t\treturn false;\n\t}\n\n\tif (!stream_file_to_digest(file_name, digest)) {\n\t\tdelete digest;\n\t\treturn false;\n\t}\n\tstring digest_check = digest->return_digest_string();\n\tif (digest_check == digest_str) {\n\t\tif (use_sha2)\n\t\t\tLOGINFO(\"SHA2 Digest: %s  %s\\n\", digest_str.c_str(), TWFunc::Get_Filename(Filename).c_str());\n\t\telse\n\t\t\tLOGINFO(\"MD5 Digest: %s  %s\\n\", digest_str.c_str(), TWFunc::Get_Filename(Filename).c_str());\n\t\tdelete digest;\n\t\treturn true;\n\t}\n\n\tgui_msg(Msg(msg::kError, \"digest_fail_match=Digest failed to match on '{1}'.\")(Filename));\n\tdelete digest;\n\treturn false;\n\n}\n\nbool twrpDigestDriver::Check_Digest(string Full_Filename) {\n\tchar split_filename[512];\n\tint index = 0;\n\n\tsync();\n\tif (!TWFunc::Path_Exists(Full_Filename)) {\n\t\t// This is a split archive, we presume\n\t\tmemset(split_filename, 0, sizeof(split_filename));\n\t\twhile (index < 1000) {\n\t\t\tsprintf(split_filename, \"%s%03i\", Full_Filename.c_str(), index);\n\t\t\tif (!TWFunc::Path_Exists(split_filename))\n\t\t\t\tbreak;\n\t\t\t\tLOGINFO(\"split_filename: %s\\n\", split_filename);\n\t\t\t\tif (!Check_Restore_File_Digest(split_filename))\n\t\t\t\t\treturn false;\n\t\t\t\tindex++;\n\t\t}\n\t\treturn true;\n\t}\n\treturn Check_Restore_File_Digest(Full_Filename); // Single file archive\n}\n\nbool twrpDigestDriver::Write_Digest(string Full_Filename) {\n\ttwrpDigest *digest;\n\tstring digest_filename, digest_str;\n\tint use_sha2;\n\n#ifdef TW_NO_SHA2_LIBRARY\n\tuse_sha2 = 0;\n#else\n\tDataManager::GetValue(TW_USE_SHA2, use_sha2);\n#endif\n\n\tif (use_sha2) {\n#ifndef TW_NO_SHA2_LIBRARY\n\t\tdigest = new twrpSHA256();\n\t\tdigest_filename = Full_Filename + \".sha2\";\n\t\tif (!stream_file_to_digest(Full_Filename, digest)) {\n\t\t\tdelete digest;\n\t\t\treturn false;\n\t\t}\n\t\tdigest_str = digest->return_digest_string();\n\t\tif (digest_str.empty()) {\n\t\t\tdelete digest;\n\t\t\treturn false;\n\t\t}\n\t\tLOGINFO(\"SHA2 Digest: %s  %s\\n\", digest_str.c_str(), TWFunc::Get_Filename(Full_Filename).c_str());\n#endif\n\t}\n\telse  {\n\t\tdigest = new twrpMD5();\n\t\tdigest_filename = Full_Filename + \".md5\";\n\t\tif (!stream_file_to_digest(Full_Filename, digest)) {\n\t\t\tdelete digest;\n\t\t\treturn false;\n\t\t}\n\t\tdigest_str = digest->return_digest_string();\n\t\tif (digest_str.empty()) {\n\t\t\tdelete digest;\n\t\t\treturn false;\n\t\t}\n\t\tLOGINFO(\"MD5 Digest: %s  %s\\n\", digest_str.c_str(), TWFunc::Get_Filename(Full_Filename).c_str());\n\t}\n\n\tdigest_str = digest_str + \"  \" + TWFunc::Get_Filename(Full_Filename) + \"\\n\";\n\tLOGINFO(\"digest_filename: %s\\n\", digest_filename.c_str());\n\n\tif (TWFunc::write_to_file(digest_filename, digest_str) == 0) {\n\t\ttw_set_default_metadata(digest_filename.c_str());\n\t\tgui_msg(\"digest_created= * Digest Created.\");\n\t}\n\telse {\n\t\tgui_err(\"digest_error= * Digest Error!\");\n\t\tdelete digest;\n\t\treturn false;\n\t}\n\tdelete digest;\n\treturn true;\n}\n\nbool twrpDigestDriver::Make_Digest(string Full_Filename) {\n\tstring command, result;\n\n\tTWFunc::GUI_Operation_Text(TW_GENERATE_DIGEST_TEXT, gui_parse_text(\"{@generating_digest1}\"));\n\tgui_msg(\"generating_digest2= * Generating digest...\");\n\tif (TWFunc::Path_Exists(Full_Filename)) {\n\t\tif (!Write_Digest(Full_Filename))\n\t\t\treturn false;\n\t} else {\n\t\tchar filename[512];\n\t\tint index = 0;\n\t\tsprintf(filename, \"%s%03i\", Full_Filename.c_str(), index);\n\t\twhile (index < 1000) {\n\t\t\tstring digest_src(filename);\n\t\t\tif (TWFunc::Path_Exists(filename)) {\n\t\t\t\tif (!Write_Digest(filename))\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\tindex++;\n\t\t\t\tsprintf(filename, \"%s%03i\", Full_Filename.c_str(), index);\n\t\t\t}\n\t\t\tif (index == 0) {\n\t\t\t\tLOGERR(\"Backup file: '%s' not found!\\n\", filename);\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgui_msg(\"digest_created= * Digest Created.\");\n\t}\n\treturn true;\n}\n\nbool twrpDigestDriver::stream_file_to_digest(string filename, twrpDigest* digest) {\n\tchar buf[4096];\n\tint bytes;\n\n\tint fd = open(filename.c_str(), O_RDONLY);\n\tif (fd < 0) {\n\t\treturn false;\n\t}\n\twhile ((bytes = read(fd, &buf, sizeof(buf))) != 0) {\n\t\tdigest->update((unsigned char*)buf, bytes);\n\t}\n\tclose(fd);\n\treturn true;\n}\n"
        },
        {
          "name": "twrpDigestDriver.hpp",
          "type": "blob",
          "size": 1.408203125,
          "content": "/*\n        Copyright 2013 to 2017 TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef __TWRP_DIGEST_DRIVER\n#define __TWRP_DIGEST_DRIVER\n#include <string>\n#include \"twrpDigest/twrpDigest.hpp\"\n\nclass twrpDigestDriver {\npublic:\n\n\tstatic bool Check_Restore_File_Digest(const string& Filename);\t\t//Check the digest of a TWRP partition backup\n\tstatic bool Check_Digest(string Full_Filename);\t\t\t\t//Check to make sure the digest is correct\n\tstatic bool Write_Digest(string Full_Filename);\t\t\t\t//Write the digest to a file\n\tstatic bool Make_Digest(string Full_Filename);\t\t\t\t//Create the digest for a partition backup\n\tstatic bool stream_file_to_digest(string filename, twrpDigest* digest); //Stream the file to twrpDigest\n};\n#endif //__TWRP_DIGEST_DRIVER\n"
        },
        {
          "name": "twrpTar.cpp",
          "type": "blob",
          "size": 47.4072265625,
          "content": "\n/*\n\tCopyright 2013 to 2016 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nextern \"C\" {\n\t#include \"libtar/libtar.h\"\n\t#include \"twrpTar.h\"\n\t#include \"tarWrite.h\"\n}\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <csignal>\n#include <dirent.h>\n#include <libgen.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <zlib.h>\n#include <semaphore.h>\n#include \"twrpTar.hpp\"\n#include \"twcommon.h\"\n#include \"variables.h\"\n#include \"adbbu/libtwadbbu.hpp\"\n#include \"twrp-functions.hpp\"\n#include \"gui/gui.hpp\"\n#include \"progresstracking.hpp\"\n#ifndef BUILD_TWRPTAR_MAIN\n#include \"data.hpp\"\n#include \"infomanager.hpp\"\n#include \"set_metadata.h\"\n#endif //ndef BUILD_TWRPTAR_MAIN\n\n#ifdef TW_INCLUDE_FBE\n#include \"crypto/ext4crypt/ext4crypt_tar.h\"\n#define TWTAR_FLAGS TAR_GNU | TAR_STORE_SELINUX | TAR_STORE_POSIX_CAP | TAR_STORE_ANDROID_USER_XATTR |TAR_STORE_EXT4_POL\n#else\n#define TWTAR_FLAGS TAR_GNU | TAR_STORE_SELINUX | TAR_STORE_POSIX_CAP | TAR_STORE_ANDROID_USER_XATTR\n#endif\n\nusing namespace std;\n\ntwrpTar::twrpTar(void) {\n\tuse_encryption = 0;\n\tuserdata_encryption = 0;\n\tuse_compression = 0;\n\tsplit_archives = 0;\n\tpigz_pid = 0;\n\toaes_pid = 0;\n\tTotal_Backup_Size = 0;\n\tArchive_Current_Size = 0;\n\tinclude_root_dir = true;\n\ttar_type.openfunc = open;\n\ttar_type.closefunc = close;\n\ttar_type.readfunc = read;\n\tinput_fd = -1;\n\toutput_fd = -1;\n\tbackup_exclusions = NULL;\n#ifdef TW_INCLUDE_FBE\n\te4crypt_set_mode();\n#endif\n}\n\ntwrpTar::~twrpTar(void) {\n\t// Do nothing\n}\n\nvoid twrpTar::setfn(string fn) {\n\ttarfn = fn;\n}\n\nvoid twrpTar::setdir(string dir) {\n\ttardir = dir;\n}\n\nvoid twrpTar::setsize(unsigned long long backup_size) {\n\tTotal_Backup_Size = backup_size;\n}\n\nvoid twrpTar::setpassword(string pass) {\n\tpassword = pass;\n}\n\nvoid twrpTar::Signal_Kill(int signum) {\n\t_exit(255);\n}\n\nvoid twrpTar::Set_Archive_Type(Archive_Type archive_type) {\n\tcurrent_archive_type = archive_type;\n}\n\nint twrpTar::createTarFork(pid_t *tar_fork_pid) {\n\tint status = 0;\n\tint progress_pipe[2];\n\n\tfile_count = 0;\n\tif (backup_exclusions == NULL) {\n\t\tLOGINFO(\"backup_exclusions is NULL\\n\");\n\t\treturn -1;\n\t}\n\n#ifndef BUILD_TWRPTAR_MAIN\n\tif (part_settings->adbbackup) {\n\t\tstd::string Backup_FileName(tarfn);\n\t\tif (!twadbbu::Write_TWFN(Backup_FileName, Total_Backup_Size, use_compression))\n\t\t\treturn -1;\n\t}\n#endif\n\n\tif (pipe(progress_pipe) < 0) {\n\t\tLOGINFO(\"Error creating progress tracking pipe\\n\");\n\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\treturn -1;\n\t}\n\tif ((*tar_fork_pid = fork()) == -1) {\n\t\tLOGINFO(\"create tar failed to fork.\\n\");\n\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\tclose(progress_pipe[0]);\n\t\tclose(progress_pipe[1]);\n\t\treturn -1;\n\t}\n\n\tif (*tar_fork_pid == 0) {\n\t\t// Child process\n\t\t// Child closes input side of progress pipe\n\t\tsignal(SIGUSR2, twrpTar::Signal_Kill);\n\t\tclose(progress_pipe[0]);\n\t\tprogress_pipe_fd = progress_pipe[1];\n\n\t\tif (use_encryption || userdata_encryption) {\n\t\t\tLOGINFO(\"Using encryption\\n\");\n\t\t\tDIR* d;\n\t\t\tstruct dirent* de;\n\t\t\tunsigned long long regular_size = 0, encrypt_size = 0, target_size = 0, total_size;\n\t\t\tunsigned enc_thread_id = 1, regular_thread_id = 0, i, start_thread_id = 1, core_count = 1;\n\t\t\tint item_len, ret, thread_error = 0;\n\t\t\tstd::vector<TarListStruct> RegularList;\n\t\t\tstd::vector<TarListStruct> EncryptList;\n\t\t\tstring FileName;\n\t\t\tstruct TarListStruct TarItem;\n\t\t\ttwrpTar reg, enc[9];\n\t\t\tstruct stat st;\n\t\t\tpthread_t enc_thread[9];\n\t\t\tpthread_attr_t tattr;\n\t\t\tvoid *thread_return;\n\n\t\t\tcore_count = sysconf(_SC_NPROCESSORS_CONF);\n\t\t\tif (core_count > 8)\n\t\t\t\tcore_count = 8;\n\t\t\tLOGINFO(\"   Core Count      : %u\\n\", core_count);\n\t\t\tArchive_Current_Size = 0;\n\n\t\t\td = opendir(tardir.c_str());\n\t\t\tif (d == NULL) {\n\t\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tardir)(strerror(errno)));\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\t// Figure out the size of all data to be encrypted and create a list of unencrypted files\n\t\t\twhile ((de = readdir(d)) != NULL) {\n\t\t\t\tFileName = tardir + \"/\" + de->d_name;\n\n\t\t\t\tif (de->d_type == DT_BLK || de->d_type == DT_CHR || backup_exclusions->check_skip_dirs(FileName))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (de->d_type == DT_DIR) {\n\t\t\t\t\titem_len = strlen(de->d_name);\n\t\t\t\t\tif (userdata_encryption && ((item_len >= 3 && strncmp(de->d_name, \"app\", 3) == 0) || (item_len >= 6 && strncmp(de->d_name, \"dalvik\", 6) == 0))) {\n\t\t\t\t\t\tret = Generate_TarList(FileName, &RegularList, &target_size, &regular_thread_id);\n\t\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\t\tLOGINFO(\"Error in Generate_TarList with regular list!\\n\");\n\t\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\t\tclosedir(d);\n\t\t\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfile_count = (unsigned long long)(ret);\n\t\t\t\t\t\tregular_size += backup_exclusions->Get_Folder_Size(FileName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tencrypt_size += backup_exclusions->Get_Folder_Size(FileName);\n\t\t\t\t\t}\n\t\t\t\t} else if (de->d_type == DT_REG) {\n\t\t\t\t\tstat(FileName.c_str(), &st);\n\t\t\t\t\tencrypt_size += (unsigned long long)(st.st_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(d);\n\n\t\t\ttarget_size = encrypt_size / core_count;\n\t\t\ttarget_size++;\n\t\t\tLOGINFO(\"   Unencrypted size: %llu\\n\", regular_size);\n\t\t\tLOGINFO(\"   Encrypted size  : %llu\\n\", encrypt_size);\n\t\t\tLOGINFO(\"   Target size     : %llu\\n\", target_size);\n\t\t\tif (!userdata_encryption) {\n\t\t\t\tenc_thread_id = 0;\n\t\t\t\tstart_thread_id = 0;\n\t\t\t\tcore_count--;\n\t\t\t}\n\t\t\tArchive_Current_Size = 0;\n\n\t\t\td = opendir(tardir.c_str());\n\t\t\tif (d == NULL) {\n\t\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tardir)(strerror(errno)));\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\t// Divide up the encrypted file list for threading\n\t\t\twhile ((de = readdir(d)) != NULL) {\n\t\t\t\tFileName = tardir + \"/\" + de->d_name;\n\n\t\t\t\tif (de->d_type == DT_BLK || de->d_type == DT_CHR || backup_exclusions->check_skip_dirs(FileName))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (de->d_type == DT_DIR) {\n\t\t\t\t\titem_len = strlen(de->d_name);\n\t\t\t\t\tif (userdata_encryption && ((item_len >= 3 && strncmp(de->d_name, \"app\", 3) == 0) || (item_len >= 6 && strncmp(de->d_name, \"dalvik\", 6) == 0))) {\n\t\t\t\t\t\t// Do nothing, we added these to RegularList earlier\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFileName = tardir + \"/\" + de->d_name;\n\t\t\t\t\t\tret = Generate_TarList(FileName, &EncryptList, &target_size, &enc_thread_id);\n\t\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\t\tLOGINFO(\"Error in Generate_TarList with encrypted list!\\n\");\n\t\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\t\tclosedir(d);\n\t\t\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfile_count += (unsigned long long)(ret);\n\t\t\t\t\t}\n\t\t\t\t} else if (de->d_type == DT_REG || de->d_type == DT_LNK) {\n\t\t\t\t\tstat(FileName.c_str(), &st);\n\t\t\t\t\tif (de->d_type == DT_REG)\n\t\t\t\t\t\tArchive_Current_Size += (unsigned long long)(st.st_size);\n\t\t\t\t\tTarItem.fn = FileName;\n\t\t\t\t\tTarItem.thread_id = enc_thread_id;\n\t\t\t\t\tEncryptList.push_back(TarItem);\n\t\t\t\t\tfile_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(d);\n\t\t\tif (enc_thread_id != core_count) {\n\t\t\t\tLOGINFO(\"Error dividing up threads for encryption, %u threads for %u cores!\\n\", enc_thread_id, core_count);\n\t\t\t\tif (enc_thread_id > core_count) {\n\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t} else {\n\t\t\t\t\tLOGINFO(\"Continuining anyway.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Send file count to parent\n\t\t\twrite(progress_pipe_fd, &file_count, sizeof(file_count));\n\t\t\t// Send backup size to parent\n\t\t\ttotal_size = regular_size + encrypt_size;\n\t\t\twrite(progress_pipe_fd, &total_size, sizeof(total_size));\n\n\t\t\tif (userdata_encryption) {\n\t\t\t\t// Create a backup of unencrypted data\n\t\t\t\treg.setfn(tarfn);\n\t\t\t\treg.ItemList = &RegularList;\n\t\t\t\treg.thread_id = 0;\n\t\t\t\treg.use_encryption = 0;\n\t\t\t\treg.use_compression = use_compression;\n\t\t\t\treg.split_archives = 1;\n\t\t\t\treg.progress_pipe_fd = progress_pipe_fd;\n\t\t\t\treg.part_settings = part_settings;\n\t\t\t\tLOGINFO(\"Creating unencrypted backup...\\n\");\n\t\t\t\tif (createList((void*)&reg) != 0) {\n\t\t\t\t\tLOGINFO(\"Error creating unencrypted backup.\\n\");\n\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pthread_attr_init(&tattr)) {\n\t\t\t\tLOGINFO(\"Unable to pthread_attr_init\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\tif (pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_JOINABLE)) {\n\t\t\t\tLOGINFO(\"Error setting pthread_attr_setdetachstate\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\tif (pthread_attr_setscope(&tattr, PTHREAD_SCOPE_SYSTEM)) {\n\t\t\t\tLOGINFO(\"Error setting pthread_attr_setscope\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\t/*if (pthread_attr_setstacksize(&tattr, 524288)) {\n\t\t\t\tLOGERR(\"Error setting pthread_attr_setstacksize\\n\");\n\t\t\t\t_exit(-1);\n\t\t\t}*/\n\n\t\t\t// Create threads for the divided up encryption lists\n\t\t\tfor (i = start_thread_id; i <= core_count; i++) {\n\t\t\t\tenc[i].setdir(tardir);\n\t\t\t\tenc[i].setfn(tarfn);\n\t\t\t\tenc[i].ItemList = &EncryptList;\n\t\t\t\tenc[i].thread_id = i;\n\t\t\t\tenc[i].use_encryption = use_encryption;\n\t\t\t\tenc[i].setpassword(password);\n\t\t\t\tenc[i].use_compression = use_compression;\n\t\t\t\tenc[i].split_archives = 1;\n\t\t\t\tenc[i].progress_pipe_fd = progress_pipe_fd;\n\t\t\t\tenc[i].part_settings = part_settings;\n\t\t\t\tLOGINFO(\"Start encryption thread %i\\n\", i);\n\t\t\t\tret = pthread_create(&enc_thread[i], &tattr, createList, (void*)&enc[i]);\n\t\t\t\tif (ret) {\n\t\t\t\t\tLOGINFO(\"Unable to create %i thread for encryption! %i\\nContinuing in same thread (backup will be slower).\\n\", i, ret);\n\t\t\t\t\tif (createList((void*)&enc[i]) != 0) {\n\t\t\t\t\t\tLOGINFO(\"Error creating encrypted backup %i.\\n\", i);\n\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tenc[i].thread_id = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tusleep(100000); // Need a short delay before starting the next thread or the threads will never finish for some reason.\n\t\t\t}\n\t\t\tif (pthread_attr_destroy(&tattr)) {\n\t\t\t\tLOGINFO(\"Failed to pthread_attr_destroy\\n\");\n\t\t\t}\n\t\t\tfor (i = start_thread_id; i <= core_count; i++) {\n\t\t\t\tif (enc[i].thread_id == i) {\n\t\t\t\t\tif (pthread_join(enc_thread[i], &thread_return)) {\n\t\t\t\t\t\tLOGINFO(\"Error joining thread %i\\n\", i);\n\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGINFO(\"Joined thread %i.\\n\", i);\n\t\t\t\t\t\tret = (int)(intptr_t)thread_return;\n\t\t\t\t\t\tif (ret != 0) {\n\t\t\t\t\t\t\tthread_error = 1;\n\t\t\t\t\t\t\tLOGINFO(\"Thread %i returned an error %i.\\n\", i, ret);\n\t\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLOGINFO(\"Skipping joining thread %i because of pthread failure.\\n\", i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (thread_error) {\n\t\t\t\tLOGINFO(\"Error returned by one or more threads.\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\tLOGINFO(\"Finished encrypted backup.\\n\");\n\t\t\tclose(progress_pipe[1]);\n\t\t\t_exit(0);\n\t\t} else {\n\t\t\t// Not encrypted\n\t\t\tstd::vector<TarListStruct> FileList;\n\t\t\tunsigned thread_id = 0;\n\t\t\tunsigned long long target_size = 0;\n\t\t\ttwrpTar reg;\n\t\t\tint ret;\n\n\t\t\t// Generate list of files to back up\n\t\t\tret = Generate_TarList(tardir, &FileList, &target_size, &thread_id);\n\t\t\tif (ret < 0) {\n\t\t\t\tLOGINFO(\"Error in Generate_TarList!\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\tfile_count = (unsigned long long)(ret);\n\t\t\t// Create a backup\n\t\t\treg.setfn(tarfn);\n\t\t\treg.ItemList = &FileList;\n\t\t\treg.thread_id = 0;\n\t\t\treg.use_encryption = 0;\n\t\t\treg.use_compression = use_compression;\n\t\t\treg.setsize(Total_Backup_Size);\n\t\t\treg.progress_pipe_fd = progress_pipe_fd;\n\t\t\treg.part_settings = part_settings;\n\t\t\tif (Total_Backup_Size > MAX_ARCHIVE_SIZE && !part_settings->adbbackup) {\n\t\t\t\tgui_msg(\"split_backup=Breaking backup file into multiple archives...\");\n\t\t\t\treg.split_archives = 1;\n\t\t\t} else {\n\t\t\t\treg.split_archives = 0;\n\t\t\t}\n\t\t\tLOGINFO(\"Creating backup...\\n\");\n\t\t\twrite(progress_pipe_fd, &file_count, sizeof(file_count));\n\t\t\twrite(progress_pipe_fd, &Total_Backup_Size, sizeof(Total_Backup_Size));\n\t\t\tif (createList((void*)&reg) != 0) {\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(progress_pipe[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t\tclose(progress_pipe[1]);\n\t\t\t_exit(0);\n\t\t}\n\t} else {\n\t\t// Parent side\n\t\tunsigned long long fs, size_backup = 0, files_backup = 0, file_count = 0;\n\t\tint first_data = 0;\n\n\t\t// Parent closes output side\n\t\tclose(progress_pipe[1]);\n\n\t\t// Read progress data from children\n\t\twhile (read(progress_pipe[0], &fs, sizeof(fs)) > 0) {\n\t\t\tif (first_data == 0) {\n\t\t\t\t// First incoming data is the file count\n\t\t\t\tfile_count = fs;\n\t\t\t\tif (file_count == 0) file_count = 1; // prevent division by 0 below\n\t\t\t\tfirst_data = 1;\n\t\t\t} else if (first_data == 1) {\n\t\t\t\t// Second incoming data is total size\n\t\t\t\tfirst_data = 2;\n\t\t\t\tpart_settings->progress->SetSizeCount(fs, file_count);\n\t\t\t} else {\n\t\t\t\tif (fs > 0) {\n\t\t\t\t\tsize_backup += fs;\n\t\t\t\t\tpart_settings->progress->UpdateSize(size_backup);\n\t\t\t\t} else { // fs == 0 increments the file counter\n\t\t\t\t\tfiles_backup++;\n\t\t\t\t\tpart_settings->progress->UpdateSizeCount(size_backup, files_backup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(progress_pipe[0]);\n#ifndef BUILD_TWRPTAR_MAIN\n\t\tDataManager::SetValue(\"tw_file_progress\", \"\");\n\t\tDataManager::SetValue(\"tw_size_progress\", \"\");\n\t\tpart_settings->progress->DisplayFileCount(false);\n\t\tpart_settings->progress->UpdateDisplayDetails(true);\n\n\t\tif (!part_settings->adbbackup) {\n\t\t\tInfoManager backup_info(backup_folder + \"/\" + partition_name + \".info\");\n\t\t\tbackup_info.SetValue(\"backup_size\", size_backup);\n\t\t\tif (use_compression && use_encryption)\n\t\t\t\tbackup_info.SetValue(\"backup_type\", COMPRESSED_ENCRYPTED);\n\t\t\telse if (use_encryption)\n\t\t\t\tbackup_info.SetValue(\"backup_type\", ENCRYPTED);\n\t\t\telse if (use_compression)\n\t\t\t\tbackup_info.SetValue(\"backup_type\", COMPRESSED);\n\t\t\telse\n\t\t\t\tbackup_info.SetValue(\"backup_type\", UNCOMPRESSED);\n\t\t\tbackup_info.SetValue(\"file_count\", files_backup);\n\t\t\tbackup_info.SaveValues();\n\t\t}\n#endif //ndef BUILD_TWRPTAR_MAIN\n\t\tif (TWFunc::Wait_For_Child(*tar_fork_pid, &status, \"createTarFork()\") != 0)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint twrpTar::extractTarFork() {\n\tint status = 0;\n\tpid_t tar_fork_pid;\n\tint progress_pipe[2];\n\n\tif (pipe(progress_pipe) < 0) {\n\t\tLOGINFO(\"Error creating progress tracking pipe\\n\");\n\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\treturn -1;\n\t}\n\n\ttar_fork_pid = fork();\n\tif (tar_fork_pid >= 0) // fork was successful\n\t{\n\t\tif (tar_fork_pid == 0) // child process\n\t\t{\n\t\t\tclose(progress_pipe[0]);\n\t\t\tprogress_pipe_fd = progress_pipe[1];\n\t\t\tif (TWFunc::Path_Exists(tarfn) || part_settings->adbbackup) {\n\t\t\t\tLOGINFO(\"Single archive\\n\");\n\t\t\t\tif (extract() != 0)\n\t\t\t\t\t_exit(-1);\n\t\t\t\telse {\n\t\t\t\t\t_exit(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOGINFO(\"Multiple archives\\n\");\n\t\t\t\tstring temp;\n\t\t\t\tchar actual_filename[255];\n\t\t\t\ttwrpTar tars[9];\n\t\t\t\tpthread_t tar_thread[9];\n\t\t\t\tpthread_attr_t tattr;\n\t\t\t\tunsigned thread_count = 0, i, start_thread_id = 1;\n\t\t\t\tint ret, thread_error = 0;\n\t\t\t\tvoid *thread_return;\n\n\t\t\t\tbasefn = tarfn;\n\t\t\t\ttemp = basefn + \"%i%02i\";\n\t\t\t\ttarfn += \"000\";\n\t\t\t\tif (!TWFunc::Path_Exists(tarfn)) {\n\t\t\t\t\tLOGINFO(\"Unable to locate '%s' or '%s'\\n\", basefn.c_str(), tarfn.c_str());\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t\tif (TWFunc::Get_File_Type(tarfn) != 2) {\n\t\t\t\t\tLOGINFO(\"First tar file '%s' not encrypted\\n\", tarfn.c_str());\n\t\t\t\t\ttars[0].basefn = basefn;\n\t\t\t\t\ttars[0].thread_id = 0;\n\t\t\t\t\ttars[0].progress_pipe_fd = progress_pipe_fd;\n\t\t\t\t\ttars[0].part_settings = part_settings;\n\t\t\t\t\tif (extractMulti((void*)&tars[0]) != 0) {\n\t\t\t\t\t\tLOGINFO(\"Error extracting split archive.\\n\");\n\t\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstart_thread_id = 0;\n\t\t\t\t}\n\t\t\t\t// Start threading encrypted restores\n\t\t\t\tif (pthread_attr_init(&tattr)) {\n\t\t\t\t\tLOGINFO(\"Unable to pthread_attr_init\\n\");\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t\tif (pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_JOINABLE)) {\n\t\t\t\t\tLOGINFO(\"Error setting pthread_attr_setdetachstate\\n\");\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t\tif (pthread_attr_setscope(&tattr, PTHREAD_SCOPE_SYSTEM)) {\n\t\t\t\t\tLOGINFO(\"Error setting pthread_attr_setscope\\n\");\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t\t/*if (pthread_attr_setstacksize(&tattr, 524288)) {\n\t\t\t\t\tLOGERR(\"Error setting pthread_attr_setstacksize\\n\");\n\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}*/\n\t\t\t\tfor (i = start_thread_id; i < 9; i++) {\n\t\t\t\t\tsprintf(actual_filename, temp.c_str(), i, 0);\n\t\t\t\t\tif (TWFunc::Path_Exists(actual_filename)) {\n\t\t\t\t\t\tthread_count++;\n\t\t\t\t\t\ttars[i].basefn = basefn;\n\t\t\t\t\t\ttars[i].setpassword(password);\n\t\t\t\t\t\ttars[i].thread_id = i;\n\t\t\t\t\t\ttars[i].progress_pipe_fd = progress_pipe_fd;\n\t\t\t\t\t\ttars[i].part_settings = part_settings;\n\t\t\t\t\t\tLOGINFO(\"Creating extract thread ID %i\\n\", i);\n\t\t\t\t\t\tret = pthread_create(&tar_thread[i], &tattr, extractMulti, (void*)&tars[i]);\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tLOGINFO(\"Unable to create %i thread for extraction! %i\\nContinuing in same thread (restore will be slower).\\n\", i, ret);\n\t\t\t\t\t\t\tif (extractMulti((void*)&tars[i]) != 0) {\n\t\t\t\t\t\t\t\tLOGINFO(\"Error extracting backup in thread %i.\\n\", i);\n\t\t\t\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttars[i].thread_id = i + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusleep(100000); // Need a short delay before starting the next thread or the threads will never finish for some reason.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = start_thread_id; i < thread_count + start_thread_id; i++) {\n\t\t\t\t\tif (tars[i].thread_id == i) {\n\t\t\t\t\t\tif (pthread_join(tar_thread[i], &thread_return)) {\n\t\t\t\t\t\t\tLOGINFO(\"Error joining thread %i\\n\", i);\n\t\t\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOGINFO(\"Joined thread %i.\\n\", i);\n\t\t\t\t\t\t\tret = (int)(intptr_t)thread_return;\n\t\t\t\t\t\t\tif (ret != 0) {\n\t\t\t\t\t\t\t\tthread_error = 1;\n\t\t\t\t\t\t\t\tLOGINFO(\"Thread %i returned an error %i.\\n\", i, ret);\n\t\t\t\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t\t\t\t_exit(-1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGINFO(\"Skipping joining thread %i because of pthread failure.\\n\", i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (thread_error) {\n\t\t\t\t\tLOGINFO(\"Error returned by one or more threads.\\n\");\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t\tLOGINFO(\"Finished encrypted restore.\\n\");\n\t\t\t\tclose(progress_pipe_fd);\n\t\t\t\t_exit(0);\n\t\t\t}\n\t\t}\n\t\telse // parent process\n\t\t{\n\t\t\tunsigned long long fs, size_backup = 0;\n\n\t\t\t// Parent closes output side\n\t\t\tclose(progress_pipe[1]);\n\n\t\t\t// Read progress data from children\n\t\t\twhile (read(progress_pipe[0], &fs, sizeof(fs)) > 0) {\n\t\t\t\tsize_backup += fs;\n\t\t\t\tpart_settings->progress->UpdateSize(size_backup);\n\t\t\t}\n\t\t\tclose(progress_pipe[0]);\n\t\t\tpart_settings->progress->UpdateDisplayDetails(true);\n\n\t\t\tif (TWFunc::Wait_For_Child(tar_fork_pid, &status, \"extractTarFork()\") != 0)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\telse // fork has failed\n\t{\n\t\tclose(progress_pipe[0]);\n\t\tclose(progress_pipe[1]);\n\t\tLOGINFO(\"extract tar failed to fork.\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint twrpTar::Generate_TarList(string Path, std::vector<TarListStruct> *TarList, unsigned long long *Target_Size, unsigned *thread_id) {\n\tDIR* d;\n\tstruct dirent* de;\n\tstruct stat st;\n\tstring FileName;\n\tstruct TarListStruct TarItem;\n\tint ret, file_count;\n\tfile_count = 0;\n\n\td = opendir(Path.c_str());\n\tif (d == NULL) {\n\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(Path)(strerror(errno)));\n\t\tclosedir(d);\n\t\treturn -1;\n\t}\n\twhile ((de = readdir(d)) != NULL) {\n\t\tFileName = Path + \"/\" + de->d_name;\n\n\t\tif (de->d_type == DT_BLK || de->d_type == DT_CHR || backup_exclusions->check_skip_dirs(FileName))\n\t\t\tcontinue;\n\t\tTarItem.fn = FileName;\n\t\tTarItem.thread_id = *thread_id;\n\t\tif (de->d_type == DT_DIR) {\n\t\t\tTarList->push_back(TarItem);\n\t\t\tret = Generate_TarList(FileName, TarList, Target_Size, thread_id);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -1;\n\t\t\tfile_count += ret;\n\t\t} else if (de->d_type == DT_REG || de->d_type == DT_LNK) {\n\t\t\tstat(FileName.c_str(), &st);\n\t\t\tTarList->push_back(TarItem);\n\t\t\tif (de->d_type == DT_REG) {\n\t\t\t\tfile_count++;\n\t\t\t\tArchive_Current_Size += st.st_size;\n\t\t\t}\n\t\t\tif (Archive_Current_Size != 0 && *Target_Size != 0 && Archive_Current_Size > *Target_Size) {\n\t\t\t\t*thread_id = *thread_id + 1;\n\t\t\t\tArchive_Current_Size = 0;\n\t\t\t}\n\t\t}\n\t}\n\tclosedir(d);\n\treturn file_count;\n}\n\nint twrpTar::extractTar() {\n\tchar* charRootDir = (char*) tardir.c_str();\n\tif (openTar() == -1)\n\t\treturn -1;\n\tif (tar_extract_all(t, charRootDir, &progress_pipe_fd) != 0) {\n\t\tLOGINFO(\"Unable to extract tar archive '%s'\\n\", tarfn.c_str());\n\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\treturn -1;\n\t}\n\tif (tar_close(t) != 0) {\n\t\tLOGINFO(\"Unable to close tar file\\n\");\n\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\treturn -1;\n\t}\n#ifndef BUILD_TWRPTAR_MAIN\n\tif (part_settings->adbbackup) {\n\t\tif (!twadbbu::Write_TWEOF())\n\t\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}\n\nint twrpTar::extract() {\n\tif (!part_settings->adbbackup)  {\n\t\tLOGINFO(\"Setting archive type\\n\");\n\t\tSet_Archive_Type(TWFunc::Get_File_Type(tarfn));\n\t}\n\telse {\n\t\tif (part_settings->adb_compression == 1) \n\t\t\tcurrent_archive_type = COMPRESSED;\n\t\telse\n\t\t\tcurrent_archive_type = UNCOMPRESSED;\n\t}\n\n\tif (current_archive_type == COMPRESSED) {\n\t\t//if you return the extractTGZ function directly, stack crashes happen\n\t\tLOGINFO(\"Extracting gzipped tar\\n\");\n\t\tint ret = extractTar();\n\t\treturn ret;\n\t} else if (current_archive_type == ENCRYPTED) {\n\t\tint ret = TWFunc::Try_Decrypting_File(tarfn, password);\n\t\tif (ret < 1) {\n\t\t\tgui_msg(Msg(msg::kError, \"fail_decrypt_tar=Failed to decrypt tar file '{1}'\")(tarfn));\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 1) {\n\t\t\tLOGINFO(\"Decrypted file is not in tar format.\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 3) {\n\t\t\tLOGINFO(\"Extracting encrypted and compressed tar.\\n\");\n\t\t\tcurrent_archive_type = COMPRESSED_ENCRYPTED;\n\t\t} else\n\t\t\tLOGINFO(\"Extracting encrypted tar.\\n\");\n\t\treturn extractTar();\n\t} else {\n\t\tLOGINFO(\"Extracting uncompressed tar\\n\");\n\t\treturn extractTar();\n\t}\n}\n\nint twrpTar::tarList(std::vector<TarListStruct> *TarList, unsigned thread_id) {\n\tstruct stat st;\n\tchar buf[PATH_MAX];\n\tint list_size = TarList->size(), i = 0, archive_count = 0;\n\tstring temp;\n\tchar actual_filename[PATH_MAX];\n\tunsigned long long fs;\n\n\tif (split_archives) {\n\t\tbasefn = tarfn;\n\t\ttemp = basefn + \"%i%02i\";\n\t\tsprintf(actual_filename, temp.c_str(), thread_id, archive_count);\n\t\ttarfn = actual_filename;\n\t\tinclude_root_dir = true;\n\t} else {\n\t\tinclude_root_dir = false;\n\t}\n\n\tif (part_settings->adbbackup)\n\t    LOGINFO(\"Writing tar file '%s' to adb backup\\n\", tarfn.c_str());\n\telse\n\t    LOGINFO(\"Creating tar file '%s'\\n\", tarfn.c_str());\n\n\tif (createTar() != 0) {\n\t\tLOGINFO(\"Error creating tar '%s' for thread %i\\n\", tarfn.c_str(), thread_id);\n\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\treturn -2;\n\t}\n\tArchive_Current_Size = 0;\n\n\twhile (i < list_size) {\n\t\tif (TarList->at(i).thread_id == thread_id) {\n\t\t\tstrcpy(buf, TarList->at(i).fn.c_str());\n\t\t\tlstat(buf, &st);\n\t\t\tif (S_ISREG(st.st_mode)) { // item is a regular file\n\t\t\t\tfs = (unsigned long long)(st.st_size);\n\t\t\t\tif (split_archives && Archive_Current_Size + fs > MAX_ARCHIVE_SIZE) {\n\t\t\t\t\tif (closeTar() != 0) {\n\t\t\t\t\t\tLOGINFO(\"Error closing '%s' on thread %i\\n\", tarfn.c_str(), thread_id);\n\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\treturn -3;\n\t\t\t\t\t}\n\t\t\t\t\tarchive_count++;\n\t\t\t\t\tgui_msg(Msg(\"split_thread=Splitting thread ID {1} into archive {2}\")(thread_id)(archive_count + 1));\n\t\t\t\t\tif (archive_count > 99) {\n\t\t\t\t\t\tLOGINFO(\"Too many archives for thread %i\\n\", thread_id);\n\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\treturn -4;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(actual_filename, temp.c_str(), thread_id, archive_count);\n\t\t\t\t\ttarfn = actual_filename;\n\t\t\t\t\tif (createTar() != 0) {\n\t\t\t\t\t\tLOGINFO(\"Error creating tar '%s' for thread %i\\n\", tarfn.c_str(), thread_id);\n\t\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\t\treturn -2;\n\t\t\t\t\t}\n\t\t\t\t\tArchive_Current_Size = 0;\n\t\t\t\t}\n\t\t\t\tArchive_Current_Size += fs;\n\t\t\t\tfs = 0; // Sending a 0 size to the pipe tells it to increment the file counter\n\t\t\t\twrite(progress_pipe_fd, &fs, sizeof(fs));\n\t\t\t}\n\t\t\tLOGINFO(\"addFile '%s' including root: %i\\n\", buf, include_root_dir);\n\t\t\tif (addFile(buf, include_root_dir) != 0) {\n\t\t\t\tLOGINFO(\"Error adding file '%s' to '%s'\\n\", buf, tarfn.c_str());\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif (closeTar() != 0) {\n\t\tLOGINFO(\"Error closing '%s' on thread %i\\n\", tarfn.c_str(), thread_id);\n\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\treturn -3;\n\t}\n\tLOGINFO(\"Thread id %i tarList done, %i archives.\\n\", thread_id, archive_count);\n\treturn 0;\n}\n\nvoid* twrpTar::createList(void *cookie) {\n\ttwrpTar* threadTar = (twrpTar*) cookie;\n\tif (threadTar->tarList(threadTar->ItemList, threadTar->thread_id) != 0) {\n\t\tLOGINFO(\"ERROR tarList for thread ID %i\\n\", threadTar->thread_id);\n\t\treturn (void*)-2;\n\t}\n\tLOGINFO(\"Thread ID %i finished successfully.\\n\", threadTar->thread_id);\n\treturn (void*)0;\n}\n\nvoid* twrpTar::extractMulti(void *cookie) {\n\ttwrpTar* threadTar = (twrpTar*) cookie;\n\tint archive_count = 0;\n\tstring temp = threadTar->basefn + \"%i%02i\";\n\tchar actual_filename[255];\n\tsprintf(actual_filename, temp.c_str(), threadTar->thread_id, archive_count);\n\twhile (TWFunc::Path_Exists(actual_filename)) {\n\t\tthreadTar->tarfn = actual_filename;\n\t\tif (threadTar->extract() != 0) {\n\t\t\tLOGINFO(\"Error extracting '%s' in thread ID %i\\n\", actual_filename, threadTar->thread_id);\n\t\t\treturn (void*)-2;\n\t\t}\n\t\tarchive_count++;\n\t\tif (archive_count > 99)\n\t\t\tbreak;\n\t\tsprintf(actual_filename, temp.c_str(), threadTar->thread_id, archive_count);\n\t}\n\tLOGINFO(\"Thread ID %i finished successfully.\\n\", threadTar->thread_id);\n\treturn (void*)0;\n}\n\nint twrpTar::addFilesToExistingTar(vector <string> files, string fn) {\n\tchar* charTarFile = (char*) fn.c_str();\n\n\tif (tar_open(&t, charTarFile, NULL, O_RDONLY | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) == -1)\n\t\treturn -1;\n\tremoveEOT(charTarFile);\n\tif (tar_open(&t, charTarFile, NULL, O_WRONLY | O_APPEND | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) == -1)\n\t\treturn -1;\n\tfor (unsigned int i = 0; i < files.size(); ++i) {\n\t\tchar* file = (char*) files.at(i).c_str();\n\t\tif (tar_append_file(t, file, file) == -1)\n\t\t\treturn -1;\n\t}\n\tif (tar_append_eof(t) == -1)\n\t\treturn -1;\n\tif (tar_close(t) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nint twrpTar::createTar() {\n\tchar* charTarFile = (char*) tarfn.c_str();\n\tchar* charRootDir = (char*) tardir.c_str();\n\n\tif (use_encryption && use_compression) {\n\t\t// Compressed and encrypted\n\t\tcurrent_archive_type = COMPRESSED_ENCRYPTED;\n\t\tLOGINFO(\"Using encryption and compression...\\n\");\n\t\tint i, pipes[4];\n\n\t\tif (pipe(pipes) < 0) {\n\t\t\tLOGINFO(\"Error creating first pipe\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (pipe(pipes + 2) < 0) {\n\t\t\tLOGINFO(\"Error creating second pipe\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\treturn -1;\n\t\t}\n\t\toutput_fd = open(tarfn.c_str(), O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (output_fd < 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tarfn)(strerror(errno)));\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tclose(pipes[i]); // close all\n\t\t\treturn -1;\n\t\t}\n\t\tpigz_pid = fork();\n\n\t\tif (pigz_pid < 0) {\n\t\t\tLOGINFO(\"pigz fork() failed\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\tclose(output_fd);\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tclose(pipes[i]); // close all\n\t\t\treturn -1;\n\t\t} else if (pigz_pid == 0) {\n\t\t\t// pigz Child\n\t\t\tclose(pipes[1]);\n\t\t\tclose(pipes[2]);\n\t\t\tint stdinfd = fileno(stdin);\n\t\t\tint stdoutfd = fileno(stdout);\n\t\t\tclose(stdinfd);\n\t\t\tdup2(pipes[0], stdinfd);\n\t\t\tclose(stdoutfd);\n\t\t\tdup2(pipes[3], stdoutfd);\n\t\t\tif (execlp(\"pigz\", \"pigz\", \"-\", NULL) < 0) {\n\t\t\t\tLOGINFO(\"execlp pigz ERROR!\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(output_fd);\n\t\t\t\tclose(pipes[0]);\n\t\t\t\tclose(pipes[3]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent\n\t\t\toaes_pid = fork();\n\n\t\t\tif (oaes_pid < 0) {\n\t\t\t\tLOGINFO(\"openaes fork() failed\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(output_fd);\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tclose(pipes[i]); // close all\n\t\t\t\treturn -1;\n\t\t\t} else if (oaes_pid == 0) {\n\t\t\t\t// openaes Child\n\t\t\t\tclose(pipes[0]);\n\t\t\t\tclose(pipes[1]);\n\t\t\t\tclose(pipes[3]);\n\t\t\t\tint stdinfd = fileno(stdin);\n\t\t\t\tint stdoutfd = fileno(stdout);\n\t\t\t\tclose(stdinfd);\n\t\t\t\tdup2(pipes[2], stdinfd);\n\t\t\t\tclose(stdoutfd);\n\t\t\t\tdup2(output_fd, stdoutfd);\n\t\t\t\tif (execlp(\"openaes\", \"openaes\", \"enc\", \"--key\", password.c_str(), NULL) < 0) {\n\t\t\t\t\tLOGINFO(\"execlp openaes ERROR!\\n\");\n\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\tclose(pipes[2]);\n\t\t\t\t\tclose(output_fd);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Parent\n\t\t\t\tclose(pipes[0]);\n\t\t\t\tclose(pipes[2]);\n\t\t\t\tclose(pipes[3]);\n\t\t\t\tfd = pipes[1];\n\t\t\t\tinit_libtar_no_buffer(progress_pipe_fd);\n\t\t\t\ttar_type.writefunc = write_tar_no_buffer;\n\t\t\t\tif (tar_fdopen(&t, fd, charRootDir, &tar_type, O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t\tLOGINFO(\"tar_fdopen failed\\n\");\n\t\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else if (use_compression) {\n\t\t// Compressed\n\t\tcurrent_archive_type = COMPRESSED;\n\t\tLOGINFO(\"Using compression...\\n\");\n\t\tint pigzfd[2];\n\t\tif (part_settings->adbbackup) {\n\t\t\tLOGINFO(\"opening TW_ADB_BACKUP compressed stream\\n\");\n\t\t\toutput_fd = open(TW_ADB_BACKUP, O_WRONLY);\n\t\t}\n\t\telse {\n\t\t\toutput_fd = open(tarfn.c_str(), O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\t}\n\t\tif (output_fd < 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tarfn)(strerror(errno)));\n\t\t\tclose(pigzfd[0]);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pipe(pigzfd) < 0) {\n\t\t\tLOGINFO(\"Error creating pipe\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\tclose(output_fd);\n\t\t\treturn -1;\n\t\t}\n\t\tpigz_pid = fork();\n\n\t\tif (pigz_pid < 0) {\n\t\t\tLOGINFO(\"fork() failed\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\tclose(output_fd);\n\t\t\tclose(pigzfd[0]);\n\t\t\tclose(pigzfd[1]);\n\t\t\treturn -1;\n\t\t} else if (pigz_pid == 0) {\n\t\t\t// Child\n\t\t\tclose(pigzfd[1]);   // close unused output pipe\n\t\t\tdup2(pigzfd[0], fileno(stdin)); // remap stdin\n\t\t\tdup2(output_fd, fileno(stdout)); // remap stdout to output file\n\t\t\tif (execlp(\"pigz\", \"pigz\", \"-\", NULL) < 0) {\n\t\t\t\tLOGINFO(\"execlp pigz ERROR!\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(output_fd);\n\t\t\t\tclose(pigzfd[0]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent\n\t\t\tclose(pigzfd[0]); // close parent input\n\t\t\tfd = pigzfd[1];   // copy parent output\n\t\t\tinit_libtar_no_buffer(progress_pipe_fd);\n\t\t\ttar_type.writefunc = write_tar_no_buffer;\n\t\t\tif (tar_fdopen(&t, fd, charRootDir, &tar_type, O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tclose(fd);\n\t\t\t\tLOGINFO(\"tar_fdopen failed\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (use_encryption) {\n\t\t// Encrypted\n\t\tcurrent_archive_type = ENCRYPTED;\n\t\tLOGINFO(\"Using encryption...\\n\");\n\t\tint oaesfd[2];\n\t\toutput_fd = open(tarfn.c_str(), O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (output_fd < 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tarfn)(strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t\tif (pipe(oaesfd) < 0) {\n\t\t\tLOGINFO(\"Error creating pipe\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\tclose(output_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toaes_pid = fork();\n\n\t\tif (oaes_pid < 0) {\n\t\t\tLOGINFO(\"fork() failed\\n\");\n\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\tclose(output_fd);\n\t\t\tclose(oaesfd[0]);\n\t\t\tclose(oaesfd[1]);\n\t\t\treturn -1;\n\t\t} else if (oaes_pid == 0) {\n\t\t\t// Child\n\t\t\tclose(oaesfd[1]);   // close unused\n\t\t\tdup2(oaesfd[0], fileno(stdin)); // remap stdin\n\t\t\tdup2(output_fd, fileno(stdout)); // remap stdout to output file\n\t\t\tif (execlp(\"openaes\", \"openaes\", \"enc\", \"--key\", password.c_str(), NULL) < 0) {\n\t\t\t\tLOGINFO(\"execlp openaes ERROR!\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\tclose(output_fd);\n\t\t\t\tclose(oaesfd[0]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent\n\t\t\tclose(oaesfd[0]); // close parent input\n\t\t\tfd = oaesfd[1];   // copy parent output\n\t\t\tinit_libtar_no_buffer(progress_pipe_fd);\n\t\t\ttar_type.writefunc = write_tar_no_buffer;\n\t\t\tif (tar_fdopen(&t, fd, charRootDir, &tar_type, O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tclose(fd);\n\t\t\t\tLOGINFO(\"tar_fdopen failed\\n\");\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t// Not compressed or encrypted\n\t\tcurrent_archive_type = UNCOMPRESSED;\n\t\tinit_libtar_buffer(0, progress_pipe_fd);\n\t\tif (part_settings->adbbackup) {\n\t\t\tLOGINFO(\"Opening TW_ADB_BACKUP uncompressed stream\\n\");\n\t\t\ttar_type.writefunc = write_tar_no_buffer;\n\t\t\toutput_fd = open(TW_ADB_BACKUP, O_WRONLY);\n\t\t\tif(tar_fdopen(&t, output_fd, charRootDir, &tar_type, O_WRONLY | O_CREAT | O_EXCL | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tclose(output_fd);\n\t\t\t\tLOGERR(\"tar_fdopen failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttar_type.writefunc = write_tar;\n\t\t\tif (tar_open(&t, charTarFile, &tar_type, O_WRONLY | O_CREAT | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) == -1) {\n\t\t\t\tLOGERR(\"tar_open error opening '%s'\\n\", tarfn.c_str());\n\t\t\t\tgui_err(\"backup_error=Error creating backup.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint twrpTar::openTar() {\n\tchar* charRootDir = (char*) tardir.c_str();\n\tchar* charTarFile = (char*) tarfn.c_str();\n\tstring Password;\n\n\tif (current_archive_type == COMPRESSED_ENCRYPTED) {\n\t\tLOGINFO(\"Opening encrypted and compressed backup...\\n\");\n\t\tint i, pipes[4];\n\t\tinput_fd = open(tarfn.c_str(), O_RDONLY | O_LARGEFILE);\n\t\tif (input_fd < 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tarfn)(strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pipe(pipes) < 0) {\n\t\t\tLOGINFO(\"Error creating first pipe\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(input_fd);\n\t\t\treturn -1;\n\t\t}\n\t\tif (pipe(pipes + 2) < 0) {\n\t\t\tLOGINFO(\"Error creating second pipe\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(pipes[0]);\n\t\t\tclose(pipes[1]);\n\t\t\tclose(input_fd);\n\t\t\treturn -1;\n\t\t}\n\t\toaes_pid = fork();\n\n\t\tif (oaes_pid < 0) {\n\t\t\tLOGINFO(\"pigz fork() failed\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(input_fd);\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tclose(pipes[i]); // close all\n\t\t\treturn -1;\n\t\t} else if (oaes_pid == 0) {\n\t\t\t// openaes Child\n\t\t\tclose(pipes[0]); // Close pipes that are not used by this child\n\t\t\tclose(pipes[2]);\n\t\t\tclose(pipes[3]);\n\t\t\tint stdinfd = fileno(stdin);\n\t\t\tint stdoutfd = fileno(stdout);\n\t\t\tclose(stdinfd);\n\t\t\tdup2(input_fd, stdinfd);\n\t\t\tclose(stdoutfd);\n\t\t\tdup2(pipes[1], stdoutfd);\n\t\t\tif (execlp(\"openaes\", \"openaes\", \"dec\", \"--key\", password.c_str(), NULL) < 0) {\n\t\t\t\tLOGINFO(\"execlp openaes ERROR!\\n\");\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\tclose(input_fd);\n\t\t\t\tclose(pipes[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent\n\t\t\tpigz_pid = fork();\n\n\t\t\tif (pigz_pid < 0) {\n\t\t\t\tLOGINFO(\"openaes fork() failed\\n\");\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\tclose(input_fd);\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tclose(pipes[i]); // close all\n\t\t\t\treturn -1;\n\t\t\t} else if (pigz_pid == 0) {\n\t\t\t\t// pigz Child\n\t\t\t\tclose(pipes[1]); // Close pipes not used by this child\n\t\t\t\tclose(pipes[2]);\n\t\t\t\tint stdinfd = fileno(stdin);\n\t\t\t\tint stdoutfd = fileno(stdout);\n\t\t\t\tclose(stdinfd);\n\t\t\t\tdup2(pipes[0], stdinfd);\n\t\t\t\tclose(stdoutfd);\n\t\t\t\tdup2(pipes[3], stdoutfd);\n\t\t\t\tif (execlp(\"pigz\", \"pigz\", \"-d\", \"-c\", NULL) < 0) {\n\t\t\t\t\tLOGINFO(\"execlp pigz ERROR!\\n\");\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\tclose(input_fd);\n\t\t\t\t\tclose(pipes[0]);\n\t\t\t\t\tclose(pipes[3]);\n\t\t\t\t\t_exit(-1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Parent\n\t\t\t\tclose(pipes[0]); // Close pipes not used by parent\n\t\t\t\tclose(pipes[1]);\n\t\t\t\tclose(pipes[3]);\n\t\t\t\tfd = pipes[2];\n\t\t\t\tif (tar_fdopen(&t, fd, charRootDir, NULL, O_RDONLY | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\t\tclose(fd);\n\t\t\t\t\tLOGINFO(\"tar_fdopen failed\\n\");\n\t\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (current_archive_type == ENCRYPTED) {\n\t\tLOGINFO(\"Opening encrypted backup...\\n\");\n\t\tint oaesfd[2];\n\t\tinput_fd = open(tarfn.c_str(), O_RDONLY | O_LARGEFILE);\n\t\tif (input_fd < 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tarfn)(strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pipe(oaesfd) < 0) {\n\t\t\tLOGINFO(\"Error creating pipe\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(input_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\toaes_pid = fork();\n\t\tif (oaes_pid < 0) {\n\t\t\tLOGINFO(\"fork() failed\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(input_fd);\n\t\t\tclose(oaesfd[0]);\n\t\t\tclose(oaesfd[1]);\n\t\t\treturn -1;\n\t\t} else if (oaes_pid == 0) {\n\t\t\t// Child\n\t\t\tclose(oaesfd[0]); // Close unused pipe\n\t\t\tint stdinfd = fileno(stdin);\n\t\t\tclose(stdinfd);   // close stdin\n\t\t\tdup2(oaesfd[1], fileno(stdout)); // remap stdout\n\t\t\tdup2(input_fd, stdinfd); // remap input fd to stdin\n\t\t\tif (execlp(\"openaes\", \"openaes\", \"dec\", \"--key\", password.c_str(), NULL) < 0) {\n\t\t\t\tLOGINFO(\"execlp openaes ERROR!\\n\");\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\tclose(input_fd);\n\t\t\t\tclose(oaesfd[1]);\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent\n\t\t\tclose(oaesfd[1]); // close parent output\n\t\t\tfd = oaesfd[0];   // copy parent input\n\t\t\tif (tar_fdopen(&t, fd, charRootDir, NULL, O_RDONLY | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tclose(fd);\n\t\t\t\tLOGINFO(\"tar_fdopen failed\\n\");\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else if (current_archive_type == COMPRESSED) {\n\t\tint pigzfd[2];\n\n\t\tLOGINFO(\"Opening gzip compressed tar...\\n\");\n\t\tif (part_settings->adbbackup)  {\n\t\t\tLOGINFO(\"opening TW_ADB_RESTORE compressed stream\\n\");\n\t\t\tinput_fd = open(TW_ADB_RESTORE, O_RDONLY | O_LARGEFILE);\n\t\t}\n\t\telse\n\t\t\tinput_fd = open(tarfn.c_str(), O_RDONLY | O_LARGEFILE);\n\n\t\tif (input_fd < 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"error_opening_strerr=Error opening: '{1}' ({2})\")(tarfn)(strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pipe(pigzfd) < 0) {\n\t\t\tLOGINFO(\"Error creating pipe\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(input_fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpigz_pid = fork();\n\t\tif (pigz_pid < 0) {\n\t\t\tLOGINFO(\"fork() failed\\n\");\n\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\tclose(input_fd);\n\t\t\tclose(pigzfd[0]);\n\t\t\tclose(pigzfd[1]);\n\t\t\treturn -1;\n\t\t} else if (pigz_pid == 0) {\n\t\t\t// Child\n\t\t\tclose(pigzfd[0]);\n\t\t\tdup2(pigzfd[1], fileno(stdout)); // remap stdout\n\t\t\tdup2(input_fd, fileno(stdin)); // remap input fd to stdin\n\t\t\tif (execlp(\"pigz\", \"pigz\", \"-d\", \"-c\", NULL) < 0) {\n\t\t\t\tclose(pigzfd[1]);\n\t\t\t\tclose(input_fd);\n\t\t\t\tLOGINFO(\"execlp openaes ERROR!\\n\");\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\t_exit(-1);\n\t\t\t}\n\t\t} else {\n\t\t\t// Parent\n\t\t\tclose(pigzfd[1]); // close parent output\n\t\t\tfd = pigzfd[0];   // copy parent input\n\t\t\tif (tar_fdopen(&t, fd, charRootDir, NULL, O_RDONLY | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tclose(fd);\n\t\t\t\tLOGINFO(\"tar_fdopen failed\\n\");\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else  {\n\t\tif (part_settings->adbbackup) {\n\t\t\tLOGINFO(\"Opening TW_ADB_RESTORE uncompressed stream\\n\");\n\t\t\tinput_fd = open(TW_ADB_RESTORE, O_RDONLY);\n\t\t\tif (tar_fdopen(&t, input_fd, charRootDir, NULL, O_RDONLY | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tLOGERR(\"Unable to open tar archive '%s'\\n\", charTarFile);\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (tar_open(&t, charTarFile, NULL, O_RDONLY | O_LARGEFILE, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, TWTAR_FLAGS) != 0) {\n\t\t\t\tLOGERR(\"Unable to open tar archive '%s'\\n\", charTarFile);\n\t\t\t\tgui_err(\"restore_error=Error during restore process.\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstring twrpTar::Strip_Root_Dir(string Path) {\n\tstring temp;\n\tsize_t slash;\n\n\tif (Path.substr(0, 1) == \"/\")\n\t\ttemp = Path.substr(1, Path.size() - 1);\n\telse\n\t\ttemp = Path;\n\tslash = temp.find(\"/\");\n\tif (slash == string::npos)\n\t\treturn temp;\n\telse {\n\t\tstring stripped;\n\n\t\tstripped = temp.substr(slash, temp.size() - slash);\n\t\treturn stripped;\n\t}\n\treturn temp;\n}\n\nint twrpTar::addFile(string fn, bool include_root) {\n\tchar* charTarFile = (char*) fn.c_str();\n\tif (include_root) {\n\t\tif (tar_append_file(t, charTarFile, NULL) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tstring temp = Strip_Root_Dir(fn);\n\t\tchar* charTarPath = (char*) temp.c_str();\n\t\tif (tar_append_file(t, charTarFile, charTarPath) == -1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint twrpTar::closeTar() {\n\tLOGINFO(\"Closing tar\\n\");\n\tflush_libtar_buffer(t->fd);\n\tif (tar_append_eof(t) != 0) {\n\t\tLOGINFO(\"tar_append_eof(): %s\\n\", strerror(errno));\n\t\ttar_close(t);\n\t\treturn -1;\n\t}\n\tif (tar_close(t) != 0) {\n\t\tLOGINFO(\"Unable to close tar archive: '%s'\\n\", tarfn.c_str());\n\t\treturn -1;\n\t}\n\tif (current_archive_type > 0) {\n\t\tclose(fd);\n\t\tint status;\n\t\tif (pigz_pid > 0 && TWFunc::Wait_For_Child(pigz_pid, &status, \"pigz\") != 0)\n\t\t\treturn -1;\n\t\tif (oaes_pid > 0 && TWFunc::Wait_For_Child(oaes_pid, &status, \"openaes\") != 0)\n\t\t\treturn -1;\n\t}\n\tfree_libtar_buffer();\n\tif (!part_settings->adbbackup) {\n\t\tif (use_compression && !use_encryption) {\n\t\t\tstring gzname = tarfn + \".gz\";\n\t\t\tif (TWFunc::Path_Exists(gzname)) {\n\t\t\t\trename(gzname.c_str(), tarfn.c_str());\n\t\t\t}\n\t\t}\n\t\tif (TWFunc::Get_File_Size(tarfn) == 0) {\n\t\t\tgui_msg(Msg(msg::kError, \"backup_size=Backup file size for '{1}' is 0 bytes.\")(tarfn));\n\t\t\treturn -1;\n\t\t}\n#ifndef BUILD_TWRPTAR_MAIN\n\t\ttw_set_default_metadata(tarfn.c_str());\n#endif\n\t}\n\telse {\n#ifndef BUILD_TWRPTAR_MAIN\n\t\tif (!twadbbu::Write_TWEOF())\n\t\t\treturn -1;\n#endif\n\t}\n\tif (input_fd >= 0)\n\t\tclose(input_fd);\n\tif (output_fd >= 0)\n\t\tclose(output_fd);\n\treturn 0;\n}\n\nint twrpTar::removeEOT(string tarFile) {\n\tchar* charTarFile = (char*) tarFile.c_str();\n\toff_t tarFileEnd = 0;\n\twhile (th_read(t) == 0) {\n\t\tif (TH_ISREG(t))\n\t\t\ttar_skip_regfile(t);\n\t\ttarFileEnd = lseek(t->fd, 0, SEEK_CUR);\n\t}\n\tif (tar_close(t) == -1)\n\t\treturn -1;\n\tif (tarFileEnd > 0 && truncate(charTarFile, tarFileEnd) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nint twrpTar::entryExists(string entry) {\n\tchar* searchstr = (char*)entry.c_str();\n\tint ret;\n\n\tSet_Archive_Type(TWFunc::Get_File_Type(tarfn));\n\n\tif (openTar() == -1)\n\t\tret = 0;\n\telse\n\t\tret = tar_find(t, searchstr);\n\n\tif (closeTar() != 0)\n\t\tLOGINFO(\"Unable to close tar after searching for entry.\\n\");\n\n\treturn ret;\n}\n\nunsigned long long twrpTar::get_size() {\n\tif (part_settings->adbbackup || TWFunc::Path_Exists(tarfn)) {\n\t\tLOGINFO(\"Single archive\\n\");\n\t\treturn uncompressedSize(tarfn);\n\t} else {\n\t\tLOGINFO(\"Multiple archives\\n\");\n\t\tstring temp;\n\t\tchar actual_filename[255];\n\t\tint archive_count = 0;\n\t\tunsigned long long total_restore_size = 0;\n\n\t\tbasefn = tarfn;\n\t\ttemp = basefn + \"%i%02i\";\n\t\ttarfn += \"000\";\n\t\tthread_id = 0;\n\t\tsprintf(actual_filename, temp.c_str(), thread_id, archive_count);\n\t\tif (!part_settings->adbbackup) {\n\t\t\tif (!TWFunc::Path_Exists(actual_filename)) {\n\t\t\t\tLOGERR(\"Unable to locate '%s' or '%s'\\n\", basefn.c_str(), tarfn.c_str());\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 9; i++) {\n\t\t\t\tarchive_count = 0;\n\t\t\t\tsprintf(actual_filename, temp.c_str(), i, archive_count);\n\t\t\t\twhile (TWFunc::Path_Exists(actual_filename)) {\n\t\t\t\t\ttotal_restore_size += uncompressedSize(actual_filename);\n\t\t\t\t\tarchive_count++;\n\t\t\t\t\tif (archive_count > 99)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tsprintf(actual_filename, temp.c_str(), i, archive_count);\n\t\t\t\t}\n\t\t\t}\n\t#ifndef BUILD_TWRPTAR_MAIN\n\t        if (!part_settings->adbbackup) {\n\t\t\tInfoManager backup_info(tarfn + \".info\");\n\t\t\tbackup_info.SetValue(\"backup_size\", total_restore_size);\n\t\t\tbackup_info.SetValue(\"backup_type\", current_archive_type);\n\t\t\tbackup_info.SaveValues();\n\t        }\n\t#endif //ndef BUILD_TWRPTAR_MAIN\n\t\t}\n\t\treturn total_restore_size;\n\t}\n\treturn 0;\n}\n\nunsigned long long twrpTar::uncompressedSize(string filename) {\n\tunsigned long long total_size = 0;\n\tstring Tar, Command, result;\n\tvector<string> split;\n\n\tSet_Archive_Type(TWFunc::Get_File_Type(tarfn));\n\tif (current_archive_type == UNCOMPRESSED) {\n\t\ttotal_size = TWFunc::Get_File_Size(filename);\n\t} else if (current_archive_type == COMPRESSED) {\n\t\t// Compressed\n\t\tCommand = \"pigz -l '\" + filename + \"'\";\n\t\t/* if we set Command = \"pigz -l \" + tarfn + \" | sed '1d' | cut -f5 -d' '\";\n\t\twe get the uncompressed size at once. */\n\t\tTWFunc::Exec_Cmd(Command, result);\n\t\tif (!result.empty()) {\n\t\t\t/* Expected output:\n\t\t\tcompressed original  reduced name\n\t\t\t95855838   179403776 -1.3%   data.yaffs2.win\n\t\t\t^\n\t\t\tsplit[5]\n\t\t\t*/\n\t\t\tsplit = TWFunc::split_string(result, ' ', true);\n\t\t\tif (split.size() > 4)\n\t\t\t\ttotal_size = atoi(split[5].c_str());\n\t\t}\n\t} else if (current_archive_type == COMPRESSED_ENCRYPTED) {\n\t\t// File is encrypted and may be compressed\n\t\tint ret = TWFunc::Try_Decrypting_File(filename, password);\n\t\tif (ret < 1) {\n\t\t\tgui_msg(Msg(msg::kError, \"fail_decrypt_tar=Failed to decrypt tar file '{1}'\")(tarfn));\n\t\t\ttotal_size = TWFunc::Get_File_Size(filename);\n\t\t} else if (ret == 1) {\n\t\t\tLOGERR(\"Decrypted file is not in tar format.\\n\");\n\t\t\ttotal_size = TWFunc::Get_File_Size(filename);\n\t\t} else if (ret == 3) {\n\t\t\tCommand = \"openaes dec --key \\\"\" + password + \"\\\" --in '\" + filename + \"' | pigz -l\";\n\t\t\t/* if we set Command = \"pigz -l \" + tarfn + \" | sed '1d' | cut -f5 -d' '\";\n\t\t\twe get the uncompressed size at once. */\n\t\t\tTWFunc::Exec_Cmd(Command, result);\n\t\t\tif (!result.empty()) {\n\t\t\t\tLOGINFO(\"result was: '%s'\\n\", result.c_str());\n\t\t\t\t/* Expected output:\n\t\t\t\tcompressed original  reduced name\n\t\t\t\t95855838   179403776 -1.3%   data.yaffs2.win\n\t\t\t\t^\n\t\t\t\tsplit[5]\n\t\t\t\t*/\n\t\t\t\tsplit = TWFunc::split_string(result, ' ', true);\n\t\t\t\tif (split.size() > 4)\n\t\t\t\t\ttotal_size = atoi(split[5].c_str());\n\t\t\t}\n\t\t} else {\n\t\t\ttotal_size = TWFunc::Get_File_Size(filename);\n\t\t}\n\t}\n\n\treturn total_size;\n}\n\nextern \"C\" ssize_t write_tar(int fd, const void *buffer, size_t size) {\n\treturn (ssize_t) write_libtar_buffer(fd, buffer, size);\n}\n\nextern \"C\" ssize_t write_tar_no_buffer(int fd, const void *buffer, size_t size) {\n\treturn (ssize_t) write_libtar_no_buffer(fd, buffer, size);\n}\n"
        },
        {
          "name": "twrpTar.h",
          "type": "blob",
          "size": 0.88671875,
          "content": "/*\n\tCopyright 2012 bigbiff/Dees_Troy TeamWin\n\tThis file is part of TWRP/TeamWin Recovery Project.\n\n\tTWRP is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTWRP is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _TWRPTAR_HEADER\n#define _TWRPTAR_HEADER\n\nssize_t write_tar(int fd, const void *buffer, size_t size);\nssize_t write_tar_no_buffer(int fd, const void *buffer, size_t size);\n\n#endif  // _TWRPTAR_HEADER\n"
        },
        {
          "name": "twrpTar.hpp",
          "type": "blob",
          "size": 3.1962890625,
          "content": "/*\n        Copyright 2012 to 2016 bigbiff/Dees_Troy TeamWin\n        This file is part of TWRP/TeamWin Recovery Project.\n\n        TWRP is free software: you can redistribute it and/or modify\n        it under the terms of the GNU General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version.\n\n        TWRP is distributed in the hope that it will be useful,\n        but WITHOUT ANY WARRANTY; without even the implied warranty of\n        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n        GNU General Public License for more details.\n\n        You should have received a copy of the GNU General Public License\n        along with TWRP.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nextern \"C\" {\n\t#include \"libtar/libtar.h\"\n}\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <fstream>\n#include <string>\n#include <vector>\n#include \"exclude.hpp\"\n#include \"progresstracking.hpp\"\n#include \"partitions.hpp\"\n#include \"twrp-functions.hpp\"\n\nusing namespace std;\n\nstruct TarListStruct {\n\tstd::string fn;\n\tunsigned thread_id;\n};\n\nstruct thread_data_struct {\n\tstd::vector<TarListStruct> *TarList;\n\tunsigned thread_id;\n};\n\nclass twrpTar {\npublic:\n\ttwrpTar();\n\tvirtual ~twrpTar();\n\tint createTarFork(pid_t *tar_fork_pid);\n\tint extractTarFork();\n\tvoid setfn(string fn);\n\tvoid setdir(string dir);\n\tvoid setsize(unsigned long long backup_size);\n\tvoid setpassword(string pass);\n\tunsigned long long get_size();\n\tvoid Set_Archive_Type(Archive_Type archive_type);\n\npublic:\n\tint use_encryption;\n\tint userdata_encryption;\n\tint use_compression;\n\tint split_archives;\n\tstring backup_name;\n\tint progress_pipe_fd;\n\tstring partition_name;\n\tstring backup_folder;\n\tPartitionSettings *part_settings;\n\tTWExclude *backup_exclusions;\n\nprivate:\n\tint extract();\n\tint addFilesToExistingTar(vector <string> files, string tarFile);\n\tint createTar();\n\tint addFile(string fn, bool include_root);\n\tint entryExists(string entry);\n\tint closeTar();\n\tint removeEOT(string tarFile);\n\tint extractTar();\n\tstring Strip_Root_Dir(string Path);\n\tint openTar();\n\tint Generate_TarList(string Path, std::vector<TarListStruct> *TarList, unsigned long long *Target_Size, unsigned *thread_id);\n\tstatic void* createList(void *cookie);\n\tstatic void* extractMulti(void *cookie);\n\tint tarList(std::vector<TarListStruct> *TarList, unsigned thread_id);\n\tunsigned long long uncompressedSize(string filename);\n\tstatic void Signal_Kill(int signum);\n\n\tenum Archive_Type current_archive_type;\n\tunsigned long long Archive_Current_Size;\n\tunsigned long long Total_Backup_Size;\n\tbool include_root_dir;\n\tTAR *t;\n\ttartype_t tar_type; // Only used in createTar() but variable must persist while the tar is open\n\tint fd;\n\tint input_fd;                                                                   // this stores the fd for libtar to write to\n\tpid_t pigz_pid;\n\tpid_t oaes_pid;\n\tunsigned long long file_count;\n\n\tstring tardir;\n\tstring tarfn;\n\tstring basefn;\n\tstring password;\n\n\tstd::vector<TarListStruct> *ItemList;\n\tint output_fd;                                                                  // this stores the output fd that gzip will read from\n\tunsigned thread_id;\n};\n"
        },
        {
          "name": "twrpTarMain",
          "type": "tree",
          "content": null
        },
        {
          "name": "ui.cpp",
          "type": "blob",
          "size": 18.7919921875,
          "content": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ui.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/input.h>\n#include <pthread.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <functional>\n#include <string>\n\n#include <android-base/file.h>\n#include <android-base/logging.h>\n#include <android-base/parseint.h>\n#include <android-base/properties.h>\n#include <android-base/strings.h>\n#include <cutils/android_reboot.h>\n#include <minui/minui.h>\n\n#include \"common.h\"\n#include \"roots.h\"\n#include \"device.h\"\n\nstatic constexpr int UI_WAIT_KEY_TIMEOUT_SEC = 120;\nstatic constexpr const char* BRIGHTNESS_FILE = \"/sys/class/leds/lcd-backlight/brightness\";\nstatic constexpr const char* MAX_BRIGHTNESS_FILE = \"/sys/class/leds/lcd-backlight/max_brightness\";\nstatic constexpr const char* BRIGHTNESS_FILE_SDM =\n    \"/sys/class/backlight/panel0-backlight/brightness\";\nstatic constexpr const char* MAX_BRIGHTNESS_FILE_SDM =\n    \"/sys/class/backlight/panel0-backlight/max_brightness\";\n\nRecoveryUI::RecoveryUI()\n    : brightness_normal_(50),\n      brightness_dimmed_(25),\n      brightness_file_(BRIGHTNESS_FILE),\n      max_brightness_file_(MAX_BRIGHTNESS_FILE),\n      touch_screen_allowed_(false),\n      kTouchLowThreshold(RECOVERY_UI_TOUCH_LOW_THRESHOLD),\n      kTouchHighThreshold(RECOVERY_UI_TOUCH_HIGH_THRESHOLD),\n      key_queue_len(0),\n      key_last_down(-1),\n      key_long_press(false),\n      key_down_count(0),\n      enable_reboot(true),\n      consecutive_power_keys(0),\n      last_key(-1),\n      has_power_key(false),\n      has_up_key(false),\n      has_down_key(false),\n      has_touch_screen(false),\n      touch_slot_(0),\n      is_bootreason_recovery_ui_(false),\n      screensaver_state_(ScreensaverState::DISABLED) {\n  pthread_mutex_init(&key_queue_mutex, nullptr);\n  pthread_cond_init(&key_queue_cond, nullptr);\n  memset(key_pressed, 0, sizeof(key_pressed));\n}\n\nvoid RecoveryUI::OnKeyDetected(int key_code) {\n  if (key_code == KEY_POWER) {\n    has_power_key = true;\n  } else if (key_code == KEY_DOWN || key_code == KEY_VOLUMEDOWN) {\n    has_down_key = true;\n  } else if (key_code == KEY_UP || key_code == KEY_VOLUMEUP) {\n    has_up_key = true;\n  } else if (key_code == ABS_MT_POSITION_X || key_code == ABS_MT_POSITION_Y) {\n    has_touch_screen = true;\n  }\n}\n\n// Reads input events, handles special hot keys, and adds to the key queue.\nstatic void* InputThreadLoop(void*) {\n  while (true) {\n    if (!ev_wait(-1)) {\n      ev_dispatch();\n    }\n  }\n  return nullptr;\n}\n\nbool RecoveryUI::InitScreensaver() {\n  // Disabled.\n  if (brightness_normal_ == 0 || brightness_dimmed_ > brightness_normal_) {\n    return false;\n  }\n  if (access(brightness_file_.c_str(), R_OK | W_OK)) {\n    brightness_file_ = BRIGHTNESS_FILE_SDM;\n  }\n  if (access(max_brightness_file_.c_str(), R_OK)) {\n    max_brightness_file_ = MAX_BRIGHTNESS_FILE_SDM;\n  }\n  // Set the initial brightness level based on the max brightness. Note that reading the initial\n  // value from BRIGHTNESS_FILE doesn't give the actual brightness value (bullhead, sailfish), so\n  // we don't have a good way to query the default value.\n  std::string content;\n  if (!android::base::ReadFileToString(max_brightness_file_, &content)) {\n    PLOG(WARNING) << \"Failed to read max brightness\";\n    return false;\n  }\n\n  unsigned int max_value;\n  if (!android::base::ParseUint(android::base::Trim(content), &max_value)) {\n    LOG(WARNING) << \"Failed to parse max brightness: \" << content;\n    return false;\n  }\n\n  brightness_normal_value_ = max_value * brightness_normal_ / 100.0;\n  brightness_dimmed_value_ = max_value * brightness_dimmed_ / 100.0;\n  if (!android::base::WriteStringToFile(std::to_string(brightness_normal_value_),\n                                        brightness_file_)) {\n    PLOG(WARNING) << \"Failed to set brightness\";\n    return false;\n  }\n\n  LOG(INFO) << \"Brightness: \" << brightness_normal_value_ << \" (\" << brightness_normal_ << \"%)\";\n  screensaver_state_ = ScreensaverState::NORMAL;\n  return true;\n}\n\nbool RecoveryUI::Init(const std::string& /* locale */) {\n  ev_init(std::bind(&RecoveryUI::OnInputEvent, this, std::placeholders::_1, std::placeholders::_2),\n          touch_screen_allowed_);\n\n  ev_iterate_available_keys(std::bind(&RecoveryUI::OnKeyDetected, this, std::placeholders::_1));\n\n  if (touch_screen_allowed_) {\n    ev_iterate_touch_inputs(std::bind(&RecoveryUI::OnKeyDetected, this, std::placeholders::_1));\n\n    // Parse /proc/cmdline to determine if it's booting into recovery with a bootreason of\n    // \"recovery_ui\". This specific reason is set by some (wear) bootloaders, to allow an easier way\n    // to turn on text mode. It will only be set if the recovery boot is triggered from fastboot, or\n    // with 'adb reboot recovery'. Note that this applies to all build variants. Otherwise the text\n    // mode will be turned on automatically on debuggable builds, even without a swipe.\n    std::string cmdline;\n    if (android::base::ReadFileToString(\"/proc/cmdline\", &cmdline)) {\n      is_bootreason_recovery_ui_ = cmdline.find(\"bootreason=recovery_ui\") != std::string::npos;\n    } else {\n      // Non-fatal, and won't affect Init() result.\n      PLOG(WARNING) << \"Failed to read /proc/cmdline\";\n    }\n  }\n\n  if (!InitScreensaver()) {\n    LOG(INFO) << \"Screensaver disabled\";\n  }\n\n  pthread_create(&input_thread_, nullptr, InputThreadLoop, nullptr);\n  return true;\n}\n\nvoid RecoveryUI::OnTouchDetected(int dx, int dy) {\n  enum SwipeDirection { UP, DOWN, RIGHT, LEFT } direction;\n\n  // We only consider a valid swipe if:\n  // - the delta along one axis is below kTouchLowThreshold;\n  // - and the delta along the other axis is beyond kTouchHighThreshold.\n  if (abs(dy) < kTouchLowThreshold && abs(dx) > kTouchHighThreshold) {\n    direction = dx < 0 ? SwipeDirection::LEFT : SwipeDirection::RIGHT;\n  } else if (abs(dx) < kTouchLowThreshold && abs(dy) > kTouchHighThreshold) {\n    direction = dy < 0 ? SwipeDirection::UP : SwipeDirection::DOWN;\n  } else {\n    LOG(DEBUG) << \"Ignored \" << dx << \" \" << dy << \" (low: \" << kTouchLowThreshold\n               << \", high: \" << kTouchHighThreshold << \")\";\n    return;\n  }\n\n  // Allow turning on text mode with any swipe, if bootloader has set a bootreason of recovery_ui.\n  if (is_bootreason_recovery_ui_ && !IsTextVisible()) {\n    ShowText(true);\n    return;\n  }\n\n  LOG(DEBUG) << \"Swipe direction=\" << direction;\n  switch (direction) {\n    case SwipeDirection::UP:\n      ProcessKey(KEY_UP, 1);  // press up key\n      ProcessKey(KEY_UP, 0);  // and release it\n      break;\n\n    case SwipeDirection::DOWN:\n      ProcessKey(KEY_DOWN, 1);  // press down key\n      ProcessKey(KEY_DOWN, 0);  // and release it\n      break;\n\n    case SwipeDirection::LEFT:\n    case SwipeDirection::RIGHT:\n      ProcessKey(KEY_POWER, 1);  // press power key\n      ProcessKey(KEY_POWER, 0);  // and release it\n      break;\n  };\n}\n\nint RecoveryUI::OnInputEvent(int fd, uint32_t epevents) {\n  struct input_event ev;\n  if (ev_get_input(fd, epevents, &ev) == -1) {\n    return -1;\n  }\n\n  // Touch inputs handling.\n  //\n  // We handle the touch inputs by tracking the position changes between initial contacting and\n  // upon lifting. touch_start_X/Y record the initial positions, with touch_finger_down set. Upon\n  // detecting the lift, we unset touch_finger_down and detect a swipe based on position changes.\n  //\n  // Per the doc Multi-touch Protocol at below, there are two protocols.\n  // https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt\n  //\n  // The main difference between the stateless type A protocol and the stateful type B slot protocol\n  // lies in the usage of identifiable contacts to reduce the amount of data sent to userspace. The\n  // slot protocol (i.e. type B) sends ABS_MT_TRACKING_ID with a unique id on initial contact, and\n  // sends ABS_MT_TRACKING_ID -1 upon lifting the contact. Protocol A doesn't send\n  // ABS_MT_TRACKING_ID -1 on lifting, but the driver may additionally report BTN_TOUCH event.\n  //\n  // For protocol A, we rely on BTN_TOUCH to recognize lifting, while for protocol B we look for\n  // ABS_MT_TRACKING_ID being -1.\n  //\n  // Touch input events will only be available if touch_screen_allowed_ is set.\n\n  if (ev.type == EV_SYN) {\n    if (touch_screen_allowed_ && ev.code == SYN_REPORT) {\n      // There might be multiple SYN_REPORT events. We should only detect a swipe after lifting the\n      // contact.\n      if (touch_finger_down_ && !touch_swiping_) {\n        touch_start_X_ = touch_X_;\n        touch_start_Y_ = touch_Y_;\n        touch_swiping_ = true;\n      } else if (!touch_finger_down_ && touch_swiping_) {\n        touch_swiping_ = false;\n        OnTouchDetected(touch_X_ - touch_start_X_, touch_Y_ - touch_start_Y_);\n      }\n    }\n    return 0;\n  }\n\n  if (ev.type == EV_REL) {\n    if (ev.code == REL_Y) {\n      // accumulate the up or down motion reported by\n      // the trackball.  When it exceeds a threshold\n      // (positive or negative), fake an up/down\n      // key event.\n      rel_sum += ev.value;\n      if (rel_sum > 3) {\n        ProcessKey(KEY_DOWN, 1);  // press down key\n        ProcessKey(KEY_DOWN, 0);  // and release it\n        rel_sum = 0;\n      } else if (rel_sum < -3) {\n        ProcessKey(KEY_UP, 1);  // press up key\n        ProcessKey(KEY_UP, 0);  // and release it\n        rel_sum = 0;\n      }\n    }\n  } else {\n    rel_sum = 0;\n  }\n\n  if (touch_screen_allowed_ && ev.type == EV_ABS) {\n    if (ev.code == ABS_MT_SLOT) {\n      touch_slot_ = ev.value;\n    }\n    // Ignore other fingers.\n    if (touch_slot_ > 0) return 0;\n\n    switch (ev.code) {\n      case ABS_MT_POSITION_X:\n        touch_X_ = ev.value;\n        touch_finger_down_ = true;\n        break;\n\n      case ABS_MT_POSITION_Y:\n        touch_Y_ = ev.value;\n        touch_finger_down_ = true;\n        break;\n\n      case ABS_MT_TRACKING_ID:\n        // Protocol B: -1 marks lifting the contact.\n        if (ev.value < 0) touch_finger_down_ = false;\n        break;\n    }\n    return 0;\n  }\n\n  if (ev.type == EV_KEY && ev.code <= KEY_MAX) {\n    if (touch_screen_allowed_) {\n      if (ev.code == BTN_TOUCH) {\n        // A BTN_TOUCH with value 1 indicates the start of contact (protocol A), with 0 means\n        // lifting the contact.\n        touch_finger_down_ = (ev.value == 1);\n      }\n\n      // Intentionally ignore BTN_TOUCH and BTN_TOOL_FINGER, which would otherwise trigger\n      // additional scrolling (because in ScreenRecoveryUI::ShowFile(), we consider keys other than\n      // KEY_POWER and KEY_UP as KEY_DOWN).\n      if (ev.code == BTN_TOUCH || ev.code == BTN_TOOL_FINGER) {\n        return 0;\n      }\n    }\n\n    ProcessKey(ev.code, ev.value);\n  }\n\n  return 0;\n}\n\n// Process a key-up or -down event.  A key is \"registered\" when it is\n// pressed and then released, with no other keypresses or releases in\n// between.  Registered keys are passed to CheckKey() to see if it\n// should trigger a visibility toggle, an immediate reboot, or be\n// queued to be processed next time the foreground thread wants a key\n// (eg, for the menu).\n//\n// We also keep track of which keys are currently down so that\n// CheckKey can call IsKeyPressed to see what other keys are held when\n// a key is registered.\n//\n// updown == 1 for key down events; 0 for key up events\nvoid RecoveryUI::ProcessKey(int key_code, int updown) {\n  bool register_key = false;\n  bool long_press = false;\n  bool reboot_enabled;\n\n  pthread_mutex_lock(&key_queue_mutex);\n  key_pressed[key_code] = updown;\n  if (updown) {\n    ++key_down_count;\n    key_last_down = key_code;\n    key_long_press = false;\n    key_timer_t* info = new key_timer_t;\n    info->ui = this;\n    info->key_code = key_code;\n    info->count = key_down_count;\n    pthread_t thread;\n    pthread_create(&thread, nullptr, &RecoveryUI::time_key_helper, info);\n    pthread_detach(thread);\n  } else {\n    if (key_last_down == key_code) {\n      long_press = key_long_press;\n      register_key = true;\n    }\n    key_last_down = -1;\n  }\n  reboot_enabled = enable_reboot;\n  pthread_mutex_unlock(&key_queue_mutex);\n\n  if (register_key) {\n    switch (CheckKey(key_code, long_press)) {\n      case RecoveryUI::IGNORE:\n        break;\n\n      case RecoveryUI::TOGGLE:\n        ShowText(!IsTextVisible());\n        break;\n\n      case RecoveryUI::REBOOT:\n        if (reboot_enabled) {\n          reboot(\"reboot,\");\n          while (true) {\n            pause();\n          }\n        }\n        break;\n\n      case RecoveryUI::ENQUEUE:\n        EnqueueKey(key_code);\n        break;\n    }\n  }\n}\n\nvoid* RecoveryUI::time_key_helper(void* cookie) {\n  key_timer_t* info = static_cast<key_timer_t*>(cookie);\n  info->ui->time_key(info->key_code, info->count);\n  delete info;\n  return nullptr;\n}\n\nvoid RecoveryUI::time_key(int key_code, int count) {\n  usleep(750000);  // 750 ms == \"long\"\n  bool long_press = false;\n  pthread_mutex_lock(&key_queue_mutex);\n  if (key_last_down == key_code && key_down_count == count) {\n    long_press = key_long_press = true;\n  }\n  pthread_mutex_unlock(&key_queue_mutex);\n  if (long_press) KeyLongPress(key_code);\n}\n\nvoid RecoveryUI::EnqueueKey(int key_code) {\n  pthread_mutex_lock(&key_queue_mutex);\n  const int queue_max = sizeof(key_queue) / sizeof(key_queue[0]);\n  if (key_queue_len < queue_max) {\n    key_queue[key_queue_len++] = key_code;\n    pthread_cond_signal(&key_queue_cond);\n  }\n  pthread_mutex_unlock(&key_queue_mutex);\n}\n\nint RecoveryUI::WaitKey() {\n  pthread_mutex_lock(&key_queue_mutex);\n\n  // Time out after UI_WAIT_KEY_TIMEOUT_SEC, unless a USB cable is\n  // plugged in.\n  do {\n    struct timeval now;\n    struct timespec timeout;\n    gettimeofday(&now, nullptr);\n    timeout.tv_sec = now.tv_sec;\n    timeout.tv_nsec = now.tv_usec * 1000;\n    timeout.tv_sec += UI_WAIT_KEY_TIMEOUT_SEC;\n\n    int rc = 0;\n    while (key_queue_len == 0 && rc != ETIMEDOUT) {\n      rc = pthread_cond_timedwait(&key_queue_cond, &key_queue_mutex, &timeout);\n    }\n\n    if (screensaver_state_ != ScreensaverState::DISABLED) {\n      if (rc == ETIMEDOUT) {\n        // Lower the brightness level: NORMAL -> DIMMED; DIMMED -> OFF.\n        if (screensaver_state_ == ScreensaverState::NORMAL) {\n          if (android::base::WriteStringToFile(std::to_string(brightness_dimmed_value_),\n                                               brightness_file_)) {\n            LOG(INFO) << \"Brightness: \" << brightness_dimmed_value_ << \" (\" << brightness_dimmed_\n                      << \"%)\";\n            screensaver_state_ = ScreensaverState::DIMMED;\n          }\n        } else if (screensaver_state_ == ScreensaverState::DIMMED) {\n          if (android::base::WriteStringToFile(\"0\", brightness_file_)) {\n            LOG(INFO) << \"Brightness: 0 (off)\";\n            screensaver_state_ = ScreensaverState::OFF;\n          }\n        }\n      } else if (screensaver_state_ != ScreensaverState::NORMAL) {\n        // Drop the first key if it's changing from OFF to NORMAL.\n        if (screensaver_state_ == ScreensaverState::OFF) {\n          if (key_queue_len > 0) {\n            memcpy(&key_queue[0], &key_queue[1], sizeof(int) * --key_queue_len);\n          }\n        }\n\n        // Reset the brightness to normal.\n        if (android::base::WriteStringToFile(std::to_string(brightness_normal_value_),\n                                             brightness_file_)) {\n          screensaver_state_ = ScreensaverState::NORMAL;\n          LOG(INFO) << \"Brightness: \" << brightness_normal_value_ << \" (\" << brightness_normal_\n                    << \"%)\";\n        }\n      }\n    }\n  } while (IsUsbConnected() && key_queue_len == 0);\n\n  int key = -1;\n  if (key_queue_len > 0) {\n    key = key_queue[0];\n    memcpy(&key_queue[0], &key_queue[1], sizeof(int) * --key_queue_len);\n  }\n  pthread_mutex_unlock(&key_queue_mutex);\n  return key;\n}\n\nbool RecoveryUI::IsUsbConnected() {\n  int fd = open(\"/sys/class/android_usb/android0/state\", O_RDONLY);\n  if (fd < 0) {\n    printf(\"failed to open /sys/class/android_usb/android0/state: %s\\n\", strerror(errno));\n    return 0;\n  }\n\n  char buf;\n  // USB is connected if android_usb state is CONNECTED or CONFIGURED.\n  int connected = (TEMP_FAILURE_RETRY(read(fd, &buf, 1)) == 1) && (buf == 'C');\n  if (close(fd) < 0) {\n    printf(\"failed to close /sys/class/android_usb/android0/state: %s\\n\", strerror(errno));\n  }\n  return connected;\n}\n\nbool RecoveryUI::IsKeyPressed(int key) {\n  pthread_mutex_lock(&key_queue_mutex);\n  int pressed = key_pressed[key];\n  pthread_mutex_unlock(&key_queue_mutex);\n  return pressed;\n}\n\nbool RecoveryUI::IsLongPress() {\n  pthread_mutex_lock(&key_queue_mutex);\n  bool result = key_long_press;\n  pthread_mutex_unlock(&key_queue_mutex);\n  return result;\n}\n\nbool RecoveryUI::HasThreeButtons() {\n  return has_power_key && has_up_key && has_down_key;\n}\n\nbool RecoveryUI::HasPowerKey() const {\n  return has_power_key;\n}\n\nbool RecoveryUI::HasTouchScreen() const {\n  return has_touch_screen;\n}\n\nvoid RecoveryUI::FlushKeys() {\n  pthread_mutex_lock(&key_queue_mutex);\n  key_queue_len = 0;\n  pthread_mutex_unlock(&key_queue_mutex);\n}\n\nRecoveryUI::KeyAction RecoveryUI::CheckKey(int key, bool is_long_press) {\n  pthread_mutex_lock(&key_queue_mutex);\n  key_long_press = false;\n  pthread_mutex_unlock(&key_queue_mutex);\n\n  // If we have power and volume up keys, that chord is the signal to toggle the text display.\n  if (HasThreeButtons() || (HasPowerKey() && HasTouchScreen() && touch_screen_allowed_)) {\n    if ((key == KEY_VOLUMEUP || key == KEY_UP) && IsKeyPressed(KEY_POWER)) {\n      return TOGGLE;\n    }\n  } else {\n    // Otherwise long press of any button toggles to the text display,\n    // and there's no way to toggle back (but that's pretty useless anyway).\n    if (is_long_press && !IsTextVisible()) {\n      return TOGGLE;\n    }\n\n    // Also, for button-limited devices, a long press is translated to KEY_ENTER.\n    if (is_long_press && IsTextVisible()) {\n      EnqueueKey(KEY_ENTER);\n      return IGNORE;\n    }\n  }\n\n  // Press power seven times in a row to reboot.\n  if (key == KEY_POWER) {\n    pthread_mutex_lock(&key_queue_mutex);\n    bool reboot_enabled = enable_reboot;\n    pthread_mutex_unlock(&key_queue_mutex);\n\n    if (reboot_enabled) {\n      ++consecutive_power_keys;\n      if (consecutive_power_keys >= 7) {\n        return REBOOT;\n      }\n    }\n  } else {\n    consecutive_power_keys = 0;\n  }\n\n  last_key = key;\n  return (IsTextVisible() || screensaver_state_ == ScreensaverState::OFF) ? ENQUEUE : IGNORE;\n}\n\nvoid RecoveryUI::KeyLongPress(int) {\n}\n\nvoid RecoveryUI::SetEnableReboot(bool enabled) {\n  pthread_mutex_lock(&key_queue_mutex);\n  enable_reboot = enabled;\n  pthread_mutex_unlock(&key_queue_mutex);\n}\n"
        },
        {
          "name": "ui.h",
          "type": "blob",
          "size": 7.005859375,
          "content": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_UI_H\n#define RECOVERY_UI_H\n\n#include <linux/input.h>\n#include <pthread.h>\n#include <time.h>\n\n#include <string>\n\n// Abstract class for controlling the user interface during recovery.\nclass RecoveryUI {\n public:\n  enum Icon {\n    NONE,\n    INSTALLING_UPDATE,\n    ERASING,\n    NO_COMMAND,\n    ERROR\n  };\n\n  enum ProgressType {\n    EMPTY,\n    INDETERMINATE,\n    DETERMINATE\n  };\n\n  enum KeyAction {\n    ENQUEUE,\n    TOGGLE,\n    REBOOT,\n    IGNORE\n  };\n\n  RecoveryUI();\n\n  virtual ~RecoveryUI() {}\n\n  // Initializes the object; called before anything else. UI texts will be initialized according to\n  // the given locale. Returns true on success.\n  virtual bool Init(const std::string& locale);\n\n  // Shows a stage indicator. Called immediately after Init().\n  virtual void SetStage(int current, int max) = 0;\n\n  // Sets the overall recovery state (\"background image\").\n  virtual void SetBackground(Icon icon) = 0;\n  virtual void SetSystemUpdateText(bool security_update) = 0;\n\n  // --- progress indicator ---\n  virtual void SetProgressType(ProgressType determinate) = 0;\n\n  // Shows a progress bar and define the scope of the next operation:\n  //   portion - fraction of the progress bar the next operation will use\n  //   seconds - expected time interval (progress bar moves at this minimum rate)\n  virtual void ShowProgress(float portion, float seconds) = 0;\n\n  // Sets progress bar position (0.0 - 1.0 within the scope defined by the last call to\n  // ShowProgress).\n  virtual void SetProgress(float fraction) = 0;\n\n  // --- text log ---\n\n  virtual void ShowText(bool visible) = 0;\n\n  virtual bool IsTextVisible() = 0;\n\n  virtual bool WasTextEverVisible() = 0;\n\n  // Writes a message to the on-screen log (shown if the user has toggled on the text display).\n  // Print() will also dump the message to stdout / log file, while PrintOnScreenOnly() not.\n  virtual void Print(const char* fmt, ...) __printflike(2, 3) = 0;\n  virtual void PrintOnScreenOnly(const char* fmt, ...) __printflike(2, 3) = 0;\n\n  virtual void ShowFile(const char* filename) = 0;\n\n  // --- key handling ---\n\n  // Waits for a key and return it. May return -1 after timeout.\n  virtual int WaitKey();\n\n  virtual bool IsKeyPressed(int key);\n  virtual bool IsLongPress();\n\n  // Returns true if you have the volume up/down and power trio typical of phones and tablets, false\n  // otherwise.\n  virtual bool HasThreeButtons();\n\n  // Returns true if it has a power key.\n  virtual bool HasPowerKey() const;\n\n  // Returns true if it supports touch inputs.\n  virtual bool HasTouchScreen() const;\n\n  // Erases any queued-up keys.\n  virtual void FlushKeys();\n\n  // Called on each key press, even while operations are in progress. Return value indicates whether\n  // an immediate operation should be triggered (toggling the display, rebooting the device), or if\n  // the key should be enqueued for use by the main thread.\n  virtual KeyAction CheckKey(int key, bool is_long_press);\n\n  // Called when a key is held down long enough to have been a long-press (but before the key is\n  // released). This means that if the key is eventually registered (released without any other keys\n  // being pressed in the meantime), CheckKey will be called with 'is_long_press' true.\n  virtual void KeyLongPress(int key);\n\n  // Normally in recovery there's a key sequence that triggers immediate reboot of the device,\n  // regardless of what recovery is doing (with the default CheckKey implementation, it's pressing\n  // the power button 7 times in row). Call this to enable or disable that feature. It is enabled by\n  // default.\n  virtual void SetEnableReboot(bool enabled);\n\n  // --- menu display ---\n\n  // Display some header text followed by a menu of items, which appears at the top of the screen\n  // (in place of any scrolling ui_print() output, if necessary).\n  virtual void StartMenu(const char* const* headers, const char* const* items,\n                         int initial_selection) = 0;\n\n  // Sets the menu highlight to the given index, wrapping if necessary. Returns the actual item\n  // selected.\n  virtual int SelectMenu(int sel) = 0;\n\n  // Ends menu mode, resetting the text overlay so that ui_print() statements will be displayed.\n  virtual void EndMenu() = 0;\n\n protected:\n  void EnqueueKey(int key_code);\n\n  // The normal and dimmed brightness percentages (default: 50 and 25, which means 50% and 25% of\n  // the max_brightness). Because the absolute values may vary across devices. These two values can\n  // be configured via subclassing. Setting brightness_normal_ to 0 to disable screensaver.\n  unsigned int brightness_normal_;\n  unsigned int brightness_dimmed_;\n  std::string brightness_file_;\n  std::string max_brightness_file_;\n\n  // Whether we should listen for touch inputs (default: false).\n  bool touch_screen_allowed_;\n\n private:\n  enum class ScreensaverState {\n    DISABLED,\n    NORMAL,\n    DIMMED,\n    OFF\n  };\n\n  struct key_timer_t {\n    RecoveryUI* ui;\n    int key_code;\n    int count;\n  };\n\n  // The sensitivity when detecting a swipe.\n  const int kTouchLowThreshold;\n  const int kTouchHighThreshold;\n\n  void OnKeyDetected(int key_code);\n  void OnTouchDetected(int dx, int dy);\n  int OnInputEvent(int fd, uint32_t epevents);\n  void ProcessKey(int key_code, int updown);\n\n  bool IsUsbConnected();\n\n  static void* time_key_helper(void* cookie);\n  void time_key(int key_code, int count);\n\n  bool InitScreensaver();\n\n  // Key event input queue\n  pthread_mutex_t key_queue_mutex;\n  pthread_cond_t key_queue_cond;\n  int key_queue[256], key_queue_len;\n  char key_pressed[KEY_MAX + 1];  // under key_queue_mutex\n  int key_last_down;              // under key_queue_mutex\n  bool key_long_press;            // under key_queue_mutex\n  int key_down_count;             // under key_queue_mutex\n  bool enable_reboot;             // under key_queue_mutex\n  int rel_sum;\n\n  int consecutive_power_keys;\n  int last_key;\n\n  bool has_power_key;\n  bool has_up_key;\n  bool has_down_key;\n  bool has_touch_screen;\n\n  // Touch event related variables. See the comments in RecoveryUI::OnInputEvent().\n  int touch_slot_;\n  int touch_X_;\n  int touch_Y_;\n  int touch_start_X_;\n  int touch_start_Y_;\n  bool touch_finger_down_;\n  bool touch_swiping_;\n  bool is_bootreason_recovery_ui_;\n\n  pthread_t input_thread_;\n\n  ScreensaverState screensaver_state_;\n\n  // The following two contain the absolute values computed from brightness_normal_ and\n  // brightness_dimmed_ respectively.\n  unsigned int brightness_normal_value_;\n  unsigned int brightness_dimmed_value_;\n};\n\n#endif  // RECOVERY_UI_H\n"
        },
        {
          "name": "uncrypt",
          "type": "tree",
          "content": null
        },
        {
          "name": "update_verifier",
          "type": "tree",
          "content": null
        },
        {
          "name": "updater",
          "type": "tree",
          "content": null
        },
        {
          "name": "variables.h",
          "type": "blob",
          "size": 7.5810546875,
          "content": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _VARIABLES_HEADER_\n#define _VARIABLES_HEADER_\n\n#define TW_MAIN_VERSION_STR       \"3.2.3\"\n#define TW_VERSION_STR TW_MAIN_VERSION_STR TW_DEVICE_VERSION\n\n#define TW_USE_COMPRESSION_VAR      \"tw_use_compression\"\n#define TW_FILENAME                 \"tw_filename\"\n#define TW_ZIP_INDEX                \"tw_zip_index\"\n#define TW_ZIP_QUEUE_COUNT       \"tw_zip_queue_count\"\n\n#define MAX_BACKUP_NAME_LEN 64\n#define TW_BACKUP_TEXT              \"tw_backup_text\"\n#define TW_BACKUP_NAME\t\t        \"tw_backup_name\"\n#define TW_BACKUP_SYSTEM_VAR        \"tw_backup_system\"\n#define TW_BACKUP_DATA_VAR          \"tw_backup_data\"\n#define TW_BACKUP_BOOT_VAR          \"tw_backup_boot\"\n#define TW_BACKUP_RECOVERY_VAR      \"tw_backup_recovery\"\n#define TW_BACKUP_CACHE_VAR         \"tw_backup_cache\"\n#define TW_BACKUP_ANDSEC_VAR        \"tw_backup_andsec\"\n#define TW_BACKUP_SDEXT_VAR         \"tw_backup_sdext\"\n#define TW_BACKUP_AVG_IMG_RATE      \"tw_backup_avg_img_rate\"\n#define TW_BACKUP_AVG_FILE_RATE     \"tw_backup_avg_file_rate\"\n#define TW_BACKUP_AVG_FILE_COMP_RATE    \"tw_backup_avg_file_comp_rate\"\n#define TW_BACKUP_SYSTEM_SIZE       \"tw_backup_system_size\"\n#define TW_BACKUP_DATA_SIZE         \"tw_backup_data_size\"\n#define TW_BACKUP_BOOT_SIZE         \"tw_backup_boot_size\"\n#define TW_BACKUP_RECOVERY_SIZE     \"tw_backup_recovery_size\"\n#define TW_BACKUP_CACHE_SIZE        \"tw_backup_cache_size\"\n#define TW_BACKUP_ANDSEC_SIZE       \"tw_backup_andsec_size\"\n#define TW_BACKUP_SDEXT_SIZE        \"tw_backup_sdext_size\"\n#define TW_STORAGE_FREE_SIZE        \"tw_storage_free_size\"\n#define TW_GENERATE_DIGEST_TEXT     \"tw_generate_digest_text\"\n\n#define TW_RESTORE_TEXT             \"tw_restore_text\"\n#define TW_RESTORE_SYSTEM_VAR       \"tw_restore_system\"\n#define TW_RESTORE_DATA_VAR         \"tw_restore_data\"\n#define TW_RESTORE_BOOT_VAR         \"tw_restore_boot\"\n#define TW_RESTORE_RECOVERY_VAR     \"tw_restore_recovery\"\n#define TW_RESTORE_CACHE_VAR        \"tw_restore_cache\"\n#define TW_RESTORE_ANDSEC_VAR       \"tw_restore_andsec\"\n#define TW_RESTORE_SDEXT_VAR        \"tw_restore_sdext\"\n#define TW_RESTORE_AVG_IMG_RATE     \"tw_restore_avg_img_rate\"\n#define TW_RESTORE_AVG_FILE_RATE    \"tw_restore_avg_file_rate\"\n#define TW_RESTORE_AVG_FILE_COMP_RATE    \"tw_restore_avg_file_comp_rate\"\n#define TW_RESTORE_FILE_DATE        \"tw_restore_file_date\"\n#define TW_VERIFY_DIGEST_TEXT       \"tw_verify_digest_text\"\n#define TW_UPDATE_SYSTEM_DETAILS_TEXT \"tw_update_system_details_text\"\n\n#define TW_VERSION_VAR              \"tw_version\"\n#define TW_GUI_SORT_ORDER           \"tw_gui_sort_order\"\n#define TW_ZIP_LOCATION_VAR         \"tw_zip_location\"\n#define TW_ZIP_INTERNAL_VAR         \"tw_zip_internal\"\n#define TW_ZIP_EXTERNAL_VAR         \"tw_zip_external\"\n#define TW_DISABLE_FREE_SPACE_VAR   \"tw_disable_free_space\"\n#define TW_FORCE_DIGEST_CHECK_VAR   \"tw_force_digest_check\"\n#define TW_SKIP_DIGEST_CHECK_VAR    \"tw_skip_digest_check\"\n#define TW_SKIP_DIGEST_GENERATE_VAR \"tw_skip_digest_generate\"\n#define TW_SIGNED_ZIP_VERIFY_VAR    \"tw_signed_zip_verify\"\n#define TW_INSTALL_REBOOT_VAR       \"tw_install_reboot\"\n#define TW_TIME_ZONE_VAR            \"tw_time_zone\"\n#define TW_RM_RF_VAR                \"tw_rm_rf\"\n\n#define TW_BACKUPS_FOLDER_VAR       \"tw_backups_folder\"\n\n#define TW_SDEXT_SIZE               \"tw_sdext_size\"\n#define TW_SWAP_SIZE                \"tw_swap_size\"\n#define TW_SDPART_FILE_SYSTEM       \"tw_sdpart_file_system\"\n#define TW_TIME_ZONE_GUISEL         \"tw_time_zone_guisel\"\n#define TW_TIME_ZONE_GUIOFFSET      \"tw_time_zone_guioffset\"\n#define TW_TIME_ZONE_GUIDST         \"tw_time_zone_guidst\"\n\n#define TW_ACTION_BUSY              \"tw_busy\"\n\n#define TW_ALLOW_PARTITION_SDCARD   \"tw_allow_partition_sdcard\"\n\n#define TW_SCREEN_OFF               \"tw_screen_off\"\n\n#define TW_REBOOT_SYSTEM            \"tw_reboot_system\"\n#define TW_REBOOT_RECOVERY          \"tw_reboot_recovery\"\n#define TW_REBOOT_POWEROFF          \"tw_reboot_poweroff\"\n#define TW_REBOOT_BOOTLOADER        \"tw_reboot_bootloader\"\n\n#define TW_USE_EXTERNAL_STORAGE     \"tw_use_external_storage\"\n#define TW_HAS_INTERNAL             \"tw_has_internal\"\n#define TW_INTERNAL_PATH            \"tw_internal_path\"         // /data/media or /internal\n#define TW_INTERNAL_MOUNT           \"tw_internal_mount\"        // /data or /internal\n#define TW_INTERNAL_LABEL           \"tw_internal_label\"        // data or internal\n#define TW_HAS_EXTERNAL             \"tw_has_external\"\n#define TW_EXTERNAL_PATH            \"tw_external_path\"         // /sdcard or /external/sdcard2\n#define TW_EXTERNAL_MOUNT           \"tw_external_mount\"        // /sdcard or /external\n#define TW_EXTERNAL_LABEL           \"tw_external_label\"        // sdcard or external\n\n#define TW_HAS_DATA_MEDIA           \"tw_has_data_media\"\n\n#define TW_HAS_BOOT_PARTITION       \"tw_has_boot_partition\"\n#define TW_HAS_RECOVERY_PARTITION   \"tw_has_recovery_partition\"\n#define TW_HAS_ANDROID_SECURE       \"tw_has_android_secure\"\n#define TW_HAS_SDEXT_PARTITION      \"tw_has_sdext_partition\"\n#define TW_HAS_USB_STORAGE          \"tw_has_usb_storage\"\n#define TW_NO_BATTERY_PERCENT       \"tw_no_battery_percent\"\n#define TW_POWER_BUTTON             \"tw_power_button\"\n#define TW_SIMULATE_ACTIONS         \"tw_simulate_actions\"\n#define TW_SIMULATE_FAIL            \"tw_simulate_fail\"\n#define TW_DONT_UNMOUNT_SYSTEM      \"tw_dont_unmount_system\"\n// #define TW_ALWAYS_RMRF              \"tw_always_rmrf\"\n\n#define TW_SHOW_DUMLOCK             \"tw_show_dumlock\"\n#define TW_HAS_INJECTTWRP           \"tw_has_injecttwrp\"\n#define TW_INJECT_AFTER_ZIP         \"tw_inject_after_zip\"\n#define TW_HAS_DATADATA             \"tw_has_datadata\"\n#define TW_FLASH_ZIP_IN_PLACE       \"tw_flash_zip_in_place\"\n#define TW_MIN_SYSTEM_SIZE          \"50\" // minimum system size to allow a reboot\n#define TW_MIN_SYSTEM_VAR           \"tw_min_system\"\n#define TW_DOWNLOAD_MODE            \"tw_download_mode\"\n#define TW_IS_ENCRYPTED             \"tw_is_encrypted\"\n#define TW_IS_DECRYPTED             \"tw_is_decrypted\"\n#define TW_CRYPTO_PWTYPE            \"tw_crypto_pwtype\"\n#define TW_HAS_CRYPTO               \"tw_has_crypto\"\n#define TW_IS_FBE                   \"tw_is_fbe\"\n#define TW_CRYPTO_PASSWORD          \"tw_crypto_password\"\n#define TW_SDEXT_DISABLE_EXT4       \"tw_sdext_disable_ext4\"\n#define TW_MILITARY_TIME            \"tw_military_time\"\n#define TW_USE_SHA2                 \"tw_use_sha2\"\n#define TW_NO_SHA2                  \"tw_no_sha2\"\n\n// Also used:\n//   tw_boot_is_mountable\n//   tw_system_is_mountable\n//   tw_data_is_mountable\n//   tw_cache_is_mountable\n//   tw_sdcext_is_mountable\n//   tw_sdcint_is_mountable\n//   tw_sd-ext_is_mountable\n//   tw_sp1_is_mountable\n//   tw_sp2_is_mountable\n//   tw_sp3_is_mountable\n\n// Max archive size for tar backups before we split (1.5GB)\n#define MAX_ARCHIVE_SIZE 1610612736LLU\n//#define MAX_ARCHIVE_SIZE 52428800LLU // 50MB split for testing\n\n#ifndef CUSTOM_LUN_FILE\n#define CUSTOM_LUN_FILE \"/sys/class/android_usb/android0/f_mass_storage/lun%d/file\"\n#endif\n\n// For OpenRecoveryScript\n#define SCRIPT_FILE_CACHE \"/cache/recovery/openrecoveryscript\"\n#define SCRIPT_FILE_TMP \"/tmp/openrecoveryscript\"\n#define TMP_LOG_FILE \"/tmp/recovery.log\"\n\n#endif  // _VARIABLES_HEADER_\n"
        },
        {
          "name": "verifier.cpp",
          "type": "blob",
          "size": 17.818359375,
          "content": "/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"verifier.h\"\n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <algorithm>\n#include <functional>\n#include <memory>\n#include <vector>\n\n#include <android-base/logging.h>\n#include <openssl/bn.h>\n#include <openssl/ecdsa.h>\n#include <openssl/obj_mac.h>\n\n#include \"asn1_decoder.h\"\n#include \"otautil/print_sha1.h\"\n\nstatic constexpr size_t MiB = 1024 * 1024;\n\n/*\n * Simple version of PKCS#7 SignedData extraction. This extracts the\n * signature OCTET STRING to be used for signature verification.\n *\n * For full details, see http://www.ietf.org/rfc/rfc3852.txt\n *\n * The PKCS#7 structure looks like:\n *\n *   SEQUENCE (ContentInfo)\n *     OID (ContentType)\n *     [0] (content)\n *       SEQUENCE (SignedData)\n *         INTEGER (version CMSVersion)\n *         SET (DigestAlgorithmIdentifiers)\n *         SEQUENCE (EncapsulatedContentInfo)\n *         [0] (CertificateSet OPTIONAL)\n *         [1] (RevocationInfoChoices OPTIONAL)\n *         SET (SignerInfos)\n *           SEQUENCE (SignerInfo)\n *             INTEGER (CMSVersion)\n *             SEQUENCE (SignerIdentifier)\n *             SEQUENCE (DigestAlgorithmIdentifier)\n *             SEQUENCE (SignatureAlgorithmIdentifier)\n *             OCTET STRING (SignatureValue)\n */\nstatic bool read_pkcs7(const uint8_t* pkcs7_der, size_t pkcs7_der_len,\n                       std::vector<uint8_t>* sig_der) {\n  CHECK(sig_der != nullptr);\n  sig_der->clear();\n\n  asn1_context ctx(pkcs7_der, pkcs7_der_len);\n\n  std::unique_ptr<asn1_context> pkcs7_seq(ctx.asn1_sequence_get());\n  if (pkcs7_seq == nullptr || !pkcs7_seq->asn1_sequence_next()) {\n    return false;\n  }\n\n  std::unique_ptr<asn1_context> signed_data_app(pkcs7_seq->asn1_constructed_get());\n  if (signed_data_app == nullptr) {\n    return false;\n  }\n\n  std::unique_ptr<asn1_context> signed_data_seq(signed_data_app->asn1_sequence_get());\n  if (signed_data_seq == nullptr ||\n      !signed_data_seq->asn1_sequence_next() ||\n      !signed_data_seq->asn1_sequence_next() ||\n      !signed_data_seq->asn1_sequence_next() ||\n      !signed_data_seq->asn1_constructed_skip_all()) {\n    return false;\n  }\n\n  std::unique_ptr<asn1_context> sig_set(signed_data_seq->asn1_set_get());\n  if (sig_set == nullptr) {\n    return false;\n  }\n\n  std::unique_ptr<asn1_context> sig_seq(sig_set->asn1_sequence_get());\n  if (sig_seq == nullptr ||\n      !sig_seq->asn1_sequence_next() ||\n      !sig_seq->asn1_sequence_next() ||\n      !sig_seq->asn1_sequence_next() ||\n      !sig_seq->asn1_sequence_next()) {\n    return false;\n  }\n\n  const uint8_t* sig_der_ptr;\n  size_t sig_der_length;\n  if (!sig_seq->asn1_octet_string_get(&sig_der_ptr, &sig_der_length)) {\n    return false;\n  }\n\n  sig_der->resize(sig_der_length);\n  std::copy(sig_der_ptr, sig_der_ptr + sig_der_length, sig_der->begin());\n  return true;\n}\n\n/*\n * Looks for an RSA signature embedded in the .ZIP file comment given the path to the zip. Verifies\n * that it matches one of the given public keys. A callback function can be optionally provided for\n * posting the progress.\n *\n * Returns VERIFY_SUCCESS or VERIFY_FAILURE (if any error is encountered or no key matches the\n * signature).\n */\nint verify_file(const unsigned char* addr, size_t length, const std::vector<Certificate>& keys,\n                const std::function<void(float)>& set_progress) {\n  if (set_progress) {\n    set_progress(0.0);\n  }\n\n  // An archive with a whole-file signature will end in six bytes:\n  //\n  //   (2-byte signature start) $ff $ff (2-byte comment size)\n  //\n  // (As far as the ZIP format is concerned, these are part of the archive comment.) We start by\n  // reading this footer, this tells us how far back from the end we have to start reading to find\n  // the whole comment.\n\n#define FOOTER_SIZE 6\n\n  if (length < FOOTER_SIZE) {\n    LOG(ERROR) << \"not big enough to contain footer\";\n    return VERIFY_FAILURE;\n  }\n\n  const unsigned char* footer = addr + length - FOOTER_SIZE;\n\n  if (footer[2] != 0xff || footer[3] != 0xff) {\n    LOG(ERROR) << \"footer is wrong\";\n    return VERIFY_FAILURE;\n  }\n\n  size_t comment_size = footer[4] + (footer[5] << 8);\n  size_t signature_start = footer[0] + (footer[1] << 8);\n  LOG(INFO) << \"comment is \" << comment_size << \" bytes; signature is \" << signature_start\n            << \" bytes from end\";\n\n  if (signature_start > comment_size) {\n    LOG(ERROR) << \"signature start: \" << signature_start << \" is larger than comment size: \"\n               << comment_size;\n    return VERIFY_FAILURE;\n  }\n\n  if (signature_start <= FOOTER_SIZE) {\n    LOG(ERROR) << \"Signature start is in the footer\";\n    return VERIFY_FAILURE;\n  }\n\n#define EOCD_HEADER_SIZE 22\n\n  // The end-of-central-directory record is 22 bytes plus any comment length.\n  size_t eocd_size = comment_size + EOCD_HEADER_SIZE;\n\n  if (length < eocd_size) {\n    LOG(ERROR) << \"not big enough to contain EOCD\";\n    return VERIFY_FAILURE;\n  }\n\n  // Determine how much of the file is covered by the signature. This is everything except the\n  // signature data and length, which includes all of the EOCD except for the comment length field\n  // (2 bytes) and the comment data.\n  size_t signed_len = length - eocd_size + EOCD_HEADER_SIZE - 2;\n\n  const unsigned char* eocd = addr + length - eocd_size;\n\n  // If this is really is the EOCD record, it will begin with the magic number $50 $4b $05 $06.\n  if (eocd[0] != 0x50 || eocd[1] != 0x4b || eocd[2] != 0x05 || eocd[3] != 0x06) {\n    LOG(ERROR) << \"signature length doesn't match EOCD marker\";\n    return VERIFY_FAILURE;\n  }\n\n  for (size_t i = 4; i < eocd_size-3; ++i) {\n    if (eocd[i] == 0x50 && eocd[i+1] == 0x4b && eocd[i+2] == 0x05 && eocd[i+3] == 0x06) {\n      // If the sequence $50 $4b $05 $06 appears anywhere after the real one, libziparchive will\n      // find the later (wrong) one, which could be exploitable. Fail the verification if this\n      // sequence occurs anywhere after the real one.\n      LOG(ERROR) << \"EOCD marker occurs after start of EOCD\";\n      return VERIFY_FAILURE;\n    }\n  }\n\n  bool need_sha1 = false;\n  bool need_sha256 = false;\n  for (const auto& key : keys) {\n    switch (key.hash_len) {\n      case SHA_DIGEST_LENGTH: need_sha1 = true; break;\n      case SHA256_DIGEST_LENGTH: need_sha256 = true; break;\n    }\n  }\n\n  SHA_CTX sha1_ctx;\n  SHA256_CTX sha256_ctx;\n  SHA1_Init(&sha1_ctx);\n  SHA256_Init(&sha256_ctx);\n\n  double frac = -1.0;\n  size_t so_far = 0;\n  while (so_far < signed_len) {\n    // On a Nexus 5X, experiment showed 16MiB beat 1MiB by 6% faster for a\n    // 1196MiB full OTA and 60% for an 89MiB incremental OTA.\n    // http://b/28135231.\n    size_t size = std::min(signed_len - so_far, 16 * MiB);\n\n    if (need_sha1) SHA1_Update(&sha1_ctx, addr + so_far, size);\n    if (need_sha256) SHA256_Update(&sha256_ctx, addr + so_far, size);\n    so_far += size;\n\n    if (set_progress) {\n      double f = so_far / (double)signed_len;\n      if (f > frac + 0.02 || size == so_far) {\n        set_progress(f);\n        frac = f;\n      }\n    }\n  }\n\n  uint8_t sha1[SHA_DIGEST_LENGTH];\n  SHA1_Final(sha1, &sha1_ctx);\n  uint8_t sha256[SHA256_DIGEST_LENGTH];\n  SHA256_Final(sha256, &sha256_ctx);\n\n  const uint8_t* signature = eocd + eocd_size - signature_start;\n  size_t signature_size = signature_start - FOOTER_SIZE;\n\n  LOG(INFO) << \"signature (offset: \" << std::hex << (length - signature_start) << \", length: \"\n            << signature_size << \"): \" << print_hex(signature, signature_size);\n\n  std::vector<uint8_t> sig_der;\n  if (!read_pkcs7(signature, signature_size, &sig_der)) {\n    LOG(ERROR) << \"Could not find signature DER block\";\n    return VERIFY_FAILURE;\n  }\n\n  // Check to make sure at least one of the keys matches the signature. Since any key can match,\n  // we need to try each before determining a verification failure has happened.\n  size_t i = 0;\n  for (const auto& key : keys) {\n    const uint8_t* hash;\n    int hash_nid;\n    switch (key.hash_len) {\n      case SHA_DIGEST_LENGTH:\n        hash = sha1;\n        hash_nid = NID_sha1;\n        break;\n      case SHA256_DIGEST_LENGTH:\n        hash = sha256;\n        hash_nid = NID_sha256;\n        break;\n      default:\n        continue;\n    }\n\n    // The 6 bytes is the \"(signature_start) $ff $ff (comment_size)\" that the signing tool appends\n    // after the signature itself.\n    if (key.key_type == Certificate::KEY_TYPE_RSA) {\n      if (!RSA_verify(hash_nid, hash, key.hash_len, sig_der.data(), sig_der.size(),\n                      key.rsa.get())) {\n        LOG(INFO) << \"failed to verify against RSA key \" << i;\n        continue;\n      }\n\n      LOG(INFO) << \"whole-file signature verified against RSA key \" << i;\n      return VERIFY_SUCCESS;\n    } else if (key.key_type == Certificate::KEY_TYPE_EC && key.hash_len == SHA256_DIGEST_LENGTH) {\n      if (!ECDSA_verify(0, hash, key.hash_len, sig_der.data(), sig_der.size(), key.ec.get())) {\n        LOG(INFO) << \"failed to verify against EC key \" << i;\n        continue;\n      }\n\n      LOG(INFO) << \"whole-file signature verified against EC key \" << i;\n      return VERIFY_SUCCESS;\n    } else {\n      LOG(INFO) << \"Unknown key type \" << key.key_type;\n    }\n    i++;\n  }\n\n  if (need_sha1) {\n    LOG(INFO) << \"SHA-1 digest: \" << print_hex(sha1, SHA_DIGEST_LENGTH);\n  }\n  if (need_sha256) {\n    LOG(INFO) << \"SHA-256 digest: \" << print_hex(sha256, SHA256_DIGEST_LENGTH);\n  }\n  LOG(ERROR) << \"failed to verify whole-file signature\";\n  return VERIFY_FAILURE;\n}\n\nstd::unique_ptr<RSA, RSADeleter> parse_rsa_key(FILE* file, uint32_t exponent) {\n    // Read key length in words and n0inv. n0inv is a precomputed montgomery\n    // parameter derived from the modulus and can be used to speed up\n    // verification. n0inv is 32 bits wide here, assuming the verification logic\n    // uses 32 bit arithmetic. However, BoringSSL may use a word size of 64 bits\n    // internally, in which case we don't have a valid n0inv. Thus, we just\n    // ignore the montgomery parameters and have BoringSSL recompute them\n    // internally. If/When the speedup from using the montgomery parameters\n    // becomes relevant, we can add more sophisticated code here to obtain a\n    // 64-bit n0inv and initialize the montgomery parameters in the key object.\n    uint32_t key_len_words = 0;\n    uint32_t n0inv = 0;\n    if (fscanf(file, \" %i , 0x%x\", &key_len_words, &n0inv) != 2) {\n        return nullptr;\n    }\n\n    if (key_len_words > 8192 / 32) {\n        LOG(ERROR) << \"key length (\" << key_len_words << \") too large\";\n        return nullptr;\n    }\n\n    // Read the modulus.\n    std::unique_ptr<uint32_t[]> modulus(new uint32_t[key_len_words]);\n    if (fscanf(file, \" , { %u\", &modulus[0]) != 1) {\n        return nullptr;\n    }\n    for (uint32_t i = 1; i < key_len_words; ++i) {\n        if (fscanf(file, \" , %u\", &modulus[i]) != 1) {\n            return nullptr;\n        }\n    }\n\n    // Cconvert from little-endian array of little-endian words to big-endian\n    // byte array suitable as input for BN_bin2bn.\n    std::reverse((uint8_t*)modulus.get(),\n                 (uint8_t*)(modulus.get() + key_len_words));\n\n    // The next sequence of values is the montgomery parameter R^2. Since we\n    // generally don't have a valid |n0inv|, we ignore this (see comment above).\n    uint32_t rr_value;\n    if (fscanf(file, \" } , { %u\", &rr_value) != 1) {\n        return nullptr;\n    }\n    for (uint32_t i = 1; i < key_len_words; ++i) {\n        if (fscanf(file, \" , %u\", &rr_value) != 1) {\n            return nullptr;\n        }\n    }\n    if (fscanf(file, \" } } \") != 0) {\n        return nullptr;\n    }\n\n    // Initialize the key.\n    std::unique_ptr<RSA, RSADeleter> key(RSA_new());\n    if (!key) {\n      return nullptr;\n    }\n\n    key->n = BN_bin2bn((uint8_t*)modulus.get(),\n                       key_len_words * sizeof(uint32_t), NULL);\n    if (!key->n) {\n      return nullptr;\n    }\n\n    key->e = BN_new();\n    if (!key->e || !BN_set_word(key->e, exponent)) {\n      return nullptr;\n    }\n\n    return key;\n}\n\nstruct BNDeleter {\n  void operator()(BIGNUM* bn) const {\n    BN_free(bn);\n  }\n};\n\nstd::unique_ptr<EC_KEY, ECKEYDeleter> parse_ec_key(FILE* file) {\n    uint32_t key_len_bytes = 0;\n    if (fscanf(file, \" %i\", &key_len_bytes) != 1) {\n        return nullptr;\n    }\n\n    std::unique_ptr<EC_GROUP, void (*)(EC_GROUP*)> group(\n        EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1), EC_GROUP_free);\n    if (!group) {\n        return nullptr;\n    }\n\n    // Verify that |key_len| matches the group order.\n    if (key_len_bytes != BN_num_bytes(EC_GROUP_get0_order(group.get()))) {\n        return nullptr;\n    }\n\n    // Read the public key coordinates. Note that the byte order in the file is\n    // little-endian, so we convert to big-endian here.\n    std::unique_ptr<uint8_t[]> bytes(new uint8_t[key_len_bytes]);\n    std::unique_ptr<BIGNUM, BNDeleter> point[2];\n    for (int i = 0; i < 2; ++i) {\n        unsigned int byte = 0;\n        if (fscanf(file, \" , { %u\", &byte) != 1) {\n            return nullptr;\n        }\n        bytes[key_len_bytes - 1] = byte;\n\n        for (size_t i = 1; i < key_len_bytes; ++i) {\n            if (fscanf(file, \" , %u\", &byte) != 1) {\n                return nullptr;\n            }\n            bytes[key_len_bytes - i - 1] = byte;\n        }\n\n        point[i].reset(BN_bin2bn(bytes.get(), key_len_bytes, nullptr));\n        if (!point[i]) {\n            return nullptr;\n        }\n\n        if (fscanf(file, \" }\") != 0) {\n            return nullptr;\n        }\n    }\n\n    if (fscanf(file, \" } \") != 0) {\n        return nullptr;\n    }\n\n    // Create and initialize the key.\n    std::unique_ptr<EC_KEY, ECKEYDeleter> key(EC_KEY_new());\n    if (!key || !EC_KEY_set_group(key.get(), group.get()) ||\n        !EC_KEY_set_public_key_affine_coordinates(key.get(), point[0].get(),\n                                                  point[1].get())) {\n        return nullptr;\n    }\n\n    return key;\n}\n\n// Reads a file containing one or more public keys as produced by\n// DumpPublicKey:  this is an RSAPublicKey struct as it would appear\n// as a C source literal, eg:\n//\n//  \"{64,0xc926ad21,{1795090719,...,-695002876},{-857949815,...,1175080310}}\"\n//\n// For key versions newer than the original 2048-bit e=3 keys\n// supported by Android, the string is preceded by a version\n// identifier, eg:\n//\n//  \"v2 {64,0xc926ad21,{1795090719,...,-695002876},{-857949815,...,1175080310}}\"\n//\n// (Note that the braces and commas in this example are actual\n// characters the parser expects to find in the file; the ellipses\n// indicate more numbers omitted from this example.)\n//\n// The file may contain multiple keys in this format, separated by\n// commas.  The last key must not be followed by a comma.\n//\n// A Certificate is a pair of an RSAPublicKey and a particular hash\n// (we support SHA-1 and SHA-256; we store the hash length to signify\n// which is being used).  The hash used is implied by the version number.\n//\n//       1: 2048-bit RSA key with e=3 and SHA-1 hash\n//       2: 2048-bit RSA key with e=65537 and SHA-1 hash\n//       3: 2048-bit RSA key with e=3 and SHA-256 hash\n//       4: 2048-bit RSA key with e=65537 and SHA-256 hash\n//       5: 256-bit EC key using the NIST P-256 curve parameters and SHA-256 hash\n//\n// Returns true on success, and appends the found keys (at least one) to certs.\n// Otherwise returns false if the file failed to parse, or if it contains zero\n// keys. The contents in certs would be unspecified on failure.\nbool load_keys(const char* filename, std::vector<Certificate>& certs) {\n  std::unique_ptr<FILE, decltype(&fclose)> f(fopen(filename, \"re\"), fclose);\n  if (!f) {\n    PLOG(ERROR) << \"error opening \" << filename;\n    return false;\n  }\n\n  while (true) {\n    certs.emplace_back(0, Certificate::KEY_TYPE_RSA, nullptr, nullptr);\n    Certificate& cert = certs.back();\n    uint32_t exponent = 0;\n\n    char start_char;\n    if (fscanf(f.get(), \" %c\", &start_char) != 1) return false;\n    if (start_char == '{') {\n      // a version 1 key has no version specifier.\n      cert.key_type = Certificate::KEY_TYPE_RSA;\n      exponent = 3;\n      cert.hash_len = SHA_DIGEST_LENGTH;\n    } else if (start_char == 'v') {\n      int version;\n      if (fscanf(f.get(), \"%d {\", &version) != 1) return false;\n      switch (version) {\n        case 2:\n          cert.key_type = Certificate::KEY_TYPE_RSA;\n          exponent = 65537;\n          cert.hash_len = SHA_DIGEST_LENGTH;\n          break;\n        case 3:\n          cert.key_type = Certificate::KEY_TYPE_RSA;\n          exponent = 3;\n          cert.hash_len = SHA256_DIGEST_LENGTH;\n          break;\n        case 4:\n          cert.key_type = Certificate::KEY_TYPE_RSA;\n          exponent = 65537;\n          cert.hash_len = SHA256_DIGEST_LENGTH;\n          break;\n        case 5:\n          cert.key_type = Certificate::KEY_TYPE_EC;\n          cert.hash_len = SHA256_DIGEST_LENGTH;\n          break;\n        default:\n          return false;\n      }\n    }\n\n    if (cert.key_type == Certificate::KEY_TYPE_RSA) {\n      cert.rsa = parse_rsa_key(f.get(), exponent);\n      if (!cert.rsa) {\n        return false;\n      }\n\n      LOG(INFO) << \"read key e=\" << exponent << \" hash=\" << cert.hash_len;\n    } else if (cert.key_type == Certificate::KEY_TYPE_EC) {\n      cert.ec = parse_ec_key(f.get());\n      if (!cert.ec) {\n        return false;\n      }\n    } else {\n      LOG(ERROR) << \"Unknown key type \" << cert.key_type;\n      return false;\n    }\n\n    // if the line ends in a comma, this file has more keys.\n    int ch = fgetc(f.get());\n    if (ch == ',') {\n      // more keys to come.\n      continue;\n    } else if (ch == EOF) {\n      break;\n    } else {\n      LOG(ERROR) << \"unexpected character between keys\";\n      return false;\n    }\n  }\n  return true;\n}\n"
        },
        {
          "name": "verifier.h",
          "type": "blob",
          "size": 2.451171875,
          "content": "/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _RECOVERY_VERIFIER_H\n#define _RECOVERY_VERIFIER_H\n\n#include <functional>\n#include <memory>\n#include <vector>\n\n#include <openssl/ec_key.h>\n#include <openssl/rsa.h>\n#include <openssl/sha.h>\n\n#define ASSUMED_UPDATE_BINARY_NAME  \"META-INF/com/google/android/update-binary\"\n\nenum { INSTALL_SUCCESS, INSTALL_ERROR, INSTALL_CORRUPT, INSTALL_RETRY };\n\nstatic const float VERIFICATION_PROGRESS_FRAC = 0.25;\n\nstruct RSADeleter {\n  void operator()(RSA* rsa) const {\n    RSA_free(rsa);\n  }\n};\n\nstruct ECKEYDeleter {\n  void operator()(EC_KEY* ec_key) const {\n    EC_KEY_free(ec_key);\n  }\n};\n\nstruct Certificate {\n    typedef enum {\n        KEY_TYPE_RSA,\n        KEY_TYPE_EC,\n    } KeyType;\n\n    Certificate(int hash_len_,\n                KeyType key_type_,\n                std::unique_ptr<RSA, RSADeleter>&& rsa_,\n                std::unique_ptr<EC_KEY, ECKEYDeleter>&& ec_)\n        : hash_len(hash_len_),\n          key_type(key_type_),\n          rsa(std::move(rsa_)),\n          ec(std::move(ec_)) {}\n\n    // SHA_DIGEST_LENGTH (SHA-1) or SHA256_DIGEST_LENGTH (SHA-256)\n    int hash_len;\n    KeyType key_type;\n    std::unique_ptr<RSA, RSADeleter> rsa;\n    std::unique_ptr<EC_KEY, ECKEYDeleter> ec;\n};\n\n/*\n * 'addr' and 'length' define an update package file that has been loaded (or mmap'ed, or\n * whatever) into memory. Verifies that the file is signed and the signature matches one of the\n * given keys. It optionally accepts a callback function for posting the progress to. Returns one\n * of the constants of VERIFY_SUCCESS and VERIFY_FAILURE.\n */\nint verify_file(const unsigned char* addr, size_t length, const std::vector<Certificate>& keys,\n                const std::function<void(float)>& set_progress = nullptr);\n\nbool load_keys(const char* filename, std::vector<Certificate>& certs);\n\n#define VERIFY_SUCCESS        0\n#define VERIFY_FAILURE        1\n\n#endif  /* _RECOVERY_VERIFIER_H */\n"
        },
        {
          "name": "verifier24",
          "type": "tree",
          "content": null
        },
        {
          "name": "vr_device.cpp",
          "type": "blob",
          "size": 0.7119140625,
          "content": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"device.h\"\n#include \"vr_ui.h\"\n\nDevice* make_device() {\n    return new Device(new VrRecoveryUI);\n}\n\n"
        },
        {
          "name": "vr_ui.cpp",
          "type": "blob",
          "size": 2.3212890625,
          "content": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"vr_ui.h\"\n\n#include <minui/minui.h>\n\nVrRecoveryUI::VrRecoveryUI() : kStereoOffset(RECOVERY_UI_VR_STEREO_OFFSET) {}\n\nint VrRecoveryUI::ScreenWidth() const {\n  return gr_fb_width() / 2;\n}\n\nint VrRecoveryUI::ScreenHeight() const {\n  return gr_fb_height();\n}\n\nvoid VrRecoveryUI::DrawSurface(GRSurface* surface, int sx, int sy, int w, int h, int dx,\n                               int dy) const {\n  gr_blit(surface, sx, sy, w, h, dx + kStereoOffset, dy);\n  gr_blit(surface, sx, sy, w, h, dx - kStereoOffset + ScreenWidth(), dy);\n}\n\nvoid VrRecoveryUI::DrawTextIcon(int x, int y, GRSurface* surface) const {\n  gr_texticon(x + kStereoOffset, y, surface);\n  gr_texticon(x - kStereoOffset + ScreenWidth(), y, surface);\n}\n\nint VrRecoveryUI::DrawTextLine(int x, int y, const char* line, bool bold) const {\n  gr_text(gr_sys_font(), x + kStereoOffset, y, line, bold);\n  gr_text(gr_sys_font(), x - kStereoOffset + ScreenWidth(), y, line, bold);\n  return char_height_ + 4;\n}\n\nint VrRecoveryUI::DrawHorizontalRule(int y) const {\n  y += 4;\n  gr_fill(kMarginWidth + kStereoOffset, y, ScreenWidth() - kMarginWidth + kStereoOffset, y + 2);\n  gr_fill(ScreenWidth() + kMarginWidth - kStereoOffset, y,\n          gr_fb_width() - kMarginWidth - kStereoOffset, y + 2);\n  return y + 4;\n}\n\nvoid VrRecoveryUI::DrawHighlightBar(int /* x */, int y, int /* width */, int height) const {\n  gr_fill(kMarginWidth + kStereoOffset, y, ScreenWidth() - kMarginWidth + kStereoOffset, y + height);\n  gr_fill(ScreenWidth() + kMarginWidth - kStereoOffset, y,\n          gr_fb_width() - kMarginWidth - kStereoOffset, y + height);\n}\n\nvoid VrRecoveryUI::DrawFill(int x, int y, int w, int h) const {\n  gr_fill(x + kStereoOffset, y, w, h);\n  gr_fill(x - kStereoOffset + ScreenWidth(), y, w, h);\n}\n"
        },
        {
          "name": "vr_ui.h",
          "type": "blob",
          "size": 1.4501953125,
          "content": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_VR_UI_H\n#define RECOVERY_VR_UI_H\n\n#include \"screen_ui.h\"\n\nclass VrRecoveryUI : public ScreenRecoveryUI {\n public:\n  VrRecoveryUI();\n\n protected:\n  // Pixel offsets to move drawing functions to visible range.\n  // Can vary per device depending on screen size and lens distortion.\n  const int kStereoOffset;\n\n  int ScreenWidth() const override;\n  int ScreenHeight() const override;\n\n  void DrawSurface(GRSurface* surface, int sx, int sy, int w, int h, int dx, int dy) const override;\n  int DrawHorizontalRule(int y) const override;\n  void DrawHighlightBar(int x, int y, int width, int height) const override;\n  void DrawFill(int x, int y, int w, int h) const override;\n  void DrawTextIcon(int x, int y, GRSurface* surface) const override;\n  int DrawTextLine(int x, int y, const char* line, bool bold) const override;\n};\n\n#endif  // RECOVERY_VR_UI_H\n"
        },
        {
          "name": "wear_device.cpp",
          "type": "blob",
          "size": 0.7138671875,
          "content": "/*\n * Copyright (C) 2017 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"device.h\"\n#include \"wear_ui.h\"\n\nDevice* make_device() {\n  return new Device(new WearRecoveryUI);\n}\n\n"
        },
        {
          "name": "wear_ui.cpp",
          "type": "blob",
          "size": 6.306640625,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"wear_ui.h\"\n\n#include <pthread.h>\n#include <stdio.h>  // TODO: Remove after killing the call to sprintf().\n#include <string.h>\n\n#include <string>\n\n#include <android-base/properties.h>\n#include <android-base/strings.h>\n#include <minui/minui.h>\n\nWearRecoveryUI::WearRecoveryUI()\n    : kProgressBarBaseline(RECOVERY_UI_PROGRESS_BAR_BASELINE),\n      kMenuUnusableRows(RECOVERY_UI_MENU_UNUSABLE_ROWS) {\n  // TODO: kMenuUnusableRows should be computed based on the lines in draw_screen_locked().\n\n  // TODO: The following three variables are likely not needed. The first two are detected\n  // automatically in ScreenRecoveryUI::LoadAnimation(), based on the actual files seen on device.\n  intro_frames = 22;\n  loop_frames = 60;\n\n  touch_screen_allowed_ = true;\n}\n\nint WearRecoveryUI::GetProgressBaseline() const {\n  return kProgressBarBaseline;\n}\n\n// Draw background frame on the screen.  Does not flip pages.\n// Should only be called with updateMutex locked.\n// TODO merge drawing routines with screen_ui\nvoid WearRecoveryUI::draw_background_locked() {\n  pagesIdentical = false;\n  gr_color(0, 0, 0, 255);\n  gr_fill(0, 0, gr_fb_width(), gr_fb_height());\n\n  if (currentIcon != NONE) {\n    GRSurface* frame = GetCurrentFrame();\n    int frame_width = gr_get_width(frame);\n    int frame_height = gr_get_height(frame);\n    int frame_x = (gr_fb_width() - frame_width) / 2;\n    int frame_y = (gr_fb_height() - frame_height) / 2;\n    gr_blit(frame, 0, 0, frame_width, frame_height, frame_x, frame_y);\n  }\n}\n\nstatic const char* SWIPE_HELP[] = {\n  \"Swipe up/down to move.\",\n  \"Swipe left/right to select.\",\n  \"\",\n  NULL\n};\n\n// TODO merge drawing routines with screen_ui\nvoid WearRecoveryUI::draw_screen_locked() {\n  char cur_selection_str[50];\n\n  draw_background_locked();\n  if (!show_text) {\n    draw_foreground_locked();\n  } else {\n    SetColor(TEXT_FILL);\n    gr_fill(0, 0, gr_fb_width(), gr_fb_height());\n\n    int y = kMarginHeight;\n    int x = kMarginWidth;\n    if (show_menu) {\n      std::string recovery_fingerprint =\n          android::base::GetProperty(\"ro.bootimage.build.fingerprint\", \"\");\n      SetColor(HEADER);\n      y += DrawTextLine(x + 4, y, \"Android Recovery\", true);\n      for (auto& chunk : android::base::Split(recovery_fingerprint, \":\")) {\n        y += DrawTextLine(x + 4, y, chunk.c_str(), false);\n      }\n\n      // This is actually the help strings.\n      y += DrawTextLines(x + 4, y, SWIPE_HELP);\n      SetColor(HEADER);\n      y += DrawTextLines(x + 4, y, menu_headers_);\n\n      // Show the current menu item number in relation to total number if\n      // items don't fit on the screen.\n      if (menu_items > menu_end - menu_start) {\n        sprintf(cur_selection_str, \"Current item: %d/%d\", menu_sel + 1, menu_items);\n        gr_text(gr_sys_font(), x + 4, y, cur_selection_str, 1);\n        y += char_height_ + 4;\n      }\n\n      // Menu begins here\n      SetColor(MENU);\n\n      for (int i = menu_start; i < menu_end; ++i) {\n        if (i == menu_sel) {\n          // draw the highlight bar\n          SetColor(MENU_SEL_BG);\n          gr_fill(x, y - 2, gr_fb_width() - x, y + char_height_ + 2);\n          // white text of selected item\n          SetColor(MENU_SEL_FG);\n          if (menu_[i][0]) {\n            gr_text(gr_sys_font(), x + 4, y, menu_[i].c_str(), 1);\n          }\n          SetColor(MENU);\n        } else if (menu_[i][0]) {\n          gr_text(gr_sys_font(), x + 4, y, menu_[i].c_str(), 0);\n        }\n        y += char_height_ + 4;\n      }\n      SetColor(MENU);\n      y += 4;\n      gr_fill(0, y, gr_fb_width(), y + 2);\n      y += 4;\n    }\n\n    SetColor(LOG);\n\n    // display from the bottom up, until we hit the top of the\n    // screen, the bottom of the menu, or we've displayed the\n    // entire text buffer.\n    int row = text_row_;\n    size_t count = 0;\n    for (int ty = gr_fb_height() - char_height_ - kMarginHeight; ty > y + 2 && count < text_rows_;\n         ty -= char_height_, ++count) {\n      gr_text(gr_sys_font(), x + 4, ty, text_[row], 0);\n      --row;\n      if (row < 0) row = text_rows_ - 1;\n    }\n  }\n}\n\n// TODO merge drawing routines with screen_ui\nvoid WearRecoveryUI::update_progress_locked() {\n  draw_screen_locked();\n  gr_flip();\n}\n\nvoid WearRecoveryUI::SetStage(int /* current */, int /* max */) {}\n\nvoid WearRecoveryUI::StartMenu(const char* const* headers, const char* const* items,\n                               int initial_selection) {\n  pthread_mutex_lock(&updateMutex);\n  if (text_rows_ > 0 && text_cols_ > 0) {\n    menu_headers_ = headers;\n    menu_.clear();\n    // \"i < text_rows_\" is removed from the loop termination condition,\n    // which is different from the one in ScreenRecoveryUI::StartMenu().\n    // Because WearRecoveryUI supports scrollable menu, it's fine to have\n    // more entries than text_rows_. The menu may be truncated otherwise.\n    // Bug: 23752519\n    for (size_t i = 0; items[i] != nullptr; i++) {\n      menu_.emplace_back(std::string(items[i], strnlen(items[i], text_cols_ - 1)));\n    }\n    menu_items = static_cast<int>(menu_.size());\n    show_menu = true;\n    menu_sel = initial_selection;\n    menu_start = 0;\n    menu_end = text_rows_ - 1 - kMenuUnusableRows;\n    if (menu_items <= menu_end) menu_end = menu_items;\n    update_screen_locked();\n  }\n  pthread_mutex_unlock(&updateMutex);\n}\n\nint WearRecoveryUI::SelectMenu(int sel) {\n  int old_sel;\n  pthread_mutex_lock(&updateMutex);\n  if (show_menu) {\n    old_sel = menu_sel;\n    menu_sel = sel;\n    if (menu_sel < 0) menu_sel = 0;\n    if (menu_sel >= menu_items) menu_sel = menu_items - 1;\n    if (menu_sel < menu_start) {\n      menu_start--;\n      menu_end--;\n    } else if (menu_sel >= menu_end && menu_sel < menu_items) {\n      menu_end++;\n      menu_start++;\n    }\n    sel = menu_sel;\n    if (menu_sel != old_sel) update_screen_locked();\n  }\n  pthread_mutex_unlock(&updateMutex);\n  return sel;\n}\n"
        },
        {
          "name": "wear_ui.h",
          "type": "blob",
          "size": 1.541015625,
          "content": "/*\n * Copyright (C) 2014 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef RECOVERY_WEAR_UI_H\n#define RECOVERY_WEAR_UI_H\n\n#include \"screen_ui.h\"\n\nclass WearRecoveryUI : public ScreenRecoveryUI {\n public:\n  WearRecoveryUI();\n\n  void SetStage(int current, int max) override;\n\n  // menu display\n  void StartMenu(const char* const* headers, const char* const* items,\n                 int initial_selection) override;\n  int SelectMenu(int sel) override;\n\n protected:\n  // progress bar vertical position, it's centered horizontally\n  const int kProgressBarBaseline;\n\n  // Unusable rows when displaying the recovery menu, including the lines for headers (Android\n  // Recovery, build id and etc) and the bottom lines that may otherwise go out of the screen.\n  const int kMenuUnusableRows;\n\n  int GetProgressBaseline() const override;\n\n  void update_progress_locked() override;\n\n private:\n  void draw_background_locked() override;\n  void draw_screen_locked() override;\n\n  int menu_start, menu_end;\n};\n\n#endif  // RECOVERY_WEAR_UI_H\n"
        },
        {
          "name": "zipwrap.cpp",
          "type": "blob",
          "size": 5.2861328125,
          "content": "/*\n * Copyright (C) 2017 bigbiff/Dees_Troy TeamWin\n * This file is part of TWRP/TeamWin Recovery Project.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"zipwrap.hpp\"\n#include <string>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n#ifdef USE_MINZIP\n#include \"minzip/Zip.h\"\n#include \"minzip/SysUtil.h\"\n#else\n#include <ziparchive/zip_archive.h>\n#include \"otautil/ZipUtil.h\"\n#include \"otautil/SysUtil.h\"\n#endif\n\nZipWrap::ZipWrap() {\n\tzip_open = false;\n}\n\nZipWrap::~ZipWrap() {\n\tif (zip_open)\n\t\tClose();\n}\n\nbool ZipWrap::Open(const char* file, MemMapping* map) {\n\tif (zip_open) {\n\t\tprintf(\"ZipWrap '%s' is already open\\n\", zip_file.c_str());\n\t\treturn true;\n\t}\n\tzip_file = file;\n#ifdef USE_MINZIP\n\tif (mzOpenZipArchive(map->addr, map->length, &Zip) != 0)\n\t\treturn false;\n#else\n\tif (OpenArchiveFromMemory(map->addr, map->length, file, &Zip) != 0)\n\t\treturn false;\n#endif\n\tzip_open = true;\n\treturn true;\n}\n\nvoid ZipWrap::Close() {\n\tif (zip_open)\n#ifdef USE_MINZIP\n\t\tmzCloseZipArchive(&Zip);\n#else\n\t\tCloseArchive(Zip);\n#endif\n\tzip_open = false;\n}\n\nbool ZipWrap::EntryExists(const string& filename) {\n#ifdef USE_MINZIP\n\tconst ZipEntry* file_location = mzFindZipEntry(&Zip, filename.c_str());\n\tif (file_location != NULL)\n\t\treturn true;\n\treturn false;\n#else\n\tZipString zip_string(filename.c_str());\n\tZipEntry file_entry;\n\n\tif (FindEntry(Zip, zip_string, &file_entry) != 0)\n\t\treturn false;\n\treturn true;\n#endif\n}\n\nbool ZipWrap::ExtractEntry(const string& source_file, const string& target_file, mode_t mode) {\n\tif (access(target_file.c_str(), F_OK) == 0 && unlink(target_file.c_str()) != 0)\n\t\tprintf(\"Unable to unlink '%s': %s\\n\", target_file.c_str(), strerror(errno));\n\t\n\tint fd = creat(target_file.c_str(), mode);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to create '%s'\\n\", target_file.c_str());\n\t\treturn false;\n\t}\n\n#ifdef USE_MINZIP\n\tconst ZipEntry* file_entry = mzFindZipEntry(&Zip, source_file.c_str());\n\tif (file_entry == NULL) {\n\t\tprintf(\"'%s' does not exist in zip '%s'\\n\", source_file.c_str(), zip_file.c_str());\n\t\treturn false;\n\t}\n\tint ret_val = mzExtractZipEntryToFile(&Zip, file_entry, fd);\n\tclose(fd);\n\n\tif (!ret_val) {\n\t\tprintf(\"Could not extract '%s'\\n\", target_file.c_str());\n\t\treturn false;\n\t}\n#else\n\tZipString zip_string(source_file.c_str());\n\tZipEntry file_entry;\n\n\tif (FindEntry(Zip, zip_string, &file_entry) != 0)\n\t\treturn false;\n\tint32_t ret_val = ExtractEntryToFile(Zip, &file_entry, fd);\n\tclose(fd);\n\n\tif (ret_val != 0) {\n\t\tprintf(\"Could not extract '%s'\\n\", target_file.c_str());\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\nbool ZipWrap::ExtractRecursive(const string& source_dir, const string& target_dir) {\n\tstruct utimbuf timestamp = { 1217592000, 1217592000 };  // 8/1/2008 default\n#ifdef USE_MINZIP\n\treturn mzExtractRecursive(&Zip, source_dir.c_str(), target_dir.c_str(), &timestamp, NULL, NULL, NULL);\n#else\n\treturn ExtractPackageRecursive(Zip, source_dir, target_dir, &timestamp, NULL);\n#endif\n}\n\nlong ZipWrap::GetUncompressedSize(const string& filename) {\n#ifdef USE_MINZIP\n\tconst ZipEntry* file_entry = mzFindZipEntry(&Zip, filename.c_str());\n\tif (file_entry == NULL) {\n\t\tprintf(\"'%s' does not exist in zip '%s'\\n\", filename.c_str(), zip_file.c_str());\n\t\treturn 0;\n\t}\n\treturn file_entry->uncompLen;\n#else\n\tZipString zip_string(filename.c_str());\n\tZipEntry file_entry;\n\n\tif (FindEntry(Zip, zip_string, &file_entry) != 0)\n\t\treturn 0;\n\treturn file_entry.uncompressed_length;\n#endif\n}\n\nbool ZipWrap::ExtractToBuffer(const string& filename, uint8_t* buffer) {\n#ifdef USE_MINZIP\n\tconst ZipEntry* file_entry = mzFindZipEntry(&Zip, filename.c_str());\n\tif (file_entry == NULL) {\n\t\tprintf(\"'%s' does not exist in zip '%s'\\n\", filename.c_str(), zip_file.c_str());\n\t\treturn false;\n\t}\n\tif (!mzExtractZipEntryToBuffer(&Zip, file_entry, buffer)) {\n\t\tprintf(\"Failed to read '%s'\\n\", filename.c_str());\n\t\treturn false;\n\t}\n#else\n\tZipString zip_string(filename.c_str());\n\tZipEntry file_entry;\n\n\tif (FindEntry(Zip, zip_string, &file_entry) != 0)\n\t\treturn false;\n\tif (ExtractToMemory(Zip, &file_entry, buffer, file_entry.uncompressed_length) != 0) {\n\t\tprintf(\"Failed to read '%s'\\n\", filename.c_str());\n\t\treturn false;\n\t}\n#endif\n\treturn true;\n}\n\n#ifdef USE_MINZIP\nloff_t ZipWrap::GetEntryOffset(const string& filename) {\n\tconst ZipEntry* file_entry = mzFindZipEntry(&Zip, filename.c_str());\n\tif (file_entry == NULL) {\n\t\tprintf(\"'%s' does not exist in zip '%s'\\n\", filename.c_str(), zip_file.c_str());\n\t\treturn 0;\n\t}\n\treturn mzGetZipEntryOffset(file_entry);\n}\n#else\noff64_t ZipWrap::GetEntryOffset(const string& filename) {\n\tZipString zip_string(filename.c_str());\n\tZipEntry file_entry;\n\n\tif (FindEntry(Zip, zip_string, &file_entry) != 0) {\n\t\tprintf(\"'%s' does not exist in zip '%s'\\n\", filename.c_str(), zip_file.c_str());\n\t\treturn 0;\n\t}\n\treturn file_entry.offset;\n}\n\nZipArchiveHandle ZipWrap::GetZipArchiveHandle() {\n\treturn Zip;\n}\n#endif\n"
        },
        {
          "name": "zipwrap.hpp",
          "type": "blob",
          "size": 1.626953125,
          "content": "/*\n * Copyright (C) 2017 bigbiff/Dees_Troy TeamWin\n * This file is part of TWRP/TeamWin Recovery Project.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __ZIPWRAP_HPP\n#define __ZIPWRAP_HPP\n\n#include <string>\n#ifdef USE_MINZIP\n#include \"minzip/Zip.h\"\n#include \"minzip/SysUtil.h\"\n#else\n#include <ziparchive/zip_archive.h>\n#include \"otautil/SysUtil.h\"\n#endif\n\nusing namespace std;\n\nclass ZipWrap {\n\tpublic:\n\t\tZipWrap();\n\t\t~ZipWrap();\n\n\t\tbool Open(const char* file, MemMapping* map);\n\t\tvoid Close();\n\t\tbool EntryExists(const string& filename);\n\t\tbool ExtractEntry(const string& source_file, const string& target_file, mode_t mode);\n\n\t\tlong GetUncompressedSize(const string& filename);\n\t\tbool ExtractToBuffer(const string& filename, uint8_t* begin);\n\t\tbool ExtractRecursive(const string& source_dir, const string& target_dir);\n#ifdef USE_MINZIP\n\t\tloff_t GetEntryOffset(const string& filename);\n#else\n\t\toff64_t GetEntryOffset(const string& filename);\n\t\tZipArchiveHandle GetZipArchiveHandle();\n#endif\n\n\tprivate:\n#ifdef USE_MINZIP\n\t\tZipArchive Zip;\n#else\n\t\tZipArchiveHandle Zip;\n#endif\n\t\tstring zip_file;\n\t\tbool zip_open;\n};\n\n#endif //__ZIPWRAP_HPP\n"
        }
      ]
    }
  ]
}