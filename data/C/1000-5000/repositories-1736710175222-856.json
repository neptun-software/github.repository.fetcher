{
  "metadata": {
    "timestamp": 1736710175222,
    "page": 856,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "simh/simh",
      "stars": 1688,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.583984375,
          "content": "# EditorConfig: https://editorconfig.org/\r\nroot = true\r\n\r\n[*.{c,h}]\r\ncharset = utf-8\r\nend_of_line = crlf\r\nindent_style = space\r\ninsert_final_newline = true\r\ntrim_trailing_whitespace = true\r\n\r\n# Makefiles\r\n[{{M,m}akefile,descrip.mms}]\r\ntrim_trailing_whitespace = true\r\nindent_style = tab\r\nend_of_line = crlf\r\ninsert_final_newline = true\r\n\r\n# Other text files\r\n[*.{txt,ini,md,simh,.editorconfig}]\r\ncharset = utf-8\r\nend_of_line = crlf\r\ntrim_trailing_whitespace = true\r\n\r\n# Git commit messages\r\n[{COMMIT_EDITMSG,MERGE_MSG}]\r\ntrim_trailing_whitespace = true\r\nmax_line_length = 80\r\nindent_style = space\r\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.2197265625,
          "content": "*.jpg binary\r\n*.png binary\r\n*.sln binary\r\n*.vcproj binary\r\n*.exe binary\r\n*.lda binary\r\n*.bin binary\r\n*.imd binary\r\n*.rim binary\r\n*.tap binary\r\n*.dsk binary\r\n*.vhd binary\r\n*.crd binary\r\n*.dck binary\r\nsim_rev.h export-subst\r\n\r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.8837890625,
          "content": ".git-commit-id\r\n.git-commit-id.h\r\n#ignore thumbnails created by windows\r\nThumbs.db\r\n#ignore Desktop Services Store created by OSX\r\n.DS_Store\r\n#Ignore files built by Visual Studio\r\n*.obj\r\n*.exe\r\n# VAX/vmb.exe is not a generated file and should be in the repository\r\n!VAX/vmb.exe\r\n*.pdb\r\n*.user\r\n*.aps\r\n*.pch\r\n*.vspscc\r\n*_i.c\r\n*_p.c\r\n*.ncb\r\n*.suo\r\n*.tlb\r\n*.tlh\r\n*.bak\r\n*.cache\r\n*.ilk\r\n*.log\r\n[Bb]in\r\n[Dd]ebug*/\r\n*.lib\r\n*.sbr\r\n*.bak\r\n*.save\r\nobj/\r\n[Rr]elease*/\r\n_ReSharper*/\r\n[Tt]est[Rr]esult*\r\n*.o\r\n*~\r\n*#\r\nBIN/\r\nipch/\r\n# We only care about specific files in the Visual Studio Projects \r\n# folder.  Things which are there on the fly to support debugging \r\n# or other things we don't want git to manage.\r\nVisual Studio Projects/*\r\n!Visual Studio Projects/*.vcproj\r\n!Visual Studio Projects/*.sln\r\nVisual Studio Projects/*-*.sln\r\n!Visual Studio Projects/0ReadMe_Projects.txt\r\n**/*.code-workspace\r\n**/.vscode/\r\n"
        },
        {
          "name": "0readmeAsynchIO.txt",
          "type": "blob",
          "size": 18.23828125,
          "content": "SIM_ASYNCH_IO\r\n\r\nTheory of operation.\r\n\r\nFeatures.\r\n   - Optional Use.  Build with or without SIM_ASYNCH_IO defined and\r\n     simulators will still build and perform correctly when run.\r\n     Additionally, a simulator built with SIM_ASYNCH_IO defined can\r\n     dynamically disable and reenable asynchronous operation with\r\n     the scp commands SET NOASYNCH and SET ASYNCH respectively.\r\n   - Consistent Save/Restore state.  The state of a simulator saved\r\n     on a simulator with (or without) Asynch support can be restored\r\n     on any simulator of the same version with or without Asynch\r\n     support.\r\n   - Optimal behavior/performance with simulator running with or\r\n     without CPU idling enabled.\r\n   - Consistent minimum instruction scheduling delays when operating\r\n     with or without SIM_ASYNCH_IO.  When SIM_ASYNCH_IO is enabled,\r\n     any operation which would have been scheduled to occur in 'n'\r\n     instructions will still occur (from the simulated computer's\r\n     point of view) at least 'n' instructions after it was initiated.\r\n\r\nBenefits.\r\n   - Allows a simulator to execute simulated instructions concurrently\r\n     with I/O operations which may take numerous milliseconds to perform.\r\n   - Allows a simulated device to potentially avoid polling for the\r\n     arrival of data.  Polling consumes host processor CPU cycles which\r\n     may better be spent executing simulated instructions or letting\r\n     other host processes run.  Measurements made of available\r\n     instruction execution easily demonstrate the benefits of parallel\r\n     instruction and I/O activities.  A VAX simulator with a process\r\n     running a disk intensive application in one process was able to\r\n     run (in another process) 11 times the number of Dhrystone operations\r\n     with Asynch I/O enabled vs not enabled.\r\n   - Allows simulator clock ticks to track wall clock was precisely as\r\n     possible under varying I/O load and activities.\r\n\r\nSimH Libraries which provide Asynch I/O support:\r\n   sim_disk\r\n   sim_tape\r\n   sim_ether\r\n   sim_console\r\n   sim_tmxr\r\n\r\nRequirements to use:\r\nThe Simulator's instruction loop needs to be modified to include a single\r\nline which checks for asynchronously arrived events.  The vax_cpu.c\r\nmodule added the following line indicated by >>>:\r\n\r\n\t\t/* Main instruction loop */\r\n\r\n        for ( ;; ) {\r\n\r\n        [...]\r\n>>>\t        AIO_CHECK_EVENT;\r\n        \tif (sim_interval <= 0) {                /* chk clock queue */\r\n        \t\ttemp = sim_process_event ();\r\n        \t\tif (temp)\r\n        \t\t\tABORT (temp);\r\n        \t\tSET_IRQL;                           /* update interrupts */\r\n        \t\t}\r\n\r\nA global variable (sim_asynch_latency) is used to indicate the \"interrupt\r\ndispatch latency\".  This variable is the number of nanoseconds between checks\r\nfor completed asynchronous I/O.  The default value is 4000 (4 usec) which\r\ncorresponds reasonably with simulated hardware.  This variable controls\r\nthe computation of sim_asynch_inst_latency which is the number of simulated\r\ninstructions in the sim_asynch_latency interval.  We are trying to avoid\r\nchecking for completed asynchronous I/O after every instruction since the\r\nactual checking every instruction can slow down execution.  Periodic checks\r\nprovide a balance which allows response similar to real hardware while also\r\nproviding minimal impact on actual instruction execution.  Meanwhile, if\r\nmaximal response is desired, then the value of sim_asynch_latency can be\r\nset sufficiently low to assure that sim_asynch_inst_latency computes to 1.\r\nThe sim_asynch_inst_latency is dynamically updated once per second in the\r\nsim_rtcn_calb routine where clock to instruction execution is dynamically\r\ndetermined.  A simulator would usually add register definitions\r\nto enable viewing and setting of these variables via scp:\r\n\r\n#if defined (SIM_ASYNCH_IO)\r\n    { DRDATA (LATENCY, sim_asynch_latency, 32), PV_LEFT },\r\n    { DRDATA (INST_LATENCY, sim_asynch_inst_latency, 32), PV_LEFT },\r\n#endif\r\n\r\nProgramming Disk and Tape devices to leverage Asynch I/O\r\n\r\nAsynch disk and tape I/O is provided through a callback model.  The callback\r\nis invoked when the desired I/O operation has completed.\r\n\r\nNaming conventions:\r\nAll of the routines implemented in sim_disk and sim_tape have been kept\r\nin place.  All routines which perform I/O have a variant routine available\r\nwith a \"_a\" appended to the the routine name with the addition of a single\r\nparameter which indicates the asynch completion callback routine.  For\r\nexample there now exists the routines:\r\n  t_stat sim_tape_rdrecf (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max);\r\n  t_stat sim_tape_rdrecf_a (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max, TAPE_PCALLBACK callback);\r\n\r\nThe Purpose of the callback function is to record the I/O completion status\r\nand then to schedule the activation of the unit.\r\n\r\nConsiderations:\r\nAvoiding multiple concurrent users of the unit structure.  While asynch\r\nI/O is pending on a Unit, the unit should not otherwise be on the event\r\nqueue.  The I/O completion will cause the Unit to be scheduled to run\r\nimmediately to actually dispatch control flow to the callback routine.\r\nThe callback routine is always called in the same thread which is\r\nexecuting instructions.  Since all simulator device data structures are\r\nonly referenced from this thread there are no host multi-processor cache\r\ncoherency issues to be concerned about.\r\n\r\nArguments to the callback routine:\r\nUNIT *, and IO Status\r\nRequirements of the Callback routine.\r\nThe callback routine must save the I/O completion status in a place\r\nwhich the next invocation of the unit service routine will reference\r\nand act on it.  This allows device code to return error conditions\r\nback to scp in a consistent way without regard to how the callback\r\nroutine (and the actual I/O) may have been executed.  When the callback\r\nroutine is called, it will already be on the simulator event queue with\r\nan event time which was specified when the unit was attached or via a\r\ncall to sim_disk_set_async.  If no value has been specified then it\r\nwill have been scheduled with a delay time of 0.  If a different event\r\nfiring time is desired, then the callback completion routine should\r\ncall sim_activate_abs to schedule the event at the appropriate time.\r\n\r\nRequired change in device coding.\r\nDevices which wish to leverage the benefits of asynch I/O must rearrange\r\nthe code which implements the unit service routine.  This rearrangement\r\nusually entails breaking the activities into two phases.  The first phase\r\n(I'll call the top half) involves performing whatever is needed to\r\ninitiate a call to perform an I/O operation with a callback argument.\r\nControl is then immediately returned to the scp event dispatcher.\r\nThe callback routine needs to be coded to stash away the io completion\r\nstatus and some indicator that an I/O has completed.\r\nThe top/bottom half separation of the unit service routine would be\r\ncoded to examine the I/O completion indicator and invoke the bottom half\r\ncode upon completion.  The bottom half code should clear the I/O\r\ncompletion indicator and then perform any activities which normally\r\nneed to occur after the I/O completes.  Care should be taken while\r\nperforming these top/bottom half activities to return to the scp event\r\ndispatcher with either SCPE_OK or an appropriate error code when needed.\r\nThe need to return error indications to the scp event dispatcher is why\r\nthe bottom half activities can't simply be performed in the\r\ncallback routine (the callback routine does not return a status).\r\nCare should also be taken to realize that local variables in the\r\nunit service routine will not directly survive between the separate\r\ntop and bottom half calls to the unit service routine.  If any such\r\ninformation must be referenced in both the top and bottom half code paths\r\nthen it must either be recomputed prior to the top/bottom half check\r\nor not stored in local variables of the unit service routine.\r\n\r\nSample Asynch I/O device implementations.\r\nThe pdp11_rq.c module has been refactored to leverage the asynch I/O\r\nfeatures of the sim_disk library.  The impact to this code to adopt the\r\nasynch I/O paradigm was quite minimal.\r\nThe pdp11_rp.c module has also been refactored to leverage the asynch I/O\r\nfeatures of the sim_disk library.  The impact to this code to adopt the\r\nasynch I/O paradigm was also quite minimal.  After conversion a latent\r\nbug in the VAX Massbus adapter implementation was illuminated due to the\r\nmore realistic delays to perform I/O operations.\r\nThe pdp11_tq.c module has been refactored to leverage the asynch I/O\r\nfeatures of the sim_tape library.  The impact to this code to adopt the\r\nasynch I/O paradigm was very significant. This was due to the two facts:\r\n1) there are many different operations which can be requested of tape\r\ndevices and 2) some of the tmscp operations required many separate\r\noperations on the physical device layer to perform a single tmscp request.\r\nThis issue was addressed by adding additional routines to the physical\r\ndevice layer (in sim_tape.c) which combined these multiple operations.\r\nThis approach will dovetail well with a potential future addition of\r\noperations on physical tapes as yet another supported tape format.\r\n\r\nProgramming Console and Multiplexer devices to leverage Asynch I/O to\r\nminimize 'unproductive' polling.\r\n\r\nThere are two goals for asynchronous Multiplexer I/O: 1) Minimize polling\r\nto only happen when data is available, not arbitrarily on every clock tick,\r\nand 2) to have polling actually happen as soon as data may be available.\r\nIn most cases no effort is required to add Asynch I/O support to a\r\nmultiplexer device emulation.  If a device emulation takes the normal\r\nmodel of polling for arriving data on every simulated clock tick, then if\r\nAsynch I/O is enabled, the device will operate asynchronously and behave\r\nwell.  There is one restriction in this model.  Specifically,  the device\r\nemulation logic can't expect that there will be a particular number (clock\r\ntick rate maybe) of invocations of a unit service routine to perform polls\r\nin any interval of time (this is what we're trying to change, right?).\r\nTherefore presumptions about measuring time by counting polls is not\r\nvalid.  If a device needs to manage time related activities, then the\r\ndevice should create a separate unit which is dedicated to the timing\r\nactivities and which explicitly schedules a different unit service routine\r\nfor those activities as needed.  Such scheduled polling should only be\r\nenabled when actual timing is required.\r\n\r\nA device which is unprepared to operate asynchronously can specifically\r\ndisable multiplexer Asynch I/O for that device by explicitly defining\r\nNO_ASYNCH_MUX at compile time.  This can be defined at the top of a\r\nparticular device emulation which isn't capable of asynch operation, or\r\nit can be defined globally on the compile command line for the simulator.\r\nAlternatively, if a specific Multiplexer device doesn't function correctly\r\nunder the multiplexer asynchronous environment and it will never be\r\nrevised to operate correctly, it may statically set the TMUF_NOASYNCH bit\r\nin its unit flags field.\r\n\r\nSome devices will need a small amount of extra coding to leverage the\r\nMultiplexer Asynch I/O capabilities.  Devices which require extra coding\r\nhave one or more of the following characteristics:\r\n- they poll for input data on a different unit (or units) than the unit\r\n  which was provided when tmxr_attach was called.\r\n- they poll for connections on a different unit than the unit which was\r\n  provided when tmxr_attach was called.\r\n\r\nThe extra coding required for proper operation is to call\r\ntmxr_set_line_unit() to associate the appropriate input polling unit to\r\nthe respective multiplexer line (ONLY if input polling is done by a unit\r\ndifferent than the unit specified when the MUX was attached). If output\r\npolling is done on a different unit, then tmxr_set_line_output_unit()\r\nshould be called to describe that fact.\r\n\r\nConsole I/O can operate asynchronously if the simulator notifies the\r\ntmxr/console subsystem which device unit is used by the simulator to poll\r\nfor console input and output units.  This is done by including sim_tmxr.h\r\nin the source module which contains the console input device definition\r\nand calling tmxr_set_console_units().  tmxr_set_console_units would usually\r\nbe called in a device reset routine.\r\n\r\nsim_tmxr consumers:\r\n  - Altair Z80 SIO   devices = 1, units = 1,      lines = 4,  flagbits = 8, Untested Asynch\r\n  - HP2100 BACI      devices = 1, units = 1,      lines = 1,  flagbits = 3, Untested Asynch\r\n  - HP2100 MPX       devices = 1, units = 10,     lines = 8,  flagbits = 2, Untested Asynch\r\n  - HP2100 MUX       devices = 3, units = 1/16/1, lines = 16, flagbits = 4, Untested Asynch\r\n  - I7094 COM        devices = 2, units = 4/33,   lines = 33, flagbits = 4, Untested Asynch\r\n  - Interdata PAS    devices = 2, units = 1/32,   lines = 32, flagbits = 3, Untested Asynch\r\n  - Nova QTY         devices = 1, units = 1,      lines = 64, flagbits = 1, Untested Asynch\r\n  - Nova TT1         devices = 2, units = 1/1,    lines = 1,  flagbits = 1, Untested Asynch\r\n  - PDP-1 DCS        devices = 2, units = 1/32,   lines = 32, flagbits = 0, Untested Asynch\r\n  - PDP-8 TTX        devices = 2, units = 1/4,    lines = 4,  flagbits = 0, Untested Asynch\r\n  - PDP-11 DC        devices = 2, units = 1/16,   lines = 16, flagbits = 5, Untested Asynch\r\n  - PDP-11 DL        devices = 2, units = 1/16,   lines = 16, flagbits = 3, Untested Asynch\r\n  - PDP-11 DZ        devices = 1, units = 1/1,    lines = 32, flagbits = 0, Good Asynch\r\n  - PDP-11 VH        devices = 1, units = 4,      lines = 32, flagbits = 4, Good Asynch\r\n  - PDP-18b TT1      devices = 2, units = 1/16,   lines = 16, flagbits = 0, Untested Asynch\r\n  - SDS MUX          devices = 2, units = 1/32,   lines = 32, flagbits = 0, Untested Asynch\r\n  - sim_console                                                             Good Asynch\r\n\r\nProgram Clock Devices to leverage Asynch I/O\r\n\r\nsimh's concept of time is calibrated by counting the number of\r\ninstructions which the simulator can execute in a given amount of wall\r\nclock time.  Once this is determined, the appropriate value is continually\r\nrecalibrated and used throughout a simulator to schedule device time\r\nrelated delays as needed.  Historically, this was fine until modern\r\nprocessors started having dynamically variable processor clock rates.\r\nOn such host systems, the simulator's concept of time passing can vary\r\ndrastically.  This dynamic adjustment of the host system's execution rate\r\nmay cause dramatic drifting of the simulated operating system's concept\r\nof time.  Once all devices are disconnected from the calibrated clock's\r\ninstruction count, the only concern for time in the simulated system is\r\nthat it's clock tick be as accurate as possible.  This has worked well\r\nin the past, however each simulator was burdened with providing code\r\nwhich facilitated managing the concept of the relationship between the\r\nnumber of instructions executed and the passage of wall clock time.\r\nTo accomodate the needs of activities or events which should be measured\r\nagainst wall clock time (vs specific number of instructions executed),\r\nthe simulator framework has been extended to specifically provide event\r\nscheduling based on elapsed wall time. A new API can be used by devices\r\nto schedule unit event delivery after the passage of a specific amount\r\nof wall clock time.  The api sim_activate_after() provides this\r\ncapability.  This capability is not limited to being available ONLY when\r\ncompiling with SIM_SYNCH_IO defined.  When SIM_ASYNCH_IO is defined, this\r\nfacility is implemented by a thread which drives the delivery of these\r\nevents from the host system's clock ticks (interpolated as needed to\r\naccomodate hosts with relatively large clock ticks).  When SIM_ASYNCH_IO\r\nis not defined, this facility is implemented using the traditional simh\r\ncalibrated clock approach.  This new approach has been measured to provide\r\nclocks which drift far less than the drift realized in prior simh versions.\r\nUsing the released simh v3.9-0 vax simulator with idling enabled, the clock\r\ndrifted some 4 minutes in 35 minutes time (approximately 10%).  The same OS\r\ndisk also running with idling enabled booted for 4 hours had less that 5\r\nseconds of clock drift (approximately 0.03%).\r\n\r\nCo-Scheduling Clock and Multiplexer (or other devices)\r\n\r\nMany simulator devices have needs to periodically executed with timing on the\r\norder of the simulated system's clock ticks.  There are numerous reasons for\r\nthis type of execution.  Meanwhile, many of these events aren't particular\r\nabout exactly when they execute as long as they execute frequently enough.\r\nFrequently executing events has the potential to interfere with a simulator's\r\nattempts to idle when the simulated system isn't actually doing useful work.\r\n\r\nInteractions with attempts to 'co-schedule' multiplexer polling with clock\r\nticks can cause strange simulator behaviors.  These strange behaviors only\r\nhappen under a combination of conditions:\r\n  1) a multiplexer device is defined in the simulator configuration,\r\n  2) the multiplexor device is NOT attached, and thus is not being managed by\r\n     the asynchronous multiplexer support\r\n  3) the multiplexer device schedules polling (co-scheduled) when not\r\n     attached (such polling will never produce any input, so this is probably\r\n     a bug).\r\nIn prior simh versions support for clock co-scheduling was implemented\r\nseparately by each simulator, and usually was expressed by code of the form:\r\n    sim_activate (uptr, clk_cosched (tmxr_poll));\r\nAs a part of asynchronous timer support, the simulator framework has been\r\nextended to generically provide clock co-scheduling support.  The use of this\r\nnew capability requires an initial call (usually in the clock device reset\r\nrouting) of the form:\r\n    sim_register_clock_unit (&clk_unit);\r\nOnce the clock unit has been registered, co-scheduling is achieved by replacing\r\nthe earlier sim_activate with the following:\r\n    sim_clock_coschedule (&dz_unit, tmxr_poll);\r\n\r\nRun time requirements to use SIM_ASYNCH_IO.\r\nThe Posix threads API (pthreads) is required for asynchronous execution.\r\nMost *nix platforms have these APIs available and on these platforms\r\nsimh is typically built with these available since on these platforms,\r\npthreads is required for simh networking support.  Windows can also\r\nutilize the pthreads APIs if the compile and run time support for the\r\nwin32Pthreads package has been installed on the build system.\r\n\r\n"
        },
        {
          "name": "0readme_39.txt",
          "type": "blob",
          "size": 5.138671875,
          "content": "Notes For V3.9\r\n\r\n\r\nThe makefile now works for all *nix platforms and with cygwin and MinGW32 \r\non Windows.  It will automatically detect the availability of libpcap \r\ncomponents and build network capable simulators if they are available.\r\n\r\n\r\n1. New Features\r\n\r\n1.1 3.9-0\r\n\r\n1.1.1 SCP and libraries\r\n\r\n\t- added *nix READLINE support (Mark Pizzolato)\r\n\t- added \"SHOW SHOW\" and \"SHOW <dev> SHOW\" commands (Mark Pizzolato)\r\n\t- added support for BREAK key on Windows (Mark Pizzolato)\r\n\t- added ethernet support (Mark Pizzolato)\r\n\t     windows host <-> simulator NIC sharing\r\n\t     native tap interfaces on BSD, Linux and OSX\r\n\t     vde (Virtual Distributed Ethernet) networking\r\n\t     Large Send Offload support\r\n\t     UDP and TCP Checksum offload support\r\n\t     dynamic libpcap loading on *nix platforms\r\n\r\n1.1.2 PDP-8\r\n\r\n\t- floating point processor is now enabled\r\n\r\n1.1.3 HP2100 (Dave Bryan)\r\n\r\n\t- added support for 12821A HP-IB disk controller,\r\n\t  7906H/20H/25H disks\r\n\r\n1.1.4 PDP11 and VAX (Mark Pizzolato)\r\n\r\n        - added DELQA-Plus device\r\n\r\n1.1.5 IA64 VMS Ethernet Support\r\n\r\n        - identified compiler version issues and added IA64 support (Matt Burke)\r\n        \r\n\r\n2. Bugs Fixed\r\n\r\nPlease see the revision history on http://simh.trailing-edge.com or\r\nin the source module sim_rev.h.\r\n\r\n\r\n3. Status Report\r\n\r\nThis is the last release of SimH for which I will be lead editor. After this\r\nrelease, the source is moving to a public repository:\r\n\r\nhttps://github.com/simh/simh\r\n\r\nunder the general editorship of Dave Hittner and Mark Pizzolato. The status\r\nof the individual simulators is as follows:\r\n\r\n3.1 PDP-1\r\n\r\nStable and working; runs available software.\r\n\r\n3.2 PDP-4/7/9/15\r\n\r\nStable and working; runs available software.\r\n\r\n3.3 PDP-8\r\n\r\nStable and working; runs available software.\r\n\r\n3.4 PDP-10 [KS-10 only]\r\n\r\nStable and working; runs available software.\r\n\r\n3.5 PDP-11\r\n\r\nStable and working; runs available system software. The emulation of individual\r\nmodels has numerous errors of detail, which prevents many diagnostics from\r\nrunning correctly.\r\n\r\n3.6 VAX-11/780\r\n\r\nStable and working; runs available software.\r\n\r\n3.7 MicroVAX 3900 (VAX)\r\n\r\nStable and working; runs available software. Thanks to the kind generosity of\r\nCamiel Vanderhoeven, this simulator has been verified with AXE, the VAX\r\narchitectural exerciser.\r\n\r\n3.8 Nova\r\n\r\nStable and working; runs available software.\r\n\r\n3.9 Eclipse\r\n\r\nStable and working, but not really supported. There is no Eclipse-specific\r\nsoftware available under a hobbyist license.\r\n\r\n3.10 Interdata 16b\r\n\r\nStable and working, but no software for it has been found, other than\r\ndiagnostics.\r\n\r\n3.11 Interdata 32b\r\n\r\nStable and working; runs 32b UNIX and diagnostics.\r\n\r\n3.12 IBM 1401\r\n\r\nStable and working; runs available software.\r\n\r\n3.13 IBM 1620\r\n\r\nHand debug only. No software for it has been found or tested.\r\n\r\n3.14 IBM 7094\r\n\r\nStable and working as a stock system; runs IBSYS. The CTSS extensions\r\nhave not been debugged.\r\n\r\n3.15 IBM S/3\r\n\r\nStable and working, but not really supported. Runs available software.\r\n\r\n3.16 IBM 1130\r\n\r\nStable and working; runs available software. Supported and edited by\r\nBrian Knittel.\r\n\r\n3.17 HP 2100/1000\r\n\r\nStable and working; runs available software. Supported and edited by\r\nDave Bryan.\r\n\r\n3.18 Honeywell 316/516\r\n\r\nStable and working; runs available software.\r\n\r\n3.19 GRI-909/99\r\n\r\nHand debug only. No software for it has been found or tested.\r\n\r\n3.20 SDS-940\r\n\r\nHand debug only, and a few diagnostics.\r\n\r\n3.21 LGP-30\r\n\r\nUnfinished; hand debug only. Does not run available software, probably\r\ndue to my misunderstanding of the LGP-30 operational procedures.\r\n\r\n3.22 Altair (original 8080 version)\r\n\r\nStable and working, but not really supported. Runs available software.\r\n\r\n3.23 AltairZ80 (Z80 version)\r\n\r\nStable and working; runs available software. Supported and edited by\r\nPeter Schorn.\r\n\r\n3.24 SWTP 6800\r\n\r\nStable and working; runs available software. Supported and edited by\r\nBill Beech\r\n\r\n3.25 Sigma 32b\r\n\r\nIncomplete; more work is needed on the peripherals for accuracy.\r\nIncluded in the beta simulators package.\r\n\r\n3.26 Alpha\r\n\r\nIncomplete; essentially just an EV-5 (21164) chip emulator. Included\r\nin the beta simulators package.\r\n\r\n3.27 SAGE\r\n\r\nIncomplete. Included in the beta simulators package.\r\n\r\n3.28 SC1\r\n\r\nInternal simulator for SiCortex supercomputer; intended as an example\r\nof implementing an SMP system in the current SimH structure. Included\r\nin the beta simulators package.\r\n\r\n\r\n4. Suggestions for Future Work\r\n\r\n4.1 General Structure\r\n\r\n\t- Multi-threading, to allow true concurrency between SCP and the simulator\r\n\t- Graphics device support, particularly for the PDP-1 and PDP-11\r\n\r\n4.2 Current Simulators\r\n\r\n\t- PDP-1 graphics, to run Space War\r\n\t- PDP-11 GT40 graphics, to run Lunar Lander\r\n\t- PDP-15 MUMPS-15\r\n\t- Interdata native OS debug, both 16b and 32b\r\n\t- SDS 940 timesharing operating system debug\r\n\t- IBM 7094 CTSS feature debug and operating system debug\r\n\t- IBM 1620 debug and software\r\n\t- GRI-909 software\r\n\t- Sigma 32b completion and debug\r\n\t- LGP-30 debug\r\n\r\n4.3 Possible Future Simulators\r\n\r\n\t- Data General MV8000 (if a hobbyist license can be obtained for AOS)\r\n\t- Alpha simulator\r\n\t- HP 3000 (16b) simulator with MPE\r\n"
        },
        {
          "name": "0readme_ethernet.txt",
          "type": "blob",
          "size": 37.6806640625,
          "content": "This file contains information about the SIMH Ethernet package.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nThe XQ emulator is a host-independent software emulation of Digital's\r\nDELQA-T (M7516-YM), DELQA (M7516) and DEQNA (M7504) Q-bus Ethernet cards\r\nfor the SIMH emulator.\r\n\r\nThe XU emulator is a host-independent software emulation of Digital's DEUNA\r\n(M7792/M7793) and DELUA (M7521) Unibus Ethernet cards for the SIMH emulator.\r\n\r\nThe XQ and XU simulators use the Sim_Ether module to execute host-specific\r\npacket reads and writes, since all operating systems talk to real Ethernet\r\ncards/controllers differently. See the comments at the top of sim_ether.c\r\nfor the list of currently supported host platforms.\r\n\r\nThe Sim_Ether module sets the selected Ethernet card into\r\npromiscuous mode to gather all packets, then filters out the packets that it\r\ndoesn't want. In Windows, packets having the same source MAC address as the\r\ncontroller are ignored for WinPCAP compatibility (see Windows notes below).\r\n\r\nIf your Ethernet card is plugged into a switch, the promiscuous mode setting\r\nshould not cause much of a problem, since the switch will still filter out\r\nmost of the undesirable traffic. You will only see \"excessive\" traffic if you\r\nare on a direct or hub(repeater) segment.\r\n\r\nOn Windows using the WinPcap interface, the simulated computer can \"talk\" to\r\nthe host computer on the same interface.  On other platforms with libpcap\r\n(*nix), the simulated computer can not \"talk\" to the host computer via the\r\nselected interface, since simulator transmitted packets are not received\r\nby the host's network stack. The workaround for this is to use a second NIC\r\nin the host and connect them both into the same network; then the host and\r\nthe simulator can communicate over the physical LAN.\r\n\r\nIntegrated Universal TUN/TAP support provides another solution for the above\r\ndual-NIC problem for systems that support Universal TUN/TAP. Since the TUN/TAP\r\ninterface is a pseudo network interface, the host can create a TAP device for\r\nthe simulator and then bridge or route packets between the TAP device and the\r\nreal network interface. Note that the TAP device and any bridging or routing\r\nmust be established before running the simulator; SIMH does not create,\r\nbridge, or route TAP devices for you.\r\n\r\nIntegrated Universal TUN/TAP support can be used for host<->simulator network\r\ntraffic (on the platforms where it is available) by using the SIMH command:\r\n\"attach xq tap:tapN\" (i.e. attach xq tap:tap0).  Platforms that this has been\r\ntested on include: Linux, FreeBSD, OpenBSD, NetBSD and OSX.  Each of these\r\nplatforms has some way to create a tap pseudo device (and possibly then to\r\nbridge it with a physical network interface).\r\n\r\nThe following steps were performed to get a working SIMH vax simulator\r\nsharing a physical NIC and allowing Host<->SIMH vax communications:\r\n\r\nLinux (Ubuntu 10.04):\r\n    apt-get install make\r\n    apt-get install libpcap-dev\r\n    apt-get install bridge-utils\r\n    apt-get install uml-utilities\r\n\r\n\r\n    #!/bin/sh\r\n    HOSTIP=`/sbin/ifconfig eth0 | grep \"inet addr\" | gawk -- '{ print $2 }' | gawk -F : -- '{ print $2 }'`\r\n    HOSTNETMASK=`/sbin/ifconfig eth0 | grep \"inet addr\" | gawk -- '{ print $4 }' | gawk -F : -- '{ print $2 }'`\r\n    HOSTBCASTADDR=`/sbin/ifconfig eth0 | grep \"inet addr\" | gawk -- '{ print $3 }' | gawk -F : -- '{ print $2 }'`\r\n    HOSTDEFAULTGATEWAY=`/sbin/route -n | grep ^0.0.0.0 | gawk -- '{ print $2 }'`\r\n    #\r\n    /usr/sbin/tunctl -t tap0 [-u someuser]\r\n    /sbin/ifconfig tap0 up\r\n    #\r\n    # Now convert eth0 to a bridge and bridge it with the TAP interface\r\n    /usr/sbin/brctl addbr br0\r\n    /usr/sbin/brctl addif br0 eth0\r\n    /usr/sbin/brctl setfd br0 0\r\n    /sbin/ifconfig eth0 0.0.0.0\r\n    /sbin/ifconfig br0 $HOSTIP netmask $HOSTNETMASK broadcast $HOSTBCASTADDR up\r\n    # set the default route to the br0 interface\r\n    /sbin/route add -net 0.0.0.0/0 gw $HOSTDEFAULTGATEWAY\r\n    # bridge in the tap device\r\n    /usr/sbin/brctl addif br0 tap0\r\n    /sbin/ifconfig tap0 0.0.0.0\r\n\r\n    # Run simulator and \"attach xq tap:tap0\"\r\n\r\n\r\nLinux (Fedora Core 18, 20, CentOS, RedHat, etc.):\r\n    yum install gcc\r\n    yum install libpcap-devel\r\n    yum install uml-utilities\r\n\r\nLinux (Centos 6.x):\r\n    yum install gcc\r\n    yum install libpcap-devel\r\n    yum install uml_utilities\r\n\r\nOpenBSD (OpenBSD 4.6)\r\n\r\n    /sbin/ifconfig tun0 create\r\n    /sbin/ifconfig tun0 link0\r\n    /sbin/ifconfig tun0 up\r\n\r\n    /sbin/ifconfig bridge0 create\r\n    /sbin/brconfig bridge0 fwddelay 4\r\n    /sbin/brconfig bridge0 add em0 add tun0  # Change em0 to reflect your physical NIC name\r\n    /sbin/brconfig bridge0 up\r\n\r\n    # Run simulator and \"attach xq tap:tun0\"\r\n\r\nFreeBSD (FreeBSD 11.3)\r\n\r\n    /sbin/sysctl net.link.tap.up_on_open=1\r\n    /sbin/ifconfig tap0 create\r\n    /sbin/ifconfig tap0 up\r\n\r\n    /sbin/ifconfig bridge0 create\r\n    /sbin/ifconfig bridge0 addm em0 addm tap0 # Change em0 to reflect your physical NIC name\r\n    /sbin/ifconfig bridge0 up\r\n\r\n    # Run simulator and \"attach xq tap:tap0\"\r\n\r\nNetBSD (NetBSD 5.0.2)\r\n\r\n    /sbin/ifconfig tap0 create\r\n    /sbin/ifconfig tap0 up\r\n\r\n    /sbin/ifconfig bridge0 create\r\n    /sbin/brconfig bridge0 fwddelay 1\r\n    /sbin/brconfig bridge0 add wm0 add tap0  # Change wm0 to reflect your physical NIC name\r\n    /sbin/brconfig bridge0 up\r\n\r\n    # Run simulator and \"attach xq tap:tap0\"\r\n\r\nOSX (Snow Leopard)\r\n    OSX Does NOT have native support for tun/tap interfaces.  It also does not have native\r\n    support for bridging.\r\n\r\n    Mattias Nissler has created tun/tap functionality available at http://tuntaposx.sourceforge.net/\r\n\r\n    We'll punt on bridging for the sake of this example and move on to use a basic tap\r\n    based internal network so a host and guest can communicate directly.\r\n\r\n    Download the install package from:\r\n    http://sourceforge.net/projects/tuntaposx/files/tuntap/20111101/tuntap_20111101.tar.gz\r\n\r\n    Expand the tarball to a directory.\r\n    Invoke the package installer tuntap_20111101.pkg\r\n    Click through the various prompts accepting things and eventually installing the package.\r\n\r\n    # Build and Run simulator and:\r\n       sim> attach xq tap:tap0\r\n       sim> ! ifconfig tap0 192.168.6.1 netmask 255.255.255.0\r\n\r\n    Simulated system uses IP address 192.168.6.2 and host uses 192.168.6.1\r\n    and things work.\r\n    You must run as root for this to work.\r\n\r\n-------------------------------------------------------------------------------\r\nAn alternative to direct pcap and tun/tap networking on *nix environments is\r\nVDE (Virtual Distributed Ethernet).\r\n\r\nNote 1: Using vde based networking is likely more flexible, but it isn't\r\n        nearly as efficient.  Host OS overhead will always be higher when\r\n        vde networking is used as compared to native pcap and/or tun/tap\r\n        networking.\r\nNote 2: Root access will likely be needed to configure or start the vde\r\n        environment prior to starting a simulator which may use it.\r\nNote 3: Simulators running using VDE networking can run without root\r\n        privilege.\r\n\r\nLinux (Ubuntu 11.10):\r\n    apt-get install make\r\n    apt-get install libvdeplug2-dev\r\n    apt-get install vde2\r\n\r\n    vde_switch -s /tmp/switch1 -tap tap0 -m 666\r\n    ifconfig tap0 192.168.6.1 netmask 255.255.255.0 up\r\n\r\n    # Build and Run simulator and:\r\n       sim> attach xq vde:/tmp/switch1  #simulator uses IP address 192.168.6.2\r\n\r\nOSX:\r\n    The macports package manager (http://www.macports.org) can be used to\r\n    install the net/vde2 package.\r\n\r\n-------------------------------------------------------------------------------\r\nAnother alternative to direct pcap and tun/tap networking on all environments is\r\nNAT (SLiRP) networking.  NAT networking is limited to only IP network protocols\r\nso DECnet, LAT and Clusting can't work on a NAT connected interface, but this may\r\nbe the easiest solution for many folks.\r\n\r\n       sim> attach xq nat:\r\n\r\nThe simulator can use static IP addresses of 10.0.2.4 thru 10.0.2.14 with a\r\nnetmask of 255.255.255.0 and a gateway of 10.0.2.2 and a nameserver of 10.0.2.3.\r\nIf the simulated machine uses DHCP it will get the address 10.0.2.15.  Various\r\nNAT based parameters can be configured on the attach command.  HELP XQ ATTACH\r\nwill provide useful information.  Host to simulator connectivity can be\r\nachieved for a simulator which gets its IP address via DHCP with the following\r\ncommand:\r\n\r\n       sim> attach xq nat:tcp=2323:10.0.2.15:23,tcp=2121:10.0.2.15:21\r\n\r\nThe host computer can telnet to localhost:2323 to reach the simulator via\r\ntelnet, etc.\r\n\r\nAdditionally NAT based networking is useful to allow host systems with WiFi\r\nnetworking to a) reach the simulated system and b) allow the simulated system\r\nto reach out to the Internet.\r\n\r\nNote: As mentioned above, NAT networking is specifically capable of providing\r\n      TCP/IP connectivity.  Only expect TCP and UDP traffic to pass through\r\n      the interface.  Do not expect ICMP traffic (ping mostly) to traverse\r\n      the NAT boundary.  This restriction is a consequence of host platform\r\n      and network limitations regarding direct user mode code generating ICMP\r\n      packets.\r\n\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nWindows notes:\r\n 1. The Npcap package available from https://nmap.org/npcap is the preferred\r\n    interface for Windows 7 onward since the original WinPCAP 4.1.3 package\r\n    from https://www.winpcap.org/install/bin/WinPcap_4_1_3.exe is no longer\r\n    developed or supported. These packages for windows simulate the libpcap\r\n    package that is freely available for un*x systems.\r\n\r\n 2. You must *install* the Npcap or WinPCAP runtime package.\r\n\r\n 3. The first time the Npcap/WinPCAP driver is used, it will be dynamically\r\n    loaded, and the user must be an Administrator on the machine to do so.\r\n    If you need to run as an unprivileged user, you must set the \"npf\" driver\r\n    to autostart.\r\n    Current Npcap and WinPcap installers provide an option to configure this\r\n    at installation time, so if that choice is made, then there is no need for\r\n    administrator privileged to run simulators with network support.\r\n\r\n\r\nBuilding on Windows:\r\n You should be able to build with any of the free compiler environments\r\n available on the Windows platform.  If you want to use the Visual C++\r\n Express 2008 or 2010 interactive development environments, read the file\r\n \".\\Visual Studio Projects\\0ReadMe_Projects.txt\" for details about the\r\n required dependencies.  Alternatively, you can build simh with networking\r\n support using the MinGW GCC compiler environment (32 bit) or the cygwin\r\n environment.  Each of these Visual C++, MinGW and cygwin build environments\r\n require Npcap or WinPcap and Posix threading packages being available.\r\n These should be located in a directory structure parallel to the current\r\n simulator source directory.\r\n\r\n For Example, the directory structure should look like:\r\n\r\n    .../simh/simh-master/VAX/vax_cpu.c\r\n    .../simh/simh-master/scp.c\r\n    .../simh/simh-master/Visual Studio Projects/simh.sln\r\n    .../simh/simh-master/Visual Studio Projects/VAX.vcproj\r\n    .../simh/simh-master/BIN/Nt/Win32-Release/vax.exe\r\n    .../simh/windows-build/pthreads/pthread.h\r\n    .../simh/windows-build/winpcap/WpdPack/Include/pcap.h\r\n\r\n The contents of the windows-build directory can be downloaded from:\r\n\r\n    https://github.com/simh/windows-build/archive/windows-build.zip\r\n\r\n This archive of dependent components for Windows simulators will\r\n automatically be downloaded, if needed, when building with Visual Studio.\r\n\r\n There are Windows batch files provided to initiate compiles using the MinGW\r\n compiler tool chain.  These batch files are located in the same directory\r\n as this file and are called: build_mingw.bat, build_mingw_ether.bat, and\r\n build_mingw_noasync.bat.  These batch files each presume that the MinGW\r\n toolchain is either in the current path or, if not that it is located at\r\n C:\\MinGW\\bin.  These batch files merely invoke the MinGW make (GNU make)\r\n passing some specific arguments along with the optional arguments the batch\r\n file is invoked with.\r\n\r\n The current windows network built binaries will run on any system without\r\n regard to whether or not Npcap or WinPcap is installed, and will provide\r\n Network functionality when Npcap or WinPcap is available.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nLinux, {Free|Net|Open}BSD, OS/X, and Un*x notes:\r\n\r\n----- WARNING ----- WARNING ----- WARNING ----- WARNING ----- WARNING -----\r\n\r\nSim_Ether has been reworked to be more universal; because of this, you will\r\nneed to get a version of libpcap that is 0.9 or greater. All current Linux\r\ndistributions provide a libpcap-dev package which has the needed version\r\nof libpcap and the required components to build applications using it.\r\nIf you are running an older Linux OS, you can download and build the required\r\nlibrary from www.tcpdump.org - see the comments at the top of Sim_ether.c\r\nfor details.\r\n\r\n----- WARNING ----- WARNING ----- WARNING ----- WARNING ----- WARNING -----\r\n\r\n 1. For all platforms, you must run SIMH(scp) with sufficient privilege to\r\n    allow the Ethernet card to be set into promiscuous mode and to write\r\n    packets through the driver.\r\n      a) For Windows systems this means having administrator privileges to\r\n         start the \"npf\" driver.  The current WinPcap installer offers an\r\n         option to autostart the \"npf\" driver when the system boots.\r\n         Starting the \"npf\" driver at boot time means that simulators do\r\n         not need to run with administrator privileges.\r\n      b) For more recent Linux systems, The concepts leveraging \"Filesystem\r\n         Capabilities\" can be used to specifically grant the simh binary\r\n         the needed privileges to access the network.  The article at:\r\n         http://packetlife.net/blog/2010/mar/19/sniffing-wireshark-non-root-user/\r\n         describes how to do this for wireshark.  The exact same capabilities\r\n         are needed by SIMH for network support.  Use that article as a guide.\r\n      c) For Unix/Unix-like systems which use bpf devices (NetBSD,\r\n         OpenBSD, FreeBSD and OS/X) it is possible to set permissions on\r\n         the bpf devices to allow read and write access to users other\r\n         than root (For example: chmod 666 /dev/bpf*).  Doing this, has\r\n         its own security issues.\r\n      d) For other platforms this will likely mean running as root.\r\n    Additional alternative methods for avoiding the 'run as root' requirement\r\n    will be welcomed.\r\n\r\n 2. If you want to use TAP devices, and any surrounding system network/bridge\r\n    setup must be done before running SIMH.  However, once that is done\r\n    (possibly at system boot time), using the TAP devices can be done without\r\n    root privileges.\r\n\r\nBuilding on Linux, {Free|Net|Open}BSD, OS/X, Solaris, other *nix:\r\n\r\n 1. Get/make/install the libpcap-dev package (or libpcap-devel) for your\r\n    operating system. Sources:\r\n      All    : http://www.tcpdump.org/\r\n      Older versions of libpcap can be found, for various systems, at:\r\n      Linux  :\r\n                Debian Based distributions:\r\n                       # apt-get install libpcap-dev\r\n                RedHat/Fedora Based distributions:\r\n                       # yum install libpcap-devel\r\n\r\n      OS/X   : The libpcap components are installed as part of the Xcode\r\n               developer package.  Instructions to install Xcode on various\r\n               OSX versions are available at:\r\n                  https://guide.macports.org/chunked/installing.xcode.html\r\n               Be sure to install the command line tools which are installed\r\n               with the command \"xcode-select --install\" in more recent\r\n               versions of the Apple developer support.\r\n\r\n      HP-UX  : ftp://hpux.connect.org.uk/hpux/Networking/Admin/\r\n\r\n\t    NOTE: The repositories for older versions of these platforms\r\n\t          don't contain a version of libpcap greater than 0.8.1.\r\n\t          However, most(all) recent releases of *nix environments\r\n\t          ship with sufficiently recent versions of libpcap either\r\n\t          automatically installed or available for installation as\r\n\t          part of the distribution.\r\n\t          The OS provided libpcap-dev components will be preferable\r\n\t          to a package built from www.tcpdump.org sources.  This is\r\n\t          due to the fact that various OS supplied packages will\r\n\t          depend on the OS supplied libpcap.  The improper build or\r\n\t          install of the www.tcpdump.org source package can conflict\r\n\t          with the OS provided one and break the OS provided\r\n\t          applications (i.e. tcpdump and/or wireshark) as well as\r\n\t          not working correctly for use by simh.\r\n\r\n 2. If you install the vendor supplied libpcap-dev package then the simh\r\n    makefile will automatically use the vendor supplied library without any\r\n    additional arguments.  If you have downloaded and built libpcap from\r\n    www.tcpdump.org, then the existing makefile will detect that this is\r\n    the case and try to use that.\r\n\r\n 3. The makefile defaults to building simulators with network support which\r\n    dynamically load the libpcap library.  This means that the same simulator\r\n    binaries will run on any system whether or not libpcap is installed.  If\r\n    you want to force direct libpcap linking during a build you do so by\r\n    typing 'make USE_NETWORK=1'.  You must build with gcc to do this.  There\r\n    is no observable benefit to directly linking against libpcap.  Support\r\n    for directly linking libpcap is deprecated on all platforms except\r\n    Linux and macOS where it has already been removed.\r\n\r\n 4. Some platforms (HP-UX in particular) may not have vendor supplied libpcap\r\n    components available and installed with the operating system.  The packages\r\n    which are available for this platform install include and library files in\r\n    user specified locations.  When building on these platforms the library\r\n    path must be specified on the make command line.  This can be done with:\r\n    'make LPATH=/usr/lib:/usr/local/lib'\r\n\r\n 5. Build it!\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nOpenVMS Alpha and OpenVMS Integrity (IA64) notes:\r\n  1. Ethernet support will only work on Alpha VMS 7.3-1 or later, which is\r\n     when required VCI promiscuous mode support was added. Hobbyists can\r\n     get the required version of VMS from the OpenVMS Alpha Hobbyist Kit 3.0.\r\n\r\n     Running a simulator built with Ethernet support on a version of VMS prior\r\n     to 7.3-1 will behave as if there is no Ethernet support built in due to\r\n     the inability of the software to set the PCAPVCM into promiscuous mode.\r\n\r\n     An example display of fully functional Ethernet support:\r\n       sim> SHOW XQ ETH\r\n       ETH devices:\r\n         0  we0 (VMS Device: _EWA0:)\r\n         1  we1 (VMS Device: _EWB0:)\r\n\r\n     An example display when the simulator was built without Ethernet support\r\n     or is not running the required version of VMS:\r\n       sim> SHOW XQ ETH\r\n       ETH devices:\r\n         no network devices are available\r\n\r\n  2. You must place the PCAPVCM.EXE execlet in SYS$LOADABLE_IMAGES before\r\n     running a simulator with Ethernet support.  Note: This is done by the\r\n     build commands in descrip.mms.\r\n\r\n  3. You must have CMKRNL privilege to SHOW or ATTACH an Ethernet device;\r\n     alternatively, you can INSTALL the simulator with CMKRNL privilege.\r\n\r\n  4. If you use a second adapter to communicate to the host, SOME protocol\r\n     that creates an I/O structure (SCS, DECNET, TCP) must be running on the\r\n     adapter prior trying to connect with SIMH, or the host may crash.\r\n     The execlet is not written to create an I/O structure for the device.\r\n\r\nBuilding on OpenVMS Alpha and OpenVMS Integrity (IA64):\r\n  The current descrip.mms file will build simulators capable of using\r\n  Ethernet support with them automatically.  These currently are: VAX,\r\n  VAX780, and PDP11.  The descrip.mms driven builds will also build the\r\n  pcap library and build and install the VCI execlet.\r\n\r\n  1. Fetch the VMS-PCAP zip file from:\r\n\t    http://simh.trailing-edge.com/sources/vms-pcap.zip\r\n  2. Unzip it into the base of the SIMH distribution directory.\r\n  3. Build the simulator(s) with MMS or MMK:\r\n         $ MMx {VAX,PDP11,PDP10, etc...}\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nVAX simulator support:\r\n\r\nAn OpenVMS VAX v7.3 system with DECNET Phase IV, MultiNet 5.4, and LAT 5.3 has\r\nbeen successfully run. Other testers have reported success booting NetBSD and\r\nOpenVMS VAX 5.5-2 also.\r\n\r\n\r\nPDP11 simulator support:\r\n\r\nAn RT-11 v5.3 system with a freeware TCP/IP stack has been successfully run.\r\nOther testers have reported that RSX with DECNET and the NetBSD operating\r\nsystems also work. RSTS/E v10.1 has preliminary support - RSTS/E boots and\r\nenables the XH (XQ) device - DECNET and LAT software have not been tested.\r\n\r\nThe XU module has been tested by a third party for basic packet functionality\r\nunder a modified RSX11M environment. I am unable to test it in-house until\r\nsomeone can arrange to send me a disk image containing a stock RSTS/E or\r\nRSX11M+ system image that also contains DECNET, LAT, and/or TCP/IP software.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nHow to debug problems with the Ethernet subsystems:\r\n\r\nPLEASE read the host-specific notes in sim_ether.c!\r\n\r\nWhile running SCP, the following commands can be used to enable debug messages:\r\n\r\n  sim> SET DEBUG STDERR\r\n  sim> SET XQ DEBUG=TRACE;CSR;VAR;WARN;SETUP;SANITY;REG;PACKET;DATA;ETH\r\n  sim> SET XU DEBUG=ETH;TRACE;REG;WARN;PACKET;DATA\r\n\r\nDocumentation of the functionality of these debug modifiers can be found in\r\npdp11_xq.h and pdp11_xu.h. Inline debugging has replaced the previous #ifdef\r\nstyle of debugging, which required recompilation before debugging.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nThings planned for future releases:\r\n 1. Full MOP implementation\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nThings which I need help with:\r\n 1. Information about Remote MOP processing\r\n 2. VAX/PDP-11 hardware diagnostics image files and docs, to test XQ thoroughly.\r\n 3. Feedback on operation with other VAX/PDP-11 OS's.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\nPlease send all patches, questions, feedback, clarifications, and help to:\r\n  david DOT hittner AT ngc DOT com\r\n\r\nThanks, and Enjoy!!\r\nDave\r\n\r\n\r\n===============================================================================\r\n                               Change Log\r\n===============================================================================\r\n\r\n  01-Mar-12  AGN  Added support for building using Cygwin on Windows\r\n  01-Mar-12  MP   Made host NIC address detection more robust on *nix platforms\r\n                  and mad it work when compiling under Cygwin\r\n  29-Feb-12  MP   Fixed MAC Address Conflict detection support\r\n  28-Feb-12  MP   Fixed overrun bug in eth_devices which caused SEGFAULTs\r\n  28-Feb-12  MP   Fixed internal loopback processing to only respond to loopback\r\n                  packets addressed to the physical MAC or appropriate Multicast\r\n                  or Broadcast addresses.\r\n  17-Nov-11  MP   Added dynamic loading of libpcap on *nix platforms\r\n  30-Oct-11  MP   Added support for vde (Virtual Distributed Ethernet) networking\r\n  29-Oct-11  MP   Added support for integrated Tap networking interfaces on OSX\r\n  17-Aug-11  RMS  Fix from Sergey Oboguev relating to XU and XQ Auto Config and\r\n                  vector assignments\r\n  12-Aug-11  MP   Cleaned up payload length determination\r\n                  Fixed race condition detecting reflections when threaded\r\n                  reading and writing is enabled\r\n  07-Jul-11  MB   VMS Pcap (from Mike Burke)\r\n                     - Fixed Alpha issues\r\n                     - Added OpenVMS Integrity support\r\n  20-Apr-11  MP   Fixed save/restore behavior\r\n  12-Jan-11  DTH  Added SHOW XU FILTERS modifier\r\n  11-Jan-11  DTH  Corrected DEUNA/DELUA SELFTEST command, enabling use by\r\n                  VMS 3.7, VMS 4.7, and Ultrix 1.1\r\n  09-Jan-11  MP   Fixed missing crc data when USE_READER_THREAD is defined and\r\n                  crc's are needed (only the pdp11_xu)\r\n  16-Dec-10  MP   added priority boost for read and write threads when\r\n                  USE_READER_THREAD does I/O in separate threads.  This helps\r\n                  throughput since it allows these I/O bound threads to preempt\r\n                  the main thread (which is executing simulated instructions).\r\n  09-Dec-10  MP   allowed more flexible parsing of MAC address strings\r\n  09-Dec-10  MP   Added support to determine if network address conflicts exist\r\n  07-Dec-10  MP   Reworked DECnet self detection to the more general approach\r\n                  of loopback self when any Physical Address is being set.\r\n  06-Dec-10  MP   Added loopback processing support to pdp11_xu.c\r\n  06-Dec-10  MP   Fixed loopback processing to correctly handle forward packets.\r\n  04-Dec-10  MP   Changed eth_write to do nonblocking writes when\r\n                  USE_READER_THREAD is defined.\r\n  30-Nov-10  MP   Fixed the fact that no broadcast packets were received by the DEUNA\r\n  29-Nov-10  MP   Fixed interrupt dispatch issue which caused delivered packets\r\n                  (in and out) to sometimes not interrupt the CPU after processing.\r\n  17-Jun-10  MP   Fixed bug in the AUTODIN II hash filtering.\r\n  14-Jun-10  MP   Added support for integrated Tap networking interfaces on BSD\r\n                  platforms.\r\n  13-Jun-10  MP   Added support for integrated Tap networking interfaces on Linux\r\n                  platforms.\r\n  31-May-10  MP   Added support for more TOE (TCP Offload Engine) features for IPv4\r\n                  network traffic from the host and/or from hosts on the LAN.  These\r\n                  new TOE features are: LSO (Large Send Offload) and Jumbo packet\r\n                  fragmentation support.  These features allow a simulated network\r\n                  device to support traffic when a host leverages a NIC's Large\r\n                  Send Offload capabilities to fragment and/or segment outgoing\r\n                  network traffic.  Additionally a simulated network device can\r\n                  reasonably exist on a LAN which is configured to use Jumbo frames.\r\n  21-May-10  MP   Added functionality to fix up IP header checksums to accommodate\r\n                  packets from a host with a NIC which has TOE (TCP Offload Engine)\r\n                  enabled which is expected to implement the checksum computations\r\n                  in hardware.  Since we catch packets before they arrive at the\r\n                  NIC the expected checksum insertions haven't been performed yet.\r\n                  This processing is only done for packets sent from the host to\r\n                  the guest we're supporting.  In general this will be a relatively\r\n                  small number of packets so it is done for all IP frame packets\r\n                  coming from the host to the guest.  In order to make the\r\n                  determination of packets specifically arriving from the host we\r\n                  need to know the hardware MAC address of the host NIC.  Currently\r\n                  determining a NIC's MAC address is relatively easy on Windows.\r\n                  The non-windows code works on linux and may work on other *nix\r\n                  platforms either as is or with slight modifications.  The code,\r\n                  as implemented, only messes with this activity if the host\r\n                  interface MAC address can be determined.\r\n  20-May-10  MP   Added general support to deal with receiving packets smaller\r\n                  than ETH_MIN_PACKET in length.  These come from packets\r\n                  looped back by some bridging mechanism and need to be padded\r\n                  to the minimum frame size.  A real NIC won't pass us any\r\n                  packets like that.  This fix belongs here since this layer\r\n                  is responsible for interfacing to the physical layer\r\n                  devices, AND it belongs here to get CRC processing right.\r\n  15-Aug-08  MP   Fixed transmitted packets to have the correct source MAC address.\r\n                  Fixed incorrect address filter setting calling eth_filter().\r\n  07-Mar-08  MP   Fixed the SCP visible SA registers to always display the\r\n                  ROM MAC address, even after it is changed by SET XQ MAC=.\r\n  07-Mar-08  MP   Added changes so that the Console DELQA diagnostic (>>>TEST 82)\r\n                  will succeed.\r\n  03-Mar-08  MP   Added DELQA-T (aka DELQA Plus) device emulation support.\r\n  06-Feb-08  MP   Added dropped frame statistics to record when the receiver discards\r\n                  received packets due to the receiver being disabled, or due to the\r\n                  XQ device's packet receive queue being full.\r\n                  Fixed bug in receive processing when we're not polling.  This could\r\n                  cause receive processing to never be activated again if we don't\r\n                  read all available packets via eth_read each time we get the\r\n                  opportunity.\r\n  31-Jan-08  MP   Added the ability to Coalesce received packet interrupts.  This\r\n                  is enabled by SET XQ POLL=DELAY=nnn where nnn is a number of\r\n                  microseconds to delay the triggering of an interrupt when a packet\r\n                  is received.\r\n  29-Jan-08  MP   Added SET XQ POLL=DISABLE (aka SET XQ POLL=0) to operate without\r\n                  polling for packet read completion.\r\n  29-Jan-08  MP   Changed the sanity and id timer mechanisms to use a separate timer\r\n                  unit so that transmit and receive activities can be dealt with\r\n                  by the normal xq_svc routine.\r\n                  Dynamically determine the timer polling rate based on the\r\n                  calibrated tmr_poll and clk_tps values of the simulator.\r\n  25-Jan-08  MP   Enabled the SET XQ POLL to be meaningful if the simulator currently\r\n                  doesn't support idling.\r\n  25-Jan-08  MP   Changed xq_debug_setup to use sim_debug instead of printf so that\r\n                  all debug output goes to the same place.\r\n  25-Jan-08  MP   Restored the call to xq_svc after all successful calls to eth_write\r\n                  to allow receive processing to happen before the next event\r\n                  service time.  This must have been inadvertently commented out\r\n                  while other things were being tested.\r\n  23-Jan-08  MP   Added debugging support to display packet headers and packet data\r\n  18-Jun-07  RMS  Added UNIT_IDLE flag\r\n  29-Oct-06  RMS  Synced poll and clock\r\n  27-Jan-06  RMS  Fixed unaligned accesses in XQB (found by Doug Carman)\r\n  07-Jan-06  RMS  Fixed unaligned access bugs (found by Doug Carman)\r\n  07-Sep-05  DTH  Removed unused variable\r\n  16-Aug-05  RMS  Fixed C++ declaration and cast problems\r\n\r\n  05-Mar-08  MP   Added optional multicast filtering support for doing\r\n                  LANCE style AUTODIN II based hashed filtering.\r\n  07-Feb-08  MP   Added eth_show_dev to display Ethernet state\r\n                  Changed the return value from eth_read to return whether\r\n                  or not a packet was read.  No existing callers used or\r\n                  checked constant return value that previously was being\r\n                  supplied.\r\n  29-Jan-08  MP   Added eth_set_async to provide a mechanism (when\r\n                  USE_READER_THREAD is enabled) to allow packet reception\r\n                  to dynamically update the simulator event queue and\r\n                  potentially avoid polling for I/O.  This provides a minimal\r\n                  overhead (no polling) maximal responsiveness for network\r\n                  activities.\r\n  29-Jan-08  MP   Properly sequenced activities in eth_close to avoid a race\r\n                  condition when USE_READER_THREAD is enabled.\r\n  25-Jan-08  MP   Changed the following when USE_READER_THREAD is enabled:\r\n                  - Fixed bug when the simulated device doesn't need crc\r\n                    in packet data which is read.\r\n                  - Added call to pcap_setmintocopy to minimize packet\r\n                    delivery latencies.\r\n                  - Added ethq_destroy and used it to avoid a memory leak in\r\n                    eth_close.\r\n                  - Properly cleaned up pthread mutexes in eth_close.\r\n                  Migrated to using sim_os_ms_sleep for a delay instead of\r\n                  a call to select().\r\n                  Fixed the bpf filter used when no traffic is to be matched.\r\n                  Reworked eth_add_packet_crc32 implementation to avoid an\r\n                  extra buffer copy while reading packets.\r\n                  Fixed up #ifdef's relating to USE_SHARED so that setting\r\n                  USE_SHARED or USE_NETWORK will build a working network\r\n                  environment.\r\n  23-Jan-08  MP   Reworked eth_packet_trace and eth_packet_trace_ex to allow\r\n                  only output Ethernet header+crc and provide a mechanism for\r\n                  the simulated device to display full packet data debugging.\r\n  17-May-07  DTH  Fixed non-Ethernet device removal loop (from Naoki Hamada)\r\n  15-May-07  DTH  Added dynamic loading of wpcap.dll;\r\n                  Corrected exceed max index bug in ethX lookup\r\n  04-May-07  DTH  Corrected failure to look up Ethernet device names in\r\n                  the registry on Windows XP x64\r\n  10-Jul-06  RMS  Fixed linux conditionalization (from Chaskiel Grundman)\r\n  02-Jun-06  JDB  Fixed compiler warning for incompatible sscanf parameter\r\n  15-Dec-05  DTH  Patched eth_host_devices [remove non-Ethernet devices]\r\n                  (from Mark Pizzolato and Galen Tackett, 08-Jun-05)\r\n                  Patched eth_open [tun fix](from Antal Ritter, 06-Oct-05)\r\n  30-Nov-05  DTH  Added option to regenerate CRC on received packets; some\r\n                  Ethernet devices need to pass it on to the simulation, and by\r\n                  the time libpcap/winpcap gets the packet, the host OS network\r\n                  layer has already stripped CRC out of the packet\r\n  01-Dec-04  DTH  Added Windows user-defined adapter names (from Timothe Litt)\r\n\r\n\r\n\r\n19-Mar-04 Release:\r\n 1. Genericized Sim_Ether code, reduced #ifdefs                (David Hittner)\r\n 2. Further refinement of sim_ether, qualified more platforms (Mark Pizzolato)\r\n 3. Added XU module                                            (David Hittner)\r\n 4. Corrected XQ interrupt signaling for PDP11s               (David Hittner)\r\n 5. Added inline debugging support                             (David Hittner)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n26-Nov-03 Release:\r\n 1. Added VMS support to Sim_Ether; created pcap-vms port      (Anders Ahgren)\r\n 2. Added DECNET duplicate detection for Windows              (Mark Pizzolato)\r\n 3. Added BPF filtering to increase efficiency                (Mark Pizzolato)\r\n 4. Corrected XQ Runt processing                              (Mark Pizzolato)\r\n 5. Corrected XQ Software Reset                               (Mark Pizzolato)\r\n 6. Corrected XQ Multicast/Promiscuous mode setting/resetting (Mark Pizzolato)\r\n 7. Added Universal TUN/TAP support                           (Mark Pizzolato)\r\n 8. Added FreeBSD support                                  (Edward Brocklesby)\r\n 9. Corrected interrupts on XQB device                         (David Hittner)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n05-Jun-03 Release:\r\n 1. Added SET/SHOW XQ STATS                                    (David Hittner)\r\n 2. Added SHOW XQ FILTERS                                      (David Hittner)\r\n 3. Added ability to split rcv packets into multiple buffers   (David Hittner)\r\n 4. Added explicit runt & giant packet processing              (David Hittner)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n30-May-03 Release:\r\n 1. Corrected bug in xq_setmac introduced in v3.0            (multiple people)\r\n 2. Made XQ rcv buffer allocation dynamic to reduce scp size   (David Hittner)\r\n 3. Optimized some structs, removed legacy variables          (Mark Pizzolato)\r\n 4. Changed #ifdef WIN32 to _WIN32 for consistency            (Mark Pizzolato)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n06-May-03 Release:\r\n 1. Added second XQ controller                                 (David Hittner)\r\n 2. Added SIMH v3.0 compatibility                              (David Hittner)\r\n 3. Removed SET ADDRESS functionality                          (David Hittner)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n10-Apr-03 Release:\r\n 1. Added preliminary support for RSTS/E                       (David Hittner)\r\n 2. Added PDP-11 bootrom load via CSR flags                    (David Hittner)\r\n 3. Support for SPARC linux                                   (Mark Pizzolato)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n11-Mar-03 Release:\r\n 1. Added support for RT-11 TCP/IP\r\n 2. Corrected interrupts (thanks to Tom Evans and Bob Supnik)\r\n 3. Moved change log to the bottom of the readme file, cleaned up document\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n16-Jan-03 Release:\r\n 1. Added VMScluster support (thanks to Mark Pizzolato)\r\n 2. Verified VAX remote boot functionality (>>>B XQA0)\r\n 3. Added major performance enhancements (thanks to Mark Pizzolato again)\r\n 4. Changed _DEBUG tracers to XQ_DEBUG and ETH_DEBUG\r\n 5. Added local packet processing\r\n 6. Added system id broadcast\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n08-Nov-02 Release:\r\n 1. Added USE_NETWORK conditional to Sim_Ether\r\n 2. Fixed behavior of SHOW XQ ETH if no devices exist\r\n 3. Added OpenBSD support to Sim_Ether (courtesy of Federico Schwindt)\r\n 4. Added ethX detection simplification (from Megan Gentry)\r\n\r\n===============================================================================\r\n"
        },
        {
          "name": "3B2",
          "type": "tree",
          "content": null
        },
        {
          "name": "ALTAIR",
          "type": "tree",
          "content": null
        },
        {
          "name": "AltairZ80",
          "type": "tree",
          "content": null
        },
        {
          "name": "B5500",
          "type": "tree",
          "content": null
        },
        {
          "name": "BESM6",
          "type": "tree",
          "content": null
        },
        {
          "name": "CDC1700",
          "type": "tree",
          "content": null
        },
        {
          "name": "COPYING.txt",
          "type": "blob",
          "size": 3.390625,
          "content": "The LICENSE.txt file summarizes the general simh license which is \r\nessentially stated at the top of all source code files, along with \r\nsome additional limitations spelled out in the LICENSE.txt file.\r\n\r\nThe purpose of this COPYING.txt file is to provide guidance for folks \r\nwho may want to include some or all of the simh code in other projects.\r\nThe point of this guidance is so that the actual version of the simh \r\ncode is retained in whatever derivative work may be produced so that \r\nproblems may be reasonably reported AND so that users and developers \r\ncan easily determine what simh version they are working with.\r\n\r\nThe best way to do this leverages git's archive feature which in \r\nthe simh case has simh git commit information embedded in the archive.\r\nAlternatively, some live git operations could be done to fetch and\r\nextrace the current commit/version information from that archive \r\nand then pass it around and through the derivative project's build \r\nmechanism.\r\n\r\nGIT ARCHIVE CONSIDERATIONS:\r\n\r\nFor all projects (even those where Internet connectivity may not be\r\navailable on all machines that may build the project) the git archive \r\nfeature would be most appropriate.  \r\nAdditionally a few dozen megabytes of storage on the build machine \r\nwon't be needed to hold the complete simh codebase.  These days \r\nstorage is so cheap that this generally shouldn't be a concern, but\r\nsome folks really like to keep things to a minimal footprint.\r\n\r\nA git archive containing all of the simh components can be acquired\r\nfrom the simh gitub repository for the latest simh code from:\r\n        https://github.com/simh/simh/archive/master.zip\r\nor for a specific simh commit:\r\n        https://github.com/simh/simh/archive/<commit-hash>.zip\r\n        \r\nThe archive produced will automatically contain the specifics of the \r\nsimh git version that has been archived.\r\n\r\nEach time the simh components are acquired as an archive, the \r\nproject's interesting simh pieces can then be extracted from the \r\narchive, modified as needed by that project and the project's build \r\nmechanism can then compile the simh components with:\r\n\r\n    -DSIM_VERSION_MODE=derivative-project-name-and-or-version\r\n\r\nThis will result in simulators built this way to have SHOW VERSION \r\noutput both identifying the particular version of simh pieces that \r\nwere used as well as whatever interesting version the project may \r\nwant to identify itself with.\r\n\r\nThose acquired and extracted pieces can then be stored in the source \r\ncode system for the derivative project and potentially be updated \r\nfrom time to time.\r\n\r\nIf all of the simh components aren't going to be available in the \r\nderivative project, all of the actual simulator pieces should generally\r\nbe gathered and used within the derivative project.  These pieces \r\nshould certainly include all the source code (and license files) in \r\nthe root simh directory along with the particular simulator's source \r\ndirectory, and any additional directories which may be referenced in \r\nthe normal simulator build.  These additional directories may include:\r\ndisplay, slirp and slirp_glue.\r\n\r\nDIRECT GIT repository access\r\n\r\nUsing a direct git approach is more complicated and entangles \r\ncapturing the git commit id and time and passing that around and \r\nthrough the derivative project's build mechanisms and the working\r\nenvironment available in the derivative project.  Folks going down \r\nthis path are on their own to try to solve this.\r\n"
        },
        {
          "name": "GRI",
          "type": "tree",
          "content": null
        },
        {
          "name": "H316",
          "type": "tree",
          "content": null
        },
        {
          "name": "HP2100",
          "type": "tree",
          "content": null
        },
        {
          "name": "HP3000",
          "type": "tree",
          "content": null
        },
        {
          "name": "I1401",
          "type": "tree",
          "content": null
        },
        {
          "name": "I1620",
          "type": "tree",
          "content": null
        },
        {
          "name": "I650",
          "type": "tree",
          "content": null
        },
        {
          "name": "I7000",
          "type": "tree",
          "content": null
        },
        {
          "name": "I7094",
          "type": "tree",
          "content": null
        },
        {
          "name": "Ibm1130",
          "type": "tree",
          "content": null
        },
        {
          "name": "Intel-Systems",
          "type": "tree",
          "content": null
        },
        {
          "name": "Interdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "LGP",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 4.15234375,
          "content": "This file summarizes below the general simh license (indented) which is \r\nessentially stated at the top of all source code files with the respective \r\nauthors mentioned there.  Pay particular attention to the paragraphs \r\n(beyond the indented section) which add some specific constraints.\r\n\r\n   Copyright (c) 1993-2022, Robert M Supnik, Mark Pizzolato and others\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK, MARK PIZZOLATO OR OTHERS BE LIABLE FOR ANY CLAIM, DAMAGES \r\n   OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \r\n   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR \r\n   OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik, Mark \r\n   Pizzolato or anyone else shall not be used in advertising or otherwise to \r\n   promote the sale, use or other dealings in this Software without prior \r\n   written authorization from all those parties.\r\n\r\n\r\nAdditionally, the following restrictions on the use of this software apply\r\nand, where applicable, thereby override the \"without limitation\" clause \r\nabove or in each relevant source code module.\r\n\r\nAny use of this codebase that changes the code to influence the behavior of \r\nthe disk access activities provided by sim_disk.c and scp.c is free to do \r\nthat as long as anyone doing this is explicitly not licensed to any subsequent \r\nchanges to any part of the codebase in the master branch of the git repository\r\n(https://github.com/simh/simh) made by Mark Pizzolato after the LICENSE.txt \r\nwas added to the master branch of repository. Changes that qualify for this \r\nrestriction at least include: changing the behavior or default of \r\nSET AUTOSIZE/NOAUTOSIZE, or any code in scp.c and sim_disk.c or any simulator \r\ncomponents that use the sim_disk routines.\r\n\r\nAll changes to the codebase in the master branch of the \r\nhttps://github.com/simh/simh repository made by Mark Pizzolato after the \r\ninclusion of the first version of this LICENSE.txt file in that branch of the\r\nrepository will be not be licensed for use by anyone making any of the above \r\nmentioned sim_disk/autosize related changes.\r\n\r\nThere are three potential categories of users who may need clarification \r\nwhen interpreting the above license wording:\r\n\r\nGroup 1: Any person who uses completely unmodified code from the master \r\n         branch of the repository is licensed to use all of \"Mark Pizzolato's \r\n         future changes\".\r\nGroup 2: Any person using a simulator that has no devices which use sim_disk\r\n         and that doesn't modify scp.c is licensed to use all of \"Mark \r\n         Pizzolato's future changes\".\r\nGroup 3: Any person who finds it desireable to change the AUTOSIZE \r\n         functionality of scp.c or any aspect of the sim_disk.c is NOT \r\n         licensed for any of \"Mark Pizzolato's future changes\".\r\n\r\nNote: Mark Pizzolato's future changes are commits made to the master branch\r\n      of the https://github.com/simh/simh repository authored by Mark \r\n      Pizzolato after the first version of this LICENSE.txt was added to \r\n      the master branch of the repository.\r\n\r\nFor many years, there exist some binary files in the repository which may \r\nnot have formal copyright releases from the original copyright holders and \r\ntherefore those are certainly not granted a license by this LICENSE.txt file.\r\n\r\nUpon specific request by the copyright holder any such unlicensed files will \r\nbe removed.\r\n"
        },
        {
          "name": "ND100",
          "type": "tree",
          "content": null
        },
        {
          "name": "NOVA",
          "type": "tree",
          "content": null
        },
        {
          "name": "PDP1",
          "type": "tree",
          "content": null
        },
        {
          "name": "PDP10",
          "type": "tree",
          "content": null
        },
        {
          "name": "PDP11",
          "type": "tree",
          "content": null
        },
        {
          "name": "PDP18B",
          "type": "tree",
          "content": null
        },
        {
          "name": "PDP8",
          "type": "tree",
          "content": null
        },
        {
          "name": "PDQ-3",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 47.8876953125,
          "content": "# SIMH v4.0 - 19-01 Current\r\n\r\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/11982/badge.svg)](https://scan.coverity.com/projects/simh)\r\n[![AppVeyor CI Build Status](https://ci.appveyor.com/api/projects/status/github/simh/simh)](https://ci.appveyor.com/project/simh/simh/history)\r\n\r\n## Table of Contents:\r\n[WHAT'S NEW since the Open SIMH fork](#whats-new-since-the-open-simh-fork)  \r\n[WHAT'S NEW since simh v3.9](#whats-new-since-simh-v39)  \r\n. . [New Simulators](#new-simulators)  \r\n. . [Simulator Front Panel API](#simulator-front-panel-api)  \r\n. . [New Functionality](#new-functionality)  \r\n. . . . [DDCMP Synchronous host physical device support - framer](#ddcmp-synchronous-host-physical-device-support---framer)  \r\n. . . . [Remote Console Facility](#remote-console-facility)  \r\n. . . . [VAX/PDP11 Enhancements](#vaxpdp11-enhancements)  \r\n. . . . [PDP11 Specific Enhancements](#pdp11-specific-enhancements)  \r\n. . . . [PDP10 Enhancements](#pdp10-enhancements)  \r\n. . . . [SDS 940 Enhancements](#sds-940-enhancements)  \r\n. . . . [Terminal Multiplexer additions](#terminal-multiplexer-additions)  \r\n. . . . [Video Display Capabilities](#video-display-capabilities)  \r\n. . . . [Asynchronous I/O](#asynchronous-io)  \r\n. . . . [Clock/Timer Enhancements](#clocktimer-enhancements)  \r\n. . . . [Ethernet Transport Enhancements](#ethernet-transport-enhancements)  \r\n. . . . [Disk Extensions](#disk-extensions)  \r\n. . . . [Embedded ROM support](#embedded-rom-support)  \r\n. . . . [Control Flow](#control-flow)  \r\n. . . . [Scriptable interactions with running simulators](#scriptable-interactions-with-running-simulators)  \r\n. . . . [Help](#help)  \r\n. . . . [Generic SCP support Clock Coscheduling as opposed to per simulator implementations](#generic-scp-support-clock-coscheduling-as-opposed-to-per-simulator-implementations)  \r\n. . . . [New SCP Commands](#new-scp-commands)  \r\n. . . . [Command Processing Enhancements](#command-processing-enhancements)  \r\n. . . . . . [Environment variable insertion](#environment-variable-insertion)  \r\n. . . . . . [Command aliases](#command-aliases)  \r\n. . . . . . [Do command argument manipulation](#do-command-argument-manipulation)  \r\n. . [Building and running a simulator](#building-and-running-a-simulator)  \r\n. . . . [Use Prebuilt Windows Simulators](#use-prebuilt-windows-simulators)  \r\n. . . . [Building simulators yourself](#building-simulators-yourself)  \r\n. . . . . . [Linux/OSX other *nix platforms](#linuxosx-other-nix-platforms)  \r\n. . . . . . . . [Build Dependencies](#build-dependencies)  \r\n. . . . . . . . . . [OS X - Dependencies](#os-x---dependencies)  \r\n. . . . . . . . . . [Linux - Dependencies](#linux---dependencies)  \r\n. . . . . . [Windows](#windows)  \r\n. . . . . . . . [Required related files](#required-related-files)  \r\n. . . . . . . . [Visual Studio (Standard or Express) 2008, 2010, 2012, 2013 or Visual Studio Community 2015, 2017, 2019](#visual-studio-standard-or-express-2008-2010-2012-2013-or-visual-studio-community-2015-2017-2019)  \r\n. . . . . . . . [MinGW32](#mingw32)  \r\n. . . . . . [VMS](#vms)  \r\n. . [Problem Reports](#problem-reports)  \r\n\r\n## WHAT'S NEW since the Open SIMH fork\r\n\r\nAll Simulator updates on Open SIMH will be present in this repository, and any changes to the master branch code in this repository authored by anyone except Mark Pizzolato may be posted as pull requests on the Open simh repo.\r\n\r\nSimulator binaries for x86 Linus, x86 macOS, and Windows for all recent changes are available at https://github.com/simh/Development-Binaries\r\n\r\n### Mark Pizzolato's changes only present in the simh/simh repo and not present in the Open SIMH repo:\r\n\r\n#### Visible changes to SCP (the simulator framework or command execution environment)\r\n\r\n- Add descriptive messages for cases when NOPARAM status is returned.\r\n- Avoid excessive DO command context lines when commands produce multiple lines of output.\r\n- Support has been added to allow for optional per device unit tests to exist and to invoke them at simulator startup.\r\n- Add support for generic bit field packing and unpacking during buffer copying.\r\n- Display count of units when all units are disabled.\r\n- Support to display all SCP visible filenames via relative paths and use those in SAVEd state.\r\n- ZAP command can be aborted by a Control-C.\r\n- Display current NOAUTOSIZE status in SHOW VERSION output.\r\n- Extend logical name support to include optional unique names for units as well as devices.\r\n- Add extended register sanity checks including duplicate name detection.  Fixed simulator devices with duplicate register names.\r\n- Simulators with video devices that may be enabled, no longer disable the screen saver until the video display is presented.  Optionally enabling or disabling the OS screen saver by an environment variable.\r\n- More readable output of SHOW <dev>|<unit> with variable sized DEVICE and UNIT names.\r\n- Automatic Cryllic Font detection in BESM6 simulator at runtime rather than build time.  More relevant for distribution binaries.\r\n- Built-in command history and tab file name completion previously done by GPL readline now done by BSD licensed library available on all platforms (especially Windows).\r\n- Robust register sanity checking for all register definition macros.\r\n- When building on windows, the windows-build dependency libraries are automatically downloaded even if git is not available.\r\n- Extended video component version information displayed in SHOW VERSION output.\r\n- Add a global SET AUTOZAP command or per drive SET <unit> AUTOZAP which removes metadata from disk containers at detach time if the container has metadata.\r\n- DISKINFO command displays disk container metadata (if present) and container size along with detected file system information if a known file system type is present.\r\n- makefile builds which have potentially useful dependencies not found will prompt to install these components prior to building.  MacOS Brew dependencies can be directly done from within the makefile.  Other platforms (or package management systems) which require root access to install will display the appropriate package management commands and and exit.  Support for macOS (HomeBrew and MacPorts), Linux (Ubuntu/Debian, RedHat/Fedora), NetBSD, FreeBSD, OpenBSD.\r\n- SHOW VERSION show the host system type that build the runing simulator when it is not the same as the current host system.\r\n- Support for building simulators without built-in boot or ROM code when building with DONT_USE_INTERNAL_ROM is defined, but to automatically and transparently fetch the needed ROM or other boot code when it is needed.  This is possibly useful for systems which don't want to distribute simulators with build-in binary code which may have unknown copyright status.\r\n- Reasonable output produced for all simulators from HELP BOOT.\r\n- Fix occasional hang of IBM1130 simulator while building with Visual Studio.\r\n- Building with the simh makefile can optionally compile each source file separately and store the compiled result.   This approach lends itself to quicker building for folks who are developing new simulators or new simulator modules.  This was requested and discussed in #697.  Invoking make with BUILD_SEPARATE=1 on the make command line or as an exported environment variable will achieve separate compiles.  Invoking make with QUIET=1 on the make command line or as an exported environment variable will summary output of activities being performed instead of full compiler commands.\r\n- TAPE and SCSI libraries have been extended to fully support partial record reads of fixed sized records which may contain multiple records in recorded data.  Images of this type are common for QIC tape archives generally available on bitsavers and elsewhere.  Attach time checking on simulated QIC tape devices reports possible problems that may occur.\r\n- Appveyor CI/CD builds of all simulators for Linux, macOS and Windows platforms.\r\n- All the available simulator defined environment variables are documented in the help and sim_doc document file.\r\n- SET CONSOLE TELNET=CONNECT will start a telnet session to the simulator console in a separate window.\r\n- Support for building on systems with the gameoftrees.org (got) source control system.\r\n- Frontpanel API improvements, document clarifications and bug fixes.\r\n- Added a SET CLOCK NOCALIBRATE mode.  \r\n    NOCALIBRATE mode allows all activity of a simulator run to occur with precisely consistent event timing.  In this mode, every clock tick takes precisely the same number of instructions/cycles.  Likewise, the polling activities for MUX or other poll oriented devices occurs after precisely the same number of instructions/cycles executed.  As a consequence of this mode, no effort to align simulated clock ticks (and simulated access to wall clock time) is made.\r\n    \r\n    This mode will often be useful for running diagnostics which expect a particular relationship between perceived wall clock and instruction times.  It might also be useful for running test scripts which may want to compare output of previous executions to to current execution or to compare execution on arbitrarily different host computers.  It will also be useful when running under a host system debugger which might produce confusing results when various wall clock pause times when stopping at breakpoints.  Additionally, consistent logical timing exists when simulator debug or instruction history is being recorded which normally would impact wall clock times.\r\n    \r\n    In NOCALIBRATE mode, the operator gets to specify the pseudo execution rate along with the base wall clock time that access to pseudo wall clock accesses returns.\r\n- All removable devices get detached on a media unload without regard to data access format (SIMH, VHD or RAW).  \r\n- Various failing bugs in tape detach logic are fixed.\r\n- Clean building on Android Termux.\r\n- Proper line editing and tab filename completion behavior on all Unix and Windows platforms.\r\n- Simulators with video displays have a working SCREENSHOT command.\r\n- VHD Support for Differencing Disks has been corrected.\r\n- Attach time disk container copy support between dissimilar storage formats (VHD<->SIMH).  Previously container copy operations were only supported between identical format containers (SIMH<->SIMH, and VHD<->VHD).\r\n- DISKINFO command provides more useful metadata information and file system verification with full support for VHD Differencing Disks.\r\n- Simulators which have instruction history support can now have SHOW HISTORY output be aborted by SIGINT (Control-C).\r\n- Device REGister variables have been extended to support double precision data.\r\n- More complete host system information displayed in SHOW VERSION output.\r\n- Simulator THROTTLING can only be enabled once per simulator run.  This avoids potential errant behaviors when arbitrarily switching throttling settings.\r\n- EXAMINE memory commands will now produce minimal output that summarizes multiple successive locations with the same contents and may be aborted by SIGINT (Control-C).\r\n- \r\n\r\n#### All simulators build cleanly under OpenVMS on ia64 systems.\r\n\r\n#### Changes to the PDP-11 and VAX simulators also not in the Open SIMH repo\r\n\r\n- All VAXen: Correct HELP CPU to properly describe model specific LOAD options for ROM and NVRAM.\r\n- Add 2.11 BSD and NetBSD file system recognizers.\r\n- Add memory details and behavior description to the MicroVAX 3900 HELP CPU output.\r\n- Unibus and Qbus autoconfiguration disabling has been relaxed somewhat.  Previously, any \"SET <device> ADDRESS= (or VECTOR=)\" command would automatically disable autoconfigure for the rest of the simulator session.  This behavior has been relaxed so that autoconfigure will only be disabled if the specified ADDRESS or VECTOR value is different from the value previously set by the initial autoconfigure.\r\n- Aggressive validation of Unibus and Qbus ADDRESS and VECTOR values prior to execution starting due to a BOOT command.\r\n- Fixed bug in devices that use sim_disk which deallocated a file transfer buffer on detach.\r\n- Metadata is implemented on all VAX and PDP11 disk devices when NOAUTOSIZE is not specified.\r\n- Full support for using disk containers with metadata between different system and device types where it makes sense.\r\n- VHD disk formats are available on all disk types (including floppy or DECtape devices).\r\n- Properly size RY drives which also don't have DEC144\r\n- Properly name RQ extended units beyond the initial default units.\r\n- HELP CPU shows supported breakpoint types.\r\n- Add device support for DL11-C/DL11-D/DL11-E/DLV11-J in addition to the original KL11/DL11-A/DL11-B/DL11-E/DL11-F support.  These new devices have different bus address ranges and can coexist with the original DL devices.  The new devices are DLCJI and DLCJO and are managed identically to the original DLI and DLO devices.\r\n- All improvements and fixes to the PDP11 simulator from simh Version 3.12-3 release and beyond.\r\n- MicroVAX I has unsupported devices (TQ, TS, and VH) removed.\r\n- VAX750, VAX780, VAX8600 and PDP11 support additional Massbus disks on DEVICE RPB.\r\n- VAXStation I is now, once again, working.\r\n- MicroVAX I/VAXStation I has been enhanced to dynamically look for its secondary bootstrap program (SYSBOOT.EXE) from both [SYSEXE]SYSBOOT.EXE and [SYS0.SYSEXE]SYSBOOT.EXE.\r\n- PDP11 now has working support for RC and RF expandable platter based disk drives.\r\n- Properly set asynchronous interrupt latency in all VAX simulators.\r\n- MicroVAX I simulator boots from oldest MicroVMS media due to the addition of RQDX1 disk controller type.\r\n- MSCP Media-Id information and drive geometry information is available for all attached disk containers.\r\n- VAX Instruction history can be recorded to disk both for all instructions executed as well as every n instructions.\r\n- VAX Unibus simulators (780, 750, 730, 8600, 8200) run DEC supplied diagnostics at the speed of the original systems and also run the privileged instruction diagnostic that was supported on the original systems.\r\n\r\n### All relevant changes in the simh v3.12-4 release have been merged into this repo\r\n\r\n### Bill Beech has made significant enhancements and bug fixes to the SWTP simulators along with a new disk controller from Roberto Sancho Villa\r\n\r\n\r\n## WHAT'S NEW since simh v3.9\r\n\r\n### New Simulators\r\n\r\n#### Seth Morabito has implemented AT&T 3B2-400 and 3B2-700 simulators.\r\n\r\n#### Leonid Broukhis and Serge Vakulenko have implemented a simulator for the Soviet mainframe BESM-6 computer.\r\n\r\n#### Matt Burke has implemented new VAX model simulators:\r\n\r\n    VAX-11/730\r\n    VAX-11/750\r\n    VAX 8200/8250\r\n    VAX 8600/8650\r\n    MicroVAX I & VAXstation I\r\n    MicroVAX II & VAXstation II & VAXstation II/GPX\r\n    rtVAX 1000 (or Industrial VAX 620)\r\n    MicroVAX 2000 & VAXstation 2000\r\n    MicroVAX 3100 M10/M20\r\n    MicroVAX 3100 M10e/M20e\r\n    InfoServer 100\r\n    InfoServer 150 VXT\r\n    VAXstation 3100 M30\r\n    VAXstation 3100 M38\r\n    VAXstation 3100 M76\r\n    VAXstation 4000 VLC\r\n    VAXstation 4000 M60\r\n    MicroVAX 3100 M80\r\n    InfoServer 1000\r\n\r\n#### Howard Harte has implemented a Lincoln Labs TX-0 simulator.\r\n\r\n#### Gerardo Ospina has implemented a Manchester University SSEM (Small Scale Experimental Machine) simulator.\r\n\r\n#### Richard Cornwell has implemented a Burroughs B5500.\r\n\r\n#### Richard Cornwell has implemented the IBM 701, IBM 704, IBM 7010/1410, IBM 7070/7074, IBM 7080/702/705/7053 and IBM 7090/7094/709/704 simulators.\r\n\r\n#### Richard Cornwell has implemented the PDP6, PDP10-KA, PDP10-KI, PDP10-KL and PDP10-KS simulators.  With the differences merely being some device name changes, the PDP10-KS should be compatible with Bob Supnik's original PDP10 simulator.\r\n\r\n#### Dave Bryan has implemented an HP-3000 Series III simulator.\r\n\r\n#### Updated HP2100 simulator from Dave Bryan.\r\n\r\n#### Updated AltairZ80 simulator from Peter Schorn.\r\n\r\n#### Sigma 5, 6 & 7 simulator from Bob Supnik\r\n\r\n#### Beta SAGE-II and PDQ-3 simulators from Holger Veit\r\n\r\n#### Intel Systems 8010 and 8020 simulators from Bill Beech\r\n\r\n#### CDC 1700 simulator from John Forecast\r\n\r\n#### Hans-Åke Lund has implemented an SCELBI (SCientic-ELectronics-BIology) simulator.\r\n\r\n#### IBM 650 simulator from Roberto Sancho Villa\r\n\r\n#### Jim Bevier has implemented a SEL32 simulator.\r\n\r\n#### Updates to the Unibus DUP & Qbus DPV device by Trevor Warwick\r\n\r\nSupport for Phase V DECnet connections on VAX Unibus and Qbus systems and the addition of support for the DPV11 for Qbus VAX systems.\r\n\r\n### New Host Platform support - HP-UX and AIX\r\n\r\n### Simulator Front Panel API\r\n\r\nThe sim_frontpanel API provides a programmatic interface to start and control any simulator without any special additions to the simulator code or changes to the SCP framework.\r\n\r\n### New Functionality\r\n\r\n#### DDCMP Synchronous host physical device support - framer\r\nPaul Koning has implemented a USB hardware device which can interface transport DDCMP packets across a synchronous line \r\nto physical host systems with native synchronous devices or other simulators using framer devices.\r\n\r\n#### Remote Console Facility\r\nA new capability has been added which allows a TELNET Connection to a user designated port so that some out of band commands can be entered to manipulate and/or adjust a running simulator.  The commands which enable and control this capability are SET REMOTE TELNET=port, SET REMOTE CONNECTIONS=n, SET REMOTE TIMEOUT=seconds, and SHOW REMOTE.\r\n\r\nThe remote console facility has two modes of operation: 1) single command mode. and 2) multiple command mode.  \r\nIn single command mode you enter one command at a time and aren't concerned about what the simulated system is doing while you enter that command.  The command is executed once you've hit return.\r\nIn multiple command mode you initiate your activities by entering the WRU character (usually ^E).  This will suspend the current simulator execution.  You then enter commands as needed and when you are done you enter a CONTINUE command.  While entering Multiple Command commands, if you fail to enter a complete command before the timeout (specified by \"SET REMOTE TIMEOUT=seconds\"), a CONTINUE command is automatically processed and simulation proceeds.\r\n\r\nA subset of normal simh commands are available for use in remote console sessions.\r\nThe Single Command Mode commands are: ATTACH, DETACH, PWD, SHOW, DIR, LS, ECHO, HELP\r\nThe Multiple Command Mode commands are: EXAMINE, IEXAMINE, DEPOSIT, EVALUATE, ATTACH, DETACH, ASSIGN, DEASSIGN, STEP, CONTINUE, PWD, SAVE, SET, SHOW, DIR, LS, ECHO, HELP\r\n\r\nA remote console session will close when an EOF character is entered (i.e. ^D or ^Z).\r\n\r\n#### VAX/PDP11 Enhancements\r\n    RQ has new disk types: RC25, RCF25, RA80\r\n    RQ device has a settable controller type (RQDX3, UDA50, KLESI, RUX50)\r\n    RQ disks default to Autosize without regard to disk type\r\n    RQ disks on PDP11 can have RAUSER size beyond 2GB\r\n    DMC11/DMR11 DDCMP DECnet device simulation.  Up to 8 DMC devices are supported.  Packet transport is via TCP or UDP connections.\r\n    KDP11 on PDP11 for DECnet\r\n    DUP11 on PDP11 for DECnet connectivity to talk to DMC, KDP or other DUP devices\r\n    CH11 on PDP11 and VAX780 for Chaosnet (from Lars Brinkhoff)\r\n    DZ on Unibus systems can have up to 256 ports (default of 32), on \r\n        Qbus systems 128 port limit (default of 16).\r\n    DZ devices optionally support full modem control (and port speed settings \r\n        when connected to serial ports).\r\n    TU58 device support for all PDP11 and VAX systems.\r\n    DHU11 (device VH) on Unibus systems now has 16 ports per multiplexer.\r\n    XQ devices (DEQNA, DELQA and DELQA-T) are bootable on Qbus PDP11 simulators\r\n    XQ and XU devices (DEQNA, DELQA, DELQA-T, DEUNA and DELQA) devices can now \r\n        directly communicate to a remote device via UDP (i.e. a built-in HECnet bridge).\r\n    XQ and XU devices (DEQNA, DELQA, DELQA-T, DEUNA and DELQA) devices can now \r\n        optionally throttle outgoing packets which is useful when communicating with\r\n        legacy systems (real hardware) on a local LAN which can easily get over run \r\n        when packets arrive too fast.\r\n    MicroVAX 3900 has QVSS (VCB01) board available.\r\n    MicroVAX 3900 and MicroVAX II have SET CPU AUTOBOOT option\r\n    MicroVAX 3900 has a SET CPU MODEL=(MicroVAX|VAXserver|VAXstation) command to change between system types\r\n    MicroVAX I has a SET CPU MODEL=(MicroVAX|VAXSTATION) command to change between system types\r\n    MicroVAX II has a SET CPU MODEL=(MicroVAX|VAXSTATION) command to change between system types\r\n\r\n#### PDP11 Specific Enhancements\r\n    ROM (from Lars Brinkhoff) I/O page ROM support\r\n    NG (from Lars Brinkhoff) Knight vector display\r\n    DAZ (from Lars Brinkhoff) Dazzle Dart Input device\r\n\r\n#### PDP10 Enhancements\r\n    KDP11 (from Timothe Litt) for DECnet connectivity to simulators with DMC, DUP or KDP devices\r\n    DMR11 for DECnet connectivity to simulators with DMC, DUP or KDP devices on TOPS10.\r\n    CH11 (from Lars Brinkhoff) Chaosnet interface.\r\n\r\n#### SDS 940 Enhancements\r\n    Support for SDS internal ASCII character encoding during display and data entry.\r\n    Allow breakpoints to be qualified by normal, monitor or user mode.\r\n    Fix CPU, RAD, MUX and I/O bugs that prevented SDS Time Share System Monitor and Executive from executing properly.\r\n\r\n#### Terminal Multiplexer additions\r\n    Added support for TCP connections using IPv4 and/or IPv6.\r\n    Logging - Traffic going out individual lines can be optionally logged to \r\n            files\r\n    Buffering - Traffic going to a multiplexor (or Console) line can \r\n            optionally be buffered while a telnet session is not connected\r\n            and the buffered contents will be sent out a newly connecting \r\n            telnet session.  This allows a user to review what may have \r\n            happened before they connect to that session.\r\n\r\n    Serial Port support based on work by J David Bryan and Holger Veit\r\n    Serial Console Support\r\n    Separate TCP listening ports per line\r\n    Outgoing connections per line (virtual Null Modem cable).\r\n    Packet sending and reception semantics for simulated network device support using either TCP or UDP transport.\r\n    Input character rates reflect the natural character arrival time based on the line speed.\r\n\r\n#### Video Display Capabilities\r\nAdded support for monochrome and color displays with optional keyboards and mice.  \r\nThe VAXstation QVSS device (VCB01) and QDSS device (VCB02) simulations use these capabilities.\r\nHost platforms which have libSDL2 available can leverage this functionality.\r\n\r\n#### Asynchronous I/O\r\n    * Disk and Tape I/O can be asynchronous.  Asynchronous support exists \r\n      for pdp11_rq, pdp11_rp and pdp11_tq devices (used by VAX and PDP11 \r\n      simulators).\r\n    * Multiplexer I/O (Telnet and/or Serial) can be asynchronous.  \r\n      Asynchronous support exists for console I/O and most multiplexer \r\n      devices.  (Still experimental - not currently by default)\r\n\r\n#### Clock/Timer Enhancements\r\n    * Asynchronous clocks ticks exist to better support modern processors \r\n      that have variable clock speeds.  The initial clock calibration model \r\n      presumed a constant simulated instruction execution rate.  \r\n      Modern processors have variable processor speeds which breaks this \r\n      key assumption.  \r\n    * Strategies to make up for missed clock ticks are now available\r\n      (independent of asynchronous tick generation).  These strategies\r\n      generate catch-up clock ticks to keep the simulator passage of \r\n      time consistent with wall clock time.  Simulator time while idling \r\n      or throttling is now consistent.  Reasonable idling behavior is \r\n      now possible without requiring that the host system clock tick be\r\n      10ms or less.\r\n    * Simulator writers have access to timing services and explicit wall \r\n      clock delays where appropriate.\r\n\r\n#### Ethernet Transport Enhancements\r\n\t* UDP packet transport.  Direct simulator connections to HECnet can be \r\n\t  made without running a local packet bridge program.\r\n\t* NAT packet transport.  Simulators which only speak TCP/IP (No DECnet)\r\n\t  and want to communicate with their host systems and/or directly to \r\n\t  the Internet can use NAT packet transport.  This also works for WiFi \r\n\t  connected host systems.\r\n\t* Packet Transmission Throttling.  When connected to a LAN which has \r\n\t  legacy network adapters (DEQNA, DEUNA) on legacy systems, it is very\r\n\t  easy for a simulated system to overrun the receiving capacity of the\r\n\t  older systems.  Throttling of simulated traffic delivered to the LAN \r\n\t  can be used to mitigate this problem.\r\n\t* Reliable MAC address conflict detection.  \r\n\t* Automatic unique default MAC address assignment.  \r\n\r\n#### Disk Extensions\r\n    RAW Disk Access (including CDROM)\r\n    Virtual Disk Container files, including differencing disks\r\n    File System type detection to accurately autosize disks.\r\n    Recognized file systems are: DEC ODS1, DEC ODS2, DEC RT11, DEC RSTS, DEC RSX11, Ultrix Partitions, ISO 9660, BSD 2.11 partitions and NetBSD partitions\r\n\r\n#### Tape Extensions\r\n    AWS format tape support\r\n    TAR format tape support\r\n    ANSI-VMS, ANSI-RSX11, ANSI-RSTS, ANSI-RT11 format tape support\r\n\r\n#### Embedded ROM support\r\n    Simulators which have boot commands which load constant files as part of \r\n    booting have those files imbedded into the simulator executable.  The \r\n    imbedded files are used if the normal boot file isn't found when the \r\n    simulator boots.  Specific examples are:\r\n    \r\n\t\tVAX (MicroVAX 3900 - ka655x.bin)\r\n\t\tVAX8600 (VAX 8600 - vmb.exe)\r\n\t\tVAX780 (VAX 11/780 - vmb.exe)\r\n\t\tVAX750 (VAX 11/750 - vmb.exe, ka750_old.bin, ka750_new.bin), \r\n\t\tVAX730 (VAX 11/730 - vmb.exe)\r\n\t\tVAX610 (MicroVAX I - ka610.bin)\r\n\t\tVAX620 (rtVAX 1000 - ka620.bin)\r\n\t\tVAX630 (MicroVAX II - ka630.bin)\r\n\r\n#### Control Flow\r\n\r\nThe following extensions to the SCP command language without affecting prior behavior:\r\n\r\n    GOTO <Label>                 Command is now available.  Labels are lines \r\n                                 in which the first non whitespace character \r\n                                 is a \":\".  The target of a goto is the first \r\n                                 matching label in the current do command \r\n                                 file which is encountered.  Since labels \r\n                                 don't do anything else besides being the \r\n                                 targets of goto's, they could be used to \r\n                                 provide comments in do command files, for \r\n                                 example (\":: This is a comment\")\r\n    RETURN {status}              Return from the current do command file \r\n                                 execution with the specified status or\r\n                                 the status from the last executed command \r\n                                 if no status is specified.  Status can be\r\n                                 a number or a SCPE_<conditionname> name \r\n                                 string.\r\n    SET ON                       Enables error trapping for currently defined \r\n                                 traps (by ON commands)\r\n    SET NOON                     Disables error trapping for currently \r\n                                 defined traps (by ON commands)\r\n    ON <statusvalue> commandtoprocess{; additionalcommandtoprocess}\r\n                                 Sets the action(s) to take when the specific \r\n                                 error status is returned by a command in the \r\n                                 currently running do command file.  Multiple \r\n                                 actions can be specified with each delimited \r\n                                 by a semicolon character (just like \r\n                                 breakpoint action commands).\r\n    ON ERROR commandtoprocess{; additionalcommandtoprocess}\r\n                                 Sets the default action(s) to take when any \r\n                                 otherwise unspecified error status is returned \r\n                                 by a command in the currently running do \r\n                                 command file.  Multiple actions can be \r\n                                 specified with each delimited by a semicolon \r\n                                 character (just like breakpoint action \r\n                                 commands).\r\n    ON CONTROL_C commandtoprocess{; additionalcommandtoprocess}\r\n                                 Specifies particular actions to perform when\r\n                                 the operator enters CTRL+C while a command\r\n                                 procedure is running.  The default action is \r\n                                 to exit the current and any nested command \r\n                                 procedures and return to the sim> input prompt.\r\n    ON <statusvalue>             Clears the action(s) to take when condition occurs\r\n    ON ERROR                     Clears the default actions to take when any \r\n                                 otherwise unspecified error status is \r\n                                 returned by a command in the currently \r\n                                 running do command file.\r\n    ON CONTROL_C\r\n                                 Restores the default CTRL+C behavior for the\r\n                                 currently running command procedure.\r\n\r\n    DO <stdin>\r\n                                 Invokes a nested DO command with input from the \r\n                                 running console.\r\n\r\nError traps can be taken for any command which returns a status other than SCPE_STEP, SCPE_OK, and SCPE_EXIT.   \r\n\r\nON Traps can specify any status value from the following list: NXM, UNATT, IOERR, CSUM, FMT, NOATT, OPENERR, MEM, ARG, STEP, UNK, RO, INCOMP, STOP, TTIERR, TTOERR, EOF, REL, NOPARAM, ALATT, TIMER, SIGERR, TTYERR, SUB, NOFNC, UDIS, NORO, INVSW, MISVAL, 2FARG, 2MARG, NXDEV, NXUN, NXREG, NXPAR, NEST, IERR, MTRLNT, LOST, TTMO, STALL, AFAIL, NOTATT, AMBREG.  These values can be indicated by name or by their internal numeric value (not recommended).\r\n\r\nInteractions with ASSERT command and \"DO -e\":\r\n\r\n    DO -e\t\tis equivalent to SET ON, which by itself it equivalent \r\n                to \"SET ON; ON ERROR RETURN\".\r\n    ASSERT\t\tfailure have several different actions:\r\n       * If error trapping is not enabled then AFAIL causes exit from \r\n         the current do command file.\r\n       * If error trapping is enabled and an explicit \"ON AFAIL\" \r\n         action is defined, then the specified action is performed.\r\n       * If error trapping is enabled and no \"ON AFAIL\" action is \r\n         defined, then an AFAIL causes exit from the current do \r\n         command file.\r\n\r\nOther related changes/extensions:\r\nThe \"!\" command (execute a command on the local OS), now returns the command's exit status as the status from the \"!\" command.  This allows ON conditions to handle error status responses from OS commands and act as desired.\r\n\r\n#### Scriptable interactions with running simulators\r\n\r\nThe EXPECT command now exists to provide a means of reacting to simulator output and the SEND command exists to inject data into programs running within a simulator.\r\n\r\n    EXPECT {HALTAFTER=n,}\"\\r\\nPassword: \"\r\n    SEND {AFTER=n,}{DELAY=m,}\"mypassword\\r\"\r\n    \r\n    or\r\n    \r\n    EXPECT {HALTAFTER=n,}\"\\r\\nPassword: \" SEND {AFTER=n,}{DELAY=m,}\"mypassword\\r\"; GO\r\n    \r\n\r\n#### Help\r\n\r\nThe built-in help system provides a heirarchical oriented help command interface.  \r\nIn addition, there is explicit support for per device help:\r\n\r\n    HELP dev\r\n    HELP dev ATTACH\r\n    HELP dev SET  (aka HELP SET dev)\r\n    HELP dev SHOW (aka HELP SHOW dev)\r\n    HELP dev REGISTERS\r\n\r\n#### Generic SCP support Clock Coscheduling as opposed to per simulator implementations\r\n\r\nDevice simulator authors can easily schedule their device polling activities to allow for efficient simulator execution when polling for device activity while still being well behaved when their simulated system is actually idle.\r\n\r\n#### New SCP Commands:\r\n\r\n    SCREENSHOT filename.bmp          Save video window to the specified file\r\n    SET ENV Name=Value               Set Environment variable\r\n    SET ENV -p \"Prompt\" Name=Default Gather User input into an Environment Variable\r\n    SET ENV -a Name=Expression       Evaluate an expression and store result in an Environment Variable\r\n    SET ASYNCH                       Enable Asynchronous I/O\r\n    SET NOASYNCH                     Disable Asynchronous I/O\r\n    SET VERIFY                       Enable command display while processing DO command files\r\n    SET NOVERIFY                     Enable command display while processing DO command files\r\n    SET MESSAGE                      Enable error message output when commands complete (default)\r\n    SET NOMESSAGE                    Disable error message output when commands complete\r\n    SET QUIET                        Set minimal output mode for command execution\r\n    SET NOQUIET                      Set normal output mode for command execution\r\n    SET PROMPT                       Change the prompt used by the simulator (default sim>)\r\n    SET THROTTLE x/t                 Throttle t ms every x cycles\r\n    SET REMOTE TELNET=port           Specify remote console telnet port\r\n    SET REMOTE NOTELNET              Disables remote console\r\n    SET REMOTE CONNECTIONS=n         Specify the number of concurrent remote console sessions\r\n    SHOW FEATURES                    Displays the devices descriptions and features\r\n    SHOW ASYNCH                      Display the current Asynchronous I/O status\r\n    SHOW SERIAL                      Display the available and/or open serial ports\r\n    SHOW ETHERNET                    Display the available and/or open ethernet connections\r\n    SHOW MULTIPLEXER                 Display the details about open multiplexer devices\r\n    SHOW CLOCKS                      Display the details about calibrated timers\r\n    SHOW REMOTE                      Display the remote console configuration\r\n    SHOW ON                          Display ON condition dispatch actions\r\n    SET ON                           Enable ON condition error dispatching\r\n    SET NOON                         Disable ON condition error dispatching\r\n    GOTO                             Transfer to label in the current DO command file\r\n    CALL                             Call subroutine at indicated label\r\n    RETURN                           Return from subroutine call\r\n    SHIFT                            Slide argument parameters %1 thru %9 left 1\r\n    NOOP                             A no-op command\r\n    ON                               Establish or cancel an ON condition dispatch\r\n    IF                               Test some simulator state and conditionally execute commands\r\n    IF (C-style-expression)          Test some simulator state and conditionally execute commands\r\n    ELSE                             commands to execute when the previous IF wasn't true\r\n    CD                               Change working directory\r\n    SET DEFAULT                      Change working directory\r\n    PWD                              Show working directory\r\n    SHOW DEFAULT                     Show working directory\r\n    DIR {path|file}                  Display file listing\r\n    LS {path|file}                   Display file listing\r\n    NEXT                             Step across a subroutine call or step a single instruction.\r\n    EXPECT                           React to output produced by a simulated system\r\n    SEND                             Inject input to a simulated system's console\r\n    SLEEP time                       Pause command execution for specified time\r\n    SCREENSHOT                       Snapshot the current video display window\r\n    RUN UNTIL breakpoint             Establish the breakpoint specified and run until it is encountered\r\n    RUN UNTIL \"output-string\" ...    Establish the specified \"output-string\" as an EXPECT and run until it is encountered.\r\n    GO UNTIL breakpoint              Establish the breakpoint specified and go until it is encountered\r\n    GO UNTIL \"output-string\" ...     Establish the specified \"output-string\" as an EXPECT and go until it is encountered.\r\n    RUNLIMIT\t\t\t\t\t\t Bound simulator execution time\r\n    TAR                              Manipulate file archives\r\n    CURL                             Access URLs from the web\r\n\r\n#### Command Processing Enhancements\r\n\r\n##### Environment variable insertion\r\nBuilt In variables %DATE%, %TIME%, %DATETIME%, %LDATE%, %LTIME%, %CTIME%, %DATE_YYYY%, %DATE_YY%, %DATE_YC%, %DATE_MM%, %DATE_MMM%, %DATE_MONTH%, %DATE_DD%, %DATE_D%, %DATE_WYYYY%, %DATE_WW%, %TIME_HH%, %TIME_MM%, %TIME_SS%, %STATUS%, %TSTATUS%, %SIM_VERIFY%, %SIM_QUIET%, %SIM_MESSAGE%\r\n\r\n   Token \"%0\" expands to the command file name. \r\n   Token %n (n being a single digit) expands to the n'th argument\r\n   Token %* expands to the whole set of arguments (%1 ... %9)\r\n\r\n   The input sequence \"%%\" represents a literal \"%\".  All other \r\n   character combinations are rendered literally.\r\n\r\n   Omitted parameters result in null-string substitutions.\r\n\r\n   Tokens preceded and followed by % characters are expanded as environment\r\n   variables, and if an environment variable isn't found then it can be one of \r\n   several special variables: \r\n   \r\n          %DATE%              yyyy-mm-dd\r\n          %TIME%              hh:mm:ss\r\n          %DATETIME%          yyyy-mm-ddThh:mm:ss\r\n          %LDATE%             mm/dd/yy (Locale Formatted)\r\n          %LTIME%             hh:mm:ss am/pm (Locale Formatted)\r\n          %CTIME%             Www Mmm dd hh:mm:ss yyyy (Locale Formatted)\r\n          %UTIME%             nnnn (Unix time - seconds since 1/1/1970)\r\n          %DATE_YYYY%         yyyy        (0000-9999)\r\n          %DATE_YY%           yy          (00-99)\r\n          %DATE_MM%           mm          (01-12)\r\n          %DATE_MMM%          mmm         (JAN-DEC)\r\n          %DATE_MONTH%        month       (January-December)\r\n          %DATE_DD%           dd          (01-31)\r\n          %DATE_WW%           ww          (01-53)     ISO 8601 week number\r\n          %DATE_WYYYY%        yyyy        (0000-9999) ISO 8601 week year number\r\n          %DATE_D%            d           (1-7)       ISO 8601 day of week\r\n          %DATE_JJJ%          jjj         (001-366) day of year\r\n          %DATE_19XX_YY%      yy          A year prior to 2000 with the same\r\n                                          calendar days as the current year\r\n          %DATE_19XX_YYYY%    yyyy        A year prior to 2000 with the same \r\n                                          calendar days as the current year\r\n          %TIME_HH%           hh          (00-23)\r\n          %TIME_MM%           mm          (00-59)\r\n          %TIME_SS%           ss          (00-59)\r\n          %STATUS%            Status value from the last command executed\r\n          %TSTATUS%           The text form of the last status value\r\n          %SIM_VERIFY%        The Verify/Verbose mode of the current Do command file\r\n          %SIM_VERBOSE%       The Verify/Verbose mode of the current Do command file\r\n          %SIM_QUIET%         The Quiet mode of the current Do command file\r\n          %SIM_MESSAGE%       The message display status of the current Do command file\r\n          %SIM_NAME%          The name of the current simulator\r\n          %SIM_BIN_NAME%      The program name of the current simulator\r\n          %SIM_BIN_PATH%      The program path that invoked the current simulator\r\n          %SIM_OSTYPE%        The Operating System running the current simulator\r\n          %SIM_RUNTIME%       The Number of simulated instructions or cycles performed\r\n          %SIM_RUNTIME_UNITS% The units of the SIM_RUNTIME value\r\n          %SIM_REGEX_TYPE%    The regular expression type available\r\n          %SIM_MAJOR%         The major portion of the simh version\r\n          %SIM_MINOR%         The minor portion of the simh version\r\n          %SIM_PATCH%         The patch portion of the simh version\r\n          %SIM_DELTA%         The delta portion of the simh version\r\n          %SIM_VM_RELEASE%    An optional VM specific release version\r\n          %SIM_VERSION_MODE%  The release mode (Current, Alpha, Beta)\r\n          %SIM_GIT_COMMIT_ID% The git commit id of the current build\r\n          %SIM_GIT_COMMIT_TIME%  The git commit time of the current build\r\n          %SIM_RUNLIMIT%      The current execution limit defined\r\n          %SIM_RUNLIMIT_UNITS% The units of the SIM_RUNLIMIT value (instructions, cycles or time)\r\n          \r\n   Environment variable lookups are done first with the precise name between \r\n   the % characters and if that fails, then the name between the % characters\r\n   is upcased and a lookup of that values is attempted.\r\n\r\n   The first Space delimited token on the line is extracted in uppercase and \r\n   then looked up as an environment variable.  If found it the value is \r\n   substituted for the original string before expanding everything else.  If \r\n   it is not found, then the original beginning token on the line is left \r\n   untouched.\r\n\r\n##### Command aliases\r\n\r\nCommands can be aliases with environment variables.  For example:\r\n   \r\n      sim> set env say=echo\r\n      sim> say Hello there\r\n      Hello there\r\n\r\n##### Do command argument manipulation\r\n\r\nThe SHIFT command will shift the %1 thru %9 arguments to the left one position.\r\n\r\n## Building and running a simulator\r\n\r\n### Use Prebuilt Windows Simulators\r\n\r\nSimulators for the Windows platform are built and made available on a regular basis (at least once a week if substantive changes have been made to the codebase).  \r\n\r\nThe prebuilt Windows binaries will run on all versions of Microsoft Windows from Windows XP onward.\r\n\r\nThey can be accessed at https://github.com/simh/Win32-Development-Binaries\r\n\r\nSeveral relatively recent versions should be available which you can download and use directly.\r\n\r\n### Building simulators yourself\r\n\r\nFirst download the latest source code from the github repository's master branch at https://github.com/simh/simh/archive/master.zip\r\n\r\nDepending on your host platform one of the following steps should be followed:\r\n\r\n#### Linux/OSX other *nix platforms\r\n\r\nIf you are interested in using a simulator with Ethernet networking support (i.e. one of the VAX simulators or the PDP11), then you should make sure you have the correct networking components available.  The instructions in https://github.com/simh/simh/blob/master/0readme_ethernet.txt describe the required steps to get ethernet networking components installed and how to configure your environment.\r\n\r\nSee the 0readme_ethernet.txt file for details about the required network components for your platform.  Once your operating system build environment has the correct networking components available the following command will build working simulators:\r\n\r\n   $ make {simulator-name (i.e. vax)}\r\n\r\nThe makefile provided requires GNU make, which is the default make facility for most systems these days.  Any host system which doesn't have GNU make available as the default make facility may have it installed as 'gmake'.  GNU make (gmake) is generally available an installation package for all current operating systems which have a package installation system.\r\n\r\n##### Build Dependencies\r\n\r\nSome simulators depend on external packages to provide the full scope of \r\nfunctionality they may be simulating.  These additional external packages \r\nmay or may not be included in as part of the standard Operating System \r\ndistributions.  If simulators are being built that could provide more \r\nfunctionality than the currently installed packages will provide, the build\r\nwill succeed with reduced functionality (i.e. limited network or no video\r\nsupport), but suggestions will be provided as to what could provide full \r\nfunctionality.\r\n\r\n\r\n###### OS X - Dependencies\r\n\r\nThe HomeBrew package manager can be used to provide these packages:\r\n\r\n    $ brew install vde pcre libedit sdl2 libpng zlib sdl2_ttf make\r\n\r\nOR\r\n\r\nThe MacPorts package manager is available to provide these external packages.  Once MacPorts is installed, this commands will install the required dependent packages:\r\n\r\n    # port install vde2 pcre libedit libsdl2 libpng zlib libsdl2_ttf gmake\r\n\r\n###### Linux - Dependencies\r\n\r\nDifferent Linux distributions have different package management systems:\r\n\r\nUbuntu/Debian:\r\n\r\n    # apt-get install gcc libpcap-dev libvdeplug-dev libpcre3-dev libedit-dev libsdl2-dev libpng-dev libsdl2-ttf-dev\r\n\r\nFedora/RedHat:\r\n\r\n    # yum install gcc libpcap-devel pcre-devel libedit-devel SDL2-devel libpng-devel zlib-devel SDL2_ttf-devel\r\n\r\n###### NetBSD - Dependencies\r\n\r\n    # pkgin install pcre editline SDL2 png zlib SDL2_ttf gmake\r\n\r\n###### FreeBSD - Dependencies\r\n\r\n    # pkg install pcre libedit sdl2 png sdl2_ttf gmake\r\n\r\n###### OpenBSD - Dependencies\r\n\r\n    # pkg_add pcre sdl2 png sdl2-ttf gmake\r\n\r\n#### Windows\r\n\r\nCompiling on windows is supported with recent versions of Microsoft Visual Studio (Standard or Express) and deprecated using GCC via the MinGW32 environment.  Things may also work under Cygwin, but that is not the preferred windows environment.  Not all features will be available when building with MinGW32 or Cygwin.\r\n\r\n##### Required related files\r\nThe file https://github.com/simh/simh/blob/master/Visual%20Studio%20Projects/0ReadMe_Projects.txt\r\n\r\n##### Visual Studio (Standard or Express) 2008, 2010, 2012, 2013 or Visual Studio Community 2015, 2017, 2019\r\n\r\nThe file https://github.com/simh/simh/blob/master/Visual%20Studio%20Projects/0ReadMe_Projects.txt describes the required steps to use the setup your environment to build using Visual Studio.\r\n\r\n##### MinGW32\r\n\r\n\r\nBuilding with MinGW32 is deprecated and may be removed in the future since the original motivation for MinGW32 builds was due to there not being a free compiler environment on Windows.  That hasn't been the case for at least 15 years.\r\nBuilding with MinGW32 requires the same directory organization and the dependent package support described for Visual Studio in the file https://github.com/simh/simh/blob/master/Visual%20Studio%20Projects/0ReadMe_Projects.txt.  Building with MinGW64 is not supported.\r\n\r\n#### VMS\r\n\r\nDownload the latest source code as a zip file from: https://github.com/simh/simh/archive/master.zip\r\n\r\nUnzip it in the directory that you want SIMH to reside in.  Unpack it and \r\nset the file attributes as follows:\r\n\r\n    $ unzip simh-master.zip\r\n    $ set default [.simh-master]\r\n    $ set file/attri=RFM:STM makefile,*.mms,[...]*.c,[...]*.h,[...]*.txt\r\n\r\nSimulators with ethernet network devices (All the VAX simulators and the \r\nPDP11) can have functioning networking when running on Alpha or IA64 OpenVMS.\r\n\r\nIn order to build and run simulators with networking support, the VMS-PCAP \r\npackage must be available while building your simulator.  The simh-vms-pcap.zip \r\nfile can be downloaded from https://github.com/simh/simh/archive/vms-pcap.zip   \r\nThis link will return a file called simh-vms-pcap.zip which should be unpacked as follows:\r\n\r\n    $ unzip -a simh-vms-pcap.zip\r\n    $ rename [.simh-vms-pcap]pcap-vms.dir []\r\n\r\nThe PCAP-VMS components are presumed (by the descript.mms file) to be \r\nlocated in a directory at the same level as the directory containing the \r\nsimh source files.  For example, if these exist here:\r\n\r\n[]descrip.mms\r\n[]scp.c\r\netc.\r\n\r\nThen the following should exist: \r\n[-.PCAP-VMS]BUILD_ALL.COM\r\n[-.PCAP-VMS.PCAP-VCI]\r\n[-.PCAP-VMS.PCAPVCM]\r\netc.\r\n\r\nTo build simulators:\r\n\r\nOn a VAX use:\r\n\r\n    $ MMx\r\n\r\nOn a Alpha & IA64 hosts use:\r\n\r\n    $ MMx                        ! With Ethernet support\r\n    $ MMx/MACRO=(NONETWORK=1)    ! Without Ethernet support\r\n\r\nUNZIP can be found on the VMS freeware CDs, or from www.info-zip.org\r\nMMS (Module Management System) can be licensed from HP/Compaq/Digital as part of the VMS Hobbyist program (it is a component of the DECSET product).\r\nMMK can be found on the VMS freeware CDs, or from http://www.kednos.com/kednos/Open_Source/MMK\r\nDEC C can be licensed from HP/Compaq/Digital as part of the VMS Hobbyist program.\r\n\r\n## Problem Reports\r\n\r\nIf you find problems or have suggestions relating to any simulator or the simh package as a whole, please report these using the github \"Issue\" interface at https://github.com/simh/simh/issues.\r\n\r\nProblem reports should contain;\r\n - a description of the problem\r\n - the simulator you experience the problem with\r\n - your host platform (and OS version)\r\n - how you built the simulator or that you're using prebuilt binaries\r\n - the simulator build description should include the output produced by while building the simulator\r\n - the output of SHOW VERSION while running the simulator which is having an issue\r\n - the simulator configuration file (or commands) which were used when the problem occurred.\r\n \r\n"
        },
        {
          "name": "S3",
          "type": "tree",
          "content": null
        },
        {
          "name": "SAGE",
          "type": "tree",
          "content": null
        },
        {
          "name": "SDS",
          "type": "tree",
          "content": null
        },
        {
          "name": "SEL32",
          "type": "tree",
          "content": null
        },
        {
          "name": "SSEM",
          "type": "tree",
          "content": null
        },
        {
          "name": "TX-0",
          "type": "tree",
          "content": null
        },
        {
          "name": "VAX",
          "type": "tree",
          "content": null
        },
        {
          "name": "Visual Studio Projects",
          "type": "tree",
          "content": null
        },
        {
          "name": "alpha",
          "type": "tree",
          "content": null
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 6.884765625,
          "content": "image:\r\n  - macos-bigsur\r\n  - Ubuntu1604\r\n  - Visual Studio 2015\r\n\r\nplatform:\r\n  - x86\r\n\r\nenvironment:\r\n  access_token:\r\n    secure: Me2UWjTL1G91AfTT9ruasivTMxtSO0SZbv3wIFRS2RygMiZhU8r9sSQ3a9QB7h70wnl2W2Cv8o1v0Z2hONpltyxKxlSP4OqXeIIIx0ssRMgg8rkm2qlDWcCzZur3tM4v\r\n\r\nmatrix:\r\n  fast_finish: true\r\n\r\ncache:\r\n  - ../windows-build\r\n\r\nskip_commits:\r\n  files:\r\n    - doc/*\r\n    - '**/*.md'\r\n    - '**/*.txt'\r\n    \r\nbefore_build:\r\n  - ps: |\r\n        Write-Output \"Building repo '$env:APPVEYOR_REPO_NAME' branch: $env:APPVEYOR_REPO_BRANCH\"\r\n        $platform = uname -s\r\n        if ($platform -eq 'Linux') {\r\n          sudo apt-get update -yqqm\r\n          sudo apt-get install -ym gcc libpcap-dev libvdeplug-dev libpcre3-dev libedit-dev libsdl2-dev libpng-dev libsdl2-ttf-dev\r\n        } else {\r\n          if ($platform -eq 'Darwin') {\r\n            $env:HOMEBREW_NO_AUTO_UPDATE=1; brew install vde pcre libedit sdl2 libpng zlib sdl2_ttf make git-lfs\r\n          }\r\n        }\r\n        git lfs install\r\n\r\nbuild_script:\r\n  - cmd: |\r\n         \"C:\\Program Files (x86)\\Microsoft Visual Studio 9.0\\VC\\vcvarsall.bat\"\r\n         echo Building with %NUMBER_OF_PROCESSORS% processors\r\n         cd \"Visual Studio Projects\" & vcbuild /M%NUMBER_OF_PROCESSORS% /useenv /rebuild simh.sln \"Release|Win32\" & cd ..\r\n  - ps: |\r\n        if ($isWindows) {\r\n          $platform = 'Windows'\r\n          $arch = 'Win32'\r\n          $commit_id_file = 'Visual Studio Projects\\.git-commit-id.h' \r\n        } else {\r\n          $platform = uname -s\r\n          $arch = arch\r\n          if ($platform -eq 'Linux') {\r\n            $ncpus = nproc\r\n            $parallel = '-j' + $ncpus\r\n            Write-Host \"Building with $ncpus processors\"\r\n          } else {\r\n            $platform = 'macOS'\r\n          }\r\n          $commit_id_file = '.git-commit-id' \r\n          make QUIET=1 $parallel\r\n        }\r\n\r\non_success:\r\n  - ps: |\r\n        $id_line = Select-String -Path $commit_id_file -Pattern 'SIM_GIT_COMMIT_ID'\r\n        $id = $id_line.Line.SubString($id_line.line.IndexOf(\"SIM_GIT_COMMIT_ID\") + 18, 8)\r\n        $datetime = Get-Date -Format \"yyyy-MM-dd_HH-mm-ss\"\r\n        $version_major = (Select-String -Path 'sim_rev.h' -Pattern '#define\\s+SIM_MAJOR\\s+(\\d+)').Matches.Groups[1].Value\r\n        $version_minor = (Select-String -Path 'sim_rev.h' -Pattern '#define\\s+SIM_MINOR\\s+(\\d+)').Matches.Groups[1].Value\r\n        $version_mode =  (Select-String -Path 'sim_rev.h' -Pattern '#define\\s+SIM_VERSION_MODE\\s+\"(.+?)\"').Matches.Groups[1].Value\r\n  - git config --global credential.helper store\r\n  - ps: Set-Content -Path \"$HOME\\.git-credentials\" -Value \"https://$($env:access_token):x-oauth-basic@github.com`n\" -NoNewline\r\n  - git config --global credential.helper store\r\n  - git config --global user.email \"mark@infocomm.com\"\r\n  - git config --global user.name \"Mark Pizzolato\"\r\n  - git config --global core.autocrlf false\r\n# Linux & macOS use the shell to address this, Windows uses cmd. Poweshell on Windows doesn't like git output to stderr\r\n  - sh: |\r\n        if test -d ../Development-Binaries\r\n        then\r\n          pushd ../Development-Binaries\r\n          git pull origin master\r\n          popd\r\n        else\r\n          pushd ..\r\n          git clone -q \"https://github.com/simh/Development-Binaries\" Development-Binaries\r\n          popd\r\n        fi\r\n  - cmd: |\r\n         if NOT EXIST ..\\Development-Binaries pushd .. & git clone -q \"https://github.com/simh/Development-Binaries\" Development-Binaries & popd\r\n         pushd ..\\Development-Binaries & git pull origin master & popd\r\n  - ps: |\r\n        cd ../Development-Binaries\r\n        $pkg_filename = \"simh-$datetime-$platform-$arch-$version_major.$version_minor-$version_mode-$id\"\r\n        if ($isWindows) {\r\n          $pkg_filename = $pkg_filename + '.zip'\r\n          Compress-Archive -Path $env:APPVEYOR_BUILD_FOLDER\\BIN\\NT\\Win32-Release\\*.exe -DestinationPath \"$pkg_filename\"\r\n        } else {\r\n          $pkg_filename = $pkg_filename + '.tgz'\r\n          pushd $env:APPVEYOR_BUILD_FOLDER/BIN\r\n          tar -cvzf ../../Development-Binaries/$pkg_filename --exclude=buildtools --exclude=NT '--exclude=*-build'  *\r\n          popd\r\n        }\r\n        \"$platform Build results for simh Commit: https://github.com/simh/simh/commit/$id\" | Out-File -FilePath ../pkg_commit_message -Encoding Ascii\r\n        (Get-Content README.md) -replace ('(\\['+$platform+' is here\\]\\(https\\:\\/\\/github\\.com\\/simh\\/Development-Binaries\\/blob\\/master\\/)([a-zA-Z0-9._-]+)(.+\\.)'),('$1'+$pkg_filename+'$3') | Out-File -FilePath README.md -Encoding Ascii\r\n        $recent_saved_commit = git log -1  --grep=\"$platform Build\" --pretty=format:%H\r\n        $recent_saved_commit_time = git log -1 --pretty=\"%at\" $recent_saved_commit\r\n        $oneweek=$((60 * 60 * 24 * 7))\r\n        # Only update the https://github.com/simh/DevelopmentBinaries repository \r\n        # during CI/CD processing of direct commits pushed to the \r\n        # https://github.com/simh/simh repository (i.e. don't update the\r\n        # DevelopmentBinaries when CI/CD actions are being done on external\r\n        # pull requests.\r\n        # Additionally, only update the https://github.com/simh/DevelopmentBinaries \r\n        # repository if the current build for this platform is one week or more \r\n        # from the last saved build for this platform in the repository\r\n        if (((Get-Date -UFormat %s) -gt $recent_saved_commit_time + $oneweek) -and \r\n            (\"$env:APPVEYOR_PULL_REQUEST_NUMBER\" -eq \"\")) {\r\n          (\"$platform Build\") | Out-File -FilePath ../Save-Build-Results\r\n        }\r\n        Write-Output \"Building repo '$env:APPVEYOR_REPO_NAME' branch: $env:APPVEYOR_REPO_BRANCH\"\r\n        if (\"$env:APPVEYOR_PULL_REQUEST_NUMBER\" -ne \"\") {\r\n          Write-Output \"Skipping Saving binaries for pull request $env:APPVEYOR_PULL_REQUEST_NUMBER CI build\"\r\n        } else {\r\n          if ((Get-Date -UFormat %s) -lt $recent_saved_commit_time + $oneweek) {\r\n            Write-Output \"Skipping Saving binaries since the last one was saved \" + (([System.DateTimeOffset]::FromUnixTimeSeconds($recent_saved_commit_time)).DateTime).ToString()\r\n          }\r\n        }\r\n  # Linux & macOS use the shell to perform git activities.\r\n  # Windows uses cmd. Poweshell on Windows doesn't like git output to stderr\r\n  - sh: |\r\n        if [ -f ../Save-Build-Results ]\r\n        then\r\n          git add *\r\n          git commit -F ../pkg_commit_message\r\n          git push -u origin master\r\n        else\r\n          # clean up the un-committed pieces so the cache is maintained correctly\r\n          git reset --hard\r\n        fi\r\n  - cmd: |\r\n         if EXIST ..\\Save-Build-Results        git add *\r\n         if EXIST ..\\Save-Build-Results        git commit -F ../pkg_commit_message\r\n         if EXIST ..\\Save-Build-Results        git push -u origin master\r\n         rem clean up the un-committed pieces so the cache is maintained correctly\r\n         if NOT EXIST ..\\Save-Build-Results    git reset --hard\r\n\r\nnotifications:\r\n  - provider: Email\r\n    to:\r\n      - Mark@infocomm.com\r\n    on_build_success: false\r\n"
        },
        {
          "name": "build_mingw.bat",
          "type": "blob",
          "size": 0.669921875,
          "content": "@echo off\r\nrem Compile all of SIMH using MINGW make and gcc environment\r\nrem\r\nrem The makefile will determine if the needed WinPcap build \r\nrem components are available and the resulting simulators will\r\nrem run with networking support when the WinPcap environment \r\nrem is installed on the running system.\r\nrem\r\nrem Individual simulator sources are in .\\simulator_name\r\nrem Individual simulator executables are to .\\BIN\r\nrem\r\nrem If needed, define the path for the MINGW bin directory.\r\nrem\r\ngcc -v 1>NUL 2>NUL\r\nif ERRORLEVEL 1 path C:\\MinGW\\bin;%path%\r\nif not exist BIN mkdir BIN\r\ngcc -v 1>NUL 2>NUL\r\nif ERRORLEVEL 1 echo \"MinGW Environment Unavailable\"\r\nmingw32-make -f makefile %*\r\n"
        },
        {
          "name": "build_mingw_ether.bat",
          "type": "blob",
          "size": 0.2314453125,
          "content": "@echo off\r\nrem Built in Ethernet support (requires WinPcap installed).\r\nrem The normal Windows build always builds with Ethernet support\r\nrem so, this procedure is un-necessary.  Just call the normal build\r\nrem\r\n%~p0\\build_mingw.bat %*\r\n"
        },
        {
          "name": "build_mingw_noasync.bat",
          "type": "blob",
          "size": 0.5166015625,
          "content": "@echo off\r\nrem Build without SIM_ASYNCH_IO defined (avoiding the use of pthreads)\r\nrem Compile all of SIMH using MINGW make and gcc environment\r\nrem Individual simulator sources are in .\\simulator_name\r\nrem Individual simulator executables are to .\\BIN\r\nrem\r\nrem If needed, define the path for the MINGW bin directory.\r\nrem\r\ngcc -v 1>NUL 2>NUL\r\nif ERRORLEVEL 1 path C:\\MinGW\\bin;%path%\r\nif not exist BIN mkdir BIN\r\ngcc -v 1>NUL 2>NUL\r\nif ERRORLEVEL 1 echo \"MinGW Environment Unavailable\"\r\nmingw32-make NOASYNCH=1 -f makefile %*\r\n"
        },
        {
          "name": "build_vstudio.bat",
          "type": "blob",
          "size": 10.626953125,
          "content": "@echo off\r\n:: Rebuild all of SIMH simulators using Visual Studio\r\n::\r\n:: If this procedure is not invoked from a Developer command prompt\r\n:: then the VS2008 tools are preferred if VS2008 is installed, \r\n:: otherwise the installed Visual Studio tools will be used \r\n:: preferring newer Visual Studio versions over older ones.\r\n::\r\n:: If this is invoked with Visual Studio 2022 installed along with\r\n:: the \"C++ for Windows XP Support for VS 2017 (v141) tools\" option\r\n:: installed, then the project files will be converted, if needed\r\n:: to leverage the available support so that the executables created\r\n:: will run on all versions of Windows from XP onward.\r\n::\r\n:: If this procedure is invoked from a Developer command prompt\r\n:: then the tool chain provided with the command prompt is used\r\n:: to build the simh projects.\r\n::\r\n:: A single argument to this procedure may be the word Debug, which \r\n:: will cause Debug binaries to be built rather than the Release \r\n:: binaries which is the default.\r\n::\r\n:: The default is to build all simulators mentioned in the simh solution.\r\n:: Optionally, individual simulators may be built by listing the specific\r\n:: simulator names on the command line invoking this procedure.\r\n::\r\n:: Individual simulator sources are in .\\simulator_name\r\n:: Individual simulator executables are produced in .\\BIN\\NT\\Win32-{Debug or Release}\\\r\n::\r\n::\r\n\r\n:: Initialize target variables\r\nset _BUILD_CONFIG=Release\r\nset _BUILD_PROJECTS=\r\nset _REBUILD_PROJECTS=\r\nset _BUILD_PROJECT_DIR=%~dp0Visual Studio Projects\\\r\n:_CheckArg\r\nif \"%1\" == \"\" goto _DoneArgs\r\nif /i \"%1\" == \"Debug\" set _BUILD_CONFIG=Debug& shift & goto _CheckArg\r\nif /i \"%1\" == \"Release\" set _BUILD_CONFIG=Release& shift & goto _CheckArg\r\ncall :GetFileName \"%_BUILD_PROJECT_DIR%%1.vcproj\" _BUILD_PROJECT\r\nif exist \"%_BUILD_PROJECT_DIR%%1.vcproj\" set _BUILD_PROJECTS=%_BUILD_PROJECTS%;%_BUILD_PROJECT%\r\nif exist \"%_BUILD_PROJECT_DIR%%1.vcproj\" set _REBUILD_PROJECTS=%_REBUILD_PROJECTS%;%_BUILD_PROJECT%:Rebuild\r\nif exist \"%_BUILD_PROJECT_DIR%%1.vcproj\" shift & goto _CheckArg\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR\r\necho **\r\necho ** No such project: %1\r\necho **\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR\r\nexit /b 1\r\n\r\n:_DoneArgs\r\nset _VC_VER=\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio 9.0\\VC\\vcvarsall.bat\" call \"%ProgramFiles(x86)%\\Microsoft Visual Studio 9.0\\VC\\vcvarsall.bat\" \r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Auxiliary\\Build\\vcvars32.bat\" call \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Enterprise\\VC\\Auxiliary\\Build\\vcvars32.bat\"\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Professional\\VC\\Auxiliary\\Build\\vcvars32.bat\" call \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Professional\\VC\\Auxiliary\\Build\\vcvars32.bat\"\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\" call \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\"\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\" call \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\"\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\" call \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvars32.bat\"\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\" call \"%ProgramFiles(x86)%\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat\" x86\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio 12.0\\VC\\vcvarsall.bat\" call \"%ProgramFiles(x86)%\\Microsoft Visual Studio 12.0\\VC\\vcvarsall.bat\" x86\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\nif exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio 10.0\\VC\\vcvarsall.bat\" call \"%ProgramFiles(x86)%\\Microsoft Visual Studio 10.0\\VC\\vcvarsall.bat\" x86\r\ncall :FindVCVersion _VC_VER\r\nif not \"%_VC_VER%\" == \"\" goto GotVC\r\n\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR **\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR **\r\necho **                                                    **\r\necho **   I can't find a Visual Studio version installed   **\r\necho **   in the default location on this system.          **\r\necho **                                                    **\r\necho **   If you haven't installed any version of Visual   **\r\necho **   Studio yet, you must install one before this     **\r\necho **   procedure can be used.  The earliest Visual      **\r\necho **   Studio version that is supported is VS2008 which **\r\necho **   can be downloaded and installed from:            **\r\necho **                                                    **\r\necho http://download.microsoft.com/download/E/8/E/E8EEB394-7F42-4963-A2D8-29559B738298/VS2008ExpressWithSP1ENUX1504728.iso\r\necho **                                                    **\r\necho **   Newer versions of Visual Studio are also         **\r\necho **   supported, but the initial build will have to    **\r\necho **   convert the VS2008 project definitions.          **\r\necho **                                                    **\r\necho **   If you installed a version of Visual Studio C++  **\r\necho **   in a non default location, then you must invoke  **\r\necho **   this procedure from a developer command prompt   **\r\necho **   for the version of Visual Studio you have        **\r\necho **   installed.                                       **\r\necho **                                                    **\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR **\r\necho ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR ** ERROR **\r\nexit /b 1\r\n\r\n:WhichInPath\r\nif \"%~$PATH:1\" EQU \"\" exit /B 1\r\nset %2=%~$PATH:1\r\nexit /B 0\r\n\r\n:FindVCVersion\r\ncall :WhichInPath cl.exe _VC_CL_\r\nfor /f \"tokens=3-9 delims=\\\" %%a in (\"%_VC_CL_%\") do call :VCCheck _VC_VER_NUM_ \"%%a\" \"%%b\" \"%%c\" \"%%d\" \"%%e\" \"%%f\" \"%%g\"\r\nfor /f \"delims=.\" %%a in (\"%_VC_VER_NUM_%\") do set %1=%%a\r\nset _VC_CL=\r\nexit /B 0\r\n\r\n:VCCheck\r\nset _VC_TMP=%1\r\n:_VCCheck_Next\r\nshift\r\nset _VC_TMP_=%~1\r\nif \"%_VC_TMP_%\" equ \"\" goto _VCCheck_Done\r\nif \"%_VC_TMP_:~0,24%\" EQU \"Microsoft Visual Studio \" set %_VC_TMP%=%_VC_TMP_:Microsoft Visual Studio =%\r\ncall :IsNumeric _VC_NUM_ %_VC_TMP_%\r\nif \"%_VC_NUM_%\" neq \"\" set %_VC_TMP%=%~1\r\nif \"%_VC_NUM_%\" neq \"\" goto _VCCheck_Done\r\ngoto _VCCheck_Next\r\n:_VCCheck_Done\r\nset _VC_TMP_=\r\nset _VC_TMP=\r\nset _VC_NUM_=\r\nexit /B 0\r\n\r\n:IsNumeric\r\nset _Numeric_TMP_=%~1\r\nset _Numeric_Test_=%2\r\nset _Numeric_Test_=%_Numeric_Test_:~0,1%\r\nset %_Numeric_TMP_%=\r\nif \"%_Numeric_Test_%\"==\"0\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"1\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"2\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"3\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"4\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"5\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"6\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"7\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"8\" set %_Numeric_TMP_%=1\r\nif \"%_Numeric_Test_%\"==\"9\" set %_Numeric_TMP_%=1\r\nset _Numeric_TMP_=\r\nset _Numeric_Test_=\r\nexit /B 0\r\n\r\n:GetFileName\r\nset %2=%~n1\r\nexit /B 0\r\n\r\n:GotVC\r\nset _BUILD_PARALLEL=8\r\nif %_BUILD_PARALLEL% GTR %NUMBER_OF_PROCESSORS% set _BUILD_PARALLEL=%NUMBER_OF_PROCESSORS%\r\nset _SLN_FILE=%_BUILD_PROJECT_DIR%Simh.sln\r\nif exist \"%_BUILD_PROJECT_DIR%Simh-%_VC_VER%.sln\" set _SLN_FILE=%_BUILD_PROJECT_DIR%Simh-%_VC_VER%.sln\r\nSET _X_SLN_VERSION=\r\necho _SLN_FILE=%_SLN_FILE%\r\nfor /F \"usebackq tokens=8\" %%a in (`findstr /C:\"Microsoft Visual Studio Solution File, Format Version\" \"%_SLN_FILE%\"`) do SET _X_SLN_VERSION=%%a\r\n\r\nif not \"%_VC_VER%\" == \"9\" goto _DoMSBuild\r\nif \"%_BUILD_PROJECTS%\" == \"\" vcbuild /nologo /M%_BUILD_PARALLEL% /useenv /rebuild \"%_SLN_FILE%\" \"%_BUILD_CONFIG%|Win32\" & goto :EOF\r\n\r\nset _BUILD_PROJECTS=%_BUILD_PROJECTS:~1%\r\n:_NextProject\r\nset _BUILD_PROJECT=\r\nfor /f \"tokens=1* delims=;\" %%a in (\"%_BUILD_PROJECTS%\") do set _BUILD_PROJECT=%%a& set _BUILD_PROJECTS=%%b\r\nif \"%_BUILD_PROJECT%\" == \"\" goto :EOF\r\necho.\r\necho Building %_BUILD_PROJECT%\r\nvcbuild /nologo /useenv /rebuild \"%_BUILD_PROJECT_DIR%%_BUILD_PROJECT%.vcproj\" \"%_BUILD_CONFIG%|Win32\" \r\ngoto _NextProject\r\n\r\n:_DoMSBuild\r\nif \"%_X_SLN_VERSION%\" == \"10.00\" set _NEW_SLN_FILE=%_BUILD_PROJECT_DIR%Simh-%_VC_VER%.sln\r\nif \"%_X_SLN_VERSION%\" == \"10.00\" copy /y \"%_SLN_FILE%\" \"%_NEW_SLN_FILE%\" >NUL & echo Converting the VS2008 projects to VS%_VC_VER%, this will take several (3-5) minutes & DevEnv /Upgrade \"%_NEW_SLN_FILE%\" & set _SLN_FILE=%_NEW_SLN_FILE%\r\nset _NEW_SLN_FILE=\r\nif not \"%_VC_VER%\" == \"2022\" goto _RunBuild\r\nif exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Microsoft\\VC\\v150\\Platforms\\x64\\PlatformToolsets\\v141_xp\" goto _DoXPConvert\r\nif exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Professional\\MSBuild\\Microsoft\\VC\\v150\\Platforms\\x64\\PlatformToolsets\\v141_xp\" goto _DoXPConvert\r\nif exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Microsoft\\VC\\v150\\Platforms\\x64\\PlatformToolsets\\v141_xp\" goto _DoXPConvert\r\ngoto _RunBuild\r\n\r\n:_DoXPConvert\r\nset _X_PROJS_CONVERTED=\r\nfor /F \"usebackq tokens=1\" %%a in (`findstr /C:\"<WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\" \"%_BUILD_PROJECT_DIR%BuildROMs.vcxproj\"`) do set _X_PROJS_CONVERTED=%%a\r\nif not \"%_X_PROJS_CONVERTED%\" == \"\" goto _RunBuild\r\necho Converting the VS2022 projects to generate XP compatible binaries\r\nPowershell -NoLogo -File \"%~dp0\\Visual Studio Projects\\ConvertToXPProject.ps1\" \"%~dp0\\Visual Studio Projects\\*.vcxproj\"\r\nset _X_PROJS_CONVERTED=\r\n:_RunBuild\r\nif \"%_BUILD_PROJECTS%\" == \"\" MSBuild /nologo \"%_SLN_FILE%\" /maxCpuCount:%_BUILD_PARALLEL% /Target:Rebuild /Property:Configuration=%_BUILD_CONFIG% /Property:Platform=Win32 /fileLogger \"/fileLoggerParameters:LogFile=%_BUILD_PROJECT_DIR%Build-VS%_VC_VER%.log\" & goto :EOF\r\nset _BUILD_PROJECTS=%_BUILD_PROJECTS:~1%\r\nset _REBUILD_PROJECTS=%_REBUILD_PROJECTS:~1%\r\nMSBuild /nologo \"%_SLN_FILE%\" /maxCpuCount:%_BUILD_PARALLEL% /Target:%_REBUILD_PROJECTS% /Property:Configuration=%_BUILD_CONFIG% /Property:Platform=Win32 \"/fileLoggerParameters:LogFile=%_BUILD_PROJECT_DIR%Build-VS%_VC_VER%.log\" & goto :EOF\r\nset _SLN_FILE=\r\n"
        },
        {
          "name": "descrip.mms",
          "type": "blob",
          "size": 140.310546875,
          "content": "# DESCRIP.MMS\r\n# Written By:   Robert Alan Byer / byer@mail.ourservers.net\r\n# Modified By:  Mark Pizzolato / mark@infocomm.com\r\n#               Norman Lastovica / norman.lastovica@oracle.com\r\n#               Camiel Vanderhoeven / camiel@camicom.com\r\n#               Matt Burke / matt@9track.net\r\n#\r\n# This MMS/MMK build script is used to compile the various simulators in\r\n# the SIMH package for OpenVMS using DEC C v6.0-001(AXP), v6.5-001(AXP),\r\n# HP C V7.3-009-48GBT (AXP), HP C V7.2-001 (IA64) and v6.4-005(VAX).\r\n#\r\n# Notes:  On VAX, the PDP-10, Eclipse, IBM 7094 and BESM6 simulators will\r\n#         not be built due to the fact that INT64 is required for these\r\n#         simulators.\r\n#\r\n# This build script will accept the following build options.\r\n#\r\n#            ALL               Just Build \"Everything\".\r\n#            3B2               Just Build The AT&T 3B2.\r\n#            ALTAIR            Just Build The MITS Altair.\r\n#            ALTAIRZ80         Just Build The MITS Altair Z80.\r\n#            BESM6             Just Build The BESM-6.\r\n#            B5500             Just Build The B5500.\r\n#            CDC1700           Just Build The CDC1700.\r\n#            ECLIPSE           Just Build The Data General Eclipse.\r\n#            GRI               Just Build The GRI Corporation GRI-909.\r\n#            LGP               Just Build The Royal-McBee LGP-30.\r\n#            H316              Just Build The Honeywell 316/516.\r\n#            HP2100            Just Build The Hewlett-Packard HP-2100.\r\n#            HP3000            Just Build The Hewlett-Packard HP-3000.\r\n#            I1401             Just Build The IBM 1401.\r\n#            I1620             Just Build The IBM 1620.\r\n#            I7094             Just Build The IBM 7094.\r\n#            IBM1130           Just Build The IBM 1130.\r\n#            ID16              Just Build The Interdata 16-bit CPU.\r\n#            ID32              Just Build The Interdata 32-bit CPU.\r\n#            INFOSERVER1000    Just Build The DEC InfoServer 1000.\r\n#            NOVA              Just Build The Data General Nova.\r\n#            PDP1              Just Build The DEC PDP-1.\r\n#            PDP4              Just Build The DEC PDP-4.\r\n#            PDP6              Just Build The DEC PDP-6.\r\n#            PDP7              Just Build The DEC PDP-7.\r\n#            PDP8              Just Build The DEC PDP-8.\r\n#            PDP9              Just Build The DEC PDP-9.\r\n#            PDP10             Just Build The DEC PDP-10 KS10.\r\n#            PDP10-KA          Just Build The DEC PDP-10 KA10.\r\n#            PDP10-KI          Just Build The DEC PDP-10 KI10.\r\n#            PDP11             Just Build The DEC PDP-11.\r\n#            PDP15             Just Build The DEC PDP-15.\r\n#            S3                Just Build The IBM System 3.\r\n#            SDS               Just Build The SDS 940.\r\n#            SSEM              Just Build the Manchester University SSEM.\r\n#            SWTP6800MP-A      Just Build The SWTP6800MP-A.\r\n#            SWTP6800MP-A2     Just Build The SWTP6800MP-A2.\r\n#            VAX               Just Build The DEC MicroVAX3900 (aka VAX).\r\n#            MicroVAX3900      Just Build The DEC MicroVAX3900 (aka VAX).\r\n#            MicroVAX1         Just Build The DEC MicroVAX1 (MicroVAX I).\r\n#            rtVAX1000         Just Build The DEC rtVAX1000 (rtVAX 1000).\r\n#            MicroVAX2         Just Build The DEC MicroVAX2 (MicroVAX II).\r\n#            MICROVAX2000      Just Build The DEC MicroVAX 2000.\r\n#            INFOSERVER100     Just Build The DEC InfoServer 100.\r\n#            INFOSERVER150VXT  Just Build The DEC InfoServer 150 VXT.\r\n#            MICROVAX3100      Just Build The DEC MicroVAX 3100 M10/M20.\r\n#            MICROVAX3100E     Just Build The DEC MicroVAX 3100 M10e/M20e.\r\n#            VAXSTATION3100M30 Just Build The DEC VAXstation 3100 M30.\r\n#            VAXSTATION3100M38 Just Build The DEC VAXstation 3100 M38.\r\n#            VAXSTATION3100M76 Just Build The DEC VAXstation 3100 M76.\r\n#            VAXSTATION4000M60 Just Build The DEC VAXstation 4000 M60.\r\n#            VAXSTATION3100M80 Just Build The DEC MicroVAX 3100 M80.\r\n#            VAXSTATION4000VLC Just Build The DEC VAXstation 4000 VLC.\r\n#            VAX730            Just Build The DEC VAX730.\r\n#            VAX750            Just Build The DEC VAX750.\r\n#            VAX780            Just Build The DEC VAX780.\r\n#            VAX8200           Just Build The DEC VAX8200.\r\n#            VAX8600           Just Build The DEC VAX8600.\r\n#            CLEAN             Will Clean Files Back To Base Kit.\r\n#\r\n# To build with debugging enabled (which will also enable traceback\r\n# information) use..\r\n#\r\n#        MMK/MACRO=(DEBUG=1)\r\n#\r\n# This will produce an executable named {Simulator}-{I64|VAX|AXP}-DBG.EXE\r\n#\r\n# To build on older Alpha VMS platforms, SIM_ASYNCH_IO must be disabled.\r\n# use..\r\n#\r\n#        MMK/MACRO=(NOASYNCH=1)\r\n#\r\n# On AXP and IA64 the VMS PCAP components are built and used to provide\r\n# network support for the VAX and PDP11 simulators.\r\n#\r\n# The AXP PCAP components can only be built using a version of the\r\n# DEC/Compaq/HP Compiler version V6.5-001 or later.  To build using an\r\n# older compiler, networking support must be disabled.  Use...\r\n#\r\n#        MMK/MACRO=(NONETWORK=1)\r\n#\r\n# The PCAP-VMS components are presumed (by this procedure) to be located\r\n# in a directory at the same level as the directory containing the\r\n# simh source files.  For example, if these exist here:\r\n#\r\n#   []descrip.mms\r\n#   []scp.c\r\n#   etc.\r\n#\r\n# Then the following should exist:\r\n#   [-.PCAP-VMS]BUILD_ALL.COM\r\n#   [-.PCAP-VMS.PCAP-VCI]\r\n#   [-.PCAP-VMS.PCAPVCM]\r\n#   etc.\r\n\r\n# Let's See If We Are Going To Build With DEBUG Enabled.  Always compile\r\n# /DEBUG so that the traceback and debug information is always available\r\n# in the object files.\r\n\r\nCC_DEBUG = /DEBUG\r\n\r\n.IFDEF DEBUG\r\nCC_OPTIMIZE = /NOOPTIMIZE\r\nNEST_DEBUG = ,DEBUG=1\r\n\r\n.IFDEF MMSALPHA\r\nALPHA_OR_IA64 = 1\r\nCC_FLAGS = /PREF=ALL\r\n.IFDEF NOASYNCH\r\nARCH = AXP-NOASYNCH-DBG\r\nCC_DEFS = \"_LARGEFILE\"\r\nLINK_DEBUG = /DEBUG/TRACEBACK\r\n.ELSE\r\nARCH = AXP-DBG\r\nCC_DEFS = \"_LARGEFILE\",\"SIM_ASYNCH_IO=1\"\r\nLINK_DEBUG = /DEBUG/TRACEBACK/THREADS_ENABLE\r\n.ENDIF\r\n.ENDIF\r\n\r\n.IFDEF MMSIA64\r\nALPHA_OR_IA64 = 1\r\nCC_FLAGS = /PREF=ALL\r\n.IFDEF NOASYNCH\r\nARCH = I64-NOASYNCH-DBG\r\nCC_DEFS = \"_LARGEFILE\"\r\nLINK_DEBUG = /DEBUG/TRACEBACK\r\n.ELSE\r\nARCH = I64-DBG\r\nCC_DEFS = \"_LARGEFILE\",\"SIM_ASYNCH_IO=1\"\r\nLINK_DEBUG = /DEBUG/TRACEBACK/THREADS_ENABLE\r\n.ENDIF\r\n.ENDIF\r\n\r\n.IFDEF MMSVAX\r\nCC_FLAGS = $(CC_FLAGS)\r\nARCH = VAX-DBG\r\nCC_DEFS = \"__VAX\"\r\nLINK_DEBUG = /DEBUG/TRACEBACK\r\n.ENDIF\r\n\r\n.ELSE\r\n# !DEBUG\r\n\r\n.IFDEF MMSALPHA\r\nALPHA_OR_IA64 = 1\r\nCC_OPTIMIZE = /OPT=(LEV=5)/ARCH=HOST\r\nCC_FLAGS = /PREF=ALL\r\n.IFDEF NOASYNCH\r\nARCH = AXP-NOASYNCH\r\nCC_DEFS = \"_LARGEFILE\"\r\nLINK_DEBUG = /NODEBUG/NOTRACEBACK\r\n.ELSE\r\nARCH = AXP\r\nCC_DEFS = \"_LARGEFILE\",\"SIM_ASYNCH_IO=1\"\r\nLINK_DEBUG = /NODEBUG/NOTRACEBACK/THREADS_ENABLE\r\n.ENDIF\r\nLINK_SECTION_BINDING = /SECTION_BINDING\r\n.ENDIF\r\n\r\n.IFDEF MMSIA64\r\nALPHA_OR_IA64 = 1\r\nCC_OPTIMIZE = /OPT=(LEV=5)\r\nCC_FLAGS = /PREF=ALL\r\n.IFDEF NOASYNCH\r\nARCH = I64-NOASYNCH\r\nCC_DEFS = \"_LARGEFILE\"\r\nLINK_DEBUG = /NODEBUG/NOTRACEBACK\r\n.ELSE\r\nARCH = I64\r\nCC_DEFS = \"_LARGEFILE\",\"SIM_ASYNCH_IO=1\"\r\nLINK_DEBUG = /NODEBUG/NOTRACEBACK/THREADS_ENABLE\r\n.ENDIF\r\n.ENDIF\r\n\r\n.IFDEF MMSVAX\r\nCC_OPTIMIZE = /OPTIMIZE\r\nCC_FLAGS = $(CC_FLAGS)\r\nARCH = VAX\r\nCC_DEFS = \"__VAX\"\r\nLINK_DEBUG = /NODEBUG/NOTRACEBACK\r\n.ENDIF\r\n\r\n.ENDIF\r\n\r\n\r\n# Define Our Compiler Flags & Define The Compile Command\r\nOUR_CC_FLAGS = $(CC_FLAGS)$(CC_DEBUG)$(CC_OPTIMIZE) \\\r\n               /NEST=PRIMARY/NAME=(AS_IS,SHORT)\r\nCC = CC/DECC$(OUR_CC_FLAGS)\r\n\r\n# Define The BIN Directory Where The Executables Will Go.\r\n# Define Our Library Directory.\r\n# Define The platform specific Build Directory Where The Objects Will Go.\r\n#\r\nBIN_DIR = SYS$DISK:[.BIN]\r\nLIB_DIR = SYS$DISK:[.BIN.VMS.LIB]\r\nBLD_DIR = SYS$DISK:[.BIN.VMS.LIB.BLD-$(ARCH)]\r\n\r\n\r\n# Core SIMH File Definitions.\r\n#\r\nSIMH_DIR = SYS$DISK:[]\r\nSIMH_LIB = $(LIB_DIR)SIMH-$(ARCH).OLB\r\nSIMH_NONET_LIB = $(LIB_DIR)SIMH-NONET-$(ARCH).OLB\r\nSIMH_SOURCE = $(SIMH_DIR)SIM_CONSOLE.C,$(SIMH_DIR)SIM_SOCK.C,\\\r\n              $(SIMH_DIR)SIM_TMXR.C,$(SIMH_DIR)SIM_ETHER.C,\\\r\n              $(SIMH_DIR)SIM_TAPE.C,$(SIMH_DIR)SIM_FIO.C,\\\r\n              $(SIMH_DIR)SIM_TIMER.C,$(SIMH_DIR)SIM_DISK.C,\\\r\n              $(SIMH_DIR)SIM_SERIAL.C,$(SIMH_DIR)SIM_VIDEO.C,\\\r\n              $(SIMH_DIR)SIM_SCSI.C\r\nSIMH_MAIN = SCP.C\r\n.IFDEF ALPHA_OR_IA64\r\nSIMH_LIB64 = $(LIB_DIR)SIMH64-$(ARCH).OLB\r\n.ENDIF\r\n\r\n# VMS PCAP File Definitions.\r\n#\r\nPCAP_DIR = SYS$DISK:[-.PCAP-VMS.PCAP-VCI]\r\nPCAP_LIB = $(LIB_DIR)PCAP-$(ARCH).OLB\r\nPCAP_SOURCE = $(PCAP_DIR)PCAPVCI.C,$(PCAP_DIR)VCMUTIL.C,\\\r\n              $(PCAP_DIR)BPF_DUMP.C,$(PCAP_DIR)BPF_FILTER.C,\\\r\n              $(PCAP_DIR)BPF_IMAGE.C,$(PCAP_DIR)ETHERENT.C,\\\r\n              $(PCAP_DIR)FAD-GIFC.C,$(PCAP_DIR)GENCODE.C,\\\r\n              $(PCAP_DIR)GRAMMAR.C,$(PCAP_DIR)INET.C,\\\r\n              $(PCAP_DIR)NAMETOADDR.C,$(PCAP_DIR)OPTIMIZE.C,\\\r\n              $(PCAP_DIR)PCAP.C,$(PCAP_DIR)SAVEFILE.C,\\\r\n              $(PCAP_DIR)SCANNER.C,$(PCAP_DIR)SNPRINTF.C,\\\r\n              $(PCAP_DIR)PCAP-VMS.C\r\nPCAP_VCMDIR = SYS$DISK:[-.PCAP-VMS.PCAPVCM]\r\nPCAP_VCM_SOURCES = $(PCAP_VCMDIR)PCAPVCM.C,$(PCAP_VCMDIR)PCAPVCM_INIT.MAR,\\\r\n                   $(PCAP_VCMDIR)VCI_JACKET.MAR,$(PCAP_VCMDIR)VCMUTIL.C\r\nPCAP_VCI = SYS$COMMON:[SYS$LDR]PCAPVCM.EXE\r\n\r\n# PCAP is not available on OpenVMS VAX\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n.IFDEF NONETWORK\r\n# Network Capabilities disabled\r\n.ELSE\r\nPCAP_EXECLET = $(PCAP_VCI)\r\nPCAP_INC = ,$(PCAP_DIR)\r\nPCAP_LIBD = $(PCAP_LIB)\r\nPCAP_LIBR = ,$(PCAP_LIB)/LIB/SYSEXE\r\nPCAP_DEFS = ,\"USE_NETWORK=1\",\"HAVE_PCAP_NETWORK=1\"\r\nPCAP_SIMH_INC = /INCL=($(PCAP_DIR))\r\n.ENDIF\r\n.ENDIF\r\n\r\n# Check To Make Sure We Have SYS$DISK:[.BIN] & SYS$DISK:[.LIB] Directory.\r\n#\r\n.FIRST\r\n  @ IF \"\".NES.\"''CC'\" THEN DELETE/SYMBOL/GLOBAL CC\r\n  @ EXIT_ON_ERROR := IF (ERROR_CONDITION) THEN EXIT %X10000004\r\n  @ ERROR_CONDITION = ((F$GETSYI(\"ARCH_NAME\").EQS.\"Alpha\").AND.(F$GETSYI(\"VERSION\").LTS.\"V8.0\").AND.(\"$(NOASYNCH)\".EQS.\"\"))\r\n  @ IF (ERROR_CONDITION) THEN WRITE SYS$OUTPUT \"*** WARNING **** Build should be invoked with /MACRO=NOASYNCH=1 on this platform\"\r\n  @ 'EXIT_ON_ERROR\r\n  @ DEFINE/USER SYS$ERROR NLA0:\r\n  @ DEFINE/USER SYS$OUTPUT CC_VERSION.DAT\r\n  @ CC/DECC/VERSION\r\n  @ OPEN /READ VERSION CC_VERSION.DAT\r\n  @ READ VERSION CC_VERSION\r\n  @ CLOSE VERSION\r\n  @ DELETE CC_VERSION.DAT;\r\n  @ CC_VERSION = F$ELEMENT(2,\" \",CC_VERSION)\r\n  @ BAD_CC_VERSION = ((F$GETSYI(\"ARCH_NAME\").EQS.\"Alpha\").AND.(CC_VERSION.LTS.\"V6.5-001\").AND.(\"$(NONETWORK)\".EQS.\"\"))\r\n  @ IF (BAD_CC_VERSION) THEN WRITE SYS$OUTPUT \"*** WARNING *** C Compiler is: ''CC_VERSION'\"\r\n  @ IF (BAD_CC_VERSION.AND.(F$GETSYI(\"VERSION\").GES.\"V8.0\")) THEN -\r\n     WRITE SYS$OUTPUT \"*** WARNING *** Build should be invoked with /MACRO=NONETWORK=1 with this compiler\"\r\n  @ IF (BAD_CC_VERSION.AND.(F$GETSYI(\"VERSION\").LTS.\"V8.0\")) THEN -\r\n     WRITE SYS$OUTPUT \"*** WARNING *** Build should be invoked with /MACRO=(NONETWORK=1,NOASYNCH=1) with this compiler\"\r\n  @ ERROR_CONDITION = BAD_CC_VERSION\r\n  @ 'EXIT_ON_ERROR\r\n  @ MISSING_PCAP = ((\"$(PCAP_EXECLET)\".NES.\"\").AND.(\"$(NONETWORK)\".EQS.\"\").AND.(F$SEARCH(\"$(PCAP_DIR)PCAP-VMS.C\").EQS.\"\"))\r\n  @ MISS_SAY := IF (MISSING_PCAP) THEN WRITE SYS$OUTPUT\r\n  @ 'MISS_SAY' \"*** Error *** Attempting a Network Build but the VMS-PCAP components are not\"\r\n  @ 'MISS_SAY' \"*** Error *** available\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error *** The simh-vms-pcap.zip file can be downloaded from:\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error ***     https://github.com/simh/simh/archive/vms-pcap.zip\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error *** Be sure to \"\"unzip -a simh-vms-pcap.zip\"\" to properly set the file attributes\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error *** The PCAP-VMS components are presumed (by this procedure) to be\"\r\n  @ 'MISS_SAY' \"*** Error *** located in a directory at the same level as the directory\"\r\n  @ 'MISS_SAY' \"*** Error *** containing the simh source files.\"\r\n  @ 'MISS_SAY' \"*** Error *** For example, if these exist here:\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error ***   []descrip.mms\"\r\n  @ 'MISS_SAY' \"*** Error ***   []scp.c\"\r\n  @ 'MISS_SAY' \"*** Error ***   etc.\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error *** Then the following should exist:\"\r\n  @ 'MISS_SAY' \"*** Error ***   [-.PCAP-VMS]BUILD_ALL.COM\"\r\n  @ 'MISS_SAY' \"*** Error ***   [-.PCAP-VMS.PCAP-VCI]\"\r\n  @ 'MISS_SAY' \"*** Error ***   [-.PCAP-VMS.PCAPVCM]\"\r\n  @ 'MISS_SAY' \"*** Error ***   etc.\"\r\n  @ 'MISS_SAY' \"*** Error *** \"\r\n  @ 'MISS_SAY' \"*** Error *** Aborting Build\"\r\n  @ ERROR_CONDITION = MISSING_PCAP\r\n  @ 'EXIT_ON_ERROR\r\n  @ IF (F$SEARCH(\"SYS$DISK:[]BIN.DIR\").EQS.\"\") THEN CREATE/DIRECTORY $(BIN_DIR)\r\n  @ IF (F$SEARCH(\"SYS$DISK:[.BIN]VMS.DIR\").EQS.\"\") THEN CREATE/DIRECTORY $(LIB_DIR)\r\n  @ IF (F$SEARCH(\"SYS$DISK:[.BIN.VMS]LIB.DIR\").EQS.\"\") THEN CREATE/DIRECTORY $(LIB_DIR)\r\n  @ IF (F$SEARCH(\"SYS$DISK:[.BIN.VMS.LIB]BLD-$(ARCH).DIR\").EQS.\"\") THEN CREATE/DIRECTORY $(BLD_DIR)\r\n  @ IF (F$SEARCH(\"$(BLD_DIR)*.*\").NES.\"\") THEN DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.*;*\r\n  @ IF ((\"$(BUILDING_ROMS)\".EQS.\"\").AND.(F$SEARCH(\"$(BIN_DIR)BuildROMs-$(ARCH).EXE\").EQS.\"\")) THEN $(MMS) BUILDROMS/MACRO=(BUILDING_ROMS=1$(NEST_DEBUG))\r\n\r\n\r\n# AT&T 3B2 Simulator Definitions.\r\n#\r\nATT3B2_DIR = SYS$DISK:[.3B2]\r\nATT3B2_LIB = $(LIB_DIR)ATT3B2-$(ARCH).OLB\r\nATT3B2_SOURCE = $(ATT3B2_DIR)3B2_CPU.C,$(ATT3B2_DIR)3B2_DMAC.C,\\\r\n                $(ATT3B2_DIR)3B2_ID.C,$(ATT3B2_DIR)3B2_IF.C,\\\r\n                $(ATT3B2_DIR)3B2_IO.C,$(ATT3B2_DIR)3B2_IU.C,\\\r\n                $(ATT3B2_DIR)3B2_MAU.C,$(ATT3B2_DIR)3B2_MMU.C,\\\r\n                $(ATT3B2_DIR)3B2_SYS.C,$(ATT3B2_DIR)3B2_SYSDEV.C\r\nATT3B2_OPTIONS = /INCL=($(SIMH_DIR),$(ATT3B2_DIR))/DEF=($(CC_DEFS))\r\n\r\n# MITS Altair Simulator Definitions.\r\n#\r\nALTAIR_DIR = SYS$DISK:[.ALTAIR]\r\nALTAIR_LIB = $(LIB_DIR)ALTAIR-$(ARCH).OLB\r\nALTAIR_SOURCE = $(ALTAIR_DIR)ALTAIR_SIO.C,$(ALTAIR_DIR)ALTAIR_CPU.C,\\\r\n                $(ALTAIR_DIR)ALTAIR_DSK.C,$(ALTAIR_DIR)ALTAIR_SYS.C\r\nALTAIR_OPTIONS = /INCL=($(SIMH_DIR),$(ALTAIR_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# MITS Altair Z80 Simulator Definitions.\r\n#\r\nALTAIRZ80_DIR = SYS$DISK:[.ALTAIRZ80]\r\nALTAIRZ80_LIB1 = $(LIB_DIR)ALTAIRZ80L1-$(ARCH).OLB\r\nALTAIRZ80_SOURCE1 = $(ALTAIRZ80_DIR)ALTAIRZ80_CPU.C,$(ALTAIRZ80_DIR)ALTAIRZ80_CPU_NOMMU.C,\\\r\n                    $(ALTAIRZ80_DIR)ALTAIRZ80_DSK.C,$(ALTAIRZ80_DIR)DISASM.C,\\\r\n                    $(ALTAIRZ80_DIR)ALTAIRZ80_SIO.C,$(ALTAIRZ80_DIR)ALTAIRZ80_SYS.C,\\\r\n                    $(ALTAIRZ80_DIR)ALTAIRZ80_HDSK.C,$(ALTAIRZ80_DIR)ALTAIRZ80_NET.C,\\\r\n                    $(ALTAIRZ80_DIR)FLASHWRITER2.C,$(ALTAIRZ80_DIR)I86_DECODE.C,\\\r\n                    $(ALTAIRZ80_DIR)I86_OPS.C,$(ALTAIRZ80_DIR)I86_PRIM_OPS.C,\\\r\n                    $(ALTAIRZ80_DIR)I8272.C,$(ALTAIRZ80_DIR)INSNSD.C,\\\r\n                    $(ALTAIRZ80_DIR)MFDC.C,$(ALTAIRZ80_DIR)N8VEM.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_MDSA.C,$(ALTAIRZ80_DIR)VFDHD.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_JADEDD.C\r\nALTAIRZ80_LIB2 = $(LIB_DIR)ALTAIRZ80L2-$(ARCH).OLB\r\nALTAIRZ80_SOURCE2 = $(ALTAIRZ80_DIR)S100_DISK1A.C,$(ALTAIRZ80_DIR)S100_DISK2.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_FIF.C,$(ALTAIRZ80_DIR)S100_MDRIVEH.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_MDSAD.C,$(ALTAIRZ80_DIR)S100_SELCHAN.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_SS1.C,$(ALTAIRZ80_DIR)S100_64FDC.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_SCP300F.C,$(SIMH_DIR)SIM_IMD.C,\\\r\n                    $(ALTAIRZ80_DIR)WD179X.C,$(ALTAIRZ80_DIR)S100_DISK3.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_ADCS6.C,$(ALTAIRZ80_DIR)S100_HDC1001.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_IF3.C,$(ALTAIRZ80_DIR)ALTAIRZ80_MHDSK.C,\\\r\n                    $(ALTAIRZ80_DIR)S100_TARBELL.C,$(ALTAIRZ80_DIR)M68KASM.C,\\\r\n                    $(ALTAIRZ80_DIR)M68KCPU.C,$(ALTAIRZ80_DIR)M68KDASM.C,\\\r\n                    $(ALTAIRZ80_DIR)M68KOPAC.C,$(ALTAIRZ80_DIR)M68KOPDM.C,\\\r\n                    $(ALTAIRZ80_DIR)M68KOPNZ.C,$(ALTAIRZ80_DIR)M68KOPS.C,$(ALTAIRZ80_DIR)M68KSIM.C\r\nALTAIRZ80_OPTIONS = /INCL=($(SIMH_DIR),$(ALTAIRZ80_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Data General Nova Simulator Definitions.\r\n#\r\nNOVA_DIR = SYS$DISK:[.NOVA]\r\nNOVA_LIB = $(LIB_DIR)NOVA-$(ARCH).OLB\r\nNOVA_SOURCE = $(NOVA_DIR)NOVA_SYS.C,$(NOVA_DIR)NOVA_CPU.C,\\\r\n              $(NOVA_DIR)NOVA_DKP.C,$(NOVA_DIR)NOVA_DSK.C,\\\r\n              $(NOVA_DIR)NOVA_LP.C,$(NOVA_DIR)NOVA_MTA.C,\\\r\n              $(NOVA_DIR)NOVA_PLT.C,$(NOVA_DIR)NOVA_PT.C,\\\r\n              $(NOVA_DIR)NOVA_CLK.C,$(NOVA_DIR)NOVA_TT.C,\\\r\n              $(NOVA_DIR)NOVA_TT1.C,$(NOVA_DIR)NOVA_QTY.C\r\nNOVA_OPTIONS = /INCL=($(SIMH_DIR),$(NOVA_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Data General Eclipse Simulator Definitions.\r\n#\r\nECLIPSE_LIB = $(LIB_DIR)ECLIPSE-$(ARCH).OLB\r\nECLIPSE_SOURCE = $(NOVA_DIR)ECLIPSE_CPU.C,$(NOVA_DIR)ECLIPSE_TT.C,\\\r\n                 $(NOVA_DIR)NOVA_SYS.C,$(NOVA_DIR)NOVA_DKP.C,\\\r\n                 $(NOVA_DIR)NOVA_DSK.C,$(NOVA_DIR)NOVA_LP.C,\\\r\n                 $(NOVA_DIR)NOVA_MTA.C,$(NOVA_DIR)NOVA_PLT.C,\\\r\n                 $(NOVA_DIR)NOVA_PT.C,$(NOVA_DIR)NOVA_CLK.C,\\\r\n                 $(NOVA_DIR)NOVA_TT1.C,$(NOVA_DIR)NOVA_QTY.C\r\nECLIPSE_OPTIONS = /INCL=($(SIMH_DIR),$(NOVA_DIR))\\\r\n                    /DEF=($(CC_DEFS),\"ECLIPSE=1\")\r\n\r\n#\r\n# GRI Corporation GRI-909 Simulator Definitions.\r\n#\r\nGRI_DIR = SYS$DISK:[.GRI]\r\nGRI_LIB = $(LIB_DIR)GRI-$(ARCH).OLB\r\nGRI_SOURCE = $(GRI_DIR)GRI_CPU.C,$(GRI_DIR)GRI_STDDEV.C,$(GRI_DIR)GRI_SYS.C\r\nGRI_OPTIONS = /INCL=($(SIMH_DIR),$(GRI_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Royal-McBee LGP-30 Simulator Definitions.\r\n#\r\nLGP_DIR = SYS$DISK:[.LGP]\r\nLGP_LIB = $(LIB_DIR)LGP-$(ARCH).OLB\r\nLGP_SOURCE = $(LGP_DIR)LGP_CPU.C,$(LGP_DIR)LGP_STDDEV.C,$(LGP_DIR)LGP_SYS.C\r\nLGP_OPTIONS = /INCL=($(SIMH_DIR),$(LGP_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Honeywell 316/516 Simulator Definitions.\r\n#\r\nH316_DIR = SYS$DISK:[.H316]\r\nH316_LIB = $(LIB_DIR)H316-$(ARCH).OLB\r\nH316_SOURCE = $(H316_DIR)H316_STDDEV.C,$(H316_DIR)H316_LP.C,\\\r\n              $(H316_DIR)H316_CPU.C,$(H316_DIR)H316_SYS.C,\\\r\n              $(H316_DIR)H316_FHD.C,$(H316_DIR)H316_MT.C,\\\r\n              $(H316_DIR)H316_DP.C,$(H316_DIR)H316_RTC.C,\\\r\n              $(H316_DIR)H316_IMP.C,$(H316_DIR)H316_HI.C,\\\r\n              $(H316_DIR)H316_MI.C,$(H316_DIR)H316_UDP.C\r\nH316_OPTIONS = /INCL=($(SIMH_DIR),$(H316_DIR))/DEF=($(CC_DEFS),\"VM_IMPTIP=1\")\r\n\r\n#\r\n# Hewlett-Packard HP-2100 Simulator Definitions.\r\n#\r\nHP2100_DIR = SYS$DISK:[.HP2100]\r\nHP2100_LIB1 = $(LIB_DIR)HP2100L1-$(ARCH).OLB\r\nHP2100_SOURCE1 = $(HP2100_DIR)HP2100_BACI.C,$(HP2100_DIR)HP2100_CPU.C,\\\r\n                 $(HP2100_DIR)HP2100_CPU_FP.C,$(HP2100_DIR)HP2100_CPU_FPP.C,\\\r\n                 $(HP2100_DIR)HP2100_CPU0.C,$(HP2100_DIR)HP2100_CPU1.C,\\\r\n                 $(HP2100_DIR)HP2100_CPU2.C,$(HP2100_DIR)HP2100_CPU3.C,\\\r\n                 $(HP2100_DIR)HP2100_CPU4.C,$(HP2100_DIR)HP2100_CPU5.C,\\\r\n                 $(HP2100_DIR)HP2100_CPU6.C,$(HP2100_DIR)HP2100_CPU7.C,\\\r\n                 $(HP2100_DIR)HP2100_DI.C,$(HP2100_DIR)HP2100_DI_DA.C,\\\r\n                 $(HP2100_DIR)HP2100_DISCLIB.C,$(HP2100_DIR)HP2100_DMA.C,\\\r\n                 $(HP2100_DIR)HP2100_DP.C,$(HP2100_DIR)HP2100_DQ.C,\\\r\n                 $(HP2100_DIR)HP2100_DR.C,$(HP2100_DIR)HP2100_DS.C,\\\r\n                 $(HP2100_DIR)HP2100_IPL.C,$(HP2100_DIR)HP2100_LPS.C\r\nHP2100_LIB2 = $(LIB_DIR)HP2100L2-$(ARCH).OLB\r\nHP2100_SOURCE2 = $(HP2100_DIR)HP2100_LPT.C,$(HP2100_DIR)HP2100_MC.C,\\\r\n                 $(HP2100_DIR)HP2100_MEM.C,$(HP2100_DIR)HP2100_MPX.C,\\\r\n                 $(HP2100_DIR)HP2100_MS.C,$(HP2100_DIR)HP2100_MT.C,\\\r\n                 $(HP2100_DIR)HP2100_MUX.C,$(HP2100_DIR)HP2100_PIF.C,\\\r\n                 $(HP2100_DIR)HP2100_PT.C,$(HP2100_DIR)HP2100_SYS.C,\\\r\n                 $(HP2100_DIR)HP2100_TBG.C,$(HP2100_DIR)HP2100_TTY.C\r\n.IFDEF ALPHA_OR_IA64\r\nHP2100_OPTIONS = /INCL=($(SIMH_DIR),$(HP2100_DIR))\\\r\n                    /DEF=($(CC_DEFS),\"HAVE_INT64=1\")\r\n.ELSE\r\nHP2100_OPTIONS = /INCL=($(SIMH_DIR),$(HP2100_DIR))/DEF=($(CC_DEFS))\r\n.ENDIF\r\n\r\n#\r\n# Hewlett-Packard HP-3000 Simulator Definitions.\r\n#\r\nHP3000_DIR = SYS$DISK:[.HP3000]\r\nHP3000_LIB1 = $(LIB_DIR)HP3000L1-$(ARCH).OLB\r\nHP3000_SOURCE1 = $(HP3000_DIR)HP3000_ATC.C,$(HP3000_DIR)HP3000_CLK.C,\\\r\n                 $(HP3000_DIR)HP3000_CPU.C,$(HP3000_DIR)HP3000_CPU_BASE.C,\\\r\n                 $(HP3000_DIR)HP3000_CPU_CIS.C,$(HP3000_DIR)HP3000_CPU_FP.C,\\\r\n                 $(HP3000_DIR)HP3000_DS.C,$(HP3000_DIR)HP3000_LP.C,\\\r\n                 $(HP3000_DIR)HP3000_IOP.C,$(HP3000_DIR)HP3000_MEM.C,\\\r\n                 $(HP3000_DIR)HP3000_MPX.C,\\\r\n                 $(HP3000_DIR)HP3000_MS.C,$(HP3000_DIR)HP3000_SCMB.C,\\\r\n                 $(HP3000_DIR)HP3000_SEL.C,$(HP3000_DIR)HP3000_SYS.C\r\nHP3000_LIB2 = $(LIB_DIR)HP3000L2-$(ARCH).OLB\r\nHP3000_SOURCE2 = $(HP3000_DIR)HP_TAPELIB.C,$(HP3000_DIR)HP_DISCLIB.C\r\n.IFDEF ALPHA_OR_IA64\r\nHP3000_OPTIONS = /INCL=($(SIMH_DIR),$(HP3000_DIR))\\\r\n                    /DEF=($(CC_DEFS),\"HAVE_INT64=1\")\r\n.ELSE\r\nHP3000_OPTIONS = /INCL=($(SIMH_DIR),$(HP3000_DIR))/DEF=($(CC_DEFS))\r\n.ENDIF\r\n\r\n#\r\n# Interdata 16-bit CPU.\r\n#\r\nID16_DIR = SYS$DISK:[.INTERDATA]\r\nID16_LIB = $(LIB_DIR)ID16-$(ARCH).OLB\r\nID16_SOURCE = $(ID16_DIR)ID16_CPU.C,$(ID16_DIR)ID16_SYS.C,$(ID16_DIR)ID_DP.C,\\\r\n              $(ID16_DIR)ID_FD.C,$(ID16_DIR)ID_FP.C,$(ID16_DIR)ID_IDC.C,\\\r\n              $(ID16_DIR)ID_IO.C,$(ID16_DIR)ID_LP.C,$(ID16_DIR)ID_MT.C,\\\r\n              $(ID16_DIR)ID_PAS.C,$(ID16_DIR)ID_PT.C,$(ID16_DIR)ID_TT.C,\\\r\n              $(ID16_DIR)ID_UVC.C,$(ID16_DIR)ID16_DBOOT.C,$(ID16_DIR)ID_TTP.C\r\nID16_OPTIONS = /INCL=($(SIMH_DIR),$(ID16_DIR))/DEF=($(CC_DEFS),\"IFP_IN_MEM=1\")\r\n\r\n#\r\n# Interdata 32-bit CPU.\r\n#\r\nID32_DIR = SYS$DISK:[.INTERDATA]\r\nID32_LIB = $(LIB_DIR)ID32-$(ARCH).OLB\r\nID32_SOURCE = $(ID32_DIR)ID32_CPU.C,$(ID32_DIR)ID32_SYS.C,$(ID32_DIR)ID_DP.C,\\\r\n              $(ID32_DIR)ID_FD.C,$(ID32_DIR)ID_FP.C,$(ID32_DIR)ID_IDC.C,\\\r\n              $(ID32_DIR)ID_IO.C,$(ID32_DIR)ID_LP.C,$(ID32_DIR)ID_MT.C,\\\r\n              $(ID32_DIR)ID_PAS.C,$(ID32_DIR)ID_PT.C,$(ID32_DIR)ID_TT.C,\\\r\n              $(ID32_DIR)ID_UVC.C,$(ID32_DIR)ID32_DBOOT.C,$(ID32_DIR)ID_TTP.C\r\nID32_OPTIONS = /INCL=($(SIMH_DIR),$(ID32_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# IBM 1130 Simulator Definitions.\r\n#\r\nIBM1130_DIR = SYS$DISK:[.IBM1130]\r\nIBM1130_LIB = $(LIB_DIR)IBM1130-$(ARCH).OLB\r\nIBM1130_SOURCE = $(IBM1130_DIR)IBM1130_CPU.C,$(IBM1130_DIR)IBM1130_CR.C,\\\r\n                 $(IBM1130_DIR)IBM1130_DISK.C,$(IBM1130_DIR)IBM1130_STDDEV.C,\\\r\n                 $(IBM1130_DIR)IBM1130_SYS.C,$(IBM1130_DIR)IBM1130_GDU.C,\\\r\n                 $(IBM1130_DIR)IBM1130_GUI.C,$(IBM1130_DIR)IBM1130_PRT.C,\\\r\n                 $(IBM1130_DIR)IBM1130_FMT.C,$(IBM1130_DIR)IBM1130_PTRP.C,\\\r\n                 $(IBM1130_DIR)IBM1130_PLOT.C,$(IBM1130_DIR)IBM1130_SCA.C,\\\r\n                 $(IBM1130_DIR)IBM1130_T2741.C\r\nIBM1130_OPTIONS = /INCL=($(SIMH_DIR),$(IBM1130_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# IBM 1401 Simulator Definitions.\r\n#\r\nI1401_DIR = SYS$DISK:[.I1401]\r\nI1401_LIB = $(LIB_DIR)I1401-$(ARCH).OLB\r\nI1401_SOURCE = $(I1401_DIR)I1401_LP.C,$(I1401_DIR)I1401_CPU.C,\\\r\n               $(I1401_DIR)I1401_IQ.C,$(I1401_DIR)I1401_CD.C,\\\r\n               $(I1401_DIR)I1401_MT.C,$(I1401_DIR)I1401_DP.C,\\\r\n               $(I1401_DIR)I1401_SYS.C\r\nI1401_OPTIONS = /INCL=($(SIMH_DIR),$(I1401_DIR))/DEF=($(CC_DEFS))\r\n\r\n\r\n#\r\n# IBM 1620 Simulators Definitions.\r\n#\r\nI1620_DIR = SYS$DISK:[.I1620]\r\nI1620_LIB = $(LIB_DIR)I1620-$(ARCH).OLB\r\nI1620_SOURCE = $(I1620_DIR)I1620_CD.C,$(I1620_DIR)I1620_DP.C,\\\r\n               $(I1620_DIR)I1620_PT.C,$(I1620_DIR)I1620_TTY.C,\\\r\n               $(I1620_DIR)I1620_CPU.C,$(I1620_DIR)I1620_LP.C,\\\r\n               $(I1620_DIR)I1620_FP.C,$(I1620_DIR)I1620_SYS.C\r\nI1620_OPTIONS = /INCL=($(SIMH_DIR),$(I1620_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# PDP-1 Simulator Definitions.\r\n#\r\nPDP1_DIR = SYS$DISK:[.PDP1]\r\nPDP1_LIB = $(LIB_DIR)PDP1-$(ARCH).OLB\r\nPDP1_SOURCE = $(PDP1_DIR)PDP1_LP.C,$(PDP1_DIR)PDP1_CPU.C,\\\r\n              $(PDP1_DIR)PDP1_STDDEV.C,$(PDP1_DIR)PDP1_SYS.C,\\\r\n              $(PDP1_DIR)PDP1_DT.C,$(PDP1_DIR)PDP1_DRM.C,\\\r\n              $(PDP1_DIR)PDP1_CLK.C,$(PDP1_DIR)PDP1_DCS.C, \\\r\n              $(PDP1_DIR)PDP1_DPY.C\r\nPDP1_OPTIONS = /INCL=($(SIMH_DIR),$(PDP1_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Digital Equipment PDP-8 Simulator Definitions.\r\n#\r\nPDP8_DIR = SYS$DISK:[.PDP8]\r\nPDP8_LIB = $(LIB_DIR)PDP8-$(ARCH).OLB\r\nPDP8_SOURCE = $(PDP8_DIR)PDP8_CPU.C,$(PDP8_DIR)PDP8_CLK.C,\\\r\n              $(PDP8_DIR)PDP8_DF.C,$(PDP8_DIR)PDP8_DT.C,\\\r\n              $(PDP8_DIR)PDP8_LP.C,$(PDP8_DIR)PDP8_MT.C,\\\r\n              $(PDP8_DIR)PDP8_PT.C,$(PDP8_DIR)PDP8_RF.C,\\\r\n              $(PDP8_DIR)PDP8_RK.C,$(PDP8_DIR)PDP8_RX.C,\\\r\n              $(PDP8_DIR)PDP8_SYS.C,$(PDP8_DIR)PDP8_TT.C,\\\r\n              $(PDP8_DIR)PDP8_TTX.C,$(PDP8_DIR)PDP8_RL.C,\\\r\n              $(PDP8_DIR)PDP8_TSC.C,$(PDP8_DIR)PDP8_TD.C,\\\r\n              $(PDP8_DIR)PDP8_CT.C,$(PDP8_DIR)PDP8_FPP.C\r\nPDP8_OPTIONS = /INCL=($(SIMH_DIR),$(PDP8_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Digital Equipment PDP-4, PDP-7, PDP-9 And PDP-15 Simulator Definitions.\r\n#\r\nPDP18B_DIR = SYS$DISK:[.PDP18B]\r\nPDP4_LIB = $(LIB_DIR)PDP4-$(ARCH).OLB\r\nPDP7_LIB = $(LIB_DIR)PDP7-$(ARCH).OLB\r\nPDP9_LIB = $(LIB_DIR)PDP9-$(ARCH).OLB\r\nPDP15_LIB = $(LIB_DIR)PDP15-$(ARCH).OLB\r\nPDP18B_SOURCE = $(PDP18B_DIR)PDP18B_DT.C,$(PDP18B_DIR)PDP18B_DRM.C,\\\r\n                $(PDP18B_DIR)PDP18B_CPU.C,$(PDP18B_DIR)PDP18B_LP.C,\\\r\n                $(PDP18B_DIR)PDP18B_MT.C,$(PDP18B_DIR)PDP18B_RF.C,\\\r\n                $(PDP18B_DIR)PDP18B_RP.C,$(PDP18B_DIR)PDP18B_STDDEV.C,\\\r\n                $(PDP18B_DIR)PDP18B_SYS.C,$(PDP18B_DIR)PDP18B_TT1.C,\\\r\n                $(PDP18B_DIR)PDP18B_RB.C,$(PDP18B_DIR)PDP18B_FPP.C,\\\r\n                $(PDP18B_DIR)PDP18B_G2TTY.C,$(PDP18B_DIR)PDP18B_DR15.C\r\nPDP4_OPTIONS = /INCL=($(SIMH_DIR),$(PDP18B_DIR))/DEF=($(CC_DEFS),\"PDP4=1\")\r\nPDP7_OPTIONS = /INCL=($(SIMH_DIR),$(PDP18B_DIR))/DEF=($(CC_DEFS),\"PDP7=1\")\r\nPDP9_OPTIONS = /INCL=($(SIMH_DIR),$(PDP18B_DIR))/DEF=($(CC_DEFS),\"PDP9=1\")\r\nPDP15_OPTIONS = /INCL=($(SIMH_DIR),$(PDP18B_DIR))/DEF=($(CC_DEFS),\"PDP15=1\")\r\n\r\n#\r\n# Digital Equipment PDP-11 Simulator Definitions.\r\n#\r\nPDP11_DIR = SYS$DISK:[.PDP11]\r\nPDP11_LIB1 = $(LIB_DIR)PDP11L1-$(ARCH).OLB\r\nPDP11_SOURCE1 = $(PDP11_DIR)PDP11_FP.C,$(PDP11_DIR)PDP11_CPU.C,\\\r\n               $(PDP11_DIR)PDP11_DZ.C,$(PDP11_DIR)PDP11_CIS.C,\\\r\n               $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_RK.C,\\\r\n               $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RP.C,\\\r\n               $(PDP11_DIR)PDP11_RX.C,$(PDP11_DIR)PDP11_STDDEV.C,\\\r\n               $(PDP11_DIR)PDP11_SYS.C,$(PDP11_DIR)PDP11_TC.C, \\\r\n               $(PDP11_DIR)PDP11_CPUMOD.C,$(PDP11_DIR)PDP11_CR.C,\\\r\n               $(PDP11_DIR)PDP11_TA.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n               $(PDP11_DIR)PDP11_DUP.C,$(PDP11_DIR)PDP11_RS.C,\\\r\n               $(PDP11_DIR)PDP11_VT.C,$(PDP11_DIR)PDP11_KMC.C,\\\r\n               $(PDP11_DIR)PDP11_IO_LIB.C\r\nPDP11_LIB2 = $(LIB_DIR)PDP11L2-$(ARCH).OLB\r\nPDP11_SOURCE2 = $(PDP11_DIR)PDP11_TM.C,$(PDP11_DIR)PDP11_TS.C,\\\r\n               $(PDP11_DIR)PDP11_IO.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n               $(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,$(PDP11_DIR)PDP11_PCLK.C,\\\r\n               $(PDP11_DIR)PDP11_RY.C,$(PDP11_DIR)PDP11_PT.C,\\\r\n               $(PDP11_DIR)PDP11_HK.C,$(PDP11_DIR)PDP11_XQ.C,\\\r\n               $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_RH.C,\\\r\n               $(PDP11_DIR)PDP11_XU.C,$(PDP11_DIR)PDP11_TU.C,\\\r\n               $(PDP11_DIR)PDP11_DL.C,$(PDP11_DIR)PDP11_RF.C, \\\r\n               $(PDP11_DIR)PDP11_RC.C,$(PDP11_DIR)PDP11_KG.C,\\\r\n               $(PDP11_DIR)PDP11_KE.C,$(PDP11_DIR)PDP11_DC.C,\\\r\n               $(PDP11_DIR)PDP11_ROM.C,$(PDP11_DIR)PDP11_CH.C,\\\r\n               $(PDP11_DIR)PDP11_RR.C\r\nPDP11_OPTIONS = /INCL=($(SIMH_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                /DEF=($(CC_DEFS),\"VM_PDP11=1\"$(PCAP_DEFS))\r\n\r\n#\r\n# Digital Equipment PDP-6 Simulator Definitions.\r\n#\r\nPDP6_DIR = SYS$DISK:[.PDP10]\r\nPDP6_LIB = $(LIB_DIR)PDP6-$(ARCH).OLB\r\nPDP6_SOURCE = $(PDP6_DIR)KX10_CPU.C,\\\r\n               $(PDP6_DIR)KX10_SYS.C,$(PDP6_DIR)KX10_CTY.C,\\\r\n               $(PDP6_DIR)KX10_LP.C,$(PDP6_DIR)KX10_PT.C,\\\r\n               $(PDP6_DIR)KX10_CR.C,$(PDP6_DIR)KX10_CP.C,\\\r\n               $(PDP6_DIR)PDP6_DCT.C,$(PDP6_DIR)PDP6_DTC.C,\\\r\n               $(PDP6_DIR)PDP6_MTC.C,$(PDP6_DIR)PDP6_DSK.C,\\\r\n               $(PDP6_DIR)PDP6_DCS.C,$(PDP6_DIR)KX10_DPY.C,\\\r\n               $(SIMH_DIR)SIM_CARD.C\r\nPDP6_OPTIONS = /INCL=($(SIMH_DIR),$(PDP6_DIR))\\\r\n                /DEF=($(CC_DEFS),\"PDP6=1\",\"USE_INT64=1\",\"USE_SIM_CARD=1\"$(PCAP_DEFS))\r\n\r\n#\r\n# Digital Equipment PDP-10-KA Simulator Definitions.\r\n#\r\nKA10_DIR = SYS$DISK:[.PDP10]\r\nKA10_LIB = $(LIB_DIR)KA10-$(ARCH).OLB\r\nKA10_SOURCE = $(KA10_DIR)KX10_CPU.C,\\\r\n               $(KA10_DIR)KX10_SYS.C,$(KA10_DIR)KX10_DF.C,\\\r\n               $(KA10_DIR)KX10_DP.C,$(KA10_DIR)KX10_MT.C,\\\r\n               $(KA10_DIR)KX10_CTY.C,$(KA10_DIR)KX10_LP.C,\\\r\n               $(KA10_DIR)KX10_PT.C,$(KA10_DIR)KX10_DC.C,\\\r\n               $(KA10_DIR)KX10_RP.C,$(KA10_DIR)KX10_RC.C,\\\r\n               $(KA10_DIR)KX10_DT.C,$(KA10_DIR)KX10_DK.C,\\\r\n               $(KA10_DIR)KX10_CR.C,$(KA10_DIR)KX10_CP.C,\\\r\n               $(KA10_DIR)KX10_TU.C,$(KA10_DIR)KX10_RS.C,\\\r\n               $(KA10_DIR)KA10_PD.C,$(KA10_DIR)KX10_IMP.C,\\\r\n               $(KA10_DIR)KA10_TK10.C,$(KA10_DIR)KA10_MTY.C,\\\r\n               $(KA10_DIR)KA10_IMX.C,$(KA10_DIR)KA10_CH10.C,\\\r\n               $(KA10_DIR)KA10_STK.C,$(KA10_DIR)KA10_TEN11.C,\\\r\n               $(KA10_DIR)KA10_AUXCPU.C,$(KA10_DIR)KA10_PMP.C,\\\r\n               $(KA10_DIR)KA10_DKB.C,$(KA10_DIR)PDP6_DCT.C,\\\r\n               $(KA10_DIR)PDP6_DTC.C,$(KA10_DIR)PDP6_MTC.C,\\\r\n               $(KA10_DIR)PDP6_DSK.C,$(KA10_DIR)PDP6_DCS.C,\\\r\n               $(KA10_DIR)KA10_DPK.C,$(KA10_DIR)KX10_DPY.C,\\\r\n               $(KA10_DIR)KA10_AI.C,$(SIMH_DIR)SIM_CARD.C\r\nKA10_OPTIONS = /INCL=($(SIMH_DIR),$(KA10_DIR))\\\r\n                /DEF=($(CC_DEFS),\"KA=1\",\"USE_INT64=1\",\"USE_SIM_CARD=1\"$(PCAP_DEFS))\r\n\r\n#\r\n# Digital Equipment PDP-10-KI Simulator Definitions.\r\n#\r\nKI10_DIR = SYS$DISK:[.PDP10]\r\nKI10_LIB = $(LIB_DIR)KI10-$(ARCH).OLB\r\nKI10_SOURCE = $(KI10_DIR)KX10_CPU.C,\\\r\n               $(KI10_DIR)KX10_SYS.C,$(KI10_DIR)KX10_DF.C,\\\r\n               $(KI10_DIR)KX10_DP.C,$(KI10_DIR)KX10_MT.C,\\\r\n               $(KI10_DIR)KX10_CTY.C,$(KI10_DIR)KX10_LP.C,\\\r\n               $(KI10_DIR)KX10_PT.C,$(KI10_DIR)KX10_DC.C,\\\r\n               $(KI10_DIR)KX10_RP.C,$(KI10_DIR)KX10_RC.C,\\\r\n               $(KI10_DIR)KX10_DT.C,$(KI10_DIR)KX10_DK.C,\\\r\n               $(KI10_DIR)KX10_CR.C,$(KI10_DIR)KX10_CP.C,\\\r\n               $(KI10_DIR)KX10_TU.C,$(KI10_DIR)KX10_RS.C,\\\r\n               $(KI10_DIR)KX10_IMP.C,$(KI10_DIR)KX10_DPY.C,\\\r\n              $(SIMH_DIR)SIM_CARD.C\r\nKI10_OPTIONS = /INCL=($(SIMH_DIR),$(KI10_DIR))\\\r\n                /DEF=($(CC_DEFS),\"KI=1\",\"USE_INT64=1\",\"USE_SIM_CARD=1\"$(PCAP_DEFS))\r\n\r\n#\r\n# Digital Equipment PDP-10 Simulator Definitions.\r\n#\r\nPDP10_DIR = SYS$DISK:[.PDP10]\r\nPDP10_LIB = $(LIB_DIR)PDP10-$(ARCH).OLB\r\nPDP10_SOURCE = $(PDP10_DIR)PDP10_FE.C,\\\r\n               $(PDP10_DIR)PDP10_CPU.C,$(PDP10_DIR)PDP10_KSIO.C,\\\r\n               $(PDP10_DIR)PDP10_LP20.C,$(PDP10_DIR)PDP10_MDFP.C,\\\r\n               $(PDP10_DIR)PDP10_PAG.C,$(PDP10_DIR)PDP10_XTND.C,\\\r\n               $(PDP10_DIR)PDP10_RP.C,$(PDP10_DIR)PDP10_SYS.C,\\\r\n               $(PDP10_DIR)PDP10_TIM.C,$(PDP10_DIR)PDP10_TU.C,\\\r\n               $(PDP11_DIR)PDP11_PT.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n               $(PDP11_DIR)PDP11_RY.C,$(PDP11_DIR)PDP11_CR.C,\\\r\n               $(PDP11_DIR)PDP11_DUP.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n               $(PDP11_DIR)PDP11_KMC.C,$(PDP11_DIR)PDP11_XU.C,\\\r\n               $(PDP11_DIR)PDP11_CH.C\r\n\r\nPDP10_OPTIONS = /INCL=($(SIMH_DIR),$(PDP10_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                /DEF=($(CC_DEFS),\"USE_INT64=1\",\"VM_PDP10=1\"$(PCAP_DEFS))\r\n\r\n#\r\n# IBM System 3 Simulator Definitions.\r\n#\r\nS3_DIR = SYS$DISK:[.S3]\r\nS3_LIB = $(LIB_DIR)S3-$(ARCH).OLB\r\nS3_SOURCE = $(S3_DIR)S3_CD.C,$(S3_DIR)S3_CPU.C,$(S3_DIR)S3_DISK.C,\\\r\n            $(S3_DIR)S3_LP.C,$(S3_DIR)S3_PKB.C,$(S3_DIR)S3_SYS.C\r\nS3_OPTIONS = /INCL=($(SIMH_DIR),$(S3_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# SDS 940\r\n#\r\nSDS_DIR = SYS$DISK:[.SDS]\r\nSDS_LIB = $(LIB_DIR)SDS-$(ARCH).OLB\r\nSDS_SOURCE = $(SDS_DIR)SDS_CPU.C,$(SDS_DIR)SDS_DRM.C,$(SDS_DIR)SDS_DSK.C,\\\r\n             $(SDS_DIR)SDS_IO.C,$(SDS_DIR)SDS_LP.C,$(SDS_DIR)SDS_MT.C,\\\r\n             $(SDS_DIR)SDS_MUX.C,$(SDS_DIR)SDS_RAD.C,$(SDS_DIR)SDS_STDDEV.C,\\\r\n             $(SDS_DIR)SDS_SYS.C,$(SDS_DIR)SDS_CR.C,$(SDS_DIR)SDS_CP.C\r\nSDS_OPTIONS = /INCL=($(SIMH_DIR),$(SDS_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# SSEM\r\n#\r\nSSEM_DIR = SYS$DISK:[.SSEM]\r\nSSEM_LIB = $(LIB_DIR)SSEM-$(ARCH).OLB\r\nSSEM_SOURCE = $(SSEM_DIR)SSEM_CPU.C,$(SSEM_DIR)SSEM_SYS.C\r\nSSEM_OPTIONS = /INCL=($(SIMH_DIR),$(SSEM_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# SWTP 6800MP A\r\n#\r\nSWTP6800MP_A_DIR = SYS$DISK:[.SWTP6800.SWTP6800]\r\nSWTP6800MP_A_COMMON = SYS$DISK:[.SWTP6800.COMMON]\r\nSWTP6800MP_A_LIB = $(LIB_DIR)SWTP6800MP-A-$(ARCH).OLB\r\nSWTP6800MP_A_SOURCE = $(SWTP6800MP_A_COMMON)mp-a.c,$(SWTP6800MP_A_COMMON)m6800.c,\\\r\n\t$(SWTP6800MP_A_COMMON)m6810.c,$(SWTP6800MP_A_COMMON)bootrom.c,$(SWTP6800MP_A_COMMON)dc-4.c,\\\r\n\t$(SWTP6800MP_A_COMMON)mp-s.c,$(SWTP6800MP_A_DIR)mp-a_sys.c,$(SWTP6800MP_A_COMMON)mp-b2.c,\\\r\n\t$(SWTP6800MP_A_COMMON)mp-8m.c,$(SWTP6800MP_A_COMMON)fd400.c\r\nSWTP6800MP_A_OPTIONS = /INCL=($(SIMH_DIR),$(SWTP6800MP_A_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# SWTP 6800MP A2\r\n#\r\nSWTP6800MP_A2_DIR = SYS$DISK:[.SWTP6800.SWTP6800]\r\nSWTP6800MP_A2_COMMON = SYS$DISK:[.SWTP6800.COMMON]\r\nSWTP6800MP_A2_LIB = $(LIB_DIR)SWTP6800MP-A2-$(ARCH).OLB\r\nSWTP6800MP_A2_SOURCE = $(SWTP6800MP_A2_COMMON)mp-a2.c,$(SWTP6800MP_A2_COMMON)m6800.c,\\\r\n\t$(SWTP6800MP_A2_COMMON)m6810.c,$(SWTP6800MP_A2_COMMON)bootrom.c,$(SWTP6800MP_A2_COMMON)dc-4.c,\\\r\n\t$(SWTP6800MP_A2_COMMON)mp-s.c,$(SWTP6800MP_A2_DIR)mp-a2_sys.c,$(SWTP6800MP_A2_COMMON)mp-b2.c,\\\r\n\t$(SWTP6800MP_A2_COMMON)mp-8m.c,$(SWTP6800MP_A2_COMMON)i2716.c,,$(SWTP6800MP_A_COMMON)fd400.c\r\nSWTP6800MP_A2_OPTIONS = /INCL=($(SIMH_DIR),$(SWTP6800MP_A2_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# BESM6\r\n#\r\nBESM6_DIR = SYS$DISK:[.BESM6]\r\nBESM6_LIB = $(LIB_DIR)BESM6-$(ARCH).OLB\r\nBESM6_SOURCE = $(BESM6_DIR)BESM6_CPU.C,$(BESM6_DIR)BESM6_SYS.C,$(BESM6_DIR)BESM6_MMU.C,\\\r\n\t$(BESM6_DIR)BESM6_ARITH.C,$(BESM6_DIR)BESM6_DISK.C,$(BESM6_DIR)BESM6_DRUM.C,$(BESM6_DIR)BESM6_MG.C,\\\r\n\t$(BESM6_DIR)BESM6_TTY.C,$(BESM6_DIR)BESM6_PANEL.C,$(BESM6_DIR)BESM6_PRINTER.C,\\\r\n\t$(BESM6_DIR)BESM6_PUNCHCARD.C,$(BESM6_DIR)BESM6_PUNCH.C,$(BESM6_DIR)BESM6_PL.C,$(BESM6_DIR)BESM6_VU.C\r\nBESM6_OPTIONS = /INCL=($(SIMH_DIR),$(BESM6_DIR))/DEF=($(CC_DEFS),\"USE_INT64=1\")\r\n\r\n#\r\n# B5500\r\n#\r\nB5500_DIR = SYS$DISK:[.B5500]\r\nB5500_LIB = $(LIB_DIR)B5500-$(ARCH).OLB\r\nB5500_SOURCE = $(B5500_DIR)B5500_CPU.C,$(B5500_DIR)B5500_DK.C,$(B5500_DIR)B5500_DR.C,\\\r\n\t$(B5500_DIR)B5500_DTC.C,$(B5500_DIR)B5500_IO.C,$(B5500_DIR)B5500_MT.C,\\\r\n\t$(B5500_DIR)B5500_SYS.C,$(B5500_DIR)B5500_UREC.C,$(SIMH_DIR)SIM_CARD.C\r\nB5500_OPTIONS = /INCL=($(SIMH_DIR),$(B5500_DIR))/DEF=($(CC_DEFS),\"USE_INT64=1\",\"USE_SIM_CARD=1\")\r\n\r\n#\r\n# CDC1700\r\n#\r\nCDC1700_DIR = SYS$DISK:[.CDC1700]\r\nCDC1700_LIB = $(LIB_DIR)CDC1700-$(ARCH).OLB\r\nCDC1700_SOURCE = $(CDC1700_DIR)CDC1700_CPU.C,$(CDC1700_DIR)CDC1700_DIS.C,$(CDC1700_DIR)CDC1700_IO.C,\\\r\n\t$(CDC1700_DIR)CDC1700_SYS.C,$(CDC1700_DIR)CDC1700_DEV1.C,$(CDC1700_DIR)CDC1700_MT.C,\\\r\n\t$(CDC1700_DIR)CDC1700_DC.C,$(CDC1700_DIR)CDC1700_IOFW.C,$(CDC1700_DIR)CDC1700_LP.C,\\\r\n\t$(CDC1700_DIR)CDC1700_DP.C,$(CDC1700_DIR)CDC1700_CD.C,$(CDC1700_DIR)CDC1700_SYM.C,\\\r\n\t$(CDC1700_DIR)CDC1700_RTC.C $(CDC1700_DIR)CDC1700_MSOS5.C $(CDC1700_DIR)CDC1700_DRM.C\r\nCDC1700_OPTIONS = /INCL=($(SIMH_DIR),$(CDC1700_DIR))/DEF=($(CC_DEFS))\r\n\r\n#\r\n# Digital Equipment VAX 3900 Simulator Definitions.\r\n#\r\nVAX_DIR = SYS$DISK:[.VAX]\r\nVAX_LIB1 = $(LIB_DIR)VAXL1-$(ARCH).OLB\r\nVAX_LIB2 = $(LIB_DIR)VAXL2-$(ARCH).OLB\r\nVAX_SOURCE1 = $(VAX_DIR)VAX_CIS.C,$(VAX_DIR)VAX_CMODE.C,\\\r\n              $(VAX_DIR)VAX_CPU.C,$(VAX_DIR)VAX_CPU1.C,\\\r\n              $(VAX_DIR)VAX_FPA.C,$(VAX_DIR)VAX_MMU.C,\\\r\n              $(VAX_DIR)VAX_OCTA.C,$(VAX_DIR)VAX_SYS.C,\\\r\n              $(VAX_DIR)VAX_SYSCM.C,$(VAX_DIR)VAX_SYSDEV.C,\\\r\n              $(VAX_DIR)VAX_SYSLIST.C,$(VAX_DIR)VAX_IO.C,\\\r\n              $(VAX_DIR)VAX_STDDEV.C\r\nVAX_SOURCE2 = $(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n              $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n              $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n              $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n              $(PDP11_DIR)PDP11_XQ.C,$(PDP11_DIR)PDP11_VH.C,\\\r\n              $(PDP11_DIR)PDP11_CR.C,$(PDP11_DIR)PDP11_DUP.C,\\\r\n              $(VAX_DIR)VAX_VC.C,$(VAX_DIR)VAX_LK.C,\\\r\n              $(VAX_DIR)VAX_VS.C,$(VAX_DIR)VAX_2681.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX_OPTIONS = /INCL=($(SIMH_DIR),$(VAX_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS))\r\nVAX_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX_OPTIONS = /INCL=($(SIMH_DIR),$(VAX_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS))\r\nVAX_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX410 (MicroVAX 2000) Simulator Definitions.\r\n#\r\nVAX410_DIR = SYS$DISK:[.VAX]\r\nVAX410_LIB1 = $(LIB_DIR)VAX410L1-$(ARCH).OLB\r\nVAX410_SOURCE1 = $(VAX410_DIR)VAX_CPU.C,$(VAX410_DIR)VAX_CPU1.C,\\\r\n                 $(VAX410_DIR)VAX_FPA.C,$(VAX410_DIR)VAX_CIS.C,\\\r\n                 $(VAX410_DIR)VAX_OCTA.C,$(VAX410_DIR)VAX_CMODE.C,\\\r\n                 $(VAX410_DIR)VAX_MMU.C,$(VAX410_DIR)VAX_SYS.C,\\\r\n                 $(VAX410_DIR)VAX_SYSCM.C\r\nVAX410_LIB2 = $(LIB_DIR)VAX410L2-$(ARCH).OLB\r\nVAX410_SOURCE2 = $(VAX410_DIR)VAX_NAR.C,$(VAX410_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX410_DIR)VAX410_SYSDEV.C,$(VAX410_DIR)VAX410_SYSLIST.C,\\\r\n                 $(VAX410_DIR)VAX4XX_DZ.C,$(VAX410_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX410_DIR)VAX4XX_RZ80.C,$(VAX410_DIR)VAX_XS.C,\\\r\n                 $(VAX410_DIR)VAX4XX_VA.C,$(VAX410_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX410_DIR)VAX_LK.C,$(VAX410_DIR)VAX_VS.C,\\\r\n                 $(VAX410_DIR)VAX_GPX.C,$(VAX410_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX410_OPTIONS = /INCL=($(SIMH_DIR),$(VAX410_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_410=1\")\r\nVAX410_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX410_OPTIONS = /INCL=($(SIMH_DIR),$(VAX410_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_410=1\")\r\nVAX410_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX411 (InfoServer 100) Simulator Definitions.\r\n#\r\nVAX411_DIR = SYS$DISK:[.VAX]\r\nVAX411_LIB1 = $(LIB_DIR)VAX411L1-$(ARCH).OLB\r\nVAX411_SOURCE1 = $(VAX411_DIR)VAX_CPU.C,$(VAX411_DIR)VAX_CPU1.C,\\\r\n                 $(VAX411_DIR)VAX_FPA.C,$(VAX411_DIR)VAX_CIS.C,\\\r\n                 $(VAX411_DIR)VAX_OCTA.C,$(VAX411_DIR)VAX_CMODE.C,\\\r\n                 $(VAX411_DIR)VAX_MMU.C,$(VAX411_DIR)VAX_SYS.C,\\\r\n                 $(VAX411_DIR)VAX_SYSCM.C\r\nVAX411_LIB2 = $(LIB_DIR)VAX411L2-$(ARCH).OLB\r\nVAX411_SOURCE2 = $(VAX411_DIR)VAX_NAR.C,$(VAX411_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX411_DIR)VAX420_SYSDEV.C,$(VAX411_DIR)VAX420_SYSLIST.C,\\\r\n                 $(VAX411_DIR)VAX4XX_DZ.C,$(VAX411_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX411_DIR)VAX4XX_RZ80.C,$(VAX411_DIR)VAX_XS.C,\\\r\n                 $(VAX411_DIR)VAX4XX_VA.C,$(VAX411_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX411_DIR)VAX4XX_VE.C,$(VAX411_DIR)VAX_LK.C,\\\r\n                 $(VAX411_DIR)VAX_VS.C,$(VAX411_DIR)VAX_GPX.C,\\\r\n                 $(VAX411_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX411_OPTIONS = /INCL=($(SIMH_DIR),$(VAX411_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_411=1\")\r\nVAX411_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX411_OPTIONS = /INCL=($(SIMH_DIR),$(VAX411_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_411=1\")\r\nVAX411_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX412 (InfoServer 150 VXT) Simulator Definitions.\r\n#\r\nVAX412_DIR = SYS$DISK:[.VAX]\r\nVAX412_LIB1 = $(LIB_DIR)VAX412L1-$(ARCH).OLB\r\nVAX412_SOURCE1 = $(VAX412_DIR)VAX_CPU.C,$(VAX412_DIR)VAX_CPU1.C,\\\r\n                 $(VAX412_DIR)VAX_FPA.C,$(VAX412_DIR)VAX_CIS.C,\\\r\n                 $(VAX412_DIR)VAX_OCTA.C,$(VAX412_DIR)VAX_CMODE.C,\\\r\n                 $(VAX412_DIR)VAX_MMU.C,$(VAX412_DIR)VAX_SYS.C,\\\r\n                 $(VAX412_DIR)VAX_SYSCM.C\r\nVAX412_LIB2 = $(LIB_DIR)VAX412L2-$(ARCH).OLB\r\nVAX412_SOURCE2 = $(VAX412_DIR)VAX_NAR.C,$(VAX412_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX412_DIR)VAX420_SYSDEV.C,$(VAX412_DIR)VAX420_SYSLIST.C,\\\r\n                 $(VAX412_DIR)VAX4XX_DZ.C,$(VAX412_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX412_DIR)VAX4XX_RZ80.C,$(VAX412_DIR)VAX_XS.C,\\\r\n                 $(VAX412_DIR)VAX4XX_VA.C,$(VAX412_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX412_DIR)VAX4XX_VE.C,$(VAX412_DIR)VAX_LK.C,\\\r\n                 $(VAX412_DIR)VAX_VS.C,$(VAX412_DIR)VAX_GPX.C,\\\r\n                 $(VAX412_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX412_OPTIONS = /INCL=($(SIMH_DIR),$(VAX412_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_412=1\")\r\nVAX412_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX412_OPTIONS = /INCL=($(SIMH_DIR),$(VAX412_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_412=1\")\r\nVAX412_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX41A (MicroVAX 3100 M10/M20) Simulator Definitions.\r\n#\r\nVAX41A_DIR = SYS$DISK:[.VAX]\r\nVAX41A_LIB1 = $(LIB_DIR)VAX41AL1-$(ARCH).OLB\r\nVAX41A_SOURCE1 = $(VAX41A_DIR)VAX_CPU.C,$(VAX41A_DIR)VAX_CPU1.C,\\\r\n                 $(VAX41A_DIR)VAX_FPA.C,$(VAX41A_DIR)VAX_CIS.C,\\\r\n                 $(VAX41A_DIR)VAX_OCTA.C,$(VAX41A_DIR)VAX_CMODE.C,\\\r\n                 $(VAX41A_DIR)VAX_MMU.C,$(VAX41A_DIR)VAX_SYS.C,\\\r\n                 $(VAX41A_DIR)VAX_SYSCM.C\r\nVAX41A_LIB2 = $(LIB_DIR)VAX41AL2-$(ARCH).OLB\r\nVAX41A_SOURCE2 = $(VAX41A_DIR)VAX_NAR.C,$(VAX41A_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX41A_DIR)VAX420_SYSDEV.C,$(VAX41A_DIR)VAX420_SYSLIST.C,\\\r\n                 $(VAX41A_DIR)VAX4XX_DZ.C,$(VAX41A_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX41A_DIR)VAX4XX_RZ80.C,$(VAX41A_DIR)VAX_XS.C,\\\r\n                 $(VAX41A_DIR)VAX4XX_VA.C,$(VAX41A_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX41A_DIR)VAX4XX_VE.C,$(VAX41A_DIR)VAX_LK.C,\\\r\n                 $(VAX41A_DIR)VAX_VS.C,$(VAX41A_DIR)VAX_GPX.C,\\\r\n                 $(VAX41A_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX41A_OPTIONS = /INCL=($(SIMH_DIR),$(VAX41A_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_41A=1\")\r\nVAX41A_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX41A_OPTIONS = /INCL=($(SIMH_DIR),$(VAX41A_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_41A=1\")\r\nVAX41A_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX41D (MicroVAX 3100 M10e/M20e) Simulator Definitions.\r\n#\r\nVAX41D_DIR = SYS$DISK:[.VAX]\r\nVAX41D_LIB1 = $(LIB_DIR)VAX41DL1-$(ARCH).OLB\r\nVAX41D_SOURCE1 = $(VAX41D_DIR)VAX_CPU.C,$(VAX41D_DIR)VAX_CPU1.C,\\\r\n                 $(VAX41D_DIR)VAX_FPA.C,$(VAX41D_DIR)VAX_CIS.C,\\\r\n                 $(VAX41D_DIR)VAX_OCTA.C,$(VAX41D_DIR)VAX_CMODE.C,\\\r\n                 $(VAX41D_DIR)VAX_MMU.C,$(VAX41D_DIR)VAX_SYS.C,\\\r\n                 $(VAX41D_DIR)VAX_SYSCM.C\r\nVAX41D_LIB2 = $(LIB_DIR)VAX41DL2-$(ARCH).OLB\r\nVAX41D_SOURCE2 = $(VAX41D_DIR)VAX_NAR.C,$(VAX41D_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX41D_DIR)VAX420_SYSDEV.C,$(VAX41D_DIR)VAX420_SYSLIST.C,\\\r\n                 $(VAX41D_DIR)VAX4XX_DZ.C,$(VAX41D_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX41D_DIR)VAX4XX_RZ80.C,$(VAX41D_DIR)VAX_XS.C,\\\r\n                 $(VAX41D_DIR)VAX4XX_VA.C,$(VAX41D_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX41D_DIR)VAX4XX_VE.C,$(VAX41D_DIR)VAX_LK.C,\\\r\n                 $(VAX41D_DIR)VAX_VS.C,$(VAX41D_DIR)VAX_GPX.C,\\\r\n                 $(VAX41D_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX41D_OPTIONS = /INCL=($(SIMH_DIR),$(VAX41D_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_41D=1\")\r\nVAX41D_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX41D_OPTIONS = /INCL=($(SIMH_DIR),$(VAX41D_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_41D=1\")\r\nVAX41D_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX42A (VAXstation 3100 M30) Simulator Definitions.\r\n#\r\nVAX42A_DIR = SYS$DISK:[.VAX]\r\nVAX42A_LIB1 = $(LIB_DIR)VAX42AL1-$(ARCH).OLB\r\nVAX42A_SOURCE1 = $(VAX42A_DIR)VAX_CPU.C,$(VAX42A_DIR)VAX_CPU1.C,\\\r\n                 $(VAX42A_DIR)VAX_FPA.C,$(VAX42A_DIR)VAX_CIS.C,\\\r\n                 $(VAX42A_DIR)VAX_OCTA.C,$(VAX42A_DIR)VAX_CMODE.C,\\\r\n                 $(VAX42A_DIR)VAX_MMU.C,$(VAX42A_DIR)VAX_SYS.C,\\\r\n                 $(VAX42A_DIR)VAX_SYSCM.C\r\nVAX42A_LIB2 = $(LIB_DIR)VAX42AL2-$(ARCH).OLB\r\nVAX42A_SOURCE2 = $(VAX42A_DIR)VAX_NAR.C,$(VAX42A_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX42A_DIR)VAX420_SYSDEV.C,$(VAX42A_DIR)VAX420_SYSLIST.C,\\\r\n                 $(VAX42A_DIR)VAX4XX_DZ.C,$(VAX42A_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX42A_DIR)VAX4XX_RZ80.C,$(VAX42A_DIR)VAX_XS.C,\\\r\n                 $(VAX42A_DIR)VAX4XX_VA.C,$(VAX42A_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX42A_DIR)VAX4XX_VE.C,$(VAX42A_DIR)VAX_LK.C,\\\r\n                 $(VAX42A_DIR)VAX_VS.C,$(VAX42A_DIR)VAX_GPX.C,\\\r\n                 $(VAX42A_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX42A_OPTIONS = /INCL=($(SIMH_DIR),$(VAX42A_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_42A=1\")\r\nVAX42A_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX42A_OPTIONS = /INCL=($(SIMH_DIR),$(VAX42A_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_42A=1\")\r\nVAX42A_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX42B (VAXstation 3100 M38) Simulator Definitions.\r\n#\r\nVAX42B_DIR = SYS$DISK:[.VAX]\r\nVAX42B_LIB1 = $(LIB_DIR)VAX42BL1-$(ARCH).OLB\r\nVAX42B_SOURCE1 = $(VAX42B_DIR)VAX_CPU.C,$(VAX42B_DIR)VAX_CPU1.C,\\\r\n                 $(VAX42B_DIR)VAX_FPA.C,$(VAX42B_DIR)VAX_CIS.C,\\\r\n                 $(VAX42B_DIR)VAX_OCTA.C,$(VAX42B_DIR)VAX_CMODE.C,\\\r\n                 $(VAX42B_DIR)VAX_MMU.C,$(VAX42B_DIR)VAX_SYS.C,\\\r\n                 $(VAX42B_DIR)VAX_SYSCM.C\r\nVAX42B_LIB2 = $(LIB_DIR)VAX42BL2-$(ARCH).OLB\r\nVAX42B_SOURCE2 = $(VAX42B_DIR)VAX_NAR.C,$(VAX42B_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX42B_DIR)VAX420_SYSDEV.C,$(VAX42B_DIR)VAX420_SYSLIST.C,\\\r\n                 $(VAX42B_DIR)VAX4XX_DZ.C,$(VAX42B_DIR)VAX4XX_RD.C,\\\r\n                 $(VAX42B_DIR)VAX4XX_RZ80.C,$(VAX42B_DIR)VAX_XS.C,\\\r\n                 $(VAX42B_DIR)VAX4XX_VA.C,$(VAX42B_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX42B_DIR)VAX4XX_VE.C,$(VAX42B_DIR)VAX_LK.C,\\\r\n                 $(VAX42B_DIR)VAX_VS.C,$(VAX42B_DIR)VAX_GPX.C,\\\r\n                 $(VAX42B_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX42B_OPTIONS = /INCL=($(SIMH_DIR),$(VAX42B_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_42B=1\")\r\nVAX42B_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX42B_OPTIONS = /INCL=($(SIMH_DIR),$(VAX42B_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_420=1\",\"VAX_42B=1\")\r\nVAX42B_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX43 (VAXstation 3100 M76) Simulator Definitions.\r\n#\r\nVAX43_DIR = SYS$DISK:[.VAX]\r\nVAX43_LIB1 = $(LIB_DIR)VAX43L1-$(ARCH).OLB\r\nVAX43_SOURCE1 = $(VAX43_DIR)VAX_CPU.C,$(VAX43_DIR)VAX_CPU1.C,\\\r\n                 $(VAX43_DIR)VAX_FPA.C,$(VAX43_DIR)VAX_CIS.C,\\\r\n                 $(VAX43_DIR)VAX_OCTA.C,$(VAX43_DIR)VAX_CMODE.C,\\\r\n                 $(VAX43_DIR)VAX_MMU.C,$(VAX43_DIR)VAX_SYS.C,\\\r\n                 $(VAX43_DIR)VAX_SYSCM.C\r\nVAX43_LIB2 = $(LIB_DIR)VAX43L2-$(ARCH).OLB\r\nVAX43_SOURCE2 = $(VAX43_DIR)VAX_NAR.C,$(VAX43_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX43_DIR)VAX43_SYSDEV.C,$(VAX43_DIR)VAX43_SYSLIST.C,\\\r\n                 $(VAX43_DIR)VAX4XX_DZ.C,$(VAX43_DIR)VAX4XX_RZ80.C,\\\r\n                 $(VAX43_DIR)VAX_XS.C,$(VAX43_DIR)VAX4XX_VC.C,\\\r\n                 $(VAX43_DIR)VAX4XX_VE.C,$(VAX43_DIR)VAX_LK.C,\\\r\n                 $(VAX43_DIR)VAX_VS.C,$(VAX43_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX43_OPTIONS = /INCL=($(SIMH_DIR),$(VAX43_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_43=1\")\r\nVAX43_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX43_OPTIONS = /INCL=($(SIMH_DIR),$(VAX43_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_43=1\")\r\nVAX43_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX46 (VAXstation 4000 M60) Simulator Definitions.\r\n#\r\nVAX46_DIR = SYS$DISK:[.VAX]\r\nVAX46_LIB1 = $(LIB_DIR)VAX46L1-$(ARCH).OLB\r\nVAX46_SOURCE1 = $(VAX46_DIR)VAX_CPU.C,$(VAX46_DIR)VAX_CPU1.C,\\\r\n                 $(VAX46_DIR)VAX_FPA.C,$(VAX46_DIR)VAX_CIS.C,\\\r\n                 $(VAX46_DIR)VAX_OCTA.C,$(VAX46_DIR)VAX_CMODE.C,\\\r\n                 $(VAX46_DIR)VAX_MMU.C,$(VAX46_DIR)VAX_SYS.C,\\\r\n                 $(VAX46_DIR)VAX_SYSCM.C\r\nVAX46_LIB2 = $(LIB_DIR)VAX46L2-$(ARCH).OLB\r\nVAX46_SOURCE2 = $(VAX46_DIR)VAX_NAR.C,$(VAX46_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX46_DIR)VAX440_SYSDEV.C,$(VAX46_DIR)VAX440_SYSLIST.C,\\\r\n                 $(VAX46_DIR)VAX4XX_DZ.C,$(VAX46_DIR)VAX4XX_RZ94.C,\\\r\n                 $(VAX46_DIR)VAX_XS.C,$(VAX46_DIR)VAX_LK.C,\\\r\n                 $(VAX46_DIR)VAX_VS.C,$(VAX46_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX46_OPTIONS = /INCL=($(SIMH_DIR),$(VAX46_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_440=1\",\"VAX_46=1\")\r\nVAX46_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX46_OPTIONS = /INCL=($(SIMH_DIR),$(VAX46_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_440=1\",\"VAX_46=1\")\r\nVAX46_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX47 (MicroVAX 3100 M80) Simulator Definitions.\r\n#\r\nVAX47_DIR = SYS$DISK:[.VAX]\r\nVAX47_LIB1 = $(LIB_DIR)VAX47L1-$(ARCH).OLB\r\nVAX47_SOURCE1 = $(VAX47_DIR)VAX_CPU.C,$(VAX47_DIR)VAX_CPU1.C,\\\r\n                 $(VAX47_DIR)VAX_FPA.C,$(VAX47_DIR)VAX_CIS.C,\\\r\n                 $(VAX47_DIR)VAX_OCTA.C,$(VAX47_DIR)VAX_CMODE.C,\\\r\n                 $(VAX47_DIR)VAX_MMU.C,$(VAX47_DIR)VAX_SYS.C,\\\r\n                 $(VAX47_DIR)VAX_SYSCM.C\r\nVAX47_LIB2 = $(LIB_DIR)VAX47L2-$(ARCH).OLB\r\nVAX47_SOURCE2 = $(VAX47_DIR)VAX_NAR.C,$(VAX47_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX47_DIR)VAX440_SYSDEV.C,$(VAX47_DIR)VAX440_SYSLIST.C,\\\r\n                 $(VAX47_DIR)VAX4XX_DZ.C,$(VAX47_DIR)VAX4XX_RZ94.C,\\\r\n                 $(VAX47_DIR)VAX_XS.C,$(VAX47_DIR)VAX_LK.C,\\\r\n                 $(VAX47_DIR)VAX_VS.C,$(VAX47_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX47_OPTIONS = /INCL=($(SIMH_DIR),$(VAX47_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_440=1\",\"VAX_47=1\")\r\nVAX47_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX47_OPTIONS = /INCL=($(SIMH_DIR),$(VAX47_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_440=1\",\"VAX_47=1\")\r\nVAX47_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX48 (VAXstation 4000 VLC) Simulator Definitions.\r\n#\r\nVAX48_DIR = SYS$DISK:[.VAX]\r\nVAX48_LIB1 = $(LIB_DIR)VAX48L1-$(ARCH).OLB\r\nVAX48_SOURCE1 = $(VAX48_DIR)VAX_CPU.C,$(VAX48_DIR)VAX_CPU1.C,\\\r\n                 $(VAX48_DIR)VAX_FPA.C,$(VAX48_DIR)VAX_CIS.C,\\\r\n                 $(VAX48_DIR)VAX_OCTA.C,$(VAX48_DIR)VAX_CMODE.C,\\\r\n                 $(VAX48_DIR)VAX_MMU.C,$(VAX48_DIR)VAX_SYS.C,\\\r\n                 $(VAX48_DIR)VAX_SYSCM.C\r\nVAX48_LIB2 = $(LIB_DIR)VAX48L2-$(ARCH).OLB\r\nVAX48_SOURCE2 = $(VAX48_DIR)VAX_NAR.C,$(VAX48_DIR)VAX4XX_STDDEV.C,\\\r\n                 $(VAX48_DIR)VAX440_SYSDEV.C,$(VAX48_DIR)VAX440_SYSLIST.C,\\\r\n                 $(VAX48_DIR)VAX4XX_DZ.C,$(VAX48_DIR)VAX4XX_RZ94.C,\\\r\n                 $(VAX48_DIR)VAX_XS.C,$(VAX48_DIR)VAX_LK.C,\\\r\n                 $(VAX48_DIR)VAX_VS.C,$(VAX48_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX48_OPTIONS = /INCL=($(SIMH_DIR),$(VAX48_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_440=1\",\"VAX_48=1\")\r\nVAX48_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX48_OPTIONS = /INCL=($(SIMH_DIR),$(VAX48_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_440=1\",\"VAX_48=1\")\r\nVAX48_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment IS1000 (InfoServer 1000) Simulator Definitions.\r\n#\r\nIS1000_DIR = SYS$DISK:[.VAX]\r\nIS1000_LIB1 = $(LIB_DIR)IS1000L1-$(ARCH).OLB\r\nIS1000_SOURCE1 = $(IS1000_DIR)VAX_CPU.C,$(IS1000_DIR)VAX_CPU1.C,\\\r\n                 $(IS1000_DIR)VAX_FPA.C,$(IS1000_DIR)VAX_CIS.C,\\\r\n                 $(IS1000_DIR)VAX_OCTA.C,$(IS1000_DIR)VAX_CMODE.C,\\\r\n                 $(IS1000_DIR)VAX_MMU.C,$(IS1000_DIR)VAX_SYS.C,\\\r\n                 $(IS1000_DIR)VAX_SYSCM.C\r\nIS1000_LIB2 = $(LIB_DIR)IS1000L2-$(ARCH).OLB\r\nIS1000_SOURCE2 = $(IS1000_DIR)VAX_NAR.C,$(IS1000_DIR)VAX4NN_STDDEV.C,\\\r\n                 $(IS1000_DIR)IS1000_SYSDEV.C,$(IS1000_DIR)IS1000_SYSLIST.C,\\\r\n                 $(IS1000_DIR)VAX4XX_RZ94.C,$(IS1000_DIR)VAX_XS.C,\\\r\n                 $(IS1000_DIR)VAX_WATCH.C\r\n.IFDEF ALPHA_OR_IA64\r\nIS1000_OPTIONS = /INCL=($(SIMH_DIR),$(IS1000_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"IS_1000=1\")\r\nIS1000_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nIS1000_OPTIONS = /INCL=($(SIMH_DIR),$(IS1000_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"IS_1000=1\")\r\nIS1000_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX610 (MicroVAX I) Simulator Definitions.\r\n#\r\nVAX610_DIR = SYS$DISK:[.VAX]\r\nVAX610_LIB1 = $(LIB_DIR)VAX610L1-$(ARCH).OLB\r\nVAX610_SOURCE1 = $(VAX610_DIR)VAX_CPU.C,$(VAX610_DIR)VAX_CPU1.C,\\\r\n                 $(VAX610_DIR)VAX_FPA.C,$(VAX610_DIR)VAX_CIS.C,\\\r\n                 $(VAX610_DIR)VAX_OCTA.C,$(VAX610_DIR)VAX_CMODE.C,\\\r\n                 $(VAX610_DIR)VAX_MMU.C,$(VAX610_DIR)VAX_SYS.C,\\\r\n                 $(VAX610_DIR)VAX_SYSCM.C,$(VAX610_DIR)VAX610_STDDEV.C,\\\r\n                 $(VAX610_DIR)VAX610_MEM.C,$(VAX610_DIR)VAX610_SYSDEV.C,\\\r\n                 $(VAX610_DIR)VAX610_IO.C,$(VAX610_DIR)VAX610_SYSLIST.C\r\nVAX610_LIB2 = $(LIB_DIR)VAX610L2-$(ARCH).OLB\r\nVAX610_SOURCE2 = $(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XQ.C,$(PDP11_DIR)PDP11_VH.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(VAX610_DIR)VAX_VC.C,\\\r\n                 $(VAX610_DIR)VAX_LK.C,$(VAX610_DIR)VAX_VS.C,\\\r\n                 $(VAX610_DIR)VAX_2681.C,$(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX610_OPTIONS = /INCL=($(SIMH_DIR),$(VAX610_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_610=1\")\r\nVAX610_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX610_OPTIONS = /INCL=($(SIMH_DIR),$(VAX610_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_610=1\")\r\nVAX610_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX630 (MicroVAX II) Simulator Definitions.\r\n#\r\nVAX630_DIR = SYS$DISK:[.VAX]\r\nVAX630_LIB1 = $(LIB_DIR)VAX630L1-$(ARCH).OLB\r\nVAX630_SOURCE1 = $(VAX630_DIR)VAX_CPU.C,$(VAX630_DIR)VAX_CPU1.C,\\\r\n                 $(VAX630_DIR)VAX_FPA.C,$(VAX630_DIR)VAX_CIS.C,\\\r\n                 $(VAX630_DIR)VAX_OCTA.C,$(VAX630_DIR)VAX_CMODE.C,\\\r\n                 $(VAX630_DIR)VAX_MMU.C,$(VAX630_DIR)VAX_SYS.C,\\\r\n                 $(VAX630_DIR)VAX_SYSCM.C,$(VAX630_DIR)VAX_WATCH.C,\\\r\n                 $(VAX630_DIR)VAX630_STDDEV.C,$(VAX630_DIR)VAX630_SYSDEV.C,\\\r\n                 $(VAX630_DIR)VAX630_IO.C,$(VAX630_DIR)VAX630_SYSLIST.C\r\nVAX630_LIB2 = $(LIB_DIR)VAX630L2-$(ARCH).OLB\r\nVAX630_SOURCE2 = $(PDP11_DIR)PDP11_IO_LIB.C,$(PDP11_DIR)PDP11_CR.C,\\\r\n                 $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,\\\r\n                 $(PDP11_DIR)PDP11_TQ.C,$(PDP11_DIR)PDP11_XQ.C,\\\r\n                 $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_DUP.C,\\\r\n                 $(VAX630_DIR)VAX_VA.C,$(VAX630_DIR)VAX_VC.C,\\\r\n                 $(VAX630_DIR)VAX_LK.C,$(VAX630_DIR)VAX_VS.C,\\\r\n                 $(VAX630_DIR)VAX_2681.C,$(VAX630_DIR)VAX_GPX.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX630_OPTIONS = /INCL=($(SIMH_DIR),$(VAX630_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_630=1\")\r\nVAX630_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX630_OPTIONS = /INCL=($(SIMH_DIR),$(VAX630_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_630=1\")\r\nVAX630_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment rtVAX1000 (rtVAX 1000) Simulator Definitions.\r\n#\r\nVAX620_DIR = SYS$DISK:[.VAX]\r\nVAX620_LIB1 = $(LIB_DIR)VAX620L1-$(ARCH).OLB\r\nVAX620_SOURCE1 = $(VAX620_DIR)VAX_CPU.C,$(VAX620_DIR)VAX_CPU1.C,\\\r\n                 $(VAX620_DIR)VAX_FPA.C,$(VAX620_DIR)VAX_CIS.C,\\\r\n                 $(VAX620_DIR)VAX_OCTA.C,$(VAX620_DIR)VAX_CMODE.C,\\\r\n                 $(VAX620_DIR)VAX_MMU.C,$(VAX620_DIR)VAX_SYS.C,\\\r\n                 $(VAX620_DIR)VAX_SYSCM.C,$(VAX630_DIR)VAX_WATCH.C,\\\r\n                 $(VAX620_DIR)VAX630_STDDEV.C,$(VAX620_DIR)VAX630_SYSDEV.C,\\\r\n                 $(VAX620_DIR)VAX630_IO.C,$(VAX620_DIR)VAX630_SYSLIST.C\r\nVAX620_LIB2 = $(LIB_DIR)VAX620L2-$(ARCH).OLB\r\nVAX620_SOURCE2 = $(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XQ.C,$(PDP11_DIR)PDP11_VH.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(VAX620_DIR)VAX_VC.C,\\\r\n                 $(VAX620_DIR)VAX_LK.C,$(VAX620_DIR)VAX_VS.C,\\\r\n                 $(VAX620_DIR)VAX_2681.C,$(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX620_OPTIONS = /INCL=($(SIMH_DIR),$(VAX620_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_620=1\")\r\nVAX620_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX620_OPTIONS = /INCL=($(SIMH_DIR),$(VAX620_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_620=1\")\r\nVAX620_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX730 Simulator Definitions.\r\n#\r\nVAX730_DIR = SYS$DISK:[.VAX]\r\nVAX730_LIB1 = $(LIB_DIR)VAX730L1-$(ARCH).OLB\r\nVAX730_SOURCE1 = $(VAX730_DIR)VAX_CPU.C,$(VAX730_DIR)VAX_CPU1.C,\\\r\n                 $(VAX730_DIR)VAX_FPA.C,$(VAX730_DIR)VAX_CIS.C,\\\r\n                 $(VAX730_DIR)VAX_OCTA.C,$(VAX730_DIR)VAX_CMODE.C,\\\r\n                 $(VAX730_DIR)VAX_MMU.C,$(VAX730_DIR)VAX_SYS.C,\\\r\n                 $(VAX730_DIR)VAX_SYSCM.C,$(VAX730_DIR)VAX730_STDDEV.C,\\\r\n                 $(VAX730_DIR)VAX730_SYS.C,$(VAX730_DIR)VAX730_MEM.C,\\\r\n                 $(VAX730_DIR)VAX730_UBA.C,$(VAX730_DIR)VAX730_RB.C,\\\r\n                 $(VAX730_DIR)VAX730_SYSLIST.C\r\nVAX730_LIB2 = $(LIB_DIR)VAX730L2-$(ARCH).OLB\r\nVAX730_SOURCE2 = $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XU.C,$(PDP11_DIR)PDP11_RY.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(PDP11_DIR)PDP11_HK.C,\\\r\n                 $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n                 $(PDP11_DIR)PDP11_TC.C,$(PDP11_DIR)PDP11_RK.C,\\\r\n                 $(PDP11_DIR)PDP11_CH.C,$(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX730_OPTIONS = /INCL=($(SIMH_DIR),$(VAX730_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_730=1\")\r\nVAX730_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX730_OPTIONS = /INCL=($(SIMH_DIR),$(VAX730_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_730=1\")\r\nVAX730_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX750 Simulator Definitions.\r\n#\r\nVAX750_DIR = SYS$DISK:[.VAX]\r\nVAX750_LIB1 = $(LIB_DIR)VAX750L1-$(ARCH).OLB\r\nVAX750_SOURCE1 = $(VAX750_DIR)VAX_CPU.C,$(VAX750_DIR)VAX_CPU1.C,\\\r\n                 $(VAX750_DIR)VAX_FPA.C,$(VAX750_DIR)VAX_CIS.C,\\\r\n                 $(VAX750_DIR)VAX_OCTA.C,$(VAX750_DIR)VAX_CMODE.C,\\\r\n                 $(VAX750_DIR)VAX_MMU.C,$(VAX750_DIR)VAX_SYS.C,\\\r\n                 $(VAX750_DIR)VAX_SYSCM.C,$(VAX750_DIR)VAX750_STDDEV.C,\\\r\n                 $(VAX750_DIR)VAX750_CMI.C,$(VAX750_DIR)VAX750_MEM.C,\\\r\n                 $(VAX750_DIR)VAX750_UBA.C,$(VAX750_DIR)VAX7X0_MBA.C,\\\r\n                 $(VAX750_DIR)VAX750_SYSLIST.C\r\nVAX750_LIB2 = $(LIB_DIR)VAX750L2-$(ARCH).OLB\r\nVAX750_SOURCE2 = $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XU.C,$(PDP11_DIR)PDP11_RY.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(PDP11_DIR)PDP11_HK.C,\\\r\n                 $(PDP11_DIR)PDP11_RP.C,$(PDP11_DIR)PDP11_TU.C,\\\r\n                 $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n                 $(PDP11_DIR)PDP11_TC.C,$(PDP11_DIR)PDP11_RK.C,\\\r\n                 $(PDP11_DIR)PDP11_CH.C,$(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX750_OPTIONS = /INCL=($(SIMH_DIR),$(VAX750_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_750=1\")\r\nVAX750_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX750_OPTIONS = /INCL=($(SIMH_DIR),$(VAX750_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_750=1\")\r\nVAX750_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX780 Simulator Definitions.\r\n#\r\nVAX780_DIR = SYS$DISK:[.VAX]\r\nVAX780_LIB1 = $(LIB_DIR)VAX780L1-$(ARCH).OLB\r\nVAX780_SOURCE1 = $(VAX780_DIR)VAX_CPU.C,$(VAX780_DIR)VAX_CPU1.C,\\\r\n                 $(VAX780_DIR)VAX_FPA.C,$(VAX780_DIR)VAX_CIS.C,\\\r\n                 $(VAX780_DIR)VAX_OCTA.C,$(VAX780_DIR)VAX_CMODE.C,\\\r\n                 $(VAX780_DIR)VAX_MMU.C,$(VAX780_DIR)VAX_SYS.C,\\\r\n                 $(VAX780_DIR)VAX_SYSCM.C,$(VAX780_DIR)VAX780_STDDEV.C,\\\r\n                 $(VAX780_DIR)VAX780_SBI.C,$(VAX780_DIR)VAX780_MEM.C,\\\r\n                 $(VAX780_DIR)VAX780_UBA.C,$(VAX780_DIR)VAX7X0_MBA.C,\\\r\n                 $(VAX780_DIR)VAX780_FLOAD.C,$(VAX780_DIR)VAX780_SYSLIST.C\r\nVAX780_LIB2 = $(LIB_DIR)VAX780L2-$(ARCH).OLB\r\nVAX780_SOURCE2 = $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XU.C,$(PDP11_DIR)PDP11_RY.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(PDP11_DIR)PDP11_RP.C,\\\r\n                 $(PDP11_DIR)PDP11_TU.C,$(PDP11_DIR)PDP11_HK.C,\\\r\n                 $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n                 $(PDP11_DIR)PDP11_TC.C,$(PDP11_DIR)PDP11_RK.C,\\\r\n                 $(PDP11_DIR)PDP11_CH.C,$(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX780_OPTIONS = /INCL=($(SIMH_DIR),$(VAX780_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_780=1\")\r\nVAX780_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX780_OPTIONS = /INCL=($(SIMH_DIR),$(VAX780_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_780=1\")\r\nVAX780_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX8200 Simulator Definitions.\r\n#\r\nVAX8200_DIR = SYS$DISK:[.VAX]\r\nVAX8200_LIB1 = $(LIB_DIR)VAX820L1-$(ARCH).OLB\r\nVAX8200_SOURCE1 = $(VAX8200_DIR)VAX_CPU.C,$(VAX8200_DIR)VAX_CPU1.C,\\\r\n                 $(VAX8200_DIR)VAX_FPA.C,$(VAX8200_DIR)VAX_CIS.C,\\\r\n                 $(VAX8200_DIR)VAX_OCTA.C,$(VAX8200_DIR)VAX_CMODE.C,\\\r\n                 $(VAX8200_DIR)VAX_MMU.C,$(VAX8200_DIR)VAX_SYS.C,\\\r\n                 $(VAX8200_DIR)VAX_SYSCM.C,$(VAX8200_DIR)VAX_WATCH.C,\\\r\n                 $(VAX8200_DIR)VAX820_STDDEV.C,$(VAX8200_DIR)VAX820_BI.C,\\\r\n                 $(VAX8200_DIR)VAX820_MEM.C,$(VAX8200_DIR)VAX820_UBA.C,\\\r\n                 $(VAX8200_DIR)VAX820_KA.C,$(VAX8200_DIR)VAX820_SYSLIST.C\r\nVAX8200_LIB2 = $(LIB_DIR)VAX820L2-$(ARCH).OLB\r\nVAX8200_SOURCE2 = $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XU.C,$(PDP11_DIR)PDP11_RY.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(PDP11_DIR)PDP11_HK.C,\\\r\n                 $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n                 $(PDP11_DIR)PDP11_TC.C,$(PDP11_DIR)PDP11_RK.C,\\\r\n                 $(PDP11_DIR)PDP11_CH.C,$(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX8200_OPTIONS = /INCL=($(SIMH_DIR),$(VAX8200_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_820=1\")\r\nVAX8200_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX8200_OPTIONS = /INCL=($(SIMH_DIR),$(VAX8200_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_860=1\")\r\nVAX8200_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# Digital Equipment VAX8600 Simulator Definitions.\r\n#\r\nVAX8600_DIR = SYS$DISK:[.VAX]\r\nVAX8600_LIB1 = $(LIB_DIR)VAX860L1-$(ARCH).OLB\r\nVAX8600_SOURCE1 = $(VAX8600_DIR)VAX_CPU.C,$(VAX8600_DIR)VAX_CPU1.C,\\\r\n                 $(VAX8600_DIR)VAX_FPA.C,$(VAX8600_DIR)VAX_CIS.C,\\\r\n                 $(VAX8600_DIR)VAX_OCTA.C,$(VAX8600_DIR)VAX_CMODE.C,\\\r\n                 $(VAX8600_DIR)VAX_MMU.C,$(VAX8600_DIR)VAX_SYS.C,\\\r\n                 $(VAX8600_DIR)VAX_SYSCM.C,$(VAX8600_DIR)VAX860_STDDEV.C,\\\r\n                 $(VAX8600_DIR)VAX860_SBIA.C,$(VAX8600_DIR)VAX860_ABUS.C,\\\r\n                 $(VAX8600_DIR)VAX780_UBA.C,$(VAX8600_DIR)VAX7X0_MBA.C,\\\r\n                 $(VAX8600_DIR)VAX860_SYSLIST.C\r\nVAX8600_LIB2 = $(LIB_DIR)VAX860L2-$(ARCH).OLB\r\nVAX8600_SOURCE2 = $(PDP11_DIR)PDP11_RL.C,$(PDP11_DIR)PDP11_RQ.C,\\\r\n                 $(PDP11_DIR)PDP11_TS.C,$(PDP11_DIR)PDP11_DZ.C,\\\r\n                 $(PDP11_DIR)PDP11_LP.C,$(PDP11_DIR)PDP11_TD.C,$(PDP11_DIR)PDP11_TQ.C,\\\r\n                 $(PDP11_DIR)PDP11_XU.C,$(PDP11_DIR)PDP11_RY.C,\\\r\n                 $(PDP11_DIR)PDP11_CR.C,$(PDP11_DIR)PDP11_RP.C,\\\r\n                 $(PDP11_DIR)PDP11_TU.C,$(PDP11_DIR)PDP11_HK.C,\\\r\n                 $(PDP11_DIR)PDP11_VH.C,$(PDP11_DIR)PDP11_DMC.C,\\\r\n                 $(PDP11_DIR)PDP11_TC.C,$(PDP11_DIR)PDP11_RK.C,\\\r\n                 $(PDP11_DIR)PDP11_CH.C,$(PDP11_DIR)PDP11_IO_LIB.C,\\\r\n                 $(PDP11_DIR)PDP11_DUP.C\r\n.IFDEF ALPHA_OR_IA64\r\nVAX8600_OPTIONS = /INCL=($(SIMH_DIR),$(VAX8600_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\",\"USE_ADDR64=1\",\"USE_INT64=1\"$(PCAP_DEFS),\"VAX_860=1\")\r\nVAX8600_SIMH_LIB = $(SIMH_LIB64)\r\n.ELSE\r\nVAX8600_OPTIONS = /INCL=($(SIMH_DIR),$(VAX8600_DIR),$(PDP11_DIR)$(PCAP_INC))\\\r\n                 /DEF=($(CC_DEFS),\"VM_VAX=1\"$(PCAP_DEFS),\"VAX_860=1\")\r\nVAX8600_SIMH_LIB = $(SIMH_LIB)\r\n.ENDIF\r\n\r\n# IBM 7094 Simulator Definitions.\r\n#\r\nI7094_DIR = SYS$DISK:[.I7094]\r\nI7094_LIB = $(LIB_DIR)I7094-$(ARCH).OLB\r\nI7094_SOURCE = $(I7094_DIR)I7094_CPU.C,$(I7094_DIR)I7094_CPU1.C,\\\r\n               $(I7094_DIR)I7094_IO.C,$(I7094_DIR)I7094_CD.C,\\\r\n               $(I7094_DIR)I7094_CLK.C,$(I7094_DIR)I7094_COM.C,\\\r\n               $(I7094_DIR)I7094_DRM.C,$(I7094_DIR)I7094_DSK.C,\\\r\n               $(I7094_DIR)I7094_SYS.C,$(I7094_DIR)I7094_LP.C,\\\r\n               $(I7094_DIR)I7094_MT.C,$(I7094_DIR)I7094_BINLOADER.C\r\nI7094_OPTIONS = /INCL=($(SIMH_DIR),$(I7094_DIR))/DEF=($(CC_DEFS))\r\n\r\n# If we're not a VAX, Build Everything\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nALL : ALTAIR ALTAIRZ80 CDC1700 ECLIPSE GRI LGP H316 HP2100 HP3000 I1401 I1620 \\\r\n      IBM1130 ID16 ID32 NOVA PDP1 PDP4 PDP7 PDP8 PDP9 PDP10 PDP11 PDP15 S3 \\\r\n      VAX MICROVAX3900 MICROVAX1 RTVAX1000 MICROVAX2 VAX730 VAX750 VAX780 \\\r\n      MICROVAX2000 INFOSERVER100 INFOSERVER150VXT \\\r\n      MICROVAX3100 MICROVAX3100E VAXSTATION3100M30 \\\r\n      VAXSTATION3100M38 VAXSTATION3100M76 VAXSTATION4000M60 \\\r\n      VAXSTATION3100M80 VAXSTATION4000VLC INFOSERVER1000 \\\r\n      VAX8200 VAX8600 SDS I7094 SWTP6800MP-A SWTP6800MP-A2 SSEM BESM6 B5500 \\\r\n      PDP6 PDP10-KA PDP10-KI\r\n        $! No further actions necessary\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Build Everything EXCEPT the 64b simulators\r\n#\r\nALL : ALTAIR GRI H316 HP2100 I1401 I1620 IBM1130 ID16 ID32 \\\r\n      NOVA PDP1 PDP4 PDP7 PDP8 PDP9 PDP11 PDP15 S3 \\\r\n      VAX MICROVAX3900 MICROVAX1 RTVAX1000 MICROVAX2 VAX730 VAX750 VAX780 VAX8600 \\\r\n      MICROVAX2000 INFOSERVER100 INFOSERVER150VXT \\\r\n      MICROVAX3100 MICROVAX3100E VAXSTATION3100M30 \\\r\n      VAXSTATION3100M38 VAXSTATION3100M76 VAXSTATION4000M60 \\\r\n      VAXSTATION3100M80 VAXSTATION4000VLC INFOSERVER1000\r\n        $! No further actions necessary\r\n.ENDIF\r\n\r\nCLEAN :\r\n        $!\r\n        $! Clean out all targets and building Remnants\r\n        $!\r\n        $ IF (F$SEARCH(\"$(BIN_DIR)*.EXE;*\").NES.\"\") THEN -\r\n             DELETE/NOLOG/NOCONFIRM $(BIN_DIR)*.EXE;*\r\n        $ IF (F$SEARCH(\"$(LIB_DIR)*.OLB;*\").NES.\"\") THEN -\r\n             DELETE/NOLOG/NOCONFIRM $(LIB_DIR)*.OLB;*\r\n        $ IF (F$SEARCH(\"SYS$DISK:[...]*.OBJ;*\").NES.\"\") THEN -\r\n             DELETE/NOLOG/NOCONFIRM SYS$DISK:[...]*.OBJ;*\r\n        $ IF (F$SEARCH(\"SYS$DISK:[...]*.LIS;*\").NES.\"\") THEN -\r\n             DELETE/NOLOG/NOCONFIRM SYS$DISK:[...]*.LIS;*\r\n        $ IF (F$SEARCH(\"SYS$DISK:[...]*.MAP;*\").NES.\"\") THEN -\r\n             DELETE/NOLOG/NOCONFIRM SYS$DISK:[...]*.MAP;*\r\n\r\n#\r\n# ROM support\r\n#\r\nBUILDROMS : $(BIN_DIR)BuildROMs-$(ARCH).EXE\r\n        $! BuildROMs done\r\n\r\n$(BIN_DIR)BuildROMs-$(ARCH).EXE : sim_BuildROMs.c\r\n        $!\r\n        $! Building The $(BIN_DIR)BuildROMs-$(ARCH).EXE Tool.\r\n        $!\r\n        $ $(CC)/OBJ=$(BLD_DIR) SIM_BUILDROMS.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)BUILDROMS-$(ARCH).EXE -\r\n               $(BLD_DIR)SIM_BUILDROMS.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n        $ RUN/NODEBUG $(BIN_DIR)BuildROMs-$(ARCH).EXE\r\n\r\n#\r\n# Build The Libraries.\r\n#\r\n$(SIMH_LIB) : $(SIMH_SOURCE)\r\n        $!\r\n        $! Building The $(SIMH_LIB) Library.\r\n        $!\r\n        $ $(CC)/DEF=($(CC_DEFS)$(PCAP_DEFS))$(PCAP_SIMH_INC) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(SIMH_NONET_LIB) : $(SIMH_SOURCE)\r\n        $!\r\n        $! Building The $(SIMH_NONET_LIB) Library.\r\n        $!\r\n        $ $(CC)/DEF=($(CC_DEFS)) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n.IFDEF ALPHA_OR_IA64\r\n$(SIMH_LIB64) : $(SIMH_SOURCE)\r\n        $!\r\n        $! Building The $(SIMH_LIB64) Library.\r\n        $!\r\n        $ $(CC)/DEF=($(CC_DEFS)$(PCAP_DEFS),\"USE_ADDR64=1\",\"USE_INT64=1\")$(PCAP_SIMH_INC) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ENDIF\r\n\r\n$(ATT3B2_LIB) : $(ATT3B2_SOURCE)\r\n        $!\r\n        $! Building The $(ATT3B2_LIB) Library.\r\n        $!\r\n        $ $(CC)$(ATT3B2_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(ALTAIR_LIB) : $(ALTAIR_SOURCE)\r\n        $!\r\n        $! Building The $(ALTAIR_LIB) Library.\r\n        $!\r\n        $ $(CC)$(ALTAIR_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The AltairZ80 Library.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(ALTAIRZ80_LIB1) : $(ALTAIRZ80_SOURCE1)\r\n        $!\r\n        $! Building The $(ALTAIRZ80_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(ALTAIRZ80_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(ALTAIRZ80_LIB2) : $(ALTAIRZ80_SOURCE2)\r\n        $!\r\n        $! Building The $(ALTAIRZ80_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(ALTAIRZ80_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(ALTAIRZ80_LIB1) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n\r\n$(ALTAIRZ80_LIB2) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n#\r\n# If Not On VAX, Build The Eclipse Library.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(ECLIPSE_LIB) : $(ECLIPSE_SOURCE)\r\n        $!\r\n        $! Building The $(ECLIPSE_LIB) Library.\r\n        $!\r\n        $ $(CC)$(ECLIPSE_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(ECLIPSE_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n$(GRI_LIB) : $(GRI_SOURCE)\r\n        $!\r\n        $! Building The $(GRI_LIB) Library.\r\n        $!\r\n        $ $(CC)$(GRI_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(LGP_LIB) : $(LGP_SOURCE)\r\n        $!\r\n        $! Building The $(LGP_LIB) Library.\r\n        $!\r\n        $ $(CC)$(LGP_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(H316_LIB) : $(H316_SOURCE)\r\n        $!\r\n        $! Building The $(H316_LIB) Library.\r\n        $!\r\n        $ $(CC)$(H316_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(HP2100_LIB1) : $(HP2100_SOURCE1)\r\n        $!\r\n        $! Building The $(HP2100_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(HP2100_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(HP2100_LIB2) : $(HP2100_SOURCE2)\r\n        $!\r\n        $! Building The $(HP2100_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(HP2100_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(HP3000_LIB1) : $(HP3000_SOURCE1)\r\n        $!\r\n        $! Building The $(HP3000_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(HP3000_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(HP3000_LIB2) : $(HP3000_SOURCE2)\r\n        $!\r\n        $! Building The $(HP3000_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(HP3000_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(I1401_LIB) : $(I1401_SOURCE)\r\n        $!\r\n        $! Building The $(I1401_LIB) Library.\r\n        $!\r\n        $ $(CC)$(I1401_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(I1620_LIB) : $(I1620_SOURCE)\r\n        $!\r\n        $! Building The $(I1620_LIB) Library.\r\n        $!\r\n        $ $(CC)$(I1620_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(IBM1130_LIB) : $(IBM1130_SOURCE)\r\n        $!\r\n        $! Building The $(IBM1130_LIB) Library.\r\n        $!\r\n        $ $(CC)$(IBM1130_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(ID16_LIB) : $(ID16_SOURCE)\r\n        $!\r\n        $! Building The $(ID16_LIB) Library.\r\n        $!\r\n        $ $(CC)$(ID16_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(ID32_LIB) : $(ID32_SOURCE)\r\n        $!\r\n        $! Building The $(ID32_LIB) Library.\r\n        $!\r\n        $ $(CC)$(ID32_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(NOVA_LIB) : $(NOVA_SOURCE)\r\n        $!\r\n        $! Building The $(NOVA_LIB) Library.\r\n        $!\r\n        $ $(CC)$(NOVA_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP1_LIB) : $(PDP1_SOURCE)\r\n        $!\r\n        $! Building The $(PDP1_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP1_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP4_LIB) : $(PDP18B_SOURCE)\r\n        $!\r\n        $! Building The $(PDP4_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP4_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP7_LIB) : $(PDP18B_SOURCE)\r\n        $!\r\n        $! Building The $(PDP7_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP7_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP8_LIB) : $(PDP8_SOURCE)\r\n        $!\r\n        $! Building The $(PDP8_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP8_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP9_LIB) : $(PDP18B_SOURCE)\r\n        $!\r\n        $! Building The $(PDP9_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP9_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The PDP-10, PDP-6, PDP-10-KA, PDP-10-KI Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(PDP10_LIB) : $(PDP10_SOURCE)\r\n        $!\r\n        $! Building The $(PDP10_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP10_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP6_LIB) : $(PDP6_SOURCE)\r\n        $!\r\n        $! Building The $(PDP10_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP6_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(KA10_LIB) : $(KA10_SOURCE)\r\n        $!\r\n        $! Building The $(KA10_LIB) Library.\r\n        $!\r\n        $ $(CC)$(KA10_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(KI10_LIB) : $(KI10_SOURCE)\r\n        $!\r\n        $! Building The $(KI10_LIB) Library.\r\n        $!\r\n        $ $(CC)$(KI10_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(PDP10_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n\r\n$(PDP6_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n\r\n$(KA10_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n\r\n$(KI10_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n$(PDP11_LIB1) : $(PDP11_SOURCE1)\r\n        $!\r\n        $! Building The $(PDP11_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(PDP11_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP11_LIB2) : $(PDP11_SOURCE2)\r\n        $!\r\n        $! Building The $(PDP11_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(PDP11_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PDP15_LIB) : $(PDP18B_SOURCE)\r\n        $!\r\n        $! Building The $(PDP15_LIB) Library.\r\n        $!\r\n        $ $(CC)$(PDP15_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(S3_LIB) : $(S3_SOURCE)\r\n        $!\r\n        $! Building The $(S3_LIB) Library.\r\n        $!\r\n        $ $(CC)$(S3_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(SDS_LIB) : $(SDS_SOURCE)\r\n        $!\r\n        $! Building The $(SDS_LIB) Library.\r\n        $!\r\n        $ $(CC)$(SDS_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(SSEM_LIB) : $(SSEM_SOURCE)\r\n        $!\r\n        $! Building The $(SSEM_LIB) Library.\r\n        $!\r\n        $ $(CC)$(SSEM_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(SWTP6800MP_A_LIB) : $(SWTP6800MP_A_SOURCE)\r\n        $!\r\n        $! Building The $(SWTP6800MP_A_LIB) Library.\r\n        $!\r\n        $ $(CC)$(SWTP6800MP_A_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(SWTP6800MP_A2_LIB) : $(SWTP6800MP_A2_SOURCE)\r\n        $!\r\n        $! Building The $(SWTP6800MP_A2_LIB) Library.\r\n        $!\r\n        $ $(CC)$(SWTP6800MP_A2_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The BESM6 Library.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(BESM6_LIB) : $(BESM6_SOURCE)\r\n        $!\r\n        $! Building The $(BESM6_LIB) Library.\r\n        $!\r\n        $ $(CC)$(BESM6_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(BESM6_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n#\r\n# If Not On VAX, Build The Burroughs B5500 Library.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(B5500_LIB) : $(B5500_SOURCE)\r\n        $!\r\n        $! Building The $(B5500_LIB) Library.\r\n        $!\r\n        $ $(CC)$(B5500_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(B5500_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n#\r\n# If Not On VAX, Build The CDC 1700 Library.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(CDC1700_LIB) : $(CDC1700_SOURCE)\r\n        $!\r\n        $! Building The $(CDC1700_LIB) Library.\r\n        $!\r\n        $ $(CC)$(CDC1700_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(CDC1700_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n$(VAX_LIB1) : $(VAX_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX_OPTIONS)/OBJ=$(VAX_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX_LIB2) : $(VAX_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX_OPTIONS)/OBJ=$(VAX_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX410_LIB1) : $(VAX410_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX410_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX410_OPTIONS)/OBJ=$(VAX410_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX410_LIB2) : $(VAX410_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX410_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX410_OPTIONS)/OBJ=$(VAX410_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX411_LIB1) : $(VAX411_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX411_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX411_OPTIONS)/OBJ=$(VAX411_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX411_LIB2) : $(VAX411_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX411_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX411_OPTIONS)/OBJ=$(VAX411_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX412_LIB1) : $(VAX412_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX412_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX412_OPTIONS)/OBJ=$(VAX412_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX412_LIB2) : $(VAX412_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX412_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX412_OPTIONS)/OBJ=$(VAX412_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX41A_LIB1) : $(VAX41A_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX41A_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX41A_OPTIONS)/OBJ=$(VAX41A_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX41A_LIB2) : $(VAX41A_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX41A_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX41A_OPTIONS)/OBJ=$(VAX41A_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX41D_LIB1) : $(VAX41D_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX41D_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX41D_OPTIONS)/OBJ=$(VAX41D_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX41D_LIB2) : $(VAX41D_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX41D_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX41D_OPTIONS)/OBJ=$(VAX41D_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX42A_LIB1) : $(VAX42A_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX42A_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX42A_OPTIONS)/OBJ=$(VAX42A_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX42A_LIB2) : $(VAX42A_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX42A_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX42A_OPTIONS)/OBJ=$(VAX42A_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX42B_LIB1) : $(VAX42B_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX42B_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX42B_OPTIONS)/OBJ=$(VAX42B_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX42B_LIB2) : $(VAX42B_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX42B_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX42B_OPTIONS)/OBJ=$(VAX42B_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX43_LIB1) : $(VAX43_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX43_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX43_OPTIONS)/OBJ=$(VAX43_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX43_LIB2) : $(VAX43_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX43_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX43_OPTIONS)/OBJ=$(VAX43_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX46_LIB1) : $(VAX46_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX46_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX46_OPTIONS)/OBJ=$(VAX46_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX46_LIB2) : $(VAX46_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX46_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX46_OPTIONS)/OBJ=$(VAX46_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX47_LIB1) : $(VAX47_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX47_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX47_OPTIONS)/OBJ=$(VAX47_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX47_LIB2) : $(VAX47_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX47_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX47_OPTIONS)/OBJ=$(VAX47_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX48_LIB1) : $(VAX48_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX48_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX48_OPTIONS)/OBJ=$(VAX48_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX48_LIB2) : $(VAX48_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX48_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX48_OPTIONS)/OBJ=$(VAX48_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(IS1000_LIB1) : $(IS1000_SOURCE1)\r\n        $!\r\n        $! Building The $(IS1000_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(IS1000_OPTIONS)/OBJ=$(IS1000_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(IS1000_LIB2) : $(IS1000_SOURCE2)\r\n        $!\r\n        $! Building The $(IS1000_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(IS1000_OPTIONS)/OBJ=$(IS1000_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX610_LIB1) : $(VAX610_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX610_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX610_OPTIONS)/OBJ=$(VAX610_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX610_LIB2) : $(VAX610_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX610_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX610_OPTIONS)/OBJ=$(VAX610_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX630_LIB1) : $(VAX630_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX630_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX630_OPTIONS)/OBJ=$(VAX630_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX630_LIB2) : $(VAX630_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX630_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX630_OPTIONS)/OBJ=$(VAX630_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX620_LIB1) : $(VAX620_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX620_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX620_OPTIONS)/OBJ=$(VAX620_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX620_LIB2) : $(VAX620_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX620_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX620_OPTIONS)/OBJ=$(VAX620_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX730_LIB1) : $(VAX730_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX730_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX730_OPTIONS)/OBJ=$(VAX730_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX730_LIB2) : $(VAX730_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX730_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX730_OPTIONS)/OBJ=$(VAX730_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX750_LIB1) : $(VAX750_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX750_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX750_OPTIONS)/OBJ=$(VAX750_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX750_LIB2) : $(VAX750_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX750_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX750_OPTIONS)/OBJ=$(VAX750_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX780_LIB1) : $(VAX780_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX780_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX780_OPTIONS)/OBJ=$(VAX780_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX780_LIB2) : $(VAX780_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX780_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX780_OPTIONS)/OBJ=$(VAX780_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX8200_LIB1) : $(VAX8200_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX8200_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX8200_OPTIONS)/OBJ=$(VAX8200_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX8200_LIB2) : $(VAX8200_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX8200_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX8200_OPTIONS)/OBJ=$(VAX8200_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX8600_LIB1) : $(VAX8600_SOURCE1)\r\n        $!\r\n        $! Building The $(VAX8600_LIB1) Library.\r\n        $!\r\n        $ $(CC)$(VAX8600_OPTIONS)/OBJ=$(VAX8600_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(VAX8600_LIB2) : $(VAX8600_SOURCE2)\r\n        $!\r\n        $! Building The $(VAX8600_LIB2) Library.\r\n        $!\r\n        $ $(CC)$(VAX8600_OPTIONS)/OBJ=$(VAX8600_DIR) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n$(PCAP_LIB) : $(PCAP_SOURCE)\r\n        $!\r\n        $! Building The $(PCAP_LIB) Library.\r\n        $!\r\n        $ Saved_Default = F$Environment(\"DEFAULT\")\r\n        $ SET DEFAULT $(PCAP_DIR)\r\n        $ @VMS_PCAP $(DEBUG)\r\n        $ SET DEFAULT 'Saved_Default\r\n        $ IF (F$SEARCH(\"$(PCAP_LIB)\").NES.\"\") THEN -\r\n             DELETE $(PCAP_LIB);\r\n        $ COPY $(PCAP_DIR)PCAP.OLB $(PCAP_LIB)\r\n        $ DELETE/NOLOG/NOCONFIRM $(PCAP_DIR)*.OBJ;*,$(PCAP_DIR)*.OLB;*\r\n\r\n#\r\n# If Not On VAX, Build The IBM 7094 Library.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\n$(I7094_LIB) : $(I7094_SOURCE)\r\n        $!\r\n        $! Building The $(I7094_LIB) Library.\r\n        $!\r\n        $ $(CC)$(I7094_OPTIONS) -\r\n               /OBJ=$(BLD_DIR) $(MMS$CHANGED_LIST)\r\n        $ IF (F$SEARCH(\"$(MMS$TARGET)\").EQS.\"\") THEN -\r\n             LIBRARY/CREATE $(MMS$TARGET)\r\n        $ LIBRARY/REPLACE $(MMS$TARGET) $(BLD_DIR)*.OBJ\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# We Are On VAX And Due To The Use of INT64 We Can't Build It.\r\n#\r\n$(I7094_LIB) :\r\n        $! Due To The Use Of INT64 We Can't Build The\r\n        $! $(MMS$TARGET) Library On VAX.\r\n.ENDIF\r\n\r\n#\r\n# Individual Simulator Builds.\r\n#\r\n\r\n#\r\n# If Not On VAX, Build The AT&T 3B2 Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nATT3B2 : $(BIN_DIR)ATT3B2-$(ARCH).EXE\r\n        $! ATT3B2 aka 3B2 done\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nATT3B2 :\r\n        $! Sorry, Can't Build $(BIN_DIR)ATT3B2-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\n$(BIN_DIR)ATT3B2-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(ATT3B2_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)ATT3B2-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(ATT3B2_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)ATT3B2-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(ATT3B2_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n        $ COPY $(BIN_DIR)ATT3B2-$(ARCH).EXE $(BIN_DIR)3B2-$(ARCH).EXE\r\n\r\nALTAIR : $(BIN_DIR)ALTAIR-$(ARCH).EXE\r\n        $! ALTAIR done\r\n\r\n$(BIN_DIR)ALTAIR-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(ALTAIR_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)ALTAIR-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(ALTAIR_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)ALTAIR-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(ALTAIR_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The AltairZ80 Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nALTAIRZ80 : $(BIN_DIR)ALTAIRZ80-$(ARCH).EXE\r\n        $! ALTAIRZ80 done\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nALTAIRZ80 :\r\n        $! Sorry, Can't Build $(BIN_DIR)ALTAIRZ80-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\n$(BIN_DIR)ALTAIRZ80-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(ALTAIRZ80_LIB1) $(ALTAIRZ80_LIB2)\r\n        $!\r\n        $! Building The $(BIN_DIR)ALTAIRZ80-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(ALTAIRZ80_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)ALTAIRZ80-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(ALTAIRZ80_LIB1)/LIBRARY, -\r\n               $(ALTAIRZ80_LIB2)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The Eclipse Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nECLIPSE : $(BIN_DIR)ECLIPSE-$(ARCH).EXE\r\n        $! ECLIPSE done\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nECLIPSE :\r\n        $! Sorry, Can't Build $(BIN_DIR)ECLIPSE-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\n$(BIN_DIR)ECLIPSE-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(ECLIPSE_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)ECLIPSE-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(ECLIPSE_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)ECLIPSE-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(ECLIPSE_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nGRI : $(BIN_DIR)GRI-$(ARCH).EXE\r\n        $! GRI done\r\n\r\n$(BIN_DIR)GRI-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(GRI_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)GRI-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(GRI_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)GRI-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(GRI_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nLGP : $(BIN_DIR)LGP-$(ARCH).EXE\r\n        $! LGP done\r\n\r\n$(BIN_DIR)LGP-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(LGP_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)LGP-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(LGP_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)LGP-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(LGP_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nH316 : $(BIN_DIR)H316-$(ARCH).EXE\r\n        $! H316 done\r\n\r\n$(BIN_DIR)H316-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(H316_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)H316-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(H316_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)H316-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(H316_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nHP2100 : $(BIN_DIR)HP2100-$(ARCH).EXE\r\n        $! HP2100 done\r\n\r\n$(BIN_DIR)HP2100-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(HP2100_LIB1) $(HP2100_LIB2)\r\n        $!\r\n        $! Building The $(BIN_DIR)HP2100-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(HP2100_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)HP2100-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(HP2100_LIB1)/LIBRARY, -\r\n               $(HP2100_LIB2)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nHP3000 : $(BIN_DIR)HP3000-$(ARCH).EXE\r\n        $! HP3000 done\r\n\r\n$(BIN_DIR)HP3000-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(HP3000_LIB1) $(HP3000_LIB2)\r\n        $!\r\n        $! Building The $(BIN_DIR)HP3000-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(HP3000_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)HP3000-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(HP3000_LIB1)/LIBRARY, -\r\n               $(HP3000_LIB2)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nI1401 : $(BIN_DIR)I1401-$(ARCH).EXE\r\n        $! I1401 done\r\n\r\n$(BIN_DIR)I1401-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(I1401_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)I1401-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(I1401_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)I1401-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(I1401_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nI1620 : $(BIN_DIR)I1620-$(ARCH).EXE\r\n        $! I1620 done\r\n\r\n$(BIN_DIR)I1620-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(I1620_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)I1620-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(I1620_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)I1620-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(I1620_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nIBM1130 : $(BIN_DIR)IBM1130-$(ARCH).EXE\r\n        $! IBM1130 done\r\n\r\n$(BIN_DIR)IBM1130-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(IBM1130_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)IBM1130-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(IBM1130_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)IBM1130-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(IBM1130_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nID16 : $(BIN_DIR)ID16-$(ARCH).EXE\r\n        $! ID16 done\r\n\r\n$(BIN_DIR)ID16-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(ID16_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)ID16-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(ID16_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)ID16-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(ID16_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nID32 : $(BIN_DIR)ID32-$(ARCH).EXE\r\n        $! ID32 done\r\n\r\n$(BIN_DIR)ID32-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(ID32_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)ID32-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(ID32_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)ID32-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(ID32_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nNOVA : $(BIN_DIR)NOVA-$(ARCH).EXE\r\n        $! NOVA done\r\n\r\n$(BIN_DIR)NOVA-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(NOVA_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)NOVA-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(NOVA_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)NOVA-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(NOVA_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP1 : $(BIN_DIR)PDP1-$(ARCH).EXE\r\n        $! PDP1 done\r\n\r\n$(BIN_DIR)PDP1-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PDP1_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP1-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP1_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP1-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP1_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP4 : $(BIN_DIR)PDP4-$(ARCH).EXE\r\n        $! PDP4 done\r\n\r\n$(BIN_DIR)PDP4-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PDP4_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP4-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP4_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP4-$(ARCH).EXE -\r\n              $(BLD_DIR)SCP.OBJ,$(PDP4_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP7 : $(BIN_DIR)PDP7-$(ARCH).EXE\r\n        $! PDP7 done\r\n\r\n$(BIN_DIR)PDP7-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PDP7_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP7-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP7_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP7-$(ARCH).EXE -\r\n              $(BLD_DIR)SCP.OBJ,$(PDP7_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP8 : $(BIN_DIR)PDP8-$(ARCH).EXE\r\n        $! PDP8 done\r\n\r\n$(BIN_DIR)PDP8-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PDP8_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP8-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP8_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP8-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP8_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP9 : $(BIN_DIR)PDP9-$(ARCH).EXE\r\n        $! PDP9 done\r\n\r\n$(BIN_DIR)PDP9-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PDP9_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP9-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP9_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP9-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP9_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The PDP-10, PDP-6, PDP-10-KA, PDP-10-KI Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nPDP10 : $(BIN_DIR)PDP10-$(ARCH).EXE\r\n        $! PDP10 done\r\n\r\n$(BIN_DIR)PDP10-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PCAP_LIBD) $(PDP10_LIB) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP10-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP10_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP10-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP10_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP6 : $(BIN_DIR)PDP6-$(ARCH).EXE\r\n        $! PDP6 done\r\n\r\n$(BIN_DIR)PDP6-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PCAP_LIBD) $(PDP6_LIB) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP6-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP6_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP6-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP6_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP10-KA : $(BIN_DIR)PDP10-KA-$(ARCH).EXE\r\n        $! PDP10-KA done\r\n\r\n$(BIN_DIR)PDP10-KA-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PCAP_LIBD) $(KA10_LIB) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP10-KA-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(KA10_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP10-KA-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(KA10_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP10-KI : $(BIN_DIR)PDP10-KI-$(ARCH).EXE\r\n        $! PDP10-KI done\r\n\r\n$(BIN_DIR)PDP10-KI-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PCAP_LIBD) $(KI10_LIB) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP10-KI-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(KI10_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP10-KI-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(KI10_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nPDP10 :\r\n        $! Sorry, Can't Build $(BIN_DIR)PDP10-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n\r\nPDP6 :\r\n        $! Sorry, Can't Build $(BIN_DIR)PDP6-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n\r\nPDP10-KA :\r\n        $! Sorry, Can't Build $(BIN_DIR)PDP10-KA-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n\r\nPDP10-KI :\r\n        $! Sorry, Can't Build $(BIN_DIR)PDP10-KI-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\nPDP11 : $(BIN_DIR)PDP11-$(ARCH).EXE\r\n        $! PDP11 done\r\n\r\n$(BIN_DIR)PDP11-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_LIB) $(PCAP_LIBD) $(PDP11_LIB1) $(PDP11_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP11-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP11_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP11-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP11_LIB1)/LIBRARY,$(PDP11_LIB2)/LIBRARY,$(SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nPDP15 : $(BIN_DIR)PDP15-$(ARCH).EXE\r\n        $! PDP15 done\r\n\r\n$(BIN_DIR)PDP15-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(PDP15_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)PDP15-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(PDP15_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)PDP15-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(PDP15_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nS3 : $(BIN_DIR)S3-$(ARCH).EXE\r\n        $! S3 done\r\n\r\n$(BIN_DIR)S3-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(S3_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)S3-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(S3_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)S3-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(S3_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nSDS : $(BIN_DIR)SDS-$(ARCH).EXE\r\n        $! SDS done\r\n\r\n$(BIN_DIR)SDS-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(SDS_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)SDS-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(SDS_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)SDS-$(ARCH).EXE -\r\n                 $(BLD_DIR)SCP.OBJ,$(SDS_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nSSEM : $(BIN_DIR)SSEM-$(ARCH).EXE\r\n        $! SSEM done\r\n\r\n$(BIN_DIR)SSEM-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(SSEM_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)SSEM-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(SSEM_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)SSEM-$(ARCH).EXE -\r\n                 $(BLD_DIR)SCP.OBJ,$(SDS_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nSWTP6800MP-A : $(BIN_DIR)SWTP6800MP-A-$(ARCH).EXE\r\n        $! SWTP6800MP-A done\r\n\r\n$(BIN_DIR)SWTP6800MP-A-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(SWTP6800MP_A_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)SWTP6800MP-A-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(SWTP6800MP_A_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)SWTP6800MP-A-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(SWTP6800MP_A_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nSWTP6800MP-A2 : $(BIN_DIR)SWTP6800MP-A2-$(ARCH).EXE\r\n        $! SWTP6800MP-A2 done\r\n\r\n$(BIN_DIR)SWTP6800MP-A2-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(SWTP6800MP_A2_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)SWTP6800MP-A2-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(SWTP6800MP_A2_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)SWTP6800MP-A2-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(SWTP6800MP_A2_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The BESM6 Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nBESM6 : $(BIN_DIR)BESM6-$(ARCH).EXE\r\n        $! BESM6 done\r\n\r\n$(BIN_DIR)BESM6-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(BESM6_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)BESM6-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(BESM6_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)BESM6-$(ARCH).EXE -\r\n                 $(BLD_DIR)SCP.OBJ,$(BESM6_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nBESM6 :\r\n        $! Sorry, Can't Build $(BIN_DIR)BESM6-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\n\r\n#\r\n# If Not On VAX, Build The Burroughs B5500 Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nB5500 : $(BIN_DIR)B5500-$(ARCH).EXE\r\n        $! B5500 done\r\n\r\n$(BIN_DIR)B5500-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(B5500_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)B5500-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(B5500_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)B5500-$(ARCH).EXE -\r\n                 $(BLD_DIR)SCP.OBJ,$(B5500_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nB5500 :\r\n        $! Sorry, Can't Build $(BIN_DIR)B5500-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\n\r\n#\r\n# If Not On VAX, Build The Burroughs B5500 Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nCDC1700 : $(BIN_DIR)CDC1700-$(ARCH).EXE\r\n        $! CDC1700 done\r\n\r\n$(BIN_DIR)CDC1700-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(CDC1700_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)CDC1700-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(CDC1700_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)CDC1700-$(ARCH).EXE -\r\n                 $(BLD_DIR)SCP.OBJ,$(CDC1700_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nCDC1700 :\r\n        $! Sorry, Can't Build $(BIN_DIR)CDC1700-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\nVAX : MICROVAX3900\r\n        $! MICROVAX3900 aka VAX done\r\n\r\nMICROVAX3900 : $(BIN_DIR)MICROVAX3900-$(ARCH).EXE\r\n        $! MICROVAX3900 done\r\n\r\n$(BIN_DIR)MICROVAX3900-$(ARCH).EXE : $(SIMH_MAIN) $(VAX_SIMH_LIB) $(PCAP_LIBD) $(VAX_LIB1) $(VAX_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)MICROVAX3900-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(VAX_LIB1)/LIBRARY,$(VAX_LIB2)/LIBRARY,-\r\n               $(VAX_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n        $ COPY $(BIN_DIR)MICROVAX3900-$(ARCH).EXE $(BIN_DIR)VAX-$(ARCH).EXE\r\n\r\nMICROVAX2000 : $(BIN_DIR)MICROVAX2000-$(ARCH).EXE\r\n        $! MICROVAX2000 done\r\n\r\n$(BIN_DIR)MICROVAX2000-$(ARCH).EXE : $(SIMH_MAIN) $(VAX410_SIMH_LIB) $(PCAP_LIBD) $(VAX410_LIB1) $(VAX410_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)MICROVAX2000-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX410_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)MICROVAX2000-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX410_LIB1)/LIBRARY,$(VAX410_LIB2)/LIBRARY,-\r\n               $(VAX410_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nINFOSERVER100 : $(BIN_DIR)INFOSERVER100-$(ARCH).EXE\r\n        $! INFOSERVER100 done\r\n\r\n$(BIN_DIR)INFOSERVER100-$(ARCH).EXE : $(SIMH_MAIN) $(VAX411_SIMH_LIB) $(PCAP_LIBD) $(VAX411_LIB1) $(VAX411_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)INFOSERVER100-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX411_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)INFOSERVER100-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX411_LIB1)/LIBRARY,$(VAX411_LIB2)/LIBRARY,-\r\n               $(VAX411_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nINFOSERVER150VXT : $(BIN_DIR)INFOSERVER150VXT-$(ARCH).EXE\r\n        $! INFOSERVER150VXT done\r\n\r\n$(BIN_DIR)INFOSERVER150VXT-$(ARCH).EXE : $(SIMH_MAIN) $(VAX412_SIMH_LIB) $(PCAP_LIBD) $(VAX412_LIB1) $(VAX412_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)INFOSERVER150VXT-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX412_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)INFOSERVER150VXT-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX412_LIB1)/LIBRARY,$(VAX412_LIB2)/LIBRARY,-\r\n               $(VAX412_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nMICROVAX3100 : $(BIN_DIR)MICROVAX3100-$(ARCH).EXE\r\n        $! MICROVAX3100 done\r\n\r\n$(BIN_DIR)MICROVAX3100-$(ARCH).EXE : $(SIMH_MAIN) $(VAX41A_SIMH_LIB) $(PCAP_LIBD) $(VAX41A_LIB1) $(VAX41A_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)MICROVAX3100-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX41A_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)MICROVAX3100-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX41A_LIB1)/LIBRARY,$(VAX41A_LIB2)/LIBRARY,-\r\n               $(VAX41A_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nMICROVAX3100E : $(BIN_DIR)MICROVAX3100E-$(ARCH).EXE\r\n        $! MICROVAX3100E done\r\n\r\n$(BIN_DIR)MICROVAX3100E-$(ARCH).EXE : $(SIMH_MAIN) $(VAX41D_SIMH_LIB) $(PCAP_LIBD) $(VAX41D_LIB1) $(VAX41D_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)MICROVAX3100E-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX41D_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)MICROVAX3100E-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX41D_LIB1)/LIBRARY,$(VAX41D_LIB2)/LIBRARY,-\r\n               $(VAX41D_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAXSTATION3100M30 : $(BIN_DIR)VAXSTATION3100M30-$(ARCH).EXE\r\n        $! VAXSTATION3100M30 done\r\n\r\n$(BIN_DIR)VAXSTATION3100M30-$(ARCH).EXE : $(SIMH_MAIN) $(VAX42A_SIMH_LIB) $(PCAP_LIBD) $(VAX42A_LIB1) $(VAX42A_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAXSTATION3100M30-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX42A_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAXSTATION3100M30-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX42A_LIB1)/LIBRARY,$(VAX42A_LIB2)/LIBRARY,-\r\n               $(VAX42A_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAXSTATION3100M38 : $(BIN_DIR)VAXSTATION3100M38-$(ARCH).EXE\r\n        $! VAXSTATION3100M38 done\r\n\r\n$(BIN_DIR)VAXSTATION3100M38-$(ARCH).EXE : $(SIMH_MAIN) $(VAX42B_SIMH_LIB) $(PCAP_LIBD) $(VAX42B_LIB1) $(VAX42B_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAXSTATION3100M38-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX42B_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAXSTATION3100M38-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX42B_LIB1)/LIBRARY,$(VAX42B_LIB2)/LIBRARY,-\r\n               $(VAX42B_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAXSTATION3100M76 : $(BIN_DIR)VAXSTATION3100M76-$(ARCH).EXE\r\n        $! VAXSTATION3100M76 done\r\n\r\n$(BIN_DIR)VAXSTATION3100M76-$(ARCH).EXE : $(SIMH_MAIN) $(VAX43_SIMH_LIB) $(PCAP_LIBD) $(VAX43_LIB1) $(VAX43_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAXSTATION3100M76-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX43_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAXSTATION3100M76-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX43_LIB1)/LIBRARY,$(VAX43_LIB2)/LIBRARY,-\r\n               $(VAX43_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAXSTATION4000M60 : $(BIN_DIR)VAXSTATION4000M60-$(ARCH).EXE\r\n        $! VAXSTATION4000M60 done\r\n\r\n$(BIN_DIR)VAXSTATION4000M60-$(ARCH).EXE : $(SIMH_MAIN) $(VAX46_SIMH_LIB) $(PCAP_LIBD) $(VAX46_LIB1) $(VAX46_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAXSTATION4000M60-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX46_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAXSTATION4000M60-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX46_LIB1)/LIBRARY,$(VAX46_LIB2)/LIBRARY,-\r\n               $(VAX46_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAXSTATION3100M80 : $(BIN_DIR)VAXSTATION3100M80-$(ARCH).EXE\r\n        $! VAXSTATION3100M80 done\r\n\r\n$(BIN_DIR)VAXSTATION3100M80-$(ARCH).EXE : $(SIMH_MAIN) $(VAX47_SIMH_LIB) $(PCAP_LIBD) $(VAX47_LIB1) $(VAX47_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAXSTATION3100M80-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX47_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAXSTATION3100M80-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX47_LIB1)/LIBRARY,$(VAX47_LIB2)/LIBRARY,-\r\n               $(VAX47_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAXSTATION4000VLC : $(BIN_DIR)VAXSTATION4000VLC-$(ARCH).EXE\r\n        $! VAXSTATION4000VLC done\r\n\r\n$(BIN_DIR)VAXSTATION4000VLC-$(ARCH).EXE : $(SIMH_MAIN) $(VAX48_SIMH_LIB) $(PCAP_LIBD) $(VAX48_LIB1) $(VAX48_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAXSTATION4000VLC-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX48_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAXSTATION4000VLC-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX48_LIB1)/LIBRARY,$(VAX48_LIB2)/LIBRARY,-\r\n               $(VAX48_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nINFOSERVER1000 : $(BIN_DIR)INFOSERVER1000-$(ARCH).EXE\r\n        $! INFOSERVER1000 done\r\n\r\n$(BIN_DIR)INFOSERVER1000-$(ARCH).EXE : $(SIMH_MAIN) $(IS1000_SIMH_LIB) $(PCAP_LIBD) $(IS1000_LIB1) $(IS1000_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)INFOSERVER1000-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(IS1000_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)INFOSERVER1000-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(IS1000_LIB1)/LIBRARY,$(IS1000_LIB2)/LIBRARY,-\r\n               $(IS1000_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nMICROVAX1 : $(BIN_DIR)MICROVAX1-$(ARCH).EXE\r\n        $! MICROVAX1 done\r\n\r\n$(BIN_DIR)MICROVAX1-$(ARCH).EXE : $(SIMH_MAIN) $(VAX610_SIMH_LIB) $(PCAP_LIBD) $(VAX610_LIB1) $(VAX610_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX610-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX610_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)MICROVAX1-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX610_LIB1)/LIBRARY,$(VAX610_LIB2)/LIBRARY,-\r\n               $(VAX610_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nMICROVAX2 : $(BIN_DIR)MICROVAX2-$(ARCH).EXE\r\n        $! MICROVAX2 done\r\n\r\n$(BIN_DIR)MICROVAX2-$(ARCH).EXE : $(SIMH_MAIN) $(VAX630_SIMH_LIB) $(PCAP_LIBD) $(VAX630_LIB1) $(VAX630_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX630-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX630_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)MICROVAX2-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX630_LIB1)/LIBRARY,$(VAX630_LIB2)/LIBRARY,-\r\n               $(VAX630_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nRTVAX1000 : $(BIN_DIR)RTVAX1000-$(ARCH).EXE\r\n        $! RTVAX1000 done\r\n\r\n$(BIN_DIR)RTVAX1000-$(ARCH).EXE : $(SIMH_MAIN) $(VAX620_SIMH_LIB) $(PCAP_LIBD) $(VAX620_LIB1) $(VAX620_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX620-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX620_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)RTVAX1000-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX620_LIB1)/LIBRARY,$(VAX620_LIB2)/LIBRARY,-\r\n               $(VAX620_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAX730 : $(BIN_DIR)VAX730-$(ARCH).EXE\r\n        $! VAX730 done\r\n\r\n$(BIN_DIR)VAX730-$(ARCH).EXE : $(SIMH_MAIN) $(VAX730_SIMH_LIB) $(PCAP_LIBD) $(VAX730_LIB1) $(VAX730_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX730-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX730_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAX730-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX730_LIB1)/LIBRARY,$(VAX730_LIB2)/LIBRARY,-\r\n               $(VAX730_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAX750 : $(BIN_DIR)VAX750-$(ARCH).EXE\r\n        $! VAX750 done\r\n\r\n$(BIN_DIR)VAX750-$(ARCH).EXE : $(SIMH_MAIN) $(VAX750_SIMH_LIB) $(PCAP_LIBD) $(VAX750_LIB1) $(VAX750_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX750-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX750_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAX750-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX750_LIB1)/LIBRARY,$(VAX750_LIB2)/LIBRARY,-\r\n               $(VAX750_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAX780 : $(BIN_DIR)VAX780-$(ARCH).EXE\r\n        $! VAX780 done\r\n\r\n$(BIN_DIR)VAX780-$(ARCH).EXE : $(SIMH_MAIN) $(VAX780_SIMH_LIB) $(PCAP_LIBD) $(VAX780_LIB1) $(VAX780_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX780-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX780_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAX780-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX780_LIB1)/LIBRARY,$(VAX780_LIB2)/LIBRARY,-\r\n               $(VAX780_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAX8200 : $(BIN_DIR)VAX8200-$(ARCH).EXE\r\n        $! VAX8200 done\r\n\r\n$(BIN_DIR)VAX8200-$(ARCH).EXE : $(SIMH_MAIN) $(VAX8200_SIMH_LIB) $(PCAP_LIBD) $(VAX8200_LIB1) $(VAX8200_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX8200-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX8200_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAX8200-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX8200_LIB1)/LIBRARY,$(VAX8200_LIB2)/LIBRARY,-\r\n               $(VAX8200_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\nVAX8600 : $(BIN_DIR)VAX8600-$(ARCH).EXE\r\n        $! VAX8600 done\r\n\r\n$(BIN_DIR)VAX8600-$(ARCH).EXE : $(SIMH_MAIN) $(VAX8600_SIMH_LIB) $(PCAP_LIBD) $(VAX8600_LIB1) $(VAX8600_LIB2) $(PCAP_EXECLET)\r\n        $!\r\n        $! Building The $(BIN_DIR)VAX8600-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(VAX8600_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)$(LINK_SECTION_BINDING)-\r\n               /EXE=$(BIN_DIR)VAX8600-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,-\r\n               $(VAX8600_LIB1)/LIBRARY,$(VAX8600_LIB2)/LIBRARY,-\r\n               $(VAX8600_SIMH_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n\r\n#\r\n# If Not On VAX, Build The IBM 7094 Simulator.\r\n#\r\n.IFDEF ALPHA_OR_IA64\r\nI7094 : $(BIN_DIR)I7094-$(ARCH).EXE\r\n        $! I7094 done\r\n\r\n$(BIN_DIR)I7094-$(ARCH).EXE : $(SIMH_MAIN) $(SIMH_NONET_LIB) $(I7094_LIB)\r\n        $!\r\n        $! Building The $(BIN_DIR)I7094-$(ARCH).EXE Simulator.\r\n        $!\r\n        $ $(CC)$(I7094_OPTIONS)/OBJ=$(BLD_DIR) SCP.C\r\n        $ LINK $(LINK_DEBUG)/EXE=$(BIN_DIR)I7094-$(ARCH).EXE -\r\n               $(BLD_DIR)SCP.OBJ,$(I7094_LIB)/LIBRARY,$(SIMH_NONET_LIB)/LIBRARY$(PCAP_LIBR)\r\n        $ DELETE/NOLOG/NOCONFIRM $(BLD_DIR)*.OBJ;*\r\n.ELSE\r\n#\r\n# Else We Are On VAX And Tell The User We Can't Build On VAX\r\n# Due To The Use Of INT64.\r\n#\r\nI7094 :\r\n        $! Sorry, Can't Build $(BIN_DIR)I7094-$(ARCH).EXE Simulator\r\n        $! Because It Requires The Use Of INT64.\r\n.ENDIF\r\n\r\n#\r\n# PCAP VCI Components\r\n#\r\n$(PCAP_VCI) : $(PCAP_VCMDIR)PCAPVCM.EXE\r\n        $!\r\n        $! Installing the PCAP VCI Execlet in SYS$LOADABLE_IMAGES\r\n        $!\r\n        $ COPY $(PCAP_VCMDIR)PCAPVCM.EXE SYS$COMMON:[SYS$LDR]PCAPVCM.EXE\r\n\r\n$(PCAP_VCMDIR)PCAPVCM.EXE : $(PCAP_VCM_SOURCES)\r\n        $!\r\n        $! Building The PCAP VCI Execlet\r\n        $!\r\n        $ @SYS$DISK:[-.PCAP-VMS.PCAPVCM]BUILD_PCAPVCM\r\n        $ DELETE/NOLOG/NOCONFIRM $(PCAP_VCMDIR)*.OBJ;*,$(PCAP_VCMDIR)*.MAP;*\r\n"
        },
        {
          "name": "display",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "frontpanel",
          "type": "tree",
          "content": null
        },
        {
          "name": "helpx",
          "type": "blob",
          "size": 13.6259765625,
          "content": "#!/usr/bin/perl\r\n\r\n# Extract utility for SimH help text\r\n\r\n\r\n#  Copyright (c) 2013, Timothe Litt\r\n\r\n#  Permission is hereby granted, free of charge, to any person obtaining a\r\n#  copy of this software and associated documentation files (the \"Software\"),\r\n#  to deal in the Software without restriction, including without limitation\r\n#  the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n#  and/or sell copies of the Software, and to permit persons to whom the\r\n#  Software is furnished to do so, subject to the following conditions:\r\n\r\n#  The above copyright notice and this permission notice shall be included in\r\n#  all copies or substantial portions of the Software.\r\n\r\n#  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n#  THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n#  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n#  Except as contained in this notice, the name of the author shall not be\r\n#  used in advertising or otherwise to promote the sale, use or other dealings\r\n#  in this Software without prior written authorization from the author.\r\n\r\nuse warnings;\r\nuse strict;\r\n\r\n# This utility attempts to read the C source of an emulator device and convert\r\n# its help function to the structured help format.  Manual editing of the result\r\n# will be required, but the mechanical work is done by the tool.\r\n#\r\n# A template for organizing the help into standard topics/subtopics is inserted\r\n# along with the translation.  At this writing, everything is experimental, so\r\n# the 'standard' format may change.  Nonetheless, this is suitable for experimentation.\r\n\r\nuse File::Basename;\r\n\r\nmy $prg = basename $0;\r\n\r\nmy $rtn;\r\nmy $ifn = '-';\r\nmy $ofn = '-';\r\nmy $line;\r\nmy $update;\r\n\r\nwhile (@ARGV) {\r\n    if( $ARGV[0] eq '--' ) {\r\n\tlast;\r\n    }\r\n    if( $ARGV[0] eq '-dev' ) {\r\n\tshift;\r\n\t$rtn = shift;\r\n\t$rtn .= \"_help\";\r\n\tnext;\r\n    }\r\n    if( $ARGV[0] eq '-u' ) {\r\n\t$update = 1;\r\n\tshift;\r\n\tnext;\r\n    }\r\n    last if( $ARGV[0] !~ /^-/ );\r\n\r\n    printf STDERR << \"USAGE_\";\r\nUsage:\r\n$prg -u -dev devname -func rtn infile outfile\r\n\r\ndevname is used to look for the existing help function name.\r\nE.g. if the routine is cr_help, use -dev cr.\r\n\r\nAlternatively, use -func to specify the full function name.\r\n\r\ninfile and outfile default to - (stdin and stdout)\r\n\r\n$prg will attempt to produce a sensible device help string, although you\r\nshould expect that the result will require manual editing.  Complex C\r\nconstructs (preprocessor conditionals, if statements that generate strings)\r\nare not automatically translated, but the old code will be preserved.\r\n\r\nHowever, as it may have been partially translated, the result may not compile.\r\n\r\nA template is installed so that you can move your information into the standard\r\nsections.\r\n\r\nSource code in the help function is reformatted - not to any particular\r\nstyle, but as a consequence of how it is tokenized and parsed.  Use your\r\nfavorite pretty-printer if you don't like the results.\r\n\r\nNormally, just the help function is output.  -u will output the entire file\r\n(-u = \"update\")\r\n\r\nUSAGE_\r\n\r\n    exit (0);\r\n}\r\n\r\nunless( defined $rtn ) {\r\n    die \"The help function must be specified with -func or -dev; -help for usage\\n\";\r\n}\r\n\r\nif( @ARGV ) {\r\n    $ifn = shift;\r\n}\r\nif( @ARGV ) {\r\n    $ofn = shift;\r\n}\r\n\r\nopen( STDIN, \"<$ifn\" ) or\r\n    die \"Unable to open $ifn for input: $!\\n\";\r\n\r\nopen( STDOUT, \">$ofn\" ) or\r\n    die \"Unable to open $ofn for output: $!\\n\";\r\n\r\n$line = \"\";\r\nwhile( <STDIN> ) {\r\n\r\n    # Look for the help function\r\n    if( /^(?:static\\s+)?t_stat\\s+$rtn\\s*\\(/ ) {\r\n\t$line = $_;\r\n\twhile( $line !~ /\\{/ && $line !~ /\\)\\s*;/ ) {\r\n\t    my $cont = <STDIN>;\r\n\t    if( !defined $cont ) {\r\n\t\tdie \"EOF in function definition\\n\";\r\n\t    }\r\n\t    $line .= $cont;\r\n\t}\r\n\tif( $line =~ /\\)\\s*;/ ) { # Just a prototype\r\n\t    if( $update ) {\r\n\t\tprint $line;\r\n\t    }\r\n\t    $line = \"\";\r\n\t    next;\r\n\t}\r\n\t# Process the function body\r\n\tmy $f = $line;\r\n\tmy $b = '';\r\n\tmy $bl = 1;\r\n\tmy( %vargs, @vargs );\r\n\tmy $help = '';\r\n\tmy $comments = '';\r\n\r\n\t# Each statement in the body\r\n\twhile (1) {\r\n\t    my ($tok, $val) = gettok();\r\n\t    last if( !defined $tok );\r\n\r\n\t    if ($tok eq '{') {                  # Track brace level\r\n\t\t$bl++;\r\n\t\t$b .= $tok;\r\n\t    } elsif ($tok eq '}') {\r\n\t\tdie \"Unmatched }\\n\" if ( --$bl < 0 );\r\n\t\t$b .= $tok;\r\n\t\tlast if (!$bl);                # End of function\r\n\t    } elsif ($tok eq 'word' && $val eq 'fprintf') {\r\n\t\t# fprintf ( st, \"string\" ,args );\r\n\t\t# Save embedded comments, but don't confuse the parse.\r\n\t\t($tok, $val) = gettok(\\$comments);\r\n\t\tif( $tok ne '(' ) {\r\n\t\t    $b .= \" $val\";\r\n\t\t    next;\r\n\t\t}\r\n\t\t($tok, $val) = gettok(\\$comments);\r\n\t\tif( $tok ne 'word' || $val ne 'st' ) {\r\n\t\t    $b .= \"fprintf ($val\";\r\n\t\t    next;\r\n\t\t}\r\n\t\t($tok, $val) = gettok(\\$comments);\r\n\t\tif( $tok ne ',' ) {\r\n\t\t    $b .= \"fprintf (st$val\";\r\n\t\t    next;\r\n\t\t}\r\n\t\t($tok, $val) = gettok(\\$comments);\r\n\t\tif( $tok ne 'QS' ) {\r\n\t\t    $b .= \"fprintf (st, $val\";\r\n\t\t    next;\r\n\t\t}\r\n\t\t# Concatenate adjacent strings\r\n\t\tmy $string = '';\r\n\t\twhile( $tok eq 'QS' ) {\r\n\t\t    $string .= substr( $val, 1, length( $ val ) -2);\r\n\t\t    ($tok, $val) = gettok(\\$comments);\r\n\t\t}\r\n\t\t# Check for format codes.  plain %s is all that can be automated\r\n\t\tif ($string =~ /(%[^%s])/) {\r\n\t\t    print STDERR \"Line $.: Unsupported format code $1 in help string.  Please convert to %s\\n\";\r\n\t\t}\r\n\t\t# Rework argument list\r\n\t\tmy $arg = '';\r\n\t\tmy @vlist;\r\n\t\tmy $pl = 1;             # Paren level\r\n\t\twhile( $tok eq ',' ) {\r\n\t\t    ($tok, $val) = gettok(\\$comments);\r\n\t\t    while( $tok ne ',' ) {\r\n\t\t\tif( $tok eq '(' ) {\r\n\t\t\t    $pl++;\r\n\t\t\t} elsif( $tok eq ')' ) {\r\n\t\t\t    die \"Unmatched )\" if( --$pl < 0);\r\n\t\t\t    last if( !$pl );\r\n\t\t\t}\r\n\t\t\t$arg .= \" $val\";\r\n\t\t\t($tok, $val) = gettok(\\$comments);\r\n\t\t    }\r\n\t\t    if( !length $arg ) {\r\n\t\t\tprint STDERR \"Line $.: null argument to fprintf in $rtn\\n\";\r\n\t\t\t$string = \"<<NULL>>\";\r\n\t\t    }\r\n\t\t    unless( exists $vargs{$arg} ) {   # Assign each unique arg an index\r\n\t\t\t$vargs{$arg} = @vargs;\r\n\t\t\tpush @vargs, $arg;\r\n\t\t    }\r\n\t\t    push @vlist, $vargs{$arg};        # Remember offset in this list\r\n\t\t    $arg = '';\r\n\t\t}\r\n\t\tdie \"Line $.: Missing ')' in fprintf\\n\" if( $tok ne ')' );\r\n\t\t($tok, $val) = gettok(\\$comments);\r\n\t\tdie \"Line $.: Missing ';' in fprintf\\n\" if( $tok ne ';' );\r\n\r\n\t\t# Replace each escape with positional %s in new list.\r\n\t\tmy $n = 0;\r\n\t\t$string =~ s/%([.\\dlhs# +Lqjzt-]*[diouxXeEfFgGaAcspnm%])/\r\n\t\t  sprintf \"%%%us\",$vlist[$n++]+1/eg;\r\n\t\t$help .= $string;\r\n\t\tnext;\r\n\t    } elsif ($tok eq 'word' && $val =~ /^fprint_(set|show|reg)_help(?:_ex)?$/) {\r\n\t\tmy %alt = ( set  => \"\\$Set commands\", \r\n\t\t\t    show => \"\\$Show commands\", \r\n\t\t\t    reg  => \"\\$Registers\" );\r\n\t\t$b .= \"/* Use \\\"$alt{$1}\\\" topic instead:\\n\";\r\n\t\tdo {\r\n\t\t    $b .= \" $val\";\r\n\t\t    ($tok, $val) = gettok (\\$comments);\r\n\t\t} while ($tok ne ';');\r\n\t\t$b .= \";\\n*/\\n\";\r\n\t\tnext;\r\n\t    }\r\n\r\n\t    # Random function body content\r\n\r\n\t    $b .= \" $val\";\r\n\t}\r\n\t# End of function - output new one\r\n\tprint $f;                       # Function header\r\n\tprint \"const char helpString[] =\\n\";\r\n\r\n\tprint << 'TEMPLATE_';\r\n/* Template for re-arranging your help.\r\n * Lines marked with '+' in the translation seemed to be indented and will\r\n * indent 4 columns for each '+'.  See scp_help.h for a worked-out example.\r\n * The '*'s in the next line represent the standard text width of a help line */\r\n     /****************************************************************************/\r\n    \" Insert your device summary here.  Keep it short.  Be sure to put a leading\\n\"\r\n    \" space at the start of each line.  Blank lines do appear in the output;\\n\"\r\n    \" don't add extras.\\n\"\r\n    \"1 Hardware Description\\n\"\r\n    \" The details of the hardware.  Feeds & speeds are OK here.\\n\"\r\n    \"2 Models\\n\"\r\n    \" If the device was offered in distinct models, a subtopic for each\\n\"\r\n    \"3 Model A\\n\"\r\n    \" Description of model A\\n\"\r\n    \"3 Model B\\n\"\r\n    \" Description of model B\\n\"\r\n    \"2 $Registers\\n\"\r\n    \" The register list of the device will automagically display above this\\n\"\r\n    \" line.  Add any special notes.\\n\"\r\n    \"1 Configuration\\n\"\r\n    \" How to configure the device under SimH.  Use subtopics\\n\"\r\n    \" if there is a lot of detail.\\n\"\r\n    \"2 $Set commands\\n\"\r\n    \" The SET commands for the device will automagically display above\\n\"\r\n    \" this line.  Add any special notes.\\n\"\r\n    \"2 OSNAME1\\n\"\r\n    \" Operating System-specific configuration details\\n\"\r\n    \" If the device needs special configuration for a particular OS, a subtopic\\n\"\r\n    \" for each such OS goes here.\\n\"\r\n    \"2 Files\\n\"\r\n    \" If the device uses external files (tapes, cards, disks, configuration)\\n\"\r\n    \" Create a subtopic for each here.\\n\"\r\n    \"3 Config file 1\\n\"\r\n    \" Description.\\n\"\r\n    \"2 Examples\\n\"\r\n    \" Provide usable examples for configuring complex devices.\\n\"\r\n    \" If the examples are more than a couple of lines, make a subtopic for each.\\n\"\r\n    \"1 Operation\\n\"\r\n    \" How to operate the device under SimH.  Attach, runtime events\\n\"\r\n    \" (e.g. how to load cards or mount a tape)\\n\"\r\n    \"1 Monitoring\\n\"\r\n    \" How to obtain and interpret status\\n\"\r\n    \"2 $Show commands\\n\"\r\n    \" The SHOW commands for the device will automagically display above\\n\"\r\n    \" this line.  Add any special notes.\\n\"\r\n    \"1 Restrictions\\n\"\r\n    \" If some aspects of the device aren't emulated or some host\\n\"\r\n    \" host environments that aren't (fully) supported, list them here.\\n\"\r\n    \"1 Debugging\\n\"\r\n    \"  Debugging information - provided by the device.  Tips for common problems.\\n\"\r\n    \"1 Related Devices\\n\"\r\n    \" If devices are configured or used together, list the other devices here.\\n\"\r\n    \" E.G. The DEC KMC/DUP are two hardware devices that are closely related;\\n\"\r\n    \" The KMC controls the DUP on behalf of the OS.\\n\"\r\n\r\n    /* **** Your converted help text starts hare **** */\r\n\r\nTEMPLATE_\r\n\r\n\tmy @lines = split /(\\\\n|\\n)/, $help;\r\n\twhile( @lines ) {\r\n\t    my $line = shift @lines;\r\n\t    my $term = shift @lines;\r\n\t    if ($term eq \"\\\\n\") {\r\n\t\t$line .= $term;\r\n\t\t$term = \"\\n\";\r\n\t    }\r\n\t    if( $line =~ s/^(\\s+)// ) {\r\n\t\t$line = ('+' x ((length( $1 ) +3)/4)) . $line;\r\n\t    } else {\r\n\t\t$line = ' ' . $line;\r\n\t    }\r\n\r\n\t    print \"    \\\"$line\\\"\\n\" ;\r\n\t}\r\n\tprint \"    ;\\n\";\r\n\tprint $b;                       # Stuff from body of old function\r\n\tif( length $comments ) {\r\n\t    print \"\\n$comments\";\r\n\t}\r\n\r\n\t# Call scp_help\r\n\r\n\tprint \"\\nreturn scp_help (st, dptr, uptr, helpString, cptr\";\r\n\r\n\t%vargs = reverse %vargs;\r\n\twhile( @vargs ) {\r\n\t    print \",\\n                \" . shift( @vargs );\r\n\t}\r\n\r\n\tprint  \");\\n}\\n\";\r\n    } else {\r\n\tif( $update ) {\r\n\t    print $_;\r\n\t}\r\n\tnext;\r\n    }\r\n}\r\n\r\nexit (0);\r\n\r\nmy @pending;\r\nsub nextc {\r\n    if( @pending ) {\r\n\tmy $c = shift @pending;\r\n\treturn $c;\r\n    }\r\n    return getc;\r\n}\r\n\r\nsub gettoken {\r\n    my $c;\r\n    my $ql = 0;\r\n    my $cl = 0;\r\n    my $tok = '';\r\n\r\n    while( defined(($c = nextc())) ) {\r\n\tif( $cl ) {\r\n\t    if( $c eq '*' ) {\r\n\t\t$c = nextc;\r\n\t\tdie \"EOF in comment\\n\" if( !defined $c );\r\n\r\n\t\tif ($c eq '/') {\r\n\t\t    $tok .= '*/';\r\n\t\t    return ('comment', $tok);\r\n\t\t}\r\n\t\tpush @pending, $c;\r\n\t\t$c = '*';\r\n\t    }\r\n\t    $tok .= $c;\r\n\t    next;\r\n\t} elsif( $c eq '/' ) {\r\n\t    $c = nextc;\r\n\t    if( $c eq '*' ) {\r\n\t\tif (length $tok) {\r\n\t\t    push @pending, '/', '*';\r\n\t\t    return ('word', $tok);\r\n\t\t}\r\n\t\t$cl = 1;\r\n\t\t$tok = '/*';\r\n\t\tnext;\r\n\t    }\r\n\t    push @pending, $c;\r\n\t    $c = '/';\r\n\t}\r\n\tif( $ql ) {\r\n\t    if( $c eq '\\\\' ) {\r\n\t\t$c = nextc;\r\n\t\tdie \"EOF in string\\n\" if( !defined $c );\r\n\r\n\t\t$tok .= \"\\\\$c\"; # eval \"\\\"\\\\$c\\\"\";\r\n\t\tnext;\r\n\t    }\r\n\t    if( $c eq $ql ) {\r\n\t\t$tok .= $ql;\r\n\t\treturn (\"QS\", $tok);\r\n\t    }\r\n\t    $tok .= $c;\r\n\t    next;\r\n\t}\r\n\tif( $c eq '\"' || $c eq \"'\" ) {\r\n\t    $ql = $c;\r\n\t    $tok = $c;\r\n\t    next;\r\n\t}\r\n\tif ($c =~ /^\\s$/) {\r\n\t    if( length $tok ) {\r\n\t\treturn ('word', $tok);\r\n\t    }\r\n\t    next;\r\n\t}\r\n\tif ($c =~ /^\\w$/) {\r\n\t    $tok .= $c;\r\n\t    next;\r\n\t}\r\n\tif( length $tok ) {\r\n\t    push @pending, $c;\r\n\t    return ('word', $tok);\r\n\t}\r\n\tif ($c eq '-') {\r\n\t    $c = nextc;\r\n\t    if( $c =~ /^[>=-]$/ ) {\r\n\t\treturn ('op', \"-$c\");\r\n\t    }\r\n\t    push @pending, $c;\r\n\t    return ('op', '-');\r\n\t}\r\n\tif( $c eq '<' ) {\r\n\t    $c = nextc;\r\n\t    if( $c eq '=' ) {\r\n\t\treturn ('op', \"<$c\");\r\n\t    }\r\n\t    if( $c eq '<' ) {\r\n\t\tmy $c2 = nextc;\r\n\t\tif( $c2 eq '=' ) {\r\n\t\t    return ('op', \"<<=\");\r\n\t\t}\r\n\t\tpush @pending, $c2;\r\n\t\treturn ('op', '<<');\r\n\t    }\r\n\t    push @pending, $c;\r\n\t    return ('op', '<');\r\n\t}\r\n\tif( $c eq '>' ) {\r\n\t    $c = nextc;\r\n\t    if( $c eq '=' ) {\r\n\t\treturn ('op', \">$c\");\r\n\t    }\r\n\t    if( $c eq '>' ) {\r\n\t\tmy $c2 = nextc;\r\n\t\tif( $c2 eq '=' ) {\r\n\t\t    return ('op', \">>=\");\r\n\t\t}\r\n\t\tpush @pending, $c2;\r\n\t\treturn ('op', '>>');\r\n\t    }\r\n\t    push @pending, $c;\r\n\t    return ('op', '>');\r\n\t}\r\n\tif( $c eq '=' ) {\r\n\t    $c = nextc;\r\n\t    if( $c eq '=' ) {\r\n\t\treturn ('op', '==');\r\n\t    }\r\n\t    push @pending, $c;\r\n\t    return ('op', '=');\r\n\t}\r\n\tif ($c =~ m,^[!*+/%&^|]$,) {\r\n\t    my $c2 = nextc;\r\n\t    if( $c2 eq '=' ) {\r\n\t\treturn ('op', \"$c$c2\");\r\n\t    }\r\n\t    push @pending, $c2;\r\n\t    return ('op', $c);\r\n\t}\r\n\tif( $c =~ /^[&|]$/ ) {\r\n\t    my $c2 = nextc;\r\n\t    if( $c2 eq $c ) {\r\n\t\treturn ('op', \"$c$c\");\r\n\t    }\r\n\t    push @pending, $c2;\r\n\t    return ('op', $c);\r\n\t}\r\n\r\n\tif ($c =~ /^[#}]$/ ) {\r\n\t    return ($c, \"\\n$c\");\r\n\t}\r\n\treturn ($c, ($c =~ /^[{;]$/? \"$c\\n\" : $c));\r\n    }\r\n    return (undef, '<<EOF>>');\r\n}\r\n\r\nsub gettok {\r\n    my $comments = $_[0];\r\n\r\n    while( 1 ) {\r\n\tmy( $token, $value ) = gettoken();\r\n\treturn ($token, $value) if( !defined $token );\r\n\r\n\tif( $token eq 'comment' && $comments ) {\r\n\t    $$comments .= $value . \"\\n\";\r\n\t    next;\r\n\t}\r\n\treturn ($token, $value);\r\n    }\r\n}\r\n"
        },
        {
          "name": "imlac",
          "type": "tree",
          "content": null
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 125.640625,
          "content": "#\r\n# This GNU make makefile has been tested on:\r\n#   Linux (x86 & Sparc & PPC)\r\n#   Android (Termux)\r\n#   OS X\r\n#   Solaris (x86 & Sparc) (gcc and Sun C)\r\n#   OpenBSD\r\n#   NetBSD\r\n#   FreeBSD\r\n#   HP-UX\r\n#   AIX\r\n#   Windows (MinGW & cygwin) - deprecated (maybe works, maybe not)\r\n#   Linux x86 targeting Android (using agcc script)\r\n#   Haiku x86 (with gcc4)\r\n#\r\n# Android targeted builds should invoke GNU make with GCC=agcc on\r\n# the command line.\r\n#\r\n# In general, the logic below will detect and build with the available\r\n# features which the host build environment provides.\r\n#\r\n# Dynamic loading of libpcap is the preferred default behavior if pcap.h\r\n# is available at build time.  Support to statically linking against libpcap\r\n# is deprecated and may be removed in the future.  Static linking against\r\n# libpcap can be enabled if GNU make is invoked with USE_NETWORK=1 on the\r\n# command line.\r\n#\r\n# Some platforms may not have vendor supplied libpcap available.  HP-UX is\r\n# one such example.  The packages which are available for this platform\r\n# install include files and libraries in user specified directories.  In\r\n# order for this makefile to locate where these components may have been\r\n# installed, gmake should be invoked with LPATH=/usr/lib:/usr/local/lib\r\n# defined (adjusted as needed depending on where they may be installed).\r\n#\r\n# In the unlikely event that someone wants to build network capable\r\n# simulators without networking support, invoking GNU make with\r\n# NONETWORK=1 on the command line will do the trick.\r\n#\r\n# By default, video support is enabled if the SDL2 development\r\n# headers and libraries are available.  To force a build without video\r\n# support, invoke GNU make with NOVIDEO=1 on the command line.\r\n#\r\n# The default build will build compiler optimized binaries.\r\n# If debugging is desired, then GNU make can be invoked with\r\n# DEBUG=1 on the command line.\r\n#\r\n# When building compiler optimized binaries with the gcc or clang\r\n# compilers, invoking GNU make with LTO=1 on the command line will\r\n# cause the build to use Link Time Optimization to maximally optimize\r\n# the results.  Link Time Optimization can report errors which aren't\r\n# otherwise detected and will also take significantly longer to\r\n# complete.  Additionally, non debug builds default to build with an\r\n# optimization level of -O2.  This optimization level can be changed\r\n# by invoking GNU make with OPTIMIZE=-O3 (or whatever optimize value\r\n# you want) on the command line if desired.\r\n#\r\n# The default setup will fail simulator build(s) if the compile\r\n# produces any warnings.  These should be cleaned up before new\r\n# or changed code is accepted into the code base.  This option\r\n# can be overridden if GNU make is invoked with WARNINGS=ALLOWED\r\n# on the command line.\r\n#\r\n# The default build will run per simulator tests if they are\r\n# available.  If building without running tests is desired,\r\n# then GNU make should be invoked with TESTS=0 on the command\r\n# line.\r\n#\r\n# The default build will compile all input source files with a\r\n# single compile and link operation.  This is most optimal when\r\n# building all simulators or just a single simulator which you\r\n# merely plan to run.  If you're developing new code for a\r\n# simulator, it is more efficient to compile each source module\r\n# into it's own object and then to link all the objects into the\r\n# simulator binary.  This allows only the changed modules to be\r\n# compiled instead of all of the input files resulting in much\r\n# quicker builds during active simulator development.  GNU make\r\n# can be invoked with BUILD_SEPARATE=1 on the command line (or\r\n# defined as an exported environment variable) and separate\r\n# objects will be built and linked into the resulting simulator.\r\n#\r\n# The default make output will show the details of each compile\r\n# and link command executed.  GNU make can be invoked with QUIET=1\r\n# on the command line (or defined as an exported environment\r\n# variable) a summary of the executed command will be displayed\r\n# in the make output.\r\n#\r\n# Default test execution will produce summary output.  Detailed\r\n# test output can be produced if GNU make is invoked with\r\n# TEST_ARG=-v on the command line.\r\n#\r\n# simh project support is provided for simulators that are built with\r\n# dependent packages provided with the or by the operating system\r\n# distribution OR for platforms where that isn't directly available\r\n# (OS X/macOS) by packages from specific package management systems\r\n# (HomeBrew or MacPorts).  Users wanting to build simulators with locally\r\n# built dependent packages or packages provided by an unsupported package\r\n# management system may be able to override where this procedure looks\r\n# for include files and/or libraries.  Overrides can be specified by define\r\n# exported environment variables or GNU make command line arguments which\r\n# specify INCLUDES and/or LIBRARIES.\r\n# Each of these, if specified, must be the complete list include directories\r\n# or library directories that should be used with each element separated by\r\n# colons. (i.e. INCLUDES=/usr/include/:/usr/local/include/:...)\r\n# If this doesn't work for you and/or you're interested in using a different\r\n# ToolChain, you're free to solve this problem on your own.  Good Luck.\r\n#\r\n# Some environments may have the LLVM (clang) compiler installed as\r\n# an alternate to gcc.  If you want to specifically build with the\r\n# clang compiler, you should invoke make with GCC=clang on the make command\r\n# line.\r\n#\r\n# Internal ROM support can be disabled if GNU make is invoked with\r\n# DONT_USE_ROMS=1 on the command line.\r\n#\r\n# For linting (or other code analyzers) make may be invoked similar to:\r\n#\r\n#   make GCC=cppcheck CC_OUTSPEC= LDFLAGS= CFLAGS_G=\"--enable=all --template=gcc\" CC_STD=--std=c99\r\n#\r\nifeq (0,$(MAKELEVEL))\t# recursive individual target build logic is end of this makefile\r\n#\r\n# CC Command (and platform available options).  (Poor man's autoconf)\r\n#\r\nifneq (,${GREP_OPTIONS})\r\n  $(info GREP_OPTIONS is defined in your environment.)\r\n  $(info )\r\n  $(info This variable interfers with the proper operation of this script.)\r\n  $(info )\r\n  $(info The GREP_OPTIONS environment variable feature of grep is deprecated)\r\n  $(info for exactly this reason and will be removed from future versions of)\r\n  $(info grep.  The grep man page suggests that you use an alias or a script)\r\n  $(info to invoke grep with your preferred options.)\r\n  $(info )\r\n  $(info unset the GREP_OPTIONS environment variable to use this makefile)\r\n  $(error 1)\r\nendif\r\nifneq ($(findstring Windows,${OS}),)\r\n  $(info *** Warning *** Compiling simh simulators with MinGW or cygwin is deprecated and)\r\n  $(info *** Warning *** may not complete successfully or produce working simulators.  If)\r\n  $(info *** Warning *** building simulators completes, they may not be fully functional.)\r\n  $(info *** Warning *** It is recommended to use one of the free Microsoft Visual Studio)\r\n  $(info *** Warning *** compilers which provide fully functional simulator capabilities.)\r\n  ifeq ($(findstring .exe,${SHELL}),.exe)\r\n    # MinGW\r\n    export WIN32 := 1\r\n    # Tests don't run under MinGW\r\n    export TESTS := 0\r\n    export RM = del /f /q\r\n    export MKDIR = mkdir\r\n    export OSTYPE = MinGW\r\n    ifneq (,$(strip $(shell $(MAKE) --version 2>NUL)))\r\n      GNUMake=$(strip $(shell $(MAKE) --version | findstr /C:\"GNU Make\"))\r\n      export GNUMakeVERSION=$(strip $(shell for /F \"tokens=3\" %%i in (\"$(GNUMake)\") do echo %%i))\r\n    else\r\n      # Nothing useful returned from MinGW GNU Make 3.82.90, make sure to set this version\r\n      export GNUMakeVERSION=3.82.90\r\n    endif\r\n  else # Msys or cygwin\r\n    ifeq (MINGW,$(findstring MINGW,$(shell uname)))\r\n      $(info *** This makefile can not be used with the Msys bash shell)\r\n      $(error Use build_mingw.bat ${MAKECMDGOALS} from a Windows command prompt)\r\n    endif\r\n  endif\r\nelse\r\n  export GNUMakeVERSION = $(shell ($(MAKE) --version /dev/null 2>&1 | grep 'GNU Make' | awk '{ print $$3 }'))\r\n  ifeq (old,$(shell $(MAKE) --version /dev/null 2>&1 | grep 'GNU Make' | awk '{ if ($$3 < \"3.81\") {print \"old\"} }'))\r\n    $(warning *** Warning *** GNU Make Version $(GNUMakeVERSION) is too old to)\r\n    $(warning *** Warning *** fully process this makefile)\r\n  endif\r\n  export MKDIR = mkdir -p\r\n  export OSTYPE = $(shell uname)\r\nendif\r\nifeq ($(WIN32),)\r\n  SIM_MAJOR=$(shell grep SIM_MAJOR sim_rev.h | awk '{ print $$3 }')\r\nelse\r\n  SIM_MAJOR=$(shell for /F \"tokens=3\" %%i in ('findstr /c:\"SIM_MAJOR\" sim_rev.h') do echo %%i)\r\nendif\r\n# Assure that only BUILD_SEPARATE=1 will cause separate compiles\r\nifeq (,$(BUILD_SEPARATE))\r\n  override BUILD_SEPARATE=\r\nendif\r\nexport BUILD_SEPARATE\r\nifeq (,$(QUIET))\r\n  override QUIET=\r\nendif\r\nexport QUIET\r\nBUILD_SINGLE := ${MAKECMDGOALS} $(BLANK_SUFFIX)\r\nBUILD_MULTIPLE_VERB = is\r\nMAKECMDGOALS_DESCRIPTION = the $(MAKECMDGOALS) simulator\r\n# building the pdp1, pdp11, tx-0, or any microvax simulator could use video support\r\nifneq (3,${SIM_MAJOR})\r\n  ifneq (,$(or $(findstring XXpdp1XX,$(addsuffix XX,$(addprefix XX,${MAKECMDGOALS}))),$(findstring pdp11,${MAKECMDGOALS}),$(findstring tx-0,${MAKECMDGOALS}),$(findstring microvax1,${MAKECMDGOALS}),$(findstring microvax2,${MAKECMDGOALS}),$(findstring microvax3900,${MAKECMDGOALS}),$(findstring microvax2000,${MAKECMDGOALS}),$(findstring vaxstation3100,${MAKECMDGOALS}),$(findstring XXvaxXX,$(addsuffix XX,$(addprefix XX,${MAKECMDGOALS})))))\r\n    VIDEO_USEFUL = true\r\n  endif\r\n  # building the besm6 needs both video support and fontfile support\r\n  ifneq (,$(findstring besm6,${MAKECMDGOALS}))\r\n    VIDEO_USEFUL = true\r\n    BESM6_BUILD = true\r\n  endif\r\n  # building the Imlac needs video support\r\n  ifneq (,$(findstring imlac,${MAKECMDGOALS}))\r\n    VIDEO_USEFUL = true\r\n  endif\r\n  # building the TT2500 needs video support\r\n  ifneq (,$(findstring tt2500,${MAKECMDGOALS}))\r\n    VIDEO_USEFUL = true\r\n  endif\r\n  # building the PDP6, KA10 or KI10 needs video support\r\n  ifneq (,$(or $(findstring pdp6,${MAKECMDGOALS}),$(findstring pdp10-ka,${MAKECMDGOALS}),$(findstring pdp10-ki,${MAKECMDGOALS})))\r\n    VIDEO_USEFUL = true\r\n  endif\r\n  # building the AltairZ80 could use video support\r\n  ifneq (,$(findstring altairz80,${MAKECMDGOALS}))\r\n    VIDEO_USEFUL = true\r\n  endif\r\nendif\r\n# building the SEL32 networking can be used\r\nifneq (,$(findstring sel32,${MAKECMDGOALS}))\r\n  NETWORK_USEFUL = true\r\nendif\r\n# building the PDP-7 needs video support\r\nifneq (,$(findstring pdp7,${MAKECMDGOALS}))\r\n  VIDEO_USEFUL = true\r\nendif\r\n# building the pdp11, any pdp10, any 3b2, or any vax simulator could use networking support\r\nifneq (,$(findstring pdp11,${MAKECMDGOALS})$(findstring pdp10,${MAKECMDGOALS})$(findstring vax,${MAKECMDGOALS})$(findstring frontpaneltest,${MAKECMDGOALS})$(findstring infoserver,${MAKECMDGOALS})$(findstring 3b2,${MAKECMDGOALS})$(findstring all,${MAKECMDGOALS}))\r\n  NETWORK_USEFUL = true\r\n  ifneq (,$(findstring all,${MAKECMDGOALS}))\r\n    BUILD_MULTIPLE = s\r\n    BUILD_MULTIPLE_VERB = are\r\n    VIDEO_USEFUL = true\r\n    BESM6_BUILD = true\r\n    MAKECMDGOALS_DESCRIPTION = everything\r\n  endif\r\nelse\r\n  ifeq (${MAKECMDGOALS},)\r\n    # default target is all\r\n    NETWORK_USEFUL = true\r\n    VIDEO_USEFUL = true\r\n    BUILD_MULTIPLE = s\r\n    BUILD_MULTIPLE_VERB = are\r\n    BUILD_SINGLE := all $(BUILD_SINGLE)\r\n    BESM6_BUILD = true\r\n    MAKECMDGOALS_DESCRIPTION = everything\r\n  endif\r\nendif\r\nifneq (,$(and $(word 1,${MAKECMDGOALS}),$(word 2,${MAKECMDGOALS})))\r\n  BUILD_MULTIPLE = s\r\n  BUILD_MULTIPLE_VERB = are\r\n  MAKECMDGOALS_DESCRIPTION = the $(MAKECMDGOALS) simulators\r\nendif\r\n# someone may want to explicitly build simulators without network support\r\nifneq ($(NONETWORK),)\r\n  NETWORK_USEFUL =\r\nendif\r\n# ... or without video support\r\nifneq ($(NOVIDEO),)\r\n  VIDEO_USEFUL =\r\nendif\r\n\r\nfind_exe = $(abspath $(strip $(firstword $(foreach dir,$(strip $(subst :, ,${PATH})),$(wildcard $(dir)/$(1))))))\r\nfind_lib = $(firstword $(abspath $(strip $(firstword $(foreach dir,$(strip ${LIBPATH}),$(foreach ext,$(strip ${LIBEXT}),$(wildcard $(dir)/lib$(1).$(ext))))))))\r\nfind_include = $(abspath $(strip $(firstword $(foreach dir,$(strip ${INCPATH}),$(wildcard $(dir)/$(1).h)))))\r\nifeq (Darwin,$(OSTYPE))\r\n  ifeq (/usr/local/bin/brew,$(call find_exe,brew))\r\n    PKG_MGR = HOMEBREW\r\n    PKG_CMD = brew install\r\n  else\r\n    ifeq (/opt/local/bin/port,$(call find_exe,port))\r\n      PKG_MGR = MACPORTS\r\n      PKG_CMD = port install\r\n    endif\r\n  endif\r\nendif\r\nifneq (,$(and $(findstring Linux,$(OSTYPE)),$(call find_exe,apt-get)))\r\n  ifneq (Android,$(shell uname -o))\r\n    PKG_MGR = APT\r\n    PKG_CMD = apt-get install\r\n  else\r\n    PKG_MGR = TERMUX\r\n    PKG_CMD = pkg install\r\n    PKG_NO_SUDO = YES\r\n  endif\r\nendif\r\nifneq (,$(and $(findstring Linux,$(OSTYPE)),$(call find_exe,yum)))\r\n  PKG_MGR = YUM\r\n  PKG_CMD = yum install\r\nendif\r\nifneq (,$(and $(findstring Linux,$(OSTYPE)),$(call find_exe,dnf)))\r\n  PKG_MGR = DNF\r\n  ifneq (,$(shell dnf repolist | grep crb))\r\n    PKG_CMD = dnf --enablerepo=crb install\r\n  else\r\n    PKG_CMD = dnf install\r\n  endif\r\nendif\r\nifneq (,$(and $(findstring Linux,$(OSTYPE)),$(call find_exe,zypper)))\r\n  PKG_MGR = ZYPPER\r\n  PKG_CMD = zypper install\r\nendif\r\nifneq (,$(and $(findstring NetBSD,$(OSTYPE)),$(call find_exe,pkgin)))\r\n  PKG_MGR = PKGSRC\r\n  PKG_CMD = pkgin install\r\n  PKG_NO_SUDO = YES\r\nendif\r\nifneq (,$(and $(findstring FreeBSD,$(OSTYPE)),$(call find_exe,pkg)))\r\n  PKG_MGR = PKGBSD\r\n  PKG_CMD = pkg install\r\n  PKG_NO_SUDO = YES\r\nendif\r\nifneq (,$(and $(findstring OpenBSD,$(OSTYPE)),$(call find_exe,pkg_add)))\r\n  PKG_MGR = PKGADD\r\n  PKG_CMD = pkg_add\r\n  PKG_NO_SUDO = YES\r\n  PKG_SHELL_READ_CANT_PROMPT = YES\r\nendif\r\n# Dependent packages\r\nDPKG_COMPILER  = 1\r\nDPKG_PCAP      = 2\r\nDPKG_VDE       = 3\r\nDPKG_PCRE      = 4\r\nDPKG_EDITLINE  = 5\r\nDPKG_SDL       = 6\r\nDPKG_PNG       = 7\r\nDPKG_ZLIB      = 8\r\nDPKG_SDL_TTF   = 9\r\nDPKG_GMAKE     = 10\r\nifneq (3,${SIM_MAJOR})\r\n  # Platform Pkg Names  COMPILER PCAP          VDE            PCRE         EDITLINE      SDL             PNG            ZLIB       SDL_TTF           GMAKE CURL\r\n  PKGS_SRC_HOMEBREW   = -        -             vde            pcre         libedit       sdl2          libpng         zlib       sdl2_ttf          make  -\r\n  PKGS_SRC_MACPORTS   = -        -             vde2           pcre         libedit       libsdl2       libpng         zlib       libsdl2_ttf       gmake -\r\n  PKGS_SRC_APT        = gcc      libpcap-dev   libvdeplug-dev libpcre3-dev libedit-dev   libsdl2-dev   libpng-dev     -          libsdl2-ttf-dev   -     curl\r\n  PKGS_SRC_YUM        = gcc      libpcap-devel -              pcre-devel   libedit-devel SDL2-devel    libpng-devel   zlib-devel SDL2_ttf-devel    -     -\r\n  PKGS_SRC_DNF        = gcc      libpcap-devel -              pcre-devel   libedit-devel SDL2-devel    libpng-devel   zlib-devel SDL2_ttf-devel    -     -\r\n  PKGS_SRC_ZYPPER     = gcc      libpcap-devel -              pcre-devel   libedit-devel libSDL2-devel libpng16-devel zlib-devel libSDL2_ttf-devel make  -\r\n  PKGS_SRC_PKGSRC     = -        -             -              pcre         editline      SDL2          png            zlib       SDL2_ttf          gmake -\r\n  PKGS_SRC_PKGBSD     = -        -             -              pcre         libedit       sdl2          png            -          sdl2_ttf          gmake -\r\n  PKGS_SRC_PKGADD     = -        -             -              pcre         -             sdl2          png            -          sdl2-ttf          gmake -\r\n  PKGS_SRC_TERMUX     = clang    libpcap       -              pcre         -             -             -              -          -                 -     curl\r\n  ifneq (0,$(TESTS))\r\n    ifneq (,${TEST_ARG})\r\n      export TEST_ARG\r\n      TESTING_FEATURES = - Per simulator tests will be run with argument: ${TEST_ARG}\r\n    else\r\n      TESTING_FEATURES = - Per simulator tests will be run\r\n    endif\r\n  else\r\n    TESTING_FEATURES = - Per simulator tests will be skipped\r\n  endif\r\nelse\r\n  # simh v3 has minimal external dependencies\r\n  # Platform Pkg Names  COMPILER PCAP          VDE            PCRE         EDITLINE      SDL         PNG          ZLIB       SDL_TTF   GMAKE\r\n  PKGS_SRC_HOMEBREW   = -        -             vde            -            libedit       -           -            -          -         -\r\n  PKGS_SRC_MACPORTS   = -        -             vde2           -            libedit       -           -            -          -         -\r\n  PKGS_SRC_APT        = gcc      libpcap-dev   libvdeplug-dev -            libedit-dev   -           -            -          -         -\r\n  PKGS_SRC_YUM        = gcc      libpcap-devel -              -            libedit-devel -           -            -          -         -\r\n  PKGS_SRC_DNF        = gcc      libpcap-devel -              -            libedit-devel -           -            -          -         -\r\n  PKGS_SRC_PKGSRC     = -        -             -              -            editline      -           -            -          -         -\r\n  PKGS_SRC_PKGBSD     = -        -             -              -            libedit       -           -            -          -         -\r\n  PKGS_SRC_PKGADD     = -        -             -              -            -             -           -            -          -         -\r\nendif\r\nifeq (${WIN32},)  #*nix Environments (&& cygwin)\r\n  # OSNAME is used in messages to indicate the source of libpcap components\r\n  OSNAME = $(OSTYPE)\r\n  ifeq (SunOS,$(OSTYPE))\r\n    export TEST = /bin/test\r\n  else\r\n    export TEST = test\r\n  endif\r\n  override AUTO_INSTALL_PACKAGES:=$(and $(AUTO_INSTALL_PACKAGES),$(or $(findstring HOMEBREW,$(PKG_MGR)),$(shell if $(TEST) -r /dev/mem; then echo running_as_root; fi)))\r\n  ifeq (${GCC},)\r\n    ifeq (,$(call find_exe,gcc))\r\n      ifneq (clang,$(findstring clang,$(and $(call find_exe,cc),$(shell cc -v /dev/null 2>&1 | grep 'clang'))))\r\n        $(info *** Warning *** Using local cc since gcc isn't available locally.)\r\n        $(info *** Warning *** You may need to install gcc to build working simulators.)\r\n      endif\r\n      GCC = cc\r\n      NEEDED_PKGS += DPKG_COMPILER\r\n    else\r\n      GCC = gcc\r\n    endif\r\n  endif\r\n  ifeq (CYGWIN,$(findstring CYGWIN,$(OSTYPE))) # uname returns CYGWIN_NT-n.n-ver\r\n    OSTYPE = cygwin\r\n    OSNAME = windows-build\r\n  endif\r\n  ifeq (Darwin,$(OSTYPE))\r\n    ifeq (,$(call find_exe,port)$(call find_exe,brew))\r\n      $(info *** Info *** simh dependent packages on macOS must be provided by either the)\r\n      $(info *** Info *** HomeBrew package system or by the MacPorts package system.)\r\n      $(info *** Info *** Neither of these seem to be installed on the local system.)\r\n      $(info *** Info ***)\r\n      ifeq (,$(INCLUDES)$(LIBRARIES))\r\n        $(info *** Info *** Users wanting to build simulators with locally built dependent)\r\n        $(info *** Info *** packages or packages provided by an unsupported package)\r\n        $(info *** Info *** management system may be able to override where this procedure)\r\n        $(info *** Info *** looks for include files and/or libraries.  Overrides can be)\r\n        $(info *** Info *** specified by defining exported environment variables or GNU make)\r\n        $(info *** Info *** command line arguments which specify INCLUDES and/or LIBRARIES.)\r\n        $(info *** Info *** If this works, that's great, if it doesn't you are on your own!)\r\n      else\r\n        $(info *** Warning *** Attempting to build on macOS with:)\r\n        $(info *** Warning *** INCLUDES defined as $(INCLUDES))\r\n        $(info *** Warning *** and)\r\n        $(info *** Warning *** LIBRARIES defined as $(LIBRARIES))\r\n      endif\r\n    endif\r\n  endif\r\n  ifeq (,$(shell ${GCC} -v /dev/null 2>&1 | grep 'clang'))\r\n    GCC_VERSION = $(shell ${GCC} -v /dev/null 2>&1 | grep 'gcc version' | awk '{ print $$3 }')\r\n    COMPILER_NAME = GCC Version: $(GCC_VERSION)\r\n    ifeq (,$(GCC_VERSION))\r\n      ifeq (SunOS,$(OSTYPE))\r\n        ifneq (,$(shell ${GCC} -V 2>&1 | grep 'Sun C'))\r\n          SUNC_VERSION = $(shell ${GCC} -V 2>&1 | grep 'Sun C')\r\n          COMPILER_NAME = $(wordlist 2,10,$(SUNC_VERSION))\r\n          CC_STD = -std=c99\r\n        endif\r\n      endif\r\n      ifeq (HP-UX,$(OSTYPE))\r\n        ifneq (,$(shell what `which $(firstword ${GCC}) 2>&1`| grep -i compiler))\r\n          COMPILER_NAME = $(strip $(shell what `which $(firstword ${GCC}) 2>&1` | grep -i compiler))\r\n          CC_STD = -std=gnu99\r\n        endif\r\n      endif\r\n    else\r\n      OS_CCDEFS += $(if $(findstring ALLOWED,$(WARNINGS)),,-Werror)\r\n      ifeq (,$(findstring ++,${GCC}))\r\n        CC_STD = -std=gnu99\r\n      else\r\n        export CPP_BUILD = 1\r\n      endif\r\n    endif\r\n  else\r\n    OS_CCDEFS += $(if $(findstring ALLOWED,$(WARNINGS)),,-Werror)\r\n    ifeq (Apple,$(shell ${GCC} -v /dev/null 2>&1 | grep 'Apple' | awk '{ print $$1 }'))\r\n      COMPILER_NAME = $(shell ${GCC} -v /dev/null 2>&1 | grep 'Apple' | awk '{ print $$1 \" \" $$2 \" \" $$3 \" \" $$4 }')\r\n      CLANG_VERSION = $(word 4,$(COMPILER_NAME))\r\n    else\r\n      COMPILER_NAME = $(shell ${GCC} -v /dev/null 2>&1 | grep 'clang version' | awk '{ print $$1 \" \" $$2 \" \" $$3 }')\r\n      CLANG_VERSION = $(word 3,$(COMPILER_NAME))\r\n      ifeq (,$(findstring .,$(CLANG_VERSION)))\r\n        COMPILER_NAME = $(shell ${GCC} -v /dev/null 2>&1 | grep 'clang version' | awk '{ print $$1 \" \" $$2 \" \" $$3 \" \" $$4 }')\r\n        CLANG_VERSION = $(word 4,$(COMPILER_NAME))\r\n      endif\r\n    endif\r\n    ifeq (,$(findstring ++,${GCC}))\r\n      CC_STD = -std=c99\r\n    else\r\n      export CPP_BUILD = 1\r\n      OS_CCDEFS += -Wno-deprecated\r\n    endif\r\n  endif\r\n  ifeq (git-repo,$(shell if ${TEST} -e ./.git; then echo git-repo; fi))\r\n    GIT_REPO=1\r\n    GIT_PATH=$(strip $(call find_exe,git))\r\n    ifeq (,$(GIT_PATH))\r\n      $(error building using a git repository, but git is not available)\r\n    endif\r\n  endif\r\n  ifeq (got-repo,$(shell if ${TEST} -e ./.got; then echo got-repo; fi))\r\n    GIT_PATH=$(strip $(call find_exe,git))\r\n    ifeq (,$(GIT_PATH))\r\n      $(error building using a got repository, but git is not available)\r\n    endif\r\n    ifeq (,$(file <.got/repository))\r\n      $(error building using a got repository, but git repository is not available)\r\n    endif\r\n    REPO_PATH=-C $(file <.got/repository)\r\n    GIT_REPO=1\r\n  endif\r\n  ifneq (,$(and $(GIT_REPO),$(GIT_PATH)))\r\n    ifeq (commit-id-exists,$(shell if ${TEST} -e .git-commit-id; then echo commit-id-exists; fi))\r\n      CURRENT_FULL_GIT_COMMIT_ID=$(strip $(shell grep 'SIM_GIT_COMMIT_ID' .git-commit-id | awk '{ print $$2 }'))\r\n      CURRENT_GIT_COMMIT_ID=$(word 1,$(subst +, , $(CURRENT_FULL_GIT_COMMIT_ID)))\r\n      ACTUAL_GIT_COMMIT_ID=$(strip $(shell git $(REPO_PATH) log -1 --pretty=\"%H\"))\r\n      ifneq ($(CURRENT_GIT_COMMIT_ID),$(ACTUAL_GIT_COMMIT_ID))\r\n        NEED_COMMIT_ID = need-commit-id$(shell touch scp.c)\r\n        # make sure that the invalidly formatted .git-commit-id file wasn't generated\r\n        # by legacy git hooks which need to be removed.\r\n        $(shell $(RM) .git/hooks/post-checkout .git/hooks/post-commit .git/hooks/post-merge)\r\n      endif\r\n    else\r\n      NEED_COMMIT_ID = need-commit-id$(shell touch scp.c)\r\n    endif\r\n    ifneq (,$(if $(REPO_PATH),$(shell got status -S ?),$(shell git update-index --refresh --)))\r\n      ifeq (,$(findstring +uncommitted-changes,$(CURRENT_FULL_GIT_COMMIT_ID)))\r\n        GIT_EXTRA_FILES=+uncommitted-changes$(shell touch scp.c)\r\n      else\r\n        GIT_EXTRA_FILES=+uncommitted-changes\r\n      endif\r\n    endif\r\n    ifneq (,$(or $(NEED_COMMIT_ID),$(GIT_EXTRA_FILES)))\r\n      isodate=$(shell git $(REPO_PATH) log -1 --pretty=\"%ai\"|sed -e 's/ /T/'|sed -e 's/ //')\r\n      $(shell git $(REPO_PATH) log -1 --pretty=\"SIM_GIT_COMMIT_ID %H$(GIT_EXTRA_FILES)%nSIM_GIT_COMMIT_TIME $(isodate)\" >.git-commit-id)\r\n    endif\r\n  endif\r\n  SIM_BUILD_OS_VERSION= -DSIM_BUILD_OS_VERSION=\"$(shell uname -a|sed 's/,//g')\"\r\n  LTO_EXCLUDE_VERSIONS =\r\n  PCAPLIB = pcap\r\n  ifeq (agcc,$(findstring agcc,${GCC})) # Android target build?\r\n    OS_CCDEFS += -D_GNU_SOURCE -DSIM_ASYNCH_IO \r\n    OS_LDFLAGS = -lm\r\n  else # Non-Android (or Native Android) Builds\r\n    ifeq (,$(INCLUDES)$(LIBRARIES))\r\n      INCPATH:=$(shell LANG=C; ${GCC} -x c -v -E /dev/null 2>&1 | grep -A 10 '> search starts here' | grep '^ ' | tr -d '\\n')\r\n      ifeq (,${INCPATH})\r\n        INCPATH:=/usr/include\r\n      endif\r\n      LIBPATH:=/usr/lib\r\n    else\r\n      $(info *** Warning ***)\r\n      ifeq (,$(INCLUDES))\r\n        INCPATH:=$(shell LANG=C; ${GCC} -x c -v -E /dev/null 2>&1 | grep -A 10 '> search starts here' | grep '^ ' | tr -d '\\n')\r\n      else\r\n        $(info *** Warning *** Unsupported build with INCLUDES defined as: $(INCLUDES))\r\n        INCPATH:=$(strip $(subst :, ,$(INCLUDES)))\r\n        UNSUPPORTED_BUILD := include\r\n      endif\r\n      ifeq (,$(LIBRARIES))\r\n        LIBPATH:=/usr/lib\r\n      else\r\n        $(info *** Warning *** Unsupported build with LIBRARIES defined as: $(LIBRARIES))\r\n        LIBPATH:=$(strip $(subst :, ,$(LIBRARIES)))\r\n        ifeq (include,$(UNSUPPORTED_BUILD))\r\n          UNSUPPORTED_BUILD := include+lib\r\n        else\r\n          UNSUPPORTED_BUILD := lib\r\n        endif\r\n      endif\r\n      $(info *** Warning ***)\r\n    endif\r\n    OS_CCDEFS += -D_GNU_SOURCE\r\n    GCC_OPTIMIZERS_CMD = ${GCC} -v --help 2>&1\r\n    GCC_WARNINGS_CMD = ${GCC} -v --help 2>&1\r\n    LD_ELF = $(shell echo | ${GCC} -E -dM - | grep __ELF__)\r\n    ifeq (Darwin,$(OSTYPE))\r\n      OSNAME = OSX\r\n      LIBEXT = dylib\r\n      ifneq (include,$(findstring include,$(UNSUPPORTED_BUILD)))\r\n        INCPATH:=$(shell LANG=C; ${GCC} -x c -v -E /dev/null 2>&1 | grep -A 10 '> search starts here' | grep '^ ' | grep -v 'framework directory' | tr -d '\\n')\r\n      endif\r\n      ifeq (incopt,$(shell if ${TEST} -d /opt/local/include; then echo incopt; fi))\r\n        INCPATH += /opt/local/include\r\n        OS_CCDEFS += -I/opt/local/include\r\n      endif\r\n      ifeq (libopt,$(shell if ${TEST} -d /opt/local/lib; then echo libopt; fi))\r\n        LIBPATH += /opt/local/lib\r\n        OS_LDFLAGS += -L/opt/local/lib\r\n      endif\r\n      ifeq (HomeBrew,$(or $(shell if ${TEST} -d /usr/local/Cellar; then echo HomeBrew; fi),$(shell if ${TEST} -d /opt/homebrew/Cellar; then echo HomeBrew; fi)))\r\n        ifeq (local,$(shell if $(TEST) -d /usr/local/Cellar; then echo local; fi))\r\n          HBPATH = /usr/local\r\n        else\r\n          HBPATH = /opt/homebrew\r\n        endif\r\n        INCPATH += $(foreach dir,$(wildcard $(HBPATH)/Cellar/*/*),$(realpath $(dir)/include))\r\n        LIBPATH += $(foreach dir,$(wildcard $(HBPATH)/Cellar/*/*),$(realpath $(dir)/lib))\r\n      endif\r\n    else\r\n      ifeq (Linux,$(OSTYPE))\r\n        ifeq (Android,$(shell uname -o))\r\n          ANDROID_API=$(shell getprop ro.build.version.sdk)\r\n          ANDROID_VERSION=$(shell getprop ro.build.version.release)\r\n          OS_CCDEFS += -DSIM_BUILD_OS=\" On Android Version $(ANDROID_VERSION) sdk=$(ANDROID_API)\"\r\n          ifeq (,$(shell clang sim_BuildROMs.c -o /dev/null -D__ANDROID_API__=$(ANDROID_API) 2>&1))\r\n            OS_CCDEFS += -D__ANDROID_API__=$(ANDROID_API)\r\n          endif\r\n        endif\r\n        ifneq (lib,$(findstring lib,$(UNSUPPORTED_BUILD)))\r\n          ifeq (Android,$(shell uname -o))\r\n            ifneq (,$(shell if ${TEST} -d ${PREFIX}/lib; then echo prefixlib; fi))\r\n              LIBPATH += ${PREFIX}/lib\r\n            endif\r\n            ifneq (,$(shell if ${TEST} -d /system/lib; then echo systemlib; fi))\r\n              LIBPATH += /system/lib\r\n            endif\r\n            LIBPATH += $(LD_LIBRARY_PATH)\r\n          endif\r\n          ifeq (ldconfig,$(shell if ${TEST} -e /sbin/ldconfig; then echo ldconfig; fi))\r\n            LIBPATH := $(sort $(foreach lib,$(shell /sbin/ldconfig -p | grep ' => /' | sed 's/^.* => //'),$(dir $(lib))))\r\n          endif\r\n        endif\r\n        LIBSOEXT = so\r\n        LIBEXT = $(LIBSOEXT) a\r\n      else\r\n        ifeq (SunOS,$(OSTYPE))\r\n          OSNAME = Solaris\r\n          ifneq (lib,$(findstring lib,$(UNSUPPORTED_BUILD)))\r\n            LIBPATH := $(shell LANG=C; crle | grep 'Default Library Path' | awk '{ print $$5 }' | sed 's/:/ /g')\r\n          endif\r\n          LIBEXT = so\r\n          OS_LDFLAGS += -lsocket -lnsl\r\n          ifeq (incsfw,$(shell if ${TEST} -d /opt/sfw/include; then echo incsfw; fi))\r\n            INCPATH += /opt/sfw/include\r\n            OS_CCDEFS += -I/opt/sfw/include\r\n          endif\r\n          ifeq (libsfw,$(shell if ${TEST} -d /opt/sfw/lib; then echo libsfw; fi))\r\n            LIBPATH += /opt/sfw/lib\r\n            OS_LDFLAGS += -L/opt/sfw/lib -R/opt/sfw/lib\r\n          endif\r\n          OS_CCDEFS += -D_LARGEFILE_SOURCE\r\n        else\r\n          ifeq (cygwin,$(OSTYPE))\r\n            # use 0readme_ethernet.txt documented Windows pcap build components\r\n            INCPATH += ../windows-build/winpcap/WpdPack/Include\r\n            LIBPATH += ../windows-build/winpcap/WpdPack/Lib\r\n            PCAPLIB = wpcap\r\n            LIBEXT = a\r\n          else\r\n            ifneq (,$(findstring AIX,$(OSTYPE)))\r\n              OS_LDFLAGS += -lm -lrt\r\n              ifeq (incopt,$(shell if ${TEST} -d /opt/freeware/include; then echo incopt; fi))\r\n                INCPATH += /opt/freeware/include\r\n                OS_CCDEFS += -I/opt/freeware/include\r\n              endif\r\n              ifeq (libopt,$(shell if ${TEST} -d /opt/freeware/lib; then echo libopt; fi))\r\n                LIBPATH += /opt/freeware/lib\r\n                OS_LDFLAGS += -L/opt/freeware/lib\r\n              endif\r\n            else\r\n              ifneq (,$(findstring Haiku,$(OSTYPE)))\r\n                HAIKU_ARCH=$(shell getarch)\r\n                ifeq ($(HAIKU_ARCH),)\r\n                  $(error Missing getarch command, your Haiku release is probably too old)\r\n                endif\r\n                ifeq ($(HAIKU_ARCH),x86_gcc2)\r\n                  $(error Unsupported arch x86_gcc2. Run setarch x86 and retry)\r\n                endif\r\n                INCPATH := $(shell findpaths -e -a $(HAIKU_ARCH) B_FIND_PATH_HEADERS_DIRECTORY)\r\n                INCPATH += $(shell findpaths -e B_FIND_PATH_HEADERS_DIRECTORY posix)\r\n                LIBPATH := $(shell findpaths -e -a $(HAIKU_ARCH) B_FIND_PATH_DEVELOP_LIB_DIRECTORY)\r\n                OS_LDFLAGS += -lnetwork\r\n              else\r\n                ifeq (,$(findstring NetBSD,$(OSTYPE)))\r\n                  ifneq (no ldconfig,$(findstring no ldconfig,$(shell which ldconfig 2>&1)))\r\n                    LDSEARCH :=$(shell LANG=C; ldconfig -r | grep 'search directories' | awk '{print $$3}' | sed 's/:/ /g')\r\n                  endif\r\n                  ifneq (,$(LDSEARCH))\r\n                    LIBPATH := $(LDSEARCH)\r\n                  else\r\n                    ifeq (,$(strip $(LPATH)))\r\n                      $(info *** Warning ***)\r\n                      $(info *** Warning *** The library search path on your $(OSTYPE) platform can not be)\r\n                      $(info *** Warning *** determined.  This should be resolved before you can expect)\r\n                      $(info *** Warning *** to have fully working simulators.)\r\n                      $(info *** Warning ***)\r\n                      $(info *** Warning *** You can specify your library paths via the LPATH environment)\r\n                      $(info *** Warning *** variable.)\r\n                      $(info *** Warning ***)\r\n                    else\r\n                      LIBPATH = $(subst :, ,$(LPATH))\r\n                    endif\r\n                  endif\r\n                  OS_LDFLAGS += $(patsubst %,-L%,${LIBPATH})\r\n                endif\r\n              endif\r\n            endif\r\n            ifeq (usrpkglib,$(shell if ${TEST} -d /usr/pkg/lib; then echo usrpkglib; fi))\r\n              LIBPATH += /usr/pkg/lib\r\n              INCPATH += /usr/pkg/include\r\n              OS_LDFLAGS += -L/usr/pkg/lib -R/usr/pkg/lib\r\n              OS_CCDEFS += -I/usr/pkg/include\r\n            endif\r\n            ifeq (/usr/local/lib,$(findstring /usr/local/lib,${LIBPATH}))\r\n              INCPATH += /usr/local/include\r\n              OS_CCDEFS += -I/usr/local/include\r\n            endif\r\n            ifneq (,$(findstring NetBSD,$(OSTYPE))$(findstring FreeBSD,$(OSTYPE))$(findstring AIX,$(OSTYPE)))\r\n              LIBEXT = so\r\n            else\r\n              ifeq (HP-UX,$(OSTYPE))\r\n                ifeq (ia64,$(shell uname -m))\r\n                  LIBEXT = so\r\n                else\r\n                  LIBEXT = sl\r\n                endif\r\n                OS_CCDEFS += -D_HPUX_SOURCE -D_LARGEFILE64_SOURCE\r\n                OS_LDFLAGS += -Wl,+b:\r\n                override LTO =\r\n              else\r\n                LIBEXT = a\r\n              endif\r\n            endif\r\n          endif\r\n        endif\r\n      endif\r\n    endif\r\n    ifeq (,$(LIBSOEXT))\r\n      LIBSOEXT = $(LIBEXT)\r\n    endif\r\n    ifeq (,$(filter /lib/,$(LIBPATH)))\r\n      ifeq (existlib,$(shell if $(TEST) -d /lib/; then echo existlib; fi))\r\n        LIBPATH += /lib/\r\n      endif\r\n    endif\r\n    ifeq (,$(filter /usr/lib/,$(LIBPATH)))\r\n      ifeq (existusrlib,$(shell if $(TEST) -d /usr/lib/; then echo existusrlib; fi))\r\n        LIBPATH += /usr/lib/\r\n      endif\r\n    endif\r\n    export CPATH = $(subst $() $(),:,$(INCPATH))\r\n    export LIBRARY_PATH = $(subst $() $(),:,$(LIBPATH))\r\n  endif\r\n  $(info lib paths are: ${LIBPATH})\r\n  $(info include paths are: ${INCPATH})\r\n  need_search = $(strip $(shell ld -l$(1) /dev/null 2>&1 | grep $(1) | sed s/$(1)//))\r\n  LD_SEARCH_NEEDED := $(call need_search,ZzzzzzzZ)\r\n  ifneq (,$(call find_lib,m))\r\n    OS_LDFLAGS += -lm\r\n    $(info using libm: $(call find_lib,m))\r\n  endif\r\n  ifneq (,$(call find_lib,rt))\r\n    OS_LDFLAGS += -lrt\r\n    $(info using librt: $(call find_lib,rt))\r\n  endif\r\n  ifneq (,$(call find_include,pthread))\r\n    ifneq (,$(call find_lib,pthread))\r\n      PTHREAD_CCDEFS += -DSIM_ASYNCH_IO\r\n      PTHREAD_LDFLAGS += -lpthread\r\n      $(info using libpthread: $(call find_lib,pthread) $(call find_include,pthread))\r\n    else\r\n      LIBEXTSAVE := ${LIBEXT}\r\n      LIBEXT = a\r\n      ifneq (,$(call find_lib,pthread))\r\n        PTHREAD_CCDEFS += -DSIM_ASYNCH_IO\r\n        PTHREAD_LDFLAGS += -lpthread\r\n        $(info using libpthread: $(call find_lib,pthread) $(call find_include,pthread))\r\n      else\r\n        ifneq (,$(findstring Haiku,$(OSTYPE)))\r\n          PTHREAD_CCDEFS += -DUSE_READER_THREAD -DSIM_ASYNCH_IO\r\n          $(info using libpthread: $(call find_include,pthread))\r\n        else\r\n          ifeq (Darwin,$(OSTYPE))\r\n            PTHREAD_CCDEFS += -DUSE_READER_THREAD -DSIM_ASYNCH_IO\r\n            PTHREAD_LDFLAGS += -lpthread\r\n            $(info using macOS libpthread: $(call find_include,pthread))\r\n          endif\r\n        endif\r\n      endif\r\n      LIBEXT = $(LIBEXTSAVE)\r\n    endif\r\n  endif\r\n  # Find PCRE RegEx library.\r\n  ifneq (,$(call find_include,pcre))\r\n    ifneq (,$(call find_lib,pcre))\r\n      $(info using libpcre: $(call find_lib,pcre) $(call find_include,pcre))\r\n      ifneq (,$(ALL_DEPENDENCIES))\r\n        OS_CCDEFS += -DHAVE_PCRE_H\r\n        OS_LDFLAGS += -lpcre\r\n        ifeq ($(LD_SEARCH_NEEDED),$(call need_search,pcre))\r\n          OS_LDFLAGS += -L$(dir $(call find_lib,pcre))\r\n        endif\r\n      endif\r\n    else\r\n      NEEDED_PKGS += DPKG_PCRE\r\n    endif\r\n  else\r\n    NEEDED_PKGS += DPKG_PCRE\r\n  endif\r\n  # Find libedit BSD licensed library for readline support.\r\n  ifneq (,$(call find_lib,edit))\r\n    ifneq (,$(call find_include,editline/readline))\r\n      $(info using libedit: $(call find_lib,edit) $(call find_include,editline/readline))\r\n      ifneq (,$(ALL_DEPENDENCIES))\r\n        OS_CCDEFS += -DHAVE_LIBEDIT\r\n        OS_LDFLAGS += -ledit\r\n        ifneq (,$(call find_lib,termcap))\r\n          OS_LDFLAGS += -ltermcap\r\n        endif\r\n        ifeq ($(LD_SEARCH_NEEDED),$(call need_search,edit))\r\n          OS_LDFLAGS += -L$(dir $(call find_lib,edit))\r\n        endif\r\n      endif\r\n    else\r\n      NEEDED_PKGS += DPKG_EDITLINE\r\n    endif\r\n  else\r\n    NEEDED_PKGS += DPKG_EDITLINE\r\n  endif\r\n  # The recursive logic needs a GNU make at least v4 when building with \r\n  # separate compiles\r\n  ifneq (,$(call find_exe,gmake))\r\n    override MAKE = $(call find_exe,gmake)\r\n  endif\r\n  ifneq (,$(and $(findstring 3.,$(GNUMakeVERSION)),$(BUILD_SEPARATE)))\r\n    NEEDED_PKGS += DPKG_GMAKE\r\n  endif\r\n  # Find available ncurses library.\r\n  ifneq (,$(call find_include,ncurses))\r\n    ifneq (,$(call find_lib,ncurses))\r\n      OS_CURSES_DEFS += -DHAVE_NCURSES -lncurses\r\n    endif\r\n  endif\r\n  ifneq (,$(call find_include,semaphore))\r\n    ifneq (, $(shell grep sem_timedwait $(call find_include,semaphore)))\r\n      OS_CCDEFS += -DHAVE_SEMAPHORE\r\n      $(info using semaphore: $(call find_include,semaphore))\r\n    endif\r\n  endif\r\n  ifneq (,$(call find_include,sys/ioctl))\r\n    OS_CCDEFS += -DHAVE_SYS_IOCTL\r\n  endif\r\n  ifneq (,$(call find_include,linux/cdrom))\r\n    OS_CCDEFS += -DHAVE_LINUX_CDROM\r\n  endif\r\n  ifneq (,$(call find_include,dlfcn))\r\n    ifneq (,$(call find_lib,dl))\r\n      OS_CCDEFS += -DSIM_HAVE_DLOPEN=$(LIBSOEXT)\r\n      OS_LDFLAGS += -ldl\r\n      $(info using libdl: $(call find_lib,dl) $(call find_include,dlfcn))\r\n    else\r\n      ifneq (,$(findstring BSD,$(OSTYPE))$(findstring AIX,$(OSTYPE))$(findstring Haiku,$(OSTYPE)))\r\n        OS_CCDEFS += -DSIM_HAVE_DLOPEN=so\r\n        $(info using libdl: $(call find_include,dlfcn))\r\n      else\r\n        ifneq (,$(call find_lib,dld))\r\n          OS_CCDEFS += -DSIM_HAVE_DLOPEN=$(LIBSOEXT)\r\n          OS_LDFLAGS += -ldld\r\n          $(info using libdld: $(call find_lib,dld) $(call find_include,dlfcn))\r\n        else\r\n          ifeq (Darwin,$(OSTYPE))\r\n            OS_CCDEFS += -DSIM_HAVE_DLOPEN=dylib\r\n            $(info using macOS dlopen with .dylib)\r\n          endif\r\n        endif\r\n      endif\r\n    endif\r\n  endif\r\n  ifneq (,$(call find_include,utime))\r\n    OS_CCDEFS += -DHAVE_UTIME\r\n  endif\r\n  ifneq (,$(call find_include,png))\r\n    ifneq (,$(call find_lib,png))\r\n      $(info using libpng: $(call find_lib,png) $(call find_include,png))\r\n      PNG_CCDEFS += -DHAVE_LIBPNG\r\n      ifneq (,$(ALL_DEPENDENCIES))\r\n        PNG_LDFLAGS += -lpng\r\n      endif\r\n      ifneq (,$(call find_include,zlib))\r\n        ifneq (,$(call find_lib,z))\r\n          $(info using zlib: $(call find_lib,z) $(call find_include,zlib))\r\n          PNG_CCDEFS += -DHAVE_ZLIB\r\n          ifneq (,$(ALL_DEPENDENCIES))\r\n            PNG_LDFLAGS += -lz\r\n          endif\r\n        else\r\n          NEEDED_PKGS += DPKG_ZLIB\r\n        endif\r\n      else\r\n        NEEDED_PKGS += DPKG_ZLIB\r\n      endif\r\n    else\r\n      # some systems may name the png library libpng16\r\n      ifneq (,$(call find_lib,png16))\r\n        PNG_CCDEFS += -DHAVE_LIBPNG\r\n        PNG_LDFLAGS += -lpng16\r\n        $(info using libpng: $(call find_lib,png16) $(call find_include,png))\r\n        ifneq (,$(call find_include,zlib))\r\n          ifneq (,$(call find_lib,z))\r\n            PNG_CCDEFS += -DHAVE_ZLIB\r\n            PNG_LDFLAGS += -lz\r\n            $(info using zlib: $(call find_lib,z) $(call find_include,zlib))\r\n          else\r\n            NEEDED_PKGS += DPKG_ZLIB\r\n          endif\r\n        endif\r\n      else\r\n        NEEDED_PKGS += DPKG_PNG\r\n      endif\r\n    endif\r\n  else\r\n    NEEDED_PKGS += DPKG_PNG\r\n  endif\r\n  ifneq (,$(call find_include,glob))\r\n    OS_CCDEFS += -DHAVE_GLOB\r\n  else\r\n    ifneq (,$(call find_include,fnmatch))\r\n      OS_CCDEFS += -DHAVE_FNMATCH\r\n    endif\r\n  endif\r\n  ifneq (,$(call find_include,sys/mman))\r\n    ifneq (,$(shell grep shm_open $(call find_include,sys/mman)))\r\n      # some Linux installs have been known to have the include, but are\r\n      # missing librt (where the shm_ APIs are implemented on Linux)\r\n      # other OSes seem have these APIs implemented elsewhere\r\n      ifneq (,$(if $(findstring Linux,$(OSTYPE)),$(call find_lib,rt),OK))\r\n        OS_CCDEFS += -DHAVE_SHM_OPEN\r\n        $(info using mman: $(call find_include,sys/mman))\r\n      endif\r\n    endif\r\n  endif\r\n  ifneq (,$(VIDEO_USEFUL))\r\n    ifeq (cygwin,$(OSTYPE))\r\n      LIBEXTSAVE := ${LIBEXT}\r\n      LIBEXT = dll.a\r\n    endif\r\n    ifneq (,$(call find_include,SDL2/SDL))\r\n      ifneq (,$(call find_lib,SDL2))\r\n        ifneq (,$(call find_exe,sdl2-config))\r\n          SDLX_CONFIG = sdl2-config\r\n        endif\r\n        ifneq (,$(SDLX_CONFIG))\r\n          VIDEO_CCDEFS += -DHAVE_LIBSDL `$(SDLX_CONFIG) --cflags` $(PNG_CCDEFS)\r\n          VIDEO_LDFLAGS += `$(SDLX_CONFIG) --libs` $(PNG_LDFLAGS)\r\n          VIDEO_FEATURES = - video capabilities provided by libSDL2 (Simple Directmedia Layer)\r\n          DISPLAYL = ${DISPLAYD}/display.c $(DISPLAYD)/sim_ws.c\r\n          DISPLAYVT = ${DISPLAYD}/vt11.c\r\n          DISPLAY340 = ${DISPLAYD}/type340.c\r\n          DISPLAYNG = ${DISPLAYD}/ng.c\r\n          DISPLAYIII = ${DISPLAYD}/iii.c\r\n          DISPLAY_OPT += -DUSE_DISPLAY $(VIDEO_CCDEFS) -DUSE_SIM_VIDEO\r\n          $(info using libSDL2: $(call find_include,SDL2/SDL))\r\n        endif\r\n      else\r\n        NEEDED_PKGS += DPKG_SDL\r\n      endif\r\n    else\r\n      NEEDED_PKGS += DPKG_SDL\r\n    endif\r\n    ifneq (,$(BESM6_BUILD))\r\n      ifneq (,$(and $(findstring sdl2,${VIDEO_LDFLAGS}),$(call find_include,SDL2/SDL_ttf),$(call find_lib,SDL2_ttf)))\r\n        $(info using libSDL2_ttf: $(call find_lib,SDL2_ttf) $(call find_include,SDL2/SDL_ttf))\r\n        $(info ***)\r\n        VIDEO_TTF_OPT = $(VIDEO_CCDEFS) -DHAVE_LIBSDL_TTF\r\n        VIDEO_TTF_LDFLAGS += -lSDL2_ttf\r\n        VIDEO_FEATURES += with TrueType font support\r\n        # Retain support for explicitly supplying a preferred fontfile\r\n        ifneq (,$(FONTFILE))\r\n          VIDEO_TTF_OPT +=  -DFONTFILE=${FONTFILE}\r\n        endif\r\n      else\r\n        NEEDED_PKGS += DPKG_SDL_TTF\r\n      endif\r\n      ifneq (,$(and $(VIDEO_CCDEFS),$(PTHREAD_CCDEFS)))\r\n        VIDEO_CCDEFS += $(PTHREAD_CCDEFS)\r\n        VIDEO_LDFLAGS += $(PTHREAD_LDFLAGS)\r\n      endif\r\n    endif\r\n  endif\r\n  ifneq (,$(NETWORK_USEFUL))\r\n    ifneq (,$(call find_include,pcap))\r\n      ifneq (,$(shell grep 'pcap/pcap.h' $(call find_include,pcap) | grep include))\r\n        PCAP_H_PATH = $(dir $(call find_include,pcap))pcap/pcap.h\r\n      else\r\n        PCAP_H_PATH = $(call find_include,pcap)\r\n      endif\r\n      ifneq (,$(shell grep pcap_compile $(PCAP_H_PATH) | grep const))\r\n        BPF_CONST_STRING = -DBPF_CONST_STRING\r\n      endif\r\n      NETWORK_CCDEFS += -DHAVE_PCAP_NETWORK -I$(dir $(call find_include,pcap)) $(BPF_CONST_STRING)\r\n      NETWORK_LAN_FEATURES += PCAP\r\n      ifneq (,$(call find_lib,$(PCAPLIB)))\r\n        ifneq ($(USE_NETWORK),) # Network support specified on the GNU make command line\r\n          NETWORK_CCDEFS += -DUSE_NETWORK\r\n          ifeq (,$(findstring Linux,$(OSTYPE))$(findstring Darwin,$(OSTYPE)))\r\n            $(info *** Warning ***)\r\n            $(info *** Warning *** Directly linking against libpcap is provides no measurable)\r\n            $(info *** Warning *** benefits over dynamically linking libpcap.)\r\n            $(info *** Warning ***)\r\n            $(info *** Warning *** Support for linking this way is currently deprecated and may be removed)\r\n            $(info *** Warning *** in the future.)\r\n            $(info *** Warning ***)\r\n          else\r\n            $(info *** Error ***)\r\n            $(info *** Error *** Directly linking against libpcap is provides no measurable)\r\n            $(info *** Error *** benefits over dynamically linking libpcap.)\r\n            $(info *** Error ***)\r\n            $(info *** Error *** Support for linking directly has been removed on the $(OSTYPE))\r\n            $(info *** Error *** platform.)\r\n            $(info *** Error ***)\r\n            $(error Retry your build without specifying USE_NETWORK=1)\r\n          endif\r\n          ifeq (cygwin,$(OSTYPE))\r\n            # cygwin has no ldconfig so explicitly specify pcap object library\r\n            NETWORK_LDFLAGS = -L$(dir $(call find_lib,$(PCAPLIB))) -Wl,-R,$(dir $(call find_lib,$(PCAPLIB))) -l$(PCAPLIB)\r\n          else\r\n            NETWORK_LDFLAGS = -l$(PCAPLIB)\r\n          endif\r\n          $(info using libpcap: $(call find_lib,$(PCAPLIB)) $(call find_include,pcap))\r\n          NETWORK_FEATURES = - static networking support using $(OSNAME) provided libpcap components\r\n        else # default build uses dynamic libpcap\r\n          NETWORK_CCDEFS += -DUSE_SHARED\r\n          $(info using libpcap: $(call find_include,pcap))\r\n          NETWORK_FEATURES = - dynamic networking support using $(OSNAME) provided libpcap components\r\n        endif\r\n      else\r\n        LIBEXTSAVE := ${LIBEXT}\r\n        LIBEXT = a\r\n        ifneq (,$(call find_lib,$(PCAPLIB)))\r\n          NETWORK_CCDEFS += -DUSE_NETWORK\r\n          NETWORK_LDFLAGS := -L$(dir $(call find_lib,$(PCAPLIB))) -l$(PCAPLIB)\r\n          NETWORK_FEATURES = - static networking support using $(OSNAME) provided libpcap components\r\n          $(info using libpcap: $(call find_lib,$(PCAPLIB)) $(call find_include,pcap))\r\n        endif\r\n        LIBEXT = $(LIBEXTSAVE)\r\n        ifeq (Darwin,$(OSTYPE)$(findstring USE_,$(NETWORK_CCDEFS)))\r\n          NETWORK_CCDEFS += -DUSE_SHARED\r\n          NETWORK_FEATURES = - dynamic networking support using $(OSNAME) provided libpcap components\r\n          $(info using macOS dynamic libpcap: $(call find_include,pcap))\r\n        endif\r\n      endif\r\n    else # pcap desired but pcap.h not found\r\n      ifneq (,$(call find_lib,$(PCAPLIB)))\r\n        PCAP_LIB_VERSION = $(shell strings $(call find_lib,$(PCAPLIB)) | grep 'libpcap version' | awk '{ print $$3}')\r\n        PCAP_LIB_BASE_VERSION = $(firstword $(subst ., ,$(PCAP_LIB_VERSION)))\r\n      endif\r\n      NEEDED_PKGS += DPKG_PCAP\r\n      # On non-Linux platforms, we'll still try to provide deprecated support for libpcap in /usr/local\r\n      INCPATHSAVE := ${INCPATH}\r\n      ifeq (,$(findstring Linux,$(OSTYPE)))\r\n        # Look for package built from tcpdump.org sources with default install target (or cygwin winpcap)\r\n        INCPATH += /usr/local/include\r\n        PCAP_H_FOUND = $(call find_include,pcap)\r\n      endif\r\n      ifneq (,$(strip $(PCAP_H_FOUND)))\r\n        ifneq (,$(shell grep 'pcap/pcap.h' $(call find_include,pcap) | grep include))\r\n          PCAP_H_PATH = $(dir $(call find_include,pcap))pcap/pcap.h\r\n        else\r\n          PCAP_H_PATH = $(call find_include,pcap)\r\n        endif\r\n        ifneq (,$(shell grep pcap_compile $(PCAP_H_PATH) | grep const))\r\n          BPF_CONST_STRING = -DBPF_CONST_STRING\r\n        endif\r\n        LIBEXTSAVE := ${LIBEXT}\r\n        # first check if binary - shared objects are available/installed in the linker known search paths\r\n        ifneq (,$(call find_lib,$(PCAPLIB)))\r\n          NETWORK_CCDEFS = -DUSE_SHARED -I$(dir $(call find_include,pcap)) $(BPF_CONST_STRING)\r\n          NETWORK_FEATURES = - dynamic networking support using libpcap components from www.tcpdump.org and locally installed libpcap.${LIBEXT}\r\n          $(info using libpcap: $(call find_include,pcap))\r\n        else\r\n          LIBPATH += /usr/local/lib\r\n          LIBEXT = a\r\n          ifneq (,$(call find_lib,$(PCAPLIB)))\r\n            $(info using libpcap: $(call find_lib,$(PCAPLIB)) $(call find_include,pcap))\r\n            ifeq (cygwin,$(OSTYPE))\r\n              NETWORK_CCDEFS = -DUSE_NETWORK -DHAVE_PCAP_NETWORK -I$(dir $(call find_include,pcap)) $(BPF_CONST_STRING)\r\n              NETWORK_LDFLAGS = -L$(dir $(call find_lib,$(PCAPLIB))) -Wl,-R,$(dir $(call find_lib,$(PCAPLIB))) -l$(PCAPLIB)\r\n              NETWORK_FEATURES = - static networking support using libpcap components located in the cygwin directories\r\n            else\r\n              NETWORK_CCDEFS := -DUSE_NETWORK -DHAVE_PCAP_NETWORK -isystem -I$(dir $(call find_include,pcap)) $(BPF_CONST_STRING) $(call find_lib,$(PCAPLIB))\r\n              NETWORK_FEATURES = - networking support using libpcap components from www.tcpdump.org\r\n              $(info *** Warning ***)\r\n              $(info *** Warning *** $(BUILD_SINGLE)Simulator$(BUILD_MULTIPLE) being built with networking support using)\r\n              $(info *** Warning *** libpcap components from www.tcpdump.org.)\r\n              $(info *** Warning *** Some users have had problems using the www.tcpdump.org libpcap)\r\n              $(info *** Warning *** components for simh networking.  For best results, with)\r\n              $(info *** Warning *** simh networking, it is recommended that you install the)\r\n              $(info *** Warning *** libpcap-dev (or libpcap-devel) package from your $(OSNAME) distribution)\r\n              $(info *** Warning ***)\r\n              $(info *** Warning *** Building with the components manually installed from www.tcpdump.org)\r\n              $(info *** Warning *** is officially deprecated.  Attempting to do so is unsupported.)\r\n              $(info *** Warning ***)\r\n            endif\r\n          else\r\n            $(error using libpcap: $(call find_include,pcap) missing $(PCAPLIB).${LIBEXT})\r\n          endif\r\n          NETWORK_LAN_FEATURES += PCAP\r\n        endif\r\n        LIBEXT = $(LIBEXTSAVE)\r\n      else\r\n        INCPATH = $(INCPATHSAVE)\r\n        ifeq (1,$(PCAP_LIB_BASE_VERSION))\r\n          $(info using libpcap $(PCAP_LIB_VERSION) without an available pcap.h)\r\n          NETWORK_CCDEFS = -DUSE_SHARED -DHAVE_PCAP_NETWORK -DPCAP_LIB_VERSION=$(PCAP_LIB_VERSION)\r\n          NETWORK_FEATURES = - dynamic networking support using libpcap components from www.tcpdump.org and locally installed libpcap.${LIBEXT}\r\n          NETWORK_LAN_FEATURES += PCAP\r\n          NEEDED_PKGS := $(filter-out DPKG_PCAP,$(NEEDED_PKGS))\r\n        else\r\n          $(info *** Warning ***)\r\n          $(info *** Warning *** $(BUILD_SINGLE)Simulator$(BUILD_MULTIPLE) $(BUILD_MULTIPLE_VERB) being built WITHOUT)\r\n          $(info *** Warning *** libpcap networking support)\r\n          $(info *** Warning ***)\r\n          $(info *** Warning *** To build simulator(s) with libpcap networking support you)\r\n          $(info *** Warning *** should install the libpcap development components for)\r\n          $(info *** Warning *** for your $(OSNAME) system.)\r\n          ifeq (,$(or $(findstring Linux,$(OSTYPE)),$(findstring OSX,$(OSNAME))))\r\n            $(info *** Warning *** You should read 0readme_ethernet.txt and follow the instructions)\r\n            $(info *** Warning *** regarding the needed libpcap development components for your)\r\n            $(info *** Warning *** $(OSNAME) platform.)\r\n          endif\r\n          $(info *** Warning ***)\r\n        endif\r\n      endif\r\n    endif\r\n    # Consider other network connections\r\n    ifneq (,$(call find_lib,vdeplug))\r\n      # libvdeplug requires the use of the OS provided libpcap\r\n      ifeq (,$(findstring usr/local,$(NETWORK_CCDEFS)))\r\n        ifneq (,$(call find_include,libvdeplug))\r\n          # Provide support for vde networking\r\n          NETWORK_CCDEFS += -DHAVE_VDE_NETWORK\r\n          NETWORK_LAN_FEATURES += VDE\r\n          ifeq (,$(findstring USE_NETWORK,$(NETWORK_CCDEFS))$(findstring USE_SHARED,$(NETWORK_CCDEFS)))\r\n            NETWORK_CCDEFS += -DUSE_NETWORK\r\n          endif\r\n          ifeq (Darwin,$(OSTYPE))\r\n            NETWORK_LDFLAGS += -lvdeplug -L$(dir $(call find_lib,vdeplug))\r\n          else\r\n            NETWORK_LDFLAGS += -lvdeplug -Wl,-R,$(dir $(call find_lib,vdeplug)) -L$(dir $(call find_lib,vdeplug))\r\n          endif\r\n          $(info using libvdeplug: $(call find_lib,vdeplug) $(call find_include,libvdeplug))\r\n        endif\r\n      else\r\n        ifeq (,$(findstring PKG_PCAP, $(NEEDED_PKGS)))\r\n          NEEDED_PKGS += DPKG_PCAP\r\n        endif\r\n      endif\r\n    else\r\n      NEEDED_PKGS += DPKG_VDE\r\n    endif\r\n    ifneq (,$(call find_include,linux/if_tun))\r\n      # Provide support for Tap networking on Linux\r\n      NETWORK_CCDEFS += -DHAVE_TAP_NETWORK\r\n      NETWORK_LAN_FEATURES += TAP\r\n      ifeq (,$(findstring USE_NETWORK,$(NETWORK_CCDEFS))$(findstring USE_SHARED,$(NETWORK_CCDEFS)))\r\n        NETWORK_CCDEFS += -DUSE_NETWORK\r\n      endif\r\n    endif\r\n    ifeq (bsdtuntap,$(shell if ${TEST} -e /usr/include/net/if_tun.h -o -e /Library/Extensions/tap.kext -o -e /Applications/Tunnelblick.app/Contents/Resources/tap-notarized.kext; then echo bsdtuntap; fi))\r\n      # Provide support for Tap networking on BSD platforms (including OS X)\r\n      NETWORK_CCDEFS += -DHAVE_TAP_NETWORK -DHAVE_BSDTUNTAP\r\n      NETWORK_LAN_FEATURES += TAP\r\n      ifeq (,$(findstring USE_NETWORK,$(NETWORK_CCDEFS))$(findstring USE_SHARED,$(NETWORK_CCDEFS)))\r\n        NETWORK_CCDEFS += -DUSE_NETWORK\r\n      endif\r\n    endif\r\n    ifeq (slirp,$(shell if ${TEST} -e slirp_glue/sim_slirp.c; then echo slirp; fi))\r\n      NETWORK_CCDEFS += -I slirp -I slirp_glue -I slirp_glue/qemu -DHAVE_SLIRP_NETWORK -DUSE_SIMH_SLIRP_DEBUG \r\n      NETWORK_DEPS += slirp/*.c slirp_glue/*.c\r\n      NETWORK_LAN_FEATURES += NAT(SLiRP)\r\n    endif\r\n    ifneq (,$(and $(NETWORK_CCDEFS),$(PTHREAD_CCDEFS)))\r\n      NETWORK_CCDEFS += -DUSE_READER_THREAD $(PTHREAD_CCDEFS)\r\n      NETWORK_LDFLAGS += $(PTHREAD_LDFLAGS)\r\n    endif\r\n    NETWORK_OPT = $(NETWORK_CCDEFS)\r\n  endif\r\n  ifneq (binexists,$(shell if ${TEST} -e BIN/buildtools; then echo binexists; fi))\r\n    export MKDIRBIN\r\n    MKDIRBIN = @$(MKDIR) BIN/buildtools\r\n  endif\r\n  ifeq (commit-id-exists,$(shell if ${TEST} -e .git-commit-id; then echo commit-id-exists; fi))\r\n    GIT_COMMIT_ID=$(shell grep 'SIM_GIT_COMMIT_ID' .git-commit-id | awk '{ print $$2 }')\r\n    GIT_COMMIT_TIME=$(shell grep 'SIM_GIT_COMMIT_TIME' .git-commit-id | awk '{ print $$2 }')\r\n  else\r\n    ifeq (,$(shell grep 'define SIM_ARCHIVE_GIT_COMMIT_ID' sim_rev.h | grep 'Format:'))\r\n      GIT_COMMIT_ID=$(shell grep 'define SIM_ARCHIVE_GIT_COMMIT_ID' sim_rev.h | awk '{ print $$3 }')\r\n      GIT_COMMIT_TIME=$(shell grep 'define SIM_ARCHIVE_GIT_COMMIT_TIME' sim_rev.h | awk '{ print $$3 }')\r\n      GIT_ARCHIVE_COMMIT_ID=$(empty) $(empty)archive\r\n     else\r\n      ifeq (git-submodule,$(if $(shell cd .. ; git rev-parse --git-dir 2>/dev/null),git-submodule))\r\n        GIT_COMMIT_ID=$(shell cd .. ; git submodule status | grep \" $(notdir $(realpath .)) \" | awk '{ print $$1 }')\r\n        GIT_COMMIT_TIME=$(shell git $(REPO_PATH) --git-dir=$(realpath .)/.git log $(GIT_COMMIT_ID) -1 --pretty=\"%aI\")\r\n      else\r\n        $(info *** Error ***)\r\n        $(info *** Error *** The simh git commit id can not be determined.)\r\n        $(info *** Error ***)\r\n        $(info *** Error *** There are ONLY two supported ways to acquire and build)\r\n        $(info *** Error *** the simh source code:)\r\n        $(info *** Error ***   1: directly with git via:)\r\n        $(info *** Error ***      $$ git clone https://github.com/simh/simh)\r\n        $(info *** Error ***      $$ cd simh)\r\n        $(info *** Error ***      $$ make {simulator-name})\r\n        $(info *** Error *** OR)\r\n        $(info *** Error ***   2: download the source code zip archive from:)\r\n        $(info *** Error ***      $$ wget(or via browser) https://github.com/simh/simh/archive/master.zip)\r\n        $(info *** Error ***      $$ unzip master.zip)\r\n        $(info *** Error ***      $$ cd simh-master)\r\n        $(info *** Error ***      $$ make {simulator-name})\r\n        $(info *** Error ***)\r\n        $(error get simh source either with zip download or git clone)\r\n      endif\r\n    endif\r\n  endif\r\nelse\r\n  #Win32 Environments (via MinGW32)\r\n  GCC := gcc\r\n  GCC_Path := $(abspath $(dir $(word 1,$(wildcard $(addsuffix /${GCC}.exe,$(subst ;, ,${PATH}))))))\r\n  ifeq (rename-build-support,$(shell if exist ..\\windows-build-windows-build echo rename-build-support))\r\n    REMOVE_OLD_BUILD := $(shell if exist ..\\windows-build rmdir/s/q ..\\windows-build)\r\n    FIXED_BUILD := $(shell move ..\\windows-build-windows-build ..\\windows-build >NUL)\r\n  endif\r\n  GCC_VERSION = $(word 3,$(shell ${GCC} --version))\r\n  COMPILER_NAME = GCC Version: $(GCC_VERSION)\r\n  ifeq (,$(findstring ++,${GCC}))\r\n    CC_STD = -std=gnu99\r\n  else\r\n    export CPP_BUILD = 1\r\n  endif\r\n  LTO_EXCLUDE_VERSIONS = 4.5.2\r\n  ifeq (,$(PATH_SEPARATOR))\r\n    PATH_SEPARATOR := ;\r\n  endif\r\n  INCPATH = $(abspath $(wildcard $(GCC_Path)\\..\\include $(subst $(PATH_SEPARATOR), ,$(CPATH))  $(subst $(PATH_SEPARATOR), ,$(C_INCLUDE_PATH))))\r\n  LIBPATH = $(abspath $(wildcard $(GCC_Path)\\..\\lib $(subst :, ,$(LIBRARY_PATH))))\r\n  $(info lib paths are: ${LIBPATH})\r\n  $(info include paths are: ${INCPATH})\r\n  # Give preference to any MinGW provided threading (if available)\r\n  ifneq (,$(call find_include,pthread))\r\n    PTHREADS_CCDEFS = -DUSE_READER_THREAD -DSIM_ASYNCH_IO\r\n    PTHREADS_LDFLAGS = -lpthread\r\n  else\r\n    ifeq (pthreads,$(shell if exist ..\\windows-build\\pthreads\\Pre-built.2\\include\\pthread.h echo pthreads))\r\n      PTHREADS_CCDEFS = -DUSE_READER_THREAD -DPTW32_STATIC_LIB -D_POSIX_C_SOURCE -I../windows-build/pthreads/Pre-built.2/include -DSIM_ASYNCH_IO\r\n      PTHREADS_LDFLAGS = -lpthreadGC2 -L..\\windows-build\\pthreads\\Pre-built.2\\lib\r\n    endif\r\n  endif\r\n  ifeq (pcap,$(shell if exist ..\\windows-build\\winpcap\\Wpdpack\\include\\pcap.h echo pcap))\r\n    NETWORK_LDFLAGS =\r\n    NETWORK_OPT = -DUSE_SHARED -I../windows-build/winpcap/Wpdpack/include\r\n    NETWORK_FEATURES = - dynamic networking support using windows-build provided libpcap components\r\n    NETWORK_LAN_FEATURES += PCAP\r\n  else\r\n    ifneq (,$(call find_include,pcap))\r\n      NETWORK_LDFLAGS =\r\n      NETWORK_OPT = -DUSE_SHARED\r\n      NETWORK_FEATURES = - dynamic networking support using libpcap components found in the MinGW directories\r\n      NETWORK_LAN_FEATURES += PCAP\r\n    endif\r\n  endif\r\n  ifneq (,$(VIDEO_USEFUL))\r\n    SDL_INCLUDE = $(word 1,$(shell dir /b /s ..\\windows-build\\libSDL\\SDL.h))\r\n    ifeq (SDL.h,$(findstring SDL.h,$(SDL_INCLUDE)))\r\n      VIDEO_CCDEFS += -DHAVE_LIBSDL -DUSE_SIM_VIDEO -I$(abspath $(dir $(SDL_INCLUDE)))\r\n      ifneq ($(DEBUG),)\r\n        VIDEO_LDFLAGS  += $(abspath $(dir $(SDL_INCLUDE))\\..\\..\\..\\lib\\lib-VC2008\\Debug)/SDL2.lib\r\n      else\r\n        VIDEO_LDFLAGS  += $(abspath $(dir $(SDL_INCLUDE))\\..\\..\\..\\lib\\lib-VC2008\\Release)/SDL2.lib\r\n      endif\r\n      VIDEO_FEATURES = - video capabilities provided by libSDL2 (Simple Directmedia Layer)\r\n      DISPLAYL = ${DISPLAYD}/display.c $(DISPLAYD)/sim_ws.c\r\n      DISPLAYVT = ${DISPLAYD}/vt11.c\r\n      DISPLAY340 = ${DISPLAYD}/type340.c\r\n      DISPLAYNG = ${DISPLAYD}/ng.c\r\n      DISPLAY_OPT += -DUSE_DISPLAY $(VIDEO_CCDEFS)\r\n    else\r\n      $(info ***********************************************************************)\r\n      $(info ***********************************************************************)\r\n      $(info **  This build could produce simulators with video capabilities.     **)\r\n      $(info **  However, the required files to achieve this can not be found on  **)\r\n      $(info **  on this system.  Download the file:                              **)\r\n      $(info **  https://github.com/simh/windows-build/archive/windows-build.zip  **)\r\n      $(info **  Extract the windows-build-windows-build folder it contains to    **)\r\n      $(info **  $(abspath ..\\)                                                   **)\r\n      $(info ***********************************************************************)\r\n      $(info ***********************************************************************)\r\n      $(info .)\r\n    endif\r\n  endif\r\n  OS_CCDEFS += -fms-extensions $(PTHREADS_CCDEFS)\r\n  OS_LDFLAGS += -lm -lwsock32 -lwinmm $(PTHREADS_LDFLAGS)\r\n  EXE = .exe\r\n  ifeq (,$(findstring clean,${MAKECMDGOALS}))\r\n    ifneq (buildtoolsexists,$(shell if exist BIN\\buildtools (echo buildtoolsexists) else (mkdir BIN\\buildtools)))\r\n      MKDIRBIN=\r\n    endif\r\n  endif\r\n  ifneq ($(USE_NETWORK),)\r\n    NETWORK_OPT += -DUSE_SHARED\r\n  endif\r\n  ifeq (git-repo,$(shell if exist .git echo git-repo))\r\n    GIT_PATH := $(shell where git)\r\n    ifeq (,$(GIT_PATH))\r\n      $(error building using a git repository, but git is not available)\r\n    endif\r\n    ifeq (commit-id-exists,$(shell if exist .git-commit-id echo commit-id-exists))\r\n      CURRENT_FULL_GIT_COMMIT_ID=$(shell for /F \"tokens=2\" %%i in (\"$(shell findstr /C:\"SIM_GIT_COMMIT_ID\" .git-commit-id)\") do echo %%i)\r\n      CURRENT_GIT_COMMIT_ID=$(word 1,$(subst +, , $(CURRENT_FULL_GIT_COMMIT_ID)))\r\n      ACTUAL_GIT_COMMIT_ID=$(strip $(shell $(REPO_PATH) git log -1 --pretty=%H))\r\n      ifneq ($(CURRENT_GIT_COMMIT_ID),$(ACTUAL_GIT_COMMIT_ID))\r\n        ifeq (,$(strip $(findstring scp.c,$(shell git $(REPO_PATH) diff --name-only))))\r\n          # scp.c hasn't changed, so we want to touch it to force it to recompile\r\n          # but touch isn't part of MinGW, so we do some git monkey business\r\n          NEED_COMMIT_ID = need-commit-id$(file >> scp.c,)$(shell git $(REPO_PATH) restore scp.c)\r\n        else\r\n          NEED_COMMIT_ID = need-commit-id\r\n        endif\r\n        # make sure that the invalidly formatted .git-commit-id file wasn't generated\r\n        # by legacy git hooks which need to be removed.\r\n        $(shell if exist .git\\hooks\\post-checkout del .git\\hooks\\post-checkout)\r\n        $(shell if exist .git\\hooks\\post-commit   del .git\\hooks\\post-commit)\r\n        $(shell if exist .git\\hooks\\post-merge    del .git\\hooks\\post-merge)\r\n      endif\r\n    else\r\n      ifeq (,$(strip $(findstring scp.c,$(shell git $(REPO_PATH) diff --name-only))))\r\n        NEED_COMMIT_ID = need-commit-id$(file >> scp.c,)$(shell git $(REPO_PATH) restore scp.c)\r\n      else\r\n        NEED_COMMIT_ID = need-commit-id\r\n      endif\r\n    endif\r\n    ifneq (,$(shell git $(REPO_PATH) update-index --refresh --))\r\n      ifeq (,$(findstring +uncommitted-changes,$(CURRENT_FULL_GIT_COMMIT_ID)))\r\n        ifeq (,$(strip $(findstring scp.c,$(shell git $(REPO_PATH) diff --name-only))))\r\n          GIT_EXTRA_FILES=+uncommitted-changes$(file >> scp.c,)$(shell git $(REPO_PATH) restore scp.c)\r\n        else\r\n          GIT_EXTRA_FILES=+uncommitted-changes\r\n        endif\r\n      else\r\n        GIT_EXTRA_FILES=+uncommitted-changes\r\n      endif\r\n    endif\r\n    ifneq (,$(or $(NEED_COMMIT_ID),$(GIT_EXTRA_FILES)))\r\n      isodatetime=$(shell git $(REPO_PATH) log -1 --pretty=%ai)\r\n      isodate=$(word 1,$(isodatetime))T$(word 2,$(isodatetime))$(word 3,$(isodatetime))\r\n      $(shell echo SIM_GIT_COMMIT_ID $(ACTUAL_GIT_COMMIT_ID)$(GIT_EXTRA_FILES)>.git-commit-id)\r\n      $(shell echo SIM_GIT_COMMIT_TIME $(isodate)>>.git-commit-id)\r\n    endif\r\n  endif\r\n  ifneq (,$(shell if exist .git-commit-id echo git-commit-id))\r\n    GIT_COMMIT_ID=$(shell for /F \"tokens=2\" %%i in (\"$(shell findstr /C:\"SIM_GIT_COMMIT_ID\" .git-commit-id)\") do echo %%i)\r\n    GIT_COMMIT_TIME=$(shell for /F \"tokens=2\" %%i in (\"$(shell findstr /C:\"SIM_GIT_COMMIT_TIME\" .git-commit-id)\") do echo %%i)\r\n  else\r\n    ifeq (,$(shell findstr /C:\"define SIM_GIT_COMMIT_ID\" sim_rev.h | findstr Format))\r\n      GIT_COMMIT_ID=$(shell for /F \"tokens=3\" %%i in (\"$(shell findstr /C:\"define SIM_GIT_COMMIT_ID\" sim_rev.h)\") do echo %%i)\r\n      GIT_COMMIT_TIME=$(shell for /F \"tokens=3\" %%i in (\"$(shell findstr /C:\"define SIM_GIT_COMMIT_TIME\" sim_rev.h)\") do echo %%i)\r\n    endif\r\n  endif\r\n  ifneq (windows-build,$(shell if exist ..\\windows-build\\README.md echo windows-build))\r\n    ifneq (,$(GIT_PATH))\r\n      $(info Cloning the windows-build dependencies into $(abspath ..)/windows-build)\r\n      $(shell git clone https://github.com/simh/windows-build ../windows-build)\r\n    else\r\n      ifneq (3,${SIM_MAJOR})\r\n        $(info ***********************************************************************)\r\n        $(info ***********************************************************************)\r\n        $(info **  This build is operating without the required windows-build       **)\r\n        $(info **  components and therefore will produce less than optimal          **)\r\n        $(info **  simulator operation and features.                                **)\r\n        $(info **  Download the file:                                               **)\r\n        $(info **  https://github.com/simh/windows-build/archive/windows-build.zip  **)\r\n        $(info **  Extract the windows-build-windows-build folder it contains to    **)\r\n        $(info **  $(abspath ..\\)                                                   **)\r\n        $(info ***********************************************************************)\r\n        $(info ***********************************************************************)\r\n        $(info .)\r\n      endif\r\n    endif\r\n  else\r\n    # Version check on windows-build\r\n    WINDOWS_BUILD = $(word 2,$(shell findstr WINDOWS-BUILD ..\\windows-build\\Windows-Build_Versions.txt))\r\n    ifeq (,$(WINDOWS_BUILD))\r\n      WINDOWS_BUILD = 00000000\r\n    endif\r\n    ifneq (,$(or $(shell if 20191001 GTR $(WINDOWS_BUILD) echo old-windows-build),$(and $(shell if 20171112 GTR $(WINDOWS_BUILD) echo old-windows-build),$(findstring pthreadGC2,$(PTHREADS_LDFLAGS)))))\r\n      $(info .)\r\n      $(info windows-build components at: $(abspath ..\\windows-build))\r\n      $(info .)\r\n      $(info ***********************************************************************)\r\n      $(info ***********************************************************************)\r\n      $(info **  This currently available windows-build components are out of     **)\r\n      ifneq (,$(GIT_PATH))\r\n        $(info **  date.  You need to update to the latest windows-build            **)\r\n        $(info **  dependencies by executing these commands:                        **)\r\n        $(info **                                                                   **)\r\n        $(info **    > cd ..\\windows-build                                          **)\r\n        $(info **    > git pull                                                     **)\r\n        $(info **                                                                   **)\r\n        $(info ***********************************************************************)\r\n        $(info ***********************************************************************)\r\n        $(error .)\r\n      else\r\n        $(info **  date.  For the most functional and stable features you should    **)\r\n        $(info **  Download the file:                                               **)\r\n        $(info **  https://github.com/simh/windows-build/archive/windows-build.zip  **)\r\n        $(info **  Extract the windows-build-windows-build folder it contains to    **)\r\n        $(info **  $(abspath ..\\)                                                   **)\r\n        $(info ***********************************************************************)\r\n        $(info ***********************************************************************)\r\n        $(info .)\r\n        $(error Update windows-build)\r\n      endif\r\n    endif\r\n    ifeq (pcre,$(shell if exist ..\\windows-build\\PCRE\\include\\pcre.h echo pcre))\r\n      OS_CCDEFS += -DHAVE_PCRE_H -DPCRE_STATIC -I$(abspath ../windows-build/PCRE/include)\r\n      OS_LDFLAGS += -lpcre -L../windows-build/PCRE/lib/\r\n      $(info using libpcre: $(abspath ../windows-build/PCRE/lib/pcre.a) $(abspath ../windows-build/PCRE/include/pcre.h))\r\n    endif\r\n    ifeq (slirp,slirp)\r\n      NETWORK_OPT += -I slirp -I slirp_glue -I slirp_glue/qemu -DHAVE_SLIRP_NETWORK -DUSE_SIMH_SLIRP_DEBUG slirp/*.c slirp_glue/*.c -lIphlpapi\r\n      NETWORK_LAN_FEATURES += NAT(SLiRP)\r\n    endif\r\n  endif\r\n  ifneq (,$(call find_include,ddk/ntdddisk))\r\n    CFLAGS_I = -DHAVE_NTDDDISK_H\r\n  endif\r\nendif # Win32 (via MinGW)\r\nifeq (clean,$(strip ${MAKECMDGOALS}))\r\n  # a simple clean has no dependencies \r\n  NEEDED_PKGS =\r\nendif\r\nUSEFUL_PACKAGES = $(filter-out -,$(foreach word,$(NEEDED_PKGS),$(word $($(word)),$(PKGS_SRC_$(strip $(PKG_MGR))))))\r\nUSEFUL_PLURAL =  $(if $(word 2,$(USEFUL_PACKAGES)),s,)\r\nUSEFUL_MULTIPLE_HIST = $(if $(word 2,$(USEFUL_PACKAGES)),were,was)\r\nUSEFUL_MULTIPLE = $(if $(word 2,$(USEFUL_PACKAGES)),these,this)\r\nifneq (,$(USEFUL_PACKAGES))\r\n  $(info )\r\n  $(info *** Info ***)\r\n  $(info *** Info *** The simulator$(BUILD_MULTIPLE) you are building could provide more)\r\n  $(info *** Info *** functionality if the:)\r\n  $(info *** Info ***     $(USEFUL_PACKAGES))\r\n  $(info *** Info *** package$(USEFUL_PLURAL) $(USEFUL_MULTIPLE_HIST) available on your system.)\r\n  $(info )\r\n  ifeq (,$(AUTO_INSTALL_PACKAGES))\r\n    $(info *** You have the option of building $(MAKECMDGOALS_DESCRIPTION) without the)\r\n    $(info *** functionality $(USEFUL_MULTIPLE) package$(USEFUL_PLURAL) provide$(if $(USEFUL_PLURAL),,s), or stopping now to install)\r\n    $(info *** $(USEFUL_MULTIPLE) package$(USEFUL_PLURAL).)\r\n    $(info )\r\n  endif\r\nendif\r\nifneq (,$(BUILD_SEPARATE))\r\n  EXTRAS:=BUILD_SEPARATE=$(BUILD_SEPARATE)\r\nendif\r\nifneq (,$(QUIET))\r\n  EXTRAS+= QUIET=$(QUIET)\r\nendif\r\nifneq (,$(and $(AUTO_INSTALL_PACKAGES),$(PKG_CMD),$(USEFUL_PACKAGES)))\r\n  ifneq (,$(AUTO_INSTALL_PACKAGES))\r\n    $(info Running $(word 1,$(PKG_CMD)) now to install $(USEFUL_MULTIPLE) package$(USEFUL_PLURAL) before building $(MAKECMDGOALS_DESCRIPTION)?)\r\n  else\r\n    $(info Do you want to install $(USEFUL_MULTIPLE) package$(USEFUL_PLURAL) before building $(MAKECMDGOALS_DESCRIPTION)?)\r\n  endif\r\n  ifeq (,$(if $(AUTO_INSTALL_PACKAGES),,$(shell $(SHELL) -c 'read -p \"[Enter Y or N, Default is Y] \" answer; echo $$answer' | grep -i n)))\r\n    INSTALLER_RESULT = $(shell $(PKG_CMD) $(USEFUL_PACKAGES) 1>&2)\r\n    $(info $(INSTALLER_RESULT))\r\n    $(info *** rerunning this make to perform your desired build...)\r\n    MAKE_RESULT = $(shell $(MAKE) $(MAKECMDGOALS) $(EXTRAS) 1>&2)\r\n    $(error Done: $(MAKE_RESULT))\r\n  endif\r\nelse\r\n  ifneq (,$(USEFUL_PACKAGES))\r\n    $(info Do you want to install $(USEFUL_MULTIPLE) package$(USEFUL_PLURAL) before building $(MAKECMDGOALS_DESCRIPTION)?)\r\n    ifeq (,$(PKG_SHELL_READ_CANT_PROMPT))\r\n      ANSWER := $(shell $(SHELL) -c 'read -p \"[Enter Y or N, Default is Y] \" answer; echo $$answer' | grep -i n)\r\n    else\r\n      $(info [Enter Y or N, Default is Y])\r\n      ANSWER := $(shell $(SHELL) -c 'read answer; echo $$answer' | grep -i n)\r\n    endif\r\n    ifeq (,$(ANSWER))\r\n      ANSWER := Y\r\n    else\r\n      ifeq (y,$(ANSWER))\r\n        ANSWER := Y\r\n      endif\r\n    endif\r\n    ifeq (Y,$(ANSWER))\r\n      ifeq (,$(PKG_NO_SUDO))\r\n        $(info Enter:    $$ sudo $(PKG_CMD) $(USEFUL_PACKAGES))\r\n        $(info when that completes)\r\n        $(info re-enter: $$ $(MAKE) $(MAKECMDGOALS) $(EXTRAS))\r\n        $(error )\r\n      else\r\n        hash := \\#\r\n        $(info Enter:    $$ su)\r\n        $(info Enter:    Password: <type-root-password>)\r\n        $(info Enter:    $(hash) $(PKG_CMD) $(USEFUL_PACKAGES))\r\n        $(info when that completes)\r\n        $(info Enter:    $(hash) exit)\r\n        $(info re-enter: $$ $(MAKE) $(MAKECMDGOALS) $(EXTRAS))\r\n        $(error )\r\n      endif\r\n    endif\r\n  endif\r\nendif\r\nifneq (,$(GIT_COMMIT_ID))\r\n  CFLAGS_GIT = -DSIM_GIT_COMMIT_ID=$(GIT_COMMIT_ID)\r\nendif\r\nifneq (,$(GIT_COMMIT_TIME))\r\n  CFLAGS_GIT += -DSIM_GIT_COMMIT_TIME=$(GIT_COMMIT_TIME)\r\nendif\r\nifneq (,$(UNSUPPORTED_BUILD))\r\n  CFLAGS_GIT += -DSIM_BUILD=Unsupported=$(UNSUPPORTED_BUILD)\r\nendif\r\nOPTIMIZE ?= -O2\r\nifneq ($(DEBUG),)\r\n  CFLAGS_G = -g -ggdb -g3\r\n  CFLAGS_O = -O0\r\n  BUILD_FEATURES = - debugging support\r\n  LTO =\r\nelse\r\n  ifneq (,$(findstring clang,$(COMPILER_NAME))$(findstring LLVM,$(COMPILER_NAME)))\r\n    CFLAGS_O = $(OPTIMIZE) -fno-strict-overflow\r\n    GCC_OPTIMIZERS_CMD = ${GCC} --help 2>&1\r\n  else\r\n    CFLAGS_O := $(OPTIMIZE)\r\n  endif\r\n  LDFLAGS_O =\r\n  GCC_MAJOR_VERSION = $(firstword $(subst  ., ,$(GCC_VERSION)))\r\n  ifneq (3,$(GCC_MAJOR_VERSION))\r\n    ifeq (,$(GCC_OPTIMIZERS_CMD))\r\n      GCC_OPTIMIZERS_CMD = ${GCC} --help=optimizers\r\n      GCC_COMMON_CMD = ${GCC} --help=common\r\n    endif\r\n  endif\r\n  ifneq (,$(GCC_OPTIMIZERS_CMD))\r\n    GCC_OPTIMIZERS = $(shell $(GCC_OPTIMIZERS_CMD))\r\n  endif\r\n  ifneq (,$(GCC_COMMON_CMD))\r\n    GCC_OPTIMIZERS += $(shell $(GCC_COMMON_CMD))\r\n  endif\r\n  ifneq (,$(findstring -finline-functions,$(GCC_OPTIMIZERS)))\r\n    CFLAGS_O += -finline-functions\r\n  endif\r\n  ifneq (,$(findstring -fgcse-after-reload,$(GCC_OPTIMIZERS)))\r\n    CFLAGS_O += -fgcse-after-reload\r\n  endif\r\n  ifneq (,$(findstring -fpredictive-commoning,$(GCC_OPTIMIZERS)))\r\n    CFLAGS_O += -fpredictive-commoning\r\n  endif\r\n  ifneq (,$(findstring -fipa-cp-clone,$(GCC_OPTIMIZERS)))\r\n    CFLAGS_O += -fipa-cp-clone\r\n  endif\r\n  ifneq (,$(findstring -funsafe-loop-optimizations,$(GCC_OPTIMIZERS)))\r\n    CFLAGS_O += -fno-unsafe-loop-optimizations\r\n  endif\r\n  ifneq (,$(findstring -fstrict-overflow,$(GCC_OPTIMIZERS)))\r\n    CFLAGS_O += -fno-strict-overflow\r\n  endif\r\n  ifneq (,$(findstring $(GCC_VERSION),$(LTO_EXCLUDE_VERSIONS)))\r\n    override LTO =\r\n  endif\r\n  ifneq (,$(LTO))\r\n    ifneq (,$(findstring -flto,$(GCC_OPTIMIZERS)))\r\n      CFLAGS_O += -flto\r\n      LTO_FEATURE = , with Link Time Optimization,\r\n    endif\r\n  endif\r\n  BUILD_FEATURES = - compiler optimizations$(LTO_FEATURE) and no debugging support\r\nendif\r\nifneq (3,$(GCC_MAJOR_VERSION))\r\n  ifeq (,$(GCC_WARNINGS_CMD))\r\n    GCC_WARNINGS_CMD = ${GCC} --help=warnings\r\n  endif\r\nendif\r\nifneq (clean,${MAKECMDGOALS})\r\n  BUILD_FEATURES := $(BUILD_FEATURES). $(COMPILER_NAME)\r\n  $(info ***)\r\n  $(info *** $(BUILD_SINGLE)Simulator$(BUILD_MULTIPLE) being built with:)\r\n  $(info *** $(BUILD_FEATURES).)\r\n  $(info *** - $(if $(BUILD_SEPARATE),Each source module compiled separately,Building using a single compile and link).)\r\n  ifneq (,$(NETWORK_FEATURES))\r\n    $(info *** $(NETWORK_FEATURES).)\r\n  endif\r\n  ifneq (,$(NETWORK_LAN_FEATURES))\r\n    $(info *** - Local LAN packet transports: $(NETWORK_LAN_FEATURES))\r\n  endif\r\n  ifneq (,$(VIDEO_FEATURES))\r\n    $(info *** $(VIDEO_FEATURES).)\r\n  endif\r\n  ifneq (,$(TESTING_FEATURES))\r\n    $(info *** $(TESTING_FEATURES).)\r\n  endif\r\n  ifneq (,$(GIT_COMMIT_ID))\r\n    $(info ***)\r\n    $(info *** git$(GIT_ARCHIVE_COMMIT_ID) commit id is $(GIT_COMMIT_ID).)\r\n    $(info *** git$(GIT_ARCHIVE_COMMIT_ID) commit time is $(GIT_COMMIT_TIME).)\r\n  endif\r\n  $(info ***)\r\nendif\r\nifneq ($(DONT_USE_ROMS),)\r\n  ROMS_OPT = -DDONT_USE_INTERNAL_ROM\r\nelse\r\n  BUILD_ROMS = ${BIN}buildtools/BuildROMs${EXE}\r\nendif\r\nifneq ($(DONT_USE_READER_THREAD),)\r\n  NETWORK_OPT += -DDONT_USE_READER_THREAD\r\nendif\r\n\r\nCC_OUTSPEC = -o $@\r\nexport CC := ${GCC} ${CC_STD} -U__STRICT_ANSI__ ${CFLAGS_G} ${CFLAGS_O} ${CFLAGS_GIT} ${CFLAGS_I} -DSIM_COMPILER=\"${COMPILER_NAME}\" $(SIM_BUILD_OS_VERSION) -DSIM_BUILD_TOOL=simh-makefile$(if $(BUILD_SEPARATE),-separate-compiles,-single-compile) -I . ${OS_CCDEFS} ${ROMS_OPT}\r\nifneq (,${SIM_VERSION_MODE})\r\n  CC += -DSIM_VERSION_MODE=\"${SIM_VERSION_MODE}\"\r\nendif\r\nexport LDFLAGS := ${OS_LDFLAGS} ${NETWORK_LDFLAGS} ${VIDEO_LDFLAGS} ${VIDEO_TTF_LDFLAGS} ${LDFLAGS_O}\r\n\r\n#\r\n# Common Libraries\r\n#\r\nSIMHD = .\r\nSIM = ${SIMHD}/scp.c ${SIMHD}/sim_console.c ${SIMHD}/sim_fio.c \\\r\n\t${SIMHD}/sim_timer.c ${SIMHD}/sim_sock.c ${SIMHD}/sim_tmxr.c \\\r\n\t${SIMHD}/sim_ether.c ${SIMHD}/sim_tape.c ${SIMHD}/sim_disk.c \\\r\n\t${SIMHD}/sim_serial.c ${SIMHD}/sim_video.c ${SIMHD}/sim_imd.c \\\r\n\t${SIMHD}/sim_card.c\r\n\r\nDISPLAYD = ${SIMHD}/display\r\n\r\nSCSI = ${SIMHD}/sim_scsi.c\r\n\r\nBIN = BIN/\r\n# The recursive logic needs a GNU make at least v4 when building with \r\n# separate compiles\r\nifneq (,$(call find_exe,gmake))\r\n  override MAKE = $(call find_exe,gmake)\r\nendif\r\nifneq (,$(and $(findstring 3.,$(GNUMakeVERSION)),$(BUILD_SEPARATE)))\r\n  ifeq (HOMEBREW,$(PKG_MGR))\r\n    $(info *** You can't build with separate compiles using version $(GNUMakeVERSION))\r\n    $(info *** of GNU make.  A GNU make version 4 or later is required.)\r\n    $(info *** Installing the latest GNU make using HomeBrew...)\r\n    BREW_RESULT = $(shell brew install make 1>&2)\r\n    $(info $(BREW_RESULT))\r\n    override MAKE = $(call find_exe,gmake)\r\n  else\r\n    $(info makefile:error *** You can't build with separate compiles using version $(GNUMakeVERSION))\r\n    $(error of GNU make.  A GNU make version 4 or later is required.)\r\n  endif\r\nendif\r\nMAKEIT = @+$(MAKE) -f $(MAKEFILE_LIST) TARGET=\"$@\" DEPS=\"$^\"\r\n\r\n#\r\n# Emulator source files and compile time options\r\n#\r\nPDP1D = ${SIMHD}/PDP1\r\nPDP1_DISPLAY_OPT = -DDISPLAY_TYPE=DIS_TYPE30 -DPIX_SCALE=RES_HALF\r\nPDP1 = ${PDP1D}/pdp1_lp.c ${PDP1D}/pdp1_cpu.c ${PDP1D}/pdp1_stddev.c \\\r\n\t${PDP1D}/pdp1_sys.c ${PDP1D}/pdp1_dt.c ${PDP1D}/pdp1_drm.c \\\r\n\t${PDP1D}/pdp1_clk.c ${PDP1D}/pdp1_dcs.c ${PDP1D}/pdp1_dpy.c \\\r\n\t${DISPLAYL}\r\nPDP1_OPT = -I ${PDP1D} ${DISPLAY_OPT} $(PDP1_DISPLAY_OPT)\r\n\r\n\r\nND100D = ${SIMHD}/ND100\r\nND100 = ${ND100D}/nd100_sys.c ${ND100D}/nd100_cpu.c ${ND100D}/nd100_floppy.c \\\r\n\t${ND100D}/nd100_stddev.c ${ND100D}/nd100_mm.c\r\nND100_OPT = -I ${ND100D}\r\n\r\n\r\nNOVAD = ${SIMHD}/NOVA\r\nNOVA = ${NOVAD}/nova_sys.c ${NOVAD}/nova_cpu.c ${NOVAD}/nova_dkp.c \\\r\n\t${NOVAD}/nova_dsk.c ${NOVAD}/nova_lp.c ${NOVAD}/nova_mta.c \\\r\n\t${NOVAD}/nova_plt.c ${NOVAD}/nova_pt.c ${NOVAD}/nova_clk.c \\\r\n\t${NOVAD}/nova_tt.c ${NOVAD}/nova_tt1.c ${NOVAD}/nova_qty.c\r\nNOVA_OPT = -I ${NOVAD}\r\n\r\n\r\nECLIPSE = ${NOVAD}/eclipse_cpu.c ${NOVAD}/eclipse_tt.c ${NOVAD}/nova_sys.c \\\r\n\t${NOVAD}/nova_dkp.c ${NOVAD}/nova_dsk.c ${NOVAD}/nova_lp.c \\\r\n\t${NOVAD}/nova_mta.c ${NOVAD}/nova_plt.c ${NOVAD}/nova_pt.c \\\r\n\t${NOVAD}/nova_clk.c ${NOVAD}/nova_tt1.c ${NOVAD}/nova_qty.c\r\nECLIPSE_OPT = -I ${NOVAD} -DECLIPSE -DUSE_INT64\r\n\r\n\r\nPDP18BD = ${SIMHD}/PDP18B\r\nPDP18B = ${PDP18BD}/pdp18b_dt.c ${PDP18BD}/pdp18b_drm.c ${PDP18BD}/pdp18b_cpu.c \\\r\n\t${PDP18BD}/pdp18b_lp.c ${PDP18BD}/pdp18b_mt.c ${PDP18BD}/pdp18b_rf.c \\\r\n\t${PDP18BD}/pdp18b_rp.c ${PDP18BD}/pdp18b_stddev.c ${PDP18BD}/pdp18b_sys.c \\\r\n\t${PDP18BD}/pdp18b_rb.c ${PDP18BD}/pdp18b_tt1.c ${PDP18BD}/pdp18b_fpp.c \\\r\n\t${PDP18BD}/pdp18b_g2tty.c ${PDP18BD}/pdp18b_dr15.c\r\n\r\nifneq (,${DISPLAY_OPT})\r\n  PDP7_DISPLAY_OPT = -DDISPLAY_TYPE=DIS_TYPE30 -DPIX_SCALE=RES_HALF\r\nendif\r\n\r\nPDP4_OPT = -DPDP4 -I ${PDP18BD}\r\nPDP7_OPT = -DPDP7 -I ${PDP18BD} ${DISPLAY_OPT} $(PDP7_DISPLAY_OPT)\r\nPDP9_OPT = -DPDP9 -I ${PDP18BD}\r\nPDP15_OPT = -DPDP15 -I ${PDP18BD}\r\n\r\n\r\nPDP11D = ${SIMHD}/PDP11\r\nPDP11 = ${PDP11D}/pdp11_fp.c ${PDP11D}/pdp11_cpu.c ${PDP11D}/pdp11_dz.c \\\r\n\t${PDP11D}/pdp11_cis.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_rk.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rp.c ${PDP11D}/pdp11_rpb.c \\\r\n\t${PDP11D}/pdp11_rx.c ${PDP11D}/pdp11_stddev.c ${PDP11D}/pdp11_sys.c \\\r\n\t${PDP11D}/pdp11_tc.c ${PDP11D}/pdp11_tm.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_io.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_pclk.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_pt.c \\\r\n\t${PDP11D}/pdp11_hk.c ${PDP11D}/pdp11_xq.c ${PDP11D}/pdp11_xu.c \\\r\n\t${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_rh.c ${PDP11D}/pdp11_tu.c \\\r\n\t${PDP11D}/pdp11_cpumod.c ${PDP11D}/pdp11_cr.c ${PDP11D}/pdp11_rf.c \\\r\n\t${PDP11D}/pdp11_dl.c ${PDP11D}/pdp11_ta.c ${PDP11D}/pdp11_rc.c \\\r\n\t${PDP11D}/pdp11_kg.c ${PDP11D}/pdp11_ke.c ${PDP11D}/pdp11_dc.c \\\r\n\t${PDP11D}/pdp11_dmc.c ${PDP11D}/pdp11_kmc.c ${PDP11D}/pdp11_dup.c \\\r\n\t${PDP11D}/pdp11_rs.c ${PDP11D}/pdp11_vt.c ${PDP11D}/pdp11_td.c \\\r\n\t${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_rom.c ${PDP11D}/pdp11_ch.c \\\r\n\t${PDP11D}/pdp11_dh.c ${PDP11D}/pdp11_ng.c ${PDP11D}/pdp11_daz.c \\\r\n\t${PDP11D}/pdp11_tv.c ${PDP11D}/pdp11_mb.c ${PDP11D}/pdp11_rr.c \\\r\n\t${DISPLAYL} ${DISPLAYNG} ${DISPLAYVT} $(NETWORK_DEPS)\r\nPDP11_OPT = -DVM_PDP11 -I ${PDP11D} ${NETWORK_OPT} ${DISPLAY_OPT}\r\n\r\n\r\nUC15D = ${SIMHD}/PDP11\r\nUC15 = ${UC15D}/pdp11_cis.c ${UC15D}/pdp11_cpu.c \\\r\n\t${UC15D}/pdp11_cpumod.c ${UC15D}/pdp11_cr.c \\\r\n\t${UC15D}/pdp11_fp.c ${UC15D}/pdp11_io.c \\\r\n\t${UC15D}/pdp11_io_lib.c ${UC15D}/pdp11_lp.c \\\r\n\t${UC15D}/pdp11_rh.c ${UC15D}/pdp11_rk.c \\\r\n\t${UC15D}/pdp11_stddev.c ${UC15D}/pdp11_sys.c \\\r\n\t${UC15D}/pdp11_uc15.c\r\nUC15_OPT = -DVM_PDP11 -DUC15 -I ${UC15D} -I ${PDP18BD}\r\n\r\n\r\nVAXD = ${SIMHD}/VAX\r\nVAX = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c ${VAXD}/vax_io.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c  ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_stddev.c ${VAXD}/vax_sysdev.c \\\r\n\t${VAXD}/vax_sys.c  ${VAXD}/vax_syscm.c ${VAXD}/vax_syslist.c \\\r\n\t${VAXD}/vax_vc.c ${VAXD}/vax_lk.c ${VAXD}/vax_vs.c ${VAXD}/vax_2681.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xq.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_dup.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX_OPT = -DVM_VAX -DUSE_INT64 -DUSE_ADDR64 -DUSE_SIM_VIDEO -I${VAXD} -I ${PDP11D} ${NETWORK_OPT} ${VIDEO_CCDEFS}\r\n\r\n\r\nVAX410 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax_nar.c ${VAXD}/vax4xx_stddev.c \\\r\n\t${VAXD}/vax410_sysdev.c ${VAXD}/vax410_syslist.c ${VAXD}/vax4xx_dz.c \\\r\n\t${VAXD}/vax4xx_rd.c ${VAXD}/vax4xx_rz80.c ${VAXD}/vax_xs.c \\\r\n\t${VAXD}/vax4xx_va.c ${VAXD}/vax4xx_vc.c ${VAXD}/vax_lk.c \\\r\n\t${VAXD}/vax_vs.c ${VAXD}/vax_gpx.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX410_OPT = -DVM_VAX -DVAX_410 -DUSE_INT64 -DUSE_ADDR64 -DUSE_SIM_VIDEO -I ${VAXD} ${NETWORK_OPT} ${VIDEO_CCDEFS}\r\n\r\n\r\nVAX420 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax_nar.c ${VAXD}/vax4xx_stddev.c \\\r\n\t${VAXD}/vax420_sysdev.c ${VAXD}/vax420_syslist.c ${VAXD}/vax4xx_dz.c \\\r\n\t${VAXD}/vax4xx_rd.c ${VAXD}/vax4xx_rz80.c ${VAXD}/vax_xs.c \\\r\n\t${VAXD}/vax4xx_va.c ${VAXD}/vax4xx_vc.c ${VAXD}/vax4xx_ve.c \\\r\n\t${VAXD}/vax_lk.c ${VAXD}/vax_vs.c ${VAXD}/vax_gpx.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX420_OPT = -DVM_VAX -DVAX_420 -DUSE_INT64 -DUSE_ADDR64 -DUSE_SIM_VIDEO -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT} ${VIDEO_CCDEFS}\r\nVAX411_OPT = ${VAX420_OPT} -DVAX_411\r\nVAX412_OPT = ${VAX420_OPT} -DVAX_412\r\nVAX41A_OPT = ${VAX420_OPT} -DVAX_41A\r\nVAX41D_OPT = ${VAX420_OPT} -DVAX_41D\r\nVAX42A_OPT = ${VAX420_OPT} -DVAX_42A\r\nVAX42B_OPT = ${VAX420_OPT} -DVAX_42B\r\n\r\n\r\nVAX43 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax_nar.c ${VAXD}/vax4xx_stddev.c \\\r\n\t${VAXD}/vax43_sysdev.c ${VAXD}/vax43_syslist.c ${VAXD}/vax4xx_dz.c \\\r\n\t${VAXD}/vax4xx_rz80.c ${VAXD}/vax_xs.c ${VAXD}/vax4xx_vc.c \\\r\n\t${VAXD}/vax4xx_ve.c ${VAXD}/vax_lk.c ${VAXD}/vax_vs.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX43_OPT = -DVM_VAX -DVAX_43 -DUSE_INT64 -DUSE_ADDR64 -DUSE_SIM_VIDEO -I ${VAXD} ${NETWORK_OPT} ${VIDEO_CCDEFS}\r\n\r\n\r\nVAX440 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax_nar.c ${VAXD}/vax4xx_stddev.c \\\r\n\t${VAXD}/vax440_sysdev.c ${VAXD}/vax440_syslist.c ${VAXD}/vax4xx_dz.c \\\r\n\t${VAXD}/vax_xs.c ${VAXD}/vax_lk.c ${VAXD}/vax_vs.c ${VAXD}/vax4xx_rz94.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX440_OPT = -DVM_VAX -DVAX_440 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} ${NETWORK_OPT}\r\nVAX46_OPT = ${VAX440_OPT} -DVAX_46\r\nVAX47_OPT = ${VAX440_OPT} -DVAX_47\r\nVAX48_OPT = ${VAX440_OPT} -DVAX_48\r\n\r\n\r\nIS1000 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax_nar.c ${VAXD}/vax_xs.c \\\r\n\t${VAXD}/vax4xx_rz94.c ${VAXD}/vax4nn_stddev.c \\\r\n\t${VAXD}/is1000_sysdev.c ${VAXD}/is1000_syslist.c \\\r\n\t$(NETWORK_DEPS)\r\nIS1000_OPT = -DVM_VAX -DIS_1000 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} ${NETWORK_OPT}\r\n\r\n\r\nVAX610 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax610_stddev.c ${VAXD}/vax610_sysdev.c ${VAXD}/vax610_io.c \\\r\n\t${VAXD}/vax610_syslist.c ${VAXD}/vax610_mem.c ${VAXD}/vax_vc.c \\\r\n\t${VAXD}/vax_lk.c ${VAXD}/vax_vs.c ${VAXD}/vax_2681.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c \\\r\n\t${PDP11D}/pdp11_xq.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_io_lib.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX610_OPT = -DVM_VAX -DVAX_610 -DUSE_INT64 -DUSE_ADDR64 -DUSE_SIM_VIDEO -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT} ${VIDEO_CCDEFS}\r\n\r\n\r\nVAX630 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax630_stddev.c ${VAXD}/vax630_sysdev.c \\\r\n\t${VAXD}/vax630_io.c ${VAXD}/vax630_syslist.c ${VAXD}/vax_va.c \\\r\n\t${VAXD}/vax_vc.c ${VAXD}/vax_lk.c ${VAXD}/vax_vs.c \\\r\n\t${VAXD}/vax_2681.c ${VAXD}/vax_gpx.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xq.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_dup.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX620_OPT = -DVM_VAX -DVAX_620 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT}\r\nVAX630_OPT = -DVM_VAX -DVAX_630 -DUSE_INT64 -DUSE_ADDR64 -DUSE_SIM_VIDEO -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT} ${VIDEO_CCDEFS}\r\n\r\n\r\nVAX730 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c  ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c  ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax730_stddev.c ${VAXD}/vax730_sys.c \\\r\n\t${VAXD}/vax730_mem.c ${VAXD}/vax730_uba.c ${VAXD}/vax730_rb.c \\\r\n\t${VAXD}/vax_uw.c ${VAXD}/vax730_syslist.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xu.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_hk.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_dmc.c \\\r\n\t${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_tc.c ${PDP11D}/pdp11_rk.c \\\r\n\t${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_ch.c ${PDP11D}/pdp11_dup.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX730_OPT = -DVM_VAX -DVAX_730 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT}\r\n\r\n\r\nVAX750 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c  ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c  ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax750_stddev.c ${VAXD}/vax750_cmi.c \\\r\n\t${VAXD}/vax750_mem.c ${VAXD}/vax750_uba.c ${VAXD}/vax7x0_mba.c \\\r\n\t${VAXD}/vax_uw.c ${VAXD}/vax750_syslist.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xu.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_hk.c ${PDP11D}/pdp11_rp.c ${PDP11D}/pdp11_rpb.c \\\r\n\t${PDP11D}/pdp11_tu.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_dmc.c \\\r\n\t${PDP11D}/pdp11_dup.c ${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_tc.c \\\r\n\t${PDP11D}/pdp11_rk.c ${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_ch.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX750_OPT = -DVM_VAX -DVAX_750 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT}\r\n\r\n\r\nVAX780 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c  ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c  ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax780_stddev.c ${VAXD}/vax780_sbi.c \\\r\n\t${VAXD}/vax780_mem.c ${VAXD}/vax780_uba.c ${VAXD}/vax7x0_mba.c \\\r\n\t${VAXD}/vax780_fload.c \t${VAXD}/vax_uw.c ${VAXD}/vax780_syslist.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xu.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_rp.c ${PDP11D}/pdp11_rpb.c ${PDP11D}/pdp11_tu.c \\\r\n\t${PDP11D}/pdp11_hk.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_dmc.c \\\r\n\t${PDP11D}/pdp11_dup.c ${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_tc.c \\\r\n\t${PDP11D}/pdp11_rk.c ${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_ch.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX780_OPT = -DVM_VAX -DVAX_780 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT}\r\n\r\n\r\nVAX8200 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c  ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c  ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax_watch.c ${VAXD}/vax820_stddev.c ${VAXD}/vax820_bi.c \\\r\n\t${VAXD}/vax820_mem.c ${VAXD}/vax820_uba.c ${VAXD}/vax820_ka.c \\\r\n\t${VAXD}/vax_uw.c ${VAXD}/vax820_syslist.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xu.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_hk.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_dmc.c \\\r\n\t${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_tc.c ${PDP11D}/pdp11_rk.c \\\r\n\t${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_ch.c ${PDP11D}/pdp11_dup.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX8200_OPT = -DVM_VAX -DVAX_820 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT}\r\n\r\n\r\nVAX8600 = ${VAXD}/vax_cpu.c ${VAXD}/vax_cpu1.c ${VAXD}/vax_fpa.c \\\r\n\t${VAXD}/vax_cis.c ${VAXD}/vax_octa.c  ${VAXD}/vax_cmode.c \\\r\n\t${VAXD}/vax_mmu.c ${VAXD}/vax_sys.c  ${VAXD}/vax_syscm.c \\\r\n\t${VAXD}/vax860_stddev.c ${VAXD}/vax860_sbia.c \\\r\n\t${VAXD}/vax860_abus.c ${VAXD}/vax780_uba.c ${VAXD}/vax7x0_mba.c \\\r\n\t${VAXD}/vax_uw.c ${VAXD}/vax860_syslist.c \\\r\n\t${PDP11D}/pdp11_rl.c ${PDP11D}/pdp11_rq.c ${PDP11D}/pdp11_ts.c \\\r\n\t${PDP11D}/pdp11_dz.c ${PDP11D}/pdp11_lp.c ${PDP11D}/pdp11_tq.c \\\r\n\t${PDP11D}/pdp11_xu.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_rp.c ${PDP11D}/pdp11_rpb.c ${PDP11D}/pdp11_tu.c \\\r\n\t${PDP11D}/pdp11_hk.c ${PDP11D}/pdp11_vh.c ${PDP11D}/pdp11_dmc.c \\\r\n\t${PDP11D}/pdp11_dup.c ${PDP11D}/pdp11_td.c ${PDP11D}/pdp11_tc.c \\\r\n\t${PDP11D}/pdp11_rk.c ${PDP11D}/pdp11_io_lib.c ${PDP11D}/pdp11_ch.c \\\r\n\t$(NETWORK_DEPS)\r\nVAX8600_OPT = -DVM_VAX -DVAX_860 -DUSE_INT64 -DUSE_ADDR64 -I ${VAXD} -I ${PDP11D} ${NETWORK_OPT}\r\n\r\n\r\nPDP10D = ${SIMHD}/PDP10\r\nPDP10 = ${PDP10D}/pdp10_fe.c ${PDP11D}/pdp11_dz.c ${PDP10D}/pdp10_cpu.c \\\r\n\t${PDP10D}/pdp10_ksio.c ${PDP10D}/pdp10_lp20.c ${PDP10D}/pdp10_mdfp.c \\\r\n\t${PDP10D}/pdp10_pag.c ${PDP10D}/pdp10_rp.c ${PDP10D}/pdp10_sys.c \\\r\n\t${PDP10D}/pdp10_tim.c ${PDP10D}/pdp10_tu.c ${PDP10D}/pdp10_xtnd.c \\\r\n\t${PDP11D}/pdp11_pt.c ${PDP11D}/pdp11_ry.c ${PDP11D}/pdp11_cr.c \\\r\n\t${PDP11D}/pdp11_dup.c ${PDP11D}/pdp11_dmc.c ${PDP11D}/pdp11_kmc.c \\\r\n\t${PDP11D}/pdp11_xu.c ${PDP11D}/pdp11_ch.c \\\r\n\t$(NETWORK_DEPS)\r\nPDP10_OPT = -DVM_PDP10 -DUSE_INT64 -I ${PDP10D} -I ${PDP11D} ${NETWORK_OPT}\r\n\r\n\r\nIMLACD = ${SIMHD}/imlac\r\nIMLAC = ${IMLACD}/imlac_sys.c ${IMLACD}/imlac_cpu.c \\\r\n\t${IMLACD}/imlac_dp.c ${IMLACD}/imlac_crt.c ${IMLACD}/imlac_kbd.c \\\r\n\t${IMLACD}/imlac_tty.c ${IMLACD}/imlac_pt.c ${IMLACD}/imlac_bel.c \\\r\n\t${DISPLAYL}\r\nIMLAC_OPT = -I ${IMLACD} ${DISPLAY_OPT}\r\n\r\n\r\nTT2500D = ${SIMHD}/tt2500\r\nTT2500 = ${TT2500D}/tt2500_sys.c ${TT2500D}/tt2500_cpu.c \\\r\n\t${TT2500D}/tt2500_dpy.c ${TT2500D}/tt2500_crt.c ${TT2500D}/tt2500_tv.c \\\r\n\t${TT2500D}/tt2500_key.c ${TT2500D}/tt2500_uart.c ${TT2500D}/tt2500_rom.c \\\r\n\t${DISPLAYL}\r\nTT2500_OPT = -I ${TT2500D} ${DISPLAY_OPT}\r\n\r\n\r\nPDP8D = ${SIMHD}/PDP8\r\nPDP8 = ${PDP8D}/pdp8_cpu.c ${PDP8D}/pdp8_clk.c ${PDP8D}/pdp8_df.c \\\r\n\t${PDP8D}/pdp8_dt.c ${PDP8D}/pdp8_lp.c ${PDP8D}/pdp8_mt.c \\\r\n\t${PDP8D}/pdp8_pt.c ${PDP8D}/pdp8_rf.c ${PDP8D}/pdp8_rk.c \\\r\n\t${PDP8D}/pdp8_rx.c ${PDP8D}/pdp8_sys.c ${PDP8D}/pdp8_tt.c \\\r\n\t${PDP8D}/pdp8_ttx.c ${PDP8D}/pdp8_rl.c ${PDP8D}/pdp8_tsc.c \\\r\n\t${PDP8D}/pdp8_td.c ${PDP8D}/pdp8_ct.c ${PDP8D}/pdp8_fpp.c\r\nPDP8_OPT = -I ${PDP8D}\r\n\r\n\r\nH316D = ${SIMHD}/H316\r\nH316 = ${H316D}/h316_stddev.c ${H316D}/h316_lp.c ${H316D}/h316_cpu.c \\\r\n\t${H316D}/h316_sys.c ${H316D}/h316_mt.c ${H316D}/h316_fhd.c \\\r\n\t${H316D}/h316_dp.c ${H316D}/h316_rtc.c ${H316D}/h316_imp.c \\\r\n\t${H316D}/h316_hi.c ${H316D}/h316_mi.c ${H316D}/h316_udp.c\r\nH316_OPT = -I ${H316D} -D VM_IMPTIP\r\n\r\n\r\nHP2100D = ${SIMHD}/HP2100\r\nHP2100 = ${HP2100D}/hp2100_baci.c ${HP2100D}/hp2100_cpu.c \\\r\n        ${HP2100D}/hp2100_cpu_fp.c ${HP2100D}/hp2100_cpu_fpp.c \\\r\n        ${HP2100D}/hp2100_cpu0.c ${HP2100D}/hp2100_cpu1.c \\\r\n        ${HP2100D}/hp2100_cpu2.c ${HP2100D}/hp2100_cpu3.c \\\r\n        ${HP2100D}/hp2100_cpu4.c ${HP2100D}/hp2100_cpu5.c \\\r\n        ${HP2100D}/hp2100_cpu6.c ${HP2100D}/hp2100_cpu7.c \\\r\n        ${HP2100D}/hp2100_di.c ${HP2100D}/hp2100_di_da.c \\\r\n        ${HP2100D}/hp2100_disclib.c ${HP2100D}/hp2100_dma.c \\\r\n        ${HP2100D}/hp2100_dp.c ${HP2100D}/hp2100_dq.c \\\r\n        ${HP2100D}/hp2100_dr.c ${HP2100D}/hp2100_ds.c \\\r\n        ${HP2100D}/hp2100_ipl.c ${HP2100D}/hp2100_lps.c \\\r\n        ${HP2100D}/hp2100_lpt.c ${HP2100D}/hp2100_mc.c \\\r\n        ${HP2100D}/hp2100_mem.c ${HP2100D}/hp2100_mpx.c \\\r\n        ${HP2100D}/hp2100_ms.c ${HP2100D}/hp2100_mt.c \\\r\n        ${HP2100D}/hp2100_mux.c ${HP2100D}/hp2100_pif.c \\\r\n        ${HP2100D}/hp2100_pt.c ${HP2100D}/hp2100_sys.c \\\r\n        ${HP2100D}/hp2100_tbg.c ${HP2100D}/hp2100_tty.c\r\nHP2100_OPT = -DHAVE_INT64 -I ${HP2100D}\r\n\r\nHP3000D = ${SIMHD}/HP3000\r\nHP3000 = ${HP3000D}/hp_disclib.c ${HP3000D}/hp_tapelib.c ${HP3000D}/hp3000_atc.c \\\r\n\t${HP3000D}/hp3000_clk.c ${HP3000D}/hp3000_cpu.c ${HP3000D}/hp3000_cpu_base.c \\\r\n\t${HP3000D}/hp3000_cpu_fp.c ${HP3000D}/hp3000_cpu_cis.c ${HP3000D}/hp3000_ds.c \\\r\n\t${HP3000D}/hp3000_iop.c ${HP3000D}/hp3000_lp.c ${HP3000D}/hp3000_mem.c \\\r\n\t${HP3000D}/hp3000_mpx.c ${HP3000D}/hp3000_ms.c ${HP3000D}/hp3000_scmb.c \\\r\n\t${HP3000D}/hp3000_sel.c ${HP3000D}/hp3000_sys.c\r\nHP3000_OPT = -I ${HP3000D}\r\n\r\n\r\nI1401D = ${SIMHD}/I1401\r\nI1401 = ${I1401D}/i1401_lp.c ${I1401D}/i1401_cpu.c ${I1401D}/i1401_iq.c \\\r\n\t${I1401D}/i1401_cd.c ${I1401D}/i1401_mt.c ${I1401D}/i1401_dp.c \\\r\n\t${I1401D}/i1401_sys.c\r\nI1401_OPT = -I ${I1401D}\r\n\r\n\r\nI1620D = ${SIMHD}/I1620\r\nI1620 = ${I1620D}/i1620_cd.c ${I1620D}/i1620_dp.c ${I1620D}/i1620_pt.c \\\r\n\t${I1620D}/i1620_tty.c ${I1620D}/i1620_cpu.c ${I1620D}/i1620_lp.c \\\r\n\t${I1620D}/i1620_fp.c ${I1620D}/i1620_sys.c\r\nI1620_OPT = -I ${I1620D}\r\n\r\nI7000D = ${SIMHD}/I7000\r\nI7090 = ${I7000D}/i7090_cpu.c ${I7000D}/i7090_sys.c ${I7000D}/i7090_chan.c \\\r\n\t${I7000D}/i7090_cdr.c ${I7000D}/i7090_cdp.c ${I7000D}/i7090_lpr.c \\\r\n\t${I7000D}/i7000_chan.c ${I7000D}/i7000_mt.c ${I7000D}/i7090_drum.c \\\r\n\t${I7000D}/i7090_hdrum.c ${I7000D}/i7000_chron.c ${I7000D}/i7000_dsk.c \\\r\n\t${I7000D}/i7000_com.c ${I7000D}/i7000_ht.c\r\nI7090_OPT = -I $(I7000D) -DUSE_INT64 -DI7090 -DUSE_SIM_CARD\r\n\r\nI7080D = ${SIMHD}/I7000\r\nI7080 = ${I7000D}/i7080_cpu.c ${I7000D}/i7080_sys.c ${I7000D}/i7080_chan.c \\\r\n\t${I7000D}/i7080_drum.c ${I7000D}/i7000_cdp.c ${I7000D}/i7000_cdr.c \\\r\n\t${I7000D}/i7000_con.c ${I7000D}/i7000_chan.c ${I7000D}/i7000_lpr.c \\\r\n\t${I7000D}/i7000_mt.c ${I7000D}/i7000_chron.c ${I7000D}/i7000_dsk.c \\\r\n\t${I7000D}/i7000_com.c ${I7000D}/i7000_ht.c\r\nI7080_OPT = -I $(I7000D) -DI7080 -DUSE_SIM_CARD\r\n\r\nI7070D = ${SIMHD}/I7000\r\nI7070 = ${I7000D}/i7070_cpu.c ${I7000D}/i7070_sys.c ${I7000D}/i7070_chan.c \\\r\n\t${I7000D}/i7000_cdp.c ${I7000D}/i7000_cdr.c ${I7000D}/i7000_con.c \\\r\n\t${I7000D}/i7000_chan.c ${I7000D}/i7000_lpr.c ${I7000D}/i7000_mt.c \\\r\n\t${I7000D}/i7000_chron.c ${I7000D}/i7000_dsk.c ${I7000D}/i7000_com.c \\\r\n\t${I7000D}/i7000_ht.c\r\nI7070_OPT = -I $(I7000D) -DUSE_INT64 -DI7070 -DUSE_SIM_CARD\r\n\r\nI7010D = ${SIMHD}/I7000\r\nI7010 = ${I7000D}/i7010_cpu.c ${I7000D}/i7010_sys.c ${I7000D}/i7010_chan.c \\\r\n\t${I7000D}/i7000_cdp.c ${I7000D}/i7000_cdr.c ${I7000D}/i7000_con.c \\\r\n\t${I7000D}/i7000_chan.c ${I7000D}/i7000_lpr.c ${I7000D}/i7000_mt.c \\\r\n\t${I7000D}/i7000_chron.c ${I7000D}/i7000_dsk.c ${I7000D}/i7000_com.c \\\r\n\t${I7000D}/i7000_ht.c\r\nI7010_OPT = -I $(I7010D) -DI7010 -DUSE_SIM_CARD\r\n\r\nI704D  = ${SIMHD}/I7000\r\nI704   = ${I7000D}/i7090_cpu.c ${I7000D}/i7090_sys.c ${I7000D}/i7090_chan.c \\\r\n\t ${I7000D}/i7090_cdr.c ${I7000D}/i7090_cdp.c ${I7000D}/i7090_lpr.c \\\r\n\t ${I7000D}/i7000_mt.c ${I7000D}/i7090_drum.c ${I7000D}/i7000_chan.c\r\nI704_OPT = -I $(I7000D) -DUSE_INT64 -DI704 -DUSE_SIM_CARD\r\n\r\n\r\nI701D  = ${SIMHD}/I7000\r\nI701   = ${I7000D}/i701_cpu.c ${I7000D}/i701_sys.c ${I7000D}/i701_chan.c \\\r\n\t ${I7000D}/i7090_cdr.c ${I7000D}/i7090_cdp.c ${I7000D}/i7090_lpr.c \\\r\n\t ${I7000D}/i7000_mt.c ${I7000D}/i7090_drum.c ${I7000D}/i7000_chan.c\r\nI701_OPT = -I $(I7000D) -DUSE_INT64 -DI701 -DUSE_SIM_CARD\r\n\r\n\r\nI7094D = ${SIMHD}/I7094\r\nI7094 = ${I7094D}/i7094_cpu.c ${I7094D}/i7094_cpu1.c ${I7094D}/i7094_io.c \\\r\n\t${I7094D}/i7094_cd.c ${I7094D}/i7094_clk.c ${I7094D}/i7094_com.c \\\r\n\t${I7094D}/i7094_drm.c ${I7094D}/i7094_dsk.c ${I7094D}/i7094_sys.c \\\r\n\t${I7094D}/i7094_lp.c ${I7094D}/i7094_mt.c ${I7094D}/i7094_binloader.c\r\nI7094_OPT = -DUSE_INT64 -I ${I7094D}\r\n\r\n\r\nI650D = ${SIMHD}/I650\r\nI650 = ${I650D}/i650_cpu.c ${I650D}/i650_cdr.c ${I650D}/i650_cdp.c \\\r\n\t${I650D}/i650_dsk.c ${I650D}/i650_mt.c ${I650D}/i650_sys.c\r\nI650_OPT = -I ${I650D} -DUSE_INT64 -DUSE_SIM_CARD\r\n\r\n\r\nIBM1130D = ${SIMHD}/Ibm1130\r\nIBM1130 = ${IBM1130D}/ibm1130_cpu.c ${IBM1130D}/ibm1130_cr.c \\\r\n\t${IBM1130D}/ibm1130_disk.c ${IBM1130D}/ibm1130_stddev.c \\\r\n\t${IBM1130D}/ibm1130_sys.c ${IBM1130D}/ibm1130_gdu.c \\\r\n\t${IBM1130D}/ibm1130_gui.c ${IBM1130D}/ibm1130_prt.c \\\r\n\t${IBM1130D}/ibm1130_fmt.c ${IBM1130D}/ibm1130_ptrp.c \\\r\n\t${IBM1130D}/ibm1130_plot.c ${IBM1130D}/ibm1130_sca.c \\\r\n\t${IBM1130D}/ibm1130_t2741.c\r\nIBM1130_OPT = -I ${IBM1130D}\r\nifneq (${WIN32},)\r\nIBM1130_OPT += -DGUI_SUPPORT -lgdi32 ${BIN}ibm1130.o\r\nendif  \r\n\r\n\r\nID16D = ${SIMHD}/Interdata\r\nID16 = ${ID16D}/id16_cpu.c ${ID16D}/id16_sys.c ${ID16D}/id_dp.c \\\r\n\t${ID16D}/id_fd.c ${ID16D}/id_fp.c ${ID16D}/id_idc.c ${ID16D}/id_io.c \\\r\n\t${ID16D}/id_lp.c ${ID16D}/id_mt.c ${ID16D}/id_pas.c ${ID16D}/id_pt.c \\\r\n\t${ID16D}/id_tt.c ${ID16D}/id_uvc.c ${ID16D}/id16_dboot.c ${ID16D}/id_ttp.c\r\nID16_OPT = -DIFP_IN_MEM -I ${ID16D}\r\n\r\n\r\nID32D = ${SIMHD}/Interdata\r\nID32 = ${ID32D}/id32_cpu.c ${ID32D}/id32_sys.c ${ID32D}/id_dp.c \\\r\n\t${ID32D}/id_fd.c ${ID32D}/id_fp.c ${ID32D}/id_idc.c ${ID32D}/id_io.c \\\r\n\t${ID32D}/id_lp.c ${ID32D}/id_mt.c ${ID32D}/id_pas.c ${ID32D}/id_pt.c \\\r\n\t${ID32D}/id_tt.c ${ID32D}/id_uvc.c ${ID32D}/id32_dboot.c ${ID32D}/id_ttp.c\r\nID32_OPT = -I ${ID32D}\r\n\r\n\r\nS3D = ${SIMHD}/S3\r\nS3 = ${S3D}/s3_cd.c ${S3D}/s3_cpu.c ${S3D}/s3_disk.c ${S3D}/s3_lp.c \\\r\n\t${S3D}/s3_pkb.c ${S3D}/s3_sys.c\r\nS3_OPT = -I ${S3D}\r\n\r\n\r\nALTAIRD = ${SIMHD}/ALTAIR\r\nALTAIR = ${ALTAIRD}/altair_sio.c ${ALTAIRD}/altair_cpu.c ${ALTAIRD}/altair_dsk.c \\\r\n\t${ALTAIRD}/altair_sys.c\r\nALTAIR_OPT = -I ${ALTAIRD}\r\n\r\n\r\nALTAIRZ80D = ${SIMHD}/AltairZ80\r\nALTAIRZ80 = ${ALTAIRZ80D}/altairz80_cpu.c ${ALTAIRZ80D}/altairz80_cpu_nommu.c \\\r\n\t${ALTAIRZ80D}/s100_dazzler.c \\\r\n\t${ALTAIRZ80D}/s100_tuart.c \\\r\n\t${ALTAIRZ80D}/s100_jair.c \\\r\n\t${ALTAIRZ80D}/sol20.c \\\r\n\t${ALTAIRZ80D}/s100_vdm1.c \\\r\n\t${ALTAIRZ80D}/mmd.c \\\r\n\t${ALTAIRZ80D}/s100_dj2d.c \\\r\n\t${ALTAIRZ80D}/s100_djhdc.c \\\r\n\t${ALTAIRZ80D}/altairz80_dsk.c ${ALTAIRZ80D}/disasm.c \\\r\n\t${ALTAIRZ80D}/altairz80_sio.c ${ALTAIRZ80D}/altairz80_sys.c \\\r\n\t${ALTAIRZ80D}/altairz80_hdsk.c ${ALTAIRZ80D}/altairz80_net.c \\\r\n\t${ALTAIRZ80D}/s100_hayes.c ${ALTAIRZ80D}/s100_2sio.c ${ALTAIRZ80D}/s100_pmmi.c\\\r\n\t${ALTAIRZ80D}/flashwriter2.c ${ALTAIRZ80D}/i86_decode.c \\\r\n\t${ALTAIRZ80D}/i86_ops.c ${ALTAIRZ80D}/i86_prim_ops.c \\\r\n\t${ALTAIRZ80D}/i8272.c ${ALTAIRZ80D}/insnsd.c ${ALTAIRZ80D}/altairz80_mhdsk.c \\\r\n\t${ALTAIRZ80D}/ibc.c ${ALTAIRZ80D}/ibc_mcc_hdc.c ${ALTAIRZ80D}/ibc_smd_hdc.c \\\r\n\t${ALTAIRZ80D}/mfdc.c ${ALTAIRZ80D}/n8vem.c ${ALTAIRZ80D}/vfdhd.c \\\r\n\t${ALTAIRZ80D}/s100_disk1a.c ${ALTAIRZ80D}/s100_disk2.c ${ALTAIRZ80D}/s100_disk3.c \\\r\n\t${ALTAIRZ80D}/s100_fif.c ${ALTAIRZ80D}/s100_mdriveh.c \\\r\n\t${ALTAIRZ80D}/s100_icom.c \\\r\n\t${ALTAIRZ80D}/s100_jadedd.c \\\r\n\t${ALTAIRZ80D}/s100_mdsa.c \\\r\n\t${ALTAIRZ80D}/s100_mdsad.c ${ALTAIRZ80D}/s100_selchan.c \\\r\n\t${ALTAIRZ80D}/s100_ss1.c ${ALTAIRZ80D}/s100_64fdc.c \\\r\n\t${ALTAIRZ80D}/s100_scp300f.c \\\r\n\t${ALTAIRZ80D}/s100_tarbell.c \\\r\n\t${ALTAIRZ80D}/s100_tdd.c \\\r\n\t${ALTAIRZ80D}/wd179x.c ${ALTAIRZ80D}/s100_hdc1001.c \\\r\n\t${ALTAIRZ80D}/s100_if3.c ${ALTAIRZ80D}/s100_adcs6.c \\\r\n\t${ALTAIRZ80D}/m68k/m68kcpu.c ${ALTAIRZ80D}/m68k/m68kdasm.c ${ALTAIRZ80D}/m68k/m68kasm.c \\\r\n\t${ALTAIRZ80D}/m68k/m68kopac.c ${ALTAIRZ80D}/m68k/m68kopdm.c \\\r\n\t${ALTAIRZ80D}/m68k/softfloat/softfloat.c \\\r\n\t${ALTAIRZ80D}/m68k/m68kopnz.c ${ALTAIRZ80D}/m68k/m68kops.c ${ALTAIRZ80D}/m68ksim.c\r\nALTAIRZ80_OPT = -I ${ALTAIRZ80D} -DUSE_SIM_VIDEO ${VIDEO_CCDEFS} $(VIDEO_LDFLAGS)\r\n\r\n\r\nGRID = ${SIMHD}/GRI\r\nGRI = ${GRID}/gri_cpu.c ${GRID}/gri_stddev.c ${GRID}/gri_sys.c\r\nGRI_OPT = -I ${GRID}\r\n\r\n\r\nLGPD = ${SIMHD}/LGP\r\nLGP = ${LGPD}/lgp_cpu.c ${LGPD}/lgp_stddev.c ${LGPD}/lgp_sys.c\r\nLGP_OPT = -I ${LGPD}\r\n\r\n\r\nSDSD = ${SIMHD}/SDS\r\nSDS = ${SDSD}/sds_cpu.c ${SDSD}/sds_drm.c ${SDSD}/sds_dsk.c ${SDSD}/sds_io.c \\\r\n\t${SDSD}/sds_lp.c ${SDSD}/sds_mt.c ${SDSD}/sds_mux.c ${SDSD}/sds_rad.c \\\r\n\t${SDSD}/sds_stddev.c ${SDSD}/sds_sys.c ${SDSD}/sds_cp.c ${SDSD}/sds_cr.c\r\nSDS_OPT = -I ${SDSD} -DUSE_SIM_CARD\r\n\r\n\r\nSWTP6800D = ${SIMHD}/swtp6800/swtp6800\r\nSWTP6800C = ${SIMHD}/swtp6800/common\r\nSWTP6800MP-A = ${SWTP6800C}/mp-a.c ${SWTP6800C}/m6800.c ${SWTP6800C}/m6810.c \\\r\n\t${SWTP6800C}/bootrom.c ${SWTP6800C}/dc-4.c ${SWTP6800D}/mp-a_sys.c \\\r\n\t${SWTP6800C}/mp-8m.c ${SWTP6800C}/fd400.c ${SWTP6800C}/mp-b2.c \\\r\n\t${SWTP6800C}/mp-s.c\r\nSWTP6800MP-A2 = ${SWTP6800C}/mp-a2.c ${SWTP6800C}/m6800.c ${SWTP6800C}/m6810.c \\\r\n\t${SWTP6800C}/bootrom.c ${SWTP6800C}/dc-4.c ${SWTP6800D}/mp-a2_sys.c \\\r\n\t${SWTP6800C}/mp-8m.c ${SWTP6800C}/i2716.c ${SWTP6800C}/fd400.c \\\r\n\t${SWTP6800C}/mp-s.c ${SWTP6800C}/mp-b2.c\r\nSWTP6800_OPT = -I ${SWTP6800D}\r\n\r\nINTELSYSD = ${SIMHD}/Intel-Systems\r\nINTELSYSC = ${SIMHD}/Intel-Systems/common\r\n\r\nINTEL_PARTS = \\\r\n\t${INTELSYSC}/i3214.c \\\r\n\t${INTELSYSC}/i8251.c \\\r\n\t${INTELSYSC}/i8253.c \\\r\n\t${INTELSYSC}/i8255.c \\\r\n\t${INTELSYSC}/i8259.c \\\r\n\t${INTELSYSC}/ieprom.c \\\r\n\t${INTELSYSC}/ioc-cont.c \\\r\n\t${INTELSYSC}/ipc-cont.c \\\r\n\t${INTELSYSC}/iram8.c \\\r\n\t${INTELSYSC}/isbc064.c \\\r\n\t${INTELSYSC}/isbc202.c \\\r\n\t${INTELSYSC}/isbc201.c \\\r\n\t${INTELSYSC}/isbc206.c \\\r\n\t${INTELSYSC}/isbc464.c \\\r\n\t${INTELSYSC}/isbc208.c \\\r\n\t${INTELSYSC}/port.c \\\r\n\t${INTELSYSC}/irq.c \\\r\n\t${INTELSYSC}/multibus.c \\\r\n\t${INTELSYSC}/mem.c \\\r\n\t${INTELSYSC}/sys.c \\\r\n\t${INTELSYSC}/zx200a.c\r\n\r\n\r\nINTEL_MDSD = ${INTELSYSD}/Intel-MDS\r\nINTEL_MDS = ${INTELSYSC}/i8080.c ${INTEL_MDSD}/imds_sys.c \\\r\n\t${INTEL_PARTS}\r\nINTEL_MDS_OPT = -I ${INTEL_MDSD}\r\n\r\n\r\nIBMPCD = ${INTELSYSD}/ibmpc\r\nIBMPCC = ${INTELSYSD}/common\r\nIBMPC =\t${IBMPCC}/i8255.c ${IBMPCD}/ibmpc.c \\\r\n\t${IBMPCC}/i8088.c ${IBMPCD}/ibmpc_sys.c \\\r\n\t${IBMPCC}/i8253.c ${IBMPCC}/i8259.c \\\r\n\t${IBMPCC}/pceprom.c ${IBMPCC}/pcram8.c \\\r\n\t${IBMPCC}/i8237.c ${IBMPCC}/pcbus.c\r\nIBMPC_OPT = -I ${IBMPCD}\r\n\r\n\r\nIBMPCXTD = ${INTELSYSD}/ibmpcxt\r\nIBMPCXTC = ${INTELSYSD}/common\r\nIBMPCXT = ${IBMPCXTC}/i8088.c ${IBMPCXTD}/ibmpcxt_sys.c \\\r\n\t${IBMPCXTC}/i8253.c ${IBMPCXTC}/i8259.c \\\r\n\t${IBMPCXTC}/i8255.c ${IBMPCXTD}/ibmpcxt.c \\\r\n\t${IBMPCXTC}/pceprom.c ${IBMPCXTC}/pcram8.c \\\r\n\t${IBMPCXTC}/pcbus.c ${IBMPCXTC}/i8237.c\r\nIBMPCXT_OPT = -I ${IBMPCXTD}\r\n\r\n\r\nSCELBID = ${INTELSYSD}/scelbi\r\nSCELBIC = ${INTELSYSD}/common\r\nSCELBI = ${SCELBIC}/i8008.c ${SCELBID}/scelbi_sys.c ${SCELBID}/scelbi_io.c\r\nSCELBI_OPT = -I ${SCELBID}\r\n\r\n\r\nTX0D = ${SIMHD}/TX-0\r\nTX0 = ${TX0D}/tx0_cpu.c ${TX0D}/tx0_dpy.c ${TX0D}/tx0_stddev.c \\\r\n\t${TX0D}/tx0_sys.c ${TX0D}/tx0_sys_orig.c ${DISPLAYL}\r\nTX0_OPT = -I ${TX0D} ${DISPLAY_OPT}\r\n\r\n\r\nSSEMD = ${SIMHD}/SSEM\r\nSSEM = ${SSEMD}/ssem_cpu.c ${SSEMD}/ssem_sys.c\r\nSSEM_OPT = -I ${SSEMD}\r\n\r\nB5500D = ${SIMHD}/B5500\r\nB5500 = ${B5500D}/b5500_cpu.c ${B5500D}/b5500_io.c ${B5500D}/b5500_sys.c \\\r\n\t${B5500D}/b5500_dk.c ${B5500D}/b5500_mt.c ${B5500D}/b5500_urec.c \\\r\n\t${B5500D}/b5500_dr.c ${B5500D}/b5500_dtc.c\r\nB5500_OPT = -I ${B5500D} -DUSE_INT64 -DB5500 -DUSE_SIM_CARD\r\n\r\nBESM6D = ${SIMHD}/BESM6\r\nBESM6 = ${BESM6D}/besm6_cpu.c ${BESM6D}/besm6_sys.c ${BESM6D}/besm6_mmu.c \\\r\n        ${BESM6D}/besm6_arith.c ${BESM6D}/besm6_disk.c ${BESM6D}/besm6_drum.c \\\r\n        ${BESM6D}/besm6_tty.c ${BESM6D}/besm6_panel.c ${BESM6D}/besm6_printer.c \\\r\n        ${BESM6D}/besm6_pl.c ${BESM6D}/besm6_mg.c \\\r\n        ${BESM6D}/besm6_punch.c ${BESM6D}/besm6_punchcard.c ${BESM6D}/besm6_vu.c\r\nBESM6_OPT = -I ${BESM6D} -DUSE_INT64 $(VIDEO_TTF_OPT)\r\n\r\nPDP6D = ${SIMHD}/PDP10\r\nifneq (,${DISPLAY_OPT})\r\n  PDP6_DISPLAY_OPT =\r\nendif\r\nPDP6 = ${PDP6D}/kx10_cpu.c ${PDP6D}/kx10_sys.c ${PDP6D}/kx10_cty.c \\\r\n\t${PDP6D}/kx10_lp.c ${PDP6D}/kx10_pt.c ${PDP6D}/kx10_cr.c \\\r\n\t${PDP6D}/kx10_cp.c ${PDP6D}/pdp6_dct.c ${PDP6D}/pdp6_dtc.c \\\r\n\t${PDP6D}/pdp6_mtc.c ${PDP6D}/pdp6_dsk.c ${PDP6D}/pdp6_dcs.c \\\r\n\t${PDP6D}/kx10_dpy.c ${PDP6D}/pdp6_slave.c ${PDP6D}/pdp6_ge.c \\\r\n\t${DISPLAYL} ${DISPLAY340}\r\nPDP6_OPT = -DPDP6=1 -DUSE_INT64 -I ${PDP6D} -DUSE_SIM_CARD ${DISPLAY_OPT} ${PDP6_DISPLAY_OPT}\r\n\r\nKA10D = ${SIMHD}/PDP10\r\nifneq (,${DISPLAY_OPT})\r\n  KA10_DISPLAY_OPT =\r\nendif\r\nKA10 = ${KA10D}/kx10_cpu.c ${KA10D}/kx10_sys.c ${KA10D}/kx10_df.c \\\r\n\t${KA10D}/kx10_dp.c ${KA10D}/kx10_mt.c ${KA10D}/kx10_cty.c \\\r\n\t${KA10D}/kx10_lp.c ${KA10D}/kx10_pt.c ${KA10D}/kx10_dc.c \\\r\n\t${KA10D}/kx10_rp.c ${KA10D}/kx10_rc.c ${KA10D}/kx10_dt.c \\\r\n\t${KA10D}/kx10_dk.c ${KA10D}/kx10_cr.c ${KA10D}/kx10_cp.c \\\r\n\t${KA10D}/kx10_tu.c ${KA10D}/kx10_rs.c ${KA10D}/ka10_pd.c \\\r\n\t${KA10D}/kx10_rh.c ${KA10D}/kx10_imp.c ${KA10D}/ka10_tk10.c \\\r\n\t${KA10D}/ka10_mty.c ${KA10D}/ka10_imx.c ${KA10D}/ka10_ch10.c \\\r\n\t${KA10D}/ka10_stk.c ${KA10D}/ka10_ten11.c ${KA10D}/ka10_auxcpu.c \\\r\n\t$(KA10D)/ka10_pmp.c ${KA10D}/ka10_dkb.c ${KA10D}/pdp6_dct.c \\\r\n\t${KA10D}/pdp6_dtc.c ${KA10D}/pdp6_mtc.c ${KA10D}/pdp6_dsk.c \\\r\n\t${KA10D}/pdp6_dcs.c ${KA10D}/ka10_dpk.c ${KA10D}/kx10_dpy.c \\\r\n\t${KA10D}/ka10_ai.c ${KA10D}/ka10_iii.c ${KA10D}/kx10_disk.c \\\r\n\t${KA10D}/ka10_pclk.c ${KA10D}/ka10_tv.c ${KA10D}/ka10_dd.c \\\r\n\t${KA10D}/kx10_ddc.c ${DISPLAYL} ${DISPLAY340} ${DISPLAYIII} $(NETWORK_DEPS)\r\nKA10_OPT = -DKA=1 -DUSE_INT64 -I ${KA10D} -DUSE_SIM_CARD ${NETWORK_OPT} ${DISPLAY_OPT} ${KA10_DISPLAY_OPT}\r\nifneq (${PANDA_LIGHTS},)\r\n# ONLY for Panda display.\r\nKA10_OPT += -DPANDA_LIGHTS\r\nKA10 += ${KA10D}/ka10_lights.c\r\nKA10_LDFLAGS += -lusb-1.0\r\nendif\r\n\r\nKI10D = ${SIMHD}/PDP10\r\nifneq (,${DISPLAY_OPT})\r\nKI10_DISPLAY_OPT =\r\nendif\r\nKI10 = ${KI10D}/kx10_cpu.c ${KI10D}/kx10_sys.c ${KI10D}/kx10_df.c \\\r\n\t${KI10D}/kx10_dp.c ${KI10D}/kx10_mt.c ${KI10D}/kx10_cty.c \\\r\n\t${KI10D}/kx10_lp.c ${KI10D}/kx10_pt.c ${KI10D}/kx10_dc.c  \\\r\n\t${KI10D}/kx10_rh.c ${KI10D}/kx10_rp.c ${KI10D}/kx10_rc.c \\\r\n\t${KI10D}/kx10_dt.c ${KI10D}/kx10_dk.c ${KI10D}/kx10_cr.c \\\r\n\t${KI10D}/kx10_cp.c ${KI10D}/kx10_tu.c ${KI10D}/kx10_rs.c \\\r\n\t${KI10D}/kx10_imp.c ${KI10D}/kx10_dpy.c ${KI10D}/kx10_disk.c \\\r\n\t${KI10D}/kx10_ddc.c ${KI10D}/kx10_tym.c ${DISPLAYL} ${DISPLAY340} $(NETWORK_DEPS)\r\nKI10_OPT = -DKI=1 -DUSE_INT64 -I ${KI10D} -DUSE_SIM_CARD ${NETWORK_OPT} ${DISPLAY_OPT} ${KI10_DISPLAY_OPT}\r\nifneq (${PANDA_LIGHTS},)\r\n# ONLY for Panda display.\r\nKI10_OPT += -DPANDA_LIGHTS\r\nKI10 += ${KA10D}/ka10_lights.c\r\nKI10_LDFLAGS = -lusb-1.0\r\nendif\r\n\r\nKL10D = ${SIMHD}/PDP10\r\nKL10 =  ${KL10D}/kx10_cpu.c ${KL10D}/kx10_sys.c ${KL10D}/kx10_df.c \\\r\n    ${KA10D}/kx10_dp.c ${KA10D}/kx10_mt.c ${KA10D}/kx10_lp.c \\\r\n    ${KA10D}/kx10_pt.c ${KA10D}/kx10_dc.c ${KL10D}/kx10_rh.c \\\r\n    ${KA10D}/kx10_dt.c ${KA10D}/kx10_cr.c ${KA10D}/kx10_cp.c \\\r\n    ${KL10D}/kx10_rp.c ${KL10D}/kx10_tu.c ${KL10D}/kx10_rs.c \\\r\n    ${KL10D}/kx10_imp.c ${KL10D}/kl10_fe.c ${KL10D}/ka10_pd.c \\\r\n    ${KL10D}/ka10_ch10.c ${KL10D}/kl10_nia.c ${KL10D}/kx10_disk.c \\\r\n    $(NETWORK_DEPS)\r\nKL10_OPT = -DKL=1 -DUSE_INT64 -I $(KL10D) -DUSE_SIM_CARD ${NETWORK_OPT} \r\n\r\nKS10D = ${SIMHD}/PDP10\r\nKS10 = ${KS10D}/kx10_cpu.c ${KS10D}/kx10_sys.c ${KS10D}/kx10_disk.c \\\r\n\t${KS10D}/ks10_cty.c ${KS10D}/ks10_uba.c ${KS10D}/kx10_rh.c \\\r\n\t${KS10D}/kx10_rp.c ${KS10D}/kx10_tu.c ${KS10D}/ks10_dz.c \\\r\n\t${KS10D}/ks10_tcu.c ${KS10D}/ks10_lp.c ${KS10D}/ks10_ch11.c \\\r\n\t${KS10D}/ks10_kmc.c ${KS10D}/ks10_dup.c ${KS10D}/kx10_imp.c \\\r\n\t$(NETWORK_DEPS)\r\nKS10_OPT = -DKS=1 -DUSE_INT64 -I $(KS10D) -I $(PDP11D) ${NETWORK_OPT}\r\n\r\nATT3B2D = ${SIMHD}/3B2\r\nATT3B2M400 = ${ATT3B2D}/3b2_cpu.c ${ATT3B2D}/3b2_sys.c \\\r\n    ${ATT3B2D}/3b2_rev2_sys.c ${ATT3B2D}/3b2_rev2_mmu.c \\\r\n    ${ATT3B2D}/3b2_mau.c ${ATT3B2D}/3b2_rev2_csr.c \\\r\n    ${ATT3B2D}/3b2_timer.c ${ATT3B2D}/3b2_stddev.c \\\r\n    ${ATT3B2D}/3b2_mem.c ${ATT3B2D}/3b2_iu.c \\\r\n    ${ATT3B2D}/3b2_if.c ${ATT3B2D}/3b2_id.c \\\r\n    ${ATT3B2D}/3b2_dmac.c ${ATT3B2D}/3b2_io.c \\\r\n    ${ATT3B2D}/3b2_ports.c ${ATT3B2D}/3b2_ctc.c \\\r\n\t${ATT3B2D}/3b2_ni.c \\\r\n\t$(NETWORK_DEPS)\r\nATT3B2M400_OPT = -DUSE_INT64 -DUSE_ADDR64 -DREV2 -I ${ATT3B2D} ${NETWORK_OPT}\r\n\r\nATT3B2M700 = ${ATT3B2D}/3b2_cpu.c ${ATT3B2D}/3b2_sys.c \\\r\n    ${ATT3B2D}/3b2_rev3_sys.c ${ATT3B2D}/3b2_rev3_mmu.c \\\r\n    ${ATT3B2D}/3b2_mau.c ${ATT3B2D}/3b2_rev3_csr.c \\\r\n    ${ATT3B2D}/3b2_timer.c ${ATT3B2D}/3b2_stddev.c \\\r\n    ${ATT3B2D}/3b2_mem.c ${ATT3B2D}/3b2_iu.c \\\r\n    ${ATT3B2D}/3b2_if.c ${ATT3B2D}/3b2_dmac.c \\\r\n    ${ATT3B2D}/3b2_io.c ${ATT3B2D}/3b2_ports.c \\\r\n\t${ATT3B2D}/3b2_scsi.c ${ATT3B2D}/3b2_ni.c \\\r\n\t$(NETWORK_DEPS)\r\nATT3B2M700_OPT = -DUSE_INT64 -DUSE_ADDR64 -DREV3 -I ${ATT3B2D} ${NETWORK_OPT}\r\n\r\nSIGMAD = ${SIMHD}/sigma\r\nSIGMA = ${SIGMAD}/sigma_cpu.c ${SIGMAD}/sigma_sys.c ${SIGMAD}/sigma_cis.c \\\r\n\t${SIGMAD}/sigma_coc.c ${SIGMAD}/sigma_dk.c ${SIGMAD}/sigma_dp.c \\\r\n\t${SIGMAD}/sigma_fp.c ${SIGMAD}/sigma_io.c ${SIGMAD}/sigma_lp.c \\\r\n\t${SIGMAD}/sigma_map.c ${SIGMAD}/sigma_mt.c ${SIGMAD}/sigma_pt.c \\\r\n\t${SIGMAD}/sigma_rad.c ${SIGMAD}/sigma_rtc.c ${SIGMAD}/sigma_tt.c \\\r\n\t${SIGMAD}/sigma_cr.c ${SIGMAD}/sigma_cp.c \r\nSIGMA_OPT = -I ${SIGMAD}\r\n\r\nSEL32D = ${SIMHD}/SEL32\r\nSEL32 = ${SEL32D}/sel32_cpu.c ${SEL32D}/sel32_sys.c ${SEL32D}/sel32_chan.c \\\r\n\t${SEL32D}/sel32_iop.c ${SEL32D}/sel32_com.c ${SEL32D}/sel32_con.c \\\r\n\t${SEL32D}/sel32_clk.c ${SEL32D}/sel32_mt.c ${SEL32D}/sel32_lpr.c \\\r\n\t${SEL32D}/sel32_scfi.c ${SEL32D}/sel32_fltpt.c ${SEL32D}/sel32_disk.c \\\r\n\t${SEL32D}/sel32_hsdp.c ${SEL32D}/sel32_mfp.c ${SEL32D}/sel32_scsi.c \\\r\n\t${SEL32D}/sel32_ec.c \\\r\n\t$(NETWORK_DEPS)\r\nSEL32_OPT = -I ${SEL32D} -DUSE_INT32 -DSEL32  ${NETWORK_OPT}\r\n\r\n###\r\n### Experimental simulators\r\n###\r\n\r\nCDC1700D = ${SIMHD}/CDC1700\r\nCDC1700 = ${CDC1700D}/cdc1700_cpu.c ${CDC1700D}/cdc1700_dis.c \\\r\n        ${CDC1700D}/cdc1700_io.c ${CDC1700D}/cdc1700_sys.c \\\r\n        ${CDC1700D}/cdc1700_dev1.c ${CDC1700D}/cdc1700_mt.c \\\r\n        ${CDC1700D}/cdc1700_dc.c ${CDC1700D}/cdc1700_iofw.c \\\r\n        ${CDC1700D}/cdc1700_lp.c ${CDC1700D}/cdc1700_dp.c \\\r\n        ${CDC1700D}/cdc1700_cd.c ${CDC1700D}/cdc1700_sym.c \\\r\n        ${CDC1700D}/cdc1700_rtc.c ${CDC1700D}/cdc1700_drm.c \\\r\n        ${CDC1700D}/cdc1700_msos5.c\r\nCDC1700_OPT = -I ${CDC1700D}\r\n\r\n###\r\n### Unsupported/Incomplete simulators\r\n###\r\n\r\nALPHAD = ${SIMHD}/alpha\r\nALPHA = ${ALPHAD}/alpha_500au_syslist.c ${ALPHAD}/alpha_cpu.c \\\r\n    ${ALPHAD}/alpha_ev5_cons.c ${ALPHAD}/alpha_ev5_pal.c \\\r\n    ${ALPHAD}/alpha_ev5_tlb.c ${ALPHAD}/alpha_fpi.c \\\r\n    ${ALPHAD}/alpha_fpv.c ${ALPHAD}/alpha_io.c \\\r\n    ${ALPHAD}/alpha_mmu.c ${ALPHAD}/alpha_sys.c\r\nALPHA_OPT = -I ${ALPHAD} -DUSE_ADDR64 -DUSE_INT64\r\n\r\nSAGED = ${SIMHD}/SAGE\r\nSAGE = ${SAGED}/sage_cpu.c ${SAGED}/sage_sys.c ${SAGED}/sage_stddev.c \\\r\n    ${SAGED}/sage_cons.c ${SAGED}/sage_fd.c ${SAGED}/sage_lp.c \\\r\n    ${SAGED}/m68k_cpu.c ${SAGED}/m68k_mem.c ${SAGED}/m68k_scp.c \\\r\n    ${SAGED}/m68k_parse.tab.c ${SAGED}/m68k_sys.c \\\r\n    ${SAGED}/i8251.c ${SAGED}/i8253.c ${SAGED}/i8255.c ${SAGED}/i8259.c ${SAGED}/i8272.c \r\nSAGE_OPT = -I ${SAGED} -DHAVE_INT64\r\n\r\nPDQ3D = ${SIMHD}/PDQ-3\r\nPDQ3 = ${PDQ3D}/pdq3_cpu.c ${PDQ3D}/pdq3_sys.c ${PDQ3D}/pdq3_stddev.c \\\r\n    ${PDQ3D}/pdq3_mem.c ${PDQ3D}/pdq3_debug.c ${PDQ3D}/pdq3_fdc.c\r\nPDQ3_OPT = -I ${PDQ3D}\r\n\r\n#\r\n# Build everything (not the unsupported/incomplete or experimental simulators)\r\n#\r\nALL = pdp1 pdp4 pdp7 pdp8 pdp9 pdp15 pdp11 pdp10 \\\r\n\tvax microvax3900 microvax1 rtvax1000 microvax2 vax730 vax750 vax780 \\\r\n\tvax8200 vax8600 besm6 \\\r\n\tmicrovax2000 infoserver100 infoserver150vxt microvax3100 microvax3100e \\\r\n\tvaxstation3100m30 vaxstation3100m38 vaxstation3100m76 vaxstation4000m60 \\\r\n\tmicrovax3100m80 vaxstation4000vlc infoserver1000 \\\r\n\tnd100 nova eclipse hp2100 hp3000 i1401 i1620 s3 altair altairz80 gri \\\r\n\ti7094 ibm1130 id16 id32 sds lgp h316 cdc1700 \\\r\n\tswtp6800mp-a swtp6800mp-a2 tx-0 ssem b5500 intel-mds \\\r\n\tscelbi 3b2 3b2-700 i701 i704 i7010 i7070 i7080 i7090 \\\r\n\tsigma uc15 pdp10-ka pdp10-ki pdp10-kl pdp10-ks pdp6 i650 \\\r\n\timlac tt2500 sel32\r\n\r\nall : ${ALL}\r\n\r\nEXPERIMENTAL = alpha pdq3 sage\r\n\r\nexperimental : ${EXPERIMENTAL}\r\n\r\nclean :\r\nifeq (${WIN32},)\r\n\t-${RM} -rf ${BIN}\r\nelse\r\n\t-if exist $(BIN) rmdir /s /q BIN\r\nendif\r\n\r\n${BUILD_ROMS} :\r\n\t${MKDIRBIN}\r\nifeq (${WIN32},)\r\n\t@if ${TEST} \\( ! -e $@ \\) -o \\( sim_BuildROMs.c -nt $@ \\) ; then ${CC} sim_BuildROMs.c ${CC_OUTSPEC}; fi\r\nelse\r\n\t@if not exist $@ ${CC} sim_BuildROMs.c ${CC_OUTSPEC}\r\nendif\r\n\t@$@\r\n\r\nMAKEFLAGS += --no-print-directory\r\n\r\n#\r\n# Individual builds\r\n#\r\n\r\npdp1 : $(BIN)pdp1$(EXE)\r\n\r\n$(BIN)pdp1$(EXE) : $(PDP1) $(SIM)\r\n\t$(MAKEIT) OPTS=\"$(PDP1_OPT)\"\r\n\r\n\r\npdp4 : $(BIN)pdp4$(EXE)\r\n\r\n$(BIN)pdp4$(EXE) : $(PDP18B) $(SIM)\r\n\t$(MAKEIT) OPTS=\"$(PDP4_OPT)\"\r\n\r\n\r\npdp7 : $(BIN)pdp7$(EXE)\r\n\r\n$(BIN)pdp7$(EXE) : $(PDP18B) ${PDP18BD}/pdp18b_dpy.c ${DISPLAYL} ${DISPLAY340} $(SIM)\r\n\t$(MAKEIT) OPTS=\"$(PDP7_OPT)\"\r\n\r\n\r\npdp8 : $(BIN)pdp8$(EXE)\r\n\r\n$(BIN)pdp8$(EXE) : ${PDP8} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(PDP8_OPT)\"\r\n\r\n\r\npdp9 : $(BIN)pdp9$(EXE)\r\n\r\n$(BIN)pdp9$(EXE) : ${PDP18B} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(PDP9_OPT)\"\r\n\r\n\r\npdp15 : $(BIN)pdp15$(EXE)\r\n\r\n$(BIN)pdp15$(EXE) : ${PDP18B} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(PDP15_OPT)\"\r\n\r\n\r\npdp10 : $(BIN)pdp10$(EXE)\r\n\r\n$(BIN)pdp10$(EXE) : ${PDP10} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(PDP10_OPT)\"\r\n\r\n\r\nimlac : $(BIN)imlac$(EXE)\r\n\r\n$(BIN)imlac$(EXE) : ${IMLAC} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(IMLAC_OPT)\"\r\n\r\n\r\ntt2500 : $(BIN)tt2500$(EXE)\r\n\r\n$(BIN)tt2500$(EXE) : ${TT2500} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(TT2500_OPT)\"\r\n\r\n\r\npdp11 : $(BIN)pdp11$(EXE)\r\n\r\n$(BIN)pdp11$(EXE) : ${PDP11} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(PDP11_OPT)\"\r\n\r\n\r\nuc15 : $(BIN)uc15$(EXE)\r\n\r\n$(BIN)uc15$(EXE) : ${UC15} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(UC15_OPT)\"\r\n\r\n\r\nmicrovax3900 : vax\r\n\r\nvax : $(BIN)vax$(EXE)\r\n\r\n$(BIN)vax$(EXE) : ${VAX} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX_OPT)\" TEST_NAME=vax-diag ALTNAME=microvax3900\r\n\r\n\r\nmicrovax2000 : $(BIN)microvax2000$(EXE)\r\n\r\n$(BIN)microvax2000$(EXE) : ${VAX410} ${SIM} ${SCSI} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX410_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\ninfoserver100 : $(BIN)infoserver100$(EXE)\r\n\r\n$(BIN)infoserver100$(EXE) : ${VAX420} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX411_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\ninfoserver150vxt : $(BIN)infoserver150vxt$(EXE)\r\n\r\n$(BIN)infoserver150vxt$(EXE) : ${VAX420} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX412_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nmicrovax3100 : $(BIN)microvax3100$(EXE)\r\n\r\n$(BIN)microvax3100$(EXE) : ${VAX420} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX41A_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nmicrovax3100e : $(BIN)microvax3100e$(EXE)\r\n\r\n$(BIN)microvax3100e$(EXE) : ${VAX420} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX41D_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvaxstation3100m30 : $(BIN)vaxstation3100m30$(EXE)\r\n\r\n$(BIN)vaxstation3100m30$(EXE) : ${VAX420} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX42A_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvaxstation3100m38 : $(BIN)vaxstation3100m38$(EXE)\r\n\r\n$(BIN)vaxstation3100m38$(EXE) : ${VAX420} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX42B_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvaxstation3100m76 : $(BIN)vaxstation3100m76$(EXE)\r\n\r\n$(BIN)vaxstation3100m76$(EXE) : ${VAX43} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX43_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvaxstation4000m60 : $(BIN)vaxstation4000m60$(EXE)\r\n\r\n$(BIN)vaxstation4000m60$(EXE) : ${VAX440} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX46_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nmicrovax3100m80 : $(BIN)microvax3100m80$(EXE)\r\n\r\n$(BIN)microvax3100m80$(EXE) : ${VAX440} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX47_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvaxstation4000vlc : $(BIN)vaxstation4000vlc$(EXE)\r\n\r\n$(BIN)vaxstation4000vlc$(EXE) : ${VAX440} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX48_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\ninfoserver1000 : $(BIN)infoserver1000$(EXE)\r\n\r\n$(BIN)infoserver1000$(EXE) : ${IS1000} ${SCSI} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(IS1000_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nmicrovax1 : $(BIN)microvax1$(EXE)\r\n\r\n$(BIN)microvax1$(EXE) : ${VAX610} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX610_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nrtvax1000 : $(BIN)rtvax1000$(EXE)\r\n\r\n$(BIN)rtvax1000$(EXE) : ${VAX630} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX620_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nmicrovax2 : $(BIN)microvax2$(EXE)\r\n\r\n$(BIN)microvax2$(EXE) : ${VAX630} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX630_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvax730 : $(BIN)vax730$(EXE)\r\n\r\n$(BIN)vax730$(EXE) : ${VAX730} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX730_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvax750 : $(BIN)vax750$(EXE)\r\n\r\n$(BIN)vax750$(EXE) : ${VAX750} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX750_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvax780 : $(BIN)vax780$(EXE)\r\n\r\n$(BIN)vax780$(EXE) : ${VAX780} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX780_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvax8200 : $(BIN)vax8200$(EXE)\r\n\r\n$(BIN)vax8200$(EXE) : ${VAX8200} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX8200_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nvax8600 : $(BIN)vax8600$(EXE)\r\n\r\n$(BIN)vax8600$(EXE) : ${VAX8600} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(VAX8600_OPT)\" TEST_NAME=vax-diag\r\n\r\n\r\nnd100 : $(BIN)nd100$(EXE)\r\n\r\n$(BIN)nd100$(EXE) : ${ND100} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ND100_OPT)\"\r\n\r\n\r\nnova : $(BIN)nova$(EXE)\r\n\r\n$(BIN)nova$(EXE) : ${NOVA} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(NOVA_OPT)\"\r\n\r\n\r\neclipse : $(BIN)eclipse$(EXE)\r\n\r\n$(BIN)eclipse$(EXE) : ${ECLIPSE} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ECLIPSE_OPT)\"\r\n\r\n\r\nh316 : $(BIN)h316$(EXE)\r\n\r\n$(BIN)h316$(EXE) : ${H316} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(H316_OPT)\"\r\n\r\n\r\nhp2100 : $(BIN)hp2100$(EXE)\r\n\r\n$(BIN)hp2100$(EXE) : ${HP2100} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(HP2100_OPT)\" NOCPP=1\r\n\r\n\r\nhp3000 : $(BIN)hp3000$(EXE)\r\n\r\n$(BIN)hp3000$(EXE) : ${HP3000} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(HP3000_OPT)\" NOCPP=1\r\n\r\n\r\ni1401 : $(BIN)i1401$(EXE)\r\n\r\n$(BIN)i1401$(EXE) : ${I1401} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I1401_OPT)\"\r\n\r\n\r\ni1620 : $(BIN)i1620$(EXE)\r\n\r\n$(BIN)i1620$(EXE) : ${I1620} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I1620_OPT)\"\r\n\r\n\r\ni7094 : $(BIN)i7094$(EXE)\r\n\r\n$(BIN)i7094$(EXE) : ${I7094} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I7094_OPT)\"\r\n\r\n\r\nibm1130 : $(BIN)ibm1130$(EXE)\r\n\r\n#$(BIN)ibm1130$(EXE) : ${IBM1130} $(SIM)\r\n#\t$(MAKEIT) OPTS=\"$(IBM1130_OPT)\" NOCPP=1\r\n\r\n${BIN}ibm1130${EXE} : ${IBM1130}\r\nifneq (1,${CPP_BUILD}${CPP_FORCE})\r\n\t${MKDIRBIN}\r\nifneq (${WIN32},)\r\n\twindres ${IBM1130D}/ibm1130.rc ${BIN}ibm1130.o\r\nendif\r\n\t${CC} ${IBM1130} ${SIM} ${IBM1130_OPT} ${CC_OUTSPEC} ${LDFLAGS}\r\nifneq (${WIN32},)\r\n\tdel $(BIN)\\ibm1130.o\r\nendif\r\nifneq (,$(call find_test,Ibm1130))\r\n\t$@ $(call find_test,Ibm1130) ${TEST_ARG}\r\nendif\r\nelse\r\n\t$(info ibm1130 can not be built using C++)\r\nendif\r\n\r\ns3 : $(BIN)s3$(EXE)\r\n\r\n$(BIN)s3$(EXE) : ${S3} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(S3_OPT)\"\r\n\r\n\r\nsel32 : $(BIN)sel32$(EXE)\r\n\r\n$(BIN)sel32$(EXE) : ${SEL32} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(SEL32_OPT)\"\r\n\r\n\r\naltair : $(BIN)altair$(EXE)\r\n\r\n$(BIN)altair$(EXE) : ${ALTAIR} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ALTAIR_OPT)\"\r\n\r\n\r\naltairz80 : $(BIN)altairz80$(EXE)\r\n\r\n$(BIN)altairz80$(EXE) : ${ALTAIRZ80} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ALTAIRZ80_OPT)\"\r\n\r\n\r\ngri : $(BIN)gri$(EXE)\r\n\r\n$(BIN)gri$(EXE) : ${GRI} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(GRI_OPT)\"\r\n\r\n\r\nlgp : $(BIN)lgp$(EXE)\r\n\r\n$(BIN)lgp$(EXE) : ${LGP} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(LGP_OPT)\"\r\n\r\n\r\nid16 : $(BIN)id16$(EXE)\r\n\r\n$(BIN)id16$(EXE) : ${ID16} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ID16_OPT)\"\r\n\r\n\r\nid32 : $(BIN)id32$(EXE)\r\n\r\n$(BIN)id32$(EXE) : ${ID32} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ID32_OPT)\"\r\n\r\n\r\nsds : $(BIN)sds$(EXE)\r\n\r\n$(BIN)sds$(EXE) : ${SDS} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(SDS_OPT)\"\r\n\r\n\r\nswtp6800mp-a : $(BIN)swtp6800mp-a$(EXE)\r\n\r\n$(BIN)swtp6800mp-a$(EXE) : ${SWTP6800MP-A} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(SWTP6800_OPT)\"\r\n\r\n\r\nswtp6800mp-a2 : $(BIN)swtp6800mp-a2$(EXE)\r\n\r\n$(BIN)swtp6800mp-a2$(EXE) : ${SWTP6800MP-A2} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(SWTP6800_OPT)\"\r\n\r\n\r\nintel-mds : $(BIN)intel-mds$(EXE)\r\n\r\n$(BIN)intel-mds$(EXE) : ${INTEL_MDS} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(INTEL_MDS_OPT)\"\r\n\r\n\r\nibmpc : $(BIN)ibmpc$(EXE)\r\n\r\n$(BIN)ibmpc$(EXE) : ${IBMPC} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(IBMPC_OPT)\"\r\n\r\n\r\nibmpcxt : $(BIN)ibmpcxt$(EXE)\r\n\r\n$(BIN)ibmpcxt$(EXE) : ${IBMPCXT} ${SIM} ${BUILD_ROMS}\r\n\t$(MAKEIT) OPTS=\"$(IBMPCXT_OPT)\"\r\n\r\n\r\nscelbi : $(BIN)scelbi$(EXE)\r\n\r\n$(BIN)scelbi$(EXE) : ${SCELBI} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(SCELBI_OPT)\"\r\n\r\n\r\ntx-0 : $(BIN)tx-0$(EXE)\r\n\r\n$(BIN)tx-0$(EXE) : ${TX0} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(TX0_OPT)\"\r\n\r\n\r\nssem : $(BIN)ssem$(EXE)\r\n\r\n$(BIN)ssem$(EXE) : ${SSEM} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(SSEM_OPT)\"\r\n\r\n\r\ncdc1700 : $(BIN)cdc1700$(EXE)\r\n\r\n$(BIN)cdc1700$(EXE) : ${CDC1700} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(CDC1700_OPT)\"\r\n\r\n\r\nbesm6 : $(BIN)besm6$(EXE)\r\n\r\n$(BIN)besm6$(EXE) : ${BESM6} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(BESM6_OPT)\" NOCPP=1\r\n\r\n\r\nsigma : $(BIN)sigma$(EXE)\r\n\r\n$(BIN)sigma$(EXE) : ${SIGMA} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(SIGMA_OPT)\"\r\n\r\n\r\nalpha : $(BIN)alpha$(EXE)\r\n\r\n$(BIN)alpha$(EXE) : ${ALPHA} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ALPHA_OPT)\"\r\n\r\n\r\nsage : $(BIN)sage$(EXE)\r\n\r\n$(BIN)sage$(EXE) : ${SAGE} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(SAGE_OPT)\"\r\n\r\n\r\npdq3 : $(BIN)pdq3$(EXE)\r\n\r\n$(BIN)pdq3$(EXE) : ${PDQ3} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(PDQ3_OPT)\"\r\n\r\n\r\nb5500 : $(BIN)b5500$(EXE)\r\n\r\n$(BIN)b5500$(EXE) : ${B5500} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(B5500_OPT)\"\r\n\r\n\r\n3b2 : $(BIN)3b2$(EXE)\r\n\r\n$(BIN)3b2$(EXE) : ${ATT3B2M400} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ATT3B2M400_OPT)\" ALTNAME=3b2-400\r\n \r\n\r\n3b2-700 : $(BIN)3b2-700$(EXE)\r\n\r\n$(BIN)3b2-700$(EXE) : ${ATT3B2M700} ${SCSI} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(ATT3B2M700_OPT)\"\r\n\r\n\r\ni7090 : $(BIN)i7090$(EXE)\r\n\r\n$(BIN)i7090$(EXE) : ${I7090} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I7090_OPT)\"\r\n\r\n\r\ni7080 : $(BIN)i7080$(EXE)\r\n\r\n$(BIN)i7080$(EXE) : ${I7080} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I7080_OPT)\"\r\n\r\n\r\ni7070 : $(BIN)i7070$(EXE)\r\n\r\n$(BIN)i7070$(EXE) : ${I7070} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I7070_OPT)\"\r\n\r\n\r\ni7010 : $(BIN)i7010$(EXE)\r\n\r\n$(BIN)i7010$(EXE) : ${I7010} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I7010_OPT)\"\r\n\r\n\r\ni704 : $(BIN)i704$(EXE)\r\n\r\n$(BIN)i704$(EXE) : ${I704} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I704_OPT)\"\r\n\r\n\r\ni701 : $(BIN)i701$(EXE)\r\n\r\n$(BIN)i701$(EXE) : ${I701} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I701_OPT)\"\r\n\r\n\r\ni650 : $(BIN)i650$(EXE)\r\n\r\n$(BIN)i650$(EXE) : ${I650} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(I650_OPT)\"\r\n\r\n\r\npdp6 : $(BIN)pdp6$(EXE)\r\n\r\n$(BIN)pdp6$(EXE) : ${PDP6} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(PDP6_OPT)\"\r\n\r\n\r\npdp10-ka : $(BIN)pdp10-ka$(EXE)\r\n\r\n$(BIN)pdp10-ka$(EXE) : ${KA10} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(KA10_OPT)\"\r\n\r\n\r\npdp10-ki : $(BIN)pdp10-ki$(EXE)\r\n\r\n$(BIN)pdp10-ki$(EXE) : ${KI10} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(KI10_OPT)\"\r\n\r\n\r\npdp10-kl : $(BIN)pdp10-kl$(EXE)\r\n\r\n$(BIN)pdp10-kl$(EXE) : ${KL10} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(KL10_OPT)\"\r\n\r\n\r\npdp10-ks : $(BIN)pdp10-ks$(EXE)\r\n\r\n$(BIN)pdp10-ks$(EXE) : ${KS10} ${SIM}\r\n\t$(MAKEIT) OPTS=\"$(KS10_OPT)\"\r\n\r\n\r\n\r\n# Front Panel API Demo/Test program\r\n\r\nfrontpaneltest : ${BIN}frontpaneltest${EXE} ${BIN}vax${EXE} \r\n\r\n${BIN}frontpaneltest${EXE} : frontpanel/FrontPanelTest.c sim_sock.c sim_frontpanel.c\r\n\t#cmake:ignore-target\r\n\t$(MAKEIT) OPTS=\"$(OS_CURSES_DEFS)\" TESTS=0\r\n\r\nelse # end of primary make recipies\r\n\r\n  # Recursion support to build simulator objects and/or binaries\r\n  # This section exists for make recursion to achieve individual target \r\n  # builds.\r\n\r\n  # potential specified input parameters\r\n  #    OPTS      - the compile options (required)\r\n  #    LNK_OPTS  - optional platform specific linker options\r\n  #    TEST_NAME - the name of the simulator test script (when not simply named <simulator-name>_test.ini)\r\n  #    ALTNAME   - an optional alternate name for the current simulator target\r\n  \r\n  override DEPS := $(filter %.c,$(DEPS))  # only worry about building C source modules\r\n\r\n  ifeq (,$(OPTS))\r\n    $(error ERROR ***  Missing build options.)\r\n  endif\r\n\r\n  ifneq (,$(QUIET))\r\n    CC := @$(CC)\r\n  endif\r\n\r\n  # Extract source directories from the dependencies\r\n  D0 = $(foreach dir,$(DEPS),$(dir $(dir)))\r\n  # Isolate the directory of the first dependency\r\n  PRIMARY_SRC = $(word 1, $(D0))\r\n  D1 = $(sort $(D0))\r\n\r\n  # Extract potential source code directories from the -I specifiers in the options\r\n\r\n  space = $(empty) $(empty)\r\n  # Combine all options separated with ^\r\n  D2=$(subst $(space),^,^$(OPTS))\r\n  # split the options with -I at the beginning of each element\r\n  D3=$(subst ^-I,$(space)^-I,$(D2))\r\n  # strip out includes for known support directories (system/dependenty includes \r\n  # starting with /, slirp, slirp_glue, display, etc - with or without spaces between the \r\n  # -I and the directory)\r\n  D4=$(filter-out ^-I/%,$(filter-out ^-I^/%,$(filter-out ^-Islirp%,$(filter-out ^-I^slirp%,$(filter-out ^-Islirp_glue%,$(filter-out ^-I^slirp_glue%,$(filter-out ^-Idisplay%,$(filter-out ^-I^display%,$(D3)))))))))\r\n  # remove leading element if it isn't an include\r\n  D5=$(filter ^-I%,$(D4))\r\n  # strip off the leading -I include specifier\r\n  D6=$(foreach include,$(D5),$(patsubst ^-I%,%,$(include)))\r\n  # chop off any extra options beyond the include directory\r\n  D7=$(foreach include,$(D6),$(word 1,$(subst ^,$(space),$(include))))\r\n  PRIMARY_INC = $(word 1, $(D7))\r\n  DIRS = $(strip $(D7) $(D1))\r\n  ifneq ($(WIN32),)\r\n    pathfix = $(subst /,\\,$(1))\r\n  else\r\n    pathfix = $(1)\r\n  endif\r\n\r\n  find_test = $(if $(findstring 0,$(TESTS)),, RegisterSanityCheck $(if $(abspath $(wildcard $(PRIMARY_SRC)/tests/$(1)_test.ini)),$(abspath $(wildcard $(PRIMARY_SRC)/tests/$(1)_test.ini)),$(abspath $(wildcard $(PRIMARY_INC)/tests/$(1)_test.ini))) </dev/null)\r\n\r\n  TARGETNAME = $(basename $(notdir $(TARGET)))\r\n  BIN = $(dir $(TARGET))\r\n  EXE = $(suffix $(TARGET))\r\n  BLDDIR = $(BIN)$(OSTYPE)-build/$(TARGETNAME)\r\n  OBJS = $(addsuffix .o,$(addprefix $(BLDDIR)/,$(basename $(notdir $(DEPS)))))\r\n  $(shell $(MKDIR) $(call pathfix,$(BLDDIR)))\r\n  ifeq (,$(findstring 3.,$(GNUMakeVERSION)))\r\n    define NEWLINE\r\n$(empty)\r\n$(empty)\r\nendef\r\n    MAKE_INFO = $(foreach VAR,CC OPTS LNK_OPTS DEPS LDFLAGS DIRS BUILD_SEPARATE,$(VAR)=$($(VAR))$(NEWLINE))\r\n    PRIOR_MAKE_INFO = $(shell if ${TEST} -e $(call pathfix,$(BLDDIR)/Make.info); then cat $(call pathfix,$(BLDDIR)/Make.info); fi)\r\n    ifneq ($(strip $(subst $(NEWLINE), ,$(MAKE_INFO))),$(strip $(PRIOR_MAKE_INFO)))\r\n      # Different or no prior options, so start from scratch\r\n      $(shell $(RM) $(call pathfix,$(BLDDIR)/*) $(call pathfix,$(wildcard $(TARGET))))\r\n      $(file >$(BLDDIR)/Make.info,$(MAKE_INFO))\r\n    endif\r\n  endif\r\n\r\n  ifneq (,$(and $(CPP_BUILD),$(NOCPP)))\r\n    $(warning the $(TARGETNAME) simulator can not be built using C++)\r\n  else\r\n\r\n$(BLDDIR)/%.o : $(word 1,$(DIRS))/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : $(word 1,$(DIRS))/*/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : $(word 1,$(DIRS))/*/*/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : display/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : slirp/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : slirp_glue/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : %.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\nifneq (,$(word 2,$(DIRS)))\r\n$(BLDDIR)/%.o : $(word 2,$(DIRS))/%.c\r\n\t-@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : $(word 2,$(DIRS))/*/%.c\r\n\t@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : $(word 2,$(DIRS))/*/*/%.c\r\n\t@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\nifneq (,$(word 3,$(DIRS)))\r\n$(BLDDIR)/%.o : $(word 3,$(DIRS))/%.c\r\n\t@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : $(word 3,$(DIRS))/*/%.c\r\n\t@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\n\r\n$(BLDDIR)/%.o : $(word 3,$(DIRS))/*/*/%.c\r\n\t@$(MKDIR) $(call pathfix,$(dir $@))\r\n  ifneq (,$(QUIET))\r\n\t@echo Compiling $< into $@\r\n  endif\r\n\t$(CC) -c $< -o $@ ${OPTS}\r\nendif\r\nendif\r\n\r\n\r\n    ifeq (,$(TEST_NAME))\r\n      override TEST_NAME = $(TARGETNAME)\r\n    endif\r\n\r\n    ifneq (,$(BUILD_SEPARATE))\r\n# Multiple Separate compiles for each input\r\n$(TARGET): $(OBJS)\r\n\t$(MKDIRBIN)\r\n    ifneq (,$(QUIET))\r\n\t  @echo Linking $(TARGET)\r\n    endif\r\n\t  ${CC} $(OBJS) ${OPTS} ${LNK_OPTS} -o $@ ${LDFLAGS}\r\n    else\r\n# Single Compile and Link of all inputs\r\n$(TARGET): $(DEPS)\r\n\t$(MKDIRBIN)\r\n    ifneq (,$(QUIET))\r\n\t  @echo Compile and Linking $(DEPS) into $(TARGET)\r\n    endif\r\n\t${CC} $(DEPS) ${OPTS} ${LNK_OPTS} -o $@ ${LDFLAGS}\r\n    endif\r\n    ifneq (,$(ALTNAME))\r\n      ifeq (${WIN32},)\r\n\tcp $(TARGET) $(@D)/$(ALTNAME)${EXE}\r\n      else\r\n\tcopy $(TARGET) $(@D)\\$(ALTNAME)${EXE}\r\n      endif\r\n    endif\r\n    ifneq (,$(call find_test,$(TEST_NAME)))\r\n    # invoke the just built simulator to engage its test activities\r\n\t$@ $(call find_test,$(TEST_NAME)) ${TEST_ARG}\r\n    endif\r\n    ifneq (,$(SOURCE_CHECK))\r\n\t  $@ $(SOURCE_CHECK_SWITCHES) CheckSourceCode $(DEPS)\r\n    endif\r\n\r\n  endif  # CPP_BUILD\r\nendif # makefile recursion build support\r\n"
        },
        {
          "name": "scp.c",
          "type": "blob",
          "size": 703.0087890625,
          "content": "/* scp.c: simulator control program\r\n\r\n   Copyright (c) 1993-2022, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   21-Oct-21    RMS     Fixed bug in byte deposits if aincr > 1\r\n   16-Feb-21    JDB     Rewrote get_rval, put_rval to support arrays of structures\r\n   25-Jan-21    JDB     REG \"size\" field now determines access size\r\n                        REG \"maxval\" field now determines maximum allowed value\r\n   08-Mar-16    RMS     Added shutdown flag for detach_all\r\n   20-Mar-12    MP      Fixes to \"SHOW <x> SHOW\" commands\r\n   06-Jan-12    JDB     Fixed \"SHOW DEVICE\" with only one enabled unit (Dave Bryan)\r\n   25-Sep-11    MP      Added the ability for a simulator built with\r\n                        SIM_ASYNCH_IO to change whether I/O is actually done\r\n                        asynchronously by the new scp command SET ASYNCH and\r\n                        SET NOASYNCH\r\n   22-Sep-11    MP      Added signal catching of SIGHUP and SIGTERM to cause\r\n                        simulator STOP.  This allows an externally signalled\r\n                        event (i.e. system shutdown, or logoff) to signal a\r\n                        running simulator of these events and to allow\r\n                        reasonable actions to be taken.  This will facilitate\r\n                        running a simulator as a 'service' on *nix platforms,\r\n                        given a sufficiently flexible simulator .ini file.\r\n   20-Apr-11    MP      Added expansion of %STATUS% and %TSTATUS% in do command\r\n                        arguments.  STATUS is the numeric value of the last\r\n                        command error status and TSTATUS is the text message\r\n                        relating to the last command error status\r\n   17-Apr-11    MP      Changed sim_rest to defer attaching devices until after\r\n                        device register contents have been restored since some\r\n                        attach activities may reference register contained info.\r\n   29-Jan-11    MP      Adjusted sim_debug to:\r\n                          - include the simulator timestamp (sim_gtime)\r\n                            as part of the prefix for each line of output\r\n                          - write complete lines at a time (avoid asynch I/O issues).\r\n   05-Jan-11    MP      Added Asynch I/O support\r\n   22-Jan-11    MP      Added SET ON, SET NOON, ON, GOTO and RETURN command support\r\n   13-Jan-11    MP      Added \"SHOW SHOW\" and \"SHOW <dev> SHOW\" commands\r\n   05-Jan-11    RMS     Fixed bug in deposit stride for numeric input (John Dundas)\r\n   23-Dec-10    RMS     Clarified some help messages (Mark Pizzolato)\r\n   08-Nov-10    RMS     Fixed handling of DO with no arguments (Dave Bryan)\r\n   22-May-10    RMS     Added *nix READLINE support (Mark Pizzolato)\r\n   08-Feb-09    RMS     Fixed warnings in help printouts\r\n   29-Dec-08    RMS     Fixed implementation of MTAB_NC\r\n   24-Nov-08    RMS     Revised RESTORE unit logic for consistency\r\n   05-Sep-08    JDB     \"detach_all\" ignores error status returns if shutting down\r\n   17-Aug-08    RMS     Revert RUN/BOOT to standard, rather than powerup, reset\r\n   25-Jul-08    JDB     DO cmd missing params now default to null string\r\n   29-Jun-08    JDB     DO cmd sub_args now allows \"\\\\\" to specify literal backslash\r\n   04-Jun-08    JDB     label the patch delta more clearly\r\n   31-Mar-08    RMS     Fixed bug in local/global register search (Mark Pizzolato)\r\n                        Fixed bug in restore of RO units (Mark Pizzolato)\r\n   06-Feb-08    RMS     Added SET/SHO/NO BR with default argument\r\n   18-Jul-07    RMS     Modified match_ext for VMS ext;version support\r\n   28-Apr-07    RMS     Modified sim_instr invocation to call sim_rtcn_init_all\r\n                        Fixed bug in get_sim_opt\r\n                        Fixed bug in restoration with changed memory size\r\n   08-Mar-07    JDB     Fixed breakpoint actions in DO command file processing\r\n   30-Jan-07    RMS     Fixed bugs in get_ipaddr\r\n   17-Oct-06    RMS     Added idle support\r\n   04-Oct-06    JDB     DO cmd failure now echoes cmd unless -q\r\n   30-Aug-06    JDB     detach_unit returns SCPE_UNATT if not attached\r\n   14-Jul-06    RMS     Added sim_activate_abs\r\n   02-Jun-06    JDB     Fixed do_cmd to exit nested files on assertion failure\r\n                        Added -E switch to do_cmd to exit on any error\r\n   14-Feb-06    RMS     Upgraded save file format to V3.5\r\n   18-Jan-06    RMS     Added fprint_stopped_gen\r\n                        Added breakpoint spaces\r\n                        Fixed unaligned register access (Doug Carman)\r\n   22-Sep-05    RMS     Fixed declarations (Sterling Garwood)\r\n   30-Aug-05    RMS     Revised to trim trailing spaces on file names\r\n   25-Aug-05    RMS     Added variable default device support\r\n   23-Aug-05    RMS     Added Linux line history support\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   01-May-05    RMS     Revised syntax for SET DEBUG (Dave Bryan)\r\n   22-Mar-05    JDB     Modified DO command to allow ten-level nesting\r\n   18-Mar-05    RMS     Moved DETACH tests into detach_unit (Dave Bryan)\r\n                        Revised interface to fprint_sym, fparse_sym\r\n   13-Mar-05    JDB     ASSERT now requires a conditional operator\r\n   07-Feb-05    RMS     Added ASSERT command (Dave Bryan)\r\n   02-Feb-05    RMS     Fixed bug in global register search\r\n   26-Dec-04    RMS     Qualified SAVE examine, RESTORE deposit with SIM_SW_REST\r\n   10-Nov-04    JDB     Fixed logging of errors from cmds in \"do\" file\r\n   05-Nov-04    RMS     Moved SET/SHOW DEBUG under CONSOLE hierarchy\r\n                        Renamed unit OFFLINE/ONLINE to DISABLED/ENABLED (Dave Bryan)\r\n                        Revised to flush output files after simulation stop (Dave Bryan)\r\n   15-Oct-04    RMS     Fixed HELP to suppress duplicate descriptions\r\n   27-Sep-04    RMS     Fixed comma-separation options in set (David Bryan)\r\n   09-Sep-04    RMS     Added -p option for RESET\r\n   13-Aug-04    RMS     Qualified RESTORE detach with SIM_SW_REST\r\n   17-Jul-04    JDB     DO cmd file open failure retries with \".sim\" appended\r\n   17-Jul-04    RMS     Added ECHO command (Dave Bryan)\r\n   12-Jul-04    RMS     Fixed problem ATTACHing to read only files\r\n                        (John Dundas)\r\n   28-May-04    RMS     Added SET/SHOW CONSOLE\r\n   14-Feb-04    RMS     Updated SAVE/RESTORE (V3.2)\r\n                RMS     Added debug print routines (Dave Hittner)\r\n                RMS     Added sim_vm_parse_addr and sim_vm_fprint_addr\r\n                RMS     Added REG_VMAD support\r\n                RMS     Split out libraries\r\n                RMS     Moved logging function to SCP\r\n                RMS     Exposed step counter interface(s)\r\n                RMS     Fixed double logging of SHOW BREAK (Mark Pizzolato)\r\n                RMS     Fixed implementation of REG_VMIO\r\n                RMS     Added SET/SHOW DEBUG, SET/SHOW <device> DEBUG,\r\n                        SHOW <device> MODIFIERS, SHOW <device> RADIX\r\n                RMS     Changed sim_fsize to take uptr argument\r\n   29-Dec-03    RMS     Added Telnet console output stall support\r\n   01-Nov-03    RMS     Cleaned up implicit detach on attach/restore\r\n                        Fixed bug in command line read while logging (Mark Pizzolato)\r\n   01-Sep-03    RMS     Fixed end-of-file problem in dep, idep\r\n                        Fixed error on trailing spaces in dep, idep\r\n   15-Jul-03    RMS     Removed unnecessary test in reset_all\r\n   15-Jun-03    RMS     Added register flag REG_VMIO\r\n   25-Apr-03    RMS     Added extended address support (V3.0)\r\n                        Fixed bug in SAVE (Peter Schorn)\r\n                        Added u5, u6 fields\r\n                        Added logical name support\r\n   03-Mar-03    RMS     Added sim_fsize\r\n   27-Feb-03    RMS     Fixed bug in multiword deposits to files\r\n   08-Feb-03    RMS     Changed sim_os_sleep to void, match_ext to char*\r\n                        Added multiple actions, .ini file support\r\n                        Added multiple switch evaluations per line\r\n   07-Feb-03    RMS     Added VMS support for ! (Mark Pizzolato)\r\n   01-Feb-03    RMS     Added breakpoint table extension, actions\r\n   14-Jan-03    RMS     Added missing function prototypes\r\n   10-Jan-03    RMS     Added attach/restore flag, dynamic memory size support,\r\n                        case sensitive SET options\r\n   22-Dec-02    RMS     Added ! (OS command) feature (Mark Pizzolato)\r\n   17-Dec-02    RMS     Added get_ipaddr\r\n   02-Dec-02    RMS     Added EValuate command\r\n   16-Nov-02    RMS     Fixed bug in register name match algorithm\r\n   13-Oct-02    RMS     Fixed Borland compiler warnings (Hans Pufal)\r\n   05-Oct-02    RMS     Fixed bugs in set_logon, ssh_break (David Hittner)\r\n                        Added support for fixed buffer devices\r\n                        Added support for Telnet console, removed VT support\r\n                        Added help <command>\r\n                        Added VMS file optimizations (Robert Alan Byer)\r\n                        Added quiet mode, DO with parameters, GUI interface,\r\n                           extensible commands (Brian Knittel)\r\n                        Added device enable/disable commands\r\n   14-Jul-02    RMS     Fixed exit bug in do, added -v switch (Brian Knittel)\r\n   17-May-02    RMS     Fixed bug in fxread/fxwrite error usage (found by\r\n                        Norm Lastovic)\r\n   02-May-02    RMS     Added VT emulation interface, changed {NO}LOG to SET {NO}LOG\r\n   22-Apr-02    RMS     Fixed laptop sleep problem in clock calibration, added\r\n                        magtape record length error (Jonathan Engdahl)\r\n   26-Feb-02    RMS     Fixed initialization bugs in do_cmd, get_aval\r\n                        (Brian Knittel)\r\n   10-Feb-02    RMS     Fixed problem in clock calibration\r\n   06-Jan-02    RMS     Moved device enable/disable to simulators\r\n   30-Dec-01    RMS     Generalized timer packaged, added circular arrays\r\n   19-Dec-01    RMS     Fixed DO command bug (John Dundas)\r\n   07-Dec-01    RMS     Implemented breakpoint package\r\n   05-Dec-01    RMS     Fixed bug in universal register logic\r\n   03-Dec-01    RMS     Added read-only units, extended SET/SHOW, universal registers\r\n   24-Nov-01    RMS     Added unit-based registers\r\n   16-Nov-01    RMS     Added DO command\r\n   28-Oct-01    RMS     Added relative range addressing\r\n   08-Oct-01    RMS     Added SHOW VERSION\r\n   30-Sep-01    RMS     Relaxed attach test in BOOT\r\n   27-Sep-01    RMS     Added queue count routine, fixed typo in ex/mod\r\n   17-Sep-01    RMS     Removed multiple console support\r\n   07-Sep-01    RMS     Removed conditional externs on function prototypes\r\n                        Added special modifier print\r\n   31-Aug-01    RMS     Changed int64 to t_int64 for Windoze (V2.7)\r\n   18-Jul-01    RMS     Minor changes for Macintosh port\r\n   12-Jun-01    RMS     Fixed bug in big-endian I/O (Dave Conroy)\r\n   27-May-01    RMS     Added multiple console support\r\n   16-May-01    RMS     Added logging\r\n   15-May-01    RMS     Added features from Tim Litt\r\n   12-May-01    RMS     Fixed missing return in disable_cmd\r\n   25-Mar-01    RMS     Added ENABLE/DISABLE\r\n   14-Mar-01    RMS     Revised LOAD/DUMP interface (again)\r\n   05-Mar-01    RMS     Added clock calibration support\r\n   05-Feb-01    RMS     Fixed bug, DETACH buffered unit with hwmark = 0\r\n   04-Feb-01    RMS     Fixed bug, RESTORE not using device's attach routine\r\n   21-Jan-01    RMS     Added relative time\r\n   22-Dec-00    RMS     Fixed find_device for devices ending in numbers\r\n   08-Dec-00    RMS     V2.5a changes\r\n   30-Oct-00    RMS     Added output file option to examine\r\n   11-Jul-99    RMS     V2.5 changes\r\n   13-Apr-99    RMS     Fixed handling of 32b addresses\r\n   04-Oct-98    RMS     V2.4 changes\r\n   20-Aug-98    RMS     Added radix commands\r\n   05-Jun-98    RMS     Fixed bug in ^D handling for UNIX\r\n   10-Apr-98    RMS     Added switches to all commands\r\n   26-Oct-97    RMS     Added search capability\r\n   25-Jan-97    RMS     Revised data types\r\n   23-Jan-97    RMS     Added bi-endian I/O\r\n   06-Sep-96    RMS     Fixed bug in variable length IEXAMINE\r\n   16-Jun-96    RMS     Changed interface to parse/print_sym\r\n   06-Apr-96    RMS     Added error checking in reset all\r\n   07-Jan-96    RMS     Added register buffers in save/restore\r\n   11-Dec-95    RMS     Fixed ordering bug in save/restore\r\n   22-May-95    RMS     Added symbolic input\r\n   13-Apr-95    RMS     Added symbolic printouts\r\n*/\r\n\r\n/* Macros and data structures */\r\n\r\n#define NOT_MUX_USING_CODE  /* sim_tmxr library provider or agnostic */\r\n\r\n#define IN_SCP_C 1          /* Include from scp.c */\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_scp_private.h\"\r\n#include \"sim_rev.h\"\r\n#include \"sim_disk.h\"\r\n#include \"sim_tape.h\"\r\n#include \"sim_ether.h\"\r\n#include \"sim_card.h\"\r\n#include \"sim_serial.h\"\r\n#include \"sim_video.h\"\r\n#include \"sim_sock.h\"\r\n#include \"sim_frontpanel.h\"\r\n#include <signal.h>\r\n#if defined(_WIN32)\r\n#include <io.h>\r\n#include <fcntl.h>\r\n#endif\r\n\r\n#ifndef MAX\r\n#define MAX(a,b)  (((a) >= (b)) ? (a) : (b))\r\n#endif\r\n#ifndef MIN\r\n#define MIN(a,b)  (((a) <= (b)) ? (a) : (b))\r\n#endif\r\n/* Max width of a value expressed as a formatted string */\r\n#define MAX_WIDTH ((int) ((CHAR_BIT * sizeof (t_value) * 4 + 3)/3))\r\n\r\n\r\n/* search logical and boolean ops */\r\n\r\n#define SCH_OR          0                               /* search logicals */\r\n#define SCH_AND         1\r\n#define SCH_XOR         2\r\n#define SCH_E           0                               /* search booleans */\r\n#define SCH_N           1\r\n#define SCH_G           2\r\n#define SCH_L           3\r\n#define SCH_EE          4\r\n#define SCH_NE          5\r\n#define SCH_GE          6\r\n#define SCH_LE          7\r\n\r\n#define MAX_DO_NEST_LVL 20                              /* DO cmd nesting level limit */\r\n#define SRBSIZ          1024                            /* save/restore buffer */\r\n#define SIM_BRK_INILNT  4096                            /* bpt tbl length */\r\n#define SIM_BRK_ALLTYP  0xFFFFFFFB\r\n#define UPDATE_SIM_TIME                                         \\\r\n    if (1) {                                                    \\\r\n        int32 _x;                                               \\\r\n        AIO_LOCK;                                               \\\r\n        if (sim_clock_queue == QUEUE_LIST_END)                  \\\r\n            _x = noqueue_time;                                  \\\r\n        else                                                    \\\r\n            _x = sim_clock_queue->time;                         \\\r\n        sim_time = sim_time + (_x - sim_interval);              \\\r\n        sim_rtime = sim_rtime + ((uint32) (_x - sim_interval)); \\\r\n        if (sim_clock_queue == QUEUE_LIST_END)                  \\\r\n            noqueue_time = sim_interval;                        \\\r\n        else                                                    \\\r\n            sim_clock_queue->time = sim_interval;               \\\r\n        AIO_UNLOCK;                                             \\\r\n        }                                                       \\\r\n    else                                                        \\\r\n        (void)0\r\n\r\n/* Size of a DEVICE's data element */\r\n#define SZ_D(dp) (size_map[((dp)->dwidth + CHAR_BIT - 1) / CHAR_BIT])\r\n/* Size of a REGister's data element */\r\n#define SZ_R(rp) \\\r\n    (size_map[((rp)->width + (rp)->offset + CHAR_BIT - 1) / CHAR_BIT])\r\n#if defined (USE_INT64)\r\n#define SZ_LOAD(sz,v,mb,j) \\\r\n    if (sz == sizeof (uint8)) v = *(((uint8 *) mb) + ((uint32) j)); \\\r\n    else if (sz == sizeof (uint16)) v = *(((uint16 *) mb) + ((uint32) j)); \\\r\n    else if (sz == sizeof (uint32)) v = *(((uint32 *) mb) + ((uint32) j)); \\\r\n    else v = *(((t_uint64 *) mb) + ((uint32) j));\r\n#define SZ_STORE(sz,v,mb,j) \\\r\n    if (sz == sizeof (uint8)) *(((uint8 *) mb) + j) = (uint8) v; \\\r\n    else if (sz == sizeof (uint16)) *(((uint16 *) mb) + ((uint32) j)) = (uint16) v; \\\r\n    else if (sz == sizeof (uint32)) *(((uint32 *) mb) + ((uint32) j)) = (uint32) v; \\\r\n    else *(((t_uint64 *) mb) + ((uint32) j)) = v;\r\n#else\r\n#define SZ_LOAD(sz,v,mb,j) \\\r\n    if (sz == sizeof (uint8)) v = *(((uint8 *) mb) + ((uint32) j)); \\\r\n    else if (sz == sizeof (uint16)) v = *(((uint16 *) mb) + ((uint32) j)); \\\r\n    else v = *(((uint32 *) mb) + ((uint32) j));\r\n#define SZ_STORE(sz,v,mb,j) \\\r\n    if (sz == sizeof (uint8)) *(((uint8 *) mb) + ((uint32) j)) = (uint8) v; \\\r\n    else if (sz == sizeof (uint16)) *(((uint16 *) mb) + ((uint32) j)) = (uint16) v; \\\r\n    else *(((uint32 *) mb) + ((uint32) j)) = v;\r\n#endif\r\n\r\n#define SIM_DBG_EVENT_NEG   0x80000000      /* negative event dispatch activities */\r\n#define SIM_DBG_EVENT       0x40000000      /* event dispatch activities */\r\n#define SIM_DBG_ACTIVATE    0x20000000      /* queue insertion activities */\r\n#define SIM_DBG_AIO_QUEUE   0x10000000      /* asynch event queue activities */\r\n#define SIM_DBG_EXP_STACK   0x08000000      /* expression stack activities */\r\n#define SIM_DBG_EXP_EVAL    0x04000000      /* expression evaluation activities */\r\n#define SIM_DBG_BRK_ACTION  0x02000000      /* action activities */\r\n#define SIM_DBG_DO          0x01000000      /* do activities */\r\n#define SIM_DBG_SAVE        0x00800000      /* save activities */\r\n#define SIM_DBG_RESTORE     0x00400000      /* restore activities */\r\n\r\nstatic DEBTAB scp_debug[] = {\r\n  {\"EVENT\",     SIM_DBG_EVENT,      \"Event Dispatch Activities\"},\r\n  {\"NEGATIVE\",  SIM_DBG_EVENT_NEG,  \"Negative Event Dispatch Activities\"},\r\n  {\"ACTIVATE\",  SIM_DBG_ACTIVATE,   \"Event Queue Insertion Activities\"},\r\n  {\"QUEUE\",     SIM_DBG_AIO_QUEUE,  \"Asynch Event Queue Activities\"},\r\n  {\"EXPSTACK\",  SIM_DBG_EXP_STACK,  \"Expression Stack Activities\"},\r\n  {\"EXPEVAL\",   SIM_DBG_EXP_EVAL,   \"Expression Evaluation Activities\"},\r\n  {\"ACTION\",    SIM_DBG_BRK_ACTION, \"If/Breakpoint/Expect Action Activities\"},\r\n  {\"DO\",        SIM_DBG_DO,         \"Do Command/Expansion Activities\"},\r\n  {\"SAVE\",      SIM_DBG_SAVE,       \"Save Activities\"},\r\n  {\"RESTORE\",   SIM_DBG_RESTORE,    \"Restore Activities\"},\r\n  {\"INIT\",      SIM_DBG_INIT,       \"Initialization Activities\"},\r\n  {0}\r\n};\r\n\r\nstatic const char *sim_scp_description (DEVICE *dptr)\r\n{\r\nreturn \"SCP Event and Internal Command Processing and Testing\";\r\n}\r\n\r\nstatic UNIT scp_test_units[4];\r\n\r\nDEVICE sim_scp_dev = {\r\n    \"SCP-PROCESS\", scp_test_units, NULL, NULL,\r\n    4, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE|DEV_DEBUG, 0,\r\n    scp_debug, NULL, NULL, NULL, NULL, NULL,\r\n    sim_scp_description};\r\n\r\nstatic volatile t_uint64 sim_asynch_event_count = 0;\r\nstatic t_uint64 sim_processed_event_count = 0;\r\n/* Asynch I/O support */\r\n#if defined (SIM_ASYNCH_IO)\r\npthread_mutex_t sim_asynch_lock = PTHREAD_MUTEX_INITIALIZER;\r\npthread_cond_t sim_asynch_wake = PTHREAD_COND_INITIALIZER;\r\n\r\npthread_mutex_t sim_timer_lock     = PTHREAD_MUTEX_INITIALIZER;\r\npthread_cond_t sim_timer_wake      = PTHREAD_COND_INITIALIZER;\r\npthread_t sim_asynch_main_threadid;\r\nUNIT * volatile sim_asynch_queue;\r\nt_bool sim_asynch_enabled = TRUE;\r\n//volatile int32 sim_asynch_check;\r\nint32 sim_asynch_check;\r\nint32 sim_asynch_latency = 4000;      /* 4 usec interrupt latency */\r\nint32 sim_asynch_inst_latency = 20;   /* assume 5 mip simulator */\r\n\r\nint sim_aio_update_queue (void)\r\n{\r\nint migrated = 0;\r\n\r\nAIO_ILOCK;\r\nif (AIO_QUEUE_VAL != QUEUE_LIST_END) {  /* List !Empty */\r\n    UNIT *q, *uptr;\r\n    int32 a_event_time;\r\n    do {                                /* Grab current queue */\r\n        q = AIO_QUEUE_VAL;\r\n        } while (q != AIO_QUEUE_SET(QUEUE_LIST_END, q));\r\n    while (q != QUEUE_LIST_END) {       /* List !Empty */\r\n        sim_debug (SIM_DBG_AIO_QUEUE, &sim_scp_dev, \"Migrating Asynch event for %s after %d %s\\n\", sim_uname(q), q->a_event_time, sim_vm_interval_units);\r\n        ++migrated;\r\n        uptr = q;\r\n        q = q->a_next;\r\n        uptr->a_next = NULL;        /* hygiene */\r\n        if (uptr->a_activate_call != &sim_activate_notbefore) {\r\n            a_event_time = uptr->a_event_time-((sim_asynch_inst_latency+1)/2);\r\n            if (a_event_time < 0)\r\n                a_event_time = 0;\r\n            }\r\n        else\r\n            a_event_time = uptr->a_event_time;\r\n        AIO_IUNLOCK;\r\n        uptr->a_activate_call (uptr, a_event_time);\r\n        if (uptr->a_check_completion) {\r\n            sim_debug (SIM_DBG_AIO_QUEUE, &sim_scp_dev, \"Calling Completion Check for asynch event on %s\\n\", sim_uname(uptr));\r\n            uptr->a_check_completion (uptr);\r\n            }\r\n        AIO_ILOCK;\r\n        }\r\n    }\r\nAIO_IUNLOCK;\r\nreturn migrated;\r\n}\r\n\r\nvoid sim_aio_activate (ACTIVATE_API caller, UNIT *uptr, int32 event_time)\r\n{\r\nAIO_ILOCK;\r\nif (sim_asynch_enabled == FALSE) {\r\n    char buf[128];\r\n    snprintf (buf, sizeof (buf), \"sim_aio_activate() called with ASYNCH Disabled for %s\\n\", sim_uname(uptr));\r\n    SIM_SCP_ABORT (buf);\r\n    }\r\n++sim_asynch_event_count;\r\nsim_debug (SIM_DBG_AIO_QUEUE, &sim_scp_dev, \"Lock Free Queueing Asynch event for %s after %d %s\\n\", sim_uname(uptr), event_time, sim_vm_interval_units);\r\nif (uptr->a_next) {\r\n    uptr->a_activate_call = sim_activate_abs;\r\n    uptr->a_event_time = MIN (uptr->a_event_time, event_time);\r\n    }\r\nelse {\r\n    UNIT *q;\r\n    uptr->a_event_time = event_time;\r\n    uptr->a_activate_call = caller;\r\n    do {\r\n        q = AIO_QUEUE_VAL;\r\n        uptr->a_next = q;                               /* Mark as on list */\r\n        } while (q != AIO_QUEUE_SET(uptr, q));\r\n    }\r\nAIO_IUNLOCK;\r\nsim_asynch_check = 0;                             /* try to force check */\r\nif (sim_idle_wait) {\r\n    sim_debug (TIMER_DBG_IDLE, &sim_timer_dev, \"wakeup from idle due to async event on %s after %d %s\\n\", sim_uname(uptr), event_time, sim_vm_interval_units);\r\n    pthread_cond_signal (&sim_asynch_wake);\r\n    }\r\n}\r\n\r\nvoid sim_aio_check_event (void)\r\n{\r\nif (0 > --sim_asynch_check) {\r\n    AIO_UPDATE_QUEUE;\r\n    sim_asynch_check = sim_asynch_inst_latency;\r\n    }\r\n}\r\n\r\nvoid sim_aio_set_interrupt_latency (int32 instpersec)\r\n{\r\nsim_asynch_inst_latency = (int32)((((double)(instpersec))*sim_asynch_latency)/1000000000);\r\nif (sim_asynch_inst_latency == 0)\r\n    sim_asynch_inst_latency = 1;\r\n}\r\n#else /* !defined (SIM_ASYNCH_IO) */\r\nt_bool sim_asynch_enabled = FALSE;\r\n#endif\r\n\r\n/* The per-simulator init routine is a weak global that defaults to NULL\r\n   The other per-simulator pointers can be overridden by the init routine\r\n\r\nWEAK void (*sim_vm_init) (void);\r\n\r\n   This routine is no longer invoked this way since it doesn't work reliably\r\n   on all simh supported compile environments.  A simulator that needs these\r\n   initializations can perform them in the CPU device reset routine which will\r\n   always be called before anything else can be processed.\r\n\r\n */\r\nchar* (*sim_vm_read) (char *ptr, int32 size, FILE *stream) = NULL;\r\nvoid (*sim_vm_post) (t_bool from_scp) = NULL;\r\nCTAB *sim_vm_cmd = NULL;\r\nvoid (*sim_vm_sprint_addr) (char *buf, DEVICE *dptr, t_addr addr) = NULL;\r\nvoid (*sim_vm_fprint_addr) (FILE *st, DEVICE *dptr, t_addr addr) = NULL;\r\nt_addr (*sim_vm_parse_addr) (DEVICE *dptr, CONST char *cptr, CONST char **tptr) = NULL;\r\nt_value (*sim_vm_pc_value) (void) = NULL;\r\nt_bool (*sim_vm_is_subroutine_call) (t_addr **ret_addrs) = NULL;\r\nvoid (*sim_vm_reg_update) (REG *rptr, uint32 idx, t_value prev_val, t_value new_val) = NULL;\r\nt_bool (*sim_vm_fprint_stopped) (FILE *st, t_stat reason) = NULL;\r\nconst char *sim_vm_release = NULL;\r\nconst char *sim_vm_release_message = NULL;\r\nconst char **sim_clock_precalibrate_commands = NULL;\r\n\r\n\r\n/* Prototypes */\r\n\r\n/* Set and show command processors */\r\n\r\nt_stat set_dev_radix (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat set_dev_enbdis (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat set_dev_debug (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat set_unit_enbdis (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat set_unit_append (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat ssh_break (FILE *st, const char *cptr, int32 flg);\r\nt_stat show_cmd_fi (FILE *ofile, int32 flag, CONST char *cptr);\r\nt_stat show_config (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_queue (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_time (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_mod_names (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_show_commands (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_log_names (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_dev_radix (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_dev_debug (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_dev_logicals (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_dev_modifiers (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_dev_show_commands (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_version (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_default (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_break (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_on (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_do (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_runlimit (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_send (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_expect (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_device (FILE *st, DEVICE *dptr, int32 flag);\r\nt_stat show_unit (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag);\r\nt_stat show_all_mods (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flg, int32 *toks);\r\nt_stat show_one_mod (FILE *st, DEVICE *dptr, UNIT *uptr, MTAB *mptr, CONST char *cptr, int32 flag);\r\nt_stat sim_save (FILE *sfile);\r\nt_stat sim_rest (FILE *rfile);\r\n\r\n/* Breakpoint package */\r\n\r\nt_stat sim_brk_init (void);\r\nt_stat sim_brk_set (t_addr loc, int32 sw, int32 ncnt, CONST char *act);\r\nt_stat sim_brk_clr (t_addr loc, int32 sw);\r\nt_stat sim_brk_clrall (int32 sw);\r\nt_stat sim_brk_show (FILE *st, t_addr loc, int32 sw);\r\nt_stat sim_brk_showall (FILE *st, int32 sw);\r\nCONST char *sim_brk_getact (char *buf, int32 size);\r\nBRKTAB *sim_brk_new (t_addr loc, uint32 btyp);\r\nchar *sim_brk_clract (void);\r\n\r\nFILE *stdnul;\r\n\r\n/* Command support routines */\r\n\r\nSCHTAB *get_rsearch (CONST char *cptr, int32 radix, SCHTAB *schptr);\r\nSCHTAB *get_asearch (CONST char *cptr, int32 radix, SCHTAB *schptr);\r\nint32 test_search (t_value *val, SCHTAB *schptr);\r\nstatic const char *get_glyph_gen (const char *iptr, char *optr, char mchar, t_bool ws_match, t_bool uc, t_bool quote, char escape_char);\r\ntypedef enum {\r\n    SW_ERROR,           /* Parse Error */\r\n    SW_BITMASK,         /* Bitmask Value or Not a switch */\r\n    SW_NUMBER           /* Numeric Value */\r\n    } SWITCH_PARSE;\r\nSWITCH_PARSE get_switches (const char *cptr, int32 *sw_val, int32 *sw_number);\r\nvoid put_rval_pcchk (REG *rptr, uint32 idx, t_value val, t_bool pc_chk);\r\nvoid put_rval (REG *rptr, uint32 idx, t_value val);\r\nvoid fprint_help (FILE *st);\r\nvoid fprint_stopped (FILE *st, t_stat r);\r\nvoid fprint_capac (FILE *st, DEVICE *dptr, UNIT *uptr);\r\nvoid fprint_sep (FILE *st, int32 *tokens, int32 flag);\r\nREG *find_reg_glob (CONST char *ptr, CONST char **optr, DEVICE **gdptr);\r\nREG *find_reg_glob_reason (CONST char *cptr, CONST char **optr, DEVICE **gdptr, t_stat *stat);\r\nconst char *sim_eval_expression (const char *cptr, t_svalue *value, t_bool parens_required, t_stat *stat);\r\n\r\n/* Forward references */\r\n\r\nt_stat scp_attach_unit (DEVICE *dptr, UNIT *uptr, const char *cptr);\r\nt_stat scp_detach_unit (DEVICE *dptr, UNIT *uptr);\r\nt_bool qdisable (DEVICE *dptr);\r\nt_stat attach_err (UNIT *uptr, t_stat stat);\r\nt_stat detach_all (int32 start_device, t_bool shutdown);\r\nt_stat assign_device (DEVICE *dptr, const char *cptr);\r\nt_stat assign_unit (UNIT *uptr, const char *cptr);\r\nt_stat deassign_device (DEVICE *dptr);\r\nt_stat deassign_unit (UNIT *uptr);\r\nt_stat ssh_break_one (FILE *st, int32 flg, t_addr lo, int32 cnt, CONST char *aptr);\r\nt_stat exdep_reg_loop (FILE *ofile, SCHTAB *schptr, int32 flag, CONST char *cptr,\r\n    REG *lowr, REG *highr, uint32 lows, uint32 highs);\r\nt_stat ex_reg (FILE *ofile, t_value val, int32 flag, REG *rptr, uint32 idx);\r\nt_stat dep_reg (int32 flag, CONST char *cptr, REG *rptr, uint32 idx);\r\nt_stat exdep_addr_loop (FILE *ofile, SCHTAB *schptr, int32 flag, const char *cptr,\r\n    t_addr low, t_addr high, DEVICE *dptr, UNIT *uptr);\r\nt_stat ex_addr (FILE *ofile, int32 flag, t_addr addr, DEVICE *dptr, UNIT *uptr, int32 dfltinc);\r\nt_stat dep_addr (int32 flag, const char *cptr, t_addr addr, DEVICE *dptr,\r\n    UNIT *uptr, int32 dfltinc);\r\nvoid fprint_fields (FILE *stream, t_value before, t_value after, BITFIELD* bitdefs);\r\nt_stat step_svc (UNIT *ptr);\r\nt_stat runlimit_svc (UNIT *ptr);\r\nt_stat expect_svc (UNIT *ptr);\r\nt_stat flush_svc (UNIT *ptr);\r\nt_stat shift_args (char *do_arg[], size_t arg_count);\r\nt_stat set_on (int32 flag, CONST char *cptr);\r\nt_stat set_verify (int32 flag, CONST char *cptr);\r\nt_stat set_message (int32 flag, CONST char *cptr);\r\nt_stat set_quiet (int32 flag, CONST char *cptr);\r\nt_stat set_asynch (int32 flag, CONST char *cptr);\r\nt_stat sim_show_asynch (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat do_cmd_label (int32 flag, CONST char *cptr, CONST char *label);\r\nvoid int_handler (int signal);\r\nt_stat set_prompt (int32 flag, CONST char *cptr);\r\nt_stat set_runlimit (int32 flag, CONST char *cptr);\r\nt_stat sim_set_asynch (int32 flag, CONST char *cptr);\r\nstatic const char *_get_dbg_verb (uint32 dbits, DEVICE* dptr, UNIT *uptr);\r\nstatic t_stat sim_sanity_check_register_declarations (DEVICE **devices);\r\nstatic t_stat sim_device_unit_tests (const char *cptr);\r\nstatic void fix_writelock_mtab (DEVICE *dptr);\r\nstatic t_stat _sim_debug_flush (void);\r\nstatic const char *_get_runlimit (void);\r\n\r\n/* Global data */\r\n\r\nconst char *sim_prog_name = NULL;                       /* pointer to the executable name */\r\nDEVICE *sim_dflt_dev = NULL;\r\nUNIT *sim_clock_queue = QUEUE_LIST_END;\r\nint32 sim_interval = 0;\r\nconst char *sim_vm_interval_units = \"instructions\";     /* Simulator can change to \"cycles\" as needed */\r\nconst char *sim_vm_step_unit = \"instruction\";           /* Simulator can change */\r\nint32 sim_switches = 0;\r\nint32 sim_switch_number = 0;\r\nFILE *sim_ofile = NULL;\r\nTMLN *sim_oline = NULL;\r\nMEMFILE *sim_mfile = NULL;\r\nSCHTAB *sim_schrptr = FALSE;\r\nSCHTAB *sim_schaptr = FALSE;\r\nDEVICE *sim_dfdev = NULL;\r\nUNIT *sim_dfunit = NULL;\r\nDEVICE **sim_internal_devices = NULL;\r\nuint32 sim_internal_device_count = 0;\r\nint32 sim_opt_out = 0;\r\nvolatile t_bool sim_is_running = FALSE;\r\nt_bool sim_processing_event = FALSE;\r\nuint32 sim_brk_summ = 0;\r\nuint32 sim_brk_types = 0;\r\nBRKTYPTAB *sim_brk_type_desc = NULL;                /* type descriptions */\r\nuint32 sim_brk_dflt = 0;\r\nuint32 sim_brk_match_type;\r\nt_addr sim_brk_match_addr;\r\nchar *sim_brk_act[MAX_DO_NEST_LVL];\r\nchar *sim_brk_act_buf[MAX_DO_NEST_LVL];\r\nBRKTAB **sim_brk_tab = NULL;\r\nint32 sim_brk_ent = 0;\r\nint32 sim_brk_lnt = 0;\r\nint32 sim_brk_ins = 0;\r\nint32 sim_quiet = 0;\r\nint32 sim_show_message = 1;                         /* the message display status of the currently open do file */\r\nint32 sim_step = 0;\r\nint32 sim_runlimit = 0;\r\nint32 sim_runlimit_initial = 0;\r\ndouble sim_runlimit_d = 0.0;\r\ndouble sim_runlimit_d_initial = 0.0;\r\nint32 sim_runlimit_switches = 0;\r\nt_bool sim_runlimit_enabled = FALSE;\r\nchar *sim_sub_instr = NULL;         /* Copy of pre-substitution buffer contents */\r\nchar *sim_sub_instr_buf = NULL;     /* Buffer address that substitutions were saved in */\r\nsize_t sim_sub_instr_size = 0;      /* substitution buffer size */\r\nsize_t *sim_sub_instr_off = NULL;   /* offsets in substitution buffer where original data started */\r\nstatic double sim_time;\r\nstatic uint32 sim_rtime;\r\nstatic int32 noqueue_time;\r\nvolatile t_bool stop_cpu = FALSE;\r\nvolatile t_bool sigterm_received = FALSE;\r\nstatic unsigned int sim_stop_sleep_ms = 250;\r\nstatic char **sim_argv;\r\nstatic int sim_exit_status = EXIT_SUCCESS;              /* optionally set by EXIT command */\r\nt_value *sim_eval = NULL;\r\nstatic char sim_last_val[CBUFSIZE];\r\nstatic t_addr sim_last_addr;\r\nFILE *sim_log = NULL;                                   /* log file */\r\nFILEREF *sim_log_ref = NULL;                            /* log file file reference */\r\nFILE *sim_deb = NULL;                                   /* debug file */\r\nFILEREF *sim_deb_ref = NULL;                            /* debug file file reference */\r\nint32 sim_deb_switches = 0;                             /* debug switches */\r\nsize_t sim_deb_buffer_size = 0;                         /* debug memory buffer size */\r\nchar *sim_deb_buffer = NULL;                            /* debug memory buffer */\r\nsize_t sim_debug_buffer_offset = 0;                     /* debug memory buffer insertion offset */\r\nsize_t sim_debug_buffer_inuse = 0;                      /* debug memory buffer inuse count */\r\nchar *sim_prompt = NULL;                                /* prompt string */\r\nstatic FILE *sim_gotofile;                              /* the currently open do file */\r\nstatic int32 sim_goto_line[MAX_DO_NEST_LVL+1];          /* the current line number in the currently open do file */\r\nstatic int32 sim_do_echo = 0;                           /* the echo status of the currently open do file */\r\nstatic int32 sim_on_inherit = 0;                        /* the inherit status of on state and conditions when executing do files */\r\nstatic int32 sim_do_depth = 0;\r\nstatic t_bool sim_cmd_echoed = FALSE;                   /* Command was emitted already prior to message output */\r\nstatic char **sim_exp_argv = NULL;\r\nstatic int32 sim_on_check[MAX_DO_NEST_LVL+1];\r\nstatic char *sim_on_actions[MAX_DO_NEST_LVL+1][SCPE_MAX_ERR+2];\r\n#define ON_SIGINT_ACTION (SCPE_MAX_ERR+1)\r\nstatic char sim_do_filename[MAX_DO_NEST_LVL+1][CBUFSIZE];\r\nstatic const char *sim_do_ocptr[MAX_DO_NEST_LVL+1];\r\nstatic const char *sim_do_label[MAX_DO_NEST_LVL+1];\r\nstatic t_bool sim_if_cmd[MAX_DO_NEST_LVL+1];\r\nstatic t_bool sim_if_cmd_last[MAX_DO_NEST_LVL+1];\r\nstatic t_bool sim_if_result[MAX_DO_NEST_LVL+1];\r\nstatic t_bool sim_if_result_last[MAX_DO_NEST_LVL+1];\r\nstatic t_bool sim_cptr_is_action[MAX_DO_NEST_LVL+1];\r\nstatic DEVICE *sim_failed_reset_dptr = NULL;\r\nstatic struct deleted_env_var {\r\n    char *name;\r\n    char *value;\r\n    } *sim_external_env = NULL;\r\nstatic int sim_external_env_count = 0;\r\nstatic char *sim_tmpnam;\r\nstatic FILE *sim_tmpfile = NULL;\r\nstatic int sim_editline_version = 0;\r\nstatic t_bool sim_pcre_regex_available = FALSE;\r\n/* Dynamically loaded pcre support */\r\n#if !defined(HAVE_PCRE_H)\r\npcre *(*pcre_compile) (const char *, int, const char **, int *, const unsigned char *);\r\nconst char *(*pcre_version) (void);\r\nvoid (*pcre_free) (void *);\r\nint (*pcre_fullinfo) (const pcre *, const pcre_extra *, int, void *);\r\nint (*pcre_exec) (const pcre *, const pcre_extra *, const char *, int, int, int, int *, int);\r\n#endif\r\nstatic void sim_exp_initialize (void);\r\n\r\nt_stat sim_last_cmd_stat;                               /* Command Status */\r\nstruct timespec cmd_time;                               /*  */\r\n\r\nstatic SCHTAB sim_stabr;                                /* Register search specifier */\r\nstatic SCHTAB sim_staba;                                /* Memory search specifier */\r\n\r\nstatic const char *sim_int_step_description (DEVICE *dptr)\r\n{\r\nreturn \"Step/Next facility\";\r\n}\r\n\r\nstatic UNIT sim_step_unit = { UDATA (&step_svc, UNIT_IDLE, 0) };\r\nDEVICE sim_step_dev = {\r\n    \"INT-STEP\", &sim_step_unit, NULL, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    sim_int_step_description};\r\n\r\nstatic const char *sim_int_runlimit_description (DEVICE *dptr)\r\n{\r\nreturn \"Run time limit facility\";\r\n}\r\n\r\nstatic t_stat sim_int_runlimit_reset (DEVICE *dptr)\r\n{\r\nif (sim_runlimit_enabled) {\r\n    if (sim_runlimit_switches & SWMASK ('T'))\r\n        return sim_activate_after_d (dptr->units, sim_runlimit_d);\r\n    else\r\n        return sim_activate (dptr->units, sim_runlimit);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic UNIT sim_runlimit_unit = { UDATA (&runlimit_svc, UNIT_IDLE, 0) };\r\nDEVICE sim_runlimit_dev = {\r\n    \"INT-RUNLIMIT\", &sim_runlimit_unit, NULL, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, &sim_int_runlimit_reset, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    sim_int_runlimit_description};\r\n\r\nstatic const char *sim_int_expect_description (DEVICE *dptr)\r\n{\r\nreturn \"Expect facility\";\r\n}\r\n\r\nstatic UNIT sim_expect_unit = { UDATA (&expect_svc, 0, 0) };\r\nDEVICE sim_expect_dev = {\r\n    \"INT-EXPECT\", &sim_expect_unit, NULL, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    sim_int_expect_description};\r\n\r\nstatic const char *sim_int_flush_description (DEVICE *dptr)\r\n{\r\nreturn \"Open File Flush facility\";\r\n}\r\n\r\nstatic uint32 sim_flush_interval = 30;  /* Flush I/O buffers every 30 seconds */\r\nstatic REG sim_flush_reg[] = {\r\n    { DRDATAD(FLUSH_INTERVAL, sim_flush_interval, 32, \"Periodic Buffer Flush Interval (seconds)\") },\r\n    { NULL}\r\n    };\r\n\r\nstatic UNIT sim_flush_unit = { UDATA (&flush_svc, UNIT_IDLE, 0) };\r\nDEVICE sim_flush_dev = {\r\n    \"INT-FLUSH\", &sim_flush_unit, sim_flush_reg, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    sim_int_flush_description};\r\n\r\n#if defined USE_INT64\r\nstatic const char *sim_si64 = \"64b data\";\r\n#else\r\nstatic const char *sim_si64 = \"32b data\";\r\n#endif\r\n#if defined USE_ADDR64\r\nstatic const char *sim_sa64 = \"64b addresses\";\r\n#else\r\nstatic const char *sim_sa64 = \"32b addresses\";\r\n#endif\r\nconst char *sim_savename = sim_name;      /* Simulator Name used in SAVE/RESTORE images */\r\n\r\n/* Tables and strings */\r\n\r\nconst char save_vercur[] = \"V4.0\";\r\nconst char save_ver40[] = \"V4.0\";\r\nconst char save_ver35[] = \"V3.5\";\r\nconst char save_ver32[] = \"V3.2\";\r\nconst char save_ver30[] = \"V3.0\";\r\nconst struct scp_error {\r\n    const char *code;\r\n    const char *message;\r\n    } scp_errors[1+SCPE_MAX_ERR-SCPE_BASE] =\r\n        {{\"NXM\",       \"Address space exceeded\"},\r\n         {\"UNATT\",     \"Unit not attached\"},\r\n         {\"IOERR\",     \"I/O error\"},\r\n         {\"CSUM\",      \"Checksum error\"},\r\n         {\"FMT\",       \"Format error\"},\r\n         {\"NOATT\",     \"Unit not attachable\"},\r\n         {\"OPENERR\",   \"File open error\"},\r\n         {\"MEM\",       \"Memory exhausted\"},\r\n         {\"ARG\",       \"Invalid argument\"},\r\n         {\"STEP\",      \"Step expired\"},\r\n         {\"UNK\",       \"Unknown command\"},\r\n         {\"RO\",        \"Read only argument\"},\r\n         {\"INCOMP\",    \"Command not completed\"},\r\n         {\"STOP\",      \"Simulation stopped\"},\r\n         {\"EXIT\",      \"Goodbye\"},\r\n         {\"TTIERR\",    \"Console input I/O error\"},\r\n         {\"TTOERR\",    \"Console output I/O error\"},\r\n         {\"EOF\",       \"End of file\"},\r\n         {\"REL\",       \"Relocation error\"},\r\n         {\"NOPARAM\",   \"No settable parameters\"},\r\n         {\"ALATT\",     \"Unit already attached\"},\r\n         {\"TIMER\",     \"Hardware timer error\"},\r\n         {\"SIGERR\",    \"Signal handler setup error\"},\r\n         {\"TTYERR\",    \"Console terminal setup error\"},\r\n         {\"SUB\",       \"Subscript out of range\"},\r\n         {\"NOFNC\",     \"Command not allowed\"},\r\n         {\"UDIS\",      \"Unit disabled\"},\r\n         {\"NORO\",      \"Read only operation not allowed\"},\r\n         {\"INVSW\",     \"Invalid switch\"},\r\n         {\"MISVAL\",    \"Missing value\"},\r\n         {\"2FARG\",     \"Too few arguments\"},\r\n         {\"2MARG\",     \"Too many arguments\"},\r\n         {\"NXDEV\",     \"Non-existent device\"},\r\n         {\"NXUN\",      \"Non-existent unit\"},\r\n         {\"NXREG\",     \"Non-existent register\"},\r\n         {\"NXPAR\",     \"Non-existent parameter\"},\r\n         {\"NEST\",      \"Nested DO command limit exceeded\"},\r\n         {\"IERR\",      \"Internal error\"},\r\n         {\"MTRLNT\",    \"Invalid magtape record length\"},\r\n         {\"LOST\",      \"Console Telnet connection lost\"},\r\n         {\"TTMO\",      \"Console Telnet connection timed out\"},\r\n         {\"STALL\",     \"Console Telnet output stall\"},\r\n         {\"AFAIL\",     \"Assertion failed\"},\r\n         {\"INVREM\",    \"Invalid remote console command\"},\r\n         {\"EXPECT\",    \"Expect matched\"},\r\n         {\"AMBREG\",    \"Ambiguous register name\"},\r\n         {\"REMOTE\",    \"remote console command\"},\r\n         {\"INVEXPR\",   \"invalid expression\"},\r\n         {\"SIGTERM\",   \"SIGTERM received\"},\r\n         {\"FSSIZE\",    \"File System size larger than disk size\"},\r\n         {\"RUNTIME\",   \"Run time limit exhausted\"},\r\n         {\"INCOMPDSK\", \"Incompatible Disk Container\"},\r\n         {\"AMBASSIGN\", \"Ambiguous logical name\"},\r\n    };\r\n\r\nconst size_t size_map[] = { sizeof (int8),\r\n    sizeof (int8), sizeof (int16), sizeof (int32), sizeof (int32)\r\n#if defined (USE_INT64)\r\n    , sizeof (t_int64), sizeof (t_int64), sizeof (t_int64), sizeof (t_int64)\r\n#endif\r\n};\r\n\r\nconst t_value width_mask[] = { 0,\r\n    0x1, 0x3, 0x7, 0xF,\r\n    0x1F, 0x3F, 0x7F, 0xFF,\r\n    0x1FF, 0x3FF, 0x7FF, 0xFFF,\r\n    0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF,\r\n    0x1FFFF, 0x3FFFF, 0x7FFFF, 0xFFFFF,\r\n    0x1FFFFF, 0x3FFFFF, 0x7FFFFF, 0xFFFFFF,\r\n    0x1FFFFFF, 0x3FFFFFF, 0x7FFFFFF, 0xFFFFFFF,\r\n    0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF, 0xFFFFFFFF\r\n#if defined (USE_INT64)\r\n    , 0x1FFFFFFFF, 0x3FFFFFFFF, 0x7FFFFFFFF, 0xFFFFFFFFF,\r\n    0x1FFFFFFFFF, 0x3FFFFFFFFF, 0x7FFFFFFFFF, 0xFFFFFFFFFF,\r\n    0x1FFFFFFFFFF, 0x3FFFFFFFFFF, 0x7FFFFFFFFFF, 0xFFFFFFFFFFF,\r\n    0x1FFFFFFFFFFF, 0x3FFFFFFFFFFF, 0x7FFFFFFFFFFF, 0xFFFFFFFFFFFF,\r\n    0x1FFFFFFFFFFFF, 0x3FFFFFFFFFFFF, 0x7FFFFFFFFFFFF, 0xFFFFFFFFFFFFF,\r\n    0x1FFFFFFFFFFFFF, 0x3FFFFFFFFFFFFF, 0x7FFFFFFFFFFFFF, 0xFFFFFFFFFFFFFF,\r\n    0x1FFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFF,\r\n    0x7FFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFF,\r\n    0x1FFFFFFFFFFFFFFF, 0x3FFFFFFFFFFFFFFF,\r\n    0x7FFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF\r\n#endif\r\n    };\r\n\r\nstatic char *simh_help = NULL;  /* First invocation of HELP command appends the help pieces */\r\n\r\nstatic const char simh_help1[] =\r\n       /***************** 80 character line width template *************************/\r\n      \"1Commands\\n\"\r\n#define HLP_RESET       \"*Commands Resetting Devices\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Resetting Devices\\n\"\r\n      \" The RESET command (abbreviation RE) resets a device or the entire simulator\\n\"\r\n      \" to a predefined condition.  If switch -p is specified, the device is reset\\n\"\r\n      \" to its power-up state:\\n\\n\"\r\n      \"++RESET                  reset all devices\\n\"\r\n      \"++RESET -p               powerup all devices\\n\"\r\n      \"++RESET ALL              reset all devices\\n\"\r\n      \"++RESET <device>         reset specified device\\n\\n\"\r\n      \" Typically, RESET stops any in-progress I/O operation, clears any interrupt\\n\"\r\n      \" request, and returns the device to a quiescent state.  It does not clear\\n\"\r\n      \" main memory or affect I/O connections.\\n\"\r\n#define HLP_EXAMINE     \"*Commands Examining_and_Changing_State\"\r\n#define HLP_IEXAMINE    \"*Commands Examining_and_Changing_State\"\r\n#define HLP_DEPOSIT     \"*Commands Examining_and_Changing_State\"\r\n#define HLP_IDEPOSIT    \"*Commands Examining_and_Changing_State\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Examining and Changing State\\n\"\r\n      \" There are four commands to examine and change state:\\n\\n\"\r\n      \"++EXAMINE (abbreviated E) examines state\\n\"\r\n      \"++DEPOSIT (abbreviated D) changes state\\n\"\r\n      \"++IEXAMINE (interactive examine, abbreviated IE) examines state and allows\\n\"\r\n      \"++++the user to interactively change it\\n\"\r\n      \"++IDEPOSIT (interactive deposit, abbreviated ID) allows the user to\\n\"\r\n      \"++++interactively change state\\n\\n\"\r\n      \" All four commands take the form\\n\\n\"\r\n      \"++command {modifiers} <object list>\\n\\n\"\r\n      \" Deposit must also include a deposit value at the end of the command.\\n\\n\"\r\n      \" There are four kinds of modifiers: switches, device/unit name, search\\n\"\r\n      \" specifier, and for EXAMINE, output file.  Switches have been described\\n\"\r\n      \" previously.  A device/unit name identifies the device and unit whose\\n\"\r\n      \" address space is to be examined or modified.  If no device is specified,\\n\"\r\n      \" the CPU (main memory)is selected; if a device but no unit is specified,\\n\"\r\n      \" unit 0 of the device is selected.\\n\\n\"\r\n      \" The search specifier provides criteria for testing addresses or registers\\n\"\r\n      \" to see if they should be processed.  A specifier consists of a logical\\n\"\r\n      \" operator, a relational operator, or both, optionally separated by spaces.\\n\\n\"\r\n      \"++{<logical op> <value>} <relational op> <value>\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \" where the logical operator is & (and), | (or), or ^ (exclusive or), and the\\n\"\r\n      \" relational operator is = or == (equal), ! or != (not equal), >= (greater\\n\"\r\n      \" than or equal), > (greater than), <= (less than or equal), or < (less than).\\n\"\r\n      \" If a logical operator is specified without a relational operator, it is\\n\"\r\n      \" ignored.  If a relational operator is specified without a logical operator,\\n\"\r\n      \" no logical operation is performed.  All comparisons are unsigned.\\n\\n\"\r\n      \" The output file modifier redirects command output to a file instead of the\\n\"\r\n      \" console.  An output file modifier consists of @ followed by a valid file\\n\"\r\n      \" name.\\n\\n\"\r\n      \" Modifiers may be specified in any order.  If multiple modifiers of the\\n\"\r\n      \" same type are specified, later modifiers override earlier modifiers.  Note\\n\"\r\n      \" that if the device/unit name comes after the search specifier, the search\\n\"\r\n      \" values will interpreted in the radix of the CPU, rather than of the\\n\"\r\n      \" device/unit.\\n\\n\"\r\n      \" The \\\"object list\\\" consists of one or more of the following, separated by\\n\"\r\n      \" commas:\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"++register                the specified register\\n\"\r\n      \"++register[sub1-sub2]     the specified register array locations,\\n\"\r\n      \"++++++++                  starting at location sub1 up to and\\n\"\r\n      \"++++++++                  including location sub2\\n\"\r\n      \"++register[sub1/length]   the specified register array locations,\\n\"\r\n      \"++++++++                  starting at location sub1 up to but\\n\"\r\n      \"++++++++                  not including sub1+length\\n\"\r\n      \"++register[ALL]           all locations in the specified register\\n\"\r\n      \"++++++++                  array\\n\"\r\n      \"++register1-register2     all the registers starting at register1\\n\"\r\n      \"++++++++                  up to and including register2\\n\"\r\n      \"++address                 the specified location\\n\"\r\n      \"++address1-address2       all locations starting at address1 up to\\n\"\r\n      \"++++++++                  and including address2\\n\"\r\n      \"++address/length          all location starting at address up to\\n\"\r\n      \"++++++++                  but not including address+length\\n\"\r\n      \"++STATE                   all registers in the device\\n\"\r\n      \"++ALL                     all locations in the unit\\n\"\r\n      \"++$                       the last value displayed by an EXAMINE\\n\"\r\n      \"++++++++                  command\\n\"\r\n      \"3Switches\\n\"\r\n      \" Switches can be used to control the format of display information.\\n\"\r\n      \" The actual interpretation and format of examine and deposit data is\\n\"\r\n      \" specific to each simulator, so HELP CPU or other documentation for\\n\"\r\n      \" this simulator might provide more details about how these details\\n\"\r\n      \" are interpreted in this simulator.  The default switch interpretations\\n\"\r\n      \" are:\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"++-a                 display as ASCII\\n\"\r\n      \"++-c                 display as character string\\n\"\r\n      \"++-m                 display as instruction mnemonics\\n\"\r\n      \"++-o or -8           display as octal\\n\"\r\n      \"++-d or -10          display as decimal\\n\"\r\n      \"++-h or -16          display as hexadecimal\\n\"\r\n      \"++-2                 display as binary\\n\"\r\n      \"++-q                 suppress examine output\\n\\n\"\r\n      \" The simulators typically accept symbolic input (see documentation with\\n\"\r\n      \" each simulator).\\n\\n\"\r\n      \"3Examples\\n\"\r\n      \" Examples:\\n\\n\"\r\n      \"++ex 1000-1100                examine 1000 to 1100\\n\"\r\n      \"++de PC 1040                  set PC to 1040\\n\"\r\n      \"++ie 40-50                    interactively examine 40:50\\n\"\r\n      \"++ie >1000 40-50              interactively examine the subset\\n\"\r\n      \"+++++++++                     of locations 40:50 that are >1000\\n\"\r\n      \"++ex rx0 50060                examine 50060, RX unit 0\\n\"\r\n      \"++ex rx sbuf[3-6]             examine SBUF[3] to SBUF[6] in RX\\n\"\r\n      \"++de all 0                    set main memory to 0\\n\"\r\n      \"++de &77>0 0                  set all addresses whose low order\\n\"\r\n      \"+++++++++                     bits are non-zero to 0\\n\"\r\n      \"++ex -m @memdump.txt 0-7777   dump memory to file\\n\"\r\n      \"++ex -q 200                   get the contents of 200 available as $\\n\"\r\n      \"++dep r0 $                    store what was in 200 in r0\\n\\n\"\r\n      \" Note: to terminate an interactive command, simply type a bad value\\n\"\r\n      \"       (eg, XYZ) when input is requested.\\n\"\r\n#define HLP_EVALUATE    \"*Commands Evaluating_Instructions\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Evaluating Instructions\\n\"\r\n      \" The EVAL command evaluates a symbolic instruction and returns the\\n\"\r\n      \" equivalent numeric value.  This is useful for obtaining numeric arguments\\n\"\r\n      \" for a search command:\\n\\n\"\r\n      \"++EVAL <expression>\\n\\n\"\r\n      \" Examples:\\n\\n\"\r\n      \"+On the VAX simulator:\\n\"\r\n      \"++sim> eval addl2 r2,r3\\n\"\r\n      \"++0:      005352C0\\n\"\r\n      \"++sim> eval addl2 #ff,6(r0)\\n\"\r\n      \"++0:      00FF8FC0\\n\"\r\n      \"++4:      06A00000\\n\"\r\n      \"++sim> eval 'AB\\n\"\r\n      \"++0:      00004241\\n\\n\"\r\n      \"+On the PDP-8:\\n\"\r\n      \"++sim> eval tad 60\\n\"\r\n      \"++0:      1060\\n\"\r\n      \"++sim> eval tad 300\\n\"\r\n      \"++tad 300\\n\"\r\n      \"++Can't be parsed as an instruction or data\\n\\n\"\r\n      \" 'tad 300' fails, because with an implicit PC of 0, location 300 can't be\\n\"\r\n      \" reached with direct addressing.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Loading and Saving Programs\\n\"\r\n#define HLP_LOAD        \"*Commands Loading_and_Saving_Programs LOAD\"\r\n      \"3LOAD\\n\"\r\n      \" The LOAD command (abbreviation LO) loads a file in binary loader format:\\n\\n\"\r\n      \"++LOAD <filename> {implementation options}\\n\\n\"\r\n      \" The types of formats supported are simulator implementation specific.\\n\"\r\n      \" Options: (such as load within range) are also implementation specific.\\n\\n\"\r\n#define HLP_DUMP        \"*Commands Loading_and_Saving_Programs DUMP\"\r\n      \"3DUMP\\n\"\r\n      \" The DUMP command (abbreviation DU) dumps memory in binary loader format:\\n\\n\"\r\n      \"++DUMP <filename> {implementation options}\\n\\n\"\r\n      \" The types of formats supported are simulator implementation specific.\\n\"\r\n      \" Options (such as dump within range) are also implementation specific.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Saving and Restoring State\\n\"\r\n#define HLP_SAVE        \"*Commands Saving_and_Restoring_State SAVE\"\r\n      \"3SAVE\\n\"\r\n      \" The SAVE command (abbreviation SA) save the complete state of the simulator\\n\"\r\n      \" to a file.  This includes the contents of main memory and all registers,\\n\"\r\n      \" and the I/O connections of devices:\\n\\n\"\r\n      \"++SAVE <filename>\\n\\n\"\r\n#define HLP_RESTORE     \"*Commands Saving_and_Restoring_State RESTORE\"\r\n      \"3RESTORE\\n\"\r\n      \" The RESTORE command (abbreviation REST, alternately GET) restores a\\n\"\r\n      \" previously saved simulator state:\\n\\n\"\r\n      \"++RESTORE <filename>\\n\"\r\n      \"4Switches\\n\"\r\n      \" Switches can influence the output and behavior of the RESTORE command\\n\\n\"\r\n      \"++-Q      Suppresses version warning messages\\n\"\r\n      \"++-D      Suppress detaching and attaching devices during a restore\\n\"\r\n      \"++-F      Overrides the related file timestamp validation check\\n\"\r\n      \"\\n\"\r\n      \"4Notes:\\n\"\r\n      \" 1) SAVE file format compresses zeroes to minimize file size.\\n\"\r\n      \" 2) The simulator can't restore active incoming telnet sessions to\\n\"\r\n      \" multiplexer devices, but the listening ports will be restored across a\\n\"\r\n      \" save/restore.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Running A Simulated Program\\n\"\r\n#define HLP_RUN         \"*Commands Running_A_Simulated_Program RUN\"\r\n      \"3RUN {start_pc_addr} {UNTIL stop_pc_addr|\\\"output-string\\\"}\\n\"\r\n      \" The RUN command (abbreviated RU) resets all devices, deposits its argument\\n\"\r\n      \" (if given) in the PC, and starts execution.  If no argument is given,\\n\"\r\n      \" execution starts at the current PC.\\n\\n\"\r\n      \" The optional UNTIL argument specifies a stop criteria for execution.\\n\"\r\n      \" There are two forms of execution stop criteria:\\n\"\r\n      \"+1. A temporary breakpoint (which exists only until it is encountered).\\n\"\r\n      \"+2. A string which will stop execution when the simulator has output\\n\"\r\n      \"++the indicated string.\\n\\n\"\r\n#define HLP_GO          \"*Commands Running_A_Simulated_Program GO\"\r\n      \"3GO {start_pc_addr} {UNTIL stop_pc_addr|\\\"output-string\\\"}\\n\"\r\n      \" The GO command does not reset devices, deposits its argument (if given)\\n\"\r\n      \" in the PC, and starts execution.  If no argument is given, execution\\n\"\r\n      \" starts at the current PC.\\n\\n\"\r\n      \" The optional UNTIL argument specifies a stop criteria for execution.\\n\"\r\n      \" There are two forms of execution stop criteria:\\n\"\r\n      \"+1. A temporary breakpoint (which exists only until it is encountered).\\n\"\r\n      \"+2. A string which will stop execution when the simulator has output\\n\"\r\n      \"++the indicated string.\\n\\n\"\r\n#define HLP_CONTINUE    \"*Commands Running_A_Simulated_Program CONTINUE\"\r\n      \"3CONTINUE\\n\"\r\n      \" The CONT command (abbreviated CO) does not reset devices and resumes\\n\"\r\n      \" execution at the current PC.\\n\\n\"\r\n#define HLP_STEP        \"*Commands Running_A_Simulated_Program STEP\"\r\n      \"3STEP\\n\"\r\n      \" The STEP command (abbreviated S) resumes execution at the current PC for\\n\"\r\n      \" the number of %Is given by its argument.  If no argument is\\n\"\r\n      \" supplied, one %I is executed.\\n\"\r\n      \"4Switches\\n\"\r\n      \" If the STEP command is invoked with the -T switch, the step command will\\n\"\r\n      \" cause execution to run for microseconds rather than %I.\\n\"\r\n#define HLP_NEXT        \"*Commands Running_A_Simulated_Program NEXT\"\r\n      \"3NEXT\\n\"\r\n      \" The NEXT command (abbreviated N) resumes execution at the current PC for\\n\"\r\n      \" one instruction, attempting to execute through a subroutine calls.\\n\"\r\n      \" If the next instruction to be executed is not a subroutine call,\\n\"\r\n      \" one instruction is executed.\\n\\n\"\r\n#define HLP_BOOT        \"*Commands Running_A_Simulated_Program BOOT\"\r\n      \"3BOOT {dev|unit}\\n\"\r\n      \" The BOOT command (abbreviated BO) resets all devices and bootstraps the\\n\"\r\n      \" device and unit given by its argument.  If no unit is supplied, unit 0 is\\n\"\r\n      \" bootstrapped.  The specified unit, generally, must be attached.\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Stopping The Simulator\\n\"\r\n      \" Programs run until the simulator detects an error or stop condition, or\\n\"\r\n      \" until the user forces a stop condition.\\n\"\r\n      \"3Simulator Detected Stop Conditions\\n\"\r\n      \" These simulator-detected conditions stop simulation:\\n\\n\"\r\n      \"++-  HALT instruction.  If a HALT instruction is decoded, simulation stops.\\n\"\r\n      \"++-  Breakpoint.  The simulator may support breakpoints (see below).\\n\"\r\n      \"++-  I/O error.  If an I/O error occurs during simulation of an I/O\\n\"\r\n      \"+++operation, and the device stop-on-I/O-error flag is set, simulation\\n\"\r\n      \"+++usually stops.\\n\\n\"\r\n      \"++-  Processor condition.  Certain processor conditions can stop\\n\"\r\n      \"+++simulation; these are described with the individual simulators.\\n\"\r\n      \"3User Specified Stop Conditions\\n\"\r\n      \" Typing the interrupt character stops simulation.  The interrupt character\\n\"\r\n      \" is defined by the WRU (where are you) console option and is initially set\\n\"\r\n      \" to 005 (^E).\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_BREAK       \"*Commands Stopping_The_Simulator User_Specified_Stop_Conditions BREAK\"\r\n#define HLP_NOBREAK     \"*Commands Stopping_The_Simulator User_Specified_Stop_Conditions BREAK\"\r\n      \"4Breakpoints\\n\"\r\n      \" A simulator may offer breakpoint capability.  A simulator may define\\n\"\r\n      \" breakpoints of different types, identified by letter (for example, E for\\n\"\r\n      \" execution, R for read, W for write, etc).  At the moment, most simulators\\n\"\r\n      \" support only E (execution) breakpoints.\\n\\n\"\r\n      \" Associated with a breakpoint are a count and, optionally, one or more\\n\"\r\n      \" actions.  Each time the breakpoint is taken, the associated count is\\n\"\r\n      \" decremented.  If the resulting count is less than or equal to 0, the\\n\"\r\n      \" breakpoint occurs; otherwise, it is deferred.  When the breakpoint occurs,\\n\"\r\n      \" the optional actions are automatically executed.\\n\\n\"\r\n      \" A breakpoint is set by the BREAK or the SET BREAK commands:\\n\\n\"\r\n      \"++BREAK {-types} {<addr range>{[count]},{addr range...}}{;action;action...}\\n\"\r\n      \"++SET BREAK {-types} {<addr range>{[count]},{addr range...}}{;action;action...}\\n\\n\"\r\n      \" If no type is specified, the simulator-specific default breakpoint type\\n\"\r\n      \" (usually E for execution) is used.  If no address range is specified, the\\n\"\r\n      \" current PC is used.  As with EXAMINE and DEPOSIT, an address range may be a\\n\"\r\n      \" single address, a range of addresses low-high, or a relative range of\\n\"\r\n      \" address/length.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"5Displaying Breakpoints\\n\"\r\n      \" Currently set breakpoints can be displayed with the SHOW BREAK command:\\n\\n\"\r\n      \"++SHOW {-C} {-types} BREAK {ALL|<addr range>{,<addr range>...}}\\n\\n\"\r\n      \" Locations with breakpoints of the specified type are displayed.\\n\\n\"\r\n      \" The -C switch displays the selected breakpoint(s) formatted as commands\\n\"\r\n      \" which may be subsequently used to establish the same breakpoint(s).\\n\\n\"\r\n      \"5Removing Breakpoints\\n\"\r\n      \" Breakpoints can be cleared by the NOBREAK or the SET NOBREAK commands.\\n\"\r\n      \"5Examples\\n\"\r\n      \"++BREAK                       set E break at current PC\\n\"\r\n      \"++BREAK -e 200                set E break at 200\\n\"\r\n      \"++BREAK 2000/2[2]             set E breaks at 2000,2001 with count = 2\\n\"\r\n      \"++BREAK 100;EX AC;D MQ 0      set E break at 100 with actions EX AC\\n\"\r\n      \"+++++++++and D MQ 0\\n\"\r\n      \"++BREAK 100;                  delete action on break at 100\\n\"\r\n      \"++HELP CPU BREAK              display the breakpoint types supported\\n\"\r\n      \"+++++++++by the CPU device\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_DEBUG       \"*Commands Stopping_The_Simulator User_Specified_Stop_Conditions DEBUG\"\r\n#define HLP_NODEBUG     \"*Commands Stopping_The_Simulator User_Specified_Stop_Conditions DEBUG\"\r\n      \"4Debug\\n\"\r\n      \" The DEBUG snd NODEBUG commands are aliases for the \\\"SET DEBUG\\\" and\\n\"\r\n      \" \\\"SET NODEBUG\\\" commands.  Additionally, support is provided that is\\n\"\r\n      \" equivalent to the \\\"SET <dev> DEBUG=opt1{;opt2}\\\" and\\n\"\r\n      \" \\\"SET <dev> NODEBUG=opt1{;opt2}\\\" commands.\\n\\n\"\r\n#define HLP_RUNLIMIT      \"*Commands Stopping_The_Simulator User_Specified_Stop_Conditions RUNLIMIT\"\r\n      \"4RUNLIMIT\\n\"\r\n      \" A simulator user may want to limit the maximum execution time that a\\n\"\r\n      \" simulator may run for.  This might be appropriate to limit a runaway\\n\"\r\n      \" diagnostic which didn't achieve explicit success or failure within\\n\"\r\n      \" some user specified time.  The RUNLIMIT command provides ways to\\n\"\r\n      \" limit execution.\\n\\n\"\r\n      \"+RUNLIMIT n{K|M} {%C|MICROSECONDS|SECONDS|MINUTES|HOURS}\\n\"\r\n      \"+NORUNLIMIT\\n\\n\"\r\n      \"  Equivalently:\\n\\n\"\r\n      \"+SET RUNLIMIT n{K|M} {%C|MICROSECONDS|SECONDS|MINUTES|HOURS}\\n\"\r\n      \"+SET NORUNLIMIT\\n\\n\"\r\n      \" The value n can be expressed as a bare number or as nK or nM to represent\\n\"\r\n      \" thousands or millions of the specified units.\\n\\n\"\r\n      \" The run limit state can be examined with:\\n\\n\"\r\n      \"+SHOW RUNLIMIT\\n\\n\"\r\n      \" If the units of the run limit are not specified, the default units are\\n\"\r\n      \" %C.  Once an execution run limit has been reached, any subsequent\\n\"\r\n      \" GO, RUN, CONTINUE, STEP or BOOT commands will cause the simulator to\\n\"\r\n      \" exit.  A previously defined RUNLIMIT can be cleared with the NORUNLIMIT\\n\"\r\n      \" command or the establishment of a new run limit.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Connecting and Disconnecting Devices\\n\"\r\n      \" Except for main memory and network devices, units are simulated as\\n\"\r\n      \" unstructured binary disk files in the host file system.  Before using a\\n\"\r\n      \" simulated unit, the user must specify the file to be accessed by that unit.\\n\"\r\n#define HLP_ATTACH      \"*Commands Connecting_and_Disconnecting_Devices ATTACH\"\r\n      \"3ATTACH\\n\"\r\n      \" The ATTACH (abbreviation AT) command associates a unit and a file:\\n\"\r\n      \"++ATTACH <unit> <filename>\\n\\n\"\r\n      \" Some devices have more detailed or specific help available with:\\n\\n\"\r\n      \"++HELP <device> ATTACH\\n\\n\"\r\n      \"4Switches\\n\"\r\n      \"5-n\\n\"\r\n      \" If the -n switch is specified when an attach is executed, a new file is\\n\"\r\n      \" created, and an appropriate message is printed.\\n\"\r\n      \"5-e\\n\"\r\n      \" If the file does not exist, and the -e switch was not specified, a new\\n\"\r\n      \" file is created, and an appropriate message is printed.  If the -e switch\\n\"\r\n      \" was specified, a new file is not created, and an error message is printed.\\n\"\r\n      \"5-r\\n\"\r\n      \" If the -r switch is specified, or the file is write protected, ATTACH tries\\n\"\r\n      \" to open the file read only.  If the file does not exist, or the unit does\\n\"\r\n      \" not support read only operation, an error occurs.  Input-only devices, such\\n\"\r\n      \" as paper-tape readers, and devices with write lock switches, such as disks\\n\"\r\n      \" and tapes, support read only operation; other devices do not.  If a file is\\n\"\r\n      \" attached read only, its contents can be examined but not modified.\\n\"\r\n      \"5-a\\n\"\r\n      \" If the -a switch is specified, and the device being attached is a\\n\"\r\n      \" sequential output only device (like a line printer, paper tape punch,\\n\"\r\n      \" etc.), the file being attached will be opened for write and positioned\\n\"\r\n      \" at the end of the file's current contents, thus adding to any existing\\n\"\r\n      \" file data beyond what may have already been there.\\n\"\r\n      \"5-q\\n\"\r\n      \" If the -q switch is specified when creating a new file (-n) or opening one\\n\"\r\n      \" read only (-r), any messages announcing these facts will be suppressed.\\n\"\r\n      \"5-f\\n\"\r\n      \" For simulated magnetic tapes, the ATTACH command can specify the format of\\n\"\r\n      \" the attached tape image file:\\n\\n\"\r\n      \"++ATTACH -f <tape_unit> <format> <filename>\\n\\n\"\r\n      \" The currently supported tape image file formats are:\\n\\n\"\r\n      \"++SIMH                   SIMH simulator format\\n\"\r\n      \"++E11                    E11 simulator format\\n\"\r\n      \"++TPC                    TPC format\\n\"\r\n      \"++P7B                    Pierce simulator 7-track format\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \" For some simulated disk devices, the ATTACH command can specify the format\\n\"\r\n      \" of the attached disk image file:\\n\\n\"\r\n      \"++ATTACH -f <disk_unit> <format> <filename>\\n\\n\"\r\n      \" The currently supported disk image file formats are:\\n\\n\"\r\n      \"++SIMH                   SIMH simulator format\\n\"\r\n      \"++VHD                    Virtual Disk format\\n\"\r\n      \"++RAW                    platform specific access to physical disk or\\n\"\r\n      \"++                       CDROM drives\\n\"\r\n      \" The disk format can also be set with the SET command prior to ATTACH:\\n\\n\"\r\n      \"++SET <disk_unit> FORMAT=<format>\\n\"\r\n      \"++ATT <disk_unit> <filename>\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \" The format of an attached tape or disk file can be displayed with the SHOW\\n\"\r\n      \" command:\\n\"\r\n      \"++SHOW <unit> FORMAT\\n\"\r\n      \" For Telnet-based terminal emulation devices, the ATTACH command associates\\n\"\r\n      \" the master unit with a TCP/IP listening port:\\n\\n\"\r\n      \"++ATTACH <unit> <port>\\n\\n\"\r\n      \" The port is a decimal number between 1 and 65535 that is not already used\\n\"\r\n      \" other TCP/IP applications.\\n\"\r\n      \" For Ethernet emulators, the ATTACH command associates the simulated Ethernet\\n\"\r\n      \" with a physical Ethernet device:\\n\\n\"\r\n      \"++ATTACH <unit> <physical device name>\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_DETACH      \"*Commands Connecting_and_Disconnecting_Devices DETACH\"\r\n      \"3DETACH\\n\"\r\n      \" The DETACH (abbreviation DET) command breaks the association between a unit\\n\"\r\n      \" and a file, port, or network device:\\n\\n\"\r\n      \"++DETACH ALL             detach all units\\n\"\r\n      \"++DETACH <unit>          detach specified unit\\n\"\r\n      \" The EXIT command performs an automatic DETACH ALL.\\n\"\r\n      \"2Controlling Simulator Operating Environment\\n\"\r\n      \"3Working Directory\\n\"\r\n#define HLP_CD          \"*Commands Controlling_Simulator_Operating_Environment Working_Directory CD\"\r\n      \"4CD\\n\"\r\n      \" Set the current working directory:\\n\"\r\n      \"++CD path\\n\"\r\n      \"4SET_DEFAULT\\n\"\r\n      \" Set the current working directory:\\n\"\r\n      \"++SET DEFAULT path\\n\"\r\n#define HLP_PWD         \"*Commands Controlling_Simulator_Operating_Environment Working_Directory PWD\"\r\n      \"4PWD\\n\"\r\n      \"++PWD\\n\"\r\n      \" Display the current working directory:\\n\"\r\n      \"2Listing Files\\n\"\r\n#define HLP_DIR         \"*Commands Listing_Files DIR\"\r\n      \"3DIR\\n\"\r\n      \"++DIR {path}                list directory files\\n\"\r\n#define HLP_LS          \"*Commands Listing_Files LS\"\r\n      \"3LS\\n\"\r\n      \"++LS {path}                 list directory files\\n\"\r\n      \"2Displaying Files\\n\"\r\n#define HLP_TYPE         \"*Commands Displaying_Files TYPE\"\r\n      \"3TYPE\\n\"\r\n      \"++TYPE file                 display a file contents\\n\"\r\n      \"4Switches\\n\"\r\n      \" The -O switch start displaying file contents at the specified\\n\"\r\n      \" file offset.\\n\\n\"\r\n      \" The -N switch will display up to a specified number of lines\\n\"\r\n      \" from the file.\\n\\n\"\r\n      \"++TYPE -{O}{N} {offset} {lines} file\\n\\n\"\r\n#define HLP_CAT          \"*Commands Displaying_Files CAT\"\r\n      \"3CAT\\n\"\r\n      \"++CAT file                  display a file contents\\n\"\r\n      \"4Switches\\n\"\r\n      \" The -O switch start displaying file contents at the specified\\n\"\r\n      \" file offset.\\n\\n\"\r\n      \" The -N switch will display up to a specified number of lines\\n\"\r\n      \" from the file.\\n\\n\"\r\n      \"++TYPE -{O}{N} {offset} {lines} file\\n\\n\"\r\n      \"2Removing Files\\n\"\r\n#define HLP_DELETE       \"*Commands Removing_Files DEL\"\r\n      \"3DELETE\\n\"\r\n      \"++DEL{ete} file             deletes a file\\n\"\r\n      \"4Switches\\n\"\r\n      \" The -Q switch will suppress file not found warning messages\\n\\n\"\r\n#define HLP_RM          \"*Commands Removing_Files RM\"\r\n      \"3RM\\n\"\r\n      \"++RM file                   deletes a file\\n\"\r\n      \"4Switches\\n\"\r\n      \" The -Q switch will suppress file not found warning messages\\n\\n\"\r\n      \"2Copying Files\\n\"\r\n#define HLP_COPY        \"*Commands Copying_Files COPY\"\r\n      \"3COPY\\n\"\r\n      \"++COPY sfile dfile          copies a file\\n\"\r\n#define HLP_CP          \"*Commands Copying_Files CP\"\r\n      \"3CP\\n\"\r\n      \"++CP sfile dfile            copies a file\\n\"\r\n      \"2Renaming Files\\n\"\r\n#define HLP_RENAME      \"*Commands Renaming_Files RENAME\"\r\n      \"3RENAME\\n\"\r\n      \"++RENAME origname newname   renames a file\\n\"\r\n#define HLP_MOVE        \"*Commands Renaming_Files MOVE\"\r\n      \"3MOVE\\n\"\r\n      \"++MOVE origname newname     renames a file\\n\"\r\n      \"+or\\n\"\r\n      \"++MV   origname newname     renames a file\\n\"\r\n      \"2Creating Directories\\n\"\r\n#define HLP_MKDIR       \"*Commands Creating_Directories MKDIR\"\r\n      \"3MKDIR\\n\"\r\n      \"++MKDIR path                creates a directory\\n\"\r\n      \"2Deleting Directories\\n\"\r\n#define HLP_RMDIR       \"*Commands Deleting_Directories RMDIR\"\r\n      \"3RMDIR\\n\"\r\n      \"++RMDIR path                deleting a directory\\n\"\r\n#define HLP_SET         \"*Commands SET\"\r\n      \"2SET\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_SET_CONSOLE \"*Commands SET CONSOLE\"\r\n      \"3Console\\n\"\r\n      \"+SET CONSOLE arg{,arg...}    set console options\\n\"\r\n      \"+SET CONSOLE WRU=value       specify console drop to simh character\\n\"\r\n      \"+SET CONSOLE BRK=value       specify console Break character\\n\"\r\n      \"+SET CONSOLE DEL=value       specify console delete character\\n\"\r\n#if (defined(__GNUC__) && !defined(__OPTIMIZE__) && !defined(_WIN32))/* Debug build? */\r\n      \"+SET CONSOLE DBGINT=value    specify SIGINT character in debugger\\n\"\r\n#endif\r\n      \"+SET CONSOLE PCHAR=bitmask   bit mask of printable characters in\\n\"\r\n      \"++++++++                     range [31,0]\\n\"\r\n      \"+SET CONSOLE SPEED=speed{*factor}\\n\"\r\n      \"++++++++                     specify console input data rate\\n\"\r\n      \"+SET CONSOLE TELNET=port     specify console telnet port\\n\"\r\n      \"+SET CONSOLE TELNET=LOG=log_file\\n\"\r\n      \"++++++++                     specify console telnet logging to the\\n\"\r\n      \"++++++++                     specified destination {LOG,STDOUT,STDERR,\\n\"\r\n      \"++++++++                     DEBUG or filename)\\n\"\r\n      \"+SET CONSOLE TELNET=NOLOG    disables console telnet logging\\n\"\r\n      \"+SET CONSOLE TELNET=BUFFERED[=bufsize]\\n\"\r\n      \"++++++++                     specify console telnet buffering\\n\"\r\n      \"+SET CONSOLE TELNET=NOBUFFERED\\n\"\r\n      \"++++++++                     disables console telnet buffering\\n\"\r\n      \"+SET CONSOLE TELNET=UNBUFFERED\\n\"\r\n      \"++++++++                     disables console telnet buffering\\n\"\r\n      \"+SET CONSOLE NOTELNET        disable console telnet\\n\"\r\n      \"+SET CONSOLE TELNET=CONNECT  open a window running a telnet session\\n\"\r\n      \"++++++++                     to the simulator console\\n\"\r\n      \"+SET CONSOLE SERIAL=serialport[;config]\\n\"\r\n      \"++++++++                     specify console serial port and optionally\\n\"\r\n      \"++++++++                     the port config (i.e. ;9600-8n1)\\n\"\r\n      \"+SET CONSOLE NOSERIAL        disable console serial session\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_SET_REMOTE \"*Commands SET REMOTE\"\r\n      \"3Remote\\n\"\r\n      \"+SET REMOTE TELNET=port      specify remote console telnet port\\n\"\r\n      \"+SET REMOTE NOTELNET         disables remote console\\n\"\r\n      \"+SET REMOTE BUFFERSIZE=bufsize\\n\"\r\n      \"++++++++                     specify remote console command output buffer\\n\"\r\n      \"++++++++                     size\\n\"\r\n      \"+SET REMOTE CONNECTIONS=n    specify number of concurrent remote\\n\"\r\n      \"++++++++                     console sessions\\n\"\r\n      \"+SET REMOTE TIMEOUT=n        specify number of seconds without input\\n\"\r\n      \"++++++++                     before automatic continue\\n\"\r\n      \"+SET REMOTE MASTER           enable master mode remote console\\n\"\r\n      \"+SET REMOTE NOMASTER         disable remote master mode console\\n\"\r\n#define HLP_SET_DEFAULT \"*Commands SET Working_Directory\"\r\n      \"3Working Directory\\n\"\r\n      \"+SET DEFAULT <dir>           set the current directory\\n\"\r\n      \"+CD <dir>                    set the current directory\\n\"\r\n#define HLP_SET_LOG    \"*Commands SET Log\"\r\n      \"3Log\\n\"\r\n      \" Interactions with the simulator session (at the \\\"sim>\\\" prompt\\n\"\r\n      \" can be recorded to a log file\\n\\n\"\r\n      \"+SET LOG log_file            specify the log destination\\n\"\r\n      \"++++++++                     (STDOUT,DEBUG or filename)\\n\"\r\n      \"+SET NOLOG                   disables any currently active logging\\n\"\r\n      \"4Switches\\n\"\r\n      \" By default, log output is written at the end of the specified log file.\\n\"\r\n      \" A new log file can created if the -N switch is used on the command line.\\n\\n\"\r\n      \" By default, log output is written in text mode.  The log file can be\\n\"\r\n      \" opened for binary mode writing if the -B switch is used on the command line.\\n\"\r\n#define HLP_SET_DEBUG  \"*Commands SET Debug\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3Debug\\n\"\r\n      \"+SET DEBUG debug_file        specify the debug destination\\n\"\r\n      \"++++++++                     (STDOUT,STDERR,LOG or filename)\\n\"\r\n      \"+SET NODEBUG                 disables any currently active debug output\\n\"\r\n      \"4Switches\\n\"\r\n      \" Debug message output contains a timestamp which indicates the number of\\n\"\r\n      \" simulated %C which have been executed prior to the debug event.\\n\\n\"\r\n      \" Debug message output can be enhanced to contain additional, potentially\\n\"\r\n      \" useful information.\\n\"\r\n      \"5-T\\n\"\r\n      \" The -T switch causes debug output to contain a time of day displayed\\n\"\r\n      \" as hh:mm:ss.msec.\\n\"\r\n      \"5-A\\n\"\r\n      \" The -A switch causes debug output to contain a time of day displayed\\n\"\r\n      \" as seconds.msec.\\n\"\r\n      \"5-R\\n\"\r\n      \" The -R switch causes the time of day displayed due to the -T or -A\\n\"\r\n      \" switches to be relative to the start time of debugging.  If neither\\n\"\r\n      \" -T or -A is explicitly specified, -T is implied.\\n\"\r\n      \"5-P\\n\"\r\n      \" The -P switch adds the output of the PC (Program Counter) to each debug\\n\"\r\n      \" message.\\n\"\r\n      \"5-N\\n\"\r\n      \" The -N switch causes a new/empty file to be written to.  The default\\n\"\r\n      \" is to append to an existing debug log file.\\n\"\r\n      \"5-D\\n\"\r\n      \" The -D switch causes data blob output to also display the data as\\n\"\r\n      \" RADIX-50 characters.\\n\"\r\n      \"5-F\\n\"\r\n      \" The -F switch causes duplicate successive lines of debug NOT to be\\n\"\r\n      \" summarized to reduce repetitive noise from the debug data stream.\\n\"\r\n      \"5-E\\n\"\r\n      \" The -E switch causes data blob output to also display the data as\\n\"\r\n      \" EBCDIC characters.\\n\"\r\n      \"5-B\\n\"\r\n      \" The -B switch causes debug data output to be written to a circular\\n\"\r\n      \" buffer in memory.   This avoids the potential delays for disk I/O to\\n\"\r\n      \" and the disk storage that a long running debug might consume.\\n\"\r\n      \" The size of the circular memory buffer that is used is specified on\\n\"\r\n      \" the SET DEBUG command line, for example:\\n\\n\"\r\n      \"++SET DEBUG -B <sizeinMB> <debug-destination-file>\\n\\n\"\r\n      \" The buffered data is written to the specified destination file when\\n\"\r\n      \" control returns to the sim> prompt or every 30 seconds while the \\n\"\r\n      \" simulator is executing instructions.\\n\\n\"\r\n#define HLP_SET_BREAK  \"*Commands SET Breakpoints\"\r\n      \"3Breakpoints\\n\"\r\n      \"+SET BREAK <list>            set breakpoints\\n\"\r\n      \"+SET NOBREAK <list>          clear breakpoints\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_SET_THROTTLE \"*Commands SET Throttle\"\r\n      \"3Throttle\\n\"\r\n      \" Simulator instruction execution rate can be controlled by specifying\\n\"\r\n      \" one of the following throttle commands:\\n\\n\"\r\n      \"+SET THROTTLE x              execute x %C per second\\n\"\r\n      \"+SET THROTTLE xM             execute x million %C per second\\n\"\r\n      \"+SET THROTTLE xK             execute x thousand %C per second\\n\"\r\n      \"+SET THROTTLE x%%             occupy x percent of the host capacity\\n\"\r\n      \"++++++++executing instructions\\n\"\r\n      \"+SET THROTTLE x/t            sleep for t milliseconds after executing x\\n\"\r\n      \"++++++++%C\\n\\n\"\r\n      \"+SET NOTHROTTLE              set simulation rate to maximum\\n\\n\"\r\n      \" Throttling is only available on host systems that implement a precision\\n\"\r\n      \" real-time delay function.\\n\\n\"\r\n      \" xM, xK and x%% modes require the simulator to execute sufficient\\n\"\r\n      \" %C to actually calibrate the desired execution rate relative\\n\"\r\n      \" to wall clock time.  Very short running programs may complete before\\n\"\r\n      \" calibration completes and therefore before the simulated execution rate\\n\"\r\n      \" can match the desired rate.\\n\\n\"\r\n      \" The SET NOTHROTTLE command turns off throttling.  The SHOW THROTTLE\\n\"\r\n      \" command shows the current settings for throttling and the calibration\\n\"\r\n      \" results\\n\\n\"\r\n      \" Some simulators implement a different form of host CPU resource management\\n\"\r\n      \" called idling.  Idling suspends simulated execution whenever the program\\n\"\r\n      \" running in the simulator is doing nothing, and runs the simulator at full\\n\"\r\n      \" speed when there is work to do.  Throttling and idling are mutually\\n\"\r\n      \" exclusive.\\n\"\r\n#define HLP_SET_CLOCK \"*Commands SET Clock\"\r\n      \"3Clock\\n\"\r\n#if defined (SIM_ASYNCH_CLOCKS)\r\n      \"+SET CLOCK asynch            enable asynchronous clocks\\n\"\r\n      \"+SET CLOCK noasynch          disable asynchronous clocks\\n\"\r\n#endif\r\n      \"+SET CLOCK nocatchup         disable catchup clock ticks\\n\"\r\n      \"+SET CLOCK catchup           enable catchup clock ticks\\n\"\r\n      \"+SET CLOCK calib{=n%%}        specify idle calibration skip %%\\n\"\r\n      \"+SET CLOCK calib{=ALWAYS}    specify calibration independent of idle %%\\n\"\r\n      \"+SET CLOCK nocalib{=n{M/K}}  disable calibration\\n\"\r\n      \"+SET CLOCK base=YYYY/MM/DD-HH:MM:SS.MSEC\\n\"\r\n      \"++++++++                     set the base pseudo time\\n\"\r\n      \"++++++++                     when calibration is disabled\\n\"\r\n      \"+SET CLOCK stop=n            stop execution after n %C\\n\\n\"\r\n      \"4CALIBRATE\\n\"\r\n      \" The SET CLOCK CALIBRATE command enables clock tick calibration to\\n\"\r\n      \" dynamically align wall clock time, and optionally allows calibration\\n\"\r\n      \" to be skipped when idle percentage exceeds a specified value.\\n\"\r\n      \" Clock calibration to align clock ticks with wall clock time is\\n\"\r\n      \" initially enabled and calibration always happens.\\n\"\r\n      \"4NOCALIBRATE\\n\"\r\n      \" The SET CLOCK NOCALIBRATE command causes simulated clocks to appear\\n\"\r\n      \" to the simulated system as if it was running at a hard set rate\\n\"\r\n      \" without any relationship to wall clock time.  This mode may be useful\\n\"\r\n      \" when running diagnostics or test scripts which may expect certain\\n\"\r\n      \" behavior or compare simulation results to previouosly observed values.\\n\"\r\n      \" When running in NOCALIBRATE mode, clock ticks are presented to the\\n\"\r\n      \" simulated system after the appropriate number of %C that happened\\n\"\r\n      \" when running on real hardware.  In addition, these ticks will be issued\\n\"\r\n      \" precisely at the same rate from one execution run to the next.\\n\\n\"\r\n      \" When running in NOCALIBRATE mode, port speed pacing on telnet or serial\\n\"\r\n      \" connections will be affected and on serial connections data out any\\n\"\r\n      \" serial ports will likely get mangled.\\n\"\r\n      \"4BASE\\n\"\r\n      \" When running with calibration disabled, wall clock time within the\\n\"\r\n      \" simulator is not meaningfully related to the real wall clock time.\\n\"\r\n      \" Simulator devices may query what they believe to be the wall clock\\n\"\r\n      \" time what they get is the pseudo wall clock time that has transpired\\n\"\r\n      \" in the simulators current execution session.\\n\"\r\n      \" The SET CLOCK BASE=YYYY/MM/DD-HH:MM:SS.MSEC command exists to specify\\n\"\r\n      \" the base time that the devices access when running relative to the\\n\"\r\n      \" beginning of simulator instruction execution.\\n\"\r\n      \"4STOP\\n\"\r\n      \" The SET CLOCK STOP command allows execution to have a bound when\\n\"\r\n      \" execution starts with a BOOT, NEXT or CONTINUE command.\\n\"\r\n#define HLP_SET_ASYNCH \"*Commands SET Asynch\"\r\n      \"3Asynch\\n\"\r\n      \"+SET ASYNCH                  enable asynchronous I/O\\n\"\r\n      \"+SET NOASYNCH                disable asynchronous I/O\\n\"\r\n#define HLP_SET_ENVIRON \"*Commands SET Environment\"\r\n      \"3Environment\\n\"\r\n      \"4Explicitily Changing a Variable\\n\"\r\n      \"+SET ENVIRONMENT name=val    set environment variable\\n\"\r\n      \"+SET ENVIRONMENT name        clear environment variable\\n\"\r\n      \"4Arithmetic Computations into a Variable\\n\\n\"\r\n      \"+SET ENVIRONMENT -A name=expression\\n\\n\"\r\n      \" Expression can contain any of these C language operators:\\n\\n\"\r\n      \"++ (                  Open Parenthesis\\n\"\r\n      \"++ )                  Close Parenthesis\\n\"\r\n      \"++ -                  Subtraction\\n\"\r\n      \"++ +                  Addition\\n\"\r\n      \"++ *                  Multiplication\\n\"\r\n      \"++ /                  Division\\n\"\r\n      \"++ %%                  Modulus\\n\"\r\n      \"++ &&                 Logical AND\\n\"\r\n      \"++ ||                 Logical OR\\n\"\r\n      \"++ &                  Bitwise AND\\n\"\r\n      \"++ |                  Bitwise Inclusive OR\\n\"\r\n      \"++ ^                  Bitwise Exclusive OR\\n\"\r\n      \"++ >>                 Bitwise Right Shift\\n\"\r\n      \"++ <<                 Bitwise Left Shift\\n\"\r\n      \"++ ==                 Equality\\n\"\r\n      \"++ !=                 Inequality\\n\"\r\n      \"++ <=                 Less than or Equal\\n\"\r\n      \"++ <                  Less than\\n\"\r\n      \"++ >=                 Greater than or Equal\\n\"\r\n      \"++ >                  Greater than\\n\"\r\n      \"++ !                  Logical Negation\\n\"\r\n      \"++ ~                  Bitwise Compliment\\n\\n\"\r\n      \" Operator precedence is consistent with C language precedence.\\n\\n\"\r\n      \" Expression can contain arbitrary combinations of constant\\n\"\r\n      \" values, simulator registers and environment variables \\n\"\r\n      \"5Examples:\\n\"\r\n      \"++SET ENV -A A=7+2\\n\"\r\n      \"++SET ENV -A A=A-1\\n\"\r\n      \"++ECHO A=%%A%%\\n\"\r\n      \"++A=8\\n\"\r\n      \"4Gathering Input From A User\\n\"\r\n      \" Input from a user can be obtained by:\\n\\n\"\r\n      \"+set environment -P \\\"Prompt String\\\" name=default\\n\\n\"\r\n      \" The -P switch indicates that the user should be prompted\\n\"\r\n      \" with the indicated prompt string and the input provided\\n\"\r\n      \" will be saved in the environment variable 'name'.  If no\\n\"\r\n      \" input is provided, the value specified as 'default' will be\\n\"\r\n      \" used.\\n\"\r\n#define HLP_SET_ON      \"*Commands SET Command_Status_Trap_Dispatching\"\r\n      \"3Command Status Trap Dispatching\\n\"\r\n      \"+SET ON                      enables error checking after command\\n\"\r\n      \"++++++++                     execution\\n\"\r\n      \"+SET NOON                    disables error checking after command\\n\"\r\n      \"++++++++                     execution\\n\"\r\n      \"+SET ON INHERIT              enables inheritance of ON state and\\n\"\r\n      \"++++++++                     actions into do command files\\n\"\r\n      \"+SET ON NOINHERIT            disables inheritance of ON state and\\n\"\r\n      \"++++++++                     actions into do command files\\n\"\r\n#define HLP_SET_VERIFY \"*Commands SET Command_Execution_Display\"\r\n#define HLP_SET_VERIFY \"*Commands SET Command_Execution_Display\"\r\n      \"3Command Execution Display\\n\"\r\n      \"+SET VERIFY                  re-enables display of command file\\n\"\r\n      \"++++++++                     processed commands\\n\"\r\n      \"+SET VERBOSE                 re-enables display of command file\\n\"\r\n      \"++++++++                     processed commands\\n\"\r\n      \"+SET NOVERIFY                disables display of command file processed\\n\"\r\n      \"++++++++                     commands\\n\"\r\n      \"+SET NOVERBOSE               disables display of command file processed\\n\"\r\n      \"++++++++                     commands\\n\"\r\n#define HLP_SET_MESSAGE \"*Commands SET Command_Error_Status_Display\"\r\n      \"3Command Error Status Display\\n\"\r\n      \"+SET MESSAGE                 re-enables display of command file error\\n\"\r\n      \"++++++++                     messages\\n\"\r\n      \"+SET NOMESSAGE               disables display of command file error\\n\"\r\n      \"++++++++                     messages\\n\"\r\n#define HLP_SET_QUIET \"*Commands SET Command_Output_Display\"\r\n      \"3Command Output Display\\n\"\r\n      \"+SET QUIET                   disables suppression of some output and\\n\"\r\n      \"++++++++                     messages\\n\"\r\n      \"+SET NOQUIET                 re-enables suppression of some output and\\n\"\r\n      \"++++++++                     messages\\n\"\r\n#define HLP_SET_PROMPT \"*Commands SET Command_Prompt\"\r\n      \"3Command Prompt\\n\"\r\n      \"+SET PROMPT \\\"string\\\"        sets an alternate simulator prompt string\\n\"\r\n      \"3Device and Unit\\n\"\r\n      \"+SET <dev> OCT|DEC|HEX|BIN   set device display radix\\n\"\r\n      \"+SET <dev> ENABLED           enable device\\n\"\r\n      \"+SET <dev> DISABLED          disable device\\n\"\r\n      \"+SET <dev> DEBUG{=arg}       set device debug flags\\n\"\r\n      \"+SET <dev> NODEBUG={arg}     clear device debug flags\\n\"\r\n      \"+SET <dev> arg{,arg...}      set device parameters (see show modifiers)\\n\"\r\n      \"+SET <unit> ENABLED          enable unit\\n\"\r\n      \"+SET <unit> DISABLED         disable unit\\n\"\r\n      \"+SET <unit> arg{,arg...}     set unit parameters (see show modifiers)\\n\"\r\n      \"+HELP <dev> SET              displays the device specific set commands\\n\"\r\n      \"++++++++                     available\\n\"\r\n#define HLP_NOAUTOSIZE  \"*Commands SET NoAutosize\"\r\n      \"3NoAutosize\\n\"\r\n      \"+SET NOAUTOSIZE              disables disk autosizing for all disks\\n\"\r\n      \"++++++++                     in the simulator which support multiple\\n\"\r\n      \"++++++++                     drive types or sizes\\n\"\r\n      \"+SET <unit> NOAUTOSIZE       disables disk autosizing for a specific\\n\"\r\n      \"++++++++                     unit in the simulator that supports\\n\"\r\n      \"++++++++                     different drive types or sizes\\n\"\r\n      \"+SET AUTOSIZE                enables disk autosizing for all disks\\n\"\r\n      \"++++++++                     in the simulator which support multiple\\n\"\r\n      \"++++++++                     drive types or sizes\\n\"\r\n      \"+SET <unit> AUTOSIZE         enables disk autosizing for a specific\\n\"\r\n      \"++++++++                     unit in the simulator that supports\\n\"\r\n      \"++++++++                     different drive types or sizes\\n\"\r\n#define HLP_AUTOZAP     \"*Commands SET Autozap\"\r\n      \"3Autozap\\n\"\r\n      \"+SET AUTOZAP                 enables automatic metadata removal on\\n\"\r\n      \"++++++++                     detach for all disks with metadata\\n\"\r\n      \"++++++++                     capabilities in the simulator\\n\"\r\n      \"+SET <unit> AUTOZAP          enables automatic metadata removal on\\n\"\r\n      \"++++++++                     detach for a specific unit in the simulator\\n\"\r\n      \"+SET <unit> NOAUTOZAP        disables automatic metadata removal on\\n\"\r\n      \"++++++++                     detach for a specific unit in the simulator\\n\";\r\nstatic const char simh_help2[] =\r\n      /***************** 80 character line width template *************************/\r\n#define HLP_SHOW        \"*Commands SHOW\"\r\n      \"2SHOW\\n\"\r\n      \"+sh{ow} {-c} br{eak} <list>   show breakpoints\\n\"\r\n      \"+sh{ow} {-ei} con{figuration} show configuration\\n\"\r\n      \"+sh{ow} cons{ole} {arg}       show console options\\n\"\r\n      \"+sh{ow} {-ei} dev{ices}       show devices\\n\"\r\n      \"+sh{ow} {-ei} fea{tures}      show system devices with descriptions\\n\"\r\n      \"+sh{ow} m{odifiers}           show modifiers for all devices\\n\"\r\n      \"+sh{ow} s{how}                show SHOW commands for all devices\\n\"\r\n      \"+sh{ow} n{ames}               show logical names\\n\"\r\n      \"+sh{ow} q{ueue}               show event queue\\n\"\r\n      \"+sh{ow} ti{me}                show simulated time\\n\"\r\n      \"+sh{ow} th{rottle}            show simulation rate\\n\"\r\n      \"+sh{ow} a{synch}              show asynchronous I/O state\\n\"\r\n      \"+sh{ow} ve{rsion}             show simulator version\\n\"\r\n      \"+sh{ow} def{ault}             show current directory\\n\"\r\n      \"+sh{ow} re{mote}              show remote console configuration\\n\"\r\n      \"+sh{ow} <dev> RADIX           show device display radix\\n\"\r\n      \"+sh{ow} <dev> DEBUG           show device debug flags\\n\"\r\n      \"+sh{ow} <dev> MODIFIERS       show device modifiers\\n\"\r\n      \"+sh{ow} <dev> NAMES           show device logical name\\n\"\r\n      \"+sh{ow} <dev> SHOW            show device SHOW commands\\n\"\r\n      \"+sh{ow} <dev> {arg,...}       show device parameters\\n\"\r\n      \"+sh{ow} <unit> {arg,...}      show unit parameters\\n\"\r\n      \"+sh{ow} ethernet              show ethernet devices\\n\"\r\n      \"+sh{ow} serial                show serial devices\\n\"\r\n      \"+sh{ow} synchronous           show DDCMP synchronous interface devices\\n\"\r\n      \"+sh{ow} multiplexer {dev}     show open multiplexer device info\\n\"\r\n      \"+sh{ow} video                 show video capabilities\\n\"\r\n      \"+sh{ow} clocks                show calibrated timer information\\n\"\r\n      \"+sh{ow} throttle              show throttle info\\n\"\r\n      \"+sh{ow} on                    show on condition actions\\n\"\r\n      \"+sh{ow} do                    show do nesting state\\n\"\r\n      \"+sh{ow} runlimit              show execution limit states\\n\"\r\n      \"+h{elp} <dev> show            displays the device specific show commands\\n\"\r\n      \"++++++++                      available\\n\"\r\n#define HLP_SHOW_CONFIG         \"*Commands SHOW\"\r\n#define HLP_SHOW_DEVICES        \"*Commands SHOW\"\r\n#define HLP_SHOW_FEATURES       \"*Commands SHOW\"\r\n#define HLP_SHOW_QUEUE          \"*Commands SHOW\"\r\n#define HLP_SHOW_TIME           \"*Commands SHOW\"\r\n#define HLP_SHOW_MODIFIERS      \"*Commands SHOW\"\r\n#define HLP_SHOW_NAMES          \"*Commands SHOW\"\r\n#define HLP_SHOW_SHOW           \"*Commands SHOW\"\r\n#define HLP_SHOW_VERSION        \"*Commands SHOW\"\r\n#define HLP_SHOW_DEFAULT        \"*Commands SHOW\"\r\n#define HLP_SHOW_CONSOLE        \"*Commands SHOW\"\r\n#define HLP_SHOW_REMOTE         \"*Commands SHOW\"\r\n#define HLP_SHOW_BREAK          \"*Commands SHOW\"\r\n#define HLP_SHOW_LOG            \"*Commands SHOW\"\r\n#define HLP_SHOW_DEBUG          \"*Commands SHOW\"\r\n#define HLP_SHOW_THROTTLE       \"*Commands SHOW\"\r\n#define HLP_SHOW_ASYNCH         \"*Commands SHOW\"\r\n#define HLP_SHOW_ETHERNET       \"*Commands SHOW\"\r\n#define HLP_SHOW_SERIAL         \"*Commands SHOW\"\r\n#define HLP_SHOW_SYNC           \"*Commands SHOW\"\r\n#define HLP_SHOW_MULTIPLEXER    \"*Commands SHOW\"\r\n#define HLP_SHOW_VIDEO          \"*Commands SHOW\"\r\n#define HLP_SHOW_CLOCKS         \"*Commands SHOW\"\r\n#define HLP_SHOW_ON             \"*Commands SHOW\"\r\n#define HLP_SHOW_DO             \"*Commands SHOW\"\r\n#define HLP_SHOW_RUNLIMIT       \"*Commands SHOW\"\r\n#define HLP_SHOW_SEND           \"*Commands SHOW\"\r\n#define HLP_SHOW_EXPECT         \"*Commands SHOW\"\r\n#define HLP_HELP                \"*Commands HELP\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2HELP\\n\"\r\n      \"+h{elp}                      type this message\\n\"\r\n      \"+h{elp} <command>            type help for command\\n\"\r\n      \"+h{elp} <dev>                type help for device\\n\"\r\n      \"+h{elp} <dev> registers      type help for device register variables\\n\"\r\n      \"+h{elp} <dev> attach         type help for device specific ATTACH command\\n\"\r\n      \"+h{elp} <dev> set            type help for device specific SET commands\\n\"\r\n      \"+h{elp} <dev> show           type help for device specific SHOW commands\\n\"\r\n      \"+h{elp} <dev> <command>      type help for device specific <command> command\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"2Altering The Simulated Configuration\\n\"\r\n      \" In most simulators, the SET <device> DISABLED command removes the\\n\"\r\n      \" specified device from the configuration.  A DISABLED device is invisible\\n\"\r\n      \" to running programs.  The device can still be RESET, but it cannot be\\n\"\r\n      \" ATTAChed, DETACHed, or BOOTed.  SET <device> ENABLED restores a disabled\\n\"\r\n      \" device to a configuration.\\n\\n\"\r\n      \" Most multi-unit devices allow units to be enabled or disabled:\\n\\n\"\r\n      \"++SET <unit> ENABLED\\n\"\r\n      \"++SET <unit> DISABLED\\n\\n\"\r\n      \" When a unit is disabled, it will not be displayed by SHOW DEVICE.\\n\\n\"\r\n#define HLP_ASSIGN      \"*Commands Logical_Names\"\r\n#define HLP_DEASSIGN    \"*Commands Logical_Names\"\r\n      \"2Logical Names\\n\"\r\n      \" The standard device names can be supplemented with logical names.  Logical\\n\"\r\n      \" names must be unique within a simulator (that is, they cannot be the same\\n\"\r\n      \" as an existing device or logical name).  To assign a logical name to a\\n\"\r\n      \" device or unit:\\n\\n\"\r\n      \"++ASSIGN <device>|<unit> <log-name>   assign log-name to device\\n\\n\"\r\n      \" To remove a logical name:\\n\\n\"\r\n      \"++DEASSIGN <device>|<unit>            remove logical name\\n\\n\"\r\n      \" To show the current logical name assignment:\\n\\n\"\r\n      \"++SHOW <device> NAMES                 show logical name, if any\\n\\n\"\r\n      \" To show all logical names:\\n\\n\"\r\n      \"++SHOW NAMES\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_DO          \"*Commands Executing_Command_Files\"\r\n      \"2Executing Command Files\\n\"\r\n      \" The simulator can execute command files with the DO command:\\n\\n\"\r\n      \"++DO <filename> {arguments...}       execute commands in file\\n\\n\"\r\n      \" The DO command allows command files to contain substitutable arguments.\\n\"\r\n      \" The string %%n, where n is between 1 and 9, is replaced with argument n\\n\"\r\n      \" from the DO command line. The string %%0 is replaced with <filename>.\\n\"\r\n      \" The string %%* is replaced by the whole set of arguments (%%1 ... %%9).\\n\"\r\n      \" The sequences \\\\%% and \\\\\\\\ are replaced with the literal characters %% and \\\\,\\n\"\r\n      \" respectively.  Arguments with spaces can be enclosed in matching single\\n\"\r\n      \" or double quotation marks.\\n\\n\"\r\n      \" DO commands may be nested up to ten invocations deep.\\n\\n\"\r\n      \"3Switches\\n\"\r\n      \" If the switch -v is specified, the commands in the file are echoed before\\n\"\r\n      \" they are executed.\\n\\n\"\r\n      \" If the switch -e is specified, command processing (including nested command\\n\"\r\n      \" invocations) will be aborted if a command error is encountered.\\n\"\r\n      \" (Simulation stop never abort processing; use ASSERT to catch unexpected\\n\"\r\n      \" stops.)  Without the switch, all errors except ASSERT failures will be\\n\"\r\n      \" ignored, and command processing will continue.\\n\\n\"\r\n      \" If the switch -o is specified, the on conditions and actions from the\\n\"\r\n      \" calling command file will be inherited in the command file being invoked.\\n\"\r\n      \" If the switch -q is specified, the quiet mode will be explicitly enabled\\n\"\r\n      \" for the called command file, otherwise quiet mode is inherited from the\\n\"\r\n      \" calling context.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3Variable_Insertion\\n\"\r\n      \" Built In variables %%DATE%%, %%TIME%%, %%DATETIME%%, %%LDATE%%, %%LTIME%%,\\n\"\r\n      \" %%CTIME%%, %%DATE_YYYY%%, %%DATE_YY%%, %%DATE_YC%%, %%DATE_MM%%, %%DATE_MMM%%,\\n\"\r\n      \" %%DATE_MONTH%%, %%DATE_DD%%, %%DATE_D%%, %%DATE_WYYYY%%, %%DATE_WW%%,\\n\"\r\n      \" %%TIME_HH%%, %%TIME_MM%%, %%TIME_SS%%, %%TIME_MSEC%%, %%STATUS%%, %%TSTATUS%%,\\n\"\r\n      \" %%SIM_VERIFY%%, %%SIM_QUIET%%, %%SIM_MESSAGE%%, %%SIM_NAME%%, %%SIM_BIN_NAME%%,\\n\"\r\n      \" %%SIM_BIN_PATH%%, %%SIM_OSTYPE%%, %%SIM_RUNTIME%%, %%SIM_RUNTIME_UNITS%%,\\n\"\r\n      \" %%SIM_ASYNC_EVENTS%%, %%SIM_PROCESSED_EVENTS%%, %%SIM_REGEX_TYPE%%,\\n\"\r\n      \" %%SIM_MAJOR%%, %%SIM_MINOR%%, %%SIM_PATCH%%, %%SIM_DELTA%%,\\n\"\r\n      \" %%SIM_VM_RELEASE%%, %%SIM_VERSION_MODE%%, %%SIM_GIT_COMMIT_ID%%,\\n\"\r\n      \" %%SIM_GIT_COMMIT_TIME%%, %%SIM_ARCHIVE_GIT_COMMIT_ID%%,\\n\"\r\n      \" %%SIM_ARCHIVE_GIT_COMMIT_TIME%%, %%SIM_RUNLIMIT%%, %%SIM_RUNLIMIT_UNITS%%,\\n\"\r\n      \" %%SIM_HOST_CORE_COUNT%%, %%SIM_HOST_MAX_THREADS%%\\n\\n\"\r\n      \"+Token %%0 expands to the command file name.\\n\"\r\n      \"+Token %%n (n being a single digit) expands to the n'th argument\\n\"\r\n      \"+Token %%* expands to the whole set of arguments (%%1 ... %%9)\\n\\n\"\r\n      \"+The input sequence \\\"%%%%\\\" represents a literal \\\"%%\\\".  All other\\n\"\r\n      \"+character combinations are rendered literally.\\n\\n\"\r\n      \"+Omitted parameters result in null-string substitutions.\\n\\n\"\r\n      \"+Tokens preceded and followed by %% characters are expanded as\\n\"\r\n      \"+environment variables, and if an environment variable isn't found then\\n\"\r\n      \"+it can be one of several special variables:\\n\\n\"\r\n      \"++%%DATE%%                 yyyy-mm-dd\\n\"\r\n      \"++%%TIME%%                 hh:mm:ss\\n\"\r\n      \"++%%DATETIME%%             yyyy-mm-ddThh:mm:ss\\n\"\r\n      \"++%%LDATE%%                mm/dd/yy (Locale Formatted)\\n\"\r\n      \"++%%LTIME%%                hh:mm:ss am/pm (Locale Formatted)\\n\"\r\n      \"++%%CTIME%%                Www Mmm dd hh:mm:ss yyyy (Locale\\n\"\r\n      \"+++++++++++      Formatted)\\n\"\r\n      \"++%%UTIME%%                nnnn (Unix time - seconds since\\n\"\r\n      \"+++++++++++      1/1/1970)\\n\"\r\n      \"++%%DATE_YYYY%%            yyyy        (0000-9999)\\n\"\r\n      \"++%%DATE_YY%%              yy          (00-99)\\n\"\r\n      \"++%%DATE_MM%%              mm          (01-12)\\n\"\r\n      \"++%%DATE_MMM%%             mmm         (JAN-DEC)\\n\"\r\n      \"++%%DATE_MONTH%%           month       (January-December)\\n\"\r\n      \"++%%DATE_DD%%              dd          (01-31)\\n\"\r\n      \"++%%DATE_WW%%              ww          (01-53)     ISO 8601\\n\"\r\n      \"+++++++++++      week number\\n\"\r\n      \"++%%DATE_WYYYY%%           yyyy        (0000-9999) ISO 8601\\n\"\r\n      \"+++++++++++      week year number\\n\"\r\n      \"++%%DATE_D%%               d           (1-7)       ISO 8601\\n\"\r\n      \"+++++++++++      day of week\\n\"\r\n      \"++%%DATE_JJJ%%             jjj         (001-366) day of year\\n\"\r\n      \"++%%DATE_19XX_YY%%         yy          A year prior to 2000\\n\"\r\n      \"+++++++++++      with the same calendar\\n\"\r\n      \"+++++++++++      days as the current year\\n\"\r\n      \"++%%DATE_19XX_YYYY%%       yyyy        A year prior to 2000\\n\"\r\n      \"+++++++++++      with the same calendar days\\n\"\r\n      \"+++++++++++      as the current year\\n\"\r\n      \"++%%TIME_HH%%              hh          (00-23)\\n\"\r\n      \"++%%TIME_MM%%              mm          (00-59)\\n\"\r\n      \"++%%TIME_SS%%              ss          (00-59)\\n\"\r\n      \"++%%TIME_MSEC%%            msec        (000-999)\\n\"\r\n      \"++%%STATUS%%               Status value from the last command executed\\n\"\r\n      \"++%%TSTATUS%%              The text form of the last status value\\n\"\r\n      \"++%%SIM_VERIFY%%           The Verify/Verbose mode of the current Do\\n\"\r\n      \"++++++++      command file\\n\"\r\n      \"++%%SIM_VERBOSE%%          The Verify/Verbose mode of the current Do\\n\"\r\n      \"++++++++      command file\\n\"\r\n      \"++%%SIM_QUIET%%            The Quiet mode of the current Do command\\n\"\r\n      \"++++++++      file\\n\"\r\n      \"++%%SIM_MESSAGE%%          The message display status of the current\\n\"\r\n      \"++++++++      Do command file\\n\"\r\n      \"++%%SIM_NAME%%             The name of the current simulator\\n\"\r\n      \"++%%SIM_BIN_NAME%%         The program name of the current simulator\\n\"\r\n      \"++%%SIM_BIN_PATH%%         The program path that invoked the current\\n\"\r\n      \"++++++++      simulator\\n\"\r\n      \"++%%SIM_OSTYPE%%           The Operating System running the current\\n\"\r\n      \"++++++++      simulator\\n\"\r\n      \"++%%SIM_RUNTIME%%          The Number of simulated instructions or\\n\"\r\n      \"++++++++      cycles performed\\n\"\r\n      \"++%%SIM_RUNTIME_UNITS%%    The units of the SIM_RUNTIME value\\n\"\r\n      \"++%%SIM_PROCESSED_EVENTS%% The Number of events performed\\n\"\r\n      \"++%%SIM_ASYNC_EVENTS%%     The Number of Asynchronous events performed\\n\"\r\n      \"++%%SIM_REGEX_TYPE%%       The regular expression type available\\n\"\r\n      \"++%%SIM_MAJOR%%            The major portion of the simh version\\n\"\r\n      \"++%%SIM_MINOR%%            The minor portion of the simh version\\n\"\r\n      \"++%%SIM_PATCH%%            The patch portion of the simh version\\n\"\r\n      \"++%%SIM_DELTA%%            The delta portion of the simh version\\n\"\r\n      \"++%%SIM_VM_RELEASE%%       An optional VM specific release version\\n\"\r\n      \"++%%SIM_VERSION_MODE%%     The release mode (Current, Alpha, Beta)\\n\"\r\n      \"++%%SIM_GIT_COMMIT_ID%%    The git commit id of the current build\\n\"\r\n      \"++%%SIM_GIT_COMMIT_TIME%%  The git commit time of the current build\\n\"\r\n      \"++%%SIM_RUNLIMIT%%         The current execution limit defined\\n\"\r\n      \"++%%SIM_RUNLIMIT_UNITS%%   The units of the SIM_RUNLIMIT value\\n\"\r\n      \"++++++++       (instructions, cycles or time)\\n\"\r\n      \"++%%SIM_HOST_CORE_COUNT%%  The number of CPU cores on the host\\n\"\r\n      \"++%%SIM_HOST_MAX_THREADS%% The maximum number of possible host threads\\n\\n\"\r\n      \"+Environment variable lookups are done first with the precise name\\n\"\r\n      \"+between the %% characters and if that fails, then the name between\\n\"\r\n      \"+the %% characters is upcased and a lookup of that value is attempted.\\n\\n\"\r\n      \"+The first Space delimited token on a sim> command line is extracted\\n\"\r\n      \"+in uppercase and then looked up as an environment variable.  If found\\n\"\r\n      \"+it the value is substituted for the original string before expanding\\n\"\r\n      \"+everything else.  If it is not found, then the original beginning\\n\"\r\n      \"+token on the line is left untouched.\\n\\n\"\r\n      \"+Environment variable string substitution:\\n\\n\"\r\n      \"++%%XYZ:str1=str2%%\\n\\n\"\r\n      \"+would expand the XYZ environment variable, substituting each occurrence\\n\"\r\n      \"+of \\\"str1\\\" in the expanded result with \\\"str2\\\".  \\\"str2\\\" can be the empty\\n\"\r\n      \"+string to effectively delete all occurrences of \\\"str1\\\" from the\\n\"\r\n      \"+expanded output.  \\\"str1\\\" can begin with an asterisk, in which case it\\n\"\r\n      \"+will match everything from the beginning of the expanded output to the\\n\"\r\n      \"+first occurrence of the remaining portion of str1.\\n\\n\"\r\n      \"+May also specify substrings for an expansion.\\n\\n\"\r\n      \"++%%XYZ:~10,5%%\\n\\n\"\r\n      \"+would expand the XYZ environment variable, and then use only the 5\\n\"\r\n      \"+characters that begin at the 11th (offset 10) character of the expanded\\n\"\r\n      \"+result.  If the length is not specified, then it defaults to the\\n\"\r\n      \"+remainder of the variable value.  If either number (offset or length)\\n\"\r\n      \"+is negative, then the number used is the length of the environment\\n\"\r\n      \"+variable value added to the offset or length specified.\\n\\n\"\r\n      \"++%%XYZ:~-10%%\\n\\n\"\r\n      \"+would extract the last 10 characters of the XYZ variable.\\n\\n\"\r\n      \"++%%XYZ:~0,-2%%\\n\\n\"\r\n      \"+would extract all but the last 2 characters of the XYZ variable.\\n\"\r\n      \"4Parameter and Environment Variable File Parsing\\n\"\r\n      \" The value of environment variables can be parsed as filenames\\n\"\r\n      \" and have their values be expanded to full paths and/or into pieces.\\n\"\r\n      \" Parsing and expansion of file names.\\n\\n\"\r\n      \"++%%~I%%     - expands the value of %%I%% removing any surrounding\\n\"\r\n      \"+++++       quotes (\\\")\\n\"\r\n      \"++%%~fI%%    - expands the value of %%I%% to a fully qualified path name\\n\"\r\n      \"++%%~pI%%    - expands the value of %%I%% to a path only\\n\"\r\n      \"++%%~nI%%    - expands the value of %%I%% to a file name only\\n\"\r\n      \"++%%~xI%%    - expands the value of %%I%% to a file extension only\\n\\n\"\r\n      \"++%%~tI%%    - expands the value of %%I%% to date/time of file\\n\\n\"\r\n      \"++%%~zI%%    - expands the value of %%I%% to size of file\\n\\n\"\r\n      \" The modifiers can be combined to get compound results:\\n\\n\"\r\n      \"++%%~pnI%%   - expands the value of %%I%% to a path and name only\\n\"\r\n      \"++%%~nxI%%   - expands the value of %%I%% to a file name and extension\\n\"\r\n      \"+++++       only\\n\\n\"\r\n      \" In the above example above %%I%% can be replaced by other\\n\"\r\n      \" environment variables or numeric parameters to a DO command\\n\"\r\n      \" invocation.\\n\"\r\n      \" Examples:\\n\\n\"\r\n      \"++sim> set env FNAME='xyzzy.ini'\\n\"\r\n      \"++sim> echo ~FNAME=%%~FNAME%%\\n\"\r\n      \"++xyzzy.ini\\n\"\r\n      \"++sim> echo ~fFNAME=%%~fFNAME%%\\n\"\r\n      \"++~fFNAME=/home/user/xyzzy.ini\\n\"\r\n      \"++sim> echo ~nxFNAME=%%~nxFNAME%%\\n\"\r\n      \"++~nxFNAME=xyzzy.ini\\n\"\r\n      \"++sim> echo ~fFNAME=%%~pnFNAME%%\\n\"\r\n      \"++~pnFNAME=/home/user/xyzzy\\n\\n\"\r\n#define HLP_GOTO        \"*Commands Executing_Command_Files GOTO\"\r\n      \"3GOTO\\n\"\r\n      \" Commands in a command file execute in sequence until either an error\\n\"\r\n      \" trap occurs (when a command completes with an error status), or when an\\n\"\r\n      \" explicit request is made to start command execution elsewhere with the\\n\"\r\n      \" GOTO command:\\n\\n\"\r\n      \"++GOTO <label>\\n\\n\"\r\n      \" Labels are lines in a command file which the first non whitespace\\n\"\r\n      \" character is a \\\":\\\".  The target of a goto is the first matching label\\n\"\r\n      \" in the current do command file which is encountered.  Since labels\\n\"\r\n      \" don't do anything else besides being the targets of goto's, they could\\n\"\r\n      \" also be used to provide comments in do command files.\\n\\n\"\r\n      \"++GOTO :EOF\\n\\n\"\r\n      \" The target label of :EOF is explicitly defined to mean the end of the\\n\"\r\n      \" DO command file.  This will cause the execution to return from the current\\n\"\r\n      \" command file.\\n\\n\"\r\n      \"4Examples\\n\\n\"\r\n      \"++:: This is a comment\\n\"\r\n      \"++echo Some Message to Output\\n\"\r\n      \"++:Target\\n\"\r\n      \"++:: This is a comment\\n\"\r\n      \"++GOTO Target\\n\\n\"\r\n#define HLP_RETURN      \"*Commands Executing_Command_Files RETURN\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3RETURN\\n\"\r\n      \" The RETURN command causes the current procedure call to be restored to the\\n\"\r\n      \" calling context, possibly returning a specific return status.\\n\"\r\n      \" If no return status is specified, the return status from the last command\\n\"\r\n      \" executed will be returned.  The calling context may have ON traps defined\\n\"\r\n      \" which may redirect command flow in that context.\\n\\n\"\r\n      \"++return                   return from command file with last command status\\n\"\r\n      \"++return {-Q} <status>     return from command file with specific status\\n\\n\"\r\n      \" The status return can be any numeric value or one of the standard SCPE_\\n\"\r\n      \" condition names.\\n\\n\"\r\n      \" The -Q switch on the RETURN command will cause the specified status to\\n\"\r\n      \" be returned, but normal error status message printing to be suppressed.\\n\"\r\n      \"4Condition Names\\n\"\r\n      \" The available standard SCPE_ condition names are\\n\"\r\n      \"5 NXM\\n\"\r\n      \" Address space exceeded\\n\"\r\n      \"5 UNATT\\n\"\r\n      \" Unit not attached\\n\"\r\n      \"5 IOERR\\n\"\r\n      \" I/O error\\n\"\r\n      \"5 CSUM\\n\"\r\n      \" Checksum error\\n\"\r\n      \"5 FMT\\n\"\r\n      \" Format error\\n\"\r\n      \"5 NOATT\\n\"\r\n      \" Unit not attachable\\n\"\r\n      \"5 OPENERR\\n\"\r\n      \" File open error\\n\"\r\n      \"5 MEM\\n\"\r\n      \" Memory exhausted\\n\"\r\n      \"5 ARG\\n\"\r\n      \" Invalid argument\\n\"\r\n      \"5 STEP\\n\"\r\n      \" Step expired\\n\"\r\n      \"5 UNK\\n\"\r\n      \" Unknown command\\n\"\r\n      \"5 RO\\n\"\r\n      \" Read only argument\\n\"\r\n      \"5 INCOMP\\n\"\r\n      \" Command not completed\\n\"\r\n      \"5 STOP\\n\"\r\n      \" Simulation stopped\\n\"\r\n      \"5 EXIT\\n\"\r\n      \" Goodbye\\n\"\r\n      \"5 TTIERR\\n\"\r\n      \" Console input I/O error\\n\"\r\n      \"5 TTOERR\\n\"\r\n      \" Console output I/O error\\n\"\r\n      \"5 EOF\\n\"\r\n      \" End of file\\n\"\r\n      \"5 REL\\n\"\r\n      \" Relocation error\\n\"\r\n      \"5 NOPARAM\\n\"\r\n      \" No settable parameters\\n\"\r\n      \"5 ALATT\\n\"\r\n      \" Unit already attached\\n\"\r\n      \"5 TIMER\\n\"\r\n      \" Hardware timer error\\n\"\r\n      \"5 SIGERR\\n\"\r\n      \" Signal handler setup error\\n\"\r\n      \"5 TTYERR\\n\"\r\n      \" Console terminal setup error\\n\"\r\n      \"5 NOFNC\\n\"\r\n      \" Command not allowed\\n\"\r\n      \"5 UDIS\\n\"\r\n      \" Unit disabled\\n\"\r\n      \"5 NORO\\n\"\r\n      \" Read only operation not allowed\\n\"\r\n      \"5 INVSW\\n\"\r\n      \" Invalid switch\\n\"\r\n      \"5 MISVAL\\n\"\r\n      \" Missing value\\n\"\r\n      \"5 2FARG\\n\"\r\n      \" Too few arguments\\n\"\r\n      \"5 2MARG\\n\"\r\n      \" Too many arguments\\n\"\r\n      \"5 NXDEV\\n\"\r\n      \" Non-existent device\\n\"\r\n      \"5 NXUN\\n\"\r\n      \" Non-existent unit\\n\"\r\n      \"5 NXREG\\n\"\r\n      \" Non-existent register\\n\"\r\n      \"5 NXPAR\\n\"\r\n      \" Non-existent parameter\\n\"\r\n      \"5 NEST\\n\"\r\n      \" Nested DO command limit exceeded\\n\"\r\n      \"5 IERR\\n\"\r\n      \" Internal error\\n\"\r\n      \"5 MTRLNT\\n\"\r\n      \" Invalid magtape record length\\n\"\r\n      \"5 LOST\\n\"\r\n      \" Console Telnet connection lost\\n\"\r\n      \"5 TTMO\\n\"\r\n      \" Console Telnet connection timed out\\n\"\r\n      \"5 STALL\\n\"\r\n      \" Console Telnet output stall\\n\"\r\n      \"5 AFAIL\\n\"\r\n      \" Assertion failed\\n\"\r\n      \"5 INVREM\\n\"\r\n      \" Invalid remote console command\\n\"\r\n      \"5 AMBREG\\n\"\r\n      \" Ambiguous register\\n\"\r\n      \"5 RUNTIME\\n\"\r\n      \" Run time limit exhausted\\n\"\r\n#define HLP_SHIFT       \"*Commands Executing_Command_Files SHIFT\"\r\n      \"3SHIFT\\n\"\r\n      \"++shift                    shift the command file's positional parameters\\n\"\r\n#define HLP_CALL        \"*Commands Executing_Command_Files CALL\"\r\n      \"3CALL\\n\"\r\n      \"++call                     transfer control to a labeled subroutine\\n\"\r\n      \"                         a command file.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_ON          \"*Commands Executing_Command_Files Error_Trapping\"\r\n      \"3Error Trapping\\n\"\r\n      \" Error traps can be taken when any command returns a non success status.\\n\"\r\n      \" Actions to be performed for particular status returns are specified with\\n\"\r\n      \" the ON command.\\n\"\r\n      \"4Enabling Error Traps\\n\"\r\n      \" Error trapping is enabled with:\\n\\n\"\r\n      \"++set on                   enable error traps\\n\\n\"\r\n      \"4Disabling Error Traps\\n\"\r\n      \" Error trapping is disabled with:\\n\\n\"\r\n      \"++set noon                 disable error traps\\n\\n\"\r\n      \" Disables error traps for the currently running command file.\\n\\n\"\r\n      \"4Inheritance of Error Traps\\n\"\r\n      \" Error traps can be local the current command file or inherited into\\n\"\r\n      \" nested command file invocations:\\n\\n\"\r\n      \"++set on INHERIT|NOINHERIT enable/disable inheritance\\n\\n\"\r\n      \" By default, ON state is NOINHERIT which means that the scope of pending ON\\n\"\r\n      \" actions is bound to the currently executing command file.  If INHERIT is\\n\"\r\n      \" enabled, the currently defined ON actions are inherited by nested command\\n\"\r\n      \" files that may be invoked.\\n\\n\"\r\n      \"4ON\\n\"\r\n      \" To set the action(s) to take when a specific error status is returned by\\n\"\r\n      \" a command in the currently running do command file:\\n\\n\"\r\n      \"++on <statusvalue> commandtoprocess{; additionalcommandtoprocess}\\n\\n\"\r\n      \" To clear the action(s) taken take when a specific error status is returned:\\n\\n\"\r\n      \"++on <statusvalue>\\n\\n\"\r\n      \" To set the default action(s) to take when any otherwise unspecified error\\n\"\r\n      \" status is returned by a command in the currently running do command file:\\n\\n\"\r\n      \"++on error commandtoprocess{; additionalcommandtoprocess}\\n\\n\"\r\n      \" To clear the default action(s) taken when any otherwise unspecified error\\n\"\r\n      \" status is returned:\\n\\n\"\r\n      \"++on error\\n\"\r\n      \"5Parameters\\n\"\r\n      \" Error traps can be taken for any command which returns a status other\\n\"\r\n      \" than SCPE_STEP, SCPE_OK, and SCPE_EXIT.\\n\\n\"\r\n      \" ON Traps can specify any of these status values:\\n\\n\"\r\n      \"++NXM, UNATT, IOERR, CSUM, FMT, NOATT, OPENERR, MEM, ARG,\\n\"\r\n      \"++STEP, UNK, RO, INCOMP, STOP, TTIERR, TTOERR, EOF, REL,\\n\"\r\n      \"++NOPARAM, ALATT, TIMER, SIGERR, TTYERR, SUB, NOFNC, UDIS,\\n\"\r\n      \"++NORO, INVSW, MISVAL, 2FARG, 2MARG, NXDEV, NXUN, NXREG,\\n\"\r\n      \"++NXPAR, NEST, IERR, MTRLNT, LOST, TTMO, STALL, AFAIL,\\n\"\r\n      \"++AMBREG, SIGTERM\\n\\n\"\r\n      \" These values can be indicated by name or by their internal\\n\"\r\n      \" numeric value (not recommended).\\n\"\r\n      /***************** 80 character line width template *************************/\r\n      \"3CONTROL-C Trapping\\n\"\r\n      \" A special ON trap is available to describe action(s) to be taken\\n\"\r\n      \" when CONTROL_C (aka SIGINT) occurs during the execution of\\n\"\r\n      \" simh commands and/or command procedures.\\n\\n\"\r\n      \"++on CONTROL_C <action>    perform action(s) after CTRL+C\\n\"\r\n      \"++on CONTROL_C             restore default CTRL+C action\\n\\n\"\r\n      \" The default ON CONTROL_C handler will exit nested DO command\\n\"\r\n      \" procedures and return to the sim> prompt.\\n\\n\"\r\n      \" Note 1: When a simulator is executing instructions entering CTRL+C\\n\"\r\n      \"+will cause the CNTL+C character to be delivered to the simulator as\\n\"\r\n      \"+input.  The simulator instruction execution can be stopped by entering\\n\"\r\n      \"+the WRU character (usually CTRL+E).  Once instruction execution has\\n\"\r\n      \"+stopped, CTRL+C can be entered and potentially acted on by the\\n\"\r\n      \"+ON CONTROL_C trap handler.\\n\"\r\n      \" Note 2: The ON CONTROL_C trapping is not affected by the SET ON and\\n\"\r\n      \"+SET NOON commands.\\n\"\r\n      \"3SIGTERM Trapping\\n\"\r\n      \" A special ON trap is available to describe action(s) to be taken\\n\"\r\n      \" when a SIGTERM (or a Windows Shutdown) signal is delivered during\\n\"\r\n      \" simulator instruction execution.  After a SIGTERM has been delivered\\n\"\r\n      \" to a simulator process, instruction execution will stop and control\\n\"\r\n      \" will return to either the invoking do command procedure with a SIGTERM\\n\"\r\n      \" status (and thus take SIGTERM ON condition) or if execution was\\n\"\r\n      \" explicitly started from a sim> prompt, the program will exit\\n\"\r\n\r\n#define HLP_PROCEED     \"*Commands Executing_Command_Files PROCEED\"\r\n#define HLP_IGNORE      \"*Commands Executing_Command_Files PROCEED\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3PROCEED/IGNORE\\n\"\r\n      \" The PROCEED or IGNORE commands do nothing.  They are potentially useful\\n\"\r\n      \" placeholders for an ON action condition which should be explicitly ignored\\n\"\r\n      \"++proceed                  continue command file execution without doing anything\\n\"\r\n      \"++ignore                   continue command file execution without doing anything\\n\"\r\n      \"3DO Command Processing Interactions With ASSERT\\n\"\r\n      \" The command:\\n\\n\"\r\n      \"++DO -e commandfile\\n\\n\"\r\n      \" is equivalent to starting the invoked command file with:\\n\\n\"\r\n      \"++SET ON\\n\\n\"\r\n      \" which by itself it equivalent to:\\n\\n\"\r\n      \"++SET ON\\n\"\r\n      \"++ON ERROR RETURN\\n\\n\"\r\n      \" ASSERT failures have several different actions:\\n\\n\"\r\n      \"+*   If error trapping is not enabled then AFAIL causes exit from the\\n\"\r\n      \"++current do command file.\\n\"\r\n      \"+*   If error trapping is enabled and an explicit \\\"ON AFAIL\\\" action\\n\"\r\n      \"++is defined, then the specified action is performed.\\n\"\r\n      \"+*   If error trapping is enabled and no \\\"ON AFAIL\\\" action is defined,\\n\"\r\n      \"++then an AFAIL causes exit from the current do command file.\\n\"\r\n#define HLP_ECHO        \"*Commands Executing_Command_Files Displaying_Arbitrary_Text ECHO_Command\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3Displaying Arbitrary Text\\n\"\r\n      \" The ECHO and ECHOF commands are useful ways of annotating command files.\\n\\n\"\r\n      \"4ECHO command\\n\"\r\n      \" The ECHO command prints out its arguments on the console (and log)\\n\"\r\n      \" followed by a newline:\\n\\n\"\r\n      \"++ECHO <string>      output string to console\\n\\n\"\r\n      \" If there is no argument, ECHO prints a blank line on the console.  This\\n\"\r\n      \" may be used to provide spacing in the console display or log.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_ECHOF       \"*Commands Executing_Command_Files Displaying_Arbitrary_Text ECHOF_Command\"\r\n       /***************** 80 character line width template *************************/\r\n      \"4ECHOF command\\n\"\r\n      \" The ECHOF command prints out its arguments on the console (and log)\\n\"\r\n      \" followed by a newline:\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"++ECHOF {-n} \\\"<string>\\\"|<string>   output string to console\\n\\n\"\r\n      \" The ECHOF command can also print output on a specified multiplexer line\\n\"\r\n      \" (and log) followed by a newline:\\n\\n\"\r\n      \"++ECHOF {-n} dev:line \\\"<string>\\\"|<string>   output string to specified line\\n\\n\"\r\n      \" If there is no argument, ECHOF prints a blank line.\\n\"\r\n      \" The string argument may be delimited by quote characters.  Quotes may\\n\"\r\n      \" be either single or double but the opening and closing quote characters\\n\"\r\n      \" must match.  If the string is enclosed in quotes, the string may\\n\"\r\n      \" contain escaped character strings which is interpreted as described\\n\"\r\n      \" in Quoted_String_Data and the resulting string is output.\\n\\n\"\r\n      \" A command alias can be used to replace the ECHO command with the ECHOF\\n\"\r\n      \" command:\\n\\n\"\r\n      \"++sim> SET ENV ECHO=ECHOF\\n\"\r\n      \"5Switches\\n\"\r\n      \" Switches can be used to influence the behavior of ECHOF commands\\n\\n\"\r\n      \"6-n\\n\"\r\n      \" The -n switch indicates that the supplied string should be output\\n\"\r\n      \" without a newline after the string is written.\\n\"\r\n      \"5Quoted String Data\\n\"\r\n      \" String data enclosed in quotes is transformed interpreting character\\n\"\r\n      \" escapes.  The following character escapes are explicitly supported:\\n\"\r\n      \"++\\\\r  Sends the ASCII Carriage Return character (Decimal value 13)\\n\"\r\n      \"++\\\\n  Sends the ASCII Linefeed character (Decimal value 10)\\n\"\r\n      \"++\\\\f  Sends the ASCII Formfeed character (Decimal value 12)\\n\"\r\n      \"++\\\\t  Sends the ASCII Horizontal Tab character (Decimal value 9)\\n\"\r\n      \"++\\\\v  Sends the ASCII Vertical Tab character (Decimal value 11)\\n\"\r\n      \"++\\\\b  Sends the ASCII Backspace character (Decimal value 8)\\n\"\r\n      \"++\\\\\\\\  Sends the ASCII Backslash character (Decimal value 92)\\n\"\r\n      \"++\\\\'  Sends the ASCII Single Quote character (Decimal value 39)\\n\"\r\n      \"++\\\\\\\"  Sends the ASCII Double Quote character (Decimal value 34)\\n\"\r\n      \"++\\\\?  Sends the ASCII Question Mark character (Decimal value 63)\\n\"\r\n      \"++\\\\e  Sends the ASCII Escape character (Decimal value 27)\\n\"\r\n      \" as well as octal character values of the form:\\n\"\r\n      \"++\\\\n{n{n}} where each n is an octal digit (0-7)\\n\"\r\n      \" and hex character values of the form:\\n\"\r\n      \"++\\\\xh{h} where each h is a hex digit (0-9A-Fa-f)\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_SEND        \"*Commands Executing_Command_Files Injecting_Console_Input\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3Injecting Console Input\\n\"\r\n      \" The SEND command provides a way to insert input into the console device of\\n\"\r\n      \" a simulated system as if it was entered by a user.\\n\\n\"\r\n      \"++SEND {-t} {after=nn,}{delay=nn,}\\\"<string>\\\"\\n\\n\"\r\n      \"++NOSEND\\n\\n\"\r\n      \"++SHOW SEND\\n\\n\"\r\n      \" The string argument must be delimited by quote characters.  Quotes may\\n\"\r\n      \" be either single or double but the opening and closing quote characters\\n\"\r\n      \" must match.  Data in the string may contain escaped character strings.\\n\\n\"\r\n      \" The SEND command can also insert input into any serial device on a\\n\"\r\n      \" simulated system as if it was entered by a user.\\n\\n\"\r\n      \"++SEND {-t} {<dev>:line} {after=nn,}{delay=nn,}\\\"<string>\\\"\\n\\n\"\r\n      \"++NOSEND {<dev>:line}\\n\\n\"\r\n      \"++SHOW SEND {<dev>:line}\\n\\n\"\r\n      \" The NOSEND command removes any undelivered input data which may be\\n\"\r\n      \" pending on the CONSOLE or a specific multiplexer line.\\n\\n\"\r\n      \" The SHOW SEND command displays any pending SEND activity for the\\n\"\r\n      \" CONSOLE or a specific multiplexer line.\\n\"\r\n      \"4Delay\\n\"\r\n      \" Specifies an integer (>=0) representing a minimal instruction delay\\n\"\r\n      \" between characters being sent.  The delay parameter can be set by\\n\"\r\n      \" itself with:\\n\\n\"\r\n      \"++SEND DELAY=n\\n\\n\"\r\n      \" which will set the default delay value for subsequent SEND commands\\n\"\r\n      \" which don't specify an explicit DELAY parameter along with a string\\n\"\r\n      \" If a SEND command is processed and no DELAY value has been specified,\\n\"\r\n      \" the default value of the delay parameter is 1000.\\n\"\r\n      \" The value n can be specified with a suffix of k or m which indicates\\n\"\r\n      \" a multiplier of 1000 or 1000000 respectively\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"4After\\n\"\r\n      \" Specifies an integer (>=0) representing a minimal number of %C\\n\"\r\n      \" which must execute before the first character in the string is sent.\\n\"\r\n      \" The after parameter value can be set by itself with:\\n\\n\"\r\n      \"++SEND AFTER=n\\n\\n\"\r\n      \" which will set the default after value for subsequent SEND commands\\n\"\r\n      \" which don't specify an explicit AFTER parameter along with a string\\n\"\r\n      \" If a SEND command is processed and no AFTER value has been specified,\\n\"\r\n      \" the default value of the delay parameter is the DELAY parameter value.\\n\"\r\n      \" The value n can be specified with a suffix of k or m which indicates\\n\"\r\n      \" a multiplier of 1000 or 1000000 respectively\\n\"\r\n      \"4Escaping String Data\\n\"\r\n      \" The following character escapes are explicitly supported:\\n\"\r\n      \"++\\\\r  Sends the ASCII Carriage Return character (Decimal value 13)\\n\"\r\n      \"++\\\\n  Sends the ASCII Linefeed character (Decimal value 10)\\n\"\r\n      \"++\\\\f  Sends the ASCII Formfeed character (Decimal value 12)\\n\"\r\n      \"++\\\\t  Sends the ASCII Horizontal Tab character (Decimal value 9)\\n\"\r\n      \"++\\\\v  Sends the ASCII Vertical Tab character (Decimal value 11)\\n\"\r\n      \"++\\\\b  Sends the ASCII Backspace character (Decimal value 8)\\n\"\r\n      \"++\\\\\\\\  Sends the ASCII Backslash character (Decimal value 92)\\n\"\r\n      \"++\\\\'  Sends the ASCII Single Quote character (Decimal value 39)\\n\"\r\n      \"++\\\\\\\"  Sends the ASCII Double Quote character (Decimal value 34)\\n\"\r\n      \"++\\\\?  Sends the ASCII Question Mark character (Decimal value 63)\\n\"\r\n      \"++\\\\e  Sends the ASCII Escape character (Decimal value 27)\\n\"\r\n      \" as well as octal character values of the form:\\n\"\r\n      \"++\\\\n{n{n}} where each n is an octal digit (0-7)\\n\"\r\n      \" and hex character values of the form:\\n\"\r\n      \"++\\\\xh{h} where each h is a hex digit (0-9A-Fa-f)\\n\"\r\n      \"4Switches\\n\"\r\n      \" Switches can be used to influence the behavior of SEND commands\\n\\n\"\r\n      \"5-t\\n\"\r\n      \" The -t switch indicates that the Delay and After values are in\\n\"\r\n      \" units of microseconds rather than %C.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_EXPECT      \"*Commands Executing_Command_Files Reacting_To_Console_Output\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3Reacting To Console Output\\n\"\r\n      \" The EXPECT command provides a way to stop execution and take actions\\n\"\r\n      \" when specific output has been generated by the simulated system.\\n\\n\"\r\n      \"++EXPECT {dev:line} {[count]} {HALTAFTER=n,}\\\"<string>\\\" {actioncommand {; actioncommand}...}\\n\\n\"\r\n      \"++NOEXPECT {dev:line} \\\"<string>\\\"\\n\\n\"\r\n      \"++SHOW EXPECT {dev:line}\\n\\n\"\r\n      \" The string argument must be delimited by quote characters.  Quotes\\n\"\r\n      \" may be either single or double but the opening and closing quote\\n\"\r\n      \" characters must match.  Data in the string may contain escaped\\n\"\r\n      \" character strings.  If a [count] is specified, the rule will match\\n\"\r\n      \" after the match string has matched count times.\\n\\n\"\r\n      \" When multiple expect rules are defined with the same match string,\\n\"\r\n      \" they will match in the same order they were defined in.\\n\\n\"\r\n      \" When expect rules are defined, they are evaluated agains recently\\n\"\r\n      \" produced output as each character is output to the device.  Since\\n\"\r\n      \" this evaluation processing is done on each output character, rule\\n\"\r\n      \" matching is not specifically line oriented.  If line oriented\\n\"\r\n      \" matching is desired then rules should be defined which contain the\\n\"\r\n      \" simulated system's line ending character sequence (i.e. \\\"\\\\r\\\\n\\\").\\n\"\r\n      \" Once data has matched any expect rule, that data is no longer\\n\"\r\n      \" eligible to match other expect rules which may already be defined.\\n\"\r\n      \" Data which is output prior to the definition of an expect rule is\\n\"\r\n      \" not eligible to be matched against.\\n\\n\"\r\n      \" The NOEXPECT command removes a previously defined EXPECT command\\n\"\r\n      \" for the console or a specific multiplexer line.  A NOEXPECT command,\\n\"\r\n      \" without a specific mention of a particular EXPECT match string, will\\n\"\r\n      \" remove all currently defined EXPECT match rules.\\n\\n\"\r\n      \" The SHOW EXPECT command displays all of the pending EXPECT state for\\n\"\r\n      \" the console or a specific multiplexer line.\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"4Switches\\n\"\r\n      \" Switches can be used to influence the behavior of EXPECT rules\\n\\n\"\r\n      \"5-p\\n\"\r\n      \" EXPECT rules default to be one shot activities.  That is a rule is\\n\"\r\n      \" automatically removed when it matches unless it is designated as a\\n\"\r\n      \" persistent rule by using a -p switch when the rule is defined.\\n\\n\"\r\n      \"5-c\\n\"\r\n      \" If an expect rule is defined with the -c switch, it will cause all\\n\"\r\n      \" pending expect rules on the current device to be cleared when the rule\\n\"\r\n      \" matches data in the device output stream.\\n\\n\"\r\n      \"5-r\\n\"\r\n      \" If an expect rule is defined with the -r switch, the string is\\n\"\r\n      \" interpreted as a regular expression applied to the output data\\n\"\r\n      \" stream.  This regular expression may contain parentheses delimited\\n\"\r\n      \" sub-groups.\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \" The syntax of the regular expressions available are those supported\\n\"\r\n      \" by the Perl Compatible Regular Expression package (aka PCRE).  As\\n\"\r\n      \" the name implies, the syntax is generally the same as Perl regular\\n\"\r\n      \" expressions.  See http://perldoc.perl.org/perlre.html for more\\n\"\r\n      \" details.\\n\\n\"\r\n      \"5-i\\n\"\r\n      \" If a regular expression expect rule is defined with the -i switch,\\n\"\r\n      \" character matching for that expression will be case independent.\\n\"\r\n      \" The -i switch is only valid for regular expression expect rules.\\n\\n\"\r\n      \"5-t\\n\"\r\n      \" The -t switch indicates that the value specified by the HaltAfter\\n\"\r\n      \" parameter are in units of microseconds rather than %C.\\n\\n\"\r\n      \"4Determining Which Output Matched\\n\"\r\n      \" When an expect rule matches data in the output stream, the rule\\n\"\r\n      \" which matched is recorded in the environment variable\\n\"\r\n      \" _EXPECT_MATCH_PATTERN.  If the expect rule was a regular expression\\n\"\r\n      \" rule, then the environment variable _EXPECT_MATCH_GROUP_0 is set to\\n\"\r\n      \" the whole string which matched and if the match pattern had any\\n\"\r\n      \" parentheses delimited sub-groups, the environment variables\\n\"\r\n      \" _EXPECT_MATCH_GROUP_1 thru _EXPECT_MATCH_GROUP_n are set to the\\n\"\r\n      \" values within the string which matched the respective sub-groups.\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"4Escaping String Data\\n\"\r\n      \" The following character escapes are explicitly supported when NOT\\n\"\r\n      \" using regular expression match patterns:\\n\"\r\n      \"++\\\\r  Expect the ASCII Carriage Return character (Decimal\\n\"\r\n      \"+++value 13)\\n\"\r\n      \"++\\\\n  Expect the ASCII Linefeed character (Decimal value 10)\\n\"\r\n      \"++\\\\f  Expect the ASCII Formfeed character (Decimal value 12)\\n\"\r\n      \"++\\\\t  Expect the ASCII Horizontal Tab character (Decimal\\n\"\r\n      \"+++value 9)\\n\"\r\n      \"++\\\\v  Expect the ASCII Vertical Tab character (Decimal\\n\"\r\n      \"+++value 11)\\n\"\r\n      \"++\\\\b  Expect the ASCII Backspace character (Decimal value 8)\\n\"\r\n      \"++\\\\\\\\  Expect the ASCII Backslash character (Decimal value 92)\\n\"\r\n      \"++\\\\'  Expect the ASCII Single Quote character (Decimal\\n\"\r\n      \"+++value 39)\\n\"\r\n      \"++\\\\\\\"  Expect the ASCII Double Quote character (Decimal\\n\"\r\n      \"+++value 34)\\n\"\r\n      \"++\\\\?  Expect the ASCII Question Mark character (Decimal\\n\"\r\n      \"+++value 63)\\n\"\r\n      \"++\\\\e  Expect the ASCII Escape character (Decimal value 27)\\n\"\r\n      \"++ as well as octal character values of the form:\\n\"\r\n      \"+++\\\\n{n{n}} where each n is an octal digit (0-7)\\n\"\r\n      \"++ and hex character values of the form:\\n\"\r\n      \"+++\\\\xh{h} where each h is a hex digit (0-9A-Fa-f)\\n\\n\"\r\n      \"4HaltAfter\\n\"\r\n      \" Specifies the number of %C which should be executed before\\n\"\r\n      \" simulator instruction execution should stop.  The default is to stop\\n\"\r\n      \" executing %C immediately (i.e. HALTAFTER=0).\\n\"\r\n      \" The default HaltAfter delay, once set, persists for all expect\\n\"\r\n      \" behaviors for that device.\\n\"\r\n      \" The default HaltAfter parameter value can be set by itself with:\\n\\n\"\r\n      \"++EXPECT HALTAFTER=n\\n\\n\"\r\n      \" A unique HaltAfter value can be specified with each expect matching\\n\"\r\n      \" rule which if it is not specified then the default value will be\\n\"\r\n      \" used.  To avoid potentially unpredictable system hehavior that will\\n\"\r\n      \" happen if multiple expect rules are in effect and a haltafter value\\n\"\r\n      \" is large enough for more than one expect rule to match before an\\n\"\r\n      \" earlier haltafter delay has expired, only a single EXPECT rule can\\n\"\r\n      \" be defined if a non-zero HaltAfter parameter has been set.\\n\"\r\n      \" The value n can be specified with a suffix of k or m which indicates\\n\"\r\n      \" a multiplier of 1000 or 1000000 respectively.\\n\\n\"\r\n      /***************** 80 character line width template *************************/\r\n#define HLP_SLEEP       \"*Commands Executing_Command_Files Pausing_Command_Execution\"\r\n      \"3Pausing Command Execution\\n\"\r\n      \" A simulator command file may wait for a specific period of time with the\\n\\n\"\r\n      \"++SLEEP NUMBER[SUFFIX]...\\n\\n\"\r\n      \" Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\\n\"\r\n      \" 'm' for minutes, 'h' for hours or 'd' for days.  NUMBER may be an\\n\"\r\n      \" arbitrary floating point number.  Given two or more arguments, pause\\n\"\r\n      \" for the amount of time specified by the sum of their values.\\n\"\r\n      \" NOTE: A SLEEP command is interruptable with SIGINT (CTRL+C).\\n\\n\"\r\n      \"4Switches\\n\"\r\n      \" A switch can be used to influence the behavior of the SLEEP command\\n\\n\"\r\n      \"5-v\\n\"\r\n      \" Causes the sleep command to visibly count down the time left until\\n\"\r\n      \" the sleeping will finish.\\n\\n\"\r\n      /***************** 80 character line width template *************************/\r\n#define HLP_ASSERT      \"*Commands Executing_Command_Files Testing_Simulator_State\"\r\n#define HLP_IF          \"*Commands Executing_Command_Files Testing_Simulator_State\"\r\n      \"3Testing Simulator State\\n\"\r\n      \" There are two ways for a command file to examine simulator state and\\n\"\r\n      \" then take action based on that state:\\n\"\r\n      \"4ASSERT\\n\"\r\n      \" The ASSERT command tests a simulator state condition and halts command\\n\"\r\n      \" file execution if the condition is false:\\n\\n\"\r\n      \"++ASSERT <Simulator State Expressions>\\n\\n\"\r\n      \" If the indicated expression evaluates to false, the command completes\\n\"\r\n      \" with an AFAIL condition.  By default, when a command file encounters a\\n\"\r\n      \" command which returns the AFAIL condition, it will exit the running\\n\"\r\n      \" command file with the AFAIL status to the calling command file.  This\\n\"\r\n      \" behavior can be changed with the ON command as well as switches to the\\n\"\r\n      \" invoking DO command.\\n\\n\"\r\n      \"5Examples:\\n\"\r\n      \" A command file might be used to bootstrap an operating system that\\n\"\r\n      \" halts after the initial load from disk.  The ASSERT command is then\\n\"\r\n      \" used to confirm that the load completed successfully by examining the\\n\"\r\n      \" CPU's \\\"A\\\" register for the expected value:\\n\\n\"\r\n      \"++; OS bootstrap command file\\n\"\r\n      \"++;\\n\"\r\n      \"++IF EXIST \\\"os.disk\\\" echo os.disk exists\\n\"\r\n      \"++IF NOT EXIST os.disk echo os.disk not existing\\n\"\r\n      \"++IF EXIST \\\"os.disk\\\" echo os.disk exists\\n\"\r\n      \"++ELSE                 echo os.disk not existing\\n\"\r\n      \"++ATTACH DS0 os.disk\\n\"\r\n      \"++BOOT DS\\n\"\r\n      \"++; A register contains error code; 0 = good boot\\n\"\r\n      \"++ASSERT A=0\\n\"\r\n      \"++ATTACH MT0 sys.tape\\n\"\r\n      \"++ATTACH MT1 user.tape\\n\"\r\n      \"++RUN\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \" In the example, if the A register is not 0, the \\\"ASSERT A=0\\\" command will\\n\"\r\n      \" be echoed, the command file will be aborted with an \\\"Assertion failed\\\"\\n\"\r\n      \" message.  Otherwise, the command file will continue to bring up the\\n\"\r\n      \" operating system.\\n\"\r\n      \"4IF-ELSE\\n\"\r\n      \" The IF command tests a simulator state condition and executes additional\\n\"\r\n      \" commands if the condition is true:\\n\\n\"\r\n      \"++IF <Conditional Expressions> commandtoprocess{; additionalcommandtoprocess}...\\n\"\r\n      \"++{ELSE commandtoprocess{; additionalcommandtoprocess}...}\\n\\n\"\r\n      \"5Examples:\\n\"\r\n      \" A command file might be used to bootstrap an operating system that\\n\"\r\n      \" halts after the initial load from disk.  The ASSERT command is then\\n\"\r\n      \" used to confirm that the load completed successfully by examining the\\n\"\r\n      \" CPU's \\\"A\\\" register for the expected value:\\n\\n\"\r\n      \"++; OS bootstrap command file\\n\"\r\n      \"++;\\n\"\r\n      \"++IF EXIST \\\"os.disk\\\" echo os.disk exists\\n\"\r\n      \"++IF NOT EXIST os.disk echo os.disk not existing\\n\"\r\n      \"++ATTACH DS0 os.disk\\n\"\r\n      \"++BOOT DS\\n\"\r\n      \"++; A register contains error code; 0 = good boot\\n\"\r\n      \"++IF NOT A=0 echo Boot failed - Failure Code; EX A; exit AFAIL\\n\"\r\n      \"++ATTACH MT0 sys.tape\\n\"\r\n      \"++ATTACH MT1 user.tape\\n\"\r\n      \"++RUN\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \" In the example, if the A register is not 0, the message \\\"Boot failed -\\n\"\r\n      \" Failure Code:\\\" command will be displayed, the contents of the A register\\n\"\r\n      \" will be displayed and the command file will be aborted with an \\\"Assertion\\n\"\r\n      \" failed\\\" message.  Otherwise, the command file will continue to bring up\\n\"\r\n      \" the operating system.\\n\"\r\n      \"4Conditional Expressions\\n\"\r\n      \" The IF and ASSERT commands evaluate five different forms of conditional\\n\"\r\n      \" expressions.:\\n\\n\"\r\n      \"5C Style Simulator State Expressions\\n\"\r\n      \" Comparisons can optionally be done with complete C style computational\\n\"\r\n      \" expressions which leverage the C operations in the below table and can\\n\"\r\n      \" optionally reference any combination of values that are constants or\\n\"\r\n      \" contained in environment variables or simulator registers.  C style\\n\"\r\n      \" expression evaluation is initiated by enclosing the expression in\\n\"\r\n      \" parenthesis.\\n\\n\"\r\n      \" Expression can contain any of these C language operators:\\n\\n\"\r\n      \"++ (                  Open Parenthesis\\n\"\r\n      \"++ )                  Close Parenthesis\\n\"\r\n      \"++ -                  Subtraction\\n\"\r\n      \"++ +                  Addition\\n\"\r\n      \"++ *                  Multiplication\\n\"\r\n      \"++ /                  Division\\n\"\r\n      \"++ %%                  Modulus\\n\"\r\n      \"++ &&                 Logical AND\\n\"\r\n      \"++ ||                 Logical OR\\n\"\r\n      \"++ &                  Bitwise AND\\n\"\r\n      \"++ |                  Bitwise Inclusive OR\\n\"\r\n      \"++ ^                  Bitwise Exclusive OR\\n\"\r\n      \"++ >>                 Bitwise Right Shift\\n\"\r\n      \"++ <<                 Bitwise Left Shift\\n\"\r\n      \"++ ==                 Equality\\n\"\r\n      \"++ !=                 Inequality\\n\"\r\n      \"++ <=                 Less than or Equal\\n\"\r\n      \"++ <                  Less than\\n\"\r\n      \"++ >=                 Greater than or Equal\\n\"\r\n      \"++ >                  Greater than\\n\"\r\n      \"++ !                  Logical Negation\\n\"\r\n      \"++ ~                  Bitwise Compliment\\n\\n\"\r\n      \" Operator precedence is consistent with C language precedence.\\n\\n\"\r\n      \" Expression can contain arbitrary combinations of constant\\n\"\r\n      \" values, simulator registers and environment variables \\n\"\r\n      \"5Simulator State Expressions\\n\"\r\n      \" The values of simulator registers can be evaluated with:\\n\\n\"\r\n      \"++{NOT} {<dev>} <reg>|<addr>{<logical-op><value>}<conditional-op><value>\\n\\n\"\r\n      \" If <dev> is not specified, CPU is assumed.  <reg> is a register (scalar\\n\"\r\n      \" or subscripted) belonging to the indicated device.  <addr> is an address\\n\"\r\n      \" in the address space of the indicated device.  The <conditional-op>\\n\"\r\n      \" and optional <logical-op> are the same as those used for \\\"search\\n\"\r\n      \" specifiers\\\" by the EXAMINE and DEPOSIT commands.  The <value>s are\\n\"\r\n      \" expressed in the radix specified for <reg>, not in the radix for the\\n\"\r\n      \" device when referencing a register and when an address is referenced\\n\"\r\n      \" the device radix is used as the default.\\n\\n\"\r\n      \" If the <logical-op> and <value> are specified, the target register value\\n\"\r\n      \" is first altered as indicated.  The result is then compared to the\\n\"\r\n      \" <value> via the <conditional-op>.  If the result is true, the additional\\n\"\r\n      \" command(s) are executed before proceeding to the next line in the command\\n\"\r\n      \" file.  Otherwise, the next command in the command file is processed.\\n\\n\"\r\n      \"5String Comparison Expressions\\n\"\r\n      \" String Values can be compared with:\\n\"\r\n      \"+{-I}{-W} {NOT} \\\"<string1>\\\"|EnVarName1 <compare-op> \\\"<string2>|EnvVarName2\\\"\\n\\n\"\r\n      \" The -I switch, if present, causes comparisons to be case insensitive.\\n\"\r\n      \" The -W switch, if present, causes comparisons to allow arbitrary runs\\n\"\r\n      \" of whitespace to be equivalent to a single space.\\n\"\r\n      \" The -I and -W switches may be combined.\\n\"\r\n      \" <string1> and <string2> are quoted string values which may have\\n\"\r\n      \" environment variables substituted as desired.\\n\"\r\n      \" Either quoted string may alternatively be an environment variable name.\\n\"\r\n      \" <compare-op> may be one of:\\n\\n\"\r\n      \"++==  - equal\\n\"\r\n      \"++EQU - equal\\n\"\r\n      \"++!=  - not equal\\n\"\r\n      \"++NEQ - not equal\\n\"\r\n      \"++<   - less than\\n\"\r\n      \"++LSS - less than\\n\"\r\n      \"++<=  - less than or equal\\n\"\r\n      \"++LEQ - less than or equal\\n\"\r\n      \"++>   - greater than\\n\"\r\n      \"++GTR - greater than\\n\"\r\n      \"++>=  - greater than or equal\\n\"\r\n      \"++GEQ - greater than or equal\\n\\n\"\r\n      \" Comparisons are generic.  This means that if both string1 and string2\\n\"\r\n      \" are comprised of all numeric digits, then the strings are converted to\\n\"\r\n      \" numbers and a numeric comparison is performed.\\n\"\r\n      \" For example: \\\"+1\\\" EQU \\\"1\\\" will be true.\\n\"\r\n      \"5File Existence Expressions\\n\"\r\n      \" File existence can be determined with:\\n\\n\"\r\n      \"++{NOT} EXIST \\\"<filespec>\\\"\\n\\n\"\r\n      \"++{NOT} EXIST <filespec>\\n\\n\"\r\n      \" Specifies a true (false {NOT}) condition if the file exists.\\n\"\r\n      \"5File Comparison Expressions\\n\"\r\n      \" Files can have their contents compared with:\\n\\n\"\r\n      \"++-F{W} {NOT} \\\"<filespec1>\\\" == \\\"<filespec2>\\\" \\n\\n\"\r\n      \" Specifies a true (false {NOT}) condition if the indicated files\\n\"\r\n      \" have the same contents.  If the -W switch is present, allows\\n\"\r\n      \" arbitrary runs of whitespace to be considered a single space\\n\"\r\n      \" during file content comparison.\\n\\n\"\r\n      \" When a file comparison determines that files are different, the\\n\"\r\n      \" environment variable _FILE_COMPARE_DIFF_OFFSET is set to the file\\n\"\r\n      \" offset where the first difference in the files was observed.\\n\\n\"\r\n      \" If the environment variable _FILE_COMPARE_START_OFFSET is defined, it\\n\"\r\n      \" specifies the offset into the both files where the comparison should\\n\"\r\n      \" start, thus skipping the initial bytes of the file before beginning\\n\"\r\n      \" the comparison.\\n\\n\"\r\n      \"5Device Existence Expressions\\n\"\r\n      \" Devices existence (or enable state) can be determined with:\\n\\n\"\r\n      \"++{NOT} DEVICE <device-name>\\n\\n\"\r\n      \" Specifies a true (false {NOT}) condition if the device exists and is\\n\"\r\n      \" enabled.\\n\\n\"\r\n      \"5Debugging Expression Evaluation\\n\"\r\n      \" Debug output can be produced which will walk through the details\\n\"\r\n      \" involved during expression evaluation.  This output can, for example,\\n\"\r\n      \" be enabled as follows:\\n\\n\"\r\n      \"++sim> SET DEBUG STDOUT\\n\"\r\n      \"++sim> SET SCP-PROCESS DEBUG=EXPSTACK  - Expression Stack Activities\\n\"\r\n      \"++sim> SET SCP-PROCESS DEBUG=EXPEVAL   - Expression Evaluation Activities\\n\"\r\n      \"3Debugging Do File Processing\\n\"\r\n      \" Debug output can be produced which will walk through the details\\n\"\r\n      \" involved during DO file processing.  This output can, for example,\\n\"\r\n      \" be enabled as follows:\\n\\n\"\r\n      \"++sim> SET DEBUG STDOUT\\n\"\r\n      \"++sim> SET SCP-PROCESS DEBUG=DO  - Debug Output DO processing\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_EXIT        \"*Commands Exiting_The_Simulator\"\r\n      \"2Exiting The Simulator\\n\"\r\n      \" EXIT (synonyms QUIT and BYE) returns control to the operating system.\\n\"\r\n      \"3 Exit Status\\n\"\r\n      \" An optional numeric exit status may be provided on the EXIT command line\\n\"\r\n      \" that an operating system script may act on.\\n\\n\"\r\n      \"++EXIT {status}        exit with optional status\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n#define HLP_SCREENSHOT  \"*Commands Screenshot_Video_Window\"\r\n      \"2Screenshot Video Window\\n\"\r\n      \" Simulators with Video devices display the simulated video in a window(s)\\n\"\r\n      \" on the local system.  The contents of that display can be saved in a\\n\"\r\n      \" file with the SCREENSHOT command:\\n\\n\"\r\n      \"++SCREENSHOT screenshotfile\\n\\n\"\r\n#if defined(HAVE_LIBPNG)\r\n      \" which will create a screen shot file called screenshotfile.png\\n\"\r\n#else\r\n      \" which will create a screen shot file called screenshotfile.bmp\\n\"\r\n#endif\r\n#define HLP_SPAWN       \"*Commands Executing_System_Commands\"\r\n      \"2Executing System Commands\\n\"\r\n      \" The simulator can execute operating system commands with the ! (spawn)\\n\"\r\n      \" command:\\n\\n\"\r\n      \"++!                    execute local command interpreter\\n\"\r\n      \"++! <command>          execute local host command\\n\"\r\n      \" If no operating system command is provided, the simulator attempts to\\n\"\r\n      \" launch the host operating system's command shell.\\n\"\r\n      \" The exit status from the command which was executed is set as the command\\n\"\r\n      \" completion status for the ! command.  This may influence any enabled ON\\n\"\r\n      \" condition traps\\n\"\r\n#define HLP_TESTLIB     \"*Commands Testing_Device_Libraries\"\r\n      \"2Testing Device Libraries\\n\"\r\n      \" A simulator developer may need to invoke the simh internal device library\\n\"\r\n      \" test routines that exercise the various libraries used by different devices.\\n\\n\"\r\n      \" There are library test routines for devices which use:\\n\\n\"\r\n      \"++sim_disk  - Disk devices\\n\"\r\n      \"++sim_tape  - Tape devices\\n\"\r\n      \"++sim_ether - Ethernet devices\\n\"\r\n      \"++sim_card  - Card Reader/Punch Devices\\n\"\r\n      \"++sim_tmxr  - Terminal Multiplexor Devices\\n\\n\"\r\n      \" The TESTLIB command by itself will invoke library tests for all devices in the\\n\"\r\n      \" current simulator.\\n\\n\"\r\n      \" The library tests for a specific device can be invoked by specifying the device\\n\"\r\n      \" name as an argument to the TESTLIB command:\\n\\n\"\r\n      \"++TESTLIB {device}           test a specific or all devices\\n\\n\"\r\n       /***************** 80 character line width template *************************/\r\n      \"3Switches\\n\"\r\n      \" Switches can be used to influence the behavior of the TESTLIB command\\n\\n\"\r\n      \"4-d\\n\"\r\n      \" Many tests are capable of producing various amounts of debug output\\n\"\r\n      \" during their execution.  The -d switch enables that output\\n\"\r\n      \"2File Tools\\n\"\r\n      \" Tools to manipulate file containers and to transfer files/data into or\\n\"\r\n      \" out of a simulated environment are provided.\\n\\n\"\r\n      \" In general, these are tools natively found on the host operating system.\\n\"\r\n      \" They are explicitly supported directly from SCP to allow for platform\\n\"\r\n      \" neutral scripts that either test or build running environments for simh\\n\"\r\n      \" users.\\n\\n\"\r\n#define HLP_TAR         \"*Commands File_Tools Tar_Tool\"\r\n      \"3Tar Tool\\n\"\r\n      \" tar is an archiving utility\\n\\n\"\r\n      \" The quick and dirty help for the TAR command can be viewed with:\\n\\n\"\r\n      \"++sim> tar --help\\n\\n\"\r\n#define HLP_CURL        \"*Commands File_Tools Curl_Tool\"\r\n      \"3Curl Tool\\n\"\r\n      \" curl is a utility to transfer a URL\\n\\n\"\r\n      \" The quick and dirty help for the CURL command can be viewed with:\\n\\n\"\r\n      \"++sim> curl --help\\n\\n\"\r\n#define HLP_DISKINFO    \"*Commands Disk_Container_Information\"\r\n      \"2Disk Container Information\\n\"\r\n      \" Information about a Disk Container can be displayed with the DISKINFO\\n\"\r\n      \" command:\\n\\n\"\r\n      \"++DISKINFO container-spec       show information about a disk container\\n\\n\"\r\n      \" Disk Containers that have metadata that describes details about the\\n\"\r\n      \" the container's type and attributes will display that detailed\\n\"\r\n      \" information for the container.  Disk Containers that don't have metadata\\n\"\r\n      \" merely have their size reported.\\n\\n\"\r\n      \" In either case, if a known file system type is recognized on the container\\n\"\r\n      \" the details about that file system are indicated.\\n\\n\"\r\n#define HLP_ZAPTYPE     \"*Commands Removing_Disk_Metadata\"\r\n      \"2Removing Disk Metadata\\n\"\r\n      \" Metadata on disk containers can be removed by using the ZAPTYPE command:\\n\\n\"\r\n      \"++ZAPTYPE container-spec       remove disk metadata if present\\n\\n\"\r\n      \" Disk Containers that have metadata will have that metadata removed and\\n\"\r\n      \" the container's last write time reflected in the file timestamp and the\\n\"\r\n      \" container's size will shrink back to the further of the file's size when\\n\"\r\n      \" the metadata was added or the furthest write point in the container.\\n\"\r\n      \" Disk Containers that don't have metadata will not be modified\\n\\n\"\r\n      \"3Switches\\n\"\r\n      \" Switches can be used to influence the behavior of the ZAPTYPE command\\n\\n\"\r\n      \"4-z\\n\"\r\n      \" The -z switch will cause all zero containing sectors to be trimmed from the\\n\"\r\n      \" end of the container file, even if they were present when the metadata\\n\"\r\n      \" was added.\\n\\n\";\r\n\r\n\r\nstatic CTAB cmd_table[] = {\r\n    { \"RESET\",      &reset_cmd,     0,          HLP_RESET,      NULL, NULL },\r\n    { \"EXAMINE\",    &exdep_cmd,     EX_E,       HLP_EXAMINE,    NULL, NULL },\r\n    { \"IEXAMINE\",   &exdep_cmd,     EX_E+EX_I,  HLP_IEXAMINE,   NULL, NULL },\r\n    { \"DEPOSIT\",    &exdep_cmd,     EX_D,       HLP_DEPOSIT,    NULL, NULL },\r\n    { \"IDEPOSIT\",   &exdep_cmd,     EX_D+EX_I,  HLP_IDEPOSIT,   NULL, NULL },\r\n    { \"EVALUATE\",   &eval_cmd,      0,          HLP_EVALUATE,   NULL, NULL },\r\n    { \"RUN\",        &run_cmd,       RU_RUN,     HLP_RUN,        NULL, &run_cmd_message },\r\n    { \"GO\",         &run_cmd,       RU_GO,      HLP_GO,         NULL, &run_cmd_message },\r\n    { \"STEP\",       &run_cmd,       RU_STEP,    HLP_STEP,       NULL, &run_cmd_message },\r\n    { \"NEXT\",       &run_cmd,       RU_NEXT,    HLP_NEXT,       NULL, &run_cmd_message },\r\n    { \"CONTINUE\",   &run_cmd,       RU_CONT,    HLP_CONTINUE,   NULL, &run_cmd_message },\r\n    { \"BOOT\",       &run_cmd,       RU_BOOT,    HLP_BOOT,       NULL, &run_cmd_message },\r\n    { \"BREAK\",      &brk_cmd,       SSH_ST,     HLP_BREAK,      NULL, NULL },\r\n    { \"NOBREAK\",    &brk_cmd,       SSH_CL,     HLP_NOBREAK,    NULL, NULL },\r\n    { \"DEBUG\",      &debug_cmd,     1,          HLP_DEBUG,      NULL, NULL },\r\n    { \"NODEBUG\",    &debug_cmd,     0,          HLP_NODEBUG,    NULL, NULL },\r\n    { \"ATTACH\",     &attach_cmd,    0,          HLP_ATTACH,     NULL, NULL },\r\n    { \"DETACH\",     &detach_cmd,    0,          HLP_DETACH,     NULL, NULL },\r\n    { \"ASSIGN\",     &assign_cmd,    0,          HLP_ASSIGN,     NULL, NULL },\r\n    { \"DEASSIGN\",   &deassign_cmd,  0,          HLP_DEASSIGN,   NULL, NULL },\r\n    { \"SAVE\",       &save_cmd,      0,          HLP_SAVE,       NULL, NULL },\r\n    { \"RESTORE\",    &restore_cmd,   0,          HLP_RESTORE,    NULL, NULL },\r\n    { \"GET\",        &restore_cmd,   0,          NULL,           NULL, NULL },\r\n    { \"LOAD\",       &load_cmd,      0,          HLP_LOAD,       NULL, NULL },\r\n    { \"DUMP\",       &load_cmd,      1,          HLP_DUMP,       NULL, NULL },\r\n    { \"EXIT\",       &exit_cmd,      0,          HLP_EXIT,       NULL, NULL },\r\n    { \"QUIT\",       &exit_cmd,      0,          NULL,           NULL, NULL },\r\n    { \"BYE\",        &exit_cmd,      0,          NULL,           NULL, NULL },\r\n    { \"CD\",         &set_default_cmd, 0,        HLP_CD,         NULL, NULL },\r\n    { \"PWD\",        &pwd_cmd,       0,          HLP_PWD,        NULL, NULL },\r\n    { \"DIR\",        &dir_cmd,       0,          HLP_DIR,        NULL, NULL },\r\n    { \"LS\",         &dir_cmd,       0,          HLP_LS,         NULL, NULL },\r\n    { \"TYPE\",       &type_cmd,      0,          HLP_TYPE,       NULL, NULL },\r\n    { \"CAT\",        &type_cmd,      0,          HLP_CAT,        NULL, NULL },\r\n    { \"DELETE\",     &delete_cmd,    0,          HLP_DELETE,     NULL, NULL },\r\n    { \"RM\",         &delete_cmd,    0,          HLP_RM,         NULL, NULL },\r\n    { \"COPY\",       &copy_cmd,      0,          HLP_COPY,       NULL, NULL },\r\n    { \"CP\",         &copy_cmd,      0,          HLP_CP,         NULL, NULL },\r\n    { \"RENAME\",     &rename_cmd,    0,          HLP_RENAME,     NULL, NULL },\r\n    { \"MOVE\",       &rename_cmd,    0,          HLP_MOVE,       NULL, NULL },\r\n    { \"MV\",         &rename_cmd,    0,          HLP_MOVE,       NULL, NULL },\r\n    { \"MKDIR\",      &mkdir_cmd,     0,          HLP_MKDIR,      NULL, NULL },\r\n    { \"RMDIR\",      &rmdir_cmd,     0,          HLP_RMDIR,      NULL, NULL },\r\n    { \"SET\",        &set_cmd,       0,          HLP_SET,        NULL, NULL },\r\n    { \"SHOW\",       &show_cmd,      0,          HLP_SHOW,       NULL, NULL },\r\n    { \"DO\",         &do_cmd,        1,          HLP_DO,         NULL, NULL },\r\n    { \"GOTO\",       &goto_cmd,      1,          HLP_GOTO,       NULL, NULL },\r\n    { \"RETURN\",     &return_cmd,    0,          HLP_RETURN,     NULL, NULL },\r\n    { \"SHIFT\",      &shift_cmd,     0,          HLP_SHIFT,      NULL, NULL },\r\n    { \"CALL\",       &call_cmd,      0,          HLP_CALL,       NULL, NULL },\r\n    { \"ON\",         &on_cmd,        0,          HLP_ON,         NULL, NULL },\r\n    { \"IF\",         &assert_cmd,    0,          HLP_IF,         NULL, NULL },\r\n    { \"ELSE\",       &assert_cmd,    2,          HLP_IF,         NULL, NULL },\r\n    { \"PROCEED\",    &noop_cmd,      0,          HLP_PROCEED,    NULL, NULL },\r\n    { \"IGNORE\",     &noop_cmd,      0,          HLP_IGNORE,     NULL, NULL },\r\n    { \"ECHO\",       &echo_cmd,      0,          HLP_ECHO,       NULL, NULL },\r\n    { \"ECHOF\",      &echof_cmd,     0,          HLP_ECHOF,      NULL, NULL },\r\n    { \"ASSERT\",     &assert_cmd,    1,          HLP_ASSERT,     NULL, NULL },\r\n    { \"SEND\",       &send_cmd,      1,          HLP_SEND,       NULL, NULL },\r\n    { \"NOSEND\",     &send_cmd,      0,          HLP_SEND,       NULL, NULL },\r\n    { \"EXPECT\",     &expect_cmd,    1,          HLP_EXPECT,     NULL, NULL },\r\n    { \"NOEXPECT\",   &expect_cmd,    0,          HLP_EXPECT,     NULL, NULL },\r\n    { \"SLEEP\",      &sleep_cmd,     0,          HLP_SLEEP,      NULL, NULL },\r\n    { \"!\",          &spawn_cmd,     0,          HLP_SPAWN,      NULL, NULL },\r\n    { \"HELP\",       &help_cmd,      0,          HLP_HELP,       NULL, NULL },\r\n    { \"SCREENSHOT\", &screenshot_cmd,0,          HLP_SCREENSHOT, NULL, NULL },\r\n    { \"TAR\",        &tar_cmd,       0,          HLP_TAR,        NULL, NULL },\r\n    { \"CURL\",       &curl_cmd,      0,          HLP_CURL,       NULL, NULL },\r\n    { \"RUNLIMIT\",   &runlimit_cmd,  1,          HLP_RUNLIMIT,   NULL, NULL },\r\n    { \"NORUNLIMIT\", &runlimit_cmd,  0,          HLP_RUNLIMIT,   NULL, NULL },\r\n    { \"TESTLIB\",    &test_lib_cmd,  0,          HLP_TESTLIB,    NULL, NULL },\r\n    { \"DISKINFO\",   &sim_disk_info_cmd,  0,     HLP_DISKINFO,   NULL, NULL },\r\n    { \"ZAPTYPE\",    &sim_disk_info_cmd,  1,     HLP_ZAPTYPE,    NULL, NULL },\r\n    { NULL,         NULL,           0,          NULL,           NULL, NULL }\r\n    };\r\n\r\nstatic CTAB set_glob_tab[] = {\r\n    { \"CONSOLE\",    &sim_set_console,           0, HLP_SET_CONSOLE },\r\n    { \"REMOTE\",     &sim_set_remote_console,    0, HLP_SET_REMOTE },\r\n    { \"BREAK\",      &brk_cmd,              SSH_ST, HLP_SET_BREAK },\r\n    { \"NOBREAK\",    &brk_cmd,              SSH_CL, HLP_SET_BREAK },\r\n    { \"DEFAULT\",    &set_default_cmd,           1, HLP_SET_DEFAULT },\r\n    { \"TELNET\",     &sim_set_telnet,            0 },            /* deprecated */\r\n    { \"NOTELNET\",   &sim_set_notelnet,          0 },            /* deprecated */\r\n    { \"LOG\",        &sim_set_logon,             0, HLP_SET_LOG  },\r\n    { \"NOLOG\",      &sim_set_logoff,            0, HLP_SET_LOG  },\r\n    { \"DEBUG\",      &sim_set_debon,             0, HLP_SET_DEBUG  },\r\n    { \"NODEBUG\",    &sim_set_deboff,            0, HLP_SET_DEBUG  },\r\n    { \"THROTTLE\",   &sim_set_throt,             1, HLP_SET_THROTTLE },\r\n    { \"NOTHROTTLE\", &sim_set_throt,             0, HLP_SET_THROTTLE },\r\n    { \"CLOCKS\",     &sim_set_timers,            1, HLP_SET_CLOCK },\r\n    { \"ASYNCH\",     &sim_set_asynch,            1, HLP_SET_ASYNCH },\r\n    { \"NOASYNCH\",   &sim_set_asynch,            0, HLP_SET_ASYNCH },\r\n    { \"ENVIRONMENT\", &sim_set_environment,      1, HLP_SET_ENVIRON },\r\n    { \"ON\",         &set_on,                    1, HLP_SET_ON },\r\n    { \"NOON\",       &set_on,                    0, HLP_SET_ON },\r\n    { \"VERIFY\",     &set_verify,                1, HLP_SET_VERIFY },\r\n    { \"VERBOSE\",    &set_verify,                1, HLP_SET_VERIFY },\r\n    { \"NOVERIFY\",   &set_verify,                0, HLP_SET_VERIFY },\r\n    { \"NOVERBOSE\",  &set_verify,                0, HLP_SET_VERIFY },\r\n    { \"MESSAGE\",    &set_message,               1, HLP_SET_MESSAGE },\r\n    { \"NOMESSAGE\",  &set_message,               0, HLP_SET_MESSAGE },\r\n    { \"QUIET\",      &set_quiet,                 1, HLP_SET_QUIET },\r\n    { \"NOQUIET\",    &set_quiet,                 0, HLP_SET_QUIET },\r\n    { \"PROMPT\",     &set_prompt,                0, HLP_SET_PROMPT },\r\n    { \"RUNLIMIT\",   &set_runlimit,              1, HLP_RUNLIMIT },\r\n    { \"NORUNLIMIT\", &set_runlimit,              0, HLP_RUNLIMIT },\r\n    { \"NOAUTOSIZE\", &sim_disk_set_all_noautosize, 1, HLP_NOAUTOSIZE },\r\n    { \"AUTOSIZE\",   &sim_disk_set_all_noautosize, 0, HLP_NOAUTOSIZE },\r\n    { \"AUTOZAP\",    &sim_disk_set_all_autozap,  1, HLP_AUTOZAP },\r\n    { \"NOAUTOZAP\",  &sim_disk_set_all_autozap,  0, HLP_AUTOZAP },\r\n    { NULL,         NULL,                       0 }\r\n    };\r\n\r\nstatic C1TAB set_dev_tab[] = {\r\n    { \"OCTAL\",      &set_dev_radix,     8 },\r\n    { \"DECIMAL\",    &set_dev_radix,     10 },\r\n    { \"HEX\",        &set_dev_radix,     16 },\r\n    { \"BINARY\",     &set_dev_radix,     2 },\r\n    { \"ENABLED\",    &set_dev_enbdis,    1 },\r\n    { \"DISABLED\",   &set_dev_enbdis,    0 },\r\n    { \"DEBUG\",      &set_dev_debug,     1 },\r\n    { \"NODEBUG\",    &set_dev_debug,     0 },\r\n    { \"APPEND\",     &set_unit_append,   0 },\r\n    { \"EOF\",        &set_unit_append,   0 },\r\n    { NULL,         NULL,               0 }\r\n    };\r\n\r\nstatic C1TAB set_unit_tab[] = {\r\n    { \"ENABLED\",    &set_unit_enbdis,   1 },\r\n    { \"DISABLED\",   &set_unit_enbdis,   0 },\r\n    { \"DEBUG\",      &set_dev_debug,     2+1 },\r\n    { \"NODEBUG\",    &set_dev_debug,     2+0 },\r\n    { \"APPEND\",     &set_unit_append,   0 },\r\n    { \"EOF\",        &set_unit_append,   0 },\r\n    { NULL,         NULL,               0 }\r\n    };\r\n\r\nstatic SHTAB show_glob_tab[] = {\r\n    { \"CONFIGURATION\",  &show_config,               0, HLP_SHOW_CONFIG },\r\n    { \"DEVICES\",        &show_config,               1, HLP_SHOW_DEVICES },\r\n    { \"FEATURES\",       &show_config,               2, HLP_SHOW_FEATURES },\r\n    { \"QUEUE\",          &show_queue,                0, HLP_SHOW_QUEUE },\r\n    { \"TIME\",           &show_time,                 0, HLP_SHOW_TIME },\r\n    { \"MODIFIERS\",      &show_mod_names,            0, HLP_SHOW_MODIFIERS },\r\n    { \"NAMES\",          &show_log_names,            0, HLP_SHOW_NAMES },\r\n    { \"SHOW\",           &show_show_commands,        0, HLP_SHOW_SHOW },\r\n    { \"VERSION\",        &show_version,              1, HLP_SHOW_VERSION },\r\n    { \"DEFAULT\",        &show_default,              0, HLP_SHOW_DEFAULT },\r\n    { \"CONSOLE\",        &sim_show_console,          0, HLP_SHOW_CONSOLE },\r\n    { \"REMOTE\",         &sim_show_remote_console,   0, HLP_SHOW_REMOTE },\r\n    { \"BREAK\",          &show_break,                0, HLP_SHOW_BREAK },\r\n    { \"LOG\",            &sim_show_log,              0, HLP_SHOW_LOG },\r\n    { \"TELNET\",         &sim_show_telnet,           0 },    /* deprecated */\r\n    { \"DEBUG\",          &sim_show_debug,            0, HLP_SHOW_DEBUG },\r\n    { \"THROTTLE\",       &sim_show_throt,            0, HLP_SHOW_THROTTLE },\r\n    { \"ASYNCH\",         &sim_show_asynch,           0, HLP_SHOW_ASYNCH },\r\n    { \"ETHERNET\",       &eth_show_devices,          0, HLP_SHOW_ETHERNET },\r\n    { \"SERIAL\",         &sim_show_serial,           0, HLP_SHOW_SERIAL },\r\n    { \"SYNCHRONOUS\",    &tmxr_show_sync_devices,    0, HLP_SHOW_SYNC },\r\n    { \"MULTIPLEXER\",    &tmxr_show_open_devices,    0, HLP_SHOW_MULTIPLEXER },\r\n    { \"MUX\",            &tmxr_show_open_devices,    0, HLP_SHOW_MULTIPLEXER },\r\n    { \"VIDEO\",          &vid_show,                  0, HLP_SHOW_VIDEO },\r\n    { \"CLOCKS\",         &sim_show_timers,           0, HLP_SHOW_CLOCKS },\r\n    { \"SEND\",           &sim_show_send,             0, HLP_SHOW_SEND },\r\n    { \"EXPECT\",         &sim_show_expect,           0, HLP_SHOW_EXPECT },\r\n    { \"ON\",             &show_on,                  -1, HLP_SHOW_ON },\r\n    { \"DO\",             &show_do,                   0, HLP_SHOW_DO },\r\n    { \"RUNLIMIT\",       &show_runlimit,             0, HLP_SHOW_RUNLIMIT },\r\n    { NULL,             NULL,                       0 }\r\n    };\r\n\r\nstatic SHTAB show_dev_tab[] = {\r\n    { \"RADIX\",      &show_dev_radix,            0 },\r\n    { \"DEBUG\",      &show_dev_debug,            0 },\r\n    { \"MODIFIERS\",  &show_dev_modifiers,        0 },\r\n    { \"NAMES\",      &show_dev_logicals,         0 },\r\n    { \"SHOW\",       &show_dev_show_commands,    0 },\r\n    { NULL,         NULL,                       0 }\r\n    };\r\n\r\nstatic SHTAB show_unit_tab[] = {\r\n    { \"DEBUG\",      &show_dev_debug,            1 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\n\r\n#if defined(_WIN32) || defined(__hpux)\r\nint setenv(const char *envname, const char *envval, int overwrite)\r\n{\r\nchar *envstr = (char *)malloc(strlen(envname)+strlen(envval)+2);\r\nint r;\r\n\r\nsprintf(envstr, \"%s=%s\", envname, envval);\r\n#if defined(_WIN32)\r\nr = _putenv(envstr);\r\nfree(envstr);\r\n#else\r\nr = putenv(envstr);\r\n#endif\r\nreturn r;\r\n}\r\n\r\nstatic\r\nint unsetenv(const char *envname)\r\n{\r\nsetenv(envname, \"\", 1);\r\nreturn 0;\r\n}\r\n#endif\r\n\r\n\r\nstatic FILE *fopen_tempfile (char **tmpname)\r\n{\r\n#ifdef _WIN32\r\nFILE *tmp = NULL;\r\n\r\ndo {\r\n    int fd;\r\n    *tmpname = _tempnam (NULL, \"simh\");\r\n    fd = _open (*tmpname, _O_CREAT | _O_RDWR | _O_EXCL, _S_IREAD | _S_IWRITE);\r\n    if (fd != -1) {\r\n        tmp = _fdopen (fd, \"w+\");\r\n        break;\r\n        }\r\n    } while (1);\r\n#else\r\nFILE *tmp = tmpfile();\r\n\r\n*tmpname = NULL;\r\n#endif\r\n\r\nif (tmp == NULL) {\r\n    fprintf (stderr, \"Unable to create temporary file: %s\\n\", strerror (errno));\r\n    free (*tmpname);\r\n    }\r\nreturn tmp;\r\n}\r\n\r\nstatic void fclose_tempfile (FILE *file, char **tmpname)\r\n{\r\nif (file != NULL)\r\n    fclose (file);\r\n#if defined _WIN32\r\nunlink (*tmpname);\r\nfree (*tmpname);\r\n*tmpname = NULL;\r\n#endif\r\n}\r\n\r\nstatic t_stat sim_snprint_sym (char *buf, size_t bufsize, t_bool vm_flag, t_addr addr, t_value *val, UNIT *uptr, int32 sw, int32 dfltinc, int32 rdx, uint32 width, uint32 fmt)\r\n{\r\nt_stat reason;\r\nMEMFILE mbuf;\r\n\r\nmemset (&mbuf, 0, sizeof (mbuf));\r\nmbuf.buf = malloc (512);            /* Pre allocate a memory buffer to avoid */\r\nmbuf.size = 512;                    /* potential double vsnprintf to expand the buffer */\r\nsim_mfile = &mbuf;\r\nif (vm_flag || ((reason = fprint_sym (sim_tmpfile, addr, val, uptr, sw)) > 0)) {\r\n    fprint_val (sim_tmpfile, val[0], rdx, width, fmt);\r\n    reason = dfltinc;\r\n    }\r\nsim_mfile = NULL;\r\nstrlcpy (buf, mbuf.buf, MIN(bufsize, mbuf.pos + 1));\r\nfree (mbuf.buf);\r\nreturn reason;\r\n}\r\n\r\nstatic t_stat sim_fprint_sym (FILE *ofile, t_bool vm_flag, t_addr addr, t_value *val, UNIT *uptr, int32 sw, int32 dfltinc, int32 rdx, uint32 width, uint32 fmt)\r\n{\r\nchar buf[CBUFSIZE];\r\nt_stat r;\r\n\r\nr = sim_snprint_sym (buf, sizeof (buf), vm_flag, addr, val, uptr, sw, dfltinc, rdx, width, fmt);\r\nfprintf (ofile, \"%s\", buf);\r\nreturn r;\r\n}\r\n\r\nt_stat process_stdin_commands (t_stat stat, char *argv[], t_bool do_called);\r\n\r\n/* Main command loop */\r\n\r\nint main (int argc, char *argv[])\r\n{\r\nchar cbuf[4*CBUFSIZE], *cptr, *cptr2;\r\nchar nbuf[PATH_MAX + 7];\r\nchar **targv = NULL;\r\nint32 i, sw;\r\nt_bool lookswitch;\r\nt_bool register_check = FALSE;\r\nt_bool device_unit_tests = FALSE;\r\nt_stat stat = SCPE_OK;\r\nCTAB *docmdp = NULL;\r\n\r\n/* Make sure that argv has at least 10 elements and that it ends in a NULL pointer */\r\ntargv = (char **)calloc (1+MAX(10, argc), sizeof(*targv));\r\nfor (i=0; i<argc; i++)\r\n    targv[i] = argv[i];\r\nargv = targv;\r\nset_prompt (0, \"sim>\");                                 /* start with set standard prompt */\r\n*cbuf = 0;                                              /* init arg buffer */\r\nsim_switches = 0;                                       /* init switches */\r\nlookswitch = TRUE;\r\nstdnul = fopen(NULL_DEVICE,\"wb\");\r\nsim_prog_name = argv [0];                               /* save a pointer to the program name */\r\nif (argc > 1) {                                         /* Check for special argument to invoke register test */\r\n    if (sim_strcasecmp (argv[1], \"RegisterSanityCheck\") == 0) {\r\n        register_check = TRUE;\r\n        /* Remove special argument to avoid confusion later */\r\n        for (i = 1; i < argc; i++)\r\n            argv[i] = argv[i+1];\r\n        --argc;\r\n        }\r\n    }\r\nif (argc > 1) {                                         /* Check for special argument to invoke device unit tests */\r\n    if (sim_strcasecmp (argv[1], \"DeviceUnitTests\") == 0) {\r\n        device_unit_tests = TRUE;\r\n        /* Remove special argument to avoid confusion later */\r\n        for (i = 1; i < argc; i++)\r\n            argv[i] = argv[i+1];\r\n        --argc;\r\n        }\r\n    }\r\nif (argc > 1) {                                         /* Check for special argument to turn on debug during initialization code */\r\n    if (sim_strcasecmp (argv[1], \"DebugInit\") == 0) {\r\n        sim_scp_dev.dctrl = SIM_DBG_INIT;\r\n        sim_switches |= SWMASK ('F');\r\n        sim_set_debon (1, \"STDOUT\");\r\n        sim_switches &= ~SWMASK ('F');\r\n        /* Remove special argument to avoid confusion later */\r\n        for (i = 1; i < argc; i++)\r\n            argv[i] = argv[i+1];\r\n        --argc;\r\n        }\r\n    }\r\nfor (i = 1; i < argc; i++) {                            /* loop thru args */\r\n    if (argv[i] == NULL)                                /* paranoia */\r\n        continue;\r\n    if ((*argv[i] == '-') && lookswitch) {              /* switch? */\r\n        int arg;\r\n\r\n        if (get_switches (argv[i], &sw, NULL) == SW_ERROR) {\r\n            fprintf (stderr, \"Invalid switch %s\\n\", argv[i]);\r\n            free (targv);\r\n            return EXIT_FAILURE;\r\n            }\r\n        sim_switches = sim_switches | sw;\r\n        /* Remove digested switch special argument to avoid confusion later */\r\n        for (arg = i + 1; argv[arg] != NULL; arg++)\r\n            argv[arg - 1] = argv[arg];\r\n        argv[arg] = NULL;\r\n        --argc;\r\n        --i;\r\n        }\r\n    else {\r\n        if ((strlen (argv[i]) + strlen (cbuf) + 3) >= sizeof(cbuf)) {\r\n            fprintf (stderr, \"Argument string too long\\n\");\r\n            free (targv);\r\n            return EXIT_FAILURE;\r\n            }\r\n        if (*cbuf)                                      /* concat args */\r\n            strlcat (cbuf, \" \", sizeof (cbuf));\r\n        sprintf(&cbuf[strlen(cbuf)], \"%s%s%s\", strchr(argv[i], ' ') ? \"\\\"\" : \"\", argv[i], strchr(argv[i], ' ') ? \"\\\"\" : \"\");\r\n        lookswitch = FALSE;                             /* no more switches */\r\n        }\r\n    }                                                   /* end for */\r\nif (*argv[0]) {                                         /* sim name arg? */\r\n    char *np;                                           /* \"path.ini\" */\r\n\r\n    strlcpy (nbuf, argv[0], PATH_MAX + 2);              /* copy sim name */\r\n    if ((np = (char *)match_ext (nbuf, \"EXE\")))         /* remove .exe */\r\n        *np = 0;\r\n    np = strrchr (nbuf, '/');                           /* strip path and try again in cwd */\r\n    if (np == NULL)\r\n        np = strrchr (nbuf, '\\\\');                      /* windows path separator */\r\n    if (np == NULL)\r\n        np = strrchr (nbuf, ']');                       /* VMS path separator */\r\n    if (np != NULL)\r\n        setenv (\"SIM_BIN_NAME\", np+1, 1);               /* Publish simulator binary name */\r\n    else\r\n        setenv (\"SIM_BIN_NAME\", nbuf, 1);               /* Publish simulator binary name */\r\n    setenv (\"SIM_BIN_PATH\", argv[0], 1);\r\n    }\r\n\r\nsim_quiet = sim_switches & SWMASK ('Q');                /* -q means quiet */\r\nsim_on_inherit = sim_switches & SWMASK ('O');           /* -o means inherit on state */\r\n\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Beginning SCP module initializations\\n\");\r\nsim_init_sock ();                                       /* init socket capabilities */\r\nAIO_INIT;                                               /* init Asynch I/O */\r\nsim_finit ();                                           /* init fio package */\r\nif (sim_disk_init () != SCPE_OK) {                      /* init disk package */\r\n    fprintf (stderr, \"Fatal sim_disk initialization error\\n\");\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    free (targv);\r\n    return EXIT_FAILURE;\r\n    }\r\nif (sim_tape_init () != SCPE_OK) {                      /* init tape package */\r\n    fprintf (stderr, \"Fatal sim_tape initialization error\\n\");\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    free (targv);\r\n    return EXIT_FAILURE;\r\n    }\r\nsim_exp_initialize ();                                  /* init expect package regex support */\r\nif ((argc > 2) &&\r\n    (sim_strcasecmp (argv[1], \"CheckSourceCode\") == 0)) {\r\n    if (sim_pcre_regex_available)\r\n        return sim_check_source (argc - 1, argv + 1);\r\n    sim_messagef (SCPE_NOFNC, \"Missing PCRE support.\\n\");\r\n    sim_messagef (SCPE_NOFNC, \"Install the Perl Compatible Regular Expression (PCRE) package for\\n\");\r\n    sim_messagef (SCPE_NOFNC, \"your system and try again.\\n\");\r\n    return EXIT_FAILURE;\r\n    }\r\n\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Merging External Environment variables overriding SCP commands\\n\");\r\nfor (i = 0; cmd_table[i].name; i++) {\r\n    size_t alias_len = strlen (cmd_table[i].name);\r\n    char *cmd_name = (char *)calloc (1 + alias_len, sizeof (*cmd_name));\r\n    char *env_cmd_val;\r\n    size_t env_cmd_val_len;\r\n\r\n    strcpy (cmd_name, cmd_table[i].name);\r\n    while (alias_len > 1) {\r\n        cmd_name[alias_len] = '\\0';                 /* Possible short form command name */\r\n        --alias_len;\r\n        env_cmd_val = getenv (cmd_name);\r\n        if (env_cmd_val) {                          /* Externally defined command alias? */\r\n            env_cmd_val_len = strlen (env_cmd_val);\r\n            ++sim_external_env_count;\r\n            sim_external_env = (struct deleted_env_var *)realloc (sim_external_env, sim_external_env_count * sizeof (*sim_external_env));\r\n            sim_external_env[sim_external_env_count - 1].name = (char *)malloc (1 + strlen (cmd_name));\r\n            strcpy (sim_external_env[sim_external_env_count - 1].name, cmd_name);\r\n            sim_external_env[sim_external_env_count - 1].value = (char *)malloc (1 + env_cmd_val_len);\r\n            strlcpy (sim_external_env[sim_external_env_count - 1].value, env_cmd_val, 1 + env_cmd_val_len);\r\n            unsetenv (cmd_name);                    /* Remove it to protect against possibly malicious aliases */\r\n            }\r\n        }\r\n    free (cmd_name);\r\n    }\r\nsetenv (\"SIM_NAME\", sim_name, 1);                       /* Publish simulator name */\r\nsim_tmpfile = fopen_tempfile (&sim_tmpnam);\r\nif (sim_tmpfile == NULL) {\r\n    fprintf (stderr, \"Can't open working temp file: %s - %s\\n\", (sim_tmpnam == NULL) ? \"\" : sim_tmpnam, strerror (errno));\r\n    free (targv);\r\n    return EXIT_FAILURE;\r\n    }\r\nstop_cpu = FALSE;\r\nsim_reset_time ();\r\nsim_clock_queue = QUEUE_LIST_END;\r\nsim_is_running = FALSE;\r\nsim_log = NULL;\r\nif (sim_emax <= 0)\r\n    sim_emax = 1;\r\nif (sim_timer_init ()) {\r\n    fprintf (stderr, \"Fatal timer initialization error\\n\");\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    free (targv);\r\n    return EXIT_FAILURE;\r\n    }\r\nsim_register_internal_device (&sim_scp_dev);\r\nsim_register_internal_device (&sim_expect_dev);\r\nsim_register_internal_device (&sim_step_dev);\r\nsim_register_internal_device (&sim_flush_dev);\r\nsim_register_internal_device (&sim_runlimit_dev);\r\n\r\nif ((stat = sim_ttinit ()) != SCPE_OK) {\r\n    fprintf (stderr, \"Fatal terminal initialization error\\n%s\\n\",\r\n        sim_error_text (stat));\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    sim_exit_status = EXIT_FAILURE;\r\n    goto cleanup_and_exit;\r\n    }\r\nif ((sim_eval = (t_value *) calloc (sim_emax, sizeof (t_value))) == NULL) {\r\n    fprintf (stderr, \"Unable to allocate examine buffer\\n\");\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    sim_exit_status = EXIT_FAILURE;\r\n    goto cleanup_and_exit;\r\n    };\r\nif (sim_dflt_dev == NULL)                               /* if no default */\r\n    sim_dflt_dev = sim_devices[0];\r\nif ((stat = reset_all_p (0)) != SCPE_OK) {\r\n    fprintf (stderr, \"Fatal simulator initialization error\\nDevice %s initial reset call returned: %s\\n\",\r\n        sim_failed_reset_dptr->name, sim_error_text (stat));\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    sim_exit_status = EXIT_FAILURE;\r\n    goto cleanup_and_exit;\r\n    }\r\nif (register_check) {\r\n    /* This test is explicitly run after the above reset_all_p() so that any devices\r\n       which dynamically manipulate their register lists have already done that. */\r\n    sim_printf (\" Running internal register sanity checks on %s simulator.\\n\", sim_name);\r\n    if ((stat = sim_sanity_check_register_declarations (NULL)) != SCPE_OK) {\r\n        sim_printf (\"Simulator device register sanity check error\\n\");\r\n        if (sim_ttisatty())\r\n            read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n        sim_exit_status = EXIT_FAILURE;\r\n        goto cleanup_and_exit;\r\n        }\r\n    sim_printf (\"*** Good Registers in %s simulator.\\n\", sim_name);\r\n    if (argc < 2) {                                 /* No remaining command arguments? */\r\n        sim_exit_status = EXIT_SUCCESS;             /* then we're done */\r\n        goto cleanup_and_exit;\r\n        }\r\n    }\r\nif ((stat = sim_brk_init ()) != SCPE_OK) {\r\n    fprintf (stderr, \"Fatal breakpoint table initialization error\\n%s\\n\",\r\n        sim_error_text (stat));\r\n    if (sim_ttisatty())\r\n        read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n    sim_exit_status = EXIT_FAILURE;\r\n    goto cleanup_and_exit;\r\n    }\r\n/* always check for register definition problems, unless we already did that */\r\nif (register_check == FALSE)\r\n    sim_sanity_check_register_declarations (NULL);\r\n\r\nif (device_unit_tests) {\r\n    int i;\r\n    DEVICE *dptr;\r\n    int devices_with_tests = 0;\r\n\r\n    /* This test is explicitly run after the above reset_all_p() so that\r\n       the simulator is in its well initialized state before testing. */\r\n    for (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n        if (dptr->unit_test)\r\n            ++devices_with_tests;\r\n        }\r\n    if (devices_with_tests == 0) {\r\n        sim_printf (\"*** No device unit tests in this %s simulator.\\n\", sim_name);\r\n        sim_exit_status = EXIT_SUCCESS;\r\n        goto cleanup_and_exit;\r\n        }\r\n    sim_printf (\" Running device unit tests on %s simulator.\\n\", sim_name);\r\n    if ((stat = sim_device_unit_tests (argv[1])) != SCPE_OK) {\r\n        sim_printf (\"Simulator device unit tests error\\n\");\r\n        if (sim_ttisatty())\r\n            read_line_p (\"Hit Return to exit: \", cbuf, sizeof (cbuf) - 1, stdin);\r\n        sim_exit_status = EXIT_FAILURE;\r\n        goto cleanup_and_exit;\r\n        }\r\n    sim_printf (\"*** Good device unit tests in %s simulator.\\n\", sim_name);\r\n    if (argc < 2) {                                 /* No remaining command arguments? */\r\n        sim_exit_status = EXIT_SUCCESS;             /* then we're done */\r\n        goto cleanup_and_exit;\r\n        }\r\n    }\r\nsignal (SIGINT, int_handler);\r\nif (!sim_quiet) {\r\n    printf (\"\\n\");\r\n    show_version (stdout, NULL, NULL, 0, NULL);\r\n    }\r\nsim_timer_precalibrate_execution_rate ();\r\nsim_reset_time ();\r\nshow_version (stdnul, NULL, NULL, 1, NULL);             /* Quietly set SIM_OSTYPE */\r\nsim_argv = argv;\r\n\r\nif (sim_switches & SWMASK ('T'))                        /* Command Line -T switch */\r\n    stat = test_lib_cmd (0, \"ALL\");                     /* run library unit tests */\r\n\r\ncptr = getenv(\"HOME\");\r\nif (cptr == NULL) {\r\n    cptr = getenv(\"HOMEPATH\");\r\n    cptr2 = getenv(\"HOMEDRIVE\");\r\n    }\r\nelse\r\n    cptr2 = NULL;\r\ndocmdp = find_cmd (\"DO\");\r\nif (docmdp) {\r\n    if (cptr && (sizeof (nbuf) > strlen (cptr) + strlen (\"/simh.ini\") + 3)) {\r\n        snprintf(nbuf, sizeof (nbuf), \"\\\"%s%s%ssimh.ini\\\"\", cptr2 ? cptr2 : \"\", cptr, strchr (cptr, '/') ? \"/\" : \"\\\\\");\r\n        stat = docmdp->action (-1, nbuf);                   /* simh.ini proc cmd file */\r\n        }\r\n    else\r\n        stat = SCPE_OPENERR;\r\n    if (SCPE_BARE_STATUS(stat) == SCPE_OPENERR)\r\n        stat = docmdp->action (-1, \"simh.ini\");             /* simh.ini proc cmd file */\r\n    if (*cbuf)                                              /* cmd file arg? */\r\n        stat = docmdp->action (0, cbuf);                    /* proc cmd file */\r\n    else {\r\n        if (*argv[0]) {                                    /* sim name arg? */\r\n            char *np;                                      /* \"path.ini\" */\r\n            nbuf[0] = '\"';                                 /* starting \" */\r\n            strlcpy (nbuf + 1, argv[0], PATH_MAX + 2);     /* copy sim name */\r\n            if ((np = (char *)match_ext (nbuf, \"EXE\")))    /* remove .exe */\r\n                *np = 0;\r\n            strlcat (nbuf, \".ini\\\"\", sizeof (nbuf));       /* add .ini\" */\r\n            stat = docmdp->action (-1, nbuf) & ~SCPE_NOMESSAGE; /* proc default cmd file */\r\n            if (stat == SCPE_OPENERR) {                    /* didn't exist/can't open? */\r\n                np = strrchr (nbuf, '/');                  /* strip path and try again in cwd */\r\n                if (np == NULL)\r\n                    np = strrchr (nbuf, '\\\\');             /* windows path separator */\r\n                if (np == NULL)\r\n                    np = strrchr (nbuf, ']');              /* VMS path separator */\r\n                if (np != NULL) {\r\n                    *np = '\"';\r\n                    stat = docmdp->action (-1, np) & ~SCPE_NOMESSAGE;/* proc default cmd file */\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\nif (SCPE_BARE_STATUS(stat) == SCPE_OPENERR)             /* didn't exist/can't open? */\r\n    stat = SCPE_OK;\r\n\r\nif (SCPE_BARE_STATUS(stat) != SCPE_EXIT)\r\n    process_stdin_commands (SCPE_BARE_STATUS(stat), argv, FALSE);\r\n\r\ncleanup_and_exit:\r\n\r\ndetach_all (0, TRUE);                                   /* close files */\r\nsim_set_deboff (0, NULL);                               /* close debug */\r\nsim_set_logoff (0, NULL);                               /* close log */\r\nsim_set_notelnet (0, NULL);                             /* close Telnet */\r\nvid_close_all ();                                       /* close video */\r\nsim_ttclose ();                                         /* close console */\r\nAIO_CLEANUP;                                            /* Asynch I/O */\r\nsim_cleanup_sock ();                                    /* cleanup sockets */\r\nfclose (stdnul);                                        /* close bit bucket file handle */\r\nfclose_tempfile (sim_tmpfile, &sim_tmpnam);             /* close temporary work file */\r\nfree (targv);                                           /* release any argv copy that was made */\r\nreturn sim_exit_status;\r\n}\r\n\r\nt_stat process_stdin_commands (t_stat stat, char *argv[], t_bool do_called)\r\n{\r\nchar cbuf[4*CBUFSIZE], gbuf[CBUFSIZE];\r\nCONST char *cptr = NULL;\r\nt_stat stat_nomessage;\r\nCTAB *cmdp = NULL;\r\n\r\nstat = SCPE_BARE_STATUS(stat);                          /* remove possible flag */\r\nwhile (stat != SCPE_EXIT) {                             /* in case exit */\r\n    if (stop_cpu) {                                     /* SIGINT happened? */\r\n        stop_cpu = FALSE;\r\n        if ((!sim_ttisatty()) ||\r\n            sigterm_received) {\r\n            stat = SCPE_EXIT;\r\n            break;\r\n            }\r\n        if (sim_on_actions[sim_do_depth][ON_SIGINT_ACTION])\r\n            sim_brk_setact (sim_on_actions[sim_do_depth][ON_SIGINT_ACTION]);\r\n        }\r\n    sim_do_ocptr[sim_do_depth] = cptr = sim_brk_getact (cbuf, sizeof(cbuf)); /* get bkpt action */\r\n    if (sim_do_ocptr[sim_do_depth]) {                   /* pending action? */\r\n        if (sim_do_echo)\r\n            printf (\"%s+ %s\\n\", sim_prompt, cptr);      /* echo */\r\n        sim_cptr_is_action[sim_do_depth] = TRUE;\r\n        }\r\n    else {\r\n        if (sim_vm_read != NULL) {                      /* sim routine? */\r\n            printf (\"%s\", sim_prompt);                  /* prompt */\r\n            cptr = (*sim_vm_read) (cbuf, sizeof(cbuf), stdin);\r\n            }\r\n        else\r\n            cptr = read_line_p (sim_prompt, cbuf, sizeof(cbuf), stdin);/* read with prompt*/\r\n        sim_do_ocptr[sim_do_depth] = cptr;\r\n        sim_cptr_is_action[sim_do_depth] = FALSE;\r\n        }\r\n    if (cptr == NULL) {                                 /* EOF? or SIGINT? */\r\n        if (sim_ttisatty()) {\r\n            printf (\"\\n\");\r\n            continue;                                   /* ignore tty EOF */\r\n            }\r\n        else\r\n            break;                                      /* otherwise exit */\r\n        }\r\n    if (*cptr == 0)                                     /* ignore blank */\r\n        continue;\r\n    sim_cmd_echoed = TRUE;\r\n    sim_sub_args (cbuf, sizeof(cbuf), argv);\r\n    if (sim_log)                                        /* log cmd */\r\n        fprintf (sim_log, \"%s%s\\n\", sim_prompt, cptr);\r\n    if (sim_deb && (sim_deb != sim_log) && (sim_deb != stdout))\r\n        fprintf (sim_deb, \"%s%s\\n\", sim_prompt, cptr);\r\n    cptr = get_glyph_cmd (cptr, gbuf);                  /* get command glyph */\r\n    sim_switches = 0;                                   /* init switches */\r\n    if (!sim_cptr_is_action[sim_do_depth]) {\r\n        sim_if_cmd_last[sim_do_depth] = sim_if_cmd[sim_do_depth];\r\n        sim_if_result_last[sim_do_depth] = sim_if_result[sim_do_depth];\r\n        sim_if_result[sim_do_depth] = sim_if_cmd[sim_do_depth] = FALSE;\r\n        }\r\n    if ((cmdp = find_cmd (gbuf))) {                     /* lookup command */\r\n        if (do_called && (cmdp->action == &return_cmd)) /* RETURN command? */\r\n            break;\r\n        stat = cmdp->action (cmdp->arg, cptr);          /* if found, exec */\r\n        }\r\n    else\r\n        stat = SCPE_UNK;\r\n    stat_nomessage = stat & SCPE_NOMESSAGE;             /* extract possible message suppression flag */\r\n    stat_nomessage = stat_nomessage || (!sim_show_message);/* Apply global suppression */\r\n    stat = SCPE_BARE_STATUS(stat);                      /* remove possible flag */\r\n    sim_last_cmd_stat = stat;                           /* save command error status */\r\n    if (!stat_nomessage) {                              /* displaying message status? */\r\n        if (cmdp && (cmdp->message))                    /* special message handler? */\r\n            cmdp->message (NULL, stat);                 /* let it deal with display */\r\n        else\r\n            if (stat >= SCPE_BASE)                      /* error? */\r\n                sim_printf (\"%s\\n\", sim_error_text (stat));\r\n        }\r\n    if ((sim_on_check[sim_do_depth]) &&\r\n        (stat != SCPE_OK)) {\r\n        if ((stat <= SCPE_MAX_ERR) && sim_on_actions[sim_do_depth][stat])\r\n            sim_brk_setact (sim_on_actions[sim_do_depth][stat]);\r\n        else\r\n            sim_brk_setact (sim_on_actions[sim_do_depth][0]);\r\n        }\r\n    if (sim_vm_post != NULL)\r\n        (*sim_vm_post) (TRUE);\r\n    }                                                   /* end while */\r\nif (do_called && cmdp &&\r\n    (cmdp->action == &return_cmd) && (0 != *cptr)) {    /* return command with argument? */\r\n    sim_string_to_stat (cptr, &stat);\r\n    sim_last_cmd_stat = stat;                           /* save explicit status as command error status */\r\n    if (sim_switches & SWMASK ('Q'))\r\n        stat |= SCPE_NOMESSAGE;                         /* suppress error message display (in caller) if requested */\r\n    return stat;                                        /* return with explicit return status */\r\n    }\r\nreturn stat;\r\n}\r\n\r\n/* Set prompt routine */\r\n\r\nt_stat set_prompt (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE], *gptr;\r\n\r\nif ((!cptr) || (*cptr == '\\0'))\r\n    return SCPE_IERR;\r\n\r\ncptr = get_glyph_nc (cptr, gbuf, '\"');                  /* get quote delimited token */\r\nif (gbuf[0] == '\\0') {                                  /* Token started with quote */\r\n    gbuf[sizeof (gbuf)-1] = '\\0';\r\n    strlcpy (gbuf, cptr, sizeof (gbuf));\r\n    gptr = strchr (gbuf, '\"');\r\n    if (gptr)\r\n        *gptr = '\\0';\r\n    }\r\nsim_prompt = (char *)realloc (sim_prompt, strlen (gbuf) + 2);   /* nul terminator and trailing blank */\r\nsprintf (sim_prompt, \"%s \", gbuf);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Find command routine */\r\n\r\nCTAB *find_cmd (const char *gbuf)\r\n{\r\nCTAB *cmdp = NULL;\r\n\r\nif (sim_vm_cmd)                                         /* try ext commands */\r\n    cmdp = find_ctab (sim_vm_cmd, gbuf);\r\nif (cmdp == NULL)                                       /* try regular cmds */\r\n    cmdp = find_ctab (cmd_table, gbuf);\r\nreturn cmdp;\r\n}\r\n\r\n/* Exit command */\r\n\r\nt_stat exit_cmd (int32 flag, CONST char *cptr)\r\n{\r\nt_stat r = SCPE_EXIT;\r\n\r\nif (cptr && *cptr) {\r\n    sim_exit_status = atoi (cptr);\r\n    r |= SCPE_NOMESSAGE;            /* exit silently with the specified status */\r\n    }\r\nif (sim_deb) {                      /* If debugging, then close debugging cleanly */\r\n    sim_switches |= SWMASK ('Q');   /*   and quietly */\r\n    sim_set_deboff (0, NULL);\r\n    }\r\nreturn r;\r\n}\r\n\r\n/* Help command */\r\n\r\n\r\n/* Used when sorting a list of command names */\r\nstatic int _cmd_name_compare (const void *pa, const void *pb)\r\n{\r\nCTAB * const *a = (CTAB * const *)pa;\r\nCTAB * const *b = (CTAB * const *)pb;\r\n\r\nreturn strcmp((*a)->name, (*b)->name);\r\n}\r\n\r\nvoid fprint_help (FILE *st)\r\n{\r\nCTAB *cmdp;\r\nCTAB **hlp_cmdp = NULL;\r\nint cmd_cnt = 0;\r\nint cmd_size = 0;\r\nsize_t max_cmdname_size = 0;\r\nint i, line_offset;\r\n\r\nfor (cmdp = sim_vm_cmd; cmdp && (cmdp->name != NULL); cmdp++) {\r\n    if (cmdp->help) {\r\n        if (cmd_cnt >= cmd_size) {\r\n            cmd_size += 20;\r\n            hlp_cmdp = (CTAB **)realloc (hlp_cmdp, sizeof(*hlp_cmdp)*cmd_size);\r\n            }\r\n        hlp_cmdp[cmd_cnt] = cmdp;\r\n        ++cmd_cnt;\r\n        if (strlen(cmdp->name) > max_cmdname_size)\r\n            max_cmdname_size = strlen(cmdp->name);\r\n        }\r\n    }\r\nfor (cmdp = cmd_table; cmdp && (cmdp->name != NULL); cmdp++) {\r\n    if (cmdp->help && (!sim_vm_cmd || !find_ctab (sim_vm_cmd, cmdp->name))) {\r\n        if (cmd_cnt >= cmd_size) {\r\n            cmd_size += 20;\r\n            hlp_cmdp = (CTAB **)realloc (hlp_cmdp, sizeof(*hlp_cmdp)*cmd_size);\r\n            }\r\n        hlp_cmdp[cmd_cnt] = cmdp;\r\n        ++cmd_cnt;\r\n        if (strlen (cmdp->name) > max_cmdname_size)\r\n            max_cmdname_size = strlen(cmdp->name);\r\n        }\r\n    }\r\nfprintf (st, \"Help is available for devices\\n\\n\");\r\nfprintf (st, \"   HELP dev\\n\");\r\nfprintf (st, \"   HELP dev SET\\n\");\r\nfprintf (st, \"   HELP dev SHOW\\n\");\r\nfprintf (st, \"   HELP dev REGISTERS\\n\\n\");\r\nfprintf (st, \"Help is available for the following commands:\\n\\n    \");\r\nif (hlp_cmdp)\r\n    qsort (hlp_cmdp, cmd_cnt, sizeof(*hlp_cmdp), _cmd_name_compare);\r\nline_offset = 4;\r\nfor (i=0; i<cmd_cnt; ++i) {\r\n    fputs (hlp_cmdp[i]->name, st);\r\n    line_offset += 5 + max_cmdname_size;\r\n    if (line_offset + max_cmdname_size > 79) {\r\n        line_offset = 4;\r\n        fprintf (st, \"\\n    \");\r\n        }\r\n    else\r\n        fprintf (st, \"%*s\", (int)(max_cmdname_size + 5 - strlen (hlp_cmdp[i]->name)), \"\");\r\n    }\r\nfree (hlp_cmdp);\r\nfprintf (st, \"\\n\");\r\n}\r\n\r\nstatic void fprint_header (FILE *st, t_bool *pdone, char *context)\r\n{\r\nif (!*pdone)\r\n    fprintf (st, \"%s\", context);\r\n*pdone = TRUE;\r\n}\r\n\r\nstatic void fprint_wrapped (FILE *st, const char *buf, size_t width, const char *gap, const char *extra, size_t max_width)\r\n{\r\nsize_t line_pos = MAX (width, strlen (buf));\r\nconst char *end;\r\n\r\nif ((strlen (buf) >= max_width) &&\r\n    (NULL != strchr (buf, '=')) &&\r\n    (NULL != strchr (strchr (buf, '='), ';')) ) {\r\n    int chunk_size;\r\n    const char *front_gap = strchr (buf, '=');\r\n    size_t front_gap_size = front_gap - buf + 1;\r\n\r\n    line_pos = 0;\r\n    end = buf + strlen (buf);\r\n    while (1) {\r\n        chunk_size = (end - buf);\r\n        if (line_pos + chunk_size >= max_width)\r\n            chunk_size = max_width - line_pos - 1;\r\n        else\r\n            break;\r\n        while ((chunk_size > 0) &&\r\n               (buf[chunk_size - 1] != ';'))\r\n               --chunk_size;\r\n        if (chunk_size == 0)\r\n            chunk_size = strlen (buf);\r\n        fprintf (st, \"%*s%*.*s\\n\", (int)(line_pos), \"\", chunk_size, chunk_size, buf);\r\n        buf += chunk_size;\r\n        while (isspace (buf[0]))\r\n            ++buf;\r\n        if (buf < end)\r\n            line_pos = front_gap_size;\r\n        }\r\n    fprintf (st, \"%*s%*.*s\", (int)(line_pos), \"\", chunk_size, chunk_size, buf);\r\n    line_pos = width + 1;\r\n    }\r\nelse\r\n    fprintf (st, \"%*s\", -((int)width), buf);\r\nif (line_pos > width) {\r\n    fprintf (st, \"\\n\");\r\n    if (extra == NULL)\r\n        return;\r\n    buf = \"\";\r\n    line_pos = width;\r\n    fprintf (st, \"%*s\", -((int)width), buf);\r\n    }\r\nend = extra + (extra ? strlen (extra) : 0);\r\nline_pos += (gap ? strlen (gap) : 0);\r\nif (line_pos + (end - extra) >= max_width) {\r\n    int chunk_size;\r\n\r\n    while (1) {\r\n        chunk_size = (end - extra);\r\n        if (line_pos + chunk_size >= max_width)\r\n            chunk_size = max_width - line_pos - 1;\r\n        else\r\n            break;\r\n        while ((chunk_size > 0) &&\r\n               (extra[chunk_size] != ' '))\r\n               --chunk_size;\r\n        if (chunk_size == 0)\r\n            chunk_size = strlen (extra);\r\n        fprintf (st, \"%s%*.*s\\n\", gap ? gap : \"\", chunk_size, chunk_size, extra);\r\n        extra += chunk_size;\r\n        while (isspace (extra[0]))\r\n            ++extra;\r\n        if (extra < end) {\r\n            line_pos = width;\r\n            fprintf (st, \"%*s\", -((int)width), \"\");\r\n            line_pos += (gap ? strlen (gap) : 0);\r\n            }\r\n        else\r\n            return;\r\n        }\r\n    }\r\nfprintf (st, \"%s%s\\n\", gap ? gap : \"\", extra ? extra : \"\");\r\n}\r\n\r\nvoid fprint_reg_help_ex (FILE *st, DEVICE *dptr, t_bool silent)\r\n{\r\nREG *rptr, *trptr;\r\nt_bool found = FALSE;\r\nt_bool all_unique = TRUE;\r\nsize_t max_namelen = 0;\r\nDEVICE *tdptr;\r\nCONST char *tptr;\r\nchar *namebuf;\r\nchar rangebuf[32];\r\nint side_effects = 0;\r\n\r\nif (!silent)\r\n    fprintf (st, \"\\n\");\r\nif (dptr->registers)\r\n    for (rptr = dptr->registers; rptr->name != NULL; rptr++) {\r\n        if (rptr->flags & REG_HIDDEN)\r\n            continue;\r\n        side_effects += ((rptr->flags & REG_DEPOSIT) != 0);\r\n        if (rptr->depth > 1)\r\n            snprintf (rangebuf, sizeof (rangebuf), \"[%d:%d]\", 0, rptr->depth-1);\r\n        else\r\n            strcpy (rangebuf, \"\");\r\n        if (max_namelen < (strlen (rptr->name) + strlen (rangebuf)))\r\n            max_namelen = strlen (rptr->name) + strlen (rangebuf);\r\n        found = TRUE;\r\n        trptr = find_reg_glob (rptr->name, &tptr, &tdptr);\r\n        if ((trptr == NULL) || (tdptr != dptr))\r\n            all_unique = FALSE;\r\n        }\r\nif (!found) {\r\n    if (!silent)\r\n        fprintf (st, \"No register help is available for the %s device\\n\", dptr->name);\r\n    }\r\nelse {\r\n    int i, hdr_len = 13 + (int)(max_namelen + (all_unique ? 0 : (1 + strlen (dptr->name))) + ((side_effects > 0) ? 0 : 1));\r\n\r\n    namebuf = (char *)calloc (max_namelen + 1, sizeof (*namebuf));\r\n    fprintf (st, \"\\nThe %s device implements these registers:\\n\\n\", dptr->name);\r\n    fprintf (st, \"  %*s Size %*sPurpose\\n\", -((int)(max_namelen + (all_unique ? 0 : (1 + strlen (dptr->name))))), \"Name\", (side_effects > 0) ? 0 : 1, \"\");\r\n    fprintf (st, \"  \");\r\n    for (i = 0; i < hdr_len; i++)\r\n        fprintf (st, \"-\");\r\n    fprintf (st, \"\\n\");\r\n    for (rptr = dptr->registers; rptr->name != NULL; rptr++) {\r\n        char note[2];\r\n        char buf[CBUFSIZE];\r\n\r\n        if (rptr->flags & REG_HIDDEN)\r\n            continue;\r\n        strlcpy (note, (side_effects != 0) ? ((rptr->flags & REG_DEPOSIT) ? \"+\" : \" \") : \"\", sizeof (note));\r\n        if (rptr->depth <= 1)\r\n            snprintf (namebuf, max_namelen + 1, \"%*s\", -((int)max_namelen), rptr->name);\r\n        else {\r\n            snprintf (rangebuf, sizeof (rangebuf), \"[%d:%d]\", 0, rptr->depth-1);\r\n            snprintf (namebuf, max_namelen + 1, \"%s%*s\", rptr->name, (int)(strlen (rptr->name))-((int)max_namelen), rangebuf);\r\n            }\r\n        if (all_unique) {\r\n            snprintf (buf, sizeof (buf), \"  %s %4d %s\", namebuf, rptr->width, note);\r\n            fprint_wrapped (st, buf, strlen (buf), \" \", rptr->desc, 80);\r\n            continue;\r\n            }\r\n        trptr = find_reg_glob (rptr->name, &tptr, &tdptr);\r\n        if ((trptr == NULL) || (tdptr != dptr))\r\n            snprintf (buf, sizeof (buf), \"  %s %s %4d %s\", dptr->name, namebuf, rptr->width, note);\r\n        else\r\n            snprintf (buf, sizeof (buf), \"  %*s %s %4d %s\", (int)strlen (dptr->name), \"\", namebuf, rptr->width, note);\r\n        fprint_wrapped (st, buf, strlen (buf), \" \", rptr->desc, 80);\r\n        }\r\n    free (namebuf);\r\n    if (side_effects)\r\n        fprintf (st, \"\\n  +  Deposits to %s register%s will have some additional\\n\"\r\n                       \"     side effects which can be suppressed if the deposit is\\n\"\r\n                       \"     done with the -Z switch specified\\n\",\r\n                                 (side_effects == 1) ? \"this\" : \"these\",\r\n                                 (side_effects == 1) ? \"\" : \"s\");\r\n    }\r\n}\r\n\r\nvoid fprint_reg_help (FILE *st, DEVICE *dptr)\r\n{\r\nfprint_reg_help_ex (st, dptr, TRUE);\r\n}\r\n\r\nvoid fprint_attach_help_ex (FILE *st, DEVICE *dptr, t_bool silent)\r\n{\r\nif (dptr->attach_help) {\r\n    fprintf (st, \"\\n%s device attach commands:\\n\\n\", dptr->name);\r\n    dptr->attach_help (st, dptr, NULL, 0, NULL);\r\n    return;\r\n    }\r\nif (DEV_TYPE(dptr) == DEV_MUX) {\r\n    fprintf (st, \"\\n%s device attach commands:\\n\\n\", dptr->name);\r\n    tmxr_attach_help (st, dptr, NULL, 0, NULL);\r\n    return;\r\n    }\r\nif (DEV_TYPE(dptr) == DEV_DISK) {\r\n    fprintf (st, \"\\n%s device attach commands:\\n\\n\", dptr->name);\r\n    sim_disk_attach_help (st, dptr, NULL, 0, NULL);\r\n    return;\r\n    }\r\nif (DEV_TYPE(dptr) == DEV_TAPE) {\r\n    fprintf (st, \"\\n%s device attach commands:\\n\\n\", dptr->name);\r\n    sim_tape_attach_help (st, dptr, NULL, 0, NULL);\r\n    return;\r\n    }\r\nif (DEV_TYPE(dptr) == DEV_ETHER) {\r\n    fprintf (st, \"\\n%s device attach commands:\\n\\n\", dptr->name);\r\n    eth_attach_help (st, dptr, NULL, 0, NULL);\r\n    return;\r\n    }\r\n#if defined(USE_SIM_CARD) && defined(SIM_CARD_API)\r\nif (DEV_TYPE(dptr) == DEV_CARD) {\r\n    fprintf (st, \"\\n%s device attach commands:\\n\\n\", dptr->name);\r\n    sim_card_attach_help (st, dptr, NULL, 0, NULL);\r\n    return;\r\n    }\r\n#endif\r\nif (!silent) {\r\n    fprintf (st, \"\\nNo ATTACH help is available for the %s device\\n\", dptr->name);\r\n    if (dptr->help)\r\n        dptr->help (st, dptr, NULL, 0, NULL);\r\n    }\r\n}\r\n\r\nvoid fprint_set_help_ex (FILE *st, DEVICE *dptr, t_bool silent)\r\n{\r\nMTAB *mptr;\r\nDEBTAB *dep;\r\nt_bool found = FALSE;\r\nt_bool deb_desc_available = FALSE;\r\nchar buf[CBUFSIZE], header[CBUFSIZE], extra[CBUFSIZE];\r\nuint32 enabled_units = dptr->numunits;\r\nchar unit_spec[50];\r\nuint32 unit, found_unit = 0;\r\nconst char *gap = \"  \";\r\n\r\nsprintf (header, \"\\n%s device SET commands:\\n\\n\", dptr->name);\r\nfor (unit=0; unit < dptr->numunits; unit++)\r\n    if (dptr->units[unit].flags & UNIT_DIS)\r\n        --enabled_units;\r\n    else\r\n        found_unit = unit;\r\nif (enabled_units == 1) {\r\n    if (found_unit == 0)\r\n        snprintf (unit_spec, sizeof (unit_spec), \"%s\", sim_dname (dptr));\r\n    else\r\n        snprintf (unit_spec, sizeof (unit_spec), \"%s\", sim_uname (&dptr->units[found_unit]));\r\n    }\r\nelse\r\n    snprintf (unit_spec, sizeof (unit_spec), \"%sn\", sim_dname (dptr));\r\nif (dptr->modifiers) {\r\n    for (mptr = dptr->modifiers; mptr->mask != 0; mptr++) {\r\n        if (!MODMASK(mptr,MTAB_VDV) && MODMASK(mptr,MTAB_VUN) && (dptr->numunits != 1))\r\n            continue;                                       /* skip unit only extended modifiers */\r\n        if ((enabled_units != 1) && !(mptr->mask & MTAB_XTD))\r\n            continue;                                       /* skip unit only simple modifiers */\r\n        if (mptr->mstring) {\r\n            fprint_header (st, &found, header);\r\n            snprintf (buf, sizeof (buf), \"set %s %s%s\", sim_dname (dptr), mptr->mstring, (strchr(mptr->mstring, '=')) ? \"\" : (MODMASK(mptr,MTAB_VALR) ? \"=val\" : (MODMASK(mptr,MTAB_VALO) ? \"{=val}\" : \"\")));\r\n            if ((mptr->valid != NULL) && (mptr->disp != NULL) && (mptr->help != NULL)) {\r\n                char gbuf[CBUFSIZE];\r\n                const char *rem;\r\n\r\n                rem = get_glyph (mptr->help, gbuf, 0);\r\n                if ((strcasecmp (gbuf, \"Display\") == 0) ||\r\n                    (strcasecmp (gbuf, \"Show\") == 0)) {\r\n                    char *thelp = (char *)malloc (9 + strlen (rem));\r\n\r\n                    sprintf (thelp, \"Specify %s\", rem);\r\n                    fprint_wrapped (st, buf, 30, gap, thelp, 80);\r\n                    free (thelp);\r\n                    }\r\n                else\r\n                    fprint_wrapped (st, buf, 30, gap, mptr->help, 80);\r\n                }\r\n            else\r\n                fprint_wrapped (st, buf, 30, gap, mptr->help, 80);\r\n            }\r\n        }\r\n    }\r\nif (dptr->flags & DEV_DISABLE) {\r\n    fprint_header (st, &found, header);\r\n    snprintf (buf, sizeof (buf), \"set %s ENABLE\", sim_dname (dptr));\r\n    snprintf (extra, sizeof (extra), \"Enables device %s\", sim_dname (dptr));\r\n    fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n    snprintf (buf, sizeof (buf), \"set %s DISABLE\", sim_dname (dptr));\r\n    snprintf (extra, sizeof (extra), \"Disables device %s\", sim_dname (dptr));\r\n    fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n    }\r\nif ((dptr->flags & DEV_DEBUG) || (dptr->debflags)) {\r\n    fprint_header (st, &found, header);\r\n    snprintf (buf, sizeof (buf), \"set %s DEBUG\", sim_dname (dptr));\r\n    snprintf (extra, sizeof (extra), \"Enables debugging for device %s\", sim_dname (dptr));\r\n    fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n    snprintf (buf, sizeof (buf), \"set %s NODEBUG\", sim_dname (dptr));\r\n    snprintf (extra, sizeof (extra), \"Disables debugging for device %s\", sim_dname (dptr));\r\n    fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n    if (dptr->debflags) {\r\n        snprintf (buf, sizeof (buf), \"set %s DEBUG=\", sim_dname (dptr));\r\n        for (dep = dptr->debflags; dep->name != NULL; dep++) {\r\n            strlcat (buf, ((dep == dptr->debflags) ? \"\" : \";\"), sizeof (buf));\r\n            strlcat (buf, dep->name, sizeof (buf));\r\n            deb_desc_available |= ((dep->desc != NULL) && (dep->desc[0] != '\\0'));\r\n            }\r\n        snprintf (extra, sizeof (extra), \"Enables specific debugging for device %s\", sim_dname (dptr));\r\n        fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n        snprintf (buf, sizeof (buf), \"set %s NODEBUG=\", sim_dname (dptr));\r\n        for (dep = dptr->debflags; dep->name != NULL; dep++) {\r\n            strlcat (buf, ((dep == dptr->debflags) ? \"\" : \";\"), sizeof (buf));\r\n            strlcat (buf, dep->name, sizeof (buf));\r\n            }\r\n        snprintf (extra, sizeof (extra), \"Disables specific debugging for device %s\", sim_dname (dptr));\r\n        fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n        }\r\n    }\r\nif ((dptr->modifiers) && (dptr->units)) {   /* handle unit specific modifiers */\r\n    if (dptr->units->flags & UNIT_DISABLE) {\r\n        fprint_header (st, &found, header);\r\n        snprintf (buf, sizeof (buf), \"set %s ENABLE\", unit_spec);\r\n        snprintf (extra, sizeof (extra), \"Enables unit %s\", unit_spec);\r\n        fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n        snprintf (buf, sizeof (buf), \"set %s DISABLE\", unit_spec);\r\n        snprintf (extra, sizeof (extra), \"Disables unit %s\", unit_spec);\r\n        fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n        }\r\n    if (((dptr->flags & DEV_DEBUG) || (dptr->debflags)) &&\r\n        ((DEV_TYPE(dptr) == DEV_DISK) || (DEV_TYPE(dptr) == DEV_TAPE)) &&\r\n        (dptr->numunits != 1)) {\r\n        snprintf (buf, sizeof (buf), \"set %s DEBUG\", unit_spec);\r\n        snprintf (extra, sizeof (extra), \"Enables debugging for device unit %s\", unit_spec);\r\n        fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n        snprintf (buf, sizeof (buf), \"set %s NODEBUG\", unit_spec);\r\n        snprintf (extra, sizeof (extra), \"Disables debugging for device unit %s\", unit_spec);\r\n        fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n        if (dptr->debflags) {\r\n            strcpy (buf, \"\");\r\n            fprintf (st, \"set %s DEBUG=\", unit_spec);\r\n            for (dep = dptr->debflags; dep->name != NULL; dep++)\r\n                fprintf (st, \"%s%s\", ((dep == dptr->debflags) ? \"\" : \";\"), dep->name);\r\n            fprintf (st, \"\\n\");\r\n            snprintf (extra, sizeof (extra), \"Enables specific debugging for device unit %s\", unit_spec);\r\n            fprint_wrapped (st, \"\", 30, gap, extra, 80);\r\n            fprintf (st, \"set %s NODEBUG=\", unit_spec);\r\n            for (dep = dptr->debflags; dep->name != NULL; dep++)\r\n                fprintf (st, \"%s%s\", ((dep == dptr->debflags) ? \"\" : \";\"), dep->name);\r\n            fprintf (st, \"\\n\");\r\n            snprintf (extra, sizeof (extra), \"Disables specific debugging for device unit %s\", unit_spec);\r\n            fprint_wrapped (st, \"\", 30, gap, extra, 80);\r\n            }\r\n        }\r\n    for (mptr = dptr->modifiers; mptr->mask != 0; mptr++) {\r\n        if ((!MODMASK(mptr,MTAB_VUN)) && MODMASK(mptr,MTAB_XTD))\r\n            continue;                                           /* skip device only modifiers */\r\n        if ((!mptr->valid) && MODMASK(mptr,MTAB_XTD))\r\n            continue;                                           /* skip show only modifiers */\r\n        if ((enabled_units == 1) && (found_unit == 0))\r\n            continue;\r\n        if (mptr->mstring) {\r\n            fprint_header (st, &found, header);\r\n            snprintf (buf, sizeof (buf), \"set %s %s%s\", unit_spec, mptr->mstring, (strchr(mptr->mstring, '=')) ? \"\" : (MODMASK(mptr,MTAB_VALR) ? \"=val\" : (MODMASK(mptr,MTAB_VALO) ? \"{=val}\": \"\")));\r\n            if ((mptr->valid != NULL) && (mptr->disp != NULL) && (mptr->help != NULL)) {\r\n                char gbuf[CBUFSIZE];\r\n                const char *rem;\r\n\r\n                rem = get_glyph (mptr->help, gbuf, 0);\r\n                if ((strcasecmp (gbuf, \"Display\") == 0) ||\r\n                    (strcasecmp (gbuf, \"Show\") == 0)) {\r\n                    char *thelp = (char *)malloc (9 + strlen (rem));\r\n\r\n                    sprintf (thelp, \"Specify %s\", rem);\r\n                    fprint_wrapped (st, buf, 30, gap, thelp, 80);\r\n                    free (thelp);\r\n                    }\r\n                else\r\n                    fprint_wrapped (st, buf, 30, gap, mptr->help, 80);\r\n                }\r\n            else\r\n                fprint_wrapped (st, buf, 30, gap, mptr->help, 80);\r\n            }\r\n        }\r\n    }\r\nif (enabled_units) {\r\n    for (unit=0; unit < dptr->numunits; unit++)\r\n        if ((!(dptr->units[unit].flags & UNIT_DIS)) &&\r\n            (dptr->units[unit].flags & UNIT_SEQ) &&\r\n            (!(dptr->units[unit].flags & UNIT_MUSTBUF))) {\r\n            snprintf (buf, sizeof (buf), \"set %s%s APPEND\", sim_uname (&dptr->units[unit]), (enabled_units > 1) ? \"n\" : \"\");\r\n            snprintf (extra, sizeof (extra), \"Sets %s%s position to EOF\", sim_uname (&dptr->units[unit]), (enabled_units > 1) ? \"n\" : \"\");\r\n            fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n            break;\r\n            }\r\n    }\r\nif (deb_desc_available) {\r\n    fprintf (st, \"\\n*%s device DEBUG settings:\\n\", sim_dname (dptr));\r\n    for (dep = dptr->debflags; dep->name != NULL; dep++)\r\n        fprintf (st, \"%4s%-12s%s\\n\", \"\", dep->name, dep->desc ? dep->desc : \"\");\r\n    }\r\nif (!found && !silent)\r\n    fprintf (st, \"No SET help is available for the %s device\\n\", dptr->name);\r\n}\r\n\r\nvoid fprint_set_help (FILE *st, DEVICE *dptr)\r\n    {\r\n    fprint_set_help_ex (st, dptr, TRUE);\r\n    }\r\n\r\nvoid fprint_show_help_ex (FILE *st, DEVICE *dptr, t_bool silent)\r\n{\r\nMTAB *mptr;\r\nt_bool found = FALSE;\r\nchar buf[CBUFSIZE], header[CBUFSIZE], extra[CBUFSIZE];\r\nuint32 enabled_units = dptr->numunits;\r\nchar unit_spec[50];\r\nuint32 unit, found_unit = 0;\r\nconst char *gap = \"  \";\r\n\r\nsprintf (header, \"\\n%s device SHOW commands:\\n\\n\", dptr->name);\r\nfor (unit=0; unit < dptr->numunits; unit++)\r\n    if (dptr->units[unit].flags & UNIT_DIS)\r\n        --enabled_units;\r\n    else\r\n        found_unit = unit;\r\nif (enabled_units == 1)\r\n    snprintf (unit_spec, sizeof (unit_spec), \"%s%u\", sim_dname (dptr), found_unit);\r\nelse\r\n    snprintf (unit_spec, sizeof (unit_spec), \"%sn\", sim_dname (dptr));\r\nif (dptr->modifiers) {\r\n    for (mptr = dptr->modifiers; mptr->mask != 0; mptr++) {\r\n        if (!MODMASK(mptr,MTAB_VDV) && MODMASK(mptr,MTAB_VUN) && (dptr->numunits != 1))\r\n            continue;                                       /* skip unit only extended modifiers */\r\n        if ((enabled_units != 1) && !(mptr->mask & MTAB_XTD))\r\n            continue;                                       /* skip unit only simple modifiers */\r\n        if ((!mptr->disp) || (!mptr->pstring) || !(*mptr->pstring))\r\n            continue;\r\n        fprint_header (st, &found, header);\r\n        sprintf (buf, \"show %s %s%s\", sim_dname (dptr), mptr->pstring, MODMASK(mptr,MTAB_SHP) ? \"{=arg}\" : \"\");\r\n        fprint_wrapped (st, buf, 30, gap, mptr->help, 80);\r\n        }\r\n    }\r\nif ((dptr->flags & DEV_DEBUG) || (dptr->debflags)) {\r\n    fprint_header (st, &found, header);\r\n    sprintf (buf, \"show %s DEBUG\", sim_dname (dptr));\r\n    sprintf (extra, \"Displays debugging status for device %s\", sim_dname (dptr));\r\n    fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n    }\r\nif (((dptr->flags & DEV_DEBUG) || (dptr->debflags)) &&\r\n    ((DEV_TYPE(dptr) == DEV_DISK) || (DEV_TYPE(dptr) == DEV_TAPE)) &&\r\n    (enabled_units != 1)) {\r\n    sprintf (buf, \"show %s DEBUG\", unit_spec);\r\n    sprintf (extra, \"Displays debugging status for device unit %s\", unit_spec);\r\n    fprint_wrapped (st, buf, 30, gap, extra, 80);\r\n    }\r\n\r\nif ((dptr->modifiers) && (dptr->units)) {   /* handle unit specific modifiers */\r\n    for (mptr = dptr->modifiers; mptr->mask != 0; mptr++) {\r\n        if ((!MODMASK(mptr,MTAB_VUN)) && MODMASK(mptr,MTAB_XTD))\r\n            continue;                                           /* skip device only modifiers */\r\n        if ((!mptr->disp) || (!mptr->pstring))\r\n            continue;\r\n        if (enabled_units == 1)\r\n            continue;                                           /* skip when only 1 unit */\r\n        fprint_header (st, &found, header);\r\n        sprintf (buf, \"show %s %s%s\", unit_spec, mptr->pstring, MODMASK(mptr,MTAB_SHP) ? \"=arg\" : \"\");\r\n        fprint_wrapped (st, buf, 30, gap, mptr->help, 80);\r\n        }\r\n    }\r\nif (!found && !silent)\r\n    fprintf (st, \"No SHOW help is available for the %s device\\n\", dptr->name);\r\n}\r\n\r\nvoid fprint_show_help (FILE *st, DEVICE *dptr)\r\n    {\r\n    fprint_show_help_ex (st, dptr, TRUE);\r\n    }\r\n\r\nvoid fprint_brk_help_ex (FILE *st, DEVICE *dptr, t_bool silent)\r\n{\r\nBRKTYPTAB *brkt = dptr->brk_types;\r\nchar gbuf[CBUFSIZE];\r\n\r\nfprintf (st, \"\\n\");\r\nif (sim_brk_types == 0) {\r\n    if ((dptr != sim_dflt_dev) && (!silent)) {\r\n        fprintf (st, \"Breakpoints are not supported in the %s simulator\\n\", sim_name);\r\n        if (dptr->help)\r\n            dptr->help (st, dptr, NULL, 0, NULL);\r\n        }\r\n    return;\r\n    }\r\nif (brkt == NULL) {\r\n    int i;\r\n\r\n    if (dptr == sim_dflt_dev) {\r\n        if (sim_brk_types & ~sim_brk_dflt) {\r\n            fprintf (st, \"%s supports the following breakpoint types:\\n\", sim_dname (dptr));\r\n            for (i=0; i<26; i++) {\r\n                if (sim_brk_types & (1<<i))\r\n                    fprintf (st, \"  -%c\\n\", 'A'+i);\r\n                }\r\n            }\r\n        fprintf (st, \"The default breakpoint type is: %s\\n\", put_switches (gbuf, sizeof(gbuf), sim_brk_dflt));\r\n        }\r\n    return;\r\n    }\r\nfprintf (st, \"%s supports the following breakpoint types:\\n\", sim_dname (dptr));\r\nwhile (brkt->btyp) {\r\n    fprintf (st, \"  %s     %s\\n\", put_switches (gbuf, sizeof(gbuf), brkt->btyp), brkt->desc);\r\n    ++brkt;\r\n    }\r\nfprintf (st, \"The default breakpoint type is: %s\\n\", put_switches (gbuf, sizeof(gbuf), sim_brk_dflt));\r\n}\r\n\r\nvoid fprint_brk_help (FILE *st, DEVICE *dptr)\r\n{\r\nfprint_brk_help_ex (st, dptr, TRUE);\r\n}\r\n\r\nt_stat help_dev_help (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCTAB *cmdp;\r\n\r\nif (*cptr) {\r\n    get_glyph (cptr, gbuf, 0);\r\n    if ((cmdp = find_cmd (gbuf))) {\r\n        if (cmdp->action == &exdep_cmd) {\r\n            if (dptr->help)\r\n                return dptr->help (st, dptr, uptr, flag, cmdp->name);\r\n            else\r\n                fprintf (st, \"No device specific help available for the %s %s command\\n\", cmdp->name, sim_dname(dptr));\r\n            return SCPE_OK;\r\n            }\r\n        if (cmdp->action == &set_cmd) {\r\n            fprint_set_help_ex (st, dptr, FALSE);\r\n            return SCPE_OK;\r\n            }\r\n        if (cmdp->action == &show_cmd) {\r\n            fprint_show_help_ex (st, dptr, FALSE);\r\n            return SCPE_OK;\r\n            }\r\n        if (cmdp->action == &attach_cmd) {\r\n            fprint_attach_help_ex (st, dptr, FALSE);\r\n            return SCPE_OK;\r\n            }\r\n        if (cmdp->action == &brk_cmd) {\r\n            fprint_brk_help_ex (st, dptr, FALSE);\r\n            return SCPE_OK;\r\n            }\r\n        if (dptr->help)\r\n            return dptr->help (st, dptr, uptr, flag, cptr);\r\n        fprintf (st, \"No %s help is available for the %s device\\n\", cmdp->name, dptr->name);\r\n        return SCPE_OK;\r\n        }\r\n    if (MATCH_CMD (gbuf, \"REGISTERS\") == 0) {\r\n        fprint_reg_help_ex (st, dptr, FALSE);\r\n        return SCPE_OK;\r\n        }\r\n    if (dptr->help)\r\n        return dptr->help (st, dptr, uptr, flag, cptr);\r\n    fprintf (st, \"No %s help is available for the %s device\\n\", gbuf, dptr->name);\r\n    return SCPE_OK;\r\n    }\r\nif (dptr->help) {\r\n    return dptr->help (st, dptr, uptr, flag, cptr);\r\n    }\r\nif (dptr->description)\r\n    fprintf (st, \"%s %s help\\n\", dptr->description (dptr), dptr->name);\r\nelse\r\n    fprintf (st, \"%s help\\n\", dptr->name);\r\nfprint_set_help_ex (st, dptr, TRUE);\r\nfprint_show_help_ex (st, dptr, TRUE);\r\nfprint_attach_help_ex (st, dptr, TRUE);\r\nfprint_reg_help_ex (st, dptr, TRUE);\r\nfprint_brk_help_ex (st, dptr, TRUE);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat help_cmd_output (int32 flag, const char *help, const char *help_base)\r\n{\r\nswitch (help[0]) {\r\n    case '*':\r\n        scp_help (stdout, NULL, NULL, flag, help_base ? help_base : simh_help, help+1);\r\n        if (sim_log && (!sim_oline))\r\n            scp_help (sim_log, NULL, NULL, flag | SCP_HELP_FLAT, help_base ? help_base : simh_help, help+1);\r\n        break;\r\n    default:\r\n        fputs (help, stdout);\r\n        if (sim_log && (!sim_oline))\r\n            fputs (help, sim_log);\r\n        break;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat help_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE], gbuf2[CBUFSIZE];\r\nCTAB *cmdp;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nt_stat r;\r\nstatic t_bool help_initialized = FALSE;\r\nt_bool explicit_device = FALSE;\r\n\r\nif (!help_initialized) {\r\n    simh_help = (char *)malloc (1 + strlen (simh_help1) + strlen (simh_help2));\r\n    strcpy (simh_help, simh_help1);\r\n    strcat (simh_help, simh_help2);\r\n    help_initialized = TRUE;\r\n    }\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (sim_switches & SWMASK ('F'))\r\n    flag = flag | SCP_HELP_FLAT;\r\nif (*cptr) {\r\n    cptr = get_glyph (cptr, gbuf, 0);\r\n\r\n    if ((0 == strncmp (gbuf, \"DEV\", 3)) &&\r\n        (0 == MATCH_CMD (gbuf, \"DEVICE\"))) {\r\n        explicit_device = TRUE;\r\n        cptr = get_glyph (cptr, gbuf, 0);\r\n        }\r\n    dptr = find_unit (gbuf, &uptr);\r\n    if ((dptr == NULL) &&\r\n        ((dptr = find_dev (gbuf)) == NULL)) {\r\n        if (explicit_device) {\r\n            int i;\r\n\r\n            if (0 != strcmp (gbuf, \"*\"))\r\n                return sim_messagef (SCPE_ARG, \"No such device %s\\n\", gbuf);\r\n            for (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n                snprintf (gbuf, sizeof (gbuf), \"DEVICE %s\", dptr->name);\r\n                sim_printf (\"\\n%2d   \", i + 1);\r\n                help_cmd (SCP_HELP_FLAT, gbuf);\r\n                }\r\n            return SCPE_OK;\r\n            }\r\n        if ((cmdp = find_cmd (gbuf))) {\r\n            if (*cptr) {\r\n                if ((cmdp->action == &set_cmd) || (cmdp->action == &show_cmd)) {\r\n                    DEVICE *dptr;\r\n                    UNIT *uptr;\r\n                    t_stat r;\r\n\r\n                    cptr = get_glyph (cptr, gbuf, 0);\r\n                    dptr = find_unit (gbuf, &uptr);\r\n                    if (dptr == NULL)\r\n                        dptr = find_dev (gbuf);\r\n                    if (dptr != NULL) {\r\n                        r = help_dev_help (stdout, dptr, uptr, flag, (cmdp->action == &set_cmd) ? \"SET\" : \"SHOW\");\r\n                        if (sim_log && (!sim_oline))\r\n                            help_dev_help (sim_log, dptr, uptr, flag | SCP_HELP_FLAT, (cmdp->action == &set_cmd) ? \"SET\" : \"SHOW\");\r\n                        return r;\r\n                        }\r\n                    if (cmdp->action == &set_cmd) { /* HELP SET xxx (not device or unit) */\r\n                        if ((cmdp = find_ctab (set_glob_tab, gbuf)) &&\r\n                             (cmdp->help))\r\n                            return help_cmd_output (flag, cmdp->help, cmdp->help_base);\r\n                        }\r\n                    else { /* HELP SHOW xxx (not device or unit) */\r\n                        SHTAB *shptr = find_shtab (show_glob_tab, gbuf);\r\n\r\n                        if ((shptr == NULL) || (shptr->help == NULL) || (*shptr->help == '\\0'))\r\n                            return SCPE_ARG;\r\n                        return help_cmd_output (flag, shptr->help, NULL);\r\n                        }\r\n                    return SCPE_ARG;\r\n                    }\r\n                }\r\n            if (cmdp->help) {\r\n                if (strcmp (cmdp->name, \"HELP\") == 0) {\r\n                    DEVICE *dptr;\r\n                    int i;\r\n\r\n                    for (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n                        if (dptr->help)\r\n                            sim_printf (\"h{elp} %-17s display help for device %s\\n\", dptr->name, dptr->name);\r\n                        if (dptr->attach_help ||\r\n                            (DEV_TYPE(dptr) == DEV_MUX) ||\r\n                            (DEV_TYPE(dptr) == DEV_DISK) ||\r\n                            (DEV_TYPE(dptr) == DEV_TAPE)) {\r\n                            sim_printf (\"h{elp} %s ATTACH\\t display help for device %s ATTACH command\\n\", dptr->name, dptr->name);\r\n                            }\r\n                        if (dptr->registers) {\r\n                            if (dptr->registers->name != NULL)\r\n                                sim_printf (\"h{elp} %s REGISTERS\\t display help for device %s register variables\\n\", dptr->name, dptr->name);\r\n                            }\r\n                        if (dptr->modifiers) {\r\n                            MTAB *mptr;\r\n\r\n                            for (mptr = dptr->modifiers; mptr->pstring != NULL; mptr++) {\r\n                                if (mptr->help) {\r\n                                    sim_printf (\"h{elp} %s SET\\t\\t display help for device %s SET commands (modifiers)\\n\", dptr->name, dptr->name);\r\n                                    break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                else {\r\n                    if (((cmdp->action == &exdep_cmd) || (0 == strcmp(cmdp->name, \"BOOT\"))) &&\r\n                        (cmdp->help == NULL) && (sim_dflt_dev->help != NULL)) {\r\n                            sim_dflt_dev->help (stdout, sim_dflt_dev, sim_dflt_dev->units, 0, cmdp->name);\r\n                            if (sim_log && (!sim_oline))\r\n                                sim_dflt_dev->help (sim_log, sim_dflt_dev, sim_dflt_dev->units, 0, cmdp->name);\r\n                        }\r\n                    }\r\n                strlcpy (gbuf2, cmdp->help, sizeof (gbuf2));\r\n                if (*cptr) {\r\n                    strlcat (gbuf2, \" \", sizeof (gbuf2));\r\n                    strlcat (gbuf2, cptr, sizeof (gbuf2));\r\n                    }\r\n                help_cmd_output (flag, gbuf2, cmdp->help_base);\r\n                }\r\n            else { /* no help so it is likely a command alias */\r\n                CTAB *cmdpa;\r\n\r\n                for (cmdpa=cmd_table; cmdpa->name != NULL; cmdpa++)\r\n                    if ((cmdpa->action == cmdp->action) && (cmdpa->help)) {\r\n                        sim_printf (\"%s is an alias for the %s command:\\n%s\",\r\n                                    cmdp->name, cmdpa->name, cmdpa->help);\r\n                        break;\r\n                        }\r\n                if (cmdpa->name == NULL)                /* not found? */\r\n                    sim_printf (\"No help available for the %s command\\n\", cmdp->name);\r\n                }\r\n            }\r\n        else {\r\n            sim_printf (\"No such command or device %s\\n\", gbuf);\r\n            }\r\n        }\r\n    else {\r\n        if (dptr->flags & DEV_DIS)\r\n            sim_printf (\"Device %s is currently disabled\\n\", dptr->name);\r\n        r = help_dev_help (stdout, dptr, uptr, flag, cptr);\r\n        if (sim_log && (!sim_oline))\r\n            help_dev_help (sim_log, dptr, uptr, flag | SCP_HELP_FLAT, cptr);\r\n        return r;\r\n        }\r\n    }\r\nelse {\r\n    fprint_help (stdout);\r\n    if (sim_log && (!sim_oline))\r\n        fprint_help (sim_log);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Spawn command */\r\n\r\nt_stat spawn_cmd (int32 flag, CONST char *cptr)\r\n{\r\nt_stat status;\r\nint i;\r\n\r\nif ((cptr == NULL) || (strlen (cptr) == 0))\r\n    cptr = getenv(\"SHELL\");\r\nif ((cptr == NULL) || (strlen (cptr) == 0))\r\n    cptr = getenv(\"ComSpec\");\r\n#if defined (VMS)\r\nif ((cptr == NULL) || (strlen (cptr) == 0))\r\n    cptr = \"SPAWN/INPUT=SYS$COMMAND:\";\r\n#endif\r\nfflush(stdout);                                         /* flush stdout */\r\nif (sim_log)                                            /* flush log if enabled */\r\n    fflush (sim_log);\r\nif (sim_deb)                                            /* flush debug if enabled */\r\n    fflush (sim_deb);\r\n/* Pass along externally defined (command alias conflicting) environment variables */\r\nfor (i = 0; i < sim_external_env_count; i++)\r\n    setenv (sim_external_env[i].name, sim_external_env[i].value, 1);\r\nstatus = system (cptr);\r\n#if defined (VMS)\r\nprintf (\"\\n\");\r\n#endif\r\n/* Remove the externally defined (command alias conflicting) environment variables again */\r\nfor (i = 0; i < sim_external_env_count; i++)\r\n    unsetenv (sim_external_env[i].name);\r\nreturn status;\r\n}\r\n\r\n/* Screenshot command */\r\n\r\nt_stat screenshot_cmd (int32 flag, CONST char *cptr)\r\n{\r\nif ((cptr == NULL) || (strlen (cptr) == 0))\r\n    return sim_messagef (SCPE_ARG, \"Missing screen shot filename\\n\");\r\nreturn vid_screenshot (cptr);\r\n}\r\n\r\n/* Echo command */\r\n\r\nt_stat echo_cmd (int32 flag, CONST char *cptr)\r\n{\r\nsim_printf (\"%s\\n\", cptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* EchoF command */\r\n\r\nt_stat echof_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *tptr;\r\nTMLN *lp = NULL;\r\nuint8 dbuf[4*CBUFSIZE];\r\nuint32 dsize = 0;\r\nt_stat r;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ntptr = get_glyph (cptr, gbuf, ',');\r\nif (sim_isalpha(gbuf[0]) && (strchr (gbuf, ':'))) {\r\n    r = tmxr_locate_line (gbuf, &lp);\r\n    if (r != SCPE_OK)\r\n        return r;\r\n    cptr = tptr;\r\n    }\r\nGET_SWITCHES (cptr);\r\nif ((*cptr == '\"') || (*cptr == '\\'')) {\r\n    cptr = get_glyph_quoted (cptr, gbuf, 0);\r\n    if (*cptr != '\\0')\r\n        return SCPE_2MARG;              /* No more arguments */\r\n    if (SCPE_OK != sim_decode_quoted_string (gbuf, dbuf, &dsize))\r\n        return sim_messagef (SCPE_ARG, \"Invalid Quoted String: %s\\n\", gbuf);\r\n    dbuf[dsize] = 0;\r\n    cptr = (char *)dbuf;\r\n    }\r\nif (lp) {\r\n    tmxr_linemsgf (lp, \"%s%s\", cptr, (sim_switches & SWMASK ('N')) ? \"\" : \"\\r\\n\");\r\n    tmxr_send_buffered_data (lp);\r\n    }\r\nelse\r\n    sim_printf (\"%s%s\", cptr, (sim_switches & SWMASK ('N')) ? \"\" : \"\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Do command\r\n\r\n   Syntax: DO {-E} {-V} <filename> {<arguments>...}\r\n\r\n   -E causes all command errors to be fatal; without it, only EXIT and ASSERT\r\n   failure will stop a command file.\r\n\r\n   -V causes commands to be echoed before execution.\r\n\r\n   Note that SCPE_STEP (\"Step expired\") is considered a note and not an error\r\n   and so does not abort command execution when using -E.\r\n\r\n   Inputs:\r\n        flag    =   caller and nesting level indicator\r\n        fcptr   =   filename and optional arguments, space-separated\r\n   Outputs:\r\n        status  =   error status\r\n\r\n   The \"flag\" input value indicates the source of the call, as follows:\r\n\r\n        -1      =   initialization file (no error if not found)\r\n         0      =   command line file\r\n         1      =   \"DO\" command\r\n        >1      =   nested \"DO\" command\r\n*/\r\n\r\nt_stat do_cmd (int32 flag, CONST char *fcptr)\r\n{\r\nreturn do_cmd_label (flag, fcptr, NULL);\r\n}\r\n\r\nstatic char *do_position(void)\r\n{\r\nstatic char cbuf[4*CBUFSIZE];\r\n\r\nsnprintf (cbuf, sizeof (cbuf), \"%s%s%s-%d\", sim_relative_path (sim_do_filename[sim_do_depth]), sim_do_label[sim_do_depth] ? \"::\" : \"\", sim_do_label[sim_do_depth] ? sim_do_label[sim_do_depth] : \"\", sim_goto_line[sim_do_depth]);\r\nreturn cbuf;\r\n}\r\n\r\nt_stat do_cmd_label (int32 flag, CONST char *fcptr, CONST char *label)\r\n{\r\nchar cbuf[4*CBUFSIZE], gbuf[CBUFSIZE], abuf[4*CBUFSIZE], quote, *c, *do_arg[11];\r\nCONST char *cptr;\r\nFILE *fpin = NULL;\r\nCTAB *cmdp = NULL;\r\nint32 echo, nargs, errabort, i;\r\nint32 saved_sim_do_echo = sim_do_echo,\r\n      saved_sim_show_message = sim_show_message,\r\n      saved_sim_on_inherit = sim_on_inherit,\r\n      saved_sim_quiet = sim_quiet;\r\nt_bool staying;\r\nt_stat stat, stat_nomessage;\r\n\r\nstat = SCPE_OK;\r\nstaying = TRUE;\r\nif (flag > 0)                                           /* need switches? */\r\n    GET_SWITCHES (fcptr);                               /* get switches */\r\necho = (sim_switches & SWMASK ('V')) || sim_do_echo;    /* -v means echo */\r\nsim_quiet = (sim_switches & SWMASK ('Q')) || sim_quiet; /* -q means quiet */\r\nsim_on_inherit =(sim_switches & SWMASK ('O')) || sim_on_inherit; /* -o means inherit ON condition actions */\r\n\r\nerrabort = sim_switches & SWMASK ('E');                 /* -e means abort on error */\r\n\r\nabuf[sizeof(abuf)-1] = '\\0';\r\nstrlcpy (abuf, fcptr, sizeof(abuf));\r\nc = abuf;\r\ndo_arg[10] = NULL;                                      /* make sure the argument list always ends with a NULL */\r\nfor (nargs = 0; nargs < 10; ) {                         /* extract arguments */\r\n    while (sim_isspace (*c))                            /* skip blanks */\r\n        c++;\r\n    if (*c == 0)                                        /* all done? */\r\n        do_arg [nargs++] = NULL;                        /* null argument */\r\n    else {\r\n        if (*c == '\\'' || *c == '\"')                    /* quoted string? */\r\n            quote = *c++;\r\n        else quote = 0;\r\n        do_arg[nargs++] = c;                            /* save start */\r\n        while (*c && (quote ? (*c != quote) : !sim_isspace (*c)))\r\n            c++;\r\n        if (*c)                                         /* term at quote/spc */\r\n            *c++ = 0;\r\n        }\r\n    }                                                   /* end for */\r\n\r\nif (do_arg [0] == NULL)                                 /* need at least 1 */\r\n    return SCPE_2FARG;\r\nif ((strcasecmp (do_arg[0], \"<stdin>\") != 0) &&\r\n    ((fpin = sim_fopen (do_arg[0], \"r\")) == NULL)) {    /* file failed to open? */\r\n    strlcpy (cbuf, do_arg[0], sizeof (cbuf));           /* try again with .sim extension */\r\n    strlcat (cbuf, \".sim\", sizeof (cbuf));\r\n    if ((fpin = sim_fopen (cbuf, \"r\")) == NULL) {       /* failed a second time? */\r\n        if (flag == 0)                                  /* cmd line file? */\r\n             fprintf (stderr, \"Can't open file %s\\n\", do_arg[0]);\r\n        return SCPE_OPENERR;                            /* return failure */\r\n        }\r\n    }\r\nelse\r\n    strlcpy (cbuf, do_arg[0], sizeof (cbuf));           /* store name of successfully opened file */\r\nif (flag >= 0) {                                        /* Only bump nesting from command or nested */\r\n    ++sim_do_depth;\r\n    if (sim_on_inherit) {                               /* inherit ON condition actions? */\r\n        sim_on_check[sim_do_depth] = sim_on_check[sim_do_depth-1]; /* inherit On mode */\r\n        for (i=0; i<=SCPE_MAX_ERR; i++) {               /* replicate appropriate on commands */\r\n            if (sim_on_actions[sim_do_depth-1][i]) {\r\n                sim_on_actions[sim_do_depth][i] = (char *)malloc(1+strlen(sim_on_actions[sim_do_depth-1][i]));\r\n                if (NULL == sim_on_actions[sim_do_depth][i]) {\r\n                    while (--i >= 0) {\r\n                        free(sim_on_actions[sim_do_depth][i]);\r\n                        sim_on_actions[sim_do_depth][i] = NULL;\r\n                        }\r\n                    sim_on_check[sim_do_depth] = 0;\r\n                    sim_brk_clract ();                  /* defang breakpoint actions */\r\n                    --sim_do_depth;                     /* unwind nesting */\r\n                    fclose (fpin);\r\n                    return SCPE_MEM;\r\n                    }\r\n                strcpy(sim_on_actions[sim_do_depth][i], sim_on_actions[sim_do_depth-1][i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nsim_debug (SIM_DBG_DO, &sim_scp_dev, \"do_cmd_label(%d, flag=%d, '%s', '%s')\\n\", sim_do_depth, flag, fcptr, label ? label : \"\");\r\nif (NULL == (c = sim_filepath_parts (cbuf, \"f\"))) {\r\n    stat = SCPE_MEM;\r\n    goto Cleanup_Return;\r\n    }\r\nstrlcpy( sim_do_filename[sim_do_depth], strcasecmp (cbuf, \"<stdin>\") ? c : cbuf,\r\n         sizeof (sim_do_filename[sim_do_depth]));       /* stash away full path of do file name for possible use by 'call' command */\r\nfree (c);\r\nsim_do_label[sim_do_depth] = label;                     /* stash away do label for possible use in messages */\r\nsim_goto_line[sim_do_depth] = 0;\r\nif (label) {\r\n    sim_gotofile = fpin;\r\n    sim_do_echo = echo;\r\n    stat = goto_cmd (0, label);\r\n    if (stat != SCPE_OK) {\r\n        strcpy(cbuf, \"RETURN SCPE_ARG\");\r\n        cptr = get_glyph (cbuf, gbuf, 0);               /* get command glyph */\r\n        cmdp = find_cmd (gbuf);                         /* return the errorStage things to the stat will be returned */\r\n        goto Cleanup_Return;\r\n        }\r\n    }\r\nif (errabort)                                           /* -e flag? */\r\n    set_on (1, NULL);                                   /* equivalent to ON ERROR RETURN */\r\n\r\nif (strcasecmp (do_arg[0], \"<stdin>\") == 0) {\r\n    stat = process_stdin_commands (SCPE_OK, do_arg, TRUE);\r\n    goto Cleanup_Return;\r\n    }\r\n\r\ndo {\r\n    if (stop_cpu) {                                     /* SIGINT? */\r\n        if (sim_on_actions[sim_do_depth][ON_SIGINT_ACTION]) {\r\n            stop_cpu = FALSE;\r\n            sim_brk_setact (sim_on_actions[sim_do_depth][ON_SIGINT_ACTION]);/* Use specified action */\r\n            }\r\n        else\r\n            break;                                      /* Exit this command procedure */\r\n        }\r\n    sim_do_ocptr[sim_do_depth] = cptr = sim_brk_getact (cbuf, sizeof(cbuf)); /* get bkpt action */\r\n    if (!sim_do_ocptr[sim_do_depth]) {                  /* no pending action? */\r\n        sim_do_ocptr[sim_do_depth] = cptr = read_line (cbuf, sizeof(cbuf), fpin);/* get cmd line */\r\n        sim_goto_line[sim_do_depth] += 1;\r\n        sim_cptr_is_action[sim_do_depth] = FALSE;\r\n        }\r\n    else\r\n        sim_cptr_is_action[sim_do_depth] = TRUE;\r\n    if (cptr == NULL) {                                 /* EOF? */\r\n        stat = SCPE_OK;                                 /* set good return */\r\n        break;\r\n        }\r\n    sim_debug (SIM_DBG_DO, &sim_scp_dev, \"Input Command:    %s\\n\", cbuf);\r\n    sim_sub_args (cbuf, sizeof(cbuf), do_arg);          /* substitute args */\r\n    sim_debug (SIM_DBG_DO, &sim_scp_dev, \"Expanded Command: %s\\n\", cbuf);\r\n    if (*cptr == 0)                                     /* ignore blank */\r\n        continue;\r\n    if (echo)                                           /* echo if -v */\r\n        sim_printf(\"%s> %s\\n\", do_position(), cptr);\r\n    sim_cmd_echoed = echo;\r\n    if (*cptr == ':')                                   /* ignore label */\r\n        continue;\r\n    cptr = get_glyph_cmd (cptr, gbuf);                  /* get command glyph */\r\n    sim_switches = 0;                                   /* init switches */\r\n    sim_gotofile = fpin;\r\n    sim_do_echo = echo;\r\n    if (!sim_cptr_is_action[sim_do_depth]) {\r\n        sim_if_cmd_last[sim_do_depth] = sim_if_cmd[sim_do_depth];\r\n        sim_if_result_last[sim_do_depth] = sim_if_result[sim_do_depth];\r\n        sim_if_result[sim_do_depth] = sim_if_cmd[sim_do_depth] = FALSE;\r\n        }\r\n    if ((cmdp = find_cmd (gbuf))) {                     /* lookup command */\r\n        if (cmdp->action == &return_cmd)                /* RETURN command? */\r\n            break;                                      /*    done! */\r\n        if (strcmp (cmdp->name, \"DO\") == 0) {           /* DO command? */\r\n            if (sim_do_depth >= MAX_DO_NEST_LVL)        /* nest too deep? */\r\n                stat = SCPE_NEST;\r\n            else\r\n                stat = cmdp->action (sim_do_depth+1, cptr);/* exec DO cmd */\r\n            }\r\n        else\r\n            if (cmdp->action == &shift_cmd)             /* SHIFT command */\r\n                stat = shift_args(do_arg, sizeof(do_arg)/sizeof(do_arg[0]));\r\n            else\r\n                stat = cmdp->action (cmdp->arg, cptr);  /* exec other cmd */\r\n        }\r\n    else\r\n        stat = SCPE_UNK;                                /* bad cmd given */\r\n    sim_debug (SIM_DBG_DO, &sim_scp_dev, \"Command '%s', Result: 0x%X - %s\\n\", cmdp ? cmdp->name : \"\", stat, sim_error_text (stat));\r\n    echo = sim_do_echo;                                 /* Allow for SET VERIFY */\r\n    stat_nomessage = stat & SCPE_NOMESSAGE;             /* extract possible message suppression flag */\r\n    stat_nomessage = stat_nomessage || (!sim_show_message);/* Apply global suppression */\r\n    stat = SCPE_BARE_STATUS(stat);                      /* remove possible flag */\r\n    if (((stat != SCPE_OK) && (stat != SCPE_EXPECT)) ||\r\n        ((cmdp->action != &return_cmd) &&\r\n         (cmdp->action != &goto_cmd) &&\r\n         (cmdp->action != &on_cmd) &&\r\n         (cmdp->action != &echo_cmd) &&\r\n         (cmdp->action != &echof_cmd) &&\r\n         (cmdp->action != &sleep_cmd)))\r\n        sim_last_cmd_stat = stat;                       /* save command error status */\r\n    switch (stat) {\r\n        case SCPE_AFAIL:\r\n            staying = (sim_on_check[sim_do_depth] &&        /* if trap action defined */\r\n                       sim_on_actions[sim_do_depth][stat]); /* use it, otherwise exit */\r\n            break;\r\n        case SCPE_EXIT:\r\n            staying = FALSE;\r\n            break;\r\n        case SCPE_OK:\r\n        case SCPE_STEP:\r\n            break;\r\n        default:\r\n            break;\r\n        }\r\n    if ((stat >= SCPE_BASE) && (stat != SCPE_EXIT) &&   /* error from cmd? */\r\n        (stat != SCPE_STEP)) {\r\n        if (!echo &&                                    /* report if not echoing */\r\n            !stat_nomessage &&                          /* and not suppressing messages */\r\n            !(cmdp && cmdp->message)) {                 /* and not handling them specially */\r\n            sim_printf(\"%s> %s\\n\", do_position(), sim_do_ocptr[sim_do_depth]);\r\n            }\r\n        }\r\n    if (!stat_nomessage) {                              /* report error if not suppressed */\r\n        if (cmdp && cmdp->message)                      /* special message handler */\r\n            cmdp->message ((!echo && !sim_quiet) ? sim_do_ocptr[sim_do_depth] : NULL, stat);\r\n        else\r\n            if (stat >= SCPE_BASE)                      /* report error if not suppressed */\r\n                sim_printf (\"%s\\n\", sim_error_text (stat));\r\n        }\r\n    if (stat == SCPE_EXPECT)                            /* EXPECT status is non actionable */\r\n        stat = SCPE_OK;                                 /* so adjust it to SCPE_OK */\r\n    if (staying &&\r\n        (sim_on_check[sim_do_depth]) &&\r\n        (stat != SCPE_OK)) {\r\n        if ((stat <= SCPE_MAX_ERR) && sim_on_actions[sim_do_depth][stat])\r\n            sim_brk_setact (sim_on_actions[sim_do_depth][stat]);\r\n        else\r\n            sim_brk_setact (sim_on_actions[sim_do_depth][0]);\r\n        }\r\n    if (sim_vm_post != NULL)\r\n        (*sim_vm_post) (TRUE);\r\n    } while (staying);\r\nCleanup_Return:\r\nif (fpin)\r\n    fclose (fpin);                                      /* close file */\r\nsim_gotofile = NULL;\r\nif (flag >= 0) {\r\n    sim_do_echo = saved_sim_do_echo;                    /* restore echo state we entered with */\r\n    sim_show_message = saved_sim_show_message;          /* restore message display state we entered with */\r\n    sim_on_inherit = saved_sim_on_inherit;              /* restore ON inheritance state we entered with */\r\n    sim_quiet = saved_sim_quiet;                        /* restore quiet mode we entered with */\r\n    }\r\nif ((flag >= 0) || (!sim_on_inherit)) {\r\n    for (i=0; i<=SCPE_MAX_ERR; i++) {                    /* release any on commands */\r\n        free (sim_on_actions[sim_do_depth][i]);\r\n        sim_on_actions[sim_do_depth][i] = NULL;\r\n        }\r\n    sim_on_check[sim_do_depth] = 0;                     /* clear on mode */\r\n    }\r\nsim_debug (SIM_DBG_DO, &sim_scp_dev, \"do_cmd_label - exiting - stat:%d (%d, flag=%d, '%s', '%s')\\n\", stat, sim_do_depth, flag, fcptr, label ? label : \"\");\r\nif (flag >= 0) {\r\n    sim_brk_clract ();                                  /* defang breakpoint actions */\r\n    --sim_do_depth;                                     /* unwind nesting */\r\n    }\r\nif (cmdp && (cmdp->action == &return_cmd) && (0 != *cptr)) { /* return command with argument? */\r\n    sim_string_to_stat (cptr, &stat);\r\n    sim_last_cmd_stat = stat;                           /* save explicit status as command error status */\r\n    if (sim_switches & SWMASK ('Q'))\r\n        stat |= SCPE_NOMESSAGE;                         /* suppress error message display (in caller) if requested */\r\n    return stat;                                        /* return with explicit return status */\r\n    }\r\nreturn stat | SCPE_NOMESSAGE;                           /* suppress message since we've already done that here */\r\n}\r\n\r\n\r\n/* sim_call_argv - call a routine with C style argc, argv parsed arguments\r\n\r\n   Inputs:\r\n\r\n   main_like_routine =  the routine that is to be called with parsed arguments\r\n   cptr              =  the command argument string to be broken down into argc, argv\r\n\r\n   When the main_like_routine is called, argc and argv are populated.\r\n\r\n      argc is the number of tokens parsed from the input string plus 1\r\n      argv is an array of parsed tokens where argv[0] is the unparsed input string\r\n\r\n*/\r\n\r\n\r\nt_stat sim_call_argv (int (*main_like_routine)(int argc, char *argv[]), const char *cptr)\r\n{\r\nint argc = 1;\r\nchar **argv = (char **)calloc ((1 + argc), sizeof (*argv));\r\nsize_t arg_size;\r\nchar *argline = NULL;\r\nchar *cp, quote;\r\nt_stat result = SCPE_OK;\r\n\r\nif (cptr == NULL) {\r\n    free (argv);\r\n    free (argline);\r\n    return SCPE_ARG;\r\n    }\r\narg_size = 2 + (2 * strlen (cptr));\r\nargline = (char *)malloc (arg_size);\r\nif ((argv == NULL) || (argline == NULL)) {\r\n    free (argv);\r\n    free (argline);\r\n    return SCPE_MEM;\r\n    }\r\nstrlcpy (argline, cptr, arg_size);\r\ncp = argline + (arg_size / 2);\r\nstrlcpy (cp, cptr, arg_size / 2);\r\nargv[0] = argline;                  /* argv[0] points to unparsed arguments */\r\nargv[argc] = NULL;                  /* make sure the argument list always ends with a NULL */\r\nwhile (*cp) {\r\n    while (sim_isspace (*cp))       /* skip blanks */\r\n        cp++;\r\n    if (*cp == '\\0')                /* all done? */\r\n        break;\r\n    if (*cp == '\\'' || *cp == '\"')  /* quoted string? */\r\n        quote = *cp++;\r\n    else\r\n        quote = 0;\r\n    ++argc;\r\n    argv = (char **)realloc (argv, (1 + argc) * sizeof (*argv));\r\n    if (argv == NULL) {\r\n        result = SCPE_MEM;\r\n        break;\r\n        }\r\n    argv[argc - 1] = cp;            /* save start */\r\n    argv[argc] = NULL;              /* make sure the argument list always ends with a NULL */\r\n    while (*cp && (quote ? (*cp != quote) : !sim_isspace (*cp)))\r\n        cp++;\r\n    if (*cp)                        /* term at quote/spc */\r\n        *cp++ = '\\0';\r\n    }\r\nif (argv != NULL)\r\n    result = (t_stat)main_like_routine (argc, argv);\r\nfree (argline);\r\nfree (argv);\r\nreturn result;\r\n}\r\n\r\n/* Substitute_args - replace %n tokens in 'instr' with the do command's arguments\r\n                     and other environment variables\r\n\r\n   Calling sequence\r\n   instr        =       input string\r\n   instr_size   =       sizeof input string buffer\r\n   do_arg[10]   =       arguments\r\n\r\n   Token %0 expands to the command file name.\r\n   Token %n (n being a single digit) expands to the n'th argument\r\n   Token %* expands to the whole set of arguments (%1 ... %9)\r\n\r\n   The input sequence \"%%\" represents a literal \"%\".  All other\r\n   character combinations are rendered literally.\r\n\r\n   Omitted parameters result in null-string substitutions.\r\n\r\n   Tokens preceded and followed by % characters are expanded as environment\r\n   variables, and if one isn't found then can be one of several special\r\n   variables:\r\n          %DATE%              yyyy-mm-dd\r\n          %TIME%              hh:mm:ss\r\n          %DATETIME%          yyyy-mm-ddThh:mm:ss\r\n          %STIME%             hh_mm_ss\r\n          %CTIME%             Www Mmm dd hh:mm:ss yyyy\r\n          %UTIME%             nnn (Unix time - seconds since 1/1/1970)\r\n          %STATUS%            Status value from the last command executed\r\n          %TSTATUS%           The text form of the last status value\r\n          %SIM_VERIFY%        The Verify/Verbose mode of the current Do command file\r\n          %SIM_VERBOSE%       The Verify/Verbose mode of the current Do command file\r\n          %SIM_QUIET%         The Quiet mode of the current Do command file\r\n          %SIM_MESSAGE%       The message display status of the current Do command file\r\n   Environment variable lookups are done first with the precise name between\r\n   the % characters and if that fails, then the name between the % characters\r\n   is upcased and a lookup of that value is attempted.\r\n\r\n   The first Space delimited token on the line is extracted in uppercase and\r\n   then looked up as an environment variable.  If found it the value is\r\n   substituted for the original string before expanding everything else.  If\r\n   it is not found, then the original beginning token on the line is left\r\n   untouched.\r\n*/\r\n\r\nstatic const char *\r\n_sim_gen_env_uplowcase (const char *gbuf, char *rbuf, size_t rbuf_size)\r\n{\r\nconst char *ap;\r\nchar tbuf[CBUFSIZE];\r\n\r\nap = getenv(gbuf);                      /* first try using the literal name */\r\nif (!ap) {\r\n    get_glyph (gbuf, tbuf, 0);          /* now try using the upcased name */\r\n    if (strcmp (gbuf, tbuf))            /* upcase different? */\r\n        ap = getenv(tbuf);              /* lookup the upcase name */\r\n    }\r\nif (ap) {                               /* environment variable found? */\r\n    strlcpy (rbuf, ap, rbuf_size);      /* Return the environment value */\r\n    ap = rbuf;\r\n    }\r\nreturn ap;\r\n}\r\n\r\n/*\r\nEnvironment variable substitution:\r\n\r\n    %XYZ:str1=str2%\r\n\r\nwould expand the XYZ environment variable, substituting each occurrence\r\nof \"str1\" in the expanded result with \"str2\".  \"str2\" can be the empty\r\nstring to effectively delete all occurrences of \"str1\" from the expanded\r\noutput.  \"str1\" can begin with an asterisk, in which case it will match\r\neverything from the beginning of the expanded output to the first\r\noccurrence of the remaining portion of str1.\r\n\r\nMay also specify substrings for an expansion.\r\n\r\n    %XYZ:~10,5%\r\n\r\nwould expand the XYZ environment variable, and then use only the 5\r\ncharacters that begin at the 11th (offset 10) character of the expanded\r\nresult.  If the length is not specified, then it defaults to the\r\nremainder of the variable value.  If either number (offset or length) is\r\nnegative, then the number used is the length of the environment variable\r\nvalue added to the offset or length specified.\r\n\r\n    %XYZ:~-10%\r\n\r\nwould extract the last 10 characters of the XYZ variable.\r\n\r\n    %XYZ:~0,-2%\r\n\r\nwould extract all but the last 2 characters of the XYZ variable.\r\n\r\n */\r\n\r\nstatic void _sim_subststr_substr (const char *ops, char *rbuf, size_t rbuf_size)\r\n{\r\nint rbuf_len = (int)strlen (rbuf);\r\nchar *tstr = (char *)malloc (1 + rbuf_len);\r\n\r\nstrcpy (tstr, rbuf);\r\n\r\nif (*ops == '~') {      /* Substring? */\r\n    int offset = 0, length = rbuf_len;\r\n    int o, l;\r\n\r\n    switch (sscanf (ops + 1, \"%d,%d\", &o, &l)) {\r\n        case 2:\r\n            if (l < 0)\r\n                length = rbuf_len - MIN(-l, rbuf_len);\r\n            else\r\n                length = l;\r\n            /* fall through */\r\n        case 1:\r\n            if (o < 0)\r\n                offset = rbuf_len - MIN(-o, rbuf_len);\r\n            else\r\n                offset = MIN(o, rbuf_len);\r\n            break;\r\n        case 0:\r\n            offset = 0;\r\n            length = rbuf_len;\r\n            break;\r\n        }\r\n    if (offset + length > rbuf_len)\r\n        length = rbuf_len - offset;\r\n    memcpy (rbuf, tstr + offset, length);\r\n    rbuf[length] = '\\0';\r\n    }\r\nelse {\r\n    const char *eq;\r\n\r\n    if ((eq = strchr (ops, '='))) {     /* Substitute? */\r\n        const char *last = tstr;\r\n        const char *curr = tstr;\r\n        char *match = (char *)malloc (1 + (eq - ops));\r\n        size_t move_size;\r\n        t_bool asterisk_match;\r\n\r\n        strlcpy (match, ops, 1 + (eq - ops));\r\n        asterisk_match = (*ops == '*');\r\n        if (asterisk_match)\r\n            memmove (match, match + 1, 1 + strlen (match + 1));\r\n        while ((curr = strstr (last, match))) {\r\n            if (!asterisk_match) {\r\n                move_size = MIN((size_t)(curr - last), rbuf_size);\r\n                memcpy (rbuf, last, move_size);\r\n                rbuf_size -= move_size;\r\n                rbuf += move_size;\r\n                }\r\n            else\r\n                asterisk_match = FALSE;\r\n            move_size = MIN(strlen (eq + 1), rbuf_size);\r\n            memcpy (rbuf, eq + 1, move_size);\r\n            rbuf_size -= move_size;\r\n            rbuf += move_size;\r\n            curr += strlen (match);\r\n            last = curr;\r\n            }\r\n        move_size = MIN(strlen (last), rbuf_size);\r\n        memcpy (rbuf, last, move_size);\r\n        rbuf_size -= move_size;\r\n        rbuf += move_size;\r\n        if (rbuf_size)\r\n            *rbuf = '\\0';\r\n        free (match);\r\n        }\r\n    }\r\nfree (tstr);\r\n}\r\n\r\nstatic const char *\r\n_sim_get_env_special (const char *gbuf, char *rbuf, size_t rbuf_size)\r\n{\r\nint i;\r\nconst char *ap;\r\nconst char *fixup_needed = strchr (gbuf, ':');\r\nchar *tgbuf = NULL;\r\nsize_t tgbuf_size = MAX(rbuf_size, 1 + (size_t)(fixup_needed - gbuf));\r\n\r\nif (fixup_needed) {\r\n    tgbuf = (char *)calloc (tgbuf_size, 1);\r\n    memcpy (tgbuf, gbuf, (fixup_needed - gbuf));\r\n    gbuf = tgbuf;\r\n    }\r\nap = _sim_gen_env_uplowcase (gbuf, rbuf, rbuf_size);/* Look for environment variable */\r\nif (!ap) {                              /* no environment variable found? */\r\n    for (i = 0; i < sim_external_env_count; i++) {\r\n        if (0 == strcmp (gbuf, sim_external_env[i].name)) {\r\n            ap = sim_external_env[i].value;\r\n            break;\r\n            }\r\n        }\r\n    }\r\nif (!ap) {                              /* no environment variable found? */\r\n    time_t now = (time_t)cmd_time.tv_sec;\r\n    struct tm *tmnow = localtime(&now);\r\n\r\n    /* ISO 8601 format date/time info */\r\n    if (!strcmp (\"DATE\", gbuf)) {\r\n        sprintf (rbuf, \"%4d-%02d-%02d\", tmnow->tm_year+1900, tmnow->tm_mon+1, tmnow->tm_mday);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"TIME\", gbuf)) {\r\n        sprintf (rbuf, \"%02d:%02d:%02d\", tmnow->tm_hour, tmnow->tm_min, tmnow->tm_sec);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATETIME\", gbuf)) {\r\n        sprintf (rbuf, \"%04d-%02d-%02dT%02d:%02d:%02d\", tmnow->tm_year+1900, tmnow->tm_mon+1, tmnow->tm_mday, tmnow->tm_hour, tmnow->tm_min, tmnow->tm_sec);\r\n        ap = rbuf;\r\n        }\r\n    /* Locale oriented formatted date/time info */\r\n    else if (!strcmp (\"LDATE\", gbuf)) {\r\n        strftime (rbuf, rbuf_size, \"%x\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"LTIME\", gbuf)) {\r\n#if defined(HAVE_C99_STRFTIME)\r\n        strftime (rbuf, rbuf_size, \"%r\", tmnow);\r\n#else\r\n        strftime (rbuf, rbuf_size, \"%p\", tmnow);\r\n        if (rbuf[0])\r\n            strftime (rbuf, rbuf_size, \"%I:%M:%S %p\", tmnow);\r\n        else\r\n            strftime (rbuf, rbuf_size, \"%H:%M:%S\", tmnow);\r\n#endif\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"CTIME\", gbuf)) {\r\n#if defined(HAVE_C99_STRFTIME)\r\n        strftime (rbuf, rbuf_size, \"%c\", tmnow);\r\n#else\r\n        strcpy (rbuf, ctime(&now));\r\n        rbuf[strlen (rbuf)-1] = '\\0';    /* remove trailing \\n */\r\n#endif\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"UTIME\", gbuf)) {\r\n        sprintf (rbuf, \"%\" LL_FMT \"d\", (LL_TYPE)now);\r\n        ap = rbuf;\r\n        }\r\n    /* Separate Date/Time info */\r\n    else if (!strcmp (\"DATE_YYYY\", gbuf)) {/* Year (0000-9999) */\r\n        strftime (rbuf, rbuf_size, \"%Y\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_YY\", gbuf)) {/* Year (00-99) */\r\n        strftime (rbuf, rbuf_size, \"%y\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_YC\", gbuf)) {/* Century (year/100) */\r\n        sprintf (rbuf, \"%d\", (tmnow->tm_year + 1900)/100);\r\n        ap = rbuf;\r\n        }\r\n    else if ((!strcmp (\"DATE_19XX_YY\", gbuf)) || /* Year with same calendar */\r\n             (!strcmp (\"DATE_19XX_YYYY\", gbuf))) {\r\n        int year = tmnow->tm_year + 1900;\r\n        int days = year - 2001;\r\n        int leaps = days/4 - days/100 + days/400;\r\n        int lyear = ((year % 4) == 0) && (((year % 100) != 0) || ((year % 400) == 0));\r\n        int selector = ((days + leaps + 7) % 7) + lyear * 7;\r\n        static int years[] = {90, 91, 97, 98, 99, 94, 89,\r\n                              96, 80, 92, 76, 88, 72, 84};\r\n        int cal_year = years[selector];\r\n\r\n        if (!strcmp (\"DATE_19XX_YY\", gbuf))\r\n            sprintf (rbuf, \"%d\", cal_year);        /* 2 digit year */\r\n        else\r\n            sprintf (rbuf, \"%d\", cal_year + 1900); /* 4 digit year */\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_MM\", gbuf)) {/* Month number (01-12) */\r\n        strftime (rbuf, rbuf_size, \"%m\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_MMM\", gbuf)) {/* abbreviated Month name */\r\n        strftime (rbuf, rbuf_size, \"%b\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_MONTH\", gbuf)) {/* full Month name */\r\n        strftime (rbuf, rbuf_size, \"%B\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_DD\", gbuf)) {/* Day of Month (01-31) */\r\n        strftime (rbuf, rbuf_size, \"%d\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_D\", gbuf)) { /* ISO 8601 weekday number (1-7) */\r\n        sprintf (rbuf, \"%d\", (tmnow->tm_wday ? tmnow->tm_wday : 7));\r\n        ap = rbuf;\r\n        }\r\n    else if ((!strcmp (\"DATE_WW\", gbuf)) ||   /* ISO 8601 week number (01-53) */\r\n             (!strcmp (\"DATE_WYYYY\", gbuf))) {/* ISO 8601 week year number (0000-9999) */\r\n        int iso_yr = tmnow->tm_year + 1900;\r\n        int iso_wk = (tmnow->tm_yday + 11 - (tmnow->tm_wday ? tmnow->tm_wday : 7))/7;;\r\n\r\n        if (iso_wk == 0) {\r\n            iso_yr = iso_yr - 1;\r\n            tmnow->tm_yday += 365 + (((iso_yr % 4) == 0) ? 1 : 0);  /* Adjust for Leap Year (Correct thru 2099) */\r\n            iso_wk = (tmnow->tm_yday + 11 - (tmnow->tm_wday ? tmnow->tm_wday : 7))/7;\r\n            }\r\n        else\r\n            if ((iso_wk == 53) && (((31 - tmnow->tm_mday) + tmnow->tm_wday) < 4)) {\r\n                ++iso_yr;\r\n                iso_wk = 1;\r\n                }\r\n        if (!strcmp (\"DATE_WW\", gbuf))\r\n            sprintf (rbuf, \"%02d\", iso_wk);\r\n        else\r\n            sprintf (rbuf, \"%04d\", iso_yr);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"DATE_JJJ\", gbuf)) {/* day of year (001-366) */\r\n        strftime (rbuf, rbuf_size, \"%j\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"TIME_HH\", gbuf)) {/* Hour of day (00-23) */\r\n        strftime (rbuf, rbuf_size, \"%H\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"TIME_MM\", gbuf)) {/* Minute of hour (00-59) */\r\n        strftime (rbuf, rbuf_size, \"%M\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"TIME_SS\", gbuf)) {/* Second of minute (00-59) */\r\n        strftime (rbuf, rbuf_size, \"%S\", tmnow);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"TIME_MSEC\", gbuf)) {/* Milliseconds of Second (000-999) */\r\n        sprintf (rbuf, \"%03d\", (int)(cmd_time.tv_nsec / 1000000));\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"STATUS\", gbuf)) {\r\n        sprintf (rbuf, \"%08X\", sim_last_cmd_stat);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"TSTATUS\", gbuf)) {\r\n        t_stat stat = SCPE_BARE_STATUS(sim_last_cmd_stat);\r\n        if ((stat > SCPE_OK) && (stat < SCPE_BASE) && (sim_stop_messages[stat] != NULL))\r\n            sprintf (rbuf, \"%s\", sim_stop_messages[stat]);\r\n        else\r\n            sprintf (rbuf, \"%s\", sim_error_text (stat));\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_VERIFY\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_do_echo ? \"-V\" : \"\");\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_VERBOSE\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_do_echo ? \"-V\" : \"\");\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_QUIET\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_quiet ? \"-Q\" : \"\");\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_MESSAGE\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_show_message ? \"\" : \"-Q\");\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_RUNTIME\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_fmt_numeric (sim_gtime ()));\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_RUNTIME_UNITS\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_vm_interval_units);\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_ASYNC_EVENTS\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_fmt_numeric ((double)sim_asynch_event_count));\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_PROCESSED_EVENTS\", gbuf)) {\r\n        sprintf (rbuf, \"%s\", sim_fmt_numeric ((double)sim_processed_event_count));\r\n        ap = rbuf;\r\n        }\r\n    else if (!strcmp (\"SIM_RUNLIMIT_REMAINING\", gbuf)) {\r\n        ap = _get_runlimit ();\r\n        }\r\n    }\r\nif (ap && fixup_needed) {   /* substring/substituted needed? */\r\n    strlcpy (tgbuf, ap, tgbuf_size);\r\n    _sim_subststr_substr (fixup_needed + 1, tgbuf, tgbuf_size);\r\n    strlcpy (rbuf, tgbuf, rbuf_size);\r\n    }\r\nfree (tgbuf);\r\nreturn ap;\r\n}\r\n\r\n/* Substitute_args - replace %n tokens in 'instr' with the do command's arguments\r\n\r\n   Calling sequence\r\n   instr        =       input string\r\n   tmpbuf       =       temp buffer\r\n   maxstr       =       min (len (instr), len (tmpbuf))\r\n   do_arg[10]   =       arguments\r\n\r\n   Token \"%0\" represents the command file name.\r\n\r\n   The input sequence \"%%\" represents a literal \"%\", and \"\\\\\" represents a\r\n   literal \"\\\".  All other character combinations are rendered literally.\r\n\r\n   Omitted parameters result in null-string substitutions.\r\n*/\r\n\r\nvoid sim_sub_args (char *instr, size_t instr_size, char *do_arg[])\r\n{\r\nchar gbuf[CBUFSIZE];\r\nchar *ip = instr, *op, *oend, *istart, *tmpbuf;\r\nconst char *ap;\r\nchar rbuf[CBUFSIZE];\r\nuint32 i;\r\nsize_t outstr_off = 0;\r\n\r\nsim_exp_argv = do_arg;\r\nsim_rtcn_get_time (&cmd_time, 0);\r\ntmpbuf = (char *)malloc(instr_size);\r\nop = tmpbuf;\r\noend = tmpbuf + instr_size - 2;\r\nif (instr_size > sim_sub_instr_size) {\r\n    sim_sub_instr = (char *)realloc (sim_sub_instr, instr_size*sizeof(*sim_sub_instr));\r\n    sim_sub_instr_off = (size_t *)realloc (sim_sub_instr_off, instr_size*sizeof(*sim_sub_instr_off));\r\n    sim_sub_instr_size = instr_size;\r\n    }\r\nsim_sub_instr_buf = instr;\r\nstrlcpy (sim_sub_instr, instr, instr_size*sizeof(*sim_sub_instr));\r\nwhile (sim_isspace (*ip)) {                                 /* skip leading spaces */\r\n    sim_sub_instr_off[outstr_off++] = ip - instr;\r\n    *op++ = *ip++;\r\n    }\r\n/* If entire string is within quotes, strip the quotes */\r\nif ((*ip == '\"') || (*ip == '\\'')) {                        /* start with a quote character? */\r\n    const char *cptr = ip;\r\n    char *tp = op;              /* use remainder of output buffer as temp buffer */\r\n\r\n    cptr = get_glyph_quoted (cptr, tp, 0);                  /* get quoted string */\r\n    while (sim_isspace (*cptr))\r\n        ++cptr;                                             /* skip over trailing spaces */\r\n    if (*cptr == '\\0') {                                    /* full string was quoted? */\r\n        uint32 dsize;\r\n\r\n        if (SCPE_OK == sim_decode_quoted_string (tp, (uint8 *)tp, &dsize)) {\r\n            tp[dsize] = '\\0';\r\n            while (sim_isspace (*tp))\r\n                memmove (tp, tp + 1, strlen (tp));\r\n            strlcpy (ip, tp, instr_size - (ip - instr));/* copy quoted contents to input buffer */\r\n            strlcpy (sim_sub_instr + (ip -  instr), tp, instr_size - (ip - instr));\r\n            }\r\n        }\r\n    }\r\nistart = ip;\r\nfor (; *ip && (op < oend); ) {\r\n    if ((ip [0] == '%') && (ip [1] == '%')) {           /* literal % insert? */\r\n        sim_sub_instr_off[outstr_off++] = ip - instr;\r\n        ip++;                                           /* skip one */\r\n        *op++ = *ip++;                                  /* copy insert % */\r\n        }\r\n    else {\r\n        t_bool expand_it = FALSE;\r\n        char parts[32];\r\n\r\n        if (*ip == '%') {\r\n            ap = NULL;\r\n            ++ip;\r\n            if (*ip == '~') {\r\n                expand_it = TRUE;\r\n                ++ip;\r\n                for (i=0; (i < (sizeof (parts) - 1)) && (strchr (\"fpnxtz\", *ip)); i++, ip++) {\r\n                    parts[i] = *ip;\r\n                    parts[i + 1] = '\\0';\r\n                    }\r\n                }\r\n            if ((*ip >= '0') && (*ip <= ('9'))) {       /* %n = sub */\r\n                ap = do_arg[*ip - '0'];\r\n                for (i=0; i < (uint32)(*ip - '0'); ++i) /* make sure we're not past the list end */\r\n                    if (do_arg[i] == NULL) {\r\n                        ap = NULL;\r\n                        break;\r\n                        }\r\n                ++ip;\r\n                }\r\n            else {\r\n                if (*ip == '*') {                       /* %1 ... %9 = sub */\r\n                    memset (rbuf, '\\0', sizeof(rbuf));\r\n                    ap = rbuf;\r\n                    for (i=1; i<=9; ++i) {\r\n                        if (do_arg[i] == NULL)\r\n                            break;\r\n                        else\r\n                            if ((sizeof(rbuf)-strlen(rbuf)) < (2 + strlen(do_arg[i]))) {\r\n                                if (strchr(do_arg[i], ' ')) { /* need to surround this argument with quotes */\r\n                                    char quote = '\"';\r\n                                    if (strchr(do_arg[i], quote))\r\n                                        quote = '\\'';\r\n                                    sprintf(&rbuf[strlen(rbuf)], \"%s%c%s%c\\\"\", (i != 1) ? \" \" : \"\", quote, do_arg[i], quote);\r\n                                    }\r\n                                else\r\n                                    sprintf(&rbuf[strlen(rbuf)], \"%s%s\", (i != 1) ? \" \" : \"\", do_arg[i]);\r\n                                }\r\n                            else\r\n                                break;\r\n                        }\r\n                    ++ip;\r\n                    }\r\n                else {\r\n                    if (*ip == '\\0') {                  /* is this a bare % at end of line? */\r\n                        *op++ = '%';                    /* leave it there as a literal percent sign */\r\n                        }\r\n                    else {\r\n                        get_glyph_nc (ip, gbuf, '%');   /* get the literal name */\r\n                        ap = _sim_get_env_special (gbuf, rbuf, sizeof (rbuf));\r\n                        ip += strlen (gbuf);\r\n                        if (*ip == '%')\r\n                            ++ip;\r\n                        }\r\n                    }\r\n                }\r\n            if (ap) {                                   /* non-null arg? */\r\n                char *expanded = NULL;\r\n\r\n                if (expand_it) {\r\n                    expanded = sim_filepath_parts (ap, parts);\r\n                    ap = expanded;\r\n                    }\r\n                while (*ap && (op < oend)) {            /* copy the argument */\r\n                    sim_sub_instr_off[outstr_off++] = ip - instr;\r\n                    *op++ = *ap++;\r\n                    }\r\n                free (expanded);\r\n                }\r\n            }\r\n        else {\r\n            if (ip == istart) {                         /* at beginning of input? */\r\n                get_glyph (istart, gbuf, 0);            /* substitute initial token */\r\n                ap = getenv(gbuf);                      /* if it is an environment variable name */\r\n                if (!ap) {                              /* nope? */\r\n                    sim_sub_instr_off[outstr_off++] = ip - instr;\r\n                    *op++ = *ip++;                      /* press on with literal character */\r\n                    continue;\r\n                    }\r\n                while (*ap && (op < oend)) {            /* copy the translation */\r\n                    sim_sub_instr_off[outstr_off++] = ip - instr;\r\n                    *op++ = *ap++;\r\n                    }\r\n                ip += strlen(gbuf);\r\n                }\r\n            else {\r\n                sim_sub_instr_off[outstr_off++] = ip - instr;\r\n                *op++ = *ip++;                          /* literal character */\r\n                }\r\n            }\r\n        }\r\n    }\r\n*op = 0;                                                /* term buffer */\r\nsim_sub_instr_off[outstr_off] = 0;\r\nstrcpy (instr, tmpbuf);\r\nfree (tmpbuf);\r\n}\r\n\r\nt_stat shift_args (char *do_arg[], size_t arg_count)\r\n{\r\nsize_t i;\r\n\r\nfor (i=1; i<arg_count-1; ++i)\r\n    do_arg[i] = do_arg[i+1];\r\nreturn SCPE_OK;\r\n}\r\n\r\nint sim_cmp_string (const char *s1, const char *s2)\r\n{\r\nlong int v1, v2;\r\nchar *ep1, *ep2;\r\n\r\nif (sim_switches & SWMASK ('F')) {      /* File Compare? */\r\n    FILE *f1, *f2;\r\n    int c1, c2;\r\n    size_t diff_offset = 0;\r\n    t_offset start_offset = 0;\r\n    char *filename1, *filename2;\r\n\r\n    filename1 = (char *)malloc (strlen (s1));\r\n    strcpy (filename1, s1 + 1);\r\n    filename1[strlen (filename1) - 1] = '\\0';\r\n    filename2 = (char *)malloc (strlen (s2));\r\n    strcpy (filename2, s2 + 1);\r\n    filename2[strlen (filename2) - 1] = '\\0';\r\n\r\n    if (getenv (\"_FILE_COMPARE_START_OFFSET\") != NULL)\r\n        start_offset = (t_offset)strtoul (getenv (\"_FILE_COMPARE_START_OFFSET\"), NULL, 0);\r\n    setenv (\"_FILE_COMPARE_DIFF_OFFSET\", \"\", 1);    /* Remove previous environment variable */\r\n    f1 = sim_fopen (filename1, \"rb\");\r\n    f2 = sim_fopen (filename2, \"rb\");\r\n    free (filename1);\r\n    free (filename2);\r\n    if ((f1 == NULL) && (f2 == NULL))   /* Both can't open? */\r\n        return 0;                       /* Call that equal */\r\n    if ((f1 == NULL) ||\r\n        (sim_fseeko (f1, start_offset, SEEK_SET) != 0)) {\r\n        fclose (f2);\r\n        return -1;\r\n        }\r\n    if ((f2 == NULL) ||\r\n        (sim_fseeko (f2, start_offset, SEEK_SET) != 0)) {\r\n        fclose (f1);\r\n        return 1;\r\n        }\r\n    if (sim_switches & SWMASK ('W')) {  /* whitespace runs equivalent? */\r\n        c1 = c2 = 0;\r\n        while ((c1 == c2) && (c1 != EOF)) {\r\n            if (c1 == ' ') {            /* last character was space? */\r\n                while (c1 == ' ') {     /* read until not a space */\r\n                    c1 = fgetc (f1);\r\n                    ++diff_offset;\r\n                    if (sim_isspace (c1))\r\n                        c1 = ' ';       /* all whitespace is a space */\r\n                    }\r\n                }\r\n            else {                      /* get new character */\r\n                c1 = fgetc (f1);\r\n                ++diff_offset;\r\n                if (sim_isspace (c1))\r\n                    c1 = ' ';           /* all whitespace is a space */\r\n                }\r\n            if (c2 == ' ') {            /* last character was space? */\r\n                while (c2 == ' ') {     /* read until not a space */\r\n                    c2 = fgetc (f2);\r\n                    if (sim_isspace (c2))\r\n                        c2 = ' ';       /* all whitespace is a space */\r\n                    }\r\n                }\r\n            else {                      /* get new character */\r\n                c2 = fgetc (f2);\r\n                if (sim_isspace (c2))\r\n                    c2 = ' ';           /* all whitespace is a space */\r\n                }\r\n            };\r\n        }\r\n    else {          /* Binary File Compare */\r\n        while (((c1 = fgetc (f1)) == (c2 = fgetc (f2))) &&\r\n               (c1 != EOF))\r\n            ++diff_offset;\r\n        }\r\n    fclose (f1);\r\n    fclose (f2);\r\n    if (c1 != c2) {\r\n        char offset_buf[32];\r\n\r\n        snprintf (offset_buf, sizeof (offset_buf), \"%u\", (uint32)(diff_offset + start_offset));\r\n        setenv (\"_FILE_COMPARE_DIFF_OFFSET\", offset_buf, 1);\r\n        }\r\n    return c1 - c2;\r\n    }\r\nv1 = strtol(s1+1, &ep1, 0);\r\nv2 = strtol(s2+1, &ep2, 0);\r\nif ((ep1 != s1 + strlen (s1) - 1) ||\r\n    (ep2 != s2 + strlen (s2) - 1))\r\n    return (strlen (s1) == strlen (s2)) ? strncmp (s1 + 1, s2 + 1, strlen (s1) - 2)\r\n                                        : strcmp (s1, s2);\r\nif (v1 == v2)\r\n    return 0;\r\nif (v1 < v2)\r\n    return -1;\r\nreturn 1;\r\n}\r\n\r\n/* Assert command\r\n   If command\r\n\r\n   Syntax: ASSERT {NOT} {<dev>} <reg>{<logical-op><value>}<conditional-op><value>\r\n   Syntax: IF {NOT} {<dev>} <reg>{<logical-op><value>}<conditional-op><value> commandtoprocess{; additionalcommandtoprocess}...\r\n\r\n       If NOT is specified, the resulting expression value is inverted.\r\n       If <dev> is not specified, sim_dflt_dev (CPU) is assumed.\r\n       <value> is expressed in the radix specified for <reg>.\r\n       <logical-op> and <conditional-op> are the same as that\r\n       allowed for examine and deposit search specifications.\r\n\r\n   Syntax: ASSERT {-i} {NOT} \"<string1>\"|EnvVarName1 <compare-op> \"<string2>\"|EnvVarName2\r\n   Syntax: IF {-i} {NOT} \"<string1>\"|EnvVarName1 <compare-op> \"<string2>\"|EnvVarName2 commandtoprocess{; additionalcommandtoprocess}...\r\n\r\n       If -i is specified, the comparisons are done in a case insensitive manner.\r\n       If NOT is specified, the resulting expression value is inverted.\r\n       \"<string1>\" and \"<string2>\" are quote delimited strings which include\r\n       expansion references to environment variables in the simulator.\r\n       <compare-op> can be any one of:\r\n            ==  - equal\r\n            EQU - equal\r\n            !=  - not equal\r\n            NEQ - not equal\r\n            <   - less than\r\n            LSS - less than\r\n            <=  - less than or equal\r\n            LEQ - less than or equal\r\n            >   - greater than\r\n            GTR - greater than\r\n            >=  - greater than or equal\r\n            GEQ - greater than or equal\r\n*/\r\nstatic CONST char *_get_string (CONST char *iptr, char *optr, char mchar)\r\n{\r\nconst char *ap;\r\nCONST char *tptr, *gptr;\r\nREG *rptr;\r\n\r\ntptr = (CONST char *)get_glyph_gen (iptr, optr, mchar, TRUE, (sim_switches & SWMASK ('I')), TRUE, '\\\\');\r\nif ((*optr != '\"') && (*optr != '\\'')) {\r\n    ap = getenv (optr);\r\n    if (!ap)\r\n        return tptr;\r\n    /* for legacy ASSERT/IF behavior give precedence to REGister names over Environment Variables */\r\n    get_glyph (optr, optr, 0);\r\n    rptr = find_reg (optr, &gptr, sim_dfdev);\r\n    if (rptr)\r\n        return tptr;\r\n    snprintf (optr, CBUFSIZE - 1, \"\\\"%s\\\"\", ap);\r\n    get_glyph_gen (optr, optr, 0, TRUE, (sim_switches & SWMASK ('I')), TRUE, '\\\\');\r\n    }\r\nreturn tptr;\r\n}\r\n\r\nt_stat assert_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE], gbuf2[CBUFSIZE];\r\nCONST char *tptr, *gptr;\r\nREG *rptr;\r\nuint32 idx = 0;\r\nt_stat r;\r\nt_bool Not = FALSE;\r\nt_bool Exist = FALSE;\r\nt_bool Device = FALSE;\r\nt_bool result;\r\nt_addr addr = 0;\r\nt_stat reason;\r\n\r\ncptr = (CONST char *)get_sim_opt (CMD_OPT_SW|CMD_OPT_DFT, (CONST char *)cptr, &r);\r\n                                                        /* get sw, default */\r\nsim_stabr.boolop = sim_staba.boolop = -1;               /* no relational op dflt */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\nif ((flag != 1) && (sim_cptr_is_action[sim_do_depth]))\r\n    return sim_messagef (SCPE_UNK, \"Invalid Command Sequence, IF/ELSE nesting not allowed\\n\");\r\nif (flag == 2) {                                        /* ELSE command? */\r\n    if (!sim_if_cmd_last[sim_do_depth])\r\n        return sim_messagef (SCPE_UNK, \"Invalid Command Sequence, ELSE not following IF\\n\");\r\n    if (*cptr == '\\0')                                  /* no more? */\r\n        return sim_messagef (SCPE_2FARG, \"Missing ELSE action commands\\n\");\r\n    if (!sim_if_result_last[sim_do_depth])\r\n        sim_brk_setact (cptr);                          /* set up ELSE actions */\r\n    return SCPE_OK;\r\n    }\r\ntptr = get_glyph (cptr, gbuf, 0);                       /* get token */\r\nif (!strcmp (gbuf, \"NOT\")) {                            /* Conditional Inversion? */\r\n    Not = TRUE;                                         /* remember that, and */\r\n    cptr = (CONST char *)tptr;\r\n    tptr = get_glyph (cptr, gbuf, 0);                   /* get next token */\r\n    }\r\nif (!strcmp (gbuf, \"EXIST\")) {                          /* File Exist Test? */\r\n    Exist = TRUE;                                       /* remember that */\r\n    cptr = (CONST char *)tptr;\r\n    }\r\nif (!strcmp (gbuf, \"DEVICE\")) {                         /* Device Exist+Enabled Test? */\r\n    Device = TRUE;                                      /* remember that, and */\r\n    cptr = (CONST char *)tptr;\r\n    }\r\ntptr = _get_string (cptr, gbuf, ' ');                   /* get first string */\r\nif (Exist || (*gbuf == '\"') || (*gbuf == '\\'')) {       /* quoted string comparison? */\r\n    char quote = *gbuf;\r\n    char op[CBUFSIZE];\r\n    static struct {\r\n        const char *op;\r\n        int aval;\r\n        int bval;\r\n        t_bool invert;\r\n        } *optr, compare_ops[] =\r\n        {\r\n            {\"==\",   0,  0, FALSE},\r\n            {\"EQU\",  0,  0, FALSE},\r\n            {\"!=\",   0,  0, TRUE},\r\n            {\"NEQ\",  0,  0, TRUE},\r\n            {\"<\",   -1, -1, FALSE},\r\n            {\"LSS\", -1, -1, FALSE},\r\n            {\"<=\",   0, -1, FALSE},\r\n            {\"LEQ\",  0, -1, FALSE},\r\n            {\">\",    1,  1, FALSE},\r\n            {\"GTR\",  1,  1, FALSE},\r\n            {\">=\",   0,  1, FALSE},\r\n            {\"GEQ\",  0,  1, FALSE},\r\n            {NULL}};\r\n\r\n    if (!*tptr)\r\n        return SCPE_2FARG;\r\n    cptr = tptr;\r\n    while (sim_isspace (*cptr))                         /* skip spaces */\r\n        ++cptr;\r\n    if (!Exist) {\r\n        get_glyph (cptr, op, quote);\r\n        for (optr = compare_ops; optr->op; optr++)\r\n            if (0 == strncmp (op, optr->op, strlen (optr->op)))\r\n                break;\r\n        if (!optr->op)\r\n            return sim_messagef (SCPE_ARG, \"Invalid operator: %s\\n\", op);\r\n        cptr += strlen (optr->op);\r\n        if ((!sim_isspace (*cptr)) && sim_isalpha (optr->op[strlen (optr->op) - 1]) && sim_isalnum (*cptr))\r\n            return sim_messagef (SCPE_ARG, \"Invalid operator: %s\\n\", op);\r\n        while (sim_isspace (*cptr))                     /* skip spaces */\r\n            ++cptr;\r\n        cptr = _get_string (cptr, gbuf2, 0);            /* get second string */\r\n        if (*cptr) {                                    /* more? */\r\n            if (flag == 1)                              /* ASSERT has no more args */\r\n                return SCPE_2MARG;\r\n            }\r\n        else {\r\n            if (flag != 1)\r\n                return SCPE_2FARG;                      /* IF/ELSE needs actions! */\r\n            }\r\n        result = sim_cmp_string (gbuf, gbuf2);\r\n        result = ((result == optr->aval) || (result == optr->bval));\r\n        if (optr->invert)\r\n            result = !result;\r\n        }\r\n    else {\r\n        FILE *f = sim_fopen (gbuf, \"r\");\r\n\r\n        if (!f) {\r\n            if (((gbuf[0] == '\"') || (gbuf[0] == '\\'')) &&      /* quoted? */\r\n                (gbuf[0] == gbuf[strlen (gbuf) - 1])) {\r\n                char *without_quotes = sim_filepath_parts (gbuf, \"f\");\r\n\r\n                if (without_quotes) {\r\n                    f = sim_fopen (without_quotes, \"r\");\r\n                    free (without_quotes);\r\n                    }\r\n                }\r\n            }\r\n        if (f)\r\n            fclose (f);\r\n        result = (f != NULL);\r\n        }\r\n    }\r\nelse {\r\n    while (sim_isspace (*cptr))                         /* skip spaces */\r\n        ++cptr;\r\n    if (*cptr == '(') {\r\n        t_svalue value;\r\n\r\n        if ((cptr > sim_sub_instr_buf) && ((size_t)(cptr - sim_sub_instr_buf) < sim_sub_instr_size))\r\n            cptr = &sim_sub_instr[sim_sub_instr_off[cptr - sim_sub_instr_buf]]; /* get un-substituted string */\r\n        cptr = sim_eval_expression (cptr, &value, TRUE, &r);\r\n        result = (value != 0);\r\n        }\r\n    else {\r\n        cptr = get_glyph (cptr, gbuf, 0);               /* get register */\r\n        if (Device) {\r\n            result = (NULL == find_dev (gbuf)) ? 0 : 1;\r\n            }\r\n        else {\r\n            rptr = find_reg (gbuf, &gptr, sim_dfdev);   /* parse register */\r\n            if (rptr) {                                 /* got register? */\r\n                if (*gptr == '[') {                     /* subscript? */\r\n                    if (rptr->depth <= 1)               /* array register? */\r\n                        return SCPE_ARG;\r\n                    idx = (uint32) strtotv (++gptr, &tptr, 0);/* convert index */\r\n                    if ((gptr == tptr) || (*tptr++ != ']'))\r\n                        return SCPE_ARG;\r\n                    gptr = tptr;                        /* update */\r\n                    }\r\n                else\r\n                    idx = 0;                            /* not array */\r\n                if (idx >= rptr->depth)                 /* validate subscript */\r\n                    return SCPE_SUB;\r\n                }\r\n            else {                                      /* not reg, check for memory */\r\n                if (sim_dfdev && sim_vm_parse_addr)     /* get addr */\r\n                    addr = sim_vm_parse_addr (sim_dfdev, gbuf, &gptr);\r\n                else\r\n                    addr = (t_addr) strtotv (gbuf, &gptr, sim_dfdev ? sim_dfdev->dradix : sim_dflt_dev->dradix);\r\n                if (gbuf == gptr)                       /* not register? */\r\n                    return sim_messagef (SCPE_NXREG, \"Non-existant register: %s\\n\", gbuf);\r\n                }\r\n            if (*gptr != 0)                             /* more? must be search */\r\n                get_glyph (gptr, gbuf, 0);\r\n            else {\r\n                if (*cptr == 0)                         /* must be more */\r\n                    return SCPE_2FARG;\r\n                cptr = get_glyph (cptr, gbuf, 0);       /* get search cond */\r\n                }\r\n            if (*cptr) {                                /* more? */\r\n                if (flag)                               /* ASSERT has no more args */\r\n                    return SCPE_2MARG;\r\n                }\r\n            else {\r\n                if (!flag)\r\n                    return SCPE_2FARG;                  /* IF needs actions! */\r\n                }\r\n            if (rptr) {                                 /* Handle register case */\r\n                if (!get_rsearch (gbuf, rptr->radix, &sim_stabr) ||  /* parse condition */\r\n                    (sim_stabr.boolop == -1))           /* relational op reqd */\r\n                    return SCPE_MISVAL;\r\n                sim_eval[0] = get_rval (rptr, idx);     /* get register value */\r\n                result = test_search (sim_eval, &sim_stabr);    /* test condition */\r\n                }\r\n            else {                                      /* Handle memory case */\r\n                if (!get_asearch (gbuf, sim_dfdev ? sim_dfdev->dradix : sim_dflt_dev->dradix, &sim_staba) ||  /* parse condition */\r\n                    (sim_staba.boolop == -1))           /* relational op reqd */\r\n                    return SCPE_MISVAL;\r\n                reason = get_aval (addr, sim_dfdev, sim_dfunit);/* get data */\r\n                if (reason != SCPE_OK)                  /* return if error */\r\n                    return reason;\r\n                result = test_search (sim_eval, &sim_staba);    /* test condition */\r\n                }\r\n            }\r\n        }\r\n    }\r\nif ((cptr > sim_sub_instr_buf) && ((size_t)(cptr - sim_sub_instr_buf) < sim_sub_instr_size))\r\n    cptr = &sim_sub_instr[sim_sub_instr_off[cptr - sim_sub_instr_buf]]; /* get un-substituted string */\r\nsim_if_cmd[sim_do_depth] = (flag == 0);                 /* record IF command */\r\nif (Not ^ result) {\r\n    if (!flag) {\r\n        sim_brk_setact (cptr);                          /* set up IF actions */\r\n        sim_if_result[sim_do_depth] = TRUE;\r\n        }\r\n    }\r\nelse\r\n    if (flag)\r\n        return SCPE_AFAIL;                              /* return assert status */\r\n    else\r\n        sim_if_result[sim_do_depth] = FALSE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Send command\r\n\r\n   Syntax: SEND {After=m},{Delay=n},\"string-to-send\"\r\n\r\n   After  - is an integer (>= 0) representing a number of instruction\r\n            delay before the initial characters is sent.  The after\r\n            parameter can is set by itself (with SEND AFTER=n).\r\n            The value specified then persists across SEND commands,\r\n            and is the default value used in subsequent SEND commands\r\n            which don't specify an explicit AFTER parameter.  This default\r\n            value is visible externally via an environment variable.\r\n   Delay  - is an integer (>= 0) representing a number of instruction\r\n            delay before and between characters being sent.  The\r\n            delay parameter can is set by itself (with SEND DELAY=n)\r\n            The value specified persists across SEND commands, and is\r\n            the default value used in subsequent SEND commands which\r\n            don't specify an explicit DELAY parameter.  This default\r\n            value is visible externally via an environment variable.\r\n   String - must be quoted.  Quotes may be either single or double but the\r\n            opening and closing quote characters must match.  Within quotes\r\n            C style character escapes are allowed.\r\n            The following character escapes are explicitly supported:\r\n        \\r  Sends the ASCII Carriage Return character (Decimal value 13)\r\n        \\n  Sends the ASCII Linefeed character (Decimal value 10)\r\n        \\f  Sends the ASCII Formfeed character (Decimal value 12)\r\n        \\t  Sends the ASCII Horizontal Tab character (Decimal value 9)\r\n        \\v  Sends the ASCII Vertical Tab character (Decimal value 11)\r\n        \\b  Sends the ASCII Backspace character (Decimal value 8)\r\n        \\\\  Sends the ASCII Backslash character (Decimal value 92)\r\n        \\'  Sends the ASCII Single Quote character (Decimal value 39)\r\n        \\\"  Sends the ASCII Double Quote character (Decimal value 34)\r\n        \\?  Sends the ASCII Question Mark character (Decimal value 63)\r\n        \\e  Sends the ASCII Escape character (Decimal value 27)\r\n     as well as octal character values of the form:\r\n        \\n{n{n}} where each n is an octal digit (0-7)\r\n     and hex character values of the form:\r\n        \\xh{h} where each h is a hex digit (0-9A-Fa-f)\r\n   */\r\n\r\nstatic uint32 get_default_env_parameter (const char *dev_name, const char *param_name, uint32 default_value)\r\n{\r\nchar varname[CBUFSIZE];\r\nuint32 val;\r\nchar *endptr;\r\nconst char *colon = strchr (dev_name, ':');\r\n\r\nif (colon)\r\n    snprintf (varname, sizeof(varname), \"%s_%*.*s_%s\", param_name, (int)(colon-dev_name), (int)(colon-dev_name), dev_name, colon + 1);\r\nelse\r\n    snprintf (varname, sizeof(varname), \"%s_%s\", param_name, dev_name);\r\nif (!getenv (varname))\r\n    val = default_value;\r\nelse {\r\n    val = strtoul (getenv (varname), &endptr, 0);\r\n    if (*endptr)\r\n        val = default_value;\r\n    }\r\nreturn val;\r\n}\r\n\r\nstatic void set_default_env_parameter (const char *dev_name, const char *param_name, uint32 value)\r\n{\r\nchar varname[CBUFSIZE];\r\nchar valbuf[CBUFSIZE];\r\n\r\nconst char *colon = strchr (dev_name, ':');\r\n\r\nif (colon)\r\n    snprintf (varname, sizeof(varname), \"%s_%*.*s_%s\", param_name, (int)(colon-dev_name), (int)(colon-dev_name), dev_name, colon + 1);\r\nelse\r\n    snprintf (varname, sizeof(varname), \"%s_%s\", param_name, dev_name);\r\nsnprintf (valbuf, sizeof(valbuf), \"%u\", value);\r\nsetenv(varname, valbuf, 1);\r\n}\r\n\r\nt_stat send_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *tptr;\r\nuint8 dbuf[CBUFSIZE];\r\nuint32 dsize = 0;\r\nconst char *dev_name;\r\nuint32 delay;\r\nt_bool delay_set = FALSE;\r\nuint32 after;\r\nt_bool after_set = FALSE;\r\nt_stat r;\r\nSEND *snd;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ntptr = get_glyph (cptr, gbuf, ',');\r\nif (sim_isalpha(gbuf[0]) && (strchr (gbuf, ':'))) {\r\n    r = tmxr_locate_line_send (gbuf, &snd);\r\n    if (r != SCPE_OK)\r\n        return r;\r\n    cptr = tptr;\r\n    tptr = get_glyph (tptr, gbuf, ',');\r\n    }\r\nelse\r\n    snd = sim_cons_get_send ();\r\ndev_name = tmxr_send_line_name (snd);\r\nif (!flag)\r\n    return sim_send_clear (snd);\r\ndelay = get_default_env_parameter (dev_name, \"SIM_SEND_DELAY\", SEND_DEFAULT_DELAY);\r\nafter = get_default_env_parameter (dev_name, \"SIM_SEND_AFTER\", delay);\r\nwhile (*cptr) {\r\n    if ((!strncmp(gbuf, \"DELAY=\", 6)) && (gbuf[6])) {\r\n        delay = (uint32)get_uint (&gbuf[6], 0, 2000000000, &r);\r\n        if (r != SCPE_OK)\r\n            return sim_messagef (SCPE_ARG, \"Invalid Delay Value: %s\\n\", &gbuf[6]);\r\n        cptr = tptr;\r\n        tptr = get_glyph (cptr, gbuf, ',');\r\n        delay_set = TRUE;\r\n        if (!after_set)\r\n            after = delay;\r\n        continue;\r\n        }\r\n    if ((!strncmp(gbuf, \"AFTER=\", 6)) && (gbuf[6])) {\r\n        after = (uint32)get_uint (&gbuf[6], 0, 2000000000, &r);\r\n        if (r != SCPE_OK)\r\n            return sim_messagef (SCPE_ARG, \"Invalid After Value: %s\\n\", &gbuf[6]);\r\n        cptr = tptr;\r\n        tptr = get_glyph (cptr, gbuf, ',');\r\n        after_set = TRUE;\r\n        continue;\r\n        }\r\n    if ((*cptr == '\"') || (*cptr == '\\''))\r\n        break;\r\n    return SCPE_ARG;\r\n    }\r\nif (!*cptr) {\r\n    if ((!delay_set) && (!after_set))\r\n        return SCPE_2FARG;\r\n    set_default_env_parameter (dev_name, \"SIM_SEND_DELAY\", delay);\r\n    set_default_env_parameter (dev_name, \"SIM_SEND_AFTER\", after);\r\n    return SCPE_OK;\r\n    }\r\nif ((*cptr != '\"') && (*cptr != '\\''))\r\n    return sim_messagef (SCPE_ARG, \"String must be quote delimited\\n\");\r\ncptr = get_glyph_quoted (cptr, gbuf, 0);\r\nif (*cptr != '\\0')\r\n    return SCPE_2MARG;                  /* No more arguments */\r\n\r\nif (SCPE_OK != sim_decode_quoted_string (gbuf, dbuf, &dsize))\r\n    return sim_messagef (SCPE_ARG, \"Invalid String\\n\");\r\nreturn sim_send_input (snd, dbuf, dsize, after, delay);\r\n}\r\n\r\nt_stat sim_show_send (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *tptr;\r\nt_stat r;\r\nSEND *snd;\r\n\r\ntptr = get_glyph (cptr, gbuf, ',');\r\nif (sim_isalpha(gbuf[0]) && (strchr (gbuf, ':'))) {\r\n    r = tmxr_locate_line_send (gbuf, &snd);\r\n    if (r != SCPE_OK)\r\n        return r;\r\n    cptr = tptr;\r\n    }\r\nelse\r\n    snd = sim_cons_get_send ();\r\nif (*cptr)\r\n    return SCPE_2MARG;\r\nreturn sim_show_send_input (st, snd);\r\n}\r\n\r\nt_stat expect_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *tptr;\r\nt_stat r;\r\nEXPECT *exp;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ntptr = get_glyph (cptr, gbuf, ',');\r\nif (sim_isalpha(gbuf[0]) && (strchr (gbuf, ':'))) {\r\n    r = tmxr_locate_line_expect (gbuf, &exp);\r\n    if (r != SCPE_OK)\r\n        return sim_messagef (r, \"No such active line: %s\\n\", gbuf);\r\n    cptr = tptr;\r\n    }\r\nelse\r\n    exp = sim_cons_get_expect ();\r\nif (flag)\r\n    return sim_set_expect (exp, cptr);\r\nelse\r\n    return sim_set_noexpect (exp, cptr);\r\n}\r\n\r\nt_stat sim_show_expect (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *tptr;\r\nt_stat r;\r\nEXPECT *exp;\r\n\r\ntptr = get_glyph (cptr, gbuf, ',');\r\nif (sim_isalpha(gbuf[0]) && (strchr (gbuf, ':'))) {\r\n    r = tmxr_locate_line_expect (gbuf, &exp);\r\n    if (r != SCPE_OK)\r\n        return r;\r\n    cptr = tptr;\r\n    }\r\nelse\r\n    exp = sim_cons_get_expect ();\r\nif (*cptr && (*cptr != '\"') && (*cptr != '\\''))\r\n    return SCPE_ARG;            /* String must be quote delimited */\r\ntptr = get_glyph_quoted (cptr, gbuf, 0);\r\nif (*tptr != '\\0')\r\n    return SCPE_2MARG;          /* No more arguments */\r\nif (*cptr && (cptr[strlen(cptr)-1] != '\"') && (cptr[strlen(cptr)-1] != '\\''))\r\n    return SCPE_ARG;            /* String must be quote delimited */\r\nreturn sim_exp_show (st, exp, gbuf);\r\n}\r\n\r\n\r\n/* Sleep command */\r\n\r\nt_stat sleep_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar *tptr;\r\ndouble wait;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nwhile (*cptr) {\r\n    wait = strtod (cptr, &tptr);\r\n    switch (*tptr) {\r\n        case ' ':\r\n        case '\\t':\r\n        case '\\0':\r\n            break;\r\n        case 's':\r\n        case 'S':\r\n            ++tptr;\r\n            break;\r\n        case 'm':\r\n        case 'M':\r\n            ++tptr;\r\n            wait *= 60.0;\r\n            break;\r\n        case 'h':\r\n        case 'H':\r\n            ++tptr;\r\n            wait *= (60.0*60.0);\r\n            break;\r\n        case 'd':\r\n        case 'D':\r\n            ++tptr;\r\n            wait *= (24.0*60.0*60.0);\r\n            break;\r\n        default:\r\n            return sim_messagef (SCPE_ARG, \"Invalid Sleep unit '%c'\\n\", *cptr);\r\n        }\r\n    wait *= 1000.0;                             /* Convert to Milliseconds */\r\n    cptr = tptr;\r\n    while ((wait > 1000.0) && (!stop_cpu)) {\r\n        if (sim_switches & SWMASK ('V'))\r\n            sim_printf (\"Sleeping for: %s          \\r\", sim_fmt_secs (wait / 1000.0));\r\n        wait -= sim_os_ms_sleep (1000);\r\n        }\r\n    if ((wait > 0.0) && (!stop_cpu)) {\r\n        if (sim_switches & SWMASK ('V'))\r\n            sim_printf (\"Sleeping for: %s          \\r\", sim_fmt_secs (wait / 1000.0));\r\n        sim_os_ms_sleep ((unsigned)wait);\r\n        }\r\n    }\r\nstop_cpu = FALSE;                   /* Clear in case sleep was interrupted */\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Goto command */\r\n\r\nt_stat goto_cmd (int32 flag, CONST char *fcptr)\r\n{\r\nchar cbuf[CBUFSIZE], gbuf[CBUFSIZE], gbuf1[CBUFSIZE];\r\nconst char *cptr;\r\nlong fpos;\r\nint32 saved_do_echo = sim_do_echo;\r\nint32 saved_goto_line = sim_goto_line[sim_do_depth];\r\n\r\nif ((NULL == sim_gotofile) ||\r\n    (0 == strcasecmp (sim_do_filename[sim_do_depth], \"<stdin>\")))\r\n    return SCPE_UNK;                                    /* only valid inside of do_cmd */\r\n\r\nget_glyph (fcptr, gbuf1, 0);\r\nif ('\\0' == gbuf1[0])                                   /* unspecified goto target */\r\n    return sim_messagef (SCPE_ARG, \"Missing goto target\\n\");\r\nfpos = ftell(sim_gotofile);                             /* Save start position */\r\nif (fpos < 0)\r\n    return sim_messagef (SCPE_IERR, \"goto ftell error: %s\\n\", strerror (errno));\r\nif (strcasecmp(\":EOF\", gbuf1) == 0) {\r\n    if (fseek (sim_gotofile, 0, SEEK_END))\r\n        return sim_messagef (SCPE_IERR, \"goto seek error: %s\\n\", strerror (errno));\r\n    sim_brk_clract ();                                  /* goto defangs current actions */\r\n    sim_do_echo = saved_do_echo;                        /* restore echo mode */\r\n    return SCPE_OK;\r\n    }\r\nrewind(sim_gotofile);                                   /* start search for label */\r\nsim_goto_line[sim_do_depth] = 0;                        /* reset line number */\r\nsim_do_echo = 0;                                        /* Don't echo while searching for label */\r\nwhile (1) {\r\n    cptr = read_line (cbuf, sizeof(cbuf), sim_gotofile);/* get cmd line */\r\n    if (cptr == NULL) break;                            /* exit on eof */\r\n    sim_goto_line[sim_do_depth] += 1;                   /* record line number */\r\n    if (*cptr == 0) continue;                           /* ignore blank */\r\n    if (*cptr != ':') continue;                         /* ignore non-labels */\r\n    ++cptr;                                             /* skip : */\r\n    while (sim_isspace (*cptr)) ++cptr;                 /* skip blanks */\r\n    get_glyph (cptr, gbuf, 0);                          /* get label glyph */\r\n    if (0 == strcmp(gbuf, gbuf1)) {\r\n        sim_brk_clract ();                              /* goto defangs current actions */\r\n        sim_do_echo = saved_do_echo;                    /* restore echo mode */\r\n        if (sim_do_echo)                                /* echo if -v */\r\n            sim_printf(\"%s> %s\\n\", do_position(), cbuf);\r\n        return SCPE_OK;\r\n        }\r\n    }\r\nsim_do_echo = saved_do_echo;                            /* restore echo mode */\r\nsim_goto_line[sim_do_depth] = saved_goto_line;          /* restore start line number */\r\nif (fseek(sim_gotofile, fpos, SEEK_SET))                /* restore start position */\r\n    return sim_messagef (SCPE_IERR, \"goto seek error: %s\\n\", strerror (errno));\r\nreturn sim_messagef (SCPE_ARG, \"goto target '%s' not found\\n\", gbuf1);\r\n}\r\n\r\n/* Return command */\r\n/* The return command is invalid unless encountered in a do_cmd context, */\r\n/* and in that context, it is handled as a special case inside of do_cmd() */\r\n/* and not dispatched here, so if we get here a return has been issued from */\r\n/* interactive input */\r\n\r\nt_stat return_cmd (int32 flag, CONST char *fcptr)\r\n{\r\nreturn sim_messagef (SCPE_UNK, \"Invalid Command\\n\"); /* only valid inside of do_cmd */\r\n}\r\n\r\n/* Shift command */\r\n/* The shift command is invalid unless encountered in a do_cmd context, */\r\n/* and in that context, it is handled as a special case inside of do_cmd() */\r\n/* and not dispatched here, so if we get here a shift has been issued from */\r\n/* interactive input (it is not valid interactively since it would have to */\r\n/* mess with the program's argv which is owned by the C runtime library */\r\n\r\nt_stat shift_cmd (int32 flag, CONST char *fcptr)\r\n{\r\nreturn SCPE_UNK;                                        /* only valid inside of do_cmd */\r\n}\r\n\r\n/* Call command */\r\n/* The call command is invalid unless encountered in a do_cmd context, */\r\n/* and in that context, it is handled as a special case inside of do_cmd() */\r\n/* and not dispatched here, so if we get here a call has been issued from */\r\n/* interactive input */\r\n\r\nt_stat call_cmd (int32 flag, CONST char *fcptr)\r\n{\r\nchar cbuf[2*CBUFSIZE], gbuf[CBUFSIZE];\r\nconst char *cptr;\r\n\r\nif (NULL == sim_gotofile) return SCPE_UNK;              /* only valid inside of do_cmd */\r\ncptr = get_glyph (fcptr, gbuf, 0);\r\nif ('\\0' == gbuf[0]) return SCPE_ARG;                   /* unspecified goto target */\r\nsnprintf (cbuf, sizeof (cbuf), \"%s%s%s %s\", (NULL != strchr (sim_do_filename[sim_do_depth], ' ')) ? \"\\\"\" : \"\",\r\n                                            sim_do_filename[sim_do_depth],\r\n                                            (NULL != strchr (sim_do_filename[sim_do_depth], ' ')) ? \"\\\"\" : \"\",\r\n                                            cptr);\r\nsim_switches |= SWMASK ('O');                           /* inherit ON state and actions */\r\nreturn do_cmd_label (flag, cbuf, gbuf);\r\n}\r\n\r\n/* On command */\r\n\r\nt_stat on_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nt_stat cond;\r\n\r\ncptr = get_glyph (cptr, gbuf, 0);\r\nif ('\\0' == gbuf[0]) return SCPE_ARG;                   /* unspecified condition */\r\nif (0 == strcmp(\"ERROR\", gbuf))\r\n    cond = 0;\r\nelse {\r\n    if (SCPE_OK != sim_string_to_stat (gbuf, &cond)) {\r\n        if ((MATCH_CMD (gbuf, \"CONTROL_C\") == 0) ||\r\n            (MATCH_CMD (gbuf, \"SIGINT\") == 0))\r\n            cond = ON_SIGINT_ACTION;                    /* Special case */\r\n        else\r\n            return sim_messagef (SCPE_ARG, \"Invalid argument: %s\\n\", gbuf);\r\n        }\r\n    }\r\nif ((NULL == cptr) || ('\\0' == *cptr)) {                /* Empty Action */\r\n    free(sim_on_actions[sim_do_depth][cond]);           /* Clear existing condition */\r\n    sim_on_actions[sim_do_depth][cond] = NULL; }\r\nelse {\r\n    if ((cptr > sim_sub_instr_buf) && ((size_t)(cptr - sim_sub_instr_buf) < sim_sub_instr_size))\r\n        cptr = &sim_sub_instr[sim_sub_instr_off[cptr - sim_sub_instr_buf]]; /* get un-substituted string */\r\n    sim_on_actions[sim_do_depth][cond] =\r\n        (char *)realloc(sim_on_actions[sim_do_depth][cond], 1+strlen(cptr));\r\n    strcpy(sim_on_actions[sim_do_depth][cond], cptr);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* noop command */\r\n/* The noop command (IGNORE, PROCEED) does nothing */\r\n\r\nt_stat noop_cmd (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nreturn SCPE_OK;                                         /* we're happy doing nothing */\r\n}\r\n\r\n/* Set on/noon routine */\r\n\r\nt_stat set_on (int32 flag, CONST char *cptr)\r\n{\r\nif ((flag) && (cptr) && (*cptr)) {                      /* Set ON with arg */\r\n    char gbuf[CBUFSIZE];\r\n\r\n    cptr = get_glyph (cptr, gbuf, 0);                   /* get command glyph */\r\n    if (((MATCH_CMD(gbuf,\"INHERIT\")) &&\r\n         (MATCH_CMD(gbuf,\"NOINHERIT\"))) ||\r\n        (*cptr))\r\n        return SCPE_2MARG;\r\n    if ((gbuf[0]) && (0 == MATCH_CMD(gbuf,\"INHERIT\")))\r\n        sim_on_inherit = 1;\r\n    if ((gbuf[0]) && (0 == MATCH_CMD(gbuf,\"NOINHERIT\")))\r\n        sim_on_inherit = 0;\r\n    return SCPE_OK;\r\n    }\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nsim_on_check[sim_do_depth] = flag;\r\nif ((sim_do_depth != 0) &&\r\n    (NULL == sim_on_actions[sim_do_depth][0])) {        /* default handler set? */\r\n    sim_on_actions[sim_do_depth][0] =                   /* No, so make \"RETURN\" */\r\n        (char *)malloc(1+strlen(\"RETURN\"));             /* be the default action */\r\n    strcpy(sim_on_actions[sim_do_depth][0], \"RETURN\");\r\n    }\r\nif ((sim_do_depth != 0) &&\r\n    (NULL == sim_on_actions[sim_do_depth][SCPE_AFAIL])) {/* handler set for AFAIL? */\r\n    sim_on_actions[sim_do_depth][SCPE_AFAIL] =          /* No, so make \"RETURN\" */\r\n        (char *)malloc(1+strlen(\"RETURN\"));             /* be the action */\r\n    strcpy(sim_on_actions[sim_do_depth][SCPE_AFAIL], \"RETURN\");\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set verify/noverify routine */\r\n\r\nt_stat set_verify (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nif (flag == sim_do_echo)                                /* already set correctly? */\r\n    return SCPE_OK;\r\nsim_do_echo = flag;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set message/nomessage routine */\r\n\r\nt_stat set_message (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nif (flag == sim_show_message)                           /* already set correctly? */\r\n    return SCPE_OK;\r\nsim_show_message = flag;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set quiet/noquiet routine */\r\n\r\nt_stat set_quiet (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nif (flag == sim_quiet)                                  /* already set correctly? */\r\n    return SCPE_OK;\r\nsim_quiet = flag;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set asynch/noasynch routine */\r\n\r\nt_stat sim_set_asynch (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\n#ifdef SIM_ASYNCH_IO\r\nif (flag == sim_asynch_enabled)                         /* already set correctly? */\r\n    return SCPE_OK;\r\nif (1) {\r\n    uint32 i;\r\n    DEVICE *dptr;\r\n\r\n    for (i = 1; (dptr = sim_devices[i]) != NULL; i++) { /* flush attached files */\r\n        if ((DEV_TYPE(dptr) == DEV_ETHER) &&\r\n            (dptr->units->flags & UNIT_ATT))\r\n            return sim_messagef (SCPE_ALATT, \"Can't change asynch mode with %s device attached\\n\", dptr->name);\r\n        }\r\n    }\r\nsim_asynch_enabled = flag;\r\nsim_timer_change_asynch ();\r\nif (1) {\r\n    uint32 i, j;\r\n    DEVICE *dptr;\r\n    UNIT *uptr;\r\n\r\n    /* Call unit flush routines to report asynch status change to device layer */\r\n    for (i = 1; (dptr = sim_devices[i]) != NULL; i++) { /* flush attached files */\r\n        for (j = 0; j < dptr->numunits; j++) {          /* if not buffered in mem */\r\n            uptr = dptr->units + j;\r\n            if ((uptr->flags & UNIT_ATT) &&             /* attached, */\r\n                (uptr->io_flush))                       /* unit specific flush routine */\r\n                uptr->io_flush (uptr);\r\n            }\r\n        }\r\n    }\r\nreturn sim_messagef (SCPE_OK, \"Asynchronous I/O %sabled\\n\", sim_asynch_enabled ? \"en\" : \"dis\");\r\n#else\r\nreturn sim_messagef (SCPE_NOFNC, \"Asynchronous I/O is not available in this simulator\\n\");\r\n#endif\r\n}\r\n\r\n/* Show asynch routine */\r\n\r\nt_stat sim_show_asynch (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\n#ifdef SIM_ASYNCH_IO\r\nfprintf (st, \"Asynchronous I/O is %sabled, %s\\n\", (sim_asynch_enabled) ? \"en\" : \"dis\", AIO_QUEUE_MODE);\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nfprintf (st, \"Asynchronous Clock is %sabled\\n\", (sim_asynch_timer) ? \"en\" : \"dis\");\r\n#endif\r\n#else\r\nfprintf (st, \"Asynchronous I/O is not available in this simulator\\n\");\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set environment routine */\r\n\r\nt_stat sim_set_environment (int32 flag, CONST char *cptr)\r\n{\r\nchar varname[CBUFSIZE], prompt[CBUFSIZE], cbuf[CBUFSIZE];\r\nint i;\r\n\r\nif ((!cptr) || (*cptr == 0))                            /* now eol? */\r\n    return SCPE_2FARG;\r\nif (sim_switches & SWMASK ('P')) {\r\n    CONST char *deflt = NULL;\r\n\r\n    cptr = get_glyph_quoted (cptr, prompt, 0);          /* get prompt */\r\n    if (prompt[0] == '\\0')\r\n        return sim_messagef (SCPE_2FARG, \"Missing Prompt and Environment Variable Name\\n\");\r\n    if ((prompt[0] == '\"') || (prompt[0] == '\\'')) {\r\n        if (strlen (prompt) < 3)\r\n            return sim_messagef (SCPE_ARG, \"Invalid Prompt\\n\");\r\n        prompt[strlen (prompt) - 1] = '\\0';\r\n        memmove (prompt, prompt + 1, strlen (prompt));\r\n        }\r\n    deflt = get_glyph (cptr, varname, '=');             /* get environment variable name */\r\n    if (varname[0] == '\\0')\r\n        return sim_messagef (SCPE_2FARG, \"Missing Environment Variable Name\\n\");\r\n    if (deflt == NULL)\r\n        deflt = \"\";\r\n    if (*deflt) {\r\n        strlcat (prompt, \" [\", sizeof (prompt));\r\n        strlcat (prompt, deflt, sizeof (prompt));\r\n        strlcat (prompt, \"] \", sizeof (prompt));\r\n        }\r\n    else\r\n        strlcat (prompt, \" \", sizeof (prompt));\r\n    if (sim_rem_cmd_active_line == -1) {\r\n        cptr = read_line_p (prompt, cbuf, sizeof(cbuf), stdin);\r\n        if (cptr == NULL)\r\n            printf (\"\\n\");\r\n        if ((cptr == NULL) || (*cptr == 0))\r\n            cptr = deflt;\r\n        else\r\n            cptr = cbuf;\r\n        }\r\n    else\r\n        cptr = deflt;\r\n    }\r\nelse {\r\n    cptr = get_glyph (cptr, varname, '=');              /* get environment variable name */\r\n    strlcpy (cbuf, cptr, sizeof(cbuf));\r\n    sim_trim_endspc (cbuf);\r\n    if (sim_switches & SWMASK ('S')) {                  /* Quote String argument? */\r\n        uint32 str_size;\r\n\r\n        cptr = cbuf;\r\n        get_glyph_quoted (cptr, cbuf, 0);\r\n        if (SCPE_OK != sim_decode_quoted_string (cbuf, (uint8 *)cbuf, &str_size))\r\n            return sim_messagef (SCPE_ARG, \"Invalid quoted string: %s\\n\", cbuf);\r\n        cbuf[str_size] = '\\0';\r\n        }\r\n    else {\r\n        if (sim_switches & SWMASK ('A')) {              /* Arithmetic Expression Evaluation argument? */\r\n            t_svalue val;\r\n            t_stat stat;\r\n            const char *eptr = cptr;\r\n\r\n            if ((cptr > sim_sub_instr_buf) && ((size_t)(cptr - sim_sub_instr_buf) < sim_sub_instr_size))\r\n                eptr = &sim_sub_instr[sim_sub_instr_off[cptr - sim_sub_instr_buf]]; /* get un-substituted string */\r\n            cptr = sim_eval_expression (eptr, &val, FALSE, &stat);\r\n            if (stat == SCPE_OK) {\r\n                sprintf (cbuf, \"%ld\", (long)val);\r\n                cptr = cbuf;\r\n                }\r\n            else\r\n                return stat;\r\n            }\r\n        }\r\n    }\r\nsetenv(varname, cptr, 1);\r\n/* remove the newly set name from the collection of alias conflicting external names */\r\nfor (i = 0; i < sim_external_env_count; i++) {\r\n    if (0 == strcmp (varname, sim_external_env[i].name)) {\r\n        int j;\r\n\r\n        free (sim_external_env[i].name);\r\n        free (sim_external_env[i].value);\r\n        for (j = 0; (i + j) < sim_external_env_count; j++)\r\n            sim_external_env[i + j] = sim_external_env[i + j + 1];\r\n        --sim_external_env_count;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set command */\r\n\r\nt_stat set_cmd (int32 flag, CONST char *cptr)\r\n{\r\nuint32 lvl = 0;\r\nt_stat r;\r\nchar gbuf[CBUFSIZE], *cvptr;\r\nCONST char *svptr;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nMTAB *mptr;\r\nCTAB *gcmdp;\r\nC1TAB *ctbr = NULL, *glbr;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (svptr = cptr, gbuf, 0);               /* get glob/dev/unit */\r\n\r\nif ((dptr = find_dev (gbuf))) {                         /* device match? */\r\n    uptr = dptr->units;                                 /* first unit */\r\n    ctbr = set_dev_tab;                                 /* global table */\r\n    lvl = MTAB_VDV;                                     /* device match */\r\n    GET_SWITCHES (cptr);                                /* get more switches */\r\n    if (dptr->numunits == 1)                            /* Single unit devices have optional */\r\n        lvl |= MTAB_VUN;                                /*  unit number */\r\n    }\r\nelse {\r\n    if ((dptr = find_unit (gbuf, &uptr))) {             /* unit match? */\r\n        if (uptr == NULL)                               /* invalid unit */\r\n            return SCPE_NXUN;\r\n        ctbr = set_unit_tab;                            /* global table */\r\n        lvl = MTAB_VUN;                                 /* unit match */\r\n        GET_SWITCHES (cptr);                            /* get more switches */\r\n        }\r\n    else {\r\n        if ((gcmdp = find_ctab (set_glob_tab, gbuf))) { /* global? */\r\n            GET_SWITCHES (cptr);                        /* get more switches */\r\n            return gcmdp->action (gcmdp->arg, cptr);    /* do the rest */\r\n            }\r\n        else {\r\n            if (sim_dflt_dev->modifiers) {\r\n                if ((cvptr = strchr (gbuf, '=')))       /* = value? */\r\n                    *cvptr++ = 0;\r\n                for (mptr = sim_dflt_dev->modifiers; mptr->mask != 0; mptr++) {\r\n                    if (mptr->mstring && (MATCH_CMD (gbuf, mptr->mstring) == 0)) {\r\n                        dptr = sim_dflt_dev;\r\n                        cptr = svptr;\r\n                        while (sim_isspace(*cptr))\r\n                            ++cptr;\r\n                        break;\r\n                        }\r\n                    }\r\n                }\r\n            if (!dptr)\r\n                return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);/* no match */\r\n            lvl = MTAB_VDV;                             /* device match */\r\n            uptr = dptr->units;                         /* first unit */\r\n            }\r\n        }\r\n    }\r\nif ((*cptr == 0) ||                                     /* must be more */\r\n    (*cptr == ';') ||\r\n    (*cptr == '#'))\r\n    return SCPE_2FARG;\r\nGET_SWITCHES (cptr);                                    /* get more switches */\r\n\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph (svptr = cptr, gbuf, ',');         /* get modifier */\r\n    if (0 == strcmp (gbuf, \";\"))\r\n        break;\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    for (mptr = dptr->modifiers; mptr && (mptr->mask != 0); mptr++) {\r\n        if ((mptr->mstring) &&                          /* match string */\r\n            (MATCH_CMD (gbuf, mptr->mstring) == 0)) {   /* matches option? */\r\n            if (mptr->mask & MTAB_XTD) {                /* extended? */\r\n                if (((lvl & mptr->mask) & ~MTAB_XTD) == 0)\r\n                    return SCPE_ARG;\r\n                if ((lvl == MTAB_VUN) && (uptr->flags & UNIT_DIS))\r\n                    return sim_messagef (SCPE_UDIS, \"Unit disabled: %s\\n\", sim_uname (uptr));\r\n                if (mptr->valid) {                      /* validation rtn? */\r\n                    if (cvptr && MODMASK(mptr,MTAB_QUOTE)) {\r\n                        svptr = get_glyph_quoted (svptr, gbuf, ',');\r\n                        if ((cvptr = strchr (gbuf, '='))) {\r\n                            *cvptr++ = 0;\r\n                            cptr = svptr;\r\n                            }\r\n                        }\r\n                    else {\r\n                        if (cvptr && MODMASK(mptr,MTAB_NC)) {\r\n                            get_glyph_nc (svptr, gbuf, ',');\r\n                            if ((cvptr = strchr (gbuf, '=')))\r\n                                *cvptr++ = 0;\r\n                            }\r\n                        }\r\n                    r = mptr->valid (uptr, mptr->match, cvptr, mptr->desc);\r\n                    if (r != SCPE_OK)\r\n                        return r;\r\n                    }\r\n                else\r\n                    if (!mptr->desc)                    /* value desc? */\r\n                        break;\r\n                    else\r\n                        if (cvptr)                      /* = value? */\r\n                            return SCPE_ARG;\r\n                        else\r\n                            *((int32 *) mptr->desc) = mptr->match;\r\n                }                                       /* end if xtd */\r\n            else {                                      /* old style */\r\n                if (cvptr)                              /* = value? */\r\n                    return SCPE_ARG;\r\n                if (uptr->flags & UNIT_DIS)             /* disabled? */\r\n                    return sim_messagef (SCPE_UDIS, \"Unit disabled: %s\\n\", sim_uname (uptr));\r\n                if ((mptr->valid) &&                    /* invalid? */\r\n                    ((r = mptr->valid (uptr, mptr->match, cvptr, mptr->desc)) != SCPE_OK))\r\n                    return r;\r\n                uptr->flags = (uptr->flags & ~(mptr->mask)) |\r\n                    (mptr->match & mptr->mask);         /* set new value */\r\n                }                                       /* end else xtd */\r\n            break;                                      /* terminate for */\r\n            }                                           /* end if match */\r\n        }                                               /* end for */\r\n    if (!mptr || (mptr->mask == 0)) {                   /* no match? */\r\n        if ((glbr = find_c1tab (ctbr, gbuf))) {         /* global match? */\r\n            r = glbr->action (dptr, uptr, glbr->arg, cvptr);    /* do global */\r\n            if (r != SCPE_OK)\r\n                return r;\r\n            }\r\n        else\r\n            if (!dptr->modifiers)                      /* no modifiers? */\r\n                return sim_messagef (SCPE_NOPARAM, \"%s device has no parameters\\n\", dptr->name);\r\n            else\r\n                return sim_messagef (SCPE_NXPAR, \"%s device: Non-existent parameter - %s\\n\", dptr->name, gbuf);\r\n        }                                               /* end if no mat */\r\n    }                                                   /* end while */\r\nreturn SCPE_OK;                                         /* done all */\r\n}\r\n\r\n/* Match CTAB/CTAB1 name */\r\n\r\nCTAB *find_ctab (CTAB *tab, const char *gbuf)\r\n{\r\nif (!tab)\r\n    return NULL;\r\nfor (; tab->name != NULL; tab++) {\r\n    if (MATCH_CMD (gbuf, tab->name) == 0)\r\n        return tab;\r\n    }\r\nreturn NULL;\r\n}\r\n\r\nC1TAB *find_c1tab (C1TAB *tab, const char *gbuf)\r\n{\r\nif (!tab)\r\n    return NULL;\r\nfor (; tab->name != NULL; tab++) {\r\n    if (MATCH_CMD (gbuf, tab->name) == 0)\r\n        return tab;\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n/* Set device data radix routine */\r\n\r\nt_stat set_dev_radix (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr)\r\n    return SCPE_ARG;\r\ndptr->dradix = flag & 037;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set device enabled/disabled routine */\r\n\r\nt_stat set_dev_enbdis (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nUNIT *up;\r\nuint32 i;\r\n\r\nif (cptr)\r\n    return SCPE_ARG;\r\nif ((dptr->flags & DEV_DISABLE) == 0)                   /* allowed? */\r\n    return SCPE_NOFNC;\r\nif (flag) {                                             /* enable? */\r\n    if ((dptr->flags & DEV_DIS) == 0)                   /* already enb? ok */\r\n        return SCPE_OK;\r\n    dptr->flags = dptr->flags & ~DEV_DIS;               /* no, enable */\r\n    }\r\nelse {\r\n    if (dptr->flags & DEV_DIS)                          /* already dsb? ok */\r\n        return SCPE_OK;\r\n    for (i = 0; i < dptr->numunits; i++) {              /* check units */\r\n        up = (dptr->units) + i;                         /* att or active? */\r\n        if ((up->flags & UNIT_ATT) || sim_is_active (up))\r\n            return sim_messagef (SCPE_NOFNC, \"%s has attached or busy units\\n\", sim_dname (dptr));                          /* can't do it */\r\n        }\r\n    dptr->flags = dptr->flags | DEV_DIS;                /* disable */\r\n    }\r\nif (dptr->reset)                                        /* reset device */\r\n    return dptr->reset (dptr);\r\nelse return SCPE_OK;\r\n}\r\n\r\n/* Set unit enabled/disabled routine */\r\n\r\nt_stat set_unit_enbdis (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr)\r\n    return SCPE_ARG;\r\nif (!(uptr->flags & UNIT_DISABLE))                      /* allowed? */\r\n    return SCPE_NOFNC;\r\nif (flag)                                               /* enb? enable */\r\n    uptr->flags = uptr->flags & ~UNIT_DIS;\r\nelse {\r\n    if ((uptr->flags & UNIT_ATT) ||                     /* dsb */\r\n        sim_is_active (uptr))                           /* more tests */\r\n        return sim_messagef (SCPE_NOFNC, \"%s is attached or busy\\n\", sim_uname (uptr));\r\n    uptr->flags = uptr->flags | UNIT_DIS;               /* disable */\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set device/unit debug enabled/disabled routine */\r\n\r\nt_stat set_dev_debug (DEVICE *dptr, UNIT *uptr, int32 flags, CONST char *cptr)\r\n{\r\nint32 flag = flags & 1;\r\nt_bool uflag = ((flags & 2) != 0);\r\nchar gbuf[CBUFSIZE];\r\nDEBTAB *dep;\r\nt_stat r = SCPE_OK;\r\n\r\nif ((dptr->flags & DEV_DEBUG) == 0)\r\n    return SCPE_NOFNC;\r\nif (cptr == NULL) {                                     /* no arguments? */\r\n    if (uflag)\r\n        uptr->dctrl = flag ? (dptr->debflags ? flag : 0xFFFFFFFF) : 0;/* disable/enable w/o table */\r\n    else\r\n        dptr->dctrl = flag ? (dptr->debflags ? flag : 0xFFFFFFFF) : 0;/* disable/enable w/o table */\r\n    if (flag && dptr->debflags) {                       /* enable with table? */\r\n        for (dep = dptr->debflags; dep->name != NULL; dep++)\r\n            if (uflag)\r\n                uptr->dctrl = uptr->dctrl | dep->mask;      /* set all */\r\n            else\r\n                dptr->dctrl = dptr->dctrl | dep->mask;      /* set all */\r\n        }\r\n    return SCPE_OK;\r\n    }\r\nif (dptr->debflags == NULL)                             /* must have table */\r\n    return sim_messagef (SCPE_ARG, \"The %s device doesn't have DEBUG options.\\n\", dptr->name);\r\nwhile (*cptr) {\r\n    cptr = get_glyph (cptr, gbuf, ';');                 /* get debug flag */\r\n    for (dep = dptr->debflags; dep->name != NULL; dep++) {\r\n        if (strcmp (dep->name, gbuf) == 0) {            /* match? */\r\n            if (flag)\r\n                if (uflag)\r\n                    uptr->dctrl = uptr->dctrl | dep->mask;\r\n                else\r\n                    dptr->dctrl = dptr->dctrl | dep->mask;\r\n            else\r\n                if (uflag)\r\n                    uptr->dctrl = uptr->dctrl & ~dep->mask;\r\n                else\r\n                    dptr->dctrl = dptr->dctrl & ~dep->mask;\r\n            break;\r\n            }\r\n        }                                               /* end for */\r\n    if (dep->mask == 0)                                 /* no match? */\r\n        r = sim_messagef (SCPE_ARG, \"Invalid DEBUG option '%s' for %s device\\n\", gbuf, dptr->name);\r\n    }                                                   /* end while */\r\nreturn r;\r\n}\r\n\r\n/* Set sequential unit position to EOF */\r\n\r\nt_stat set_unit_append (DEVICE *dptr, UNIT *uptr, int32 flags, CONST char *cptr)\r\n{\r\nif (!(uptr->flags & UNIT_SEQ))\r\n    return sim_messagef (SCPE_NOFNC, \"%s is not a sequential device.\\n\", sim_uname (uptr));\r\nif (uptr->flags & UNIT_BUF)\r\n    return sim_messagef (SCPE_NOFNC, \"Can't append to a buffered device %s.\\n\", sim_uname (uptr));\r\nif (!(uptr->flags & UNIT_ATT))\r\n    return SCPE_UNATT;\r\n\r\nif (0 == sim_fseek (uptr->fileref, 0, SEEK_END)) {\r\n    uptr->pos = (t_addr)sim_ftell (uptr->fileref);      /* Position at end of file */\r\n    return SCPE_OK;\r\n    }\r\n\r\nreturn sim_messagef (SCPE_IERR, \"%s Can't seek to end of file: %s - %s\\n\", sim_uname (uptr), sim_attach_name (uptr), strerror (errno));\r\n}\r\n\r\n/* Show command */\r\n\r\nt_stat show_cmd (int32 flag, CONST char *cptr)\r\n{\r\nt_stat r;\r\n\r\ncptr = get_sim_opt (CMD_OPT_SW|CMD_OPT_OF, cptr, &r);\r\n                                                        /* get sw, ofile */\r\nif (!cptr)                                              /* error? */\r\n    return r;\r\nif (sim_ofile) {                                        /* output file? */\r\n    r = show_cmd_fi (sim_ofile, flag, cptr);            /* do show */\r\n    fclose (sim_ofile);\r\n    }\r\nelse {\r\n    r = show_cmd_fi (stdout, flag, cptr);               /* no, stdout, log */\r\n    if ((!sim_oline) && (sim_log && (sim_log != stdout)))\r\n        show_cmd_fi (sim_log, flag, cptr);\r\n    if ((!sim_oline) && (sim_deb && (sim_deb != stdout) && (sim_deb != sim_log)))\r\n        show_cmd_fi (sim_deb, flag, cptr);\r\n    }\r\nreturn r;\r\n}\r\n\r\nt_stat show_cmd_fi (FILE *ofile, int32 flag, CONST char *cptr)\r\n{\r\nuint32 lvl = 0xFFFFFFFF;\r\nchar gbuf[CBUFSIZE], *cvptr;\r\nCONST char *svptr;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nMTAB *mptr;\r\nSHTAB *shtb = NULL, *shptr;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif ((*cptr == 0) || (*cptr == ';') || (*cptr == '#'))   /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (svptr = cptr, gbuf, 0);               /* get next glyph */\r\n\r\nif ((dptr = find_dev (gbuf))) {                         /* device match? */\r\n    uptr = dptr->units;                                 /* first unit */\r\n    shtb = show_dev_tab;                                /* global table */\r\n    lvl = MTAB_VDV;                                     /* device match */\r\n    GET_SWITCHES (cptr);                                /* get more switches */\r\n    }\r\nelse {\r\n    if ((dptr = find_unit (gbuf, &uptr))) {             /* unit match? */\r\n        if (uptr == NULL)                               /* invalid unit */\r\n            return sim_messagef (SCPE_NXUN, \"Non-existent unit: %s\\n\", gbuf);\r\n        if (uptr->flags & UNIT_DIS)                     /* disabled? */\r\n            return sim_messagef (SCPE_UDIS, \"Unit disabled: %s\\n\", gbuf);\r\n        shtb = show_unit_tab;                           /* global table */\r\n        lvl = MTAB_VUN;                                 /* unit match */\r\n        GET_SWITCHES (cptr);                            /* get more switches */\r\n        }\r\n    else {\r\n        if ((shptr = find_shtab (show_glob_tab, gbuf))) {/* global? */\r\n            GET_SWITCHES (cptr);                        /* get more switches */\r\n            return shptr->action (ofile, NULL, NULL, shptr->arg, cptr);\r\n            }\r\n        else {\r\n            if (sim_dflt_dev->modifiers) {\r\n                if ((cvptr = strchr (gbuf, '=')))       /* = value? */\r\n                    *cvptr++ = 0;\r\n                for (mptr = sim_dflt_dev->modifiers; mptr && (mptr->mask != 0); mptr++) {\r\n                    if ((((mptr->mask & MTAB_VDV) == MTAB_VDV) &&\r\n                         (mptr->pstring && (MATCH_CMD (gbuf, mptr->pstring) == 0))) ||\r\n                        (!(mptr->mask & MTAB_VDV) && (mptr->mstring && (MATCH_CMD (gbuf, mptr->mstring) == 0)))) {\r\n                        dptr = sim_dflt_dev;\r\n                        lvl = MTAB_VDV;                 /* device match */\r\n                        cptr = svptr;\r\n                        while (sim_isspace(*cptr))\r\n                            ++cptr;\r\n                        break;\r\n                        }\r\n                    }\r\n                }\r\n            if (!dptr) {\r\n                if ((shptr = find_shtab (show_dev_tab, gbuf)))  /* global match? */\r\n                    return shptr->action (ofile, sim_dflt_dev, uptr, shptr->arg, cptr);\r\n                else\r\n                    return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);/* no match */\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nif ((*cptr == 0) || (*cptr == ';') || (*cptr == '#')) { /* now eol? */\r\n    return (lvl == MTAB_VDV)?\r\n        show_device (ofile, dptr, 0):\r\n        show_unit (ofile, dptr, uptr, -1);\r\n    }\r\nGET_SWITCHES (cptr);                                    /* get more switches */\r\n\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph (cptr, gbuf, ',');                 /* get modifier */\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    for (mptr = dptr->modifiers; mptr && (mptr->mask != 0); mptr++) {\r\n        if (((mptr->mask & MTAB_XTD)?                   /* right level? */\r\n            ((mptr->mask & lvl) == lvl): (MTAB_VUN & lvl)) &&\r\n            ((mptr->disp && mptr->pstring &&            /* named disp? */\r\n            (MATCH_CMD (gbuf, mptr->pstring) == 0))\r\n            )) {\r\n            if (cvptr && !MODMASK(mptr,MTAB_SHP))\r\n                return sim_messagef (SCPE_ARG, \"Invalid Argument: %s=%s\\n\", gbuf, cvptr);\r\n            show_one_mod (ofile, dptr, uptr, mptr, cvptr, 1);\r\n            break;\r\n            }                                           /* end if */\r\n        }                                               /* end for */\r\n    if (!mptr || (mptr->mask == 0)) {                   /* no match? */\r\n        if (shtb && (shptr = find_shtab (shtb, gbuf))) {/* global match? */\r\n            t_stat r;\r\n\r\n            r = shptr->action (ofile, dptr, uptr, shptr->arg, cptr);\r\n            if (r != SCPE_OK)\r\n                return r;\r\n            }\r\n        else {\r\n            if (!dptr->modifiers)                       /* no modifiers? */\r\n                return sim_messagef (SCPE_NOPARAM, \"%s device has no parameters\\n\", dptr->name);\r\n            else\r\n                return sim_messagef (SCPE_NXPAR, \"%s device: Non-existent parameter: %s\\n\", dptr->name, gbuf);\r\n            }\r\n        }                                               /* end if */\r\n    }                                                   /* end while */\r\nreturn SCPE_OK;\r\n}\r\n\r\nSHTAB *find_shtab (SHTAB *tab, const char *gbuf)\r\n{\r\nif (!tab)\r\n    return NULL;\r\nfor (; tab->name != NULL; tab++) {\r\n    if (MATCH_CMD (gbuf, tab->name) == 0)\r\n        return tab;\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n/* Show device and unit */\r\n\r\nstatic size_t dev_name_len;\r\nstatic size_t unit_name_len;\r\n\r\nconst char *_sim_name_prefix (const char *name, const char *prefix, size_t max_name_len)\r\n{\r\nstatic char nambuf[CBUFSIZE];\r\nsize_t prefix_len = prefix ? strlen (prefix) : 0;\r\nsize_t name_len = name ? strlen (name) : 0;\r\nsize_t string_len = prefix_len + name_len;\r\n\r\nsnprintf (nambuf, sizeof (nambuf), \"%s%*s\", prefix ? prefix : \"\",\r\n                                            ((string_len <= 6) && (max_name_len <= 6)) ? -((int)(8 - prefix_len)) :\r\n                                                                                        -((int)(max_name_len + 2)),\r\n                                                                                        name ? name : \"\");\r\nreturn nambuf;\r\n}\r\n\r\nconst char *_sim_dname_prefix (DEVICE *dptr, const char *prefix)\r\n{\r\nreturn _sim_name_prefix (sim_dname (dptr), prefix, dev_name_len);\r\n}\r\n\r\nconst char *_sim_uname_prefix (UNIT *uptr, const char *prefix)\r\n{\r\nreturn _sim_name_prefix (sim_uname (uptr), prefix, unit_name_len);\r\n}\r\n\r\nconst char *_sim_dname (DEVICE *dptr)\r\n{\r\nreturn _sim_dname_prefix (dptr, \"\");\r\n}\r\n\r\nconst char *_sim_uname (UNIT *uptr)\r\n{\r\nreturn _sim_uname_prefix (uptr, \"\");\r\n}\r\n\r\nconst char *_sim_dname_space (void)\r\n{\r\nreturn _sim_dname_prefix (NULL, \"\");\r\n}\r\n\r\nconst char *_sim_uname_space (void)\r\n{\r\nreturn _sim_uname_prefix (NULL, \"\");\r\n}\r\n\r\nvoid _set_dname_len (DEVICE *dptr)\r\n{\r\nuint32 i;\r\n\r\nif (dev_name_len < strlen (sim_dname (dptr)))\r\n    dev_name_len = strlen (sim_dname (dptr));\r\nfor (i = 0; i < dptr->numunits; i++) {\r\n    UNIT *uptr = &dptr->units[i];\r\n\r\n    if (((uptr->flags & UNIT_DIS) == 0) &&\r\n        (unit_name_len < strlen (sim_uname (uptr))))\r\n        unit_name_len = strlen (sim_uname (uptr));\r\n    }\r\n}\r\n\r\nt_stat show_device (FILE *st, DEVICE *dptr, int32 flag)\r\n{\r\nuint32 j, udbl, ucnt;\r\nUNIT *uptr;\r\nint32 toks = -1;\r\nt_bool did_set_dname_len = FALSE;\r\n\r\nif (dev_name_len == 0) {\r\n    _set_dname_len (dptr);\r\n    did_set_dname_len = TRUE;\r\n    }\r\nfprintf (st, \"%s\", _sim_dname (dptr));                   /* print dev name */\r\nif ((flag == 2) && dptr->description) {\r\n    fprintf (st, \"%s\\n\", dptr->description(dptr));\r\n    fprintf (st, \"%s\", _sim_dname_space ());\r\n    }\r\nelse {\r\n    if ((sim_switches & SWMASK ('D')) && dptr->description) {\r\n        fprintf (st, \"%s\\n\", dptr->description(dptr));\r\n        fprintf (st, \"%s\", _sim_dname_space ());\r\n        }\r\n    }\r\nif (qdisable (dptr)) {                                  /* disabled? */\r\n    fprintf (st, \"%s\\n\", \"disabled\");\r\n    goto Cleanup_Return;\r\n    }\r\nfor (j = ucnt = udbl = 0; j < dptr->numunits; j++) {    /* count units */\r\n    uptr = dptr->units + j;\r\n    if (!(uptr->flags & UNIT_DIS))                      /* count enabled units */\r\n        ucnt++;\r\n    else\r\n        if (uptr->flags & UNIT_DISABLE)\r\n            udbl++;                                     /* count user-disabled */\r\n    }\r\nshow_all_mods (st, dptr, dptr->units, MTAB_VDV, &toks); /* show dev mods */\r\nif (dptr->numunits == 0) {\r\n    if (toks)\r\n        fprintf (st, \"\\n\");\r\n    }\r\nelse {\r\n    if (ucnt == 0) {\r\n        fprint_sep (st, &toks, MTAB_VDV);\r\n        fprintf (st, \"all %d units disabled\\n\", udbl);\r\n        }\r\n    else {\r\n        if ((ucnt > 1) || (udbl > 0)) {\r\n            fprint_sep (st, &toks, MTAB_VDV);\r\n            fprintf (st, \"%d units\\n\", ucnt + udbl);\r\n            }\r\n        else {\r\n            if ((flag != 2) || !dptr->description || toks) {\r\n                if ((ucnt == 1) && (toks < 0) && (flag != 2) &&\r\n                    (dptr->description) && ((sim_switches & SWMASK ('D')) == 0))\r\n                    fprintf (st, \"%s\", dptr->description (dptr));\r\n                fprintf (st, \"\\n\");\r\n                }\r\n            }\r\n        }\r\n    toks = 0;\r\n    }\r\nif (flag)                                               /* dev only? */\r\n    goto Cleanup_Return;\r\nfor (j = 0; j < dptr->numunits; j++) {                  /* loop thru units */\r\n    uptr = dptr->units + j;\r\n    if ((uptr->flags & UNIT_DIS) == 0)\r\n        show_unit (st, dptr, uptr, ucnt + udbl);\r\n    }\r\nCleanup_Return:\r\nif (did_set_dname_len)\r\n    dev_name_len = unit_name_len = 0;\r\nreturn SCPE_OK;\r\n}\r\n\r\nvoid fprint_sep (FILE *st, int32 *tokens, int32 flag)\r\n{\r\nfprintf (st, \"%s\", (*tokens > 0) ? \", \" : ((*tokens < 0) ? \"\" : ((flag == MTAB_VDV) ? _sim_dname_space () : _sim_uname_space ())));\r\n*tokens += 1;\r\nif (*tokens == 0)\r\n    *tokens = 1;\r\n}\r\n\r\nt_stat show_unit (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag)\r\n{\r\nint32 toks = -1;\r\n\r\nif (flag > 1)\r\n    fprintf (st, \"%s\", _sim_uname_prefix (uptr, \"  \"));\r\nelse\r\n    if (flag < 0)\r\n        fprintf (st, \"%s\", _sim_uname (uptr));\r\n    else\r\n        toks = 0;\r\nif (uptr->flags & UNIT_FIX) {\r\n    fprint_sep (st, &toks, MTAB_VUN);\r\n    fprint_capac (st, dptr, uptr);\r\n    }\r\nif (uptr->flags & UNIT_ATT) {\r\n    fprint_sep (st, &toks, MTAB_VUN);\r\n    fprintf (st, \"attached to %s\", sim_attach_name (uptr));\r\n    if (uptr->flags & UNIT_RO)\r\n        fprintf (st, \", read only\");\r\n    }\r\nelse {\r\n    if (uptr->flags & UNIT_ATTABLE) {\r\n        fprint_sep (st, &toks, MTAB_VUN);\r\n        fprintf (st, \"not attached\");\r\n        }\r\n    }\r\nshow_all_mods (st, dptr, uptr, MTAB_VUN, &toks);        /* show unit mods */\r\nif (toks || (flag < 0) || (flag > 1))\r\n    fprintf (st, \"\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nconst char *sprint_capac (DEVICE *dptr, UNIT *uptr)\r\n{\r\nstatic char capac_buf[MAX_WIDTH + 12];\r\nt_offset kval = (uptr->flags & UNIT_BINK)? 1024: 1000;\r\nt_offset mval;\r\ndouble remfrac;\r\nt_offset psize = (t_offset)uptr->capac;\r\nconst char *scale, *width;\r\n\r\nif (sim_switches & SWMASK ('B'))\r\n    kval = 1024;\r\nmval = kval * kval;\r\nif (dptr->flags & DEV_SECTORS)\r\n    psize = psize * 512;\r\nif ((dptr->dwidth / dptr->aincr) > 8)\r\n    width = \"W\";\r\nelse\r\n    width = \"B\";\r\nif ((psize < (kval * 10)) &&\r\n    (0 != (psize % kval))) {\r\n    remfrac = 0.0;\r\n    scale = \"\";\r\n    }\r\nelse if ((psize < (mval * 10)) &&\r\n         (0 != (psize % mval))){\r\n    scale = \"K\";\r\n    remfrac = ((double)(psize % kval))/kval;\r\n    psize = psize / kval;\r\n    }\r\nelse {\r\n    scale = \"M\";\r\n    remfrac = ((double)(psize % mval))/mval;\r\n    psize = psize / mval;\r\n    }\r\nsprint_val (capac_buf, (t_value) psize, 10, T_ADDR_W, PV_LEFT);\r\nif ((remfrac != 0.0) && (sim_switches & SWMASK ('R'))) {\r\n    char *plast_char = &capac_buf[strlen (capac_buf) - 1];\r\n    char save_char = *plast_char;\r\n\r\n    sprintf (plast_char, \"%0.3f\", remfrac);\r\n    *plast_char = save_char;\r\n    }\r\nsprintf (&capac_buf[strlen (capac_buf)], \"%s%s\", scale, width);\r\nreturn capac_buf;\r\n}\r\n\r\nvoid fprint_capac (FILE *st, DEVICE *dptr, UNIT *uptr)\r\n{\r\nfprintf (st, \"%s\", sprint_capac (dptr, uptr));\r\n}\r\n\r\nconst char *sim_get_tool_path (const char *tool)\r\n{\r\nchar findcmd[PATH_MAX+1];\r\nstatic char toolpath[PATH_MAX+1];\r\nFILE *f;\r\n\r\n#if defined(_WIN32)\r\n#define FIND_CMD \"where\"\r\n#define FIND_CMD2 \"2>NUL\"\r\n#define popen _popen\r\n#define pclose _pclose\r\n#else\r\n#define FIND_CMD \"command -v\"\r\n#define FIND_CMD2 \"2>/dev/null\"\r\n#define FIND_CMD_EXTRA \"which\"\r\n#define FIND_CMD2_EXTRA \"2>/dev/null\"\r\n#endif\r\nmemset (toolpath, 0, sizeof(toolpath));\r\nsnprintf (findcmd, sizeof (findcmd), \"%s %s %s\", FIND_CMD, tool, FIND_CMD2);\r\nif ((f = popen (findcmd, \"r\"))) {\r\n    do {\r\n        if (NULL == fgets (toolpath, sizeof(toolpath)-1, f))\r\n            break;\r\n        sim_trim_endspc (toolpath);\r\n        } while (toolpath[0] == '\\0');\r\n    pclose (f);\r\n    }\r\nif (toolpath[0] == '\\0') { /* Not found yet? */\r\n#if defined(FIND_CMD_EXTRA) /* Try with alternative command */\r\n    snprintf (findcmd, sizeof (findcmd), \"%s %s %s\", FIND_CMD_EXTRA, tool, FIND_CMD2_EXTRA);\r\n    if ((f = popen (findcmd, \"r\"))) {\r\n        do {\r\n            if (NULL == fgets (toolpath, sizeof(toolpath)-1, f))\r\n                break;\r\n            sim_trim_endspc (toolpath);\r\n            } while (toolpath[0] == '\\0');\r\n        pclose (f);\r\n        }\r\n#endif\r\n    }\r\nreturn toolpath;\r\n}\r\n\r\nstatic const char *_get_tool_version (const char *tool)\r\n{\r\nconst char *toolpath;\r\nchar versioncmd[PATH_MAX+1];\r\nstatic char toolversion[PATH_MAX+1];\r\nFILE *f;\r\n\r\nmemset (toolversion, 0, sizeof(toolversion));\r\ntoolpath = sim_get_tool_path (tool);\r\nif (toolpath[0]) {\r\n    snprintf (versioncmd, sizeof (versioncmd), \"%s --version 2>&1\", tool);\r\n    if ((f = popen (versioncmd, \"r\"))) {\r\n        do {\r\n            if (NULL == fgets (toolversion, sizeof(toolversion)-1, f))\r\n                break;\r\n            sim_trim_endspc (toolversion);\r\n            } while (toolversion[0] == '\\0');\r\n        pclose (f);\r\n        }\r\n    }\r\nreturn toolversion;\r\n}\r\n\r\n/* Show <global name> processors  */\r\n\r\nt_stat show_version (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint32 vmaj = SIM_MAJOR, vmin = SIM_MINOR, vpat = SIM_PATCH, vdelt = SIM_DELTA;\r\nchar vmaj_s[12], vmin_s[12], vpat_s[12], vdelt_s[12];\r\nconst char *cpp = \"\";\r\nconst char *build = \"\";\r\nconst char *arch = \"\";\r\nFILE *saved_st = st;\r\n\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nsprintf (vmaj_s, \"%d\", vmaj);\r\nsetenv (\"SIM_MAJOR\", vmaj_s, 1);\r\nsprintf (vmin_s, \"%d\", vmin);\r\nsetenv (\"SIM_MINOR\", vmin_s, 1);\r\nsprintf (vpat_s, \"%d\", vpat);\r\nsetenv (\"SIM_PATCH\", vpat_s, 1);\r\nfprintf (st, \"%s simulator V%d.%d-%d\", sim_name, vmaj, vmin, vpat);\r\nif (vdelt) {\r\n    sprintf (vdelt_s, \"%d\", vdelt);\r\n    setenv (\"SIM_DELTA\", vdelt_s, 1);\r\n    fprintf (st, \" delta %d\", vdelt);\r\n    }\r\nif (sim_vm_release != NULL) {                           /* if a release string is defined */\r\n    setenv (\"SIM_VM_RELEASE\", sim_vm_release, 1);\r\n    fprintf (st, \" Release %s\", sim_vm_release);        /*   then display it */\r\n    }\r\n#if defined (SIM_VERSION_MODE)\r\nif (1) {\r\n    char mode[] = __STR(SIM_VERSION_MODE);\r\n\r\n    if (NULL != strchr (mode, '\\\"')) {          /* Quoted String? */\r\n        mode[strlen (mode) - 1] = '\\0';         /* strip quotes */\r\n        memmove (mode, mode + 1, strlen (mode));\r\n        }\r\n    fprintf (st, \" %s\", mode);\r\n    setenv (\"SIM_VERSION_MODE\", mode, 1);\r\n    }\r\n#endif\r\nif (flag == 0)\r\n    st = stdnul;\r\nif (1) {\r\n    t_bool idle_capable;\r\n    uint32 os_ms_sleep_1, os_tick_size;\r\n    char os_type[128] = \"Unknown\";\r\n\r\n    fprintf (st, \"\\n    Simulator Framework Capabilities:\");\r\n    fprintf (st, \"\\n        %s\", sim_si64);\r\n    fprintf (st, \"\\n        %s\", sim_sa64);\r\n    fprintf (st, \"\\n        %s\", eth_capabilities());\r\n    idle_capable = sim_timer_idle_capable (&os_ms_sleep_1, &os_tick_size);\r\n    fprintf (st, \"\\n        Idle/Throttling support is %savailable\", idle_capable ? \"\" : \"NOT \");\r\n    if (sim_disk_vhd_support())\r\n        fprintf (st, \"\\n        Virtual Hard Disk (VHD) support\");\r\n    if (sim_disk_raw_support())\r\n        fprintf (st, \"\\n        RAW disk and CD/DVD ROM support\");\r\n#if defined (SIM_ASYNCH_IO)\r\n    fprintf (st, \"\\n        Asynchronous I/O support (%s)\", AIO_QUEUE_MODE);\r\n#endif\r\n#if defined (SIM_ASYNCH_CLOCKS)\r\n    fprintf (st, \"\\n        Asynchronous Clock support\");\r\n#endif\r\n#if defined (SIM_FRONTPANEL_VERSION)\r\n    fprintf (st, \"\\n        FrontPanel API Version %d\", SIM_FRONTPANEL_VERSION);\r\n#endif\r\n    fprintf (st, \"\\n    Host Platform:\");\r\n#if defined (__GNUC__) && defined (__VERSION__)\r\n    fprintf (st, \"\\n        Compiler: GCC %s\", __VERSION__);\r\n#elif defined (__clang_version__)\r\n    fprintf (st, \"\\n        Compiler: clang %s\", __clang_version__);\r\n#elif defined (_MSC_FULL_VER) && defined (_MSC_BUILD)\r\n    fprintf (st, \"\\n        Compiler: Microsoft Visual C++ %d.%02d.%05d.%02d\", _MSC_FULL_VER/10000000, (_MSC_FULL_VER/100000)%100, _MSC_FULL_VER%100000, _MSC_BUILD);\r\n#if defined(_DEBUG)\r\n    build = \" (Debug Build)\";\r\n#else\r\n    build = \" (Release Build)\";\r\n#endif\r\n#elif defined (__DECC_VER)\r\n    fprintf (st, \"\\n        Compiler: DEC C %c%d.%d-%03d\", (\"T SV\")[((__DECC_VER/10000)%10)-6], __DECC_VER/10000000, (__DECC_VER/100000)%100, __DECC_VER%10000);\r\n#elif defined (SIM_COMPILER)\r\n    fprintf (st, \"\\n        Compiler: %s\", __STR(SIM_COMPILER));\r\n#endif\r\n#if defined(__GNUC__)\r\n#if defined(__OPTIMIZE__)\r\n    build = \" (Release Build)\";\r\n#else\r\n    build = \" (Debug Build)\";\r\n#endif\r\n#endif\r\n#if defined(_M_X64) || defined(_M_AMD64) || defined(__amd64__) || defined(__x86_64__)\r\n    arch = \" arch: x64\";\r\n#elif defined(_M_IX86) || defined(__i386)\r\n    arch = \" arch: x86\";\r\n#elif defined(_M_ARM64) || defined(__aarch64_)\r\n    arch = \" arch: ARM64\";\r\n#elif defined(_M_ARM) || defined(__arm__)\r\n    arch = \" arch: ARM\";\r\n#elif defined(__ia64__) || defined(_M_IA64) || defined(__itanium__)\r\n    arch = \" arch: IA-64\";\r\n#endif\r\n#if defined (__DATE__) && defined (__TIME__)\r\n#ifdef  __cplusplus\r\n    cpp = \"C++\";\r\n#else\r\n    cpp = \"C\";\r\n#endif\r\n#if !defined (SIM_BUILD_OS)\r\n    fprintf (st, \"\\n        Simulator Compiled as %s%s%s on %s at %s\", cpp, arch, build, __DATE__, __TIME__);\r\n#else\r\n    fprintf (st, \"\\n        Simulator Compiled as %s%s%s on %s at %s %s\", cpp, arch, build, __DATE__, __TIME__, __STR(SIM_BUILD_OS));\r\n#endif\r\n#endif\r\n#if defined (SIM_BUILD_TOOL)\r\n    fprintf (st, \"\\n        Build Tool: %s\", __STR(SIM_BUILD_TOOL));\r\n#else\r\n    fprintf (st, \"\\n        Build Tool: undefined (probably cmake)\");\r\n#endif\r\n    fprintf (st, \"\\n        Memory Access: %s Endian\", sim_end ? \"Little\" : \"Big\");\r\n    fprintf (st, \"\\n        Memory Pointer Size: %d bits\", (int)sizeof(dptr)*8);\r\n    fprintf (st, \"\\n        %s\", sim_toffset_64 ? \"Large File (>2GB) support\" : \"No Large File support\");\r\n    fprintf (st, \"\\n        SDL Video support: %s\", vid_version());\r\n    if (sim_pcre_regex_available)\r\n        fprintf (st, \"\\n        PCRE RegEx (Version %s) support for EXPECT commands\", pcre_version());\r\n    else\r\n        fprintf (st, \"\\n        No RegEx support for EXPECT commands\");\r\n    fprintf (st, \"\\n        OS clock resolution: %dms\", os_tick_size);\r\n    fprintf (st, \"\\n        Time taken by msleep(1): %dms\", os_ms_sleep_1);\r\n    if (sim_editline_version != 0) {\r\n        if (sim_editline_version > 0xFFFF)\r\n            fprintf (st, \"\\n        WinEditLine Version: %d.%d%02X\", sim_editline_version >> 16, (sim_editline_version >> 8) & 0xFF, sim_editline_version & 0xFF);\r\n        else\r\n            fprintf (st, \"\\n        EditLine Version: %d.%d\", (sim_editline_version >> 8) & 0xFF, sim_editline_version & 0xFF);\r\n        }\r\n    if (eth_version ())\r\n        fprintf (st, \"\\n        Ethernet packet info: %s\", eth_version());\r\n#if defined(__VMS)\r\n    if (1) {\r\n        char *arch =\r\n#if defined(__ia64)\r\n            \"I64\";\r\n#elif defined(__ALPHA)\r\n            \"Alpha\";\r\n#else\r\n            \"VAX\";\r\n#endif\r\n        strlcpy (os_type, \"OpenVMS \", sizeof (os_type));\r\n        strlcat (os_type, arch, sizeof (os_type));\r\n        fprintf (st, \"\\n        OS: OpenVMS %s %s\", arch, __VMS_VERSION);\r\n        }\r\n#elif defined(_WIN32)\r\n    if (1) {\r\n        char *proc_id = getenv (\"PROCESSOR_IDENTIFIER\");\r\n        char *arch = getenv (\"PROCESSOR_ARCHITECTURE\");\r\n        char *procs = getenv (\"NUMBER_OF_PROCESSORS\");\r\n        char *proc_level = getenv (\"PROCESSOR_LEVEL\");\r\n        char *proc_rev = getenv (\"PROCESSOR_REVISION\");\r\n        char *proc_arch3264 = getenv (\"PROCESSOR_ARCHITEW6432\");\r\n        char osversion[PATH_MAX+1] = \"\";\r\n        char cores[64] = \"\";\r\n        char tarversion[PATH_MAX+1] = \"\";\r\n        char curlversion[PATH_MAX+1] = \"\";\r\n        char wmicpath[PATH_MAX+1] = \"\";\r\n        char proc_name[CBUFSIZE] = \"\";\r\n        FILE *f;\r\n\r\n        if ((f = _popen (\"ver\", \"r\"))) {\r\n            do {\r\n                if (NULL == fgets (osversion, sizeof (osversion), f))\r\n                    break;\r\n                sim_trim_endspc (osversion);\r\n                } while (osversion[0] == '\\0');\r\n            _pclose (f);\r\n            }\r\n        if ((f = _popen (\"WMIC CPU Get NumberOfCores\", \"r\"))) {\r\n            do {\r\n                if (NULL == fgets (cores, sizeof (cores), f))\r\n                    break;\r\n                sim_trim_endspc (cores);\r\n                } while (!isdigit (cores[0]));\r\n            _pclose (f);\r\n            }\r\n        setenv (\"SIM_HOST_CORE_COUNT\", cores, 1);\r\n        setenv (\"SIM_HOST_MAX_THREADS\", procs, 1);\r\n        fprintf (st, \"\\n        OS: %s\", osversion);\r\n        fprintf (st, \"\\n        Architecture: %s%s%s, %s%s%sLogical Processors: %s\", arch, proc_arch3264 ? \" on \" : \"\", proc_arch3264 ? proc_arch3264  : \"\", (cores[0] == '\\0') ? \"\" : \"Cores: \", cores, (cores[0] == '\\0') ? \"\" : \", \", procs);\r\n        fprintf (st, \"\\n        Processor Id: %s, Level: %s, Revision: %s\", proc_id ? proc_id : \"\", proc_level ? proc_level : \"\", proc_rev ? proc_rev : \"\");\r\n        strlcpy (wmicpath, sim_get_tool_path (\"wmic\"), sizeof (wmicpath));\r\n        if (wmicpath[0]) {\r\n            strlcat (wmicpath, \" cpu get name\", sizeof (wmicpath));\r\n            if ((f = _popen (wmicpath, \"r\"))) {\r\n                memset (proc_name, 0, sizeof(proc_name));\r\n                do {\r\n                    if (NULL == fgets (proc_name, sizeof(proc_name)-1, f))\r\n                        break;\r\n                    sim_trim_endspc (proc_name);\r\n                    if (0 == strcmp (proc_name, \"Name\"))    /* skip header line */\r\n                        memset (proc_name, 0, sizeof (proc_name));\r\n                    } while (proc_name[0] == '\\0');\r\n                _pclose (f);\r\n                }\r\n            if (proc_name[0] != '\\0')\r\n                fprintf (st, \"\\n        Processor Name: %s\", proc_name);\r\n            }\r\n        strlcpy (os_type, \"Windows\", sizeof (os_type));\r\n        strlcpy (tarversion, _get_tool_version (\"tar\"), sizeof (tarversion));\r\n        if (tarversion[0]) {\r\n            fprintf (st, \"\\n        tar tool: %s\", tarversion);\r\n            setenv (\"SIM_TAR_CMD_AVAILABLE\", \"TRUE\", 1);\r\n            }\r\n        strlcpy (curlversion, _get_tool_version (\"curl\"), sizeof (curlversion));\r\n        if (curlversion[0]) {\r\n            fprintf (st, \"\\n        curl tool: %s\", curlversion);\r\n            setenv (\"SIM_CURL_CMD_AVAILABLE\", \"TRUE\", 1);\r\n            }\r\n        }\r\n#else\r\n    if (1) {\r\n        char osname[2*PATH_MAX+1] = \"\";\r\n        char osversion[2*PATH_MAX+1] = \"\";\r\n        char tarversion[PATH_MAX+1] = \"\";\r\n        char curlversion[PATH_MAX+1] = \"\";\r\n        FILE *f;\r\n        char *c;\r\n        const char *run_context = \"\";\r\n#if defined(SIM_BUILD_OS_VERSION)\r\n        char buildosversion[2*PATH_MAX+1] = __STR(SIM_BUILD_OS_VERSION);\r\n\r\n        /* compress multiple spaces to one */\r\n        c = buildosversion;\r\n        while ((c = strstr (c, \"  \")))\r\n            memmove (c, c+1, strlen (c));\r\n#endif\r\n        if ((f = popen (\"uname -a | sed 's/,//g'\", \"r\"))) {\r\n            memset (osversion, 0, sizeof (osversion));\r\n            do {\r\n                if (NULL == fgets (osversion, sizeof (osversion)-1, f))\r\n                    break;\r\n                sim_trim_endspc (osversion);\r\n                } while (osversion[0] == '\\0');\r\n            pclose (f);\r\n            }\r\n        /* compress multiple spaces to one */\r\n        c = osversion;\r\n        while ((c = strstr (c, \"  \")))\r\n            memmove (c, c+1, strlen (c));\r\n        if ((f = popen (\"grep PRETTY_NAME /etc/os-release 2>/dev/null\", \"r\"))) {\r\n            memset (osname, 0, sizeof (osname));\r\n            do {\r\n                if (NULL == fgets (osname, sizeof (osname)-1, f))\r\n                    break;\r\n                sim_trim_endspc (osname);\r\n                } while (osname[0] == '\\0');\r\n            pclose (f);\r\n            }\r\n        if ((c = strchr (osname, '=')))\r\n            memmove (osname, c+1, strlen(c));\r\n        while (isspace (osname[0]))\r\n            memmove (osname, osname+1, strlen(osname));\r\n        if (osname[0] == '\"')\r\n            memmove (osname, osname+1, strlen(osname));\r\n        if ((osname[0] != '\\0') && (osname[strlen(osname)-1] == '\"'))\r\n            osname[strlen(osname)-1] = '\\0';\r\n        if (osname[0] != '\\0')\r\n            fprintf (st, \"\\n        Operating System: %s\", osname);\r\n        else {\r\n            if ((f = popen (\"sw_vers -ProductVersion 2>/dev/null\", \"r\"))) {\r\n                memset (osname, 0, sizeof (osname));\r\n                do {\r\n                    if (NULL == fgets (osname, sizeof (osname)-1, f))\r\n                        break;\r\n                    sim_trim_endspc (osname);\r\n                    } while (osname[0] == '\\0');\r\n                pclose (f);\r\n                }\r\n            if (osname[0] != '\\0')\r\n                fprintf (st, \"\\n        Operating System: macOS %s\", osname);\r\n            }\r\n#if defined(SIM_BUILD_OS_VERSION)\r\n        if (strcmp(osversion, buildosversion) != 0) {\r\n            fprintf (st, \"\\n        Built on OS: %s\", buildosversion);\r\n            run_context = \"Running on \";\r\n            }\r\n#endif\r\n        fprintf (st, \"\\n        %sOS: %s\", run_context, osversion);\r\n        if ((f = popen (\"uname\", \"r\"))) {\r\n            memset (os_type, 0, sizeof (os_type));\r\n            do {\r\n                if (NULL == fgets (os_type, sizeof (os_type)-1, f))\r\n                    break;\r\n                sim_trim_endspc (os_type);\r\n                } while (os_type[0] == '\\0');\r\n            pclose (f);\r\n            }\r\n#if (defined(__linux) || defined(__linux__))\r\n        if ((f = popen (\"lscpu 2>/dev/null\", \"r\"))) {\r\n            char line[256];\r\n            char arch[PATH_MAX+1] = \"\";\r\n            char cores[PATH_MAX+1] = \"\";\r\n            char procs[PATH_MAX+1] = \"\";\r\n            char proc_name[PATH_MAX+1] = \"\";\r\n\r\n            do {\r\n                if (NULL == fgets (line, sizeof (line), f))\r\n                    break;\r\n                sim_trim_endspc (line);\r\n                if (0 == memcmp (\"Architecture:\", line, 13)) {\r\n                    size_t offset = 13 + strspn (line + 13, \" \");\r\n                    strlcpy (arch, &line[offset], sizeof (arch));\r\n                    }\r\n                if (0 == memcmp (\"Model name:\", line, 11)) {\r\n                    size_t offset = 11 + strspn (line + 11, \" \");\r\n                    strlcpy (proc_name, &line[offset], sizeof (proc_name));\r\n                    }\r\n                if (0 == memcmp (\"CPU(s):\", line, 7)) {\r\n                    size_t offset = 7 + strspn (line + 7, \" \");\r\n                    strlcpy (procs, &line[offset], sizeof (procs));\r\n                    }\r\n                if (0 == memcmp (\"Core(s) per socket:\", line, 19)) {\r\n                    size_t offset = 19 + strspn (line + 19, \" \");\r\n                    strlcpy (cores, &line[offset], sizeof (cores));\r\n                    }\r\n                } while ((arch[0] == '\\0') || (proc_name[0] == '\\0') || (procs[0] == '\\0') || (cores[0] == '\\0'));\r\n            pclose (f);\r\n            if (proc_name[0] != '\\0')\r\n                fprintf (st, \"\\n        Processor Name: %s\", proc_name);\r\n            if ((arch[0] != '\\0') || (procs[0] != '\\0') || (cores[0] != '\\0'))\r\n                fprintf (st, \"\\n        \");\r\n            if (arch[0] != '\\0')\r\n                fprintf (st, \"Architecture: %s\", arch);\r\n            if (cores[0] != '\\0') {\r\n                fprintf (st, \", Cores: %s\", cores);\r\n                setenv (\"SIM_HOST_CORE_COUNT\", cores, 1);\r\n                }\r\n            if (procs[0] != '\\0') {\r\n                fprintf (st, \", Logical Processors: %s\", procs);\r\n                setenv (\"SIM_HOST_MAX_THREADS\", procs, 1);\r\n                }\r\n            }\r\n#elif defined (__APPLE__)\r\n        if ((f = popen (\"sysctl machdep.cpu 2>/dev/null\", \"r\"))) {\r\n            char line[256];\r\n            char cores[PATH_MAX+1] = \"\";\r\n            char procs[PATH_MAX+1] = \"\";\r\n            char proc_name[PATH_MAX+1] = \"\";\r\n\r\n            do {\r\n                if (NULL == fgets (line, sizeof (line), f))\r\n                    break;\r\n                sim_trim_endspc (line);\r\n                if (0 == memcmp (\"machdep.cpu.brand_string:\", line, 25)) {\r\n                    size_t offset = 25 + strspn (line + 25, \" \");\r\n                    strlcpy (proc_name, &line[offset], sizeof (proc_name));\r\n                    }\r\n                if (0 == memcmp (\"machdep.cpu.core_count:\", line, 23)) {\r\n                    size_t offset = 23 + strspn (line + 23, \" \");\r\n                    strlcpy (cores, &line[offset], sizeof (cores));\r\n                    }\r\n                if (0 == memcmp (\"machdep.cpu.thread_count:\", line, 25)) {\r\n                    size_t offset = 25 + strspn (line + 25, \" \");\r\n                    strlcpy (procs, &line[offset], sizeof (procs));\r\n                    }\r\n                } while ((proc_name[0] == '\\0') || (cores[0] == '\\0') || (procs[0] == '\\0'));\r\n            pclose (f);\r\n            if (proc_name[0] != '\\0')\r\n                fprintf (st, \"\\n        Processor Name: %s\", proc_name);\r\n            if ((procs[0] != '\\0') || (cores[0] != '\\0'))\r\n                fprintf (st, \"\\n        \");\r\n            if (cores[0] != '\\0') {\r\n                fprintf (st, \"Cores: %s\", cores);\r\n                setenv (\"SIM_HOST_CORE_COUNT\", cores, 1);\r\n                }\r\n            if (procs[0] != '\\0') {\r\n                fprintf (st, \", Logical Processors: %s\", procs);\r\n                setenv (\"SIM_HOST_MAX_THREADS\", procs, 1);\r\n                }\r\n            }\r\n#endif\r\n        strlcpy (tarversion, _get_tool_version (\"tar\"), sizeof (tarversion));\r\n        if (tarversion[0]) {\r\n            fprintf (st, \"\\n        tar tool: %s\", tarversion);\r\n            setenv (\"SIM_TAR_CMD_AVAILABLE\", \"TRUE\", 1);\r\n            }\r\n        strlcpy (curlversion, _get_tool_version (\"curl\"), sizeof (curlversion));\r\n        if (curlversion[0]) {\r\n            fprintf (st, \"\\n        curl tool: %s\", curlversion);\r\n            setenv (\"SIM_CURL_CMD_AVAILABLE\", \"TRUE\", 1);\r\n            }\r\n        }\r\n#endif\r\n    if ((!strcmp (os_type, \"Unknown\")) && (getenv (\"OSTYPE\")))\r\n        strlcpy (os_type, getenv (\"OSTYPE\"), sizeof (os_type));\r\n    setenv (\"SIM_OSTYPE\", os_type, 1);\r\n    }\r\nif (flag == 0)\r\n    st = saved_st;\r\n#if defined(SIM_GIT_COMMIT_ID)\r\nif (1) {\r\n    const char *extras = strchr (__STR(SIM_GIT_COMMIT_ID), '+');\r\n\r\n    fprintf (st, \"%sgit commit id: %8.8s%s\", flag ? \"\\n        \" : \"        \", __STR(SIM_GIT_COMMIT_ID), extras ? extras : \"\");\r\n    setenv (\"SIM_GIT_COMMIT_ID\", __STR(SIM_GIT_COMMIT_ID), 1);\r\n    }\r\n#if defined(SIM_GIT_COMMIT_TIME)\r\nsetenv (\"SIM_GIT_COMMIT_TIME\", __STR(SIM_GIT_COMMIT_TIME), 1);\r\nif (flag)\r\n    fprintf (st, \"%sgit commit time: %s\", \"\\n        \", __STR(SIM_GIT_COMMIT_TIME));\r\n#endif\r\n#else\r\n#if defined(SIM_ARCHIVE_GIT_COMMIT_ID)\r\nif (NULL == strchr (__STR(SIM_ARCHIVE_GIT_COMMIT_ID), '$')) {\r\n    const char *extras = strchr (__STR(SIM_ARCHIVE_GIT_COMMIT_ID), '+');\r\n\r\n    fprintf (st, \"%ssimh git commit id: %8.8s%s\", flag ? \"\\n        \" : \"        \", __STR(SIM_ARCHIVE_GIT_COMMIT_ID), extras ? extras : \"\");\r\n    setenv (\"SIM_ARCHIVE_GIT_COMMIT_ID\", __STR(SIM_ARCHIVE_GIT_COMMIT_ID), 1);\r\n    }\r\n#if defined(SIM_ARCHIVE_GIT_COMMIT_TIME)\r\nif (NULL == strchr (__STR(SIM_ARCHIVE_GIT_COMMIT_TIME), '$')) {\r\n    setenv (\"SIM_ARCHIVE_GIT_COMMIT_TIME\", __STR(SIM_ARCHIVE_GIT_COMMIT_TIME), 1);\r\n    if (flag)\r\n        fprintf (st, \"%ssimh git commit time: %s\", \"\\n        \", __STR(SIM_ARCHIVE_GIT_COMMIT_TIME));\r\n    }\r\n#endif\r\n#endif\r\n#endif\r\n#if defined(SIM_BUILD)\r\nfprintf (st, \"%sBuild: %s\", flag ? \"\\n        \" : \"        \", __STR(SIM_BUILD));\r\n#endif\r\nfprintf (st, \"\\n\");\r\nif (sim_vm_release_message != NULL)                    /* if a release message string is defined */\r\n    fprintf (st, \"\\n%s\", sim_vm_release_message);      /*   then display it */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_config (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr)\r\n{\r\nint32 i;\r\nDEVICE *dptr;\r\nt_bool only_enabled = (sim_switches & SWMASK ('E'));\r\n\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nfprintf (st, \"%s simulator configuration%s\\n\\n\", sim_name, only_enabled ? \" (enabled devices)\" : \"\");\r\nfor (i = dev_name_len = unit_name_len = 0; (dptr = sim_devices[i]) != NULL; i++)\r\n    if (!only_enabled || !qdisable (dptr))\r\n        _set_dname_len (dptr);\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++)\r\n    if (!only_enabled || !qdisable (dptr))\r\n        show_device (st, dptr, flag);\r\nif (sim_switches & SWMASK ('I')) {\r\n    for (i = dev_name_len = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i)\r\n        if (!only_enabled || !qdisable (dptr))\r\n            _set_dname_len (dptr);\r\n    fprintf (st, \"\\nInternal Devices%s\\n\\n\", only_enabled ? \" (enabled devices)\" : \"\");\r\n    for (i = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i)\r\n        if (!only_enabled || !qdisable (dptr))\r\n            show_device (st, dptr, flag);\r\n    }\r\ndev_name_len = unit_name_len = 0;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_log_names (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr)\r\n{\r\nint32 i;\r\nDEVICE *dptr;\r\n\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++)\r\n    show_dev_logicals (st, dptr, NULL, 1, cptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_dev_logicals (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nuint32 u;\r\nt_bool found = FALSE;\r\n\r\nfor (u = 0; u < dptr->numunits; u++) {\r\n    if (dptr->units[u].lname) {\r\n        found = TRUE;\r\n        fprintf (st, \"%s -> %s%u\\n\", dptr->units[u].lname, dptr->name, u);\r\n        }\r\n    }\r\nif (dptr->lname)\r\n    fprintf (st, \"%s -> %s\\n\", dptr->lname, dptr->name);\r\nelse\r\n    if ((!flag) && (!found))\r\n        fputs (\"no logical name assigned\\n\", st);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_queue (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr)\r\n{\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nMEMFILE buf;\r\n\r\nmemset (&buf, 0, sizeof (buf));\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nif (sim_clock_queue == QUEUE_LIST_END)\r\n    fprintf (st, \"%s event queue empty, time = %.0f, executing %s %s/sec\\n\",\r\n             sim_name, sim_time, sim_fmt_numeric (sim_timer_inst_per_sec ()), sim_vm_interval_units);\r\nelse {\r\n    const char *tim = \"\";\r\n    double inst_per_sec = sim_timer_inst_per_sec ();\r\n\r\n    fprintf (st, \"%s event queue status, time = %.0f, executing %s %s/sec\\n\",\r\n             sim_name, sim_time, sim_fmt_numeric (inst_per_sec), sim_vm_interval_units);\r\n    for (uptr = sim_clock_queue; uptr != QUEUE_LIST_END; uptr = uptr->next) {\r\n        if (uptr == &sim_step_unit)\r\n            fprintf (st, \"  Step timer\");\r\n        else\r\n            if (uptr == &sim_expect_unit)\r\n                fprintf (st, \"  Expect fired\");\r\n            else\r\n                if ((dptr = find_dev_from_unit (uptr)) != NULL) {\r\n                    fprintf (st, \"  %s\", sim_dname (dptr));\r\n                    if (dptr->numunits > 1)\r\n                        fprintf (st, \" unit %d\", (int32) (uptr - dptr->units));\r\n                    }\r\n                else\r\n                    fprintf (st, \"  Unknown\");\r\n        if (inst_per_sec != 0.0) {\r\n            tim = sim_fmt_secs(((_sim_activate_queue_time (uptr) - 1) / sim_timer_inst_per_sec ()) + (uptr->usecs_remaining / 1000000.0));\r\n            if (strcmp (tim, \"0 seconds\") == 0)\r\n                tim = \"\";\r\n            }\r\n        if (uptr->usecs_remaining)\r\n            fprintf (st, \" at %d plus %.0f usecs%s%s%s%s\\n\", _sim_activate_queue_time (uptr) - 1, uptr->usecs_remaining,\r\n                                            (*tim) ? \" (\" : \"\", tim, (*tim) ? \" total)\" : \"\",\r\n                                            (uptr->flags & UNIT_IDLE) ? \" (Idle capable)\" : \"\");\r\n        else\r\n            fprintf (st, \" at %d%s%s%s%s\\n\", _sim_activate_queue_time (uptr) - 1,\r\n                                            (*tim) ? \" (\" : \"\", tim, (*tim) ? \")\" : \"\",\r\n                                            (uptr->flags & UNIT_IDLE) ? \" (Idle capable)\" : \"\");\r\n        }\r\n    }\r\nsim_show_clock_queues (st, dnotused, unotused, flag, cptr);\r\n#if defined (SIM_ASYNCH_IO)\r\npthread_mutex_lock (&sim_asynch_lock);\r\nsim_mfile = &buf;\r\nfprintf (st, \"asynchronous pending event queue\\n\");\r\nif (sim_asynch_queue == QUEUE_LIST_END)\r\n    fprintf (st, \"  Empty\\n\");\r\nelse {\r\n    for (uptr = sim_asynch_queue; uptr != QUEUE_LIST_END; uptr = uptr->a_next) {\r\n        if ((dptr = find_dev_from_unit (uptr)) != NULL) {\r\n            fprintf (st, \"  %s\", sim_dname (dptr));\r\n            if (dptr->numunits > 1) fprintf (st, \" unit %d\",\r\n                (int32) (uptr - dptr->units));\r\n            }\r\n        else fprintf (st, \"  Unknown\");\r\n        fprintf (st, \" event delay %d\\n\", uptr->a_event_time);\r\n        }\r\n    }\r\nfprintf (st, \"asynch latency: %d nanoseconds\\n\", sim_asynch_latency);\r\nfprintf (st, \"asynch instruction latency: %d %s\\n\", sim_asynch_inst_latency, sim_vm_interval_units);\r\npthread_mutex_unlock (&sim_asynch_lock);\r\nsim_mfile = NULL;\r\nfprintf (st, \"%*.*s\", (int)buf.pos, (int)buf.pos, buf.buf);\r\nfree (buf.buf);\r\n#endif /* SIM_ASYNCH_IO */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_time (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nfprintf (st, \"Time:\\t%.0f\\n\", sim_gtime());\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_break (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nt_stat r;\r\n\r\nif (cptr && (*cptr != 0))\r\n    r = ssh_break (st, cptr, 1);  /* more? */\r\nelse\r\n    r = sim_brk_showall (st, sim_switches);\r\nreturn r;\r\n}\r\n\r\nt_stat show_dev_radix (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nfprintf (st, \"Radix=%d\\n\", dptr->dradix);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_dev_debug (FILE *st, DEVICE *dptr, UNIT *uptr, int32 uflag, CONST char *cptr)\r\n{\r\nDEBTAB *dep;\r\nuint32 unit;\r\nint32 any = 0;\r\n\r\nif (uflag) {\r\n    if ((dptr->flags & DEV_DEBUG) || (dptr->debflags)) {\r\n        if (!uptr->dctrl)\r\n            return SCPE_OK;\r\n        if (dptr->debflags == NULL)\r\n            fprintf (st, \"%s: Debugging enabled\\n\", sim_uname (uptr));\r\n        else {\r\n            uint32 dctrl = uptr->dctrl;\r\n\r\n            for (dep = dptr->debflags; (dctrl != 0) && (dep->name != NULL); dep++) {\r\n                if ((dctrl & dep->mask) == dep->mask) {\r\n                    dctrl &= ~dep->mask;\r\n                    if (any)\r\n                        fputc (';', st);\r\n                    else\r\n                        fprintf (st, \"%s: Debug=\", sim_uname (uptr));\r\n                    fputs (dep->name, st);\r\n                    any = 1;\r\n                    }\r\n                }\r\n            if (any)\r\n                fputc ('\\n', st);\r\n            }\r\n        }\r\n    return SCPE_OK;\r\n    }\r\nif ((dptr->flags & DEV_DEBUG) || (dptr->debflags)) {\r\n    if (dptr->dctrl == 0)\r\n        fputs (\"Debugging disabled\", st);\r\n    else if (dptr->debflags == NULL)\r\n        fputs (\"Debugging enabled\", st);\r\n    else {\r\n        uint32 dctrl = dptr->dctrl;\r\n\r\n        fputs (\"Debug=\", st);\r\n        for (dep = dptr->debflags; (dctrl != 0) && (dep->name != NULL); dep++) {\r\n            if ((dctrl & dep->mask) == dep->mask) {\r\n                dctrl &= ~dep->mask;\r\n                if (any)\r\n                    fputc (';', st);\r\n                fputs (dep->name, st);\r\n                any = 1;\r\n                }\r\n            }\r\n        }\r\n    fputc ('\\n', st);\r\n    for (unit = 0; unit < dptr->numunits; unit++)\r\n        show_dev_debug (st, dptr, &dptr->units[unit], 1, NULL);\r\n    return SCPE_OK;\r\n    }\r\nelse return SCPE_NOFNC;\r\n}\r\n\r\n/* Show On actions for one level (default current level) */\r\n\r\nt_stat show_on (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint32 lvl, i;\r\n\r\nif (cptr && (*cptr != 0)) return SCPE_2MARG;            /* now eol? */\r\nif (flag < 0)\r\n    lvl = sim_do_depth;\r\nelse\r\n    if (flag > sim_do_depth)\r\n        return SCPE_ARG;\r\n    else\r\n        lvl = flag;\r\nif (flag == -1) {\r\n    if (lvl > 0)\r\n        fprintf(st, \"On Processing at Do Nest Level: %d\", lvl);\r\n    else\r\n        fprintf(st, \"On Processing for input commands\");\r\n    }\r\nelse\r\n    fprintf(st, \"On Processing\");\r\nfprintf(st, \" is %s\\n\", (sim_on_check[lvl]) ? \"enabled\" : \"disabled\");\r\nfor (i=1; i<SCPE_BASE; ++i) {\r\n    if (sim_on_actions[lvl][i])\r\n        fprintf(st, \"    on %6d    %s\\n\", i, sim_on_actions[lvl][i]); }\r\nfor (i=SCPE_BASE; i<=SCPE_MAX_ERR; ++i) {\r\n    if (sim_on_actions[lvl][i])\r\n        fprintf(st, \"    on %-6s    %s\\n\", scp_errors[i-SCPE_BASE].code, sim_on_actions[lvl][i]); }\r\nif (sim_on_actions[lvl][0])\r\n    fprintf(st, \"    on ERROR     %s\\n\", sim_on_actions[lvl][0]);\r\nif (sim_on_actions[lvl][ON_SIGINT_ACTION]) {\r\n    fprintf(st, \"CONTROL+C/SIGINT Handling:\\n\");\r\n    fprintf(st, \"    on CONTROL_C %s\\n\", sim_on_actions[lvl][ON_SIGINT_ACTION]);\r\n    }\r\nfprintf(st, \"\\n\");\r\nif ((flag < 0) && sim_on_inherit)\r\n    fprintf(st, \"on state and actions are inherited by nested do commands and subroutines\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_do (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint32 lvl;\r\n\r\nif (cptr && (*cptr != 0)) return SCPE_2MARG;            /* now eol? */\r\nfor (lvl=sim_do_depth; lvl >= 0; --lvl) {\r\n    if (lvl > 0)\r\n        fprintf(st, \"Do Nest Level: %d\\n\", lvl);\r\n    else {\r\n        if (sim_do_filename[lvl][0])\r\n            fprintf(st, \"Initial Input \");\r\n        else\r\n            fprintf(st, \"Console Input commands\\n\");\r\n        }\r\n    if (sim_do_filename[lvl][0]) {\r\n        fprintf (st, \"File: %s\", sim_relative_path (sim_do_filename[lvl]));\r\n        if (strcasecmp (sim_do_filename[lvl], \"<stdin>\"))\r\n            fprintf (st, \" Line: %d\\n\", sim_goto_line[lvl]);\r\n        else\r\n            fprintf (st, \"\\n\");\r\n        }\r\n    if (sim_if_cmd[lvl])\r\n        fprintf (st, \"Processing IF command\\n\");\r\n    if (sim_if_cmd_last[lvl])\r\n        fprintf (st, \"IF command last\\n\");\r\n    if (sim_if_result[lvl])\r\n        fprintf (st, \"IF result\\n\");\r\n    if (sim_if_result_last[lvl])\r\n        fprintf (st, \"IF result last\\n\");\r\n    if (sim_cptr_is_action[lvl])\r\n        fprintf (st, \"Command is Action\\n\");\r\n    fprintf (st, \"Command is: %s\\n\", sim_do_ocptr[lvl]);\r\n    show_on (st, dptr, uptr, lvl, cptr);\r\n    }\r\nif (sim_on_inherit)\r\n    fprintf(st, \"on state and actions are inherited by nested do commands and subroutines\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show modifiers */\r\n\r\nt_stat show_mod_names (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr)\r\n{\r\nint32 i;\r\nDEVICE *dptr;\r\n\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++)\r\n    show_dev_modifiers (st, dptr, NULL, flag, cptr);\r\nfor (i = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i)\r\n    show_dev_modifiers (st, dptr, NULL, flag, cptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_dev_modifiers (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nfprint_set_help (st, dptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_all_mods (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, int32 *toks)\r\n{\r\nMTAB *mptr;\r\nt_stat r = SCPE_OK;\r\n\r\nif (dptr->modifiers == NULL)\r\n    return SCPE_OK;\r\nfor (mptr = dptr->modifiers; mptr->mask != 0; mptr++) {\r\n    if (mptr->pstring &&\r\n        ((mptr->mask & MTAB_XTD)?\r\n            (MODMASK(mptr,flag) && !MODMASK(mptr,MTAB_NMO)):\r\n            ((MTAB_VUN == (uint32)flag) && ((uptr->flags & mptr->mask) == mptr->match)))) {\r\n        if ((*toks > 2) && (r == SCPE_OK)) {/* something emitted already? */\r\n            fprintf (st, \"\\n\");\r\n            *toks = 0;                      /* force device/unit name indent on next output */\r\n            }\r\n        if (r == SCPE_OK)\r\n            fprint_sep (st, toks, flag);\r\n        r = show_one_mod (st, dptr, uptr, mptr, NULL, 0);\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_one_mod (FILE *st, DEVICE *dptr, UNIT *uptr, MTAB *mptr,\r\n    CONST char *cptr, int32 flag)\r\n{\r\nt_stat r = SCPE_OK;\r\n\r\nif (mptr->disp)\r\n    r = mptr->disp (st, uptr, mptr->match, (CONST void *)(cptr? cptr: mptr->desc));\r\nelse\r\n    fputs (mptr->pstring, st);\r\nif ((r == SCPE_OK) && (flag && !((mptr->mask & MTAB_XTD) && MODMASK(mptr,MTAB_NMO))))\r\n    fputc ('\\n', st);\r\nreturn r;\r\n}\r\n\r\n/* Show show commands */\r\n\r\nt_stat show_show_commands (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr)\r\n{\r\nint32 i;\r\nDEVICE *dptr;\r\n\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++)\r\n    show_dev_show_commands (st, dptr, NULL, flag, cptr);\r\nfor (i = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i)\r\n    show_dev_show_commands (st, dptr, NULL, flag, cptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat show_dev_show_commands (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nfprint_show_help (st, dptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show/change the current working directory commands */\r\n\r\nt_stat show_default (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nchar buffer[PATH_MAX];\r\nchar *wd = sim_getcwd(buffer, PATH_MAX);\r\n\r\nfprintf (st, \"%s\\n\", wd);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat set_default_cmd (int32 flg, CONST char *cptr)\r\n{\r\nchar gbuf[4*CBUFSIZE];\r\n\r\nif (sim_is_running)\r\n    return SCPE_INVREM;\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ngbuf[sizeof(gbuf)-1] = '\\0';\r\nstrlcpy (gbuf, cptr, sizeof(gbuf));\r\nsim_trim_endspc(gbuf);\r\nif (sim_chdir(gbuf) != 0)\r\n    return sim_messagef(SCPE_IOERR, \"Unable to change directory to: %s\\n\", gbuf);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat pwd_cmd (int32 flg, CONST char *cptr)\r\n{\r\nreturn show_cmd (0, \"DEFAULT\");\r\n}\r\n\r\ntypedef struct {\r\n    char LastDir[PATH_MAX + 1];\r\n    t_offset TotalBytes;\r\n    int TotalDirs;\r\n    int TotalFiles;\r\n    int DirChanges;\r\n    int DirCount;\r\n    int FileCount;\r\n    t_offset ByteCount;\r\n    } DIR_CTX;\r\n\r\nstatic void sim_dir_entry (const char *directory,\r\n                        const char *filename,\r\n                        t_offset FileSize,\r\n                        const struct stat *filestat,\r\n                        void *context)\r\n{\r\nDIR_CTX *ctx = (DIR_CTX *)context;\r\nstruct tm *local;\r\n\r\nif ((directory == NULL) || (filename == NULL)) {\r\n    if (ctx->DirChanges > 1)\r\n        sim_printf (\"     Total Files Listed:\\n\");\r\n    if (ctx->DirChanges > 0) {\r\n        sim_printf (\"%16d File(s) \", ctx->TotalFiles);\r\n        sim_print_val ((t_value) ctx->TotalBytes, 10, 17, PV_RCOMMA);\r\n        sim_printf (\" bytes\\n\");\r\n        sim_printf (\"%16d Dir(s)\\n\", ctx->TotalDirs);\r\n        }\r\n    return;\r\n    }\r\nif (strcmp (ctx->LastDir, directory)) {\r\n    if (ctx->DirCount || ctx->FileCount) {\r\n        sim_printf (\"%16d File(s) \", ctx->FileCount);\r\n        sim_print_val ((t_value) ctx->ByteCount, 10, 17, PV_RCOMMA);\r\n        sim_printf (\" bytes\\n\");\r\n        ctx->ByteCount = ctx->DirCount = ctx->FileCount = 0;\r\n        sim_printf (\"%16d Dir(s)\\n\", ctx->DirCount);\r\n        }\r\n    ++ctx->DirChanges;\r\n    sim_printf (\" Directory of %*.*s\\n\\n\", (int)(strlen (directory) - 1), (int)(strlen (directory) - 1), directory);\r\n    strcpy (ctx->LastDir, directory);\r\n    }\r\nlocal = localtime (&filestat->st_mtime);\r\nif (local)\r\n    sim_printf (\"%02d/%02d/%04d  %02d:%02d %s \", local->tm_mon+1, local->tm_mday, 1900+local->tm_year, local->tm_hour%12, local->tm_min, (local->tm_hour >= 12) ? \"PM\" : \"AM\");\r\nelse {\r\n    local = localtime (&filestat->st_ctime);\r\n    if (local)\r\n        sim_printf (\"%02d/%02d/%04d  %02d:%02d %s \", local->tm_mon+1, local->tm_mday, 1900+local->tm_year, local->tm_hour%12, local->tm_min, (local->tm_hour >= 12) ? \"PM\" : \"AM\");\r\n    }\r\nif (filestat->st_mode & S_IFDIR) {\r\n    ++ctx->DirCount;\r\n    ++ctx->TotalDirs;\r\n    sim_printf (\"   <DIR>         \");\r\n    }\r\nelse {\r\n    if (filestat->st_mode & S_IFREG) {\r\n        ++ctx->FileCount;\r\n        ++ctx->TotalFiles;\r\n        sim_print_val ((t_value) FileSize, 10, 17, PV_RCOMMA);\r\n        ctx->ByteCount += FileSize;\r\n        ctx->TotalBytes += FileSize;\r\n        }\r\n    else {\r\n        sim_printf (\"%17s\", \"\");\r\n        }\r\n    }\r\nsim_printf (\" %s\\n\", filename);\r\n}\r\n\r\nt_stat dir_cmd (int32 flg, CONST char *cptr)\r\n{\r\nDIR_CTX dir_state;\r\nt_stat r;\r\nchar WildName[PATH_MAX + 1];\r\nstruct stat filestat;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nmemset (&dir_state, 0, sizeof (dir_state));\r\nstrlcpy (WildName, cptr, sizeof(WildName));\r\ncptr = WildName;\r\nsim_trim_endspc (WildName);\r\nif (*cptr == '\\0')\r\n    strlcpy (WildName, \".\", sizeof (WildName));\r\nelse {\r\n    if ((WildName[strlen (WildName) - 1] == '/') ||\r\n        (WildName[strlen (WildName) - 1] == '\\\\'))\r\n        strlcat (WildName, \".\", sizeof (WildName));\r\n    }\r\nif ((!sim_stat (WildName, &filestat)) && (filestat.st_mode & S_IFDIR))\r\n    strlcat (WildName, \"/*\", sizeof (WildName));\r\nr = sim_dir_scan (cptr, sim_dir_entry, &dir_state);\r\nsim_dir_entry (NULL, NULL, 0, NULL, &dir_state);    /* output summary */\r\nif (r != SCPE_OK) {\r\n    char *cp = sim_filepath_parts (WildName, \"p\");\r\n\r\n    sim_printf (\"\\n Directory of %s\\n\\n\", cp);\r\n    sim_printf (\"File Not Found\\n\\n\");\r\n    free (cp);\r\n    return SCPE_OK;\r\n    }\r\nreturn r;\r\n}\r\n\r\nstatic long sim_type_file_offset;\r\nstatic long sim_type_line_count;\r\n\r\ntypedef struct {\r\n    t_stat stat;\r\n    } TYPE_CTX;\r\n\r\nstatic void sim_type_entry (const char *directory,\r\n                            const char *filename,\r\n                            t_offset FileSize,\r\n                            const struct stat *filestat,\r\n                            void *context)\r\n{\r\nchar FullPath[PATH_MAX + 1];\r\nFILE *file;\r\nlong lines = 0;\r\nchar lbuf[4*CBUFSIZE];\r\n\r\nsprintf (FullPath, \"%s%s\", directory, filename);\r\n\r\nfile = sim_fopen (FullPath, \"r\");\r\nif (file == NULL)                           /* open failed? */\r\n    return;\r\nsim_printf (\"\\n%s\\n\\n\", FullPath);\r\nlbuf[sizeof(lbuf)-1] = '\\0';\r\nif (sim_type_file_offset)\r\n    (void)fseek (file, sim_type_file_offset, SEEK_SET);\r\nwhile ((NULL != fgets (lbuf, sizeof(lbuf)-1, file)) &&\r\n       (lines++ < sim_type_line_count)) {\r\n    sim_printf (\"%s\", lbuf);\r\n    if (stop_cpu) {\r\n        stop_cpu = FALSE;\r\n        break;\r\n        }\r\n    }\r\nfclose (file);\r\n}\r\n\r\n\r\nt_stat type_cmd (int32 flg, CONST char *cptr)\r\n{\r\nFILE *file;\r\nlong lines = 0;\r\nchar lbuf[4*CBUFSIZE];\r\n\r\nsim_type_file_offset = 0;                           /* beginning of file */\r\nsim_type_line_count = 0X7FFFFFFF;                   /* output many lines */\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nif (sim_switches & SWMASK ('O')) {      /* Specify Offset in file */\r\n    char gbuf[CBUFSIZE];\r\n    char *eptr;\r\n\r\n    cptr = get_glyph (cptr, gbuf, 0);\r\n    if ((!cptr) || (*cptr == 0))\r\n        return SCPE_2FARG;\r\n    sim_type_file_offset = strtol (gbuf, &eptr, 0);\r\n    if ((*eptr) || (sim_type_file_offset < 0))\r\n        return sim_messagef (SCPE_ARG, \"Invalid file offset: %s\\n\", gbuf);\r\n    }\r\nif (sim_switches & SWMASK ('N')) {      /* Specify Line Count to display */\r\n    char gbuf[CBUFSIZE];\r\n    char *eptr;\r\n\r\n    cptr = get_glyph (cptr, gbuf, 0);\r\n    if ((!cptr) || (*cptr == 0))\r\n        return SCPE_2FARG;\r\n    sim_type_line_count = strtol (gbuf, &eptr, 0);\r\n    if ((*eptr) || (sim_type_line_count < 0))\r\n        return sim_messagef (SCPE_ARG, \"Invalid file line count: %s\\n\", gbuf);\r\n    }\r\nlbuf[sizeof(lbuf)-1] = '\\0';\r\nstrlcpy (lbuf, cptr, sizeof(lbuf));\r\nsim_trim_endspc(lbuf);\r\nfile = sim_fopen (lbuf, \"r\");\r\nif (file == NULL) {                         /* open failed? */\r\n    TYPE_CTX type_state;\r\n    t_stat stat;\r\n\r\n    memset (&type_state, 0, sizeof (type_state));\r\n    stat = sim_dir_scan (cptr, sim_type_entry, &type_state);\r\n    if (stat == SCPE_OK)\r\n        return SCPE_OK;\r\n    return sim_messagef (SCPE_OPENERR, \"The system cannot find the file specified.\\n\");\r\n    }\r\nlbuf[sizeof(lbuf)-1] = '\\0';\r\nif (sim_type_file_offset)\r\n    (void)fseek (file, sim_type_file_offset, SEEK_SET);\r\nwhile ((NULL != fgets (lbuf, sizeof(lbuf)-1, file)) &&\r\n       (lines++ < sim_type_line_count))\r\n    sim_printf (\"%s\", lbuf);\r\nfclose (file);\r\nreturn SCPE_OK;\r\n}\r\n\r\ntypedef struct {\r\n    t_stat stat;\r\n    } DEL_CTX;\r\n\r\nstatic void sim_delete_entry (const char *directory,\r\n                              const char *filename,\r\n                              t_offset FileSize,\r\n                              const struct stat *filestat,\r\n                              void *context)\r\n{\r\nDEL_CTX *ctx = (DEL_CTX *)context;\r\nchar FullPath[PATH_MAX + 1];\r\n\r\nsprintf (FullPath, \"%s%s\", directory, filename);\r\n\r\nif (!unlink (FullPath))\r\n    return;\r\nctx->stat = sim_messagef (SCPE_ARG, \"%s\\n\", strerror (errno));\r\n}\r\n\r\nt_stat delete_cmd (int32 flg, CONST char *cptr)\r\n{\r\nDEL_CTX del_state;\r\nt_stat stat;\r\n\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nmemset (&del_state, 0, sizeof (del_state));\r\nstat = sim_dir_scan (cptr, sim_delete_entry, &del_state);\r\nif (stat == SCPE_OK)\r\n    return del_state.stat;\r\nreturn sim_messagef (SCPE_OK, \"No such file or directory: %s\\n\", cptr);\r\n}\r\n\r\ntypedef struct {\r\n    t_stat stat;\r\n    int count;\r\n    char destname[CBUFSIZE];\r\n    } COPY_CTX;\r\n\r\nstatic void sim_copy_entry (const char *directory,\r\n                            const char *filename,\r\n                            t_offset FileSize,\r\n                            const struct stat *filestat,\r\n                            void *context)\r\n{\r\nCOPY_CTX *ctx = (COPY_CTX *)context;\r\nstruct stat deststat;\r\nchar FullPath[PATH_MAX + 1];\r\nchar dname[CBUFSIZE];\\\r\nt_stat st;\r\n\r\nstrlcpy (dname, ctx->destname, sizeof (dname));\r\n\r\nsprintf (FullPath, \"%s%s\", directory, filename);\r\n\r\nif ((dname[strlen (dname) - 1] == '/') || (dname[strlen (dname) - 1] == '\\\\'))\r\n    dname[strlen (dname) - 1] = '\\0';\r\nif ((!sim_stat (dname, &deststat)) && (deststat.st_mode & S_IFDIR)) {\r\n    const char *dslash = (strrchr (dname, '/') ? \"/\" : (strrchr (dname, '\\\\') ? \"\\\\\" : \"/\"));\r\n\r\n    dname[sizeof (dname) - 1] = '\\0';\r\n    snprintf (&dname[strlen (dname)], sizeof (dname) - strlen (dname), \"%s%s\", dslash, filename);\r\n    }\r\nst = sim_copyfile (FullPath, dname, TRUE);\r\nif (SCPE_OK == st)\r\n    ++ctx->count;\r\nelse\r\n    ctx->stat = st;\r\n}\r\n\r\nt_stat copy_cmd (int32 flg, CONST char *cptr)\r\n{\r\nchar sname[CBUFSIZE];\r\nCOPY_CTX copy_state;\r\nt_stat stat;\r\n\r\nmemset (&copy_state, 0, sizeof (copy_state));\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ncptr = get_glyph_quoted (cptr, sname, 0);\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\ncptr = get_glyph_quoted (cptr, copy_state.destname, 0);\r\nstat = sim_dir_scan (sname, sim_copy_entry, &copy_state);\r\nif ((stat == SCPE_OK) && (copy_state.count))\r\n    return sim_messagef (SCPE_OK, \"      %3d file(s) copied\\n\", copy_state.count);\r\nreturn copy_state.stat;\r\n}\r\n\r\nt_stat rename_cmd (int32 flg, CONST char *cptr)\r\n{\r\nchar sname[CBUFSIZE], dname[CBUFSIZE];\r\n\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ncptr = get_glyph_quoted (cptr, sname, 0);\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\ncptr = get_glyph_quoted (cptr, dname, 0);\r\nif (0 == rename (sname, dname))\r\n    return SCPE_OK;\r\nreturn sim_messagef (SCPE_ARG, \"Can't rename '%s' to '%s': %s\\n\\n\", sname, dname, strerror (errno));\r\n}\r\n\r\nt_stat mkdir_cmd (int32 flg, CONST char *cptr)\r\n{\r\nchar path[CBUFSIZE];\r\nchar *c;\r\nstruct stat filestat;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif ((!cptr) || (*cptr == '\\0'))\r\n    return sim_messagef (SCPE_2FARG, \"Must specify a directory path\\n\");\r\nstrlcpy (path, cptr, sizeof (path));\r\nwhile ((c = strchr (path, '\\\\')))\r\n    *c = '/';\r\nif (path[strlen (path) - 1] == '/')     /* trim any trailing / from the path */\r\n    path[strlen (path) - 1] = '\\0';\r\nwhile ((c = strstr (path, \"//\")))\r\n    memmove (c, c + 1, strlen (c + 1) + 1); /* clean out any empty directories // */\r\nif ((!sim_stat (path, &filestat)) && (filestat.st_mode & S_IFDIR))\r\n    return sim_messagef (SCPE_OK, \"directory %s already exists\\n\", path);\r\nc = path;\r\nwhile ((c = strchr (c, '/'))) {\r\n    *c = '\\0';\r\n    if (!sim_stat (path, &filestat)) {\r\n        if (filestat.st_mode & S_IFDIR) {\r\n            *c = '/';   /* restore / */\r\n            ++c;\r\n            continue;\r\n            }\r\n        return sim_messagef (SCPE_ARG, \"%s is not a directory\\n\", path);\r\n        }\r\n    if (sim_mkdir (path))\r\n        return sim_messagef (SCPE_ARG, \"Can't create directory: %s - %s\\n\", path, strerror (errno));\r\n    *c = '/';   /* restore / */\r\n    ++c;\r\n    }\r\nif (sim_mkdir (path))\r\n    return sim_messagef (SCPE_ARG, \"Can't create directory: %s - %s\\n\", path, strerror (errno));\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat rmdir_cmd (int32 flg, CONST char *cptr)\r\n{\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif ((!cptr) || (*cptr == '\\0'))\r\n    return sim_messagef (SCPE_2FARG, \"Must specify a directory\\n\");\r\nif (sim_rmdir (cptr))\r\n    return sim_messagef (SCPE_ARG, \"Can't remove directory: %s - %s\\n\", cptr, strerror (errno));\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Debug command */\r\n\r\nt_stat debug_cmd (int32 flg, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *svptr;\r\nDEVICE *dptr;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\ncptr = get_glyph (svptr = cptr, gbuf, 0);               /* get next glyph */\r\nif ((dptr = find_dev (gbuf)))                           /* device match? */\r\nreturn set_dev_debug (dptr, NULL, flg, *cptr ? cptr : NULL);\r\ncptr = svptr;\r\nif (flg)\r\n    return sim_set_debon (0, cptr);\r\nelse\r\n    return sim_set_deboff (0, cptr);\r\n}\r\n\r\n/* Breakpoint commands */\r\n\r\nt_stat brk_cmd (int32 flg, CONST char *cptr)\r\n{\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nreturn ssh_break (NULL, cptr, flg);                     /* call common code */\r\n}\r\n\r\nt_stat ssh_break (FILE *st, const char *cptr, int32 flg)\r\n{\r\nchar gbuf[CBUFSIZE], *aptr, abuf[4*CBUFSIZE];\r\nCONST char *tptr, *t1ptr;\r\nDEVICE *dptr = sim_dflt_dev;\r\nUNIT *uptr;\r\nt_stat r;\r\nt_addr lo, hi, max;\r\nint32 cnt;\r\n\r\nif (sim_brk_types == 0)\r\n    return sim_messagef (SCPE_NOFNC, \"No breakpoint support in this simulator\\n\");\r\nif (dptr == NULL)\r\n    return SCPE_IERR;\r\nuptr = dptr->units;\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nmax = uptr->capac - 1;\r\nabuf[sizeof(abuf)-1] = '\\0';\r\nstrlcpy (abuf, cptr, sizeof(abuf));\r\nif ((aptr = strchr (abuf, ';'))) {                      /* ;action? */\r\n    cptr += aptr - abuf + 1;\r\n    if (flg != SSH_ST)                                  /* only on SET */\r\n        return sim_messagef (SCPE_ARG, \"Invalid argument: %s\\n\", cptr);\r\n    *aptr++ = 0;                                        /* separate strings */\r\n    if ((cptr > sim_sub_instr_buf) && ((size_t)(cptr - sim_sub_instr_buf) < sim_sub_instr_size))\r\n        aptr = &sim_sub_instr[sim_sub_instr_off[cptr - sim_sub_instr_buf]]; /* get un-substituted string */\r\n    }\r\ncptr = abuf;\r\nif (*cptr == 0) {                                       /* no argument? */\r\n    lo = (t_addr) get_rval (sim_PC, 0);                 /* use PC */\r\n    return ssh_break_one (st, flg, lo, 0, aptr);\r\n    }\r\nwhile (*cptr) {\r\n    const char *ocptr = cptr;\r\n\r\n    cptr = get_glyph (cptr, gbuf, ',');\r\n    tptr = get_range (dptr, gbuf, &lo, &hi, dptr->aradix, max, 0);\r\n    if (tptr == NULL)\r\n        return sim_messagef (SCPE_ARG, \"Invalid breakpoint address specifier: %s\\n\", ocptr);\r\n    if (*tptr == '[') {\r\n        cnt = (int32) strtotv (tptr + 1, &t1ptr, 0);\r\n        if ((tptr == t1ptr) || (*t1ptr != ']') || (flg != SSH_ST))\r\n            return sim_messagef (SCPE_ARG, \"Invalid breakpoint repeat count specifier: %s\\n\", tptr + 1);\r\n        tptr = t1ptr + 1;\r\n        }\r\n    else cnt = 0;\r\n    if (*tptr != 0)\r\n        return sim_messagef (SCPE_ARG, \"Unexpected breakpoint argument: %s\\n\", tptr);\r\n    if ((lo == 0) && (hi == max)) {\r\n        if (flg == SSH_CL)\r\n            sim_brk_clrall (sim_switches);\r\n        else\r\n            if (flg == SSH_SH)\r\n                sim_brk_showall (st, sim_switches);\r\n            else\r\n                return SCPE_ARG;\r\n        }\r\n    else {\r\n        for ( ; lo <= hi; lo = lo + 1) {\r\n            r = ssh_break_one (st, flg, lo, cnt, aptr);\r\n            if (r != SCPE_OK)\r\n                return r;\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat ssh_break_one (FILE *st, int32 flg, t_addr lo, int32 cnt, CONST char *aptr)\r\n{\r\nif (!sim_brk_types)\r\n    return sim_messagef (SCPE_NOFNC, \"No breakpoint support in this simulator\\n\");\r\nswitch (flg) {\r\n\r\n    case SSH_ST:\r\n        return sim_brk_set (lo, sim_switches, cnt, aptr);\r\n        break;\r\n\r\n    case SSH_CL:\r\n        return sim_brk_clr (lo, sim_switches);\r\n        break;\r\n\r\n    case SSH_SH:\r\n        return sim_brk_show (st, lo, sim_switches);\r\n        break;\r\n\r\n    default:\r\n        return SCPE_ARG;\r\n    }\r\n}\r\n\r\n/* Reset command and routines\r\n\r\n   re[set]              reset all devices\r\n   re[set] all          reset all devices\r\n   re[set] device       reset specific device\r\n*/\r\n\r\nstatic t_bool run_cmd_did_reset = FALSE;\r\n\r\nt_stat reset_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nDEVICE *dptr;\r\n\r\nrun_cmd_did_reset = FALSE;\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* reset(cr) */\r\n    return (reset_all (0));\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get next glyph */\r\nif (*cptr != 0)                                         /* now eol? */\r\n    return SCPE_2MARG;\r\nif (strcmp (gbuf, \"ALL\") == 0)\r\n    return (reset_all (0));\r\ndptr = find_dev (gbuf);                                 /* locate device */\r\nif (dptr == NULL)                                       /* found it? */\r\n    return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);\r\nif (dptr->reset != NULL)\r\n    return dptr->reset (dptr);\r\nelse return SCPE_OK;\r\n}\r\n\r\nt_stat runlimit_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nint32 num;\r\nt_stat r;\r\ndouble usec_factor = 1.0;\r\nconst char *units = \"\";\r\nchar runlimit[32];\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (0 == flag) {\r\n    if (*cptr)\r\n        return sim_messagef (SCPE_ARG, \"NORUNLIMIT expects no arguments: %s\\n\", cptr);\r\n    sim_runlimit = 0;\r\n    sim_runlimit_switches = 0;\r\n    sim_runlimit_enabled = FALSE;\r\n    sim_cancel (&sim_runlimit_unit);\r\n    unsetenv (\"SIM_RUNLIMIT\");\r\n    unsetenv (\"SIM_RUNLIMIT_UNITS\");\r\n    return SCPE_OK;\r\n    }\r\n\r\ncptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\nnum = (int32) get_uint (gbuf, 0, INT_MAX, &r);\r\nif ((r != SCPE_OK) || (num == 0))               /* error? */\r\n    return sim_messagef (SCPE_ARG, \"Invalid argument: %s\\n\", gbuf);\r\ncptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\nif ((gbuf[0] == '\\0') ||\r\n    (MATCH_CMD (gbuf, sim_vm_interval_units) == 0)) {\r\n    sim_switches &= ~SWMASK ('T');\r\n    units = sim_vm_interval_units;\r\n    }\r\nelse {\r\n    int i;\r\n    struct {\r\n        const char *name;\r\n        double usec_factor;\r\n        } time_units[] = {\r\n            {\"MICROSECONDS\",             1.0},\r\n            {\"USECONDS\",                 1.0},\r\n            {\"SECONDS\",            1000000.0},\r\n            {\"MINUTES\",         60*1000000.0},\r\n            {\"HOURS\",        60*60*1000000.0},\r\n            {NULL,                       0.0}};\r\n\r\n    for (i=0; time_units[i].name; i++) {\r\n        if (MATCH_CMD (gbuf, time_units[i].name) == 0) {\r\n            sim_switches |= SWMASK ('T');\r\n            usec_factor = time_units[i].usec_factor;\r\n            units = time_units[i].name;\r\n            break;\r\n            }\r\n        }\r\n    if (time_units[i].name == NULL)\r\n        return sim_messagef (SCPE_2MARG, \"Too many arguments: %s %s\\n\", gbuf, cptr);\r\n    }\r\nif (*cptr)\r\n    return sim_messagef (SCPE_2MARG, \"Too many arguments: %s\\n\", cptr);\r\nsim_runlimit_enabled = TRUE;\r\nsim_cancel (&sim_runlimit_unit);\r\nsim_runlimit_switches = sim_switches;\r\nif (sim_runlimit_switches & SWMASK ('T')) {\r\n    sim_runlimit_d_initial = sim_runlimit_d = num * usec_factor * sim_host_speed_factor ();\r\n    if (sim_host_speed_factor () > 1.0)\r\n        sim_messagef (SCPE_OK, \"Slow host - adjusting RUNLIMIT from %d %s to %.1f %s\\n\", num, units, num * sim_host_speed_factor (), units);\r\n    snprintf (runlimit, sizeof (runlimit), \"%s\", sim_fmt_secs (num * sim_host_speed_factor ()));\r\n    setenv (\"SIM_RUNLIMIT\", runlimit, 1);\r\n    setenv (\"SIM_RUNLIMIT_UNITS\", units, 1);\r\n    return sim_activate_after_d (&sim_runlimit_unit, sim_runlimit_d);\r\n    }\r\nelse {\r\n    sim_runlimit_initial = sim_runlimit = num;\r\n    snprintf (runlimit, sizeof (runlimit), \"%s\", sim_fmt_numeric ((double)num));\r\n    setenv (\"SIM_RUNLIMIT\", runlimit, 1);\r\n    setenv (\"SIM_RUNLIMIT_UNITS\", units, 1);\r\n    return sim_activate (&sim_runlimit_unit, sim_runlimit);\r\n    }\r\n}\r\n\r\nt_stat set_runlimit (int32 flag, CONST char *cptr)\r\n{\r\nreturn runlimit_cmd (flag, cptr);\r\n}\r\n\r\nstatic const char *_get_runlimit (void)\r\n{\r\nstatic char msg[CBUFSIZE];\r\nchar msgend[CBUFSIZE] = \"\";\r\n\r\nif (sim_runlimit_enabled) {\r\n    if (sim_runlimit_switches & SWMASK ('T')) {\r\n        if (sim_runlimit_d_initial != sim_runlimit_d) {\r\n            snprintf (msg, sizeof (msg), \"%s initially, \", sim_fmt_secs (sim_runlimit_d_initial / 1000000.0));\r\n            if (sim_is_active (&sim_runlimit_unit))\r\n                snprintf (msgend, sizeof (msgend), \"and %s remaining\", sim_fmt_secs (sim_runlimit_d / 1000000.0));\r\n            else\r\n                snprintf (msgend, sizeof (msgend), \"expired now\");\r\n            }\r\n        else\r\n            snprintf (msg, sizeof (msg), \"%s\", sim_fmt_secs (sim_runlimit_d_initial / 1000000.0));\r\n        }\r\n    else {\r\n        if (sim_runlimit_initial != sim_runlimit) {\r\n            snprintf (msg, sizeof (msg), \"%s %s initially, \", sim_fmt_numeric ((double)sim_runlimit_initial), sim_vm_interval_units);\r\n            if (sim_is_active (&sim_runlimit_unit))\r\n                snprintf (msgend, sizeof (msgend), \"and %s %s remaining\", sim_fmt_numeric ((double)sim_activate_time (&sim_runlimit_unit)), sim_vm_interval_units);\r\n            else\r\n                snprintf (msgend, sizeof (msgend), \"expired now\");\r\n            }\r\n        else\r\n            snprintf (msg, sizeof (msg), \"%s %s\\n\", sim_fmt_numeric ((double)sim_runlimit_initial), sim_vm_interval_units);\r\n        }\r\n    }\r\nelse\r\n    snprintf (msg, sizeof (msg), \"Run Limit Disabled\");\r\nstrlcat (msg, msgend, sizeof (msg));\r\nreturn msg;\r\n}\r\n\r\nt_stat show_runlimit (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nfprintf (st, \"%s\\n\", _get_runlimit ());\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Reset devices start..end\r\n\r\n   Inputs:\r\n        start   =       number of starting device\r\n   Outputs:\r\n        status  =       error status\r\n*/\r\n\r\nt_stat reset_all (uint32 start)\r\n{\r\nDEVICE *dptr;\r\nuint32 i;\r\nt_stat reason;\r\nint32 saved_sim_switches = sim_switches;\r\n\r\nfor (i = 0; i < start; i++) {\r\n    if (sim_devices[i] == NULL)\r\n        return SCPE_IERR;\r\n    }\r\nfor (i = start; (dptr = sim_devices[i]) != NULL; i++) {\r\n    sim_switches = saved_sim_switches;  /* restore initial switches */\r\n    if (sim_switches & SWMASK ('P')) {\r\n        tmxr_add_debug (dptr);          /* Add TMXR debug to MUX devices */\r\n        sim_tape_add_debug (dptr);      /* Add TAPE debug to TAPE devices */\r\n        fix_writelock_mtab (dptr);\r\n        }\r\n    if (dptr->reset != NULL) {\r\n        reason = dptr->reset (dptr);\r\n        if (reason != SCPE_OK) {\r\n            sim_failed_reset_dptr = dptr;\r\n            return reason;\r\n            }\r\n        }\r\n    }\r\nfor (i = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i) {\r\n    sim_switches = saved_sim_switches;  /* restore initial switches */\r\n    if (dptr->reset != NULL) {\r\n        reason = dptr->reset (dptr);\r\n        if (reason != SCPE_OK)\r\n            return reason;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_add_debug_flags (DEVICE *dptr, DEBTAB *debflags)\r\n{\r\ndptr->flags |= DEV_DEBUG;\r\nif (!dptr->debflags)                /* Current flags available */\r\n    dptr->debflags = debflags;      /* No, so just use new flags table */\r\nelse {\r\n    DEBTAB *cdptr, *sdptr, *ndptr;\r\n\r\n    for (sdptr = debflags; sdptr->name; sdptr++) {\r\n        /* Find a new mask value that isn't in the existing table yet */\r\n        for (cdptr = dptr->debflags; cdptr->name; cdptr++) {\r\n            if (sdptr->mask == cdptr->mask)\r\n                break;\r\n            }\r\n        if (sdptr->mask != cdptr->mask) {\r\n            int i, dcount = 0;\r\n\r\n            for (cdptr = dptr->debflags; cdptr->name; cdptr++)\r\n                dcount++;                       /* Count current table size */\r\n            for (cdptr = debflags; cdptr->name; cdptr++)\r\n                dcount++;                       /* Count new table size */\r\n            /* Allocate enough to hold both plus the list end */\r\n            ndptr = (DEBTAB *)calloc (1 + dcount, sizeof (*ndptr));\r\n            /* Copy current table to new array */\r\n            for (dcount = 0, cdptr = dptr->debflags; cdptr->name; cdptr++)\r\n                ndptr[dcount++] = *cdptr;\r\n            /* for each element of the new list */\r\n            for (cdptr = debflags; cdptr->name; cdptr++) {\r\n                /* check if new mask value */\r\n                for (i = 0; i < dcount; i++) {\r\n                    if (cdptr->mask == ndptr[i].mask)\r\n                        break;\r\n                    }\r\n                if (i == dcount)\r\n                    ndptr[dcount++] = *cdptr;   /* add new value to list */\r\n                }\r\n            dptr->debflags = ndptr;\r\n            break;\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Reset to powerup state\r\n\r\n   Inputs:\r\n        start   =       number of starting device\r\n   Outputs:\r\n        status  =       error status\r\n*/\r\n\r\nt_stat reset_all_p (uint32 start)\r\n{\r\nt_stat r;\r\nint32 old_sw = sim_switches;\r\n\r\nsim_switches = SWMASK ('P');\r\nr = reset_all (start);\r\nsim_switches = old_sw;\r\nreturn r;\r\n}\r\n\r\n/* Set Hardware Write Lock */\r\n\r\nt_stat set_writelock (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nif (((uptr->flags & UNIT_WPRT) != 0) == val)        /* Already set as desired? */\r\n    return SCPE_OK;                                 /* Do nothing */\r\nif (val) {                                          /* Lock? */\r\n    uptr->flags |= UNIT_WLK;                        /* Do it. */\r\n    if ((uptr->flags & UNIT_ATT) == 0)\r\n        uptr->flags |= UNIT_RO;                     /* Next attach will be Read-Only. */\r\n    }\r\nelse                                                /* Unlock */\r\n    if (((uptr->flags & UNIT_ATT) != 0) &&          /* Transition from Locked to Unlock while attached read-only? */\r\n        ((uptr->flags & UNIT_RO) != 0))\r\n        return sim_messagef (SCPE_ALATT, \"%s: Can't enable write when attached read only\\n\", sim_uname (uptr));\r\n    else\r\n        uptr->flags &= ~UNIT_WPRT;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show Write Lock */\r\n\r\nt_stat show_writelock (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nfprintf (st, \"write %s\", (uptr->flags & UNIT_WPRT) ? \"locked\" : \"enabled\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic void fix_writelock_mtab (DEVICE *dptr)\r\n{\r\nMTAB *mtab;\r\n\r\nfor (mtab = dptr->modifiers; (mtab != NULL) && ((mtab->mstring != NULL) || (mtab->pstring != NULL)); ++mtab) {\r\n    if (mtab->disp == &show_writelock)\r\n        mtab->pstring = \"WRITEENABLED\";\r\n    }\r\n}\r\n\r\n/* Load and dump commands\r\n\r\n   lo[ad] filename {arg}        load specified file\r\n   du[mp] filename {arg}        dump to specified file\r\n*/\r\n\r\n/* Memory File use (for internal memory static ROM images)\r\n\r\n    when used to read ROM image with internally generated\r\n    load commands, calling code setups with sim_set_memory_file()\r\n    sim_load uses Fgetc() instead of fgetc() or getc()\r\n*/\r\n\r\nstatic const unsigned char *mem_data = NULL;\r\nstatic size_t mem_data_size = 0;\r\nstatic const char *mem_filepath;\r\nstatic unsigned int mem_checksum;\r\n\r\nt_stat sim_set_memory_load_file_ex (const unsigned char *builtin_code, size_t size, const char *filepath, unsigned int checksum)\r\n{\r\nmem_data = builtin_code;\r\nmem_data_size = size;\r\nmem_filepath = filepath;\r\nmem_checksum = checksum;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_set_memory_load_file (const unsigned char *data, size_t size)\r\n{\r\nreturn sim_set_memory_load_file_ex (data, size, NULL, 0);\r\n}\r\n\r\nint Fgetc (FILE *f)\r\n{\r\nif (mem_data) {\r\n    if (mem_data_size == 0)\r\n        return EOF;\r\n    --mem_data_size;\r\n    return (int)(*mem_data++);\r\n    }\r\nelse\r\n    return fgetc (f);\r\n}\r\n\r\n\r\nt_stat load_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nFILE *loadfile = NULL;\r\nt_stat reason = SCPE_OK;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph_nc (cptr, gbuf, 0);                    /* get file name */\r\nif (mem_data == NULL) {\r\n    if (mem_filepath != NULL)\r\n        reason = sim_fetch_binary_file (gbuf, mem_filepath, mem_data_size, mem_checksum);\r\n    if (reason != SCPE_OK)\r\n        return reason;\r\n    loadfile = sim_fopen (gbuf, flag? \"wb\": \"rb\");      /* open for wr/rd */\r\n    if (loadfile == NULL)\r\n        return sim_messagef (SCPE_OPENERR, \"Error opening '%s' - %s\\n\", gbuf, strerror (errno));\r\n    }\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nreason = sim_load (loadfile, (CONST char *)cptr, gbuf, flag);/* load or dump */\r\nif (loadfile)\r\n    fclose (loadfile);\r\nreturn reason;\r\n}\r\n\r\n#define SIM_REPO_PATH \"https://github.com/simh/simh/raw/master/\"\r\n\r\nt_stat sim_fetch_binary_file (const char *filename, const char *filepath, size_t size, unsigned int checksum)\r\n{\r\nstruct stat filestat;\r\nt_stat r = SCPE_OK;\r\nFILE *f;\r\nt_bool fetched = FALSE;\r\nint byte;\r\nunsigned int thissum = 0;\r\nsize_t bytes = 0;\r\n\r\nif (sim_stat (filename, &filestat)) {\r\n    char cmd[CBUFSIZE];\r\n\r\n    if ((errno == EACCES) || (errno == EPERM))\r\n        return SCPE_OPENERR;\r\n    sim_messagef (SCPE_OK, \"Fetching %s from %s%s\\n\", filename, SIM_REPO_PATH, filepath);\r\n    snprintf (cmd, sizeof (cmd), \"-LJOs %s%s\", SIM_REPO_PATH, filepath);\r\n    r = curl_cmd (0, cmd);\r\n    if (r != SCPE_OK)\r\n        return sim_messagef (SCPE_OPENERR, \"Can't acquire '%s' remotely\\n\", filename);\r\n    fetched = TRUE;\r\n    }\r\nf = sim_fopen (filename, \"rb\");\r\nif (f == NULL)\r\n    return sim_messagef (SCPE_OPENERR, \"Can't open '%s' - %s\\n\", filename, strerror (errno));\r\nwhile (EOF != (byte = fgetc (f))) {\r\n    ++bytes;\r\n    thissum += (unsigned char)byte;\r\n    }\r\nfclose (f);\r\nthissum = ~thissum;\r\nif (((bytes != size) || (thissum != checksum)) && fetched)\r\n    unlink (filename);\r\nif (bytes != size)\r\n    return sim_messagef (SCPE_OPENERR, \"'%s' Expected file size found %d instead of %d\\n\", filename, (int)bytes, (int)size);\r\nif (thissum != checksum)\r\n    return sim_messagef (SCPE_OPENERR, \"'%s' Expected file size found 0x%X instead of 0x%X\\n\", filename, thissum, checksum);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Attach command\r\n\r\n   at[tach] unit file   attach specified unit to file\r\n*/\r\n\r\nt_stat attach_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[4*CBUFSIZE];\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nt_stat r;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get next glyph */\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* now eol? */\r\n    return SCPE_2FARG;\r\ndptr = find_unit (gbuf, &uptr);                         /* locate unit */\r\nif (dptr == NULL)                                       /* found dev? */\r\n    return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);\r\nif (uptr == NULL)                                       /* valid unit? */\r\n    return SCPE_NXUN;\r\nif (uptr->flags & UNIT_ATT) {                           /* already attached? */\r\n    if (!(uptr->dynflags & UNIT_ATTMULT) &&             /* and only single attachable */\r\n        !(dptr->flags & DEV_DONTAUTO)) {                /* and auto detachable */\r\n        r = scp_detach_unit (dptr, uptr);               /* detach it */\r\n        if (r != SCPE_OK)                               /* error? */\r\n            return r;\r\n        }\r\n    else {\r\n        if (!(uptr->dynflags & UNIT_ATTMULT))\r\n            return sim_messagef (SCPE_ALATT, \"%s: Already attached\\n\", sim_uname (uptr));\r\n        }\r\n    }\r\ngbuf[sizeof(gbuf)-1] = '\\0';\r\nstrlcpy (gbuf, cptr, sizeof(gbuf));\r\nsim_trim_endspc (gbuf);                                 /* trim trailing spc */\r\nreturn scp_attach_unit (dptr, uptr, gbuf);              /* attach */\r\n}\r\n\r\n/* Call device-specific or file-oriented attach unit routine */\r\n\r\nt_stat scp_attach_unit (DEVICE *dptr, UNIT *uptr, const char *cptr)\r\n{\r\nif (uptr->flags & UNIT_DIS)                             /* disabled? */\r\n    return sim_messagef (SCPE_UDIS, \"Unit disabled: %s\\n\", sim_uname (uptr));\r\nif (dptr->attach != NULL)                               /* device routine? */\r\n    return dptr->attach (uptr, (CONST char *)cptr);     /* call it */\r\nreturn attach_unit (uptr, (CONST char *)cptr);          /* no, std routine */\r\n}\r\n\r\n/* Attach unit to file */\r\n\r\nt_stat attach_unit (UNIT *uptr, CONST char *cptr)\r\n{\r\nDEVICE *dptr;\r\nt_bool open_rw = FALSE;\r\n\r\nif (!(uptr->flags & UNIT_ATTABLE))                      /* not attachable? */\r\n    return SCPE_NOATT;\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nuptr->filename = (char *) calloc (CBUFSIZE, sizeof (char)); /* alloc name buf */\r\nif (uptr->filename == NULL)\r\n    return SCPE_MEM;\r\nstrlcpy (uptr->filename, cptr, CBUFSIZE);               /* save name */\r\nif ((sim_switches & SWMASK ('R')) ||                    /* read only? */\r\n    ((uptr->flags & UNIT_RO) != 0)) {\r\n    if (((uptr->flags & UNIT_ROABLE) == 0) &&           /* allowed? */\r\n        ((uptr->flags & UNIT_RO) == 0))\r\n        return sim_messagef (attach_err (uptr, SCPE_NORO), \"%s: Read Only operation not allowed\\n\", /* no, error */\r\n                                                        sim_uname (uptr));\r\n    uptr->fileref = sim_fopen (cptr, \"rb\");             /* open rd only */\r\n    if (uptr->fileref == NULL)                          /* open fail? */\r\n        return sim_messagef (attach_err (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                            sim_uname (uptr), cptr, strerror (errno));\r\n    if (!(uptr->flags & UNIT_RO))\r\n        sim_messagef (SCPE_OK, \"%s: unit is read only\\n\", sim_uname (uptr));\r\n    uptr->flags = uptr->flags | UNIT_RO;                /* set rd only */\r\n    }\r\nelse {\r\n    if (sim_switches & SWMASK ('N')) {                  /* new file only? */\r\n        uptr->fileref = sim_fopen (cptr, \"wb+\");        /* open new file */\r\n        if (uptr->fileref == NULL)                      /* open fail? */\r\n            return sim_messagef (attach_err (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                                sim_uname (uptr), cptr, strerror (errno));\r\n        sim_messagef (SCPE_OK, \"%s: creating new file: %s\\n\", sim_uname (uptr), cptr);\r\n        }\r\n    else {                                              /* normal */\r\n        uptr->fileref = sim_fopen (cptr, \"rb+\");        /* open r/w */\r\n        if (uptr->fileref == NULL) {                    /* open fail? */\r\n#if defined(EPERM)\r\n            if ((errno == EROFS) || (errno == EACCES) || (errno == EPERM)) {/* read only? */\r\n#else\r\n            if ((errno == EROFS) || (errno == EACCES)) {/* read only? */\r\n#endif\r\n                if ((uptr->flags & UNIT_ROABLE) == 0)   /* allowed? */\r\n                    return sim_messagef (attach_err (uptr, SCPE_NORO), \"%s: Read Only operation not allowed\\n\", /* no, error */\r\n                                                                    sim_uname (uptr));\r\n                uptr->fileref = sim_fopen (cptr, \"rb\"); /* open rd only */\r\n                if (uptr->fileref == NULL)              /* open fail? */\r\n                    return sim_messagef (attach_err (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                                        sim_uname (uptr), cptr, strerror (errno));\r\n                uptr->flags = uptr->flags | UNIT_RO;    /* set rd only */\r\n                sim_messagef (SCPE_OK, \"%s: unit is read only\\n\", sim_uname (uptr));\r\n                }\r\n            else {                                      /* doesn't exist */\r\n                if (sim_switches & SWMASK ('E'))        /* must exist? */\r\n                    return sim_messagef (attach_err (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                                        sim_uname (uptr), cptr, strerror (errno));\r\n                uptr->fileref = sim_fopen (cptr, \"wb+\");/* open new file */\r\n                if (uptr->fileref == NULL)              /* open fail? */\r\n                    return sim_messagef (attach_err (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                                        sim_uname (uptr), cptr, strerror (errno));\r\n                sim_messagef (SCPE_OK, \"%s: creating new file\\n\", sim_uname (uptr));\r\n                }\r\n            }                                           /* end if null */\r\n        else\r\n            open_rw = TRUE;\r\n        }                                               /* end else */\r\n    }\r\nif (uptr->flags & UNIT_BUFABLE) {                       /* buffer? */\r\n    uint32 cap = ((uint32) uptr->capac) / dptr->aincr;  /* effective size */\r\n\r\n    uptr->filebuf2 = calloc (cap, SZ_D (dptr));         /* allocate copy */\r\n    if (uptr->filebuf2 == NULL)\r\n        return attach_err (uptr, SCPE_MEM);             /* error */\r\n    if (uptr->flags & UNIT_MUSTBUF) {                   /* dyn alloc? */\r\n        uptr->filebuf = calloc (cap, SZ_D (dptr));      /* allocate */\r\n        if (uptr->filebuf == NULL) {\r\n            free (uptr->filebuf);\r\n            uptr->filebuf = NULL;\r\n            free (uptr->filebuf2);\r\n            uptr->filebuf2 = NULL;\r\n            return attach_err (uptr, SCPE_MEM);         /* error */\r\n            }\r\n        }\r\n    sim_messagef (SCPE_OK, \"%s: buffering file in memory\\n\", sim_uname (uptr));\r\n    uptr->hwmark = (uint32)sim_fread (uptr->filebuf,    /* read file */\r\n        SZ_D (dptr), cap, uptr->fileref);\r\n    memcpy (uptr->filebuf2, uptr->filebuf, cap * SZ_D (dptr));/* save initial contents */\r\n    uptr->flags = uptr->flags | UNIT_BUF;               /* set buffered */\r\n    }\r\nuptr->flags = uptr->flags | UNIT_ATT;\r\nuptr->pos = 0;\r\nif (open_rw &&                                      /* open for write in append mode? */\r\n    (sim_switches & SWMASK ('A')) &&\r\n    (uptr->flags & UNIT_SEQ) &&\r\n    (!(uptr->flags & UNIT_MUSTBUF)) &&\r\n    (0 == sim_fseek (uptr->fileref, 0, SEEK_END)))\r\n    uptr->pos = (t_addr)sim_ftell (uptr->fileref);  /* Position at end of file */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat attach_err (UNIT *uptr, t_stat stat)\r\n{\r\nfree (uptr->filename);\r\nuptr->filename = NULL;\r\nreturn stat;\r\n}\r\n\r\n/* Detach command\r\n\r\n   det[ach] all         detach all units\r\n   det[ach] unit        detach specified unit\r\n*/\r\n\r\nt_stat detach_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get next glyph */\r\nif (*cptr != 0)                                         /* now eol? */\r\n    return SCPE_2MARG;\r\nif (strcmp (gbuf, \"ALL\") == 0)\r\n    return (detach_all (0, FALSE));\r\ndptr = find_unit (gbuf, &uptr);                         /* locate unit */\r\nif (dptr == NULL)                                       /* found dev? */\r\n    return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);\r\nif (uptr == NULL)                                       /* valid unit? */\r\n    return SCPE_NXUN;\r\nreturn scp_detach_unit (dptr, uptr);                    /* detach */\r\n}\r\n\r\n/* Detach devices start..end\r\n\r\n   Inputs:\r\n        start   =       number of starting device\r\n        shutdown =      TRUE if simulator shutting down\r\n   Outputs:\r\n        status  =       error status\r\n\r\n   Note that during shutdown, detach routines for non-attachable devices\r\n   will be called.  These routines can implement simulator shutdown.  Error\r\n   returns during shutdown are ignored.\r\n*/\r\n\r\nt_stat detach_all (int32 start, t_bool shutdown)\r\n{\r\nuint32 i, j;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nt_stat r;\r\n\r\nif ((start < 0) || (start > 1))\r\n    return SCPE_IERR;\r\nif (shutdown)\r\n    sim_switches = sim_switches | SIM_SW_SHUT;          /* flag shutdown */\r\nfor (i = start; (dptr = sim_devices[i]) != NULL; i++) { /* loop thru dev */\r\n    for (j = 0; j < dptr->numunits; j++) {              /* loop thru units */\r\n        uptr = (dptr->units) + j;\r\n        if ((uptr->flags & UNIT_ATT) ||                 /* attached? */\r\n            (shutdown && dptr->detach &&                /* shutdown, spec rtn, */\r\n            !(uptr->flags & UNIT_ATTABLE))) {           /* !attachable? */\r\n            r = scp_detach_unit (dptr, uptr);           /* detach unit */\r\n\r\n            if ((r != SCPE_OK) && !shutdown)            /* error and not shutting down? */\r\n                return r;                               /* bail out now with error status */\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Call device-specific or file-oriented detach unit routine */\r\n\r\nt_stat scp_detach_unit (DEVICE *dptr, UNIT *uptr)\r\n{\r\nif (dptr->detach != NULL)                               /* device routine? */\r\n    return dptr->detach (uptr);\r\nreturn detach_unit (uptr);                              /* no, standard */\r\n}\r\n\r\n/* Detach unit from file */\r\n\r\nt_stat detach_unit (UNIT *uptr)\r\n{\r\nDEVICE *dptr;\r\n\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nif (!(uptr->flags & UNIT_ATTABLE))                      /* attachable? */\r\n    return SCPE_NOATT;\r\nif (!(uptr->flags & UNIT_ATT)) {                        /* not attached? */\r\n    if (sim_switches & SIM_SW_REST)                     /* restoring? */\r\n        return SCPE_OK;                                 /* allow detach */\r\n    else\r\n        return SCPE_UNATT;                              /* complain */\r\n    }\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_OK;\r\nif ((dptr->flags & DEV_DISK) && ((dptr->flags & DEV_TAPE) == 0))\r\n    return sim_disk_detach (uptr);\r\nif ((dptr->flags & DEV_TAPE) && ((dptr->flags & DEV_DISK) == 0))\r\n    return sim_tape_detach (uptr);\r\nif ((uptr->flags & UNIT_BUF) && (uptr->filebuf)) {\r\n    uint32 cap = (uptr->hwmark + dptr->aincr - 1) / dptr->aincr;\r\n    if (((uptr->flags & UNIT_RO) == 0) &&\r\n        (memcmp (uptr->filebuf, uptr->filebuf2, (size_t)(SZ_D (dptr) * (uptr->capac / dptr->aincr))) != 0)) {\r\n        sim_messagef (SCPE_OK, \"%s: writing buffer to file: %s\\n\", sim_uname (uptr), sim_attach_name (uptr));\r\n        rewind (uptr->fileref);\r\n        sim_fwrite (uptr->filebuf, SZ_D (dptr), cap, uptr->fileref);\r\n        if (ferror (uptr->fileref))\r\n            sim_printf (\"%s: I/O error - %s\", sim_uname (uptr), strerror (errno));\r\n        }\r\n    if (uptr->flags & UNIT_MUSTBUF) {                   /* dyn alloc? */\r\n        free (uptr->filebuf);                           /* free buffers */\r\n        uptr->filebuf = NULL;\r\n        free (uptr->filebuf2);\r\n        uptr->filebuf2 = NULL;\r\n        }\r\n    uptr->flags = uptr->flags & ~UNIT_BUF;\r\n    }\r\nuptr->flags = uptr->flags & ~(UNIT_ATT | ((uptr->flags & UNIT_ROABLE) ? UNIT_RO : 0));\r\nfree (uptr->filename);\r\nuptr->filename = NULL;\r\nif (uptr->fileref) {                        /* Only close open file */\r\n    if (fclose (uptr->fileref) == EOF) {\r\n        uptr->fileref = NULL;\r\n        return SCPE_IOERR;\r\n        }\r\n    uptr->fileref = NULL;\r\n    }\r\nuptr->dynflags &= ~UNIT_NO_FIO;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Assign command\r\n\r\n   as[sign] device name assign logical name to device or unit\r\n*/\r\n\r\nt_stat assign_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nDEVICE *dptr;\r\nUNIT *uptr, *tuptr;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get next glyph */\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* now eol? */\r\n    return SCPE_2FARG;\r\ndptr = find_unit (gbuf, &uptr);                         /* locate device */\r\nif (dptr == NULL)                                       /* found dev? */\r\n    return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get next glyph */\r\nif (*cptr != 0)                                         /* must be eol */\r\n    return sim_messagef (SCPE_2MARG, \"Unexpected additional arguments: %s\\n\", cptr);\r\nif ((find_dev (gbuf) != NULL) ||                        /* name in use? */\r\n    (find_unit (gbuf, &tuptr) != NULL))\r\n    return sim_messagef (SCPE_AMBASSIGN, \"%s is already in use\\n\", gbuf);\r\nif ((dptr->numunits > 1) || (uptr != dptr->units))\r\n    return assign_unit (uptr, gbuf);\r\nreturn assign_device (dptr, gbuf);\r\n}\r\n\r\nt_stat assign_device (DEVICE *dptr, const char *cptr)\r\n{\r\ndptr->lname = (char *) realloc (dptr->lname, (1 + strlen (cptr)) * sizeof (char));\r\nif (dptr->lname == NULL)\r\n    return SCPE_MEM;\r\nstrcpy (dptr->lname, cptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat assign_unit (UNIT *uptr, const char *cptr)\r\n{\r\nuptr->lname = (char *) realloc (uptr->lname, (1 + strlen (cptr)) * sizeof (char));\r\nif (uptr->lname == NULL)\r\n    return SCPE_MEM;\r\nstrcpy (uptr->lname, cptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Deassign command\r\n\r\n   dea[ssign] device    deassign logical name\r\n*/\r\n\r\nt_stat deassign_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get next glyph */\r\nif (*cptr != 0)                                         /* now eol? */\r\n    return SCPE_2MARG;\r\ndptr = find_unit (gbuf, &uptr);                         /* locate device or unit */\r\nif (dptr == NULL)                                       /* found dev? */\r\n    return sim_messagef (SCPE_NXDEV, \"Non-existent device: %s\\n\", gbuf);\r\nif (uptr == NULL)\r\n    return deassign_device (dptr);\r\nelse\r\n    return deassign_unit (uptr);\r\n}\r\n\r\nt_stat deassign_device (DEVICE *dptr)\r\n{\r\nfree (dptr->lname);\r\ndptr->lname = NULL;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat deassign_unit (UNIT *uptr)\r\n{\r\nfree (uptr->lname);\r\nuptr->lname = NULL;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Get device display name */\r\n\r\nconst char *sim_dname (DEVICE *dptr)\r\n{\r\nreturn (dptr ? (dptr->lname? dptr->lname: dptr->name) : \"\");\r\n}\r\n\r\n/* Get unit display name */\r\n\r\nconst char *sim_uname (UNIT *uptr)\r\n{\r\nDEVICE *d;\r\nchar uname[CBUFSIZE];\r\n\r\nif (!uptr)\r\n    return \"\";\r\nif (uptr->lname)\r\n    return uptr->lname;             /* Prefer user defined Logical Name defined? */\r\nif (uptr->uname)\r\n    return uptr->uname;\r\nd = find_dev_from_unit(uptr);\r\nif (!d)\r\n    return \"\";\r\nif (d->numunits == 1)\r\n    sprintf (uname, \"%s\", sim_dname (d));\r\nelse\r\n    sprintf (uname, \"%s%d\", sim_dname (d), (int)(uptr-d->units));\r\nreturn sim_set_uname (uptr, uname);\r\n}\r\n\r\nconst char *sim_set_uname (UNIT *uptr, const char *uname)\r\n{\r\nfree (uptr->uname);\r\nreturn uptr->uname = strcpy ((char *)malloc (1 + strlen (uname)), uname);\r\n}\r\n\r\n/* Get attach display name */\r\n\r\nconst char *sim_attach_name (UNIT *uptr)\r\n{\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\n\r\nif ((uptr == NULL) || ((uptr->flags & UNIT_ATT) == 0))\r\n    return \"\";\r\nif ((DEV_TYPE (uptr->dptr) != DEV_MUX) &&\r\n    (DEV_TYPE (uptr->dptr) != DEV_ETHER))\r\n    return sim_relative_path (uptr->filename);\r\nelse\r\n    return uptr->filename;\r\n}\r\n\r\n\r\n/* Save command\r\n\r\n   sa[ve] filename              save state to specified file\r\n*/\r\n\r\nt_stat save_cmd (int32 flag, CONST char *cptr)\r\n{\r\nFILE *sfile;\r\nt_stat r;\r\nchar gbuf[4*CBUFSIZE];\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ngbuf[sizeof(gbuf)-1] = '\\0';\r\nstrlcpy (gbuf, cptr, sizeof(gbuf));\r\nsim_trim_endspc (gbuf);\r\nif ((sfile = sim_fopen (gbuf, \"r+b\")) == NULL) {    /* try existing file */\r\n    if ((sfile = sim_fopen (gbuf, \"wb\")) == NULL)   /* create new empty file */\r\n        return SCPE_OPENERR;\r\n    }\r\nr = sim_save (sfile);\r\nfclose (sfile);\r\nreturn r;\r\n}\r\n\r\nt_stat sim_save (FILE *sfile)\r\n{\r\nvoid *mbuf;\r\nint32 l, t;\r\nuint32 i, j, device_count;\r\nt_addr k, high;\r\nt_value val;\r\nt_stat r;\r\nt_bool zeroflg;\r\nsize_t sz;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nREG *rptr;\r\n\r\n#define WRITE_I(xx) sim_fwrite (&(xx), sizeof (xx), 1, sfile)\r\n\r\nsim_debug(SIM_DBG_SAVE, &sim_scp_dev, \"sim_save ()\\n\");\r\n\r\n/* Don't make changes below without also changing save_vercur above */\r\n\r\nfprintf (sfile, \"%s\\n%s\\n%s\\n%s\\n%s\\n%.0f\\n\",\r\n    save_vercur,                                        /* [V2.5] save format */\r\n    sim_savename,                                       /* sim name */\r\n    sim_si64, sim_sa64, eth_capabilities(),             /* [V3.5] options */\r\n    sim_time);                                          /* [V3.2] sim time */\r\nWRITE_I (sim_rtime);                                    /* [V2.6] sim rel time */\r\n#if defined(SIM_GIT_COMMIT_ID)\r\nfprintf (sfile, \"git commit id: %8.8s\\n\", __STR(SIM_GIT_COMMIT_ID));\r\n#else\r\nfprintf (sfile, \"git commit id: unknown\\n\");\r\n#endif\r\n\r\nfor (device_count = 0; sim_devices[device_count]; device_count++);/* count devices */\r\nfor (i = 0; i < (device_count + sim_internal_device_count); i++) {/* loop thru devices */\r\n    if (i < device_count)\r\n        dptr = sim_devices[i];\r\n    else\r\n        dptr = sim_internal_devices[i - device_count];\r\n    if (dptr->flags & DEV_NOSAVE)\r\n        continue;\r\n    sim_debug (SIM_DBG_SAVE, &sim_scp_dev, \"Saving %s\\n\", dptr->name);\r\n    fputs (dptr->name, sfile);                          /* device name */\r\n    fputc ('\\n', sfile);\r\n    if (dptr->lname)                                    /* [V3.0] logical name */\r\n        fputs (dptr->lname, sfile);\r\n    fputc ('\\n', sfile);\r\n    WRITE_I (dptr->flags);                              /* [V2.10] flags */\r\n    for (j = 0; j < dptr->numunits; j++) {\r\n        uptr = dptr->units + j;\r\n        t = sim_activate_time (uptr);\r\n        WRITE_I (j);                                    /* unit number */\r\n        WRITE_I (t);                                    /* activation time */\r\n        WRITE_I (uptr->u3);                             /* unit specific */\r\n        WRITE_I (uptr->u4);\r\n        WRITE_I (uptr->u5);                             /* [V3.0] more unit */\r\n        WRITE_I (uptr->u6);\r\n        WRITE_I (uptr->flags);                          /* [V2.10] flags */\r\n        WRITE_I (uptr->dynflags);\r\n        WRITE_I (uptr->wait);\r\n        WRITE_I (uptr->buf);\r\n        WRITE_I (uptr->recsize);\r\n        WRITE_I (uptr->tape_eom);\r\n        WRITE_I (uptr->tape_chunk_size);\r\n        WRITE_I (uptr->capac);                          /* [V3.5] capacity */\r\n        fprintf (sfile, \"%.0f\\n\", uptr->usecs_remaining);/* [V4.0] remaining wait */\r\n        WRITE_I (uptr->pos);\r\n        if (uptr->flags & UNIT_ATT) {\r\n            if ((uptr->drvtyp != NULL) && (sim_disk_drive_type_set_string (uptr) != NULL))\r\n                fprintf (sfile, \"\\001DriveType=%s\\001\", sim_disk_drive_type_set_string (uptr));\r\n            fputs (sim_attach_name (uptr), sfile);\r\n            if ((uptr->flags & UNIT_BUF) &&             /* writable buffered */\r\n                uptr->hwmark &&                         /* files need to be */\r\n                ((uptr->flags & UNIT_RO) == 0)) {       /* written on save */\r\n                uint32 cap = (uptr->hwmark + dptr->aincr - 1) / dptr->aincr;\r\n                rewind (uptr->fileref);\r\n                sim_fwrite (uptr->filebuf, SZ_D (dptr), cap, uptr->fileref);\r\n                fclose (uptr->fileref);                 /* flush data and state */\r\n                uptr->fileref = sim_fopen (uptr->filename, \"rb+\");/* reopen r/w */\r\n                }\r\n            }\r\n        fputc ('\\n', sfile);\r\n        if (((uptr->flags & (UNIT_FIX + UNIT_ATTABLE)) == UNIT_FIX) &&\r\n             (dptr->examine != NULL) &&\r\n             ((high = uptr->capac) != 0)) {             /* memory-like unit? */\r\n            WRITE_I (high);                             /* [V2.5] write size */\r\n            sz = SZ_D (dptr);\r\n            if ((mbuf = calloc (SRBSIZ, sz)) == NULL) {\r\n                fclose (sfile);\r\n                return SCPE_MEM;\r\n                }\r\n            for (k = 0; k < high; ) {                   /* loop thru mem */\r\n                zeroflg = TRUE;\r\n                for (l = 0; (l < SRBSIZ) && (k < high); l++,\r\n                     k = k + (dptr->aincr)) {           /* check for 0 block */\r\n                    r = dptr->examine (&val, k, uptr, SIM_SW_REST);\r\n                    if (r != SCPE_OK) {\r\n                        free (mbuf);\r\n                        return r;\r\n                        }\r\n                    if (val) zeroflg = FALSE;\r\n                    SZ_STORE (sz, val, mbuf, l);\r\n                    }                                   /* end for l */\r\n                if (zeroflg) {                          /* all zero's? */\r\n                    l = -l;                             /* invert block count */\r\n                    WRITE_I (l);                        /* write only count */\r\n                    }\r\n                else {\r\n                    WRITE_I (l);                        /* block count */\r\n                    sim_fwrite (mbuf, sz, l, sfile);\r\n                    }\r\n                }                                       /* end for k */\r\n            free (mbuf);                                /* dealloc buffer */\r\n            }                                           /* end if mem */\r\n        else {                                          /* no memory */\r\n            high = 0;                                   /* write 0 */\r\n            WRITE_I (high);\r\n            }                                           /* end else mem */\r\n        }                                               /* end unit loop */\r\n    t = -1;                                             /* end units */\r\n    WRITE_I (t);                                        /* write marker */\r\n    for (rptr = dptr->registers; (rptr != NULL) &&      /* loop thru regs */\r\n         (rptr->name != NULL); rptr++) {\r\n        fputs (rptr->name, sfile);                      /* name */\r\n        fputc ('\\n', sfile);\r\n        WRITE_I (rptr->depth);                          /* [V2.10] depth */\r\n        for (j = 0; j < rptr->depth; j++) {             /* loop thru values */\r\n            if ((rptr->macro != NULL) && (memcmp (rptr->macro, \"DBRDATA\", 7) == 0)) {\r\n                fprintf (sfile, \"%f\\n\", *(((double *)(rptr->loc)) + j));\r\n                }\r\n            else {\r\n                val = get_rval (rptr, j);                   /* get value */\r\n                WRITE_I (val);                              /* store */\r\n                }\r\n            }\r\n        }\r\n    fputc ('\\n', sfile);                                /* end registers */\r\n    }\r\nfputc ('\\n', sfile);                                    /* end devices */\r\nif (!ferror (sfile)) {\r\n    t_offset pos = sim_ftell (sfile);                   /* get current position */\r\n\r\n    if (pos < 0)                                        /* error? */\r\n        return SCPE_IOERR;                              /* done! */\r\n    sim_set_fsize (sfile, (t_addr)pos);                 /* truncate the save file */\r\n    }\r\nreturn (ferror (sfile))? SCPE_IOERR: SCPE_OK;           /* error during save? */\r\n}\r\n\r\n/* Restore command\r\n\r\n   re[store] filename           restore state from specified file\r\n*/\r\n\r\nt_stat restore_cmd (int32 flag, CONST char *cptr)\r\n{\r\nFILE *rfile;\r\nt_stat r;\r\nchar gbuf[4*CBUFSIZE];\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\ngbuf[sizeof(gbuf)-1] = '\\0';\r\nstrlcpy (gbuf, cptr, sizeof(gbuf));\r\nsim_trim_endspc (gbuf);\r\nif ((rfile = sim_fopen (gbuf, \"rb\")) == NULL)\r\n    return SCPE_OPENERR;\r\nr = sim_rest (rfile);\r\nfclose (rfile);\r\nreturn r;\r\n}\r\n\r\nt_stat sim_rest (FILE *rfile)\r\n{\r\nchar buf[CBUFSIZE];\r\nchar **attnames = NULL;\r\nUNIT **attunits = NULL;\r\nint32 *attswitches = NULL;\r\nint32 attcnt = 0;\r\nvoid *mbuf = NULL;\r\nint32 j, blkcnt, limit, unitno, time, flg;\r\nuint32 us, depth;\r\nt_addr k, high, old_capac;\r\nt_value val, max;\r\nt_stat r;\r\nsize_t sz;\r\nt_bool v40, v35, v32;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nREG *rptr;\r\nstruct stat rstat;\r\nt_bool force_restore = ((sim_switches & SWMASK ('F')) != 0);\r\nt_bool dont_detach_attach = ((sim_switches & SWMASK ('D')) != 0);\r\nt_bool suppress_warning = ((sim_switches & SWMASK ('Q')) != 0);\r\nt_bool warned = FALSE;\r\n\r\nsim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"sim_rest (force=%d, dont_detach=%d, nowarnings=%d)\\n\", force_restore, dont_detach_attach, suppress_warning);\r\nsim_switches &= ~(SWMASK ('F') | SWMASK ('D') | SWMASK ('Q'));  /* remove digested switches */\r\n#define READ_S(xx) if (read_line ((xx), sizeof(xx), rfile) == NULL) {   \\\r\n    r = SCPE_IOERR;                                                     \\\r\n    goto Cleanup_Return;                                                \\\r\n    }\r\n#define READ_I(xx) if (sim_fread (&xx, sizeof (xx), 1, rfile) == 0) {   \\\r\n    r = SCPE_IOERR;                                                     \\\r\n    goto Cleanup_Return;                                                \\\r\n    }\r\n\r\nif (fstat (fileno (rfile), &rstat)) {\r\n    r = SCPE_IOERR;\r\n    goto Cleanup_Return;\r\n    }\r\nREAD_S (buf);                                           /* [V2.5+] read version */\r\nsim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"version=%s\\n\", buf);\r\nv40 = v35 = v32 = FALSE;\r\nif (strcmp (buf, save_ver40) == 0)                      /* version 4.0? */\r\n    v40 = v35 = v32 = TRUE;\r\nelse if (strcmp (buf, save_ver35) == 0)                 /* version 3.5? */\r\n    v35 = v32 = TRUE;\r\nelse if (strcmp (buf, save_ver32) == 0)                 /* version 3.2? */\r\n    v32 = TRUE;\r\nelse if (strcmp (buf, save_ver30) != 0) {               /* version 3.0? */\r\n    sim_printf (\"Invalid file version: %s\\n\", buf);\r\n    return SCPE_INCOMP;\r\n    }\r\nif ((strcmp (buf, save_ver40) != 0) && (!sim_quiet) && (!suppress_warning)) {\r\n    sim_printf (\"warning - attempting to restore a saved simulator image in %s image format.\\n\", buf);\r\n    warned = TRUE;\r\n    }\r\nREAD_S (buf);                                           /* read sim name */\r\nsim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"sim_name=%s\\n\", buf);\r\nif (strcmp (buf, sim_savename)) {                       /* name match? */\r\n    sim_printf (\"Wrong system type: %s\\n\", buf);\r\n    return SCPE_INCOMP;\r\n    }\r\nif (v35) {                                              /* [V3.5+] options */\r\n    READ_S (buf);                                       /* integer size */\r\n    if (strcmp (buf, sim_si64) != 0) {\r\n        sim_printf (\"Incompatible integer size, save file = %s\\n\", buf);\r\n        return SCPE_INCOMP;\r\n        }\r\n    READ_S (buf);                                       /* address size */\r\n    if (strcmp (buf, sim_sa64) != 0) {\r\n        sim_printf (\"Incompatible address size, save file = %s\\n\", buf);\r\n        return SCPE_INCOMP;\r\n        }\r\n    READ_S (buf);                                       /* Ethernet */\r\n    }\r\nif (v32) {                                              /* [V3.2+] time as string */\r\n    READ_S (buf);\r\n    sscanf (buf, \"%lf\", &sim_time);\r\n    }\r\nelse READ_I (sim_time);                                 /* sim time */\r\nREAD_I (sim_rtime);                                     /* [V2.6+] sim rel time */\r\nif (v40) {\r\n    READ_S (buf);                                       /* read git commit id */\r\n#if defined(SIM_GIT_COMMIT_ID)\r\n    if ((memcmp (buf, \"git commit id: \" __STR(SIM_GIT_COMMIT_ID), 23)) &&\r\n        (!sim_quiet) && (!suppress_warning)) {\r\n        sim_printf (\"warning - different simulator git versions.\\nSaved commit id: %8.8s, Running commit id: %8.8s\\n\", buf + 15, __STR(SIM_GIT_COMMIT_ID));\r\n        warned = TRUE;\r\n        }\r\n#endif\r\n    }\r\nif (!dont_detach_attach)\r\n    detach_all (0, 0);                                  /* Detach everything to start from a consistent state */\r\nelse {\r\n    if (!suppress_warning) {\r\n        uint32 i, j;\r\n\r\n        for (i = 0; (dptr = sim_devices[i]) != NULL; i++) { /* loop thru dev */\r\n            for (j = 0; j < dptr->numunits; j++) {      /* loop thru units */\r\n                uptr = (dptr->units) + j;\r\n                if (uptr->flags & UNIT_ATT) {           /* attached? */\r\n                    sim_printf (\"warning - leaving %s attached to '%s'\\n\", sim_uname (uptr), sim_attach_name (uptr));\r\n                    warned = TRUE;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\nfor ( ;; ) {                                            /* device loop */\r\n    READ_S (buf);                                       /* read device name */\r\n    if (buf[0] == 0)                                    /* last? */\r\n        break;\r\n    sim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"DEVICE=%s\\n\", buf);\r\n    if ((dptr = find_dev (buf)) == NULL) {              /* locate device */\r\n        sim_printf (\"Invalid device name: %s\\n\", buf);\r\n        r = SCPE_INCOMP;\r\n        goto Cleanup_Return;\r\n        }\r\n    READ_S (buf);                                       /* [V3.0+] logical name */\r\n    if (buf[0] != '\\0')\r\n        sim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"logical name=%s\\n\", buf);\r\n    deassign_device (dptr);                             /* delete old name */\r\n    if ((buf[0] != 0) &&\r\n        ((r = assign_device (dptr, buf)) != SCPE_OK)) {\r\n        r = SCPE_INCOMP;\r\n        goto Cleanup_Return;\r\n        }\r\n    READ_I (flg);                                       /* [V2.10+] ctlr flags */\r\n    sim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"DEVICE.flags=%0X\\n\", flg);\r\n    if (!v32)\r\n        flg = ((flg & DEV_UFMASK_31) << (DEV_V_UF - DEV_V_UF_31)) |\r\n            (flg & ~DEV_UFMASK_31);                     /* [V3.2+] flags moved */\r\n    dptr->flags = (dptr->flags & ~DEV_RFLAGS) |         /* restore ctlr flags */\r\n         (flg & DEV_RFLAGS);\r\n    for ( ;; ) {                                        /* unit loop */\r\n        sim_switches = SIM_SW_REST;                     /* flag rstr, clr RO */\r\n        READ_I (unitno);                                /* unit number */\r\n        if (unitno < 0)                                 /* end units? */\r\n            break;\r\n        if ((uint32) unitno >= dptr->numunits) {        /* too big? */\r\n            sim_printf (\"Invalid unit number: %s%d\\n\", sim_dname (dptr), unitno);\r\n            r = SCPE_INCOMP;\r\n            goto Cleanup_Return;\r\n            }\r\n        READ_I (time);                                  /* event time */\r\n        uptr = (dptr->units) + unitno;\r\n        sim_cancel (uptr);\r\n        if (time > 0)\r\n            sim_activate (uptr, time - 1);\r\n        READ_I (uptr->u3);                              /* device specific */\r\n        READ_I (uptr->u4);\r\n        READ_I (uptr->u5);                              /* [V3.0+] more dev spec */\r\n        READ_I (uptr->u6);\r\n        READ_I (flg);                                   /* [V2.10+] unit flags */\r\n        if (v40) {                                      /* [V4.0+] dynflags */\r\n            READ_I (uptr->dynflags);\r\n            READ_I (uptr->wait);\r\n            READ_I (uptr->buf);\r\n            READ_I (uptr->recsize);\r\n            READ_I (uptr->tape_eom);\r\n            READ_I (uptr->tape_chunk_size);\r\n            }\r\n        old_capac = uptr->capac;                        /* save current capacity */\r\n        if (v35) {                                      /* [V3.5+] capacity */\r\n            READ_I (uptr->capac);\r\n            }\r\n        if (v40) {\r\n            READ_S (buf);\r\n            sscanf (buf, \"%lf\", &uptr->usecs_remaining);\r\n            READ_I (uptr->pos);\r\n            }\r\n        if (!v32)\r\n            flg = ((flg & UNIT_UFMASK_31) << (UNIT_V_UF - UNIT_V_UF_31)) |\r\n                (flg & ~UNIT_UFMASK_31);                /* [V3.2+] flags moved */\r\n        uptr->flags = (uptr->flags & ~UNIT_RFLAGS) |\r\n            (flg & UNIT_RFLAGS);                        /* restore */\r\n        READ_S (buf);                                   /* attached file */\r\n        if ((uptr->flags & UNIT_ATT) &&                 /* unit currently attached? */\r\n            (!dont_detach_attach)) {\r\n            r = scp_detach_unit (dptr, uptr);           /* detach it */\r\n            if (r != SCPE_OK) {\r\n                sim_printf (\"Error detaching %s from %s: %s\\n\", sim_uname (uptr), sim_attach_name (uptr), sim_error_text (r));\r\n                r = SCPE_INCOMP;\r\n                goto Cleanup_Return;\r\n                }\r\n            }\r\n        if ((buf[0] != '\\0') &&                         /* unit to be reattached? */\r\n            ((uptr->flags & UNIT_ATTABLE) ||            /*  and unit is attachable */\r\n             (dptr->attach != NULL))) {                 /*    or VM attach routine provided? */\r\n            uptr->flags = uptr->flags & ~UNIT_DIS;      /* ensure device is enabled */\r\n            if (flg & UNIT_RO)                          /* [V2.10+] saved flgs & RO? */\r\n                sim_switches |= SWMASK ('R');           /* RO attach */\r\n            /* add unit to list of units to attach after registers are read */\r\n            attunits = (UNIT **)realloc (attunits, sizeof (*attunits)*(attcnt+1));\r\n            attunits[attcnt] = uptr;\r\n            attnames = (char **)realloc (attnames, sizeof (*attnames)*(attcnt+1));\r\n            attnames[attcnt] = (char *)malloc(1+strlen(buf));\r\n            strcpy (attnames[attcnt], buf);\r\n            attswitches = (int32 *)realloc (attswitches, sizeof (*attswitches)*(attcnt+1));\r\n            attswitches[attcnt] = sim_switches;\r\n            ++attcnt;\r\n            }\r\n        READ_I (high);                                  /* memory capacity */\r\n        if (high > 0) {                                 /* [V2.5+] any memory? */\r\n            if (((uptr->flags & (UNIT_FIX + UNIT_ATTABLE)) != UNIT_FIX) ||\r\n                 (dptr->deposit == NULL)) {\r\n                sim_printf (\"Can't restore memory: %s%d\\n\", sim_dname (dptr), unitno);\r\n                r = SCPE_INCOMP;\r\n                goto Cleanup_Return;\r\n                }\r\n            if (high != old_capac) {                    /* size change? */\r\n                uptr->capac = old_capac;                /* temp restore old */\r\n                if ((dptr->flags & DEV_DYNM) &&\r\n                    ((dptr->msize == NULL) ||\r\n                     (dptr->msize (uptr, (int32) high, NULL, NULL) != SCPE_OK))) {\r\n                    sim_printf (\"Can't change memory size: %s%d\\n\",\r\n                                sim_dname (dptr), unitno);\r\n                    r = SCPE_INCOMP;\r\n                    goto Cleanup_Return;\r\n                    }\r\n                uptr->capac = high;                     /* new memory size */\r\n                sim_printf (\"Memory size changed: %s%d = \", sim_dname (dptr), unitno);\r\n                fprint_capac (stdout, dptr, uptr);\r\n                if (sim_log)\r\n                    fprint_capac (sim_log, dptr, uptr);\r\n                sim_printf (\"\\n\");\r\n                }\r\n            sz = SZ_D (dptr);                           /* allocate buffer */\r\n            if ((mbuf = realloc (mbuf, SRBSIZ * sz)) == NULL) {\r\n                r = SCPE_MEM;\r\n                goto Cleanup_Return;\r\n                }\r\n            for (k = 0; k < high; ) {                   /* loop thru mem */\r\n                if (sim_fread (&blkcnt, sizeof (blkcnt), 1, rfile) == 0) {/* block count */\r\n                    r = SCPE_IOERR;\r\n                    goto Cleanup_Return;\r\n                    }\r\n                if (blkcnt < 0)                         /* compressed? */\r\n                    limit = -blkcnt;\r\n                else\r\n                    limit = (int32)sim_fread (mbuf, sz, blkcnt, rfile);\r\n                if (limit <= 0) {                       /* invalid or err? */\r\n                    r = SCPE_IOERR;\r\n                    goto Cleanup_Return;\r\n                    }\r\n                for (j = 0; j < limit; j++, k = k + (dptr->aincr)) {\r\n                    if (blkcnt < 0)                     /* compressed? */\r\n                        val = 0;\r\n                    else\r\n                        SZ_LOAD (sz, val, mbuf, j);     /* saved value */\r\n                    r = dptr->deposit (val, k, uptr, SIM_SW_REST);\r\n                    if (r != SCPE_OK) {\r\n                        goto Cleanup_Return;\r\n                        }\r\n                    }                                   /* end for j */\r\n                }                                       /* end for k */\r\n            }                                           /* end if high */\r\n        }                                               /* end unit loop */\r\n    for ( ;; ) {                                        /* register loop */\r\n        READ_S (buf);                                   /* read reg name */\r\n        if (buf[0] == 0)                                /* last? */\r\n            break;\r\n        READ_I (depth);                                 /* [V2.10+] depth */\r\n        sim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"REGISTER=%s, depth=%u\\n\", buf, depth);\r\n        if ((rptr = find_reg (buf, NULL, dptr)) == NULL) {\r\n            sim_printf (\"Invalid register name: %s %s\\n\", sim_dname (dptr), buf);\r\n            for (us = 0; us < depth; us++) {            /* skip values */\r\n                READ_I (val);\r\n                }\r\n            continue;\r\n            }\r\n        if (depth != rptr->depth) {                      /* [V2.10+] mismatch? */\r\n            sim_printf (\"Register depth mismatch: %s %s, file = %d, sim = %d\\n\",\r\n                        sim_dname (dptr), buf, depth, rptr->depth);\r\n            if (depth > rptr->depth)\r\n                depth = rptr->depth;\r\n            }\r\n        if (rptr->maxval > 0)                           /* if a maximum value is defined */\r\n            max = rptr->maxval;                         /*   then use it */\r\n        else                                            /* otherwise */\r\n            max = width_mask[rptr->width];              /*   the mask defines the maximum value */\r\n        for (us = 0; us < depth; us++) {                /* loop thru values */\r\n            if ((rptr->macro != NULL) && (memcmp (rptr->macro, \"DBRDATA\", 7) == 0)) {\r\n                READ_S (buf);\r\n                sscanf(buf, \"%lf\", (((double *)rptr->loc) + us));\r\n                continue;\r\n                }\r\n            READ_I (val);                               /* read value */\r\n            if (val > max) {                            /* value ok? */\r\n                sim_printf (\"Invalid register value: %s %s\\n\", sim_dname (dptr), buf);\r\n                }\r\n            else {\r\n                if (us < rptr->depth)                   /* in range? */\r\n                    put_rval(rptr, us, val);\r\n                }\r\n            }\r\n        }                                               /* end register loop */\r\n    }                                                   /* end device loop */\r\n/* Now that all of the register state has been imported, we can attach\r\n   units which were originally attached.  Some of these attach operations\r\n   may depend on the state of the device (in registers) to work correctly */\r\nfor (j=0, r = SCPE_OK; j<attcnt; j++) {\r\n    if ((r == SCPE_OK) && (!dont_detach_attach)) {\r\n        struct stat fstat;\r\n        t_addr saved_pos;\r\n        char drivetype[CBUFSIZE], filename[CBUFSIZE], cmd[CBUFSIZE * 2];\r\n\r\n        if (0 != memcmp (attnames[j], \"\\001DriveType=\", 11)) {\r\n            strlcpy (filename, attnames[j], sizeof (filename));\r\n            cmd[0] = drivetype[0] = '\\0';\r\n            }\r\n        else {\r\n            const char *fname = get_glyph_gen (attnames[j] + 11, drivetype, '\\001', FALSE, TRUE, FALSE, 0);\r\n\r\n            strlcpy (filename, fname, sizeof (filename));\r\n            snprintf (cmd, sizeof (cmd), \"%s %s\", sim_uname (attunits[j]), drivetype);\r\n            }\r\n        sim_debug (SIM_DBG_RESTORE, &sim_scp_dev, \"ATTACHING=%s to %s%s%s\\n\", sim_uname (attunits[j]), filename, drivetype[0] ? \" as \" : \"\", drivetype);\r\n        if (cmd[0])\r\n            set_cmd (0, cmd);\r\n        dptr = find_dev_from_unit (attunits[j]);\r\n        if ((!force_restore) &&\r\n            (!stat(filename, &fstat)))\r\n            if (fstat.st_mtime > rstat.st_mtime + 30) {\r\n                r = SCPE_INCOMP;\r\n                sim_printf (\"Error Attaching %s to %s - the restore state is %d seconds older than the attach file\\n\", sim_dname (dptr), attnames[j], (int)(fstat.st_mtime - rstat.st_mtime));\r\n                sim_printf (\"restore with the -F switch to override this sanity check\\n\");\r\n                continue;\r\n                }\r\n        saved_pos = attunits[j]->pos;\r\n        sim_switches = attswitches[j];\r\n        r = scp_attach_unit (dptr, attunits[j], filename);/* reattach unit */\r\n        attunits[j]->pos = saved_pos;\r\n        if (r != SCPE_OK)\r\n            sim_printf (\"Error Attaching %s to %s%s%s\\n\", sim_uname (attunits[j]), filename, drivetype[0] ? \" as \" : \"\", drivetype);\r\n        }\r\n    else {\r\n        if ((r == SCPE_OK) && (dont_detach_attach)) {\r\n            if ((!suppress_warning) &&\r\n                ((!attunits[j]->filename) || (strcmp (attunits[j]->filename, attnames[j]) != 0))) {\r\n                warned = TRUE;\r\n                sim_printf (\"warning - %s was attached to '%s'\", sim_uname (attunits[j]), attnames[j]);\r\n                if (attunits[j]->filename)\r\n                    sim_printf (\", now attached to '%s'\\n\", attunits[j]->filename);\r\n                else\r\n                    sim_printf (\", now unattached\\n\");\r\n                }\r\n            }\r\n        }\r\n    free (attnames[j]);\r\n    attnames[j] = NULL;\r\n    }\r\nCleanup_Return:\r\nfree (mbuf);\r\nfor (j=0; j < attcnt; j++)\r\n    free (attnames[j]);\r\nfree (attnames);\r\nfree (attunits);\r\nfree (attswitches);\r\nif (warned)\r\n    sim_printf (\"restore with the -Q switch to suppress warning messages\\n\");\r\nreturn r;\r\n}\r\n\r\nvoid sim_flush_buffered_files (t_bool debug_flush)\r\n{\r\nuint32 i, j;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\n\r\nif (sim_log)                                            /* flush console log */\r\n    fflush (sim_log);\r\nif (debug_flush && (sim_deb != NULL))                   /* flush debug log */\r\n    _sim_debug_flush ();\r\nfor (i = 1; (dptr = sim_devices[i]) != NULL; i++) {     /* flush attached files */\r\n    for (j = 0; j < dptr->numunits; j++) {              /* if not buffered in mem */\r\n        uptr = dptr->units + j;\r\n        if (uptr->flags & UNIT_ATT) {                   /* attached, */\r\n            if (uptr->io_flush) {                       /* unit specific flush routine? */\r\n                if (!sim_asynch_enabled ||              /* and asynch I/O not possible? */\r\n                    !sim_is_running)\r\n                    uptr->io_flush (uptr);              /* call it */\r\n                }\r\n            else {\r\n                if (!(uptr->flags & UNIT_BUF) &&        /* not buffered, */\r\n                    (uptr->fileref) &&                  /* real file, */\r\n                    !(uptr->dynflags & UNIT_NO_FIO) &&  /* is FILE *, */\r\n                    !(uptr->flags & UNIT_RO))           /* not read only? */\r\n                    fflush (uptr->fileref);\r\n                }\r\n            }\r\n        }\r\n    }\r\ntmxr_flush_log_files ();\r\n}\r\n\r\nt_stat\r\nflush_svc (UNIT *uptr)\r\n{\r\nsim_activate_after (uptr, sim_flush_interval * 1000000);\r\nsim_flush_buffered_files (FALSE);\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Run, go, boot, cont, step, next commands\r\n\r\n   ru[n] [new PC]       reset and start simulation\r\n   go [new PC]          start simulation\r\n   co[nt]               start simulation\r\n   s[tep] [step limit]  start simulation for 'limit' instructions\r\n   next                 start simulation for 1 instruction\r\n                        stepping over subroutine calls\r\n   b[oot] device        bootstrap from device and start simulation\r\n\r\n   switches:\r\n    -Q                  quiet return status\r\n    -T                  (only for step), causes the step limit to\r\n                        be a number of microseconds to run for\r\n*/\r\n\r\nt_stat run_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE] = \"\";\r\nCONST char *tptr;\r\nuint32 i, j;\r\nint32 sim_next = 0;\r\nint32 unitno;\r\nt_value new_pcv, orig_pcv;\r\nt_stat r;\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\n\r\nif (sim_runlimit_enabled &&                             /* If the run limit has been hit? */\r\n    (!sim_is_active (&sim_runlimit_unit))) {\r\n    sim_messagef (SCPE_RUNTIME, \"Execution limit exceeded, can't proceed.  Exiting...\\n\");\r\n    exit (SCPE_RUNTIME);                                /* Execution can't proceed */\r\n    }\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nsim_step = 0;\r\nif ((flag == RU_RUN) || (flag == RU_GO)) {              /* run or go */\r\n    t_bool new_pc = FALSE;\r\n\r\n    new_pcv = orig_pcv = get_rval (sim_PC, 0);          /* get current PC value */\r\n    if (*cptr != 0) {                                   /* argument? */\r\n        cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n        if (MATCH_CMD (gbuf, \"UNTIL\") != 0) {\r\n            if (sim_vm_parse_addr)                      /* address parser? */\r\n                new_pcv = sim_vm_parse_addr (sim_dflt_dev, gbuf, &tptr);\r\n            else\r\n                new_pcv = strtotv (gbuf, &tptr, sim_PC->radix);/* parse PC */\r\n            if ((tptr == gbuf) || (*tptr != 0) ||       /* error? */\r\n                (new_pcv > ((sim_PC->maxval > 0)\r\n                            ? sim_PC->maxval\r\n                            : (width_mask[sim_PC->width]))))\r\n                return SCPE_ARG;\r\n            new_pc = TRUE;\r\n            }\r\n        }\r\n    put_rval_pcchk (sim_PC, 0, new_pcv, new_pc);        /* Save in PC in case reset references PC */\r\n    if ((flag == RU_RUN) &&                             /* run? */\r\n        ((r = sim_run_boot_prep (flag)) != SCPE_OK)) {  /* reset sim */\r\n        put_rval_pcchk (sim_PC, 0, orig_pcv, FALSE);    /* restore original PC */\r\n        return r;\r\n        }\r\n    if ((*cptr) || (MATCH_CMD (gbuf, \"UNTIL\") == 0)) {  /* should be end */\r\n        int32 saved_switches = sim_switches;\r\n\r\n        if (MATCH_CMD (gbuf, \"UNTIL\") != 0)\r\n            cptr = get_glyph (cptr, gbuf, 0);           /* get next glyph */\r\n        if (MATCH_CMD (gbuf, \"UNTIL\") != 0)\r\n            return sim_messagef (SCPE_2MARG, \"Unexpected %s command argument: %s %s\\n\",\r\n                                             (flag == RU_RUN) ? \"RUN\" : \"GO\", gbuf, cptr);\r\n        sim_switches = 0;\r\n        GET_SWITCHES (cptr);\r\n        if (((*cptr == '\\'') || (*cptr == '\"')) ||      /* Expect UNTIL condition */\r\n            (!sim_strncasecmp(cptr, \"HALTAFTER=\", 10))) {\r\n            r = expect_cmd (1, cptr);\r\n            if (r != SCPE_OK)\r\n                return r;\r\n            }\r\n        else {                                          /* BREAK UNTIL condition */\r\n            if (sim_switches == 0)\r\n                sim_switches = sim_brk_dflt;\r\n            sim_switches |= BRK_TYP_TEMP;               /* make this a one-shot breakpoint */\r\n            sim_brk_types |= BRK_TYP_TEMP;\r\n            r = ssh_break (NULL, cptr, SSH_ST);\r\n            if (r != SCPE_OK)\r\n                return sim_messagef (r, \"Unable to establish breakpoint at: %s\\n\", cptr);\r\n            }\r\n        sim_switches = saved_switches;\r\n        }\r\n    put_rval_pcchk (sim_PC, 0, new_pcv, new_pc);        /* Save in PC again in case reset changed it */\r\n    }\r\n\r\nelse if ((flag == RU_STEP) ||\r\n         ((flag == RU_NEXT) && !sim_vm_is_subroutine_call)) { /* step */\r\n    static t_bool not_implemented_message = FALSE;\r\n\r\n    if ((!not_implemented_message) && (flag == RU_NEXT)) {\r\n        sim_printf (\"This simulator does not have subroutine call detection.\\nPerforming a STEP instead\\n\");\r\n        not_implemented_message = TRUE;\r\n        flag = RU_STEP;\r\n        }\r\n    if (*cptr != 0) {                                   /* argument? */\r\n        cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n        if (*cptr != 0)                                 /* should be end */\r\n            return SCPE_2MARG;\r\n        sim_step = (int32) get_uint (gbuf, 0, INT_MAX, &r);\r\n        if ((r != SCPE_OK) || (sim_step <= 0))          /* error? */\r\n            return SCPE_ARG;\r\n        }\r\n    else\r\n        sim_step = 1;\r\n    }\r\nelse if (flag == RU_NEXT) {                             /* next */\r\n    t_addr *addrs;\r\n\r\n    if (*cptr != 0) {                                   /* argument? */\r\n        cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n        if (*cptr != 0)                                 /* should be end */\r\n            return SCPE_2MARG;\r\n        sim_next = (int32) get_uint (gbuf, 0, INT_MAX, &r);\r\n        if ((r != SCPE_OK) || (sim_next <= 0))          /* error? */\r\n            return SCPE_ARG;\r\n        }\r\n    else\r\n        sim_next = 1;\r\n    if (sim_vm_is_subroutine_call(&addrs)) {\r\n        sim_brk_types |= BRK_TYP_DYN_STEPOVER;\r\n        for (i=0; addrs[i]; i++)\r\n            sim_brk_set (addrs[i], BRK_TYP_DYN_STEPOVER, 0, NULL);\r\n        }\r\n    else\r\n        sim_step = 1;\r\n    }\r\nelse if (flag == RU_BOOT) {                             /* boot */\r\n    if (*cptr == 0)                                     /* must be more */\r\n        return SCPE_2FARG;\r\n    cptr = get_glyph (cptr, gbuf, 0);                   /* get next glyph */\r\n    if (*cptr != 0)                                     /* should be end */\r\n        return SCPE_2MARG;\r\n    dptr = find_unit (gbuf, &uptr);                     /* locate unit */\r\n    if (dptr == NULL)                                   /* found dev? */\r\n        return sim_messagef (SCPE_NXUN, \"No such Unit: %s\\n\", gbuf);\r\n    if (uptr == NULL)                                   /* valid unit? */\r\n        return sim_messagef (SCPE_NXUN, \"No such Unit: %s\\n\", gbuf);\r\n    if (dptr->boot == NULL)                             /* can it boot? */\r\n        return sim_messagef (SCPE_NOFNC, \"Non bootable device: %s\\n\", gbuf);\r\n    if (uptr->flags & UNIT_DIS)                         /* disabled? */\r\n        return sim_messagef (SCPE_UDIS, \"Unit disabled: %s\\n\", sim_uname (uptr));\r\n    if ((uptr->flags & UNIT_ATTABLE) &&                 /* if attable, att? */\r\n        !(uptr->flags & UNIT_ATT))\r\n        return sim_messagef (SCPE_UNATT, \"Unit not attached: %s\\n\", sim_uname (uptr));\r\n    unitno = (int32) (uptr - dptr->units);              /* recover unit# */\r\n    if ((r = sim_run_boot_prep (flag)) != SCPE_OK)      /* reset sim */\r\n        return r;\r\n    if ((r = dptr->boot (unitno, dptr)) != SCPE_OK)     /* boot device */\r\n        return r;\r\n    }\r\n\r\nelse\r\n    if (flag != RU_CONT)                                /* must be cont */\r\n        return SCPE_IERR;\r\n    else                                                /* CONTINUE command */\r\n        if (*cptr != 0)                                 /* should be end (no arguments allowed) */\r\n            return sim_messagef (SCPE_2MARG, \"CONTINUE command takes no arguments\\n\");\r\n\r\nif (sim_switches & SIM_SW_HIDE)                         /* Setup only for Remote Console Mode */\r\n    return SCPE_OK;\r\n\r\nfor (i = 1; (dptr = sim_devices[i]) != NULL; i++) {     /* reposition all */\r\n    for (j = 0; j < dptr->numunits; j++) {              /* seq devices */\r\n        uptr = dptr->units + j;\r\n        if ((uptr->flags & (UNIT_ATT + UNIT_SEQ)) == (UNIT_ATT + UNIT_SEQ))\r\n            if (sim_can_seek (uptr->fileref) &&\r\n                (0 != sim_fseek (uptr->fileref, uptr->pos, SEEK_SET)))\r\n                return sim_messagef (SCPE_IERR, \"Can't seek to %u in %s for %s\\n\", (unsigned)uptr->pos, sim_attach_name (uptr), sim_uname (uptr));\r\n        }\r\n    }\r\nif ((r = sim_ttrun ()) != SCPE_OK) {                    /* set console mode */\r\n    r = sim_messagef (SCPE_TTYERR, \"sim_ttrun() returned: %s - errno: %d - %s\\n\", sim_error_text (r), errno, strerror (errno));\r\n    sim_ttcmd ();\r\n    return r;\r\n    }\r\nif ((r = sim_check_console (30)) != SCPE_OK) {          /* check console, error? */\r\n    r = sim_messagef (r, \"sim_check_console () returned: %s - errno: %d - %s\\n\", sim_error_text (r), errno, strerror (errno));\r\n    sim_ttcmd ();\r\n    return r;\r\n    }\r\n#ifdef SIGHUP\r\nif (signal (SIGHUP, int_handler) == SIG_ERR) {          /* set WRU */\r\n    r = sim_messagef (SCPE_SIGERR, \"Can't establish SIGHUP: errno: %d - %s\", errno, strerror (errno));\r\n    sim_ttcmd ();\r\n    return r;\r\n    }\r\n#endif\r\nif (signal (SIGTERM, int_handler) == SIG_ERR) {         /* set WRU */\r\n    r = sim_messagef (SCPE_SIGERR, \"Can't establish SIGTERM: errno: %d - %s\", errno, strerror (errno));\r\n    sim_ttcmd ();\r\n    return r;\r\n    }\r\nif (sim_step)                                           /* set step timer */\r\n    sim_sched_step ();\r\nsim_activate_after (&sim_flush_unit, sim_flush_interval * 1000000);/* Enable periodic buffer flushing */\r\nstop_cpu = FALSE;\r\nsim_is_running = TRUE;                                  /* flag running */\r\nfflush(stdout);                                         /* flush stdout */\r\nif (sim_log)                                            /* flush log if enabled */\r\n    fflush (sim_log);\r\nsim_throt_sched ();                                     /* set throttle */\r\nsim_start_timer_services ();                            /* enable wall clock timing */\r\n\r\ndo {\r\n    t_addr *addrs;\r\n\r\n    while (1) {\r\n        r = sim_instr();\r\n        if (r != SCPE_REMOTE)\r\n            break;\r\n        UPDATE_SIM_TIME;\r\n        sim_remote_process_command ();                  /* Process the command and resume processing */\r\n        }\r\n    if ((flag != RU_NEXT) ||                            /* done if not doing NEXT */\r\n        (--sim_next <=0))\r\n        break;\r\n    if (sim_step == 0) {                                /* doing a NEXT? */\r\n        t_addr val;\r\n        BRKTAB *bp;\r\n\r\n        if (SCPE_BARE_STATUS(r) >= SCPE_BASE)           /* done if an error occurred */\r\n            break;\r\n        if (sim_vm_pc_value)                            /* done if didn't stop at a dynamic breakpoint */\r\n            val = (t_addr)(*sim_vm_pc_value)();\r\n        else\r\n            val = (t_addr)get_rval (sim_PC, 0);\r\n        if ((!(bp = sim_brk_fnd (val))) || (!(bp->typ & BRK_TYP_DYN_STEPOVER)))\r\n            break;\r\n        sim_brk_clrall (BRK_TYP_DYN_STEPOVER);          /* cancel any step/over subroutine breakpoints */\r\n        }\r\n    else {\r\n        if (r != SCPE_STEP)                             /* done if step didn't complete with step expired */\r\n            break;\r\n        }\r\n    /* setup another next/step */\r\n    sim_step = 0;\r\n    if (sim_vm_is_subroutine_call(&addrs)) {\r\n        sim_brk_types |= BRK_TYP_DYN_STEPOVER;\r\n        for (i=0; addrs[i]; i++)\r\n            sim_brk_set (addrs[i], BRK_TYP_DYN_STEPOVER, 0, NULL);\r\n        }\r\n    else\r\n        sim_step = 1;\r\n    if (sim_step)                                       /* set step timer */\r\n        sim_sched_step ();\r\n    } while (1);\r\n\r\nif ((SCPE_BARE_STATUS(r) == SCPE_STOP) &&\r\n    sigterm_received)\r\n    r = SCPE_SIGTERM;\r\n\r\nif (sim_runlimit_enabled) {\r\n    if (sim_runlimit_switches & SWMASK ('T'))\r\n        sim_runlimit_d = sim_activate_time_usecs (&sim_runlimit_unit);\r\n    else\r\n        sim_runlimit = sim_activate_time (&sim_runlimit_unit) - 1;\r\n    }\r\n\r\nif ((SCPE_BARE_STATUS(r) == SCPE_STOP) &&               /* WRU exit from sim_instr() */\r\n    (sim_on_actions[sim_do_depth][SCPE_STOP] == NULL) &&/* without a handler for a STOP condition */\r\n    (sim_on_actions[sim_do_depth][0] == NULL))\r\n    sim_os_ms_sleep (sim_stop_sleep_ms);                /* wait a bit for SIGINT */\r\nsim_is_running = FALSE;                                 /* flag idle */\r\nsim_stop_timer_services ();                             /* disable wall clock timing */\r\nsim_ttcmd ();                                           /* restore console */\r\nsim_brk_clrall (BRK_TYP_DYN_STEPOVER);                  /* cancel any step/over subroutine breakpoints */\r\n#ifdef SIGHUP\r\nsignal (SIGHUP, sigterm_received ? SIG_IGN : SIG_DFL);  /* cancel WRU */\r\n#endif\r\nsignal (SIGTERM, sigterm_received ? SIG_IGN : SIG_DFL); /* cancel WRU */\r\nsim_flush_buffered_files (TRUE);\r\nsim_cancel (&sim_flush_unit);                           /* cancel flush timer */\r\nsim_cancel_step ();                                     /* cancel step timer */\r\nsim_throt_cancel ();                                    /* cancel throttle */\r\nAIO_UPDATE_QUEUE;\r\nUPDATE_SIM_TIME;                                        /* update sim time */\r\nreturn r | ((sim_switches & SWMASK ('Q')) ? SCPE_NOMESSAGE : 0);\r\n}\r\n\r\n/* run command message handler */\r\n\r\nvoid\r\nrun_cmd_message (const char *unechoed_cmdline, t_stat r)\r\n{\r\n#if defined (VMS)\r\nprintf (\"\\n\");\r\n#endif\r\nif (unechoed_cmdline && (r >= SCPE_BASE) && (r != SCPE_STEP) && (r != SCPE_STOP) && (r != SCPE_EXPECT))\r\n    sim_printf(\"%s> %s\\n\", do_position(), unechoed_cmdline);\r\nfprint_stopped (stdout, r);                         /* print msg */\r\nif ((!sim_oline) && ((sim_log && (sim_log != stdout))))/* log if enabled */\r\n    fprint_stopped (sim_log, r);\r\nif (sim_deb && (sim_deb != stdout) && (sim_deb != sim_log)) {/* debug if enabled */\r\n    TMLN *saved_oline = sim_oline;\r\n\r\n    sim_oline = NULL;                               /* avoid potential debug to active socket */\r\n    fprint_stopped (sim_deb, r);\r\n    sim_oline = saved_oline;                        /* restore original socket */\r\n    }\r\n}\r\n\r\n/* Common setup for RUN or BOOT */\r\n\r\nt_stat sim_run_boot_prep (int32 flag)\r\n{\r\nt_stat r;\r\n\r\n/* reset queue */\r\nwhile (sim_clock_queue != QUEUE_LIST_END)\r\n    sim_cancel (sim_clock_queue);\r\nsim_reset_time ();\r\nr = reset_all (0);\r\nif ((r == SCPE_OK) && (flag == RU_RUN)) {\r\n    if ((run_cmd_did_reset) && (0 == (sim_switches & SWMASK ('Q')))) {\r\n        sim_printf (\"Resetting all devices...  This may not have been your intention.\\n\");\r\n        sim_printf (\"The GO and CONTINUE commands do not reset devices.\\n\");\r\n        }\r\n    run_cmd_did_reset = TRUE;\r\n    }\r\nreturn r;\r\n}\r\n\r\n/* Print stopped message\r\n * For VM stops, if a VM-specific \"sim_vm_fprint_stopped\" pointer is defined,\r\n * call the indicated routine to print additional information after the message\r\n * and before the PC value is printed.  If the routine returns FALSE, skip\r\n * printing the PC and its related instruction.\r\n */\r\n\r\nvoid fprint_stopped_gen (FILE *st, t_stat v, REG *pc, DEVICE *dptr)\r\n{\r\nint32 i;\r\nt_stat r = 0;\r\nt_addr k;\r\nt_value pcval;\r\n\r\nfputc ('\\n', st);                                       /* start on a new line */\r\n\r\nif (v == SCPE_OK || v >= SCPE_BASE)                                     /* SCP error? */\r\n    fputs (sim_error_text (v), st);                     /* print it from the SCP list */\r\nelse {                                                  /* VM error */\r\n    if (sim_stop_messages [v])\r\n        fputs (sim_stop_messages [v], st);              /* print the VM-specific message */\r\n    else\r\n        fprintf (st, \"Unknown %s simulator stop code %d\", sim_name, v);\r\n    if ((sim_vm_fprint_stopped != NULL) &&              /* if a VM-specific stop handler is defined */\r\n        (!sim_vm_fprint_stopped (st, v)))               /*   call it; if it returned FALSE, */\r\n        return;                                         /*     we're done */\r\n    }\r\n\r\nfprintf (st, \", %s: \", pc->name);                       /* print the name of the PC register */\r\n\r\npcval = get_rval (pc, 0);\r\nif ((pc->flags & REG_VMAD) && sim_vm_fprint_addr)       /* if reg wants VM-specific printer */\r\n    sim_vm_fprint_addr (st, dptr, (t_addr) pcval);      /*   call it to print the PC address */\r\nelse fprint_val (st, pcval, pc->radix, pc->width,       /* otherwise, print as a numeric value */\r\n    pc->flags & REG_FMT);                               /*   with the radix and formatting specified */\r\nif ((dptr != NULL) && (dptr->examine != NULL)) {\r\n    for (i = 0; i < sim_emax; i++)\r\n        sim_eval[i] = 0;\r\n    for (i = 0, k = (t_addr) pcval; i < sim_emax; i++, k = k + dptr->aincr) {\r\n        if ((r = dptr->examine (&sim_eval[i], k, dptr->units, SWMASK ('V')|SIM_SW_STOP)) != SCPE_OK)\r\n            break;\r\n        }\r\n    if ((r == SCPE_OK) || (i > 0)) {\r\n        fprintf (st, \" (\");\r\n        sim_fprint_sym (st, FALSE, (t_addr) pcval, sim_eval, NULL, SWMASK ('M') | SIM_SW_STOP, 0, dptr->dradix, dptr->dwidth, PV_RZRO);\r\n        fprintf (st, \")\");\r\n        }\r\n    }\r\nfprintf (st, \"\\n\");\r\n}\r\n\r\nvoid fprint_stopped (FILE *st, t_stat v)\r\n{\r\nfprint_stopped_gen (st, v, sim_PC, sim_dflt_dev);\r\n}\r\n\r\n/* Unit service for step timeout, originally scheduled by STEP n command\r\n   Return step timeout SCP code, will cause simulation to stop */\r\n\r\nt_stat step_svc (UNIT *uptr)\r\n{\r\nreturn SCPE_STEP;\r\n}\r\n\r\n/* Unit service for run for timeout, originally scheduled by RUNFOR n command\r\n   Return runlimit timeout SCP code, will cause simulation to stop */\r\n\r\nt_stat runlimit_svc (UNIT *uptr)\r\n{\r\nreturn SCPE_RUNTIME;\r\n}\r\n\r\n/* Unit service to facilitate expect matching to stop simulation.\r\n   Return expect SCP code, will cause simulation to stop */\r\n\r\nt_stat expect_svc (UNIT *uptr)\r\n{\r\nreturn SCPE_EXPECT | (sim_do_echo ? 0 : SCPE_NOMESSAGE);\r\n}\r\n\r\n/* Cancel scheduled step service */\r\n\r\nt_stat sim_cancel_step (void)\r\n{\r\nreturn sim_cancel (&sim_step_unit);\r\n}\r\n\r\n/* schedule step service */\r\n\r\nt_stat sim_sched_step (void)\r\n{\r\nif (sim_switches & SWMASK ('T'))                    /* stepping for elapsed time? */\r\n    return sim_activate_after_abs (&sim_step_unit, (uint32)sim_step);/* wall clock based step */\r\nelse\r\n    return sim_activate_abs (&sim_step_unit, sim_step);    /* instruction based step */\r\n}\r\n\r\n/* Signal handler for ^C signal - set stop simulation flag */\r\n\r\nvoid int_handler (int sig)\r\n{\r\nstop_cpu = TRUE;\r\nif (sig == SIGTERM)\r\n    sigterm_received = TRUE;\r\nsim_interval = 0;               /* Minimize when stop_cpu gets noticed */\r\n}\r\n\r\n/* Examine/deposit commands\r\n\r\n   ex[amine] [modifiers] list           examine\r\n   de[posit] [modifiers] list val       deposit\r\n   ie[xamine] [modifiers] list          interactive examine\r\n   id[eposit] [modifiers] list          interactive deposit\r\n\r\n   modifiers\r\n        @filename                       output file\r\n        -letter(s)                      switches\r\n        devname'n                       device name and unit number\r\n        [{&|^}value]{=|==|!|!=|>|>=|<|<=} value search specification\r\n\r\n   list                                 list of addresses and registers\r\n        addr[:addr|-addr]               address range\r\n        ALL                             all addresses\r\n        register[:register|-register]   register range\r\n        register[index]                 register array element\r\n        register[start:end]             register array range\r\n        STATE                           all registers\r\n*/\r\n\r\nt_stat exdep_cmd (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nCONST char *gptr;\r\nCONST char *tptr = NULL;\r\nconst char *ap;\r\nint32 opt;\r\nt_addr low, high;\r\nt_stat reason;\r\nDEVICE *tdptr;\r\nt_stat tstat = SCPE_OK;\r\nREG *lowr, *highr;\r\nFILE *ofile;\r\n\r\nopt = CMD_OPT_SW|CMD_OPT_SCH|CMD_OPT_DFT;               /* options for all */\r\nif (flag == EX_E)                                       /* extra for EX */\r\n    opt = opt | CMD_OPT_OF;\r\ncptr = get_sim_opt (opt, cptr, &reason);                /* get cmd options */\r\nif (!cptr)                                              /* error? */\r\n    return reason;\r\nif (*cptr == 0)                                         /* must be more */\r\n    return SCPE_2FARG;\r\nif (sim_dfunit == NULL)                                 /* got a unit? */\r\n    return SCPE_NXUN;\r\ncptr = get_glyph (cptr, gbuf, 0);                       /* get list */\r\nif ((flag == EX_D) && (*cptr == 0))                     /* deposit needs more */\r\n    return SCPE_2FARG;\r\nofile = sim_ofile? sim_ofile: stdout;                   /* no ofile? use stdout */\r\nif (sim_switches & SWMASK ('Q'))                        /* Quiet mode to suppress output */\r\n    ofile = stdnul;\r\n\r\nfor (gptr = gbuf, reason = SCPE_OK;\r\n    (*gptr != 0) && (reason == SCPE_OK); gptr = tptr) {\r\n    tdptr = sim_dfdev;                                  /* working dptr */\r\n    if (strncmp (gptr, \"STATE\", strlen (\"STATE\")) == 0) {\r\n        tptr = gptr + strlen (\"STATE\");\r\n        if (*tptr && (*tptr++ != ','))\r\n            return sim_messagef (SCPE_ARG, \"Invalid Argument: %s\\n\", (tptr - 1));\r\n        if ((lowr = sim_dfdev->registers) == NULL)\r\n            return sim_messagef (SCPE_NXREG, \"Non existant register: %s\\n\", tptr);\r\n        for (highr = lowr; highr->name != NULL; highr++) ;\r\n        sim_switches = sim_switches | SIM_SW_HIDE;\r\n        reason = exdep_reg_loop (ofile, sim_schrptr, flag, cptr,\r\n            lowr, --highr, 0, 0xFFFFFFFF);\r\n        if ((!sim_oline) && (sim_log && (ofile == stdout)))\r\n            exdep_reg_loop (sim_log, sim_schrptr, EX_E, cptr,\r\n                lowr, --highr, 0, 0xFFFFFFFF);\r\n        if (sim_deb && (sim_deb != stdout) && (sim_deb != sim_log))\r\n            exdep_reg_loop (sim_deb, sim_schrptr, EX_E, cptr,\r\n                lowr, --highr, 0, 0xFFFFFFFF);\r\n        continue;\r\n        }\r\n\r\n    if ((lowr = find_reg (gptr, &tptr, tdptr)) ||       /* local reg or */\r\n        (!(sim_opt_out & CMD_OPT_DFT) &&                /* no dflt, global? */\r\n        (lowr = find_reg_glob_reason (gptr, &tptr, &tdptr, &tstat)))) {\r\n        low = high = 0;\r\n        if ((*tptr == '-') || (*tptr == ':')) {\r\n            highr = find_reg (tptr + 1, &tptr, tdptr);\r\n            if (highr == NULL)\r\n                return sim_messagef (SCPE_NXREG, \"Non existant register: %s\\n\", tptr + 1);\r\n            }\r\n        else {\r\n            highr = lowr;\r\n            if (*tptr == '[') {\r\n                const char *stptr = tptr;\r\n\r\n                if (lowr->depth <= 1)\r\n                    return sim_messagef (SCPE_ARG, \"Invalid register depth specification: %s\\n\", tptr);\r\n                tptr = get_range (NULL, tptr + 1, &low, &high,\r\n                    10, lowr->depth - 1, ']');\r\n                if (tptr == NULL)\r\n                    return sim_messagef (SCPE_ARG, \"Invalid register depth specification: %s\\n\", stptr);\r\n                }\r\n            }\r\n        if (*tptr && (*tptr++ != ','))\r\n            return sim_messagef (SCPE_ARG, \"Invalid Argument: %s\\n\", (tptr - 1));\r\n        reason = exdep_reg_loop (ofile, sim_schrptr, flag, cptr,\r\n            lowr, highr, (uint32) low, (uint32) high);\r\n        if ((flag & EX_E) && (!sim_oline) && (sim_log && (ofile == stdout)))\r\n            exdep_reg_loop (sim_log, sim_schrptr, EX_E, cptr,\r\n                lowr, highr, (uint32) low, (uint32) high);\r\n        if ((flag & EX_E) && (!sim_oline) && (sim_deb && (sim_deb != stdout) && (sim_deb != sim_log)))\r\n            exdep_reg_loop (sim_deb, sim_schrptr, EX_E, cptr,\r\n                lowr, highr, (uint32) low, (uint32) high);\r\n        continue;\r\n        }\r\n\r\n    if ((ap = getenv (gptr))) {\r\n        strlcpy (gbuf, ap, sizeof (gbuf));\r\n        gptr = gbuf;\r\n        }\r\n    /* Special handling of EXAMINE to cover the case of ALL (detected in\r\n       get_range) so that all of memory isn't output at once without any\r\n       ability to interrupt that output */\r\n    tptr = get_range (sim_dfdev, gptr, &low, &high, sim_dfdev->aradix,\r\n        (((sim_dfunit->capac == 0) || (flag == EX_E))? 0:\r\n        sim_dfunit->capac - sim_dfdev->aincr), 0);\r\n    if (tptr == NULL)\r\n        return (tstat ? tstat : sim_messagef (SCPE_ARG, \"Non existant register: %s\\n\", gptr));\r\n    if (*tptr && (*tptr++ != ','))\r\n        return sim_messagef (SCPE_ARG, \"Invalid Argument: %s\\n\", (tptr - 1));\r\n    reason = exdep_addr_loop (ofile, sim_schaptr, flag, cptr, low, high,\r\n        sim_dfdev, sim_dfunit);\r\n    if ((flag & EX_E) && (!sim_oline) && (sim_log && (ofile == stdout)))\r\n        exdep_addr_loop (sim_log, sim_schaptr, EX_E, cptr, low, high,\r\n            sim_dfdev, sim_dfunit);\r\n    if ((flag & EX_E) && (!sim_oline) && (sim_deb && (sim_deb != stdout) && (sim_deb != sim_log)))\r\n        exdep_addr_loop (sim_deb, sim_schaptr, EX_E, cptr, low, high,\r\n            sim_dfdev, sim_dfunit);\r\n    }                                                   /* end for */\r\nif (sim_ofile)                                          /* close output file */\r\n    fclose (sim_ofile);\r\nreturn reason;\r\n}\r\n\r\n/* Loop controllers for examine/deposit\r\n\r\n   exdep_reg_loop       examine/deposit range of registers\r\n   exdep_addr_loop      examine/deposit range of addresses\r\n*/\r\n\r\nt_stat exdep_reg_loop (FILE *ofile, SCHTAB *schptr, int32 flag, CONST char *cptr,\r\n    REG *lowr, REG *highr, uint32 lows, uint32 highs)\r\n{\r\nt_stat reason;\r\nuint32 idx, val_start=lows, limits;\r\nt_value val, last_val;\r\nREG *rptr;\r\nint32 saved_switches = sim_switches;\r\n\r\nif ((lowr == NULL) || (highr == NULL))\r\n    return SCPE_IERR;\r\nif (lowr > highr)\r\n    return sim_messagef (SCPE_ARG, \"%s is > than %s\\n\", lowr->name, highr->name);\r\nfor (rptr = lowr; rptr <= highr; rptr++) {\r\n    if ((sim_switches & SIM_SW_HIDE) &&\r\n        (rptr->flags & REG_HIDDEN))\r\n        continue;\r\n    val = last_val = 0;\r\n    limits = highs;\r\n    if (highs == 0xFFFFFFFF)\r\n        limits = (rptr->depth > 1) ? (rptr->depth - 1) : 0;\r\n    for (idx = lows; idx <= limits; idx++) {\r\n        if (idx >= rptr->depth)\r\n            return SCPE_SUB;\r\n        sim_eval[0] = val = get_rval (rptr, idx);\r\n        sim_switches = saved_switches;\r\n        if (schptr && !test_search (sim_eval, schptr))\r\n            continue;\r\n        if (flag == EX_E) {\r\n            if ((idx > lows) && (val == last_val))\r\n                continue;\r\n            if (idx > val_start+1) {\r\n                if (idx-1 == val_start+1) {\r\n                    reason = ex_reg (ofile, val, flag, rptr, idx-1);\r\n                    sim_switches = saved_switches;\r\n                    if (reason != SCPE_OK)\r\n                        return reason;\r\n                    }\r\n                else {\r\n                    if (val_start+1 != idx-1)\r\n                        fprintf (ofile, \"%s[%d]-%s[%d]: same as above\\n\", rptr->name, val_start+1, rptr->name, idx-1);\r\n                    else\r\n                        fprintf (ofile, \"%s[%d]: same as above\\n\", rptr->name, val_start+1);\r\n                    }\r\n                }\r\n            last_val = val;\r\n            val_start = idx;\r\n            reason = ex_reg (ofile, val, flag, rptr, idx);\r\n            sim_switches = saved_switches;\r\n            if (reason != SCPE_OK)\r\n                return reason;\r\n            }\r\n        if (flag != EX_E) {\r\n            reason = dep_reg (flag, cptr, rptr, idx);\r\n            sim_switches = saved_switches;\r\n            if (reason != SCPE_OK)\r\n                return reason;\r\n            }\r\n        }\r\n    if ((flag == EX_E) && (val_start != limits)) {\r\n        if (highs == val_start+1) {\r\n            reason = ex_reg (ofile, val, flag, rptr, limits);\r\n            sim_switches = saved_switches;\r\n            if (reason != SCPE_OK)\r\n                return reason;\r\n            }\r\n        else {\r\n            if (val_start+1 != limits)\r\n                fprintf (ofile, \"%s[%d]-%s[%d]: same as above\\n\", rptr->name, val_start+1, rptr->name, limits);\r\n            else\r\n                fprintf (ofile, \"%s[%d]: same as above\\n\", rptr->name, val_start+1);\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat exdep_addr_loop (FILE *ofile, SCHTAB *schptr, int32 flag, const char *cptr,\r\n    t_addr low, t_addr high, DEVICE *dptr, UNIT *uptr)\r\n{\r\nt_addr i, mask;\r\nt_stat reason, dfltinc;\r\nint32 saved_switches = sim_switches;\r\n\r\nif (uptr->flags & UNIT_DIS)                             /* disabled? */\r\n    return sim_messagef (SCPE_UDIS, \"Unit disabled: %s\\n\", sim_uname (uptr));\r\nmask = (t_addr) width_mask[dptr->awidth];\r\nif ((low > mask) || (high > mask) || (low > high))\r\n    return SCPE_ARG;\r\ndfltinc =  parse_sym (\"0\", 0, uptr, sim_eval, sim_switches);\r\nif (dfltinc > 0)                                        /* parse_sym doing nums? */\r\n    dfltinc = 1 - dptr->aincr;                          /* no, use std dflt incr */\r\nfor (i = low;\r\n     ((i <= high) && (sim_is_running || !stop_cpu)); ) {/* all paths must incr!! */\r\n    reason = get_aval (i, dptr, uptr);                  /* get data */\r\n    sim_switches = saved_switches;\r\n    if (reason != SCPE_OK)                              /* return if error */\r\n        return reason;\r\n    if (schptr && !test_search (sim_eval, schptr))\r\n        i = i + (1 - dfltinc);                          /* sch fails, incr */\r\n    else {                                              /* no sch or success */\r\n        if (flag != EX_D) {                             /* ex, ie, or id? */\r\n            reason = ex_addr (ofile, flag, i, dptr, uptr, dfltinc);\r\n            sim_switches = saved_switches;\r\n            if (reason > SCPE_OK)\r\n                return reason;\r\n            }\r\n        else\r\n            reason = dfltinc;                           /* no, dflt incr */\r\n        if (flag != EX_E) {                             /* ie, id, or d? */\r\n            reason = dep_addr (flag, cptr, i, dptr, uptr, reason);\r\n            sim_switches = saved_switches;\r\n            if (reason > SCPE_OK)\r\n                return reason;\r\n            }\r\n        i = i + (1 - reason);                           /* incr */\r\n        }\r\n    }\r\nif (flag == EX_E)\r\n    ex_addr (ofile, EX_DONE, i, dptr, uptr, dfltinc);\r\nstop_cpu = FALSE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Examine register routine\r\n\r\n   Inputs:\r\n        ofile   =       output stream\r\n        val     =       current register value\r\n        flag    =       type of ex/mod command (ex, iex, idep)\r\n        rptr    =       pointer to register descriptor\r\n        idx     =       index\r\n   Outputs:\r\n        return  =       error status\r\n*/\r\n\r\nt_stat ex_reg (FILE *ofile, t_value val, int32 flag, REG *rptr, uint32 idx)\r\n{\r\nint32 rdx;\r\n\r\nif (rptr == NULL)\r\n    return SCPE_IERR;\r\nif (rptr->depth > 1)\r\n    fprintf (ofile, \"%s[%d]:\\t\", rptr->name, idx);\r\nelse\r\n    fprintf (ofile, \"%s:\\t\", rptr->name);\r\nif (!(flag & EX_E))\r\n    return SCPE_OK;\r\nsim_eval[0] = val;\r\nGET_RADIX (rdx, rptr->radix);\r\nif ((rptr->flags & REG_VMAD) && sim_vm_fprint_addr)\r\n    sim_vm_fprint_addr (ofile, sim_dflt_dev, (t_addr) val);\r\nelse {\r\n    sim_snprint_sym (sim_last_val, sizeof (sim_last_val), !(rptr->flags & REG_VMFLAGS),\r\n                     (t_addr)((rptr->flags & REG_UFMASK) | rdx),\r\n                     ((rptr->flags & REG_DOUBLE) == 0) ? sim_eval : (t_value *)rptr->loc,\r\n                     NULL, sim_switches | SIM_SW_REG, 0, rdx, rptr->width,\r\n                     rptr->flags & REG_FMT);\r\n    fprintf (ofile, \"%s\", sim_last_val);\r\n    }\r\nif (rptr->fields) {\r\n    fprintf (ofile, \"\\t\");\r\n    fprint_fields (ofile, val, val, rptr->fields);\r\n    }\r\nif (flag & EX_I)\r\n    fprintf (ofile, \"\\t\");\r\nelse\r\n    fprintf (ofile, \"\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Get register value\r\n\r\n   Inputs:\r\n        rptr    =       pointer to register descriptor\r\n        idx     =       index\r\n   Outputs:\r\n        return  =       register value\r\n\r\n   Implementation notes:\r\n\r\n    1. The stride is the size of the element spacing for arrays, which is\r\n       equivalent to the addressing increment for array subscripting.  For\r\n       scalar registers, the stride will be zero (as will the idx value), so the\r\n       access pointer is same as the specified location pointer.\r\n\r\n    2. The size of the t_value type is determined by the USE_INT64 symbol and\r\n       will be either a 32-bit or a 64-bit type.  It represents the largest\r\n       value that can be returned and so is the default if one of the smaller\r\n       sizes is not indicated.  If USE_INT64 is not defined, t_value will be\r\n       identical to uint32.  In this case, compilers are generally smart enough\r\n       to eliminate the 32-bit size test and combine the two assignments into a\r\n       single default assignment.\r\n*/\r\n\r\nt_value get_rval (REG *rptr, uint32 idx)\r\n{\r\nt_value val;\r\nvoid    *ptr;\r\n\r\nif ((rptr->depth > 1) && (rptr->flags & REG_CIRC))      /* if the register is a circular queue */\r\n    idx = (idx + rptr->qptr) % rptr->depth;             /*   then adjust the index relative to the queue (wrapped as needed) */\r\n\r\nptr = ((char *) rptr->loc) + (idx * rptr->stride);      /* point at the starting byte of the item */\r\n\r\nif (rptr->size == sizeof (uint8))                       /* get the value */\r\n    val = *((uint8 *) ptr);                             /*   using a size */\r\n                                                        /*     appropriate to */\r\nelse if (rptr->size == sizeof (uint16))                 /*       the size of */\r\n    val = *((uint16 *) ptr);                            /*         the underlying type */\r\n\r\nelse if (rptr->size == sizeof (uint32))\r\n    val = *((uint32 *) ptr);\r\n\r\nelse                                                    /* if the element size is non-standard */\r\n    val = *((t_value *) ptr);                           /*   then access using the largest size permitted */\r\n\r\nval = (val >> rptr->offset) & width_mask[rptr->width];  /* shift and mask to obtain the final value */\r\n\r\nreturn val;\r\n}\r\n\r\n/* Deposit register routine\r\n\r\n   Inputs:\r\n        flag    =       type of deposit (normal/interactive)\r\n        cptr    =       pointer to input string\r\n        rptr    =       pointer to register descriptor\r\n        idx     =       index\r\n   Outputs:\r\n        return  =       error status\r\n*/\r\n\r\nt_stat dep_reg (int32 flag, CONST char *cptr, REG *rptr, uint32 idx)\r\n{\r\nt_stat r;\r\nt_value val, max;\r\nint32 rdx;\r\nCONST char *tptr;\r\nchar gbuf[CBUFSIZE];\r\n\r\nif ((cptr == NULL) || (rptr == NULL))\r\n    return SCPE_IERR;\r\nif (rptr->flags & REG_RO)\r\n    return SCPE_RO;\r\nif (flag & EX_I) {\r\n    cptr = read_line (gbuf, sizeof(gbuf), stdin);\r\n    if (sim_log)\r\n        fprintf (sim_log, \"%s\\n\", cptr? cptr: \"\");      /* fix clang error */\r\n    if (cptr == NULL)                                   /* force exit */\r\n        return 1;\r\n    if (*cptr == 0)                                     /* success */\r\n        return SCPE_OK;\r\n    }\r\nif (rptr->maxval > 0)                                   /* if a maximum value is defined */\r\n    max = rptr->maxval;                                 /*   then use it */\r\nelse                                                    /* otherwise */\r\n    max = width_mask[rptr->width];                      /*   the mask defines the maximum value */\r\nGET_RADIX (rdx, rptr->radix);\r\nif (strcmp (cptr, \"$\") == 0)\r\n    cptr = sim_last_val;\r\nif ((rptr->flags & REG_VMAD) && sim_vm_parse_addr) {    /* address form? */\r\n    val = sim_vm_parse_addr (sim_dflt_dev, cptr, &tptr);\r\n    if ((tptr == cptr) || (*tptr != 0) || (val > max))\r\n        return SCPE_ARG;\r\n    }\r\nelse\r\n    if (!(rptr->flags & REG_VMFLAGS) ||                 /* dont use sym? */\r\n        (parse_sym ((CONST char *)cptr, (rptr->flags & REG_UFMASK) | rdx, NULL,\r\n                    &val, sim_switches | SIM_SW_REG) > SCPE_OK)) {\r\n    val = get_uint (cptr, rdx, max, &r);\r\n    if (r != SCPE_OK)\r\n        return SCPE_ARG;\r\n    }\r\nif ((rptr->flags & REG_NZ) && (val == 0))\r\n    return SCPE_ARG;\r\nput_rval (rptr, idx, val);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Put register value\r\n\r\n   Inputs:\r\n        rptr    =       pointer to register descriptor\r\n        idx     =       index\r\n        val     =       new value\r\n        mask    =       mask\r\n   Outputs:\r\n        none\r\n\r\n\r\n   Implementation notes:\r\n\r\n    1. mask and val are of type t_value, so an explicit cast is not needed for\r\n       that type of assignment.\r\n\r\n    2. See the notes for the get_rval routine for additional information\r\n       regarding the stride calculation and the t_value default assignment,\r\n*/\r\n\r\nvoid put_rval_pcchk (REG *rptr, uint32 idx, t_value val, t_bool pc_chk)\r\n{\r\nt_value mask;\r\nvoid    *ptr;\r\nt_value prev_val = 0;\r\n\r\nif ((!(sim_switches & SWMASK ('Z'))) &&\r\n    (rptr->flags & REG_DEPOSIT) && sim_vm_reg_update)\r\n    prev_val = get_rval (rptr, idx);\r\n\r\nif (pc_chk && (rptr == sim_PC))                         /* if the PC is changing */\r\n    sim_brk_npc (0);                                    /*   then notify the breakpoint package */\r\n\r\nmask = ~(width_mask [rptr->width] << rptr->offset);     /* set up a mask to produce a hole in the element */\r\nval  = val << rptr->offset;                             /*   and position the new value to fit the hole */\r\n\r\nif ((rptr->depth > 1) && (rptr->flags & REG_CIRC))      /* if the register is a circular queue */\r\n    idx = (idx + rptr->qptr) % rptr->depth;             /*   then adjust the index relative to the queue (wrapped as needed) */\r\n\r\nptr = ((char *) rptr->loc) + (idx * rptr->stride);      /* point at the starting byte of the item */\r\n\r\nif (rptr->size == sizeof (uint8))                       /* store the value */\r\n    *((uint8 *) ptr) =                                  /*   using a size */\r\n       (uint8) ((*((uint8 *) ptr) & mask) | val);        /*     appropriate to */\r\n                                                        /*       the size of */\r\nelse\r\n    if (rptr->size == sizeof (uint16))                  /*         the underlying type */\r\n        *((uint16 *) ptr) =\r\n          (uint16) ((*((uint16 *) ptr) & mask) | val);\r\n\r\n    else\r\n        if (rptr->size == sizeof (uint32))\r\n            *((uint32 *) ptr) =\r\n              (uint32) ((*((uint32 *) ptr) & mask) | val);\r\n\r\n        else                                            /* if the element size is non-standard */\r\n            *((t_value *) ptr) =                        /*   then access using the largest size permitted */\r\n              (*((t_value *) ptr) & mask) | val;\r\n\r\nif ((!(sim_switches & SWMASK ('Z'))) &&\r\n    (rptr->flags & REG_DEPOSIT) && sim_vm_reg_update)\r\n    sim_vm_reg_update (rptr, idx, prev_val, val);\r\n}\r\n\r\nvoid put_rval (REG *rptr, uint32 idx, t_value val)\r\n{\r\nput_rval_pcchk (rptr, idx, val, TRUE);\r\n}\r\n\r\n\r\n/* Examine address routine\r\n\r\n   Inputs: (sim_eval is an implicit argument)\r\n        ofile   =       output stream\r\n        flag    =       type of ex/mod command (ex, iex, idep)\r\n        addr    =       address to examine\r\n        dptr    =       pointer to device\r\n        uptr    =       pointer to unit\r\n        dfltinc =       default increment\r\n   Outputs:\r\n        return  =       if > 0, error status\r\n                        if <= 0,-number of extra addr units retired\r\n*/\r\n\r\nt_stat ex_addr (FILE *ofile, int32 flag, t_addr addr, DEVICE *dptr, UNIT *uptr, int32 dfltinc)\r\n{\r\nt_stat reason;\r\nint32 rdx;\r\nchar sim_current_last_val[sizeof(sim_last_val)];\r\nstatic int32 same = -1;\r\nstatic t_bool same_done = TRUE;\r\nstatic t_addr same_start_addr;\r\n\r\nif (flag == EX_DONE) {\r\n    if (same >= 0) {\r\n        if (sim_vm_fprint_addr)\r\n            sim_vm_fprint_addr (ofile, dptr, same_start_addr);\r\n        else\r\n            fprint_val (ofile, same_start_addr, dptr->aradix, dptr->awidth, PV_LEFT);\r\n        if (same == 0)\r\n            fprintf (ofile, \":\\t%s\\n\", sim_last_val);\r\n        else {\r\n            fprintf (ofile, \": thru \");\r\n            if (sim_vm_fprint_addr)\r\n                sim_vm_fprint_addr (ofile, dptr, addr - (1 - dfltinc));\r\n            else\r\n                fprint_val (ofile, addr - (1 - dfltinc), dptr->aradix, dptr->awidth, PV_LEFT);\r\n            fprintf (ofile, \": same as above.\\n\");\r\n            }\r\n        same = -1;\r\n        }\r\n    same_done = TRUE;\r\n    return SCPE_OK;\r\n    }\r\nif ((flag == EX_E) && same_done) {\r\n    strlcpy (sim_last_val, \"\", sizeof (sim_last_val));\r\n    same_done = FALSE;\r\n    }\r\nGET_RADIX (rdx, dptr->dradix);\r\nreason = sim_snprint_sym (sim_current_last_val, sizeof (sim_current_last_val), FALSE, addr, sim_eval, uptr, sim_switches, dfltinc, rdx, dptr->dwidth, PV_RZRO);\r\nif ((flag == EX_E) && (strcmp (sim_last_val, sim_current_last_val) == 0)) {\r\n    if (same < 0)\r\n        same_start_addr = addr;\r\n    ++same;\r\n    return reason;\r\n    }\r\nif (same >= 0) {\r\n    if (sim_vm_fprint_addr)\r\n        sim_vm_fprint_addr (ofile, dptr, same_start_addr);\r\n    else\r\n        fprint_val (ofile, same_start_addr, dptr->aradix, dptr->awidth, PV_LEFT);\r\n    if (same == 0)\r\n        fprintf (ofile, \":\\t%s\\n\", sim_last_val);\r\n    else {\r\n        fprintf (ofile, \": thru \");\r\n        if (sim_vm_fprint_addr)\r\n            sim_vm_fprint_addr (ofile, dptr, addr - (1 - dfltinc));\r\n        else\r\n            fprint_val (ofile, addr - (1 - dfltinc), dptr->aradix, dptr->awidth, PV_LEFT);\r\n        fprintf (ofile, \": same as above.\\n\");\r\n        }\r\n    same = -1;\r\n    }\r\nsame_start_addr = addr;\r\nif (sim_vm_fprint_addr)\r\n    sim_vm_fprint_addr (ofile, dptr, addr);\r\nelse fprint_val (ofile, addr, dptr->aradix, dptr->awidth, PV_LEFT);\r\nfprintf (ofile, \":\\t\");\r\nif (!(flag & EX_E))\r\n    return dfltinc;\r\n\r\nfprintf (ofile, \"%s\", sim_current_last_val);\r\nstrlcpy (sim_last_val, sim_current_last_val, sizeof (sim_last_val));\r\nif (flag & EX_I)\r\n    fprintf (ofile, \"\\t\");\r\nelse\r\n    fprintf (ofile, \"\\n\");\r\nreturn reason;\r\n}\r\n\r\n/* Get address routine\r\n\r\n   Inputs:\r\n        flag    =       type of ex/mod command (ex, iex, idep)\r\n        addr    =       address to examine\r\n        dptr    =       pointer to device\r\n        uptr    =       pointer to unit\r\n   Outputs: (sim_eval is an implicit output)\r\n        return  =       error status\r\n*/\r\n\r\nt_stat get_aval (t_addr addr, DEVICE *dptr, UNIT *uptr)\r\n{\r\nint32 i;\r\nt_value mask;\r\nt_addr j, loc;\r\nsize_t sz;\r\nt_stat reason = SCPE_OK;\r\n\r\nif ((dptr == NULL) || (uptr == NULL))\r\n    return SCPE_IERR;\r\nmask = width_mask[dptr->dwidth];\r\nfor (i = 0; i < sim_emax; i++)\r\n    sim_eval[i] = 0;\r\nfor (i = 0, j = addr; i < sim_emax; i++, j = j + dptr->aincr) {\r\n    if (dptr->examine != NULL) {\r\n        reason = dptr->examine (&sim_eval[i], j, uptr, sim_switches);\r\n        if (reason != SCPE_OK)\r\n            break;\r\n        }\r\n    else {\r\n        if (!(uptr->flags & UNIT_ATT))\r\n            return SCPE_UNATT;\r\n        if (((uptr->flags & UNIT_BUF) == 0) &&\r\n             ((uptr->dynflags & UNIT_NO_FIO) ||\r\n              (uptr->fileref == NULL) ||\r\n              (sim_can_seek (uptr->fileref) == FALSE)))\r\n              return sim_messagef (SCPE_NOFNC, \"Can't seek on %s - %s\\n\", sim_uname (uptr), uptr->filename ? uptr->filename : \"\");\r\n        if ((uptr->flags & UNIT_FIX) && (j >= uptr->capac)) {\r\n            reason = SCPE_NXM;\r\n            break;\r\n            }\r\n        sz = SZ_D (dptr);\r\n        loc = j / dptr->aincr;\r\n        if (uptr->flags & UNIT_BUF) {\r\n            SZ_LOAD (sz, sim_eval[i], uptr->filebuf, loc);\r\n            }\r\n        else {\r\n            if (sim_fseek (uptr->fileref, (t_addr)(sz * loc), SEEK_SET)) {\r\n                clearerr (uptr->fileref);\r\n                reason = SCPE_IOERR;\r\n                break;\r\n                }\r\n            (void)sim_fread (&sim_eval[i], sz, 1, uptr->fileref);\r\n            if ((feof (uptr->fileref)) &&\r\n               !(uptr->flags & UNIT_FIX)) {\r\n                reason = SCPE_EOF;\r\n                break;\r\n                }\r\n            else if (ferror (uptr->fileref)) {\r\n                clearerr (uptr->fileref);\r\n                reason = SCPE_IOERR;\r\n                break;\r\n                }\r\n            }\r\n        }\r\n    sim_eval[i] = sim_eval[i] & mask;\r\n    }\r\nif ((reason != SCPE_OK) && (i == 0))\r\n    return reason;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Deposit address routine\r\n\r\n   Inputs:\r\n        flag    =       type of deposit (normal/interactive)\r\n        cptr    =       pointer to input string\r\n        addr    =       address to examine\r\n        dptr    =       pointer to device\r\n        uptr    =       pointer to unit\r\n        dfltinc =       value to return on cr input\r\n   Outputs:\r\n        return  =       if > 0, error status\r\n                        if <= 0, -number of extra address units retired\r\n*/\r\n\r\nt_stat dep_addr (int32 flag, const char *cptr, t_addr addr, DEVICE *dptr,\r\n    UNIT *uptr, int32 dfltinc)\r\n{\r\nint32 i, count, rdx;\r\nt_addr j, loc;\r\nt_stat r, reason;\r\nt_value mask;\r\nsize_t sz;\r\nchar gbuf[CBUFSIZE];\r\n\r\nif (dptr == NULL)\r\n    return SCPE_IERR;\r\nif (flag & EX_I) {\r\n    cptr = read_line (gbuf, sizeof(gbuf), stdin);\r\n    if (sim_log)\r\n        fprintf (sim_log, \"%s\\n\", cptr? cptr: \"\");\r\n    if (cptr == NULL)                                   /* force exit */\r\n        return 1;\r\n    if (*cptr == 0)                                     /* success */\r\n        return dfltinc;\r\n    }\r\nif (uptr->flags & UNIT_RO)                              /* read only? */\r\n    return sim_messagef (SCPE_RO, \"%s is read only.\\n\"\r\n                                  \"%sse a writable device to change %s\\n\",\r\n                                  sim_uname (uptr), (uptr->flags & UNIT_ROABLE) ? \"Attach Read/Write or u\" : \"U\",\r\n                                  uptr->filename ? sim_attach_name (uptr) : \"it\");\r\nmask = width_mask[dptr->dwidth];\r\n\r\nGET_RADIX (rdx, dptr->dradix);\r\nif (strcmp (cptr, \"$\") == 0)\r\n    cptr = sim_last_val;\r\nif ((reason = parse_sym ((CONST char *)cptr, addr, uptr, sim_eval, sim_switches)) > 0) {\r\n    sim_eval[0] = get_uint (cptr, rdx, mask, &reason);\r\n    if (reason != SCPE_OK)\r\n        return reason;\r\n    reason = dfltinc;\r\n    }\r\ncount = (1 - reason + (dptr->aincr - 1)) / dptr->aincr;\r\n\r\nfor (i = 0, j = addr; i < count; i++, j = j + dptr->aincr) {\r\n    sim_eval[i] = sim_eval[i] & mask;\r\n    if (dptr->deposit != NULL) {\r\n        r = dptr->deposit (sim_eval[i], j, uptr, sim_switches);\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        }\r\n    else {\r\n        if (!(uptr->flags & UNIT_ATT))\r\n            return SCPE_UNATT;\r\n        if ((uptr->dynflags & UNIT_NO_FIO) ||\r\n            (sim_can_seek (uptr->fileref) == FALSE))\r\n            return SCPE_NOFNC;\r\n        if ((uptr->flags & UNIT_FIX) && (j >= uptr->capac))\r\n            return SCPE_NXM;\r\n        sz = SZ_D (dptr);\r\n        loc = j / dptr->aincr;\r\n        if (uptr->flags & UNIT_BUF) {\r\n            SZ_STORE (sz, sim_eval[i], uptr->filebuf, loc);\r\n            if (loc >= uptr->hwmark)\r\n                uptr->hwmark = (uint32) loc + 1;\r\n            }\r\n        else {\r\n            if (sim_fseek (uptr->fileref, (t_addr)(sz * loc), SEEK_SET)) {\r\n                clearerr (uptr->fileref);\r\n                return SCPE_IOERR;\r\n                }\r\n            sim_fwrite (&sim_eval[i], sz, 1, uptr->fileref);\r\n            if (ferror (uptr->fileref)) {\r\n                clearerr (uptr->fileref);\r\n                return SCPE_IOERR;\r\n                }\r\n            }\r\n        }\r\n    }\r\nreturn reason;\r\n}\r\n\r\n/* Evaluate command */\r\n\r\nt_stat eval_cmd (int32 flg, CONST char *cptr)\r\n{\r\nDEVICE *dptr = sim_dflt_dev;\r\nint32 i, rdx, a, lim;\r\nt_stat r;\r\n\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nGET_RADIX (rdx, dptr->dradix);\r\nfor (i = 0; i < sim_emax; i++)\r\n    sim_eval[i] = 0;\r\nif (*cptr == 0)\r\n    return SCPE_2FARG;\r\nif ((r = parse_sym ((CONST char *)cptr, 0, dptr->units, sim_eval, sim_switches)) > 0) {\r\n    sim_eval[0] = get_uint (cptr, rdx, width_mask[dptr->dwidth], &r);\r\n    if (r != SCPE_OK)\r\n        return sim_messagef (r, \"'%s' - Can't be parsed as an instruction or data\\n\", cptr);\r\n    }\r\nlim = 1 - r;\r\nfor (i = a = 0; a < lim; ) {\r\n    sim_printf (\"%d:\\t\", a);\r\n    r = sim_fprint_sym (stdout, FALSE, a, &sim_eval[i], dptr->units, sim_switches, SCPE_OK, rdx, dptr->dwidth, PV_RZRO);\r\n    if (sim_log && (!sim_oline))\r\n        r = sim_fprint_sym (sim_log, FALSE, a, &sim_eval[i], dptr->units, sim_switches, SCPE_OK, rdx, dptr->dwidth, PV_RZRO);\r\n    sim_printf (\"\\n\");\r\n    if (r < 0)\r\n        a = a + 1 - r;\r\n    else a = a + dptr->aincr;\r\n    i = a / dptr->aincr;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* String processing routines\r\n\r\n   read_line            read line\r\n\r\n   Inputs:\r\n        cptr    =       pointer to buffer\r\n        size    =       maximum size\r\n        stream  =       pointer to input stream\r\n   Outputs:\r\n        optr    =       pointer to first non-blank character\r\n                        NULL if EOF\r\n*/\r\n\r\nchar *read_line (char *cptr, int32 size, FILE *stream)\r\n{\r\nreturn read_line_p (NULL, cptr, size, stream);\r\n}\r\n\r\n/* read_line_p          read line with prompt\r\n\r\n   Inputs:\r\n        prompt  =       pointer to prompt string\r\n        cptr    =       pointer to buffer\r\n        size    =       maximum size\r\n        stream  =       pointer to input stream\r\n   Outputs:\r\n        optr    =       pointer to first non-blank character\r\n                        NULL if EOF\r\n*/\r\n\r\n#if defined (HAVE_LIBEDIT)\r\n#include <editline/readline.h>\r\n#endif\r\n#if defined(_WIN32)\r\n#define EDIT_DEFAULT_LIB \"edit.\"\r\n#else /* !defined(_WIN32) */\r\n#define EDIT_DEFAULT_LIB \"libedit.\"\r\n#endif /* defined(_WIN32) */\r\n\r\nchar *read_line_p (const char *prompt, char *cptr, int32 size, FILE *stream)\r\n{\r\nstatic int initialized = 0;\r\ntypedef char *(*readline_func)(const char *);\r\nstatic readline_func p_readline = NULL;\r\ntypedef void (*add_history_func)(const char *);\r\nstatic add_history_func p_add_history = NULL;\r\ntypedef void (*free_line_func)(void *);\r\nstatic free_line_func p_free_line = NULL;\r\nchar *tptr;\r\n\r\nif (prompt && (!initialized)) {\r\n    initialized = 1;\r\n\r\n#if defined(HAVE_LIBEDIT)\r\n    p_readline = (readline_func)&readline;\r\n    p_add_history = (add_history_func)&add_history;\r\n    sim_editline_version = RL_READLINE_VERSION;\r\n#if !defined(RL_READLINE_VERSION)\r\n    p_free_line = (free_line_func)&rl_free;\r\n#else\r\n    p_free_line = (free_line_func)&free;\r\n#endif\r\n#else /* !defined(HAVE_LIBEDIT) */\r\n#if defined(SIM_DLOPEN_EXTENSION)\r\n    if (!p_readline) {   /* libedit not available at compile time, try OS shared object? */\r\n        void *handle;\r\n\r\n        handle = dlopen(EDIT_DEFAULT_LIB __STR(SIM_DLOPEN_EXTENSION), RTLD_NOW|RTLD_GLOBAL);\r\n        if (!handle)\r\n            handle = dlopen(EDIT_DEFAULT_LIB __STR(SIM_DLOPEN_EXTENSION) \".2\", RTLD_NOW|RTLD_GLOBAL);\r\n        if (handle) {\r\n            p_readline = (readline_func)((size_t)dlsym(handle, \"readline\"));\r\n            p_add_history = (add_history_func)((size_t)dlsym(handle, \"add_history\"));\r\n            p_free_line = (free_line_func)((size_t)dlsym(handle, \"rl_free\"));\r\n            if (p_free_line == NULL)\r\n                p_free_line = (free_line_func)&free;\r\n            sim_editline_version = *((int *)dlsym(handle, \"rl_readline_version\"));\r\n            }\r\n        }\r\n#endif /* defined(SIM_DLOPEN_EXTENSION) */\r\n#endif /* defined(HAVE_LIBEDIT) */\r\n    }\r\n\r\nif (prompt) {                                           /* interactive? */\r\n    if (p_readline) {\r\n        char *tmpc = p_readline (prompt);               /* get cmd line */\r\n        if (tmpc == NULL)                               /* bad result? */\r\n            cptr = NULL;\r\n        else {\r\n            strlcpy (cptr, tmpc, size);                 /* copy result */\r\n            p_free_line (tmpc) ;                        /* free temp */\r\n            }\r\n        }\r\n    else {\r\n        printf (\"%s\", prompt);                          /* display prompt */\r\n        fflush (stdout);\r\n        cptr = fgets (cptr, size, stream);              /* get cmd line */\r\n        }\r\n    }\r\nelse\r\n    cptr = fgets (cptr, size, stream);                  /* get cmd line */\r\n\r\nif (cptr == NULL) {\r\n    clearerr (stream);                                  /* clear error */\r\n    return NULL;                                        /* ignore EOF */\r\n    }\r\nfor (tptr = cptr; tptr < (cptr + size); tptr++) {       /* remove cr or nl */\r\n    if ((*tptr == '\\n') || (*tptr == '\\r') ||\r\n        (tptr == (cptr + size - 1))) {                  /* str max length? */\r\n        *tptr = 0;                                      /* terminate */\r\n        break;\r\n        }\r\n    }\r\nif (0 == memcmp (cptr, \"\\xEF\\xBB\\xBF\", 3))              /* Skip/ignore UTF8_BOM */\r\n    memmove (cptr, cptr + 3, strlen (cptr + 3));\r\nwhile (sim_isspace (*cptr))                             /* trim leading spc */\r\n    cptr++;\r\nsim_trim_endspc (cptr);                                 /* trim trailing spc */\r\nif ((*cptr == ';') || (*cptr == '#')) {                 /* ignore comment */\r\n    if (sim_do_echo)                                    /* echo comments if -v */\r\n        sim_printf(\"%s> %s\\n\", do_position(), cptr);\r\n    *cptr = 0;\r\n    }\r\n\r\nif (prompt && p_add_history && *cptr)                   /* Save non blank lines in history */\r\n    p_add_history (cptr);\r\n\r\nreturn cptr;\r\n}\r\n\r\n/* get_glyph            get next glyph (force upper case)\r\n   get_glyph_sp         get next glyph (only delimited by the match char (no whitespace))\r\n   get_glyph_nc         get next glyph (no conversion)\r\n   get_glyph_quoted     get next glyph (potentially enclosed in quotes, no conversion)\r\n   get_glyph_cmd        get command glyph (force upper case, extract leading !)\r\n   get_glyph_gen        get next glyph (general case)\r\n\r\n   Inputs:\r\n        iptr        =   pointer to input string\r\n        optr        =   pointer to output string\r\n        mchar       =   optional end of glyph character (0 means whitespace ends glyph)\r\n        ws_match    =   white space also ends glyph (when mchar isn't 0)\r\n        uc          =   TRUE for convert to upper case (_gen only)\r\n        quote       =   TRUE to allow quote enclosing values (_gen only)\r\n        escape_char =   optional escape character within quoted strings (_gen only)\r\n\r\n   Outputs\r\n        result      =   pointer to next character in input string\r\n*/\r\n\r\nstatic const char *get_glyph_gen (const char *iptr, char *optr, char mchar, t_bool ws_match, t_bool uc, t_bool quote, char escape_char)\r\n{\r\nt_bool quoting = FALSE;\r\nt_bool escaping = FALSE;\r\nt_bool got_quoted = FALSE;\r\nchar quote_char = 0;\r\nt_bool match_ws = (mchar == 0) || ws_match;\r\n\r\nwhile ((*iptr != 0) && (!got_quoted) &&\r\n       ((quote && quoting) || \r\n        ((!match_ws || (sim_isspace (*iptr) == 0)) && \r\n         (*iptr != mchar)))) {\r\n    if (quote) {\r\n        if (quoting) {\r\n            if (!escaping) {\r\n                if (*iptr == escape_char)\r\n                    escaping = TRUE;\r\n                else\r\n                    if (*iptr == quote_char) {\r\n                        quoting = FALSE;\r\n                        got_quoted = TRUE;\r\n                        }\r\n                }\r\n            else\r\n                escaping = FALSE;\r\n            }\r\n        else {\r\n            if ((*iptr == '\"') || (*iptr == '\\'')) {\r\n                quoting = TRUE;\r\n                quote_char = *iptr;\r\n                }\r\n            }\r\n        }\r\n    if (sim_islower (*iptr) && uc)\r\n        *optr = (char)sim_toupper (*iptr);\r\n    else\r\n        *optr = *iptr;\r\n    iptr++; optr++;\r\n    }\r\n*optr = 0;                                  /* terminate result string */\r\nif (((mchar != 0) && (*iptr == mchar)) ||   /* skip input terminator */\r\n    (match_ws && sim_isspace (*iptr)))\r\n    iptr++;\r\nwhile ((*iptr != 0) &&                      /* more input? */\r\n       ((match_ws && sim_isspace (*iptr)) ||\r\n        ((mchar != 0) && (*iptr == mchar))))\r\n    iptr++;                                 /* skip additional input terminators */\r\nreturn iptr;\r\n}\r\n\r\nCONST char *get_glyph (const char *iptr, char *optr, char mchar)\r\n{\r\nreturn (CONST char *)get_glyph_gen (iptr, optr, mchar, TRUE, TRUE, FALSE, 0);\r\n}\r\n\r\nCONST char *get_glyph_sp (const char *iptr, char *optr, char mchar)\r\n{\r\nreturn (CONST char *)get_glyph_gen (iptr, optr, mchar, FALSE, TRUE, FALSE, 0);\r\n}\r\n\r\nCONST char *get_glyph_nc (const char *iptr, char *optr, char mchar)\r\n{\r\nreturn (CONST char *)get_glyph_gen (iptr, optr, mchar, TRUE, FALSE, FALSE, 0);\r\n}\r\n\r\nCONST char *get_glyph_quoted (const char *iptr, char *optr, char mchar)\r\n{\r\nreturn (CONST char *)get_glyph_gen (iptr, optr, mchar, TRUE, FALSE, TRUE, '\\\\');\r\n}\r\n\r\nCONST char *get_glyph_cmd (const char *iptr, char *optr)\r\n{\r\n/* Tolerate \"!subprocess\" vs. requiring \"! subprocess\" */\r\nif ((iptr[0] == '!') && (!sim_isspace(iptr[1]))) {\r\n    strcpy (optr, \"!\");                     /* return ! as command glyph */\r\n    return (CONST char *)(iptr + 1);        /* and skip over the leading ! */\r\n    }\r\nreturn (CONST char *)get_glyph_gen (iptr, optr, 0, TRUE, TRUE, FALSE, 0);\r\n}\r\n\r\n/* get_yn               yes/no question\r\n\r\n   Inputs:\r\n        ques    =       pointer to question\r\n        deflt   =       default answer\r\n   Outputs:\r\n        result  =       true if yes, false if no\r\n*/\r\n\r\nt_bool get_yn (const char *ques, t_bool deflt)\r\n{\r\nchar cbuf[CBUFSIZE];\r\nconst char *cptr;\r\n\r\nif (sim_switches & SWMASK ('Y'))\r\n    return TRUE;\r\nif (sim_switches & SWMASK ('N'))\r\n    return FALSE;\r\nif (sim_rem_cmd_active_line != -1)\r\n    return deflt;\r\ncptr = read_line_p (ques, cbuf, sizeof(cbuf), stdin);\r\nif (cptr == NULL)\r\n    printf (\"\\n\");\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return deflt;\r\nif ((*cptr == 'Y') || (*cptr == 'y'))\r\n    return TRUE;\r\nreturn FALSE;\r\n}\r\n\r\n/* get_uint             unsigned number\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n        radix   =       input radix\r\n        max     =       maximum acceptable value\r\n        *status =       pointer to error status\r\n   Outputs:\r\n        val     =       value\r\n*/\r\n\r\nt_value get_uint (const char *cptr, uint32 radix, t_value max, t_stat *status)\r\n{\r\nt_value val;\r\nuint32 factor = 1;\r\nCONST char *tptr;\r\n\r\n*status = SCPE_OK;\r\nval = strtotv ((CONST char *)cptr, &tptr, radix);\r\nif ((cptr == tptr) || (val > max))\r\n    *status = SCPE_ARG;\r\nelse {\r\n    while (sim_isspace (*tptr)) tptr++;\r\n    if (sim_toupper (*tptr) == 'K') {\r\n        factor = 1000;\r\n        ++tptr;\r\n        }\r\n    else {\r\n        if (sim_toupper (*tptr) == 'M') {\r\n            factor = 1000000;\r\n            ++tptr;\r\n            }\r\n        }\r\n    if ((*tptr != 0) || (val > (max / factor)))\r\n        *status = SCPE_ARG;\r\n    val *= factor;\r\n    }\r\nreturn val;\r\n}\r\n\r\n/* get_range            range specification\r\n\r\n   Inputs:\r\n        dptr    =       pointer to device (NULL if none)\r\n        cptr    =       pointer to input string\r\n        *lo     =       pointer to low result\r\n        *hi     =       pointer to high result\r\n        rdx     =       radix\r\n        max     =       default high value\r\n        term    =       terminating character, 0 if none\r\n   Outputs:\r\n        tptr    =       input pointer after processing\r\n                        NULL if error\r\n*/\r\n\r\nCONST char *get_range (DEVICE *dptr, CONST char *cptr, t_addr *lo, t_addr *hi,\r\n    uint32 rdx, t_addr max, char term)\r\n{\r\nCONST char *tptr, *ntptr;\r\n\r\nif (max && strncmp (cptr, \"ALL\", strlen (\"ALL\")) == 0) {/* ALL? */\r\n    tptr = cptr + strlen (\"ALL\");\r\n    *lo = 0;\r\n    *hi = max;\r\n    }\r\nelse {\r\n    if ((strncmp (cptr, \".\", strlen (\".\")) == 0) &&     /* .? */\r\n        ((cptr[1] == '\\0') ||\r\n         (cptr[1] == '-')  ||\r\n         (cptr[1] == ':')  ||\r\n         (cptr[1] == '/'))) {\r\n        tptr = cptr + strlen (\".\");\r\n        *lo = *hi = sim_last_addr;\r\n        }\r\n    else {\r\n        ntptr = cptr + 1;\r\n        if (strncmp (cptr, \"$\", strlen (\"$\")) == 0)     /* $? */\r\n            cptr = sim_last_val;\r\n        if (dptr && sim_vm_parse_addr)                  /* get low */\r\n            *lo = sim_vm_parse_addr (dptr, cptr, &tptr);\r\n        else\r\n            *lo = (t_addr) strtotv (cptr, &tptr, rdx);\r\n        if (cptr == tptr)                               /* error? */\r\n                return NULL;\r\n        if (cptr == sim_last_val)\r\n            tptr = ntptr;\r\n        }\r\n    if ((*tptr == '-') || (*tptr == ':')) {             /* range? */\r\n        cptr = tptr + 1;\r\n        ntptr = cptr + 1;\r\n        if (strncmp (cptr, \"$\", strlen (\"$\")) == 0)     /* $? */\r\n            cptr = sim_last_val;\r\n        if (dptr && sim_vm_parse_addr)                  /* get high */\r\n            *hi = sim_vm_parse_addr (dptr, cptr, &tptr);\r\n        else\r\n            *hi = (t_addr) strtotv (cptr, &tptr, rdx);\r\n        if (cptr == tptr)\r\n            return NULL;\r\n        if (*lo > *hi)\r\n            return NULL;\r\n        if (cptr == sim_last_val)\r\n            tptr = ntptr;\r\n        }\r\n    else {\r\n        if (*tptr == '/') {                             /* relative? */\r\n            cptr = tptr + 1;\r\n            *hi = (t_addr) strtotv (cptr, &tptr, rdx);  /* get high */\r\n            if ((cptr == tptr) || (*hi == 0))\r\n                return NULL;\r\n            *hi = *lo + *hi - 1;\r\n            }\r\n        else\r\n            *hi = *lo;\r\n        }\r\n    }\r\nsim_last_addr = *hi;\r\nif (term && (*tptr++ != term))\r\n    return NULL;\r\nreturn tptr;\r\n}\r\n\r\n/* sim_decode_quoted_string\r\n\r\n   Inputs:\r\n        iptr        =   pointer to input string\r\n        optr        =   pointer to output buffer\r\n                        the output buffer must be allocated by the caller\r\n                        and to avoid overrun it must be at least as big\r\n                        as the input string.\r\n\r\n   Outputs\r\n        result      =   status of decode SCPE_OK when good, SCPE_ARG otherwise\r\n        osize       =   size of the data in the optr buffer\r\n\r\n   The input string must be quoted.  Quotes may be either single or\r\n   double but the opening and closing quote characters must match.\r\n   Within quotes C style character escapes are allowed.\r\n\r\n   The following character escapes are explicitly supported:\r\n        \\r  ASCII Carriage Return character (Decimal value 13)\r\n        \\n  ASCII Linefeed character (Decimal value 10)\r\n        \\f  ASCII Formfeed character (Decimal value 12)\r\n        \\t  ASCII Horizontal Tab character (Decimal value 9)\r\n        \\v  ASCII Vertical Tab character (Decimal value 11)\r\n        \\b  ASCII Backspace character (Decimal value 8)\r\n        \\\\  ASCII Backslash character (Decimal value 92)\r\n        \\'  ASCII Single Quote character (Decimal value 39)\r\n        \\\"  ASCII Double Quote character (Decimal value 34)\r\n        \\?  ASCII Question Mark character (Decimal value 63)\r\n        \\e  ASCII Escape character (Decimal value 27)\r\n     as well as octal character values of the form:\r\n        \\n{n{n}} where each n is an octal digit (0-7)\r\n     and hex character values of the form:\r\n        \\xh{h} where each h is a hex digit (0-9A-Fa-f)\r\n\r\n*/\r\n\r\nt_stat sim_decode_quoted_string (const char *iptr, uint8 *optr, uint32 *osize)\r\n{\r\nchar quote_char;\r\nuint8 *ostart = optr;\r\n\r\n*osize = 0;\r\nif ((strlen(iptr) == 1) ||\r\n    (iptr[0] != iptr[strlen(iptr)-1]) ||\r\n    ((iptr[strlen(iptr)-1] != '\"') && (iptr[strlen(iptr)-1] != '\\'')))\r\n    return sim_messagef (SCPE_ARG, \"String must be quote delimited: %s\\n\", iptr);\r\nquote_char = *iptr++;           /* Save quote character */\r\nwhile (iptr[1]) {               /* Skip trailing quote */\r\n    if (*iptr != '\\\\') {\r\n        if (*iptr == quote_char)\r\n            return sim_messagef (SCPE_ARG, \"Imbedded quotes must be escaped: %s\\n\", iptr);\r\n        *(optr++) = (uint8)(*(iptr++));\r\n        continue;\r\n        }\r\n    ++iptr; /* Skip backslash */\r\n    switch (*iptr) {\r\n        case 'r':   /* ASCII Carriage Return character (Decimal value 13) */\r\n            *(optr++) = 13; ++iptr;\r\n            break;\r\n        case 'n':   /* ASCII Linefeed character (Decimal value 10) */\r\n            *(optr++) = 10; ++iptr;\r\n            break;\r\n        case 'f':   /* ASCII Formfeed character (Decimal value 12) */\r\n            *(optr++) = 12; ++iptr;\r\n            break;\r\n        case 't':   /* ASCII Horizontal Tab character (Decimal value 9) */\r\n            *(optr++) = 9; ++iptr;\r\n            break;\r\n        case 'v':   /* ASCII Vertical Tab character (Decimal value 11) */\r\n            *(optr++) = 11; ++iptr;\r\n            break;\r\n        case 'b':   /* ASCII Backspace character (Decimal value 8) */\r\n            *(optr++) = 8; ++iptr;\r\n            break;\r\n        case '\\\\':   /* ASCII Backslash character (Decimal value 92) */\r\n            *(optr++) = 92; ++iptr;\r\n            break;\r\n        case 'e':   /* ASCII Escape character (Decimal value 27) */\r\n            *(optr++) = 27; ++iptr;\r\n            break;\r\n        case '\\'':   /* ASCII Single Quote character (Decimal value 39) */\r\n            *(optr++) = 39; ++iptr;\r\n            break;\r\n        case '\"':   /* ASCII Double Quote character (Decimal value 34) */\r\n            *(optr++) = 34; ++iptr;\r\n            break;\r\n        case '?':   /* ASCII Question Mark character (Decimal value 63) */\r\n            *(optr++) = 63; ++iptr;\r\n            break;\r\n        case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7':\r\n            *optr = *(iptr++) - '0';\r\n            if ((*iptr >= '0') && (*iptr <= '7'))\r\n                *optr = ((*optr)<<3) + (*(iptr++) - '0');\r\n            if ((*iptr >= '0') && (*iptr <= '7'))\r\n                *optr = ((*optr)<<3) + (*(iptr++) - '0');\r\n            ++optr;\r\n            break;\r\n        case 'x':\r\n            if (1) {\r\n                static const char *hex_digits = \"0123456789ABCDEF\";\r\n                const char *c;\r\n\r\n                ++iptr;\r\n                *optr = 0;\r\n                c = strchr (hex_digits, sim_toupper(*iptr));\r\n                if (c) {\r\n                    *optr = ((*optr)<<4) + (uint8)(c-hex_digits);\r\n                    ++iptr;\r\n                    }\r\n                c = strchr (hex_digits, sim_toupper(*iptr));\r\n                if (c) {\r\n                    *optr = ((*optr)<<4) + (uint8)(c-hex_digits);\r\n                    ++iptr;\r\n                    }\r\n                ++optr;\r\n                }\r\n            break;\r\n        default:\r\n            return sim_messagef (SCPE_ARG, \"Invalid escape: \\\\%s\\n\", iptr);\r\n        }\r\n    }\r\n*optr = '\\0';\r\n*osize = (uint32)(optr-ostart);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* sim_encode_quoted_string\r\n\r\n   Inputs:\r\n        iptr        =   pointer to input buffer\r\n        size        =   number of bytes of data in the buffer\r\n\r\n   Outputs\r\n        optr        =   pointer to output buffer\r\n                        the output buffer must be freed by the caller\r\n\r\n   The input data will be encoded into a simply printable form.\r\n   Control and other non-printable data will be escaped using the\r\n   following rules:\r\n\r\n   The following character escapes are explicitly supported:\r\n        \\r  ASCII Carriage Return character (Decimal value 13)\r\n        \\n  ASCII Linefeed character (Decimal value 10)\r\n        \\f  ASCII Formfeed character (Decimal value 12)\r\n        \\t  ASCII Horizontal Tab character (Decimal value 9)\r\n        \\v  ASCII Vertical Tab character (Decimal value 11)\r\n        \\b  ASCII Backspace character (Decimal value 8)\r\n        \\\\  ASCII Backslash character (Decimal value 92)\r\n        \\'  ASCII Single Quote character (Decimal value 39)\r\n        \\\"  ASCII Double Quote character (Decimal value 34)\r\n        \\?  ASCII Question Mark character (Decimal value 63)\r\n        \\e  ASCII Escape character (Decimal value 27)\r\n     as well as octal character values of the form:\r\n        \\n{n{n}} where each n is an octal digit (0-7)\r\n     and hex character values of the form:\r\n        \\xh{h} where each h is a hex digit (0-9A-Fa-f)\r\n\r\n*/\r\n\r\nchar *sim_encode_quoted_string (const uint8 *iptr, uint32 size)\r\n{\r\nuint32 i;\r\nt_bool double_quote_found = FALSE;\r\nt_bool single_quote_found = FALSE;\r\nchar quote = '\"';\r\nchar *tptr, *optr;\r\n\r\noptr = (char *)malloc (4*size + 3);\r\nif (optr == NULL)\r\n    return NULL;\r\ntptr = optr;\r\nfor (i=0; i<size; i++)\r\n    switch ((char)iptr[i]) {\r\n        case '\"':\r\n            double_quote_found = TRUE;\r\n            break;\r\n        case '\\'':\r\n            single_quote_found = TRUE;\r\n            break;\r\n        }\r\nif (double_quote_found && (!single_quote_found))\r\n    quote = '\\'';\r\n*tptr++ = quote;\r\nwhile (size--) {\r\n    switch (*iptr) {\r\n        case '\\r':\r\n            *tptr++ = '\\\\'; *tptr++ = 'r'; break;\r\n        case '\\n':\r\n            *tptr++ = '\\\\'; *tptr++ = 'n'; break;\r\n        case '\\f':\r\n            *tptr++ = '\\\\'; *tptr++ = 'f'; break;\r\n        case '\\t':\r\n            *tptr++ = '\\\\'; *tptr++ = 't'; break;\r\n        case '\\v':\r\n            *tptr++ = '\\\\'; *tptr++ = 'v'; break;\r\n        case '\\b':\r\n            *tptr++ = '\\\\'; *tptr++ = 'b'; break;\r\n        case '\\\\':\r\n            *tptr++ = '\\\\'; *tptr++ = '\\\\'; break;\r\n        case '\"':\r\n        case '\\'':\r\n            if (quote == *iptr)\r\n                *tptr++ = '\\\\';\r\n            /* fall through */\r\n        default:\r\n            if (sim_isprint (*iptr))\r\n                *tptr++ = *iptr;\r\n            else {\r\n                sprintf (tptr, \"\\\\%03o\", *iptr);\r\n                tptr += 4;\r\n                }\r\n            break;\r\n        }\r\n    ++iptr;\r\n    }\r\n*tptr++ = quote;\r\n*tptr++ = '\\0';\r\nreturn optr;\r\n}\r\n\r\nvoid fprint_buffer_string (FILE *st, const uint8 *buf, uint32 size)\r\n{\r\nchar *string;\r\n\r\nstring = sim_encode_quoted_string (buf, size);\r\nfprintf (st, \"%s\", string);\r\nfree (string);\r\n}\r\n\r\n\r\n/* Find_device          find device matching input string\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n   Outputs:\r\n        result  =       pointer to device\r\n*/\r\n\r\nDEVICE *find_dev (const char *cptr)\r\n{\r\nint32 i;\r\nDEVICE *dptr;\r\n\r\nif (cptr == NULL)\r\n    return NULL;\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n    if ((strcmp (cptr, dptr->name) == 0) ||\r\n        (dptr->lname &&\r\n        (strcmp (cptr, dptr->lname) == 0)))\r\n        return dptr;\r\n    }\r\nfor (i = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i) {\r\n    if ((strcmp (cptr, dptr->name) == 0) ||\r\n        (dptr->lname &&\r\n        (strcmp (cptr, dptr->lname) == 0)))\r\n        return dptr;\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n/* Find_unit            find unit matching input string\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n        uptr    =       pointer to unit pointer\r\n   Outputs:\r\n        result  =       pointer to device (null if no dev)\r\n        *iptr   =       pointer to unit (null if nx unit)\r\n\r\n*/\r\n\r\nDEVICE *find_unit (const char *cptr, UNIT **uptr)\r\n{\r\nuint32 i, u;\r\nconst char *nptr;\r\nconst char *tptr;\r\nt_stat r;\r\nDEVICE *dptr;\r\n\r\nif (uptr == NULL)                                       /* arg error? */\r\n    return NULL;\r\n*uptr = NULL;\r\nif ((dptr = find_dev (cptr))) {                         /* exact match? */\r\n    if (qdisable (dptr))                                /* disabled? */\r\n        return NULL;\r\n    *uptr = dptr->units;                                /* unit 0 */\r\n    return dptr;\r\n    }\r\n\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++) {     /* base + unit#? */\r\n    if (qdisable (dptr))                                /* device disabled? */\r\n        continue;\r\n    for (u = 0; u < dptr->numunits; u++) {              /* Look for user defined unit names first */\r\n        if ((dptr->units[u].lname == NULL) ||\r\n            (strcmp (cptr, dptr->units[u].lname) != 0))\r\n            continue;\r\n        *uptr = &dptr->units[u];\r\n        return dptr;\r\n        }\r\n    if (dptr->numunits &&                               /* any units? */\r\n        (((nptr = dptr->name) &&\r\n          (strncmp (cptr, nptr, strlen (nptr)) == 0)) ||\r\n         ((nptr = dptr->lname) &&\r\n          (strncmp (cptr, nptr, strlen (nptr)) == 0)))) {\r\n        tptr = cptr + strlen (nptr);\r\n        if (sim_isdigit (*tptr)) {\r\n            if (qdisable (dptr))                        /* disabled? */\r\n                return NULL;\r\n            u = (uint32) get_uint (tptr, 10, dptr->numunits - 1, &r);\r\n            if (r != SCPE_OK)                           /* error? */\r\n                *uptr = NULL;\r\n            else\r\n                *uptr = dptr->units + u;\r\n            return dptr;\r\n            }\r\n        }\r\n    for (u = 0; u < dptr->numunits; u++) {\r\n        if (0 == strcmp (cptr, sim_uname (&dptr->units[u]))) {\r\n            *uptr = &dptr->units[u];\r\n            return dptr;\r\n            }\r\n        }\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n/* sim_register_internal_device   Add device to internal device list\r\n\r\n   Inputs:\r\n        dptr    =       pointer to device\r\n*/\r\n\r\nt_stat sim_register_internal_device (DEVICE *dptr)\r\n{\r\nuint32 i;\r\n\r\nfor (i = 0; i < sim_internal_device_count; i++)\r\n    if (sim_internal_devices[i] == dptr)\r\n        return SCPE_OK;\r\nfor (i = 0; (sim_devices[i] != NULL); i++)\r\n    if (sim_devices[i] == dptr)\r\n        return SCPE_OK;\r\n++sim_internal_device_count;\r\nsim_internal_devices = (DEVICE **)realloc(sim_internal_devices, (sim_internal_device_count+1)*sizeof(*sim_internal_devices));\r\nsim_internal_devices[sim_internal_device_count-1] = dptr;\r\nsim_internal_devices[sim_internal_device_count] = NULL;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Find_dev_from_unit   find device for unit\r\n\r\n   Inputs:\r\n        uptr    =       pointer to unit\r\n   Outputs:\r\n        result  =       pointer to device\r\n*/\r\n\r\nDEVICE *find_dev_from_unit (UNIT *uptr)\r\n{\r\nDEVICE *dptr;\r\nuint32 i, j;\r\n\r\nif (uptr == NULL)\r\n    return NULL;\r\nif (uptr->dptr)\r\n    return uptr->dptr;\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n    for (j = 0; j < dptr->numunits; j++) {\r\n        if (uptr == (dptr->units + j)) {\r\n            uptr->dptr = dptr;\r\n            return dptr;\r\n            }\r\n        }\r\n    }\r\nfor (i = 0; i<sim_internal_device_count; i++) {\r\n    dptr = sim_internal_devices[i];\r\n    for (j = 0; j < dptr->numunits; j++) {\r\n        if (uptr == (dptr->units + j)) {\r\n            uptr->dptr = dptr;\r\n            return dptr;\r\n            }\r\n        }\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n/* Test for disabled device */\r\n\r\nt_bool qdisable (DEVICE *dptr)\r\n{\r\nreturn (dptr->flags & DEV_DIS? TRUE: FALSE);\r\n}\r\n\r\n/* find_reg_glob        find globally unique register\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n        optr    =       pointer to output pointer (can be null)\r\n        gdptr   =       pointer to global device\r\n   Outputs:\r\n        result  =       pointer to register, NULL if error\r\n        *optr   =       pointer to next character in input string\r\n        *gdptr  =       pointer to device where found\r\n        *stat   =       pointer to stat for reason\r\n*/\r\n\r\nREG *find_reg_glob_reason (CONST char *cptr, CONST char **optr, DEVICE **gdptr, t_stat *stat)\r\n{\r\nint32 i, j;\r\nDEVICE *dptr, **devs, **dptrptr[] = {sim_devices, sim_internal_devices, NULL};\r\nREG *rptr, *srptr = NULL;\r\n\r\nif (stat)\r\n    *stat = SCPE_OK;\r\n*gdptr = NULL;\r\nfor (j = 0; (devs = dptrptr[j]) != NULL; j++) {\r\n    for (i = 0; (dptr = devs[i]) != NULL; i++) {        /* all dev */\r\n        if (dptr->flags & DEV_DIS)                          /* skip disabled */\r\n            continue;\r\n        if ((rptr = find_reg (cptr, optr, dptr))) {         /* found? */\r\n            if (srptr) {                                    /* ambig? err */\r\n                if (stat) {\r\n                    if (sim_show_message) {\r\n                        if (*stat == SCPE_OK)\r\n                            sim_printf (\"Ambiguous register.  %s appears in devices %s and %s\", cptr, (*gdptr)->name, dptr->name);\r\n                        else\r\n                            sim_printf (\" and %s\", dptr->name);\r\n                        }\r\n                    *stat = SCPE_AMBREG|SCPE_NOMESSAGE;\r\n                    }\r\n                else\r\n                    return NULL;\r\n                }\r\n            srptr = rptr;                                   /* save reg */\r\n            *gdptr = dptr;                                  /* save unit */\r\n            }\r\n        }\r\n    }\r\nif (stat && (*stat != SCPE_OK)) {\r\n    if (sim_show_message)\r\n        sim_printf (\"\\n\");\r\n    srptr = NULL;\r\n    }\r\nreturn srptr;\r\n}\r\n\r\nREG *find_reg_glob (CONST char *cptr, CONST char **optr, DEVICE **gdptr)\r\n{\r\nreturn find_reg_glob_reason (cptr, optr, gdptr, NULL);\r\n}\r\n\r\n/* find_reg             find register matching input string\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n        optr    =       pointer to output pointer (can be null)\r\n        dptr    =       pointer to device\r\n   Outputs:\r\n        result  =       pointer to register, NULL if error\r\n        *optr   =       pointer to next character in input string\r\n*/\r\n\r\nREG *find_reg (CONST char *cptr, CONST char **optr, DEVICE *dptr)\r\n{\r\nCONST char *tptr;\r\nREG *rptr;\r\nsize_t slnt;\r\n\r\nif ((cptr == NULL) || (dptr == NULL) || (dptr->registers == NULL))\r\n    return NULL;\r\ntptr = cptr;\r\ndo {\r\n    tptr++;\r\n    } while (sim_isalnum (*tptr) || (*tptr == '*') || (*tptr == '_') || (*tptr == '.'));\r\nslnt = tptr - cptr;\r\nfor (rptr = dptr->registers; rptr->name != NULL; rptr++) {\r\n    if ((slnt == strlen (rptr->name)) &&\r\n        (strncmp (cptr, rptr->name, slnt) == 0)) {\r\n        if (optr != NULL)\r\n            *optr = tptr;\r\n        return rptr;\r\n        }\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n/* get_switches         get switches from input string\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n   Outputs:\r\n        *sw      =       switch bit mask\r\n        *number  =       numeric value\r\n   Return value:        SW_ERROR     if error\r\n                        SW_BITMASK   if switch bitmask or not a switch\r\n                        SW_NUMBER    if numeric\r\n*/\r\n"
        },
        {
          "name": "scp.h",
          "type": "blob",
          "size": 20.9736328125,
          "content": "/* scp.h: simulator control program headers\r\n\r\n   Copyright (c) 1993-2009, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not\r\n   be used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   05-Dec-10    MP      Added macro invocation of sim_debug\r\n   09-Aug-06    JDB     Added assign_device and deassign_device\r\n   14-Jul-06    RMS     Added sim_activate_abs\r\n   06-Jan-06    RMS     Added fprint_stopped_gen\r\n                        Changed arg type in sim_brk_test\r\n   07-Feb-05    RMS     Added ASSERT command\r\n   09-Sep-04    RMS     Added reset_all_p\r\n   14-Feb-04    RMS     Added debug prototypes (from Dave Hittner)\r\n   02-Jan-04    RMS     Split out from SCP\r\n*/\r\n\r\n#ifndef SIM_SCP_H_\r\n#define SIM_SCP_H_     0\r\n\r\n#include \"sim_fio.h\"\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* run_cmd parameters */\r\n\r\n#define RU_RUN          0                               /* run */\r\n#define RU_GO           1                               /* go */\r\n#define RU_STEP         2                               /* step */\r\n#define RU_NEXT         3                               /* step or step/over */\r\n#define RU_CONT         4                               /* continue */\r\n#define RU_BOOT         5                               /* boot */\r\n\r\n/* exdep_cmd parameters */\r\n\r\n#define EX_D            0                               /* deposit */\r\n#define EX_E            1                               /* examine */\r\n#define EX_I            2                               /* interactive */\r\n#define EX_DONE         4                               /* examine done */\r\n\r\n/* brk_cmd parameters */\r\n\r\n#define SSH_ST          0                               /* set */\r\n#define SSH_SH          1                               /* show */\r\n#define SSH_CL          2                               /* clear */\r\n\r\n/* get_sim_opt parameters */\r\n\r\n#define CMD_OPT_SW      001                             /* switches */\r\n#define CMD_OPT_OF      002                             /* output file */\r\n#define CMD_OPT_SCH     004                             /* search */\r\n#define CMD_OPT_DFT     010                             /* defaults */\r\n\r\n/* Command processors */\r\n\r\nt_stat reset_cmd (int32 flag, CONST char *ptr);\r\nt_stat exdep_cmd (int32 flag, CONST char *ptr);\r\nt_stat eval_cmd (int32 flag, CONST char *ptr);\r\nt_stat load_cmd (int32 flag, CONST char *ptr);\r\nt_stat run_cmd (int32 flag, CONST char *ptr);\r\nvoid run_cmd_message (const char *unechod_cmdline, t_stat r);\r\nt_stat attach_cmd (int32 flag, CONST char *ptr);\r\nt_stat detach_cmd (int32 flag, CONST char *ptr);\r\nt_stat assign_cmd (int32 flag, CONST char *ptr);\r\nt_stat deassign_cmd (int32 flag, CONST char *ptr);\r\nt_stat save_cmd (int32 flag, CONST char *ptr);\r\nt_stat restore_cmd (int32 flag, CONST char *ptr);\r\nt_stat exit_cmd (int32 flag, CONST char *ptr);\r\nt_stat set_cmd (int32 flag, CONST char *ptr);\r\nt_stat show_cmd (int32 flag, CONST char *ptr);\r\nt_stat set_default_cmd (int32 flg, CONST char *cptr);\r\nt_stat pwd_cmd (int32 flg, CONST char *cptr);\r\nt_stat dir_cmd (int32 flg, CONST char *cptr);\r\nt_stat type_cmd (int32 flg, CONST char *cptr);\r\nt_stat delete_cmd (int32 flg, CONST char *cptr);\r\nt_stat copy_cmd (int32 flg, CONST char *cptr);\r\nt_stat rename_cmd (int32 flg, CONST char *cptr);\r\nt_stat mkdir_cmd (int32 flg, CONST char *cptr);\r\nt_stat rmdir_cmd (int32 flg, CONST char *cptr);\r\nt_stat brk_cmd (int32 flag, CONST char *ptr);\r\nt_stat do_cmd (int32 flag, CONST char *ptr);\r\nt_stat goto_cmd (int32 flag, CONST char *ptr);\r\nt_stat return_cmd (int32 flag, CONST char *ptr);\r\nt_stat shift_cmd (int32 flag, CONST char *ptr);\r\nt_stat call_cmd (int32 flag, CONST char *ptr);\r\nt_stat on_cmd (int32 flag, CONST char *ptr);\r\nt_stat noop_cmd (int32 flag, CONST char *ptr);\r\nt_stat assert_cmd (int32 flag, CONST char *ptr);\r\nt_stat send_cmd (int32 flag, CONST char *ptr);\r\nt_stat expect_cmd (int32 flag, CONST char *ptr);\r\nt_stat sleep_cmd (int32 flag, CONST char *ptr);\r\nt_stat help_cmd (int32 flag, CONST char *ptr);\r\nt_stat screenshot_cmd (int32 flag, CONST char *ptr);\r\nt_stat spawn_cmd (int32 flag, CONST char *ptr);\r\nt_stat echo_cmd (int32 flag, CONST char *ptr);\r\nt_stat echof_cmd (int32 flag, CONST char *ptr);\r\nt_stat debug_cmd (int32 flag, CONST char *ptr);\r\nt_stat runlimit_cmd (int32 flag, CONST char *ptr);\r\nt_stat tar_cmd (int32 flag, CONST char *ptr);\r\nt_stat curl_cmd (int32 flag, CONST char *ptr);\r\nt_stat test_lib_cmd (int32 flag, CONST char *ptr);\r\n\r\n/* Allow compiler to help validate printf style format arguments */\r\n#if !defined __GNUC__\r\n#define GCC_FMT_ATTR(n, m)\r\n#endif\r\n#if !defined(GCC_FMT_ATTR)\r\n#define GCC_FMT_ATTR(n, m) __attribute__ ((format (__printf__, n, m)))\r\n#endif\r\n\r\n/* Utility routines */\r\n\r\nt_stat sim_process_event (void);\r\nt_stat sim_activate (UNIT *uptr, int32 interval);\r\nt_stat _sim_activate (UNIT *uptr, int32 interval);\r\nt_stat sim_activate_abs (UNIT *uptr, int32 interval);\r\nt_stat sim_activate_notbefore (UNIT *uptr, int32 rtime);\r\nt_stat sim_activate_after (UNIT *uptr, uint32 usecs_walltime);\r\nt_stat sim_activate_after_d (UNIT *uptr, double usecs_walltime);\r\nt_stat _sim_activate_after (UNIT *uptr, double usecs_walltime);\r\nt_stat sim_activate_after_abs (UNIT *uptr, uint32 usecs_walltime);\r\nt_stat sim_activate_after_abs_d (UNIT *uptr, double usecs_walltime);\r\nt_stat _sim_activate_after_abs (UNIT *uptr, double usecs_walltime);\r\nt_stat sim_cancel (UNIT *uptr);\r\nt_bool sim_is_active (UNIT *uptr);\r\nint32 sim_activate_time (UNIT *uptr);\r\nint32 _sim_activate_queue_time (UNIT *uptr);\r\nint32 _sim_activate_time (UNIT *uptr);\r\ndouble sim_activate_time_usecs (UNIT *uptr);\r\nt_stat sim_run_boot_prep (int32 flag);\r\ndouble sim_gtime (void);\r\nuint32 sim_grtime (void);\r\nvoid sim_reset_time (void);\r\nint32 sim_qcount (void);\r\nt_stat attach_unit (UNIT *uptr, CONST char *cptr);\r\nt_stat detach_unit (UNIT *uptr);\r\nt_stat assign_device (DEVICE *dptr, const char *cptr);\r\nt_stat deassign_device (DEVICE *dptr);\r\nt_stat reset_all (uint32 start_device);\r\nt_stat reset_all_p (uint32 start_device);\r\nt_stat set_writelock (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat show_writelock (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nconst char *sim_dname (DEVICE *dptr);\r\nconst char *sim_uname (UNIT *dptr);\r\nconst char *sim_set_uname (UNIT *uptr, const char *uname);\r\nconst char *sim_attach_name (UNIT *dptr);\r\nt_bool get_yn (const char *ques, t_bool deflt);\r\nvoid sim_srand (unsigned int seed);\r\nint sim_rand (void);\r\n#ifdef RAND_MAX\r\n#undef RAND_MAX\r\n#endif\r\n#define RAND_MAX 2147483646\r\n#define rand sim_rand\r\n#define srand(seed) sim_srand(seed)\r\nCONST char *get_sim_opt (int32 opt, CONST char *cptr, t_stat *st);\r\nCONST char *get_sim_sw (CONST char *cptr);\r\nconst char *put_switches (char *buf, size_t bufsize, uint32 sw);\r\nCONST char *get_glyph (const char *iptr, char *optr, char mchar);\r\nCONST char *get_glyph_nc (const char *iptr, char *optr, char mchar);\r\nCONST char *get_glyph_quoted (const char *iptr, char *optr, char mchar);\r\nCONST char *get_glyph_cmd (const char *iptr, char *optr);\r\nt_value get_uint (const char *cptr, uint32 radix, t_value max, t_stat *status);\r\nCONST char *get_range (DEVICE *dptr, CONST char *cptr, t_addr *lo, t_addr *hi,\r\n    uint32 rdx, t_addr max, char term);\r\nt_stat sim_set_environment (int32 flag, CONST char *cptr);\r\nt_stat sim_decode_quoted_string (const char *iptr, uint8 *optr, uint32 *osize);\r\nchar *sim_encode_quoted_string (const uint8 *iptr, uint32 size);\r\nvoid fprint_buffer_string (FILE *st, const uint8 *buf, uint32 size);\r\nt_value strtotv (CONST char *cptr, CONST char **endptr, uint32 radix);\r\nt_svalue strtotsv (CONST char *inptr, CONST char **endptr, uint32 radix);\r\nint Fprintf (FILE *f, const char *fmt, ...) GCC_FMT_ATTR(2, 3);\r\n/* Use scp.c provided fprintf function */\r\n#define fprintf Fprintf\r\n#define fputs(_s,_f) Fprintf(_f,\"%s\",_s)\r\n#define fputc(_c,_f) Fprintf(_f,\"%c\",_c)\r\nt_stat sim_set_memory_load_file (const unsigned char *data, size_t size);\r\nt_stat sim_set_memory_load_file_ex (const unsigned char *data, size_t size, const char *filepath, unsigned int checksum);\r\nint Fgetc (FILE *f);\r\nt_stat fprint_val (FILE *stream, t_value val, uint32 rdx, uint32 wid, uint32 fmt);\r\nt_stat sprint_val (char *buf, t_value val, uint32 rdx, uint32 wid, uint32 fmt);\r\nt_stat sim_print_val (t_value val, uint32 radix, uint32 width, uint32 format);\r\nconst char *sim_fmt_secs (double seconds);\r\nconst char *sim_fmt_numeric (double number);\r\nconst char *sprint_capac (DEVICE *dptr, UNIT *uptr);\r\nchar *read_line (char *cptr, int32 size, FILE *stream);\r\nchar *read_line_p (const char *prompt, char *ptr, int32 size, FILE *stream);\r\nvoid fprint_brk_help (FILE *st, DEVICE *dptr);\r\nvoid fprint_reg_help (FILE *st, DEVICE *dptr);\r\nvoid fprint_set_help (FILE *st, DEVICE *dptr);\r\nvoid fprint_show_help (FILE *st, DEVICE *dptr);\r\nCTAB *find_cmd (const char *gbuf);\r\nDEVICE *find_dev (const char *ptr);\r\nDEVICE *find_unit (const char *ptr, UNIT **uptr);\r\nDEVICE *find_dev_from_unit (UNIT *uptr);\r\nt_stat sim_register_internal_device (DEVICE *dptr);\r\nvoid sim_sub_args (char *in_str, size_t in_str_size, char *do_arg[]);\r\nREG *find_reg (CONST char *ptr, CONST char **optr, DEVICE *dptr);\r\nCTAB *find_ctab (CTAB *tab, const char *gbuf);\r\nC1TAB *find_c1tab (C1TAB *tab, const char *gbuf);\r\nSHTAB *find_shtab (SHTAB *tab, const char *gbuf);\r\nt_stat get_aval (t_addr addr, DEVICE *dptr, UNIT *uptr);\r\nt_value get_rval (REG *rptr, uint32 idx);\r\nBRKTAB *sim_brk_fnd (t_addr loc);\r\nuint32 sim_brk_test (t_addr bloc, uint32 btyp);\r\nvoid sim_brk_clrspc (uint32 spc, uint32 btyp);\r\nvoid sim_brk_npc (uint32 cnt);\r\nvoid sim_brk_setact (const char *action);\r\nchar *sim_brk_replace_act (char *new_action);\r\nconst char *sim_brk_message(void);\r\nt_stat sim_send_input (SEND *snd, uint8 *data, size_t size, uint32 after, uint32 delay);\r\nt_stat sim_show_send_input (FILE *st, const SEND *snd);\r\nt_bool sim_send_poll_data (SEND *snd, t_stat *stat);\r\nt_stat sim_send_clear (SEND *snd);\r\nt_stat sim_set_expect (EXPECT *exp, CONST char *cptr);\r\nt_stat sim_set_noexpect (EXPECT *exp, const char *cptr);\r\nt_stat sim_exp_set (EXPECT *exp, const char *match, int32 cnt, uint32 after, int32 switches, const char *act);\r\nt_stat sim_exp_clr (EXPECT *exp, const char *match);\r\nt_stat sim_exp_clrall (EXPECT *exp);\r\nt_stat sim_exp_show (FILE *st, CONST EXPECT *exp, const char *match);\r\nt_stat sim_exp_showall (FILE *st, const EXPECT *exp);\r\nt_stat sim_exp_check (EXPECT *exp, uint8 data);\r\nCONST char *match_ext (CONST char *fnam, const char *ext);\r\nint sim_cmp_string (const char *s1, const char *s2);\r\nt_stat sim_fetch_binary_file (const char *filename, const char *filepath, size_t size, unsigned int checksum);\r\nt_stat show_version (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat set_dev_enbdis (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat set_dev_debug (DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat show_dev_debug (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_add_debug_flags (DEVICE *dptr, DEBTAB *debflags);\r\nconst char *sim_error_text (t_stat stat);\r\nt_stat sim_string_to_stat (const char *cptr, t_stat *cond);\r\nt_stat sim_sched_step (void);\r\nt_stat sim_cancel_step (void);\r\nconst char *sim_get_tool_path (const char *tool);\r\nvoid sim_printf (const char *fmt, ...) GCC_FMT_ATTR(1, 2);\r\nvoid sim_perror (const char *msg);\r\nt_stat sim_call_argv (int (*main_like)(int argc, char *argv[]), const char *cptr);\r\nt_stat sim_messagef (t_stat stat, const char *fmt, ...) GCC_FMT_ATTR(2, 3);\r\nvoid sim_data_trace(DEVICE *dptr, UNIT *uptr, const uint8 *data, const char *position, size_t len, const char *txt, uint32 reason);\r\nvoid sim_debug_bits_hdr (uint32 dbits, DEVICE* dptr, const char *header,\r\n    BITFIELD* bitdefs, uint32 before, uint32 after, int terminate);\r\nvoid sim_debug_bits (uint32 dbits, DEVICE* dptr, BITFIELD* bitdefs,\r\n    uint32 before, uint32 after, int terminate);\r\n#if defined (__DECC) && defined (__VMS) && (defined (__VAX) || (__DECC_VER < 60590001))\r\n#define CANT_USE_MACRO_VA_ARGS 1\r\n#endif\r\nvoid _sim_vdebug (uint32 dbits, DEVICE* dptr, UNIT *uptr, const char* fmt, va_list arglist);\r\n#ifdef CANT_USE_MACRO_VA_ARGS\r\n#define _sim_debug_device sim_debug\r\nvoid sim_debug (uint32 dbits, DEVICE* dptr, const char *fmt, ...) GCC_FMT_ATTR(3, 4);\r\n#define _sim_debug_unit sim_debug_unit\r\nvoid sim_debug_unit (uint32 dbits, UNIT* uptr, const char *fmt, ...) GCC_FMT_ATTR(3, 4);\r\n#else\r\nvoid _sim_debug_unit (uint32 dbits, UNIT *uptr, const char* fmt, ...) GCC_FMT_ATTR(3, 4);\r\nvoid _sim_debug_device (uint32 dbits, DEVICE* dptr, const char* fmt, ...) GCC_FMT_ATTR(3, 4);\r\n#define sim_debug(dbits, dptr, ...) do { if ((sim_deb != NULL) && ((dptr) != NULL) && ((dptr)->dctrl & (dbits))) _sim_debug_device (dbits, dptr, __VA_ARGS__);} while (0)\r\n#define sim_debug_unit(dbits, uptr, ...) do { if ((sim_deb != NULL) && ((uptr) != NULL) && (uptr->dptr != NULL) && (((uptr)->dctrl | (uptr)->dptr->dctrl) & (dbits))) _sim_debug_unit (dbits, uptr, __VA_ARGS__);} while (0)\r\n#endif\r\nvoid sim_flush_buffered_files (t_bool debug_flush);\r\n\r\n/* Only for use in SCP code and libraries - NOT in simulator code */\r\n#define SIM_SCP_ABORT(msg) _sim_scp_abort (msg, __FILE__, __LINE__)\r\nvoid _sim_scp_abort (const char *msg, const char *filename, int filelinenum);\r\n\r\nvoid fprint_stopped_gen (FILE *st, t_stat v, REG *pc, DEVICE *dptr);\r\n#define SCP_HELP_FLAT   (1u << 31)       /* Force flat help when prompting is not possible */\r\n#define SCP_HELP_ONECMD (1u << 30)       /* Display one topic, do not prompt */\r\n#define SCP_HELP_ATTACH (1u << 29)       /* Top level topic is ATTACH help */\r\nt_stat scp_help (FILE *st, DEVICE *dptr,\r\n                 UNIT *uptr, int32 flag, const char *help, const char *cptr, ...);\r\nt_stat scp_vhelp (FILE *st, DEVICE *dptr,\r\n                  UNIT *uptr, int32 flag, const char *help, const char *cptr, va_list ap);\r\nt_stat scp_helpFromFile (FILE *st, DEVICE *dptr,\r\n                         UNIT *uptr, int32 flag, const char *help, const char *cptr, ...);\r\nt_stat scp_vhelpFromFile (FILE *st, DEVICE *dptr,\r\n                          UNIT *uptr, int32 flag, const char *help, const char *cptr, va_list ap);\r\n\r\n/* Global data */\r\n\r\nextern DEVICE *sim_dflt_dev;\r\nextern DEVICE *sim_dfdev;\r\nextern UNIT *sim_dfunit;\r\nextern int32 sim_interval;\r\nextern int32 sim_switches;\r\nextern int32 sim_switch_number;\r\n#define GET_SWITCHES(cp) \\\r\n    if ((cp = get_sim_sw (cp)) == NULL) return SCPE_INVSW\r\n#define GET_RADIX(val,dft) \\\r\n    if (sim_switches & SWMASK ('O')) val = 8; \\\r\n    else if (sim_switches & SWMASK ('D')) val = 10; \\\r\n    else if (sim_switches & SWMASK ('H')) val = 16; \\\r\n    else if ((sim_switch_number >= 2) && (sim_switch_number <= 36)) val = sim_switch_number; \\\r\n    else val = dft;\r\nextern int32 sim_show_message;\r\nextern int32 sim_quiet;\r\nextern int32 sim_step;\r\nextern t_stat sim_last_cmd_stat;                        /* Command Status */\r\nextern FILE *sim_log;                                   /* log file */\r\nextern FILEREF *sim_log_ref;                            /* log file file reference */\r\nextern FILE *sim_deb;                                   /* debug file */\r\nextern FILEREF *sim_deb_ref;                            /* debug file file reference */\r\nextern int32 sim_deb_switches;                          /* debug display flags */\r\nextern size_t sim_deb_buffer_size;                      /* debug memory buffer size */\r\nextern char *sim_deb_buffer;                            /* debug memory buffer */\r\nextern size_t sim_debug_buffer_offset;                  /* debug memory buffer insertion offset */\r\nextern size_t sim_debug_buffer_inuse;                   /* debug memory buffer inuse count */\r\nextern DEVICE **sim_internal_devices;\r\nextern uint32 sim_internal_device_count;\r\nextern UNIT *sim_clock_queue;\r\nextern volatile t_bool sim_is_running;\r\nextern t_bool sim_processing_event;                     /* Called from sim_process_event */\r\nextern char *sim_prompt;                                /* prompt string */\r\nextern const char *sim_savename;                        /* Simulator Name used in Save/Restore files */\r\nextern t_value *sim_eval;\r\nextern volatile t_bool stop_cpu;\r\nextern uint32 sim_brk_types;                            /* breakpoint info */\r\nextern uint32 sim_brk_dflt;\r\nextern uint32 sim_brk_summ;\r\nextern uint32 sim_brk_match_type;\r\nextern t_addr sim_brk_match_addr;\r\nextern BRKTYPTAB *sim_brk_type_desc;                    /* type descriptions */\r\nextern const char *sim_prog_name;                       /* executable program name */\r\nextern FILE *stdnul;\r\nextern t_bool sim_asynch_enabled;\r\nextern int32 sim_asynch_latency;\r\nextern int32 sim_asynch_inst_latency;\r\n#if defined(SIM_ASYNCH_IO)\r\nint sim_aio_update_queue (void);\r\nvoid sim_aio_activate (ACTIVATE_API caller, UNIT *uptr, int32 event_time);\r\nvoid sim_aio_check_event (void);\r\nvoid sim_aio_set_interrupt_latency (int32 instpersec);\r\n#endif\r\n\r\n/* VM interface */\r\n\r\nextern char sim_name[64];\r\nextern const char *sim_vm_release;\r\nextern const char *sim_vm_release_message;\r\nextern DEVICE *sim_devices[];\r\nextern REG *sim_PC;\r\nextern const char *sim_stop_messages[SCPE_BASE];\r\nextern t_stat sim_instr (void);\r\nextern t_stat sim_load (FILE *ptr, CONST char *cptr, CONST char *fnam, int flag);\r\nextern int32 sim_emax;\r\nextern t_stat fprint_sym (FILE *ofile, t_addr addr, t_value *val,\r\n    UNIT *uptr, int32 sw);\r\nextern t_stat parse_sym (CONST char *cptr, t_addr addr, UNIT *uptr, t_value *val,\r\n    int32 sw);\r\n\r\n/* The per-simulator init routine is a weak global that defaults to NULL\r\n   The other per-simulator pointers can be overridden by the init routine\r\n\r\nextern void (*sim_vm_init) (void);\r\n\r\n   This routine is no longer invoked this way since it doesn't work reliably\r\n   on all simh supported compile environments.  A simulator that needs these\r\n   initializations can perform them in the CPU device reset routine which will\r\n   always be called before anything else can be processed.\r\n\r\n */\r\nextern char *(*sim_vm_read) (char *ptr, int32 size, FILE *stream);\r\nextern void (*sim_vm_post) (t_bool from_scp);\r\nextern CTAB *sim_vm_cmd;\r\nextern void (*sim_vm_sprint_addr) (char *buf, DEVICE *dptr, t_addr addr);\r\nextern void (*sim_vm_fprint_addr) (FILE *st, DEVICE *dptr, t_addr addr);\r\nextern t_addr (*sim_vm_parse_addr) (DEVICE *dptr, CONST char *cptr, CONST char **tptr);\r\nextern t_bool (*sim_vm_fprint_stopped) (FILE *st, t_stat reason);\r\nextern t_value (*sim_vm_pc_value) (void);\r\nextern t_bool (*sim_vm_is_subroutine_call) (t_addr **ret_addrs);\r\nextern void (*sim_vm_reg_update) (REG *rptr, uint32 idx, t_value prev_val, t_value new_val);\r\nextern const char **sim_clock_precalibrate_commands;\r\nextern uint32 sim_vm_initial_ips;                       /* base estimate of simulated instructions per second */\r\nextern const char *sim_vm_interval_units;               /* Simulator can change this - default \"instructions\" */\r\nextern const char *sim_vm_step_unit;                    /* Simulator can change this - default \"instruction\" */\r\n\r\n\r\n/* Core SCP libraries can potentially have unit test routines.\r\n   These defines help implement consistent unit test functionality */\r\n\r\n#define SIM_TEST_INIT                                           \\\r\n        volatile int test_stat;                                 \\\r\n        const char *volatile sim_test;                          \\\r\n        jmp_buf sim_test_env;                                   \\\r\n        if ((test_stat = setjmp (sim_test_env))) {              \\\r\n            sim_printf (\"Error: %d - '%s' processing: %s\\n\",    \\\r\n                        SCPE_BARE_STATUS(test_stat),            \\\r\n                        sim_error_text(test_stat), sim_test);   \\\r\n            return test_stat;                                   \\\r\n            }\r\n#define SIM_TEST(_stat)                                         \\\r\n        do {                                                    \\\r\n            if (SCPE_OK != (test_stat = (_stat))) {             \\\r\n                sim_test = #_stat;                              \\\r\n                longjmp (sim_test_env, test_stat);              \\\r\n                }                                               \\\r\n            } while (0)\r\n\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "scp_help.h",
          "type": "blob",
          "size": 12.2490234375,
          "content": "/* scp_help.h: hierarchical help definitions\r\n\r\n   Copyright (c) 2013, Timothe Litt\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n*/\r\n\r\n#ifndef SCP_HELP_H_\r\n#define SCP_HELP_H_  0\r\n\r\n/* The SCP structured help uses help text that defines a hierarchy of information\r\n * organized into topics and subtopics.  This is modelled on the VMS help command.\r\n *\r\n * This arrangement allows the long help messages being used in many devices to be\r\n * organized to be easier to approach and navigate.\r\n *\r\n * The helpx utility (a Perl script) will read a device source file\r\n * that conforms to the previous conventions, and produce a template and\r\n * initial translation into the format described here.\r\n *\r\n * The structure of the help text is:\r\n *\r\n * Lines beginning with whitespace are displayed as part of the current topic, except:\r\n *   * The leading white space is replaced by a standard indentation of 4 spaces.\r\n *     Additional indentation, where appropriate, can be obtained with '+', 4 spaces each.\r\n *\r\n *   * The following % escapes are recognized:\r\n *     * %D    - Inserts the name of the device     (e.g. \"DTA\").\r\n *     * %U    - Inserts the name of the unit       (e.g. \"DTA0\").\r\n *     * %S    - Inserts the current simulator name (e.g. \"PDP-10\")\r\n *     * %C    - Inserts the current value of the sim_vm_interval_units string\r\n *     * %I    - Inserts the current value of the sim_vm_step_unit string\r\n *     * %#s   - Inserts the string suppled in the \"#\"th optional argument to the help\r\n *               routine.  # starts with 1.  Any embedded newlines will cause following\r\n *               text to be indented.\r\n *     * %#H   - Appends the #th optional argument to the help text.  Use to add common\r\n *               help to device specific help.  The text is placed AFTER the current help\r\n *               string, and after any previous %H inclusions.  Parameter numbers restart\r\n *               with the new string, following the last parameter used by the previous tree.\r\n *     * %%    - Inserts a literal %.\r\n *     * %+    - Inserts a literal +.\r\n *      - Any other escape is reserved and will cause an exception.  However, the goal\r\n *        is to provide help, not a general formatting facility.  Use sprintf to a\r\n *        local buffer, and pass that as a string if more general formatting is required.\r\n *\r\n * Lines beginning with a number introduce a subtopic of the device.  The number indicates\r\n * the subtopic's place in the help hierarchy.  Topics offered as Additional Information\r\n * under the device's main topic are at level 1.  Their sub-topics are at level 2, and\r\n * so on.  Following the number is a string that names the sub-topic.  This is displayed,\r\n * and what the user types to access the information.  Whitespace in the topic name is\r\n * typed as an underscore (_).  Topic names beginning with '$' invoke other kinds of help,\r\n * These are:\r\n *    $Registers     - Displays the device register help\r\n *    $Set commands  - Displays the standard SET command help.\r\n *    $Show commands - Displays the standard SHOW command help.\r\n *\r\n * For these special topics, any text that you provide will be added after\r\n * the output from the system routines.  This allows you to add more information, or\r\n * an introduction to subtopics with more detail.\r\n *\r\n * Topic names that begin with '?' are conditional topics.\r\n * Some devices adopt radically different personalities at runtime,\r\n * e.g. when attached to a processor with different bus.\r\n * In rare cases, it's better not to include help that doesn't apply.\r\n * For these cases, ?#, where # is a 1-based parameter number, can be used\r\n * to selectively include a topic.  If the specified parameter is TRUE\r\n * (a string with the value \"T\", \"t\" or '1'), the topic will be visible.\r\n * If the parameter is FALSE (NULL, or a string with any other value),\r\n * the topic will not be visible.\r\n *\r\n * If it can be determined at compile time whether the topic in question\r\n * is needed, #ifdef around those lines of the help is a better choice.\r\n *\r\n * If both $ and ? are used, ? comes first.\r\n *\r\n * Guidelines:\r\n *   Help should be concise and easy to understand.\r\n *\r\n *   The main topic should be short - less than a screenful when presented with the\r\n *   subtopic list.\r\n *\r\n *   Keep line lengths to 76 columns or less.\r\n *\r\n *   Follow the subtopic naming conventions (under development) for a consistent style:\r\n *\r\n *   At the top level, the device should be summarized in a few sentences.\r\n *   The subtopics for detail should be:\r\n *     Hardware Description - The details of the hardware.  Feeds & speeds are OK here.\r\n *          Models          -   If the device was offered in distinct models, a subtopic for each.\r\n *          Registers       -   Register descriptions\r\n *\r\n *     Configuration         - How to configure the device under SimH.  SET commands.\r\n *          Operating System -   If the device needs special configuration for a particular\r\n *                               OS, a subtopic for each such OS goes here.\r\n *          Files            - If the device uses external files (tapes, cards, disks, configuration)\r\n *                             A subtopic for each here.\r\n *          Examples         - Provide usable examples for configuring complex devices.\r\n *\r\n *     Operation             - How to operate the device under SimH.  Attach, runtime events\r\n *                             (e.g. how to load cards or mount a tape)\r\n *\r\n *     Monitoring            - How to obtain status (SHOW commands)\r\n *\r\n *     Restrictions          - If some aspects of the device aren't emulated, list them here.\r\n *\r\n *     Debugging             - Debugging information\r\n *\r\n *     Related Devices       - If devices are configured or used together, list the other devices here.\r\n *                             E.G. The DEC KMC/DUP are two hardware devices that are closely related;\r\n *                             The KMC controls the DUP on behalf of the OS.\r\n *\r\n * This text can be created by any convenient means.  It can be mechanically extracted from the device\r\n * source, read from a file, or simply entered as a string in the help routine.  To facilitate the latter,\r\n * this file defines two convenience macros:\r\n *\r\n *   L(text)     - provides a string with a leading space and a trailing \\n.  Enter a line of topic text.\r\n *   T(n, NAME)  - provides a string with the topic level n and the topic name NAME, and a trailing \\n.\r\n *\r\n * These are concatenated normally, e.g.\r\n   const char *const help =\r\n    L (The %D device is interesting)\r\n    L (It has lots of help options)\r\n    T (1, TOPIC 1)\r\n    L (And this is topic 1)\r\n    ;\r\n *\r\n * API:\r\n *  To make use of this type of help in your device, create (or replace) a help routine with one that\r\n *   calls scp_help.  Most of the arguments are the same as those of the device help routine.\r\n *\r\n *  t_stat scp_help (FILE *st, DEVICE *dptr,\r\n *                   UNIT *uptr, int flag, const char *help, char *cptr, ...)\r\n *\r\n *  If you need to pass the variable argument list from another routine, use:\r\n *\r\n *  t_stat scp_vhelp (FILE *st, DEVICE *dptr,\r\n *                    UNIT *uptr, int flag, const char *help, char *cptr, va_list ap)\r\n *\r\n *  To obtain the help from an external file (Note this reads the entire file into memory):\r\n *  t_stat scp_helpFromFile (FILE *st, DEVICE *dptr,\r\n *                            UNIT *uptr, int flag, const char *helpfile, char *cptr, ...)\r\n *  and for va_list:\r\n *  t_stat scp_vhelpFromFile (FILE *st, DEVICE *dptr,\r\n *                            UNIT *uptr, int flag, const char *helpfile, char *cptr, va_list ap) {\r\n *\r\n * dptr and uptr are only used if the %D and/or %U escapes are encountered.\r\n * help is the help text; helpfile is the help file name.\r\n *\r\n * flag is usually the flag from the help command dispatch.  SCP_HELP_FLAT is set in non-interactive\r\n * environments.  When this flag, or DEV_FLATHELP in DEVICE.flags is set, the entire help text\r\n * will be flattened and displayed in outline form.\r\n *\r\n * Help files are easier to edit, but can become separated from the SimH executable.  Finding them\r\n * at runtime can also be a challenge.  SimH tries...but the project standard is to embed help\r\n * as strings in the device.  (It may be easier to develop help as a file before converting it\r\n * to a string.)\r\n *\r\n * Lines beginning with ';' will be ignored.\r\n *\r\n * Here is a worked-out example:\r\n *\r\n;****************************************************************************\r\n The Whizbang 100 is a DMA line printer controller used on the Whizbang 1000\r\n and Gurgle 1200 processor families of the Obsolete Hardware Corporation.\r\n1 Hardware Description\r\n The Whizbang 100 is specified to operate \"any printer you and a friend can\r\n lift\", and speeds up to 0.5 C.\r\n\r\n The controller requires a refrigerator-sized box, consumes 5.5KW, and is\r\n liquid cooled.  It uses GBL (Granite Baked Logic).\r\n\r\n Painted a cool blue, it consistently won industrial design awards, even\r\n as mechanically, it was less than perfect.  Plumbers had full employment.\r\n2 Models\r\n The Whizbang 100 model G was commissioned by a government agency, which\r\n insisted on dull gray paint, and speeds limited to 11 MPH.\r\n\r\n The Whizbang 100 Model X is powered by the improbability drive, and is\r\n rarely seen once installed.\r\n2 $Registers\r\n The two main registers are the Print Control register and the Print Data\r\n register.  The Print Maintenance register is usually broken.\r\n3 Print Control register\r\n  Bit 0 turns the attached printer on when set, off when clear.\r\n  Bit 1 ejects the current page\r\n  Bit 2 ejects the operator\r\n  Bit 3 enables interrupts\r\n3 Print data register\r\n  The print data register is thirty-seven bits wide, and accepts data in\r\n  elephantcode, the precursor to Unicode.  Paper advance is accomplished\r\n  with the Rocket Return and Page Trampoline characters.\r\n1 Configuration\r\n  The Whizbang 100 requires 4 address slots on the LooneyBus.\r\n+  SET WHIZBANG LUNA 11\r\n  will assign the controller to its default bus address.\r\n2 $Set commands\r\n  The output codeset can be ASCII or elephantcode\r\n+ SET WHIZBANG CODESET ASCII\r\n+   SET WHIZBANG CODESET ELEPHANTCODE\r\n\r\n  The VFU (carriage control tape) is specified with\r\n+ SET WHIZBANG TAPE vfufile\r\n2 WOS\r\n  Under WOS, the device will only work at LooneyBus slot 9\r\n2 RTG\r\n  The RTG driver has been lost.  It is not known if the\r\n  Whizbang will operate correctly.\r\n2 Files\r\n  The VFU is programmed with an ASCII text file.  Each line of the\r\n  file corresponds to a line of the form.  Enter the channel numbers\r\n  as base 33 roman numerals.\r\n2 Examples\r\n  TBS\r\n1 Operation\r\n  Specify the host file to receive output using the\r\n+ATTACH WHIZBANG filespec\r\n command.\r\n1 Monitoring\r\n  The Whizbang has no lights or switches.  The model X may be located\r\n  with the\r\n+SHOW WHIZBANG LOCATION\r\n simulator command.\r\n2 $Show commands\r\n1 Restrictions\r\n The emulator is limited to a single Whizbang controller.\r\n1 Debugging\r\n The only implemented debugging command is\r\n+ SET WHIZBANG DEBUG=PRAY\r\n To stop:\r\n+ SET WHIZBANG NODEBUG=PRAY\r\n1 Related Devices\r\n  See also the Whizbang paper shredder (SHRED).\r\n *\r\n */\r\n\r\n#define T(level, text) #level \" \" #text \"\\n\"\r\n#define L(text) \" \" #text \"\\n\"\r\n\r\n#endif\r\n"
        },
        {
          "name": "sigma",
          "type": "tree",
          "content": null
        },
        {
          "name": "sim_BuildROMs.c",
          "type": "blob",
          "size": 21.560546875,
          "content": "/* sim_buildROMs.c: Boot ROM / Boot program load internal support\r\n\r\n   Copyright (c) 2011, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   MARK PIZZOLATO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n*/\r\n#include <stdio.h>\r\n#include <errno.h>\r\n#include <stdlib.h>\r\n/*\r\n\r\n   This program builds C include files which can be used to contain the contents\r\n   of ROM or other boot code needed by simulators.\r\n\r\n   Current Internal ROM files being built:\r\n\r\n      ROM/Boot File:     Include File:            Size:                 Checksum:\r\n      =======================================================================================\r\n*/\r\nstruct ROM_File_Descriptor {\r\n    const char *BinaryName;             const char *IncludeFileName; size_t expected_size; unsigned int checksum;  const char *ArrayName;            const char *Comments;} ROMs[] = {\r\n   {\"VAX/ka655x.bin\",                   \"VAX/vax_ka655x_bin.h\",                    131072,            0xFF7673B6,        \"vax_ka655x_bin\"},\r\n   {\"VAX/ka620.bin\",                    \"VAX/vax_ka620_bin.h\",                      65536,            0xFF7F930F,        \"vax_ka620_bin\"},\r\n   {\"VAX/ka630.bin\",                    \"VAX/vax_ka630_bin.h\",                      65536,            0xFF7F73EF,        \"vax_ka630_bin\"},\r\n   {\"VAX/ka610.bin\",                    \"VAX/vax_ka610_bin.h\",                      16384,            0xFFEF3312,        \"vax_ka610_bin\"},\r\n   {\"VAX/ka410.bin\",                    \"VAX/vax_ka410_bin.h\",                     262144,            0xFEDA0B61,        \"vax_ka410_bin\"},\r\n   {\"VAX/ka411.bin\",                    \"VAX/vax_ka411_bin.h\",                     262144,            0xFECB7EE3,        \"vax_ka411_bin\"},\r\n   {\"VAX/ka412.bin\",                    \"VAX/vax_ka412_bin.h\",                     262144,            0xFED96BB4,        \"vax_ka412_bin\"},\r\n   {\"VAX/ka41a.bin\",                    \"VAX/vax_ka41a_bin.h\",                     262144,            0xFECBAD2E,        \"vax_ka41a_bin\"},\r\n   {\"VAX/ka41d.bin\",                    \"VAX/vax_ka41d_bin.h\",                     262144,            0xFECB8513,        \"vax_ka41d_bin\"},\r\n   {\"VAX/ka42a.bin\",                    \"VAX/vax_ka42a_bin.h\",                     262144,            0xFED8967F,        \"vax_ka42a_bin\"},\r\n   {\"VAX/ka42b.bin\",                    \"VAX/vax_ka42b_bin.h\",                     262144,            0xFECBB2EF,        \"vax_ka42b_bin\"},\r\n   {\"VAX/ka43a.bin\",                    \"VAX/vax_ka43a_bin.h\",                     262144,            0xFEAB1DF9,        \"vax_ka43a_bin\"},\r\n   {\"VAX/ka46a.bin\",                    \"VAX/vax_ka46a_bin.h\",                     262144,            0xFE8D094C,        \"vax_ka46a_bin\"},\r\n   {\"VAX/ka47a.bin\",                    \"VAX/vax_ka47a_bin.h\",                     262144,            0xFE8D8DDA,        \"vax_ka47a_bin\"},\r\n   {\"VAX/ka48a.bin\",                    \"VAX/vax_ka48a_bin.h\",                     262144,            0xFEBB854D,        \"vax_ka48a_bin\"},\r\n   {\"VAX/is1000.bin\",                   \"VAX/vax_is1000_bin.h\",                    524288,            0xFCBCD74A,        \"vax_is1000_bin\"},\r\n   {\"VAX/ka410_xs.bin\",                 \"VAX/vax_ka410_xs_bin.h\",                   32768,            0xFFD8BD83,        \"vax_ka410_xs_bin\"},\r\n   {\"VAX/ka420_rdrz.bin\",               \"VAX/vax_ka420_rdrz_bin.h\",                131072,            0xFF747E93,        \"vax_ka420_rdrz_bin\"},\r\n   {\"VAX/ka420_rzrz.bin\",               \"VAX/vax_ka420_rzrz_bin.h\",                131072,            0xFF7A9A51,        \"vax_ka420_rzrz_bin\"},\r\n   {\"VAX/ka4xx_4pln.bin\",               \"VAX/vax_ka4xx_4pln_bin.h\",                 65536,            0xFF9CD286,        \"vax_ka4xx_4pln_bin\"},\r\n   {\"VAX/ka4xx_8pln.bin\",               \"VAX/vax_ka4xx_8pln_bin.h\",                 65536,            0xFFA2FF59,        \"vax_ka4xx_8pln_bin\"},\r\n   {\"VAX/ka4xx_dz.bin\",                 \"VAX/vax_ka4xx_dz_bin.h\",                   32768,            0xFFD84C02,        \"vax_ka4xx_dz_bin\"},\r\n   {\"VAX/ka4xx_spx.bin\",                \"VAX/vax_ka4xx_spx_bin.h\",                 131072,            0xFF765752,        \"vax_ka4xx_spx_bin\"},\r\n   {\"VAX/ka750_new.bin\",                \"VAX/vax_ka750_bin_new.h\",                   1024,            0xFFFE7BE5,        \"vax_ka750_bin_new\", \"From ROM set: E40A9, E41A9, E42A9, E43A9 (Boots: A=DD, B=DB, C=DU)\"},\r\n   {\"VAX/ka750_old.bin\",                \"VAX/vax_ka750_bin_old.h\",                   1024,            0xFFFEBAA5,        \"vax_ka750_bin_old\", \"From ROM set: 990A9, 948A9, 906A9, 905A9 (Boots: A=DD, B=DM, C=DL, D=DU)\"},\r\n   {\"VAX/vcb02.bin\",                    \"VAX/vax_vcb02_bin.h\",                      16384,            0xFFF1D2AD,        \"vax_vcb02_bin\"},\r\n   {\"VAX/vmb.exe\",                      \"VAX/vax_vmb_exe.h\",                        44544,            0xFFC014BB,        \"vax_vmb_exe\"},\r\n   {\"PDP11/lunar11/lunar.lda\",          \"PDP11/pdp11_vt_lunar_rom.h\",               13824,            0xFFF15D00,        \"lunar_lda\"},\r\n   {\"PDP11/dazzledart/dazzle.lda\",      \"PDP11/pdp11_dazzle_dart_rom.h\",             6096,            0xFFF83848,        \"dazzle_lda\"},\r\n   {\"PDP11/11logo/11logo.lda\",          \"PDP11/pdp11_11logo_rom.h\",                 26009,            0xFFDD77F7,        \"logo_lda\"},\r\n   {\"swtp6800/swtp6800/swtbugv10.bin\",  \"swtp6800/swtp6800/swtp_swtbugv10_bin.h\",    1024,            0xFFFE4FBC,        \"swtp_swtbugv10_bin\"},\r\n   };\r\n\r\n\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <time.h>\r\n#include <sys/stat.h>\r\n\r\n#define MAX_CONCURRENT_ROMS 4\r\n\r\n#if defined(_WIN32)\r\n#include <sys/utime.h>\r\n#define utimbuf _utimbuf \r\n#define utime _utime\r\n#define snprintf _snprintf\r\n#else\r\n#include <utime.h>\r\n#include <unistd.h>\r\n#endif\r\n\r\nint sim_read_ROM_include(const char *include_filename, \r\n                         size_t *psize,\r\n                         unsigned char **pROMData,\r\n                         unsigned int *pchecksum,\r\n                         char **prom_array_name,\r\n                         int *defines_found)\r\n{\r\nFILE *iFile;\r\nchar line[256], cmpbuf[256];\r\nsize_t i;\r\nsize_t bytes_written = 0;\r\nsize_t allocated_size = 0;\r\nint define_size_found = 0;\r\nint define_filename_found = 0;\r\nint define_array_found = 0;\r\n\r\n*psize = 0;\r\n*pchecksum = 0;\r\n*pROMData = NULL;\r\n*prom_array_name = NULL;\r\nif (NULL == (iFile = fopen (include_filename, \"r\")))\r\n    return -1;\r\n\r\nmemset (line, 0, sizeof (line));\r\n\r\nwhile (fgets (line, sizeof(line)-1, iFile)) {\r\n    unsigned int byte;\r\n    char *c;\r\n\r\n    switch (line[0]) {\r\n        case '#':\r\n            snprintf (cmpbuf, sizeof (cmpbuf), \"_%d \", MAX_CONCURRENT_ROMS);\r\n            if ((0 == strncmp (\"#define BOOT_CODE_SIZE\", line, 22)) &&\r\n                (0 == strncmp (cmpbuf, &line[22], strlen (cmpbuf))))\r\n                define_size_found = 1;\r\n            if ((0 == strncmp (\"#define BOOT_CODE_FILENAME\", line, 26)) &&\r\n                (0 == strncmp (cmpbuf, &line[26], strlen (cmpbuf))))\r\n                define_filename_found = 1;\r\n            if ((0 == strncmp (\"#define BOOT_CODE_ARRAY\", line, 23)) &&\r\n                (0 == strncmp (cmpbuf, &line[23], strlen (cmpbuf))))\r\n                define_array_found = 1;\r\n            break;\r\n        case ' ':\r\n        case '/':\r\n        case '*':\r\n        case '\\n':\r\n            break;\r\n        case 'u': /* unsigned char {array_name}[] */\r\n            *prom_array_name = (char *)calloc(512, sizeof(char));\r\n            if (1 == sscanf (line, \"unsigned char %s[]\", *prom_array_name)) {\r\n                c = strchr (*prom_array_name, '[');\r\n                if (c)\r\n                    *c = '\\0';\r\n                }\r\n            break;\r\n        case '0': /* line containing byte data */\r\n            c = line;\r\n            while (1 == sscanf (c, \"0x%2Xd,\", &byte)) {\r\n                if (bytes_written >= allocated_size) {\r\n                    allocated_size += 2048;\r\n                    *pROMData = (unsigned char *)realloc(*pROMData, allocated_size);\r\n                    }\r\n                *(*pROMData + bytes_written++) = (unsigned char)byte;\r\n                c += 5;\r\n                }\r\n            break;\r\n        }\r\n    if (strchr (line, '}'))\r\n        break;\r\n    }\r\nfclose (iFile);\r\nfor (i=0; i<bytes_written; ++i)\r\n    *pchecksum += *(*pROMData + i);\r\n*pchecksum = ~*pchecksum;\r\n*psize = bytes_written;\r\n*defines_found = (3 == (define_size_found + define_filename_found + define_array_found));\r\nreturn 0;\r\n}\r\n\r\nint sim_make_ROMs_entry(const char *rom_filename)\r\n{\r\nFILE *rFile;\r\nstruct stat statb;\r\nunsigned char *ROMData = NULL;\r\nunsigned int checksum = 0;\r\nchar *c;\r\nint i;\r\nchar cleaned_rom_filename[512];\r\nchar *include_filename;\r\nchar array_name[512];\r\n\r\nif (NULL == (rFile = fopen (rom_filename, \"rb\"))) {\r\n    printf (\"Error Opening ROM binary file '%s' for input: %s\\n\", rom_filename, strerror(errno));\r\n    return -1;\r\n    }\r\nif (stat (rom_filename, &statb)) {\r\n    printf (\"Error stating '%s': %s\\n\", rom_filename, strerror(errno));\r\n    fclose (rFile);\r\n    return -1;\r\n    }\r\nROMData = (unsigned char *)malloc (statb.st_size);\r\nif ((size_t)(statb.st_size) != fread (ROMData, sizeof(*ROMData), statb.st_size, rFile)) {\r\n    printf (\"Error reading '%s': %s\\n\", rom_filename, strerror(errno));\r\n    fclose (rFile);\r\n    free (ROMData);\r\n    return -1;\r\n    }\r\nfclose (rFile);\r\nfor (i=0; i<statb.st_size; ++i)\r\n    checksum += ROMData[i];\r\nchecksum = ~checksum;\r\nstrncpy (cleaned_rom_filename, rom_filename, sizeof(cleaned_rom_filename)-2);\r\ncleaned_rom_filename[sizeof(cleaned_rom_filename)-1] = '\\0';\r\nwhile ((c = strchr (cleaned_rom_filename, '\\\\')))\r\n    *c = '/';\r\nstrcpy (array_name, cleaned_rom_filename);\r\nfor (c=array_name; *c; ++c)\r\n    if (isupper(*c))\r\n        *c = (char)tolower(*c);\r\nif ((c = strchr (array_name, '.')))\r\n    *c = '_';\r\nif ((c = strchr (array_name, '/')))\r\n    *c = '_';\r\ninclude_filename = (char *)calloc (3 + strlen (cleaned_rom_filename), sizeof (*include_filename));\r\nsprintf (include_filename, \"%s.h\", cleaned_rom_filename);\r\nif ((c = strrchr (include_filename, '/')))\r\n    sprintf (c+1, \"%s.h\", array_name);\r\nelse\r\n    sprintf (include_filename, \"%s.h\", array_name);\r\nprintf (\"The ROMs array entry for this new ROM image file should look something like:\\n\");\r\nprintf (\"{\\\"%s\\\",    \\\"%s\\\",     %d,  0x%08X, \\\"%s\\\"}\\n\",\r\n        rom_filename, include_filename, (int)(statb.st_size), checksum, array_name);\r\nfree (include_filename);\r\nfree (ROMData);\r\nreturn 1;\r\n}\r\n\r\nint sim_make_ROM_include(const char *rom_filename,\r\n                         size_t expected_size,\r\n                         unsigned int expected_checksum,\r\n                         const char *include_filename, \r\n                         const char *rom_array_name,\r\n                         const char *Comments)\r\n{\r\nFILE *rFile;\r\nFILE *iFile;\r\ntime_t now;\r\nint bytes_written = 0;\r\nsize_t include_bytes;\r\nint c;\r\nint rom;\r\nstruct stat statb;\r\nconst char *load_filename;\r\nunsigned char *ROMData = NULL;\r\nunsigned char *include_ROMData = NULL;\r\nchar *include_array_name = NULL;\r\nunsigned int checksum = 0;\r\nunsigned int include_checksum;\r\nint defines_found;\r\n\r\nif (NULL == (rFile = fopen (rom_filename, \"rb\"))) {\r\n    printf (\"Error Opening ROM binary file '%s' for input: %s\\n\", rom_filename, strerror(errno));\r\n    if (0 != sim_read_ROM_include(include_filename, \r\n                                  &include_bytes,\r\n                                  &include_ROMData,\r\n                                  &include_checksum,\r\n                                  &include_array_name,\r\n                                  &defines_found))\r\n        return -1;\r\n    c = ((include_checksum == expected_checksum) && \r\n         (include_bytes == expected_size) &&\r\n         (0 == strcmp(include_array_name, rom_array_name)) &&\r\n         defines_found);\r\n    free(include_ROMData);\r\n    free(include_array_name);\r\n    if (!c)\r\n        printf (\"Existing ROM include file: %s has unexpected content\\n\", include_filename);\r\n    else\r\n        printf (\"Existing ROM include file: %s looks good\\n\", include_filename);\r\n    return (c ? 0 : -1);\r\n    }\r\nif (stat (rom_filename, &statb)) {\r\n    printf (\"Error stating '%s': %s\\n\", rom_filename, strerror(errno));\r\n    fclose (rFile);\r\n    return -1;\r\n    }\r\nif ((size_t)statb.st_size != expected_size) {\r\n    printf (\"Error: ROM file '%s' has an unexpected size: %d vs %d\\n\", rom_filename, (int)statb.st_size, (int)expected_size);\r\n    printf (\"This can happen if the file was transferred or unpacked incorrectly\\n\");\r\n    printf (\"and in the process tried to convert line endings rather than passing\\n\");\r\n    printf (\"the file's contents unmodified\\n\");\r\n    fclose (rFile);\r\n    return -1;\r\n    }\r\nROMData = (unsigned char *)malloc (statb.st_size);\r\nif ((size_t)(statb.st_size) != fread (ROMData, sizeof(*ROMData), statb.st_size, rFile)) {\r\n    printf (\"Error reading '%s': %s\\n\", rom_filename, strerror(errno));\r\n    fclose (rFile);\r\n    free (ROMData);\r\n    return -1;\r\n    }\r\nfclose (rFile);\r\nfor (c=0; c<statb.st_size; ++c)\r\n    checksum += ROMData[c];\r\nchecksum = ~checksum;\r\nif ((expected_checksum != 0) && (checksum != expected_checksum)) {\r\n    printf (\"Error: ROM file '%s' has an unexpected checksum: 0x%08X vs 0x%08X\\n\", rom_filename, checksum, expected_checksum);\r\n    printf (\"This can happen if the file was transferred or unpacked incorrectly\\n\");\r\n    printf (\"and in the process tried to convert line endings rather than passing\\n\");\r\n    printf (\"the file's contents unmodified\\n\");\r\n    free (ROMData);\r\n    return -1;\r\n    }\r\n/*\r\n * If the target include file already exists, determine if it contains the exact\r\n * data in the base ROM image.  If so, then we are already done\r\n */\r\nif (0 == sim_read_ROM_include(include_filename, \r\n                              &include_bytes,\r\n                              &include_ROMData,\r\n                              &include_checksum,\r\n                              &include_array_name,\r\n                              &defines_found)) {\r\n    c = ((include_checksum == expected_checksum) && \r\n         (include_bytes == expected_size) &&\r\n         (0 == strcmp (include_array_name, rom_array_name)) &&\r\n         (0 == memcmp (include_ROMData, ROMData, include_bytes)) &&\r\n         defines_found);\r\n    free(include_ROMData);\r\n    free(include_array_name);\r\n    if (c) {\r\n        free (ROMData);\r\n        return 0;\r\n        }\r\n    }\r\n\r\n/* Open output file in binary mode for consistency with all simh \r\n   source files that have CRLF line endings with explicit writes of \\r\\n */\r\nif (NULL == (iFile = fopen (include_filename, \"wb\"))) {\r\n    printf (\"Error Opening '%s' for output: %s\\n\", include_filename, strerror(errno));\r\n    free (ROMData);\r\n    return -1;\r\n    }\r\nload_filename = strrchr (rom_filename, '/');\r\nif (load_filename)\r\n    ++load_filename;\r\nelse\r\n    load_filename = rom_filename;\r\ntime (&now);\r\nfprintf (iFile, \"#ifndef ROM_%s_H\\r\\n\", rom_array_name);\r\nfprintf (iFile, \"#define ROM_%s_H 0\\r\\n\", rom_array_name);\r\nfprintf (iFile, \"/*\\r\\n\");\r\nfprintf (iFile, \"   %s         produced at %24.24s\\r\\n\", include_filename, ctime(&now));\r\nfprintf (iFile, \"   from %s which was last modified at %24.24s\\r\\n\", rom_filename, ctime(&statb.st_mtime));\r\nfprintf (iFile, \"   file size: %d (0x%X) - checksum: 0x%08X\\r\\n\", (int)statb.st_size, (int)statb.st_size, checksum);\r\nfprintf (iFile, \"   This file is a generated file and should NOT be edited or changed by hand.\\r\\n\");\r\nif (Comments)\r\n    fprintf (iFile, \"\\r\\n   %s\\r\\n\\r\\n\", Comments);\r\nfprintf (iFile, \"*/\\r\\n\");\r\nfprintf (iFile, \"#if !defined(BOOT_CODE_SIZE)\\r\\n\");\r\nfprintf (iFile, \"#define BOOT_CODE_SIZE 0x%X\\r\\n\", (int)statb.st_size);\r\nfprintf (iFile, \"#define BOOT_CODE_CHECKSUM 0x%X\\r\\n\", checksum);\r\nfprintf (iFile, \"#define BOOT_CODE_FILENAME \\\"%s\\\"\\r\\n\", load_filename);\r\nfprintf (iFile, \"#define BOOT_CODE_FILEPATH \\\"%s\\\"\\r\\n\", rom_filename);\r\nfprintf (iFile, \"#if defined(DONT_USE_INTERNAL_ROM)\\r\\n\");\r\nfprintf (iFile, \"#define BOOT_CODE_ARRAY NULL\\r\\n\");\r\nfprintf (iFile, \"#else\\r\\n\");\r\nfprintf (iFile, \"#define BOOT_CODE_ARRAY %s\\r\\n\", rom_array_name);\r\nfprintf (iFile, \"#endif\\r\\n\");\r\nfprintf (iFile, \"#define BOOT_CODE_URL NULL\\r\\n\");\r\nfor (rom = 1; rom <= MAX_CONCURRENT_ROMS; rom++) {\r\n    fprintf (iFile, \"%s !defined(BOOT_CODE_SIZE_%d)\\r\\n\", (rom == 1) ? \"#endif\\r\\n#if\" : \"#elif\", rom);\r\n    fprintf (iFile, \"#define BOOT_CODE_SIZE_%d 0x%X\\r\\n\", rom, (int)statb.st_size);\r\n    fprintf (iFile, \"#define BOOT_CODE_CHECKSUM_%d 0x%X\\r\\n\", rom, checksum);\r\n    fprintf (iFile, \"#define BOOT_CODE_FILENAME_%d \\\"%s\\\"\\r\\n\", rom, load_filename);\r\n    fprintf (iFile, \"#define BOOT_CODE_FILEPATH_%d \\\"%s\\\"\\r\\n\", rom, rom_filename);\r\n    fprintf (iFile, \"#if defined(DONT_USE_INTERNAL_ROM)\\r\\n\");\r\n    fprintf (iFile, \"#define BOOT_CODE_ARRAY_%d NULL\\r\\n\", rom);\r\n    fprintf (iFile, \"#else\\r\\n\");\r\n    fprintf (iFile, \"#define BOOT_CODE_ARRAY_%d %s\\r\\n\", rom, rom_array_name);\r\n    fprintf (iFile, \"#endif\\r\\n\");\r\n    fprintf (iFile, \"#define BOOT_CODE_URL_%d NULL\\r\\n\", rom);\r\n    }\r\nfprintf (iFile, \"#endif\\r\\n\");\r\nfprintf (iFile, \"#if !defined(DONT_USE_INTERNAL_ROM)\\r\\n\");\r\nfprintf (iFile, \"unsigned char %s[] = {\", rom_array_name);\r\nfor (bytes_written=0;bytes_written<statb.st_size; ++bytes_written) {\r\n    c = ROMData[bytes_written];\r\n    if (0 == bytes_written%16)\r\n        fprintf (iFile, \"\\r\\n\");\r\n    fprintf (iFile,\"0x%02X,\", c&0xFF);\r\n    }\r\nfree (ROMData);\r\nfprintf (iFile,\"};\\r\\n\");\r\nfprintf (iFile, \"#endif\\r\\n\");\r\nfprintf (iFile, \"#endif /* ROM_%s_H */\\r\\n\", rom_array_name);\r\nfclose (iFile);\r\nif (1) { /* Set Modification Time on the include file to be the modification time of the ROM file */\r\n    struct utimbuf times;\r\n\r\n    times.modtime = statb.st_mtime;\r\n    times.actime = statb.st_atime;\r\n    utime (include_filename, &times);\r\n    }\r\nreturn 0;\r\n}\r\n\r\nvoid\r\nUsage(void)\r\n{\r\nsize_t i;\r\n\r\nprintf (\"sim_BuildROMs Usage:\\n\");\r\nprintf (\"sim_BuildROMs\\n\");\r\nprintf (\"                  invoked with no arguments will verify and/or produce all\\n\");\r\nprintf (\"                  known ROM include files\\n\");\r\nprintf (\"sim_BuildROMs -rebuild\\n\");\r\nprintf (\"                  invoked with the single -rebuild argument will force rebuilding\\n\");\r\nprintf (\"                  of all ROM include files\\n\");\r\nprintf (\"sim_BuildROMs -checksum ROM-File-name\\n\");\r\nprintf (\"                  computes the checksum on a ROM image file and provides a\\n\");\r\nprintf (\"                  template which can be added to the ROMs array in the\\n\");\r\nprintf (\"                  source file sim_BuildROMs.c\\n\");\r\nprintf (\"sim_BuildROMs ROM-File-name\\n\");\r\nprintf (\"                  if the 'ROM-File-name' specified is a file name already\\n\");\r\nprintf (\"                  contained in the ROMs array, only that ROM image file's\\n\");\r\nprintf (\"                  include file will be verified and/or created\\n\");\r\nprintf (\"                  if the 'ROM-File-name' specified is not a file name already\\n\");\r\nprintf (\"                  contained in the ROMs array, that ROM's checksum is computed\\n\");\r\nprintf (\"                  and a template which can be added to the ROMs array in the\\n\");\r\nprintf (\"                  source file sim_BuildROMs.c is displayed.\\n\");\r\nprintf (\"\\n\");\r\nprintf (\"Current ROM files:\\n\");\r\nprintf (\"\\n\");\r\nprintf (\"BinaryName:      IncludeFileName:          Size:   Checksum:  ROM Array Name:\\n\");\r\nprintf (\"=============================================================================\\n\");\r\nfor (i=0; i<sizeof(ROMs)/sizeof(ROMs[0]); ++i)\r\n    printf(\"%-17s%-23s%8d  0x%08X  %s\\n\", ROMs[i].BinaryName, ROMs[i].IncludeFileName, (int)ROMs[i].expected_size, ROMs[i].checksum, ROMs[i].ArrayName);\r\nexit(2);\r\n}\r\n\r\nint\r\nmain(int argc, char **argv)\r\n{\r\nsize_t i;\r\nint status = 0;\r\nint rebuild = 0;\r\n\r\nif ((argc == 2) && (strcmp (argv[1], \"-rebuild\") == 0)) {\r\n    rebuild = 1;\r\n    --argc;\r\n    ++argv;\r\n    }\r\nif (argc == 1) {  /* invoked without any arguments */\r\n    for (i=0; i<sizeof(ROMs)/sizeof(ROMs[0]); ++i) {\r\n        if (rebuild)\r\n            unlink (ROMs[i].IncludeFileName);\r\n        status += sim_make_ROM_include (ROMs[i].BinaryName, ROMs[i].expected_size, ROMs[i].checksum, ROMs[i].IncludeFileName, ROMs[i].ArrayName, ROMs[i].Comments);\r\n        }\r\n    exit((status == 0) ? 0 : 2);\r\n    }\r\nif ((0 == strcmp(argv[1], \"/?\")) ||\r\n    (0 == strcmp(argv[1], \"-?\")) ||\r\n    (0 == strcmp(argv[1], \"/help\")) ||\r\n    (0 == strcmp(argv[1], \"-help\")))\r\n    Usage();\r\nif ((0 == strcmp(argv[1], \"-checksum\")) && (argc > 2))\r\n    status = sim_make_ROMs_entry (argv[2]);\r\nelse {\r\n    for (i=0; i<sizeof(ROMs)/sizeof(ROMs[0]); ++i)\r\n        if (0 == strcmp(argv[1], ROMs[i].BinaryName))\r\n            break;\r\n    if (i == sizeof(ROMs)/sizeof(ROMs[0]))\r\n        status = sim_make_ROMs_entry (argv[1]);\r\n    else\r\n        status = sim_make_ROM_include (ROMs[i].BinaryName, ROMs[i].expected_size, ROMs[i].checksum, ROMs[i].IncludeFileName, ROMs[i].ArrayName, ROMs[i].Comments);\r\n    }\r\nexit((status == 0) ? 0 : 2);\r\n}\r\n"
        },
        {
          "name": "sim_card.c",
          "type": "blob",
          "size": 57.001953125,
          "content": "/* Generic Card read/punch routines for simulators.\r\n\r\n   Copyright (c) 2005, Richard Cornwell\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   This is the standard card reader.\r\n   This is the standard card punch.\r\n\r\n   Input formats are accepted in a variaty of formats:\r\n        Standard ASCII: one record per line.\r\n                returns are ignored.\r\n                tabs are expanded to modules 8 characters.\r\n                ~ in first column is treated as a EOF.\r\n\r\n        Binary Card format:\r\n                Each record 160 characters.\r\n                First characters 6789----\r\n                Second character 21012345\r\n                                 111\r\n                Top 4 bits of second character are 0.\r\n                It is unlikely that any other format could\r\n                look like this.\r\n\r\n        BCD Format:\r\n                Each record variable length (80 chars or less).\r\n                Record mark has bit 7 set.\r\n                Bit 6 is even parity.\r\n                Bits 5-0 are character.\r\n\r\n        CBN Format:\r\n                Each record 160 charaters.\r\n                First char has bit 7 set. Rest set to 0.\r\n                Bit 6 is odd parity.\r\n                Bit 5-0 of first character are top 6 bits\r\n                        of card.\r\n                Bit 5-0 of second character are lower 6 bits\r\n                        of card.\r\n\r\n    ASCII mode recognizes some additional forms of input which allows the\r\n    intermixing of binary cards with text cards.\r\n\r\n    Lines beginning with ~raw are taken as a number of 4 digit octal values\r\n    with represent each column of the card from 12 row down to 9 row. If there\r\n    is not enough octal numbers to span a full card the remainder of the\r\n    card will not be punched.\r\n\r\n    Also ~eor, will generate a 7/8/9 punch card. An ~eof will gernerate a\r\n    6/7/9 punch card, and a ~eoi will generate a 6/7/8/9 punch.\r\n\r\n    A single line of ~ will set the EOF flag when that card is read.\r\n\r\n    For autodetection of card format, there can be no parity errors.\r\n    All undeterminate formats are treated as ASCII. CBN and BCD cards\r\n    must also contain short or full records, if the record is not terminate\r\n    early by a EOR flag, then only up to record size (80 for BCD and\r\n    160 for CBN will be read).\r\n\r\n    Auto output format is ASCII if card has only printable characters\r\n    or card format binary.\r\n\r\n    The card module uses up7 to hold a buffer for the card being translated\r\n    and the backward translation table. Which is generated from the table.\r\n*/\r\n\f\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_card.h\"\r\n\r\n#if defined(USE_SIM_CARD)\r\n\r\n#define card_ctx up8\r\n\r\n#define CARD_EOF          0x1000         /* This card is end of file card. */\r\n#define CARD_ERR          0x2000         /* Return error for this card */\r\n#define DECK_SIZE         1000           /* Number of cards to allocate at a time */\r\n\r\n\r\nstruct card_context\r\n{\r\n    t_addr              punch_count;     /* Number of cards punched */\r\n    char                cbuff[1024];     /* Read in buffer for cards */\r\n    uint8               hol_to_ascii[4096]; /* Back conversion table */\r\n    t_addr              hopper_size;     /* Size of hopper */\r\n    t_addr              hopper_cards;    /* Number of cards in hopper */\r\n    uint16              (*images)[1][80];\r\n};\r\n\r\n/* Character conversion tables */\r\n\r\nconst char          sim_six_to_ascii[64] = {\r\n    ' ', '1', '2', '3', '4', '5', '6', '7',\r\n    '8', '9', '0', '=', '\\'', ':', '>', '%',    /* 17 = box */\r\n    '_', '/', 'S', 'T', 'U', 'V', 'W', 'X',\r\n    'Y', 'Z', '@', ',', '(', '~', '\\\\', '#',\r\n    '-', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\r\n    'Q', 'R', '!', '$', '*', ']', ';', '^',     /* 57 = triangle */\r\n    '+', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\r\n    'H', 'I', '?', '.', ')', '[', '<', '@',     /* 37 = stop code */\r\n};                              /* 72 = rec mark */\r\n                                /* 75 = squiggle, 77 = del */\r\n\r\nstatic const uint16          ascii_to_hol_026[128] = {\r\n   /* Control                              */\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,    /*0-37*/\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*  sp      !      \"      #      $      %      &      ' */\r\n   /* none   Y28    78     T28    Y38    T48    XT     48  */\r\n    0x000, 0x600, 0x006, 0x282, 0x442, 0x222, 0xA00, 0x022,     /* 40 - 77 */\r\n   /*   (      )      *      +      ,      -      .      / */\r\n   /* T48    X48    Y48    X      T38    T      X38    T1  */\r\n    0x222, 0x822, 0x422, 0x800, 0x242, 0x400, 0x842, 0x300,\r\n   /*   0      1      2      3      4      5      6      7 */\r\n   /* T      1      2      3      4      5      6      7   */\r\n    0x200, 0x100, 0x080, 0x040, 0x020, 0x010, 0x008, 0x004,\r\n   /*   8      9      :      ;      <      =      >      ? */\r\n   /* 8      9      58     Y68    X68    38     68     X28 */\r\n    0x002, 0x001, 0x012, 0x40A, 0x80A, 0x042, 0x00A, 0x882,\r\n   /*   @      A      B      C      D      E      F      G */\r\n   /*  82    X1     X2     X3     X4     X5     X6     X7  */\r\n    0x022, 0x900, 0x880, 0x840, 0x820, 0x810, 0x808, 0x804,     /* 100 - 137 */\r\n   /*   H      I      J      K      L      M      N      O */\r\n   /* X8     X9     Y1     Y2     Y3     Y4     Y5     Y6  */\r\n    0x802, 0x801, 0x500, 0x480, 0x440, 0x420, 0x410, 0x408,\r\n   /*   P      Q      R      S      T      U      V      W */\r\n   /* Y7     Y8     Y9     T2     T3     T4     T5     T6  */\r\n    0x404, 0x402, 0x401, 0x280, 0x240, 0x220, 0x210, 0x208,\r\n   /*   X      Y      Z      [      \\      ]      ^      _ */\r\n   /* T7     T8     T9     X58    X68    T58    T78     28 */\r\n    0x204, 0x202, 0x201, 0x812, 0x20A, 0x412, 0x406, 0x082,\r\n   /*   `      a      b      c      d      e      f      g */\r\n    0x212, 0xB00, 0xA80, 0xA40, 0xA20, 0xA10, 0xA08, 0xA04,     /* 140 - 177 */\r\n   /*   h      i      j      k      l      m      n      o */\r\n    0xA02, 0xA01, 0xD00, 0xC80, 0xC40, 0xC20, 0xC10, 0xC08,\r\n   /*   p      q      r      s      t      u      v      w */\r\n    0xC04, 0xC02, 0xC01, 0x680, 0x640, 0x620, 0x610, 0x608,\r\n   /*   x      y      z      {      |      }      ~    del */\r\n   /*                     T79     X78   X79     79         */\r\n    0x604, 0x602, 0x601, 0x406, 0x806, 0x805, 0x005, 0xf000\r\n};\r\n\r\n/* Set for Burrough codes */\r\nstatic const uint16          ascii_to_hol_029[128] = {\r\n   /* Control                              */\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,    /*0-37*/\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*  sp      !      \"      #      $      %      &      ' */\r\n   /* none   X28    78      38    Y38    T48    X      58  */\r\n    0x000, 0x482, 0x006, 0x042, 0x442, 0x222, 0x800, 0x012,     /* 40 - 77 */\r\n   /*   (      )      *      +      ,      -      .      / */\r\n   /* X58    Y58    Y48    X68    T38    Y      X38    T1  */\r\n    0x812, 0x412, 0x422, 0x80A, 0x242, 0x400, 0x842, 0x300,\r\n   /*   0      1      2      3      4      5      6      7 */\r\n   /* T      1      2      3      4      5      6      7   */\r\n    0x200, 0x100, 0x080, 0x040, 0x020, 0x010, 0x008, 0x004,\r\n   /*   8      9      :      ;      <      =      >      ? */\r\n   /* 8      9      28     Y68    X48     68    T68    T78 */\r\n    0x002, 0x001, 0x082, 0x40A, 0x822, 0x00A, 0x20A, 0x206,\r\n   /*   @      A      B      C      D      E      F      G */\r\n   /*  48    X1     X2     X3     X4     X5     X6     X7  */\r\n    0x022, 0x900, 0x880, 0x840, 0x820, 0x810, 0x808, 0x804,     /* 100 - 137 */\r\n   /*   H      I      J      K      L      M      N      O */\r\n   /* X8     X9     Y1     Y2     Y3     Y4     Y5     Y6  */\r\n    0x802, 0x801, 0x500, 0x480, 0x440, 0x420, 0x410, 0x408,\r\n   /*   P      Q      R      S      T      U      V      W */\r\n   /* Y7     Y8     Y9     T2     T3     T4     T5     T6  */\r\n    0x404, 0x402, 0x401, 0x280, 0x240, 0x220, 0x210, 0x208,\r\n   /*   X      Y      Z      [      \\      ]      ^      _ */\r\n   /* T7     T8     T9   TY028    T28  TY038    Y78    T58 */\r\n    0x204, 0x202, 0x201, 0xE82, 0x282, 0xE42, 0x406, 0x212,\r\n   /*   `      a      b      c      d      e      f      g */\r\n    0x102 ,0xB00, 0xA80, 0xA40, 0xA20, 0xA10, 0xA08, 0xA04,     /* 140 - 177 */\r\n   /*   h      i      j      k      l      m      n      o */\r\n    0xA02, 0xA01, 0xD00, 0xC80, 0xC40, 0xC20, 0xC10, 0xC08,\r\n   /*   p      q      r      s      t      u      v      w */\r\n    0xC04, 0xC02, 0xC01, 0x680, 0x640, 0x620, 0x610, 0x608,\r\n   /*   x      y      z      {      |      }      ~    del */\r\n   /*                      Y78    X78    X79  XTY18        */\r\n    0x604, 0x602, 0x601, 0x406, 0x806, 0x805, 0xF02,0xf000\r\n};\r\n\r\n/* Set for DEC 029 codes */\r\nstatic const uint16          ascii_to_dec_029[128] = {\r\n   /* Control                              */\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,    /*0-37*/\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*  sp      !      \"      #      $      %      &      ' */\r\n   /* none   Y28    78      38    Y38    T48    X      58  */\r\n    0x000, 0x482, 0x006, 0x042, 0x442, 0x222, 0x800, 0x012,     /* 40 - 77 */\r\n   /*   (      )      *      +      ,      -      .      / */\r\n   /* X58    Y58    Y48    X68    T38    Y      X38    T1  */\r\n    0x812, 0x412, 0x422, 0x80A, 0x242, 0x400, 0x842, 0x300,\r\n   /*   0      1      2      3      4      5      6      7 */\r\n   /* T      1      2      3      4      5      6      7   */\r\n    0x200, 0x100, 0x080, 0x040, 0x020, 0x010, 0x008, 0x004,\r\n   /*   8      9      :      ;      <      =      >      ? */\r\n   /* 8      9      28     Y68    X48     68    T68    T78 */\r\n    0x002, 0x001, 0x082, 0x40A, 0x822, 0x00A, 0x20A, 0x206,\r\n   /*   @      A      B      C      D      E      F      G */\r\n   /*  48    X1     X2     X3     X4     X5     X6     X7  */\r\n    0x022, 0x900, 0x880, 0x840, 0x820, 0x810, 0x808, 0x804,     /* 100 - 137 */\r\n   /*   H      I      J      K      L      M      N      O */\r\n   /* X8     X9     Y1     Y2     Y3     Y4     Y5     Y6  */\r\n    0x802, 0x801, 0x500, 0x480, 0x440, 0x420, 0x410, 0x408,\r\n   /*   P      Q      R      S      T      U      V      W */\r\n   /* Y7     Y8     Y9     T2     T3     T4     T5     T6  */\r\n    0x404, 0x402, 0x401, 0x280, 0x240, 0x220, 0x210, 0x208,\r\n   /*   X      Y      Z      [      \\      ]      ^      _ */\r\n   /* T7     T8     T9     X28    Y78    T28    X78    T58 */\r\n    0x204, 0x202, 0x201, 0x882, 0x406, 0x282, 0x806, 0x212,\r\n   /*   `      a      b      c      d      e      f      g */\r\n    0x102 ,0xB00, 0xA80, 0xA40, 0xA20, 0xA10, 0xA08, 0xA04,     /* 140 - 177 */\r\n   /*   h      i      j      k      l      m      n      o */\r\n    0xA02, 0xA01, 0xD00, 0xC80, 0xC40, 0xC20, 0xC10, 0xC08,\r\n   /*   p      q      r      s      t      u      v      w */\r\n    0xC04, 0xC02, 0xC01, 0x680, 0x640, 0x620, 0x610, 0x608,\r\n   /*   x      y      z      {      |      }      ~    del */\r\n   /*                       XT     XY     YT    YT1        */\r\n    0x604, 0x602, 0x601, 0xA00, 0xC00, 0x600, 0x700,0xf000\r\n};\r\n\r\n\r\nstatic const uint16          ascii_to_hol_ebcdic[128] = {\r\n   /* Control                              */\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,    /*0-37*/\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*Control*/\r\n    0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,0xf000,\r\n   /*  sp      !      \"      #      $      %      &      ' */\r\n   /* none   Y28    78      38    Y38    T48    X      58  */\r\n    0x000, 0x482, 0x006, 0x042, 0x442, 0x222, 0x800, 0x012,     /* 40 - 77 */\r\n   /*   (      )      *      +      ,      -      .      / */\r\n   /* X58    Y58    Y48    X      T38    Y      X38    T1  */\r\n    0x812, 0x412, 0x422, 0x800, 0x242, 0x400, 0x842, 0x300,\r\n   /*   0      1      2      3      4      5      6      7 */\r\n   /* T      1      2      3      4      5      6      7   */\r\n    0x200, 0x100, 0x080, 0x040, 0x020, 0x010, 0x008, 0x004,\r\n   /*   8      9      :      ;      <      =      >      ? */\r\n   /* 8      9      28     Y68    X48    68     T68    T78 */\r\n    0x002, 0x001, 0x082, 0x40A, 0x822, 0x00A, 0x20A, 0x206,\r\n   /*   @      A      B      C      D      E      F      G */\r\n   /*  48    X1     X2     X3     X4     X5     X6     X7  */\r\n    0x022, 0x900, 0x880, 0x840, 0x820, 0x810, 0x808, 0x804,     /* 100 - 137 */\r\n   /*   H      I      J      K      L      M      N      O */\r\n   /* X8     X9     Y1     Y2     Y3     Y4     Y5     Y6  */\r\n    0x802, 0x801, 0x500, 0x480, 0x440, 0x420, 0x410, 0x408,\r\n   /*   P      Q      R      S      T      U      V      W */\r\n   /* Y7     Y8     Y9     T2     T3     T4     T5     T6  */\r\n    0x404, 0x402, 0x401, 0x280, 0x240, 0x220, 0x210, 0x208,\r\n   /*   X      Y      Z      [      \\      ]      ^      _ */\r\n   /* T7     T8     T9     X28    X68    Y28    Y78    X58 */\r\n    0x204, 0x202, 0x201, 0x882, 0x20A, 0x482, 0x406, 0x212,\r\n   /*   `      a      b      c      d      e      f      g */\r\n    0x102, 0xB00, 0xA80, 0xA40, 0xA20, 0xA10, 0xA08, 0xA04,     /* 140 - 177 */\r\n   /*   h      i      j      k      l      m      n      o */\r\n    0xA02, 0xA01, 0xD00, 0xC80, 0xC40, 0xC20, 0xC10, 0xC08,\r\n   /*   p      q      r      s      t      u      v      w */\r\n    0xC04, 0xC02, 0xC01, 0x680, 0x640, 0x620, 0x610, 0x608,\r\n   /*   x      y      z      {      |      }      ~    del */\r\n   /*                     X18     X78    Y18  XYT18        */\r\n    0x604, 0x602, 0x601, 0x902, 0x806, 0x502, 0xF02,0xf000\r\n};\r\n\r\nconst char          sim_ascii_to_six[128] = {\r\n   /* Control                              */\r\n     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,     /* 0 - 37 */\r\n   /* Control                              */\r\n     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,\r\n   /* Control                              */\r\n     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,\r\n   /* Control                              */\r\n     -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,\r\n   /*sp    !    \"    #    $    %    &    ' */\r\n    000, 052,  -1, 032, 053, 017, 060, 014,     /* 40 - 77 */\r\n   /* (    )    *    +    ,    -    .    / */\r\n    034, 074, 054, 060, 033, 040, 073, 021,\r\n   /* 0    1    2    3    4    5    6    7 */\r\n    012, 001, 002, 003, 004, 005, 006, 007,\r\n   /* 8    9    :    ;    <    =    >    ? */\r\n    010, 011, 015, 056, 076, 013, 016, 072,\r\n   /* @    A    B    C    D    E    F    G */\r\n    014, 061, 062, 063, 064, 065, 066, 067,     /* 100 - 137 */\r\n   /* H    I    J    K    L    M    N    O */\r\n    070, 071, 041, 042, 043, 044, 045, 046,\r\n   /* P    Q    R    S    T    U    V    W */\r\n    047, 050, 051, 022, 023, 024, 025, 026,\r\n   /* X    Y    Z    [    \\    ]    ^    _ */\r\n    027, 030, 031, 075, 036, 055, 057, 020,\r\n   /* `    a    b    c    d    e    f    g */\r\n    035, 061, 062, 063, 064, 065, 066, 067,     /* 140 - 177 */\r\n   /* h    i    j    k    l    m    n    o */\r\n    070, 071, 041, 042, 043, 044, 045, 046,\r\n   /* p    q    r    s    t    u    v    w */\r\n    047, 050, 051, 022, 023, 024, 025, 026,\r\n   /* x    y    z    {    |    }    ~   del*/\r\n    027, 030, 031, 057, 077, 017,  -1,  -1\r\n};\r\n\r\nstatic uint16 ebcdic_to_hol[256] = {\r\n /*  T918    T91    T92    T93    T94    T95    T96   T97   0x0x */\r\n   0xB03,  0x901, 0x881, 0x841, 0x821, 0x811, 0x809, 0x805,\r\n /*  T98,   T189 , T289,  T389,  T489,  T589,  T689, T789   */\r\n   0x803,  0x903, 0x883, 0x843, 0x823, 0x813, 0x80B, 0x807,\r\n /* TE189    E91    E92    E93    E94    E95    E96   E97   0x1x */\r\n   0xD03,  0x501, 0x481, 0x441, 0x421, 0x411, 0x409, 0x405,\r\n /*  E98     E918   E928   E938   E948   E958   E968  E978   */\r\n   0x403,  0x503, 0x483, 0x443, 0x423, 0x413, 0x40B, 0x407,\r\n /*  E0918   091    092    093    094    095    096   097   0x2x */\r\n   0x703,  0x301, 0x281, 0x241, 0x221, 0x211, 0x209, 0x205,\r\n /*  098     0918  0928   0938    0948   0958   0968  0978   */\r\n   0x203,  0x303, 0x283, 0x243, 0x223, 0x213, 0x20B, 0x207,\r\n /* TE0918   91    92     93      94     95     96     97   0x3x */\r\n   0xF03,  0x101, 0x081, 0x041, 0x021, 0x011, 0x009, 0x005,\r\n /*  98      189    289    389    489    589    689    789   */\r\n   0x003,  0x103, 0x083, 0x043, 0x023, 0x013, 0x00B, 0x007,\r\n /*          T091  T092   T093   T094   T095   T096    T097  0x4x */\r\n   0x000,  0xB01, 0xA81, 0xA41, 0xA21, 0xA11, 0xA09, 0xA05,\r\n /* T098     T18    T28    T38    T48    T58    T68    T78    */\r\n   0xA03,  0x902, 0x882, 0x842, 0x822, 0x812, 0x80A, 0x806,\r\n /* T        TE91  TE92   TE93   TE94   TE95   TE96    TE97  0x5x */\r\n   0x800,  0xD01, 0xC81, 0xC41, 0xC21, 0xC11, 0xC09, 0xC05,\r\n /* TE98     E18    E28    E38    E48    E58    E68    E78   */\r\n   0xC03,  0x502, 0x482, 0x442, 0x422, 0x412, 0x40A, 0x406,\r\n /* E        01    E092   E093   E094   E095   E096    E097  0x6x */\r\n   0x400,  0x300, 0x681, 0x641, 0x621, 0x611, 0x609, 0x605,\r\n /* E098     018   TE     038    048     68    068     078    */\r\n   0x603,  0x302, 0xC00, 0x242, 0x222, 0x212, 0x20A, 0x206,\r\n /* TE0    TE091  TE092  TE093  TE094  TE095  TE096  TE097   0x7x */\r\n   0xE00,  0xF01, 0xE81, 0xE41, 0xE21, 0xE11, 0xE09, 0xE05,\r\n /* TE098    18     28     38    48      58      68     78    */\r\n   0xE03,  0x102, 0x082, 0x042, 0x022, 0x012, 0x00A, 0x006,\r\n /* T018     T01    T02    T03    T04    T05    T06    T07   0x8x */\r\n   0xB02,  0xB00, 0xA80, 0xA40, 0xA20, 0xA10, 0xA08, 0xA04,\r\n /* T08      T09   T028   T038    T048   T058   T068   T078   */\r\n   0xA02,  0xA01, 0xA82, 0xA42, 0xA22, 0xA12, 0xA0A, 0xA06,\r\n /* TE18     TE1    TE2    TE3    TE4    TE5    TE6    TE7   0x9x */\r\n   0xD02,  0xD00, 0xC80, 0xC40, 0xC20, 0xC10, 0xC08, 0xC04,\r\n /* TE8      TE9   TE28   TE38    TE48   TE58   TE68   TE78   */\r\n   0xC02,  0xC01, 0xC82, 0xC42, 0xC22, 0xC12, 0xC0A, 0xC06,\r\n /* E018     E01    E02    E03    E04    E05    E06    E07   0xax */\r\n   0x702,  0x700, 0x680, 0x640, 0x620, 0x610, 0x608, 0x604,\r\n /* E08      E09   E028   E038    E048   E058   E068   E078   */\r\n   0x602,  0x601, 0x682, 0x642, 0x622, 0x612, 0x60A, 0x606,\r\n /* TE018    TE01   TE02   TE03   TE04   TE05   TE06   TE07  0xbx */\r\n   0xF02,  0xF00, 0xE80, 0xE40, 0xE20, 0xE10, 0xE08, 0xE04,\r\n /* TE08     TE09   TE028  TE038  TE048  TE058  TE068  TE078  */\r\n   0xE02,  0xE01, 0xE82, 0xE42, 0xE22, 0xE12, 0xE0A, 0xE06,\r\n /*  T0      T1     T2     T3     T4     T5     T6     T7    0xcx */\r\n   0xA00,  0x900, 0x880, 0x840, 0x820, 0x810, 0x808, 0x804,\r\n /* T8       T9     T0928  T0938  T0948  T0958  T0968  T0978  */\r\n   0x802,  0x801, 0xA83, 0xA43, 0xA23, 0xA13, 0xA0B, 0xA07,\r\n /* E0       E1     E2     E3     E4     E5     E6     E7    0xdx */\r\n   0x600,  0x500, 0x480, 0x440, 0x420, 0x410, 0x408, 0x404,\r\n /* E8       E9     TE928  TE938  TE948  TE958  TE968  TE978  */\r\n   0x402,  0x401, 0xC83, 0xC43, 0xC23, 0xC13, 0xC0B, 0xC07,\r\n /* 028      E091   02     03     04     05     06     07    0xex  */\r\n   0x282,  0x701, 0x280, 0x240, 0x220, 0x210, 0x208, 0x204,\r\n /* 08       09     E0928  E0938  E0948  E0958  E0968  E0978  */\r\n   0x202,  0x201, 0x683, 0x643, 0x623, 0x613, 0x60B, 0x607,\r\n /* 0        1      2      3      4      5      6      7     0xfx */\r\n   0x200,  0x100, 0x080, 0x040, 0x020, 0x010, 0x008, 0x004,\r\n /* 8        9     TE0928 TE0938 TE0948 TE0958 TE0968 TE0978  */\r\n   0x002,  0x001, 0xE83, 0xE43, 0xE23, 0xE13, 0xE0B, 0xE07\r\n};\r\n\r\nstatic uint16 hol_to_ebcdic[4096];\r\n\r\nconst uint8        sim_parity_table[64] = {\r\n    /* 0    1    2    3    4    5    6    7 */\r\n    0000, 0100, 0100, 0000, 0100, 0000, 0000, 0100,\r\n    0100, 0000, 0000, 0100, 0000, 0100, 0100, 0000,\r\n    0100, 0000, 0000, 0100, 0000, 0100, 0100, 0000,\r\n    0000, 0100, 0100, 0000, 0100, 0000, 0000, 0100,\r\n    0100, 0000, 0000, 0100, 0000, 0100, 0100, 0000,\r\n    0000, 0100, 0100, 0000, 0100, 0000, 0000, 0100,\r\n    0000, 0100, 0100, 0000, 0100, 0000, 0000, 0100,\r\n    0100, 0000, 0000, 0100, 0000, 0100, 0100, 0000\r\n};\r\n\r\nstruct card_formats {\r\n    uint32      mode;\r\n    const char  *name;\r\n};\r\n\r\nstatic struct card_formats fmts[] = {\r\n    {MODE_AUTO,  \"AUTO\"},\r\n    {MODE_BIN,   \"BIN\"},\r\n    {MODE_TEXT,  \"TEXT\"},\r\n    {MODE_BCD,   \"BCD\"},\r\n    {MODE_CBN,   \"CBN\"},\r\n    {MODE_EBCDIC,\"EBCDIC\"},\r\n    {MODE_OCTAL, \"OCTAL\"},\r\n    {0, 0},\r\n};\r\n\r\n\f\r\n/* Conversion routines */\r\n\r\n/* Convert BCD character into hollerith code */\r\nuint16\r\nsim_bcd_to_hol(uint8 bcd) {\r\n    uint16      hol;\r\n\r\n    /* Handle space correctly */\r\n    if (bcd == 0)               /* 0 to 82 punch */\r\n        return 0x82;\r\n    if (bcd == 020)             /* 20 no punch */\r\n        return 0;\r\n\r\n    /* Convert to top column */\r\n    switch (bcd & 060) {\r\n    default:\r\n    case 000:\r\n         hol = 0x000;\r\n         break;\r\n    case 020:\r\n         hol = 0x200;\r\n         break;\r\n    case 040:\r\n         hol = 0x400;\r\n         break;\r\n    case 060:\r\n         hol = 0x800;\r\n         break;\r\n    }\r\n\r\n    /* Handle case of 10 special */\r\n    /* Only 032 is punched as 8-2 */\r\n    if ((bcd & 017) == 10 && (bcd & 060) != 020) {\r\n        hol |= 1 << 9;\r\n        return hol;\r\n    }\r\n    /* Convert to 0-9 row */\r\n    bcd &= 017;\r\n    if (bcd > 9) {\r\n        hol |= 0x2;       /* Col 8 */\r\n        bcd -= 8;\r\n    }\r\n    if (bcd != 0)\r\n        hol |= 1 << (9 - bcd);\r\n    return hol;\r\n}\r\n\r\n/* Returns the BCD of the hollerith code or 0x7f if error */\r\nuint8\r\nsim_hol_to_bcd(uint16 hol) {\r\n    uint8                bcd;\r\n\r\n    /* Convert 10,11,12 rows */\r\n    switch (hol & 0xe00) {\r\n    case 0x000:\r\n         bcd = 0;\r\n         break;\r\n    case 0x200:\r\n         if ((hol & 0x1ff) == 0)\r\n           return 10;\r\n         bcd = 020;\r\n         break;\r\n    case 0x400:\r\n         bcd = 040;\r\n         break;\r\n    case 0x600: /* 11-10 Punch */\r\n         bcd = 052;\r\n         break;\r\n    case 0x800:\r\n         bcd = 060;\r\n         break;\r\n    case 0xA00: /* 12-10 Punch */\r\n         bcd = 072;\r\n         break;\r\n    default: /* Double punch in 10,11,12 rows */\r\n         return 0x7f;\r\n    }\r\n\r\n    hol &= 0x1ff;       /* Mask rows 0-9 */\r\n    /* Check row 8 punched */\r\n    if (hol & 0x2) {\r\n         bcd += 8;\r\n         hol &= ~0x2;\r\n    }\r\n\r\n    /* Convert rows 0-9 */\r\n    while (hol != 0 && (hol & 0x200) == 0) {\r\n         bcd++;\r\n         hol <<= 1;\r\n    }\r\n\r\n    /* Any more columns punched? */\r\n    if ((hol & 0x1ff) != 0)\r\n         return 0x7f;\r\n    return bcd;\r\n}\r\n\r\n/* Convert EBCDIC character into hollerith code */\r\nuint16\r\nsim_ebcdic_to_hol(uint8 ebcdic) {\r\n   return ebcdic_to_hol[ebcdic];\r\n}\r\n\r\n\r\n\r\n/* Returns the BCD of the hollerith code or 0x7f if error */\r\nuint16\r\nsim_hol_to_ebcdic(uint16 hol) {\r\n    return hol_to_ebcdic[hol];\r\n}\r\n\r\n\r\n\f\r\nt_addr\r\nsim_hopper_size(UNIT * uptr) {\r\n    struct card_context  *data = (struct card_context *)uptr->card_ctx;\r\n    if (data == NULL)\r\n        return 0;\r\n    return data->hopper_cards;\r\n}\r\n\r\nt_addr\r\nsim_punch_count(UNIT * uptr) {\r\n    struct card_context  *data = (struct card_context *)uptr->card_ctx;\r\n    if (data == NULL)\r\n        return 0;\r\n    return data->punch_count;\r\n}\r\n\r\nt_addr\r\nsim_card_input_hopper_count(UNIT *uptr) {\r\n    struct card_context  *data = (struct card_context *)uptr->card_ctx;\r\n    uint16                col;\r\n\r\n    if (data == NULL || data->images == NULL)\r\n        return 0;           /* attached? */\r\n\r\n    if (uptr->pos >= data->hopper_cards)\r\n        return 0;\r\n\r\n    col = (*data->images)[data->hopper_cards-1][0];\r\n\r\n    return (int)((data->hopper_cards - uptr->pos) - ((col & CARD_EOF) ? 1 : 0));\r\n}\r\n\r\nt_addr\r\nsim_card_output_hopper_count(UNIT *uptr) {\r\n    struct card_context  *data = (struct card_context *)uptr->card_ctx;\r\n\r\n    if (data == NULL)\r\n        return 0;           /* attached? */\r\n\r\n    return (int)data->punch_count;\r\n}\r\n\r\n\r\nt_cdstat\r\nsim_read_card(UNIT * uptr, uint16 image[80])\r\n{\r\n    int                   i;\r\n    struct card_context  *data = (struct card_context *)uptr->card_ctx;\r\n    DEVICE               *dptr;\r\n    uint16               (*img)[80];\r\n    t_stat                r = CDSE_OK;\r\n\r\n    if (data == NULL || (uptr->flags & UNIT_ATT) == 0)\r\n        return CDSE_EMPTY;      /* attached? */\r\n    if (data->hopper_cards == 0 || uptr->pos >= data->hopper_cards)\r\n        return CDSE_EMPTY;\r\n\r\n    dptr = find_dev_from_unit( uptr);\r\n    img = &(*data->images)[uptr->pos];\r\n    if (sim_deb && dptr && ((dptr)->dctrl & DEBUG_CARD)) {\r\n         if (image[0] & CARD_EOF) {\r\n             sim_debug(DEBUG_CARD, dptr, \"Read hopper EOF\\n\");\r\n         } else if (image[0] & CARD_ERR) {\r\n             sim_debug(DEBUG_CARD, dptr, \"Read hopper ERR\\n\");\r\n         } else {\r\n             uint8        out[81];\r\n             int          ok = 1;\r\n             for (i = 0; i < 80; i++) {\r\n                 out[i] = data->hol_to_ascii[(int)(*img)[i]];\r\n                 if (out[i] == 0xff) {\r\n                    ok = 0;\r\n                 }\r\n             }\r\n             if (ok) {\r\n                 sim_debug(DEBUG_CARD, dptr, \"Read hopper: [\");\r\n                 for (i = 0; i < 80; i++) {\r\n                     sim_debug(DEBUG_CARD, dptr, \"%c\", out[i]);\r\n                 }\r\n                 sim_debug(DEBUG_CARD, dptr, \"]\\n\");\r\n             } else {\r\n                 sim_debug(DEBUG_CARD, dptr, \"Read hopper binary\\n\");\r\n             }\r\n         }\r\n    }\r\n    if ((*img)[0] & CARD_EOF)\r\n        r = CDSE_EOF;\r\n    else if ((*img)[0] & CARD_ERR)\r\n           r = CDSE_ERROR;\r\n    uptr->pos++;\r\n    data->punch_count++;\r\n    memcpy(image, img, 80 * sizeof(uint16));\r\n    image[0] &= 0xfff;          /* Remove any CARD_EOF and CARD_ERR Flags */\r\n    return r;\r\n}\r\n\r\n/*\r\n * Check if reader is at last card.\r\n */\r\nint\r\nsim_card_eof(UNIT *uptr)\r\n{\r\n    struct card_context  *data = (struct card_context *)uptr->card_ctx;\r\n    uint16                col;\r\n\r\n    if (data == NULL || data->images == NULL)\r\n        return SCPE_UNATT;      /* attached? */\r\n\r\n    if (uptr->pos >= data->hopper_cards)\r\n        return SCPE_UNATT;\r\n\r\n    col = (*data->images)[uptr->pos][0];\r\n\r\n    if (col & CARD_EOF)\r\n        return 1;\r\n    return 0;\r\n}\r\n\r\n\f\r\n\r\nstruct _card_buffer {\r\n   uint8                 buffer[8192+500];    /* Buffer data */\r\n   int                   len;                 /* Amount of data in buffer */\r\n   int                   size;                /* Size of last card read */\r\n};\r\n\r\nstatic int _cmpcard(const uint8 *p, const char *s) {\r\n   int  i;\r\n   if (p[0] != '~')\r\n        return 0;\r\n   for(i = 0; i < 3; i++) {\r\n        if (tolower(p[i+1]) != s[i])\r\n           return 0;\r\n   }\r\n   return 1;\r\n}\r\n\r\nt_stat\r\n_sim_parse_card(UNIT *uptr, DEVICE *dptr, struct _card_buffer *buf, uint16 (*image)[80]) {\r\n    unsigned int          mode;\r\n    uint16                temp;\r\n    int                   i;\r\n    char                  c;\r\n    int                   col;\r\n\r\n    sim_debug(DEBUG_CARD, dptr, \"Read card \");\r\n    memset(image, 0, 160);\r\n    if ((uptr->flags & UNIT_CARD_MODE) == MODE_AUTO) {\r\n        mode = MODE_TEXT;   /* Default is text */\r\n\r\n        /* Check buffer to see if binary card in it. */\r\n        for (i = 0, temp = 0; i < 160 && i <buf->len; i+=2)\r\n            temp |= (uint16)(buf->buffer[i] & 0xFF);\r\n        /* Check if every other char < 16 & full buffer */\r\n        if ((temp & 0x0f) == 0 && i == 160)\r\n            mode = MODE_BIN;        /* Probably binary */\r\n        /* Check if maybe BCD or CBN */\r\n        if (buf->buffer[0] & 0x80) {\r\n            int     odd = 0;\r\n            int     even = 0;\r\n\r\n            /* Check all chars for correct parity */\r\n            for(i = 0, temp = 0; i < buf->len; i++) {\r\n               uint8        ch = buf->buffer[i] & 0177;\r\n               /* Try matching parity */\r\n               if (sim_parity_table[(ch & 077)] == (ch & 0100))\r\n                    even++;\r\n               else\r\n                    odd++;\r\n               /* Check if we hit end of record. */\r\n               if ((i == 79 && even == 80) || (i == 159 && odd == 160)) {\r\n                   ch = buf->buffer[i+1];\r\n                   /* If we have EOR then all ok */\r\n                   if (ch & 0x80)\r\n                      break;\r\n                   if (ch == '\\r' || ch == '\\n' || ch >= ' ')\r\n                      break;\r\n               }\r\n           }\r\n           if (even == 0 && odd == 160)\r\n               mode = MODE_CBN;\r\n           else if (odd == 80 && even == 0)\r\n               mode = MODE_BCD;\r\n         }\r\n\r\n        /* Check if modes match */\r\n        if ((uptr->flags & UNIT_CARD_MODE) != MODE_AUTO &&\r\n            (uptr->flags & UNIT_CARD_MODE) != mode) {\r\n            (*image)[0] = CARD_ERR;\r\n            sim_debug(DEBUG_CARD, dptr, \"invalid mode\\n\");\r\n            return SCPE_OPENERR;\r\n        }\r\n    } else\r\n        mode = uptr->flags & UNIT_CARD_MODE;\r\n\r\n    switch(mode) {\r\n    default:\r\n    case MODE_TEXT:\r\n        sim_debug(DEBUG_CARD, dptr, \"text: [\");\r\n        /* Check for special codes */\r\n        if (buf->buffer[0] == '~') {\r\n            int f = 1;\r\n            for(col = i = 1; col < 80 && f && i < buf->len; i++) {\r\n                c = buf->buffer[i];\r\n                switch (c) {\r\n                case '\\n':\r\n                case '\\0':\r\n                case '\\r':\r\n                    col = 80;\r\n                case ' ':\r\n                    break;              /* Ignore these */\r\n                case '\\t':\r\n                    col = (col | 7) + 1;        /* Mult of 8 */\r\n                    break;\r\n                default:\r\n                    f = 0;\r\n                    break;\r\n                }\r\n             }\r\n             if (f) {\r\n                (*image)[0] |= CARD_EOF;\r\n                goto end_card;\r\n             }\r\n        }\r\n        if (_cmpcard(&buf->buffer[0], \"raw\")) {\r\n            int         j = 0;\r\n            sim_debug(DEBUG_CARD, dptr, \"-octal-\");\r\n            for(col = 0, i = 4; col < 80 && i < buf->len; i++) {\r\n                if (buf->buffer[i] >= '0' && buf->buffer[i] <= '7') {\r\n                    (*image)[col] = ((*image)[col] << 3) | (buf->buffer[i] - '0');\r\n                    j++;\r\n                } else if (buf->buffer[i] == '\\n' || buf->buffer[i] == '\\r') {\r\n                    break;\r\n                } else {\r\n                    (*image)[0] = CARD_ERR;\r\n                    break;\r\n                }\r\n                if (j == 4) {\r\n                   col++;\r\n                   j = 0;\r\n                }\r\n            }\r\n        } else if (_cmpcard(&buf->buffer[0], \"eor\")) {\r\n            sim_debug(DEBUG_CARD, dptr, \"-eor-\");\r\n            (*image)[0] = 07;        /* 7/8/9 punch */\r\n            i = 4;\r\n        } else if (_cmpcard(&buf->buffer[0], \"eof\")) {\r\n            sim_debug(DEBUG_CARD, dptr, \"-eof-\");\r\n            (*image)[0] = 015;       /* 6/7/9 punch */\r\n            i = 4;\r\n        } else if (_cmpcard(&buf->buffer[0], \"eoi\")) {\r\n            sim_debug(DEBUG_CARD, dptr, \"-eoi-\");\r\n            (*image)[0] = 017;       /* 6/7/8/9 punch */\r\n            i = 4;\r\n        } else if (_cmpcard(&buf->buffer[0], \"78\")) {\r\n            sim_debug(DEBUG_CARD, dptr, \"-78-\");\r\n            (*image)[0] = 06;       /* 7/8 punch */\r\n            i = 3;\r\n        } else {\r\n            /* Convert text line into card image */\r\n            for (col = 0, i = 0; col < 80 && i < buf->len; i++) {\r\n                c = buf->buffer[i];\r\n                switch (c) {\r\n                case '\\0':\r\n                case '\\r':\r\n                    break;              /* Ignore these */\r\n                case '\\t':\r\n                    col = (col | 7) + 1;        /* Mult of 8 */\r\n                    break;\r\n                case '\\n':\r\n                    col = 80;\r\n                    i--;\r\n                    break;\r\n                default:\r\n                    sim_debug(DEBUG_CARD, dptr, \"%c\", c);\r\n                    if ((uptr->flags & MODE_LOWER) == 0)\r\n                        c = toupper(c);\r\n                    switch(uptr->flags & MODE_CHAR) {\r\n                    default:\r\n                    case MODE_026:\r\n                           temp = ascii_to_hol_026[(int)c];\r\n                           break;\r\n                    case MODE_029:\r\n                           temp = ascii_to_hol_029[(int)c];\r\n                           break;\r\n                    case MODE_DEC29:\r\n                           temp = ascii_to_dec_029[(int)c];\r\n                           break;\r\n                    }\r\n                    if (temp & 0xf000)\r\n                        (*image)[0] |= CARD_ERR;\r\n                    (*image)[col++] = temp & 0xfff;\r\n                }\r\n            }\r\n        }\r\n    end_card:\r\n        sim_debug(DEBUG_CARD, dptr, \"-%d-\", i);\r\n\r\n        /* Scan to end of line, ignore anything after last column */\r\n        while (buf->buffer[i] != '\\n' && buf->buffer[i] != '\\r' && i < buf->len) {\r\n            i++;\r\n        }\r\n        if (buf->buffer[i] == '\\r')\r\n            i++;\r\n        if (buf->buffer[i] == '\\n')\r\n            i++;\r\n        sim_debug(DEBUG_CARD, dptr, \"]\\n\");\r\n        break;\r\n\r\n    case MODE_BIN:\r\n        temp = 0;\r\n        sim_debug(DEBUG_CARD, dptr, \"bin\\n\");\r\n        if (buf->len < 160) {\r\n            (*image)[0] = CARD_ERR;\r\n            return SCPE_OPENERR;\r\n        }\r\n        /* Move data to buffer */\r\n        for (col = i = 0; i < 160;) {\r\n            temp |= (uint16)(buf->buffer[i] & 0xff);\r\n            (*image)[col] = (buf->buffer[i++] >> 4) & 0xF;\r\n            (*image)[col++] |= ((uint16)buf->buffer[i++] & 0xff) << 4;\r\n        }\r\n        /* Check if format error */\r\n        if (temp & 0xF)\r\n            (*image)[0]  |= CARD_ERR;\r\n\r\n        break;\r\n\r\n    case MODE_CBN:\r\n        sim_debug(DEBUG_CARD, dptr, \"cbn\\n\");\r\n        /* Check if first character is a tape mark */\r\n        if (buf->buffer[0] == 0217 &&\r\n                   (buf->len == 1 || (buf->buffer[1] & 0200) != 0)) {\r\n            i = 1;\r\n            (*image)[0] |= CARD_EOF;\r\n            break;\r\n        }\r\n\r\n        /* Clear record mark */\r\n        buf->buffer[0] &= 0x7f;\r\n\r\n        /* Convert card and check for errors */\r\n        for (col = i = 0; i < buf->len && col < 80;) {\r\n            uint8       c;\r\n\r\n            if (buf->buffer[i] & 0x80)\r\n                break;\r\n            c = buf->buffer[i] & 077;\r\n            if (sim_parity_table[(int)c] == (buf->buffer[i++] & 0100))\r\n                (*image)[0] |= CARD_ERR;\r\n            (*image)[col] = ((uint16)c) << 6;\r\n            if (buf->buffer[i] & 0x80)\r\n                break;\r\n            c = buf->buffer[i] & 077;\r\n            if (sim_parity_table[(int)c] == (buf->buffer[i++] & 0100))\r\n                (*image)[0] |= CARD_ERR;\r\n            (*image)[col++] |= c;\r\n        }\r\n\r\n        /* Record over length of card, skip until next */\r\n        if ((uptr->flags & UNIT_CARD_MODE) != MODE_AUTO) {\r\n            if (i < buf->len && col >= 80 && (buf->buffer[i] & 0x80) == 0) {\r\n                (*image)[0] |= CARD_ERR;\r\n                while ((buf->buffer[i] & 0x80) == 0) {\r\n                    if (i > buf->len)\r\n                       break;\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        break;\r\n\r\n    case MODE_BCD:\r\n        sim_debug(DEBUG_CARD, dptr, \"bcd [\");\r\n        /* Check if first character is a tape mark */\r\n        if (buf->buffer[0] == 0217 && (buf->buffer[1] & 0200) != 0) {\r\n            i = 1;\r\n            (*image)[0] |= CARD_EOF;\r\n            break;\r\n        }\r\n\r\n        /* Convert text line into card image */\r\n        for (col = 0, i = 0; col < 80 && i < buf->len; i++) {\r\n            if (buf->buffer[i] & 0x80)\r\n                break;\r\n            c = buf->buffer[i] & 077;\r\n            if (sim_parity_table[(int)c] != (buf->buffer[i] & 0100))\r\n                (*image)[0] |= CARD_ERR;\r\n            sim_debug(DEBUG_CARD, dptr, \"%c\", sim_six_to_ascii[(int)c]);\r\n            /* Convert to top column */\r\n            (*image)[col++] = sim_bcd_to_hol(c);\r\n        }\r\n\r\n        /* Record over length of card, skip until next */\r\n        if ((uptr->flags & UNIT_CARD_MODE) != MODE_AUTO) {\r\n            if (i < buf->len && col >= 80 && (buf->buffer[i] & 0x80) == 0) {\r\n                (*image)[0] |= CARD_ERR;\r\n                while ((buf->buffer[i] & 0x80) == 0) {\r\n                    if (i > buf->len)\r\n                       break;\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        sim_debug(DEBUG_CARD, dptr, \"]\\n\");\r\n        break;\r\n\r\n    case MODE_EBCDIC:\r\n        sim_debug(DEBUG_CARD, dptr, \"ebcdic\\n\");\r\n        if (buf->len < 80)\r\n            (*image)[0] |= CARD_ERR;\r\n        /* Move data to buffer */\r\n        for (i = 0; i < 80 && i < buf->len; i++) {\r\n            temp = (uint16)(buf->buffer[i]) & 0xFF;\r\n            (*image)[i] = ebcdic_to_hol[temp];\r\n        }\r\n        break;\r\n\r\n    }\r\n    buf->size = i;\r\n    return SCPE_OK;\r\n}\r\n\r\nt_stat\r\n_sim_read_deck(UNIT * uptr, int eof)\r\n{\r\n    struct _card_buffer   buf;\r\n    struct card_context  *data;\r\n    DEVICE               *dptr;\r\n    int                   i;\r\n    int                   j;\r\n    int                   l;\r\n    int                   cards = 0;\r\n    t_stat                r = SCPE_OK;\r\n\r\n    if ((uptr->flags & UNIT_ATT) == 0)\r\n        return SCPE_UNATT;      /* attached? */\r\n\r\n    dptr = find_dev_from_unit( uptr);\r\n    data = (struct card_context *)uptr->card_ctx;\r\n\r\n    buf.len = 0;\r\n    buf.size = 0;\r\n    buf.buffer[0] = 0; /* Initialize bufer to empty */\r\n\r\n    /* Slurp up current file */\r\n    do {\r\n        if (buf.len < 500 && !feof(uptr->fileref)) {\r\n            l = sim_fread(&buf.buffer[buf.len], 1, 8192, uptr->fileref);\r\n            buf.len += l;\r\n        }\r\n\r\n        /* Allocate space for some more cards if needed */\r\n        if (data->hopper_cards >= data->hopper_size) {\r\n            data->hopper_size += DECK_SIZE;\r\n            data->images = (uint16 (*)[1][80])realloc(data->images,\r\n                       (size_t)data->hopper_size * sizeof(*(data->images)));\r\n            memset(&data->images[data->hopper_cards], 0,\r\n                       (size_t)(data->hopper_size - data->hopper_cards) *\r\n                             sizeof(*(data->images)));\r\n        }\r\n\r\n        /* Process one card */\r\n        cards++;\r\n        if (_sim_parse_card(uptr, dptr, &buf, &(*data->images)[data->hopper_cards])\r\n                != SCPE_OK) {\r\n            r = sim_messagef(SCPE_OPENERR, \"%s: %s Error (%s) in card %d\\n\",\r\n                   sim_uname(uptr), uptr->filename, sim_error_text(r), cards);\r\n        }\r\n        data->hopper_cards++;\r\n        /* Move data to start at begining of buffer */\r\n        /* Data is moved down to simplify the decoding of one card */\r\n        l = buf.len - buf.size;\r\n        j = buf.size;\r\n        for(i = 0; i < l; i++, j++)\r\n            buf.buffer[i] = buf.buffer[j];\r\n        buf.buffer[i] = '\\0';\r\n        buf.len -= buf.size;\r\n    } while (buf.len > 0 && r == SCPE_OK);\r\n\r\n    /* If there is an error, free just read deck */\r\n    if (r == SCPE_OK) {\r\n       if (eof) {\r\n          /* Allocate space for some more cards if needed */\r\n          if (data->hopper_cards >= data->hopper_size) {\r\n              data->hopper_size += DECK_SIZE;\r\n              data->images = (uint16 (*)[1][80])realloc(data->images,\r\n                         (size_t)data->hopper_size * sizeof(*(data->images)));\r\n              memset(&data->images[data->hopper_cards], 0,\r\n                         (size_t)(data->hopper_size - data->hopper_cards) *\r\n                               sizeof(*(data->images)));\r\n          }\r\n\r\n          /* Create empty card */\r\n          (*data->images)[data->hopper_cards][0] = CARD_EOF;\r\n          data->hopper_cards++;\r\n       }\r\n    }\r\n    return r;\r\n}\r\n\r\n\f\r\n/* Card punch routine\r\n\r\n   Modifiers have been checked by the caller\r\n   C modifier is recognized (column binary is implemented)\r\n*/\r\n\r\n\r\nt_stat\r\nsim_punch_card(UNIT * uptr, uint16 image[80])\r\n{\r\n/* Convert word record into column image */\r\n/* Check output type, if auto or text, try and convert record to bcd first */\r\n/* If failed and text report error and dump what we have */\r\n/* Else if binary or not convertable, dump as image */\r\n\r\n    /* Try to convert to text */\r\n    uint8                out[512];\r\n    int                  i;\r\n    int                  outp = 0;\r\n    int                  mode = uptr->flags & UNIT_CARD_MODE;\r\n    int                  ok = 1;\r\n    struct card_context *data;\r\n    DEVICE              *dptr;\r\n\r\n    dptr = find_dev_from_unit(uptr);\r\n    data = (struct card_context *)uptr->card_ctx;\r\n\r\n    if (data == NULL || (uptr->flags & UNIT_ATT) == 0)\r\n        return CDSE_EMPTY;      /* attached? */\r\n\r\n    /* Fix mode if in auto mode */\r\n    if (mode == MODE_AUTO) {\r\n         /* Try to convert each column to ascii */\r\n         for (i = 0; i < 80; i++) {\r\n             out[i] = data->hol_to_ascii[image[i]];\r\n             if (out[i] == 0xff) {\r\n                ok = 0;\r\n             }\r\n         }\r\n         mode = ok?MODE_TEXT:MODE_OCTAL;\r\n    }\r\n\r\n    switch(mode) {\r\n    default:\r\n    case MODE_TEXT:\r\n        /* Scan each column */\r\n        sim_debug(DEBUG_CARD, dptr, \"text: [\");\r\n        for (i = 0; i < 80; i++, outp++) {\r\n            out[outp] = data->hol_to_ascii[image[i]];\r\n            if (out[outp] == 0xff) {\r\n               out[outp] = '?';\r\n            }\r\n            sim_debug(DEBUG_CARD, dptr, \"%c\", out[outp]);\r\n        }\r\n        sim_debug(DEBUG_CARD, dptr, \"]\\n\");\r\n        /* Trim off trailing spaces */\r\n        while (outp > 0 && out[--outp] == ' ') ;\r\n        out[++outp] = '\\n';\r\n        out[++outp] = '\\0';\r\n        break;\r\n\r\n    case MODE_OCTAL:\r\n        sim_debug(DEBUG_CARD, dptr, \"octal: [\");\r\n        out[outp++] = '~';\r\n        for (i = 79; i >= 0; i--) {\r\n            if (image[i] != 0)\r\n               break;\r\n        }\r\n        /* Check if special card */\r\n        if (i == 0) {\r\n            out[outp++] = 'e';\r\n            out[outp++] = 'o';\r\n            if (image[0] == 07) {\r\n               out[outp++] = 'r';\r\n               out[outp++] = '\\n';\r\n               sim_debug(DEBUG_CARD, dptr, \"eor\\n\");\r\n               break;\r\n            }\r\n            if (image[0] == 015) {\r\n               out[outp++] = 'f';\r\n               out[outp++] = '\\n';\r\n               sim_debug(DEBUG_CARD, dptr, \"eof\\n\");\r\n               break;\r\n            }\r\n            if (image[0] == 017) {\r\n               out[outp++] = 'f';\r\n               out[outp++] = '\\n';\r\n               sim_debug(DEBUG_CARD, dptr, \"eoi\\n\");\r\n               break;\r\n            }\r\n        }\r\n        out[outp++] = 'r';\r\n        out[outp++] = 'a';\r\n        out[outp++] = 'w';\r\n        for (i = 0; i < 80; i++) {\r\n            uint16 col = image[i];\r\n            out[outp++] = ((col >> 9) & 07) + '0';\r\n            out[outp++] = ((col >> 6) & 07) + '0';\r\n            out[outp++] = ((col >> 3) & 07) + '0';\r\n            out[outp++] = (col & 07) + '0';\r\n        }\r\n        out[outp++] = '\\n';\r\n        sim_debug(DEBUG_CARD, dptr, \"%s\", &out[4]);\r\n        break;\r\n\r\n\r\n    case MODE_BIN:\r\n        sim_debug(DEBUG_CARD, dptr, \"bin\\n\");\r\n        for (i = 0; i < 80; i++) {\r\n            uint16      col = image[i];\r\n            out[outp++] = (col & 0x00f) << 4;\r\n            out[outp++] = (col & 0xff0) >> 4;\r\n        }\r\n        break;\r\n\r\n    case MODE_CBN:\r\n        sim_debug(DEBUG_CARD, dptr, \"cbn\\n\");\r\n        /* Fill buffer */\r\n        for (i = 0; i < 80; i++) {\r\n            uint16      col = image[i];\r\n            out[outp++] = (col >> 6) & 077;\r\n            out[outp++] = col & 077;\r\n        }\r\n        /* Now set parity */\r\n        for (i = 0; i < 160; i++)\r\n            out[i] |= 0100 ^ sim_parity_table[(int)out[i]];\r\n        out[0] |= 0x80;     /* Set record mark */\r\n        break;\r\n\r\n    case MODE_BCD:\r\n        sim_debug(DEBUG_CARD, dptr, \"bcd [\");\r\n        for (i = 0; i < 80; i++, outp++) {\r\n             out[outp] = sim_hol_to_bcd(image[i]);\r\n             if (out[outp] != 0x7f)\r\n                 out[outp] |= sim_parity_table[(int)out[outp]];\r\n             else\r\n                 out[outp] = 077;\r\n            sim_debug(DEBUG_CARD, dptr, \"%c\",\r\n                         sim_six_to_ascii[(int)out[outp]]);\r\n        }\r\n        sim_debug(DEBUG_CARD, dptr, \"]\\n\");\r\n        out[0] |= 0x80;     /* Set record mark */\r\n        while (outp > 0 && out[--outp] == 0);\r\n        outp++;\r\n        break;\r\n\r\n    case MODE_EBCDIC:\r\n        sim_debug(DEBUG_CARD, dptr, \"ebcdic\\n\");\r\n        /* Fill buffer */\r\n        for (i = 0; i < 80; i++, outp++) {\r\n            uint16      col = image[i];\r\n            out[outp] = 0xff & hol_to_ebcdic[col];\r\n        }\r\n        break;\r\n    }\r\n    data->punch_count++;\r\n    sim_fwrite(out, 1, outp, uptr->fileref);\r\n    uptr->pos = ftell (uptr->fileref);\r\n    /* Clear image buffer */\r\n    for (i = 0; i < 80; image[i++] = 0);\r\n    return CDSE_OK;\r\n}\r\n\r\n/* Set card format */\r\nt_stat sim_card_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\n    int f;\r\n\r\n    if (uptr == NULL) return SCPE_IERR;\r\n    if (cptr == NULL) return SCPE_ARG;\r\n    for (f = 0; fmts[f].name != 0; f++) {\r\n        if (strcmp (cptr, fmts[f].name) == 0) {\r\n            uptr->flags = (uptr->flags & ~UNIT_CARD_MODE) | fmts[f].mode;\r\n            return SCPE_OK;\r\n            }\r\n        }\r\n    return SCPE_ARG;\r\n}\r\n\r\n/* Show card format */\r\n\r\nt_stat sim_card_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\n    int f;\r\n\r\n    for (f = 0; fmts[f].name != 0; f++) {\r\n        if ((uptr->flags & UNIT_CARD_MODE) == fmts[f].mode) {\r\n            fprintf (st, \"%s format\", fmts[f].name);\r\n            return SCPE_OK;\r\n        }\r\n    }\r\n    fprintf (st, \"invalid format\");\r\n    return SCPE_OK;\r\n}\r\n\r\n\r\nt_stat\r\nsim_card_attach(UNIT * uptr, CONST char *cptr)\r\n{\r\n    t_stat               r = SCPE_OK;\r\n    int                  eof = 0;\r\n    struct card_context *data;\r\n    char                 gbuf[30];\r\n    unsigned int         i;\r\n    char                *saved_filename;\r\n    t_bool               was_attached = (uptr->flags & UNIT_ATT);\r\n    t_addr               saved_pos;\r\n    static int           ebcdic_init = 0;\r\n\r\n    if ((uptr->flags & UNIT_RO) &&      /* Attaching a Reader */\r\n            strchr (cptr, ',')) {       /* Restoring Attach list of files? */\r\n        char tbuf[10*CBUFSIZE];\r\n        char *tptr = tbuf;\r\n        int32 saved_switches = sim_switches;\r\n\r\n        strlcpy (tbuf, cptr, sizeof(tbuf));\r\n        tptr = strtok (tptr, \",\");\r\n        while (tptr) {\r\n            cptr = tptr;\r\n            while (isspace(*cptr))\r\n                ++cptr;\r\n            r = sim_card_attach (uptr, cptr);\r\n            if (r != SCPE_OK)\r\n                return r;\r\n            tptr = strtok (NULL, \",\");\r\n            sim_switches = saved_switches & ~SWMASK('F');\r\n            sim_switches |= SWMASK('S');\r\n        }\r\n        sim_switches = saved_switches;\r\n        return SCPE_OK;\r\n    }\r\n\r\n    cptr = get_sim_sw (cptr);                               /* Pickup optional format specifier during RESTORE */\r\n    if (sim_switches & SWMASK ('F')) {                      /* format spec? */\r\n        cptr = get_glyph (cptr, gbuf, 0);                   /* get spec */\r\n        if (*cptr == 0) return SCPE_2FARG;                  /* must be more */\r\n        if (sim_card_set_fmt (uptr, 0, gbuf, NULL) != SCPE_OK)\r\n            return SCPE_ARG;\r\n    }\r\n\r\n    if (sim_switches & SWMASK ('E'))\r\n       eof = 1;\r\n\r\n    saved_filename = uptr->filename;\r\n    uptr->filename = NULL;\r\n    saved_pos = uptr->pos;\r\n    if ((r = attach_unit(uptr, cptr)) != SCPE_OK) {\r\n        uptr->filename = saved_filename;\r\n        uptr->pos = saved_pos;\r\n        return r;\r\n    }\r\n\r\n\r\n    /* Initialize reverse mapping if not initialized */\r\n    /* Set all to invalid */\r\n    /* Allocate a buffer if one does not exist */\r\n    if (uptr->card_ctx == 0) {\r\n        uptr->card_ctx = malloc(sizeof(struct card_context));\r\n        data = (struct card_context *)uptr->card_ctx;\r\n        memset(data, 0, sizeof(struct card_context));\r\n    } else {\r\n        data = (struct card_context *)uptr->card_ctx;\r\n    }\r\n\r\n    if (!ebcdic_init) {\r\n        for (i = 0; i < 4096; i++)\r\n            hol_to_ebcdic[i] = 0x100;\r\n        for (i = 0; i < 256; i++) {\r\n            uint16     temp = ebcdic_to_hol[i];\r\n            if (hol_to_ebcdic[temp] != 0x100) {\r\n                fprintf(stderr, \"Translation error %02x is %03x and %03x\\n\",\r\n                    i, temp, hol_to_ebcdic[temp]);\r\n            } else {\r\n                hol_to_ebcdic[temp] = i;\r\n            }\r\n        }\r\n        ebcdic_init = 1;\r\n    }\r\n\r\n    memset(&data->hol_to_ascii[0], 0xff, 4096);\r\n    for(i = 0; i < (sizeof(ascii_to_hol_026)/sizeof(uint16)); i++) {\r\n         uint16          temp;\r\n         switch(uptr->flags & MODE_CHAR) {\r\n         default:\r\n         case 0:\r\n         case MODE_026:\r\n              temp = ascii_to_hol_026[i];\r\n              break;\r\n         case MODE_029:\r\n              temp = ascii_to_hol_029[i];\r\n              break;\r\n         case MODE_DEC29:\r\n              temp = ascii_to_dec_029[i];\r\n              break;\r\n         }\r\n         if ((temp & 0xf000) == 0) {\r\n            data->hol_to_ascii[temp] = i;\r\n         }\r\n    }\r\n\r\n    if (uptr->flags & UNIT_RO) {            /* Card Reader? */\r\n        t_addr  previous_cards = data->hopper_cards;\r\n\r\n        /* Check if we should append to end of existing */\r\n        if ((sim_switches & SWMASK ('S')) == 0) {\r\n           previous_cards = 0;\r\n           data->hopper_cards = 0;\r\n           data->hopper_size = 0;\r\n           data->punch_count = 0;\r\n           free(data->images);\r\n           data->images = NULL;\r\n           free(saved_filename);\r\n           saved_filename = NULL;\r\n           saved_pos = 0;\r\n        }\r\n\r\n        /* Go read the deck */\r\n        r = _sim_read_deck(uptr, eof);\r\n        uptr->pos = saved_pos;\r\n        detach_unit(uptr);\r\n        if (was_attached) {\r\n            uptr->flags |= UNIT_ATT;\r\n            uptr->filename = saved_filename;\r\n        }\r\n        if (r == SCPE_OK) {\r\n            const char    *fmt = \"AUTO\";\r\n            unsigned int   mode = uptr->flags & UNIT_CARD_MODE;\r\n            for (i = 0; fmts[i].name != 0; i++) {\r\n                if (fmts[i].mode == mode) {\r\n                    fmt = fmts[i].name;\r\n                    break;\r\n                }\r\n            }\r\n            uptr->flags |= UNIT_ATT;\r\n            uptr->dynflags |= UNIT_ATTMULT;\r\n            if (saved_filename) {\r\n                uptr->filename = (char *)malloc (32 + strlen (cptr) + strlen (saved_filename));\r\n                sprintf (uptr->filename, \"%s, %s-F %s %s\", saved_filename,\r\n                     (eof)? \"-E \": \"\", fmt, cptr);\r\n                free(saved_filename);\r\n            } else {\r\n                uptr->filename = (char *)malloc (32 + strlen (cptr));\r\n                sprintf (uptr->filename, \"%s-F %s %s\", (eof)?\"-E \": \"\", fmt, cptr);\r\n            }\r\n            r = sim_messagef(SCPE_OK, \"%s: %d card Deck Loaded from %s\\n\",\r\n                       sim_uname(uptr), (int)(data->hopper_cards - previous_cards), cptr);\r\n        } else {\r\n            if (uptr->dynflags & UNIT_ATTMULT)\r\n                uptr->flags |= UNIT_ATT;\r\n            detach_unit(uptr);\r\n            return r;\r\n        }\r\n    }\r\n\r\n    return r;\r\n}\r\n\r\nt_stat\r\nsim_card_detach(UNIT * uptr)\r\n{\r\n    /* Free buffer if one allocated */\r\n    if (uptr->card_ctx != 0) {\r\n        struct card_context * data = (struct card_context *)uptr->card_ctx;\r\n        /* No clear any existing decks on stack */\r\n        free(data->images);\r\n        free(uptr->card_ctx);\r\n        uptr->card_ctx = 0;\r\n    }\r\n    if (uptr->flags & UNIT_RO) {           /* Card Reader? */\r\n       free(uptr->filename);\r\n       uptr->filename = NULL;\r\n       uptr->flags &= ~UNIT_ATT;\r\n       uptr->dynflags &= ~UNIT_ATTMULT;\r\n       return SCPE_OK;                     /* Already detached */\r\n    }\r\n    return detach_unit(uptr);\r\n}\r\n\r\nt_stat sim_card_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\n    uint32 i, readers = 0, punches = 0;\r\n\r\n    for (i=0; i < dptr->numunits; ++i)\r\n        if (dptr->units[i].flags & UNIT_ATTABLE) {\r\n            readers += ((dptr->units[i].flags & UNIT_RO) != 0);\r\n            punches += ((dptr->units[i].flags & UNIT_RO) == 0);\r\n            }\r\n    if (uptr == NULL)\r\n        uptr = dptr->units;\r\n    fprintf (st, \"%s Card %s%s%sAttach Help\\n\\n\", dptr->name,\r\n                 readers ? \"Reader \" : \"\", readers & punches ? \"& \" : \"\", punches ? \"Punch \": \"\");\r\n    if (0 == (uptr-dptr->units)) {\r\n        if (dptr->numunits > 1) {\r\n            uint32 i;\r\n\r\n            for (i=0; i < dptr->numunits; ++i)\r\n                if (dptr->units[i].flags & UNIT_ATTABLE)\r\n                    fprintf (st, \"  sim> ATTACH {switches} %s carddeck%s\\n\", sim_uname (&dptr->units[i]), ((dptr->units[i].flags & UNIT_RO) != 0) ? \"{,extra-cards,...}\" : \"\");\r\n            fprintf (st, \"\\n\");\r\n            }\r\n        else\r\n            fprintf (st, \"  sim> ATTACH {switches} %s carddeck%s\\n\\n\", sim_uname (uptr), ((dptr->units[0].flags & UNIT_RO) != 0) ? \"{,extra-cards,...}\" : \"\");\r\n        }\r\n    else\r\n        fprintf (st, \"  sim> ATTACH {switches} %s carddeck%s\\n\\n\", sim_uname (uptr), (readers > 0) ? \"{,extra-cards,...}\" : \"\");\r\n    fprintf (st, \"Attach command switches\\n\");\r\n    fprintf (st, \"    -F          Open the indicated card deck in a specific format (default\\n\");\r\n    fprintf (st, \"                is AUTO, alternatives are BIN, TEXT, BCD, CBN and EBCDIC)\\n\");\r\n    if (punches != 0) {\r\n        fprintf (st, \"    -N          Create a new punch output file (default is to append to\\n\");\r\n        fprintf (st, \"                an existing file if it exists)\\n\");\r\n    }\r\n    if (readers != 0) {\r\n        fprintf (st, \"    -E          Return EOF after deck read\\n\");\r\n        fprintf (st, \"    -S          Append deck to cards currently waiting to be read\\n\");\r\n    }\r\n    return SCPE_OK;\r\n}\r\n\r\nstatic t_stat create_card_file (const char *filename, int cards)\r\n{\r\nFILE *f;\r\nint i;\r\n\r\nf = fopen (filename, \"w\");\r\nif (f == NULL)\r\n    return SCPE_OPENERR;\r\nfor (i=0; i<cards; i++)\r\n    fprintf (f, \"%05d ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\\n\", i);\r\nfclose (f);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_card_test (DEVICE *dptr, const char *cptr)\r\n{\r\nt_stat stat = SCPE_OK;\r\n#if defined(USE_SIM_CARD) && defined(SIM_CARD_API) && (SIM_MAJOR > 3)\r\nchar cmd[CBUFSIZE];\r\nchar saved_filename[4*CBUFSIZE];\r\nuint16 card_image[80];\r\nSIM_TEST_INIT;\r\n\r\nif ((dptr->units->flags & UNIT_RO) == 0)  /* Punch device? */\r\n    return SCPE_OK;\r\n\r\nsim_printf (\"Testing %s device sim_card APIs\\n\", dptr->name);\r\n\r\n(void)remove(\"file1.deck\");\r\n(void)remove(\"file2.deck\");\r\n(void)remove(\"file3.deck\");\r\n(void)remove(\"file4.deck\");\r\n\r\nSIM_TEST(create_card_file (\"File10.deck\", 10));\r\nSIM_TEST(create_card_file (\"File20.deck\", 20));\r\nSIM_TEST(create_card_file (\"File30.deck\", 30));\r\nSIM_TEST(create_card_file (\"File40.deck\", 40));\r\n\r\nsprintf (cmd, \"%s File10.deck\", dptr->name);\r\nSIM_TEST(attach_cmd (0, cmd));\r\nsprintf (cmd, \"%s File20.deck\", dptr->name);\r\nSIM_TEST(attach_cmd (0, cmd));\r\nsprintf (cmd, \"%s -S File30.deck\", dptr->name);\r\nSIM_TEST(attach_cmd (0, cmd));\r\nsprintf (cmd, \"%s -S -E File40.deck\", dptr->name);\r\nSIM_TEST(attach_cmd (0, cmd));\r\nsprintf (saved_filename, \"%s %s\", dptr->name, dptr->units->filename);\r\nshow_cmd (0, dptr->name);\r\nsim_printf (\"Input Hopper Count:  %d\\n\", (int)sim_card_input_hopper_count(dptr->units));\r\nsim_printf (\"Output Hopper Count: %d\\n\", (int)sim_card_output_hopper_count(dptr->units));\r\nwhile (!sim_card_eof (dptr->units))\r\n    SIM_TEST(sim_read_card (dptr->units, card_image));\r\nsim_printf (\"Input Hopper Count:  %d\\n\", (int)sim_card_input_hopper_count(dptr->units));\r\nsim_printf (\"Output Hopper Count: %d\\n\", (int)sim_card_output_hopper_count(dptr->units));\r\nsim_printf (\"Detaching %s\\n\", dptr->name);\r\nSIM_TEST(detach_cmd (0, dptr->name));\r\nshow_cmd (0, dptr->name);\r\nsim_printf (\"Input Hopper Count:  %d\\n\", (int)sim_card_input_hopper_count(dptr->units));\r\nsim_printf (\"Output Hopper Count: %d\\n\", (int)sim_card_output_hopper_count(dptr->units));\r\nsim_printf (\"Attaching Saved Filenames: %s\\n\", saved_filename + strlen(dptr->name));\r\nSIM_TEST(attach_cmd (0, saved_filename));\r\nshow_cmd (0, dptr->name);\r\nsim_printf (\"Input Hopper Count:  %d\\n\", (int)sim_card_input_hopper_count(dptr->units));\r\nsim_printf (\"Output Hopper Count: %d\\n\", (int)sim_card_output_hopper_count(dptr->units));\r\nSIM_TEST(detach_cmd (0, dptr->name));\r\n(void)remove (\"file10.deck\");\r\n(void)remove (\"file20.deck\");\r\n(void)remove (\"file30.deck\");\r\n(void)remove (\"file40.deck\");\r\n#endif /* defined(USE_SIM_CARD) && defined(SIM_CARD_API) */\r\nreturn stat;\r\n}\r\n\r\n#else   /* !defined(USE_SIM_CARD) */\r\n\r\nt_stat sim_card_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\n    return SCPE_OK;\r\n}\r\n\r\nt_stat sim_card_test (DEVICE *dptr, const char *cptr)\r\n{\r\n    return SCPE_OK;\r\n}\r\n\r\n#endif /* USE_SIM_CARD */\r\n"
        },
        {
          "name": "sim_card.h",
          "type": "blob",
          "size": 6.2265625,
          "content": "/* Generic Card read/punch routines for simulators.\r\n\r\n   Copyright (c) 2005, Richard Cornwell\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   This is the standard card reader.\r\n   This is the standard card punch.\r\n\r\n   Input formats are accepted in a variaty of formats:\r\n        Standard ASCII: one record per line.\r\n                returns are ignored.\r\n                tabs are expanded to modules 8 characters.\r\n                ~ in first column is treated as a EOF.\r\n\r\n        Binary Card format:\r\n                Each record 160 characters.\r\n                First character   21012345\r\n                                  111\r\n                Second characters 6789----\r\n                Top 4 bits of second character are 0.\r\n                It is unlikely that ascii text or BCD format\r\n                text could produce similar profile.\r\n\r\n        BCD Format:\r\n                Each record variable length (80 chars or less).\r\n                Record mark has bit 7 set.\r\n                Bit 6 is even parity.\r\n                Bits 5-0 are character.\r\n\r\n        CBN Format:\r\n                Each record 160 charaters.\r\n                First char has bit 7 set. Rest set to 0.\r\n                Bit 6 is odd parity.\r\n                Bit 5-0 of first character are top 6 bits\r\n                        of card.\r\n                Bit 5-0 of second character are lower 6 bits\r\n                        of card.\r\n\r\n    For autodetection of BCD card format, there can be no parity errors.\r\n    All undeterminate formats are treated as ASCII. CBN and BCD cards\r\n    must also contain short or full records, if the record is not terminate\r\n    early by a EOR flag, then only up to record size (80 for BCD and\r\n    160 for CBN will be read).\r\n\r\n\r\n    ASCII mode recognizes some additional forms of input which allows the\r\n    intermixing of binary cards with text cards.\r\n\r\n    Lines beginning with ~raw are taken as a number of 4 digit octal values\r\n    with represent each column of the card from 12 row down to 9 row. If there\r\n    is not enough octal numbers to span a full card the remainder of the\r\n    card will not be punched.\r\n\r\n    Also ~eor, will generate a 7/8/9 punch card. An ~eof will gernerate a\r\n    6/7/9 punch card, and a ~eoi will generate a 6/7/8/9 punch.\r\n\r\n    A single line of ~ will set the EOF flag when that card is read.\r\n\r\n    Auto output format is ASCII if card has only printable characters\r\n    or card format binary.\r\n*/\r\n\f\r\n#ifndef SIM_CARD_H_\r\n#define SIM_CARD_H_     0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#define SIM_CARD_API    2               /* API Version */\r\n\r\n#define DEBUG_CARD      0x80000000      /* Show details */\r\n\r\n/* Flags for punch and reader. */\r\n#define UNIT_V_CARD_MODE  (UNIT_V_UF + 0)\r\n#define UNIT_CARD_MODE  (7 << UNIT_V_CARD_MODE)\r\n#define MODE_AUTO       (0 << UNIT_V_CARD_MODE)\r\n#define MODE_BIN        (1 << UNIT_V_CARD_MODE)\r\n#define MODE_TEXT       (2 << UNIT_V_CARD_MODE)\r\n#define MODE_BCD        (3 << UNIT_V_CARD_MODE)\r\n#define MODE_CBN        (4 << UNIT_V_CARD_MODE)\r\n#define MODE_EBCDIC     (5 << UNIT_V_CARD_MODE)\r\n#define MODE_OCTAL      (6 << UNIT_V_CARD_MODE)\r\n/* Allow lower case letters */\r\n#define MODE_LOWER      (8 << UNIT_V_CARD_MODE)\r\n#define MODE_026        (0x10 << UNIT_V_CARD_MODE)\r\n#define MODE_029        (0x20 << UNIT_V_CARD_MODE)\r\n#define MODE_DEC29      (0x30 << UNIT_V_CARD_MODE)\r\n#define MODE_CHAR       (0x70 << UNIT_V_CARD_MODE)\r\n\f\r\n\r\n/* Card Reader Return Status code */\r\ntypedef int t_cdstat;\r\n#define CDSE_OK     0   /* Good */\r\n#define CDSE_EOF    1   /* End of File */\r\n#define CDSE_EMPTY  2   /* Input Hopper Empty */\r\n#define CDSE_ERROR  3   /* Error Card Read */\r\n\r\n/* Generic routines. */\r\n\r\n     /* Read next card into image row 12,11,10,1-9 */\r\n     /* Return SCPE_EOF if end file detected. */\r\nt_cdstat sim_read_card(UNIT * uptr, uint16 image[80]);\r\n     /* Punch card from image row 12,11,10,1-9 */\r\nt_cdstat sim_punch_card(UNIT * uptr, uint16 image[80]);\r\n     /* Check if next card to be read is EOF */\r\nint      sim_card_eof(UNIT * uptr);\r\n     /* Return number of cards yet to read */\r\nt_addr   sim_hopper_size(UNIT * uptr);\r\n     /* Return number of cards punched */\r\nt_addr   sim_punch_count(UNIT * uptr);\r\nt_addr   sim_card_input_hopper_count(UNIT *uptr);\r\nt_addr   sim_card_output_hopper_count(UNIT *uptr);\r\nt_stat   sim_card_attach(UNIT * uptr, CONST char *file);\r\nt_stat   sim_card_detach(UNIT *uptr);\r\n\r\n/* Conversion routines to save code */\r\nuint16   sim_bcd_to_hol(uint8 bcd);\r\nuint16   sim_ebcdic_to_hol(uint8 ebcdic);\r\nuint8    sim_hol_to_bcd(uint16 hol);\r\nuint16   sim_hol_to_ebcdic(uint16 hol);\r\n\r\n/* Format control routines. */\r\nt_stat   sim_card_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat   sim_card_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\n\r\n/* Help information */\r\nt_stat   sim_card_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr);\r\n\r\n/* Translation tables */\r\nextern const char      sim_six_to_ascii[64];        /* Map BCD to ASCII */\r\nextern const char      sim_ascii_to_six[128];       /* Map 7 bit ASCII to BCD */\r\nextern const uint8     sim_parity_table[64];        /* 64 entry odd parity table */\r\n\r\n/* Unit test routine */\r\nextern t_stat sim_card_test (DEVICE *dptr, const char *cptr);\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_console.c",
          "type": "blob",
          "size": 158.2099609375,
          "content": "/* sim_console.c: simulator console I/O library\r\n\r\n   Copyright (c) 1993-2014, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   02-Jan-14    RMS     Added tab stop routines\r\n   18-Mar-12    RMS     Removed unused reference to sim_switches (Dave Bryan)\r\n   07-Dec-11    MP      Added sim_ttisatty to support reasonable behaviour (i.e.\r\n                        avoid in infinite loop) in the main command input\r\n                        loop when EOF is detected and input is coming from\r\n                        a file (or a null device: /dev/null or NUL:) This may\r\n                        happen when a simulator is running in a background\r\n                        process.\r\n   17-Apr-11    MP      Cleaned up to support running in a background/detached\r\n                        process\r\n   20-Jan-11    MP      Fixed support for BREAK key on Windows to account\r\n                        for/ignore other keyboard Meta characters.\r\n   18-Jan-11    MP      Added log file reference count support\r\n   17-Jan-11    MP      Added support for a \"Buffered\" behaviors which include:\r\n                        - If Buffering is enabled and Telnet is enabled, a\r\n                          telnet connection is not required for simulator\r\n                          operation (instruction execution).\r\n                        - If Buffering is enabled, all console output is\r\n                          written to the buffer at all times (deleting the\r\n                          oldest buffer contents on overflow).\r\n                        - when a connection is established on the console\r\n                          telnet port, the whole contents of the Buffer is\r\n                          presented on the telnet session and connection\r\n                          will then proceed as if the connection had always\r\n                          been there.\r\n                        This concept allows a simulator to run in the background\r\n                        and when needed a console session to be established.\r\n                        The \"when needed\" case usually will be interested in\r\n                        what already happened before looking to address what\r\n                        to do, hence the buffer contents being presented.\r\n   28-Dec-10    MP      Added support for BREAK key on Windows\r\n   30-Sep-06    RMS     Fixed non-printable characters in KSR mode\r\n   22-Jun-06    RMS     Implemented SET/SHOW PCHAR\r\n   31-May-06    JDB     Fixed bug if SET CONSOLE DEBUG with no argument\r\n   22-Nov-05    RMS     Added central input/output conversion support\r\n   05-Nov-04    RMS     Moved SET/SHOW DEBUG under CONSOLE hierarchy\r\n   28-Oct-04    JDB     Fixed SET CONSOLE to allow comma-separated parameters\r\n   20-Aug-04    RMS     Added OS/2 EMX fixes (Holger Veit)\r\n   14-Jul-04    RMS     Revised Windows console code (Dave Bryan)\r\n   28-May-04    RMS     Added SET/SHOW CONSOLE\r\n                RMS     Added break, delete character maps\r\n   02-Jan-04    RMS     Removed timer routines, added Telnet console routines\r\n                RMS     Moved console logging to OS-independent code\r\n   25-Apr-03    RMS     Added long seek support (Mark Pizzolato)\r\n                        Added Unix priority control (Mark Pizzolato)\r\n   24-Sep-02    RMS     Removed VT support, added Telnet console support\r\n                        Added CGI support (Brian Knittel)\r\n                        Added MacOS sleep (Peter Schorn)\r\n   14-Jul-02    RMS     Added Windows priority control (Mark Pizzolato)\r\n   20-May-02    RMS     Added Windows VT support (Fischer Franz)\r\n   01-Feb-02    RMS     Added VAX fix (Robert Alan Byer)\r\n   19-Sep-01    RMS     More MacOS changes\r\n   31-Aug-01    RMS     Changed int64 to t_int64 for Windoze\r\n   20-Jul-01    RMS     Added MacOS support (Louis Chretien, Peter Schorn, Ben Supnik)\r\n   15-May-01    RMS     Added logging support\r\n   05-Mar-01    RMS     Added clock calibration support\r\n   08-Dec-00    BKR     Added OS/2 support (Bruce Ray)\r\n   18-Aug-98    RMS     Added BeOS support\r\n   13-Oct-97    RMS     Added NetBSD terminal support\r\n   25-Jan-97    RMS     Added POSIX terminal I/O support\r\n   02-Jan-97    RMS     Fixed bug in sim_poll_kbd\r\n\r\n   This module implements the following routines to support terminal and\r\n   Remote Console I/O:\r\n\r\n   sim_poll_kbd                 poll for keyboard input\r\n   sim_putchar                  output character to console\r\n   sim_putchar_s                output character to console, stall if congested\r\n   sim_set_console              set console parameters\r\n   sim_show_console             show console parameters\r\n   sim_set_remote_console       set remote console parameters\r\n   sim_show_remote_console      show remote console parameters\r\n   sim_set_cons_buff            set console buffered\r\n   sim_set_cons_unbuff          set console unbuffered\r\n   sim_set_cons_log             set console log\r\n   sim_set_cons_nolog           set console nolog\r\n   sim_show_cons_buff           show console buffered\r\n   sim_show_cons_log            show console log\r\n   sim_tt_inpcvt                convert input character per mode\r\n   sim_tt_outcvt                convert output character per mode\r\n   sim_cons_get_send            get console send structure address\r\n   sim_cons_get_expect          get console expect structure address\r\n   sim_show_cons_send_input     show pending input data\r\n   sim_show_cons_expect         show expect rules and state\r\n   sim_ttinit                   called once to get initial terminal state\r\n   sim_ttrun                    called to put terminal into run state\r\n   sim_ttcmd                    called to return terminal to command state\r\n   sim_ttclose                  called once before the simulator exits\r\n   sim_ttisatty                 called to determine if running interactively\r\n   sim_os_poll_kbd              poll for keyboard input\r\n   sim_os_putchar               output character to console\r\n   sim_set_noconsole_port       Enable automatic WRU console polling\r\n   sim_set_stable_registers_state Declare that all registers are always stable\r\n\r\n\r\n   The first group is OS-independent; the second group is OS-dependent.\r\n\r\n   The following routines are exposed but deprecated:\r\n\r\n   sim_set_telnet               set console to Telnet port\r\n   sim_set_notelnet             close console Telnet port\r\n   sim_show_telnet              show console status\r\n*/\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_scp_private.h\"\r\n#include \"sim_tmxr.h\"\r\n#include \"sim_serial.h\"\r\n#include \"sim_timer.h\"\r\n\r\n#ifdef __HAIKU__\r\n#define nice(n) ({})\r\n#endif\r\n\r\n#ifndef MIN\r\n#define MIN(a,b)  (((a) <= (b)) ? (a) : (b))\r\n#endif\r\n\r\n#if defined(_WIN32) || defined(__hpux)\r\nint setenv(const char *envname, const char *envval, int overwrite);\r\n#endif\r\n\r\n/* Forward Declarations of Platform specific routines */\r\n\r\nstatic t_stat sim_os_poll_kbd (void);\r\nstatic t_bool sim_os_poll_kbd_ready (int ms_timeout);\r\nstatic t_stat sim_os_putchar (int32 out);\r\nstatic t_stat sim_os_ttinit (void);\r\nstatic t_stat sim_os_ttrun (void);\r\nstatic t_stat sim_os_ttcmd (void);\r\nstatic t_stat sim_os_ttclose (void);\r\nstatic t_bool sim_os_fd_isatty (int fd);\r\nstatic t_stat sim_os_connect_telnet (int port);\r\n\r\nstatic t_stat sim_set_rem_telnet (int32 flag, CONST char *cptr);\r\nstatic t_stat sim_set_rem_bufsize (int32 flag, CONST char *cptr);\r\nstatic t_stat sim_set_rem_connections (int32 flag, CONST char *cptr);\r\nstatic t_stat sim_set_rem_timeout (int32 flag, CONST char *cptr);\r\nstatic t_stat sim_set_rem_master (int32 flag, CONST char *cptr);\r\n\r\n/* Deprecated CONSOLE HALT, CONSOLE RESPONSE and CONSOLE DELAY support */\r\nstatic t_stat sim_set_halt (int32 flag, CONST char *cptr);\r\nstatic t_stat sim_set_response (int32 flag, CONST char *cptr);\r\nstatic t_stat sim_set_delay (int32 flag, CONST char *cptr);\r\n\r\n\r\n#define KMAP_WRU        0\r\n#define KMAP_BRK        1\r\n#define KMAP_DEL        2\r\n#define KMAP_DBGINT     3\r\n#define KMAP_MASK       0377\r\n#define KMAP_NZ         0400\r\n\r\nint32 sim_int_char = 005;                               /* interrupt character */\r\nint32 sim_dbg_int_char = 0;                             /* SIGINT char under debugger */\r\nstatic t_bool sigint_message_issued = FALSE;\r\nint32 sim_brk_char = 000;                               /* break character */\r\nint32 sim_tt_pchar = 0x00002780;\r\n#if defined (_WIN32)\r\nint32 sim_del_char = '\\b';                              /* delete character */\r\n#else\r\nint32 sim_del_char = 0177;\r\n#endif\r\nt_bool sim_signaled_int_char                            /* WRU character detected by signal while running */\r\n#if defined (_WIN32) || defined (_VMS) || defined (__CYGWIN__) || (defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL))\r\n                             = FALSE;\r\n#else\r\n                             = TRUE;\r\n#endif\r\nuint32 sim_last_poll_kbd_time;                          /* time when sim_poll_kbd was called */\r\nextern TMLN *sim_oline;                                 /* global output socket */\r\nstatic uint32 sim_con_pos;                              /* console character output count */\r\n\r\nstatic t_stat sim_con_poll_svc (UNIT *uptr);                /* console connection poll routine */\r\nstatic t_stat sim_con_reset (DEVICE *dptr);                 /* console reset routine */\r\nstatic t_stat sim_con_attach (UNIT *uptr, CONST char *ptr); /* console attach routine (save,restore) */\r\nstatic t_stat sim_con_detach (UNIT *uptr);                  /* console detach routine (save,restore) */\r\n\r\nUNIT sim_con_units[2] = {{ UDATA (&sim_con_poll_svc, UNIT_ATTABLE, 0)}}; /* console connection unit */\r\n#define sim_con_unit sim_con_units[0]\r\n\r\n/* debugging bitmaps */\r\n#define DBG_TRC  TMXR_DBG_TRC                           /* trace routine calls */\r\n#define DBG_XMT  TMXR_DBG_XMT                           /* display Transmitted Data */\r\n#define DBG_RCV  TMXR_DBG_RCV                           /* display Received Data */\r\n#define DBG_RET  TMXR_DBG_RET                           /* display Returned Received Data */\r\n#define DBG_CON  TMXR_DBG_CON                           /* display connection activity */\r\n#define DBG_EXP  0x00000001                             /* Expect match activity */\r\n#define DBG_SND  0x00000002                             /* Send (Inject) data activity */\r\n\r\nstatic DEBTAB sim_con_debug[] = {\r\n  {\"TRC\",    DBG_TRC, \"routine calls\"},\r\n  {\"XMT\",    DBG_XMT, \"Transmitted Data\"},\r\n  {\"RCV\",    DBG_RCV, \"Received Data\"},\r\n  {\"RET\",    DBG_RET, \"Returned Received Data\"},\r\n  {\"CON\",    DBG_CON, \"connection activity\"},\r\n  {\"EXP\",    DBG_EXP, \"Expect match activity\"},\r\n  {\"SND\",    DBG_SND, \"Send (Inject) data activity\"},\r\n  {0}\r\n};\r\n\r\nstatic REG sim_con_reg[] = {\r\n    { ORDATAD (WRU,         sim_int_char,  8, \"interrupt character\") },\r\n    { ORDATAD (BRK,         sim_brk_char,  8, \"break character\") },\r\n    { ORDATAD (DEL,         sim_del_char,  8, \"delete character \") },\r\n    { ORDATAD (PCHAR,       sim_tt_pchar, 32, \"printable character mask\") },\r\n    { DRDATAD (CONSOLE_POS, sim_con_pos,  32, \"character output count\") },\r\n  { 0 },\r\n};\r\n\r\nstatic MTAB sim_con_mod[] = {\r\n  { 0 },\r\n};\r\n\r\nstatic const char *sim_con_telnet_description (DEVICE *dptr)\r\n{\r\nreturn \"Console telnet support\";\r\n}\r\n\r\nDEVICE sim_con_telnet = {\r\n    \"CON-TELNET\", sim_con_units, sim_con_reg, sim_con_mod,\r\n    2, 0, 0, 0, 0, 0,\r\n    NULL, NULL, sim_con_reset, NULL, sim_con_attach, sim_con_detach,\r\n    NULL, DEV_DEBUG | DEV_NOSAVE, 0, sim_con_debug,\r\n    NULL, NULL, NULL, NULL, NULL, sim_con_telnet_description};\r\nTMLN sim_con_ldsc = { 0 };                                          /* console line descr */\r\nTMXR sim_con_tmxr = { 1, 0, 0, &sim_con_ldsc, NULL, &sim_con_telnet };/* console line mux */\r\n\r\n\r\nSEND sim_con_send = {0, &sim_con_telnet, DBG_SND};\r\nEXPECT sim_con_expect = {&sim_con_telnet, DBG_EXP};\r\n\r\nstatic t_bool sim_con_console_port = TRUE;\r\n\r\n/* Enable automatic WRU console polling */\r\n\r\nt_stat sim_set_noconsole_port (void)\r\n{\r\nsim_con_console_port = FALSE;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_bool sim_con_stable_registers = FALSE;\r\n\r\n/* Enable automatic WRU console polling */\r\n\r\nt_stat sim_set_stable_registers_state (void)\r\n{\r\nsim_con_stable_registers = TRUE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Unit service for console connection polling */\r\n\r\nstatic t_stat sim_con_poll_svc (UNIT *uptr)\r\n{\r\nif ((sim_con_tmxr.master == 0) &&                       /* not Telnet and not serial and not WRU polling? */\r\n    (sim_con_ldsc.serport == 0) &&\r\n    (sim_con_console_port))\r\n    return SCPE_OK;                                     /* done */\r\nif (tmxr_poll_conn (&sim_con_tmxr) >= 0)                /* poll connect */\r\n    sim_con_ldsc.rcve = 1;                              /* rcv enabled */\r\nsim_activate_after(uptr, 1000000);                      /* check again in 1 second */\r\nif (!sim_con_console_port)                              /* WRU poll needed */\r\n    sim_poll_kbd();                                     /* sets global stop_cpu when WRU received */\r\nif (sim_con_ldsc.conn)\r\n    tmxr_send_buffered_data (&sim_con_ldsc);            /* try to flush any buffered data */\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_con_reset (DEVICE *dptr)\r\n{\r\ndptr->units[1].flags = UNIT_DIS;\r\nreturn sim_con_poll_svc (&dptr->units[0]);              /* establish polling as needed */\r\n}\r\n\r\n/* Console Attach/Detach - only used indirectly in restore */\r\n\r\nstatic t_stat sim_con_attach (UNIT *uptr, CONST char *ptr)\r\n{\r\nreturn tmxr_attach (&sim_con_tmxr, &sim_con_unit, ptr);\r\n}\r\n\r\nstatic t_stat sim_con_detach (UNIT *uptr)\r\n{\r\nreturn sim_set_notelnet (0, NULL);\r\n}\r\n\r\n/* Set/show data structures */\r\n\r\nstatic CTAB set_con_tab[] = {\r\n    { \"WRU\",     &sim_set_kmap, KMAP_WRU    | KMAP_NZ },\r\n    { \"BRK\",     &sim_set_kmap, KMAP_BRK },\r\n    { \"DEL\",     &sim_set_kmap, KMAP_DEL    | KMAP_NZ },\r\n    { \"DBGINT\",  &sim_set_kmap, KMAP_DBGINT | KMAP_NZ },\r\n    { \"PCHAR\",   &sim_set_pchar, 0 },\r\n    { \"SPEED\",   &sim_set_cons_speed, 0 },\r\n    { \"TELNET\",  &sim_set_telnet, 0 },\r\n    { \"NOTELNET\", &sim_set_notelnet, 0 },\r\n    { \"SERIAL\",  &sim_set_serial, 0 },\r\n    { \"NOSERIAL\", &sim_set_noserial, 0 },\r\n    { \"LOG\",     &sim_set_logon, 0 },\r\n    { \"NOLOG\",   &sim_set_logoff, 0 },\r\n    { \"DEBUG\",   &sim_set_debon, 0 },\r\n    { \"NODEBUG\", &sim_set_deboff, 0 },\r\n#define CMD_WANTSTR     0100000\r\n    { \"HALT\", &sim_set_halt, 1 | CMD_WANTSTR },\r\n    { \"NOHALT\", &sim_set_halt, 0 },\r\n    { \"DELAY\", &sim_set_delay, 0 },\r\n    { \"RESPONSE\", &sim_set_response, 1 | CMD_WANTSTR },\r\n    { \"NORESPONSE\", &sim_set_response, 0 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\nstatic CTAB set_rem_con_tab[] = {\r\n    { \"CONNECTIONS\", &sim_set_rem_connections, 0 },\r\n    { \"TELNET\", &sim_set_rem_telnet, 1 },\r\n    { \"BUFFERSIZE\", &sim_set_rem_bufsize, 1 },\r\n    { \"NOTELNET\", &sim_set_rem_telnet, 0 },\r\n    { \"TIMEOUT\", &sim_set_rem_timeout, 0 },\r\n    { \"MASTER\", &sim_set_rem_master, 1 },\r\n    { \"NOMASTER\", &sim_set_rem_master, 0 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\nstatic SHTAB show_con_tab[] = {\r\n    { \"WRU\", &sim_show_kmap, KMAP_WRU },\r\n    { \"BRK\", &sim_show_kmap, KMAP_BRK },\r\n    { \"DEL\", &sim_show_kmap, KMAP_DEL },\r\n#if (defined(__GNUC__) && !defined(__OPTIMIZE__) && !defined(_WIN32))       /* Debug build? */\r\n    { \"DBGINT\", &sim_show_kmap, KMAP_DBGINT },\r\n#endif\r\n    { \"PCHAR\", &sim_show_pchar, 0 },\r\n    { \"SPEED\", &sim_show_cons_speed, 0 },\r\n    { \"LOG\", &sim_show_cons_log, 0 },\r\n    { \"TELNET\", &sim_show_telnet, 0 },\r\n    { \"DEBUG\", &sim_show_cons_debug, 0 },\r\n    { \"BUFFERED\", &sim_show_cons_buff, 0 },\r\n    { \"EXPECT\", &sim_show_cons_expect, 0 },\r\n    { \"HALT\", &sim_show_cons_expect, -1 },\r\n    { \"INPUT\", &sim_show_cons_send_input, 0 },\r\n    { \"RESPONSE\", &sim_show_cons_send_input, -1 },\r\n    { \"DELAY\", &sim_show_cons_expect, -1 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\nstatic CTAB set_con_telnet_tab[] = {\r\n    { \"LOG\", &sim_set_cons_log, 0 },\r\n    { \"NOLOG\", &sim_set_cons_nolog, 0 },\r\n    { \"BUFFERED\", &sim_set_cons_buff, 0 },\r\n    { \"NOBUFFERED\", &sim_set_cons_unbuff, 0 },\r\n    { \"UNBUFFERED\", &sim_set_cons_unbuff, 0 },\r\n    { \"CONNECT\", &sim_set_cons_connect, 0 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\nstatic CTAB set_con_serial_tab[] = {\r\n    { \"LOG\", &sim_set_cons_log, 0 },\r\n    { \"NOLOG\", &sim_set_cons_nolog, 0 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\nstatic int32 *cons_kmap[] = {\r\n    &sim_int_char,\r\n    &sim_brk_char,\r\n    &sim_del_char,\r\n    &sim_dbg_int_char\r\n    };\r\n\r\n/* Console I/O package.\r\n\r\n   The console terminal can be attached to the controlling window\r\n   or to a Telnet connection.  If attached to a Telnet connection,\r\n   the console is described by internal terminal multiplexor\r\n   sim_con_tmxr and internal terminal line description sim_con_ldsc.\r\n*/\r\n\r\n/* SET CONSOLE command */\r\n\r\nt_stat sim_set_console (int32 flag, CONST char *cptr)\r\n{\r\nchar *cvptr, gbuf[CBUFSIZE];\r\nCTAB *ctptr;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph_nc (cptr, gbuf, ',');              /* get modifier */\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    get_glyph (gbuf, gbuf, 0);                          /* modifier to UC */\r\n    if ((ctptr = find_ctab (set_con_tab, gbuf))) {      /* match? */\r\n        r = ctptr->action (ctptr->arg, cvptr);          /* do the rest */\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        }\r\n    else\r\n        return sim_messagef (SCPE_NOPARAM, \"Invalid console parameter: %s\\n\", gbuf);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* SHOW CONSOLE command */\r\n\r\nt_stat sim_show_console (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nSHTAB *shptr;\r\nint32 i;\r\n\r\nif (*cptr == 0) {                                       /* show all */\r\n    for (i = 0; show_con_tab[i].name; i++)\r\n        if (show_con_tab[i].arg != -1)\r\n            show_con_tab[i].action (st, dptr, uptr, show_con_tab[i].arg, cptr);\r\n    return SCPE_OK;\r\n    }\r\nwhile (*cptr != 0) {\r\n    cptr = get_glyph (cptr, gbuf, ',');                 /* get modifier */\r\n    if ((shptr = find_shtab (show_con_tab, gbuf)))\r\n        shptr->action (st, dptr, uptr, shptr->arg, NULL);\r\n    else\r\n        return sim_messagef (SCPE_NOPARAM, \"Invalid console parameter: %s\\n\", gbuf);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n#define MAX_REMOTE_SESSIONS 40                          /* Arbitrary Session Limit */\r\n\r\nt_stat sim_rem_con_poll_svc (UNIT *uptr);               /* remote console connection poll routine */\r\nt_stat sim_rem_con_data_svc (UNIT *uptr);               /* remote console connection data routine */\r\nt_stat sim_rem_con_repeat_svc (UNIT *uptr);             /* remote auto repeat command console timing routine */\r\nt_stat sim_rem_con_smp_collect_svc (UNIT *uptr);        /* remote remote register data sampling routine */\r\nt_stat sim_rem_con_reset (DEVICE *dptr);                /* remote console reset routine */\r\n#define rem_con_poll_unit (&sim_remote_console.units[0])\r\n#define rem_con_data_unit (&sim_remote_console.units[1])\r\n#define REM_CON_BASE_UNITS 2\r\n#define rem_con_repeat_units (&sim_remote_console.units[REM_CON_BASE_UNITS])\r\n#define rem_con_smp_smpl_units (&sim_remote_console.units[REM_CON_BASE_UNITS+sim_rem_con_tmxr.lines])\r\n\r\n#define DBG_MOD  0x00000004                             /* Remote Console Mode activities */\r\n#define DBG_REP  0x00000008                             /* Remote Console Repeat activities */\r\n#define DBG_SAM  0x00000010                             /* Remote Console Sample activities */\r\n#define DBG_CMD  0x00000020                             /* Remote Console Command activities */\r\n\r\nDEBTAB sim_rem_con_debug[] = {\r\n  {\"TRC\",    DBG_TRC, \"routine calls\"},\r\n  {\"XMT\",    DBG_XMT, \"Transmitted Data\"},\r\n  {\"RCV\",    DBG_RCV, \"Received Data\"},\r\n  {\"CON\",    DBG_CON, \"connection activity\"},\r\n  {\"CMD\",    DBG_CMD, \"Remote Console Command activity\"},\r\n  {\"MODE\",   DBG_MOD, \"Remote Console Mode activity\"},\r\n  {\"REPEAT\", DBG_REP, \"Remote Console Repeat activity\"},\r\n  {\"SAMPLE\", DBG_SAM, \"Remote Console Sample activity\"},\r\n  {0}\r\n};\r\n\r\nMTAB sim_rem_con_mod[] = {\r\n  { 0 },\r\n};\r\n\r\nstatic const char *sim_rem_con_description (DEVICE *dptr)\r\n{\r\nreturn \"Remote Console Facility\";\r\n}\r\n\r\nDEVICE sim_remote_console = {\r\n    \"REM-CON\", NULL, NULL, sim_rem_con_mod,\r\n    0, 0, 0, 0, 0, 0,\r\n    NULL, NULL, sim_rem_con_reset, NULL, NULL, NULL,\r\n    NULL, DEV_DEBUG | DEV_NOSAVE, 0, sim_rem_con_debug,\r\n    NULL, NULL, NULL, NULL, NULL, sim_rem_con_description};\r\n\r\ntypedef struct BITSAMPLE BITSAMPLE;\r\nstruct BITSAMPLE {\r\n    int             tot;            /* total of all values */\r\n    int             ptr;            /* pointer to next value cell */\r\n    int             depth;          /* number of values */\r\n    int             *vals;          /* values */\r\n    };\r\ntypedef struct BITSAMPLE_REG BITSAMPLE_REG;\r\nstruct BITSAMPLE_REG {\r\n    REG             *reg;           /* Register to be sampled */\r\n    uint32           idx;           /* Register index */\r\n    t_bool          indirect;       /* Register value points at memory */\r\n    DEVICE          *dptr;          /* Device register is part of */\r\n    UNIT            *uptr;          /* Unit Register is related to */\r\n    uint32          width;          /* number of bits to sample */\r\n    BITSAMPLE       *bits;\r\n    };\r\ntypedef struct REMOTE REMOTE;\r\nstruct REMOTE {\r\n    size_t          buf_size;\r\n    size_t          buf_ptr;\r\n    char            *buf;\r\n    char            *act_buf;\r\n    size_t          act_buf_size;\r\n    char            *act;\r\n    t_bool          single_mode;\r\n    uint32          read_timeout;\r\n    int             line;                   /* remote console line number */\r\n    TMLN            *lp;                    /* mux line/socket for remote session */\r\n    UNIT            *uptr;                  /* remote console unit */\r\n    uint32          repeat_interval;        /* usecs between repeat execution */\r\n    t_bool          repeat_pending;         /* repeat delivery pending */\r\n    char            *repeat_action;         /* command(s) to repeatedly execute */\r\n    int             smp_sample_interval;    /* cycles between samples */\r\n    int             smp_sample_dither_pct;  /* dithering of cycles interval */\r\n    uint32          smp_reg_count;          /* sample register count */\r\n    BITSAMPLE_REG   *smp_regs;              /* registers being sampled */\r\n    };\r\nREMOTE *sim_rem_consoles = NULL;\r\n\r\nstatic TMXR sim_rem_con_tmxr = { 0, 0, 0, NULL, NULL, &sim_remote_console };/* remote console line mux */\r\nstatic uint32 sim_rem_read_timeout = 30;    /* seconds before automatic continue */\r\nstatic int32 sim_rem_active_number = -1;    /* -1 - not active, >= 0 is index of active console */\r\nint32 sim_rem_cmd_active_line = -1;         /* step in progress on line # */\r\nstatic CTAB *sim_rem_active_command = NULL; /* active command */\r\nstatic char *sim_rem_command_buf;           /* active command buffer */\r\nstatic t_bool sim_log_temp = FALSE;         /* temporary log file active */\r\nstatic char sim_rem_con_temp_name[PATH_MAX+1];\r\nstatic t_bool sim_rem_master_mode = FALSE;  /* Master Mode Enabled Flag */\r\nstatic t_bool sim_rem_master_was_enabled = FALSE; /* Master was Enabled */\r\nstatic t_bool sim_rem_master_was_connected = FALSE; /* Master Mode has been connected */\r\nstatic t_offset sim_rem_cmd_log_start = 0;  /* Log File saved position */\r\n\r\nstatic t_stat sim_rem_sample_output (FILE *st, int32 line)\r\n{\r\nREMOTE *rem = &sim_rem_consoles[line];\r\nuint32 reg;\r\n\r\nif (rem->smp_reg_count == 0) {\r\n    fprintf (st, \"Samples are not being collected\\n\");\r\n    return SCPE_OK;\r\n    }\r\nfor (reg = 0; reg < rem->smp_reg_count; reg++) {\r\n    uint32 bit;\r\n\r\n    if (rem->smp_regs[reg].reg->depth > 1)\r\n        fprintf (st, \"}%s %s[%d] %s %d:\", rem->smp_regs[reg].dptr->name, rem->smp_regs[reg].reg->name, rem->smp_regs[reg].idx, rem->smp_regs[reg].indirect ? \" -I\" : \"\", rem->smp_regs[reg].bits[0].depth);\r\n    else\r\n        fprintf (st, \"}%s %s%s %d:\", rem->smp_regs[reg].dptr->name, rem->smp_regs[reg].reg->name, rem->smp_regs[reg].indirect ? \" -I\" : \"\", rem->smp_regs[reg].bits[0].depth);\r\n    for (bit = 0; bit < rem->smp_regs[reg].width; bit++)\r\n        fprintf (st, \"%s%d\", (bit != 0) ? \",\" : \"\", rem->smp_regs[reg].bits[bit].tot);\r\n    fprintf (st, \"\\n\");\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* SET REMOTE CONSOLE command */\r\n\r\nt_stat sim_set_remote_console (int32 flag, CONST char *cptr)\r\n{\r\nchar *cvptr, gbuf[CBUFSIZE];\r\nCTAB *ctptr;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph_nc (cptr, gbuf, ',');              /* get modifier */\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    get_glyph (gbuf, gbuf, 0);                          /* modifier to UC */\r\n    if ((ctptr = find_ctab (set_rem_con_tab, gbuf))) {  /* match? */\r\n        r = ctptr->action (ctptr->arg, cvptr);          /* do the rest */\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        }\r\n    else\r\n        return sim_messagef (SCPE_NOPARAM, \"Invalid remote console parameter: %s\\n\", gbuf);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* SHOW REMOTE CONSOLE command */\r\n\r\nt_stat sim_show_remote_console (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint32 i, connections;\r\nREMOTE *rem;\r\n\r\nif (*cptr != 0)\r\n    return SCPE_NOPARAM;\r\nif (sim_rem_active_number >= 0) {\r\n    if (sim_rem_master_mode && (sim_rem_active_number == 0))\r\n        fprintf (st, \"Running from Master Mode Remote Console Connection\\n\");\r\n    else\r\n        fprintf (st, \"Running from Remote Console Connection %d\\n\", sim_rem_active_number);\r\n    }\r\nif (sim_rem_con_tmxr.lines > 1)\r\n    fprintf (st, \"Remote Console Input Connections from %d sources are supported concurrently\\n\", sim_rem_con_tmxr.lines);\r\nif (sim_rem_read_timeout)\r\n    fprintf (st, \"Remote Console Input automatically continues after %d seconds\\n\", sim_rem_read_timeout);\r\nif (!sim_rem_con_tmxr.master)\r\n    fprintf (st, \"Remote Console Command input is disabled\\n\");\r\nelse {\r\n    fprintf (st, \"Remote Console Command Input listening on TCP port: %s\\n\", rem_con_poll_unit->filename);\r\n    fprintf (st, \"Remote Console Per Command Output buffer size:      %d bytes\\n\", sim_rem_con_tmxr.buffered);\r\n    }\r\nfor (i=connections=0; i<sim_rem_con_tmxr.lines; i++) {\r\n    rem = &sim_rem_consoles[i];\r\n    if (!rem->lp->conn)\r\n        continue;\r\n    ++connections;\r\n    if (connections == 1)\r\n        fprintf (st, \"\\nRemote Console Connections:\\n\");\r\n    tmxr_fconns (st, rem->lp, i);\r\n    if (rem->read_timeout != sim_rem_read_timeout) {\r\n        if (rem->read_timeout)\r\n            fprintf (st, \"Remote Console Input on connection %d automatically continues after %d seconds\\n\", i, rem->read_timeout);\r\n        else\r\n            fprintf (st, \"Remote Console Input on connection %d does not continue automatically\\n\", i);\r\n        }\r\n    if (rem->repeat_action) {\r\n        fprintf (st, \"The Command: %s\\n\", rem->repeat_action);\r\n        fprintf (st, \"    is repeated every %s\\n\", sim_fmt_secs (rem->repeat_interval / 1000000.0));\r\n        }\r\n    if (rem->smp_reg_count) {\r\n        uint32 reg;\r\n        DEVICE *dptr = NULL;\r\n\r\n        if (rem->smp_sample_dither_pct)\r\n            fprintf (st, \"Register Bit Sampling is occurring every %d %s (dithered %d percent)\\n\", rem->smp_sample_interval, sim_vm_interval_units, rem->smp_sample_dither_pct);\r\n        else\r\n            fprintf (st, \"Register Bit Sampling is occurring every %d %s\\n\", rem->smp_sample_interval, sim_vm_interval_units);\r\n        fprintf (st, \" Registers being sampled are: \");\r\n        for (reg = 0; reg < rem->smp_reg_count; reg++) {\r\n            if (rem->smp_regs[reg].indirect)\r\n                fprintf (st, \" indirect \");\r\n            if (dptr != rem->smp_regs[reg].dptr)\r\n                fprintf (st, \"%s \", rem->smp_regs[reg].dptr->name);\r\n            if (rem->smp_regs[reg].reg->depth > 1)\r\n                fprintf (st, \"%s[%d]%s\", rem->smp_regs[reg].reg->name, rem->smp_regs[reg].idx, ((reg + 1) < rem->smp_reg_count) ? \", \" : \"\");\r\n            else\r\n                fprintf (st, \"%s%s\", rem->smp_regs[reg].reg->name, ((reg + 1) < rem->smp_reg_count) ? \", \" : \"\");\r\n            dptr = rem->smp_regs[reg].dptr;\r\n            }\r\n        fprintf (st, \"\\n\");\r\n        if (sim_switches & SWMASK ('D'))\r\n            sim_rem_sample_output (st, rem->line);\r\n            fprintf (st, \"\\n\");\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Unit service for remote console connection polling */\r\n\r\nt_stat sim_rem_con_poll_svc (UNIT *uptr)\r\n{\r\nint32 c;\r\n\r\nc = tmxr_poll_conn (&sim_rem_con_tmxr);\r\nif (c >= 0) {                                           /* poll connect */\r\n    REMOTE *rem = &sim_rem_consoles[c];\r\n    TMLN *lp = rem->lp;\r\n    char wru_name[8];\r\n\r\n    sim_activate_after(rem_con_data_unit, 1000000);     /* start data poll after 1 second */\r\n    lp->rcve = 1;                                       /* rcv enabled */\r\n    rem->buf_ptr = 0;                                   /* start with empty command buffer */\r\n    rem->single_mode = TRUE;                            /* start in single command mode */\r\n    rem->read_timeout = sim_rem_read_timeout;           /* Start with default timeout */\r\n    if (isprint(sim_int_char&0xFF))\r\n        sprintf(wru_name, \"'%c'\", sim_int_char&0xFF);\r\n    else\r\n        if (sim_int_char <= 26)\r\n            sprintf(wru_name, \"^%c\", '@' + (sim_int_char&0xFF));\r\n        else\r\n            sprintf(wru_name, \"'\\\\%03o'\", sim_int_char&0xFF);\r\n    tmxr_linemsgf (lp, \"%s Remote Console\\r\\n\"\r\n                       \"Enter single commands or to enter multiple command mode enter the %s character\\r\"\r\n                       \"%s\",\r\n                       sim_name, wru_name,\r\n                       ((sim_rem_master_mode && (c == 0)) ? \"\" : \"\\nSimulator Running...\"));\r\n    if (sim_rem_master_mode && (c == 0))                /* Master Mode session? */\r\n        rem->single_mode = FALSE;                       /*  start in multi-command mode */\r\n    tmxr_send_buffered_data (lp);                       /* flush buffered data */\r\n    }\r\nsim_activate_after(uptr, 1000000);                      /* check again in 1 second */\r\nif (sim_con_ldsc.conn)\r\n    tmxr_send_buffered_data (&sim_con_ldsc);            /* try to flush any buffered data */\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat x_continue_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 1+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_repeat_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 2+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_collect_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 3+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_sampleout_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 4+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_execute_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 5+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_step_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 6+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_run_cmd (int32 flag, CONST char *cptr)\r\n{\r\nreturn 7+SCPE_IERR;         /* This routine should never be called */\r\n}\r\n\r\nstatic t_stat x_help_cmd (int32 flag, CONST char *cptr);\r\n\r\nstatic CTAB allowed_remote_cmds[] = {\r\n    { \"EXAMINE\",  &exdep_cmd,      EX_E },\r\n    { \"DEPOSIT\",  &exdep_cmd,      EX_D },\r\n    { \"EVALUATE\", &eval_cmd,          0 },\r\n    { \"ATTACH\",   &attach_cmd,        0 },\r\n    { \"DETACH\",   &detach_cmd,        0 },\r\n    { \"ASSIGN\",   &assign_cmd,        0 },\r\n    { \"DEASSIGN\", &deassign_cmd,      0 },\r\n    { \"CONTINUE\", &x_continue_cmd,    0 },\r\n    { \"REPEAT\",   &x_repeat_cmd,      0 },\r\n    { \"COLLECT\",  &x_collect_cmd,     0 },\r\n    { \"SAMPLEOUT\",&x_sampleout_cmd,   0 },\r\n    { \"PWD\",      &pwd_cmd,           0 },\r\n    { \"SAVE\",     &save_cmd,          0 },\r\n    { \"DIR\",      &dir_cmd,           0 },\r\n    { \"LS\",       &dir_cmd,           0 },\r\n    { \"ECHO\",     &echo_cmd,          0 },\r\n    { \"ECHOF\",    &echof_cmd,         0 },\r\n    { \"SET\",      &set_cmd,           0 },\r\n    { \"SHOW\",     &show_cmd,          0 },\r\n    { \"HELP\",     &x_help_cmd,        0 },\r\n    { NULL,       NULL }\r\n    };\r\n\r\nstatic CTAB allowed_master_remote_cmds[] = {\r\n    { \"EXAMINE\",  &exdep_cmd,      EX_E },\r\n    { \"DEPOSIT\",  &exdep_cmd,      EX_D },\r\n    { \"EVALUATE\", &eval_cmd,          0 },\r\n    { \"ATTACH\",   &attach_cmd,        0 },\r\n    { \"DETACH\",   &detach_cmd,        0 },\r\n    { \"ASSIGN\",   &assign_cmd,        0 },\r\n    { \"DEASSIGN\", &deassign_cmd,      0 },\r\n    { \"CONTINUE\", &x_continue_cmd,    0 },\r\n    { \"STEP\",     &x_step_cmd,        0 },\r\n    { \"REPEAT\",   &x_repeat_cmd,      0 },\r\n    { \"COLLECT\",  &x_collect_cmd,     0 },\r\n    { \"SAMPLEOUT\",&x_sampleout_cmd,   0 },\r\n    { \"EXECUTE\",  &x_execute_cmd,     0 },\r\n    { \"PWD\",      &pwd_cmd,           0 },\r\n    { \"SAVE\",     &save_cmd,          0 },\r\n    { \"CD\",       &set_default_cmd,   0 },\r\n    { \"DIR\",      &dir_cmd,           0 },\r\n    { \"LS\",       &dir_cmd,           0 },\r\n    { \"ECHO\",     &echo_cmd,          0 },\r\n    { \"ECHOF\",    &echof_cmd,         0 },\r\n    { \"SET\",      &set_cmd,           0 },\r\n    { \"SHOW\",     &show_cmd,          0 },\r\n    { \"HELP\",     &x_help_cmd,        0 },\r\n    { \"EXIT\",     &exit_cmd,          0 },\r\n    { \"QUIT\",     &exit_cmd,          0 },\r\n    { \"RUN\",      &x_run_cmd,    RU_RUN },\r\n    { \"GO\",       &x_run_cmd,     RU_GO },\r\n    { \"BOOT\",     &x_run_cmd,   RU_BOOT },\r\n    { \"BREAK\",    &brk_cmd,      SSH_ST },\r\n    { \"NOBREAK\",  &brk_cmd,      SSH_CL },\r\n    { \"EXPECT\",   &expect_cmd,        1 },\r\n    { \"NOEXPECT\", &expect_cmd,        0 },\r\n    { \"DEBUG\",    &debug_cmd,         1 },\r\n    { \"NODEBUG\",  &debug_cmd,         0 },\r\n    { \"SEND\",     &send_cmd,          0 },\r\n    { NULL,       NULL }\r\n    };\r\n\r\nstatic CTAB allowed_single_remote_cmds[] = {\r\n    { \"ATTACH\",   &attach_cmd,        0 },\r\n    { \"DETACH\",   &detach_cmd,        0 },\r\n    { \"EXAMINE\",  &exdep_cmd,      EX_E },\r\n    { \"EVALUATE\", &eval_cmd,          0 },\r\n    { \"REPEAT\",   &x_repeat_cmd,      0 },\r\n    { \"COLLECT\",  &x_collect_cmd,     0 },\r\n    { \"SAMPLEOUT\",&x_sampleout_cmd,   0 },\r\n    { \"EXECUTE\",  &x_execute_cmd,     0 },\r\n    { \"PWD\",      &pwd_cmd,           0 },\r\n    { \"DIR\",      &dir_cmd,           0 },\r\n    { \"LS\",       &dir_cmd,           0 },\r\n    { \"ECHO\",     &echo_cmd,          0 },\r\n    { \"ECHOF\",    &echof_cmd,         0 },\r\n    { \"SHOW\",     &show_cmd,          0 },\r\n    { \"DEBUG\",    &debug_cmd,         1 },\r\n    { \"NODEBUG\",  &debug_cmd,         0 },\r\n    { \"HELP\",     &x_help_cmd,        0 },\r\n    { NULL,       NULL }\r\n    };\r\n\r\nstatic CTAB remote_only_cmds[] = {\r\n    { \"REPEAT\",   &x_repeat_cmd,      0 },\r\n    { \"COLLECT\",  &x_collect_cmd,     0 },\r\n    { \"SAMPLEOUT\",&x_sampleout_cmd,   0 },\r\n    { \"EXECUTE\",  &x_execute_cmd,     0 },\r\n    { NULL,       NULL }\r\n    };\r\n\r\nstatic t_stat x_help_cmd (int32 flag, CONST char *cptr)\r\n{\r\nCTAB *cmdp, *cmdph;\r\n\r\nif (*cptr) {\r\n    int32 saved_switches = sim_switches;\r\n    t_stat r;\r\n\r\n    sim_switches |= SWMASK ('F');\r\n    r = help_cmd (flag, cptr);\r\n    sim_switches = saved_switches;\r\n    return r;\r\n    }\r\nsim_printf (\"Help is available for the following Remote Console commands:\\r\\n\");\r\nfor (cmdp=allowed_remote_cmds; cmdp->name != NULL; ++cmdp) {\r\n    cmdph = find_cmd (cmdp->name);\r\n    if (cmdph && cmdph->help)\r\n        sim_printf (\"    %s\\r\\n\", cmdp->name);\r\n    }\r\nsim_printf (\"Enter \\\"HELP cmd\\\" for detailed help on a command\\r\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat _sim_rem_message (const char *cmd, t_stat stat)\r\n{\r\nCTAB *cmdp = NULL;\r\nt_stat stat_nomessage = stat & SCPE_NOMESSAGE;  /* extract possible message suppression flag */\r\n\r\ncmdp = find_cmd (cmd);\r\nstat = SCPE_BARE_STATUS(stat);                  /* remove possible flag */\r\nif (!stat_nomessage) {\r\n    if (cmdp && (cmdp->message))                /* special message handler? */\r\n        cmdp->message (NULL, stat);             /* let it deal with display */\r\n    else {\r\n        if (stat >= SCPE_BASE)                  /* error? */\r\n            sim_printf (\"%s\\r\\n\", sim_error_text (stat));\r\n        }\r\n    }\r\nreturn stat;\r\n}\r\n\r\nstatic void _sim_rem_log_out (TMLN *lp)\r\n{\r\nchar cbuf[4*CBUFSIZE];\r\nREMOTE *rem = &sim_rem_consoles[(int)(lp - sim_rem_con_tmxr.ldsc)];\r\nsize_t out_count = 0;\r\n\r\nif ((!sim_oline) && (sim_log)) {\r\n    fflush (sim_log);\r\n    (void)sim_fseeko (sim_log, sim_rem_cmd_log_start, SEEK_SET);\r\n    cbuf[sizeof(cbuf)-1] = '\\0';\r\n    while (fgets (cbuf, sizeof(cbuf)-1, sim_log)) {\r\n        out_count += strlen (cbuf);\r\n        tmxr_linemsgf (lp, \"%s\", cbuf);\r\n        }\r\n    }\r\nsim_oline = NULL;\r\nif ((rem->act == NULL) && (out_count != 0)) {\r\n    int32 pending_input = tmxr_input_pending_ln (lp);\r\n    int32 unwritten;\r\n\r\n    if ((pending_input == 0) ||                                     /* No input pending OR */\r\n        ((pending_input == 1) && (lp->rxb[lp->rxbpr] == '\\n'))) {   /* Microsoft Telnet bug (extra \\n after \\r) */\r\n        /* Time to flush pending output */\r\n        do {\r\n            unwritten = tmxr_send_buffered_data (lp);\r\n            if (unwritten == lp->txbsz)\r\n                sim_os_ms_sleep (100);\r\n            } while (unwritten == lp->txbsz);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid sim_remote_process_command (void)\r\n{\r\nchar cbuf[4*CBUFSIZE], gbuf[CBUFSIZE], *argv[1] = {NULL};\r\nCONST char *cptr;\r\nint32 saved_switches = sim_switches;\r\nt_stat stat;\r\n\r\nstrlcpy (cbuf, sim_rem_command_buf, sizeof (cbuf));\r\nwhile (isspace(cbuf[0]))\r\n    memmove (cbuf, cbuf+1, strlen(cbuf+1)+1);   /* skip leading whitespace */\r\nsim_sub_args (cbuf, sizeof(cbuf), argv);\r\ncptr = cbuf;\r\nsim_debug (DBG_CMD, &sim_remote_console, \"Processing Command: %s\\n\", cptr);\r\ncptr = get_glyph (cptr, gbuf, 0);               /* get command glyph */\r\nsim_rem_active_command = find_cmd (gbuf);       /* find command */\r\n\r\nif (!sim_processing_event)\r\n    sim_ttcmd ();                               /* restore console */\r\nstat = sim_rem_active_command->action (sim_rem_active_command->arg, cptr);/* execute command */\r\nif (stat != SCPE_OK)\r\n    stat = _sim_rem_message (gbuf, stat);       /* display results */\r\nsim_last_cmd_stat = SCPE_BARE_STATUS(stat);\r\nif (sim_vm_post != NULL)                        /* optionally let the simulator know */\r\n    (*sim_vm_post) (TRUE);                      /* something might have changed */\r\nif (!sim_processing_event) {\r\n    sim_ttrun ();                               /* set console mode */\r\n    sim_cancel (rem_con_data_unit);             /* force immediate activation of sim_rem_con_data_svc with the */\r\n    sim_activate (rem_con_data_unit, -1);       /* special case delay (-1) which forces it to the head of the queue */\r\n    }\r\nsim_switches = saved_switches;                  /* restore original switches */\r\n}\r\n\r\n/* Clear pending actions */\r\n\r\nstatic char *sim_rem_clract (int32 line)\r\n{\r\nREMOTE *rem = &sim_rem_consoles[line];\r\n\r\ntmxr_send_buffered_data (rem->lp);              /* flush any buffered data */\r\nreturn rem->act = NULL;\r\n}\r\n\r\n/* Set up pending actions */\r\n\r\nstatic void sim_rem_setact (int32 line, const char *action)\r\n{\r\nif (action) {\r\n    size_t act_size = strlen (action) + 1;\r\n    REMOTE *rem = &sim_rem_consoles[line];\r\n\r\n    if (act_size > rem->act_buf_size) {         /* expand buffer if necessary */\r\n        rem->act_buf = (char *)realloc (rem->act_buf, act_size);\r\n        rem->act_buf_size = act_size;\r\n        }\r\n    strcpy (rem->act_buf, action);              /* populate buffer */\r\n    rem->act = rem->act_buf;                    /* start at beginning of buffer */\r\n    }\r\nelse\r\n    sim_rem_clract (line);\r\n}\r\n\r\n/* Get next pending action, if any */\r\n\r\nstatic char *sim_rem_getact (int32 line, char *buf, size_t size)\r\n{\r\nchar *ep;\r\nsize_t lnt;\r\nREMOTE *rem = &sim_rem_consoles[line];\r\n\r\nif (rem->act == NULL)                           /* any action? */\r\n    return NULL;\r\nwhile (sim_isspace (*rem->act))                 /* skip spaces */\r\n    rem->act++;\r\nif (*rem->act == 0)                             /* now empty? */\r\n    return sim_rem_clract (line);\r\nep = strpbrk (rem->act, \";\\\"'\");                /* search for a semicolon or single or double quote */\r\nif ((ep != NULL) && (*ep != ';')) {             /* if a quoted string is present */\r\n    char quote = *ep++;                         /*   then save the opening quotation mark */\r\n\r\n    while (ep [0] != '\\0' && ep [0] != quote)   /* while characters remain within the quotes */\r\n        if (ep [0] == '\\\\' && ep [1] == quote)  /*   if an escaped quote sequence follows */\r\n            ep = ep + 2;                        /*     then skip over the pair */\r\n        else                                    /*   otherwise */\r\n            ep = ep + 1;                        /*     skip the non-quote character */\r\n    ep = strchr (ep, ';');                      /* the next semicolon is outside the quotes if it exists */\r\n    }\r\n\r\nif (ep != NULL) {                               /* if a semicolon is present */\r\n    lnt = ep - rem->act;                        /* cmd length */\r\n    if (lnt >= size) {                          /* command longer than buffer size? */\r\n        memcpy (buf, rem->act, size);           /* copy some */\r\n        buf[size - 1] = 0;                      /* nul terminate cmd */\r\n        }\r\n    else {\r\n        memcpy (buf, rem->act, lnt + 1);        /* copy with ; */\r\n        buf[lnt] = 0;                           /* erase ; */\r\n        }\r\n    rem->act += lnt + 1;                        /* adv ptr */\r\n    }\r\nelse {\r\n    strlcpy (buf, rem->act, size);              /* copy action */\r\n    rem->act += strlen (rem->act);              /* adv ptr to end */\r\n    sim_rem_clract (line);\r\n    }\r\nreturn buf;\r\n}\r\n\r\n/*\r\n    Parse and setup Remote Console REPEAT command:\r\n       REPEAT EVERY nnn USECS Command {; command...}\r\n */\r\nstatic t_stat sim_rem_repeat_cmd_setup (int32 line, CONST char **iptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nint32 val;\r\nt_bool all_stop = FALSE;\r\nt_stat stat = SCPE_OK;\r\nCONST char *cptr = *iptr;\r\nREMOTE *rem = &sim_rem_consoles[line];\r\n\r\nsim_debug (DBG_REP, &sim_remote_console, \"Repeat Setup: %s\\n\", cptr);\r\nif (*cptr == 0)         /* required argument? */\r\n    stat = SCPE_2FARG;\r\nelse {\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    if (MATCH_CMD (gbuf, \"EVERY\") == 0) {\r\n        cptr = get_glyph (cptr, gbuf, 0);           /* get next glyph */\r\n        val = (int32) get_uint (gbuf, 10, INT_MAX, &stat);\r\n        if ((stat != SCPE_OK) || (val <= 0))        /* error? */\r\n            stat = SCPE_ARG;\r\n        else {\r\n            cptr = get_glyph (cptr, gbuf, 0);       /* get next glyph */\r\n            if ((MATCH_CMD (gbuf, \"USECS\") != 0) || (*cptr == 0))\r\n                stat = SCPE_ARG;\r\n            else\r\n                rem->repeat_interval = val;\r\n            }\r\n        }\r\n    else {\r\n        if (MATCH_CMD (gbuf, \"STOP\") == 0) {\r\n            if (*cptr) {                            /* more command arguments? */\r\n                cptr = get_glyph (cptr, gbuf, 0);   /* get next glyph */\r\n                if ((MATCH_CMD (gbuf, \"ALL\") != 0) ||   /*  */\r\n                    (*cptr != 0)                   ||   /*  */\r\n                    (line != 0))                        /* master line? */\r\n                    stat = SCPE_ARG;\r\n                else\r\n                    all_stop = TRUE;\r\n                }\r\n            else\r\n                rem->repeat_interval = 0;\r\n            }\r\n        else\r\n            stat = SCPE_ARG;\r\n        }\r\n    }\r\nif (stat == SCPE_OK) {\r\n    if (all_stop) {\r\n        for (line = 0; line < sim_rem_con_tmxr.lines; line++) {\r\n            rem = &sim_rem_consoles[line];\r\n            free (rem->repeat_action);\r\n            rem->repeat_action = NULL;\r\n            sim_cancel (rem->uptr);\r\n            rem->repeat_pending = FALSE;\r\n            sim_rem_clract (line);\r\n            }\r\n        }\r\n    else {\r\n        if (rem->repeat_interval != 0) {\r\n            rem->repeat_action = (char *)realloc (rem->repeat_action, 1 + strlen (cptr));\r\n            strcpy (rem->repeat_action, cptr);\r\n            cptr += strlen (cptr);\r\n            stat = sim_activate_after (rem->uptr, rem->repeat_interval);\r\n            }\r\n        else {\r\n            free (rem->repeat_action);\r\n            rem->repeat_action = NULL;\r\n            sim_cancel (rem->uptr);\r\n            }\r\n        rem->repeat_pending = FALSE;\r\n        sim_rem_clract (line);\r\n        }\r\n    }\r\n*iptr = cptr;\r\nreturn stat;\r\n}\r\n\r\n\r\n/*\r\n    Parse and setup Remote Console REPEAT command:\r\n       COLLECT nnn SAMPLES EVERY nnn CYCLES reg{,reg...}\r\n */\r\nstatic t_stat sim_rem_collect_cmd_setup (int32 line, CONST char **iptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nint32 samples, cycles, dither_pct;\r\nt_bool all_stop = FALSE;\r\nt_stat stat = SCPE_OK;\r\nCONST char *cptr = *iptr;\r\nREMOTE *rem = &sim_rem_consoles[line];\r\n\r\nsim_debug (DBG_SAM, &sim_remote_console, \"Collect Setup: %s\\n\", cptr);\r\nif (*cptr == 0)         /* required argument? */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\nsamples = (int32) get_uint (gbuf, 10, INT_MAX, &stat);\r\nif ((stat != SCPE_OK) || (samples <= 0)) {      /* error? */\r\n    if (MATCH_CMD (gbuf, \"STOP\") == 0) {\r\n        stat = SCPE_OK;\r\n        if (*cptr) {                            /* more command arguments? */\r\n            cptr = get_glyph (cptr, gbuf, 0);   /* get next glyph */\r\n            if ((MATCH_CMD (gbuf, \"ALL\") != 0) ||   /*  */\r\n                (*cptr != 0)                   ||   /*  */\r\n                (line != 0))                        /* master line? */\r\n                stat = SCPE_ARG;\r\n            else\r\n                all_stop = TRUE;\r\n            }\r\n        if (stat == SCPE_OK) {\r\n            for (line = all_stop ? 0 : rem->line; line < (all_stop ? sim_rem_con_tmxr.lines : (rem->line + 1)); line++) {\r\n                uint32 i, j;\r\n\r\n                rem = &sim_rem_consoles[line];\r\n                for (i = 0; i< rem->smp_reg_count; i++) {\r\n                    for (j = 0; j < rem->smp_regs[i].width; j++)\r\n                        free (rem->smp_regs[i].bits[j].vals);\r\n                    free (rem->smp_regs[i].bits);\r\n                    }\r\n                free (rem->smp_regs);\r\n                rem->smp_regs = NULL;\r\n                rem->smp_reg_count = 0;\r\n                sim_cancel (&rem_con_smp_smpl_units[rem->line]);\r\n                rem->smp_sample_interval = 0;\r\n                }\r\n            }\r\n        }\r\n    else\r\n        stat = sim_messagef (SCPE_ARG, \"Expected value or STOP found: %s\\n\", gbuf);\r\n    }\r\nelse {\r\n    const char *tptr;\r\n    int32 event_time = rem->smp_sample_interval;\r\n\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    if (MATCH_CMD (gbuf, \"SAMPLES\") != 0) {\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected SAMPLES found: %s\\n\", gbuf);\r\n        }\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    if (MATCH_CMD (gbuf, \"EVERY\") != 0) {\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected EVERY found: %s\\n\", gbuf);\r\n        }\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    cycles = (int32) get_uint (gbuf, 10, INT_MAX, &stat);\r\n    if ((stat != SCPE_OK) || (cycles <= 0)) {       /* error? */\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected value found: %s\\n\", gbuf);\r\n        }\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    if ((MATCH_CMD (gbuf, \"CYCLES\") != 0) || (*cptr == 0)) {\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected CYCLES found: %s\\n\", gbuf);\r\n        }\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    if ((MATCH_CMD (gbuf, \"DITHER\") != 0) || (*cptr == 0)) {\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected DITHER found: %s\\n\", gbuf);\r\n        }\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    dither_pct = (int32) get_uint (gbuf, 10, INT_MAX, &stat);\r\n    if ((stat != SCPE_OK) ||                        /* error? */\r\n        (dither_pct < 0) || (dither_pct > 25)) {\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected value found: %s\\n\", gbuf);\r\n        }\r\n    cptr = get_glyph (cptr, gbuf, 0);               /* get next glyph */\r\n    if ((MATCH_CMD (gbuf, \"PERCENT\") != 0) || (*cptr == 0)) {\r\n        *iptr = cptr;\r\n        return sim_messagef (SCPE_ARG, \"Expected PERCENT found: %s\\n\", gbuf);\r\n        }\r\n    tptr = strcpy (gbuf, \"STOP\");                   /* Start from a clean slate */\r\n    sim_rem_collect_cmd_setup (rem->line, &tptr);\r\n    rem->smp_sample_interval = cycles;\r\n    rem->smp_reg_count = 0;\r\n    while (cptr && *cptr) {\r\n        const char *comma = strchr (cptr, ',');\r\n        char tbuf[2*CBUFSIZE];\r\n        uint32 bit, width;\r\n        REG *reg;\r\n        uint32 idx;\r\n        int32 saved_switches = sim_switches;\r\n        t_bool indirect = FALSE;\r\n        BITSAMPLE_REG *smp_regs;\r\n\r\n        if (comma) {\r\n            strncpy (tbuf, cptr, comma - cptr);\r\n            tbuf[comma - cptr] = '\\0';\r\n            cptr = comma + 1;\r\n            }\r\n        else {\r\n            strcpy (tbuf, cptr);\r\n            cptr += strlen (cptr);\r\n            }\r\n        tptr = tbuf;\r\n        if (strchr (tbuf, ' ')) {\r\n            sim_switches = 0;\r\n            tptr = get_sim_opt (CMD_OPT_SW|CMD_OPT_DFT, tbuf, &stat); /* get switches and device */\r\n            indirect = ((sim_switches & SWMASK('I')) != 0);\r\n            sim_switches = saved_switches;\r\n            }\r\n        if (stat != SCPE_OK)\r\n            break;\r\n        tptr = get_glyph (tptr, gbuf, 0);     /* get next glyph */\r\n        reg = find_reg (gbuf, &tptr, sim_dfdev);\r\n        if (reg == NULL) {\r\n            stat = sim_messagef (SCPE_NXREG, \"Nonexistent Register: %s\\n\", gbuf);\r\n            break;\r\n            }\r\n        if (*tptr == '[') {                             /* subscript? */\r\n            const char *tgptr = ++tptr;\r\n\r\n            if (reg->depth <= 1) {                      /* array register? */\r\n                stat = sim_messagef (SCPE_SUB, \"Not Array Register: %s\\n\", reg->name);\r\n                break;\r\n                }\r\n            idx = (uint32) strtotv (tgptr, &tptr, 10);  /* convert index */\r\n            if ((tgptr == tptr) || (*tptr++ != ']')) {\r\n                stat = sim_messagef (SCPE_SUB, \"Missing or Invalid Register Subscript: %s[%s\\n\", reg->name, tgptr);\r\n                break;\r\n                }\r\n            if (idx >= reg->depth) {                    /* validate subscript */\r\n                stat = sim_messagef (SCPE_SUB, \"Invalid Register Subscript: %s[%d]\\n\", reg->name, idx);\r\n                break;\r\n                }\r\n            }\r\n        else\r\n            idx = 0;                                    /* not array */\r\n        smp_regs = (BITSAMPLE_REG *)realloc (rem->smp_regs, (rem->smp_reg_count + 1) * sizeof(*smp_regs));\r\n        if (smp_regs == NULL) {\r\n            stat = SCPE_MEM;\r\n            break;\r\n            }\r\n        rem->smp_regs = smp_regs;\r\n        smp_regs[rem->smp_reg_count].reg = reg;\r\n        smp_regs[rem->smp_reg_count].idx = idx;\r\n        smp_regs[rem->smp_reg_count].dptr = sim_dfdev;\r\n        smp_regs[rem->smp_reg_count].uptr = sim_dfunit;\r\n        smp_regs[rem->smp_reg_count].indirect = indirect;\r\n        width = indirect ? sim_dfdev->dwidth : reg->width;\r\n        smp_regs[rem->smp_reg_count].width = width;\r\n        smp_regs[rem->smp_reg_count].bits = (BITSAMPLE *)calloc (width, sizeof (*smp_regs[rem->smp_reg_count - 1].bits));\r\n        if (smp_regs[rem->smp_reg_count].bits == NULL) {\r\n            stat = SCPE_MEM;\r\n            break;\r\n            }\r\n        rem->smp_reg_count += 1;\r\n        for (bit = 0; bit < width; bit++) {\r\n            smp_regs[rem->smp_reg_count - 1].bits[bit].depth = samples;\r\n            smp_regs[rem->smp_reg_count - 1].bits[bit].vals = (int *)calloc (samples, sizeof (int));\r\n            if (smp_regs[rem->smp_reg_count - 1].bits[bit].vals == NULL) {\r\n                stat = SCPE_MEM;\r\n                break;\r\n                }\r\n            }\r\n        if (stat != SCPE_OK)\r\n            break;\r\n        }\r\n    if (stat != SCPE_OK) {                      /* Error? */\r\n        *iptr = cptr;\r\n        cptr = strcpy (gbuf, \"STOP\");\r\n        sim_rem_collect_cmd_setup (line, &cptr);/* Cleanup mess */\r\n        return stat;\r\n        }\r\n    if (rem->smp_sample_dither_pct)\r\n        event_time = (((rand() % (2 * rem->smp_sample_dither_pct)) - rem->smp_sample_dither_pct) * event_time) / 100;\r\n    sim_activate (&rem_con_smp_smpl_units[rem->line], event_time);\r\n    }\r\n*iptr = cptr;\r\nreturn stat;\r\n}\r\n\r\nt_stat sim_rem_con_repeat_svc (UNIT *uptr)\r\n{\r\nint line = uptr - rem_con_repeat_units;\r\nREMOTE *rem = &sim_rem_consoles[line];\r\n\r\nsim_debug (DBG_REP, &sim_remote_console, \"sim_rem_con_repeat_svc(line=%d) - interval=%d usecs\\n\", line, rem->repeat_interval);\r\nif (rem->repeat_interval) {\r\n    rem->repeat_pending = TRUE;\r\n    sim_activate_after (uptr, rem->repeat_interval);        /* reschedule */\r\n    sim_activate_abs (rem_con_data_unit, -1);               /* wake up to process */\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic void sim_rem_record_reg_bit (BITSAMPLE *bit, int val)\r\n{\r\nbit->tot -= bit->vals[bit->ptr];    /* remove retired value */\r\nbit->tot += val;                    /* accumulate new value */\r\nbit->vals[bit->ptr] = val;          /* save new value */\r\n++bit->ptr;                         /* increment next pointer */\r\nif (bit->ptr >= bit->depth)         /* if too big */\r\n    bit->ptr = 0;                   /* wrap around */\r\n}\r\n\r\nstatic void sim_rem_set_reg_bit (BITSAMPLE *bit, int val)\r\n{\r\nint i;\r\n\r\nbit->tot = bit->depth * val;        /* compute total */\r\nfor (i = 0; i < bit->depth; i++)    /* set all value bits */\r\n    bit->vals[i] = val;\r\n}\r\n\r\nstatic void sim_rem_collect_reg_bits (BITSAMPLE_REG *reg)\r\n{\r\nuint32 i;\r\nt_value val = get_rval (reg->reg, reg->idx);\r\n\r\nif (reg->indirect)\r\n    val = get_aval ((t_addr)val, reg->dptr, reg->uptr);\r\nval = val >> reg->reg->offset;\r\nfor (i = 0; i < reg->width; i++) {\r\n    if (sim_is_running)\r\n        sim_rem_record_reg_bit (&reg->bits[i], val&1);\r\n    else\r\n        sim_rem_set_reg_bit (&reg->bits[i], val&1);\r\n    val = val >> 1;\r\n    }\r\n}\r\n\r\nstatic void sim_rem_collect_registers (REMOTE *rem)\r\n{\r\nuint32 i;\r\n\r\nfor (i = 0; i < rem->smp_reg_count; i++)\r\n    sim_rem_collect_reg_bits (&rem->smp_regs[i]);\r\n}\r\n\r\nstatic void sim_rem_collect_all_registers (void)\r\n{\r\nint32 line;\r\n\r\nfor (line = 0; line < sim_rem_con_tmxr.lines; line++)\r\n    sim_rem_collect_registers (&sim_rem_consoles[line]);\r\n}\r\n\r\nt_stat sim_rem_con_smp_collect_svc (UNIT *uptr)\r\n{\r\nint line = uptr - rem_con_smp_smpl_units;\r\nREMOTE *rem = &sim_rem_consoles[line];\r\n\r\nsim_debug (DBG_SAM, &sim_remote_console, \"sim_rem_con_smp_collect_svc(line=%d) - interval=%d, dither=%d%%\\n\", line, rem->smp_sample_interval, rem->smp_sample_dither_pct);\r\nif (rem->smp_sample_interval && (rem->smp_reg_count != 0)) {\r\n    int32 event_time = rem->smp_sample_interval;\r\n\r\n    if (rem->smp_sample_dither_pct)\r\n        event_time = (((rand() % (2 * rem->smp_sample_dither_pct)) - rem->smp_sample_dither_pct) * event_time) / 100;\r\n    sim_rem_collect_registers (rem);\r\n    sim_activate (uptr, event_time);                    /* reschedule */\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Unit service for remote console data polling and managing of command execution/dispatch */\r\n\r\nt_stat sim_rem_con_data_svc (UNIT *uptr)\r\n{\r\nint32 i, j, c = 0;\r\nt_stat stat = SCPE_OK;\r\nt_bool active_command = FALSE;\r\nint32 steps = 0;\r\nt_bool was_active_command = (sim_rem_cmd_active_line != -1);\r\nt_bool got_command = FALSE;\r\nt_bool close_session = FALSE;\r\nTMLN *lp;\r\nchar cbuf[4*CBUFSIZE], gbuf[CBUFSIZE], *argv[1] = {NULL};\r\nCONST char *cptr;\r\nCTAB *cmdp = NULL;\r\nCTAB *basecmdp = NULL;\r\nuint32 read_start_time = 0;\r\nt_bool abort_for_debug = FALSE;\r\n\r\nif (abort_for_debug)                                /* Set this in the debugger to abort simulation and cleanly close debug output */\r\n    SIM_SCP_ABORT (\"Remote-Console-Data\");\r\ntmxr_poll_rx (&sim_rem_con_tmxr);                   /* pickup any new input */\r\nfor (i=(was_active_command ? sim_rem_cmd_active_line : 0);\r\n     (i < sim_rem_con_tmxr.lines) && (!active_command) && (stat != SCPE_REMOTE);\r\n     i++) {\r\n    REMOTE *rem = &sim_rem_consoles[i];\r\n    t_bool master_session = (sim_rem_master_mode && (i == 0));\r\n\r\n    lp = rem->lp;\r\n    if (!lp->conn) {                                /* this line connection never connected or just dropped? */\r\n        if (rem->repeat_interval) {                 /* was repeated enabled? */\r\n            cptr = strcpy (gbuf, \"STOP\");\r\n            sim_rem_repeat_cmd_setup (i, &cptr);    /* make sure it is now disabled */\r\n            }\r\n        if (rem->smp_reg_count) {                   /* were bit samples being collected? */\r\n            cptr = strcpy (gbuf, \"STOP\");\r\n            sim_rem_collect_cmd_setup (i, &cptr);   /* make sure it is now disabled */\r\n            }\r\n        continue;                                   /* process next line */\r\n        }\r\n    if (master_session && !sim_rem_master_was_connected) { /* new/first master mode session */\r\n        tmxr_linemsgf (lp, \"\\nMaster Mode Session\\r\\n\");\r\n        tmxr_send_buffered_data (lp);               /* flush just issued message from buffered data */\r\n        sim_rem_master_was_connected = TRUE;        /* Remember master actually connected */\r\n        }\r\n    stat = SCPE_OK;\r\n    if ((was_active_command) ||\r\n        (master_session && !rem->single_mode)) {\r\n        sim_debug (DBG_MOD, &sim_remote_console, \"Session: %d %s %s\\n\", i, was_active_command ? \"Was Active\" : \"\", (master_session && !rem->single_mode) ? \"master_session && !single_mode\" : \"\");\r\n        if (was_active_command) {\r\n            sim_rem_cmd_active_line = -1;           /* Done with active command */\r\n            if (!sim_rem_active_command) {          /* STEP command? */\r\n                stat = SCPE_STEP;\r\n                if (sim_con_stable_registers || !sim_rem_master_mode)\r\n                    _sim_rem_message (\"STEP\", stat);/* produce a STEP complete message */\r\n                }\r\n            _sim_rem_log_out (lp);\r\n            sim_rem_active_command = NULL;          /* Restart loop to process any available input */\r\n            was_active_command = FALSE;\r\n            i = -1;\r\n            continue;                               /* process all lines */\r\n            }\r\n        else {\r\n            sim_is_running = FALSE;\r\n            sim_rem_collect_all_registers ();\r\n            sim_stop_timer_services ();\r\n            sim_flush_buffered_files (TRUE);\r\n            if (rem->act == NULL) {\r\n                for (j=0; j < sim_rem_con_tmxr.lines; j++) {\r\n                    TMLN *lpj = &sim_rem_con_tmxr.ldsc[j];\r\n                    if ((i == j) || (!lpj->conn))\r\n                        continue;\r\n                    tmxr_linemsgf (lpj, \"\\nRemote Master Console(%s) Entering Commands\\n\", lp->ipad);\r\n                    tmxr_send_buffered_data (lpj);     /* flush any buffered data */\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    else {  /* (!was_active_command && (!master_session || rem->single_mode)) */\r\n        if (((!rem->repeat_pending) && (rem->act == NULL)) ||   /* Repeat isn't pending AND no prior commands still active */\r\n            (rem->buf_ptr != 0) ||                              /* OR Not at beginning of line */\r\n            (tmxr_input_pending_ln (lp))) {                     /* OR input available to read */\r\n            c = tmxr_getc_ln (lp);\r\n            if (!(TMXR_VALID & c))\r\n                continue;\r\n            c = c & ~TMXR_VALID;\r\n            if (rem->single_mode) {\r\n                if (c == sim_int_char) {                /* ^E (the interrupt character) must start continue mode console interaction */\r\n                    while (rem->buf_ptr > 0) {          /* Erase current input line */\r\n                        tmxr_linemsg (lp, \"\\b \\b\");\r\n                        --rem->buf_ptr;\r\n                        }\r\n                    rem->single_mode = FALSE;           /* enter multi command mode */\r\n                    rem->repeat_pending = FALSE;\r\n                    sim_is_running = FALSE;\r\n                    sim_rem_collect_all_registers ();\r\n                    sim_stop_timer_services ();\r\n                    sim_flush_buffered_files (TRUE);\r\n                    stat = SCPE_STOP;\r\n                    _sim_rem_message (\"RUN\", stat);\r\n                    _sim_rem_log_out (lp);\r\n                    for (j=0; j < sim_rem_con_tmxr.lines; j++) {\r\n                        TMLN *lpj = &sim_rem_con_tmxr.ldsc[j];\r\n                        if ((i == j) || (!lpj->conn))\r\n                            continue;\r\n                        tmxr_linemsgf (lpj, \"\\nRemote Console %d(%s) Entering Commands\\n\", i, lp->ipad);\r\n                        tmxr_send_buffered_data (lpj);  /* flush the output message just buffered */\r\n                        }\r\n                    lp = &sim_rem_con_tmxr.ldsc[i];\r\n                    if (!master_session)\r\n                        tmxr_linemsg (lp, \"\\r\\nSimulator paused.\\r\\n\");\r\n                    if (!master_session && rem->read_timeout) {\r\n                        tmxr_linemsgf (lp, \"Simulation will resume automatically if input is not received in %d seconds\\n\", rem->read_timeout);\r\n                        tmxr_linemsgf (lp, \"\\r\\n\");\r\n                        tmxr_send_buffered_data (lp);   /* flush the output message just buffered */\r\n                        }\r\n                    }\r\n                else { /* c != sim_int_char */\r\n                    if ((rem->buf_ptr == 0) &&          /* At beginning of input line */\r\n                        ((c == '\\n') ||                 /* Ignore bare LF between commands (Microsoft Telnet bug) */\r\n                         (c == '\\r')))                  /* Ignore empty commands */\r\n                        continue;\r\n                    if ((c == '\\004') || (c == '\\032')) {/* EOF character (^D or ^Z) ? */\r\n                        while (rem->buf_ptr > 0) {      /* Erase current input line */\r\n                            tmxr_linemsg (lp, \"\\b \\b\");\r\n                            --rem->buf_ptr;\r\n                            }\r\n                        tmxr_linemsgf (lp, \"\\r\\nGoodbye\\r\\n\");\r\n                        tmxr_send_buffered_data (lp);   /* flush the output message just buffered */\r\n                        tmxr_reset_ln (lp);\r\n                        continue;\r\n                        }\r\n                    if (rem->buf_ptr == 0) {\r\n                        /* we just picked up the first character on a command line */\r\n                        if (!master_session)\r\n                            tmxr_linemsgf (lp, \"\\r\\n%s\", sim_prompt);\r\n                        else\r\n                            tmxr_linemsgf (lp, \"\\r\\n%s\", sim_is_running ? \"SIM> \" : \"sim> \");\r\n                        sim_debug (DBG_XMT, &sim_remote_console, \"Prompt Written: %s\\n\", sim_is_running ? \"SIM> \" : \"sim> \");\r\n                        if ((rem->act == NULL) && (!tmxr_input_pending_ln (lp)))\r\n                            tmxr_send_buffered_data (lp);/* flush the output message just buffered  */\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    got_command = FALSE;\r\n    while (1) {\r\n        if (stat == SCPE_EXIT)\r\n            return stat|SCPE_NOMESSAGE;\r\n        if ((!rem->single_mode) && (rem->act == NULL)) {\r\n            read_start_time = sim_os_msec();\r\n            if (master_session)\r\n                tmxr_linemsg (lp, \"sim> \");\r\n            else\r\n                tmxr_linemsg (lp, sim_prompt);\r\n            tmxr_send_buffered_data (lp);               /* flush the output message just buffered  */\r\n            }\r\n        do {\r\n            if (rem->buf_ptr == 0) {\r\n                if (sim_rem_getact (i, rem->buf, rem->buf_size)) {\r\n                    if (!master_session)\r\n                        tmxr_linemsgf (lp, \"%s%s\\n\", sim_prompt, rem->buf);\r\n                    else\r\n                        tmxr_linemsgf (lp, \"%s%s\\n\", \"SIM> \", rem->buf);\r\n                    rem->buf_ptr = strlen (rem->buf);\r\n                    got_command = TRUE;\r\n                    break;\r\n                    }\r\n                if ((rem->repeat_pending) &&            /* New repeat pending */\r\n                    (rem->act == NULL) &&               /* AND no prior still active */\r\n                    (!tmxr_input_pending_ln (lp))) {    /* AND no session input pending on this line */\r\n                    rem->repeat_pending = FALSE;\r\n                    sim_rem_setact (rem-sim_rem_consoles, rem->repeat_action);\r\n                    sim_rem_getact (rem-sim_rem_consoles, rem->buf, rem->buf_size);\r\n                    if (!master_session)\r\n                        tmxr_linemsgf (lp, \"%s%s\\n\", sim_prompt, rem->buf);\r\n                    else\r\n                        tmxr_linemsgf (lp, \"%s%s\\n\", \"SIM> \", rem->buf);\r\n                    rem->buf_ptr = strlen (rem->buf);\r\n                    got_command = TRUE;\r\n                    break;\r\n                    }\r\n                }\r\n            if (!rem->single_mode) {\r\n                c = tmxr_getc_ln (lp);\r\n                if (!(TMXR_VALID & c)) {\r\n                    tmxr_send_buffered_data (lp);       /* flush any buffered data */\r\n                    if (!master_session &&\r\n                        rem->read_timeout &&\r\n                        ((sim_os_msec() - read_start_time)/1000 >= rem->read_timeout)) {\r\n                        while (rem->buf_ptr > 0) {      /* Erase current input line */\r\n                            tmxr_linemsg (lp, \"\\b \\b\");\r\n                            --rem->buf_ptr;\r\n                            }\r\n                        if (rem->buf_ptr+80 >= rem->buf_size) {\r\n                            rem->buf_size += 1024;\r\n                            rem->buf = (char *)realloc (rem->buf, rem->buf_size);\r\n                            }\r\n                        strcpy (rem->buf, \"CONTINUE         ! Automatic continue due to timeout\");\r\n                        tmxr_linemsgf (lp, \"%s\\n\", rem->buf);\r\n                        got_command = TRUE;\r\n                        break;\r\n                        }\r\n                    sim_os_ms_sleep (50);\r\n                    tmxr_poll_rx (&sim_rem_con_tmxr);   /* poll input */\r\n                    if (!lp->conn) {                    /* if connection lost? */\r\n                        rem->single_mode = TRUE;        /* No longer multi-command more */\r\n                        break;                          /* done waiting */\r\n                        }\r\n                    continue;\r\n                    }\r\n                read_start_time = sim_os_msec();\r\n                c = c & ~TMXR_VALID;\r\n                }\r\n            switch (c) {\r\n                case 0:     /* no data */\r\n                    break;\r\n                case '\\b':  /* Backspace */\r\n                case 127:   /* Rubout */\r\n                    if (rem->buf_ptr > 0) {\r\n                        tmxr_linemsg (lp, \"\\b \\b\");\r\n                        --rem->buf_ptr;\r\n                        }\r\n                    break;\r\n                case 27:   /* escape */\r\n                case 21:   /* ^U */\r\n                    while (rem->buf_ptr > 0) {\r\n                        tmxr_linemsg (lp, \"\\b \\b\");\r\n                        --rem->buf_ptr;\r\n                        }\r\n                    break;\r\n                case '\\n':\r\n                    if (rem->buf_ptr == 0)\r\n                        break;\r\n                    /* fall through */\r\n                case '\\r':\r\n                    tmxr_linemsg (lp, \"\\r\\n\");\r\n                    if (rem->buf_ptr+1 >= rem->buf_size) {\r\n                        rem->buf_size += 1024;\r\n                        rem->buf = (char *)realloc (rem->buf, rem->buf_size);\r\n                        }\r\n                    rem->buf[rem->buf_ptr++] = '\\0';\r\n                    sim_debug (DBG_RCV, &sim_remote_console, \"Got Command (%d bytes still in buffer): %s\\n\", tmxr_input_pending_ln (lp), rem->buf);\r\n                    got_command = TRUE;\r\n                    break;\r\n                case '\\004': /* EOF (^D) */\r\n                case '\\032': /* EOF (^Z) */\r\n                    while (rem->buf_ptr > 0) {          /* Erase current input line */\r\n                        tmxr_linemsg (lp, \"\\b \\b\");\r\n                        --rem->buf_ptr;\r\n                        }\r\n                    if (!rem->single_mode) {\r\n                        if (rem->buf_ptr+80 >= rem->buf_size) {\r\n                            rem->buf_size += 1024;\r\n                            rem->buf = (char *)realloc (rem->buf, rem->buf_size);\r\n                            }\r\n                        strcpy (rem->buf, \"CONTINUE         ! Automatic continue before close\");\r\n                        tmxr_linemsgf (lp, \"%s\\n\", rem->buf);\r\n                        got_command = TRUE;\r\n                        }\r\n                    close_session = TRUE;\r\n                    break;\r\n                default:\r\n                    tmxr_putc_ln (lp, c);               /* echo input character */\r\n                    if (rem->buf_ptr+2 >= rem->buf_size) {\r\n                        rem->buf_size += 1024;\r\n                        rem->buf = (char *)realloc (rem->buf, rem->buf_size);\r\n                        }\r\n                    rem->buf[rem->buf_ptr++] = (char)c;\r\n                    rem->buf[rem->buf_ptr] = '\\0';\r\n                    if (rem->buf_ptr >= sizeof(cbuf))\r\n                        got_command = TRUE;             /* command too long */\r\n                    break;\r\n                }\r\n            c = 0;\r\n            if ((!got_command) &&                   /* No Command yet */\r\n                (rem->single_mode) &&               /* AND single command mode */\r\n                (tmxr_input_pending_ln (lp)) &&     /* AND something ready to read */\r\n                (rem->act == NULL)) {               /* AND no prior still active */\r\n                c = tmxr_getc_ln (lp);\r\n                c = c & ~TMXR_VALID;\r\n                }\r\n            } while ((!got_command) && ((!rem->single_mode) || c));\r\n        if ((rem->act == NULL) && (!tmxr_input_pending_ln (lp)))\r\n            tmxr_send_buffered_data (lp);               /* flush any buffered data */\r\n        if ((rem->single_mode) && !got_command) {\r\n            break;\r\n            }\r\n        if (!sim_rem_master_mode)\r\n            sim_printf (\"Remote Console Command from %s> %s\\r\\n\", lp->ipad, rem->buf);\r\n        got_command = FALSE;\r\n        if (strlen(rem->buf) >= sizeof(cbuf)) {\r\n            sim_printf (\"\\r\\nLine too long. Ignored.  Continuing Simulator execution\\r\\n\");\r\n            tmxr_linemsgf (lp, \"\\nLine too long. Ignored.  Continuing Simulator execution\\n\");\r\n            tmxr_send_buffered_data (lp);               /* try to flush any buffered data */\r\n            break;\r\n            }\r\n        strcpy (cbuf, rem->buf);\r\n        rem->buf_ptr = 0;\r\n        rem->buf[rem->buf_ptr] = '\\0';\r\n        while (isspace(cbuf[0]))\r\n            memmove (cbuf, cbuf+1, strlen(cbuf+1)+1);   /* skip leading whitespace */\r\n        if (cbuf[0] == '\\0') {\r\n            if (rem->single_mode) {\r\n                rem->single_mode = FALSE;\r\n                break;\r\n                }\r\n            else\r\n                continue;\r\n            }\r\n        strcpy (sim_rem_command_buf, cbuf);\r\n        sim_sub_args (cbuf, sizeof(cbuf), argv);\r\n        cptr = cbuf;\r\n        cptr = get_glyph (cptr, gbuf, 0);               /* get command glyph */\r\n        sim_switches = 0;                               /* init switches */\r\n        sim_rem_active_number = i;\r\n        if (!sim_log) {                                 /* Not currently logging? */\r\n            int32 save_quiet = sim_quiet;\r\n\r\n            sim_quiet = 1;\r\n            sprintf (sim_rem_con_temp_name, \"sim_remote_console_%d.temporary_log\", (int)getpid());\r\n            sim_set_logon (0, sim_rem_con_temp_name);\r\n            sim_quiet = save_quiet;\r\n            sim_log_temp = TRUE;\r\n            }\r\n        sim_rem_cmd_log_start = sim_ftell (sim_log);\r\n        basecmdp = find_cmd (gbuf);                     /* validate basic command */\r\n        if (basecmdp == NULL)\r\n            basecmdp = find_ctab (remote_only_cmds, gbuf);/* validate basic command */\r\n        if (basecmdp == NULL) {\r\n            if ((gbuf[0] == ';') || (gbuf[0] == '#')) { /* ignore comment */\r\n                sim_rem_cmd_active_line = i;\r\n                was_active_command = TRUE;\r\n                sim_rem_active_command = &allowed_single_remote_cmds[0];/* Dummy */\r\n                i = i - 1;\r\n                break;\r\n                }\r\n            else\r\n                stat = SCPE_UNK;\r\n            }\r\n        else {\r\n            if ((cmdp = find_ctab (rem->single_mode ? allowed_single_remote_cmds : (master_session ? allowed_master_remote_cmds : allowed_remote_cmds), gbuf))) {/* lookup command */\r\n                sim_debug (DBG_CMD, &sim_remote_console, \"gbuf='%s', basecmd='%s', cmd='%s'\\n\", gbuf, basecmdp->name, cmdp->name);\r\n                if (cmdp->action == &x_continue_cmd) {\r\n                    sim_debug (DBG_CMD, &sim_remote_console, \"continue_cmd executing\\n\");\r\n                    stat = SCPE_OK;\r\n                    }\r\n                else {\r\n                    if (cmdp->action == &exit_cmd)\r\n                        return SCPE_EXIT;\r\n                    if (cmdp->action == &x_step_cmd) {\r\n                        sim_debug (DBG_CMD, &sim_remote_console, \"step_cmd executing\\n\");\r\n                        steps = 1;                      /* default of 1 instruction */\r\n                        stat = SCPE_OK;\r\n                        if (*cptr != 0) {               /* argument? */\r\n                            cptr = get_glyph (cptr, gbuf, 0);/* get next glyph */\r\n                            if (*cptr != 0)            /* should be end */\r\n                                stat = SCPE_2MARG;\r\n                            else {\r\n                                steps = (int32) get_uint (gbuf, 10, INT_MAX, &stat);\r\n                                if ((stat != SCPE_OK) || (steps <= 0)) /* error? */\r\n                                    stat = SCPE_ARG;\r\n                                }\r\n                            }\r\n                        if (stat != SCPE_OK)\r\n                            cmdp = NULL;\r\n                        }\r\n                    else {\r\n                        if (cmdp->action == &x_run_cmd) {\r\n                            sim_debug (DBG_CMD, &sim_remote_console, \"run_cmd executing\\n\");\r\n                            if (sim_con_stable_registers && /* can we process command now? */\r\n                                sim_rem_master_mode)\r\n                                sim_oline = lp;             /* specify output socket */\r\n                            sim_switches |= SIM_SW_HIDE;    /* Request Setup only */\r\n                            stat = basecmdp->action (cmdp->arg, cptr);\r\n                            sim_switches &= ~SIM_SW_HIDE;   /* Done with Setup only mode */\r\n                            if (stat == SCPE_OK) {\r\n                                /* switch to CONTINUE after x_run_cmd() did RUN setup */\r\n                                cmdp = find_ctab (allowed_master_remote_cmds, \"CONTINUE\");\r\n                                }\r\n                            }\r\n                        else {\r\n                            if (cmdp->action == &x_sampleout_cmd) {\r\n                                sim_debug (DBG_CMD, &sim_remote_console, \"sampleout_cmd executing\\n\");\r\n                                sim_oline = lp;                     /* specify output socket */\r\n                                stat = sim_rem_sample_output (NULL, i);\r\n                                }\r\n                            else {\r\n                                if (cmdp->action == &x_repeat_cmd) {\r\n                                    sim_debug (DBG_CMD, &sim_remote_console, \"repeat_cmd executing\\n\");\r\n                                    stat = sim_rem_repeat_cmd_setup (i, &cptr);\r\n                                    }\r\n                                else {\r\n                                    if (cmdp->action == &x_execute_cmd) {\r\n                                        sim_debug (DBG_CMD, &sim_remote_console, \"execute_cmd executing\\n\");\r\n                                        if (rem->act)\r\n                                            stat = SCPE_IERR;\r\n                                        else {\r\n                                            sim_rem_setact (rem-sim_rem_consoles, cptr);\r\n                                            stat = SCPE_OK;\r\n                                            }\r\n                                        }\r\n                                    else {\r\n                                        if (cmdp->action == &x_collect_cmd) {\r\n                                            sim_debug (DBG_CMD, &sim_remote_console, \"collect_cmd executing\\n\");\r\n                                            stat = sim_rem_collect_cmd_setup (i, &cptr);\r\n                                            }\r\n                                        else {\r\n                                            if ((sim_con_stable_registers &&    /* can we process command now? */\r\n                                                 sim_rem_master_mode) ||\r\n                                                (cmdp->action == &x_help_cmd)) {\r\n                                                sim_debug (DBG_CMD, &sim_remote_console, \"Processing Command directly\\n\");\r\n                                                sim_oline = lp;         /* specify output socket */\r\n                                                if (cmdp->action == &x_help_cmd)\r\n                                                    x_help_cmd (0, cptr);\r\n                                                else\r\n                                                    sim_remote_process_command ();\r\n                                                stat = SCPE_OK;         /* any message has already been emitted */\r\n                                                }\r\n                                            else {\r\n                                                sim_debug (DBG_CMD, &sim_remote_console, \"Processing Command via SCPE_REMOTE\\n\");\r\n                                                stat = SCPE_REMOTE;     /* force processing outside of sim_instr() */\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            else\r\n                stat = SCPE_INVREM;\r\n            }\r\n        sim_rem_active_number = -1;\r\n        if ((stat != SCPE_OK) && (stat != SCPE_REMOTE))\r\n            stat = _sim_rem_message (gbuf, stat);\r\n        _sim_rem_log_out (lp);\r\n        if (master_session && !sim_rem_master_mode) {\r\n            rem->single_mode = TRUE;\r\n            return SCPE_STOP;\r\n            }\r\n        if (cmdp && (cmdp->action == &x_continue_cmd)) {\r\n            sim_rem_cmd_active_line = -1;                   /* Not active_command */\r\n            if (sim_log_temp &&                             /* If we setup a temporary log, clean it now  */\r\n                (!sim_rem_master_mode)) {\r\n                int32 save_quiet = sim_quiet;\r\n\r\n                sim_quiet = 1;\r\n                sim_set_logoff (0, NULL);\r\n                sim_quiet = save_quiet;\r\n                (void)remove (sim_rem_con_temp_name);\r\n                sim_log_temp = FALSE;\r\n                }\r\n            else {\r\n                fflush (sim_log);\r\n                sim_rem_cmd_log_start = sim_ftell (sim_log);\r\n                }\r\n            if (!rem->single_mode) {\r\n                tmxr_linemsg (lp, \"Simulator Running...\");\r\n                tmxr_send_buffered_data (lp);\r\n                for (j=0; j < sim_rem_con_tmxr.lines; j++) {\r\n                    TMLN *lpj = &sim_rem_con_tmxr.ldsc[j];\r\n                    if ((i == j) || (!lpj->conn))\r\n                        continue;\r\n                    tmxr_linemsg (lpj, \"Simulator Running...\");\r\n                    tmxr_send_buffered_data (lpj);\r\n                    }\r\n                sim_is_running = TRUE;\r\n                sim_start_timer_services ();\r\n                }\r\n            if (cmdp && (cmdp->action == &x_continue_cmd))\r\n                rem->single_mode = TRUE;\r\n            else {\r\n                if (!rem->single_mode) {\r\n                    if (master_session)\r\n                        tmxr_linemsgf (lp, \"%s\", \"sim> \");\r\n                    else\r\n                        tmxr_linemsgf (lp, \"%s\", sim_prompt);\r\n                    tmxr_send_buffered_data (lp);\r\n                    }\r\n                }\r\n            break;\r\n            }\r\n        if ((cmdp && (cmdp->action == &x_step_cmd)) ||\r\n            (stat == SCPE_REMOTE)) {\r\n            sim_rem_cmd_active_line = i;\r\n            break;\r\n            }\r\n        }\r\n    if (close_session) {\r\n        tmxr_linemsgf (lp, \"\\r\\nGoodbye\\r\\n\");\r\n        tmxr_send_buffered_data (lp);                       /* flush any buffered data */\r\n        tmxr_reset_ln (lp);\r\n        rem->single_mode = FALSE;\r\n        close_session = FALSE;\r\n        }\r\n    }\r\nif (sim_rem_master_was_connected &&                         /* Master mode ever connected? */\r\n    !sim_rem_con_tmxr.ldsc[0].sock)                         /* Master Connection lost? */\r\n    return sim_messagef (SCPE_EXIT, \"Master Session Disconnect\");/* simulator has been 'unplugged' */\r\nif (sim_rem_cmd_active_line != -1) {\r\n    if (steps) {\r\n        if (!sim_con_stable_registers && sim_rem_master_mode) {\r\n            sim_step = steps;\r\n            sim_sched_step ();\r\n            }\r\n        else\r\n            sim_activate(uptr, steps);                      /* check again after 'steps' instructions */\r\n        }\r\n    else {\r\n        return SCPE_REMOTE;                                 /* force sim_instr() to exit to process command */\r\n        }\r\n    }\r\nelse\r\n    sim_activate_after(uptr, 100000);                       /* check again in 100 milliseconds */\r\nif (sim_rem_master_was_enabled && !sim_rem_master_mode) {   /* Transitioning out of master mode? */\r\n    lp = &sim_rem_con_tmxr.ldsc[0];\r\n    tmxr_linemsgf (lp, \"Non Master Mode Session...\");       /* report transition */\r\n    tmxr_send_buffered_data (lp);                           /* flush any buffered data */\r\n    return SCPE_STOP|SCPE_NOMESSAGE;                        /* Unwind to the normal input path */\r\n    }\r\nelse\r\n    return SCPE_OK;                                         /* keep going */\r\n}\r\n\r\nt_stat sim_rem_con_reset (DEVICE *dptr)\r\n{\r\nif (sim_rem_con_tmxr.lines) {\r\n    int32 i;\r\n\r\n    sim_debug (DBG_REP, &sim_remote_console, \"sim_rem_con_reset(lines=%d)\\n\", sim_rem_con_tmxr.lines);\r\n    for (i=0; i<sim_rem_con_tmxr.lines; i++) {\r\n        REMOTE *rem = &sim_rem_consoles[i];\r\n\r\n        if (!sim_rem_con_tmxr.ldsc[i].conn)\r\n            continue;\r\n        sim_debug (DBG_REP, &sim_remote_console, \"sim_rem_con_reset(line=%d, usecs=%d)\\n\", i, rem->repeat_interval);\r\n        if (rem->repeat_interval)\r\n            sim_activate_after (&rem_con_repeat_units[rem->line], rem->repeat_interval);    /* schedule */\r\n        if (rem->smp_reg_count)\r\n            sim_activate (&rem_con_smp_smpl_units[rem->line], rem->smp_sample_interval);    /* schedule */\r\n        }\r\n    sim_activate_after (rem_con_data_unit, 100000);         /* continue polling for open sessions */\r\n    return sim_rem_con_poll_svc (rem_con_poll_unit);        /* establish polling for new sessions */\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_set_rem_telnet (int32 flag, CONST char *cptr)\r\n{\r\nt_stat r;\r\n\r\nif (flag) {\r\n    char gbuf[CBUFSIZE];\r\n    char *cp;\r\n\r\n    strlcpy (gbuf, cptr, sizeof (gbuf));\r\n    if ((cp = strchr (gbuf, ';')))\r\n        *cp = '\\0';\r\n    r = sim_parse_addr (gbuf, NULL, 0, NULL, NULL, 0, NULL, NULL);\r\n    if (r == SCPE_OK) {\r\n        if (cp != NULL)\r\n            *cp = ';';\r\n        if (sim_rem_con_tmxr.master)                        /* already open? */\r\n            sim_set_rem_telnet (0, NULL);                   /* close first */\r\n        if (sim_rem_con_tmxr.lines == 0)                    /* if no connection limit set */\r\n            sim_set_rem_connections (0, \"1\");               /* use 1 */\r\n        sim_rem_con_tmxr.buffered = 8192;                   /* Use big enough buffers */\r\n        sim_register_internal_device (&sim_remote_console);\r\n        sim_rem_con_tmxr.dptr = NULL;                       /* be sure that dptr and uptr are NULL which might */\r\n        sim_rem_con_tmxr.uptr = NULL;                       /* not be the case if a prior TELNET option was set */\r\n        r = tmxr_attach (&sim_rem_con_tmxr, rem_con_poll_unit, cptr);/* open master socket */\r\n        if (r == SCPE_OK)\r\n            sim_activate_after(rem_con_poll_unit, 1000000);/* check for connection in 1 second */\r\n        return r;\r\n        }\r\n    return sim_messagef (SCPE_NOPARAM, \"Invalid remote telnet specification: %s\\n\", gbuf);\r\n    }\r\nelse {\r\n    if (sim_rem_con_tmxr.master) {\r\n        int32 i;\r\n\r\n        tmxr_detach (&sim_rem_con_tmxr, rem_con_poll_unit);\r\n        for (i=0; i<sim_rem_con_tmxr.lines; i++) {\r\n            REMOTE *rem = &sim_rem_consoles[i];\r\n            free (rem->buf);\r\n            rem->buf = NULL;\r\n            rem->buf_size = 0;\r\n            rem->buf_ptr = 0;\r\n            rem->single_mode = TRUE;\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_set_rem_connections (int32 flag, CONST char *cptr)\r\n{\r\nint32 lines;\r\nREMOTE *rem;\r\nt_stat r;\r\nint32 i;\r\n\r\nif (cptr == NULL)\r\n    return SCPE_ARG;\r\nlines = (int32) get_uint (cptr, 10, MAX_REMOTE_SESSIONS, &r);\r\nif (r != SCPE_OK)\r\n    return r;\r\nif (sim_rem_con_tmxr.master)\r\n    return sim_messagef (SCPE_ALATT, \"Remote Console Connection Limit must be set before TELNET parameters\\n\");\r\nif (sim_rem_con_tmxr.lines) {\r\n    sim_cancel (rem_con_poll_unit);\r\n    sim_cancel (rem_con_data_unit);\r\n    }\r\nfor (i=0; i<sim_rem_con_tmxr.lines; i++) {\r\n    rem = &sim_rem_consoles[i];\r\n    free (rem->buf);\r\n    free (rem->act_buf);\r\n    free (rem->act);\r\n    free (rem->repeat_action);\r\n    sim_cancel (&rem_con_repeat_units[i]);\r\n    sim_cancel (&rem_con_smp_smpl_units[i]);\r\n    }\r\nsim_rem_con_tmxr.lines = lines;\r\nsim_rem_con_tmxr.ldsc = (TMLN *)realloc (sim_rem_con_tmxr.ldsc, sizeof(*sim_rem_con_tmxr.ldsc)*lines);\r\nmemset (sim_rem_con_tmxr.ldsc, 0, sizeof(*sim_rem_con_tmxr.ldsc)*lines);\r\nsim_remote_console.units = (UNIT *)realloc (sim_remote_console.units, sizeof(*sim_remote_console.units)*((2 * lines) + REM_CON_BASE_UNITS));\r\nmemset (sim_remote_console.units, 0, sizeof(*sim_remote_console.units)*((2 * lines) + REM_CON_BASE_UNITS));\r\nsim_remote_console.numunits = (2 * lines) + REM_CON_BASE_UNITS;\r\nrem_con_poll_unit->action = &sim_rem_con_poll_svc;/* remote console connection polling unit */\r\nrem_con_poll_unit->flags |= UNIT_IDLE;\r\nsim_set_uname (rem_con_poll_unit, \"REM-CON-POLL\");\r\nrem_con_data_unit->action = &sim_rem_con_data_svc;/* console data handling unit */\r\nrem_con_data_unit->flags |= UNIT_IDLE|UNIT_DIS;\r\nsim_set_uname (rem_con_data_unit, \"REM-CON-DATA\");\r\nsim_rem_consoles = (REMOTE *)realloc (sim_rem_consoles, sizeof(*sim_rem_consoles)*lines);\r\nmemset (sim_rem_consoles, 0, sizeof(*sim_rem_consoles)*lines);\r\nsim_rem_command_buf = (char *)realloc (sim_rem_command_buf, 4*CBUFSIZE+1);\r\nmemset (sim_rem_command_buf, 0, 4*CBUFSIZE+1);\r\nfor (i=0; i<lines; i++) {\r\n    char uname[32];\r\n\r\n    rem_con_repeat_units[i].flags = UNIT_DIS;\r\n    rem_con_repeat_units[i].action = &sim_rem_con_repeat_svc;\r\n    snprintf (uname, sizeof (uname), \"%s-REP%d\", sim_remote_console.name, i);\r\n    sim_set_uname (&rem_con_repeat_units[i], uname);\r\n    rem_con_smp_smpl_units[i].flags = UNIT_DIS;\r\n    rem_con_smp_smpl_units[i].action = &sim_rem_con_smp_collect_svc;\r\n    snprintf (uname, sizeof (uname), \"%s-SMP%d\", sim_remote_console.name, i);\r\n    sim_set_uname (&rem_con_smp_smpl_units[i], uname);\r\n    rem = &sim_rem_consoles[i];\r\n    rem->line = i;\r\n    rem->lp = &sim_rem_con_tmxr.ldsc[i];\r\n    rem->uptr = &rem_con_repeat_units[i];\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_set_rem_timeout (int32 flag, CONST char *cptr)\r\n{\r\nint32 timeout;\r\nt_stat r;\r\n\r\nif (cptr == NULL)\r\n    return SCPE_ARG;\r\ntimeout = (int32) get_uint (cptr, 10, 3600, &r);\r\nif (r != SCPE_OK)\r\n    return r;\r\nif (sim_rem_active_number >= 0)\r\n    sim_rem_consoles[sim_rem_active_number].read_timeout = timeout;\r\nelse\r\n    sim_rem_read_timeout = timeout;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_set_rem_bufsize (int32 flag, CONST char *cptr)\r\n{\r\nchar cmdbuf[CBUFSIZE];\r\nint32 bufsize;\r\nt_stat r;\r\n\r\nif (cptr == NULL)\r\n    return SCPE_ARG;\r\nbufsize = (int32) get_uint (cptr, 10, 32768, &r);\r\nif (r != SCPE_OK)\r\n    return r;\r\nif (bufsize < 1400)\r\n    return sim_messagef (SCPE_ARG, \"%d is too small.  Minimum size is 1400\\n\", bufsize);\r\nsprintf(cmdbuf, \"BUFFERED=%d\", bufsize);\r\nreturn tmxr_open_master (&sim_rem_con_tmxr, cmdbuf);        /* open master socket */\r\n}\r\n\r\nt_bool sim_is_remote_console_master_line (void *lp)\r\n{\r\nreturn sim_rem_master_mode &&                                           /* master mode */\r\n       (((TMLN *)lp) >= sim_rem_con_tmxr.ldsc) &&                       /* And it is one of the Remote Console Lines */\r\n       (((TMLN *)lp) < sim_rem_con_tmxr.ldsc + sim_rem_con_tmxr.lines);\r\n}\r\n\r\n/* Enable or disable Remote Console master mode */\r\n\r\n/* In master mode, commands are subsequently processed from the\r\n   primary/initial (master mode) remote console session.  Commands\r\n   are processed from that source until that source disables master\r\n   mode or the simulator exits\r\n */\r\n\r\nstatic t_stat sim_set_rem_master (int32 flag, CONST char *cptr)\r\n{\r\nt_stat stat = SCPE_OK;\r\n\r\nif (cptr && *cptr)\r\n    return SCPE_2MARG;\r\n\r\nif (sim_rem_active_number > 0)\r\n    return sim_messagef (SCPE_INVREM, \"Can't change Remote Console mode from Remote Console\\n\");\r\n\r\nif (sim_rem_con_tmxr.master || (!flag))                     /* Remote Console Enabled? */\r\n    sim_rem_master_mode = flag;\r\nelse\r\n    return sim_messagef (SCPE_INVREM, \"Can't enable Remote Console Master mode with Remote Console disabled\\n\");\r\n\r\nif (sim_rem_master_mode) {\r\n    t_stat stat_nomessage = 0;\r\n\r\n    sim_messagef (SCPE_OK, \"Command input starting on Master Remote Console Session\\n\");\r\n    stat = sim_run_boot_prep (0);\r\n    sim_rem_master_was_enabled = TRUE;\r\n    sim_last_cmd_stat = SCPE_OK;\r\n    while (sim_rem_master_mode) {\r\n        char *brk_action;\r\n\r\n        sim_rem_consoles[0].single_mode = FALSE;\r\n        sim_cancel (rem_con_data_unit);\r\n        sim_activate (rem_con_data_unit, -1);\r\n        stat = run_cmd (RU_GO, \"\");\r\n        if (stat != SCPE_TTMO) {\r\n            stat_nomessage = stat & SCPE_NOMESSAGE;         /* extract possible message suppression flag */\r\n            stat = _sim_rem_message (\"RUN\", stat);\r\n            }\r\n        brk_action = sim_brk_replace_act (NULL);\r\n        sim_debug (DBG_MOD, &sim_remote_console, \"Master Session Returned: Status - %d Active_Line: %d, Mode: %s, Active Cmd: %s%s%s\\n\", stat, sim_rem_cmd_active_line, sim_rem_consoles[0].single_mode ? \"Single\" : \"^E Stopped\", sim_rem_active_command ? sim_rem_active_command->name : \"\", brk_action ? \" Break Action: \" : \"\", brk_action ? brk_action : \"\");\r\n        if (stat == SCPE_EXIT)\r\n            sim_rem_master_mode = FALSE;\r\n        if (brk_action) {\r\n            free (sim_rem_consoles[0].act);\r\n            sim_rem_consoles[0].act = brk_action;\r\n            }\r\n        sim_rem_cmd_active_line = 0;                    /* Make it look like */\r\n        sim_rem_consoles[0].single_mode = FALSE;\r\n        sim_cancel_step ();\r\n        if (stat != SCPE_STEP)\r\n            sim_rem_active_command = &allowed_single_remote_cmds[0];/* Dummy */\r\n        else\r\n            sim_activate_abs (rem_con_data_unit, -1);   /* force step completion processing */\r\n        sim_last_cmd_stat = SCPE_BARE_STATUS(stat);     /* make exit status available to remote console */\r\n        }\r\n    sim_rem_master_was_enabled = FALSE;\r\n    sim_rem_master_was_connected = FALSE;\r\n    if (sim_log_temp) {                                     /* If we setup a temporary log, clean it now  */\r\n        int32 save_quiet = sim_quiet;\r\n\r\n        sim_quiet = 1;\r\n        sim_set_logoff (0, NULL);\r\n        sim_quiet = save_quiet;\r\n        (void)remove (sim_rem_con_temp_name);\r\n        sim_log_temp = FALSE;\r\n        }\r\n    stat |= stat_nomessage;\r\n    }\r\nelse {\r\n    sim_rem_consoles[0].single_mode = TRUE;                 /* Force remote session into single command mode */\r\n    }\r\nreturn stat;\r\n}\r\n\r\n/* Set keyboard map */\r\n\r\nt_stat sim_set_kmap (int32 flag, CONST char *cptr)\r\n{\r\nDEVICE *dptr = sim_devices[0];\r\nint32 val, rdx;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nif (dptr->dradix == 16)\r\n    rdx = 16;\r\nelse\r\n    rdx = 8;\r\nval = (int32) get_uint (cptr, rdx, 0177, &r);\r\nif ((r != SCPE_OK) ||\r\n    ((val == 0) && (flag & KMAP_NZ)))\r\n    return SCPE_ARG;\r\n*(cons_kmap[flag & KMAP_MASK]) = val;\r\nsigint_message_issued = FALSE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show keyboard map */\r\n\r\nt_stat sim_show_kmap (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint32 kmap_char = *(cons_kmap[flag & KMAP_MASK]);\r\n\r\nif (sim_devices[0]->dradix == 16)\r\n    fprintf (st, \"%s = 0x%X\", show_con_tab[flag].name, kmap_char);\r\nelse\r\n    fprintf (st, \"%s = 0%o\", show_con_tab[flag].name, kmap_char);\r\nif (isprint(kmap_char&0xFF))\r\n    fprintf (st, \" = '%c'\\n\", kmap_char&0xFF);\r\nelse\r\n    if (kmap_char <= 26)\r\n        fprintf (st, \" = ^%c\\n\", '@' + (kmap_char&0xFF));\r\n    else\r\n        if (kmap_char == 28)\r\n            fprintf (st, \" = ^\\\\\\n\");\r\n        else\r\n            fprintf (st, \"\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set printable characters */\r\n\r\nt_stat sim_set_pchar (int32 flag, CONST char *cptr)\r\n{\r\nDEVICE *dptr = sim_devices[0];\r\nuint32 val, rdx;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nif (dptr->dradix == 16) rdx = 16;\r\nelse rdx = 8;\r\nval = (uint32) get_uint (cptr, rdx, 0xFFFFFFFF, &r);\r\nif ((r != SCPE_OK) ||\r\n    ((val & 0x00002400) == 0))\r\n    return SCPE_ARG;\r\nsim_tt_pchar = val;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show printable characters */\r\n\r\nt_stat sim_show_pchar (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (sim_devices[0]->dradix == 16)\r\n    fprintf (st, \"pchar mask = %X\", sim_tt_pchar);\r\nelse\r\n    fprintf (st, \"pchar mask = %o\", sim_tt_pchar);\r\nif (sim_tt_pchar) {\r\n    static const char *pchars[] = {\"NUL(^@)\", \"SOH(^A)\", \"STX(^B)\", \"ETX(^C)\", \"EOT(^D)\", \"ENQ(^E)\", \"ACK(^F)\", \"BEL(^G)\",\r\n                                   \"BS(^H)\" , \"HT(^I)\",  \"LF(^J)\",  \"VT(^K)\",  \"FF(^L)\",  \"CR(^M)\",  \"SO(^N)\",  \"SI(^O)\",\r\n                                   \"DLE(^P)\", \"DC1(^Q)\", \"DC2(^R)\", \"DC3(^S)\", \"DC4(^T)\", \"NAK(^U)\", \"SYN(^V)\", \"ETB(^W)\",\r\n                                   \"CAN(^X)\", \"EM(^Y)\",  \"SUB(^Z)\", \"ESC\",     \"FS(^\\\\)\", \"GS\",      \"RS\",      \"US\"};\r\n    int i;\r\n    t_bool found = FALSE;\r\n\r\n    fprintf (st, \" {\");\r\n    for (i=31; i>=0; i--)\r\n        if (sim_tt_pchar & (1 << i)) {\r\n            fprintf (st, \"%s%s\", found ? \",\" : \"\", pchars[i]);\r\n            found = TRUE;\r\n            }\r\n    fprintf (st, \"}\");\r\n    }\r\nfprintf (st, \"\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set input speed (bps) */\r\n\r\nt_stat sim_set_cons_speed (int32 flag, CONST char *cptr)\r\n{\r\nt_stat r = tmxr_set_line_speed (&sim_con_ldsc, cptr);\r\n\r\nif ((r == SCPE_OK) && (sim_con_ldsc.uptr != NULL))\r\n    sim_con_ldsc.uptr->wait = sim_con_ldsc.rxdeltausecs;\r\nreturn r;\r\n}\r\n\r\nt_stat sim_show_cons_speed (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (sim_con_ldsc.rxbps) {\r\n    fprintf (st, \"Speed = %d\", sim_con_ldsc.rxbps);\r\n    if (sim_con_ldsc.bpsfactor != 1.0)\r\n        fprintf (st, \"*%.0f\", sim_con_ldsc.bpsfactor);\r\n    fprintf (st, \" bps\\n\");\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set log routine */\r\n\r\nt_stat sim_set_logon (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nt_stat r;\r\ntime_t now;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))                     /* need arg */\r\n    return SCPE_2FARG;\r\ncptr = get_glyph_nc (cptr, gbuf, 0);                    /* get file name */\r\nif (*cptr != 0)                                         /* now eol? */\r\n    return SCPE_2MARG;\r\nsim_set_logoff (0, NULL);                               /* close cur log */\r\nr = sim_open_logfile (gbuf, (sim_switches & SWMASK ('B')) == SWMASK ('B'),\r\n                            &sim_log, &sim_log_ref);    /* open log */\r\nif (r != SCPE_OK)                                       /* error? */\r\n    return r;\r\nif ((!sim_quiet) && (!(sim_switches & SWMASK ('Q'))))\r\n    fprintf (stdout, \"Logging to file \\\"%s\\\"\\n\",\r\n             sim_logfile_name (sim_log, sim_log_ref));\r\nfprintf (sim_log, \"Logging to file \\\"%s\\\"\\n\",\r\n             sim_logfile_name (sim_log, sim_log_ref));  /* start of log */\r\ntime(&now);\r\nif ((!sim_quiet) && (!(sim_switches & SWMASK ('Q'))))\r\n    fprintf (sim_log, \"Logging to file \\\"%s\\\" at %s\", sim_logfile_name (sim_log, sim_log_ref), ctime(&now));\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set nolog routine */\r\n\r\nt_stat sim_set_logoff (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nif (sim_log == NULL)                                    /* no log? */\r\n    return SCPE_OK;\r\nif ((!sim_quiet) && (!(sim_switches & SWMASK ('Q'))))\r\n    fprintf (stdout, \"Log file closed\\n\");\r\nfprintf (sim_log, \"Log file closed\\n\");\r\nsim_close_logfile (&sim_log_ref);                       /* close log */\r\nsim_log = NULL;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show log status */\r\n\r\nt_stat sim_show_log (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nif (sim_log)\r\n    fprintf (st, \"Logging enabled to \\\"%s\\\"\\n\",\r\n                 sim_relative_path (sim_logfile_name (sim_log, sim_log_ref)));\r\nelse\r\n    fprintf (st, \"Logging disabled\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set debug switches */\r\n\r\nint32 sim_set_deb_switches (int32 switches)\r\n{\r\nint32 old_deb_switches = sim_deb_switches;\r\n\r\nsim_deb_switches = switches &\r\n                   (SWMASK ('R') | SWMASK ('P') |\r\n                    SWMASK ('T') | SWMASK ('A') |\r\n                    SWMASK ('F') | SWMASK ('N') |\r\n                    SWMASK ('B') | SWMASK ('E') |\r\n                    SWMASK ('D') );                 /* save debug switches */\r\nreturn old_deb_switches;\r\n}\r\n\r\n/* Set debug routine */\r\n\r\nt_stat sim_set_debon (int32 flag, CONST char *cptr)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nt_stat r;\r\ntime_t now;\r\nsize_t buffer_size = 0;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))                     /* need arg */\r\n    return SCPE_2FARG;\r\nif (sim_switches & SWMASK ('B')) {\r\n    cptr = get_glyph_nc (cptr, gbuf, 0);                /* buffer size */\r\n    buffer_size = (size_t)strtoul (gbuf, NULL, 10);\r\n    if ((buffer_size == 0) || (buffer_size > 1024))\r\n        return sim_messagef (SCPE_ARG, \"Invalid debug memory buffersize %u MB\\n\", (unsigned int)buffer_size);\r\n    }\r\ncptr = get_glyph_quoted (cptr, gbuf, 0);                /* get file name */\r\nif (*cptr != 0)                                         /* now eol? */\r\n    return SCPE_2MARG;\r\nr = sim_open_logfile (gbuf, FALSE, &sim_deb, &sim_deb_ref);\r\n\r\nif (r != SCPE_OK)\r\n    return r;\r\n\r\nsim_set_deb_switches (sim_switches);\r\n\r\nif (sim_deb_switches & SWMASK ('R')) {\r\n    struct tm loc_tm, gmt_tm;\r\n    time_t time_t_now;\r\n    struct timespec basetime;\r\n\r\n    sim_rtcn_get_time(&basetime, 0);\r\n    time_t_now = (time_t)basetime.tv_sec;\r\n    /* Adjust the relative timebase to reflect the localtime GMT offset */\r\n    loc_tm = *localtime (&time_t_now);\r\n    gmt_tm = *gmtime (&time_t_now);\r\n    basetime.tv_sec -= mktime (&gmt_tm) - mktime (&loc_tm);\r\n    sim_rtcn_set_debug_basetime (&basetime);\r\n    if (!(sim_deb_switches & (SWMASK ('A') | SWMASK ('T'))))\r\n        sim_deb_switches |= SWMASK ('T');\r\n    }\r\nsim_messagef (SCPE_OK, \"Debug output to \\\"%s\\\"\\n\", sim_logfile_name (sim_deb, sim_deb_ref));\r\nif (sim_deb_switches & SWMASK ('P'))\r\n    sim_messagef (SCPE_OK, \"   Debug messages contain current PC value\\n\");\r\nif (sim_deb_switches & SWMASK ('T'))\r\n    sim_messagef (SCPE_OK, \"   Debug messages display time of day as hh:mm:ss.msec%s\\n\", sim_deb_switches & SWMASK ('R') ? \" relative to the start of debugging\" : \"\");\r\nif (sim_deb_switches & SWMASK ('A'))\r\n    sim_messagef (SCPE_OK, \"   Debug messages display time of day as seconds.msec%s\\n\", sim_deb_switches & SWMASK ('R') ? \" relative to the start of debugging\" : \"\");\r\nif (sim_deb_switches & SWMASK ('F'))\r\n    sim_messagef (SCPE_OK, \"   Debug messages will not be filtered to summarize duplicate lines\\n\");\r\nif (sim_deb_switches & SWMASK ('E'))\r\n    sim_messagef (SCPE_OK, \"   Debug messages containing blob data in EBCDIC will display in readable form\\n\");\r\nif (sim_deb_switches & SWMASK ('B'))\r\n    sim_messagef (SCPE_OK, \"   Debug messages will be written to a %u MB circular memory buffer\\n\",\r\n                                (unsigned int)buffer_size);\r\ntime(&now);\r\nif (!sim_quiet) {\r\n    fprintf (sim_deb, \"Debug output to \\\"%s\\\" at %s\", sim_logfile_name (sim_deb, sim_deb_ref), ctime(&now));\r\n    show_version (sim_deb, NULL, NULL, 0, NULL);\r\n    }\r\nif (sim_deb_switches & SWMASK ('N'))\r\n    sim_deb_switches &= ~SWMASK ('N');          /* Only process the -N flag initially */\r\n\r\nif (sim_deb_switches & SWMASK ('B')) {\r\n    sim_deb_buffer_size = (size_t)(1024 * 1024 * buffer_size);\r\n    sim_deb_buffer = (char *)realloc (sim_deb_buffer, sim_deb_buffer_size);\r\n    sim_debug_buffer_offset = sim_debug_buffer_inuse = 0;\r\n    memset (sim_deb_buffer, 0, sim_deb_buffer_size);\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set nodebug routine */\r\n\r\nt_stat sim_set_deboff (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* now eol? */\r\n    return SCPE_2MARG;\r\nif (sim_deb == NULL) {                                  /* no debug? */\r\n    if  (cptr != NULL)\r\n        return sim_messagef (SCPE_OK, \"Debug not enabled\\n\");\r\n    else\r\n        return SCPE_OK;\r\n    }\r\nif (sim_deb_switches & SWMASK ('B')) {\r\n    size_t offset = (sim_debug_buffer_inuse == sim_deb_buffer_size) ? sim_debug_buffer_offset : 0;\r\n    const char *bufmsg = \"\\nCircular Buffer Contents follow here:\\n\\n\";\r\n\r\n    if (sim_debug_buffer_inuse > 0)\r\n        fwrite (bufmsg, 1, strlen (bufmsg), sim_deb);\r\n\r\n    while (sim_debug_buffer_inuse > 0) {\r\n        size_t write_size = MIN (sim_deb_buffer_size - offset, sim_debug_buffer_inuse);\r\n        size_t written;\r\n\r\n        written = fwrite (sim_deb_buffer + offset, 1, write_size, sim_deb);\r\n        sim_debug_buffer_inuse -= written;\r\n        offset += written;\r\n        if (offset == sim_deb_buffer_size)\r\n            offset = 0;\r\n        }\r\n    free (sim_deb_buffer);\r\n    sim_deb_buffer = NULL;\r\n    sim_deb_buffer_size = sim_debug_buffer_offset = sim_debug_buffer_inuse = 0;\r\n    }\r\nsim_close_logfile (&sim_deb_ref);\r\nsim_deb = NULL;\r\nsim_deb_switches = 0;\r\nerrno = 0;\r\nreturn sim_messagef (SCPE_OK, \"Debug output disabled\\n\");\r\n}\r\n\r\n/* Show debug routine */\r\n\r\nt_stat sim_show_debug (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint32 i;\r\n\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nif (sim_deb) {\r\n    fprintf (st, \"Debug output enabled to \\\"%s\\\"\\n\",\r\n                 sim_relative_path (sim_logfile_name (sim_deb, sim_deb_ref)));\r\n    if (sim_deb_switches & SWMASK ('P'))\r\n        fprintf (st, \"   Debug messages contain current PC value\\n\");\r\n    if (sim_deb_switches & SWMASK ('T'))\r\n        fprintf (st, \"   Debug messages display time of day as hh:mm:ss.msec%s\\n\", sim_deb_switches & SWMASK ('R') ? \" relative to the start of debugging\" : \"\");\r\n    if (sim_deb_switches & SWMASK ('A'))\r\n        fprintf (st, \"   Debug messages display time of day as seconds.msec%s\\n\", sim_deb_switches & SWMASK ('R') ? \" relative to the start of debugging\" : \"\");\r\n    if (sim_deb_switches & SWMASK ('F'))\r\n        fprintf (st, \"   Debug messages are not being filtered to summarize duplicate lines\\n\");\r\n    if (sim_deb_switches & SWMASK ('E'))\r\n        fprintf (st, \"   Debug messages containing blob data in EBCDIC will display in readable form\\n\");\r\n    for (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n        t_bool unit_debug = FALSE;\r\n        uint32 unit;\r\n\r\n        for (unit = 0; unit < dptr->numunits; unit++)\r\n            if (dptr->units[unit].dctrl) {\r\n                unit_debug = TRUE;\r\n                break;\r\n                }\r\n        if (!(dptr->flags & DEV_DIS) &&\r\n            ((dptr->flags & DEV_DEBUG) || (dptr->debflags)) &&\r\n            ((dptr->dctrl) || unit_debug)) {\r\n            fprintf (st, \"Device: %-6s \", dptr->name);\r\n            show_dev_debug (st, dptr, NULL, 0, NULL);\r\n            }\r\n        }\r\n    for (i = 0; sim_internal_device_count && (dptr = sim_internal_devices[i]); ++i) {\r\n        t_bool unit_debug = FALSE;\r\n        uint32 unit;\r\n\r\n        for (unit = 0; unit < dptr->numunits; unit++)\r\n            if (dptr->units[unit].dctrl) {\r\n                unit_debug = TRUE;\r\n                break;\r\n                }\r\n        if (!(dptr->flags & DEV_DIS) &&\r\n            ((dptr->flags & DEV_DEBUG) || (dptr->debflags)) &&\r\n            ((dptr->dctrl) || unit_debug)) {\r\n            fprintf (st, \"Device: %-6s \", dptr->name);\r\n            show_dev_debug (st, dptr, NULL, 0, NULL);\r\n            }\r\n        }\r\n    }\r\nelse\r\n    fprintf (st, \"Debug output disabled\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* SET CONSOLE command */\r\n\r\n/* Set console to Telnet port (and parameters) */\r\n\r\nt_stat sim_set_telnet (int32 flag, CONST char *cptr)\r\n{\r\nchar *cvptr, gbuf[CBUFSIZE];\r\nCTAB *ctptr;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph_nc (cptr, gbuf, ',');              /* get modifier */\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    get_glyph (gbuf, gbuf, 0);                          /* modifier to UC */\r\n    if ((ctptr = find_ctab (set_con_telnet_tab, gbuf))) { /* match? */\r\n        r = ctptr->action (ctptr->arg, cvptr);          /* do the rest */\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        }\r\n    else {\r\n        if (cvptr)                                      /* if we removed a = sign */\r\n            *(--cvptr) = '=';                           /* restore it */\r\n        if (sim_con_tmxr.master)                        /* already open? */\r\n            sim_set_notelnet (0, NULL);                 /* close first */\r\n        r = tmxr_attach (&sim_con_tmxr, &sim_con_unit, gbuf);/* open master socket */\r\n        if (r == SCPE_OK)\r\n            sim_activate_after(&sim_con_unit, 1000000); /* check for connection in 1 second */\r\n        else\r\n            return r;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Close console Telnet port */\r\n\r\nt_stat sim_set_notelnet (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* too many arguments? */\r\n    return SCPE_2MARG;\r\nif (sim_con_tmxr.master == 0)                           /* ignore if already closed */\r\n    return SCPE_OK;\r\nreturn tmxr_close_master (&sim_con_tmxr);               /* close master socket */\r\n}\r\n\r\n/* Show console Telnet status */\r\n\r\nt_stat sim_show_telnet (FILE *st, DEVICE *dunused, UNIT *uunused, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nif ((sim_con_tmxr.master == 0) &&\r\n    (sim_con_ldsc.serport == 0))\r\n    fprintf (st, \"Connected to console window\\n\");\r\nelse {\r\n    if (sim_con_ldsc.serport) {\r\n        fprintf (st, \"Connected to \");\r\n        tmxr_fconns (st, &sim_con_ldsc, -1);\r\n        }\r\n    else\r\n        if (sim_con_ldsc.sock == 0)\r\n            fprintf (st, \"Listening on port %s\\n\", sim_con_tmxr.port);\r\n        else {\r\n            fprintf (st, \"Listening on port %s, connection from %s\\n\",\r\n                sim_con_tmxr.port, sim_con_ldsc.ipad);\r\n            tmxr_fconns (st, &sim_con_ldsc, -1);\r\n            }\r\n    tmxr_fstats (st, &sim_con_ldsc, -1);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set console to Buffering  */\r\n\r\nt_stat sim_set_cons_buff (int32 flg, CONST char *cptr)\r\n{\r\nchar cmdbuf[CBUFSIZE];\r\n\r\nsprintf(cmdbuf, \"BUFFERED%c%s\", cptr ? '=' : '\\0', cptr ? cptr : \"\");\r\nreturn tmxr_open_master (&sim_con_tmxr, cmdbuf);      /* open master socket */\r\n}\r\n\r\n/* Set console to NoBuffering */\r\n\r\nt_stat sim_set_cons_unbuff (int32 flg, CONST char *cptr)\r\n{\r\nchar cmdbuf[CBUFSIZE];\r\n\r\nsprintf(cmdbuf, \"UNBUFFERED%c%s\", cptr ? '=' : '\\0', cptr ? cptr : \"\");\r\nreturn tmxr_open_master (&sim_con_tmxr, cmdbuf);      /* open master socket */\r\n}\r\n\r\n/* Set console to Logging */\r\n\r\nt_stat sim_set_cons_log (int32 flg, CONST char *cptr)\r\n{\r\nchar cmdbuf[CBUFSIZE];\r\n\r\nsprintf(cmdbuf, \"LOG%c%s\", cptr ? '=' : '\\0', cptr ? cptr : \"\");\r\nreturn tmxr_open_master (&sim_con_tmxr, cmdbuf);      /* open master socket */\r\n}\r\n\r\n/* Set console to NoLogging */\r\n\r\nt_stat sim_set_cons_nolog (int32 flg, CONST char *cptr)\r\n{\r\nchar cmdbuf[CBUFSIZE];\r\n\r\nsprintf(cmdbuf, \"NOLOG%c%s\", cptr ? '=' : '\\0', cptr ? cptr : \"\");\r\nreturn tmxr_open_master (&sim_con_tmxr, cmdbuf);      /* open master socket */\r\n}\r\n\r\nt_stat sim_show_cons_log (FILE *st, DEVICE *dunused, UNIT *uunused, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nif (sim_con_tmxr.ldsc->txlog)\r\n    fprintf (st, \"Log File being written to %s\\n\", sim_con_tmxr.ldsc->txlogname);\r\nelse\r\n    fprintf (st, \"No Logging\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_show_cons_buff (FILE *st, DEVICE *dunused, UNIT *uunused, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nif (!sim_con_tmxr.ldsc->txbfd)\r\n    fprintf (st, \"Unbuffered\\n\");\r\nelse\r\n    fprintf (st, \"Buffer Size = %d\\n\", sim_con_tmxr.ldsc->txbsz);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Start telnet session/window to console or optionally an arbitrary TCP port on the local system */\r\n\r\nt_stat sim_set_cons_connect (int32 flg, CONST char *cptr)\r\n{\r\nif ((cptr != NULL) && (*cptr != '\\0')) {\r\n    t_stat r;\r\n    uint32 port = (uint32)get_uint (cptr, 10, 65535, &r);\r\n\r\n    if ((port == 0) || (r != SCPE_OK))\r\n        return sim_messagef (SCPE_ARG, \"Invalid TCP port for telnet connection: %s\\n\", cptr);\r\n    }\r\nelse\r\n    if (sim_con_tmxr.port == NULL)\r\n        return sim_messagef (SCPE_ARG, \"Console not listening for telnet connections\\n\");\r\n    else\r\n        cptr = sim_con_tmxr.port;\r\nreturn sim_os_connect_telnet (atoi (cptr));\r\n}\r\n\r\n\r\n/* Set console Debug Mode */\r\n\r\nt_stat sim_set_cons_debug (int32 flg, CONST char *cptr)\r\n{\r\nreturn set_dev_debug (&sim_con_telnet, &sim_con_unit, flg, cptr);\r\n}\r\n\r\nt_stat sim_show_cons_debug (FILE *st, DEVICE *dunused, UNIT *uunused, int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))\r\n    return SCPE_2MARG;\r\nreturn show_dev_debug (st, &sim_con_telnet, &sim_con_unit, flag, cptr);\r\n}\r\n\r\n/* Set console to Serial port (and parameters) */\r\n\r\nt_stat sim_set_serial (int32 flag, CONST char *cptr)\r\n{\r\nchar *cvptr, gbuf[CBUFSIZE], ubuf[CBUFSIZE];\r\nCTAB *ctptr;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph_nc (cptr, gbuf, ',');              /* get modifier */\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    get_glyph (gbuf, ubuf, 0);                          /* modifier to UC */\r\n    if ((ctptr = find_ctab (set_con_serial_tab, ubuf))) { /* match? */\r\n        r = ctptr->action (ctptr->arg, cvptr);          /* do the rest */\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        }\r\n    else {\r\n        SERHANDLE serport = sim_open_serial (gbuf, NULL, &r);\r\n        if (serport != INVALID_HANDLE) {\r\n            sim_close_serial (serport);\r\n            if (r == SCPE_OK) {\r\n                char cbuf[CBUFSIZE+10];\r\n\r\n                if ((sim_con_tmxr.master) ||            /* already open? */\r\n                    (sim_con_ldsc.serport))\r\n                    sim_set_noserial (0, NULL);         /* close first */\r\n                sprintf(cbuf, \"Connect=%s\", gbuf);\r\n                r = tmxr_attach (&sim_con_tmxr, &sim_con_unit, cbuf);/* open master socket */\r\n                sim_con_ldsc.rcve = 1;                  /* rcv enabled */\r\n                if (r == SCPE_OK)\r\n                    sim_activate_after(&sim_con_unit, 1000000); /* check for connection in 1 second */\r\n                return r;\r\n                }\r\n            }\r\n        return SCPE_ARG;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Close console Serial port */\r\n\r\nt_stat sim_set_noserial (int32 flag, CONST char *cptr)\r\n{\r\nif (cptr && (*cptr != 0))                               /* too many arguments? */\r\n    return SCPE_2MARG;\r\nif (sim_con_ldsc.serport == 0)                          /* ignore if already closed */\r\n    return SCPE_OK;\r\nreturn tmxr_close_master (&sim_con_tmxr);               /* close master socket */\r\n}\r\n\r\n/* Show the console expect rules and state */\r\n\r\nt_stat sim_show_cons_expect (FILE *st, DEVICE *dunused, UNIT *uunused, int32 flag, CONST char *cptr)\r\n{\r\nfprintf (st, \"Console Expect processing:\\n\");\r\nreturn sim_exp_show (st, &sim_con_expect, cptr);\r\n}\r\n\r\n/* Log File Open/Close/Show Support */\r\n\r\n/* Open log file */\r\n\r\nt_stat sim_open_logfile (const char *filename, t_bool binary, FILE **pf, FILEREF **pref)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nconst char *tptr;\r\n\r\nif ((filename == NULL) || (*filename == 0))             /* too few arguments? */\r\n    return SCPE_2FARG;\r\ntptr = get_glyph_quoted (filename, gbuf, 0);\r\nif (*tptr != 0)                                         /* now eol? */\r\n    return SCPE_2MARG;\r\nsim_close_logfile (pref);\r\n*pf = NULL;\r\nif (strcmp (gbuf, \"LOG\") == 0) {                        /* output to log? */\r\n    if (sim_log == NULL)                                /* any log? */\r\n        return SCPE_ARG;\r\n    *pf = sim_log;\r\n    *pref = sim_log_ref;\r\n    if (*pref)\r\n        ++(*pref)->refcount;\r\n    }\r\nelse if (strcmp (gbuf, \"DEBUG\") == 0) {                 /* output to debug? */\r\n    if (sim_deb == NULL)                                /* any debug? */\r\n        return SCPE_ARG;\r\n    *pf = sim_deb;\r\n    *pref = sim_deb_ref;\r\n    if (*pref)\r\n        ++(*pref)->refcount;\r\n    }\r\nelse if (strcmp (gbuf, \"STDOUT\") == 0) {                /* output to stdout? */\r\n    *pf = stdout;\r\n    *pref = NULL;\r\n    }\r\nelse if (strcmp (gbuf, \"STDERR\") == 0) {                /* output to stderr? */\r\n    *pf = stderr;\r\n    *pref = NULL;\r\n    }\r\nelse {\r\n    char *fullpath = NULL;\r\n\r\n    *pref = (FILEREF *)calloc (1, sizeof(**pref));\r\n    if (!*pref)\r\n        return SCPE_MEM;\r\n    fullpath = sim_filepath_parts (filename, \"f\");      /* reparse */\r\n    strlcpy ((*pref)->name, fullpath, sizeof((*pref)->name));\r\n    if (sim_switches & SWMASK ('N'))                    /* if a new log file is requested */\r\n        *pf = sim_fopen (fullpath, (binary ? \"w+b\" : \"w+\"));/*   then open an empty file */\r\n    else                                                /* otherwise */\r\n        *pf = sim_fopen (fullpath, (binary ? \"a+b\" : \"a+\"));/*   append to an existing file */\r\n    free (fullpath);\r\n    if (*pf == NULL) {                                  /* error? */\r\n        free (*pref);\r\n        *pref = NULL;\r\n        return SCPE_OPENERR;\r\n        }\r\n    setvbuf (*pf, NULL, _IOFBF, 65536);\r\n    (*pref)->file = *pf;\r\n    (*pref)->refcount = 1;                               /* need close */\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Close log file */\r\n\r\nt_stat sim_close_logfile (FILEREF **pref)\r\n{\r\nif (NULL == *pref)\r\n    return SCPE_OK;\r\n(*pref)->refcount = (*pref)->refcount  - 1;\r\nif ((*pref)->refcount > 0) {\r\n    *pref = NULL;\r\n    return SCPE_OK;\r\n    }\r\nfclose ((*pref)->file);\r\nfree (*pref);\r\n*pref = NULL;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show logfile support routine */\r\n\r\nconst char *sim_logfile_name (FILE *st, FILEREF *ref)\r\n{\r\nif (!st)\r\n    return \"\";\r\nif (st == stdout)\r\n    return \"STDOUT\";\r\nif (st == stderr)\r\n    return \"STDERR\";\r\nif (!ref)\r\n    return \"\";\r\nreturn ref->name;\r\n}\r\n\r\n/* Check connection before executing\r\n   (including a remote console which may be required in master mode) */\r\n\r\nt_stat sim_check_console (int32 sec)\r\n{\r\nint32 c, trys = 0;\r\n\r\nif (sim_rem_master_mode) {\r\n    for (;trys < sec; ++trys) {\r\n        sim_rem_con_poll_svc (rem_con_poll_unit);\r\n        if (sim_rem_con_tmxr.ldsc[0].conn)\r\n            break;\r\n        if ((trys % 10) == 0) {                         /* Status every 10 sec */\r\n            sim_messagef (SCPE_OK, \"Waiting for Remote Console connection\\r\\n\");\r\n            fflush (stdout);\r\n            if (sim_log)                                /* log file? */\r\n                fflush (sim_log);\r\n            }\r\n        sim_os_sleep (1);                               /* wait 1 second */\r\n        }\r\n    if ((sim_rem_con_tmxr.ldsc[0].conn) &&\r\n        (!sim_con_ldsc.serport) &&\r\n        (sim_con_tmxr.master == 0) &&\r\n        (sim_con_console_port)) {\r\n        tmxr_linemsgf (&sim_rem_con_tmxr.ldsc[0], \"\\r\\nConsole port must be Telnet or Serial with Master Remote Console\\r\\n\");\r\n        tmxr_linemsgf (&sim_rem_con_tmxr.ldsc[0], \"Goodbye\\r\\n\");\r\n        while (tmxr_send_buffered_data (&sim_rem_con_tmxr.ldsc[0]))\r\n            sim_os_ms_sleep (100);\r\n        sim_os_ms_sleep (100);\r\n        tmxr_reset_ln (&sim_rem_con_tmxr.ldsc[0]);\r\n        return sim_messagef (SCPE_EXIT, \"Console port must be Telnet or Serial with Master Remote Console\\r\\n\");\r\n        }\r\n    }\r\nif (trys == sec) {\r\n    return SCPE_TTMO;                                   /* timed out */\r\n    }\r\nif (sim_con_ldsc.serport)\r\n    if (tmxr_poll_conn (&sim_con_tmxr) >= 0)\r\n        sim_con_ldsc.rcve = 1;                          /* rcv enabled */\r\nif ((sim_con_tmxr.master == 0) ||                       /* serial console or not Telnet? done */\r\n    (sim_con_ldsc.serport))\r\n    return SCPE_OK;\r\nif (sim_con_ldsc.conn || sim_con_ldsc.txbfd) {          /* connected or buffered ? */\r\n    tmxr_poll_rx (&sim_con_tmxr);                       /* poll (check disconn) */\r\n    if (sim_con_ldsc.conn || sim_con_ldsc.txbfd) {      /* still connected? */\r\n        if (!sim_con_ldsc.conn) {\r\n            sim_messagef (SCPE_OK, \"Running with Buffered Console\\r\\n\"); /* print transition */\r\n            fflush (stdout);\r\n            if (sim_log)                                /* log file? */\r\n                fflush (sim_log);\r\n            }\r\n        return SCPE_OK;\r\n        }\r\n    }\r\nfor (; trys < sec; trys++) {                            /* loop */\r\n    if (tmxr_poll_conn (&sim_con_tmxr) >= 0) {          /* poll connect */\r\n        sim_con_ldsc.rcve = 1;                          /* rcv enabled */\r\n        if (trys) {                                     /* if delayed */\r\n            sim_messagef (SCPE_OK, \"Running\\r\\n\");                 /* print transition */\r\n            fflush (stdout);\r\n            if (sim_log)                                /* log file? */\r\n                fflush (sim_log);\r\n            }\r\n        return SCPE_OK;                                 /* ready to proceed */\r\n        }\r\n    c = sim_os_poll_kbd ();                             /* check for stop char */\r\n    if ((c == SCPE_STOP) || stop_cpu)\r\n        return SCPE_STOP;\r\n    if ((trys % 10) == 0) {                             /* Status every 10 sec */\r\n        sim_messagef (SCPE_OK, \"Waiting for console Telnet connection\\r\\n\");\r\n        fflush (stdout);\r\n        if (sim_log)                                    /* log file? */\r\n            fflush (sim_log);\r\n        }\r\n    sim_os_sleep (1);                                   /* wait 1 second */\r\n    }\r\nreturn SCPE_TTMO;                                       /* timed out */\r\n}\r\n\r\n/* Get Send object address for console */\r\n\r\nSEND *sim_cons_get_send (void)\r\n{\r\nreturn &sim_con_send;\r\n}\r\n\r\n/* Get Expect object address for console */\r\n\r\nEXPECT *sim_cons_get_expect (void)\r\n{\r\nreturn &sim_con_expect;\r\n}\r\n\r\n/* Display console Queued input data status */\r\n\r\nt_stat sim_show_cons_send_input (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nfprintf (st, \"Console Send processing:\\n\");\r\nreturn sim_show_send_input (st, &sim_con_send);\r\n}\r\n\r\n/* Poll for character */\r\n\r\nt_stat sim_poll_kbd (void)\r\n{\r\nt_stat c;\r\n\r\nsim_last_poll_kbd_time = sim_os_msec ();                    /* record when this poll happened */\r\nif (sim_send_poll_data (&sim_con_send, &c))                 /* injected input characters available? */\r\n    return c;\r\nif (!sim_rem_master_mode) {\r\n    if ((sim_con_ldsc.rxbps) &&                             /* rate limiting && */\r\n        (sim_gtime () < sim_con_ldsc.rxnexttime))           /* too soon? */\r\n        return SCPE_OK;                                     /* not yet */\r\n    if (sim_ttisatty ())\r\n        c = sim_os_poll_kbd ();                             /* get character */\r\n    else\r\n        c = SCPE_OK;\r\n    if (c == SCPE_STOP) {                                   /* ^E */\r\n        stop_cpu = TRUE;                                    /* Force a stop (which is picked up by sim_process_event */\r\n        return SCPE_OK;\r\n        }\r\n    if ((sim_con_tmxr.master == 0) &&                       /* not Telnet? */\r\n        (sim_con_ldsc.serport == 0)) {                      /* and not serial? */\r\n        if (c && sim_con_ldsc.rxbps)                        /* got something && rate limiting? */\r\n            sim_con_ldsc.rxnexttime =                       /* compute next input time */\r\n                floor (sim_gtime () + ((sim_con_ldsc.rxdeltausecs * sim_timer_inst_per_sec ()) / USECS_PER_SECOND));\r\n        if (c)\r\n            sim_debug (DBG_RCV, &sim_con_telnet, \"sim_poll_kbd() returning: '%c' (0x%02X)\\n\", sim_isprint (c & 0xFF) ? c & 0xFF : '.', c);\r\n        return c;                                           /* in-window */\r\n        }\r\n    if (!sim_con_ldsc.conn) {                               /* no telnet or serial connection? */\r\n        if (!sim_con_ldsc.txbfd)                            /* unbuffered? */\r\n            return SCPE_LOST;                               /* connection lost */\r\n        if (tmxr_poll_conn (&sim_con_tmxr) >= 0)            /* poll connect */\r\n            sim_con_ldsc.rcve = 1;                          /* rcv enabled */\r\n        else                                                /* fall through to poll reception */\r\n            return SCPE_OK;                                 /* unconnected and buffered - nothing to receive */\r\n        }\r\n    }\r\ntmxr_poll_rx (&sim_con_tmxr);                               /* poll for input */\r\nif ((c = (t_stat)tmxr_getc_ln (&sim_con_ldsc))) {           /* any char? */\r\n    sim_debug (DBG_RCV, &sim_con_telnet, \"sim_poll_kbd() tmxr_getc_ln() returning: '%c' (0x%02X)\\n\", sim_isprint (c & 0xFF) ? c & 0xFF : '.', c);\r\n    return (c & (SCPE_BREAK | 0377)) | SCPE_KFLAG;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Output character */\r\n\r\nt_stat sim_putchar (int32 c)\r\n{\r\nsim_exp_check (&sim_con_expect, c);\r\nif ((sim_con_tmxr.master == 0) &&                       /* not Telnet? */\r\n    (sim_con_ldsc.serport == 0)) {                      /* and not serial port */\r\n    ++sim_con_pos;                                      /* bookkeeping */\r\n    if (sim_log)                                        /* log file? */\r\n        fputc (c, sim_log);\r\n    sim_debug (DBG_XMT, &sim_con_telnet, \"sim_putchar('%c' (0x%02X)\\n\", sim_isprint (c) ? c : '.', c);\r\n    return sim_os_putchar (c);                          /* in-window version */\r\n    }\r\nif (!sim_con_ldsc.conn) {                               /* no Telnet or serial connection? */\r\n    if (!sim_con_ldsc.txbfd)                            /* unbuffered? */\r\n        return SCPE_LOST;                               /* connection lost */\r\n    if (tmxr_poll_conn (&sim_con_tmxr) >= 0)            /* poll connect */\r\n        sim_con_ldsc.rcve = 1;                          /* rcv enabled */\r\n    }\r\ntmxr_putc_ln (&sim_con_ldsc, c);                        /* output char */\r\n++sim_con_pos;                                          /* bookkeeping */\r\ntmxr_poll_tx (&sim_con_tmxr);                           /* poll xmt */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_putchar_s (int32 c)\r\n{\r\nt_stat r;\r\n\r\nsim_exp_check (&sim_con_expect, c);\r\nif ((sim_con_tmxr.master == 0) &&                       /* not Telnet? */\r\n    (sim_con_ldsc.serport == 0)) {                      /* and not serial port */\r\n    ++sim_con_pos;                                      /* bookkeeping */\r\n    if (sim_log)                                        /* log file? */\r\n        fputc (c, sim_log);\r\n    sim_debug (DBG_XMT, &sim_con_telnet, \"sim_putchar('%c' (0x%02X)\\n\", sim_isprint (c) ? c : '.', c);\r\n    return sim_os_putchar (c);                          /* in-window version */\r\n    }\r\nif (!sim_con_ldsc.conn) {                               /* no Telnet or serial connection? */\r\n    if (!sim_con_ldsc.txbfd)                            /* non-buffered Telnet connection? */\r\n        return SCPE_LOST;                               /* lost */\r\n    if (tmxr_poll_conn (&sim_con_tmxr) >= 0)            /* poll connect */\r\n        sim_con_ldsc.rcve = 1;                          /* rcv enabled */\r\n    }\r\nr = tmxr_putc_ln (&sim_con_ldsc, c);                    /* Telnet output */\r\nif (r == SCPE_OK)\r\n    ++sim_con_pos;                                      /* bookkeeping */\r\ntmxr_poll_tx (&sim_con_tmxr);                           /* poll xmt */\r\nreturn r;                                               /* return status */\r\n}\r\n\r\n/* Input character processing */\r\n\r\nint32 sim_tt_inpcvt (int32 c, uint32 mode)\r\n{\r\nuint32 md = mode & TTUF_M_MODE;\r\n\r\nif (md != TTUF_MODE_8B) {\r\n    uint32 par_mode = (mode >> TTUF_W_MODE) & TTUF_M_PAR;\r\n    static int32 nibble_even_parity = 0x699600;     /* bit array indicating the even parity for each index (offset by 8) */\r\n\r\n    c = c & 0177;\r\n    if (md == TTUF_MODE_UC) {\r\n        if (islower (c))\r\n            c = toupper (c);\r\n        if (mode & TTUF_KSR)\r\n            c = c | 0200;                           /* Force MARK parity */\r\n        }\r\n    switch (par_mode) {\r\n        case TTUF_PAR_EVEN:\r\n            c |= (((nibble_even_parity >> ((c & 0xF) + 1)) ^ (nibble_even_parity >> (((c >> 4) & 0xF) + 1))) & 0x80);\r\n            break;\r\n        case TTUF_PAR_ODD:\r\n            c |= ((~((nibble_even_parity >> ((c & 0xF) + 1)) ^ (nibble_even_parity >> (((c >> 4) & 0xF) + 1)))) & 0x80);\r\n            break;\r\n        case TTUF_PAR_MARK:\r\n            c = c | 0x80;\r\n            break;\r\n        }\r\n    }\r\nelse\r\n    c = c & 0377;\r\nreturn c;\r\n}\r\n\r\n/* Output character processing */\r\n\r\nint32 sim_tt_outcvt (int32 c, uint32 mode)\r\n{\r\nuint32 md = mode & TTUF_M_MODE;\r\n\r\nif (md != TTUF_MODE_8B) {\r\n    c = c & 0177;\r\n    if (md == TTUF_MODE_UC) {\r\n        if (islower (c))\r\n            c = toupper (c);\r\n        if ((mode & TTUF_KSR) && (c >= 0140))\r\n            return -1;\r\n        }\r\n    if (((md == TTUF_MODE_UC) || (md == TTUF_MODE_7P)) &&\r\n        ((c == 0177) ||\r\n         ((c < 040) && !((sim_tt_pchar >> c) & 1))))\r\n        return -1;\r\n    }\r\nelse c = c & 0377;\r\nreturn c;\r\n}\r\n\r\n/* Tab stop array handling\r\n\r\n   *desc points to a uint8 array of length val\r\n\r\n   Columns with tabs set are non-zero; columns without tabs are 0 */\r\n\r\nt_stat sim_tt_settabs (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nuint8 *temptabs, *tabs = (uint8 *) desc;\r\nint32 i, d;\r\nt_stat r;\r\nchar gbuf[CBUFSIZE];\r\n\r\nif ((cptr == NULL) || (tabs == NULL) || (val <= 1))\r\n    return SCPE_IERR;\r\nif (*cptr == 0)\r\n    return SCPE_2FARG;\r\nif ((temptabs = (uint8 *)malloc (val)) == NULL)\r\n    return SCPE_MEM;\r\nfor (i = 0; i < val; i++)\r\n    temptabs[i] = 0;\r\ndo {\r\n    cptr = get_glyph (cptr, gbuf, ';');\r\n    d = (int32)get_uint (gbuf, 10, val, &r);\r\n    if ((r != SCPE_OK) || (d == 0)) {\r\n        free (temptabs);\r\n        return SCPE_ARG;\r\n        }\r\n    temptabs[d - 1] = 1;\r\n    } while (*cptr != 0);\r\nfor (i = 0; i < val; i++)\r\n    tabs[i] = temptabs[i];\r\nfree (temptabs);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_tt_showtabs (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nconst uint8 *tabs = (const uint8 *) desc;\r\nint32 i, any;\r\n\r\nif ((st == NULL) || (val == 0) || (desc == NULL))\r\n    return SCPE_IERR;\r\nfor (i = any = 0; i < val; i++) {\r\n    if (tabs[i] != 0) {\r\n        fprintf (st, (any? \";%d\": \"%d\"), i + 1);\r\n        any = 1;\r\n        }\r\n    }\r\nfprintf (st, (any? \"\\n\": \"no tabs set\\n\"));\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_tt_set_mode (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nuint32 par_mode = (TT_GET_MODE (uptr->flags) >> TTUF_W_MODE) & TTUF_M_PAR;\r\n\r\nuptr->flags = uptr->flags & ~((TTUF_M_MODE << TTUF_V_MODE) | (TTUF_M_PAR << TTUF_V_PAR) | TTUF_KSR);\r\nuptr->flags |= val;\r\nif (val != TT_MODE_8B)\r\n    uptr->flags |= (par_mode << TTUF_V_PAR);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_tt_set_parity (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nuptr->flags = uptr->flags & ~(TTUF_M_MODE | TTUF_M_PAR);\r\nuptr->flags |= TT_MODE_7B | val;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_tt_show_modepar (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nuint32 md = (TT_GET_MODE (uptr->flags) & TTUF_M_MODE);\r\nstatic const char *modes[] = {\"7b\", \"8b\", \"UC\", \"7p\"};\r\nuint32 par_mode = (TT_GET_MODE (uptr->flags) >> TTUF_W_MODE) & TTUF_M_PAR;\r\nstatic const char *parity[] = {\"SPACE\", \"MARK\", \"EVEN\", \"ODD\"};\r\n\r\nif ((md == TTUF_MODE_UC) && (par_mode == TTUF_PAR_MARK))\r\n    fprintf (st, \"KSR (UC, MARK parity)\");\r\nelse\r\n    fprintf (st, \"%s\", modes[md]);\r\nif ((md != TTUF_MODE_8B) &&\r\n    ((md != TTUF_MODE_UC) || (par_mode != TTUF_PAR_MARK))) {\r\n    if (par_mode != 0)\r\n        fprintf (st, \", %s parity\", parity[par_mode]);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nt_stat sim_ttinit (void)\r\n{\r\nsim_con_tmxr.ldsc->mp = &sim_con_tmxr;\r\nsim_register_internal_device (&sim_con_telnet);\r\ntmxr_startup ();\r\nreturn sim_os_ttinit ();\r\n}\r\n\r\nt_stat sim_ttrun (void)\r\n{\r\nif (!sim_con_tmxr.ldsc->uptr)                           /* If simulator didn't declare its input polling unit */\r\n    sim_con_unit.dynflags &= ~UNIT_TM_POLL;             /* we can't poll asynchronously */\r\nreturn sim_os_ttrun ();\r\n}\r\n\r\nt_stat sim_ttcmd (void)\r\n{\r\nreturn sim_os_ttcmd ();\r\n}\r\n\r\nt_stat sim_ttclose (void)\r\n{\r\nt_stat r1 = tmxr_shutdown ();\r\nt_stat r2 = sim_os_ttclose ();\r\n\r\nif (r1 != SCPE_OK)\r\n    return r1;\r\nreturn r2;\r\n}\r\n\r\nt_bool sim_ttisatty (void)\r\n{\r\nstatic int answer = -1;\r\n\r\nif (answer == -1)\r\n    answer = sim_os_fd_isatty (0);\r\nreturn (t_bool)answer;\r\n}\r\n\r\nt_bool sim_fd_isatty (int fd)\r\n{\r\nreturn sim_os_fd_isatty (fd);\r\n}\r\n\r\n/* Platform specific routine definitions */\r\n\r\n/* VMS routines, from Ben Thomas, with fixes from Robert Alan Byer */\r\n\r\n#if defined (VMS)\r\n\r\n#if defined(__VAX)\r\n#define sys$assign SYS$ASSIGN\r\n#define sys$qiow SYS$QIOW\r\n#define sys$dassgn SYS$DASSGN\r\n#endif\r\n\r\n#include <descrip.h>\r\n#include <ttdef.h>\r\n#include <tt2def.h>\r\n#include <iodef.h>\r\n#include <ssdef.h>\r\n#include <starlet.h>\r\n#include <unistd.h>\r\n\r\n#define EFN 0\r\nuint32 tty_chan = 0;\r\nint buffered_character = 0;\r\n\r\ntypedef struct {\r\n    unsigned short sense_count;\r\n    unsigned char sense_first_char;\r\n    unsigned char sense_reserved;\r\n    unsigned int stat;\r\n    unsigned int stat2; } SENSE_BUF;\r\n\r\ntypedef struct {\r\n    unsigned short status;\r\n    unsigned short count;\r\n    unsigned int dev_status; } IOSB;\r\n\r\nSENSE_BUF cmd_mode = { 0 };\r\nSENSE_BUF run_mode = { 0 };\r\n\r\nstatic t_stat sim_os_ttinit (void)\r\n{\r\nunsigned int status;\r\nIOSB iosb;\r\n$DESCRIPTOR (terminal_device, \"tt\");\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttinit()\\n\");\r\n\r\nstatus = sys$assign (&terminal_device, &tty_chan, 0, 0);\r\nif (status != SS$_NORMAL)\r\n    return SCPE_TTIERR;\r\nstatus = sys$qiow (EFN, tty_chan, IO$_SENSEMODE, &iosb, 0, 0,\r\n    &cmd_mode, sizeof (cmd_mode), 0, 0, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return SCPE_TTIERR;\r\nrun_mode = cmd_mode;\r\nrun_mode.stat = cmd_mode.stat | TT$M_NOECHO & ~(TT$M_HOSTSYNC | TT$M_TTSYNC);\r\nrun_mode.stat2 = cmd_mode.stat2 | TT2$M_PASTHRU;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttrun (void)\r\n{\r\nunsigned int status;\r\nIOSB iosb;\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttrun()\\n\");\r\n\r\nstatus = sys$qiow (EFN, tty_chan, IO$_SETMODE, &iosb, 0, 0,\r\n    &run_mode, sizeof (run_mode), 0, 0, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return SCPE_TTIERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttcmd (void)\r\n{\r\nunsigned int status;\r\nIOSB iosb;\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttcmd() - BSDTTY\\n\");\r\n\r\nstatus = sys$qiow (EFN, tty_chan, IO$_SETMODE, &iosb, 0, 0,\r\n    &cmd_mode, sizeof (cmd_mode), 0, 0, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return SCPE_TTIERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttclose (void)\r\n{\r\nsim_ttcmd ();\r\nsys$dassgn (tty_chan);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_bool sim_os_fd_isatty (int fd)\r\n{\r\nreturn isatty (fd);\r\n}\r\n\r\nstatic t_stat sim_os_poll_kbd_data (void)\r\n{\r\nunsigned int status, term[2];\r\nunsigned char buf[4];\r\nIOSB iosb;\r\nSENSE_BUF sense;\r\n\r\nterm[0] = 0; term[1] = 0;\r\nstatus = sys$qiow (EFN, tty_chan, IO$_SENSEMODE | IO$M_TYPEAHDCNT, &iosb,\r\n    0, 0, &sense, 8, 0, term, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return SCPE_TTIERR;\r\nif (sense.sense_count == 0) return SCPE_OK;\r\nterm[0] = 0; term[1] = 0;\r\nstatus = sys$qiow (EFN, tty_chan,\r\n    IO$_READLBLK | IO$M_NOECHO | IO$M_NOFILTR | IO$M_TIMED | IO$M_TRMNOECHO,\r\n    &iosb, 0, 0, buf, 1, 0, term, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return SCPE_OK;\r\nif (buf[0] == sim_int_char)\r\n    return SCPE_STOP;\r\nif (sim_brk_char && (buf[0] == sim_brk_char))\r\n    return SCPE_BREAK;\r\nreturn (buf[0] | SCPE_KFLAG);\r\n}\r\n\r\nstatic t_stat sim_os_poll_kbd (void)\r\n{\r\nt_stat response;\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_poll_kbd()\\n\");\r\n\r\nif (response = buffered_character) {\r\n    buffered_character = 0;\r\n    return response;\r\n    }\r\nreturn sim_os_poll_kbd_data ();\r\n}\r\n\r\nstatic t_bool sim_os_poll_kbd_ready (int ms_timeout)\r\n{\r\nunsigned int status, term[2];\r\nunsigned char buf[4];\r\nIOSB iosb;\r\n\r\nterm[0] = 0; term[1] = 0;\r\nstatus = sys$qiow (EFN, tty_chan,\r\n    IO$_READLBLK | IO$M_NOECHO | IO$M_NOFILTR | IO$M_TIMED | IO$M_TRMNOECHO,\r\n    &iosb, 0, 0, buf, 1, (ms_timeout+999)/1000, term, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return FALSE;\r\nif (buf[0] == sim_int_char)\r\n    buffered_character = SCPE_STOP;\r\nelse\r\n    if (sim_brk_char && (buf[0] == sim_brk_char))\r\n        buffered_character = SCPE_BREAK;\r\n    else\r\n        buffered_character = (buf[0] | SCPE_KFLAG);\r\nreturn TRUE;\r\n}\r\n\r\n\r\nstatic t_stat sim_os_putchar (int32 out)\r\n{\r\nunsigned int status;\r\nchar c;\r\nIOSB iosb;\r\n\r\nc = out;\r\nstatus = sys$qiow (EFN, tty_chan, IO$_WRITELBLK | IO$M_NOFORMAT,\r\n    &iosb, 0, 0, &c, 1, 0, 0, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL))\r\n    return SCPE_TTOERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_connect_telnet (int port)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\n\r\n/* Win32 routines */\r\n\r\n#elif defined (_WIN32)\r\n\r\n#include <fcntl.h>\r\n#include <io.h>\r\n#define RAW_MODE 0\r\nstatic HANDLE std_input;\r\nstatic HANDLE std_output;\r\nstatic HANDLE std_error;\r\nstatic DWORD saved_input_mode;\r\nstatic DWORD saved_output_mode;\r\nstatic DWORD saved_error_mode;\r\n#ifndef ENABLE_VIRTUAL_TERMINAL_INPUT\r\n#define ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200\r\n#endif\r\n#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING\r\n#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004\r\n#endif\r\n\r\n/* Note: This routine catches all the potential events which some aspect\r\n         of the windows system can generate.  The CTRL_C_EVENT won't be\r\n         generated by a  user typing in a console session since that\r\n         session is in RAW mode.  In general, Ctrl-C on a simulator's\r\n         console terminal is a useful character to be passed to the\r\n         simulator.  This code does nothing to disable or affect that. */\r\n\r\n#include <signal.h>\r\n\r\nstatic BOOL WINAPI\r\nControlHandler(DWORD dwCtrlType)\r\n    {\r\n    DWORD Mode;\r\n    extern void int_handler (int sig);\r\n\r\n    switch (dwCtrlType)\r\n        {\r\n        case CTRL_BREAK_EVENT:      // Use CTRL-Break or CTRL-C to simulate\r\n        case CTRL_C_EVENT:          // SERVICE_CONTROL_STOP in debug mode\r\n            int_handler(SIGINT);\r\n            return TRUE;\r\n        case CTRL_CLOSE_EVENT:      // Window is Closing\r\n        case CTRL_LOGOFF_EVENT:     // User is logging off\r\n            if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &Mode))\r\n                return TRUE;        // Not our User, so ignore\r\n            /* fall through */\r\n        case CTRL_SHUTDOWN_EVENT:   // System is shutting down\r\n            int_handler(SIGTERM);\r\n            return TRUE;\r\n        }\r\n    return FALSE;\r\n    }\r\n\r\nstatic t_stat sim_os_ttinit (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttinit()\\n\");\r\n\r\nSetConsoleCtrlHandler( ControlHandler, TRUE );\r\nstd_input = GetStdHandle (STD_INPUT_HANDLE);\r\nstd_output = GetStdHandle (STD_OUTPUT_HANDLE);\r\nstd_error = GetStdHandle (STD_ERROR_HANDLE);\r\nif ((std_input) &&                                      /* Not Background process? */\r\n    (std_input != INVALID_HANDLE_VALUE))\r\n    GetConsoleMode (std_input, &saved_input_mode);      /* Save Input Mode */\r\nif ((std_output) &&                                     /* Not Background process? */\r\n    (std_output != INVALID_HANDLE_VALUE))\r\n    GetConsoleMode (std_output, &saved_output_mode);    /* Save Output Mode */\r\nif ((std_error) &&                                      /* Not Background process? */\r\n    (std_error != INVALID_HANDLE_VALUE))\r\n    GetConsoleMode (std_error, &saved_error_mode);      /* Save Output Mode */\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttrun (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttrun()\\n\");\r\n\r\nif ((sim_ttisatty ()) &&\r\n    (std_input) &&                                      /* If Not Background process? */\r\n    (std_input != INVALID_HANDLE_VALUE)) {\r\n    if (!GetConsoleMode(std_input, &saved_input_mode))\r\n        return sim_messagef (SCPE_TTYERR, \"GetConsoleMode() error: 0x%X\\n\", (unsigned int)GetLastError ());\r\n    if ((!SetConsoleMode(std_input, ENABLE_VIRTUAL_TERMINAL_INPUT)) &&\r\n        (!SetConsoleMode(std_input, RAW_MODE)))\r\n        return sim_messagef (SCPE_TTYERR, \"SetConsoleMode() error: 0x%X\\n\", (unsigned int)GetLastError ());\r\n    }\r\nif ((std_output) &&                                     /* If Not Background process? */\r\n    (std_output != INVALID_HANDLE_VALUE)) {\r\n    if (GetConsoleMode(std_output, &saved_output_mode))\r\n        if (!SetConsoleMode(std_output, ENABLE_VIRTUAL_TERMINAL_PROCESSING|ENABLE_PROCESSED_OUTPUT|ENABLE_WRAP_AT_EOL_OUTPUT))\r\n            SetConsoleMode(std_output, ENABLE_PROCESSED_OUTPUT|ENABLE_WRAP_AT_EOL_OUTPUT);\r\n    }\r\nif (sim_log) {\r\n    fflush (sim_log);\r\n    _setmode (_fileno (sim_log), _O_BINARY);\r\n    }\r\nsim_os_set_thread_priority (PRIORITY_BELOW_NORMAL);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttcmd (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttcmd() - BSDTTY\\n\");\r\n\r\nif (sim_log) {\r\n    fflush (sim_log);\r\n    _setmode (_fileno (sim_log), _O_TEXT);\r\n    }\r\nsim_os_set_thread_priority (PRIORITY_NORMAL);\r\nif ((sim_ttisatty ()) &&\r\n    (std_input) &&                                      /* If Not Background process? */\r\n    (std_input != INVALID_HANDLE_VALUE) &&\r\n    (!SetConsoleMode(std_input, saved_input_mode)))     /* Restore Normal mode */\r\n    return SCPE_TTYERR;\r\nif ((std_output) &&                                     /* If Not Background process? */\r\n    (std_output != INVALID_HANDLE_VALUE) &&\r\n    (!SetConsoleMode(std_output, saved_output_mode)))   /* Restore Normal mode */\r\n    return SCPE_TTYERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttclose (void)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_bool sim_os_fd_isatty (int fd)\r\n{\r\nDWORD Mode;\r\nHANDLE handle;\r\n\r\nswitch (fd) {\r\n    case 0:\r\n        handle = std_input;\r\n        break;\r\n    case 1:\r\n        handle = std_output;\r\n        break;\r\n    case 2:\r\n        handle = std_error;\r\n        break;\r\n    default:\r\n        handle = NULL;\r\n    }\r\n\r\nreturn (handle) && (handle != INVALID_HANDLE_VALUE) && GetConsoleMode (handle, &Mode);\r\n}\r\n\r\nstatic t_stat sim_os_poll_kbd (void)\r\n{\r\nint c = -1;\r\nDWORD nkbevents, nkbevent;\r\nINPUT_RECORD rec;\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_poll_kbd()\\n\");\r\n\r\nif ((std_input == NULL) ||                              /* No keyboard for */\r\n    (std_input == INVALID_HANDLE_VALUE))                /* background processes */\r\n    return SCPE_OK;\r\nif (!GetNumberOfConsoleInputEvents(std_input, &nkbevents))\r\n    return SCPE_TTYERR;\r\nwhile (c == -1) {\r\n    if (0 == nkbevents)\r\n        return SCPE_OK;\r\n    if (!ReadConsoleInput(std_input, &rec, 1, &nkbevent))\r\n        return SCPE_TTYERR;\r\n    if (0 == nkbevent)\r\n        return SCPE_OK;\r\n    --nkbevents;\r\n    if (rec.EventType == KEY_EVENT) {\r\n        if (rec.Event.KeyEvent.bKeyDown) {\r\n            if (0 == rec.Event.KeyEvent.uChar.UnicodeChar) {     /* Special Character/Keys? */\r\n                if (rec.Event.KeyEvent.wVirtualKeyCode == VK_PAUSE) /* Pause/Break Key */\r\n                    c = sim_brk_char | SCPE_BREAK;\r\n                else\r\n                    if (rec.Event.KeyEvent.wVirtualKeyCode == '2')  /* ^@ */\r\n                        c = 0;                                      /* return NUL */\r\n            } else\r\n                c = rec.Event.KeyEvent.uChar.AsciiChar;\r\n            }\r\n      }\r\n    }\r\nif ((c & 0177) == sim_del_char)\r\n    c = 0177;\r\nif ((c & 0177) == sim_int_char)\r\n    return SCPE_STOP;\r\nif ((sim_brk_char && ((c & 0177) == sim_brk_char)) || (c & SCPE_BREAK))\r\n    return SCPE_BREAK;\r\nreturn c | SCPE_KFLAG;\r\n}\r\n\r\nstatic t_bool sim_os_poll_kbd_ready (int ms_timeout)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_poll_kbd_ready()\\n\");\r\nif ((std_input == NULL) ||                              /* No keyboard for */\r\n    (std_input == INVALID_HANDLE_VALUE)) {              /* background processes */\r\n    Sleep (ms_timeout);\r\n    return FALSE;\r\n    }\r\nreturn (WAIT_OBJECT_0 == WaitForSingleObject (std_input, ms_timeout));\r\n}\r\n\r\n\r\n#define BELL_CHAR           7       /* Bell Character */\r\n#define BELL_INTERVAL_MS    500     /* No more than 2 Bell Characters Per Second */\r\n#define ESC_CHAR            033     /* Escape Character */\r\n#define CSI_CHAR            0233    /* Control Sequence Introducer */\r\n#define NUL_CHAR            0000    /* NUL character */\r\n#define ESC_HOLD_USEC_DELAY 8000    /* Escape hold interval */\r\n#define ESC_HOLD_MAX        32      /* Maximum Escape hold buffer */\r\n\r\nstatic uint8 out_buf[ESC_HOLD_MAX]; /* Buffered characters pending output */\r\nstatic int32 out_ptr = 0;\r\n\r\nstatic t_stat sim_out_hold_svc (UNIT *uptr)\r\n{\r\nDWORD unused;\r\n\r\nWriteConsoleA(std_output, out_buf, out_ptr, &unused, NULL);\r\nout_ptr = 0;\r\nreturn SCPE_OK;\r\n}\r\n\r\n#define out_hold_unit sim_con_units[1]\r\n\r\nstatic t_stat sim_os_putchar (int32 c)\r\n{\r\nDWORD unused;\r\nuint32 now;\r\nstatic uint32 last_bell_time;\r\n\r\nif (c != 0177) {\r\n    switch (c) {\r\n        case BELL_CHAR:\r\n            now = sim_os_msec ();\r\n            if ((now - last_bell_time) > BELL_INTERVAL_MS) {\r\n                WriteConsoleA(std_output, &c, 1, &unused, NULL);\r\n                last_bell_time = now;\r\n                }\r\n            break;\r\n        case NUL_CHAR:\r\n            break;\r\n        case CSI_CHAR:\r\n        case ESC_CHAR:\r\n            if (out_ptr) {\r\n                WriteConsoleA(std_output, out_buf, out_ptr, &unused, NULL);\r\n                out_ptr = 0;\r\n                sim_cancel (&out_hold_unit);\r\n                }\r\n            out_buf[out_ptr++] = (uint8)c;\r\n            sim_activate_after (&out_hold_unit, ESC_HOLD_USEC_DELAY);\r\n            out_hold_unit.action = &sim_out_hold_svc;\r\n            break;\r\n        default:\r\n            if (out_ptr) {\r\n                if (out_ptr >= ESC_HOLD_MAX) {              /* Stop buffering if full */\r\n                    WriteConsoleA(std_output, out_buf, out_ptr, &unused, NULL);\r\n                    out_ptr = 0;\r\n                    WriteConsoleA(std_output, &c, 1, &unused, NULL);\r\n                    }\r\n                else\r\n                    out_buf[out_ptr++] = (uint8)c;\r\n                }\r\n            else\r\n                WriteConsoleA(std_output, &c, 1, &unused, NULL);\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_connect_telnet (int port)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nconst char *program = sim_get_tool_path (\"PuTTY\");\r\n\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"start PuTTY telnet://localhost:%d\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nsnprintf (gbuf, sizeof (gbuf), \"%s;%s\\\\PuTTY;%s\\\\PuTTY\", getenv (\"PATH\"), getenv (\"ProgramFiles\"), getenv (\"ProgramFiles(x86)\"));\r\nsetenv(\"PATH\", gbuf, 1);\r\nprogram = sim_get_tool_path (\"PuTTY\");\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"start PuTTY telnet://localhost:%d\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nprogram = sim_get_tool_path (\"telnet\");\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"start telnet localhost:%d\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nreturn sim_messagef (SCPE_NOFNC, \"Can't find a telnet program to connect to the console in a window\\n\");\r\n}\r\n\r\n/* BSD UNIX routines */\r\n\r\n#elif defined (BSDTTY)\r\n\r\n#include <sgtty.h>\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n\r\n#if (!defined(O_NONBLOCK)) && defined(O_NDELAY)\r\n#define O_NONBLOCK O_NDELAY\r\n#else\r\n#if !defined(O_NONBLOCK)\r\n#define O_NONBLOCK FNDELAY\r\n#endif\r\n#endif\r\n\r\nstruct sgttyb cmdtty,runtty;                            /* V6/V7 stty data */\r\nstruct tchars cmdtchars,runtchars;                      /* V7 editing */\r\nstruct ltchars cmdltchars,runltchars;                   /* 4.2 BSD editing */\r\nint cmdfl,runfl;                                        /* TTY flags */\r\n\r\nstatic t_stat sim_os_ttinit (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttinit() - BSDTTY\\n\");\r\n\r\ncmdfl = fcntl (fileno (stdin), F_GETFL, 0);             /* get old flags  and status */\r\nrunfl = cmdfl | O_NONBLOCK;\r\nif (ioctl (0, TIOCGETP, &cmdtty) < 0)\r\n    return SCPE_TTIERR;\r\nif (ioctl (0, TIOCGETC, &cmdtchars) < 0)\r\n    return SCPE_TTIERR;\r\nif (ioctl (0, TIOCGLTC, &cmdltchars) < 0)\r\n    return SCPE_TTIERR;\r\nruntty = cmdtty;                                        /* initial run state */\r\nruntty.sg_flags = cmdtty.sg_flags & ~(ECHO|CRMOD) | CBREAK;\r\nruntchars.t_intrc = sim_int_char;                       /* interrupt */\r\nruntchars.t_quitc = 0xFF;                               /* no quit */\r\nruntchars.t_startc = 0xFF;                              /* no host sync */\r\nruntchars.t_stopc = 0xFF;\r\nruntchars.t_eofc = 0xFF;\r\nruntchars.t_brkc = 0xFF;\r\nrunltchars.t_suspc = 0xFF;                              /* no specials of any kind */\r\nrunltchars.t_dsuspc = 0xFF;\r\nrunltchars.t_rprntc = 0xFF;\r\nrunltchars.t_flushc = 0xFF;\r\nrunltchars.t_werasc = 0xFF;\r\nrunltchars.t_lnextc = 0xFF;\r\nreturn SCPE_OK;                                         /* return success */\r\n}\r\n\r\nstatic t_stat sim_os_ttrun (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttrun() - BSDTTY\\n\");\r\n\r\n#if (defined(__GNUC__) && !defined(__OPTIMIZE__))       /* Debug build? */\r\nif (sim_dbg_int_char == 0)\r\n    sim_dbg_int_char = sim_int_char + 1;\r\nruntchars.t_intrc = sim_dbg_int_char;                   /* let debugger get SIGINT with next highest char */\r\nif (!sigint_message_issued) {\r\n    char sigint_name[8];\r\n\r\n    if (isprint(sim_dbg_int_char&0xFF))\r\n        sprintf(sigint_name, \"'%c'\", sim_dbg_int_char&0xFF);\r\n    else\r\n        if (sim_dbg_int_char <= 26)\r\n            sprintf(sigint_name, \"^%c\", '@' + (sim_dbg_int_char&0xFF));\r\n        else\r\n            sprintf(sigint_name, \"'\\\\%03o'\", sim_dbg_int_char&0xFF);\r\n    sigint_message_issued = TRUE;\r\n    sim_messagef (SCPE_OK, \"SIGINT will be delivered to your debugger when the %s character is entered\\n\", sigint_name);\r\n    }\r\n#else\r\nruntchars.t_intrc = sim_int_char;                       /* in case changed */\r\n#endif\r\nfcntl (0, F_SETFL, runfl);                              /* non-block mode */\r\nif (ioctl (0, TIOCSETP, &runtty) < 0)\r\n    return SCPE_TTIERR;\r\nif (ioctl (0, TIOCSETC, &runtchars) < 0)\r\n    return SCPE_TTIERR;\r\nif (ioctl (0, TIOCSLTC, &runltchars) < 0)\r\n    return SCPE_TTIERR;\r\nsim_os_set_thread_priority (PRIORITY_BELOW_NORMAL)l     /* lower priority */\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttcmd (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttcmd() - BSDTTY\\n\");\r\n\r\nsim_os_set_thread_priority (PRIORITY_NORMAL);           /* restore priority */\r\nfcntl (0, F_SETFL, cmdfl);                              /* block mode */\r\nif (ioctl (0, TIOCSETP, &cmdtty) < 0)\r\n    return SCPE_TTIERR;\r\nif (ioctl (0, TIOCSETC, &cmdtchars) < 0)\r\n    return SCPE_TTIERR;\r\nif (ioctl (0, TIOCSLTC, &cmdltchars) < 0)\r\n    return SCPE_TTIERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttclose (void)\r\n{\r\nreturn sim_ttcmd ();\r\n}\r\n\r\nstatic t_bool sim_os_fd_isatty (int fd)\r\n{\r\nreturn isatty (fd);\r\n}\r\n\r\nstatic t_stat sim_os_poll_kbd (void)\r\n{\r\nint status;\r\nunsigned char buf[1];\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_poll_kbd() - BSDTTY\\n\");\r\n\r\nstatus = read (0, buf, 1);\r\nif (status != 1)\r\n    return SCPE_OK;\r\nif (sim_brk_char && (buf[0] == sim_brk_char))\r\n    return SCPE_BREAK;\r\nif (sim_int_char && (buf[0] == sim_int_char))\r\n    return SCPE_STOP;\r\nreturn (buf[0] | SCPE_KFLAG);\r\n}\r\n\r\nstatic t_bool sim_os_poll_kbd_ready (int ms_timeout)\r\n{\r\nfd_set readfds;\r\nstruct timeval timeout;\r\n\r\nif (!isatty (0)) {                           /* skip if !tty */\r\n    sim_os_ms_sleep (ms_timeout);\r\n    return FALSE;\r\n    }\r\nFD_ZERO (&readfds);\r\nFD_SET (0, &readfds);\r\ntimeout.tv_sec = (ms_timeout*1000)/1000000;\r\ntimeout.tv_usec = (ms_timeout*1000)%1000000;\r\nreturn (1 == select (1, &readfds, NULL, NULL, &timeout));\r\n}\r\n\r\nstatic t_stat sim_os_putchar (int32 out)\r\n{\r\nchar c;\r\n\r\nc = out;\r\nwrite (1, &c, 1);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_connect_telnet (int port)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\n/* POSIX UNIX routines, from Leendert Van Doorn */\r\n\r\n#else\r\n\r\n#if !defined (__ANDROID_API__) || (__ANDROID_API__ < 26)\r\n#define TCSETATTR_ACTION TCSAFLUSH\r\n#else\r\n#define TCSETATTR_ACTION TCSANOW\r\n#endif\r\n\r\n#include <termios.h>\r\n#include <unistd.h>\r\n\r\nstruct termios cmdtty, runtty;\r\nint cmdfl,runfl;                                        /* TTY flags */\r\n\r\nstatic t_stat sim_os_ttinit (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttinit()\\n\");\r\n\r\ncmdfl = fcntl (fileno (stdin), F_GETFL, 0);             /* get old flags  and status */\r\n/*\r\n * make sure systems with broken termios (that don't honor\r\n * VMIN=0 and VTIME=0) actually implement non blocking reads.\r\n * This will have no negative effect on other systems since\r\n * this is turned on and off depending on whether simulation\r\n * is running or not.\r\n */\r\nrunfl = cmdfl | O_NONBLOCK;\r\nif (!isatty (fileno (stdin)))                           /* skip if !tty */\r\n    return SCPE_OK;\r\nif (tcgetattr (0, &cmdtty) < 0)                         /* get old flags */\r\n    return SCPE_TTIERR;\r\nruntty = cmdtty;\r\nruntty.c_lflag = runtty.c_lflag & ~(ECHO | ICANON);     /* no echo or edit */\r\nruntty.c_oflag = runtty.c_oflag & ~OPOST;               /* no output edit */\r\nruntty.c_iflag = runtty.c_iflag & ~ICRNL;               /* no cr conversion */\r\n#if defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL)\r\nruntty.c_cc[VINTR] = 0;                                 /* OS X doesn't deliver SIGINT to main thread when enabled */\r\n#else\r\nruntty.c_cc[VINTR] = sim_int_char;                      /* interrupt */\r\n#endif\r\nruntty.c_cc[VQUIT] = 0;                                 /* no quit */\r\nruntty.c_cc[VERASE] = 0;\r\nruntty.c_cc[VKILL] = 0;\r\nruntty.c_cc[VEOF] = 0;\r\nruntty.c_cc[VEOL] = 0;\r\nruntty.c_cc[VSTART] = 0;                                /* no host sync */\r\nruntty.c_cc[VSUSP] = 0;\r\nruntty.c_cc[VSTOP] = 0;\r\n#if defined (VREPRINT)\r\nruntty.c_cc[VREPRINT] = 0;                              /* no specials */\r\n#endif\r\n#if defined (VDISCARD)\r\nruntty.c_cc[VDISCARD] = 0;\r\n#endif\r\n#if defined (VWERASE)\r\nruntty.c_cc[VWERASE] = 0;\r\n#endif\r\n#if defined (VLNEXT)\r\nruntty.c_cc[VLNEXT] = 0;\r\n#endif\r\nruntty.c_cc[VMIN] = 0;                                  /* no waiting */\r\nruntty.c_cc[VTIME] = 0;\r\n#if defined (VDSUSP)\r\nruntty.c_cc[VDSUSP] = 0;\r\n#endif\r\n#if defined (VSTATUS)\r\nruntty.c_cc[VSTATUS] = 0;\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttrun (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttrun()\\n\");\r\n\r\nif (!isatty (fileno (stdin)))                           /* skip if !tty */\r\n    return SCPE_OK;\r\n(void)fcntl (fileno (stdin), F_SETFL, runfl);           /* non-block mode */\r\n#if defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL)\r\nruntty.c_cc[VINTR] = 0;                                 /* OS X doesn't deliver SIGINT to main thread when enabled */\r\n#else\r\nruntty.c_cc[VINTR] = sim_int_char;                      /* in case changed */\r\n#endif\r\n#if (defined(__GNUC__) && !defined(__OPTIMIZE__))       /* Debug build? */\r\nif (sim_dbg_int_char == 0)\r\n    sim_dbg_int_char = sim_int_char + 1;\r\nruntty.c_cc[VINTR] = sim_dbg_int_char;                  /* let debugger get SIGINT with next highest char */\r\nif (!sigint_message_issued) {\r\n    char sigint_name[8];\r\n\r\n    if (isprint(sim_dbg_int_char&0xFF))\r\n        sprintf(sigint_name, \"'%c'\", sim_dbg_int_char&0xFF);\r\n    else\r\n        if (sim_dbg_int_char <= 26)\r\n            sprintf(sigint_name, \"^%c\", '@' + (sim_dbg_int_char&0xFF));\r\n        else\r\n            sprintf(sigint_name, \"'\\\\%03o'\", sim_dbg_int_char&0xFF);\r\n    sigint_message_issued = TRUE;\r\n    sim_messagef (SCPE_OK, \"SIGINT will be delivered to your debugger when the %s character is entered\\n\", sigint_name);\r\n    }\r\n#endif\r\nif (tcsetattr (fileno(stdin), TCSETATTR_ACTION, &runtty) < 0)\r\n    return SCPE_TTIERR;\r\nsim_os_set_thread_priority (PRIORITY_BELOW_NORMAL);     /* try to lower pri */\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttcmd (void)\r\n{\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_ttcmd() - BSDTTY\\n\");\r\n\r\nif (!isatty (fileno (stdin)))                           /* skip if !tty */\r\n    return SCPE_OK;\r\nsim_os_set_thread_priority (PRIORITY_NORMAL);           /* try to raise pri */\r\n(void)fcntl (0, F_SETFL, cmdfl);                        /* block mode */\r\nif (tcsetattr (fileno(stdin), TCSETATTR_ACTION, &cmdtty) < 0)\r\n    return SCPE_TTIERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_ttclose (void)\r\n{\r\nreturn sim_ttcmd ();\r\n}\r\n\r\nstatic t_bool sim_os_fd_isatty (int fd)\r\n{\r\nreturn isatty (fd);\r\n}\r\n\r\nstatic t_stat sim_os_poll_kbd (void)\r\n{\r\nint status;\r\nunsigned char buf[1];\r\n\r\nsim_debug (DBG_TRC, &sim_con_telnet, \"sim_os_poll_kbd()\\n\");\r\n\r\nstatus = read (0, buf, 1);\r\nif (status != 1)\r\n    return SCPE_OK;\r\nif (sim_brk_char && (buf[0] == sim_brk_char))\r\n    return SCPE_BREAK;\r\nif (sim_int_char && (buf[0] == sim_int_char))\r\n    return SCPE_STOP;\r\nreturn (buf[0] | SCPE_KFLAG);\r\n}\r\n\r\nstatic t_bool sim_os_poll_kbd_ready (int ms_timeout)\r\n{\r\nfd_set readfds;\r\nstruct timeval timeout;\r\n\r\nif (!sim_ttisatty()) {                      /* skip if !tty */\r\n    sim_os_ms_sleep (ms_timeout);\r\n    return FALSE;\r\n    }\r\nFD_ZERO (&readfds);\r\nFD_SET (0, &readfds);\r\ntimeout.tv_sec = (ms_timeout*1000)/1000000;\r\ntimeout.tv_usec = (ms_timeout*1000)%1000000;\r\nreturn (1 == select (1, &readfds, NULL, NULL, &timeout));\r\n}\r\n\r\nstatic t_stat sim_os_putchar (int32 out)\r\n{\r\nchar c;\r\n\r\nc = out;\r\nif (write (1, &c, 1)) {};\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_connect_telnet (int port)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nconst char *program = sim_get_tool_path (\"osascript\");\r\n\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"osascript -e 'tell application \\\"Terminal\\\" to do script \\\"telnet localhost %d; exit\\\"'\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nprogram = sim_get_tool_path (\"putty\");\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"nohup putty telnet://localhost:%d' 2>/dev/null&\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nprogram = sim_get_tool_path (\"gnome-terminal\");\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"nohup gnome-terminal -- telnet localhost %d' 2>/dev/null&\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nprogram = sim_get_tool_path (\"uxterm\");\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"nohup uxterm -e 'telnet localhost %d' 2>/dev/null&\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nprogram = sim_get_tool_path (\"xterm\");\r\nif (program[0] != '\\0') {\r\n    snprintf (gbuf, sizeof (gbuf), \"nohup xterm -e 'telnet localhost %d' 2>/dev/null&\", port);\r\n    return spawn_cmd (0, gbuf);\r\n    }\r\nreturn sim_messagef (SCPE_NOFNC, \"Can't find a telnet program to connect to the console in a window\\n\");\r\n}\r\n\r\n#endif\r\n\r\n/* Decode a string.\r\n\r\n   A string containing encoded control characters is decoded into the equivalent\r\n   character string.  Escape targets @, A-Z, and [\\]^_ form control characters\r\n   000-037.\r\n*/\r\n#define ESCAPE_CHAR '~'\r\n\r\nstatic void decode (char *decoded, const char *encoded)\r\n{\r\nchar c;\r\n\r\nwhile ((c = *decoded++ = *encoded++))                   /* copy the character */\r\n    if (c == ESCAPE_CHAR) {                             /* does it start an escape? */\r\n        if ((isalpha (*encoded)) ||                     /* is next character \"A-Z\" or \"a-z\"? */\r\n            (*encoded == '@') ||                        /*   or \"@\"? */\r\n            ((*encoded >= '[') && (*encoded <= '_')))   /*   or \"[\\]^_\"? */\r\n\r\n            *(decoded - 1) = *encoded++ & 037;          /* convert back to control character */\r\n        else {\r\n            if ((*encoded == '\\0') ||                   /* single escape character at EOL? */\r\n                 (*encoded++ != ESCAPE_CHAR))           /*   or not followed by another escape? */\r\n                decoded--;                              /* drop the encoding */\r\n            }\r\n        }\r\nreturn;\r\n}\r\n\r\n/* Set console halt */\r\n\r\nstatic t_stat sim_set_halt (int32 flag, CONST char *cptr)\r\n{\r\nif (flag == 0)                                              /* no halt? */\r\n    sim_exp_clrall (&sim_con_expect);                       /* disable halt checks */\r\nelse {\r\n    char *mbuf;\r\n    char *mbuf2;\r\n\r\n    if (cptr == NULL || *cptr == 0)                         /* no match string? */\r\n        return SCPE_2FARG;                                  /* need an argument */\r\n\r\n    sim_exp_clrall (&sim_con_expect);                       /* make sure that none currently exist */\r\n\r\n    mbuf = (char *)malloc (1 + strlen (cptr));\r\n    decode (mbuf, cptr);                                    /* save decoded match string */\r\n\r\n    mbuf2 = (char *)malloc (3 + strlen(cptr));\r\n    sprintf (mbuf2, \"%s%s%s\", (sim_switches & SWMASK ('A')) ? \"\\n\" : \"\",\r\n                              mbuf,\r\n                              (sim_switches & SWMASK ('I')) ? \"\" : \"\\n\");\r\n    free (mbuf);\r\n    mbuf = sim_encode_quoted_string ((uint8 *)mbuf2, strlen (mbuf2));\r\n    sim_switches = EXP_TYP_PERSIST;\r\n    sim_set_expect (&sim_con_expect, mbuf);\r\n    free (mbuf);\r\n    free (mbuf2);\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Set console response */\r\n\r\nstatic t_stat sim_set_response (int32 flag, CONST char *cptr)\r\n{\r\nif (flag == 0)                                          /* no response? */\r\n    sim_send_clear (&sim_con_send);\r\nelse {\r\n    uint8 *rbuf;\r\n\r\n    if (cptr == NULL || *cptr == 0)\r\n        return SCPE_2FARG;                              /* need arg */\r\n\r\n    rbuf = (uint8 *)malloc (1 + strlen(cptr));\r\n\r\n    decode ((char *)rbuf, cptr);                        /* decode string */\r\n    sim_send_input (&sim_con_send, rbuf, strlen((char *)rbuf), 0, 0); /* queue it for output */\r\n    free (rbuf);\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set console delay */\r\n\r\nstatic t_stat sim_set_delay (int32 flag, CONST char *cptr)\r\n{\r\nint32 val;\r\nt_stat r;\r\n\r\nif (cptr == NULL || *cptr == 0)                         /* no argument string? */\r\n    return SCPE_2FARG;                                  /* need an argument */\r\n\r\nval = (int32) get_uint (cptr, 10, INT_MAX, &r);         /* parse the argument */\r\nif (r == SCPE_OK) {                                     /* parse OK? */\r\n    char gbuf[CBUFSIZE];\r\n\r\n    snprintf (gbuf, sizeof (gbuf), \"HALTAFTER=%d\", val);\r\n    expect_cmd (1, gbuf);\r\n    }\r\n\r\nreturn r;\r\n}\r\n"
        },
        {
          "name": "sim_console.h",
          "type": "blob",
          "size": 7.484375,
          "content": "/* sim_console.h: simulator console I/O library headers\r\n\r\n   Copyright (c) 1993-2014, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   02-Jan-14    RMS     Added tab stop routines\r\n   17-Jan-11    MP      Added buffered line capabilities\r\n   22-Jun-06    RMS     Implemented SET/SHOW PCHAR\r\n   22-Nov-05    RMS     Added central input/output conversion support\r\n   05-Nov-04    RMS     Moved SET/SHOW DEBUG under CONSOLE hierarchy\r\n   28-May-04    RMS     Added SET/SHOW CONSOLE\r\n   02-Jan-04    RMS     Removed timer routines, added Telnet console routines\r\n*/\r\n\r\n#ifndef SIM_CONSOLE_H_\r\n#define SIM_CONSOLE_H_ 0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#define TTUF_V_MODE     (UNIT_V_UF + 0)\r\n#define TTUF_W_MODE     2\r\n#define  TTUF_MODE_7B   0\r\n#define  TTUF_MODE_8B   1\r\n#define  TTUF_MODE_UC   2\r\n#define  TTUF_MODE_7P   3\r\n#define TTUF_M_MODE     ((1u << TTUF_W_MODE) - 1)\r\n#define TTUF_V_PAR      (TTUF_V_MODE + TTUF_W_MODE)\r\n#define TTUF_W_PAR      2\r\n#define  TTUF_PAR_SPACE 0\r\n#define  TTUF_PAR_MARK  1\r\n#define  TTUF_PAR_EVEN  2\r\n#define  TTUF_PAR_ODD   3\r\n#define TTUF_M_PAR      ((1u << TTUF_W_PAR) - 1)\r\n#define  TTUF_KSR       (1u << (TTUF_W_MODE + TTUF_W_PAR))\r\n#define TTUF_V_UF       (TTUF_V_MODE + TTUF_W_MODE + TTUF_W_PAR)\r\n#define TT_MODE         (TTUF_M_MODE << TTUF_V_MODE)\r\n#define  TT_MODE_7B     (TTUF_MODE_7B << TTUF_V_MODE)\r\n#define  TT_MODE_8B     (TTUF_MODE_8B << TTUF_V_MODE)\r\n#define  TT_MODE_UC     (TTUF_MODE_UC << TTUF_V_MODE)\r\n#define  TT_MODE_7P     (TTUF_MODE_7P << TTUF_V_MODE)\r\n#define  TT_MODE_KSR    (TT_MODE_UC|TT_PAR_MARK)\r\n/* 7 bit modes allow for an 8th bit parity mode */\r\n#define TT_PAR          (TTUF_M_PAR << TTUF_V_PAR)\r\n#define  TT_PAR_SPACE   (TTUF_PAR_SPACE << TTUF_V_PAR)\r\n#define  TT_PAR_MARK    (TTUF_PAR_MARK  << TTUF_V_PAR)\r\n#define  TT_PAR_EVEN    (TTUF_PAR_EVEN  << TTUF_V_PAR)\r\n#define  TT_PAR_ODD     (TTUF_PAR_ODD   << TTUF_V_PAR)\r\n/* TT_GET_MODE returns both the TT_MODE and TT_PAR fields \r\n   since they together are passed into sim_tt_inpcvt() */\r\n#define TT_GET_MODE(x)  (((x) >> TTUF_V_MODE) & (TTUF_M_MODE | (TTUF_M_PAR << TTUF_W_MODE)))\r\n\r\nt_stat sim_set_console (int32 flag, CONST char *cptr);\r\nt_stat sim_set_remote_console (int32 flag, CONST char *cptr);\r\nvoid sim_remote_process_command (void);\r\nt_stat sim_set_kmap (int32 flag, CONST char *cptr);\r\nt_stat sim_set_telnet (int32 flag, CONST char *cptr);\r\nt_stat sim_set_notelnet (int32 flag, CONST char *cptr);\r\nt_stat sim_set_serial (int32 flag, CONST char *cptr);\r\nt_stat sim_set_noserial (int32 flag, CONST char *cptr);\r\nt_stat sim_set_logon (int32 flag, CONST char *cptr);\r\nt_stat sim_set_logoff (int32 flag, CONST char *cptr);\r\nint32 sim_set_deb_switches (int32 switches);\r\nt_stat sim_set_debon (int32 flag, CONST char *cptr);\r\nt_stat sim_set_cons_debug (int32 flg, CONST char *cptr);\r\nt_stat sim_set_cons_buff (int32 flg, CONST char *cptr);\r\nt_stat sim_set_cons_unbuff (int32 flg, CONST char *cptr);\r\nt_stat sim_set_cons_log (int32 flg, CONST char *cptr);\r\nt_stat sim_set_cons_nolog (int32 flg, CONST char *cptr);\r\nt_stat sim_set_cons_connect (int32 flg, CONST char *cptr);\r\nt_stat sim_set_deboff (int32 flag, CONST char *cptr);\r\nt_stat sim_set_cons_expect (int32 flg, CONST char *cptr);\r\nt_stat sim_set_cons_noexpect (int32 flg, CONST char *cptr);\r\nt_stat sim_set_pchar (int32 flag, CONST char *cptr);\r\nt_stat sim_set_cons_speed (int32 flag, CONST char *cptr);\r\nt_stat sim_show_console (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_remote_console (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_kmap (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_telnet (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_log (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_debug (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_pchar (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_cons_speed (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_cons_buff (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_cons_log (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_cons_debug (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_show_cons_expect (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_check_console (int32 sec);\r\nt_stat sim_open_logfile (const char *filename, t_bool binary, FILE **pf, FILEREF **pref);\r\nt_stat sim_close_logfile (FILEREF **pref);\r\nconst char *sim_logfile_name (FILE *st, FILEREF *ref);\r\nSEND *sim_cons_get_send (void);\r\nEXPECT *sim_cons_get_expect (void);\r\nt_stat sim_show_cons_send_input (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_stat sim_set_noconsole_port (void);\r\nt_stat sim_set_stable_registers_state (void);\r\nt_stat sim_poll_kbd (void);\r\nt_stat sim_putchar (int32 c);\r\nt_stat sim_putchar_s (int32 c);\r\nt_stat sim_ttinit (void);\r\nt_stat sim_ttrun (void);\r\nt_stat sim_ttcmd (void);\r\nt_stat sim_ttclose (void);\r\nt_bool sim_ttisatty (void);\r\nt_bool sim_fd_isatty (int fd);\r\nint32 sim_tt_inpcvt (int32 c, uint32 mode);\r\nint32 sim_tt_outcvt (int32 c, uint32 mode);\r\nt_stat sim_tt_set_mode (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_tt_set_parity (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_tt_show_modepar (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_tt_settabs (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_tt_showtabs (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_bool sim_is_remote_console_master_line (void *lp);\r\n\r\nextern int32 sim_rem_cmd_active_line;   /* command in progress on line # */\r\n\r\nextern int32 sim_int_char;              /* interrupt character */\r\nextern int32 sim_brk_char;              /* break character */\r\nextern int32 sim_tt_pchar;              /* printable character mask */\r\nextern int32 sim_del_char;              /* delete character */\r\nextern t_bool sim_signaled_int_char;    /* WRU character detected by signal while running  */\r\nextern uint32 sim_last_poll_kbd_time;   /* time when sim_poll_kbd was called */\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_defs.h",
          "type": "blob",
          "size": 55.8857421875,
          "content": "/* sim_defs.h: simulator definitions\r\n\r\n   Copyright (c) 1993-2016, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   25-Sep-16    RMS     Removed KBD_WAIT and friends\r\n   08-Mar-16    RMS     Added shutdown invisible switch\r\n   24-Dec-14    JDB     Added T_ADDR_FMT\r\n   05-Jan-11    MP      Added Asynch I/O support\r\n   18-Jan-11    MP      Added log file reference count support\r\n   21-Jul-08    RMS     Removed inlining support\r\n   28-May-08    RMS     Added inlining support\r\n   28-Jun-07    RMS     Added IA64 VMS support (from Norm Lastovica)\r\n   18-Jun-07    RMS     Added UNIT_IDLE flag\r\n   18-Mar-07    RMS     Added UNIT_TEXT flag\r\n   07-Mar-07    JDB     Added DEBUG_PRJ macro\r\n   18-Oct-06    RMS     Added limit check for clock synchronized keyboard waits\r\n   13-Jul-06    RMS     Guarantee CBUFSIZE is at least 256\r\n   07-Jan-06    RMS     Added support for breakpoint spaces\r\n                        Added REG_FIT flag\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   11-Mar-05    RMS     Moved 64b data type definitions outside USE_INT64\r\n   07-Feb-05    RMS     Added assertion fail stop\r\n   05-Nov-04    RMS     Added support for SHOW opt=val\r\n   20-Oct-04    RMS     Converted all base types to typedefs\r\n   21-Sep-04    RMS     Added switch to flag stop message printout\r\n   06-Feb-04    RMS     Moved device and unit user flags fields (V3.2)\r\n                RMS     Added REG_VMAD\r\n   29-Dec-03    RMS     Added output stall status\r\n   15-Jun-03    RMS     Added register flag REG_VMIO\r\n   23-Apr-03    RMS     Revised for 32b/64b t_addr\r\n   14-Mar-03    RMS     Lengthened default serial output wait\r\n   31-Mar-03    RMS     Added u5, u6 fields\r\n   18-Mar-03    RMS     Added logical name support\r\n                        Moved magtape definitions to sim_tape.h\r\n                        Moved breakpoint definitions from scp.c\r\n   03-Mar-03    RMS     Added sim_fsize\r\n   08-Feb-03    RMS     Changed sim_os_sleep to void, added match_ext\r\n   05-Jan-03    RMS     Added hidden switch definitions, device dyn memory support,\r\n                        parameters for function pointers, case sensitive SET support\r\n   22-Dec-02    RMS     Added break flag\r\n   08-Oct-02    RMS     Increased simulator error code space\r\n                        Added Telnet errors\r\n                        Added end of medium support\r\n                        Added help messages to CTAB\r\n                        Added flag and context fields to DEVICE\r\n                        Added restore flag masks\r\n                        Revised 64b definitions\r\n   02-May-02    RMS     Removed log status codes\r\n   22-Apr-02    RMS     Added magtape record length error\r\n   30-Dec-01    RMS     Generalized timer package, added circular arrays\r\n   07-Dec-01    RMS     Added breakpoint package\r\n   01-Dec-01    RMS     Added read-only unit support, extended SET/SHOW features,\r\n                        improved error messages\r\n   24-Nov-01    RMS     Added unit-based registers\r\n   27-Sep-01    RMS     Added queue count prototype\r\n   17-Sep-01    RMS     Removed multiple console support\r\n   07-Sep-01    RMS     Removed conditional externs on function prototypes\r\n   31-Aug-01    RMS     Changed int64 to t_int64 for Windoze\r\n   17-Jul-01    RMS     Added additional function prototypes\r\n   27-May-01    RMS     Added multiple console support\r\n   15-May-01    RMS     Increased string buffer size\r\n   25-Feb-01    RMS     Revisions for V2.6\r\n   15-Oct-00    RMS     Editorial revisions for V2.5\r\n   11-Jul-99    RMS     Added unsigned int data types\r\n   14-Apr-99    RMS     Converted t_addr to unsigned\r\n   04-Oct-98    RMS     Additional definitions for V2.4\r\n\r\n   The interface between the simulator control package (SCP) and the\r\n   simulator consists of the following routines and data structures\r\n\r\n        sim_name                simulator name string\r\n        sim_devices[]           array of pointers to simulated devices\r\n        sim_PC                  pointer to saved PC register descriptor\r\n        sim_interval            simulator interval to next event\r\n        sim_stop_messages[SCPE_BASE]\r\n                                array of pointers to stop messages\r\n        sim_instr()             instruction execution routine\r\n        sim_load()              binary loader routine\r\n        sim_emax                maximum number of words in an instruction\r\n\r\n   In addition, the simulator must supply routines to print and parse\r\n   architecture specific formats\r\n\r\n        print_sym               print symbolic output\r\n        parse_sym               parse symbolic input\r\n*/\r\n\r\n#ifndef SIM_DEFS_H_\r\n#define SIM_DEFS_H_    0\r\n\r\n#include \"sim_rev.h\"\r\n#include <stddef.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\r\n#define snprintf _snprintf      /* poor man's snprintf which will work most of the time but has different return value */\r\n#endif\r\n#if defined(__VAX)\r\nextern int sim_vax_snprintf(char *buf, size_t buf_size, const char *fmt, ...);\r\n#define snprintf sim_vax_snprintf\r\n#endif\r\n#include <stdarg.h>\r\n#include <string.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#include <ctype.h>\r\n#include <math.h>\r\n#include <setjmp.h>\r\n\r\n#ifndef EXIT_FAILURE\r\n#define EXIT_FAILURE 1\r\n#endif\r\n#ifndef EXIT_SUCCESS\r\n#define EXIT_SUCCESS 0\r\n#endif\r\n\r\n#if defined(__DECC)\r\n#define __FUNCTION__ __FILE__\r\n#endif\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* avoid macro names collisions */\r\n#ifdef MAX\r\n#undef MAX\r\n#endif\r\n#ifdef MIN\r\n#undef MIN\r\n#endif\r\n#ifdef PMASK\r\n#undef PMASK\r\n#endif\r\n#ifdef RS\r\n#undef RS\r\n#endif\r\n#ifdef PAGESIZE\r\n#undef PAGESIZE\r\n#endif\r\n\r\n\r\n#ifndef TRUE\r\n#define TRUE            1\r\n#define FALSE           0\r\n#endif\r\n\r\n/* SCP API shim.\r\n\r\n   The SCP API for version 4.0 introduces a number of \"pointer-to-const\"\r\n   parameter qualifiers that were not present in the 3.x versions.  To maintain\r\n   compatibility with the earlier versions, the new qualifiers are expressed as\r\n   \"CONST\" rather than \"const\".  This allows macro removal of the qualifiers\r\n   when compiling for SIMH 3.x.\r\n*/\r\n#ifndef CONST\r\n#define CONST const\r\n#endif\r\n\r\n/* Stringify macro value */\r\n\r\n#define __STR_QUOTE(tok) #tok\r\n#define __STR(tok) __STR_QUOTE(tok)\r\n\r\n/* Length specific integer declarations */\r\n\r\n/* Handle the special/unusual cases first with everything else leveraging stdint.h */\r\n#if defined (VMS)\r\n#include <ints.h>\r\n#elif defined(_MSC_VER) && (_MSC_VER < 1600)\r\ntypedef __int8           int8;\r\ntypedef __int16          int16;\r\ntypedef __int32          int32;\r\ntypedef unsigned __int8  uint8;\r\ntypedef unsigned __int16 uint16;\r\ntypedef unsigned __int32 uint32;\r\n#else\r\n/* All modern/standard compiler environments */\r\n/* any other environment needs a special case above */\r\n#include <stdint.h>\r\ntypedef int8_t          int8;\r\ntypedef int16_t         int16;\r\ntypedef int32_t         int32;\r\ntypedef uint8_t         uint8;\r\ntypedef uint16_t        uint16;\r\ntypedef uint32_t        uint32;\r\n#endif                                                  /* end standard integers */\r\n\r\ntypedef int             t_stat;                         /* status */\r\ntypedef int             t_bool;                         /* boolean */\r\n\r\n/* 64b integers */\r\n\r\n#if defined (__GNUC__)                                  /* GCC */\r\ntypedef signed long long        t_int64;\r\ntypedef unsigned long long      t_uint64;\r\n#elif defined (_WIN32)                                  /* Windows */\r\ntypedef signed __int64          t_int64;\r\ntypedef unsigned __int64        t_uint64;\r\n#elif (defined (__ALPHA) || defined (__ia64)) && defined (VMS) /* 64b VMS */\r\ntypedef signed __int64          t_int64;\r\ntypedef unsigned __int64        t_uint64;\r\n#elif defined (__ALPHA) && defined (__unix__)           /* Alpha UNIX */\r\ntypedef signed long             t_int64;\r\ntypedef unsigned long           t_uint64;\r\n#else                                                   /* default */\r\n#define t_int64                 signed long long\r\n#define t_uint64                unsigned long long\r\n#endif                                                  /* end 64b */\r\n#ifndef INT64_C\r\n#define INT64_C(x)      x ## LL\r\n#endif\r\n\r\n#if defined (USE_INT64)                                 /* 64b data */\r\ntypedef t_int64         t_svalue;                       /* signed value */\r\ntypedef t_uint64        t_value;                        /* value */\r\n#define T_VALUE_MAX     0xffffffffffffffffuLL\r\n#define T_SVALUE_MAX    0x7fffffffffffffffLL\r\n#else                                                   /* 32b data */\r\ntypedef int32           t_svalue;\r\ntypedef uint32          t_value;\r\n#define T_VALUE_MAX     0xffffffffUL\r\n#define T_SVALUE_MAX    0x7fffffffL\r\n#endif                                                  /* end 64b data */\r\n\r\n#if defined (USE_INT64) && defined (USE_ADDR64)         /* 64b address */\r\ntypedef t_uint64        t_addr;\r\n#define T_ADDR_W        64\r\n#define T_ADDR_FMT      LL_FMT\r\n#else                                                   /* 32b address */\r\ntypedef uint32          t_addr;\r\n#define T_ADDR_W        32\r\n#define T_ADDR_FMT      \"\"\r\n#endif                                                  /* end 64b address */\r\n\r\n#if defined (_WIN32)\r\n#define vsnprintf _vsnprintf\r\n#endif\r\n#if defined (__DECC) && defined (__VMS) && (defined (__VAX) || (__CRTL_VER <= 70311000))\r\n#define NO_vsnprintf\r\n#endif\r\n#if defined( NO_vsnprintf)\r\n#define STACKBUFSIZE 16384\r\n#else\r\n#define STACKBUFSIZE 2048\r\n#endif\r\n\r\n#if defined (_WIN32) /* Actually, a GCC issue */\r\n#define LL_FMT \"I64\"\r\n#define LL_TYPE long long\r\n#else\r\n#if defined (__VAX) /* No 64 bit ints on VAX */\r\n#define LL_FMT \"l\"\r\n#define LL_TYPE long\r\n#else\r\n#define LL_FMT \"ll\"\r\n#define LL_TYPE long long\r\n#endif\r\n#endif\r\n\r\n#if defined (VMS) && (defined (__ia64) || defined (__ALPHA))\r\n#define HAVE_GLOB\r\n#endif\r\n\r\n#if defined (__linux) || defined (VMS) || defined (__APPLE__)\r\n#define HAVE_C99_STRFTIME 1\r\n#endif\r\n\r\n#if defined (_WIN32)\r\n#define NULL_DEVICE \"NUL:\"\r\n#elif defined (_VMS)\r\n#define NULL_DEVICE \"NL:\"\r\n#else\r\n#define NULL_DEVICE \"/dev/null\"\r\n#endif\r\n\r\n/* Stubs for inlining */\r\n\r\n#if defined(_MSC_VER)\r\n#define SIM_INLINE _inline\r\n#define SIM_NOINLINE _declspec (noinline)\r\n#elif defined(__GNUC__)\r\n#define SIM_INLINE inline\r\n#define SIM_NOINLINE  __attribute__ ((noinline))\r\n#else\r\n#define SIM_INLINE\r\n#define SIM_NOINLINE\r\n#endif\r\n\r\n/* Packed structure support */\r\n\r\n#ifdef _MSC_VER\r\n# define PACKED_BEGIN __pragma( pack(push, 1) )\r\n# define PACKED_END __pragma( pack(pop) )\r\n#else\r\n# define PACKED_BEGIN\r\n#if defined(_WIN32)\r\n# define PACKED_END __attribute__((gcc_struct, packed))\r\n#else\r\n# define PACKED_END __attribute__((packed))\r\n#endif\r\n#endif\r\n\r\n\r\n/* System independent definitions */\r\n\r\n#define FLIP_SIZE       (1 << 16)                       /* flip buf size */\r\n#if !defined (PATH_MAX)                                 /* usually in limits */\r\n#define PATH_MAX        512\r\n#endif\r\n#if (PATH_MAX >= 128)\r\n#define CBUFSIZE        (128 + PATH_MAX)                /* string buf size */\r\n#else\r\n#define CBUFSIZE        256\r\n#endif\r\n\r\n/* Breakpoint spaces definitions */\r\n\r\n#define SIM_BKPT_N_SPC  (1 << (32 - SIM_BKPT_V_SPC))    /* max number spaces */\r\n#define SIM_BKPT_V_SPC  (BRK_TYP_MAX + 1)               /* location in arg */\r\n\r\n/* Extended switch definitions (bits >= 26) */\r\n\r\n#define SIM_SW_HIDE     (1u << 26)                      /* enable hiding */\r\n#define SIM_SW_REST     (1u << 27)                      /* attach/restore */\r\n#define SIM_SW_REG      (1u << 28)                      /* register value */\r\n#define SIM_SW_STOP     (1u << 29)                      /* stop message */\r\n#define SIM_SW_SHUT     (1u << 30)                      /* shutdown */\r\n\r\n/* Simulator status codes\r\n\r\n   0                    ok\r\n   1 - (SCPE_BASE - 1)  simulator specific\r\n   SCPE_BASE - n        general\r\n*/\r\n\r\n#define SCPE_OK         0                               /* normal return */\r\n#define SCPE_BASE       64                              /* base for messages */\r\n#define SCPE_NXM        (SCPE_BASE + 0)                 /* nxm */\r\n#define SCPE_UNATT      (SCPE_BASE + 1)                 /* no file */\r\n#define SCPE_IOERR      (SCPE_BASE + 2)                 /* I/O error */\r\n#define SCPE_CSUM       (SCPE_BASE + 3)                 /* loader cksum */\r\n#define SCPE_FMT        (SCPE_BASE + 4)                 /* loader format */\r\n#define SCPE_NOATT      (SCPE_BASE + 5)                 /* not attachable */\r\n#define SCPE_OPENERR    (SCPE_BASE + 6)                 /* open error */\r\n#define SCPE_MEM        (SCPE_BASE + 7)                 /* alloc error */\r\n#define SCPE_ARG        (SCPE_BASE + 8)                 /* argument error */\r\n#define SCPE_STEP       (SCPE_BASE + 9)                 /* step expired */\r\n#define SCPE_UNK        (SCPE_BASE + 10)                /* unknown command */\r\n#define SCPE_RO         (SCPE_BASE + 11)                /* read only */\r\n#define SCPE_INCOMP     (SCPE_BASE + 12)                /* incomplete */\r\n#define SCPE_STOP       (SCPE_BASE + 13)                /* sim stopped */\r\n#define SCPE_EXIT       (SCPE_BASE + 14)                /* sim exit */\r\n#define SCPE_TTIERR     (SCPE_BASE + 15)                /* console tti err */\r\n#define SCPE_TTOERR     (SCPE_BASE + 16)                /* console tto err */\r\n#define SCPE_EOF        (SCPE_BASE + 17)                /* end of file */\r\n#define SCPE_REL        (SCPE_BASE + 18)                /* relocation error */\r\n#define SCPE_NOPARAM    (SCPE_BASE + 19)                /* no parameters */\r\n#define SCPE_ALATT      (SCPE_BASE + 20)                /* already attached */\r\n#define SCPE_TIMER      (SCPE_BASE + 21)                /* hwre timer err */\r\n#define SCPE_SIGERR     (SCPE_BASE + 22)                /* signal err */\r\n#define SCPE_TTYERR     (SCPE_BASE + 23)                /* tty setup err */\r\n#define SCPE_SUB        (SCPE_BASE + 24)                /* subscript err */\r\n#define SCPE_NOFNC      (SCPE_BASE + 25)                /* func not imp */\r\n#define SCPE_UDIS       (SCPE_BASE + 26)                /* unit disabled */\r\n#define SCPE_NORO       (SCPE_BASE + 27)                /* rd only not ok */\r\n#define SCPE_INVSW      (SCPE_BASE + 28)                /* invalid switch */\r\n#define SCPE_MISVAL     (SCPE_BASE + 29)                /* missing value */\r\n#define SCPE_2FARG      (SCPE_BASE + 30)                /* too few arguments */\r\n#define SCPE_2MARG      (SCPE_BASE + 31)                /* too many arguments */\r\n#define SCPE_NXDEV      (SCPE_BASE + 32)                /* nx device */\r\n#define SCPE_NXUN       (SCPE_BASE + 33)                /* nx unit */\r\n#define SCPE_NXREG      (SCPE_BASE + 34)                /* nx register */\r\n#define SCPE_NXPAR      (SCPE_BASE + 35)                /* nx parameter */\r\n#define SCPE_NEST       (SCPE_BASE + 36)                /* nested DO */\r\n#define SCPE_IERR       (SCPE_BASE + 37)                /* internal error */\r\n#define SCPE_MTRLNT     (SCPE_BASE + 38)                /* tape rec lnt error */\r\n#define SCPE_LOST       (SCPE_BASE + 39)                /* Telnet conn lost */\r\n#define SCPE_TTMO       (SCPE_BASE + 40)                /* Telnet conn timeout */\r\n#define SCPE_STALL      (SCPE_BASE + 41)                /* Telnet conn stall */\r\n#define SCPE_AFAIL      (SCPE_BASE + 42)                /* assert failed */\r\n#define SCPE_INVREM     (SCPE_BASE + 43)                /* invalid remote console command */\r\n#define SCPE_EXPECT     (SCPE_BASE + 44)                /* expect matched */\r\n#define SCPE_AMBREG     (SCPE_BASE + 45)                /* ambiguous register */\r\n#define SCPE_REMOTE     (SCPE_BASE + 46)                /* remote console command */\r\n#define SCPE_INVEXPR    (SCPE_BASE + 47)                /* invalid expression */\r\n#define SCPE_SIGTERM    (SCPE_BASE + 48)                /* SIGTERM has been received */\r\n#define SCPE_FSSIZE     (SCPE_BASE + 49)                /* File System size larger than disk size */\r\n#define SCPE_RUNTIME    (SCPE_BASE + 50)                /* Run Time Limit Exhausted */\r\n#define SCPE_INCOMPDSK  (SCPE_BASE + 51)                /* Incompatible Disk Container */\r\n#define SCPE_AMBASSIGN  (SCPE_BASE + 52)                /* ambiguous logical name */\r\n\r\n#define SCPE_MAX_ERR    (SCPE_BASE + 52)                /* Maximum SCPE Error Value */\r\n#define SCPE_KFLAG      0x10000000                      /* tti data flag */\r\n#define SCPE_BREAK      0x20000000                      /* tti break flag */\r\n#define SCPE_NOMESSAGE  0x40000000                      /* message display suppression flag */\r\n#define SCPE_BARE_STATUS(stat) ((stat) & ~(SCPE_NOMESSAGE|SCPE_KFLAG|SCPE_BREAK))\r\n\r\n/* Print value format codes */\r\n\r\n#define PV_RZRO         0                               /* right, zero fill */\r\n#define PV_RSPC         1                               /* right, space fill */\r\n#define PV_RCOMMA       2                               /* right, space fill. Comma separate every 3 */\r\n#define PV_LEFT         3                               /* left justify */\r\n#define PV_RCOMMASIGN   6                               /* right, space fill. Comma separate every 3 treat as signed */\r\n#define PV_LEFTSIGN     7                               /* left justify treat as signed */\r\n\r\n/* Default timing parameters */\r\n\r\n#define KBD_POLL_WAIT   5000                            /* keyboard poll */\r\n#define SERIAL_IN_WAIT  100                             /* serial in time */\r\n#define SERIAL_OUT_WAIT 100                             /* serial output */\r\n#define NOQUEUE_WAIT    1000000                         /* min check time */\r\n\r\n/* Convert switch letter to bit mask */\r\n\r\n#define SWMASK(x) (1u << (((int) (x)) - ((int) 'A')))\r\n\r\n/* String match - at least one character required */\r\n\r\n#define MATCH_CMD(ptr,cmd) ((NULL == (ptr)) || (!*(ptr)) || strncasecmp ((ptr), (cmd), strlen (ptr)))\r\n\r\n/* End of Linked List/Queue value                           */\r\n/* Chosen for 2 reasons:                                    */\r\n/*     1 - to not be NULL, this allowing the NULL value to  */\r\n/*         indicate inclusion on a list                     */\r\n/* and                                                      */\r\n/*     2 - to not be a valid/possible pointer (alignment)   */\r\n#define QUEUE_LIST_END ((UNIT *)1)\r\n\r\n/* Typedefs for principal structures */\r\n\r\ntypedef struct DEVICE DEVICE;\r\ntypedef struct UNIT UNIT;\r\ntypedef struct REG REG;\r\ntypedef struct CTAB CTAB;\r\ntypedef struct C1TAB C1TAB;\r\ntypedef struct SHTAB SHTAB;\r\ntypedef struct MTAB MTAB;\r\ntypedef struct SCHTAB SCHTAB;\r\ntypedef struct BRKTAB BRKTAB;\r\ntypedef struct BRKTYPTAB BRKTYPTAB;\r\ntypedef struct EXPTAB EXPTAB;\r\ntypedef struct EXPECT EXPECT;\r\ntypedef struct SEND SEND;\r\ntypedef struct DEBTAB DEBTAB;\r\ntypedef struct FILEREF FILEREF;\r\ntypedef struct MEMFILE MEMFILE;\r\ntypedef struct BITFIELD BITFIELD;\r\ntypedef struct DRVTYP DRVTYP;\r\n\r\ntypedef t_stat (*ACTIVATE_API)(UNIT *unit, int32 interval);\r\n\r\n/* Device data structure */\r\n\r\nstruct DEVICE {\r\n    const char          *name;                          /* name */\r\n    UNIT                *units;                         /* units */\r\n    REG                 *registers;                     /* registers */\r\n    MTAB                *modifiers;                     /* modifiers */\r\n    uint32              numunits;                       /* #units */\r\n    uint32              aradix;                         /* address radix */\r\n    uint32              awidth;                         /* address width */\r\n    uint32              aincr;                          /* addr increment */\r\n    uint32              dradix;                         /* data radix */\r\n    uint32              dwidth;                         /* data width */\r\n    t_stat              (*examine)(t_value *v, t_addr a, UNIT *up,\r\n                            int32 sw);                  /* examine routine */\r\n    t_stat              (*deposit)(t_value v, t_addr a, UNIT *up,\r\n                            int32 sw);                  /* deposit routine */\r\n    t_stat              (*reset)(DEVICE *dp);           /* reset routine */\r\n    t_stat              (*boot)(int32 u, DEVICE *dp);\r\n                                                        /* boot routine */\r\n    t_stat              (*attach)(UNIT *up, CONST char *cp);\r\n                                                        /* attach routine */\r\n    t_stat              (*detach)(UNIT *up);            /* detach routine */\r\n    void                *ctxt;                          /* context */\r\n    uint32              flags;                          /* flags */\r\n    uint32              dctrl;                          /* debug control */\r\n    DEBTAB              *debflags;                      /* debug flags */\r\n    t_stat              (*msize)(UNIT *up, int32 v, CONST char *cp, void *dp);\r\n                                                        /* mem size routine */\r\n    char                *lname;                         /* logical name */\r\n    t_stat              (*help)(FILE *st, DEVICE *dptr,\r\n                            UNIT *uptr, int32 flag, const char *cptr);\r\n                                                        /* help */\r\n    t_stat              (*attach_help)(FILE *st, DEVICE *dptr,\r\n                            UNIT *uptr, int32 flag, const char *cptr);\r\n                                                        /* attach help */\r\n    void                *help_ctx;                      /* Context available to help routines */\r\n    const char          *(*description)(DEVICE *dptr);  /* Device Description */\r\n    BRKTYPTAB           *brk_types;                     /* Breakpoint types */\r\n    void                *type_ctx;                      /* Device Type/Library Context */\r\n    t_stat              (*unit_test)(DEVICE *dptr, const char *cptr);\r\n                                                        /* Device Unit Test Routine */\r\n    };\r\n\r\n/* Device flags */\r\n\r\n#define DEV_V_DIS       0                               /* dev disabled */\r\n#define DEV_V_DISABLE   1                               /* dev disable-able */\r\n#define DEV_V_DYNM      2                               /* mem size dynamic */\r\n#define DEV_V_DEBUG     3                               /* debug capability */\r\n#define DEV_V_TYPE      4                               /* Attach type */\r\n#define DEV_S_TYPE      4                               /* Width of Type Field */\r\n#define DEV_V_SECTORS   8                               /* Unit Capacity is in 512byte sectors */\r\n#define DEV_V_DONTAUTO  9                               /* Do not auto detach already attached units */\r\n#define DEV_V_FLATHELP  10                              /* Use traditional (unstructured) help */\r\n#define DEV_V_NOSAVE    11                              /* Don't save device state */\r\n#define DEV_V_UF_31     12                              /* user flags, V3.1 */\r\n#define DEV_V_UF        16                              /* user flags */\r\n#define DEV_V_RSV       31                              /* reserved */\r\n\r\n#define DEV_DIS         (1 << DEV_V_DIS)                /* device is currently disabled */\r\n#define DEV_DISABLE     (1 << DEV_V_DISABLE)            /* device can be set enabled or disabled */\r\n#define DEV_DYNM        (1 << DEV_V_DYNM)               /* device requires call on msize routine to change memory size */\r\n#define DEV_DEBUG       (1 << DEV_V_DEBUG)              /* device supports SET DEBUG command */\r\n#define DEV_SECTORS     (1 << DEV_V_SECTORS)            /* capacity is 512 byte sectors */\r\n#define DEV_DONTAUTO    (1 << DEV_V_DONTAUTO)           /* Do not auto detach already attached units */\r\n#define DEV_FLATHELP    (1 << DEV_V_FLATHELP)           /* Use traditional (unstructured) help */\r\n#define DEV_NOSAVE      (1 << DEV_V_NOSAVE)             /* Don't save device state */\r\n#define DEV_NET         0                               /* Deprecated - meaningless */\r\n\r\n\r\n#define DEV_TYPEMASK    (((1 << DEV_S_TYPE) - 1) << DEV_V_TYPE)\r\n#define DEV_DISK        (1 << DEV_V_TYPE)               /* sim_disk Attach */\r\n#define DEV_TAPE        (2 << DEV_V_TYPE)               /* sim_tape Attach */\r\n#define DEV_SCSI        (3 << DEV_V_TYPE)               /* sim_scsi Attach */\r\n#define DEV_MUX         (4 << DEV_V_TYPE)               /* sim_tmxr Attach */\r\n#define DEV_CARD        (5 << DEV_V_TYPE)               /* sim_card Attach */\r\n#define DEV_ETHER       (6 << DEV_V_TYPE)               /* Ethernet Device */\r\n#define DEV_DISPLAY     (7 << DEV_V_TYPE)               /* Display Device (sim_video) */\r\n#define DEV_TYPE(dptr)  ((dptr)->flags & DEV_TYPEMASK)\r\n\r\n#define DEV_UFMASK_31   (((1u << DEV_V_RSV) - 1) & ~((1u << DEV_V_UF_31) - 1))\r\n#define DEV_UFMASK      (((1u << DEV_V_RSV) - 1) & ~((1u << DEV_V_UF) - 1))\r\n#define DEV_RFLAGS      (DEV_UFMASK|DEV_DIS)            /* restored flags */\r\n\r\n/* Unit data structure\r\n\r\n   Parts of the unit structure are device specific, that is, they are\r\n   not referenced by the simulator control package and can be freely\r\n   used by device simulators.  Fields starting with 'buf', and flags\r\n   starting with 'UF', are device specific.  The definitions given here\r\n   are for a typical sequential device.\r\n*/\r\n\r\nstruct UNIT {\r\n    UNIT                *next;                          /* next active */\r\n    t_stat              (*action)(UNIT *up);            /* action routine */\r\n    char                *filename;                      /* open file name */\r\n    FILE                *fileref;                       /* file reference */\r\n    void                *filebuf;                       /* memory buffer */\r\n    void                *filebuf2;                      /* copy of initial memory buffer */\r\n    uint32              hwmark;                         /* high water mark */\r\n    int32               time;                           /* time out */\r\n    uint32              flags;                          /* flags */\r\n    uint32              dynflags;                       /* dynamic flags */\r\n    t_addr              capac;                          /* capacity */\r\n    t_addr              pos;                            /* file position */\r\n    void                (*io_flush)(UNIT *up);          /* io flush routine */\r\n    uint32              iostarttime;                    /* I/O start time */\r\n    int32               buf;                            /* buffer */\r\n    void                *up7;                           /* device specific */\r\n    void                *up8;                           /* device specific */\r\n    uint16              us9;                            /* device specific */\r\n    uint16              us10;                           /* device specific */\r\n    void                *up11;                          /* device specific */\r\n    DRVTYP              *drvtyp;                        /* Drive Type */\r\n    void                *tmxr;                          /* TMXR linkage */\r\n    uint32              recsize;                        /* Tape specific info */\r\n    t_addr              tape_eom;                       /* Tape specific info */\r\n    uint32              tape_chunk_size;                /* Tape specific info */\r\n    t_bool              (*cancel)(UNIT *);\r\n    double              usecs_remaining;                /* time balance for long delays */\r\n    char                *uname;                         /* Unit name */\r\n    DEVICE              *dptr;                          /* DEVICE linkage (backpointer) */\r\n    uint32              dctrl;                          /* debug control */\r\n    char                *lname;                         /* logical name */\r\n#ifdef SIM_ASYNCH_IO\r\n    void                (*a_check_completion)(UNIT *);\r\n    t_bool              (*a_is_active)(UNIT *);\r\n    UNIT                *a_next;                        /* next asynch active */\r\n    int32               a_event_time;\r\n    ACTIVATE_API        a_activate_call;\r\n    /* Asynchronous Timer control */\r\n    double              a_due_time;                     /* due time for timer event */\r\n    double              a_due_gtime;                    /* due time (in instructions) for timer event */\r\n    double              a_usec_delay;                   /* time delay for timer event */\r\n#endif\r\n    /* Everything above here in the UNIT structure is within the scope of the UDATA \r\n       macro initializer, if a simulator developer wants to initialize any of these \r\n       values, they must be done by explicit code usually in a device reset routine */\r\n    int32               wait;                           /* wait */\r\n    int32               u3;                             /* device specific */\r\n    int32               u4;                             /* device specific */\r\n    int32               u5;                             /* device specific */\r\n    int32               u6;                             /* device specific */\r\n    };\r\n\r\n/* Unit flags */\r\n\r\n#define UNIT_V_UF_31    12              /* dev spec, V3.1 */\r\n#define UNIT_V_UF       16              /* device specific */\r\n#define UNIT_V_RSV      31              /* reserved!! */\r\n\r\n#define UNIT_ATTABLE    0000001         /* attachable */\r\n#define UNIT_RO         0000002         /* read only */\r\n#define UNIT_FIX        0000004         /* fixed capacity */\r\n#define UNIT_SEQ        0000010         /* sequential */\r\n#define UNIT_ATT        0000020         /* attached */\r\n#define UNIT_BINK       0000040         /* K = power of 2 */\r\n#define UNIT_BUFABLE    0000100         /* bufferable */\r\n#define UNIT_MUSTBUF    0000200         /* must buffer */\r\n#define UNIT_BUF        0000400         /* buffered */\r\n#define UNIT_ROABLE     0001000         /* read only ok */\r\n#define UNIT_DISABLE    0002000         /* disable-able */\r\n#define UNIT_DIS        0004000         /* disabled */\r\n#define UNIT_IDLE       0040000         /* idle eligible */\r\n#define UNIT_WLK        0100000         /* hardware write lock */\r\n#define UNIT_WPRT     (UNIT_WLK|UNIT_RO)/* write protect */\r\n\r\n/* Unused/meaningless flags */\r\n#define UNIT_TEXT       0000000         /* text mode - no effect */\r\n\r\n#define UNIT_UFMASK_31  (((1u << UNIT_V_RSV) - 1) & ~((1u << UNIT_V_UF_31) - 1))\r\n#define UNIT_UFMASK     (((1u << UNIT_V_RSV) - 1) & ~((1u << UNIT_V_UF) - 1))\r\n#define UNIT_RFLAGS     (UNIT_UFMASK|UNIT_DIS)          /* restored flags */\r\n\r\n/* Unit dynamic flags (dynflags) */\r\n\r\n/* These flags are only set dynamically */\r\n\r\n#define UNIT_ATTMULT        0000001         /* Allow multiple attach commands */\r\n#define UNIT_TM_POLL        0000002         /* TMXR Polling unit (connect, transmit or receive) */\r\n#define UNIT_NO_FIO         0000004         /* fileref is NOT a FILE * */\r\n#define UNIT_DISK_CHK       0000010         /* disk data debug checking (sim_disk) */\r\n#define UNIT_TMR_UNIT       0000200         /* Unit registered as a calibrated timer */\r\n#define UNIT_TAPE_MRK       0000400         /* Tape Unit Tapemark */\r\n#define UNIT_TAPE_PNU       0001000         /* Tape Unit Position Not Updated */\r\n#define UNIT_V_DF_TAPE      10              /* Bit offset for Tape Density reservation */\r\n#define UNIT_S_DF_TAPE      3               /* Bits Reserved for Tape Density */\r\n#define UNIT_V_TAPE_FMT     13              /* Bit offset for Tape Format */\r\n#define UNIT_S_TAPE_FMT     4               /* Bits Reserved for Tape Format */\r\n#define UNIT_M_TAPE_FMT     (((1 << UNIT_S_TAPE_FMT) - 1) << UNIT_V_TAPE_FMT)\r\n#define UNIT_V_TAPE_ANSI    17              /* Bit offset for ANSI Tape Type */\r\n#define UNIT_S_TAPE_ANSI    4               /* Bits Reserved for ANSI Tape Type */\r\n#define UNIT_M_TAPE_ANSI    (((1 << UNIT_S_TAPE_ANSI) - 1) << UNIT_V_TAPE_ANSI)\r\n\r\nstruct BITFIELD {\r\n    const char      *name;                              /* field name */\r\n    uint32          offset;                             /* starting bit */\r\n    uint32          width;                              /* width */\r\n    const char      **valuenames;                       /* map of values to strings */\r\n    const char      *format;                            /* value format string */\r\n    };\r\n\r\n/* Register data structure */\r\n\r\nstruct REG {\r\n    CONST char          *name;                          /* name */\r\n    void                *loc;                           /* location */\r\n    uint32              radix;                          /* radix */\r\n    uint32              width;                          /* width */\r\n    uint32              offset;                         /* starting bit */\r\n    uint32              depth;                          /* save depth */\r\n    const char          *desc;                          /* description */\r\n    BITFIELD            *fields;                        /* bit fields */\r\n    uint32              qptr;                           /* circ q ptr */\r\n    size_t              stride;                         /* structure/object size (for indexing) */\r\n    size_t              obj_size;                       /* sizeof(loc) */\r\n    size_t              pobj_size;                      /* sizeof(*loc) */\r\n    size_t              size;                           /* sizeof(**loc) or sizeof(*loc) if depth == 1 */\r\n    const char          *macro;                         /* Initializer Macro Name */\r\n    const char          *source_file;                   /* source file used macro */\r\n    int                 source_line;                    /* source line used macro */\r\n    /* NOTE: Flags and maxval MUST always be last since they are initialized outside of macro definitions */\r\n    uint32              flags;                          /* flags */\r\n    t_value             maxval;                         /* maximum value */\r\n    };\r\n\r\n/* Register flags */\r\n\r\n#define REG_FMT         00017                           /* see PV_x */\r\n#define REG_DOUBLE      00010                           /* Double Precision Value */\r\n#define REG_RO          00020                           /* read only */\r\n#define REG_HIDDEN      00040                           /* hidden */\r\n#define REG_NZ          00100                           /* must be non-zero */\r\n#define REG_CIRC        00200                           /* circular array */\r\n#define REG_VMIO        00400                           /* use VM data print/parse */\r\n#define REG_VMAD        01000                           /* use VM addr print/parse */\r\n#define REG_FIT         00000                           /* fit access to size (obsolete) */\r\n#define REG_DEPOSIT     04000                           /* call VM routine after update */\r\n#define REG_HRO         (REG_RO | REG_HIDDEN)           /* hidden, read only */\r\n\r\n#define REG_V_UF        16                              /* device specific */\r\n#define REG_UFMASK      (~((1u << REG_V_UF) - 1))       /* user flags mask */\r\n#define REG_VMFLAGS     (REG_VMIO | REG_UFMASK)         /* call VM routine if any of these are set */\r\n\r\n/* Command tables, base and alternate formats */\r\n\r\nstruct CTAB {\r\n    const char          *name;                          /* name */\r\n    t_stat              (*action)(int32 flag, CONST char *cptr);\r\n                                                        /* action routine */\r\n    int32               arg;                            /* argument */\r\n    const char          *help;                          /* help string/structured locator */\r\n    const char          *help_base;                     /* structured help base*/\r\n    void                (*message)(const char *unechoed_cmdline, t_stat stat);\r\n                                                        /* message printing routine */\r\n    };\r\n\r\nstruct C1TAB {\r\n    const char          *name;                          /* name */\r\n    t_stat              (*action)(DEVICE *dptr, UNIT *uptr,\r\n                            int32 flag, CONST char *cptr);/* action routine */\r\n    int32               arg;                            /* argument */\r\n    const char          *help;                          /* help string */\r\n    };\r\n\r\nstruct SHTAB {\r\n    const char          *name;                          /* name */\r\n    t_stat              (*action)(FILE *st, DEVICE *dptr,\r\n                            UNIT *uptr, int32 flag, CONST char *cptr);\r\n    int32               arg;                            /* argument */\r\n    const char          *help;                          /* help string */\r\n    };\r\n\r\n/* Modifier table - only extended entries have disp, reg, or flags */\r\n\r\nstruct MTAB {\r\n    uint32              mask;                           /* mask */\r\n    uint32              match;                          /* match */\r\n    const char          *pstring;                       /* print string */\r\n    const char          *mstring;                       /* match string */\r\n    t_stat              (*valid)(UNIT *up, int32 v, CONST char *cp, void *dp);\r\n                                                        /* validation routine */\r\n    t_stat              (*disp)(FILE *st, UNIT *up, int32 v, CONST void *dp);\r\n                                                        /* display routine */\r\n    void                *desc;                          /* value descriptor */\r\n                                                        /* pointer to something needed by */\r\n                                                        /* the validation and/or display routines */\r\n    const char          *help;                          /* help string */\r\n    };\r\n\r\n\r\n/* mtab mask flag bits */\r\n/* NOTE: MTAB_VALR and MTAB_VALO are only used to display help */\r\n#define MTAB_XTD        (1u << UNIT_V_RSV)              /* ext entry flag */\r\n#define MTAB_VDV        (0001 | MTAB_XTD)               /* valid for dev */\r\n#define MTAB_VUN        (0002 | MTAB_XTD)               /* valid for unit */\r\n#define MTAB_VALR       (0004 | MTAB_XTD)               /* takes a value (required) */\r\n#define MTAB_VALO       (0010 | MTAB_XTD)               /* takes a value (optional) */\r\n#define MTAB_NMO        (0020 | MTAB_XTD)               /* only if named */\r\n#define MTAB_NC         (0040 | MTAB_XTD)               /* no UC conversion */\r\n#define MTAB_QUOTE      (0100 | MTAB_XTD)               /* quoted string */\r\n#define MTAB_SHP        (0200 | MTAB_XTD)               /* show takes parameter */\r\n#define MODMASK(mptr,flag) (((mptr)->mask & (uint32)(flag)) == (uint32)(flag))/* flag mask test */\r\n\r\n/* Search table */\r\n\r\nstruct SCHTAB {\r\n    int32               logic;                          /* logical operator */\r\n    int32               boolop;                         /* boolean operator */\r\n    uint32              count;                          /* value count in mask and comp arrays */\r\n    t_value             *mask;                          /* mask for logical */\r\n    t_value             *comp;                          /* comparison for boolean */\r\n    };\r\n\r\n/* Breakpoint table */\r\n\r\nstruct BRKTAB {\r\n    t_addr              addr;                           /* address */\r\n    uint32              typ;                            /* mask of types */\r\n#define BRK_TYP_USR_TYPES       ((1 << ('Z'-'A'+1)) - 1)/* all types A-Z */\r\n#define BRK_TYP_DYN_STEPOVER    (SWMASK ('Z'+1))\r\n#define BRK_TYP_DYN_USR         (SWMASK ('Z'+2))\r\n#define BRK_TYP_DYN_ALL         (BRK_TYP_DYN_USR|BRK_TYP_DYN_STEPOVER) /* Mask of All Dynamic types */\r\n#define BRK_TYP_TEMP            (SWMASK ('Z'+3))        /* Temporary (one-shot) */\r\n#define BRK_TYP_MAX             (('Z'-'A')+3)           /* Maximum breakpoint type */\r\n    int32               cnt;                            /* proceed count */\r\n    char                *act;                           /* action string */\r\n    double              time_fired[SIM_BKPT_N_SPC];     /* instruction count when match occurred */\r\n    BRKTAB *next;                                       /* list with same address value */\r\n    };\r\n\r\n/* Breakpoint table */\r\n\r\nstruct BRKTYPTAB {\r\n    uint32      btyp;                                   /* type mask */\r\n    const char *desc;                                   /* description */\r\n    };\r\n#define BRKTYPE(typ,descrip) {SWMASK(typ), descrip}\r\n\r\n/* Debug table */\r\n\r\nstruct DEBTAB {\r\n    const char          *name;                          /* control name */\r\n    uint32              mask;                           /* control bit */\r\n    const char          *desc;                          /* description */\r\n    };\r\n\r\n/* Deprecated Debug macros.  Use sim_debug() */\r\n\r\n#define DEBUG_PRS(d)    (sim_deb && d.dctrl)\r\n#define DEBUG_PRD(d)    (sim_deb && d->dctrl)\r\n#define DEBUG_PRI(d,m)  (sim_deb && (d.dctrl & (m)))\r\n#define DEBUG_PRJ(d,m)  (sim_deb && ((d)->dctrl & (m)))\r\n\r\n/* Open File Reference */\r\nstruct FILEREF {\r\n    char                name[CBUFSIZE];                 /* file name */\r\n    FILE                *file;                          /* file handle */\r\n    int32               refcount;                       /* reference count */\r\n    };\r\n\r\nstruct MEMFILE {\r\n    char                *buf;                           /* buffered data */\r\n    size_t              size;                        /* size */\r\n    size_t              pos;                         /* data used */\r\n    };\r\n\r\n/*\r\n   The following macros exist to help populate structure contents\r\n\r\n   They are dependent on the declaration order of the fields\r\n   of the structures they exist to populate.\r\n\r\n */\r\n\r\n#ifdef SIM_ASYNCH_IO\r\n#define UDATA(act,fl,cap) NULL,act,NULL,NULL,NULL,NULL,0,0,(fl),0,(cap),0,NULL,0,0,NULL,NULL,0,0,NULL,NULL,NULL,0,0,0,NULL,0,NULL,NULL,0,NULL,\\\r\n                          NULL,NULL,NULL,0,NULL,0,0,0\r\n#else\r\n#define UDATA(act,fl,cap) NULL,act,NULL,NULL,NULL,NULL,0,0,(fl),0,(cap),0,NULL,0,0,NULL,NULL,0,0,NULL,NULL,NULL,0,0,0,NULL,0,NULL,NULL,0,NULL\r\n#endif\r\n\r\n/* Register initialization macros.\r\n\r\n   The following macros should be used to initialize the elements of a\r\n   simulator's register array.  The macros provide simplified initialization,\r\n   ensure that unspecified fields are set appropriately, and insulate the\r\n   simulator writer from changes in the underlying REG structure.\r\n\r\n   The macros take varying numbers of parameters with the following meanings:\r\n\r\n     Param  Meaning\r\n     -----  ------------------------------------------\r\n      nm    Register symbolic name\r\n      loc   Location of the associated variable\r\n      aloc  Location of the associated array\r\n      floc  Location of the associated structure field\r\n      rdx   Display and entry radix\r\n      wd    Field width in bits\r\n      off   Field offset in bits from LSB\r\n      dep   Number of array elements\r\n      siz   Element size in bytes\r\n      str   Array element spacing in bytes\r\n\r\n   The macros have the following uses:\r\n\r\n     Macro     Use with\r\n     --------  ---------------------------------------------------------------\r\n     ORDATA    Scalar with octal display/entry\r\n     DRDATA    Scalar with decimal display/entry\r\n     HRDATA    Scalar with hexadecimal display/entry\r\n     BINRDATA  Scalar with binary display/entry\r\n     FLDATA    Scalar with single bit display/entry\r\n     DBRDATA   Scalar double precision floating display (no entry)\r\n     GRDATA    Scalar with with specification of radix/width/offset parameters\r\n\r\n     BRDATA    Singly-subscripted array of scalars\r\n     CRDATA    Doubly-subscripted array of scalars\r\n     VBRDATA   List of elements accessed like a Singly-subscripted array of scalars\r\n\r\n     SRDATA    Singly-subscripted array of general structure fields\r\n     URDATA    Singly-subscripted array of UNIT structure fields\r\n\r\n     XRDATA    Generic type with specification of all parameters\r\n     SAVEDATA  Generic type used only for persistence across SAVE/RESTORE\r\n\r\n   Normally, scalar and array locations specify the variable name; the names are\r\n   converted internally to pointers as needed.  However, the starting point of\r\n   a partial array may be specified by passing a pointer to the desired element.\r\n   For example:\r\n\r\n     BRDATA (SYM, array, ...)\r\n\r\n   ...specifies a register starting with array element zero, while:\r\n\r\n     BRDATA (SYM, &array[3], ...)\r\n\r\n   ...specifies a register starting with array element three.\r\n\r\n   For arrays of general structures, the names of the array and selected field\r\n   are given:\r\n\r\n     SRDATA (SYM, array, field, ...)\r\n\r\n   This specifies a arrayed register whose elements are array[0].field,\r\n   array[1].field, etc.\r\n\r\n   All above macro names from ORDATA through XRDATA have two additional\r\n   precisely related macros.  The first it the above name with D appended and\r\n   has an additional parameter which is a quoted string describing the purpose\r\n   of the register which is visible when displaying HELP about a device's\r\n   registers.  The second related macro has the above name with DF appended\r\n   and has two additional parameters.  The first parameter is the register\r\n   description, and the second is the name of a BITFIELD array which describes\r\n   the fields in the register's contents.  This info is used to display the\r\n   register contents (via EXAMINE) along with the detailed bitfield data.\r\n   For example:\r\n\r\n       { HRDATA  (KSP,        KSP,  32) },\r\n       { HRDATAD (KSP,        KSP,  32, \"kernel stack pointer\") },\r\n       { HRDATADF(PSL,        PSL,  32, \"processor status longword\", cpu_psl_bits) },\r\n     or\r\n       { ORDATA  (PSW, PSW, 16) },\r\n       { ORDATAD (PSW, PSW, 16,                \"Processor Status Word\") },\r\n       { ORDATADF(PSW, PSW, 16,                \"Processor Status Word\", psw_bits) },\r\n\r\n\r\n   Implementation notes:\r\n\r\n    1. The \"_RegCheck\" macro is used to ensure that each of the user macros has\r\n       the correct number of parameters.  This improves maintenance reliability,\r\n       as changes to the REG structure need to be reflected only in the\r\n       \"_RegCheck\" macro.\r\n\r\n    2. \"Stringization\" must occur at the first macro call level to support\r\n       register names that are themselves macros.  Otherwise, macro expansion\r\n       will occur before stringization, resulting in the wrong register name.\r\n\r\n    3. Additional REG initialization values may be supplied after a macro\r\n       invocation.  If present, these begin with the \"flags\" field which is,\r\n       for the most part, not specified as a macro parameter.\r\n\r\n    4. The URDATA macro is obsolescent and present for backward-compatibility.\r\n       It is a special case of the generic SRDATA macro, which provides the same\r\n       functionality.  Note also that URDATA requires a \"flags\" parameter value,\r\n       which is optional for all other macros.\r\n\r\n    5. The SAVEDATA macro is useful to indicate global variables whose values\r\n       must persist across a SAVE and RESTORE.  Such data is hidden from the\r\n       register user interface.  Data saved this way may generally not be \r\n       usefully restored when a SAVE and RESTORE operations are done on host\r\n       systems with different endian attributes.\r\n*/\r\n\r\n/* Internal use ONLY (see below) Generic Register declaration for all fields */\r\n#define _RegCheck(nm,loc,rdx,wd,off,dep,desc,flds,qptr,siz,elesiz,macro) \\\r\n    nm, (loc), (rdx), (wd), (off), (dep), (desc), (flds), (qptr), (siz), sizeof(loc), sizeof(*(loc)), (elesiz), #macro, __FILE__, __LINE__\r\n\r\n/* Generic Register declaration for all fields.\r\n   If the register structure is extended, this macro will be retained and a\r\n   new internal macro will be provided that populates the new register structure */\r\n#define REGDATA(nm,loc,rdx,wd,off,dep,desc,flds,fl,qptr,siz) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,desc,flds,qptr,siz,sizeof((loc)),REGDATA),(fl)\r\n/* v3 compatible macro */\r\n#define XRDATA(nm,loc,rdx,wd,off,dep,siz,str) \\\r\n    _RegCheck(#nm,loc,rdx,wd,off,dep,NULL,NULL,0,siz,sizeof((loc)),XRDATA)\r\n#define XRDATAD(nm,loc,rdx,wd,off,dep,siz,str,desc) \\\r\n    _RegCheck(#nm,loc,rdx,wd,off,dep,desc,NULL,0,siz,sizeof((loc)),XRDATAD)\r\n#define XRDATADF(nm,loc,rdx,wd,off,dep,siz,str,desc,flds) \\\r\n    _RegCheck(#nm,loc,rdx,wd,off,dep,desc,flds,0,siz,sizeof((loc)),XRDATADF)\r\n\r\n/* Right Justified Octal Register Data */\r\n#define ORDATA(nm,loc,wd) \\\r\n    _RegCheck(#nm,&(loc),8,wd,0,1,NULL,NULL,0,0,sizeof((loc)),ORDATA)\r\n#define ORDATAD(nm,loc,wd,desc) \\\r\n    _RegCheck(#nm,&(loc),8,wd,0,1,desc,NULL,0,0,sizeof((loc)),ORDATAD)\r\n#define ORDATADF(nm,loc,wd,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),8,wd,0,1,desc,flds,0,0,sizeof((loc)),ORDATADF)\r\n/* Right Justified Decimal Register Data */\r\n#define DRDATA(nm,loc,wd) \\\r\n    _RegCheck(#nm,&(loc),10,wd,0,1,NULL,NULL,0,0,sizeof((loc)),DRDATA)\r\n#define DRDATAD(nm,loc,wd,desc) \\\r\n    _RegCheck(#nm,&(loc),10,wd,0,1,desc,NULL,0,0,sizeof((loc)),DRDATAD)\r\n#define DRDATADF(nm,loc,wd,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),10,wd,0,1,desc,flds,0,0,sizeof((loc)),DRDATADF)\r\n/* Right Justified Hexadecimal Register Data */\r\n#define HRDATA(nm,loc,wd) \\\r\n    _RegCheck(#nm,&(loc),16,wd,0,1,NULL,NULL,0,0,sizeof((loc)),HRDATA)\r\n#define HRDATAD(nm,loc,wd,desc) \\\r\n    _RegCheck(#nm,&(loc),16,wd,0,1,desc,NULL,0,0,sizeof((loc)),HRDATAD)\r\n#define HRDATADF(nm,loc,wd,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),16,wd,0,1,desc,flds,0,0,sizeof((loc)),HRDATADF)\r\n/* Right Justified Binary Register Data */\r\n#define BINRDATA(nm,loc,wd) \\\r\n    _RegCheck(#nm,&(loc),2,wd,0,1,NULL,NULL,0,0,sizeof((loc)),BINRDATA)\r\n#define BINRDATAD(nm,loc,wd,desc) \\\r\n    _RegCheck(#nm,&(loc),2,wd,0,1,desc,NULL,0,0,sizeof((loc)),BINRDATAD)\r\n#define BINRDATADF(nm,loc,wd,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),2,wd,0,1,desc,flds,0,0,sizeof((loc)),BINRDATADF)\r\n/* One-bit binary flag at an arbitrary offset in a 32-bit word Register */\r\n#define FLDATA(nm,loc,pos) \\\r\n    _RegCheck(#nm,&(loc),2,1,pos,1,NULL,NULL,0,0,sizeof((loc)),FLDATA)\r\n#define FLDATAD(nm,loc,pos,desc) \\\r\n    _RegCheck(#nm,&(loc),2,1,pos,1,desc,NULL,0,0,sizeof((loc)),FLDATAD)\r\n#define FLDATADF(nm,loc,pos,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),2,1,pos,1,desc,flds,0,0,sizeof((loc)),FLDATADF)\r\n/* Double Precision Floating Register Data */\r\n#define DBRDATA(nm,loc) \\\r\n    _RegCheck(#nm,&(loc),10,16,0,1,NULL,NULL,0,0,sizeof((loc)),DBRDATA)\r\n#define DBRDATAD(nm,loc,desc) \\\r\n    _RegCheck(#nm,&(loc),10,16,0,1,desc,NULL,0,0,sizeof((loc)),DBRDATAD)\r\n/* Arbitrary location and Radix Register */\r\n#define GRDATA(nm,loc,rdx,wd,pos) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,pos,1,NULL,NULL,0,0,sizeof((loc)),GRDATA)\r\n#define GRDATAD(nm,loc,rdx,wd,pos,desc) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,pos,1,desc,NULL,0,0,sizeof((loc)),GRDATAD)\r\n#define GRDATADF(nm,loc,rdx,wd,pos,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,pos,1,desc,flds,0,0,sizeof((loc)),GRDATADF)\r\n/* Arrayed register whose data is kept in a standard C array Register */\r\n#define BRDATA(nm,aloc,rdx,wd,dep) \\\r\n    _RegCheck(#nm,aloc,rdx,wd,0,dep,NULL,NULL,0,sizeof(*(aloc)),sizeof(*(aloc)),BRDATA)\r\n#define BRDATAD(nm,aloc,rdx,wd,dep,desc) \\\r\n    _RegCheck(#nm,aloc,rdx,wd,0,dep,desc,NULL,0,sizeof(*(aloc)),sizeof(*(aloc)),BRDATAD)\r\n#define BRDATADF(nm,aloc,rdx,wd,dep,desc,flds) \\\r\n    _RegCheck(#nm,aloc,rdx,wd,0,dep,desc,flds,0,sizeof(*(aloc)),sizeof(*(aloc)),BRDATADF)\r\n/* Arrayed register whose data is kept in a standard C two dimensional array Register */\r\n#define CRDATA(nm,aloc,rdx,wd,dep) \\\r\n    _RegCheck(#nm,&(aloc),rdx,wd,0,dep,NULL,NULL,0,sizeof(**(aloc)),sizeof(**(aloc)),CRDATA)\r\n#define CRDATAD(nm,aloc,rdx,wd,dep,desc) \\\r\n    _RegCheck(#nm,&(aloc),rdx,wd,0,dep,desc,NULL,0,sizeof(**(aloc)),sizeof(**(aloc)),CRDATAD)\r\n#define CRDATADF(nm,aloc,rdx,wd,dep,desc,flds) \\\r\n    _RegCheck(#nm,&(aloc),rdx,wd,0,dep,desc,flds,0,sizeof(**(aloc)),sizeof(**(aloc)),CRDATADF)\r\n\r\n/* Range of memory whose data is successive scalar values accessed like an array Register */\r\n#define VBRDATA(nm,loc,rdx,wd,dep) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,0,dep,NULL,NULL,0,wd/8,sizeof(loc),VBRDATA)\r\n#define VBRDATAD(nm,loc,rdx,wd,dep,desc) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,0,dep,desc,NULL,0,wd/8,sizeof(loc),VBRDATAD)\r\n#define VBRDATADF(nm,loc,rdx,wd,dep,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,0,dep,desc,flds,0,wd/8,sizeof(loc),VBRDATADF)\r\n/* Arrayed register whose data is part of the UNIT structure */\r\n#define URDATA(nm,loc,rdx,wd,off,dep,fl) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,NULL,NULL,0,sizeof(UNIT),sizeof((loc)),URDATA),(fl)\r\n#define URDATAD(nm,loc,rdx,wd,off,dep,fl,desc) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,desc,NULL,0,sizeof(UNIT),sizeof((loc)),URDATAD),(fl)\r\n#define URDATADF(nm,loc,rdx,wd,off,dep,fl,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,desc,flds,0,sizeof(UNIT),sizeof((loc)),URDATADF),(fl)\r\n/* Arrayed register whose data is a field in a structure */\r\n#define SRDATA(nm,aloc,floc,rdx,wd,off,dep) \\\r\n    _RegCheck(#nm,&((aloc)->floc),(rdx),(wd),(off),(dep),NULL,NULL,0,sizeof(*(&aloc)),sizeof((aloc)->floc),SRDATA)\r\n#define SRDATAD(nm,aloc,floc,rdx,wd,off,dep,desc) \\\r\n    _RegCheck(#nm,&((aloc)->floc),(rdx),(wd),(off),(dep),desc,NULL,0,sizeof(*(&aloc)),sizeof((aloc)->floc),SRDATAD)\r\n#define SRDATADF(nm,aloc,floc,rdx,wd,off,dep,desc,flds) \\\r\n    _RegCheck(#nm,&((aloc)->floc),(rdx),(wd),(off),(dep),desc,flds,0,sizeof(*(&aloc)),sizeof((aloc)->floc),SRDATADF)\r\n\r\n/* Arrayed register whose data is part of an arbitrary structure */\r\n#define STRDATA(nm,loc,rdx,wd,off,dep,siz,fl) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,NULL,NULL,0,siz,sizeof((loc)),STRDATA),(fl)\r\n#define STRDATAD(nm,loc,rdx,wd,off,dep,siz,fl,desc) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,desc,NULL,0,siz,sizeof((loc)),STRDATAD),(fl)\r\n#define STRDATADF(nm,loc,rdx,wd,off,dep,siz,fl,desc,flds) \\\r\n    _RegCheck(#nm,&(loc),rdx,wd,off,dep,desc,flds,0,siz,sizeof((loc)),STRDATADF),(fl)\r\n/* Hidden Blob of Data - Only used for SAVE/RESTORE */\r\n#define SAVEDATA(nm,loc) \\\r\n    _RegCheck(#nm,&(loc),0,8,0,1,NULL,NULL,0,sizeof(loc),sizeof(loc),SAVEDATA),(REG_HRO)\r\n#define STARTBIT             {\"\",  0x00000000, 0,  NULL, NULL}  /* Start at beginning bit */\r\n#define BIT(nm)              {#nm, 0xffffffff, 1,  NULL, NULL}  /* Single Bit definition */\r\n#define BITNC                {\"\",  0xffffffff, 1,  NULL, NULL}  /* Don't care Bit definition */\r\n#define BITF(nm,sz)          {#nm, 0xffffffff, sz, NULL, NULL}  /* Bit Field definition */\r\n#define BITNCF(sz)           {\"\",  0xffffffff, sz, NULL, NULL}  /* Don't care Bit Field definition */\r\n#define BITFFMT(nm,sz,fmt)   {#nm, 0xffffffff, sz, NULL, #fmt}  /* Bit Field definition with Output format */\r\n#define BITFNAM(nm,sz,names) {#nm, 0xffffffff, sz, names,NULL}  /* Bit Field definition with value->name map */\r\n#define ENDBITS {NULL}  /* end of bitfield list */\r\n\r\n\r\n/* Function prototypes */\r\n\r\n#include \"scp.h\"\r\n#include \"sim_console.h\"\r\n#include \"sim_timer.h\"\r\n#include \"sim_fio.h\"\r\n\r\n/* Macro to ALWAYS execute the specified expression and fail if it evaluates to false. */\r\n/* This replaces any references to \"assert()\" which should never be invoked */\r\n/* with an expression which causes side effects (i.e. must be executed for */\r\n/* the program to work correctly) */\r\n#define ASSURE(_Expression) while (!(_Expression)) {                                    \\\r\n                                char buf[512];                                          \\\r\n                                snprintf(buf, sizeof (buf), \"%s failed\", #_Expression); \\\r\n                                SIM_SCP_ABORT (buf);                                    \\\r\n                                }\r\n#if defined(assert)\r\n#error \"Don't use assert().  It is advised to use ASSURE(expression) instead\"\r\n#else\r\n#define assert(_Expression) do {                                                                                             \\\r\n                                fprintf (stderr, \"Don't use assert().  It is advised to use ASSURE(expression) instead.\\n\"); \\\r\n                                abort();                                                                                     \\\r\n                                } while (1)\r\n#endif\r\n\r\n#if defined(SIM_ASYNCH_IO)\r\n#define AIO_CHECK_EVENT sim_aio_check_event()\r\n#define AIO_SET_INTERRUPT_LATENCY(instpersec) sim_aio_set_interrupt_latency(instpersec)\r\n#else /* !SIM_ASYNCH_IO */\r\n#define AIO_CHECK_EVENT\r\n#define AIO_SET_INTERRUPT_LATENCY(instpersec)\r\n#endif\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_disk.c",
          "type": "blob",
          "size": 352.083984375,
          "content": "/* sim_disk.c: simulator disk support library\r\n\r\n   Copyright (c) 2011, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   MARK PIZZOLATO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the names of Mark Pizzolato shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Mark Pizzolato.\r\n\r\n\r\n\r\n   This is the place which hides processing of various disk formats,\r\n   as well as OS-specific direct hardware access.\r\n\r\n   25-Jan-11    MP      Initial Implementation\r\n\r\nPublic routines:\r\n\r\n   sim_disk_attach           attach disk unit\r\n   sim_disk_attach_ex        attach disk unit extended parameters\r\n   sim_disk_attach_ex2       attach disk unit additional extended parameters\r\n   sim_disk_detach           detach disk unit\r\n   sim_disk_attach_help      help routine for attaching disks\r\n   sim_disk_rdsect           read disk sectors\r\n   sim_disk_rdsect_a         read disk sectors asynchronously\r\n   sim_disk_wrsect           write disk sectors\r\n   sim_disk_wrsect_a         write disk sectors asynchronously\r\n   sim_disk_unload           unload or detach a disk as needed\r\n   sim_disk_reset            reset unit\r\n   sim_disk_wrp              TRUE if write protected\r\n   sim_disk_isavailable      TRUE if available for I/O\r\n   sim_disk_size             get disk size\r\n   sim_disk_set_fmt          set disk format\r\n   sim_disk_show_fmt         show disk format\r\n   sim_disk_set_capac        set disk capacity\r\n   sim_disk_show_capac       show disk capacity\r\n   sim_disk_set_autosize     MTAB set autosize\r\n   sim_disk_show_autosize    MTAB display autosize\r\n   sim_disk_set_autozap      MTAB set autozap\r\n   sim_disk_show_autozap     MTAB display autozap\r\n   sim_disk_set_async        enable asynchronous operation\r\n   sim_disk_clr_async        disable asynchronous operation\r\n   sim_disk_data_trace       debug support\r\n   sim_disk_set_drive_type   MTAB validator routine\r\n   sim_disk_set_drive_type_by_name device reset initialization\r\n   sim_disk_show_drive_type  MTAB display routine\r\n   sim_disk_get_drive_type_set_string set command arguments for the specified unit\r\n   sim_disk_test             unit test routine\r\n\r\nInternal routines:\r\n\r\n   sim_os_disk_open_raw      platform specific open raw device\r\n   sim_os_disk_close_raw     platform specific close raw device\r\n   sim_os_disk_size_raw      platform specific raw device size\r\n   sim_os_disk_unload_raw    platform specific disk unload/eject\r\n   sim_os_disk_rdsect        platform specific read sectors\r\n   sim_os_disk_wrsect        platform specific write sectors\r\n\r\n   sim_vhd_disk_open         platform independent open virtual disk file\r\n   sim_vhd_disk_create       platform independent create virtual disk file\r\n   sim_vhd_disk_create_diff  platform independent create differencing virtual disk file\r\n   sim_vhd_disk_close        platform independent close virtual disk file\r\n   sim_vhd_disk_size         platform independent virtual disk size\r\n   sim_vhd_CHS               platform independent virtual disk size CHS value\r\n   sim_vhd_disk_parent_path  platform independent differencing virtual disk parent path\r\n   sim_vhd_disk_rdsect       platform independent read virtual disk sectors\r\n   sim_vhd_disk_wrsect       platform independent write virtual disk sectors\r\n\r\n   sim_disk_find_type        locate DRVTYP of named disk type\r\n\r\n*/\r\n\r\n#define _FILE_OFFSET_BITS 64    /* 64 bit file offset for raw I/O operations  */\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_disk.h\"\r\n#include \"sim_ether.h\"\r\n#include \"sim_scsi.h\"\r\n\r\n#include \"sim_scp_private.h\"\r\n\r\n#define DKUF_F_AUTO      0                              /* Auto detect format format */\r\n#define DKUF_F_STD       1                              /* SIMH format */\r\n#define DKUF_F_RAW       2                              /* Raw Physical Disk Access */\r\n#define DKUF_F_VHD       3                              /* VHD format */\r\n\r\n#define DKUF_E_AUTO      0                              /* Auto detect encoding */\r\n#define DKUF_E_DLD9      1                              /* KLH10 packed 36bit little endian word */\r\n#define DKUF_E_DBD9      2                              /* KLH10 packed 36bit big endian word */\r\n\r\n#define DK_GET_FMT(u)   (((u)->flags >> DKUF_V_FMT) & DKUF_M_FMT)\r\n#define DK_GET_ENC(u)   (((u)->flags >> DKUF_V_ENC) & DKUF_M_ENC)\r\n\r\n#if defined SIM_ASYNCH_IO\r\n#include <pthread.h>\r\n#endif\r\n\r\nstatic t_bool sim_disk_check_attached_container (const char *filename, UNIT **auptr);\r\n\r\n\r\n/* Newly created SIMH (and possibly RAW) disk containers       */\r\n/* will have this data as the last 512 bytes of the container  */\r\n/* It will not be considered part of the data in the container */\r\n/* Previously existing containers will have this appended to   */\r\n/* the end of the container if they are opened for write       */\r\nstruct simh_disk_footer {\r\n    uint8       Signature[4];           /* must be 'simh' */\r\n    uint8       CreatingSimulator[64];  /* name of simulator */\r\n    uint8       DriveType[16];\r\n    uint32      SectorSize;\r\n    uint32      SectorCount;\r\n    uint32      ElementEncodingSize;\r\n    uint8       CreationTime[28];       /* Result of ctime() */\r\n    uint8       FooterVersion;          /* Initially 0 */\r\n#define FOOTER_VERSION  1\r\n    uint8       AccessFormat;           /* 1 - SIMH, 2 - RAW */\r\n    uint8       Reserved[342];          /* Currently unused */\r\n    uint32      Geometry;               /* CHS (Cylinders, Heads and Sectors) */\r\n    uint32      DataWidth;              /* Data Width in the Transfer Size */\r\n    uint32      MediaID;                /* Media ID */\r\n    uint8       DeviceName[16];         /* Name of the Device when created */\r\n    uint32      Highwater[2];           /* Size before footer addition or furthest container point written */\r\n    uint32      Unused;                 /* Currently unused */\r\n    uint32      Checksum;               /* CRC32 of the prior 508 bytes */\r\n    };\r\n\r\n/* OS Independent Disk Virtual Disk (VHD) I/O support */\r\n\r\n#if (defined (VMS) && !(defined (__ALPHA) || defined (__ia64)))\r\n#define DONT_DO_VHD_SUPPORT  /* VAX/VMS compilers don't have 64 bit integers */\r\n#endif\r\n\r\n#if defined(_WIN32) || defined (__ALPHA) || defined (__ia64) || defined (VMS)\r\n#ifndef __BYTE_ORDER__\r\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\r\n#endif\r\n#endif\r\n#ifndef __BYTE_ORDER__\r\n#define __BYTE_ORDER__ UNKNOWN\r\n#endif\r\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\r\nstatic uint32\r\nNtoHl(uint32 value)\r\n{\r\nuint8 *l = (uint8 *)&value;\r\nreturn (uint32)l[3] | ((uint32)l[2]<<8) | ((uint32)l[1]<<16) | ((uint32)l[0]<<24);\r\n}\r\n#elif  __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\r\nstatic uint32\r\nNtoHl(uint32 value)\r\n{\r\nreturn value;\r\n}\r\n#else\r\nstatic uint32\r\nNtoHl(uint32 value)\r\n{\r\nuint8 *l = (uint8 *)&value;\r\n\r\nif (sim_end)\r\n    return l[3] | (l[2]<<8) | (l[1]<<16) | (l[0]<<24);\r\nreturn value;\r\n}\r\n#endif\r\n\r\nstruct disk_context {\r\n    t_offset            container_size;     /* Size of the data portion (of the pseudo disk) */\r\n    t_offset            highwater;          /* Furthest written sector in the disk */\r\n    DEVICE              *dptr;              /* Device for unit (access to debug flags) */\r\n    uint32              dbit;               /* debugging bit */\r\n    uint32              sector_size;        /* Disk Sector Size (of the pseudo disk) */\r\n    uint32              capac_factor;       /* Units of Capacity (8 = quadword, 2 = word, 1 = byte) */\r\n    uint32              xfer_encode_size;   /* Disk Bus Transfer size (1 - byte, 2 - word, 4 - longword) */\r\n    uint32              storage_sector_size;/* Sector size of the containing storage */\r\n\r\n    uint32              removable;          /* Removable device flag */\r\n    uint32              media_id;           /* MediaID of the container */\r\n    uint32              is_cdrom;           /* Host system CDROM Device */\r\n    uint32              media_removed;      /* Media not available flag */\r\n    uint32              auto_format;        /* Format determined dynamically */\r\n    uint32              read_count;         /* Number of read operations performed */\r\n    uint32              write_count;        /* Number of write operations performed */\r\n    uint32              data_ileave;        /* Data sectors interleaved in container */\r\n    uint32              data_ileave_skew;   /* Data sectors track skew in container */\r\n    DRVTYP              *initial_drvtyp;    /* Unit Drive Type before any autosize */\r\n    t_addr              initial_capac;      /* Unit Capacity before any autosize */\r\n    struct simh_disk_footer\r\n                        *footer;\r\n#if defined _WIN32\r\n    HANDLE              disk_handle;        /* OS specific Raw device handle */\r\n#endif\r\n#if defined SIM_ASYNCH_IO\r\n    int                 asynch_io;          /* Asynchronous Interrupt scheduling enabled */\r\n    int                 asynch_io_latency;  /* instructions to delay pending interrupt */\r\n    pthread_mutex_t     lock;\r\n    pthread_t           io_thread;          /* I/O Thread Id */\r\n    pthread_mutex_t     io_lock;\r\n    pthread_cond_t      io_cond;\r\n    pthread_cond_t      io_done;\r\n    pthread_cond_t      startup_cond;\r\n    int                 io_dop;\r\n    uint8               *buf;\r\n    t_seccnt            *rsects;\r\n    t_seccnt            sects;\r\n    t_lba               lba;\r\n    DISK_PCALLBACK      callback;\r\n    t_stat              io_status;\r\n#endif\r\n    };\r\n\r\n#define disk_ctx up8                        /* Field in Unit structure which points to the disk_context */\r\n\r\n#if defined SIM_ASYNCH_IO\r\n#define AIO_CALLSETUP                                               \\\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;   \\\r\n                                                                    \\\r\nif ((!callback) || !ctx->asynch_io)\r\n\r\n#define AIO_CALL(op, _lba, _buf, _rsects, _sects,  _callback)   \\\r\n    if (ctx->asynch_io) {                                       \\\r\n        struct disk_context *ctx =                              \\\r\n                      (struct disk_context *)uptr->disk_ctx;    \\\r\n                                                                \\\r\n        pthread_mutex_lock (&ctx->io_lock);                     \\\r\n                                                                \\\r\n        sim_debug_unit (ctx->dbit, uptr,                        \\\r\n      \"sim_disk AIO_CALL(op=%d, unit=%d, lba=0x%X, sects=%d)\\n\",\\\r\n                op, (int)(uptr - ctx->dptr->units), _lba, _sects);\\\r\n                                                                \\\r\n        if (ctx->callback)      /* horrible mistake, stop */    \\\r\n            SIM_SCP_ABORT (\"AIO_CALL error\");                   \\\r\n        ctx->io_dop = op;                                       \\\r\n        ctx->lba = _lba;                                        \\\r\n        ctx->buf = _buf;                                        \\\r\n        ctx->sects = _sects;                                    \\\r\n        ctx->rsects = _rsects;                                  \\\r\n        ctx->callback = _callback;                              \\\r\n        pthread_cond_signal (&ctx->io_cond);                    \\\r\n        pthread_mutex_unlock (&ctx->io_lock);                   \\\r\n        }                                                       \\\r\n    else                                                        \\\r\n        if (_callback)                                          \\\r\n            (_callback) (uptr, r);\r\n\r\n\r\n#define DOP_DONE  0             /* close */\r\n#define DOP_RSEC  1             /* sim_disk_rdsect_a */\r\n#define DOP_WSEC  2             /* sim_disk_wrsect_a */\r\n#define DOP_IAVL  3             /* sim_disk_isavailable_a */\r\n\r\nstatic void *\r\n_disk_io(void *arg)\r\n{\r\nUNIT* volatile uptr = (UNIT*)arg;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\n/* Boost Priority for this I/O thread vs the CPU instruction execution\r\n   thread which in general won't be readily yielding the processor when\r\n   this thread needs to run */\r\nsim_os_set_thread_priority (PRIORITY_ABOVE_NORMAL);\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"_disk_io(unit=%d) starting\\n\", (int)(uptr - ctx->dptr->units));\r\n\r\npthread_mutex_lock (&ctx->io_lock);\r\npthread_cond_signal (&ctx->startup_cond);   /* Signal we're ready to go */\r\nwhile (ctx->asynch_io) {\r\n    pthread_cond_wait (&ctx->io_cond, &ctx->io_lock);\r\n    if (ctx->io_dop == DOP_DONE)\r\n        break;\r\n    pthread_mutex_unlock (&ctx->io_lock);\r\n    switch (ctx->io_dop) {\r\n        case DOP_RSEC:\r\n            ctx->io_status = sim_disk_rdsect (uptr, ctx->lba, ctx->buf, ctx->rsects, ctx->sects);\r\n            break;\r\n        case DOP_WSEC:\r\n            ctx->io_status = sim_disk_wrsect (uptr, ctx->lba, ctx->buf, ctx->rsects, ctx->sects);\r\n            break;\r\n        case DOP_IAVL:\r\n            ctx->io_status = sim_disk_isavailable (uptr);\r\n            break;\r\n        }\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n    ctx->io_dop = DOP_DONE;\r\n    pthread_cond_signal (&ctx->io_done);\r\n    sim_activate (uptr, ctx->asynch_io_latency);\r\n    }\r\npthread_mutex_unlock (&ctx->io_lock);\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"_disk_io(unit=%d) exiting\\n\", (int)(uptr - ctx->dptr->units));\r\n\r\nreturn NULL;\r\n}\r\n\r\n/* This routine is called in the context of the main simulator thread before\r\n   processing events for any unit. It is only called when an asynchronous\r\n   thread has called sim_activate() to activate a unit.  The job of this\r\n   routine is to put the unit in proper condition to digest what may have\r\n   occurred in the asynchronous thread.\r\n\r\n   Since disk processing only handles a single I/O at a time to a\r\n   particular disk device (due to using stdio for the SimH Disk format\r\n   and stdio doesn't have an atomic seek+(read|write) operation),\r\n   we have the opportunity to possibly detect improper attempts to\r\n   issue multiple concurrent I/O requests. */\r\nstatic void _disk_completion_dispatch (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nDISK_PCALLBACK callback = ctx->callback;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"_disk_completion_dispatch(unit=%d, dop=%d, callback=%p)\\n\", (int)(uptr - ctx->dptr->units), ctx->io_dop, (void *)(ctx->callback));\r\n\r\nif (ctx->io_dop != DOP_DONE)\r\n    SIM_SCP_ABORT (\"_disk_completion_dispatch()\"); /* horribly wrong, stop */\r\n\r\nif (ctx->callback && ctx->io_dop == DOP_DONE) {\r\n    ctx->callback = NULL;\r\n    callback (uptr, ctx->io_status);\r\n    }\r\n}\r\n\r\nstatic t_bool _disk_is_active (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nif (ctx) {\r\n    sim_debug_unit (ctx->dbit, uptr, \"_disk_is_active(unit=%d, dop=%d)\\n\", (int)(uptr - ctx->dptr->units), ctx->io_dop);\r\n    return (ctx->io_dop != DOP_DONE);\r\n    }\r\nreturn FALSE;\r\n}\r\n\r\nstatic t_bool _disk_cancel (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nif (ctx) {\r\n    sim_debug_unit (ctx->dbit, uptr, \"_disk_cancel(unit=%d, dop=%d)\\n\", (int)(uptr - ctx->dptr->units), ctx->io_dop);\r\n    if (ctx->asynch_io) {\r\n        pthread_mutex_lock (&ctx->io_lock);\r\n        while (ctx->io_dop != DOP_DONE)\r\n            pthread_cond_wait (&ctx->io_done, &ctx->io_lock);\r\n        pthread_mutex_unlock (&ctx->io_lock);\r\n        }\r\n    }\r\nreturn FALSE;\r\n}\r\n#else\r\n#define AIO_CALLSETUP\r\n#define AIO_CALL(op, _lba, _buf, _rsects, _sects,  _callback)   \\\r\n    if (_callback)                                              \\\r\n        (_callback) (uptr, r);\r\n#endif\r\n\r\n/* Forward declarations */\r\n\r\nstatic t_stat sim_vhd_disk_implemented (void);\r\nstatic FILE *sim_vhd_disk_open (const char *rawdevicename, const char *openmode);\r\nstatic FILE *sim_vhd_disk_create (const char *szVHDPath, t_offset desiredsize, DRVTYP *drvtyp);\r\nstatic FILE *sim_vhd_disk_create_diff (const char *szVHDPath, const char *szParentVHDPath);\r\nstatic FILE *sim_vhd_disk_merge (const char *szVHDPath, char **ParentVHD);\r\nstatic int sim_vhd_disk_close (FILE *f);\r\nstatic void sim_vhd_disk_flush (FILE *f);\r\nstatic t_offset sim_vhd_disk_size (FILE *f);\r\nstatic uint32 sim_vhd_CHS (FILE *f);\r\nstatic const char *sim_vhd_disk_parent_path (FILE *f);\r\nstatic t_stat sim_vhd_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects);\r\nstatic t_stat sim_vhd_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects);\r\nstatic t_stat sim_vhd_disk_clearerr (UNIT *uptr);\r\nstatic t_stat sim_vhd_disk_set_dtype (FILE *f, const char *dtype, uint32 SectorSize, uint32 xfer_encode_size, uint32 media_id, const char *device_name, uint32 data_width, DRVTYP *drvtyp);\r\nstatic const char *sim_vhd_disk_get_dtype (FILE *f, uint32 *SectorSize, uint32 *xfer_encode_size, char sim_name[64], time_t *creation_time, uint32 *media_id, char device_name[16], uint32 *data_width);\r\nstatic DRVTYP *sim_disk_find_type (UNIT *uptr, const char *dtype);\r\nuint32 sim_disk_drvtype_geometry (DRVTYP *drvtyp, uint32 totalSectors);\r\nstatic uint32 sim_SectorsToCHS (uint32 totalSectors);\r\nstatic t_stat sim_os_disk_implemented_raw (void);\r\nstatic FILE *sim_os_disk_open_raw (const char *rawdevicename, const char *openmode);\r\nstatic int sim_os_disk_close_raw (FILE *f);\r\nstatic void sim_os_disk_flush_raw (FILE *f);\r\nstatic t_offset sim_os_disk_size_raw (FILE *f);\r\nstatic t_stat sim_os_disk_unload_raw (FILE *f);\r\nstatic t_bool sim_os_disk_isavailable_raw (FILE *f);\r\nstatic t_stat sim_os_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects);\r\nstatic t_stat sim_os_disk_read (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *bytesread, uint32 bytes);\r\nstatic t_stat sim_os_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects);\r\nstatic t_stat sim_os_disk_write (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *byteswritten, uint32 bytes);\r\nstatic t_stat sim_os_disk_info_raw (FILE *f, uint32 *sector_size, uint32 *removable, uint32 *is_cdrom);\r\nstatic char *HostPathToVhdPath (const char *szHostPath, char *szVhdPath, size_t VhdPathSize);\r\nstatic char *VhdPathToHostPath (const char *szVhdPath, char *szHostPath, size_t HostPathSize);\r\nstatic t_offset get_filesystem_size (UNIT *uptr, t_bool *isreadonly);\r\n\r\nstruct sim_disk_fmt {\r\n    const char          *name;                          /* name */\r\n    int32               uflags;                         /* unit flags */\r\n    int32               fmtval;                         /* Format type value */\r\n    uint32              encode;                         /* Data Encode Default - 0 means take from attach parameter */\r\n    t_stat              (*impl_fnc)(void);              /* Implemented Test Function */\r\n    };\r\n\r\nstatic struct sim_disk_fmt fmts[] = {\r\n    { \"AUTO detect\", 0, DKUF_F_AUTO,     0,                 NULL},\r\n    { \"SIMH\",        0, DKUF_F_STD,      0,                 NULL},\r\n    { \"RAW\",         0, DKUF_F_RAW,      0,                 sim_os_disk_implemented_raw},\r\n    { \"VHD\",         0, DKUF_F_VHD,      0,                 sim_vhd_disk_implemented},\r\n    { NULL,          0, 0,               0,                 NULL}\r\n    };\r\n\r\n/* Set disk format */\r\n\r\nt_stat sim_disk_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nuint32 f;\r\n\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nif ((cptr == NULL) || (*cptr == '\\0'))\r\n    return SCPE_ARG;\r\nfor (f = 0; fmts[f].name; f++) {\r\n    if (fmts[f].name && (MATCH_CMD (cptr, fmts[f].name) == 0)) {\r\n        if ((fmts[f].impl_fnc) && (fmts[f].impl_fnc() != SCPE_OK))\r\n            return SCPE_NOFNC;\r\n        uptr->flags = (uptr->flags & ~DKUF_FMT) |\r\n            (fmts[f].fmtval << DKUF_V_FMT) | fmts[f].uflags;\r\n        if (fmts[f].fmtval == DKUF_F_AUTO)\r\n            uptr->flags = (uptr->flags & ~DKUF_ENC) | (DKUF_E_AUTO << DKUF_V_ENC);\r\n        return SCPE_OK;\r\n        }\r\n    }\r\nif (MATCH_CMD (cptr, \"DLD9\") == 0) {\r\n    if (DK_GET_FMT (uptr) == DKUF_F_AUTO)\r\n        uptr->flags = (uptr->flags & ~DKUF_FMT) |\r\n            (DKUF_F_STD << DKUF_V_FMT) | fmts[f].uflags;\r\n    uptr->flags = (uptr->flags & ~DKUF_ENC) | (DKUF_E_DLD9 << DKUF_V_ENC);\r\n    return SCPE_OK;\r\n    }\r\nif (MATCH_CMD (cptr, \"DBD9\") == 0) {\r\n    if (DK_GET_FMT (uptr) == DKUF_F_AUTO)\r\n        uptr->flags = (uptr->flags & ~DKUF_FMT) |\r\n            (DKUF_F_STD << DKUF_V_FMT) | fmts[f].uflags;\r\n    uptr->flags = (uptr->flags & ~DKUF_ENC) | (DKUF_E_DBD9 << DKUF_V_ENC);\r\n    return SCPE_OK;\r\n    }\r\nreturn sim_messagef (SCPE_ARG, \"Unknown disk format: %s\\n\", cptr);\r\n}\r\n\r\n/* Show disk format */\r\n\r\nstatic const char *sim_disk_fmt (UNIT *uptr)\r\n{\r\nint32 f = DK_GET_FMT (uptr);\r\nstatic char fmt_buf[32];\r\nstatic const char *encodings[] = {\"\", \"DLD9\", \"DBD9\", \"\"};\r\nsize_t i;\r\n\r\nfor (i = 0; fmts[i].name; i++)\r\n    if (fmts[i].fmtval == f) {\r\n        snprintf (fmt_buf, sizeof (fmt_buf), \"%s%s%s\", fmts[i].name, (DK_GET_ENC (uptr) > DKUF_E_AUTO) ? \"-\" : \"\", encodings[DK_GET_ENC (uptr)]);\r\n        return fmt_buf;\r\n        }\r\nreturn \"invalid\";\r\n}\r\n\r\nt_stat sim_disk_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nfprintf (st, \"%s format\", sim_disk_fmt (uptr));\r\nreturn SCPE_OK;\r\n}\r\n\r\nconst char *_disk_tranfer_encoding (uint32 val)\r\n{\r\nstatic char encoding[128];\r\n\r\nswitch (val) {\r\n    case 0:\r\n        snprintf (encoding, sizeof (encoding), \"Unexpected packing/encoding missing (i.e. 0)\");\r\n        break;\r\n    case 1:\r\n    case 2:\r\n    case 4:\r\n    case 8:\r\n        snprintf (encoding, sizeof (encoding), \"%u bytes in and out\", val);\r\n        break;\r\n    case DK_ENC_LL_DLD9:\r\n        snprintf (encoding, sizeof (encoding), \"DLD9: 36bits on disk (little endian order) to 64bits in memory\");\r\n        break;\r\n    case DK_ENC_LL_DBD9:\r\n        snprintf (encoding, sizeof (encoding), \"DBD9: 36bits on disk (big endian order) to 64bits in memory\");\r\n        break;\r\n    default:\r\n        snprintf (encoding, sizeof (encoding), \"Unexpected encoding: %u bits on disk packed %s endian order to %u bits in memory %s endian order\",\r\n                                    (val >> DK_ENC_XFR_IN) & 0x7F, ((val >> DK_ENC_XFR_IN) & DK_ENC_X_LSB) ? \"little\" : \"big\",\r\n                                    (val >> DK_ENC_XFR_OUT) & 0x7F, ((val >> DK_ENC_XFR_OUT) & DK_ENC_X_LSB) ? \"little\" : \"big\");\r\n        break;\r\n    }\r\nreturn encoding;\r\n}\r\n\r\n/* Set disk capacity */\r\n\r\nt_stat sim_disk_set_capac (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nt_offset cap;\r\nt_stat r;\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_ARG;\r\nif (uptr->flags & UNIT_ATT)\r\n    return SCPE_ALATT;\r\ncap = (t_offset) get_uint (cptr, 10, sim_taddr_64? 2000000: 2000, &r);\r\nif (r != SCPE_OK)\r\n    return SCPE_ARG;\r\nuptr->capac = (t_addr)((cap * ((t_offset) 1000000))/((dptr->flags & DEV_SECTORS) ? 512 : 1));\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show disk capacity */\r\n\r\nt_stat sim_disk_show_capac (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nconst char *cap_units = \"B\";\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\nt_offset capac = ((t_offset)uptr->capac)*((dptr->flags & DEV_SECTORS) ? 512 : 1);\r\n\r\nif ((dptr->dwidth / dptr->aincr) == 16)\r\n    cap_units = \"W\";\r\nif (capac) {\r\n    if (capac >= (t_offset) 1000000)\r\n        fprintf (st, \"capacity=%dM%s\", (uint32) (capac / ((t_offset) 1000000)), cap_units);\r\n    else if (uptr->capac >= (t_addr) 1000)\r\n        fprintf (st, \"capacity=%dK%s\", (uint32) (capac / ((t_offset) 1000)), cap_units);\r\n    else fprintf (st, \"capacity=%d%s\", (uint32) capac, cap_units);\r\n    }\r\nelse fprintf (st, \"undefined capacity\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Test for available */\r\n\r\nt_bool sim_disk_isavailable (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx;\r\nt_bool is_available;\r\n\r\nif (!(uptr->flags & UNIT_ATT))                          /* attached? */\r\n    return FALSE;\r\nctx = (struct disk_context *)uptr->disk_ctx;\r\nswitch (DK_GET_FMT (uptr)) {                            /* case on format */\r\n    case DKUF_F_STD:                                    /* SIMH format */\r\n        is_available = TRUE;\r\n        break;\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        is_available = TRUE;\r\n        break;\r\n    case DKUF_F_RAW:                                    /* Raw Physical Disk Access */\r\n        if (sim_os_disk_isavailable_raw (uptr->fileref)) {\r\n            if (ctx->media_removed) {\r\n                int32 saved_switches = sim_switches;\r\n                int32 saved_quiet = sim_quiet;\r\n                char *path = (char *)malloc (1 + strlen (uptr->filename));\r\n\r\n                sim_switches = 0;\r\n                sim_quiet = 1;\r\n                strcpy (path, uptr->filename);\r\n                sim_disk_attach (uptr, path, ctx->sector_size, ctx->xfer_encode_size,\r\n                                 FALSE, ctx->dbit, NULL, 0, 0);\r\n                sim_quiet = saved_quiet;\r\n                sim_switches = saved_switches;\r\n                free (path);\r\n                ctx->media_removed = 0;\r\n                }\r\n            }\r\n        else\r\n            ctx->media_removed = 1;\r\n        is_available = !ctx->media_removed;\r\n        break;\r\n    default:\r\n        is_available = FALSE;\r\n        break;\r\n    }\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_isavailable(unit=%d)=%s\\n\", (int)(uptr - ctx->dptr->units), is_available ? \"true\" : \"false\");\r\nreturn is_available;\r\n}\r\n\r\nt_bool sim_disk_isavailable_a (UNIT *uptr, DISK_PCALLBACK callback)\r\n{\r\nt_bool r = FALSE;\r\nAIO_CALLSETUP\r\n    r = sim_disk_isavailable (uptr);\r\nAIO_CALL(DOP_IAVL, 0, NULL, NULL, 0, callback);\r\nreturn r;\r\n}\r\n\r\nt_stat sim_disk_set_all_noautosize (int32 flag, CONST char *cptr)\r\n{\r\nDEVICE *dptr;\r\nuint32 dev, unit, count = 0;\r\nint32 saved_sim_show_message = sim_show_message;\r\n\r\nsim_show_message = FALSE;\r\nfor (dev = 0; (dptr = sim_devices[dev]) != NULL; dev++) {\r\n    t_bool device_disabled = ((dptr->flags & DEV_DIS) != 0);\r\n\r\n    if ((DEV_TYPE (dptr) != DEV_DISK) &&\r\n        (DEV_TYPE (dptr) != DEV_SCSI))                          /* If not a sim_disk device? */\r\n        continue;                                               /*   skip this device */\r\n\r\n    if (device_disabled)\r\n        dptr->flags &= ~DEV_DIS;                                /* Temporarily enable device */\r\n    ++count;\r\n    for (unit = 0; unit < dptr->numunits; unit++) {\r\n        char cmd[CBUFSIZE];\r\n        t_bool unit_disabled = ((dptr->units[unit].flags & UNIT_DIS) != 0);\r\n\r\n        if (unit_disabled &&                                    /* disabled and */\r\n            ((dptr->units[unit].flags & UNIT_DISABLE) == 0))    /* can't be enabled? */\r\n             continue;                                          /*  Not a drive unit, so skip. */\r\n\r\n        if (unit_disabled)\r\n            dptr->units[unit].flags &= ~UNIT_DIS;               /* Temporarily enable unit */\r\n        sprintf (cmd, \"%s %sAUTOSIZE\", sim_uname (&dptr->units[unit]), (flag != 0) ? \"NO\" : \"\");\r\n        set_cmd (0, cmd);\r\n        if (unit_disabled)\r\n            dptr->units[unit].flags |= ~UNIT_DIS;               /* leave unit disabled again */\r\n        }\r\n    if (device_disabled)\r\n        dptr->flags |= DEV_DIS;                                 /* leave device the way we found it */\r\n    }\r\nsim_show_message = saved_sim_show_message;\r\nif (count == 0)\r\n    return sim_messagef (SCPE_ARG, \"No disk devices support autosizing\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set disk autosize */\r\n\r\nt_stat sim_disk_set_autosize (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nif ((uptr->drvtyp != NULL) &&\r\n    (DRVFL_GET_IFTYPE(uptr->drvtyp) == DRVFL_TYPE_SCSI) &&\r\n    (uptr->drvtyp->devtype == SCSI_TAPE))\r\n    return sim_messagef (SCPE_NOFNC, \"%s: Autosizing Tapes is not supported\\n\", sim_uname (uptr));\r\nif (cptr != NULL)\r\n    return sim_messagef (SCPE_ARG, \"%s: Unexpected autosize argument: %s\\n\", sim_uname (uptr), cptr);\r\nif (((uptr->flags & UNIT_ATT) != 0) && ((uptr->drvtyp == NULL) || ((uptr->drvtyp->flags & DRVFL_DETAUTO) == 0)))\r\n    return sim_messagef (SCPE_ALATT, \"%s: Disk already attached, autosizing not changed\\n\", sim_uname (uptr));\r\nif (val ^ ((uptr->flags & DKUF_NOAUTOSIZE) != 0))\r\n    return SCPE_OK;\r\nif (val)\r\n    uptr->flags &= ~DKUF_NOAUTOSIZE;\r\nelse\r\n    uptr->flags |= DKUF_NOAUTOSIZE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show disk autosize */\r\n\r\nt_stat sim_disk_show_autosize (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nif ((uptr->drvtyp != NULL) &&\r\n    (DRVFL_GET_IFTYPE(uptr->drvtyp) == DRVFL_TYPE_SCSI) &&\r\n    (uptr->drvtyp->devtype == SCSI_TAPE))\r\n    return SCPE_NOFNC;\r\nfprintf (st, \"%sautosize\", ((uptr->flags & DKUF_NOAUTOSIZE) != 0) ? \"no\" : \"\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_set_all_autozap (int32 flag, CONST char *cptr)\r\n{\r\nDEVICE *dptr;\r\nuint32 dev, unit, count = 0;\r\nint32 saved_sim_show_message = sim_show_message;\r\n\r\nsim_show_message = FALSE;\r\nfor (dev = 0; (dptr = sim_devices[dev]) != NULL; dev++) {\r\n    t_bool device_disabled = ((dptr->flags & DEV_DIS) != 0);\r\n\r\n    if ((DEV_TYPE (dptr) != DEV_DISK) &&\r\n        (DEV_TYPE (dptr) != DEV_SCSI))                          /* If not a sim_disk device? */\r\n        continue;                                               /*   skip this device */\r\n\r\n    if (device_disabled)\r\n        dptr->flags &= ~DEV_DIS;                                /* Temporarily enable device */\r\n    ++count;\r\n    for (unit = 0; unit < dptr->numunits; unit++) {\r\n        char cmd[CBUFSIZE];\r\n        t_bool unit_disabled = ((dptr->units[unit].flags & UNIT_DIS) != 0);\r\n\r\n        if (unit_disabled &&                                    /* disabled and */\r\n            ((dptr->units[unit].flags & UNIT_DISABLE) == 0))    /* can't be enabled? */\r\n             continue;                                          /*  Not a drive unit, so skip. */\r\n\r\n        if (unit_disabled)\r\n            dptr->units[unit].flags &= ~UNIT_DIS;               /* Temporarily enable unit */\r\n        sprintf (cmd, \"%s %sAUTOZAP\", sim_uname (&dptr->units[unit]), (flag != 0) ? \"\" : \"NO\");\r\n        set_cmd (0, cmd);\r\n        if (unit_disabled)\r\n            dptr->units[unit].flags |= ~UNIT_DIS;               /* leave unit disabled again */\r\n        }\r\n    if (device_disabled)\r\n        dptr->flags |= DEV_DIS;                                 /* leave device the way we found it */\r\n    }\r\nsim_show_message = saved_sim_show_message;\r\nif (count == 0)\r\n    return sim_messagef (SCPE_ARG, \"No disk devices in the %s simulator support autozap\\n\", sim_name);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set disk autozap */\r\n\r\nt_stat sim_disk_set_autozap (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nif ((uptr->drvtyp != NULL) &&\r\n    (DRVFL_GET_IFTYPE(uptr->drvtyp) == DRVFL_TYPE_SCSI) &&\r\n    (uptr->drvtyp->devtype == SCSI_TAPE))\r\n    return sim_messagef (SCPE_NOFNC, \"%s: Autozapping Tapes is not supported\\n\", sim_uname (uptr));\r\nif (cptr != NULL)\r\n    return sim_messagef (SCPE_ARG, \"%s: Unexpected autozap argument: %s\\n\", sim_uname (uptr), cptr);\r\nif (val ^ ((uptr->flags & DKUF_AUTOZAP) == 0))\r\n    return SCPE_OK;\r\nif (val)\r\n    uptr->flags |= DKUF_AUTOZAP;\r\nelse\r\n    uptr->flags &= ~DKUF_AUTOZAP;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show disk autozap */\r\n\r\nt_stat sim_disk_show_autozap (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nif ((uptr->drvtyp != NULL) &&\r\n    (DRVFL_GET_IFTYPE(uptr->drvtyp) == DRVFL_TYPE_SCSI) &&\r\n    (uptr->drvtyp->devtype == SCSI_TAPE))\r\n    return SCPE_NOFNC;\r\nfprintf (st, \"%sautozap\", ((uptr->flags & DKUF_AUTOZAP) != 0) ? \"\" : \"no\" );\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Test for write protect */\r\n\r\nt_bool sim_disk_wrp (UNIT *uptr)\r\n{\r\nreturn (uptr->flags & DKUF_WRP)? TRUE: FALSE;\r\n}\r\n\r\n/* Get Disk size */\r\n\r\nt_offset sim_disk_size (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_offset physical_size, filesystem_size;\r\nt_bool saved_quiet = sim_quiet;\r\n\r\nif ((uptr->flags & UNIT_ATT) == 0)\r\n    return (t_offset)-1;\r\nphysical_size = ctx->container_size;\r\nsim_quiet = TRUE;\r\nfilesystem_size = get_filesystem_size (uptr, NULL);\r\nsim_quiet = saved_quiet;\r\nif ((filesystem_size == (t_offset)-1) ||\r\n    (filesystem_size < physical_size))\r\n    return physical_size;\r\nreturn filesystem_size;\r\n}\r\n\r\n/* Enable asynchronous operation */\r\n\r\nt_stat sim_disk_set_async (UNIT *uptr, int latency)\r\n{\r\n#if !defined(SIM_ASYNCH_IO)\r\nchar *msg = \"Disk: cannot operate asynchronously\\r\\n\";\r\nsim_printf (\"%s\", msg);\r\nreturn SCPE_NOFNC;\r\n#else\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\npthread_attr_t attr;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_set_async(unit=%d)\\n\", (int)(uptr - ctx->dptr->units));\r\n\r\nctx->asynch_io = sim_asynch_enabled;\r\nctx->asynch_io_latency = latency;\r\nif (ctx->asynch_io) {\r\n    pthread_mutex_init (&ctx->io_lock, NULL);\r\n    pthread_cond_init (&ctx->io_cond, NULL);\r\n    pthread_cond_init (&ctx->io_done, NULL);\r\n    pthread_cond_init (&ctx->startup_cond, NULL);\r\n    pthread_attr_init(&attr);\r\n    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n    pthread_create (&ctx->io_thread, &attr, _disk_io, (void *)uptr);\r\n    pthread_attr_destroy(&attr);\r\n    pthread_cond_wait (&ctx->startup_cond, &ctx->io_lock); /* Wait for thread to stabilize */\r\n    pthread_mutex_unlock (&ctx->io_lock);\r\n    pthread_cond_destroy (&ctx->startup_cond);\r\n    }\r\nuptr->a_check_completion = _disk_completion_dispatch;\r\nuptr->a_is_active = _disk_is_active;\r\nuptr->cancel = _disk_cancel;\r\nreturn SCPE_OK;\r\n#endif\r\n}\r\n\r\n/* Disable asynchronous operation */\r\n\r\nt_stat sim_disk_clr_async (UNIT *uptr)\r\n{\r\n#if !defined(SIM_ASYNCH_IO)\r\nreturn SCPE_NOFNC;\r\n#else\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\n/* make sure device exists */\r\nif (!ctx) return SCPE_UNATT;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_clr_async(unit=%d)\\n\", (int)(uptr - ctx->dptr->units));\r\n\r\nif (ctx->asynch_io) {\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n    ctx->asynch_io = 0;\r\n    pthread_cond_signal (&ctx->io_cond);\r\n    pthread_mutex_unlock (&ctx->io_lock);\r\n    pthread_join (ctx->io_thread, NULL);\r\n    pthread_mutex_destroy (&ctx->io_lock);\r\n    pthread_cond_destroy (&ctx->io_cond);\r\n    pthread_cond_destroy (&ctx->io_done);\r\n    }\r\nreturn SCPE_OK;\r\n#endif\r\n}\r\n\r\n/* Read Sectors */\r\n\r\nstatic t_stat _sim_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\nt_offset da;\r\nuint32 err, tbc;\r\nsize_t i;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"_sim_disk_rdsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nda = ((t_offset)lba) * ctx->sector_size;\r\ntbc = sects * ctx->sector_size;\r\nif (sectsread)\r\n    *sectsread = 0;\r\nwhile (tbc) {\r\n    size_t sectbytes;\r\n\r\n    clearerr (uptr->fileref);\r\n    err = sim_fseeko (uptr->fileref, da, SEEK_SET);          /* set pos */\r\n    if (err)\r\n        return SCPE_IOERR;\r\n    i = sim_fread (buf, 1, tbc, uptr->fileref);\r\n    if (i < tbc)                 /* fill */\r\n        memset (&buf[i], 0, tbc-i);\r\n    if ((i == 0) &&             /* Reading at or past EOF? */\r\n        feof (uptr->fileref))\r\n        i = tbc;                /* return 0's which have already been filled in buffer */\r\n    sectbytes = (i / ctx->sector_size) * ctx->sector_size;\r\n    if (i > sectbytes)\r\n        sectbytes += ctx->sector_size;\r\n    if (sectsread)\r\n        *sectsread += sectbytes / ctx->sector_size;\r\n    err = ferror (uptr->fileref);\r\n    if (err)\r\n        return SCPE_IOERR;\r\n    tbc -= sectbytes;\r\n    if ((tbc == 0) || (i == 0))\r\n        return SCPE_OK;\r\n    da += sectbytes;\r\n    buf += sectbytes;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\nt_stat r;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nuint32 f = DK_GET_FMT (uptr);\r\nt_seccnt sread = 0;\r\nuint8 *tbuf = NULL;\r\nuint8 *rbuf;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_rdsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nctx->read_count++;                                      /* record read operation */\r\nif ((sects == 1) &&                                     /* Single sector reads */\r\n    (lba >= (uptr->capac*ctx->capac_factor)/(ctx->sector_size/((ctx->dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)))) {/* beyond the end of the disk */\r\n    memset (buf, '\\0', ctx->sector_size);               /* are bad block management efforts - zero buffer */\r\n    if (sectsread)\r\n        *sectsread = 1;\r\n    return SCPE_OK;                                     /* return success */\r\n    }\r\n\r\nif ((0 == (ctx->sector_size & (ctx->storage_sector_size - 1))) ||   /* Sector Aligned & whole sector transfers */\r\n    ((0 == ((lba*ctx->sector_size) & (ctx->storage_sector_size - 1))) &&\r\n     (0 == ((sects*ctx->sector_size) & (ctx->storage_sector_size - 1)))) ||\r\n    (f == DKUF_F_STD) || (f == DKUF_F_VHD)) {                       /* or SIMH or VHD formats */\r\n        if (ctx->xfer_encode_size > DK_ENC_LONGLONG) {\r\n            tbuf = (uint8*) malloc (ctx->sector_size * sects);\r\n            if (tbuf == NULL)\r\n                return SCPE_MEM;\r\n            rbuf = tbuf;\r\n            }\r\n        else\r\n            rbuf = buf;\r\n    switch (f) {                                        /* case on format */\r\n        case DKUF_F_STD:                                /* SIMH format */\r\n            r = _sim_disk_rdsect (uptr, lba, rbuf, &sread, sects);\r\n            break;\r\n        case DKUF_F_VHD:                                /* VHD format */\r\n            r = sim_vhd_disk_rdsect (uptr, lba, rbuf, &sread, sects);\r\n            break;\r\n        case DKUF_F_RAW:                                /* Raw Physical Disk Access */\r\n            r = sim_os_disk_rdsect (uptr, lba, rbuf, &sread, sects);\r\n            break;\r\n        default:\r\n            free (tbuf);\r\n            return SCPE_NOFNC;\r\n        }\r\n    if (sectsread)\r\n        *sectsread = sread;\r\n    if (ctx->xfer_encode_size > DK_ENC_LONGLONG) {\r\n        uint32 sbits = (ctx->xfer_encode_size >> DK_ENC_XFR_IN) & 0x7F;\r\n        t_bool sLSB = (((ctx->xfer_encode_size >> DK_ENC_XFR_IN) & DK_ENC_X_LSB) != 0);\r\n        uint32 dbits = (ctx->xfer_encode_size >> DK_ENC_XFR_OUT) & 0x7F;\r\n        t_bool dLSB = (((ctx->xfer_encode_size >> DK_ENC_XFR_OUT) & DK_ENC_X_LSB) != 0);\r\n        uint32 scount = ((sread * ctx->sector_size) * 8) / sbits;\r\n\r\n        sim_buf_pack_unpack (rbuf,      /* source buffer pointer */\r\n                             buf,       /* destination buffer pointer */\r\n                             sbits,     /* source buffer element size in bits */\r\n                             sLSB,      /* source numbered using LSB ordering */\r\n                             scount,    /* count of source elements */\r\n                             dbits,     /* interesting bits of each destination element */\r\n                             dLSB);     /* destination numbered using LSB ordering */\r\n        }\r\n    else\r\n        sim_buf_swap_data (buf, ctx->xfer_encode_size, (sread * ctx->sector_size) / ctx->xfer_encode_size);\r\n    free (tbuf);\r\n    return r;\r\n    }\r\nelse { /* Unaligned and/or partial sector transfers in RAW mode */\r\n    size_t tbufsize = sects * ctx->sector_size + 2 * ctx->storage_sector_size;\r\n    uint8 *tbuf = (uint8*) malloc (tbufsize);\r\n    t_offset ssaddr = (lba * (t_offset)ctx->sector_size) & ~(t_offset)(ctx->storage_sector_size -1);\r\n    uint32 soffset = (uint32)((lba * (t_offset)ctx->sector_size) - ssaddr);\r\n    uint32 bytesread;\r\n\r\n    if (sectsread)\r\n        *sectsread = 0;\r\n    if (tbuf == NULL)\r\n        return SCPE_MEM;\r\n    r = sim_os_disk_read (uptr, ssaddr, tbuf, &bytesread, tbufsize & ~(ctx->storage_sector_size - 1));\r\n    sread = (bytesread - soffset) / ctx->sector_size;\r\n    if (sread > sects)\r\n        sread = sects;\r\n    if (sectsread)\r\n        *sectsread = sread;\r\n    if (ctx->xfer_encode_size > DK_ENC_LONGLONG) {\r\n        uint32 sbits = (ctx->xfer_encode_size >> DK_ENC_XFR_IN) & 0x7F;\r\n        t_bool sLSB = (((ctx->xfer_encode_size >> DK_ENC_XFR_IN) & DK_ENC_X_LSB) != 0);\r\n        uint32 dbits = (ctx->xfer_encode_size >> DK_ENC_XFR_OUT) & 0x7F;\r\n        t_bool dLSB = (((ctx->xfer_encode_size >> DK_ENC_XFR_OUT) & DK_ENC_X_LSB) != 0);\r\n        uint32 scount = ((sread * ctx->sector_size) * 8) / sbits;\r\n\r\n        sim_buf_pack_unpack (tbuf + soffset,    /* source buffer pointer */\r\n                             buf,               /* destination buffer pointer */\r\n                             sbits,             /* source buffer element size in bits */\r\n                             sLSB,              /* source numbered using LSB ordering */\r\n                             scount,            /* count of source elements */\r\n                             dbits,             /* interesting bits of each destination element */\r\n                             dLSB);             /* destination numbered using LSB ordering */\r\n        }\r\n    else\r\n        sim_buf_copy_swapped (buf, tbuf + soffset, ctx->xfer_encode_size, (sread * ctx->sector_size) / ctx->xfer_encode_size);\r\n    free (tbuf);\r\n    return r;\r\n    }\r\n}\r\n\r\nt_stat sim_disk_rdsect_a (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects, DISK_PCALLBACK callback)\r\n{\r\nt_stat r = SCPE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_disk_rdsect (uptr, lba, buf, sectsread, sects);\r\nAIO_CALL(DOP_RSEC, lba, buf, sectsread, sects, callback);\r\nreturn r;\r\n}\r\n\r\n/* Write Sectors */\r\n\r\nstatic t_stat _sim_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\nt_offset da;\r\nuint32 err, tbc;\r\nsize_t i;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"_sim_disk_wrsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nda = ((t_offset)lba) * ctx->sector_size;\r\ntbc = sects * ctx->sector_size;\r\nif (sectswritten)\r\n    *sectswritten = 0;\r\nerr = sim_fseeko (uptr->fileref, da, SEEK_SET);          /* set pos */\r\nif (err)\r\n    return SCPE_IOERR;\r\ni = sim_fwrite (buf, ctx->xfer_encode_size, tbc/ctx->xfer_encode_size, uptr->fileref);\r\nif (sectswritten)\r\n    *sectswritten += (t_seccnt)((i * ctx->xfer_encode_size + ctx->sector_size - 1)/ctx->sector_size);\r\nerr = ferror (uptr->fileref);\r\nif (err)\r\n    return SCPE_IOERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nuint32 f = DK_GET_FMT (uptr);\r\nt_stat r;\r\nuint8 *tbuf = NULL;\r\nt_seccnt written = 0;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_wrsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nif (sectswritten)\r\n    *sectswritten = 0;\r\nctx->write_count++;                                     /* record write operation */\r\nif (uptr->dynflags & UNIT_DISK_CHK) {\r\n    DEVICE *dptr = find_dev_from_unit (uptr);\r\n    uint32 capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (quadword: 8, word: 2, byte: 1) */\r\n    t_lba total_sectors = (t_lba)((uptr->capac*capac_factor)/(ctx->sector_size/((dptr->flags & DEV_SECTORS) ? 512 : 1)));\r\n    t_lba sect;\r\n\r\n    for (sect = 0; sect < sects; sect++) {\r\n        t_lba offset;\r\n        t_bool sect_error = FALSE;\r\n\r\n        for (offset = 0; offset < ctx->sector_size; offset += sizeof(uint32)) {\r\n            if (*((uint32 *)&buf[sect*ctx->sector_size + offset]) != (uint32)(lba + sect)) {\r\n                sect_error = TRUE;\r\n                break;\r\n                }\r\n            }\r\n        if (sect_error) {\r\n            uint32 save_dctrl = dptr->dctrl;\r\n            FILE *save_sim_deb = sim_deb;\r\n\r\n            sim_printf (\"\\n%s: Write Address Verification Error on lbn %d(0x%X) of %d(0x%X).\\n\", sim_uname (uptr), (int)(lba+sect), (int)(lba+sect), (int)total_sectors, (int)total_sectors);\r\n            dptr->dctrl = 0xFFFFFFFF;\r\n            sim_deb = save_sim_deb ? save_sim_deb : stdout;\r\n            sim_disk_data_trace (uptr, buf+sect*ctx->sector_size, lba+sect, ctx->sector_size,    \"Found\", TRUE, 1);\r\n            dptr->dctrl = save_dctrl;\r\n            sim_deb = save_sim_deb;\r\n            }\r\n        }\r\n    }\r\nswitch (f) {                                            /* case on format */\r\n    case DKUF_F_STD:                                    /* SIMH format */\r\n        r = _sim_disk_wrsect (uptr, lba, buf, &written, sects);\r\n        break;\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        if (!sim_end && (ctx->xfer_encode_size != sizeof (char))) {\r\n            tbuf = (uint8*) malloc (sects * ctx->sector_size);\r\n            if (NULL == tbuf)\r\n                return SCPE_MEM;\r\n            sim_buf_copy_swapped (tbuf, buf, ctx->xfer_encode_size, (sects * ctx->sector_size) / ctx->xfer_encode_size);\r\n            buf = tbuf;\r\n            }\r\n        r = sim_vhd_disk_wrsect  (uptr, lba, buf, &written, sects);\r\n        break;\r\n    case DKUF_F_RAW:                                    /* Raw Physical Disk Access */\r\n        break;                                          /* handle below */\r\n    default:\r\n        return SCPE_NOFNC;\r\n    }\r\nif (f == DKUF_F_RAW) {\r\n    if ((0 == (ctx->sector_size & (ctx->storage_sector_size - 1))) ||   /* Sector Aligned & whole sector transfers */\r\n        ((0 == ((lba*ctx->sector_size) & (ctx->storage_sector_size - 1))) &&\r\n         (0 == ((sects*ctx->sector_size) & (ctx->storage_sector_size - 1))))) {\r\n\r\n        if (!sim_end && (ctx->xfer_encode_size != sizeof (char))) {\r\n            tbuf = (uint8*) malloc (sects * ctx->sector_size);\r\n            if (NULL == tbuf)\r\n                return SCPE_MEM;\r\n            sim_buf_copy_swapped (tbuf, buf, ctx->xfer_encode_size, (sects * ctx->sector_size) / ctx->xfer_encode_size);\r\n            buf = tbuf;\r\n            }\r\n\r\n        r = sim_os_disk_wrsect (uptr, lba, buf, &written, sects);\r\n        }\r\n    else { /* Unaligned and/or partial sector transfers in RAW mode */\r\n        size_t tbufsize = sects * ctx->sector_size + 2 * ctx->storage_sector_size;\r\n        t_offset ssaddr = (lba * (t_offset)ctx->sector_size) & ~(t_offset)(ctx->storage_sector_size -1);\r\n        t_offset sladdr = ((lba + sects) * (t_offset)ctx->sector_size) & ~(t_offset)(ctx->storage_sector_size -1);\r\n        uint32 soffset = (uint32)((lba * (t_offset)ctx->sector_size) - ssaddr);\r\n        uint32 byteswritten;\r\n\r\n        tbuf = (uint8*) malloc (tbufsize);\r\n        if (tbuf == NULL)\r\n            return SCPE_MEM;\r\n        /* Partial Sector writes require a read-modify-write sequence for the partial sectors */\r\n        if (soffset)\r\n            sim_os_disk_read (uptr, ssaddr, tbuf, NULL, ctx->storage_sector_size);\r\n        sim_os_disk_read (uptr, sladdr, tbuf + (size_t)(sladdr - ssaddr), NULL, ctx->storage_sector_size);\r\n        sim_buf_copy_swapped (tbuf + soffset,\r\n                              buf, ctx->xfer_encode_size, (sects * ctx->sector_size) / ctx->xfer_encode_size);\r\n        r = sim_os_disk_write (uptr, ssaddr, tbuf, &byteswritten, (soffset + (sects * ctx->sector_size) + ctx->storage_sector_size - 1) & ~(ctx->storage_sector_size - 1));\r\n        written = byteswritten / ctx->sector_size;\r\n        if (written > sects)\r\n            written = sects;\r\n        }\r\n    }\r\nfree (tbuf);\r\nif (sectswritten)\r\n    *sectswritten = written;\r\nif (written > 0) {\r\n    t_offset da = ((t_offset)lba) * ctx->sector_size;\r\n    t_offset end_write = da + (written * ctx->sector_size);\r\n\r\n    if (ctx->highwater < end_write)\r\n        ctx->highwater = end_write;\r\n    }\r\nreturn r;\r\n}\r\n\r\nt_stat sim_disk_wrsect_a (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects, DISK_PCALLBACK callback)\r\n{\r\nt_stat r = SCPE_OK;\r\nAIO_CALLSETUP\r\n    r =  sim_disk_wrsect (uptr, lba, buf, sectswritten, sects);\r\nAIO_CALL(DOP_WSEC, lba, buf, sectswritten, sects, callback);\r\nreturn r;\r\n}\r\n\r\nt_stat sim_disk_unload (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nswitch (DK_GET_FMT (uptr)) {                            /* case on format */\r\n    case DKUF_F_STD:                                    /* Simh */\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        ctx->media_removed = 1;\r\n        return sim_disk_detach (uptr);\r\n    case DKUF_F_RAW:                                    /* Raw Physical Disk Access */\r\n        ctx->media_removed = 1;\r\n        sim_os_disk_unload_raw (uptr->fileref);         /* remove/eject disk */\r\n        return sim_disk_detach (uptr);\r\n        break;\r\n    default:\r\n        return SCPE_NOFNC;\r\n    }\r\n}\r\n\r\nt_stat sim_disk_erase (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nuint8 *buf;\r\nt_lba lba;\r\n\r\nif (uptr->flags & UNIT_ATT)\r\n    return SCPE_UNATT;\r\n\r\nbuf = (uint8 *)calloc (1, ctx->storage_sector_size);\r\nif (buf == NULL)\r\n    return SCPE_MEM;\r\nfor (lba = 0; lba < ctx->container_size / ctx->sector_size; lba++)\r\n    sim_disk_wrsect (uptr, lba, buf, NULL, 1);          /* write sector */\r\nfree (buf);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/*\r\n   This routine is called when the simulator stops and any time\r\n   the asynch mode is changed (enabled or disabled)\r\n*/\r\nstatic void _sim_disk_io_flush (UNIT *uptr)\r\n{\r\nuint32 f = DK_GET_FMT (uptr);\r\n\r\n#if defined (SIM_ASYNCH_IO)\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nsim_disk_clr_async (uptr);\r\nif (sim_asynch_enabled)\r\n    sim_disk_set_async (uptr, ctx->asynch_io_latency);\r\n#endif\r\nswitch (f) {                                            /* case on format */\r\n    case DKUF_F_STD:                                    /* Simh */\r\n        fflush (uptr->fileref);\r\n        break;\r\n    case DKUF_F_VHD:                                    /* Virtual Disk */\r\n        sim_vhd_disk_flush (uptr->fileref);\r\n        break;\r\n    case DKUF_F_RAW:                                    /* Physical */\r\n        sim_os_disk_flush_raw (uptr->fileref);\r\n        break;\r\n        }\r\n}\r\n\r\nstatic t_stat _err_return (UNIT *uptr, t_stat stat)\r\n{\r\nfree (uptr->filename);\r\nuptr->filename = NULL;\r\nfree (uptr->disk_ctx);\r\nuptr->disk_ctx = NULL;\r\nreturn stat;\r\n}\r\n\r\nstatic t_stat _sim_disk_rdsect_interleave (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects, uint16 sectpertrack, uint16 interleave, uint16 skew, uint16 offset)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_lba sectno = lba, psa;\r\nt_stat status;\r\n\r\nif (sectsread)\r\n    *sectsread = 0;\r\n\r\ndo {\r\n    uint16 i, track, sector;\r\n\r\n    /*\r\n     * Map an LBA address into a physical sector address\r\n     */\r\n    track = sectno / sectpertrack;\r\n    i = (sectno % sectpertrack) * interleave;\r\n    if (i >= sectpertrack)\r\n        i++;\r\n    sector = (i + (track * skew)) % sectpertrack;\r\n\r\n    psa = sector + (track * sectpertrack) + offset;\r\n\r\n    status = sim_disk_rdsect(uptr, psa, buf, NULL, 1);\r\n    sects--;\r\n    buf += ctx->sector_size;\r\n    sectno++;\r\n    if (sectsread)\r\n        *sectsread += 1;\r\n    } while ((sects != 0) && (status == SCPE_OK));\r\n\r\nreturn status;\r\n}\r\n\r\n/*\r\n * Version of sim_disk_rdsect() specifically for filesystem detection of DEC\r\n * file systems. The routine handles regular DEC disks (physsectsz == 0) and\r\n * RX01/RX02 disks (physsectsz == 128 or == 256) which ignore track 0,\r\n * interleave physical sectors 2:1 for the remaining tracks and have a skew\r\n * 6 sectors at the end of a track.\r\n */\r\n#define RX0xNSECT               26                      /* 26 sectors/track */\r\n#define RX0xINTER               2                       /* 2 sector interleave */\r\n#define RX0xISKEW               6                       /* 6 sectors interleave per track */\r\n\r\nstatic t_stat _DEC_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects, uint32 physsectsz)\r\n{\r\nif (physsectsz == 0)            /* Use device natural sector size */\r\n    return sim_disk_rdsect(uptr, lba, buf, sectsread, sects);\r\n\r\nreturn _sim_disk_rdsect_interleave(uptr, lba, buf, sectsread, sects, RX0xNSECT, RX0xINTER, RX0xISKEW, RX0xNSECT);\r\n}\r\n\r\n#pragma pack(push,1)\r\ntypedef struct _ODS1_HomeBlock\r\n    {\r\n    uint16  hm1_w_ibmapsize;\r\n    uint32  hm1_l_ibmaplbn;\r\n    uint16  hm1_w_maxfiles;\r\n    uint16  hm1_w_cluster;\r\n    uint16  hm1_w_devtype;\r\n    uint16  hm1_w_structlev;\r\n#define HM1_C_LEVEL1    0401\r\n#define HM1_C_LEVEL2    0402\r\n    uint8   hm1_t_volname[12];\r\n    uint8   hm1_b_fill_1[4];\r\n    uint16  hm1_w_volowner;\r\n    uint16  hm1_w_protect;\r\n    uint16  hm1_w_volchar;\r\n    uint16  hm1_w_fileprot;\r\n    uint8   hm1_b_fill_2[6];\r\n    uint8   hm1_b_window;\r\n    uint8   hm1_b_extend;\r\n    uint8   hm1_b_lru_lim;\r\n    uint8   hm1_b_fill_3[11];\r\n    uint16  hm1_w_checksum1;\r\n    uint8   hm1_t_credate[14];\r\n    uint8   hm1_b_fill_4[382];\r\n    uint32  hm1_l_serialnum;\r\n    uint8   hm1_b_fill_5[12];\r\n    uint8   hm1_t_volname2[12];\r\n    uint8   hm1_t_ownername[12];\r\n    uint8   hm1_t_format[12];\r\n    uint8   hm1_t_fill_6[2];\r\n    uint16  hm1_w_checksum2;\r\n    } ODS1_HomeBlock;\r\n\r\n    typedef struct _ODS2_HomeBlock\r\n    {\r\n    uint32 hm2_l_homelbn;\r\n    uint32 hm2_l_alhomelbn;\r\n    uint32 hm2_l_altidxlbn;\r\n    uint8  hm2_b_strucver;\r\n    uint8  hm2_b_struclev;\r\n    uint16 hm2_w_cluster;\r\n    uint16 hm2_w_homevbn;\r\n    uint16 hm2_w_alhomevbn;\r\n    uint16 hm2_w_altidxvbn;\r\n    uint16 hm2_w_ibmapvbn;\r\n    uint32 hm2_l_ibmaplbn;\r\n    uint32 hm2_l_maxfiles;\r\n    uint16 hm2_w_ibmapsize;\r\n    uint16 hm2_w_resfiles;\r\n    uint16 hm2_w_devtype;\r\n    uint16 hm2_w_rvn;\r\n    uint16 hm2_w_setcount;\r\n    uint16 hm2_w_volchar;\r\n    uint32 hm2_l_volowner;\r\n    uint32 hm2_l_reserved;\r\n    uint16 hm2_w_protect;\r\n    uint16 hm2_w_fileprot;\r\n    uint16 hm2_w_reserved;\r\n    uint16 hm2_w_checksum1;\r\n    uint32 hm2_q_credate[2];\r\n    uint8  hm2_b_window;\r\n    uint8  hm2_b_lru_lim;\r\n    uint16 hm2_w_extend;\r\n    uint32 hm2_q_retainmin[2];\r\n    uint32 hm2_q_retainmax[2];\r\n    uint32 hm2_q_revdate[2];\r\n    uint8  hm2_r_min_class[20];\r\n    uint8  hm2_r_max_class[20];\r\n    uint8  hm2_r_reserved[320];\r\n    uint32 hm2_l_serialnum;\r\n    uint8  hm2_t_strucname[12];\r\n    uint8  hm2_t_volname[12];\r\n    uint8  hm2_t_ownername[12];\r\n    uint8  hm2_t_format[12];\r\n    uint16 hm2_w_reserved2;\r\n    uint16 hm2_w_checksum2;\r\n    } ODS2_HomeBlock;\r\n\r\ntypedef struct _ODS1_FileHeader\r\n    {\r\n    uint8   fh1_b_idoffset;\r\n    uint8   fh1_b_mpoffset;\r\n    uint16  fh1_w_fid_num;\r\n    uint16  fh1_w_fid_seq;\r\n    uint16  fh1_w_struclev;\r\n    uint16  fh1_w_fileowner;\r\n    uint16  fh1_w_fileprot;\r\n    uint16  fh1_w_filechar;\r\n    uint16  fh1_w_recattr;\r\n    uint8   fh1_b_fill_1[494];\r\n    uint16  fh1_w_checksum;\r\n    } ODS1_FileHeader;\r\n\r\ntypedef struct _ODS2_FileHeader\r\n    {\r\n    uint8  fh2_b_idoffset;\r\n    uint8  fh2_b_mpoffset;\r\n    uint8  fh2_b_acoffset;\r\n    uint8  fh2_b_rsoffset;\r\n    uint16 fh2_w_seg_num;\r\n    uint16 fh2_w_structlev;\r\n    uint16 fh2_w_fid[3];\r\n    uint16 fh2_w_ext_fid[3];\r\n    uint16 fh2_w_recattr[16];\r\n    uint32 fh2_l_filechar;\r\n    uint16 fh2_w_remaining[228];\r\n    } ODS2_FileHeader;\r\n\r\ntypedef union _ODS2_Retreval\r\n    {\r\n        struct\r\n            {\r\n            unsigned fm2___fill   : 14;       /* type specific data               */\r\n            unsigned fm2_v_format : 2;        /* format type code                 */\r\n            } fm2_r_word0_bits;\r\n        struct\r\n            {\r\n            unsigned fm2_v_exact    : 1;      /* exact placement specified        */\r\n            unsigned fm2_v_oncyl    : 1;      /* on cylinder allocation desired   */\r\n            unsigned fm2___fill     : 10;\r\n            unsigned fm2_v_lbn      : 1;      /* use LBN of next map pointer      */\r\n            unsigned fm2_v_rvn      : 1;      /* place on specified RVN           */\r\n            unsigned fm2_v_format0  : 2;\r\n            } fm2_r_map_bits0;\r\n        struct\r\n            {\r\n            unsigned fm2_b_count1   : 8;      /* low byte described below         */\r\n            unsigned fm2_v_highlbn1 : 6;      /* high order LBN                   */\r\n            unsigned fm2_v_format1  : 2;\r\n            unsigned fm2_w_lowlbn1  : 16;     /* low order LBN                    */\r\n            } fm2_r_map_bits1;\r\n        struct\r\n            {\r\n            struct\r\n                {\r\n                unsigned fm2_v_count2   : 14; /* count field                      */\r\n                unsigned fm2_v_format2  : 2;\r\n                unsigned fm2_l_lowlbn2  : 16; /* low order LBN                    */\r\n                } fm2_r_map2_long0;\r\n            uint16 fm2_l_highlbn2;            /* high order LBN                   */\r\n            } fm2_r_map_bits2;\r\n        struct\r\n            {\r\n            struct\r\n                {\r\n                unsigned fm2_v_highcount3 : 14; /* low order count field          */\r\n                unsigned fm2_v_format3  : 2;\r\n                unsigned fm2_w_lowcount3 : 16;  /* high order count field         */\r\n                } fm2_r_map3_long0;\r\n            uint32 fm2_l_lbn3;\r\n            } fm2_r_map_bits3;\r\n    } ODS2_Retreval;\r\n\r\ntypedef struct _ODS1_Retreval\r\n    {\r\n    uint8   fm1_b_ex_segnum;\r\n    uint8   fm1_b_ex_rvn;\r\n    uint16  fm1_w_ex_filnum;\r\n    uint16  fm1_w_ex_filseq;\r\n    uint8   fm1_b_countsize;\r\n    uint8   fm1_b_lbnsize;\r\n    uint8   fm1_b_inuse;\r\n    uint8   fm1_b_avail;\r\n    union {\r\n        struct {\r\n            uint8 fm1_b_highlbn;\r\n            uint8 fm1_b_count;\r\n            uint16 fm1_w_lowlbn;\r\n            } fm1_s_fm1def1;\r\n        struct {\r\n            uint8 fm1_b_highlbn;\r\n            uint8 fm1_b_count;\r\n            uint16 fm1_w_lowlbn;\r\n            } fm1_s_fm1def2;\r\n        } fm1_pointers[4];\r\n    } ODS1_Retreval;\r\n\r\ntypedef struct _ODS1_StorageControlBlock\r\n    {\r\n    uint8  scb_b_unused[3];\r\n    uint8  scb_b_bitmapblks;\r\n    struct _bitmapblk {\r\n        uint16 scb_w_freeblks;\r\n        uint16 scb_w_freeptr;\r\n        } scb_r_blocks[1];\r\n    } ODS1_SCB;\r\n\r\n\r\ntypedef struct _ODS2_StorageControlBlock\r\n    {\r\n    uint8  scb_b_strucver;   /* 1 */\r\n    uint8  scb_b_struclev;   /* 2 */\r\n    uint16 scb_w_cluster;\r\n    uint32 scb_l_volsize;\r\n    uint32 scb_l_blksize;\r\n    uint32 scb_l_sectors;\r\n    uint32 scb_l_tracks;\r\n    uint32 scb_l_cylinder;\r\n    uint32 scb_l_status;\r\n    uint32 scb_l_status2;\r\n    uint16 scb_w_writecnt;\r\n    uint8  scb_t_volockname[12];\r\n    uint32 scb_q_mounttime[2];\r\n    uint16 scb_w_backrev;\r\n    uint32 scb_q_genernum[2];\r\n    uint8  scb_b_reserved[446];\r\n    uint16 scb_w_checksum;\r\n    } ODS2_SCB;\r\n#pragma pack(pop)\r\n\r\nstatic uint16\r\nODSChecksum (void *Buffer, uint16 WordCount)\r\n    {\r\n    int i;\r\n    uint16 CheckSum = 0;\r\n    uint16 *Buf = (uint16 *)Buffer;\r\n\r\n    for (i=0; i<WordCount; i++)\r\n        CheckSum += Buf[i];\r\n    return CheckSum;\r\n    }\r\n\r\n\r\nstatic t_offset get_ods2_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_offset temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nODS2_HomeBlock Home;\r\nODS2_FileHeader Header;\r\nODS2_Retreval *Retr;\r\nODS2_SCB Scb;\r\nuint16 CheckSum1, CheckSum2;\r\nuint32 ScbLbn = 0;\r\nt_offset ret_val = (t_offset)-1;\r\nt_seccnt sects_read;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = (t_addr)temp_capac;\r\nif ((_DEC_rdsect (uptr, 512 / ctx->sector_size, (uint8 *)&Home, &sects_read, sizeof (Home) / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (sizeof (Home) / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\nCheckSum1 = ODSChecksum (&Home, (uint16)((((char *)&Home.hm2_w_checksum1)-((char *)&Home.hm2_l_homelbn))/2));\r\nCheckSum2 = ODSChecksum (&Home, (uint16)((((char *)&Home.hm2_w_checksum2)-((char *)&Home.hm2_l_homelbn))/2));\r\nif ((Home.hm2_l_homelbn == 0) ||\r\n    (Home.hm2_l_alhomelbn == 0) ||\r\n    (Home.hm2_l_altidxlbn == 0) ||\r\n    ((Home.hm2_b_struclev != 2) && (Home.hm2_b_struclev != 5)) ||\r\n    (Home.hm2_b_strucver == 0) ||\r\n    (Home.hm2_w_cluster == 0) ||\r\n    (Home.hm2_w_homevbn == 0) ||\r\n    (Home.hm2_w_alhomevbn == 0) ||\r\n    (Home.hm2_w_ibmapvbn == 0) ||\r\n    (Home.hm2_l_ibmaplbn == 0) ||\r\n    (Home.hm2_w_resfiles >= Home.hm2_l_maxfiles) ||\r\n    (Home.hm2_w_ibmapsize == 0) ||\r\n    (Home.hm2_w_resfiles < 5) ||\r\n    (Home.hm2_w_checksum1 != CheckSum1) ||\r\n    (Home.hm2_w_checksum2 != CheckSum2))\r\n    goto Return_Cleanup;\r\nif ((_DEC_rdsect (uptr, (Home.hm2_l_ibmaplbn+Home.hm2_w_ibmapsize+1) * (512 / ctx->sector_size),\r\n                  (uint8 *)&Header, &sects_read, sizeof (Header) / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (sizeof (Header) / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\nCheckSum1 = ODSChecksum (&Header, 255);\r\nif (CheckSum1 != *(((uint16 *)&Header)+255)) /* Verify Checksum on BITMAP.SYS file header */\r\n    goto Return_Cleanup;\r\nRetr = (ODS2_Retreval *)(((uint16*)(&Header))+Header.fh2_b_mpoffset);\r\n/* The BitMap File has a single extent, which may be preceded by a placement descriptor */\r\nif (Retr->fm2_r_word0_bits.fm2_v_format == 0)\r\n    Retr = (ODS2_Retreval *)(((uint16 *)Retr)+1); /* skip placement descriptor */\r\nswitch (Retr->fm2_r_word0_bits.fm2_v_format)\r\n    {\r\n    case 1:\r\n        ScbLbn = (Retr->fm2_r_map_bits1.fm2_v_highlbn1<<16)+Retr->fm2_r_map_bits1.fm2_w_lowlbn1;\r\n        break;\r\n    case 2:\r\n        ScbLbn = (Retr->fm2_r_map_bits2.fm2_l_highlbn2<<16)+Retr->fm2_r_map_bits2.fm2_r_map2_long0.fm2_l_lowlbn2;\r\n        break;\r\n    case 3:\r\n        ScbLbn = Retr->fm2_r_map_bits3.fm2_l_lbn3;\r\n        break;\r\n    }\r\nRetr = (ODS2_Retreval *)(((uint16 *)Retr)+Retr->fm2_r_word0_bits.fm2_v_format+1);\r\nif ((_DEC_rdsect (uptr, ScbLbn * (512 / ctx->sector_size), (uint8 *)&Scb, &sects_read, sizeof (Scb) / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (sizeof (Scb) / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\nCheckSum1 = ODSChecksum (&Scb, 255);\r\nif (CheckSum1 != *(((uint16 *)&Scb)+255)) /* Verify Checksum on Storage Control Block */\r\n    goto Return_Cleanup;\r\nif ((Scb.scb_w_cluster != Home.hm2_w_cluster) ||\r\n    (Scb.scb_b_strucver != Home.hm2_b_strucver) ||\r\n    (Scb.scb_b_struclev != Home.hm2_b_struclev))\r\n    goto Return_Cleanup;\r\nsim_messagef (SCPE_OK, \"%s: '%s' Contains ODS%d File system\\n\", sim_uname (uptr), sim_relative_path (uptr->filename), Home.hm2_b_struclev);\r\nsim_messagef (SCPE_OK, \"%s: Volume Name: %12.12s Format: %12.12s Sectors In Volume: %u\\n\",\r\n                                   sim_uname (uptr), Home.hm2_t_volname, Home.hm2_t_format, Scb.scb_l_volsize);\r\nret_val = ((t_offset)Scb.scb_l_volsize) * 512;\r\n\r\nReturn_Cleanup:\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\nstatic t_offset get_ods1_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nODS1_HomeBlock Home;\r\nODS1_FileHeader Header;\r\nODS1_Retreval *Retr;\r\nuint8 scb_buf[512];\r\nODS1_SCB *Scb = (ODS1_SCB *)scb_buf;\r\nuint16 CheckSum1, CheckSum2;\r\nuint32 ScbLbn;\r\nt_offset ret_val = (t_offset)-1;\r\nt_seccnt sects_read;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\nif ((_DEC_rdsect (uptr, 512 / ctx->sector_size, (uint8 *)&Home, &sects_read, sizeof (Home) / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (sizeof (Home) / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\nCheckSum1 = ODSChecksum (&Home, (uint16)((((char *)&Home.hm1_w_checksum1)-((char *)&Home.hm1_w_ibmapsize))/2));\r\nCheckSum2 = ODSChecksum (&Home, (uint16)((((char *)&Home.hm1_w_checksum2)-((char *)&Home.hm1_w_ibmapsize))/2));\r\nif ((Home.hm1_w_ibmapsize == 0) ||\r\n    (Home.hm1_l_ibmaplbn == 0) ||\r\n    (Home.hm1_w_maxfiles == 0) ||\r\n    (Home.hm1_w_cluster != 1) ||\r\n    ((Home.hm1_w_structlev != HM1_C_LEVEL1) && (Home.hm1_w_structlev != HM1_C_LEVEL2)) ||\r\n    (Home.hm1_l_ibmaplbn == 0) ||\r\n    (Home.hm1_w_checksum1 != CheckSum1) ||\r\n    (Home.hm1_w_checksum2 != CheckSum2))\r\n    goto Return_Cleanup;\r\nif ((_DEC_rdsect (uptr, (((Home.hm1_l_ibmaplbn << 16) + ((Home.hm1_l_ibmaplbn >> 16) & 0xFFFF)) + Home.hm1_w_ibmapsize + 1) * (512 / ctx->sector_size),\r\n                  (uint8 *)&Header, &sects_read, sizeof (Header) / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (sizeof (Header) / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\nCheckSum1 = ODSChecksum (&Header, 255);\r\nif (CheckSum1 != *(((uint16 *)&Header)+255)) /* Verify Checksum on BITMAP.SYS file header */\r\n    goto Return_Cleanup;\r\n\r\nRetr = (ODS1_Retreval *)(((uint16*)(&Header))+Header.fh1_b_mpoffset);\r\nScbLbn = (Retr->fm1_pointers[0].fm1_s_fm1def1.fm1_b_highlbn<<16)+Retr->fm1_pointers[0].fm1_s_fm1def1.fm1_w_lowlbn;\r\nif ((_DEC_rdsect (uptr, ScbLbn * (512 / ctx->sector_size), (uint8 *)Scb, &sects_read, 512 / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (512 / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\nif (Scb->scb_b_bitmapblks < 127)\r\n    ret_val = (((t_offset)Scb->scb_r_blocks[Scb->scb_b_bitmapblks].scb_w_freeblks << 16) + Scb->scb_r_blocks[Scb->scb_b_bitmapblks].scb_w_freeptr) * 512;\r\nelse\r\n    ret_val = (((t_offset)Scb->scb_r_blocks[0].scb_w_freeblks << 16) + Scb->scb_r_blocks[0].scb_w_freeptr) * 512;\r\nsim_messagef (SCPE_OK, \"%s: '%s' Contains an ODS1 File system\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\nsim_messagef (SCPE_OK, \"%s: Volume Name: %12.12s Format: %12.12s Sectors In Volume: %u\\n\",\r\n                                sim_uname (uptr), Home.hm1_t_volname, Home.hm1_t_format, (uint32)(ret_val / 512));\r\nReturn_Cleanup:\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\ntypedef struct ultrix_disklabel {\r\n    uint32  pt_magic;       /* magic no. indicating part. info exits */\r\n    uint32  pt_valid;       /* set by driver if pt is current */\r\n    struct  pt_info {\r\n        uint32  pi_nblocks; /* no. of sectors */\r\n        uint32  pi_blkoff;  /* block offset for start */\r\n        } pt_part[8];\r\n    } ultrix_disklabel;\r\n\r\n#define PT_MAGIC        0x032957        /* Partition magic number */\r\n#define PT_VALID        1               /* Indicates if struct is valid */\r\n\r\nstatic t_offset get_ultrix_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nuint8 sector_buf[512];\r\nultrix_disklabel *Label = (ultrix_disklabel *)(sector_buf + sizeof (sector_buf) - sizeof (ultrix_disklabel));\r\nt_offset ret_val = (t_offset)-1;\r\nint i;\r\nuint32 max_lbn = 0, max_lbn_partnum = 0;\r\nt_seccnt sects_read;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\nif ((_DEC_rdsect (uptr, 31 * (512 / ctx->sector_size), sector_buf, &sects_read, 512 / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (512 / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\n\r\nif ((Label->pt_magic != PT_MAGIC) ||\r\n    (Label->pt_valid != PT_VALID))\r\n    goto Return_Cleanup;\r\n\r\nfor (i = 0; i < 8; i++) {\r\n    uint32 end_lbn = Label->pt_part[i].pi_blkoff + Label->pt_part[i].pi_nblocks;\r\n    if (end_lbn > max_lbn) {\r\n        max_lbn = end_lbn;\r\n        max_lbn_partnum = i;\r\n        }\r\n    }\r\nsim_messagef (SCPE_OK, \"%s: '%s' Contains Ultrix partitions\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\nsim_messagef (SCPE_OK, \"Partition with highest sector: %c, Sectors On Disk: %u\\n\", 'a' + max_lbn_partnum, max_lbn);\r\nret_val = ((t_offset)max_lbn) * 512;\r\n\r\nReturn_Cleanup:\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\n\r\n/* ISO 9660 Volume Recognizer - Structure Info gathered from: https://wiki.osdev.org/ISO_9660 */\r\n\r\ntypedef struct ISO_9660_Volume_Descriptor {\r\n    uint8   Type;                       // Volume Descriptor type code (0, 1, 2, 3 and 255)\r\n    uint8   Identifier[5];              // Always 'CD001'.\r\n    uint8   Version;                    // Volume Descriptor Version (0x01).\r\n    uint8   Data[2041];                 // Depends on the volume descriptor type.\r\n    } ISO_9660_Volume_Descriptor;\r\n\r\ntypedef struct ISO_9660_Primary_Volume_Descriptor {\r\n    uint8   Type;                       // Always 0x01 for a Primary Volume Descriptor.\r\n    uint8   Identifier[5];              // Always 'CD001'.\r\n    uint8   Version;                    // Always 0x01.\r\n    uint8   Unused;                     // Always 0x00.\r\n    uint8   SystemIdentifier[32];       // The name of the system that can act upon sectors 0x00-0x0F for the volume.\r\n    uint8   VolumeIdentifier[32];       // Identification of this volume.\r\n    uint8   UnusedField[8];             // All zeros.\r\n    uint32  VolumeSpaceSize[2];         // Number of Logical Blocks in which the volume is recorded\r\n    uint8   UnusedField2[32];           // All zeroes.\r\n    uint16  VolumeSetSize[2];           // The size of the set in this logical volume (number of disks).\r\n    uint16  VolumeSequenceNumber[2];    // The number of this disk in the Volume Set.\r\n    uint16  LogicalBlockSize[2];        // The size in bytes of a logical block. NB: This means that a logical block on a CD could be something other than 2 KiB!\r\n    uint32  PathTableSize[2];           // The size in bytes of the path table.\r\n    uint32  LocationTypeLPathTable;     // LBA location of the path table. The path table pointed to contains only little-endian values.\r\n    uint32  LocationOptTypeLPathTable;  // LBA location of the optional path table. The path table pointed to contains only little-endian values. Zero means that no optional path table exists.\r\n    uint32  LocationTypeMPathTable;     // LBA location of the path table. The path table pointed to contains only big-endian values.\r\n    uint32  LocationOptTypeMPathTable;  // LBA location of the optional path table. The path table pointed to contains only big-endian values. Zero means that no optional path table exists.\r\n    uint8   DirectoryEntryRootDirectory[34];// Note that this is not an LBA address, it is the actual Directory Record, which contains a single byte Directory Identifier (0x00), hence the fixed 34 byte size.\r\n    uint8   VolumeSetIdentifier[128];   // Identifier of the volume set of which this volume is a member.\r\n    uint8   PublisherIdentifier[128];   // The volume publisher. For extended publisher information, the first byte should be 0x5F, followed by the filename of a file in the root directory. If not specified, all bytes should be 0x20.\r\n    uint8   DataPreparerIdentifier[128];// The identifier of the person(s) who prepared the data for this volume. For extended preparation information, the first byte should be 0x5F, followed by the filename of a file in the root directory. If not specified, all bytes should be 0x20.\r\n    uint8   ApplicationIdentifier[128]; // Identifies how the data are recorded on this volume. For extended information, the first byte should be 0x5F, followed by the filename of a file in the root directory. If not specified, all bytes should be 0x20.\r\n    uint8   CopyrightFileIdentifier[37];// Filename of a file in the root directory that contains copyright information for this volume set. If not specified, all bytes should be 0x20.\r\n    uint8   AbstractFileIdentifier[37]; // Filename of a file in the root directory that contains abstract information for this volume set. If not specified, all bytes should be 0x20.\r\n    uint8   BibliographicFileIdentifier[37];// Filename of a file in the root directory that contains bibliographic information for this volume set. If not specified, all bytes should be 0x20.\r\n    uint8   VolumeCreationDateTime[17]; // The date and time of when the volume was created.\r\n    uint8   VolumeModificationDateTime[17];// The date and time of when the volume was modified.\r\n    uint8   VolumeExpirationDateTime[17];// The date and time after which this volume is considered to be obsolete. If not specified, then the volume is never considered to be obsolete.\r\n    uint8   VolumeEffectiveDateTime[17];// The date and time after which the volume may be used. If not specified, the volume may be used immediately.\r\n    uint8   FileStructureVersion;       // The directory records and path table version (always 0x01).\r\n    uint8   Unused2;                    // Always 0x00.\r\n    uint8   ApplicationUsed[512];       // Contents not defined by ISO 9660.\r\n    uint8   Reserved[653];              // Reserved by ISO.\r\n    } ISO_9660_Primary_Volume_Descriptor;\r\n\r\nstatic t_offset get_iso9660_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nuint8 sector_buf[2048];\r\nISO_9660_Volume_Descriptor *Desc = (ISO_9660_Volume_Descriptor *)sector_buf;\r\nuint8 primary_buf[2048];\r\nISO_9660_Primary_Volume_Descriptor *Primary = NULL;\r\nt_lba sectfactor = sizeof (*Desc) / ctx->sector_size;\r\nt_offset ret_val = (t_offset)-1;\r\nt_offset cur_pos = 32768;           /* Beyond the boot area of an ISO 9660 image */\r\nt_seccnt sectsread;\r\nint read_count = 0;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\n\r\nwhile (sim_disk_rdsect(uptr, (t_lba)(sectfactor * cur_pos / sizeof (*Desc)), (uint8 *)Desc, &sectsread, sectfactor) == DKSE_OK) {\r\n    if ((sectsread != sectfactor)               ||\r\n        (Desc->Version != 1)                    ||\r\n        (0 != memcmp (Desc->Identifier, \"CD001\", sizeof (Desc->Identifier))))\r\n        break;\r\n    if (Desc->Type == 1) {  /* Primary Volume Descriptor */\r\n        Primary = (ISO_9660_Primary_Volume_Descriptor *)primary_buf;\r\n        *Primary = *(ISO_9660_Primary_Volume_Descriptor *)Desc;\r\n        }\r\n    cur_pos += sizeof (*Desc);\r\n    ++read_count;\r\n    if ((Desc->Type == 255) ||\r\n        (read_count >= 32)) {\r\n        ret_val = ctx->container_size;\r\n        sim_messagef (SCPE_OK, \"%s: '%s' Contains an ISO 9660 filesystem\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\n        if (Primary) {\r\n            char VolId[sizeof (Primary->VolumeIdentifier) + 1];\r\n\r\n            memcpy (VolId, Primary->VolumeIdentifier, sizeof (Primary->VolumeIdentifier));\r\n            VolId[sizeof (Primary->VolumeIdentifier)] = '\\0';\r\n            sim_messagef (SCPE_OK, \"%s: Volume Identifier: %s   Containing %u %u Byte Sectors\\n\", sim_uname (uptr), sim_trim_endspc (VolId), (uint32)(ctx->container_size / Primary->LogicalBlockSize[1 - sim_end]), (uint32)Primary->LogicalBlockSize[1 - sim_end]);\r\n            }\r\n        break;\r\n        }\r\n    }\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr) || (ret_val != (t_offset)-1);\r\nreturn ret_val;\r\n}\r\n\r\n/* 2.11 BSD Volume Recognizer - Structure Info gathered from: the 2.11 BSD disklabel section 5 man page */\r\n\r\n#define BSD_DISKMAGIC           ((uint32) 0x82564557)   /* The disk label magic number */\r\n#define BSD_211_MAXPARTITIONS   8\r\n\r\ntypedef struct BSD_211_disklabel {\r\n    uint32  d_magic;        /* the magic number */\r\n    uint8   d_type;         /* drive type */\r\n    uint8   d_subtype;      /* controller/d_type specific */\r\n    char    d_typename[16]; /* type name, e.g. \"eagle\" */\r\n    /*\r\n     * d_packname contains the pack identifier and is returned when\r\n     * the disklabel is read off the disk or in-core copy.\r\n     * d_boot0 is the (optional) name of the primary (block 0) bootstrap\r\n     * as found in /mdec.  This is returned when using\r\n     * getdiskbyname(3) to retrieve the values from /etc/disktab.\r\n     */\r\n    char    d_packname[16];     /* pack identifier */\r\n                                /* disk geometry: */\r\n    uint16  d_secsize;          /* # of bytes per sector */\r\n    uint16  d_nsectors;         /* # of data sectors per track */\r\n    uint16  d_ntracks;          /* # of tracks per cylinder */\r\n    uint16  d_ncylinders;       /* # of data cylinders per unit */\r\n    uint16  d_secpercyl;        /* # of data sectors per cylinder */\r\n    uint32  d_secperunit;       /* # of data sectors per unit */\r\n    /*\r\n     * Spares (bad sector replacements) below\r\n     * are not counted in d_nsectors or d_secpercyl.\r\n     * Spare sectors are assumed to be physical sectors\r\n     * which occupy space at the end of each track and/or cylinder.\r\n     */\r\n    uint16  d_sparespertrack;   /* # of spare sectors per track */\r\n    uint16  d_sparespercyl;     /* # of spare sectors per cylinder */\r\n    /*\r\n     * Alternate cylinders include maintenance, replacement,\r\n     * configuration description areas, etc.\r\n     */\r\n    uint16  d_acylinders;       /* # of alt. cylinders per unit */\r\n\r\n        /* hardware characteristics: */\r\n    /*\r\n     * d_interleave, d_trackskew and d_cylskew describe perturbations\r\n     * in the media format used to compensate for a slow controller.\r\n     * Interleave is physical sector interleave, set up by the formatter\r\n     * or controller when formatting.  When interleaving is in use,\r\n     * logically adjacent sectors are not physically contiguous,\r\n     * but instead are separated by some number of sectors.\r\n     * It is specified as the ratio of physical sectors traversed\r\n     * per logical sector.  Thus an interleave of 1:1 implies contiguous\r\n     * layout, while 2:1 implies that logical sector 0 is separated\r\n     * by one sector from logical sector 1.\r\n     * d_trackskew is the offset of sector 0 on track N\r\n     * relative to sector 0 on track N-1 on the same cylinder.\r\n     * Finally, d_cylskew is the offset of sector 0 on cylinder N\r\n     * relative to sector 0 on cylinder N-1.\r\n     */\r\n    uint16  d_rpm;              /* rotational speed */\r\n    uint8   d_interleave;       /* hardware sector interleave */\r\n    uint8   d_trackskew;        /* sector 0 skew, per track */\r\n    uint8   d_cylskew;          /* sector 0 skew, per cylinder */\r\n    uint8   d_headswitch;       /* head swith time, usec */\r\n    uint16  d_trkseek;          /* track-to-track seek, msec */\r\n    uint16  d_flags;            /* generic flags */\r\n#define NDDATA 5\r\n    uint32  d_drivedata[NDDATA]; /* drive-type specific information */\r\n#define NSPARE 5\r\n    uint32  d_spare[NSPARE];    /* reserved for future use */\r\n    uint32  d_magic2;           /* the magic number (again) */\r\n    uint16  d_checksum;         /* xor of data incl. partitions */\r\n\r\n            /* filesystem and partition information: */\r\n    uint16  d_npartitions;      /* number of partitions in following */\r\n    uint8   d_bbsize;           /* size of boot area at sn0, bytes */\r\n    uint8   d_sbsize;           /* max size of fs superblock, bytes */\r\n    struct  {                   /* the partition table */\r\n        uint32  p_size;         /* number of sectors in partition */\r\n        uint32  p_offset;       /* starting sector */\r\n        uint16  p_fsize;        /* filesystem basic fragment size */\r\n        uint8   p_fstype;       /* filesystem type, see below */\r\n        uint8   p_frag;         /* filesystem fragments per block */\r\n        } d_partitions[BSD_211_MAXPARTITIONS];/* actually may be more */\r\n} BSD_211_disklabel;\r\n\r\n\r\nstatic t_offset get_BSD_211_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nuint8 sector_buf[512];\r\nBSD_211_disklabel *Label = (BSD_211_disklabel *)sector_buf;\r\nt_offset ret_val = (t_offset)-1;\r\nuint16 i;\r\nuint32 max_lbn = 0, max_lbn_partnum = 0;\r\nt_seccnt sects_read;\r\nuint16 sum = 0;\r\nuint16 *pdata;\r\n#define WORDSWAP(l) (((l >> 16) & 0xFFFF) | ((l & 0xFFFF) << 16))\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\nif ((_DEC_rdsect (uptr, 1, sector_buf, &sects_read, 512 / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (512 / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\n\r\n/* Confirm the Label magic numbers */\r\nif ((WORDSWAP(Label->d_magic) != BSD_DISKMAGIC) ||\r\n    (WORDSWAP(Label->d_magic2) != BSD_DISKMAGIC))\r\n    goto Return_Cleanup;\r\n\r\n/* Verify the label checksum */\r\nif (Label->d_npartitions > BSD_211_MAXPARTITIONS)\r\n    goto Return_Cleanup;\r\n\r\npdata = (uint16 *)Label;\r\nfor (sum = 0, pdata = (uint16 *)Label; pdata < (uint16 *)&Label->d_partitions[Label->d_npartitions]; pdata++)\r\n    sum ^= *pdata;\r\n\r\nif (sum != 0)\r\n    goto Return_Cleanup;\r\n\r\n/* Walk through the partitions */\r\nfor (i = 0; i < Label->d_npartitions; i++) {\r\n    uint32 end_lbn = WORDSWAP (Label->d_partitions[i].p_offset) + WORDSWAP (Label->d_partitions[i].p_size);\r\n    if (end_lbn > max_lbn) {\r\n        max_lbn = end_lbn;\r\n        max_lbn_partnum = i;\r\n        }\r\n    }\r\nsim_messagef (SCPE_OK, \"%s: '%s' Contains BSD 2.11 partitions\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\nsim_messagef (SCPE_OK, \"Partition with highest sector: %c, Sectors On Disk: %u\\n\", 'a' + max_lbn_partnum, max_lbn);\r\nret_val = ((t_offset)max_lbn) * 512;\r\n\r\nReturn_Cleanup:\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\n/* NetBSD Volume Recognizer - Structure Info gathered from: the NetBSD disklabel section 5 man page */\r\n\r\n#define NETBSD_MAXPARTITIONS   22\r\n\r\ntypedef struct NetBSD_disklabel {\r\n    uint32  d_magic;        /* the magic number */\r\n    uint16  d_type;         /* drive type */\r\n    uint16  d_subtype;      /* controller/d_type specific */\r\n    char    d_typename[16]; /* type name, e.g. \"eagle\" */\r\n    /*\r\n     * d_packname contains the pack identifier and is returned when\r\n     * the disklabel is read off the disk or in-core copy.\r\n     * d_boot0 is the (optional) name of the primary (block 0) bootstrap\r\n     * as found in /mdec.  This is returned when using\r\n     * getdiskbyname(3) to retrieve the values from /etc/disktab.\r\n     */\r\n    char    d_packname[16];     /* pack identifier */\r\n                                /* disk geometry: */\r\n    uint32  d_secsize;          /* # of bytes per sector */\r\n    uint32  d_nsectors;         /* # of data sectors per track */\r\n    uint32  d_ntracks;          /* # of tracks per cylinder */\r\n    uint32  d_ncylinders;       /* # of data cylinders per unit */\r\n    uint32  d_secpercyl;        /* # of data sectors per cylinder */\r\n    uint32  d_secperunit;       /* # of data sectors per unit */\r\n    /*\r\n     * Spares (bad sector replacements) below\r\n     * are not counted in d_nsectors or d_secpercyl.\r\n     * Spare sectors are assumed to be physical sectors\r\n     * which occupy space at the end of each track and/or cylinder.\r\n     */\r\n    uint16  d_sparespertrack;   /* # of spare sectors per track */\r\n    uint16  d_sparespercyl;     /* # of spare sectors per cylinder */\r\n    /*\r\n     * Alternate cylinders include maintenance, replacement,\r\n     * configuration description areas, etc.\r\n     */\r\n    uint32  d_acylinders;       /* # of alt. cylinders per unit */\r\n\r\n        /* hardware characteristics: */\r\n    /*\r\n     * d_interleave, d_trackskew and d_cylskew describe perturbations\r\n     * in the media format used to compensate for a slow controller.\r\n     * Interleave is physical sector interleave, set up by the formatter\r\n     * or controller when formatting.  When interleaving is in use,\r\n     * logically adjacent sectors are not physically contiguous,\r\n     * but instead are separated by some number of sectors.\r\n     * It is specified as the ratio of physical sectors traversed\r\n     * per logical sector.  Thus an interleave of 1:1 implies contiguous\r\n     * layout, while 2:1 implies that logical sector 0 is separated\r\n     * by one sector from logical sector 1.\r\n     * d_trackskew is the offset of sector 0 on track N\r\n     * relative to sector 0 on track N-1 on the same cylinder.\r\n     * Finally, d_cylskew is the offset of sector 0 on cylinder N\r\n     * relative to sector 0 on cylinder N-1.\r\n     */\r\n    uint16  d_rpm;              /* rotational speed */\r\n    uint16  d_interleave;       /* hardware sector interleave */\r\n    uint16  d_trackskew;        /* sector 0 skew, per track */\r\n    uint16  d_cylskew;          /* sector 0 skew, per cylinder */\r\n    uint32  d_headswitch;       /* head swith time, usec */\r\n    uint32  d_trkseek;          /* track-to-track seek, msec */\r\n    uint32  d_flags;            /* generic flags */\r\n#define NDDATA 5\r\n    uint32  d_drivedata[NDDATA]; /* drive-type specific information */\r\n#define NSPARE 5\r\n    uint32  d_spare[NSPARE];    /* reserved for future use */\r\n    uint32  d_magic2;           /* the magic number (again) */\r\n    uint16  d_checksum;         /* xor of data incl. partitions */\r\n\r\n            /* filesystem and partition information: */\r\n    uint16  d_npartitions;      /* number of partitions in following */\r\n    uint32  d_bbsize;           /* size of boot area at sn0, bytes */\r\n    uint32  d_sbsize;           /* max size of fs superblock, bytes */\r\n    struct  {                   /* the partition table */\r\n        uint32  p_size;         /* number of sectors in partition */\r\n        uint32  p_offset;       /* starting sector */\r\n        uint32  p_fsize;        /* filesystem basic fragment size */\r\n        uint8   p_fstype;       /* filesystem type, see below */\r\n        uint8   p_frag;         /* filesystem fragments per block */\r\n        union {\r\n            uint16 cpg;         /* UFS: FS cylinders per group */\r\n            uint16 sgs;         /* LFS: FS segment shift */\r\n            } __partition_u1;\r\n#define p_cpg   __partition_ul.cpg\r\n#define p_sgs   __partition_ul.sgs\r\n        } d_partitions[NETBSD_MAXPARTITIONS];/* actually may be more */\r\n} NetBSD_disklabel;\r\n\r\n\r\nstatic t_offset get_NetBSD_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nuint8 sector_buf[512];\r\nNetBSD_disklabel *Label = (NetBSD_disklabel *)(&sector_buf[64]);\r\nt_offset ret_val = (t_offset)-1;\r\nuint16 i = sizeof (NetBSD_disklabel);\r\nuint32 max_lbn = 0, max_lbn_partnum = 0;\r\nt_seccnt sects_read;\r\nuint16 sum = 0;\r\nuint16 *pdata;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\nif ((_DEC_rdsect (uptr, 0, (uint8 *)sector_buf, &sects_read, 512 / ctx->sector_size, physsectsz)) ||\r\n    (sects_read != (512 / ctx->sector_size)))\r\n    goto Return_Cleanup;\r\n\r\n/* Confirm the Label magic numbers */\r\nif ((Label->d_magic != BSD_DISKMAGIC) ||\r\n    (Label->d_magic2 != BSD_DISKMAGIC))\r\n    goto Return_Cleanup;\r\n\r\n/* Verify the label checksum */\r\nif (Label->d_npartitions > NETBSD_MAXPARTITIONS)\r\n    goto Return_Cleanup;\r\n\r\npdata = (uint16 *)Label;\r\nfor (sum = 0, pdata = (uint16 *)Label; pdata < (uint16 *)&Label->d_partitions[Label->d_npartitions]; pdata++)\r\n    sum ^= *pdata;\r\n\r\nif (sum != 0)\r\n    goto Return_Cleanup;\r\n\r\n/* Walk through the partitions */\r\nfor (i = 0; i < Label->d_npartitions; i++) {\r\n    uint32 end_lbn = Label->d_partitions[i].p_offset + Label->d_partitions[i].p_size;\r\n    if (end_lbn > max_lbn) {\r\n        max_lbn = end_lbn;\r\n        max_lbn_partnum = i;\r\n        }\r\n    }\r\nsim_messagef (SCPE_OK, \"%s: '%s' Contains NET/Open BSD partitions\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\nsim_messagef (SCPE_OK, \"Partition with highest sector: %c, Sectors On Disk: %u\\n\", 'a' + max_lbn_partnum, max_lbn);\r\nret_val = ((t_offset)max_lbn) * 512;\r\n\r\nReturn_Cleanup:\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\n\r\n#pragma pack(push,1)\r\n/*\r\n * The first logical block of device cluster 1 is either:\r\n *      1. MFD label entry (RSTS versions through 7.x)\r\n *      2. Disk Pack label (RSTS version 8.0 and later)\r\n */\r\ntypedef struct _RSTS_MFDLABEL {\r\n    uint16  ml_ulnk;\r\n    uint16  ml_mbm1;\r\n    uint16  ml_reserved1;\r\n    uint16  ml_reserved2;\r\n    uint16  ml_pcs;\r\n    uint16  ml_pstat;\r\n    uint16  ml_packid[2];\r\n    } RSTS_MFDLABEL;\r\n\r\ntypedef struct _RSTS_PACKLABEL {\r\n    uint16  pk_mb01;\r\n    uint16  pk_mbm1;\r\n    uint16  pk_mdcn;\r\n    uint16  pk_plvl;\r\n#define PK_LVL0         0000\r\n#define PK_LVL11        0401\r\n#define PK_LVL12        0402\r\n    uint16  pk_ppcs;\r\n    uint16  pk_pstat;\r\n#define PK_UC_NEW       0020000\r\n    uint16  pk_packid[2];\r\n    uint16  pk_tapgvn[2];\r\n    uint16  pk_bckdat;\r\n    uint16  pk_bcktim;\r\n    } RSTS_PACKLABEL;\r\n\r\ntypedef union _RSTS_ROOT {\r\n    RSTS_MFDLABEL  rt_mfd;\r\n    RSTS_PACKLABEL rt_pack;\r\n    uint8          rt_block[512];\r\n    } RSTS_ROOT;\r\n\r\ntypedef struct _RSTS_MFDBLOCKETTE {\r\n    uint16  mb_ulnk;\r\n    uint16  mb_mbm1;\r\n    uint16  mb_reserved1;\r\n    uint16  mb_reserved2;\r\n    uint16  mb_reserved3;\r\n    uint16  mb_malnk;\r\n    uint16  mb_lppn;\r\n    uint16  mb_lid;\r\n#define MB_ID           0051064\r\n    } RSTS_MFDBLOCKETTE;\r\n#define IS_VALID_RSTS_MFD(b) \\\r\n     ((((b)->mb_ulnk == 0) || ((b)->mb_ulnk == 1)) &&                         \\\r\n      ((b)->mb_mbm1 == 0177777) &&                                            \\\r\n      ((b)->mb_reserved1 == 0) &&                                             \\\r\n      ((b)->mb_reserved2 == 0) &&                                             \\\r\n      ((b)->mb_reserved3 == 0) &&                                             \\\r\n      ((b)->mb_lppn == 0177777) &&                                            \\\r\n      ((b)->mb_lid == MB_ID))\r\n\r\ntypedef struct _RSTS_GFDBLOCKETTE {\r\n    uint16  gb_ulnk;\r\n    uint16  gb_mbm1;\r\n    uint16  gb_reserved1;\r\n    uint16  gb_reserved2;\r\n    uint16  gb_reserved3;\r\n    uint16  gb_reserved4;\r\n    uint16  gb_lppn;\r\n    uint16  gb_lid;\r\n#define GB_ID           0026264\r\n    } RSTS_GFDBLOCKETTE;\r\n#define IS_VALID_RSTS_GFD(b, g) \\\r\n     ((((b)->gb_ulnk == 0) || ((b)->gb_ulnk == 1)) &&                         \\\r\n      ((b)->gb_mbm1 == 0177777) &&                                            \\\r\n      ((b)->gb_reserved1 == 0) &&                                             \\\r\n      ((b)->gb_reserved2 == 0) &&                                             \\\r\n      ((b)->gb_reserved3 == 0) &&                                             \\\r\n      ((b)->gb_reserved4 == 0) &&                                             \\\r\n      ((b)->gb_lppn == (((g) << 8) | 0377)) &&                                \\\r\n      ((b)->gb_lid == GB_ID))\r\n\r\ntypedef struct _RSTS_UFDBLOCKETTE {\r\n    uint16  ub_ulnk;\r\n    uint16  ub_mbm1;\r\n    uint16  ub_reserved1;\r\n    uint16  ub_reserved2;\r\n    uint16  ub_reserved3;\r\n    uint16  ub_reserved4;\r\n    uint16  ub_lppn;\r\n    uint16  ub_lid;\r\n#define UB_ID           0102064\r\n    } RSTS_UFDBLOCKETTE;\r\n#define IS_VALID_RSTS_UFD(b, g, u) \\\r\n     (((b)->ub_mbm1 == 0177777) &&                                            \\\r\n      ((b)->ub_reserved1 == 0) &&                                             \\\r\n      ((b)->ub_reserved2 == 0) &&                                             \\\r\n      ((b)->ub_reserved3 == 0) &&                                             \\\r\n      ((b)->ub_reserved4 == 0) &&                                             \\\r\n      ((b)->ub_lppn == (((g) << 8) | (u))) &&                                 \\\r\n      ((b)->ub_lid == UB_ID))\r\n\r\ntypedef struct _RSTS_UNAME {\r\n    uint16  un_ulnk;\r\n    uint16  un_unam;\r\n    uint16  un_reserved1;\r\n    uint16  un_reserved2;\r\n    uint16  un_ustat;\r\n    uint16  un_uacnt;\r\n    uint16  un_uaa;\r\n    uint16  un_uar;\r\n    } RSTS_UNAME;\r\n\r\ntypedef struct _RSTS_FNAME {\r\n    uint16  fn_ulnk;\r\n    uint16  fn_unam[3];\r\n    uint16  fn_ustat;\r\n    uint16  fn_uacnt;\r\n    uint16  fn_uaa;\r\n    uint16  fn_uar;\r\n    } RSTS_FNAME;\r\n\r\ntypedef struct _RSTS_ACNT {\r\n    uint16  ac_ulnk;\r\n    uint16  ac_udla;\r\n    uint16  ac_usiz;\r\n    uint16  ac_udc;\r\n    uint16  ac_utc;\r\n    uint16  ac_urts[2];\r\n    uint16  ac_uclus;\r\n    } RSTS_ACNT;\r\n\r\ntypedef struct _RSTS_RETR {\r\n    uint16  rt_ulnk;\r\n    uint16  rt_uent[7];\r\n#define RT_ENTRIES      7\r\n    } RSTS_RETR;\r\n\r\ntypedef struct _RSTS_DCMAP {\r\n    uint16  dc_clus;\r\n#define DC_MASK         0077777\r\n    uint16  dc_map[7];\r\n    }  RSTS_DCMAP;\r\n\r\n/*\r\n * Directory link definitions\r\n */\r\n#define DL_USE          0000001\r\n#define DL_BAD          0000002\r\n#define DL_CHE          0000004\r\n#define DL_CLN          0000010\r\n#define DL_ENO          0000760\r\n#define DL_CLO          0007000\r\n#define DL_BLO          0170000\r\n\r\n#define DLSH_ENO         4\r\n#define DLSH_CLO         9\r\n#define DLSH_BLO        12\r\n\r\n#define BLOCKETTE_SZ    (8 * sizeof(uint16))\r\n#define MAP_OFFSET      (31 * BLOCKETTE_SZ)\r\n\r\n#define SATT0           0073374\r\n#define SATT1           0076400\r\n#define SATT2           0075273\r\n\r\n#pragma pack(pop)\r\n\r\ntypedef struct _rstsContext {\r\n    UNIT        *uptr;\r\n    int         dcshift;\r\n    int         pcs;\r\n    char        packid[8];\r\n    t_seccnt    sects;\r\n    RSTS_DCMAP  map;\r\n} rstsContext;\r\n\r\nstatic char rad50[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ$.%0123456789\";\r\n\r\nstatic void r50Asc(uint16 val, char *buf)\r\n{\r\nbuf[2] = rad50[val % 050];\r\nval /= 050;\r\nbuf[1] = rad50[val % 050];\r\nbuf[0] = rad50[val / 050];\r\n}\r\n\r\nstatic t_stat rstsValidateClusterSize(uint16 size, uint16 minSize)\r\n{\r\nint i;\r\n\r\n/*\r\n * Check that the cluster size is a power of 2 and greater than or equal\r\n * to some location dependent value.\r\n */\r\nif (size >= minSize)\r\n    for (i = 0; i < 16; i++)\r\n        if (size == (1 << i))\r\n            return SCPE_OK;\r\n\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat rstsReadBlock(rstsContext *context, uint16 cluster, uint16 block, void *buf)\r\n{\r\nt_lba blk = (cluster << context->dcshift) + block;\r\nt_seccnt sects_read;\r\n\r\nif ((sim_disk_rdsect(context->uptr, blk * context->sects, (uint8 *)buf, &sects_read, context->sects) == SCPE_OK) &&\r\n    (sects_read == context->sects))\r\n    return SCPE_OK;\r\n\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat rstsReadBlockette(rstsContext *context, uint16 link, void *buf)\r\n{\r\nuint16 block = (link & DL_BLO) >> DLSH_BLO;\r\nuint16 dcn = (link & DL_CLO) >> DLSH_CLO;\r\nuint16 blockette = (link & DL_ENO) >> DLSH_ENO;\r\nuint8 temp[512];\r\n\r\nif ((dcn != 7) && (blockette != 31) &&\r\n    (block <= (context->map.dc_clus & DC_MASK))) {\r\n    if (rstsReadBlock(context, context->map.dc_map[dcn], block, temp) == SCPE_OK) {\r\n        memcpy(buf, &temp[blockette * BLOCKETTE_SZ], BLOCKETTE_SZ);\r\n        return SCPE_OK;\r\n        }\r\n    }\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat rstsFind01UFD(rstsContext *context, uint16 *ufd, uint16 *level)\r\n{\r\nuint16 dcs = 1 << context->dcshift;\r\nRSTS_ROOT root;\r\nuint16 buf[256];\r\n\r\nif (rstsReadBlock(context, 1, 0, &root) == SCPE_OK) {\r\n    /*\r\n     * First validate fields which are common to both the MFD label and\r\n     * Pack label - we'll use Pack label offsets here.\r\n     */\r\n    if ((root.rt_pack.pk_mbm1 == 0177777) &&\r\n        (rstsValidateClusterSize(root.rt_pack.pk_ppcs, dcs) == SCPE_OK)) {\r\n        char ch, *tmp = &context->packid[1];\r\n        uint16 mfd, gfd;\r\n\r\n        context->pcs = root.rt_pack.pk_ppcs;\r\n\r\n        r50Asc(root.rt_pack.pk_packid[0], &context->packid[0]);\r\n        r50Asc(root.rt_pack.pk_packid[1], &context->packid[3]);\r\n        context->packid[6] = '\\0';\r\n\r\n        /*\r\n         * The Pack ID must consist of 1 - 6 alphanumeric characters\r\n         * padded at the end with spaces.\r\n         */\r\n        if (!isalnum(context->packid[0]))\r\n            return SCPE_IOERR;\r\n\r\n        while ((ch = *tmp++) != 0) {\r\n            if (!isalnum(ch)) {\r\n                if (ch != ' ')\r\n                    return SCPE_IOERR;\r\n\r\n                while (*tmp)\r\n                    if (*tmp++ != ' ')\r\n                        return SCPE_IOERR;\r\n                break;\r\n                }\r\n            }\r\n\r\n        /*\r\n         * Determine the pack revision level and, therefore, the path to\r\n         * [0,1]satt.sys which will allow us to determine the size of the\r\n         * pack used by RSTS.\r\n         */\r\n        if ((root.rt_pack.pk_pstat & PK_UC_NEW) == 0) {\r\n            uint16 link = root.rt_mfd.ml_ulnk;\r\n            RSTS_UNAME uname;\r\n\r\n            /*\r\n             * Old format used by RSTS up through V07.x\r\n             */\r\n            if (dcs > 16)\r\n                return SCPE_IOERR;\r\n\r\n            *level = PK_LVL0;\r\n\r\n            memcpy(&context->map, &root.rt_block[MAP_OFFSET], BLOCKETTE_SZ);\r\n\r\n            /*\r\n             * Scan the MFD name entries looking for [0,1]. Note there will\r\n             * always be at least 1 entry.\r\n             */\r\n            do {\r\n                if (rstsReadBlockette(context, link, &uname) != SCPE_OK)\r\n                    break;\r\n\r\n                if (uname.un_unam == ((0 << 8) | 1)) {\r\n                    *ufd = uname.un_uar;\r\n                    return SCPE_OK;\r\n                    }\r\n                } while ((link = uname.un_ulnk) != 0);\r\n            }\r\n        else {\r\n            /*\r\n             * New format used by RSTS V08 and later\r\n             */\r\n            switch (root.rt_pack.pk_plvl) {\r\n                case PK_LVL11:\r\n                    if (dcs > 16)\r\n                        return SCPE_IOERR;\r\n                    break;\r\n\r\n                case PK_LVL12:\r\n                    if (dcs > 64)\r\n                        return SCPE_IOERR;\r\n                    break;\r\n\r\n                default:\r\n                    return SCPE_IOERR;\r\n                }\r\n            *level = root.rt_pack.pk_plvl;\r\n\r\n            mfd = root.rt_pack.pk_mdcn;\r\n\r\n            if (rstsReadBlock(context, mfd, 0, buf) == SCPE_OK) {\r\n                if (IS_VALID_RSTS_MFD((RSTS_MFDBLOCKETTE *)buf)) {\r\n                    if (rstsReadBlock(context, mfd, 1, buf) == SCPE_OK)\r\n                        if ((gfd = buf[0]) != 0)\r\n                            if (rstsReadBlock(context, gfd, 0, buf) == SCPE_OK)\r\n                                if (IS_VALID_RSTS_GFD((RSTS_GFDBLOCKETTE *)buf, 0)) {\r\n                                    if (rstsReadBlock(context, gfd, 1, buf) == SCPE_OK)\r\n                                        if ((*ufd = buf[1]) != 0)\r\n                                            return SCPE_OK;\r\n                                    }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat rstsLoadAndScanSATT(rstsContext *context, uint16 uaa, uint16 uar, t_offset *result)\r\n{\r\nuint8 bitmap[8192];\r\nint i, j;\r\nRSTS_ACNT acnt;\r\nRSTS_RETR retr;\r\n\r\nif (uar != 0) {\r\n    if (rstsReadBlockette(context, uaa, &acnt) == SCPE_OK) {\r\n        uint16 blocks = acnt.ac_usiz;\r\n        uint16 offset = 0;\r\n\r\n        if ((rstsValidateClusterSize(acnt.ac_uclus, context->pcs) != SCPE_OK) ||\r\n            (blocks > 16))\r\n            return SCPE_IOERR;\r\n\r\n        memset(bitmap, 0xFF, sizeof(bitmap));\r\n\r\n        if (blocks != 0) {\r\n            do {\r\n                int i, j;\r\n                uint16 fcl;\r\n\r\n                if (rstsReadBlockette(context, uar, &retr) != SCPE_OK)\r\n                    return SCPE_IOERR;\r\n\r\n                for (i = 0; i < RT_ENTRIES; i++) {\r\n                    if ((fcl = retr.rt_uent[i]) == 0)\r\n                        goto scanBitmap;\r\n\r\n                    for (j = 0; j < acnt.ac_uclus; j++) {\r\n                        if ((blocks == 0) || (offset >= sizeof(bitmap)))\r\n                            goto scanBitmap;\r\n\r\n                        if (rstsReadBlock(context, fcl, j, &bitmap[offset]) != SCPE_OK)\r\n                            return SCPE_IOERR;\r\n\r\n                        offset += 512;\r\n                        blocks--;\r\n                        }\r\n                    }\r\n                } while ((uar = retr.rt_ulnk) != 0);\r\n\r\n        scanBitmap:\r\n            for (i = sizeof(bitmap) - 1; i != 0; i--)\r\n                if (bitmap[i] != 0xFF) {\r\n                    blocks = i * 8;\r\n                    for (j = 7; j >= 0; j--)\r\n                        if ((bitmap[i] & (1 << j)) == 0) {\r\n                            blocks += j + 1;\r\n                            goto scanDone;\r\n                            }\r\n                    }\r\n        scanDone:\r\n            *result = (t_offset)(blocks + 1) * context->pcs;\r\n            return SCPE_OK;\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_offset get_rsts_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nuint8 buf[512];\r\nt_offset ret_val = (t_offset)-1;\r\nrstsContext context;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\n\r\ncontext.uptr = uptr;\r\ncontext.sects = 512 / ctx->sector_size;\r\n\r\n/*\r\n * Check all possible device cluster sizes\r\n */\r\nfor (context.dcshift = 0; context.dcshift < 8; context.dcshift++) {\r\n    uint16 ufd, level;\r\n\r\n    /*\r\n     * We need to find [0,1]SATT.SYS to compute the actual size of the disk.\r\n     * First find the DCN of the [0,1] UFD.\r\n     */\r\n    if (rstsFind01UFD(&context, &ufd, &level) == SCPE_OK) {\r\n        if (rstsReadBlock(&context, ufd, 0, buf) == SCPE_OK) {\r\n            if (IS_VALID_RSTS_UFD((RSTS_UFDBLOCKETTE *)buf, 0, 1)) {\r\n                uint16 link = ((RSTS_UFDBLOCKETTE *)buf)->ub_ulnk;\r\n                RSTS_FNAME fname;\r\n\r\n                memcpy(&context.map, &buf[MAP_OFFSET], BLOCKETTE_SZ);\r\n\r\n                /*\r\n                 * Scan the UFD looking for SATT.SYS - the allocation bitmap\r\n                 */\r\n                do {\r\n                    if (rstsReadBlockette(&context, link, &fname) != SCPE_OK)\r\n                        break;\r\n\r\n                    if ((fname.fn_unam[0] == SATT0) &&\r\n                        (fname.fn_unam[1] == SATT1) &&\r\n                        (fname.fn_unam[2] == SATT2)) {\r\n                        if (rstsLoadAndScanSATT(&context, fname.fn_uaa, fname.fn_uar, &ret_val) == SCPE_OK) {\r\n                            const char *fmt = \"???\";\r\n\r\n                            ret_val *= 512;\r\n\r\n                            switch (level) {\r\n                                case PK_LVL0:\r\n                                    fmt = \"0.0\";\r\n                                    break;\r\n\r\n                                case PK_LVL11:\r\n                                    fmt = \"1.1\";\r\n                                    break;\r\n\r\n                                case PK_LVL12:\r\n                                    fmt = \"1.2\";\r\n                                    break;\r\n                                }\r\n\r\n                            sim_messagef(SCPE_OK, \"%s: '%s' Contains a RSTS File system\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\n                            sim_messagef(SCPE_OK, \"%s: Pack ID: %6.6s Revision Level: %3s Pack Clustersize: %d\\n\",\r\n                                                                  sim_uname (uptr), context.packid, fmt, context.pcs);\r\n                            sim_messagef(SCPE_OK, \"%s: Last Unallocated Sector In File System: %u\\n\", sim_uname (uptr), (uint32)((ret_val / 512) - 1));\r\n                            goto cleanup_done;\r\n                            }\r\n                        }\r\n                    } while ((link = fname.fn_ulnk) != 0);\r\n                }\r\n            }\r\n        }\r\n    }\r\ncleanup_done:\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\n#pragma pack(push,1)\r\ntypedef struct _RT11_HomeBlock {\r\n    uint8   hb_b_bbtable[130];\r\n    uint8   hb_b_unused1[2];\r\n    uint8   hb_b_initrestore[38];\r\n    uint8   hb_b_bup[18];\r\n    uint8   hb_b_unused2[260];\r\n    uint16  hb_w_reserved1;\r\n    uint16  hb_w_reserved2;\r\n    uint8   hb_b_unused3[14];\r\n    uint16  hb_w_clustersize;\r\n    uint16  hb_w_firstdir;\r\n    uint16  hb_w_sysver;\r\n#define HB_C_SYSVER_V3A 36521\r\n#define HB_C_SYSVER_V04 36434\r\n#define HB_C_SYSVER_V05 36435\r\n    uint8   hb_b_volid[12];\r\n    uint8   hb_b_owner[12];\r\n    uint8   hb_b_sysid[12];\r\n#define HB_C_SYSID      \"DECRT11A    \"\r\n#define HB_C_VMSSYSID   \"DECVMSEXCHNG\"\r\n    uint8   hb_b_unused4[2];\r\n    uint16  hb_w_checksum;\r\n    } RT11_HomeBlock;\r\n\r\ntypedef struct _RT11_DirHeader {\r\n    uint16  dh_w_count;\r\n    uint16  dh_w_next;\r\n    uint16  dh_w_highest;\r\n#define DH_C_MAXSEG     31\r\n    uint16  dh_w_extra;\r\n    uint16  dh_w_start;\r\n    } RT11_DirHeader;\r\n\r\ntypedef struct _RT11_DirEntry {\r\n    uint16  de_w_status;\r\n#define DE_C_PRE        0000020\r\n#define DE_C_TENT       0000400\r\n#define DE_C_EMPTY      0001000\r\n#define DE_C_PERM       0002000\r\n#define DE_C_EOS        0004000\r\n#define DE_C_READ       0040000\r\n#define DE_C_PROT       0100000\r\n    uint16  de_w_fname1;\r\n    uint16  de_w_fname2;\r\n    uint16  de_w_ftype;\r\n    uint16  de_w_length;\r\n    uint16  de_w_jobchannel;\r\n    uint16  de_w_creationdate;\r\n    } RT11_DirEntry;\r\n#pragma pack(pop)\r\n\r\n#define RT11_MAXPARTITIONS      256             /* Max partitions supported */\r\n#define RT11_HOME                 1             /* Home block # */\r\n\r\n#define RT11_NOPART             0\r\n#define RT11_SINGLEPART         1\r\n#define RT11_MULTIPART          2\r\n\r\nstatic int rt11_get_partition_type(RT11_HomeBlock *home, int part)\r\n{\r\nif (strncmp((char *)&home->hb_b_sysid, HB_C_SYSID, strlen(HB_C_SYSID)) == 0) {\r\n    uint16 type = home->hb_w_sysver;\r\n\r\n    if (part == 0) {\r\n        if ((type == HB_C_SYSVER_V3A) || (type == HB_C_SYSVER_V04))\r\n            return RT11_SINGLEPART;\r\n        }\r\n\r\n    if (type == HB_C_SYSVER_V05)\r\n        return RT11_MULTIPART;\r\n    }\r\n\r\nif (strncmp((char *)&home->hb_b_sysid, HB_C_VMSSYSID, strlen(HB_C_VMSSYSID)) == 0)\r\n    return RT11_SINGLEPART;\r\n\r\nreturn RT11_NOPART;\r\n}\r\n\r\nstatic t_offset get_rt11_filesystem_size (UNIT *uptr, uint32 physsectsz, t_bool *isreadonly)\r\n{\r\nt_addr saved_capac;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nt_addr temp_capac = (sim_toffset_64 ? (t_addr)0xFFFFFFFFu : (t_addr)0x7FFFFFFFu);  /* Make sure we can access the largest sector */\r\nuint8 sector_buf[1024];\r\nRT11_HomeBlock Home;\r\nt_seccnt sects_read;\r\nRT11_DirHeader *dir_hdr = (RT11_DirHeader *)sector_buf;\r\nint partitions = 0;\r\nint part;\r\nuint32 base;\r\nuint32 dir_sec;\r\nuint16 dir_seg;\r\nuint16 version = 0;\r\nt_offset ret_val = (t_offset)-1;\r\n\r\nsaved_capac = uptr->capac;\r\nuptr->capac = temp_capac;\r\n\r\nfor (part = 0; part < RT11_MAXPARTITIONS; part++) {\r\n    uint16 seg_highest = 0;\r\n    int type;\r\n\r\n    /*\r\n     * RX01/RX02 media can only have a single partition\r\n     */\r\n    if ((part != 0) && (physsectsz != 0))\r\n      break;\r\n\r\n    base = part << 16;\r\n\r\n    if (_DEC_rdsect(uptr, (base + RT11_HOME) * (512 / ctx->sector_size), (uint8 *)&Home, &sects_read, 512 / ctx->sector_size, physsectsz) ||\r\n        (sects_read != (512 / ctx->sector_size)))\r\n        goto Return_Cleanup;\r\n\r\n    type = rt11_get_partition_type(&Home, part);\r\n\r\n    if (type != RT11_NOPART) {\r\n        uint16 highest = 0;\r\n        uint8 seg_seen[DH_C_MAXSEG + 1];\r\n\r\n        memset(seg_seen, 0, sizeof(seg_seen));\r\n\r\n        partitions++;\r\n\r\n        dir_seg = 1;\r\n        do {\r\n            int offset = sizeof(RT11_DirHeader);\r\n            int dir_size = sizeof(RT11_DirEntry);\r\n            uint16 cur_blk;\r\n\r\n            if (seg_seen[dir_seg]++ != 0)\r\n                goto Next_Partition;\r\n\r\n            dir_sec = Home.hb_w_firstdir + ((dir_seg - 1) * 2);\r\n\r\n            if ((_DEC_rdsect(uptr, (base + dir_sec) * (512 / ctx->sector_size), sector_buf, &sects_read, 1024 / ctx->sector_size, physsectsz)) ||\r\n                (sects_read != (1024 / ctx->sector_size)))\r\n                goto Return_Cleanup;\r\n\r\n            if (dir_seg == 1) {\r\n                seg_highest = dir_hdr->dh_w_highest;\r\n                if (seg_highest > DH_C_MAXSEG)\r\n                    goto Next_Partition;\r\n                }\r\n            dir_size += dir_hdr->dh_w_extra;\r\n            cur_blk = dir_hdr->dh_w_start;\r\n\r\n            while ((1024 - offset) >= dir_size) {\r\n                RT11_DirEntry *dir_entry = (RT11_DirEntry *)&sector_buf[offset];\r\n\r\n                if (dir_entry->de_w_status & DE_C_EOS)\r\n                    break;\r\n\r\n                /*\r\n                 * Within each directory segment the bas address should never\r\n                 * decrease.\r\n                 */\r\n                if (((cur_blk + dir_entry->de_w_length) & 0xFFFF) < cur_blk)\r\n                    goto Next_Partition;\r\n\r\n                cur_blk += dir_entry->de_w_length;\r\n                offset += dir_size;\r\n                }\r\n            if (cur_blk > highest)\r\n                highest = cur_blk;\r\n            dir_seg = dir_hdr->dh_w_next;\r\n\r\n            if (dir_seg > seg_highest)\r\n                goto Next_Partition;\r\n            } while (dir_seg != 0);\r\n\r\n        ret_val = (t_offset)((base + highest) * (t_offset)512);\r\n        version = Home.hb_w_sysver;\r\n\r\n        if (type == RT11_SINGLEPART)\r\n          break;\r\n        }\r\nNext_Partition:\r\n    ;\r\n    }\r\n\r\nReturn_Cleanup:\r\nif (partitions) {\r\n    const char *parttype;\r\n\r\n    switch (version) {\r\n        case HB_C_SYSVER_V3A:\r\n            parttype = \"V3A\";\r\n            break;\r\n\r\n        case HB_C_SYSVER_V04:\r\n            parttype = \"V04\";\r\n            break;\r\n\r\n        case HB_C_SYSVER_V05:\r\n            parttype = \"V05\";\r\n            break;\r\n\r\n        default:\r\n            parttype = \"???\";\r\n            break;\r\n        }\r\n    sim_messagef (SCPE_OK, \"%s: '%s' Contains RT11 partitions\\n\", sim_uname (uptr), sim_relative_path (uptr->filename));\r\n    sim_messagef (SCPE_OK, \"%d valid partition%s, Type: %s, Sectors On Disk: %u\\n\", partitions, partitions == 1 ? \"\" : \"s\", parttype, (uint32)(ret_val / 512));\r\n    }\r\nuptr->capac = saved_capac;\r\nif (isreadonly)\r\n    *isreadonly = sim_disk_wrp (uptr);\r\nreturn ret_val;\r\n}\r\n\r\nt_offset pseudo_filesystem_size = 0;        /* Dummy file system check return used during testing */\r\n\r\ntypedef t_offset (*FILESYSTEM_CHECK)(UNIT *uptr, uint32, t_bool *);\r\n\r\nstatic t_offset get_filesystem_size (UNIT *uptr, t_bool *isreadonly)\r\n{\r\nstatic FILESYSTEM_CHECK checks[] = {\r\n    &get_ods2_filesystem_size,\r\n    &get_ods1_filesystem_size,\r\n    &get_ultrix_filesystem_size,\r\n    &get_iso9660_filesystem_size,\r\n    &get_rsts_filesystem_size,\r\n    &get_BSD_211_filesystem_size,\r\n    &get_NetBSD_filesystem_size,\r\n    &get_rt11_filesystem_size,          /* This should be the last entry\r\n                                           in the table to reduce the\r\n                                           possibility of matching an RT-11\r\n                                           container file stored in another\r\n                                           filesystem */\r\n    NULL\r\n    };\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nuint32 saved_sector_size = ctx->sector_size;\r\nt_offset ret_val = (t_offset)-1;\r\nint i;\r\n\r\nif (isreadonly != NULL)\r\n    *isreadonly = FALSE;\r\n\r\nif (pseudo_filesystem_size != 0) {      /* Dummy file system size mechanism? */\r\n    sim_messagef (SCPE_OK, \"%s: '%s' Pseudo File System containing %u %d byte sectors\\n\", sim_uname (uptr), uptr->filename, (uint32)(pseudo_filesystem_size / ctx->sector_size), ctx->sector_size);\r\n    return pseudo_filesystem_size;\r\n    }\r\n\r\nfor (i = 0; checks[i] != NULL; i++)\r\n    if ((ret_val = checks[i] (uptr, 0, isreadonly)) != (t_offset)-1) {\r\n        /* ISO files that haven't already been determined to be ISO 9660\r\n         * which contain a known file system are also marked read-only\r\n         * now.  This fits early DEC distribution CDs that were created\r\n         * before ISO 9660 was standardized and operating support was added.\r\n         */\r\n        if ((isreadonly != NULL)          &&\r\n            (*isreadonly == FALSE)        &&\r\n            (NULL != match_ext (uptr->filename, \"ISO\")))\r\n            *isreadonly = TRUE;\r\n        return ret_val;\r\n        }\r\n/*\r\n * The only known interleaved disk devices have either 256 byte\r\n * or 128 byte sector sizes.  If additional interleaved file\r\n * system scenarios with different sector sizes come up they\r\n * should be added here.\r\n */\r\n\r\nfor (i = 0; checks[i] != NULL; i++) {\r\n    ctx->sector_size = 256;\r\n    if ((ret_val = checks[i] (uptr, ctx->sector_size, isreadonly)) != (t_offset)-1)\r\n        break;\r\n    ctx->sector_size = 128;\r\n    if ((ret_val = checks[i] (uptr, ctx->sector_size, isreadonly)) != (t_offset)-1)\r\n        break;\r\n    }\r\nif (ret_val != (t_offset)-1) {\r\n    ctx->data_ileave = RX0xINTER;\r\n    ctx->data_ileave_skew = RX0xISKEW;\r\n    if (ctx->sector_size != saved_sector_size)\r\n        sim_messagef (SCPE_OK, \"%s: with an unexpected sector size of %u bytes instead of %u bytes\\n\",\r\n                               sim_uname (uptr), ctx->sector_size, saved_sector_size);\r\n    }\r\nctx->sector_size = saved_sector_size;\r\nreturn ret_val;\r\n}\r\n\r\nstatic t_stat store_disk_footer (UNIT *uptr, const char *dtype);\r\n\r\nstatic t_stat get_disk_footer (UNIT *uptr, struct disk_context **pctx)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nstruct simh_disk_footer *f = (struct simh_disk_footer *)calloc (1, sizeof (*f));\r\nt_offset container_size;\r\nt_offset sim_fsize_ex (FILE *fptr);\r\nuint32 bytesread;\r\n\r\nif (f == NULL)\r\n    return SCPE_MEM;\r\nif (pctx != NULL)\r\n    *pctx = ctx;\r\nsim_debug_unit (ctx->dbit, uptr, \"get_disk_footer(%s)\\n\", sim_uname (uptr));\r\nswitch (DK_GET_FMT (uptr)) {                            /* case on format */\r\n    case DKUF_F_STD:                                    /* SIMH format */\r\n        container_size = sim_fsize_ex (uptr->fileref);\r\n        if ((container_size != (t_offset)-1) && (container_size > (t_offset)sizeof (*f)) &&\r\n            (sim_fseeko (uptr->fileref, container_size - sizeof (*f), SEEK_SET) == 0) &&\r\n            (sizeof (*f) == sim_fread (f, 1, sizeof (*f), uptr->fileref)))\r\n            break;\r\n        free (f);\r\n        f = NULL;\r\n        break;\r\n    case DKUF_F_RAW:                                    /* RAW format */\r\n        container_size = sim_os_disk_size_raw (uptr->fileref);\r\n        if ((container_size != (t_offset)-1) && (container_size > (t_offset)sizeof (*f)) &&\r\n            (sim_os_disk_read (uptr, container_size - sizeof (*f), (uint8 *)f, &bytesread, sizeof (*f)) == SCPE_OK) &&\r\n            (bytesread == sizeof (*f)))\r\n            break;\r\n        free (f);\r\n        f = NULL;\r\n        break;\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        if (1) {\r\n            time_t creation_time;\r\n\r\n            /* Construct a pseudo simh disk footer*/\r\n            memcpy (f->Signature, \"simh\", 4);\r\n            f->FooterVersion = FOOTER_VERSION;\r\n            memset (f->DriveType, 0, sizeof (f->DriveType));\r\n            strlcpy ((char *)f->DriveType, sim_vhd_disk_get_dtype (uptr->fileref, &f->SectorSize, &f->ElementEncodingSize, (char *)f->CreatingSimulator, &creation_time, &f->MediaID, (char *)f->DeviceName, &f->DataWidth), sizeof (f->DriveType));\r\n            if ((f->DriveType[0] == 0) && (uptr->drvtyp != NULL))\r\n                strlcpy ((char *)f->DriveType, uptr->drvtyp->name, sizeof (f->DriveType));\r\n            if (ctx->sector_size == 0)\r\n                ctx->sector_size = f->SectorSize;\r\n            if (ctx->media_id == 0)\r\n                ctx->media_id = f->MediaID;\r\n            if (ctx->xfer_encode_size == 0)\r\n                ctx->xfer_encode_size = f->ElementEncodingSize;\r\n            f->Geometry = NtoHl (sim_vhd_CHS (uptr->fileref));\r\n            f->DataWidth = NtoHl (f->DataWidth);\r\n            f->SectorSize = NtoHl (f->SectorSize);\r\n            f->MediaID = NtoHl (f->MediaID);\r\n            f->ElementEncodingSize = NtoHl (f->ElementEncodingSize);\r\n            if ((f->SectorSize == 0)                  ||      /* Old or mangled format VHD footer */\r\n                (NtoHl (f->SectorSize) == 0x00020000) ||\r\n                (NtoHl (f->MediaID) == 0)             ||\r\n                ((sim_disk_find_type (uptr, (char *)f->DriveType) != NULL) &&\r\n                 (NtoHl (f->Geometry) != sim_disk_drvtype_geometry (sim_disk_find_type (uptr, (char *)f->DriveType), NtoHl (f->SectorCount))))) {\r\n                sim_vhd_disk_set_dtype (uptr->fileref, uptr->drvtyp ? uptr->drvtyp->name : (char *)f->DriveType, ctx->sector_size, ctx->xfer_encode_size, ctx->media_id, uptr->dptr->name, uptr->dptr->dwidth, uptr->drvtyp);\r\n                sim_vhd_disk_get_dtype (uptr->fileref, &f->SectorSize, &f->ElementEncodingSize, (char *)f->CreatingSimulator, NULL, &f->MediaID, (char *)f->DeviceName, &f->DataWidth);\r\n                f->DataWidth = NtoHl (f->DataWidth);\r\n                f->SectorSize = NtoHl (f->SectorSize);\r\n                f->MediaID = NtoHl (f->MediaID);\r\n                f->ElementEncodingSize = NtoHl (f->ElementEncodingSize);\r\n                }\r\n            memset (f->CreationTime, 0, sizeof (f->CreationTime));\r\n            strlcpy ((char*)f->CreationTime, ctime (&creation_time), sizeof (f->CreationTime));\r\n            container_size = sim_vhd_disk_size (uptr->fileref);\r\n            if ((f->SectorSize != 0) && (NtoHl (f->SectorSize) <= 65536)) /* Range check for Coverity sake */\r\n                f->SectorCount = NtoHl ((uint32)(container_size / NtoHl (f->SectorSize)));\r\n            container_size += sizeof (*f);      /* Adjust since it is removed below */\r\n            f->AccessFormat = DKUF_F_VHD;\r\n            f->Checksum = NtoHl (eth_crc32 (0, f, sizeof (*f) - sizeof (f->Checksum)));\r\n            }\r\n        break;\r\n    default:\r\n        free (f);\r\n        return SCPE_IERR;\r\n    }\r\nif (f) {\r\n    if (f->Checksum != NtoHl (eth_crc32 (0, f, sizeof (*f) - sizeof (f->Checksum)))) {\r\n        sim_debug_unit (ctx->dbit, uptr, \"No footer found on %s format container: %s\\n\", sim_disk_fmt (uptr), uptr->filename);\r\n        free (f);\r\n        f = NULL;\r\n        }\r\n    else {\r\n        /* We've got a valid footer, but it may need to be corrected or have missing pieces added */\r\n        if (((f->MediaID == 0) && (((uptr->drvtyp != NULL) ? uptr->drvtyp->MediaId : 0) != 0)) ||\r\n            ((sim_disk_find_type (uptr, (char *)f->DriveType) != NULL) &&\r\n             (NtoHl (f->Geometry) != sim_disk_drvtype_geometry (sim_disk_find_type (uptr, (char *)f->DriveType), NtoHl (f->SectorCount)))) ||\r\n            ((NtoHl (f->ElementEncodingSize) == 1) &&   /* Encoding still 1 and SCSI disk/cdrom drive */\r\n             ((0 == memcmp (f->DriveType, \"RZ\", 2)) ||\r\n              (0 == memcmp (f->DriveType, \"RR\", 2))))) {\r\n            f->ElementEncodingSize = NtoHl (2);\r\n            if ((uptr->flags & UNIT_RO) == 0) {\r\n                DEVICE *dptr = uptr->dptr;\r\n                t_addr saved_capac = uptr->capac;\r\n                uint32 capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (quadword: 8, word: 2, byte: 1) */\r\n\r\n                uptr->capac = (t_addr)(((t_offset)NtoHl(f->SectorCount) * NtoHl(f->SectorSize)) / capac_factor);\r\n                store_disk_footer (uptr, (char *)f->DriveType);\r\n                uptr->capac = saved_capac;\r\n                *f = *ctx->footer;                  /* copy updated footer */\r\n                }\r\n            }\r\n        if ((uptr->flags & UNIT_RO) == 0) {\r\n            if ((NtoHl (f->SectorSize) != 512) &&\r\n                (f->FooterVersion == 0)) {\r\n                /* remove and rebuild early version original footer for non 512 byte sector containers */\r\n                char *filename = strdup (uptr->filename);\r\n                int32 saved_switches = sim_switches;\r\n                uint32 saved_flags;\r\n\r\n                uptr->flags |= UNIT_ATT;            /* mark as attached so detach works */\r\n                sim_disk_detach (uptr);\r\n                saved_flags = uptr->flags;\r\n                sim_switches |= SWMASK ('Q');       /* silently */\r\n                sim_switches |= SWMASK ('Z');       /* stripping trailing 0's */\r\n                sim_disk_info_cmd (1, filename);    /* remove existing metadata */\r\n                uptr->flags &= ~DKUF_NOAUTOSIZE;    /* enable autosize on unit */\r\n                uptr->dptr->attach (uptr, filename);/* attach in autosize mode */\r\n                uptr->flags &= ~UNIT_ATT;           /* mark as unattached for now */\r\n                uptr->flags |= (saved_flags & DKUF_NOAUTOSIZE); /* restore autosize setting */\r\n                sim_switches = saved_switches;\r\n                ctx = (struct disk_context *)uptr->disk_ctx;/* attach repopulates the context */\r\n                if (pctx != NULL)\r\n                    *pctx = ctx;\r\n                *f = *ctx->footer;                  /* copy updated footer */\r\n                free (filename);\r\n                }\r\n            }\r\n        free (ctx->footer);\r\n        ctx->footer = f;\r\n        if (NtoHl (f->MediaID) != 0)\r\n            ctx->media_id = NtoHl (f->MediaID);\r\n        ctx->highwater = (((t_offset)NtoHl (f->Highwater[0])) << 32) | ((t_offset)NtoHl (f->Highwater[1]));\r\n        container_size -= sizeof (*f);\r\n        sim_debug_unit (ctx->dbit, uptr, \"Footer: %s - %s\\n\"\r\n            \"   Simulator:           %s\\n\"\r\n            \"   DriveType:           %s\\n\"\r\n            \"   SectorSize:          %u\\n\"\r\n            \"   SectorCount:         %u\\n\"\r\n            \"   TransferElementSize: %s\\n\"\r\n            \"   FooterVersion:       %u\\n\"\r\n            \"   AccessFormat:        %u\\n\"\r\n            \"   CreationTime:        %s\",\r\n            sim_uname (uptr), uptr->filename,\r\n            f->CreatingSimulator, f->DriveType, NtoHl(f->SectorSize), NtoHl (f->SectorCount),\r\n            _disk_tranfer_encoding (NtoHl (f->ElementEncodingSize)), f->FooterVersion, f->AccessFormat, f->CreationTime);\r\n        if (f->DeviceName[0] != '\\0')\r\n            sim_debug_unit (ctx->dbit, uptr,\r\n                \"   DeviceName:          %s\\n\", (char *)f->DeviceName);\r\n        if (f->DataWidth != 0)\r\n            sim_debug_unit (ctx->dbit, uptr,\r\n                \"   DataWidth:           %d bits\\n\", NtoHl(f->DataWidth));\r\n        if (f->MediaID != 0)\r\n            sim_debug_unit (ctx->dbit, uptr,\r\n                \"   MediaID:             0x%08X (%s)\\n\", NtoHl(f->MediaID), sim_disk_decode_mediaid (NtoHl(f->MediaID)));\r\n        sim_debug_unit (ctx->dbit, uptr,\r\n            \"   HighwaterSector:     %u\\n\", (uint32)(ctx->highwater/ctx->sector_size));\r\n        }\r\n    }\r\nsim_debug_unit (ctx->dbit, uptr, \"Container Size: %u sectors %u bytes each\\n\", (uint32)(container_size/ctx->sector_size), ctx->sector_size);\r\nctx->container_size = container_size;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat store_disk_footer (UNIT *uptr, const char *dtype)\r\n{\r\nDEVICE *dptr;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nstruct stat statb;\r\nstruct simh_disk_footer *f;\r\nstruct simh_disk_footer *old_f = ctx->footer;\r\ntime_t now = time (NULL);\r\nt_offset total_sectors;\r\nt_offset highwater;\r\n\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nif (uptr->flags & UNIT_RO)\r\n    return SCPE_RO;\r\nif (sim_stat (uptr->filename, &statb))\r\n    memset (&statb, 0, sizeof (statb));\r\nf = (struct simh_disk_footer *)calloc (1, sizeof (*f));\r\nf->AccessFormat = DK_GET_FMT (uptr);\r\ntotal_sectors = (((t_offset)uptr->capac) * ctx->capac_factor * ((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)) / ctx->sector_size;\r\nmemcpy (f->Signature, \"simh\", 4);\r\nf->FooterVersion = FOOTER_VERSION;\r\nmemset (f->CreatingSimulator, 0, sizeof (f->CreatingSimulator));\r\nstrlcpy ((char *)f->CreatingSimulator, sim_name, sizeof (f->CreatingSimulator));\r\nmemset (f->DriveType, 0, sizeof (f->DriveType));\r\nstrlcpy ((char *)f->DriveType, dtype, sizeof (f->DriveType));\r\nf->SectorSize = NtoHl (ctx->sector_size);\r\nf->SectorCount = NtoHl ((uint32)total_sectors);\r\nf->ElementEncodingSize = NtoHl (ctx->xfer_encode_size);\r\nmemset (f->CreationTime, 0, sizeof (f->CreationTime));\r\nstrlcpy ((char*)f->CreationTime, ctime (&now), sizeof (f->CreationTime));\r\nmemset (f->DeviceName, 0, sizeof (f->DeviceName));\r\nstrlcpy ((char*)f->DeviceName, dptr->name, sizeof (f->DeviceName));\r\nf->MediaID = (uptr->drvtyp != NULL) ? NtoHl (uptr->drvtyp->MediaId) : 0;\r\nf->DataWidth = NtoHl (uptr->dptr->dwidth);\r\nf->Geometry = NtoHl (sim_disk_drvtype_geometry (sim_disk_find_type (uptr, (char *)f->DriveType), (uint32)total_sectors));\r\nhighwater = sim_fsize_name_ex (uptr->filename);\r\n/* Align Initial Highwater to a sector boundary */\r\nhighwater = ((highwater + ctx->sector_size - 1) / ctx->sector_size) * ctx->sector_size;\r\nf->Highwater[0] = NtoHl ((uint32)(highwater >> 32));\r\nf->Highwater[1] = NtoHl ((uint32)(highwater & 0xFFFFFFFF));\r\nf->Checksum = NtoHl (eth_crc32 (0, f, sizeof (*f) - sizeof (f->Checksum)));\r\nif ((old_f != NULL) &&\r\n    (f->DataWidth           == old_f->DataWidth) &&\r\n    (f->SectorSize          == old_f->SectorSize) &&\r\n    (f->MediaID             == old_f->MediaID) &&\r\n    (f->ElementEncodingSize == old_f->ElementEncodingSize) &&\r\n    (f->Geometry            == old_f->Geometry) &&\r\n    (f->FooterVersion       == old_f->FooterVersion)) /* Unchanged? */\r\n    free(f);\r\nelse {\r\n    free (ctx->footer);\r\n    ctx->footer = f;\r\n    switch (f->AccessFormat) {\r\n        case DKUF_F_STD:                                    /* SIMH format */\r\n            if (sim_fseeko ((FILE *)uptr->fileref, total_sectors * ctx->sector_size, SEEK_SET) == 0) {\r\n                sim_fwrite (f, sizeof (*f), 1, (FILE *)uptr->fileref);\r\n                fclose ((FILE *)uptr->fileref);\r\n                sim_set_file_times (uptr->filename, statb.st_atime, statb.st_mtime);\r\n                uptr->fileref = sim_fopen (uptr->filename, \"rb+\");\r\n                }\r\n            break;\r\n        case DKUF_F_VHD:                                    /* VHD format */\r\n            break;\r\n        case DKUF_F_RAW:                                    /* Raw Physical Disk Access */\r\n            sim_os_disk_write (uptr, total_sectors * ctx->sector_size, (uint8 *)f, NULL, sizeof (*f));\r\n            sim_os_disk_close_raw (uptr->fileref);\r\n            sim_set_file_times (uptr->filename, statb.st_atime, statb.st_mtime);\r\n            uptr->fileref = sim_os_disk_open_raw (uptr->filename, \"rb+\");\r\n            break;\r\n        default:\r\n            break;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat update_disk_footer (UNIT *uptr)\r\n{\r\nDEVICE *dptr;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nstruct stat statb;\r\nstruct simh_disk_footer *f;\r\nt_offset total_sectors;\r\nt_offset highwater;\r\nt_offset footer_highwater;\r\n\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nif (uptr->flags & UNIT_RO)\r\n    return SCPE_RO;\r\nif (ctx == NULL)\r\n    return SCPE_IERR;\r\nif ((uptr->drvtyp != NULL) &&\r\n    ((uptr->drvtyp->flags & DRVFL_DETAUTO) != 0) &&\r\n    ((uptr->flags & DKUF_NOAUTOSIZE) == 0))\r\n    store_disk_footer (uptr, uptr->drvtyp->name);\r\nf = ctx->footer;\r\nif (f == NULL)\r\n    return SCPE_IERR;\r\n\r\nfooter_highwater = (((t_offset)NtoHl (f->Highwater[0])) << 32) | ((t_offset)NtoHl (f->Highwater[1]));\r\nif (ctx->highwater <= footer_highwater)\r\n    return SCPE_OK;\r\n\r\nif (sim_stat (uptr->filename, &statb))\r\n    memset (&statb, 0, sizeof (statb));\r\ntotal_sectors = (((t_offset)uptr->capac) * ctx->capac_factor * ((dptr->flags & DEV_SECTORS) ? 512 : 1)) / ctx->sector_size;\r\nhighwater = ctx->highwater;\r\nf->Highwater[0] = NtoHl ((uint32)(highwater >> 32));\r\nf->Highwater[1] = NtoHl ((uint32)(highwater & 0xFFFFFFFF));\r\nf->Checksum = NtoHl (eth_crc32 (0, f, sizeof (*f) - sizeof (f->Checksum)));\r\nswitch (DK_GET_FMT (uptr)) {\r\n    case DKUF_F_STD:                                    /* SIMH format */\r\n        if (sim_fseeko ((FILE *)uptr->fileref, total_sectors * ctx->sector_size, SEEK_SET) == 0) {\r\n            sim_fwrite (f, sizeof (*f), 1, (FILE *)uptr->fileref);\r\n            fclose ((FILE *)uptr->fileref);\r\n            sim_set_file_times (uptr->filename, statb.st_atime, statb.st_mtime);\r\n            uptr->fileref = sim_fopen (uptr->filename, \"rb+\");\r\n            }\r\n        break;\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        break;\r\n    case DKUF_F_RAW:                                    /* Raw Physical Disk Access */\r\n        sim_os_disk_write (uptr, total_sectors * ctx->sector_size, (uint8 *)f, NULL, sizeof (*f));\r\n        sim_os_disk_close_raw (uptr->fileref);\r\n        sim_set_file_times (uptr->filename, statb.st_atime, statb.st_mtime);\r\n        uptr->fileref = sim_os_disk_open_raw (uptr->filename, \"rb+\");\r\n        break;\r\n    default:\r\n        break;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_attach (UNIT *uptr, const char *cptr, size_t sector_size, size_t xfer_encode_size, t_bool dontchangecapac,\r\n                        uint32 dbit, const char *dtype, uint32 pdp11tracksize, int completion_delay)\r\n{\r\nreturn sim_disk_attach_ex (uptr, cptr, sector_size, xfer_encode_size, dontchangecapac, dbit, dtype, pdp11tracksize, completion_delay, NULL);\r\n}\r\n\r\nt_stat sim_disk_attach_ex (UNIT *uptr, const char *cptr, size_t sector_size, size_t xfer_encode_size, t_bool dontchangecapac,\r\n                           uint32 dbit, const char *dtype, uint32 pdp11tracksize, int completion_delay, const char **drivetypes)\r\n{\r\nreturn sim_disk_attach_ex2 (uptr, cptr, sector_size, xfer_encode_size, dontchangecapac,\r\n                            dbit, dtype, pdp11tracksize, completion_delay, drivetypes, 0);\r\n}\r\n\r\nt_stat sim_disk_attach_ex2 (UNIT *uptr, const char *cptr, size_t sector_size, size_t xfer_encode_size, t_bool dontchangecapac,\r\n                            uint32 dbit, const char *dtype, uint32 pdp11tracksize, int completion_delay, const char **drivetypes,\r\n                            size_t reserved_sectors)\r\n{\r\nstruct disk_context *ctx;\r\nDEVICE *dptr;\r\nchar tbuf[4*CBUFSIZE];\r\nFILE *(*open_function)(const char *filename, const char *mode) = sim_fopen;\r\nFILE *(*create_function)(const char *filename, t_offset desiredsize, DRVTYP *drvtyp) = NULL;\r\nt_stat (*storage_function)(FILE *file, uint32 *sector_size, uint32 *removable, uint32 *is_cdrom) = NULL;\r\nt_bool created = FALSE, copied = FALSE, autosized = FALSE;\r\nt_bool auto_format = FALSE;\r\nUNIT *auptr;\r\nDRVTYP *size_settable_drive_type = NULL;\r\nt_offset container_size, filesystem_size, current_unit_size;\r\nsize_t tmp_size = 1;\r\nDRVTYP *drvtypes = NULL;\r\n\r\nif (uptr->flags & UNIT_DIS)                             /* disabled? */\r\n    return SCPE_UDIS;\r\nif (!(uptr->flags & UNIT_ATTABLE))                      /* not attachable? */\r\n    return SCPE_NOATT;\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nif ((uptr->flags & DKUF_NOAUTOSIZE) != 0) {             /* unit autosize disabled? */\r\n    dontchangecapac = TRUE;\r\n    drivetypes = NULL;\r\n    }\r\nelse {\r\n    if (drivetypes == NULL) {                           /* Drive type list unspecified? */\r\n        int i;\r\n\r\n        drvtypes = (DRVTYP *)dptr->type_ctx;            /* Use device specific types (if any) */\r\n        if (drvtypes != NULL) {\r\n            for (i = 0; drvtypes[i].name; i++) {\r\n                if (drvtypes[i].flags & DRVFL_SETSIZE) {\r\n                    size_settable_drive_type = &drvtypes[i];\r\n                    break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\nswitch (xfer_encode_size) {\r\n    default:\r\n        return sim_messagef (SCPE_ARG, \"Unsupported transfer element size: %u\\n\", (uint32)xfer_encode_size);\r\n    case 1: case 2: case 4: case 8:\r\n        break;\r\n    }\r\nif ((sector_size % xfer_encode_size) != 0)\r\n    return sim_messagef (SCPE_ARG, \"Invalid sector size: %u - must be a multiple of the transfer element size %u\\n\", (uint32)sector_size, (uint32)xfer_encode_size);\r\nif (sim_switches & SWMASK ('F')) {                      /* format spec? */\r\n    char gbuf[CBUFSIZE];\r\n    cptr = get_glyph (cptr, gbuf, 0);                   /* get spec */\r\n    if (*cptr == 0)                                     /* must be more */\r\n        return SCPE_2FARG;\r\n    if ((sim_disk_set_fmt (uptr, 0, gbuf, NULL) != SCPE_OK) ||\r\n        (DK_GET_FMT (uptr) == DKUF_F_AUTO))\r\n        return sim_messagef (SCPE_ARG, \"Invalid Override Disk Format: %s\\n\", gbuf);\r\n    sim_switches = sim_switches & ~(SWMASK ('F'));      /* Record Format specifier already processed */\r\n    auto_format = TRUE;\r\n    }\r\nif (sim_switches & SWMASK ('D')) {                      /* create difference disk? */\r\n    char gbuf[CBUFSIZE];\r\n    FILE *vhd;\r\n\r\n    sim_switches = sim_switches & ~(SWMASK ('D'));\r\n    cptr = get_glyph_nc (cptr, gbuf, 0);                /* get spec */\r\n    if (*cptr == 0)                                     /* must be more */\r\n        return SCPE_2FARG;\r\n    if (sim_disk_check_attached_container (cptr, &auptr))\r\n        return sim_messagef (SCPE_ALATT, \"'%s' is already attach to %s\\n\", cptr, sim_uname (auptr));\r\n    vhd = sim_vhd_disk_create_diff (gbuf, cptr);\r\n    if (vhd) {\r\n        sim_vhd_disk_close (vhd);\r\n        return sim_disk_attach (uptr, gbuf, sector_size, xfer_encode_size, dontchangecapac, dbit, dtype, pdp11tracksize, completion_delay);\r\n        }\r\n    return sim_messagef (SCPE_ARG, \"Unable to create differencing VHD: %s - %s\\n\", gbuf, strerror (errno));\r\n    }\r\nif (sim_switches & SWMASK ('C')) {                      /* create new disk container & copy contents? */\r\n    char gbuf[CBUFSIZE];\r\n    const char *dest_fmt = ((DK_GET_FMT (uptr) == DKUF_F_AUTO) || (DK_GET_FMT (uptr) == DKUF_F_VHD)) ? \"VHD\" : \"SIMH\";\r\n    FILE *dest;\r\n    int saved_sim_switches = sim_switches;\r\n    int32 saved_sim_quiet = sim_quiet;\r\n    DRVTYP *saved_drvtyp = uptr->drvtyp;\r\n    t_addr saved_capac = uptr->capac;\r\n    DRVTYP *source_drvtyp = NULL;\r\n    uint32 saved_noautosize = (uptr->flags & DKUF_NOAUTOSIZE);\r\n    t_addr target_capac = saved_capac;\r\n    t_addr source_capac;\r\n    uint32 capac_factor;\r\n    t_stat r;\r\n\r\n    sim_switches = sim_switches & ~(SWMASK ('C'));\r\n    cptr = get_glyph_nc (cptr, gbuf, 0);                /* get spec */\r\n    if (*cptr == 0)                                     /* must be more */\r\n        return sim_messagef (SCPE_2FARG, \"Missing Copy container source specification\\n\");\r\n    sim_switches |= SWMASK ('R') | SWMASK ('E');\r\n    sim_quiet = TRUE;\r\n    sim_disk_set_fmt (uptr, 0, \"AUTO\", NULL);   /* autodetect the source container format */\r\n    uptr->flags &= ~DKUF_NOAUTOSIZE;            /* autosize the source container */\r\n    /* First open the source of the copy operation */\r\n    r = sim_disk_attach_ex (uptr, cptr, sector_size, xfer_encode_size, dontchangecapac, dbit, dtype, pdp11tracksize, completion_delay, NULL);\r\n    sim_quiet = saved_sim_quiet;\r\n    uptr->flags |= saved_noautosize;\r\n    if (r != SCPE_OK) {\r\n        sim_switches = saved_sim_switches;\r\n        return sim_messagef (r, \"%s: Cannot open copy source: %s - %s\\n\", sim_uname (uptr), cptr, sim_error_text (r));\r\n        }\r\n    source_drvtyp = uptr->drvtyp;\r\n    source_capac = uptr->capac;\r\n    if (saved_noautosize) {\r\n        uptr->drvtyp = saved_drvtyp;\r\n        uptr->capac = saved_capac;\r\n        }\r\n    sim_messagef (SCPE_OK, \"%s: Creating new %s format '%s' %s disk container\\n\", sim_uname (uptr), dest_fmt, gbuf, uptr->drvtyp->name);\r\n    sim_messagef (SCPE_OK, \"%s: copying from '%s' %s%s%s\\n\", sim_uname (uptr), cptr, source_drvtyp ? \"a \" : \"\", source_drvtyp ? source_drvtyp->name : \"\", source_drvtyp ? \" disk container.\" : \"\");\r\n    capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (quadword: 8, word: 2, byte: 1) */\r\n    target_capac = uptr->capac;\r\n    if (strcmp (\"VHD\", dest_fmt) == 0)\r\n        dest = sim_vhd_disk_create (gbuf, ((t_offset)uptr->capac)*capac_factor*((dptr->flags & DEV_SECTORS) ? 512 : 1), uptr->drvtyp);\r\n    else\r\n        dest = sim_fopen (gbuf, \"wb+\");\r\n    if (!dest) {\r\n        sim_disk_detach (uptr);\r\n        return sim_messagef (r, \"%s: Cannot create %s disk container '%s'\\n\", sim_uname (uptr), dest_fmt, gbuf);\r\n        }\r\n    else {\r\n        uint8 *copy_buf = (uint8*) malloc (1024*1024);\r\n        t_lba lba;\r\n        t_seccnt sectors_per_buffer = (t_seccnt)((1024*1024)/sector_size);\r\n        t_lba total_sectors = (t_lba)((target_capac*capac_factor)/(sector_size/((dptr->flags & DEV_SECTORS) ? 512 : 1)));\r\n        t_seccnt sects = sectors_per_buffer;\r\n        t_seccnt sects_read;\r\n\r\n        if (!copy_buf) {\r\n            if (strcmp (\"VHD\", dest_fmt) == 0)\r\n                sim_vhd_disk_close (dest);\r\n            else\r\n                fclose (dest);\r\n            (void)remove (gbuf);\r\n            sim_disk_detach (uptr);\r\n            return SCPE_MEM;\r\n            }\r\n        errno = 0;\r\n        sim_messagef (SCPE_OK, \"%s: Copying %u sectors each %u bytes in size\\n\", sim_uname (uptr), (uint32)total_sectors, (uint32)sector_size);\r\n        if (source_capac > target_capac) {\r\n            sim_messagef (SCPE_OK, \"%s: The source %s%scontainer is %u sectors larger than\\n\",\r\n                sim_uname (uptr), source_drvtyp ? source_drvtyp->name : \"\", source_drvtyp ? \" \" : \"\", (t_lba)(((source_capac - target_capac)*capac_factor)/(sector_size/((dptr->flags & DEV_SECTORS) ? 512 : 1))));\r\n            sim_messagef (SCPE_OK, \"%s: the destination %s%sdisk container.\\n\",\r\n                sim_uname (uptr), uptr->drvtyp ? uptr->drvtyp->name : \"\", uptr->drvtyp ? \" \" : \"\");\r\n            sim_messagef (SCPE_OK, \"%s: These additional sectors will be unavailable in the target drive\\n\", sim_uname (uptr));\r\n            }\r\n        for (lba = 0; (lba < total_sectors) && (r == SCPE_OK); lba += sects_read) {\r\n            uptr->capac = source_capac;\r\n            sects = sectors_per_buffer;\r\n            if (lba + sects > total_sectors)\r\n                sects = total_sectors - lba;\r\n            r = sim_disk_rdsect (uptr, lba, copy_buf, &sects_read, sects);\r\n            if ((r == SCPE_OK) && (sects_read > 0)) {\r\n                uint32 saved_unit_flags = uptr->flags;\r\n                FILE *saved_unit_fileref = uptr->fileref;\r\n                t_seccnt sects_written;\r\n\r\n                sim_disk_set_fmt (uptr, 0, dest_fmt, NULL);\r\n                uptr->fileref = dest;\r\n                uptr->capac = target_capac;\r\n                r = sim_disk_wrsect (uptr, lba, copy_buf, &sects_written, sects_read);\r\n                uptr->fileref = saved_unit_fileref;\r\n                uptr->flags = saved_unit_flags;\r\n                if (sects_read != sects_written)\r\n                    r = SCPE_IOERR;\r\n                sim_messagef (SCPE_OK, \"%s: Copied %u/%u sectors.  %d%% complete.\\r\", sim_uname (uptr), (uint32)(lba + sects_read), (uint32)total_sectors, (int)((((float)lba)*100)/total_sectors));\r\n                }\r\n            }\r\n        if ((errno == ERANGE) &&    /* If everything was read before the end of the disk */\r\n            (sects_read == 0))\r\n            r = SCPE_OK;            /* That's OK */\r\n        if (r == SCPE_OK)\r\n            sim_messagef (SCPE_OK, \"\\n%s: Copied %u sectors. Done.\\n\", sim_uname (uptr), (uint32)total_sectors);\r\n        else\r\n            sim_messagef (r, \"\\n%s: Error copying: %s.\\n\", sim_uname (uptr), sim_error_text (r));\r\n        if ((r == SCPE_OK) && (sim_switches & SWMASK ('V'))) {\r\n            uint8 *verify_buf = (uint8*) malloc (1024*1024);\r\n            t_seccnt sects_read, verify_read;\r\n\r\n            if (!verify_buf) {\r\n                if (strcmp (\"VHD\", dest_fmt) == 0)\r\n                    sim_vhd_disk_close (dest);\r\n                else\r\n                    fclose (dest);\r\n                (void)remove (gbuf);\r\n                free (copy_buf);\r\n                sim_disk_detach (uptr);\r\n                return SCPE_MEM;\r\n                }\r\n            for (lba = 0; (lba < total_sectors) && (r == SCPE_OK); lba += sects_read) {\r\n                sim_messagef (SCPE_OK, \"%s: Verified %u/%u sectors.  %d%% complete.\\r\", sim_uname (uptr), (uint32)lba, (uint32)total_sectors, (int)((((float)lba)*100)/total_sectors));\r\n                uptr->capac = source_capac;\r\n                sects = sectors_per_buffer;\r\n                if (lba + sects > total_sectors)\r\n                    sects = total_sectors - lba;\r\n                r = sim_disk_rdsect (uptr, lba, copy_buf, &sects_read, sects);\r\n                if (r == SCPE_OK) {\r\n                    uint32 saved_unit_flags = uptr->flags;\r\n                    FILE *saved_unit_fileref = uptr->fileref;\r\n\r\n                    sim_disk_set_fmt (uptr, 0, dest_fmt, NULL);\r\n                    uptr->fileref = dest;\r\n                    uptr->capac = target_capac;\r\n                    r = sim_disk_rdsect (uptr, lba, verify_buf, &verify_read, sects_read);\r\n                    uptr->fileref = saved_unit_fileref;\r\n                    uptr->flags = saved_unit_flags;\r\n                    if (r == SCPE_OK) {\r\n                        if ((sects_read != verify_read) ||\r\n                            (0 != memcmp (copy_buf, verify_buf, verify_read*sector_size)))\r\n                            r = SCPE_IOERR;\r\n                        }\r\n                    }\r\n                if (r != SCPE_OK)\r\n                    break;\r\n                }\r\n            if (!sim_quiet) {\r\n                if (r == SCPE_OK)\r\n                    sim_messagef (r, \"\\n%s: Verified %u sectors. Done.\\n\", sim_uname (uptr), (uint32)total_sectors);\r\n                else {\r\n                    t_lba i;\r\n                    uint32 save_dctrl = dptr->dctrl;\r\n                    FILE *save_sim_deb = sim_deb;\r\n\r\n                    for (i = 0; i < sects_read; ++i)\r\n                        if (0 != memcmp (copy_buf+i*sector_size, verify_buf+i*sector_size, sector_size))\r\n                            break;\r\n                    sim_printf (\"\\n%s: Verification Error on lbn %d.\\n\", sim_uname (uptr), lba+i);\r\n                    dptr->dctrl = 0xFFFFFFFF;\r\n                    sim_deb = stdout;\r\n                    sim_disk_data_trace (uptr,   copy_buf+i*sector_size, lba+i, sector_size, \"Expected\", TRUE, 1);\r\n                    sim_disk_data_trace (uptr, verify_buf+i*sector_size, lba+i, sector_size,    \"Found\", TRUE, 1);\r\n                    dptr->dctrl = save_dctrl;\r\n                    sim_deb = save_sim_deb;\r\n                    }\r\n                }\r\n            free (verify_buf);\r\n            }\r\n        free (copy_buf);\r\n        if (strcmp (\"VHD\", dest_fmt) == 0) {\r\n            sim_vhd_disk_set_dtype (dest, (char *)uptr->drvtyp->name, sector_size, xfer_encode_size, uptr->drvtyp->MediaId, uptr->dptr->name, uptr->dptr->dwidth, uptr->drvtyp);\r\n            sim_vhd_disk_close (dest);\r\n            }\r\n        else\r\n            fclose (dest);\r\n        sim_disk_detach (uptr);\r\n        if (r == SCPE_OK) {\r\n            created = TRUE;\r\n            copied = TRUE;\r\n            strlcpy (tbuf, gbuf, sizeof(tbuf)-1);\r\n            cptr = tbuf;\r\n            sim_disk_set_fmt (uptr, 0, dest_fmt, NULL);\r\n            sim_switches = saved_sim_switches;\r\n            }\r\n        else\r\n            return r;\r\n        /* fall through and open/return the newly created & copied disk container */\r\n        }\r\n    }\r\nelse {\r\n    if (sim_switches & SWMASK ('M')) {                 /* merge difference disk? */\r\n        char gbuf[CBUFSIZE], *Parent = NULL;\r\n        FILE *vhd;\r\n\r\n        sim_switches = sim_switches & ~(SWMASK ('M'));\r\n        get_glyph_nc (cptr, gbuf, 0);                  /* get spec */\r\n        vhd = sim_vhd_disk_merge (gbuf, &Parent);\r\n        if (vhd) {\r\n            t_stat r;\r\n\r\n            sim_vhd_disk_close (vhd);\r\n            r = sim_disk_attach (uptr, Parent, sector_size, xfer_encode_size, dontchangecapac, dbit, dtype, pdp11tracksize, completion_delay);\r\n            free (Parent);\r\n            return r;\r\n            }\r\n        return SCPE_ARG;\r\n        }\r\n    }\r\nif ((uptr->drvtyp != NULL) && (uptr->drvtyp->flags & DRVFL_RO))\r\n    sim_switches |= SWMASK ('R');\r\nif (sim_disk_check_attached_container (cptr, &auptr))\r\n    return sim_messagef (SCPE_ALATT, \"'%s' is already attach to %s\\n\", cptr, sim_uname (auptr));\r\n\r\nswitch (DK_GET_FMT (uptr)) {                            /* case on format */\r\n    case DKUF_F_AUTO:                                   /* SIMH format */\r\n        auto_format = TRUE;\r\n        if (NULL != (uptr->fileref = sim_vhd_disk_open (cptr, \"rb\"))) { /* Try VHD */\r\n            sim_disk_set_fmt (uptr, 0, \"VHD\", NULL);    /* set file format to VHD */\r\n            sim_vhd_disk_close (uptr->fileref);         /* close vhd file*/\r\n            uptr->fileref = NULL;\r\n            open_function = sim_vhd_disk_open;\r\n            break;\r\n            }\r\n        while (tmp_size < sector_size)\r\n            tmp_size <<= 1;\r\n        if (tmp_size ==  sector_size) {                     /* Power of 2 sector size can do RAW */\r\n            if (NULL != (uptr->fileref = sim_os_disk_open_raw (cptr, \"rb\"))) {\r\n                sim_disk_set_fmt (uptr, 0, \"RAW\", NULL);    /* set file format to RAW */\r\n                sim_os_disk_close_raw (uptr->fileref);      /* close raw file*/\r\n                open_function = sim_os_disk_open_raw;\r\n                storage_function = sim_os_disk_info_raw;\r\n                uptr->fileref = NULL;\r\n                break;\r\n                }\r\n            }\r\n        sim_disk_set_fmt (uptr, 0, \"SIMH\", NULL);       /* set file format to SIMH */\r\n        open_function = sim_fopen;\r\n        break;\r\n    case DKUF_F_STD:                                    /* SIMH format */\r\n        if (NULL != (uptr->fileref = sim_vhd_disk_open (cptr, \"rb\"))) { /* Try VHD first */\r\n            sim_disk_set_fmt (uptr, 0, \"VHD\", NULL);    /* set file format to VHD */\r\n            sim_vhd_disk_close (uptr->fileref);         /* close vhd file*/\r\n            uptr->fileref = NULL;\r\n            open_function = sim_vhd_disk_open;\r\n            auto_format = TRUE;\r\n            break;\r\n            }\r\n        open_function = sim_fopen;\r\n        break;\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        open_function = sim_vhd_disk_open;\r\n        create_function = sim_vhd_disk_create;\r\n        storage_function = sim_os_disk_info_raw;\r\n        break;\r\n    case DKUF_F_RAW:                                    /* Raw Physical Disk Access */\r\n        if (NULL != (uptr->fileref = sim_vhd_disk_open (cptr, \"rb\"))) { /* Try VHD first */\r\n            sim_disk_set_fmt (uptr, 0, \"VHD\", NULL);    /* set file format to VHD */\r\n            sim_vhd_disk_close (uptr->fileref);         /* close vhd file*/\r\n            uptr->fileref = NULL;\r\n            open_function = sim_vhd_disk_open;\r\n            auto_format = TRUE;\r\n            break;\r\n            }\r\n        open_function = sim_os_disk_open_raw;\r\n        storage_function = sim_os_disk_info_raw;\r\n        break;\r\n    default:\r\n        return SCPE_IERR;\r\n    }\r\nuptr->filename = (char *) calloc (CBUFSIZE, sizeof (char));/* alloc name buf */\r\nuptr->disk_ctx = ctx = (struct disk_context *)calloc(1, sizeof(struct disk_context));\r\nif ((uptr->filename == NULL) || (uptr->disk_ctx == NULL))\r\n    return _err_return (uptr, SCPE_MEM);\r\nstrlcpy (uptr->filename, cptr, CBUFSIZE);               /* save name */\r\nctx->sector_size = (uint32)sector_size;                 /* save sector_size */\r\nctx->capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* save capacity units (quadword: 8, word: 2, byte: 1) */\r\nctx->xfer_encode_size = (uint32)xfer_encode_size;       /* save xfer_encode_size */\r\nctx->media_id = (uptr->drvtyp != NULL) ?\r\n                    uptr->drvtyp->MediaId : 0;          /* save initial device type media id */\r\nctx->dptr = dptr;                                       /* save DEVICE pointer */\r\nctx->dbit = dbit;                                       /* save debug bit */\r\nctx->media_removed = 0;                                 /* default present */\r\nctx->initial_drvtyp = uptr->drvtyp;                     /* save original drive type */\r\nctx->initial_capac = uptr->capac;                       /* save original capacity */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_attach(unit=%d,filename='%s')\\n\", (int)(uptr - ctx->dptr->units), uptr->filename);\r\nctx->auto_format = auto_format;                         /* save that we auto selected format */\r\nctx->storage_sector_size = (uint32)sector_size;         /* Default */\r\nif ((sim_switches & SWMASK ('R')) ||                    /* read only? */\r\n    ((uptr->flags & UNIT_RO) != 0)) {\r\n    if (((uptr->flags & UNIT_ROABLE) == 0) &&           /* allowed? */\r\n        ((uptr->flags & UNIT_RO) == 0))\r\n        return sim_messagef (_err_return (uptr, SCPE_NORO), \"%s: Read Only operation not allowed\\n\", /* no, error */\r\n                                                        sim_uname (uptr));\r\n    uptr->fileref = open_function (cptr, \"rb\");         /* open rd only */\r\n    if (uptr->fileref == NULL)                          /* open fail? */\r\n        return sim_messagef (_err_return (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                            sim_uname (uptr), cptr, strerror (errno));\r\n    uptr->flags = uptr->flags | UNIT_RO;                /* set rd only */\r\n    sim_messagef (SCPE_OK, \"%s: Unit is read only\\n\", sim_uname (uptr));\r\n    }\r\nelse {                                                  /* normal */\r\n    uptr->fileref = open_function (cptr, \"rb+\");        /* open r/w */\r\n    if (uptr->fileref == NULL) {                        /* open fail? */\r\n        if ((errno == EROFS) || (errno == EACCES)) {    /* read only? */\r\n            if ((uptr->flags & UNIT_ROABLE) == 0)       /* allowed? */\r\n                return sim_messagef (_err_return (uptr, SCPE_NORO), \"%s: Read Only operation not allowed\\n\", /* no, error */\r\n                                                                sim_uname (uptr));\r\n            uptr->fileref = open_function (cptr, \"rb\"); /* open rd only */\r\n            if (uptr->fileref == NULL)                  /* open fail? */\r\n                return sim_messagef (_err_return (uptr, SCPE_OPENERR), \"%s: Can't open '%s': %s\\n\", /* yes, error */\r\n                                                    sim_uname (uptr), cptr, strerror (errno));\r\n            uptr->flags = uptr->flags | UNIT_RO;        /* set rd only */\r\n            sim_messagef (SCPE_OK, \"%s: Unit is read only\\n\", sim_uname (uptr));\r\n            }\r\n        else {                                          /* other error? */\r\n            if ((sim_switches & SWMASK ('E')) ||        /* must exist? */\r\n                (errno != ENOENT))                      /* or must not re-create? */\r\n                return sim_messagef (_err_return (uptr, SCPE_OPENERR), \"%s: Cannot open '%s' - %s\\n\",\r\n                                     sim_uname (uptr), cptr, strerror (errno));\r\n            if (create_function)\r\n                uptr->fileref = create_function (cptr, ((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? 512 : 1), uptr->drvtyp);/* create new file */\r\n            else\r\n                uptr->fileref = open_function (cptr, \"wb+\");/* open new file */\r\n            if (uptr->fileref == NULL)                  /* open fail? */\r\n                return sim_messagef (_err_return (uptr, SCPE_OPENERR), \"%s: Cannot create '%s' - %s\\n\",\r\n                                     sim_uname (uptr), cptr, strerror (errno));\r\n            sim_messagef (SCPE_OK, \"%s: Creating new file: %s\\n\", sim_uname (uptr), cptr);\r\n            created = TRUE;\r\n            }\r\n        }                                               /* end if null */\r\n    }                                                   /* end else */\r\n(void)get_disk_footer (uptr, &ctx);\r\nif ((DK_GET_FMT (uptr) == DKUF_F_VHD) || (ctx->footer)) {\r\n    uint32 container_sector_size = 0, container_xfer_encode_size = 0, container_sectors = 0;\r\n    char created_name[64];\r\n    const char *container_dtype = ctx->footer ? (char *)ctx->footer->DriveType : sim_vhd_disk_get_dtype (uptr->fileref, &container_sector_size, &container_xfer_encode_size, created_name, NULL, NULL, NULL, NULL);\r\n\r\n    if (ctx->footer) {\r\n        container_sector_size = NtoHl (ctx->footer->SectorSize);\r\n        container_sectors = NtoHl (ctx->footer->SectorCount);\r\n        xfer_encode_size = NtoHl (ctx->footer->ElementEncodingSize);\r\n        strlcpy (created_name, (char *)ctx->footer->CreatingSimulator, sizeof (created_name));\r\n        }\r\n    if (dtype) {\r\n        char cmd[64];\r\n        t_stat r = SCPE_OK;\r\n\r\n        if ((strcmp (container_dtype, dtype) == 0) ||\r\n            (((container_sector_size == 0) || (container_sector_size == ctx->sector_size) ||\r\n              ((ctx->data_ileave == 0) && (ctx->sector_size % container_sector_size) == 0)) &&\r\n             ((container_xfer_encode_size == 0) || (container_xfer_encode_size == ctx->xfer_encode_size)))) {\r\n            if (strcmp (container_dtype, dtype) != 0) {\r\n                t_bool can_autosize = ((drivetypes != NULL) || (drvtypes != NULL) || (!dontchangecapac));\r\n\r\n                if (can_autosize) {\r\n                    int32 saved_show_message = sim_show_message;\r\n                    int32 saved_switches = sim_switches;\r\n                    uint32 saved_RO_flags = (uptr->flags & UNIT_RO);\r\n\r\n                    snprintf (cmd, sizeof (cmd), \"%s %s\", sim_uname (uptr), container_dtype);\r\n                    set_cmd (0, \"NOMESSAGE\");\r\n                    r = set_cmd (0, cmd);\r\n                    uptr->flags |= saved_RO_flags;    /* While autosizing, retain the unit Read Only state */\r\n                    sim_show_message = saved_show_message;\r\n                    if (r != SCPE_OK) {\r\n                        if (size_settable_drive_type != NULL) {\r\n                            sim_switches |= SWMASK ('L');   /* LBN size */\r\n                            snprintf (cmd, sizeof (cmd), \"%s %s=%u\", sim_uname (uptr), size_settable_drive_type->name, (uint32)(ctx->container_size / ctx->sector_size));\r\n                            r = set_cmd (0, cmd);\r\n                            uptr->flags |= saved_RO_flags;  /* restore unit Read Only state after size adjustment */\r\n                            }\r\n                        else\r\n                            r = sim_messagef (SCPE_INCOMPDSK, \"%s: Cannot set to drive type %s\\n\", sim_uname (uptr), container_dtype);\r\n                        }\r\n                    sim_switches = saved_switches;\r\n                    }\r\n                current_unit_size = ((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1);\r\n                if (ctx->container_size > current_unit_size) {\r\n                    t_lba current_unit_sectors = (t_lba)((dptr->flags & DEV_SECTORS) ? uptr->capac : (uptr->capac*ctx->capac_factor)/ctx->sector_size);\r\n\r\n                    if ((uptr->flags & UNIT_RO) != 0)                   /* Not Opening read only? */\r\n                        r = sim_messagef (SCPE_OK, \"%s: Read Only access to inconsistent drive type allowed\\n\", sim_uname (uptr));\r\n                    else {\r\n                        r = sim_messagef (SCPE_INCOMPDSK, \"%s: Too large container having %u sectors, drive has: %u sectors\\n\", sim_uname (uptr), container_sectors, current_unit_sectors);\r\n                        if ((uptr->flags & UNIT_ROABLE) == 0) {\r\n                            r = sim_messagef (SCPE_INCOMPDSK, \"%s: Drive type doesn't support Read Only attach\\n\", sim_uname (uptr));\r\n                            }\r\n                        else {\r\n                            r = sim_messagef (SCPE_INCOMPDSK, \"%s: '%s' can only be attached Read Only\\n\", sim_uname (uptr), cptr);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            else { /* Type already matches, Need to confirm compatibility */\r\n                t_lba current_unit_sectors = (t_lba)((dptr->flags & DEV_SECTORS) ? uptr->capac : (uptr->capac*ctx->capac_factor)/ctx->sector_size);\r\n\r\n                if ((container_sector_size != 0) && (sector_size != container_sector_size))\r\n                    r = sim_messagef (SCPE_OPENERR, \"%s: Incompatible Container Sector Size %d\\n\", sim_uname (uptr), container_sector_size);\r\n                else {\r\n                    if (dontchangecapac &&\r\n                        ((((t_lba)(ctx->container_size/sector_size) > current_unit_sectors)) ||\r\n                         ((container_sectors != 0) && (container_sectors != current_unit_sectors)))) {\r\n                         r = sim_messagef (SCPE_OK, \"%s: Container has %u sectors, drive has: %u sectors\\n\", sim_uname (uptr), container_sectors, current_unit_sectors);\r\n                         if (container_sectors != 0)\r\n                             r = sim_messagef (SCPE_INCOMPDSK, \"%s: %s container created by the %s simulator is incompatible with the %s device on the %s simulator\\n\", sim_uname (uptr), container_dtype, created_name, uptr->dptr->name, sim_name);\r\n                         else\r\n                             r = sim_messagef (SCPE_INCOMPDSK, \"%s: disk container %s is incompatible with the %s device\\n\", sim_uname (uptr), uptr->filename, uptr->dptr->name);\r\n                         if ((uptr->flags & UNIT_RO) != 0)\r\n                             r = sim_messagef (SCPE_OK, \"%s: Read Only access to incompatible %s container '%s' allowed\\n\", sim_uname (uptr), container_dtype, uptr->filename);\r\n                         if (container_sectors < current_unit_sectors) {\r\n                             r = sim_messagef (SCPE_BARE_STATUS (r), \"%s: Since the container is smaller than the drive, this might be useful:\\n\", sim_uname (uptr));\r\n                             r = sim_messagef (SCPE_BARE_STATUS (r), \"%s:   sim> ATTACH %s -C New-%s %s\\n\", sim_uname (uptr), sim_uname (uptr), uptr->filename, uptr->filename);\r\n                             }\r\n                        }\r\n                    }\r\n                if ((r == SCPE_OK) && ((uptr->drvtyp == NULL) || (strcmp (container_dtype, uptr->drvtyp->name) != 0))) {\r\n                    int32 saved_show_message = sim_show_message;\r\n\r\n                    snprintf (cmd, sizeof (cmd), \"%s %s\", sim_uname (uptr), container_dtype);\r\n                    set_cmd (0, \"NOMESSAGE\");\r\n                    set_cmd (0, cmd);\r\n                    sim_show_message = saved_show_message;\r\n                    }\r\n                }\r\n            if (r == SCPE_OK)\r\n                autosized = TRUE;\r\n            }\r\n        else\r\n            r = sim_messagef (SCPE_INCOMPDSK, \"%s: %s container created by the %s simulator is incompatible with the %s device on the %s simulator\\n\", sim_uname (uptr), container_dtype, created_name, uptr->dptr->name, sim_name);\r\n        if (r != SCPE_OK) {\r\n            uptr->flags |= UNIT_ATT;\r\n            sim_disk_detach (uptr);                         /* report error now */\r\n            sprintf (cmd, \"%s%d %s\", dptr->name, (int)(uptr-dptr->units), dtype);/* restore original dtype */\r\n            set_cmd (0, cmd);\r\n            return r;\r\n            }\r\n        }\r\n    }\r\nuptr->flags |= UNIT_ATT;\r\nuptr->pos = 0;\r\n\r\n/* Get Device attributes if they are available */\r\nif (storage_function)\r\n    storage_function (uptr->fileref, &ctx->storage_sector_size, &ctx->removable, &ctx->is_cdrom);\r\n\r\nif ((created) && (!copied)) {\r\n    t_stat r = SCPE_OK;\r\n    uint8 *secbuf = (uint8 *)calloc (128, ctx->sector_size);     /* alloc temp sector buf */\r\n\r\n    /*\r\n       On a newly created disk, we write zeros to the whole disk.\r\n       This serves 3 purposes:\r\n         1) it avoids strange allocation delays writing newly allocated\r\n            storage at the end of the disk during simulator operation\r\n         2) it allocates storage for the whole disk at creation time to\r\n            avoid strange failures which may happen during simulator execution\r\n            if the containing disk is full\r\n         3) it leaves a Simh Format disk at the intended size so it may\r\n            subsequently be autosized with the correct size.\r\n    */\r\n    if (secbuf == NULL)\r\n        r = SCPE_MEM;\r\n    if (r == SCPE_OK) { /* Write all blocks */\r\n        t_lba lba;\r\n        t_lba total_lbas = (t_lba)((((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? 512 : 1))/ctx->sector_size);\r\n\r\n        for (lba = 0; (r == SCPE_OK) && (lba < total_lbas); lba += 128) {\r\n            t_seccnt sectors = ((lba + 128) <= total_lbas) ? 128 : total_lbas - lba;\r\n\r\n            r = sim_disk_wrsect (uptr, lba, secbuf, NULL, sectors);\r\n            }\r\n        }\r\n    free (secbuf);\r\n    if (r != SCPE_OK) {\r\n        sim_disk_detach (uptr);                         /* report error now */\r\n        (void)remove (cptr);                            /* remove the created file */\r\n        return SCPE_OPENERR;\r\n        }\r\n    if (pdp11tracksize)\r\n        sim_disk_pdp11_bad_block (uptr, pdp11tracksize, sector_size/sizeof(uint16));\r\n    }\r\nif (sim_switches & SWMASK ('I')) {                  /* Initialize To Sector Address */\r\n    t_stat r = SCPE_OK;\r\n    size_t init_buf_size = 1024*1024;\r\n    uint8 *init_buf = (uint8*) calloc (init_buf_size, 1);\r\n    t_lba lba, sect;\r\n    uint32 capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (quadword: 8, word: 2, byte: 1) */\r\n    t_seccnt sectors_per_buffer = (t_seccnt)((init_buf_size)/sector_size);\r\n    t_lba total_sectors = (t_lba)((uptr->capac*capac_factor)/(sector_size/((dptr->flags & DEV_SECTORS) ? 512 : 1)));\r\n    t_seccnt sects = sectors_per_buffer;\r\n\r\n    if (!init_buf) {\r\n        sim_disk_detach (uptr);                     /* report error now */\r\n        (void)remove (cptr);\r\n        return SCPE_MEM;\r\n        }\r\n    if (sector_size < ctx->storage_sector_size)\r\n        sectors_per_buffer = 1;                     /* exercise more of write logic with small I/Os */\r\n    sim_messagef (SCPE_OK, \"Initializing %u sectors each %u bytes with the sector address\\n\", (uint32)total_sectors, (uint32)sector_size);\r\n    for (lba = 0; (lba < total_sectors) && (r == SCPE_OK); lba += sects) {\r\n        t_seccnt sects_written;\r\n\r\n        sects = sectors_per_buffer;\r\n        if (lba + sects > total_sectors)\r\n            sects = total_sectors - lba;\r\n        for (sect = 0; sect < sects; sect++) {\r\n            t_lba offset;\r\n\r\n            if (xfer_encode_size <= sizeof (uint32)) {\r\n                for (offset = 0; offset < sector_size; offset += sizeof(uint32))\r\n                    *((uint32 *)&init_buf[sect*sector_size + offset]) = (uint32)(lba + sect);\r\n                }\r\n            else {\r\n                for (offset = 0; offset < sector_size; offset += xfer_encode_size)\r\n                    *((t_uint64 *)&init_buf[sect*sector_size + offset]) = (t_uint64)(lba + sect);\r\n                }\r\n            }\r\n        r = sim_disk_wrsect (uptr, lba, init_buf, &sects_written, sects);\r\n        if ((r != SCPE_OK) || (sects != sects_written)) {\r\n            free (init_buf);\r\n            sim_disk_detach (uptr);                         /* report error now */\r\n            (void)remove (cptr);                            /* remove the created file */\r\n            return sim_messagef (SCPE_OPENERR, \"Error initializing each sector with its address: %s\\n\",\r\n                                               (r == SCPE_OK) ? sim_error_text (r) : \"sectors written not what was requested\");\r\n            }\r\n        sim_messagef (SCPE_OK, \"%s: Set To Sector Address %u/%u sectors.  %d%% complete.\\r\", sim_uname (uptr), (uint32)(lba + sects_written), (uint32)total_sectors, (int)((((float)lba)*100)/total_sectors));\r\n        }\r\n    sim_messagef (SCPE_OK, \"%s: Initialized To Sector Address %u sectors.  100%% complete.       \\n\", sim_uname (uptr), (uint32)total_sectors);\r\n    free (init_buf);\r\n    }\r\nif (sim_switches & SWMASK ('K')) {\r\n    t_stat r = SCPE_OK;\r\n    t_lba lba, sect;\r\n    uint32 capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (word: 2, byte: 1) */\r\n    t_seccnt sectors_per_buffer = (t_seccnt)((1024*1024)/sector_size);\r\n    t_lba total_sectors = (t_lba)((uptr->capac*capac_factor)/(sector_size/((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)));\r\n    t_seccnt sects = sectors_per_buffer;\r\n    t_seccnt sects_verify;\r\n    uint8 *verify_buf = (uint8*) malloc (1024*1024);\r\n\r\n    if (!verify_buf) {\r\n        sim_disk_detach (uptr);                     /* report error now */\r\n        return SCPE_MEM;\r\n        }\r\n    if (sector_size < ctx->storage_sector_size)\r\n        sectors_per_buffer = 1;                     /* exercise more of read logic with small I/Os */\r\n    for (lba = 0; (lba < total_sectors) && (r == SCPE_OK); lba += sects_verify) {\r\n        sects = sectors_per_buffer;\r\n        if (lba + sects > total_sectors)\r\n            sects = total_sectors - lba;\r\n        r = sim_disk_rdsect (uptr, lba, verify_buf, &sects_verify, sects);\r\n        if (r == SCPE_OK) {\r\n            if (sects != sects_verify)\r\n                sim_printf (\"\\n%s: Verification Error when reading lbn %d(0x%X) of %d(0x%X) Requested %u sectors, read %u sectors.\\n\",\r\n                            sim_uname (uptr), (int)lba, (int)lba, (int)total_sectors, (int)total_sectors, sects, sects_verify);\r\n            for (sect = 0; sect < sects_verify; sect++) {\r\n                t_lba offset;\r\n                t_bool sect_error = FALSE;\r\n\r\n                if (xfer_encode_size <= sizeof (uint32)) {\r\n                    for (offset = 0; offset < sector_size; offset += sizeof(uint32)) {\r\n                        if (*((uint32 *)&verify_buf[sect*sector_size + offset]) != (uint32)(lba + sect)) {\r\n                            sect_error = TRUE;\r\n                            break;\r\n                            }\r\n                        }\r\n                    }\r\n                else {\r\n                    for (offset = 0; offset < sector_size; offset += xfer_encode_size) {\r\n                        if (*((t_uint64 *)&verify_buf[sect*sector_size + offset]) != (t_uint64)(lba + sect)) {\r\n                            sect_error = TRUE;\r\n                            break;\r\n                            }\r\n                        }\r\n                    }\r\n                if (sect_error) {\r\n                    uint32 save_dctrl = dptr->dctrl;\r\n                    FILE *save_sim_deb = sim_deb;\r\n\r\n                    sim_printf (\"\\n%s: Verification Error on lbn %d(0x%X) of %d(0x%X).\\n\", sim_uname (uptr), (int)(lba+sect), (int)(lba+sect), (int)total_sectors, (int)total_sectors);\r\n                    dptr->dctrl = 0xFFFFFFFF;\r\n                    sim_deb = stdout;\r\n                    sim_disk_data_trace (uptr, verify_buf+sect*sector_size, lba+sect, sector_size,    \"Found\", TRUE, 1);\r\n                    dptr->dctrl = save_dctrl;\r\n                    sim_deb = save_sim_deb;\r\n                    }\r\n                }\r\n            }\r\n        sim_messagef (SCPE_OK, \"%s: Verified Sector Address %u/%u sectors.  %d%% complete.\\r\", sim_uname (uptr), (uint32)lba, (uint32)total_sectors, (int)((((float)lba)*100)/total_sectors));\r\n        }\r\n    sim_messagef (SCPE_OK, \"%s: Verified Sector Address %u sectors.  100%% complete.         \\n\", sim_uname (uptr), (uint32)lba);\r\n    free (verify_buf);\r\n    uptr->dynflags |= UNIT_DISK_CHK;\r\n    }\r\n\r\nif (get_disk_footer (uptr, &ctx) != SCPE_OK) {\r\n    sim_disk_detach (uptr);\r\n    return SCPE_OPENERR;\r\n    }\r\nfilesystem_size = get_filesystem_size (uptr, NULL);\r\nif (filesystem_size != (t_offset)-1)\r\n    filesystem_size += reserved_sectors * sector_size;\r\ncontainer_size = sim_disk_size (uptr);\r\nif ((filesystem_size == (t_offset)-1) &&\r\n    (ctx->footer != NULL))                      /* The presence of metadata means we already */\r\n    filesystem_size = ctx->container_size;      /* know the interesting disk size */\r\ncurrent_unit_size = ((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1);\r\nif (container_size && (container_size != (t_offset)-1) &&\r\n    (container_size != current_unit_size) &&\r\n    (filesystem_size != current_unit_size)) { /* need to autosize */\r\n    t_addr saved_capac = uptr->capac;\r\n    const char *saved_drvtyp = (uptr->drvtyp != NULL) ? uptr->drvtyp->name : dtype;\r\n    char cmd[CBUFSIZE];\r\n\r\n    if (!created && (ctx->footer == NULL) && (filesystem_size == (t_offset)-1)) {\r\n        if (container_size != current_unit_size) {  /* container doesn't precisely matches unit size */\r\n            sim_messagef (SCPE_OK, \"%s: Amount of data in use in disk container '%s' cannot be determined, skipping autosizing\\n\", sim_uname (uptr), cptr);\r\n            if (container_size > current_unit_size) {\r\n                t_stat r = SCPE_FSSIZE;\r\n                char *capac1;\r\n\r\n                uptr->capac = (t_addr)(container_size/(ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)));\r\n                capac1 = strdup (sprint_capac (dptr, uptr));\r\n                uptr->capac = saved_capac;\r\n                r = sim_messagef (r, \"%s: The disk container '%s' is larger than simulated device (%s > %s)\\n\",\r\n                                    sim_uname (uptr), cptr, capac1, sprint_capac (dptr, uptr));\r\n                free (capac1);\r\n                sim_disk_detach (uptr);\r\n                return r;\r\n                }\r\n            }\r\n        /* Fall through and skip autosizing for a container we can't determine anything about but happens to be the same size as the unit */\r\n        }\r\n    else {      /* Active autosizing */\r\n        /* Prefer capacity change over drive type change for the same drive type container */\r\n        if ((!dontchangecapac) &&\r\n            (((uptr->flags & UNIT_RO) != 0) ||\r\n             ((ctx->footer != NULL) &&\r\n              ((uptr->drvtyp == NULL) ||\r\n               (strcasecmp (uptr->drvtyp->name, (char *)ctx->footer->DriveType) == 0))))) { /* autosize by changing capacity */\r\n            if (filesystem_size != (t_offset)-1) {              /* Known file system data size AND */\r\n                if (filesystem_size >= container_size) {        /*    Data size >= container size? */\r\n                    container_size = filesystem_size +          /*       Use file system data size */\r\n                                 (pdp11tracksize * sector_size);/*       plus any bad block data beyond the file system */\r\n                    autosized = TRUE;\r\n                    }\r\n                }\r\n            else {                                              /* Unrecognized file system */\r\n                if (container_size < current_unit_size)         /*     Use MAX of container or current device size */\r\n                    if ((DKUF_F_VHD != DK_GET_FMT (uptr)) &&    /*     when size can be expanded */\r\n                        (0 == (uptr->flags & UNIT_RO))) {\r\n                        container_size = current_unit_size;     /*     Use MAX of container or current device size */\r\n                        autosized = TRUE;\r\n                        }\r\n                }\r\n            uptr->capac = (t_addr)(container_size/(ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? 512 : 1)));  /* update current size */\r\n            current_unit_size = ((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1);\r\n            }\r\n        else {                              /* autosize by potentially changing drive type */\r\n            if ((drivetypes != NULL) || (drvtypes != NULL)) {   /* Available drive type list? */\r\n                const char **saved_drivetypes = drivetypes;\r\n                DRVTYP *saved_drvtypes = drvtypes;\r\n                const char *drive;\r\n\r\n                /* Walk through all potential drive types (if any) until we find one at least the right size */\r\n                for (drive = (drivetypes != NULL) ? *drivetypes : drvtypes->name;\r\n                     drive != NULL;\r\n                     drive = (drivetypes != NULL) ? *++drivetypes : (++drvtypes)->name) {\r\n                    t_stat st;\r\n                    int32 saved_switches = sim_switches;\r\n                    uint32 saved_RO = (uptr->flags & UNIT_RO);\r\n\r\n                    if ((drvtypes != NULL) &&\r\n                        (DRVFL_GET_IFTYPE(drvtypes) == DRVFL_TYPE_SCSI) && (drvtypes->devtype == SCSI_TAPE))\r\n                        continue;\r\n                    uptr->flags &= ~UNIT_ATT;       /* temporarily mark as un-attached */\r\n                    if ((size_settable_drive_type != NULL) &&\r\n                        (strcasecmp (size_settable_drive_type->name, drive) == 0))\r\n                        snprintf (cmd, sizeof (cmd), \"%s %s=%u\", sim_uname (uptr), drive, (uint32)(filesystem_size / size_settable_drive_type->sectsize));\r\n                    else\r\n                        snprintf (cmd, sizeof (cmd), \"%s %s\", sim_uname (uptr), drive);\r\n                    sim_switches |= SWMASK ('L');\r\n                    st = set_cmd (0, cmd);\r\n                    sim_switches = saved_switches;  /* restore switches */\r\n                    uptr->flags |= UNIT_ATT;        /* restore attached indicator */\r\n                    uptr->flags &= ~UNIT_RO;        /* restore RO indicator */\r\n                    uptr->flags |= saved_RO;\r\n                    if (st == SCPE_OK)\r\n                        current_unit_size = ((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1);\r\n                    if (filesystem_size != (t_offset)-1) {  /* File System found? */\r\n                        if (current_unit_size >= filesystem_size)\r\n                            break;\r\n                        }\r\n                    else {                                  /* No file system case */\r\n                        if (current_unit_size == container_size) {\r\n                            autosized = TRUE;\r\n                            break;\r\n                            }\r\n                        }\r\n                    }\r\n                drivetypes = saved_drivetypes;\r\n                drvtypes = saved_drvtypes;\r\n                }\r\n            if (filesystem_size <= current_unit_size)\r\n                autosized = TRUE;\r\n            }\r\n        /* After potentially changing the drive type, are we OK now? */\r\n        if (dontchangecapac &&\r\n            (filesystem_size != (t_offset)-1) &&\r\n            (filesystem_size > current_unit_size)) {\r\n            t_stat r = ((uptr->flags & UNIT_RO) == 0) ? SCPE_FSSIZE : SCPE_OK;\r\n            char *capac1;\r\n\r\n            uptr->capac = (t_addr)(filesystem_size/(ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)));\r\n            capac1 = strdup (sprint_capac (dptr, uptr));\r\n            uptr->capac = saved_capac;\r\n            r = sim_messagef (r, \"%s: The file system in the disk container %s is larger than simulated device (%s > %s)\\n\",\r\n                                sim_uname (uptr), cptr, capac1, sprint_capac (dptr, uptr));\r\n            free (capac1);\r\n            if ((uptr->flags & UNIT_RO) == 0)\r\n                sim_disk_detach (uptr);\r\n            sprintf (cmd, \"%s %s\", sim_uname (uptr), saved_drvtyp);\r\n            set_cmd (0, cmd);\r\n            return r;\r\n            }\r\n        }\r\n    if ((container_size != current_unit_size)) {\r\n        if (container_size <= current_unit_size) {\r\n            if (DKUF_F_VHD == DK_GET_FMT (uptr)){\r\n                t_stat r = SCPE_INCOMPDSK;\r\n                const char *container_dtype = ctx->footer ? (const char *)ctx->footer->DriveType : \"\";\r\n                char *capac1;\r\n\r\n                uptr->capac = (t_addr)(container_size/(ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)));\r\n                capac1 = strdup (sprint_capac (dptr, uptr));\r\n                uptr->capac = saved_capac;\r\n                r = sim_messagef (r, \"%s: non expandable %s%sdisk container '%s' is smaller than simulated device (%s < %s)\\n\",\r\n                                    sim_uname (uptr), container_dtype, (*container_dtype != '\\0') ? \" \" : \"\", cptr, capac1, sprint_capac (dptr, uptr));\r\n                free (capac1);\r\n                sim_disk_detach (uptr);\r\n                return r;\r\n                }\r\n            }\r\n        else { /* (container_size > current_unit_size) */\r\n            if (0 == (uptr->flags & UNIT_RO)) {\r\n                t_stat r = SCPE_OK;\r\n                int32 saved_switches = sim_switches;\r\n                const char *container_dtype;\r\n                char *capac1;\r\n\r\n                uptr->capac = (t_addr)(container_size/(ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1)));\r\n                capac1 = strdup (sprint_capac (dptr, uptr));\r\n                uptr->capac = saved_capac;\r\n                sim_disk_detach (uptr);\r\n                sim_switches = SWMASK ('R');\r\n                r = sim_disk_attach_ex (uptr, cptr, sector_size, xfer_encode_size, dontchangecapac, dbit, dtype, pdp11tracksize, completion_delay, NULL);\r\n                container_dtype = ctx->footer ? (const char *)ctx->footer->DriveType : \"\";\r\n                sim_switches = saved_switches;\r\n                if (r == SCPE_OK)\r\n                    r = sim_messagef (SCPE_OK, \"%s: %s%sdisk container '%s' is larger than simulated device (%s > %s) Read Only Forced\\n\",\r\n                            sim_uname (uptr), container_dtype, (*container_dtype != '\\0') ? \" \" : \"\", cptr,\r\n                            capac1, sprint_capac (dptr, uptr));\r\n                free (capac1);\r\n                return r;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nif ((uptr->flags & UNIT_RO) == 0) {     /* Opened Read/Write? */\r\n    t_bool isreadonly;\r\n    int32 saved_quiet = sim_quiet;\r\n\r\n    sim_quiet = 1;\r\n    get_filesystem_size (uptr, &isreadonly);\r\n    if (isreadonly) {                     /* ReadOny File System? */\r\n        sim_disk_detach (uptr);\r\n        sim_switches |= SWMASK ('R');\r\n        sim_disk_attach_ex2 (uptr, cptr, sector_size, xfer_encode_size, dontchangecapac,\r\n                            dbit, dtype, pdp11tracksize, completion_delay, drivetypes,\r\n                            reserved_sectors);\r\n        }\r\n    sim_quiet = saved_quiet;\r\n    }\r\nif (dtype && ((uptr->drvtyp == NULL) ? TRUE : ((uptr->drvtyp->flags & DRVFL_DETAUTO) == 0)) && ((uptr->flags & DKUF_NOAUTOSIZE) == 0) &&\r\n    (created                                                                                  ||\r\n     ((ctx->footer == NULL) && (autosized || (current_unit_size == container_size)))          ||\r\n     (!created && (ctx->container_size == 0) && (ctx->footer == NULL))))\r\n    store_disk_footer (uptr, (uptr->drvtyp == NULL) ? dtype : uptr->drvtyp->name);\r\n\r\n#if defined (SIM_ASYNCH_IO)\r\nsim_disk_set_async (uptr, completion_delay);\r\n#endif\r\nuptr->io_flush = _sim_disk_io_flush;\r\n\r\nif (uptr->flags & UNIT_BUFABLE) {                       /* buffer in memory? */\r\n    t_seccnt sectsread;\r\n    t_stat r = SCPE_OK;\r\n\r\n    if (uptr->flags & UNIT_MUSTBUF) {                   /* dyn alloc? */\r\n        uptr->filebuf = calloc ((size_t)current_unit_size,\r\n                                    ctx->xfer_encode_size);       /* allocate */\r\n        uptr->filebuf2 = calloc ((size_t)current_unit_size,\r\n                                    ctx->xfer_encode_size);       /* allocate copy */\r\n        if ((uptr->filebuf == NULL) ||                  /* either failed? */\r\n            (uptr->filebuf2 == NULL)) {\r\n            sim_disk_detach (uptr);\r\n            return SCPE_MEM;                            /* memory allocation error */\r\n            }\r\n        }\r\n    sim_messagef (SCPE_OK, \"%s: buffering file in memory\\n\", sim_uname (uptr));\r\n    r = sim_disk_rdsect (uptr, 0, (uint8 *)uptr->filebuf, &sectsread, (t_seccnt)(ctx->container_size / ctx->sector_size));\r\n    if (r != SCPE_OK)\r\n        return sim_disk_detach (uptr);\r\n    uptr->hwmark = (sectsread * ctx->sector_size) / ctx->xfer_encode_size;\r\n    memcpy (uptr->filebuf2, uptr->filebuf, (size_t)ctx->container_size);/* save initial contents */\r\n    uptr->flags |= UNIT_BUF;                            /* mark as buffered */\r\n    if ((uptr->hwmark * ctx->xfer_encode_size) < current_unit_size)/* Make sure the container on disk has all the data (zero fill as needed) */\r\n        sim_disk_wrsect (uptr, 0, (uint8 *)uptr->filebuf, NULL, (t_seccnt)(current_unit_size / ctx->sector_size));\r\n    }\r\nif (DK_GET_FMT (uptr) != DKUF_F_STD)\r\n    uptr->dynflags |= UNIT_NO_FIO;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_detach (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx;\r\nint (*close_function)(FILE *f);\r\nFILE *fileref;\r\nt_bool auto_format;\r\nchar *autozap_filename = NULL;\r\n\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nsim_cancel (uptr);\r\nif (!(uptr->flags & UNIT_ATT))\r\n    return SCPE_UNATT;\r\n\r\nctx = (struct disk_context *)uptr->disk_ctx;\r\nfileref = uptr->fileref;            /* save local copy used after unit cleanup */\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_detach(unit=%d,filename='%s')\\n\", (int)(uptr - ctx->dptr->units), uptr->filename);\r\n\r\n/* Save close function to call after unit cleanup */\r\nswitch (DK_GET_FMT (uptr)) {                            /* case on format */\r\n    case DKUF_F_STD:                                    /* Simh */\r\n        close_function = fclose;\r\n        break;\r\n    case DKUF_F_VHD:                                    /* Virtual Disk */\r\n        close_function = sim_vhd_disk_close;\r\n        break;\r\n    case DKUF_F_RAW:                                    /* Physical */\r\n        close_function = sim_os_disk_close_raw;\r\n        break;\r\n    default:\r\n        return SCPE_IERR;\r\n        }\r\nif (!(uptr->flags & UNIT_ATTABLE))                      /* attachable? */\r\n    return SCPE_NOATT;\r\nif (!(uptr->flags & UNIT_ATT))                          /* attached? */\r\n    return SCPE_OK;\r\nif (NULL == find_dev_from_unit (uptr))\r\n    return SCPE_OK;\r\n\r\nif ((uptr->flags & UNIT_BUF) && (uptr->filebuf)) {\r\n    uint32 cap = (uptr->hwmark + uptr->dptr->aincr - 1) / uptr->dptr->aincr;\r\n    t_offset current_unit_size = ((t_offset)uptr->capac)*ctx->capac_factor*((uptr->dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1);\r\n\r\n    if (((uptr->flags & UNIT_RO) == 0) &&\r\n        (memcmp (uptr->filebuf, uptr->filebuf2, (size_t)current_unit_size) != 0)) {\r\n        sim_messagef (SCPE_OK, \"%s: writing buffer to file: %s\\n\", sim_uname (uptr), uptr->filename);\r\n        sim_disk_wrsect (uptr, 0, (uint8 *)uptr->filebuf, NULL, (cap + ctx->sector_size - 1) / ctx->sector_size);\r\n        }\r\n    uptr->flags = uptr->flags & ~UNIT_BUF;\r\n    }\r\nfree (uptr->filebuf);                                   /* free buffers */\r\nuptr->filebuf = NULL;\r\nfree (uptr->filebuf2);\r\nuptr->filebuf2 = NULL;\r\n\r\nupdate_disk_footer (uptr);                              /* Update meta data if highwater has changed */\r\nfileref = uptr->fileref;                                /* update local copy used after unit cleanup */\r\n\r\nauto_format = ctx->auto_format;                         /* save for update after unit cleanup */\r\n\r\nif (uptr->io_flush)\r\n    uptr->io_flush (uptr);                              /* flush buffered data */\r\n\r\nsim_disk_clr_async (uptr);\r\n\r\nuptr->flags &= ~(UNIT_ATT | UNIT_RO);\r\nuptr->dynflags &= ~(UNIT_NO_FIO | UNIT_DISK_CHK);\r\nif ((uptr->flags & DKUF_AUTOZAP) != 0)\r\n    autozap_filename = strdup (uptr->filename);\r\nfree (uptr->filename);\r\nuptr->filename = NULL;\r\nuptr->fileref = NULL;\r\nfree (ctx->footer);\r\nctx->footer = NULL;\r\nuptr->drvtyp = ctx->initial_drvtyp;                     /* restore drive type */\r\nuptr->capac = ctx->initial_capac;                       /* restore drive size */\r\nfree (uptr->disk_ctx);\r\nuptr->disk_ctx = NULL;\r\nuptr->io_flush = NULL;\r\n\r\nif (auto_format)\r\n    sim_disk_set_fmt (uptr, 0, \"AUTO\", NULL);           /* restore file format */\r\n\r\nif (close_function (fileref) == EOF) {\r\n    free (autozap_filename);\r\n    return SCPE_IOERR;\r\n    }\r\nif (autozap_filename) {\r\n    t_bool saved_sim_show_message = sim_show_message;\r\n\r\n    sim_show_message = FALSE;\r\n    sim_disk_info_cmd (1, autozap_filename);\r\n    free (autozap_filename);\r\n    sim_show_message = saved_sim_show_message;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\nstatic struct example_fields {\r\n    const char *dname;\r\n    const char *dtype;\r\n    const char *dsize;\r\n    const char *dtype2;\r\n    const char *dsize2;\r\n    const char *dtype3;\r\n    const char *dsize3;\r\n    const char *dtype4;\r\n    const char *dsize4;\r\n    } ex_data[] = {\r\n        {\"RQ\", \"RD54\", \"159MB\", \"RX50\", \"409KB\", \"RA81\", \"456MB\", \"RA92\", \"1505MB\"},\r\n        {\"RP\", \"RM03\",  \"33MW\", \"RM03\",  \"33MW\", \"RP07\", \"258MW\", \"RM03\",  \"15MW\"},\r\n        {\"RP\", \"RM03\",  \"39MW\", \"RM03\",  \"39MW\", \"RP07\", \"110MW\", \"RM03\",  \"15MW\"},\r\n    };\r\nstruct example_fields *ex = &ex_data[0];\r\n\r\nif (strcmp (dptr->name, \"RP\") == 0)\r\n    ex = &ex_data[1];\r\nif (strstr (sim_name, \"-10\")) {\r\n    ex = &ex_data[2];\r\n    if (strstr (sim_name, \"PDP\") == NULL)\r\n        ex->dname = \"RPA\";\r\n    }\r\n\r\nfprintf (st, \"%s Disk Attach Help\\n\\n\", dptr->name);\r\n\r\nfprintf (st, \"Disk container files can be one of several different types:\\n\\n\");\r\n//if (strstr (sim_name, \"-10\") == NULL) {\r\n    fprintf (st, \"    SIMH   A disk is an unstructured binary file of the size appropriate\\n\");\r\n    fprintf (st, \"           for the disk drive being simulated accessed by C runtime APIs\\n\");\r\n    fprintf (st, \"    VHD    Virtual Disk format which is described in the \\\"Microsoft\\n\");\r\n    fprintf (st, \"           Virtual Hard Disk (VHD) Image Format Specification\\\".  The\\n\");\r\n    fprintf (st, \"           VHD implementation includes support for 1) Fixed (Preallocated)\\n\");\r\n    fprintf (st, \"           disks, 2) Dynamically Expanding disks, and 3) Differencing disks.\\n\");\r\n    fprintf (st, \"    RAW    platform specific access to physical disk or CDROM drives\\n\\n\");\r\n//    }\r\n//else {\r\n//    fprintf (st, \"   SIMH     A disk is an unstructured binary file of 64bit integers\\n\"\r\n//                 \"            access by C runtime APIs\\n\");\r\n//    fprintf (st, \"   VHD      A disk is an unstructured binary file of 64bit integers\\n\"\r\n//                 \"            contained in a VHD container\\n\");\r\n//    fprintf (st, \"   RAW      A disk is an unstructured binary file of 64bit integers\\n\"\r\n//                 \"            accessed by direct read/write APIs\\n\");\r\n//    fprintf (st, \"   DLD9     Packed little endian words (Compatible with KLH10)\\n\");\r\n//    fprintf (st, \"   DBD9     Packed big endian words (Compatible with KLH10)\\n\");\r\n//    fprintf (st, \"   VHD-DLD9 Packed little endian words stored in a VHD container\\n\");\r\n//    fprintf (st, \"   VHD-DBD9 Packed big endian words stored in a VHD container\\n\\n\");\r\n//    }\r\nfprintf (st, \"Virtual (VHD) Disk  support conforms to the \\\"Virtual Hard Disk Image Format\\n\");\r\nfprintf (st, \"Specification\\\", Version 1.0 October 11, 2006.\\n\");\r\nfprintf (st, \"Dynamically expanding disks never change their \\\"Virtual Size\\\", but they don't\\n\");\r\nfprintf (st, \"consume disk space on the containing storage until the virtual sectors in the\\n\");\r\nfprintf (st, \"disk are actually written to (i.e. a 2GB Dynamic disk container file with only\\n\");\r\nfprintf (st, \"30MB of data will initially be about 30MB in size and this size will grow up to\\n\");\r\nfprintf (st, \"2GB as different sectors are written to.  The VHD format contains metadata\\n\");\r\nfprintf (st, \"which describes the drive size and the simh device type in use when the VHD\\n\");\r\nfprintf (st, \"was created.  This metadata is therefore available whenever that VHD is\\n\");\r\nfprintf (st, \"attached to an emulated disk device in the future so the device type and\\n\");\r\nfprintf (st, \"size can be automatically be configured.\\n\\n\");\r\n\r\nif (dptr->numunits > 1) {\r\n    uint32 i, attachable_count = 0, out_count = 0, skip_count;\r\n\r\n    for (i=0; i < dptr->numunits; ++i)\r\n        if ((dptr->units[i].flags & UNIT_ATTABLE) &&\r\n            !(dptr->units[i].flags & UNIT_DIS))\r\n            ++attachable_count;\r\n    for (i=0; (i < dptr->numunits) && (out_count < 2); ++i)\r\n        if ((dptr->units[i].flags & UNIT_ATTABLE) &&\r\n            !(dptr->units[i].flags & UNIT_DIS)) {\r\n            fprintf (st, \"  sim> ATTACH {switches} %s diskfile\\n\", sim_uname (&dptr->units[i]));\r\n            ++out_count;\r\n            }\r\n    if (attachable_count > 4) {\r\n        fprintf (st, \"       .\\n\");\r\n        fprintf (st, \"       .\\n\");\r\n        fprintf (st, \"       .\\n\");\r\n        }\r\n    skip_count = attachable_count - 2;\r\n    for (i=0; i < dptr->numunits; ++i)\r\n        if ((dptr->units[i].flags & UNIT_ATTABLE) &&\r\n            !(dptr->units[i].flags & UNIT_DIS)) {\r\n            if (skip_count == 0)\r\n                fprintf (st, \"  sim> ATTACH {switches} %s diskfile\\n\", sim_uname (&dptr->units[i]));\r\n            else\r\n                --skip_count;\r\n            }\r\n    }\r\nelse\r\n    fprintf (st, \"  sim> ATTACH {switches} %s diskfile\\n\", dptr->name);\r\nfprintf (st, \"\\n%s attach command switches\\n\", dptr->name);\r\nfprintf (st, \"    -R          Attach Read Only.\\n\");\r\nfprintf (st, \"    -E          Must Exist (if not specified an attempt to create the indicated\\n\");\r\nfprintf (st, \"                disk container will be attempted).\\n\");\r\nfprintf (st, \"    -F          Open the indicated disk container in a specific format (default\\n\");\r\nfprintf (st, \"                is to autodetect VHD defaulting to RAW if the indicated\\n\");\r\nfprintf (st, \"                container is not a VHD).\\n\");\r\nfprintf (st, \"    -I          Initialize newly created disk so that each sector contains its\\n\");\r\nfprintf (st, \"                sector address\\n\");\r\nfprintf (st, \"    -K          Verify that the disk contents contain the sector address in each\\n\");\r\nfprintf (st, \"                sector.  Whole disk checked at attach time and each sector is\\n\");\r\nfprintf (st, \"                checked when written.\\n\");\r\nfprintf (st, \"    -C          Create a disk container and copy its contents from another disk\\n\");\r\nfprintf (st, \"                (simh, VHD, or RAW format).  The current (or specified with -F)\\n\");\r\nfprintf (st, \"                container format will be the format of the created container.\\n\");\r\nfprintf (st, \"                AUTO or VHD will create a VHD container, SIMH will create a.\\n\");\r\nfprintf (st, \"                SIMH container. Add a -V switch to verify a copy operation.\\n\");\r\nfprintf (st, \"                Note: A copy will be performed between dissimilar sized\\n\");\r\nfprintf (st, \"                containers.  Copying from a larger container to a smaller\\n\");\r\nfprintf (st, \"                one will produce a truncated result.\\n\");\r\nfprintf (st, \"    -V          Perform a verification pass to confirm successful data copy\\n\");\r\nfprintf (st, \"                operation.\\n\");\r\nfprintf (st, \"    -X          When creating a VHD, create a fixed sized VHD (vs a Dynamically\\n\");\r\nfprintf (st, \"                expanding one).\\n\");\r\nfprintf (st, \"    -D          Create a Differencing VHD (relative to an already existing VHD\\n\");\r\nfprintf (st, \"                disk)\\n\");\r\nfprintf (st, \"    -M          Merge a Differencing VHD into its parent VHD disk\\n\");\r\nfprintf (st, \"    -O          Override consistency checks when attaching differencing disks\\n\");\r\nfprintf (st, \"                which have unexpected parent disk GUID or timestamps\\n\");\r\nfprintf (st, \"    -U          Fix inconsistencies which are overridden by the -O switch\\n\");\r\nif (strstr (sim_name, \"-10\") == NULL) {\r\n    fprintf (st, \"    -Y          Answer Yes to prompt to overwrite last track (on disk create)\\n\");\r\n    fprintf (st, \"    -N          Answer No to prompt to overwrite last track (on disk create)\\n\");\r\n    }\r\nfprintf (st, \"\\n\\n\");\r\nfprintf (st, \"Examples:\\n\");\r\nfprintf (st, \"  sim> show %s\\n\", ex->dname);\r\nfprintf (st, \"    %s, address=20001468-2000146B*, no vector, 4 units\\n\", ex->dname);\r\nfprintf (st, \"    %s0, %s, not attached, write enabled, %s, autosize, AUTO detect format\\n\", ex->dname, ex->dsize, ex->dtype);\r\nfprintf (st, \"    %s1, %s, not attached, write enabled, %s, autosize, AUTO detect format\\n\", ex->dname, ex->dsize, ex->dtype);\r\nfprintf (st, \"    %s2, %s, not attached, write enabled, %s, autosize, AUTO detect format\\n\", ex->dname, ex->dsize, ex->dtype);\r\nfprintf (st, \"    %s3, %s, not attached, write enabled, %s, autosize, AUTO detect format\\n\", ex->dname, ex->dsize2, ex->dtype2);\r\nfprintf (st, \"  sim> # attach an existing VHD and determine its size and type automatically\\n\");\r\nfprintf (st, \"  sim> attach %s0 %s.vhd\\n\", ex->dname, ex->dtype3);\r\nfprintf (st, \"  sim> show %s0\\n\", ex->dname);\r\nfprintf (st, \"  %s0, %s, attached to %s.vhd, write enabled, %s, autosize, VHD format\\n\", ex->dname, ex->dsize3, ex->dtype3, ex->dtype3);\r\nfprintf (st, \"  sim> # create a new %s drive type VHD\\n\", ex->dtype4);\r\nfprintf (st, \"  sim> set %s2 %s\\n\", ex->dname, ex->dtype4);\r\nfprintf (st, \"  sim> attach %s2 -f vhd %s.vhd\\n\", ex->dname, ex->dtype4);\r\nfprintf (st, \"  %s2: creating new file\\n\", ex->dname);\r\nfprintf (st, \"  sim> show %s2\\n\", ex->dname);\r\nfprintf (st, \"  %s2, %s, attached to %s.vhd, write enabled, %s, autosize, VHD format\\n\", ex->dname, ex->dsize4, ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  sim> # examine the size consumed by the %s VHD file\\n\", ex->dsize4);\r\nfprintf (st, \"  sim> dir %s.vhd\\n\", ex->dtype4);\r\nfprintf (st, \"   Directory of H:\\\\Data\\n\\n\");\r\nfprintf (st, \"  04/14/2011  12:57 PM             5,120 %s.vhd\\n\", ex->dtype4);\r\nfprintf (st, \"                 1 File(s)          5,120 bytes\\n\");\r\nfprintf (st, \"  sim> # create a differencing vhd (%s-1-Diff.vhd) with %s.vhd as parent\\n\", ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  sim> attach %s3 -d %s-1-Diff.vhd %s.vhd\\n\", ex->dname, ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  sim> # create a VHD (%s-1.vhd) which is a copy of an existing disk\\n\", ex->dtype4);\r\nfprintf (st, \"  sim> attach %s3 -c %s-1.vhd %s.vhd\\n\", ex->dname, ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  %s3: Creating new VHD format '%s-1.vhd' %s disk container.\\n\", ex->dname, ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  %s3: copying from '%s.vhd' a %s container\\n\", ex->dname, ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  %s3: Copied %s.  99%% complete.\\n\", ex->dname, ex->dsize4);\r\nfprintf (st, \"  %s3: Copied %s. Done.\\n\", ex->dname, ex->dsize4);\r\nfprintf (st, \"  sim> show %s3\\n\", ex->dname);\r\nfprintf (st, \"  %s3, %s, attached to %s-1.vhd, write enabled, %s, autosize, VHD format\\n\", ex->dname, ex->dsize4, ex->dtype4, ex->dtype4);\r\nfprintf (st, \"  sim> dir %s*\\n\", ex->dtype4);\r\nfprintf (st, \"   Directory of H:\\\\Data\\n\\n\");\r\nfprintf (st, \"  04/14/2011  01:12 PM             5,120 %s-1.vhd\\n\", ex->dtype4);\r\nfprintf (st, \"  04/14/2011  12:58 PM             5,120 %s.vhd\\n\", ex->dtype4);\r\nfprintf (st, \"                 2 File(s)         10,240 bytes\\n\");\r\nfprintf (st, \"  sim> show %s2\\n\", ex->dname);\r\nfprintf (st, \"  %s2, %s, not attached, write enabled, %s, autosize, VHD format\\n\", ex->dname, ex->dsize4, ex->dtype4);\r\nfprintf (st, \"  sim> set %s2 %s\\n\", ex->dname, ex->dtype3);\r\nfprintf (st, \"  sim> set %s2 noauto\\n\", ex->dname);\r\nfprintf (st, \"  sim> show %s2\\n\", ex->dname);\r\nfprintf (st, \"  %s2, %s, not attached, write enabled, %s, noautosize, VHD format\\n\", ex->dname, ex->dsize3, ex->dtype3);\r\nfprintf (st, \"  sim> set %s2 format=simh\\n\", ex->dname);\r\nfprintf (st, \"  sim> show %s2\\n\", ex->dname);\r\nfprintf (st, \"  %s2, %s, not attached, write enabled, %s, noautosize, SIMH format\\n\", ex->dname, ex->dsize3, ex->dtype3);\r\nfprintf (st, \"  sim> # create a VHD from an existing SIMH format disk\\n\");\r\nfprintf (st, \"  sim> attach %s2 -c %s-Copy.vhd XYZZY.dsk\\n\", ex->dname, ex->dtype3);\r\nfprintf (st, \"  %s3: copying from '%s.vhd' a %s container.\\n\", ex->dname, ex->dtype3, ex->dtype3);\r\nfprintf (st, \"  %s2: creating new virtual disk '%s-Copy.vhd'\\n\", ex->dname, ex->dtype3);\r\nfprintf (st, \"  %s2: Copied %s.  99%% complete.\\n\", ex->dname, ex->dsize3);\r\nfprintf (st, \"  %s2: Copied %s. Done.\\n\", ex->dname, ex->dsize3);\r\nfprintf (st, \"  sim> show %s2\\n\", ex->dname);\r\nfprintf (st, \"  %s2, %s, attached to %s-Copy.vhd, write enabled, %s, noautosize, VHD format\\n\", ex->dname, ex->dsize3, ex->dtype3, ex->dtype3);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_bool sim_disk_vhd_support (void)\r\n{\r\nreturn SCPE_OK == sim_vhd_disk_implemented ();\r\n}\r\n\r\nt_bool sim_disk_raw_support (void)\r\n{\r\nreturn SCPE_OK == sim_os_disk_implemented_raw ();\r\n}\r\n\r\nt_stat sim_disk_reset (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nif (!(uptr->flags & UNIT_ATT))                          /* attached? */\r\n    return SCPE_OK;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_disk_reset(unit=%d)\\n\", (int)(uptr - ctx->dptr->units));\r\n\r\n_sim_disk_io_flush(uptr);\r\nAIO_VALIDATE(uptr);\r\nAIO_UPDATE_QUEUE;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_perror (UNIT *uptr, const char *msg)\r\n{\r\nint saved_errno = errno;\r\n\r\nif (!(uptr->flags & UNIT_ATTABLE))                      /* not attachable? */\r\n    return SCPE_NOATT;\r\n#if defined(_WIN32)\r\nsaved_errno = GetLastError ();\r\n#endif\r\nperror (msg);\r\nsim_printf (\"%s %s: %s\\n\", sim_uname(uptr), msg, sim_get_os_error_text (saved_errno));\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_clearerr (UNIT *uptr)\r\n{\r\nif (!(uptr->flags & UNIT_ATTABLE))                      /* not attachable? */\r\n    return SCPE_NOATT;\r\nswitch (DK_GET_FMT (uptr)) {                            /* case on format */\r\n    case DKUF_F_STD:                                    /* SIMH format */\r\n        clearerr (uptr->fileref);\r\n        break;\r\n    case DKUF_F_VHD:                                    /* VHD format */\r\n        sim_vhd_disk_clearerr (uptr);\r\n        break;\r\n    default:\r\n        ;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Factory bad block table creation routine\r\n\r\n   This routine writes a DEC standard 144 compliant bad block table on the\r\n   last track of the specified unit as described in:\r\n      EL-00144_B_DEC_STD_144_Disk_Standard_for_Recording_and_Handling_Bad_Sectors_Nov76.pdf\r\n   The bad block table consists of 10 repetitions of the same table,\r\n   formatted as follows:\r\n\r\n        words 0-1       pack id number\r\n        words 2-3       cylinder/sector/surface specifications\r\n         :\r\n        words n-n+1     end of table (-1,-1)\r\n\r\n   Inputs:\r\n        uptr    =       pointer to unit\r\n        sec     =       number of sectors per surface\r\n        wds     =       number of words per sector\r\n   Outputs:\r\n        sta     =       status code\r\n*/\r\n\r\nt_stat sim_disk_pdp11_bad_block (UNIT *uptr, int32 sec, int32 wds)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nint32 i;\r\nt_addr da;\r\nuint16 *buf;\r\nDEVICE *dptr;\r\nchar *namebuf, *c;\r\nuint32 packid;\r\nt_stat stat = SCPE_OK;\r\n\r\nif ((sec < 2) || (wds < 16))\r\n    return SCPE_ARG;\r\nif ((uptr->flags & UNIT_ATT) == 0)\r\n    return SCPE_UNATT;\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nif (uptr->flags & UNIT_RO)\r\n    return SCPE_RO;\r\nif (!get_yn (\"Overwrite last track? [N]\", FALSE))\r\n    return SCPE_OK;\r\nif ((buf = (uint16 *) malloc (wds * sizeof (uint16))) == NULL)\r\n    return SCPE_MEM;\r\nnamebuf = uptr->filename;\r\nif ((c = strrchr (namebuf, '/')))\r\n    namebuf = c+1;\r\nif ((c = strrchr (namebuf, '\\\\')))\r\n    namebuf = c+1;\r\nif ((c = strrchr (namebuf, ']')))\r\n    namebuf = c+1;\r\npackid = eth_crc32(0, namebuf, strlen (namebuf));\r\nbuf[0] = (uint16)packid;\r\nbuf[1] = (uint16)(packid >> 16) & 0x7FFF;   /* Make sure MSB is clear */\r\nbuf[2] = buf[3] = 0;\r\nfor (i = 4; i < wds; i++)\r\n    buf[i] = 0177777u;\r\nda = (uptr->capac*((dptr->flags & DEV_SECTORS) ? 512 : 1)) - (sec * wds);\r\nfor (i = 0; (stat == SCPE_OK) && (i < sec) && (i < 10); i++, da += wds)\r\n    if (ctx)\r\n        stat = sim_disk_wrsect (uptr, (t_lba)(da/wds), (uint8 *)buf, NULL, 1);\r\n    else {\r\n        if (sim_fseek (uptr->fileref, da, SEEK_SET)) {\r\n            stat = SCPE_IOERR;\r\n            break;\r\n            }\r\n        if ((size_t)wds != sim_fwrite (buf, sizeof (uint16), wds, uptr->fileref))\r\n            stat = SCPE_IOERR;\r\n        }\r\nfree (buf);\r\nreturn stat;\r\n}\r\n\r\nvoid sim_disk_data_trace(UNIT *uptr, const uint8 *data, size_t lba, size_t len, const char* txt, int detail, uint32 reason)\r\n{\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\n\r\nif (sim_deb && ((uptr->dctrl | dptr->dctrl) & reason)) {\r\n    char pos[32];\r\n\r\n    sprintf (pos, \"lbn: %08X \", (unsigned int)lba);\r\n    sim_data_trace(dptr, uptr, (detail ? data : NULL), pos, len, txt, reason);\r\n    }\r\n}\r\n\r\n/* OS Specific RAW Disk I/O support */\r\n\r\n#if defined _WIN32\r\n\r\nstatic void _set_errno_from_status (DWORD dwStatus)\r\n{\r\nswitch (dwStatus) {\r\n    case ERROR_FILE_NOT_FOUND:    case ERROR_PATH_NOT_FOUND:\r\n    case ERROR_INVALID_DRIVE:     case ERROR_NO_MORE_FILES:\r\n    case ERROR_BAD_NET_NAME:      case ERROR_BAD_NETPATH:\r\n    case ERROR_BAD_PATHNAME:      case ERROR_FILENAME_EXCED_RANGE:\r\n        errno = ENOENT;\r\n        return;\r\n    case ERROR_INVALID_ACCESS:    case ERROR_INVALID_DATA:\r\n    case ERROR_INVALID_FUNCTION:  case ERROR_INVALID_PARAMETER:\r\n    case ERROR_NEGATIVE_SEEK:\r\n        errno = EINVAL;\r\n        return;\r\n    case ERROR_ARENA_TRASHED:     case ERROR_NOT_ENOUGH_MEMORY:\r\n    case ERROR_INVALID_BLOCK:     case ERROR_NOT_ENOUGH_QUOTA:\r\n        errno = ENOMEM;\r\n        return;\r\n    case ERROR_TOO_MANY_OPEN_FILES:\r\n        errno = EMFILE;\r\n        return;\r\n    case ERROR_ACCESS_DENIED:     case ERROR_CURRENT_DIRECTORY:\r\n    case ERROR_LOCK_VIOLATION:    case ERROR_NETWORK_ACCESS_DENIED:\r\n    case ERROR_CANNOT_MAKE:       case ERROR_FAIL_I24:\r\n    case ERROR_DRIVE_LOCKED:      case ERROR_SEEK_ON_DEVICE:\r\n    case ERROR_NOT_LOCKED:        case ERROR_LOCK_FAILED:\r\n        errno = EACCES;\r\n        return;\r\n    case ERROR_ALREADY_EXISTS:    case ERROR_FILE_EXISTS:\r\n        errno = EEXIST;\r\n        return;\r\n    case ERROR_INVALID_HANDLE:    case ERROR_INVALID_TARGET_HANDLE:\r\n    case ERROR_DIRECT_ACCESS_HANDLE:\r\n        errno = EBADF;\r\n        return;\r\n    case ERROR_DIR_NOT_EMPTY:\r\n        errno = ENOTEMPTY;\r\n        return;\r\n    case ERROR_BAD_ENVIRONMENT:\r\n        errno = E2BIG;\r\n        return;\r\n    case ERROR_BAD_FORMAT:\r\n        errno = ENOEXEC;\r\n        return;\r\n    case ERROR_NOT_SAME_DEVICE:\r\n        errno = EXDEV;\r\n        return;\r\n    case ERROR_BROKEN_PIPE:\r\n        errno = EPIPE;\r\n        return;\r\n    case ERROR_DISK_FULL:\r\n        errno = ENOSPC;\r\n        return;\r\n    case ERROR_WAIT_NO_CHILDREN:  case ERROR_CHILD_NOT_COMPLETE:\r\n        errno = ECHILD;\r\n        return;\r\n    case ERROR_NO_PROC_SLOTS:     case ERROR_MAX_THRDS_REACHED:\r\n    case ERROR_NESTING_NOT_ALLOWED:\r\n        errno = EAGAIN;\r\n        return;\r\n    }\r\nif ((dwStatus >= ERROR_WRITE_PROTECT) && (dwStatus <= ERROR_SHARING_BUFFER_EXCEEDED)) {\r\n    errno = EACCES;\r\n    return;\r\n    }\r\nif ((dwStatus >= ERROR_INVALID_STARTING_CODESEG) && (dwStatus <= ERROR_INFLOOP_IN_RELOC_CHAIN)) {\r\n    errno = ENOEXEC;\r\n    return;\r\n    }\r\nerrno = EINVAL;\r\n}\r\n#if defined(__GNUC__) && defined(HAVE_NTDDDISK_H)\r\n#include <ddk/ntddstor.h>\r\n#include <ddk/ntdddisk.h>\r\n#else\r\n#include <winioctl.h>\r\n#endif\r\n\r\n#if defined(__cplusplus)\r\nextern \"C\" {\r\n#endif\r\nWINBASEAPI BOOL WINAPI GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);\r\n#if defined(__cplusplus)\r\n    }\r\n#endif\r\n\r\nstruct _device_type {\r\n    int32 Type;\r\n    const char *desc;\r\n    } DeviceTypes[] = {\r\n        {FILE_DEVICE_8042_PORT,             \"8042_PORT\"},\r\n        {FILE_DEVICE_ACPI,                  \"ACPI\"},\r\n        {FILE_DEVICE_BATTERY,               \"BATTERY\"},\r\n        {FILE_DEVICE_BEEP,                  \"BEEP\"},\r\n#ifdef FILE_DEVICE_BLUETOOTH\r\n        {FILE_DEVICE_BLUETOOTH,             \"BLUETOOTH\"},\r\n#endif\r\n        {FILE_DEVICE_BUS_EXTENDER,          \"BUS_EXTENDER\"},\r\n        {FILE_DEVICE_CD_ROM,                \"CD_ROM\"},\r\n        {FILE_DEVICE_CD_ROM_FILE_SYSTEM,    \"CD_ROM_FILE_SYSTEM\"},\r\n        {FILE_DEVICE_CHANGER,               \"CHANGER\"},\r\n        {FILE_DEVICE_CONTROLLER,            \"CONTROLLER\"},\r\n#ifdef FILE_DEVICE_CRYPT_PROVIDER\r\n        {FILE_DEVICE_CRYPT_PROVIDER,        \"CRYPT_PROVIDER\"},\r\n#endif\r\n        {FILE_DEVICE_DATALINK,              \"DATALINK\"},\r\n        {FILE_DEVICE_DFS,                   \"DFS\"},\r\n        {FILE_DEVICE_DFS_FILE_SYSTEM,       \"DFS_FILE_SYSTEM\"},\r\n        {FILE_DEVICE_DFS_VOLUME,            \"DFS_VOLUME\"},\r\n        {FILE_DEVICE_DISK,                  \"DISK\"},\r\n        {FILE_DEVICE_DISK_FILE_SYSTEM,      \"DISK_FILE_SYSTEM\"},\r\n        {FILE_DEVICE_DVD,                   \"DVD\"},\r\n        {FILE_DEVICE_FILE_SYSTEM,           \"FILE_SYSTEM\"},\r\n#ifdef FILE_DEVICE_FIPS\r\n        {FILE_DEVICE_FIPS,                  \"FIPS\"},\r\n#endif\r\n        {FILE_DEVICE_FULLSCREEN_VIDEO,      \"FULLSCREEN_VIDEO\"},\r\n#ifdef FILE_DEVICE_INFINIBAND\r\n        {FILE_DEVICE_INFINIBAND,            \"INFINIBAND\"},\r\n#endif\r\n        {FILE_DEVICE_INPORT_PORT,           \"INPORT_PORT\"},\r\n        {FILE_DEVICE_KEYBOARD,              \"KEYBOARD\"},\r\n        {FILE_DEVICE_KS,                    \"KS\"},\r\n        {FILE_DEVICE_KSEC,                  \"KSEC\"},\r\n        {FILE_DEVICE_MAILSLOT,              \"MAILSLOT\"},\r\n        {FILE_DEVICE_MASS_STORAGE,          \"MASS_STORAGE\"},\r\n        {FILE_DEVICE_MIDI_IN,               \"MIDI_IN\"},\r\n        {FILE_DEVICE_MIDI_OUT,              \"MIDI_OUT\"},\r\n        {FILE_DEVICE_MODEM,                 \"MODEM\"},\r\n        {FILE_DEVICE_MOUSE,                 \"MOUSE\"},\r\n        {FILE_DEVICE_MULTI_UNC_PROVIDER,    \"MULTI_UNC_PROVIDER\"},\r\n        {FILE_DEVICE_NAMED_PIPE,            \"NAMED_PIPE\"},\r\n        {FILE_DEVICE_NETWORK,               \"NETWORK\"},\r\n        {FILE_DEVICE_NETWORK_BROWSER,       \"NETWORK_BROWSER\"},\r\n        {FILE_DEVICE_NETWORK_FILE_SYSTEM,   \"NETWORK_FILE_SYSTEM\"},\r\n        {FILE_DEVICE_NETWORK_REDIRECTOR,    \"NETWORK_REDIRECTOR\"},\r\n        {FILE_DEVICE_NULL,                  \"NULL\"},\r\n        {FILE_DEVICE_PARALLEL_PORT,         \"PARALLEL_PORT\"},\r\n        {FILE_DEVICE_PHYSICAL_NETCARD,      \"PHYSICAL_NETCARD\"},\r\n        {FILE_DEVICE_PRINTER,               \"PRINTER\"},\r\n        {FILE_DEVICE_SCANNER,               \"SCANNER\"},\r\n        {FILE_DEVICE_SCREEN,                \"SCREEN\"},\r\n        {FILE_DEVICE_SERENUM,               \"SERENUM\"},\r\n        {FILE_DEVICE_SERIAL_MOUSE_PORT,     \"SERIAL_MOUSE_PORT\"},\r\n        {FILE_DEVICE_SERIAL_PORT,           \"SERIAL_PORT\"},\r\n        {FILE_DEVICE_SMARTCARD,             \"SMARTCARD\"},\r\n        {FILE_DEVICE_SMB,                   \"SMB\"},\r\n        {FILE_DEVICE_SOUND,                 \"SOUND\"},\r\n        {FILE_DEVICE_STREAMS,               \"STREAMS\"},\r\n        {FILE_DEVICE_TAPE,                  \"TAPE\"},\r\n        {FILE_DEVICE_TAPE_FILE_SYSTEM,      \"TAPE_FILE_SYSTEM\"},\r\n        {FILE_DEVICE_TERMSRV,               \"TERMSRV\"},\r\n        {FILE_DEVICE_TRANSPORT,             \"TRANSPORT\"},\r\n        {FILE_DEVICE_UNKNOWN,               \"UNKNOWN\"},\r\n        {FILE_DEVICE_VDM,                   \"VDM\"},\r\n        {FILE_DEVICE_VIDEO,                 \"VIDEO\"},\r\n        {FILE_DEVICE_VIRTUAL_DISK,          \"VIRTUAL_DISK\"},\r\n#ifdef FILE_DEVICE_VMBUS\r\n        {FILE_DEVICE_VMBUS,                 \"VMBUS\"},\r\n#endif\r\n        {FILE_DEVICE_WAVE_IN,               \"WAVE_IN\"},\r\n        {FILE_DEVICE_WAVE_OUT,              \"WAVE_OUT\"},\r\n#ifdef FILE_DEVICE_WPD\r\n        {FILE_DEVICE_WPD,                   \"WPD\"},\r\n#endif\r\n        {0,                                 NULL}};\r\n\r\nstatic const char *_device_type_name (int DeviceType)\r\n{\r\nint i;\r\n\r\nfor (i=0; DeviceTypes[i].desc; i++)\r\n    if (DeviceTypes[i].Type == DeviceType)\r\n        return DeviceTypes[i].desc;\r\nreturn \"Unknown\";\r\n}\r\n\r\nstatic t_stat sim_os_disk_implemented_raw (void)\r\n{\r\nreturn sim_toffset_64 ? SCPE_OK : SCPE_NOFNC;\r\n}\r\n\r\nstatic FILE *sim_os_disk_open_raw (const char *rawdevicename, const char *openmode)\r\n{\r\nHANDLE Handle;\r\nDWORD DesiredAccess = 0;\r\nuint32 is_cdrom;\r\nchar *tmpname = (char *)malloc (2 + strlen (rawdevicename));\r\n\r\nif (tmpname == NULL)\r\n    return NULL;\r\nif (strchr (openmode, 'r'))\r\n    DesiredAccess |= GENERIC_READ;\r\nif (strchr (openmode, 'w') || strchr (openmode, '+'))\r\n    DesiredAccess |= GENERIC_WRITE;\r\n/* SCP Command Line parsing replaces \\\\ with \\ presuming this is an\r\n   escape sequence.  This only affects RAW device names and UNC paths.\r\n   We handle the RAW device name case here by prepending paths beginning\r\n   with \\.\\ with an extra \\. */\r\nif ((!memcmp (\"\\\\.\\\\\", rawdevicename, 3)) ||\r\n    (!memcmp (\"/./\", rawdevicename, 3))) {\r\n    *tmpname = '\\\\';\r\n    strcpy (tmpname + 1, rawdevicename);\r\n    }\r\nelse\r\n    strcpy (tmpname, rawdevicename);\r\nHandle = CreateFileA (tmpname, DesiredAccess, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS|FILE_FLAG_WRITE_THROUGH, NULL);\r\nfree (tmpname);\r\nif (Handle != INVALID_HANDLE_VALUE) {\r\n    if ((sim_os_disk_info_raw ((FILE *)Handle, NULL, NULL, &is_cdrom)) ||\r\n        ((DesiredAccess & GENERIC_WRITE) && is_cdrom)) {\r\n        CloseHandle (Handle);\r\n        errno = EACCES;\r\n        return NULL;\r\n        }\r\n    return (FILE *)Handle;\r\n    }\r\n_set_errno_from_status (GetLastError ());\r\nreturn NULL;\r\n}\r\n\r\nstatic int sim_os_disk_close_raw (FILE *f)\r\n{\r\nif (!CloseHandle ((HANDLE)f)) {\r\n    _set_errno_from_status (GetLastError ());\r\n    return EOF;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nstatic void sim_os_disk_flush_raw (FILE *f)\r\n{\r\nFlushFileBuffers ((HANDLE)f);\r\n}\r\n\r\nstatic t_offset sim_os_disk_size_raw (FILE *Disk)\r\n{\r\nDWORD IoctlReturnSize;\r\nLARGE_INTEGER Size;\r\n\r\nif (GetFileSizeEx((HANDLE)Disk, &Size))\r\n    return (t_offset)(Size.QuadPart);\r\n#ifdef IOCTL_STORAGE_READ_CAPACITY\r\nif (1) {\r\n    STORAGE_READ_CAPACITY S;\r\n\r\n    ZeroMemory (&S, sizeof (S));\r\n    S.Version = sizeof (STORAGE_READ_CAPACITY);\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_STORAGE_READ_CAPACITY,      /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &S,                      /* output buffer */\r\n                         (DWORD) sizeof(S),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        return (t_offset)(S.DiskLength.QuadPart);\r\n    }\r\n#endif\r\n#ifdef IOCTL_DISK_GET_DRIVE_GEOMETRY_EX\r\nif (1) {\r\n    DISK_GEOMETRY_EX G;\r\n\r\n    ZeroMemory (&G, sizeof (G));\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &G,                      /* output buffer */\r\n                         (DWORD) sizeof(G),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        return (t_offset)(G.DiskSize.QuadPart);\r\n    }\r\n#endif\r\n#ifdef IOCTL_DISK_GET_DRIVE_GEOMETRY\r\nif (1) {\r\n    DISK_GEOMETRY G;\r\n\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_DISK_GET_DRIVE_GEOMETRY,    /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &G,                      /* output buffer */\r\n                         (DWORD) sizeof(G),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        return (t_offset)(G.Cylinders.QuadPart*G.TracksPerCylinder*G.SectorsPerTrack*G.BytesPerSector);\r\n    }\r\n#endif\r\n_set_errno_from_status (GetLastError ());\r\nreturn (t_offset)-1;\r\n}\r\n\r\nstatic t_stat sim_os_disk_unload_raw (FILE *Disk)\r\n{\r\n#ifdef IOCTL_STORAGE_EJECT_MEDIA\r\nDWORD BytesReturned;\r\nuint32 Removable = FALSE;\r\n\r\nsim_os_disk_info_raw (Disk, NULL, &Removable, NULL);\r\nif (Removable) {\r\n    if (!DeviceIoControl((HANDLE)Disk,                  /* handle to disk */\r\n                         IOCTL_STORAGE_EJECT_MEDIA,     /* dwIoControlCode */\r\n                         NULL,                          /* lpInBuffer */\r\n                         0,                             /* nInBufferSize */\r\n                         NULL,                          /* lpOutBuffer */\r\n                         0,                             /* nOutBufferSize */\r\n                         (LPDWORD) &BytesReturned,      /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL)) {        /* OVERLAPPED structure */\r\n        _set_errno_from_status (GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n#else\r\nreturn SCPE_NOFNC;\r\n#endif\r\n}\r\n\r\nstatic t_bool sim_os_disk_isavailable_raw (FILE *Disk)\r\n{\r\n#ifdef IOCTL_STORAGE_EJECT_MEDIA\r\nDWORD BytesReturned;\r\nuint32 Removable = FALSE;\r\n\r\nsim_os_disk_info_raw (Disk, NULL, &Removable, NULL);\r\nif (Removable) {\r\n    if (!DeviceIoControl((HANDLE)Disk,                  /* handle to disk */\r\n                         IOCTL_STORAGE_CHECK_VERIFY,    /* dwIoControlCode */\r\n                         NULL,                          /* lpInBuffer */\r\n                         0,                             /* nInBufferSize */\r\n                         NULL,                          /* lpOutBuffer */\r\n                         0,                             /* nOutBufferSize */\r\n                         (LPDWORD) &BytesReturned,      /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL)) {        /* OVERLAPPED structure */\r\n        _set_errno_from_status (GetLastError ());\r\n        return FALSE;\r\n        }\r\n    }\r\n#endif\r\nreturn TRUE;\r\n}\r\n\r\nstatic t_stat sim_os_disk_info_raw (FILE *Disk, uint32 *sector_size, uint32 *removable, uint32 *is_cdrom)\r\n{\r\nDWORD IoctlReturnSize;\r\nSTORAGE_DEVICE_NUMBER Device;\r\n\r\nZeroMemory (&Device, sizeof (Device));\r\nDeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                IOCTL_STORAGE_GET_DEVICE_NUMBER,  /* dwIoControlCode */\r\n                NULL,                             /* lpInBuffer */\r\n                0,                                /* nInBufferSize */\r\n                (LPVOID) &Device,                 /* output buffer */\r\n                (DWORD) sizeof(Device),           /* size of output buffer */\r\n                (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                (LPOVERLAPPED) NULL);             /* OVERLAPPED structure */\r\n\r\nif (sector_size)\r\n    *sector_size = 512;\r\nif (removable)\r\n    *removable = 0;\r\nif (is_cdrom)\r\n    *is_cdrom = (Device.DeviceType == FILE_DEVICE_CD_ROM) || (Device.DeviceType == FILE_DEVICE_DVD);\r\n#ifdef IOCTL_STORAGE_READ_CAPACITY\r\nif (1) {\r\n    STORAGE_READ_CAPACITY S;\r\n\r\n    ZeroMemory (&S, sizeof (S));\r\n    S.Version = sizeof (STORAGE_READ_CAPACITY);\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_STORAGE_READ_CAPACITY,      /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &S,                      /* output buffer */\r\n                         (DWORD) sizeof(S),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        if (sector_size)\r\n            *sector_size = S.BlockLength;\r\n    }\r\n#endif\r\n#ifdef IOCTL_DISK_GET_DRIVE_GEOMETRY_EX\r\nif (1) {\r\n    DISK_GEOMETRY_EX G;\r\n\r\n    ZeroMemory (&G, sizeof (G));\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_DISK_GET_DRIVE_GEOMETRY_EX, /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &G,                      /* output buffer */\r\n                         (DWORD) sizeof(G),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        if (sector_size)\r\n            *sector_size = G.Geometry.BytesPerSector;\r\n    }\r\n#endif\r\n#ifdef IOCTL_DISK_GET_DRIVE_GEOMETRY\r\nif (1) {\r\n    DISK_GEOMETRY G;\r\n\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_DISK_GET_DRIVE_GEOMETRY,    /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &G,                      /* output buffer */\r\n                         (DWORD) sizeof(G),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        if (sector_size)\r\n            *sector_size = G.BytesPerSector;\r\n    }\r\n#endif\r\n#ifdef IOCTL_STORAGE_GET_HOTPLUG_INFO\r\nif (1) {\r\n    STORAGE_HOTPLUG_INFO H;\r\n\r\n    ZeroMemory (&H, sizeof (H));\r\n    if (DeviceIoControl((HANDLE)Disk,                      /* handle to volume */\r\n                         IOCTL_STORAGE_GET_HOTPLUG_INFO,   /* dwIoControlCode */\r\n                         NULL,                             /* lpInBuffer */\r\n                         0,                                /* nInBufferSize */\r\n                         (LPVOID) &H,                      /* output buffer */\r\n                         (DWORD) sizeof(H),                /* size of output buffer */\r\n                         (LPDWORD) &IoctlReturnSize,       /* number of bytes returned */\r\n                         (LPOVERLAPPED) NULL))             /* OVERLAPPED structure */\r\n        if (removable)\r\n            *removable = H.MediaRemovable;\r\n    }\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\nOVERLAPPED pos;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nlong long addr = ((long long)lba) * ctx->sector_size;\r\nDWORD bytestoread = sects * ctx->sector_size;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_rdsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\nif (sectsread)\r\n    *sectsread = 0;\r\nmemset (&pos, 0, sizeof (pos));\r\nwhile (bytestoread) {\r\n    DWORD bytesread;\r\n    DWORD sectorbytes;\r\n\r\n    pos.Offset = (DWORD)addr;\r\n    pos.OffsetHigh = (DWORD)(addr >> 32);\r\n    if (!ReadFile ((HANDLE)(uptr->fileref), buf, bytestoread, &bytesread, &pos)) {\r\n        if (ERROR_HANDLE_EOF == GetLastError ()) {  /* Return 0's for reads past EOF */\r\n            memset (buf, 0, bytestoread);\r\n            if (sectsread)\r\n                *sectsread += bytestoread / ctx->sector_size;\r\n            return SCPE_OK;\r\n            }\r\n        _set_errno_from_status (GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\n    sectorbytes = (bytesread / ctx->sector_size) * ctx->sector_size;\r\n    if (bytesread > sectorbytes) {\r\n        memset (buf + bytesread, 0, bytestoread - bytesread);\r\n        sectorbytes += ctx->sector_size;\r\n        }\r\n    if (sectsread)\r\n        *sectsread += sectorbytes / ctx->sector_size;\r\n    bytestoread -= sectorbytes;\r\n    buf +=  sectorbytes;\r\n    addr += sectorbytes;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_read (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *bytesread, uint32 bytes)\r\n{\r\nOVERLAPPED pos;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_read(unit=%d, addr=0x%X, bytes=%u)\\n\", (int)(uptr - ctx->dptr->units), (uint32)addr, bytes);\r\n\r\nmemset (&pos, 0, sizeof (pos));\r\npos.Offset = (DWORD)addr;\r\npos.OffsetHigh = (DWORD)(addr >> 32);\r\nif (ReadFile ((HANDLE)(uptr->fileref), buf, (DWORD)bytes, (LPDWORD)bytesread, &pos))\r\n    return SCPE_OK;\r\nif (ERROR_HANDLE_EOF == GetLastError ()) {  /* Return 0's for reads past EOF */\r\n    memset (buf, 0, bytes);\r\n    if (bytesread)\r\n        *bytesread = bytes;\r\n    return SCPE_OK;\r\n    }\r\n_set_errno_from_status (GetLastError ());\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat sim_os_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\nOVERLAPPED pos;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nlong long addr;\r\nDWORD byteswritten;\r\nDWORD bytestowrite = sects * ctx->sector_size;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_wrsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nif (sectswritten)\r\n    *sectswritten = 0;\r\naddr = ((long long)lba) * ctx->sector_size;\r\nmemset (&pos, 0, sizeof (pos));\r\nwhile (bytestowrite) {\r\n    DWORD sectorbytes;\r\n\r\n    pos.Offset = (DWORD)addr;\r\n    pos.OffsetHigh = (DWORD)(addr >> 32);\r\n    if (!WriteFile ((HANDLE)(uptr->fileref), buf, bytestowrite, &byteswritten, &pos)) {\r\n        _set_errno_from_status (GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\n    if (sectswritten)\r\n        *sectswritten += byteswritten / ctx->sector_size;\r\n    sectorbytes = (byteswritten / ctx->sector_size) * ctx->sector_size;\r\n    bytestowrite -= sectorbytes;\r\n    if (bytestowrite == 0)\r\n        break;\r\n    buf += sectorbytes;\r\n    addr += sectorbytes;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_write (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *byteswritten, uint32 bytes)\r\n{\r\nOVERLAPPED pos;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_write(unit=%d, lba=0x%X, bytes=%u)\\n\", (int)(uptr - ctx->dptr->units), (uint32)addr, bytes);\r\n\r\nmemset (&pos, 0, sizeof (pos));\r\npos.Offset = (DWORD)addr;\r\npos.OffsetHigh = (DWORD)(addr >> 32);\r\nif (WriteFile ((HANDLE)(uptr->fileref), buf, bytes, (LPDWORD)byteswritten, &pos))\r\n    return SCPE_OK;\r\n_set_errno_from_status (GetLastError ());\r\nreturn SCPE_IOERR;\r\n}\r\n\r\n#elif defined (__linux) || defined (__linux__) || defined (__APPLE__)|| defined (__sun) || defined (__sun__) || defined (__hpux) || defined (_AIX)\r\n\r\n#include <sys/types.h>\r\n#include <sys/stat.h>\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n#if defined(HAVE_SYS_IOCTL)\r\n#include <sys/ioctl.h>\r\n#endif\r\n#if defined(HAVE_LINUX_CDROM)\r\n#include <linux/cdrom.h>\r\n#endif\r\n\r\nstatic t_stat sim_os_disk_implemented_raw (void)\r\n{\r\nreturn sim_toffset_64 ? SCPE_OK : SCPE_NOFNC;\r\n}\r\n\r\nstatic FILE *sim_os_disk_open_raw (const char *rawdevicename, const char *openmode)\r\n{\r\nint mode = 0;\r\nint fd;\r\n\r\nif (strchr (openmode, 'r') && (strchr (openmode, '+') || strchr (openmode, 'w')))\r\n    mode = O_RDWR;\r\nelse\r\n    if (strchr (openmode, 'r'))\r\n        mode = O_RDONLY;\r\n#ifdef O_LARGEFILE\r\nmode |= O_LARGEFILE;\r\n#endif\r\n#ifdef O_DSYNC\r\nmode |= O_DSYNC;\r\n#endif\r\nfd = open (rawdevicename, mode, 0);\r\nif (fd < 0)\r\n    return (FILE *)NULL;\r\nreturn (FILE *)((long)fd);\r\n}\r\n\r\nstatic int sim_os_disk_close_raw (FILE *f)\r\n{\r\nreturn close ((int)((long)f));\r\n}\r\n\r\nstatic void sim_os_disk_flush_raw (FILE *f)\r\n{\r\nfsync ((int)((long)f));\r\n}\r\n\r\nstatic t_offset sim_os_disk_size_raw (FILE *f)\r\n{\r\nt_offset pos, size;\r\n\r\npos = (t_offset)lseek ((int)((long)f), (off_t)0, SEEK_CUR);\r\nsize = (t_offset)lseek ((int)((long)f), (off_t)0, SEEK_END);\r\nif (pos != (t_offset)-1)\r\n    (void)lseek ((int)((long)f), (off_t)pos, SEEK_SET);\r\nreturn size;\r\n}\r\n\r\nstatic t_stat sim_os_disk_unload_raw (FILE *f)\r\n{\r\n#if defined(CDROM_GET_CAPABILITY) && defined(CDROMEJECT) && defined(CDROMEJECT_SW)\r\nif (ioctl ((int)((long)f), CDROM_GET_CAPABILITY, NULL) < 0)\r\n    return SCPE_OK;\r\nif (ioctl((int)((long)f), CDROM_LOCKDOOR, 0) < 0)\r\n    return sim_messagef (SCPE_OK, \"Apparent CDROM can't unlock door: %s\\n\", strerror (errno));\r\nif (ioctl((int)((long)f), CDROMEJECT) < 0)\r\n    return sim_messagef (SCPE_OK, \"Apparent CDROM can't eject: %s\\n\", strerror (errno));\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_bool sim_os_disk_isavailable_raw (FILE *Disk)\r\n{\r\n#if defined(CDROMSTART) && defined(CDROM_GET_CAPABILITY)\r\nif (ioctl ((int)((long)Disk), CDROM_GET_CAPABILITY, NULL) < 0)\r\n    return TRUE;\r\nswitch (ioctl((int)((long)Disk), CDROM_DRIVE_STATUS, CDSL_NONE)) {\r\n    case CDS_NO_INFO:\r\n    case CDS_NO_DISC:\r\n    case CDS_TRAY_OPEN:\r\n    case CDS_DRIVE_NOT_READY:\r\n    default: /* error */\r\n        return FALSE;\r\n    case CDS_DISC_OK:\r\n        return TRUE;\r\n    }\r\n#endif\r\nreturn TRUE;\r\n}\r\n\r\nstatic t_stat sim_os_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\noff_t addr = ((off_t)lba) * ctx->sector_size;\r\nssize_t bytesread;\r\nsize_t bytestoread = sects * ctx->sector_size;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_rdsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nif (sectsread)\r\n    *sectsread = 0;\r\nwhile (bytestoread) {\r\n    size_t sectorbytes;\r\n\r\n    bytesread = pread((int)((long)uptr->fileref), buf, bytestoread, addr);\r\n    if (bytesread < 0) {\r\n        return SCPE_IOERR;\r\n        }\r\n    if ((size_t)bytesread < bytestoread) {/* read zeros at/past EOF */\r\n        memset (buf + bytesread, 0, bytestoread - bytesread);\r\n        bytesread = bytestoread;\r\n        }\r\n    sectorbytes = (bytesread / ctx->sector_size) * ctx->sector_size;\r\n    if ((size_t)bytesread > sectorbytes)\r\n        sectorbytes += ctx->sector_size;\r\n    if (sectsread)\r\n        *sectsread += sectorbytes / ctx->sector_size;\r\n    bytestoread -= sectorbytes;\r\n    buf += sectorbytes;\r\n    addr += sectorbytes;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_read (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *rbytesread, uint32 bytes)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nssize_t bytesread;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_read(unit=%d, addr=0x%X, bytes=%u)\\n\", (int)(uptr - ctx->dptr->units), (uint32)addr, bytes);\r\n\r\nbytesread = pread((int)((long)uptr->fileref), buf, bytes, (off_t)addr);\r\nif (bytesread < 0) {\r\n    if (rbytesread)\r\n        *rbytesread = 0;\r\n    return SCPE_IOERR;\r\n    }\r\nif (rbytesread)\r\n    *rbytesread = bytesread;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\noff_t addr = ((off_t)lba) * ctx->sector_size;\r\nssize_t byteswritten;\r\nsize_t bytestowrite = sects * ctx->sector_size;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_wrsect(unit=%d, lba=0x%X, sects=%d)\\n\", (int)(uptr - ctx->dptr->units), lba, sects);\r\n\r\nif (sectswritten)\r\n    *sectswritten = 0;\r\nwhile (bytestowrite) {\r\n    size_t sectorbytes;\r\n\r\n    byteswritten = pwrite((int)((long)uptr->fileref), buf, bytestowrite, addr);\r\n    if (byteswritten < 0) {\r\n        return SCPE_IOERR;\r\n        }\r\n    if (sectswritten)\r\n        *sectswritten += byteswritten / ctx->sector_size;\r\n    sectorbytes = (byteswritten / ctx->sector_size) * ctx->sector_size;\r\n    bytestowrite -= sectorbytes;\r\n    if (bytestowrite == 0)\r\n        break;\r\n    buf += sectorbytes;\r\n    addr += sectorbytes;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_write (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *rbyteswritten, uint32 bytes)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nssize_t byteswritten;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_os_disk_write(unit=%d, addr=0x%X, bytes=%u)\\n\", (int)(uptr - ctx->dptr->units), (uint32)addr, bytes);\r\n\r\nif (rbyteswritten)\r\n    *rbyteswritten = 0;\r\nbyteswritten = pwrite((int)((long)uptr->fileref), buf, bytes, (off_t)addr);\r\nif (byteswritten < 0)\r\n    return SCPE_IOERR;\r\nif (rbyteswritten)\r\n    *rbyteswritten = byteswritten;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_os_disk_info_raw (FILE *f, uint32 *sector_size, uint32 *removable, uint32 *is_cdrom)\r\n{\r\nif (sector_size) {\r\n#if defined(BLKSSZGET)\r\n    if (ioctl ((int)((long)f), BLKSSZGET, sector_size) < 0)\r\n#endif\r\n        *sector_size = 512;\r\n    }\r\nif (removable)\r\n    *removable = 0;\r\nif (is_cdrom) {\r\n#if defined(CDROM_GET_CAPABILITY)\r\n    int cd_cap = ioctl ((int)((long)f), CDROM_GET_CAPABILITY, NULL);\r\n\r\n    if (cd_cap < 0)\r\n        *is_cdrom = 0;\r\n    else {\r\n        *is_cdrom = 1;\r\n        if (removable)\r\n            *removable = 1;\r\n        if (sector_size)\r\n            *sector_size = 2048;\r\n        }\r\n#else\r\n    *is_cdrom = 0;\r\n#endif\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n#else\r\n/*============================================================================*/\r\n/*                        Non-implemented versions                            */\r\n/*============================================================================*/\r\n\r\nstatic t_stat sim_os_disk_implemented_raw (void)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic FILE *sim_os_disk_open_raw (const char *rawdevicename, const char *openmode)\r\n{\r\nreturn NULL;\r\n}\r\n\r\nstatic int sim_os_disk_close_raw (FILE *f)\r\n{\r\nreturn EOF;\r\n}\r\n\r\nstatic void sim_os_disk_flush_raw (FILE *f)\r\n{\r\n}\r\n\r\nstatic t_offset sim_os_disk_size_raw (FILE *f)\r\n{\r\nreturn (t_offset)-1;\r\n}\r\n\r\nstatic t_stat sim_os_disk_unload_raw (FILE *f)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic t_bool sim_os_disk_isavailable_raw (FILE *Disk)\r\n{\r\nreturn FALSE;\r\n}\r\n\r\nstatic t_stat sim_os_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\n*sectsread = 0;\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic t_stat sim_os_disk_read (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *bytesread, uint32 bytes)\r\n{\r\n*bytesread = 0;\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic t_stat sim_os_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\n*sectswritten = 0;\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic t_stat sim_os_disk_write (UNIT *uptr, t_offset addr, uint8 *buf, uint32 *byteswritten, uint32 bytes)\r\n{\r\n*byteswritten = 0;\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic t_stat sim_os_disk_info_raw (FILE *f, uint32 *sector_size, uint32 *removable, uint32 *is_cdrom)\r\n{\r\n*sector_size = *removable = *is_cdrom = 0;\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\n#endif\r\n\r\n/* OS Independent Disk Virtual Disk (VHD) I/O support */\r\n\r\n#if (defined (VMS) && !(defined (__ALPHA) || defined (__ia64)))\r\n#define DONT_DO_VHD_SUPPORT  /* VAX/VMS compilers don't have 64 bit integers */\r\n#endif\r\n\r\n#if defined (DONT_DO_VHD_SUPPORT)\r\n\r\n/*============================================================================*/\r\n/*                        Non-implemented version                             */\r\n/*   This is only for systems which don't have 64 bit integer types           */\r\n/*============================================================================*/\r\n\r\nstatic t_stat sim_vhd_disk_implemented (void)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_open (const char *vhdfilename, const char *openmode)\r\n{\r\nreturn NULL;\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_merge (const char *szVHDPath, char **ParentVHD)\r\n{\r\nreturn NULL;\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_create (const char *szVHDPath, t_offset desiredsize, DRVTYP *drvtyp)\r\n{\r\nreturn NULL;\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_create_diff (const char *szVHDPath, const char *szParentVHDPath)\r\n{\r\nreturn NULL;\r\n}\r\n\r\nstatic int sim_vhd_disk_close (FILE *f)\r\n{\r\nreturn -1;\r\n}\r\n\r\nstatic void sim_vhd_disk_flush (FILE *f)\r\n{\r\n}\r\n\r\nstatic t_offset sim_vhd_disk_size (FILE *f)\r\n{\r\nreturn (t_offset)-1;\r\n}\r\n\r\nstatic uint32 sim_vhd_CHS (FILE *f)\r\n{\r\nreturn 0;\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_parent_path (FILE *f)\r\n{\r\nreturn NULL;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\n*sectsread = 0;\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_clearerr (UNIT *uptr)\r\n{\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\n*sectswritten = 0;\r\nreturn SCPE_IOERR;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_set_dtype (FILE *f, const char *dtype, uint32 SectorSize, uint32 xfer_encode_size, uint32 media_id, const char *device_name, uint32 data_width, DRVTYP *drvtyp)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nstatic const char *sim_vhd_disk_get_dtype (FILE *f, uint32 *SectorSize, uint32 *xfer_encode_size, char sim_name[64], time_t *creation_time, uint32 *media_id, char device_name[16], uint32 *data_width)\r\n{\r\n*SectorSize = *xfer_encode_size = 0;\r\nreturn NULL;\r\n}\r\n\r\n#else\r\n\r\n/*++\r\n    This code follows the details specified in the \"Virtual Hard Disk Image\r\n    Format Specification\", Version 1.0 October 11, 2006.  This format\r\n    specification is available for anyone to implement under the\r\n    \"Microsoft Open Specification Promise\" described at:\r\n        http://www.microsoft.com/interop/osp/default.mspx.\r\n--*/\r\n\r\ntypedef t_uint64    uint64;\r\ntypedef t_int64     int64;\r\n\r\ntypedef struct _VHD_Footer {\r\n    /*\r\n    Cookies are used to uniquely identify the original creator of the hard disk\r\n    image. The values are case-sensitive.  Microsoft uses the \"conectix\" string\r\n    to identify this file as a hard disk image created by Microsoft Virtual\r\n    Server, Virtual PC, and predecessor products. The cookie is stored as an\r\n    eight-character ASCII string with the \"c\" in the first byte, the \"o\" in\r\n    the second byte, and so on.\r\n    */\r\n    char Cookie[8];\r\n    /*\r\n    This is a bit field used to indicate specific feature support. The following\r\n    table displays the list of features.\r\n    Any fields not listed are reserved.\r\n\r\n    Feature Value:\r\n       No features enabled     0x00000000\r\n       Temporary               0x00000001\r\n       Reserved                0x00000002\r\n\r\n       No features enabled.\r\n              The hard disk image has no special features enabled in it.\r\n       Temporary.\r\n              This bit is set if the current disk is a temporary disk. A\r\n              temporary disk designation indicates to an application that\r\n              this disk is a candidate for deletion on shutdown.\r\n       Reserved.\r\n              This bit must always be set to 1.\r\n       All other bits are also reserved and should be set to 0.\r\n    */\r\n    uint32 Features;\r\n    /*\r\n    This field is divided into a major/minor version and matches the version of\r\n    the specification used in creating the file. The most-significant two bytes\r\n    are for the major version. The least-significant two bytes are the minor\r\n    version.  This must match the file format specification. For the current\r\n    specification, this field must be initialized to 0x00010000.\r\n    The major version will be incremented only when the file format is modified\r\n    in such a way that it is no longer compatible with older versions of the\r\n    file format.\r\n    */\r\n    uint32 FileFormatVersion;\r\n    /*\r\n    This field holds the absolute byte offset, from the beginning of the file,\r\n    to the next structure. This field is used for dynamic disks and differencing\r\n    disks, but not fixed disks. For fixed disks, this field should be set to\r\n    0xFFFFFFFF.\r\n    */\r\n    uint64 DataOffset;\r\n    /*\r\n    This field stores the creation time of a hard disk image. This is the number\r\n    of seconds since January 1, 2000 12:00:00 AM in UTC/GMT.\r\n    */\r\n    uint32 TimeStamp;\r\n    /*\r\n    This field is used to document which application created the hard disk. The\r\n    field is a left-justified text field. It uses a single-byte character set.\r\n    If the hard disk is created by Microsoft Virtual PC, \"vpc \" is written in\r\n    this field. If the hard disk image is created by Microsoft Virtual Server,\r\n    then \"vs  \" is written in this field.\r\n    Other applications should use their own unique identifiers.\r\n    */\r\n    char CreatorApplication[4];\r\n    /*\r\n    This field holds the major/minor version of the application that created\r\n    the hard disk image.  Virtual Server 2004 sets this value to 0x00010000 and\r\n    Virtual PC 2004 sets this to 0x00050000.\r\n    */\r\n    uint32 CreatorVersion;\r\n    /*\r\n    This field stores the type of host operating system this disk image is\r\n    created on.\r\n       Host OS type    Value\r\n       Windows         0x5769326B (Wi2k)\r\n       Macintosh       0x4D616320 (Mac )\r\n    */\r\n    uint8 CreatorHostOS[4];\r\n    /*\r\n    This field stores the size of the hard disk in bytes, from the perspective\r\n    of the virtual machine, at creation time. This field is for informational\r\n    purposes.\r\n    */\r\n    uint64 OriginalSize;\r\n    /*\r\n    This field stores the current size of the hard disk, in bytes, from the\r\n    perspective of the virtual machine.\r\n    This value is same as the original size when the hard disk is created.\r\n    This value can change depending on whether the hard disk is expanded.\r\n    */\r\n    uint64 CurrentSize;\r\n    /*\r\n    This field stores the cylinder, heads, and sectors per track value for the\r\n    hard disk.\r\n       Disk Geometry field          Size (bytes)\r\n       Cylinder                     2\r\n       Heads                        1\r\n       Sectors per track/cylinder   1\r\n\r\n    When a hard disk is configured as an ATA hard disk, the CHS values (that is,\r\n    Cylinder, Heads, Sectors per track) are used by the ATA controller to\r\n    determine the size of the disk. When the user creates a hard disk of a\r\n    certain size, the size of the hard disk image in the virtual machine is\r\n    smaller than that created by the user. This is because CHS value calculated\r\n    from the hard disk size is rounded down. The pseudo-code for the algorithm\r\n    used to determine the CHS values can be found in the appendix of this\r\n    document.\r\n    */\r\n    uint32 DiskGeometry;\r\n    /*\r\n       Disk Type field              Value\r\n       None                         0\r\n       Reserved (deprecated)        1\r\n       Fixed hard disk              2\r\n       Dynamic hard disk            3\r\n       Differencing hard disk       4\r\n       Reserved (deprecated)        5\r\n       Reserved (deprecated)        6\r\n    */\r\n    uint32 DiskType;\r\n    /*\r\n    This field holds a basic checksum of the hard disk footer. It is just a\r\n    one's complement of the sum of all the bytes in the footer without the\r\n    checksum field.\r\n    If the checksum verification fails, the Virtual PC and Virtual Server\r\n    products will instead use the header. If the checksum in the header also\r\n    fails, the file should be assumed to be corrupt. The pseudo-code for the\r\n    algorithm used to determine the checksum can be found in the appendix of\r\n    this document.\r\n    */\r\n    uint32 Checksum;\r\n    /*\r\n    Every hard disk has a unique ID stored in the hard disk. This is used to\r\n    identify the hard disk. This is a 128-bit universally unique identifier\r\n    (UUID). This field is used to associate a parent hard disk image with its\r\n    differencing hard disk image(s).\r\n    */\r\n    uint8 UniqueID[16];\r\n    /*\r\n    This field holds a one-byte flag that describes whether the system is in\r\n    saved state. If the hard disk is in the saved state the value is set to 1.\r\n    Operations such as compaction and expansion cannot be performed on a hard\r\n    disk in a saved state.\r\n    */\r\n    uint8 SavedState;\r\n    /*\r\n    This field contains zeroes. It is 427 bytes in size.\r\n    */\r\n    uint8 Reserved1[11];\r\n    /*\r\n    This field is an extension to the VHD spec and includes a simh drive type\r\n    name as a nul terminated string.\r\n    */\r\n    uint8 DriveType[16];\r\n    uint32 DriveSectorSize;\r\n    uint32 DriveElementEncodingSize;\r\n    uint8 CreatingSimulator[64];\r\n    uint32 MediaId;\r\n    uint32 DataWidth;\r\n    uint8 DeviceName[16];\r\n    /*\r\n    This field contains zeroes. It is 304 bytes in size.\r\n    */\r\n    uint8 Reserved[304];\r\n    } VHD_Footer;\r\n\r\n/*\r\nFor dynamic and differencing disk images, the \"Data Offset\" field within\r\nthe image footer points to a secondary structure that provides additional\r\ninformation about the disk image. The dynamic disk header should appear on\r\na sector (512-byte) boundary.\r\n*/\r\ntypedef struct _VHD_DynamicDiskHeader {\r\n    /*\r\n    This field holds the value \"cxsparse\". This field identifies the header.\r\n    */\r\n    char Cookie[8];\r\n    /*\r\n    This field contains the absolute byte offset to the next structure in the\r\n    hard disk image. It is currently unused by existing formats and should be\r\n    set to 0xFFFFFFFF.\r\n    */\r\n    uint64 DataOffset;\r\n    /*\r\n    This field stores the absolute byte offset of the Block Allocation Table\r\n    (BAT) in the file.\r\n    */\r\n    uint64 TableOffset;\r\n    /*\r\n    This field stores the version of the dynamic disk header. The field is\r\n    divided into Major/Minor version. The least-significant two bytes represent\r\n    the minor version, and the most-significant two bytes represent the major\r\n    version. This must match with the file format specification. For this\r\n    specification, this field must be initialized to 0x00010000.\r\n    The major version will be incremented only when the header format is\r\n    modified in such a way that it is no longer compatible with older versions\r\n    of the product.\r\n    */\r\n    uint32 HeaderVersion;\r\n    /*\r\n    This field holds the maximum entries present in the BAT. This should be\r\n    equal to the number of blocks in the disk (that is, the disk size divided\r\n    by the block size).\r\n    */\r\n    uint32 MaxTableEntries;\r\n    /*\r\n    A block is a unit of expansion for dynamic and differencing hard disks. It\r\n    is stored in bytes. This size does not include the size of the block bitmap.\r\n    It is only the size of the data section of the block. The sectors per block\r\n    must always be a power of two. The default value is 0x00200000 (indicating a\r\n    block size of 2 MB).\r\n    */\r\n    uint32 BlockSize;\r\n    /*\r\n    This field holds a basic checksum of the dynamic header. It is a one's\r\n    complement of the sum of all the bytes in the header without the checksum\r\n    field.\r\n    If the checksum verification fails the file should be assumed to be corrupt.\r\n    */\r\n    uint32 Checksum;\r\n    /*\r\n    This field is used for differencing hard disks. A differencing hard disk\r\n    stores a 128-bit UUID of the parent hard disk. For more information, see\r\n    \"Creating Differencing Hard Disk Images\" later in this paper.\r\n    */\r\n    uint8 ParentUniqueID[16];\r\n    /*\r\n    This field stores the modification time stamp of the parent hard disk. This\r\n    is the number of seconds since January 1, 2000 12:00:00 AM in UTC/GMT.\r\n    */\r\n    uint32 ParentTimeStamp;\r\n    /*\r\n    This field should be set to zero.\r\n    */\r\n    uint32 Reserved0;\r\n    /*\r\n    This field contains a Unicode string (UTF-16) of the parent hard disk\r\n    filename.\r\n    */\r\n    char ParentUnicodeName[512];\r\n    /*\r\n    These entries store an absolute byte offset in the file where the parent\r\n    locator for a differencing hard disk is stored. This field is used only for\r\n    differencing disks and should be set to zero for dynamic disks.\r\n    */\r\n    struct VHD_ParentLocator {\r\n        /*\r\n        The platform code describes which platform-specific format is used for the\r\n        file locator. For Windows, a file locator is stored as a path (for example.\r\n        \"c:\\disksimages\\ParentDisk.vhd\"). On a Macintosh system, the file locator\r\n        is a binary large object (blob) that contains an \"alias.\" The parent locator\r\n        table is used to support moving hard disk images across platforms.\r\n        Some current platform codes include the following:\r\n           Platform Code        Description\r\n           None (0x0)\r\n           Wi2r (0x57693272)    [deprecated]\r\n           Wi2k (0x5769326B)    [deprecated]\r\n           W2ru (0x57327275)    Unicode pathname (UTF-16) on Windows relative to the differencing disk pathname.\r\n           W2ku (0x57326B75)    Absolute Unicode (UTF-16) pathname on Windows.\r\n           Mac (0x4D616320)     (Mac OS alias stored as a blob)\r\n           MacX(0x4D616358)     A file URL with UTF-8 encoding conforming to RFC 2396.\r\n        */\r\n        uint8 PlatformCode[4];\r\n        /*\r\n        This field stores the number of 512-byte sectors needed to store the parent\r\n        hard disk locator.\r\n        */\r\n        uint32 PlatformDataSpace;\r\n        /*\r\n        This field stores the actual length of the parent hard disk locator in bytes.\r\n        */\r\n        uint32 PlatformDataLength;\r\n        /*\r\n        This field must be set to zero.\r\n        */\r\n        uint32 Reserved;\r\n        /*\r\n        This field stores the absolute file offset in bytes where the platform\r\n        specific file locator data is stored.\r\n        */\r\n        uint64 PlatformDataOffset;\r\n        /*\r\n        This field stores the absolute file offset in bytes where the platform\r\n        specific file locator data is stored.\r\n        */\r\n        } ParentLocatorEntries[8];\r\n    /*\r\n    This must be initialized to zeroes.\r\n    */\r\n    char Reserved[256];\r\n    } VHD_DynamicDiskHeader;\r\n\r\n#define VHD_BAT_FREE_ENTRY (0xFFFFFFFF)\r\n#define VHD_DATA_BLOCK_ALIGNMENT ((uint64)4096)    /* Optimum when underlying storage has 4k sectors */\r\n\r\n#define VHD_DT_Fixed                 2  /* Fixed hard disk */\r\n#define VHD_DT_Dynamic               3  /* Dynamic hard disk */\r\n#define VHD_DT_Differencing          4  /* Differencing hard disk */\r\n\r\n#define VHD_Internal_SectorSize     512\r\n\r\ntypedef struct VHD_IOData *VHDHANDLE;\r\n\r\nstatic t_stat ReadFilePosition(FILE *File, void *buf, size_t bufsize, uint32 *bytesread, uint64 position)\r\n{\r\nuint32 err = sim_fseeko (File, (t_offset)position, SEEK_SET);\r\nsize_t i;\r\n\r\nif (bytesread)\r\n    *bytesread = 0;\r\nif (!err) {\r\n    i = fread (buf, 1, bufsize, File);\r\n    if (bytesread)\r\n        *bytesread = (uint32)i;\r\n    err = ferror (File);\r\n    }\r\nreturn (err ? SCPE_IOERR : SCPE_OK);\r\n}\r\n\r\nstatic t_stat WriteFilePosition(FILE *File, void *buf, size_t bufsize, uint32 *byteswritten, uint64 position)\r\n{\r\nuint32 err = sim_fseeko (File, (t_offset)position, SEEK_SET);\r\nsize_t i;\r\n\r\nif (byteswritten)\r\n    *byteswritten = 0;\r\nif (!err) {\r\n    i = fwrite (buf, 1, bufsize, File);\r\n    if (byteswritten)\r\n        *byteswritten = (uint32)i;\r\n    err = ferror (File);\r\n    }\r\nreturn (err ? SCPE_IOERR : SCPE_OK);\r\n}\r\n\r\nstatic uint32\r\nCalculateVhdFooterChecksum(void *data,\r\n                           size_t size)\r\n{\r\nuint32 sum = 0;\r\nuint8 *c = (uint8 *)data;\r\n\r\nwhile (size--)\r\n    sum += *c++;\r\nreturn ~sum;\r\n}\r\n\r\n#if defined(_WIN32) || defined (__ALPHA) || defined (__ia64) || defined (VMS)\r\n#ifndef __BYTE_ORDER__\r\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\r\n#endif\r\n#endif\r\n#ifndef __BYTE_ORDER__\r\n#define __BYTE_ORDER__ UNKNOWN\r\n#endif\r\n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\r\nstatic uint64\r\nNtoHll(uint64 value)\r\n{\r\nuint8 *l = (uint8 *)&value;\r\nuint64 highresult = (uint64)l[3] | ((uint64)l[2]<<8) | ((uint64)l[1]<<16) | ((uint64)l[0]<<24);\r\nuint32 lowresult = (uint64)l[7] | ((uint64)l[6]<<8) | ((uint64)l[5]<<16) | ((uint64)l[4]<<24);\r\nreturn (highresult << 32) | lowresult;\r\n}\r\n#elif  __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\r\nstatic uint64\r\nNtoHll(uint64 value)\r\n{\r\nreturn value;\r\n}\r\n#else\r\nstatic uint32\r\nNtoHl(uint32 value)\r\n{\r\nuint8 *l = (uint8 *)&value;\r\n\r\nif (sim_end)\r\n    return l[3] | (l[2]<<8) | (l[1]<<16) | (l[0]<<24);\r\nreturn value;\r\n}\r\n\r\nstatic uint64\r\nNtoHll(uint64 value)\r\n{\r\nuint8 *l = (uint8 *)&value;\r\n\r\nif (sim_end) {\r\n    uint64 highresult = l[3] | (l[2]<<8) | (l[1]<<16) | (l[0]<<24);\r\n    uint32 lowresult = l[7] | (l[6]<<8) | (l[5]<<16) | (l[4]<<24);\r\n    return (highresult << 32) | lowresult;\r\n    }\r\nreturn value;\r\n}\r\n#endif\r\n\r\nstatic\r\nint\r\nGetVHDFooter(const char *szVHDPath,\r\n             VHD_Footer *sFooter,\r\n             VHD_DynamicDiskHeader *sDynamic,\r\n             uint32 **aBAT,\r\n             uint32 *ModifiedTimeStamp,\r\n             char *szParentVHDPath,\r\n             size_t ParentVHDPathSize)\r\n{\r\nFILE *File = NULL;\r\nuint64 position;\r\nuint32 sum, saved_sum;\r\nint Return = 0;\r\nVHD_Footer sHeader;\r\nstruct stat statb;\r\n\r\nmemset(sFooter, '\\0', sizeof(*sFooter));\r\nif (sDynamic)\r\n    memset(sDynamic, '\\0', sizeof(*sDynamic));\r\nif (aBAT)\r\n    *aBAT = NULL;\r\nFile = sim_fopen (szVHDPath, \"rb\");\r\nif (!File) {\r\n    Return = errno;\r\n    goto Return_Cleanup;\r\n    }\r\nif (ModifiedTimeStamp) {\r\n    if (fstat (fileno (File), &statb)) {\r\n        Return = errno;\r\n        goto Return_Cleanup;\r\n        }\r\n    else\r\n        *ModifiedTimeStamp = NtoHl ((uint32)(statb.st_mtime-946684800));\r\n    }\r\nposition = sim_fsize_ex (File);\r\nif (((int64)position) == -1) {\r\n    Return = errno;\r\n    goto Return_Cleanup;\r\n    }\r\nposition -= sizeof(*sFooter);\r\nif (ReadFilePosition(File,\r\n                     sFooter,\r\n                     sizeof(*sFooter),\r\n                     NULL,\r\n                     position)) {\r\n    Return = errno;\r\n    goto Return_Cleanup;\r\n    }\r\nsaved_sum = NtoHl(sFooter->Checksum);\r\nsFooter->Checksum = 0;\r\nsum = CalculateVhdFooterChecksum(sFooter, sizeof(*sFooter));\r\nsFooter->Checksum = NtoHl(saved_sum);\r\nif ((sum != saved_sum) || (memcmp(\"conectix\", sFooter->Cookie, sizeof(sFooter->Cookie)))) {\r\n    Return = EINVAL;                                    /* File Corrupt */\r\n    goto Return_Cleanup;\r\n    }\r\nif (ReadFilePosition(File,\r\n                     &sHeader,\r\n                     sizeof(sHeader),\r\n                     NULL,\r\n                     (uint64)0)) {\r\n    Return = errno;\r\n    goto Return_Cleanup;\r\n    }\r\nif ((NtoHl(sFooter->DiskType) != VHD_DT_Dynamic) &&\r\n    (NtoHl(sFooter->DiskType) != VHD_DT_Differencing) &&\r\n    (NtoHl(sFooter->DiskType) != VHD_DT_Fixed)) {\r\n    Return = EINVAL;                                    /* File Corrupt */\r\n    goto Return_Cleanup;\r\n    }\r\nif (((NtoHl(sFooter->DiskType) == VHD_DT_Dynamic) ||\r\n     (NtoHl(sFooter->DiskType) == VHD_DT_Differencing)) &&\r\n     memcmp(sFooter, &sHeader, sizeof(sHeader))) {\r\n    Return = EINVAL;                                    /* File Corrupt */\r\n    goto Return_Cleanup;\r\n    }\r\nif ((sDynamic) &&\r\n    ((NtoHl(sFooter->DiskType) == VHD_DT_Dynamic) ||\r\n     (NtoHl(sFooter->DiskType) == VHD_DT_Differencing))) {\r\n    if (ReadFilePosition(File,\r\n                         sDynamic,\r\n                         sizeof (*sDynamic),\r\n                         NULL,\r\n                         NtoHll (sFooter->DataOffset))) {\r\n        Return = errno;\r\n        goto Return_Cleanup;\r\n        }\r\n    saved_sum = NtoHl (sDynamic->Checksum);\r\n    sDynamic->Checksum = 0;\r\n    sum = CalculateVhdFooterChecksum (sDynamic, sizeof(*sDynamic));\r\n    sDynamic->Checksum = NtoHl (saved_sum);\r\n    if ((sum != saved_sum) || (memcmp (\"cxsparse\", sDynamic->Cookie, sizeof (sDynamic->Cookie)))) {\r\n        Return = errno;\r\n        goto Return_Cleanup;\r\n        }\r\n    if (aBAT) {\r\n        *aBAT = (uint32*) calloc(1, VHD_Internal_SectorSize * ((sizeof(**aBAT) * NtoHl(sDynamic->MaxTableEntries) + VHD_Internal_SectorSize - 1) / VHD_Internal_SectorSize));\r\n        if (ReadFilePosition(File,\r\n                             *aBAT,\r\n                             sizeof (**aBAT) * NtoHl(sDynamic->MaxTableEntries),\r\n                             NULL,\r\n                             NtoHll (sDynamic->TableOffset))) {\r\n            Return = EINVAL;                            /* File Corrupt */\r\n            goto Return_Cleanup;\r\n            }\r\n        }\r\n    if (szParentVHDPath && ParentVHDPathSize) {\r\n        VHD_Footer sParentFooter;\r\n\r\n        memset (szParentVHDPath, '\\0', ParentVHDPathSize);\r\n        if (NtoHl (sFooter->DiskType) == VHD_DT_Differencing) {\r\n            size_t i, j;\r\n\r\n            for (j=0; j<8; ++j) {\r\n                uint8 *Pdata;\r\n                uint32 PdataSize;\r\n                char ParentName[512];\r\n                char CheckPath[512];\r\n                uint32 ParentModificationTime;\r\n\r\n                if ('\\0' == sDynamic->ParentLocatorEntries[j].PlatformCode[0])\r\n                    continue;\r\n                memset (ParentName, '\\0', sizeof(ParentName));\r\n                memset (CheckPath, '\\0', sizeof(CheckPath));\r\n                PdataSize = NtoHl(sDynamic->ParentLocatorEntries[j].PlatformDataSpace);\r\n                Pdata = (uint8*) calloc (1, PdataSize+2);\r\n                if (!Pdata)\r\n                    continue;\r\n                if (ReadFilePosition(File,\r\n                                     Pdata,\r\n                                     PdataSize,\r\n                                     NULL,\r\n                                     NtoHll (sDynamic->ParentLocatorEntries[j].PlatformDataOffset))) {\r\n                    free (Pdata);\r\n                    continue;\r\n                    }\r\n                for (i=0; i<NtoHl(sDynamic->ParentLocatorEntries[j].PlatformDataLength); i+=2)\r\n                    if ((Pdata[i] == '\\0') && (Pdata[i+1] == '\\0')) {\r\n                        ParentName[i/2] = '\\0';\r\n                        break;\r\n                        }\r\n                    else\r\n                        ParentName[i/2] = Pdata[i] ? Pdata[i] : Pdata[i+1];\r\n                free (Pdata);\r\n                memset (CheckPath, 0, sizeof (CheckPath));\r\n                if (0 == memcmp (sDynamic->ParentLocatorEntries[j].PlatformCode, \"W2ku\", 4))\r\n                    strlcpy (CheckPath, ParentName, sizeof (CheckPath));\r\n                else\r\n                    if (0 == memcmp (sDynamic->ParentLocatorEntries[j].PlatformCode, \"W2ru\", 4)) {\r\n                        const char *c;\r\n\r\n                        if ((c = strrchr (szVHDPath, '\\\\'))) {\r\n                            memcpy (CheckPath, szVHDPath, c-szVHDPath+1);\r\n                            strlcat (CheckPath, ParentName, sizeof (CheckPath));\r\n                            }\r\n                        }\r\n                VhdPathToHostPath (CheckPath, CheckPath, sizeof (CheckPath));\r\n                if (0 == GetVHDFooter(CheckPath,\r\n                                      &sParentFooter,\r\n                                      NULL,\r\n                                      NULL,\r\n                                      &ParentModificationTime,\r\n                                      NULL,\r\n                                      0)) {\r\n                    if ((0 == memcmp (sDynamic->ParentUniqueID, sParentFooter.UniqueID, sizeof (sParentFooter.UniqueID))) &&\r\n                        ((sDynamic->ParentTimeStamp == ParentModificationTime) ||\r\n                         ((NtoHl(sDynamic->ParentTimeStamp)-NtoHl(ParentModificationTime)) == 3600) ||\r\n                         (sim_switches & SWMASK ('O')))) {\r\n                         memset (szParentVHDPath, 0, ParentVHDPathSize);\r\n                         strlcpy (szParentVHDPath, CheckPath, ParentVHDPathSize);\r\n                        }\r\n                    else {\r\n                        if (0 != memcmp (sDynamic->ParentUniqueID, sParentFooter.UniqueID, sizeof (sParentFooter.UniqueID)))\r\n                            sim_printf (\"Error Invalid Parent VHD '%s' for Differencing VHD: %s\\n\", CheckPath, szVHDPath);\r\n                        else\r\n                            sim_printf (\"Error Parent VHD '%s' has been modified since Differencing VHD: %s was created\\n\", CheckPath, szVHDPath);\r\n                        Return = EINVAL;                /* File Corrupt/Invalid */\r\n                        }\r\n                    break;\r\n                    }\r\n                else {\r\n                    struct stat statb;\r\n\r\n                    if (0 == stat (CheckPath, &statb)) {\r\n                        sim_printf (\"Parent VHD '%s' corrupt for Differencing VHD: %s\\n\", CheckPath, szVHDPath);\r\n                        Return = EBADF;                /* File Corrupt/Invalid */\r\n                        break;\r\n                        }\r\n                    }\r\n                }\r\n            if (!*szParentVHDPath) {\r\n                if (Return != EINVAL)                   /* File Not Corrupt? */\r\n                    sim_printf (\"Missing Parent VHD for Differencing VHD: %s\\n\", szVHDPath);\r\n                Return = EBADF;\r\n                }\r\n            }\r\n        }\r\n    }\r\nReturn_Cleanup:\r\nif (File)\r\n    fclose(File);\r\nif (aBAT && (0 != Return)) {\r\n    free (*aBAT);\r\n    *aBAT = NULL;\r\n    }\r\nreturn errno = Return;\r\n}\r\n\r\nstruct VHD_IOData {\r\n    VHD_Footer Footer;\r\n    VHD_DynamicDiskHeader Dynamic;\r\n    uint32 *BAT;\r\n    FILE *File;\r\n    int Writable;\r\n    char VHDPath[512];\r\n    char ParentVHDPath[512];\r\n    struct VHD_IOData *Parent;\r\n    };\r\n\r\nstatic t_stat sim_vhd_disk_implemented (void)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_set_dtype (FILE *f, const char *dtype, uint32 SectorSize, uint32 xfer_encode_size, uint32 media_id, const char *device_name, uint32 data_width, DRVTYP *drvtyp)\r\n{\r\nVHDHANDLE hVHD  = (VHDHANDLE)f;\r\nint Status = 0;\r\nstruct stat statb;\r\n\r\nif (fstat (fileno (f), &statb))\r\n    memset (&statb, 0, sizeof (statb));\r\nmemset (hVHD->Footer.DriveType, '\\0', sizeof hVHD->Footer.DriveType);\r\nmemcpy (hVHD->Footer.DriveType, dtype, ((1+strlen (dtype)) < sizeof (hVHD->Footer.DriveType)) ? (1+strlen (dtype)) : sizeof (hVHD->Footer.DriveType));\r\nhVHD->Footer.DriveSectorSize = NtoHl (SectorSize);\r\nhVHD->Footer.DriveElementEncodingSize = NtoHl (xfer_encode_size);\r\nif (hVHD->Footer.CreatingSimulator[0] == 0) {\r\n    memset (hVHD->Footer.CreatingSimulator, 0, sizeof (hVHD->Footer.CreatingSimulator));\r\n    strlcpy ((char *)hVHD->Footer.CreatingSimulator, sim_name, sizeof (hVHD->Footer.CreatingSimulator));\r\n    }\r\nhVHD->Footer.MediaId = NtoHl (media_id);\r\nif (device_name) {\r\n    memset (hVHD->Footer.DeviceName, 0, sizeof (hVHD->Footer.DeviceName));\r\n    strlcpy ((char *)hVHD->Footer.DeviceName, device_name, sizeof (hVHD->Footer.DeviceName));\r\n    }\r\nhVHD->Footer.DataWidth = NtoHl (data_width);\r\nhVHD->Footer.DiskGeometry = NtoHl (sim_disk_drvtype_geometry (drvtyp, (uint32)(NtoHll (hVHD->Footer.CurrentSize) / NtoHl (hVHD->Footer.DriveSectorSize))));\r\nhVHD->Footer.Checksum = 0;\r\nhVHD->Footer.Checksum = NtoHl (CalculateVhdFooterChecksum (&hVHD->Footer, sizeof(hVHD->Footer)));\r\n\r\nif (hVHD->Writable == 0) {\r\n    fclose (hVHD->File);\r\n    hVHD->File = sim_fopen (hVHD->VHDPath, \"rb+\");\r\n    }\r\nif (NtoHl (hVHD->Footer.DiskType) == VHD_DT_Fixed) {\r\n    if (WriteFilePosition(hVHD->File,\r\n                          &hVHD->Footer,\r\n                          sizeof(hVHD->Footer),\r\n                          NULL,\r\n                          NtoHll (hVHD->Footer.CurrentSize)))\r\n        Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nelse {\r\n    uint64 position;\r\n\r\n    position = sim_fsize_ex (hVHD->File);\r\n    if (((int64)position) == -1) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    position -= sizeof(hVHD->Footer);\r\n    /* Update both copies on a dynamic disk */\r\n    if (WriteFilePosition(hVHD->File,\r\n                          &hVHD->Footer,\r\n                          sizeof(hVHD->Footer),\r\n                          NULL,\r\n                          (uint64)0)) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    if (WriteFilePosition(hVHD->File,\r\n                          &hVHD->Footer,\r\n                          sizeof(hVHD->Footer),\r\n                          NULL,\r\n                          position)) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    }\r\nCleanup_Return:\r\nif (Status)\r\n    return SCPE_IOERR;\r\nelse {\r\n    fclose (hVHD->File);\r\n    sim_set_file_times (hVHD->VHDPath, statb.st_atime, statb.st_mtime);\r\n    hVHD->File = sim_fopen (hVHD->VHDPath, hVHD->Writable ? \"rb+\" : \"rb\");\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic const char *sim_vhd_disk_get_dtype (FILE *f, uint32 *SectorSize, uint32 *xfer_encode_size, char sim_name[64], time_t *creation_time, uint32 *media_id, char device_name[16], uint32 *data_width)\r\n{\r\nVHDHANDLE hVHD  = (VHDHANDLE)f;\r\n\r\nif (SectorSize)\r\n    *SectorSize = NtoHl (hVHD->Footer.DriveSectorSize);\r\nif (xfer_encode_size)\r\n    *xfer_encode_size = NtoHl (hVHD->Footer.DriveElementEncodingSize);\r\nif (sim_name)\r\n    memcpy (sim_name, hVHD->Footer.CreatingSimulator, 64);\r\nif (creation_time)\r\n    *creation_time = (time_t)NtoHl (hVHD->Footer.TimeStamp) + 946684800;\r\nif (media_id)\r\n    *media_id = NtoHl (hVHD->Footer.MediaId);\r\nif (device_name)\r\n    memcpy (device_name, hVHD->Footer.DeviceName, 16);\r\nif (data_width)\r\n    *data_width = NtoHl (hVHD->Footer.DataWidth);\r\nreturn (char *)(&hVHD->Footer.DriveType[0]);\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_open (const char *szVHDPath, const char *DesiredAccess)\r\n    {\r\n    VHDHANDLE hVHD = (VHDHANDLE) calloc (1, sizeof(*hVHD));\r\n    int NeedUpdate = FALSE;\r\n    int Status;\r\n\r\n    if (!hVHD)\r\n        return (FILE *)hVHD;\r\n    Status = GetVHDFooter (szVHDPath,\r\n                           &hVHD->Footer,\r\n                           &hVHD->Dynamic,\r\n                           &hVHD->BAT,\r\n                           NULL,\r\n                           hVHD->ParentVHDPath,\r\n                           sizeof (hVHD->ParentVHDPath));\r\n    if (Status)\r\n        goto Cleanup_Return;\r\n    if (NtoHl (hVHD->Footer.DiskType) == VHD_DT_Differencing) {\r\n        uint32 ParentModifiedTimeStamp;\r\n        VHD_Footer ParentFooter;\r\n        VHD_DynamicDiskHeader ParentDynamic;\r\n\r\n        hVHD->Parent = (VHDHANDLE)sim_vhd_disk_open (hVHD->ParentVHDPath, \"rb\");\r\n        if (!hVHD->Parent) {\r\n            Status = errno;\r\n            goto Cleanup_Return;\r\n            }\r\n        Status = GetVHDFooter (hVHD->ParentVHDPath,\r\n                               &ParentFooter,\r\n                               &ParentDynamic,\r\n                               NULL,\r\n                               &ParentModifiedTimeStamp,\r\n                               NULL,\r\n                               0);\r\n        if (Status)\r\n            goto Cleanup_Return;\r\n        if ((0 != memcmp (hVHD->Dynamic.ParentUniqueID, ParentFooter.UniqueID, sizeof (ParentFooter.UniqueID))) ||\r\n            (ParentModifiedTimeStamp != hVHD->Dynamic.ParentTimeStamp)) {\r\n            if (sim_switches & SWMASK ('O')) {                      /* OVERRIDE consistency checks? */\r\n                if ((sim_switches & SWMASK ('U')) &&                /* FIX (UPDATE) consistency checks AND */\r\n                    (strchr (DesiredAccess, '+'))) {                /* open for write/update? */\r\n                    memcpy (hVHD->Dynamic.ParentUniqueID, ParentFooter.UniqueID, sizeof (ParentFooter.UniqueID));\r\n                    hVHD->Dynamic.ParentTimeStamp = ParentModifiedTimeStamp;\r\n                    hVHD->Dynamic.Checksum = 0;\r\n                    hVHD->Dynamic.Checksum = NtoHl (CalculateVhdFooterChecksum (&hVHD->Dynamic, sizeof(hVHD->Dynamic)));\r\n                    NeedUpdate = TRUE;\r\n                    }\r\n                }\r\n            else {\r\n                Status = EBADF;\r\n                goto Cleanup_Return;\r\n                }\r\n            }\r\n        }\r\n    if (hVHD->Footer.SavedState) {\r\n        Status = EAGAIN;                                /* Busy */\r\n        goto Cleanup_Return;\r\n        }\r\n    hVHD->File = sim_fopen (szVHDPath, DesiredAccess);\r\n    if (!hVHD->File) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    else {\r\n        strlcpy (hVHD->VHDPath, szVHDPath, sizeof (hVHD->VHDPath));\r\n        hVHD->Writable = (strchr (DesiredAccess, 'w') || strchr (DesiredAccess, '+'));\r\n        }\r\nCleanup_Return:\r\n    if (Status) {\r\n        sim_vhd_disk_close ((FILE *)hVHD);\r\n        hVHD = NULL;\r\n        }\r\n    else {\r\n        if (NeedUpdate) {                               /* Update Differencing Disk Header? */\r\n            if (WriteFilePosition(hVHD->File,\r\n                                  &hVHD->Dynamic,\r\n                                  sizeof (hVHD->Dynamic),\r\n                                  NULL,\r\n                                  NtoHll (hVHD->Footer.DataOffset))) {\r\n                sim_vhd_disk_close ((FILE *)hVHD);\r\n                hVHD = NULL;\r\n                }\r\n            }\r\n        }\r\n    errno = Status;\r\n    return (FILE *)hVHD;\r\n    }\r\n\r\nstatic t_stat\r\nWriteVirtualDiskSectors(VHDHANDLE hVHD,\r\n                        uint8 *buf,\r\n                        t_seccnt sects,\r\n                        t_seccnt *sectswritten,\r\n                        uint32 SectorSize,\r\n                        t_lba lba);\r\n\r\nstatic FILE *sim_vhd_disk_merge (const char *szVHDPath, char **ParentVHD)\r\n    {\r\n    VHDHANDLE hVHD = (VHDHANDLE) calloc (1, sizeof(*hVHD));\r\n    VHDHANDLE Parent = NULL;\r\n    int Status;\r\n    uint32 SectorSize, SectorsPerBlock, BlockSize, BlockNumber, BitMapBytes, BitMapSectors, BlocksToMerge, NeededBlock;\r\n    uint64 BlockOffset;\r\n    uint32 BytesRead;\r\n    t_seccnt SectorsWritten;\r\n    void *BlockData = NULL;\r\n\r\n    if (!hVHD)\r\n        return (FILE *)hVHD;\r\n    if (0 != (Status = GetVHDFooter (szVHDPath,\r\n                                     &hVHD->Footer,\r\n                                     &hVHD->Dynamic,\r\n                                     &hVHD->BAT,\r\n                                     NULL,\r\n                                     hVHD->ParentVHDPath,\r\n                                     sizeof (hVHD->ParentVHDPath))))\r\n        goto Cleanup_Return;\r\n    if (NtoHl (hVHD->Footer.DiskType) != VHD_DT_Differencing) {\r\n        Status = EINVAL;\r\n        goto Cleanup_Return;\r\n        }\r\n    if (hVHD->Footer.SavedState) {\r\n        Status = EAGAIN;                                /* Busy */\r\n        goto Cleanup_Return;\r\n        }\r\n    SectorSize = 512;\r\n    BlockSize = NtoHl (hVHD->Dynamic.BlockSize);\r\n    BlockData = malloc (BlockSize*SectorSize);\r\n    if (NULL == BlockData) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    Parent = (VHDHANDLE)sim_vhd_disk_open (hVHD->ParentVHDPath, \"rb+\");\r\n    if (!Parent) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    hVHD->File = sim_fopen (szVHDPath, \"rb\");\r\n    if (!hVHD->File) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n    else\r\n        strlcpy (hVHD->VHDPath, szVHDPath, sizeof (hVHD->VHDPath));\r\n    SectorsPerBlock = NtoHl (hVHD->Dynamic.BlockSize)/SectorSize;\r\n    BitMapBytes = (7+(NtoHl (hVHD->Dynamic.BlockSize)/SectorSize))/8;\r\n    BitMapSectors = (BitMapBytes+SectorSize-1)/SectorSize;\r\n    for (BlockNumber=BlocksToMerge=0; BlockNumber< NtoHl (hVHD->Dynamic.MaxTableEntries); ++BlockNumber) {\r\n        if (hVHD->BAT[BlockNumber] == VHD_BAT_FREE_ENTRY)\r\n            continue;\r\n        ++BlocksToMerge;\r\n        }\r\n    sim_messagef (SCPE_OK, \"Merging %s\\ninto %s\\n\", szVHDPath, hVHD->ParentVHDPath);\r\n    for (BlockNumber=NeededBlock=0; BlockNumber < NtoHl (hVHD->Dynamic.MaxTableEntries); ++BlockNumber) {\r\n        uint32 BlockSectors = SectorsPerBlock;\r\n\r\n        if (hVHD->BAT[BlockNumber] == VHD_BAT_FREE_ENTRY)\r\n            continue;\r\n        ++NeededBlock;\r\n        BlockOffset = SectorSize*((uint64)(NtoHl (hVHD->BAT[BlockNumber]) + BitMapSectors));\r\n        if (((uint64)BlockNumber*SectorsPerBlock + BlockSectors) > ((uint64)NtoHll (hVHD->Footer.CurrentSize))/SectorSize)\r\n            BlockSectors = (uint32)(((uint64)NtoHll (hVHD->Footer.CurrentSize))/SectorSize - (BlockNumber*SectorsPerBlock));\r\n        if (ReadFilePosition(hVHD->File,\r\n                             BlockData,\r\n                             SectorSize*BlockSectors,\r\n                             &BytesRead,\r\n                             BlockOffset))\r\n            break;\r\n        if (WriteVirtualDiskSectors (Parent,\r\n                                     (uint8*)BlockData,\r\n                                     BlockSectors,\r\n                                     &SectorsWritten,\r\n                                     SectorSize,\r\n                                     SectorsPerBlock*BlockNumber))\r\n            break;\r\n        sim_messagef (SCPE_OK, \"Merged %dMB.  %d%% complete.\\r\", (int)((((float)NeededBlock)*SectorsPerBlock)*SectorSize/1000000), (int)((((float)NeededBlock)*100)/BlocksToMerge));\r\n        hVHD->BAT[BlockNumber] = VHD_BAT_FREE_ENTRY;\r\n        }\r\n    if (BlockNumber < NtoHl (hVHD->Dynamic.MaxTableEntries)) {\r\n        Status = errno;\r\n        }\r\n    else {\r\n        Status = 0;\r\n        sim_messagef (SCPE_OK, \"Merged %dMB.  100%% complete.\\n\", (int)((((float)NeededBlock)*SectorsPerBlock)*SectorSize/1000000));\r\n        fclose (hVHD->File);\r\n        hVHD->File = NULL;\r\n        (void)remove (szVHDPath);\r\n        *ParentVHD = (char*) malloc (strlen (hVHD->ParentVHDPath)+1);\r\n        strcpy (*ParentVHD, hVHD->ParentVHDPath);\r\n        }\r\nCleanup_Return:\r\n    free (BlockData);\r\n    if (hVHD->File)\r\n        fclose (hVHD->File);\r\n    if (Status) {\r\n        free (hVHD->BAT);\r\n        free (hVHD);\r\n        hVHD = NULL;\r\n        sim_vhd_disk_close ((FILE *)Parent);\r\n        }\r\n    else {\r\n        free (hVHD->BAT);\r\n        free (hVHD);\r\n        hVHD = Parent;\r\n        }\r\n    errno = Status;\r\n    return (FILE *)hVHD;\r\n    }\r\n\r\nstatic int sim_vhd_disk_close (FILE *f)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)f;\r\n\r\nif (NULL != hVHD) {\r\n    if (hVHD->Parent)\r\n        sim_vhd_disk_close ((FILE *)hVHD->Parent);\r\n    free (hVHD->BAT);\r\n    if (hVHD->File) {\r\n        fflush (hVHD->File);\r\n        fclose (hVHD->File);\r\n        }\r\n    free (hVHD);\r\n    return 0;\r\n    }\r\nreturn -1;\r\n}\r\n\r\nstatic void sim_vhd_disk_flush (FILE *f)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)f;\r\n\r\nif ((NULL != hVHD) && (hVHD->File))\r\n    fflush (hVHD->File);\r\n}\r\n\r\nstatic t_offset sim_vhd_disk_size (FILE *f)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)f;\r\n\r\nreturn (t_offset)(NtoHll (hVHD->Footer.CurrentSize));\r\n}\r\n\r\nstatic uint32 sim_vhd_CHS (FILE *f)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)f;\r\n\r\nreturn NtoHl (hVHD->Footer.DiskGeometry);\r\n}\r\n\r\nstatic const char *sim_vhd_disk_parent_path (FILE *f)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)f;\r\n\r\nreturn (const char *)(hVHD->ParentVHDPath);\r\n}\r\n\r\n#include <stdlib.h>\r\n#include <time.h>\r\nstatic void\r\n_rand_uuid_gen (void *uuidaddr)\r\n{\r\nint i;\r\nuint8 *b = (uint8 *)uuidaddr;\r\nuint32 timenow = (uint32)time (NULL);\r\n\r\nmemcpy (uuidaddr, &timenow, sizeof (timenow));\r\nsrand ((unsigned)timenow);\r\nfor (i=4; i<16; i++) {\r\n    b[i] = (uint8)rand();\r\n    }\r\n}\r\n\r\n#if defined (_WIN32)\r\nstatic void\r\nuuid_gen (void *uuidaddr)\r\n{\r\nstatic\r\nRPC_STATUS\r\n(RPC_ENTRY *UuidCreate_c) (void *);\r\n\r\nif (!UuidCreate_c) {\r\n    HINSTANCE hDll;\r\n    hDll = LoadLibraryA(\"rpcrt4.dll\");\r\n    UuidCreate_c = (RPC_STATUS (RPC_ENTRY *) (void *))GetProcAddress(hDll, \"UuidCreate\");\r\n    }\r\nif (UuidCreate_c)\r\n    UuidCreate_c(uuidaddr);\r\nelse\r\n    _rand_uuid_gen (uuidaddr);\r\n}\r\n#elif defined (SIM_HAVE_DLOPEN)\r\nstatic void\r\nuuid_gen (void *uuidaddr)\r\n{\r\nvoid (*uuid_generate_c) (void *) = NULL;\r\nvoid *handle;\r\n\r\n    handle = dlopen(\"libuuid.\" __STR(SIM_DLOPEN_EXTENSION), RTLD_NOW|RTLD_GLOBAL);\r\n    if (handle)\r\n        uuid_generate_c = (void (*)(void *))((size_t)dlsym(handle, \"uuid_generate\"));\r\n    if (uuid_generate_c)\r\n        uuid_generate_c(uuidaddr);\r\n    else\r\n        _rand_uuid_gen (uuidaddr);\r\n    if (handle)\r\n        dlclose(handle);\r\n}\r\n#else\r\nstatic void\r\nuuid_gen (void *uuidaddr)\r\n{\r\n_rand_uuid_gen (uuidaddr);\r\n}\r\n#endif\r\n\r\n/* CHS Calculation */\r\nstatic uint32 sim_SectorsToCHS (uint32 totalSectors)\r\n{\r\nuint32 cylinders;                                          /* Number of cylinders present on the disk */\r\nuint32 heads;                                              /* Number of heads present on the disk */\r\nuint32 sectorsPerTrack;                                    /* Sectors per track on the disk */\r\nuint32 cylinderTimesHeads;                                 /* Cylinders x heads */\r\n\r\nif (totalSectors > 65535 * 16 * 255)\r\n    totalSectors = 65535 * 16 * 255;\r\n\r\nif (totalSectors >= 65535 * 16 * 63) {\r\n    sectorsPerTrack = 255;\r\n    heads = 16;\r\n    cylinderTimesHeads = totalSectors / sectorsPerTrack;\r\n    }\r\nelse {\r\n    sectorsPerTrack = 17;\r\n    cylinderTimesHeads = totalSectors / sectorsPerTrack;\r\n\r\n    heads = (cylinderTimesHeads + 1023) / 1024;\r\n\r\n    if (heads < 4)\r\n        heads = 4;\r\n    if (cylinderTimesHeads >= (heads * 1024) || heads > 16) {\r\n        sectorsPerTrack = 31;\r\n        heads = 16;\r\n        cylinderTimesHeads = totalSectors / sectorsPerTrack;\r\n        }\r\n    if (cylinderTimesHeads >= (heads * 1024)) {\r\n        sectorsPerTrack = 63;\r\n        heads = 16;\r\n        cylinderTimesHeads = totalSectors / sectorsPerTrack;\r\n        }\r\n    }\r\ncylinders = (totalSectors + sectorsPerTrack * heads - 1) / (sectorsPerTrack * heads);\r\nreturn (cylinders<<16) | (heads<<8) | sectorsPerTrack;\r\n}\r\n\r\nuint32 sim_disk_drvtype_geometry (DRVTYP *drvtyp, uint32 totalSectors)\r\n{\r\nif ((drvtyp == NULL) || (0xFFFF10FF == sim_SectorsToCHS (totalSectors)) ||\r\n    ((drvtyp->sect * drvtyp->surf * drvtyp->cyl) < totalSectors))\r\n    return sim_SectorsToCHS (totalSectors);\r\nreturn ((drvtyp->cyl << 16) | (drvtyp->surf << 8) | drvtyp->sect);\r\n}\r\n\r\n\r\nstatic VHDHANDLE\r\nsim_CreateVirtualDisk(const char *szVHDPath,\r\n                      uint32 SizeInSectors,\r\n                      uint32 BlockSize,\r\n                      t_bool bFixedVHD,\r\n                      VHD_Footer *ParentFooter,\r\n                      DRVTYP *drvtyp)\r\n{\r\nVHD_Footer Footer;\r\nVHD_DynamicDiskHeader Dynamic;\r\nuint32 *BAT = NULL;\r\ntime_t now;\r\nuint32 i;\r\nFILE *File = NULL;\r\nuint32 Status = 0;\r\nuint32 BytesPerSector = 512;\r\nuint64 SizeInBytes = ((uint64)SizeInSectors) * BytesPerSector;\r\nuint64 TableOffset;\r\nuint32 MaxTableEntries;\r\nVHDHANDLE hVHD = NULL;\r\n\r\nif (SizeInBytes > ((uint64)(1024 * 1024 * 1024)) * 2040) {\r\n    Status = EFBIG;\r\n    goto Cleanup_Return;\r\n    }\r\nFile = sim_fopen (szVHDPath, \"rb\");\r\nif (File) {\r\n    fclose (File);\r\n    File = NULL;\r\n    Status = EEXIST;\r\n    goto Cleanup_Return;\r\n    }\r\nFile = sim_fopen (szVHDPath, \"wb\");\r\nif (!File) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\n\r\nmemset (&Footer, 0, sizeof(Footer));\r\nif (ParentFooter)                                               /* If provided */\r\n    Footer = *ParentFooter;                                     /* Inherit Footer contents from Parent */\r\nFooter.Checksum = 0;\r\nmemcpy (Footer.Cookie, \"conectix\", 8);\r\nFooter.Features = NtoHl (0x00000002);;\r\nFooter.FileFormatVersion = NtoHl (0x00010000);;\r\nFooter.DataOffset = NtoHll (bFixedVHD ? ((long long)-1) : (long long)(sizeof(Footer)));\r\ntime (&now);\r\nFooter.TimeStamp = NtoHl ((uint32)(now - 946684800));\r\nmemcpy (Footer.CreatorApplication, \"simh\", 4);\r\nFooter.CreatorVersion = NtoHl (0x00040000);\r\nmemcpy (Footer.CreatorHostOS, \"Wi2k\", 4);\r\nFooter.OriginalSize = NtoHll (SizeInBytes);\r\nFooter.CurrentSize = NtoHll (SizeInBytes);\r\nuuid_gen (Footer.UniqueID);\r\nFooter.DiskType = NtoHl (bFixedVHD ? VHD_DT_Fixed : VHD_DT_Dynamic);\r\nif (ParentFooter == NULL)\r\n    Footer.DiskGeometry = NtoHl (sim_disk_drvtype_geometry (drvtyp, (uint32)(SizeInBytes / BytesPerSector)));\r\nFooter.Checksum = NtoHl (CalculateVhdFooterChecksum(&Footer, sizeof(Footer)));\r\n\r\nif (bFixedVHD) {\r\n    if (WriteFilePosition(File,\r\n                          &Footer,\r\n                          sizeof(Footer),\r\n                          NULL,\r\n                          SizeInBytes))\r\n        Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\n\r\n/* Dynamic Disk */\r\nmemset (&Dynamic, 0, sizeof(Dynamic));\r\nmemcpy (Dynamic.Cookie, \"cxsparse\", 8);\r\nDynamic.DataOffset = NtoHll ((uint64)0xFFFFFFFFFFFFFFFFLL);\r\nTableOffset = NtoHll(Footer.DataOffset)+sizeof(Dynamic);\r\nDynamic.TableOffset = NtoHll (TableOffset);\r\nDynamic.HeaderVersion = NtoHl (0x00010000);\r\nif (0 == BlockSize)\r\n    BlockSize = 2*1024*1024;\r\nDynamic.BlockSize = NtoHl (BlockSize);\r\nMaxTableEntries = (uint32)((SizeInBytes+BlockSize-1)/BlockSize);\r\nDynamic.MaxTableEntries = NtoHl (MaxTableEntries);\r\nDynamic.Checksum = NtoHl (CalculateVhdFooterChecksum(&Dynamic, sizeof(Dynamic)));\r\nBAT = (uint32*) malloc (BytesPerSector*((MaxTableEntries*sizeof(*BAT)+BytesPerSector-1)/BytesPerSector));\r\nmemset (BAT, 0, BytesPerSector*((MaxTableEntries*sizeof(*BAT)+BytesPerSector-1)/BytesPerSector));\r\nfor (i=0; i<MaxTableEntries; ++i)\r\n    BAT[i] = VHD_BAT_FREE_ENTRY;\r\n\r\nif (WriteFilePosition(File,\r\n                      &Footer,\r\n                      sizeof(Footer),\r\n                      NULL,\r\n                      0)) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (WriteFilePosition(File,\r\n                      &Dynamic,\r\n                      sizeof(Dynamic),\r\n                      NULL,\r\n                      NtoHll(Footer.DataOffset))) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (WriteFilePosition(File,\r\n                      BAT,\r\n                      BytesPerSector*((MaxTableEntries*sizeof(*BAT)+BytesPerSector-1)/BytesPerSector),\r\n                      NULL,\r\n                      NtoHll(Dynamic.TableOffset))) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (WriteFilePosition(File,\r\n                      &Footer,\r\n                      sizeof(Footer),\r\n                      NULL,\r\n                      NtoHll(Dynamic.TableOffset)+BytesPerSector*((MaxTableEntries*sizeof(*BAT)+BytesPerSector-1)/BytesPerSector))) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\n\r\nCleanup_Return:\r\nfree (BAT);\r\nif (File)\r\n    fclose (File);\r\nif (Status) {\r\n    if (Status != EEXIST)\r\n        (void)remove (szVHDPath);\r\n    }\r\nelse {\r\n    hVHD = (VHDHANDLE)sim_vhd_disk_open (szVHDPath, \"rb+\");\r\n    if (!hVHD)\r\n        Status = errno;\r\n    }\r\nerrno = Status;\r\nreturn hVHD;\r\n}\r\n\r\n#if defined(__CYGWIN__) || defined(VMS) || defined(__APPLE__) || defined(__linux) || defined(__linux__) || defined(__unix__)\r\n#include <unistd.h>\r\n#endif\r\nstatic void\r\nExpandToFullPath (const char *szFileSpec,\r\n                  char *szFullFileSpecBuffer,\r\n                  size_t BufferSize)\r\n{\r\nchar *c;\r\n#ifdef _WIN32\r\nfor (c = strchr (szFullFileSpecBuffer, '/'); c; c = strchr (szFullFileSpecBuffer, '/'))\r\n    *c = '\\\\';\r\nGetFullPathNameA (szFileSpec, (DWORD)BufferSize, szFullFileSpecBuffer, NULL);\r\nfor (c = strchr (szFullFileSpecBuffer, '\\\\'); c; c = strchr (szFullFileSpecBuffer, '\\\\'))\r\n    *c = '/';\r\n#else\r\nchar buffer[PATH_MAX];\r\nchar *wd = getcwd(buffer, PATH_MAX);\r\n\r\nif ((szFileSpec[0] != '/') || (strchr (szFileSpec, ':')))\r\n    snprintf (szFullFileSpecBuffer, BufferSize, \"%s/%s\", wd, szFileSpec);\r\nelse\r\n    strlcpy (szFullFileSpecBuffer, szFileSpec, BufferSize);\r\nif ((c = strstr (szFullFileSpecBuffer, \"]/\")))\r\n    memmove (c+1, c+2, strlen(c+2)+1);\r\nmemset (szFullFileSpecBuffer + strlen (szFullFileSpecBuffer), 0, BufferSize - strlen (szFullFileSpecBuffer));\r\n#endif\r\n}\r\n\r\nstatic char *\r\nHostPathToVhdPath (const char *szHostPath,\r\n                   char *szVhdPath,\r\n                   size_t VhdPathSize)\r\n{\r\nchar *c, *d;\r\n\r\nmemset (szVhdPath, 0, VhdPathSize);\r\nstrlcpy (szVhdPath, szHostPath, VhdPathSize-1);\r\nif ((szVhdPath[1] == ':') && islower(szVhdPath[0]))\r\n    szVhdPath[0] = toupper(szVhdPath[0]);\r\nszVhdPath[VhdPathSize-1] = '\\0';\r\nif ((c = strrchr (szVhdPath, ']'))) {\r\n    *c = '\\0';\r\n    if (!(d = strchr (szVhdPath, '[')))\r\n        return d;\r\n    *d = '/';\r\n    while ((d = strchr (d, '.')))\r\n        *d = '/';\r\n    *c = '/';\r\n    }\r\nwhile ((c = strchr (szVhdPath, '/')))\r\n    *c = '\\\\';\r\nfor (c = strstr (szVhdPath, \"\\\\.\\\\\"); c; c = strstr (szVhdPath, \"\\\\.\\\\\"))\r\n    memmove (c, c+2, strlen(c+2)+1);\r\nfor (c = strstr (szVhdPath, \"\\\\\\\\\"); c; c = strstr (szVhdPath, \"\\\\\\\\\"))\r\n    memmove (c, c+1, strlen(c+1)+1);\r\nwhile ((c = strstr (szVhdPath, \"\\\\..\\\\\"))) {\r\n    *c = '\\0';\r\n    d = strrchr (szVhdPath, '\\\\');\r\n    if (d)\r\n        memmove (d, c+3, strlen(c+3)+1);\r\n    else\r\n        return d;\r\n    }\r\nmemset (szVhdPath + strlen (szVhdPath), 0, VhdPathSize - strlen (szVhdPath));\r\nreturn szVhdPath;\r\n}\r\n\r\nstatic char *\r\nVhdPathToHostPath (const char *szVhdPath,\r\n                   char *szHostPath,\r\n                   size_t HostPathSize)\r\n{\r\nchar *c;\r\nchar *d = szHostPath;\r\n\r\nmemmove (szHostPath, szVhdPath, HostPathSize);\r\nszHostPath[HostPathSize-1] = '\\0';\r\n#if defined(VMS)\r\nc = strchr (szHostPath, ':');\r\nif (*(c+1) != '\\\\')\r\n    return NULL;\r\n*(c+1) = '[';\r\nd = strrchr (c+2, '\\\\');\r\nif (d) {\r\n    *d = ']';\r\n    while ((d = strrchr (c+2, '\\\\')))\r\n        *d = '.';\r\n    }\r\nelse\r\n    return NULL;\r\n#else\r\nwhile ((c = strchr (d, '\\\\')))\r\n    *c = '/';\r\n#endif\r\nmemset (szHostPath + strlen (szHostPath), 0, HostPathSize - strlen (szHostPath));\r\nreturn szHostPath;\r\n}\r\n\r\nstatic VHDHANDLE\r\nCreateDifferencingVirtualDisk(const char *szVHDPath,\r\n                              const char *szParentVHDPath)\r\n{\r\nuint32 BytesPerSector = 512;\r\nVHDHANDLE hVHD = NULL;\r\nVHD_Footer ParentFooter;\r\nVHD_DynamicDiskHeader ParentDynamic;\r\nuint32 ParentTimeStamp;\r\nuint32 Status = 0;\r\nchar *RelativeParentVHDPath = NULL;\r\nchar *FullParentVHDPath = NULL;\r\nchar *RelativeParentVHDPathUnicode = NULL;\r\nchar *FullParentVHDPathUnicode = NULL;\r\nchar *FullVHDPath = NULL;\r\nchar *TempPath = NULL;\r\nsize_t i, RelativeMatch, UpDirectories, LocatorsWritten = 0;\r\nint64 LocatorPosition;\r\n\r\nif ((Status = GetVHDFooter (szParentVHDPath,\r\n                            &ParentFooter,\r\n                            &ParentDynamic,\r\n                            NULL,\r\n                            &ParentTimeStamp,\r\n                            NULL,\r\n                            0)))\r\n    goto Cleanup_Return;\r\nhVHD = sim_CreateVirtualDisk (szVHDPath,\r\n                              (uint32)(NtoHll(ParentFooter.CurrentSize)/BytesPerSector),\r\n                              NtoHl(ParentDynamic.BlockSize),\r\n                              FALSE,\r\n                              &ParentFooter,\r\n                              NULL);\r\nif (!hVHD) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nLocatorPosition = ((sizeof (hVHD->Footer) + BytesPerSector - 1)/BytesPerSector + (sizeof (hVHD->Dynamic) + BytesPerSector - 1)/BytesPerSector)*BytesPerSector;\r\nhVHD->Dynamic.Checksum = 0;\r\nRelativeParentVHDPath = (char*) calloc (1, BytesPerSector+2);\r\nFullParentVHDPath = (char*) calloc (1, BytesPerSector+2);\r\nRelativeParentVHDPathUnicode = (char*) calloc (1, BytesPerSector+2);\r\nFullParentVHDPathUnicode = (char*) calloc (1, BytesPerSector+2);\r\nFullVHDPath = (char*) calloc (1, BytesPerSector+2);\r\nTempPath = (char*) calloc (1, BytesPerSector+2);\r\nExpandToFullPath (szParentVHDPath, TempPath, BytesPerSector);\r\nHostPathToVhdPath (TempPath, FullParentVHDPath, BytesPerSector);\r\nfor (i=0; i < strlen (FullParentVHDPath); i++)\r\n    hVHD->Dynamic.ParentUnicodeName[i*2+1] = FullParentVHDPath[i];  /* Big Endian Unicode */\r\nfor (i=0; i < strlen (FullParentVHDPath); i++)\r\n    FullParentVHDPathUnicode[i*2] = FullParentVHDPath[i];           /* Little Endian Unicode */\r\nExpandToFullPath (szVHDPath, TempPath, BytesPerSector);\r\nHostPathToVhdPath (TempPath, FullVHDPath, BytesPerSector);\r\nfor (i=0, RelativeMatch=UpDirectories=0; i<strlen(FullVHDPath); i++)\r\n    if (FullVHDPath[i] == '\\\\') {\r\n        if (memcmp (FullVHDPath, FullParentVHDPath, i+1))\r\n            ++UpDirectories;\r\n        else\r\n            RelativeMatch = i;\r\n        }\r\nif (RelativeMatch) {\r\n    char UpDir[4] = \"..\\\\\";\r\n\r\n    UpDir[2] = FullParentVHDPath[RelativeMatch];\r\n    if (UpDirectories)\r\n        for (i=0; i<UpDirectories; i++)\r\n            strcpy (RelativeParentVHDPath+strlen (RelativeParentVHDPath), UpDir);\r\n    else\r\n        strcpy (RelativeParentVHDPath+strlen (RelativeParentVHDPath), UpDir+1);\r\n    strcpy (RelativeParentVHDPath+strlen (RelativeParentVHDPath), &FullParentVHDPath[RelativeMatch+1]);\r\n    }\r\nfor (i=0; i < strlen(RelativeParentVHDPath); i++)\r\n    RelativeParentVHDPathUnicode[i*2] = RelativeParentVHDPath[i];\r\nhVHD->Dynamic.ParentTimeStamp = ParentTimeStamp;\r\nmemcpy (hVHD->Dynamic.ParentUniqueID, ParentFooter.UniqueID, sizeof (hVHD->Dynamic.ParentUniqueID));\r\n/* There are two potential parent locators on current vhds */\r\nmemcpy (hVHD->Dynamic.ParentLocatorEntries[0].PlatformCode, \"W2ku\", 4);\r\nhVHD->Dynamic.ParentLocatorEntries[0].PlatformDataSpace = NtoHl (BytesPerSector);\r\nhVHD->Dynamic.ParentLocatorEntries[0].PlatformDataLength = NtoHl ((uint32)(2*strlen(FullParentVHDPath)));\r\nhVHD->Dynamic.ParentLocatorEntries[0].Reserved = 0;\r\nhVHD->Dynamic.ParentLocatorEntries[0].PlatformDataOffset = NtoHll (LocatorPosition+LocatorsWritten*BytesPerSector);\r\n++LocatorsWritten;\r\nif (RelativeMatch) {\r\n    memcpy (hVHD->Dynamic.ParentLocatorEntries[1].PlatformCode, \"W2ru\", 4);\r\n    hVHD->Dynamic.ParentLocatorEntries[1].PlatformDataSpace = NtoHl (BytesPerSector);\r\n    hVHD->Dynamic.ParentLocatorEntries[1].PlatformDataLength = NtoHl ((uint32)(2*strlen(RelativeParentVHDPath)));\r\n    hVHD->Dynamic.ParentLocatorEntries[1].Reserved = 0;\r\n    hVHD->Dynamic.ParentLocatorEntries[1].PlatformDataOffset = NtoHll (LocatorPosition+LocatorsWritten*BytesPerSector);\r\n    ++LocatorsWritten;\r\n    }\r\nhVHD->Dynamic.TableOffset = NtoHll (((LocatorPosition+LocatorsWritten*BytesPerSector + VHD_DATA_BLOCK_ALIGNMENT - 1)/VHD_DATA_BLOCK_ALIGNMENT)*VHD_DATA_BLOCK_ALIGNMENT);\r\nhVHD->Dynamic.Checksum = 0;\r\nhVHD->Dynamic.Checksum = NtoHl (CalculateVhdFooterChecksum (&hVHD->Dynamic, sizeof(hVHD->Dynamic)));\r\nhVHD->Footer.Checksum = 0;\r\nhVHD->Footer.DiskType = NtoHl (VHD_DT_Differencing);\r\nmemcpy (hVHD->Footer.DriveType, ParentFooter.DriveType, sizeof (hVHD->Footer.DriveType));\r\nhVHD->Footer.DriveSectorSize = ParentFooter.DriveSectorSize;\r\nhVHD->Footer.DriveElementEncodingSize = ParentFooter.DriveElementEncodingSize;\r\nhVHD->Footer.Checksum = NtoHl (CalculateVhdFooterChecksum (&hVHD->Footer, sizeof(hVHD->Footer)));\r\n\r\nif (WriteFilePosition (hVHD->File,\r\n                       &hVHD->Footer,\r\n                       sizeof (hVHD->Footer),\r\n                       NULL,\r\n                       0)) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (WriteFilePosition (hVHD->File,\r\n                       &hVHD->Dynamic,\r\n                       sizeof (hVHD->Dynamic),\r\n                       NULL,\r\n                       NtoHll (hVHD->Footer.DataOffset))) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (WriteFilePosition (hVHD->File,\r\n                       hVHD->BAT,\r\n                       BytesPerSector*((NtoHl (hVHD->Dynamic.MaxTableEntries)*sizeof(*hVHD->BAT)+BytesPerSector-1)/BytesPerSector),\r\n                       NULL,\r\n                       NtoHll (hVHD->Dynamic.TableOffset))) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (WriteFilePosition (hVHD->File,\r\n                       &hVHD->Footer,\r\n                       sizeof (hVHD->Footer),\r\n                       NULL,\r\n                       NtoHll (hVHD->Dynamic.TableOffset)+BytesPerSector*((NtoHl (hVHD->Dynamic.MaxTableEntries)*sizeof(*hVHD->BAT)+BytesPerSector-1)/BytesPerSector))) {\r\n    Status = errno;\r\n    goto Cleanup_Return;\r\n    }\r\nif (hVHD->Dynamic.ParentLocatorEntries[0].PlatformDataLength)\r\n    if (WriteFilePosition (hVHD->File,\r\n                           FullParentVHDPathUnicode,\r\n                           BytesPerSector,\r\n                           NULL,\r\n                           NtoHll (hVHD->Dynamic.ParentLocatorEntries[0].PlatformDataOffset))) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\nif (hVHD->Dynamic.ParentLocatorEntries[1].PlatformDataLength)\r\n    if (WriteFilePosition (hVHD->File,\r\n                           RelativeParentVHDPathUnicode,\r\n                           BytesPerSector,\r\n                           NULL,\r\n                           NtoHll (hVHD->Dynamic.ParentLocatorEntries[1].PlatformDataOffset))) {\r\n        Status = errno;\r\n        goto Cleanup_Return;\r\n        }\r\n\r\nCleanup_Return:\r\nfree (RelativeParentVHDPath);\r\nfree (FullParentVHDPath);\r\nfree (RelativeParentVHDPathUnicode);\r\nfree (FullParentVHDPathUnicode);\r\nfree (FullVHDPath);\r\nfree (TempPath);\r\nsim_vhd_disk_close ((FILE *)hVHD);\r\nhVHD = NULL;\r\nif (Status) {\r\n    if ((EEXIST != Status) && (ENOENT != Status))\r\n        (void)remove (szVHDPath);\r\n    }\r\nelse {\r\n    hVHD = (VHDHANDLE)sim_vhd_disk_open (szVHDPath, \"rb+\");\r\n    if (!hVHD)\r\n        Status = errno;\r\n    }\r\nerrno = Status;\r\nreturn hVHD;\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_create (const char *szVHDPath, t_offset desiredsize, DRVTYP *drvtyp)\r\n{\r\nreturn (FILE *)sim_CreateVirtualDisk (szVHDPath, (uint32)(desiredsize/512), 0, (sim_switches & SWMASK ('X')), NULL, drvtyp);\r\n}\r\n\r\nstatic FILE *sim_vhd_disk_create_diff (const char *szVHDPath, const char *szParentVHDPath)\r\n{\r\nreturn (FILE *)CreateDifferencingVirtualDisk (szVHDPath, szParentVHDPath);\r\n}\r\n\r\nstatic t_stat\r\nReadVirtualDisk(VHDHANDLE hVHD,\r\n                uint8 *buf,\r\n                uint32 BytesToRead,\r\n                uint32 *BytesRead,\r\n                uint64 Offset)\r\n{\r\nuint32 TotalBytesRead = 0;\r\nuint32 BitMapBytes;\r\nuint32 BitMapSectors;\r\nuint32 DynamicBlockSize;\r\nt_stat r = SCPE_OK;\r\n\r\nif (BytesRead)\r\n    *BytesRead = 0;\r\nif (!hVHD || (hVHD->File == NULL)) {\r\n    errno = EBADF;\r\n    return SCPE_IOERR;\r\n    }\r\nif (BytesToRead == 0)\r\n    return SCPE_OK;\r\nif (Offset >= (uint64)NtoHll (hVHD->Footer.CurrentSize)) {\r\n    errno = ERANGE;\r\n    return SCPE_IOERR;\r\n    }\r\nif (NtoHl (hVHD->Footer.DiskType) == VHD_DT_Fixed) {\r\n    if (ReadFilePosition(hVHD->File,\r\n                         buf,\r\n                         BytesToRead,\r\n                         BytesRead,\r\n                         Offset))\r\n        r = SCPE_IOERR;\r\n    return r;\r\n    }\r\n/* We are now dealing with a Dynamically expanding or differencing disk */\r\nDynamicBlockSize = NtoHl (hVHD->Dynamic.BlockSize);\r\nif ((DynamicBlockSize == 0) ||\r\n    ((DynamicBlockSize & (DynamicBlockSize - 1)) != 0)) {\r\n    errno = ERANGE;\r\n    return SCPE_IOERR;\r\n    }\r\nBitMapBytes = (7+(DynamicBlockSize / VHD_Internal_SectorSize))/8;\r\nBitMapSectors = (BitMapBytes+VHD_Internal_SectorSize-1)/VHD_Internal_SectorSize;\r\nwhile (BytesToRead && (r == SCPE_OK)) {\r\n    uint32 BlockNumber = (uint32)(Offset / DynamicBlockSize);\r\n    uint32 BytesInRead = BytesToRead;\r\n    uint32 BytesThisRead = 0;\r\n\r\n    if (BlockNumber != (Offset + BytesToRead) / DynamicBlockSize)\r\n        BytesInRead = (uint32)(((BlockNumber + 1) * DynamicBlockSize) - Offset);\r\n    if (hVHD->BAT[BlockNumber] == VHD_BAT_FREE_ENTRY) {\r\n        if (!hVHD->Parent) {\r\n            memset (buf, 0, BytesInRead);\r\n            BytesThisRead = BytesInRead;\r\n            }\r\n        else {\r\n            if (ReadVirtualDisk(hVHD->Parent,\r\n                                buf,\r\n                                BytesInRead,\r\n                                &BytesThisRead,\r\n                                Offset))\r\n                r = SCPE_IOERR;\r\n            }\r\n        }\r\n    else {\r\n        uint64 BlockOffset = VHD_Internal_SectorSize * ((uint64)(NtoHl (hVHD->BAT[BlockNumber]) + BitMapSectors)) + (Offset % DynamicBlockSize);\r\n\r\n        if (ReadFilePosition(hVHD->File,\r\n                             buf,\r\n                             BytesInRead,\r\n                             &BytesThisRead,\r\n                             BlockOffset))\r\n            r = SCPE_IOERR;\r\n        }\r\n    BytesToRead -= BytesThisRead;\r\n    buf = (uint8 *)(((char *)buf) + BytesThisRead);\r\n    Offset += BytesThisRead;\r\n    TotalBytesRead += BytesThisRead;\r\n    }\r\nif (BytesRead)\r\n    *BytesRead = TotalBytesRead;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat\r\nReadVirtualDiskSectors(VHDHANDLE hVHD,\r\n                       uint8 *buf,\r\n                       t_seccnt sects,\r\n                       t_seccnt *sectsread,\r\n                       uint32 SectorSize,\r\n                       t_lba lba)\r\n{\r\nuint32 BytesRead;\r\nt_stat r = ReadVirtualDisk(hVHD,\r\n                           buf,\r\n                           sects * SectorSize,\r\n                           &BytesRead,\r\n                           SectorSize * (uint64)lba);\r\nif (sectsread)\r\n    *sectsread = BytesRead / SectorSize;\r\nreturn r;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)uptr->fileref;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nreturn ReadVirtualDiskSectors(hVHD, buf, sects, sectsread, ctx->sector_size, lba);\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_clearerr (UNIT *uptr)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)uptr->fileref;\r\n\r\nclearerr (hVHD->File);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_bool\r\nBufferIsZeros(void *Buffer, size_t BufferSize)\r\n{\r\nsize_t i;\r\nchar *c = (char *)Buffer;\r\n\r\nfor (i=0; i<BufferSize; ++i)\r\n    if (c[i])\r\n        return FALSE;\r\nreturn TRUE;\r\n}\r\n\r\nstatic t_stat\r\nWriteVirtualDisk(VHDHANDLE hVHD,\r\n                 uint8 *buf,\r\n                 uint32 BytesToWrite,\r\n                 uint32 *BytesWritten,\r\n                 uint64 Offset)\r\n{\r\nuint32 TotalBytesWritten = 0;\r\nuint32 BitMapBytes;\r\nuint32 BitMapSectors;\r\nuint32 DynamicBlockSize;\r\nt_stat r = SCPE_OK;\r\n\r\nif (BytesWritten)\r\n    *BytesWritten = 0;\r\nif (!hVHD || !hVHD->File) {\r\n    errno = EBADF;\r\n    return SCPE_IOERR;\r\n    }\r\nif (BytesToWrite == 0)\r\n    return SCPE_OK;\r\nif (Offset >= (uint64)NtoHll(hVHD->Footer.CurrentSize)) {\r\n    errno = ERANGE;\r\n    return SCPE_IOERR;\r\n    }\r\nif (NtoHl(hVHD->Footer.DiskType) == VHD_DT_Fixed) {\r\n    if (WriteFilePosition(hVHD->File,\r\n                          buf,\r\n                          BytesToWrite,\r\n                          BytesWritten,\r\n                          Offset))\r\n        r = SCPE_IOERR;\r\n    return r;\r\n    }\r\n/* We are now dealing with a Dynamically expanding or differencing disk */\r\nDynamicBlockSize = NtoHl (hVHD->Dynamic.BlockSize);\r\nif ((DynamicBlockSize == 0) ||\r\n    ((DynamicBlockSize & (DynamicBlockSize - 1)) != 0)) {\r\n    errno = ERANGE;\r\n    return SCPE_IOERR;\r\n    }\r\nBitMapBytes = (7 + (DynamicBlockSize / VHD_Internal_SectorSize)) / 8;\r\nBitMapSectors = (BitMapBytes + VHD_Internal_SectorSize - 1) / VHD_Internal_SectorSize;\r\nwhile (BytesToWrite && (r == SCPE_OK)) {\r\n    uint32 BlockNumber = (uint32)(Offset / DynamicBlockSize);\r\n    uint32 BytesInWrite = BytesToWrite;\r\n    uint32 BytesThisWrite = 0;\r\n\r\n    if (BlockNumber >= NtoHl(hVHD->Dynamic.MaxTableEntries)) {\r\n        return SCPE_EOF;\r\n        }\r\n    if (BlockNumber != (Offset + BytesToWrite) / DynamicBlockSize)\r\n        BytesInWrite = (uint32)(((BlockNumber + 1) * DynamicBlockSize) - Offset);\r\n    if (hVHD->BAT[BlockNumber] == VHD_BAT_FREE_ENTRY) {\r\n        uint8 *BitMap = NULL;\r\n        uint32 BitMapBufferSize = VHD_DATA_BLOCK_ALIGNMENT;\r\n        uint8 *BitMapBuffer = NULL;\r\n        void *BlockData = NULL;\r\n        uint8 *BATUpdateBufferAddress;\r\n        uint32 BATUpdateBufferSize;\r\n        uint64 BATUpdateStorageAddress;\r\n        uint64 BlockOffset;\r\n\r\n        if (!hVHD->Parent && BufferIsZeros(buf, BytesInWrite)) {\r\n            BytesThisWrite = BytesInWrite;\r\n            goto IO_Done;\r\n            }\r\n        /* Need to allocate a new Data Block. */\r\n        BlockOffset = sim_fsize_ex (hVHD->File);\r\n        if (((int64)BlockOffset) == -1)\r\n            return SCPE_IOERR;\r\n        if ((BitMapSectors * VHD_Internal_SectorSize) > BitMapBufferSize)\r\n            BitMapBufferSize = BitMapSectors * VHD_Internal_SectorSize;\r\n        BitMapBuffer = (uint8 *)calloc(1, BitMapBufferSize + DynamicBlockSize);\r\n        if (BitMapBufferSize > BitMapSectors * VHD_Internal_SectorSize)\r\n            BitMap = BitMapBuffer + BitMapBufferSize - BitMapBytes;\r\n        else\r\n            BitMap = BitMapBuffer;\r\n        memset(BitMap, 0xFF, BitMapBytes);\r\n        BlockOffset -= sizeof(hVHD->Footer);\r\n        if (0 == (BlockOffset & (VHD_DATA_BLOCK_ALIGNMENT-1)))\r\n            {  // Already aligned, so use padded BitMapBuffer\r\n            if (WriteFilePosition(hVHD->File,\r\n                                  BitMapBuffer,\r\n                                  BitMapBufferSize + DynamicBlockSize,\r\n                                  NULL,\r\n                                  BlockOffset)) {\r\n                free (BitMapBuffer);\r\n                return SCPE_IOERR;\r\n                }\r\n            BlockOffset += BitMapBufferSize;\r\n            }\r\n        else\r\n            {\r\n            // align the data portion of the block to the desired alignment\r\n            // compute the address of the data portion of the block\r\n            BlockOffset += BitMapSectors * VHD_Internal_SectorSize;\r\n            // round up this address to the desired alignment\r\n            BlockOffset += VHD_DATA_BLOCK_ALIGNMENT-1;\r\n            BlockOffset &= ~(VHD_DATA_BLOCK_ALIGNMENT - 1);\r\n            BlockOffset -= BitMapSectors * VHD_Internal_SectorSize;\r\n            if (WriteFilePosition(hVHD->File,\r\n                                  BitMap,\r\n                                  (BitMapSectors * VHD_Internal_SectorSize) + DynamicBlockSize,\r\n                                  NULL,\r\n                                  BlockOffset)) {\r\n                free (BitMapBuffer);\r\n                return SCPE_IOERR;\r\n                }\r\n            BlockOffset += BitMapSectors * VHD_Internal_SectorSize;\r\n            }\r\n        free(BitMapBuffer);\r\n        BitMapBuffer = BitMap = NULL;\r\n        /* the BAT block address is the beginning of the block bitmap */\r\n        BlockOffset -= BitMapSectors * VHD_Internal_SectorSize;\r\n        hVHD->BAT[BlockNumber] = NtoHl((uint32)(BlockOffset / VHD_Internal_SectorSize));\r\n        BlockOffset += (BitMapSectors * VHD_Internal_SectorSize) + DynamicBlockSize;\r\n        if (WriteFilePosition(hVHD->File,\r\n                              &hVHD->Footer,\r\n                              sizeof(hVHD->Footer),\r\n                              NULL,\r\n                              BlockOffset))\r\n            goto Fatal_IO_Error;\r\n        /* Since a large VHD can have a pretty large BAT, and we've only changed one longword bat entry\r\n           in the current BAT, we write just the aligned sector which contains the updated BAT entry */\r\n        BATUpdateBufferAddress = (uint8 *)hVHD->BAT - (size_t)NtoHll(hVHD->Dynamic.TableOffset) +\r\n            (size_t)((((size_t)&hVHD->BAT[BlockNumber]) - (size_t)hVHD->BAT + (size_t)NtoHll(hVHD->Dynamic.TableOffset)) & ~(VHD_DATA_BLOCK_ALIGNMENT-1));\r\n        /* If the starting of the BAT isn't on a VHD_DATA_BLOCK_ALIGNMENT boundary and we've just updated\r\n           a BAT entry early in the array, the buffer computed address might be before the start of the\r\n           BAT table.  If so, only write the BAT data needed */\r\n        if (BATUpdateBufferAddress < (uint8 *)hVHD->BAT) {\r\n            BATUpdateBufferAddress = (uint8 *)hVHD->BAT;\r\n            BATUpdateBufferSize = (uint32)((((size_t)&hVHD->BAT[BlockNumber]) - (size_t)hVHD->BAT) + 512) & ~511;\r\n            BATUpdateStorageAddress = NtoHll(hVHD->Dynamic.TableOffset);\r\n            }\r\n        else {\r\n            BATUpdateBufferSize = VHD_DATA_BLOCK_ALIGNMENT;\r\n            BATUpdateStorageAddress = NtoHll(hVHD->Dynamic.TableOffset) + BATUpdateBufferAddress - ((uint8 *)hVHD->BAT);\r\n            }\r\n        /* If the total BAT is smaller than one VHD_DATA_BLOCK_ALIGNMENT, then be sure to only write out the BAT data */\r\n        if ((size_t)(BATUpdateBufferAddress - (uint8 *)hVHD->BAT + BATUpdateBufferSize) > VHD_Internal_SectorSize * ((sizeof(*hVHD->BAT)*NtoHl(hVHD->Dynamic.MaxTableEntries) + VHD_Internal_SectorSize - 1)/VHD_Internal_SectorSize))\r\n            BATUpdateBufferSize = (uint32)(VHD_Internal_SectorSize * ((sizeof(*hVHD->BAT) * NtoHl(hVHD->Dynamic.MaxTableEntries) + VHD_Internal_SectorSize - 1)/VHD_Internal_SectorSize) - (BATUpdateBufferAddress - ((uint8 *)hVHD->BAT)));\r\n        if (WriteFilePosition(hVHD->File,\r\n                              BATUpdateBufferAddress,\r\n                              BATUpdateBufferSize,\r\n                              NULL,\r\n                              BATUpdateStorageAddress))\r\n            goto Fatal_IO_Error;\r\n        if (hVHD->Parent)\r\n            { /* Need to populate data block contents from parent VHD */\r\n            BlockData = malloc (NtoHl (hVHD->Dynamic.BlockSize));\r\n\r\n            if (ReadVirtualDisk(hVHD->Parent,\r\n                                (uint8*) BlockData,\r\n                                NtoHl (hVHD->Dynamic.BlockSize),\r\n                                NULL,\r\n                                (Offset / NtoHl (hVHD->Dynamic.BlockSize)) * NtoHl (hVHD->Dynamic.BlockSize)))\r\n                goto Fatal_IO_Error;\r\n            if (WriteVirtualDisk(hVHD,\r\n                                 (uint8*) BlockData,\r\n                                 NtoHl (hVHD->Dynamic.BlockSize),\r\n                                 NULL,\r\n                                 (Offset / NtoHl (hVHD->Dynamic.BlockSize)) * NtoHl (hVHD->Dynamic.BlockSize)))\r\n                goto Fatal_IO_Error;\r\n            free(BlockData);\r\n            }\r\n        continue;\r\nFatal_IO_Error:\r\n        free (BitMap);\r\n        free (BlockData);\r\n        r = SCPE_IOERR;\r\n        }\r\n    else {\r\n        uint64 BlockOffset = VHD_Internal_SectorSize * ((uint64)(NtoHl(hVHD->BAT[BlockNumber]) + BitMapSectors)) + (Offset % DynamicBlockSize);\r\n\r\n        if (WriteFilePosition(hVHD->File,\r\n                              buf,\r\n                              BytesInWrite,\r\n                              &BytesThisWrite,\r\n                              BlockOffset))\r\n            r = SCPE_IOERR;\r\n        }\r\nIO_Done:\r\n    BytesToWrite -= BytesThisWrite;\r\n    buf = (uint8 *)(((char *)buf) + BytesThisWrite);\r\n    Offset += BytesThisWrite;\r\n    TotalBytesWritten += BytesThisWrite;\r\n    }\r\nif (BytesWritten)\r\n    *BytesWritten = TotalBytesWritten;\r\nreturn r;\r\n}\r\n\r\nstatic t_stat\r\nWriteVirtualDiskSectors(VHDHANDLE hVHD,\r\n                        uint8 *buf,\r\n                        t_seccnt sects,\r\n                        t_seccnt *sectswritten,\r\n                        uint32 SectorSize,\r\n                        t_lba lba)\r\n{\r\nuint32 BytesWritten;\r\nt_stat r = WriteVirtualDisk(hVHD,\r\n                            buf,\r\n                            sects * SectorSize,\r\n                            &BytesWritten,\r\n                            SectorSize * (uint64)lba);\r\n\r\nif (sectswritten)\r\n    *sectswritten = BytesWritten / SectorSize;\r\nreturn r;\r\n}\r\n\r\nstatic t_stat sim_vhd_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects)\r\n{\r\nVHDHANDLE hVHD = (VHDHANDLE)uptr->fileref;\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\n\r\nreturn WriteVirtualDiskSectors(hVHD, buf, sects, sectswritten, ctx->sector_size, lba);\r\n}\r\n#endif\r\n\r\n/* Used when sorting a drive type list: */\r\n/* - Disks come first ordered by drive size */\r\n/* - Tapes come last ordered by drive name */\r\nstatic int _drive_type_compare (const void *pa, const void *pb)\r\n{\r\nconst DRVTYP *a = (const DRVTYP *)pa;\r\nconst DRVTYP *b = (const DRVTYP *)pb;\r\nint32 size_cmp;\r\n\r\nif (a->devtype == SCSI_TAPE) {\r\n    if (b->devtype == SCSI_TAPE)\r\n        return strcmp (a->name, b->name);\r\n    else\r\n        return 1;\r\n    }\r\nelse {\r\n    if (b->devtype == SCSI_TAPE)\r\n        return -1;\r\n    else {\r\n        size_cmp = ((int32)a->size - (int32)b->size);\r\n        if (size_cmp == 0)\r\n            size_cmp = strcmp (a->name, b->name);\r\n        return size_cmp;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void deb_MTAB (MTAB *mptr)\r\n{\r\nchar mask[CBUFSIZE] = \"\";\r\nchar pstring[CBUFSIZE];\r\nchar mstring[CBUFSIZE];\r\nchar desc[CBUFSIZE];\r\nchar help[CBUFSIZE];\r\n\r\nif ((sim_scp_dev.dctrl & SIM_DBG_INIT) && sim_deb) {\r\n    if ((mptr->mask & MTAB_XTD)) {\r\n        if (MODMASK(mptr, MTAB_VDV))\r\n            strlcat (mask, \"MTAB_VDV|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_VUN))\r\n            strlcat (mask, \"MTAB_VUN|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_VALR))\r\n            strlcat (mask, \"MTAB_VALR|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_VALO))\r\n            strlcat (mask, \"MTAB_VALO|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_NMO))\r\n            strlcat (mask, \"MTAB_NMO|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_NC))\r\n            strlcat (mask, \"MTAB_NC|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_QUOTE))\r\n            strlcat (mask, \"MTAB_QUOTE|\", sizeof (mask));\r\n        if (MODMASK(mptr, MTAB_SHP))\r\n            strlcat (mask, \"MTAB_SHP|\", sizeof (mask));\r\n        if (strlen (mask) > 0)\r\n            mask[strlen (mask) - 1] = '\\0';\r\n        }\r\n    else\r\n        snprintf (mask, sizeof (mask), \"0x%X\", mptr->mask);\r\n    if (mptr->pstring)\r\n        snprintf (pstring, sizeof (pstring), \"\\\"%s\\\"\", mptr->pstring);\r\n    else\r\n        strlcpy (pstring, \"NULL\", sizeof (pstring));\r\n    if (mptr->mstring)\r\n        snprintf (mstring, sizeof (mstring), \"\\\"%s\\\"\", mptr->mstring);\r\n    else\r\n        strlcpy (mstring, \"NULL\", sizeof (mstring));\r\n    if (mptr->desc)\r\n        snprintf (desc, sizeof (desc), \"\\\"%s\\\"\", (char *)mptr->desc);\r\n    else\r\n        strlcpy (desc, \"NULL\", sizeof (desc));\r\n    if (mptr->help)\r\n        snprintf (help, sizeof (help), \"\\\"%s\\\"\", mptr->help);\r\n    else\r\n        strlcpy (help, \"NULL\", sizeof (help));\r\n    }\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"{%s, 0x%X, %s, %s,\\n\", mask, mptr->match,\r\n           pstring, mstring);\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"    %s, %s,\\n\",\r\n           mptr->valid ? \"Validator-Routine\" : \"NULL\", mptr->disp ? \"Display-Routine\" : \"NULL\");\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"    %s, %s}\\n\",\r\n           desc, help);\r\n}\r\n\r\nt_stat sim_disk_init (void)\r\n{\r\nint32 saved_sim_show_message = sim_show_message;\r\nDEVICE *dptr;\r\nuint32 i, j, k, l;\r\nt_stat stat = SCPE_OK;\r\n\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"sim_disk_init()\\n\");\r\nfor (i = 0; NULL != (dptr = sim_devices[i]); i++) {\r\n    DRVTYP *drive;\r\n    static MTAB autos[] = {\r\n        { MTAB_XTD|MTAB_VUN,        1,  NULL, \"AUTOSIZE\",\r\n            &sim_disk_set_autosize,  NULL, NULL, \"Enable disk autosize on attach\" },\r\n        { MTAB_XTD|MTAB_VUN,        0,  NULL, \"NOAUTOSIZE\",\r\n            &sim_disk_set_autosize,  NULL, NULL, \"Disable disk autosize on attach\"  },\r\n        { MTAB_XTD|MTAB_VUN,        0,  \"AUTOSIZE\", NULL,\r\n            NULL, &sim_disk_show_autosize, NULL, \"Display disk autosize on attach setting\" }};\r\n    static MTAB autoz[] = {\r\n        { MTAB_XTD|MTAB_VUN,        1,  NULL, \"AUTOZAP\",\r\n            &sim_disk_set_autozap,  NULL, NULL, \"Enable disk metadata removal on detach\" },\r\n        { MTAB_XTD|MTAB_VUN,        0,  NULL, \"NOAUTOZAP\",\r\n            &sim_disk_set_autozap,  NULL, NULL, \"Disable disk metadata removal on detach\"  },\r\n        { MTAB_XTD|MTAB_VUN,        0,  \"AUTOZAP\", NULL,\r\n            NULL, &sim_disk_show_autozap, NULL, \"Display disk autozap on detach setting\" }};\r\n    MTAB *mtab = dptr->modifiers;\r\n    MTAB *nmtab = NULL;\r\n    t_stat (*validator)(UNIT *up, int32 v, CONST char *cp, void *dp) = NULL;\r\n    uint32 modifiers = 0;\r\n    uint32 setters = 0;\r\n    uint32 dumb_autosizers = 0;\r\n    uint32 smart_autosizers = 0;\r\n    uint32 smart_autosizer = 0xFFFFFFFF;\r\n    uint32 drives = 0;\r\n    uint32 aliases = 0;\r\n    int32 show_type_entry = -1;\r\n\r\n    if (((DEV_TYPE (dptr) != DEV_DISK) && (DEV_TYPE (dptr) != DEV_SCSI)) ||\r\n        (dptr->type_ctx == NULL))\r\n        continue;\r\n    sim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Device: %s\\n\", dptr->name);\r\n    drive = (DRVTYP *)dptr->type_ctx;\r\n    /* First prepare/fill-in the drive type list */\r\n    for (drives = aliases = 0; drive[drives].name != NULL; drives++) {\r\n        if (drive[drives].MediaId == 0)\r\n            drive[drives].MediaId = sim_disk_drive_type_to_mediaid (drive[drives].name, drive[drives].driver_name);\r\n        if (drive[drives].name_alias != NULL)\r\n            ++aliases;\r\n        /* Validate Geometry parameters */\r\n        if (((drive[drives].flags & DRVFL_SETSIZE) == 0) &&\r\n            ((DRVFL_GET_IFTYPE(&drive[drives]) != DRVFL_TYPE_SCSI) ||\r\n             (drive[drives].devtype != SCSI_TAPE)) &&\r\n            ((drive[drives].flags & DRVFL_QICTAPE) == 0) &&\r\n            (drive[drives].size > (drive[drives].sect * drive[drives].surf * drive[drives].cyl))) {\r\n            stat = sim_messagef (SCPE_IERR, \"Device %s drive type %s has unreasonable geometry values:\\n\",\r\n                                            dptr->name, drive[drives].name);\r\n            stat = sim_messagef (SCPE_IERR, \"Total Sectors: %u > (%u Cyls * %u Heads * %u sectors)\\n\",\r\n                                            drive[drives].size, drive[drives].cyl, drive[drives].surf, drive[drives].sect);\r\n            }\r\n        }\r\n    sim_debug (SIM_DBG_INIT, &sim_scp_dev, \"%d Drive Types, %d aliases\\n\", drives, aliases);\r\n    qsort (drive, drives, sizeof (*drive), _drive_type_compare);\r\n    /* find device type modifier entries */\r\n    for (j = 0; mtab[j].mask != 0; j++) {\r\n        ++modifiers;\r\n        if (((mtab[j].pstring != NULL) &&\r\n             ((strcasecmp (mtab[j].pstring, \"AUTOSIZE\") == 0)   ||\r\n              (strcasecmp (mtab[j].pstring, \"NOAUTOSIZE\") == 0))) ||\r\n            ((mtab[j].mstring != NULL) &&\r\n             ((strcasecmp (mtab[j].mstring, \"AUTOSIZE\") == 0)   ||\r\n              (strcasecmp (mtab[j].mstring, \"NOAUTOSIZE\") == 0)))) {\r\n             if ((mtab[j].mask & (MTAB_XTD|MTAB_VUN)) == 0)\r\n                 ++dumb_autosizers;             /* Autosize set in unit flags */\r\n             else {\r\n                 ++smart_autosizers;            /* Autosize set by modifier */\r\n                 smart_autosizer = j;\r\n                 }\r\n            }\r\n        if ((mtab[j].disp == &sim_disk_show_drive_type) &&\r\n            (mtab[j].mask == (MTAB_XTD|MTAB_VUN)))\r\n            show_type_entry = j;\r\n        for (k = 0; drive[k].name != NULL; k++) {\r\n            if ((mtab[j].mstring == NULL) ||\r\n                (strncasecmp (mtab[j].mstring, drive[k].name, strlen (drive[k].name))))\r\n                continue;\r\n            validator = mtab[j].valid;\r\n            break;\r\n            }\r\n        if ((k == drives) &&\r\n            ((mtab[j].mask != (MTAB_XTD|MTAB_VUN)) ||\r\n             (mtab[j].pstring == NULL)             ||\r\n             (strcasecmp (mtab[j].pstring, \"TYPE\") != 0)))\r\n            continue;\r\n        ++setters;\r\n        }\r\n    sim_debug (SIM_DBG_INIT, &sim_scp_dev, \"%d Smart Autosizers, %d Modifiers, %d Setters, %d Dumb Autosizers\\n\",\r\n                                           smart_autosizers, modifiers, setters, dumb_autosizers);\r\n    nmtab = (MTAB *)calloc (2 + ((smart_autosizers == 0) * (sizeof (autos)/sizeof (autos[0]))) + (1 + (sizeof (autos)/sizeof (autos[0]))) * (drives + aliases + (modifiers - (setters + dumb_autosizers))), sizeof (MTAB));\r\n    l = 0;\r\n    for (j = 0; mtab[j].mask != 0; j++) {\r\n        if ((((mtab[j].pstring != NULL) &&\r\n              ((strcasecmp (mtab[j].pstring, \"AUTOSIZE\") == 0)   ||\r\n               (strcasecmp (mtab[j].pstring, \"NOAUTOSIZE\") == 0))) ||\r\n             ((mtab[j].mstring != NULL) &&\r\n              ((strcasecmp (mtab[j].mstring, \"AUTOSIZE\") == 0)   ||\r\n               (strcasecmp (mtab[j].mstring, \"NOAUTOSIZE\") == 0)))) &&\r\n            ((mtab[j].mask & (MTAB_XTD|MTAB_VUN)) == 0))\r\n             continue;          /* skip dumb autosizers */\r\n        for (k = 0; drive[k].name != NULL; k++) {\r\n            if ((mtab[j].mstring == NULL) ||\r\n                (strncasecmp (mtab[j].mstring, drive[k].name, strlen (drive[k].name))))\r\n                continue;\r\n            break;\r\n            }\r\n        if ((k == drives) &&\r\n            ((validator == NULL) || (validator != mtab[j].valid)) &&\r\n            ((mtab[j].mask != (MTAB_XTD|MTAB_VUN)) ||\r\n             (mtab[j].pstring == NULL)             ||\r\n             (strcasecmp (mtab[j].pstring, \"TYPE\") != 0))) {\r\n            deb_MTAB (&mtab[j]);\r\n            nmtab[l++] = mtab[j];\r\n            if (smart_autosizer == j) {\r\n                for (k = 0; k < (sizeof (autoz)/sizeof (autoz[0])); k++) {\r\n                    deb_MTAB (&autoz[k]);\r\n                    nmtab[l++] = autoz[k];\r\n                    }\r\n                }\r\n            continue;\r\n            }\r\n        }\r\n    if (smart_autosizers == 0) {\r\n        for (k = 0; k < (sizeof (autos)/sizeof (autos[0])); k++) {\r\n            deb_MTAB (&autos[k]);\r\n            nmtab[l++] = autos[k];\r\n            }\r\n        for (k = 0; k < (sizeof (autoz)/sizeof (autoz[0])); k++) {\r\n            deb_MTAB (&autoz[k]);\r\n            nmtab[l++] = autoz[k];\r\n            }\r\n        }\r\n    for (k = 0; k < drives; k++) {\r\n        char *hlp = (char *)malloc (CBUFSIZE);\r\n        char *mstring = (char *)malloc (CBUFSIZE);\r\n\r\n        nmtab[l].mask = MTAB_XTD|MTAB_VUN;\r\n        nmtab[l].match = k;\r\n        nmtab[l].pstring = NULL;\r\n        nmtab[l].mstring = mstring;\r\n        nmtab[l].valid = &sim_disk_set_drive_type;\r\n        nmtab[l].disp = NULL;\r\n        nmtab[l].desc = NULL;\r\n        nmtab[l].help = hlp;\r\n        ++l;\r\n        if (drive[k].flags & DRVFL_SETSIZE) {\r\n            snprintf (mstring, CBUFSIZE, \"%s=SizeInMB\", drive[k].name);\r\n            snprintf (hlp, CBUFSIZE, \"Set %s Disk Type and its size\", drive[k].name);\r\n            }\r\n        else {\r\n            strlcpy (mstring, drive[k].name, CBUFSIZE);\r\n            if (drive[k].name_desc == NULL) {\r\n                if (drive[k].devtype == SCSI_TAPE)\r\n                    snprintf (hlp, CBUFSIZE, \"Set %s%s%s Tape Type\", drive[k].manufacturer ? drive[k].manufacturer : \"\", drive[k].manufacturer ? \" \" : \"\", drive[k].name);\r\n                else\r\n                    snprintf (hlp, CBUFSIZE, \"Set %s%s%s Disk Type\", drive[k].manufacturer ? drive[k].manufacturer : \"\", drive[k].manufacturer ? \" \" : \"\", drive[k].name);\r\n                }\r\n            else\r\n                strlcpy (hlp, drive[k].name_desc, CBUFSIZE);\r\n            }\r\n        deb_MTAB (&nmtab[l-1]);\r\n        if (drive[k].name_alias != NULL) {\r\n            hlp = (char *)malloc (CBUFSIZE);\r\n            mstring = (char *)malloc (CBUFSIZE);\r\n            nmtab[l].mask = MTAB_XTD|MTAB_VUN;\r\n            nmtab[l].match = k;\r\n            nmtab[l].pstring = NULL;\r\n            nmtab[l].mstring = mstring;\r\n            nmtab[l].valid = &sim_disk_set_drive_type;\r\n            nmtab[l].disp = NULL;\r\n            nmtab[l].desc = NULL;\r\n            nmtab[l].help = hlp;\r\n            ++l;\r\n            if (drive[k].flags & DRVFL_SETSIZE) {\r\n                snprintf (mstring, CBUFSIZE, \"%s=SizeInMB\", drive[k].name_alias);\r\n                snprintf (hlp, CBUFSIZE, \"Set %s Disk Type and its size\", drive[k].name_alias);\r\n                }\r\n            else {\r\n                strlcpy (mstring, drive[k].name_alias, CBUFSIZE);\r\n                if (drive[k].name_desc == NULL)\r\n                    snprintf (hlp, CBUFSIZE, \"Set %s Disk Type\", drive[k].name_alias);\r\n                else\r\n                    strlcpy (hlp, drive[k].name_desc, CBUFSIZE);\r\n                }\r\n            deb_MTAB (&nmtab[l-1]);\r\n            }\r\n        }\r\n    if (show_type_entry == -1) {\r\n        nmtab[l].mask = MTAB_XTD|MTAB_VUN;\r\n        nmtab[l].match = k;\r\n        nmtab[l].pstring = \"TYPE\";\r\n        nmtab[l].mstring = NULL;\r\n        nmtab[l].valid = NULL;\r\n        nmtab[l].disp = &sim_disk_show_drive_type;\r\n        nmtab[l].desc = NULL;\r\n        nmtab[l].help = \"Display device type\";\r\n        deb_MTAB (&nmtab[l]);\r\n        }\r\n    /* replace the original modifier table with the revised one */\r\n    dptr->modifiers = nmtab;\r\n    sim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Updated MTAB table with %d entries\\n\", l);\r\n    }\r\nsim_show_message = FALSE;\r\nsim_disk_set_all_noautosize (FALSE, NULL);\r\nsim_show_message = saved_sim_show_message;\r\nreturn stat;\r\n}\r\n\r\n/*\r\n * Zap Type command to remove incorrectly autosize information that\r\n * may have been recorded at the end of a disk container file\r\n */\r\n\r\ntypedef struct {\r\n    t_stat stat;\r\n    int32 flag;\r\n    } DISK_INFO_CTX;\r\n\r\nstatic t_bool sim_disk_check_attached_container (const char *filename, UNIT **auptr)\r\n{\r\nDEVICE *dptr;\r\nUNIT *uptr;\r\nuint32 i, j;\r\nstruct stat filestat;\r\nchar *fullname;\r\n\r\nerrno = 0;\r\nif (auptr != NULL)\r\n    *auptr = NULL;\r\nif (sim_stat (filename, &filestat))\r\n    return FALSE;\r\nfullname = sim_filepath_parts (filename, \"f\");\r\nif (fullname == NULL)\r\n    return FALSE;                                        /* can't expand path assume attached */\r\n\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++) {     /* loop thru dev */\r\n    if (0 == (dptr->flags & DEV_DISK))\r\n        continue;                                       /* Only interested in disk devices */\r\n    for (j = 0; j < dptr->numunits; j++) {              /* loop thru units */\r\n        uptr = (dptr->units) + j;\r\n        if (uptr->flags & UNIT_ATT) {                   /* attached? */\r\n            struct stat statb;\r\n            char *fullpath;\r\n\r\n            errno = 0;\r\n            fullpath = sim_filepath_parts (uptr->filename, \"f\");\r\n            if (fullpath == NULL)\r\n                continue;\r\n            if (0 != strcasecmp (fullname, fullpath)) {\r\n                free (fullpath);\r\n                continue;\r\n                }\r\n            if (sim_stat (fullpath, &statb)) {\r\n                free (fullpath);\r\n                free (fullname);\r\n                if (auptr != NULL)\r\n                    *auptr = uptr;\r\n                return TRUE;                            /* can't stat assume attached */\r\n                }\r\n            free (fullpath);\r\n            if ((statb.st_dev   != filestat.st_dev)   ||\r\n                (statb.st_ino   != filestat.st_ino)   ||\r\n                (statb.st_mode  != filestat.st_mode)  ||\r\n                (statb.st_nlink != filestat.st_nlink) ||\r\n                (statb.st_uid   != filestat.st_uid)   ||\r\n                (statb.st_gid   != filestat.st_gid)   ||\r\n                (statb.st_atime != filestat.st_atime) ||\r\n                (statb.st_mtime != filestat.st_mtime) ||\r\n                (statb.st_ctime != filestat.st_ctime))\r\n                continue;\r\n            free (fullname);\r\n            if (auptr != NULL)\r\n                *auptr = uptr;\r\n            return TRUE;                                /* file currently attached */\r\n            }\r\n        }\r\n    }\r\nfree (fullname);\r\nreturn FALSE;                                           /* Not attached */\r\n}\r\n\r\nstatic void sim_disk_info_entry (const char *directory,\r\n                                 const char *filename,\r\n                                 t_offset FileSize,\r\n                                 const struct stat *filestat,\r\n                                 void *context)\r\n{\r\nDISK_INFO_CTX *info = (DISK_INFO_CTX *)context;\r\nchar FullPath[PATH_MAX + 1];\r\nstruct simh_disk_footer footer;\r\nstruct simh_disk_footer *f = &footer;\r\nFILE *container;\r\nt_offset container_size;\r\n\r\nsnprintf (FullPath, sizeof (FullPath), \"%s%s\", directory, filename);\r\n\r\nif (info->flag) {        /* zap disk type */\r\n    struct stat statb;\r\n\r\n    if (sim_disk_check_attached_container (FullPath, NULL)) {\r\n        info->stat = sim_messagef (SCPE_ALATT, \"Cannot ZAP an attached disk container: %s\\n\", FullPath);\r\n        return;\r\n        }\r\n    container = sim_vhd_disk_open (FullPath, \"r\");\r\n    if (container != NULL) {\r\n        sim_vhd_disk_close (container);\r\n        info->stat = sim_messagef (SCPE_OPENERR, \"Cannot change the disk type of a VHD container file: %s\\n\", FullPath);\r\n        return;\r\n        }\r\n    if (sim_stat (FullPath, &statb)) {\r\n        info->stat = sim_messagef (SCPE_OPENERR, \"Cannot stat file: '%s' - %s\\n\", FullPath, strerror (errno));\r\n        return;\r\n        }\r\n    container = sim_fopen (FullPath, \"rb+\");\r\n    if (container == NULL) {\r\n        info->stat = sim_messagef (SCPE_OPENERR, \"Cannot open container file '%s' - %s\\n\", FullPath, strerror (errno));\r\n        return;\r\n        }\r\n    container_size = sim_fsize_ex (container);\r\n    if ((container_size != (t_offset)-1) && (container_size > (t_offset)sizeof (*f)) &&\r\n        (sim_fseeko (container, container_size - sizeof (*f), SEEK_SET) == 0) &&\r\n        (sizeof (*f) == sim_fread (f, 1, sizeof (*f), container))) {\r\n        if ((memcmp (f->Signature, \"simh\", 4) == 0) &&\r\n            (f->Checksum == NtoHl (eth_crc32 (0, f, sizeof (*f) - sizeof (f->Checksum))))) {\r\n            uint8 *sector_data;\r\n            uint8 *zero_sector;\r\n            t_offset initial_container_size;\r\n            size_t sector_size = NtoHl (f->SectorSize);\r\n            t_offset highwater = (((t_offset)NtoHl (f->Highwater[0])) << 32) | ((t_offset)NtoHl (f->Highwater[1]));\r\n\r\n            if (sector_size > 16384)        /* arbitrary upper limit */\r\n                sector_size = 16384;\r\n            /* determine whole sectors in original container size */\r\n            /* By default we chop off the disk footer and trailing */\r\n            /* zero sectors added since the footer was appended that */\r\n            /* hadn't been written by normal disk operations. */\r\n            highwater = (highwater + (sector_size - 1)) & (~(t_offset)(sector_size - 1));\r\n            if (sim_switches & SWMASK ('Z'))    /* Unless -Z switch specified */\r\n                highwater = 0;                  /* then removes all trailing zero sectors */\r\n            container_size -= sizeof (*f);\r\n            initial_container_size = container_size;\r\n            stop_cpu = FALSE;\r\n            if (container_size > highwater) {\r\n                sector_data = (uint8 *)malloc (sector_size * sizeof (*sector_data));\r\n                zero_sector = (uint8 *)calloc (sector_size, sizeof (*sector_data));\r\n                sim_messagef (SCPE_OK, \"Trimming trailing zero containing blocks back to lbn: %u\\n\", (uint32)(highwater / sector_size));\r\n                while ((container_size > highwater) &&\r\n                       (!stop_cpu)) {\r\n                    if ((sim_fseeko (container, container_size - sector_size, SEEK_SET) != 0) ||\r\n                        (sector_size != sim_fread (sector_data, 1, sector_size, container))   ||\r\n                        (0 != memcmp (sector_data, zero_sector, sector_size)))\r\n                        break;\r\n                    if ((0 == (container_size % 1024*1024)))\r\n                        sim_messagef (SCPE_OK, \"Trimming trailing zero containing blocks at lbn: %u         \\r\", (uint32)(container_size / sector_size));\r\n                    container_size -= sector_size;\r\n                    }\r\n                free (sector_data);\r\n                free (zero_sector);\r\n                }\r\n            if (!stop_cpu) {\r\n                if (container_size == initial_container_size) {\r\n                    sim_messagef (SCPE_OK, \"The container was previously completely written with user data\\n\");\r\n                    }\r\n                else {\r\n                    sim_messagef (SCPE_OK, \"Last zero containing block found at lbn: %u          \\n\", (uint32)(container_size / sector_size));\r\n                    sim_messagef (SCPE_OK, \"Trimmed %u zero containing sectors\\n\", (uint32)((initial_container_size - container_size) / sector_size));\r\n                    }\r\n                (void)sim_set_fsize (container, (t_addr)container_size);\r\n                fclose (container);\r\n                sim_set_file_times (FullPath, statb.st_atime, statb.st_mtime);\r\n                info->stat = sim_messagef (SCPE_OK, \"Disk Type Info Removed from container: '%s'\\n\", sim_relative_path (FullPath));\r\n                }\r\n            else {\r\n                fclose (container);\r\n                info->stat = sim_messagef (SCPE_ARG, \"Canceled Disk Type Info Removal from container: '%s'\\n\", sim_relative_path (FullPath));\r\n                }\r\n            stop_cpu = FALSE;\r\n            return;\r\n            }\r\n        }\r\n    fclose (container);\r\n    info->stat = sim_messagef (SCPE_ARG, \"No footer found on disk container '%s'.\\n\", FullPath);\r\n    stop_cpu = FALSE;\r\n    return;\r\n    }\r\nif (info->flag == 0) {  /* DISKINFO */\r\n    DEVICE device, *dptr = &device;\r\n    UNIT unit, *uptr = &unit;\r\n    struct disk_context disk_ctx;\r\n    struct disk_context *ctx = &disk_ctx;\r\n    t_offset (*size_function)(FILE *file);\r\n    int (*close_function)(FILE *f);\r\n    const char *(*parent_path_function)(FILE *f);\r\n    t_offset container_size;\r\n    int32 saved_switches = sim_switches;\r\n    char indent[CBUFSIZE] = \"\";\r\n\r\n    memset (&device, 0, sizeof (device));\r\n    memset (&unit, 0, sizeof (unit));\r\n    memset (&disk_ctx, 0, sizeof (disk_ctx));\r\n    sim_switches |= SWMASK ('E') | SWMASK ('R');   /* Must exist, Read Only */\r\n    uptr->flags |= UNIT_ATTABLE;\r\n    uptr->disk_ctx = &disk_ctx;\r\n    disk_ctx.capac_factor = 1;\r\n    disk_ctx.dptr = uptr->dptr = dptr;\r\n    sim_disk_set_fmt (uptr, 0, \"VHD\", NULL);\r\n    container = sim_vhd_disk_open (FullPath, \"rb\");\r\n    if (container == NULL) {\r\n        sim_disk_set_fmt (uptr, 0, \"SIMH\", NULL);\r\n        container = sim_fopen (FullPath, \"rb\");\r\n        close_function = fclose;\r\n        size_function = sim_fsize_ex;\r\n        parent_path_function = NULL;\r\n        }\r\n    else {\r\n        close_function = sim_vhd_disk_close;\r\n        size_function = sim_vhd_disk_size;\r\n        parent_path_function = sim_vhd_disk_parent_path;\r\n        }\r\n    if (container != NULL) {\r\n        while (container != NULL) {\r\n            container_size = size_function (container);\r\n            uptr->filename = strdup (FullPath);\r\n            uptr->fileref = container;\r\n            uptr->flags |= UNIT_ATT | UNIT_RO;\r\n            get_disk_footer (uptr, NULL);\r\n            f = ctx->footer;\r\n            if (f) {\r\n                t_offset highwater_sector = (f->SectorSize == 0) ? (t_offset)-1 : ((((t_offset)NtoHl (f->Highwater[0])) << 32) | ((t_offset)NtoHl (f->Highwater[1]))) / NtoHl(f->SectorSize);\r\n\r\n                sim_printf (\"%sContainer:              %s\\n\"\r\n                            \"%s   Simulator:           %s\\n\"\r\n                            \"%s   DriveType:           %s\\n\"\r\n                            \"%s   SectorSize:          %u\\n\"\r\n                            \"%s   SectorCount:         %u\\n\"\r\n                            \"%s   ElementEncodingSize: %s\\n\"\r\n                            \"%s   AccessFormat:        %s%s\\n\"\r\n                            \"%s   CreationTime:        %s\",\r\n                            indent, sim_relative_path (uptr->filename),\r\n                            indent, f->CreatingSimulator,\r\n                            indent, f->DriveType,\r\n                            indent, NtoHl(f->SectorSize),\r\n                            indent, NtoHl (f->SectorCount),\r\n                            indent, _disk_tranfer_encoding (NtoHl (f->ElementEncodingSize)),\r\n                            indent, fmts[f->AccessFormat].name,\r\n                            ((parent_path_function == NULL) || (*parent_path_function (container) == '\\0')) ? \"\" : \" - Differencing Disk\",\r\n                            indent, f->CreationTime);\r\n                if (ctime (&filestat->st_mtime))\r\n                    sim_printf (\"%s   ModifyTime:          %s\", indent, ctime (&filestat->st_mtime));\r\n                if (f->DeviceName[0] != '\\0')\r\n                    sim_printf (\"%s   DeviceName:          %s\\n\", indent, (char *)f->DeviceName);\r\n                if (f->DataWidth != 0)\r\n                    sim_printf (\"%s   DataWidth:           %d bits\\n\", indent, NtoHl(f->DataWidth));\r\n                if (f->MediaID != 0)\r\n                    sim_printf (\"%s   MediaID:             0x%08X (%s)\\n\", indent, NtoHl(f->MediaID), sim_disk_decode_mediaid (NtoHl(f->MediaID)));\r\n                if (f->Geometry != 0) {\r\n                    uint32 CHS = NtoHl (f->Geometry);\r\n\r\n                    sim_printf (\"%s   Geometry:            %u Cylinders, %u Heads, %u Sectors\\n\", indent, CHS >> 16, (CHS >> 8) & 0xFF, CHS & 0xFF);\r\n                    }\r\n                if (highwater_sector > 0)\r\n                    sim_printf (\"%s   HighwaterSector:     %u\\n\", indent, (uint32)highwater_sector);\r\n                sim_printf (\"%sContainer Size: %s bytes\\n\", indent, sim_fmt_numeric ((double)ctx->container_size));\r\n                ctx->sector_size = NtoHl(f->SectorSize);\r\n                ctx->xfer_encode_size = NtoHl (f->ElementEncodingSize);\r\n                }\r\n            else {\r\n                sim_printf (\"%sContainer Info metadata for '%s' unavailable\\n\", indent, sim_relative_path (uptr->filename));\r\n                sim_printf (\"%sContainer Size: %s bytes\\n\", indent, sim_fmt_numeric ((double)container_size));\r\n                info->stat = SCPE_ARG|SCPE_NOMESSAGE;\r\n                ctx->sector_size = 512;\r\n                ctx->xfer_encode_size = 1;\r\n                }\r\n            sim_set_uname (uptr, \"FILE\");\r\n            get_filesystem_size (uptr, NULL);\r\n            free (uptr->filename);\r\n            free (ctx->footer);\r\n            ctx->footer = NULL;\r\n            free (uptr->uname);\r\n            uptr->uname = NULL;\r\n            if (parent_path_function != NULL)\r\n                strlcpy (FullPath, parent_path_function (container), sizeof (FullPath));\r\n            close_function (container);\r\n            container = NULL;\r\n            if (parent_path_function != NULL) {\r\n                container = sim_vhd_disk_open (FullPath, \"rb\");\r\n                if (container != NULL) {\r\n                    sim_printf (\"%sDifferencing Disk Parent:\\n\", indent);\r\n                    strlcat (indent, \"    \", sizeof (indent));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    else\r\n        info->stat = sim_messagef (SCPE_OPENERR, \"Cannot open container file '%s' - %s\\n\", FullPath, strerror (errno));\r\n    sim_switches = saved_switches;\r\n    return;\r\n    }\r\n}\r\n\r\nt_stat sim_disk_info_cmd (int32 flag, CONST char *cptr)\r\n{\r\nDISK_INFO_CTX disk_info_state;\r\nt_stat stat;\r\n\r\nif ((!cptr) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nGET_SWITCHES (cptr);                                    /* get switches */\r\nmemset (&disk_info_state, 0, sizeof (disk_info_state));\r\ndisk_info_state.flag = flag;\r\nstat = sim_dir_scan (cptr, sim_disk_info_entry, &disk_info_state);\r\nif (stat == SCPE_OK)\r\n    return disk_info_state.stat;\r\nreturn sim_messagef (SCPE_OK, \"No such file or directory: %s\\n\", cptr);\r\n}\r\n\r\n/*\r\n\r\nMediaId\r\n\r\nIs defined in the MSCP Basic Disk Functions Manual, page 4-37 to 4-38:\r\n\r\nThe media type identifier is a 32-bit number, and it's coded like this:\r\nThe high 25 bits are 5 characters, each coded with 5 bits. The low 7\r\nbits is a binary coded 2 digits.\r\n\r\nLooking at it, you have:\r\nD0,D1,A0,A1,A2,N\r\n\r\nFor an RA81, it would be:\r\n\r\nD0,D1 is the preferred device type name for the unit. In our case,\r\nthat would be \"DU\".\r\nA0,A1,A2 is the name of the media used on the unit. In our case \"RA\".\r\nN is the value of the two decimal digits, so 81 for this example.\r\n\r\nAnd for letters, the coding is that A=1, B=2 and so on. 0 means the\r\ncharacter is not used.\r\n\r\nSo, again, for an RA81, we would get:\r\n\r\nDecimal Values:        4,    21,    18,     1,     0,      81\r\nHex Values:            4,    15,    12,     1,     0,      51\r\nBinary Values:     00100, 10101, 10010, 00001, 00000, 1010001\r\nHex 4 bit Nibbles:    2     5     6     4   1     0     5   1\r\n\r\nThe 32bit value of RA81_MED is 0x25641051\r\n\r\n */\r\nconst char *sim_disk_decode_mediaid (uint32 MediaId)\r\n{\r\nstatic char text[16];\r\nchar D0[2] = \"\";\r\nchar D1[2] = \"\";\r\nchar A0[2] = \"\";\r\nchar A1[2] = \"\";\r\nchar A2[2] = \"\";\r\nuint32 byte;\r\nchar num[4];\r\n\r\nbyte = (MediaId >> 27) & 0x1F;\r\nif (byte)\r\n    snprintf (D0, sizeof (D0), \"%c\", ('A' - 1) + byte);\r\nbyte = (MediaId >> 22) & 0x1F;\r\nif (byte)\r\n    snprintf (D1, sizeof (D1), \"%c\", ('A' - 1) + byte);\r\nbyte = (MediaId >> 17) & 0x1F;\r\nif (byte)\r\n    snprintf (A0, sizeof (A0), \"%c\", ('A' - 1) + byte);\r\nbyte = (MediaId >> 12) & 0x1F;\r\nif (byte)\r\n    snprintf (A1, sizeof (A1), \"%c\", ('A' - 1) + byte);\r\nbyte = (MediaId >> 7) & 0x1F;\r\nif (byte)\r\n    snprintf (A2, sizeof (A2), \"%c\", ('A' - 1) + byte);\r\nsnprintf (num, sizeof (num), \"%02d\", MediaId & 0x7F);\r\nsnprintf (text, sizeof (text), \"%s%s - %s%s%s%s\", D0, D1, A0, A1, num, A2);\r\nreturn text;\r\n}\r\n\r\nuint32 sim_disk_drive_type_to_mediaid (const char *drive_type, const char *device_type)\r\n{\r\nuint32 D0 = 0;\r\nuint32 D1 = 0;\r\nuint32 num = 0;\r\nuint32 A0 = 0;\r\nuint32 A1 = 0;\r\nuint32 A2 = 0;\r\n\r\nif (device_type == NULL)\r\n    return 0;\r\nif (isalpha (device_type[0]))\r\n    D0 = toupper (device_type[0]) - 'A' + 1;\r\nif (isalpha (device_type[1]))\r\n    D1 = toupper (device_type[1]) - 'A' + 1;\r\nif (isalpha (drive_type[0]))\r\n    A0 = toupper (drive_type[0]) - 'A' + 1;\r\nif (isalpha (drive_type[1]))\r\n    A1 = toupper (drive_type[1]) - 'A' + 1;\r\nif (isalpha (drive_type[strlen (drive_type) - 1]))\r\n    A2 = toupper (drive_type[strlen (drive_type) - 1]) - 'A' + 1;\r\nwhile (isalpha (*drive_type))\r\n    ++drive_type;\r\nif (isdigit (*drive_type))\r\n    num = strtoul (drive_type, NULL, 10);\r\nreturn (D0 << 27) | (D1 << 22) | (A0 << 17) | (A1 << 12) | (A2 << 7) | num;\r\n}\r\n\r\nuint32 sim_disk_get_mediaid (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nuint32 result = uptr->drvtyp ? uptr->drvtyp->MediaId : 0;\r\n\r\nif ((ctx != NULL) && (ctx->media_id != 0))\r\n    result = ctx->media_id;\r\nreturn result;\r\n}\r\n\r\nt_stat sim_disk_set_drive_type (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\nDRVTYP *drives = (DRVTYP *)dptr->type_ctx;\r\nuint32 cap;\r\nuint32 max = sim_toffset_64? DRV_EMAXC: DRV_MAXC;\r\nuint32 capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (quadword: 8, word: 2, byte: 1) */\r\nt_stat r;\r\n\r\nif (drives == NULL)\r\n    return SCPE_IERR;\r\nif (uptr->flags & UNIT_ATT)\r\n    return SCPE_ALATT;\r\nif (uptr->drvtyp != NULL) {\r\n    if (((uptr->drvtyp->flags & DRVFL_NOCHNG) != 0) &&\r\n        (strcasecmp (uptr->drvtyp->name, drives[val].name) != 0))\r\n        return sim_messagef (SCPE_ARG, \"%s: Can't change drive type\\n\", sim_uname (uptr));\r\n    if (((uptr->drvtyp->flags & DRVFL_NORMV) != 0) &&\r\n        ((drives[val].flags & DRVFL_RMV) != 0))\r\n        return sim_messagef (SCPE_ARG, \"%s: Can't change unit with a %s to a removable drive type: %s\\n\", sim_uname (uptr), uptr->drvtyp->name, drives[val].name);\r\n    }\r\ncap = (t_addr)drives[val].size;\r\nif (((drives[val].flags & DRVFL_SETSIZE) != 0) && ((cptr == NULL) || (*cptr == '\\0')))\r\n    return sim_messagef (SCPE_ARG, \"%s: Missing Drive size specifier: %s=nnn\\n\", sim_uname (uptr), (drives[val].name_alias != NULL) ? drives[val].name_alias : drives[val].name);\r\nif (cptr) {\r\n    if ((drives[val].flags & DRVFL_SETSIZE) == 0)\r\n        return sim_messagef (SCPE_ARG, \"%s: Unexpected argument: %s\\n\", sim_uname (uptr), cptr);\r\n    cap = (uint32) get_uint (cptr, 10, 0xFFFFFFFF, &r);\r\n    if ((sim_switches & SWMASK ('L')) == 0)\r\n        cap = cap * ((sim_switches & SWMASK ('B')) ? 2048 : 1954);\r\n    if ((r != SCPE_OK) || (cap < DRV_MINC) || (cap > max))\r\n        return sim_messagef (SCPE_ARG, \"%s: Unreasonable capacity: %u\\n\", sim_uname (uptr), cap);\r\n    }\r\nif ((uptr->drvtyp != NULL) &&\r\n    (DRVFL_GET_IFTYPE(uptr->drvtyp) == DRVFL_TYPE_SCSI) &&\r\n    (uptr->drvtyp->devtype != drives[val].devtype)) {\r\n    sim_tape_set_fmt (uptr, 0, \"SIMH\", NULL);\r\n    sim_disk_set_fmt (uptr, 0, \"AUTO\", NULL);\r\n    sim_tape_set_chunk_mode (uptr, ((drives[val].devtype == SCSI_TAPE) &&\r\n                                    (drives[val].flags & DRVFL_QICTAPE)) ? drives[val].sectsize : 0);\r\n    }\r\nuptr->drvtyp = &drives[val];\r\nset_writelock (uptr, ((uptr->drvtyp->flags & DRVFL_RO) != 0), NULL, NULL);\r\nif ((dptr->flags & DEV_SECTORS) == 0)\r\n    cap *= uptr->drvtyp->sectsize / capac_factor;\r\nuptr->capac = (t_addr)cap;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_show_drive_type (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nint toks = 0;\r\n\r\n#define SEP (0 == ((toks++) % 4)) ? \",\\n\\t\" : \", \"\r\nfprintf (st, \"%s\", uptr->drvtyp->name);\r\nif ((uptr->flags & UNIT_ATT) != 0) {\r\n    if (sim_disk_get_mediaid (uptr))\r\n        fprintf (st, \", MediaID=(%s)\", sim_disk_decode_mediaid (sim_disk_get_mediaid (uptr)));\r\n    fprintf (st, \"%ssectors=%u, heads=%u, cylinders=%u, sectorsize=%u\", SEP,\r\n                uptr->drvtyp->sect, uptr->drvtyp->surf, uptr->drvtyp->cyl, uptr->drvtyp->sectsize);\r\n    toks += 3;\r\n    if (sim_switches & SWMASK ('D')) {\r\n        if (uptr->drvtyp->model)\r\n            fprintf (st, \"%smodel=%u\", SEP, uptr->drvtyp->model);\r\n        if (uptr->drvtyp->tpg)\r\n            fprintf (st, \"%stpg=%u\", SEP, uptr->drvtyp->tpg);\r\n        if (uptr->drvtyp->gpc)\r\n            fprintf (st, \"%sgpc=%u\", SEP, uptr->drvtyp->gpc);\r\n        if (uptr->drvtyp->xbn)\r\n            fprintf (st, \"%sxbn=%u\", SEP, uptr->drvtyp->xbn);\r\n        if (uptr->drvtyp->dbn)\r\n            fprintf (st, \"%sdbn=%u\", SEP, uptr->drvtyp->dbn);\r\n        if (uptr->drvtyp->rcts)\r\n            fprintf (st, \"%srcts=%u\", SEP, uptr->drvtyp->rcts);\r\n        if (uptr->drvtyp->rctc)\r\n            fprintf (st, \"%srctc=%u\", SEP, uptr->drvtyp->rctc);\r\n        if (uptr->drvtyp->rbn)\r\n            fprintf (st, \"%srbn=%u\", SEP, uptr->drvtyp->rbn);\r\n        if (uptr->drvtyp->rctc)\r\n            fprintf (st, \"%srctc=%u\", SEP, uptr->drvtyp->rctc);\r\n        if (uptr->drvtyp->rbn)\r\n            fprintf (st, \"%srbn=%u\", SEP, uptr->drvtyp->rbn);\r\n        if (uptr->drvtyp->cylp)\r\n            fprintf (st, \"%scylp=%u\", SEP, uptr->drvtyp->cylp);\r\n        if (uptr->drvtyp->cylr)\r\n            fprintf (st, \"%scylr=%u\", SEP, uptr->drvtyp->cylr);\r\n        if (uptr->drvtyp->ccs)\r\n            fprintf (st, \"%sccs=%u\", SEP, uptr->drvtyp->ccs);\r\n        if (DRVFL_GET_IFTYPE(uptr->drvtyp) == DRVFL_TYPE_SCSI)\r\n            fprintf (st, \"%sdevtype=%u\", SEP, uptr->drvtyp->devtype);\r\n        if (uptr->drvtyp->pqual)\r\n            fprintf (st, \"%spqual=%u\", SEP, uptr->drvtyp->pqual);\r\n        if (uptr->drvtyp->scsiver)\r\n            fprintf (st, \"%sscsiver=%u\", SEP, uptr->drvtyp->scsiver);\r\n        if (uptr->drvtyp->manufacturer)\r\n            fprintf (st, \"%smanufacturer=%s\", SEP, uptr->drvtyp->manufacturer);\r\n        if (uptr->drvtyp->product)\r\n            fprintf (st, \"%sproduct=%s\", SEP, uptr->drvtyp->product);\r\n        if (uptr->drvtyp->rev)\r\n            fprintf (st, \"%srev=%s\", SEP, uptr->drvtyp->rev);\r\n        if (uptr->drvtyp->gaplen)\r\n            fprintf (st, \"%sgaplen=%u\", SEP, uptr->drvtyp->gaplen);\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nconst char *sim_disk_drive_type_set_string (UNIT *uptr)\r\n{\r\nstatic char typestr[80];\r\n\r\nif (uptr->drvtyp) {\r\n    if ((uptr->drvtyp->flags & DRVFL_SETSIZE) != 0) {\r\n        uint32 totsectors = (uint32)(((uptr->dptr->flags & DEV_SECTORS) == 0)\r\n                                                  ? (uptr->capac / uptr->drvtyp->sectsize)\r\n                                                  : uptr->capac);\r\n        snprintf (typestr, sizeof (typestr), \"-L %s=%u\", uptr->drvtyp->name, totsectors);\r\n        }\r\n    else\r\n        snprintf (typestr, sizeof (typestr), \"%s\", uptr->drvtyp->name);\r\n    return typestr;\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n\r\nt_stat sim_disk_set_drive_type_by_name (UNIT *uptr, const char *drive_type)\r\n{\r\nDEVICE *dptr;\r\nchar cmd[CBUFSIZE];\r\nt_bool dev_disabled, unit_disabled;\r\nt_stat r;\r\n\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_IERR;\r\ndev_disabled = (dptr->flags & DEV_DIS);\r\nunit_disabled = uptr->flags & UNIT_DIS;\r\ndptr->flags &= ~DEV_DIS;                    /* Assure that the DEVICE and UNIT */\r\nuptr->flags &= ~UNIT_DIS;                   /* are enabled so the SET command works */\r\nsnprintf (cmd, sizeof (cmd), \"%s %s\", sim_uname (uptr), drive_type);\r\nr = set_cmd (0, cmd);\r\nif (dev_disabled)                           /* restore DEVICE enabled state */\r\n    dptr->flags |= DEV_DIS;\r\nif (unit_disabled)                          /* restore UNIT enabled state */\r\n    uptr->flags |= UNIT_DIS;\r\nreturn r;\r\n}\r\n\r\nstatic DRVTYP *sim_disk_find_type (UNIT *uptr, const char *dtype)\r\n{\r\nint i, j;\r\nDEVICE *dptr;\r\n\r\nif ((uptr->drvtyp != NULL) && (strcasecmp (uptr->drvtyp->name, dtype) == 0))\r\n    return uptr->drvtyp;\r\nfor (i = 0; (dptr = sim_devices[i]) != NULL; i++) {\r\n    DRVTYP *drvtypes = (DRVTYP *)dptr->type_ctx;\r\n\r\n    if (((DEV_TYPE(dptr) != DEV_DISK) && (DEV_TYPE(dptr) != DEV_SCSI)) ||\r\n        (drvtypes == NULL))\r\n        continue;\r\n    for (j = 0; drvtypes[j].name; j++) {\r\n        if (strcasecmp (drvtypes[j].name, dtype) == 0)\r\n            return &drvtypes[j];\r\n        }\r\n    }\r\nreturn NULL;\r\n}\r\n\r\n\r\n/* disk testing */\r\n\r\nstruct disk_test_coverage {\r\n    t_lba total_sectors;\r\n    uint32 max_xfer_size;\r\n    t_seccnt max_xfer_sectors;\r\n    uint32 wsetbits;\r\n    uint32 *wbitmap;\r\n    uint32 *data;\r\n    };\r\n\r\nstatic t_stat sim_disk_test_exercise (UNIT *uptr)\r\n{\r\nstruct disk_context *ctx = (struct disk_context *)uptr->disk_ctx;\r\nstruct disk_test_coverage *c = (struct disk_test_coverage *)calloc (1, sizeof (*c));\r\nt_stat r = SCPE_OK;\r\nuint32 uint32s_per_sector = (ctx->sector_size / sizeof (*c->data));\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\nuint32 capac_factor = ((dptr->dwidth / dptr->aincr) >= 32) ? 8 : ((dptr->dwidth / dptr->aincr) == 16) ? 2 : 1; /* capacity units (quadword: 8, word: 2, byte: 1) */\r\nuint32 tries = 0;\r\nt_bool unexpected_data = FALSE;\r\n\r\nif (!(uptr->flags & UNIT_RO)) { /* Only test drives open Read/Write - Read Only due to container larger than drive */\r\n    c->max_xfer_size = 1024*1024;\r\n    c->max_xfer_sectors = c->max_xfer_size / ctx->sector_size;\r\n    c->total_sectors = (t_lba)((uptr->capac*capac_factor)/(ctx->sector_size/((dptr->flags & DEV_SECTORS) ? ((ctx->sector_size >=  512) ? 512 : ctx->sector_size): 1)));\r\n    c->data = (uint32 *)malloc (c->max_xfer_size);\r\n    c->wbitmap = (uint32 *)calloc ((c->total_sectors + 32)/32, sizeof (*c->wbitmap));\r\n#define BITMAP_IS_SET(n) (c->wbitmap[(n) >> 5] & (1 << ((n) & 0x1f)))\r\n#define SET_BITMAP(n) c->wbitmap[(n) >> 5] |= (1 << ((n) & 0x1f))\r\n    /* Randomly populate the whole drive container with known data (sector # in each sector) */\r\n    srand (0);\r\n    while (c->wsetbits < c->total_sectors) {\r\n        t_lba start_lba = (rand () % c->total_sectors);\r\n        t_lba end_lba = start_lba + 1 + (rand () % (c->max_xfer_sectors - 1));\r\n        t_lba lba;\r\n        t_seccnt i, sectors_to_write, sectors_written;\r\n\r\n        if (end_lba > c->total_sectors)\r\n            end_lba = c->total_sectors;\r\n        if (BITMAP_IS_SET(start_lba)) {\r\n            ++tries;\r\n            if (tries < 30)\r\n                continue;\r\n            while (BITMAP_IS_SET(start_lba))\r\n                start_lba = (1 + start_lba) % c->total_sectors;\r\n            end_lba = start_lba + 1;\r\n            }\r\n        tries = 0;\r\n        for (lba = start_lba; lba < end_lba; lba++) {\r\n            if (BITMAP_IS_SET(lba)) {\r\n                end_lba = lba;\r\n                break;\r\n                }\r\n            SET_BITMAP(lba);\r\n            ++c->wsetbits;\r\n            }\r\n        sectors_to_write = end_lba - start_lba;\r\n        for (i=0; i < sectors_to_write * uint32s_per_sector; i++)\r\n            c->data[i] = start_lba + i / uint32s_per_sector;\r\n        r = sim_disk_wrsect (uptr, start_lba, (uint8 *)c->data, &sectors_written, sectors_to_write);\r\n        if (r != SCPE_OK) {\r\n            sim_printf (\"Error writing sectors %u thru %u: %s\\n\", start_lba, end_lba - 1, sim_error_text (r));\r\n            break;\r\n            }\r\n        else {\r\n            if (sectors_to_write != sectors_written) {\r\n                sim_printf (\"Unexpectedly wrote %u sectors instead of %u sectors starting at lba %u\\n\", sectors_written, sectors_to_write, start_lba);\r\n                break;\r\n                }\r\n            }\r\n        }\r\n    if (r == SCPE_OK) {\r\n        t_seccnt sectors_read, sectors_to_read, sector_to_check;\r\n        t_lba lba;\r\n\r\n        sim_printf(\"Writing OK\\n\");\r\n        for (lba = 0; (lba < c->total_sectors) && (r == SCPE_OK); lba += sectors_read) {\r\n            sectors_to_read = 1 + (rand () % (c->max_xfer_sectors - 1));\r\n            if (lba + sectors_to_read > c->total_sectors)\r\n                sectors_to_read = c->total_sectors - lba;\r\n            r = sim_disk_rdsect (uptr, lba, (uint8 *)c->data, &sectors_read, sectors_to_read);\r\n            if (r == SCPE_OK) {\r\n                if (sectors_read != sectors_to_read) {\r\n                    sim_printf (\"Only returned %u sectors when reading %u sectors from lba %u\\n\", sectors_read, sectors_to_read, lba);\r\n                    r = SCPE_INCOMP;\r\n                    }\r\n                }\r\n            else\r\n                sim_printf (\"Error reading %u sectors at lba %u, %u read - %s\\n\", sectors_to_read, lba, sectors_read, sim_error_text (r));\r\n            for (sector_to_check = 0; sector_to_check < sectors_read; ++sector_to_check) {\r\n                uint32 i;\r\n\r\n                for (i = 0; i < uint32s_per_sector; i++)\r\n                    if (c->data[i + sector_to_check * uint32s_per_sector] != (lba + sector_to_check)) {\r\n                        sim_printf (\"Sector %u(0x%X) has unexpected data at offset 0x%X: 0x%08X\\n\",\r\n                                    lba + sector_to_check, lba + sector_to_check, i, c->data[i + sector_to_check * uint32s_per_sector]);\r\n                        unexpected_data = TRUE;\r\n                        break;\r\n                        }\r\n                }\r\n            }\r\n        if ((r == SCPE_OK) && !unexpected_data)\r\n            sim_printf(\"Reading OK\\n\");\r\n        else {\r\n            sim_printf(\"Reading BAD\\n\");\r\n            r = SCPE_IERR;\r\n            }\r\n        }\r\n    if (r == SCPE_OK) { /* If still good, then do EOF and beyond boundary test */\r\n        t_offset current_unit_size = ((t_offset)uptr->capac)*ctx->capac_factor*((dptr->flags & DEV_SECTORS) ? ctx->sector_size : 1);\r\n        t_seccnt sectors_read, sectors_to_read;\r\n        t_lba lba = (t_lba)(current_unit_size / ctx->sector_size) - 2;\r\n        int i;\r\n\r\n        sectors_to_read = 1;\r\n        for (i = 0; (i < 4) && (r == SCPE_OK); i++) {\r\n            r = sim_disk_rdsect (uptr, lba + i, (uint8 *)c->data, &sectors_read, sectors_to_read);\r\n            if ((r != SCPE_OK) || (sectors_read != sectors_to_read))\r\n                r = SCPE_IERR;\r\n            }\r\n        }\r\n    }\r\nfree (c->data);\r\nfree (c->wbitmap);\r\nfree (c);\r\nif (r == SCPE_OK) {\r\n    char *filename = strdup (uptr->filename);\r\n\r\n    sim_disk_detach (uptr);\r\n    (void)remove (filename);\r\n    free (filename);\r\n    }\r\nreturn r;\r\n}\r\n\r\nstatic t_stat _sim_disk_test_create (const char *container, size_t size)\r\n{\r\nFILE *f = fopen (container, \"w\");\r\nt_stat r = SCPE_OPENERR;\r\n\r\nif (NULL == f)\r\n    return SCPE_OPENERR;\r\nif (0 == sim_set_fsize (f, (t_addr)size))\r\n    r = SCPE_OK;\r\nfclose (f);\r\nreturn r;\r\n}\r\n\r\n/* Autosizing and Meta data testing support. */\r\n/* Only operate on specific disk cases: */\r\n/* Device: */\r\n/*   RL  - 2 different disk sizes to autosize between */\r\n/*   RQ  - Arbitrary disk size change supported */\r\n/*   RK  - 1 sized disk with reserved cylinders */\r\nt_stat sim_disk_sizing_test (DEVICE *dptr, const char *cptr)\r\n{\r\nchar filename[256] = \"TestFile.dsk\";\r\nUNIT *uptr = &dptr->units[0];\r\nt_stat r = SCPE_OK;\r\nint specific_test = -1;\r\nstatic struct {\r\n    int32       switches;\r\n    t_offset    container_size;\r\n    t_bool      autosize_attach;\r\n    t_offset    pseudo_fs_size;\r\n    t_stat      exp_attach_status;\r\n    t_stat      unit_ro_attach;\r\n    t_bool      has_footer;\r\n    const char *drive_type;\r\n    const char *device_name;\r\n    int         testid;\r\n    } tests[] = {\r\n#define DMB 1024*1024\r\n#define DKB 1024\r\n      /* switches   containersize        autosize      fs_size          status    ro_after    footer   type        device   testid*/\r\n        {0,              4800*512,          FALSE,    4800*512,        SCPE_OK,      FALSE,     TRUE,    NULL,       \"RK\",    25},\r\n        {0,              2436*DKB,          FALSE,    4800*512,        SCPE_OK,      FALSE,     TRUE,    NULL,       \"RK\",    24},\r\n        {SWMASK ('R'),   2436*DKB,          FALSE,    4800*512,        SCPE_OK,       TRUE,    FALSE,    NULL,       \"RK\",    23},\r\n        {0,                     0,          FALSE,    4800*512,        SCPE_OK,      FALSE,     TRUE,    NULL,       \"RK\",    22},\r\n        {0,                 7*DMB,           TRUE,     500*DMB,        SCPE_OK,       TRUE,    FALSE, \"RRD40\",       \"RQ\",    21},\r\n        {0,                 7*DMB,          FALSE,     500*DMB,        SCPE_OK,       TRUE,    FALSE, \"RRD40\",       \"RQ\",    20},\r\n        {0,                 7*DMB,           TRUE,      20*DMB,        SCPE_OK,      FALSE,     TRUE,  \"RD51\",       \"RQ\",    19},\r\n        {0,                 4*DMB,          FALSE,      20*DMB,    SCPE_FSSIZE,      FALSE,    FALSE,  \"RD51\",       \"RQ\",    18},\r\n        {0,                30*DMB,          FALSE,           0,        SCPE_OK,       TRUE,    FALSE,  \"RD51\",       \"RQ\",    17},\r\n        {0,                     0,          FALSE,           0,        SCPE_OK,      FALSE,     TRUE,  \"RD51\",       \"RQ\",    16},\r\n        {SWMASK ('R'),     20*DKB,          FALSE,           0,        SCPE_OK,       TRUE,    FALSE,  \"RD51\",       \"RQ\",    15},\r\n        {SWMASK ('R'),     20*DKB,          FALSE,           0,        SCPE_OK,       TRUE,    FALSE,  \"RL01\",       \"RL\",    14},\r\n        {0,                20*DKB,          FALSE,      10*DMB,    SCPE_FSSIZE,      FALSE,    FALSE,  \"RL01\",       \"RL\",    13},\r\n        {0,                20*DKB,           TRUE,      13*DMB,    SCPE_FSSIZE,      FALSE,    FALSE,  \"RL01\",       \"RL\",    12},\r\n        {SWMASK ('Y'),          0,           TRUE,           0,        SCPE_OK,      FALSE,     TRUE,  \"RL01\",       \"RL\",    11},\r\n        {0,                20*DMB,           TRUE,           0,    SCPE_FSSIZE,      FALSE,    FALSE,  \"RL01\",       \"RL\",    10},\r\n        {0,                20*DKB,           TRUE,           0,        SCPE_OK,      FALSE,    FALSE,  \"RL01\",       \"RL\",     9},\r\n        {0,                20*DKB,           TRUE,       5*DMB,        SCPE_OK,      FALSE,     TRUE,  \"RL01\",       \"RL\",     8},\r\n        {0,                20*DMB,          FALSE,           0,        SCPE_OK,       TRUE,    FALSE,  \"RL01\",       \"RL\",     7},\r\n        {0,                20*DKB,          FALSE,           0,        SCPE_OK,      FALSE,    FALSE,  \"RL01\",       \"RL\",     6},\r\n        {0,                20*DKB,          FALSE,       5*DMB,        SCPE_OK,      FALSE,     TRUE,  \"RL01\",       \"RL\",     5},\r\n        {SWMASK ('Y'),          0,          FALSE,           0,        SCPE_OK,      FALSE,     TRUE,  \"RL02\",       \"RL\",     4},\r\n        {0,                20*DMB,          FALSE,           0,        SCPE_OK,       TRUE,    FALSE,  \"RL02\",       \"RL\",     3},\r\n        {0,                20*DKB,          FALSE,           0,        SCPE_OK,      FALSE,    FALSE,  \"RL02\",       \"RL\",     2},\r\n        {0,                20*DKB,          FALSE,       5*DMB,        SCPE_OK,      FALSE,    FALSE,  \"RL02\",       \"RL\",     1},\r\n        {0,0,0,0,0,0}\r\n    };\r\n\r\nsim_printf (\"\\n*** Container sizing behavior tests\\n\");\r\nif ((cptr != NULL) && (isdigit (*cptr)))\r\n    specific_test = atoi (cptr);\r\nif ((0 == strcmp (\"RL\", dptr->name)) ||\r\n    (0 == strcmp (\"RQ\", dptr->name)) ||\r\n    (0 == strcmp (\"RK\", dptr->name))) {\r\n    int i;\r\n\r\n    (void)remove (filename);\r\n    for (i=0; tests[i].device_name != NULL; i++) {\r\n        char cmd[32];\r\n\r\n        if (0 != strcmp (tests[i].device_name, dptr->name))\r\n            continue;\r\n        if ((specific_test != -1) && (tests[i].testid != specific_test))\r\n            continue;\r\n        sim_printf (\"%d : Attaching %s with a %s byte container\\n\", tests[i].testid, sim_uname (uptr), sim_fmt_numeric ((double)tests[i].container_size));\r\n        sim_printf (\"%d : Device Type: %s, %sAutoSize\\n\", tests[i].testid, tests[i].drive_type ? tests[i].drive_type : tests[i].device_name, tests[i].autosize_attach ? \"\" : \"No\");\r\n        if (tests[i].pseudo_fs_size)\r\n            sim_printf (\"%d : File System Size: %s\\n\", tests[i].testid, sim_fmt_numeric ((double)tests[i].pseudo_fs_size));\r\n        else\r\n            sim_printf (\"%d : No File System\\n\", tests[i].testid);\r\n        sim_switches = tests[i].switches;\r\n        sprintf(cmd, \"%s %sAUTOSIZE\", sim_uname (uptr), tests[i].autosize_attach ? \"\" : \"NO\");\r\n        set_cmd (0, cmd);\r\n        if (tests[i].drive_type != NULL) {\r\n            sprintf(cmd, \"%s %s\", sim_uname (uptr), tests[i].drive_type);\r\n            set_cmd (0, cmd);\r\n            }\r\n        if (tests[i].container_size)\r\n            _sim_disk_test_create (filename, (size_t)tests[i].container_size);\r\n        pseudo_filesystem_size = tests[i].pseudo_fs_size;\r\n        r = dptr->attach (uptr, filename);\r\n        sim_printf (\"%d: %s attach status. Expected: %s, Got: %s\\n\", tests[i].testid, (SCPE_BARE_STATUS (r) == SCPE_OK) ? \"Success\" : \"Failure\", sim_error_text (tests[i].exp_attach_status), sim_error_text (r));\r\n        if (SCPE_BARE_STATUS (r) == SCPE_OK)\r\n            show_cmd (0, sim_uname (uptr));\r\n        if (SCPE_BARE_STATUS (r) != tests[i].exp_attach_status) {\r\n            if (SCPE_BARE_STATUS (r) == SCPE_OK)\r\n                sim_printf (\"%d: UNEXPECTED Success attach status. Expected: %s\\n\", tests[i].testid, sim_error_text (tests[i].exp_attach_status));\r\n            else\r\n                sim_printf (\"%d: UNEXPECTED Failure attach status: %s\\n\", tests[i].testid, sim_error_text (SCPE_BARE_STATUS (r)));\r\n            return SCPE_INCOMP;\r\n            }\r\n        if ((SCPE_BARE_STATUS (r) == SCPE_OK) && (((uptr->flags & UNIT_RO) != 0) != tests[i].unit_ro_attach))\r\n            r = SCPE_OK; /* Error */\r\n        sim_disk_detach (uptr);\r\n        if ((SCPE_OK == sim_disk_info_cmd (0, filename)) != tests[i].has_footer) {\r\n            if (tests[i].has_footer)\r\n                sim_printf (\"%d: Expected metadata missing\\n\", tests[i].testid);\r\n            else\r\n                sim_printf (\"%d: Unexpected metadata found\\n\", tests[i].testid);\r\n            return SCPE_INCOMP;\r\n            }\r\n        pseudo_filesystem_size = 0;\r\n        (void)remove (filename);\r\n        sim_printf (\"\\n\");\r\n        }\r\n    }\r\nreturn r;\r\n}\r\n\r\nt_stat sim_disk_meta_attach_test (DEVICE *dptr, const char *cptr)\r\n{\r\nchar **tarfiles = sim_get_filelist (\"../Test-Disks/*.tar.gz\");\r\nchar cmd[CBUFSIZE];\r\n\r\nsim_printf (\"\\n*** Containers with meta data tests\\n\");\r\nif (tarfiles == NULL)\r\n    tarfiles = sim_get_filelist (\"./Test-Disks/*.tar.gz\");\r\nif (tarfiles == NULL)\r\n    tarfiles = sim_get_filelist (\"./Visual Studio Projects/Test-Disks/*.tar.gz\");\r\nsim_printf (\"Tar File containing test disk images: \");\r\nsim_print_filelist (tarfiles);\r\nif (tarfiles) {\r\n    char **dskfiles = sim_get_filelist (\"*.dsk.meta\");\r\n\r\n    if (dskfiles != NULL) {\r\n        sim_printf (\"Existing test disk containers:\\n\");\r\n        sim_print_filelist (dskfiles);\r\n        }\r\n    else {\r\n        sim_printf (\"Extracting test disk containers from: %s\\n\", tarfiles[0]);\r\n        if (strchr (tarfiles[0], ' '))\r\n            snprintf (cmd, sizeof (cmd), \"xf \\\"%s\\\"\", tarfiles[0]);\r\n        else\r\n            snprintf (cmd, sizeof (cmd), \"xf %s\", tarfiles[0]);\r\n        tar_cmd (0, cmd);\r\n        dskfiles = sim_get_filelist (\"*.dsk.meta\");\r\n        sim_printf (\"Extracted test disk containers:\\n\");\r\n        sim_print_filelist (dskfiles);\r\n        }\r\n    if (dskfiles == NULL) {\r\n        sim_printf (\"No test disk meta data containers were found.\\n\");\r\n        }\r\n    else {\r\n        int i;\r\n        UNIT *uptr = &dptr->units[0];\r\n        t_stat r;\r\n\r\n        for (i = 0; dskfiles[i] != NULL; i++) {\r\n            char *drive_type = sim_filepath_parts (dskfiles[i], \"n\");\r\n            const char *specific_file = ((cptr != NULL) && (*cptr != '\\0') && (!isdigit (*cptr))) ? cptr : NULL;\r\n            char *file_name = sim_filepath_parts (dskfiles[i], \"nx\");\r\n\r\n            r = SCPE_OK;\r\n            if ((specific_file == NULL) || (0 == strcasecmp (file_name, specific_file))) {\r\n                if (strchr (drive_type, '.'))\r\n                    *(strchr (drive_type, '.')) = '\\0';\r\n                sim_printf (\"\\n\");\r\n                sim_printf (\"Attaching %s disk image '%s' to %s...\\n\", drive_type, dskfiles[i], sim_uname (uptr));\r\n                sim_disk_info_cmd (0, dskfiles[i]);\r\n                snprintf (cmd, sizeof (cmd), \"%s RD51\", sim_uname (uptr));\r\n                set_cmd (0, \"NOMESSAGE\");\r\n                set_cmd (0, cmd);\r\n                set_cmd (0, \"MESSAGE\");\r\n                snprintf (cmd, sizeof (cmd), \"%s %s\", sim_uname (uptr), drive_type);\r\n                sim_switches = 0;\r\n                set_cmd (0, cmd);\r\n                r = dptr->attach (uptr, dskfiles[i]);\r\n                sim_disk_detach (uptr);\r\n                sim_printf (\"%s: %s read/write attach status: %s\\n\", drive_type, (SCPE_BARE_STATUS (r) == SCPE_OK) ? \"Success\" : \"Failure\", sim_error_text (r));\r\n                if ((SCPE_BARE_STATUS (r) != SCPE_OK)      &&\r\n                    (SCPE_BARE_STATUS (r) != SCPE_OPENERR) &&\r\n                    (SCPE_BARE_STATUS (r) != SCPE_INCOMPDSK)) {\r\n                    free (drive_type);\r\n                    free (file_name);\r\n                    return r;\r\n                    }\r\n                sim_switches = SWMASK ('R');\r\n                r = dptr->attach (uptr, dskfiles[i]);\r\n                sim_disk_detach (uptr);\r\n                sim_printf (\"%s: %s read only attach status: %s\\n\", drive_type, (SCPE_BARE_STATUS (r) == SCPE_OK) ? \"Success\" : \"Failure\", sim_error_text (r));\r\n                if ((SCPE_BARE_STATUS (r) != SCPE_OK)      &&\r\n                    (SCPE_BARE_STATUS (r) != SCPE_OPENERR) &&\r\n                    (SCPE_BARE_STATUS (r) != SCPE_INCOMPDSK)) {\r\n                    free (drive_type);\r\n                    free (file_name);\r\n                    return r;\r\n                    }\r\n                }\r\n            free (drive_type);\r\n            free (file_name);\r\n            }\r\n        }\r\n    sim_free_filelist (&dskfiles);\r\n    }\r\nsim_free_filelist (&tarfiles);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_disk_test (DEVICE *dptr, const char *cptr)\r\n{\r\nconst char *fmt[] = {\"RAW\", \"VHD\", \"VHD\", \"SIMH\", NULL};\r\nuint32 sect_size[] = {576, 4096, 1024, 512, 256, 128, 64, 0};\r\nuint32 xfr_size[] = {1, 2, 4, 8, 0};\r\nint x, s, f;\r\nUNIT *uptr = &dptr->units[0];\r\nchar filename[256];\r\nt_stat r;\r\nint32 saved_switches = sim_switches & ~SWMASK('T');\r\nSIM_TEST_INIT;\r\n\r\nif (sim_switches & SWMASK ('M')) { /* Do meta first? */\r\n    sim_switches = saved_switches &= ~SWMASK ('M');\r\n    SIM_TEST (sim_disk_meta_attach_test (dptr, cptr));\r\n    SIM_TEST (sim_disk_sizing_test (dptr, cptr));\r\n    }\r\nelse {\r\n    SIM_TEST (sim_disk_sizing_test (dptr, cptr));\r\n    SIM_TEST (sim_disk_meta_attach_test (dptr, cptr));\r\n    }\r\nsim_printf (\"\\n*** Disk Format combination behavior tests\\n\");\r\nfor (x = 0; xfr_size[x] != 0; x++) {\r\n    for (f = 0; fmt[f] != 0; f++) {\r\n        for (s = 0; sect_size[s] != 0; s++) {\r\n            snprintf (filename, sizeof (filename), \"Test-%u-%u.%s\", sect_size[s], xfr_size[x], fmt[f]);\r\n            if ((f > 0) && (strcmp (fmt[f], \"VHD\") == 0) && (strcmp (fmt[f - 1], \"VHD\") == 0)) { /* Second VHD is Fixed */\r\n                sim_switches |= SWMASK('X');\r\n                snprintf (filename, sizeof (filename), \"Test-%u-%u-Fixed.%s\", sect_size[s], xfr_size[x], fmt[f]);\r\n                }\r\n            else\r\n                sim_switches = saved_switches;\r\n            (void)remove (filename);        /* Remove any prior remnants */\r\n            r = sim_disk_set_fmt (uptr, 0, fmt[f], NULL);\r\n            if (r != SCPE_OK)\r\n                break;\r\n            sim_printf (\"Testing %s (%s) using %s\\n\", sim_uname (uptr), sprint_capac (dptr, uptr), filename);\r\n            if (strcmp (fmt[f], \"RAW\") == 0) {\r\n                /* There is no innate creation of RAW containers, so create the empty container using SIMH format */\r\n                sim_disk_set_fmt (uptr, 0, \"SIMH\", NULL);\r\n                sim_disk_attach_ex (uptr, filename, sect_size[s], xfr_size[x], TRUE, 0, NULL, 0, 0, NULL);\r\n                sim_disk_detach (uptr);\r\n                sim_disk_set_fmt (uptr, 0, fmt[f], NULL);\r\n                }\r\n            r = sim_disk_attach_ex (uptr, filename, sect_size[s], xfr_size[x], TRUE, 0, NULL, 0, 0, NULL);\r\n            if ((r != SCPE_OK) &&\r\n                (SCPE_BARE_STATUS (r) != SCPE_INCOMPDSK))\r\n                break;\r\n            if (r == SCPE_OK)\r\n                SIM_TEST (sim_disk_test_exercise (uptr));\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n"
        },
        {
          "name": "sim_disk.h",
          "type": "blob",
          "size": 13.6494140625,
          "content": "/* sim_disk.h: simulator disk support library definitions\r\n\r\n   Copyright (c) 2011, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the names of Robert M Supnik and\r\n   Mark Pizzolato shall not be used in advertising or otherwise to promote\r\n   the sale, use or other dealings in this Software without prior written\r\n   authorization from Robert M Supnik and Mark Pizzolato.\r\n\r\n   25-Jan-11    MP      Initial Implementation\r\n*/\r\n\r\n#ifndef SIM_DISK_H_\r\n#define SIM_DISK_H_    0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* SIMH/Disk format */\r\n\r\ntypedef uint32          t_seccnt;                       /* disk sector count */\r\ntypedef uint32          t_lba;                          /* disk logical block address */\r\n\r\n/* Unit flags */\r\n\r\n#define DKUF_V_FMT      (UNIT_V_UF + 0)                 /* disk file format */\r\n#define DKUF_W_FMT      2                               /* 2b of container formats */\r\n#define DKUF_M_FMT      ((1u << DKUF_W_FMT) - 1)\r\n#define DKUF_V_ENC      (DKUF_V_FMT + DKUF_W_FMT)       /* data encoding/packing */\r\n#define DKUF_W_ENC      2                               /* 2b of data encoding/packing */\r\n#define DKUF_M_ENC      ((1u << DKUF_W_ENC) - 1)\r\n#define DKUF_V_NOAUTOSIZE (DKUF_V_ENC + DKUF_W_ENC)     /* Don't Autosize disk option */\r\n#define DKUF_V_AUTOZAP  (DKUF_V_NOAUTOSIZE + 1)         /* Auto ZAP disk option */\r\n#define DKUF_V_UF       (DKUF_V_AUTOZAP + 1)\r\n#define DKUF_WLK        UNIT_WLK\r\n#define DKUF_FMT        (DKUF_M_FMT << DKUF_V_FMT)\r\n#define DKUF_ENC        (DKUF_M_ENC << DKUF_V_ENC)\r\n#define DKUF_WRP        (DKUF_WLK | UNIT_RO)\r\n#define DKUF_NOAUTOSIZE (1 << DKUF_V_NOAUTOSIZE)\r\n#define DKUF_AUTOZAP    (1 << DKUF_V_AUTOZAP)\r\n\r\n/* Encoding/Packing specfics */\r\n\r\n#define DK_ENC_BYTE         0x00000001\r\n#define DK_ENC_WORD         0x00000002\r\n#define DK_ENC_LONG         0x00000004\r\n#define DK_ENC_LONGLONG     0x00000008\r\n#define DK_ENC_X_LSB        0x80\r\n#define DK_ENC_X_MSB        0x00\r\n#define DK_ENC_XFR_IN       0\r\n#define DK_ENC_XFR_OUT      16\r\n#define DK_ENC_LL_DBD9      (((DK_ENC_X_LSB | 64) << DK_ENC_XFR_OUT) | ((DK_ENC_X_MSB | 36) << DK_ENC_XFR_IN))\r\n#define DK_ENC_LL_DLD9      (((DK_ENC_X_LSB | 64) << DK_ENC_XFR_OUT) | ((DK_ENC_X_LSB | 36) << DK_ENC_XFR_IN))\r\n\r\n/* Return status codes */\r\n\r\n#define DKSE_OK         0                               /* no error */\r\n\r\ntypedef void (*DISK_PCALLBACK)(UNIT *unit, t_stat status);\r\n\r\n/* Prototypes */\r\n\r\nt_stat sim_disk_init (void);\r\nt_stat sim_disk_attach (UNIT *uptr,\r\n                        const char *cptr,\r\n                        size_t memory_sector_size,  /* memory footprint of sector data */\r\n                        size_t xfer_element_size,\r\n                        t_bool dontchangecapac,     /* if false just change uptr->capac as needed */\r\n                        uint32 debugbit,            /* debug bit */\r\n                        const char *drivetype,      /* drive type */\r\n                        uint32 pdp11_tracksize,     /* BAD144 track */\r\n                        int completion_delay);      /* Minimum Delay for asynch I/O completion */\r\nt_stat sim_disk_attach_ex (UNIT *uptr,\r\n                           const char *cptr,\r\n                           size_t memory_sector_size,   /* memory footprint of sector data */\r\n                           size_t xfer_element_size,\r\n                           t_bool dontchangecapac,      /* if false just change uptr->capac as needed */\r\n                           uint32 dbit,                 /* debug bit */\r\n                           const char *dtype,           /* drive type */\r\n                           uint32 pdp11tracksize,       /* BAD144 track */\r\n                           int completion_delay,        /* Minimum Delay for asynch I/O completion */\r\n                           const char **drivetypes);    /* list of drive types (from smallest to largest) */\r\n                                                        /* to try and fit the container/file system into */\r\nt_stat sim_disk_attach_ex2 (UNIT *uptr,\r\n                            const char *cptr,\r\n                            size_t memory_sector_size,  /* memory footprint of sector data */\r\n                            size_t xfer_element_size,\r\n                            t_bool dontchangecapac,     /* if false just change uptr->capac as needed */\r\n                            uint32 dbit,                /* debug bit */\r\n                            const char *dtype,          /* drive type */\r\n                            uint32 pdp11tracksize,      /* BAD144 track */\r\n                            int completion_delay,       /* Minimum Delay for asynch I/O completion */\r\n                            const char **drivetypes,    /* list of drive types (from smallest to largest) */\r\n                                                        /* to try and fit the container/file system into */\r\n                            size_t reserved_sectors);   /* Unused sectors beyond the file system */\r\nt_stat sim_disk_detach (UNIT *uptr);\r\nt_stat sim_disk_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr);\r\nt_stat sim_disk_rdsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects);\r\nt_stat sim_disk_rdsect_a (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectsread, t_seccnt sects, DISK_PCALLBACK callback);\r\nt_stat sim_disk_wrsect (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects);\r\nt_stat sim_disk_wrsect_a (UNIT *uptr, t_lba lba, uint8 *buf, t_seccnt *sectswritten, t_seccnt sects, DISK_PCALLBACK callback);\r\nt_stat sim_disk_unload (UNIT *uptr);\r\nt_stat sim_disk_erase (UNIT *uptr);\r\nt_stat sim_disk_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_disk_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_disk_set_capac (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_disk_show_capac (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_disk_set_autosize (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_disk_show_autosize (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_disk_set_asynch (UNIT *uptr, int latency);\r\nt_stat sim_disk_clr_asynch (UNIT *uptr);\r\nt_stat sim_disk_reset (UNIT *uptr);\r\nt_stat sim_disk_perror (UNIT *uptr, const char *msg);\r\nt_stat sim_disk_clearerr (UNIT *uptr);\r\nt_bool sim_disk_isavailable (UNIT *uptr);\r\nt_bool sim_disk_isavailable_a (UNIT *uptr, DISK_PCALLBACK callback);\r\nt_bool sim_disk_wrp (UNIT *uptr);\r\nt_stat sim_disk_pdp11_bad_block (UNIT *uptr, int32 sec, int32 wds);\r\nconst char *sim_disk_decode_mediaid (uint32 MediaId);\r\nuint32 sim_disk_drive_type_to_mediaid (const char *drive_type, const char *device_type);\r\nuint32 sim_disk_get_mediaid (UNIT *uptr);\r\nt_offset sim_disk_size (UNIT *uptr);\r\nt_bool sim_disk_vhd_support (void);\r\nt_bool sim_disk_raw_support (void);\r\nvoid sim_disk_data_trace (UNIT *uptr, const uint8 *data, size_t lba, size_t len, const char* txt, int detail, uint32 reason);\r\nt_stat sim_disk_info_cmd (int32 flag, CONST char *ptr);\r\nt_stat sim_disk_set_all_noautosize (int32 flag, CONST char *cptr);\r\nt_stat sim_disk_set_all_autozap (int32 flag, CONST char *cptr);\r\nt_stat sim_disk_set_drive_type (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_disk_set_drive_type_by_name (UNIT *uptr, const char *drive_type);\r\nt_stat sim_disk_show_drive_type (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nconst char *sim_disk_drive_type_set_string (UNIT *uptr);\r\nt_stat sim_disk_test (DEVICE *dptr, const char *cptr);\r\n\r\n\r\nstruct DRVTYP {\r\n    uint32      sect;           /* sectors */\r\n    uint32      surf;           /* surfaces */\r\n    uint32      cyl;            /* cylinders */\r\n    uint32      size;           /* size in LBNs */\r\n    const char  *name;          /* name */\r\n    uint32      sectsize;       /* sector size in bytes */\r\n    uint32      flags;          /* flags */\r\n    const char  *driver_name;   /* OS Driver device name */\r\n    uint32      MediaId;        /* MSCP media id */\r\n    uint32      model;          /* model */\r\n    const char  *name_alias;    /* Alias device type name */\r\n    const char  *name_desc;     /* Descriptive Text for device type */\r\n    uint32      uint32_01;      /* #1 device specific parameter */\r\n    uint32      uint32_02;      /* #2 device specific parameter */\r\n    uint32      uint32_03;      /* #3 device specific parameter */\r\n    uint32      uint32_04;      /* #4 device specific parameter */\r\n    uint32      uint32_05;      /* #5 device specific parameter */\r\n    uint32      uint32_06;      /* #6 device specific parameter */\r\n    uint32      uint32_07;      /* #7 device specific parameter */\r\n    uint32      uint32_08;      /* #8 device specific parameter */\r\n    uint32      uint32_09;      /* #9 device specific parameter */\r\n    uint32      uint32_10;      /* #10 device specific parameter */\r\n    uint32      uint32_11;      /* #11 device specific parameter */\r\n    uint32      uint32_12;      /* #12 device specific parameter */\r\n    uint32      uint32_13;      /* #13 device specific parameter */\r\n    const char *str_01;         /* #1 device specific string */\r\n    const char *str_02;         /* #2 device specific string  */\r\n    const char *str_03;         /* #3 device specific string */\r\n    uint32      uint32_14;      /* #14 device specific parameter */\r\n    };\r\n/* MSCP specific drive parameters */\r\n#define tpg     uint32_01       /* trk/grp */\r\n#define gpc     uint32_02       /* grp/cyl */\r\n#define xbn     uint32_03       /* XBN size */\r\n#define dbn     uint32_04       /* DBN size */\r\n#define rcts    uint32_05       /* RCT size */\r\n#define rctc    uint32_06       /* RCT copies */\r\n#define rbn     uint32_07       /* RBNs */\r\n#define cylp    uint32_08       /* first cyl for write precomp */\r\n#define cylr    uint32_09       /* first cyl for reduced write current */\r\n#define ccs     uint32_10       /* cyl/cyl skew */\r\n/* SCSI specific drive parameters */\r\n#define devtype uint32_11       /* SCSI Device Type */\r\n#define pqual   uint32_12       /* SCSI pqual */\r\n#define scsiver uint32_13       /* SCSI scsi version */\r\n#define manufacturer str_01     /* SCSI manufacturer string */\r\n#define product      str_02     /* SCSI product string */\r\n#define rev          str_03     /* SCSI revision string */\r\n#define gaplen  uint32_14       /* SCSI tape gap length */\r\n\r\n\r\n\r\n\r\n/* Contents/Values in DRVTYP.flags field */\r\n\r\n#define DRVFL_V_TYPE    0                       /* Interface Type */\r\n#define DRVFL_W_TYPE    5\r\n#define DRVFL_M_TYPE    ((1u << DRVFL_W_TYPE) - 1)\r\n#define DRVFL_TYPE_MFM  (0 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_SDI  (1 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_RC   (2 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_DSSI (3 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_SCSI (4 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_RM   (5 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_RP   (6 << DRVFL_V_TYPE)\r\n#define DRVFL_TYPE_RL   (7 << DRVFL_V_TYPE)\r\n#define DRVFL_GET_IFTYPE(drv) (((drv)->flags >> DRVFL_V_TYPE) & DRVFL_M_TYPE)\r\n#define DRVFL_V_RMV     (DRVFL_V_TYPE + DRVFL_W_TYPE)\r\n#define DRVFL_RMV       (1u << DRVFL_V_RMV)     /* Removable */\r\n#define DRVFL_V_RO      (DRVFL_V_RMV + 1)\r\n#define DRVFL_RO        (1u << DRVFL_V_RO)      /* Read Only */\r\n#define DRVFL_V_DEC144  (DRVFL_V_RO + 1)\r\n#define DRVFL_DEC144    (1u << DRVFL_V_DEC144)  /* DEC 144 Bad Block track */\r\n#define DRVFL_V_SETSIZE (DRVFL_V_DEC144 + 1)\r\n#define DRVFL_SETSIZE   (1u << DRVFL_V_SETSIZE) /* Settable Drive Size/Capacity */\r\n#define DRVFL_V_NOCHNG  (DRVFL_V_SETSIZE + 1)\r\n#define DRVFL_NOCHNG    (1u << DRVFL_V_NOCHNG)  /* Can't change drive type once set */\r\n#define DRVFL_V_DETAUTO (DRVFL_V_NOCHNG + 1)\r\n#define DRVFL_DETAUTO   (1u << DRVFL_V_DETAUTO) /* Don't Autosize attach, write metadata on detach*/\r\n#define DRVFL_V_NORMV   (DRVFL_V_DETAUTO + 1)\r\n#define DRVFL_NORMV     (1u << DRVFL_V_NORMV)   /* Can't change to a removable drive */\r\n#define DRVFL_V_QICTAPE (DRVFL_V_NORMV + 1)\r\n#define DRVFL_QICTAPE   (1u << DRVFL_V_QICTAPE) /* drive is a QIC (Quarter Inch Cartridge) tape */\r\n\r\n/* DRVTYP Initializer for SCSI disk and/or tape */\r\n#define DRV_SCSI(typ, pq, ver, rmv, bsz, sect, surf, cyl, lbn, man, prd, rev, nm, gap, txt) \\\r\n    sect, surf, cyl, lbn, nm, bsz,                                                          \\\r\n    DRVFL_TYPE_SCSI | ((rmv == TRUE) ? DRVFL_RMV|DRVFL_QICTAPE : 0),                        \\\r\n    NULL, 0, 0, NULL, txt,                                                                  \\\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                                                           \\\r\n    typ, pq, ver, man, prd, rev, gap\r\n\r\n#define DRV_MINC       512                             /* min cap LBNs */\r\n#define DRV_MAXC       4194303                         /* max cap LBNs */\r\n#define DRV_EMAXC      2147483647                      /* ext max cap */\r\n\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_ether.c",
          "type": "blob",
          "size": 171.18359375,
          "content": "/* sim_ether.c: OS-dependent network routines\r\n  ------------------------------------------------------------------------------\r\n   Copyright (c) 2002-2007, David T. Hittner\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n\r\n  ------------------------------------------------------------------------------\r\n\r\n  This ethernet simulation is based on the PCAP and WinPcap packages.\r\n\r\n  PCAP/WinPcap was chosen as the basis for network code since it is the most\r\n  \"universal\" of the various network packages available. Using this style has\r\n  allowed rapid network development for the major SIMH platforms. Developing\r\n  a network package specifically for SIMH was rejected due to the time required;\r\n  the advantage would be a more easily compiled and integrated code set.\r\n\r\n  There are various problems associated with use of ethernet networking, which\r\n  would be true regardless of the network package used, since there are no\r\n  universally accepted networking methods. The most serious of these is getting\r\n  the proper networking package loaded onto the system, since most environments\r\n  do not come with the network interface packages loaded.\r\n\r\n  The second most serious network issue relates to security. The network\r\n  simulation needs to simulate operating system level functionality (packet\r\n  driving). However, the host network programming interfaces tend to operate at\r\n  the user level of functionality, so getting to the full functionality of\r\n  the network interface usually requires that the person executing the\r\n  network code be a privileged user of the host system. See the PCAP/WinPcap\r\n  documentation for the appropriate host platform if unprivileged use of\r\n  networking is needed - there may be known workarounds.\r\n\r\n  Define one of the two macros below to enable networking:\r\n    USE_NETWORK - Create statically linked network code\r\n    USE_SHARED  - Create dynamically linked network code\r\n\r\n  ------------------------------------------------------------------------------\r\n\r\n  Supported/Tested Platforms:\r\n\r\n  Windows(NT,2K,XP,2K3,Vista,Win7)     WinPcap-4.1.3 Npcap-V0.9994\r\n  Linux                     libpcap at least 0.9\r\n  OpenBSD,FreeBSD,NetBSD    libpcap at least 0.9\r\n  MAC OS/X                  libpcap at least 0.9\r\n  Solaris Sparc             libpcap at least 0.9\r\n  Solaris Intel             libpcap at least 0.9\r\n  AIX                       ??\r\n  HP/UX                     ??\r\n  Compaq Tru64 Unix         ??\r\n  VMS                       Alpha/Itanium VMS only, needs VMS libpcap\r\n\r\n  WinPcap is no longer developed or supported but was available from:\r\n                        http://winpcap.polito.it/\r\n  Npcap is a complete replacement for systems running Windows7 and later\r\n  and is available from:\r\n                        https://nmap.org/npcap\r\n  libpcap for VMS is available from:\r\n                        http://simh.trailing-edge.com/sources/vms-pcap.zip\r\n  libpcap for other Unix platforms is available at:\r\n        NOTE: As of the release of this version of sim_ether.c ALL current\r\n              *nix platforms ship with a sufficiently new version of\r\n              libpcap, and ALL provide a libpcap-dev package for developing\r\n              libpcap based applications.  The OS vendor supplied version\r\n              of libpcap AND the libpcap-dev components are preferred for\r\n              proper operation of both simh AND other applications on the\r\n              host system which use libpcap.\r\n        Current Version:  http://www.tcpdump.org/daily/libpcap-current.tar.gz\r\n        Released Version: http://www.tcpdump.org/release/\r\n\r\n        When absolutely necessary (see NOTE above about vendor supplied\r\n        libpcap), we've gotten the tarball, unpacked, built and installed\r\n        it with:\r\n            gzip -dc libpcap-current.tar.gz | tar xvf -\r\n            cd libpcap-directory-name\r\n            ./configure\r\n            make\r\n            make install\r\n        Note:  The \"make install\" step generally will have to be done as root.\r\n        This will install libpcap in /usr/local/lib and /usr/local/include\r\n        The current simh makefile will do the right thing to locate and\r\n        reference the OS provided libpcap or the one just installed.\r\n\r\n\r\n  Note: Building for the platforms indicated above, with the indicated libpcap,\r\n  should automatically leverage the appropriate mechanisms contained here.\r\n  Things are structured so that it is likely to work for any other as yet\r\n  untested platform.  If it works for you, please let the author know so we\r\n  can update the table above.  If it doesn't work, then the following #define\r\n  variables can influence the operation on an untested platform.\r\n\r\n  USE_BPF           - Determines if this code leverages a libpcap/WinPcap\r\n                      provided bpf packet filtering facility.  All tested\r\n                      environments have bpf facilities that work the way we\r\n                      need them to.  However a new one might not.  undefine\r\n                      this variable to let this code do its own filtering.\r\n  USE_SETNONBLOCK   - Specifies whether the libpcap environment's non-blocking\r\n                      semantics are to be leveraged.  This helps to manage the\r\n                      varying behaviours of the kernel packet facilities\r\n                      leveraged by libpcap.\r\n  USE_READER_THREAD - Specifies that packet reading should be done in the\r\n                      context of a separate thread.  The Posix threading\r\n                      APIs are used.  This option is less efficient than the\r\n                      default non-threaded approach, but it exists since some\r\n                      platforms don't want to work with nonblocking libpcap\r\n                      semantics.   OpenBSD and NetBSD either don't have pthread\r\n                      APIs available, or they are too buggy to be useful.\r\n                      Using the threaded approach may require special compile\r\n                      and/or link time switches (i.e. -lpthread or -pthread,\r\n                      etc.) Consult the documentation for your platform as\r\n                      needed.  Although this may be 'less efficient' than the\r\n                      non-threaded approach, the efficiency is an overall system\r\n                      efficiency not necessarily a simulator efficiency.  This\r\n                      means that work is removed from the thread executing\r\n                      simulated instructions so the simulated system will most\r\n                      likely run faster (given that modern host CPUs are\r\n                      multi-core and have someplace to do this work in parallel).\r\n  MUST_DO_SELECT    - Specifies that, when USE_READER_THREAD is active,\r\n                      select() should be used to determine when available\r\n                      packets are ready for reading.  Otherwise, we depend\r\n                      on the libpcap/kernel packet timeout specified on\r\n                      pcap_open_live.  If USE_READER_THREAD is not set, then\r\n                      MUST_DO_SELECT is irrelevant\r\n  HAVE_TAP_NETWORK  - Specifies that support for tap networking should be\r\n                      included.  This can be leveraged, along with OS bridging\r\n                      capabilities to share a single LAN interface.  This\r\n                      allows device names of the form tap:tap0 to be specified\r\n                      at open time.  This functionality is only useful/needed\r\n                      on *nix platforms since native sharing of Windows NIC\r\n                      devices works with no external magic.\r\n  HAVE_VDE_NETWORK  - Specifies that support for vde networking should be\r\n                      included.  This can be leveraged, along with OS bridging\r\n                      capabilities to share a single LAN interface.  It also\r\n                      can allow a simulator to have useful networking\r\n                      functionality when running without root access.  This\r\n                      allows device names of the form vde:/tmp/switch to be\r\n                      specified at open time.  This functionality is only\r\n                      available on *nix platforms since the vde api isn't\r\n                      available on Windows.\r\n  HAVE_SLIRP_NETWORK- Specifies that support for SLiRP networking should be\r\n                      included.  This can be leveraged to provide User Mode\r\n                      IP NAT connectivity for simulators.\r\n\r\n  NEED_PCAP_SENDPACKET\r\n                    - Specifies that you are using an older version of libpcap\r\n                      which doesn't provide a pcap_sendpacket API.\r\n\r\n  NOTE: Changing these defines is done in either sim_ether.h OR on the global\r\n        compiler command line which builds all of the modules included in a\r\n        simulator.\r\n\r\n  ------------------------------------------------------------------------------\r\n\r\n  Modification history:\r\n\r\n  30-Mar-12  MP   Added host NIC address determination on supported VMS platforms\r\n  01-Mar-12  MP   Made host NIC address determination on *nix platforms more\r\n                  robust.\r\n  01-Mar-12  MP   Added host NIC address determination work when building\r\n                  under Cygwin\r\n  01-Mar-12  AGN  Add conditionals for Cygwin dynamic loading of wpcap.dll\r\n  01-Mar-12  AGN  Specify the full /usr/lib for dlopen under Apple Mac OS X.\r\n  17-Nov-11  MP   Added dynamic loading of libpcap on *nix platforms\r\n  30-Oct-11  MP   Added support for vde (Virtual Distributed Ethernet) networking\r\n  29-Oct-11  MP   Added support for integrated Tap networking interfaces on OSX\r\n  12-Aug-11  MP   Cleaned up payload length determination\r\n                  Fixed race condition detecting reflections when threaded\r\n                  reading and writing is enabled\r\n  18-Apr-11  MP   Fixed race condition with self loopback packets in\r\n                  multithreaded environments\r\n  09-Jan-11  MP   Fixed missing crc data when USE_READER_THREAD is defined and\r\n                  crc's are needed (only the pdp11_xu)\r\n  16-Dec-10  MP   added priority boost for read and write threads when\r\n                  USE_READER_THREAD does I/O in separate threads.  This helps\r\n                  throughput since it allows these I/O bound threads to preempt\r\n                  the main thread (which is executing simulated instructions).\r\n  09-Dec-10  MP   allowed more flexible parsing of MAC address strings\r\n  09-Dec-10  MP   Added support to determine if network address conflicts exist\r\n  07-Dec-10  MP   Reworked DECnet self detection to the more general approach\r\n                  of loopback self when a Physical Address is being set.\r\n  04-Dec-10  MP   Changed eth_write to do nonblocking writes when\r\n                  USE_READER_THREAD is defined.\r\n  20-Aug-10  TVO  Fix for Mac OSX 10.6\r\n  17-Jun-10  MP   Fixed bug in the AUTODIN II hash filtering.\r\n  14-Jun-10  MP   Added support for integrated Tap networking interfaces on BSD\r\n                  platforms.\r\n  13-Jun-10  MP   Added support for integrated Tap networking interfaces on Linux\r\n                  platforms.\r\n  31-May-10  MP   Added support for more TOE (TCP Offload Engine) features for IPv4\r\n                  network traffic from the host and/or from hosts on the LAN.  These\r\n                  new TOE features are: LSO (Large Send Offload) and Jumbo packet\r\n                  fragmentation support.  These features allow a simulated network\r\n                  device to support traffic when a host leverages a NIC's Large\r\n                  Send Offload capabilities to fragment and/or segment outgoing\r\n                  network traffic.  Additionally a simulated network device can\r\n                  reasonably exist on a LAN which is configured to use Jumbo frames.\r\n  21-May-10  MP   Added functionality to fixup IP header checksums to accomodate\r\n                  packets from a host with a NIC which has TOE (TCP Offload Engine)\r\n                  enabled which is expected to implement the checksum computations\r\n                  in hardware.  Since we catch packets before they arrive at the\r\n                  NIC the expected checksum insertions haven't been performed yet.\r\n                  This processing is only done for packets sent from the host to\r\n                  the guest we're supporting.  In general this will be a relatively\r\n                  small number of packets so it is done for all IP frame packets\r\n                  coming from the host to the guest.  In order to make the\r\n                  determination of packets specifically arriving from the host we\r\n                  need to know the hardware MAC address of the host NIC.  Currently\r\n                  determining a NIC's MAC address is relatively easy on Windows.\r\n                  The non-windows code works on linux and may work on other *nix\r\n                  platforms either as is or with slight modifications.  The code,\r\n                  as implemented, only messes with this activity if the host\r\n                  interface MAC address can be determined.\r\n  20-May-10  MP   Added general support to deal with receiving packets smaller\r\n                  than ETH_MIN_PACKET in length.  These come from packets\r\n                  looped back by some bridging mechanism and need to be padded\r\n                  to the minimum frame size.  A real NIC won't pass us any\r\n                  packets like that.  This fix belongs here since this layer\r\n                  is responsible for interfacing to they physical layer\r\n                  devices, AND it belongs here to get CRC processing right.\r\n  05-Mar-08  MP   Added optional multicast filtering support for doing\r\n                  LANCE style AUTODIN II based hashed filtering.\r\n  07-Feb-08  MP   Added eth_show_dev to display ethernet state\r\n                  Changed the return value from eth_read to return whether\r\n                  or not a packet was read.  No existing callers used or\r\n                  checked constant return value that previously was being\r\n                  supplied.\r\n  29-Jan-08  MP   Added eth_set_async to provide a mechanism (when\r\n                  USE_READER_THREAD is enabled) to allow packet reception\r\n                  to dynamically update the simulator event queue and\r\n                  potentially avoid polling for I/O.  This provides a minimal\r\n                  overhead (no polling) maximal responsiveness for network\r\n                  activities.\r\n  29-Jan-08  MP   Properly sequenced activities in eth_close to avoid a race\r\n                  condition when USE_READER_THREAD is enabled.\r\n  25-Jan-08  MP   Changed the following when USE_READER_THREAD is enabled:\r\n                  - Fixed bug when the simulated device doesn't need crc\r\n                    in packet data which is read.\r\n                  - Added call to pcap_setmintocopy to minimize packet\r\n                    delivery latencies.\r\n                  - Added ethq_destroy and used it to avoid a memory leak in\r\n                    eth_close.\r\n                  - Properly cleaned up pthread mutexes in eth_close.\r\n                  Migrated to using sim_os_ms_sleep for a delay instead of\r\n                  a call to select().\r\n                  Fixed the bpf filter used when no traffic is to be matched.\r\n                  Reworked eth_add_packet_crc32 implementation to avoid an\r\n                  extra buffer copy while reading packets.\r\n                  Fixedup #ifdef's relating to USE_SHARED so that setting\r\n                  USE_SHARED or USE_NETWORK will build a working network\r\n                  environment.\r\n  23-Jan-08  MP   Reworked eth_packet_trace and eth_packet_trace_ex to allow\r\n                  only output ethernet header+crc and provide a mechanism for\r\n                  the simulated device to display full packet data debugging.\r\n  17-May-07  DTH  Fixed non-ethernet device removal loop (from Naoki Hamada)\r\n  15-May-07  DTH  Added dynamic loading of wpcap.dll;\r\n                  Corrected exceed max index bug in ethX lookup\r\n  04-May-07  DTH  Corrected failure to look up ethernet device names in\r\n                  the registry on Windows XP x64\r\n  10-Jul-06  RMS  Fixed linux conditionalization (from Chaskiel Grundman)\r\n  02-Jun-06  JDB  Fixed compiler warning for incompatible sscanf parameter\r\n  15-Dec-05  DTH  Patched eth_host_pcap_devices [remove non-ethernet devices]\r\n                  (from Mark Pizzolato and Galen Tackett, 08-Jun-05)\r\n                  Patched eth_open [tun fix](from Antal Ritter, 06-Oct-05)\r\n  30-Nov-05  DTH  Added option to regenerate CRC on received packets; some\r\n                  ethernet devices need to pass it on to the simulation, and by\r\n                  the time libpcap/winpcap gets the packet, the host OS network\r\n                  layer has already stripped CRC out of the packet\r\n  01-Dec-04  DTH  Added Windows user-defined adapter names (from Timothe Litt)\r\n  25-Mar-04  MP   Revised comments and minor #defines to deal with updated\r\n                  libpcap which now provides pcap_sendpacket on all platforms.\r\n  04-Feb-04  MP   Returned success/fail status from eth_write to support\r\n                  determining if the current libpcap connection can successfully\r\n                  write packets.\r\n                  Added threaded approach to reading packets since\r\n                  this works better on some platforms (solaris intel) than the\r\n                  inconsistently implemented non-blocking read approach.\r\n  04-Feb-04  DTH  Converted ETH_DEBUG to sim_debug\r\n  13-Jan-04  MP   tested and fixed on OpenBSD, NetBS and FreeBSD.\r\n  09-Jan-04  MP   removed the BIOCSHDRCMPLT ioctl() for OS/X\r\n  05-Jan-04  DTH  Added eth_mac_scan\r\n  30-Dec-03  DTH  Cleaned up queue routines, added no network support message\r\n  26-Dec-03  DTH  Added ethernet show and queue functions from pdp11_xq\r\n  15-Dec-03  MP   polished generic libpcap support.\r\n  05-Dec-03  DTH  Genericized eth_devices() and #ifdefs\r\n  03-Dec-03  MP   Added Solaris support\r\n  02-Dec-03  DTH  Corrected decnet fix to use reflection counting\r\n  01-Dec-03  DTH  Added BPF source filtering and reflection counting\r\n  28-Nov-03  DTH  Rewrote eth_devices using universal pcap_findalldevs()\r\n  25-Nov-03  DTH  Verified DECNET_FIX, reversed ifdef to mainstream code\r\n  19-Nov-03  MP   Fixed BPF functionality on Linux/BSD.\r\n  17-Nov-03  DTH  Added xBSD simplification\r\n  14-Nov-03  DTH  Added #ifdef DECNET_FIX for problematic duplicate detection code\r\n  13-Nov-03  DTH  Merged in __FreeBSD__ support\r\n  21-Oct-03  MP   Added enriched packet dumping for debugging\r\n  20-Oct-03  MP   Added support for multiple ethernet devices on VMS\r\n  20-Sep-03  Ankan Add VMS support (Alpha only)\r\n  29-Sep-03  MP   Changed separator character in eth_fmt_mac to be \":\" to\r\n                  format ethernet addresses the way the BPF compile engine\r\n                  wants to see them.\r\n                  Added BPF support to filter packets\r\n                  Added missing printf in eth_close\r\n  07-Jun-03  MP   Added WIN32 support for DECNET duplicate address detection.\r\n  06-Jun-03  MP   Fixed formatting of Ethernet Protocol Type in eth_packet_trace\r\n  30-May-03  DTH  Changed WIN32 to _WIN32 for consistency\r\n  07-Mar-03  MP   Fixed Linux implementation of PacketGetAdapterNames to also\r\n                  work on Red Hat 6.2-sparc and Debian 3.0r1-sparc.\r\n  03-Mar-03  MP   Changed logging to be consistent on stdout and sim_log\r\n  01-Feb-03  MP   Changed type of local variables in eth_packet_trace to\r\n                  conform to the interface needs of eth_mac_fmt which produces\r\n                  char data instead of unsigned char data.  Suggested by the\r\n                  DECC compiler.\r\n  15-Jan-03  DTH  Corrected PacketGetAdapterNames parameter2 datatype\r\n  26-Dec-02  DTH  Merged Mark Pizzolato's enhancements with main source\r\n                  Added networking documentation\r\n                  Changed _DEBUG to ETH_DEBUG\r\n  20-Dec-02  MP   Added display of packet CRC to the eth_packet_trace.\r\n                  This helps distinguish packets with identical lengths\r\n                  and protocols.\r\n  05-Dec-02  MP   With the goal of draining the input buffer more rapidly\r\n                  changed eth_read to call pcap_dispatch repeatedly until\r\n                  either a timeout returns nothing or a packet allowed by\r\n                  the filter is seen.  This more closely reflects how the\r\n                  pcap layer will work when the filtering is actually done\r\n                  by a bpf filter.\r\n  31-Oct-02  DTH  Added USE_NETWORK conditional\r\n                  Reworked not attached test\r\n                  Added OpenBSD support (from Federico Schwindt)\r\n                  Added ethX detection simplification (from Megan Gentry)\r\n                  Removed sections of temporary code\r\n                  Added parameter validation\r\n  23-Oct-02  DTH  Beta 5 released\r\n  22-Oct-02  DTH  Added all_multicast and promiscuous support\r\n                  Fixed not attached behavior\r\n  21-Oct-02  DTH  Added NetBSD support (from Jason Thorpe)\r\n                  Patched buffer size to make sure entire packet is read in\r\n                  Made 'ethX' check characters passed as well as length\r\n                  Corrected copyright again\r\n  16-Oct-02  DTH  Beta 4 released\r\n                  Corrected copyright\r\n  09-Oct-02  DTH  Beta 3 released\r\n                  Added pdp11 write acceleration (from Patrick Caulfield)\r\n  08-Oct-02  DTH  Beta 2 released\r\n                  Integrated with 2.10-0p4\r\n                  Added variable vector and copyrights\r\n  04-Oct-02  DTH  Added linux support (from Patrick Caulfield)\r\n  03-Oct-02  DTH  Beta version of xq/sim_ether released for SIMH 2.09-11\r\n  24-Sep-02  DTH  Finished eth_devices, eth_getname\r\n  18-Sep-02  DTH  Callbacks implemented\r\n  13-Sep-02  DTH  Basic packet read/write written\r\n  20-Aug-02  DTH  Created Sim_Ether for O/S independent ethernet implementation\r\n\r\n  ------------------------------------------------------------------------------\r\n*/\r\n\r\n\r\n#include \"sim_ether.h\"\r\n#include \"sim_sock.h\"\r\n#include \"sim_timer.h\"\r\n\r\n#include \"sim_scp_private.h\"\r\n\r\n#if defined(_WIN32)\r\n#include <direct.h>\r\n#else\r\n#include <unistd.h>\r\n#endif\r\n\r\n#if defined (USE_READER_THREAD)\r\n#include <pthread.h>\r\n#endif\r\n\r\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\r\n\r\n/* Internal routine - forward declaration */\r\nstatic int _eth_get_system_id (char *buf, size_t buf_size);\r\nstatic void eth_get_nic_hw_addr(ETH_DEV* dev, const char *devname, int set_on);\r\n\r\nstatic const unsigned char framer_oui[3] = { 0xaa, 0x00, 0x03 };\r\n\r\n/*============================================================================*/\r\n/*                  OS-independent ethernet routines                          */\r\n/*============================================================================*/\r\n\r\nt_stat eth_mac_scan (ETH_MAC* mac, const char* strmac)\r\n{\r\nreturn eth_mac_scan_ex (mac, strmac, NULL);\r\n}\r\n\r\nt_stat eth_mac_scan_ex (ETH_MAC* mac, const char* strmac, UNIT *uptr)\r\n{\r\n  unsigned int a[6], g[6];\r\n  FILE *f;\r\n  char filebuf[64] = \"\";\r\n  uint32 i;\r\n  static const ETH_MAC zeros = {0,0,0,0,0,0};\r\n  static const ETH_MAC ones  = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\r\n  ETH_MAC newmac;\r\n  struct {\r\n      uint32 bits;\r\n      char system_id[64];\r\n      char cwd[PATH_MAX];\r\n      char file[PATH_MAX];\r\n      ETH_MAC base_mac;\r\n      char uname[64];\r\n      char sim[128];\r\n      } state;\r\n  CONST char *cptr, *tptr;\r\n  uint32 data;\r\n\r\n  /* Allow generated MAC address */\r\n  /* XX:XX:XX:XX:XX:XX{/bits{>file}} */\r\n  /* bits (if specified) must be from 16 thru 48 */\r\n\r\n  memset (&state, 0, sizeof(state));\r\n  _eth_get_system_id (state.system_id, sizeof(state.system_id));\r\n  strlcpy (state.sim, sim_name, sizeof(state.sim));\r\n  if (getcwd (state.cwd, sizeof(state.cwd))) {};\r\n  if (uptr)\r\n    strlcpy (state.uname, sim_uname (uptr), sizeof(state.uname));\r\n  cptr = strchr (strmac, '>');\r\n  if (cptr) {\r\n    state.file[sizeof(state.file)-1] = '\\0';\r\n    strlcpy (state.file, cptr + 1, sizeof(state.file));\r\n    if ((f = fopen (state.file, \"r\"))) {\r\n      filebuf[sizeof(filebuf)-1] = '\\0';\r\n      if (fgets (filebuf, sizeof(filebuf)-1, f)) {};\r\n      strmac = filebuf;\r\n      fclose (f);\r\n      strcpy (state.file, \"\");  /* avoid saving */\r\n      }\r\n    }\r\n  cptr = strchr (strmac, '/');\r\n  if (cptr) {\r\n    state.bits = (uint32)strtotv (cptr + 1, &tptr, 10);\r\n    if ((state.bits < 16) || (state.bits > 48))\r\n      return sim_messagef (SCPE_ARG, \"Invalid MAC address bits specifier '%d'. Valid values are from 16 thru 48\\n\", state.bits);\r\n    }\r\n  else\r\n    state.bits = 48;\r\n  data = eth_crc32 (0, (void *)&state, sizeof(state));\r\n  for (i=g[0]=g[1]=0; i<4; i++)\r\n    g[i+2] = (data >> (i << 3)) & 0xFF;\r\n  if ((6 != sscanf(strmac, \"%x:%x:%x:%x:%x:%x\", &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) &&\r\n      (6 != sscanf(strmac, \"%x.%x.%x.%x.%x.%x\", &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) &&\r\n      (6 != sscanf(strmac, \"%x-%x-%x-%x-%x-%x\", &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])))\r\n    return sim_messagef (SCPE_ARG, \"Invalid MAC address format: '%s'\\n\", strmac);\r\n  for (i=0; i<6; i++)\r\n    if (a[i] > 0xFF)\r\n      return sim_messagef (SCPE_ARG, \"Invalid MAC address byte value: %02X\\n\", a[i]);\r\n    else {\r\n      uint32 mask, shift;\r\n\r\n      state.base_mac[i] = a[i];\r\n      if (((i + 1) << 3) < state.bits)\r\n          shift = 0;\r\n      else\r\n          shift = ((i + 1) << 3) - state.bits;\r\n      mask = 0xFF << shift;\r\n      newmac[i] = (unsigned char)((a[i] & mask) | (g[i] & ~mask));\r\n      }\r\n\r\n  /* final check - mac cannot be broadcast or multicast address */\r\n  if (!memcmp(newmac, zeros, sizeof(ETH_MAC)) ||  /* broadcast */\r\n      !memcmp(newmac, ones,  sizeof(ETH_MAC)) ||  /* broadcast */\r\n      (newmac[0] & 0x01)                          /* multicast */\r\n     )\r\n    return sim_messagef (SCPE_ARG, \"Can't use Broadcast or MultiCast address as interface MAC address\\n\");\r\n\r\n  /* new mac is OK */\r\n  /* optionally save */\r\n  if (state.file[0]) {              /* Save File specified? */\r\n    f = fopen (state.file, \"w\");\r\n    if (f == NULL)\r\n      return sim_messagef (SCPE_ARG, \"Can't open MAC address configuration file '%s'.\\n\", state.file);\r\n    eth_mac_fmt (&newmac, filebuf);\r\n    fprintf (f, \"%s/48\\n\", filebuf);\r\n    fprintf (f, \"system-id: %s\\n\", state.system_id);\r\n    fprintf (f, \"directory: %s\\n\", state.cwd);\r\n    fprintf (f, \"simulator: %s\\n\", state.sim);\r\n    fprintf (f, \"device:    %s\\n\", state.uname);\r\n    fprintf (f, \"file:      %s\\n\", state.file);\r\n    eth_mac_fmt (&state.base_mac, filebuf);\r\n    fprintf (f, \"base-mac:  %s\\n\", filebuf);\r\n    fprintf (f, \"specified: %d bits\\n\", state.bits);\r\n    fprintf (f, \"generated: %d bits\\n\", 48-state.bits);\r\n    fclose (f);\r\n    }\r\n  /* copy into passed mac */\r\n  memcpy (*mac, newmac, sizeof(ETH_MAC));\r\n  return SCPE_OK;\r\n}\r\n\r\nvoid eth_mac_fmt(ETH_MAC* const mac, char* buff)\r\n{\r\n  const uint8* m = (const uint8*) mac;\r\n  sprintf(buff, \"%02X:%02X:%02X:%02X:%02X:%02X\", m[0], m[1], m[2], m[3], m[4], m[5]);\r\n  return;\r\n}\r\n\r\nstatic const uint32 crcTable[256] = {\r\n  0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,\r\n  0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\r\n  0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,\r\n  0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\r\n  0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,\r\n  0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\r\n  0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,\r\n  0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\r\n  0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,\r\n  0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\r\n  0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,\r\n  0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\r\n  0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,\r\n  0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\r\n  0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,\r\n  0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\r\n  0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,\r\n  0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\r\n  0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,\r\n  0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\r\n  0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,\r\n  0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\r\n  0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,\r\n  0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\r\n  0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,\r\n  0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\r\n  0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,\r\n  0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\r\n  0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,\r\n  0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\r\n  0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,\r\n  0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\r\n  0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,\r\n  0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\r\n  0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,\r\n  0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\r\n  0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,\r\n  0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\r\n  0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,\r\n  0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\r\n  0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,\r\n  0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\r\n  0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\r\n};\r\n\r\nuint32 eth_crc32(uint32 crc, const void* vbuf, size_t len)\r\n{\r\n  const uint32 mask = 0xFFFFFFFF;\r\n  const unsigned char* buf = (const unsigned char*)vbuf;\r\n\r\n  crc ^= mask;\r\n  while (len > 8) {\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n    len -= 8;\r\n  }\r\n  while (0 != len--)\r\n    crc = (crc >> 8) ^ crcTable[ (crc ^ (*buf++)) & 0xFF ];\r\n  return(crc ^ mask);\r\n}\r\n\r\nint eth_get_packet_crc32_data(const uint8 *msg, int len, uint8 *crcdata)\r\n{\r\n  int crc_len;\r\n\r\n  if (len <= ETH_MAX_PACKET) {\r\n    uint32 crc = eth_crc32(0, msg, len);                  /* calculate CRC */\r\n    uint32 ncrc = htonl(crc);                             /* CRC in network order */\r\n    int size = sizeof(ncrc);                              /* size of crc field */\r\n    memcpy(crcdata, &ncrc, size);                         /* append crc to packet */\r\n    crc_len = len + size;                                 /* set packet crc length */\r\n  } else {\r\n    crc_len = 0;                                          /* appending crc would destroy packet */\r\n  }\r\n  return crc_len;\r\n}\r\n\r\nint eth_add_packet_crc32(uint8 *msg, int len)\r\n{\r\n  int crc_len;\r\n\r\n  if (len <= ETH_MAX_PACKET) {\r\n    crc_len = eth_get_packet_crc32_data(msg, len, &msg[len]);/* append crc to packet */\r\n  } else {\r\n    crc_len = 0;                                          /* appending crc would destroy packet */\r\n  }\r\n  return crc_len;\r\n}\r\n\r\nvoid eth_setcrc(ETH_DEV* dev, int need_crc)\r\n{\r\n  dev->need_crc = need_crc;\r\n}\r\n\r\nvoid eth_packet_trace_ex(ETH_DEV* dev, const uint8 *msg, int len, const char* txt, int detail, uint32 reason)\r\n{\r\n  if (dev->dptr->dctrl & reason) {\r\n    char src[20];\r\n    char dst[20];\r\n    const unsigned short* proto = (const unsigned short*) &msg[12];\r\n    uint32 crc = eth_crc32(0, msg, len);\r\n    eth_mac_fmt((ETH_MAC*)msg, dst);\r\n    eth_mac_fmt((ETH_MAC*)(msg+6), src);\r\n    sim_debug(reason, dev->dptr, \"%s  dst: %s  src: %s  proto: 0x%04X  len: %d  crc: %X\\n\",\r\n          txt, dst, src, ntohs(*proto), len, crc);\r\n    if (detail) {\r\n      int i, same, group, sidx, oidx;\r\n      char outbuf[80], strbuf[18];\r\n      static const char hex[] = \"0123456789ABCDEF\";\r\n\r\n      for (i=same=0; i<len; i += 16) {\r\n        if ((i > 0) && (0 == memcmp(&msg[i], &msg[i-16], 16))) {\r\n          ++same;\r\n          continue;\r\n        }\r\n        if (same > 0) {\r\n          sim_debug(reason, dev->dptr, \"%04X thru %04X same as above\\n\", i-(16*same), i-1);\r\n          same = 0;\r\n        }\r\n        group = (((len - i) > 16) ? 16 : (len - i));\r\n        for (sidx=oidx=0; sidx<group; ++sidx) {\r\n          outbuf[oidx++] = ' ';\r\n          outbuf[oidx++] = hex[(msg[i+sidx]>>4)&0xf];\r\n          outbuf[oidx++] = hex[msg[i+sidx]&0xf];\r\n          if (isprint(msg[i+sidx]))\r\n            strbuf[sidx] = msg[i+sidx];\r\n          else\r\n            strbuf[sidx] = '.';\r\n        }\r\n        outbuf[oidx] = '\\0';\r\n        strbuf[sidx] = '\\0';\r\n        sim_debug(reason, dev->dptr, \"%04X%-48s %s\\n\", i, outbuf, strbuf);\r\n      }\r\n      if (same > 0) {\r\n        sim_debug(reason, dev->dptr, \"%04X thru %04X same as above\\n\", i-(16*same), len-1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nvoid eth_packet_trace(ETH_DEV* dev, const uint8 *msg, int len, const char* txt)\r\n{\r\n  eth_packet_trace_ex(dev, msg, len, txt, 0, dev->dbit);\r\n}\r\n\r\nvoid eth_packet_trace_detail(ETH_DEV* dev, const uint8 *msg, int len, const char* txt)\r\n{\r\n  eth_packet_trace_ex(dev, msg, len, txt, 1     , dev->dbit);\r\n}\r\n\r\nvoid eth_zero(ETH_DEV* dev)\r\n{\r\n  /* set all members to NULL OR 0 */\r\n  memset(dev, 0, sizeof(ETH_DEV));\r\n  dev->reflections = -1;                          /* not established yet */\r\n}\r\n\r\nt_stat ethq_init(ETH_QUE* que, int max)\r\n{\r\n  /* create dynamic queue if it does not exist */\r\n  if (!que->item) {\r\n    que->item = (struct eth_item *) calloc(max, sizeof(struct eth_item));\r\n    if (!que->item) {\r\n      /* failed to allocate memory */\r\n      sim_printf(\"EthQ: failed to allocate dynamic queue[%d]\\n\", max);\r\n      return SCPE_MEM;\r\n    };\r\n    que->max = max;\r\n  };\r\n  ethq_clear(que);\r\n  return SCPE_OK;\r\n}\r\n\r\nt_stat ethq_destroy(ETH_QUE* que)\r\n{\r\n  /* release dynamic queue if it exists */\r\n  ethq_clear(que);\r\n  que->max = 0;\r\n  if (que->item) {\r\n    free(que->item);\r\n    que->item = NULL;\r\n  };\r\n  return SCPE_OK;\r\n}\r\n\r\nvoid ethq_clear(ETH_QUE* que)\r\n{\r\n  int i;\r\n\r\n  /* free up any extended packets */\r\n  for (i=0; i<que->max; ++i)\r\n    if (que->item[i].packet.oversize) {\r\n      free (que->item[i].packet.oversize);\r\n      que->item[i].packet.oversize = NULL;\r\n      }\r\n  /* clear packet array */\r\n  memset(que->item, 0, sizeof(struct eth_item) * que->max);\r\n  /* clear rest of structure */\r\n  que->count = que->head = que->tail = 0;\r\n}\r\n\r\nvoid ethq_remove(ETH_QUE* que)\r\n{\r\n  struct eth_item* item = &que->item[que->head];\r\n\r\n  if (que->count) {\r\n    if (item->packet.oversize)\r\n      free (item->packet.oversize);\r\n    memset(item, 0, sizeof(struct eth_item));\r\n    if (++que->head == que->max)\r\n      que->head = 0;\r\n    que->count--;\r\n  }\r\n}\r\n\r\nvoid ethq_insert_data(ETH_QUE* que, int32 type, const uint8 *data, int used, size_t len, size_t crc_len, const uint8 *crc_data, int32 status)\r\n{\r\n  struct eth_item* item;\r\n\r\n  /* if queue empty, set pointers to beginning */\r\n  if (!que->count) {\r\n    que->head = 0;\r\n    que->tail = -1;\r\n  }\r\n\r\n  /* find new tail of the circular queue */\r\n  if (++que->tail == que->max)\r\n    que->tail = 0;\r\n  if (++que->count > que->max) {\r\n    que->count = que->max;\r\n    /* lose oldest packet */\r\n    if (++que->head == que->max)\r\n      que->head = 0;\r\n    que->loss++;\r\n    }\r\n  if (que->count > que->high)\r\n    que->high = que->count;\r\n\r\n  /* set information in (new) tail item */\r\n  item = &que->item[que->tail];\r\n  item->type = type;\r\n  item->packet.len = len;\r\n  item->packet.used = used;\r\n  item->packet.crc_len = crc_len;\r\n  if (MAX (len, crc_len) <= sizeof (item->packet.msg)) {\r\n    memcpy(item->packet.msg, data, ((len > crc_len) ? len : crc_len));\r\n    if (crc_data && (crc_len > len))\r\n      memcpy(&item->packet.msg[len], crc_data, ETH_CRC_SIZE);\r\n    }\r\n  else {\r\n    item->packet.oversize = (uint8 *)realloc (item->packet.oversize, ((len > crc_len) ? len : crc_len));\r\n    memcpy(item->packet.oversize, data, ((len > crc_len) ? len : crc_len));\r\n    if (crc_data && (crc_len > len))\r\n      memcpy(&item->packet.oversize[len], crc_data, ETH_CRC_SIZE);\r\n    }\r\n  item->packet.status = status;\r\n}\r\n\r\nvoid ethq_insert(ETH_QUE* que, int32 type, ETH_PACK* pack, int32 status)\r\n{\r\nethq_insert_data(que, type, pack->oversize ? pack->oversize : pack->msg, pack->used, pack->len, pack->crc_len, NULL, status);\r\n}\r\n\r\nt_stat eth_show_devices (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char *desc)\r\n{\r\nreturn eth_show (st, uptr, val, NULL);\r\n}\r\n\r\n#if defined (USE_NETWORK) || defined (USE_SHARED)\r\n\r\nstatic const char* _eth_getname(int number, char* name, char *desc)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int count = eth_devices(ETH_MAX_DEVICE, list, FALSE);\r\n\r\n  if ((number < 0) || (count <= number))\r\n      return NULL;\r\n  if (list[number].eth_api != ETH_API_PCAP) {\r\n#if defined(_WIN32)\r\n    sim_printf (\"Eth: Pcap capable device not found.  Install Npcap or WinPcap 4.1.3 to use pcap networking\\n\");\r\n#else\r\n    sim_printf (\"Eth: Pcap capable device not found.  You may need to run as root\\n\");\r\n#endif\r\n    return NULL;\r\n    }\r\n\r\n  strcpy(name, list[number].name);\r\n  strcpy(desc, list[number].desc);\r\n  return name;\r\n}\r\n\r\nconst char* eth_getname_bydesc(const char* desc, char* name, char *ndesc)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int count = eth_devices(ETH_MAX_DEVICE, list, FALSE);\r\n  int i;\r\n  size_t j=strlen(desc);\r\n\r\n  for (i=0; i<count; i++) {\r\n    int found = 1;\r\n    size_t k = strlen(list[i].desc);\r\n\r\n    if (j != k) continue;\r\n    for (k=0; k<j; k++)\r\n      if (tolower(list[i].desc[k]) != tolower(desc[k]))\r\n        found = 0;\r\n    if (found == 0) continue;\r\n\r\n    /* found a case-insensitive description match */\r\n    strcpy(name, list[i].name);\r\n    strcpy(ndesc, list[i].desc);\r\n    return name;\r\n  }\r\n  /* not found */\r\n  return NULL;\r\n}\r\n\r\nchar* eth_getname_byname(const char* name, char* temp, char *desc)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int count = eth_devices(ETH_MAX_DEVICE, list, FALSE);\r\n  size_t n;\r\n  int i, found;\r\n\r\n  found = 0;\r\n  n = strlen(name);\r\n  for (i=0; i<count && !found; i++) {\r\n    if ((n == strlen(list[i].name)) &&\r\n        (strncasecmp(name, list[i].name, n) == 0)) {\r\n      found = 1;\r\n      strcpy(temp, list[i].name); /* only case might be different */\r\n      strcpy(desc, list[i].desc);\r\n    }\r\n  }\r\n  return (found ? temp : NULL);\r\n}\r\n\r\nchar* eth_getdesc_byname(char* name, char* temp)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int count = eth_devices(ETH_MAX_DEVICE, list, FALSE);\r\n  size_t n;\r\n  int i, found;\r\n\r\n  found = 0;\r\n  n = strlen(name);\r\n  for (i=0; i<count && !found; i++) {\r\n    if ((n == strlen(list[i].name)) &&\r\n        (strncasecmp(name, list[i].name, n) == 0)) {\r\n      found = 1;\r\n      strcpy(temp, list[i].desc);\r\n    }\r\n  }\r\n  return (found ? temp : NULL);\r\n}\r\n\r\nstatic ETH_DEV **eth_open_devices = NULL;\r\nstatic int eth_open_device_count = 0;\r\n\r\nstatic char *(*p_pcap_lib_version) (void);\r\n\r\nstatic void _eth_add_to_open_list (ETH_DEV* dev)\r\n{\r\neth_open_devices = (ETH_DEV**)realloc(eth_open_devices, (eth_open_device_count+1)*sizeof(*eth_open_devices));\r\neth_open_devices[eth_open_device_count++] = dev;\r\n}\r\n\r\nstatic void _eth_remove_from_open_list (ETH_DEV* dev)\r\n{\r\nint i, j;\r\n\r\nfor (i=0; i<eth_open_device_count; ++i)\r\n    if (eth_open_devices[i] == dev) {\r\n        for (j=i+1; j<eth_open_device_count; ++j)\r\n            eth_open_devices[j-1] = eth_open_devices[j];\r\n        --eth_open_device_count;\r\n        break;\r\n        }\r\n}\r\n\r\nt_stat eth_show (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int number;\r\n\r\n  fprintf(st, \"Ethernet Packet Info: %s\\n\", eth_version());\r\n  number = eth_devices(ETH_MAX_DEVICE, list, FALSE);\r\n  fprintf(st, \"ETH devices:\\n\");\r\n  if (number == -1)\r\n    fprintf(st, \"  network support not available in simulator\\n\");\r\n  else\r\n    if (number == 0)\r\n      fprintf(st, \"  no network devices are available\\n\");\r\n    else {\r\n      size_t min, len;\r\n      int i;\r\n      for (i=0, min=0; i<number; i++)\r\n        if ((len = strlen(list[i].name)) > min) min = len;\r\n      for (i=0; i<number; i++)\r\n        fprintf(st,\" eth%d\\t%-*s (%s)\\n\", i, (int)min, list[i].name, list[i].desc);\r\n    }\r\n  if (eth_open_device_count) {\r\n    int i;\r\n    char desc[ETH_DEV_DESC_MAX], *d;\r\n\r\n    fprintf(st,\"Open ETH Devices:\\n\");\r\n    for (i=0; i<eth_open_device_count; i++) {\r\n      d = eth_getdesc_byname(eth_open_devices[i]->name, desc);\r\n      if (d)\r\n        fprintf(st, \" %-7s%s (%s)\\n\", eth_open_devices[i]->dptr->name, eth_open_devices[i]->dptr->units[0].filename, d);\r\n      else\r\n        fprintf(st, \" %-7s%s\\n\", eth_open_devices[i]->dptr->name, eth_open_devices[i]->dptr->units[0].filename);\r\n      eth_show_dev (st, eth_open_devices[i]);\r\n      }\r\n    }\r\n  return SCPE_OK;\r\n}\r\n\r\n#endif\r\n/*============================================================================*/\r\n/*                        Non-implemented versions                            */\r\n/*============================================================================*/\r\n\r\n#if !defined (USE_NETWORK) && !defined (USE_SHARED)\r\nconst char *eth_capabilities(void)\r\n    {return \"no Ethernet\";}\r\nt_stat eth_open(ETH_DEV* dev, const char* name, DEVICE* dptr, uint32 dbit)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_close (ETH_DEV* dev)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n  {\r\n  fprintf (st, \"%s attach help\\n\\n\", dptr->name);\r\n  fprintf (st, \"This simulator was not built with ethernet device support\\n\");\r\n  return SCPE_OK;\r\n  }\r\nt_stat eth_check_address_conflict (ETH_DEV* dev,\r\n                                   ETH_MAC* const mac)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_set_throttle (ETH_DEV* dev, uint32 time, uint32 burst, uint32 delay)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_set_async (ETH_DEV *dev, int latency)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_clr_async (ETH_DEV *dev)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_write (ETH_DEV* dev, ETH_PACK* packet, ETH_PCALLBACK routine)\r\n  {return SCPE_NOFNC;}\r\nint eth_read (ETH_DEV* dev, ETH_PACK* packet, ETH_PCALLBACK routine)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_filter (ETH_DEV* dev, int addr_count, ETH_MAC* const addresses,\r\n                   ETH_BOOL all_multicast, ETH_BOOL promiscuous)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_filter_hash (ETH_DEV* dev, int addr_count, ETH_MAC* const addresses,\r\n                   ETH_BOOL all_multicast, ETH_BOOL promiscuous, ETH_MULTIHASH* const hash)\r\n  {return SCPE_NOFNC;}\r\nt_stat eth_filter_hash_ex (ETH_DEV* dev, int addr_count, ETH_MAC* const addresses,\r\n                   ETH_BOOL all_multicast, ETH_BOOL promiscuous, ETH_BOOL match_broadcast, \r\n                   ETH_MULTIHASH* const hash)\r\n  {return SCPE_NOFNC;}\r\nconst char *eth_version (void)\r\n  {return NULL;}\r\nint eth_devices(int max, ETH_LIST* list, ETH_BOOL framers)\r\n  {return 0;}\r\nvoid eth_show_dev (FILE* st, ETH_DEV* dev)\r\n  {}\r\nt_stat eth_show (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n  {\r\n  fprintf(st, \"ETH devices:\\n\");\r\n  fprintf(st, \"  network support not available in simulator\\n\");\r\n  return SCPE_OK;\r\n  }\r\nstatic int _eth_get_system_id (char *buf, size_t buf_size)\r\n  {memset (buf, 0, buf_size); return 0;}\r\nt_stat sim_ether_test (DEVICE *dptr, const char *cptr)\r\n  {return SCPE_OK;}\r\n#else    /* endif unimplemented */\r\n\r\n#if (defined (xBSD) || defined (__APPLE__)) && (defined (HAVE_TAP_NETWORK) || defined (HAVE_PCAP_NETWORK))\r\n#include <sys/ioctl.h>\r\n#include <net/bpf.h>\r\n#endif\r\n\r\n#if defined (HAVE_PCAP_NETWORK) && !defined (PCAP_LIB_VERSION)\r\n/*============================================================================*/\r\n/*      WIN32, Linux, and xBSD routines use WinPcap and libpcap packages      */\r\n/*        OpenVMS Alpha uses a WinPcap port and an associated execlet         */\r\n/*============================================================================*/\r\n\r\n#include <pcap.h>\r\n#else\r\nstruct pcap_pkthdr {\r\n    uint32 caplen;  /* length of portion present */\r\n    uint32 len;     /* length this packet (off wire) */\r\n};\r\n#define PCAP_ERRBUF_SIZE 256\r\ntypedef void * pcap_t;          /* Pseudo Type to avoid compiler errors */\r\n#define DLT_EN10MB 1            /* Dummy Value to avoid compiler errors */\r\n#if defined (PCAP_LIB_VERSION) && defined (USE_SHARED)\r\ntypedef uint32 bpf_u_int32;     /* Pseudo Type to avoid compiler errors */\r\ntypedef struct pcap_if {\r\n        struct pcap_if *next;\r\n        char *name;             /* name to hand to \"pcap_open_live()\" */\r\n        char *description;      /* textual description of interface, or NULL */\r\n        struct pcap_addr *addresses;\r\n        bpf_u_int32 flags;      /* PCAP_IF_ interface flags */\r\n} pcap_if_t;       /* Pseudo Type to avoid compiler errors */\r\n#define PCAP_IF_LOOPBACK                                0x00000001      /* interface is loopback */\r\nstruct bpf_program { void *pgm; };  /* Pseudo Type to avoid compiler errors */\r\ntypedef void (*pcap_handler)(u_char *, const struct pcap_pkthdr *,\r\n                             const u_char *);\r\n\r\nvoid    pcap_close (pcap_t *);\r\n#define BPF_CONST_STRING 1\r\nint     pcap_compile (pcap_t *, struct bpf_program *, const char *, int, unsigned int);\r\nint     pcap_datalink (pcap_t *);\r\nint     pcap_dispatch (pcap_t *, int, pcap_handler, u_char *);\r\nint     pcap_findalldevs (pcap_if_t **, char *);\r\nvoid    pcap_freealldevs (pcap_if_t *);\r\nvoid    pcap_freecode (struct bpf_program *);\r\nchar*   pcap_geterr (pcap_t *);\r\nint     pcap_lookupnet (const char *, bpf_u_int32 *, bpf_u_int32 *, char *);\r\npcap_t* pcap_open_live (const char *, int, int, int, char *);\r\n#ifdef _WIN32\r\nint     pcap_setmintocopy (pcap_t* handle, int);\r\nHANDLE  pcap_getevent (pcap_t *);\r\n#else\r\n#ifdef MUST_DO_SELECT\r\nint     pcap_get_selectable_fd (pcap_t *);\r\n#endif\r\nint     pcap_fileno (pcap_t *);\r\n#endif\r\nint     pcap_sendpacket (pcap_t* handle, const u_char* msg, int len);\r\nint     pcap_setfilter (pcap_t *, struct bpf_program *);\r\nint     pcap_setnonblock(pcap_t* a, int nonblock, char *errbuf);\r\n#endif\r\n#endif /* HAVE_PCAP_NETWORK */\r\n\r\n/*\r\n     The libpcap provided API pcap_findalldevs() on most platforms, will\r\n     leverage the getifaddrs() API if it is available in preference to\r\n     alternate platform specific methods of determining the interface list.\r\n\r\n     A limitation of getifaddrs() is that it returns only interfaces which\r\n     have associated addresses.  This may not include all of the interesting\r\n     interfaces that we are interested in since a host may have dedicated\r\n     interfaces for a simulator, which is otherwise unused by the host.\r\n\r\n     One could hand craft the the build of libpcap to specifically use\r\n     alternate methods to implement pcap_findalldevs().  However, this can\r\n     get tricky, and would then result in a sort of deviant libpcap.\r\n\r\n     This routine exists to allow platform specific code to validate and/or\r\n     extend the set of available interfaces to include any that are not\r\n     returned by pcap_findalldevs.\r\n\r\n*/\r\nstatic int eth_host_pcap_devices(int used, int max, ETH_LIST* list)\r\n{\r\nint i;\r\n\r\nfor (i=0; i<used; ++i) {\r\n  /* Cull any non-ethernet interface types */\r\n#if defined(HAVE_PCAP_NETWORK)\r\n  int j, datalink = 0;\r\n  pcap_t* conn = NULL;\r\n  char errbuf[PCAP_ERRBUF_SIZE];\r\n\r\n  conn = pcap_open_live(list[i].name, ETH_MAX_PACKET, ETH_PROMISC, PCAP_READ_TIMEOUT, errbuf);\r\n  if (NULL != conn)\r\n    datalink = pcap_datalink(conn), pcap_close(conn);\r\n  list[i].eth_api = ETH_API_PCAP;\r\n  if ((NULL == conn) || (datalink != DLT_EN10MB)) {\r\n    for (j=i; j<used-1; ++j)\r\n      list[j] = list[j+1];\r\n    --used;\r\n    --i;\r\n    }\r\n#endif\r\n  } /* for */\r\n\r\n#if defined(_WIN32)\r\n/* replace device description with user-defined adapter name (if defined) */\r\nfor (i=0; i<used; i++) {\r\n  char regkey[2048];\r\n  unsigned char regval[2048];\r\n  LONG status;\r\n  DWORD reglen, regtype;\r\n  HKEY reghnd;\r\n\r\n  /* These registry keys don't seem to exist for all devices, so we simply ignore errors. */\r\n  /* Windows XP x64 registry uses wide characters by default,\r\n     so we force use of narrow characters by using the 'A'(ANSI) version of RegOpenKeyEx.\r\n     This could cause some problems later, if this code is internationalized. Ideally,\r\n     the pcap lookup will return wide characters, and we should use them to build a wide\r\n     registry key, rather than hardcoding the string as we do here. */\r\n  if (list[i].name[strlen( \"\\\\Device\\\\NPF_\" )] == '{') {\r\n    sprintf( regkey, \"SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\\"\r\n             \"{4D36E972-E325-11CE-BFC1-08002BE10318}\\\\%s\\\\Connection\", list[i].name+\r\n             strlen( \"\\\\Device\\\\NPF_\" ) );\r\n    if ((status = RegOpenKeyExA (HKEY_LOCAL_MACHINE, regkey, 0, KEY_QUERY_VALUE, &reghnd)) != ERROR_SUCCESS)\r\n      continue;\r\n    reglen = sizeof(regval);\r\n\r\n    /* look for user-defined adapter name, bail if not found */\r\n    /* same comment about Windows XP x64 (above) using RegQueryValueEx */\r\n    if ((status = RegQueryValueExA (reghnd, \"Name\", NULL, &regtype, regval, &reglen)) != ERROR_SUCCESS) {\r\n      RegCloseKey (reghnd);\r\n      continue;\r\n      }\r\n    /* make sure value is the right type, bail if not acceptable */\r\n    if ((regtype != REG_SZ) || (reglen > sizeof(regval))) {\r\n      RegCloseKey (reghnd);\r\n      continue;\r\n      }\r\n    /* registry value seems OK, finish up and replace description */\r\n    RegCloseKey (reghnd );\r\n    sprintf (list[i].desc, \"%s\", regval);\r\n    }\r\n  } /* for */\r\n#endif\r\n\r\nreturn used;\r\n}\r\n\r\n#ifdef HAVE_TAP_NETWORK\r\n#if defined(__linux) || defined(__linux__)\r\n#include <sys/ioctl.h>\r\n#include <net/if.h>\r\n#include <linux/if_tun.h>\r\n#elif defined(HAVE_BSDTUNTAP)\r\n#include <sys/types.h>\r\n#include <net/if_types.h>\r\n#include <net/if.h>\r\n#else /* We don't know how to do this on the current platform */\r\n#undef HAVE_TAP_NETWORK\r\n#endif\r\n#endif /* HAVE_TAP_NETWORK */\r\n\r\n#ifdef HAVE_VDE_NETWORK\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n#include <libvdeplug.h>\r\n/* support for dynamic loading */\r\nstatic void load_vde (void);\r\nstatic VDECONN *(*p_vde_open_real)(char *vde_url,char *descr,int interface_version, struct vde_open_args *open_args) = NULL;\r\nstatic ssize_t (*p_vde_recv)(VDECONN *conn,void *buf,size_t len,int flags) = NULL;\r\nstatic ssize_t (*p_vde_send)(VDECONN *conn,const void *buf,size_t len,int flags) = NULL;\r\nstatic int (*p_vde_datafd)(VDECONN *conn) = NULL;\r\nstatic int (*p_vde_close)(VDECONN *conn) = NULL;\r\nstatic t_bool eth_vde_network_available = FALSE;\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n#endif /* HAVE_VDE_NETWORK */\r\n\r\n#ifdef HAVE_SLIRP_NETWORK\r\n#include \"sim_slirp.h\"\r\n#endif /* HAVE_SLIRP_NETWORK */\r\n\r\n/* Allows windows to look up user-defined adapter names */\r\n#if defined(_WIN32)\r\n#include <winreg.h>\r\n#endif\r\n\r\nconst char *eth_capabilities(void)\r\n {\r\n static char capabilities[CBUFSIZE] = \"\";\r\n\r\n if (capabilities[0] != '\\0')\r\n     return capabilities;\r\n#if defined (USE_READER_THREAD)\r\n strlcat (capabilities, \"Threaded \", sizeof (capabilities));\r\n#else\r\n strlcat (capabilities, \"Polled \", sizeof (capabilities));\r\n#endif\r\n strlcat (capabilities, \"Ethernet Packet transports\", sizeof (capabilities));\r\n#if defined (HAVE_PCAP_NETWORK)\r\n strlcat (capabilities, \":PCAP\", sizeof (capabilities));\r\n#endif\r\n#if defined (HAVE_TAP_NETWORK)\r\n strlcat (capabilities, \":TAP\", sizeof (capabilities));\r\n#endif\r\n#if defined (HAVE_VDE_NETWORK)\r\n load_vde();\r\n if (eth_vde_network_available)\r\n   strlcat (capabilities, \":VDE\", sizeof (capabilities));\r\n#endif\r\n#if defined (HAVE_SLIRP_NETWORK)\r\n strlcat (capabilities, \":NAT\", sizeof (capabilities));\r\n#endif\r\n strlcat (capabilities, \":UDP\", sizeof (capabilities));\r\n return capabilities;\r\n }\r\n\r\nint eth_devices(int max, ETH_LIST* list, ETH_BOOL framers)\r\n{\r\nint used = 0;\r\nchar errbuf[PCAP_ERRBUF_SIZE] = \"\";\r\n#ifndef DONT_USE_PCAP_FINDALLDEVS\r\npcap_if_t* alldevs;\r\npcap_if_t* dev;\r\nETH_DEV edev;\r\n\r\nmemset(list, 0, max*sizeof(*list));\r\nerrbuf[0] = '\\0';\r\n/* retrieve the device list */\r\nif (pcap_findalldevs(&alldevs, errbuf) == -1) {\r\n  if (errbuf[0])\r\n    sim_printf (\"Eth: %s\\n\", errbuf);\r\n  }\r\nelse {\r\n  /* copy device list into the passed structure */\r\n  for (used=0, dev=alldevs; dev && (used < max); dev=dev->next) {\r\n    edev.eth_api = ETH_API_PCAP;\r\n    eth_get_nic_hw_addr (&edev, dev->name, 0);\r\n    if ((memcmp (edev.host_nic_phy_hw_addr, framer_oui, 3) == 0) != framers)\r\n      continue;\r\n    if ((dev->flags & PCAP_IF_LOOPBACK) || (!strcmp(\"any\", dev->name)))\r\n      continue;\r\n    strlcpy(list[used].name, dev->name, sizeof(list[used].name));\r\n    if (dev->description)\r\n      strlcpy(list[used].desc, dev->description, sizeof(list[used].desc));\r\n    else\r\n      strlcpy(list[used].desc, \"No description available\", sizeof(list[used].desc));\r\n    ++used;\r\n    }\r\n\r\n  /* free device list */\r\n  pcap_freealldevs(alldevs);\r\n  }\r\n#endif\r\n\r\n/* Add any host specific devices and/or validate those already found */\r\nused = eth_host_pcap_devices(used, max, list);\r\n\r\n/* If no devices were found and an error message was left in the buffer, display it */\r\nif ((used == 0) && (errbuf[0])) {\r\n    sim_printf (\"Eth: pcap_findalldevs warning: %s\\n\", errbuf);\r\n    }\r\n\r\nif (framers)\r\n    return used;    /* don't add pseudo-ethernet devices */\r\n\r\n#ifdef HAVE_TAP_NETWORK\r\nif (used < max) {\r\n#if defined(__OpenBSD__)\r\n  sprintf(list[used].name, \"%s\", \"tap:tunN\");\r\n#else\r\n  sprintf(list[used].name, \"%s\", \"tap:tapN\");\r\n#endif\r\n  sprintf(list[used].desc, \"%s\", \"Integrated Tun/Tap support\");\r\n  list[used].eth_api = ETH_API_TAP;\r\n  ++used;\r\n  }\r\n#endif\r\n#ifdef HAVE_VDE_NETWORK\r\nif (eth_vde_network_available && (used < max)) {\r\n  sprintf(list[used].name, \"%s\", \"vde:device{:switch-port-number}\");\r\n  sprintf(list[used].desc, \"%s\", \"Integrated VDE support\");\r\n  list[used].eth_api = ETH_API_VDE;\r\n  ++used;\r\n  }\r\n#endif\r\n#ifdef HAVE_SLIRP_NETWORK\r\nif (used < max) {\r\n  sprintf(list[used].name, \"%s\", \"nat:{optional-nat-parameters}\");\r\n  sprintf(list[used].desc, \"%s\", \"Integrated NAT (SLiRP) support\");\r\n  list[used].eth_api = ETH_API_NAT;\r\n  ++used;\r\n  }\r\n#endif\r\n\r\nif (used < max) {\r\n  sprintf(list[used].name, \"%s\", \"udp:sourceport:remotehost:remoteport\");\r\n  sprintf(list[used].desc, \"%s\", \"Integrated UDP bridge support\");\r\n  list[used].eth_api = ETH_API_UDP;\r\n  ++used;\r\n  }\r\n\r\n/* return device count */\r\nreturn used;\r\n}\r\n\r\n#if defined(USE_SHARED) && (defined(_WIN32) || defined(SIM_HAVE_DLOPEN))\r\n/* Dynamic DLL loading technique and modified source comes from\r\n   Etherial/WireShark capture_pcap.c */\r\n\r\n/* Dynamic DLL load variables */\r\n#ifdef _WIN32\r\nstatic HINSTANCE hLib = NULL;               /* handle to DLL */\r\n#else\r\nstatic void *hLib = 0;                      /* handle to Library */\r\n#endif\r\nstatic int lib_loaded = 0;                  /* 0=not loaded, 1=loaded, 2=library load failed, 3=Func load failed */\r\n\r\nstatic const char* lib_name =\r\n#if defined(_WIN32) || defined(__CYGWIN__)\r\n                          \"wpcap.dll\";\r\n#elif defined(__APPLE__)\r\n                          \"/usr/lib/libpcap.A.dylib\";\r\n#else\r\n                          \"libpcap.\" __STR(SIM_DLOPEN_EXTENSION);\r\n#endif\r\n\r\nstatic char no_pcap[PCAP_ERRBUF_SIZE] =\r\n#if defined(_WIN32) || defined(__CYGWIN__)\r\n    \"wpcap.dll failed to load, install Npcap or WinPcap 4.1.3 to use pcap networking\";\r\n#elif defined(__APPLE__)\r\n    \"/usr/lib/libpcap.A.dylib failed to load, install libpcap to use pcap networking\";\r\n#else\r\n    \"libpcap.\" __STR(SIM_DLOPEN_EXTENSION) \" failed to load, install libpcap to use pcap networking\";\r\n#endif\r\n\r\n/* define pointers to pcap functions needed */\r\nstatic void    (*p_pcap_close) (pcap_t *);\r\nstatic int     (*p_pcap_compile) (pcap_t *, struct bpf_program *, const char *, int, bpf_u_int32);\r\nstatic int     (*p_pcap_datalink) (pcap_t *);\r\nstatic int     (*p_pcap_dispatch) (pcap_t *, int, pcap_handler, u_char *);\r\nstatic int     (*p_pcap_findalldevs) (pcap_if_t **, char *);\r\nstatic void    (*p_pcap_freealldevs) (pcap_if_t *);\r\nstatic void    (*p_pcap_freecode) (struct bpf_program *);\r\nstatic char*   (*p_pcap_geterr) (pcap_t *);\r\nstatic int     (*p_pcap_lookupnet) (const char *, bpf_u_int32 *, bpf_u_int32 *, char *);\r\nstatic pcap_t* (*p_pcap_open_live) (const char *, int, int, int, char *);\r\n#ifdef _WIN32\r\nstatic int     (*p_pcap_setmintocopy) (pcap_t* handle, int);\r\nstatic HANDLE  (*p_pcap_getevent) (pcap_t *);\r\n#else\r\n#ifdef MUST_DO_SELECT\r\nstatic int     (*p_pcap_get_selectable_fd) (pcap_t *);\r\n#endif\r\nstatic int     (*p_pcap_fileno) (pcap_t *);\r\n#endif\r\nstatic int     (*p_pcap_sendpacket) (pcap_t* handle, const u_char* msg, int len);\r\nstatic int     (*p_pcap_setfilter) (pcap_t *, struct bpf_program *);\r\nstatic int     (*p_pcap_setnonblock)(pcap_t* a, int nonblock, char *errbuf);\r\n\r\n/* load function pointer from DLL */\r\ntypedef int (*_func)();\r\n\r\nstatic void load_function(const char* function, _func* func_ptr) {\r\n#ifdef _WIN32\r\n    *func_ptr = (_func)((size_t)GetProcAddress(hLib, function));\r\n#else\r\n    *func_ptr = (_func)((size_t)dlsym(hLib, function));\r\n#endif\r\n    if (*func_ptr == 0) {\r\n    sim_printf (\"Eth: Failed to find function '%s' in %s\\n\", function, lib_name);\r\n    lib_loaded = 3;\r\n  }\r\n}\r\n\r\n/* load wpcap.dll or libpcap as required */\r\nint load_pcap(void) {\r\n  switch(lib_loaded) {\r\n    case 0:                  /* not loaded */\r\n            /* attempt to load DLL */\r\n#ifdef _WIN32\r\n      if (1) {\r\n        BOOL(WINAPI *p_SetDllDirectory)(const char *);\r\n        UINT(WINAPI *p_GetSystemDirectory)(char * lpBuffer, UINT uSize);\r\n\r\n        p_SetDllDirectory = (BOOL(WINAPI *)(const char *)) GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"SetDllDirectoryA\");\r\n        p_GetSystemDirectory = (UINT(WINAPI *)(char *, UINT)) GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"GetSystemDirectoryA\");\r\n        if (p_SetDllDirectory && p_GetSystemDirectory) {\r\n          char npcap_path[512] = \"\";\r\n\r\n          if (p_GetSystemDirectory (npcap_path, sizeof(npcap_path) - 7))\r\n            strlcat (npcap_path, \"\\\\Npcap\", sizeof(npcap_path));\r\n          if (p_SetDllDirectory(npcap_path))\r\n            hLib = LoadLibraryA(lib_name);\r\n          p_SetDllDirectory (NULL);\r\n          }\r\n        if (hLib == NULL)\r\n          hLib = LoadLibraryA(lib_name);\r\n        }\r\n#else\r\n      hLib = dlopen(lib_name, RTLD_NOW);\r\n#endif\r\n      if (hLib == 0) {\r\n        /* failed to load DLL */\r\n        lib_loaded = 2;\r\n        break;\r\n      } else {\r\n        /* library loaded OK */\r\n        lib_loaded = 1;\r\n      }\r\n\r\n      /* load required functions; sets dll_load=3 on error */\r\n      load_function(\"pcap_close\",        (_func *) &p_pcap_close);\r\n      load_function(\"pcap_compile\",      (_func *) &p_pcap_compile);\r\n      load_function(\"pcap_datalink\",     (_func *) &p_pcap_datalink);\r\n      load_function(\"pcap_dispatch\",     (_func *) &p_pcap_dispatch);\r\n      load_function(\"pcap_findalldevs\",  (_func *) &p_pcap_findalldevs);\r\n      load_function(\"pcap_freealldevs\",  (_func *) &p_pcap_freealldevs);\r\n      load_function(\"pcap_freecode\",     (_func *) &p_pcap_freecode);\r\n      load_function(\"pcap_geterr\",       (_func *) &p_pcap_geterr);\r\n      load_function(\"pcap_lookupnet\",    (_func *) &p_pcap_lookupnet);\r\n      load_function(\"pcap_open_live\",    (_func *) &p_pcap_open_live);\r\n#ifdef _WIN32\r\n      load_function(\"pcap_setmintocopy\", (_func *) &p_pcap_setmintocopy);\r\n      load_function(\"pcap_getevent\",     (_func *) &p_pcap_getevent);\r\n#else\r\n#ifdef MUST_DO_SELECT\r\n      load_function(\"pcap_get_selectable_fd\",     (_func *) &p_pcap_get_selectable_fd);\r\n#endif\r\n      load_function(\"pcap_fileno\",       (_func *) &p_pcap_fileno);\r\n#endif\r\n      load_function(\"pcap_sendpacket\",   (_func *) &p_pcap_sendpacket);\r\n      load_function(\"pcap_setfilter\",    (_func *) &p_pcap_setfilter);\r\n      load_function(\"pcap_setnonblock\",  (_func *) &p_pcap_setnonblock);\r\n      load_function(\"pcap_lib_version\",  (_func *) &p_pcap_lib_version);\r\n      break;\r\n    default:                /* loaded or failed */\r\n      break;\r\n  }\r\n  return (lib_loaded == 1) ? 1 : 0;\r\n}\r\n\r\n/* define functions with dynamic revectoring */\r\nvoid pcap_close(pcap_t* a) {\r\n  if (load_pcap() != 0) {\r\n    p_pcap_close(a);\r\n  }\r\n}\r\n\r\n/* Some platforms's pcap.h have an ancient declaration of pcap_compile which doesn't have a const in the bpf string argument */\r\n#if !defined (BPF_CONST_STRING)\r\nint pcap_compile(pcap_t* a, struct bpf_program* b, char* c, int d, bpf_u_int32 e) {\r\n#else\r\nint pcap_compile(pcap_t* a, struct bpf_program* b, const char* c, int d, bpf_u_int32 e) {\r\n#endif\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_compile(a, b, c, d, e);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\nconst char *pcap_lib_version(void) {\r\n  static char buf[256];\r\n\r\n  if ((load_pcap() != 0) && (p_pcap_lib_version != NULL)) {\r\n    return p_pcap_lib_version();\r\n  } else {\r\n    sprintf (buf, \"%s not installed\",\r\n#if defined(_WIN32)\r\n        \"npcap or winpcap\"\r\n#else\r\n        \"libpcap\"\r\n#endif\r\n        );\r\n    return buf;\r\n  }\r\n}\r\n\r\nint pcap_datalink(pcap_t* a) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_datalink(a);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\nint pcap_dispatch(pcap_t* a, int b, pcap_handler c, u_char* d) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_dispatch(a, b, c, d);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\nint pcap_findalldevs(pcap_if_t** a, char* b) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_findalldevs(a, b);\r\n  } else {\r\n    *a = 0;\r\n    strcpy(b, no_pcap);\r\n    no_pcap[0] = '\\0';\r\n    return -1;\r\n  }\r\n}\r\n\r\nvoid pcap_freealldevs(pcap_if_t* a) {\r\n  if (load_pcap() != 0) {\r\n    p_pcap_freealldevs(a);\r\n  }\r\n}\r\n\r\nvoid pcap_freecode(struct bpf_program* a) {\r\n  if (load_pcap() != 0) {\r\n    p_pcap_freecode(a);\r\n  }\r\n}\r\n\r\nchar* pcap_geterr(pcap_t* a) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_geterr(a);\r\n  } else {\r\n    return (char*) \"\";\r\n  }\r\n}\r\n\r\nint pcap_lookupnet(const char* a, bpf_u_int32* b, bpf_u_int32* c, char* d) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_lookupnet(a, b, c, d);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\npcap_t* pcap_open_live(const char* a, int b, int c, int d, char* e) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_open_live(a, b, c, d, e);\r\n  } else {\r\n    return (pcap_t*) 0;\r\n  }\r\n}\r\n\r\n#ifdef _WIN32\r\nint pcap_setmintocopy(pcap_t* a, int b) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_setmintocopy(a, b);\r\n  } else {\r\n    return -1;\r\n  }\r\n}\r\n\r\nHANDLE pcap_getevent(pcap_t* a) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_getevent(a);\r\n  } else {\r\n    return (HANDLE) 0;\r\n  }\r\n}\r\n\r\n#else\r\n#ifdef MUST_DO_SELECT\r\nint pcap_get_selectable_fd(pcap_t* a) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_get_selectable_fd(a);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n#endif\r\n\r\nint pcap_fileno(pcap_t * a) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_fileno(a);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n#endif\r\n\r\nint pcap_sendpacket(pcap_t* a, const u_char* b, int c) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_sendpacket(a, b, c);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\nint pcap_setfilter(pcap_t* a, struct bpf_program* b) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_setfilter(a, b);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\nint pcap_setnonblock(pcap_t* a, int nonblock, char *errbuf) {\r\n  if (load_pcap() != 0) {\r\n    return p_pcap_setnonblock(a, nonblock, errbuf);\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n\r\n#if defined(HAVE_VDE_NETWORK)\r\n/* Dynamic VDE loading */\r\nstatic void load_vde (void)\r\n{\r\n  void *handle;\r\n\r\n  handle = dlopen(\"libvdeplug.\" __STR(SIM_DLOPEN_EXTENSION), RTLD_NOW|RTLD_GLOBAL);\r\n  if (handle == NULL)\r\n      handle = dlopen(\"libvdeplug.\" __STR(SIM_DLOPEN_EXTENSION) \".2\", RTLD_NOW|RTLD_GLOBAL);\r\n  if (handle != NULL) {\r\n#define _load_function(function)  *((_func **)&p_##function) = (_func *)((size_t)dlsym(handle, __STR(function)))\r\n    _load_function(vde_open_real);\r\n    _load_function(vde_datafd);\r\n    _load_function(vde_recv);\r\n    _load_function(vde_send);\r\n    _load_function(vde_close);\r\n#undef _load_function\r\n    }\r\n  eth_vde_network_available = (p_vde_open_real != NULL);\r\n}\r\n\r\n#endif\r\n\r\n\r\n#endif /* defined(USE_SHARED) && (defined(_WIN32) || defined(SIM_HAVE_DLOPEN)) */\r\n\r\n/* Some platforms have always had pcap_sendpacket */\r\n#if defined(_WIN32) || defined(__VMS)\r\n#define HAS_PCAP_SENDPACKET 1\r\n#else\r\n/* The latest libpcap and WinPcap all have pcap_sendpacket */\r\n#if !defined (NEED_PCAP_SENDPACKET)\r\n#define HAS_PCAP_SENDPACKET 1\r\n#endif\r\n#endif\r\n\r\n#if !defined (HAS_PCAP_SENDPACKET)\r\n/* libpcap has no function to write a packet, so we need to implement\r\n   pcap_sendpacket() for compatibility with the WinPcap base code.\r\n   Return value: 0=Success, -1=Failure */\r\nint pcap_sendpacket(pcap_t* handle, const u_char* msg, int len)\r\n{\r\n#if defined (__linux) || defined (__linux__)\r\n  return (send(pcap_fileno(handle), msg, len, 0) == len)? 0 : -1;\r\n#else\r\n  return (write(pcap_fileno(handle), msg, len) == len)? 0 : -1;\r\n#endif /* linux */\r\n}\r\n#endif /* !HAS_PCAP_SENDPACKET */\r\n\r\n#if defined(_WIN32) || defined(__CYGWIN__)\r\n/* extracted from WinPcap's Packet32.h */\r\nstruct _PACKET_OID_DATA {\r\n    uint32 Oid;                 ///< OID code. See the Microsoft DDK documentation or the file ntddndis.h\r\n                                ///< for a complete list of valid codes.\r\n    uint32 Length;              ///< Length of the data field\r\n    uint8 Data[1];              ///< variable-length field that contains the information passed to or received\r\n                                ///< from the adapter.\r\n};\r\ntypedef struct _PACKET_OID_DATA PACKET_OID_DATA, *PPACKET_OID_DATA;\r\ntypedef void **LPADAPTER;\r\n#define OID_802_3_CURRENT_ADDRESS               0x01010102 /* Extracted from ntddndis.h */\r\n\r\nstatic int pcap_mac_if_win32(const char *AdapterName, unsigned char MACAddress[6])\r\n{\r\n  LPADAPTER         lpAdapter;\r\n  PPACKET_OID_DATA  OidData;\r\n  int               Status;\r\n  int               ReturnValue;\r\n#ifdef _WIN32\r\n  HMODULE           hDll;         /* handle to DLL */\r\n#else\r\n  static void       *hDll = NULL; /* handle to Library */\r\n  typedef int BOOLEAN;\r\n#endif\r\n  LPADAPTER (*p_PacketOpenAdapter)(const char *AdapterName);\r\n  void (*p_PacketCloseAdapter)(LPADAPTER lpAdapter);\r\n  int (*p_PacketRequest)(LPADAPTER  AdapterObject,BOOLEAN Set,PPACKET_OID_DATA  OidData);\r\n\r\n#ifdef _WIN32\r\n  hDll = LoadLibraryA(\"packet.dll\");\r\n  p_PacketOpenAdapter = (LPADAPTER (*)(const char *AdapterName))GetProcAddress(hDll, \"PacketOpenAdapter\");\r\n  p_PacketCloseAdapter = (void (*)(LPADAPTER lpAdapter))GetProcAddress(hDll, \"PacketCloseAdapter\");\r\n  p_PacketRequest = (int (*)(LPADAPTER  AdapterObject,BOOLEAN Set,PPACKET_OID_DATA  OidData))GetProcAddress(hDll, \"PacketRequest\");\r\n#else\r\n  hDll = dlopen(\"packet.dll\", RTLD_NOW);\r\n  p_PacketOpenAdapter = (LPADAPTER (*)(const char *AdapterName))dlsym(hDll, \"PacketOpenAdapter\");\r\n  p_PacketCloseAdapter = (void (*)(LPADAPTER lpAdapter))dlsym(hDll, \"PacketCloseAdapter\");\r\n  p_PacketRequest = (int (*)(LPADAPTER  AdapterObject,BOOLEAN Set,PPACKET_OID_DATA  OidData))dlsym(hDll, \"PacketRequest\");\r\n#endif\r\n\r\n  /* Open the selected adapter */\r\n\r\n  lpAdapter =   p_PacketOpenAdapter(AdapterName);\r\n\r\n  if (!lpAdapter || (*lpAdapter == (void *)-1)) {\r\n#ifdef _WIN32\r\n      FreeLibrary(hDll);\r\n#else\r\n      dlclose(hDll);\r\n#endif\r\n    return -1;\r\n  }\r\n\r\n  /* Allocate a buffer to get the MAC address */\r\n\r\n  OidData = (PACKET_OID_DATA *)malloc(6 + sizeof(PACKET_OID_DATA));\r\n  if (OidData == NULL) {\r\n    p_PacketCloseAdapter(lpAdapter);\r\n#ifdef _WIN32\r\n    FreeLibrary(hDll);\r\n#else\r\n    dlclose(hDll);\r\n#endif\r\n    return -1;\r\n  }\r\n\r\n  /* Retrieve the adapter MAC querying the NIC driver */\r\n\r\n  OidData->Oid = OID_802_3_CURRENT_ADDRESS;\r\n\r\n  OidData->Length = 6;\r\n  memset(OidData->Data, 0, 6);\r\n\r\n  Status = p_PacketRequest(lpAdapter, FALSE, OidData);\r\n  if(Status) {\r\n    memcpy(MACAddress, OidData->Data, 6);\r\n    ReturnValue = 0;\r\n  } else\r\n    ReturnValue = -1;\r\n\r\n  free(OidData);\r\n  p_PacketCloseAdapter(lpAdapter);\r\n#ifdef _WIN32\r\n  FreeLibrary(hDll);\r\n#else\r\n  dlclose(hDll);\r\n#endif\r\n  return ReturnValue;\r\n}\r\n\r\n#endif  /* defined(_WIN32) || defined(__CYGWIN__) */\r\n\r\n#if defined (__VMS) && !defined(__VAX)\r\n#include <descrip.h>\r\n#include <iodef.h>\r\n#include <ssdef.h>\r\n#include <starlet.h>\r\n#include <stdio.h>\r\n#include <stsdef.h>\r\n#include <nmadef.h>\r\n\r\nstatic int pcap_mac_if_vms(const char *AdapterName, unsigned char MACAddress[6])\r\n{\r\n  char VMS_Device[16];\r\n  $DESCRIPTOR(Device, VMS_Device);\r\n  unsigned short iosb[4];\r\n  unsigned short *w;\r\n  unsigned char *pha = NULL;\r\n  unsigned char *hwa = NULL;\r\n  int tmpval;\r\n  int status;\r\n  unsigned short characteristics[512];\r\n  long chardesc[] = {sizeof(characteristics), (long)&characteristics};\r\n  unsigned short chan;\r\n#pragma member_alignment save\r\n#pragma nomember_alignment\r\n  static struct {\r\n    short fmt;\r\n    long val_fmt;\r\n    short pty;\r\n    long val_pty;\r\n    short pad;\r\n    long val_pad;\r\n    } setup  = {\r\n        NMA$C_PCLI_FMT, NMA$C_LINFM_ETH,\r\n        NMA$C_PCLI_PTY, 0x0090,\r\n        NMA$C_PCLI_PAD, NMA$C_STATE_OFF,\r\n    };\r\n#pragma member_alignment restore\r\n    long setupdesc[] = {sizeof(setup), (long)&setup};\r\n\r\n  /* Convert Interface Name to VMS Device Name */\r\n  /* This is a name shuffle */\r\n  /*   WE0 becomes EWA0:    */\r\n  /*   SE1 becomes ESB0:    */\r\n  /*   XE0 becomes EXA0:    */\r\n  tmpval = (int)(AdapterName[2]-'0');\r\n  if ((tmpval < 0) || (tmpval > 25))\r\n    return -1;\r\n  VMS_Device[0] = toupper(AdapterName[1]);\r\n  VMS_Device[1] = toupper(AdapterName[0]);\r\n  VMS_Device[2] = 'A' + tmpval;\r\n  VMS_Device[3] = '0';\r\n  VMS_Device[4] = '\\0';\r\n  VMS_Device[5] = '\\0';\r\n  Device.dsc$w_length = strlen(VMS_Device);\r\n  if (!$VMS_STATUS_SUCCESS( sys$assign (&Device, &chan, 0, 0, 0) ))\r\n    return -1;\r\n  status = sys$qiow (0, chan, IO$_SETMODE|IO$M_CTRL|IO$M_STARTUP, &iosb, 0, 0,\r\n                     0, &setupdesc, 0, 0, 0, 0);\r\n  if ((!$VMS_STATUS_SUCCESS(status)) || (!$VMS_STATUS_SUCCESS(iosb[0]))) {\r\n    sys$dassgn(chan);\r\n    return -1;\r\n    }\r\n  status = sys$qiow (0, chan, IO$_SENSEMODE|IO$M_CTRL, &iosb, 0, 0,\r\n                     0, &chardesc, 0, 0, 0, 0);\r\n  sys$dassgn(chan);\r\n  if ((!$VMS_STATUS_SUCCESS(status)) || (!$VMS_STATUS_SUCCESS(iosb[0])))\r\n    return -1;\r\n  for (w=characteristics; w < &characteristics[iosb[1]]; ) {\r\n    if ((((*w)&0xFFF) == NMA$C_PCLI_HWA) && (6 == *(w+1)))\r\n      hwa = (unsigned char *)(w + 2);\r\n    if ((((*w)&0xFFF) == NMA$C_PCLI_PHA) && (6 == *(w+1)))\r\n      pha = (unsigned char *)(w + 2);\r\n    if (((*w)&0x1000) == 0)\r\n      w += 3;                       /* Skip over Longword Parameter */\r\n    else\r\n      w += (2 + ((1 + *(w+1))/2));  /* Skip over String Parameter */\r\n    }\r\n  if (pha != NULL)                  /* Prefer Physical Address */\r\n    memcpy(MACAddress, pha, 6);\r\n  else\r\n    if (hwa != NULL)                /* Fallback to Hardware Address */\r\n      memcpy(MACAddress, hwa, 6);\r\n    else\r\n      return -1;\r\n  return 0;\r\n}\r\n#endif /* defined (__VMS) && !defined(__VAX) */\r\n\r\n#if SIM_MAJOR != 4\r\nstatic const char *sim_get_tool_path (const char *tool)\r\n{\r\nreturn tool;\r\n}\r\n#endif\r\n\r\nstatic void eth_get_nic_hw_addr(ETH_DEV* dev, const char *devname, int set_on)\r\n{\r\n  memset(&dev->host_nic_phy_hw_addr, 0, sizeof(dev->host_nic_phy_hw_addr));\r\n  dev->have_host_nic_phy_addr = 0;\r\n  if (dev->eth_api != ETH_API_PCAP)\r\n    return;\r\n#if defined(_WIN32) || defined(__CYGWIN__)\r\n  if (!pcap_mac_if_win32(devname, dev->host_nic_phy_hw_addr))\r\n    dev->have_host_nic_phy_addr = 1;\r\n#elif defined (__VMS) && !defined(__VAX)\r\n  if (!pcap_mac_if_vms(devname, dev->host_nic_phy_hw_addr))\r\n    dev->have_host_nic_phy_addr = 1;\r\n#elif !defined(__CYGWIN__) && !defined(__VMS)\r\n  if (1) {\r\n    char command[1024];\r\n    FILE *f;\r\n    int i;\r\n    char tool[CBUFSIZE];\r\n    const char *turnon[] = {\r\n        \"ip link set dev %.*s up 2>/dev/null\",\r\n        \"ifconfig %.*s up 2>/dev/null\",\r\n        NULL};\r\n    const char *patterns[] = {\r\n        \"ip link show %.*s 2>/dev/null | grep [0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F] 2>/dev/null\",\r\n        \"ip link show %.*s 2>/dev/null | grep -E [0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F] 2>/dev/null\",\r\n        \"ip link show %.*s 2>/dev/null | egrep [0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F] 2>/dev/null\",\r\n        \"ifconfig %.*s 2>/dev/null | grep [0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F]:[0-9a-fA-F][0-9a-fA-F] 2>/dev/null\",\r\n        \"ifconfig %.*s 2>/dev/null | grep -E [0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F] 2>/dev/null\",\r\n        \"ifconfig %.*s 2>/dev/null | egrep [0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F]:[0-9a-fA-F]?[0-9a-fA-F] 2>/dev/null\",\r\n        NULL};\r\n\r\n    memset(command, 0, sizeof(command));\r\n    if (set_on) {\r\n      /* try to force an otherwise unused interface to be turned on */\r\n      for (i=0; turnon[i]; ++i) {\r\n        snprintf(command, sizeof(command), turnon[i], (int)(sizeof(command) - (2 + strlen(turnon[i]))), devname);\r\n        get_glyph_nc (command, tool, 0);\r\n        if (sim_get_tool_path (tool)[0]) {\r\n          if (NULL != (f = popen(command, \"r\")))\r\n            pclose(f);\r\n          }\r\n        }\r\n      }\r\n    for (i=0; patterns[i] && (0 == dev->have_host_nic_phy_addr); ++i) {\r\n      snprintf(command, sizeof(command), patterns[i], (int)(sizeof(command) - (2 + strlen(patterns[i]))), devname);\r\n      get_glyph_nc (command, tool, 0);\r\n      if (sim_get_tool_path (tool)[0]) {\r\n        if (NULL != (f = popen(command, \"r\"))) {\r\n          while (0 == dev->have_host_nic_phy_addr) {\r\n            if (fgets(command, sizeof(command)-1, f)) {\r\n              char *p1, *p2;\r\n\r\n              p1 = strchr(command, ':');\r\n              while (p1) {\r\n                p2 = strchr(p1+1, ':');\r\n                if (p2 <= p1+3) {\r\n                  unsigned int mac_bytes[6];\r\n                  if (6 == sscanf(p1-2, \"%02x:%02x:%02x:%02x:%02x:%02x\", &mac_bytes[0], &mac_bytes[1], &mac_bytes[2], &mac_bytes[3], &mac_bytes[4], &mac_bytes[5])) {\r\n                    dev->host_nic_phy_hw_addr[0] = mac_bytes[0];\r\n                    dev->host_nic_phy_hw_addr[1] = mac_bytes[1];\r\n                    dev->host_nic_phy_hw_addr[2] = mac_bytes[2];\r\n                    dev->host_nic_phy_hw_addr[3] = mac_bytes[3];\r\n                    dev->host_nic_phy_hw_addr[4] = mac_bytes[4];\r\n                    dev->host_nic_phy_hw_addr[5] = mac_bytes[5];\r\n                    dev->have_host_nic_phy_addr = 1;\r\n                    }\r\n                  break;\r\n                  }\r\n                p1 = p2;\r\n                }\r\n              }\r\n            else\r\n              break;\r\n            }\r\n          pclose(f);\r\n          }\r\n        }\r\n      }\r\n    }\r\n#endif\r\n}\r\n\r\n#if defined(__APPLE__)\r\n#include <uuid/uuid.h>\r\n#include <unistd.h>\r\nstatic int _eth_get_system_id (char *buf, size_t buf_size)\r\n{\r\nstatic struct timespec wait = {5, 0};   /* 5 seconds */\r\nstatic uuid_t uuid;\r\n\r\nmemset (buf, 0, buf_size);\r\nif (buf_size < 37)\r\n  return -1;\r\nif (gethostuuid (uuid, &wait))\r\n  memset (uuid, 0, sizeof(uuid));\r\nuuid_unparse_lower(uuid, buf);\r\nreturn 0;\r\n}\r\n\r\n#elif defined(_WIN32)\r\nstatic int _eth_get_system_id (char *buf, size_t buf_size)\r\n{\r\n  LONG status;\r\n  DWORD reglen, regtype;\r\n  HKEY reghnd;\r\n\r\n  memset (buf, 0, buf_size);\r\n#ifndef KEY_WOW64_64KEY\r\n#define KEY_WOW64_64KEY         (0x0100)\r\n#endif\r\n  if ((status = RegOpenKeyExA (HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Cryptography\", 0, KEY_QUERY_VALUE|KEY_WOW64_64KEY, &reghnd)) != ERROR_SUCCESS)\r\n    return -1;\r\n  if (buf_size < 37)\r\n    return -1;\r\n  reglen = buf_size - 1;\r\n  if ((status = RegQueryValueExA (reghnd, \"MachineGuid\", NULL, &regtype, (LPBYTE)buf, &reglen)) != ERROR_SUCCESS) {\r\n    RegCloseKey (reghnd);\r\n    return -1;\r\n    }\r\n  RegCloseKey (reghnd );\r\n  /* make sure value is the right type, bail if not acceptable */\r\n  if ((regtype != REG_SZ) || (reglen > buf_size))\r\n    return -1;\r\n  /* registry value seems OK */\r\n  return 0;\r\n}\r\n\r\n#else\r\nstatic int _eth_get_system_id (char *buf, size_t buf_size)\r\n{\r\nFILE *f;\r\nt_bool popened = FALSE;\r\n\r\nmemset (buf, 0, buf_size);\r\nif (buf_size < 37)\r\n    return -1;\r\nif ((f = fopen (\"/etc/machine-id\", \"r\")) == NULL) {\r\n  f = popen (\"hostname\", \"r\");\r\n  popened = TRUE;\r\n  }\r\nif (f) {\r\n  size_t read_size;\r\n\r\n  read_size = fread (buf, 1, buf_size - 1, f);\r\n  buf[read_size] = '\\0';\r\n  if (popened)\r\n    pclose (f);\r\n  else\r\n    fclose (f);\r\n  }\r\nwhile ((strlen (buf) > 0) && sim_isspace(buf[strlen (buf) - 1]))\r\n  buf[strlen (buf) - 1] = '\\0';\r\nreturn 0;\r\n}\r\n#endif\r\n\r\n/* Forward declarations */\r\nstatic void\r\n_eth_callback(u_char* info, const struct pcap_pkthdr* header, const u_char* data);\r\n\r\nstatic t_stat\r\n_eth_write(ETH_DEV* dev, ETH_PACK* packet, ETH_PCALLBACK routine);\r\n\r\nstatic void\r\n_eth_error(ETH_DEV* dev, const char* where);\r\n\r\n#if defined(HAVE_SLIRP_NETWORK)\r\nstatic void _slirp_callback (void *opaque, const unsigned char *buf, int len)\r\n{\r\nstruct pcap_pkthdr header;\r\n\r\nmemset(&header, 0, sizeof(header));\r\nheader.caplen = header.len = len;\r\n_eth_callback((u_char *)opaque, &header, buf);\r\n}\r\n#endif\r\n\r\n#if defined (USE_READER_THREAD)\r\nstatic void *\r\n_eth_reader(void *arg)\r\n{\r\nETH_DEV* volatile dev = (ETH_DEV*)arg;\r\nint status = 0;\r\nint sel_ret = 0;\r\nint do_select = 0;\r\nSOCKET select_fd = 0;\r\n#if defined (_WIN32)\r\nHANDLE hWait = (dev->eth_api == ETH_API_PCAP) ? pcap_getevent ((pcap_t*)dev->handle) : NULL;\r\n#endif\r\n\r\nswitch (dev->eth_api) {\r\n  case ETH_API_PCAP:\r\n#if defined (HAVE_PCAP_NETWORK)\r\n#if defined (MUST_DO_SELECT)\r\n    do_select = 1;\r\n    select_fd = pcap_get_selectable_fd((pcap_t *)dev->handle);\r\n#endif\r\n#endif\r\n    break;\r\n  case ETH_API_TAP:\r\n  case ETH_API_VDE:\r\n  case ETH_API_UDP:\r\n  case ETH_API_NAT:\r\n    do_select = 1;\r\n    select_fd = dev->fd_handle;\r\n    break;\r\n  }\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Reader Thread Starting\\n\");\r\n\r\n/* Boost Priority for this I/O thread vs the CPU instruction execution\r\n   thread which, in general, won't be readily yielding the processor\r\n   when this thread needs to run */\r\nsim_os_set_thread_priority (PRIORITY_ABOVE_NORMAL);\r\n\r\nwhile (dev->handle) {\r\n#if defined (_WIN32)\r\n  if (dev->eth_api == ETH_API_PCAP) {\r\n    if (WAIT_OBJECT_0 == WaitForSingleObject (hWait, 250))\r\n      sel_ret = 1;\r\n    }\r\n  if ((dev->eth_api == ETH_API_UDP) || (dev->eth_api == ETH_API_NAT))\r\n#endif /* _WIN32 */\r\n  if (1) {\r\n    if (do_select) {\r\n#ifdef HAVE_SLIRP_NETWORK\r\n      if (dev->eth_api == ETH_API_NAT) {\r\n        sel_ret = sim_slirp_select ((SLIRP*)dev->handle, 250);\r\n        }\r\n      else\r\n#endif\r\n        {\r\n        fd_set setl;\r\n        struct timeval timeout;\r\n\r\n        FD_ZERO(&setl);\r\n        FD_SET(select_fd, &setl);\r\n        timeout.tv_sec = 0;\r\n        timeout.tv_usec = 250*1000;\r\n        sel_ret = select(1+select_fd, &setl, NULL, NULL, &timeout);\r\n        }\r\n      }\r\n    else\r\n      sel_ret = 1;\r\n    if (sel_ret < 0 && errno != EINTR)\r\n      break;\r\n    }\r\n  if (sel_ret > 0) {\r\n    if (!dev->handle)\r\n      break;\r\n    /* dispatch read request queue available packets */\r\n    switch (dev->eth_api) {\r\n#ifdef HAVE_PCAP_NETWORK\r\n      case ETH_API_PCAP:\r\n        status = pcap_dispatch ((pcap_t*)dev->handle, -1, &_eth_callback, (u_char*)dev);\r\n        break;\r\n#endif\r\n#ifdef HAVE_TAP_NETWORK\r\n      case ETH_API_TAP:\r\n        if (1) {\r\n          struct pcap_pkthdr header;\r\n          int len;\r\n          u_char buf[ETH_MAX_JUMBO_FRAME];\r\n\r\n          memset(&header, 0, sizeof(header));\r\n          len = read(dev->fd_handle, buf, sizeof(buf));\r\n          if (len > 0) {\r\n            status = 1;\r\n            header.caplen = header.len = len;\r\n            _eth_callback((u_char *)dev, &header, buf);\r\n            }\r\n          else {\r\n            if (len < 0)\r\n              status = -1;\r\n            else\r\n              status = 0;\r\n            }\r\n          }\r\n        break;\r\n#endif /* HAVE_TAP_NETWORK */\r\n#ifdef HAVE_VDE_NETWORK\r\n      case ETH_API_VDE:\r\n        if (1) {\r\n          struct pcap_pkthdr header;\r\n          int len;\r\n          u_char buf[ETH_MAX_JUMBO_FRAME];\r\n\r\n          memset(&header, 0, sizeof(header));\r\n          len = p_vde_recv((VDECONN *)dev->handle, buf, sizeof(buf), 0);\r\n          if (len > 0) {\r\n            status = 1;\r\n            header.caplen = header.len = len;\r\n            _eth_callback((u_char *)dev, &header, buf);\r\n            }\r\n          else {\r\n            if (len < 0)\r\n              status = -1;\r\n            else\r\n              status = 0;\r\n            }\r\n          }\r\n        break;\r\n#endif /* HAVE_VDE_NETWORK */\r\n#ifdef HAVE_SLIRP_NETWORK\r\n      case ETH_API_NAT:\r\n        sim_slirp_dispatch ((SLIRP*)dev->handle);\r\n        status = 1;\r\n        break;\r\n#endif /* HAVE_SLIRP_NETWORK */\r\n      case ETH_API_UDP:\r\n        if (1) {\r\n          struct pcap_pkthdr header;\r\n          int len;\r\n          u_char buf[ETH_MAX_JUMBO_FRAME];\r\n\r\n          memset(&header, 0, sizeof(header));\r\n          len = (int)sim_read_sock (select_fd, (char *)buf, (int32)sizeof(buf));\r\n          if (len > 0) {\r\n            status = 1;\r\n            header.caplen = header.len = len;\r\n            _eth_callback((u_char *)dev, &header, buf);\r\n            }\r\n          else {\r\n            if (len < 0)\r\n              status = -1;\r\n            else\r\n              status = 0;\r\n            }\r\n          }\r\n        break;\r\n      }\r\n    if ((status > 0) && (dev->asynch_io)) {\r\n      int wakeup_needed;\r\n\r\n      pthread_mutex_lock (&dev->lock);\r\n      wakeup_needed = (dev->read_queue.count != 0);\r\n      pthread_mutex_unlock (&dev->lock);\r\n      if (wakeup_needed) {\r\n        sim_debug(dev->dbit, dev->dptr, \"Queueing automatic poll\\n\");\r\n        sim_activate_abs (dev->dptr->units, dev->asynch_io_latency);\r\n        }\r\n      }\r\n    if (status < 0) {\r\n      ++dev->receive_packet_errors;\r\n      _eth_error (dev, \"_eth_reader\");\r\n      if (dev->handle) { /* Still attached? */\r\n#if defined (_WIN32)\r\n        hWait = (dev->eth_api == ETH_API_PCAP) ? pcap_getevent ((pcap_t*)dev->handle) : NULL;\r\n#endif\r\n        if (do_select) {\r\n          select_fd = dev->fd_handle;\r\n#if !defined (_WIN32) && defined(HAVE_PCAP_NETWORK)\r\n          if (dev->eth_api == ETH_API_PCAP)\r\n            select_fd = pcap_get_selectable_fd((pcap_t *)dev->handle);\r\n#endif\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Reader Thread Exiting\\n\");\r\nreturn NULL;\r\n}\r\n\r\nstatic void *\r\n_eth_writer(void *arg)\r\n{\r\nETH_DEV* volatile dev = (ETH_DEV*)arg;\r\nETH_WRITE_REQUEST *request = NULL;\r\n\r\n/* Boost Priority for this I/O thread vs the CPU instruction execution\r\n   thread which in general won't be readily yielding the processor when\r\n   this thread needs to run */\r\nsim_os_set_thread_priority (PRIORITY_ABOVE_NORMAL);\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Writer Thread Starting\\n\");\r\n\r\npthread_mutex_lock (&dev->writer_lock);\r\nwhile (dev->handle) {\r\n  pthread_cond_wait (&dev->writer_cond, &dev->writer_lock);\r\n  while (NULL != (request = dev->write_requests)) {\r\n    if (dev->handle == NULL)      /* Shutting down? */\r\n      break;\r\n    /* Pull buffer off request list */\r\n    dev->write_requests = request->next;\r\n    pthread_mutex_unlock (&dev->writer_lock);\r\n\r\n    if (dev->throttle_delay != ETH_THROT_DISABLED_DELAY) {\r\n      uint32 packet_delta_time = sim_os_msec() - dev->throttle_packet_time;\r\n      dev->throttle_events <<= 1;\r\n      dev->throttle_events += (packet_delta_time < dev->throttle_time) ? 1 : 0;\r\n      if ((dev->throttle_events & dev->throttle_mask) == dev->throttle_mask) {\r\n        sim_os_ms_sleep (dev->throttle_delay);\r\n        ++dev->throttle_count;\r\n        }\r\n      dev->throttle_packet_time = sim_os_msec();\r\n      }\r\n    dev->write_status = _eth_write(dev, &request->packet, NULL);\r\n\r\n    pthread_mutex_lock (&dev->writer_lock);\r\n    /* Put buffer on free buffer list */\r\n    request->next = dev->write_buffers;\r\n    dev->write_buffers = request;\r\n    request = NULL;\r\n    }\r\n  }\r\n/* If we exited these loops with a request allocated, */\r\n/* avoid buffer leaking by putting it on free buffer list */\r\nif (request) {\r\n  request->next = dev->write_buffers;\r\n  dev->write_buffers = request;\r\n  }\r\npthread_mutex_unlock (&dev->writer_lock);\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Writer Thread Exiting\\n\");\r\nreturn NULL;\r\n}\r\n#endif\r\n\r\n/* eth_set_async\r\n *\r\n * Turn on receiver processing which can be either asynchronous or polled\r\n */\r\nt_stat eth_set_async (ETH_DEV *dev, int latency)\r\n{\r\n#if !defined(USE_READER_THREAD) || !defined(SIM_ASYNCH_IO)\r\nchar *msg = \"Eth: Can't operate asynchronously, must poll.\\n\"\r\n            \" *** Build with USE_READER_THREAD defined and link with pthreads for asynchronous operation. ***\\n\";\r\nreturn sim_messagef (SCPE_NOFNC, \"%s\", msg);\r\n#else\r\nint wakeup_needed;\r\n\r\ndev->asynch_io = sim_asynch_enabled;\r\ndev->asynch_io_latency = latency;\r\npthread_mutex_lock (&dev->lock);\r\nwakeup_needed = (dev->read_queue.count != 0);\r\npthread_mutex_unlock (&dev->lock);\r\nif (wakeup_needed) {\r\n  sim_debug(dev->dbit, dev->dptr, \"Queueing automatic poll\\n\");\r\n  sim_activate_abs (dev->dptr->units, dev->asynch_io_latency);\r\n  }\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* eth_clr_async\r\n *\r\n * Turn off receiver processing\r\n */\r\nt_stat eth_clr_async (ETH_DEV *dev)\r\n{\r\n#if !defined(USE_READER_THREAD) || !defined(SIM_ASYNCH_IO)\r\nreturn SCPE_NOFNC;\r\n#else\r\n/* make sure device exists */\r\nif (!dev) return SCPE_UNATT;\r\n\r\ndev->asynch_io = 0;\r\nreturn SCPE_OK;\r\n#endif\r\n}\r\n\r\nt_stat eth_set_throttle (ETH_DEV* dev, uint32 time, uint32 burst, uint32 delay)\r\n{\r\nif (!dev)\r\n  return SCPE_IERR;\r\ndev->throttle_time = time;\r\ndev->throttle_burst = burst;\r\ndev->throttle_delay = delay;\r\ndev->throttle_mask = (1 << dev->throttle_burst) - 1;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat _eth_open_port(char *savname, int *eth_api, void **handle, SOCKET *fd_handle, char errbuf[PCAP_ERRBUF_SIZE], char *bpf_filter, void *opaque, DEVICE *dptr, uint32 dbit)\r\n{\r\nint bufsz = (BUFSIZ < ETH_MAX_PACKET) ? ETH_MAX_PACKET : BUFSIZ;\r\n\r\nif (bufsz < ETH_MAX_JUMBO_FRAME)\r\n  bufsz = ETH_MAX_JUMBO_FRAME;    /* Enable handling of jumbo frames */\r\n\r\n*eth_api = 0;\r\n*handle = NULL;\r\n*fd_handle = 0;\r\n\r\n/* attempt to connect device */\r\nmemset(errbuf, 0, PCAP_ERRBUF_SIZE);\r\nif (0 == strncmp(\"tap:\", savname, 4)) {\r\n  int  tun = -1;    /* TUN/TAP Socket */\r\n  int  on = 1;\r\n  const char *devname = savname + 4;\r\n\r\n  while (isspace(*devname))\r\n      ++devname;\r\n#if defined(HAVE_TAP_NETWORK)\r\n  if (!strcmp(savname, \"tap:tapN\"))\r\n    return sim_messagef (SCPE_OPENERR, \"Eth: Must specify actual tap device name (i.e. tap:tap0)\\n\");\r\n#endif\r\n#if (defined(__linux) || defined(__linux__)) && defined(HAVE_TAP_NETWORK)\r\n  if ((tun = open(\"/dev/net/tun\", O_RDWR)) >= 0) {\r\n    struct ifreq ifr; /* Interface Requests */\r\n\r\n    memset(&ifr, 0, sizeof(ifr));\r\n    /* Set up interface flags */\r\n    strlcpy(ifr.ifr_name, devname, sizeof(ifr.ifr_name));\r\n    ifr.ifr_flags = IFF_TAP|IFF_NO_PI;\r\n\r\n    /* Send interface requests to TUN/TAP driver. */\r\n    if (ioctl(tun, TUNSETIFF, &ifr) >= 0) {\r\n      if (ioctl(tun, FIONBIO, &on)) {\r\n        strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n        close(tun);\r\n        tun = -1;\r\n        }\r\n      else {\r\n        *fd_handle = (SOCKET)tun;\r\n        strcpy(savname, ifr.ifr_name);\r\n        }\r\n      }\r\n    else\r\n      strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n    }\r\n  else\r\n    strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n  if ((tun >= 0) && (errbuf[0] != 0)) {\r\n    close(tun);\r\n    tun = -1;\r\n    }\r\n#elif defined(HAVE_BSDTUNTAP) && defined(HAVE_TAP_NETWORK)\r\n  if (1) {\r\n    char dev_name[64] = \"\";\r\n\r\n    snprintf(dev_name, sizeof(dev_name)-1, \"/dev/%s\", devname);\r\n    dev_name[sizeof(dev_name)-1] = '\\0';\r\n\r\n    if ((tun = open(dev_name, O_RDWR)) >= 0) {\r\n      if (ioctl(tun, FIONBIO, &on)) {\r\n        strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n        close(tun);\r\n        tun = -1;\r\n        }\r\n      else {\r\n        *fd_handle = (SOCKET)tun;\r\n        memmove(savname, devname, strlen(devname) + 1);\r\n        }\r\n#if defined (__APPLE__)\r\n      if (tun >= 0) {       /* Good so far? */\r\n        struct ifreq ifr;\r\n        int s;\r\n\r\n        /* Now make sure the interface is up */\r\n        memset (&ifr, 0, sizeof(ifr));\r\n        ifr.ifr_addr.sa_family = AF_INET;\r\n        strlcpy(ifr.ifr_name, savname, sizeof(ifr.ifr_name));\r\n        if ((s = socket(AF_INET, SOCK_DGRAM, 0)) >= 0) {\r\n          if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) >= 0) {\r\n            ifr.ifr_flags |= IFF_UP;\r\n            if (ioctl(s, SIOCSIFFLAGS, (caddr_t)&ifr)) {\r\n              strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n              close(tun);\r\n              tun = -1;\r\n              }\r\n            }\r\n          close(s);\r\n          }\r\n        }\r\n#endif\r\n      }\r\n    else\r\n      strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n    if ((tun >= 0) && (errbuf[0] != 0)) {\r\n      close(tun);\r\n      tun = -1;\r\n      }\r\n    }\r\n#else\r\n  strlcpy(errbuf, \"No support for tap: devices\", PCAP_ERRBUF_SIZE);\r\n#endif /* !defined(__linux) && !defined(HAVE_BSDTUNTAP) */\r\n  if (0 == errbuf[0]) {\r\n    *eth_api = ETH_API_TAP;\r\n    *handle = (void *)1;  /* Flag used to indicated open */\r\n    }\r\n  }\r\nelse { /* !tap: */\r\n  if (0 == strncmp(\"vde:\", savname, 4)) {\r\n#if defined(HAVE_VDE_NETWORK)\r\n    if (eth_vde_network_available) {\r\n      char vdeswitch_s[CBUFSIZE]; /* VDE switch name */\r\n      char vdeport_s[CBUFSIZE];   /* VDE switch port (optional), numeric */\r\n\r\n      struct vde_open_args voa;\r\n      const char *devname = savname + 4;\r\n\r\n      memset(&voa, 0, sizeof(voa));\r\n      if (!strcmp(savname, \"vde:vdedevice\"))\r\n        return sim_messagef (SCPE_OPENERR, \"Eth: Must specify actual vde device name (i.e. vde:/tmp/switch)\\n\");\r\n      while (isspace(*devname))\r\n        ++devname;\r\n      devname = get_glyph_nc (devname, vdeswitch_s, ':'); /* Extract switch name          */\r\n      devname = get_glyph_nc (devname, vdeport_s, 0);     /* Extract optional port number */\r\n\r\n      if (vdeport_s[0]) {                                 /* port provided? */\r\n        t_stat r;\r\n\r\n        voa.port = (int)get_uint (vdeport_s, 10, 255, &r);\r\n        if (r != SCPE_OK)\r\n            return sim_messagef (SCPE_OPENERR, \"Eth: Invalid vde port number: %s in %s\\n\", vdeport_s, savname);\r\n        }\r\n\r\n      if (!(*handle = (void*) p_vde_open_real((char *)vdeswitch_s, (char *)\"simh\", LIBVDEPLUG_INTERFACE_VERSION, &voa)))\r\n        strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n      else {\r\n        *eth_api = ETH_API_VDE;\r\n        *fd_handle = (SOCKET)p_vde_datafd((VDECONN*)(*handle));\r\n        }\r\n      }\r\n    else\r\n      strlcpy(errbuf, \"No support for vde: network devices\", PCAP_ERRBUF_SIZE);\r\n#else\r\n    strlcpy(errbuf, \"No support for vde: network devices\", PCAP_ERRBUF_SIZE);\r\n#endif /* defined(HAVE_VDE_NETWORK) */\r\n    }\r\n  else { /* !vde: */\r\n    if (0 == strncmp(\"nat:\", savname, 4)) {\r\n#if defined(HAVE_SLIRP_NETWORK)\r\n      const char *devname = savname + 4;\r\n\r\n      while (isspace(*devname))\r\n        ++devname;\r\n      if (!(*handle = (void*) sim_slirp_open(devname, opaque, &_slirp_callback, dptr, dbit, errbuf, PCAP_ERRBUF_SIZE)))\r\n        strlcpy(errbuf, strerror(errno), PCAP_ERRBUF_SIZE);\r\n      else {\r\n        *eth_api = ETH_API_NAT;\r\n        *fd_handle = 0;\r\n        }\r\n#else\r\n      strlcpy(errbuf, \"No support for nat: network devices\", PCAP_ERRBUF_SIZE);\r\n#endif /* defined(HAVE_SLIRP_NETWORK) */\r\n      }\r\n    else { /* not nat: */\r\n      if (0 == strncmp(\"udp:\", savname, 4)) {\r\n        char localport[CBUFSIZE], host[CBUFSIZE], port[CBUFSIZE];\r\n        char hostport[2*CBUFSIZE];\r\n        const char *devname = savname + 4;\r\n\r\n        if (!strcmp(savname, \"udp:sourceport:remotehost:remoteport\"))\r\n          return sim_messagef (SCPE_OPENERR, \"Eth: Must specify actual udp host and ports(i.e. udp:1224:somehost.com:2234)\\n\");\r\n\r\n        while (isspace(*devname))\r\n          ++devname;\r\n        if (SCPE_OK != sim_parse_addr_ex (devname, host, sizeof(host), \"localhost\", port, sizeof(port), localport, sizeof(localport), NULL))\r\n          return SCPE_OPENERR;\r\n\r\n        if (localport[0] == '\\0')\r\n          strcpy (localport, port);\r\n        sprintf (hostport, \"%s:%s\", host, port);\r\n        if ((SCPE_OK == sim_parse_addr (hostport, NULL, 0, NULL, NULL, 0, NULL, \"localhost\")) &&\r\n            (0 == strcmp (localport, port)))\r\n          return sim_messagef (SCPE_OPENERR, \"Eth: Must specify different udp localhost ports\\n\");\r\n        *fd_handle = sim_connect_sock_ex (localport, hostport, NULL, NULL, SIM_SOCK_OPT_DATAGRAM);\r\n        if (INVALID_SOCKET == *fd_handle)\r\n          return SCPE_OPENERR;\r\n        *eth_api = ETH_API_UDP;\r\n        *handle = (void *)1;  /* Flag used to indicated open */\r\n        }\r\n      else { /* not udp:, so attempt to open the parameter as if it were an explicit device name */\r\n#if defined(HAVE_PCAP_NETWORK)\r\n        *handle = (void*) pcap_open_live(savname, bufsz, ETH_PROMISC, PCAP_READ_TIMEOUT, errbuf);\r\n#if !defined(__CYGWIN__) && !defined(__VMS) && !defined(_WIN32)\r\n        if (!*handle) { /* can't open device */\r\n          if (strstr (errbuf, \"That device is not up\")) {\r\n            char command[1024];\r\n\r\n            /* try to force an otherwise unused interface to be turned on */\r\n            snprintf(command, sizeof(command), (sim_get_tool_path (\"ifconfig\")[0] != '\\0') ? \"ifconfig %s up\" : \"ip link set dev %s up\", savname);\r\n            if (system(command)) {};\r\n            errbuf[0] = '\\0';\r\n            *handle = (void*) pcap_open_live(savname, bufsz, ETH_PROMISC, PCAP_READ_TIMEOUT, errbuf);\r\n            }\r\n          }\r\n#endif\r\n        if (!*handle)  /* can't open device */\r\n          return sim_messagef (SCPE_OPENERR, \"Eth: pcap_open_live error - %s\\n\", errbuf);\r\n        *eth_api = ETH_API_PCAP;\r\n#if !defined(HAS_PCAP_SENDPACKET) && defined (xBSD) && !defined (__APPLE__)\r\n        /* Tell the kernel that the header is fully-formed when it gets it.\r\n           This is required in order to fake the src address. */\r\n        if (1) {\r\n          int one = 1;\r\n          ioctl(pcap_fileno(*handle), BIOCSHDRCMPLT, &one);\r\n          }\r\n#endif /* xBSD */\r\n#if defined(_WIN32)\r\n        if ((pcap_setmintocopy ((pcap_t*)(*handle), 0) == -1) ||\r\n            (pcap_getevent ((pcap_t*)(*handle)) == NULL)) {\r\n          pcap_close ((pcap_t*)(*handle));\r\n          errbuf[PCAP_ERRBUF_SIZE-1] = '\\0';\r\n          snprintf (errbuf, PCAP_ERRBUF_SIZE-1, \"pcap can't initialize API for interface: %s\", savname);\r\n          return SCPE_OPENERR;\r\n          }\r\n#endif\r\n#if !defined (USE_READER_THREAD)\r\n#ifdef USE_SETNONBLOCK\r\n        /* set ethernet device non-blocking so pcap_dispatch() doesn't hang */\r\n        if (pcap_setnonblock (*handle, 1, errbuf) == -1) {\r\n          sim_printf (\"Eth: Failed to set non-blocking: %s\\n\", errbuf);\r\n          }\r\n#endif\r\n#if defined (__APPLE__)\r\n        if (1) {\r\n          /* Deliver packets immediately, needed for OS X 10.6.2 and later\r\n           * (Snow-Leopard).\r\n           * See this thread on libpcap and Mac Os X 10.6 Snow Leopard on\r\n           * the tcpdump mailinglist: http://seclists.org/tcpdump/2010/q1/110\r\n           */\r\n          int v = 1;\r\n          ioctl(pcap_fileno(*handle), BIOCIMMEDIATE, &v);\r\n          }\r\n#endif /* defined (__APPLE__) */\r\n#endif /* !defined (USE_READER_THREAD) */\r\n#else\r\n        strlcpy (errbuf, \"Unknown or unsupported network device\", PCAP_ERRBUF_SIZE);\r\n#endif /* defined(HAVE_PCAP_NETWORK) */\r\n        } /* not udp:, so attempt to open the parameter as if it were an explicit device name */\r\n      } /* !nat: */\r\n    } /* !vde: */\r\n  } /* !tap: */\r\nif (errbuf[0])\r\n  return SCPE_OPENERR;\r\n\r\n#ifdef USE_BPF\r\nif (bpf_filter && (*eth_api == ETH_API_PCAP)) {\r\n  struct bpf_program bpf;\r\n  int status;\r\n  bpf_u_int32  bpf_subnet, bpf_netmask;\r\n\r\n  if (pcap_lookupnet(savname, &bpf_subnet, &bpf_netmask, errbuf)<0)\r\n    bpf_netmask = 0;\r\n  /* compile filter string */\r\n  if ((status = pcap_compile((pcap_t*)(*handle), &bpf, bpf_filter, 1, bpf_netmask)) < 0) {\r\n    sprintf(errbuf, \"%s\", pcap_geterr((pcap_t*)(*handle)));\r\n    sim_printf(\"Eth: pcap_compile error: %s\\n\", errbuf);\r\n    /* show erroneous BPF string */\r\n    sim_printf (\"Eth: BPF string is: |%s|\\n\", bpf_filter);\r\n    }\r\n  else {\r\n    /* apply compiled filter string */\r\n    if ((status = pcap_setfilter((pcap_t*)(*handle), &bpf)) < 0) {\r\n      sprintf(errbuf, \"%s\", pcap_geterr((pcap_t*)(*handle)));\r\n      sim_printf(\"Eth: pcap_setfilter error: %s\\n\", errbuf);\r\n      }\r\n    else {\r\n#ifdef USE_SETNONBLOCK\r\n      /* set file non-blocking */\r\n      status = pcap_setnonblock ((pcap_t*)(*handle), 1, errbuf);\r\n#endif /* USE_SETNONBLOCK */\r\n      }\r\n    pcap_freecode(&bpf);\r\n    }\r\n  }\r\n#endif /* USE_BPF */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat eth_open(ETH_DEV* dev, const char* name, DEVICE* dptr, uint32 dbit)\r\n{\r\nt_stat r;\r\nint bufsz = (BUFSIZ < ETH_MAX_PACKET) ? ETH_MAX_PACKET : BUFSIZ;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\nchar temp[1024], desc[1024] = \"\";\r\nconst char* savname = name;\r\nchar namebuf[4*CBUFSIZE];\r\nint   num;\r\n\r\nif (bufsz < ETH_MAX_JUMBO_FRAME)\r\n  bufsz = ETH_MAX_JUMBO_FRAME;    /* Enable handling of jumbo frames */\r\n\r\n/* initialize device */\r\neth_zero(dev);\r\n\r\n/* translate name of type \"eth<num>\" to real device name */\r\nif ((strlen(name) == 4 || strlen(name) == 5)\r\n    && (tolower(name[0]) == 'e')\r\n    && (tolower(name[1]) == 't')\r\n    && (tolower(name[2]) == 'h')\r\n    && isdigit(name[3])\r\n    && (strlen(name) == 4 || isdigit(name[4]))\r\n   ) {\r\n  num = atoi(&name[3]);\r\n  savname = _eth_getname(num, temp, desc);\r\n  if (savname == NULL) /* didn't translate */\r\n    return SCPE_OPENERR;\r\n  }\r\nelse {\r\n  /* are they trying to use device description? */\r\n  savname = eth_getname_bydesc(name, temp, desc);\r\n  if (savname == NULL) { /* didn't translate */\r\n    /* probably is not ethX and has no description */\r\n    savname = eth_getname_byname(name, temp, desc);\r\n    if (savname == NULL) {/* didn't translate */\r\n      savname = name;\r\n      desc[0] = '\\0';   /* no description */\r\n      }\r\n    }\r\n  }\r\n\r\nnamebuf[sizeof(namebuf)-1] = '\\0';\r\nstrlcpy (namebuf, savname, sizeof(namebuf));\r\nif (strchr (namebuf, ':')) {\r\n    for (num = 0; (namebuf[num] != ':') && (namebuf[num] != '\\0'); num++)\r\n        if (isupper (namebuf[num]))\r\n            namebuf[num] = tolower (namebuf[num]);\r\n    }\r\nsavname = namebuf;\r\nr = _eth_open_port(namebuf, &dev->eth_api, &dev->handle, &dev->fd_handle, errbuf, NULL, (void *)dev, dptr, dbit);\r\n\r\nif (errbuf[0])\r\n  return sim_messagef (SCPE_OPENERR, \"Eth: open error - %s\\n\", errbuf);\r\nif (r != SCPE_OK)\r\n  return r;\r\n\r\nif (!strcmp (desc, \"No description available\"))\r\n    strcpy (desc, \"\");\r\nsim_messagef (SCPE_OK, \"Eth: opened OS device %s%s%s\\n\", savname, desc[0] ? \" - \" : \"\", desc);\r\n\r\n/* get the NIC's hardware MAC address */\r\neth_get_nic_hw_addr(dev, savname, 1);\r\n\r\n/* save name of device */\r\ndev->name = (char *)malloc(strlen(savname)+1);\r\nstrcpy(dev->name, savname);\r\n\r\n/* save debugging information */\r\ndev->dptr = dptr;\r\ndev->dbit = dbit;\r\n\r\n#if defined (USE_READER_THREAD)\r\nif (1) {\r\n  pthread_attr_t attr;\r\n\r\n  ethq_init (&dev->read_queue, 200);         /* initialize FIFO queue */\r\n  pthread_mutex_init (&dev->lock, NULL);\r\n  pthread_mutex_init (&dev->writer_lock, NULL);\r\n  pthread_mutex_init (&dev->self_lock, NULL);\r\n  pthread_cond_init (&dev->writer_cond, NULL);\r\n  pthread_attr_init(&attr);\r\n  pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);\r\n#if defined(__hpux)\r\n  {\r\n    /* libpcap needs sizeof(long) * 8192 bytes on the stack */\r\n    size_t stack_size;\r\n    const size_t min_stack_size = sizeof(long) * 8192 * 3 / 2;\r\n    if (!pthread_attr_getstacksize(&attr, &stack_size) && stack_size < min_stack_size) {\r\n      pthread_attr_setstacksize(&attr, min_stack_size);\r\n    }\r\n  }\r\n#endif /* defined(__hpux) */\r\n  pthread_create (&dev->reader_thread, &attr, _eth_reader, (void *)dev);\r\n  pthread_create (&dev->writer_thread, &attr, _eth_writer, (void *)dev);\r\n  pthread_attr_destroy(&attr);\r\n  }\r\n#endif /* defined (USE_READER_THREAD */\r\n_eth_add_to_open_list (dev);\r\n/*\r\n * install a total filter on a newly opened interface and let the device\r\n * simulator install an appropriate filter that reflects the device's\r\n * configuration.\r\n */\r\nreturn eth_filter_hash (dev, 0, NULL, FALSE, FALSE, NULL);\r\n}\r\n\r\nstatic t_stat _eth_close_port(int eth_api, pcap_t *pcap, SOCKET pcap_fd)\r\n{\r\nswitch (eth_api) {\r\n#ifdef HAVE_PCAP_NETWORK\r\n  case ETH_API_PCAP:\r\n    pcap_close(pcap);\r\n    break;\r\n#endif\r\n#ifdef HAVE_TAP_NETWORK\r\n  case ETH_API_TAP:\r\n    close(pcap_fd);\r\n    break;\r\n#endif\r\n#ifdef HAVE_VDE_NETWORK\r\n  case ETH_API_VDE:\r\n    p_vde_close((VDECONN*)pcap);\r\n    break;\r\n#endif\r\n#ifdef HAVE_SLIRP_NETWORK\r\n  case ETH_API_NAT:\r\n    sim_slirp_close((SLIRP*)pcap);\r\n    break;\r\n#endif\r\n  case ETH_API_UDP:\r\n    sim_close_sock(pcap_fd);\r\n    break;\r\n  }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat eth_close(ETH_DEV* dev)\r\n{\r\npcap_t *pcap;\r\nSOCKET pcap_fd;\r\n\r\n/* make sure device exists */\r\nif (!dev) return SCPE_UNATT;\r\n\r\n/* close the device */\r\npcap_fd = dev->fd_handle;                   /* save handle to possibly close later */\r\npcap = (pcap_t *)dev->handle;\r\ndev->handle = NULL;\r\ndev->fd_handle = 0;\r\ndev->have_host_nic_phy_addr = 0;\r\n\r\n#if defined (USE_READER_THREAD)\r\npthread_join (dev->reader_thread, NULL);\r\npthread_mutex_destroy (&dev->lock);\r\npthread_cond_signal (&dev->writer_cond);\r\npthread_join (dev->writer_thread, NULL);\r\npthread_mutex_destroy (&dev->self_lock);\r\npthread_mutex_destroy (&dev->writer_lock);\r\npthread_cond_destroy (&dev->writer_cond);\r\nif (1) {\r\n  ETH_WRITE_REQUEST *buffer;\r\n   while (NULL != (buffer = dev->write_buffers)) {\r\n    dev->write_buffers = buffer->next;\r\n    free(buffer);\r\n    }\r\n  while (NULL != (buffer = dev->write_requests)) {\r\n    dev->write_requests = buffer->next;\r\n    free(buffer);\r\n    }\r\n  }\r\nethq_destroy (&dev->read_queue);         /* release FIFO queue */\r\n#endif\r\n\r\n_eth_close_port (dev->eth_api, pcap, pcap_fd);\r\nsim_messagef (SCPE_OK, \"Eth: closed %s\\n\", dev->name);\r\n\r\n/* clean up the mess */\r\nfree(dev->name);\r\nfree(dev->bpf_filter);\r\neth_zero(dev);\r\n_eth_remove_from_open_list (dev);\r\nreturn SCPE_OK;\r\n}\r\n\r\nconst char *eth_version (void)\r\n{\r\nstatic char version[300] = \"\";\r\n\r\nif (version[0] != '\\0')\r\n  return version;\r\n#if defined(HAVE_SLIRP_NETWORK)\r\nif (version[0] != '\\0')\r\n  strlcat (version, \", \", sizeof (version));\r\nstrlcat (version, \"NAT\", sizeof (version));\r\n#endif\r\n#if defined(HAVE_TAP_NETWORK)\r\nif (version[0] != '\\0')\r\n  strlcat (version, \", \", sizeof (version));\r\nstrlcat (version, \"TAP\", sizeof (version));\r\n#endif\r\n#if defined(HAVE_VDE_NETWORK)\r\nif (eth_vde_network_available) {\r\n  if (version[0] != '\\0')\r\n    strlcat (version, \", \", sizeof (version));\r\n  strlcat (version, \"VDE\", sizeof (version));\r\n  }\r\n#endif\r\nif (version[0] != '\\0')\r\n  strlcat (version, \", \", sizeof (version));\r\nstrlcat (version, \"UDP\", sizeof (version));\r\n#if defined(HAVE_PCAP_NETWORK)\r\nif (version[0] != '\\0')\r\n  strlcat (version, \", \", sizeof (version));\r\nstrlcat (version, \"PCAP: \", sizeof (version));\r\nif (strstr (pcap_lib_version(), \"Npcap\") != NULL) {\r\n  char maj_min[CBUFSIZE];\r\n  const char *c = pcap_lib_version();\r\n\r\n  while (*c && !isdigit (*c))\r\n    ++c;\r\n  get_glyph (c, maj_min, ',');\r\n  if (strcmp (\"0.9990\", maj_min) > 0)\r\n    strlcat (version, \"Unsupported - \", sizeof(version));\r\n  }\r\nstrlcat (version, pcap_lib_version(), sizeof (version));\r\n#endif\r\nreturn version;\r\n}\r\n\r\nt_stat eth_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\nfprintf (st, \"%s attach help\\n\\n\", dptr->name);\r\nfprintf (st, \"   sim> SHOW ETHERNET\\n\");\r\nfprintf (st, \"   Ethernet Packet Info: NAT, TAP, VDE, UDP, PCAP: libpcap version 1.10.1 (with TPACKET_V3)\\n\");\r\nfprintf (st, \"   ETH devices:\\n\");\r\nfprintf (st, \"    eth0   en0                                  (No description available)\\n\");\r\n#if defined(HAVE_TAP_NETWORK)\r\nfprintf (st, \"    eth1   tap:tapN                             (Integrated Tun/Tap support)\\n\");\r\n#endif\r\n#if defined(HAVE_VDE_NETWORK)\r\nif (eth_vde_network_available)\r\n  fprintf (st, \"    eth2   vde:device{:switch-port-number}      (Integrated VDE support)\\n\");\r\n#endif\r\n#if defined(HAVE_SLIRP_NETWORK)\r\nfprintf (st, \"    eth3   nat:{optional-nat-parameters}        (Integrated NAT (SLiRP) support)\\n\");\r\n#endif\r\nfprintf (st, \"    eth4   udp:sourceport:remotehost:remoteport (Integrated UDP bridge support)\\n\");\r\nfprintf (st, \"   sim> ATTACH %s eth0\\n\\n\", dptr->name);\r\nfprintf (st, \"or equivalently:\\n\\n\");\r\nfprintf (st, \"   sim> ATTACH %s en0\\n\\n\", dptr->name);\r\n#if defined(HAVE_SLIRP_NETWORK)\r\nsim_slirp_attach_help (st, dptr, uptr, flag, cptr);\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic int _eth_rand_byte()\r\n{\r\nstatic int rand_initialized = 0;\r\n\r\nif (!rand_initialized)\r\n  srand((unsigned int)sim_os_msec());\r\nreturn (rand() & 0xFF);\r\n}\r\n\r\nt_stat eth_check_address_conflict_ex (ETH_DEV* dev,\r\n                                      ETH_MAC* const mac,\r\n                                      int *reflections,\r\n                                      t_bool silent)\r\n{\r\nETH_PACK send, recv;\r\nt_stat status;\r\nuint32 i;\r\nint responses = 0;\r\nuint32 offset, function;\r\nchar mac_string[32];\r\n\r\nif (reflections)\r\n    *reflections = 0;\r\neth_mac_fmt(mac, mac_string);\r\nsim_debug(dev->dbit, dev->dptr, \"Determining Address Conflict for MAC address: %s\\n\", mac_string);\r\n\r\n/* 00:00:00:00:00:00 or any address with a multi-cast address is invalid */\r\nif ((((*mac)[0] == 0) && ((*mac)[1] == 0) && ((*mac)[2] == 0) &&\r\n     ((*mac)[3] == 0) && ((*mac)[4] == 0) && ((*mac)[5] == 0)) ||\r\n     ((*mac)[0] & 1)) {\r\n  return sim_messagef (SCPE_ARG, \"%s: Invalid NIC MAC Address: %s\\n\", sim_dname(dev->dptr), mac_string);\r\n  }\r\n\r\n/* The process of checking address conflicts is used in two ways:\r\n   1) to determine the behavior of the currently running packet\r\n      delivery facility regarding whether it may receive copies\r\n      of every packet sent (and how many).\r\n   2) to verify if a MAC address which this facility is planning\r\n      to use as the source address of packets is already in use\r\n      by some other node on the local network\r\n   Case #1, doesn't require (and explicitly doesn't want) any\r\n   interaction or response from other systems on the LAN so\r\n   therefore no considerations regarding switch packet forwarding\r\n   are important.  Meanwhile, Case #2 does require responses from\r\n   other components on the LAN to provide useful functionality.\r\n   The original designers of this mechanism did this when essentially\r\n   all LANs were single collision domains (i.e. ALL nodes which might\r\n   be affected by an address conflict were physically present on a single\r\n   Ethernet cable which might have been extended by a couple of repeaters).\r\n   Since that time, essentially no networks are single collision domains.\r\n   Thick and thinwire Ethernet cables don't exist and very few networks\r\n   even have hubs.  Today, essentially all LANs are deployed using one\r\n   or more layers of network switches.  In a switched LAN environment, the\r\n   switches on the LAN \"learn\" which ports on the LAN source traffic from\r\n   which MAC addresses and then forward traffic destined for particular\r\n   MAC address to the appropriate ports.  If a particular MAC address is\r\n   already in use somewhere on the LAN, then the switches \"know\" where\r\n   it is.  The host based test using the loopback protocol is poorly\r\n   designed to detect this condition.  This test is performed by the host\r\n   first changing the device's Physical MAC address to the address which\r\n   is to be tested, and then sending a loopback packet FROM AND TO this\r\n   MAC address with a loopback reply to be sent by a system which may be\r\n   currently using the MAC address.  If no reply is received, then the\r\n   MAC address is presumed to be unused.  The sending of this packet will\r\n   result in its delivery to the right system since the switch port/MAC\r\n   address tables know where to deliver packets destined to this MAC\r\n   address, however the response it generates won't be delivered to the\r\n   system performing the test since the switches on the LAN won't know\r\n   about the local port being the right target for packets with this MAC\r\n   address.  A better test design to detect these conflicts would be for\r\n   the testing system to send a loopback packet FROM the current physical\r\n   MAC address (BEFORE changing it) TO the MAC address being tested with\r\n   the loopback response coming to the current physical MAC address of\r\n   the device.  If a response is received, then the address is in use and\r\n   the attempt to change the device's MAC address should fail.  Since we\r\n   can't change the software running in these simulators to implement this\r\n   better conflict detection approach, we can still \"do the right thing\"\r\n   in the sim_ether layer.  We're already handling the loopback test\r\n   packets specially since we always had to avoid receiving the packets\r\n   which were being sent, but needed to allow for the incoming loopback\r\n   packets to be properly dealt with.  We can extend this current special\r\n   handling to change outgoing \"loopback to self\" packets to have source\r\n   AND loopback destination addresses in the packets to be the host NIC's\r\n   physical address.  The switch network will already know the correct\r\n   MAC/port relationship for the host NIC's physical address, so loopback\r\n   response packets will be delivered as needed.\r\n\r\n   Code in _eth_write and _eth_callback provide the special handling to\r\n   perform the described loopback packet adjustments, and code in\r\n   eth_filter_hash makes sure that the loopback response packets are received.\r\n\r\n   */\r\n\r\n/* build a loopback forward request packet */\r\nmemset (&send, 0, sizeof(ETH_PACK));\r\nsend.len = ETH_MIN_PACKET;                              /* minimum packet size */\r\nfor (i=0; i<send.len; i++)\r\n  send.msg[i] = _eth_rand_byte();\r\nmemcpy(&send.msg[0], mac, sizeof(ETH_MAC));             /* target address */\r\nmemcpy(&send.msg[6], mac, sizeof(ETH_MAC));             /* source address */\r\nsend.msg[12] = 0x90;                                    /* loopback packet type */\r\nsend.msg[13] = 0;\r\nsend.msg[14] = 0;                                       /* Offset */\r\nsend.msg[15] = 0;\r\nsend.msg[16] = 2;                                       /* Forward */\r\nsend.msg[17] = 0;\r\nmemcpy(&send.msg[18], mac, sizeof(ETH_MAC));            /* Forward Destination */\r\nsend.msg[24] = 1;                                       /* Reply */\r\nsend.msg[25] = 0;\r\n\r\neth_filter(dev, 1, (ETH_MAC *)mac, 0, 0);\r\n\r\n/* send the packet */\r\nstatus = _eth_write (dev, &send, NULL);\r\nif (status != SCPE_OK) {\r\n  const char *msg;\r\n  msg = (dev->eth_api == ETH_API_PCAP) ?\r\n      \"%s: Eth: Error Transmitting packet: %s\\n\"\r\n        \"You may need to run as root, or install a libpcap version\\n\"\r\n        \"which is at least 0.9 from your OS vendor or www.tcpdump.org\\n\" :\r\n      \"%s: Eth: Error Transmitting packet: %s\\n\"\r\n        \"You may need to run as root.\\n\";\r\n  return sim_messagef (SCPE_ARG, msg, sim_dname (dev->dptr), strerror(errno));\r\n  }\r\n\r\nsim_os_ms_sleep (300);   /* time for a conflicting host to respond */\r\n\r\neth_packet_trace_detail (dev, send.msg, send.len, \"Sent-Address-Check\");\r\n\r\n/* empty the read queue and count the responses */\r\ndo {\r\n  memset (&recv, 0, sizeof(ETH_PACK));\r\n  status = eth_read (dev, &recv, NULL);\r\n  eth_packet_trace_detail (dev, recv.msg, recv.len, \"Recv-Address-Check\");\r\n  offset = 16 + (recv.msg[14] | (recv.msg[15] << 8));\r\n  function = 0;\r\n  if ((offset+2) < recv.len)\r\n    function = recv.msg[offset] | (recv.msg[offset+1] << 8);\r\n  if (((0 == memcmp(send.msg+12, recv.msg+12, 2)) &&   /* Protocol Match */\r\n       (function == 1) &&                              /* Function is Reply */\r\n       (0 == memcmp(&send.msg[offset], &recv.msg[offset], send.len-offset))) || /* Content Match */\r\n      (0 == memcmp(send.msg, recv.msg, send.len)))     /* Packet Match (Reflection) */\r\n    responses++;\r\n  } while (recv.len > 0);\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Address Conflict = %d\\n\", responses);\r\nif (responses && !silent)\r\n  return sim_messagef (SCPE_ARG, \"%s: MAC Address Conflict on LAN for address %s, change the MAC address to a unique value\\n\", sim_dname (dev->dptr), mac_string);\r\nif (reflections)\r\n  *reflections = responses;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat eth_check_address_conflict (ETH_DEV* dev,\r\n                                   ETH_MAC* const mac)\r\n{\r\nchar mac_string[32];\r\n\r\neth_mac_fmt(mac, mac_string);\r\nif (0 == memcmp (mac, dev->host_nic_phy_hw_addr, sizeof *mac))\r\n    return sim_messagef (SCPE_OK, \"Sharing the host NIC MAC address %s may cause unexpected behavior\\n\", mac_string);\r\nreturn eth_check_address_conflict_ex (dev, mac, NULL, FALSE);\r\n}\r\n\r\nt_stat eth_reflect(ETH_DEV* dev)\r\n{\r\nt_stat r;\r\n\r\n/* Test with an address no NIC should have. */\r\n/* We do this to avoid reflections from the wire, */\r\n/* in the event that a simulated NIC has a MAC address conflict. */\r\nstatic ETH_MAC mac = {0xfe,0xff,0xff,0xff,0xff,0xfe};\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Determining Reflections...\\n\");\r\n\r\nr = eth_check_address_conflict_ex (dev, &mac, &dev->reflections, TRUE);\r\nif (r != SCPE_OK)\r\n  return sim_messagef (r, \"eth: Error determining reflection count\\n\");\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"Reflections = %d\\n\", dev->reflections);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic void\r\n_eth_error(ETH_DEV* dev, const char* where)\r\n{\r\nchar msg[64];\r\nconst char *netname = \"\";\r\ntime_t now;\r\n\r\ntime(&now);\r\nsim_printf (\"%s\", asctime(localtime(&now)));\r\nswitch (dev->eth_api) {\r\n  case ETH_API_PCAP:\r\n      netname = \"pcap\";\r\n      break;\r\n  case ETH_API_TAP:\r\n      netname = \"tap\";\r\n      break;\r\n  case ETH_API_VDE:\r\n      netname = \"vde\";\r\n      break;\r\n  case ETH_API_UDP:\r\n      netname = \"udp\";\r\n      break;\r\n  case ETH_API_NAT:\r\n      netname = \"nat\";\r\n      break;\r\n  }\r\nsprintf(msg, \"%s(%s): \", where, netname);\r\nswitch (dev->eth_api) {\r\n#if defined(HAVE_PCAP_NETWORK)\r\n  case ETH_API_PCAP:\r\n      sim_printf (\"%s%s\\n\", msg, pcap_geterr ((pcap_t*)dev->handle));\r\n      break;\r\n#endif\r\n  default:\r\n      sim_err_sock (INVALID_SOCKET, msg);\r\n      break;\r\n  }\r\n#ifdef USE_READER_THREAD\r\npthread_mutex_lock (&dev->lock);\r\n++dev->error_waiting_threads;\r\nif (!dev->error_needs_reset)\r\n  dev->error_needs_reset = (((dev->transmit_packet_errors + dev->receive_packet_errors)%ETH_ERROR_REOPEN_THRESHOLD) == 0);\r\npthread_mutex_unlock (&dev->lock);\r\n#else\r\ndev->error_needs_reset = (((dev->transmit_packet_errors + dev->receive_packet_errors)%ETH_ERROR_REOPEN_THRESHOLD) == 0);\r\n#endif\r\n/* Limit errors to 1 per second (per invoking thread (reader and writer)) */\r\nsim_os_sleep (1);\r\n/*\r\n When all of the threads which can reference this ETH_DEV object are\r\n simultaneously waiting in this routine, we have the potential to close\r\n and reopen the network connection.\r\n We do this after ETH_ERROR_REOPEN_THRESHOLD total errors have occurred.\r\n In practice could be as frequently as once every ETH_ERROR_REOPEN_THRESHOLD/2\r\n seconds, but normally would be about once every 1.5*ETH_ERROR_REOPEN_THRESHOLD\r\n seconds (ONLY when the error condition exists).\r\n */\r\n#ifdef USE_READER_THREAD\r\npthread_mutex_lock (&dev->lock);\r\nif ((dev->error_waiting_threads == 2) &&\r\n    (dev->error_needs_reset)) {\r\n#else\r\nif (dev->error_needs_reset) {\r\n#endif\r\n  char errbuf[PCAP_ERRBUF_SIZE];\r\n  t_stat r;\r\n\r\n  _eth_close_port(dev->eth_api, (pcap_t *)dev->handle, dev->fd_handle);\r\n  sim_os_sleep (ETH_ERROR_REOPEN_PAUSE);\r\n\r\n  r = _eth_open_port(dev->name, &dev->eth_api, &dev->handle, &dev->fd_handle, errbuf, dev->bpf_filter, (void *)dev, dev->dptr, dev->dbit);\r\n  dev->error_needs_reset = FALSE;\r\n  if (r == SCPE_OK)\r\n    sim_printf (\"%s ReOpened: %s \\n\", msg, dev->name);\r\n  else\r\n    sim_printf (\"%s ReOpen Attempt Failed: %s - %s\\n\", msg, dev->name, errbuf);\r\n  ++dev->error_reopen_count;\r\n  }\r\n#ifdef USE_READER_THREAD\r\n--dev->error_waiting_threads;\r\npthread_mutex_unlock (&dev->lock);\r\n#endif\r\n}\r\n\r\nstatic\r\nt_stat _eth_write(ETH_DEV* dev, ETH_PACK* packet, ETH_PCALLBACK routine)\r\n{\r\nint status = 1;   /* default to failure */\r\n\r\n/* make sure device exists */\r\nif ((!dev) || (dev->eth_api == ETH_API_NONE)) return SCPE_UNATT;\r\n\r\n/* make sure packet exists */\r\nif (!packet) return SCPE_ARG;\r\n\r\n/* make sure packet is acceptable length */\r\nif ((packet->len >= ETH_MIN_PACKET) && (packet->len <= ETH_MAX_PACKET)) {\r\n  int loopback_self_frame = LOOPBACK_SELF_FRAME(packet->msg, packet->msg);\r\n  int loopback_physical_response = LOOPBACK_PHYSICAL_RESPONSE(dev, packet->msg);\r\n\r\n  eth_packet_trace (dev, packet->msg, packet->len, \"writing\");\r\n\r\n  /* record sending of loopback packet (done before actual send to avoid race conditions with receiver) */\r\n  if (loopback_self_frame || loopback_physical_response) {\r\n    /* Direct loopback responses to the host physical address since our physical address\r\n       may not have been learned yet. */\r\n    if (loopback_self_frame && dev->have_host_nic_phy_addr) {\r\n      memcpy(&packet->msg[6],  dev->host_nic_phy_hw_addr, sizeof(ETH_MAC));\r\n      memcpy(&packet->msg[18], dev->host_nic_phy_hw_addr, sizeof(ETH_MAC));\r\n      eth_packet_trace (dev, packet->msg, packet->len, \"writing-fixed\");\r\n    }\r\n#ifdef USE_READER_THREAD\r\n    pthread_mutex_lock (&dev->self_lock);\r\n#endif\r\n    dev->loopback_self_sent += dev->reflections;\r\n    dev->loopback_self_sent_total++;\r\n#ifdef USE_READER_THREAD\r\n    pthread_mutex_unlock (&dev->self_lock);\r\n#endif\r\n  }\r\n\r\n    /* dispatch write request (synchronous; no need to save write info to dev) */\r\n  switch (dev->eth_api) {\r\n#ifdef HAVE_PCAP_NETWORK\r\n    case ETH_API_PCAP:\r\n      status = pcap_sendpacket((pcap_t*)dev->handle, (u_char*)packet->msg, packet->len);\r\n      break;\r\n#endif\r\n#ifdef HAVE_TAP_NETWORK\r\n    case ETH_API_TAP:\r\n      status = (((int)packet->len == write(dev->fd_handle, (void *)packet->msg, packet->len)) ? 0 : -1);\r\n      break;\r\n#endif\r\n#ifdef HAVE_VDE_NETWORK\r\n    case ETH_API_VDE:\r\n      status = p_vde_send((VDECONN*)dev->handle, (void *)packet->msg, packet->len, 0);\r\n      if ((status == (int)packet->len) || (status == 0))\r\n        status = 0;\r\n      else\r\n        if ((status == -1) && ((errno == EAGAIN) || (errno == EWOULDBLOCK)))\r\n          status = 0;\r\n        else\r\n          status = 1;\r\n      break;\r\n#endif\r\n#ifdef HAVE_SLIRP_NETWORK\r\n    case ETH_API_NAT:\r\n      status = sim_slirp_send((SLIRP*)dev->handle, (char *)packet->msg, (size_t)packet->len, 0);\r\n      if ((status == (int)packet->len) || (status == 0))\r\n        status = 0;\r\n      else\r\n        status = 1;\r\n      break;\r\n#endif\r\n    case ETH_API_UDP:\r\n      status = (((int32)packet->len == sim_write_sock (dev->fd_handle, (char *)packet->msg, (int32)packet->len)) ? 0 : -1);\r\n      break;\r\n    }\r\n  ++dev->packets_sent;              /* basic bookkeeping */\r\n  /* On error, correct loopback bookkeeping */\r\n  if ((status != 0) && loopback_self_frame) {\r\n#ifdef USE_READER_THREAD\r\n    pthread_mutex_lock (&dev->self_lock);\r\n#endif\r\n    dev->loopback_self_sent -= dev->reflections;\r\n    dev->loopback_self_sent_total--;\r\n#ifdef USE_READER_THREAD\r\n    pthread_mutex_unlock (&dev->self_lock);\r\n#endif\r\n    }\r\n  if (status != 0) {\r\n    ++dev->transmit_packet_errors;\r\n    _eth_error (dev, \"_eth_write\");\r\n    }\r\n\r\n  } /* if packet->len */\r\n\r\n/* call optional write callback function */\r\nif (routine)\r\n  (routine)(status);\r\n\r\nreturn ((status == 0) ? SCPE_OK : SCPE_IOERR);\r\n}\r\n\r\nt_stat eth_write(ETH_DEV* dev, ETH_PACK* packet, ETH_PCALLBACK routine)\r\n{\r\n#ifdef USE_READER_THREAD\r\nETH_WRITE_REQUEST *request;\r\nint write_queue_size = 1;\r\n\r\n/* make sure device exists */\r\nif ((!dev) || (dev->eth_api == ETH_API_NONE)) return SCPE_UNATT;\r\n\r\nif (packet->len > sizeof (packet->msg)) /* packet oversized? */\r\n    return SCPE_IERR;                   /* that's no good! */\r\n\r\n/* Get a buffer */\r\npthread_mutex_lock (&dev->writer_lock);\r\nif (NULL != (request = dev->write_buffers))\r\n  dev->write_buffers = request->next;\r\npthread_mutex_unlock (&dev->writer_lock);\r\nif (NULL == request)\r\n  request = (ETH_WRITE_REQUEST *)malloc(sizeof(*request));\r\n\r\n/* Copy buffer contents */\r\nrequest->packet.len = packet->len;\r\nrequest->packet.used = packet->used;\r\nrequest->packet.status = packet->status;\r\nrequest->packet.crc_len = packet->crc_len;\r\nmemcpy(request->packet.msg, packet->msg, packet->len);\r\n\r\n/* Insert buffer at the end of the write list (to make sure that */\r\n/* packets make it to the wire in the order they were presented here) */\r\npthread_mutex_lock (&dev->writer_lock);\r\nrequest->next = NULL;\r\nif (dev->write_requests) {\r\n  ETH_WRITE_REQUEST *last_request = dev->write_requests;\r\n\r\n  ++write_queue_size;\r\n  while (last_request->next) {\r\n    last_request = last_request->next;\r\n    ++write_queue_size;\r\n    }\r\n  last_request->next = request;\r\n  }\r\nelse\r\n    dev->write_requests = request;\r\nif (write_queue_size > dev->write_queue_peak)\r\n  dev->write_queue_peak = write_queue_size;\r\npthread_mutex_unlock (&dev->writer_lock);\r\n\r\n/* Awaken writer thread to perform actual write */\r\npthread_cond_signal (&dev->writer_cond);\r\n\r\n/* Return with a status from some prior write */\r\nif (routine)\r\n  (routine)(dev->write_status);\r\nreturn dev->write_status;\r\n#else\r\nreturn _eth_write(dev, packet, routine);\r\n#endif\r\n}\r\n\r\nstatic int\r\n_eth_hash_lookup(ETH_MULTIHASH hash, const u_char* data)\r\n{\r\nint key = 0x3f & (eth_crc32(0, data, 6) >> 26);\r\n\r\nkey ^= 0x3f;\r\nreturn (hash[key>>3] & (1 << (key&0x7)));\r\n}\r\n\r\n#if 0\r\nstatic int\r\n_eth_hash_validate(ETH_MAC *MultiCastList, int count, ETH_MULTIHASH hash)\r\n{\r\nETH_MULTIHASH lhash;\r\nint i;\r\n\r\nmemset(lhash, 0, sizeof(lhash));\r\nfor (i=0; i<count; ++i) {\r\n  int key = 0x3f & (eth_crc32(0, MultiCastList[i], 6) >> 26);\r\n\r\n  key ^= 0x3F;\r\n  printf(\"MAC: %02X:%02X:%02X:%02X:%02X:%02X Key: %X, Byte: %X, Val: %X\\n\",\r\n      MultiCastList[i][0], MultiCastList[i][1], MultiCastList[i][2], MultiCastList[i][3], MultiCastList[i][4], MultiCastList[i][5],\r\n      key, key>>3, (1 << (key&0x7)));\r\n  lhash[key>>3] |= (1 << (key&0x7));\r\n  }\r\nif (memcmp(hash, lhash, sizeof(lhash))) {\r\n  printf(\"Inconsistent Computed Hash:\\n\");\r\n  printf(\"Should be: %02X %02X %02X %02X %02X %02X %02X %02X\\n\",\r\n         hash[0], hash[1], hash[2], hash[3],\r\n         hash[4], hash[5], hash[6], hash[7]);\r\n  printf(\"Was:       %02X %02X %02X %02X %02X %02X %02X %02X\\n\",\r\n         lhash[0], lhash[1], lhash[2], lhash[3],\r\n         lhash[4], lhash[5], lhash[6], lhash[7]);\r\n  }\r\nelse {\r\n  printf(\"Should be: %02X %02X %02X %02X %02X %02X %02X %02X\\n\",\r\n         hash[0], hash[1], hash[2], hash[3],\r\n         hash[4], hash[5], hash[6], hash[7]);\r\n  printf(\"Was:       %02X %02X %02X %02X %02X %02X %02X %02X\\n\",\r\n         lhash[0], lhash[1], lhash[2], lhash[3],\r\n         lhash[4], lhash[5], lhash[6], lhash[7]);\r\n  }\r\nreturn 0;\r\n}\r\n\r\nstatic void\r\n_eth_test_multicast_hash()\r\n{\r\nETH_MAC tMacs[] = {\r\n                   {0xAB, 0x00, 0x04, 0x01, 0xAC, 0x10},\r\n                   {0xAB, 0x00, 0x00, 0x04, 0x00, 0x00},\r\n                   {0x09, 0x00, 0x2B, 0x00, 0x00, 0x0F},\r\n                   {0x09, 0x00, 0x2B, 0x02, 0x01, 0x04},\r\n                   {0x09, 0x00, 0x2B, 0x02, 0x01, 0x07},\r\n                   {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\r\n                   {0x01, 0x00, 0x5E, 0x00, 0x00, 0x01}};\r\nETH_MULTIHASH thash = {0x01, 0x40, 0x00, 0x00, 0x48, 0x88, 0x40, 0x00};\r\n\r\n_eth_hash_validate(tMacs, sizeof(tMacs)/sizeof(tMacs[0]), thash);\r\n}\r\n#endif\r\n\r\n/* The IP header */\r\nstruct IPHeader {\r\n  uint8 verhlen;          /* Version & Header Length in dwords */\r\n#define IP_HLEN(IP) (((IP)->verhlen&0xF)<<2) /* Header Length in Bytes */\r\n#define IP_VERSION(IP) ((((IP)->verhlen)>>4)&0xF) /* IP Version */\r\n  uint8 tos;              /* Type of service */\r\n  uint16 total_len;       /* Length of the packet in dwords */\r\n  uint16 ident;           /* unique identifier */\r\n  uint16 flags;           /* Fragmentation Flags */\r\n#define IP_DF_FLAG (0x4000)\r\n#define IP_MF_FLAG (0x2000)\r\n#define IP_OFFSET_MASK (0x1FFF)\r\n#define IP_FRAG_DF(IP) (ntohs(((IP)->flags))&IP_DF_FLAG)\r\n#define IP_FRAG_MF(IP) (ntohs(((IP)->flags))&IP_MF_FLAG)\r\n#define IP_FRAG_OFFSET(IP) (ntohs(((IP)->flags))&IP_OFFSET_MASK)\r\n  uint8 ttl;              /* Time to live */\r\n  uint8 proto;            /* Protocol number (TCP, UDP etc) */\r\n  uint16 checksum;        /* IP checksum */\r\n  uint32 source_ip;       /* Source Address */\r\n  uint32 dest_ip;         /* Destination Address */\r\n  };\r\n\r\n/* ICMP header */\r\nstruct ICMPHeader {\r\n  uint8 type;          /* ICMP packet type */\r\n  uint8 code;          /* Type sub code */\r\n  uint16 checksum;     /* ICMP Checksum */\r\n  uint32 otherstuff[1];/* optional data */\r\n  };\r\n\r\nstruct UDPHeader {\r\n  uint16 source_port;\r\n  uint16 dest_port;\r\n  uint16 length;      /* The length of the entire UDP datagram, including both header and Data fields. */\r\n  uint16 checksum;\r\n  };\r\n\r\nstruct TCPHeader {\r\n  uint16 source_port;\r\n  uint16 dest_port;\r\n  uint32 sequence_number;\r\n  uint32 acknowledgement_number;\r\n  uint16 data_offset_and_flags;\r\n#define TCP_DATA_OFFSET(TCP) ((ntohs((TCP)->data_offset_and_flags)>>12)<<2)\r\n#define TCP_CWR_FLAG (0x80)\r\n#define TCP_ECR_FLAG (0x40)\r\n#define TCP_URG_FLAG (0x20)\r\n#define TCP_ACK_FLAG (0x10)\r\n#define TCP_PSH_FLAG (0x08)\r\n#define TCP_RST_FLAG (0x04)\r\n#define TCP_SYN_FLAG (0x02)\r\n#define TCP_FIN_FLAG (0x01)\r\n#define TCP_FLAGS_MASK (0xFFF)\r\n  uint16 window;\r\n  uint16 checksum;\r\n  uint16 urgent;\r\n  uint16 otherstuff[1];  /* The rest of the packet */\r\n  };\r\n\r\n#ifndef IPPROTO_TCP\r\n#define IPPROTO_TCP             6               /* tcp */\r\n#endif\r\n#ifndef IPPROTO_UDP\r\n#define IPPROTO_UDP             17              /* user datagram protocol */\r\n#endif\r\n#ifndef IPPROTO_ICMP\r\n#define IPPROTO_ICMP            1               /* control message protocol */\r\n#endif\r\n\r\nstatic uint16\r\nip_checksum(uint16 *buffer, int size)\r\n{\r\nunsigned long cksum = 0;\r\n\r\n/* Sum all the words together, adding the final byte if size is odd  */\r\nwhile (size > 1) {\r\n  cksum += *buffer++;\r\n  size -= sizeof(*buffer);\r\n}\r\nif (size) {\r\n  uint16 endword;\r\n  uint8 *endbytes = (uint8 *)&endword;\r\n\r\n  endbytes[0] = *((uint8 *)buffer);\r\n  endbytes[1] = 0;\r\n  cksum += endword;\r\n  }\r\n\r\n/* Do a little shuffling  */\r\ncksum = (cksum >> 16) + (cksum & 0xffff);\r\ncksum += (cksum >> 16);\r\n\r\n/* Return the bitwise complement of the resulting mishmash  */\r\nreturn (uint16)(~cksum);\r\n}\r\n\r\n/*\r\n * src_addr and dest_addr are presented in network byte order\r\n */\r\n\r\nstatic uint16\r\npseudo_checksum(uint16 len, uint16 proto, void *nsrc_addr, void *ndest_addr, uint8 *buff)\r\n{\r\nuint32 sum;\r\nuint16 *src_addr = (uint16 *)nsrc_addr;\r\nuint16 *dest_addr = (uint16 *)ndest_addr;\r\n\r\n/* Sum the data first */\r\nsum = 0xffff&(~ip_checksum((uint16 *)buff, len));\r\n\r\n/* add the pseudo header which contains the IP source and\r\n   destination addresses already in network byte order */\r\nsum += src_addr[0];\r\nsum += src_addr[1];\r\nsum += dest_addr[0];\r\nsum += dest_addr[1];\r\n/* and the protocol number and the length of the UDP packet */\r\nsum = sum + htons(proto) + htons(len);\r\n\r\n/* Do a little shuffling  */\r\nsum = (sum >> 16) + (sum & 0xffff);\r\nsum += (sum >> 16);\r\n\r\n/* Return the bitwise complement of the resulting mishmash  */\r\nreturn (uint16)(~sum);\r\n}\r\n\r\nstatic void\r\n_eth_fix_ip_jumbo_offload(ETH_DEV* dev, u_char* msg, int len)\r\n{\r\nconst unsigned short* proto = (const unsigned short*) &msg[12];\r\nstruct IPHeader *IP;\r\nstruct TCPHeader *TCP = NULL;\r\nstruct UDPHeader *UDP;\r\nstruct ICMPHeader *ICMP;\r\nuint16 orig_checksum;\r\nuint16 payload_len;\r\nuint16 mtu_payload;\r\nuint16 ip_flags;\r\nuint16 frag_offset;\r\nstruct pcap_pkthdr header;\r\nuint16 orig_tcp_flags;\r\n\r\n/* Only interested in IP frames */\r\nif (ntohs(*proto) != 0x0800) {\r\n  ++dev->jumbo_dropped; /* Non IP Frames are dropped */\r\n  return;\r\n  }\r\nIP = (struct IPHeader *)&msg[14];\r\nif (IP_VERSION(IP) != 4) {\r\n  ++dev->jumbo_dropped; /* Non IPv4 jumbo frames are dropped */\r\n  return;\r\n  }\r\nif ((IP_HLEN(IP) > len) || (ntohs(IP->total_len) > len)) {\r\n  ++dev->jumbo_dropped; /* Bogus header length frames are dropped */\r\n  return;\r\n  }\r\nif (IP_FRAG_OFFSET(IP) || IP_FRAG_MF(IP)) {\r\n  ++dev->jumbo_dropped; /* Previously fragmented, but currently jumbo sized frames are dropped */\r\n  return;\r\n  }\r\nswitch (IP->proto) {\r\n  case IPPROTO_UDP:\r\n    UDP = (struct UDPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    if (ntohs(UDP->length) > (len-IP_HLEN(IP))) {\r\n      ++dev->jumbo_dropped; /* Bogus UDP packet length (packet contained length exceeds packet size) frames are dropped */\r\n      return;\r\n      }\r\n    if (UDP->checksum == 0)\r\n      break; /* UDP Checksums are disabled */\r\n    orig_checksum = UDP->checksum;\r\n    UDP->checksum = 0;\r\n    UDP->checksum = pseudo_checksum(ntohs(UDP->length), IPPROTO_UDP, &IP->source_ip, &IP->dest_ip, (uint8 *)UDP);\r\n    if (orig_checksum != UDP->checksum)\r\n      eth_packet_trace (dev, msg, len, \"reading jumbo UDP header Checksum Fixed\");\r\n    break;\r\n  case IPPROTO_ICMP:\r\n    ICMP = (struct ICMPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    orig_checksum = ICMP->checksum;\r\n    ICMP->checksum = 0;\r\n    ICMP->checksum = ip_checksum((uint16 *)ICMP, ntohs(IP->total_len)-IP_HLEN(IP));\r\n    if (orig_checksum != ICMP->checksum)\r\n      eth_packet_trace (dev, msg, len, \"reading jumbo ICMP header Checksum Fixed\");\r\n    break;\r\n  case IPPROTO_TCP:\r\n    TCP = (struct TCPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    if ((TCP_DATA_OFFSET(TCP) > (len-IP_HLEN(IP))) || (TCP_DATA_OFFSET(TCP) < 20)) {\r\n      ++dev->jumbo_dropped; /* Bogus TCP packet header length (packet contained length exceeds packet size) frames are dropped */\r\n      return;\r\n      }\r\n    /* We don't do anything with the TCP checksum since we're going to resegment the TCP data below */\r\n    break;\r\n  default:\r\n    ++dev->jumbo_dropped; /* We only handle UDP, ICMP and TCP jumbo frames others are dropped */\r\n    return;\r\n  }\r\n/* Reasonable Checksums are now in the jumbo packet, but we've got to actually */\r\n/* deliver ONLY standard sized ethernet frames.  Our job here is to now act as */\r\n/* a router might have to and fragment these IPv4 frames as they are delivered */\r\n/* into the virtual NIC. We do this by walking down the packet and dispatching */\r\n/* a chunk at a time recomputing an appropriate header for each chunk. For */\r\n/* datagram oriented protocols (UDP and ICMP) this is done by simple packet */\r\n/* fragmentation.  For TCP this is done by breaking large packets into separate */\r\n/* TCP packets. */\r\nmemset(&header, 0, sizeof(header));\r\nswitch (IP->proto) {\r\n  case IPPROTO_UDP:\r\n  case IPPROTO_ICMP:\r\n    ++dev->jumbo_fragmented;\r\n    /* When we're performing LSO (Large Send Offload), we're given a\r\n       'template' header which may not include a value being populated\r\n       in the IP header length (which is only 16 bits).\r\n       We process as payload everything which isn't known header data. */\r\n    payload_len = (uint16)(len - (14 + IP_HLEN(IP)));\r\n    mtu_payload = ETH_MIN_JUMBO_FRAME - (14 + IP_HLEN(IP));\r\n    frag_offset = 0;\r\n    while (payload_len > 0) {\r\n      ip_flags = frag_offset;\r\n      if (payload_len > mtu_payload) {\r\n        ip_flags |= IP_MF_FLAG;\r\n        IP->total_len = htons(((mtu_payload>>3)<<3) + IP_HLEN(IP));\r\n        }\r\n      else {\r\n        IP->total_len = htons(payload_len + IP_HLEN(IP));\r\n        }\r\n      IP->flags = htons(ip_flags);\r\n      IP->checksum = 0;\r\n      IP->checksum = ip_checksum((uint16 *)IP, IP_HLEN(IP));\r\n      header.caplen = header.len = 14 + ntohs(IP->total_len);\r\n      eth_packet_trace (dev, ((u_char *)IP)-14, header.len, \"reading Datagram fragment\");\r\n#if ETH_MIN_JUMBO_FRAME < ETH_MAX_PACKET\r\n      if (1) {\r\n        /* Debugging is easier if we read packets directly with pcap\r\n           (i.e. we can use Wireshark to verify packet contents)\r\n           we don't want to do this all the time for 2 reasons:\r\n             1) sending through pcap involves kernel transitions and\r\n             2) if the current system reflects sent packets, the\r\n                receiving side will receive and process 2 copies of\r\n                any packets sent this way. */\r\n        ETH_PACK pkt;\r\n\r\n        memset(&pkt, 0, sizeof(pkt));\r\n        memcpy(pkt.msg, ((u_char *)IP)-14, header.len);\r\n        pkt.len = header.len;\r\n        _eth_write(dev, &pkt, NULL);\r\n        }\r\n#else\r\n      _eth_callback((u_char *)dev, &header, ((u_char *)IP)-14);\r\n#endif\r\n      payload_len -= (ntohs(IP->total_len) - IP_HLEN(IP));\r\n      frag_offset += (ntohs(IP->total_len) - IP_HLEN(IP))>>3;\r\n      if (payload_len > 0) {\r\n        /* Move the MAC and IP headers down to just prior to the next payload segment */\r\n        memcpy(((u_char *)IP) + ntohs(IP->total_len) - (14 + IP_HLEN(IP)), ((u_char *)IP) - 14, 14 + IP_HLEN(IP));\r\n        IP = (struct IPHeader *)(((u_char *)IP) + ntohs(IP->total_len) - IP_HLEN(IP));\r\n        }\r\n      }\r\n    break;\r\n  case IPPROTO_TCP:\r\n    ++dev->jumbo_fragmented;\r\n    eth_packet_trace_ex (dev, ((u_char *)IP)-14, len, \"Fragmenting Jumbo TCP segment\", 1, dev->dbit);\r\n    TCP = (struct TCPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    orig_tcp_flags = ntohs(TCP->data_offset_and_flags);\r\n    /* When we're performing LSO (Large Send Offload), we're given a\r\n       'template' header which may not include a value being populated\r\n       in the IP header length (which is only 16 bits).\r\n       We process as payload everything which isn't known header data. */\r\n    payload_len = (uint16)(len - (14 + IP_HLEN(IP) + TCP_DATA_OFFSET(TCP)));\r\n    mtu_payload = ETH_MIN_JUMBO_FRAME - (14 + IP_HLEN(IP) + TCP_DATA_OFFSET(TCP));\r\n    while (payload_len > 0) {\r\n      if (payload_len > mtu_payload) {\r\n        TCP->data_offset_and_flags = htons(orig_tcp_flags&~(TCP_PSH_FLAG|TCP_FIN_FLAG|TCP_RST_FLAG));\r\n        IP->total_len = htons(mtu_payload + IP_HLEN(IP) + TCP_DATA_OFFSET(TCP));\r\n        }\r\n      else {\r\n        TCP->data_offset_and_flags = htons(orig_tcp_flags);\r\n        IP->total_len = htons(payload_len + IP_HLEN(IP) + TCP_DATA_OFFSET(TCP));\r\n        }\r\n      IP->checksum = 0;\r\n      IP->checksum = ip_checksum((uint16 *)IP, IP_HLEN(IP));\r\n      TCP->checksum = 0;\r\n      TCP->checksum = pseudo_checksum(ntohs(IP->total_len)-IP_HLEN(IP), IPPROTO_TCP, &IP->source_ip, &IP->dest_ip, (uint8 *)TCP);\r\n      header.caplen = header.len = 14 + ntohs(IP->total_len);\r\n      eth_packet_trace_ex (dev, ((u_char *)IP)-14, header.len, \"reading TCP segment\", 1, dev->dbit);\r\n#if ETH_MIN_JUMBO_FRAME < ETH_MAX_PACKET\r\n      if (1) {\r\n        /* Debugging is easier if we read packets directly with pcap\r\n           (i.e. we can use Wireshark to verify packet contents)\r\n           we don't want to do this all the time for 2 reasons:\r\n             1) sending through pcap involves kernel transitions and\r\n             2) if the current system reflects sent packets, the\r\n                receiving side will receive and process 2 copies of\r\n                any packets sent this way. */\r\n        ETH_PACK pkt;\r\n\r\n        memset(&pkt, 0, sizeof(pkt));\r\n        memcpy(pkt.msg, ((u_char *)IP)-14, header.len);\r\n        pkt.len = header.len;\r\n        _eth_write(dev, &pkt, NULL);\r\n        }\r\n#else\r\n      _eth_callback((u_char *)dev, &header, ((u_char *)IP)-14);\r\n#endif\r\n      payload_len -= (ntohs(IP->total_len) - (IP_HLEN(IP) + TCP_DATA_OFFSET(TCP)));\r\n      if (payload_len > 0) {\r\n        /* Move the MAC, IP and TCP headers down to just prior to the next payload segment */\r\n        memcpy(((u_char *)IP) + ntohs(IP->total_len) - (14 + IP_HLEN(IP) + TCP_DATA_OFFSET(TCP)), ((u_char *)IP) - 14, 14 + IP_HLEN(IP) + TCP_DATA_OFFSET(TCP));\r\n        IP = (struct IPHeader *)(((u_char *)IP) + ntohs(IP->total_len) - (IP_HLEN(IP) + TCP_DATA_OFFSET(TCP)));\r\n        TCP = (struct TCPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n        TCP->sequence_number = htonl(mtu_payload + ntohl(TCP->sequence_number));\r\n        }\r\n      }\r\n    break;\r\n  }\r\n}\r\n\r\nstatic void\r\n_eth_fix_ip_xsum_offload(ETH_DEV* dev, const u_char* msg, int len)\r\n{\r\nconst unsigned short* proto = (const unsigned short*) &msg[12];\r\nstruct IPHeader *IP;\r\nstruct TCPHeader *TCP;\r\nstruct UDPHeader *UDP;\r\nstruct ICMPHeader *ICMP;\r\nuint16 orig_checksum;\r\n\r\n/* Only need to process locally originated packets */\r\nif ((!dev->have_host_nic_phy_addr) || (memcmp(msg+6, dev->host_nic_phy_hw_addr, 6)))\r\n  return;\r\n/* Only interested in IP frames */\r\nif (ntohs(*proto) != 0x0800)\r\n  return;\r\nIP = (struct IPHeader *)&msg[14];\r\nif (IP_VERSION(IP) != 4)\r\n  return; /* Only interested in IPv4 frames */\r\nif ((IP_HLEN(IP) > len) || (ntohs(IP->total_len) > len))\r\n  return; /* Bogus header length */\r\norig_checksum = IP->checksum;\r\nIP->checksum = 0;\r\nIP->checksum = ip_checksum((uint16 *)IP, IP_HLEN(IP));\r\nif (orig_checksum != IP->checksum)\r\n  eth_packet_trace (dev, msg, len, \"reading IP header Checksum Fixed\");\r\nif (IP_FRAG_OFFSET(IP) || IP_FRAG_MF(IP))\r\n  return; /* Insufficient data to compute payload checksum */\r\nswitch (IP->proto) {\r\n  case IPPROTO_UDP:\r\n    UDP = (struct UDPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    if (ntohs(UDP->length) > (len-IP_HLEN(IP)))\r\n      return; /* packet contained length exceeds packet size */\r\n    if (UDP->checksum == 0)\r\n      return; /* UDP Checksums are disabled */\r\n    orig_checksum = UDP->checksum;\r\n    UDP->checksum = 0;\r\n    UDP->checksum = pseudo_checksum(ntohs(UDP->length), IPPROTO_UDP, &IP->source_ip, &IP->dest_ip, (uint8 *)UDP);\r\n    if (orig_checksum != UDP->checksum)\r\n      eth_packet_trace (dev, msg, len, \"reading UDP header Checksum Fixed\");\r\n    break;\r\n  case IPPROTO_TCP:\r\n    TCP = (struct TCPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    orig_checksum = TCP->checksum;\r\n    TCP->checksum = 0;\r\n    TCP->checksum = pseudo_checksum(ntohs(IP->total_len)-IP_HLEN(IP), IPPROTO_TCP, &IP->source_ip, &IP->dest_ip, (uint8 *)TCP);\r\n    if (orig_checksum != TCP->checksum)\r\n      eth_packet_trace (dev, msg, len, \"reading TCP header Checksum Fixed\");\r\n    break;\r\n  case IPPROTO_ICMP:\r\n    ICMP = (struct ICMPHeader *)(((char *)IP)+IP_HLEN(IP));\r\n    orig_checksum = ICMP->checksum;\r\n    ICMP->checksum = 0;\r\n    ICMP->checksum = ip_checksum((uint16 *)ICMP, ntohs(IP->total_len)-IP_HLEN(IP));\r\n    if (orig_checksum != ICMP->checksum)\r\n      eth_packet_trace (dev, msg, len, \"reading ICMP header Checksum Fixed\");\r\n    break;\r\n  }\r\n}\r\n\r\nstatic int\r\n_eth_process_loopback (ETH_DEV* dev, const u_char* data, uint32 len)\r\n{\r\nint protocol = data[12] | (data[13] << 8);\r\nETH_PACK  response;\r\nuint32 offset, function;\r\n\r\nif (protocol != 0x0090)     /* !ethernet loopback */\r\n  return 0;\r\n\r\nif (LOOPBACK_REFLECTION_TEST_PACKET(dev, data))\r\n  return 0;                 /* Ignore reflection check packet */\r\n\r\noffset   = 16 + (data[14] | (data[15] << 8));\r\nif (offset >= len)\r\n  return 0;\r\nfunction = data[offset] | (data[offset+1] << 8);\r\n\r\nif (function != 2) /*forward*/\r\n  return 0;\r\n\r\n/* The only packets we should be responding to are ones which\r\n   we received due to them being directed to our physical MAC address,\r\n   OR the Broadcast address OR to a Multicast address we're listening to\r\n   (we may receive others if we're in promiscuous mode, but shouldn't\r\n   respond to them) */\r\nif ((0 == (data[0]&1)) &&           /* Multicast or Broadcast */\r\n    (0 != memcmp(dev->filter_address[0], data, sizeof(ETH_MAC))))\r\n  return 0;\r\n\r\n/* Attempts to forward to multicast or broadcast addresses are explicitly\r\n   ignored by consuming the packet and doing nothing else */\r\nif (data[offset+2]&1)\r\n  return 1;\r\n\r\neth_packet_trace (dev, data, len, \"rcvd\");\r\n\r\nsim_debug(dev->dbit, dev->dptr, \"_eth_process_loopback()\\n\");\r\n\r\n/* create forward response packet */\r\nmemset(&response, 0, sizeof(response));\r\nresponse.len = len;\r\nmemcpy(response.msg, data, len);\r\nmemcpy(&response.msg[0], &response.msg[offset+2], sizeof(ETH_MAC));\r\nmemcpy(&response.msg[6], dev->filter_address[0], sizeof(ETH_MAC));\r\noffset += 8 - 16; /* Account for the Ethernet Header and Offset value in this number  */\r\nresponse.msg[14] = offset & 0xFF;\r\nresponse.msg[15] = (offset >> 8) & 0xFF;\r\n\r\n/* send response packet */\r\neth_write(dev, &response, NULL);\r\n\r\neth_packet_trace(dev, response.msg, response.len, \"loopbackforward\");\r\n\r\n++dev->loopback_packets_processed;\r\n\r\nreturn 1;\r\n}\r\n\r\nstatic void\r\n_eth_callback(u_char* info, const struct pcap_pkthdr* header, const u_char* data)\r\n{\r\nETH_DEV*  dev = (ETH_DEV*) info;\r\nint to_me;\r\nint from_me = 0;\r\nint i;\r\nint bpf_used;\r\n\r\nif (LOOPBACK_PHYSICAL_RESPONSE(dev, data)) {\r\n  u_char *datacopy = (u_char *)malloc(header->len);\r\n\r\n  /* Since we changed the outgoing loopback packet to have the physical MAC address of the\r\n     host's interface instead of the programmatically set physical address of this pseudo\r\n     device, we restore parts of the modified packet back as needed */\r\n  memcpy(datacopy, data, header->len);\r\n  memcpy(datacopy, dev->physical_addr, sizeof(ETH_MAC));\r\n  memcpy(datacopy+18, dev->physical_addr, sizeof(ETH_MAC));\r\n  _eth_callback(info, header, datacopy);\r\n  free(datacopy);\r\n  return;\r\n}\r\nswitch (dev->eth_api) {\r\n  case ETH_API_PCAP:\r\n#ifdef USE_BPF\r\n    bpf_used = 1;\r\n    to_me = 1;\r\n    /* AUTODIN II hash mode? */\r\n    if ((dev->hash_filter) && (data[0] & 0x01) && (!dev->promiscuous) && (!dev->all_multicast))\r\n      to_me = _eth_hash_lookup(dev->hash, data);\r\n    break;\r\n#endif /* USE_BPF */\r\n  case ETH_API_TAP:\r\n  case ETH_API_VDE:\r\n  case ETH_API_UDP:\r\n  case ETH_API_NAT:\r\n    bpf_used = 0;\r\n    to_me = 0;\r\n    eth_packet_trace (dev, data, header->len, \"received\");\r\n\r\n    for (i = 0; i < dev->addr_count; i++) {\r\n      if (memcmp(data, dev->filter_address[i], 6) == 0) to_me = 1;\r\n      if (memcmp(&data[6], dev->filter_address[i], 6) == 0) from_me = 1;\r\n    }\r\n\r\n    /* all multicast mode? */\r\n    if (dev->all_multicast && (data[0] & 0x01)) to_me = 1;\r\n\r\n    /* promiscuous mode? */\r\n    if (dev->promiscuous) to_me = 1;\r\n\r\n    /* AUTODIN II hash mode? */\r\n    if ((dev->hash_filter) && (!to_me) && (data[0] & 0x01))\r\n      to_me = _eth_hash_lookup(dev->hash, data);\r\n    break;\r\n  default:\r\n    bpf_used = to_me = 0;                           /* Should NEVER happen */\r\n    SIM_SCP_ABORT (\"_eth_callback()\");\r\n    break;\r\n  }\r\n\r\n/* detect reception of loopback packet to our physical address */\r\nif ((LOOPBACK_SELF_FRAME(dev->physical_addr, data)) ||\r\n    (LOOPBACK_PHYSICAL_REFLECTION(dev, data))) {\r\n#ifdef USE_READER_THREAD\r\n  pthread_mutex_lock (&dev->self_lock);\r\n#endif\r\n  dev->loopback_self_rcvd_total++;\r\n  /* lower reflection count - if already zero, pass it on */\r\n  if (dev->loopback_self_sent > 0) {\r\n    eth_packet_trace (dev, data, header->len, \"ignored\");\r\n    dev->loopback_self_sent--;\r\n    to_me = 0;\r\n    }\r\n  else\r\n    if (!bpf_used)\r\n      from_me = 0;\r\n#ifdef USE_READER_THREAD\r\n  pthread_mutex_unlock (&dev->self_lock);\r\n#endif\r\n  }\r\n\r\nif (bpf_used ? to_me : (to_me && !from_me)) {\r\n  if (header->len > ETH_MIN_JUMBO_FRAME) {\r\n    if (header->len <= header->caplen) {/* Whole Frame captured? */\r\n      u_char *datacopy = (u_char *)malloc(header->len);\r\n      memcpy(datacopy, data, header->len);\r\n      _eth_fix_ip_jumbo_offload(dev, datacopy, header->len);\r\n      free(datacopy);\r\n      }\r\n    else\r\n      ++dev->jumbo_truncated;\r\n    return;\r\n    }\r\n  if (_eth_process_loopback(dev, data, header->len))\r\n    return;\r\n#if defined (USE_READER_THREAD)\r\n  if (1) {\r\n    int crc_len = 0;\r\n    uint8 crc_data[4];\r\n    uint32 len = header->len;\r\n    u_char *moved_data = NULL;\r\n\r\n    if (header->len < ETH_MIN_PACKET) {   /* Pad runt packets before CRC append */\r\n      moved_data = (u_char *)malloc(ETH_MIN_PACKET);\r\n      memcpy(moved_data, data, len);\r\n      memset(moved_data + len, 0, ETH_MIN_PACKET-len);\r\n      len = ETH_MIN_PACKET;\r\n      data = moved_data;\r\n      }\r\n\r\n    /* If necessary, fix IP header checksums for packets originated locally */\r\n    /* but were presumed to be traversing a NIC which was going to handle that task */\r\n    /* This must be done before any needed CRC calculation */\r\n    _eth_fix_ip_xsum_offload(dev, (const u_char*)data, len);\r\n\r\n    if (dev->need_crc)\r\n      crc_len = eth_get_packet_crc32_data(data, len, crc_data);\r\n\r\n    eth_packet_trace (dev, data, len, \"rcvqd\");\r\n\r\n    pthread_mutex_lock (&dev->lock);\r\n    ethq_insert_data(&dev->read_queue, ETH_ITM_NORMAL, data, 0, len, crc_len, crc_data, 0);\r\n    ++dev->packets_received;\r\n    pthread_mutex_unlock (&dev->lock);\r\n    free(moved_data);\r\n    }\r\n#else /* !USE_READER_THREAD */\r\n  /* set data in passed read packet */\r\n  dev->read_packet->len = header->len;\r\n  memcpy(dev->read_packet->msg, data, header->len);\r\n  /* Handle runt case and pad with zeros.  */\r\n  /* The real NIC won't hand us runts from the wire, BUT we may be getting */\r\n  /* some packets looped back before they actually traverse the wire */\r\n  /* (by an internal bridge device for instance) */\r\n  if (header->len < ETH_MIN_PACKET) {\r\n    memset(&dev->read_packet->msg[header->len], 0, ETH_MIN_PACKET-header->len);\r\n    dev->read_packet->len = ETH_MIN_PACKET;\r\n    }\r\n  /* If necessary, fix IP header checksums for packets originated by the local host */\r\n  /* but were presumed to be traversing a NIC which was going to handle that task */\r\n  /* This must be done before any needed CRC calculation */\r\n  _eth_fix_ip_xsum_offload(dev, dev->read_packet->msg, dev->read_packet->len);\r\n  if (dev->need_crc)\r\n    dev->read_packet->crc_len = eth_add_packet_crc32(dev->read_packet->msg, dev->read_packet->len);\r\n  else\r\n    dev->read_packet->crc_len = 0;\r\n\r\n  eth_packet_trace (dev, dev->read_packet->msg, dev->read_packet->len, \"reading\");\r\n\r\n  ++dev->packets_received;\r\n\r\n  /* call optional read callback function */\r\n  if (dev->read_callback)\r\n    (dev->read_callback)(0);\r\n#endif\r\n  }\r\n}\r\n\r\nint eth_read(ETH_DEV* dev, ETH_PACK* packet, ETH_PCALLBACK routine)\r\n{\r\nint status;\r\n\r\n/* make sure device exists */\r\n\r\nif ((!dev) || (dev->eth_api == ETH_API_NONE)) return 0;\r\n\r\n/* make sure packet exists */\r\nif (!packet) return 0;\r\n\r\npacket->len = 0;\r\n#if !defined (USE_READER_THREAD)\r\n/* set read packet */\r\ndev->read_packet = packet;\r\n\r\n/* set optional callback routine */\r\ndev->read_callback = routine;\r\n\r\n/* dispatch read request to either receive a filtered packet or timeout */\r\ndo {\r\n  switch (dev->eth_api) {\r\n#ifdef HAVE_PCAP_NETWORK\r\n    case ETH_API_PCAP:\r\n      status = pcap_dispatch((pcap_t*)dev->handle, 1, &_eth_callback, (u_char*)dev);\r\n      break;\r\n#endif\r\n#ifdef HAVE_TAP_NETWORK\r\n    case ETH_API_TAP:\r\n      if (1) {\r\n        struct pcap_pkthdr header;\r\n        int len;\r\n        u_char buf[ETH_MAX_JUMBO_FRAME];\r\n\r\n        memset(&header, 0, sizeof(header));\r\n        len = read(dev->fd_handle, buf, sizeof(buf));\r\n        if (len > 0) {\r\n          status = 1;\r\n          header.caplen = header.len = len;\r\n          _eth_callback((u_char *)dev, &header, buf);\r\n          }\r\n        else {\r\n          if (len < 0)\r\n            status = -1;\r\n          else\r\n            status = 0;\r\n          }\r\n        }\r\n      break;\r\n#endif /* HAVE_TAP_NETWORK */\r\n#ifdef HAVE_VDE_NETWORK\r\n    case ETH_API_VDE:\r\n      if (1) {\r\n        struct pcap_pkthdr header;\r\n        int len;\r\n        u_char buf[ETH_MAX_JUMBO_FRAME];\r\n\r\n        memset(&header, 0, sizeof(header));\r\n        len = p_vde_recv((VDECONN*)dev->handle, buf, sizeof(buf), 0);\r\n        if (len > 0) {\r\n          status = 1;\r\n          header.caplen = header.len = len;\r\n          _eth_callback((u_char *)dev, &header, buf);\r\n          }\r\n        else {\r\n          if (len < 0)\r\n            status = -1;\r\n          else\r\n            status = 0;\r\n          }\r\n        }\r\n      break;\r\n#endif /* HAVE_VDE_NETWORK */\r\n    case ETH_API_UDP:\r\n      if (1) {\r\n        struct pcap_pkthdr header;\r\n        int len;\r\n        u_char buf[ETH_MAX_JUMBO_FRAME];\r\n\r\n        memset(&header, 0, sizeof(header));\r\n        len = (int)sim_read_sock (dev->fd_handle, (char *)buf, (int32)sizeof(buf));\r\n        if (len > 0) {\r\n          status = 1;\r\n          header.caplen = header.len = len;\r\n          _eth_callback((u_char *)dev, &header, buf);\r\n          }\r\n        else {\r\n          if (len < 0)\r\n            status = -1;\r\n          else\r\n            status = 0;\r\n          }\r\n        }\r\n      break;\r\n    }\r\n  } while ((status > 0) && (0 == packet->len));\r\nif (status < 0) {\r\n  ++dev->receive_packet_errors;\r\n  _eth_error (dev, \"eth_reader\");\r\n  }\r\n\r\n#else /* USE_READER_THREAD */\r\n\r\n  status = 0;\r\n  pthread_mutex_lock (&dev->lock);\r\n  if (dev->read_queue.count > 0) {\r\n    ETH_ITEM* item = &dev->read_queue.item[dev->read_queue.head];\r\n    packet->len = item->packet.len;\r\n    packet->crc_len = item->packet.crc_len;\r\n    memcpy(packet->msg, item->packet.msg, ((packet->len > packet->crc_len) ? packet->len : packet->crc_len));\r\n    status = 1;\r\n    ethq_remove(&dev->read_queue);\r\n  }\r\n  pthread_mutex_unlock (&dev->lock);\r\n  if ((status) && (routine))\r\n    routine(0);\r\n#endif\r\n\r\nreturn status;\r\n}\r\n\r\nt_stat eth_bpf_filter (ETH_DEV* dev, int addr_count, ETH_MAC* const filter_address,\r\n                       ETH_BOOL all_multicast, ETH_BOOL promiscuous,\r\n                       int reflections,\r\n                       ETH_MAC* physical_addr,\r\n                       ETH_MAC* host_nic_phy_hw_addr,\r\n                       ETH_MULTIHASH* const hash,\r\n                       char *buf)\r\n{\r\nint i;\r\nchar mac[20];\r\nchar *buf2;\r\n\r\n/* setup BPF filters and other fields to minimize packet delivery */\r\nstrcpy(buf, \"\");\r\n\r\n/* construct destination filters - since the real ethernet interface was set\r\n   into promiscuous mode by eth_open(), we need to filter out the packets that\r\n   our simulated interface doesn't want. */\r\nif (!promiscuous) {\r\n  for (i = 0; i < addr_count; i++) {\r\n    eth_mac_fmt(&filter_address[i], mac);\r\n    if (!strstr(buf, mac))    /* eliminate duplicates */\r\n      sprintf(&buf[strlen(buf)], \"%s(ether dst %s)\", (*buf) ? \" or \" : \"((\", mac);\r\n    }\r\n  if (all_multicast || hash)\r\n    sprintf(&buf[strlen(buf)], \"%s(ether multicast)\", (*buf) ? \" or \" : \"((\");\r\n  if (strlen(buf) > 0)\r\n    sprintf(&buf[strlen(buf)], \")\");\r\n  }\r\n\r\n/* construct source filters - this prevents packets from being reflected back\r\n   by systems where WinPcap and libpcap cause packet reflections. Note that\r\n   some systems do not reflect packets at all. This *assumes* that the\r\n   simulated NIC will not send out packets with multicast source fields. */\r\nif ((addr_count > 0) && (reflections > 0)) {\r\n  if (strlen(buf) > 0)\r\n    sprintf(&buf[strlen(buf)], \" and \");\r\n  else\r\n    if (promiscuous)\r\n      sprintf(&buf[strlen(buf)], \"(\");\r\n  sprintf (&buf[strlen(buf)], \"not (\");\r\n  buf2 = &buf[strlen(buf)];\r\n  for (i = 0; i < addr_count; i++) {\r\n    if (filter_address[i][0] & 0x01) continue; /* skip multicast addresses */\r\n    eth_mac_fmt(&filter_address[i], mac);\r\n    if (!strstr(buf2, mac))   /* only process each address once */\r\n      sprintf(&buf2[strlen(buf2)], \"%s(ether src %s)\", (*buf2) ? \" or \" : \"\", mac);\r\n    }\r\n  sprintf (&buf[strlen(buf)], \")\");\r\n  if (1 == strlen(buf2)) {          /* all addresses were multicast? */\r\n    buf[strlen(buf)-6] = '\\0';      /* Remove \"not ()\" */\r\n    if (strlen(buf) > 0)\r\n        buf[strlen(buf)-5] = '\\0';  /* remove \" and \" */\r\n    }\r\n  }\r\nif (strlen(buf) > 0)\r\n  sprintf(&buf[strlen(buf)], \")\");\r\n/* When changing the Physical Address on a LAN interface, VMS sends out a\r\n   loopback packet with the source and destination addresses set to the same\r\n   value as the Physical Address which is being setup.  This packet is\r\n   designed to find and help diagnose MAC address conflicts (which also\r\n   include DECnet address conflicts). Normally, this packet would not be\r\n   seen by the sender, only by the other machine that has the same Physical\r\n   Address (or possibly DECnet address). If the ethernet subsystem is\r\n   reflecting packets, the network startup will fail to start if it sees the\r\n   reflected packet, since it thinks another system is using this Physical\r\n   Address (or DECnet address). We have to let these packets through, so\r\n   that if another machine has the same Physical Address (or DECnet address)\r\n   that we can detect it. Both eth_write() and _eth_callback() help by\r\n   checking the reflection count - eth_write() adds the reflection count to\r\n   dev->loopback_self_sent, and _eth_callback() check the value - if the\r\n   dev->loopback_self_sent count is zero, then the packet has come from\r\n   another machine with the same address, and needs to be passed on to the\r\n   simulated machine. */\r\n/* check for physical address in filters */\r\nif ((!promiscuous) && (addr_count) && (reflections > 0)) {\r\n  eth_mac_fmt(&physical_addr[0], mac);\r\n  if (strcmp(mac, \"00:00:00:00:00:00\") != 0) {\r\n    /* let packets through where dst and src are the same as our physical address */\r\n    sprintf (&buf[strlen(buf)], \" or ((ether dst %s) and (ether src %s))\", mac, mac);\r\n    if (host_nic_phy_hw_addr) {\r\n      eth_mac_fmt(&host_nic_phy_hw_addr[0], mac);\r\n      sprintf(&buf[strlen(buf)], \" or ((ether dst %s) and (ether proto 0x9000))\", mac);\r\n      }\r\n    }\r\n  }\r\nif ((0 == strlen(buf)) && (!promiscuous)) /* Empty filter means match nothing */\r\n  strcpy(buf, \"ether host fe:ff:ff:ff:ff:ff\"); /* this should be a good match nothing filter */\r\nsim_debug(dev->dbit, dev->dptr, \"BPF string is: |%s|\\n\", buf);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat eth_filter(ETH_DEV* dev, int addr_count, ETH_MAC* const addresses,\r\n                  ETH_BOOL all_multicast, ETH_BOOL promiscuous)\r\n{\r\nreturn eth_filter_hash_ex(dev, addr_count, addresses,\r\n                          all_multicast, promiscuous, FALSE,\r\n                          NULL);\r\n}\r\n\r\nt_stat eth_filter_hash(ETH_DEV* dev, int addr_count, ETH_MAC* const addresses,\r\n                       ETH_BOOL all_multicast, ETH_BOOL promiscuous,\r\n                       ETH_MULTIHASH* const hash)\r\n{\r\nreturn eth_filter_hash_ex(dev, addr_count, addresses,\r\n                          all_multicast, promiscuous, TRUE,\r\n                          hash);\r\n}\r\n\r\nt_stat eth_filter_hash_ex(ETH_DEV* dev, int addr_count, ETH_MAC* const addresses,\r\n                          ETH_BOOL all_multicast, ETH_BOOL promiscuous,\r\n                          ETH_BOOL match_broadcast, ETH_MULTIHASH* const hash)\r\n{\r\nint i;\r\nchar buf[116+66*ETH_FILTER_MAX];\r\nchar mac[20];\r\nt_stat status;\r\n#ifdef USE_BPF\r\nstruct bpf_program bpf;\r\n#endif\r\n\r\n/* make sure device exists */\r\nif (!dev) return SCPE_UNATT;\r\n\r\n/* filter count OK? */\r\nif ((addr_count < 0) || ((addr_count + (match_broadcast ? 1 : 0)) > ETH_FILTER_MAX))\r\n  return SCPE_ARG;\r\nelse\r\n  if (!addresses && (addr_count != 0))\r\n     return SCPE_ARG;\r\n\r\n/* test reflections.  This is done early in this routine since eth_reflect */\r\n/* calls eth_filter recursively and thus changes the state of the device. */\r\nif (dev->reflections == -1)\r\n  status = eth_reflect(dev);\r\n\r\n/* set new filter addresses */\r\nfor (i = 0; i < addr_count; i++)\r\n  memcpy(dev->filter_address[i], addresses[i], sizeof(ETH_MAC));\r\ndev->addr_count = addr_count;\r\nif (match_broadcast) {\r\n  memset(&dev->filter_address[addr_count], 0xFF, sizeof(ETH_MAC));\r\n  ++addr_count;\r\n  }\r\ndev->addr_count = addr_count;\r\n\r\n/* store other flags */\r\ndev->all_multicast = all_multicast;\r\ndev->promiscuous   = promiscuous;\r\n\r\n/* store multicast hash data */\r\ndev->hash_filter = (hash != NULL);\r\nif (hash) {\r\n  memcpy(dev->hash, hash, sizeof(*hash));\r\n  sim_debug(dev->dbit, dev->dptr, \"Multicast Hash: %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\\n\",\r\n                                  dev->hash[0], dev->hash[1], dev->hash[2], dev->hash[3],\r\n                                  dev->hash[4], dev->hash[5], dev->hash[6], dev->hash[7]);\r\n  }\r\n\r\n/* print out filter information if debugging */\r\nif (dev->dptr->dctrl & dev->dbit) {\r\n  sim_debug(dev->dbit, dev->dptr, \"Filter Set\\n\");\r\n  for (i = 0; i < addr_count; i++) {\r\n    char mac[20];\r\n    eth_mac_fmt(&dev->filter_address[i], mac);\r\n    sim_debug(dev->dbit, dev->dptr, \"  Addr[%d]: %s\\n\", i, mac);\r\n    }\r\n  if (dev->all_multicast) {\r\n    sim_debug(dev->dbit, dev->dptr, \"All Multicast\\n\");\r\n    }\r\n  if (dev->promiscuous) {\r\n    sim_debug(dev->dbit, dev->dptr, \"Promiscuous\\n\");\r\n    }\r\n  }\r\n#ifdef USE_READER_THREAD\r\n  pthread_mutex_lock (&dev->self_lock);\r\n#endif\r\n/* Set the desired physical address */\r\nmemset(dev->physical_addr, 0, sizeof(ETH_MAC));\r\ndev->loopback_self_sent = 0;\r\n/* Find desired physical address in filters */\r\nfor (i = 0; i < addr_count; i++) {\r\n  if (dev->filter_address[i][0]&1)\r\n    continue;  /* skip all multicast addresses */\r\n  eth_mac_fmt(&dev->filter_address[i], mac);\r\n  if (strcmp(mac, \"00:00:00:00:00:00\") != 0) {\r\n    memcpy(dev->physical_addr, &dev->filter_address[i], sizeof(ETH_MAC));\r\n    break;\r\n    }\r\n  }\r\n#ifdef USE_READER_THREAD\r\n  pthread_mutex_unlock (&dev->self_lock);\r\n#endif\r\n\r\n/* setup BPF filters and other fields to minimize packet delivery */\r\neth_bpf_filter (dev, dev->addr_count, dev->filter_address,\r\n                dev->all_multicast, dev->promiscuous,\r\n                dev->reflections, &dev->physical_addr,\r\n                dev->have_host_nic_phy_addr ? &dev->host_nic_phy_hw_addr: NULL,\r\n                (dev->hash_filter ? &dev->hash : NULL), buf);\r\n\r\n/* get netmask, which is a required argument for compiling.  The value,\r\n   in our case isn't actually interesting since the filters we generate\r\n   aren't referencing IP fields, networks or values */\r\n\r\n#ifdef USE_BPF\r\nif (dev->eth_api == ETH_API_PCAP) {\r\n  char errbuf[PCAP_ERRBUF_SIZE];\r\n  bpf_u_int32  bpf_subnet, bpf_netmask;\r\n\r\n  if (pcap_lookupnet(dev->name, &bpf_subnet, &bpf_netmask, errbuf)<0)\r\n    bpf_netmask = 0;\r\n  /* compile filter string */\r\n  if ((status = pcap_compile((pcap_t*)dev->handle, &bpf, buf, 1, bpf_netmask)) < 0) {\r\n    sprintf(errbuf, \"%s\", pcap_geterr((pcap_t*)dev->handle));\r\n    sim_printf(\"Eth: pcap_compile error: %s\\n\", errbuf);\r\n    /* show erroneous BPF string */\r\n    sim_printf (\"Eth: BPF string is: |%s|\\n\", buf);\r\n    sim_printf (\"Eth: Input to BPF string construction:\\n\");\r\n    sim_printf (\"Eth: Reflections: %d\\n\", dev->reflections);\r\n    sim_printf (\"Eth: Filter Set:\\n\");\r\n    for (i = 0; i < addr_count; i++) {\r\n      char mac[20];\r\n      eth_mac_fmt(&dev->filter_address[i], mac);\r\n      sim_printf (\"Eth:   Addr[%d]: %s\\n\", i, mac);\r\n      }\r\n    if (dev->all_multicast)\r\n      sim_printf (\"Eth: All Multicast\\n\");\r\n    if (dev->promiscuous)\r\n      sim_printf (\"Eth: Promiscuous\\n\");\r\n    if (dev->hash_filter)\r\n      sim_printf (\"Eth: Multicast Hash: %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\\n\",\r\n                  dev->hash[0], dev->hash[1], dev->hash[2], dev->hash[3],\r\n                  dev->hash[4], dev->hash[5], dev->hash[6], dev->hash[7]);\r\n    if (dev->have_host_nic_phy_addr) {\r\n      eth_mac_fmt(&dev->host_nic_phy_hw_addr, mac);\r\n      sim_printf (\"Eth: host_nic_phy_hw_addr: %s\\n\", mac);\r\n      }\r\n    }\r\n  else {\r\n    /* apply compiled filter string */\r\n    if ((status = pcap_setfilter((pcap_t*)dev->handle, &bpf)) < 0) {\r\n      sprintf(errbuf, \"%s\", pcap_geterr((pcap_t*)dev->handle));\r\n      sim_printf(\"Eth: pcap_setfilter error: %s\\n\", errbuf);\r\n      sim_printf (\"Eth: BPF string is: |%s|\\n\", buf);\r\n      }\r\n    else {\r\n      /* Save BPF filter string */\r\n      dev->bpf_filter = (char *)realloc(dev->bpf_filter, 1 + strlen(buf));\r\n      strcpy (dev->bpf_filter, buf);\r\n#ifdef USE_SETNONBLOCK\r\n      /* set file non-blocking */\r\n      status = pcap_setnonblock (dev->handle, 1, errbuf);\r\n#endif /* USE_SETNONBLOCK */\r\n      }\r\n    pcap_freecode(&bpf);\r\n    }\r\n#ifdef USE_READER_THREAD\r\n  pthread_mutex_lock (&dev->lock);\r\n  ethq_clear (&dev->read_queue); /* Empty FIFO Queue when filter list changes */\r\n  pthread_mutex_unlock (&dev->lock);\r\n#endif\r\n  }\r\n#endif /* USE_BPF */\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\nvoid eth_show_dev (FILE *st, ETH_DEV* dev)\r\n{\r\nfprintf(st, \"Ethernet Device:\\n\");\r\nif (!dev) {\r\n  fprintf(st, \"-- Not Attached\\n\");\r\n  return;\r\n  }\r\nfprintf(st, \"  Name:                    %s\\n\", dev->name);\r\nfprintf(st, \"  Reflections:             %d\\n\", dev->reflections);\r\nfprintf(st, \"  Self Loopbacks Sent:     %d\\n\", dev->loopback_self_sent_total);\r\nfprintf(st, \"  Self Loopbacks Rcvd:     %d\\n\", dev->loopback_self_rcvd_total);\r\nif (dev->have_host_nic_phy_addr) {\r\n  char hw_mac[20];\r\n\r\n  eth_mac_fmt(&dev->host_nic_phy_hw_addr, hw_mac);\r\n  fprintf(st, \"  Host NIC Address:        %s\\n\", hw_mac);\r\n  }\r\nif (dev->jumbo_dropped)\r\n  fprintf(st, \"  Jumbo Dropped:           %d\\n\", dev->jumbo_dropped);\r\nif (dev->jumbo_fragmented)\r\n  fprintf(st, \"  Jumbo Fragmented:        %d\\n\", dev->jumbo_fragmented);\r\nif (dev->jumbo_truncated)\r\n  fprintf(st, \"  Jumbo Truncated:         %d\\n\", dev->jumbo_truncated);\r\nif (dev->packets_sent)\r\n  fprintf(st, \"  Packets Sent:            %d\\n\", dev->packets_sent);\r\nif (dev->transmit_packet_errors)\r\n  fprintf(st, \"  Send Packet Errors:      %d\\n\", dev->transmit_packet_errors);\r\nif (dev->packets_received)\r\n  fprintf(st, \"  Packets Received:        %d\\n\", dev->packets_received);\r\nif (dev->receive_packet_errors)\r\n  fprintf(st, \"  Read Packet Errors:      %d\\n\", dev->receive_packet_errors);\r\nif (dev->error_reopen_count)\r\n  fprintf(st, \"  Error ReOpen Count:      %d\\n\", dev->error_reopen_count);\r\nif (dev->loopback_packets_processed)\r\n  fprintf(st, \"  Loopback Packets:        %d\\n\", dev->loopback_packets_processed);\r\n#if defined(USE_READER_THREAD)\r\nfprintf(st, \"  Asynch Interrupts:       %s\\n\", dev->asynch_io?\"Enabled\":\"Disabled\");\r\nif (dev->asynch_io)\r\n  fprintf(st, \"  Interrupt Latency:       %d uSec\\n\", dev->asynch_io_latency);\r\nif (dev->throttle_count)\r\n  fprintf(st, \"  Throttle Delays:         %d\\n\", dev->throttle_count);\r\nfprintf(st, \"  Read Queue: Count:       %d\\n\", dev->read_queue.count);\r\nfprintf(st, \"  Read Queue: High:        %d\\n\", dev->read_queue.high);\r\nfprintf(st, \"  Read Queue: Loss:        %d\\n\", dev->read_queue.loss);\r\nfprintf(st, \"  Peak Write Queue Size:   %d\\n\", dev->write_queue_peak);\r\n#endif\r\nif (dev->error_needs_reset)\r\n  fprintf(st, \"  In Error Needs Reset:    True\\n\");\r\nif (dev->error_reopen_count)\r\n  fprintf(st, \"  Error Reopen Count:      %d\\n\", (int)dev->error_reopen_count);\r\nif (1) {\r\n  int i, count = 0;\r\n  ETH_MAC zeros = {0, 0, 0, 0, 0, 0};\r\n  char  buffer[20];\r\n\r\n  for (i = 0; i < ETH_FILTER_MAX; i++) {\r\n    if (memcmp(zeros, &dev->filter_address[i], sizeof(ETH_MAC))) {\r\n      eth_mac_fmt(&dev->filter_address[i], buffer);\r\n      fprintf(st, \"  MAC Filter[%2d]: %s\\n\", count++, buffer);\r\n      }\r\n    }\r\n  }\r\nif (dev->all_multicast)\r\n  fprintf(st, \"  All Multicast mode:      Enabled\\n\");\r\nif (dev->promiscuous)\r\n  fprintf(st, \"  Promiscuous mode:        Enabled\\n\");\r\nif (dev->bpf_filter)\r\n  fprintf(st, \"  BPF Filter: %s\\n\", dev->bpf_filter);\r\n#if defined(HAVE_SLIRP_NETWORK)\r\nif (dev->eth_api == ETH_API_NAT)\r\n  sim_slirp_show ((SLIRP *)dev->handle, st);\r\n#endif\r\n}\r\n\r\nstatic\r\nt_stat eth_test_crc32 (DEVICE *dptr)\r\n{\r\nint errors = 0;\r\nint val;\r\nuint8 data[12];\r\nstatic uint32 valcrc32[] = {\r\n  0x7BD5C66F, 0x92C4D707, 0x7286E2FE, 0x9B97F396, 0x69738F4D, 0x80629E25, 0x6020ABDC, 0x8931BAB4,\r\n  0x5E99542B, 0xB7884543, 0x57CA70BA, 0xBEDB61D2, 0x4C3F1D09, 0xA52E0C61, 0x456C3998, 0xAC7D28F0,\r\n  0x314CE2E7, 0xD85DF38F, 0x381FC676, 0xD10ED71E, 0x23EAABC5, 0xCAFBBAAD, 0x2AB98F54, 0xC3A89E3C,\r\n  0x140070A3, 0xFD1161CB, 0x1D535432, 0xF442455A, 0x06A63981, 0xEFB728E9, 0x0FF51D10, 0xE6E40C78,\r\n  0xEEE78F7F, 0x07F69E17, 0xE7B4ABEE, 0x0EA5BA86, 0xFC41C65D, 0x1550D735, 0xF512E2CC, 0x1C03F3A4,\r\n  0xCBAB1D3B, 0x22BA0C53, 0xC2F839AA, 0x2BE928C2, 0xD90D5419, 0x301C4571, 0xD05E7088, 0x394F61E0,\r\n  0xA47EABF7, 0x4D6FBA9F, 0xAD2D8F66, 0x443C9E0E, 0xB6D8E2D5, 0x5FC9F3BD, 0xBF8BC644, 0x569AD72C,\r\n  0x813239B3, 0x682328DB, 0x88611D22, 0x61700C4A, 0x93947091, 0x7A8561F9, 0x9AC75400, 0x73D64568,\r\n  0x8AC0520E, 0x63D14366, 0x8393769F, 0x6A8267F7, 0x98661B2C, 0x71770A44, 0x91353FBD, 0x78242ED5,\r\n  0xAF8CC04A, 0x469DD122, 0xA6DFE4DB, 0x4FCEF5B3, 0xBD2A8968, 0x543B9800, 0xB479ADF9, 0x5D68BC91,\r\n  0xC0597686, 0x294867EE, 0xC90A5217, 0x201B437F, 0xD2FF3FA4, 0x3BEE2ECC, 0xDBAC1B35, 0x32BD0A5D,\r\n  0xE515E4C2, 0x0C04F5AA, 0xEC46C053, 0x0557D13B, 0xF7B3ADE0, 0x1EA2BC88, 0xFEE08971, 0x17F19819,\r\n  0x1FF21B1E, 0xF6E30A76, 0x16A13F8F, 0xFFB02EE7, 0x0D54523C, 0xE4454354, 0x040776AD, 0xED1667C5,\r\n  0x3ABE895A, 0xD3AF9832, 0x33EDADCB, 0xDAFCBCA3, 0x2818C078, 0xC109D110, 0x214BE4E9, 0xC85AF581,\r\n  0x556B3F96, 0xBC7A2EFE, 0x5C381B07, 0xB5290A6F, 0x47CD76B4, 0xAEDC67DC, 0x4E9E5225, 0xA78F434D,\r\n  0x7027ADD2, 0x9936BCBA, 0x79748943, 0x9065982B, 0x6281E4F0, 0x8B90F598, 0x6BD2C061, 0x82C3D109,\r\n  0x428FE8EC, 0xAB9EF984, 0x4BDCCC7D, 0xA2CDDD15, 0x5029A1CE, 0xB938B0A6, 0x597A855F, 0xB06B9437,\r\n  0x67C37AA8, 0x8ED26BC0, 0x6E905E39, 0x87814F51, 0x7565338A, 0x9C7422E2, 0x7C36171B, 0x95270673,\r\n  0x0816CC64, 0xE107DD0C, 0x0145E8F5, 0xE854F99D, 0x1AB08546, 0xF3A1942E, 0x13E3A1D7, 0xFAF2B0BF,\r\n  0x2D5A5E20, 0xC44B4F48, 0x24097AB1, 0xCD186BD9, 0x3FFC1702, 0xD6ED066A, 0x36AF3393, 0xDFBE22FB,\r\n  0xD7BDA1FC, 0x3EACB094, 0xDEEE856D, 0x37FF9405, 0xC51BE8DE, 0x2C0AF9B6, 0xCC48CC4F, 0x2559DD27,\r\n  0xF2F133B8, 0x1BE022D0, 0xFBA21729, 0x12B30641, 0xE0577A9A, 0x09466BF2, 0xE9045E0B, 0x00154F63,\r\n  0x9D248574, 0x7435941C, 0x9477A1E5, 0x7D66B08D, 0x8F82CC56, 0x6693DD3E, 0x86D1E8C7, 0x6FC0F9AF,\r\n  0xB8681730, 0x51790658, 0xB13B33A1, 0x582A22C9, 0xAACE5E12, 0x43DF4F7A, 0xA39D7A83, 0x4A8C6BEB,\r\n  0xB39A7C8D, 0x5A8B6DE5, 0xBAC9581C, 0x53D84974, 0xA13C35AF, 0x482D24C7, 0xA86F113E, 0x417E0056,\r\n  0x96D6EEC9, 0x7FC7FFA1, 0x9F85CA58, 0x7694DB30, 0x8470A7EB, 0x6D61B683, 0x8D23837A, 0x64329212,\r\n  0xF9035805, 0x1012496D, 0xF0507C94, 0x19416DFC, 0xEBA51127, 0x02B4004F, 0xE2F635B6, 0x0BE724DE,\r\n  0xDC4FCA41, 0x355EDB29, 0xD51CEED0, 0x3C0DFFB8, 0xCEE98363, 0x27F8920B, 0xC7BAA7F2, 0x2EABB69A,\r\n  0x26A8359D, 0xCFB924F5, 0x2FFB110C, 0xC6EA0064, 0x340E7CBF, 0xDD1F6DD7, 0x3D5D582E, 0xD44C4946,\r\n  0x03E4A7D9, 0xEAF5B6B1, 0x0AB78348, 0xE3A69220, 0x1142EEFB, 0xF853FF93, 0x1811CA6A, 0xF100DB02,\r\n  0x6C311115, 0x8520007D, 0x65623584, 0x8C7324EC, 0x7E975837, 0x9786495F, 0x77C47CA6, 0x9ED56DCE,\r\n  0x497D8351, 0xA06C9239, 0x402EA7C0, 0xA93FB6A8, 0x5BDBCA73, 0xB2CADB1B, 0x5288EEE2, 0xBB99FF8A};\r\n\r\nfor (val=0; val <= 0xFF; val++) {\r\n  memset (data, val, sizeof (data));\r\n  if (valcrc32[val] != eth_crc32 (0, data, sizeof (data))) {\r\n    printf(\"Unexpected CRC for %d byte buffer containing 0x%02X. Expected %08X, got %08X\\n\",\r\n           (int)sizeof (data), val, valcrc32[val], eth_crc32 (0, data, sizeof (data)));\r\n    ++errors;\r\n    }\r\n  }\r\nreturn (errors == 0) ? SCPE_OK : SCPE_IERR;\r\n}\r\n\r\nstatic\r\nt_stat eth_test_bpf (DEVICE *dptr)\r\n{\r\nint errors = 0;\r\n#ifdef USE_BPF\r\nt_stat r;\r\nDEVICE eth_tst;\r\nETH_DEV dev;\r\nint eth_num;\r\nint eth_opened;\r\nETH_LIST  eth_list[ETH_MAX_DEVICE];\r\nint eth_device_count;\r\nint reflections, all_multicast, promiscuous;\r\nchar buf[116+66*ETH_FILTER_MAX];\r\nchar mac[20];\r\nETH_MAC filter_address[3] = {\r\n    {0x04, 0x05, 0x06, 0x07, 0x08, 0x09},\r\n    {0x09, 0x00, 0x2B, 0x02, 0x01, 0x07},\r\n    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},\r\n  };\r\nint addr_count;\r\nETH_MAC host_nic_phy_hw_addr = {0x02, 0x03, 0x04, 0x05, 0x06, 0x07};\r\nETH_MAC *host_phy_addr_list[2] = {&host_nic_phy_hw_addr, NULL};\r\nint host_phy_addr_listindex;\r\nETH_MULTIHASH hash = {0x01, 0x40, 0x00, 0x00, 0x48, 0x88, 0x40, 0x00};\r\nETH_MULTIHASH *hash_list[2] = {&hash, NULL};\r\nint hash_listindex;\r\nint bpf_count = 0;\r\nint bpf_construct_error_count = 0;\r\nint bpf_compile_error_count = 0;\r\nint bpf_compile_skip_count = 0;\r\n#define SIM_PRINT_BPF_ARGUMENTS                                 \\\r\n    if (1) {                                                    \\\r\n      sim_printf (\"Eth: Input to BPF string construction:\\n\");  \\\r\n      sim_printf (\"Eth: Reflections: %d\\n\", reflections);       \\\r\n      sim_printf (\"Eth: Filter Set:\\n\");                        \\\r\n      for (i = 0; i < addr_count; i++) {                        \\\r\n        eth_mac_fmt(&filter_address[i], mac);                   \\\r\n        sim_printf (\"Eth:   Addr[%d]: %s\\n\", i, mac);           \\\r\n        }                                                       \\\r\n      if (all_multicast)                                        \\\r\n        sim_printf (\"Eth: All Multicast\\n\");                    \\\r\n      if (promiscuous)                                          \\\r\n        sim_printf (\"Eth: Promiscuous\\n\");                      \\\r\n      if (hash_list[hash_listindex])                            \\\r\n        sim_printf (\"Eth: Multicast Hash: %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\\n\",\\\r\n                    (*hash_list[hash_listindex])[0], (*hash_list[hash_listindex])[1], (*hash_list[hash_listindex])[2], (*hash_list[hash_listindex])[3], \\\r\n                    (*hash_list[hash_listindex])[4], (*hash_list[hash_listindex])[5], (*hash_list[hash_listindex])[6], (*hash_list[hash_listindex])[7]);\\\r\n      if (host_phy_addr_list[host_phy_addr_listindex]) {        \\\r\n        eth_mac_fmt(host_phy_addr_list[host_phy_addr_listindex], mac);\\\r\n        sim_printf (\"Eth: host_nic_phy_hw_addr: %s\\n\", mac);    \\\r\n        }                                                       \\\r\n      }\r\n\r\n\r\nmemset (&eth_tst, 0, sizeof(eth_tst));\r\neth_device_count = eth_devices(ETH_MAX_DEVICE, eth_list, FALSE);\r\neth_opened = 0;\r\nfor (eth_num=0; eth_num<eth_device_count; eth_num++) {\r\n  char eth_name[32];\r\n\r\n  if ((0 == memcmp (eth_list[eth_num].name, \"nat:\", 4)) ||\r\n      (0 == memcmp (eth_list[eth_num].name, \"tap:\", 4)) ||\r\n      (0 == memcmp (eth_list[eth_num].name, \"vde:\", 4)) ||\r\n      (0 == memcmp (eth_list[eth_num].name, \"udp:\", 4)))\r\n      continue;\r\n  eth_name[sizeof (eth_name)-1] = '\\0';\r\n  snprintf (eth_name, sizeof (eth_name)-1, \"eth%d\", eth_num);\r\n  r = eth_open(&dev, eth_name, &eth_tst, 1);\r\n  if (r != SCPE_OK) {\r\n    sim_printf (\"%s: Eth: Error opening eth%d: %s\\n\", dptr->name, eth_num, sim_error_text (r));\r\n    continue;\r\n    }\r\n  ++eth_opened;\r\n  for (reflections=0; reflections<=1; reflections++) {\r\n    for (all_multicast=0; all_multicast<=1; all_multicast++) {\r\n      for (promiscuous=0; promiscuous<=1; promiscuous++) {\r\n        for (addr_count=1; addr_count<=2; addr_count++) {\r\n          for (hash_listindex=0; hash_listindex<=1; hash_listindex++) {\r\n            for (host_phy_addr_listindex=0; host_phy_addr_listindex<=1; host_phy_addr_listindex++) {\r\n              int i;\r\n              char errbuf[PCAP_ERRBUF_SIZE];\r\n\r\n              ++bpf_count;\r\n              r = eth_bpf_filter (&dev, addr_count, &filter_address[0],\r\n                                  all_multicast, promiscuous, reflections,\r\n                                  &filter_address[0],\r\n                                  host_phy_addr_list[host_phy_addr_listindex],\r\n                                  hash_list[hash_listindex],\r\n                                  buf);\r\n              if (r != SCPE_OK) {\r\n                ++bpf_construct_error_count;\r\n                sim_printf (\"Eth: Error producing a BPF filter for:\\n\");\r\n                SIM_PRINT_BPF_ARGUMENTS;\r\n                }\r\n              else {\r\n                if (sim_switches & SWMASK('D')) {\r\n                  SIM_PRINT_BPF_ARGUMENTS;\r\n                  sim_printf (\"Eth: BPF string is: |%s|\\n\", buf);\r\n                  }\r\n                if (dev.eth_api == ETH_API_PCAP) {\r\n                  struct bpf_program bpf;\r\n\r\n                  if (pcap_compile ((pcap_t*)dev.handle, &bpf, buf, 1, (bpf_u_int32)0) < 0) {\r\n                    ++bpf_compile_error_count;\r\n                    sprintf(errbuf, \"%s\", pcap_geterr((pcap_t*)dev.handle));\r\n                    sim_printf(\"Eth: pcap_compile error: %s\\n\", errbuf);\r\n                    if (!(sim_switches & SWMASK('D'))) {\r\n                      /* show erroneous BPF string */\r\n                      SIM_PRINT_BPF_ARGUMENTS;\r\n                      sim_printf (\"Eth: BPF string is: |%s|\\n\", buf);\r\n                      }\r\n                    }\r\n                  pcap_freecode(&bpf);\r\n                  }\r\n                else\r\n                  ++bpf_compile_skip_count;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  eth_close(&dev);\r\n  }\r\n\r\nif (eth_opened == 0) {\r\n  errors = 1;\r\n  sim_printf (\"%s: No testable LAN interfaces found\\n\", dptr->name);\r\n  }\r\nif (bpf_count)\r\n  sim_printf (\"BPF Filter Count:     %d\\n\", bpf_count);\r\nif (bpf_construct_error_count)\r\n  sim_printf (\"BPF Construct Errors: %d\\n\", bpf_construct_error_count);\r\nif (bpf_compile_error_count)\r\n  sim_printf (\"BPF Compile Errors:   %d\\n\", bpf_compile_error_count);\r\nif (bpf_compile_skip_count)\r\n  sim_printf (\"BPF Compile Skipped:  %d\\n\", bpf_compile_skip_count);\r\n#endif /* USE_BPF */\r\nreturn (errors == 0) ? SCPE_OK : SCPE_IERR;\r\n}\r\n\r\nt_stat sim_ether_test (DEVICE *dptr, const char *cptr)\r\n{\r\nt_stat stat = SCPE_OK;\r\nSIM_TEST_INIT;\r\n\r\nsim_printf (\"Testing %s device sim_ether APIs\\n\", dptr->name);\r\n\r\nSIM_TEST(eth_test_crc32 (dptr));\r\nSIM_TEST(eth_test_bpf (dptr));\r\nreturn stat;\r\n}\r\n#endif /* USE_NETWORK */\r\n"
        },
        {
          "name": "sim_ether.h",
          "type": "blob",
          "size": 22.287109375,
          "content": "/* sim_ether.h: OS-dependent network information\r\n  ------------------------------------------------------------------------------\r\n\r\n   Copyright (c) 2002-2005, David T. Hittner\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n\r\n  ------------------------------------------------------------------------------\r\n\r\n  Modification history:\r\n\r\n  01-Mar-12  AGN  Cygwin doesn't have non-blocking pcap I/O pcap (it uses WinPcap)\r\n  17-Nov-11  MP   Added dynamic loading of libpcap on *nix platforms\r\n  30-Oct-11  MP   Added support for vde (Virtual Distributed Ethernet) networking\r\n  18-Apr-11  MP   Fixed race condition with self loopback packets in\r\n                  multithreaded environments\r\n  09-Dec-10  MP   Added support to determine if network address conflicts exist\r\n  07-Dec-10  MP   Reworked DECnet self detection to the more general approach\r\n                  of loopback self when any Physical Address is being set.\r\n  04-Dec-10  MP   Changed eth_write to do nonblocking writes when\r\n                  USE_READER_THREAD is defined.\r\n  07-Feb-08  MP   Added eth_show_dev to display ethernet state\r\n  28-Jan-08  MP   Added eth_set_async\r\n  23-Jan-08  MP   Added eth_packet_trace_ex and ethq_destroy\r\n  30-Nov-05  DTH  Added CRC length to packet and more field comments\r\n  04-Feb-04  DTH  Added debugging information\r\n  14-Jan-04  MP   Generalized BSD support issues\r\n  05-Jan-04  DTH  Added eth_mac_scan\r\n  26-Dec-03  DTH  Added ethernet show and queue functions from pdp11_xq\r\n  23-Dec-03  DTH  Added status to packet\r\n  01-Dec-03  DTH  Added reflections, tweaked decnet fix items\r\n  25-Nov-03  DTH  Verified DECNET_FIX, reversed ifdef to mainstream code\r\n  14-Nov-03  DTH  Added #ifdef DECNET_FIX for problematic duplicate detection code\r\n  07-Jun-03  MP   Added WIN32 support for DECNET duplicate address detection.\r\n  05-Jun-03  DTH  Added used to struct eth_packet\r\n  01-Feb-03  MP   Changed some uint8 strings to char* to reflect usage\r\n  22-Oct-02  DTH  Added all_multicast and promiscuous support\r\n  21-Oct-02  DTH  Corrected copyright again\r\n  16-Oct-02  DTH  Fixed copyright\r\n  08-Oct-02  DTH  Integrated with 2.10-0p4, added variable vector and copyrights\r\n  03-Oct-02  DTH  Beta version of xq/sim_ether released for SIMH 2.09-11\r\n  15-Aug-02  DTH  Started XQ simulation\r\n\r\n  ------------------------------------------------------------------------------\r\n*/\r\n\r\n#ifndef SIM_ETHER_H\r\n#define SIM_ETHER_H\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_sock.h\"\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* make common BSD code a bit easier to read in this file */\r\n/* OS/X seems to define and compile using one of these BSD types */\r\n#if defined(__NetBSD__) || defined (__OpenBSD__) || defined (__FreeBSD__)\r\n#define xBSD 1\r\n#endif\r\n#if !defined(__FreeBSD__) && !defined(_WIN32) && !defined(VMS) && !defined(__CYGWIN__) && !defined(__APPLE__)\r\n#define USE_SETNONBLOCK 1\r\n#endif\r\n\r\n/* cygwin doesn't have the right features to use the threaded network I/O */\r\n#if defined(__CYGWIN__) || defined(__ZAURUS__) // psco added check for Zaurus platform\r\n#define DONT_USE_READER_THREAD\r\n#endif\r\n\r\n#if ((((defined(__sun) || defined(__sun__)) && defined(__i386__)) || defined(__linux)) && !defined(DONT_USE_READER_THREAD))\r\n#define USE_READER_THREAD 1\r\n#endif\r\n\r\n#if defined(DONT_USE_READER_THREAD)\r\n#undef USE_READER_THREAD\r\n#endif\r\n\r\n/* make common winpcap code a bit easier to read in this file */\r\n#if defined(_WIN32) || defined(VMS) || defined(__CYGWIN__)\r\n#define PCAP_READ_TIMEOUT -1\r\n#else\r\n#define PCAP_READ_TIMEOUT  1\r\n#endif\r\n\r\n#include <time.h>\r\n#if defined(__struct_timespec_defined) && !defined(_TIMESPEC_DEFINED)\r\n#define _TIMESPEC_DEFINED\r\n#endif\r\n\r\n/* set related values to have correct relationships */\r\n#if defined (USE_READER_THREAD)\r\n#include <pthread.h>\r\n#if defined (USE_SETNONBLOCK)\r\n#undef USE_SETNONBLOCK\r\n#endif /* USE_SETNONBLOCK */\r\n#undef PCAP_READ_TIMEOUT\r\n#define PCAP_READ_TIMEOUT 15\r\n#if (!defined (xBSD) && !defined(_WIN32) && !defined(VMS) && !defined(__CYGWIN__)) || defined (HAVE_TAP_NETWORK) || defined (HAVE_VDE_NETWORK)\r\n#define MUST_DO_SELECT 1\r\n#endif\r\n#endif /* USE_READER_THREAD */\r\n\r\n/* give priority to USE_NETWORK over USE_SHARED */\r\n#if defined(USE_NETWORK) && defined(USE_SHARED)\r\n#undef USE_SHARED\r\n#endif\r\n/* USE_SHARED only works on Windows or if SIM_HAVE_DLOPEN */\r\n#if defined(USE_SHARED) && !defined(_WIN32) && !defined(SIM_HAVE_DLOPEN)\r\n#undef USE_SHARED\r\n#endif\r\n\r\n/* USE_SHARED implies shared pcap, so force HAVE_PCAP_NETWORK */\r\n#if defined(USE_SHARED) && !defined(HAVE_PCAP_NETWORK)\r\n#define HAVE_PCAP_NETWORK 1\r\n#endif\r\n\r\n/*\r\n  USE_BPF is defined to let this code leverage the libpcap/OS kernel provided\r\n  BPF packet filtering.  This generally will enhance performance.  It may not\r\n  be available in some environments and/or it may not work correctly, so\r\n  undefining this will still provide working code here.\r\n*/\r\n#if defined(HAVE_PCAP_NETWORK)\r\n#define USE_BPF 1\r\n#if defined (_WIN32) && !defined (BPF_CONST_STRING)\r\n#define BPF_CONST_STRING 1\r\n#endif\r\n#else\r\n#define DONT_USE_PCAP_FINDALLDEVS 1\r\n#endif\r\n\r\n\r\n/* structure declarations */\r\n\r\n#define ETH_PROMISC            1                        /* promiscuous mode = true */\r\n#define ETH_TIMEOUT           -1                        /* read timeout in milliseconds (immediate) */\r\n#define ETH_FILTER_MAX        20                        /* maximum address filters */\r\n#define ETH_DEV_NAME_MAX     256                        /* maximum device name size */\r\n#define ETH_DEV_DESC_MAX     256                        /* maximum device description size */\r\n#define ETH_MIN_PACKET        60                        /* minimum ethernet packet size */\r\n#define ETH_MAX_PACKET      1514                        /* maximum ethernet packet size */\r\n#define ETH_MAX_JUMBO_FRAME 65536                       /* maximum ethernet jumbo frame size (or Offload Segment Size) */\r\n#define ETH_MAX_DEVICE        40                        /* maximum ethernet devices */\r\n#define ETH_CRC_SIZE           4                        /* ethernet CRC size */\r\n#define ETH_FRAME_SIZE (ETH_MAX_PACKET+ETH_CRC_SIZE)    /* ethernet maximum frame size */\r\n#define ETH_MIN_JUMBO_FRAME ETH_MAX_PACKET              /* Threshold size for Jumbo Frame Processing */\r\n\r\n#define LOOPBACK_SELF_FRAME(phy_mac, msg)                                                     \\\r\n    (((msg)[12] == 0x90) && ((msg)[13] == 0x00) &&              /* Ethernet Loopback */       \\\r\n     ((msg)[16] == 0x02) && ((msg)[17] == 0x00) &&              /* Forward Function */        \\\r\n     ((msg)[24] == 0x01) && ((msg)[25] == 0x00) &&              /* Next Function - Reply */   \\\r\n     (memcmp(phy_mac, (msg),    6) == 0) &&                     /* Ethernet Destination */    \\\r\n     (memcmp(phy_mac, (msg)+6,  6) == 0) &&                     /* Ethernet Source */         \\\r\n     (memcmp(phy_mac, (msg)+18, 6) == 0))                       /* Forward Address */\r\n\r\n#define LOOPBACK_PHYSICAL_RESPONSE(dev, msg)                                                    \\\r\n    ((dev->have_host_nic_phy_addr) &&                                                           \\\r\n     ((msg)[12] == 0x90) && ((msg)[13] == 0x00) &&              /* Ethernet Loopback */         \\\r\n     ((msg)[14] == 0x08) && ((msg)[15] == 0x00) &&              /* Skipcount - 8 */             \\\r\n     ((msg)[16] == 0x02) && ((msg)[17] == 0x00) &&              /* Last Function - Forward */   \\\r\n     ((msg)[24] == 0x01) && ((msg)[25] == 0x00) &&              /* Function - Reply */          \\\r\n     (memcmp(dev->host_nic_phy_hw_addr, (msg)+18, 6) == 0) &&   /* Forward Address - Host MAC */\\\r\n     (memcmp(dev->host_nic_phy_hw_addr, (msg),    6) == 0) &&   /* Ethernet Source - Host MAC */\\\r\n     (memcmp(dev->physical_addr,  (msg)+6,  6) == 0))           /* Ethernet Source */\r\n\r\n#define LOOPBACK_PHYSICAL_REFLECTION(dev, msg)                                                  \\\r\n    ((dev->have_host_nic_phy_addr) &&                                                           \\\r\n     ((msg)[12] == 0x90) && ((msg)[13] == 0x00) &&              /* Ethernet Loopback */         \\\r\n     ((msg)[16] == 0x02) && ((msg)[17] == 0x00) &&              /* Forward Function */          \\\r\n     ((msg)[24] == 0x01) && ((msg)[25] == 0x00) &&              /* Next Function - Reply */     \\\r\n     (memcmp(dev->host_nic_phy_hw_addr, (msg)+6,  6) == 0) &&   /* Ethernet Source - Host MAC */\\\r\n     (memcmp(dev->host_nic_phy_hw_addr, (msg)+18, 6) == 0))     /* Forward Address - Host MAC */\r\n\r\n#define LOOPBACK_REFLECTION_TEST_PACKET(dev, msg)                                                \\\r\n    ((dev->have_host_nic_phy_addr) &&                                                            \\\r\n     ((msg)[12] == 0x90) && ((msg)[13] == 0x00) &&             /* Ethernet Loopback */           \\\r\n     ((msg)[14] == 0x00) && ((msg)[15] == 0x00) &&             /* Skipcount - 0 */               \\\r\n     ((msg)[16] == 0x02) && ((msg)[17] == 0x00) &&             /* Forward Function */            \\\r\n     ((msg)[24] == 0x01) && ((msg)[25] == 0x00) &&             /* Next Function - Reply */       \\\r\n     ((msg)[00] == 0xFE) && ((msg)[01] == 0xFF) &&             /* Ethernet Destination - Reflection Test MAC */\\\r\n     ((msg)[02] == 0xFF) && ((msg)[03] == 0xFF) &&                                               \\\r\n     ((msg)[04] == 0xFF) && ((msg)[05] == 0xFE) &&                                               \\\r\n     (memcmp(dev->host_nic_phy_hw_addr, (msg)+6,  6) == 0))    /* Ethernet Source - Host MAC */\r\n\r\nstruct eth_packet {\r\n  uint8   msg[ETH_FRAME_SIZE];                          /* ethernet frame (message) */\r\n  uint8   *oversize;                                    /* oversized frame (message) */\r\n  uint32  len;                                          /* packet length without CRC */\r\n  uint32  used;                                         /* bytes processed (used in packet chaining) */\r\n  int     status;                                       /* transmit/receive status */\r\n  uint32  crc_len;                                      /* packet length with CRC */\r\n};\r\n\r\nstruct eth_item {\r\n  int                 type;                             /* receive (0=setup, 1=loopback, 2=normal) */\r\n#define ETH_ITM_SETUP    0\r\n#define ETH_ITM_LOOPBACK 1\r\n#define ETH_ITM_NORMAL   2\r\n  struct eth_packet   packet;\r\n};\r\n\r\nstruct eth_queue {\r\n  int                 max;\r\n  int                 count;\r\n  int                 head;\r\n  int                 tail;\r\n  int                 loss;\r\n  int                 high;\r\n  struct eth_item*    item;\r\n};\r\n\r\ntypedef unsigned char ETH_MAC[6];\r\n\r\nstruct eth_list {\r\n  char    name[ETH_DEV_NAME_MAX];\r\n  char    desc[ETH_DEV_DESC_MAX];\r\n  int     eth_api;\r\n};\r\n\r\ntypedef int ETH_BOOL;\r\ntypedef unsigned char ETH_MULTIHASH[8];\r\ntypedef struct eth_packet  ETH_PACK;\r\ntypedef void (*ETH_PCALLBACK)(int status);\r\ntypedef struct eth_list ETH_LIST;\r\ntypedef struct eth_queue ETH_QUE;\r\ntypedef struct eth_item ETH_ITEM;\r\nstruct eth_write_request {\r\n  struct eth_write_request *next;\r\n  ETH_PACK packet;\r\n  };\r\ntypedef struct eth_write_request ETH_WRITE_REQUEST;\r\n\r\nstruct eth_device {\r\n  char*         name;                                   /* name of ethernet device */\r\n  void*         handle;                                 /* handle of implementation-specific device */\r\n  SOCKET        fd_handle;                              /* fd to kernel device (where needed) */\r\n  char*         bpf_filter;                             /* bpf filter currently in effect */\r\n  int           eth_api;                                /* Designator for which API is being used to move packets */\r\n#define ETH_API_NONE 0                                  /* No API in use yet */\r\n#define ETH_API_PCAP 1                                  /* Pcap API in use */\r\n#define ETH_API_TAP  2                                  /* tun/tap API in use */\r\n#define ETH_API_VDE  3                                  /* VDE API in use */\r\n#define ETH_API_UDP  4                                  /* UDP API in use */\r\n#define ETH_API_NAT  5                                  /* NAT (SLiRP) API in use */\r\n  ETH_PCALLBACK read_callback;                          /* read callback function */\r\n  ETH_PCALLBACK write_callback;                         /* write callback function */\r\n  ETH_PACK*     read_packet;                            /* read packet */\r\n  ETH_MAC       filter_address[ETH_FILTER_MAX];         /* filtering addresses */\r\n  int           addr_count;                             /* count of filtering addresses */\r\n  ETH_BOOL      promiscuous;                            /* promiscuous mode flag */\r\n  ETH_BOOL      all_multicast;                          /* receive all multicast messages */\r\n  ETH_BOOL      hash_filter;                            /* filter using AUTODIN II multicast hash */\r\n  ETH_MULTIHASH hash;                                   /* AUTODIN II multicast hash */\r\n  int32         loopback_self_sent;                     /* loopback packets sent but not seen */\r\n  int32         loopback_self_sent_total;               /* total loopback packets sent */\r\n  int32         loopback_self_rcvd_total;               /* total loopback packets seen */\r\n  ETH_MAC       physical_addr;                          /* physical address of interface */\r\n  int32         have_host_nic_phy_addr;                 /* flag indicating that the host_nic_phy_hw_addr is valid */\r\n  ETH_MAC       host_nic_phy_hw_addr;                   /* MAC address of the attached NIC */\r\n  uint32        jumbo_fragmented;                       /* Giant IPv4 Frames Fragmented */\r\n  uint32        jumbo_dropped;                          /* Giant Frames Dropped */\r\n  uint32        jumbo_truncated;                        /* Giant Frames too big for capture buffer - Dropped */\r\n  uint32        packets_sent;                           /* Total Packets Sent */\r\n  uint32        packets_received;                       /* Total Packets Received */\r\n  uint32        loopback_packets_processed;             /* Total Loopback Packets Processed */\r\n  uint32        transmit_packet_errors;                 /* Total Send Packet Errors */\r\n  uint32        receive_packet_errors;                  /* Total Read Packet Errors */\r\n  int32         error_waiting_threads;                  /* Count of threads currently waiting after an error */\r\n  ETH_BOOL      error_needs_reset;                      /* Flag indicating to force reset */\r\n#define ETH_ERROR_REOPEN_THRESHOLD 10                   /* Attempt ReOpen after 20 send/receive errors */\r\n#define ETH_ERROR_REOPEN_PAUSE 4                        /* Seconds to pause between closing and reopening LAN */\r\n  uint32        error_reopen_count;                     /* Count of ReOpen Attempts */\r\n  DEVICE*       dptr;                                   /* device ethernet is attached to */\r\n  uint32        dbit;                                   /* debugging bit */\r\n  int           reflections;                            /* packet reflections on interface */\r\n  int           need_crc;                               /* device needs CRC (Cyclic Redundancy Check) */\r\n  /* Throttling control parameters: */\r\n  uint32        throttle_time;                          /* ms burst time window */\r\n#define ETH_THROT_DEFAULT_TIME 5                        /* 5ms Default burst time window */\r\n  uint32        throttle_burst;                         /* packets passed with throttle_time which trigger throttling */\r\n#define ETH_THROT_DEFAULT_BURST 4                       /* 4 Packet burst in time window */\r\n  uint32        throttle_delay;                         /* ms to delay when throttling.  0 disables throttling */\r\n#define ETH_THROT_DISABLED_DELAY 0                      /* 0 Delay disables throttling */\r\n#define ETH_THROT_DEFAULT_DELAY 10                      /* 10ms Delay during burst */\r\n  /* Throttling state variables: */\r\n  uint32        throttle_mask;                          /* match test for threshold detection (1 << throttle_burst) - 1 */\r\n  uint32        throttle_events;                        /* keeps track of packet arrival values */\r\n  uint32        throttle_packet_time;                   /* time last packet was transmitted */\r\n  uint32        throttle_count;                         /* Total Throttle Delays */\r\n#if defined (USE_READER_THREAD)\r\n  int           asynch_io;                              /* Asynchronous Interrupt scheduling enabled */\r\n  int           asynch_io_latency;                      /* instructions to delay pending interrupt */\r\n  ETH_QUE       read_queue;\r\n  pthread_mutex_t     lock;\r\n  pthread_t     reader_thread;                          /* Reader Thread Id */\r\n  pthread_t     writer_thread;                          /* Writer Thread Id */\r\n  pthread_mutex_t     writer_lock;\r\n  pthread_mutex_t     self_lock;\r\n  pthread_cond_t      writer_cond;\r\n  ETH_WRITE_REQUEST *write_requests;\r\n  int write_queue_peak;\r\n  ETH_WRITE_REQUEST *write_buffers;\r\n  t_stat write_status;\r\n#endif\r\n};\r\n\r\ntypedef struct eth_device  ETH_DEV;\r\n\r\n/* prototype declarations*/\r\n\r\nt_stat eth_open   (ETH_DEV* dev, const char* name,      /* open ethernet interface */\r\n                   DEVICE* dptr, uint32 dbit);\r\nt_stat eth_close  (ETH_DEV* dev);                       /* close ethernet interface */\r\nt_stat eth_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr);\r\nt_stat eth_write  (ETH_DEV* dev, ETH_PACK* packet,      /* write synchronous packet; */\r\n                   ETH_PCALLBACK routine);              /*  callback when done */\r\nint eth_read      (ETH_DEV* dev, ETH_PACK* packet,      /* read single packet; */\r\n                   ETH_PCALLBACK routine);              /*  callback when done*/\r\nt_stat eth_filter (ETH_DEV* dev, int addr_count,        /* set filter on incoming packets */\r\n                   ETH_MAC* const addresses,\r\n                   ETH_BOOL all_multicast,\r\n                   ETH_BOOL promiscuous);\r\nt_stat eth_filter_hash (ETH_DEV* dev, int addr_count,   /* set filter on incoming packets with hash */\r\n                        ETH_MAC* const addresses,\r\n                        ETH_BOOL all_multicast,\r\n                        ETH_BOOL promiscuous,\r\n                        ETH_MULTIHASH* const hash);     /* AUTODIN II based 8 byte imperfect hash */\r\nt_stat eth_filter_hash_ex (ETH_DEV* dev, int addr_count,/* set filter on incoming packets with hash */\r\n                           ETH_MAC* const addresses,\r\n                           ETH_BOOL all_multicast,\r\n                           ETH_BOOL promiscuous,\r\n                           ETH_BOOL match_broadcast,\r\n                           ETH_MULTIHASH* const hash);  /* AUTODIN II based 8 byte imperfect hash */\r\nt_stat eth_check_address_conflict (ETH_DEV* dev,\r\n                                   ETH_MAC* const address);\r\nconst char *eth_version (void);                         /* Version of dynamically loaded library (pcap) */\r\nvoid eth_setcrc   (ETH_DEV* dev, int need_crc);         /* enable/disable CRC mode */\r\nt_stat eth_set_async (ETH_DEV* dev, int latency);       /* set read behavior to be async */\r\nt_stat eth_clr_async (ETH_DEV* dev);                    /* set read behavior to be not async */\r\nt_stat eth_set_throttle (ETH_DEV* dev, uint32 time, uint32 burst, uint32 delay); /* set transmit throttle parameters */\r\nuint32 eth_crc32(uint32 crc, const void* vbuf, size_t len); /* Compute Ethernet Autodin II CRC for buffer */\r\n\r\nvoid eth_packet_trace (ETH_DEV* dev, const uint8 *msg, int len, const char* txt); /* trace ethernet packet header+crc */\r\nvoid eth_packet_trace_ex (ETH_DEV* dev, const uint8 *msg, int len, const char* txt, int detail, uint32 reason); /* trace ethernet packet */\r\nt_stat eth_show (FILE* st, UNIT* uptr,                  /* show ethernet devices */\r\n                 int32 val, CONST void* desc);\r\nt_stat eth_show_devices (FILE* st, DEVICE *dptr,        /* show ethernet devices */\r\n                         UNIT* uptr, int32 val, CONST char* desc);\r\nint eth_devices (int max, ETH_LIST* dev, ETH_BOOL framers); /* get ethernet devices on host */\r\nvoid eth_show_dev (FILE*st, ETH_DEV* dev);              /* show ethernet device state */\r\n\r\nvoid eth_mac_fmt (ETH_MAC* const add, char* buffer);    /* format ethernet mac address */\r\nt_stat eth_mac_scan (ETH_MAC* mac, const char* strmac); /* scan string for mac, put in mac */\r\nt_stat eth_mac_scan_ex (ETH_MAC* mac,                   /* scan string for mac, put in mac */\r\n                        const char* strmac, UNIT *uptr);/* for specified unit */\r\n\r\nt_stat ethq_init (ETH_QUE* que, int max);               /* initialize FIFO queue */\r\nvoid ethq_clear  (ETH_QUE* que);                        /* clear FIFO queue */\r\nvoid ethq_remove (ETH_QUE* que);                        /* remove item from FIFO queue */\r\nvoid ethq_insert (ETH_QUE* que, int32 type,             /* insert item into FIFO queue */\r\n                  ETH_PACK* packet, int32 status);\r\nvoid ethq_insert_data(ETH_QUE* que, int32 type,         /* insert item into FIFO queue */\r\n                  const uint8 *data, int used, size_t len,\r\n                  size_t crc_len, const uint8 *crc_data, int32 status);\r\nt_stat ethq_destroy(ETH_QUE* que);                      /* release FIFO queue */\r\nconst char *eth_capabilities(void);\r\nt_stat sim_ether_test (DEVICE *dptr, const char *cptr); /* unit test routine */\r\n\r\n#if !defined(SIM_TEST_INIT)     /* Need stubs for test APIs */\r\n#define SIM_TEST_INIT\r\n#define SIM_TEST(xxx)\r\n#endif\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif                                                  /* _SIM_ETHER_H */\r\n"
        },
        {
          "name": "sim_fio.c",
          "type": "blob",
          "size": 102.1640625,
          "content": "/* sim_fio.c: simulator file I/O library\r\n\r\n   Copyright (c) 1993-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   03-Jun-11    MP      Simplified VMS 64b support and made more portable\r\n   02-Feb-11    MP      Added sim_fsize_ex and sim_fsize_name_ex returning t_addr\r\n                        Added export of sim_buf_copy_swapped and sim_buf_swap_data\r\n   28-Jun-07    RMS     Added VMS IA64 support (from Norm Lastovica)\r\n   10-Jul-06    RMS     Fixed linux conditionalization (from Chaskiel Grundman)\r\n   15-May-06    RMS     Added sim_fsize_name\r\n   21-Apr-06    RMS     Added FreeBSD large file support (from Mark Martinec)\r\n   19-Nov-05    RMS     Added OS/X large file support (from Peter Schorn)\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   17-Jul-04    RMS     Fixed bug in optimized sim_fread (reported by Scott Bailey)\r\n   26-May-04    RMS     Optimized sim_fread (suggested by John Dundas)\r\n   02-Jan-04    RMS     Split out from SCP\r\n\r\n   This library includes:\r\n\r\n   sim_finit         -       initialize package\r\n   sim_fopen         -       open file\r\n   sim_fread         -       endian independent read (formerly fxread)\r\n   sim_fwrite        -       endian independent write (formerly fxwrite)\r\n   sim_fseek         -       conditionally extended (>32b) seek (\r\n   sim_fseeko        -       extended seek (>32b if available)\r\n   sim_can_seek      -       test for seekable (regular file)\r\n   sim_fsize         -       get file size\r\n   sim_fsize_name    -       get file size of named file\r\n   sim_fsize_ex      -       get file size as a t_offset\r\n   sim_fsize_name_ex -       get file size as a t_offset of named file\r\n   sim_buf_copy_swapped -    copy data swapping elements along the way\r\n   sim_buf_swap_data -       swap data elements inplace in buffer if needed\r\n   sim_byte_swap_data -      swap data elements inplace in buffer\r\n   sim_buf_pack_unpack -     pack or unpack data between buffers\r\n   sim_shmem_open            create or attach to a shared memory region\r\n   sim_shmem_close           close a shared memory region\r\n   sim_chdir                 change working directory\r\n   sim_mkdir                 create a directory\r\n   sim_rmdir                 remove a directory\r\n   sim_getcwd                get the current working directory\r\n   sim_copyfile              copy a file\r\n   sim_filepath_parts        expand and extract filename/path parts\r\n   sim_dirscan               scan for a filename pattern\r\n   sim_get_filelist          get a list of files matching a pattern\r\n   sim_free_filelist         free a filelist\r\n   sim_print_filelist        print the elements of a filelist\r\n\r\n   sim_fopen and sim_fseek are OS-dependent.  The other routines are not.\r\n   sim_fsize is always a 32b routine (it is used only with small capacity random\r\n   access devices like fixed head disks and DECtapes).\r\n*/\r\n\r\n#define IN_SIM_FIO_C 1              /* Include from sim_fio.c */\r\n\r\n#include \"sim_defs.h\"\r\n\r\n#include \"sim_scp_private.h\"\r\n\r\nt_bool sim_end;                     /* TRUE = little endian, FALSE = big endian */\r\nt_bool sim_taddr_64;                /* t_addr is > 32b and Large File Support available */\r\nt_bool sim_toffset_64;              /* Large File (>2GB) file I/O Support available */\r\n\r\nconst char sim_file_path_separator  /* Platform specific value \\ or / as appropriate */\r\n#if defined (_WIN32)\r\n                              = '\\\\';\r\n#else\r\n                              = '/';\r\n#endif\r\n\r\n#if defined(fprintf)                /* Make sure to only use the C rtl stream I/O routines */\r\n#undef fprintf\r\n#undef fputs\r\n#undef fputc\r\n#endif\r\n\r\n#ifndef MAX\r\n#define MAX(a,b)  (((a) >= (b)) ? (a) : (b))\r\n#endif\r\n#ifndef MIN\r\n#define MIN(a,b)  (((a) <= (b)) ? (a) : (b))\r\n#endif\r\n\r\n#define FIO_DBG_PACK    1       /* Pack/Unpack Test Detail */\r\n#define FIO_DBG_SCAN    2       /* File/Directory Scan Detail */\r\n\r\nstatic DEBTAB fio_debug[] = {\r\n  {\"PACK\",     FIO_DBG_PACK,      \"Pack/Unpack Test Detail\"},\r\n  {\"SCAN\",     FIO_DBG_SCAN,      \"File/Directory Scan Detail\"},\r\n  {0}\r\n};\r\n\r\nstatic const char *sim_fio_test_description (DEVICE *dptr)\r\n{\r\nreturn \"SCP FIO Testing\";\r\n}\r\n\r\nstatic UNIT sim_fio_unit = { 0 };\r\n\r\nstatic DEVICE sim_fio_test_dev = {\r\n    \"SCP-FIO\", &sim_fio_unit, NULL, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE|DEV_DEBUG, 0,\r\n    fio_debug, NULL, NULL, NULL, NULL, NULL,\r\n    sim_fio_test_description};\r\n\r\n/* OS-independent, endian independent binary I/O package\r\n\r\n   For consistency, all binary data read and written by the simulator\r\n   is stored in little endian data order.  That is, in a multi-byte\r\n   data item, the bytes are written out right to left, low order byte\r\n   to high order byte.  On a big endian host, data is read and written\r\n   from high byte to low byte.  Consequently, data written on a little\r\n   endian system must be byte reversed to be usable on a big endian\r\n   system, and vice versa.\r\n\r\n   These routines are analogs of the standard C runtime routines\r\n   fread and fwrite.  If the host is little endian, or the data items\r\n   are size char, then the calls are passed directly to fread or\r\n   fwrite.  Otherwise, these routines perform the necessary byte swaps.\r\n   Sim_fread swaps in place, sim_fwrite uses an intermediate buffer.\r\n*/\r\n\r\nint32 sim_finit (void)\r\n{\r\nunion {int32 i; char c[sizeof (int32)]; } end_test;\r\n\r\nend_test.i = 1;                                         /* test endian-ness */\r\nsim_end = (end_test.c[0] != 0);\r\nsim_toffset_64 = (sizeof(t_offset) > sizeof(int32));    /* Large File (>2GB) support */\r\nsim_taddr_64 = sim_toffset_64 && (sizeof(t_addr) > sizeof(int32));\r\nreturn sim_end;\r\n}\r\n\r\n/* Copy little endian data to local buffer swapping if needed */\r\nvoid sim_buf_swap_data (void *bptr, size_t size, size_t count)\r\n{\r\nif (sim_end || (count == 0) || (size == sizeof (char)))\r\n    return;\r\nsim_byte_swap_data (bptr, size, count);\r\n}\r\n\r\nvoid sim_byte_swap_data (void *bptr, size_t size, size_t count)\r\n{\r\nuint32 j;\r\nint32 k;\r\nunsigned char by, *sptr, *dptr;\r\n\r\nif (sim_end || (count == 0) || (size == sizeof (char)))\r\n    return;\r\nfor (j = 0, dptr = sptr = (unsigned char *) bptr;       /* loop on items */\r\n     j < count; j++) {\r\n    for (k = (int32)(size - 1); k >= (((int32) size + 1) / 2); k--) {\r\n        by = *sptr;                                     /* swap end-for-end */\r\n        *sptr++ = *(dptr + k);\r\n        *(dptr + k) = by;\r\n        }\r\n    sptr = dptr = dptr + size;                          /* next item */\r\n    }\r\n}\r\n\r\nsize_t sim_fread (void *bptr, size_t size, size_t count, FILE *fptr)\r\n{\r\nsize_t c;\r\n\r\nif ((size == 0) || (count == 0))                        /* check arguments */\r\n    return 0;\r\nc = fread (bptr, size, count, fptr);                    /* read buffer */\r\nif (sim_end || (size == sizeof (char)) || (c == 0))     /* le, byte, or err? */\r\n    return c;                                           /* done */\r\nsim_buf_swap_data (bptr, size, c);\r\nreturn c;\r\n}\r\n\r\nvoid sim_buf_copy_swapped (void *dbuf, const void *sbuf, size_t size, size_t count)\r\n{\r\nsize_t j;\r\nint32 k;\r\nconst unsigned char *sptr = (const unsigned char *)sbuf;\r\nunsigned char *dptr = (unsigned char *)dbuf;\r\n\r\nif (sim_end || (size == sizeof (char))) {\r\n    memcpy (dptr, sptr, size * count);\r\n    return;\r\n    }\r\nfor (j = 0; j < count; j++) {                           /* loop on items */\r\n    for (k = (int32)(size - 1); k >= 0; k--)\r\n        *(dptr + k) = *sptr++;\r\n    dptr = dptr + size;\r\n    }\r\n}\r\n\r\nstatic uint32 _bit_index (uint32 bit, uint32 bits, t_bool LSB)\r\n{\r\nuint32 base, offset;\r\n\r\nif (LSB)\r\n    return bit;\r\n//return (bits * (bit / bits)) + bits - ((bit % bits) + 1); /* Reverse bit ordering - likely not useful */\r\nbase = (bits * (bit / bits)) - (((bits % 8) == 0) ? 8 : 0);\r\noffset = ((base / bits) * (bits % 8));\r\nbit = (bit % bits) + offset;\r\nreturn base + (bits - (((bit + (bits % 8)) / 8) * 8) - (bits % 8)) + offset + ((bit + (bits % 8)) % 8);\r\n}\r\n\r\nt_bool sim_buf_pack_unpack (const void *sptr,          /* source buffer pointer */\r\n                            void *dptr,                /* destination buffer pointer */\r\n                            uint32 sbits,              /* source buffer element size in bits */\r\n                            t_bool sLSB_o_numbering,   /* source numbered using LSB ordering */\r\n                            uint32 scount,             /* count of source elements */\r\n                            uint32 dbits,              /* interesting bits of each destination element */\r\n                            t_bool dLSB_o_numbering)   /* destination numbered using LSB ordering */\r\n{\r\nconst uint8 *s = (const uint8 *)sptr;\r\nuint8 *d = (uint8 *)dptr;\r\nuint32 bits_to_process;         /* bits in current source element remaining to be processed */\r\nuint32 sbit_offset, dbit_offset;/* source and destination bit offsets */\r\nuint32 sx;                      /* source byte index */\r\nuint32 dx;                      /* destination byte index */\r\nuint32 bit;                     /* Current Bit number */\r\nuint32 element;                 /* Current element number */\r\n\r\nsim_debug (FIO_DBG_PACK, &sim_fio_test_dev, \"sim_buf_pack_unpack(sbits=%d, dLSB_o=%s, scount=%d, dbits=%d, dLSB_o=%s)\\n\", sbits, sLSB_o_numbering ? \"True\" : \"False\", scount, dbits, dLSB_o_numbering ? \"True\" : \"False\");\r\nif (((dbits * scount) & 7) != 0)\r\n    return TRUE;                    /* Error - Can't process all source elements */\r\nmemset (d, 0, (dbits * scount) >> 3);\r\n\r\nif (((sbits % 8) == 0)                  &&\r\n    (sbits == dbits)                    &&\r\n    (sLSB_o_numbering == dLSB_o_numbering)) {\r\n    sim_buf_copy_swapped (dptr, sptr, sbits >> 3, scount);\r\n    return FALSE;\r\n    }\r\nbits_to_process = MIN (sbits, dbits);\r\nfor (element = 0; element < scount; element++) {\r\n    sbit_offset = element * sbits;\r\n    dbit_offset = element * dbits;\r\n    for (bit = 0; bit < bits_to_process; bit++, sbit_offset++, dbit_offset++) {\r\n        sx = _bit_index (sbit_offset, sbits, sLSB_o_numbering);\r\n        dx = _bit_index (dbit_offset, dbits, dLSB_o_numbering);\r\n        d[dx >> 3] |= (((s[sx >> 3] >> (sx & 7)) & 1) << (dx & 7));\r\n        }\r\n    }\r\nreturn FALSE;\r\n}\r\n\r\nsize_t sim_fwrite (const void *bptr, size_t size, size_t count, FILE *fptr)\r\n{\r\nsize_t c, nelem, nbuf, lcnt, total;\r\nint32 i;\r\nconst unsigned char *sptr;\r\nunsigned char *sim_flip;\r\n\r\nif ((size == 0) || (count == 0))                        /* check arguments */\r\n    return 0;\r\nif (sim_end || (size == sizeof (char)))                 /* le or byte? */\r\n    return fwrite (bptr, size, count, fptr);            /* done */\r\nsim_flip = (unsigned char *)malloc(FLIP_SIZE);\r\nif (!sim_flip)\r\n    return 0;\r\nnelem = FLIP_SIZE / size;                               /* elements in buffer */\r\nnbuf = count / nelem;                                   /* number buffers */\r\nlcnt = count % nelem;                                   /* count in last buf */\r\nif (lcnt) nbuf = nbuf + 1;\r\nelse lcnt = nelem;\r\ntotal = 0;\r\nsptr = (const unsigned char *) bptr;                    /* init input ptr */\r\nfor (i = (int32)nbuf; i > 0; i--) {                     /* loop on buffers */\r\n    c = (i == 1)? lcnt: nelem;\r\n    sim_buf_copy_swapped (sim_flip, sptr, size, c);\r\n    sptr = sptr + size * count;\r\n    c = fwrite (sim_flip, size, c, fptr);\r\n    if (c == 0) {\r\n        free(sim_flip);\r\n        return total;\r\n        }\r\n    total = total + c;\r\n    }\r\nfree(sim_flip);\r\nreturn total;\r\n}\r\n\r\n/* Forward Declaration */\r\n\r\nt_offset sim_ftell (FILE *st);\r\nstatic int _sim_filename_compare (const char *filename1, const char *filename2);\r\nstatic void _flush_filelist_directory_cache_entry (const char *directory);\r\n\r\n/* Get file size */\r\n\r\nt_offset sim_fsize_ex (FILE *fp)\r\n{\r\nt_offset pos, sz;\r\n\r\nif (fp == NULL)\r\n    return 0;\r\npos = sim_ftell (fp);\r\nif (sim_fseeko (fp, 0, SEEK_END))\r\n    return 0;\r\nsz = sim_ftell (fp);\r\nif (sim_fseeko (fp, pos, SEEK_SET))\r\n    return 0;\r\nreturn sz;\r\n}\r\n\r\nt_offset sim_fsize_name_ex (const char *fname)\r\n{\r\nFILE *fp;\r\nt_offset sz;\r\n\r\nif ((fp = sim_fopen (fname, \"rb\")) == NULL)\r\n    return 0;\r\nsz = sim_fsize_ex (fp);\r\nfclose (fp);\r\nreturn sz;\r\n}\r\n\r\nuint32 sim_fsize_name (const char *fname)\r\n{\r\nreturn (uint32)(sim_fsize_name_ex (fname));\r\n}\r\n\r\nuint32 sim_fsize (FILE *fp)\r\n{\r\nreturn (uint32)(sim_fsize_ex (fp));\r\n}\r\n\r\nt_bool sim_can_seek (FILE *fp)\r\n{\r\nstruct stat statb;\r\n\r\nif ((0 != fstat (fileno (fp), &statb)) ||\r\n    (0 == (statb.st_mode & S_IFREG)))\r\n    return FALSE;\r\nreturn TRUE;\r\n}\r\n\r\n\r\n\r\n#if defined(_WIN32)\r\n#include <direct.h>\r\n#include <io.h>\r\n#include <fcntl.h>\r\n#else\r\n#include <unistd.h>\r\n#endif\r\n\r\nstatic char *_sim_expand_homedir (const char *file, char *dest, size_t dest_size)\r\n{\r\nchar *without_quotes = NULL;\r\n\r\nerrno = 0;\r\nif (((*file == '\"') && (file[strlen (file) - 1] == '\"')) ||\r\n    ((*file == '\\'') && (file[strlen (file) - 1] == '\\''))) {\r\n    size_t offset = 1;\r\n    const char *end = &file[strlen (file) - 1];\r\n    char quote = *file;\r\n\r\n    without_quotes = (char *)malloc (strlen (file) + 1);\r\n    if (without_quotes == NULL)\r\n        return NULL;\r\n    strcpy (without_quotes, file + 1);\r\n    without_quotes[strlen (without_quotes) - 1] = '\\0';\r\n    file = (const char*)without_quotes;\r\n}\r\n\r\nif (memcmp (file, \"~/\", 2) != 0)\r\n    strlcpy (dest, file, dest_size);\r\nelse {\r\n    char *cptr = getenv(\"HOME\");\r\n    char *cptr2;\r\n\r\n    if (cptr == NULL) {\r\n        cptr = getenv(\"HOMEPATH\");\r\n        cptr2 = getenv(\"HOMEDRIVE\");\r\n        }\r\n    else\r\n        cptr2 = NULL;\r\n    if (cptr && (dest_size > strlen (cptr) + strlen (file) + 3))\r\n        snprintf(dest, dest_size, \"%s%s%s%s\", cptr2 ? cptr2 : \"\", cptr, strchr (cptr, '/') ? \"/\" : \"\\\\\", file + 2);\r\n    else\r\n        strlcpy (dest, file, dest_size);\r\n    while ((strchr (dest, '\\\\') != NULL) && ((cptr = strchr (dest, '/')) != NULL))\r\n        *cptr = '\\\\';\r\n    }\r\nfree (without_quotes);\r\nreturn dest;\r\n}\r\n\r\n/*\r\n *  DBD9 packing/encoding is:\r\n *          9 character per pair of 36 bit words.\r\n *\r\n *    36b   Bit numbers using              bit\r\n *   word   standard bit numbering   byte  offset\r\n *      0 - 35 34 33 32 31 30 29 28     0     0\r\n *      0 - 27 26 25 24 23 22 21 20     1     8\r\n *      0 - 19 18 17 16 15 14 13 12     2    16\r\n *      0 - 11 10  9  8  7  6  5  4     3    24\r\n *      0 -  3  2  1  0 35 34 33 32     4    32\r\n *      1 - 31 30 29 28 27 26 25 24     5    40\r\n *      1 - 23 22 21 20 19 18 17 16     6    48\r\n *      1 - 15 14 13 12 11 10  9  8     7    56\r\n *      1 -  7  6  5  4  3  2  1  0     8    64\r\n *\r\n *   word   Bit numbers using PDP10 bit numbering\r\n *      0 - B0  1  2  3  4  5  6  7\r\n *      0 -  8  9 10 11 12 13 14 15\r\n *      0 - 16 17 18 19 20 21 22 23\r\n *      0 - 24 25 26 27 28 29 30 31\r\n *      0 - 32 33 34 35 B0  1  2  3\r\n *      1 -  4  5  6  7  8  9 10 11\r\n *      1 - 12 13 14 15 16 17 18 19\r\n *      1 - 20 21 22 23 24 25 26 27\r\n *      1 - 28 29 30 31 32 33 34 35\r\n *\r\n *  DLD9 packing/encoding is:\r\n *          9 character per pair of 36 bit words.\r\n *\r\n *    36b   Bit numbers using              bit\r\n *   word   standard bit numbering   byte  offset\r\n *      0 -  7  6  5  4  3  2  1  0     0     0\r\n *      0 - 15 14 13 12 11 10  9  8     1     8\r\n *      0 - 23 22 21 20 19 18 17 16     2    16\r\n *      0 - 31 30 29 28 27 26 25 24     3    24\r\n *      0 -  3  2  1  0 35 34 33 32     4    32\r\n *      1 - 11 10  9  8  7  6  5  4     5    40\r\n *      1 - 19 18 17 16 15 14 13 12     6    48\r\n *      1 - 27 26 25 24 23 22 21 20     7    56\r\n *      1 - 35 34 33 32 31 30 29 28     8    64\r\n *\r\n *   word   Bit numbers using PDP10 bit numbering\r\n *      0 - 28 29 30 31 32 33 34 35\r\n *      0 - 20 21 22 23 24 25 26 27\r\n *      0 - 12 13 14 15 16 17 18 19\r\n *      0 -  4  5  6  7  8  9 10 11\r\n *      0 - 32 33 34 35 B0  1  2  3\r\n *      1 - 24 25 26 27 28 29 30 31\r\n *      1 - 16 17 18 19 20 21 22 23\r\n *      1 -  8  9 10 11 12 13 14 15\r\n *      1 - B0  1  2  3  4  5  6  7\r\n */\r\n\r\nuint32 int32_data[] = {  0x00000000,  0x00000001,  0x00000002,  0x00000003,\r\n                         0x00000004,  0x00000005,  0x00000006,  0x00000007,\r\n                         0x00000008,  0x00000009,  0x0000000A,  0x0000000B,\r\n                         0x0000000C,  0x0000000D,  0x0000000E,  0x0000000F};\r\nuint32 res_32bitM[] = {  0x00000000,  0x01000000,  0x02000000,  0x03000000,\r\n                         0x04000000,  0x05000000,  0x06000000,  0x07000000,\r\n                         0x08000000,  0x09000000,  0x0A000000,  0x0B000000,\r\n                         0x0C000000,  0x0D000000,  0x0E000000,  0x0F000000};\r\nuint32 res_32_1[] =   {  0,  1,  0,  1,\r\n                         0,  1,  0,  1,\r\n                         0,  1,  0,  1,\r\n                         0,  1,  0,  1};\r\nuint16 int16_data[] = { 0x1234, 0x5678,\r\n                        0x9ABC, 0xDEF0};\r\nuint16 res_16bit[] =  { 0x3412, 0x7856,\r\n                        0xBC9A, 0xF0DE};\r\nuint8 res_8bit[] = {  0,  1,  2,  3,\r\n                      4,  5,  6,  7,\r\n                      8,  9, 10, 11,\r\n                     12, 13, 14, 15};\r\nuint8 res_4bit[] = {  0x10,  0x32, 0x54, 0x76,\r\n                      0x98,  0xba, 0xdc, 0xfe};\r\nuint8 res_2bit[] = {  0xE4,  0xE4, 0xE4, 0xE4};\r\nuint8 res_1bit[] = {  0xAA,  0xAA};\r\n#if defined (USE_INT64)\r\nt_uint64 int64_data[] = { 0x876543210, 0x012345678, 0x987654321, 0x123456789};\r\nuint8 res_36bit[] = {0x10, 0x32, 0x54, 0x76, 0x88, 0x67, 0x45, 0x23, 0x01,\r\n                     0x21, 0x43, 0x65, 0x87, 0x99, 0x78, 0x56, 0x34, 0x12};\r\nuint8 res_36bitM[]= {0x87, 0x65, 0x43, 0x21, 0x00, 0x12, 0x34, 0x56, 0x78,\r\n                     0x98, 0x76, 0x54, 0x32, 0x11, 0x23, 0x45, 0x67, 0x89};\r\nuint8 int64_data_dbd9[18];\r\nuint8 int64_data_dld9[18];\r\n#endif\r\n\r\nstatic struct pack_test {\r\n    const void *src;\r\n    const void *exp_dst;\r\n    uint32      sbits;\r\n    t_bool      slsb;\r\n    uint32      dbits;\r\n    t_bool      dlsb;\r\n    uint32      scount;\r\n    t_bool      exp_stat;\r\n    } p_test[] = {\r\n#if defined (USE_INT64)\r\n        {&int64_data, &res_36bitM, 64, TRUE,  36, FALSE, 4,  FALSE},\r\n        {&res_36bitM, &int64_data, 36, FALSE, 64, TRUE,  4,  FALSE},\r\n        {&int64_data, &res_36bit,  64, TRUE,  36, TRUE,  4,  FALSE},\r\n        {&res_36bit,  &int64_data, 36, TRUE,  64, TRUE,  4,  FALSE},\r\n#endif\r\n        {&int16_data, &res_16bit,  16, TRUE,  16, FALSE, 4,  FALSE},\r\n        {&int16_data, &res_16bit,  16, FALSE, 16, TRUE,  4,  FALSE},\r\n        {&int16_data, &int16_data, 16, TRUE,  16, TRUE,  4,  FALSE},\r\n        {&int16_data, &int16_data, 16, FALSE, 16, FALSE, 4,  FALSE},\r\n        {&int32_data, &int32_data, 32, FALSE, 32, FALSE,16,  FALSE},\r\n        {&int32_data, &int32_data, 32, TRUE,  32, TRUE, 16,  FALSE},\r\n        {&int32_data, &res_32bitM, 32, TRUE,  32, FALSE,16,  FALSE},\r\n        {&res_32bitM, &int32_data, 32, FALSE, 32, TRUE, 16,  FALSE},\r\n        {&res_8bit,   &res_8bit,    8, TRUE,   8, FALSE,16,  FALSE},\r\n        {&res_8bit,   &res_8bit,    8, FALSE,  8, TRUE, 16,  FALSE},\r\n        {&res_8bit,   &res_8bit,    8, FALSE,  8, FALSE,16,  FALSE},\r\n        {&res_8bit,   &res_8bit,    8, TRUE,   8, TRUE, 16,  FALSE},\r\n        {&res_8bit,   &res_8bit,   16, TRUE,  16, TRUE,  8,  FALSE},\r\n        {&res_8bit,   &res_8bit,   16, FALSE, 16, FALSE, 8,  FALSE},\r\n        {&res_1bit,   &res_32_1,    1, TRUE,  32, TRUE, 16,  FALSE},\r\n        {&res_8bit,   &int32_data,  8, TRUE,  32, TRUE,  2,  FALSE},\r\n        {&res_4bit,   &int32_data,  4, TRUE,  32, TRUE, 16,  FALSE},\r\n        {&int32_data, &res_8bit,   32, TRUE,   8, TRUE, 16,  FALSE},\r\n        {&int32_data, &int32_data, 32, TRUE,  32, TRUE, 16,  FALSE},\r\n        {&int32_data, &int32_data, 16, TRUE,  16, TRUE, 32,  FALSE},\r\n        {&int32_data, &int32_data,  8, TRUE,   8, TRUE, 64,  FALSE},\r\n        {&int32_data, &res_8bit,   32, TRUE,   8, TRUE, 16,  FALSE},\r\n        {&int32_data, &res_4bit,   32, TRUE,   4, TRUE, 16,  FALSE},\r\n        {&int32_data, &res_2bit,   32, TRUE,   2, TRUE, 16,  FALSE},\r\n        {&int32_data, &res_1bit,   32, TRUE,   1, TRUE, 16,  FALSE},\r\n        {NULL},\r\n        };\r\n\r\n\r\n\r\nstatic struct relative_path_test {\r\n    const char  *input;\r\n    t_bool      prepend_orig_cwd;\r\n    const char  *working_dir;\r\n    t_bool      prepend_working_cwd;\r\n    const char  *extra_dir;\r\n    const char  *result;\r\n    } r_test[] = {\r\n        {\"../../../xyzz/*\",         FALSE, \"xya/b/c\", TRUE,  \"xyzz\",   \"../../../xyzz/*\"},\r\n        {\"../xyzz/*\",               FALSE, \"xya/b/c\", FALSE, \"xyzz\",  \"../xyzz/*\"},\r\n        {\"/xx.dat\",                 TRUE,  \"xx\",      FALSE, NULL,     \"../xx.dat\"},\r\n        {\"/file.dat\",               TRUE,  \"xx/t\",    FALSE, NULL,     \"../../file.dat\"},\r\n        {\"/../../xxx/file.dat\",     TRUE,  NULL,      FALSE, NULL,     \"../../xxx/file.dat\"},\r\n        {\"\\\\..\\\\..\\\\xxx\\\\file.dat\", TRUE,  NULL,      FALSE, NULL,     \"../../xxx/file.dat\"},\r\n        {\"file.dat\",                FALSE, NULL,      FALSE, NULL,     \"./file.dat\"},\r\n        {\"\\\\file.dat\",              TRUE,  NULL,      FALSE, NULL,     \"./file.dat\"},\r\n        {\"C:/XXX/yyy/file.dat\",     FALSE, NULL,      FALSE, NULL,     \"C:/XXX/yyy/file.dat\"},\r\n        {\"C:/Users/yyy/file.dat\",   FALSE, NULL,      FALSE, NULL,     \"C:/Users/yyy/file.dat\"},\r\n        {\"W:/XXX/yyy/file.dat\",     FALSE, NULL,      FALSE, NULL,     \"W:/XXX/yyy/file.dat\"},\r\n        {\"/file.dat\",               TRUE,  NULL,      FALSE, NULL,     \"./file.dat\"},\r\n        {\"/x/filepath/file.dat\",    FALSE, NULL,      FALSE, NULL,     \"/x/filepath/file.dat\"},\r\n        {NULL},\r\n        };\r\n\r\nstatic struct filename_compare_test {\r\n    const char *testname;\r\n    const char *filename1;\r\n    const char *filename2;\r\n    int         expected_result;\r\n    } name_compare_test[] = {\r\n        {\"name-equal-drive letter different case\",\r\n         \"C:\\\\Xyz\\\\zzz.x\",\r\n         \"c:\\\\Xyz\\\\zzz.x\",\r\n         0},\r\n        {\"name-diff-drive letter different\",\r\n         \"C:\\\\Xyz\\\\zzz.x\",\r\n         \"E:\\\\Xyz\\\\zzz.x\",\r\n         -1},\r\n        {\"name-diff-drive letter different-vs-path\",\r\n         \"C:\\\\Xyz\\\\zzz.x\",\r\n         \"\\\\Xyz\\\\zzz.x\",\r\n         -1},\r\n        {\"name-equal-separator-different-2\",\r\n         \"C:/Xyz/zzz.x\",\r\n         \"c:\\\\Xyz\\\\zzz.x\",\r\n#if defined(_WIN32)\r\n         2},\r\n#else\r\n         1},\r\n#endif\r\n        {\"name-equal-separator-different-1\",\r\n         \"c:\\\\Xyz\\\\zzz.x\",\r\n         \"C:/Xyz/zzz.x\",\r\n#if defined(_WIN32)\r\n         1},\r\n#else\r\n         2},\r\n#endif\r\n        {\"name-different-equal-path-diff-filename\",\r\n         \"/a/b/cdd/dzzz.x\",\r\n         \"/a/b/cdd/zzzz.x\",\r\n         -1},\r\n        {\"name-diff-nostarting-separator\",\r\n         \"a/b/cdd/dzzz.x\",\r\n         \"a/b/cdd/zzzz.x\",\r\n         -1},\r\n        {\"name-equal-nostarting-separator\",\r\n         \"a/b/cdd/dzzz.x\",\r\n         \"a/b/cdd/dzzz.x\",\r\n         0},\r\n        {\"name-equal-noseparator\",\r\n         \"zzz.x\",\r\n         \"zzz.x\",\r\n         0},\r\n        {\"name-diff-nostarting-separator\",\r\n         \"a/b/cdd/dzzz.x\",\r\n         \"abcddzzzz.x\",\r\n         -1},\r\n        {\"name-diff-nostarting-same-length\",\r\n         \"abcddzzzz.x/b/cdd/dzzz.x\",\r\n         \"abcddzzzz.x\",\r\n         -1},\r\n        {\"name-diff-nostarting-same-length-firsttoken\",\r\n         \"abcde.x/b/cdd/dzzz.x\",\r\n         \"abcde.x\",\r\n         -1},\r\n        {NULL},\r\n        };\r\n\r\nstatic struct get_filelist_test {\r\n    const char *name;\r\n    const char  *files[10];\r\n    const char *search;\r\n    int         expected_count;\r\n   } get_test[] = {\r\n        {\"test-single file in subdirectory\",\r\n         {\"a0a/file.txt\",\r\n          NULL},\r\n         \"file.txt\", 1},\r\n        {\"test-similar deep file names\",\r\n         {\"aab/bbc/ccd/eef/file.txt\",\r\n          \"aab/bbc/ccd/eef/file2.txt\",\r\n          \"aac/bbd/cce/eef/file2.txt\",\r\n          NULL},\r\n         \"file.txt\", 1},\r\n        {\"test-single file no subdirectories\",\r\n         {\"file.txt\",\r\n          NULL},\r\n         \"file.txt\", 1},\r\n        {\"test-3 text files in the same 4 deep subdirectory\",\r\n         {\"aab/bbc/ccd/eef/file.txt\",\r\n          \"aab/bbc/ccd/eef/file2.txt\",\r\n          \"aac/bbd/cce/eef/file2.txt\",\r\n          NULL},\r\n         \"*.txt\", 3},\r\n        {\"test-2 text files\",\r\n         {\"xab/bbc/ccd/eef/file.txt\",\r\n          \"xab/bbc/ccd/eef/file2.bbb\",\r\n          \"xac/bbd/cce/eef/file2.txt\",\r\n          NULL},\r\n         \"*.txt\", 2},\r\n        {NULL},\r\n    };\r\n\r\n#if !defined (NO_FIO_TEST_CODE)\r\n\r\nt_stat sim_fio_test (const char *cptr)\r\n{\r\nstruct pack_test *pt;\r\nstruct relative_path_test *rt;\r\nstruct filename_compare_test *nt;\r\nstruct get_filelist_test *gt;\r\nt_stat r = SCPE_OK;\r\nchar test_desc[512];\r\nuint8 result[512];\r\nint tests;\r\n\r\nsim_register_internal_device (&sim_fio_test_dev);\r\nsim_fio_test_dev.dctrl |= (sim_switches & SWMASK ('D')) ? FIO_DBG_PACK : 0;\r\nsim_fio_test_dev.dctrl |= (sim_switches & SWMASK ('S')) ? FIO_DBG_SCAN : 0;\r\nsim_set_deb_switches (SWMASK ('F'));\r\nsim_messagef (SCPE_OK, \"*** Running sim_buf_pack_unpack - tests\\n\");\r\nfor (pt = p_test, tests = 0; pt->src; ++pt) {\r\n    t_bool res;\r\n\r\n    ++tests;\r\n    snprintf (test_desc, sizeof (test_desc), \"%dbit%s->%dbit%s %d words\", pt->sbits, pt->slsb ? \"LSB\" : \"MSB\", pt->dbits, pt->dlsb ? \"LSB\" : \"MSB\", pt->scount);\r\n    memset (result, 0x80, sizeof (result));\r\n    res = sim_buf_pack_unpack (pt->src, result, pt->sbits, pt->slsb, pt->scount, pt->dbits, pt->dlsb);\r\n    if (res == pt->exp_stat) {\r\n        if (!res) {\r\n            if (0 == memcmp (pt->exp_dst, result, (pt->scount * pt->dbits) / 8))\r\n                sim_messagef (SCPE_OK, \"%s - GOOD\\n\", test_desc);\r\n            else {\r\n                uint32 i;\r\n\r\n                r = sim_messagef (SCPE_IERR, \"%s - BAD Data:\\n\", test_desc);\r\n                sim_messagef (SCPE_IERR, \"Off: Exp:    Got:\\n\");\r\n                for (i = 0; i < ((pt->scount * pt->dbits) / 8); i++)\r\n                    sim_messagef (SCPE_IERR, \"%3d  0x%02X%s0x%02X\\n\", i, ((uint8 *)pt->exp_dst)[i], (((uint8 *)pt->exp_dst)[i] == result[i]) ? \"    \" : \" != \", result[i]);\r\n                }\r\n            }\r\n        }\r\n    else\r\n        r = sim_messagef (SCPE_IERR, \"%s - BAD Status - Expected: %s got %s\\n\", test_desc, pt->exp_stat ? \"True\" : \"False\", res ? \"True\" : \"False\");\r\n    }\r\nif (r != SCPE_OK)\r\n    return r;\r\nsim_messagef (SCPE_OK, \"*** All %d sim_buf_pack_unpack tests GOOD\\n\", tests);\r\nsim_messagef (SCPE_OK, \"*** Testing relative path logic:\\n\");\r\nfor (rt = r_test, tests = 0; rt->input; ++rt) {\r\n    char input[PATH_MAX + 1];\r\n    char cmpbuf[PATH_MAX + 1];\r\n    char cwd[PATH_MAX + 1];\r\n    char origcwd[PATH_MAX + 1];\r\n    char *wd = sim_getcwd(cwd, sizeof (cwd));\r\n    char *cp;\r\n    const char *result;\r\n    static const char seperators[] = \"/\\\\\";\r\n    const char *sep;\r\n    t_stat mkdir_stat = SCPE_OK;\r\n\r\n    ++tests;\r\n    strlcpy (origcwd, cwd, sizeof (origcwd));\r\n    if (rt->extra_dir != NULL)\r\n        mkdir_stat = mkdir_cmd (0, rt->extra_dir);\r\n    if (rt->working_dir != NULL) {\r\n        mkdir_stat = mkdir_cmd (0, rt->working_dir);\r\n        sim_chdir (rt->working_dir);\r\n        wd = sim_getcwd(cwd, sizeof (cwd));\r\n        }\r\n    if (rt->prepend_orig_cwd) {\r\n        strlcpy (input, origcwd, sizeof (input));\r\n        strlcat (input, \"/\", sizeof (input));\r\n        strlcat (input, rt->input, sizeof (input));\r\n        }\r\n    else {\r\n        if (rt->prepend_working_cwd) {\r\n            strlcpy (input, cwd, sizeof (input));\r\n            strlcat (input, \"/\", sizeof (input));\r\n            strlcat (input, rt->input, sizeof (input));\r\n            }\r\n        else\r\n            strlcpy (input, rt->input, sizeof (input));\r\n        }\r\n    for (sep = seperators; *sep != '\\0'; ++sep) {\r\n        while ((cp = strchr (input, *sep)))\r\n            *cp = (*sep == '/') ? '\\\\' : '/';\r\n        while ((cp = strchr (cwd, *sep)))\r\n            *cp = (*sep == '/') ? '\\\\' : '/';\r\n        result = sim_relative_path (input);\r\n        strlcpy (cmpbuf, rt->result, sizeof (cmpbuf));\r\n        if (strchr (input, *sep) != NULL) {         /* Input has separators? */\r\n            while ((cp = strchr (cmpbuf, *sep)))\r\n                *cp = (*sep == '/') ? '\\\\' : '/';   /* Change the expected result to match */\r\n            }\r\n        if (strcmp (result, cmpbuf) != 0) {\r\n            r = sim_messagef (SCPE_IERR, \"Relative Path Unexpected Result:\\n\");\r\n            sim_messagef (SCPE_IERR, \"    input: %s\\n\", input);\r\n            sim_messagef (SCPE_IERR, \"   result: %s\\n\", result);\r\n            sim_messagef (SCPE_IERR, \" expected: %s\\n\", cmpbuf);\r\n            sim_messagef (SCPE_IERR, \"      cwd: %s\\n\", cwd);\r\n            }\r\n        else {\r\n            sim_messagef (SCPE_OK, \"Relative Path Good Result:\\n\");\r\n            sim_messagef (SCPE_OK, \"    input: %s\\n\", input);\r\n            sim_messagef (SCPE_OK, \"   result: %s\\n\", result);\r\n            }\r\n        }\r\n    sim_chdir (origcwd);\r\n    if ((rt->extra_dir != NULL) && (mkdir_stat == SCPE_OK)) {\r\n        char *xdir = strdup (rt->extra_dir);\r\n\r\n        sim_rmdir (rt->extra_dir);\r\n        while ((cp = strrchr (xdir, '/')) != NULL) {\r\n            *cp = '\\0';\r\n            sim_rmdir (xdir);\r\n            }\r\n        free (xdir);\r\n        }\r\n    if ((rt->working_dir != NULL) && (mkdir_stat == SCPE_OK)) {\r\n        char *xdir = strdup (rt->working_dir);\r\n\r\n        sim_rmdir (rt->working_dir);\r\n        while ((cp = strrchr (xdir, '/')) != NULL) {\r\n            *cp = '\\0';\r\n            sim_rmdir (xdir);\r\n            }\r\n        free (xdir);\r\n        }\r\n    }\r\nif (r != SCPE_OK)\r\n    return r;\r\nsim_messagef (SCPE_OK, \"*** All %d relative path logic tests GOOD\\n\", tests);\r\nsim_messagef (SCPE_OK, \"*** Testing filename compare:\\n\");\r\nfor (nt = name_compare_test, tests = 0; nt->testname; ++nt) {\r\n    int result;\r\n\r\n    ++tests;\r\n    result = _sim_filename_compare (nt->filename1, nt->filename2);\r\n    if (result != nt->expected_result) {\r\n        sim_messagef (SCPE_IERR, \"Name Compare test %d %s\\n\", tests, nt->testname);\r\n        sim_messagef (SCPE_IERR, \"    filename1: %s\\n\", nt->filename1);\r\n        sim_messagef (SCPE_IERR, \"    filename2: %s\\n\", nt->filename2);\r\n        r = sim_messagef (SCPE_IERR, \"    BAD result: %d\\n\", result);\r\n        }\r\n    }\r\nif (r != SCPE_OK)\r\n    return r;\r\nsim_messagef (SCPE_OK, \"*** All %d filename compare tests GOOD\\n\", tests);\r\nsim_messagef (SCPE_OK, \"*** Testing sim_get_filelist:\\n\");\r\nfor (gt = get_test, tests = 0; gt->name; ++gt) {\r\n    char xpath[PATH_MAX + 1];\r\n    int i;\r\n    char **filelist;\r\n\r\n    ++tests;\r\n    sim_messagef (r, \"FileList test %s\\n\", gt->name);\r\n    for (i=0; gt->files[i]; ++i) {\r\n        char *c, *end;\r\n        char *filename = sim_filepath_parts (gt->files[i], \"nx\");\r\n\r\n        sim_messagef (r, \"Creating: %s\\n\", gt->files[i]);\r\n        snprintf (xpath, sizeof (xpath), \"testfiles/%s\", gt->files[i]);\r\n        end = strrchr (xpath, '/');\r\n        *end = '\\0';\r\n        c = xpath;\r\n        while ((c = strchr (c, '/'))) {\r\n            *c = '\\0';\r\n            sim_mkdir (xpath);\r\n            *c++ = '/';\r\n            }\r\n        sim_mkdir (xpath);\r\n        *end = '/';\r\n        fclose (fopen (xpath, \"w\"));\r\n        free (filename);\r\n        }\r\n    sim_chdir (\"testfiles\");\r\n    snprintf (xpath, sizeof (xpath), \"%s\", gt->search);\r\n    filelist = sim_get_filelist (xpath);\r\n    sim_chdir (\"..\");\r\n    r |= sim_messagef ((gt->expected_count != sim_count_filelist (filelist)) ? SCPE_IERR : SCPE_OK,\r\n                      \"sim_get_filelist (\\\"%s\\\") yielded %d entries, expected %d entries:\\n\", xpath, sim_count_filelist (filelist), gt->expected_count);\r\n    sim_print_filelist (filelist);\r\n    sim_free_filelist (&filelist);\r\n    /* Cleanup created test files and directories */\r\n    for (i=0; gt->files[i]; ++i) {\r\n        char *c;\r\n        char *filename = sim_filepath_parts (gt->files[i], \"nx\");\r\n        snprintf (xpath, sizeof (xpath), \"testfiles/%s\", gt->files[i]);\r\n        sim_messagef (r, \"Removing: %s\\n\", gt->files[i]);\r\n        unlink (xpath);\r\n        c = strrchr (xpath, '/');\r\n        *c = '\\0';\r\n        sim_rmdir (xpath);\r\n        while ((c = strrchr (xpath, '/'))) {\r\n            *c = '\\0';\r\n            sim_rmdir (xpath);\r\n            }\r\n        sim_rmdir (xpath);\r\n        free (filename);\r\n        }\r\n    }\r\nif (r == SCPE_OK)\r\n    sim_messagef (SCPE_OK, \"All %d sim_get_filelist tests GOOD\\n\", tests);\r\nreturn r;\r\n}\r\n\r\n#endif /* NO_FIO_TEST_CODE */\r\nint sim_stat (const char *fname, struct stat *stat_str)\r\n{\r\nchar namebuf[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (fname, namebuf, sizeof (namebuf)))\r\n    return -1;\r\nreturn stat (namebuf, stat_str);\r\n}\r\n\r\nint sim_chdir(const char *path)\r\n{\r\nchar pathbuf[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (path, pathbuf, sizeof (pathbuf)))\r\n    return -1;\r\nreturn chdir (pathbuf);\r\n}\r\n\r\nint sim_mkdir(const char *path)\r\n{\r\nchar pathbuf[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (path, pathbuf, sizeof (pathbuf)))\r\n    return -1;\r\n#if defined(_WIN32)\r\nreturn mkdir (pathbuf);\r\n#else\r\nreturn mkdir (pathbuf, 0777);\r\n#endif\r\n}\r\n\r\nint sim_rmdir(const char *path)\r\n{\r\nchar pathbuf[PATH_MAX + 1];\r\nstruct stat statb;\r\nchar *fullpath;\r\nchar FullPath[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (path, pathbuf, sizeof (pathbuf)))\r\n    return -1;\r\n\r\nmemset (&statb, 0, sizeof (statb));\r\n(void)stat (pathbuf, &statb);\r\nif ((statb.st_mode & S_IFDIR) == 0)\r\n    return rmdir (pathbuf);         /* This is an error, but let rmdir() set errno */\r\n\r\nfullpath = sim_filepath_parts (pathbuf, \"f\");\r\nsnprintf (FullPath, sizeof (FullPath), \"%s/*\", fullpath);\r\nfree (fullpath);\r\n_flush_filelist_directory_cache_entry (FullPath);\r\n\r\nreturn rmdir (pathbuf);\r\n}\r\n\r\ntypedef struct FILELIST_DIRECTORY_CACHE {\r\n    struct FILELIST_DIRECTORY_CACHE *next;\r\n    char *directory;\r\n    char **dirlist;\r\n    } FILELIST_DIRECTORY_CACHE;\r\n\r\nstatic FILELIST_DIRECTORY_CACHE *_filelist_directory_cache = NULL;\r\n\r\nstatic char **_check_filelist_directory_cache (const char *directory)\r\n{\r\nFILELIST_DIRECTORY_CACHE *entry = _filelist_directory_cache;\r\n\r\nwhile (entry != NULL) {\r\n    if (strcmp (directory, entry->directory) == 0) {\r\n        sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"_check_filelist_directory_cache(directory=\\\"%s\\\") found with %d entries\\n\", directory, sim_count_filelist (entry->dirlist));\r\n        return entry->dirlist;\r\n        }\r\n    entry = entry->next;\r\n    }\r\nsim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"_check_filelist_directory_cache(directory=\\\"%s\\\") not found\\n\", directory);\r\nreturn NULL;\r\n}\r\n\r\nstatic void _save_filelist_directory_cache (const char *directory, char **dirlist)\r\n{\r\nFILELIST_DIRECTORY_CACHE *entry;\r\n\r\nif (_check_filelist_directory_cache (directory) != NULL) {\r\n    sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"_save_filelist_directory_cache(directory=\\\"%s\\\") previously saved with %d directories\\n\", directory, sim_count_filelist (dirlist));\r\n    return;\r\n    }\r\nentry = (FILELIST_DIRECTORY_CACHE *)calloc (1, sizeof (*entry));\r\nentry->directory = strdup (directory);\r\nentry->dirlist = dirlist;\r\nentry->next = _filelist_directory_cache;\r\n_filelist_directory_cache = entry;\r\nsim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"_save_filelist_directory_cache(directory=\\\"%s\\\") saved with %d directories\\n\", directory, sim_count_filelist (dirlist));\r\n}\r\n\r\nstatic void _flush_filelist_directory_cache_entry (const char *directory)\r\n{\r\nFILELIST_DIRECTORY_CACHE *entry = _filelist_directory_cache;\r\nFILELIST_DIRECTORY_CACHE *last = NULL;\r\n\r\nwhile (entry != NULL) {\r\n    if (strcmp (entry->directory, directory) == 0) {\r\n        if (last == NULL)\r\n            _filelist_directory_cache = entry->next;\r\n        else\r\n            last->next = entry->next;\r\n        free (entry->directory);\r\n        sim_free_filelist (&entry->dirlist);\r\n        free (entry);\r\n        return;\r\n        }\r\n    last = entry;\r\n    entry = entry->next;\r\n    }\r\n}\r\n\r\nstatic void _flush_filelist_directory_cache (void)\r\n{\r\nFILELIST_DIRECTORY_CACHE *entry = _filelist_directory_cache;\r\n\r\nwhile (entry != NULL) {\r\n    _filelist_directory_cache = entry->next;\r\n    free (entry->directory);\r\n    sim_free_filelist (&entry->dirlist);\r\n    free (entry);\r\n    entry = _filelist_directory_cache;\r\n    }\r\n}\r\n\r\nstatic char **filelist_skip_directories = NULL;\r\n\r\nvoid sim_set_get_filelist_skip_directories (const char * const *dirlist)\r\n{\r\nint dircount = 0;\r\n\r\nif (dirlist != NULL) {\r\n    while (dirlist[dircount++] != NULL);\r\n    --dircount;\r\n    }\r\n\r\nsim_free_filelist (&filelist_skip_directories);\r\n\r\nfilelist_skip_directories = (char **)calloc (dircount + 1, sizeof (*filelist_skip_directories));\r\ndircount = 0;\r\nwhile (*dirlist != NULL)\r\n    filelist_skip_directories[dircount++] = strdup (*dirlist++);\r\n}\r\n\r\nvoid sim_clear_get_filelist_skip_directories (void)\r\n{\r\nsim_free_filelist (&filelist_skip_directories);\r\n}\r\n\r\nstatic void _sim_dirlist_entry (const char *directory,\r\n                                 const char *filename,\r\n                                 t_offset FileSize,\r\n                                 const struct stat *filestat,\r\n                                 void *context)\r\n{\r\nchar **dirlist = *(char ***)context;\r\nchar FullPath[PATH_MAX + 1];\r\nint listcount;\r\n\r\nif ((strcmp (filename, \"..\") == 0)       || /* Ignore previous dir */\r\n    ((filestat->st_mode & S_IFDIR) == 0) || /* Ignore anything not a directory */\r\n    (stop_cpu))\r\n    return;\r\n\r\nif (filelist_skip_directories != NULL) {\r\n    char **cdir = filelist_skip_directories;\r\n\r\n    while (*cdir != NULL) {\r\n        if (strcmp (*cdir, filename) == 0)\r\n            break;\r\n        ++cdir;\r\n        }\r\n    if (*cdir != NULL) {\r\n        sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"Skipping directory: %s\\n\", filename);\r\n        return;\r\n        }\r\n    }\r\n\r\nif (strcmp (filename, \".\") == 0)\r\n    filename = \"\";\r\nsnprintf (FullPath, sizeof (FullPath), \"%s%s%s\", directory, filename, (*filename != '\\0') ? \"/\" : \"\");\r\n\r\n/* Ignore this entry if it is already in the directory list */\r\nlistcount = 0;\r\nif (dirlist != NULL) {\r\n    while (dirlist[listcount] != NULL) {\r\n        if (strcmp (FullPath, dirlist[listcount]) == 0) {\r\n            sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"Ignoring already present directory: %s\\n\", FullPath);\r\n            return;\r\n            }\r\n        ++listcount;\r\n        }\r\n    }\r\ndirlist = (char **)realloc (dirlist, (listcount + 2) * sizeof (*dirlist));\r\ndirlist[listcount] = strdup (FullPath);\r\ndirlist[listcount + 1] = NULL;\r\n*(char ***)context = dirlist;\r\nif (*filename != '\\0') {\r\n    strlcat (FullPath, \"*\", sizeof (FullPath));                     /* append wildcard selector */\r\n    sim_dir_scan (FullPath, _sim_dirlist_entry, context);           /* recurse on this directory */\r\n    }\r\n}\r\n\r\n/*\r\n * Compare two file names ignoring possibly different path separators\r\n *\r\n * Return value\r\n *    -1 - names are different\r\n *     0 - names are equal\r\n *     1 - names equal first one is preferred on this platform -\r\n *         path separators are locally appropriate.\r\n *     2 - names equal second one is preferred on this platform -\r\n *         path separators are locally appropriate.\r\n */\r\nstatic int _sim_filename_compare (const char *name1,\r\n                                  const char *name2)\r\n{\r\nconst char *p1 = name1;\r\nconst char *p2 = name2;\r\nconst char *e1;\r\nconst char *e2;\r\nchar n1_sep = '\\0';\r\nchar n2_sep = '\\0';\r\nint result = -2;\r\n\r\nif (p1[1] == ':') {  /* Windows Drive letter delimiter */\r\n    if ((p2[1] == ':') &&\r\n        (sim_toupper (p1[0]) == sim_toupper (p2[0]))) {\r\n        p1 += 2;\r\n        p2 += 2;\r\n        }\r\n    }\r\nif ((*p1 == '/') || (*p1 == '\\\\')) {\r\n    n1_sep = *p1;\r\n    ++p1;\r\n    }\r\nif ((*p2 == '/') || (*p2 == '\\\\')) {\r\n    n2_sep = *p2;\r\n    ++p2;\r\n    }\r\nif (n1_sep == '\\0') {\r\n    if (strchr (p1, '/'))\r\n        n1_sep = '/';\r\n    if (strchr (p1, '\\\\'))\r\n        n1_sep = '\\\\';\r\n    }\r\nif (n2_sep == '\\0') {\r\n    if (strchr (p2, '/'))\r\n        n2_sep = '/';\r\n    if (strchr (p2, '\\\\'))\r\n        n2_sep = '\\\\';\r\n    }\r\nif (strcmp (p1, p2) == 0)\r\n    result = 0;\r\nwhile (result == -2) {\r\n    e1 = strchr (p1, n1_sep);\r\n    e2 = strchr (p2, n2_sep);\r\n    if ((e1 != NULL) && (e2 != NULL)) {\r\n        if ((e1 - p1) != (e2 - p2)) {\r\n            result = -1;/* Directory or filename Lengths differ */\r\n            break;\r\n            }\r\n        if (memcmp (p1, p2, (e1 - p1)) != 0) {\r\n            result = -1;/* Directory or filename differ */\r\n            break;\r\n            }\r\n        /* Move to next Directory or filename */\r\n        p1 = e1 + ((n1_sep != '\\0') ? 1 : 0);\r\n        p2 = e2 + ((n2_sep != '\\0') ? 1 : 0);\r\n        continue;\r\n        }\r\n    if (((e1 != NULL) && (e2 == NULL)) ||\r\n        ((e2 != NULL) && (e1 == NULL))) {\r\n        result = -1;    /* At the end of one filename but not both */\r\n        }\r\n    if (0 != strcmp (p1, p2)) {\r\n        result = -1;    /* The filename parts are different */\r\n        break;\r\n        }\r\n    if (n1_sep == sim_file_path_separator) {\r\n        result = 1;\r\n        break;\r\n        }\r\n    result = 2;\r\n    }\r\nsim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"_sim_filename_compare(\\\"%s\\\", \\\"%s\\\") result: %d\\n\", name1, name2, result);\r\nreturn result;\r\n}\r\n\r\nstatic void _sim_filelist_entry (const char *directory,\r\n                                 const char *filename,\r\n                                 t_offset FileSize,\r\n                                 const struct stat *filestat,\r\n                                 void *context)\r\n{\r\nchar **filelist = *(char ***)context;\r\nchar FullPath[PATH_MAX + 1];\r\nint listcount = 0;\r\n\r\nsnprintf (FullPath, sizeof (FullPath), \"%s%s\", directory, filename);\r\nif (filelist != NULL) {\r\n    while (filelist[listcount] != NULL) {\r\n        int same = _sim_filename_compare (filelist[listcount], FullPath);\r\n\r\n        if (same < 0) {\r\n            ++listcount;\r\n            continue;\r\n            }\r\n        if (same == 2) {\r\n            free (filelist[listcount]);\r\n            filelist[listcount] = strdup (FullPath);\r\n            }\r\n        return;\r\n        }\r\n    }\r\nfilelist = (char **)realloc (filelist, (listcount + 2) * sizeof (filelist));\r\nfilelist[listcount] = strdup (FullPath);\r\nfilelist[listcount + 1] = NULL;\r\n*(char ***)context = filelist;\r\n}\r\n\r\nchar **sim_get_filelist (const char *filename)\r\n{\r\nt_stat r = SCPE_OK;\r\nchar *dir = sim_filepath_parts (filename, \"p\");\r\nsize_t dirsize = strlen (dir);\r\nchar *file = sim_filepath_parts (filename, \"nx\");\r\nchar **dirlist = NULL, **dirs;\r\nchar **filelist = NULL;\r\n\r\nsim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"sim_get_filelist(filename=\\\"%s\\\")\\n\", filename);\r\nsim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \" Looking for Directories in\\\"%s\\\"\\n\", dir);\r\ndir = (char *)realloc (dir, dirsize + 2);\r\nstrlcat (dir, \"*\", dirsize + 2);\r\ndirlist = _check_filelist_directory_cache (dir);\r\nif (dirlist == NULL)\r\n    r = sim_dir_scan (dir, _sim_dirlist_entry, &dirlist);\r\nsim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \" %d directories found, r=%d\\n\", sim_count_filelist (dirlist), r);\r\nif (r == SCPE_OK) {\r\n    filelist = NULL;\r\n    if (dirlist != NULL) {\r\n        dirs = dirlist;\r\n        while (*dirs && !stop_cpu) {\r\n            size_t dfsize = 1 + strlen (file) + strlen (*dirs);\r\n            char *dfile = (char *)malloc (dfsize);\r\n            char **files;\r\n\r\n            snprintf (dfile, dfsize, \"%s%s\", *dirs++, file);\r\n            sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"Checking for: %s\\n\", dfile);\r\n            r = sim_dir_scan (dfile, _sim_filelist_entry, &filelist);\r\n            free (dfile);\r\n            files = filelist;\r\n            if (sim_deb && files) {\r\n                sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"Result: %s\\n\", *files);\r\n                while (*++files)\r\n                    sim_debug (FIO_DBG_SCAN, &sim_fio_test_dev, \"Result: %s\\n\", *files);\r\n                }\r\n            }\r\n        }\r\n    sim_dir_scan (filename, _sim_filelist_entry, &filelist);\r\n    free (file);\r\n    _save_filelist_directory_cache (dir, dirlist);\r\n    free (dir);\r\n    return filelist;\r\n    }\r\nfree (file);\r\nfree (dir);\r\nr = sim_dir_scan (filename, _sim_filelist_entry, &filelist);\r\nif (r == SCPE_OK)\r\n    return filelist;\r\nreturn NULL;\r\n}\r\n\r\nvoid sim_free_filelist (char ***pfilelist)\r\n{\r\nchar **listp = *pfilelist;\r\n\r\nif (listp == NULL)\r\n    return;\r\nwhile (*listp != NULL)\r\n    free (*listp++);\r\nfree (*pfilelist);\r\n*pfilelist = NULL;\r\n}\r\n\r\nvoid sim_print_filelist (char **filelist)\r\n{\r\nif (filelist == NULL)\r\n    return;\r\nwhile (*filelist != NULL)\r\n    sim_printf (\"%s\\n\", *filelist++);\r\n}\r\n\r\nint sim_count_filelist (char **filelist)\r\n{\r\nint count = 0;\r\n\r\nif (filelist == NULL)\r\n    return count;\r\nwhile (*filelist++ != NULL)\r\n    ++count;\r\nreturn count;\r\n}\r\n\r\n\r\n\r\n/* OS-dependent routines */\r\n\r\n/* Optimized file open */\r\nFILE* sim_fopen (const char *file, const char *mode)\r\n{\r\nFILE *f;\r\nchar namebuf[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (file, namebuf, sizeof (namebuf)))\r\n    return NULL;\r\n#if defined (VMS)\r\nf = fopen (namebuf, mode, \"ALQ=32\", \"DEQ=4096\",\r\n                          \"MBF=6\", \"MBC=127\", \"FOP=cbt,tef\", \"ROP=rah,wbh\", \"CTX=stm\");\r\n#elif (defined (__linux) || defined (__linux__) || defined (__hpux) || defined (_AIX)) && !defined (DONT_DO_LARGEFILE)\r\nf = fopen64 (namebuf, mode);\r\n#else\r\nf = fopen (namebuf, mode);\r\n#endif\r\nreturn f;\r\n}\r\n\r\n#if !defined (DONT_DO_LARGEFILE)\r\n/* 64b VMS */\r\n\r\n#if ((defined (__ALPHA) || defined (__ia64)) && defined (VMS) && (__DECC_VER >= 60590001)) || \\\r\n    ((defined(__sun) || defined(__sun__)) && defined(_LARGEFILE_SOURCE))\r\n#define S_SIM_IO_FSEEK_EXT_ 1\r\nint sim_fseeko (FILE *st, t_offset offset, int whence)\r\n{\r\nreturn fseeko (st, (off_t)offset, whence);\r\n}\r\n\r\nt_offset sim_ftell (FILE *st)\r\n{\r\nreturn (t_offset)(ftello (st));\r\n}\r\n\r\n#endif\r\n\r\n/* Alpha UNIX - natively 64b */\r\n\r\n#if defined (__ALPHA) && defined (__unix__)             /* Alpha UNIX */\r\n#define S_SIM_IO_FSEEK_EXT_ 1\r\nint sim_fseeko (FILE *st, t_offset offset, int whence)\r\n{\r\nreturn fseek (st, offset, whence);\r\n}\r\n\r\nt_offset sim_ftell (FILE *st)\r\n{\r\nreturn (t_offset)(ftell (st));\r\n}\r\n\r\n#endif\r\n\r\n/* Windows */\r\n\r\n#if defined (_WIN32)\r\n#define S_SIM_IO_FSEEK_EXT_ 1\r\n\r\nint sim_fseeko (FILE *st, t_offset offset, int whence)\r\n{\r\nreturn _fseeki64 (st, (__int64)offset, whence);\r\n}\r\n\r\nt_offset sim_ftell (FILE *st)\r\n{\r\nreturn (t_offset)_ftelli64 (st);\r\n}\r\n\r\n#endif                                                  /* end Windows */\r\n\r\n/* Linux */\r\n\r\n#if defined (__linux) || defined (__linux__) || defined (__hpux) || defined (_AIX)\r\n#define S_SIM_IO_FSEEK_EXT_ 1\r\nint sim_fseeko (FILE *st, t_offset xpos, int origin)\r\n{\r\nreturn fseeko64 (st, (off64_t)xpos, origin);\r\n}\r\n\r\nt_offset sim_ftell (FILE *st)\r\n{\r\nreturn (t_offset)(ftello64 (st));\r\n}\r\n\r\n#endif                                                  /* end Linux with LFS */\r\n\r\n/* Apple OS/X */\r\n\r\n#if defined (__APPLE__) || defined (__FreeBSD__) || defined(__NetBSD__) || defined (__OpenBSD__) || defined (__CYGWIN__)\r\n#define S_SIM_IO_FSEEK_EXT_ 1\r\nint sim_fseeko (FILE *st, t_offset xpos, int origin)\r\n{\r\nreturn fseeko (st, (off_t)xpos, origin);\r\n}\r\n\r\nt_offset sim_ftell (FILE *st)\r\n{\r\nreturn (t_offset)(ftello (st));\r\n}\r\n\r\n#endif  /* end Apple OS/X */\r\n#endif /* !DONT_DO_LARGEFILE */\r\n\r\n/* Default: no OS-specific routine has been defined */\r\n\r\n#if !defined (S_SIM_IO_FSEEK_EXT_)\r\nint sim_fseeko (FILE *st, t_offset xpos, int origin)\r\n{\r\nreturn fseek (st, (long) xpos, origin);\r\n}\r\n\r\nt_offset sim_ftell (FILE *st)\r\n{\r\nreturn (t_offset)(ftell (st));\r\n}\r\n#endif\r\n\r\nint sim_fseek (FILE *st, t_addr offset, int whence)\r\n{\r\nreturn sim_fseeko (st, (t_offset)offset, whence);\r\n}\r\n\r\n#if defined(_WIN32)\r\nconst char *\r\nsim_get_os_error_text (int Error)\r\n{\r\nstatic char szMsgBuffer[2048];\r\nDWORD dwStatus;\r\n\r\ndwStatus = FormatMessageA (FORMAT_MESSAGE_FROM_SYSTEM|\r\n                           FORMAT_MESSAGE_IGNORE_INSERTS,     //  __in      DWORD dwFlags,\r\n                           NULL,                              //  __in_opt  LPCVOID lpSource,\r\n                           Error,                             //  __in      DWORD dwMessageId,\r\n                           0,                                 //  __in      DWORD dwLanguageId,\r\n                           szMsgBuffer,                       //  __out     LPTSTR lpBuffer,\r\n                           sizeof (szMsgBuffer) -1,           //  __in      DWORD nSize,\r\n                           NULL);                             //  __in_opt  va_list *Arguments\r\nif (0 == dwStatus)\r\n    snprintf(szMsgBuffer, sizeof(szMsgBuffer) - 1, \"Error Code: 0x%X\", Error);\r\nwhile (sim_isspace (szMsgBuffer[strlen (szMsgBuffer)-1]))\r\n    szMsgBuffer[strlen (szMsgBuffer) - 1] = '\\0';\r\nreturn szMsgBuffer;\r\n}\r\n\r\nt_stat sim_copyfile (const char *source_file, const char *dest_file, t_bool overwrite_existing)\r\n{\r\nchar sourcename[PATH_MAX + 1], destname[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (source_file, sourcename, sizeof (sourcename)))\r\n    return sim_messagef (SCPE_ARG, \"Error Copying - Problem Parsing Source Filename '%s'\\n\", source_file);\r\nif (NULL == _sim_expand_homedir (dest_file, destname, sizeof (destname)))\r\n    return sim_messagef (SCPE_ARG, \"Error Copying - Problem Parsing Destination Filename '%s'\\n\", dest_file);\r\nif (CopyFileA (sourcename, destname, !overwrite_existing))\r\n    return SCPE_OK;\r\nreturn sim_messagef (SCPE_ARG, \"Error Copying '%s' to '%s': %s\\n\", source_file, dest_file, sim_get_os_error_text (GetLastError ()));\r\n}\r\n\r\nstatic void _time_t_to_filetime (time_t ttime, FILETIME *filetime)\r\n{\r\nt_uint64 time64;\r\n\r\ntime64 = 134774;                /* Days between Jan 1, 1601 and Jan 1, 1970 */\r\ntime64 *= 24;                   /* Hours */\r\ntime64 *= 3600;                 /* Seconds */\r\ntime64 += (t_uint64)ttime;      /* include time_t seconds */\r\n\r\ntime64 *= 10000000;             /* Convert seconds to 100ns units */\r\nfiletime->dwLowDateTime = (DWORD)time64;\r\nfiletime->dwHighDateTime = (DWORD)(time64 >> 32);\r\n}\r\n\r\nt_stat sim_set_file_times (const char *file_name, time_t access_time, time_t write_time)\r\n{\r\nchar filename[PATH_MAX + 1];\r\nFILETIME accesstime, writetime;\r\nHANDLE hFile;\r\nBOOL bStat;\r\n\r\n_time_t_to_filetime (access_time, &accesstime);\r\n_time_t_to_filetime (write_time, &writetime);\r\nif (NULL == _sim_expand_homedir (file_name, filename, sizeof (filename)))\r\n    return sim_messagef (SCPE_ARG, \"Error Setting File Times - Problem Source Filename '%s'\\n\", filename);\r\nhFile = CreateFileA (filename, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\nif (hFile == INVALID_HANDLE_VALUE)\r\n    return sim_messagef (SCPE_ARG, \"Can't open file '%s' to set it's times: %s\\n\", filename, sim_get_os_error_text (GetLastError ()));\r\nbStat = SetFileTime (hFile, NULL, &accesstime, &writetime);\r\nCloseHandle (hFile);\r\nreturn bStat ? SCPE_OK : sim_messagef (SCPE_ARG, \"Error setting file '%s' times: %s\\n\", filename, sim_get_os_error_text (GetLastError ()));\r\n}\r\n\r\n\r\n#include <io.h>\r\n#include <direct.h>\r\nint sim_set_fsize (FILE *fptr, t_addr size)\r\n{\r\nreturn _chsize(_fileno(fptr), (long)size);\r\n}\r\n\r\nint sim_set_fifo_nonblock (FILE *fptr)\r\n{\r\nreturn -1;\r\n}\r\n\r\nstruct SHMEM {\r\n    HANDLE hMapping;\r\n    size_t shm_size;\r\n    void *shm_base;\r\n    char *shm_name;\r\n    };\r\n\r\nt_stat sim_shmem_open (const char *name, size_t size, SHMEM **shmem, void **addr)\r\n{\r\nSYSTEM_INFO SysInfo;\r\nt_bool AlreadyExists;\r\n\r\nGetSystemInfo (&SysInfo);\r\n*shmem = (SHMEM *)calloc (1, sizeof(**shmem));\r\nif (*shmem == NULL)\r\n    return SCPE_MEM;\r\n(*shmem)->shm_name = (char *)calloc (1, 1 + strlen (name));\r\nif ((*shmem)->shm_name == NULL) {\r\n    free (*shmem);\r\n    *shmem = NULL;\r\n    return SCPE_MEM;\r\n    }\r\nstrcpy ((*shmem)->shm_name, name);\r\n(*shmem)->hMapping = INVALID_HANDLE_VALUE;\r\n(*shmem)->shm_size = size;\r\n(*shmem)->shm_base = NULL;\r\n(*shmem)->hMapping = CreateFileMappingA (INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE|SEC_COMMIT, 0, (DWORD)(size+SysInfo.dwPageSize), name);\r\nif ((*shmem)->hMapping == INVALID_HANDLE_VALUE) {\r\n    DWORD LastError = GetLastError();\r\n\r\n    sim_shmem_close (*shmem);\r\n    *shmem = NULL;\r\n    return sim_messagef (SCPE_OPENERR, \"Can't CreateFileMapping of a %u byte shared memory segment '%s' - LastError=0x%X\\n\", (unsigned int)size, name, (unsigned int)LastError);\r\n    }\r\nAlreadyExists = (GetLastError () == ERROR_ALREADY_EXISTS);\r\n(*shmem)->shm_base = MapViewOfFile ((*shmem)->hMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);\r\nif ((*shmem)->shm_base == NULL) {\r\n    DWORD LastError = GetLastError();\r\n\r\n    sim_shmem_close (*shmem);\r\n    *shmem = NULL;\r\n    return sim_messagef (SCPE_OPENERR, \"Can't MapViewOfFile() of a %u byte shared memory segment '%s' - LastError=0x%X\\n\", (unsigned int)size, name, (unsigned int)LastError);\r\n    }\r\nif (AlreadyExists) {\r\n    if (*((DWORD *)((*shmem)->shm_base)) == 0)\r\n        Sleep (50);\r\n    if (*((DWORD *)((*shmem)->shm_base)) != (DWORD)size) {\r\n        DWORD SizeFound = *((DWORD *)((*shmem)->shm_base));\r\n        sim_shmem_close (*shmem);\r\n        *shmem = NULL;\r\n        return sim_messagef (SCPE_OPENERR, \"Shared Memory segment '%s' is %u bytes instead of %d\\n\", name, (unsigned int)SizeFound, (int)size);\r\n        }\r\n    }\r\nelse\r\n    *((DWORD *)((*shmem)->shm_base)) = (DWORD)size;     /* Save Size in first page */\r\n\r\n*addr = ((char *)(*shmem)->shm_base + SysInfo.dwPageSize);      /* Point to the second page for data */\r\nreturn SCPE_OK;\r\n}\r\n\r\nvoid sim_shmem_close (SHMEM *shmem)\r\n{\r\nif (shmem == NULL)\r\n    return;\r\nif (shmem->shm_base != NULL)\r\n    UnmapViewOfFile (shmem->shm_base);\r\nif (shmem->hMapping != INVALID_HANDLE_VALUE)\r\n    CloseHandle (shmem->hMapping);\r\nfree (shmem->shm_name);\r\nfree (shmem);\r\n}\r\n\r\nint32 sim_shmem_atomic_add (int32 *p, int32 v)\r\n{\r\nreturn InterlockedExchangeAdd ((volatile long *) p,v) + (v);\r\n}\r\n\r\nt_bool sim_shmem_atomic_cas (int32 *ptr, int32 oldv, int32 newv)\r\n{\r\nreturn (InterlockedCompareExchange ((LONG volatile *) ptr, newv, oldv) == oldv);\r\n}\r\n\r\n#else /* !defined(_WIN32) */\r\n#include <unistd.h>\r\nint sim_set_fsize (FILE *fptr, t_addr size)\r\n{\r\nreturn ftruncate(fileno(fptr), (off_t)size);\r\n}\r\n\r\n#include <fcntl.h>\r\n#if defined (HAVE_UTIME)\r\n#include <utime.h>\r\n#endif\r\n\r\nconst char *\r\nsim_get_os_error_text (int Error)\r\n{\r\nreturn strerror (Error);\r\n}\r\n\r\nt_stat sim_copyfile (const char *source_file, const char *dest_file, t_bool overwrite_existing)\r\n{\r\nFILE *fIn = NULL, *fOut = NULL;\r\nt_stat st = SCPE_OK;\r\nchar *buf = NULL;\r\nsize_t bytes;\r\n\r\nfIn = sim_fopen (source_file, \"rb\");\r\nif (!fIn) {\r\n    st = sim_messagef (SCPE_ARG, \"Can't open '%s' for input: %s\\n\", source_file, strerror (errno));\r\n    goto Cleanup_Return;\r\n    }\r\nfOut = sim_fopen (dest_file, \"wb\");\r\nif (!fOut) {\r\n    st = sim_messagef (SCPE_ARG, \"Can't open '%s' for output: %s\\n\", dest_file, strerror (errno));\r\n    goto Cleanup_Return;\r\n    }\r\nbuf = (char *)malloc (BUFSIZ);\r\nwhile ((bytes = fread (buf, 1, BUFSIZ, fIn)))\r\n    fwrite (buf, 1, bytes, fOut);\r\nCleanup_Return:\r\nfree (buf);\r\nif (fIn)\r\n    fclose (fIn);\r\nif (fOut)\r\n    fclose (fOut);\r\n#if defined(HAVE_UTIME)\r\nif (st == SCPE_OK) {\r\n    struct stat statb;\r\n\r\n    if (!sim_stat (source_file, &statb)) {\r\n        struct utimbuf utim;\r\n\r\n        utim.actime = statb.st_atime;\r\n        utim.modtime = statb.st_mtime;\r\n        if (utime (dest_file, &utim))\r\n            st = SCPE_IOERR;\r\n        }\r\n    else\r\n        st = SCPE_IOERR;\r\n    }\r\n#endif\r\nreturn st;\r\n}\r\n\r\nt_stat sim_set_file_times (const char *file_name, time_t access_time, time_t write_time)\r\n{\r\nt_stat st = SCPE_IOERR;\r\n#if defined (HAVE_UTIME)\r\nstruct utimbuf utim;\r\n\r\nutim.actime = access_time;\r\nutim.modtime = write_time;\r\nif (!utime (file_name, &utim))\r\n    st = SCPE_OK;\r\n#else\r\nst = SCPE_NOFNC;\r\n#endif\r\nreturn st;\r\n}\r\n\r\nint sim_set_fifo_nonblock (FILE *fptr)\r\n{\r\nstruct stat stbuf;\r\n\r\nif (!fptr || fstat (fileno(fptr), &stbuf))\r\n    return -1;\r\n#if defined(S_IFIFO) && defined(O_NONBLOCK)\r\nif ((stbuf.st_mode & S_IFIFO)) {\r\n    int flags = fcntl(fileno(fptr), F_GETFL, 0);\r\n    return fcntl(fileno(fptr), F_SETFL, flags | O_NONBLOCK);\r\n    }\r\n#endif\r\nreturn -1;\r\n}\r\n\r\n#if defined (__linux__) || defined (__APPLE__) || defined (__CYGWIN__) || defined (__FreeBSD__) || defined(__NetBSD__) || defined (__OpenBSD__)\r\n\r\n#if defined (HAVE_SHM_OPEN)\r\n#include <sys/mman.h>\r\n#endif\r\n\r\nstruct SHMEM {\r\n    int shm_fd;\r\n    size_t shm_size;\r\n    void *shm_base;\r\n    char *shm_name;\r\n    };\r\n\r\nt_stat sim_shmem_open (const char *name, size_t size, SHMEM **shmem, void **addr)\r\n{\r\n#if defined (HAVE_SHM_OPEN) && defined (__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)\r\n*shmem = (SHMEM *)calloc (1, sizeof(**shmem));\r\nmode_t orig_mask;\r\n\r\n*addr = NULL;\r\nif (*shmem == NULL)\r\n    return SCPE_MEM;\r\n(*shmem)->shm_name = (char *)calloc (1, 1 + strlen (name) + ((*name != '/') ? 1 : 0));\r\nif ((*shmem)->shm_name == NULL) {\r\n    free (*shmem);\r\n    *shmem = NULL;\r\n    return SCPE_MEM;\r\n    }\r\n\r\nsprintf ((*shmem)->shm_name, \"%s%s\", ((*name != '/') ? \"/\" : \"\"), name);\r\n(*shmem)->shm_base = MAP_FAILED;\r\n(*shmem)->shm_size = size;\r\n(*shmem)->shm_fd = shm_open ((*shmem)->shm_name, O_RDWR, 0);\r\nif ((*shmem)->shm_fd == -1) {\r\n    int last_errno;\r\n\r\n    orig_mask = umask (0000);\r\n    (*shmem)->shm_fd = shm_open ((*shmem)->shm_name, O_CREAT | O_RDWR, 0660);\r\n    last_errno = errno;\r\n    umask (orig_mask);                  /* Restore original mask */\r\n    if ((*shmem)->shm_fd == -1) {\r\n        sim_shmem_close (*shmem);\r\n        *shmem = NULL;\r\n        return sim_messagef (SCPE_OPENERR, \"Can't shm_open() a %d byte shared memory segment '%s' - errno=%d - %s\\n\", (int)size, name, last_errno, strerror (last_errno));\r\n        }\r\n    if (ftruncate((*shmem)->shm_fd, size)) {\r\n        sim_shmem_close (*shmem);\r\n        *shmem = NULL;\r\n        return SCPE_OPENERR;\r\n        }\r\n    }\r\nelse {\r\n    struct stat statb;\r\n\r\n    if ((fstat ((*shmem)->shm_fd, &statb)) ||\r\n        ((size_t)statb.st_size != (*shmem)->shm_size)) {\r\n        sim_shmem_close (*shmem);\r\n        *shmem = NULL;\r\n        return sim_messagef (SCPE_OPENERR, \"Shared Memory segment '%s' is %d bytes instead of %d\\n\", name, (int)(statb.st_size), (int)size);\r\n        }\r\n    }\r\n(*shmem)->shm_base = mmap(NULL, (*shmem)->shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, (*shmem)->shm_fd, 0);\r\nif ((*shmem)->shm_base == MAP_FAILED) {\r\n    int last_errno = errno;\r\n\r\n    sim_shmem_close (*shmem);\r\n    *shmem = NULL;\r\n    return sim_messagef (SCPE_OPENERR, \"Shared Memory '%s' mmap() failed. errno=%d - %s\\n\", name, last_errno, strerror (last_errno));\r\n    }\r\n*addr = (*shmem)->shm_base;\r\nreturn SCPE_OK;\r\n#else\r\n*shmem = NULL;\r\nreturn sim_messagef (SCPE_NOFNC, \"Shared memory not available - Missing shm_open() API\\n\");\r\n#endif\r\n}\r\n\r\nvoid sim_shmem_close (SHMEM *shmem)\r\n{\r\n#if defined (HAVE_SHM_OPEN)\r\nif (shmem == NULL)\r\n    return;\r\nif (shmem->shm_base != MAP_FAILED)\r\n    munmap (shmem->shm_base, shmem->shm_size);\r\nif (shmem->shm_fd != -1) {\r\n    shm_unlink (shmem->shm_name);\r\n    close (shmem->shm_fd);\r\n    }\r\nfree (shmem->shm_name);\r\nfree (shmem);\r\n#endif\r\n}\r\n\r\nint32 sim_shmem_atomic_add (int32 *p, int32 v)\r\n{\r\n#if defined (__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)\r\nreturn __sync_add_and_fetch ((int *) p, v);\r\n#else\r\nreturn *p + v;\r\n#endif\r\n}\r\n\r\nt_bool sim_shmem_atomic_cas (int32 *ptr, int32 oldv, int32 newv)\r\n{\r\n#if defined (__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4)\r\nreturn __sync_bool_compare_and_swap (ptr, oldv, newv);\r\n#else\r\nif (*ptr == oldv) {\r\n    *ptr = newv;\r\n    return 1;\r\n    }\r\nelse\r\n    return 0;\r\n#endif\r\n}\r\n\r\n#else /* !(defined (__linux__) || defined (__APPLE__)) */\r\n\r\nt_stat sim_shmem_open (const char *name, size_t size, SHMEM **shmem, void **addr)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nvoid sim_shmem_close (SHMEM *shmem)\r\n{\r\n}\r\n\r\nint32 sim_shmem_atomic_add (int32 *p, int32 v)\r\n{\r\nreturn -1;\r\n}\r\n\r\nt_bool sim_shmem_atomic_cas (int32 *ptr, int32 oldv, int32 newv)\r\n{\r\nreturn FALSE;\r\n}\r\n\r\n#endif /* defined (__linux__) || defined (__APPLE__) */\r\n#endif /* defined (_WIN32) */\r\n\r\n#if defined(__VAX)\r\n/*\r\n * We provide a 'basic' snprintf, which 'might' overrun a buffer, but\r\n * the actual use cases don't on other platforms and none of the callers\r\n * care about the function return value.\r\n */\r\nint sim_vax_snprintf(char *buf, size_t buf_size, const char *fmt, ...)\r\n{\r\nva_list arglist;\r\n\r\nva_start (arglist, fmt);\r\nvsprintf (buf, fmt, arglist);\r\nva_end (arglist);\r\nreturn 0;\r\n}\r\n#endif\r\n\r\nchar *sim_getcwd (char *buf, size_t buf_size)\r\n{\r\n#if defined (VMS)\r\nreturn getcwd (buf, buf_size, 0);\r\n#else\r\nchar *result = getcwd (buf, buf_size);\r\n\r\n#if defined (_WIN32)\r\nif ((result != NULL) && sim_islower (buf[0]) && (buf[1] == ':'))\r\n    buf[0] = sim_toupper (buf[0]);\r\n#endif\r\nreturn result;\r\n#endif\r\n}\r\n\r\n/*\r\n * Parsing and expansion of file names.\r\n *\r\n *    %~I%        - expands filepath value removing any surrounding quotes (\" or ')\r\n *    %~fI%       - expands filepath value to a fully qualified path name\r\n *    %~pI%       - expands filepath value to a path only\r\n *    %~nI%       - expands filepath value to a file name only\r\n *    %~xI%       - expands filepath value to a file extension only\r\n *\r\n * The modifiers can be combined to get compound results:\r\n *\r\n *    %~pnI%      - expands filepath value to a path and name only\r\n *    %~nxI%      - expands filepath value to a file name and extension only\r\n *\r\n * In the above example above %I% can be replaced by other\r\n * environment variables or numeric parameters to a DO command\r\n * invocation.\r\n *\r\n * This routine returns an allocated buffer which must be freed by the\r\n * caller as needed to avoid leaking memory.\r\n */\r\n\r\nchar *sim_filepath_parts (const char *filepath, const char *parts)\r\n{\r\nsize_t tot_len = 0, tot_size = 0;\r\nchar *fullpath = NULL, *result = NULL;\r\nchar *c, *name, *ext;\r\nchar chr;\r\nconst char *p;\r\nchar filesizebuf[32] = \"\";\r\nchar filedatetimebuf[64] = \"\";\r\nchar namebuf[PATH_MAX + 1];\r\n\r\n\r\n/* Expand ~/ home directory */\r\nif (NULL == _sim_expand_homedir (filepath, namebuf, sizeof (namebuf)))\r\n    return NULL;\r\nfilepath = namebuf;\r\n\r\n/* Check for full or current directory relative path */\r\nif ((filepath[1] == ':')  ||\r\n    (filepath[0] == '/')  ||\r\n    (filepath[0] == '\\\\')){\r\n        tot_len = 1 + strlen (filepath);\r\n        fullpath = (char *)malloc (tot_len);\r\n        if (fullpath == NULL)\r\n            return NULL;\r\n        strcpy (fullpath, filepath);\r\n    }\r\nelse {          /* Need to prepend current directory */\r\n    char dir[PATH_MAX+1] = \"\";\r\n    char *wd = sim_getcwd(dir, sizeof (dir));\r\n\r\n    if (wd == NULL)\r\n        return NULL;\r\n    tot_len = 1 + strlen (filepath) + 1 + strlen (dir);\r\n    fullpath = (char *)malloc (tot_len);\r\n    if (fullpath == NULL)\r\n        return NULL;\r\n    strlcpy (fullpath, dir, tot_len);\r\n    if ((dir[strlen (dir) - 1] != '/') &&       /* if missing a trailing directory separator? */\r\n        (dir[strlen (dir) - 1] != '\\\\'))\r\n        strlcat (fullpath, \"/\", tot_len);       /*  then add one */\r\n    strlcat (fullpath, filepath, tot_len);\r\n    }\r\nwhile ((c = strchr (fullpath, '\\\\')))           /* standardize on / directory separator */\r\n       *c = '/';\r\nif ((fullpath[1] == ':') && sim_islower (fullpath[0]))\r\n    fullpath[0] = sim_toupper (fullpath[0]);\r\nwhile ((c = strstr (fullpath + 1, \"//\")))       /* strip out redundant / characters (leaving the option for a leading //) */\r\n       memmove (c, c + 1, 1 + strlen (c + 1));\r\nwhile ((c = strstr (fullpath, \"/./\")))          /* strip out irrelevant /./ sequences */\r\n       memmove (c, c + 2, 1 + strlen (c + 2));\r\nwhile ((c = strstr (fullpath, \"/../\"))) {       /* process up directory climbing */\r\n    char *cl = c - 1;\r\n\r\n    while ((*cl != '/') && (cl > fullpath))\r\n        --cl;\r\n    if ((cl <= fullpath) ||                      /* Digest Leading /../ sequences */\r\n        ((fullpath[1] == ':') && (c == fullpath + 2)))\r\n        memmove (c, c + 3, 1 + strlen (c + 3)); /* and removing intervening elements */\r\n    else\r\n        if (*cl == '/')\r\n            memmove (cl, c + 3, 1 + strlen (c + 3));/* and removing intervening elements */\r\n        else\r\n            break;\r\n    }\r\nif (!strrchr (fullpath, '/'))\r\n    name = fullpath + strlen (fullpath);\r\nelse\r\n    name = 1 + strrchr (fullpath, '/');\r\next = strrchr (name, '.');\r\nif (ext == NULL)\r\n    ext = name + strlen (name);\r\ntot_size = 0;\r\nif (*parts == '\\0')             /* empty part specifier means strip only quotes */\r\n    tot_size = strlen (filepath);\r\nif (strchr (parts, 't') ||      /* modification time or */\r\n    strchr (parts, 'z')) {      /* or size requested? */\r\n    struct stat filestat;\r\n    struct tm *tm;\r\n\r\n    memset (&filestat, 0, sizeof (filestat));\r\n    (void)stat (fullpath, &filestat);\r\n    if (sizeof (filestat.st_size) == 4)\r\n        sprintf (filesizebuf, \"%ld \", (long)filestat.st_size);\r\n    else\r\n        sprintf (filesizebuf, \"%\" LL_FMT \"d \", (LL_TYPE)filestat.st_size);\r\n    tm = localtime (&filestat.st_mtime);\r\n    snprintf (filedatetimebuf, sizeof (filedatetimebuf), \"%02d/%02d/%04d %02d:%02d %cM \", 1 + tm->tm_mon, tm->tm_mday, 1900 + tm->tm_year,\r\n                                                              tm->tm_hour % 12, tm->tm_min, (0 == (tm->tm_hour % 12)) ? 'A' : 'P');\r\n    }\r\nfor (p = parts; *p; p++) {\r\n    switch (*p) {\r\n        case 'f':\r\n            tot_size += strlen (fullpath);\r\n            break;\r\n        case 'p':\r\n            tot_size += name - fullpath;\r\n            break;\r\n        case 'n':\r\n            tot_size += ext - name;\r\n            break;\r\n        case 'x':\r\n            tot_size += strlen (ext);\r\n            break;\r\n        case 't':\r\n            tot_size += strlen (filedatetimebuf);\r\n            break;\r\n        case 'z':\r\n            tot_size += strlen (filesizebuf);\r\n            break;\r\n        }\r\n    }\r\nresult = (char *)malloc (1 + tot_size);\r\n*result = '\\0';\r\nif (*parts == '\\0')             /* empty part specifier means strip only quotes */\r\n    strlcat (result, filepath, 1 + tot_size);\r\nfor (p = parts; *p; p++) {\r\n    switch (*p) {\r\n        case 'f':\r\n            strlcat (result, fullpath, 1 + tot_size);\r\n            break;\r\n        case 'p':\r\n            chr = *name;\r\n            *name = '\\0';\r\n            strlcat (result, fullpath, 1 + tot_size);\r\n            *name = chr;\r\n            break;\r\n        case 'n':\r\n            chr = *ext;\r\n            *ext = '\\0';\r\n            strlcat (result, name, 1 + tot_size);\r\n            *ext = chr;\r\n            break;\r\n        case 'x':\r\n            strlcat (result, ext, 1 + tot_size);\r\n            break;\r\n        case 't':\r\n            strlcat (result, filedatetimebuf, 1 + tot_size);\r\n            break;\r\n        case 'z':\r\n            strlcat (result, filesizebuf, 1 + tot_size);\r\n            break;\r\n        }\r\n    }\r\nfree (fullpath);\r\nreturn result;\r\n}\r\n\r\n/*\r\n * relative file path processing\r\n *\r\n *    Input is a filepath which may contain either / or \\ directory\r\n *    separators (or both) and always returns a relative or complete path\r\n *    with / directory separators.\r\n */\r\n\r\nconst char *sim_relative_path (const char *filenamepath)\r\n{\r\nchar dir[PATH_MAX+1] = \"\";\r\nchar *wd = sim_getcwd(dir, sizeof (dir));\r\nchar dsep = (strchr (wd, '/') != NULL) ? '/' : '\\\\';\r\nchar *cp;\r\nstatic char buf[CBUFSIZE*4];\r\nchar *filepath = NULL;\r\nchar fsep = (strchr (filenamepath, '\\\\') != NULL) ? '\\\\' : '/';\r\nchar updir[4] = {'.', '.', fsep};\r\nsize_t offset = 0, lastdir = 0, updirs = 0, up, cwd_dirs;\r\n\r\nfilepath = sim_filepath_parts (filenamepath, \"f\");\r\nif (strchr (filepath, fsep) == NULL) {  /* file directory path separators changed? */\r\n    char csep = (fsep == '/') ? '\\\\' : '/';\r\n\r\n    while ((cp = strchr (filepath, csep)))\r\n        *cp = fsep;                     /* restore original file path separator */\r\n    }\r\nif (dsep != fsep) {                     /* if directory path separators aren't the same */\r\n    while ((cp = strchr (wd, dsep)) != NULL)\r\n        *cp = fsep;                     /* change to the file path separator */\r\n    dsep = fsep;\r\n    }\r\ncp = wd - 1;\r\ncwd_dirs = (isalpha(wd[0]) && (wd[1] == ':')) ? 1 : 0;\r\nwhile ((cp = strchr (cp + 1, fsep)) != NULL)\r\n    cwd_dirs++;\r\nif (wd[strlen (wd) - 1] != fsep)\r\n    cwd_dirs++;\r\nbuf[0] = '\\0';\r\n/* Skip over matching directory pieces */\r\nwhile ((wd[offset] != '\\0') && (filepath[offset] != '\\0')) {\r\n    if ((wd[offset] == dsep) &&\r\n        (filepath[offset] == fsep)) {\r\n        lastdir = offset;               /* save position of last director match */\r\n        ++offset;\r\n        continue;\r\n        }\r\n#if defined(_WIN32)                     /* Windows has case independent file names */\r\n#define _CMP(x) (sim_islower (x) ? sim_toupper (x) : x)\r\n#else\r\n#define _CMP(x) (x)\r\n#endif\r\n    if (_CMP(wd[offset]) != _CMP(filepath[offset]))\r\n        break;\r\n    ++offset;\r\n    }\r\nif (wd[offset] == '\\0') {\r\n    if (filepath[offset] == fsep) {\r\n        lastdir = offset;\r\n        ++offset;\r\n        updirs = 0;\r\n        }\r\n    else {\r\n        offset = lastdir + 1;\r\n        updirs = 1;\r\n        }\r\n    }\r\nelse {\r\n    offset = lastdir + 1;\r\n    updirs = 1;\r\n    while (wd[++lastdir] != '\\0') {\r\n        if (wd[lastdir] == fsep)\r\n            ++updirs;\r\n        }\r\n    }\r\nif (updirs > 0) {\r\n    if ((offset == 3) &&                /* if only match windows drive letter? */\r\n        (wd[1] == ':') &&\r\n        (wd[2] == dsep))\r\n        offset = 0;                     /* */\r\n    if ((offset > 0) && (updirs != cwd_dirs)) {\r\n        for (up = 0; up < updirs; up++)\r\n            strlcat (buf, updir, sizeof (buf));\r\n        if (strlen (buf) > offset) {    /* if relative path prefix is longer than input path? */\r\n            offset = 0;                 /* revert to original path */\r\n            buf[0] = '\\0';\r\n            }\r\n        }\r\n    }\r\nelse\r\n    strlcpy (buf, \"./\", sizeof (buf));\r\nstrlcat (buf, &filepath[offset], sizeof (buf));\r\nif (dsep != '/')\r\n    while ((cp = strchr (buf, dsep)) != NULL)\r\n        *cp = '/';                      /* Always return with / as the directory separator */\r\nfree (filepath);\r\nreturn buf;\r\n}\r\n\r\n#if defined (_WIN32)\r\n\r\nt_stat sim_dir_scan (const char *cptr, DIR_ENTRY_CALLBACK entry, void *context)\r\n{\r\nHANDLE hFind;\r\nWIN32_FIND_DATAA File;\r\nstruct stat filestat;\r\nchar WildName[PATH_MAX + 1];\r\n\r\nif (NULL == _sim_expand_homedir (cptr, WildName, sizeof (WildName)))\r\n    return SCPE_ARG;\r\ncptr = WildName;\r\nsim_trim_endspc (WildName);\r\nif ((hFind =  FindFirstFileA (cptr, &File)) != INVALID_HANDLE_VALUE) {\r\n    t_int64 FileSize;\r\n    char DirName[PATH_MAX + 1], FileName[PATH_MAX + 1];\r\n    char *c;\r\n    const char *backslash = strchr (cptr, '\\\\');\r\n    const char *slash = strchr (cptr, '/');\r\n    const char *pathsep = (backslash && slash) ? MIN (backslash, slash) : (backslash ? backslash : slash);\r\n\r\n    GetFullPathNameA(cptr, sizeof(DirName), DirName, (char **)&c);\r\n    c = strrchr (DirName, '\\\\');\r\n    *c = '\\0';                                  /* Truncate to just directory path */\r\n    if (!pathsep ||                             /* Separator wasn't mentioned? */\r\n        (slash && (0 == strcmp (slash, \"/*\"))))\r\n        pathsep = \"\\\\\";                         /* Default to Windows backslash */\r\n    if (*pathsep == '/') {                      /* If slash separator? */\r\n        while ((c = strchr (DirName, '\\\\')))\r\n            *c = '/';                           /* Convert backslash to slash */\r\n        }\r\n    if (sim_islower (DirName[0]) && (DirName[1] == ':'))\r\n        DirName[0] = sim_toupper (DirName[0]);\r\n    sprintf (&DirName[strlen (DirName)], \"%c\", *pathsep);\r\n    do {\r\n        FileSize = (((t_int64)(File.nFileSizeHigh)) << 32) | File.nFileSizeLow;\r\n        strlcpy (FileName, DirName, sizeof (FileName));\r\n        strlcat (FileName, File.cFileName, sizeof (FileName));\r\n        stat (FileName, &filestat);\r\n        entry (DirName, File.cFileName, FileSize, &filestat, context);\r\n        } while (FindNextFileA (hFind, &File));\r\n    FindClose (hFind);\r\n    }\r\nelse\r\n    return SCPE_ARG;\r\nreturn SCPE_OK;\r\n}\r\n\r\n#else /* !defined (_WIN32) */\r\n\r\n#if defined (HAVE_GLOB)\r\n#include <glob.h>\r\n#else /* !defined (HAVE_GLOB) */\r\n#include <dirent.h>\r\n#if defined (HAVE_FNMATCH)\r\n#include <fnmatch.h>\r\n#endif\r\n#endif /* defined (HAVE_GLOB) */\r\n\r\nt_stat sim_dir_scan (const char *cptr, DIR_ENTRY_CALLBACK entry, void *context)\r\n{\r\n#if defined (HAVE_GLOB)\r\nglob_t  paths;\r\n#else\r\nDIR *dir;\r\n#endif\r\nint found_count = 0;\r\nstruct stat filestat;\r\nchar *c;\r\nchar DirName[PATH_MAX + 1], WholeName[PATH_MAX + 1], WildName[PATH_MAX + 1], MatchName[PATH_MAX + 1];\r\n\r\nmemset (DirName, 0, sizeof(DirName));\r\nmemset (WholeName, 0, sizeof(WholeName));\r\nmemset (MatchName, 0, sizeof(MatchName));\r\nif (NULL == _sim_expand_homedir (cptr, WildName, sizeof (WildName)))\r\n    return SCPE_ARG;\r\ncptr = WildName;\r\nsim_trim_endspc (WildName);\r\nc = sim_filepath_parts (cptr, \"f\");\r\nstrlcpy (WholeName, c, sizeof (WholeName));\r\nfree (c);\r\nc = sim_filepath_parts (cptr, \"nx\");\r\nstrlcpy (MatchName, c, sizeof (MatchName));\r\nfree (c);\r\nc = strrchr (WholeName, '/');\r\nif (c) {\r\n    memmove (DirName, WholeName, 1+c-WholeName);\r\n    DirName[2+c-WholeName] = '\\0';  /* Terminate after the path separator */\r\n    }\r\nelse\r\n    DirName[0] = '\\0';\r\ncptr = WholeName;\r\n#if defined (HAVE_GLOB)\r\nmemset (&paths, 0, sizeof (paths));\r\nif (0 == glob (cptr, 0, NULL, &paths)) {\r\n#else\r\ndir = opendir(DirName[0] ? DirName : \"/.\");\r\nif (dir) {\r\n    struct dirent *ent;\r\n#endif\r\n    t_offset FileSize;\r\n    char *FileName;\r\n     char *p_name;\r\n#if defined (HAVE_GLOB)\r\n    size_t i;\r\n#endif\r\n\r\n#if defined (HAVE_GLOB)\r\n    for (i=0; i<paths.gl_pathc; i++) {\r\n        FileName = (char *)malloc (1 + strlen (paths.gl_pathv[i]));\r\n        sprintf (FileName, \"%s\", paths.gl_pathv[i]);\r\n#else /* !defined (HAVE_GLOB) */\r\n    while ((ent = readdir (dir))) {\r\n#if defined (HAVE_FNMATCH)\r\n        if (fnmatch(MatchName, ent->d_name, 0))\r\n            continue;\r\n#else /* !defined (HAVE_FNMATCH) */\r\n        /* only match all names or exact name without fnmatch support */\r\n        if ((strcmp(MatchName, \"*\") != 0) &&\r\n            (strcmp(MatchName, ent->d_name) != 0))\r\n            continue;\r\n#endif /* defined (HAVE_FNMATCH) */\r\n        FileName = (char *)malloc (1 + strlen (DirName) + strlen (ent->d_name));\r\n        sprintf (FileName, \"%s%s\", DirName, ent->d_name);\r\n#endif /* defined (HAVE_GLOB) */\r\n        p_name = FileName + strlen (DirName);\r\n        memset (&filestat, 0, sizeof (filestat));\r\n        (void)stat (FileName, &filestat);\r\n        FileSize = (t_offset)((filestat.st_mode & S_IFDIR) ? 0 : sim_fsize_name_ex (FileName));\r\n        entry (DirName, p_name, FileSize, &filestat, context);\r\n        free (FileName);\r\n        ++found_count;\r\n        }\r\n#if defined (HAVE_GLOB)\r\n    globfree (&paths);\r\n#else\r\n    closedir (dir);\r\n#endif\r\n    }\r\nelse\r\n    return SCPE_ARG;\r\nif (found_count)\r\n    return SCPE_OK;\r\nelse\r\n    return SCPE_ARG;\r\n}\r\n#endif /* !defined(_WIN32) */\r\n\r\n/* Trim trailing spaces from a string\r\n\r\n    Inputs:\r\n        cptr    =       pointer to string\r\n    Outputs:\r\n        cptr    =       pointer to string\r\n*/\r\n\r\nchar *sim_trim_endspc (char *cptr)\r\n{\r\nchar *tptr;\r\n\r\ntptr = cptr + strlen (cptr);\r\nwhile ((--tptr >= cptr) && sim_isspace (*tptr))\r\n    *tptr = 0;\r\nreturn cptr;\r\n}\r\n\r\nint sim_isspace (int c)\r\n{\r\nreturn ((c < 0) || (c >= 128)) ? 0 : isspace (c);\r\n}\r\n\r\nint sim_islower (int c)\r\n{\r\nreturn (c >= 'a') && (c <= 'z');\r\n}\r\n\r\nint sim_isupper (int c)\r\n{\r\nreturn (c >= 'A') && (c <= 'Z');\r\n}\r\n\r\nint sim_toupper (int c)\r\n{\r\nreturn ((c >= 'a') && (c <= 'z')) ? ((c - 'a') + 'A') : c;\r\n}\r\n\r\nint sim_tolower (int c)\r\n{\r\nreturn ((c >= 'A') && (c <= 'Z')) ? ((c - 'A') + 'a') : c;\r\n}\r\n\r\nint sim_isalpha (int c)\r\n{\r\nreturn ((c < 0) || (c >= 128)) ? 0 : isalpha (c);\r\n}\r\n\r\nint sim_isprint (int c)\r\n{\r\nreturn ((c < 0) || (c >= 128)) ? 0 : isprint (c);\r\n}\r\n\r\nint sim_isdigit (int c)\r\n{\r\nreturn ((c >= '0') && (c <= '9'));\r\n}\r\n\r\nint sim_isgraph (int c)\r\n{\r\nreturn ((c < 0) || (c >= 128)) ? 0 : isgraph (c);\r\n}\r\n\r\nint sim_isalnum (int c)\r\n{\r\nreturn ((c < 0) || (c >= 128)) ? 0 : isalnum (c);\r\n}\r\n\r\n/* strncasecmp() is not available on all platforms */\r\nint sim_strncasecmp (const char* string1, const char* string2, size_t len)\r\n{\r\nsize_t i;\r\nunsigned char s1, s2;\r\n\r\nfor (i=0; i<len; i++) {\r\n    s1 = (unsigned char)string1[i];\r\n    s2 = (unsigned char)string2[i];\r\n    s1 = (unsigned char)sim_toupper (s1);\r\n    s2 = (unsigned char)sim_toupper (s2);\r\n    if (s1 < s2)\r\n        return -1;\r\n    if (s1 > s2)\r\n        return 1;\r\n    if (s1 == 0)\r\n        return 0;\r\n    }\r\nreturn 0;\r\n}\r\n\r\n/* strcasecmp() is not available on all platforms */\r\nint sim_strcasecmp (const char *string1, const char *string2)\r\n{\r\nsize_t i = 0;\r\nunsigned char s1, s2;\r\n\r\nwhile (1) {\r\n    s1 = (unsigned char)string1[i];\r\n    s2 = (unsigned char)string2[i];\r\n    s1 = (unsigned char)sim_toupper (s1);\r\n    s2 = (unsigned char)sim_toupper (s2);\r\n    if (s1 == s2) {\r\n        if (s1 == 0)\r\n            return 0;\r\n        i++;\r\n        continue;\r\n        }\r\n    if (s1 < s2)\r\n        return -1;\r\n    if (s1 > s2)\r\n        return 1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nint sim_strwhitecasecmp (const char *string1, const char *string2, t_bool casecmp)\r\n{\r\nunsigned char s1 = 1, s2 = 1;   /* start with equal, but not space */\r\n\r\nwhile ((s1 == s2) && (s1 != '\\0')) {\r\n    if (s1 == ' ') {            /* last character was space? */\r\n        while (s1 == ' ') {     /* read until not a space */\r\n            s1 = *string1++;\r\n            if (sim_isspace (s1))\r\n                s1 = ' ';       /* all whitespace is a space */\r\n            else {\r\n                if (casecmp)\r\n                    s1 = (unsigned char)sim_toupper (s1);\r\n                }\r\n            }\r\n        }\r\n    else {                      /* get new character */\r\n        s1 = *string1++;\r\n        if (sim_isspace (s1))\r\n            s1 = ' ';           /* all whitespace is a space */\r\n        else {\r\n            if (casecmp)\r\n                s1 = (unsigned char)sim_toupper (s1);\r\n            }\r\n        }\r\n    if (s2 == ' ') {            /* last character was space? */\r\n        while (s2 == ' ') {     /* read until not a space */\r\n            s2 = *string2++;\r\n            if (sim_isspace (s2))\r\n                s2 = ' ';       /* all whitespace is a space */\r\n            else {\r\n                if (casecmp)\r\n                    s2 = (unsigned char)sim_toupper (s2);\r\n                }\r\n            }\r\n        }\r\n    else {                      /* get new character */\r\n        s2 = *string2++;\r\n        if (sim_isspace (s2))\r\n            s2 = ' ';           /* all whitespace is a space */\r\n        else {\r\n            if (casecmp)\r\n                s2 = (unsigned char)sim_toupper (s2);\r\n            }\r\n        }\r\n    if (s1 == s2) {\r\n        if (s1 == 0)\r\n            return 0;\r\n        continue;\r\n        }\r\n    if (s1 < s2)\r\n        return -1;\r\n    if (s1 > s2)\r\n        return 1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\n/* strlcat() and strlcpy() are not available on all platforms */\r\n/* Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com> */\r\n/*\r\n * Appends src to string dst of size siz (unlike strncat, siz is the\r\n * full size of dst, not space left).  At most siz-1 characters\r\n * will be copied.  Always NUL terminates (unless siz <= strlen(dst)).\r\n * Returns strlen(src) + MIN(siz, strlen(initial dst)).\r\n * If retval >= siz, truncation occurred.\r\n */\r\nsize_t sim_strlcat(char *dst, const char *src, size_t size)\r\n{\r\nchar *d = dst;\r\nconst char *s = src;\r\nsize_t n = size;\r\nsize_t dlen;\r\n\r\n/* Find the end of dst and adjust bytes left but don't go past end */\r\nwhile (n-- != 0 && *d != '\\0')\r\n    d++;\r\ndlen = d - dst;\r\nn = size - dlen;\r\n\r\nif (n == 0)\r\n    return (dlen + strlen(s));\r\nwhile (*s != '\\0') {\r\n    if (n != 1) {\r\n        *d++ = *s;\r\n        n--;\r\n        }\r\n    s++;\r\n    }\r\n*d = '\\0';\r\n\r\nreturn (dlen + (s - src));          /* count does not include NUL */\r\n}\r\n\r\n/*\r\n * Copy src to string dst of size siz.  At most siz-1 characters\r\n * will be copied.  Always NUL terminates (unless siz == 0).\r\n * Returns strlen(src); if retval >= siz, truncation occurred.\r\n */\r\nsize_t sim_strlcpy (char *dst, const char *src, size_t size)\r\n{\r\nchar *d = dst;\r\nconst char *s = src;\r\nsize_t n = size;\r\n\r\n/* Copy as many bytes as will fit */\r\nif (n != 0) {\r\n    while (--n != 0) {\r\n        if ((*d++ = *s++) == '\\0')\r\n            break;\r\n        }\r\n    }\r\n\r\n    /* Not enough room in dst, add NUL and traverse rest of src */\r\n    if (n == 0) {\r\n        if (size != 0)\r\n            *d = '\\0';              /* NUL-terminate dst */\r\n        while (*s++)\r\n            ;\r\n        }\r\nreturn (s - src - 1);               /* count does not include NUL */\r\n}\r\n\r\n/* SCP Simulator Source Code validator support */\r\n\r\nstatic const char *_check_source_skip_dirs[] = {\r\n    \".git\",\r\n    \".github\",\r\n    \".travis\",\r\n    \"BIN\",\r\n    \"doc\",\r\n    NULL\r\n    };\r\n\r\nstatic const char *_check_source_scp_sub_dirs[] = {\r\n    \"slirp\",\r\n    \"slirp_glue\",\r\n    \"slirp_glue/qemu\",\r\n    \"slirp_glue/qemu/sysemu\",\r\n    \"display\",\r\n    NULL\r\n    };\r\n\r\n\r\nstatic const char *_check_source_allowed_sysincludes[] = {\r\n    \"ctype.h\",\r\n    \"errno.h\",\r\n    \"limits.h\",\r\n    \"math.h\",\r\n    \"setjmp.h\",\r\n    \"stdarg.h\",\r\n    \"stddef.h\",\r\n    \"stdio.h\",\r\n    \"stdlib.h\",\r\n    \"string.h\",\r\n    \"sys/stat.h\",\r\n    \"time.h\",\r\n    \"SDL.h\",\r\n    \"SDL_ttf.h\",\r\n    NULL\r\n    };\r\n\r\nstatic const char *_check_source_platform_defines[] = {\r\n    \"_WIN32\",\r\n    \"__ALPHA\",\r\n    \"__ia64\",\r\n    \"__VMS\",\r\n    \"__unix__\",\r\n    \"__linux\",\r\n    \"__hpux\",\r\n    \"_AIX\",\r\n    \"__APPLE__\",\r\n    \"__FreeBSD__\",\r\n    \"__NetBSD__\",\r\n    \"__OpenBSD__\",\r\n    \"__CYGWIN__\",\r\n    \"__VAX\",\r\n    \"__sun\",\r\n    \"__amd64__\",\r\n    \"__x86_64__\",\r\n    \"__itanium__\",\r\n    \"NDEBUG\",\r\n    \"_DEBUG\",\r\n    NULL\r\n    };\r\n\r\nstatic const char *_check_source_scp_only_apis[] = {\r\n    \"sim_os_ms_sleep\",\r\n    \"sim_reset_time\",\r\n    \"sim_master_sock\",\r\n    \"sim_accept_conn\",\r\n    \"sim_accept_conn_ex\",\r\n    \"sim_connect_sock\",\r\n    \"sim_connect_sock_ex\",\r\n    \"sim_read_sock\",\r\n    \"sim_write_sock\",\r\n    \"sim_close_sock\",\r\n    NULL\r\n    };\r\n\r\ntypedef struct FILE_STATS {\r\n    char RelativePath[PATH_MAX + 1];\r\n    t_offset FileSize;\r\n    int Lines;\r\n    t_bool IsInScpDir;\r\n    t_bool HasBinary;\r\n    t_bool IsSource;\r\n    t_bool HasTabs;\r\n    t_bool HasSimSockInclude;\r\n    int BenignIncludeCount;\r\n    char **BenignIncludes;\r\n    int LocalIncludeCount;\r\n    char **LocalIncludes;\r\n    int SysIncludeCount;\r\n    char **SysIncludes;\r\n    int OtherSysIncludeCount;\r\n    char **OtherSysIncludes;\r\n    int MissingIncludeCount;\r\n    char **MissingIncludes;\r\n    int PlatformDefineCount;\r\n    char **PlatformDefines;\r\n    int ScpAPICount;\r\n    char **ScpAPIs;\r\n    int LineEndingsLF;\r\n    int LineEndingsCRLF;\r\n    t_bool ProblemFile;\r\n    } FILE_STATS;\r\n\r\nstatic char *sim_check_scp_dir = NULL;\r\n\r\nstatic FILE *sim_problem_list = NULL;\r\n\r\nstatic char **sim_exceptions = NULL;\r\nstatic int exception_count = 0;\r\n\r\nstatic t_bool _source_problem_emit (const char *RelativePath, const char *problem, int count, char **list)\r\n{\r\nint i, j;\r\nchar buf[CBUFSIZE];\r\nt_bool result = FALSE;\r\n\r\nfor (i = 0; i < count; i++) {\r\n    snprintf (buf, sizeof (buf), \"%s:%s:%s\", RelativePath, problem, list[i]);\r\n    for (j = 0; j < exception_count; j++)\r\n        if (strcmp (sim_exceptions[j], buf) == 0)\r\n            break;\r\n    if (j < exception_count)\r\n        continue;\r\n    result |= TRUE;\r\n    if (sim_problem_list != NULL)\r\n        fprintf (sim_problem_list, \"%s\\r\\n\", buf);\r\n    }\r\nreturn result;\r\n}\r\n\r\nstatic t_bool _source_problem_check (FILE_STATS *Stats)\r\n{\r\nt_bool result = FALSE;\r\n\r\nif ((!Stats->IsInScpDir) &&\r\n    ((Stats->MissingIncludeCount != 0) ||\r\n     (Stats->OtherSysIncludeCount != 0) ||\r\n     (Stats->PlatformDefineCount != 0)  ||\r\n     (Stats->ScpAPICount != 0))) {\r\n    result |= _source_problem_emit (Stats->RelativePath, \"MissingInclude\", Stats->MissingIncludeCount, Stats->MissingIncludes);\r\n    result |= _source_problem_emit (Stats->RelativePath, \"OtherSysInclude\", Stats->OtherSysIncludeCount, Stats->OtherSysIncludes);\r\n    result |= _source_problem_emit (Stats->RelativePath, \"PlatformDefine\", Stats->PlatformDefineCount, Stats->PlatformDefines);\r\n    result |= _source_problem_emit (Stats->RelativePath, \"ScpAPI\", Stats->ScpAPICount, Stats->ScpAPIs);\r\n    }\r\nreturn result;\r\n}\r\n\r\nstatic void _check_source_check_file (const char *directory,\r\n                                      const char *filename,\r\n                                      t_offset FileSize,\r\n                                      FILE_STATS *Stats)\r\n{\r\nchar filepath[PATH_MAX + 1];\r\nFILE *f;\r\nchar *data;\r\nchar *extension;\r\nchar *dir;\r\nt_offset byte;\r\nsize_t lfcount = 0,\r\n       crlfcount = 0,\r\n       tabcount = 0,\r\n       wscount = 0,\r\n       bincount = 0;\r\nconst char *errmsg;\r\n\r\ndata = (char *)malloc ((size_t)(FileSize + 1));\r\ndata[FileSize] = '\\0';\r\nsnprintf (filepath, sizeof (filepath), \"%s%s\", directory, filename);\r\nstrlcpy (Stats->RelativePath, sim_relative_path (filepath), sizeof (Stats->RelativePath));\r\nextension = sim_filepath_parts (filepath, \"x\");\r\nStats->IsSource = ((0 == strcmp (\".c\", extension)) || (0 == strcmp (\".h\", extension)));\r\ndir = sim_filepath_parts (directory, \"p\");\r\nStats->IsInScpDir = (sim_check_scp_dir != NULL) && (strcmp (dir, sim_check_scp_dir) == 0);\r\nif ((!Stats->IsInScpDir) && (sim_check_scp_dir != NULL)) {\r\n    const char **scp_sub_dir = _check_source_scp_sub_dirs;\r\n\r\n    while (*scp_sub_dir != NULL) {\r\n        char tmp_dir[PATH_MAX + 1];\r\n\r\n        strlcpy (tmp_dir, sim_check_scp_dir, sizeof (tmp_dir));\r\n        strlcat (tmp_dir, *scp_sub_dir, sizeof (tmp_dir));\r\n        strlcat (tmp_dir, &dir[strlen (dir) - 1], sizeof (tmp_dir));\r\n        if (strcmp (dir, tmp_dir) == 0)\r\n            break;\r\n        ++scp_sub_dir;\r\n        }\r\n    Stats->IsInScpDir = (*scp_sub_dir != NULL);\r\n    }\r\nfree (dir);\r\nf = fopen (filepath, \"rb\");\r\nif ((f == NULL) ||\r\n    ((size_t)FileSize != fread (data, 1, (size_t)FileSize, f))) {\r\n    fprintf (stderr, \"Error Opening or Reading: %s - %s\\n\", filepath, strerror (errno));\r\n    fclose (f);\r\n    free (data);\r\n    Stats->ProblemFile = TRUE;\r\n    return;\r\n    }\r\nStats->FileSize = FileSize;\r\nfor (byte=0; (byte < FileSize) && (bincount < 100); ++byte) {\r\n    switch (data[byte]) {\r\n        case '\\n':\r\n            ++lfcount;\r\n            break;\r\n        case '\\r':\r\n            if (data[byte+1] == '\\n')\r\n                ++crlfcount;\r\n            break;\r\n        case '\\t':\r\n            ++tabcount;\r\n            break;\r\n        default:\r\n            if (sim_isspace (data[byte]))\r\n                ++wscount;\r\n            else {\r\n                if (!sim_isprint (data[byte]))\r\n                    ++bincount;\r\n                }\r\n            break;\r\n        }\r\n    }\r\nfclose (f);\r\nif (tabcount > 0)\r\n    Stats->HasTabs = TRUE;\r\nif (Stats->HasTabs && Stats->IsSource)\r\n    Stats->ProblemFile = TRUE;\r\nif (FileSize > 0) {\r\n    if (crlfcount == lfcount)\r\n        Stats->Lines = crlfcount;\r\n    else {\r\n        Stats->Lines = lfcount;\r\n        Stats->ProblemFile = TRUE;\r\n        }\r\n    }\r\nif (bincount > 0)\r\n    Stats->HasBinary = TRUE;\r\nStats->LineEndingsCRLF = crlfcount;\r\nStats->LineEndingsLF = lfcount;\r\nif (Stats->IsSource) {\r\n    static pcre *sys_include_re = NULL;\r\n    static pcre *local_include_re = NULL;\r\n    static pcre *sim_sock_re = NULL;\r\n    int rc;\r\n    int matches = 0;\r\n    int ovec[6];\r\n    int startoffset = 0;\r\n    int erroffset;\r\n    const char **platform_define;\r\n    const char **scp_api;\r\n\r\n    if (sim_sock_re == NULL)\r\n        sim_sock_re = pcre_compile (\"\\\\#\\\\s*include\\\\s+\\\\\\\"sim_sock\\\\.h\\\"\", 0, &errmsg, &erroffset, NULL);\r\n\r\n    matches = 0;\r\n    while (sim_sock_re != NULL) {\r\n        rc = pcre_exec (sim_sock_re, NULL, data, (int)FileSize, startoffset, PCRE_NOTBOL, ovec, 6);\r\n        if (rc == PCRE_ERROR_NOMATCH)\r\n            break;\r\n        ++matches;\r\n        startoffset = ovec[1];\r\n        }\r\n    if ((matches > 0) && (!Stats->IsInScpDir))\r\n        Stats->HasSimSockInclude = TRUE;\r\n\r\n    if (local_include_re == NULL)\r\n        local_include_re = pcre_compile (\"\\\\#\\\\s*include\\\\s+\\\\\\\"(.+)\\\\\\\"\", 0, &errmsg, &erroffset, NULL);\r\n\r\n    matches = startoffset = 0;\r\n    while (local_include_re != NULL) {\r\n        char *local_include;\r\n\r\n        rc = pcre_exec (local_include_re, NULL, data, (int)FileSize, startoffset, PCRE_NOTBOL, ovec, 6);\r\n        if (rc == PCRE_ERROR_NOMATCH)\r\n            break;\r\n        ++matches;\r\n        startoffset = ovec[1];\r\n        local_include = (char *)calloc (1 + ovec[3] - ovec[2], sizeof (*local_include));\r\n        memcpy (local_include, &data[ovec[2]], ovec[3] - ovec[2]);\r\n        ++Stats->LocalIncludeCount;\r\n        Stats->LocalIncludes = (char **)realloc (Stats->LocalIncludes, Stats->LocalIncludeCount * sizeof (*Stats->LocalIncludes));\r\n        Stats->LocalIncludes[Stats->LocalIncludeCount - 1] = local_include;\r\n        }\r\n\r\n    if (sys_include_re == NULL)\r\n        sys_include_re = pcre_compile (\"\\\\#\\\\s*include\\\\s+\\\\<(.+)\\\\>\", 0, &errmsg, &erroffset, NULL);\r\n\r\n    matches = startoffset = 0;\r\n    while (sys_include_re != NULL) {\r\n        char *sys_include;\r\n        t_bool benign_include = FALSE;\r\n        const char **allowed_include = _check_source_allowed_sysincludes;\r\n\r\n        rc = pcre_exec (sys_include_re, NULL, data, (int)FileSize, startoffset, PCRE_NOTBOL, ovec, 6);\r\n        if (rc == PCRE_ERROR_NOMATCH)\r\n            break;\r\n        ++matches;\r\n        startoffset = ovec[3];\r\n        sys_include = (char *)calloc (1 + ovec[3]-ovec[2], sizeof (*sys_include));\r\n        memcpy (sys_include, &data[ovec[2]], ovec[3] - ovec[2]);\r\n        if (Stats->IsInScpDir) {\r\n            ++Stats->SysIncludeCount;\r\n            Stats->SysIncludes = (char **)realloc (Stats->SysIncludes, Stats->SysIncludeCount * sizeof (*Stats->SysIncludes));\r\n            Stats->SysIncludes[Stats->SysIncludeCount - 1] = sys_include;\r\n            }\r\n        else {\r\n            while (*allowed_include != NULL) {\r\n                if (0 == strcmp (sys_include, *allowed_include))\r\n                    break;\r\n                ++allowed_include;\r\n                }\r\n            if (*allowed_include != NULL) {\r\n                ++Stats->BenignIncludeCount;\r\n                Stats->BenignIncludes = (char **)realloc (Stats->BenignIncludes, Stats->BenignIncludeCount * sizeof (*Stats->BenignIncludes));\r\n                Stats->BenignIncludes[Stats->BenignIncludeCount - 1] = sys_include;\r\n                }\r\n            else {\r\n                ++Stats->OtherSysIncludeCount;\r\n                Stats->OtherSysIncludes = (char **)realloc (Stats->OtherSysIncludes, Stats->OtherSysIncludeCount * sizeof (*Stats->OtherSysIncludes));\r\n                Stats->OtherSysIncludes[Stats->OtherSysIncludeCount - 1] = sys_include;\r\n                }\r\n            }\r\n        }\r\n    for (platform_define = _check_source_platform_defines; *platform_define != NULL; ++platform_define) {\r\n        const char *found = strstr (data, *platform_define);\r\n        if (found != NULL) {\r\n            char before = *(found - 1);\r\n            char after = *(found + strlen (*platform_define));\r\n\r\n            if ((isalpha (before) || (before == '_') ||\r\n                (isalpha (after)  || (after  == '_'))))\r\n                continue;\r\n            ++Stats->PlatformDefineCount;\r\n            Stats->PlatformDefines = (char **)realloc (Stats->PlatformDefines, Stats->PlatformDefineCount * sizeof (*Stats->PlatformDefines));\r\n            Stats->PlatformDefines[Stats->PlatformDefineCount - 1] = strdup (*platform_define);\r\n            }\r\n        }\r\n\r\n    for (scp_api = _check_source_scp_only_apis; *scp_api != NULL; ++scp_api) {\r\n        if (strstr (data, *scp_api) != NULL) {\r\n            ++Stats->ScpAPICount;\r\n            Stats->ScpAPIs = (char **)realloc (Stats->ScpAPIs, Stats->ScpAPICount * sizeof (*Stats->ScpAPIs));\r\n            Stats->ScpAPIs[Stats->ScpAPICount - 1] = strdup (*scp_api);\r\n            }\r\n        }\r\n    Stats->ProblemFile |= _source_problem_check (Stats);\r\n    }\r\nfree (extension);\r\nfree (data);\r\n}\r\n\r\ntypedef struct CHECK_STATS {\r\n    int BinaryFiles;\r\n    int SourceFiles;\r\n    int TextFiles;\r\n    int ProblemFiles;\r\n    int FileCount;\r\n    int SourceTotalLineCount;\r\n    int SourceTotalSize;\r\n    FILE_STATS **Files;\r\n    } CHECK_STATS;\r\n\r\nstatic void _check_source_directory_check (const char *directory,\r\n                                           const char *filename,\r\n                                           t_offset FileSize,\r\n                                           const struct stat *filestat,\r\n                                           void *context)\r\n{\r\nCHECK_STATS *Stats = (CHECK_STATS *)context;\r\n\r\nif (filestat->st_mode & S_IFDIR) {\r\n    char dirpath[PATH_MAX + 1];\r\n    char RelativePath[PATH_MAX + 1];\r\n    const char **skip_dir = _check_source_skip_dirs;\r\n    char pathsep = directory[strlen (directory) - 1];\r\n\r\n    /* Ignore directory self and parent */\r\n    if ((0 == strcmp (filename, \".\")) ||\r\n        (0 == strcmp (filename, \"..\")))\r\n        return;\r\n\r\n    /* Ignore uninteresting directories */\r\n    while (*skip_dir != NULL) {\r\n        if (0 == strcmp (filename, *skip_dir))\r\n            return;\r\n        ++skip_dir;\r\n        }\r\n    strlcpy (RelativePath, sim_relative_path (dirpath), sizeof (RelativePath));\r\n\r\n    sim_dir_scan (RelativePath, _check_source_directory_check, Stats);\r\n    }\r\nelse {\r\n    ++Stats->FileCount;\r\n    Stats->Files = (FILE_STATS **)realloc (Stats->Files, Stats->FileCount * sizeof (FILE_STATS **));\r\n    Stats->Files[Stats->FileCount - 1] = (FILE_STATS *)calloc (1, sizeof (FILE_STATS));\r\n    _check_source_check_file (directory, filename, FileSize, Stats->Files[Stats->FileCount - 1]);\r\n    }\r\n}\r\n\r\nstatic void _check_source_scp_check (const char *directory,\r\n                       const char *filename,\r\n                       t_offset FileSize,\r\n                       const struct stat *filestat,\r\n                       void *context)\r\n{\r\nchar **scp_dir = (char **)context;\r\n\r\nif (strcmp (\"scp.c\", filename) == 0)\r\n    *scp_dir = sim_filepath_parts (directory, \"p\");\r\n}\r\n\r\nstatic void _check_source_print_string_list (const char *title, char **list, int count)\r\n{\r\nint i;\r\n\r\nif (count > 0) {\r\n    sim_printf (\"    %s:\\n\", title);\r\n    for (i = 0; i < count; i++)\r\n        sim_printf (\"        %s\\n\", list[i]);\r\n    }\r\n}\r\n\r\nstatic void _check_source_free_string_list (char **list, int count)\r\n{\r\nint i;\r\n\r\nfor (i = 0; i < count; i++)\r\n    free (list[i]);\r\nfree (list);\r\n}\r\n\r\nstatic void _sim_check_source_file_report (FILE_STATS *File, int maxnamelen, t_stat stat, int *SourceLineCount, int *SourceByteCount)\r\n{\r\nif ((sim_switches & SWMASK ('D')) || (File->ProblemFile) ||\r\n    ((stat != SCPE_OK) &&\r\n     ((File->HasSimSockInclude) || (File->BenignIncludeCount != 0)))) {\r\n    sim_printf (\"%*.*s   \", -maxnamelen, -maxnamelen, File->RelativePath);\r\n    sim_printf (\"%8u bytes\", (unsigned int)File->FileSize);\r\n    if (File->Lines)\r\n        sim_printf (\" %5d lines\", File->Lines);\r\n    if (File->IsSource) {\r\n        if (SourceLineCount != NULL)\r\n            *SourceLineCount += File->Lines;\r\n        if (SourceByteCount != NULL)\r\n            *SourceByteCount += (int)File->FileSize;\r\n        if (File->HasTabs)\r\n            sim_printf (\", has-tabs\");\r\n        if (File->HasBinary)\r\n            sim_printf (\", has-binary(non-ascii)\");\r\n        if ((File->LineEndingsCRLF != 0) && (File->LineEndingsCRLF != File->LineEndingsLF))\r\n            sim_printf (\", mixed CRLF and LF line-endings\");\r\n        else {\r\n            if (File->LineEndingsLF == File->LineEndingsCRLF)\r\n                sim_printf (\", CRLF line-endings\");\r\n            else\r\n                sim_printf (\", LF line-endings\");\r\n            }\r\n        }\r\n    sim_printf (\"\\n\");\r\n    if (File->HasSimSockInclude)\r\n        sim_printf (\"Has unneeded include of sim_sock.h\\n\");\r\n    _check_source_print_string_list (\"Benign (unneeded) System Include Files\", File->BenignIncludes,   File->BenignIncludeCount);\r\n    _check_source_print_string_list (\"Local Include Files\",                    File->LocalIncludes,    File->LocalIncludeCount);\r\n    _check_source_print_string_list (\"System Include Files\",                   File->SysIncludes,      File->SysIncludeCount);\r\n    _check_source_print_string_list (\"Other System Include Files\",             File->OtherSysIncludes, File->OtherSysIncludeCount);\r\n    _check_source_print_string_list (\"Missing Include Files\",                  File->MissingIncludes,  File->MissingIncludeCount);\r\n    _check_source_print_string_list (\"Platform Specific Defines\",              File->PlatformDefines,  File->PlatformDefineCount);\r\n    _check_source_print_string_list (\"SCP Private APIs\",                       File->ScpAPIs,          File->ScpAPICount);\r\n    }\r\n_check_source_free_string_list (File->BenignIncludes,   File->BenignIncludeCount);\r\n_check_source_free_string_list (File->LocalIncludes,    File->LocalIncludeCount);\r\n_check_source_free_string_list (File->SysIncludes,      File->SysIncludeCount);\r\n_check_source_free_string_list (File->OtherSysIncludes, File->OtherSysIncludeCount);\r\n_check_source_free_string_list (File->MissingIncludes,  File->MissingIncludeCount);\r\n_check_source_free_string_list (File->PlatformDefines,  File->PlatformDefineCount);\r\n_check_source_free_string_list (File->ScpAPIs,          File->ScpAPICount);\r\nfree (File);\r\n}\r\n\r\nstatic void _check_source_add_needed_include (FILE_STATS *File, const char *include_file, CHECK_STATS *Stats)\r\n{\r\nchar filepath[PATH_MAX + 1];\r\nint file;\r\nchar **files;\r\n\r\nif (sim_check_scp_dir == NULL)\r\n    return;\r\n\r\nfor (file = 0; file < Stats->FileCount; file++) {\r\n    char *filename = sim_filepath_parts (Stats->Files[file]->RelativePath, \"nx\");\r\n\r\n    if (strcmp (include_file, filename) == 0) {\r\n        free (filename);\r\n        break;\r\n        }\r\n    free (filename);\r\n    }\r\nif (file == Stats->FileCount) {\r\n    char *filename;\r\n    char *filedir;\r\n\r\n    snprintf (filepath, sizeof (filepath), \"%s%s\", sim_check_scp_dir, include_file);\r\n    filename = sim_filepath_parts (filepath, \"nx\");\r\n    filedir = sim_filepath_parts (filepath, \"p\");\r\n    if (strchr (include_file, filedir[strlen (filedir) - 1]) != NULL)\r\n        snprintf (filepath, sizeof (filepath), \"%s%s\", sim_check_scp_dir, filename);\r\n    free (filename);\r\n    free (filedir);\r\n    files = sim_get_filelist (filepath);\r\n    if (files != NULL) {\r\n        char RelativePath[PATH_MAX + 1];\r\n\r\n        strlcpy (RelativePath, sim_relative_path (files[0]), sizeof (RelativePath));\r\n\r\n        for (file = 0; file < Stats->FileCount; file++) {\r\n            if (strcmp (RelativePath, Stats->Files[file]->RelativePath) == 0)\r\n                break;\r\n            }\r\n        if (file == Stats->FileCount) {\r\n            struct stat statb;\r\n            char *directory = sim_filepath_parts (files[0], \"p\");\r\n            char *filename = sim_filepath_parts (files[0], \"nx\");\r\n\r\n            sim_stat (files[0], &statb);\r\n            ++Stats->FileCount;\r\n            Stats->Files = (FILE_STATS **)realloc (Stats->Files, Stats->FileCount * sizeof (FILE_STATS **));\r\n            Stats->Files[Stats->FileCount - 1] = (FILE_STATS *)calloc (1, sizeof (FILE_STATS));\r\n            _check_source_check_file (directory, filename, statb.st_size, Stats->Files[Stats->FileCount - 1]);\r\n            free (directory);\r\n            free (filename);\r\n            }\r\n        }\r\n    else {\r\n        ++File->MissingIncludeCount;\r\n        File->MissingIncludes = (char **)realloc (File->MissingIncludes, File->MissingIncludeCount * sizeof (*File->MissingIncludes));\r\n        File->MissingIncludes[File->MissingIncludeCount - 1] = strdup (include_file);\r\n        if (!File->IsInScpDir)\r\n            File->ProblemFile |= _source_problem_check (File);\r\n        }\r\n    sim_free_filelist (&files);\r\n    }\r\n}\r\n\r\nstatic int _check_source_compare (const void *pa, const void *pb)\r\n{\r\nchar **a = (char **)pa;\r\nchar **b = (char **)pb;\r\n\r\nreturn strcasecmp(*a, *b);\r\n}\r\n\r\n\r\nstatic t_stat _sim_check_source_report (CHECK_STATS *Stats)\r\n{\r\nt_stat stat = SCPE_OK;\r\nint file, namelen;\r\n\r\nqsort (Stats->Files, Stats->FileCount, sizeof (Stats->Files[0]), _check_source_compare);\r\nfor (file = namelen = 0; file < Stats->FileCount; file++) {\r\n    if (namelen < (int)strlen (Stats->Files[file]->RelativePath))\r\n        namelen = (int)strlen (Stats->Files[file]->RelativePath);\r\n    }\r\n\r\n/* Populate Counts */\r\nfor (file = 0; file < Stats->FileCount; file++) {\r\n    if (Stats->Files[file]->HasBinary)\r\n        ++Stats->BinaryFiles;\r\n    else\r\n        ++Stats->TextFiles;\r\n    if (Stats->Files[file]->IsSource)\r\n        ++Stats->SourceFiles;\r\n    if (Stats->Files[file]->ProblemFile)\r\n        ++Stats->ProblemFiles;\r\n    }\r\n/* Report Results */\r\nif ((sim_check_scp_dir != NULL) &&\r\n    ((sim_switches & SWMASK ('D')) || (Stats->ProblemFiles > 0))) {\r\n    sim_printf (\"scp.c directory: %s\\n\", sim_relative_path (sim_check_scp_dir));\r\n    free (sim_check_scp_dir);\r\n    sim_check_scp_dir = NULL;\r\n    }\r\nfor (file = 0; file < Stats->FileCount; file++)\r\n    _sim_check_source_file_report (Stats->Files[file], namelen, stat, &Stats->SourceTotalLineCount, &Stats->SourceTotalSize);\r\nif (sim_switches & SWMASK ('D')) {\r\n    sim_printf (\"Source Code Total Files: %d, \", Stats->FileCount);\r\n    sim_printf (\"Total Lines: %s, \", sim_fmt_numeric ((double)Stats->SourceTotalLineCount));\r\n    sim_printf (\"Total Size: %s bytes\\n\", sim_fmt_numeric ((double)Stats->SourceTotalSize));\r\n    }\r\nif (Stats->ProblemFiles > 0)\r\n    stat = SCPE_FMT;\r\nfree (Stats->Files);\r\nfree (Stats);\r\nif (sim_switches & SWMASK ('E')) /* -E switch means don't return any error */\r\n    stat = SCPE_OK;\r\nreturn stat;\r\n}\r\n\r\nint\r\nsim_check_source (int argc, char **argv)\r\n{\r\nCHECK_STATS *Stats = (CHECK_STATS *)calloc (1, sizeof (*Stats));\r\nint i, file;\r\nstatic const char *source_skip_dirs[] = { \".git\", \"BIN\", NULL};\r\n\r\nif (sim_switches & SWMASK ('D')) {\r\n    sim_printf (\"Check Source args:\");\r\n    for (i = 0; i < argc; i++)\r\n        sim_printf (\" %s\", argv[i]);\r\n    sim_printf (\"\\n\");\r\n    }\r\nif (sim_switches & SWMASK ('X'))\r\n    sim_problem_list = fopen(\"Source.Errors\", \"ab\");\r\nif (sim_switches & SWMASK ('A')) {\r\n    FILE *f = fopen (\"Source.Exceptions\", \"r\");\r\n\r\n    if (f != NULL) {\r\n        char buf[CBUFSIZE];\r\n\r\n        while (fgets (buf, sizeof (buf), f)) {\r\n            size_t len = strlen (buf);\r\n\r\n            while ((len > 0) && isspace (buf[len - 1]))\r\n                buf[len - 1] = '\\0';\r\n            ++exception_count;\r\n            sim_exceptions = (char **)realloc (sim_exceptions, exception_count * sizeof (*sim_exceptions));\r\n            sim_exceptions[exception_count - 1] = strdup (buf);\r\n            }\r\n        fclose (f);\r\n        }\r\n    }\r\nfree (sim_check_scp_dir);\r\nsim_check_scp_dir = NULL;\r\nsim_set_get_filelist_skip_directories (source_skip_dirs);\r\n/* Find the directory where scp.c is located */\r\nfor (i = 1; i < argc; i++) {\r\n    if (sim_check_scp_dir != NULL)\r\n        break;\r\n    sim_dir_scan (argv[i], _check_source_scp_check, &sim_check_scp_dir);\r\n    }\r\n/* Process the list of files */\r\nwhile (--argc > 0) {\r\n    ++argv;\r\n    sim_dir_scan (*argv, _check_source_directory_check, Stats);\r\n    }\r\n/* Add includes to the file list if they're not there */\r\nfor (file = 0; file < Stats->FileCount; file++) {\r\n    int include;\r\n\r\n    for (include = 0; include < Stats->Files[file]->LocalIncludeCount; include++) {\r\n        _check_source_add_needed_include (Stats->Files[file], Stats->Files[file]->LocalIncludes[include], Stats);\r\n        }\r\n    }\r\nsim_clear_get_filelist_skip_directories ();\r\n_flush_filelist_directory_cache ();\r\nif (sim_problem_list != NULL) {\r\n    fclose (sim_problem_list);\r\n    sim_problem_list = NULL;\r\n    }\r\nreturn _sim_check_source_report (Stats);\r\n}\r\n"
        },
        {
          "name": "sim_fio.h",
          "type": "blob",
          "size": 8.18359375,
          "content": "/* sim_fio.h: simulator file I/O library headers\r\n\r\n   Copyright (c) 1993-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   be used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   02-Feb-11    MP      Added sim_fsize_ex and sim_fsize_name_ex returning t_addr\r\n                        Added export of sim_buf_copy_swapped and sim_buf_swap_data\r\n   15-May-06    RMS     Added sim_fsize_name\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   02-Jan-04    RMS     Split out from SCP\r\n*/\r\n\r\n#ifndef SIM_FIO_H_\r\n#define SIM_FIO_H_     0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <sys/stat.h>\r\n\r\n#define FLIP_SIZE       (1 << 16)                       /* flip buf size */\r\n#define fxread(a,b,c,d)         sim_fread (a, b, c, d)\r\n#define fxwrite(a,b,c,d)        sim_fwrite (a, b, c, d)\r\n\r\n#if ((defined (__linux) || defined (__linux__)) && (defined (__ANDROID_API__) && (__ANDROID_API__ < 24)))\r\n#define DONT_DO_LARGEFILE 1\r\n#endif\r\nint32 sim_finit (void);\r\n#if (defined (__linux) || defined (__linux__) || defined (__hpux) || defined (_AIX) ||         \\\r\n     (defined (VMS) && (defined (__ALPHA) || defined (__ia64)) && (__DECC_VER >= 60590001)) || \\\r\n     ((defined(__sun) || defined(__sun__)) && defined(_LARGEFILE_SOURCE)) ||                   \\\r\n     defined (_WIN32) || defined (__APPLE__) || defined (__CYGWIN__) ||                        \\\r\n     defined (__FreeBSD__) || defined(__NetBSD__) || defined (__OpenBSD__)) && !defined (DONT_DO_LARGEFILE)\r\ntypedef t_int64        t_offset;\r\n#else\r\ntypedef int32        t_offset;\r\n#if !defined (DONT_DO_LARGEFILE)\r\n#define DONT_DO_LARGEFILE 1\r\n#endif\r\n#endif\r\nFILE *sim_fopen (const char *file, const char *mode);\r\nint sim_fseek (FILE *st, t_addr offset, int whence);\r\nint sim_fseeko (FILE *st, t_offset offset, int whence);\r\nt_bool sim_can_seek (FILE *st);\r\nint sim_set_fsize (FILE *fptr, t_addr size);\r\nt_stat sim_set_file_times (const char *file_name, time_t access_time, time_t write_time);\r\nint sim_set_fifo_nonblock (FILE *fptr);\r\nsize_t sim_fread (void *bptr, size_t size, size_t count, FILE *fptr);\r\nsize_t sim_fwrite (const void *bptr, size_t size, size_t count, FILE *fptr);\r\nuint32 sim_fsize (FILE *fptr);\r\nuint32 sim_fsize_name (const char *fname);\r\nt_offset sim_ftell (FILE *st);\r\nt_offset sim_fsize_ex (FILE *fptr);\r\nt_offset sim_fsize_name_ex (const char *fname);\r\nint sim_stat (const char *fname, struct stat *stat_str);\r\nint sim_chdir(const char *path);\r\nint sim_mkdir(const char *path);\r\nint sim_rmdir(const char *path);\r\nt_stat sim_copyfile (const char *source_file, const char *dest_file, t_bool overwrite_existing);\r\nchar *sim_filepath_parts (const char *pathname, const char *parts);\r\nconst char *sim_relative_path (const char *filepath);\r\nchar *sim_getcwd (char *buf, size_t buf_size);\r\ntypedef void (*DIR_ENTRY_CALLBACK)(const char *directory,\r\n                                   const char *filename,\r\n                                   t_offset FileSize,\r\n                                   const struct stat *filestat,\r\n                                   void *context);\r\nt_stat sim_dir_scan (const char *cptr, DIR_ENTRY_CALLBACK entry, void *context);\r\nchar **sim_get_filelist (const char *filename);\r\nvoid sim_set_get_filelist_skip_directories (const char * const *dirlist);\r\nvoid sim_clear_get_filelist_skip_directories (void);\r\nvoid sim_free_filelist (char ***pfilelist);\r\nvoid sim_print_filelist (char **filelist);\r\nint sim_count_filelist (char **filelist);\r\n\r\nvoid sim_buf_swap_data (void *bptr, size_t size, size_t count);\r\nvoid sim_byte_swap_data (void *bptr, size_t size, size_t count);\r\nvoid sim_buf_copy_swapped (void *dptr, const void *bptr, size_t size, size_t count);\r\nt_bool sim_buf_pack_unpack (const void *sptr,          /* source buffer pointer */\r\n                            void *dptr,                /* destination buffer pointer */\r\n                            uint32 sbits,              /* source buffer element size in bits */\r\n                            t_bool sLSB_o_numbering,   /* source numbered using LSB ordering */\r\n                            uint32 scount,             /* count of source elements */\r\n                            uint32 dbits,              /* interesting bits of each destination element */\r\n                            t_bool dLSB_o_numbering);  /* destination numbered using LSB ordering */\r\nt_stat sim_fio_test (const char *cptr);\r\nconst char *sim_get_os_error_text (int error);\r\ntypedef struct SHMEM SHMEM;\r\nt_stat sim_shmem_open (const char *name, size_t size, SHMEM **shmem, void **addr);\r\nvoid sim_shmem_close (SHMEM *shmem);\r\nint32 sim_shmem_atomic_add (int32 *ptr, int32 val);\r\nt_bool sim_shmem_atomic_cas (int32 *ptr, int32 oldv, int32 newv);\r\nextern int sim_check_source (int argc, char **argv);\r\n\r\nextern t_bool sim_taddr_64;         /* t_addr is > 32b and Large File Support available */\r\nextern t_bool sim_toffset_64;       /* Large File (>2GB) file I/O support */\r\nextern t_bool sim_end;              /* TRUE = little endian, FALSE = big endian */\r\n\r\nextern const char sim_file_path_separator;  /* Platform specific value \\ or / as appropriate */\r\n\r\nchar *sim_trim_endspc (char *cptr);\r\nint sim_isspace (int c);\r\n#ifdef isspace\r\n#undef isspace\r\n#endif\r\n#ifndef IN_SIM_FIO_C\r\n#define isspace(chr) sim_isspace (chr)\r\n#endif\r\nint sim_islower (int c);\r\n#ifdef islower\r\n#undef islower\r\n#endif\r\n#define islower(chr) sim_islower (chr)\r\nint sim_isupper (int c);\r\n#ifdef isupper\r\n#undef isupper\r\n#endif\r\n#define isupper(chr) sim_isupper (chr)\r\nint sim_isalpha (int c);\r\n#ifdef isalpha\r\n#undef isalpha\r\n#endif\r\n#ifndef IN_SIM_FIO_C\r\n#define isalpha(chr) sim_isalpha (chr)\r\n#endif\r\nint sim_isprint (int c);\r\n#ifdef isprint\r\n#undef isprint\r\n#endif\r\n#ifndef IN_SIM_FIO_C\r\n#define isprint(chr) sim_isprint (chr)\r\n#endif\r\nint sim_isdigit (int c);\r\n#ifdef isdigit\r\n#undef isdigit\r\n#endif\r\n#define isdigit(chr) sim_isdigit (chr)\r\nint sim_isgraph (int c);\r\n#ifdef isgraph\r\n#undef isgraph\r\n#endif\r\n#ifndef IN_SIM_FIO_C\r\n#define isgraph(chr) sim_isgraph (chr)\r\n#endif\r\nint sim_isalnum (int c);\r\n#ifdef isalnum\r\n#undef isalnum\r\n#endif\r\n#ifndef IN_SIM_FIO_C\r\n#define isalnum(chr) sim_isalnum (chr)\r\n#endif\r\nint sim_toupper (int c);\r\nint sim_tolower (int c);\r\n#ifdef toupper\r\n#undef toupper\r\n#endif\r\n#define toupper(chr) sim_toupper(chr)\r\n#ifdef tolower\r\n#undef tolower\r\n#endif\r\n#define tolower(chr) sim_tolower(chr)\r\nint sim_strncasecmp (const char *string1, const char *string2, size_t len);\r\nint sim_strcasecmp (const char *string1, const char *string2);\r\nsize_t sim_strlcat (char *dst, const char *src, size_t size);\r\nsize_t sim_strlcpy (char *dst, const char *src, size_t size);\r\n#ifndef strlcpy\r\n#define strlcpy(dst, src, size) sim_strlcpy((dst), (src), (size))\r\n#endif\r\n#ifndef strlcat\r\n#define strlcat(dst, src, size) sim_strlcat((dst), (src), (size))\r\n#endif\r\n#ifndef strncasecmp\r\n#define strncasecmp(str1, str2, len) sim_strncasecmp((str1), (str2), (len))\r\n#endif\r\n#ifndef strcasecmp\r\n#define strcasecmp(str1, str2) sim_strcasecmp ((str1), (str2))\r\n#endif\r\nint sim_strwhitecasecmp (const char *string1, const char *string2, t_bool casecmp);\r\n\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_frontpanel.c",
          "type": "blob",
          "size": 102.9140625,
          "content": "/* sim_frontpanel.c: simulator frontpanel API\r\n\r\n   Copyright (c) 2015, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   MARK PIZZOLATO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Mark Pizzolato shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Mark Pizzolato.\r\n\r\n   05-Feb-15    MP      Initial implementation\r\n   01-Apr-15    MP      Added register indirect, mem_examine and mem_deposit\r\n   03-Apr-15    MP      Added logic to pass simulator startup messages in\r\n                        panel error text if the connection to the simulator\r\n                        shuts down while it is starting.\r\n   04-Apr-15    MP      Added mount and dismount routines to connect and\r\n                        disconnect removable media\r\n\r\n   This module provides interface between a front panel application and a simh\r\n   simulator.  Facilities provide ways to gather information from and to\r\n   observe and control the state of a simulator.\r\n\r\n   The details of the 'wire protocol' are internal to the API interfaces\r\n   provided here and described in sim_frontpanel.h.  These details are subject\r\n   to change from one sim_frontpanel version to the next, while all efforts\r\n   will be made to retain any prior sim_frontpanel API interfaces.\r\n\r\n*/\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"sim_sock.h\"\r\n\r\n#include \"sim_frontpanel.h\"\r\n\r\n#include <stdio.h>\r\n#include <stdarg.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n#include <sys/stat.h>\r\n#include <errno.h>\r\n#include <signal.h>\r\n#include <pthread.h>\r\n\r\n#if defined(_WIN32)\r\n#include <process.h>\r\n#include <windows.h>\r\n#include <winerror.h>\r\n#define sleep(n) Sleep(n*1000)\r\n#define msleep(n) Sleep(n)\r\n#define strtoull _strtoui64\r\n#define CLOCK_REALTIME 0\r\nint clock_gettime(int clk_id, struct timespec *tp)\r\n{\r\nunsigned long long now, unixbase;\r\n\r\nunixbase = 116444736;\r\nunixbase *= 1000000000;\r\nGetSystemTimeAsFileTime((FILETIME*)&now);\r\nnow -= unixbase;\r\ntp->tv_sec = (long)(now/10000000);\r\ntp->tv_nsec = (now%10000000)*100;\r\nreturn 0;\r\n}\r\n\r\nstatic const char *GetErrorText (DWORD dwError)\r\n{\r\nstatic __declspec (thread) char szMsgBuffer[2048];\r\nDWORD dwStatus;\r\n\r\ndwStatus = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM|\r\n                          FORMAT_MESSAGE_IGNORE_INSERTS,     //  __in      DWORD dwFlags,\r\n                          NULL,                              //  __in_opt  LPCVOID lpSource,\r\n                          dwError,                           //  __in      DWORD dwMessageId,\r\n                          0,                                 //  __in      DWORD dwLanguageId,\r\n                          szMsgBuffer,                       //  __out     LPTSTR lpBuffer,\r\n                          2048,                              //  __in      DWORD nSize,\r\n                          NULL);                             //  __in_opt  va_list *Arguments\r\nif (0 == dwStatus)\r\n    _snprintf(szMsgBuffer, sizeof(szMsgBuffer), \"Error Code: %d\", dwError);\r\nwhile (isspace(szMsgBuffer[strlen(szMsgBuffer)-1]))\r\n    szMsgBuffer[strlen(szMsgBuffer)-1] = '\\0';\r\nreturn szMsgBuffer;\r\n}\r\n\r\n#define SET_THREAD_NAME(name) pthread_setname_np (pthread_self(), name)\r\n\r\n#else /* NOT _WIN32 */\r\n#include <unistd.h>\r\n#define msleep(n) usleep(1000*n)\r\n#include <sys/wait.h>\r\n#if defined (__APPLE__)\r\n#define HAVE_STRUCT_TIMESPEC 1   /* OSX defined the structure but doesn't tell us */\r\n#endif\r\n\r\n/* on HP-UX, CLOCK_REALTIME is enum, not preprocessor define */\r\n#if !defined(CLOCK_REALTIME) && !defined(__hpux)\r\n#define CLOCK_REALTIME 1\r\n#define NEED_CLOCK_GETTIME 1\r\n#if !defined(HAVE_STRUCT_TIMESPEC)\r\n#define HAVE_STRUCT_TIMESPEC\r\n#if !defined(_TIMESPEC_DEFINED)\r\n#define _TIMESPEC_DEFINED\r\nstruct timespec {\r\n    long   tv_sec;\r\n    long   tv_nsec;\r\n};\r\n#endif /* _TIMESPEC_DEFINED */\r\n#endif /* HAVE_STRUCT_TIMESPEC */\r\n#if defined(NEED_CLOCK_GETTIME)\r\nint clock_gettime(int clk_id, struct timespec *tp)\r\n{\r\nstruct timeval cur;\r\nstruct timezone foo;\r\n\r\ngettimeofday (&cur, &foo);\r\ntp->tv_sec = cur.tv_sec;\r\ntp->tv_nsec = cur.tv_usec*1000;\r\nreturn 0;\r\n}\r\n#endif /* defined(NEED_CLOCK_GETTIME) */\r\n#endif /* !defined(CLOCK_REALTIME) && !defined(__hpux) */\r\n\r\n#if (defined(__linux) || defined(__linux__))\r\n#define SET_THREAD_NAME(name) pthread_setname_np (pthread_self(), name)\r\n#else\r\n#if defined(__APPLE__)\r\n#define SET_THREAD_NAME(name) pthread_setname_np (name)\r\n#else\r\n#define SET_THREAD_NAME(name)\r\n#endif\r\n#endif\r\n\r\n#endif /* NOT _WIN32 */\r\n\r\ntypedef struct {\r\n    char *name;\r\n    char *device_name;\r\n    void *addr;\r\n    size_t size;\r\n    int indirect;\r\n    size_t element_count;\r\n    int *bits;\r\n    size_t bit_count;\r\n    } REG;\r\n\r\nstruct PANEL {\r\n    PANEL                   *parent;        /* Device Panels can have parent panels */\r\n    char                    *path;          /* simulator path */\r\n    char                    *config;\r\n    char                    *device_name;   /* device name */\r\n    char                    *temp_config;\r\n    char                    hostport[64];\r\n    size_t                  device_count;\r\n    PANEL                   **devices;\r\n    SOCKET                  sock;\r\n    size_t                  reg_count;\r\n    REG                     *regs;\r\n    char                    *reg_query;\r\n    int                     new_register;\r\n    size_t                  reg_query_size;\r\n    unsigned long long      array_element_data;\r\n    volatile OperationalState State;\r\n    unsigned long long      simulation_time;\r\n    unsigned long long      simulation_time_base;\r\n    pthread_t               creating_thread;\r\n    pthread_t               io_thread;\r\n    int                     io_thread_running;\r\n    pthread_mutex_t         io_lock;\r\n    pthread_mutex_t         io_send_lock;\r\n    pthread_mutex_t         io_command_lock;\r\n    pthread_mutex_t         debug_lock;\r\n    int                     command_count;\r\n    int                     io_waiting;\r\n    char                    *io_response;\r\n    char                    *halt_reason;\r\n    size_t                  io_response_data;\r\n    size_t                  io_response_size;\r\n    const char              *completion_string;\r\n    pthread_cond_t          io_done;\r\n    pthread_cond_t          startup_done;\r\n    PANEL_DISPLAY_PCALLBACK callback;\r\n    pthread_t               callback_thread;\r\n    int                     callback_thread_running;\r\n    void                    *callback_context;\r\n    int                     usecs_between_callbacks;\r\n    pthread_t               debugflush_thread;\r\n    int                     debugflush_thread_running;\r\n    unsigned int            sample_frequency;\r\n    unsigned int            sample_dither_pct;\r\n    unsigned int            sample_depth;\r\n    int                     debug;\r\n    char                    *simulator_version;\r\n    int                     radix;\r\n    FILE                    *Debug;\r\n#if defined(_WIN32)\r\n    HANDLE                  hProcess;\r\n    DWORD                   dwProcessId;\r\n#else\r\n    pid_t                   pidProcess;\r\n#endif\r\n    };\r\n\r\n/*\r\n * Thread synchronization model:\r\n *\r\n *  Mutex:               Role:\r\n *   io_lock             Serialize access to panel state variables\r\n *                        acquired and released in application threads:\r\n *                                                  _panel_register_query_string,\r\n *                                                  _panel_establish_register_bits_collection,\r\n *                                                  _panel_sendf\r\n *                        acquired and released in internal threads:\r\n *                                                  _panel_callback\r\n *                                                  _panel_reader\r\n *   io_send_lock        Serializes writes to a panel's sockets so that complete\r\n *                       command/request data can be delivered before another\r\n *                       thread attempts to write to the socket.\r\n *                        acquired and released in: _panel_send\r\n *   io_command_lock     To serialize frontpanel application command requests\r\n *                        acquired and released in: _panel_get_registers,\r\n *                                                  _panel_sendf_completion\r\n *   debug_lock          To serialize writing debug information activities\r\n *                        acquired and released in: __panel_vdebug,\r\n *                                                  _panel_debugflusher\r\n *\r\n *  Condition Var:  Sync Mutex:  Purpose & Duration:\r\n *   io_done        io_lock\r\n *   startup_done   io_lock      Indicate background thread setup is complete.\r\n *                               Once signaled, it is immediately destroyed.\r\n */\r\n\r\nstatic const char *sim_prompt = \"sim> \";\r\nstatic const char *register_repeat_prefix = \"repeat every \";\r\nstatic const char *register_repeat_stop = \"repeat stop\";\r\nstatic const char *register_repeat_stop_all = \"repeat stop all\";\r\nstatic const char *register_repeat_units = \" usecs \";\r\nstatic const char *register_get_prefix = \"show time\";\r\nstatic const char *register_collect_prefix = \"collect \";\r\nstatic const char *register_collect_mid1 = \" samples every \";\r\nstatic const char *register_collect_mid2 = \" cycles dither \";\r\nstatic const char *register_collect_mid3 = \" percent \";\r\nstatic const char *register_get_postfix = \"sampleout\";\r\nstatic const char *register_get_start = \"# REGISTERS-START\";\r\nstatic const char *register_get_end = \"# REGISTERS-DONE\";\r\nstatic const char *register_repeat_start = \"# REGISTERS-REPEAT-START\";\r\nstatic const char *register_repeat_end = \"# REGISTERS-REPEAT-DONE\";\r\nstatic const char *register_dev_echo = \"# REGISTERS-FOR-DEVICE:\";\r\nstatic const char *register_ind_echo = \"# REGISTER-INDIRECT:\";\r\nstatic const char *command_status = \"ECHO Status:%STATUS%-%TSTATUS%\";\r\nstatic const char *command_done_echo = \"# COMMAND-DONE\";\r\nstatic int little_endian;\r\nstatic void *_panel_reader(void *arg);\r\nstatic void *_panel_callback(void *arg);\r\nstatic void *_panel_debugflusher(void *arg);\r\nstatic int sim_panel_set_error (PANEL *p, const char *fmt, ...);\r\nstatic pthread_key_t panel_thread_id;\r\n\r\n#define TN_IAC          0xFFu /* -1 */                  /* protocol delim */\r\n#define TN_DONT         0xFEu /* -2 */                  /* dont */\r\n#define TN_DO           0xFDu /* -3 */                  /* do */\r\n#define TN_WONT         0xFCu /* -4 */                  /* wont */\r\n#define TN_WILL         0xFBu /* -5 */                  /* will */\r\n\r\n#define TN_BIN            0                             /* bin */\r\n#define TN_ECHO           1                             /* echo */\r\n#define TN_SGA            3                             /* sga */\r\n#define TN_CR           015                             /* carriage return */\r\n#define TN_LF           012                             /* line feed */\r\n#define TN_LINE          34                             /* line mode */\r\n\r\nstatic unsigned char mantra[] = {\r\n    TN_IAC, TN_WILL, TN_LINE,\r\n    TN_IAC, TN_WILL, TN_SGA,\r\n    TN_IAC, TN_WILL, TN_ECHO,\r\n    TN_IAC, TN_WILL, TN_BIN,\r\n    TN_IAC, TN_DO, TN_BIN\r\n    };\r\n\r\nstatic void *\r\n_panel_malloc (size_t size)\r\n{\r\nvoid *p = malloc (size);\r\n\r\nif (p == NULL)\r\n    sim_panel_set_error (NULL, \"Out of Memory\");\r\nreturn p;\r\n}\r\n\r\n/* Allow compiler to help validate printf style format arguments */\r\n#if !defined __GNUC__\r\n#define GCC_FMT_ATTR(n, m)\r\n#endif\r\n#if !defined(GCC_FMT_ATTR)\r\n#define GCC_FMT_ATTR(n, m) __attribute__ ((format (__printf__, n, m)))\r\n#endif\r\n\r\nstatic void __panel_debug (PANEL *p, int dbits, const char *fmt, const char *buf, int bufsize, ...) GCC_FMT_ATTR(3, 6);\r\n#define _panel_debug(p, dbits, fmt, buf, bufsize, ...) do { if (p && p->Debug && ((dbits) & p->debug)) __panel_debug (p, dbits, fmt, buf, bufsize, ##__VA_ARGS__);} while (0)\r\n\r\nstatic void __panel_vdebug (PANEL *p, int dbits, const char *fmt, const char *buf, int bufsize, va_list arglist)\r\n{\r\nsize_t obufsize = 10240 + 9*bufsize;\r\n\r\nwhile (p && p->Debug && (dbits & p->debug)) {\r\n    int i, len;\r\n    struct timespec time_now;\r\n    char timestamp[32];\r\n    char threadname[50];\r\n    char *obuf = (char *)_panel_malloc (obufsize);\r\n\r\n    clock_gettime(CLOCK_REALTIME, &time_now);\r\n    sprintf (timestamp, \"%lld.%03d \", (long long)(time_now.tv_sec), (int)(time_now.tv_nsec/1000000));\r\n    sprintf (threadname, \"%s:%s \", p->parent ? p->device_name : \"CPU\", (pthread_getspecific (panel_thread_id)) ? (const char *)pthread_getspecific (panel_thread_id) : \"\");\r\n\r\n    obuf[obufsize - 1] = '\\0';\r\n    len = vsnprintf (obuf, obufsize - 1, fmt, arglist);\r\n    if (len < 0)\r\n        return;\r\n    /* If the formatted result didn't fit into the buffer, then grow the buffer and try again */\r\n    if (len >= (int)(obufsize - 9*bufsize)) {\r\n        obufsize = len + 1 + 9*bufsize;\r\n        free (obuf);\r\n        continue;\r\n        }\r\n\r\n    for (i=0; i<bufsize; ++i) {\r\n        switch ((unsigned char)buf[i]) {\r\n            case TN_CR:\r\n                sprintf (&obuf[strlen (obuf)], \"_TN_CR_\");\r\n                break;\r\n            case TN_LF:\r\n                sprintf (&obuf[strlen (obuf)], \"_TN_LF_\");\r\n                break;\r\n            case TN_IAC:\r\n                sprintf (&obuf[strlen (obuf)], \"_TN_IAC_\");\r\n                switch ((unsigned char)buf[i+1]) {\r\n                    case TN_IAC:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_IAC_\"); ++i;\r\n                        break;\r\n                    case TN_DONT:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_DONT_\"); ++i;\r\n                        break;\r\n                    case TN_DO:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_DO_\"); ++i;\r\n                        break;\r\n                    case TN_WONT:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_WONT_\"); ++i;\r\n                        break;\r\n                    case TN_WILL:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_WILL_\"); ++i;\r\n                        break;\r\n                    default:\r\n                        sprintf (&obuf[strlen (obuf)], \"_0x%02X_\", (unsigned char)buf[i+1]); ++i;\r\n                        break;\r\n                    }\r\n                switch ((unsigned char)buf[i+1]) {\r\n                    case TN_BIN:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_BIN_\"); ++i;\r\n                        break;\r\n                    case TN_ECHO:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_ECHO_\"); ++i;\r\n                        break;\r\n                    case TN_SGA:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_SGA_\"); ++i;\r\n                        break;\r\n                    case TN_LINE:\r\n                        sprintf (&obuf[strlen (obuf)], \"_TN_LINE_\"); ++i;\r\n                        break;\r\n                    default:\r\n                        sprintf (&obuf[strlen (obuf)], \"_0x%02X_\", (unsigned char)buf[i+1]); ++i;\r\n                        break;\r\n                    }\r\n                    break;\r\n            default:\r\n                if (isprint((u_char)buf[i]))\r\n                    sprintf (&obuf[strlen (obuf)], \"%c\", buf[i]);\r\n                else {\r\n                    sprintf (&obuf[strlen (obuf)], \"_\");\r\n                    if ((buf[i] >= 1) && (buf[i] <= 26))\r\n                        sprintf (&obuf[strlen (obuf)], \"^%c\", 'A' + buf[i] - 1);\r\n                    else\r\n                        sprintf (&obuf[strlen (obuf)], \"\\\\%03o\", (u_char)buf[i]);\r\n                    sprintf (&obuf[strlen (obuf)], \"_\");\r\n                    }\r\n                break;\r\n            }\r\n        }\r\n    if (p->io_thread_running)\r\n        pthread_mutex_lock (&p->debug_lock);\r\n    fprintf(p->Debug ? p->Debug : stdout, \"%s%s%s\\n\", timestamp, threadname, obuf);\r\n    if (p->io_thread_running)\r\n        pthread_mutex_unlock (&p->debug_lock);\r\n    free (obuf);\r\n    break;\r\n    }\r\n}\r\n\r\nstatic void __panel_debug (PANEL *p, int dbits, const char *fmt, const char *buf, int bufsize, ...)\r\n{\r\nva_list arglist;\r\n\r\nva_start (arglist, bufsize);\r\n__panel_vdebug (p, dbits, fmt, buf, bufsize, arglist);\r\nva_end (arglist);\r\n}\r\n\r\nvoid\r\nsim_panel_debug (PANEL *panel, const char *fmt, ...)\r\n{\r\nva_list arglist;\r\n\r\nva_start (arglist, fmt);\r\n__panel_vdebug (panel, DBG_APP, fmt, NULL, 0, arglist);\r\nva_end (arglist);\r\n}\r\n\r\n\r\nstatic void *\r\n_panel_debugflusher(void *arg)\r\n{\r\nPANEL *p = (PANEL*)arg;\r\nint flush_interval = 15;\r\nint sleeps = 0;\r\nint debug_close = 0;        /* set this to 1 in the debugger to for close the debug log */\r\n\r\npthread_setspecific (panel_thread_id, \"debugflush\");\r\nSET_THREAD_NAME(\"debugflush\");\r\n\r\npthread_mutex_lock (&p->io_lock);\r\np->debugflush_thread_running = 1;\r\npthread_mutex_unlock (&p->io_lock);\r\npthread_cond_signal (&p->startup_done);   /* Signal we're ready to go */\r\nmsleep (100);\r\npthread_mutex_lock (&p->debug_lock);\r\nwhile ((p->sock != INVALID_SOCKET) && (debug_close == 0)) {\r\n    pthread_mutex_unlock (&p->debug_lock);\r\n    msleep (1000);\r\n    pthread_mutex_lock (&p->debug_lock);\r\n    if (0 == (sleeps++)%flush_interval)\r\n        sim_panel_flush_debug (p);\r\n    }\r\nif (debug_close) {\r\n    fclose (p->Debug);\r\n    p->Debug = NULL;\r\n    }\r\npthread_setspecific (panel_thread_id, NULL);\r\np->debugflush_thread_running  = 0;\r\npthread_mutex_unlock (&p->debug_lock);\r\nreturn NULL;\r\n}\r\n\r\n\r\nstatic void\r\n_set_debug_file (PANEL *panel, const char *debug_file)\r\n{\r\nif (!panel)\r\n    return;\r\npanel->Debug = fopen(debug_file, \"w\");\r\nif (panel->Debug)\r\n    setvbuf (panel->Debug, NULL, _IOFBF, 65536);\r\n}\r\n\r\nvoid\r\nsim_panel_set_debug_mode (PANEL *panel, int debug_bits)\r\n{\r\nif (panel)\r\n    panel->debug = debug_bits;\r\n}\r\n\r\nvoid\r\nsim_panel_flush_debug (PANEL *panel)\r\n{\r\nif (!panel)\r\n    return;\r\nif (panel->Debug)\r\n    fflush (panel->Debug);\r\n}\r\n\r\n\r\nstatic int\r\n_panel_send (PANEL *p, const char *msg, int len)\r\n{\r\nint sent = 0;\r\n\r\nif (p->sock == INVALID_SOCKET)\r\n    return sim_panel_set_error (p, \"Invalid Socket for write\");\r\npthread_mutex_lock (&p->io_send_lock);\r\nwhile ((len > 0) && (p->sock != INVALID_SOCKET)) {\r\n    int bsent = sim_write_sock (p->sock, msg, len);\r\n    if (bsent < 0) {\r\n        SOCKET sock = p->sock;\r\n\r\n        p->sock = INVALID_SOCKET;\r\n        sim_panel_set_error (NULL, \"%s\", sim_get_err_sock(\"Error writing to socket\"));\r\n        sim_close_sock (sock);\r\n        pthread_mutex_unlock (&p->io_send_lock);\r\n        return -1;\r\n        }\r\n    _panel_debug (p, DBG_XMT, \"Sent %d bytes: \", msg, bsent, bsent);\r\n    len -= bsent;\r\n    msg += bsent;\r\n    sent += bsent;\r\n    }\r\npthread_mutex_unlock (&p->io_send_lock);\r\nreturn sent;\r\n}\r\n\r\nstatic int\r\n_panel_sendf (PANEL *p, int *completion_status, char **response, const char *fmt, ...);\r\n\r\nstatic int\r\n_panel_sendf_completion (PANEL *p, char **response, const char *completion, const char *fmt, ...);\r\n\r\nstatic int\r\n_panel_register_query_string (PANEL *panel, char **buf, size_t *buf_size)\r\n{\r\nsize_t i, j, buf_data, buf_needed = 0, reg_count = 0, bit_reg_count = 0;\r\nconst char *dev;\r\n\r\npthread_mutex_lock (&panel->io_lock);\r\nbuf_needed = 3 + 7 +                        /* EXECUTE */\r\n             strlen (register_get_start) +  /* # REGISTERS-START */\r\n             strlen (register_get_prefix);  /* SHOW TIME */\r\nfor (i=0; i<panel->reg_count; i++) {\r\n    if (panel->regs[i].bits)\r\n        ++bit_reg_count;\r\n    else {\r\n        ++reg_count;\r\n        buf_needed += 10 + strlen (panel->regs[i].name) + (panel->regs[i].device_name ? strlen (panel->regs[i].device_name) : 0);\r\n        if (panel->regs[i].element_count > 0)\r\n            buf_needed += 4 + 6 /* 6 digit register array index */;\r\n        if (panel->regs[i].indirect)\r\n            buf_needed += 12 + strlen (register_ind_echo) + strlen (panel->regs[i].name);\r\n        }\r\n    }\r\nif (bit_reg_count)\r\n    buf_needed += 2 + strlen (register_get_postfix);\r\nbuf_needed += 10 + strlen (register_get_end);    /* # REGISTERS-DONE */\r\nif (buf_needed > *buf_size) {\r\n    free (*buf);\r\n    *buf = (char *)_panel_malloc (buf_needed);\r\n    if (!*buf) {\r\n        panel->State = Error;\r\n        pthread_mutex_unlock (&panel->io_lock);\r\n        return -1;\r\n        }\r\n    *buf_size = buf_needed;\r\n    }\r\nbuf_data = 0;\r\nif (reg_count) {\r\n    sprintf (*buf + buf_data, \"EXECUTE %s;%s;\", register_get_start, register_get_prefix);\r\n    buf_data += strlen (*buf + buf_data);\r\n    }\r\ndev = \"\";\r\nfor (i=j=0; i<panel->reg_count; i++) {\r\n    const char *reg_dev = panel->regs[i].device_name ? panel->regs[i].device_name : \"\";\r\n\r\n    if ((panel->regs[i].indirect) || (panel->regs[i].bits))\r\n        continue;\r\n    if (strcmp (dev, reg_dev)) {/* devices are different */\r\n        char *tbuf;\r\n\r\n        buf_needed += 4 + strlen (register_dev_echo) + strlen (reg_dev);   /* # REGISTERS-for-DEVICE:XXX */\r\n        tbuf = (char *)_panel_malloc (buf_needed);\r\n        if (tbuf == NULL) {\r\n            panel->State = Error;\r\n            pthread_mutex_unlock (&panel->io_lock);\r\n            return -1;\r\n            }\r\n        strcpy (tbuf, *buf);\r\n        free (*buf);\r\n        *buf = tbuf;\r\n        sprintf (*buf + buf_data, \"%s%s%s;\", (i == 0)? \"\" : \";\", register_dev_echo, reg_dev);\r\n        buf_data += strlen (*buf + buf_data);\r\n        dev = reg_dev;\r\n        j = 0;\r\n        *buf_size = buf_needed;\r\n        }\r\n    if (panel->regs[i].element_count == 0) {\r\n        if (j == 0)\r\n            sprintf (*buf + buf_data, \"E -16 %s %s\", dev, panel->regs[i].name);\r\n        else\r\n            sprintf (*buf + buf_data, \",%s\", panel->regs[i].name);\r\n        }\r\n    else {\r\n        if (j == 0)\r\n            sprintf (*buf + buf_data, \"E -16 %s %s[0:%d]\", dev, panel->regs[i].name, (int)(panel->regs[i].element_count-1));\r\n        else\r\n            sprintf (*buf + buf_data, \",%s[0:%d]\", panel->regs[i].name, (int)(panel->regs[i].element_count-1));\r\n        }\r\n    ++j;\r\n    buf_data += strlen (*buf + buf_data);\r\n    }\r\nif (buf_data && ((*buf)[buf_data-1] != ';')) {\r\n    strcpy (*buf + buf_data, \";\");\r\n    buf_data += strlen (*buf + buf_data);\r\n    }\r\nfor (i=j=0; i<panel->reg_count; i++) {\r\n    const char *reg_dev = panel->regs[i].device_name ? panel->regs[i].device_name : \"\";\r\n\r\n    if ((!panel->regs[i].indirect) || (panel->regs[i].bits))\r\n        continue;\r\n    sprintf (*buf + buf_data, \"%s%s;E -16 %s %s,$;\", register_ind_echo, panel->regs[i].name, reg_dev, panel->regs[i].name);\r\n    buf_data += strlen (*buf + buf_data);\r\n    }\r\nif (bit_reg_count) {\r\n    strcpy (*buf + buf_data, register_get_postfix);\r\n    buf_data += strlen (*buf + buf_data);\r\n    strcpy (*buf + buf_data, \";\");\r\n    buf_data += strlen (*buf + buf_data);\r\n    }\r\nstrcpy (*buf + buf_data, register_get_end);\r\nbuf_data += strlen (*buf + buf_data);\r\nstrcpy (*buf + buf_data, \"\\r\");\r\nbuf_data += strlen (*buf + buf_data);\r\n*buf_size = buf_data;\r\npthread_mutex_unlock (&panel->io_lock);\r\nreturn 0;\r\n}\r\n\r\nstatic int\r\n_panel_establish_register_bits_collection (PANEL *panel)\r\n{\r\nsize_t i, buf_data, buf_needed = 1, reg_count = 0, bit_reg_count = 0;\r\nint cmd_stat, bits_count = 0;\r\nchar *buf, *response = NULL;\r\n\r\npthread_mutex_lock (&panel->io_lock);\r\nfor (i=0; i<panel->reg_count; i++) {\r\n    if (panel->regs[i].bits)\r\n        buf_needed += 9 + strlen (panel->regs[i].name) + (panel->regs[i].device_name ? strlen (panel->regs[i].device_name) : 0);\r\n    }\r\nbuf = (char *)_panel_malloc (buf_needed);\r\nif (!buf) {\r\n    panel->State = Error;\r\n    pthread_mutex_unlock (&panel->io_lock);\r\n    return -1;\r\n    }\r\n*buf = '\\0';\r\nbuf_data = 0;\r\nfor (i=0; i<panel->reg_count; i++) {\r\n    if (panel->regs[i].bits) {\r\n        ++bits_count;\r\n        sprintf (buf + buf_data, \"%s%s\", (bits_count != 1) ? \",\" : \"\", panel->regs[i].indirect ? \"-I \" : \"\");\r\n        buf_data += strlen (buf + buf_data);\r\n        if (panel->regs[i].device_name) {\r\n            sprintf (buf + buf_data, \"%s \", panel->regs[i].device_name);\r\n            buf_data += strlen (buf + buf_data);\r\n            }\r\n        sprintf (buf + buf_data, \"%s\", panel->regs[i].name);\r\n        buf_data += strlen (buf + buf_data);\r\n        }\r\n    }\r\npthread_mutex_unlock (&panel->io_lock);\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"%s%u%s%u%s%u%s%s\\r\", register_collect_prefix, panel->sample_depth,\r\n                                                                     register_collect_mid1, panel->sample_frequency,\r\n                                                                     register_collect_mid2, panel->sample_dither_pct,\r\n                                                                     register_collect_mid3, buf)) {\r\n    sim_panel_set_error (NULL, \"Error establishing bit data collection:%s\", response);\r\n    free (response);\r\n    free (buf);\r\n    return -1;\r\n    }\r\nfree (response);\r\nfree (buf);\r\nreturn 0;\r\n}\r\n\r\nstatic PANEL **panels = NULL;\r\nstatic int panel_count = 0;\r\nstatic char *sim_panel_error_buf = NULL;\r\nstatic size_t sim_panel_error_bufsize = 0;\r\n\r\n\r\nstatic void\r\n_panel_cleanup (void)\r\n{\r\nwhile (panel_count)\r\n    sim_panel_destroy (panels);\r\n}\r\n\r\nstatic void\r\n_panel_register_panel (PANEL *p)\r\n{\r\nif (panel_count == 0)\r\n    pthread_key_create (&panel_thread_id, NULL);\r\nif (!pthread_getspecific (panel_thread_id)) {\r\n    pthread_setspecific (panel_thread_id, p->device_name ? p->device_name : \"PanelCreator\");\r\n    SET_THREAD_NAME (\"PanelCreator\");\r\n    }\r\n\r\n++panel_count;\r\npanels = (PANEL **)realloc (panels, sizeof(*panels)*panel_count);\r\npanels[panel_count-1] = p;\r\nif (panel_count == 1)\r\n    atexit (&_panel_cleanup);\r\n}\r\n\r\nstatic void\r\n_panel_deregister_panel (PANEL *p)\r\n{\r\nint i;\r\n\r\nfor (i=0; i<panel_count; i++) {\r\n    if (panels[i] == p) {\r\n        int j;\r\n        for (j=i+1; j<panel_count; j++)\r\n            panels[j-1] = panels[j];\r\n        --panel_count;\r\n        if (panel_count == 0) {\r\n            free (panels);\r\n            panels = NULL;\r\n            pthread_setspecific (panel_thread_id, NULL);\r\n            pthread_key_delete (panel_thread_id);\r\n            }\r\n        break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstatic PANEL *\r\n_sim_panel_create (const char *sim_path,\r\n                   const char *sim_config,\r\n                   size_t device_panel_count,\r\n                   PANEL *simulator_panel,\r\n                   const char *device_name,\r\n                   const char *debug_file)\r\n{\r\nPANEL *p = NULL;\r\nFILE *fIn = NULL;\r\nFILE *fOut = NULL;\r\nstruct stat statb;\r\nchar *buf = NULL;\r\nint port;\r\nint cmd_stat;\r\nsize_t i, device_num;\r\nchar hostport[64];\r\nunion {int i; char c[sizeof (int)]; } end_test;\r\n\r\nif (sim_panel_error_buf == NULL) {  /* Preallocate an error message buffer */\r\n    sim_panel_error_bufsize = 2048;\r\n    sim_panel_error_buf = (char *) malloc (sim_panel_error_bufsize);\r\n    if (sim_panel_error_buf == NULL) {\r\n        sim_panel_error_buf = (char *)\"sim_panel_set_error(): Out of Memory\\n\";\r\n        sim_panel_error_bufsize = 0;\r\n        return NULL;\r\n        }\r\n    }\r\nif (simulator_panel) {\r\n    for (device_num=0; device_num < simulator_panel->device_count; ++device_num)\r\n        if (simulator_panel->devices[device_num] == NULL)\r\n            break;\r\n    if (device_num == simulator_panel->device_count) {\r\n        sim_panel_set_error (NULL, \"No free panel devices slots available %s simulator.  All %d slots are used.\", simulator_panel->path, (int)simulator_panel->device_count);\r\n        return NULL;\r\n        }\r\n    p = (PANEL *)_panel_malloc (sizeof(*p));\r\n    if (p == NULL)\r\n        goto Error_Return;\r\n    memset (p, 0, sizeof(*p));\r\n    _panel_register_panel (p);\r\n    p->device_name = (char *)_panel_malloc (1 + strlen (device_name));\r\n    if (p->device_name == NULL)\r\n        goto Error_Return;\r\n    strcpy (p->device_name, device_name);\r\n    p->parent = simulator_panel;\r\n    p->Debug = p->parent->Debug;\r\n    strcpy (p->hostport, simulator_panel->hostport);\r\n    p->sock = INVALID_SOCKET;\r\n    }\r\nelse {\r\n    end_test.i = 1;                             /* test endian-ness */\r\n    little_endian = (end_test.c[0] != 0);\r\n    sim_init_sock ();\r\n    for (port=1024; port < 2048; port++) {\r\n        SOCKET sock;\r\n\r\n        sprintf (hostport, \"%d\", port);\r\n        sock = sim_connect_sock_ex (NULL, hostport, NULL, NULL, SIM_SOCK_OPT_NODELAY | SIM_SOCK_OPT_BLOCKING);\r\n        if (sock != INVALID_SOCKET) {\r\n            int sta = 0;\r\n            while (!sta) {\r\n                msleep (10);\r\n                sta = sim_check_conn (sock, 1);\r\n                }\r\n            sim_close_sock (sock);\r\n            if (sta == -1)\r\n                break;\r\n            }\r\n        else\r\n            break;\r\n        }\r\n    if (stat (sim_config, &statb) < 0) {\r\n        sim_panel_set_error (NULL, \"Can't stat simulator configuration '%s': %s\", sim_config, strerror(errno));\r\n        goto Error_Return;\r\n        }\r\n    buf = (char *)_panel_malloc (statb.st_size+1);\r\n    if (buf == NULL)\r\n        goto Error_Return;\r\n    buf[statb.st_size] = '\\0';\r\n    p = (PANEL *)_panel_malloc (sizeof(*p));\r\n    if (p == NULL)\r\n        goto Error_Return;\r\n    memset (p, 0, sizeof(*p));\r\n    _panel_register_panel (p);\r\n    p->sock = INVALID_SOCKET;\r\n    p->path = (char *)_panel_malloc (strlen (sim_path) + 1);\r\n    if (p->path == NULL)\r\n        goto Error_Return;\r\n    strcpy (p->path, sim_path);\r\n    p->config = (char *)_panel_malloc (strlen (sim_config) + 1);\r\n    if (p->config == NULL)\r\n        goto Error_Return;\r\n    strcpy (p->config, sim_config);\r\n    fIn = fopen (sim_config, \"r\");\r\n    if (fIn == NULL) {\r\n        sim_panel_set_error (NULL, \"Can't open configuration file '%s': %s\", sim_config, strerror(errno));\r\n        goto Error_Return;\r\n        }\r\n    p->temp_config = (char *)_panel_malloc (strlen (sim_config) + 40);\r\n    if (p->temp_config == NULL)\r\n        goto Error_Return;\r\n    sprintf (p->temp_config, \"%s-Panel-%d\", sim_config, getpid());\r\n    fOut = fopen (p->temp_config, \"w\");\r\n    if (fOut == NULL) {\r\n        sim_panel_set_error (NULL, \"Can't create temporary configuration file '%s': %s\", p->temp_config, strerror(errno));\r\n        goto Error_Return;\r\n        }\r\n    fprintf (fOut, \"# Temporary FrontPanel generated simh configuration file\\n\");\r\n    fprintf (fOut, \"# Original Configuration File: %s\\n\", p->config);\r\n    fprintf (fOut, \"# Simulator Path: %s\\n\", sim_path);\r\n    while (fgets (buf, statb.st_size, fIn))\r\n        fputs (buf, fOut);\r\n    free (buf);\r\n    buf = NULL;\r\n    fclose (fIn);\r\n    fIn = NULL;\r\n    fprintf (fOut, \"set remote notelnet\\n\");\r\n    if ((device_panel_count != 0) || (debug_file != NULL))\r\n        fprintf (fOut, \"set remote connections=%d\\n\", (int)(device_panel_count + 1 + ((debug_file != NULL) ? 1 : 0)));\r\n    fprintf (fOut, \"set remote -u telnet=%s\\n\", hostport);\r\n    fprintf (fOut, \"set remote master\\n\");\r\n    fprintf (fOut, \"exit\\n\");\r\n    fclose (fOut);\r\n    fOut = NULL;\r\n    }\r\nif (debug_file) {\r\n    _set_debug_file (p, debug_file);\r\n    sim_panel_set_debug_mode (p, DBG_XMT|DBG_RCV);\r\n    _panel_debug (p, DBG_XMT|DBG_RCV, \"Creating Simulator Process %s\\n\", NULL, 0, sim_path);\r\n\r\n    if (stat (p->temp_config, &statb) < 0) {\r\n        sim_panel_set_error (NULL, \"Can't stat temporary simulator configuration '%s': %s\", p->temp_config, strerror(errno));\r\n        goto Error_Return;\r\n        }\r\n    buf = (char *)_panel_malloc (statb.st_size+1);\r\n    if (buf == NULL)\r\n        goto Error_Return;\r\n    buf[statb.st_size] = '\\0';\r\n    fIn = fopen (p->temp_config, \"r\");\r\n    if (fIn == NULL) {\r\n        sim_panel_set_error (NULL, \"Can't open temporary configuration file '%s': %s\", p->temp_config, strerror(errno));\r\n        goto Error_Return;\r\n        }\r\n    _panel_debug (p, DBG_XMT|DBG_RCV, \"Using Temporary Configuration File '%s' containing:\", NULL, 0, p->temp_config);\r\n    i = 0;\r\n    while (fgets (buf, statb.st_size, fIn)) {\r\n        ++i;\r\n        buf[strlen(buf) - 1] = '\\0';\r\n        _panel_debug (p, DBG_XMT|DBG_RCV, \"Line %2d: %s\", NULL, 0, (int)i, buf);\r\n        }\r\n    free (buf);\r\n    buf = NULL;\r\n    fclose (fIn);\r\n    fIn = NULL;\r\n    }\r\np->creating_thread = pthread_self();\r\nif (!simulator_panel) {\r\n#if defined(_WIN32)\r\n    char cmd[2048];\r\n    PROCESS_INFORMATION ProcessInfo;\r\n    STARTUPINFO StartupInfo;\r\n\r\n    sprintf(cmd, \"%s%s%s %s%s%s\", strchr (sim_path, ' ') ? \"\\\"\" : \"\", sim_path, strchr (sim_path, ' ') ? \"\\\"\" : \"\", strchr (p->temp_config, ' ') ? \"\\\"\" : \"\", p->temp_config, strchr (p->temp_config, ' ') ? \"\\\"\" : \"\");\r\n\r\n    memset (&ProcessInfo, 0, sizeof(ProcessInfo));\r\n    memset (&StartupInfo, 0, sizeof(StartupInfo));\r\n    StartupInfo.dwFlags = STARTF_USESTDHANDLES;\r\n    StartupInfo.hStdInput = INVALID_HANDLE_VALUE;\r\n    StartupInfo.hStdOutput = INVALID_HANDLE_VALUE;\r\n    StartupInfo.hStdError = INVALID_HANDLE_VALUE;\r\n    if (CreateProcessA(NULL, cmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &StartupInfo, &ProcessInfo)) {\r\n        CloseHandle (ProcessInfo.hThread);\r\n        p->hProcess = ProcessInfo.hProcess;\r\n        p->dwProcessId = ProcessInfo.dwProcessId;\r\n        }\r\n    else { /* Creation Problem */\r\n        sim_panel_set_error (NULL, \"CreateProcess Error: %s - %d\", cmd, GetErrorText(GetLastError()));\r\n        goto Error_Return;\r\n        }\r\n#else\r\n    p->pidProcess = fork();\r\n    if (p->pidProcess == 0) {\r\n        close (0); close (1); close (2);        /* make sure not to pass the open standard handles */\r\n        if (dup (dup (open (\"/dev/null\", O_RDWR)))) {}; /* open standard handles to /dev/null */\r\n        if (execlp (sim_path, sim_path, p->temp_config, NULL, NULL)) {\r\n            perror (\"execlp\");\r\n            exit(errno);\r\n            }\r\n        }\r\n    if (p->pidProcess < 0) {\r\n        p->pidProcess = 0;\r\n        sim_panel_set_error (NULL, \"fork() Error: %s\", strerror(errno));\r\n        goto Error_Return;\r\n        }\r\n#endif\r\n    strcpy (p->hostport, hostport);\r\n    }\r\nfor (i=0; i<100; i++) {          /* Allow up to 10 seconds waiting for simulator to start up */\r\n    p->sock = sim_connect_sock_ex (NULL, p->hostport, NULL, NULL, SIM_SOCK_OPT_NODELAY | SIM_SOCK_OPT_BLOCKING);\r\n    if (p->sock == INVALID_SOCKET)\r\n        msleep (100);\r\n    else\r\n        break;\r\n    }\r\nif (p->sock == INVALID_SOCKET) {\r\n    if (simulator_panel) {\r\n        sim_panel_set_error (NULL, \"Can't connect to simulator Remote Console on port %s\", p->hostport);\r\n        }\r\n    else {\r\n        if (stat (sim_path, &statb) < 0)\r\n            sim_panel_set_error (NULL, \"Can't stat simulator '%s': %s\", sim_path, strerror(errno));\r\n        else\r\n            sim_panel_set_error (NULL, \"Can't connect to the %s simulator Remote Console on port %s, the simulator process may not have started or the simulator binary can't be found\", sim_path, p->hostport);\r\n        }\r\n    goto Error_Return;\r\n    }\r\n_panel_debug (p, DBG_XMT|DBG_RCV, \"Connected to simulator on %s after %dms\", NULL, 0, p->hostport, (int)i*100);\r\nif (1) {\r\n    pthread_mutexattr_t attr;\r\n    pthread_mutexattr_t *mattr = NULL;\r\n\r\n    /*\r\n     * Error check mutexes are slightly slower, but useful to help\r\n     * untangle deadlock situations.  The mutex access APIs used here\r\n     * don't check error status since they're presumed to be well\r\n     * organized and thus won't encounter deadlocks.  If deadlocks\r\n     * occur, then it is easy enough to put OS breakpoints at all\r\n     * the error paths through the mutex lock and unlock code to find\r\n     * these cases.\r\n     */\r\n    if (debug_file) {\r\n        pthread_mutexattr_init (&attr);\r\n        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);\r\n        mattr = &attr;\r\n        }\r\n    pthread_mutex_init (&p->debug_lock, mattr);\r\n    pthread_mutex_init (&p->io_lock, mattr);\r\n    pthread_mutex_init (&p->io_send_lock, mattr);\r\n    pthread_mutex_init (&p->io_command_lock, mattr);\r\n    if (debug_file)\r\n        pthread_mutexattr_destroy (&attr);\r\n    }\r\npthread_cond_init (&p->io_done, NULL);\r\npthread_cond_init (&p->startup_done, NULL);\r\nif (sizeof(mantra) != _panel_send (p, (char *)mantra, sizeof(mantra))) {\r\n    sim_panel_set_error (NULL, \"Error sending Telnet mantra (options): %s\", sim_get_err_sock (\"send\"));\r\n    goto Error_Return;\r\n    }\r\nif (1) {\r\n    pthread_attr_t attr;\r\n\r\n    pthread_attr_init(&attr);\r\n    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);\r\n    pthread_mutex_lock (&p->io_lock);\r\n    p->io_thread_running = 0;\r\n    pthread_create (&p->io_thread, &attr, _panel_reader, (void *)p);\r\n    while (!p->io_thread_running)\r\n        pthread_cond_wait (&p->startup_done, &p->io_lock); /* Wait for thread to stabilize */\r\n    if ((p->Debug) && (p->parent == NULL)) {\r\n        p->debugflush_thread_running = 0;\r\n        pthread_create (&p->debugflush_thread, &attr, _panel_debugflusher, (void *)p);\r\n        while (!p->debugflush_thread_running)\r\n            pthread_cond_wait (&p->startup_done, &p->io_lock); /* Wait for thread to stabilize */\r\n        }\r\n    pthread_mutex_unlock (&p->io_lock);\r\n    pthread_attr_destroy(&attr);\r\n    pthread_cond_destroy (&p->startup_done);\r\n    }\r\nif (simulator_panel) {\r\n    simulator_panel->devices[device_num] = p;\r\n    }\r\nelse {\r\n    if (device_panel_count) {\r\n        p->devices = (PANEL **)_panel_malloc (device_panel_count*sizeof(*p->devices));\r\n        if (p->devices == NULL)\r\n            goto Error_Return;\r\n        memset (p->devices, 0, device_panel_count*sizeof(*p->devices));\r\n        p->device_count = device_panel_count;\r\n        }\r\n    if (p->State == Error)\r\n        goto Error_Return;\r\n    /* Validate sim_frontpanel API version */\r\n    if (_panel_sendf (p, &cmd_stat, &p->simulator_version, \"SHOW VERSION\\r\"))\r\n        goto Error_Return;\r\n    if (1) {\r\n        int api_version = 0;\r\n        char *c = strstr (p->simulator_version, \"FrontPanel API Version\");\r\n\r\n        if ((!c) ||\r\n            (1 != sscanf (c, \"FrontPanel API Version %d\", &api_version)) ||\r\n            (api_version != SIM_FRONTPANEL_VERSION)) {\r\n            sim_panel_set_error (NULL, \"Inconsistent sim_frontpanel API version %d in simulator.  Version %d needed.-\", api_version, SIM_FRONTPANEL_VERSION);\r\n            goto Error_Return;\r\n            }\r\n        }\r\n    if (1) {\r\n        char *radix = NULL;\r\n\r\n        if (_panel_sendf (p, &cmd_stat, &radix, \"SHOW %s RADIX\\r\", p->device_name ? p->device_name : \"\")) {\r\n            free (radix);\r\n            goto Error_Return;\r\n            }\r\n        sscanf (radix, \"Radix=%d\", &p->radix);\r\n        free (radix);\r\n        if ((p->radix != 16) && (p->radix != 8)) {\r\n            sim_panel_set_error (NULL, \"Unsupported Radix: %d%s%s.\", p->radix, p->device_name ? \" on device \" : \"\", p->device_name ? p->device_name : \"\");\r\n            goto Error_Return;\r\n            }\r\n        }\r\n    }\r\nreturn p;\r\n\r\nError_Return:\r\nif (fIn)\r\n    fclose (fIn);\r\nif (fOut) {\r\n    fclose (fOut);\r\n    (void)remove (p->temp_config);\r\n    }\r\nif (buf)\r\n    free (buf);\r\nif (1) {\r\n    const char *err = sim_panel_get_error();\r\n    char *errbuf = (char *)_panel_malloc (1 + strlen (err));\r\n\r\n    strcpy (errbuf, err);               /* preserve error info while closing */\r\n    sim_panel_destroy (&p);\r\n    sim_panel_set_error (NULL, \"%s\", errbuf);\r\n    free (errbuf);\r\n    }\r\nif (!simulator_panel)\r\n    sim_cleanup_sock();\r\nreturn NULL;\r\n}\r\n\r\nPANEL *\r\nsim_panel_start_simulator_debug (const char *sim_path,\r\n                                 const char *sim_config,\r\n                                 size_t device_panel_count,\r\n                                 const char *debug_file)\r\n{\r\nreturn _sim_panel_create (sim_path, sim_config, device_panel_count, NULL, NULL, debug_file);\r\n}\r\n\r\nPANEL *\r\nsim_panel_start_simulator (const char *sim_path,\r\n                           const char *sim_config,\r\n                           size_t device_panel_count)\r\n{\r\nreturn sim_panel_start_simulator_debug (sim_path, sim_config, device_panel_count, NULL);\r\n}\r\n\r\nPANEL *\r\nsim_panel_add_device_panel_debug (PANEL *simulator_panel,\r\n                                  const char *device_name,\r\n                                  const char *debug_file)\r\n{\r\nreturn _sim_panel_create (NULL, NULL, 0, simulator_panel, device_name, debug_file);\r\n}\r\n\r\nPANEL *\r\nsim_panel_add_device_panel (PANEL *simulator_panel,\r\n                            const char *device_name)\r\n{\r\nreturn sim_panel_add_device_panel_debug (simulator_panel, device_name, NULL);\r\n}\r\n\r\nint\r\nsim_panel_destroy (PANEL **ppanel)\r\n{\r\nREG *reg;\r\nPANEL *panel;\r\n\r\nif (ppanel)\r\n    panel = *ppanel;\r\nelse\r\n    return -1;\r\n\r\nif (panel) {\r\n    _panel_debug (panel, DBG_XMT|DBG_RCV, \"Closing Panel %s\", NULL, 0, panel->device_name? panel->device_name : panel->path);\r\n    if (panel->devices) {\r\n        size_t i;\r\n\r\n        for (i=0; i<panel->device_count; i++) {\r\n            if (panel->devices[i])\r\n                sim_panel_destroy (&panel->devices[i]);\r\n            }\r\n        free (panel->devices);\r\n        panel->devices = NULL;\r\n        }\r\n\r\n    if (panel->sock != INVALID_SOCKET) {\r\n        SOCKET sock = panel->sock;\r\n        int wait_count;\r\n\r\n        _panel_debug (panel, DBG_XMT|DBG_RCV, \"Closing socket\", NULL, 0);\r\n        /* First, wind down the automatic register queries */\r\n        sim_panel_set_display_callback_interval (panel, NULL, NULL, 0);\r\n        /* Next, attempt a simulator shutdown only with the master panel */\r\n        if (panel->parent == NULL) {\r\n            if (panel->State == Run)\r\n                sim_panel_exec_halt (panel);\r\n            _panel_send (panel, \"EXIT\\r\", 5);\r\n            }\r\n        /* Wait for up to 2 seconds for a graceful shutdown */\r\n        panel->sock = INVALID_SOCKET;\r\n        for (wait_count=0; panel->io_thread_running && (wait_count<20); ++wait_count)\r\n            msleep (100);\r\n        /* Now close the socket which should stop a pending read that hasn't completed */\r\n        sim_close_sock (sock);\r\n        pthread_join (panel->io_thread, NULL);\r\n\r\n        if ((panel->Debug) && (panel->parent == NULL))\r\n            pthread_join (panel->debugflush_thread, NULL);\r\n        /* panel mutexes and condition variables are only initialize after a successful socket open */\r\n        pthread_mutex_destroy (&panel->io_lock);\r\n        pthread_mutex_destroy (&panel->io_send_lock);\r\n        pthread_mutex_destroy (&panel->io_command_lock);\r\n        pthread_mutex_destroy (&panel->debug_lock);\r\n        pthread_cond_destroy (&panel->io_done);\r\n        }\r\n#if defined(_WIN32)\r\n    if (panel->hProcess) {\r\n        _panel_debug (panel, DBG_XMT|DBG_RCV, \"Stopping simulator process\", NULL, 0);\r\n        GenerateConsoleCtrlEvent (CTRL_BREAK_EVENT, panel->dwProcessId);\r\n        msleep (200);\r\n        TerminateProcess (panel->hProcess, 0);\r\n        WaitForSingleObject (panel->hProcess, INFINITE);\r\n        CloseHandle (panel->hProcess);\r\n        panel->hProcess = NULL;\r\n        }\r\n#else\r\n    if (panel->pidProcess) {\r\n        int status;\r\n\r\n        _panel_debug (panel, DBG_XMT|DBG_RCV, \"Stopping simulator process\", NULL, 0);\r\n        if (!kill (panel->pidProcess, 0)) {\r\n            kill (panel->pidProcess, SIGTERM);\r\n            msleep (200);\r\n            if (!kill (panel->pidProcess, 0))\r\n                kill (panel->pidProcess, SIGKILL);\r\n            }\r\n        waitpid (panel->pidProcess, &status, 0);\r\n        panel->pidProcess = 0;\r\n        }\r\n#endif\r\n    free (panel->path);\r\n    free (panel->device_name);\r\n    free (panel->config);\r\n    if (panel->temp_config)\r\n        (void)remove (panel->temp_config);\r\n    free (panel->temp_config);\r\n    reg = panel->regs;\r\n    while (panel->reg_count--) {\r\n        free (reg->name);\r\n        free (reg->device_name);\r\n        reg++;\r\n        }\r\n    free (panel->regs);\r\n    free (panel->reg_query);\r\n    free (panel->io_response);\r\n    free (panel->halt_reason);\r\n    free (panel->simulator_version);\r\n    if ((panel->Debug) && (!panel->parent))\r\n        fclose (panel->Debug);\r\n    if (!panel->parent)\r\n        sim_cleanup_sock ();\r\n    _panel_deregister_panel (panel);\r\n    free (panel);\r\n    *ppanel = NULL;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nOperationalState\r\nsim_panel_get_state (PANEL *panel)\r\n{\r\nif (!panel)\r\n    return Error;\r\nreturn panel->State;\r\n}\r\n\r\nstatic int\r\n_panel_add_register (PANEL *panel,\r\n                     const char *name,\r\n                     const char *device_name,\r\n                     size_t size,\r\n                     void *addr,\r\n                     int indirect,\r\n                     size_t element_count,\r\n                     int *bits,\r\n                     size_t bit_count)\r\n{\r\nREG *regs, *reg;\r\nchar *response = NULL, *c;\r\nunsigned long long data;\r\nsize_t i;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif ((bit_count != 0) && (panel->sample_depth == 0)) {\r\n    sim_panel_set_error (NULL, \"sim_panel_set_sampling_parameters() must be called first\");\r\n    return -1;\r\n    }\r\nregs = (REG *)_panel_malloc ((1 + panel->reg_count)*sizeof(*regs));\r\nif (regs == NULL)\r\n    return sim_panel_set_error (panel, \"_panel_add_register(): Out of Memory\\n\");\r\npthread_mutex_lock (&panel->io_lock);\r\nmemcpy (regs, panel->regs, panel->reg_count*sizeof(*regs));\r\nreg = &regs[panel->reg_count];\r\nmemset (reg, 0, sizeof(*regs));\r\nreg->name = (char *)_panel_malloc (1 + strlen (name));\r\nif (reg->name == NULL) {\r\n    panel->State = Error;\r\n    pthread_mutex_unlock (&panel->io_lock);\r\n    sim_panel_set_error (NULL, \"_panel_add_register(): Out of Memory\\n\");\r\n    free (regs);\r\n    return -1;\r\n    }\r\nstrcpy (reg->name, name);\r\nreg->indirect = indirect;\r\nreg->addr = addr;\r\nreg->size = size;\r\nreg->element_count = element_count;\r\nreg->bits = bits;\r\nreg->bit_count = bit_count;\r\nfor (i=0; i<strlen (reg->name); i++) {\r\n    if (islower (reg->name[i]))\r\n        reg->name[i] = toupper (reg->name[i]);\r\n    }\r\nif (device_name) {\r\n    reg->device_name = (char *)_panel_malloc (1 + strlen (device_name));\r\n    if (reg->device_name == NULL) {\r\n        free (reg->name);\r\n        free (regs);\r\n        pthread_mutex_unlock (&panel->io_lock);\r\n        return sim_panel_set_error (panel, \"_panel_add_register(): Out of Memory\\n\");\r\n        }\r\n    strcpy (reg->device_name, device_name);\r\n    for (i=0; i<strlen (reg->device_name); i++) {\r\n        if (islower (reg->device_name[i]))\r\n            reg->device_name[i] = toupper (reg->device_name[i]);\r\n        }\r\n    }\r\nfor (i=0; i<panel->reg_count; i++) {\r\n    char *t1 = (char *)_panel_malloc (2 + strlen (regs[i].name) + (regs[i].device_name? strlen (regs[i].device_name) : 0));\r\n    char *t2 = (char *)_panel_malloc (2 + strlen (reg->name) + (reg->device_name? strlen (reg->device_name) : 0));\r\n\r\n    if ((t1 == NULL) || (t2 == NULL)) {\r\n        free (t1);\r\n        free (t2);\r\n        free (reg->name);\r\n        free (reg->device_name);\r\n        panel->State = Error;\r\n        free (regs);\r\n        pthread_mutex_unlock (&panel->io_lock);\r\n        return sim_panel_set_error (NULL, \"_panel_add_register(): Out of Memory\\n\");\r\n        }\r\n    sprintf (t1, \"%s %s\", regs[i].device_name ? regs[i].device_name : \"\", regs[i].name);\r\n    sprintf (t2, \"%s %s\", reg->device_name ? reg->device_name : \"\", reg->name);\r\n    if ((!strcmp (t1, t2)) &&\r\n        (reg->indirect == regs[i].indirect) &&\r\n        ((reg->bits == NULL) == (regs[i].bits == NULL))) {\r\n        pthread_mutex_unlock (&panel->io_lock);\r\n        sim_panel_set_error (NULL, \"Duplicate Register Declaration\");\r\n        free (t1);\r\n        free (t2);\r\n        free (reg->name);\r\n        free (reg->device_name);\r\n        free (regs);\r\n        return -1;\r\n        }\r\n    free (t1);\r\n    free (t2);\r\n    }\r\npthread_mutex_unlock (&panel->io_lock);\r\n/* Validate existence of requested register/array */\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"EXAMINE -H %s %s%s\\r\", device_name? device_name : \"\", name, (element_count > 0) ? \"[0]\" : \"\")) {\r\n    free (reg->name);\r\n    free (reg->device_name);\r\n    free (regs);\r\n    return -1;\r\n    }\r\nc = strchr (response, ':');\r\nif ((!strcmp (\"Invalid argument\\r\\n\", response)) || (!c)) {\r\n    sim_panel_set_error (NULL, \"Invalid Register: %s %s\", device_name? device_name : \"\", name);\r\n    free (response);\r\n    free (reg->name);\r\n    free (reg->device_name);\r\n    free (regs);\r\n    return -1;\r\n    }\r\ndata = strtoull (c + 1, NULL, 16);\r\nfree (response);\r\nif (element_count > 0) {\r\n    if (_panel_sendf (panel, &cmd_stat, &response, \"EXAMINE %s %s[%d]\\r\", device_name? device_name : \"\", name, element_count-1)) {\r\n        free (reg->name);\r\n        free (reg->device_name);\r\n        free (regs);\r\n        return -1;\r\n        }\r\n    if (!strcmp (\"Subscript out of range\\r\\n\", response)) {\r\n        sim_panel_set_error (NULL, \"Invalid Register Array Dimension: %s %s[%d]\", device_name? device_name : \"\", name, element_count-1);\r\n        free (response);\r\n        free (reg->name);\r\n        free (reg->device_name);\r\n        free (regs);\r\n        return -1;\r\n        }\r\n    free (response);\r\n    }\r\npthread_mutex_lock (&panel->io_lock);\r\n++panel->reg_count;\r\nfree (panel->regs);\r\npanel->regs = regs;\r\npanel->new_register = 1;\r\npthread_mutex_unlock (&panel->io_lock);\r\n/* Now build the register query string for the whole register list */\r\nif (_panel_register_query_string (panel, &panel->reg_query, &panel->reg_query_size))\r\n    return -1;\r\nif (bits) {\r\n    for (i=0; i<bit_count; i++)\r\n        bits[i] = (data & (1LL<<i)) ? panel->sample_depth : 0;\r\n    if (_panel_establish_register_bits_collection (panel))\r\n        return -1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_add_register (PANEL *panel,\r\n                        const char *name,\r\n                        const char *device_name,\r\n                        size_t size,\r\n                        void *addr)\r\n{\r\nreturn _panel_add_register (panel, name, device_name, size, addr, 0, 0, NULL, 0);\r\n}\r\n\r\nint\r\nsim_panel_add_register_bits (PANEL *panel,\r\n                             const char *name,\r\n                             const char *device_name,\r\n                             size_t bit_width,\r\n                             int *bits)\r\n{\r\nreturn _panel_add_register (panel, name, device_name, 0, NULL, 0, 0, bits, bit_width);\r\n}\r\n\r\nint\r\nsim_panel_add_register_array (PANEL *panel,\r\n                              const char *name,\r\n                              const char *device_name,\r\n                              size_t element_count,\r\n                              size_t size,\r\n                              void *addr)\r\n{\r\nreturn _panel_add_register (panel, name, device_name, size, addr, 0, element_count, NULL, 0);\r\n}\r\n\r\n\r\nint\r\nsim_panel_add_register_indirect (PANEL *panel,\r\n                                 const char *name,\r\n                                 const char *device_name,\r\n                                 size_t size,\r\n                                 void *addr)\r\n{\r\nreturn _panel_add_register (panel, name, device_name, size, addr, 1, 0, NULL, 0);\r\n}\r\n\r\nint\r\nsim_panel_add_register_indirect_bits (PANEL *panel,\r\n                                      const char *name,\r\n                                      const char *device_name,\r\n                                      size_t bit_width,\r\n                                      int *bits)\r\n{\r\nreturn _panel_add_register (panel, name, device_name, 0, NULL, 1, 0, bits, bit_width);\r\n}\r\n\r\nstatic int\r\n_panel_get_registers (PANEL *panel, int calledback, unsigned long long *simulation_time)\r\n{\r\nif ((!panel) || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif ((!calledback) && (panel->callback)) {\r\n    sim_panel_set_error (NULL, \"Callback provides register data\");\r\n    return -1;\r\n    }\r\nif (!panel->reg_count) {\r\n    sim_panel_set_error (NULL, \"No registers specified\");\r\n    return -1;\r\n    }\r\npthread_mutex_lock (&panel->io_command_lock);\r\npthread_mutex_lock (&panel->io_lock);\r\nif (panel->reg_query_size != _panel_send (panel, panel->reg_query, panel->reg_query_size)) {\r\n    pthread_mutex_unlock (&panel->io_lock);\r\n    pthread_mutex_unlock (&panel->io_command_lock);\r\n    return -1;\r\n    }\r\nif (panel->io_response_data)\r\n    _panel_debug (panel, DBG_RCV, \"Receive Data Discarded: \", panel->io_response, panel->io_response_data);\r\npanel->io_response_data = 0;\r\npanel->io_waiting = 1;\r\nwhile (panel->io_waiting)\r\n    pthread_cond_wait (&panel->io_done, &panel->io_lock);\r\nif (simulation_time)\r\n    *simulation_time = panel->simulation_time;\r\npthread_mutex_unlock (&panel->io_lock);\r\npthread_mutex_unlock (&panel->io_command_lock);\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_get_registers (PANEL *panel, unsigned long long *simulation_time)\r\n{\r\nreturn _panel_get_registers (panel, (panel->State == Halt), simulation_time);\r\n}\r\n\r\nint\r\nsim_panel_set_display_callback_interval (PANEL *panel,\r\n                                         PANEL_DISPLAY_PCALLBACK callback,\r\n                                         void *context,\r\n                                         int usecs_between_callbacks)\r\n{\r\nif (!panel) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\npthread_mutex_lock (&panel->io_lock);                               /* acquire access */\r\npanel->callback = callback;\r\npanel->callback_context = context;\r\nif (usecs_between_callbacks && (0 == panel->usecs_between_callbacks)) { /* Need to start/enable callbacks */\r\n    pthread_attr_t attr;\r\n\r\n    _panel_debug (panel, DBG_THR, \"Starting callback thread, Interval: %d usecs\", NULL, 0, usecs_between_callbacks);\r\n    panel->usecs_between_callbacks = usecs_between_callbacks;\r\n    pthread_cond_init (&panel->startup_done, NULL);\r\n    pthread_attr_init(&attr);\r\n    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);\r\n    pthread_create (&panel->callback_thread, &attr, _panel_callback, (void *)panel);\r\n    pthread_attr_destroy(&attr);\r\n    while (!panel->callback_thread_running)\r\n        pthread_cond_wait (&panel->startup_done, &panel->io_lock);  /* Wait for thread to stabilize */\r\n    pthread_cond_destroy (&panel->startup_done);\r\n    }\r\nif ((usecs_between_callbacks == 0) && panel->usecs_between_callbacks) { /* Need to stop callbacks */\r\n    OperationalState PriorState = panel->State;                     /* record initial state */\r\n    _panel_debug (panel, DBG_THR, \"Shutting down callback thread\", NULL, 0);\r\n\r\n    if (PriorState == Run) {                                        /* If running? */\r\n        pthread_mutex_unlock (&panel->io_lock);                     /* allow access */\r\n        sim_panel_exec_halt (panel);                                /* Stop for Now */\r\n        pthread_mutex_lock (&panel->io_lock);                       /* acquire access */\r\n        }\r\n    panel->usecs_between_callbacks = 0;                             /* flag disabled */\r\n    pthread_mutex_unlock (&panel->io_lock);                         /* allow access */\r\n    pthread_join (panel->callback_thread, NULL);                    /* synchronize with thread rundown */\r\n    pthread_mutex_lock (&panel->io_lock);                           /* reacquire access */\r\n\r\n    if (PriorState == Run) {                                        /* If was running? */\r\n        pthread_mutex_unlock (&panel->io_lock);                     /* allow access */\r\n        sim_panel_exec_run (panel);                                 /* resume running */\r\n        pthread_mutex_lock (&panel->io_lock);                       /* acquire access */\r\n        }\r\n    }\r\npthread_mutex_unlock (&panel->io_lock);\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_set_sampling_parameters_ex (PANEL *panel,\r\n                                      unsigned int sample_frequency,\r\n                                      unsigned int sample_dither_pct,\r\n                                      unsigned int sample_depth)\r\n{\r\nif (sample_frequency == 0) {\r\n    sim_panel_set_error (NULL, \"Invalid sample frequency value: %u\", sample_frequency);\r\n    return -1;\r\n    }\r\nif (sample_dither_pct > 25) {\r\n    sim_panel_set_error (NULL, \"Invalid sample dither percentage value: %u\", sample_dither_pct);\r\n    return -1;\r\n    }\r\nif (sample_depth == 0) {\r\n    sim_panel_set_error (NULL, \"Invalid sample depth value: %u\", sample_depth);\r\n    return -1;\r\n    }\r\npanel->sample_frequency = sample_frequency;\r\npanel->sample_dither_pct = sample_dither_pct;\r\npanel->sample_depth = sample_depth;\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_set_sampling_parameters (PANEL *panel,\r\n                                   unsigned int sample_frequency,\r\n                                   unsigned int sample_depth)\r\n{\r\nreturn sim_panel_set_sampling_parameters_ex (panel,\r\n                                             sample_frequency,\r\n                                             5,\r\n                                             sample_depth);\r\n}\r\n\r\nint\r\nsim_panel_exec_halt (PANEL *panel)\r\n{\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't HALT simulator from a device front panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    if (_panel_sendf_completion (panel, NULL, sim_prompt, \"\\005\")) {\r\n        _panel_debug (panel, DBG_THR, \"Error trying to HALT running simulator: %s\", NULL, 0, sim_panel_get_error ());\r\n        return -1;\r\n        }\r\n    if (panel->State == Run) {\r\n        _panel_debug (panel, DBG_THR, \"Unable to HALT running simulator\", NULL, 0);\r\n        return -1;\r\n        }\r\n    }\r\nreturn 0;\r\n}\r\n\r\nconst char *\r\nsim_panel_halt_text (PANEL *panel)\r\n{\r\nif (!panel || !panel->halt_reason)\r\n    return \"\";\r\nreturn panel->halt_reason;\r\n}\r\n\r\n\r\nint\r\nsim_panel_exec_boot (PANEL *panel, const char *device)\r\n{\r\nint cmd_stat;\r\nchar *response, *simtime;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't BOOT simulator from device front panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\n/* A BOOT or RUN command will restart the simulator's time base. */\r\n/* We account for that so that the frontpanel application sees ever */\r\n/* increasing time values when register data is delivered. */\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"SHOW TIME\\r\"))\r\n    return -1;\r\nif ((simtime = strstr (response, \"Time:\"))) {\r\n    panel->simulation_time = strtoull (simtime + 5, NULL, 10);\r\n    panel->simulation_time_base += panel->simulation_time;\r\n    }\r\nfree (response);\r\nif (_panel_sendf_completion (panel, NULL, \"Simulator Running...\", \"BOOT %s\\r\", device)) {\r\n    _panel_debug (panel, DBG_THR, \"Unable to BOOT simulator: %s\", NULL, 0, sim_panel_get_error());\r\n    return -1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_exec_start (PANEL *panel)\r\n{\r\nint cmd_stat;\r\nchar *response, *simtime;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't RUN simulator from device front panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\n/* A BOOT or RUN command will restart the simulator's time base. */\r\n/* We account for that so that the frontpanel application sees ever */\r\n/* increasing time values when register data is delivered. */\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"SHOW TIME\\r\")) {\r\n    _panel_debug (panel, DBG_THR, \"Unable to send SHOW TIME command while starting simulator: %s\", NULL, 0, sim_panel_get_error());\r\n    return -1;\r\n    }\r\nif ((simtime = strstr (response, \"Time:\"))) {\r\n    panel->simulation_time = strtoull (simtime + 5, NULL, 10);\r\n    panel->simulation_time_base += panel->simulation_time;\r\n    }\r\nfree (response);\r\npanel->simulation_time_base += panel->simulation_time;\r\nif (_panel_sendf_completion (panel, NULL, \"Simulator Running...\", \"RUN\\r\", 5)) {\r\n    _panel_debug (panel, DBG_THR, \"Unable to start simulator: %s\", NULL, 0, sim_panel_get_error());\r\n    return -1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_exec_run (PANEL *panel)\r\n{\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't CONT simulator from device front panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (_panel_sendf_completion (panel, NULL, \"Simulator Running...\", \"CONT\\r\"))\r\n    return -1;\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_exec_step (PANEL *panel)\r\n{\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't STEP simulator from device front panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (_panel_sendf_completion (panel, NULL, sim_prompt, \"STEP\")) {\r\n    _panel_debug (panel, DBG_THR, \"Error trying to STEP running simulator: %s\", NULL, 0, sim_panel_get_error ());\r\n    return -1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_break_set (PANEL *panel, const char *condition)\r\n{\r\nchar *response = NULL;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't establish a breakpoint from device front panel\");\r\n    return -1;\r\n    }\r\nif ((_panel_sendf (panel, &cmd_stat, &response, \"BREAK %s\\r\", condition)) ||\r\n    (*response)) {\r\n    sim_panel_set_error (NULL, \"Error establishing breakpoint at '%s': %s\", condition, response ? response : \"\");\r\n    free (response);\r\n    return -1;\r\n    }\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_break_clear (PANEL *panel, const char *condition)\r\n{\r\nchar *response = NULL;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't clear a breakpoint from device front panel\");\r\n    return -1;\r\n    }\r\nif ((_panel_sendf (panel, &cmd_stat, &response, \"NOBREAK %s\\r\", condition)) ||\r\n    (*response)) {\r\n    sim_panel_set_error (NULL, \"Error clearing breakpoint at '%s': %s\", condition, response ? response : \"\");\r\n    free (response);\r\n    return -1;\r\n    }\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_break_output_set (PANEL *panel, const char *condition)\r\n{\r\nchar *response = NULL;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't establish an output breakpoint from device front panel\");\r\n    return -1;\r\n    }\r\nif ((_panel_sendf (panel, &cmd_stat, &response, \"EXPECT %s\\r\", condition)) ||\r\n    (*response)) {\r\n    sim_panel_set_error (NULL, \"Error establishing output breakpoint for '%s': %s\", condition, response ? response : \"\");\r\n    free (response);\r\n    return -1;\r\n    }\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_break_output_clear (PANEL *panel, const char *condition)\r\n{\r\nchar *response = NULL;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->parent) {\r\n    sim_panel_set_error (NULL, \"Can't clear an output breakpoint from device front panel\");\r\n    return -1;\r\n    }\r\nif ((_panel_sendf (panel, &cmd_stat, &response, \"NOEXPECT %s\\r\", condition)) ||\r\n    (*response)) {\r\n    sim_panel_set_error (NULL, \"Error clearing output breakpoint for '%s': %s\", condition, response ? response : \"\");\r\n    free (response);\r\n    return -1;\r\n    }\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\n/**\r\n\r\n   sim_panel_gen_examine\r\n\r\n        name_or_addr the name the simulator knows this register by\r\n        size         the size (in local storage) of the buffer which will\r\n                     receive the data returned when examining the simulator\r\n        value        a pointer to the buffer which will be loaded with the\r\n                     data returned when examining the simulator\r\n */\r\n\r\nint\r\nsim_panel_gen_examine (PANEL *panel,\r\n                       const char *name_or_addr,\r\n                       size_t size,\r\n                       void *value)\r\n{\r\nchar *response = NULL, *c;\r\nunsigned long long data = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"EXAMINE -H %s\", name_or_addr)) {\r\n    free (response);\r\n    return -1;\r\n    }\r\nc = strchr (response, ':');\r\nif (!c) {\r\n    sim_panel_set_error (NULL, \"response: %s\", response);\r\n    free (response);\r\n    return -1;\r\n    }\r\ndata = strtoull (c + 1, NULL, 16);\r\nif (little_endian)\r\n    memcpy (value, &data, size);\r\nelse\r\n    memcpy (value, ((char *)&data) + sizeof(data)-size, size);\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\n/**\r\n\r\n   sim_panel_get_history\r\n\r\n        count        the number of instructions to return\r\n        size         the size (in local storage) of the buffer which will\r\n                     receive the data returned when examining the simulator\r\n        buffer       a pointer to the buffer which will be loaded with the\r\n                     instruction history returned from the simulator\r\n */\r\n\r\nint\r\nsim_panel_get_history (PANEL *panel,\r\n                       int count,\r\n                       size_t size,\r\n                       char *buffer)\r\n{\r\nchar *response = NULL;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"SHOW HISTORY=%d\", count)) {\r\n    free (response);\r\n    return -1;\r\n    }\r\nstrncpy (buffer, response, size);\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\nint\r\nsim_panel_device_debug_mode (PANEL *panel,\r\n                             const char *device,\r\n                             int set_unset,\r\n                             const char *mode_bits)\r\n{\r\nchar *response = NULL;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif ((device != NULL) &&\r\n    ((_panel_sendf (panel, &cmd_stat, &response, \"SHOW %s\", device) ||\r\n     (cmd_stat)))) {\r\n    sim_panel_set_error (NULL, \"Can't %s Debug Mode: '%s' on Device '%s': %s\",\r\n                               set_unset ? \"Enable\" : \"Disable\", mode_bits ? mode_bits : \"\", device, response);\r\n    free (response);\r\n    return -1;\r\n    }\r\nfree (response);\r\nresponse = NULL;\r\nif (_panel_sendf (panel, &cmd_stat, &response, \"%sDEBUG %s %s\",\r\n                         set_unset ? \"\" : \"NO\", device ? device : \"\", mode_bits ? mode_bits : \"\") ||\r\n    (cmd_stat)) {\r\n    sim_panel_set_error (NULL, \"Can't %s Debug Mode: '%s' on Device '%s': %s\",\r\n                               set_unset ? \"Enable\" : \"Disable\", mode_bits ? mode_bits : \"\", device, response);\r\n    free (response);\r\n    return -1;\r\n    }\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\n/**\r\n\r\n   sim_panel_gen_deposit\r\n\r\n        name_or_addr the name the simulator knows this register by\r\n        size         the size (in local storage) of the buffer which\r\n                     contains the data to be deposited into the simulator\r\n        value        a pointer to the buffer which contains the data to\r\n                     be deposited into the simulator\r\n */\r\n\r\nint\r\nsim_panel_gen_deposit (PANEL *panel,\r\n                       const char *name_or_addr,\r\n                       size_t size,\r\n                       const void *value)\r\n{\r\nunsigned long long data = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (little_endian)\r\n    memcpy (&data, value, size);\r\nelse\r\n    memcpy (((char *)&data) + sizeof(data)-size, value, size);\r\nif (_panel_sendf (panel, &cmd_stat, NULL, \"DEPOSIT -H %s %llx\", name_or_addr, data))\r\n    return -1;\r\nreturn 0;\r\n}\r\n\r\n/**\r\n\r\n   sim_panel_mem_examine\r\n\r\n        addr_size    the size (in local storage) of the buffer which\r\n                     contains the memory address of the data to be examined\r\n                     in the simulator\r\n        addr         a pointer to the buffer containing the memory address\r\n                     of the data to be examined in the simulator\r\n        value_size   the size (in local storage) of the buffer which will\r\n                     receive the data returned when examining the simulator\r\n        value        a pointer to the buffer which will be loaded with the\r\n                     data returned when examining the simulator\r\n */\r\n\r\nint\r\nsim_panel_mem_examine (PANEL *panel,\r\n                       size_t addr_size,\r\n                       const void *addr,\r\n                       size_t value_size,\r\n                       void *value)\r\n{\r\nchar *response = NULL, *c;\r\nunsigned long long data = 0, address = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (little_endian)\r\n    memcpy (&address, addr, addr_size);\r\nelse\r\n    memcpy (((char *)&address) + sizeof(address)-addr_size, addr, addr_size);\r\nif (_panel_sendf (panel, &cmd_stat, &response, (panel->radix == 16) ? \"EXAMINE -H %llx\" : \"EXAMINE -H %llo\", address)) {\r\n    free (response);\r\n    return -1;\r\n    }\r\nc = strchr (response, ':');\r\nif (!c) {\r\n    sim_panel_set_error (NULL, \"%s\", response);\r\n    free (response);\r\n    return -1;\r\n    }\r\ndata = strtoull (c + 1, NULL, 16);\r\nif (little_endian)\r\n    memcpy (value, &data, value_size);\r\nelse\r\n    memcpy (value, ((char *)&data) + sizeof(data)-value_size, value_size);\r\nfree (response);\r\nreturn 0;\r\n}\r\n\r\n/**\r\n\r\n   sim_panel_mem_deposit\r\n\r\n        addr_size    the size (in local storage) of the buffer which\r\n                     contains the memory address of the data to be deposited\r\n                     into the simulator\r\n        addr         a pointer to the buffer containing the memory address\r\n                     of the data to be deposited into the simulator\r\n        value_size   the size (in local storage) of the buffer which will\r\n                     contains the data to be deposited into the simulator\r\n        value        a pointer to the buffer which contains the data to be\r\n                     deposited into the simulator\r\n */\r\n\r\n int\r\nsim_panel_mem_deposit (PANEL *panel,\r\n                       size_t addr_size,\r\n                       const void *addr,\r\n                       size_t value_size,\r\n                       const void *value)\r\n{\r\nunsigned long long data = 0, address = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (little_endian) {\r\n    memcpy (&data, value, value_size);\r\n    memcpy (&address, addr, addr_size);\r\n    }\r\nelse {\r\n    memcpy (((char *)&data) + sizeof(data)-value_size, value, value_size);\r\n    memcpy (((char *)&address) + sizeof(address)-addr_size, addr, addr_size);\r\n    }\r\nif (_panel_sendf (panel, &cmd_stat, NULL, (panel->radix == 16) ? \"DEPOSIT -H %llx %llx\" : \"DEPOSIT -H %llo %llx\", address, data))\r\n    return -1;\r\nreturn 0;\r\n}\r\n\r\n/**\r\n\r\n   sim_panel_mem_deposit_instruction\r\n\r\n        addr_size    the size (in local storage) of the buffer which\r\n                     contains the memory address of the data to be deposited\r\n                     into the simulator\r\n        addr         a pointer to the buffer containing the memory address\r\n                     of the data to be deposited into the simulator\r\n        instruction  a pointer to the buffer that contains the mnemonic\r\n                     instruction to be deposited at the indicated address\r\n */\r\n\r\n int\r\nsim_panel_mem_deposit_instruction (PANEL *panel,\r\n                                   size_t addr_size,\r\n                                   const void *addr,\r\n                                   const char *instruction)\r\n{\r\nunsigned long long address = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (little_endian)\r\n    memcpy (&address, addr, addr_size);\r\nelse\r\n    memcpy (((char *)&address) + sizeof(address)-addr_size, addr, addr_size);\r\nif (_panel_sendf (panel, &cmd_stat, NULL, (panel->radix == 16) ? \"DEPOSIT -H %llx %s\" : \"DEPOSIT -H %llo %s\", address, instruction))\r\n    return -1;\r\nreturn 0;\r\n}\r\n\r\n/**\r\n   sim_panel_set_register_value\r\n\r\n        name        the name of a simulator register or a memory address\r\n                    which is to receive a new value\r\n        value       the new value in character string form.  The string\r\n                    must be in the native/natural radix that the simulator\r\n                    uses when referencing that register\r\n\r\n */\r\n\r\nint\r\nsim_panel_set_register_value (PANEL *panel,\r\n                              const char *name,\r\n                              const char *value)\r\n{\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nif (panel->State == Run) {\r\n    sim_panel_set_error (NULL, \"Not Halted\");\r\n    return -1;\r\n    }\r\nif (_panel_sendf (panel, &cmd_stat, NULL, \"DEPOSIT %s %s\", name, value))\r\n    return -1;\r\nreturn 0;\r\n}\r\n\r\n/**\r\n   sim_panel_mount\r\n\r\n        device      the name of a simulator device/unit\r\n        switches    any switches appropriate for the desire attach (can be NULL)\r\n        path        the path on the local system to be attached\r\n\r\n */\r\nint\r\nsim_panel_mount (PANEL *panel,\r\n                 const char *device,\r\n                 const char *switches,\r\n                 const char *path)\r\n{\r\nchar *response = NULL;\r\nOperationalState OrigState;\r\nint stat = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nOrigState = panel->State;\r\nif (OrigState == Run)\r\n    sim_panel_exec_halt (panel);\r\ndo {\r\n    if (_panel_sendf (panel, &cmd_stat, &response, \"ATTACH %s %s %s\", (switches == NULL) ? \"\" : switches, device, path)) {\r\n        stat = -1;\r\n        break;\r\n        }\r\n    if (cmd_stat) {\r\n        sim_panel_set_error (NULL, response);\r\n        stat = -1;\r\n        }\r\n    } while (0);\r\nif (OrigState == Run)\r\n    sim_panel_exec_run (panel);\r\nfree (response);\r\nreturn stat;\r\n}\r\n\r\n/**\r\n   sim_panel_dismount\r\n\r\n        device      the name of a simulator device/unit\r\n\r\n */\r\nint\r\nsim_panel_dismount (PANEL *panel,\r\n                    const char *device)\r\n{\r\nchar *response = NULL;\r\nOperationalState OrigState;\r\nint stat = 0;\r\nint cmd_stat;\r\n\r\nif (!panel || (panel->State == Error)) {\r\n    sim_panel_set_error (NULL, \"Invalid Panel\");\r\n    return -1;\r\n    }\r\nOrigState = panel->State;\r\nif (OrigState == Run)\r\n    sim_panel_exec_halt (panel);\r\ndo {\r\n    if (_panel_sendf (panel, &cmd_stat, &response, \"DETACH %s\", device)) {\r\n        stat = -1;\r\n        break;\r\n        }\r\n    if (cmd_stat) {\r\n        sim_panel_set_error (NULL, \"%s\", response);\r\n        stat = -1;\r\n        }\r\n    } while (0);\r\nif (OrigState == Run)\r\n    sim_panel_exec_run (panel);\r\nfree (response);\r\nreturn stat;\r\n}\r\n\r\n\r\nstatic void *\r\n_panel_reader(void *arg)\r\n{\r\nPANEL *p = (PANEL*)arg;\r\nREG *r = NULL;\r\nint sched_policy;\r\nstruct sched_param sched_priority;\r\nchar buf[4096];\r\nint buf_data = 0;\r\nint processing_register_output = 0;\r\nint io_wait_done = 0;\r\nint transitioned_to_halt;\r\n\r\n/*\r\n   Boost Priority for this response processing thread to quickly digest\r\n   arriving data.\r\n */\r\npthread_getschedparam (pthread_self(), &sched_policy, &sched_priority);\r\n++sched_priority.sched_priority;\r\npthread_setschedparam (pthread_self(), sched_policy, &sched_priority);\r\npthread_setspecific (panel_thread_id, \"reader\");\r\nSET_THREAD_NAME (\"reader\");\r\n_panel_debug (p, DBG_THR, \"Starting\", NULL, 0);\r\n\r\nbuf[buf_data] = '\\0';\r\npthread_mutex_lock (&p->io_lock);\r\nif (!p->parent) {\r\n    while (1) {\r\n        int new_data = sim_read_sock (p->sock, &buf[buf_data], sizeof(buf)-(buf_data+1));\r\n\r\n        if (new_data <= 0) {\r\n            SOCKET sock = p->sock;\r\n\r\n            sim_panel_set_error (NULL, \"During Startup: %s after reading %d bytes: %s\", sim_get_err_sock(\"Unexpected socket read\"), buf_data, buf);\r\n            p->sock = INVALID_SOCKET;\r\n            sim_close_sock (sock);\r\n            _panel_debug (p, DBG_RCV, \"%s\", NULL, 0, sim_panel_get_error());\r\n            p->State = Error;\r\n            break;\r\n            }\r\n        _panel_debug (p, DBG_RCV, \"Startup receive of %d bytes: \", &buf[buf_data], new_data, new_data);\r\n        buf_data += new_data;\r\n        buf[buf_data] = '\\0';\r\n        if (!memcmp (mantra, buf, sizeof (mantra))) {   /* strip initial telnet mantra from input stream */\r\n            memmove (buf, buf + sizeof (mantra), 1 + buf_data - sizeof (mantra));\r\n            buf_data -= sizeof (mantra);\r\n            }\r\n        if ((size_t)buf_data < strlen (sim_prompt))\r\n            continue;\r\n        if (!strcmp (sim_prompt, &buf[buf_data - strlen (sim_prompt)])) {\r\n            memmove (buf, &buf[buf_data - strlen (sim_prompt)], strlen (sim_prompt) + 1);\r\n            buf_data = strlen (sim_prompt);\r\n            break;\r\n            }\r\n        }\r\n    }\r\np->io_thread_running = 1;\r\npthread_mutex_unlock (&p->io_lock);\r\npthread_cond_signal (&p->startup_done);   /* Signal we're ready to go */\r\nmsleep (100);\r\npthread_mutex_lock (&p->io_lock);\r\nwhile ((p->sock != INVALID_SOCKET) &&\r\n       (p->State != Error)) {\r\n    int new_data;\r\n    char *s, *e, *eol;\r\n\r\n    transitioned_to_halt = 0;\r\n    if (NULL == strchr (buf, '\\n')) {\r\n        pthread_mutex_unlock (&p->io_lock);\r\n        new_data = sim_read_sock (p->sock, &buf[buf_data], sizeof(buf)-(buf_data+1));\r\n        pthread_mutex_lock (&p->io_lock);\r\n        if (new_data <= 0) {\r\n            sim_panel_set_error (NULL, \"%s\", sim_get_err_sock(\"Unexpected socket read\"));\r\n            _panel_debug (p, DBG_RCV, \"%s\", NULL, 0, sim_panel_get_error());\r\n            p->State = Error;\r\n            break;\r\n            }\r\n        _panel_debug (p, DBG_RCV, \"Received %d bytes: \", &buf[buf_data], new_data, new_data);\r\n        buf_data += new_data;\r\n        buf[buf_data] = '\\0';\r\n        }\r\n    s = buf;\r\n    while ((eol = strchr (s, '\\n'))) {\r\n        /* Line to process */\r\n        *eol++ = '\\0';\r\n        while ((*s) && (s[strlen(s)-1] == '\\r'))\r\n            s[strlen(s)-1] = '\\0';\r\n        if (p->State == Run)\r\n            if (0 == memcmp (s, sim_prompt, strlen (sim_prompt))) {\r\n                _panel_debug (p, DBG_RSP, \"State transitioning to Halt with '%s': io_waiting: %d\", NULL, 0, s, p->io_waiting);\r\n                transitioned_to_halt = 1;\r\n                }\r\n        if (processing_register_output) {\r\n            e = strchr (s, ':');\r\n            if (e) {\r\n                size_t i;\r\n                char smp_dev[32], smp_reg[32], smp_ind[32];\r\n                unsigned int bit;\r\n\r\n                *e++ = '\\0';\r\n                if (!strcmp(\"Time\", s)) {\r\n                    p->simulation_time = strtoull (e, NULL, 10);\r\n                    s = eol;\r\n                    while (isspace(0xFF & (*s)))\r\n                        ++s;\r\n                    continue;                                   /* process next line */\r\n                    }\r\n                if ((*s == '}') &&\r\n                    (3 == sscanf (s, \"}%s %s %s\", smp_dev, smp_reg, smp_ind))) {   /* Register bit Sample Data? */\r\n                    r = NULL;\r\n                    for (i=0; i<p->reg_count; i++) {\r\n                        if (p->regs[i].bits == NULL)\r\n                            continue;\r\n                        if ((!strcmp (smp_reg, p->regs[i].name)) &&\r\n                            ((!p->device_name) || (!strcmp (smp_dev, p->device_name)))) {\r\n                            r = &p->regs[i];\r\n                            break;\r\n                            }\r\n                        }\r\n                    if (r) {\r\n                        for (bit = 0; bit < r->bit_count; bit++) {\r\n                            int val = (int)strtol (e, &e, 10);\r\n                            r->bits[bit] = val;\r\n                            if (*e == ',')\r\n                                ++e;\r\n                            else\r\n                                break;\r\n                            }\r\n                        s = eol;\r\n                        }\r\n                    while (isspace(0xFF & (*s)))\r\n                        ++s;\r\n                    r = NULL;\r\n                    continue;                                   /* process next line */\r\n                    }\r\n                if (!strncmp (s + strlen (sim_prompt), register_ind_echo, strlen (register_ind_echo) - 1)) {\r\n                    e = s + strlen (sim_prompt) + strlen (register_ind_echo);\r\n                    r = NULL;\r\n                    for (i=0; i<p->reg_count; i++) {\r\n                        if (p->regs[i].indirect && (!strcmp(p->regs[i].name, e))) {\r\n                            r = &p->regs[i];\r\n                            break;\r\n                            }\r\n                        }\r\n                    s = eol;\r\n                    while (isspace(0xFF & (*s)))\r\n                        ++s;\r\n                    if (r)\r\n                        continue;                               /* process next line */\r\n                    }\r\n                if (r) {\r\n                    if (strcmp (s, r->name)) {\r\n                        unsigned long long data;\r\n\r\n                        data = strtoull (e, NULL, 16);\r\n                        if (little_endian)\r\n                            memcpy (r->addr, &data, r->size);\r\n                        else\r\n                            memcpy (r->addr, ((char *)&data) + sizeof(data)-r->size, r->size);\r\n                        r = NULL;\r\n                        }\r\n                    s = eol;\r\n                    while (isspace(0xFF & (*s)))\r\n                        ++s;\r\n                    continue;                               /* process next line */\r\n                    }\r\n                for (i=0; i<p->reg_count; i++) {\r\n                    if (p->regs[i].element_count == 0) {\r\n                        if (!strcmp(p->regs[i].name, s)) {\r\n                            unsigned long long data;\r\n\r\n                            data = strtoull (e, NULL, 16);\r\n                            if (little_endian)\r\n                                memcpy (p->regs[i].addr, &data, p->regs[i].size);\r\n                            else\r\n                                memcpy (p->regs[i].addr, ((char *)&data) + sizeof(data)-p->regs[i].size, p->regs[i].size);\r\n                            break;\r\n                            }\r\n                        }\r\n                    else {\r\n                        size_t name_len = strlen (p->regs[i].name);\r\n\r\n                        if ((0 == memcmp (p->regs[i].name, s, name_len)) && (s[name_len] == '[')) {\r\n                            size_t array_index = (size_t)atoi (s + name_len + 1);\r\n                            size_t end_index = array_index;\r\n                            char *end = strchr (s + name_len + 1, '[');\r\n\r\n                            if (end)\r\n                                end_index = (size_t)atoi (end + 1);\r\n                            if (strcmp (e, \" same as above\"))\r\n                                p->array_element_data = strtoull (e, NULL, 16);\r\n                            while (array_index <= end_index) {\r\n                                if (little_endian)\r\n                                    memcpy ((char *)(p->regs[i].addr) + (array_index * p->regs[i].size), &p->array_element_data, p->regs[i].size);\r\n                                else\r\n                                    memcpy ((char *)(p->regs[i].addr) + (array_index * p->regs[i].size), ((char *)&p->array_element_data) + sizeof(p->array_element_data)-p->regs[i].size, p->regs[i].size);\r\n                                ++array_index;\r\n                                }\r\n                            break;\r\n                            }\r\n                        }\r\n                    }\r\n                if (i != p->reg_count) {\r\n                    s = eol;\r\n                    while (isspace(0xFF & (*s)))\r\n                        ++s;\r\n                    continue;\r\n                    }\r\n                --e;\r\n                *e = ':';\r\n                /* Unexpected Register Data Found (or other output containing a : character) */\r\n                }\r\n            }\r\n        if ((strlen (s) > strlen (sim_prompt)) && (!strcmp (s + strlen (sim_prompt), register_repeat_end))) {\r\n            _panel_debug (p, DBG_RCV, \"*Repeat Block Complete (Accumulated Data = %d)\", NULL, 0, (int)p->io_response_data);\r\n            if ((p->callback) && (!transitioned_to_halt)) {\r\n                pthread_mutex_unlock (&p->io_lock);\r\n                p->callback (p, p->simulation_time_base + p->simulation_time, p->callback_context);\r\n                pthread_mutex_lock (&p->io_lock);\r\n                }\r\n            processing_register_output = 0;\r\n            p->io_response_data = 0;\r\n            p->io_response[p->io_response_data] = '\\0';\r\n            goto Start_Next_Line;\r\n            }\r\n        if ((strlen (s) > strlen (sim_prompt)) &&\r\n            ((!strcmp (s + strlen (sim_prompt), register_repeat_start)) ||\r\n             (!strcmp (s + strlen (sim_prompt), register_get_start)))) {\r\n            _panel_debug (p, DBG_RCV, \"*Repeat/Register Block Starting\", NULL, 0);\r\n            processing_register_output = 1;\r\n            goto Start_Next_Line;\r\n            }\r\n        if ((strlen (s) > strlen (sim_prompt)) &&\r\n            (!strcmp (s + strlen (sim_prompt), register_get_end))) {\r\n            _panel_debug (p, DBG_RCV, \"*Register Block Complete: Request %d\", NULL, 0, p->io_waiting);\r\n            p->io_waiting = 0;\r\n            processing_register_output = 0;\r\n            pthread_cond_signal (&p->io_done);\r\n            goto Start_Next_Line;\r\n            }\r\n        if ((strlen (s) > strlen (sim_prompt)) && (!strcmp (s + strlen (sim_prompt), command_done_echo))) {\r\n            _panel_debug (p, DBG_RCV, \"*Received Command Complete: Request %d\", NULL, 0, p->io_waiting);\r\n            p->io_waiting = 0;\r\n            pthread_cond_signal (&p->io_done);\r\n            goto Start_Next_Line;\r\n            }\r\n        /* Non Register Data Found (echo of EXAMINE or other commands and/or command output) */\r\n        if (p->io_response_data + strlen (s) + 3 > p->io_response_size) {\r\n            char *t = (char *)_panel_malloc (p->io_response_data + strlen (s) + 3);\r\n\r\n            if (t == NULL) {\r\n                _panel_debug (p, DBG_RCV, \"%s\", NULL, 0, sim_panel_get_error());\r\n                p->State = Error;\r\n                break;\r\n                }\r\n            memcpy (t, p->io_response, p->io_response_data);\r\n            free (p->io_response);\r\n            p->io_response = t;\r\n            p->io_response_size = p->io_response_data + strlen (s) + 3;\r\n            }\r\n        _panel_debug (p, DBG_RCV, \"Receive Data Accumulated: '%s'\", NULL, 0, s);\r\n        strcpy (p->io_response + p->io_response_data, s);\r\n        p->io_response_data += strlen(s);\r\n        strcpy (p->io_response + p->io_response_data, \"\\r\\n\");\r\n        p->io_response_data += 2;\r\n        if ((!p->parent) &&\r\n            (p->completion_string) &&\r\n            (!memcmp (s, p->completion_string, strlen (p->completion_string)))) {\r\n            _panel_debug (p, DBG_RCV, \"Match with potentially coalesced additional data: '%s'\", NULL, 0, p->completion_string);\r\n            if (eol < &buf[buf_data])\r\n                memset (s + strlen (s), ' ', eol - (s + strlen (s)));\r\n            break;\r\n            }\r\nStart_Next_Line:\r\n        s = eol;\r\n        while (isspace(0xFF & (*s)))\r\n            ++s;\r\n        }\r\n    memmove (buf, s, buf_data - (s - buf) + 1);\r\n    buf_data = strlen (buf);\r\n    if (buf_data) {\r\n        _panel_debug (p, DBG_RSP, \"Remnant Buffer Contents: '%s'\", NULL, 0, buf);\r\n        }\r\n    if ((!p->parent) &&\r\n        (p->completion_string) &&\r\n        (!memcmp (buf, p->completion_string, strlen (p->completion_string)))) {\r\n        _panel_debug (p, DBG_RCV, \"*Received Command Complete - Match: '%s'\", NULL, 0, p->completion_string);\r\n        io_wait_done = 1;\r\n        }\r\n    if (!memcmp (\"Simulator Running...\", buf, 20)) {\r\n        _panel_debug (p, DBG_RSP, \"State transitioning to Run\", NULL, 0);\r\n        p->State = Run;\r\n        buf_data -= 20;\r\n        if (buf_data) {\r\n            memmove (buf, buf + 20, buf_data + 1);\r\n            _panel_debug (p, DBG_RSP, \"Remnant Buffer Contents: '%s'\", NULL, 0, buf);\r\n            }\r\n        else\r\n            buf[buf_data] = '\\0';\r\n        if (io_wait_done) {                     /* someone waiting for this? */\r\n            _panel_debug (p, DBG_RCV, \"*Match Command Complete - Match signaling waiting thread: Request %d\", NULL, 0, p->io_waiting);\r\n            io_wait_done = 0;\r\n            p->io_waiting = 0;\r\n            p->completion_string = NULL;\r\n            pthread_cond_signal (&p->io_done);\r\n            /* Let this state transition propagate to the interested thread(s) */\r\n            /* before processing remaining buffered data */\r\n            pthread_mutex_unlock (&p->io_lock);\r\n            msleep (100);\r\n            pthread_mutex_lock (&p->io_lock);\r\n            }\r\n        }\r\n    if ((p->State == Run) && (!memcmp (buf, sim_prompt, strlen (sim_prompt)))) {\r\n        char *response = p->io_response;\r\n\r\n        _panel_debug (p, DBG_RSP, \"State transitioning to Halt: io_wait_done: %d\", NULL, 0, io_wait_done);\r\n        p->State = Halt;\r\n        free (p->halt_reason);\r\n        while ((response != NULL) && isspace (*response))\r\n            ++response;\r\n        p->halt_reason = (char *)_panel_malloc (1 + strlen (response));\r\n        if (p->halt_reason == NULL) {\r\n            _panel_debug (p, DBG_RCV, \"%s\", NULL, 0, sim_panel_get_error());\r\n            p->State = Error;\r\n            break;\r\n            }\r\n        strcpy (p->halt_reason, response);\r\n        _panel_debug (p, DBG_RSP, \"Halt Reason: %s\", NULL, 0, p->halt_reason);\r\n        }\r\n    if (io_wait_done) {\r\n        _panel_debug (p, DBG_RCV, \"*Match Command Complete - Match signaling waiting thread: Request %d\", NULL, 0, p->io_waiting);\r\n        io_wait_done = 0;\r\n        p->io_waiting = 0;\r\n        p->completion_string = NULL;\r\n        pthread_cond_signal (&p->io_done);\r\n        /* Let this state transition propagate to the interested thread(s) */\r\n        /* before processing remaining buffered data */\r\n        pthread_mutex_unlock (&p->io_lock);\r\n        msleep (50);\r\n        pthread_mutex_lock (&p->io_lock);\r\n        }\r\n    }\r\nif (p->io_waiting != 0) {\r\n    _panel_debug (p, DBG_THR, \"Receive: restarting waiting thread while exiting: Request %d\", NULL, 0, p->io_waiting);\r\n    p->io_waiting = 0;\r\n    pthread_cond_signal (&p->io_done);\r\n    }\r\n_panel_debug (p, DBG_THR, \"Exiting\", NULL, 0);\r\npthread_setspecific (panel_thread_id, NULL);\r\np->io_thread_running = 0;\r\npthread_mutex_unlock (&p->io_lock);\r\nreturn NULL;\r\n}\r\n\r\nstatic void *\r\n_panel_callback(void *arg)\r\n{\r\nPANEL *p = (PANEL*)arg;\r\nint sched_policy;\r\nstruct sched_param sched_priority;\r\nchar *buf = NULL;\r\nsize_t buf_data = 0;\r\nunsigned int callback_count = 0;\r\nint cmd_stat;\r\n\r\n/*\r\n   Boost Priority for timer thread so it doesn't compete\r\n   with compute bound activities.\r\n */\r\npthread_getschedparam (pthread_self(), &sched_policy, &sched_priority);\r\n++sched_priority.sched_priority;\r\npthread_setschedparam (pthread_self(), sched_policy, &sched_priority);\r\npthread_setspecific (panel_thread_id, \"callback\");\r\nSET_THREAD_NAME (\"callback\");\r\n_panel_debug (p, DBG_THR, \"Starting\", NULL, 0);\r\n\r\npthread_mutex_lock (&p->io_lock);\r\np->callback_thread_running = 1;\r\npthread_mutex_unlock (&p->io_lock);\r\npthread_cond_signal (&p->startup_done);   /* Signal we're ready to go */\r\nmsleep (100);\r\npthread_mutex_lock (&p->io_lock);\r\nwhile ((p->sock != INVALID_SOCKET) &&\r\n       (p->usecs_between_callbacks) &&\r\n       (p->State != Error)) {\r\n    int interval = p->usecs_between_callbacks;\r\n    int new_register = p->new_register;\r\n\r\n    pthread_mutex_unlock (&p->io_lock);\r\n\r\n    if (new_register)           /* need to get and send updated register info */\r\n        _panel_register_query_string (p, &buf, &buf_data);\r\n\r\n    /* twice a second activities:                                               */\r\n    /*  1) update the query string if it has changed                            */\r\n    /*     (only really happens at startup)                                     */\r\n    /*  2) update register state by polling if the simulator is halted          */\r\n    msleep (500);\r\n    pthread_mutex_lock (&p->io_lock);\r\n    if (new_register && (p->State == Halt)) {\r\n        size_t repeat_data = strlen (register_repeat_prefix) +  /* prefix */\r\n                             20                              +  /* max int width */\r\n                             strlen (register_repeat_units)  +  /* units and spacing */\r\n                             buf_data                        +  /* command contents */\r\n                             1                               +  /* ; */\r\n                             strlen (register_repeat_start)  +  /* auto repeat begin */\r\n                             1                               +  /* ; */\r\n                             strlen (register_repeat_end)    +  /* auto repeat completion */\r\n                             1                               +  /* carriage return */\r\n                             1;                                 /* NUL */\r\n        char *repeat = (char *)malloc (repeat_data);\r\n        char *c;\r\n\r\n        c = strstr (buf, register_get_start);       /* remove register_get_start string and anything before it */\r\n        if (c) {                                    /* always true */\r\n            buf_data -= (c - buf) + strlen (register_get_start);\r\n            c += strlen (register_get_start);\r\n            }\r\n        sprintf (repeat, \"%s%d%s%s%*.*s\", register_repeat_prefix,\r\n                                     p->usecs_between_callbacks,\r\n                                     register_repeat_units,\r\n                                     register_repeat_start,\r\n                                     (int)buf_data, (int)buf_data, c);\r\n        pthread_mutex_unlock (&p->io_lock);\r\n        c = strstr (repeat, register_get_end);      /* remove register_done_echo string and */\r\n        if (c)                                      /* always true */\r\n            strcpy (c, register_repeat_end);        /* replace it with the register_repeat_end string */\r\n        if (_panel_sendf (p, &cmd_stat, NULL, \"%s\", repeat)) {\r\n            pthread_mutex_lock (&p->io_lock);\r\n            free (repeat);\r\n            break;\r\n            }\r\n        pthread_mutex_lock (&p->io_lock);\r\n        free (repeat);\r\n        p->new_register = 0;\r\n        }\r\n    /* when halted, we directly poll the halted system to get updated */\r\n    /* register state which may have changed due to panel activities */\r\n    if (p->State == Halt) {\r\n        pthread_mutex_unlock (&p->io_lock);\r\n        if (_panel_get_registers (p, 1, NULL)) {\r\n            pthread_mutex_lock (&p->io_lock);\r\n            break;\r\n            }\r\n        if (p->callback)\r\n            p->callback (p, p->simulation_time_base + p->simulation_time, p->callback_context);\r\n        pthread_mutex_lock (&p->io_lock);\r\n        }\r\n    }\r\npthread_mutex_unlock (&p->io_lock);\r\n/* stop any established repeating activity in the simulator */\r\nif (p->parent == NULL) {        /* Top level panel? */\r\n    _panel_debug (p, DBG_THR, \"Stopping All Repeats before exiting\", NULL, 0);\r\n    _panel_sendf (p, &cmd_stat, NULL, \"%s\", register_repeat_stop_all);\r\n    }\r\nelse {\r\n    _panel_debug (p, DBG_THR, \"Stopping Repeats before exiting\", NULL, 0);\r\n    _panel_sendf (p, &cmd_stat, NULL, \"%s\", register_repeat_stop);\r\n    }\r\npthread_mutex_lock (&p->io_lock);\r\n_panel_debug (p, DBG_THR, \"Exiting\", NULL, 0);\r\npthread_setspecific (panel_thread_id, NULL);\r\np->callback_thread_running = 0;\r\npthread_mutex_unlock (&p->io_lock);\r\nfree (buf);\r\nreturn NULL;\r\n}\r\n\r\nconst char *sim_panel_get_error (void)\r\n{\r\nreturn (sim_panel_error_buf ? sim_panel_error_buf : \"\");\r\n}\r\n\r\nvoid sim_panel_clear_error (void)\r\n{\r\nif (sim_panel_error_bufsize)\r\n    free (sim_panel_error_buf);\r\nsim_panel_error_buf = NULL;\r\nsim_panel_error_bufsize = 0;\r\n}\r\n\r\n#if defined (_WIN32)\r\n#define vsnprintf _vsnprintf\r\n#endif\r\n\r\nstatic int sim_panel_set_error (PANEL *p, const char *fmt, ...)\r\n{\r\nva_list arglist;\r\nint len;\r\n\r\nif (p) {\r\n    pthread_mutex_lock (&p->io_lock);\r\n    p->State = Error;\r\n    if (p->io_waiting != 0) {\r\n        p->io_waiting = 0;\r\n        pthread_cond_signal (&p->io_done);\r\n        }\r\n    pthread_mutex_unlock (&p->io_lock);\r\n    }\r\nif (sim_panel_error_bufsize == 0) {\r\n    sim_panel_error_bufsize = 2048;\r\n    sim_panel_error_buf = (char *) malloc (sim_panel_error_bufsize);\r\n    if (sim_panel_error_buf == NULL) {\r\n        sim_panel_error_buf = (char *)\"sim_panel_set_error(): Out of Memory\\n\";\r\n        sim_panel_error_bufsize = 0;\r\n        return -1;\r\n        }\r\n    }\r\nsim_panel_error_buf[sim_panel_error_bufsize-1] = '\\0';\r\n\r\nwhile (1) {                                         /* format passed string, args */\r\n    va_start (arglist, fmt);\r\n    len = vsnprintf (sim_panel_error_buf, sim_panel_error_bufsize-1, fmt, arglist);\r\n    va_end (arglist);\r\n\r\n    if (len < 0)        /* Format encoding error? */\r\n        break;\r\n    /* If the formatted result didn't fit into the buffer, then grow the buffer and try again */\r\n    if (len >= (int)(sim_panel_error_bufsize-1)) {\r\n        free (sim_panel_error_buf);\r\n        sim_panel_error_bufsize = sim_panel_error_bufsize * 2;\r\n        while ((int)sim_panel_error_bufsize < len + 2)\r\n            sim_panel_error_bufsize = sim_panel_error_bufsize * 2;\r\n        sim_panel_error_buf = (char *) malloc (sim_panel_error_bufsize);\r\n        if (sim_panel_error_buf == NULL) {\r\n            sim_panel_error_buf = (char *)\"sim_panel_set_error(): Out of Memory\\n\";\r\n            sim_panel_error_bufsize = 0;\r\n            return -1;\r\n            }\r\n        sim_panel_error_buf[sim_panel_error_bufsize-1] = '\\0';\r\n        continue;\r\n        }\r\n    break;\r\n    }\r\nreturn -1;\r\n}\r\n\r\nstatic int\r\n_panel_vsendf_completion (PANEL *p, int *completion_status, char **response, const char *completion_string, const char *fmt, va_list arglist)\r\n{\r\nchar stackbuf[1024];\r\nint bufsize = sizeof(stackbuf);\r\nchar *buf = stackbuf;\r\nint len, status_echo_len = 0, sent_len;\r\nint post_fix_len = completion_status ? 7 + sizeof (command_done_echo) + sizeof (command_status) : 1;\r\nint ret;\r\n\r\nif (completion_status && completion_string)         /* one or the other, but */\r\n    return -1;                                      /* not both */\r\n\r\nwhile (1) {                                         /* format passed string, args */\r\n    len = vsnprintf (buf, bufsize-1, fmt, arglist);\r\n\r\n    if (len < 0)\r\n        return sim_panel_set_error (NULL, \"Format encoding error while processing '%s'\", fmt);\r\n\r\n    /* If the formatted result didn't fit into the buffer, then grow the buffer and try again */\r\n    if ((len + post_fix_len) >= bufsize-1) {\r\n        if (buf != stackbuf)\r\n            free (buf);\r\n        bufsize = bufsize * 2;\r\n        if (bufsize < (len + post_fix_len + 2))\r\n            bufsize = len + post_fix_len + 2;\r\n        buf = (char *) _panel_malloc (bufsize);\r\n        if (buf == NULL)\r\n            return -1;\r\n        buf[bufsize-1] = '\\0';\r\n        continue;\r\n        }\r\n    break;\r\n    }\r\n\r\nif (len && (buf[len-1] != '\\r')) {\r\n    strcpy (&buf[len], \"\\r\");           /* Make sure command line is nul terminated */\r\n    ++len;\r\n    }\r\n\r\npthread_mutex_lock (&p->io_command_lock);\r\n++p->command_count;\r\nif (completion_status || completion_string) {\r\n    if (completion_status) {\r\n        sprintf (&buf[len], \"%s\\r%s\\r\", command_status, command_done_echo);\r\n        status_echo_len = strlen (&buf[len]);\r\n        }\r\n    pthread_mutex_lock (&p->io_lock);\r\n    p->completion_string = completion_string;\r\n    if (p->io_response_data)\r\n        _panel_debug (p, DBG_RCV, \"Receive Data Discarded: \", p->io_response, p->io_response_data);\r\n    p->io_response_data = 0;\r\n    p->io_waiting = p->command_count;\r\n    }\r\n\r\n_panel_debug (p, DBG_REQ, \"Command %d Request%s: %*.*s\", NULL, 0, p->command_count, completion_status ? \" (with response)\" : \"\", len, len, buf);\r\nret = ((len + status_echo_len) == (sent_len = _panel_send (p, buf, len + status_echo_len))) ? 0 : -1;\r\n\r\nif (completion_status || completion_string) {\r\n    if (ret) {                                      /* Send failed? */\r\n        p->completion_string = NULL;\r\n        p->io_waiting = 0;\r\n        }\r\n    else {                                          /* Sent OK? */\r\n        char *tresponse = NULL;\r\n\r\n        while (p->io_waiting != 0)\r\n            pthread_cond_wait (&p->io_done, &p->io_lock); /* Wait for completion */\r\n        tresponse = (char *)_panel_malloc (p->io_response_data + 1);\r\n        if (0 == memcmp (buf, p->io_response + strlen (sim_prompt), len)) {\r\n            char *eol, *status;\r\n            memcpy (tresponse, p->io_response + strlen (sim_prompt) + len + 1, p->io_response_data + 1 - (strlen (sim_prompt) + len + 1));\r\n            if (completion_status) {\r\n                *completion_status = -1;\r\n                status = strstr (tresponse, command_status);\r\n                if (status) {\r\n                    *(status - strlen (sim_prompt)) = '\\0';\r\n                    status += strlen (command_status) + 2;\r\n                    eol = strchr (status, '\\r');\r\n                    if (eol)\r\n                        *eol = '\\0';\r\n                    sscanf (status, \"Status:%08X-\", completion_status);\r\n                    }\r\n                }\r\n            }\r\n        else\r\n            memcpy (tresponse, p->io_response, p->io_response_data + 1);\r\n        if (response) {\r\n            *response = tresponse;\r\n            if (completion_status)\r\n                _panel_debug (p, DBG_RSP, \"Command %d Response(Status=%d): '%s'\", NULL, 0, p->command_count, *completion_status, *response);\r\n            else\r\n                _panel_debug (p, DBG_RSP, \"Command %d Response - Match '%s': '%s'\", NULL, 0, p->command_count, completion_string, *response);\r\n            }\r\n        else {\r\n            free (tresponse);\r\n            if (p->io_response_data) {\r\n                if (completion_status)\r\n                    _panel_debug (p, DBG_RSP, \"Discarded Unwanted Command %d Response Data(Status=%d):\", p->io_response, p->io_response_data, p->command_count, *completion_status);\r\n                else\r\n                    _panel_debug (p, DBG_RSP, \"Discarded Unwanted Command %d Response Data - Match '%s':\", p->io_response, p->io_response_data, p->command_count, completion_string);\r\n                }\r\n            }\r\n        }\r\n    p->completion_string = NULL;\r\n    p->io_response_data = 0;\r\n    p->io_response[0] = '\\0';\r\n    pthread_mutex_unlock (&p->io_lock);\r\n    }\r\nelse {\r\n    if (ret)\r\n        sim_panel_set_error (p, \"Unexpected send length: %d, expected: %d\", sent_len, len + status_echo_len);\r\n    }\r\npthread_mutex_unlock (&p->io_command_lock);\r\n\r\nif (buf != stackbuf)\r\n    free (buf);\r\nreturn ret;\r\n}\r\n\r\nstatic int\r\n_panel_sendf (PANEL *p, int *completion_status, char **response, const char *fmt, ...)\r\n{\r\nva_list arglist;\r\nint status;\r\n\r\nva_start (arglist, fmt);\r\nstatus = _panel_vsendf_completion (p, completion_status, response, NULL, fmt, arglist);\r\nva_end (arglist);\r\nreturn status;\r\n}\r\n\r\nstatic int\r\n_panel_sendf_completion (PANEL *p, char **response, const char *completion, const char *fmt, ...)\r\n{\r\nva_list arglist;\r\nint status;\r\n\r\nva_start (arglist, fmt);\r\nstatus = _panel_vsendf_completion (p, NULL, response, completion, fmt, arglist);\r\nva_end (arglist);\r\nreturn status;\r\n}\r\n\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n"
        },
        {
          "name": "sim_frontpanel.h",
          "type": "blob",
          "size": 24.04296875,
          "content": "/* sim_frontpanel.h: simulator frontpanel API definitions\r\n\r\n   Copyright (c) 2015, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   MARK PIZZOLATO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Mark Pizzolato shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Mark Pizzolato.\r\n\r\n   15-Jan-15    MP      Initial implementation\r\n   01-Apr-15    MP      Added register indirect, mem_examine and mem_deposit\r\n   03-Apr-15    MP      Added logic to pass simulator startup messages in\r\n                        panel error text if the connection to the simulator\r\n                        shuts down while it is starting.\r\n   04-Apr-15    MP      Added mount and dismount routines to connect and\r\n                        disconnect removable media\r\n\r\n   This module defines interface between a front panel application and a simh\r\n   simulator.  Facilities provide ways to gather information from and to\r\n   observe and control the state of a simulator.\r\n\r\n   Any application which wants to use this API needs to:\r\n      1) include this file in the application code\r\n      2) compile sim_frontpanel.c and sim_sock.c from the top level directory\r\n         of the simh source.\r\n      3) link the sim_frontpanel and sim_sock object modules and libpthreads\r\n         into the application.\r\n      4) Use a simh simulator built from the same version of simh that the\r\n         sim_frontpanel and sim_sock modules came from.\r\n*/\r\n\r\n#ifndef SIM_FRONTPANEL_H_\r\n#define SIM_FRONTPANEL_H_     0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include <stdlib.h>\r\n\r\n#if !defined(__VAX)         /* Unsupported platform */\r\n\r\n#define SIM_FRONTPANEL_VERSION   15\r\n\r\n/**\r\n\r\n    sim_panel_start_simulator       A starts a simulator with a particular\r\n                                    configuration\r\n\r\n        sim_path            the path to the simulator binary\r\n        sim_config          the configuration to run the simulator with\r\n        device_panel_count  the number of sub panels for connected devices\r\n\r\n    Note 1: - The path specified must be either a fully specified path or\r\n              it could be merely the simulator name if the simulator binary\r\n              is located in the current PATH.\r\n            - The simulator binary must be built from the same version\r\n              simh source code that the frontpanel API was acquired from\r\n              (the API and the simh framework must speak the same language)\r\n\r\n    Note 2: - Configuration file specified should contain device setup\r\n              statements (enable, disable, CPU types and attach commands).\r\n              It should not start a simulator running.\r\n */\r\n\r\ntypedef struct PANEL PANEL;\r\n\r\nPANEL *\r\nsim_panel_start_simulator (const char *sim_path,\r\n                           const char *sim_config,\r\n                           size_t device_panel_count);\r\n\r\nPANEL *\r\nsim_panel_start_simulator_debug (const char *sim_path,\r\n                                 const char *sim_config,\r\n                                 size_t device_panel_count,\r\n                                 const char *debug_file);\r\n\r\n/**\r\n\r\n    sim_panel_add_device_panel - creates a sub panel associated\r\n                                 with a specific simulator panel\r\n\r\n        simulator_panel     the simulator panel to connect to\r\n        device_name         the simulator's name for the device\r\n */\r\n\r\nPANEL *\r\nsim_panel_add_device_panel (PANEL *simulator_panel,\r\n                            const char *device_name);\r\n\r\n/**\r\n\r\n    sim_panel_destroy   to shutdown a panel or sub panel.\r\n\r\n    Note: destroying a simulator panel will also destroy any\r\n          related sub panels\r\n */\r\n\r\nint\r\nsim_panel_destroy (PANEL **ppanel);\r\n\r\n/**\r\n\r\n   The frontpanel API exposes the state of a simulator via access to\r\n   simh register variables that the simulator and its devices define.\r\n   These registers certainly include any architecturally described\r\n   registers (PC, PSL, SP, etc.), but also include anything else\r\n   the simulator uses as internal state to implement the running\r\n   simulator.\r\n\r\n   The registers that a particular frontpanel application might need\r\n   access to are specified by the application when it calls:\r\n\r\n   sim_panel_add_register\r\n   sim_panel_add_register_bits\r\n   sim_panel_add_register_array\r\nand\r\n   sim_panel_add_register_indirect\r\n   sim_panel_add_register_indirect_bits\r\n\r\n        name         the name the simulator knows this register by\r\n        device_name  the device this register is part of.  Defaults to\r\n                     the device of the panel (in a device panel) or the\r\n                     default device in the simulator (usually the CPU).\r\n        element_count number of elements in the register array\r\n        size         the size (in local storage) of the buffer which will\r\n                     receive the data in the simulator's register\r\n        addr         a pointer to the location of the buffer which will\r\n                     be loaded with the data in the simulator's register\r\n        bit_width    the number of values to populate in the bits array\r\n        bits         an array of integers which is bit_width long that\r\n                     will receive each bit's current accumulated value.\r\n                     The accumulated value will range from 0 thru the\r\n                     the sample_depth specified when calling\r\n                     sim_panel_set_sampling_parameters().\r\n\r\n    Notes:    There are two categories of REGisters in simulators:\r\n           1) Many simulators contain every interesting simh REGisters\r\n              in single variables and use those variables directly\r\n              throughout the simulator as needed by the system being\r\n              simulated.\r\n           2) Some simulators have some of their REGisters in a single\r\n              variable, but during instruction execution, the actual\r\n              contents of that REGister is split into possibly multiple\r\n              pieces which are assembled into the single variable when\r\n              the simulator stops instruction execution and split apart\r\n              again when simulation starts executing instructions again.\r\n              An example of this case is the PSL on the VAX simulator.\r\n              In the VAX architecture, the PSL register contains the\r\n              condition code information which is a field in the PSL.\r\n              For efficiency sake, while sim_instr() is executing\r\n              instructions, the condition code is stored a separate\r\n              variable CC.  Whenever sim_instr() exits, the pieces\r\n              that comprise this register are put together into the\r\n              PSL variable.  This allows the PSL register to be examined\r\n              and/or deposited to directly from SCP as needed. The PDP11\r\n              simulator handles its PSW in a similar way breaking it\r\n              into pieces during sim_instr() execution and reassembling\r\n              it upon exit.\r\n\r\n              Therefore, if every REGister that an application that\r\n              uses the sim_frontpanel register APIs is always stored\r\n              in single variables (case 1 above), then front panel\r\n              access to registers can be most efficient if, at\r\n              initialization time, the simulator calls the\r\n              sim_set_stable_registers_state() API.\r\n              Having called this API allows the internals of the\r\n              frontpanel access activities to be significantly more\r\n              efficient.\r\n\r\n */\r\n\r\nint\r\nsim_panel_add_register (PANEL *panel,\r\n                        const char *name,\r\n                        const char *device_name,\r\n                        size_t size,\r\n                        void *addr);\r\n\r\nint\r\nsim_panel_add_register_bits (PANEL *panel,\r\n                             const char *name,\r\n                             const char *device_name,\r\n                             size_t bit_width,\r\n                             int *bits);\r\n\r\nint\r\nsim_panel_add_register_array (PANEL *panel,\r\n                              const char *name,\r\n                              const char *device_name,\r\n                              size_t element_count,\r\n                              size_t size,\r\n                              void *addr);\r\n\r\nint\r\nsim_panel_add_register_indirect (PANEL *panel,\r\n                                 const char *name,\r\n                                 const char *device_name,\r\n                                 size_t size,\r\n                                 void *addr);\r\n\r\nint\r\nsim_panel_add_register_indirect_bits (PANEL *panel,\r\n                                      const char *name,\r\n                                      const char *device_name,\r\n                                      size_t bit_width,\r\n                                      int *bits);\r\n\r\n/**\r\n\r\n    A panel application has a choice of two different methods of getting\r\n    the values contained in the set of registers it has declared interest in via\r\n    the sim_panel_add_register APIs.\r\n\r\n       1)  The values can be polled (whenever it is desired) by calling\r\n           sim_panel_get_registers().\r\n       2)  The panel can call sim_panel_set_display_callback_interval() to\r\n           specify a callback routine and a periodic rate that the callback\r\n           routine should be called.  The panel API will make a best effort\r\n           to deliver the current register state at the desired rate.\r\n\r\n\r\n   Note 1: The buffers described in a panel's register set will be\r\n           dynamically revised as soon as data is available from the\r\n           simulator.  The callback routine merely serves as a notification\r\n           that a complete register set has arrived.\r\n   Note 2: The callback routine should, in general, not run for a long time\r\n           or frontpanel interactions with the simulator may be disrupted.\r\n           Setting a flag, signaling an event or posting a message are\r\n           reasonable activities to perform in a callback routine.\r\n */\r\n\r\nint\r\nsim_panel_get_registers (PANEL *panel, unsigned long long *simulation_time);\r\n\r\ntypedef void (*PANEL_DISPLAY_PCALLBACK)(PANEL *panel,\r\n                                        unsigned long long simulation_time,\r\n                                        void *context);\r\n\r\nint\r\nsim_panel_set_display_callback_interval (PANEL *panel,\r\n                                         PANEL_DISPLAY_PCALLBACK callback,\r\n                                         void *context,\r\n                                         int usecs_between_callbacks);\r\n\r\n/**\r\n\r\n    When a front panel application wants to get averaged bit sample\r\n    values, it must first declare the sampling parameters that will\r\n    be used while collecting the bit values.  The dithering\r\n    percentage must be 25% or less and when non 0 causes the sample\r\n    frequency to vary by plus or minus a random percentage value up\r\n    to the specified value.\r\n\r\n   sim_panel_set_sampling_parameters\r\n   sim_panel_set_sampling_parameters_ex\r\n\r\n        sample_frequency    cycles/instructions between sample captures\r\n        sample_dither_pct   percentage of sample_frequency to vary randomly\r\n        sample_depth        how many samples to accumulate in the rolling\r\n                            average for each bit sample.  Returned bit\r\n                            sample values will range from 0 thru this\r\n                            value.\r\n */\r\n\r\nint\r\nsim_panel_set_sampling_parameters_ex (PANEL *panel,\r\n                                      unsigned int sample_frequency,\r\n                                      unsigned int sample_dither_pct,\r\n                                      unsigned int sample_depth);\r\n\r\nint\r\nsim_panel_set_sampling_parameters (PANEL *panel,\r\n                                   unsigned int sample_frequency,\r\n                                   unsigned int sample_depth);\r\n/**\r\n\r\n    When a front panel application needs to change the running\r\n    state of a simulator one of the following routines should\r\n    be called:\r\n\r\n    sim_panel_exec_halt     - Stop instruction execution\r\n    sim_panel_exec_boot     - Boot a simulator from a specific device\r\n    sim_panel_exec_run      - Start/Resume a simulator running instructions\r\n    sim_panel_exec_start    - Start a simulator running instructions\r\n                              after resetting all devices\r\n    sim_panel_exec_step     - Have a simulator execute a single step\r\n */\r\n\r\nint\r\nsim_panel_exec_halt (PANEL *panel);\r\n\r\nint\r\nsim_panel_exec_boot (PANEL *panel, const char *device);\r\n\r\nint\r\nsim_panel_exec_start (PANEL *panel);\r\n\r\nint\r\nsim_panel_exec_run (PANEL *panel);\r\n\r\nint\r\nsim_panel_exec_step (PANEL *panel);\r\n\r\n\r\n\r\n/**\r\n    A simulator often displays some useful information as it stops\r\n    executing instructions.\r\n\r\n    sim_panel_halt_text     - Returns the simulator output immediately prior\r\n                              to the most recent transition to the Halt state.\r\n */\r\n\r\nconst char *\r\nsim_panel_halt_text (PANEL *panel);\r\n\r\n/**\r\n\r\n    When a front panel application wants to describe conditions that\r\n    should stop instruction execution an execution or an output\r\n    breakpoint should be used.  To established or clear a breakpoint,\r\n    one of the following routines should be called:\r\n\r\n    sim_panel_break_set          - Establish a simulation breakpoint\r\n    sim_panel_break_clear        - Cancel/Delete a previously defined\r\n                                   breakpoint\r\n    sim_panel_break_output_set   - Establish a simulator output\r\n                                   breakpoint\r\n    sim_panel_break_output_clear - Cancel/Delete a previously defined\r\n                                   output breakpoint\r\n\r\n    Note: Any breakpoint switches/flags must be located at the\r\n          beginning of the condition string\r\n */\r\n\r\nint\r\nsim_panel_break_set (PANEL *panel, const char *condition);\r\n\r\nint\r\nsim_panel_break_clear (PANEL *panel, const char *condition);\r\n\r\nint\r\nsim_panel_break_output_set (PANEL *panel, const char *condition);\r\n\r\nint\r\nsim_panel_break_output_clear (PANEL *panel, const char *condition);\r\n\r\n\r\n/**\r\n\r\n    When a front panel application needs to change or access\r\n    memory or a register one of the following routines should\r\n    be called:\r\n\r\n    sim_panel_gen_examine               - Examine register or memory\r\n    sim_panel_gen_deposit               - Deposit to register or memory\r\n    sim_panel_mem_examine               - Examine memory location\r\n    sim_panel_mem_deposit               - Deposit to memory location\r\n    sim_panel_mem_deposit_instruction   - Deposit instruction to memory\r\n                                          location\r\n    sim_panel_set_register_value        - Deposit to a register or memory\r\n                                          location\r\n */\r\n\r\n\r\n/**\r\n\r\n   sim_panel_gen_examine\r\n\r\n        name_or_addr the name the simulator knows this register by\r\n        size         the size (in local storage) of the buffer which will\r\n                     receive the data returned when examining the simulator\r\n        value        a pointer to the buffer which will be loaded with the\r\n                     data returned when examining the simulator\r\n */\r\n\r\nint\r\nsim_panel_gen_examine (PANEL *panel,\r\n                       const char *name_or_addr,\r\n                       size_t size,\r\n                       void *value);\r\n\r\n/**\r\n\r\n   sim_panel_gen_deposit\r\n\r\n        name_or_addr the name the simulator knows this register by\r\n        size         the size (in local storage) of the buffer which\r\n                     contains the data to be deposited into the simulator\r\n        value        a pointer to the buffer which contains the data to\r\n                     be deposited into the simulator\r\n */\r\n\r\nint\r\nsim_panel_gen_deposit (PANEL *panel,\r\n                       const char *name_or_addr,\r\n                       size_t size,\r\n                       const void *value);\r\n\r\n/**\r\n\r\n   sim_panel_mem_examine\r\n\r\n        addr_size    the size (in local storage) of the buffer which\r\n                     contains the memory address of the data to be examined\r\n                     in the simulator\r\n        addr         a pointer to the buffer containing the memory address\r\n                     of the data to be examined in the simulator\r\n        value_size   the size (in local storage) of the buffer which will\r\n                     receive the data returned when examining the simulator\r\n        value        a pointer to the buffer which will be loaded with the\r\n                     data returned when examining the simulator\r\n */\r\n\r\nint\r\nsim_panel_mem_examine (PANEL *panel,\r\n                       size_t addr_size,\r\n                       const void *addr,\r\n                       size_t value_size,\r\n                       void *value);\r\n\r\n/**\r\n\r\n   sim_panel_mem_deposit\r\n\r\n        addr_size    the size (in local storage) of the buffer which\r\n                     contains the memory address of the data to be deposited\r\n                     into the simulator\r\n        addr         a pointer to the buffer containing the memory address\r\n                     of the data to be deposited into the simulator\r\n        value_size   the size (in local storage) of the buffer which will\r\n                     contains the data to be deposited into the simulator\r\n        value        a pointer to the buffer which contains the data to be\r\n                     deposited into the simulator\r\n */\r\n\r\nint\r\nsim_panel_mem_deposit (PANEL *panel,\r\n                       size_t addr_size,\r\n                       const void *addr,\r\n                       size_t value_size,\r\n                       const void *value);\r\n\r\n/**\r\n\r\n   sim_panel_mem_deposit_instruction\r\n\r\n        addr_size    the size (in local storage) of the buffer which\r\n                     contains the memory address of the data to be deposited\r\n                     into the simulator\r\n        addr         a pointer to the buffer containing the memory address\r\n                     of the data to be deposited into the simulator\r\n        instruction  a pointer to the buffer that contains the mnemonic\r\n                     instruction to be deposited at the indicated address\r\n */\r\n\r\nint\r\nsim_panel_mem_deposit_instruction (PANEL *panel,\r\n                                   size_t addr_size,\r\n                                   const void *addr,\r\n                                   const char *instruction);\r\n\r\n/**\r\n\r\n   sim_panel_set_register_value\r\n\r\n        name        the name of a simulator register or a memory address\r\n                    which is to receive a new value\r\n        value       the new value in character string form.  The string\r\n                    must be in the native/natural radix that the simulator\r\n                    uses when referencing that register\r\n */\r\nint\r\nsim_panel_set_register_value (PANEL *panel,\r\n                              const char *name,\r\n                              const char *value);\r\n\r\n/**\r\n\r\n    A front panel application might want to have access to the\r\n    instruction execution history that a simulator may be capable\r\n    of providing.  If this functionality is desired, enabling of\r\n    recording instruction history should be explicitly enabled\r\n    in the sim_config file that the simulator is started with.\r\n */\r\n\r\n/**\r\n\r\n   sim_panel_get_history\r\n\r\n        count        the number of instructions to return\r\n        size         the size (in local storage) of the buffer which will\r\n                     receive the data returned when examining the simulator\r\n        buffer       a pointer to the buffer which will be loaded with the\r\n                     instruction history returned from the simulator\r\n */\r\n\r\nint\r\nsim_panel_get_history (PANEL *panel,\r\n                       int count,\r\n                       size_t size,\r\n                       char *buffer);\r\n\r\n\r\n/**\r\n\r\n    A front panel application might want some details of simulator\r\n    and/or device behavior that is provided by a particular simulator\r\n    via debug information.  Debugging for particular device(s)\r\n    and/or simulator debug settings can be controlled via the\r\n    sim_panel_device_debug_mode API.\r\n */\r\n\r\n/**\r\n\r\n   sim_panel_device_debug_mode\r\n\r\n        device       the device whose debug mode is to change\r\n        set_unset    1 to set debug flags, 0 to clear debug flags\r\n        mode_bits    character string with different debug mode bits\r\n                     to enable or disable.  An empty string will\r\n                     enable or disable all mode bits for the specified\r\n                     device\r\n */\r\n\r\nint\r\nsim_panel_device_debug_mode (PANEL *panel,\r\n                             const char *device,\r\n                             int set_unset,\r\n                             const char *mode_bits);\r\n\r\n\r\n/**\r\n\r\n    When a front panel application needs to change the media\r\n    in a simulated removable media device one of the following\r\n    routines should be called:\r\n\r\n    sim_panel_mount    - mounts the indicated media file on a device\r\n    sim_panel_dismount - dismounts the currently mounted media file\r\n                         from a device\r\n */\r\n\r\n/**\r\n\r\n   sim_panel_mount\r\n\r\n        device      the name of a simulator device/unit\r\n        switches    any switches appropriate for the desire attach\r\n        path        the path on the local system to be attached\r\n */\r\n\r\nint\r\nsim_panel_mount (PANEL *panel,\r\n                 const char *device,\r\n                 const char *switches,\r\n                 const char *path);\r\n\r\n/**\r\n\r\n   sim_panel_dismount\r\n\r\n        device      the name of a simulator device/unit\r\n */\r\n\r\nint\r\nsim_panel_dismount (PANEL *panel,\r\n                    const char *device);\r\n\r\n\r\ntypedef enum {\r\n    Halt,       /* Simulation is halted (instructions not being executed) */\r\n    Run,        /* Simulation is executing instructions */\r\n    Error       /* Panel simulator is in an error state and should be */\r\n                /* closed (destroyed).  sim_panel_get_error might help */\r\n                /* explain why */\r\n    } OperationalState;\r\n\r\nOperationalState\r\nsim_panel_get_state (PANEL *panel);\r\n\r\n/**\r\n\r\n    All API routines which return an int return 0 for\r\n    success and -1 for an error.\r\n\r\n    An API which returns an error (-1), will not change the panel state\r\n    except to possibly set the panel state to Error if the panel\r\n    condition is no longer useful.\r\n\r\n    sim_panel_get_error     - the details of the most recent error\r\n    sim_panel_clear_error   - clears the error buffer\r\n */\r\n\r\nconst char *sim_panel_get_error (void);\r\nvoid sim_panel_clear_error (void);\r\n\r\n/**\r\n\r\n    The panel<->simulator wire protocol can be traced if protocol problems arise.\r\n\r\n    sim_panel_set_debug_mode    - Specifies the debug detail to be recorded\r\n    sim_panel_flush_debug       - Flushes debug output to disk\r\n    sim_panel_debug       -       Write message to the debug file\r\n\r\n */\r\n#define DBG_XMT         1   /* Transmit Data */\r\n#define DBG_RCV         2   /* Receive Data */\r\n#define DBG_REQ         4   /* Request Data */\r\n#define DBG_RSP         8   /* Response Data */\r\n#define DBG_THR        16   /* Thread Activities */\r\n#define DBG_APP        32   /* Application Activities */\r\n\r\nvoid\r\nsim_panel_set_debug_mode (PANEL *panel, int debug_bits);\r\n\r\nvoid\r\nsim_panel_debug (PANEL *panel, const char *fmt, ...);\r\n\r\nvoid\r\nsim_panel_flush_debug (PANEL *panel);\r\n\r\n#endif /* !defined(__VAX) */\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* SIM_FRONTPANEL_H_ */\r\n"
        },
        {
          "name": "sim_imd.c",
          "type": "blob",
          "size": 30.69140625,
          "content": "/*************************************************************************\r\n *                                                                       *\r\n * Copyright (c) 2007-2023 Howard M. Harte.                              *\r\n * https://github.com/hharte                                             *\r\n *                                                                       *\r\n * Permission is hereby granted, free of charge, to any person obtaining *\r\n * a copy of this software and associated documentation files (the       *\r\n * \"Software\"), to deal in the Software without restriction, including   *\r\n * without limitation the rights to use, copy, modify, merge, publish,   *\r\n * distribute, sublicense, and/or sell copies of the Software, and to    *\r\n * permit persons to whom the Software is furnished to do so, subject to *\r\n * the following conditions:                                             *\r\n *                                                                       *\r\n * The above copyright notice and this permission notice shall be        *\r\n * included in all copies or substantial portions of the Software.       *\r\n *                                                                       *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,       *\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    *\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-            *\r\n * INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE   *\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN       *\r\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN     *\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE      *\r\n * SOFTWARE.                                                             *\r\n *                                                                       *\r\n * Except as contained in this notice, the names of The Authors shall    *\r\n * not be used in advertising or otherwise to promote the sale, use or   *\r\n * other dealings in this Software without prior written authorization   *\r\n * from the Authors.                                                     *\r\n *                                                                       *\r\n * Module Description:                                                   *\r\n *     ImageDisk Disk Image File access module for SIMH, definitions.    *\r\n *     See: http://dunfield.classiccmp.org/img/index.htm                 *\r\n *     for details on the ImageDisk format and other utilities.          *\r\n *                                                                       *\r\n *************************************************************************/\r\n\r\n/* Change log:\r\n     - 06-Aug-2008, Tony Nicholson, Add support for logical Head and\r\n                    Cylinder maps in the .IMD image file (AGN)\r\n*/\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_imd.h\"\r\n\r\nstatic t_stat commentParse(DISK_INFO *myDisk, uint8 comment[], uint32 buffLen);\r\nstatic t_stat diskParse(DISK_INFO *myDisk, uint32 isVerbose);\r\nstatic t_stat diskFormat(DISK_INFO *myDisk);\r\n\r\n/* Open an existing IMD disk image.  It will be opened and parsed, and after this\r\n * call, will be ready for sector read/write. The result is the corresponding\r\n * DISK_INFO or NULL if an error occurred.\r\n */\r\nDISK_INFO *diskOpenEx(FILE *fileref, uint32 isVerbose, DEVICE *device, uint32 debugmask, uint32 verbosedebugmask)\r\n{\r\n    DISK_INFO *myDisk = NULL;\r\n\r\n    myDisk = (DISK_INFO*)calloc(1, sizeof(DISK_INFO));\r\n    if (myDisk == NULL) {\r\n        sim_printf(\"%s: %s(): memory allocation failure.\\n\", __FILE__, __FUNCTION__);\r\n        return NULL;\r\n    }\r\n\r\n    myDisk->file = fileref;\r\n    myDisk->device = device;\r\n    myDisk->debugmask = debugmask;\r\n    myDisk->verbosedebugmask = verbosedebugmask;\r\n\r\n    if (diskParse(myDisk, isVerbose) != SCPE_OK) {\r\n        free(myDisk);\r\n        myDisk = NULL;\r\n    }\r\n\r\n    return myDisk;\r\n}\r\n\r\nDISK_INFO *diskOpen(FILE *fileref, uint32 isVerbose)\r\n{\r\n    return diskOpenEx(fileref, isVerbose, NULL, 0, 0);\r\n}\r\n\r\n/* Scans the IMD file for the comment string, and returns it in comment buffer.\r\n * After this function returns, the file pointer is placed after the comment and\r\n * the 0x1A \"EOF\" marker.\r\n *\r\n * The comment parameter is optional, and if NULL, then the comment will not\r\n * be extracted from the IMD file, but the file position will still be advanced\r\n * to the end of the comment.\r\n */\r\nstatic t_stat commentParse(DISK_INFO *myDisk, uint8 comment[], uint32 buffLen)\r\n{\r\n    uint8 cData;\r\n    uint32 commentLen = 0;\r\n\r\n    /* rewind to the beginning of the file. */\r\n    rewind(myDisk->file);\r\n    cData = (uint8)fgetc(myDisk->file);\r\n    while ((!feof(myDisk->file)) && (cData != 0x1a)) {\r\n        if ((comment != NULL) && (commentLen < buffLen)) {\r\n            comment[commentLen++] = cData;\r\n        }\r\n        cData = (uint8)fgetc(myDisk->file);\r\n    }\r\n    if (comment != NULL) {\r\n        if (commentLen == buffLen)\r\n            commentLen--;\r\n        comment[commentLen] = 0;\r\n    }\r\n    return SCPE_OK;\r\n}\r\n\r\nstatic uint32 headerOk(IMD_HEADER imd) {\r\n    return (imd.cyl < MAX_CYL) && (imd.head < MAX_HEAD);\r\n}\r\n\r\n/* Parse an IMD image.  This sets up sim_imd to be able to do sector read/write and\r\n * track write.\r\n */\r\nstatic t_stat diskParse(DISK_INFO *myDisk, uint32 isVerbose)\r\n{\r\n    uint8 comment[256];\r\n    uint8 sectorMap[256];\r\n    uint8 sectorHeadMap[256];\r\n    uint8 sectorCylMap[256];\r\n    uint32 sectorSize, sectorHeadwithFlags, sectRecordType;\r\n    uint32 hdrBytes, i;\r\n    uint8 start_sect;\r\n\r\n    uint32 TotalSectorCount = 0;\r\n    IMD_HEADER imd;\r\n\r\n    if(myDisk == NULL) {\r\n        return (SCPE_OPENERR);\r\n    }\r\n\r\n    memset(myDisk->track, 0, (sizeof(TRACK_INFO)*MAX_CYL*MAX_HEAD));\r\n\r\n    if (commentParse(myDisk, comment, sizeof(comment)) != SCPE_OK) {\r\n        return (SCPE_OPENERR);\r\n    }\r\n\r\n    if(isVerbose)\r\n        sim_printf(\"%s\\n\", comment);\r\n\r\n    myDisk->nsides = 1;\r\n    myDisk->ntracks = 0;\r\n    myDisk->flags = 0;      /* Make sure all flags are clear. */\r\n\r\n    if(feof(myDisk->file)) {\r\n        sim_printf(\"SIM_IMD: Disk image is blank, it must be formatted.\\n\");\r\n        return (SCPE_OPENERR);\r\n    }\r\n\r\n    do {\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"start of track %d at file offset %ld\\n\", myDisk->ntracks, ftell(myDisk->file));\r\n\r\n        hdrBytes = sim_fread(&imd, 1, 5, myDisk->file);\r\n\r\n        if ((hdrBytes == 0) && feof(myDisk->file))\r\n            break; /* detected end of IMD file */\r\n\r\n        if (hdrBytes != 5) {\r\n            sim_printf(\"SIM_IMD: Header read returned %d bytes instead of 5.\\n\", hdrBytes);\r\n            return (SCPE_OPENERR);\r\n        }\r\n\r\n        if (feof(myDisk->file))\r\n            break;\r\n        sectorSize = 128 << (imd.sectsize & 0x1f);\r\n        sectorHeadwithFlags = imd.head; /*AGN save the head and flags */\r\n        imd.head &= 1 ; /*AGN mask out flag bits to head 0 or 1 */\r\n\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"Track %d:\\n\", myDisk->ntracks);\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"\\tMode=%d, Cyl=%d, Head=%d(%d), #sectors=%d, sectsize=%d (%d bytes)\\n\", imd.mode, imd.cyl, sectorHeadwithFlags, imd.head, imd.nsects, imd.sectsize, sectorSize);\r\n\r\n        if (!headerOk(imd)) {\r\n            sim_printf(\"SIM_IMD: Corrupt header.\\n\");\r\n            return (SCPE_OPENERR);\r\n        }\r\n\r\n        if((imd.head + 1) > myDisk->nsides) {\r\n            myDisk->nsides = imd.head + 1;\r\n        }\r\n\r\n        if (imd.head >= MAX_HEAD) {\r\n            sim_printf(\"SIM_IMD: Invalid head %d, a maximum of %d heads are supported.\\n\",\r\n                imd.head, MAX_HEAD);\r\n            return (SCPE_IERR);\r\n        }\r\n\r\n        if (imd.cyl >= MAX_CYL) {\r\n            sim_printf(\"SIM_IMD: Invalid cylinder %d, a maximum of %d cylinders are supported.\\n\",\r\n                imd.cyl, MAX_CYL);\r\n            return (SCPE_IERR);\r\n        }\r\n\r\n        myDisk->track[imd.cyl][imd.head].mode = imd.mode;\r\n        myDisk->track[imd.cyl][imd.head].nsects = imd.nsects;\r\n        myDisk->track[imd.cyl][imd.head].sectsize = sectorSize;\r\n\r\n        if (sim_fread(sectorMap, 1, imd.nsects, myDisk->file) != imd.nsects) {\r\n            sim_printf(\"SIM_IMD: Corrupt file [Sector Map].\\n\");\r\n            return (SCPE_OPENERR);\r\n        }\r\n        myDisk->track[imd.cyl][imd.head].start_sector = imd.nsects;\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"\\tSector Map: \");\r\n        for(i=0;i<imd.nsects;i++) {\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"%d \", sectorMap[i]);\r\n            if(sectorMap[i] < myDisk->track[imd.cyl][imd.head].start_sector) {\r\n                myDisk->track[imd.cyl][imd.head].start_sector = sectorMap[i];\r\n            }\r\n        }\r\n        sim_debug(myDisk->debugmask, myDisk->device, \", Start Sector=%d\", myDisk->track[imd.cyl][imd.head].start_sector);\r\n\r\n        if(sectorHeadwithFlags & IMD_FLAG_SECT_HEAD_MAP) {\r\n            if (sim_fread(sectorHeadMap, 1, imd.nsects, myDisk->file) != imd.nsects) {\r\n                sim_printf(\"SIM_IMD: Corrupt file [Sector Head Map].\\n\");\r\n                return (SCPE_OPENERR);\r\n            }\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"\\tSector Head Map: \");\r\n            for(i=0;i<imd.nsects;i++) {\r\n                sim_debug(myDisk->debugmask, myDisk->device, \"%d \", sectorHeadMap[i]);\r\n            }\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"\\n\");\r\n        } else {\r\n            /* Default Head is physical head for each sector */\r\n            for(i=0;i<imd.nsects;i++) {\r\n                sectorHeadMap[i] = imd.head;\r\n            };\r\n        }\r\n\r\n        if(sectorHeadwithFlags & IMD_FLAG_SECT_CYL_MAP) {\r\n            if (sim_fread(sectorCylMap, 1, imd.nsects, myDisk->file) != imd.nsects) {\r\n                sim_printf(\"SIM_IMD: Corrupt file [Sector Cyl Map].\\n\");\r\n                return (SCPE_OPENERR);\r\n            }\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"\\tSector Cyl Map: \");\r\n            for(i=0;i<imd.nsects;i++) {\r\n                sim_debug(myDisk->debugmask, myDisk->device, \"%d \", sectorCylMap[i]);\r\n            }\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"\\n\");\r\n        } else {\r\n            /* Default Cyl Map is physical cylinder for each sector */\r\n            for(i=0;i<imd.nsects;i++) {\r\n                sectorCylMap[i] = imd.cyl;\r\n            }\r\n        }\r\n\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"\\nSector data at offset 0x%08lx\\n\", ftell(myDisk->file));\r\n\r\n        /* Build the table with location 0 being the start sector. */\r\n        start_sect = myDisk->track[imd.cyl][imd.head].start_sector;\r\n\r\n        /* Now read each sector */\r\n        for(i=0;i<imd.nsects;i++) {\r\n            TotalSectorCount++;\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"Sector Phys: %2d/Logical: %2d: %4d bytes, offset: 0x%05x: \", i, sectorMap[i], sectorSize, (unsigned int)ftell(myDisk->file));\r\n            sectRecordType = fgetc(myDisk->file);\r\n            /* AGN Logical head mapping */\r\n            myDisk->track[imd.cyl][imd.head].logicalHead[i] = sectorHeadMap[i];\r\n            /* AGN Logical cylinder mapping */\r\n            myDisk->track[imd.cyl][imd.head].logicalCyl[i] = sectorCylMap[i];\r\n            switch(sectRecordType) {\r\n                case SECT_RECORD_UNAVAILABLE:   /* Data could not be read from the original media */\r\n                    if (sectorMap[i]-start_sect < MAX_SPT)\r\n                        myDisk->track[imd.cyl][imd.head].sectorOffsetMap[sectorMap[i]-start_sect] = 0xBADBAD;\r\n                    else {\r\n                        sim_printf(\"SIM_IMD: ERROR: Illegal sector offset %d\\n\", sectorMap[i]-start_sect);\r\n                        return (SCPE_OPENERR);\r\n                    }\r\n                    break;\r\n                case SECT_RECORD_NORM:          /* Normal Data */\r\n                case SECT_RECORD_NORM_DAM:      /* Normal Data with deleted address mark */\r\n                case SECT_RECORD_NORM_ERR:      /* Normal Data with read error */\r\n                case SECT_RECORD_NORM_DAM_ERR:  /* Normal Data with deleted address mark with read error */\r\n/*                  sim_debug(myDisk->debugmask, myDisk->device, \"Uncompressed Data\\n\"); */\r\n                    if (sectorMap[i]-start_sect < MAX_SPT) {\r\n                        myDisk->track[imd.cyl][imd.head].sectorOffsetMap[sectorMap[i]-start_sect] = ftell(myDisk->file);\r\n                        (void)sim_fseek(myDisk->file, sectorSize, SEEK_CUR);\r\n                    }\r\n                    else {\r\n                        sim_printf(\"SIM_IMD: ERROR: Illegal sector offset %d\\n\", sectorMap[i]-start_sect);\r\n                        return (SCPE_OPENERR);\r\n                    }\r\n                    break;\r\n                case SECT_RECORD_NORM_COMP:     /* Compressed Normal Data */\r\n                case SECT_RECORD_NORM_DAM_COMP: /* Compressed Normal Data with deleted address mark */\r\n                case SECT_RECORD_NORM_COMP_ERR: /* Compressed Normal Data */\r\n                case SECT_RECORD_NORM_DAM_COMP_ERR: /* Compressed Normal Data with deleted address mark */\r\n                    if (sectorMap[i]-start_sect < MAX_SPT) {\r\n                        myDisk->track[imd.cyl][imd.head].sectorOffsetMap[sectorMap[i]-start_sect] = ftell(myDisk->file);\r\n                        myDisk->flags |= FD_FLAG_WRITELOCK; /* Write-protect the disk if any sectors are compressed. */\r\n                        if (1) {\r\n                            uint8 cdata = (uint8)fgetc(myDisk->file);\r\n\r\n                            sim_debug(myDisk->debugmask, myDisk->device, \"Compressed Data = 0x%02x\", cdata);\r\n                            }\r\n                    }\r\n                    else {\r\n                        sim_printf(\"SIM_IMD: ERROR: Illegal sector offset %d\\n\", sectorMap[i]-start_sect);\r\n                        return (SCPE_OPENERR);\r\n                    }\r\n                    break;\r\n                default:\r\n                    sim_printf(\"SIM_IMD: ERROR: unrecognized sector record type %d\\n\", sectRecordType);\r\n                    return (SCPE_OPENERR);\r\n                    break;\r\n            }\r\n            sim_debug(myDisk->debugmask, myDisk->device, \"\\n\");\r\n        }\r\n\r\n        myDisk->ntracks++;\r\n\r\n    } while (!feof(myDisk->file));\r\n\r\n    sim_debug(myDisk->debugmask, myDisk->device, \"Processed %d sectors\\n\", TotalSectorCount);\r\n\r\n    for(i=0;i<myDisk->ntracks;i++) {\r\n        uint8 j;\r\n        sim_debug(myDisk->verbosedebugmask, myDisk->device, \"Track %3d: \", i);\r\n        for(j=0;j<myDisk->track[i >> 1][i & 1].nsects;j++) {\r\n            sim_debug(myDisk->verbosedebugmask, myDisk->device, \"0x%05x \", myDisk->track[i >> 1][i & 1].sectorOffsetMap[j]);\r\n        }\r\n        sim_debug(myDisk->verbosedebugmask, myDisk->device, \"\\n\");\r\n    }\r\n    if(myDisk->flags & FD_FLAG_WRITELOCK) {\r\n        sim_printf(\"Disk write-protected because the image contains compressed sectors. Use IMDU to uncompress.\\n\");\r\n    }\r\n\r\n    return SCPE_OK;\r\n}\r\n\r\n/*\r\n * This function closes the IMD image.  After closing, the sector read/write operations are not\r\n * possible.\r\n *\r\n * The IMD file is not actually closed, we leave that to SIMH.\r\n */\r\nt_stat diskClose(DISK_INFO **myDisk)\r\n{\r\n    if(*myDisk == NULL)\r\n        return SCPE_OPENERR;\r\n    free(*myDisk);\r\n    *myDisk = NULL;\r\n    return SCPE_OK;\r\n}\r\n\r\n#define MAX_COMMENT_LEN 256\r\n\r\n/*\r\n * Create an ImageDisk (IMD) file.  This function just creates the comment header, and allows\r\n * the user to enter a comment.  After the IMD is created, it must be formatted with a format\r\n * program on the simulated operating system, ie CP/M, CDOS, 86-DOS.\r\n *\r\n * If the IMD file already exists, the user will be given the option of overwriting it.\r\n */\r\nt_stat diskCreate(FILE *fileref, const char *ctlr_comment)\r\n{\r\n    DISK_INFO *myDisk = NULL;\r\n    char *comment;\r\n    char *curptr;\r\n    char *result;\r\n    uint8 answer;\r\n    int32 len, remaining;\r\n\r\n    if(fileref == NULL) {\r\n        return (SCPE_OPENERR);\r\n    }\r\n\r\n    if(sim_fsize(fileref) != 0) {\r\n        sim_printf(\"SIM_IMD: Disk image already has data, do you want to overwrite it? \");\r\n        answer = (uint8)getchar();\r\n\r\n        if((answer != 'y') && (answer != 'Y')) {\r\n            return (SCPE_OPENERR);\r\n        }\r\n    }\r\n\r\n    if((curptr = comment = (char *)calloc(1, MAX_COMMENT_LEN)) == 0) {\r\n        sim_printf(\"Memory allocation failure.\\n\");\r\n        return (SCPE_MEM);\r\n    }\r\n\r\n    sim_printf(\"SIM_IMD: Enter a comment for this disk.\\n\"\r\n               \"SIM_IMD: Terminate with a '.' on an otherwise blank line.\\n\");\r\n    remaining = MAX_COMMENT_LEN;\r\n    do {\r\n        sim_printf(\"IMD> \");\r\n        result = fgets(curptr, remaining - 3, stdin);\r\n        if ((result == NULL) || (strcmp(curptr, \".\\n\") == 0)) {\r\n            remaining = 0;\r\n        } else {\r\n            len = strlen(curptr) - 1;\r\n            if (curptr[len] != '\\n')\r\n                len++;\r\n            remaining -= len;\r\n            curptr += len;\r\n            *curptr++ = 0x0d;\r\n            *curptr++ = 0x0a;\r\n        }\r\n    } while (remaining > 4);\r\n    *curptr = 0x00;\r\n\r\n    /* rewind to the beginning of the file. */\r\n    rewind(fileref);\r\n\r\n    /* Erase the contents of the IMD file in case we are overwriting an existing image. */\r\n    if (sim_set_fsize(fileref, 0) == -1) {\r\n        free(comment);\r\n        sim_printf(\"SIM_IMD: Error overwriting disk image.\\n\");\r\n        return(SCPE_OPENERR);\r\n    }\r\n\r\n    fprintf(fileref, \"IMD SIMH %s %s\\n\", __DATE__, __TIME__);\r\n    fputs(comment, fileref);\r\n    free(comment);\r\n    fprintf(fileref, \"\\n\\n$Id: sim_imd.c 1999 2008-07-22 04:25:28Z hharte $\\n\");\r\n    fprintf(fileref, \"%s\\n\", ctlr_comment);\r\n    fputc(0x1A, fileref); /* EOF marker for IMD comment. */\r\n    fflush(fileref);\r\n\r\n    if((myDisk = diskOpen(fileref, 0)) == NULL) {\r\n        sim_printf(\"SIM_IMD: Error opening disk for format.\\n\");\r\n        return(SCPE_OPENERR);\r\n    }\r\n\r\n    if(diskFormat(myDisk) != SCPE_OK) {\r\n        sim_printf(\"SIM_IMD: error formatting disk.\\n\");\r\n    }\r\n\r\n    return diskClose(&myDisk);\r\n}\r\n\r\n\r\nstatic t_stat diskFormat(DISK_INFO *myDisk)\r\n{\r\n    uint8 i;\r\n    uint8 sector_map[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26};\r\n    uint32 flags;\r\n\r\n    sim_printf(\"SIM_IMD: Formatting disk in IBM 3740 SS/SD Format.\\n\");\r\n\r\n    for(i=0;i<77;i++) {\r\n        if((trackWrite(myDisk, i, 0, 26, 128, sector_map, IMD_MODE_500K_FM, 0xE5, &flags)) != 0) {\r\n            sim_printf(\"SIM_IMD: Error formatting track %d\\n\", i);\r\n            return SCPE_IOERR;\r\n        } else {\r\n            putchar('.');\r\n        }\r\n    }\r\n\r\n    sim_printf(\"\\nSIM_IMD: Format Complete.\\n\");\r\n\r\n    return SCPE_OK;\r\n}\r\n\r\nuint32 imdGetSides(DISK_INFO *myDisk)\r\n{\r\n    if(myDisk != NULL) {\r\n        return(myDisk->nsides);\r\n    }\r\n\r\n    return (0);\r\n}\r\n\r\nuint32 imdIsWriteLocked(DISK_INFO *myDisk)\r\n{\r\n    if(myDisk != NULL) {\r\n        return((myDisk->flags & FD_FLAG_WRITELOCK) ? 1 : 0);\r\n    }\r\n\r\n    return (0);\r\n}\r\n\r\n/* Check that the given track/sector exists on the disk */\r\nt_stat sectSeek(DISK_INFO *myDisk,\r\n             uint32 Cyl,\r\n             uint32 Head)\r\n{\r\n    if(Cyl >= myDisk->ntracks) {\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(Head >= myDisk->nsides) {\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(myDisk->track[Cyl][Head].nsects == 0) {\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"%s: invalid track/head\\n\", __FUNCTION__);\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    return(SCPE_OK);\r\n}\r\n\r\n/* Read a sector from an IMD image. */\r\nt_stat sectRead(DISK_INFO *myDisk,\r\n             uint32 Cyl,\r\n             uint32 Head,\r\n             uint32 Sector,\r\n             uint8 *buf,\r\n             uint32 buflen,\r\n             uint32 *flags,\r\n             uint32 *readlen)\r\n{\r\n    uint32 sectorFileOffset;\r\n    uint8 sectRecordType;\r\n    uint8 start_sect;\r\n    *readlen = 0;\r\n    *flags = 0;\r\n\r\n    /* Check parameters */\r\n    if(myDisk == NULL) {\r\n        *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(sectSeek(myDisk, Cyl, Head) != SCPE_OK) {\r\n        *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(Sector > myDisk->track[Cyl][Head].nsects) {\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"%s: invalid sector\\n\", __FUNCTION__);\r\n        *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(buflen < myDisk->track[Cyl][Head].sectsize) {\r\n        sim_printf(\"%s: Reading C:%d/H:%d/S:%d, len=%d: user buffer too short, need %d\\n\", __FUNCTION__, Cyl, Head, Sector, buflen, myDisk->track[Cyl][Head].sectsize);\r\n        *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    start_sect = myDisk->track[Cyl][Head].start_sector;\r\n\r\n    sectorFileOffset = myDisk->track[Cyl][Head].sectorOffsetMap[Sector-start_sect];\r\n\r\n    sim_debug(myDisk->debugmask, myDisk->device, \"Reading C:%d/H:%d/S:%d, len=%d, offset=0x%08x\\n\", Cyl, Head, Sector, buflen, sectorFileOffset);\r\n\r\n    (void)sim_fseek(myDisk->file, sectorFileOffset-1, SEEK_SET);\r\n\r\n    sectRecordType = (uint8)fgetc(myDisk->file);\r\n    switch(sectRecordType) {\r\n        case SECT_RECORD_UNAVAILABLE:   /* Data could not be read from the original media */\r\n            *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n            break;\r\n        case SECT_RECORD_NORM_ERR:      /* Normal Data with read error */\r\n        case SECT_RECORD_NORM_DAM_ERR:  /* Normal Data with deleted address mark with read error */\r\n            *flags |= IMD_DISK_IO_ERROR_CRC;\r\n            /* fall through */\r\n        case SECT_RECORD_NORM:          /* Normal Data */\r\n        case SECT_RECORD_NORM_DAM:      /* Normal Data with deleted address mark */\r\n\r\n/*          sim_debug(myDisk->debugmask, myDisk->device, \"Uncompressed Data\\n\"); */\r\n            if (sim_fread(buf, 1, myDisk->track[Cyl][Head].sectsize, myDisk->file) != myDisk->track[Cyl][Head].sectsize) {\r\n                sim_printf(\"SIM_IMD[%s]: sim_fread error for SECT_RECORD_NORM_DAM.\\n\", __FUNCTION__);\r\n            }\r\n            *readlen = myDisk->track[Cyl][Head].sectsize;\r\n            break;\r\n        case SECT_RECORD_NORM_COMP_ERR: /* Compressed Normal Data */\r\n        case SECT_RECORD_NORM_DAM_COMP_ERR: /* Compressed Normal Data with deleted address mark */\r\n            *flags |= IMD_DISK_IO_ERROR_CRC;\r\n            /* fall through */\r\n        case SECT_RECORD_NORM_COMP:     /* Compressed Normal Data */\r\n        case SECT_RECORD_NORM_DAM_COMP: /* Compressed Normal Data with deleted address mark */\r\n/*          sim_debug(myDisk->debugmask, myDisk->device, \"Compressed Data\\n\"); */\r\n            memset(buf, fgetc(myDisk->file), myDisk->track[Cyl][Head].sectsize);\r\n            *readlen = myDisk->track[Cyl][Head].sectsize;\r\n            *flags |= IMD_DISK_IO_COMPRESSED;\r\n            break;\r\n        default:\r\n            sim_printf(\"ERROR: unrecognized sector record type %d\\n\", sectRecordType);\r\n            break;\r\n    }\r\n\r\n    /* Set flags for deleted address mark. */\r\n    switch(sectRecordType) {\r\n        case SECT_RECORD_NORM_DAM:      /* Normal Data with deleted address mark */\r\n        case SECT_RECORD_NORM_DAM_ERR:  /* Normal Data with deleted address mark with read error */\r\n        case SECT_RECORD_NORM_DAM_COMP: /* Compressed Normal Data with deleted address mark */\r\n        case SECT_RECORD_NORM_DAM_COMP_ERR: /* Compressed Normal Data with deleted address mark */\r\n            *flags |= IMD_DISK_IO_DELETED_ADDR_MARK;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    return(SCPE_OK);\r\n}\r\n\r\n/* Write a sector to an IMD image. */\r\nt_stat sectWrite(DISK_INFO *myDisk,\r\n              uint32 Cyl,\r\n              uint32 Head,\r\n              uint32 Sector,\r\n              uint8 *buf,\r\n              uint32 buflen,\r\n              uint32 *flags,\r\n              uint32 *writelen)\r\n{\r\n    uint32 sectorFileOffset;\r\n    uint8 sectRecordType;\r\n    uint8 start_sect;\r\n    *writelen = 0;\r\n\r\n    sim_debug(myDisk->debugmask, myDisk->device, \"Writing C:%d/H:%d/S:%d, len=%d\\n\", Cyl, Head, Sector, buflen);\r\n\r\n    /* Check parameters */\r\n    if(myDisk == NULL) {\r\n        *flags = IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(sectSeek(myDisk, Cyl, Head) != 0) {\r\n        *flags = IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(Sector > myDisk->track[Cyl][Head].nsects) {\r\n        sim_debug(myDisk->debugmask, myDisk->device, \"%s: invalid sector\\n\", __FUNCTION__);\r\n        *flags = IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(myDisk->flags & FD_FLAG_WRITELOCK) {\r\n        sim_printf(\"Disk write-protected because the image contains compressed sectors. Use IMDU to uncompress.\\n\");\r\n        *flags = IMD_DISK_IO_ERROR_WPROT;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(buflen < myDisk->track[Cyl][Head].sectsize) {\r\n        sim_printf(\"%s: user buffer too short [buflen %i < sectsize %i]\\n\",\r\n                   __FUNCTION__, buflen, myDisk->track[Cyl][Head].sectsize);\r\n        *flags = IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    start_sect = myDisk->track[Cyl][Head].start_sector;\r\n\r\n    sectorFileOffset = myDisk->track[Cyl][Head].sectorOffsetMap[Sector-start_sect];\r\n\r\n    (void)sim_fseek(myDisk->file, sectorFileOffset-1, SEEK_SET);\r\n\r\n    if (*flags & IMD_DISK_IO_ERROR_GENERAL) {\r\n        sectRecordType = SECT_RECORD_UNAVAILABLE;\r\n    } else if (*flags & IMD_DISK_IO_ERROR_CRC) {\r\n        if (*flags & IMD_DISK_IO_DELETED_ADDR_MARK)\r\n            sectRecordType = SECT_RECORD_NORM_DAM_ERR;\r\n        else\r\n            sectRecordType = SECT_RECORD_NORM_ERR;\r\n    } else {\r\n        if (*flags & IMD_DISK_IO_DELETED_ADDR_MARK)\r\n            sectRecordType = SECT_RECORD_NORM_DAM;\r\n        else\r\n        sectRecordType = SECT_RECORD_NORM;\r\n    }\r\n\r\n    fputc(sectRecordType, myDisk->file);\r\n    sim_fwrite(buf, 1, myDisk->track[Cyl][Head].sectsize, myDisk->file);\r\n    *writelen = myDisk->track[Cyl][Head].sectsize;\r\n\r\n    return(SCPE_OK);\r\n}\r\n\r\n/* Format an entire track.  The new track to be formatted must be after any existing tracks on\r\n * the disk.\r\n *\r\n * This routine should be enhanced to re-format an existing track to the same format (this\r\n * does not involve changing the disk image size.)\r\n *\r\n * Any existing data on the disk image will be destroyed when Track 0, Head 0 is formatted.\r\n * At that time, the IMD file is truncated.  So for the trackWrite to be used to successfully\r\n * format a disk image, then format program must format tracks starting with Cyl 0, Head 0,\r\n * and proceed sequentially through all tracks/heads on the disk.\r\n *\r\n * Format programs that are known to work include:\r\n * Cromemco CDOS \"INIT.COM\"\r\n * ADC Super-Six (CP/M-80) \"FMT8.COM\"\r\n * 86-DOS \"INIT.COM\"\r\n * MS-DOS 1.25 \"FORMAT.COM\" - SSSD 8\"\r\n * MS-DOS 1.25 \"FORMAT.COM /D\" - DSDD 8\"\r\n * OASIS-80 v5.6 \"INITDISK A (FORMAT,SECTOR 13)\" - SSSD 8\"\r\n * OASIS-80 v5.6 \"INITDISK A (FORMAT)\" - SSDD 8\"\r\n * OASIS-80 v5.6 \"INITDISK A (FORMAT,HEAD 2)\" - DSDD 8\"\r\n */\r\nt_stat trackWrite(DISK_INFO *myDisk,\r\n               uint32 Cyl,\r\n               uint32 Head,\r\n               uint32 numSectors,\r\n               uint32 sectorLen,\r\n               uint8 *sectorMap,\r\n               uint8 mode,\r\n               uint8 fillbyte,\r\n               uint32 *flags)\r\n{\r\n    FILE *fileref;\r\n    IMD_HEADER track_header = { 0 };\r\n    uint8 *sectorData;\r\n    t_addr comment;\r\n    unsigned long i;\r\n    unsigned long dataLen;\r\n    uint8 sectsize = 0;\r\n\r\n    *flags = 0;\r\n\r\n    /* Check parameters */\r\n    if(myDisk == NULL) {\r\n        *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    if(myDisk->flags & FD_FLAG_WRITELOCK) {\r\n        sim_printf(\"Disk write-protected, cannot format tracks.\\n\");\r\n        *flags |= IMD_DISK_IO_ERROR_WPROT;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    fileref = myDisk->file;\r\n\r\n    sim_debug(myDisk->debugmask, myDisk->device, \"Formatting C:%d/H:%d/N:%d, len=%d, Fill=0x%02x\\n\", Cyl, Head, numSectors, sectorLen, fillbyte);\r\n\r\n    /* Truncate the IMD file when formatting Cyl 0, Head 0 */\r\n    if((Cyl == 0) && (Head == 0))\r\n    {\r\n        /* Skip over IMD comment field. */\r\n        commentParse(myDisk, NULL, 0);\r\n\r\n        /* Truncate the IMD file after the comment field. */\r\n        if (((comment = (t_addr)ftell (fileref)) == (t_addr)-1) ||\r\n            (sim_set_fsize(fileref, comment) == -1)) {\r\n            sim_printf(\"Disk truncation failed.\\n\");\r\n            *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n            return(SCPE_IOERR);\r\n        }\r\n        /* Flush and re-parse the IMD file. */\r\n        fflush(fileref);\r\n        diskParse(myDisk, 0);\r\n    }\r\n\r\n    /* Check to make sure the Cyl / Head is not already formatted. */\r\n    if(sectSeek(myDisk, Cyl, Head) == 0) {\r\n        sim_printf(\"SIM_IMD: ERROR: Not Formatting C:%d/H:%d, track already exists.\\n\", Cyl, Head);\r\n        *flags |= IMD_DISK_IO_ERROR_GENERAL;\r\n        return(SCPE_IOERR);\r\n    }\r\n\r\n    track_header.mode = mode;\r\n    track_header.cyl = Cyl;\r\n    track_header.head = Head;\r\n    track_header.nsects = numSectors;\r\n\r\n    for (i = (sectorLen >> 8); i; i >>= 1) {\r\n        sectsize++;\r\n    }\r\n\r\n    if (sectsize > IMD_MAX_SECTSIZE) {\r\n        sim_printf(\"SIM_IMD: ERROR: Invalid sectsize %d\\n\", sectsize);\r\n        return(SCPE_IERR);\r\n    }\r\n    track_header.sectsize = sectsize;\r\n\r\n    /* Forward to end of the file, write track header and sector map. */\r\n    (void)sim_fseek(myDisk->file, 0, SEEK_END);\r\n    sim_fwrite(&track_header, 1, sizeof(IMD_HEADER), fileref);\r\n    sim_fwrite(sectorMap, 1, numSectors, fileref);\r\n\r\n    /* Compute data length, and fill a sector buffer with the\r\n     * sector record type as the first byte, and fill the sector\r\n     * data with the fillbyte.\r\n     */\r\n    dataLen = sectorLen + 1;\r\n    sectorData = (uint8 *)malloc(dataLen);\r\n\r\n    if (sectorData == NULL) {\r\n        sim_printf(\"%s: %s(): memory allocation failure.\\n\", __FILE__, __FUNCTION__);\r\n        return SCPE_MEM;\r\n    }\r\n\r\n    memset(sectorData, fillbyte, dataLen);\r\n    sectorData[0] = SECT_RECORD_NORM;\r\n\r\n    /* For each sector on the track, write the record type and sector data. */\r\n    for(i=0;i<numSectors;i++) {\r\n        sim_fwrite(sectorData, 1, dataLen, fileref);\r\n    }\r\n\r\n    /* Flush the file, and free the sector buffer. */\r\n    fflush(fileref);\r\n    free(sectorData);\r\n\r\n    /* Now that the disk track/sector layout has been modified, re-parse the disk image. */\r\n    diskParse(myDisk, 0);\r\n\r\n    return(SCPE_OK);\r\n}\r\n\r\n/* Utility function to set the image type for a unit to the correct value.\r\n * Prints an error message in case a CPT image is presented and returns\r\n * SCPE_OPENERR in this case. Otherwise the return value is SCPE_OK\r\n */\r\nt_stat assignDiskType(UNIT *uptr) {\r\n    t_stat result = SCPE_OK;\r\n    char header[4];\r\n    t_offset pos = sim_ftell(uptr->fileref);\r\n\r\n    rewind(uptr->fileref);\r\n    if (fgets(header, 4, uptr->fileref) == NULL)\r\n        uptr->u3 = IMAGE_TYPE_DSK;\r\n    else if (strncmp(header, \"IMD\", 3) == 0)\r\n        uptr->u3 = IMAGE_TYPE_IMD;\r\n    else if(strncmp(header, \"CPT\", 3) == 0) {\r\n        sim_printf(\"CPT images not yet supported.\\n\");\r\n        uptr->u3 = IMAGE_TYPE_CPT;\r\n        result = SCPE_OPENERR;\r\n    }\r\n    else\r\n        uptr->u3 = IMAGE_TYPE_DSK;\r\n    (void)sim_fseeko(uptr->fileref, pos, SEEK_SET);\r\n    return result;\r\n}\r\n"
        },
        {
          "name": "sim_imd.h",
          "type": "blob",
          "size": 6.39453125,
          "content": "/*************************************************************************\r\n *                                                                       *\r\n * Copyright (c) 2007-2022 Howard M. Harte.                              *\r\n * https://github.com/hharte                                             *\r\n *                                                                       *\r\n * Permission is hereby granted, free of charge, to any person obtaining *\r\n * a copy of this software and associated documentation files (the       *\r\n * \"Software\"), to deal in the Software without restriction, including   *\r\n * without limitation the rights to use, copy, modify, merge, publish,   *\r\n * distribute, sublicense, and/or sell copies of the Software, and to    *\r\n * permit persons to whom the Software is furnished to do so, subject to *\r\n * the following conditions:                                             *\r\n *                                                                       *\r\n * The above copyright notice and this permission notice shall be        *\r\n * included in all copies or substantial portions of the Software.       *\r\n *                                                                       *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,       *\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    *\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-            *\r\n * INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE   *\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN       *\r\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN     *\r\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE      *\r\n * SOFTWARE.                                                             *\r\n *                                                                       *\r\n * Except as contained in this notice, the names of The Authors shall    *\r\n * not be used in advertising or otherwise to promote the sale, use or   *\r\n * other dealings in this Software without prior written authorization   *\r\n * from the Authors.                                                     *\r\n *                                                                       *\r\n * Module Description:                                                   *\r\n *     ImageDisk Disk Image File access module for SIMH, definitions.    *\r\n *     See: http://dunfield.classiccmp.org/img/index.htm                 *\r\n *     for details on the ImageDisk format and other utilities.          *\r\n *                                                                       *\r\n *************************************************************************/\r\n\r\n#ifndef SIM_IMD_H_\r\n#define SIM_IMD_H_     0\r\n\r\n#include \"sim_defs.h\"\r\n\r\ntypedef struct {\r\n    uint8 mode;\r\n    uint8 cyl;\r\n    uint8 head;\r\n    uint8 nsects;\r\n    uint8 sectsize;\r\n} IMD_HEADER;\r\n\r\n\r\n#define IMD_FLAG_SECT_HEAD_MAP  (1 << 6)\r\n#define IMD_FLAG_SECT_CYL_MAP   (1 << 7)\r\n\r\n#define SECT_RECORD_UNAVAILABLE         0   /* Data could not be read from the original media */\r\n#define SECT_RECORD_NORM                1   /* Normal Data */\r\n#define SECT_RECORD_NORM_COMP           2   /* Compressed Normal Data */\r\n#define SECT_RECORD_NORM_DAM            3   /* Normal Data with deleted address mark */\r\n#define SECT_RECORD_NORM_DAM_COMP       4   /* Compressed Normal Data with deleted address mark */\r\n#define SECT_RECORD_NORM_ERR            5   /* Normal Data */\r\n#define SECT_RECORD_NORM_COMP_ERR       6   /* Compressed Normal Data */\r\n#define SECT_RECORD_NORM_DAM_ERR        7   /* Normal Data with deleted address mark */\r\n#define SECT_RECORD_NORM_DAM_COMP_ERR   8   /* Compressed Normal Data with deleted address mark */\r\n\r\n#define MAX_CYL     80\r\n#define MAX_HEAD    2\r\n#define MAX_SPT     26\r\n\r\n#define FD_FLAG_WRITELOCK   1\r\n\r\n#define IMD_DISK_IO_ERROR_GENERAL       (1 << 0)    /* General data error. */\r\n#define IMD_DISK_IO_ERROR_CRC           (1 << 1)    /* Data read/written, but got a CRC error. */\r\n#define IMD_DISK_IO_DELETED_ADDR_MARK   (1 << 2)    /* Sector had a deleted address mark */\r\n#define IMD_DISK_IO_COMPRESSED          (1 << 3)    /* Sector is compressed in the IMD file (Read Only) */\r\n#define IMD_DISK_IO_ERROR_WPROT         (1 << 4)    /* Disk is write protected */\r\n\r\n#define IMD_MODE_500K_FM        0\r\n#define IMD_MODE_300K_FM        1\r\n#define IMD_MODE_250K_FM        2\r\n#define IMD_MODE_500K_MFM       3\r\n#define IMD_MODE_300K_MFM       4\r\n#define IMD_MODE_250K_MFM       5\r\n\r\n#define IMD_MAX_SECTSIZE        6\r\n\r\n#define IMD_MODE_FM(x)      (x <= IMD_MODE_250K_FM)\r\n#define IMD_MODE_MFM(x)     (x >= IMD_MODE_500K_MFM)\r\n\r\n#define IMAGE_TYPE_DSK          1               /* Flat binary \"DSK\" image file.            */\r\n#define IMAGE_TYPE_IMD          2               /* ImageDisk \"IMD\" image file.              */\r\n#define IMAGE_TYPE_CPT          3               /* CP/M Transfer \"CPT\" image file.          */\r\n\r\ntypedef struct {\r\n    uint8 mode;\r\n    uint8 nsects;\r\n    uint32 sectsize;\r\n    uint32 sectorOffsetMap[MAX_SPT];\r\n    uint8 start_sector;\r\n    uint8 logicalHead[MAX_SPT];\r\n    uint8 logicalCyl[MAX_SPT];\r\n} TRACK_INFO;\r\n\r\ntypedef struct {\r\n    FILE *file;\r\n    uint32 ntracks;\r\n    uint8 nsides;\r\n    uint8 flags;\r\n    DEVICE *device;\r\n    uint32 debugmask;\r\n    uint32 verbosedebugmask;\r\n    TRACK_INFO track[MAX_CYL][MAX_HEAD];\r\n} DISK_INFO;\r\n\r\nextern DISK_INFO *diskOpen(FILE *fileref, uint32 isVerbose);\r\nextern DISK_INFO *diskOpenEx(FILE *fileref, uint32 isVerbose, DEVICE *device, uint32 debugmask, uint32 verbosedebugmask);\r\nextern t_stat diskClose(DISK_INFO **myDisk);\r\nextern t_stat diskCreate(FILE *fileref, const char *ctlr_comment);\r\nextern uint32 imdGetSides(DISK_INFO *myDisk);\r\nextern uint32 imdIsWriteLocked(DISK_INFO *myDisk);\r\n\r\nextern t_stat sectSeek(DISK_INFO *myDisk, uint32 Cyl, uint32 Head);\r\nextern t_stat sectRead(DISK_INFO *myDisk, uint32 Cyl, uint32 Head, uint32 Sector, uint8 *buf, uint32 buflen, uint32 *flags, uint32 *readlen);\r\nextern t_stat sectWrite(DISK_INFO *myDisk, uint32 Cyl, uint32 Head, uint32 Sector, uint8 *buf, uint32 buflen, uint32 *flags, uint32 *writelen);\r\nextern t_stat trackWrite(DISK_INFO *myDisk,\r\n               uint32 Cyl,\r\n               uint32 Head,\r\n               uint32 numSectors,\r\n               uint32 sectorLen,\r\n               uint8 *sectorMap,\r\n               uint8 mode,\r\n               uint8 fillbyte,\r\n               uint32 *flags);\r\nextern t_stat assignDiskType(UNIT *uptr);\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_rev.h",
          "type": "blob",
          "size": 124.666015625,
          "content": "/* sim_rev.h: simulator revisions and current rev level\r\n\r\n   Copyright (c) 1993-2012, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n*/\r\n\r\n#ifndef SIM_REV_H_\r\n#define SIM_REV_H_     0\r\n\r\n#ifndef SIM_MAJOR\r\n#define SIM_MAJOR       4\r\n#endif\r\n#ifndef SIM_MINOR\r\n#define SIM_MINOR       0\r\n#endif\r\n#ifndef SIM_PATCH\r\n#define SIM_PATCH       0\r\n#endif\r\n#ifndef SIM_DELTA\r\n#define SIM_DELTA       0\r\n#endif\r\n\r\n#ifndef SIM_VERSION_MODE\r\n#define SIM_VERSION_MODE \"Current\"\r\n#endif\r\n\r\n#if defined(SIM_NEED_GIT_COMMIT_ID)\r\n#include \".git-commit-id.h\"\r\n#endif\r\n\r\n/*\r\n  Simh's git commit id would be undefined when working with an\r\n  extracted archive (zip file or tar ball).  To address this\r\n  problem and record the commit id that the archive was created\r\n  from, the archive creation process populates the below\r\n  information as a consequence of the \"sim_rev.h export-subst\"\r\n  line in the .gitattributes file.\r\n */\r\n#define SIM_ARCHIVE_GIT_COMMIT_ID $Format:%H$\r\n#define SIM_ARCHIVE_GIT_COMMIT_TIME $Format:%aI$\r\n\r\n/*\r\n  The comment section below reflects the manual editing process which was in place\r\n  prior to the use of the git source control system on at https://github.com/simh/simh\r\n\r\n  Details about all future fixes will be visible in the source control system's\r\n  history.\r\n\r\n*/\r\n\r\n/*\r\n   V3.9 revision history\r\n\r\npatch   date            module(s) and fix(es)\r\n\r\n  0     01-May-2012     scp.c:\r\n                        - added *nix READLINE support (Mark Pizzolato)\r\n                        - fixed handling of DO with no arguments (Dave Bryan)\r\n                        - fixed \"SHOW DEVICE\" with only one enabled unit (Dave Bryan)\r\n                        - clarified some help messages (Mark Pizzolato)\r\n                        - added \"SHOW SHOW\" and \"SHOW <dev> SHOW\" commands (Mark Pizzolato)\r\n                        - fixed bug in deposit stride for numeric input (John Dundas)\r\n\r\n                        sim_console.c\r\n                        - added support for BREAK key on Windows (Mark Pizzolato)\r\n\r\n                        sim_ether.c\r\n                        - major revision (Dave Hittner and Mark Pizzolato)\r\n                        - fixed array overrun which caused SEGFAULT on hosts with many\r\n                          devices which libpcap can access.\r\n                        - fixed duplicate MAC address detection to work reliably on switch\r\n                          connected LANs\r\n\r\n                        sim_tmxr.c:\r\n                        - made telnet option negotiation more reliable, VAX simulator now\r\n                          works with PuTTY as console (Mark Pizzolato)\r\n\r\n                        h316_cpu.c:\r\n                        - fixed bugs in MPY, DIV introduced in 3.8-1 (from Theo Engel)\r\n                        - fixed bugs in double precision, normalization, SC (from Adrian Wise)\r\n                        - fixed XR behavior (from Adrian Wise)\r\n\r\n                        hp2100 all peripherals (Dave Bryan):\r\n                        - Changed I/O signal handlers for newly revised signal model\r\n                        - Deprecated DEVNO modifier in favor of SC\r\n\r\n                        hp2100_cpu.c (Dave Bryan):\r\n                        - Minor speedup in \"is_mapped\"\r\n                        - Added casts to cpu_mod, dmasio, dmapio, cpu_reset, dma_reset\r\n                        - Fixed I/O return status bug for DMA cycles\r\n                        - Failed I/O cycles now stop on failing instruction\r\n                        - Revised DMA for new multi-card paradigm\r\n                        - Consolidated DMA reset routines\r\n                        - DMA channels renamed from 0,1 to 1,2 to match documentation\r\n                        - Changed I/O instructions, handlers, and DMA for revised signal model\r\n                        - Changed I/O dispatch table to use DIB pointers\r\n                        - Removed DMA latency counter\r\n                        - Fixed DMA requests to enable stealing every cycle\r\n                        - Fixed DMA priority for channel 1 over channel 2\r\n                        - Corrected comments for \"cpu_set_idle\"\r\n\r\n                        hp2100_cpu.h:\r\n                        - Changed declarations for VMS compiler\r\n\r\n                        hp2100_cpu0.c (Dave Bryan):\r\n                        - Removed DS note regarding PIF card (is now implemented)\r\n\r\n                        hp2100_cpu4.c (Dave Bryan):\r\n                        - Added OPSIZE casts to fp_accum calls in .FPWR/.TPWR\r\n\r\n                        hp2100_cpu5.c (Dave Bryan):\r\n                        - Added sign extension for dim count in \"cpu_ema_resolve\"\r\n                        - Eliminated unused variable in \"cpu_ema_vset\"\r\n\r\n                        hp2100_cpu6.c (Dave Bryan):\r\n                        - DMA channels renamed from 0,1 to 1,2 to match documentation\r\n\r\n                        hp2100_cpu7.c (Dave Bryan):\r\n                        - Corrected \"opsize\" parameter type in vis_abs\r\n\r\n                        hp2100_defs.h (Dave Bryan):\r\n                        - Added hp_setsc, hp_showsc functions to support SC modifier\r\n                        - DMA channels renamed from 0,1 to 1,2 to match documentation\r\n                        - Revised I/O signal enum values for concurrent signals\r\n                        - Revised I/O macros for new signal handling\r\n                        - Added DA and DC device select code assignments\r\n\r\n                        hp2100_di.c, hp2100_di.h (Dave Bryan):\r\n                        - Implemented 12821A HP-IB Disc Interface\r\n\r\n                        hp2100_di_da.c (Dave Bryan):\r\n                        - Implemented 7906H/20H/25H ICD disc drives\r\n\r\n                        hp2100_dp.c (Dave Bryan):\r\n                        - Added CNTLR_TYPE cast to dp_settype\r\n\r\n                        hp2100_ds.c (Dave Bryan):\r\n                        - Rewritten to use the MAC/ICD disc controller library\r\n                        - ioIOO now notifies controller service of parameter output\r\n                        - Corrected SRQ generation and FIFO under/overrun detection\r\n                        - Corrected Clear command to conform to the hardware\r\n                        - Fixed Request Status to return Unit Unavailable if illegal\r\n                        - Seek and Cold Load Read now Seek Check if seek in progress\r\n                        - Remodeled command wait for seek completion\r\n                        - Corrected status returns for disabled drive, auto-seek\r\n                          beyond drive limits, Request Sector Address and Wakeup\r\n                          with invalid or offline unit\r\n                        - Address verification reenabled if auto-seek during\r\n                          Read Without Verify\r\n\r\n                        hp2100_fp1.c (Dave Bryan):\r\n                        - Added missing precision on constant \"one\" in fp_trun\r\n                        - Completed the comments for divide; no code changes\r\n\r\n                        hp2100_ipl.c (Dave Bryan):\r\n                        - Added CARD_INDEX casts to dib.card_index\r\n                        - A failed STC may now be retried\r\n                        - Consolidated reporting of consecutive CRS signals\r\n                        - Revised for new multi-card paradigm\r\n\r\n                        hp2100_lps.c (Dave Bryan):\r\n                        - Revised detection of CLC at last DMA cycle\r\n                        - Corrected 12566B (DIAG mode) jumper settings\r\n\r\n                        hp2100_ms.c (Dave Bryan):\r\n                        - Added CNTLR_TYPE cast to ms_settype\r\n\r\n                        hp2100_mt.c (Dave Bryan):\r\n                        - Removed redundant MTAB_VUN from \"format\" MTAB entry\r\n                        - Fixed command scanning error in mtcio ioIOO handler\r\n\r\n                        hp2100_stddev.c (Dave Bryan):\r\n                        - Add TBG as a logical name for the CLK device\r\n\r\n                        hp2100_sys.c (Dave Bryan):\r\n                        - Deprecated DEVNO in favor of SC\r\n                        - Added hp_setsc, hp_showsc functions to support SC modifier\r\n                        - Added DA and dummy DC devices\r\n                        - DMA channels renamed from 0,1 to 1,2 to match documentation\r\n                        - Changed DIB access for revised signal model\r\n\r\n                        hp_disclib.c, hp_disclib.h (Dave Bryan)\r\n                        - Created MAC/ICD disc controller library\r\n\r\n                        i1401_cd.c:\r\n                        - fixed read stacker operation in column binary mode\r\n                        - fixed punch stacker operation (Van Snyder)\r\n\r\n                        id_pas.c:\r\n                        - fixed TT_GET_MODE test to use TTUF_MODE_x (Michael Bloom)\r\n                        - revised to use clock coscheduling\r\n\r\n                        id_tt.c, id_ttc.p:\r\n                        - revised to use clock coscheduling\r\n\r\n                        id_uvc.c:\r\n                        - added clock coscheduling routine\r\n\r\n                        1401_cpu.c:\r\n                        - reverted multiple tape indicator implementation\r\n                        - fixed EOT indicator test not to clear indicator (Van Snyder)\r\n                        - fixed divide not to clear word marks in quotient (Van Snyder)\r\n                        - revised divide algorithm (Van Snyder)\r\n\r\n                        i1401_mt.c:\r\n                        - reverted multiple tape indicator implementation\r\n                        - fixed END indicator test not to clear indicator (Van Snyder)\r\n                        - fixed backspace over tapemark not to set EOR (Van Snyder)\r\n                        - added no rewind option (Van Snyder)\r\n\r\n                        i1401_sys.c:\r\n                        - fixed misuse of & instead of && in decode (Peter Schorn)\r\n\r\n                        pdp1_cpu.c:\r\n                        - fixed misuse of & instead of && in Ea_ch (Michael Bloom)\r\n\r\n                        pdp1_stddev.c:\r\n                        - fixed uninitialized variable in tty output service (Michael Bloom)\r\n\r\n                        pdp10_fe.c:\r\n                        - revised to use clock coscheduling\r\n\r\n                        pdp11_defs.h:\r\n                        - fixed priority of PIRQ vs IO; added INT_INTERNALn\r\n\r\n                        pdp11_io.c:\r\n                        - fixed Qbus interrupts to treat all IO devices (except clock) as BR4\r\n                        - fixed order of int_internal (Jordi Guillaumes i Pons)\r\n\r\n                        pdp11_rf.c\r\n                        - fixed bug in updating mem addr extension (Peter Schorn)\r\n\r\n                        pdp11_rk.c:\r\n                        - fixed bug in read header (Walter F Mueller)\r\n\r\n                        pdp11_rl.c:\r\n                        - added debug support\r\n\r\n                        pdp11_rq.c:\r\n                        - added RD32 support\r\n\r\n                        pdp11_tq.c: (Mark Pizzolato)\r\n                        - set UNIT_SXC flag when a tape mark is encountered\r\n                          during forward motion read operations\r\n                        - fixed logic which clears UNIT_SXC to check command modifier\r\n                        - added CMF_WR flag to tq_cmf entry for OP_WTM\r\n                        - made non-immediate rewind positioning operations take 2 seconds\r\n                        - added UNIT_IDLE flag to tq units.\r\n                        - fixed debug output of tape file positions when they are 64b\r\n                        - added more debug output after positioning operations\r\n                        - added textual display of the command being performed\r\n                        - fixed comments about register addresses\r\n\r\n                        pdp11_ts.c:\r\n                        - fixed t_addr printouts for 64b big-endian systems (Mark Pizzolato)\r\n\r\n                        pdp11_tu.c:\r\n                        - fixed t_addr printouts for 64b big-endian systems (Mark Pizzolato)\r\n\r\n                        pdp11_vh.c: (Mark Pizzolato)\r\n                        - fixed SET VH LINES=n to correctly adjust the number\r\n                          of lines available to be 8, 16, 24, or 32.\r\n                        - fixed performance issue avoiding redundant polling\r\n\r\n                        pdp11_xq.c: (Mark Pizzolato)\r\n                        - Fixed missing information from save/restore which\r\n                          caused operations to not complete correctly after\r\n                          a restore until the OS reset the controller.\r\n                        - Added address conflict check during attach.\r\n                        - Fixed loopback processing to correctly handle forward packets.\r\n                        - Fixed interrupt dispatch issue which caused delivered packets\r\n                          (in and out) to sometimes not interrupt the CPU after processing.\r\n                        - Fixed the SCP visible SA registers to always display the\r\n                          ROM mac address, even after it is changed by SET XQ MAC=.\r\n                        - Added changes so that the Console DELQA diagnostic (>>>TEST 82)\r\n                          will succeed.\r\n                        - Added DELQA-T (aka DELQA Plus) device emulation support.\r\n                        - Added dropped frame statistics to record when the receiver discards\r\n                          received packets due to the receiver being disabled, or due to the\r\n                          XQ device's packet receive queue being full.\r\n                        - Fixed bug in receive processing when we're not polling.  This could\r\n                          cause receive processing to never be activated again if we don't\r\n                          read all available packets via eth_read each time we get the\r\n                          opportunity.\r\n                        - Added the ability to Coalesce received packet interrupts.  This\r\n                          is enabled by SET XQ POLL=DELAY=nnn where nnn is a number of\r\n                          microseconds to delay the triggering of an interrupt when a packet\r\n                          is received.\r\n                        - Added SET XQ POLL=DISABLE (aka SET XQ POLL=0) to operate without\r\n                          polling for packet read completion.\r\n                        - Changed the sanity and id timer mechanisms to use a separate timer\r\n                          unit so that transmit and receive activities can be dealt with\r\n                          by the normal xq_svc routine.\r\n                          Dynamically determine the timer polling rate based on the\r\n                          calibrated tmr_poll and clk_tps values of the simulator.\r\n                        - Enabled the SET XQ POLL to be meaningful if the simulator currently\r\n                          doesn't support idling.\r\n                        - Changed xq_debug_setup to use sim_debug instead of printf so that\r\n                          all debug output goes to the same place.\r\n                        - Restored the call to xq_svc after all successful calls to eth_write\r\n                          to allow receive processing to happen before the next event\r\n                          service time.  This must have been inadvertently commented out\r\n                          while other things were being tested.\r\n\r\n                        pdp11_xu.c: (Mark Pizzolato)\r\n                        - Added SHOW XU FILTERS modifier (Dave Hittner)\r\n                        - Corrected SELFTEST command, enabling use by VMS 3.7, VMS 4.7, and Ultrix 1.1 (Dave Hittner)\r\n                        - Added address conflict check during attach.\r\n                        - Added loopback processing support\r\n                        - Fixed the fact that no broadcast packets were received by the DEUNA\r\n                        - Fixed transmitted packets to have the correct source MAC address.\r\n                        - Fixed incorrect address filter setting calling eth_filter().\r\n\r\n                        pdp18b_stddev.c:\r\n                        - added clock coscheduling\r\n                        - revised TTI to use clock coscheduling and to fix perpetual CAF bug\r\n\r\n                        pdp18b_ttx.c:\r\n                        - revised to use clock coscheduling\r\n\r\n                        pdp8_clk.c:\r\n                        - added clock coscheduling\r\n\r\n                        pdp8_fpp.c: (Rick Murphy)\r\n                        - many bug fixes; now functional\r\n\r\n                        pdp8_tt.c:\r\n                        - revised to use clock coscheduling and to fix perpetual CAF bug\r\n\r\n                        pdp8_ttx.c:\r\n                        - revised to use clock coscheduling\r\n\r\n                        pdp8_sys.c:\r\n                        - added link to FPP\r\n\r\n                        pdp8_td.c:\r\n                        - fixed SDLC to clear AC (Dave Gesswein)\r\n\r\n                        sds_mt.c:\r\n                        - fixed bug in scan function decode (Peter Schorn)\r\n\r\n                        vax_cpu.c:\r\n                        - revised idle design (Mark Pizzolato)\r\n                        - fixed bug in SET CPU IDLE\r\n                        - fixed failure to clear PSL<tp> in BPT, XFC\r\n\r\n                        vax_cpu1.c:\r\n                        - revised idle design Mark Pizzolato)\r\n                        - added VEC_QMODE test in interrupt handler\r\n\r\n                        vax_fpa.c:\r\n                        - fixed integer overflow bug in EMODx (Camiel Vanderhoeven)\r\n                        - fixed POLYx normalizing before add mask bug (Camiel Vanderhoeven)\r\n                        - fixed missing arguments in 32b floating add (Mark Pizzolato)\r\n\r\n                        vax_octa.c (Camiel Vanderhoeven)\r\n                        - fixed integer overflow bug in EMODH\r\n                        - fixed POLYH normalizing before add mask bug\r\n\r\n                        vax_stddev.c:\r\n                        - revised to use clock coscheduling\r\n\r\n                        vax_syscm.c:\r\n                        - fixed t_addr printouts for 64b big-endian systems (Mark Pizzolato)\r\n\r\n                        vax_sysdev.c:\r\n                        - added power clear call to boot routine (Mark Pizzolato)\r\n\r\n                        vax780_sbi.c:\r\n                        - added AUTORESTART switch support (Mark Pizzolato)\r\n\r\n                        vax780_stddev.c\r\n                        - added REBOOT support (Mark Pizzolato)\r\n                        - revised to use clock coscheduling\r\n\r\n                        vaxmod_def.h\r\n                        - moved all Qbus devices to BR4; deleted RP definitions\r\n\r\n\r\n   V3.8 revision history\r\n\r\n  1     08-Feb-09       scp.c:\r\n                        - revised RESTORE unit logic for consistency\r\n                        - \"detach_all\" ignores error status returns if shutting down (Dave Bryan)\r\n                        - DO cmd missing params now default to null string (Dave Bryan)\r\n                        - DO cmd sub_args now allows \"\\\\\" to specify literal backslash (Dave Bryan)\r\n                        - decommitted MTAB_VAL\r\n                        - fixed implementation of MTAB_NC\r\n                        - fixed warnings in help printouts\r\n                        - fixed \"SHOW DEVICE\" with only one enabled unit (Dave Bryan)\r\n\r\n                        sim_tape.c:\r\n                        - fixed signed/unsigned warning in sim_tape_set_fmt (Dave Bryan)\r\n\r\n                        sim_tmxr.c, sim_tmxr.h:\r\n                        - added line connection order to tmxr_poll_conn,\r\n                          added tmxr_set_lnorder and tmxr_show_lnorder (Dave Bryan)\r\n                        - print device and line to which connection was made (Dave Bryan)\r\n                        - added three new standardized SHOW routines\r\n\r\n                        all terminal multiplexers:\r\n                        - revised for new common SHOW routines in TMXR library\r\n                        - rewrote set size routines not to use MTAB_VAL\r\n\r\n                        hp2100_cpu.c (Dave Bryan):\r\n                        - VIS and IOP are now mutually exclusive on 1000-F\r\n                        - Removed A/B shadow register variables\r\n                        - Moved hp_setdev, hp_showdev to hp2100_sys.c\r\n                        - Moved non-existent memory checks to WritePW\r\n                        - Fixed mp_dms_jmp to accept lower bound, check write protection\r\n                        - Corrected DMS violation register set conditions\r\n                        - Redefined ABORT to pass address, moved def to hp2100_cpu.h\r\n                        - Combined dms and dms_io routines\r\n                        - JSB to 0/1 with W5 out and fence = 0 erroneously causes MP abort\r\n                        - Unified I/O slot dispatch by adding DIBs for CPU, MP, and DMA\r\n                        - Rewrote device I/O to model backplane signals\r\n                        - EDT no longer passes DMA channel\r\n                        - Added SET CPU IDLE/NOIDLE, idle detection for DOS/RTE\r\n                        - Breakpoints on interrupt trap cells now work\r\n\r\n                        hp2100_cpu0.c (Dave Bryan):\r\n                        - .FLUN and self-tests for VIS and SIGNAL are NOP if not present\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Removed option-present tests (now in UIG dispatchers)\r\n                        - Added \"user microcode\" dispatcher for unclaimed instructions\r\n\r\n                        hp2100_cpu1.c (Dave Bryan):\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Moved option-present tests to UIG dispatchers\r\n                        - Call \"user microcode\" dispatcher for unclaimed UIG instructions\r\n\r\n                        hp2100_cpu2.c (Dave Bryan):\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Removed option-present tests (now in UIG dispatchers)\r\n                        - Updated mp_dms_jmp calling sequence\r\n                        - Fixed DJP, SJP, and UJP jump target validation\r\n                        - RVA/B conditionally updates dms_vr before returning value\r\n\r\n                        hp2100_cpu3.c (Dave Bryan):\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Removed option-present tests (now in UIG dispatchers)\r\n                        - Updated mp_dms_jmp calling sequence\r\n\r\n                        hp2100_cpu4.c, hp2100_cpu7.c (Dave Bryan):\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Removed option-present tests (now in UIG dispatchers)\r\n\r\n                        hp2100_cpu5.c (Dave Bryan):\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Removed option-present tests (now in UIG dispatchers)\r\n                        - Redefined ABORT to pass address, moved def to hp2100_cpu.h\r\n                        - Rewrote device I/O to model backplane signals\r\n\r\n                        hp2100_cpu6.c (Dave Bryan):\r\n                        - Corrected .SIP debug formatting\r\n                        - Moved microcode function prototypes to hp2100_cpu1.h\r\n                        - Removed option-present tests (now in UIG dispatchers)\r\n                        - Rewrote device I/O to model backplane signals\r\n\r\n                        hp2100 all peripherals (Dave Bryan):\r\n                        - Rewrote device I/O to model backplane signals\r\n\r\n                        hp2100_baci.c (Dave Bryan):\r\n                        - Fixed STC,C losing interrupt request on BREAK\r\n                        - Changed Telnet poll to connect immediately after reset or attach\r\n                        - Added REG_FIT to register variables < 32-bit size\r\n                        - Moved fmt_char() function to hp2100_sys.c\r\n\r\n                        hp2100_dp.c, hp2100_dq.c (Dave Bryan):\r\n                        - Added REG_FIT to register variables < 32-bit size\r\n\r\n                        hp2100_dr.c (Dave Bryan):\r\n                        - Revised drc_boot to use ibl_copy\r\n\r\n                        hp2100_fp1.c (Dave Bryan):\r\n                        - Quieted bogus gcc warning in fp_exec\r\n\r\n                        hp2100_ipl.c (Dave Bryan):\r\n                        - Changed socket poll to connect immediately after reset or attach\r\n                        - Revised EDT handler to refine completion delay conditions\r\n                        - Revised ipl_boot to use ibl_copy\r\n\r\n                        hp2100_lpt.c (Dave Bryan):\r\n                        - Changed CTIME register width to match documentation\r\n\r\n                        hp2100_mpx.c (Dave Bryan):\r\n                        - Implemented 12792C eight-channel terminal multiplexer\r\n\r\n                        hp2100_ms.c (Dave Bryan):\r\n                        - Revised to use AR instead of saved_AR in boot\r\n\r\n                        hp2100_mt.c (Dave Bryan):\r\n                        - Fixed missing flag after CLR command\r\n                        - Moved write enable and format commands from MTD to MTC\r\n\r\n                        hp2100_mux.c (Dave Bryan):\r\n                        - SHOW MUX CONN/STAT with SET MUX DIAG is no longer disallowed\r\n                        - Changed Telnet poll to connect immediately after reset or attach\r\n                        - Added LINEORDER support\r\n                        - Added BREAK deferral to allow RTE break-mode to work\r\n\r\n                        hp2100_pif.c (Dave Bryan):\r\n                        - Implemented 12620A/12936A Privileged Interrupt Fences\r\n\r\n                        hp2100_sys.c (Dave Bryan):\r\n                        - Fixed IAK instruction dual-use mnemonic display\r\n                        - Moved hp_setdev, hp_showdev from hp2100_cpu.c\r\n                        - Changed sim_load to use WritePW instead of direct M[] access\r\n                        - Added PIF device\r\n                        - Moved fmt_char() function from hp2100_baci.c\r\n                        - Added MPX device\r\n\r\n                        hp2100_cpu.h (Dave Bryan):\r\n                        - Rearranged declarations with hp2100_cpu.c and hp2100_defs.h\r\n                        - Added mp_control to CPU state externals\r\n\r\n                        hp2100_cpu1.h (Dave Bryan):\r\n                        - Moved microcode function prototypes here\r\n\r\n                        hp2100_defs.h (Dave Bryan):\r\n                        - Added POLL_FIRST to indicate immediate connection attempt\r\n                        - Rearranged declarations with hp2100_cpu.h\r\n                        - Added PIF device\r\n                        - Declared fmt_char() function\r\n                        - Added MPX device\r\n\r\n                        i1401_cpu.c:\r\n                        - fixed bug in ZA and ZS (Bob Abeles)\r\n                        - fixed tape indicator implementation (Bob Abeles)\r\n                        - added missing magtape modifier A (Van Snyder)\r\n\r\n                        i1401_mt.c:\r\n                        - added -n (no rewind) option to BOOT (Van Snyder)\r\n                        - fixed bug to mask input to 6b on read (Bob Abeles)\r\n\r\n                        lgp_stddev.c:\r\n                        - changed encode character from # to !, due to overlap\r\n\r\n                        pdp11_cpu.c:\r\n                        - fixed failure to clear cpu_bme on RESET (Walter Mueller)\r\n\r\n                        pdp11_dz.c:\r\n                        - added MTAB_NC modifier on SET LOG command (Walter Mueller)\r\n\r\n                        pdp11_io.c, vax_io.c, vax780_uba.c:\r\n                        - revised to use PDP-11 I/O library\r\n\r\n                        pdp11_io_lib.c:\r\n                        - created common library for Unibus/Qbus support routines\r\n\r\n                        pdp11_cis.c, vax_cis.c:\r\n                        - fixed bug in ASHP left overflow calc (Word/NibbleLShift)\r\n                        - fixed bug in DIVx (LntDstr calculation)\r\n\r\n                        sds_lp.c:\r\n                        - fixed loss of carriage control position on space op\r\n\r\n                        vax_stddev.c, vax780_stddev.c\r\n                        - modified to resync TODR on any clock reset\r\n\r\n  0     15-Jun-08       scp.c:\r\n                        - fixed bug in local/global register search (Mark Pizzolato)\r\n                        - fixed bug in restore of RO units (Mark Pizzolato)\r\n                        - added SET/SHO/NO BR with default argument (Dave Bryan)\r\n\r\n                        sim_tmxr.c\r\n                        - worked around Telnet negotiation problem with QCTerm (Dave Bryan)\r\n\r\n                        gri_defs.h, gri_cpu.c, gri_sys.c:\r\n                        - added GRI-99 support\r\n\r\n                        hp2100_baci.c (Dave Bryan):\r\n                        - Implemented 12966A Buffered Asynchronous Communications Interface simulator\r\n\r\n                        hp2100_cpu.c (Dave Bryan):\r\n                        - Memory ex/dep and bkpt type default to current map mode\r\n                        - Added SET CPU DEBUG and OS/VMA flags, enabled OS/VMA\r\n                        - Corrected MP W5 (JSB) jumper action, SET/SHOW reversal,\r\n                          mp_mevff clear on interrupt with I/O instruction in trap cell\r\n                        - Removed DBI support from 1000-M (was temporary for RTE-6/VM)\r\n                        - Enabled EMA and VIS, added EMA, VIS, and SIGNAL debug flags\r\n                        - Enabled SIGNAL instructions, SIG debug flag\r\n                        - Fixed single stepping through interrupts\r\n\r\n                        hp2100_cpu0.c (Dave Bryan and Holger Veit):\r\n                        - Removed and implemented \"cpu_rte_vma\" and \"cpu_rte_os\"\r\n                        - Removed and implemented \"cpu_vis\" and \"cpu_signal\"\r\n                        - Removed and implemented \"cpu_rte_ema\"\r\n\r\n                        hp2100_cpu1.c (Dave Bryan):\r\n                        - Added fprint_ops, fprint_regs for debug printouts\r\n                        - Enabled DIAG as NOP on 1000 F-Series\r\n                        - Fixed VIS and SIGNAL to depend on the FPP and HAVE_INT64\r\n\r\n                        hp2100_cpu3.c (Dave Bryan):\r\n                        - Fixed unsigned divide bug in .DDI\r\n                        - Fixed unsigned multiply bug in .DMP\r\n                        - Added implementation of DBI self-test\r\n\r\n                        hp2100_cpu4.c (Dave Bryan):\r\n                        - Fixed B register return bug in /CMRT\r\n\r\n                        hp2100_cpu5.c (Holger Veit):\r\n                        - Implemented RTE-6/VM Virtual Memory Area firmware\r\n                        - Implemented RTE-IV Extended Memory Area firmware\r\n\r\n                        hp2100_cpu6.c (Dave Bryan):\r\n                        - Implemented RTE-6/VM OS accelerator firmware\r\n\r\n                        hp2100_cpu7.c (Holger Veit):\r\n                        - Implemented Vector Instruction Set and SIGNAL/1000 firmware\r\n\r\n                        hp2100_ds.c (Dave Bryan):\r\n                        - Corrected and verified ioCRS action\r\n                        - Corrected DPTR register definition from FLDATA to DRDATA\r\n\r\n                        hp2100_fp.c (Mark Pizzolato)\r\n                        - Corrected fp_unpack mantissa high-word return\r\n\r\n                        hp2100_fp1.c (Dave Bryan):\r\n                        - Reworked \"complement\" to avoid inlining bug in gcc-4.x\r\n                        - Fixed uninitialized return in fp_accum when setting\r\n\r\n                        hp2100_mux.c (Dave Bryan):\r\n                        - Sync mux poll with console poll for idle compatibility\r\n\r\n                        hp2100_stddev.c (Dave Bryan):\r\n                        - Fixed PTR trailing null counter for tape re-read\r\n                        - Added IPTICK register to CLK to display CPU instr/tick\r\n                        - Corrected and verified ioCRS actions\r\n                        - Changed TTY console poll to 10 msec. real time\r\n                        - Synchronized CLK with TTY if set for 10 msec.\r\n                        - Added UNIT_IDLE to TTY and CLK\r\n                        - Removed redundant control char handling definitions\r\n                        - Changed TTY output wait from 100 to 200 for MSU BASIC\r\n\r\n                        hp2100_sys.c (Dave Bryan):\r\n                        - Added BACI device\r\n                        - Added RTE OS/VMA/EMA mnemonics\r\n                        - Changed fprint_sym to handle step with irq pending\r\n\r\n                        hp2100_cpu.h (Dave Bryan):\r\n                        - Added calc_defer() prototype\r\n                        - Added extern sim_deb, cpu_dev, DEB flags for debug printouts\r\n                        - Added extern intaddr, mp_viol, mp_mevff, calc_int, dev_ctl,\r\n                          ReadIO, WriteIO for RTE-6/VM microcode support\r\n\r\n                        hp2100_cpu1.h (Dave Bryan):\r\n                        - Corrected OP_AFF to OP_AAFF for SIGNAL/1000\r\n                        - Removed unused operand patterns\r\n                        - Added fprint_ops, fprint_regs for debug printouts\r\n                        - Revised OP_KKKAKK operand profile to OP_CCCACC for $LOC\r\n\r\n                        hp2100_defs.h (Dave Bryan):\r\n                        - Added BACI device\r\n                        - Added 16/32-bit unsigned-to-signed conversions\r\n                        - Changed TMR_MUX to TMR_POLL for idle support\r\n                        - Added POLLMODE, sync_poll() declaration\r\n                        - Added I_MRG, I_ISZ, I_IOG, I_STF, and I_SFS instruction masks\r\n                        - Added I_MRG_I, I_JSB, I_JSB_I, and I_JMP instruction masks\r\n\r\n                        nova_defs.h (Bruce Ray):\r\n                        - added support for third-party 64KW memory\r\n\r\n                        nova_clk.c (Bruce Ray):\r\n                        - renamed to RTC, to match DG literature\r\n\r\n                        nova_cpu.c (Bruce Ray):\r\n                        - added support for third-party 64KW memory\r\n                        - added Nova 3 \"secret\" instructions\r\n                        - added CPU history support\r\n\r\n                        nova_dkp.c (Bruce Ray):\r\n                        - renamed to DKP, to match DG literature\r\n                        - fixed numerous bugs in both documented and undocumented behavior\r\n                        - changed bootstrap code to DG official sequence\r\n\r\n                        nova_dsk.c (Bruce Ray):\r\n                        - renamed to DSK, to match DG literature\r\n                        - added support for undocumented behavior\r\n                        - changed bootstrap code to DG official sequence\r\n\r\n                        nova_mta.c (Bruce Ray):\r\n                        - renamed to MTA, to match DG literature\r\n                        - changed bootstrap code to DG official sequence\r\n\r\n                        nova_plt.c, nova_pt.c (Bruce Ray):\r\n                        - added 7B/8B support\r\n\r\n                        nova_sys.c (Bruce Ray):\r\n                        - fixed mistaken instruction mnemonics\r\n\r\n                        pdp11_cpu.c, pdp11_io.c, pdp11_rh.c:\r\n                        - fixed DMA memory address limit test (John Dundas)\r\n                        - fixed MMR0 treatment in RESET (Walter Mueller)\r\n\r\n                        pdp11_cpumod.h, pdp11_cpumod.c:\r\n                        - fixed write behavior of 11/70 MBRK, LOSIZE, HISIZE (Walter Mueller)\r\n                        - added support to set default state of KDJ11B,E clock control register\r\n\r\n                        pdp11_dc.c:\r\n                        - added support for DC11\r\n\r\n                        pdp11_defs.h:\r\n                        - added KE, KG, RC, DC support\r\n                        - renamed DL11 devices\r\n\r\n                        pdp11_dl.c:\r\n                        - renamed devices to DLI/DLO, to match DC11\r\n                        - added modem control\r\n\r\n                        pdp11_io.c:\r\n                        - added autoconfigure support for DC11\r\n\r\n                        pdp11_ke.c:\r\n                        - added support for KE11A\r\n\r\n                        pdp11_kg.c (John Dundas):\r\n                        - added support for KG11A\r\n\r\n                        pdp11_rc.c (John Dundas):\r\n                        - added support for RC11\r\n\r\n                        pdp11_sys.c:\r\n                        - modified to allow -A, -B use with 8b devices\r\n                        - added KE, KG, RC, DC support\r\n                        - renamed DL11 devices\r\n\r\n                        vax_cmode.c, vax_io.c, vax780_uba.c:\r\n                        - fixed declarations (Mark Pizzolato)\r\n\r\n\r\n   V3.7 revision history\r\n\r\n  3     02-Sep-07       scp.c:\r\n                        - fixed bug in SET THROTTLE command\r\n\r\n                        pdp10_cpu.c:\r\n                        - fixed non-portable usage in SHOW HISTORY routine\r\n\r\n                        pdp11_ta.c:\r\n                        - forward op at BOT skips initial file gap\r\n\r\n                        pdp8_ct.c:\r\n                        - forward op at BOT skips initial file gap\r\n                        - fixed handling of BEOT\r\n\r\n                        vax_cpu.c:\r\n                        - fixed bug in read access g-format indexed specifiers\r\n\r\n  2     12-Jul-07       sim_ether.c (Dave Hittner):\r\n                        - fixed non-ethernet device removal loop (Naoki Hamada)\r\n                        - added dynamic loading of wpcap.dll;\r\n                        - corrected exceed max index bug in ethX lookup\r\n                        - corrected failure to look up ethernet device names in\r\n                          the registry on Windows XP x64\r\n\r\n                        sim_timer.c:\r\n                        - fixed idle timer event selection algorithm\r\n\r\n                        h316_lp.c:\r\n                        - fixed loss of last print line (Theo Engel)\r\n\r\n                        h316_mt.c:\r\n                        - fixed bug in write without stop (Theo Engel)\r\n\r\n                        h316_stddev.c:\r\n                        - fixed bug in clock increment (Theo Engel)\r\n\r\n                        i1401_cpu.c:\r\n                        - added recognition of overlapped operation modifiers\r\n                        - remove restriction on load-mode binary tape operations\r\n\r\n                        i1401_mt.c:\r\n                        - fixed read tape mark operation (Van Snyder)\r\n                        - remove restriction on load-mode binary tape operations\r\n\r\n                        pdp1_cpu.c:\r\n                        - fixed typo in SBS clear (Norm Lastovica)\r\n\r\n                        pdp11_rh.c, pdp11_rp.c, pdp11_tu.c:\r\n                        - CS1 DVA is in the device, not the MBA\r\n\r\n                        pdp8_ct.c:\r\n                        - fixed typo (Norm Lastovica)\r\n\r\n                        vax_cpu.c:\r\n                        - revised idle detector\r\n\r\n  1     14-May-07       scp.c:\r\n                        - modified sim_instr invocation to call sim_rtcn_init_all\r\n                        - fixed bug in get_sim_opt (reported by Don North)\r\n                        - fixed bug in RESTORE with changed memory size\r\n                        - added global 'RESTORE in progress' flag\r\n                        - fixed breakpoint actions in DO command file processing\r\n                          (Dave Bryan)\r\n\r\n                        all CPU's with clocks:\r\n                        - removed clock initialization (now done in SCP)\r\n\r\n                        hp2100_cpu.c (Dave Bryan):\r\n                        - EDT passes input flag and DMA channel in dat parameter\r\n\r\n                        hp2100_ipl.c (Dave Bryan):\r\n                        - IPLI EDT delays DMA completion interrupt for TSB\r\n\r\n                        hp2100_mux.c (Dave Bryan):\r\n                        - corrected \"mux_sta\" size from 16 to 21 elements\r\n                        - fixed \"muxc_reset\" to clear lines 16-20\r\n                        - fixed control card OTx to set current channel number\r\n                        - fixed to set \"muxl_ibuf\" in response to a transmit interrupt\r\n                        - changed \"mux_xbuf\", \"mux_rbuf\" declarations from 8 to 16 bits\r\n                        - fixed to set \"mux_rchp\" when a line break is received\r\n                        - fixed incorrect \"odd_par\" table values\r\n                        - reversed test in \"RCV_PAR\" to return \"LIL_PAR\" on odd parity\r\n                        - fixed mux reset (ioCRS) to clear port parameters\r\n                        - fixed to use PUT_DCH instead of PUT_CCH for data channel status\r\n                        - added DIAG/TERM modifiers to implement diagnostic mode\r\n\r\n                        pdp11_cpumod.c:\r\n                        - changed memory size routine to work with RESTORE\r\n\r\n                        pdp11_hk.c:\r\n                        - NOP and DCLR (at least) do not check drive type\r\n                        - MR2 and MR3 only updated on NOP\r\n\r\n                        pdp10_tu.c, pdp11_tu.c:\r\n                        - TMK sets FCE only on read (Naoki Hamada)\r\n\r\n                        pdp11_xu.c:\r\n                        - added missing FC_RMAL command\r\n                        - cleared multicast on write\r\n\r\n                        vax_moddefs.h, vax_cpu1.c:\r\n                        - separated PxBR and SBR mbz checks\r\n\r\n                        vax780_defs.h\r\n                        - separated PxBR and SBR mbz checks\r\n                        - modified mbz checks to reflect 780 microcode patches\r\n                          (Naoki Hamada)\r\n\r\n                        vax_mmu.c:\r\n                        - added address masking to all SBR-based memory reads\r\n\r\n  0     30-Jan-07       scp.c:\r\n                        - implemented throttle commands\r\n                        - added -e to control error processing in DO command files\r\n                          (Dave Bryan)\r\n\r\n                        sim_console.c:\r\n                        - fixed handling of non-printable characters in KSR mode\r\n\r\n                        sim_tape.c:\r\n                        - fixed bug in reverse operations for P7B-format tapes\r\n                        - fixed bug in reverse operations across erase gaps\r\n\r\n                        sim_timer.c:\r\n                        - added throttle support\r\n                        - added idle support (based on work by Mark Pizzolato)\r\n\r\n                        gri_stddev.c, h316_stddev.c, pdp18b_tt1.c\r\n                        - fixed handling of non-printable characters in KSR mode\r\n\r\n                        hp2100_cpu.c, hp2100_cpu0.c, hp2100_cpu1.c, hp2100_cpu2.c,\r\n                        hp2100_cpu3.c, hp2100_cpu4.c (Dave Bryan):\r\n                        - reorganized CPU modules for easier addition of new instructions\r\n                        - added Double Integer instructions, 1000-F CPU, 2114 and\r\n                          2115 CPUs, 12K and 24K memory sizes, 12607B and 12578A DMA\r\n                          controllers, and 21xx binary loader protection\r\n                        - fixed DMS self-test instruction execution on 1000-M\r\n                        - fixed indirect interrupt holdoff logic\r\n\r\n                        hp2100_ds.c:\r\n                        - fixed REQUEST STATUS to clear status-1 (Dave Bryan)\r\n\r\n                        hp2100_fp1.c:\r\n                        - Added Floating Point Processor (Dave Bryan)\r\n\r\n                        hp2100_lps.c:\r\n                        - fixed diag-mode CLC response\r\n\r\n                        i7094_cpu.c:\r\n                        - fixed new bug in halt IO wait loop\r\n                        - added IFT, EFT expanded core test instructions\r\n\r\n                        id16_cpu.c, id32_cpu.c:\r\n                        - removed separate multiplexor clock\r\n                        - added idle support\r\n\r\n                        id_pas.c:\r\n                        - synced multiplexor poll to real-time clock\r\n\r\n                        id_tt.c, id_ttp.c:\r\n                        - fixed handling of non-printable characters in KSR mode\r\n                        - synced keyboard poll to real-time clock\r\n\r\n                        id_uvc.c:\r\n                        - changed line-time clock to be free-running\r\n\r\n                        pdp1_cpu.c:\r\n                        - added 16-channel sequence break system (API) support\r\n                        - added PDP-1D support\r\n\r\n                        pdp1_clk.c:\r\n                        - first release\r\n\r\n                        pdp1_dcs.c:\r\n                        - first release\r\n\r\n                        pdp1_stddev.c:\r\n                        - separated TTI, TTO for API support\r\n\r\n                        pdp1_sys.c:\r\n                        - added PDP-1D, 16-channel SBS, clock, DCS support\r\n                        - fixed bugs in character input, block loader\r\n\r\n                        pdp10_cpu.c:\r\n                        - added idle support\r\n\r\n                        pdp10_defs.h, pdp10_sys.c:\r\n                        - added CR support\r\n\r\n                        pdp10_fe.c, pdp10_tim.c:\r\n                        - synced keyboard poll to real-time clock\r\n\r\n                        pdp11_cr.c:\r\n                        - revised for PDP-10 compatibility (CD11 only)\r\n\r\n                        pdp11_cpu.c:\r\n                        - added idle support\r\n                        - fixed bug in ASH -32 C value\r\n\r\n                        pdp11_rf.c:\r\n                        - fixed unit mask (John Dundas)\r\n\r\n                        pdp11_stddev.c, vax_stddev.c, vax780_stddev.c:\r\n                        - synced keyboard poll to real-time clock\r\n                        - added clock coscheduling support\r\n\r\n                        pdp11_ta.c:\r\n                        - first release\r\n\r\n                        pdp11_vh.c:\r\n                        - synced service poll to real-time clock\r\n                        - changed device to be off by default\r\n\r\n                        pdp11_dz.c, pdp11_xq.c, pdp11_xu.c:\r\n                        - synced service poll to real-time clock\r\n\r\n                        pdp11_sys.c:\r\n                        - fixed operand order in EIS instructions (W.F.J. Mueller)\r\n                        - added TA11 support\r\n\r\n                        pdp18b_cpu.c:\r\n                        - fixed incorrect value of PC on instruction fetch mem mmgt error\r\n                        - fixed PDP-15 handling of mem mmgt traps (sets API 3)\r\n                        - fixed PDP-15 handling of CAL API 4 (sets only if 0-3 inactive)\r\n                        - fixed PDP-15 CAF to clear memory management mode register\r\n                        - fixed boundary test in KT15/XVM (reported by Andrew Warkentin)\r\n                        - added XVM RDCLK instruction\r\n                        - added idle support and infinite loop detection\r\n\r\n                        pdp18b_rf.c:\r\n                        - fixed bug, DSCD does not clear function register\r\n\r\n                        pdp18b_stddev.c:\r\n                        - added PDP-15 program-selectable duplex handling instruction\r\n                        - fixed PDP-15 handling of reader out-of-tape\r\n                        - fixed handling of non-printable characters in KSR mode\r\n                        - added XVM RDCLK instruction\r\n                        - changed real-time clock to be free running\r\n                        - synced keyboard poll to real-time clock\r\n\r\n                        pdp18b_tt1.c\r\n                        - fixed handling of non-printable characters in KSR mode\r\n\r\n                        pdp18b_sys.c:\r\n                        - added XVM RDCLK instruction\r\n\r\n                        pdp8_cpu.c:\r\n                        - fixed SC value after DVI overflow (Don North)\r\n                        - added idle support and infinite loop detection\r\n\r\n                        pdp8_ct.c:\r\n                        - first release\r\n\r\n                        pdp8_clk.c:\r\n                        - changed real-time clock to be free running\r\n\r\n                        pdp8_sys.c:\r\n                        - added TA8E support\r\n                        - added ability to disambiguate overlapping IOT definitions\r\n\r\n                        pdp8_tt.c:\r\n                        - fixed handling of non-printable characters in KSR mode\r\n                        - synced keyboard poll to real-time clock\r\n\r\n                        vax_cpu.c, vax_cpu1.c:\r\n                        - added idle support\r\n\r\n                        vax_syscm.c:\r\n                        - fixed operand order in EIS instructions (W.F.J. Mueller)\r\n\r\n\r\n   V3.6 revision history\r\n\r\n  1     25-Jul-06       sim_console.c:\r\n                        - implemented SET/SHOW PCHAR\r\n\r\n                        all DECtapes:\r\n                        - fixed conflict in ATTACH switches\r\n\r\n                        hp2100_ms.c (Dave Bryan):\r\n                        - added CAPACITY as alternate for REEL\r\n                        - fixed EOT test for unlimited reel size\r\n\r\n                        i1620_cd.c (Tom McBride):\r\n                        - fixed card reader fgets call\r\n                        - fixed card reader boot sequence\r\n\r\n                        i7094_cd.c:\r\n                        - fixed problem with 80 column full cards\r\n\r\n                        i7094_cpu.c:\r\n                        - fixed bug in halt IO wait loop\r\n\r\n                        i7094_sys.c:\r\n                        - added binary loader (courtesy of Dave Pitt)\r\n\r\n                        pdp1_cpu.c:\r\n                        - fixed bugs in MUS and DIV\r\n\r\n                        pdp11_cis.c:\r\n                        - added interrupt tests to character instructions\r\n                        - added 11/44 stack probe test to MOVCx (only)\r\n\r\n                        pdp11_dl.c:\r\n                        - first release\r\n\r\n                        pdp11_rf.c:\r\n                        - first release\r\n\r\n                        pdp11_stddev.c:\r\n                        - added UC support to TTI, TTO\r\n\r\n                        pdp18b_cpu.c:\r\n                        - fixed RESET to clear AC, L, and MQ\r\n\r\n                        pdp18b_dt.c:\r\n                        - fixed checksum calculation bug for Type 550\r\n\r\n                        pdp18b_fpp.c:\r\n                        - fixed bugs in left shift, multiply\r\n\r\n                        pdp18b_stddev.c:\r\n                        - fixed Baudot letters/figures inversion for PDP-4\r\n                        - fixed letters/figures tracking for PDP-4\r\n                        - fixed PDP-4/PDP-7 default terminal to be local echo\r\n\r\n                        pdp18b_sys.c:\r\n                        - added Fiodec, Baudot display\r\n                        - generalized LOAD to handle HRI, RIM, and BIN files\r\n\r\n                        pdp8_ttx.c:\r\n                        - fixed bug in DETACH routine\r\n\r\n  0     15-May-06       scp.c:\r\n                        - revised save file format to save options, unit capacity\r\n\r\n                        sim_tape.c, sim_tape.h:\r\n                        - added support for finite reel size\r\n                        - fixed bug in P7B write record\r\n\r\n                        most magtapes:\r\n                        - added support for finite reel size\r\n\r\n                        h316_cpu.c: fixed bugs in LLL, LRL (Theo Engel)\r\n\r\n                        h316_lp.c: fixed bug in blanks backscanning (Theo Engel)\r\n\r\n                        h316_stddev.c: fixed bugs in punch state handling (Theo Engel)\r\n\r\n                        i1401_cpu.c: fixed bug in divide (reported by Van Snyder)\r\n\r\n                        i16_cpu.c: fixed bug in DH (Mark Hittinger)\r\n\r\n                        i32_cpu.c:\r\n                        - fixed bug in DH (Mark Hittinger)\r\n                        - added support for 8 register banks in 8/32\r\n\r\n                        i7094: first release\r\n\r\n                        id_io.c: fixed bug, GO preserves EXA and SSTA (Davis Johnson)\r\n\r\n                        id_idc.c:\r\n                        - fixed WD/WH handling (Davis Johnson)\r\n                        - fixed bug, nop command should be ignored (Davis Johnson)\r\n\r\n                        nova_cpu.c: fixed bug in DIVS (Mark Hittinger)\r\n\r\n                        pdp11_cis.c: (all reported by John Dundas)\r\n                        - fixed bug in decode table\r\n                        - fixed bug in ASHP\r\n                        - fixed bug in write decimal string with mmgt enabled\r\n                        - fixed bug in 0-length strings in multiply/divide\r\n\r\n                        pdp11_cpu.c: fixed order of operand fetching in XOR for SDSD models\r\n\r\n                        pdp11_cr.c: added CR11/CD11 support\r\n\r\n                        pdp11_tc.c:\r\n                        - fixed READ to set extended data bits in TCST (Alan Frisbie)\r\n\r\n                        vax780_fload.c: added FLOAD command\r\n\r\n                        vax780_sbi.c: fixed writes to ACCS\r\n\r\n                        vax780_stddev.c: revised timer logic for EVKAE (reported by Tim Stark)\r\n\r\n                        vax_cis.c: (all reported by Tim Stark)\r\n                        - fixed MOVTC, MOVTUC to preserve cc's through page faults\r\n                        - fixed MOVTUC to stop on translated == escape\r\n                        - fixed CVTPL to set registers before destination reg write\r\n                        - fixed CVTPL to set correct cc bit on overflow\r\n                        - fixed EDITPC to preserve cc's through page faults\r\n                        - fixed EDITPC EO$BLANK_ZERO count, cc test\r\n                        - fixed EDITPC EO$INSERT to insert fill instead of blank\r\n                        - fixed EDITPC EO$LOAD_PLUS/MINUS to skip character\r\n\r\n                        vax_cpu.c:\r\n                        - added KESU capability to virtual examine\r\n                        - fixed bugs in virtual examine\r\n                        - rewrote CPU history function for improved usability\r\n                        (bugs below reported by Tim Stark)\r\n                        - fixed fault cleanup to clear PSL<tp>\r\n                        - fixed ADAWI r-mode to preserve dst<31:16>\r\n                        - fixed ACBD/G to test correct operand\r\n                        - fixed access checking on modify-class specifiers\r\n                        - fixed branch address calculation in CPU history\r\n                        - fixed bug in reported VA on faulting cross-page write\r\n\r\n                        vax_cpu1.c: (all reported by Tim Stark)\r\n                        - added access check on system PTE for 11/780\r\n                        - added mbz check in LDPCTX for 11/780\r\n\r\n                        vax_cmode.c: (all reported by Tim Stark)\r\n                        - fixed omission of SXT\r\n                        - fixed order of operand fetching in XOR\r\n\r\n                        vax_fpa.c: (all reported by Tim Stark)\r\n                        - fixed POLYD, POLYG to clear R4, R5\r\n                        - fixed POLYD, POLYG to set R3 correctly\r\n                        - fixed POLYD, POLYG to not exit prematurely if arg = 0\r\n                        - fixed POLYD, POLYG to do full 64b multiply\r\n                        - fixed POLYF, POLYD, POLYG to remove truncation on add\r\n                        - fixed POLYF, POLYD, POLYG to mask mul result to 31b/63b/63b\r\n                        - fixed fp add routine to test for zero via fraction\r\n                          to support \"denormal\" argument from POLYF, POLYD, POLYG\r\n                        - fixed bug in 32b floating multiply routine\r\n                        - fixed bug in 64b extended modulus routine\r\n\r\n                        vax_mmu.c:\r\n                        - added access check on system PTE for 11/780\r\n\r\n                        vax_octa.c: (all reported by Tim Stark)\r\n                        - fixed MNEGH to test negated sign, clear C\r\n                        - fixed carry propagation in qp_inc, qp_neg, qp_add\r\n                        - fixed pack routines to test for zero via fraction\r\n                        - fixed ACBH to set cc's on result\r\n                        - fixed POLYH to set R3 correctly\r\n                        - fixed POLYH to not exit prematurely if arg = 0\r\n                        - fixed POLYH to mask mul result to 127b\r\n                        - fixed fp add routine to test for zero via fraction\r\n                          to support \"denormal\" argument from POLYH\r\n                        - fixed EMODH to concatenate 15b of 16b extension\r\n                        - fixed bug in reported VA on faulting cross-page write\r\n\r\n\r\n   V3.5 revision history\r\n\r\npatch   date            module(s) and fix(es)\r\n\r\n  2     07-Jan-06       scp.c:\r\n                        - added breakpoint spaces\r\n                        - added REG_FIT support\r\n\r\n                        sim_console.c: added ASCII character processing routines\r\n\r\n                        sim_tape.c, sim_tape.h:\r\n                        - added write support for P7B format\r\n                        - fixed bug in write forward (Dave Bryan)\r\n\r\n                        h316_stddev.c, hp2100_stddev.c, hp2100_mux.c, id_tt.c,\r\n                        id_ttp.c, id_pas.c, pdp8_tt.c, pdp8_ttx.c, pdp11_stddev.c,\r\n                        pdp11_dz.c, pdp18b_stddev.c, pdp18b_tt1.c, vax_stddev,\r\n                        gri_stddev.c:\r\n                        - revised to support new character handling routines\r\n\r\n                        pdp10_rp.c: fixed DCLR not to clear disk address\r\n\r\n                        pdp11_hk.c: fixed overlapped seek interaction with NOP, etc\r\n\r\n                        pdp11_rh.c: added enable/disable routine\r\n\r\n                        pdp11_rq.c, pdp11_tm.c, pdp11_tq.c, pdp11_ts.c\r\n                        - widened address display to 64b when USE_ADDR64\r\n\r\n                        pdp11_rp.c:\r\n                        - fixed DCLR not to clear disk address\r\n                        - fixed device enable/disable logic to include Massbus adapter\r\n                        - widened address display to 64b when USE_ADDR64\r\n\r\n                        pdp11_tu.c:\r\n                        - fixed device enable/disable logic to include Massbus adapter\r\n                        - widened address display to 64b when USE_ADDR64\r\n                        - changed default adapter to TM03 (for VMS)\r\n\r\n                        pdp8_df.c, pdp8_dt.c, pdp8_rf.c:\r\n                        - fixed unaligned access bug (Doug Carman)\r\n\r\n                        pdp8_rl.c: fixed IOT 61 decoding bug (David Gesswein)\r\n\r\n                        vax_cpu.c:\r\n                        - fixed breakpoint detection when USE_ADDR64 option is active\r\n                        - fixed CVTfi to trap on integer overflow if PSW<iv> set\r\n\r\n  1     15-Oct-05       All CPU's, other sources: fixed declaration inconsistencies\r\n                        (Sterling Garwood)\r\n\r\n                        i1401_cpu.c: added control for old/new character encodings\r\n\r\n                        i1401_cd.c, i1401_lpt.c, i1401_tty.c:\r\n                        - changed character encodings to be consistent with 7094\r\n                        - changed column binary format to be consistent with 7094\r\n                        - added choice of business or Fortran set for output encoding\r\n\r\n                        i1401_sys.c: changed WM character to ` under new encodings\r\n\r\n                        i1620_cd.c, i1620_lpt.c, i1620_tty.c:\r\n                        - changed character encodings to be consistent with 7094\r\n\r\n                        pdp10_cpu.c: changed MOVNI to eliminate gcc warning\r\n\r\n                        pdp11_io.c: fixed bug in autoconfiguration (missing XU)\r\n\r\n                        vax_io.c: fixed bug in autoconfiguration (missing XU)\r\n\r\n                        vax_fpa.c: fixed bug in 32b structure definitions (Jason Stevens)\r\n\r\n  0     1-Sep-05        Note: most source modules have been edited to improve\r\n                        readability and to fix declaration and cast problems in C++\r\n\r\n                        all instruction histories: fixed reversed arguments to calloc\r\n\r\n                        scp.c: revised to trim trailing spaces on file inputs\r\n\r\n                        sim_sock.c: fixed SIGPIPE error on Unix\r\n\r\n                        sim_ether.c: added Windows user-defined adapter names (Timothe Litt)\r\n\r\n                        sim_tape.c: fixed misallocation of TPC map array\r\n\r\n                        sim_tmxr.c: added support for SET <unit> DISCONNECT\r\n\r\n                        hp2100_mux.c: added SET MUXLn DISCONNECT\r\n\r\n                        i1401_cpu.c:\r\n                        - fixed SSB-SSG clearing on RESET (reported by Ralph Reinke)\r\n                        - removed error stops in MCE\r\n\r\n                        i1401_cd.c: fixed read, punch to ignore modifier on 1, 4 char inst\r\n                        (reported by Van Snyder)\r\n\r\n                        id_pas.c:\r\n                        - fixed bug in SHOW CONN/STATS\r\n                        - added SET PASLn DISCONNECT\r\n\r\n                        pdp10_ksio.c: revised for new autoconfiguration interface\r\n\r\n                        pdp11_cpu.c: replaced WAIT clock queue check with API call\r\n\r\n                        pdp11_cpumod.c: added additional 11/60 registers\r\n\r\n                        pdp11_io.c: revised autoconfiguration algorithm and interface\r\n\r\n                        pdp11_dz.c: revised for new autoconfiguration interface\r\n\r\n                        pdp11_vh.c:\r\n                        - revised for new autoconfiguration interface\r\n                        - fixed bug in vector display routine\r\n\r\n                        pdp11_xu.c: fixed runt packet processing (Tim Chapman)\r\n\r\n                        pdp18b_cpu.c, pdp18b_sys.c:\r\n                        - removed spurious AAS instruction\r\n\r\n                        pdp18b_tt1.c:\r\n                        - fixed bug in SHOW CONN/STATS\r\n                        - fixed bug in SET LOG/NOLOG\r\n                        - added SET TTOXn DISCONNECT\r\n\r\n                        pdp8_ttx.c:\r\n                        - fixed bug in SHOW CONN/STATS\r\n                        - fixed bug in SET LOG/NOLOG\r\n                        - added SET TTOXn DISCONNECT\r\n\r\n                        sds_mux.c:\r\n                        - fixed bug in SHOW CONN/STATS\r\n                        - added SET MUXLn DISCONNECT\r\n\r\n                        vaxmod_defs.h: added QDSS support\r\n\r\n                        vax_io.c: revised autoconfiguration algorithm and interface\r\n\r\n   V3.4 revision history\r\n\r\n  0     01-May-04       scp.c:\r\n                        - fixed ASSERT code\r\n                        - revised syntax for SET DEBUG (Dave Bryan)\r\n                        - revised interpretation of fprint_sym, fparse_sym returns\r\n                        - moved DETACH sanity tests into detach_unit\r\n\r\n                        sim_sock.h and sim_sock.c:\r\n                        - added test for WSAEINPROGRESS (Tim Riker)\r\n\r\n                        many: revised detach routines to test for attached state\r\n\r\n                        hp2100_cpu.c: reorganized CPU options (Dave Bryan)\r\n\r\n                        hp2100_cpu1.c: reorganized EIG routines (Dave Bryan)\r\n\r\n                        hp2100_fp1.c: added FFP support (Dave Bryan)\r\n\r\n                        id16_cpu.c:\r\n                        - fixed bug in show history routine (Mark Hittinger)\r\n                        - revised examine/deposit to do words rather than bytes\r\n\r\n                        id32_cpu.c:\r\n                        - fixed bug in initial memory allocation\r\n                        - fixed bug in show history routine (Mark Hittinger)\r\n                        - revised examine/deposit to do words rather than bytes\r\n\r\n                        id16_sys.c, id32_sys:\r\n                        - revised examine/deposit to do words rather than bytes\r\n\r\n                        pdp10_tu.c:\r\n                        - fixed bug, ERASE and WREOF should not clear done (reported\r\n                          by Rich Alderson)\r\n                        - fixed error reporting\r\n\r\n                        pdp11_tu.c: fixed error reporting\r\n\r\n   V3.3 revision history\r\n\r\n  2     08-Mar-05       scp.c: added ASSERT command (Dave Bryan)\r\n\r\n                        h316_defs.h: fixed IORETURN macro\r\n\r\n                        h316_mt.c: fixed error reporting from OCP (Philipp Hachtmann)\r\n\r\n                        h316_stddev.c: fixed bug in OCP '0001 (Philipp Hachtmann)\r\n\r\n                        hp2100_cpu.c: split out EAU and MAC instructions\r\n\r\n                        hp2100_cpu1.c: (Dave Bryan)\r\n                        - fixed missing MPCK on JRS target\r\n                        - removed EXECUTE instruction (is NOP in actual microcode)\r\n\r\n                        hp2100_fp: (Dave Bryan)\r\n                        - fixed missing negative overflow renorm in StoreFP\r\n\r\n                        i1401_lp.c: fixed bug in write_line (reported by Van Snyder)\r\n\r\n                        id32_cpu.c: fixed branches to mask new PC (Greg Johnson)\r\n\r\n                        pdp11_cpu.c: fixed bugs in RESET for 11/70 (reported by Tim Chapman)\r\n\r\n                        pdp11_cpumod.c:\r\n                        - fixed bug in SHOW MODEL (Sergey Okhapkin)\r\n                        - made SYSID variable for 11/70 (Tim Chapman)\r\n                        - added MBRK write case for 11/70 (Tim Chapman)\r\n\r\n                        pdp11_rq: added RA60, RA71, RA81 disks\r\n\r\n                        pdp11_ry: fixed bug in boot code (reported by Graham Toal)\r\n\r\n                        vax_cpu.c: fixed initial state of cpu_extmem\r\n\r\n  1     05-Jan-05       h316_cpu.c: fixed bug in DIV\r\n\r\n                        h316_stddev.c:\r\n                        - fixed bug in SKS '104 (reported by Philipp Hachtmann)\r\n                        - fixed bug in SKS '504\r\n                        - adder reader/punch ASCII file support\r\n                        - added Teletype reader/punch support\r\n\r\n                        h316_dp.c: fixed bug in skip on !seeking\r\n\r\n                        h316_mt.c: fixed bug in DMA/DMC support\r\n\r\n                        h316_lp.c: fixed bug in DMA/DMC support\r\n\r\n                        hp2100_cpu.c:\r\n                        - fixed DMA reset to clear alternate CTL flop (Dave Bryan)\r\n                        - fixed DMA reset to not clear control words (Dave Bryan)\r\n                        - fixed SBS, CBS, TBS to do virtual reads\r\n                        - separated A/B from M[0/1], for DMA IO (Dave Bryan)\r\n                        - added SET CPU 21MX-M, 21MX-E (Dave Brian)\r\n                        - disabled TIMER/EXECUTE/DIAG instructions for 21MX-M (Dave Bryan)\r\n                        - added post-processor to maintain T/M consistency (Dave Bryan)\r\n\r\n                        hp2100_ds.c: first release\r\n\r\n                        hp2100_lps.c (all changes from Dave Bryan)\r\n                        - added restart when set online, etc.\r\n                        - fixed col count for non-printing chars\r\n\r\n                        hp2100_lpt.c (all changes from Dave Bryan)\r\n                        - added restart when set online, etc.\r\n\r\n                        hp2100_sys.c (all changes from Dave Bryan):\r\n                        - added STOP_OFFLINE, STOP_PWROFF messages\r\n\r\n                        i1401_sys.c: added address argument support (Van Snyder)\r\n\r\n                        id_mt.c: added read-only file support\r\n\r\n                        lgp_cpu.c, lgp_sys.c: modified VM pointer setup\r\n\r\n                        pdp11_cpu.c: fixed WAIT to work in all modes (John Dundas)\r\n\r\n                        pdp11_tm.c, pdp11_ts.c: added read-only file support\r\n\r\n                        sds_mt.c: added read-only file support\r\n\r\n  0     23-Nov-04       scp.c:\r\n                        - added reset_all_p (powerup)\r\n                        - fixed comma-separated SET options (Dave Bryan)\r\n                        - changed ONLINE/OFFLINE to ENABLED/DISABLED (Dave Bryan)\r\n                        - modified to flush device buffers on stop (Dave Bryan)\r\n                        - changed HELP to suppress duplicate command displays\r\n\r\n                        sim_console.c:\r\n                        - moved SET/SHOW DEBUG under CONSOLE hierarchy\r\n\r\n                        hp2100_cpu.c: (all fixes by Dave Bryan)\r\n                        - moved MP into its own device; added MP option jumpers\r\n                        - modified DMA to allow disabling\r\n                        - modified SET CPU 2100/2116 to truncate memory > 32K\r\n                        - added -F switch to SET CPU to force memory truncation\r\n                        - fixed S-register behavior on 2116\r\n                        - fixed LIx/MIx behavior for DMA on 2116 and 2100\r\n                        - fixed LIx/MIx behavior for empty I/O card slots\r\n                        - modified WRU to be REG_HRO\r\n                        - added BRK and DEL to save console settings\r\n                        - fixed use of \"unsigned int16\" in cpu_reset\r\n\r\n                        hp2100_dp.c: (all fixes by Dave Bryan)\r\n                        - fixed enable/disable from either device\r\n                        - fixed ANY ERROR status for 12557A interface\r\n                        - fixed unattached drive status for 12557A interface\r\n                        - status cmd without prior STC DC now completes (12557A)\r\n                        - OTA/OTB CC on 13210A interface also does CLC CC\r\n                        - fixed RAR model\r\n                        - fixed seek check on 13210 if sector out of range\r\n\r\n                        hp2100_dq.c: (all fixes by Dave Bryan)\r\n                        - fixed enable/disable from either device\r\n                        - shortened xtime from 5 to 3 (drive avg 156KW/second)\r\n                        - fixed not ready/any error status\r\n                        - fixed RAR model\r\n\r\n                        hp2100_dr.c: (all fixes by Dave Bryan)\r\n                        - fixed enable/disable from either device\r\n                        - fixed sector return in status word\r\n                        - provided protected tracks and \"Writing Enabled\" status bit\r\n                        - fixed DMA last word write, incomplete sector fill value\r\n                        - added \"parity error\" status return on writes for 12606\r\n                        - added track origin test for 12606\r\n                        - added SCP test for 12606\r\n                        - fixed 12610 SFC operation\r\n                        - added \"Sector Flag\" status bit\r\n                        - added \"Read Inhibit\" status bit for 12606\r\n                        - fixed current-sector determination\r\n                        - added TRACKPROT modifier\r\n\r\n                        hp2100_ipl.c, hp2100_ms.c: (all fixes by Dave Bryan)\r\n                        - fixed enable/disable from either device\r\n\r\n                        hp2100_lps.c: (all fixes by Dave Bryan)\r\n                        - added SET OFFLINE/ONLINE, POWEROFF/POWERON\r\n                        - fixed status returns for error conditions\r\n                        - fixed handling of non-printing characters\r\n                        - fixed handling of characters after column 80\r\n                        - improved timing model accuracy for RTE\r\n                        - added fast/realistic timing\r\n                        - added debug printouts\r\n\r\n                        hp2100_lpt.c: (all fixes by Dave Bryan)\r\n                        - added SET OFFLINE/ONLINE, POWEROFF/POWERON\r\n                        - fixed status returns for error conditions\r\n                        - fixed TOF handling so form remains on line 0\r\n\r\n                        hp2100_stddev.c (all fixes by Dave Bryan)\r\n                        - added paper tape loop mode, DIAG/READER modifiers to PTR\r\n                        - added PV_LEFT to PTR TRLLIM register\r\n                        - modified CLK to permit disable\r\n\r\n                        hp2100_sys.c: (all fixes by Dave Bryan)\r\n                        - added memory protect device\r\n                        - fixed display of CCA/CCB/CCE instructions\r\n\r\n                        i1401_cpu.c: added =n to SHOW HISTORY\r\n\r\n                        id16_cpu.c: added instruction history\r\n\r\n                        id32_cpu.c: added =n to SHOW HISTORY\r\n\r\n                        pdp10_defs.h: revised Unibus DMA API's\r\n\r\n                        pdp10_ksio.c: revised Unibus DMA API's\r\n\r\n                        pdp10_lp20.c: revised Unibus DMA API's\r\n\r\n                        pdp10_rp.c: replicated register state per drive\r\n\r\n                        pdp10_tu.c:\r\n                        - fixed to set FCE on short record\r\n                        - fixed to return bit<15> in drive type\r\n                        - fixed format specification, 1:0 are don't cares\r\n                        - implemented write check\r\n                        - TMK is cleared by new motion command, not DCLR\r\n                        - DONE is set on data transfers, ATA on non data transfers\r\n\r\n                        pdp11_defs.h:\r\n                        - revised Unibus/Qbus DMA API's\r\n                        - added CPU type and options flags\r\n\r\n                        pdp11_cpumod.h, pdp11_cpumod.c:\r\n                        - new routines for setting CPU type and options\r\n\r\n                        pdp11_io.c: revised Unibus/Qbus DMA API's\r\n\r\n                        all PDP-11 DMA peripherals:\r\n                        - revised Unibus/Qbus DMA API's\r\n\r\n                        pdp11_hk.c: CS2 OR must be zero for M+\r\n\r\n                        pdp11_rh.c, pdp11_rp.c, pdp11_tu.c:\r\n                        - split Massbus adapter from controllers\r\n                        - replicated RP register state per drive\r\n                        - added TM02/TM03 with TE16/TU45/TU77 drives\r\n\r\n                        pdp11_rq.c, pdp11_tq.c:\r\n                        - provided different default timing for PDP-11, VAX\r\n                        - revised to report CPU bus type in stage 1\r\n                        - revised to report controller type reflecting bus type\r\n                        - added -L switch (LBNs) to RAUSER size specification\r\n\r\n                        pdp15_cpu.c: added =n to SHOW HISTORY\r\n\r\n                        pdp15_fpp.c:\r\n                        - fixed URFST to mask low 9b of fraction\r\n                        - fixed exception PC setting\r\n\r\n                        pdp8_cpu.c: added =n to SHOW HISTORY\r\n\r\n                        vax_defs.h:\r\n                        - added octaword, compatibility mode support\r\n\r\n                        vax_moddefs.h:\r\n                        - revised Unibus/Qbus DMA API's\r\n\r\n                        vax_cpu.c:\r\n                        - moved processor-specific code to vax_sysdev.c\r\n                        - added =n to SHOW HISTORY\r\n\r\n                        vax_cpu1.c:\r\n                        - moved processor-specific IPR's to vax_sysdev.c\r\n                        - moved emulation trap to vax_cis.c\r\n                        - added support for compatibility mode\r\n\r\n                        vax_cis.c: new full VAX CIS instruction emulator\r\n\r\n                        vax_octa.c: new full VAX octaword and h_floating instruction emulator\r\n\r\n                        vax_cmode.c: new full VAX compatibility mode instruction emulator\r\n\r\n                        vax_io.c:\r\n                        - revised Unibus/Qbus DMA API's\r\n\r\n                        vax_io.c, vax_stddev.c, vax_sysdev.c:\r\n                        - integrated powerup into RESET (with -p)\r\n\r\n                        vax_sys.c:\r\n                        - fixed bugs in parsing indirect displacement modes\r\n                        - fixed bugs in displaying and parsing character data\r\n\r\n                        vax_syscm.c: added display and parse for compatibility mode\r\n\r\n                        vax_syslist.c:\r\n                        - split from vax_sys.c\r\n                        - removed PTR, PTP\r\n\r\n   V3.2 revision history\r\n\r\n  3     03-Sep-04       scp.c:\r\n                        - added ECHO command (Dave Bryan)\r\n                        - qualified RESTORE detach with SIM_SW_REST\r\n\r\n                        sim_console: added OS/2 EMX fixes (Holger Veit)\r\n\r\n                        sim_sock.h: added missing definition for OS/2 (Holger Veit)\r\n\r\n                        hp2100_cpu.c: changed error stops to report PC not PC + 1\r\n                        (Dave Bryan)\r\n\r\n                        hp2100_dp.c: functional and timing fixes (Dave Bryan)\r\n                        - controller sets ATN for all commands except read status\r\n                        - controller resumes polling for ATN interrupts after read status\r\n                        - check status on unattached drive set busy and not ready\r\n                        - check status tests wrong unit for write protect status\r\n                        - drive on line sets ATN, will set FLG if polling\r\n\r\n                        hp2100_dr.c: fixed CLC to stop operation (Dave Bryan)\r\n\r\n                        hp2100_ms.c: functional and timing fixes (Dave Bryan)\r\n                        - fixed erroneous execution of rejected command\r\n                        - fixed erroneous execution of select-only command\r\n                        - fixed erroneous execution of clear command\r\n                        - fixed odd byte handling for read\r\n                        - fixed spurious odd byte status on 13183A EOF\r\n                        - modified handling of end of medium\r\n                        - added detailed timing, with fast and realistic modes\r\n                        - added reel sizes to simulate end of tape\r\n                        - added debug printouts\r\n\r\n                        hp2100_mt.c: modified handling of end of medium (Dave Bryan)\r\n\r\n                        hp2100_stddev.c: added tab to control char set (Dave Bryan)\r\n\r\n                        pdp11_rq.c: VAX controllers luns start at 0 (Andreas Cejna)\r\n\r\n                        vax_cpu.c: fixed bug in EMODD/G, second word of quad dst not probed\r\n\r\n  2     17-Jul-04       scp.c: fixed problem ATTACHing to read only files\r\n                        (John Dundas)\r\n\r\n                        sim_console.c: revised Windows console code (Dave Bryan)\r\n\r\n                        sim_fio.c: fixed problem in big-endian read\r\n                        (reported by Scott Bailey)\r\n\r\n                        gri_cpu.c: updated MSR, EAO functions\r\n\r\n                        hp_stddev.c: generalized handling of control char echoing\r\n                        (Dave Bryan)\r\n\r\n                        vax_sys.c: fixed bad block initialization routine\r\n\r\n  1     10-Jul-04       scp.c: added SET/SHOW CONSOLE subhierarchy\r\n\r\n                        hp2100_cpu.c: fixes and added features (Dave Bryan)\r\n                        - SBT increments B after store\r\n                        - DMS console map must check dms_enb\r\n                        - SFS x,C and SFC x,C work\r\n                        - MP violation clears automatically on interrupt\r\n                        - SFS/SFC 5 is not gated by protection enabled\r\n                        - DMS enable does not disable mem prot checks\r\n                        - DMS status inconsistent at simulator halt\r\n                        - Examine/deposit are checking wrong addresses\r\n                        - Physical addresses are 20b not 15b\r\n                        - Revised DMS to use memory rather than internal format\r\n                        - Added instruction printout to HALT message\r\n                        - Added M and T internal registers\r\n                        - Added N, S, and U breakpoints\r\n                        Revised IBL facility to conform to microcode\r\n                        Added DMA EDT I/O pseudo-opcode\r\n                        Separated DMA SRQ (service request) from FLG\r\n\r\n                        all HP2100 peripherals:\r\n                        - revised to make SFS x,C and SFC x,C work\r\n                        - revised to separate SRQ from FLG\r\n\r\n                        all HP2100 IBL bootable peripherals:\r\n                        - revised boot ROMs to use IBL facility\r\n                        - revised SR values to preserve SR<5:3>\r\n\r\n                        hp2100_lps.c, hp2100_lpt.c: fixed timing\r\n\r\n                        hp2100_dp.c: fixed interpretation of SR<0>\r\n\r\n                        hp2100_dr.c: revised boot code to use IBL algorithm\r\n\r\n                        hp2100_mt.c, hp2100_ms.c: fixed spurious timing error after CLC\r\n                         (Dave Bryan)\r\n\r\n                        hp2100_stddev.c:\r\n                        - fixed input behavior during typeout for RTE-IV\r\n                        - suppressed nulls on TTY output for RTE-IV\r\n\r\n                        hp2100_sys.c: added SFS x,C and SFC x,C to print/parse routines\r\n\r\n                        pdp10_fe.c, pdp11_stddev.c, pdp18b_stddev.c, pdp8_tt.c, vax_stddev.c:\r\n                        - removed SET TTI CTRL-C option\r\n\r\n                        pdp11_tq.c:\r\n                        - fixed bug in reporting write protect (reported by Lyle Bickley)\r\n                        - fixed TK70 model number and media ID (Robert Schaffrath)\r\n\r\n                        pdp11_vh.c: added DHQ11 support (John Dundas)\r\n\r\n                        pdp11_io.c, vax_io.c: fixed DHQ11 autoconfigure (John Dundas)\r\n\r\n                        pdp11_sys.c, vax_sys.c: added DHQ11 support (John Dundas)\r\n\r\n                        vax_cpu.c: fixed bug in DIVBx, DIVWx (reported by Peter Trimmel)\r\n\r\n  0     04-Apr-04       scp.c:\r\n                        - added sim_vm_parse_addr and sim_vm_fprint_addr\r\n                        - added REG_VMAD\r\n                        - moved console logging to SCP\r\n                        - changed sim_fsize to use descriptor rather than name\r\n                        - added global device/unit show modifiers\r\n                        - added device debug support (Dave Hittner)\r\n                        - moved device and unit flags, updated save format\r\n\r\n                        sim_ether.c:\r\n                        - further generalizations (Dave Hittner, Mark Pizzolato)\r\n\r\n                        sim_tmxr.h, sim_tmxr.c:\r\n                        - added tmxr_linemsg\r\n                        - changed TMXR definition to support variable number of lines\r\n\r\n                        sim_libraries:\r\n                        - new console library (sim_console.h, sim_console.c)\r\n                        - new file I/O library (sim_fio.h, sim_fio.c)\r\n                        - new timer library (sim_timer.h, sim_timer.c)\r\n\r\n                        all terminal multiplexors: revised for tmxr library changes\r\n\r\n                        all DECtapes:\r\n                        - added STOP_EOR to enable end-of-reel stop\r\n                        - revised for device debug support\r\n\r\n                        all variable-sized devices: revised for sim_fsize change\r\n\r\n                        eclipse_cpu.c, nova_cpu.c: fixed device enable/disable support\r\n                           (Bruce Ray)\r\n\r\n                        nova_defs.h, nova_sys.c, nova_qty.c:\r\n                        - added QTY and ALM support (Bruce Ray)\r\n\r\n                        id32_cpu.c, id_dp.c: revised for device debug support\r\n\r\n                        lgp: added LGP-30 [LGP-21] simulator\r\n\r\n                        pdp1_sys.c: fixed bug in LOAD (Mark Crispin)\r\n\r\n                        pdp10_mdfp.c:\r\n                        - fixed bug in floating unpack\r\n                        - fixed bug in FIXR (Philip Stone, fixed by Chris Smith)\r\n\r\n                        pdp11_dz.c: added per-line logging\r\n\r\n                        pdp11_rk.c:\r\n                        - added formatting support\r\n                        - added address increment inhibit support\r\n                        - added transfer overrun detection\r\n\r\n                        pdp11_hk.c, pdp11_rp.c: revised for device debug support\r\n\r\n                        pdp11_rq.c: fixed bug in interrupt control (Tom Evans)\r\n\r\n                        pdp11_ry.c: added VAX support\r\n\r\n                        pdp11_tm.c, pdp11_tq.c, pdp11_ts.c: revised for device debug support\r\n\r\n                        pdp11_xu.c: replaced stub with real implementation (Dave Hittner)\r\n\r\n                        pdp18b_cpu.c:\r\n                        - fixed bug in XVM g_mode implementation\r\n                        - fixed bug in PDP-15 indexed address calculation\r\n                        - fixed bug in PDP-15 autoindexed address calculation\r\n\r\n                        pdp18b_fpp.c: fixed bugs in instruction decode\r\n\r\n                        pdp18b_stddev.c:\r\n                        - fixed clock response to CAF\r\n                        - fixed bug in hardware read-in mode bootstrap\r\n\r\n                        pdp18b_sys.c: fixed XVM instruction decoding errors\r\n\r\n                        pdp18b_tt1.c: added support for 1-16 additional terminals\r\n\r\n                        vax_moddef.h, vax_cpu.c, vax_sysdev.c:\r\n                        - added extended physical memory support (Mark Pizzolato)\r\n                        - added RXV21 support\r\n\r\n                        vax_cpu1.c:\r\n                        - added PC read fault in EXTxV\r\n                        - fixed PC write fault in INSV\r\n\r\n   V3.1 revision history\r\n\r\n  0     29-Dec-03       sim_defs.h, scp.c: added output stall status\r\n\r\n                        all console emulators: added output stall support\r\n\r\n                        sim_ether.c (Dave Hittner, Mark Pizzolato, Anders Ahgren):\r\n                        - added Alpha/VMS support\r\n                        - added FreeBSD, Mac OS/X support\r\n                        - added TUN/TAP support\r\n                        - added DECnet duplicate address detection\r\n\r\n                        all memory buffered devices (fixed head disks, floppy disks):\r\n                        - cleaned up buffer copy code\r\n\r\n                        all DECtapes:\r\n                        - fixed reverse checksum in read all\r\n                        - added DECtape off reel message\r\n                        - simplified timing\r\n\r\n                        eclipse_cpu.c (Charles Owen):\r\n                        - added floating point support\r\n                        - added programmable interval timer support\r\n                        - bug fixes\r\n\r\n                        h316_cpu.c:\r\n                        - added instruction history\r\n                        - added DMA/DMC support\r\n                        - added device ENABLE/DISABLE support\r\n                        - change default to HSA option included\r\n\r\n                        h316_dp.c: added moving head disk support\r\n\r\n                        h316_fhd.c: added fixed head disk support\r\n\r\n                        h316_mt.c: added magtape support\r\n\r\n                        h316_sys.c: added new device support\r\n\r\n                        nova_dkp.c (Charles Owen):\r\n                        - fixed bug in flag clear sequence\r\n                        - added diagnostic mode support for disk sizing\r\n\r\n`                       nova_mt.c (Charles Owen):\r\n                        - fixed bug, space operations return record count\r\n                        - fixed bug, reset doesn't cancel rewind\r\n\r\n                        nova_sys.c: added floating point, timer support (Charles Owen)\r\n\r\n                        i1620_cpu.c: fixed bug in branch digit (Dave Babcock)\r\n\r\n                        pdp1_drm.c:\r\n                        - added parallel drum support\r\n                        - fixed bug in serial drum instruction decoding\r\n\r\n                        pdp1_sys.c: added parallel drum support, mnemonics\r\n\r\n                        pdp11_cpu.c:\r\n                        - added autoconfiguration controls\r\n                        - added support for 18b-only Qbus devices\r\n                        - cleaned up addressing/bus definitions\r\n\r\n                        pdp11_rk.c, pdp11_ry.c, pdp11_tm.c, pdp11_hk.c:\r\n                        - added Q18 attribute\r\n\r\n                        pdp11_io.c:\r\n                        - added autoconfiguration controls\r\n                        - fixed bug in I/O configuration (Dave Hittner)\r\n\r\n                        pdp11_rq.c:\r\n                        - revised MB->LBN conversion for greater accuracy\r\n                        - fixed bug with multiple RAUSER drives\r\n\r\n                        pdp11_tc.c: changed to be off by default (base config is Qbus)\r\n\r\n                        pdp11_xq.c (Dave Hittner, Mark Pizzolato):\r\n                        - fixed second controller interrupts\r\n                        - fixed bugs in multicast and promiscuous setup\r\n\r\n                        pdp18b_cpu.c:\r\n                        - added instruction history\r\n                        - fixed PDP-4,-7,-9 autoincrement bug\r\n                        - change PDP-7,-9 default to API option included\r\n\r\n                        pdp8_defs.h, pdp8_sys.c:\r\n                        - added DECtape off reel message\r\n                        - added support for TSC8-75 (ETOS) option\r\n                        - added support for TD8E controller\r\n\r\n                        pdp8_cpu.c: added instruction history\r\n\r\n                        pdp8_rx.c:\r\n                        - fixed bug in RX28 read status (Charles Dickman)\r\n                        - fixed double density write\r\n\r\n                        pdp8_td.c: added TD8E controller\r\n\r\n                        pdp8_tsc.c: added TSC8-75 option\r\n\r\n                        vax_cpu.c:\r\n                        - revised instruction history for dynamic sizing\r\n                        - added autoconfiguration controls\r\n\r\n                        vax_io.c:\r\n                        - added autoconfiguration controls\r\n                        - fixed bug in I/O configuration (Dave Hittner)\r\n\r\n                        id16_cpu.c: revised instruction decoding\r\n\r\n                        id32_cpu.c:\r\n                        - revised instruction decoding\r\n                        - added instruction history\r\n\r\n   V3.0 revision history\r\n\r\n  2     15-Sep-03       scp.c:\r\n                        - fixed end-of-file problem in dep, idep\r\n                        - fixed error on trailing spaces in dep, idep\r\n\r\n                        pdp1_stddev.c\r\n                        - fixed system hang if continue after PTR error\r\n                        - added PTR start/stop functionality\r\n                        - added address switch functionality to PTR BOOT\r\n\r\n                        pdp1_sys.c: added multibank capability to LOAD\r\n\r\n                        pdp18b_cpu.c:\r\n                        - fixed priorities in PDP-15 API (PI between 3 and 4)\r\n                        - fixed sign handling in PDP-15 unsigned mul/div\r\n                        - fixed bug in CAF, must clear API subsystem\r\n\r\n                        i1401_mt.c:\r\n                        - fixed tape read end-of-record handling based on real 1401\r\n                        - added diagnostic read (space forward)\r\n\r\n                        i1620_cpu.c\r\n                        - fixed bug in immediate index add (Michael Short)\r\n\r\n  1     27-Jul-03       pdp1_cpu.c: updated to detect indefinite I/O wait\r\n\r\n                        pdp1_drm.c: fixed incorrect logical, missing activate, break\r\n\r\n                        pdp1_lp.c:\r\n                        - fixed bugs in instruction decoding, overprinting\r\n                        - updated to detect indefinite I/O wait\r\n\r\n                        pdp1_stddev.c:\r\n                        - changed RIM loader to be \"hardware\"\r\n                        - updated to detect indefinite I/O wait\r\n\r\n                        pdp1_sys.c: added block loader format support to LOAD\r\n\r\n                        pdp10_rp.c: fixed bug in read header\r\n\r\n                        pdp11_rq: fixed bug in user disk size (Chaskiel M Grundman)\r\n\r\n                        pdp18b_cpu.c:\r\n                        - added FP15 support\r\n                        - added XVM support\r\n                        - added EAE support to the PDP-4\r\n                        - added PDP-15 \"re-entrancy ECO\"\r\n                        - fixed memory protect/skip interaction\r\n                        - fixed CAF to only reset peripherals\r\n\r\n                        pdp18b_fpp.c: added FP15\r\n\r\n                        pdp18b_lp.c: fixed bug in Type 62 overprinting\r\n\r\n                        pdp18b_rf.c: fixed bug in set size routine\r\n\r\n                        pdp18b_stddev.c:\r\n                        - increased PTP TIME for PDP-15 operating systems\r\n                        - added hardware RIM loader for PDP-7, PDP-9, PDP-15\r\n\r\n                        pdp18b_sys.c: added FP15, KT15, XVM instructions\r\n\r\n                        pdp8b_df.c, pdp8_rf.c: fixed bug in set size routine\r\n\r\n                        hp2100_dr.c:\r\n                        - fixed drum sizes\r\n                        - fixed variable capacity interaction with SAVE/RESTORE\r\n\r\n                        i1401_cpu.c: revised fetch to model hardware more closely\r\n\r\n                        ibm1130: fixed bugs found by APL 1130\r\n\r\n                        nova_dsk.c: fixed bug in set size routine\r\n\r\n                        altairz80: fixed bug in real-time clock on Windows host\r\n\r\n  0     15-Jun-03       scp.c:\r\n                        - added ASSIGN/DEASSIGN\r\n                        - changed RESTORE to detach files\r\n                        - added u5, u6 unit fields\r\n                        - added USE_ADDR64 support\r\n                        - changed some structure fields to unsigned\r\n\r\n                        scp_tty.c: added extended file seek\r\n\r\n                        sim_sock.c: fixed calling sequence in stubs\r\n\r\n                        sim_tape.c:\r\n                        - added E11 and TPC format support\r\n                        - added extended file support\r\n\r\n                        sim_tmxr.c: fixed bug in SHOW CONNECTIONS\r\n\r\n                        all magtapes:\r\n                        - added multiformat support\r\n                        - added extended file support\r\n\r\n                        i1401_cpu.c:\r\n                        - fixed mnemonic, instruction lengths, and reverse\r\n                           scan length check bug for MCS\r\n                        - fixed MCE bug, BS off by 1 if zero suppress\r\n                        - fixed chaining bug, D lost if return to SCP\r\n                        - fixed H branch, branch occurs after continue\r\n                        - added check for invalid 8 character MCW, LCA\r\n\r\n                        i1401_mt.c: fixed load-mode end of record response\r\n\r\n                        nova_dsk.c: fixed variable size interaction with restore\r\n\r\n                        pdp1_dt.c: fixed variable size interaction with restore\r\n\r\n                        pdp10_rp.c: fixed ordering bug in attach\r\n\r\n                        pdp11_cpu.c:\r\n                        - fixed bug in MMR1 update (Tim Stark)\r\n                        - fixed bug in memory size table\r\n\r\n                        pdp11_lp.c, pdp11_rq.c: added extended file support\r\n\r\n                        pdp11_rl.c, pdp11_rp.c, pdp11_ry.c: fixed ordering bug in attach\r\n\r\n                        pdp11_tc.c: fixed variable size interaction with restore\r\n\r\n                        pdp11_xq.c:\r\n                        - corrected interrupts on IE state transition (code by Tom Evans)\r\n                        - added interrupt clear on soft reset (first noted by Bob Supnik)\r\n                        - removed interrupt when setting XL or RL (multiple people)\r\n                        - added SET/SHOW XQ STATS\r\n                        - added SHOW XQ FILTERS\r\n                        - added ability to split received packet into multiple buffers\r\n                        - added explicit runt & giant packet processing\r\n\r\n                        vax_fpa.c:\r\n                        - fixed integer overflow bug in CVTfi\r\n                        - fixed multiple bugs in EMODf\r\n\r\n                        vax_io.c: optimized byte and word DMA routines\r\n\r\n                        vax_sysdev.c:\r\n                        - added calibrated delay to ROM reads (Mark Pizzolato)\r\n                        - fixed calibration problems in interval timer (Mark Pizzolato)\r\n\r\n                        pdp1_dt.c: fixed variable size interaction with restore\r\n\r\n                        pdp18b_dt.c: fixed variable size interaction with restore\r\n\r\n                        pdp18b_mt.c: fixed bug in MTTR\r\n\r\n                        pdp18b_rf.c: fixed variable size interaction with restore\r\n\r\n                        pdp8_df.c, pdp8_rf.c: fixed variable size interaction\r\n                        with restore\r\n\r\n                        pdp8_dt.c: fixed variable size interaction with restore\r\n\r\n                        pdp8_mt.c: fixed bug in SKTR\r\n\r\n                        hp2100_dp.c,hp2100_dq.c:\r\n                        - fixed bug in read status (13210A controller)\r\n                        - fixed bug in seek completion\r\n\r\n                        id_pt.c: fixed type declaration (Mark Pizzolato)\r\n\r\n                        gri_cpu.c: fixed bug in SC queue pointer management\r\n\r\n   V2.10 revision history\r\n\r\n  4     03-Mar-03       scp.c\r\n                        - added .ini startup file capability\r\n                        - added multiple breakpoint actions\r\n                        - added multiple switch evaluation points\r\n                        - fixed bug in multiword deposits to file\r\n\r\n                        sim_tape.c: magtape simulation library\r\n\r\n                        h316_stddev.c: added set line frequency command\r\n\r\n                        hp2100_mt.c, hp2100_ms.c: revised to use magtape library\r\n\r\n                        i1401_mt.c: revised to use magtape library\r\n\r\n                        id_dp.c, id_idc.c: fixed cylinder overflow on writes\r\n\r\n                        id_mt.c:\r\n                        - fixed error handling to stop selector channel\r\n                        - revised to use magtape library\r\n\r\n                        id16_sys.c, id32_sys.c: added relative addressing support\r\n\r\n                        id_uvc.c:\r\n                        - added set frequency command to line frequency clock\r\n                        - improved calibration algorithm for precision clock\r\n\r\n                        nova_clk.c: added set line frequency command\r\n\r\n                        nova_dsk.c: fixed autosizing algorithm\r\n\r\n                        nova_mt.c: revised to use magtape library\r\n\r\n                        pdp10_tu.c: revised to use magtape library\r\n\r\n                        pdp11_cpu.c: fixed bug in MMR1 update (Tim Stark)\r\n\r\n                        pdp11_stddev.c\r\n                        - added set line frequency command\r\n                        - added set ctrl-c command\r\n\r\n                        pdp11_rq.c:\r\n                        - fixed ordering problem in queue process\r\n                        - fixed bug in vector calculation for VAXen\r\n                        - added user defined drive support\r\n\r\n                        pdp11_ry.c: fixed autosizing algorithm\r\n\r\n                        pdp11_tm.c, pdp11_ts.c: revised to use magtape library\r\n\r\n                        pdp11_tq.c:\r\n                        - fixed ordering problem in queue process\r\n                        - fixed overly restrictive test for bad modifiers\r\n                        - fixed bug in vector calculation for VAXen\r\n                        - added variable controller, user defined drive support\r\n                        - revised to use magtape library\r\n\r\n                        pdp18b_cpu.c: fixed three EAE bugs (Hans Pufal)\r\n\r\n                        pdp18b_mt.c:\r\n                        - fixed bugs in BOT error handling, interrupt handling\r\n                        - revised to use magtape library\r\n\r\n                        pdp18b_rf.c:\r\n                        - removed 22nd bit from disk address\r\n                        - fixed autosizing algorithm\r\n\r\n                        pdp18b_stddev.c:\r\n                        - added set line frequency command\r\n                        - added set ctrl-c command\r\n\r\n                        pdp18b_sys.c: fixed FMTASC printouts (Hans Pufal)\r\n\r\n                        pdp8_clk.c: added set line frequency command\r\n\r\n                        pdp8_df.c, pdp8_rf.c, pdp8_rx.c: fixed autosizing algorithm\r\n\r\n                        pdp8_mt.c:\r\n                        - fixed bug in BOT error handling\r\n                        - revised to use magtape library\r\n\r\n                        pdp8_tt.c: added set ctrl-c command\r\n\r\n                        sds_cpu.c: added set line frequency command\r\n\r\n                        sds_mt.c: revised to use magtape library\r\n\r\n                        vax_stddev.c: added set ctrl-c command\r\n\r\n  3     06-Feb-03       scp.c:\r\n                        - added dynamic extension of the breakpoint table\r\n                        - added breakpoint actions\r\n\r\n                        hp2100_cpu.c: fixed last cycle bug in DMA output (found by\r\n                        Mike Gemeny)\r\n\r\n                        hp2100_ipl.c: individual links are full duplex (found by\r\n                        Mike Gemeny)\r\n\r\n                        pdp11_cpu.c: changed R, SP to track PSW<rs,cm> respectively\r\n\r\n                        pdp18b_defs.h, pdp18b_sys.c: added RB09 fixed head disk,\r\n                        LP09 printer\r\n\r\n                        pdp18b_rf.c:\r\n                        - fixed IOT decoding (Hans Pufal)\r\n                        - fixed address overrun logic\r\n                        - added variable number of platters and autosizing\r\n\r\n                        pdp18b_rf.c:\r\n                        - fixed IOT decoding\r\n                        - fixed bug in command initiation\r\n\r\n                        pdp18b_rb.c: new RB09 fixed head disk\r\n\r\n                        pdp18b_lp.c: new LP09 line printer\r\n\r\n                        pdp8_df.c: added variable number of platters and autosizing\r\n\r\n                        pdp8_rf.c: added variable number of platters and autosizing\r\n\r\n                        nova_dsk.c: added variable number of platters and autosizing\r\n\r\n                        id16_cpu.c: fixed bug in SETM, SETMR (Mark Pizzolato)\r\n\r\n  2     15-Jan-03       scp.c:\r\n                        - added dynamic memory size flag and RESTORE support\r\n                        - added EValuate command\r\n                        - added get_ipaddr routine\r\n                        - added ! (OS command) feature (Mark Pizzolato)\r\n                        - added BREAK support to sim_poll_kbd (Mark Pizzolato)\r\n\r\n                        sim_tmxr.c:\r\n                        - fixed bugs in IAC+IAC handling (Mark Pizzolato)\r\n                        - added IAC+BRK handling (Mark Pizzolato)\r\n\r\n                        sim_sock.c:\r\n                        - added use count for Windows start/stop\r\n                        - added sim_connect_sock\r\n\r\n                        pdp1_defs.h, pdp1_cpu.c, pdp1_sys.c, pdp1_drm.c:\r\n                        added Type 24 serial drum\r\n\r\n                        pdp18_defs.h: added PDP-4 drum support\r\n\r\n                        hp2100_cpu.c: added 21MX IOP support\r\n\r\n                        hp2100_ipl.c: added HP interprocessor link support\r\n\r\n                        pdp11_tq.c: fixed bug in transfer end packet length\r\n\r\n                        pdp11_xq.c:\r\n                        - added VMScluster support (thanks to Mark Pizzolato)\r\n                        - added major performance enhancements (thanks to Mark Pizzolato)\r\n                        - added local packet processing\r\n                        - added system id broadcast\r\n\r\n                        pdp11_stddev.c: changed default to 7b (for early UNIX)\r\n\r\n                        vax_cpu.c, vax_io.c, vax_stddev.c, vax_sysdev.c:\r\n                        added console halt capability (Mark Pizzolato)\r\n\r\n                        all terminals and multiplexors: added BREAK support\r\n\r\n  1     21-Nov-02       pdp1_stddev.c: changed typewriter to half duplex\r\n                        (Derek Peschel)\r\n\r\n                        pdp10_tu.c:\r\n                        - fixed bug in bootstrap (reported by Michael Thompson)\r\n                        - fixed bug in read (reported by Harris Newman)\r\n\r\n  0     15-Nov-02       SCP and libraries\r\n                        scp.c:\r\n                        - added Telnet console support\r\n                        - removed VT emulation support\r\n                        - added support for statically buffered devices\r\n                        - added HELP <command>\r\n                        - fixed bugs in set_logon, ssh_break (David Hittner)\r\n                        - added VMS file optimization (Robert Alan Byer)\r\n                        - added quiet mode, DO with parameters, GUI interface,\r\n                           extensible commands (Brian Knittel)\r\n                        - added DEVICE context and flags\r\n                        - added central device enable/disable support\r\n                        - modified SAVE/GET to save and restore flags\r\n                        - modified boot routine calling sequence\r\n                        scp_tty.c:\r\n                        - removed VT emulation support\r\n                        - added sim_os_sleep, renamed sim_poll_kbd, sim_putchar\r\n                        sim_tmxr.c:\r\n                        - modified for Telnet console support\r\n                        - fixed bug in binary (8b) support\r\n                        sim_sock.c: modified for Telnet console support\r\n                        sim_ether.c: new library for Ethernet (David Hittner)\r\n\r\n                        all magtapes:\r\n                        - added support for end of medium\r\n                        - cleaned up BOT handling\r\n\r\n                        all DECtapes: added support for RT11 image file format\r\n\r\n                        most terminals and multiplexors:\r\n                        - added support for 7b vs 8b character processing\r\n\r\n                        PDP-1\r\n                        pdp1_cpu.c, pdp1_sys.c, pdp1_dt.c: added PDP-1 DECtape support\r\n\r\n                        PDP-8\r\n                        pdp8_cpu.c, all peripherals:\r\n                        - added variable device number support\r\n                        - added new device enabled/disable support\r\n                        pdp8_rx.c: added RX28/RX02 support\r\n\r\n                        PDP-11\r\n                        pdp11_defs.h, pdp11_io.c, pdp11_sys.c, all peripherals:\r\n                        - added variable vector support\r\n                        - added new device enable/disable support\r\n                        - added autoconfiguration support\r\n                        all bootstraps: modified to support variable addresses\r\n                        dec_mscp.h, pdp11_tq.c: added TK50 support\r\n                        pdp11_rq.c:\r\n                        - added multicontroller support\r\n                        - fixed bug in HBE error log packet\r\n                        - fixed bug in ATP processing\r\n                        pdp11_ry.c: added RX211/RX02 support\r\n                        pdp11_hk.c: added RK611/RK06/RK07 support\r\n                        pdp11_tq.c: added TMSCP support\r\n                        pdp11_xq.c: added DEQNA/DELQA support (David Hittner)\r\n                        pdp11_pclk.c: added KW11P support\r\n                        pdp11_ts.c:\r\n                        - fixed bug in CTL decoding\r\n                        - fixed bug in extended status XS0_MOT\r\n                        pdp11_stddev.c: removed paper tape to its own module\r\n\r\n                        PDP-18b\r\n                        pdp18b_cpu.c, all peripherals:\r\n                        - added variable device number support\r\n                        - added new device enabled/disabled support\r\n\r\n                        VAX\r\n                        dec_dz.h: fixed bug in number of boards calculation\r\n                        vax_moddefs.h, vax_io.c, vax_sys.c, all peripherals:\r\n                        - added variable vector support\r\n                        - added new device enable/disable support\r\n                        - added autoconfiguration support\r\n                        vax_sys.c:\r\n                        - generalized examine/deposit\r\n                        - added TMSCP, multiple RQDX3, DEQNA/DELQA support\r\n                        vax_stddev.c: removed paper tape, now uses PDP-11 version\r\n                        vax_sysdev.c:\r\n                        - allowed NVR to be attached to file\r\n                        - removed unused variables (David Hittner)\r\n\r\n                        PDP-10\r\n                        pdp10_defs.h, pdp10_ksio.c, all peripherals:\r\n                        - added variable vector support\r\n                        - added new device enable/disable support\r\n                        pdp10_defs.h, pdp10_ksio.c: added support for standard PDP-11\r\n                           peripherals, added RX211 support\r\n                        pdp10_pt.c: rewritten to reference common implementation\r\n\r\n                        Nova, Eclipse:\r\n                        nova_cpu.c, eclipse_cpu.c, all peripherals:\r\n                        - added new device enable/disable support\r\n\r\n                        HP2100\r\n                        hp2100_cpu:\r\n                        - fixed bugs in the EAU, 21MX, DMS, and IOP instructions\r\n                        - fixed bugs in the memory protect and DMS functions\r\n                        - created new options to enable/disable EAU, MPR, DMS\r\n                        - added new device enable/disable support\r\n                        hp2100_fp.c:\r\n                        - recoded to conform to 21MX microcode algorithms\r\n                        hp2100_stddev.c:\r\n                        - fixed bugs in TTY reset, OTA, time base generator\r\n                        - revised BOOT support to conform to RBL loader\r\n                        - added clock calibration\r\n                        hp2100_dp.c:\r\n                        - changed default to 13210A\r\n                        - added BOOT support\r\n                        hp2100_dq.c:\r\n                        - finished incomplete functions, fixed head switching\r\n                        - added BOOT support\r\n                        hp2100_ms.c:\r\n                        - fixed bugs found by diagnostics\r\n                        - added 13183 support\r\n                        - added BOOT support\r\n                        hp2100_mt.c:\r\n                        - fixed bugs found by diagnostics\r\n                        - disabled by default\r\n                        hp2100_lpt.c: implemented 12845A controller\r\n                        hp2100_lps.c:\r\n                        - renamed 12653A controller\r\n                        - added diagnostic mode for MPR, DCPC diagnostics\r\n                        - disabled by default\r\n\r\n                        IBM 1620: first release\r\n\r\n   V2.9 revision history\r\n\r\n  11    20-Jul-02       i1401_mt.c: on read, end of record stores group mark\r\n                           without word mark (Van Snyder)\r\n\r\n                        i1401_dp.c: reworked address generation and checking\r\n\r\n                        vax_cpu.c: added infinite loop detection and halt to\r\n                           boot ROM option (Mark Pizzolato)\r\n\r\n                        vax_fpa.c: changed function names to prevent conflict\r\n                           with C math library\r\n\r\n                        pdp11_cpu.c: fixed bug in MMR0 update logic (from\r\n                           John Dundas)\r\n\r\n                        pdp18b_stddev.c: added \"ASCII mode\" for reader and\r\n                           punch (Hans Pufal)\r\n\r\n                        gri_*.c: added GRI-909 simulator\r\n\r\n                        scp.c: added DO echo, DO exit (Brian Knittel)\r\n\r\n                        scp_tty.c: added Windows priority hacking (from\r\n                           Mark Pizzolato)\r\n\r\n  10    15-Jun-02       scp.c: fixed error checking on calls to fxread/fxwrite\r\n                           (Norm Lastovic)\r\n\r\n                        scp_tty.c, sim_vt.h, sim_vt.c: added VTxxx emulation\r\n                           support for Windows (Fischer Franz)\r\n\r\n                        sim_sock.c: added OS/2 support (Holger Veit)\r\n\r\n                        pdp11_cpu.c: fixed bugs (John Dundas)\r\n                        - added special case for PS<15:12> = 1111 to MFPI\r\n                        - removed special case from MTPI\r\n                        - added masking of relocation adds\r\n\r\n                        i1401_cpu.c:\r\n                        - added multiply/divide\r\n                        - fixed bugs (Van Snyder)\r\n                           o 5 and 7 character H, 7 character doesn't branch\r\n                           o 8 character NOP\r\n                           o 1401-like memory dump\r\n\r\n                        i1401_dp.c: added 1311 disk\r\n\r\n  9     04-May-02       pdp11_rq: fixed bug in polling routine\r\n\r\n  8     03-May-02       scp.c:\r\n                        - changed LOG/NOLOG to SET LOG/NOLOG\r\n                        - added SHOW LOG\r\n                        - added SET VT/NOVT and SHOW VT for VT emulation\r\n\r\n                        sim_sock.h: changed VMS stropt.h include to ioctl.h\r\n\r\n                        vax_cpu.c\r\n                        - added TODR powerup routine to set date, time on boot\r\n                        - fixed exception flows to clear trap request\r\n                        - fixed register logging in autoincrement indexed\r\n\r\n                        vax_stddev.c: added TODR powerup routine\r\n\r\n                        vax_cpu1.c: fixed exception flows to clear trap request\r\n\r\n  7     30-Apr-02       scp.c: fixed bug in clock calibration when (real) clock\r\n                           jumps forward due too far (Jonathan Engdahl)\r\n\r\n                        pdp11_cpu.c: fixed bugs, added features (John Dundas\r\n                           and Wolfgang Helbig)\r\n                        - added HTRAP and BPOK to maintenance register\r\n                        - added trap on kernel HALT if MAINT<HTRAP> set\r\n                        - fixed red zone trap, clear odd address and nxm traps\r\n                        - fixed RTS SP, don't increment restored SP\r\n                        - fixed TSTSET, write dst | 1 rather than prev R0 | 1\r\n                        - fixed DIV, set N=0,Z=1 on div by zero (J11, 11/70)\r\n                        - fixed DIV, set set N=Z=0 on overflow (J11, 11/70)\r\n                        - fixed ASH, ASHC, count = -32 used implementation-\r\n                           dependent 32 bit right shift\r\n                        - fixed illegal instruction test to detect 000010\r\n                        - fixed write-only page test\r\n\r\n                        pdp11_rp.c: fixed SHOW ADDRESS command\r\n\r\n                        vaxmod_defs.h: fixed DZ vector base and number of lines\r\n\r\n                        dec_dz.h:\r\n                        - fixed interrupt acknowledge routines\r\n                        - fixed SHOW ADDRESS command\r\n\r\n                        all magtape routines: added test for badly formed\r\n                           record length (suggested by Jonathan Engdahl)\r\n\r\n  6     18-Apr-02       vax_cpu.c: fixed CASEL condition codes\r\n\r\n                        vax_cpu1.c: fixed vfield pos > 31 test to be unsigned\r\n\r\n                        vax_fpu.c: fixed EDIV overflow test for 0 quotient\r\n\r\n  5     14-Apr-02       vax_cpu1.c:\r\n                        - fixed interrupt, prv_mode set to 0 (Tim Stark)\r\n                        - fixed PROBEx to mask mode to 2b (Kevin Handy)\r\n\r\n  4     1-Apr-02        pdp11_rq.c: fixed bug, reset cleared write protect status\r\n\r\n                        pdp11_ts.c: fixed bug in residual frame count after space\r\n\r\n  3     15-Mar-02       pdp11_defs.h: changed default model to KDJ11A (11/73)\r\n\r\n                        pdp11_rq.c: adjusted delays for M+ timing bugs\r\n\r\n                        hp2100_cpu.c, pdp10_cpu.c, pdp11_cpu.c: tweaked abort\r\n                           code for ANSI setjmp/longjmp compliance\r\n\r\n                        hp2100_cpu.c, hp2100_fp.c, hp2100_stddev.c, hp2100_sys.c:\r\n                           revised to allocate memory dynamically\r\n\r\n  2     01-Mar-02       pdp11_cpu.c:\r\n                        - fixed bugs in CPU registers\r\n                        - fixed double operand evaluation order for M+\r\n\r\n                        pdp11_rq.c: added delays to initialization for\r\n                           RSX11M+ prior to V4.5\r\n\r\n  1     20-Feb-02       scp.c: fixed bug in clock calibration when (real)\r\n                        time runs backwards\r\n\r\n                        pdp11_rq.c: fixed bug in host timeout logic\r\n\r\n                        pdp11_ts.c: fixed bug in message header logic\r\n\r\n                        pdp18b_defs.h, pdp18b_dt.c, pdp18b_sys.c: added\r\n                           PDP-7 DECtape support\r\n\r\n                        hp2100_cpu.c:\r\n                        - added floating point and DMS\r\n                        - fixed bugs in DIV, ASL, ASR, LBT, SBT, CBT, CMW\r\n\r\n                        hp2100_sys.c: added floating point, DMS\r\n\r\n                        hp2100_fp.c: added floating point\r\n\r\n                        ibm1130: added Brian Knittel's IBM 1130 simulator\r\n\r\n  0     30-Jan-02       scp.c:\r\n                        - generalized timer package for multiple timers\r\n                        - added circular register arrays\r\n                        - fixed bugs, line spacing in modifier display\r\n                        - added -e switch to attach\r\n                        - moved device enable/disable to simulators\r\n\r\n                        scp_tty.c: VAX specific fix (Robert Alan Byer)\r\n\r\n                        sim_tmxr.c, sim_tmxr.h:\r\n                        - added tmxr_fstats, tmxr_dscln\r\n                        - renamed tmxr_fstatus to tmxr_fconns\r\n\r\n                        sim_sock.c, sim_sock.h: added VMS support (from\r\n                        Robert Alan Byer)\r\n\r\n                        pdp_dz.h, pdp18b_tt1.c, nova_tt1.c:\r\n                        - added SET DISCONNECT\r\n                        - added SHOW STATISTICS\r\n\r\n                        pdp8_defs.h: fixed bug in interrupt enable initialization\r\n\r\n                        pdp8_ttx.c: rewrote as unified multiplexor\r\n\r\n                        pdp11_cpu.c: fixed calc_MMR1 macro (Robert Alan Byer)\r\n\r\n                        pdp11_stddev.c: fixed bugs in KW11L (John Dundas)\r\n\r\n                        pdp11_rp.c: fixed bug in 18b mode boot\r\n\r\n                        pdp11 bootable I/O devices: fixed register setup at boot\r\n                           exit (Doug Carman)\r\n\r\n                        hp2100_cpu.c:\r\n                        - fixed DMA register tables (Bill McDermith)\r\n                        - fixed SZx,SLx,RSS bug (Bill McDermith)\r\n                        - fixed flop restore logic (Bill McDermith)\r\n\r\n                        hp2100_mt.c: fixed bug on write of last character\r\n\r\n                        hp2100_dq,dr,ms,mux.c: added new disk, magtape, and terminal\r\n                           multiplexor controllers\r\n\r\n                        i1401_cd.c, i1401_mt.c: new zero footprint bootstraps\r\n                           (Van Snyder)\r\n\r\n                        i1401_sys.c: fixed symbolic display of H, NOP with no trailing\r\n                           word mark (Van Snyder)\r\n\r\n                        most CPUs:\r\n                        - replaced OLDPC with PC queue\r\n                        - implemented device enable/disable locally\r\n\r\n   V2.8 revision history\r\n\r\n5       25-Dec-01       scp.c: fixed bug in DO command (John Dundas)\r\n\r\n                        pdp10_cpu.c:\r\n                        - moved trap-in-progress to separate variable\r\n                        - cleaned up declarations\r\n                        - cleaned up volatile state for GNU C longjmp\r\n\r\n                        pdp11_cpu.c: cleaned up declarations\r\n\r\n                        pdp11_rq.c: added RA-class disks\r\n\r\n4       17-Dec-01       pdp11_rq.c: added delayed processing of packets\r\n\r\n3       16-Dec-01       pdp8_cpu.c:\r\n                        - mode A EAE instructions didn't clear GTF\r\n                        - ASR shift count > 24 mis-set GTF\r\n                        - effective shift count == 32 didn't work\r\n\r\n2       07-Dec-01       scp.c: added breakpoint package\r\n\r\n                        all CPU's: revised to use new breakpoint package\r\n\r\n1       05-Dec-01       scp.c: fixed bug in universal register name logic\r\n\r\n0       30-Nov-01       Reorganized simh source and documentation tree\r\n\r\n                        scp: Added DO command, universal registers, extended\r\n                           SET/SHOW logic\r\n\r\n                        pdp11: overhauled PDP-11 for DMA map support, shared\r\n                           sources with VAX, dynamic buffer allocation\r\n\r\n                        18b pdp: overhauled interrupt structure\r\n\r\n                        pdp8: added RL8A\r\n\r\n                        pdp10: fixed two ITS-related bugs (Dave Conroy)\r\n\r\n   V2.7 revision history\r\n\r\npatch   date            module(s) and fix(es)\r\n\r\n15      23-Oct-01       pdp11_rp.c, pdp10_rp.c, pdp10_tu.c: fixed bugs\r\n                           error interrupt handling\r\n\r\n                        pdp10_defs.h, pdp10_ksio.c, pdp10_fe.c, pdp10_fe.c,\r\n                        pdp10_rp.c, pdp10_tu.c: reworked I/O page interface\r\n                           to use symbolic base addresses and lengths\r\n\r\n14      20-Oct-01       dec_dz.h, sim_tmxr_h, sim_tmxr.c: fixed bug in Telnet\r\n                           state handling (Thord Nilson), removed\r\n                           tmxr_getchar, added tmxr_rqln and tmxr_tqln\r\n\r\n13      18-Oct-01       pdp11_tm.c: added stub diagnostic register clock\r\n                           for RSTS/E (Thord Nilson)\r\n\r\n12      15-Oct-01       pdp11_defs.h, pdp11_cpu.c, pdp11_tc.c, pdp11_ts.c,\r\n                           pdp11_rp.c: added operations logging\r\n\r\n11      8-Oct-01        scp.c: added sim_rev.h include and version print\r\n\r\n                        pdp11_cpu.c: fixed bug in interrupt acknowledge,\r\n                           multiple outstanding interrupts caused the lowest\r\n                           rather than the highest to be acknowledged\r\n\r\n10      7-Oct-01        pdp11_stddev.c: added monitor bits (CSR<7>) for full\r\n                           KW11L compatibility, needed for RSTS/E autoconfiguration\r\n\r\n9       6-Oct-01        pdp11_rp.c, pdp10_rp.c, pdp10_tu.c: rewrote interrupt\r\n                           logic from RH11/RH70 schematics, to mimic hardware quirks\r\n\r\n                        dec_dz.c: fixed bug in carrier detect logic, carrier\r\n                           detect was being cleared on next modem poll\r\n\r\n8       4-Oct-01        pdp11_rp.c, pdp10_rp.c, pdp10_tu.c: undid edit of\r\n                           28-Sep-01; real problem was level-sensitive nature of\r\n                           CS1_SC, but CS1_SC can only trigger an interrupt if\r\n                           DONE is set\r\n\r\n7       2-Oct-01        pdp11_rp.c, pdp10_rp.c: CS1_SC is evaluated as a level-\r\n                           sensitive, rather than an edge-sensitive, input to\r\n                           interrupt request\r\n\r\n6       30-Sep-01       pdp11_rp.c, pdp10_rp.c: separated out CS1<5:0> to per-\r\n                           drive registers\r\n\r\n                        pdp10_tu.c: based on above, cleaned up handling of\r\n                           non-existent formatters, fixed non-data transfer\r\n                           commands clearing DONE\r\n\r\n5       28-Sep-01       pdp11_rp.c, pdp10_rp.c, pdp10_tu.c: controller should\r\n                           interrupt if ATA or SC sets when IE is set, was\r\n                           interrupting only if DON = 1 as well\r\n\r\n4       27-Sep-01       pdp11_ts.c:\r\n                        - NXM errors should return TC4 or TC5; were returning TC3\r\n                        - extended features is part of XS2; was returned in XS3\r\n                        - extended characteristics (fifth) word needed for RSTS/E\r\n\r\n                        pdp11_tc.c: stop, stop all do cause an interrupt\r\n\r\n                        dec_dz.h: scanner should find a ready output line, even\r\n                           if there are no connections; needed for RSTS/E autoconfigure\r\n\r\n                        scp.c:\r\n                        - added routine sim_qcount for 1130\r\n                        - added \"simulator exit\" detach routine for 1130\r\n\r\n                        sim_defs.h: added header for sim_qcount\r\n\r\n3       20-Sep-01       pdp11_ts.c: boot code binary was incorrect\r\n\r\n2       19-Sep-01       pdp18b_cpu.c: EAE should interpret initial count of 00\r\n                           as 100\r\n\r\n                        scp.c: modified Macintosh support\r\n\r\n1       17-Sep-01       pdp8_ttx.c: new module for PDP-8 multi-terminal support\r\n\r\n                        pdp18b_tt1.c: modified to use sim_tmxr library\r\n\r\n                        nova_tt1.c: modified to use sim_tmxr library\r\n\r\n                        dec_dz.h: added autodisconnect support\r\n\r\n                        scp.c: removed old multiconsole support\r\n\r\n                        sim_tmxr.c: modified calling sequence for sim_putchar_ln\r\n\r\n                        sim_sock.c: added Macintosh sockets support\r\n*/\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_scp_private.h",
          "type": "blob",
          "size": 21.3212890625,
          "content": "/* sim_scp_private.h: scp library private definitions\r\n\r\n   Copyright (c) 2023, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   MARK PIZZOLATO BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Mark Pizzolato shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Mark Pizzolato.\r\n\r\nThis include file may only be included by code in SCP libraries and should \r\nnever be included directly in any simulator source code modules.\r\n\r\n*/\r\n\r\n#ifndef SIM_SCP_PRIVATE_H_\r\n#define SIM_SCP_PRIVATE_H_    0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"sim_sock.h\"\r\n\r\n#if defined(_WIN32)\r\n#define dlopen(X,Y)    LoadLibraryA((X))\r\n#define dlsym(X,Y)     GetProcAddress((HINSTANCE)(X),(Y))\r\n#define dlclose(X)     FreeLibrary((X))\r\n#define SIM_DLOPEN_EXTENSION DLL\r\n#else /* !defined(_WIN32) */\r\n#if defined(SIM_HAVE_DLOPEN)\r\n#include <dlfcn.h>\r\n#define SIM_DLOPEN_EXTENSION SIM_HAVE_DLOPEN\r\n#endif\r\n#endif /* defined(_WIN32) */\r\n\r\n#if defined(HAVE_PCRE_H)\r\n#include <pcre.h>\r\n#else /* !defined(HAVE_PCRE_H) */\r\n/* Dynamically loaded PCRE support */\r\n#if !defined(PCRE_DYNAMIC_SETUP)\r\n#define PCRE_DYNAMIC_SETUP\r\ntypedef void pcre;\r\ntypedef void pcre_extra;\r\n#ifndef PCRE_INFO_CAPTURECOUNT\r\n#define PCRE_INFO_CAPTURECOUNT 2\r\n#define PCRE_ERROR_NOMATCH          (-1)\r\n#endif\r\n#ifndef PCRE_NOTBOL\r\n#define PCRE_NOTBOL             0x00000080  /*    E D J */\r\n#endif\r\n#ifndef PCRE_CASELESS\r\n#define PCRE_CASELESS           0x00000001  /* C1       */\r\n#endif\r\n/* Pointers to useful PCRE functions */\r\nextern pcre *(*pcre_compile) (const char *, int, const char **, int *, const unsigned char *);\r\nextern const char *(*pcre_version) (void);\r\nextern void (*pcre_free) (void *);\r\nextern int (*pcre_fullinfo) (const pcre *, const pcre_extra *, int, void *);\r\nextern int (*pcre_exec) (const pcre *, const pcre_extra *, const char *, int, int, int, int *, int);\r\n#endif /* PCRE_DYNAMIC_SETUP */\r\n#endif /* HAVE_PCRE_H */\r\n\r\n/* Dynamically loaded PNG support */\r\n#if defined(PNG_H)  /* This symbol has been defined by png.h since png 1.0.7 in 2000 */\r\n#if !defined(PNG_ROUTINE)\r\n#if PNG_LIBPNG_VER < 10600\r\n#define png_const_structrp png_structp\r\n#define png_structrp png_structp\r\n#define png_const_inforp png_infop\r\n#define png_inforp png_infop\r\n#define png_const_colorp png_colorp\r\n#define png_const_bytep png_bytep\r\n#undef PNG_SETJMP_SUPPORTED\r\n#endif\r\n/* Pointers to useful PNG functions */\r\n#if defined(_WIN32) || defined(ALL_DEPENDENCIES)     /* This would be appropriate anytime libpng is specifically listed at link time */\r\n#define PNG_ROUTINE(_type, _name, _args) _type (*p_##_name) _args = &_name;\r\n#else\r\n#define PNG_ROUTINE(_type, _name, _args) _type (*p_##_name) _args;\r\n#endif\r\n#else /* !defined(PNG_ROUTINE) */\r\n#undef PNG_ROUTINE\r\nstatic struct PNG_Entry {\r\n    const char *entry_name;\r\n    void **entry_pointer;\r\n    } libpng_entries[] = {\r\n#define DEFINING_PNG_ARRAY 1\r\n#define PNG_ROUTINE(_type, _name, _args) {#_name, (void **)&p_##_name},\r\n#endif\r\n/* Return the user pointer associated with the I/O functions */\r\nPNG_ROUTINE(png_voidp, png_get_io_ptr, (png_const_structrp png_ptr))\r\n/* Allocate and initialize png_ptr struct for reading, and any other memory. */\r\nPNG_ROUTINE(png_structp, png_create_read_struct,\r\n    (png_const_charp user_png_ver, png_voidp error_ptr,\r\n    png_error_ptr error_fn, png_error_ptr warn_fn))\r\n/* Allocate and initialize png_ptr struct for writing, and any other memory */\r\nPNG_ROUTINE(png_structp, png_create_write_struct,\r\n    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn))\r\n/* Allocate and initialize the info structure */\r\nPNG_ROUTINE(png_infop, png_create_info_struct, (png_const_structrp png_ptr))\r\n/* Free any memory associated with the png_struct and the png_info_structs */\r\nPNG_ROUTINE(void, png_destroy_read_struct, (png_structpp png_ptr_ptr,\r\n    png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr))\r\n/* Free any memory associated with the png_struct and the png_info_structs */\r\nPNG_ROUTINE(void, png_destroy_write_struct, (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr))\r\n/* Replace the default data output functions with a user supplied one(s).\r\n * If buffered output is not used, then output_flush_fn can be set to NULL.\r\n * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time\r\n * output_flush_fn will be ignored (and thus can be NULL).\r\n * It is probably a mistake to use NULL for output_flush_fn if\r\n * write_data_fn is not also NULL unless you have built libpng with\r\n * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's\r\n * default flush function, which uses the standard *FILE structure, will\r\n * be used.\r\n */\r\nPNG_ROUTINE(void, png_set_write_fn, (png_structrp png_ptr, png_voidp io_ptr,\r\n    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn))\r\nPNG_ROUTINE(void, png_set_PLTE, (png_structrp png_ptr,\r\n    png_inforp info_ptr, png_const_colorp palette, int num_palette))\r\nPNG_ROUTINE(void, png_set_IHDR, (png_const_structrp png_ptr,\r\n    png_inforp info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth,\r\n    int color_type, int interlace_method, int compression_method,\r\n    int filter_method))\r\n/* Use blue, green, red order for pixels. */\r\nPNG_ROUTINE(void, png_set_bgr, (png_structrp png_ptr))\r\nPNG_ROUTINE(void, png_write_info,\r\n    (png_structrp png_ptr, png_const_inforp info_ptr))\r\n/* Write a row of image data */\r\nPNG_ROUTINE(void, png_write_row, (png_structrp png_ptr,\r\n    png_const_bytep row))\r\n/* Write the image data */\r\nPNG_ROUTINE(void, png_write_image, (png_structrp png_ptr, png_bytepp image))\r\n/* Write the end of the PNG file. */\r\nPNG_ROUTINE(void, png_write_end, (png_structrp png_ptr,\r\n    png_inforp info_ptr))\r\n#if defined(PNG_SETJMP_SUPPORTED)\r\n/* This function returns the jmp_buf built in to *png_ptr.  It must be\r\n * supplied with an appropriate 'longjmp' function to use on that jmp_buf\r\n * unless the default error function is overridden in which case NULL is\r\n * acceptable.  The size of the jmp_buf is checked against the actual size\r\n * allocated by the library - the call will return NULL on a mismatch\r\n * indicating an ABI mismatch.\r\n */\r\nPNG_ROUTINE(jmp_buf*, png_set_longjmp_fn, (png_structrp png_ptr,\r\n    png_longjmp_ptr longjmp_fn, size_t jmp_buf_size))\r\n#endif /* PNG_SETJMP_SUPPORTED */\r\nPNG_ROUTINE(png_const_charp, png_get_libpng_ver,\r\n    (png_const_structrp png_ptr))\r\n#if defined(ZLIB_VERSION)\r\nPNG_ROUTINE(png_const_charp, zlibVersion,\r\n    (void))\r\n#endif\r\n#if defined(DEFINING_PNG_ARRAY)\r\n    {0},\r\n    };\r\n#undef DEFINING_PNG_ARRAY\r\n#else /* !defined(DEFINING_PNG_ARRAY) */\r\n#undef SIM_SCP_PRIVATE_H_\r\n#include \"sim_scp_private.h\" /* recurse to generate libpng_entries array */\r\n#endif /* !defined(DEFINING_PNG_ARRAY) */\r\n#endif /* PNG_H */\r\n\r\n/* Asynch/Threaded I/O support */\r\n\r\n#if defined (SIM_ASYNCH_IO)\r\n#include <pthread.h>\r\n\r\n#define SIM_ASYNCH_CLOCKS 1\r\n\r\nextern pthread_mutex_t sim_asynch_lock;\r\nextern pthread_cond_t sim_asynch_wake;\r\nextern pthread_mutex_t sim_timer_lock;\r\nextern pthread_cond_t sim_timer_wake;\r\nextern t_bool sim_timer_event_canceled;\r\nextern pthread_t sim_asynch_main_threadid;\r\nextern UNIT * volatile sim_asynch_queue;\r\nextern volatile t_bool sim_idle_wait;\r\nextern int32 sim_asynch_check;\r\nextern int32 sim_asynch_latency;\r\nextern int32 sim_asynch_inst_latency;\r\n\r\n/* Thread local storage */\r\n#if defined(thread_local)\r\n#define AIO_TLS thread_local\r\n#elif (__STDC_VERSION__ >= 201112) && !(defined(__STDC_NO_THREADS__))\r\n#define AIO_TLS _Thread_local\r\n#elif defined(__GNUC__) && !defined(__APPLE__) && !defined(__hpux) && !defined(__OpenBSD__) && !defined(_AIX)\r\n#define AIO_TLS __thread\r\n#elif defined(_MSC_VER)\r\n#define AIO_TLS __declspec(thread)\r\n#else\r\n/* Other compiler environment, then don't worry about thread local storage. */\r\n/* It is primarily used only used in debugging messages */\r\n#define AIO_TLS\r\n#endif\r\n#define AIO_QUEUE_CHECK(que, lock)                              \\\r\n    do {                                                        \\\r\n        UNIT *_cptr;                                            \\\r\n        if (lock)                                               \\\r\n            pthread_mutex_lock (lock);                          \\\r\n        for (_cptr = que;                                       \\\r\n            (_cptr != QUEUE_LIST_END);                          \\\r\n            _cptr = _cptr->next)                                \\\r\n            if (!_cptr->next)                                   \\\r\n                SIM_SCP_ABORT (\"Queue Corruption detected\");    \\\r\n        if (lock)                                               \\\r\n            pthread_mutex_unlock (lock);                        \\\r\n        } while (0)\r\n#define AIO_MAIN_THREAD (pthread_equal ( pthread_self(), sim_asynch_main_threadid ))\r\n#define AIO_LOCK                                                  \\\r\n    pthread_mutex_lock(&sim_asynch_lock)\r\n#define AIO_UNLOCK                                                \\\r\n    pthread_mutex_unlock(&sim_asynch_lock)\r\n#define AIO_IS_ACTIVE(uptr) (((uptr)->a_is_active ? (uptr)->a_is_active (uptr) : FALSE) || ((uptr)->a_next))\r\n\r\n#if defined(__DECC_VER)\r\n#include <builtins>\r\n#if defined(__IA64) || defined(__ia64)\r\n#define USE_AIO_INTRINSICS 1\r\n#endif\r\n#endif\r\n#if defined(_WIN32) || defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4) || defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)\r\n#define USE_AIO_INTRINSICS 1\r\n#endif\r\n/* Provide a way to test both Intrinsic and Lock based queue manipulations  */\r\n/* when both are available on a particular platform                         */\r\n#if defined(DONT_USE_AIO_INTRINSICS) && defined(USE_AIO_INTRINSICS)\r\n#undef USE_AIO_INTRINSICS\r\n#endif\r\n#ifdef USE_AIO_INTRINSICS\r\n/* This approach uses intrinsics to manage access to the link list head     */\r\n/* sim_asynch_queue.  This implementation is a completely lock free design  */\r\n/* which avoids the potential ABA issues.                                   */\r\n#define AIO_QUEUE_MODE \"Lock free asynchronous event queue\"\r\n#define AIO_INIT                                                  \\\r\n    do {                                                          \\\r\n      sim_asynch_main_threadid = pthread_self();                  \\\r\n      /* Empty list/list end uses the point value (void *)1.      \\\r\n         This allows NULL in an entry's a_next pointer to         \\\r\n         indicate that the entry is not currently in any list */  \\\r\n      sim_asynch_queue = QUEUE_LIST_END;                          \\\r\n      } while (0)\r\n#define AIO_CLEANUP                                               \\\r\n    do {                                                          \\\r\n      pthread_mutex_destroy(&sim_asynch_lock);                    \\\r\n      pthread_cond_destroy(&sim_asynch_wake);                     \\\r\n      pthread_mutex_destroy(&sim_timer_lock);                     \\\r\n      pthread_cond_destroy(&sim_timer_wake);                      \\\r\n      } while (0)\r\n#ifdef _WIN32\r\n#elif defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4) || defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)\r\n#define InterlockedCompareExchangePointerAcquire(Destination, Exchange, Comparand) __sync_val_compare_and_swap(Destination, Comparand, Exchange)\r\n#define InterlockedCompareExchangePointerRelease(Destination, Exchange, Comparand) __sync_val_compare_and_swap(Destination, Comparand, Exchange)\r\n#elif defined(__DECC_VER)\r\n#define InterlockedCompareExchangePointerAcquire(Destination, Exchange, Comparand) _InterlockedCompareExchange64_acq(Destination, Exchange, Comparand)\r\n#define InterlockedCompareExchangePointerRelease(Destination, Exchange, Comparand) _InterlockedCompareExchange64_rel(Destination, Exchange, Comparand)\r\n#else\r\n#error \"Implementation of function InterlockedCompareExchangePointer() is needed to build with USE_AIO_INTRINSICS\"\r\n#endif\r\n#define AIO_ILOCK AIO_LOCK\r\n#define AIO_IUNLOCK AIO_UNLOCK\r\n#if defined(_M_IX86) || defined(_M_X64)\r\n#define AIO_QUEUE_VAL ((UNIT *)sim_asynch_queue)\r\n#else /* !defined(_M_IX86) || defined(_M_X64) */\r\n#define AIO_QUEUE_VAL (UNIT *)(InterlockedCompareExchangePointerAcquire((void * volatile *)&sim_asynch_queue, (void *)sim_asynch_queue, NULL))\r\n#endif /* defined(_M_IX86) || defined(_M_X64) */\r\n#define AIO_QUEUE_SET(newval, oldval) ((UNIT *)(InterlockedCompareExchangePointerRelease((void * volatile *)&sim_asynch_queue, (void *)newval, oldval)))\r\n#define AIO_UPDATE_QUEUE sim_aio_update_queue ()\r\n#define AIO_ACTIVATE(caller, uptr, event_time)                                   \\\r\n    if (!pthread_equal ( pthread_self(), sim_asynch_main_threadid )) {           \\\r\n      sim_aio_activate ((ACTIVATE_API)caller, uptr, event_time);                 \\\r\n      return SCPE_OK;                                                            \\\r\n    } else (void)0\r\n#else /* !USE_AIO_INTRINSICS */\r\n/* This approach uses a pthread mutex to manage access to the link list     */\r\n/* head sim_asynch_queue.  It will always work, but may be slower than the  */\r\n/* lock free approach when using USE_AIO_INTRINSICS                         */\r\n#define AIO_QUEUE_MODE \"Lock based asynchronous event queue\"\r\n#define AIO_INIT                                                  \\\r\n    do {                                                          \\\r\n      pthread_mutexattr_t attr;                                   \\\r\n                                                                  \\\r\n      pthread_mutexattr_init (&attr);                             \\\r\n      pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);  \\\r\n      pthread_mutex_init (&sim_asynch_lock, &attr);               \\\r\n      pthread_mutexattr_destroy (&attr);                          \\\r\n      sim_asynch_main_threadid = pthread_self();                  \\\r\n      /* Empty list/list end uses the point value (void *)1.      \\\r\n         This allows NULL in an entry's a_next pointer to         \\\r\n         indicate that the entry is not currently in any list */  \\\r\n      sim_asynch_queue = QUEUE_LIST_END;                          \\\r\n      } while (0)\r\n#define AIO_CLEANUP                                               \\\r\n    do {                                                          \\\r\n      pthread_mutex_destroy(&sim_asynch_lock);                    \\\r\n      pthread_cond_destroy(&sim_asynch_wake);                     \\\r\n      pthread_mutex_destroy(&sim_timer_lock);                     \\\r\n      pthread_cond_destroy(&sim_timer_wake);                      \\\r\n      } while (0)\r\n#define AIO_ILOCK AIO_LOCK\r\n#define AIO_IUNLOCK AIO_UNLOCK\r\n#define AIO_QUEUE_VAL sim_asynch_queue\r\n#define AIO_QUEUE_SET(newval, oldval) ((sim_asynch_queue = newval),oldval)\r\n#define AIO_UPDATE_QUEUE sim_aio_update_queue ()\r\n#define AIO_ACTIVATE(caller, uptr, event_time)                         \\\r\n    if (!pthread_equal ( pthread_self(), sim_asynch_main_threadid )) { \\\r\n      sim_debug (SIM_DBG_AIO_QUEUE, sim_dflt_dev, \"Lock Based Queueing Asynch event for %s after %d %s\\n\", sim_uname(uptr), event_time, sim_vm_interval_units);\\\r\n      AIO_LOCK;                                                        \\\r\n      if (uptr->a_next) {                       /* already queued? */  \\\r\n        uptr->a_activate_call = sim_activate_abs;                      \\\r\n        uptr->a_event_time = MIN (uptr->a_event_time, event_time);     \\\r\n      } else {                                                         \\\r\n        uptr->a_next = sim_asynch_queue;                               \\\r\n        uptr->a_event_time = event_time;                               \\\r\n        uptr->a_activate_call = (ACTIVATE_API)&caller;                 \\\r\n        sim_asynch_queue = uptr;                                       \\\r\n      }                                                                \\\r\n      if (sim_idle_wait) {                                             \\\r\n        if (sim_deb) {  /* only while debug do lock/unlock overhead */ \\\r\n          AIO_UNLOCK;                                                  \\\r\n          sim_debug (TIMER_DBG_IDLE, &sim_timer_dev, \"wakeup from idle due to async event on %s after %d %s\\n\", sim_uname(uptr), event_time, sim_vm_interval_units);\\\r\n          AIO_LOCK;                                                    \\\r\n          }                                                            \\\r\n        pthread_cond_signal (&sim_asynch_wake);                        \\\r\n        }                                                              \\\r\n      AIO_UNLOCK;                                                      \\\r\n      sim_asynch_check = 0;     /* try to force check */               \\\r\n      return SCPE_OK;                                                  \\\r\n    } else (void)0\r\n#endif /* USE_AIO_INTRINSICS */\r\n#define AIO_VALIDATE(uptr)                                             \\\r\n    if (!pthread_equal ( pthread_self(), sim_asynch_main_threadid )) { \\\r\n      SIM_SCP_ABORT (\"Improper thread context for operation detected\");\\\r\n      } else (void)0\r\n#else /* !SIM_ASYNCH_IO */\r\n#define AIO_QUEUE_MODE \"Asynchronous I/O is not available\"\r\n#define AIO_UPDATE_QUEUE\r\n#define AIO_ACTIVATE(caller, uptr, event_time)\r\n#define AIO_VALIDATE(uptr)\r\n#define AIO_INIT\r\n#define AIO_MAIN_THREAD TRUE\r\n#define AIO_LOCK\r\n#define AIO_UNLOCK\r\n#define AIO_CLEANUP\r\n#define AIO_IS_ACTIVE(uptr) FALSE\r\n#define AIO_TLS\r\n#endif /* SIM_ASYNCH_IO */\r\n\r\n/* Private SCP only structures */\r\n\r\n#if !defined(SIM_SCP_PRIVATE_DONT_REPEAT)\r\n#define SIM_SCP_PRIVATE_DONT_REPEAT\r\n\r\n/* Internal SCP declarations */\r\nextern DEVICE sim_scp_dev;\r\n#define SIM_DBG_INIT        0x00200000      /* initialization activities */\r\n\r\n/* Expect rule */\r\n\r\nstruct EXPTAB {\r\n    uint8               *match;                         /* match string */\r\n    uint32              size;                           /* match string size */\r\n    char                *match_pattern;                 /* match pattern for format */\r\n    int32               cnt;                            /* proceed count */\r\n    uint32              after;                          /* delay before halting */\r\n    int32               switches;                       /* flags */\r\n#define EXP_TYP_PERSIST         (SWMASK ('P'))      /* rule persists after match, default is once a rule matches, it is removed */\r\n#define EXP_TYP_CLEARALL        (SWMASK ('C'))      /* clear all rules after matching this rule, default is to once a rule matches, it is removed */\r\n#define EXP_TYP_REGEX           (SWMASK ('R'))      /* rule pattern is a regular expression */\r\n#define EXP_TYP_REGEX_I         (SWMASK ('I'))      /* regular expression pattern matching should be case independent */\r\n#define EXP_TYP_TIME            (SWMASK ('T'))      /* halt delay is in microseconds instead of instructions */\r\n    pcre                *regex;                         /* compiled regular expression */\r\n    int                 re_nsub;                        /* regular expression sub expression count */\r\n    char                *act;                           /* action string */\r\n    };\r\n\r\n/* Expect Context */\r\n\r\nstruct EXPECT {\r\n    DEVICE              *dptr;                          /* Device (for Debug) */\r\n    uint32              dbit;                           /* Debugging Bit */\r\n    EXPTAB              *rules;                         /* match rules */\r\n    int32               size;                           /* count of match rules */\r\n    uint8               *buf;                           /* buffer of output data which has produced */\r\n    uint32              buf_ins;                        /* buffer insertion point for the next output data */\r\n    uint32              buf_size;                       /* buffer size */\r\n    uint32              buf_data;                       /* count of data in buffer */\r\n    };\r\n\r\n/* Send Context */\r\n\r\nstruct SEND {\r\n    uint32              delay;                          /* instruction delay between sent data */\r\n#define SEND_DEFAULT_DELAY  1000                        /* default delay instruction count */\r\n    DEVICE              *dptr;                          /* Device (for Debug) */\r\n    uint32              dbit;                           /* Debugging Bit */\r\n    uint32              after;                          /* instruction delay before sending any data */\r\n    double              next_time;                      /* execution time when next data can be sent */\r\n    uint8               *buffer;                        /* buffer */\r\n    size_t              bufsize;                        /* buffer size */\r\n    int32               insoff;                         /* insert offset */\r\n    int32               extoff;                         /* extra offset */\r\n    };\r\n\r\n#endif /* defined(SIM_SCP_PRIVATE_DONT_REPEAT) */\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_scsi.c",
          "type": "blob",
          "size": 63.134765625,
          "content": "/* sim_scsi.c: SCSI bus simulation\r\n\r\n   Copyright (c) 2019, Matt Burke\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n*/\r\n\r\n#include \"sim_scsi.h\"\r\n#include \"sim_disk.h\"\r\n#include \"sim_tape.h\"\r\n\r\n/* SCSI commands */\r\n\r\n#define CMD_TESTRDY     0x00                            /* test unit ready */\r\n#define CMD_INQUIRY     0x12                            /* inquiry */\r\n#define CMD_REQSENSE    0x03                            /* request sense */\r\n#define CMD_RDBLKLIM    0x05                            /* read block limits */\r\n#define CMD_MODESEL6    0x15                            /* mode select (6 bytes) */\r\n#define CMD_MODESEL10   0x55                            /* mode select (10 bytes) */\r\n#define CMD_MODESENSE6  0x1A                            /* mode sense (6 bytes) */\r\n#define CMD_MODESENSE10 0x5A                            /* mode sense (10 bytes) */\r\n#define CMD_STARTSTOP   0x1B                            /* start/stop unit */\r\n#define CMD_LOADUNLOAD  0x1B                            /* load/unload unit */\r\n#define CMD_PREVALLOW   0x1E                            /* prevent/allow medium removal */\r\n#define CMD_RDCAP       0x25                            /* read capacity */\r\n#define CMD_READ6       0x08                            /* read (6 bytes) */\r\n#define CMD_READ10      0x28                            /* read (10 bytes) */\r\n#define CMD_RDLONG      0x3E                            /* read long */\r\n#define CMD_WRITE6      0x0A                            /* write (6 bytes) */\r\n#define CMD_WRITE10     0x2A                            /* write (10 bytes) */\r\n#define CMD_ERASE       0x19                            /* erase */\r\n#define CMD_RESERVE     0x16                            /* reserve unit */\r\n#define CMD_RELEASE     0x17                            /* release unit */\r\n#define CMD_REWIND      0x01                            /* rewind */\r\n#define CMD_SNDDIAG     0x1D                            /* send diagnostic */\r\n#define CMD_SPACE       0x11                            /* space */\r\n#define CMD_WRFMARK     0x10                            /* write filemarks */\r\n\r\n#define CMD_READ6_TAPE_FIXED    0x01                    /* Fixed record size read */\r\n#define CMD_READ6_TAPE_SILI     0x02                    /* Suppress Incorrect Length Indicator */\r\n\r\n\r\n/* SCSI status codes */\r\n\r\n#define STS_OK          0                               /* good */\r\n#define STS_CHK         2                               /* check condition */\r\n\r\n/* SCSI sense keys */\r\n\r\n#define KEY_OK          0                               /* no sense */\r\n#define KEY_NOTRDY      2                               /* not ready */\r\n#define KEY_ILLREQ      5                               /* illegal request */\r\n#define KEY_PROT        7                               /* data protect */\r\n#define KEY_BLANK       8                               /* blank check */\r\n#define KEY_M_ILI       0x20                            /* incorrect length indicator */\r\n\r\n/* Additional sense codes */\r\n\r\n#define ASC_OK          0                               /* no additional sense information */\r\n#define ASC_INVCOM      0x20                            /* invalid command operation code */\r\n#define ASC_INVCDB      0x24                            /* invalid field in cdb */\r\n#define ASC_NOMEDIA     0x3A                            /* media not present */\r\n\r\n#define PUTL(b,x,v)     b[x] = (v >> 24) & 0xFF; \\\r\n                        b[x+1] = (v >> 16) & 0xFF; \\\r\n                        b[x+2] = (v >> 8) & 0xFF; \\\r\n                        b[x+3] = v & 0xFF\r\n#define PUTW(b,x,v)     b[x] = (v >> 8) & 0xFF; \\\r\n                        b[x+1] = v & 0xFF\r\n#define GETL(b,x)       ((b[x] << 24) | \\\r\n                         (b[x+1] << 16) | \\\r\n                         (b[x+2] << 8) | \\\r\n                          b[x+3])\r\n#define GETW(b,x)       ((b[x] << 8)|b[x+1])\r\n\r\nstatic void _scsi_vdebug (uint32 dbits, SCSI_BUS *bus, const char* fmt, va_list arglist)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nsize_t tfmt_size = strlen (fmt) + strlen (sim_uname (uptr)) + 3;\r\nchar *tfmt = (char *)malloc (tfmt_size);\r\n\r\nsnprintf (tfmt, tfmt_size, \"%s: %s\", sim_uname (uptr), fmt);\r\n_sim_vdebug (dbits, bus->dptr, uptr, tfmt, arglist);\r\nfree (tfmt);\r\n}\r\n\r\nstatic void scsi_debug_cmd (SCSI_BUS *bus, const char* fmt, ...)\r\n{\r\nva_list arglist;\r\n\r\nva_start (arglist, fmt);\r\n_scsi_vdebug (SCSI_DBG_CMD, bus, fmt, arglist);\r\nva_end (arglist);\r\n}\r\n\r\nstatic const char *scsi_phases[] = {\r\n    \"DATO\",                                             /* data out */\r\n    \"DATI\",                                             /* data in */\r\n    \"CMD\",                                              /* command */\r\n    \"STS\",                                              /* status */\r\n    \"\",                                                 /* invalid*/\r\n    \"\",                                                 /* invalid*/\r\n    \"MSGO\",                                             /* message out */\r\n    \"MSGI\"                                              /* message in */\r\n    };\r\n\r\n/* Arbitrate for control of the bus */\r\n\r\nt_bool scsi_arbitrate (SCSI_BUS *bus, uint32 initiator)\r\n{\r\nif (bus->initiator < 0) {                               /* bus free? */\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n       \"Initiator %d won arbitration\\n\", initiator);\r\n    bus->initiator = initiator;                         /* won arbitration */\r\n    return TRUE;\r\n    }\r\nsim_debug (SCSI_DBG_BUS, bus->dptr,\r\n   \"Initiator %d lost arbitration\\n\", initiator);\r\nreturn FALSE;                                           /* lost arbitration */\r\n}\r\n\r\n/* Release control of the bus */\r\n\r\nvoid scsi_release (SCSI_BUS *bus)\r\n{\r\nif (bus->initiator < 0)                                 /* already free? */\r\n    return;\r\nsim_debug (SCSI_DBG_BUS, bus->dptr,\r\n   \"Initiator %d released bus\\n\", bus->initiator);\r\nbus->phase = SCSI_DATO;                                 /* bus free state */\r\nbus->initiator = -1;\r\nbus->target = -1;\r\nbus->buf_t = bus->buf_b = 0;\r\n}\r\n\r\n/* Assert the attention signal */\r\n\r\nvoid scsi_set_atn (SCSI_BUS *bus)\r\n{\r\nsim_debug (SCSI_DBG_BUS, bus->dptr,\r\n   \"Attention signal asserted\\n\");\r\nbus->atn = TRUE;                                        /* assert ATN */\r\nif (bus->target != -1)                                  /* target selected? */\r\n    bus->phase = SCSI_MSGO;                             /* go to msg out phase */\r\n}\r\n\r\n/* Clear the attention signal */\r\n\r\nvoid scsi_release_atn (SCSI_BUS *bus)\r\n{\r\nsim_debug (SCSI_DBG_BUS, bus->dptr,\r\n   \"Attention signal cleared\\n\");\r\nbus->atn = FALSE;                                       /* release ATN */\r\n}\r\n\r\n/* Assert the request signal */\r\n\r\nvoid scsi_set_req (SCSI_BUS *bus)\r\n{\r\nif (bus->req == FALSE) {\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n       \"Request signal asserted\\n\");\r\n    bus->req = TRUE;                                    /* assert REQ */\r\n    }\r\n}\r\n\r\n/* Clear the attention signal */\r\n\r\nvoid scsi_release_req (SCSI_BUS *bus)\r\n{\r\nif (bus->req == TRUE) {\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n       \"Request signal cleared\\n\");\r\n    bus->req = FALSE;                                   /* release REQ */\r\n    }\r\n}\r\n\r\nvoid scsi_set_phase (SCSI_BUS *bus, uint32 phase)\r\n{\r\nif (bus->phase != phase) {\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n       \"Phase changed to %s\\n\", scsi_phases[phase]);\r\n    bus->phase = phase;\r\n    }\r\n}\r\n\r\n/* Attempt to select a target device */\r\n\r\nt_bool scsi_select (SCSI_BUS *bus, uint32 target)\r\n{\r\nUNIT *uptr = bus->dev[target];\r\n\r\nif (bus->initiator < 0) {\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n        \"SCSI: Attempted to select a target without arbitration\\n\");\r\n    return FALSE;\r\n    }\r\nif (bus->target >= 0) {\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n        \"SCSI: Attempted to select a target when a target is already selected\\n\");\r\n    return FALSE;\r\n    }\r\nif ((uptr->flags & UNIT_DIS) == 0) {                    /* unit enabled? */\r\n    sim_debug (SCSI_DBG_BUS, bus->dptr,\r\n       \"Select target %d%s\\n\", target, (bus->atn ? \" with attention\" : \"\"));\r\n    if (bus->atn)\r\n        scsi_set_phase (bus, SCSI_MSGO);                /* message out */\r\n    else\r\n        scsi_set_phase (bus, SCSI_CMD);                 /* command */\r\n    bus->target = target;\r\n    scsi_set_req (bus);                                 /* request data */\r\n    return TRUE;\r\n    }\r\nsim_debug (SCSI_DBG_BUS, bus->dptr,\r\n   \"Select timeout for target %d\\n\", target);\r\nscsi_release (bus);\r\nreturn FALSE;\r\n}\r\n\r\n/* Process a SCSI message */\r\n\r\nuint32 scsi_message (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nuint32 used;\r\n\r\nif (data[0] & 0x80) {                                   /* identify */\r\n    bus->lun = (data[0] & 0xF);\r\n    sim_debug (SCSI_DBG_MSG, bus->dptr,\r\n        \"Identify, LUN = %d\\n\", bus->lun);\r\n    scsi_set_req (bus);                                 /* request data */\r\n    used = 1;                                           /* message length */\r\n    }\r\nelse if (data[0] == 0x1) {                              /* extended message */\r\n    if (len < 2)\r\n        return 0;                                       /* need more */\r\n    if (len < (data[1] + 2u))\r\n        return 0;                                       /* need more */\r\n    sim_debug (SCSI_DBG_MSG, bus->dptr,\r\n        \"Extended message\\n\");\r\n    scsi_set_req (bus);                                 /* request data */\r\n    used = data[1] + 2;                                 /* extended message length */\r\n    }\r\nelse if (data[0] == 0x6) {                              /* abort */\r\n    sim_debug (SCSI_DBG_MSG, bus->dptr,\r\n        \"Abort\\n\");\r\n    scsi_release (bus);                                 /* disconnect */\r\n    used = 1;\r\n    }\r\nelse if (data[0] == 0xc) {\r\n    sim_debug (SCSI_DBG_MSG, bus->dptr,\r\n        \"Bus device reset\\n\");\r\n    scsi_release (bus);                                 /* disconnect */\r\n    used = 1;\r\n    }\r\nelse {\r\n    sim_printf (\"SCSI: Unknown Message %02X\\n\", data[0]);\r\n    used = len;                                         /* discard all bytes */\r\n    }\r\nscsi_set_phase (bus, SCSI_CMD);                         /* command phase next */\r\nreturn used;\r\n}\r\n\r\n/* Send status to the initiator immediately */\r\n\r\nvoid scsi_status (SCSI_BUS *bus, uint32 sts, uint32 key, uint32 asc)\r\n{\r\nbus->sense_key = key;\r\nbus->sense_code = asc;\r\nbus->buf[0] = sts;                                      /* status code */\r\nbus->buf_b = 1;\r\nscsi_set_phase (bus, SCSI_STS);                         /* status phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Send status to the initiator at the end of transaction */\r\n\r\nvoid scsi_status_deferred (SCSI_BUS *bus, uint32 sts, uint32 key, uint32 asc)\r\n{\r\nbus->status = sts;\r\nbus->sense_key = key;\r\nbus->sense_code = asc;\r\n}\r\n\r\n/* Decode the command group to get the command length */\r\n\r\nuint32 scsi_decode_group (uint8 data)\r\n{\r\nuint32 group = (data >> 5) & 0x7;\r\n\r\nswitch (group) {\r\n    case 0:                                             /* 6 byte commands */\r\n        return 6;\r\n\r\n    case 1:                                             /* 10 byte commands */\r\n    case 2:\r\n        return 10;\r\n\r\n    case 3:                                             /* 12 byte commands */\r\n        return 12;\r\n\r\n    default:                                            /* vendor specific or reserved */\r\n        return 0;\r\n        }\r\n}\r\n\r\n/* Translate sim_tape status to SCSI status */\r\n\r\nvoid scsi_tape_status (SCSI_BUS *bus, t_stat st)\r\n{\r\nswitch (st) {\r\n\r\n    case MTSE_OK:\r\n        scsi_status_deferred (bus, STS_OK, KEY_OK, ASC_OK);\r\n        break;\r\n\r\n    case MTSE_TMK:\r\n        scsi_status_deferred (bus, STS_CHK, (KEY_OK | 0x80), ASC_OK);\r\n        bus->sense_qual = 1;                            /* filemark detected */\r\n        break;\r\n\r\n    case MTSE_RECE:                                     /* record in error */\r\n    case MTSE_INVRL:                                    /* invalid rec lnt */\r\n    case MTSE_IOERR:                                    /* IO error */\r\n        scsi_status_deferred (bus, STS_CHK, KEY_OK, ASC_OK);\r\n        break;\r\n\r\n    case MTSE_FMT:\r\n    case MTSE_UNATT:\r\n    case MTSE_EOM:                                      /* end of medium */\r\n        scsi_status_deferred (bus, STS_CHK, (KEY_BLANK | 0x40), ASC_OK);\r\n        break;\r\n\r\n    case MTSE_BOT:                                      /* reverse into BOT */\r\n        scsi_status_deferred (bus, STS_CHK, (KEY_OK | 0x40), ASC_OK);\r\n        break;\r\n\r\n    case MTSE_WRP:                                      /* write protect */\r\n        scsi_status_deferred (bus, STS_CHK, KEY_PROT, ASC_OK);\r\n        break;\r\n        }\r\n\r\nreturn;\r\n}\r\n\r\n/* Limit the transfer count to the allocation specified\r\n   by the SCSI command */\r\n\r\nvoid scsi_check_alloc (SCSI_BUS *bus, uint32 alloc)\r\n{\r\nif (bus->buf_b > alloc)                                 /* check allocation */\r\n    bus->buf_b = alloc;\r\n}\r\n\r\n/* Command - Test Unit Ready */\r\n\r\nvoid scsi_test_ready (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\n\r\nscsi_debug_cmd (bus, \"Test Unit Ready\\n\");\r\n\r\nif (uptr->flags & UNIT_ATT)                             /* attached? */\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);          /* unit is ready */\r\nelse\r\n    scsi_status (bus, STS_CHK, KEY_NOTRDY, ASC_NOMEDIA); /* no media present */\r\n}\r\n\r\n/* Command - Inquiry */\r\n\r\nvoid scsi_inquiry (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\n\r\nscsi_debug_cmd (bus, \"Inquiry\\n\");\r\n\r\nif ((bus->lun != 0) || (uptr->flags & UNIT_DIS)) {\r\n    memset (&bus->buf[0], 0, 36);                       /* no such device or lun */\r\n    bus->buf[0] = 0x7f;\r\n    bus->buf_b += 36;\r\n//    scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCOM);\r\n    }\r\nelse {\r\n    bus->buf[bus->buf_b++] = (uptr->drvtyp->pqual << 5) | uptr->drvtyp->devtype;   /* device class */\r\n#if 0\r\n    if (data[0] & 0x01) {                               /* vital product data */\r\n\r\n        switch (data[2]) {                              /* page code */\r\n\r\n            case 0x00:                                  /* list of supported pages */\r\n                bus->buf[bus->buf_b++] = 0x00;          /* page code */\r\n                bus->buf[bus->buf_b++] = 0x00;          /* reserved */\r\n                bus->buf[bus->buf_b++] = 0x02;          /* page length */\r\n                bus->buf[bus->buf_b++] = 0x00;          /* page 0 is supported. */\r\n                bus->buf[bus->buf_b++] = 0x80;          /* page 0x80 is supported. */\r\n                break;\r\n\r\n            case 0x80:                                  /* unit serial # page */\r\n                bus->buf[bus->buf_b++] = 0x80;          /* page code */\r\n                bus->buf[bus->buf_b++] = 0x00;          /* reserved */\r\n                bus->buf[bus->buf_b++] = 4;             /* serial number length */\r\n                sprintf (&bus->buf[l], \"%-4s\", \"1234\");\r\n                l += 4;\r\n                break;\r\n\r\n            default:\r\n                sim_printf (\"SCSI: Vital product data page %02x not implemented\\n\", data[2]);\r\n                }\r\n        }\r\n#endif\r\n    if (uptr->drvtyp->flags & DRVFL_RMV)\r\n        bus->buf[bus->buf_b++] = 0x80;                  /* removable */\r\n    else\r\n        bus->buf[bus->buf_b++] = 0;                     /* fixed */\r\n    bus->buf[bus->buf_b++] = uptr->drvtyp->scsiver;     /* versions */\r\n    bus->buf[bus->buf_b++] = uptr->drvtyp->scsiver;     /* response data format */\r\n    bus->buf[bus->buf_b++] = 31;                        /* additional length */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    bus->buf[bus->buf_b++] = 0;\r\n\r\n    sprintf ((char *)&bus->buf[bus->buf_b], \"%-8s\", uptr->drvtyp->manufacturer);\r\n    bus->buf_b += 8;\r\n    sprintf ((char *)&bus->buf[bus->buf_b], \"%-16s\", uptr->drvtyp->product);\r\n    bus->buf_b += 16;\r\n    sprintf ((char *)&bus->buf[bus->buf_b], \"%-4s\", uptr->drvtyp->rev);\r\n    bus->buf_b += 4;\r\n    }\r\n\r\nscsi_check_alloc (bus, data[4]);                        /* check allocation */\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Request Sense */\r\n\r\nvoid scsi_req_sense (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Request Sense\\n\");\r\n\r\nbus->buf[bus->buf_b++] = (0x70 | 0x80);                 /* current error, valid */\r\nbus->buf[bus->buf_b++] = 0;                             /* segment # */\r\nbus->buf[bus->buf_b++] = bus->sense_key;                /* sense key */\r\nbus->buf[bus->buf_b++] = (bus->sense_info >> 24) & 0xFF; /* information */\r\nbus->buf[bus->buf_b++] = (bus->sense_info >> 16) & 0xFF;\r\nbus->buf[bus->buf_b++] = (bus->sense_info >> 8) & 0xFF;\r\nbus->buf[bus->buf_b++] = bus->sense_info & 0xFF;\r\nbus->buf[bus->buf_b++] = 10;                            /* additional length */\r\nbus->buf[bus->buf_b++] = 0;                             /* cmd specific info */\r\nbus->buf[bus->buf_b++] = 0;\r\nbus->buf[bus->buf_b++] = 0;\r\nbus->buf[bus->buf_b++] = 0;\r\nbus->buf[bus->buf_b++] = bus->sense_code;               /* ASC */\r\nbus->buf[bus->buf_b++] = bus->sense_qual;               /* ASCQ */\r\nbus->buf[bus->buf_b++] = 0;                             /* FRU code */\r\nbus->buf[bus->buf_b++] = 0;                             /* sense key specific */\r\nbus->buf[bus->buf_b++] = 0;\r\nbus->buf[bus->buf_b++] = 0;\r\n\r\nbus->sense_key = 0;                                     /* no sense */\r\nbus->sense_code = 0;                                    /* no additional sense information */\r\nbus->sense_qual = 0;\r\nbus->sense_info = 0;\r\n\r\nscsi_check_alloc (bus, data[4]);                        /* check allocation */\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Mode Select (6 byte command) */\r\n\r\nvoid scsi_mode_sel6 (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nuint32 blk_size;\r\n\r\nif (bus->phase == SCSI_CMD) {\r\n    scsi_debug_cmd (bus, \"Mode Select(6) - CMD\\n\");\r\n    memcpy (&bus->cmd[0], &data[0], 6);\r\n    bus->buf_b = bus->cmd[4];\r\n    scsi_set_phase (bus, SCSI_DATO);                    /* data out phase next */\r\n    scsi_set_req (bus);                                 /* request data */\r\n    }\r\nelse if (bus->phase == SCSI_DATO) {\r\n    scsi_debug_cmd (bus, \"Mode Select(6) - DATO\\n\");\r\n    if ((DRVFL_GET_IFTYPE(uptr->drvtyp) == SCSI_TAPE) &&\r\n        (uptr->drvtyp->flags & DRVFL_QICTAPE)) {\r\n        blk_size = ((uint32)bus->buf[9]) << 16 |\r\n            ((uint32)bus->buf[10]) << 8 |\r\n            (uint32)bus->buf[11];\r\n        /* QIC tape ONLY supports requesting a fixed block size of\r\n         * 0x200 bytes. Any other block size will cause an illegal\r\n         * request. */\r\n        if (blk_size == uptr->drvtyp->sectsize) {\r\n            scsi_status(bus, STS_OK, KEY_OK, ASC_OK);\r\n            }\r\n        else {\r\n            scsi_status(bus, STS_CHK, KEY_ILLREQ|KEY_M_ILI, ASC_INVCDB);\r\n            }\r\n        }\r\n    else {\r\n        /* Not implemented for disk and non-QIC tape */\r\n        scsi_status(bus, STS_OK, KEY_OK, ASC_OK);\r\n        }\r\n    }\r\n}\r\n\r\n/* Command - Mode Select (10 byte command) */\r\n\r\nvoid scsi_mode_sel10 (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nif (bus->phase == SCSI_CMD) {\r\n    scsi_debug_cmd (bus, \"Mode Select(10) - CMD\\n\");\r\n    memcpy (&bus->cmd[0], &data[0], 10);\r\n    bus->buf_b = GETW (data, 7);\r\n    scsi_set_phase (bus, SCSI_DATO);                    /* data out phase next */\r\n    scsi_set_req (bus);                                 /* request data */\r\n    }\r\nelse if (bus->phase == SCSI_DATO) {\r\n    scsi_debug_cmd (bus, \"Mode Select(6) - DATO\\n\");\r\n    /* Not currently implemented so just return\r\n       good status for now */\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n    }\r\n}\r\n\r\n/* Mode Sense common fields */\r\n\r\nvoid scsi_mode_sense (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nuint32 pc, pctl;\r\n\r\npc = data[2] & 0x3F;                                    /* page code */\r\npctl = (data[2] >> 6) & 0x3F;                           /* page control */\r\n\r\nbus->buf[bus->buf_b++] = 0x00;                          /* density code */\r\nbus->buf[bus->buf_b++] = ((uptr->capac - 1) >> 16) & 0xFF; /* # blocks (23:16) */\r\nbus->buf[bus->buf_b++] = ((uptr->capac - 1) >> 8) & 0xFF; /* # blocks (15:8) */\r\nbus->buf[bus->buf_b++] = (uptr->capac - 1) & 0xFF;      /* # blocks (7:0) */\r\nbus->buf[bus->buf_b++] = 0x00;                          /* reserved */\r\nbus->buf[bus->buf_b++] = (uptr->drvtyp->sectsize >> 16) & 0xFF;\r\nbus->buf[bus->buf_b++] = (uptr->drvtyp->sectsize >> 8) & 0xFF;\r\nbus->buf[bus->buf_b++] = (uptr->drvtyp->sectsize >> 0) & 0xFF;\r\n\r\nif ((pc == 0x1) || (pc == 0x3F)) {\r\n    bus->buf[bus->buf_b++] = 0x1;                       /* R/W error recovery page */\r\n    bus->buf[bus->buf_b++] = 0xA;                       /* page length */\r\n    bus->buf[bus->buf_b++] = 0x26;                      /* TB, PER, DTE */\r\n    bus->buf[bus->buf_b++] = 0x8;                       /* read retry count */\r\n    bus->buf[bus->buf_b++] = 0x78;                      /* correction span */\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0x8;                       /* write retry count */\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    }\r\nif ((pc == 0x2) || (pc == 0x3F)) {\r\n    bus->buf[bus->buf_b++] = 0x2;                       /* disconnect-reconnect page */\r\n    bus->buf[bus->buf_b++] = 0xE;                       /* page length */\r\n    bus->buf[bus->buf_b++] = 0x10;                      /* buffer full ratio */\r\n    bus->buf[bus->buf_b++] = 0x10;                      /* buffer empty ratio */\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    }\r\nif ((pc == 0x3) || (pc == 0x3F)) {\r\n    bus->buf[bus->buf_b++] = 0x3;                       /* format device page */\r\n    bus->buf[bus->buf_b++] = 0x16;                      /* page length */\r\n    bus->buf[bus->buf_b++] = 0;                         /* tracks per zone (15:8) */\r\n    bus->buf[bus->buf_b++] = 1;                         /* tracks per zone (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* alt sectors per zone (15:8) */\r\n    bus->buf[bus->buf_b++] = 1;                         /* alt sectors per zone (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* alt tracks per zone (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* alt tracks per zone (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* alt tracks per unit (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* alt tracks per unit (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* sectors per track (15:8) */\r\n    bus->buf[bus->buf_b++] = 0x21;                      /* sectors per track (7:0) */\r\n    bus->buf[bus->buf_b++] = 0x2;                       /* bytes per sector (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* bytes per sector (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* interleave (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* interleave (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* track skew factor (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* track skew factor (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* cyl skew factor (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* cyl skew factor (7:0) */\r\n    bus->buf[bus->buf_b++] = 0x40;                      /* flags */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    }\r\nif ((pc == 0x4) || (pc == 0x3F)) {\r\n    bus->buf[bus->buf_b++] = 0x4;                       /* rigid disk geometry page */\r\n    bus->buf[bus->buf_b++] = 0x16;                      /* page length */\r\n    bus->buf[bus->buf_b++] = 0;                         /* # cyls (23:16) */\r\n    bus->buf[bus->buf_b++] = 0x4;                       /* # cyls (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* # cyls (7:0) */\r\n    bus->buf[bus->buf_b++] = 0x2;                       /* # heads */\r\n    bus->buf[bus->buf_b++] = 0;                         /* start cyl for write precomp (23:16) */\r\n    bus->buf[bus->buf_b++] = 0x4;                       /* start cyl for write precomp (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* start cyl for write precomp (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* start cyl for reduced write current (23:16) */\r\n    bus->buf[bus->buf_b++] = 0x4;                       /* start cyl for reduced write current (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* start cyl for reduced write current (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* drive step rate (15:8) */\r\n    bus->buf[bus->buf_b++] = 0x1;                       /* drive step rate (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* landing zone cyl (23:16) */\r\n    bus->buf[bus->buf_b++] = 0x4;                       /* landing zone cyl (15:8) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* landing zone cyl (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved, RPL */\r\n    bus->buf[bus->buf_b++] = 0;                         /* rotational offset */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    bus->buf[bus->buf_b++] = 0x1C;                      /* medium rotation rate (15:8) */\r\n    bus->buf[bus->buf_b++] = 0x20;                      /* medium rotation rate (7:0) */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    bus->buf[bus->buf_b++] = 0;                         /* reserved */\r\n    }\r\nif ((pc == 0xA) || (pc == 0x3F)) {\r\n    bus->buf[bus->buf_b++] = 0xA;                       /* control mode page */\r\n    bus->buf[bus->buf_b++] = 0x6;                       /* page length */\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    bus->buf[bus->buf_b++] = 0;\r\n    }\r\n}\r\n\r\n/* Command - Mode Sense (6 byte command) */\r\n\r\nvoid scsi_mode_sense6 (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nuint32 pc, pctl;\r\n\r\nscsi_debug_cmd (bus, \"Mode Sense(6)\\n\");\r\n\r\npc = data[2] & 0x3F;                                    /* page code */\r\npctl = (data[2] >> 6) & 0x3F;                           /* page control */\r\n\r\nif (pc == 0x8) {\r\n    scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCDB);\r\n    return;\r\n    }\r\n\r\nmemset (&bus->buf[0], 0, data[4]);                      /* allocation len */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* mode data length */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* medium type */\r\nif (uptr->drvtyp->devtype == SCSI_CDROM)\r\n    bus->buf[bus->buf_b++] = 0x80;                      /* dev specific param */\r\nelse\r\n    bus->buf[bus->buf_b++] = 0x0;                       /* dev specific param */\r\nbus->buf[bus->buf_b++] = 0x8;                           /* block descriptor len */\r\n\r\nscsi_mode_sense (bus, data, len);                        /* get common data */\r\n\r\nbus->buf[0] = bus->buf_b - 1;                           /* mode data length */\r\n\r\nscsi_check_alloc (bus, data[4]);                        /* check allocation */\r\nscsi_set_phase (bus, SCSI_DATI);\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Mode Sense (10 byte command) */\r\n\r\nvoid scsi_mode_sense10 (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nuint32 pc, pctl;\r\n\r\nscsi_debug_cmd (bus, \"Mode Sense(10)\\n\");\r\n\r\npc = data[2] & 0x3F;                                    /* page code */\r\npctl = (data[2] >> 6) & 0x3F;                           /* page control */\r\n\r\nif (pc == 0x8) {\r\n    scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCDB);\r\n    return;\r\n    }\r\n\r\nmemset (&bus->buf[0], 0, GETW (data, 7));               /* allocation len */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* mode data length (15:8) */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* mode data length (7:0) */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* medium type */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* dev specific param */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* reserved */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* reserved */\r\nbus->buf[bus->buf_b++] = 0x0;                           /* block descriptor len (15:8) */\r\nbus->buf[bus->buf_b++] = 0x8;                           /* block descriptor len (7:0) */\r\n\r\nscsi_mode_sense (bus, data, len);                        /* get common data */\r\n\r\nPUTW (bus->buf, 0, (bus->buf_b - 1));                   /* mode data length */\r\n\r\nscsi_check_alloc (bus, GETW (data, 7));                 /* check allocation */\r\nscsi_set_phase (bus, SCSI_DATI);\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Start/Stop Unit */\r\n\r\nvoid scsi_start_stop (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Start/Stop Unit\\n\");\r\nscsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n}\r\n\r\n/* Command - Prevent/Allow Medium Removal */\r\n\r\nvoid scsi_prev_allow (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Prevent/Allow Medium Removal\\n\");\r\nscsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n}\r\n\r\n/* Command - Read Capacity */\r\n\r\nvoid scsi_read_capacity (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\n\r\nscsi_debug_cmd (bus, \"Read Capacity, pmi = %d\\n\", (data[8] & 0x1));\r\n\r\nif ((uptr->flags & UNIT_ATT) == 0) {                    /* not attached? */\r\n    scsi_status (bus, STS_CHK, KEY_NOTRDY, ASC_NOMEDIA);\r\n    return;\r\n    }\r\n\r\nPUTL (bus->buf, 0, (uptr->capac - 1));                  /* LBN of last block is 1 less than # blocks */\r\nPUTL (bus->buf, 4, uptr->drvtyp->sectsize);             /* block size */\r\n\r\nbus->buf_b = 8;\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Read (6 byte command), disk version */\r\n\r\nvoid scsi_read6_disk (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_lba lba;\r\nt_seccnt sects, sectsread;\r\nt_stat r;\r\n\r\nlba = GETW (data, 2) | ((data[1] & 0x1F) << 16);\r\nsects = data[4];\r\nif (sects == 0)\r\n    sects = 256;\r\n\r\nscsi_debug_cmd (bus, \"Read(6) lba %d blks %d\\n\", lba, sects);\r\n\r\nif (uptr->flags & UNIT_ATT)\r\n    r = sim_disk_rdsect (uptr, lba, &bus->buf[0], &sectsread, sects);\r\nelse {\r\n    memset (&bus->buf[0], 0, (sects * uptr->drvtyp->sectsize));\r\n    sectsread = sects;\r\n    }\r\n\r\nbus->buf_b = (sectsread * uptr->drvtyp->sectsize);\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Read (6 byte command), tape version */\r\n\r\nvoid scsi_read6_tape (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_seccnt sects, sectsread, new_buf_b;\r\nt_stat r;\r\nuint32 i;\r\n\r\nif ((data[1] & 0x3) == 0x3) {                           /* SILI and FIXED? */\r\n    scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCDB);\r\n    return;\r\n    }\r\n\r\nsects = GETW (data, 3) | (data[2] << 16);\r\nnew_buf_b = 0;\r\nsectsread = 0;\r\n\r\nif (sects == 0) {                                       /* no data to read */\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n    return;\r\n    }\r\n\r\nscsi_debug_cmd (bus, \"Read(6) blks %d fixed %d\\n\", sects, (data[1] & 0x1));\r\n\r\nif (uptr->flags & UNIT_ATT) {\r\n    if (uptr->drvtyp->flags & DRVFL_QICTAPE) {\r\n        if (data[1] & 0x1) {\r\n            /* If this is a QIC tape drive and bit 0 is set, this is a\r\n               request to read multiple fixed-length blocks. */\r\n            scsi_debug_cmd(bus, \"QIC in fixed block mode\\n\");\r\n            for (i = 0; i < sects; i++) {\r\n                r = sim_tape_rdrecf(uptr, &bus->buf[new_buf_b], &sectsread, uptr->drvtyp->sectsize);\r\n                scsi_debug_cmd(bus, \"Read tape blk %d, read %d, r = %d\\n\",\r\n                               sects, sectsread, r);\r\n                if (r == MTSE_OK) {\r\n                    new_buf_b += uptr->drvtyp->sectsize;\r\n                } else {\r\n                    scsi_tape_status(bus, r);\r\n                    scsi_status(bus, bus->status, bus->sense_key, bus->sense_code);\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            /* QIC drives respond with an illegal request when the\r\n               request does not specify fixed-block mode */\r\n            scsi_debug_cmd(bus, \"QIC not in fixed block mode, invalid command\\n\");\r\n            scsi_status(bus, STS_CHK, KEY_ILLREQ|KEY_M_ILI, ASC_INVCDB);\r\n            return;\r\n            }\r\n        }\r\n    else {\r\n        /* Otherwise, this is a normal streaming tape read */\r\n        if (data[1] & 0x1) {\r\n            r = sim_tape_rdrecf (uptr, &bus->buf[0], &sectsread, (sects * uptr->drvtyp->sectsize));\r\n            scsi_debug_cmd (bus, \"Read tape blk %d, read %d, r = %d\\n\", sects, sectsread, r);\r\n            }\r\n        else {\r\n            r = sim_tape_rdrecf (uptr, &bus->buf[0], &sectsread, sects);\r\n            scsi_debug_cmd (bus, \"Read tape max %d, read %d, r = %d\\n\", sects, sectsread, r);\r\n            if (r == MTSE_INVRL) {                          /* overlength condition */\r\n                scsi_debug_cmd (bus, \"Overlength\\n\");\r\n                if ((data[1] & 0x2) && (uptr->drvtyp->sectsize == 0)) { /* SILI set */\r\n                    scsi_debug_cmd (bus, \"SILI set\\n\");\r\n                    }\r\n                else {\r\n                    scsi_debug_cmd (bus, \"SILI not set - check condition\\n\");\r\n                    scsi_status (bus, STS_CHK, (KEY_OK | KEY_M_ILI), ASC_OK);\r\n                    return;\r\n                    }\r\n                }\r\n            else if ((r == MTSE_OK) && (sectsread < sects)) {  /* underlength condition */\r\n                scsi_debug_cmd (bus, \"Underlength\\n\");\r\n                if (data[1] & 0x2) {                        /* SILI set */\r\n                    scsi_debug_cmd (bus, \"SILI set\\n\");\r\n                    }\r\n                else {\r\n                    scsi_debug_cmd (bus, \"SILI not set - check condition\\n\");\r\n                    scsi_status_deferred (bus, STS_CHK, (KEY_OK | KEY_M_ILI), ASC_OK);\r\n                    bus->sense_info = (sects - sectsread);\r\n                    }\r\n                }\r\n            }\r\n        new_buf_b = sectsread;\r\n        }\r\n\r\n    if (r != MTSE_OK) {\r\n        scsi_debug_cmd (bus, \"Read error, r = %d\\n\", r);\r\n        }\r\n        scsi_tape_status (bus, r);\r\n    }\r\nelse {\r\n    memset (&bus->buf[0], 0, (sects * uptr->drvtyp->sectsize));\r\n    sectsread = (sects * uptr->drvtyp->sectsize);\r\n    }\r\n\r\nif (sectsread > 0) {\r\n    bus->buf_b = new_buf_b;\r\n    scsi_set_phase (bus, SCSI_DATI);                    /* data in phase next */\r\n    }\r\nelse {\r\n    bus->buf[bus->buf_b++] = bus->status;               /* status code */\r\n    scsi_set_phase (bus, SCSI_STS);                     /* status phase next */\r\n    }\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Read (10 byte command), disk version */\r\n\r\nvoid scsi_read10_disk (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_lba lba;\r\nt_seccnt sects, sectsread;\r\nt_stat r;\r\n\r\nlba = GETL (data, 2);\r\nsects = GETW (data, 7);\r\n\r\nscsi_debug_cmd (bus, \"Read(10) lba %d blks %d\\n\", lba, sects);\r\n\r\nif (sects == 0) {                                       /* no data to read */\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n    return;\r\n    }\r\n\r\nif (uptr->flags & UNIT_ATT)\r\n    r = sim_disk_rdsect (uptr, lba, &bus->buf[0], &sectsread, sects);\r\nelse {\r\n    memset (&bus->buf[0], 0, (sects * uptr->drvtyp->sectsize));\r\n    sectsread = sects;\r\n    }\r\n\r\nbus->buf_b = (sectsread * uptr->drvtyp->sectsize);\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Read Long */\r\n/* This command is needed by VMS for host-based volume shadowing */\r\n/* See DKDRIVER */\r\n\r\nvoid scsi_read_long (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_lba lba;\r\nt_seccnt sects, sectsread;\r\nt_stat r;\r\n\r\nlba = GETL (data, 2);\r\nsects = GETW (data, 7);\r\n\r\nscsi_debug_cmd (bus, \"Read Long lba %d bytes %d\\n\", lba, sects);\r\n\r\nif (uptr->flags & UNIT_ATT)\r\n    r = sim_disk_rdsect (uptr, lba, &bus->buf[0], &sectsread, ((sects >> 9) + 1));\r\nelse {\r\n    memset (&bus->buf[0], 0, sects);\r\n    }\r\n\r\nbus->buf_b = sects;\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Write (6 byte command), disk version */\r\n\r\nvoid scsi_write6_disk (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_lba lba;\r\nt_seccnt sects, sectswritten;\r\nt_stat r;\r\n\r\nif (bus->phase == SCSI_CMD) {\r\n    scsi_debug_cmd (bus, \"Write(6) - CMD\\n\");\r\n    memcpy (&bus->cmd[0], &data[0], 6);\r\n    sects = bus->cmd[4];\r\n    if (sects == 0) sects = 256;\r\n    bus->buf_b = (sects * uptr->drvtyp->sectsize);\r\n    scsi_set_phase (bus, SCSI_DATO);                    /* data out phase next */\r\n    scsi_set_req (bus);                                 /* request data */\r\n    }\r\nelse if (bus->phase == SCSI_DATO) {\r\n    sects = bus->cmd[4];\r\n    if (sects == 0) sects = 256;\r\n    lba = GETW (bus->cmd, 2) | ((bus->cmd[1] & 0x1F) << 16);\r\n    scsi_debug_cmd (bus, \"Write(6) - DATO, lba %d bytes %d\\n\", lba, sects);\r\n\r\n    if (uptr->flags & UNIT_ATT)\r\n        r = sim_disk_wrsect (uptr, lba, &bus->buf[0], &sectswritten, sects);\r\n\r\n    memset (&bus->cmd[0], 0, 10);\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n    }\r\n}\r\n\r\n/* Command - Write (6 byte command), tape version */\r\n\r\nvoid scsi_write6_tape (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_seccnt sects;\r\nt_stat r;\r\n\r\nif (bus->phase == SCSI_CMD) {\r\n    scsi_debug_cmd (bus, \"Write(6) - CMD\\n\");\r\n    memcpy (&bus->cmd[0], &data[0], 6);                 /* save current cmd */\r\n    sects = GETW (bus->cmd, 3) | (bus->cmd[2] << 16);\r\n    if (data[1] & 0x1)                                  /* FIXED */\r\n        sects = sects * uptr->drvtyp->sectsize;\r\n    bus->buf_b = sects;\r\n    scsi_set_phase (bus, SCSI_DATO);                    /* data out phase next */\r\n    scsi_set_req (bus);                                 /* request data */\r\n    }\r\nelse if (bus->phase == SCSI_DATO) {\r\n    sects = GETW (bus->cmd, 3) | (bus->cmd[2] << 16);\r\n    if (data[1] & 0x1)                                  /* FIXED */\r\n        sects = sects * uptr->drvtyp->sectsize;\r\n    scsi_debug_cmd (bus, \"Write(6) - DATO, bytes %d\\n\", sects);\r\n\r\n    if (uptr->flags & UNIT_ATT) {\r\n        r = sim_tape_wrrecf (uptr, &bus->buf[0], sects);\r\n        scsi_debug_cmd (bus, \"Write(6) - DATO, r = %d\\n\", r);\r\n        scsi_tape_status (bus, r);                      /* translate status */\r\n        }\r\n    else\r\n        scsi_status_deferred (bus, STS_OK, KEY_OK, ASC_OK);\r\n\r\n    memset (&bus->cmd[0], 0, 10);                       /* clear current cmd */\r\n    scsi_status (bus, bus->status, bus->sense_key, bus->sense_code);\r\n    }\r\n}\r\n\r\n/* Command - Write (10 byte command), disk version */\r\n\r\nvoid scsi_write10_disk (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_lba lba;\r\nt_seccnt sects, sectswritten;\r\nt_stat r;\r\n\r\nif (bus->phase == SCSI_CMD) {\r\n    scsi_debug_cmd (bus, \"Write(10) - CMD\\n\");\r\n    memcpy (&bus->cmd[0], &data[0], 10);\r\n    sects = GETW (bus->cmd, 7);\r\n    if (sects == 0)                                     /* no data to write */\r\n        scsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n    else {\r\n        bus->buf_b = (sects * uptr->drvtyp->sectsize);\r\n        scsi_set_phase (bus, SCSI_DATO);                /* data out phase next */\r\n        scsi_set_req (bus);                             /* request data */\r\n        }\r\n    }\r\nelse if (bus->phase == SCSI_DATO) {\r\n    sects = GETW (bus->cmd, 7);\r\n    lba = GETL (bus->cmd, 2);\r\n    scsi_debug_cmd (bus, \"Write(10) - DATO, lba %d bytes %d\\n\", lba, sects);\r\n\r\n    if (uptr->flags & UNIT_ATT)\r\n        r = sim_disk_wrsect (uptr, lba, &bus->buf[0], &sectswritten, sects);\r\n\r\n    memset (&bus->cmd[0], 0, 10);\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);\r\n    }\r\n}\r\n\r\n/* Command - Erase */\r\n\r\nvoid scsi_erase (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_stat r;\r\n\r\nscsi_debug_cmd (bus, \"Erase\\n\");\r\n\r\nif (data[1] & 0x1)                                      /* LONG bit set? */\r\n    r = sim_tape_wreom (uptr);                          /* erase to EOT */\r\nelse\r\n    r = sim_tape_wrgap (uptr, uptr->drvtyp->gaplen);    /* write gap */\r\n\r\nscsi_tape_status (bus, r);\r\nscsi_status (bus, bus->status, bus->sense_key, bus->sense_code);\r\n}\r\n\r\n/* Command - Reserve Unit */\r\n\r\nvoid scsi_reserve_unit (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Reserve Unit\\n\");\r\nscsi_status (bus, STS_OK, KEY_OK, ASC_OK);              /* GOOD status */\r\n}\r\n\r\n/* Command - Release Unit */\r\n\r\nvoid scsi_release_unit (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Release Unit\\n\");\r\nscsi_status (bus, STS_OK, KEY_OK, ASC_OK);              /* GOOD status */\r\n}\r\n\r\n/* Command - Rewind */\r\n\r\nvoid scsi_rewind (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nt_stat r;\r\n\r\nscsi_debug_cmd (bus, \"Rewind\\n\");\r\n\r\nr = sim_tape_rewind (uptr);\r\n\r\nscsi_tape_status (bus, r);\r\nscsi_status (bus, bus->status, bus->sense_key, bus->sense_code);\r\n}\r\n\r\n/* Command - Send Diagnostic */\r\n\r\nvoid scsi_send_diag (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Send Diagnostic\\n\");\r\n\r\nif (data[1] & 0x4)                                      /* selftest */\r\n    scsi_status (bus, STS_OK, KEY_OK, ASC_OK);          /* GOOD status */\r\nelse\r\n    scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCDB);\r\n}\r\n\r\n/* Command - Space */\r\n\r\nvoid scsi_space (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nuint32 code, skipped;\r\nt_seccnt sects;\r\nt_stat r = 0;\r\n\r\ncode = data[1] & 0x7;\r\nsects = GETW (data, 3) | (data[2] << 16);\r\n\r\nscsi_debug_cmd (bus, \"Space %d %s\\n\", sects, ((code == 0) ? \"records\" : \"files\"));\r\n\r\nswitch (code) {\r\n\r\n    case 0:                                             /* blocks */\r\n        if (sects & 0x800000) {                         /* reverse */\r\n            sects = 0x1000000 - sects;\r\n            r = sim_tape_sprecsr (uptr, sects, &skipped);\r\n            }\r\n        else                                            /* forwards */\r\n            r = sim_tape_sprecsf (uptr, sects, &skipped);\r\n        break;\r\n\r\n    case 1:                                             /* filemarks */\r\n        if (sects & 0x800000) {                         /* reverse */\r\n            sects = 0x1000000 - sects;\r\n            r = sim_tape_spfiler (uptr, sects, &skipped);\r\n            }\r\n        else                                            /* forwards */\r\n            r = sim_tape_spfilef (uptr, sects, &skipped);\r\n        break;\r\n        }\r\n\r\nscsi_tape_status (bus, r);\r\nbus->buf[bus->buf_b++] = bus->status;                   /* status code */\r\nscsi_set_phase (bus, SCSI_STS);                         /* status phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Write Filemarks */\r\n\r\nvoid scsi_wrfmark (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nuint32 i;\r\nt_seccnt sects;\r\nt_stat r;\r\n\r\nscsi_debug_cmd (bus, \"Write Filemarks\\n\");\r\n\r\nsects = GETW (data, 3) | (data[2] << 16);\r\n\r\nfor (i = 0; i < sects; i++) {\r\n    r = sim_tape_wrtmk (uptr);\r\n    if (r != MTSE_OK) break;\r\n    }\r\n\r\nscsi_tape_status (bus, r);\r\nbus->buf[bus->buf_b++] = bus->status;                   /* status code */\r\nscsi_set_phase (bus, SCSI_STS);                         /* status phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command - Read Block Limits */\r\n\r\nvoid scsi_read_blklim (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nscsi_debug_cmd (bus, \"Read Block Limits\\n\");\r\n\r\nbus->buf[bus->buf_b++] = 0x00;                          /* reserved */\r\nbus->buf[bus->buf_b++] = (MTR_MAXLEN >> 16) & 0xFF;     /* max block length (23:16) */\r\nbus->buf[bus->buf_b++] = (MTR_MAXLEN >> 8) & 0xFF;      /* max block length (15:8) */\r\nbus->buf[bus->buf_b++] = MTR_MAXLEN & 0xFF;             /* max block length (7:0) */\r\nbus->buf[bus->buf_b++] = 0x00;                          /* min block length (15:8) */\r\nbus->buf[bus->buf_b++] = 0x01;                          /* min block length (7:0) */\r\nscsi_set_phase (bus, SCSI_DATI);                        /* data in phase next */\r\nscsi_set_req (bus);                                     /* request to send data */\r\n}\r\n\r\n/* Command Load/Unload Unit */\r\n\r\nvoid scsi_load_unload (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\n\r\nscsi_debug_cmd (bus, \"Load/Unload\\n\");\r\n\r\nif ((data[4] & 0x5) == 0x5) {                           /* EOT & Load? */\r\n    scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCDB); /* invalid combination */\r\n    return;\r\n    }\r\nif ((data[4] & 0x1) == 0)\r\n    sim_tape_detach (uptr);                             /* unload */\r\nscsi_status (bus, STS_OK, KEY_OK, ASC_OK);              /* GOOD status */\r\n}\r\n\r\n/* Process a SCSI command for a direct-access device */\r\n\r\nvoid scsi_disk_command (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nswitch (data[0]) {\r\n\r\n    /* FIXME: FORMAT UNIT */\r\n\r\n    case CMD_INQUIRY:                                   /* mandatory */\r\n        scsi_inquiry (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESEL6:                                  /* optional */\r\n        scsi_mode_sel6 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESEL10:                                 /* optional */\r\n        scsi_mode_sel10 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESENSE6:                                /* optional */\r\n        scsi_mode_sense6 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESENSE10:                               /* optional */\r\n        scsi_mode_sense10 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_PREVALLOW:                                 /* optional */\r\n        scsi_prev_allow (bus, data, len);\r\n        break;\r\n\r\n    case CMD_READ6:                                     /* mandatory */\r\n        scsi_read6_disk (bus, data, len);\r\n        break;\r\n\r\n    case CMD_READ10:                                    /* mandatory */\r\n        scsi_read10_disk (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RDCAP:                                     /* mandatory */\r\n        scsi_read_capacity (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RDLONG:                                    /* optional - needed by VMS volume shadowing */\r\n        scsi_read_long (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RELEASE:                                   /* mandatory */\r\n        scsi_release_unit (bus, data, len);\r\n        break;\r\n\r\n    case CMD_REQSENSE:                                  /* mandatory */\r\n        scsi_req_sense (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RESERVE:                                   /* mandatory */\r\n        scsi_reserve_unit (bus, data, len);\r\n        break;\r\n\r\n    case CMD_SNDDIAG:                                   /* mandatory */\r\n        scsi_send_diag (bus, data, len);\r\n        break;\r\n\r\n    case CMD_STARTSTOP:                                 /* optional */\r\n        scsi_start_stop (bus, data, len);\r\n        break;\r\n\r\n    case CMD_TESTRDY:                                   /* mandatory */\r\n        scsi_test_ready (bus, data, len);\r\n        break;\r\n\r\n    case CMD_WRITE6:                                    /* optional */\r\n        scsi_write6_disk (bus, data, len);\r\n        break;\r\n\r\n    case CMD_WRITE10:                                   /* optional */\r\n        scsi_write10_disk (bus, data, len);\r\n        break;\r\n\r\n    default:\r\n        sim_printf (\"SCSI: unknown disk command %02X\\n\", data[0]);\r\n        scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCOM);\r\n        break;\r\n        }\r\n}\r\n\r\n/* Process a SCSI command for a sequential-access device */\r\n\r\nvoid scsi_tape_command (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nswitch (data[0]) {\r\n\r\n    case CMD_ERASE:                                     /* mandatory */\r\n        scsi_erase (bus, data, len);\r\n        break;\r\n\r\n    case CMD_INQUIRY:                                   /* mandatory */\r\n        scsi_inquiry (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESEL6:                                  /* mandatory */\r\n        scsi_mode_sel6 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESEL10:                                 /* optional */\r\n        scsi_mode_sel10 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESENSE6:                                /* mandatory */\r\n        scsi_mode_sense6 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESENSE10:                               /* optional */\r\n        scsi_mode_sense10 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_PREVALLOW:                                 /* optional */\r\n        scsi_prev_allow (bus, data, len);\r\n        break;\r\n\r\n    case CMD_READ6:                                     /* mandatory */\r\n        scsi_read6_tape (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RDBLKLIM:                                  /* mandatory */\r\n        scsi_read_blklim (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RELEASE:                                   /* mandatory */\r\n        scsi_release_unit (bus, data, len);\r\n        break;\r\n\r\n    case CMD_REQSENSE:                                  /* mandatory */\r\n        scsi_req_sense (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RESERVE:                                   /* mandatory */\r\n        scsi_reserve_unit (bus, data, len);\r\n        break;\r\n\r\n    case CMD_REWIND:                                    /* mandatory */\r\n        scsi_rewind (bus, data, len);\r\n        break;\r\n\r\n    case CMD_SNDDIAG:                                   /* mandatory */\r\n        scsi_send_diag (bus, data, len);\r\n        break;\r\n\r\n    case CMD_SPACE:                                     /* mandatory */\r\n        scsi_space (bus, data, len);\r\n        break;\r\n\r\n    case CMD_LOADUNLOAD:                                /* optional */\r\n        scsi_load_unload (bus, data, len);\r\n        break;\r\n\r\n    case CMD_TESTRDY:                                   /* mandatory */\r\n        scsi_test_ready (bus, data, len);\r\n        break;\r\n\r\n    case CMD_WRITE6:                                    /* mandatory */\r\n        scsi_write6_tape (bus, data, len);\r\n        break;\r\n\r\n    case CMD_WRFMARK:                                   /* mandatory */\r\n        scsi_wrfmark (bus, data, len);\r\n        break;\r\n\r\n    default:\r\n        sim_printf (\"SCSI: unknown tape command %02X\\n\", data[0]);\r\n        scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCOM);\r\n        break;\r\n        }\r\n}\r\n\r\n/* Process a SCSI command for a CD-ROM device */\r\n\r\nvoid scsi_cdrom_command (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nswitch (data[0]) {\r\n\r\n    case CMD_INQUIRY:                                   /* mandatory */\r\n        scsi_inquiry (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESEL6:                                  /* optional */\r\n        scsi_mode_sel6 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESEL10:                                 /* optional */\r\n        scsi_mode_sel10 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESENSE6:                                /* optional */\r\n        scsi_mode_sense6 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_MODESENSE10:                               /* optional */\r\n        scsi_mode_sense10 (bus, data, len);\r\n        break;\r\n\r\n    case CMD_PREVALLOW:                                 /* optional */\r\n        scsi_prev_allow (bus, data, len);\r\n        break;\r\n\r\n    case CMD_READ6:                                     /* optional */\r\n        scsi_read6_disk (bus, data, len);\r\n        break;\r\n\r\n    case CMD_READ10:                                    /* mandatory */\r\n        scsi_read10_disk (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RDCAP:                                     /* mandatory */\r\n        scsi_read_capacity (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RDLONG:                                    /* optional */\r\n        scsi_read_long (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RELEASE:                                   /* mandatory */\r\n        scsi_release_unit (bus, data, len);\r\n        break;\r\n\r\n    case CMD_REQSENSE:                                  /* mandatory */\r\n        scsi_req_sense (bus, data, len);\r\n        break;\r\n\r\n    case CMD_RESERVE:                                   /* mandatory */\r\n        scsi_reserve_unit (bus, data, len);\r\n        break;\r\n\r\n    case CMD_SNDDIAG:                                   /* mandatory */\r\n        scsi_send_diag (bus, data, len);\r\n        break;\r\n\r\n    case CMD_STARTSTOP:                                 /* optional */\r\n        scsi_start_stop (bus, data, len);\r\n        break;\r\n\r\n    case CMD_TESTRDY:                                   /* mandatory */\r\n        scsi_test_ready (bus, data, len);\r\n        break;\r\n\r\n    default:\r\n        sim_printf (\"SCSI: unknown CD-ROM command %02X\\n\", data[0]);\r\n        scsi_status (bus, STS_CHK, KEY_ILLREQ, ASC_INVCOM);\r\n        break;\r\n        }\r\n}\r\n\r\n/* Process data for CMD phase */\r\n\r\nuint32 scsi_command (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nUNIT *uptr = bus->dev[bus->target];\r\nuint32 cmd_len;\r\n\r\ncmd_len = scsi_decode_group (data[0]);\r\n\r\nif (len < cmd_len)                                      /* all command bytes received? */\r\n    return 0;                                           /* no, need more */\r\nbus->status = STS_OK;\r\n\r\nswitch (uptr->drvtyp->devtype) {\r\n\r\n    case SCSI_DISK:\r\n    case SCSI_WORM:                                     /* same as disk for now */\r\n        scsi_disk_command (bus, data, len);\r\n        break;\r\n\r\n    case SCSI_TAPE:\r\n        scsi_tape_command (bus, data, len);\r\n        break;\r\n\r\n    case SCSI_CDROM:\r\n        scsi_cdrom_command (bus, data, len);\r\n        break;\r\n\r\n    default:\r\n        sim_printf (\"SCSI: commands unimplemented for device type %d\\n\", uptr->drvtyp->devtype);\r\n        break;\r\n        }\r\n\r\nreturn cmd_len;\r\n}\r\n\r\n/* Process data for DATO phase */\r\n\r\nuint32 scsi_data (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nuint32 i;\r\n\r\nfor (i = 0; ((i < len) && (bus->buf_t != bus->buf_b)); i++, bus->buf_t++)\r\n    bus->buf[bus->buf_t] = data[i];\r\nif (bus->buf_t == bus->buf_b) {\r\n    bus->buf_t = 0;\r\n    scsi_command (bus, &bus->cmd[0], bus->buf_b);\r\n    }\r\nelse\r\n    scsi_set_req (bus);                                 /* request data */\r\nreturn i;\r\n}\r\n\r\n/* Write data to the SCSI bus */\r\n\r\nuint32 scsi_write (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nuint32 left = len;\r\nuint32 bc;\r\nuint8 *buf;\r\n\r\nscsi_release_req (bus);                                 /* assume done */\r\nfor (buf = data; left > 0; buf += bc, left -= bc) {\r\n    switch (bus->phase) {\r\n        case SCSI_DATO:\r\n            bc = scsi_data (bus, buf, left);\r\n            break;\r\n        case SCSI_MSGO:\r\n            bc = scsi_message (bus, buf, left);\r\n            break;\r\n        case SCSI_CMD:\r\n            bc = scsi_command (bus, buf, left);\r\n            break;\r\n        default:\r\n            return (len - left);\r\n            }\r\n    if (bc == 0) {                                      /* no data processed? */\r\n        scsi_set_req (bus);                             /* request more */\r\n        return (len - left);\r\n        }\r\n    }\r\nswitch (bus->phase) {                                   /* new phase */\r\n    case SCSI_DATI:                                     /* data in */\r\n    case SCSI_STS:                                      /* status */\r\n    case SCSI_MSGI:                                     /* message in */\r\n        if (bus->buf_t != bus->buf_b)                   /* data to return? */\r\n            scsi_set_req (bus);                         /* let initiator know */\r\n        break;\r\n    default:\r\n        break;\r\n        }\r\nreturn (len - left);\r\n}\r\n\r\n/* Read data from the SCSI bus */\r\n\r\nuint32 scsi_read (SCSI_BUS *bus, uint8 *data, uint32 len)\r\n{\r\nuint32 i;\r\n\r\nif (len == 0) {\r\n    *data = bus->buf[bus->buf_t];\r\n    return 0;\r\n    }\r\nscsi_release_req (bus);                                 /* assume done */\r\nfor (i = 0; ((i < len) && (bus->buf_t != bus->buf_b)); i++, bus->buf_t++)\r\n    data[i] = bus->buf[bus->buf_t];\r\nif (bus->buf_t == bus->buf_b) {\r\n    bus->buf_t = bus->buf_b = 0;\r\n    switch (bus->phase) {\r\n        case SCSI_DATI:                                 /* data in */\r\n            scsi_set_phase (bus, SCSI_STS);\r\n            bus->buf[bus->buf_b++] = bus->status;       /* status code */\r\n            scsi_set_req (bus);\r\n            break;\r\n        case SCSI_STS:                                  /* status */\r\n            scsi_set_phase (bus, SCSI_MSGI);\r\n            bus->buf[bus->buf_b++] = 0;                 /* command complete */\r\n            scsi_set_req (bus);\r\n            break;\r\n//        case SCSI_MSGI:                                 /* message in */\r\n//            scsi_release (bus);\r\n//            break;\r\n        default:\r\n            break;\r\n            }\r\n    }\r\nelse\r\n    scsi_set_req (bus);\r\nreturn i;\r\n}\r\n\r\n/* Get the state of the given SCSI device */\r\n\r\nuint32 scsi_state (SCSI_BUS *bus, uint32 id)\r\n{\r\nif (bus->initiator == id)\r\n    return SCSI_INIT;                                   /* device is initiator */\r\nif (bus->target == id)\r\n    return SCSI_TARG;                                   /* device is target */\r\nreturn SCSI_DISC;                                       /* device is disconnected */\r\n}\r\n\r\n/* Add a unit to the SCSI bus */\r\n\r\nvoid scsi_add_unit (SCSI_BUS *bus, uint32 id, UNIT *uptr)\r\n{\r\nbus->dev[id] = uptr;\r\n}\r\n\r\n/* Reset a unit */\r\n\r\nvoid scsi_reset_unit (UNIT *uptr)\r\n{\r\nif (uptr->drvtyp == NULL)\r\n    return;\r\n\r\nswitch (uptr->drvtyp->devtype) {\r\n    case SCSI_DISK:\r\n    case SCSI_WORM:\r\n    case SCSI_CDROM:\r\n        sim_disk_reset (uptr);\r\n        break;\r\n    case SCSI_TAPE:\r\n        sim_tape_rewind (uptr);\r\n        break;\r\n        }\r\n}\r\n\r\n/* Reset the SCSI bus */\r\n\r\nvoid scsi_reset (SCSI_BUS *bus)\r\n{\r\nsim_debug (SCSI_DBG_BUS, bus->dptr, \"Bus reset\\n\");\r\nbus->phase = SCSI_DATO;\r\nbus->buf_t = bus->buf_b = 0;\r\nbus->atn = FALSE;\r\nbus->initiator = -1;\r\nbus->target = -1;\r\nbus->lun = 0;\r\n//bus->sense_key = 6;                                     /* UNIT ATTENTION */\r\n//bus->sense_code = 0x29;                                 /* POWER ON, RESET, OR BUS DEVICE RESET OCCURRED */\r\nbus->sense_key = 0;\r\nbus->sense_code = 0;\r\nbus->sense_qual = 0;\r\nbus->sense_info = 0;\r\n}\r\n\r\n/* Initial setup of SCSI bus */\r\n\r\nt_stat scsi_init (SCSI_BUS *bus, uint32 maxfr)\r\n{\r\nif (bus->buf == NULL)\r\n    bus->buf = (uint8 *)calloc (maxfr, sizeof(uint8));\r\nif (bus->buf == NULL)\r\n    return SCPE_MEM;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set device file format */\r\n\r\nt_stat scsi_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nif (uptr->drvtyp == NULL)\r\n    return SCPE_NOFNC;\r\n\r\nswitch (uptr->drvtyp->devtype) {\r\n    case SCSI_DISK:\r\n    case SCSI_WORM:\r\n    case SCSI_CDROM:\r\n        return sim_disk_set_fmt (uptr, val, cptr, desc);\r\n    case SCSI_TAPE:\r\n        return sim_tape_set_fmt (uptr, val, cptr, desc);\r\n    default:\r\n        return SCPE_NOFNC;\r\n        }\r\n}\r\n\r\n/* Show device file format */\r\n\r\nt_stat scsi_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nif (uptr->drvtyp == NULL)\r\n    return SCPE_NOFNC;\r\n\r\nswitch (uptr->drvtyp->devtype) {\r\n    case SCSI_DISK:\r\n    case SCSI_WORM:\r\n    case SCSI_CDROM:\r\n        return sim_disk_show_fmt (st, uptr, val, desc);\r\n    case SCSI_TAPE:\r\n        return sim_tape_show_fmt (st, uptr, val, desc);\r\n    default:\r\n        return SCPE_OK;\r\n        }\r\n}\r\n\r\n/* Set/clear hardware write lock */\r\n\r\nt_stat scsi_set_wlk (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nif ((uptr->drvtyp->devtype == SCSI_CDROM) && (val == 0))\r\n    return sim_messagef (SCPE_ARG, \"%s: Can't write enable CDROM device\\n\", sim_uname (uptr));\r\nreturn set_writelock (uptr, val, cptr, desc);\r\n}\r\n\r\n/* Show write lock status */\r\n\r\nt_stat scsi_show_wlk (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nreturn show_writelock (st, uptr, val, desc);\r\n}\r\n\r\n/* Attach device */\r\n\r\nt_stat scsi_attach_ex (UNIT *uptr, CONST char *cptr, const char **drivetypes)\r\n{\r\nif (uptr->drvtyp == NULL)\r\n    return SCPE_NOFNC;\r\n\r\nswitch (uptr->drvtyp->devtype) {\r\n    case SCSI_DISK:\r\n    case SCSI_WORM:\r\n        return sim_disk_attach_ex (uptr, cptr, uptr->drvtyp->sectsize, sizeof (uint16), 0, SCSI_DBG_DSK, uptr->drvtyp->name, 0, 0, drivetypes);\r\n    case SCSI_CDROM:\r\n        sim_switches |= SWMASK ('R');       /* Force Read Only Attach for CDROM */\r\n        return sim_disk_attach_ex (uptr, cptr, uptr->drvtyp->sectsize, sizeof (uint16), FALSE, SCSI_DBG_DSK, uptr->drvtyp->name, 0, 0, drivetypes);\r\n    case SCSI_TAPE:\r\n        return sim_tape_attach_ex (uptr, cptr, SCSI_DBG_TAP, 0);\r\n    default:\r\n        return SCPE_NOFNC;\r\n        }\r\n}\r\n\r\nt_stat scsi_attach (UNIT *uptr, CONST char *cptr)\r\n{\r\nreturn scsi_attach_ex (uptr, cptr, NULL);\r\n}\r\n\r\n/* Detach device */\r\n\r\nt_stat scsi_detach (UNIT *uptr)\r\n{\r\nif (uptr->drvtyp == NULL)\r\n    return SCPE_NOFNC;\r\n\r\nswitch (uptr->drvtyp->devtype) {\r\n    case SCSI_DISK:\r\n    case SCSI_WORM:\r\n    case SCSI_CDROM:\r\n        return sim_disk_detach (uptr);                  /* detach unit */\r\n    case SCSI_TAPE:\r\n        return sim_tape_detach (uptr);                  /* detach unit */\r\n    default:\r\n        return SCPE_NOFNC;\r\n        }\r\n}\r\n\r\n/* Show common SCSI help */\r\n\r\nt_stat scsi_help (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\nfprintf (st, \"\\nDisk drives on the SCSI bus can be attached to simulated storage in the\\n\");\r\nfprintf (st, \"following ways:\\n\\n\");\r\nsim_disk_attach_help (st, dptr, uptr, flag, cptr);\r\nfprintf (st, \"\\nTape drives on the SCSI bus can be attached to simulated storage in the\\n\");\r\nfprintf (st, \"following ways:\\n\\n\");\r\nsim_tape_attach_help (st, dptr, uptr, flag, cptr);\r\nreturn SCPE_OK;\r\n}\r\n"
        },
        {
          "name": "sim_scsi.h",
          "type": "blob",
          "size": 6.564453125,
          "content": "/* sim_scsi.h: SCSI bus simulation\r\n\r\n   Copyright (c) 2019, Matt Burke\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n*/\r\n\r\n#ifndef _SIM_SCSI_H_\r\n#define _SIM_SCSI_H_     0\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_disk.h\"\r\n#include \"sim_tape.h\"\r\n\r\n/* SCSI device states */\r\n\r\n#define SCSI_DISC       0                               /* disconnected */\r\n#define SCSI_TARG       1                               /* target mode */\r\n#define SCSI_INIT       2                               /* initiator mode */\r\n\r\n/* SCSI device types */\r\n\r\n#define SCSI_DISK       0                               /* direct access device */\r\n#define SCSI_TAPE       1                               /* sequential access device */\r\n#define SCSI_PRINT      2                               /* printer */\r\n#define SCSI_PROC       3                               /* processor */\r\n#define SCSI_WORM       4                               /* write-once device */\r\n#define SCSI_CDROM      5                               /* CD-ROM */\r\n#define SCSI_SCAN       6                               /* scanner */\r\n#define SCSI_OPTI       7                               /* optical */\r\n#define SCSI_JUKE       8                               /* jukebox */\r\n#define SCSI_COMM       9                               /* communications device */\r\n\r\n/* SCSI bus phases */\r\n\r\n#define SCSI_DATO       0                               /* data out */\r\n#define SCSI_DATI       1                               /* data in */\r\n#define SCSI_CMD        2                               /* command */\r\n#define SCSI_STS        3                               /* status */\r\n#define SCSI_MSGO       6                               /* message out */\r\n#define SCSI_MSGI       7                               /* message in */\r\n\r\n/* Debugging bitmaps */\r\n\r\n#define SCSI_DBG_CMD    0x01000000                      /* SCSI commands */\r\n#define SCSI_DBG_MSG    0x02000000                      /* SCSI messages */\r\n#define SCSI_DBG_BUS    0x04000000                      /* bus activity */\r\n#define SCSI_DBG_DSK    0x08000000                      /* disk activity */\r\n#define SCSI_DBG_TAP    0x10000000                      /* tape activity */\r\n\r\n#define SCSI_WLK        (UNIT_WLK|UNIT_RO)              /* hwre write lock */\r\n\r\n/* This structure has been obsoleted and its role is now provided by\r\n   the DRVTYP structure */\r\n#if 0\r\nstruct scsi_dev_t {\r\n    uint8 devtype;                                      /* device type */\r\n    uint8 pqual;                                        /* peripheral qualifier */\r\n    uint32 scsiver;                                     /* SCSI version */\r\n    t_bool removeable;                                  /* removable flag */\r\n    uint32 block_size;                                  /* device block size */\r\n    uint32 lbn;                                         /* device size (blocks) */\r\n    const char *manufacturer;                           /* manufacturer string */\r\n    const char *product;                                /* product string */\r\n    const char *rev;                                    /* revision string */\r\n    const char *name;                                   /* gap length for tapes */\r\n    uint32 gaplen;\r\n    };\r\n#endif\r\n\r\nstruct scsi_bus_t {\r\n    DEVICE *dptr;                                       /* SCSI device */\r\n    UNIT *dev[8];                                       /* target units */\r\n    int32 initiator;                                    /* current initiator */\r\n    int32 target;                                       /* current target */\r\n    t_bool atn;                                         /* attention flag */\r\n    t_bool req;                                         /* request flag */\r\n    uint8 *buf;                                         /* transfer buffer */\r\n    uint8 cmd[10];                                      /* command buffer */\r\n    uint32 buf_b;                                       /* buffer bottom ptr */\r\n    uint32 buf_t;                                       /* buffer top ptr */\r\n    uint32 phase;                                       /* current bus phase */\r\n    uint32 lun;                                         /* selected lun */\r\n    uint32 status;\r\n    uint32 sense_key;\r\n    uint32 sense_code;\r\n    uint32 sense_qual;\r\n    uint32 sense_info;\r\n};\r\n\r\ntypedef struct scsi_bus_t SCSI_BUS;\r\n\r\nt_bool scsi_arbitrate (SCSI_BUS *bus, uint32 initiator);\r\nvoid scsi_release (SCSI_BUS *bus);\r\nvoid scsi_set_atn (SCSI_BUS *bus);\r\nvoid scsi_release_atn (SCSI_BUS *bus);\r\nt_bool scsi_select (SCSI_BUS *bus, uint32 target);\r\nuint32 scsi_write (SCSI_BUS *bus, uint8 *data, uint32 len);\r\nuint32 scsi_read (SCSI_BUS *bus, uint8 *data, uint32 len);\r\nuint32 scsi_state (SCSI_BUS *bus, uint32 id);\r\nvoid scsi_add_unit (SCSI_BUS *bus, uint32 id, UNIT *uptr);\r\nvoid scsi_reset_unit (UNIT *uptr);\r\nvoid scsi_reset (SCSI_BUS *bus);\r\nt_stat scsi_init (SCSI_BUS *bus, uint32 maxfr);\r\n\r\nt_stat scsi_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat scsi_set_wlk (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat scsi_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat scsi_show_wlk (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat scsi_attach (UNIT *uptr, CONST char *cptr);\r\nt_stat scsi_attach_ex (UNIT *uptr, CONST char *cptr, const char **drivetypes);\r\nt_stat scsi_detach (UNIT *uptr);\r\nt_stat scsi_help (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr);\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_serial.c",
          "type": "blob",
          "size": 72.5234375,
          "content": "/* sim_serial.c: OS-dependent serial port routines\r\n\r\n   Copyright (c) 2008, J. David Bryan, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n\r\n   The author gratefully acknowledges the assistance of Holger Veit with the\r\n   UNIX-specific code and testing.\r\n\r\n   07-Oct-08    JDB     [serial] Created file\r\n   22-Apr-12    MP      Adapted from code originally written by J. David Bryan\r\n\r\n\r\n   This module provides OS-dependent routines to access serial ports on the host\r\n   machine.  The terminal multiplexer library uses these routines to provide\r\n   serial connections to simulated terminal interfaces.\r\n\r\n   Currently, the module supports Windows and UNIX.  Use on other systems\r\n   returns error codes indicating that the functions failed, inhibiting serial\r\n   port support in SIMH.\r\n\r\n   The following routines are provided:\r\n\r\n     sim_open_serial        open a serial port\r\n     sim_config_serial      change baud rate and character framing configuration\r\n     sim_control_serial     manipulate and/or return the modem bits on a serial port\r\n     sim_read_serial        read from a serial port\r\n     sim_write_serial       write to a serial port\r\n     sim_close_serial       close a serial port\r\n     sim_show_serial        shows the available host serial ports\r\n\r\n\r\n   The calling sequences are as follows:\r\n\r\n\r\n   SERHANDLE sim_open_serial (char *name)\r\n   --------------------------------------\r\n\r\n   The serial port referenced by the OS-dependent \"name\" is opened.  If the open\r\n   is successful, and \"name\" refers to a serial port on the host system, then a\r\n   handle to the port is returned.  If not, then the value INVALID_HANDLE is\r\n   returned.\r\n\r\n\r\n   t_stat sim_config_serial (SERHANDLE port, const char *config)\r\n   -------------------------------------------------------------\r\n\r\n   The baud rate and framing parameters (character size, parity, and number of\r\n   stop bits) of the serial port associated with \"port\" are set.  If any\r\n   \"config\" field value is unsupported by the host system, or if the combination\r\n   of values (e.g., baud rate and number of stop bits) is unsupported, SCPE_ARG\r\n   is returned.  If the configuration is successful, SCPE_OK is returned.\r\n\r\n\r\n   sim_control_serial (SERHANDLE port, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits)\r\n   -------------------------------------------------------------------------------------------------\r\n\r\n   The DTR and RTS line of the serial port is set or cleared as indicated in\r\n   the respective bits_to_set or bits_to_clear parameters.  If the\r\n   incoming_bits parameter is not NULL, then the modem status bits DCD, RNG,\r\n   DSR and CTS are returned.\r\n\r\n   If unreasonable or nonsense bits_to_set or bits_to_clear bits are\r\n   specified, then the return status is SCPE_ARG;\r\n   If an error occurs, SCPE_IOERR is returned.\r\n\r\n\r\n   int32 sim_read_serial (SERHANDLE port, char *buffer, int32 count, char *brk)\r\n   ----------------------------------------------------------------------------\r\n\r\n   A non-blocking read is issued for the serial port indicated by \"port\" to get\r\n   at most \"count\" bytes into the string \"buffer\".  If a serial line break was\r\n   detected during the read, the variable pointed to by \"brk\" is set to 1.  If\r\n   the read is successful, the actual number of characters read is returned.  If\r\n   no characters were available, then the value 0 is returned.  If an error\r\n   occurs, then the value -1 is returned.\r\n\r\n\r\n   int32 sim_write_serial (SERHANDLE port, char *buffer, int32 count)\r\n   ------------------------------------------------------------------\r\n\r\n   A write is issued to the serial port indicated by \"port\" to put \"count\"\r\n   characters from \"buffer\".  If the write is successful, the actual number of\r\n   characters written is returned.  If an error occurs, then the value -1 is\r\n   returned.\r\n\r\n\r\n   void sim_close_serial (SERHANDLE port)\r\n   --------------------------------------\r\n\r\n   The serial port indicated by \"port\" is closed.\r\n\r\n\r\n   int sim_serial_devices (int max, SERIAL_LIST* list)\r\n   ---------------------------------------------------\r\n\r\n   enumerates the available host serial ports\r\n\r\n\r\n   t_stat sim_show_serial (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, const void* desc)\r\n   ---------------------------------\r\n\r\n   displays the available host serial ports\r\n\r\n*/\r\n\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_scp_private.h\"\r\n#include \"sim_serial.h\"\r\n#include \"sim_tmxr.h\"\r\n\r\n#define SER_DEV_NAME_MAX     256                        /* maximum device name size */\r\n#define SER_DEV_DESC_MAX     256                        /* maximum device description size */\r\n#define SER_DEV_CONFIG_MAX    64                        /* maximum device config size */\r\n#define SER_MAX_DEVICE        64                        /* maximum serial devices */\r\n\r\ntypedef struct serial_list {\r\n    char    name[SER_DEV_NAME_MAX];\r\n    char    desc[SER_DEV_DESC_MAX];\r\n    } SERIAL_LIST;\r\n\r\ntypedef struct serial_config {                          /* serial port configuration */\r\n    uint32 baudrate;                                    /* baud rate */\r\n    uint32 charsize;                                    /* character size in bits */\r\n    char   parity;                                      /* parity (N/O/E/M/S) */\r\n    uint32 stopbits;                                    /* 0/1/2 stop bits (0 implies 1.5) */\r\n    } SERCONFIG;\r\n\r\nstatic int       sim_serial_os_devices (int max, SERIAL_LIST* list);\r\nstatic SERHANDLE sim_open_os_serial    (char *name);\r\nstatic void      sim_close_os_serial   (SERHANDLE port);\r\nstatic t_stat    sim_config_os_serial  (SERHANDLE port, SERCONFIG config);\r\n\r\n\r\nstatic struct open_serial_device {\r\n    SERHANDLE port;\r\n    TMLN *line;\r\n    char name[SER_DEV_NAME_MAX];\r\n    char config[SER_DEV_CONFIG_MAX];\r\n    } *serial_open_devices = NULL;\r\nstatic int serial_open_device_count = 0;\r\n\r\nstatic struct open_serial_device *_get_open_device (SERHANDLE port)\r\n{\r\nint i;\r\n\r\nfor (i=0; i<serial_open_device_count; ++i)\r\n    if (serial_open_devices[i].port == port)\r\n        return &serial_open_devices[i];\r\nreturn NULL;\r\n}\r\n\r\nstatic struct open_serial_device *_get_open_device_byname (const char *name)\r\n{\r\nint i;\r\n\r\nfor (i=0; i<serial_open_device_count; ++i)\r\n    if (0 == strcmp(name, serial_open_devices[i].name))\r\n        return &serial_open_devices[i];\r\nreturn NULL;\r\n}\r\n\r\nstatic struct open_serial_device *_serial_add_to_open_list (SERHANDLE port, TMLN *line, const char *name, const char *config)\r\n{\r\nserial_open_devices = (struct open_serial_device *)realloc(serial_open_devices, (++serial_open_device_count)*sizeof(*serial_open_devices));\r\nmemset(&serial_open_devices[serial_open_device_count-1], 0, sizeof(serial_open_devices[serial_open_device_count-1]));\r\nserial_open_devices[serial_open_device_count-1].port = port;\r\nserial_open_devices[serial_open_device_count-1].line = line;\r\nstrlcpy(serial_open_devices[serial_open_device_count-1].name, name, sizeof(serial_open_devices[serial_open_device_count-1].name));\r\nif (config)\r\n    strlcpy(serial_open_devices[serial_open_device_count-1].config, config, sizeof(serial_open_devices[serial_open_device_count-1].config));\r\nreturn &serial_open_devices[serial_open_device_count-1];\r\n}\r\n\r\nstatic void _serial_remove_from_open_list (SERHANDLE port)\r\n{\r\nint i, j;\r\n\r\nfor (i=0; i<serial_open_device_count; ++i)\r\n    if (serial_open_devices[i].port == port) {\r\n        for (j=i+1; j<serial_open_device_count; ++j)\r\n            serial_open_devices[j-1] = serial_open_devices[j];\r\n        --serial_open_device_count;\r\n        break;\r\n        }\r\n}\r\n\r\n/* Generic error message handler.\r\n\r\n   This routine should be called for unexpected errors.  Some error returns may\r\n   be expected, e.g., a \"file not found\" error from an \"open\" routine.  These\r\n   should return appropriate status codes to the caller, allowing SCP to print\r\n   an error message if desired, rather than printing this generic error message.\r\n*/\r\n\r\nstatic void sim_error_serial (const char *routine, int error)\r\n{\r\nsim_printf (\"Serial: %s fails with error %d\\n\", routine, error);\r\nreturn;\r\n}\r\n\r\n/* Used when sorting a list of serial port names */\r\nstatic int _serial_name_compare (const void *pa, const void *pb)\r\n{\r\nconst SERIAL_LIST *a = (const SERIAL_LIST *)pa;\r\nconst SERIAL_LIST *b = (const SERIAL_LIST *)pb;\r\n\r\nreturn strcmp(a->name, b->name);\r\n}\r\n\r\nstatic int sim_serial_devices (int max, SERIAL_LIST *list)\r\n{\r\nint i, j, ports = sim_serial_os_devices(max, list);\r\n\r\n/* Open ports may not show up in the list returned by sim_serial_os_devices\r\n   so we add the open ports to the list removing duplicates before sorting\r\n   the resulting list */\r\n\r\nfor (i=0; i<serial_open_device_count; ++i) {\r\n    for (j=0; j<ports; ++j)\r\n        if (0 == strcmp(serial_open_devices[i].name, list[j].name))\r\n            break;\r\n    if (j<ports)\r\n        continue;\r\n    if (ports >= max)\r\n        break;\r\n    strcpy(list[ports].name, serial_open_devices[i].name);\r\n    strcpy(list[ports].desc, serial_open_devices[i].config);\r\n    ++ports;\r\n    }\r\nif (ports) /* Order the list returned alphabetically by the port name */\r\n    qsort (list, ports, sizeof(list[0]), _serial_name_compare);\r\nreturn ports;\r\n}\r\n\r\nstatic char* sim_serial_getname (int number, char* name)\r\n{\r\nSERIAL_LIST  list[SER_MAX_DEVICE];\r\nint count = sim_serial_devices(SER_MAX_DEVICE, list);\r\n\r\nif (count <= number)\r\n    return NULL;\r\nstrcpy(name, list[number].name);\r\nreturn name;\r\n}\r\n\r\nstatic char* sim_serial_getname_bydesc (char* desc, char* name)\r\n{\r\nSERIAL_LIST  list[SER_MAX_DEVICE];\r\nint count = sim_serial_devices(SER_MAX_DEVICE, list);\r\nint i;\r\nsize_t j=strlen(desc);\r\n\r\nfor (i=0; i<count; i++) {\r\n    int found = 1;\r\n    size_t k = strlen(list[i].desc);\r\n\r\n    if (j != k)\r\n        continue;\r\n    for (k=0; k<j; k++)\r\n        if (tolower(list[i].desc[k]) != tolower(desc[k]))\r\n            found = 0;\r\n    if (found == 0)\r\n        continue;\r\n\r\n    /* found a case-insensitive description match */\r\n    strcpy(name, list[i].name);\r\n    return name;\r\n    }\r\n/* not found */\r\nreturn NULL;\r\n}\r\n\r\nstatic char* sim_serial_getname_byname (char* name, char* temp)\r\n{\r\nSERIAL_LIST  list[SER_MAX_DEVICE];\r\nint count = sim_serial_devices(SER_MAX_DEVICE, list);\r\nsize_t n;\r\nint i, found;\r\n\r\nfound = 0;\r\nn = strlen(name);\r\nfor (i=0; i<count && !found; i++) {\r\n    if ((n == strlen(list[i].name)) &&\r\n        (strncasecmp(name, list[i].name, n) == 0)) {\r\n        found = 1;\r\n        strcpy(temp, list[i].name); /* only case might be different */\r\n        }\r\n    }\r\nreturn (found ? temp : NULL);\r\n}\r\n\r\nchar* sim_serial_getdesc_byname (char* name, char* temp)\r\n{\r\nSERIAL_LIST  list[SER_MAX_DEVICE];\r\nint count = sim_serial_devices(SER_MAX_DEVICE, list);\r\nsize_t n;\r\nint i, found;\r\n\r\nfound = 0;\r\nn = strlen(name);\r\nfor (i=0; i<count && !found; i++) {\r\n    if ((n == strlen(list[i].name)) &&\r\n        (strncasecmp(name, list[i].name, n) == 0)) {\r\n        found = 1;\r\n        strcpy(temp, list[i].desc);\r\n        }\r\n    }\r\n  return (found ? temp : NULL);\r\n}\r\n\r\nt_stat sim_show_serial (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char* desc)\r\n{\r\nSERIAL_LIST  list[SER_MAX_DEVICE];\r\nint number = sim_serial_devices(SER_MAX_DEVICE, list);\r\n\r\nfprintf(st, \"Serial devices:\\n\");\r\nif (number == -1)\r\n    fprintf(st, \"  serial support not available in simulator\\n\");\r\nelse {\r\n    if (number == 0) {\r\n        fprintf(st, \"  no serial devices are available.\\n\");\r\n        fprintf(st, \"You may need to run with privilege or set device permissions\\n\");\r\n        fprintf(st, \"to access local serial ports\\n\");\r\n        }\r\n    else {\r\n        size_t min, len;\r\n        int i;\r\n        for (i=0, min=0; i<number; i++)\r\n            if ((len = strlen(list[i].name)) > min)\r\n                min = len;\r\n        for (i=0; i<number; i++)\r\n            fprintf(st,\" ser%d\\t%-*s%s%s%s\\n\", i, (int)min, list[i].name, list[i].desc[0] ? \" (\" : \"\", list[i].desc, list[i].desc[0] ? \")\" : \"\");\r\n        }\r\n    }\r\nif (serial_open_device_count) {\r\n    int i;\r\n    char desc[SER_DEV_DESC_MAX], *d;\r\n\r\n    fprintf(st,\"Open Serial Devices:\\n\");\r\n    for (i=0; i<serial_open_device_count; i++) {\r\n        d = sim_serial_getdesc_byname(serial_open_devices[i].name, desc);\r\n        fprintf(st, \" %s\\tLn%02d %s%s%s%s\\tConfig: %s\\n\", serial_open_devices[i].line->mp->dptr->name, (int)(serial_open_devices[i].line->mp->ldsc-serial_open_devices[i].line),\r\n                    serial_open_devices[i].line->destination, ((d != NULL) && (*d != '\\0')) ? \" (\" : \"\", ((d != NULL) && (*d != '\\0'))  ? d : \"\", ((d != NULL) && (*d != '\\0'))  ? \")\" : \"\", serial_open_devices[i].line->serconfig);\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nSERHANDLE sim_open_serial (char *name, TMLN *lp, t_stat *stat)\r\n{\r\nchar temp1[1024], devname [1024];\r\nchar *savname = name;\r\nSERHANDLE port = INVALID_HANDLE;\r\nCONST char *config;\r\nt_stat status;\r\n\r\nconfig = get_glyph_nc (name, devname, ';');             /* separate port name from optional config params */\r\n\r\nif ((config == NULL) || (*config == '\\0'))\r\n    config = \"9600-8N1\";\r\n\r\nif (stat)\r\n    *stat = SCPE_OK;\r\n\r\n/* translate name of type \"serX\" to real device name */\r\nif ((strlen(devname) <= 5)\r\n    && (tolower(devname[0]) == 's')\r\n    && (tolower(devname[1]) == 'e')\r\n    && (tolower(devname[2]) == 'r')\r\n    && (isdigit(devname[3]))\r\n    && (isdigit(devname[4]) || (devname[4] == '\\0'))\r\n   ) {\r\n    int num = atoi(&devname[3]);\r\n    savname = sim_serial_getname(num, temp1);\r\n    if (savname == NULL) {                              /* didn't translate */\r\n        if (stat)\r\n            *stat = SCPE_OPENERR;\r\n        return INVALID_HANDLE;\r\n        }\r\n    }\r\nelse {\r\n    /* are they trying to use device description? */\r\n    savname = sim_serial_getname_bydesc(devname, temp1);\r\n    if (savname == NULL) {                              /* didn't translate */\r\n        /* probably is not serX and has no description */\r\n        savname = sim_serial_getname_byname(devname, temp1);\r\n        if (savname == NULL) /* didn't translate */\r\n            savname = devname;\r\n        }\r\n    }\r\n\r\nif (_get_open_device_byname (savname)) {\r\n    if (stat)\r\n        *stat = SCPE_OPENERR;\r\n    return INVALID_HANDLE;\r\n    }\r\n\r\nport = sim_open_os_serial (savname);\r\n\r\nif (port == INVALID_HANDLE) {\r\n    if (stat)\r\n        *stat = SCPE_OPENERR;\r\n    return port;\r\n    }\r\n\r\nstatus = sim_config_serial (port, config);              /* set serial configuration */\r\nif ((lp) && (status == SCPE_OK))                        /* line specified? */\r\n    status = tmxr_set_config_line (lp, config);         /* set line speed parameters */\r\n\r\nif (status != SCPE_OK) {                                /* port configuration error? */\r\n    sim_close_serial (port);                            /* close the port */\r\n    if (stat)\r\n        *stat = status;\r\n    port = INVALID_HANDLE;                              /* report error */\r\n    }\r\n\r\nif ((port != INVALID_HANDLE) && (*config) && (lp)) {\r\n    lp->serconfig = (char *)realloc (lp->serconfig, 1 + strlen (config));\r\n    strcpy (lp->serconfig, config);\r\n    }\r\nif (port != INVALID_HANDLE)\r\n    _serial_add_to_open_list (port, lp, savname, config);\r\n\r\nreturn port;\r\n}\r\n\r\nvoid sim_close_serial (SERHANDLE port)\r\n{\r\n_serial_remove_from_open_list (port);\r\nsim_close_os_serial (port);\r\n}\r\n\r\nt_stat sim_config_serial  (SERHANDLE port, CONST char *sconfig)\r\n{\r\nCONST char *pptr;\r\nCONST char *sptr, *tptr;\r\nSERCONFIG config = { 0 };\r\nt_bool arg_error = FALSE;\r\nt_stat r;\r\nstruct open_serial_device *dev;\r\n\r\nif ((sconfig == NULL) || (*sconfig == '\\0'))\r\n    sconfig = \"9600-8N1\";                               /* default settings */\r\npptr = sconfig;\r\n\r\nconfig.baudrate = (uint32)strtotv (pptr, &sptr, 10);    /* parse baud rate */\r\narg_error = (pptr == sptr);                             /* check for bad argument */\r\n\r\nif (*sptr)                                              /* separator present? */\r\n    sptr++;                                             /* skip it */\r\n\r\nconfig.charsize = (uint32)strtotv (sptr, &tptr, 10);    /* parse character size */\r\narg_error = arg_error || (sptr == tptr);                /* check for bad argument */\r\n\r\nif (*tptr)                                              /* parity character present? */\r\n    config.parity = (char)toupper (*tptr++);            /* save parity character */\r\n\r\nconfig.stopbits = (uint32)strtotv (tptr, &sptr, 10);    /* parse number of stop bits */\r\narg_error = arg_error || (tptr == sptr);                /* check for bad argument */\r\n\r\nif (arg_error)                                          /* bad conversions? */\r\n    return SCPE_ARG;                                    /* report argument error */\r\nif (strcmp (sptr, \".5\") == 0)                           /* 1.5 stop bits requested? */\r\n    config.stopbits = 0;                                /* code request */\r\n\r\nr = sim_config_os_serial (port, config);\r\ndev = _get_open_device (port);\r\nif (dev) {\r\n    dev->line->serconfig = (char *)realloc (dev->line->serconfig, 1 + strlen (sconfig));\r\n    strcpy (dev->line->serconfig, sconfig);\r\n    }\r\nreturn r;\r\n}\r\n\r\n#if defined (_WIN32)\r\n\r\n/* Windows serial implementation */\r\n\r\n/* Enumerate the available serial ports.\r\n\r\n   The serial port names are extracted from the appropriate place in the\r\n   windows registry (HKLM\\HARDWARE\\DEVICEMAP\\SERIALCOMM\\).  The resulting\r\n   list is sorted alphabetically by device name (COMn).  The device description\r\n   is set to the OS internal name for the COM device.\r\n\r\n*/\r\n\r\nstruct SERPORT {\r\n    HANDLE hPort;\r\n    DWORD dwEvtMask;\r\n    OVERLAPPED oReadSync;\r\n    OVERLAPPED oWriteReady;\r\n    OVERLAPPED oWriteSync;\r\n    };\r\n\r\nstatic int sim_serial_os_devices (int max, SERIAL_LIST* list)\r\n{\r\nint ports = 0;\r\nHKEY hSERIALCOMM;\r\n\r\nmemset(list, 0, max*sizeof(*list));\r\nif (RegOpenKeyExA(HKEY_LOCAL_MACHINE, \"HARDWARE\\\\DEVICEMAP\\\\SERIALCOMM\", 0, KEY_QUERY_VALUE, &hSERIALCOMM) == ERROR_SUCCESS) {\r\n    DWORD dwIndex = 0;\r\n    DWORD dwType;\r\n    DWORD dwValueNameSize = sizeof(list[ports].desc);\r\n    DWORD dwDataSize = sizeof(list[ports].name);\r\n\r\n    /* Enumerate all the values underneath HKEY_LOCAL_MACHINE\\HARDWARE\\DEVICEMAP\\SERIALCOMM */\r\n    while (RegEnumValueA(hSERIALCOMM, dwIndex, list[ports].desc, &dwValueNameSize, NULL, &dwType, (BYTE *)list[ports].name, &dwDataSize) == ERROR_SUCCESS) {\r\n        /* String values with non-zero size are the interesting ones */\r\n        if ((dwType == REG_SZ) && (dwDataSize > 0)) {\r\n            if (ports < max)\r\n                ++ports;\r\n            else\r\n                break;\r\n            }\r\n        /* Be sure to clear the working entry before trying again */\r\n        memset(list[ports].name, 0, sizeof(list[ports].name));\r\n        memset(list[ports].desc, 0, sizeof(list[ports].desc));\r\n        dwValueNameSize = sizeof(list[ports].desc);\r\n        dwDataSize = sizeof(list[ports].name);\r\n        ++dwIndex;\r\n        }\r\n    RegCloseKey(hSERIALCOMM);\r\n    }\r\nreturn ports;\r\n}\r\n\r\n/* Open a serial port.\r\n\r\n   The serial port designated by \"name\" is opened, and the handle to the port is\r\n   returned.  If an error occurs, INVALID_HANDLE is returned instead.  After\r\n   opening, the port is configured with the default communication parameters\r\n   established by the system, and the timeouts are set for immediate return on a\r\n   read request to enable polling.\r\n\r\n   Implementation notes:\r\n\r\n    1. We call \"GetDefaultCommConfig\" to obtain the default communication\r\n       parameters for the specified port.  If the name does not refer to a\r\n       communications port (serial or parallel), the function fails.\r\n\r\n    2. There is no way to limit \"CreateFile\" just to serial ports, so we must\r\n       check after the port is opened.  The \"GetCommState\" routine will return\r\n       an error if the handle does not refer to a serial port.\r\n\r\n    3. Calling \"GetDefaultCommConfig\" for a serial port returns a structure\r\n       containing a DCB.  This contains the default parameters.  However, some\r\n       of the DCB fields are not set correctly, so we cannot use this directly\r\n       in a call to \"SetCommState\".  Instead, we must copy the fields of\r\n       interest to a DCB retrieved from a call to \"GetCommState\".\r\n*/\r\n\r\nstatic SERHANDLE sim_open_os_serial (char *name)\r\n{\r\nHANDLE hPort;\r\nSERHANDLE port;\r\nDCB dcb;\r\nCOMMCONFIG commdefault;\r\nDWORD error;\r\nDWORD commsize = sizeof (commdefault);\r\nCOMMTIMEOUTS cto;\r\nchar win32name[1028];\r\n\r\nif (!GetDefaultCommConfigA (name, &commdefault, &commsize)) {    /* get default comm parameters */\r\n    error = GetLastError ();                                    /* function failed; get error */\r\n\r\n    if (error != ERROR_INVALID_PARAMETER)                       /* not a communications port name? */\r\n        sim_error_serial (\"GetDefaultCommConfig\", (int) error); /* no, so report unexpected error */\r\n\r\n    return INVALID_HANDLE;                                      /* indicate bad port name */\r\n    }\r\n\r\nsnprintf (win32name, sizeof (win32name), \"\\\\\\\\.\\\\%s\", name);\r\nhPort = CreateFileA (win32name, GENERIC_READ | GENERIC_WRITE, /* open the port */\r\n                    0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);\r\n\r\nif (hPort == INVALID_HANDLE_VALUE) {                    /* open failed? */\r\n    error = GetLastError ();                            /* get error code */\r\n\r\n    if ((error != ERROR_FILE_NOT_FOUND) &&              /* bad filename? */\r\n        (error != ERROR_ACCESS_DENIED))                 /* already open? */\r\n        sim_error_serial (\"CreateFile\", (int) error);   /* no, so report unexpected error */\r\n\r\n    return INVALID_HANDLE;                              /* indicate bad port name */\r\n    }\r\n\r\nport = (SERHANDLE)calloc (1, sizeof(*port));            /* instantiate the SERHANDLE */\r\nport->hPort = hPort;\r\n\r\nif (!GetCommState (port->hPort, &dcb)) {                /* get the current comm parameters */\r\n    error = GetLastError ();                            /* function failed; get error */\r\n\r\n    if (error != ERROR_INVALID_PARAMETER)               /* not a serial port name? */\r\n        sim_error_serial (\"GetCommState\", (int) error); /* no, so report unexpected error */\r\n\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate bad port name */\r\n    }\r\n\r\ndcb.BaudRate = commdefault.dcb.BaudRate;                /* copy default parameters of interest */\r\ndcb.Parity   = commdefault.dcb.Parity;\r\ndcb.ByteSize = commdefault.dcb.ByteSize;\r\ndcb.StopBits = commdefault.dcb.StopBits;\r\ndcb.fOutX    = commdefault.dcb.fOutX;\r\ndcb.fInX     = commdefault.dcb.fInX;\r\n\r\ndcb.fDtrControl = DTR_CONTROL_DISABLE;                  /* disable DTR initially until poll connects */\r\n\r\nif (!SetCommState (port->hPort, &dcb)) {                /* configure the port with default parameters */\r\n    sim_error_serial (\"SetCommState\",                   /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate failure to caller */\r\n    }\r\n\r\ncto.ReadIntervalTimeout         = MAXDWORD;             /* set port to return immediately on read */\r\ncto.ReadTotalTimeoutMultiplier  = 0;                    /* i.e., to enable polling */\r\ncto.ReadTotalTimeoutConstant    = 0;\r\ncto.WriteTotalTimeoutMultiplier = 0;\r\ncto.WriteTotalTimeoutConstant   = 0;\r\n\r\nif (!SetCommTimeouts (port->hPort, &cto)) {             /* configure port timeouts */\r\n    sim_error_serial (\"SetCommTimeouts\",                /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate failure to caller */\r\n    }\r\n\r\n/* Create an event object for use by WaitCommEvent. */\r\n\r\nport->oWriteReady.hEvent = CreateEvent(NULL,            /* default security attributes */\r\n                                       TRUE,            /* manual-reset event */\r\n                                       TRUE,            /* signaled */\r\n                                       NULL);           /* no name */\r\nif (port->oWriteReady.hEvent == NULL) {\r\n    sim_error_serial (\"CreateEvent\",                    /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate failure to caller */\r\n    }\r\n\r\nport->oReadSync.hEvent = CreateEvent(NULL,              /* default security attributes */\r\n                                     TRUE,              /* manual-reset event */\r\n                                     FALSE,             /* not signaled */\r\n                                     NULL);             /* no name */\r\nif (port->oReadSync.hEvent == NULL) {\r\n    sim_error_serial (\"CreateEvent\",                    /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate failure to caller */\r\n    }\r\n\r\nport->oWriteSync.hEvent = CreateEvent(NULL,             /* default security attributes */\r\n                                      TRUE,             /* manual-reset event */\r\n                                      FALSE,            /* not signaled */\r\n                                      NULL);            /* no name */\r\nif (port->oWriteSync.hEvent == NULL) {\r\n    sim_error_serial (\"CreateEvent\",                    /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate failure to caller */\r\n    }\r\n\r\nif (!SetCommMask (port->hPort, EV_TXEMPTY)) {\r\n    sim_error_serial (\"SetCommMask\",                    /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    sim_close_os_serial (port);                         /* close port */\r\n    return INVALID_HANDLE;                              /*   and indicate failure to caller */\r\n    }\r\n\r\nreturn port;                                            /* return port handle on success */\r\n}\r\n\r\n\r\n/* Configure a serial port.\r\n\r\n   Port parameters are configured as specified in the \"config\" structure.  If\r\n   \"config\" contains an invalid configuration value, or if the host system\r\n   rejects the configuration (e.g., by requesting an unsupported combination of\r\n   character size and stop bits), SCPE_ARG is returned to the caller.  If an\r\n   unexpected error occurs, SCPE_IOERR is returned.  If the configuration\r\n   succeeds, SCPE_OK is returned.\r\n\r\n   Implementation notes:\r\n\r\n    1. We do not enable input parity checking, as the multiplexer library has no\r\n       way of communicating parity errors back to the target simulator.\r\n\r\n    2. A zero value for the \"stopbits\" field of the \"config\" structure implies\r\n       1.5 stop bits.\r\n*/\r\n\r\nstatic t_stat sim_config_os_serial (SERHANDLE port, SERCONFIG config)\r\n{\r\nstatic const struct {\r\n    char parity;\r\n    BYTE parity_code;\r\n    } parity_map [] =\r\n        { { 'E', EVENPARITY }, { 'M', MARKPARITY  }, { 'N', NOPARITY },\r\n          { 'O', ODDPARITY  }, { 'S', SPACEPARITY } };\r\n\r\nstatic const int32 parity_count = sizeof (parity_map) / sizeof (parity_map [0]);\r\n\r\nDCB dcb;\r\nDWORD error;\r\nint32 i;\r\n\r\nif (!GetCommState (port->hPort, &dcb)) {                /* get the current comm parameters */\r\n    sim_error_serial (\"GetCommState\",                   /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    return SCPE_IOERR;                                  /* return failure status */\r\n    }\r\n\r\ndcb.BaudRate = config.baudrate;                         /* assign baud rate */\r\n\r\nif (config.charsize >= 5 && config.charsize <= 8)       /* character size OK? */\r\n    dcb.ByteSize = (BYTE)config.charsize;               /* assign character size */\r\nelse\r\n    return SCPE_ARG;                                    /* not a valid size */\r\n\r\nfor (i = 0; i < parity_count; i++)                      /* assign parity */\r\n    if (config.parity == parity_map [i].parity) {       /* match mapping value? */\r\n        dcb.Parity = parity_map [i].parity_code;        /* assign corresponding code */\r\n        break;\r\n        }\r\n\r\nif (i == parity_count)                                  /* parity assigned? */\r\n    return SCPE_ARG;                                    /* not a valid parity specifier */\r\n\r\nif (config.stopbits == 1)                               /* assign stop bits */\r\n    dcb.StopBits = ONESTOPBIT;\r\nelse if (config.stopbits == 2)\r\n    dcb.StopBits = TWOSTOPBITS;\r\nelse if (config.stopbits == 0)                          /* 0 implies 1.5 stop bits */\r\n    dcb.StopBits = ONE5STOPBITS;\r\nelse\r\n    return SCPE_ARG;                                    /* not a valid number of stop bits */\r\n\r\nif (!SetCommState (port->hPort, &dcb)) {                /* set the configuration */\r\n    error = GetLastError ();                            /* check for error */\r\n\r\n    if (error == ERROR_INVALID_PARAMETER)               /* invalid configuration? */\r\n        return SCPE_ARG;                                /* report as argument error */\r\n\r\n    sim_error_serial (\"SetCommState\", (int) error);     /* function failed; report unexpected error */\r\n    return SCPE_IOERR;                                  /* return failure status */\r\n    }\r\n\r\nreturn SCPE_OK;                                         /* return success status */\r\n}\r\n\r\n\r\n/* Control a serial port.\r\n\r\n   The DTR and RTS line of the serial port is set or cleared as indicated in\r\n   the respective bits_to_set or bits_to_clear parameters.  If the\r\n   incoming_bits parameter is not NULL, then the modem status bits DCD, RNG,\r\n   DSR and CTS are returned.\r\n\r\n   If unreasonable or nonsense bits_to_set or bits_to_clear bits are\r\n   specified, then the return status is SCPE_ARG;\r\n   If an error occurs, SCPE_IOERR is returned.\r\n*/\r\n\r\nt_stat sim_control_serial (SERHANDLE port, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits)\r\n{\r\nif ((bits_to_set & ~(TMXR_MDM_OUTGOING)) ||         /* Assure only settable bits */\r\n    (bits_to_clear & ~(TMXR_MDM_OUTGOING)) ||\r\n    (bits_to_set & bits_to_clear))                  /* and can't set and clear the same bits */\r\n    return SCPE_ARG;\r\nif (bits_to_set&TMXR_MDM_DTR)\r\n    if (!EscapeCommFunction (port->hPort, SETDTR)) {\r\n        sim_error_serial (\"EscapeCommFunction\", (int) GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\nif (bits_to_clear&TMXR_MDM_DTR)\r\n    if (!EscapeCommFunction (port->hPort, CLRDTR)) {\r\n        sim_error_serial (\"EscapeCommFunction\", (int) GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\nif (bits_to_set&TMXR_MDM_RTS)\r\n    if (!EscapeCommFunction (port->hPort, SETRTS)) {\r\n        sim_error_serial (\"EscapeCommFunction\", (int) GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\nif (bits_to_clear&TMXR_MDM_RTS)\r\n    if (!EscapeCommFunction (port->hPort, CLRRTS)) {\r\n        sim_error_serial (\"EscapeCommFunction\", (int) GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\nif (incoming_bits) {\r\n    DWORD ModemStat;\r\n    if (!GetCommModemStatus (port->hPort, &ModemStat)) {\r\n        sim_error_serial (\"GetCommModemStatus\", (int) GetLastError ());\r\n        return SCPE_IOERR;\r\n        }\r\n    *incoming_bits = ((ModemStat&MS_CTS_ON)  ? TMXR_MDM_CTS : 0) |\r\n                     ((ModemStat&MS_DSR_ON)  ? TMXR_MDM_DSR : 0) |\r\n                     ((ModemStat&MS_RING_ON) ? TMXR_MDM_RNG : 0) |\r\n                     ((ModemStat&MS_RLSD_ON) ? TMXR_MDM_DCD : 0);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Read from a serial port.\r\n\r\n   The port is checked for available characters.  If any are present, they are\r\n   copied to the passed buffer, and the count of characters is returned.  If no\r\n   characters are available, 0 is returned.  If an error occurs, -1 is returned.\r\n   If a BREAK is detected on the communications line, the corresponding flag in\r\n   the \"brk\" array is set.\r\n\r\n   Implementation notes:\r\n\r\n    1. The \"ClearCommError\" function will set the CE_BREAK flag in the returned\r\n       errors value if a BREAK has occurred.  However, we do not know where in\r\n       the serial stream it happened, as CE_BREAK isn't associated with a\r\n       specific character.  Because the \"brk\" array does want a flag associated\r\n       with a specific character, we guess at the proper location by setting\r\n       the \"brk\" entry corresponding to the first NUL in the character stream.\r\n       If no NUL is present, then the \"brk\" entry associated with the first\r\n       character is set.\r\n*/\r\n\r\nint32 sim_read_serial (SERHANDLE port, char *buffer, int32 count, char *brk)\r\n{\r\nDWORD read;\r\nDWORD commerrors;\r\nCOMSTAT cs;\r\nchar *bptr;\r\n\r\nmemset (brk, 0, count);                                 /* start with no break indicators */\r\nif (!ClearCommError (port->hPort, &commerrors, &cs)) {  /* get the comm error flags  */\r\n    sim_error_serial (\"ClearCommError\",                 /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    return -1;                                          /* return failure to caller */\r\n    }\r\n\r\nif (!ReadFile (port->hPort, (LPVOID) buffer,            /* read any available characters */\r\n               (DWORD) count, &read, &port->oReadSync)) {\r\n    sim_error_serial (\"ReadFile\",                       /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    return -1;                                          /* return failure to caller */\r\n    }\r\n\r\nif (commerrors & CE_BREAK) {                            /* was a BREAK detected? */\r\n    bptr = (char *) memchr (buffer, 0, read);           /* search for the first NUL in the buffer */\r\n\r\n    if (bptr)                                           /* was one found? */\r\n        brk = brk + (bptr - buffer);                    /* calculate corresponding position */\r\n\r\n    *brk = 1;                                           /* set the BREAK flag */\r\n    }\r\n\r\nreturn read;                                            /* return the number of characters read */\r\n}\r\n\r\n\r\n/* Write to a serial port.\r\n\r\n   \"Count\" characters are written from \"buffer\" to the serial port.  The actual\r\n   number of characters written to the port is returned.  If an error occurred\r\n   on writing, -1 is returned.\r\n*/\r\n\r\nint32 sim_write_serial (SERHANDLE port, char *buffer, int32 count)\r\n{\r\nif ((!WriteFile (port->hPort, (LPVOID) buffer,   /* write the buffer to the serial port */\r\n                 (DWORD) count, NULL, &port->oWriteSync)) &&\r\n    (GetLastError () != ERROR_IO_PENDING)) {\r\n    sim_error_serial (\"WriteFile\",              /* function failed; report unexpected error */\r\n                      (int) GetLastError ());\r\n    return -1;                                  /* return failure to caller */\r\n    }\r\nreturn count;                                   /* return number of characters written/queued */\r\n}\r\n\r\n\r\n/* Close a serial port.\r\n\r\n   The serial port is closed.  Errors are ignored.\r\n*/\r\n\r\nstatic void sim_close_os_serial (SERHANDLE port)\r\n{\r\nif (port->oWriteReady.hEvent)\r\n    CloseHandle (port->oWriteReady.hEvent);               /* close the event handle */\r\nif (port->oReadSync.hEvent)\r\n    CloseHandle (port->oReadSync.hEvent);               /* close the event handle */\r\nif (port->oWriteSync.hEvent)\r\n    CloseHandle (port->oWriteSync.hEvent);              /* close the event handle */\r\nif (port->hPort)\r\n    CloseHandle (port->hPort);                          /* close the port */\r\nfree (port);\r\n}\r\n\r\n\r\n\r\n#elif defined (__unix__) || defined(__APPLE__) || defined(__hpux)\r\n\r\nstruct SERPORT {\r\n    int port;\r\n    };\r\n\r\n#if defined(__linux) || defined(__linux__)\r\n#include <dirent.h>\r\n#include <libgen.h>\r\n#include <unistd.h>\r\n#include <sys/stat.h>\r\n#endif /* __linux__ */\r\n\r\n/* UNIX implementation */\r\n\r\n/* Enumerate the available serial ports.\r\n\r\n   The serial port names generated by attempting to open /dev/ttyS0 thru\r\n   /dev/ttyS63 and /dev/ttyUSB0 thru /dev/ttyUSB63 and /dev/tty.serial0\r\n   thru /dev/tty.serial63.  Ones we can open and are ttys (as determined\r\n   by isatty()) are added to the list.  The list is sorted alphabetically\r\n   by device name.\r\n\r\n*/\r\n\r\nstatic int sim_serial_os_devices (int max, SERIAL_LIST* list)\r\n{\r\nint i;\r\nint port;\r\nint ports = 0;\r\n\r\nmemset(list, 0, max*sizeof(*list));\r\n#if defined(__linux) || defined(__linux__)\r\nif (1) {\r\n    struct dirent **namelist = NULL;\r\n    struct stat st;\r\n\r\n    i = scandir(\"/sys/class/tty/\", &namelist, NULL, NULL);\r\n\r\n    while (0 < i--) {\r\n        if (strcmp(namelist[i]->d_name, \".\") &&\r\n            strcmp(namelist[i]->d_name, \"..\")) {\r\n            char path[1024], devicepath[1024], driverpath[1024];\r\n\r\n            snprintf (path, sizeof (path), \"/sys/class/tty/%s\", namelist[i]->d_name);\r\n            snprintf (devicepath, sizeof (devicepath), \"/sys/class/tty/%s/device\", namelist[i]->d_name);\r\n            snprintf (driverpath, sizeof (driverpath), \"/sys/class/tty/%s/device/driver\", namelist[i]->d_name);\r\n            if ((lstat(devicepath, &st) == 0) && S_ISLNK(st.st_mode)) {\r\n                char buffer[1024];\r\n\r\n                memset (buffer, 0, sizeof(buffer));\r\n                if (readlink(driverpath, buffer, sizeof(buffer)) > 0) {\r\n                    snprintf (list[ports].name, sizeof (list[ports].name), \"/dev/%s\", basename (path));\r\n                    port = open (list[ports].name, O_RDWR | O_NOCTTY | O_NONBLOCK);     /* open the port */\r\n                    if (port != -1) {                   /* open OK? */\r\n                        if ((ports < max) &&            /* room for another? */\r\n                            (isatty (port)))            /* is device a TTY? */\r\n                            ++ports;\r\n                        close (port);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        free (namelist[i]);\r\n        }\r\n    free (namelist);\r\n    }\r\n#elif defined(__hpux)\r\nfor (i=0; (ports < max) && (i < 64); ++i) {\r\n    snprintf (list[ports].name, sizeof (list[ports].name), \"/dev/tty%dp%d\", i/8, i%8);\r\n    port = open (list[ports].name, O_RDWR | O_NOCTTY | O_NONBLOCK);     /* open the port */\r\n    if (port != -1) {                                   /* open OK? */\r\n        if (isatty (port))                              /* is device a TTY? */\r\n            ++ports;\r\n        close (port);\r\n        }\r\n    }\r\n#else /* Non Linux/HP-UX, just try some well known device names */\r\n/* modern UNIX serial port names - usually USB */\r\nstatic char *serial_unix_serial_names[] = { \"S\", \"U\", \"USB\", \".serial\", \".usbserial\", NULL};\r\nchar **sp;\r\n\r\nfor (sp = serial_unix_serial_names; *sp; sp++) {\r\n    for (i=0; (ports < max) && (i <= 64); ++i) {\r\n        if (i < 64)\r\n            snprintf (list[ports].name, sizeof (list[ports].name), \"/dev/tty%s%d\", *sp, i);\r\n        else    /* no trailing number */\r\n            snprintf (list[ports].name, sizeof (list[ports].name), \"/dev/tty%s\", *sp);\r\n        port = open (list[ports].name, O_RDWR | O_NOCTTY | O_NONBLOCK);     /* open the port */\r\n        if (port != -1) {                                   /* open OK? */\r\n            if (isatty (port))                              /* is device a TTY? */\r\n                ++ports;\r\n            close (port);\r\n            }\r\n        }\r\n    }\r\n/* now the traditional UNIX serial port names */\r\nfor (i=0; (ports < max) && (i < 64); ++i) {\r\n    snprintf (list[ports].name, sizeof (list[ports].name), \"/dev/tty%02d\", i);\r\n    port = open (list[ports].name, O_RDWR | O_NOCTTY | O_NONBLOCK);     /* open the port */\r\n    if (port != -1) {                                   /* open OK? */\r\n        if (isatty (port))                              /* is device a TTY? */\r\n            ++ports;\r\n        close (port);\r\n        }\r\n    }\r\n\r\n#endif\r\nreturn ports;\r\n}\r\n\r\n/* Open a serial port.\r\n\r\n   The serial port designated by \"name\" is opened, and the handle to the port is\r\n   returned.  If an error occurs, INVALID_HANDLE is returned instead.  After\r\n   opening, the port is configured to \"raw\" mode.\r\n\r\n   Implementation notes:\r\n\r\n    1. We use a non-blocking open to allow for polling during reads.\r\n\r\n    2. There is no way to limit \"open\" just to serial ports, so we must check\r\n       after the port is opened.  We do this with a combination of \"isatty\" and\r\n       \"tcgetattr\".\r\n\r\n    3. We configure with PARMRK set and IGNBRK and BRKINT cleared.  This will\r\n       mark a communication line BREAK condition in the input stream with the\r\n       three-character sequence \\377 \\000 \\000.  This is detected during\r\n       reading.\r\n*/\r\n\r\nstatic SERHANDLE sim_open_os_serial (char *name)\r\n{\r\nstatic const tcflag_t i_clear = IGNBRK |                /* ignore BREAK */\r\n                                BRKINT |                /* signal on BREAK */\r\n                                INPCK  |                /* enable parity checking */\r\n                                ISTRIP |                /* strip character to 7 bits */\r\n                                INLCR  |                /* map NL to CR */\r\n                                IGNCR  |                /* ignore CR */\r\n                                ICRNL  |                /* map CR to NL */\r\n                                IXON   |                /* enable XON/XOFF output control */\r\n                                IXOFF;                  /* enable XON/XOFF input control */\r\n\r\nstatic const tcflag_t i_set   = PARMRK |                /* mark parity errors and line breaks */\r\n                                IGNPAR;                 /* ignore parity errors */\r\n\r\nstatic const tcflag_t o_clear = OPOST;                  /* post-process output */\r\n\r\nstatic const tcflag_t o_set   = 0;\r\n\r\nstatic const tcflag_t c_clear = HUPCL;                  /* hang up line on last close */\r\n\r\nstatic const tcflag_t c_set   = CREAD |                 /* enable receiver */\r\n                                CLOCAL;                 /* ignore modem status lines */\r\n\r\nstatic const tcflag_t l_clear = ISIG    |               /* enable signals */\r\n                                ICANON  |               /* canonical input */\r\n                                ECHO    |               /* echo characters */\r\n                                ECHOE   |               /* echo ERASE as an error correcting backspace */\r\n                                ECHOK   |               /* echo KILL */\r\n                                ECHONL  |               /* echo NL */\r\n                                NOFLSH  |               /* disable flush after interrupt */\r\n                                TOSTOP  |               /* send SIGTTOU for background output */\r\n                                IEXTEN;                 /* enable extended functions */\r\n\r\nstatic const tcflag_t l_set   = 0;\r\nint port;\r\nSERHANDLE serport;\r\nstruct termios tio;\r\n\r\nport = open (name, O_RDWR | O_NOCTTY | O_NONBLOCK);     /* open the port */\r\n\r\nif (port == -1) {                                       /* open failed? */\r\n    if (errno != ENOENT && errno != EACCES)             /* file not found or can't open? */\r\n        sim_error_serial (\"open\", errno);               /* no, so report unexpected error */\r\n\r\n    return INVALID_HANDLE;                              /* indicate failure to caller */\r\n    }\r\n\r\nif (!isatty (port)) {                                   /* is device a TTY? */\r\n    close (port);                                       /* no, so close it */\r\n    return INVALID_HANDLE;                              /*   and return failure to caller */\r\n    }\r\n\r\nif (tcgetattr (port, &tio)) {                           /* get the terminal attributes */\r\n    sim_error_serial (\"tcgetattr\", errno);              /* function failed; report unexpected error */\r\n    close (port);                                       /* close the port */\r\n    return INVALID_HANDLE;                              /*   and return failure to caller */\r\n    }\r\n\r\ntio.c_iflag = (tio.c_iflag & ~i_clear) | i_set;           /* configure the serial line for raw mode */\r\ntio.c_oflag = (tio.c_oflag & ~o_clear) | o_set;\r\ntio.c_cflag = (tio.c_cflag & ~c_clear) | c_set;\r\ntio.c_lflag = (tio.c_lflag & ~l_clear) | l_set;\r\n#ifdef VMIN\r\ntio.c_cc[VMIN] = 1;\r\n#endif\r\n#ifdef VTIME\r\ntio.c_cc[VTIME] = 0;\r\n#endif\r\n\r\nif (tcsetattr (port, TCSANOW, &tio)) {                  /* set the terminal attributes */\r\n    sim_error_serial (\"tcsetattr\", errno);              /* function failed; report unexpected error */\r\n    close (port);                                       /* close the port */\r\n    return INVALID_HANDLE;                              /*   and return failure to caller */\r\n    }\r\n\r\nserport = (SERHANDLE)calloc (1, sizeof(*serport));\r\nserport->port = port;\r\nreturn serport;                                         /* return port fd for success */\r\n}\r\n\r\n\r\n/* Configure a serial port.\r\n\r\n   Port parameters are configured as specified in the \"config\" structure.  If\r\n   \"config\" contains an invalid configuration value, or if the host system\r\n   rejects the configuration (e.g., by requesting an unsupported combination of\r\n   character size and stop bits), SCPE_ARG is returned to the caller.  If an\r\n   unexpected error occurs, SCPE_IOERR is returned.  If the configuration\r\n   succeeds, SCPE_OK is returned.\r\n\r\n   Implementation notes:\r\n\r\n    1. 1.5 stop bits is not a supported configuration.\r\n\r\n*/\r\n\r\nstatic t_stat sim_config_os_serial (SERHANDLE port, SERCONFIG config)\r\n{\r\nstruct termios tio;\r\nint32 i;\r\n\r\nstatic const struct {\r\n    uint32  rate;\r\n    speed_t rate_code;\r\n    } baud_map [] =\r\n        { { 50,     B50     }, { 75,     B75     }, { 110,    B110    }, {  134,   B134   },\r\n          { 150,    B150    }, { 200,    B200    }, { 300,    B300    }, {  600,   B600   },\r\n          { 1200,   B1200   }, { 1800,   B1800   }, { 2400,   B2400   }, {  4800,  B4800  },\r\n          { 9600,   B9600   }, { 19200,  B19200  }, { 38400,  B38400  }, {  57600, B57600 },\r\n          { 115200, B115200 } };\r\n\r\nstatic const int32 baud_count = sizeof (baud_map) / sizeof (baud_map [0]);\r\n\r\nstatic const tcflag_t charsize_map [4] = { CS5, CS6, CS7, CS8 };\r\n\r\n\r\nif (tcgetattr (port->port, &tio)) {                     /* get the current configuration */\r\n    sim_error_serial (\"tcgetattr\", errno);              /* function failed; report unexpected error */\r\n    return SCPE_IOERR;                                  /* return failure status */\r\n    }\r\n\r\nfor (i = 0; i < baud_count; i++)                        /* assign baud rate */\r\n    if (config.baudrate == baud_map [i].rate) {         /* match mapping value? */\r\n        cfsetispeed(&tio, baud_map [i].rate_code);      /* set input rate */\r\n        cfsetospeed(&tio, baud_map [i].rate_code);      /* set output rate */\r\n        break;\r\n        }\r\n\r\nif (i == baud_count)                                    /* baud rate assigned? */\r\n    return SCPE_ARG;                                    /* invalid rate specified */\r\n\r\nif ((config.charsize >= 5) && (config.charsize <= 8))   /* character size OK? */\r\n    tio.c_cflag = (tio.c_cflag & ~CSIZE) |              /* replace character size code */\r\n                charsize_map [config.charsize - 5];\r\nelse\r\n    return SCPE_ARG;                                    /* not a valid size */\r\n\r\nswitch (config.parity) {                                /* assign parity */\r\n    case 'E':\r\n        tio.c_cflag = (tio.c_cflag & ~PARODD) | PARENB; /* set for even parity */\r\n        break;\r\n\r\n    case 'N':\r\n        tio.c_cflag = tio.c_cflag & ~PARENB;            /* set for no parity */\r\n        break;\r\n\r\n    case 'O':\r\n        tio.c_cflag = tio.c_cflag | PARODD | PARENB;    /* set for odd parity */\r\n        break;\r\n\r\n    default:\r\n        return SCPE_ARG;                                /* not a valid parity specifier */\r\n    }\r\n\r\nif (config.stopbits == 1)                               /* one stop bit? */\r\n    tio.c_cflag = tio.c_cflag & ~CSTOPB;                /* clear two-bits flag */\r\nelse if (config.stopbits == 2)                          /* two stop bits? */\r\n    tio.c_cflag = tio.c_cflag | CSTOPB;                 /* set two-bits flag */\r\nelse                                                    /* some other number? */\r\n    return SCPE_ARG;                                    /* not a valid number of stop bits */\r\n\r\nif (tcsetattr (port->port, TCSAFLUSH, &tio)) {          /* set the new configuration */\r\n    sim_error_serial (\"tcsetattr\", errno);              /* function failed; report unexpected error */\r\n    return SCPE_IERR;                                   /* return failure status */\r\n    }\r\n\r\nreturn SCPE_OK;                                         /* configuration set successfully */\r\n}\r\n\r\n\r\n/* Control a serial port.\r\n\r\n   The DTR and RTS line of the serial port is set or cleared as indicated in\r\n   the respective bits_to_set or bits_to_clear parameters.  If the\r\n   incoming_bits parameter is not NULL, then the modem status bits DCD, RNG,\r\n   DSR and CTS are returned.\r\n\r\n   If unreasonable or nonsense bits_to_set or bits_to_clear bits are\r\n   specified, then the return status is SCPE_ARG;\r\n   If an error occurs, SCPE_IOERR is returned.\r\n*/\r\n\r\nt_stat sim_control_serial (SERHANDLE port, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits)\r\n{\r\nint bits;\r\n\r\nif ((bits_to_set & ~(TMXR_MDM_OUTGOING)) ||         /* Assure only settable bits */\r\n    (bits_to_clear & ~(TMXR_MDM_OUTGOING)) ||\r\n    (bits_to_set & bits_to_clear))                  /* and can't set and clear the same bits */\r\n    return SCPE_ARG;\r\nif (bits_to_set) {\r\n    bits = ((bits_to_set&TMXR_MDM_DTR) ? TIOCM_DTR : 0) |\r\n           ((bits_to_set&TMXR_MDM_RTS) ? TIOCM_RTS : 0);\r\n    if (ioctl (port->port, TIOCMBIS, &bits)) {      /* set the desired bits */\r\n        sim_error_serial (\"ioctl\", errno);          /* report unexpected error */\r\n        return SCPE_IOERR;                          /* return failure status */\r\n        }\r\n    }\r\nif (bits_to_clear) {\r\n    bits = ((bits_to_clear&TMXR_MDM_DTR) ? TIOCM_DTR : 0) |\r\n           ((bits_to_clear&TMXR_MDM_RTS) ? TIOCM_RTS : 0);\r\n    if (ioctl (port->port, TIOCMBIC, &bits)) {      /* clear the desired bits */\r\n        sim_error_serial (\"ioctl\", errno);          /* report unexpected error */\r\n        return SCPE_IOERR;                          /* return failure status */\r\n        }\r\n    }\r\nif (incoming_bits) {\r\n    if (ioctl (port->port, TIOCMGET, &bits)) {      /* get the modem bits */\r\n        sim_error_serial (\"ioctl\", errno);          /* report unexpected error */\r\n        return SCPE_IOERR;                          /* return failure status */\r\n        }\r\n    *incoming_bits = ((bits&TIOCM_CTS) ? TMXR_MDM_CTS : 0) |\r\n                     ((bits&TIOCM_DSR) ? TMXR_MDM_DSR : 0) |\r\n                     ((bits&TIOCM_RNG) ? TMXR_MDM_RNG : 0) |\r\n                     ((bits&TIOCM_CAR) ? TMXR_MDM_DCD : 0);\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Read from a serial port.\r\n\r\n   The port is checked for available characters.  If any are present, they are\r\n   copied to the passed buffer, and the count of characters is returned.  If no\r\n   characters are available, 0 is returned.  If an error occurs, -1 is returned.\r\n   If a BREAK is detected on the communications line, the corresponding flag in\r\n   the \"brk\" array is set.\r\n\r\n   Implementation notes:\r\n\r\n    1. A character with a framing or parity error is indicated in the input\r\n       stream by the three-character sequence \\377 \\000 \\ccc, where \"ccc\" is the\r\n       bad character.  A communications line BREAK is indicated by the sequence\r\n       \\377 \\000 \\000.  A received \\377 character is indicated by the\r\n       two-character sequence \\377 \\377.  If we find any of these sequences,\r\n       they are replaced by the single intended character by sliding the\r\n       succeeding characters backward by one or two positions.  If a BREAK\r\n       sequence was encountered, the corresponding location in the \"brk\" array\r\n       is determined, and the flag is set.  Note that there may be multiple\r\n       sequences in the buffer.\r\n*/\r\n\r\nint32 sim_read_serial (SERHANDLE port, char *buffer, int32 count, char *brk)\r\n{\r\nint read_count;\r\nchar *bptr, *cptr;\r\nint32 remaining;\r\n\r\nread_count = read (port->port, (void *) buffer, (size_t) count);/* read from the serial port */\r\n\r\nif (read_count == -1)                                       /* read error? */\r\n    if (errno == EAGAIN)                                    /* no characters available? */\r\n        return 0;                                           /* return 0 to indicate */\r\n    else                                                    /* some other problem */\r\n        sim_error_serial (\"read\", errno);                   /* report unexpected error */\r\n\r\nelse {                                                      /* read succeeded */\r\n    cptr = buffer;                                          /* point at start of buffer */\r\n    remaining = read_count - 1;                             /* stop search one char from end of string */\r\n\r\n    while (remaining > 0 &&                                 /* still characters to search? */\r\n           (bptr = (char*)memchr (cptr, '\\377', remaining))) {/* search for start of PARMRK sequence */\r\n        remaining = remaining - (bptr - cptr) - 1;          /* calc characters remaining */\r\n\r\n        if (*(bptr + 1) == '\\377') {                        /* is it a \\377 \\377 sequence? */\r\n            memmove (bptr + 1, bptr + 2, remaining);        /* slide string backward to leave first \\377 */\r\n            remaining = remaining - 1;                      /* drop remaining count */\r\n            read_count = read_count - 1;                    /*   and read count by char eliminated */\r\n            }\r\n\r\n        else if (remaining > 0 && *(bptr + 1) == '\\0') {    /* is it a \\377 \\000 \\ccc sequence? */\r\n            memmove (bptr, bptr + 2, remaining);            /* slide string backward to leave \\ccc */\r\n            remaining = remaining - 2;                      /* drop remaining count */\r\n            read_count = read_count - 2;                    /*   and read count by chars eliminated */\r\n\r\n            if (*bptr == '\\0')                              /* is it a BREAK sequence? */\r\n                *(brk + (bptr - buffer)) = 1;               /* set corresponding BREAK flag */\r\n            }\r\n\r\n        cptr = bptr + 1;                                    /* point at remainder of string */\r\n        }\r\n    }\r\n\r\nreturn (int32) read_count;                                  /* return the number of characters read */\r\n}\r\n\r\n\r\n/* Write to a serial port.\r\n\r\n   \"Count\" characters are written from \"buffer\" to the serial port.  The actual\r\n   number of characters written to the port is returned.  If an error occurred\r\n   on writing, -1 is returned.\r\n*/\r\n\r\nint32 sim_write_serial (SERHANDLE port, char *buffer, int32 count)\r\n{\r\nint written;\r\n\r\nwritten = write (port->port, (void *) buffer, (size_t) count);/* write the buffer to the serial port */\r\n\r\nif (written == -1) {\r\n    if (errno == EWOULDBLOCK)\r\n        written = 0;                                        /* not an error, but nothing written */\r\n#if defined(EAGAIN)\r\n    else if (errno == EAGAIN)\r\n        written = 0;                                        /* not an error, but nothing written */\r\n#endif\r\n    else                                                    /* unexpected error? */\r\n        sim_error_serial (\"write\", errno);                  /* report it */\r\n    }\r\n\r\nreturn (int32) written;                                     /* return number of characters written */\r\n}\r\n\r\n\r\n/* Close a serial port.\r\n\r\n   The serial port is closed.  Errors are ignored.\r\n*/\r\n\r\nstatic void sim_close_os_serial (SERHANDLE port)\r\n{\r\nclose (port->port);                                           /* close the port */\r\nfree (port);\r\n}\r\n\r\n\r\n#elif defined (VMS)\r\n\r\n/* VMS implementation */\r\n\r\n#if defined(__VAX)\r\n#define sys$assign SYS$ASSIGN\r\n#define sys$qio SYS$QIO\r\n#define sys$qiow SYS$QIOW\r\n#define sys$dassgn SYS$DASSGN\r\n#define sys$device_scan SYS$DEVICE_SCAN\r\n#define sys$getdviw SYS$GETDVIW\r\n#endif\r\n\r\n#include <descrip.h>\r\n#include <ttdef.h>\r\n#include <tt2def.h>\r\n#include <iodef.h>\r\n#include <ssdef.h>\r\n#include <dcdef.h>\r\n#include <dvsdef.h>\r\n#include <dvidef.h>\r\n#include <starlet.h>\r\n#include <unistd.h>\r\n\r\ntypedef struct {\r\n    unsigned short sense_count;\r\n    unsigned char sense_first_char;\r\n    unsigned char sense_reserved;\r\n    unsigned int stat;\r\n    unsigned int stat2; } SENSE_BUF;\r\n\r\ntypedef struct {\r\n    unsigned short status;\r\n    unsigned short count;\r\n    unsigned int dev_status; } IOSB;\r\n\r\ntypedef struct {\r\n    unsigned short buffer_size;\r\n    unsigned short item_code;\r\n    void *buffer_address;\r\n    void *return_length_address;\r\n    } ITEM;\r\n\r\nstruct SERPORT {\r\n    uint32 port;\r\n    IOSB write_iosb;\r\n    };\r\n\r\n/* Enumerate the available serial ports.\r\n\r\n   The serial port names generated by attempting to open /dev/ttyS0 thru\r\n   /dev/ttyS53 and /dev/ttyUSB0 thru /dev/ttyUSB0.  Ones we can open and\r\n   are ttys (as determined by isatty()) are added to the list.  The list\r\n   is sorted alphabetically by device name.\r\n\r\n*/\r\n\r\nstatic int sim_serial_os_devices (int max, SERIAL_LIST* list)\r\n{\r\n$DESCRIPTOR (wild, \"*\");\r\nchar devstr[sizeof(list[0].name)];\r\n$DESCRIPTOR (device, devstr);\r\nint ports;\r\nIOSB iosb;\r\nuint32 status;\r\nuint32 devsts;\r\n#define UCB$M_TEMPLATE 0x2000       /* Device is a template device */\r\n#define UCB$M_ONLINE   0x0010       /* Device is online */\r\nuint32 devtype;\r\nuint32 devdepend;\r\n#define DEV$M_RTM 0x20000000\r\nuint32 devnamlen = 0;\r\nt_bool done = FALSE;\r\nuint32 context[2];\r\nuint32 devclass = DC$_TERM; /* Only interested in terminal devices */\r\nITEM select_items[] = { {sizeof (devclass), DVS$_DEVCLASS, &devclass, NULL},\r\n                        {                  0,               0,        NULL, NULL}};\r\nITEM valid_items[] =  { {    sizeof (devsts),        DVI$_STS,     &devsts, NULL},\r\n                        {     sizeof(devstr),     DVI$_DEVNAM,      devstr, &devnamlen},\r\n                        {    sizeof(devtype),    DVI$_DEVTYPE,    &devtype, NULL},\r\n                        {  sizeof(devdepend),  DVI$_DEVDEPEND,  &devdepend, NULL},\r\n                        {                  0,               0,        NULL, NULL}};\r\n\r\nmemset(context, 0, sizeof(context));\r\nmemset(devstr, 0, sizeof(devstr));\r\nmemset(list, 0, max*sizeof(*list));\r\nfor (ports=0; (ports < max); ++ports) {\r\n    device.dsc$w_length = sizeof (devstr) - 1;\r\n    status = sys$device_scan (&device,\r\n                              &device.dsc$w_length,\r\n                              &wild,\r\n                              select_items,\r\n                              &context);\r\n    switch (status) {\r\n        case SS$_NOSUCHDEV:\r\n        case SS$_NOMOREDEV:\r\n            done = TRUE;\r\n            break;\r\n        default:\r\n            if (0 == (status&1))\r\n                done = TRUE;\r\n            else {\r\n                status = sys$getdviw (0, 0, &device, valid_items, &iosb, NULL, 0, NULL);\r\n                if (status == SS$_NORMAL)\r\n                    status = iosb.status;\r\n                if (status != SS$_NORMAL) {\r\n                    done = TRUE;\r\n                    break;\r\n                    }\r\n                device.dsc$w_length = devnamlen;\r\n                if ((0 == (devsts & UCB$M_TEMPLATE)) &&\r\n                    (0 != (devsts & UCB$M_ONLINE)) &&\r\n                    (0 == (devdepend & DEV$M_RTM))) {\r\n                    devstr[device.dsc$w_length] = '\\0';\r\n                    strcpy (list[ports].name, devstr);\r\n                    while (list[ports].name[0] == '_')\r\n                        strcpy (list[ports].name, list[ports].name+1);\r\n                    }\r\n                else\r\n                    --ports;\r\n                }\r\n            break;\r\n        }\r\n    if (done)\r\n        break;\r\n    }\r\nreturn ports;\r\n}\r\n\r\n/* Open a serial port.\r\n\r\n   The serial port designated by \"name\" is opened, and the handle to the port is\r\n   returned.  If an error occurs, INVALID_HANDLE is returned instead.  After\r\n   opening, the port is configured to \"raw\" mode.\r\n\r\n   Implementation notes:\r\n\r\n    1. We use a non-blocking open to allow for polling during reads.\r\n\r\n    2. There is no way to limit \"open\" just to serial ports, so we must check\r\n       after the port is opened.  We do this with sys$getdvi.\r\n\r\n*/\r\n\r\nstatic SERHANDLE sim_open_os_serial (char *name)\r\n{\r\nuint32 status;\r\nuint32 chan = 0;\r\nIOSB iosb;\r\n$DESCRIPTOR (devnam, name);\r\nuint32 devclass;\r\nITEM items[] = { {sizeof (devclass), DVI$_DEVCLASS, &devclass, NULL},\r\n                 {                0,             0,      NULL, NULL}};\r\nSENSE_BUF start_mode = { 0 };\r\nSENSE_BUF run_mode = { 0 };\r\nSERHANDLE port;\r\n\r\ndevnam.dsc$w_length = strlen (devnam.dsc$a_pointer);\r\nstatus = sys$assign (&devnam, &chan, 0, 0);\r\nif (status != SS$_NORMAL)\r\n    return INVALID_HANDLE;\r\nstatus = sys$getdviw (0, chan, NULL, items, &iosb, NULL, 0, NULL);\r\nif ((status != SS$_NORMAL)      ||\r\n    (iosb.status != SS$_NORMAL) ||\r\n    (devclass != DC$_TERM)) {\r\n    sys$dassgn (chan);\r\n    return INVALID_HANDLE;\r\n    }\r\nstatus = sys$qiow (0, chan, IO$_SENSEMODE, &iosb, 0, 0,\r\n    &start_mode, sizeof (start_mode), 0, 0, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL)) {\r\n    sys$dassgn (chan);\r\n    return INVALID_HANDLE;\r\n    }\r\nrun_mode = start_mode;\r\nrun_mode.stat = start_mode.stat | TT$M_NOECHO & ~(TT$M_HOSTSYNC | TT$M_TTSYNC | TT$M_HALFDUP);\r\nrun_mode.stat2 = start_mode.stat2 | TT2$M_PASTHRU;\r\nstatus = sys$qiow (0, chan, IO$_SETMODE, &iosb, 0, 0,\r\n    &run_mode, sizeof (run_mode), 0, 0, 0, 0);\r\nif ((status != SS$_NORMAL) || (iosb.status != SS$_NORMAL)) {\r\n    sys$dassgn (chan);\r\n    return INVALID_HANDLE;\r\n    }\r\nport = (SERHANDLE)calloc (1, sizeof(*port));\r\nport->port = chan;\r\nport->write_iosb.status = 1;\r\nreturn port;                                            /* return channel for success */\r\n}\r\n\r\n\r\n/* Configure a serial port.\r\n\r\n   Port parameters are configured as specified in the \"config\" structure.  If\r\n   \"config\" contains an invalid configuration value, or if the host system\r\n   rejects the configuration (e.g., by requesting an unsupported combination of\r\n   character size and stop bits), SCPE_ARG is returned to the caller.  If an\r\n   unexpected error occurs, SCPE_IOERR is returned.  If the configuration\r\n   succeeds, SCPE_OK is returned.\r\n\r\n   Implementation notes:\r\n\r\n    1. 1.5 stop bits is not a supported configuration.\r\n\r\n*/\r\n\r\nstatic t_stat sim_config_os_serial (SERHANDLE port, SERCONFIG config)\r\n{\r\nint32 i;\r\nSENSE_BUF sense;\r\nuint32 status, speed, parity, charsize, stopbits;\r\nIOSB iosb;\r\nstatic const struct {\r\n    uint32  rate;\r\n    uint32  rate_code;\r\n    } baud_map [] =\r\n        { { 50,     TT$C_BAUD_50     }, { 75,     TT$C_BAUD_75     }, { 110,    TT$C_BAUD_110    }, {  134,   TT$C_BAUD_134   },\r\n          { 150,    TT$C_BAUD_150    }, { 300,    TT$C_BAUD_300    }, {  600,   TT$C_BAUD_600    }, {  1200,  TT$C_BAUD_1200  },\r\n          { 1800,   TT$C_BAUD_1800   }, { 2000,   TT$C_BAUD_2000   }, { 2400,   TT$C_BAUD_2400   }, {  3600,  TT$C_BAUD_3600  },\r\n          { 4800,   TT$C_BAUD_4800   }, { 7200,   TT$C_BAUD_7200   }, { 9600,   TT$C_BAUD_9600   }, { 19200,  TT$C_BAUD_19200 },\r\n          { 38400,  TT$C_BAUD_38400  }, { 57600,  TT$C_BAUD_57600  }, { 76800,  TT$C_BAUD_76800  }, { 115200, TT$C_BAUD_115200} };\r\n\r\nstatic const int32 baud_count = sizeof (baud_map) / sizeof (baud_map [0]);\r\n\r\nstatus = sys$qiow (0, port->port, IO$_SENSEMODE, &iosb, 0, 0, &sense, sizeof(sense), 0, NULL, 0, 0);\r\nif (status == SS$_NORMAL)\r\n    status = iosb.status;\r\nif (status != SS$_NORMAL) {\r\n    sim_error_serial (\"config-SENSEMODE\", status);      /* report unexpected error */\r\n    return SCPE_IOERR;\r\n    }\r\n\r\nfor (i = 0; i < baud_count; i++)                        /* assign baud rate */\r\n    if (config.baudrate == baud_map [i].rate) {         /* match mapping value? */\r\n        speed = baud_map [i].rate_code << 8 |           /* set input rate */\r\n                baud_map [i].rate_code;                 /* set output rate */\r\n        break;\r\n        }\r\n\r\nif (i == baud_count)                                    /* baud rate assigned? */\r\n    return SCPE_ARG;                                    /* invalid rate specified */\r\n\r\nif (config.charsize >= 5 && config.charsize <= 8)       /* character size OK? */\r\n    charsize = TT$M_ALTFRAME | config.charsize;         /* set character size */\r\nelse\r\n    return SCPE_ARG;                                    /* not a valid size */\r\n\r\nswitch (config.parity) {                                /* assign parity */\r\n    case 'E':\r\n        parity = TT$M_ALTRPAR | TT$M_PARITY;            /* set for even parity */\r\n        break;\r\n\r\n    case 'N':\r\n        parity = TT$M_ALTRPAR;                          /* set for no parity */\r\n        break;\r\n\r\n    case 'O':\r\n        parity = TT$M_ALTRPAR | TT$M_PARITY | TT$M_ODD; /* set for odd parity */\r\n        break;\r\n\r\n    default:\r\n        return SCPE_ARG;                                /* not a valid parity specifier */\r\n    }\r\n\r\n\r\nswitch (config.stopbits) {\r\n    case 1:                                             /* one stop bit? */\r\n        stopbits = 0;\r\n        break;\r\n    case 2:                                             /* two stop bits? */\r\n        if ((speed & 0xff) <= TT$C_BAUD_150) {          /* Only valid for */\r\n            stopbits = TT$M_TWOSTOP;                    /* speeds 150baud or less */\r\n            break;\r\n            }\r\n    default:\r\n        return SCPE_ARG;                                /* not a valid number of stop bits */\r\n    }\r\n\r\nstatus = sys$qiow (0, port->port, IO$_SETMODE, &iosb, 0, 0,\r\n    &sense, sizeof (sense), speed, 0, parity | charsize | stopbits, 0);\r\nif (status == SS$_NORMAL)\r\n    status = iosb.status;\r\nif (status != SS$_NORMAL) {\r\n    sim_error_serial (\"config-SETMODE\", status);        /* report unexpected error */\r\n    return SCPE_IOERR;\r\n    }\r\nreturn SCPE_OK;                                         /* configuration set successfully */\r\n}\r\n\r\n\r\n/* Control a serial port.\r\n\r\n   The DTR and RTS line of the serial port is set or cleared as indicated in\r\n   the respective bits_to_set or bits_to_clear parameters.  If the\r\n   incoming_bits parameter is not NULL, then the modem status bits DCD, RNG,\r\n   DSR and CTS are returned.\r\n\r\n   If unreasonable or nonsense bits_to_set or bits_to_clear bits are\r\n   specified, then the return status is SCPE_ARG;\r\n   If an error occurs, SCPE_IOERR is returned.\r\n*/\r\n\r\nt_stat sim_control_serial (SERHANDLE port, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits)\r\n{\r\nuint32 status;\r\nIOSB iosb;\r\nuint32 bits[2] = {0, 0};\r\n\r\nif ((bits_to_set & ~(TMXR_MDM_OUTGOING)) ||         /* Assure only settable bits */\r\n    (bits_to_clear & ~(TMXR_MDM_OUTGOING)) ||\r\n    (bits_to_set & bits_to_clear))                  /* and can't set and clear the same bits */\r\n    return SCPE_ARG;\r\nif (bits_to_set)\r\n    bits[0] |= (((bits_to_set&TMXR_MDM_DTR) ? TT$M_DS_DTR : 0) |\r\n                ((bits_to_set&TMXR_MDM_RTS) ? TT$M_DS_RTS : 0)) << 16;\r\nif (bits_to_clear)\r\n    bits[0] |= (((bits_to_clear&TMXR_MDM_DTR) ? TT$M_DS_DTR : 0) |\r\n                ((bits_to_clear&TMXR_MDM_RTS) ? TT$M_DS_RTS : 0)) << 24;\r\nif (bits_to_set || bits_to_clear) {\r\n    status = sys$qiow (0, port->port, IO$_SETMODE|IO$M_SET_MODEM|IO$M_MAINT, &iosb, 0, 0,\r\n                       bits, 0, 0, 0, 0, 0);\r\n    if (status == SS$_NORMAL)\r\n        status = iosb.status;\r\n    if (status != SS$_NORMAL) {\r\n        sim_error_serial (\"control-SETMODE\", status);      /* report unexpected error */\r\n        return SCPE_IOERR;\r\n        }\r\n    }\r\nif (incoming_bits) {\r\n    uint32 modem;\r\n\r\n    status = sys$qiow (0, port->port, IO$_SENSEMODE|IO$M_RD_MODEM, &iosb, 0, 0,\r\n                       bits, 0, 0, 0, 0, 0);\r\n    if (status == SS$_NORMAL)\r\n        status = iosb.status;\r\n    if (status != SS$_NORMAL) {\r\n        sim_error_serial (\"control-SENSEMODE\", status);      /* report unexpected error */\r\n        return SCPE_IOERR;\r\n        }\r\n    modem = bits[0] >> 16;\r\n    *incoming_bits = ((modem&TT$M_DS_CTS)     ? TMXR_MDM_CTS : 0) |\r\n                     ((modem&TT$M_DS_DSR)     ? TMXR_MDM_DSR : 0) |\r\n                     ((modem&TT$M_DS_RING)    ? TMXR_MDM_RNG : 0) |\r\n                     ((modem&TT$M_DS_CARRIER) ? TMXR_MDM_DCD : 0);\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Read from a serial port.\r\n\r\n   The port is checked for available characters.  If any are present, they are\r\n   copied to the passed buffer, and the count of characters is returned.  If no\r\n   characters are available, 0 is returned.  If an error occurs, -1 is returned.\r\n   If a BREAK is detected on the communications line, the corresponding flag in\r\n   the \"brk\" array is set.\r\n\r\n   Implementation notes:\r\n\r\n    1. A character with a framing or parity error is indicated in the input\r\n       stream by the three-character sequence \\377 \\000 \\ccc, where \"ccc\" is the\r\n       bad character.  A communications line BREAK is indicated by the sequence\r\n       \\377 \\000 \\000.  A received \\377 character is indicated by the\r\n       two-character sequence \\377 \\377.  If we find any of these sequences,\r\n       they are replaced by the single intended character by sliding the\r\n       succeeding characters backward by one or two positions.  If a BREAK\r\n       sequence was encountered, the corresponding location in the \"brk\" array\r\n       is determined, and the flag is set.  Note that there may be multiple\r\n       sequences in the buffer.\r\n*/\r\n\r\nint32 sim_read_serial (SERHANDLE port, char *buffer, int32 count, char *brk)\r\n{\r\nint read_count = 0;\r\nuint32 status;\r\nstatic uint32 term[2] = {0, 0};\r\nunsigned char buf[4];\r\nIOSB iosb;\r\nSENSE_BUF sense;\r\n\r\nstatus = sys$qiow (0, port->port, IO$_SENSEMODE | IO$M_TYPEAHDCNT, &iosb,\r\n    0, 0, &sense, 8, 0, term, 0, 0);\r\nif (status == SS$_NORMAL)\r\n    status = iosb.status;\r\nif (status != SS$_NORMAL) {\r\n    sim_error_serial (\"read\", status);                      /* report unexpected error */\r\n    return -1;\r\n    }\r\nif (sense.sense_count == 0)                                 /* no characters available? */\r\n    return 0;                                               /* return 0 to indicate */\r\nstatus = sys$qiow (0, port->port, IO$_READLBLK | IO$M_NOECHO | IO$M_NOFILTR | IO$M_TIMED | IO$M_TRMNOECHO,\r\n                   &iosb, 0, 0, buffer, (count < sense.sense_count) ? count : sense.sense_count, 0, term, 0, 0);\r\nif (status == SS$_NORMAL)\r\n    status = iosb.status;\r\nif (status != SS$_NORMAL) {\r\n    sim_error_serial (\"read\", status);                      /* report unexpected error */\r\n    return -1;\r\n    }\r\nreturn (int32)iosb.count;                                   /* return the number of characters read */\r\n}\r\n\r\n\r\n/* Write to a serial port.\r\n\r\n   \"Count\" characters are written from \"buffer\" to the serial port.  The actual\r\n   number of characters written to the port is returned.  If an error occurred\r\n   on writing, -1 is returned.\r\n*/\r\n\r\nint32 sim_write_serial (SERHANDLE port, char *buffer, int32 count)\r\n{\r\nuint32 status;\r\n\r\nif (port->write_iosb.status == 0)           /* Prior write not done yet? */\r\n    return 0;\r\nstatus = sys$qio (0, port->port, IO$_WRITELBLK | IO$M_NOFORMAT,\r\n                  &port->write_iosb, 0, 0, buffer, count, 0, 0, 0, 0);\r\nif (status != SS$_NORMAL) {\r\n    sim_error_serial (\"write\", status);                 /* report unexpected error */\r\n    return -1;\r\n    }\r\nreturn (int32)count;                                    /* return number of characters written */\r\n}\r\n\r\n\r\n/* Close a serial port.\r\n\r\n   The serial port is closed.  Errors are ignored.\r\n*/\r\n\r\nstatic void sim_close_os_serial (SERHANDLE port)\r\n{\r\nsys$dassgn (port->port);                                /* close the port */\r\nfree (port);\r\n}\r\n\r\n#else\r\n\r\n/* Non-implemented stubs */\r\n\r\n/* Enumerate the available serial ports. */\r\n\r\nstatic int sim_serial_os_devices (int max, SERIAL_LIST* list)\r\n{\r\nreturn 0;\r\n}\r\n\r\n/* Open a serial port */\r\n\r\nstatic SERHANDLE sim_open_os_serial (char *name)\r\n{\r\nreturn INVALID_HANDLE;\r\n}\r\n\r\n\r\n/* Configure a serial port */\r\n\r\nstatic t_stat sim_config_os_serial (SERHANDLE port, SERCONFIG config)\r\n{\r\nreturn SCPE_IERR;\r\n}\r\n\r\n\r\n/* Control a serial port */\r\n\r\nt_stat sim_control_serial (SERHANDLE port, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\n\r\n/* Read from a serial port */\r\n\r\nint32 sim_read_serial (SERHANDLE port, char *buffer, int32 count, char *brk)\r\n{\r\nreturn -1;\r\n}\r\n\r\n\r\n/* Write to a serial port */\r\n\r\nint32 sim_write_serial (SERHANDLE port, char *buffer, int32 count)\r\n{\r\nreturn -1;\r\n}\r\n\r\n\r\n/* Close a serial port */\r\n\r\nstatic void sim_close_os_serial (SERHANDLE port)\r\n{\r\n}\r\n\r\n\r\n\r\n#endif                                                  /* end else !implemented */\r\n"
        },
        {
          "name": "sim_serial.h",
          "type": "blob",
          "size": 3.8603515625,
          "content": "/* sim_serial.h: OS-dependent serial port routines header file\r\n\r\n   Copyright (c) 2008, J. David Bryan, Mark Pizzolato\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n\r\n   07-Oct-08    JDB     [serial] Created file\r\n   22-Apr-12    MP      Adapted from code originally written by J. David Bryan\r\n\r\n*/\r\n\r\n\r\n#ifndef SIM_SERIAL_H_\r\n#define SIM_SERIAL_H_    0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifndef SIMH_SERHANDLE_DEFINED\r\n#define SIMH_SERHANDLE_DEFINED 0\r\ntypedef struct SERPORT *SERHANDLE;\r\n#endif /* SERHANDLE_DEFINED */\r\n\r\n#if defined (_WIN32)                        /* Windows definitions */\r\n\r\n/* We need the basic Win32 definitions, but including \"windows.h\" also includes\r\n   \"winsock.h\" as well.  However, \"sim_sock.h\" explicitly includes \"winsock2.h,\"\r\n   and this file cannot coexist with \"winsock.h\".  So we set a guard definition\r\n   that prevents \"winsock.h\" from being included.\r\n*/\r\n\r\n#ifndef WIN32_LEAN_AND_MEAN\r\n#define WIN32_LEAN_AND_MEAN\r\n#endif\r\n#include <windows.h>\r\n#if !defined(INVALID_HANDLE)\r\n#define INVALID_HANDLE  (SERHANDLE)INVALID_HANDLE_VALUE\r\n#endif /* !defined(INVALID_HANDLE) */\r\n\r\n#elif defined (__unix__) || defined (__APPLE__) || defined (__hpux) /* UNIX definitions */\r\n\r\n#include <fcntl.h>\r\n#ifdef __hpux\r\n#include <sys/modem.h>\r\n#endif\r\n#include <termios.h>\r\n#include <unistd.h>\r\n#include <sys/ioctl.h>\r\n\r\n#if !defined(INVALID_HANDLE)\r\n#define INVALID_HANDLE  ((SERHANDLE)(void *)-1)\r\n#endif /* !defined(INVALID_HANDLE) */\r\n\r\n#elif defined (VMS)                             /* VMS definitions */\r\n#if !defined(INVALID_HANDLE)\r\n#define INVALID_HANDLE  ((SERHANDLE)(void *)-1)\r\n#endif /* !defined(INVALID_HANDLE) */\r\n\r\n#else                                           /* Non-implemented definitions */\r\n\r\n#if !defined(INVALID_HANDLE)\r\n#define INVALID_HANDLE  ((SERHANDLE)(void *)-1)\r\n#endif /* !defined(INVALID_HANDLE) */\r\n\r\n#endif  /* OS variants */\r\n\r\n\r\n/* Common definitions */\r\n\r\n/* Global routines */\r\n#include \"sim_tmxr.h\"                           /* need TMLN definition and modem definitions */\r\n\r\nextern SERHANDLE sim_open_serial    (char *name, TMLN *lp, t_stat *status);\r\nextern t_stat    sim_config_serial  (SERHANDLE port, CONST char *config);\r\nextern t_stat    sim_control_serial (SERHANDLE port, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits);\r\nextern int32     sim_read_serial    (SERHANDLE port, char *buffer, int32 count, char *brk);\r\nextern int32     sim_write_serial   (SERHANDLE port, char *buffer, int32 count);\r\nextern void      sim_close_serial   (SERHANDLE port);\r\nextern t_stat    sim_show_serial    (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char* desc);\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_sock.c",
          "type": "blob",
          "size": 48.0986328125,
          "content": "/* sim_sock.c: OS-dependent socket routines\r\n\r\n   Copyright (c) 2001-2010, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   15-Oct-12    MP      Added definitions needed to detect possible tcp \r\n                        connect failures\r\n   25-Sep-12    MP      Reworked for RFC3493 interfaces supporting IPv6 and IPv4\r\n   22-Jun-10    RMS     Fixed types in sim_accept_conn (from Mark Pizzolato)\r\n   19-Nov-05    RMS     Added conditional for OpenBSD (from Federico G. Schwindt)\r\n   16-Aug-05    RMS     Fixed spurious SIGPIPE signal error in Unix\r\n   14-Apr-05    RMS     Added WSAEINPROGRESS test (from Tim Riker)\r\n   09-Jan-04    RMS     Fixed typing problem in Alpha Unix (found by Tim Chapman)\r\n   17-Apr-03    RMS     Fixed non-implemented version of sim_close_sock\r\n                        (found by Mark Pizzolato)\r\n   17-Dec-02    RMS     Added sim_connect_socket, sim_create_socket\r\n   08-Oct-02    RMS     Revised for .NET compatibility\r\n   22-Aug-02    RMS     Changed calling sequence for sim_accept_conn\r\n   22-May-02    RMS     Added OS2 EMX support from Holger Veit\r\n   06-Feb-02    RMS     Added VMS support from Robert Alan Byer\r\n   16-Sep-01    RMS     Added Macintosh support from Peter Schorn\r\n   02-Sep-01    RMS     Fixed UNIX bugs found by Mirian Lennox and Tom Markson\r\n*/\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"sim_sock.h\"\r\n#include <signal.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#if defined(AF_INET6) && defined(_WIN32)\r\n#include <ws2tcpip.h>\r\n#endif\r\n\r\n#ifdef SIM_HAVE_DLOPEN\r\n#include <dlfcn.h>\r\n#endif\r\n\r\n#ifndef WSAAPI\r\n#define WSAAPI\r\n#endif\r\n\r\n#if !defined(SD_BOTH)\r\n#define SD_BOTH SHUT_RDWR\r\n#endif\r\n\r\n#ifndef   NI_MAXHOST\r\n#define   NI_MAXHOST 1025\r\n#endif\r\n\r\n/* OS dependent routines\r\n\r\n   sim_master_sock      create master socket\r\n   sim_connect_sock     connect a socket to a remote destination\r\n   sim_connect_sock_ex  connect a socket to a remote destination\r\n   sim_accept_conn      accept connection\r\n   sim_read_sock        read from socket\r\n   sim_write_sock       write from socket\r\n   sim_close_sock       close socket\r\n   sim_setnonblock      set socket non-blocking\r\n*/\r\n\r\n\r\n/* UNIX, Win32, Macintosh, VMS, OS2 (Berkeley socket) routines */\r\n\r\nstatic struct sock_errors {\r\n    int value;\r\n    const char *text;\r\n    } sock_errors[] = {\r\n        {WSAEWOULDBLOCK,  \"Operation would block\"},\r\n        {WSAENAMETOOLONG, \"File name too long\"},\r\n        {WSAEINPROGRESS,  \"Operation now in progress \"},\r\n        {WSAETIMEDOUT,    \"Connection timed out\"},\r\n        {WSAEISCONN,      \"Transport endpoint is already connected\"},\r\n        {WSAECONNRESET,   \"Connection reset by peer\"},\r\n        {WSAECONNREFUSED, \"Connection refused\"},\r\n        {WSAECONNABORTED, \"Connection aborted\"},\r\n        {WSAEHOSTUNREACH, \"No route to host\"},\r\n        {WSAEADDRINUSE,   \"Address already in use\"},\r\n#if defined (WSAEAFNOSUPPORT)\r\n        {WSAEAFNOSUPPORT, \"Address family not supported by protocol\"},\r\n#endif\r\n        {WSAEACCES,       \"Permission denied\"},\r\n        {0, NULL}\r\n    };\r\n\r\n\r\nconst char *sim_get_err_sock (const char *emsg)\r\n{\r\nint err = WSAGetLastError ();\r\nint i;\r\nstatic char err_buf[512];\r\n\r\nfor (i=0; (sock_errors[i].text) && (sock_errors[i].value != err); i++)\r\n    ;\r\nif (sock_errors[i].value == err)\r\n    sprintf (err_buf, \"Sockets: %s error %d - %s\\n\", emsg, err, sock_errors[i].text);\r\nelse\r\n#if defined(_WIN32)\r\n    sprintf (err_buf, \"Sockets: %s error %d\\n\", emsg, err);\r\n#else\r\n    sprintf (err_buf, \"Sockets: %s error %d - %s\\n\", emsg, err, strerror(err));\r\n#endif\r\nreturn err_buf;\r\n}\r\n\r\nSOCKET sim_err_sock (SOCKET s, const char *emsg)\r\n{\r\nsim_printf (\"%s\", sim_get_err_sock (emsg));\r\nif (s != INVALID_SOCKET) {\r\n    int err = WSAGetLastError ();\r\n    sim_close_sock (s);\r\n    WSASetLastError (err);      /* Retain Original socket error value */\r\n    }\r\nreturn INVALID_SOCKET;\r\n}\r\n\r\ntypedef void    (WSAAPI *freeaddrinfo_func) (struct addrinfo *ai);\r\nstatic freeaddrinfo_func p_freeaddrinfo;\r\n\r\ntypedef int     (WSAAPI *getaddrinfo_func) (const char *hostname,\r\n                                 const char *service,\r\n                                 const struct addrinfo *hints,\r\n                                 struct addrinfo **res);\r\nstatic getaddrinfo_func p_getaddrinfo;\r\n\r\n#if defined(VMS)\r\ntypedef size_t socklen_t;\r\n#if !defined(EAI_OVERFLOW)\r\n#define EAI_OVERFLOW EAI_FAIL\r\n#endif\r\n#endif\r\n\r\n#if defined(__hpux)\r\n#if !defined(EAI_OVERFLOW)\r\n#define EAI_OVERFLOW EAI_FAIL\r\n#endif\r\n#endif\r\n\r\ntypedef int (WSAAPI *getnameinfo_func) (const struct sockaddr *sa, socklen_t salen, char *host, size_t hostlen, char *serv, size_t servlen, int flags);\r\nstatic getnameinfo_func p_getnameinfo;\r\n\r\nstatic void    WSAAPI s_freeaddrinfo (struct addrinfo *ai)\r\n{\r\nstruct addrinfo *a, *an;\r\n\r\nfor (a=ai; a != NULL; a=an) {\r\n    an = a->ai_next;\r\n    free (a->ai_canonname);\r\n    free (a->ai_addr);\r\n    free (a);\r\n    }\r\n}\r\n\r\nstatic int     WSAAPI s_getaddrinfo (const char *hostname,\r\n                                     const char *service,\r\n                                     const struct addrinfo *hints,\r\n                                     struct addrinfo **res)\r\n{\r\nstruct hostent *he;\r\nstruct servent *se = NULL;\r\nstruct sockaddr_in *sin;\r\nstruct addrinfo *result = NULL;\r\nstruct addrinfo *ai, *lai = NULL;\r\nstruct addrinfo dhints;\r\nstruct in_addr ipaddr;\r\nstruct in_addr *fixed[2];\r\nstruct in_addr **ips = NULL;\r\nstruct in_addr **ip;\r\nconst char *cname = NULL;\r\nint port = 0;\r\n\r\n// Validate parameters\r\nif ((hostname == NULL) && (service == NULL))\r\n    return EAI_NONAME;\r\n\r\nif (hints) {\r\n    if ((hints->ai_family != PF_INET) && (hints->ai_family != PF_UNSPEC))\r\n        return EAI_FAMILY;\r\n    switch (hints->ai_socktype)\r\n        {\r\n        default:\r\n            return EAI_SOCKTYPE;\r\n        case SOCK_DGRAM:\r\n        case SOCK_STREAM:\r\n        case 0:\r\n            break;\r\n        }\r\n    }\r\nelse {\r\n    hints = &dhints;\r\n    memset(&dhints, 0, sizeof(dhints));\r\n    dhints.ai_family = PF_UNSPEC;\r\n    }\r\nif (service) {\r\n    char *c;\r\n\r\n    port = strtoul(service, &c, 10);\r\n    port = htons((unsigned short)port);\r\n    if ((port == 0) || (*c != '\\0')) {\r\n        switch (hints->ai_socktype)\r\n            {\r\n            case SOCK_DGRAM:\r\n                se = getservbyname(service, \"udp\");\r\n                break;\r\n            case SOCK_STREAM:\r\n            case 0:\r\n                se = getservbyname(service, \"tcp\");\r\n                break;\r\n            }\r\n        if (NULL == se)\r\n            return EAI_SERVICE;\r\n        port = se->s_port;\r\n        }\r\n    }\r\n\r\nif (hostname) {\r\n    if ((0xffffffff != (ipaddr.s_addr = inet_addr(hostname))) || \r\n        (0 == strcmp(\"255.255.255.255\", hostname))) {\r\n        fixed[0] = &ipaddr;\r\n        fixed[1] = NULL;\r\n        if ((hints->ai_flags & AI_CANONNAME) && !(hints->ai_flags & AI_NUMERICHOST)) {\r\n            he = gethostbyaddr((char *)&ipaddr, 4, AF_INET);\r\n            if (NULL != he)\r\n                cname = he->h_name;\r\n            else\r\n                cname = hostname;\r\n            }\r\n        ips = fixed;\r\n        }\r\n    else {\r\n        if (hints->ai_flags & AI_NUMERICHOST)\r\n            return EAI_NONAME;\r\n        he = gethostbyname(hostname);\r\n        if (he) {\r\n            ips = (struct in_addr **)he->h_addr_list;\r\n            if (hints->ai_flags & AI_CANONNAME)\r\n                cname = he->h_name;\r\n            }\r\n        else {\r\n            switch (h_errno)\r\n                {\r\n                case HOST_NOT_FOUND:\r\n                case NO_DATA:\r\n                    return EAI_NONAME;\r\n                case TRY_AGAIN:\r\n                    return EAI_AGAIN;\r\n                default:\r\n                    return EAI_FAIL;\r\n                }\r\n            }\r\n        }\r\n    }\r\nelse {\r\n    if (hints->ai_flags & AI_PASSIVE)\r\n        ipaddr.s_addr = htonl(INADDR_ANY);\r\n    else\r\n        ipaddr.s_addr = htonl(INADDR_LOOPBACK);\r\n    fixed[0] = &ipaddr;\r\n    fixed[1] = NULL;\r\n    ips = fixed;\r\n    }\r\nfor (ip=ips; (ip != NULL) && (*ip != NULL); ++ip) {\r\n    ai = (struct addrinfo *)calloc(1, sizeof(*ai));\r\n    if (NULL == ai) {\r\n        s_freeaddrinfo(result);\r\n        return EAI_MEMORY;\r\n        }\r\n    ai->ai_family = PF_INET;\r\n    ai->ai_socktype = hints->ai_socktype;\r\n    ai->ai_protocol = hints->ai_protocol;\r\n    ai->ai_addr = NULL;\r\n    ai->ai_addrlen = sizeof(struct sockaddr_in);\r\n    ai->ai_canonname = NULL;\r\n    ai->ai_next = NULL;\r\n    ai->ai_addr = (struct sockaddr *)calloc(1, sizeof(struct sockaddr_in));\r\n    if (NULL == ai->ai_addr) {\r\n        free(ai);\r\n        s_freeaddrinfo(result);\r\n        return EAI_MEMORY;\r\n        }\r\n    sin = (struct sockaddr_in *)ai->ai_addr;\r\n    sin->sin_family = PF_INET;\r\n    sin->sin_port = (unsigned short)port;\r\n    memcpy(&sin->sin_addr, *ip, sizeof(sin->sin_addr));\r\n    if (NULL == result)\r\n        result = ai;\r\n    else\r\n        lai->ai_next = ai;\r\n    lai = ai;\r\n    }\r\nif (cname) {\r\n    result->ai_canonname = (char *)calloc(1, strlen(cname)+1);\r\n    if (NULL == result->ai_canonname) {\r\n        s_freeaddrinfo(result);\r\n        return EAI_MEMORY;\r\n        }\r\n    strcpy(result->ai_canonname, cname);\r\n    }\r\n*res = result;\r\nreturn 0;\r\n}\r\n\r\n#ifndef EAI_OVERFLOW\r\n#define EAI_OVERFLOW WSAENAMETOOLONG\r\n#endif\r\n\r\nstatic int     WSAAPI s_getnameinfo (const struct sockaddr *sa, socklen_t salen,\r\n                                     char *host, size_t hostlen,\r\n                                     char *serv, size_t servlen,\r\n                                     int flags)\r\n{\r\nstruct hostent *he;\r\nstruct servent *se = NULL;\r\nconst struct sockaddr_in *sin = (const struct sockaddr_in *)sa;\r\n\r\nif (sin->sin_family != PF_INET)\r\n    return EAI_FAMILY;\r\nif ((NULL == host) && (NULL == serv))\r\n    return EAI_NONAME;\r\nif ((serv) && (servlen > 0)) {\r\n    if (flags & NI_NUMERICSERV)\r\n        se = NULL;\r\n    else\r\n        if (flags & NI_DGRAM)\r\n            se = getservbyport(sin->sin_port, \"udp\");\r\n        else\r\n            se = getservbyport(sin->sin_port, \"tcp\");\r\n    if (se) {\r\n        if (servlen <= strlen(se->s_name))\r\n            return EAI_OVERFLOW;\r\n        strcpy(serv, se->s_name);\r\n        }\r\n    else {\r\n        char buf[16];\r\n\r\n        sprintf(buf, \"%d\", ntohs(sin->sin_port));\r\n        if (servlen <= strlen(buf))\r\n            return EAI_OVERFLOW;\r\n        strcpy(serv, buf);\r\n        }\r\n    }\r\nif ((host) && (hostlen > 0)) {\r\n    if (flags & NI_NUMERICHOST)\r\n        he = NULL;\r\n    else\r\n        he = gethostbyaddr((const char *)&sin->sin_addr, 4, AF_INET);\r\n    if (he) {\r\n        if (hostlen < strlen(he->h_name)+1)\r\n            return EAI_OVERFLOW;\r\n        strcpy(host, he->h_name);\r\n        }\r\n    else {\r\n        if (flags & NI_NAMEREQD)\r\n            return EAI_NONAME;\r\n        if (hostlen < strlen(inet_ntoa(sin->sin_addr))+1)\r\n            return EAI_OVERFLOW;\r\n        strcpy(host, inet_ntoa(sin->sin_addr));\r\n        }\r\n    }\r\nreturn 0;\r\n}\r\n\r\n#if defined(_WIN32) || defined(__CYGWIN__)\r\n\r\n#if !defined(IPV6_V6ONLY)           /* Older XP environments may not define IPV6_V6ONLY */\r\n#define IPV6_V6ONLY           27    /* Treat wildcard bind as AF_INET6-only. */\r\n#endif\r\n#if defined(TEST_INFO_STUBS)\r\n#undef IPV6_V6ONLY\r\n#undef AF_INET6\r\n#endif\r\n/* Dynamic DLL load variables */\r\n#ifdef _WIN32\r\nstatic HINSTANCE hLib = 0;                      /* handle to DLL */\r\n#else\r\nstatic void *hLib = NULL;                       /* handle to Library */\r\n#endif\r\nstatic int lib_loaded = 0;                      /* 0=not loaded, 1=loaded, 2=library load failed, 3=Func load failed */\r\nstatic const char* lib_name = \"Ws2_32.dll\";\r\n\r\n/* load function pointer from DLL */\r\ntypedef int (*_func)();\r\n\r\nstatic void load_function(const char* function, _func* func_ptr) {\r\n#ifdef _WIN32\r\n    *func_ptr = (_func)GetProcAddress(hLib, function);\r\n#else\r\n    *func_ptr = (_func)dlsym(hLib, function);\r\n#endif\r\n    if (*func_ptr == 0) {\r\n    sim_printf (\"Sockets: Failed to find function '%s' in %s\\r\\n\", function, lib_name);\r\n    lib_loaded = 3;\r\n  }\r\n}\r\n\r\n/* load Ws2_32.dll as required */\r\nint load_ws2(void) {\r\n  switch(lib_loaded) {\r\n    case 0:                  /* not loaded */\r\n            /* attempt to load DLL */\r\n#ifdef _WIN32\r\n      hLib = LoadLibraryA(lib_name);\r\n#else\r\n      hLib = dlopen(lib_name, RTLD_NOW);\r\n#endif\r\n      if (hLib == 0) {\r\n        /* failed to load DLL */\r\n        sim_printf (\"Sockets: Failed to load %s\\r\\n\", lib_name);\r\n        lib_loaded = 2;\r\n        break;\r\n      } else {\r\n        /* library loaded OK */\r\n        lib_loaded = 1;\r\n      }\r\n\r\n      /* load required functions; sets dll_load=3 on error */\r\n      load_function(\"getaddrinfo\",       (_func *) &p_getaddrinfo);\r\n      load_function(\"getnameinfo\",       (_func *) &p_getnameinfo);\r\n      load_function(\"freeaddrinfo\",      (_func *) &p_freeaddrinfo);\r\n\r\n      if (lib_loaded != 1) {\r\n        /* unsuccessful load, connect stubs */\r\n        p_getaddrinfo = (getaddrinfo_func)s_getaddrinfo;\r\n        p_getnameinfo = (getnameinfo_func)s_getnameinfo;\r\n        p_freeaddrinfo = (freeaddrinfo_func)s_freeaddrinfo;\r\n      }\r\n      break;\r\n    default:                /* loaded or failed */\r\n      break;\r\n  }\r\n  return (lib_loaded == 1) ? 1 : 0;\r\n}\r\n#endif\r\n\r\n/* OS independent routines\r\n\r\n   sim_parse_addr       parse a hostname/ipaddress from port and apply defaults \r\n                        and optionally validate an address match\r\n   sim_addr_acl_check   parse a hostname/ipaddress (possibly in CIDR form) and \r\n                        test against an acl\r\n*/\r\n\r\n/* sim_parse_addr       host:port\r\n\r\n   Presumption is that the cptr input, if it doesn't contain a ':' character \r\n   is a port specifier.  If the host field contains one or more colon characters \r\n   (i.e. it is an IPv6 address), the IPv6 address MUST be enclosed in square \r\n   bracket characters (i.e. Domain Literal format)\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n        host    =       optional pointer to host buffer\r\n        host_len =      length of host buffer\r\n        default_host =  optional pointer to default host if none specified \r\n                        in cptr\r\n        port    =       optional pointer to port buffer\r\n        port_len =      length of port buffer\r\n        default_port =  optional pointer to default port if none specified \r\n                        in cptr\r\n        validate_addr = optional name/addr which is checked to be equivalent\r\n                        to the host result of parsing the other input.  This\r\n                        address would usually be returned by sim_accept_conn.\r\n                        The validate_addr can also be a CIDR address specifier\r\n                        which will match against the provided host.\r\n                        If the validate_addr is provided with cptr as NULL,\r\n                        the validate_addr is parsed for reasonableness and \r\n                        the result returned with 0 indicating a reasonable \r\n                        value and -1 indicating a parsing error.\r\n   Outputs:\r\n        host    =       pointer to buffer for IP address (may be NULL), 0 = none\r\n        port    =       pointer to buffer for IP port (may be NULL), 0 = none\r\n        result  =       status (0 on complete success or -1 if \r\n                        parsing can't happen due to bad syntax, a value is \r\n                        out of range, a result can't fit into a result buffer, \r\n                        a service name doesn't exist, or a validation name \r\n                        doesn't match the parsed host)\r\n*/\r\n\r\nint sim_parse_addr (const char *cptr, char *host, size_t host_len, const char *default_host, \r\n                                      char *port, size_t port_len, const char *default_port, \r\n                                      const char *validate_addr)\r\n{\r\nchar gbuf[CBUFSIZE], default_pbuf[CBUFSIZE];\r\nconst char *hostp;\r\nchar *portp;\r\nchar *endc;\r\nunsigned long portval;\r\n\r\nif ((host != NULL) && (host_len != 0))\r\n    memset (host, 0, host_len);\r\nif ((port != NULL) && (port_len != 0))\r\n    memset (port, 0, port_len);\r\nif ((cptr == NULL) || (*cptr == 0)) {\r\n    if (((default_host == NULL) || (*default_host == 0)) || \r\n        ((default_port == NULL) || (*default_port == 0)))\r\n        return -1;\r\n    if ((host == NULL) || (port == NULL))\r\n        return -1;                                  /* no place */\r\n    if ((strlen(default_host) >= host_len) || (strlen(default_port) >= port_len))\r\n        return -1;                                  /* no room */\r\n    strcpy (host, default_host);\r\n    strcpy (port, default_port);\r\n    return 0;\r\n    }\r\nmemset (default_pbuf, 0, sizeof(default_pbuf));\r\nif (default_port)\r\n    strncpy (default_pbuf, default_port, sizeof(default_pbuf)-1);\r\ngbuf[sizeof(gbuf)-1] = '\\0';\r\nstrncpy (gbuf, cptr, sizeof(gbuf)-1);\r\nhostp = gbuf;                                           /* default addr */\r\nportp = NULL;\r\nif ((portp = strrchr (gbuf, ':')) &&                    /* x:y? split */\r\n    (NULL == strchr (portp, ']'))) {\r\n    *portp++ = 0;\r\n    if (*portp == '\\0')\r\n        portp = default_pbuf;\r\n    }\r\nelse {                                                  /* No colon in input */\r\n    portp = gbuf;                                       /* Input is the port specifier */\r\n    hostp = (const char *)default_host;                 /* host is defaulted if provided */\r\n    }\r\nif ((portp != NULL) && (*portp != '\\0')) {\r\n    portval = strtoul(portp, &endc, 10);\r\n    if ((*endc == '\\0') && ((portval == 0) || (portval > 65535)))\r\n        return -1;                                      /* numeric value too big */\r\n    if (*endc != '\\0') {\r\n        struct servent *se = getservbyname(portp, \"tcp\");\r\n\r\n        if (se == NULL)\r\n            return -1;                                  /* invalid service name */\r\n        }\r\n    }\r\nif (port)                                               /* port wanted? */\r\n    if (portp != NULL) {\r\n        if (strlen(portp) >= port_len)\r\n            return -1;                                  /* no room */\r\n        else\r\n            strcpy (port, portp);\r\n        }\r\nif ((hostp != NULL) && (*hostp != '\\0')) {\r\n    if (']' == hostp[strlen(hostp)-1]) {\r\n        if ('[' != hostp[0])\r\n            return -1;                                  /* invalid domain literal */\r\n        /* host may be the const default_host so move to temp buffer before modifying */\r\n        strncpy(gbuf, hostp+1, sizeof(gbuf)-1);         /* remove brackets from domain literal host */\r\n        gbuf[strlen(gbuf)-1] = '\\0';\r\n        hostp = gbuf;\r\n        }\r\n    }\r\nif (host) {                                             /* host wanted? */\r\n    if (hostp != NULL) {\r\n        if (strlen(hostp) >= host_len)\r\n            return -1;                                  /* no room */\r\n        else\r\n            if (('\\0' != hostp[0]) || (default_host == NULL))\r\n                strcpy (host, hostp);\r\n            else\r\n                if (strlen(default_host) >= host_len)\r\n                    return -1;                          /* no room */\r\n                else\r\n                    strcpy (host, default_host);\r\n        }\r\n    else {\r\n        if (default_host) {\r\n            if (strlen(default_host) >= host_len)\r\n                return -1;                              /* no room */\r\n            else\r\n                strcpy (host, default_host);\r\n            }\r\n        }\r\n    }\r\nif (validate_addr) {\r\n    struct addrinfo *ai_host, *ai_validate, *ai, *aiv;\r\n    int status;\r\n\r\n    if ((hostp == NULL) || \r\n        (0 != p_getaddrinfo(hostp, NULL, NULL, &ai_host)))\r\n        return -1;\r\n    if (p_getaddrinfo(validate_addr, NULL, NULL, &ai_validate)) {\r\n        p_freeaddrinfo (ai_host);\r\n        return -1;\r\n        }\r\n    status = -1;\r\n    for (ai = ai_host; (ai != NULL) && (status == -1); ai = ai->ai_next) {\r\n        for (aiv = ai_validate; aiv != NULL; aiv = aiv->ai_next) {\r\n            if ((ai->ai_addrlen == aiv->ai_addrlen) &&\r\n                (ai->ai_family == aiv->ai_family) &&\r\n                (0 == memcmp (ai->ai_addr, aiv->ai_addr, ai->ai_addrlen))) {\r\n                status = 0;\r\n                break;\r\n                }\r\n            }\r\n        }\r\n    if (status != 0) {\r\n        /* be generous and allow successful validations against variations of localhost addresses */\r\n        if (((0 == strcmp(\"127.0.0.1\", hostp)) && \r\n             (0 == strcmp(\"::1\", validate_addr))) ||\r\n            ((0 == strcmp(\"127.0.0.1\", validate_addr)) && \r\n             (0 == strcmp(\"::1\", hostp))))\r\n            status = 0;\r\n        }\r\n    p_freeaddrinfo (ai_host);\r\n    p_freeaddrinfo (ai_validate);\r\n    return status;\r\n    }\r\nreturn 0;\r\n}\r\n\r\n/* sim_addr_acl_check   host:port,acl\r\n\r\n                        parse a hostname/ipaddress (possibly in CIDR form) and \r\n                        test against an acl\r\n\r\n   Inputs:\r\n        validate_addr = This address would usually be returned by \r\n                        sim_accept_conn.  The validate_addr can also be a \r\n                        CIDR address specifier and in that mode, acl should \r\n                        be NULL so that we're just validating the syntax \r\n                        of what will likely become an entry in an acl list.\r\n                        If the validate_addr is provided with cptr as NULL,\r\n                        the validate_addr is parsed for reasonableness and \r\n                        the result returned with 0 indicating a reasonable \r\n                        value and -1 indicating a parsing error.\r\n        acl           = pointer to acl string which is comprised of comma \r\n                        separated entries each which may have a + or - \r\n                        prefix that indicated a permit or deny status when \r\n                        the entry matches.  Each entry may specify a CIDR\r\n                        form match criteria.\r\n   Outputs:\r\n        result  =       status (0 on complete success or -1 if \r\n                        parsing can't happen due to bad syntax, a value is \r\n                        out of range or the validate_addr matches a reject\r\n                        entry in the acl or it is not mentioned at all in \r\n                        the acl.\r\n*/\r\n\r\nint sim_addr_acl_check (const char *validate_addr, const char *acl)\r\n{\r\nint status = -1;\r\nint done = 0;\r\nstruct addrinfo *ai_validate;\r\nunsigned long bits = 0;\r\nconst char *c;\r\nchar *c1, v_cpy[256];\r\n\r\nif (validate_addr == NULL)\r\n    return status;\r\n\r\nc = strchr (validate_addr, '/');\r\nif (c != NULL) {\r\n    bits = strtoul (c + 1, &c1, 10);\r\n    if ((bits == 0) || (bits > 128) || (*c1 != '\\0'))\r\n        return status;\r\n    if ((c - validate_addr) > sizeof (v_cpy) - 1)\r\n        return status;\r\n    memcpy (v_cpy, validate_addr, c - validate_addr);   /* Copy everything before the / */\r\n    v_cpy[c - validate_addr] = '\\0';                    /* NUL terminate the result */\r\n    validate_addr = v_cpy;                              /* Use the original string minus the prefix specifier */\r\n    }\r\nif (p_getaddrinfo(validate_addr, NULL, NULL, &ai_validate))\r\n    return status;\r\nif (acl == NULL) {          /* Just checking validate_addr syntax? */\r\n    status = 0;\r\n    if ((ai_validate->ai_family == AF_INET) && (bits > 32))\r\n        status = -1;\r\n    p_freeaddrinfo (ai_validate);\r\n    return status;\r\n    }\r\nstatus = -1;\r\nwhile ((*acl != '\\0') && !done) {\r\n    struct addrinfo *ai_rule, *ai, *aiv;\r\n    int permit; \r\n    unsigned long bits = 0;\r\n    const char *cc;\r\n    char *c,*c1, rule[260];\r\n\r\n    permit = (*acl == '+');\r\n    cc = strchr (acl, ',');\r\n    if (cc != NULL) {\r\n        if ((cc - acl) > sizeof (rule))\r\n            break;                  /* Too big - error */\r\n        memcpy (rule, acl + 1, cc - (acl + 1));\r\n        rule[cc - (acl + 1)] = '\\0';\r\n        }\r\n    else {\r\n        if (strlen (acl) >= sizeof (rule))\r\n            break;                  /* Too big - error */\r\n        strcpy (rule, acl + 1);\r\n        }\r\n    acl += strlen (rule) + 1 + (cc != NULL);\r\n    c = strchr (rule, '/');\r\n    if (c != NULL) {\r\n        bits = strtoul (c + 1, &c1, 10);\r\n        if ((bits == 0) || (bits > 128) || (*c1 != '\\0'))\r\n            break;\r\n        *c = '\\0';\r\n        }\r\n\r\n    if (p_getaddrinfo(rule, NULL, NULL, &ai_rule))\r\n        break;\r\n\r\n    for (ai = ai_rule; (ai != NULL) && (done == 0); ai = ai->ai_next) {\r\n        for (aiv = ai_validate; aiv != NULL; aiv = aiv->ai_next) {\r\n            if ((ai->ai_addrlen == aiv->ai_addrlen) &&\r\n                (ai->ai_family == aiv->ai_family)) {\r\n                unsigned int bit, addr_bits;\r\n                unsigned char *da, *dav;\r\n               \r\n                if (ai->ai_family == AF_INET) {\r\n                    da = (unsigned char *)&((struct sockaddr_in *)ai->ai_addr)->sin_addr;\r\n                    dav = (unsigned char *)&((struct sockaddr_in *)aiv->ai_addr)->sin_addr;\r\n                    addr_bits = 32;\r\n                    }\r\n    #if !defined(AF_INET6)\r\n                else {\r\n                    done = 1;\r\n                    break;\r\n                    }\r\n    #else\r\n                else {\r\n                    if (ai->ai_family == AF_INET6) {\r\n                        da = (unsigned char *)&((struct sockaddr_in6 *)ai->ai_addr)->sin6_addr;\r\n                        dav = (unsigned char *)&((struct sockaddr_in6 *)aiv->ai_addr)->sin6_addr;\r\n                        addr_bits = 128;\r\n                        }\r\n                    else {\r\n                        done = 1;\r\n                        break;\r\n                        }\r\n                    }\r\n    #endif\r\n                if (bits == 0)          /* Bits not specified? */\r\n                    bits = addr_bits;   /* Use them all */\r\n                for (bit=0; (bit < bits) && (bit < addr_bits); bit++) {\r\n                    unsigned int bitmask = 1 << (7 - (bit & 7));\r\n\r\n                    if ((da[bit>>3] & bitmask) != (dav[bit>>3] & bitmask))\r\n                        break;\r\n                    }\r\n                if (bit == bits) {  /* All desired bits matched? */\r\n                    done = 1;\r\n                    status = permit ? 0 : -1;\r\n                    break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    p_freeaddrinfo (ai_rule);\r\n    }\r\np_freeaddrinfo (ai_validate);\r\nreturn status;\r\n}\r\n\r\n/* sim_parse_addr_ex    localport:host:port\r\n\r\n   Presumption is that the input, if it doesn't contain a ':' character is a port specifier.\r\n   If the host field contains one or more colon characters (i.e. it is an IPv6 address), \r\n   the IPv6 address MUST be enclosed in square bracket characters (i.e. Domain Literal format)\r\n\r\n        llll:w.x.y.z:rrrr\r\n        llll:name.domain.com:rrrr\r\n        llll::rrrr\r\n        rrrr\r\n        w.x.y.z:rrrr\r\n        [w.x.y.z]:rrrr\r\n        name.domain.com:rrrr\r\n\r\n   Inputs:\r\n        cptr    =       pointer to input string\r\n        default_host\r\n                =       optional pointer to default host if none specified\r\n        host_len =      length of host buffer\r\n        default_port\r\n                =       optional pointer to default port if none specified\r\n        port_len =      length of port buffer\r\n\r\n   Outputs:\r\n        host    =       pointer to buffer for IP address (may be NULL), 0 = none\r\n        port    =       pointer to buffer for IP port (may be NULL), 0 = none\r\n        localport\r\n                =       pointer to buffer for local IP port (may be NULL), 0 = none\r\n        result  =       status (0 on complete success or -1 if \r\n                        parsing can't happen due to bad syntax, a value is \r\n                        out of range, a result can't fit into a result buffer, \r\n                        a service name doesn't exist, or a validation name \r\n                        doesn't match the parsed host)\r\n*/\r\nint sim_parse_addr_ex (const char *cptr, char *host, size_t hostlen, const char *default_host, char *port, size_t port_len, char *localport, size_t localport_len, const char *default_port)\r\n{\r\nconst char *hostp;\r\n\r\nif ((localport != NULL) && (localport_len != 0))\r\n    memset (localport, 0, localport_len);\r\nhostp = strchr (cptr, ':');\r\nif ((hostp != NULL) && ((hostp[1] == '[') || (NULL != strchr (hostp+1, ':')))) {\r\n    if ((localport != NULL) && (localport_len != 0)) {\r\n        localport_len -= 1;\r\n        if (localport_len > (size_t)(hostp-cptr))\r\n            localport_len = (size_t)(hostp-cptr);\r\n        memcpy (localport, cptr, localport_len);\r\n        }\r\n    return sim_parse_addr (hostp+1, host, hostlen, default_host, port, port_len, default_port, NULL);\r\n    }\r\nreturn sim_parse_addr (cptr, host, hostlen, default_host, port, port_len, default_port, NULL);\r\n}\r\n\r\n\r\nvoid sim_init_sock (void)\r\n{\r\n#if defined (_WIN32)\r\nint err;\r\nWORD wVersionRequested; \r\nWSADATA wsaData; \r\nwVersionRequested = MAKEWORD (2, 2);\r\n\r\nerr = WSAStartup (wVersionRequested, &wsaData);         /* start Winsock */ \r\nif (err != 0)\r\n    sim_printf (\"Winsock: startup error %d\\n\", err);\r\n#if defined(AF_INET6)\r\nload_ws2 ();\r\n#endif                                                  /* endif AF_INET6 */\r\n#else                                                   /* Use native addrinfo APIs */\r\n#if defined(AF_INET6)\r\n    p_getaddrinfo = (getaddrinfo_func)getaddrinfo;\r\n    p_getnameinfo = (getnameinfo_func)getnameinfo;\r\n    p_freeaddrinfo = (freeaddrinfo_func)freeaddrinfo;\r\n#else\r\n    /* Native APIs not available, connect stubs */\r\n    p_getaddrinfo = (getaddrinfo_func)s_getaddrinfo;\r\n    p_getnameinfo = (getnameinfo_func)s_getnameinfo;\r\n    p_freeaddrinfo = (freeaddrinfo_func)s_freeaddrinfo;\r\n#endif                                                  /* endif AF_INET6 */\r\n#endif                                                  /* endif _WIN32 */\r\n#if defined (SIGPIPE)\r\nsignal (SIGPIPE, SIG_IGN);                              /* no pipe signals */\r\n#endif\r\n#if defined(TEST_INFO_STUBS)\r\n/* force use of stubs */\r\np_getaddrinfo = (getaddrinfo_func)s_getaddrinfo;\r\np_getnameinfo = (getnameinfo_func)s_getnameinfo;\r\np_freeaddrinfo = (freeaddrinfo_func)s_freeaddrinfo;\r\n#endif\r\n}\r\n\r\nvoid sim_cleanup_sock (void)\r\n{\r\n#if defined (_WIN32)\r\nWSACleanup ();\r\n#endif\r\n}\r\n\r\n#if defined (_WIN32)                                    /* Windows */\r\nstatic int sim_setnonblock (SOCKET sock)\r\n{\r\nunsigned long non_block = 1;\r\n\r\nreturn ioctlsocket (sock, FIONBIO, &non_block);         /* set nonblocking */\r\n}\r\n\r\n#elif defined (VMS)                                     /* VMS */\r\nstatic int sim_setnonblock (SOCKET sock)\r\n{\r\nint non_block = 1;\r\n\r\nreturn ioctl (sock, FIONBIO, &non_block);               /* set nonblocking */\r\n}\r\n\r\n#else                                                   /* Mac, Unix, OS/2 */\r\nstatic int sim_setnonblock (SOCKET sock)\r\n{\r\nint fl, sta;\r\n\r\nfl = fcntl (sock, F_GETFL,0);                           /* get flags */\r\nif (fl == -1)\r\n    return SOCKET_ERROR;\r\nsta = fcntl (sock, F_SETFL, fl | O_NONBLOCK);           /* set nonblock */\r\nif (sta == -1)\r\n    return SOCKET_ERROR;\r\n#if !defined (macintosh) && !defined (__EMX__) && \\\r\n    !defined (__HAIKU__)                                /* Unix only */\r\nsta = fcntl (sock, F_SETOWN, getpid());                 /* set ownership */\r\nif (sta == -1)\r\n    return SOCKET_ERROR;\r\n#endif\r\nreturn 0;\r\n}\r\n\r\n#endif                                                  /* endif !Win32 && !VMS */\r\n\r\nstatic int sim_setnodelay (SOCKET sock)\r\n{\r\nint nodelay = 1;\r\nint sta;\r\n\r\n/* disable Nagle algorithm */\r\nsta = setsockopt (sock, IPPROTO_TCP, TCP_NODELAY, (char *)&nodelay, sizeof(nodelay));\r\nif (sta == -1)\r\n    return SOCKET_ERROR;\r\n\r\n#if defined(TCP_NODELAYACK)\r\n/* disable delayed ack algorithm */\r\nsta = setsockopt (sock, IPPROTO_TCP, TCP_NODELAYACK, (char *)&nodelay, sizeof(nodelay));\r\nif (sta == -1)\r\n    return SOCKET_ERROR;\r\n#endif\r\n\r\n#if defined(TCP_QUICKACK)\r\n/* disable delayed ack algorithm */\r\nsta = setsockopt (sock, IPPROTO_TCP, TCP_QUICKACK, (char *)&nodelay, sizeof(nodelay));\r\nif (sta == -1)\r\n    return SOCKET_ERROR;\r\n#endif\r\n\r\nreturn sta;\r\n}\r\n\r\nstatic SOCKET sim_create_sock (int af, int opt_flags)\r\n{\r\nSOCKET newsock;\r\nint err;\r\n\r\nnewsock = socket (af, ((opt_flags & SIM_SOCK_OPT_DATAGRAM) ? SOCK_DGRAM : SOCK_STREAM), 0);/* create socket */\r\nif (newsock == INVALID_SOCKET) {                        /* socket error? */\r\n    err = WSAGetLastError ();\r\n#if defined(WSAEAFNOSUPPORT)\r\n    if (err == WSAEAFNOSUPPORT)                         /* expected error, just return */\r\n        return newsock;\r\n#endif\r\n    return sim_err_sock (newsock, \"socket\");            /* report error and return */\r\n    }\r\nreturn newsock;\r\n}\r\n\r\n/*\r\n   Some platforms and/or network stacks have varying support for listening on \r\n   an IPv6 socket and receiving connections from both IPv4 and IPv6 client \r\n   connections.  This is known as IPv4-Mapped.  Some platforms claim such \r\n   support (i.e. some Windows versions), but it doesn't work in all cases.\r\n*/\r\n\r\nSOCKET sim_master_sock_ex (const char *hostport, int *parse_status, int opt_flags)\r\n{\r\nSOCKET newsock = INVALID_SOCKET;\r\nint sta;\r\nchar host[CBUFSIZE], port[CBUFSIZE];\r\nint r;\r\nstruct addrinfo hints;\r\nstruct addrinfo *result = NULL, *preferred;\r\n\r\nr = sim_parse_addr (hostport, host, sizeof(host), NULL, port, sizeof(port), NULL, NULL);\r\nif (parse_status)\r\n    *parse_status = r;\r\nif (r)\r\n    return newsock;\r\n\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_flags = AI_PASSIVE;\r\nhints.ai_family = AF_UNSPEC;\r\nhints.ai_protocol = IPPROTO_TCP;\r\nhints.ai_socktype = SOCK_STREAM;\r\nif (p_getaddrinfo(host[0] ? host : NULL, port[0] ? port : NULL, &hints, &result)) {\r\n    if (parse_status)\r\n        *parse_status = -1;\r\n    return newsock;\r\n    }\r\npreferred = result;\r\n#ifdef IPV6_V6ONLY\r\n/*\r\n    When we can create a dual stack socket, be sure to find the IPv6 addrinfo \r\n    to bind to.\r\n*/\r\nfor (; preferred != NULL; preferred = preferred->ai_next) {\r\n    if (preferred->ai_family == AF_INET6)\r\n        break;\r\n    }\r\nif (preferred == NULL)\r\n    preferred = result;\r\n#endif\r\nretry:\r\nnewsock = sim_create_sock (preferred->ai_family, 0);    /* create socket */\r\nif (newsock == INVALID_SOCKET) {                        /* socket error? */\r\n#ifndef IPV6_V6ONLY\r\n    if (preferred->ai_next) {\r\n        preferred = preferred->ai_next;\r\n        goto retry;\r\n        }\r\n#else\r\n    if ((preferred->ai_family == AF_INET6) &&\r\n        (preferred != result)) {\r\n        preferred = result;\r\n        goto retry;\r\n        }\r\n#endif\r\n    p_freeaddrinfo(result);\r\n    return newsock;\r\n    }\r\n#ifdef IPV6_V6ONLY\r\nif (preferred->ai_family == AF_INET6) {\r\n    int off = 0;\r\n    sta = setsockopt (newsock, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&off, sizeof(off));\r\n    }\r\n#endif\r\nif (opt_flags & SIM_SOCK_OPT_REUSEADDR) {\r\n    int on = 1;\r\n\r\n    sta = setsockopt (newsock, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));\r\n    }\r\n#if defined (SO_EXCLUSIVEADDRUSE)\r\nelse {\r\n    int on = 1;\r\n\r\n    sta = setsockopt (newsock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&on, sizeof(on));\r\n    }\r\n#endif\r\nsta = bind (newsock, preferred->ai_addr, preferred->ai_addrlen);\r\np_freeaddrinfo(result);\r\nif (sta == SOCKET_ERROR)                                /* bind error? */\r\n    return sim_err_sock (newsock, \"bind\");\r\nif (!(opt_flags & SIM_SOCK_OPT_BLOCKING)) {\r\n    sta = sim_setnonblock (newsock);                    /* set nonblocking */\r\n    if (sta == SOCKET_ERROR)                            /* fcntl error? */\r\n        return sim_err_sock (newsock, \"setnonblock\");\r\n    }\r\nsta = listen (newsock, SIM_SOCK_OPT_BACKLOG(opt_flags));/* listen on socket */\r\nif (sta == SOCKET_ERROR)                                /* listen error? */\r\n    return sim_err_sock (newsock, \"listen\");\r\nreturn newsock;                                         /* got it! */\r\n}\r\n\r\nSOCKET sim_connect_sock_ex (const char *sourcehostport, const char *hostport, const char *default_host, const char *default_port, int opt_flags)\r\n{\r\nSOCKET newsock = INVALID_SOCKET;\r\nint sta;\r\nchar host[CBUFSIZE], port[CBUFSIZE];\r\nstruct addrinfo hints;\r\nstruct addrinfo *result = NULL, *source = NULL;\r\n\r\nif (sim_parse_addr (hostport, host, sizeof(host), default_host, port, sizeof(port), default_port, NULL))\r\n    return INVALID_SOCKET;\r\n\r\nmemset(&hints, 0, sizeof(hints));\r\nhints.ai_family = AF_UNSPEC;\r\nhints.ai_protocol = ((opt_flags & SIM_SOCK_OPT_DATAGRAM) ? IPPROTO_UDP : IPPROTO_TCP);\r\nhints.ai_socktype = ((opt_flags & SIM_SOCK_OPT_DATAGRAM) ? SOCK_DGRAM : SOCK_STREAM);\r\nif (p_getaddrinfo(host[0] ? host : NULL, port[0] ? port : NULL, &hints, &result))\r\n    return INVALID_SOCKET;\r\n\r\nif (sourcehostport) {\r\n\r\n    /* Validate the local/source side address which we'll bind to */\r\n    if (sim_parse_addr (sourcehostport, host, sizeof(host), NULL, port, sizeof(port), NULL, NULL)) {\r\n        p_freeaddrinfo (result);\r\n        return INVALID_SOCKET;\r\n        }\r\n\r\n    memset(&hints, 0, sizeof(hints));\r\n    hints.ai_flags = AI_PASSIVE;\r\n    hints.ai_family = result->ai_family;                /* Same family as connect destination */\r\n    hints.ai_protocol = ((opt_flags & SIM_SOCK_OPT_DATAGRAM) ? IPPROTO_UDP : IPPROTO_TCP);\r\n    hints.ai_socktype = ((opt_flags & SIM_SOCK_OPT_DATAGRAM) ? SOCK_DGRAM : SOCK_STREAM);\r\n    if (p_getaddrinfo(host[0] ? host : NULL, port[0] ? port : NULL, &hints, &source)) {\r\n        p_freeaddrinfo (result);\r\n        return INVALID_SOCKET;\r\n        }\r\n\r\n    newsock = sim_create_sock (result->ai_family, opt_flags & SIM_SOCK_OPT_DATAGRAM);/* create socket */\r\n    if (newsock == INVALID_SOCKET) {                    /* socket error? */\r\n        p_freeaddrinfo (result);\r\n        p_freeaddrinfo (source);\r\n        return newsock;\r\n        }\r\n\r\n    sta = bind (newsock, source->ai_addr, source->ai_addrlen);\r\n    p_freeaddrinfo(source);\r\n    source = NULL;\r\n    if (sta == SOCKET_ERROR) {                          /* bind error? */\r\n        p_freeaddrinfo (result);\r\n        return sim_err_sock (newsock, \"bind\");\r\n        }\r\n    }\r\n\r\nif (newsock == INVALID_SOCKET) {                        /* socket error? */\r\n    newsock = sim_create_sock (result->ai_family, opt_flags & SIM_SOCK_OPT_DATAGRAM);/* create socket */\r\n    if (newsock == INVALID_SOCKET) {                    /* socket error? */\r\n        p_freeaddrinfo (result);\r\n        return newsock;\r\n        }\r\n    }\r\n\r\nif (!(opt_flags & SIM_SOCK_OPT_BLOCKING)) {\r\n    sta = sim_setnonblock (newsock);                    /* set nonblocking */\r\n    if (sta == SOCKET_ERROR) {                          /* fcntl error? */\r\n        p_freeaddrinfo (result);\r\n        return sim_err_sock (newsock, \"setnonblock\");\r\n        }\r\n    }\r\nif ((!(opt_flags & SIM_SOCK_OPT_DATAGRAM)) && (opt_flags & SIM_SOCK_OPT_NODELAY)) {\r\n    sta = sim_setnodelay (newsock);                     /* set nodelay */\r\n    if (sta == SOCKET_ERROR) {                          /* setsock error? */\r\n        p_freeaddrinfo (result);\r\n        return sim_err_sock (newsock, \"setnodelay\");\r\n        }\r\n    }\r\nif (!(opt_flags & SIM_SOCK_OPT_DATAGRAM)) {\r\n    int keepalive = 1;\r\n\r\n    /* enable TCP Keep Alives */\r\n    sta = setsockopt (newsock, SOL_SOCKET, SO_KEEPALIVE, (char *)&keepalive, sizeof(keepalive));\r\n    if (sta == -1) \r\n        return sim_err_sock (newsock, \"setsockopt KEEPALIVE\");\r\n    }\r\nsta = connect (newsock, result->ai_addr, result->ai_addrlen);\r\np_freeaddrinfo (result);\r\nif (sta == SOCKET_ERROR) {\r\n    if (opt_flags & SIM_SOCK_OPT_BLOCKING) {\r\n        if ((WSAGetLastError () == WSAETIMEDOUT)    ||                        /* expected errors after a connect failure */\r\n            (WSAGetLastError () == WSAEHOSTUNREACH) ||\r\n            (WSAGetLastError () == WSAECONNREFUSED) ||\r\n            (WSAGetLastError () == WSAECONNABORTED) ||\r\n            (WSAGetLastError () == WSAECONNRESET)) {\r\n            sim_close_sock (newsock);\r\n            newsock = INVALID_SOCKET;\r\n            }\r\n        else\r\n            return sim_err_sock (newsock, \"connect\");\r\n        }\r\n    else    /* Non Blocking case won't return errors until some future read */\r\n        if ((WSAGetLastError () != WSAEWOULDBLOCK) &&\r\n            (WSAGetLastError () != WSAEINPROGRESS))\r\n            return sim_err_sock (newsock, \"connect\");\r\n    }\r\nreturn newsock;                                         /* got it! */\r\n}\r\n\r\nSOCKET sim_accept_conn_ex (SOCKET master, char **connectaddr, int opt_flags)\r\n{\r\nint sta = 0, err;\r\nint keepalive = 1;\r\n#if defined (macintosh) || defined (__linux) || defined (__linux__) || \\\r\n    defined (__APPLE__) || defined (__OpenBSD__) || \\\r\n    defined(__NetBSD__) || defined(__FreeBSD__) || \\\r\n    (defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)) || \\\r\n    defined (__HAIKU__) || defined(__CYGWIN__)\r\nsocklen_t size;\r\n#elif defined (_WIN32) || defined (__EMX__) || \\\r\n     (defined (__ALPHA) && defined (__unix__)) || \\\r\n     defined (__hpux)\r\nint size;\r\n#else \r\nsize_t size; \r\n#endif\r\nSOCKET newsock;\r\nstruct sockaddr_storage clientname;\r\n\r\nif (master == 0)                                        /* not attached? */\r\n    return INVALID_SOCKET;\r\nsize = sizeof (clientname);\r\nmemset (&clientname, 0, sizeof(clientname));\r\nnewsock = accept (master, (struct sockaddr *) &clientname, &size);\r\nif (newsock == INVALID_SOCKET) {                        /* error? */\r\n    err = WSAGetLastError ();\r\n    if (err != WSAEWOULDBLOCK)\r\n        sim_err_sock(newsock, \"accept\");\r\n    return INVALID_SOCKET;\r\n    }\r\nif (connectaddr != NULL) {\r\n    *connectaddr = (char *)calloc(1, NI_MAXHOST+1);\r\n    p_getnameinfo((struct sockaddr *)&clientname, size, *connectaddr, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\r\n    if (0 == memcmp(\"::ffff:\", *connectaddr, 7))        /* is this a IPv4-mapped IPv6 address? */\r\n        memmove(*connectaddr, 7+*connectaddr,           /* prefer bare IPv4 address */\r\n                strlen(*connectaddr) - 7 + 1);          /* length to include terminating \\0 */\r\n    }\r\n\r\nif (!(opt_flags & SIM_SOCK_OPT_BLOCKING)) {\r\n    sta = sim_setnonblock (newsock);                    /* set nonblocking */\r\n    if (sta == SOCKET_ERROR)                            /* fcntl error? */\r\n        return sim_err_sock (newsock, \"setnonblock\");\r\n    }\r\n\r\nif ((opt_flags & SIM_SOCK_OPT_NODELAY)) {\r\n    sta = sim_setnodelay (newsock);                     /* set nonblocking */\r\n    if (sta == SOCKET_ERROR)                            /* setsockopt error? */\r\n        return sim_err_sock (newsock, \"setnodelay\");\r\n    }\r\n\r\n/* enable TCP Keep Alives */\r\nsta = setsockopt (newsock, SOL_SOCKET, SO_KEEPALIVE, (char *)&keepalive, sizeof(keepalive));\r\nif (sta == -1) \r\n    return sim_err_sock (newsock, \"setsockopt KEEPALIVE\");\r\n\r\nreturn newsock;\r\n}\r\n\r\nint sim_check_conn (SOCKET sock, int rd)\r\n{\r\nfd_set rw_set, er_set;\r\nfd_set *rw_p = &rw_set;\r\nfd_set *er_p = &er_set;\r\nstruct timeval zero;\r\nstruct sockaddr_storage peername;\r\n#if defined (macintosh) || defined (__linux) || defined (__linux__) || \\\r\n    defined (__APPLE__) || defined (__OpenBSD__) || \\\r\n    defined(__NetBSD__) || defined(__FreeBSD__) || \\\r\n    (defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)) || \\\r\n    defined (__HAIKU__) || defined(__CYGWIN__)\r\nsocklen_t peernamesize = (socklen_t)sizeof(peername);\r\n#elif defined (_WIN32) || defined (__EMX__) || \\\r\n     (defined (__ALPHA) && defined (__unix__)) || \\\r\n     defined (__hpux)\r\nint peernamesize = (int)sizeof(peername);\r\n#else \r\nsize_t peernamesize = sizeof(peername); \r\n#endif\r\n\r\nmemset (&zero, 0, sizeof(zero));\r\nFD_ZERO (rw_p);\r\nFD_ZERO (er_p);\r\nFD_SET (sock, rw_p);\r\nFD_SET (sock, er_p);\r\nif (rd)\r\n    (void)select ((int) sock + 1, rw_p, NULL, er_p, &zero);\r\nelse\r\n    (void)select ((int) sock + 1, NULL, rw_p, er_p, &zero);\r\nif (FD_ISSET (sock, er_p))\r\n    return -1;\r\nif (FD_ISSET (sock, rw_p)) {\r\n    if (0 == getpeername (sock, (struct sockaddr *)&peername, &peernamesize))\r\n        return 1;\r\n    else\r\n        return -1;\r\n    }\r\nreturn 0;\r\n}\r\n\r\nstatic int _sim_getaddrname (struct sockaddr *addr, size_t addrsize, char *hostnamebuf, char *portnamebuf)\r\n{\r\n#if defined (macintosh) || defined (__linux) || defined (__linux__) || \\\r\n    defined (__APPLE__) || defined (__OpenBSD__) || \\\r\n    defined(__NetBSD__) || defined(__FreeBSD__) || \\\r\n    (defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)) || \\\r\n    defined (__HAIKU__) || defined(__CYGWIN__)\r\nsocklen_t size = (socklen_t)addrsize;\r\n#elif defined (_WIN32) || defined (__EMX__) || \\\r\n     (defined (__ALPHA) && defined (__unix__)) || \\\r\n     defined (__hpux)\r\nint size = (int)addrsize;\r\n#else \r\nsize_t size = addrsize; \r\n#endif\r\nint ret = 0;\r\n\r\n*hostnamebuf = '\\0';\r\n*portnamebuf = '\\0';\r\nret = p_getnameinfo(addr, size, hostnamebuf, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\r\nif (0 == memcmp(\"::ffff:\", hostnamebuf, 7))        /* is this a IPv4-mapped IPv6 address? */\r\n    memmove(hostnamebuf, 7+hostnamebuf,            /* prefer bare IPv4 address */\r\n            strlen(hostnamebuf) + 7 - 1);          /* length to include terminating \\0 */\r\nif (!ret)\r\n    ret = p_getnameinfo(addr, size, NULL, 0, portnamebuf, NI_MAXSERV, NI_NUMERICSERV);\r\nreturn ret;\r\n}\r\n\r\nint sim_getnames_sock (SOCKET sock, char **socknamebuf, char **peernamebuf)\r\n{\r\nstruct sockaddr_storage sockname, peername;\r\n#if defined (macintosh) || defined (__linux) || defined (__linux__) || \\\r\n    defined (__APPLE__) || defined (__OpenBSD__) || \\\r\n    defined(__NetBSD__) || defined(__FreeBSD__) || \\\r\n    (defined(__hpux) && defined(_XOPEN_SOURCE_EXTENDED)) || \\\r\n    defined (__HAIKU__) || defined(__CYGWIN__)\r\nsocklen_t socknamesize = (socklen_t)sizeof(sockname);\r\nsocklen_t peernamesize = (socklen_t)sizeof(peername);\r\n#elif defined (_WIN32) || defined (__EMX__) || \\\r\n     (defined (__ALPHA) && defined (__unix__)) || \\\r\n     defined (__hpux)\r\nint socknamesize = (int)sizeof(sockname);\r\nint peernamesize = (int)sizeof(peername);\r\n#else \r\nsize_t socknamesize = sizeof(sockname); \r\nsize_t peernamesize = sizeof(peername); \r\n#endif\r\nchar hostbuf[NI_MAXHOST+1];\r\nchar portbuf[NI_MAXSERV+1];\r\n\r\nif (socknamebuf)\r\n    *socknamebuf = (char *)calloc(1, NI_MAXHOST+NI_MAXSERV+4);\r\nif (peernamebuf)\r\n    *peernamebuf = (char *)calloc(1, NI_MAXHOST+NI_MAXSERV+4);\r\n(void)getsockname (sock, (struct sockaddr *)&sockname, &socknamesize);\r\n(void)getpeername (sock, (struct sockaddr *)&peername, &peernamesize);\r\nif (socknamebuf != NULL) {\r\n    _sim_getaddrname ((struct sockaddr *)&sockname, (size_t)socknamesize, hostbuf, portbuf);\r\n    sprintf(*socknamebuf, \"[%s]:%s\", hostbuf, portbuf);\r\n    }\r\nif (peernamebuf != NULL) {\r\n    _sim_getaddrname ((struct sockaddr *)&peername, (size_t)peernamesize, hostbuf, portbuf);\r\n    sprintf(*peernamebuf, \"[%s]:%s\", hostbuf, portbuf);\r\n    }\r\nreturn 0;\r\n}\r\n\r\n\r\nint sim_read_sock (SOCKET sock, char *buf, int nbytes)\r\n{\r\nint rbytes, err;\r\n\r\nrbytes = recv (sock, buf, nbytes, 0);\r\nif (rbytes == 0) {                                       /* disconnect */\r\n    err = WSAGetLastError ();\r\n    return -1;\r\n    }\r\nif (rbytes == SOCKET_ERROR) {\r\n    err = WSAGetLastError ();\r\n    if (err == WSAEWOULDBLOCK)                          /* no data */\r\n        return 0;\r\n#if defined(EAGAIN)\r\n    if (err == EAGAIN)                                  /* no data */\r\n        return 0;\r\n#endif\r\n    if ((err != WSAETIMEDOUT) &&                        /* expected errors after a connect failure */\r\n        (err != WSAEHOSTUNREACH) &&\r\n        (err != WSAECONNREFUSED) &&\r\n        (err != WSAECONNABORTED) &&\r\n        (err != WSAECONNRESET) &&\r\n        (err != WSAEINTR))                              /* or a close of a blocking read */\r\n        sim_err_sock (INVALID_SOCKET, \"read\");\r\n    return -1;\r\n    }\r\nreturn rbytes;\r\n}\r\n\r\nint sim_write_sock (SOCKET sock, const char *msg, int nbytes)\r\n{\r\nint err, sbytes = send (sock, msg, nbytes, 0);\r\n\r\nif (sbytes == SOCKET_ERROR) {\r\n    err = WSAGetLastError ();\r\n    if (err == WSAEWOULDBLOCK)                          /* no data */\r\n        return 0;\r\n#if defined(EAGAIN)\r\n    if (err == EAGAIN)                                  /* no data */\r\n        return 0;\r\n#endif\r\n    }\r\nreturn sbytes;\r\n}\r\n\r\nvoid sim_close_sock (SOCKET sock)\r\n{\r\nshutdown(sock, SD_BOTH);\r\nclosesocket (sock);\r\n}\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n"
        },
        {
          "name": "sim_sock.h",
          "type": "blob",
          "size": 7.3759765625,
          "content": "/* sim_sock.h: OS-dependent socket routines header file\r\n\r\n   Copyright (c) 2001-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   15-Oct-12    MP      Added definitions needed to detect possible tcp\r\n                        connect failures\r\n   25-Sep-12    MP      Reworked for RFC3493 interfaces supporting IPv6 and IPv4\r\n   04-Jun-08    RMS     Added sim_create_sock, for IBM 1130\r\n   14-Apr-05    RMS     Added WSAEINPROGRESS (from Tim Riker)\r\n   20-Aug-04    HV      Added missing definition for OS/2 (from Holger Veit)\r\n   22-Oct-03    MP      Changed WIN32 winsock include to use winsock2.h to\r\n                        avoid a conflict if sim_sock.h and sim_ether.h get\r\n                        included by the same module.\r\n   20-Mar-03    RMS     Added missing timerclear definition for VMS (from\r\n                        Robert Alan Byer)\r\n   15-Feb-03    RMS     Added time.h for EMX (from Holger Veit)\r\n   17-Dec-02    RMS     Added sim_connect_sock\r\n   08-Oct-02    RMS     Revised for .NET compatibility\r\n   20-Aug-02    RMS     Changed calling sequence for sim_accept_conn\r\n   30-Apr-02    RMS     Changed VMS stropts include to ioctl\r\n   06-Feb-02    RMS     Added VMS support from Robert Alan Byer\r\n   16-Sep-01    RMS     Added Macintosh support from Peter Schorn\r\n*/\r\n\r\n#ifndef SIM_SOCK_H_\r\n#define SIM_SOCK_H_    0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#if defined (_WIN32)                                    /* Windows */\r\n#pragma push_macro (\"INT_PTR\")\r\n#pragma push_macro (\"PURE\")\r\n#pragma push_macro (\"BYTE\")\r\n#pragma push_macro (\"WORD\")\r\n#undef INT_PTR                      /* avoid macro name collision */\r\n#undef PURE                         /* avoid macro name collision */\r\n#undef BYTE                         /* avoid macro name collision */\r\n#undef WORD                         /* avoid macro name collision */\r\n#include <winsock2.h>\r\n#include <winerror.h>\r\n#undef PACKED                       /* avoid macro name collision */\r\n#undef ERROR                        /* avoid macro name collision */\r\n#undef MEM_MAPPED                   /* avoid macro name collision */\r\n#undef INTERFACE                    /* avoid macro name collision */\r\n#include <process.h>\r\n#pragma pop_macro (\"WORD\")\r\n#pragma pop_macro (\"BYTE\")\r\n#pragma pop_macro (\"PURE\")\r\n#pragma pop_macro (\"INT_PTR\")\r\n\r\n#else                                                   /* VMS, Mac, Unix */\r\n#include <sys/types.h>                                  /* for fcntl, getpid */\r\n#include <sys/socket.h>                                 /* for sockets */\r\n#include <string.h>\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n#include <netinet/in.h>                                 /* for sockaddr_in */\r\n#include <netinet/tcp.h>                                /* for TCP_NODELAY */\r\n#include <arpa/inet.h>                                  /* for inet_addr and inet_ntoa */\r\n#include <netdb.h>\r\n#include <sys/time.h>                                   /* for EMX */\r\n\r\n#define WSAGetLastError()       errno                   /* Windows macros */\r\n#define WSASetLastError(err) errno = err\r\n#define closesocket     close\r\n#define SOCKET          int\r\n#if defined(__hpux)\r\n#define WSAEWOULDBLOCK  EAGAIN\r\n#else\r\n#define WSAEWOULDBLOCK  EWOULDBLOCK\r\n#endif\r\n#define WSAENAMETOOLONG ENAMETOOLONG\r\n#define WSAEINPROGRESS  EINPROGRESS\r\n#define WSAETIMEDOUT    ETIMEDOUT\r\n#define WSAEISCONN      EISCONN\r\n#define WSAECONNRESET   ECONNRESET\r\n#define WSAECONNREFUSED ECONNREFUSED\r\n#define WSAECONNABORTED ECONNABORTED\r\n#define WSAEHOSTUNREACH EHOSTUNREACH\r\n#define WSAEADDRINUSE   EADDRINUSE\r\n#if defined(EAFNOSUPPORT)\r\n#define WSAEAFNOSUPPORT EAFNOSUPPORT\r\n#endif\r\n#define WSAEACCES       EACCES\r\n#define WSAEINTR        EINTR\r\n#define INVALID_SOCKET  ((SOCKET)-1)\r\n#if !defined(SOCKET_ERROR)\r\n#define SOCKET_ERROR    (-1)\r\n#endif\r\n#endif\r\n\r\n#if defined (VMS)                                       /* VMS unique */\r\n#include <ioctl.h>                                      /* for ioctl */\r\n#if !defined (AI_NUMERICHOST)\r\n#define AI_NUMERICHOST 0\r\n#endif\r\n#if defined (__VAX)\r\n#define sockaddr_storage sockaddr\r\n#endif\r\n#endif\r\n\r\n#if !defined(CBUFSIZE)\r\n#define CBUFSIZE 1024\r\n#define sim_printf printf\r\n#endif\r\n\r\nint sim_parse_addr (const char *cptr, char *host, size_t hostlen, const char *default_host,\r\n                                      char *port, size_t port_len, const char *default_port,\r\n                                      const char *validate_addr);\r\nint sim_parse_addr_ex (const char *cptr, char *host, size_t hostlen, const char *default_host,\r\n                                         char *port, size_t port_len, char *localport, size_t local_port_len, const char *default_port);\r\nint sim_addr_acl_check (const char *validate_addr, const char *acl);\r\n#define SIM_SOCK_OPT_REUSEADDR      0x0001\r\n#define SIM_SOCK_OPT_DATAGRAM       0x0002\r\n#define SIM_SOCK_OPT_NODELAY        0x0004\r\n#define SIM_SOCK_OPT_BLOCKING       0x0008\r\n#define SIM_SOCK_OPT_SET_BACKLOG(N) ((N) << 16)\r\n#define SIM_SOCK_OPT_BACKLOG(opts)  ((((opts) >> 16) == 0) ? 1 : ((opts) >> 16))\r\nSOCKET sim_master_sock_ex (const char *hostport, int *parse_status, int opt_flags);\r\n#define sim_master_sock(hostport, parse_status) sim_master_sock_ex(hostport, parse_status, ((sim_switches & SWMASK ('U')) ? SIM_SOCK_OPT_REUSEADDR : 0))\r\nSOCKET sim_connect_sock_ex (const char *sourcehostport, const char *hostport, const char *default_host, const char *default_port, int opt_flags);\r\n#define sim_connect_sock(hostport, default_host, default_port) sim_connect_sock_ex(NULL, hostport, default_host, default_port, SIM_SOCK_OPT_BLOCKING)\r\nSOCKET sim_accept_conn_ex (SOCKET master, char **connectaddr, int opt_flags);\r\n#define sim_accept_conn(master, connectaddr) sim_accept_conn_ex(master, connectaddr, 0)\r\nint sim_check_conn (SOCKET sock, int rd);\r\nint sim_read_sock (SOCKET sock, char *buf, int nbytes);\r\nint sim_write_sock (SOCKET sock, const char *msg, int nbytes);\r\nvoid sim_close_sock (SOCKET sock);\r\nconst char *sim_get_err_sock (const char *emsg);\r\nSOCKET sim_err_sock (SOCKET sock, const char *emsg);\r\nint sim_getnames_sock (SOCKET sock, char **socknamebuf, char **peernamebuf);\r\nvoid sim_init_sock (void);\r\nvoid sim_cleanup_sock (void);\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_tape.c",
          "type": "blob",
          "size": 207.03125,
          "content": "/* sim_tape.c: simulator tape support library\r\n\r\n   Copyright (c) 1993-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   Ultimately, this will be a place to hide processing of various tape formats,\r\n   as well as OS-specific direct hardware access.\r\n\r\n   23-Jan-12    MP      Added support for Logical EOT detection while positioning\r\n   05-Feb-11    MP      Refactored to prepare for SIM_ASYNC_IO support\r\n                        Added higher level routines:\r\n                            sim_tape_wreomrw    - erase remainder of tape & rewind\r\n                            sim_tape_sprecsf    - skip records\r\n                            sim_tape_spfilef    - skip files\r\n                            sim_tape_sprecsr    - skip records rev\r\n                            sim_tape_spfiler    - skip files rev\r\n                            sim_tape_position   - general purpose position\r\n                        These routines correspond to natural tape operations\r\n                        and will align better when physical tape support is\r\n                        included here.\r\n   08-Jun-08    JDB     Fixed signed/unsigned warning in sim_tape_set_fmt\r\n   23-Jan-07    JDB     Fixed backspace over gap at BOT\r\n   22-Jan-07    RMS     Fixed bug in P7B format read reclnt rev (found by Rich Cornwell)\r\n   15-Dec-06    RMS     Added support for small capacity tapes\r\n   30-Aug-06    JDB     Added erase gap support\r\n   14-Feb-06    RMS     Added variable tape capacity\r\n   23-Jan-06    JDB     Fixed odd-byte-write problem in sim_tape_wrrecf\r\n   17-Dec-05    RMS     Added write support for Paul Pierce 7b format\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   02-May-05    RMS     Added support for Pierce 7b format\r\n   28-Jul-04    RMS     Fixed bug in writing error records (found by Dave Bryan)\r\n                RMS     Fixed incorrect error codes (found by Dave Bryan)\r\n   05-Jan-04    RMS     Revised for file I/O library\r\n   25-Apr-03    RMS     Added extended file support\r\n   28-Mar-03    RMS     Added E11 and TPC format support\r\n\r\n   Public routines:\r\n\r\n   sim_tape_attach      attach tape unit\r\n   sim_tape_detach      detach tape unit\r\n   sim_tape_attach_help help routine for attaching tapes\r\n   sim_tape_rdrecf      read tape record forward\r\n   sim_tape_rdrecr      read tape record reverse\r\n   sim_tape_wrrecf      write tape record forward\r\n   sim_tape_sprecf      space tape record forward\r\n   sim_tape_sprecr      space tape record reverse\r\n   sim_tape_wrtmk       write tape mark\r\n   sim_tape_wreom       erase remainder of tape\r\n   sim_tape_wreomrw     erase remainder of tape & rewind\r\n   sim_tape_wrgap       write erase gap\r\n   sim_tape_errecf      erase record forward\r\n   sim_tape_errecr      erase record reverse\r\n   sim_tape_sprecsf     space records forward\r\n   sim_tape_spfilef     space files forward\r\n   sim_tape_sprecsr     space records reverse\r\n   sim_tape_spfiler     space files reverse\r\n   sim_tape_position    generalized position\r\n   sim_tape_rewind      rewind\r\n   sim_tape_reset       reset unit\r\n   sim_tape_bot         TRUE if at beginning of tape\r\n   sim_tape_eot         TRUE if at or beyond end of tape\r\n   sim_tape_wrp         TRUE if write protected\r\n   sim_tape_set_fmt     set tape format\r\n   sim_tape_show_fmt    show tape format\r\n   sim_tape_set_capac   set tape capacity\r\n   sim_tape_show_capac  show tape capacity\r\n   sim_tape_set_dens    set tape density\r\n   sim_tape_show_dens   show tape density\r\n   sim_tape_error_text  the textual description of a tape status\r\n   sim_tape_set_async   enable asynchronous operation\r\n   sim_tape_clr_async   disable asynchronous operation\r\n   aim_tape_test        unit test routine\r\n\r\n*/\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_tape.h\"\r\n\r\n#include \"sim_scp_private.h\"\r\n\r\n#ifndef MAX\r\n#define MAX(a,b)  (((a) >= (b)) ? (a) : (b))\r\n#endif\r\n#ifndef MIN\r\n#define MIN(a,b)  (((a) <= (b)) ? (a) : (b))\r\n#endif\r\n\r\n#if defined SIM_ASYNCH_IO\r\n#include <pthread.h>\r\n#endif\r\n\r\nstatic struct sim_tape_fmt {\r\n    const char          *name;                          /* name */\r\n    int32               uflags;                         /* unit flags */\r\n    t_addr              bot;                            /* bot test */\r\n    t_addr              eom_remnant;                    /* potentially unprocessed data */\r\n    } fmts[] = {\r\n    { \"SIMH\",       0,       sizeof (t_mtrlnt) - 1, sizeof (t_mtrlnt) },\r\n    { \"E11\",        0,       sizeof (t_mtrlnt) - 1, sizeof (t_mtrlnt) },\r\n    { \"TPC\",        UNIT_RO, sizeof (t_tpclnt) - 1, sizeof (t_tpclnt) },\r\n    { \"P7B\",        0,       0,                     0                 },\r\n    { \"AWS\",        0,       0,                     0                 },\r\n    { \"TAR\",        UNIT_RO, 0,                     0                 },\r\n    { \"ANSI\",       UNIT_RO, 0,                     0                 },\r\n    { \"FIXED\",      UNIT_RO, 0,                     0                 },\r\n    { \"DOS11\",      UNIT_RO, 0,                     0                 },\r\n    { NULL,         0,       0,                     0                 }\r\n    };\r\n\r\nstatic const uint32 bpi [] = {                          /* tape density table, indexed by MT_DENS constants */\r\n    0,                                                  /*   0 = MT_DENS_NONE -- density not set */\r\n    200,                                                /*   1 = MT_DENS_200  -- 200 bpi NRZI */\r\n    556,                                                /*   2 = MT_DENS_556  -- 556 bpi NRZI */\r\n    800,                                                /*   3 = MT_DENS_800  -- 800 bpi NRZI */\r\n    1600,                                               /*   4 = MT_DENS_1600 -- 1600 bpi PE */\r\n    6250                                                /*   5 = MT_DENS_6250 -- 6250 bpi GCR */\r\n    };\r\n\r\n#define BPI_COUNT       (sizeof (bpi) / sizeof (bpi [0]))   /* count of density table entries */\r\n\r\nstatic t_stat sim_tape_ioerr (UNIT *uptr);\r\nstatic t_stat sim_tape_wrdata (UNIT *uptr, uint32 dat);\r\nstatic t_stat sim_tape_aws_wrdata (UNIT *uptr, uint8 *buf, t_mtrlnt bc);\r\nstatic uint32 sim_tape_tpc_map (UNIT *uptr, t_addr *map, uint32 mapsize);\r\nstatic t_stat sim_tape_validate_tape (UNIT *uptr);\r\nstatic t_addr sim_tape_tpc_fnd (UNIT *uptr, t_addr *map);\r\nstatic void sim_tape_data_trace (UNIT *uptr, const uint8 *data, size_t len, const char* txt, int detail, uint32 reason);\r\nstatic t_stat tape_erase_fwd (UNIT *uptr, t_mtrlnt gap_size);\r\nstatic t_stat tape_erase_rev (UNIT *uptr, t_mtrlnt gap_size);\r\n\r\nstruct tape_context {\r\n    DEVICE              *dptr;              /* Device for unit (access to debug flags) */\r\n    uint32              dbit;               /* debugging bit for trace */\r\n    uint32              auto_format;        /* Format determined dynamically */\r\n    uint8               *chunk_buf;\r\n    uint32              chunk_buf_size;\r\n    uint32              chunk_data_size;\r\n    uint32              chunk_offset;\r\n#if defined SIM_ASYNCH_IO\r\n    t_bool              asynch_io;          /* Asynchronous Interrupt scheduling enabled */\r\n    int                 asynch_io_latency;  /* instructions to delay pending interrupt */\r\n    pthread_mutex_t     lock;\r\n    pthread_t           io_thread;          /* I/O Thread Id */\r\n    pthread_mutex_t     io_lock;\r\n    pthread_cond_t      io_cond;\r\n    pthread_cond_t      io_done;\r\n    pthread_cond_t      startup_cond;\r\n    int                 io_top;\r\n    uint8               *buf;\r\n    uint32              *bc;\r\n    uint32              *fc;\r\n    uint32              vbc;\r\n    uint32              max;\r\n    uint32              gaplen;\r\n    uint32              bpi;\r\n    uint32              *objupdate;\r\n    TAPE_PCALLBACK      callback;\r\n    t_stat              io_status;\r\n#endif\r\n    };\r\n#define tape_ctx up8                        /* Field in Unit structure which points to the tape_context */\r\n\r\n#if defined SIM_ASYNCH_IO\r\n#define AIO_CALLSETUP                                                   \\\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;       \\\r\n                                                                        \\\r\nif (ctx == NULL)                                                        \\\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");                    \\\r\nif ((callback == NULL) || !(ctx->asynch_io))\r\n\r\n#define AIO_CALL(op, _buf, _bc, _fc, _max, _vbc, _gaplen, _bpi, _obj, _callback)\\\r\n    if (ctx->asynch_io) {                                               \\\r\n        struct tape_context *ctx =                                      \\\r\n                      (struct tape_context *)uptr->tape_ctx;            \\\r\n                                                                        \\\r\n        pthread_mutex_lock (&ctx->io_lock);                             \\\r\n                                                                        \\\r\n        sim_debug_unit (ctx->dbit, uptr,                                \\\r\n      \"sim_tape AIO_CALL(op=%d, unit=%d)\\n\", op, (int)(uptr-ctx->dptr->units));\\\r\n                                                                        \\\r\n        if (ctx->callback)      /* horrible mistake, stop */            \\\r\n            SIM_SCP_ABORT (\"AIO_CALL error\");                           \\\r\n        ctx->io_top = op;                                               \\\r\n        ctx->buf = _buf;                                                \\\r\n        ctx->bc = _bc;                                                  \\\r\n        ctx->fc = _fc;                                                  \\\r\n        ctx->max = _max;                                                \\\r\n        ctx->vbc = _vbc;                                                \\\r\n        ctx->gaplen = _gaplen;                                          \\\r\n        ctx->bpi = _bpi;                                                \\\r\n        ctx->objupdate = _obj;                                          \\\r\n        ctx->callback = _callback;                                      \\\r\n        pthread_cond_signal (&ctx->io_cond);                            \\\r\n        pthread_mutex_unlock (&ctx->io_lock);                           \\\r\n        }                                                               \\\r\n    else                                                                \\\r\n        if (_callback)                                                  \\\r\n            (_callback) (uptr, r);\r\n#define TOP_DONE  0             /* close */\r\n#define TOP_RDRF  1             /* sim_tape_rdrecf_a */\r\n#define TOP_RDRR  2             /* sim_tape_rdrecr_a */\r\n#define TOP_WREC  3             /* sim_tape_wrrecf_a */\r\n#define TOP_WTMK  4             /* sim_tape_wrtmk_a */\r\n#define TOP_WEOM  5             /* sim_tape_wreom_a */\r\n#define TOP_WEMR  6             /* sim_tape_wreomrw_a */\r\n#define TOP_WGAP  7             /* sim_tape_wrgap_a */\r\n#define TOP_SPRF  8             /* sim_tape_sprecf_a */\r\n#define TOP_SRSF  9             /* sim_tape_sprecsf_a */\r\n#define TOP_SPRR 10             /* sim_tape_sprecr_a */\r\n#define TOP_SRSR 11             /* sim_tape_sprecsr_a */\r\n#define TOP_SPFF 12             /* sim_tape_spfilef */\r\n#define TOP_SFRF 13             /* sim_tape_spfilebyrecf */\r\n#define TOP_SPFR 14             /* sim_tape_spfiler */\r\n#define TOP_SFRR 15             /* sim_tape_spfilebyrecr */\r\n#define TOP_RWND 16             /* sim_tape_rewind_a */\r\n#define TOP_POSN 17             /* sim_tape_position_a */\r\n\r\nstatic void *\r\n_tape_io(void *arg)\r\n{\r\nUNIT* volatile uptr = (UNIT*)arg;\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\n    /* Boost Priority for this I/O thread vs the CPU instruction execution\r\n       thread which in general won't be readily yielding the processor when\r\n       this thread needs to run */\r\n    sim_os_set_thread_priority (PRIORITY_ABOVE_NORMAL);\r\n\r\n    sim_debug_unit (ctx->dbit, uptr, \"_tape_io(unit=%d) starting\\n\", (int)(uptr-ctx->dptr->units));\r\n\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n    pthread_cond_signal (&ctx->startup_cond);   /* Signal we're ready to go */\r\n    while (1) {\r\n        pthread_cond_wait (&ctx->io_cond, &ctx->io_lock);\r\n        if (ctx->io_top == TOP_DONE)\r\n            break;\r\n        pthread_mutex_unlock (&ctx->io_lock);\r\n        switch (ctx->io_top) {\r\n            case TOP_RDRF:\r\n                ctx->io_status = sim_tape_rdrecf (uptr, ctx->buf, ctx->bc, ctx->max);\r\n                break;\r\n            case TOP_RDRR:\r\n                ctx->io_status = sim_tape_rdrecr (uptr, ctx->buf, ctx->bc, ctx->max);\r\n                break;\r\n            case TOP_WREC:\r\n                ctx->io_status = sim_tape_wrrecf (uptr, ctx->buf, ctx->vbc);\r\n                break;\r\n            case TOP_WTMK:\r\n                ctx->io_status = sim_tape_wrtmk (uptr);\r\n                break;\r\n            case TOP_WEOM:\r\n                ctx->io_status = sim_tape_wreom (uptr);\r\n                break;\r\n            case TOP_WEMR:\r\n                ctx->io_status = sim_tape_wreomrw (uptr);\r\n                break;\r\n            case TOP_WGAP:\r\n                ctx->io_status = sim_tape_wrgap (uptr, ctx->gaplen);\r\n                break;\r\n            case TOP_SPRF:\r\n                ctx->io_status = sim_tape_sprecf (uptr, ctx->bc);\r\n                break;\r\n            case TOP_SRSF:\r\n                ctx->io_status = sim_tape_sprecsf (uptr, ctx->vbc, ctx->bc);\r\n                break;\r\n            case TOP_SPRR:\r\n                ctx->io_status = sim_tape_sprecr (uptr, ctx->bc);\r\n                break;\r\n            case TOP_SRSR:\r\n                ctx->io_status = sim_tape_sprecsr (uptr, ctx->vbc, ctx->bc);\r\n                break;\r\n            case TOP_SPFF:\r\n                ctx->io_status = sim_tape_spfilef (uptr, ctx->vbc, ctx->bc);\r\n                break;\r\n            case TOP_SFRF:\r\n                ctx->io_status = sim_tape_spfilebyrecf (uptr, ctx->vbc, ctx->bc, ctx->fc, ctx->max);\r\n                break;\r\n            case TOP_SPFR:\r\n                ctx->io_status = sim_tape_spfiler (uptr, ctx->vbc, ctx->bc);\r\n                break;\r\n            case TOP_SFRR:\r\n                ctx->io_status = sim_tape_spfilebyrecr (uptr, ctx->vbc, ctx->bc, ctx->fc);\r\n                break;\r\n            case TOP_RWND:\r\n                ctx->io_status = sim_tape_rewind (uptr);\r\n                break;\r\n            case TOP_POSN:\r\n                ctx->io_status = sim_tape_position (uptr, ctx->vbc, ctx->gaplen, ctx->bc, ctx->bpi, ctx->fc, ctx->objupdate);\r\n                break;\r\n            }\r\n        pthread_mutex_lock (&ctx->io_lock);\r\n        ctx->io_top = TOP_DONE;\r\n        pthread_cond_signal (&ctx->io_done);\r\n        sim_activate (uptr, ctx->asynch_io_latency);\r\n    }\r\n    pthread_mutex_unlock (&ctx->io_lock);\r\n\r\n    sim_debug_unit (ctx->dbit, uptr, \"_tape_io(unit=%d) exiting\\n\", (int)(uptr-ctx->dptr->units));\r\n\r\n    return NULL;\r\n}\r\n\r\n/* This routine is called in the context of the main simulator thread before\r\n   processing events for any unit. It is only called when an asynchronous\r\n   thread has called sim_activate() to activate a unit.  The job of this\r\n   routine is to put the unit in proper condition to digest what may have\r\n   occurred in the asynchronous thread.\r\n\r\n   Since tape processing only handles a single I/O at a time to a\r\n   particular tape device, we have the opportunity to possibly detect\r\n   improper attempts to issue multiple concurrent I/O requests. */\r\nstatic void _tape_completion_dispatch (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nTAPE_PCALLBACK callback = ctx->callback;\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"_tape_completion_dispatch(unit=%d, top=%d, callback=%p)\\n\", (int)(uptr-ctx->dptr->units), ctx->io_top, ctx->callback);\r\n\r\nif (ctx->io_top != TOP_DONE)\r\n    SIM_SCP_ABORT (\"_tape_completion_dispatch()\"); /* horribly wrong, stop */\r\n\r\nif (ctx->asynch_io)\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n\r\nif (ctx->callback) {\r\n    ctx->callback = NULL;\r\n    if (ctx->asynch_io)\r\n        pthread_mutex_unlock (&ctx->io_lock);\r\n    callback (uptr, ctx->io_status);\r\n    }\r\nelse {\r\n    if (ctx->asynch_io)\r\n        pthread_mutex_unlock (&ctx->io_lock);\r\n    }\r\n}\r\n\r\nstatic t_bool _tape_is_active (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nif (ctx) {\r\n    sim_debug_unit (ctx->dbit, uptr, \"_tape_is_active(unit=%d, top=%d)\\n\", (int)(uptr-ctx->dptr->units), ctx->io_top);\r\n    return (ctx->io_top != TOP_DONE);\r\n    }\r\nreturn FALSE;\r\n}\r\n\r\nstatic t_bool _tape_cancel (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nif (ctx) {\r\n    sim_debug_unit (ctx->dbit, uptr, \"_tape_cancel(unit=%d, top=%d)\\n\", (int)(uptr-ctx->dptr->units), ctx->io_top);\r\n    if (ctx->asynch_io) {\r\n        pthread_mutex_lock (&ctx->io_lock);\r\n        while (ctx->io_top != TOP_DONE)\r\n            pthread_cond_wait (&ctx->io_done, &ctx->io_lock);\r\n        pthread_mutex_unlock (&ctx->io_lock);\r\n        }\r\n    }\r\nreturn FALSE;\r\n}\r\n#else\r\n#define AIO_CALLSETUP                                                       \\\r\n    if (uptr->tape_ctx == NULL)                                             \\\r\n        return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");\r\n#define AIO_CALL(op, _buf, _fc, _bc, _max, _vbc, _gaplen, _bpi, _obj, _callback) \\\r\n    if (_callback)                                                    \\\r\n        (_callback) (uptr, r);\r\n#endif\r\n\r\n#define MIN_RECORD_SIZE    14   /* Mag tape records <14 bytes are considered noise */\r\n#define MAX_RECORD_SIZE 65535   /* DEC tape controllers have a 16-bit byte count reg */\r\n\r\ntypedef struct VOL1 {\r\n    char type[3];               /* VOL  */\r\n    char num;                   /* 1    */\r\n    char ident[6];              /* <ansi <a> characters blank padded > */\r\n    char accessibity;           /* blank */\r\n    char reserved1[13];         /*      */\r\n    char implement[13];         /*      */\r\n    char owner[14];             /*      */\r\n    char reserved2[28];         /*      */\r\n    char standard;              /* 1,3 or 4  */\r\n    } VOL1;\r\n\r\ntypedef struct HDR1 {       /* Also EOF1, EOV1 */\r\n    char type[3];               /* HDR|EOF|EOV  */\r\n    char num;                   /* 1    */\r\n    char file_ident[17];        /* filename */\r\n    char file_set[6];           /* label ident */\r\n    char file_section[4];       /* 0001 */\r\n    char file_sequence[4];      /* 0001 */\r\n    char generation_number[4];  /* 0001 */\r\n    char version_number[2];     /* 00 */\r\n    char creation_date[6];      /* cyyddd */\r\n    char expiration_date[6];\r\n    char accessibility;         /* space */\r\n    char block_count[6];        /* 000000 */\r\n    char system_code[13];       /* */\r\n    char reserved[7];           /* blank */\r\n    } HDR1;\r\n\r\ntypedef struct HDR2 {       /* Also EOF2, EOV2 */\r\n    char type[3];               /* HDR  */\r\n    char num;                   /* 2    */\r\n    char record_format;         /* F(fixed)|D(variable)|S(spanned) */\r\n    char block_length[5];       /* label ident */\r\n    char record_length[5];      /*  */\r\n    char reserved_os1[21];      /* */\r\n    char carriage_control;      /* A - Fortran CC, M - Record contained CC, space - CR/LF to be added */\r\n    char reserved_os2[13];      /* */\r\n    char buffer_offset[2];      /* */\r\n    char reserved_std[28];      /* */\r\n    } HDR2;\r\n\r\ntypedef struct HDR3 {       /* Also EOF3, EOV3 */\r\n    char type[3];               /* HDR  */\r\n    char num;                   /* 3    */\r\n    char rms_attributes[64];    /* 32 bytes of RMS attributes, converted to hex */\r\n    char reserved[12];          /* */\r\n    } HDR3;\r\n\r\ntypedef struct HDR4 {       /* Also EOF4, EOV4 */\r\n    char type[3];               /* HDR  */\r\n    char num;                   /* 4    */\r\n    char blank;                 /* blank */\r\n    char extra_name[62];        /*  */\r\n    char extra_name_used[2];    /* 99 */\r\n    char unused[11];\r\n    } HDR4;\r\n\r\ntypedef struct TAPE_RECORD {\r\n    uint32 size;\r\n    uint8 data[1];\r\n    } TAPE_RECORD;\r\n\r\ntypedef struct MEMORY_TAPE {\r\n    uint32 ansi_type;       /* ANSI-VMS, ANSI-RT11, ANSI-RSTS, ANSI-RSX11, etc. */\r\n    uint32 file_count;      /* number of labeled files */\r\n    uint32 record_count;    /* number of entries in the record array */\r\n    uint32 array_size;      /* allocated size of records array */\r\n    uint32 block_size;      /* tape block size */\r\n    TAPE_RECORD **records;\r\n    VOL1 vol1;\r\n    } MEMORY_TAPE;\r\n\r\nconst char HDR3_RMS_STREAM[] = \"HDR3020002040000\"\r\n                               \"0000000100000000\"\r\n                               \"0000000002000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000            \";\r\nconst char HDR3_RMS_STMLF[] =  \"HDR3020002050000\"\r\n                               \"0000000100000000\"\r\n                               \"0000000002000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000            \";\r\nconst char HDR3_RMS_FIXED[] =  \"HDR3020000010000\"\r\n                               \"0000000100000000\"\r\n                               \"0000000002000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000            \";\r\nconst char HDR3_RMS_VARRSX[] = \"HDR300000A020000\"\r\n                               \"0000000100000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000            \";\r\nconst char HDR3_RMS_FIXRSX[] = \"HDR3020008010000\"\r\n                               \"0000000100000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000000000000000\"\r\n                               \"0000            \";\r\n\r\nstatic struct ansi_tape_parameters {\r\n    const char          *name;                  /* operating system */\r\n    const char          *system_code;           /* */\r\n    t_bool              nohdr2;                 /* no HDR2 records */\r\n    t_bool              nohdr3;                 /* no HDR2 records */\r\n    t_bool              fixed_text;             /*  */\r\n    char                vol1_standard;          /* 3 or 4 */\r\n    const char          *hdr3_fixed;            /* HDR3 template for Fixed format files */\r\n    const char          *hdr3_lf_line_endings;  /* HDR3 template for text with LF line ending files */\r\n    const char          *hdr3_crlf_line_endings;/* HDR3 template for text with CRLF line ending files */\r\n    int                 skip_lf_line_endings;\r\n    int                 skip_crlf_line_endings;\r\n    t_bool              y2k_date_bug;\r\n    t_bool              zero_record_length;\r\n    char                record_format;\r\n    char                carriage_control;\r\n    } ansi_args[] = {     /* code       nohdr2 nohdr3 fixed_text lvl hdr3 for fixed    hdr3 for lf      hdr3 for crlf  skLF CRLF Y2KDT  0RecLnt RFM  CC*/\r\n        {\"ANSI-VMS\"      , \"DECFILE11A\", FALSE, FALSE, FALSE,    '3', HDR3_RMS_FIXED,  HDR3_RMS_STMLF,  HDR3_RMS_STREAM, 0,   0, FALSE, FALSE,   0,   0},\r\n        {\"ANSI-RSX11\"    , \"DECFILE11A\", FALSE, FALSE, FALSE,    '4', HDR3_RMS_FIXRSX, HDR3_RMS_VARRSX, HDR3_RMS_VARRSX, 1,   2, FALSE, FALSE,   0,   0},\r\n        {\"ANSI-RT11\"     , \"DECRT11A\",   TRUE,  TRUE,  TRUE,     '3', NULL,            NULL,            NULL,            0,   0, FALSE, FALSE,   0,   0},\r\n        {\"ANSI-RSTS\"     , \"DECRSTS/E\",  FALSE, TRUE,  TRUE,     '3', NULL,            NULL,            NULL,            0,   0, TRUE,  TRUE,  'U', 'M'},\r\n        {\"ANSI-VAR\"      , \"DECRSTS/E\",  FALSE, TRUE,  FALSE,    '3', NULL,            NULL,            NULL,            1,   2, TRUE,  FALSE, 'D', ' '},\r\n        {NULL}\r\n    };\r\n\r\n\r\nstatic MEMORY_TAPE *ansi_create_tape (const char *label, uint32 block_size, uint32 ansi_type);\r\nstatic MEMORY_TAPE *memory_create_tape (void);\r\nstatic void memory_free_tape (void *vtape);\r\nstatic void sim_tape_add_ansi_entry (const char *directory,\r\n                                     const char *filename,\r\n                                     t_offset FileSize,\r\n                                     const struct stat *filestat,\r\n                                     void *context);\r\nstatic t_bool memory_tape_add_block (MEMORY_TAPE *tape, uint8 *block, uint32 size);\r\n\r\ntypedef struct DOS11_HDR {\r\n    uint16 fname[2];        /* File name (RAD50 - 6 characters) */\r\n    uint16 ext;             /* Extension (RAD50 - 3 characters) */\r\n    uint8  prog;            /* Programmer # */\r\n    uint8  proj;            /* Project # */\r\n    uint16 prot;            /* Protection */\r\n    uint16 date;            /* (year - 1970) * 1000 + day of year */\r\n    uint16 fname3;          /* File name (RAD50 - 3 characters) */\r\n    } DOS11_HDR;\r\n#define DOS11_PROT      0233\r\n\r\nstatic void sim_tape_add_dos11_entry (const char *directory,\r\n                                      const char *filename,\r\n                                      t_offset FileSize,\r\n                                      const struct stat *filestat,\r\n                                      void *context);\r\n\r\nstatic t_stat sim_export_tape (UNIT *uptr, const char *export_file);\r\nstatic FILE *tape_open_and_check_file(const char *filename);\r\nstatic int tape_classify_file_contents (FILE *f, size_t *max_record_size, t_bool *lf_line_endings, t_bool *crlf_line_endings);\r\n\r\n\r\n/* Enable asynchronous operation */\r\n\r\nt_stat sim_tape_set_async (UNIT *uptr, int latency)\r\n{\r\n#if !defined(SIM_ASYNCH_IO)\r\nreturn sim_messagef (SCPE_NOFNC, \"Tape: can't operate asynchronously\\r\\n\");\r\n#else\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\npthread_attr_t attr;\r\n\r\nctx->asynch_io = sim_asynch_enabled;\r\nctx->asynch_io_latency = latency;\r\nif (ctx->asynch_io) {\r\n    pthread_mutex_init (&ctx->io_lock, NULL);\r\n    pthread_cond_init (&ctx->io_cond, NULL);\r\n    pthread_cond_init (&ctx->io_done, NULL);\r\n    pthread_cond_init (&ctx->startup_cond, NULL);\r\n    pthread_attr_init(&attr);\r\n    pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n    pthread_create (&ctx->io_thread, &attr, _tape_io, (void *)uptr);\r\n    pthread_attr_destroy(&attr);\r\n    pthread_cond_wait (&ctx->startup_cond, &ctx->io_lock); /* Wait for thread to stabilize */\r\n    pthread_mutex_unlock (&ctx->io_lock);\r\n    pthread_cond_destroy (&ctx->startup_cond);\r\n    }\r\nuptr->a_check_completion = _tape_completion_dispatch;\r\nuptr->a_is_active = _tape_is_active;\r\nuptr->cancel = _tape_cancel;\r\nreturn SCPE_OK;\r\n#endif\r\n}\r\n\r\n/* Disable asynchronous operation */\r\n\r\nt_stat sim_tape_clr_async (UNIT *uptr)\r\n{\r\n#if !defined(SIM_ASYNCH_IO)\r\nreturn SCPE_NOFNC;\r\n#else\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\n/* make sure device exists */\r\nif (!ctx) return SCPE_UNATT;\r\n\r\nif (ctx->asynch_io) {\r\n    pthread_mutex_lock (&ctx->io_lock);\r\n    ctx->asynch_io = FALSE;\r\n    pthread_cond_signal (&ctx->io_cond);\r\n    pthread_mutex_unlock (&ctx->io_lock);\r\n    pthread_join (ctx->io_thread, NULL);\r\n    pthread_mutex_destroy (&ctx->io_lock);\r\n    pthread_cond_destroy (&ctx->io_cond);\r\n    pthread_cond_destroy (&ctx->io_done);\r\n    }\r\nreturn SCPE_OK;\r\n#endif\r\n}\r\n\r\nt_stat sim_tape_set_chunk_mode (UNIT *uptr, uint32 chunk_size)\r\n{\r\nuptr->tape_chunk_size = chunk_size;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/*\r\n   This routine is called when the simulator stops and any time\r\n   the asynch mode is changed (enabled or disabled)\r\n*/\r\nstatic void _sim_tape_io_flush (UNIT *uptr)\r\n{\r\n#if defined (SIM_ASYNCH_IO)\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nsim_tape_clr_async (uptr);\r\nif (sim_asynch_enabled)\r\n    sim_tape_set_async (uptr, ctx->asynch_io_latency);\r\n#endif\r\nif (MT_GET_FMT (uptr) < MTUF_F_ANSI)\r\n    fflush (uptr->fileref);\r\n}\r\n\r\nstatic const char *_sim_tape_format_name (UNIT *uptr)\r\n{\r\nint32 f = MT_GET_FMT (uptr);\r\n\r\nif (f == MTUF_F_ANSI)\r\n    return ansi_args[MT_GET_ANSI_TYP (uptr)].name;\r\nelse\r\n    return fmts[f].name;\r\n}\r\n\r\n/* Attach tape unit */\r\n\r\nt_stat sim_tape_attach (UNIT *uptr, CONST char *cptr)\r\n{\r\nDEVICE *dptr;\r\n\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nreturn sim_tape_attach_ex (uptr, cptr, ((dptr->flags & DEV_DEBUG) || (dptr->debflags != NULL)) ? MTSE_DBG_API : 0, 0);\r\n}\r\n\r\nt_stat sim_tape_attach_ex (UNIT *uptr, const char *cptr, uint32 dbit, int completion_delay)\r\n{\r\nstruct tape_context *ctx;\r\nuint32 objc;\r\nDEVICE *dptr;\r\nchar gbuf[CBUFSIZE];\r\nchar export_file[CBUFSIZE] = \"\";\r\nt_stat r;\r\nt_bool auto_format = FALSE;\r\nt_bool had_debug = (sim_deb != NULL);\r\nuint32 starting_dctrl = uptr->dctrl;\r\nint32 saved_switches = sim_switches;\r\nMEMORY_TAPE *tape = NULL;\r\n\r\nif ((dptr = find_dev_from_unit (uptr)) == NULL)\r\n    return SCPE_NOATT;\r\nif (sim_switches & SWMASK ('F')) {                      /* format spec? */\r\n    cptr = get_glyph (cptr, gbuf, 0);                   /* get spec */\r\n    if (*cptr == 0)                                     /* must be more */\r\n        return sim_messagef (SCPE_2FARG, \"Missing Format specifier and/or filename to attach\\n\");\r\n    if (sim_tape_set_fmt (uptr, 0, gbuf, NULL) != SCPE_OK)\r\n        return sim_messagef (SCPE_ARG, \"Invalid Tape Format: %s\\n\", gbuf);\r\n    sim_switches = sim_switches & ~(SWMASK ('F'));      /* Record Format specifier already processed */\r\n    auto_format = TRUE;\r\n    }\r\nif (sim_switches & SWMASK ('B')) {                      /* Record Size (blocking factor)? */\r\n    cptr = get_glyph (cptr, gbuf, 0);                   /* get spec */\r\n    if (*cptr == 0)                                     /* must be more */\r\n        return sim_messagef (SCPE_2FARG, \"Missing Record Size and/or filename to attach\\n\");\r\n    if ((MT_GET_FMT (uptr) != MTUF_F_TAR) &&            /* -B is honored for TAR, */\r\n        (MT_GET_FMT (uptr) != MTUF_F_FIXED) &&          /*     FIXED, */\r\n        ((MT_GET_FMT (uptr) == MTUF_F_ANSI) &&\r\n         ((MT_GET_ANSI_TYP (uptr) != MTAT_F_VMS) &&     /*     ANSI-VMS, */\r\n          (MT_GET_ANSI_TYP (uptr) != MTAT_F_RSX11) &&   /*     ANSI-RSX11, */\r\n          (MT_GET_ANSI_TYP (uptr) != MTAT_F_VAR)))) {   /*     and ANSI-VAR only */\r\n        sim_messagef (SCPE_ARG, \"The -B option is ignored for %s format\\n\", _sim_tape_format_name (uptr));\r\n        }\r\n    else {\r\n        uint32 recsize = (uint32) get_uint (gbuf, 10, MAX_RECORD_SIZE, &r);\r\n        if ((r != SCPE_OK) || (recsize < MIN_RECORD_SIZE))\r\n            return sim_messagef (SCPE_ARG, \"Invalid Tape Record Size: %s\\n\", gbuf);\r\n        uptr->recsize = recsize;\r\n        }\r\n    sim_switches = sim_switches & ~(SWMASK ('B'));      /* Record Blocking Factor */\r\n    }\r\nif (sim_switches & SWMASK ('E'))                        /* On-disk tape image file must exist? */\r\n    if (MT_GET_FMT (uptr) >= MTUF_F_ANSI)               /* Does not apply to MEMORY_TAPE images */\r\n        sim_messagef (SCPE_ARG, \"The -E option is ignored for %s format\\n\", _sim_tape_format_name (uptr));\r\nif (fmts[MT_GET_FMT (uptr)].uflags & UNIT_RO)           /* Force ReadOnly attach for TPC, */\r\n    sim_switches |= SWMASK ('R');                       /*     TAR, ANSI, FIXED and DOS11 */\r\nif (sim_switches & SWMASK ('X'))                        /* Export as SIMH? */\r\n    cptr = get_glyph_nc (cptr, export_file, 0);         /* get export file spec */\r\n\r\nswitch (MT_GET_FMT (uptr)) {\r\n    case MTUF_F_ANSI:\r\n        {\r\n            const char *ocptr = cptr;\r\n            char label[CBUFSIZE] = \"simh\";\r\n            int file_errors = 0;\r\n\r\n            if ((MT_GET_ANSI_TYP (uptr) == MTAT_F_RT11)  ||\r\n                (MT_GET_ANSI_TYP (uptr) == MTAT_F_RSTS))\r\n                uptr->recsize = 512;\r\n            if (uptr->recsize == 0)\r\n                uptr->recsize = 2048;\r\n            tape = ansi_create_tape (label, uptr->recsize, MT_GET_ANSI_TYP (uptr));\r\n            uptr->fileref = (FILE *)tape;\r\n            if (uptr->fileref == NULL)\r\n                return SCPE_MEM;\r\n            while (*cptr != 0) {                                    /* do all mods */\r\n                uint32 initial_file_count = tape->file_count;\r\n\r\n                cptr = get_glyph_nc (cptr, gbuf, ',');              /* get filename */\r\n                r = sim_dir_scan (gbuf, sim_tape_add_ansi_entry, tape);\r\n                if (r != SCPE_OK)\r\n                    sim_messagef (SCPE_ARG, \"file not found: %s\\n\", gbuf);\r\n                if (tape->file_count == initial_file_count)\r\n                    ++file_errors;\r\n                }\r\n            if ((tape->file_count > 0) && (file_errors == 0)) {\r\n                r = SCPE_OK;\r\n                memory_tape_add_block (tape, NULL, 0);  /* Tape Mark */\r\n                /* RT-11 and RSTS write three tape marks at the end of an ANSI volume */\r\n                /* RSX-11 and VMS do not, but there is no harm in the extra tape mark */\r\n                memory_tape_add_block (tape, NULL, 0);  /* Tape Mark */\r\n                uptr->flags |= UNIT_ATT;\r\n                uptr->filename = (char *)malloc (strlen (ocptr) + 1);\r\n                strcpy (uptr->filename, ocptr);\r\n                uptr->tape_eom = tape->record_count;\r\n                }\r\n            else {\r\n                r = SCPE_ARG;\r\n                memory_free_tape (uptr->fileref);\r\n                uptr->fileref = NULL;\r\n                cptr = ocptr;\r\n                }\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_FIXED:\r\n        {\r\n            FILE *f;\r\n            struct stat statb;\r\n            size_t max_record_size;\r\n            t_bool lf_line_endings;\r\n            t_bool crlf_line_endings;\r\n            uint8 *block = NULL;\r\n            int error = FALSE;\r\n            static const uint8 ascii2ebcdic[128] = {\r\n                0000,0001,0002,0003,0067,0055,0056,0057,\r\n                0026,0005,0045,0013,0014,0015,0016,0017,\r\n                0020,0021,0022,0023,0074,0075,0062,0046,\r\n                0030,0031,0077,0047,0034,0035,0036,0037,\r\n                0100,0117,0177,0173,0133,0154,0120,0175,\r\n                0115,0135,0134,0116,0153,0140,0113,0141,\r\n                0360,0361,0362,0363,0364,0365,0366,0367,\r\n                0370,0371,0172,0136,0114,0176,0156,0157,\r\n                0174,0301,0302,0303,0304,0305,0306,0307,\r\n                0310,0311,0321,0322,0323,0324,0325,0326,\r\n                0327,0330,0331,0342,0343,0344,0345,0346,\r\n                0347,0350,0351,0112,0340,0132,0137,0155,\r\n                0171,0201,0202,0203,0204,0205,0206,0207,\r\n                0210,0211,0221,0222,0223,0224,0225,0226,\r\n                0227,0230,0231,0242,0243,0244,0245,0246,\r\n                0247,0250,0251,0300,0152,0320,0241,0007};\r\n\r\n            memset (&statb, 0, sizeof (statb));\r\n            tape = memory_create_tape ();\r\n            uptr->fileref = (FILE *)tape;\r\n            if (uptr->fileref == NULL)\r\n                return SCPE_MEM;\r\n            f = fopen (cptr, \"rb\");\r\n            if (f == NULL) {\r\n                r = sim_messagef (SCPE_OPENERR, \"Can't open: %s - %s\\n\", cptr, strerror (errno));\r\n                break;\r\n                }\r\n            if (fstat (fileno (f), &statb) != 0) {\r\n                r = sim_messagef (SCPE_OPENERR, \"Can't stat: %s - %s\\n\", cptr, strerror (errno));\r\n                fclose (f);\r\n                break;\r\n                }\r\n            r = SCPE_OK;\r\n            tape_classify_file_contents (f, &max_record_size, &lf_line_endings, &crlf_line_endings);\r\n            if (!lf_line_endings && !crlf_line_endings) {       /* binary file? */\r\n                if (uptr->recsize == 0)\r\n                    uptr->recsize = 512;\r\n                if ((statb.st_size % uptr->recsize) != 0) {\r\n                    r = sim_messagef (SCPE_ARG, \"Binary file data is not a multiple of the specified record size (%d)\\n\", (int)uptr->recsize);\r\n                    fclose (f);\r\n                    break;\r\n                    }\r\n                tape->block_size = uptr->recsize;\r\n                block = (uint8 *)malloc (tape->block_size);\r\n                while (!feof (f) && !error) {\r\n                    size_t data_read = fread (block, 1, tape->block_size, f);\r\n                    if (data_read == tape->block_size)\r\n                        error = memory_tape_add_block (tape, block, tape->block_size);\r\n                    else {\r\n                        if (data_read != 0) {\r\n                            r = sim_messagef (SCPE_ARG, \"Read %u bytes of data when expecting %u bytes\\n\", (uint32)data_read, (uint32)tape->block_size);\r\n                            error = TRUE;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            else {                                              /* text file */\r\n                if (uptr->recsize == 0)\r\n                    uptr->recsize = max_record_size;\r\n                if (uptr->recsize < max_record_size) {\r\n                    r = sim_messagef (SCPE_ARG, \"Text file: %s has lines longer than %d.  Max Line Size: %d\\n\", cptr, (int)uptr->recsize, (int)max_record_size);\r\n                    fclose (f);\r\n                    break;\r\n                    }\r\n                tape->block_size = uptr->recsize;\r\n                block = (uint8 *)calloc (1, tape->block_size + 3);\r\n                while (!feof (f) && !error) {\r\n                    if (fgets ((char *)block, (int)(tape->block_size + 3), f)) {\r\n                        size_t len = strlen ((char *)block);\r\n\r\n                        while ((len > 0) &&\r\n                               ((block[len - 1] == '\\r') || (block[len - 1] == '\\n')))\r\n                            --len;\r\n                        memset (block + len, ' ', tape->block_size - len);\r\n                        if (sim_switches & SWMASK ('C')) {\r\n                            uint32 i;\r\n\r\n                            for (i = 0; i < tape->block_size; i++)\r\n                                block[i] = ascii2ebcdic[block[i]];\r\n                            }\r\n                        error = memory_tape_add_block (tape, block, tape->block_size);\r\n                        }\r\n                    else\r\n                        error = ferror (f);\r\n                    }\r\n                }\r\n            free (block);\r\n            fclose (f);\r\n            if (error)\r\n                r = sim_messagef (SCPE_IERR, \"Error processing input file %s\\n\", cptr);\r\n            else {\r\n                memory_tape_add_block (tape, NULL, 0);  /* Tape Mark */\r\n                memory_tape_add_block (tape, NULL, 0);  /* Tape Mark */\r\n                uptr->flags |= UNIT_ATT;\r\n                uptr->filename = (char *)malloc (strlen (cptr) + 1);\r\n                strcpy (uptr->filename, cptr);\r\n                uptr->tape_eom = tape->record_count;\r\n                }\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_DOS11:\r\n        {\r\n            const char *ocptr = cptr;\r\n            int file_errors = 0;\r\n\r\n            uptr->recsize = 512;\r\n\r\n            tape = memory_create_tape();\r\n            tape->block_size = uptr->recsize;\r\n            uptr->fileref = (FILE *)tape;\r\n            if (uptr->fileref == NULL)\r\n                return SCPE_MEM;\r\n\r\n            while (*cptr != 0) {\r\n                uint32 initial_file_count = tape->file_count;\r\n\r\n                cptr = get_glyph_nc (cptr, gbuf, ',');   /* Get filename */\r\n                r = sim_dir_scan (gbuf, sim_tape_add_dos11_entry, tape);\r\n                if (r != SCPE_OK)\r\n                    sim_messagef (SCPE_ARG, \"file not found: %s\\n\", gbuf);\r\n                if (tape->file_count == initial_file_count)\r\n                    ++file_errors;\r\n                }\r\n\r\n            if ((tape->file_count > 0) && (file_errors == 0)) {\r\n                r = SCPE_OK;\r\n                memory_tape_add_block (tape, NULL, 0); /* Tape Mark */\r\n                /* RSX-11 and RSTS write three tape marks at the end of a DOS volume */\r\n                /* VMS does not, but there is no harm in the extra tape mark         */\r\n                memory_tape_add_block (tape, NULL, 0); /* Tape Mark */\r\n                uptr->flags |= UNIT_ATT;\r\n                uptr->filename = (char *)malloc (strlen (ocptr) + 1);\r\n                strcpy (uptr->filename, ocptr);\r\n                uptr->tape_eom = tape->record_count;\r\n                }\r\n            else {\r\n                r = SCPE_ARG;\r\n                cptr = ocptr;\r\n                }\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_TAR:\r\n        if (uptr->recsize == 0)\r\n            uptr->recsize = TAR_DFLT_RECSIZE;           /* Apply default block size */\r\n        if ((uptr->recsize % 512) != 0)\r\n            return sim_messagef (SCPE_ARG, \"TAR format block size of %u is not a multiple of 512\\n\", uptr->recsize);\r\n        sim_switches |= SWMASK ('E');                   /* The TAR file must exist */\r\n        /* fall through */\r\n    default:\r\n        r = attach_unit (uptr, (CONST char *)cptr);     /* attach unit */\r\n        break;\r\n    }\r\nif (r != SCPE_OK) {                                     /* error? */\r\n    if (MT_GET_FMT (uptr) >= MTUF_F_ANSI) {\r\n        r = sim_messagef (r, \"Error opening %s format internal tape image generated from: '%s'\\n\", _sim_tape_format_name (uptr), cptr);\r\n        memory_free_tape (uptr->fileref);\r\n        uptr->fileref = NULL;\r\n        }\r\n    else\r\n        r = sim_messagef (r, \"Error opening %s format tape image: '%s' - %s\\n\", _sim_tape_format_name (uptr), cptr, strerror(errno));\r\n    if (auto_format)    /* format was specified at attach time? */\r\n        sim_tape_set_fmt (uptr, 0, \"SIMH\", NULL);   /* restore default format */\r\n    uptr->recsize = 0;\r\n    uptr->tape_eom = 0;\r\n    return r;\r\n    }\r\n\r\nif ((sim_switches & SWMASK ('D')) && !had_debug) {\r\n    sim_switches |= SWMASK ('E');\r\n    sim_switches &= ~(SWMASK ('D') | SWMASK ('R') | SWMASK ('F'));\r\n    sim_set_debon (0, \"STDOUT\");\r\n    sim_switches = saved_switches;\r\n    }\r\nif (sim_switches & SWMASK ('D'))\r\n    uptr->dctrl = MTSE_DBG_STR | MTSE_DBG_DAT;\r\n\r\nuptr->tape_ctx = ctx = (struct tape_context *)calloc(1, sizeof(struct tape_context));\r\nctx->dptr = dptr;                                       /* save DEVICE pointer */\r\nctx->dbit = dbit;                                       /* save debug bit */\r\nctx->auto_format = auto_format;                         /* save that we auto selected format */\r\n\r\nswitch (MT_GET_FMT (uptr)) {                            /* case on format */\r\n\r\n    case MTUF_F_TPC:                                    /* TPC */\r\n        objc = sim_tape_tpc_map (uptr, NULL, 0);        /* get # objects */\r\n        if (objc == 0) {                                /* tape empty? */\r\n            sim_tape_detach (uptr);\r\n            r = SCPE_FMT;                               /* yes, complain */\r\n            }\r\n        uptr->filebuf = calloc (objc + 1, sizeof (t_addr));\r\n        if (uptr->filebuf == NULL) {                    /* map allocated? */\r\n            sim_tape_detach (uptr);\r\n            r = SCPE_MEM;                               /* no, complain */\r\n            }\r\n        uptr->hwmark = objc + 1;                        /* save map size */\r\n        sim_tape_tpc_map (uptr, (t_addr *) uptr->filebuf, objc);/* fill map */\r\n        break;\r\n\r\n    case MTUF_F_TAR:                                    /* TAR */\r\n        uptr->hwmark = (t_addr)sim_fsize (uptr->fileref);\r\n        break;\r\n\r\n    default:\r\n        break;\r\n        }\r\n\r\nif (r == SCPE_OK) {\r\n\r\n    sim_tape_validate_tape (uptr);\r\n\r\n    sim_tape_rewind (uptr);\r\n\r\n#if defined (SIM_ASYNCH_IO)\r\n    sim_tape_set_async (uptr, completion_delay);\r\n#endif\r\n    uptr->io_flush = _sim_tape_io_flush;\r\n    }\r\n\r\nif ((sim_switches & SWMASK ('D')) && !had_debug)\r\n    sim_set_deboff (0, NULL);\r\nif (sim_switches & SWMASK ('D'))\r\n    uptr->dctrl = starting_dctrl;\r\nif ((r == SCPE_OK) && (sim_switches & SWMASK ('X')))\r\n    r = sim_export_tape (uptr, export_file);\r\nreturn r;\r\n}\r\n\r\n/* Detach tape unit */\r\n\r\nt_stat sim_tape_detach (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx;\r\nuint32 f;\r\nt_bool auto_format = FALSE;\r\n\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nsim_cancel (uptr);\r\nif (!(uptr->flags & UNIT_ATT))\r\n    return SCPE_UNATT;\r\n\r\nctx = (struct tape_context *)uptr->tape_ctx;\r\nf = MT_GET_FMT (uptr);\r\n\r\nif (uptr->io_flush)\r\n    uptr->io_flush (uptr);                              /* flush buffered data */\r\nif (ctx)\r\n    auto_format = ctx->auto_format;\r\n\r\nsim_tape_clr_async (uptr);\r\n\r\nMT_CLR_INMRK (uptr);                                    /* Not within a TAR tapemark */\r\nif (MT_GET_FMT (uptr) >= MTUF_F_ANSI) {\r\n    memory_free_tape ((void *)uptr->fileref);\r\n    uptr->fileref = NULL;\r\n    }\r\nswitch (f) {                                            /* case on format */\r\n\r\n    case MTUF_F_TPC:                                    /* TPC */\r\n        if (uptr->filebuf)                              /* free map */\r\n            free (uptr->filebuf);\r\n        uptr->filebuf = NULL;\r\n        break;\r\n\r\n    default:\r\n        break;\r\n        }\r\nuptr->hwmark = 0;\r\nuptr->recsize = 0;\r\nuptr->tape_eom = 0;\r\nuptr->pos = 0;\r\nMT_CLR_PNU (uptr);\r\nMT_CLR_INMRK (uptr);                                    /* Not within a TAR tapemark */\r\nfree (ctx->chunk_buf);\r\nfree (uptr->tape_ctx);\r\nuptr->tape_ctx = NULL;\r\nuptr->io_flush = NULL;\r\nuptr->flags = uptr->flags & ~(UNIT_ATT | ((uptr->flags & UNIT_ROABLE) ? UNIT_RO : 0));\r\nfree (uptr->filename);\r\nuptr->filename = NULL;\r\nif (uptr->fileref) {                        /* Only close open file */\r\n    if (fclose (uptr->fileref) == EOF) {\r\n        uptr->fileref = NULL;\r\n        return SCPE_IOERR;\r\n        }\r\n    uptr->fileref = NULL;\r\n    }\r\nuptr->dynflags &= ~UNIT_NO_FIO;\r\nif (auto_format)    /* format was determined or specified at attach time? */\r\n    sim_tape_set_fmt (uptr, 0, \"SIMH\", NULL);   /* restore default format */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_tape_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\nfprintf (st, \"%s Tape Attach Help\\n\\n\", dptr->name);\r\nif (0 == (uptr - dptr->units)) {\r\n    if (dptr->numunits > 1) {\r\n        uint32 i;\r\n\r\n        for (i = 0; i < dptr->numunits; ++i)\r\n            if (dptr->units[i].flags & UNIT_ATTABLE)\r\n                fprintf (st, \"  sim> ATTACH {switches} %s%d tapefile\\n\\n\", dptr->name, i);\r\n        }\r\n    else\r\n        fprintf (st, \"  sim> ATTACH {switches} %s tapefile\\n\\n\", dptr->name);\r\n    }\r\nelse\r\n    fprintf (st, \"  sim> ATTACH {switches} %s tapefile\\n\\n\", dptr->name);\r\nfprintf (st, \"Attach command switches\\n\");\r\nfprintf (st, \"    -R          Attach Read Only.\\n\");\r\nfprintf (st, \"    -E          Must Exist (if not specified, the default behavior is to\\n\");\r\nfprintf (st, \"                attempt to create the indicated virtual tape file).\\n\");\r\nfprintf (st, \"    -N          Create a new empty tape container file.\\n\");\r\nfprintf (st, \"    -Q          Suppress informative messages during attach activities.\\n\");\r\nfprintf (st, \"    -F          Open the indicated tape container in a specific format\\n\");\r\nfprintf (st, \"                (default is SIMH, alternatives are E11, TPC, P7B, AWS, TAR,\\n\");\r\nfprintf (st, \"                ANSI-VMS, ANSI-RT11, ANSI-RSX11, ANSI-RSTS, ANSI-VAR, FIXED,\\n\");\r\nfprintf (st, \"                DOS11)\\n\");\r\nfprintf (st, \"    -B          For TAR format tapes, the record size for data read from the\\n\");\r\nfprintf (st, \"                specified file.  This record size will be used for all but \\n\");\r\nfprintf (st, \"                possibly the last record which will be what remains unread.\\n\");\r\nfprintf (st, \"                The default TAR record size is 10240.  For FIXED format tapes\\n\");\r\nfprintf (st, \"                -B specifies the record size for binary data or the maximum \\n\");\r\nfprintf (st, \"                record size for text data\\n\");\r\nfprintf (st, \"    -V          Display some summary information about the record structure\\n\");\r\nfprintf (st, \"                observed in the tape image observed during the attach\\n\");\r\nfprintf (st, \"                validation pass\\n\");\r\nfprintf (st, \"    -L          Display detailed record size counts observed during attach\\n\");\r\nfprintf (st, \"                validation pass\\n\");\r\nfprintf (st, \"    -D          Causes the internal tape structure information to be displayed\\n\");\r\nfprintf (st, \"                while the tape image is scanned.\\n\");\r\nfprintf (st, \"    -C          Causes FIXED format tape data sets derived from text files to\\n\");\r\nfprintf (st, \"                be converted from ASCII to EBCDIC.\\n\");\r\nfprintf (st, \"    -X          Extract a copy of the attached tape and convert it to a SIMH\\n\");\r\nfprintf (st, \"                format tape image.\\n\\n\");\r\nfprintf (st, \"Notes:  ANSI-VMS, ANSI-RT11, ANSI-RSTS, ANSI-RSX11, ANSI-VAR formats allows\\n\");\r\nfprintf (st, \"        one or several files to be presented to as a read only ANSI Level 3\\n\");\r\nfprintf (st, \"        labeled tape with file labels that make each individual file\\n\");\r\nfprintf (st, \"        accessible directly as files on the tape.\\n\\n\");\r\nfprintf (st, \"        FIXED format will present the contents of a file (text or binary) as\\n\");\r\nfprintf (st, \"        fixed sized records/blocks with ascii text data optionally converted\\n\");\r\nfprintf (st, \"        to EBCDIC.\\n\\n\");\r\nfprintf (st, \"        DOS11 format will present the contents of a file preceded by a DOS11\\n\");\r\nfprintf (st, \"        14-byte header. All files will be owned by [1,1], have a default\\n\");\r\nfprintf (st, \"        protection of <233> and a date in the range 1972 - 1999 with the\\n\");\r\nfprintf (st, \"        month/day layout as the current year. The file name on the tape\\n\");\r\nfprintf (st, \"        will be sanitized to contain only alphanumeric characters from the\\n\");\r\nfprintf (st, \"        original source file name. Characters 7 - 9 of the file name will be\\n\");\r\nfprintf (st, \"        placed in an otherwise unused word in the header which some DEC\\n\");\r\nfprintf (st, \"        operating systems will be able to process. If the resulting\\n\");\r\nfprintf (st, \"        filename is NULL, a filename in the range 000000 - 999999 will be\\n\");\r\nfprintf (st, \"        generated based of the file position on the tape.\\n\\n\");\r\nfprintf (st, \"Examples:\\n\\n\");\r\nfprintf (st, \"  sim> ATTACH %s -F ANSI-VMS Hobbyist-USE-ONLY-VA.TXT\\n\", dptr->name);\r\nfprintf (st, \"  sim> ATTACH %s -F ANSI-RSX11 *.TXT,*.ini,*.exe\\n\", dptr->name);\r\nfprintf (st, \"  sim> ATTACH %s -FX ANSI-RSTS RSTS.tap *.TXT,*.SAV\\n\", dptr->name);\r\nfprintf (st, \"  sim> ATTACH %s -F ANSI-RT11 *.TXT,*.TSK\\n\", dptr->name);\r\nfprintf (st, \"  sim> ATTACH %s -FB FIXED 80 SOMEFILE.TXT\\n\", dptr->name);\r\nfprintf (st, \"  sim> ATTACH %s -F DOS11 *.LDA,*.TXT\\n\\n\", dptr->name);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic void sim_tape_data_trace(UNIT *uptr, const uint8 *data, size_t len, const char* txt, int detail, uint32 reason)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nif (ctx == NULL)\r\n    return;\r\nif (sim_deb && ((uptr->dctrl | ctx->dptr->dctrl) & reason))\r\n    sim_data_trace(ctx->dptr, uptr, (detail ? data : NULL), \"\", len, txt, reason);\r\n}\r\n\r\nstatic int sim_tape_seek (UNIT *uptr, t_addr pos)\r\n{\r\nif (MT_GET_FMT (uptr) < MTUF_F_ANSI)\r\n    return sim_fseek (uptr->fileref, pos, SEEK_SET);\r\nreturn 0;\r\n}\r\n\r\nstatic t_offset sim_tape_size (UNIT *uptr)\r\n{\r\nif (MT_GET_FMT (uptr) < MTUF_F_ANSI)\r\n    return sim_fsize_ex (uptr->fileref); /* True on-disk tape images: file size  */\r\nreturn uptr->tape_eom;                   /* Virtual tape images: record/TM count */\r\n}\r\n\r\n/* Read record length forward (internal routine).\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        bc      =       pointer to returned record length\r\n\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       tape position\r\n   ------------------   -----------------------------------------------------\r\n   unit unattached      unchanged\r\n   read error           unchanged, PNU set\r\n   end of file/medium   updated if a gap precedes, else unchanged and PNU set\r\n   tape mark            updated\r\n   tape runaway         updated\r\n   data record          updated, sim_fread will read record forward\r\n\r\n   This routine is called to set up a record read or spacing in the forward\r\n   direction.  On return, status is MTSE_OK and the tape is positioned at the\r\n   first data byte if a record was encountered, or status is an MTSE error code\r\n   giving the reason that the operation did not succeed and the tape position is\r\n   as indicated above.\r\n\r\n   The ANSI standards for magnetic tape recording (X3.22, X3.39, and X3.54) and\r\n   the equivalent ECMA standard (ECMA-62) specify a maximum erase gap length of\r\n   25 feet (7.6 meters).  While gaps of any length may be written, gaps longer\r\n   than this are non-standard and may indicate that an unrecorded or erased tape\r\n   is being read.\r\n\r\n   If the tape density has been set via a previous \"sim_tape_set_dens\" call,\r\n   then the length is monitored when skipping over erase gaps.  If the length\r\n   reaches 25 feet, motion is terminated, and MTSE_RUNAWAY status is returned.\r\n   Runaway status is also returned if an end-of-medium marker or the physical\r\n   end of file is encountered while spacing over a gap; however, MTSE_EOM is\r\n   returned if the tape is positioned at the EOM or EOF on entry.\r\n\r\n   If the density has not been set, then a gap of any length is skipped, and\r\n   MTSE_RUNAWAY status is never returned.  In effect, erase gaps present in the\r\n   tape image file will be transparent to the caller.\r\n\r\n   Erase gaps are currently supported only in SIMH (MTUF_F_STD) tape format.\r\n   Because gaps may be partially overwritten with data records, gap metadata\r\n   must be examined marker-by-marker.  To reduce the number of file read calls,\r\n   a buffer of metadata elements is used.  The buffer size is initially\r\n   established at 256 elements but may be set to any size desired.  To avoid a\r\n   large read for the typical case where an erase gap is not present, the first\r\n   read is of a single metadatum marker.  If that is a gap marker, then\r\n   additional buffered reads are performed.\r\n\r\n   See the notes at \"tape_erase_fwd\" regarding the erase gap implementation.\r\n\r\n\r\n   Implementation notes:\r\n\r\n    1. For programming convenience, erase gap processing is performed for both\r\n       SIMH standard and E11 tape formats, although the latter will never\r\n       contain erase gaps, as the \"tape_erase_fwd\" call takes no action for the\r\n       E11 format.\r\n\r\n    2. The \"feof\" call cannot return a non-zero value on the first pass through\r\n       the loop, because the \"sim_fseek\" call resets the internal end-of-file\r\n       indicator.  Subsequent passes only occur if an erase gap is present, so\r\n       a non-zero return indicates an EOF was seen while reading through a gap.\r\n\r\n    3. The \"runaway_counter\" cannot decrement to zero (or below) in the presence\r\n       of an error that terminates the gap-search loop.  Therefore, the test\r\n       after the loop exit need not check for error status.\r\n\r\n    4. The dynamic start/stop test of the HP 3000 magnetic tape diagnostic\r\n       heavily exercises the erase gap scanning code.  Sample test execution\r\n       times for various buffer sizes on a 2 GHz host platform are:\r\n\r\n         buffer size    execution time\r\n         (elements)     (CPU seconds)\r\n         -----------    --------------\r\n               1             7200\r\n              32              783\r\n             128              237\r\n             256              203\r\n             512              186\r\n            1024              171\r\n\r\n    5. Because an erase gap may precede the logical end-of-medium, represented\r\n       either by the physical end-of-file or by an EOM marker, the \"position not\r\n       updated\" flag is set only if the tape is positioned at the EOM when the\r\n       routine is entered.  If at least one gap marker precedes the EOM, then\r\n       the PNU flag is not set.  This ensures that a backspace-and-retry\r\n       sequence will work correctly in both cases.\r\n*/\r\n\r\nstatic t_stat sim_tape_rdlntf (UNIT *uptr, t_mtrlnt *bc)\r\n{\r\nuint8    c;\r\nt_bool   all_eof;\r\nuint32   f = MT_GET_FMT (uptr);\r\nt_mtrlnt sbc;\r\nt_tpclnt tpcbc;\r\nt_awshdr awshdr;\r\nsize_t   rdcnt;\r\nt_mtrlnt buffer [256];                                  /* local tape buffer */\r\nt_addr   saved_pos = uptr->pos;\r\nuint32   bufcntr, bufcap;                               /* buffer counter and capacity */\r\nint32    runaway_counter, sizeof_gap;                   /* bytes remaining before runaway and bytes per gap */\r\nt_stat   status = MTSE_OK;\r\n\r\nMT_CLR_PNU (uptr);                                      /* clear the position-not-updated flag */\r\n*bc = 0;\r\n\r\nif ((uptr->flags & UNIT_ATT) == 0)                      /* if the unit is not attached */\r\n    return MTSE_UNATT;                                  /*   then quit with an error */\r\n\r\nif ((uptr->tape_eom > 0) &&\r\n    (uptr->pos >= uptr->tape_eom)) {\r\n    MT_SET_PNU (uptr);                                  /*   then set position not updated */\r\n    return MTSE_EOM;                                    /*     and quit with I/O error status */\r\n    }\r\n\r\nif (sim_tape_seek (uptr, uptr->pos)) {                  /* set the initial tape position; if it fails */\r\n    MT_SET_PNU (uptr);                                  /*   then set position not updated */\r\n    return sim_tape_ioerr (uptr);                       /*     and quit with I/O error status */\r\n    }\r\n\r\nswitch (f) {                                       /* otherwise the read method depends on the tape format */\r\n\r\n    case MTUF_F_STD:\r\n    case MTUF_F_E11:\r\n        runaway_counter = 25 * 12 * bpi [MT_DENS (uptr->dynflags)]; /* set the largest legal gap size in bytes */\r\n\r\n        if (runaway_counter == 0) {                     /* if tape density has not been not set */\r\n            sizeof_gap = 0;                             /*   then disable runaway detection */\r\n            runaway_counter = INT_MAX;                  /*     to allow gaps of any size */\r\n            }\r\n\r\n        else                                            /* otherwise */\r\n            sizeof_gap = sizeof (t_mtrlnt);             /*   set the size of the gap */\r\n\r\n        bufcntr = 0;                                    /* force an initial read */\r\n        bufcap = 0;                                     /*   but of just one metadata marker */\r\n\r\n        do {                                            /* loop until a record, gap, or error is seen */\r\n            if (bufcntr == bufcap) {                    /* if the buffer is empty then refill it */\r\n                if (feof (uptr->fileref)) {             /* if we hit the EOF while reading a gap */\r\n                    if (sizeof_gap > 0)                 /*   then if detection is enabled */\r\n                        status = MTSE_RUNAWAY;          /*     then report a tape runaway */\r\n                    else                                /*   otherwise report the physical EOF */\r\n                        status = MTSE_EOM;              /*     as the end-of-medium */\r\n                    break;\r\n                    }\r\n\r\n                else if (bufcap == 0)                   /* otherwise if this is the initial read */\r\n                    bufcap = 1;                         /*   then start with just one marker */\r\n\r\n                else                                    /* otherwise reset the capacity */\r\n                    bufcap = sizeof (buffer)            /*   to the full size of the buffer */\r\n                               / sizeof (buffer [0]);\r\n\r\n                bufcap = sim_fread (buffer,             /* fill the buffer */\r\n                                    sizeof (t_mtrlnt),  /*   with tape metadata */\r\n                                    bufcap,\r\n                                    uptr->fileref);\r\n\r\n                if (ferror (uptr->fileref)) {           /* if a file I/O error occurred */\r\n                    if (bufcntr == 0)                   /*   then if this is the initial read */\r\n                        MT_SET_PNU (uptr);              /*     then set position not updated */\r\n\r\n                    status = sim_tape_ioerr (uptr);     /* report the error and quit */\r\n                    break;\r\n                    }\r\n\r\n                else if (bufcap == 0                    /* otherwise if positioned at the physical EOF */\r\n                  || buffer [0] == MTR_EOM)             /*   or at the logical EOM */\r\n                    if (bufcntr == 0) {                 /*     then if this is the initial read */\r\n                        MT_SET_PNU (uptr);              /*       then set position not updated */\r\n                        status = MTSE_EOM;              /*         and report the end-of-medium and quit */\r\n                        uptr->tape_eom = uptr->pos;\r\n                        break;\r\n                        }\r\n\r\n                    else {                              /*     otherwise some gap has already been skipped */\r\n                        if (sizeof_gap > 0)             /*       so if detection is enabled */\r\n                            status = MTSE_RUNAWAY;      /*         then report a tape runaway */\r\n                        else                            /*       otherwise report the physical EOF */\r\n                            status = MTSE_EOM;          /*         as the end-of-medium */\r\n                        break;\r\n                        }\r\n\r\n                else                                    /* otherwise reset the index */\r\n                    bufcntr = 0;                        /*   to the start of the buffer */\r\n                }\r\n\r\n            *bc = buffer [bufcntr++];                   /* store the metadata marker value */\r\n\r\n            if (*bc == MTR_EOM) {                       /* if an end-of-medium marker is seen */\r\n                if (sizeof_gap > 0)                     /*   then if detection is enabled */\r\n                    status = MTSE_RUNAWAY;              /*     then report a tape runaway */\r\n                else                                    /*   otherwise report the physical EOF */\r\n                    status = MTSE_EOM;                  /*     as the end-of-medium */\r\n                break;\r\n                }\r\n\r\n            uptr->pos += sizeof (t_mtrlnt);             /* space over the marker */\r\n\r\n            if (*bc == MTR_TMK) {                       /* if the value is a tape mark */\r\n                status = MTSE_TMK;                      /*   then quit with tape mark status */\r\n                break;\r\n                }\r\n\r\n            else if (*bc == MTR_GAP)                    /* otherwise if the value is a full gap */\r\n                runaway_counter -= sizeof_gap;          /*   then decrement the gap counter */\r\n\r\n            else if (*bc == MTR_FHGAP) {                /* otherwise if the value if a half gap */\r\n                uptr->pos -= sizeof (t_mtrlnt) / 2;     /*   then back up and resync */\r\n\r\n                if (sim_tape_seek (uptr, uptr->pos)) {  /* set the tape position; if it fails */\r\n                    status = sim_tape_ioerr (uptr);     /*   then quit with I/O error status */\r\n                    break;\r\n                    }\r\n\r\n                bufcntr = bufcap;                       /* mark the buffer as invalid to force a read */\r\n\r\n                *bc = (t_mtrlnt)MTR_GAP;                /* reset the marker */\r\n                runaway_counter -= sizeof_gap / 2;      /*   and decrement the gap counter */\r\n                }\r\n\r\n            else {                                      /* otherwise it's a record marker */\r\n                saved_pos = uptr->pos;                  /* Save data position */\r\n                sbc = MTR_L (*bc);                      /* extract the record length */\r\n                uptr->pos = uptr->pos + sizeof (t_mtrlnt)     /* position to the start */\r\n                  + (f == MTUF_F_STD ? (sbc + 1) & ~1 : sbc); /*   of the record */\r\n                }\r\n            }\r\n        while (*bc == MTR_GAP && runaway_counter > 0);  /* continue until data or runaway occurs */\r\n\r\n        if (runaway_counter <= 0)                       /* if a tape runaway occurred */\r\n            status = MTSE_RUNAWAY;                      /*   then report it */\r\n\r\n        if (status == MTSE_OK) {        /* Validate the reverse record size for data records */\r\n            t_mtrlnt rev_lnt;\r\n\r\n            if (sim_tape_seek (uptr, uptr->pos - sizeof (t_mtrlnt))) {  /*   then seek to the end of record size; if it fails */\r\n                status = sim_tape_ioerr (uptr);         /*     then quit with I/O error status */\r\n                break;\r\n                }\r\n\r\n            (void)sim_fread (&rev_lnt,                  /* get the reverse length */\r\n                             sizeof (t_mtrlnt),\r\n                             1,\r\n                             uptr->fileref);\r\n\r\n            if (ferror (uptr->fileref)) {               /* if a file I/O error occurred */\r\n                status = sim_tape_ioerr (uptr);         /* report the error and quit */\r\n                break;\r\n                }\r\n            if (rev_lnt != *bc) {           /* size mismatch? */\r\n                status = MTSE_INVRL;\r\n                uptr->pos -= (sizeof (t_mtrlnt) + *bc + sizeof (t_mtrlnt));\r\n                MT_SET_PNU (uptr);                      /* pos not upd */\r\n                break;\r\n                }\r\n            if (sim_tape_seek (uptr, saved_pos))        /*   then seek back to the beginning of the data; if it fails */\r\n                status = sim_tape_ioerr (uptr);         /*     then quit with I/O error status */\r\n            }\r\n        break;                                          /* otherwise the operation succeeded */\r\n\r\n    case MTUF_F_TPC:\r\n        (void)sim_fread (&tpcbc, sizeof (t_tpclnt), 1, uptr->fileref);\r\n        *bc = (t_mtrlnt)tpcbc;                          /* save rec lnt */\r\n\r\n        if (ferror (uptr->fileref)) {                   /* error? */\r\n            MT_SET_PNU (uptr);                          /* pos not upd */\r\n            status = sim_tape_ioerr (uptr);\r\n            }\r\n        else {\r\n            if ((feof (uptr->fileref)) ||               /* eof? */\r\n                ((tpcbc == TPC_EOM) &&\r\n                 (sim_fsize (uptr->fileref) == (uint32)sim_ftell (uptr->fileref)))) {\r\n                MT_SET_PNU (uptr);                      /* pos not upd */\r\n                status = MTSE_EOM;\r\n                }\r\n            else {\r\n                uptr->pos += sizeof (t_tpclnt);         /* spc over reclnt */\r\n                if (tpcbc == TPC_TMK)                   /* tape mark? */\r\n                    status = MTSE_TMK;\r\n                else\r\n                    uptr->pos += (tpcbc + 1) & ~1;      /* spc over record */\r\n                }\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_P7B:\r\n        for (sbc = 0, all_eof = 1; ; sbc++) {           /* loop thru record */\r\n            (void)sim_fread (&c, sizeof (uint8), 1, uptr->fileref);\r\n\r\n            if (ferror (uptr->fileref)) {               /* error? */\r\n                MT_SET_PNU (uptr);                      /* pos not upd */\r\n                status = sim_tape_ioerr (uptr);\r\n                break;\r\n                }\r\n            else if (feof (uptr->fileref)) {            /* eof? */\r\n                if (sbc == 0)                           /* no data? eom */\r\n                    status = MTSE_EOM;\r\n                break;                                  /* treat like eor */\r\n                }\r\n            else if ((sbc != 0) && (c & P7B_SOR))       /* next record? */\r\n                break;\r\n            else if ((c & P7B_DPAR) != P7B_EOF)\r\n                all_eof = 0;\r\n            }\r\n\r\n        if (status == MTSE_OK) {\r\n            *bc = sbc;                                      /* save rec lnt */\r\n            (void)sim_tape_seek (uptr, uptr->pos);          /* for read */\r\n            uptr->pos = uptr->pos + sbc;                    /* spc over record */\r\n            if (all_eof) {                                  /* tape mark? */\r\n                status = MTSE_TMK;\r\n                *bc = 0;\r\n                }\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_AWS:\r\n        memset (&awshdr, 0, sizeof (awshdr));\r\n        rdcnt = sim_fread (&awshdr, sizeof (t_awslnt), 3, uptr->fileref);\r\n        if (ferror (uptr->fileref)) {           /* error? */\r\n            MT_SET_PNU (uptr);                  /* pos not upd */\r\n            status = sim_tape_ioerr (uptr);\r\n            break;\r\n            }\r\n        if ((feof (uptr->fileref)) ||           /* eof? */\r\n            (rdcnt < 3)) {\r\n            uptr->tape_eom = uptr->pos;\r\n            MT_SET_PNU (uptr);                  /* pos not upd */\r\n            status = MTSE_EOM;\r\n            break;\r\n            }\r\n        uptr->pos += sizeof (t_awshdr);         /* spc over AWS header */\r\n        if (awshdr.rectyp == AWS_TMK)           /* tape mark? */\r\n            status = MTSE_TMK;\r\n        else {\r\n            if (awshdr.rectyp != AWS_REC) {     /* Unknown record type */\r\n                MT_SET_PNU (uptr);              /* pos not upd */\r\n                uptr->tape_eom = uptr->pos;\r\n                status = MTSE_INVRL;\r\n                break;\r\n                }\r\n            else\r\n                status = MTSE_OK;\r\n            }\r\n        /* tape data record (or tapemark) */\r\n        *bc = (t_mtrlnt)awshdr.nxtlen;          /* save rec lnt */\r\n        uptr->pos += awshdr.nxtlen;             /* spc over record */\r\n        memset (&awshdr, 0, sizeof (t_awslnt));\r\n        saved_pos = (t_addr)sim_ftell (uptr->fileref);/* save record data address */\r\n        (void)sim_tape_seek (uptr, uptr->pos); /* for read */\r\n        rdcnt = sim_fread (&awshdr, sizeof (t_awslnt), 3, uptr->fileref);\r\n        if ((rdcnt == 3) &&\r\n            ((awshdr.prelen != *bc) || ((awshdr.rectyp != AWS_REC) && (awshdr.rectyp != AWS_TMK)))) {\r\n            status = MTSE_INVRL;\r\n            uptr->tape_eom = uptr->pos;\r\n            uptr->pos = saved_pos - sizeof (t_awslnt);\r\n            }\r\n        else\r\n            (void)sim_tape_seek (uptr, saved_pos); /* Move back to the data */\r\n        break;\r\n\r\n    case MTUF_F_TAR:\r\n        if (uptr->pos < uptr->hwmark) {\r\n            if ((uptr->hwmark - uptr->pos) >= uptr->recsize)\r\n                *bc = (t_mtrlnt)uptr->recsize;              /* TAR record size */\r\n            else\r\n                *bc = (t_mtrlnt)(uptr->hwmark - uptr->pos); /* TAR remnant last record */\r\n            (void)sim_tape_seek (uptr, uptr->pos);\r\n            uptr->pos += *bc;\r\n            MT_CLR_INMRK (uptr);\r\n            }\r\n        else {\r\n            if (MT_TST_INMRK (uptr))\r\n                status = MTSE_EOM;\r\n            else {\r\n                status = MTSE_TMK;\r\n                MT_SET_INMRK (uptr);\r\n                }\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_ANSI:\r\n    case MTUF_F_FIXED:\r\n    case MTUF_F_DOS11:\r\n        if (1) {\r\n            MEMORY_TAPE *tape = (MEMORY_TAPE *)uptr->fileref;\r\n\r\n            if (uptr->pos >= tape->record_count)\r\n                status = MTSE_EOM;\r\n            else {\r\n                if (tape->records[uptr->pos]->size == 0)\r\n                    status = MTSE_TMK;\r\n                else\r\n                    *bc = tape->records[uptr->pos]->size;\r\n                ++uptr->pos;\r\n                }\r\n            }\r\n        break;\r\n\r\n    default:\r\n        status = MTSE_FMT;\r\n    }\r\n\r\nreturn status;\r\n}\r\n\r\nstatic t_stat sim_tape_rdrlfwd (UNIT *uptr, t_mtrlnt *bc)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat status;\r\n\r\n*bc = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\n\r\nstatus = sim_tape_rdlntf (uptr, bc);                    /* read the record length */\r\n\r\nsim_debug_unit (MTSE_DBG_STR, uptr, \"rd_lntf: st: %d, lnt: %d, pos: %\" T_ADDR_FMT \"u\\n\", status, *bc, uptr->pos);\r\n\r\nreturn status;\r\n}\r\n\r\n/* Read record length reverse (internal routine).\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        bc      =       pointer to returned record length\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       tape position\r\n   ------------------   -------------------------------------------\r\n   unit unattached      unchanged\r\n   beginning of tape    unchanged\r\n   read error           unchanged\r\n   end of file          unchanged\r\n   end of medium        updated\r\n   tape mark            updated\r\n   tape runaway         updated\r\n   data record          updated, sim_fread will read record forward\r\n\r\n   This routine is called to set up a record read or spacing in the reverse\r\n   direction.  On return, status is MTSE_OK and the tape is positioned at the\r\n   first data byte if a record was encountered, or status is an MTSE error code\r\n   giving the reason that the operation did not succeed and the tape position is\r\n   as indicated above.\r\n\r\n\r\n   Implementation notes:\r\n\r\n    1. The \"sim_fread\" call cannot return 0 in the absence of an error\r\n       condition.  The preceding \"sim_tape_bot\" test ensures that \"pos\" >= 4, so\r\n       \"sim_fseek\" will back up at least that far, so \"sim_fread\" will read at\r\n       least one element.  If the call returns zero, an error must have\r\n       occurred, so the \"ferror\" call must succeed.\r\n\r\n    2. See the notes at \"sim_tape_rdlntf\" and \"tape_erase_fwd\" regarding tape\r\n       runaway and the erase gap implementation, respectively.\r\n*/\r\n\r\nstatic t_stat sim_tape_rdlntr (UNIT *uptr, t_mtrlnt *bc)\r\n{\r\nuint8    c;\r\nt_bool   all_eof;\r\nuint32   f = MT_GET_FMT (uptr);\r\nt_addr   ppos;\r\nt_mtrlnt sbc;\r\nt_tpclnt tpcbc;\r\nt_awshdr awshdr;\r\nsize_t   rdcnt;\r\nt_mtrlnt buffer [256];                                  /* local tape buffer */\r\nuint32   bufcntr, bufcap;                               /* buffer counter and capacity */\r\nint32    runaway_counter, sizeof_gap;                   /* bytes remaining before runaway and bytes per gap */\r\nt_stat   status = MTSE_OK;\r\n\r\nMT_CLR_PNU (uptr);                                      /* clear the position-not-updated flag */\r\n*bc = 0;\r\n\r\nif ((uptr->flags & UNIT_ATT) == 0)                      /* if the unit is not attached */\r\n    return MTSE_UNATT;                                  /*   then quit with an error */\r\n\r\nif (sim_tape_bot (uptr))                                /* if the unit is positioned at the BOT */\r\n    return MTSE_BOT;                                    /*   then reading backward is not possible */\r\n\r\nswitch (f) {                                            /* otherwise the read method depends on the tape format */\r\n\r\n    case MTUF_F_STD:\r\n    case MTUF_F_E11:\r\n        runaway_counter = 25 * 12 * bpi [MT_DENS (uptr->dynflags)]; /* set the largest legal gap size in bytes */\r\n\r\n        if (runaway_counter == 0) {                     /* if tape density has not been not set */\r\n            sizeof_gap = 0;                             /*   then disable runaway detection */\r\n            runaway_counter = INT_MAX;                  /*     to allow gaps of any size */\r\n            }\r\n\r\n        else                                            /* otherwise */\r\n            sizeof_gap = sizeof (t_mtrlnt);             /*   set the size of the gap */\r\n\r\n        bufcntr = 0;                                    /* force an initial read */\r\n        bufcap = 0;                                     /*   but of just one metadata marker */\r\n\r\n        do {                                            /* loop until a record, gap, or error is seen */\r\n            if (bufcntr == 0) {                         /* if the buffer is empty then refill it */\r\n                if (sim_tape_bot (uptr)) {              /* if the search has backed into the BOT */\r\n                    status = MTSE_BOT;                  /*   then quit with an error */\r\n                    break;\r\n                    }\r\n\r\n                else if (bufcap == 0)                   /* otherwise if this is the initial read */\r\n                    bufcap = 1;                         /*   then start with just one marker */\r\n\r\n                else if (uptr->pos < sizeof (buffer))   /* otherwise if less than a full buffer remains */\r\n                    bufcap = (uint32) uptr->pos         /*   then reduce the capacity accordingly */\r\n                               / sizeof (t_mtrlnt);\r\n\r\n                else                                    /* otherwise reset the capacity */\r\n                    bufcap = sizeof (buffer)            /*   to the full size of the buffer */\r\n                               / sizeof (buffer [0]);\r\n\r\n                if (sim_tape_seek (uptr,                /* seek back to the location */\r\n                                   uptr->pos - bufcap * sizeof (t_mtrlnt))) {  /* corresponding to the start */\r\n                                                        /* of the buffer; if it fails */\r\n                    status = sim_tape_ioerr (uptr);     /*         and fail with I/O error status */\r\n                    break;\r\n                    }\r\n\r\n                bufcntr = sim_fread (buffer, sizeof (t_mtrlnt), /* fill the buffer */\r\n                                     bufcap, uptr->fileref);    /*   with tape metadata */\r\n\r\n                if (ferror (uptr->fileref)) {           /* if a file I/O error occurred */\r\n                    status = sim_tape_ioerr (uptr);     /*   then report the error and quit */\r\n                    break;\r\n                    }\r\n                }\r\n\r\n            *bc = buffer [--bufcntr];                   /* store the metadata marker value */\r\n\r\n            uptr->pos = uptr->pos - sizeof (t_mtrlnt);  /* backspace over the marker */\r\n\r\n            if (*bc == MTR_TMK) {                       /* if the marker is a tape mark */\r\n                status = MTSE_TMK;                      /*   then quit with tape mark status */\r\n                break;\r\n                }\r\n\r\n            else if (*bc == MTR_GAP)                    /* otherwise if the marker is a full gap */\r\n                runaway_counter -= sizeof_gap;          /*   then decrement the gap counter */\r\n\r\n            else if ((*bc & MTR_M_RHGAP) == MTR_RHGAP   /* otherwise if the marker */\r\n              || *bc == MTR_RRGAP) {                    /*   is a half gap */\r\n                uptr->pos = uptr->pos + sizeof (t_mtrlnt) / 2;/* then position forward to resync */\r\n                bufcntr = 0;                            /* mark the buffer as invalid to force a read */\r\n\r\n                *bc = (t_mtrlnt)MTR_GAP;                /* reset the marker */\r\n                runaway_counter -= sizeof_gap / 2;      /*   and decrement the gap counter */\r\n                }\r\n\r\n            else {                                      /* otherwise it's a record marker */\r\n                sbc = MTR_L (*bc);                      /* extract the record length */\r\n                uptr->pos = uptr->pos - sizeof (t_mtrlnt)/* position to the start */\r\n                  - (f == MTUF_F_STD ? (sbc + 1) & ~1 : sbc);/*   of the record */\r\n\r\n                if (sim_tape_seek (uptr,                /* seek to the start of the data area; if it fails */\r\n                               uptr->pos + sizeof (t_mtrlnt))) {/* then return with I/O error status */\r\n                    status = sim_tape_ioerr (uptr);\r\n                    break;\r\n                    }\r\n                }\r\n            }\r\n        while (*bc == MTR_GAP && runaway_counter > 0);  /* continue until data or runaway occurs */\r\n\r\n        if (runaway_counter <= 0)                       /* if a tape runaway occurred */\r\n            status = MTSE_RUNAWAY;                      /*   then report it */\r\n\r\n        break;                                          /* otherwise the operation succeeded */\r\n\r\n    case MTUF_F_TPC:\r\n        ppos = sim_tape_tpc_fnd (uptr, (t_addr *) uptr->filebuf); /* find prev rec */\r\n        (void)sim_tape_seek (uptr, ppos);               /* position */\r\n        (void)sim_fread (&tpcbc, sizeof (t_tpclnt), 1, uptr->fileref);\r\n        *bc = (t_mtrlnt)tpcbc;                          /* save rec lnt */\r\n\r\n        if (ferror (uptr->fileref))                     /* error? */\r\n            status = sim_tape_ioerr (uptr);\r\n        else if (feof (uptr->fileref))                  /* eof? */\r\n            status = MTSE_EOM;\r\n        else {\r\n            uptr->pos = ppos;                           /* spc over record */\r\n            if (*bc == MTR_TMK)                         /* tape mark? */\r\n                status = MTSE_TMK;\r\n            else\r\n                (void)sim_tape_seek (uptr, uptr->pos + sizeof (t_tpclnt));\r\n            }\r\n        break;\r\n\r\n    case MTUF_F_P7B:\r\n        if (1) {\r\n#define BUF_SZ 512\r\n            uint8 buf[BUF_SZ];\r\n            t_addr buf_offset = uptr->pos;\r\n            size_t bytes_in_buf = 0;\r\n            size_t read_size;\r\n\r\n            for (sbc = 1, all_eof = 1; (t_addr) sbc <= uptr->pos ; sbc++) {\r\n                if (bytes_in_buf == 0) {                /* Need to Fill Buffer */\r\n                    if (buf_offset < BUF_SZ) {\r\n                        read_size = (size_t)buf_offset;\r\n                        buf_offset = 0;\r\n                        }\r\n                    else {\r\n                        read_size = BUF_SZ;\r\n                        buf_offset -= BUF_SZ;\r\n                        }\r\n                    (void)sim_tape_seek (uptr, buf_offset);\r\n                    bytes_in_buf = sim_fread (buf, sizeof (uint8), read_size, uptr->fileref);\r\n                    if (ferror (uptr->fileref)) {       /* error? */\r\n                        status = sim_tape_ioerr (uptr);\r\n                        break;\r\n                        }\r\n                    if (feof (uptr->fileref)) {         /* eof? */\r\n                        status = MTSE_EOM;\r\n                        break;\r\n                        }\r\n                    }\r\n                c = buf[--bytes_in_buf];\r\n                if ((c & P7B_DPAR) != P7B_EOF)\r\n                    all_eof = 0;\r\n                if (c & P7B_SOR)                        /* start of record? */\r\n                    break;\r\n                }\r\n\r\n            if (status == MTSE_OK) {\r\n                uptr->pos = uptr->pos - sbc;            /* update position */\r\n                *bc = sbc;                              /* save rec lnt */\r\n                (void)sim_tape_seek (uptr, uptr->pos);  /* for next read */\r\n                if (all_eof)                            /* tape mark? */\r\n                    status = MTSE_TMK;\r\n                }\r\n            break;\r\n            }\r\n\r\n    case MTUF_F_AWS:\r\n        *bc = 0;\r\n        status = MTSE_OK;\r\n        (void)sim_tape_seek (uptr, uptr->pos);          /* position */\r\n        while (1) {\r\n            if (sim_tape_bot (uptr)) {                  /* if we start at BOT */\r\n                status = MTSE_BOT;                      /*   then we're done */\r\n                break;\r\n                }\r\n            memset (&awshdr, 0, sizeof (awshdr));\r\n            rdcnt = sim_fread (&awshdr, sizeof (t_awslnt), 3, uptr->fileref);\r\n            if (ferror (uptr->fileref)) {               /* error? */\r\n                status = sim_tape_ioerr (uptr);\r\n                break;\r\n                }\r\n            if (feof (uptr->fileref)) {                 /* eof? */\r\n                if ((uptr->pos > sizeof (t_awshdr)) &&\r\n                    (uptr->pos >= sim_fsize (uptr->fileref))) {\r\n                    uptr->tape_eom = uptr->pos;\r\n                    (void)sim_tape_seek (uptr, uptr->pos - sizeof (t_awshdr));/* position */\r\n                    continue;\r\n                    }\r\n                status = MTSE_EOM;\r\n                break;\r\n                }\r\n            if ((rdcnt != 3) ||\r\n                ((awshdr.rectyp != AWS_REC) &&\r\n                 (awshdr.rectyp != AWS_TMK))) {\r\n                status = MTSE_INVRL;\r\n                }\r\n            break;\r\n            }\r\n        if (status != MTSE_OK)\r\n            break;\r\n        if (awshdr.prelen == 0)\r\n            status = MTSE_TMK;\r\n        else {\r\n            if ((uptr->tape_eom > 0) &&\r\n                (uptr->pos >= uptr->tape_eom) &&\r\n                (awshdr.rectyp == AWS_TMK)) {\r\n                status = MTSE_TMK;\r\n                *bc = 0;                                /* save rec lnt */\r\n                }\r\n            else {\r\n                status = MTSE_OK;\r\n                *bc = (t_mtrlnt)awshdr.prelen;          /* save rec lnt */\r\n                }\r\n            }\r\n        uptr->pos -= sizeof (t_awshdr);                 /* position to the start of the record */\r\n        uptr->pos -= *bc;                               /* Including the data length */\r\n        if (sim_tape_seek (uptr,                        /* seek to the start of the data area; if it fails */\r\n                           uptr->pos + sizeof (t_awshdr))) {\r\n            status = sim_tape_ioerr (uptr);             /* then return with I/O error status */\r\n            break;\r\n            }\r\n        break;\r\n\r\n     case MTUF_F_TAR:\r\n         if (uptr->pos == uptr->hwmark) {\r\n             if (MT_TST_INMRK (uptr)) {\r\n                 status = MTSE_TMK;\r\n                 MT_CLR_INMRK (uptr);\r\n                 }\r\n             else {\r\n                 if (uptr->hwmark % uptr->recsize)\r\n                     *bc = (t_mtrlnt)(uptr->hwmark % uptr->recsize);\r\n                 else\r\n                     *bc = (t_mtrlnt)uptr->recsize;\r\n                 }\r\n             }\r\n         else\r\n             *bc = (t_mtrlnt)uptr->recsize;\r\n         if (*bc) {\r\n             uptr->pos -= *bc;\r\n             (void)sim_tape_seek (uptr, uptr->pos);\r\n             }\r\n        break;\r\n\r\n    case MTUF_F_ANSI:\r\n    case MTUF_F_FIXED:\r\n    case MTUF_F_DOS11:\r\n        if (1) {\r\n            MEMORY_TAPE *tape = (MEMORY_TAPE *)uptr->fileref;\r\n\r\n            --uptr->pos;\r\n            if (tape->records[uptr->pos]->size == 0)\r\n                status = MTSE_TMK;\r\n            else\r\n                *bc = tape->records[uptr->pos]->size;\r\n            }\r\n        break;\r\n\r\n   default:\r\n        status = MTSE_FMT;\r\n        }\r\n\r\nreturn status;\r\n}\r\n\r\nstatic t_stat sim_tape_rdrlrev (UNIT *uptr, t_mtrlnt *bc)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat status;\r\n\r\n*bc = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\n\r\nstatus = sim_tape_rdlntr (uptr, bc);                    /* read the record length */\r\n\r\nsim_debug_unit (MTSE_DBG_STR, uptr, \"rd_lntr: st: %d, lnt: %d, pos: %\" T_ADDR_FMT \"u\\n\", status, *bc, uptr->pos);\r\n\r\nreturn status;\r\n}\r\n\r\n/* Read record forward\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        buf     =       pointer to buffer\r\n        bc      =       pointer to returned record length\r\n        max     =       maximum record size\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   read error           unchanged, PNU set\r\n   end of file/medium   unchanged, PNU set\r\n   invalid record       unchanged, PNU set\r\n   tape mark            updated\r\n   data record          updated\r\n   data record error    updated\r\n*/\r\n\r\nt_stat sim_tape_rdrecf (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nuint32 f = MT_GET_FMT (uptr);\r\nt_mtrlnt i, tbc, rbc;\r\nt_addr opos;\r\nt_stat st;\r\n\r\n*bc = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_rdrecf(unit=%d, buf=%p, max=%d)\\n\", (int)(uptr-ctx->dptr->units), buf, max);\r\n\r\nif ((uptr->tape_chunk_size) &&\r\n    (ctx->chunk_data_size > ctx->chunk_offset)) {       /* remnant chunk data available? */\r\n    /* return the next chunk of data */\r\n    *bc = MIN (max, ctx->chunk_data_size - ctx->chunk_offset);\r\n    memcpy (buf, ctx->chunk_buf + ctx->chunk_offset, *bc);\r\n    ctx->chunk_offset += *bc;\r\n    return MTSE_OK;\r\n    }\r\nopos = uptr->pos;                                       /* old position */\r\nst = sim_tape_rdrlfwd (uptr, &tbc);                     /* read rec lnt */\r\nif (st != MTSE_OK) {\r\n    *bc = 0;\r\n    return st;\r\n    }\r\n*bc = rbc = MTR_L (tbc);                                /* strip error flag */\r\nif (rbc > max) {                                        /* rec out of range? */\r\n    if (uptr->tape_chunk_size) {\r\n        /* prep the chunk buffer */\r\n        if (tbc > ctx->chunk_buf_size) {\r\n            ctx->chunk_buf_size = MAX (65536, tbc);\r\n            ctx->chunk_buf = (uint8 *)realloc (ctx->chunk_buf, ctx->chunk_buf_size);\r\n            }\r\n        ctx->chunk_data_size = ctx->chunk_offset = 0;\r\n        uptr->pos = opos;\r\n        /* Fill the chunk buffer */\r\n        st = sim_tape_rdrecf (uptr, ctx->chunk_buf, &ctx->chunk_data_size, ctx->chunk_buf_size);\r\n        if (st != MTSE_OK) {\r\n            MT_SET_PNU (uptr);\r\n            uptr->pos = opos;\r\n            return st;\r\n            }\r\n        /* return the first chunk */\r\n        return sim_tape_rdrecf (uptr, buf, bc, max);\r\n        }\r\n    else {\r\n        MT_SET_PNU (uptr);\r\n        uptr->pos = opos;\r\n        return MTSE_INVRL;\r\n        }\r\n    }\r\nif (f < MTUF_F_ANSI) {\r\n    i = (t_mtrlnt) sim_fread (buf, sizeof (uint8), rbc, uptr->fileref); /* read record */\r\n    if (ferror (uptr->fileref)) {                           /* error? */\r\n        MT_SET_PNU (uptr);\r\n        uptr->pos = opos;\r\n        return sim_tape_ioerr (uptr);\r\n        }\r\n    }\r\nelse {\r\n    MEMORY_TAPE *tape = (MEMORY_TAPE *)uptr->fileref;\r\n\r\n    memcpy (buf, tape->records[uptr->pos - 1]->data, rbc);\r\n    i = rbc;\r\n    }\r\nfor ( ; i < rbc; i++)                                   /* fill with 0's */\r\n    buf[i] = 0;\r\nif (f == MTUF_F_P7B)                                    /* p7b? strip SOR */\r\n    buf[0] = buf[0] & P7B_DPAR;\r\nsim_tape_data_trace(uptr, buf, rbc, \"Record Read\", (uptr->dctrl | ctx->dptr->dctrl) & MTSE_DBG_DAT, MTSE_DBG_STR);\r\nreturn (MTR_F (tbc)? MTSE_RECE: MTSE_OK);\r\n}\r\n\r\nt_stat sim_tape_rdrecf_a (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = SCPE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_rdrecf (uptr, buf, bc, max);\r\nAIO_CALL(TOP_RDRF, buf, bc, NULL, max, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n\r\n/* Read record reverse\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        buf     =       pointer to buffer\r\n        bc      =       pointer to returned record length\r\n        max     =       maximum record size\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   read error           unchanged\r\n   end of file          unchanged\r\n   end of medium        updated\r\n   invalid record       unchanged\r\n   tape mark            updated\r\n   data record          updated\r\n   data record error    updated\r\n*/\r\n\r\nt_stat sim_tape_rdrecr (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nuint32 f = MT_GET_FMT (uptr);\r\nt_mtrlnt i, rbc, tbc;\r\nt_stat st;\r\n\r\n*bc = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_rdrecr(unit=%d, buf=%p, max=%d)\\n\", (int)(uptr-ctx->dptr->units), buf, max);\r\n\r\nctx->chunk_offset = ctx->chunk_data_size = 0;           /* discard any pending chunking */\r\nst = sim_tape_rdrlrev (uptr, &tbc);                     /* read rec lnt */\r\nif (st != MTSE_OK) {\r\n    *bc = 0;\r\n    return st;\r\n    }\r\n*bc = rbc = MTR_L (tbc);                                /* strip error flag */\r\nif (rbc > max)                                          /* rec out of range? */\r\n    return MTSE_INVRL;\r\nif (f < MTUF_F_ANSI) {\r\n    i = (t_mtrlnt) sim_fread (buf, sizeof (uint8), rbc, uptr->fileref); /* read record */\r\n    if (ferror (uptr->fileref))                             /* error? */\r\n        return sim_tape_ioerr (uptr);\r\n    }\r\nelse {\r\n    MEMORY_TAPE *tape = (MEMORY_TAPE *)uptr->fileref;\r\n\r\n    memcpy (buf, tape->records[uptr->pos]->data, rbc);\r\n    i = rbc;\r\n    }\r\nfor ( ; i < rbc; i++)                                   /* fill with 0's */\r\n    buf[i] = 0;\r\nif (f == MTUF_F_P7B)                                    /* p7b? strip SOR */\r\n    buf[0] = buf[0] & P7B_DPAR;\r\nsim_tape_data_trace(uptr, buf, rbc, \"Record Read Reverse\", (uptr->dctrl | ctx->dptr->dctrl) & MTSE_DBG_DAT, MTSE_DBG_STR);\r\nreturn (MTR_F (tbc)? MTSE_RECE: MTSE_OK);\r\n}\r\n\r\nt_stat sim_tape_rdrecr_a (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = SCPE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_rdrecr (uptr, buf, bc, max);\r\nAIO_CALL(TOP_RDRR, buf, bc, NULL, max, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Write record forward\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        buf     =       pointer to buffer\r\n        bc      =       record length\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   write protect        unchanged\r\n   write error          unchanged, PNU set\r\n   data record          updated\r\n*/\r\n\r\nt_stat sim_tape_wrrecf (UNIT *uptr, uint8 *buf, t_mtrlnt bc)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nuint32 f = MT_GET_FMT (uptr);\r\nt_mtrlnt sbc;\r\nt_stat status = MTSE_OK;\r\n\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_wrrecf(unit=%d, buf=%p, bc=%d)\\n\", (int)(uptr-ctx->dptr->units), buf, bc);\r\n\r\nsim_tape_data_trace(uptr, buf, bc, \"Record Write\", (uptr->dctrl | ctx->dptr->dctrl) & MTSE_DBG_DAT, MTSE_DBG_STR);\r\nMT_CLR_PNU (uptr);\r\nsbc = MTR_L (bc);\r\nif ((uptr->flags & UNIT_ATT) == 0)                      /* not attached? */\r\n    return MTSE_UNATT;\r\nif (sim_tape_wrp (uptr))                                /* write prot? */\r\n    return MTSE_WRP;\r\nif (sbc == 0)                                           /* nothing to do? */\r\n    return MTSE_OK;\r\nif (sim_tape_seek (uptr, uptr->pos))                    /* set pos */\r\n    return MTSE_IOERR;\r\nswitch (f) {                                            /* case on format */\r\n\r\n    case MTUF_F_STD:                                    /* standard */\r\n        sbc = MTR_L ((bc + 1) & ~1);                    /* pad odd length */\r\n        /* fall through into the E11 handler */\r\n    case MTUF_F_E11:                                    /* E11 */\r\n        (void)sim_fwrite (&bc, sizeof (t_mtrlnt), 1, uptr->fileref);\r\n        (void)sim_fwrite (buf, sizeof (uint8), sbc, uptr->fileref);\r\n        (void)sim_fwrite (&bc, sizeof (t_mtrlnt), 1, uptr->fileref);\r\n        if (ferror (uptr->fileref)) {                   /* error? */\r\n            MT_SET_PNU (uptr);\r\n            return sim_tape_ioerr (uptr);\r\n            }\r\n        uptr->pos = uptr->pos + sbc + (2 * sizeof (t_mtrlnt));  /* move tape */\r\n        break;\r\n\r\n    case MTUF_F_P7B:                                    /* Pierce 7B */\r\n        buf[0] = buf[0] | P7B_SOR;                      /* mark start of rec */\r\n        (void)sim_fwrite (buf, sizeof (uint8), sbc, uptr->fileref);\r\n        (void)sim_fwrite (buf, sizeof (uint8), 1, uptr->fileref); /* delimit rec */\r\n        if (ferror (uptr->fileref)) {                   /* error? */\r\n            MT_SET_PNU (uptr);\r\n            return sim_tape_ioerr (uptr);\r\n            }\r\n        uptr->pos = uptr->pos + sbc;                    /* move tape */\r\n        break;\r\n    case MTUF_F_AWS:                                    /* AWS */\r\n        status = sim_tape_aws_wrdata (uptr, buf, bc);\r\n        if (status != MTSE_OK)\r\n            return status;\r\n        break;\r\n        }\r\nif (uptr->pos > uptr->tape_eom)\r\n    uptr->tape_eom = uptr->pos;         /* update EOM as needed */\r\nsim_tape_data_trace(uptr, buf, sbc, \"Record Written\", (uptr->dctrl | ctx->dptr->dctrl) & MTSE_DBG_DAT, MTSE_DBG_STR);\r\nreturn MTSE_OK;\r\n}\r\n\r\nt_stat sim_tape_wrrecf_a (UNIT *uptr, uint8 *buf, t_mtrlnt bc, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = SCPE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_wrrecf (uptr, buf, bc);\r\nAIO_CALL(TOP_WREC, buf, 0, NULL, 0, bc, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Write AWS metadata (and possibly data) forward (internal routine) */\r\n\r\nstatic t_stat sim_tape_aws_wrdata (UNIT *uptr, uint8 *buf, t_mtrlnt bc)\r\n{\r\nt_awshdr awshdr;\r\nsize_t   rdcnt;\r\nt_bool   replacing_record;\r\n\r\nmemset (&awshdr, 0, sizeof (t_awshdr));\r\nif (sim_tape_seek (uptr, uptr->pos))        /* set pos */\r\n    return MTSE_IOERR;\r\nrdcnt = sim_fread (&awshdr, sizeof (t_awslnt), 3, uptr->fileref);\r\nif (ferror (uptr->fileref)) {               /* error? */\r\n    MT_SET_PNU (uptr);                      /* pos not upd */\r\n    return sim_tape_ioerr (uptr);\r\n    }\r\nif ((!sim_tape_bot (uptr)) &&\r\n    (((feof (uptr->fileref)) && (rdcnt < 3)) || /* eof? */\r\n     ((awshdr.rectyp != AWS_REC) && (awshdr.rectyp != AWS_TMK)))) {\r\n    MT_SET_PNU (uptr);                      /* pos not upd */\r\n    return MTSE_INVRL;\r\n    }\r\nif (sim_tape_seek (uptr, uptr->pos))        /* set pos */\r\n    return MTSE_IOERR;\r\nreplacing_record = (awshdr.nxtlen == (t_awslnt)bc) && (awshdr.rectyp == (bc ? AWS_REC : AWS_TMK));\r\nawshdr.nxtlen = (t_awslnt)bc;\r\nawshdr.rectyp = (bc) ? AWS_REC : AWS_TMK;\r\n(void)sim_fwrite (&awshdr, sizeof (t_awslnt), 3, uptr->fileref);\r\nif (bc)\r\n    (void)sim_fwrite (buf, sizeof (uint8), bc, uptr->fileref);\r\nuptr->pos += sizeof (awshdr) + bc;\r\nif ((!replacing_record) || (bc == 0)) {\r\n    awshdr.prelen = bc;\r\n    awshdr.nxtlen = 0;\r\n    awshdr.rectyp = AWS_TMK;\r\n    (void)sim_fwrite (&awshdr, sizeof (t_awslnt), 3, uptr->fileref);\r\n    if (!replacing_record)\r\n        sim_set_fsize (uptr->fileref, uptr->pos + sizeof (awshdr));\r\n    }\r\nif (uptr->pos > uptr->tape_eom)\r\n    uptr->tape_eom = uptr->pos;                     /* Update EOM if we're there */\r\nreturn MTSE_OK;\r\n}\r\n\r\n/* Write metadata forward (internal routine) */\r\n\r\nstatic t_stat sim_tape_wrdata (UNIT *uptr, uint32 dat)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nMT_CLR_PNU (uptr);\r\nif ((uptr->flags & UNIT_ATT) == 0)                      /* not attached? */\r\n    return MTSE_UNATT;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nif (sim_tape_wrp (uptr))                                /* write prot? */\r\n    return MTSE_WRP;\r\n(void)sim_tape_seek (uptr, uptr->pos);                  /* set pos */\r\n(void)sim_fwrite (&dat, sizeof (t_mtrlnt), 1, uptr->fileref);\r\nif (ferror (uptr->fileref)) {                           /* error? */\r\n    MT_SET_PNU (uptr);\r\n    return sim_tape_ioerr (uptr);\r\n    }\r\nsim_debug_unit (MTSE_DBG_STR, uptr, \"wr_lnt: lnt: %d, pos: %\" T_ADDR_FMT \"u\\n\", dat, uptr->pos);\r\nuptr->pos = uptr->pos + sizeof (t_mtrlnt);              /* move tape */\r\nif (uptr->pos > uptr->tape_eom)\r\n    uptr->tape_eom = uptr->pos;                         /* update EOM */\r\nreturn MTSE_OK;\r\n}\r\n\r\n/* Write tape mark */\r\n\r\nt_stat sim_tape_wrtmk (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_wrtmk(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\nif (MT_GET_FMT (uptr) == MTUF_F_P7B) {                  /* P7B? */\r\n    uint8 buf = P7B_EOF;                                /* eof mark */\r\n    return sim_tape_wrrecf (uptr, &buf, 1);             /* write char */\r\n    }\r\nif (MT_GET_FMT (uptr) == MTUF_F_AWS)                    /* AWS? */\r\n    return sim_tape_aws_wrdata (uptr, NULL, 0);\r\nreturn sim_tape_wrdata (uptr, MTR_TMK);\r\n}\r\n\r\nt_stat sim_tape_wrtmk_a (UNIT *uptr, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_wrtmk (uptr);\r\nAIO_CALL(TOP_WTMK, NULL, NULL, NULL, 0, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Write end of medium */\r\n\r\nt_stat sim_tape_wreom (UNIT *uptr)\r\n{\r\nt_stat result;\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_wreom(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\nif (sim_tape_wrp (uptr))                                /* write prot? */\r\n    return MTSE_WRP;\r\nif (MT_GET_FMT (uptr) == MTUF_F_P7B)                    /* cant do P7B */\r\n    return MTSE_FMT;\r\nif (MT_GET_FMT (uptr) == MTUF_F_AWS) {\r\n    sim_set_fsize (uptr->fileref, uptr->pos);\r\n    result = MTSE_OK;\r\n    }\r\nelse {\r\n    result = sim_tape_wrdata (uptr, MTR_EOM);           /* write the EOM marker */\r\n    uptr->pos = uptr->pos - sizeof (t_mtrlnt);          /* restore original tape position */\r\n    }\r\nMT_SET_PNU (uptr);                                      /* indicate that position was not updated */\r\n\r\nreturn result;\r\n}\r\n\r\nt_stat sim_tape_wreom_a (UNIT *uptr, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_wreom (uptr);\r\nAIO_CALL(TOP_WEOM, NULL, NULL, NULL, 0, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Write end of medium-rewind */\r\n\r\nt_stat sim_tape_wreomrw (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat r;\r\n\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_wreomrw(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\nr = sim_tape_wreom (uptr);\r\nif (r == MTSE_OK)\r\n    r = sim_tape_rewind (uptr);\r\nreturn r;\r\n}\r\n\r\nt_stat sim_tape_wreomrw_a (UNIT *uptr, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_wreomrw (uptr);\r\nAIO_CALL(TOP_WEMR, NULL, NULL, NULL, 0, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n\r\n/* Erase a gap in the forward direction (internal routine).\r\n\r\n   An erase gap is written in the forward direction on the tape unit specified\r\n   by \"uptr\" for the number of bytes specified by \"bc\".  The status of the\r\n   operation is returned, and the file position is altered as follows:\r\n\r\n     Exit Condition       File Position\r\n     ------------------   ------------------\r\n     unit unattached      unchanged\r\n     unsupported format   unchanged\r\n     write protected      unchanged\r\n     read error           unchanged, PNU set\r\n     write error          unchanged, PNU set\r\n     gap written          updated\r\n\r\n   If the requested byte count equals the metadatum size, then the routine\r\n   succeeds only if it can overlay a single metadatum (i.e., a tape mark, an\r\n   end-of-medium marker, or an existing erase gap marker); otherwise, the file\r\n   position is not altered, PNU is set, and MTSE_INVRL (invalid record length)\r\n   status is returned.\r\n\r\n   An erase gap is represented in the tape image file by a special metadata\r\n   value repeated throughout the gap.  The value is chosen so that it is still\r\n   recognizable even if it has been \"cut in half\" by a subsequent data overwrite\r\n   that does not end on a metadatum-sized boundary.  In addition, a range of\r\n   metadata values are reserved for detection in the reverse direction.\r\n\r\n   This implementation supports erasing gaps in the middle of a populated tape\r\n   image and will always produce a valid image.  It also produces valid images\r\n   when overwriting gaps with data records, with one exception: a data write\r\n   that leaves only two bytes of gap remaining will produce an invalid tape.\r\n   This limitation is deemed acceptable, as it is analogous to the existing\r\n   limitation that data records cannot overwrite other data records without\r\n   producing an invalid tape.\r\n\r\n   To write an erase gap, the implementation uses one of two approaches,\r\n   depending on whether or not the current tape position is at EOM.  Erasing at\r\n   EOM presents no special difficulties; gap metadata markers are written for\r\n   the prescribed number of bytes.  If the tape is not at EOM, then erasing must\r\n   take into account the existing record structure to ensure that a valid tape\r\n   image is maintained.\r\n\r\n   The general approach is to erase for the nominal number of bytes but to\r\n   increase that length, if necessary, to ensure that a partially overwritten\r\n   data record at the end of the gap can be altered to maintain validity.\r\n   Because the smallest legal tape record requires space for two metadata\r\n   markers plus two data bytes, an erasure that would leave less than that\r\n   is increased to consume the entire record.  Otherwise, the final record is\r\n   truncated by rewriting the leading and trailing length words appropriately.\r\n\r\n   When reading in either direction, gap metadata markers are ignored (skipped)\r\n   until a record length header, EOF marker, EOM marker, or physical EOF is\r\n   encountered.  Thus, tape images containing gap metadata are transparent to\r\n   the calling simulator (unless tape runaway support is enabled -- see the\r\n   notes at \"sim_tape_rdlntf\" for details).\r\n\r\n   The permissibility of data record lengths that are not multiples of the\r\n   metadatum size presents a difficulty when reading.  If such an \"odd length\"\r\n   record is written over a gap, half of a metadata marker will exist\r\n   immediately after the trailing record length.\r\n\r\n   This condition is detected when reading forward by the appearance of a\r\n   \"reversed\" marker.  The value appears reversed because the value is made up\r\n   of half of one marker and half of the next.  This is handled by seeking\r\n   forward two bytes to resync (the stipulation above that the overwrite cannot\r\n   leave only two bytes of gap means that at least one \"whole\" metadata marker\r\n   will follow).  Reading in reverse presents a more complex problem, because\r\n   half of the marker is from the preceding trailing record length marker and\r\n   therefore could be any of a range of values.  However, that range is\r\n   restricted by the SIMH tape specification requirement that record length\r\n   metadata values must have bits 30:24 set to zero.  This allows unambiguous\r\n   detection of the condition.\r\n\r\n   The value chosen for gap metadata and the values reserved for \"half-gap\"\r\n   detection are:\r\n\r\n     0xFFFFFFFE            - primary gap value\r\n     0xFFFEFFFF            - reserved (indicates half-gap in forward reads)\r\n     0xFFFF0000:0xFFFF00FF - reserved (indicates half-gap in reverse reads)\r\n     0xFFFF8000:0xFFFF80FF - reserved (indicates half-gap in reverse reads)\r\n\r\n   If the current tape format supports erase gaps, then this routine will write\r\n   a gap of the requested size.  If the format does not, then no action will be\r\n   taken, and MTSE_OK status will be returned.  This allows a device simulator\r\n   that supports writing erase gaps to use the same code without worrying about\r\n   the tape format currently selected by the user.  A request for an erase gap\r\n   of zero length also succeeds with no action taken.\r\n\r\n\r\n   Implementation notes:\r\n\r\n    1. Erase gaps are currently supported only in SIMH (MTUF_F_STD) tape format.\r\n*/\r\n\r\nstatic t_stat tape_erase_fwd (UNIT *uptr, t_mtrlnt gap_size)\r\n{\r\nsize_t   xfer;\r\nt_stat   st;\r\nt_mtrlnt meta, sbc, new_len, rec_size;\r\nuint32   file_size, marker_count;\r\nint32    gap_needed = (int32) gap_size;                 /* the gap remaining to be allocated from the tape */\r\nuint32   gap_alloc = 0;                                 /* the gap currently allocated from the tape */\r\nconst t_addr gap_pos = uptr->pos;                       /* the file position where the gap will start */\r\nconst uint32 format = MT_GET_FMT (uptr);                /* the tape format */\r\nconst uint32 meta_size = sizeof (t_mtrlnt);             /* the number of bytes per metadatum */\r\nconst uint32 min_rec_size = 2 + sizeof (t_mtrlnt) * 2;  /* the smallest data record size */\r\n\r\nMT_CLR_PNU (uptr);\r\n\r\nif ((uptr->flags & UNIT_ATT) == 0)                      /* if the unit is not attached */\r\n    return MTSE_UNATT;                                  /*   then we cannot proceed */\r\n\r\nelse if (sim_tape_wrp (uptr))                           /* otherwise if the unit is write protected */\r\n    return MTSE_WRP;                                    /*   then we cannot write */\r\n\r\nelse if (gap_size == 0 || format != MTUF_F_STD)         /* otherwise if zero length or gaps aren't supported */\r\n    return MTSE_OK;                                     /*   then take no action */\r\n\r\nfile_size = sim_fsize (uptr->fileref);                  /* get the file size */\r\n\r\nif (sim_tape_seek (uptr, uptr->pos)) {                  /* position the tape; if it fails */\r\n    MT_SET_PNU (uptr);                                  /*   then set position not updated */\r\n    return sim_tape_ioerr (uptr);                       /*     and quit with I/O error status */\r\n    }\r\n\r\n/* Read tape records and allocate them to the gap until the amount required is\r\n   consumed.\r\n\r\n   Read the next metadatum from tape:\r\n    - EOF or EOM: allocate remainder of bytes needed.\r\n    - TMK or GAP: allocate sizeof(metadatum) bytes.\r\n    - Reverse GAP: allocate sizeof(metadatum) / 2 bytes.\r\n    - Data record: see below.\r\n\r\n   Loop until the bytes needed = 0.\r\n*/\r\n\r\ndo {\r\n    xfer = sim_fread (&meta, meta_size, 1, uptr->fileref);  /* read a metadatum */\r\n\r\n    if (ferror (uptr->fileref)) {                       /* read error? */\r\n        uptr->pos = gap_pos;                            /* restore original position */\r\n        MT_SET_PNU (uptr);                              /* position not updated */\r\n        return sim_tape_ioerr (uptr);                   /* translate error */\r\n        }\r\n\r\n    else if (xfer != 1 && feof (uptr->fileref) == 0) {  /* otherwise if a partial metadatum was read */\r\n        uptr->pos = gap_pos;                            /*   then restore the original position */\r\n        MT_SET_PNU (uptr);                              /* set the position-not-updated flag */\r\n        return MTSE_INVRL;                              /*   and return an invalid record length error */\r\n        }\r\n\r\n    else                                                /* otherwise we had a good read */\r\n        uptr->pos = uptr->pos + meta_size;              /*   so move the tape over the datum */\r\n\r\n    if (feof (uptr->fileref) || (meta == MTR_EOM)) {    /* at eof or eom? */\r\n        gap_alloc = gap_alloc + gap_needed;             /* allocate remainder */\r\n        gap_needed = 0;\r\n        }\r\n\r\n    else if ((meta == MTR_GAP) || (meta == MTR_TMK)) {  /* gap or tape mark? */\r\n        gap_alloc = gap_alloc + meta_size;              /* allocate marker space */\r\n        gap_needed = gap_needed - meta_size;            /* reduce requirement */\r\n        }\r\n\r\n    else if (gap_size == meta_size) {                   /* otherwise if the request is for a single metadatum */\r\n        uptr->pos = gap_pos;                            /*   then restore the original position */\r\n        MT_SET_PNU (uptr);                              /* set the position-not-updated flag */\r\n        return MTSE_INVRL;                              /*   and return an invalid record length error */\r\n        }\r\n\r\n    else if (meta == MTR_FHGAP) {                       /* half gap? */\r\n        uptr->pos = uptr->pos - meta_size / 2;          /* backup to resync */\r\n\r\n        if (sim_tape_seek (uptr, uptr->pos))            /* position the tape; if it fails */\r\n            return sim_tape_ioerr (uptr);               /*   then quit with I/O error status */\r\n\r\n        gap_alloc = gap_alloc + meta_size / 2;          /* allocate marker space */\r\n        gap_needed = gap_needed - meta_size / 2;        /* reduce requirement */\r\n        }\r\n\r\n    else if (uptr->pos + MTR_L (meta) + meta_size > file_size) {    /* rec len out of range? */\r\n        gap_alloc = gap_alloc + gap_needed;                         /* presume overwritten tape */\r\n        gap_needed = 0;                                             /* allocate remainder */\r\n        }\r\n\r\n/* Allocate a data record:\r\n    - Determine record size in bytes (including metadata)\r\n    - If record size - bytes needed < smallest allowed record size,\r\n      allocate entire record to gap, else allocate needed amount and\r\n      truncate data record to reflect remainder.\r\n*/\r\n\r\n    else {                                              /* data record */\r\n        sbc = MTR_L (meta);                             /* get record data length */\r\n        rec_size = ((sbc + 1) & ~1) + meta_size * 2;    /* overall size in bytes */\r\n\r\n        if (rec_size < gap_needed + min_rec_size) {         /* rec too small? */\r\n            uptr->pos = uptr->pos - meta_size + rec_size;   /* position past record */\r\n\r\n            if (sim_tape_seek (uptr, uptr->pos))            /* position the tape; if it fails */\r\n                return sim_tape_ioerr (uptr);               /*   then quit with I/O error status */\r\n\r\n            gap_alloc = gap_alloc + rec_size;               /* allocate record */\r\n            gap_needed = gap_needed - rec_size;             /* reduce requirement */\r\n            }\r\n\r\n        else {                                              /* record size OK */\r\n            uptr->pos = uptr->pos - meta_size + gap_needed; /* position to end of gap */\r\n            new_len = MTR_F (meta) | (sbc - gap_needed);    /* truncate to new len */\r\n            st = sim_tape_wrdata (uptr, new_len);           /* write new rec len */\r\n\r\n            if (st != MTSE_OK) {                            /* write OK? */\r\n                uptr->pos = gap_pos;                        /* restore orig pos */\r\n                return st;                                  /* PNU was set by wrdata */\r\n                }\r\n\r\n            uptr->pos = uptr->pos + sbc - gap_needed;       /* position to end of data */\r\n            st = sim_tape_wrdata (uptr, new_len);           /* write new rec len */\r\n\r\n            if (st != MTSE_OK) {                            /* write OK? */\r\n                uptr->pos = gap_pos;                        /* restore orig pos */\r\n                return st;                                  /* PNU was set by wrdata */\r\n                }\r\n\r\n            gap_alloc = gap_alloc + gap_needed;             /* allocate remainder */\r\n            gap_needed = 0;\r\n            }\r\n        }\r\n    }\r\nwhile (gap_needed > 0);                                 /* loop until all of the gap has been allocated */\r\n\r\nuptr->pos = gap_pos;                                    /* reposition to gap start */\r\n\r\nif (gap_alloc & (meta_size - 1)) {                      /* gap size \"odd?\" */\r\n    st = sim_tape_wrdata (uptr, MTR_FHGAP);             /* write half gap marker */\r\n\r\n    if (st != MTSE_OK) {                                /* write OK? */\r\n        uptr->pos = gap_pos;                            /* restore orig pos */\r\n        return st;                                      /* PNU was set by wrdata */\r\n        }\r\n\r\n    uptr->pos = uptr->pos - meta_size / 2;              /* realign position */\r\n    gap_alloc = gap_alloc - 2;                          /* decrease gap to write */\r\n    }\r\n\r\nmarker_count = gap_alloc / meta_size;                   /* count of gap markers */\r\n\r\ndo {\r\n    st = sim_tape_wrdata (uptr, MTR_GAP);               /* write gap markers */\r\n\r\n    if (st != MTSE_OK) {                                /* write OK? */\r\n        uptr->pos = gap_pos;                            /* restore orig pos */\r\n        return st;                                      /* PNU was set by wrdata */\r\n        }\r\n    }\r\nwhile (--marker_count > 0);\r\n\r\nreturn MTSE_OK;\r\n}\r\n\r\n/* Erase a gap in the reverse direction (internal routine).\r\n\r\n   An erase gap is written in the reverse direction on the tape unit specified\r\n   by \"uptr\" for the number of bytes specified by \"bc\".  The status of the\r\n   operation is returned, and the file position is altered as follows:\r\n\r\n     Exit Condition       File Position\r\n     ------------------   ------------------\r\n     unit unattached      unchanged\r\n     unsupported format   unchanged\r\n     write protected      unchanged\r\n     read error           unchanged, PNU set\r\n     write error          unchanged, PNU set\r\n     gap written          updated\r\n\r\n   If the requested byte count equals the metadatum size, then the routine\r\n   succeeds only if it can overlay a single metadatum (i.e., a tape mark or an\r\n   existing erase gap marker); otherwise, the file position is not altered, and\r\n   MTSE_INVRL (invalid record length) status is returned.\r\n\r\n\r\n   Implementation notes:\r\n\r\n    1. Erase gaps are currently supported only in SIMH (MTUF_F_STD) tape format.\r\n\r\n    2. Erasing a record in the reverse direction currently succeeds only if the\r\n       gap requested occupies the same space as the record located immediately\r\n       before the current file position.  This limitation may be lifted in a\r\n       future update.\r\n\r\n    3. The \"sim_fread\" call cannot return 0 in the absence of an error\r\n       condition.  The preceding \"sim_tape_bot\" test ensures that \"pos\" >= 4, so\r\n       \"sim_fseek\" will back up at least that far, so \"sim_fread\" will read at\r\n       least one element.  If the call returns zero, an error must have\r\n       occurred, so the \"ferror\" call must succeed.\r\n*/\r\n\r\nstatic t_stat tape_erase_rev (UNIT *uptr, t_mtrlnt gap_size)\r\n{\r\nconst uint32 format = MT_GET_FMT (uptr);                /* the tape format */\r\nconst uint32 meta_size = sizeof (t_mtrlnt);             /* the number of bytes per metadatum */\r\nt_stat   status;\r\nt_mtrlnt rec_size, metadatum;\r\nt_addr   gap_pos;\r\nsize_t   xfer;\r\n\r\nMT_CLR_PNU (uptr);                                      /* clear the position-not-updated flag */\r\n\r\nif ((uptr->flags & UNIT_ATT) == 0)                      /* if the unit is not attached */\r\n    return MTSE_UNATT;                                  /*   then we cannot proceed */\r\n\r\nelse if (sim_tape_wrp (uptr))                           /* otherwise if the unit is write protected */\r\n    return MTSE_WRP;                                    /*   then we cannot write */\r\n\r\nelse if ((gap_size == 0) || (format != MTUF_F_STD))     /* otherwise if the gap length is zero or unsupported */\r\n    return MTSE_OK;                                     /*   then take no action */\r\n\r\ngap_pos = uptr->pos;                                    /* save the starting position */\r\n\r\nif (gap_size == meta_size) {                            /* if the request is for a single metadatum */\r\n    if (sim_tape_bot (uptr))                            /*   then if the unit is positioned at the BOT */\r\n        return MTSE_BOT;                                /*     then erasing backward is not possible */\r\n    else                                                /*   otherwise */\r\n        uptr->pos -= meta_size;                         /*     back up the file pointer */\r\n\r\n    if (sim_tape_seek (uptr, uptr->pos))                /* position the tape; if it fails */\r\n        return sim_tape_ioerr (uptr);                   /*   then quit with I/O error status */\r\n\r\n    (void)sim_fread (&metadatum, meta_size, 1, uptr->fileref);/* read a metadatum */\r\n\r\n    if (ferror (uptr->fileref))                             /* if a file I/O error occurred */\r\n        return sim_tape_ioerr (uptr);                       /*   then report the error and quit */\r\n\r\n    else if (metadatum == MTR_TMK)                          /* otherwise if a tape mark is present */\r\n        if (sim_tape_seek (uptr, uptr->pos))                /*   then reposition the tape; if it fails */\r\n            return sim_tape_ioerr (uptr);                   /*     then quit with I/O error status */\r\n\r\n        else {                                              /*   otherwise */\r\n            metadatum = MTR_GAP;                            /*     replace it with an erase gap marker */\r\n\r\n            xfer = sim_fwrite (&metadatum, meta_size,   /* write the gap marker */\r\n                               1, uptr->fileref);\r\n\r\n            if (ferror (uptr->fileref) || (xfer == 0))  /* if a file I/O error occurred */\r\n                return sim_tape_ioerr (uptr);           /* report the error and quit */\r\n            else                                        /* otherwise the write succeeded */\r\n                status = MTSE_OK;                       /*   so return success */\r\n            }\r\n\r\n    else if (metadatum == MTR_GAP)                      /* otherwise if a gap already exists */\r\n        status = MTSE_OK;                               /*   then take no additional action */\r\n\r\n    else {                                              /* otherwise a data record is present */\r\n        uptr->pos = gap_pos;                            /*   so restore the starting position */\r\n        return MTSE_INVRL;                              /*     and fail with invalid record length status */\r\n        }\r\n    }\r\n\r\nelse {                                                  /* otherwise it's an erase record request */\r\n    status = sim_tape_rdlntr (uptr, &rec_size);         /*   so get the length of the preceding record */\r\n\r\n    if ((status == MTSE_OK) &&                          /* if the read succeeded */\r\n        (gap_size == rec_size + 2 * meta_size)) {       /*   and the gap will exactly overlay the record */\r\n        gap_pos = uptr->pos;                            /*     then save the gap start position */\r\n\r\n        status = tape_erase_fwd (uptr, gap_size);       /* erase the record */\r\n\r\n        if (status == MTSE_OK)                          /* if the gap write succeeded */\r\n            uptr->pos = gap_pos;                        /*   the reposition back to the start of the gap */\r\n        }\r\n\r\n    else {                                              /* otherwise the read failed or is the wrong size */\r\n        uptr->pos = gap_pos;                            /*   so restore the starting position */\r\n\r\n        if (status != MTSE_OK)                          /* if the record was not found */\r\n            return status;                              /*   then return the failure reason */\r\n        else                                            /* otherwise the record is the wrong size */\r\n            return MTSE_INVRL;                          /*   so report an invalid record length */\r\n        }\r\n    }\r\n\r\nreturn status;                                          /* return the status of the erase operation */\r\n}\r\n\r\n/* Write an erase gap.\r\n\r\n   An erase gap is written in on the tape unit specified by \"uptr\" for the\r\n   length specified by \"gap_size\" in tenths of an inch, and the status of the\r\n   operation is returned.  The tape density must have been set via a previous\r\n   sim_tape_set_dens call; if it has not, then no action is taken, and\r\n   MTSE_IOERR is returned.\r\n\r\n   If the requested gap length is zero, or the tape format currently selected\r\n   does not support erase gaps, the call succeeds with no action taken.  This\r\n   allows a device simulator that supports writing erase gaps to use the same\r\n   code without worrying about the tape format currently selected by the user.\r\n\r\n   Because SIMH tape images do not carry physical parameters (e.g., recording\r\n   density), overwriting a tape image file containing a gap is problematic if\r\n   the density setting is not the same as that used during recording.  There is\r\n   no way to establish a gap of a certain length unequivocally in an image file,\r\n   so this implementation establishes a gap of a certain number of bytes that\r\n   reflect the desired gap length at the tape density in bits per inch used\r\n   during writing.\r\n*/\r\n\r\nt_stat sim_tape_wrgap (UNIT *uptr, uint32 gaplen)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nconst uint32 density = bpi [MT_DENS (uptr->dynflags)];  /* the tape density in bits per inch */\r\nconst uint32 byte_length = (gaplen * density) / 10;     /* the size of the requested gap in bytes */\r\n\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\n\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_wrgap(unit=%d, gaplen=%u)\\n\", (int)(uptr-ctx->dptr->units), gaplen);\r\n\r\nif (density == 0)                                       /* if the density has not been set */\r\n    return MTSE_IOERR;                                  /*   then report an I/O error */\r\nelse                                                    /* otherwise */\r\n    return tape_erase_fwd (uptr, byte_length);          /*   erase the requested gap size in bytes */\r\n}\r\n\r\nt_stat sim_tape_wrgap_a (UNIT *uptr, uint32 gaplen, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_wrgap (uptr, gaplen);\r\nAIO_CALL(TOP_RDRR, NULL, NULL, NULL, 0, 0, gaplen, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Erase a record forward.\r\n\r\n   An erase gap is written in the forward direction on the tape unit specified\r\n   by \"uptr\" for a length corresponding to a record containing the number of\r\n   bytes specified by \"bc\", and the status of the operation is returned.  The\r\n   resulting gap will occupy \"bc\" bytes plus the size of the record length\r\n   metadata.  This function may be used to erase a record of length \"n\" in place\r\n   by requesting a gap of length \"n\".  After erasure, the tape will be\r\n   positioned at the end of the gap.\r\n\r\n   If a length of 0 is specified, then the metadatum marker at the current tape\r\n   position will be erased.  If the tape is not positioned at a metadatum\r\n   marker, the routine fails with MTSE_INVRL, and the tape position is\r\n   unchanged.\r\n*/\r\n\r\nt_stat sim_tape_errecf (UNIT *uptr, t_mtrlnt bc)\r\n{\r\nconst t_mtrlnt meta_size = sizeof (t_mtrlnt);           /* the number of bytes per metadatum */\r\nconst t_mtrlnt gap_size = bc + 2 * meta_size;           /* the requested gap size in bytes */\r\n\r\nif (bc == 0)                                            /* if a zero-length erase is requested */\r\n    return tape_erase_fwd (uptr, meta_size);            /*   then erase a metadatum marker */\r\nelse                                                    /* otherwise */\r\n    return tape_erase_fwd (uptr, gap_size);             /*   erase the requested gap */\r\n}\r\n\r\n/* Erase a record reverse.\r\n\r\n   An erase gap is written in the reverse direction on the tape unit specified\r\n   by \"uptr\" for a length corresponding to a record containing the number of\r\n   bytes specified by \"bc\", and the status of the operation is returned.  The\r\n   resulting gap will occupy \"bc\" bytes plus the size of the record length\r\n   metadata.  This function may be used to erase a record of length \"n\" in place\r\n   by requesting a gap of length \"n\".  After erasure, the tape will be\r\n   positioned at the start of the gap.\r\n\r\n   If a length of 0 is specified, then the metadatum marker preceding the\r\n   current tape position will be erased.  If the tape is not positioned after a\r\n   metadatum marker, the routine fails with MTSE_INVRL, and the tape position is\r\n   unchanged.\r\n*/\r\n\r\nt_stat sim_tape_errecr (UNIT *uptr, t_mtrlnt bc)\r\n{\r\nconst t_mtrlnt meta_size = sizeof (t_mtrlnt);           /* the number of bytes per metadatum */\r\nconst t_mtrlnt gap_size = bc + 2 * meta_size;           /* the requested gap size in bytes */\r\n\r\nif (bc == 0)                                            /* if a zero-length erase is requested */\r\n    return tape_erase_rev (uptr, meta_size);            /*   then erase a metadatum marker */\r\nelse                                                    /* otherwise */\r\n    return tape_erase_rev (uptr, gap_size);             /*   erase the requested gap */\r\n}\r\n\r\n/* Space record forward\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        bc      =       pointer to size of record skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   read error           unchanged, PNU set\r\n   end of file/medium   unchanged, PNU set\r\n   tape mark            updated\r\n   data record          updated\r\n   data record error    updated\r\n*/\r\n\r\nt_stat sim_tape_sprecf (UNIT *uptr, t_mtrlnt *bc)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat st;\r\n\r\n*bc = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_sprecf(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\n\r\nst = sim_tape_rdrlfwd (uptr, bc);                       /* get record length */\r\n*bc = MTR_L (*bc);\r\nreturn st;\r\n}\r\n\r\nt_stat sim_tape_sprecf_a (UNIT *uptr, t_mtrlnt *bc, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_sprecf (uptr, bc);\r\nAIO_CALL(TOP_SPRF, NULL, bc, NULL, 0, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space records forward\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        count   =       count of records to skip\r\n        skipped =       pointer to number of records actually skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   read error           unchanged, PNU set\r\n   end of file/medium   unchanged, PNU set\r\n   tape mark            updated\r\n   data record          updated\r\n   data record error    updated\r\n*/\r\n\r\nt_stat sim_tape_sprecsf (UNIT *uptr, uint32 count, uint32 *skipped)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat st;\r\nt_mtrlnt tbc;\r\n\r\n*skipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_sprecsf(unit=%d, count=%d)\\n\", (int)(uptr-ctx->dptr->units), count);\r\n\r\nwhile (*skipped < count) {                              /* loop */\r\n    st = sim_tape_sprecf (uptr, &tbc);                  /* spc rec */\r\n    if (st != MTSE_OK)\r\n        return st;\r\n    *skipped = *skipped + 1;                            /* # recs skipped */\r\n    }\r\nreturn MTSE_OK;\r\n}\r\n\r\nt_stat sim_tape_sprecsf_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_sprecsf (uptr, count, skipped);\r\nAIO_CALL(TOP_SRSF, NULL, skipped, NULL, 0, count, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space record reverse\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        bc      =       pointer to size of records skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   beginning of tape    unchanged\r\n   read error           unchanged\r\n   end of file          unchanged\r\n   end of medium        updated\r\n   tape mark            updated\r\n   data record          updated\r\n*/\r\n\r\nt_stat sim_tape_sprecr (UNIT *uptr, t_mtrlnt *bc)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat st;\r\n\r\n*bc = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_sprecr(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\n\r\nif (MT_TST_PNU (uptr)) {\r\n    MT_CLR_PNU (uptr);\r\n    *bc = 0;\r\n    return MTSE_OK;\r\n    }\r\nst = sim_tape_rdrlrev (uptr, bc);                       /* get record length */\r\n*bc = MTR_L (*bc);\r\nreturn st;\r\n}\r\n\r\nt_stat sim_tape_sprecr_a (UNIT *uptr, t_mtrlnt *bc, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_sprecr (uptr, bc);\r\nAIO_CALL(TOP_SPRR, NULL, bc, NULL, 0, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space records reverse\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        count   =       count of records to skip\r\n        skipped =       pointer to number of records actually skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   beginning of tape    unchanged\r\n   read error           unchanged\r\n   end of file          unchanged\r\n   end of medium        updated\r\n   tape mark            updated\r\n   data record          updated\r\n*/\r\n\r\nt_stat sim_tape_sprecsr (UNIT *uptr, uint32 count, uint32 *skipped)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat st;\r\nt_mtrlnt tbc;\r\n\r\n*skipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_sprecsr(unit=%d, count=%d)\\n\", (int)(uptr-ctx->dptr->units), count);\r\n\r\nwhile (*skipped < count) {                              /* loop */\r\n    st = sim_tape_sprecr (uptr, &tbc);                  /* spc rec rev */\r\n    if (st != MTSE_OK)\r\n        return st;\r\n    *skipped = *skipped + 1;                            /* # recs skipped */\r\n    }\r\nreturn MTSE_OK;\r\n}\r\n\r\nt_stat sim_tape_sprecsr_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_sprecsr (uptr, count, skipped);\r\nAIO_CALL(TOP_SRSR, NULL, skipped, NULL, 0, count, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space files forward by record\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        count   =       count of files to skip\r\n        skipped =       pointer to number of files actually skipped\r\n        recsskipped =   pointer to number of records skipped\r\n        check_leot =    flag to detect and stop skip between two successive tape marks\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   read error           unchanged, PNU set\r\n   end of file/medium   unchanged, PNU set\r\n   tape mark            updated\r\n   data record          updated\r\n   data record error    updated\r\n*/\r\n\r\nt_stat sim_tape_spfilebyrecf (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped, t_bool check_leot)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat st;\r\nt_bool last_tapemark = FALSE;\r\nuint32 filerecsskipped;\r\n\r\n*skipped = *recsskipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_spfilebyrecf(unit=%d, count=%d, check_leot=%d)\\n\", (int)(uptr-ctx->dptr->units), count, check_leot);\r\n\r\nif (check_leot) {\r\n    t_mtrlnt rbc;\r\n\r\n    st = sim_tape_rdrlrev (uptr, &rbc);\r\n    last_tapemark = (MTSE_TMK == st);\r\n    if ((st == MTSE_OK) || (st == MTSE_TMK))\r\n        sim_tape_rdrlfwd (uptr, &rbc);\r\n    }\r\n*skipped = 0;\r\n*recsskipped = 0;\r\nwhile (*skipped < count) {                              /* loop */\r\n    while (1) {\r\n        st = sim_tape_sprecsf (uptr, 0x1ffffff, &filerecsskipped);/* spc recs */\r\n        *recsskipped += filerecsskipped;\r\n        if (st != MTSE_OK)\r\n            break;\r\n        }\r\n    if (st == MTSE_TMK) {\r\n        *skipped = *skipped + 1;                        /* # files skipped */\r\n        if (check_leot && (filerecsskipped == 0) && last_tapemark) {\r\n            uint32 filefileskipped;\r\n            sim_tape_spfilebyrecr (uptr, 1, &filefileskipped, &filerecsskipped);\r\n            *skipped = *skipped - 1;                    /* adjust # files skipped */\r\n            return MTSE_LEOT;\r\n            }\r\n        last_tapemark = TRUE;\r\n        }\r\n    else\r\n        return st;\r\n    }\r\nreturn MTSE_OK;\r\n}\r\n\r\nt_stat sim_tape_spfilebyrecf_a (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped, t_bool check_leot, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_spfilebyrecf (uptr, count, skipped, recsskipped, check_leot);\r\nAIO_CALL(TOP_SFRF, NULL, skipped, recsskipped, check_leot, count, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space files forward\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        count   =       count of files to skip\r\n        skipped =       pointer to number of files actually skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   read error           unchanged, PNU set\r\n   end of file/medium   unchanged, PNU set\r\n   tape mark            updated\r\n   data record          updated\r\n   data record error    updated\r\n*/\r\n\r\nt_stat sim_tape_spfilef (UNIT *uptr, uint32 count, uint32 *skipped)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nuint32 totalrecsskipped;\r\n\r\n*skipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_spfilef(unit=%d, count=%d)\\n\", (int)(uptr-ctx->dptr->units), count);\r\n\r\nreturn sim_tape_spfilebyrecf (uptr, count, skipped, &totalrecsskipped, FALSE);\r\n}\r\n\r\nt_stat sim_tape_spfilef_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_spfilef (uptr, count, skipped);\r\nAIO_CALL(TOP_SPFF, NULL, skipped, NULL, 0, count, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space files reverse by record\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        count   =       count of files to skip\r\n        skipped =       pointer to number of files actually skipped\r\n        recsskipped =   pointer to number of records skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   beginning of tape    unchanged\r\n   read error           unchanged\r\n   end of file          unchanged\r\n   end of medium        updated\r\n   tape mark            updated\r\n   data record          updated\r\n*/\r\n\r\nt_stat sim_tape_spfilebyrecr (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat st;\r\nuint32 filerecsskipped;\r\n\r\n*skipped = 0;\r\n*recsskipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_spfilebyrecr(unit=%d, count=%d)\\n\", (int)(uptr-ctx->dptr->units), count);\r\n\r\nwhile (*skipped < count) {                              /* loop */\r\n    while (1) {\r\n        st = sim_tape_sprecsr (uptr, 0x1ffffff, &filerecsskipped);/* spc recs rev */\r\n        *recsskipped += filerecsskipped;\r\n        if (st != MTSE_OK)\r\n            break;\r\n        }\r\n    if (st == MTSE_TMK)\r\n        *skipped = *skipped + 1;                        /* # files skipped */\r\n    else\r\n        return st;\r\n    }\r\nreturn MTSE_OK;\r\n}\r\n\r\nt_stat sim_tape_spfilebyrecr_a (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_spfilebyrecr (uptr, count, skipped, recsskipped);\r\nAIO_CALL(TOP_SPFR, NULL, skipped, recsskipped, 0, count, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Space files reverse\r\n\r\n   Inputs:\r\n        uptr    =       pointer to tape unit\r\n        count   =       count of files to skip\r\n        skipped =       pointer to number of files actually skipped\r\n   Outputs:\r\n        status  =       operation status\r\n\r\n   exit condition       position\r\n\r\n   unit unattached      unchanged\r\n   beginning of tape    unchanged\r\n   read error           unchanged\r\n   end of file          unchanged\r\n   end of medium        updated\r\n   tape mark            updated\r\n   data record          updated\r\n*/\r\n\r\nt_stat sim_tape_spfiler (UNIT *uptr, uint32 count, uint32 *skipped)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nuint32 totalrecsskipped;\r\n\r\n*skipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_spfiler(unit=%d, count=%d)\\n\", (int)(uptr-ctx->dptr->units), count);\r\n\r\nreturn sim_tape_spfilebyrecr (uptr, count, skipped, &totalrecsskipped);\r\n}\r\n\r\nt_stat sim_tape_spfiler_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_spfiler (uptr, count, skipped);\r\nAIO_CALL(TOP_SPFR, NULL, skipped, NULL, 0, count, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Rewind tape */\r\n\r\nt_stat sim_tape_rewind (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nif (uptr->flags & UNIT_ATT) {\r\n    if (ctx == NULL)                                    /* if not properly attached? */\r\n        return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");/*   that's a problem */\r\n    sim_debug_unit (ctx->dbit, uptr, \"sim_tape_rewind(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\n    }\r\nuptr->pos = 0;\r\nif (uptr->flags & UNIT_ATT) {\r\n    (void)sim_tape_seek (uptr, uptr->pos);\r\n    }\r\nMT_CLR_PNU (uptr);\r\nMT_CLR_INMRK (uptr);                                    /* Not within a TAR tapemark */\r\nreturn MTSE_OK;\r\n}\r\n\r\nt_stat sim_tape_rewind_a (UNIT *uptr, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_rewind (uptr);\r\nAIO_CALL(TOP_RWND, NULL, NULL, NULL, 0, 0, 0, 0, NULL, callback);\r\nreturn r;\r\n}\r\n\r\n/* Position Tape */\r\n\r\nt_stat sim_tape_position (UNIT *uptr, uint32 flags, uint32 recs, uint32 *recsskipped, uint32 files, uint32 *filesskipped, uint32 *objectsskipped)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\nt_stat r = MTSE_OK;\r\n\r\n*recsskipped = *filesskipped = *objectsskipped = 0;\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_position(unit=%d, flags=0x%X, recs=%d, files=%d)\\n\", (int)(uptr-ctx->dptr->units), flags, recs, files);\r\n\r\nif (flags & MTPOS_M_REW)\r\n    r = sim_tape_rewind (uptr);\r\nif (r != MTSE_OK)\r\n    return r;\r\nif (flags & MTPOS_M_OBJ) {\r\n    uint32 objs = recs;\r\n    uint32 skipped;\r\n    uint32 objsremaining = objs;\r\n\r\n    while (*objectsskipped < objs) {                    /* loop */\r\n        if (flags & MTPOS_M_REV)                        /* reverse? */\r\n            r = sim_tape_sprecsr (uptr, objsremaining, &skipped);\r\n        else\r\n            r = sim_tape_sprecsf (uptr, objsremaining, &skipped);\r\n        objsremaining = objsremaining - (skipped + ((r == MTSE_TMK) ? 1 : 0));\r\n        if ((r == MTSE_TMK) || (r == MTSE_OK))\r\n            *objectsskipped = *objectsskipped + skipped + ((r == MTSE_TMK) ? 1 : 0);\r\n        else\r\n            return r;\r\n        }\r\n    r = MTSE_OK;\r\n    }\r\nelse {\r\n    uint32 fileskiprecs;\r\n\r\n    if (flags & MTPOS_M_REV)                            /* reverse? */\r\n        r = sim_tape_spfilebyrecr (uptr, files, filesskipped, &fileskiprecs);\r\n    else\r\n        r = sim_tape_spfilebyrecf (uptr, files, filesskipped, &fileskiprecs, (flags & MTPOS_M_DLE));\r\n    if (r != MTSE_OK)\r\n        return r;\r\n    if (flags & MTPOS_M_REV)                            /* reverse? */\r\n        r = sim_tape_sprecsr (uptr, recs, recsskipped);\r\n    else\r\n        r = sim_tape_sprecsf (uptr, recs, recsskipped);\r\n    if (r == MTSE_TMK)\r\n        *filesskipped = *filesskipped + 1;\r\n    *objectsskipped = fileskiprecs + *filesskipped + *recsskipped;\r\n    }\r\nreturn r;\r\n}\r\n\r\nt_stat sim_tape_position_a (UNIT *uptr, uint32 flags, uint32 recs, uint32 *recsskipped, uint32 files, uint32 *filesskipped, uint32 *objectsskipped, TAPE_PCALLBACK callback)\r\n{\r\nt_stat r = MTSE_OK;\r\nAIO_CALLSETUP\r\n    r = sim_tape_position (uptr, flags, recs, recsskipped, files, filesskipped, objectsskipped);\r\nAIO_CALL(TOP_POSN, NULL, recsskipped, filesskipped, 0, flags, recs, files, objectsskipped, callback);\r\nreturn r;\r\n}\r\n\r\n/* Reset tape */\r\n\r\nt_stat sim_tape_reset (UNIT *uptr)\r\n{\r\nstruct tape_context *ctx = (struct tape_context *)uptr->tape_ctx;\r\n\r\nMT_CLR_PNU (uptr);\r\nif (!(uptr->flags & UNIT_ATT))                          /* attached? */\r\n    return SCPE_OK;\r\n\r\nif (ctx == NULL)                                        /* if not properly attached? */\r\n    return sim_messagef (SCPE_IERR, \"Bad Attach\\n\");    /*   that's a problem */\r\nsim_debug_unit (ctx->dbit, uptr, \"sim_tape_reset(unit=%d)\\n\", (int)(uptr-ctx->dptr->units));\r\n\r\n_sim_tape_io_flush(uptr);\r\nAIO_VALIDATE(uptr);\r\nAIO_UPDATE_QUEUE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Test for BOT */\r\n\r\nt_bool sim_tape_bot (UNIT *uptr)\r\n{\r\nuint32 f = MT_GET_FMT (uptr);\r\n\r\nreturn ((uptr->pos <= fmts[f].bot) && (!MT_TST_INMRK (uptr))) ? TRUE: FALSE;\r\n}\r\n\r\n/* Test for end of tape */\r\n\r\nt_bool sim_tape_eot (UNIT *uptr)\r\n{\r\nreturn (uptr->capac && (uptr->pos >= uptr->capac))? TRUE: FALSE;\r\n}\r\n\r\n/* Test for write protect */\r\n\r\nt_bool sim_tape_wrp (UNIT *uptr)\r\n{\r\nreturn ((uptr->flags & MTUF_WRP) || (uptr->flags & UNIT_RO) || (MT_GET_FMT (uptr) == MTUF_F_TPC))? TRUE: FALSE;\r\n}\r\n\r\n/* Process I/O error */\r\n\r\nstatic t_stat sim_tape_ioerr (UNIT *uptr)\r\n{\r\nsim_printf (\"%s: Magtape library I/O error: %s\\n\", sim_uname (uptr), strerror (errno));\r\nclearerr (uptr->fileref);\r\nreturn MTSE_IOERR;\r\n}\r\n\r\n/* Set tape format */\r\n\r\nt_stat sim_tape_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nuint32 f;\r\n\r\nif (uptr == NULL)\r\n    return SCPE_IERR;\r\nif (uptr->flags & UNIT_ATT)\r\n    return SCPE_ALATT;\r\nif (cptr == NULL)\r\n    return SCPE_ARG;\r\nfor (f = 0; fmts[f].name; f++) {\r\n    if (MATCH_CMD(fmts[f].name, cptr) == 0) {\r\n        uint32 a = 0;\r\n\r\n        if (f == MTUF_F_ANSI) {\r\n            for (a = 0; ansi_args[a].name; a++)\r\n                if (MATCH_CMD(ansi_args[a].name, cptr) == 0)\r\n                    break;\r\n            if (ansi_args[a].name == NULL)\r\n                return sim_messagef (SCPE_ARG, \"Unknown ANSI tape format: %s\\n\", cptr);\r\n            }\r\n        uptr->flags &= ~UNIT_RO;\r\n        uptr->flags |= fmts[f].uflags;\r\n        uptr->dynflags &= ~UNIT_M_TAPE_FMT;\r\n        uptr->dynflags |= (f << UNIT_V_TAPE_FMT);\r\n        uptr->dynflags &= ~UNIT_M_TAPE_ANSI;\r\n        uptr->dynflags |= (a << UNIT_V_TAPE_ANSI);\r\n        return SCPE_OK;\r\n        }\r\n    }\r\nreturn sim_messagef (SCPE_ARG, \"Unknown tape format: %s\\n\", cptr);\r\n}\r\n\r\n/* Show tape format */\r\n\r\nt_stat sim_tape_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nfprintf (st, \"%s format\", _sim_tape_format_name (uptr));\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Map a TPC format tape image */\r\n\r\nstatic uint32 sim_tape_tpc_map (UNIT *uptr, t_addr *map, uint32 mapsize)\r\n{\r\nt_addr tpos, leot = 0;\r\nt_addr tape_size;\r\nt_tpclnt bc, last_bc = TPC_EOM;\r\nuint32 had_double_tape_mark = 0;\r\nsize_t i;\r\nuint32 objc, sizec;\r\nuint32 *countmap = NULL;\r\nuint8 *recbuf = NULL;\r\nDEVICE *dptr = find_dev_from_unit (uptr);\r\n\r\nif ((uptr == NULL) || (uptr->fileref == NULL))\r\n    return 0;\r\ncountmap = (uint32 *)calloc (65536, sizeof(*countmap));\r\nrecbuf = (uint8 *)malloc (65536);\r\ntape_size = (t_addr)sim_fsize (uptr->fileref);\r\nsim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: tape_size: %\" T_ADDR_FMT \"u\\n\", tape_size);\r\nfor (objc = 0, sizec = 0, tpos = 0;; ) {\r\n    (void)sim_tape_seek (uptr, tpos);\r\n    i = sim_fread (&bc, sizeof (bc), 1, uptr->fileref);\r\n    if (i == 0)     /* past or at eof? */\r\n        break;\r\n    if (bc > 65535) /* Range check length value to satisfy Coverity */\r\n        break;\r\n    if (countmap[bc] == 0)\r\n        sizec++;\r\n    ++countmap[bc];\r\n    if (map && (objc < mapsize))\r\n        map[objc] = tpos;\r\n    if (bc) {\r\n        sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: %d byte count at pos: %\" T_ADDR_FMT \"u\\n\", bc, tpos);\r\n        if (map && sim_deb && (dptr->dctrl & MTSE_DBG_STR)) {\r\n            (void)sim_fread (recbuf, 1, bc, uptr->fileref);\r\n            sim_data_trace(dptr, uptr, (((uptr->dctrl | dptr->dctrl) & MTSE_DBG_DAT) ? recbuf : NULL), \"\", bc, \"Data Record\", MTSE_DBG_STR);\r\n            }\r\n        }\r\n    else\r\n        sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: tape mark at pos: %\" T_ADDR_FMT \"u\\n\", tpos);\r\n    objc++;\r\n    tpos = tpos + ((bc + 1) & ~1) + sizeof (t_tpclnt);\r\n    if ((bc == 0) && (last_bc == 0)) {  /* double tape mark? */\r\n        had_double_tape_mark = objc;\r\n        leot = tpos;\r\n        }\r\n    last_bc = bc;\r\n    }\r\nsim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: objc: %u, different record sizes: %u\\n\", objc, sizec);\r\nfor (i=0; i<65535; i++) {\r\n    if (countmap[i]) {\r\n        if (i == 0)\r\n            sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: summary - %u tape marks\\n\", countmap[i]);\r\n        else\r\n            sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: summary - %u %d byte record%s\\n\", countmap[i], (int)i, (countmap[i] > 1) ? \"s\" : \"\");\r\n        }\r\n    }\r\nif (((last_bc != TPC_EOM) &&\r\n     (tpos > tape_size) &&\r\n     (!had_double_tape_mark))    ||\r\n    (!had_double_tape_mark)      ||\r\n    ((objc == countmap[0]) &&\r\n     (countmap[0] != 2))) {     /* Unreasonable format? */\r\n    if (last_bc != TPC_EOM)\r\n        sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: ERROR unexpected EOT byte count: %d\\n\", last_bc);\r\n    if (tpos > tape_size)\r\n        sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: ERROR next record position %\" T_ADDR_FMT \"u beyond EOT: %\" T_ADDR_FMT \"u\\n\", tpos, tape_size);\r\n    if (objc == countmap[0])\r\n        sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: ERROR tape only contains tape marks\\n\");\r\n    free (countmap);\r\n    free (recbuf);\r\n    return 0;\r\n    }\r\n\r\nif ((last_bc != TPC_EOM) && (tpos > tape_size)) {\r\n    sim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: WARNING unexpected EOT byte count: %d, double tape mark before %\" T_ADDR_FMT \"u provides logical EOT\\n\", last_bc, leot);\r\n    objc = had_double_tape_mark;\r\n    tpos = leot;\r\n    }\r\nif (map)\r\n    map[objc] = tpos;\r\nsim_debug_unit (MTSE_DBG_STR, uptr, \"tpc_map: OK objc: %d\\n\", objc);\r\nfree (countmap);\r\nfree (recbuf);\r\nreturn objc;\r\n}\r\n\r\nconst char *sim_tape_error_text (t_stat stat)\r\n{\r\nconst char *mtse_errors[] = {\r\n    \"no error\",\r\n    \"tape mark\",\r\n    \"unattached\",\r\n    \"I/O error\",\r\n    \"invalid record length\",\r\n    \"invalid format\",\r\n    \"beginning of tape\",\r\n    \"end of medium\",\r\n    \"error in record\",\r\n    \"write protected\",\r\n    \"Logical End Of Tape\",\r\n    \"tape runaway\"\r\n    };\r\nstatic char msgbuf[64];\r\n\r\nif (stat <= MTSE_MAX_ERR)\r\n    return mtse_errors[stat];\r\nsprintf(msgbuf, \"Error %d\", stat);\r\nreturn msgbuf;\r\n}\r\n\r\n#ifndef MAX\r\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\r\n#endif\r\n\r\nstatic t_stat sim_tape_validate_tape (UNIT *uptr)\r\n{\r\nt_addr saved_pos = uptr->pos;\r\nuint32 data_total = 0;\r\nuint32 tapemark_total = 0;\r\nuint32 record_total = 0;\r\nuint32 unique_record_sizes = 0;\r\nuint32 remaining_data = 0;\r\nuint32 gaps = 0;\r\nuint32 gap_bytes = 0;\r\nuint32 *rec_sizes = NULL;\r\nt_stat r = SCPE_OK;\r\nt_stat r_f;\r\nt_stat r_r;\r\nt_stat r_s;\r\nuint8 *buf_f = NULL;\r\nuint8 *buf_r = NULL;\r\nt_mtrlnt bc_f;\r\nt_mtrlnt bc_r;\r\nt_mtrlnt bc_s;\r\nt_mtrlnt bc;\r\nt_addr pos_f;\r\nt_addr pos_r;\r\nt_addr pos_fa;\r\nt_addr pos_sa;\r\nt_mtrlnt max = MTR_MAXLEN;\r\n\r\nif (!(uptr->flags & UNIT_ATT))\r\n    return SCPE_UNATT;\r\nbuf_f = (uint8 *)calloc (1, max);\r\nif (buf_f == NULL)\r\n    return SCPE_MEM;\r\nbuf_r = (uint8 *)calloc (1, max);\r\nif (buf_r == NULL) {\r\n    free (buf_f);\r\n    return SCPE_MEM;\r\n    }\r\nrec_sizes = (uint32 *)calloc (max + 1, sizeof (*rec_sizes));\r\nif (rec_sizes == NULL) {\r\n    free (buf_f);\r\n    free (buf_r);\r\n    return SCPE_MEM;\r\n    }\r\n\r\nr = sim_tape_rewind (uptr);\r\nwhile (r == SCPE_OK) {\r\n    if (stop_cpu) { /* SIGINT? */\r\n        stop_cpu = FALSE;\r\n        break;\r\n        }\r\n    pos_f = uptr->pos;\r\n    r_f = sim_tape_rdrecf (uptr, buf_f, &bc_f, max);\r\n    pos_fa = uptr->pos;\r\n    switch (r_f) {\r\n    case MTSE_OK:                                   /* no error */\r\n    case MTSE_TMK:                                  /* tape mark */\r\n        if (r_f == MTSE_OK)\r\n            ++record_total;\r\n        else\r\n            ++tapemark_total;\r\n        data_total += bc_f;\r\n        if (bc_f != 0) {\r\n            if (rec_sizes[bc_f] == 0)\r\n                ++unique_record_sizes;\r\n            ++rec_sizes[bc_f];\r\n            }\r\n        r_r = sim_tape_rdrecr (uptr, buf_r, &bc_r, max);\r\n        pos_r = uptr->pos;\r\n        if (r_r != r_f) {\r\n            sim_printf (\"Forward Record Read returned: %s, Reverse read returned: %s\\n\", sim_tape_error_text (r_f), sim_tape_error_text (r_r));\r\n            r = MAX(r_f, r_r);\r\n            break;\r\n            }\r\n        if (bc_f != bc_r) {\r\n            sim_printf (\"Forward Record Read record length: %d, Reverse read record length: %d\\n\", bc_f, bc_r);\r\n            r = MTSE_RECE;\r\n            break;\r\n            }\r\n        if (0 != memcmp (buf_f, buf_r, bc_f)) {\r\n            sim_printf (\"%d byte record contents differ when read forward and backwards start from position %\" T_ADDR_FMT \"u\\n\", bc_f, pos_f);\r\n            r = MTSE_RECE;\r\n            break;\r\n            }\r\n        memset (buf_f, 0, bc_f);\r\n        memset (buf_r, 0, bc_r);\r\n        if (pos_f != pos_r) {\r\n            if (MT_GET_FMT (uptr) == MTUF_F_STD) {\r\n                ++gaps;\r\n                gap_bytes += (uint32)(pos_r - pos_f);\r\n                }\r\n            else {\r\n                sim_printf (\"Unexpected tape file position between forward and reverse record read: (%\" T_ADDR_FMT \"u, %\" T_ADDR_FMT \"u)\\n\", pos_f, pos_r);\r\n                r = MTSE_RECE;\r\n                break;\r\n                }\r\n            }\r\n        r_s = sim_tape_sprecf (uptr, &bc_s);\r\n        pos_sa = uptr->pos;\r\n        if (r_s != r_f) {\r\n            sim_printf (\"Unexpected Space Record Status: %s vs %s\\n\", sim_tape_error_text (r_s), sim_tape_error_text (r_f));\r\n            r = MAX(r_s, r_f);\r\n            break;\r\n            }\r\n        if (bc_s != bc_f) {\r\n            sim_printf (\"Unexpected Space Record Length: %d vs %d\\n\", bc_s, bc_f);\r\n            r = MTSE_RECE;\r\n            break;\r\n            }\r\n        if (pos_fa != pos_sa) {\r\n            sim_printf (\"Unexpected tape file position after forward and skip record: (%\" T_ADDR_FMT \"u, %\" T_ADDR_FMT \"u)\\n\", pos_fa, pos_sa);\r\n            break;\r\n            }\r\n        r = SCPE_OK;\r\n        break;\r\n    case MTSE_INVRL:                                /* invalid rec lnt */\r\n    case MTSE_FMT:                                  /* invalid format */\r\n    case MTSE_BOT:                                  /* beginning of tape */\r\n    case MTSE_RECE:                                 /* error in record */\r\n    case MTSE_WRP:                                  /* write protected */\r\n    case MTSE_LEOT:                                 /* Logical End Of Tape */\r\n    case MTSE_RUNAWAY:                              /* tape runaway */\r\n    default:\r\n        r = r_f;\r\n        break;\r\n    case MTSE_EOM:                                  /* end of medium */\r\n        r = r_f;\r\n        break;\r\n        }\r\n    }\r\nuptr->tape_eom = uptr->pos;\r\nif (!stop_cpu) {            /* if SIGINT didn't interrupt the scan */\r\n    sim_messagef (SCPE_OK, \"%s: Tape Image %s'%s' scanned as %s format\\n\", sim_uname (uptr),\r\n                           ((MT_GET_FMT (uptr) >= MTUF_F_ANSI) ? \"made from \" : \"\"), uptr->filename,\r\n                           _sim_tape_format_name (uptr));\r\n    remaining_data = (uint32)(sim_tape_size (uptr) - (t_offset)uptr->tape_eom);\r\n    if ((r != MTSE_EOM) || (sim_switches & SWMASK ('V')) || (sim_switches & SWMASK ('L')) ||\r\n        (remaining_data > 0) ||\r\n        (unique_record_sizes > 2 * tapemark_total)) {\r\n        sim_messagef (SCPE_OK, \"%s %u bytes of tape data (%u record%s, %u tapemark%s)\\n\",\r\n                               (r != MTSE_EOM) ? \"After processing\" : \"contains\", data_total,\r\n                               record_total, (record_total == 1) ? \"\" : \"s\",\r\n                               tapemark_total, (tapemark_total == 1) ? \"\" : \"s\");\r\n        if ((record_total > 0) && (sim_switches & SWMASK ('L'))) {\r\n            sim_messagef (SCPE_OK, \"Comprising %d different sized records (in record size order):\\n\", unique_record_sizes);\r\n            for (bc = 0; bc <= max; bc++) {\r\n                if (rec_sizes[bc])\r\n                    sim_messagef (SCPE_OK, \"%8u %u byte record%s\\n\", rec_sizes[bc], (uint32)bc, (rec_sizes[bc] != 1) ? \"s\" : \"\");\r\n                }\r\n            if (gaps)\r\n                sim_messagef (SCPE_OK, \"%8u gap%s totalling %u bytes %s seen\\n\", gaps, (gaps != 1) ? \"s\" : \"\", gap_bytes, (gaps != 1) ? \"were\" : \"was\");\r\n            }\r\n        if (r != MTSE_EOM)\r\n            sim_messagef (SCPE_OK, \"Read Tape Record Returned Unexpected Status: %s\\n\", sim_tape_error_text (r));\r\n        if (remaining_data > fmts[MT_GET_FMT (uptr)].eom_remnant)\r\n            sim_messagef (SCPE_OK, \"%u %s of unexamined data remain in the tape image file\\n\",\r\n                                   remaining_data, (MT_GET_FMT (uptr) < MTUF_F_ANSI) ? \"bytes\" : \"records\");\r\n        }\r\n    if (unique_record_sizes > 2 * tapemark_total) {\r\n        sim_messagef (SCPE_OK, \"A potentially unreasonable number of record sizes(%u) vs tape marks (%u) have been found\\n\", unique_record_sizes, tapemark_total);\r\n        sim_messagef (SCPE_OK, \"The tape format (%s) might not be correct for the '%s' tape image\\n\", _sim_tape_format_name (uptr), uptr->filename);\r\n        }\r\n    if (uptr->tape_chunk_size > 0) {\r\n        t_bool good_chunks = TRUE;\r\n        uint32 chunk_total, error_total;\r\n\r\n        for (bc = 0; bc <= max; bc++) {\r\n            if ((rec_sizes[bc] != 0) &&\r\n                ((bc % uptr->tape_chunk_size) != 0)) {\r\n                sim_messagef (SCPE_OK, \"Records of size %u are not a multiple of the required %u for this device\\n\", bc, uptr->tape_chunk_size);\r\n                good_chunks = FALSE;\r\n                }\r\n            }\r\n        if (good_chunks) {\r\n            error_total = chunk_total = tapemark_total = 0;\r\n            r = sim_tape_rewind (uptr);\r\n            while (r == SCPE_OK) {\r\n                if (stop_cpu) { /* SIGINT? */\r\n                    stop_cpu = FALSE;\r\n                    break;\r\n                    }\r\n                r = sim_tape_rdrecf (uptr, buf_f, &bc_f, uptr->tape_chunk_size);\r\n                switch (r) {\r\n                case MTSE_OK:                                   /* no error */\r\n                case MTSE_TMK:                                  /* tape mark */\r\n                    if (r == MTSE_OK)\r\n                        ++chunk_total;\r\n                    else\r\n                        ++tapemark_total;\r\n                    r = SCPE_OK;\r\n                    break;\r\n                case MTSE_EOM:                                  /* end of medium */\r\n                    break;\r\n                default:\r\n                    ++error_total;\r\n                    r = SCPE_OK;\r\n                    }\r\n                }\r\n            sim_tape_rewind (uptr);\r\n            }\r\n        }\r\n    }\r\n\r\nfree (buf_f);\r\nfree (buf_r);\r\nfree (rec_sizes);\r\nuptr->pos = saved_pos;\r\n(void)sim_tape_seek (uptr, uptr->pos);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Find the preceding record in a TPC file */\r\n\r\nstatic t_addr sim_tape_tpc_fnd (UNIT *uptr, t_addr *map)\r\n{\r\nuint32 lo, hi, p;\r\n\r\n\r\nif (map == NULL)\r\n    return 0;\r\nlo = 0;\r\nhi = uptr->hwmark - 1;\r\ndo {\r\n    p = (lo + hi) >> 1;\r\n    if (uptr->pos == map[p])\r\n        return ((p == 0)? map[p]: map[p - 1]);\r\n    else {\r\n        if (uptr->pos < map[p])\r\n            hi = p - 1;\r\n        else\r\n            lo = p + 1;\r\n        }\r\n    }\r\nwhile (lo <= hi);\r\nreturn ((p == 0)? map[p]: map[p - 1]);\r\n}\r\n\r\n/* Set tape capacity */\r\n\r\nt_stat sim_tape_set_capac (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nt_addr cap;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_ARG;\r\nif (uptr->flags & UNIT_ATT)\r\n    return SCPE_ALATT;\r\ncap = (t_addr) get_uint (cptr, 10, sim_taddr_64? 2000000: 2000, &r);\r\nif (r != SCPE_OK)\r\n    return SCPE_ARG;\r\nuptr->capac = cap * ((t_addr) 1000000);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show tape capacity */\r\n\r\nt_stat sim_tape_show_capac (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nif (uptr->capac) {\r\n    if (uptr->capac >= (t_addr) 1000000)\r\n        fprintf (st, \"capacity=%dMB\", (uint32) (uptr->capac / ((t_addr) 1000000)));\r\n    else {\r\n        if (uptr->capac >= (t_addr) 1000)\r\n            fprintf (st, \"capacity=%dKB\", (uint32) (uptr->capac / ((t_addr) 1000)));\r\n        else\r\n            fprintf (st, \"capacity=%dB\", (uint32) uptr->capac);\r\n        }\r\n    }\r\nelse\r\n    fprintf (st, \"unlimited capacity\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set the tape density.\r\n\r\n   Set the density of the specified tape unit either to the value supplied or to\r\n   the value represented by the supplied character string.\r\n\r\n   If \"desc\" is NULL, then \"val\" must be set to one of the MT_DENS_* constants\r\n   in sim_tape.h other than MT_DENS_NONE; the supplied value is used as the tape\r\n   density, and the character string is ignored.  Otherwise, \"desc\" must point\r\n   at an int32 value containing a set of allowed densities constructed as a\r\n   bitwise OR of the appropriate MT_*_VALID values.  In this case, the string\r\n   pointed to by \"cptr\" will be parsed for a decimal value corresponding to the\r\n   desired density in bits per inch and validated against the set of allowed\r\n   values.\r\n\r\n   In either case, SCPE_ARG is returned if the density setting is not valid or\r\n   allowed.  If the setting is OK, the new density is set into the unit\r\n   structure, and SCPE_OK is returned.\r\n*/\r\n\r\nt_stat sim_tape_set_dens (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nuint32 density, new_bpi;\r\nt_stat result = SCPE_OK;\r\n\r\nif (uptr == NULL)                                               /* if the unit pointer is null */\r\n    return SCPE_IERR;                                           /*   then the caller has screwed up */\r\n\r\nelse if (desc == NULL)                                          /* otherwise if a validation set was not supplied */\r\n    if (val > 0 && val < (int32) BPI_COUNT)                     /*   then if a valid density code was supplied */\r\n        uptr->dynflags = (uptr->dynflags & ~MTVF_DENS_MASK)     /*     then insert the code */\r\n                           | (val << UNIT_V_DF_TAPE);           /*       in the unit flags */\r\n    else                                                        /*   otherwise the code is invalid */\r\n        return SCPE_ARG;                                        /*     so report a bad argument */\r\n\r\nelse {                                                          /* otherwise a validation set was supplied */\r\n    if (cptr == NULL || *cptr == 0)                             /*   but if no value is present */\r\n        return SCPE_MISVAL;                                     /*     then report a missing value */\r\n\r\n    new_bpi = (uint32) get_uint (cptr, 10, UINT_MAX, &result);  /* convert the string value */\r\n\r\n    if (result != SCPE_OK)                                      /* if the conversion failed */\r\n        result = SCPE_ARG;                                      /*   then report a bad argument */\r\n\r\n    else for (density = 0; density < BPI_COUNT; density++)      /* otherwise validate the density */\r\n        if (new_bpi == bpi [density]                            /* if it matches a value in the list */\r\n          && ((1 << density) & *(const int32 *) desc)) {        /*   and it's an allowed value */\r\n            uptr->dynflags = (uptr->dynflags & ~MTVF_DENS_MASK) /*     then store the index of the value */\r\n                               | density << UNIT_V_DF_TAPE;     /*       in the unit flags */\r\n            return SCPE_OK;                                     /*         and return success */\r\n            }\r\n\r\n    result = SCPE_ARG;                                          /* if no match, then report a bad argument */\r\n    }\r\n\r\nreturn result;                                                  /* return the result of the operation */\r\n}\r\n\r\n/* Show the tape density */\r\n\r\nt_stat sim_tape_show_dens (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nuint32 tape_density;\r\n\r\nif (uptr == NULL)                                       /* if the unit pointer is null */\r\n    return SCPE_IERR;                                   /*   then the caller has screwed up */\r\n\r\nelse {                                                  /* otherwise get the density */\r\n    tape_density = bpi [MT_DENS (uptr->dynflags)];      /*   of the tape from the unit flags */\r\n\r\n    if (tape_density)                                   /* if it's set */\r\n        fprintf (st, \"density=%d bpi\", tape_density);   /*   then report it */\r\n    else                                                /* otherwise */\r\n        fprintf (st, \"density not set\");                /*   it was never set by the caller */\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* list supported densities\r\n\r\n   translates the mask of supported densities to a string list in the form:\r\n\r\n           \"(800|1600|6250)\"\r\n\r\n   this string may be useful to construct a MTAB help string for a\r\n   SET <unit> DENSITY= command.\r\n\r\n*/\r\n\r\nt_stat sim_tape_density_supported (char *string, size_t string_size, int32 valid_bits)\r\n{\r\nuint32 density;\r\nint32 count;\r\n\r\nstrlcpy (string, \"\", string_size);\r\nif ((!valid_bits) || (valid_bits >> BPI_COUNT))\r\n    return SCPE_ARG;\r\nfor (density = count = 0; density < BPI_COUNT; density++) {\r\n    if (valid_bits & (1 << density)) {\r\n        char density_str[20];\r\n\r\n        ++count;\r\n        if (count == 1)\r\n            strlcat (string, \"{\", string_size);\r\n        else\r\n            strlcat (string, \"|\", string_size);\r\n        sprintf (density_str, \"%d\", bpi[density]);\r\n        strlcat (string, density_str, string_size);\r\n        }\r\n    }\r\nif ((count == 1) && (string_size > 1))\r\n    memmove (string, string + 1, strlen (string));\r\nelse\r\n    strlcat (string, \"}\", string_size);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic DEBTAB tape_debug[] = {\r\n  {\"TRACE\",     MTSE_DBG_API,       \"API Trace\"},\r\n  {\"DATA\",      MTSE_DBG_DAT,       \"Tape Data\"},\r\n  {\"POS\",       MTSE_DBG_POS,       \"Positioning Activities\"},\r\n  {\"STR\",       MTSE_DBG_STR,       \"Tape Structure\"},\r\n  {0}\r\n};\r\n\r\nt_stat sim_tape_add_debug (DEVICE *dptr)\r\n{\r\nif (DEV_TYPE(dptr) != DEV_TAPE)\r\n    return SCPE_OK;\r\nreturn sim_add_debug_flags (dptr, tape_debug);\r\n}\r\n\r\nt_stat sim_tape_init (void)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_bool p7b_parity_inited = FALSE;\r\nstatic uint8 p7b_odd_parity[64];\r\nstatic uint8 p7b_even_parity[64];\r\n\r\nstatic t_stat sim_tape_test_create_tape_files (UNIT *uptr, const char *filename, int files, int records, int max_size)\r\n{\r\nFILE *fSIMH = NULL;\r\nFILE *fE11 = NULL;\r\nFILE *fTPC = NULL;\r\nFILE *fP7B = NULL;\r\nFILE *fAWS = NULL;\r\nFILE *fAWS2 = NULL;\r\nFILE *fAWS3 = NULL;\r\nFILE *fTAR = NULL;\r\nFILE *fTAR2 = NULL;\r\nFILE *fBIN = NULL;\r\nFILE *fTXT = NULL;\r\nFILE *fVAR = NULL;\r\nint i, j, k;\r\nt_tpclnt tpclnt;\r\nt_mtrlnt mtrlnt;\r\nt_awslnt awslnt;\r\nt_awslnt awslnt_last = 0;\r\nt_awslnt awsrec_typ = AWS_REC;\r\nchar name[256];\r\nt_stat stat = SCPE_OPENERR;\r\nuint8 *buf = NULL, zpad = 0;\r\nt_stat aws_stat = MTSE_UNATT;\r\nint32 saved_switches = sim_switches;\r\n\r\nconst char hello_world[] =      /* FORTRAN IV text data file */\r\n\"      WRITE (6,7)                                                       HELLO001\\r\\n\"\r\n\"    7 FORMAT(14H HELLO, WORLD!)                                         HELLO002\\r\\n\"\r\n\"      STOP                                                              HELLO003\\r\\n\"\r\n\"      END                                                               HELLO004\\r\\n\";\r\n\r\nsrand (0);                      /* All devices use the same random sequence for binary data */\r\nif (max_size == 0)\r\n    max_size = MAX_RECORD_SIZE;\r\nif (!p7b_parity_inited) {\r\n    for (i=0; i < 64; i++) {\r\n        int bit_count = 0;\r\n\r\n        for (j=0; j<6; j++) {\r\n            if (i & (1 << j))\r\n                ++bit_count;\r\n            }\r\n        p7b_odd_parity[i] = i | ((~bit_count & 1) << 6);\r\n        p7b_even_parity[i] = i | ((bit_count & 1) << 6);\r\n        }\r\n    p7b_parity_inited = TRUE;\r\n    }\r\nbuf = (uint8 *)malloc (65536);\r\nif (buf == NULL)\r\n    return SCPE_MEM;\r\nsprintf (name, \"%s.simh\", filename);\r\nfSIMH = fopen (name, \"wb\");\r\nif (fSIMH  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.e11\", filename);\r\nfE11 = fopen (name, \"wb\");\r\nif (fE11  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.tpc\", filename);\r\nfTPC = fopen (name, \"wb\");\r\nif (fTPC  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.p7b\", filename);\r\nfP7B = fopen (name, \"wb\");\r\nif (fP7B  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.tar\", filename);\r\nfTAR = fopen (name, \"wb\");\r\nif (fTAR  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.2.tar\", filename);\r\nfTAR2 = fopen (name, \"wb\");\r\nif (fTAR2  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.aws\", filename);\r\nfAWS = fopen (name, \"wb\");\r\nif (fAWS  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.2.aws\", filename);\r\nfAWS2 = fopen (name, \"wb\");\r\nif (fAWS2  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.3.aws\", filename);\r\nfAWS3 = fopen (name, \"wb\");\r\nif (fAWS3  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.bin.fixed\", filename);\r\nfBIN = fopen (name, \"wb\");\r\nif (fBIN  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.txt.fixed\", filename);\r\nfTXT = fopen (name, \"wb\");\r\nif (fTXT  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"%s.txt.ansi-var\", filename);\r\nfVAR = fopen (name, \"wb\");\r\nif (fVAR  == NULL)\r\n    goto Done_Files;\r\nsprintf (name, \"aws %s.aws.tape\", filename);\r\nsim_switches = SWMASK ('F') | (sim_switches & SWMASK ('D')) | SWMASK ('N');\r\nif (sim_switches & SWMASK ('D'))\r\n    uptr->dctrl = MTSE_DBG_STR | MTSE_DBG_DAT;\r\naws_stat = sim_tape_attach_ex (uptr, name, (saved_switches & SWMASK ('D')) ? MTSE_DBG_STR | MTSE_DBG_DAT: 0, 0);\r\nif (aws_stat != MTSE_OK) {\r\n    stat = aws_stat;\r\n    goto Done_Files;\r\n    }\r\nsim_switches = saved_switches;\r\nstat = SCPE_OK;\r\nfor (i=0; i<files; i++) {\r\n    int rec_size = 1 + (rand () % max_size);\r\n\r\n    awslnt = mtrlnt = tpclnt = rec_size;\r\n    for (j=0; j<records; j++) {\r\n        awsrec_typ = AWS_REC;\r\n        if (sim_switches & SWMASK ('V'))\r\n            sim_printf (\"Writing %d byte record\\n\", rec_size);\r\n        for (k=0; k<rec_size; k++)\r\n            buf[k] = rand () & 0xFF;\r\n        (void)sim_fwrite (&mtrlnt,       sizeof (mtrlnt),       1, fSIMH);\r\n        (void)sim_fwrite (&mtrlnt,       sizeof (mtrlnt),       1, fE11);\r\n        (void)sim_fwrite (&tpclnt,       sizeof (tpclnt),       1, fTPC);\r\n        (void)sim_fwrite (&awslnt,       sizeof (awslnt),       1, fAWS);\r\n        (void)sim_fwrite (&awslnt_last,  sizeof (awslnt_last),  1, fAWS);\r\n        (void)sim_fwrite (&awsrec_typ,   sizeof (awsrec_typ),   1, fAWS);\r\n        if (i == 0) {\r\n            (void)sim_fwrite (&awslnt,       sizeof (awslnt),       1, fAWS3);\r\n            (void)sim_fwrite (&awslnt_last,  sizeof (awslnt_last),  1, fAWS3);\r\n            (void)sim_fwrite (&awsrec_typ,   sizeof (awsrec_typ),   1, fAWS3);\r\n            }\r\n        awslnt_last = awslnt;\r\n        (void)sim_fwrite (buf, 1, rec_size, fSIMH);\r\n        (void)sim_fwrite (buf, 1, rec_size, fE11);\r\n        (void)sim_fwrite (buf, 1, rec_size, fTPC);\r\n        (void)sim_fwrite (buf, 1, rec_size, fAWS);\r\n        if (i == 0)\r\n            (void)sim_fwrite (buf, 1, rec_size, fAWS3);\r\n        stat = sim_tape_wrrecf (uptr, buf, rec_size);\r\n        if (MTSE_OK != stat)\r\n            goto Done_Files;\r\n        if (rec_size & 1) {\r\n            (void)sim_fwrite (&zpad, 1, 1, fSIMH);\r\n            (void)sim_fwrite (&zpad, 1, 1, fTPC);\r\n            }\r\n        (void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fSIMH);\r\n        (void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fE11);\r\n        for (k=0; k<rec_size; k++)\r\n            buf[k] = p7b_odd_parity[buf[k] & 0x3F]; /* Only 6 data bits plus parity */\r\n        buf[0] |= P7B_SOR;\r\n        (void)sim_fwrite (buf, 1, rec_size, fP7B);\r\n        }\r\n    awslnt_last = awslnt;\r\n    mtrlnt = tpclnt = awslnt = 0;\r\n    awsrec_typ = AWS_TMK;\r\n    (void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fSIMH);\r\n    (void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fE11);\r\n    (void)sim_fwrite (&tpclnt, sizeof (tpclnt), 1, fTPC);\r\n    buf[0] = P7B_SOR | P7B_EOF;\r\n    (void)sim_fwrite (buf, 1, 1, fP7B);\r\n    (void)sim_fwrite (&awslnt,       sizeof (awslnt),       1, fAWS);\r\n    (void)sim_fwrite (&awslnt_last,  sizeof (awslnt_last),  1, fAWS);\r\n    (void)sim_fwrite (&awsrec_typ,   sizeof (awsrec_typ),   1, fAWS);\r\n    if (i == 0) {\r\n        (void)sim_fwrite (&awslnt,       sizeof (awslnt),       1, fAWS3);\r\n        (void)sim_fwrite (&awslnt_last,  sizeof (awslnt_last),  1, fAWS3);\r\n        (void)sim_fwrite (&awsrec_typ,   sizeof (awsrec_typ),   1, fAWS3);\r\n        }\r\n    awslnt_last = 0;\r\n    stat = sim_tape_wrtmk (uptr);\r\n    if (MTSE_OK != stat)\r\n        goto Done_Files;\r\n    if (i == 0) {\r\n        mtrlnt = MTR_GAP;\r\n        for (j=0; j<rec_size; j++)\r\n            (void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fSIMH);\r\n        mtrlnt = 0;\r\n        }\r\n    }\r\nmtrlnt = tpclnt = 0;\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fSIMH);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fE11);\r\n(void)sim_fwrite (&tpclnt, sizeof (tpclnt), 1, fTPC);\r\nawslnt_last = awslnt;\r\nawsrec_typ = AWS_TMK;\r\n(void)sim_fwrite (&awslnt,       sizeof (awslnt),       1, fAWS);\r\n(void)sim_fwrite (&awslnt_last,  sizeof (awslnt_last),  1, fAWS);\r\n(void)sim_fwrite (&awsrec_typ,   sizeof (awsrec_typ),   1, fAWS);\r\nmtrlnt = 0xffffffff;\r\ntpclnt = 0xffff;\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fSIMH);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fE11);\r\n(void)sim_fwrite (&tpclnt, sizeof (tpclnt), 1, fTPC);\r\n(void)sim_fwrite (buf, 1, 1, fP7B);\r\n/* Write an unmatched record delimiter (aka garbage) at\r\n   the end of the SIMH, E11 and AWS files */\r\nmtrlnt = 25;\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fSIMH);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fE11);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fAWS);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fAWS);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, fAWS);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, uptr->fileref);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, uptr->fileref);\r\n(void)sim_fwrite (&mtrlnt, sizeof (mtrlnt), 1, uptr->fileref);\r\nfor (j=0; j<records; j++) {\r\n    memset (buf, j, 10240);\r\n    (void)sim_fwrite (buf, 1, 10240, fTAR);\r\n    (void)sim_fwrite (buf, 1, 10240, fTAR2);\r\n    (void)sim_fwrite (buf, 1, 10240, fBIN);\r\n    }\r\nmemset (buf, j, 10240);\r\n(void)sim_fwrite (buf, 1, 5120, fTAR2);\r\nfor (j=0; j<3; j++) {\r\n    awslnt_last = awslnt = 0;\r\n    awsrec_typ = AWS_TMK;\r\n    (void)sim_fwrite (&awslnt,       sizeof (awslnt),       1, fAWS2);\r\n    (void)sim_fwrite (&awslnt_last,  sizeof (awslnt_last),  1, fAWS2);\r\n    (void)sim_fwrite (&awsrec_typ,   sizeof (awsrec_typ),   1, fAWS2);\r\n    }\r\n(void)sim_fwrite (hello_world, 1, strlen(hello_world), fTXT);\r\n(void)sim_fwrite (hello_world, 1, strlen(hello_world), fVAR);\r\nDone_Files:\r\nif (fSIMH)\r\n    fclose (fSIMH);\r\nif (fE11)\r\n    fclose (fE11);\r\nif (fTPC)\r\n    fclose (fTPC);\r\nif (fP7B)\r\n    fclose (fP7B);\r\nif (fAWS)\r\n    fclose (fAWS);\r\nif (fAWS2)\r\n    fclose (fAWS2);\r\nif (fAWS3)\r\n    fclose (fAWS3);\r\nif (fTAR)\r\n    fclose (fTAR);\r\nif (fTAR2)\r\n    fclose (fTAR2);\r\nif (fBIN)\r\n    fclose (fBIN);\r\nif (fTXT)\r\n    fclose (fTXT);\r\nif (fVAR)\r\n    fclose (fVAR);\r\nfree (buf);\r\nif (aws_stat == MTSE_OK)\r\n    sim_tape_detach (uptr);\r\nif (stat == SCPE_OK) {\r\n    char name1[CBUFSIZE], name2[CBUFSIZE];\r\n\r\n    sprintf (name1, \"\\\"%s.aws\\\"\", filename);\r\n    sprintf (name2, \"\\\"%s.aws.tape\\\"\", filename);\r\n    sim_switches = SWMASK ('F');\r\n    if (sim_cmp_string (name1, name2))\r\n        stat = 1;\r\n    }\r\nsim_switches = saved_switches;\r\nreturn stat;\r\n}\r\n\r\nstatic t_stat sim_tape_test_process_tape_file (UNIT *uptr, const char *filename, const char *format, t_awslnt recsize)\r\n{\r\nchar args[256];\r\nchar str_recsize[16] = \"\";\r\nt_stat stat;\r\n\r\nif (recsize) {\r\n    sim_switches |= SWMASK ('B');\r\n    sprintf (str_recsize, \" %d\", (int)recsize);\r\n    }\r\nif (NULL == strchr (filename, '*'))\r\n    sprintf (args, \"%s%s %s.%s\", format, str_recsize, filename, format);\r\nelse\r\n    sprintf (args, \"%s%s %s\", format, str_recsize, filename);\r\nsim_tape_detach (uptr);\r\nsim_switches |= SWMASK ('F') | SWMASK ('L');    /* specific-format and detailed record report */\r\nstat = sim_tape_attach_ex (uptr, args, 0, 0);\r\nif (stat != SCPE_OK)\r\n    return stat;\r\nsim_tape_detach (uptr);\r\nsim_switches = 0;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_tape_test_remove_tape_files (UNIT *uptr, const char *filename)\r\n{\r\nchar name[256];\r\n\r\nsprintf (name, \"%s.simh\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.2.simh\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.e11\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.2.e11\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.tpc\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.2.tpc\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.p7b\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.2.p7b\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.aws\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.2.aws\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.3.aws\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.tar\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.2.tar\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.bin.fixed\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.txt.fixed\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.txt.ansi-var\", filename);\r\n(void)remove (name);\r\nsprintf (name, \"%s.aws.tape\", filename);\r\n(void)remove (name);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_tape_test_density_string (void)\r\n{\r\nchar buf[128];\r\nint32 valid_bits = 0;\r\nt_stat stat;\r\n\r\nif ((SCPE_ARG != (stat = sim_tape_density_supported (buf, sizeof (buf), valid_bits))) ||\r\n    (strcmp (buf, \"\")))\r\n    return stat;\r\nvalid_bits = MT_556_VALID;\r\nif ((SCPE_OK != (stat = sim_tape_density_supported (buf, sizeof (buf), valid_bits))) ||\r\n    (strcmp (buf, \"556\")))\r\n    return sim_messagef (SCPE_ARG, \"stat was: %s, got string: %s\\n\", sim_error_text (stat), buf);\r\nvalid_bits = MT_800_VALID | MT_1600_VALID;\r\nif ((SCPE_OK != (stat = sim_tape_density_supported (buf, sizeof (buf), valid_bits))) ||\r\n    (strcmp (buf, \"{800|1600}\")))\r\n    return sim_messagef (SCPE_ARG, \"stat was: %s, got string: %s\\n\", sim_error_text (stat), buf);\r\nvalid_bits = MT_800_VALID | MT_1600_VALID | MT_6250_VALID;\r\nif ((SCPE_OK != (stat = sim_tape_density_supported (buf, sizeof (buf), valid_bits))) ||\r\n    (strcmp (buf, \"{800|1600|6250}\")))\r\n    return sim_messagef (SCPE_ARG, \"stat was: %s, got string: %s\\n\", sim_error_text (stat), buf);\r\nvalid_bits = MT_200_VALID | MT_800_VALID | MT_1600_VALID | MT_6250_VALID;\r\nif ((SCPE_OK != (stat = sim_tape_density_supported (buf, sizeof (buf), valid_bits))) ||\r\n    (strcmp (buf, \"{200|800|1600|6250}\")))\r\n    return sim_messagef (SCPE_ARG, \"stat was: %s, got string: %s\\n\", sim_error_text (stat), buf);\r\nvalid_bits = MT_NONE_VALID | MT_800_VALID | MT_1600_VALID | MT_6250_VALID;\r\nif ((SCPE_OK != (stat = sim_tape_density_supported (buf, sizeof (buf), valid_bits))) ||\r\n    (strcmp (buf, \"{0|800|1600|6250}\")))\r\n    return sim_messagef (SCPE_ARG, \"stat was: %s, got string: %s\\n\", sim_error_text (stat), buf);\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic struct classify_test {\r\n    const char *testname;\r\n    const char *testdata;\r\n    size_t expected_mrs;\r\n    t_bool expected_lf_lines;\r\n    t_bool expected_crlf_lines;\r\n    const char *success_attach_args;\r\n    const char *fail_attach_args;\r\n    } classify_tests[] = {\r\n        {\"TapeTest-Classify-80.txt\",\r\n         \"Now is the time for all good men to come to the aid of their country.~~~~~~~~~~~\\r\\n\",\r\n         80, FALSE, TRUE, \"-fb FIXED 80\"},\r\n        {\"TapeTest-Classify-80-lf.txt\",\r\n         \"Now is the time for all good men to come to the aid of their country.~~~~~~~~~~~\\n\",\r\n         80, TRUE, FALSE, \"-fb FIXED 80\"},\r\n        {\"TapeTest-Classify-508.txt\",\r\n         \"A really long line of text (512 - 4 = 508 characters) 64646464641281281281281281\"\r\n         \"28128128128128128128128128128128128128128128128125625625625625625625625625625625\"\r\n         \"62562562562562562562562562562562256256256256256256256256256256256256256256256256\"\r\n         \"25625625625625625125125125125125125125125125125125125125125125125125125125125125\"\r\n         \"51251251251251251251251251251251251251251251251251251251251251255125125125125125\"\r\n         \"12512512512512512512512512512512512512512512512551251251251251251251251251251251\"\r\n         \"2512512512512512512512512512\\r\\n\",\r\n         508, FALSE, TRUE, \"-fb FIXED 512\"},\r\n        {\"TapeTest-Classify-512.txt\",\r\n         \"A really long line of text (516 - 4 = 512 characters) 64646464641281281281281281\"\r\n         \"28128128128128128128128128128128128128128128128125625625625625625625625625625625\"\r\n         \"62562562562562562562562562562562256256256256256256256256256256256256256256256256\"\r\n         \"25625625625625625125125125125125125125125125125125125125125125125125125125125125\"\r\n         \"51251251251251251251251251251251251251251251251251251251251251255125125125125125\"\r\n         \"12512512512512512512512512512512512512512512512551251251251251251251251251251251\"\r\n         \"2512512512512512512512512512~~~~\\r\\n\",\r\n         512, FALSE, TRUE, \"-fb FIXED 512\", \"-fb ANSI-VMS 512\"},\r\n        {\"TapeTest-Classify-82.bin\",\r\n         \"Now is the time for all good men to come to the aid of their country.\\001\\002~~~~~~~~~\\r\\n\"\r\n         \"Now is the time for all good men to come to the aid of their country.\\001\\002~~~~~~~~~\\r\\n\",\r\n         512, FALSE, FALSE, \"-fb FIXED 82\"},\r\n        {NULL}\r\n    };\r\n\r\nstatic t_stat sim_tape_test_classify_file_contents (UNIT *uptr)\r\n{\r\nstruct classify_test *t;\r\nFILE *f;\r\nsize_t mrs;\r\nt_bool lf_lines;\r\nt_bool crlf_lines;\r\n\r\nfor (t = classify_tests; t->testname != NULL; t++) {\r\n    (void)remove (t->testname);\r\n    f = fopen (t->testname, \"wb+\");\r\n    if (f == NULL)\r\n        return sim_messagef (SCPE_ARG, \"Error creating test file '%s' - %s\\n\", t->testname, strerror (errno));\r\n    fprintf (f, \"%s\", t->testdata);\r\n    tape_classify_file_contents (f, &mrs, &lf_lines, &crlf_lines);\r\n    fclose (f);\r\n    if ((mrs != t->expected_mrs) || (lf_lines != t->expected_lf_lines) || (crlf_lines != t->expected_crlf_lines))\r\n        return sim_messagef (SCPE_ARG, \"%s was unexpectedly reported to having MRS=%d, lf_lines=%s, crlf_lines=%s\\n\",\r\n                                       t->testname, (int)mrs, lf_lines ? \"true\" : \"false\", crlf_lines ? \"true\" : \"false\");\r\n    if (t->success_attach_args) {\r\n        char args[CBUFSIZE*2];\r\n        t_stat r;\r\n\r\n        snprintf (args, sizeof (args), \"%s -v %s %s\", sim_uname (uptr), t->success_attach_args, t->testname);\r\n        r = attach_cmd (0, args);\r\n        if (r != SCPE_OK)\r\n            return sim_messagef (r, \"ATTACH %s failed\\n\", args);\r\n        detach_cmd (0, sim_uname (uptr));\r\n        }\r\n    if (t->fail_attach_args) {\r\n        char args[CBUFSIZE*2];\r\n        t_stat r;\r\n\r\n        snprintf (args, sizeof (args), \"%s -v %s %s\", sim_uname (uptr), t->fail_attach_args, t->testname);\r\n        r = attach_cmd (0, args);\r\n        if (r == SCPE_OK) {\r\n            detach_cmd (0, sim_uname (uptr));\r\n            return sim_messagef (r, \"** UNEXPECTED ATTACH SUCCESS ** %s\\n\", args);\r\n            }\r\n        }\r\n    (void)remove (t->testname);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_tape_test (DEVICE *dptr, const char *cptr)\r\n{\r\nint32 saved_switches = sim_switches;\r\nSIM_TEST_INIT;\r\n\r\nif (dptr->units->flags & UNIT_ATT)\r\n    return sim_messagef (SCPE_ALATT, \"The %s device must be detached to run the sim_tape library API tests.\\n\",\r\n                                     sim_uname(dptr->units));\r\n\r\nsim_printf (\"\\nTesting %s device sim_tape library APIs\\n\", sim_uname(dptr->units));\r\n\r\nSIM_TEST(sim_tape_test_density_string ());\r\n\r\nSIM_TEST(sim_tape_test_classify_file_contents (dptr->units));\r\n\r\nSIM_TEST(sim_tape_test_remove_tape_files (dptr->units, \"TapeTestFile1\"));\r\n\r\nSIM_TEST(sim_tape_test_create_tape_files (dptr->units, \"TapeTestFile1\", 2, 5, 4096));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.bin\", \"fixed\", 2048));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.txt\", \"fixed\", 80));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.*\", \"dos11\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.*\", \"ansi-vms\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.*\", \"ansi-rsx11\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.*\", \"ansi-rt11\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.*\", \"ansi-rsts\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.txt\", \"ansi-var\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1\", \"tar\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.2\", \"tar\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1\", \"aws\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.2\", \"aws\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1.3\", \"aws\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1\", \"p7b\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1\", \"tpc\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1\", \"e11\", 0));\r\n\r\nsim_switches = saved_switches;\r\nSIM_TEST(sim_tape_test_process_tape_file (dptr->units, \"TapeTestFile1\", \"simh\", 0));\r\n\r\nsim_switches = saved_switches;\r\nif ((sim_switches & SWMASK ('D')) == 0)\r\n    SIM_TEST(sim_tape_test_remove_tape_files (dptr->units, \"TapeTestFile1\"));\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic void ansi_date (time_t datetime, char date[6], t_bool y2k_date_bug)\r\n    {\r\n    struct tm *lt;\r\n    char buf[20];\r\n\r\n    lt = localtime (&datetime);\r\n    if (y2k_date_bug)\r\n        sprintf (buf, \" %c%c%03d\", '0' + (lt->tm_year / 10),\r\n                                   '0' + (lt->tm_year % 10),\r\n                                   lt->tm_yday + 1);\r\n    else\r\n        sprintf (buf, \"%c%02d%03d\", (lt->tm_year < 100) ? ' ' : '0' + (lt->tm_year/100 - 1),\r\n                                    lt->tm_year % 100,\r\n                                    lt->tm_yday + 1);\r\n    memcpy (date, buf, 6);\r\n    }\r\n\r\n/*\r\n * This isn't quite ANSI 'a' since several ANSI allowed characters\r\n * are either illegal file names on many DEC systems or are confusing\r\n * to OS file name parsers.\r\n */\r\nstatic void to_ansi_a (char *out, const char *in, size_t size)\r\n    {\r\n    memset (out, ' ', size);\r\n    while (size--) {\r\n        if (isupper (*in) || isdigit (*in))\r\n            *(out++) = *in++;\r\n        else {\r\n            if (*in == '\\0')\r\n                break;\r\n            if (islower (*in)) {\r\n                *(out++) = toupper (*in);\r\n                ++in;\r\n                }\r\n            else {\r\n                if (strchr (\"-.$_/\", *in))\r\n                    *(out++) = *in++;\r\n                else\r\n                    ++in;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\nstatic void ansi_make_VOL1 (VOL1 *vol, const char *ident, uint32 ansi_type)\r\n    {\r\n    memset (vol, ' ', sizeof (*vol));\r\n    memcpy (vol->type, \"VOL\", 3);\r\n    vol->num = '1';\r\n    to_ansi_a (vol->ident, ident, sizeof (vol->ident));\r\n    vol->standard = ansi_args[ansi_type].vol1_standard;\r\n    }\r\n\r\nstatic void ansi_make_HDR1 (HDR1 *hdr1, VOL1 *vol, HDR4 *hdr4, const char *filename, uint32 ansi_type)\r\n    {\r\n    const char *fn;\r\n    struct stat statb;\r\n    char extra_name_used[3] = \"00\";\r\n    char *fn_cpy, *c, *ext;\r\n\r\n    memset (&statb, 0, sizeof (statb));\r\n    (void)stat (filename, &statb);\r\n    if (!(fn = strrchr (filename, '/')) && !(fn = strrchr (filename, '\\\\')))\r\n        fn = filename;\r\n    else\r\n        ++fn;                                   /* skip over slash or backslash */\r\n    fn_cpy = (char *)malloc (strlen (fn) + 1);\r\n    strcpy (fn_cpy, fn);\r\n    fn = fn_cpy;\r\n    ext = strrchr (fn_cpy, '.');\r\n    if (ext) {\r\n        while (((c = strchr (fn_cpy, '.')) != NULL) &&\r\n               (c != ext))\r\n            *c = '_';                              /* translate extra .'s to _ */\r\n        }\r\n    memset (hdr1, ' ', sizeof (*hdr1));\r\n    memcpy (hdr1->type, \"HDR\", 3);\r\n    hdr1->num = '1';\r\n    memset (hdr4, ' ', sizeof (*hdr1));\r\n    memcpy (hdr4->type, \"HDR\", 3);\r\n    hdr4->num = '4';\r\n    to_ansi_a (hdr1->file_ident, fn, sizeof (hdr1->file_ident));\r\n    if (strlen (fn) > sizeof (hdr1->file_ident)) {\r\n        to_ansi_a (hdr4->extra_name, fn + sizeof (hdr1->file_ident), sizeof (hdr4->extra_name));\r\n        snprintf (extra_name_used, sizeof (extra_name_used), \"%02d\", (int)(MIN((strlen (fn) - sizeof (hdr1->file_ident)), sizeof (hdr4->extra_name))));\r\n        }\r\n    memcpy (hdr4->extra_name_used, extra_name_used, 2);\r\n    memcpy (hdr1->file_set, vol->ident, sizeof (hdr1->file_set));\r\n    memcpy (hdr1->file_section, \"0001\", 4);\r\n    memcpy (hdr1->file_sequence, \"0001\", 4);\r\n    memcpy (hdr1->generation_number, \"0001\", 4);    /* generation_number and version_number */\r\n    memcpy (hdr1->version_number, \"00\", 2);         /* combine to produce VMS version # ;1 here */\r\n    ansi_date (statb.st_mtime, hdr1->creation_date, ansi_args[ansi_type].y2k_date_bug);\r\n    memcpy (hdr1->expiration_date, \" 00000\", 6);\r\n    memcpy (hdr1->block_count, \"000000\", 6);\r\n    to_ansi_a (hdr1->system_code, ansi_args[ansi_type].system_code, sizeof (hdr1->system_code));\r\n    free (fn_cpy);\r\n    }\r\n\r\nstatic void ansi_make_HDR2 (HDR2 *hdr, t_bool fixed_record, size_t block_size, size_t record_size, uint32 ansi_type)\r\n    {\r\n    char size[12];\r\n    struct ansi_tape_parameters *ansi = &ansi_args[ansi_type];\r\n\r\n    memset (hdr, ' ', sizeof (*hdr));\r\n    memcpy (hdr->type, \"HDR\", 3);\r\n    hdr->num = '2';\r\n    hdr->record_format = ansi->record_format ? ansi->record_format : (fixed_record ? 'F' : 'D');\r\n    sprintf (size, \"%05d\", (int)block_size);\r\n    memcpy (hdr->block_length, size, sizeof (hdr->block_length));\r\n    sprintf (size, \"%05d\", (ansi->zero_record_length) ? 0 : (int)record_size);\r\n    memcpy (hdr->record_length, size, sizeof (hdr->record_length));\r\n    hdr->carriage_control = ansi->carriage_control ? ansi->carriage_control : (fixed_record ? 'M' : ' ');\r\n    memcpy (hdr->buffer_offset, \"00\", 2);\r\n    }\r\n\r\nstatic void ansi_fill_text_buffer (FILE *f, char *buf, size_t buf_size, size_t record_skip_ending, t_bool fixed_text)\r\n    {\r\n    long start;\r\n    char *tmp = (char *)calloc (2 + buf_size, sizeof (*buf));\r\n    size_t offset = 0;\r\n\r\n    while (1) {\r\n        size_t rec_size;\r\n        char rec_size_str[16];\r\n\r\n        start = ftell (f);\r\n        if (start < 0)\r\n            break;\r\n        if (!fgets (tmp, (int)buf_size, f))\r\n            break;\r\n        rec_size = strlen (tmp);\r\n        if (!fixed_text) {\r\n            if (rec_size >= record_skip_ending)\r\n                rec_size -= record_skip_ending;\r\n            if ((rec_size + 4) > (buf_size - offset)) { /* room for record? */\r\n                (void)fseek (f, start, SEEK_SET);\r\n                break;\r\n                }\r\n            sprintf (rec_size_str, \"%04u\", (int)(rec_size + 4));\r\n            memcpy (buf + offset, rec_size_str, 4);\r\n            memcpy (buf + offset + 4, tmp, rec_size);\r\n            offset += 4 + rec_size;\r\n            }\r\n        else {\r\n            size_t move_size;\r\n\r\n            if ((tmp[rec_size - 2] != '\\r') &&\r\n                (tmp[rec_size - 1] == '\\n')) {\r\n                memcpy (&tmp[rec_size - 1], \"\\r\\n\", 3);\r\n                rec_size += 1;\r\n                }\r\n            if (offset + rec_size < buf_size)\r\n                move_size = rec_size;\r\n            else\r\n                move_size = buf_size - offset;\r\n            /* We've got a line that straddles a block boundary */\r\n            memcpy (buf + offset, tmp, move_size);\r\n            offset += move_size;\r\n            if (offset == buf_size) {\r\n                (void)fseek (f, start + move_size, SEEK_SET);\r\n                break;\r\n                }\r\n            }\r\n        }\r\n    if (buf_size > offset) {\r\n        if (fixed_text)\r\n            memset (buf + offset, 0, buf_size - offset);\r\n        else\r\n            memset (buf + offset, '^', buf_size - offset);\r\n        }\r\n    free (tmp);\r\n    }\r\n\r\nstatic t_bool memory_tape_add_block (MEMORY_TAPE *tape, uint8 *block, uint32 size)\r\n{\r\nTAPE_RECORD *rec;\r\n\r\nASSURE((size == 0) == (block == NULL));\r\n\r\nif (tape->array_size <= tape->record_count) {\r\n    TAPE_RECORD **new_records;\r\n    new_records = (TAPE_RECORD **)realloc (tape->records, (tape->array_size + 1000) * sizeof (*tape->records));\r\n    if (new_records == NULL)\r\n        return TRUE;                /* no memory error */\r\n    tape->records = new_records;\r\n    memset (tape->records + tape->array_size, 0, 1000 * sizeof (*tape->records));\r\n    tape->array_size += 1000;\r\n    }\r\nrec = (TAPE_RECORD *)malloc (sizeof (*rec) + size);\r\nif (rec == NULL)\r\n    return TRUE;                    /* no memory error */\r\nrec->size = size;\r\nmemcpy (rec->data, block, size);\r\ntape->records[tape->record_count++] = rec;\r\nreturn FALSE;\r\n}\r\n\r\nstatic void memory_free_tape (void *vtape)\r\n{\r\nuint32 i;\r\nMEMORY_TAPE *tape = (MEMORY_TAPE *)vtape;\r\n\r\nif (tape == NULL)\r\n    return;\r\nfor (i = 0; i < tape->record_count; i++) {\r\n    free (tape->records[i]);\r\n    tape->records[i] = NULL;\r\n    }\r\nfree (tape->records);\r\nfree (tape);\r\n}\r\n\r\nMEMORY_TAPE *memory_create_tape (void)\r\n{\r\nMEMORY_TAPE *tape = (MEMORY_TAPE *)calloc (1, sizeof (*tape));\r\n\r\nif (NULL == tape)\r\n    return tape;\r\ntape->ansi_type = -1;\r\nreturn tape;\r\n}\r\n\r\nstatic const char rad50[] = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ%.%0123456789\";\r\n\r\nstatic uint16 dos11_ascR50(char *inbuf)\r\n{\r\nuint16 value;\r\n\r\nvalue = (strchr (rad50, *inbuf++) - rad50) * 03100;\r\nvalue += (strchr (rad50, *inbuf++) - rad50) * 050;\r\nvalue += (strchr (rad50, *inbuf++) - rad50);\r\n\r\nreturn value;\r\n}\r\n\r\n/*\r\n * Sanitize a filename to generate a DOS-11 compatible version. Ignore\r\n * non-alphanumerics, upper case lower case characters and terminate on '.'\r\n */\r\nstatic void dos11_sanitize(char *buf, int len, const char *inbuf)\r\n{\r\n    while ((len != 0) && (*inbuf != '\\0') && (*inbuf !='.')) {\r\n    char ch = toupper (*inbuf++);\r\n\r\n    if (isalnum(ch)) {\r\n        *buf++ = ch;\r\n        len--;\r\n        }\r\n    }\r\n}\r\n\r\nstatic int dos11_copy_ascii_file (FILE *f, MEMORY_TAPE *tape, char *buf, size_t bufSize)\r\n{\r\nchar ch, tmp[512];\r\nt_bool crlast = FALSE;\r\nint error = 0;\r\nsize_t i, data_read, offset = 0;\r\n\r\nwhile (!feof (f) && !error) {\r\n    data_read = fread (tmp, 1, sizeof (tmp), f);\r\n    if (data_read > 0)\r\n        for (i = 0; i < data_read; i++) {\r\n            ch = tmp[i];\r\n            if (ch == '\\n') {\r\n                if (!crlast) {\r\n                    buf[offset++] = '\\r';\r\n                    if (offset == bufSize) {\r\n                        error = memory_tape_add_block (tape, (uint8 *)buf, bufSize);\r\n                        offset = 0;\r\n                        }\r\n                    }\r\n                buf[offset++] = ch;\r\n                if (offset == bufSize) {\r\n                    error = memory_tape_add_block (tape, (uint8 *)buf, bufSize);\r\n                    offset = 0;\r\n                    }\r\n                crlast = FALSE;\r\n                }\r\n            else {\r\n                crlast = ch == '\\r';\r\n\r\n                buf[offset++] = ch;\r\n                if (offset == bufSize) {\r\n                    error = memory_tape_add_block (tape, (uint8 *)buf, bufSize);\r\n                    offset = 0;\r\n                    }\r\n                }\r\n            }\r\n    }\r\n    if (offset > 0) {\r\n        /* RSTS COPY to a DOS volume pads the last block with zeros     */\r\n        /* VMS EXCHANGE COPY /RECORD_FORMAT=STREAM and RSX-11 FLX /FA   */\r\n        /* output to a DOS volume do not                                */\r\n        /* DOS-11 ignores NULs in ASCII data transfer modes             */\r\n        memset (buf + offset, 0, bufSize - offset);\r\n        error = memory_tape_add_block (tape, (uint8 *)buf, bufSize);\r\n        }\r\n\r\nreturn error;\r\n}\r\n\r\nstatic void sim_tape_add_dos11_entry (const char *directory,\r\n                                      const char *filename,\r\n                                      t_offset FileSize,\r\n                                      const struct stat *filestat,\r\n                                      void *context)\r\n{\r\nMEMORY_TAPE *tape = (MEMORY_TAPE *)context;\r\nchar FullPath[PATH_MAX + 1];\r\nFILE *f;\r\nsize_t max_record_size;\r\nt_bool lf_line_endings;\r\nt_bool crlf_line_endings;\r\nuint8 *block = NULL;\r\nint error = 0;\r\nDOS11_HDR hdr;\r\nchar fname[9], ext[3];\r\nconst char *ptr;\r\nstruct tm *tm;\r\ntime_t filetime;\r\nuint16 fileday;\r\nint year;\r\n\r\n/*\r\n * Compute a suitable year for file creation date. This year will have the\r\n * same calendar as the current year but will be in the 20th century so that\r\n * DOS/BATCH-11 will be able to interpret it correctly.\r\n */\r\nfiletime = (time_t)filestat->st_ctime;\r\ntm = localtime (&filetime);\r\nyear = tm->tm_year + 1900;\r\nwhile (year >= 2000)\r\n    year -= 28;\r\n\r\nfileday = 1000 * ((year - 70) % 100) + tm->tm_yday + 1;\r\n\r\nsprintf (FullPath, \"%s%s\", directory, filename);\r\nf = tape_open_and_check_file (FullPath);\r\n if (f == NULL)\r\n    return;\r\n\r\ntape_classify_file_contents (f, &max_record_size, &lf_line_endings, &crlf_line_endings);\r\n\r\nmemset (&hdr, 0, sizeof (hdr));\r\nmemset (fname, ' ', sizeof (fname));\r\nmemset (ext, ' ', sizeof (ext));\r\n\r\ndos11_sanitize (fname, sizeof (fname), filename);\r\nptr = strchr (filename, '.');\r\nif (ptr != NULL)\r\n    dos11_sanitize (ext, sizeof (ext), ++ptr);\r\n\r\n/*\r\n * If we were unable to generate a valid DOS11 filename, generate one based\r\n * on the file number on the tape (000000 - 999999).\r\n */\r\nif (fname[0] == ' ') {\r\n  char temp[10];\r\n\r\n  sprintf(temp, \"%06u   \", tape->file_count % 100000);\r\n  memcpy(fname, temp, sizeof(fname));\r\n}\r\n\r\nhdr.fname[0] = dos11_ascR50 (&fname[0]);\r\nhdr.fname[1] = dos11_ascR50 (&fname[3]);\r\nhdr.ext = dos11_ascR50 (&ext[0]);\r\nhdr.prog = 1;\r\nhdr.proj = 1;\r\nhdr.prot = DOS11_PROT;\r\nhdr.date = fileday;\r\nhdr.fname3 = dos11_ascR50 (&fname[6]);\r\n\r\nmemory_tape_add_block (tape, (uint8 *)&hdr, sizeof (hdr));\r\n\r\nrewind (f);\r\nblock = (uint8 *)calloc (tape->block_size, 1);\r\n\r\nif (lf_line_endings || crlf_line_endings)\r\n    error = dos11_copy_ascii_file (f, tape, (char *)block, tape->block_size);\r\nelse {\r\n    size_t data_read;\r\n\r\n    while (!feof (f) && !error) {\r\n        data_read = fread (block, 1, tape->block_size, f);\r\n        if (data_read > 0)\r\n            error = memory_tape_add_block (tape, block, data_read);\r\n        }\r\n    }\r\n\r\nfclose (f);\r\nfree (block);\r\nif (error)\r\n    sim_messagef (SCPE_IERR, \"Error processing input file %s\\n\", FullPath);\r\nmemory_tape_add_block (tape, NULL, 0); /* Tape Mark */\r\n++tape->file_count;\r\n}\r\n\r\nstatic FILE *tape_open_and_check_file (const char *filename)\r\n{\r\nFILE *file = fopen(filename, \"rb\");\r\n\r\nif (file != NULL) {\r\n    struct stat statb;\r\n\r\n    memset (&statb, 0, sizeof (statb));\r\n    if (fstat (fileno (file), &statb) == 0) {\r\n        if (((S_IFDIR | S_IFREG) & statb.st_mode) == S_IFREG)\r\n            return file;\r\n\r\n        sim_printf (\"Can't put a %s on tape: %s\\n\",\r\n                    statb.st_mode & S_IFREG ? \"directory\" : \"non regular file\",\r\n                    filename);\r\n        fclose (file);\r\n        return NULL;\r\n        }\r\n    sim_printf (\"Can't stat: %s\\n\", filename);\r\n    fclose (file);\r\n    return NULL;\r\n    }\r\nsim_printf (\"Can't open: %s - %s\\n\", filename, strerror (errno));\r\nreturn NULL;\r\n}\r\n\r\nstatic int tape_classify_file_contents (FILE *f, size_t *max_record_size, t_bool *lf_line_endings, t_bool *crlf_line_endings)\r\n{\r\nlong pos = -1;\r\nlong last_cr = -1;\r\nlong line_start = 0;\r\nint chr;\r\nt_bool non_print_chars = FALSE;\r\nlong lf_lines = 0;\r\nlong crlf_lines = 0;\r\n\r\n*max_record_size = 0;\r\n*lf_line_endings = FALSE;\r\n*crlf_line_endings = FALSE;\r\nrewind (f);\r\nwhile (EOF != (chr = fgetc (f))) {\r\n    ++pos;\r\n    if (!isprint (chr) && (chr != '\\r') && (chr != '\\n') && (chr != '\\t') && (chr != '\\f')) {\r\n        non_print_chars = TRUE;\r\n        break;\r\n        }\r\n    if (chr == '\\r')\r\n        last_cr = pos;\r\n    if (chr == '\\n') {\r\n        long line_size;\r\n\r\n        if (last_cr == (pos - 1)) {\r\n            ++crlf_lines;\r\n            line_size = pos - line_start - 1;\r\n            }\r\n        else {\r\n            ++lf_lines;\r\n            line_size = pos - line_start;\r\n            }\r\n        if (line_size > (long)(*max_record_size))\r\n            *max_record_size = line_size;\r\n        line_start = pos + 1;\r\n        }\r\n    }\r\nrewind (f);\r\n\r\n/* Binary file */\r\n\r\nif (non_print_chars)\r\n    *max_record_size = 512;\r\n\r\n/* Text file */\r\n\r\nelse {\r\n    if ((crlf_lines > 0) && (lf_lines == 0)) {\r\n        *lf_line_endings = FALSE;\r\n        *crlf_line_endings = TRUE;\r\n        }\r\n    else {\r\n        if ((lf_lines > 0) && (crlf_lines == 0)) {\r\n            *lf_line_endings = TRUE;\r\n            *crlf_line_endings = FALSE;\r\n            }\r\n        }\r\n    }\r\nreturn 0;\r\n}\r\n\r\nMEMORY_TAPE *ansi_create_tape (const char *label, uint32 block_size, uint32 ansi_type)\r\n{\r\nMEMORY_TAPE *tape = memory_create_tape ();\r\n\r\nif (NULL == tape)\r\n    return tape;\r\ntape->block_size = block_size;\r\ntape->ansi_type = ansi_type;\r\nansi_make_VOL1 (&tape->vol1, label, ansi_type);\r\nmemory_tape_add_block (tape, (uint8 *)&tape->vol1, sizeof (tape->vol1));\r\nreturn tape;\r\n}\r\n\r\nstatic int ansi_add_file_to_tape (MEMORY_TAPE *tape, const char *filename)\r\n{\r\nFILE *f;\r\nstruct ansi_tape_parameters *ansi = &ansi_args[tape->ansi_type];\r\nuint8 *block = NULL;\r\nsize_t rms_record_size, max_record_size;\r\nt_bool lf_line_endings, crlf_line_endings;\r\nchar file_sequence[5];\r\nint block_count = 0;\r\nchar block_count_string[17];\r\nint error = FALSE;\r\nHDR1 hdr1;\r\nHDR2 hdr2;\r\nHDR3 hdr3;\r\nHDR4 hdr4;\r\n\r\nf = tape_open_and_check_file (filename);\r\nif (f == NULL)\r\n    return TRUE;\r\n\r\ntape_classify_file_contents (f, &rms_record_size, &lf_line_endings, &crlf_line_endings);\r\nif (!lf_line_endings && !crlf_line_endings) {           /* Binary File? */\r\n    if (ansi->record_format == 'D') {                   /* ANSI format forces 'D' Record Format? */\r\n        sim_messagef (SCPE_ARG, \"%s format does not support binary files\\n\", ansi->name);\r\n        fclose (f);\r\n        return TRUE;\r\n        }\r\n    max_record_size = rms_record_size;\r\n    }\r\nelse {                                                  /* Text file */\r\n    if (ansi->fixed_text) {\r\n        /* ANSI-RT11 and ANSI-RSTS text files are unformatted, i.e., a stream of bytes */\r\n        max_record_size = rms_record_size = 512;\r\n        /* max_record_size must fit */\r\n        ASSURE((tape->block_size == 512));              /* ANSI-RT11 and ANSI-RSTS are forced to use -B 512, above */\r\n        }\r\n    else {\r\n        /* All other ANSI formats use D Record Format */\r\n        /* Add the 4-character ANSI RCW and the length of the line endings to rms_record_size */\r\n        max_record_size = 4 + rms_record_size +\r\n                          (crlf_line_endings ? 2 - ansi->skip_crlf_line_endings :\r\n                                               1 - ansi->skip_lf_line_endings);\r\n        /* max_record_size must fit in the 4-character ANSI RCW */\r\n        if (max_record_size > 9999) {\r\n            size_t max_allowed = 9999 - 4 -\r\n                                 (crlf_line_endings ? 2 - ansi->skip_crlf_line_endings :\r\n                                                      1 - ansi->skip_lf_line_endings);\r\n            sim_messagef (SCPE_ARG, \"Text file: %s has lines longer (%d) than %s format allows (%d)\\n\",\r\n                                    filename, (int)rms_record_size, ansi->name, (int)max_allowed);\r\n            fclose (f);\r\n            return TRUE;\r\n            }\r\n        }\r\n    }\r\n/* max_record_size must be no greater than the block size */\r\nif (max_record_size > tape->block_size) {\r\n    sim_messagef (SCPE_ARG, \"%s file: %s requires a minimum block size of %d\\n\",\r\n                            (lf_line_endings || crlf_line_endings) ? \"Text\" : \"Binary\", filename, (int)max_record_size);\r\n    fclose (f);\r\n    return TRUE;\r\n    }\r\nansi_make_HDR1 (&hdr1, &tape->vol1, &hdr4, filename, tape->ansi_type);\r\nsprintf (file_sequence, \"%04d\", 1 + tape->file_count);\r\nmemcpy (hdr1.file_sequence, file_sequence, sizeof (hdr1.file_sequence));\r\nansi_make_HDR2 (&hdr2, !lf_line_endings && !crlf_line_endings, tape->block_size, max_record_size, tape->ansi_type);\r\n\r\nif (!(ansi->nohdr3)) {               /* Need HDR3? */\r\n    char size[5];\r\n    if (!lf_line_endings && !crlf_line_endings)         /* Binary File? */\r\n        memcpy (&hdr3, ansi->hdr3_fixed, sizeof (hdr3));\r\n    else {                                              /* Text file */\r\n        if (lf_line_endings && !(ansi->fixed_text))\r\n            memcpy (&hdr3, ansi->hdr3_lf_line_endings, sizeof (hdr3));\r\n        else\r\n            memcpy (&hdr3, ansi->hdr3_crlf_line_endings, sizeof (hdr3));\r\n        }\r\n    sprintf (size, \"%04x\", (uint16)rms_record_size);\r\n    memcpy (hdr3.rms_attributes, size, 4);\r\n    }\r\nmemory_tape_add_block (tape, (uint8 *)&hdr1, sizeof (hdr1));\r\nif (!(ansi->nohdr2))\r\n    memory_tape_add_block (tape, (uint8 *)&hdr2, sizeof (hdr2));\r\nif (!(ansi->nohdr3))\r\n    memory_tape_add_block (tape, (uint8 *)&hdr3, sizeof (hdr3));\r\nif ((0 != memcmp (hdr4.extra_name_used, \"00\", 2)) && !(ansi->nohdr3) && !(ansi->nohdr2))\r\n    memory_tape_add_block (tape, (uint8 *)&hdr4, sizeof (hdr4));\r\nmemory_tape_add_block (tape, NULL, 0);        /* Tape Mark */\r\nrewind (f);\r\nblock = (uint8 *)calloc (tape->block_size, 1);\r\nwhile (!feof (f) && !error) {\r\n    size_t data_read = tape->block_size;\r\n\r\n    if (lf_line_endings || crlf_line_endings)           /* Text file? */\r\n        ansi_fill_text_buffer (f, (char *)block, tape->block_size,\r\n                               crlf_line_endings ? ansi->skip_crlf_line_endings : ansi->skip_lf_line_endings,\r\n                               ansi->fixed_text);\r\n\r\n    else {                                              /* Binary file */\r\n        size_t runt = 0;\r\n\r\n        data_read = fread (block, 1, tape->block_size, f);\r\n        if (max_record_size > 0)                /* always will be true but Xcode thinks otherwise */\r\n            runt = data_read % max_record_size; /* data_read (=0) % anypositivenumber == 0 */\r\n        /* Pad short records with zeros */\r\n        if (runt > 0) {\r\n            size_t nPad = max_record_size - runt;\r\n            memset (block + data_read, 0, nPad);\r\n            data_read += nPad;\r\n            }\r\n        }\r\n\r\n    if (data_read > 0) {\r\n        error = memory_tape_add_block (tape, block, data_read);\r\n        if (!error)\r\n            ++block_count;\r\n        }\r\n    }\r\nfclose (f);\r\nfree (block);\r\nmemory_tape_add_block (tape, NULL, 0);        /* Tape Mark */\r\nmemcpy (hdr1.type, \"EOF\", sizeof (hdr1.type));\r\nmemcpy (hdr2.type, \"EOF\", sizeof (hdr2.type));\r\nmemcpy (hdr3.type, \"EOF\", sizeof (hdr3.type));\r\nmemcpy (hdr4.type, \"EOF\", sizeof (hdr4.type));\r\nsprintf (block_count_string, \"%06d\", block_count);\r\nmemcpy (hdr1.block_count, block_count_string, sizeof (hdr1.block_count));\r\nmemory_tape_add_block (tape, (uint8 *)&hdr1, sizeof (hdr1));\r\nif (!(ansi->nohdr2))\r\n    memory_tape_add_block (tape, (uint8 *)&hdr2, sizeof (hdr2));\r\nif (!(ansi->nohdr3))\r\n    memory_tape_add_block (tape, (uint8 *)&hdr3, sizeof (hdr3));\r\nif ((0 != memcmp (hdr4.extra_name_used, \"00\", 2)) && !(ansi->nohdr3) && !(ansi->nohdr2))\r\n    memory_tape_add_block (tape, (uint8 *)&hdr4, sizeof (hdr4));\r\nmemory_tape_add_block (tape, NULL, 0);        /* Tape Mark */\r\nif (sim_switches & SWMASK ('V'))\r\n    sim_messagef (SCPE_OK, \"%17.17s%62.62s\\n\\t%d blocks of data\\n\", hdr1.file_ident, hdr4.extra_name, block_count);\r\n++tape->file_count;\r\nreturn error;\r\n}\r\n\r\nstatic void sim_tape_add_ansi_entry (const char *directory,\r\n                                     const char *filename,\r\n                                     t_offset FileSize,\r\n                                     const struct stat *filestat,\r\n                                     void *context)\r\n{\r\nMEMORY_TAPE *tape = (MEMORY_TAPE *)context;\r\nchar FullPath[PATH_MAX + 1];\r\n\r\nsprintf (FullPath, \"%s%s\", directory, filename);\r\n\r\n(void)ansi_add_file_to_tape (tape, FullPath);\r\n}\r\n\r\n/* export an existing tape to a SIMH tape image */\r\nstatic t_stat sim_export_tape (UNIT *uptr, const char *export_file)\r\n{\r\nt_stat r;\r\nFILE *f;\r\nt_addr saved_pos = uptr->pos;\r\nuint8 *buf = NULL;\r\nt_mtrlnt bc, sbc;\r\nt_mtrlnt max = MTR_MAXLEN;\r\n\r\nif ((export_file == NULL) || (*export_file == '\\0'))\r\n    return sim_messagef (SCPE_ARG, \"Missing tape export file specification\\n\");\r\nf = fopen (export_file, \"wb\");\r\nif (f == NULL)\r\n    return sim_messagef (SCPE_OPENERR, \"Can't open SIMH tape image file: %s - %s\\n\", export_file, strerror (errno));\r\n\r\nbuf = (uint8 *)calloc (max, 1);\r\nif (buf == NULL) {\r\n    fclose (f);\r\n    return SCPE_MEM;\r\n    }\r\nr = sim_tape_rewind (uptr);\r\nwhile (r == SCPE_OK) {\r\n    r = sim_tape_rdrecf (uptr, buf, &bc, max);\r\n    switch (r) {\r\n        case MTSE_OK:\r\n            sbc = ((bc + 1) & ~1);              /* word alignment for SIMH format data */\r\n            if ((1   != sim_fwrite (&bc, sizeof (bc),   1, f)) ||\r\n                (sbc != sim_fwrite (buf, 1,           sbc, f))         ||\r\n                (1   != sim_fwrite (&bc, sizeof (bc),   1, f)))\r\n                r = sim_messagef (SCPE_IOERR, \"Error writing file: %s - %s\\n\", export_file, strerror (errno));\r\n            else\r\n                r = SCPE_OK;\r\n            break;\r\n\r\n        case MTSE_TMK:\r\n            bc = 0;\r\n            if (1 != sim_fwrite (&bc, sizeof (bc), 1, f))\r\n                r = sim_messagef (SCPE_IOERR, \"Error writing file: %s - %s\\n\", export_file, strerror (errno));\r\n            else\r\n                r = SCPE_OK;\r\n            break;\r\n\r\n        default:\r\n            break;\r\n        }\r\n    }\r\nif (r == MTSE_EOM)\r\n    r = SCPE_OK;\r\nfree (buf);\r\nfclose (f);\r\nuptr->pos = saved_pos;\r\nreturn r;\r\n}\r\n"
        },
        {
          "name": "sim_tape.h",
          "type": "blob",
          "size": 13.0546875,
          "content": "/* sim_tape.h: simulator tape support library definitions\r\n\r\n   Copyright (c) 1993-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   18-Jul-16    JDB     Added sim_tape_errecf, sim_tape_errecr functions\r\n   15-Dec-14    JDB     Added tape density validity flags\r\n   04-Nov-14    JDB     Added tape density flags\r\n   11-Oct-14    JDB     Added reverse read half gap, set/show density\r\n   22-Sep-14    JDB     Added tape runaway support\r\n   23-Jan-12    MP      Added support for Logical EOT detection while positioning\r\n   05-Feb-11    MP      Add Asynch I/O support\r\n   30-Aug-06    JDB     Added erase gap support\r\n   14-Feb-06    RMS     Added variable tape capacity\r\n   17-Dec-05    RMS     Added write support for Paul Pierce 7b format\r\n   02-May-05    RMS     Added support for Paul Pierce 7b format\r\n*/\r\n\r\n#ifndef SIM_TAPE_H_\r\n#define SIM_TAPE_H_    0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* SIMH/E11 tape format */\r\n\r\ntypedef uint32          t_mtrlnt;                       /* magtape rec lnt */\r\n\r\n#define MTR_TMK         0x00000000                      /* tape mark */\r\n#define MTR_EOM         0xFFFFFFFF                      /* end of medium */\r\n#define MTR_GAP         0xFFFFFFFE                      /* primary gap */\r\n#define MTR_RRGAP       0xFFFFFFFF                      /* reverse read half gap */\r\n#define MTR_FHGAP       0xFFFEFFFF                      /* fwd half gap (overwrite) */\r\n#define MTR_RHGAP       0xFFFF0000                      /* rev half gap (overwrite) */\r\n#define MTR_M_RHGAP     (~0x000080FF)                   /* range mask for rev gap */\r\n#define MTR_MAXLEN      0x00FFFFFF                      /* max len is 24b */\r\n#define MTR_ERF         0x80000000                      /* error flag */\r\n#define MTR_F(x)        ((x) & MTR_ERF)                 /* record error flg */\r\n#define MTR_L(x)        ((t_mtrlnt)((x) & ~MTR_ERF))    /* record length */\r\n\r\n/* TPC tape format */\r\n\r\ntypedef uint16          t_tpclnt;                       /* magtape rec lnt */\r\n\r\n#define TPC_TMK         0x0000                          /* tape mark */\r\n#define TPC_EOM         0xFFFF                          /* end of medium */\r\n\r\n\r\n/* P7B tape format */\r\n\r\n#define P7B_SOR         0x80                            /* start of record */\r\n#define P7B_PAR         0x40                            /* parity */\r\n#define P7B_DATA        0x3F                            /* data */\r\n#define P7B_DPAR        (P7B_PAR|P7B_DATA)              /* data and parity */\r\n#define P7B_EOF         0x0F                            /* eof character */\r\n\r\n/* AWS tape format */\r\n\r\ntypedef uint16          t_awslnt;                       /* magtape rec lnt */\r\ntypedef struct {\r\n    t_awslnt    nxtlen;\r\n    t_awslnt    prelen;\r\n    t_awslnt    rectyp;\r\n#define AWS_TMK         0x0040\r\n#define AWS_REC         0x00A0\r\n    } t_awshdr;\r\n\r\n/* TAR tape format */\r\n\r\n#define TAR_DFLT_RECSIZE     10240                      /* Default Fixed record size */\r\n\r\n/* Unit flags */\r\n\r\n#define MTUF_V_UF       (UNIT_V_UF + 0)\r\n#define MTUF_F_STD      0                               /* SIMH format */\r\n#define MTUF_F_E11      1                               /* E11 format */\r\n#define MTUF_F_TPC      2                               /* TPC format */\r\n#define MTUF_F_P7B      3                               /* P7B format */\r\n#define MTUF_F_AWS      4                               /* AWS format */\r\n#define MTUF_F_TAR      5                               /* TAR format */\r\n/* MT_GET_FMT() >= MTUF_F_ANSI is a MEMORY_TAPE image */\r\n#define MTUF_F_ANSI     6                               /* ANSI format */\r\n#define MTUF_F_FIXED    7                               /* FIXED format */\r\n#define MTUF_F_DOS11    8                               /* DOS11 format */\r\n\r\n#define MTAT_F_VMS      0                               /* VMS ANSI type */\r\n#define MTAT_F_RSX11    1                               /* RSX-11 ANSI type */\r\n#define MTAT_F_RT11     2                               /* RT-11 ANSI type */\r\n#define MTAT_F_RSTS     3                               /* RSTS ANSI type */\r\n#define MTAT_F_VAR      4                               /* RSTS VAR ANSI type */\r\n\r\n#define MTUF_WLK        UNIT_WLK\r\n#define MTUF_WRP        (MTUF_WLK | UNIT_RO)\r\n\r\n#define MT_SET_PNU(u)   (u)->dynflags |= UNIT_TAPE_PNU\r\n#define MT_CLR_PNU(u)   (u)->dynflags &= ~UNIT_TAPE_PNU\r\n#define MT_TST_PNU(u)   ((u)->dynflags & UNIT_TAPE_PNU)\r\n#define MT_SET_INMRK(u) (u)->dynflags = (u)->dynflags | UNIT_TAPE_MRK\r\n#define MT_CLR_INMRK(u) (u)->dynflags = (u)->dynflags & ~UNIT_TAPE_MRK\r\n#define MT_TST_INMRK(u) ((u)->dynflags & UNIT_TAPE_MRK)\r\n#define MT_GET_FMT(u)   (((u)->dynflags >> UNIT_V_TAPE_FMT) & ((1 << UNIT_S_TAPE_FMT) - 1))\r\n#define MT_GET_ANSI_TYP(u)   (((u)->dynflags >> UNIT_V_TAPE_ANSI) & ((1 << UNIT_S_TAPE_ANSI) - 1))\r\n\r\n/* sim_tape_position Position Flags */\r\n\r\n#define MTPOS_V_REW     3\r\n#define MTPOS_M_REW     (1u << MTPOS_V_REW)            /* Rewind First */\r\n#define MTPOS_V_REV     2\r\n#define MTPOS_M_REV     (1u << MTPOS_V_REV)            /* Reverse Direction */\r\n#define MTPOS_V_OBJ     1\r\n#define MTPOS_M_OBJ     (1u << MTPOS_V_OBJ)            /* Objects vs Records/Files */\r\n#define MTPOS_V_DLE     4\r\n#define MTPOS_M_DLE     (1u << MTPOS_V_DLE)            /* Detect LEOT */\r\n\r\n/* Tape density values */\r\n\r\n#define MT_DENS_NONE    0                               /* density not set */\r\n#define MT_DENS_200     1                               /* 200 bpi NRZI */\r\n#define MT_DENS_556     2                               /* 556 bpi NRZI */\r\n#define MT_DENS_800     3                               /* 800 bpi NRZI */\r\n#define MT_DENS_1600    4                               /* 1600 bpi PE */\r\n#define MT_DENS_6250    5                               /* 6250 bpi GCR */\r\n\r\n#define MTVF_DENS_MASK  (((1u << UNIT_S_DF_TAPE) - 1) << UNIT_V_DF_TAPE)\r\n#define MT_DENS(f)      (((f) & MTVF_DENS_MASK) >> UNIT_V_DF_TAPE)\r\n\r\n#define MT_NONE_VALID   (1u << MT_DENS_NONE)            /* density not set is valid */\r\n#define MT_200_VALID    (1u << MT_DENS_200)             /* 200 bpi is valid */\r\n#define MT_556_VALID    (1u << MT_DENS_556)             /* 556 bpi is valid */\r\n#define MT_800_VALID    (1u << MT_DENS_800)             /* 800 bpi is valid */\r\n#define MT_1600_VALID   (1u << MT_DENS_1600)            /* 1600 bpi is valid */\r\n#define MT_6250_VALID   (1u << MT_DENS_6250)            /* 6250 bpi is valid */\r\n\r\n/* Return status codes */\r\n\r\n#define MTSE_OK         0                               /* no error */\r\n#define MTSE_TMK        1                               /* tape mark */\r\n#define MTSE_UNATT      2                               /* unattached */\r\n#define MTSE_IOERR      3                               /* IO error */\r\n#define MTSE_INVRL      4                               /* invalid rec lnt */\r\n#define MTSE_FMT        5                               /* invalid format */\r\n#define MTSE_BOT        6                               /* beginning of tape */\r\n#define MTSE_EOM        7                               /* end of medium */\r\n#define MTSE_RECE       8                               /* error in record */\r\n#define MTSE_WRP        9                               /* write protected */\r\n#define MTSE_LEOT       10                              /* Logical End Of Tape */\r\n#define MTSE_RUNAWAY    11                              /* tape runaway */\r\n#define MTSE_MAX_ERR    11\r\n\r\ntypedef void (*TAPE_PCALLBACK)(UNIT *unit, t_stat status);\r\n\r\n/* Tape Internal Debug flags */\r\n\r\n#define MTSE_DBG_API   0x10000000                       /* API Trace */\r\n#define MTSE_DBG_DAT   0x20000000                       /* Debug Data */\r\n#define MTSE_DBG_POS   0x40000000                       /* Debug Positioning activities */\r\n#define MTSE_DBG_STR   0x80000000                       /* Debug Tape Structure */\r\n\r\n/* Prototypes */\r\n\r\nt_stat sim_tape_init (void);\r\nt_stat sim_tape_attach_ex (UNIT *uptr, const char *cptr, uint32 dbit, int completion_delay);\r\nt_stat sim_tape_attach (UNIT *uptr, CONST char *cptr);\r\nt_stat sim_tape_detach (UNIT *uptr);\r\nt_stat sim_tape_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr);\r\nt_stat sim_tape_rdrecf (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max);\r\nt_stat sim_tape_rdrecf_a (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_rdrecr (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max);\r\nt_stat sim_tape_rdrecr_a (UNIT *uptr, uint8 *buf, t_mtrlnt *bc, t_mtrlnt max, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_wrrecf (UNIT *uptr, uint8 *buf, t_mtrlnt bc);\r\nt_stat sim_tape_wrrecf_a (UNIT *uptr, uint8 *buf, t_mtrlnt bc, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_wrtmk (UNIT *uptr);\r\nt_stat sim_tape_wrtmk_a (UNIT *uptr, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_wreom (UNIT *uptr);\r\nt_stat sim_tape_wreom_a (UNIT *uptr, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_wreomrw (UNIT *uptr);\r\nt_stat sim_tape_wreomrw_a (UNIT *uptr, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_wrgap (UNIT *uptr, uint32 gaplen);\r\nt_stat sim_tape_wrgap_a (UNIT *uptr, uint32 gaplen, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_errecf (UNIT *uptr, t_mtrlnt bc);\r\nt_stat sim_tape_errecr (UNIT *uptr, t_mtrlnt bc);\r\nt_stat sim_tape_sprecf (UNIT *uptr, t_mtrlnt *bc);\r\nt_stat sim_tape_sprecf_a (UNIT *uptr, t_mtrlnt *bc, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_sprecsf (UNIT *uptr, uint32 count, uint32 *skipped);\r\nt_stat sim_tape_sprecsf_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_spfilef (UNIT *uptr, uint32 count, uint32 *skipped);\r\nt_stat sim_tape_spfilef_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_spfilebyrecf (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped, t_bool check_leot);\r\nt_stat sim_tape_spfilebyrecf_a (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped, t_bool check_leot, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_sprecr (UNIT *uptr, t_mtrlnt *bc);\r\nt_stat sim_tape_sprecr_a (UNIT *uptr, t_mtrlnt *bc, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_sprecsr (UNIT *uptr, uint32 count, uint32 *skipped);\r\nt_stat sim_tape_sprecsr_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_spfiler (UNIT *uptr, uint32 count, uint32 *skipped);\r\nt_stat sim_tape_spfiler_a (UNIT *uptr, uint32 count, uint32 *skipped, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_spfilebyrecr (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped);\r\nt_stat sim_tape_spfilebyrecr_a (UNIT *uptr, uint32 count, uint32 *skipped, uint32 *recsskipped, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_rewind (UNIT *uptr);\r\nt_stat sim_tape_rewind_a (UNIT *uptr, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_position (UNIT *uptr, uint32 flags, uint32 recs, uint32 *recskipped, uint32 files, uint32 *fileskipped, uint32 *objectsskipped);\r\nt_stat sim_tape_position_a (UNIT *uptr, uint32 flags, uint32 recs, uint32 *recsskipped, uint32 files, uint32 *filesskipped, uint32 *objectsskipped, TAPE_PCALLBACK callback);\r\nt_stat sim_tape_reset (UNIT *uptr);\r\nt_bool sim_tape_bot (UNIT *uptr);\r\nt_bool sim_tape_wrp (UNIT *uptr);\r\nt_bool sim_tape_eot (UNIT *uptr);\r\nt_stat sim_tape_set_fmt (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_tape_show_fmt (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_tape_set_capac (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_tape_show_capac (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_tape_set_dens (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_tape_show_dens (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat sim_tape_density_supported (char *string, size_t string_size, int32 valid_bits);\r\nt_stat sim_tape_set_chunk_mode (UNIT *uptr, uint32 chunk_size);\r\nconst char *sim_tape_error_text (t_stat stat);\r\nt_stat sim_tape_set_asynch (UNIT *uptr, int latency);\r\nt_stat sim_tape_clr_asynch (UNIT *uptr);\r\nt_stat sim_tape_test (DEVICE *dptr, const char *cptr);\r\nt_stat sim_tape_add_debug (DEVICE *dptr);\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_timer.c",
          "type": "blob",
          "size": 160.166015625,
          "content": "/* sim_timer.c: simulator timer library\r\n\r\n   Copyright (c) 1993-2010, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   21-Oct-11    MP      Fixed throttling in several ways:\r\n                         - Sleep for the observed clock tick size while throttling\r\n                         - Recompute the throttling wait once every 10 seconds\r\n                           to account for varying instruction mixes during\r\n                           different phases of a simulator execution or to\r\n                           accommodate the presence of other load on the host\r\n                           system.\r\n                         - Each of the pre-existing throttling modes (Kcps,\r\n                           Mcps, and %) all compute the appropriate throttling\r\n                           interval dynamically.  These dynamic computations\r\n                           assume that 100% of the host CPU is dedicated to\r\n                           the current simulator during this computation.\r\n                           This assumption may not always be true and under\r\n                           certain conditions may never provide a way to\r\n                           correctly determine the appropriate throttling\r\n                           wait.  An additional throttling mode has been added\r\n                           which allows the simulator operator to explicitly\r\n                           state the desired throttling wait parameters.\r\n                           These are specified by:\r\n                                  SET THROT insts/delay\r\n                           where 'insts' is the number of instructions to\r\n                           execute before sleeping for 'delay' milliseconds.\r\n   22-Apr-11    MP      Fixed Asynch I/O support to reasonably account cycles\r\n                        when an idle wait is terminated by an external event\r\n   05-Jan-11    MP      Added Asynch I/O support\r\n   29-Dec-10    MP      Fixed clock resolution determination for Unix platforms\r\n   22-Sep-08    RMS     Added \"stability threshold\" for idle routine\r\n   27-May-08    RMS     Fixed bug in Linux idle routines (from Walter Mueller)\r\n   18-Jun-07    RMS     Modified idle to exclude counted delays\r\n   22-Mar-07    RMS     Added sim_rtcn_init_all\r\n   17-Oct-06    RMS     Added idle support (based on work by Mark Pizzolato)\r\n                        Added throttle support\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   02-Jan-04    RMS     Split out from SCP\r\n\r\n   This library includes the following routines:\r\n\r\n   sim_timer_init -         initialize timing system\r\n   sim_rtc_init -           initialize calibration\r\n   sim_rtc_calb -           calibrate clock\r\n   sim_idle -               virtual machine idle\r\n   sim_os_msec  -           return elapsed time in msec\r\n   sim_os_sleep -           sleep specified number of seconds\r\n   sim_os_ms_sleep -        sleep specified number of milliseconds\r\n   sim_idle_ms_sleep -      sleep specified number of milliseconds\r\n                            or until awakened by an asynchronous\r\n                            event\r\n   sim_timespec_diff        subtract two timespec values\r\n   sim_timer_activate_after schedule unit for specific time\r\n   sim_timer_activate_time  determine activation time\r\n   sim_timer_activate_time_usecs determine activation time in usecs\r\n   sim_rom_read_with_delay  delay for default or specified delay\r\n   sim_get_rom_delay_factor get current or initialize 1usec delay factor\r\n   sim_set_rom_delay_factor set specific delay factor\r\n\r\n\r\n   The calibration, idle, and throttle routines are OS-independent; the _os_\r\n   routines are not.\r\n*/\r\n\r\n#define NOT_MUX_USING_CODE /* sim_tmxr library provider or agnostic */\r\n\r\n#include \"sim_defs.h\"\r\n\r\n#include \"sim_scp_private.h\"\r\n\r\n#define SIM_INTERNAL_CLK (SIM_NTIMERS+(1<<30))\r\n#define SIM_INTERNAL_UNIT sim_internal_timer_unit\r\n#ifndef MIN\r\n#define MIN(a,b)  (((a) < (b)) ? (a) : (b))\r\n#endif\r\n#ifndef MAX\r\n#define MAX(a,b)  (((a) > (b)) ? (a) : (b))\r\n#endif\r\n\r\nuint32 sim_idle_ms_sleep (unsigned int msec);\r\nstatic uint32 _sim_os_msec (void);\r\n\r\n/* MS_MIN_GRANULARITY exists here so that timing behavior for hosts systems  */\r\n/* with slow clock ticks can be assessed and tested without actually having  */\r\n/* that slow a clock tick on the development platform                        */\r\n//#define MS_MIN_GRANULARITY 20   /* Uncomment to simulate 20ms host tick size.*/\r\n                                /* some Solaris and BSD hosts come this way  */\r\n\r\n#if defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1)\r\nuint32 real_sim_idle_ms_sleep (unsigned int msec);\r\nuint32 real_sim_os_msec (void);\r\nuint32 real_sim_os_ms_sleep (unsigned int msec);\r\nstatic uint32 real_sim_os_sleep_min_ms = 0;\r\nstatic uint32 real_sim_os_sleep_inc_ms = 0;\r\n\r\nuint32 sim_idle_ms_sleep (unsigned int msec)\r\n{\r\nuint32 real_start = real_sim_os_msec ();\r\nuint32 start = (real_start / MS_MIN_GRANULARITY) * MS_MIN_GRANULARITY;\r\nuint32 tick_left;\r\n\r\nif (msec == 0)\r\n    return 0;\r\nif (real_start == start)\r\n    tick_left = 0;\r\nelse\r\n    tick_left = MS_MIN_GRANULARITY - (real_start - start);\r\nif (msec <= tick_left)\r\n    real_sim_idle_ms_sleep (tick_left);\r\nelse\r\n    real_sim_idle_ms_sleep (((msec + MS_MIN_GRANULARITY - 1) / MS_MIN_GRANULARITY) * MS_MIN_GRANULARITY);\r\n\r\nreturn (sim_os_msec () - start);\r\n}\r\n\r\nstatic uint32 _sim_os_msec (void)\r\n{\r\nreturn (real_sim_os_msec ()/MS_MIN_GRANULARITY)*MS_MIN_GRANULARITY;\r\n}\r\n\r\nuint32 sim_os_ms_sleep (unsigned int msec)\r\n{\r\nmsec = MS_MIN_GRANULARITY*((msec+MS_MIN_GRANULARITY-1)/MS_MIN_GRANULARITY);\r\n\r\nreturn real_sim_os_ms_sleep (msec);\r\n}\r\n\r\n#endif /* defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1) */\r\n\r\nt_bool sim_idle_enab = FALSE;                       /* global flag */\r\nvolatile t_bool sim_idle_wait = FALSE;              /* global flag */\r\n\r\nuint32 sim_vm_initial_ips = SIM_INITIAL_IPS;\r\n\r\nstatic uint32 sim_precalibrate_ips = SIM_INITIAL_IPS;\r\nstatic int32 sim_calb_tmr = -1;                     /* the system calibrated timer */\r\nstatic int32 sim_calb_tmr_last = -1;                /* shadow value when at sim> prompt */\r\nstatic double sim_inst_per_sec_last = 0;            /* shadow value when at sim> prompt */\r\nstatic uint32 sim_stop_time = 0;                    /* time when sim_stop_timer_services was called */\r\ndouble sim_time_at_sim_prompt =  0.0;               /* time spent processing commands from sim> prompt */\r\n\r\nstatic uint32 sim_idle_rate_ms = 0;                 /* Minimum Sleep time */\r\nstatic uint32 sim_os_sleep_min_ms = 0;\r\nstatic uint32 sim_os_sleep_inc_ms = 0;\r\nstatic uint32 sim_os_clock_resoluton_ms = 0;\r\nstatic uint32 sim_os_tick_hz = 0;\r\nstatic uint32 sim_idle_stable = SIM_IDLE_STDFLT;\r\nstatic uint32 sim_idle_calib_pct = 100;\r\nstatic double sim_timer_stop_time = 0;\r\nstatic uint32 sim_rom_delay = 0;\r\nstatic uint32 sim_throt_ms_start = 0;\r\nstatic uint32 sim_throt_ms_stop = 0;\r\nstatic uint32 sim_throt_type = 0;\r\nstatic uint32 sim_throt_val = 0;\r\nstatic uint32 sim_throt_drift_pct = SIM_THROT_DRIFT_PCT_DFLT;\r\nstatic uint32 sim_throt_state = SIM_THROT_STATE_INIT;\r\nstatic double sim_throt_cps;\r\nstatic double sim_throt_peak_cps;\r\nstatic double sim_throt_inst_start;\r\nstatic uint32 sim_throt_sleep_time = 0;\r\nstatic int32 sim_throt_wait = 0;\r\nstatic uint32 sim_throt_delay = 3;\r\n#define CLK_TPS 100\r\n#define CLK_INIT (sim_precalibrate_ips/CLK_TPS)\r\nstatic int32 sim_int_clk_tps;\r\nstatic t_bool sim_timer_calib_enabled = TRUE;\r\nstatic struct timespec sim_timer_uncalib_base_time = {0, 0};\r\nstatic t_bool sim_throttle_has_been_active = FALSE;\r\n\r\ntypedef struct RTC {\r\n    UNIT *clock_unit;               /* registered ticking clock unit */\r\n    UNIT *timer_unit;               /* points to related clock assist unit (sim_timer_units) */\r\n    UNIT *clock_cosched_queue;\r\n    int32 cosched_interval;\r\n    uint32 ticks;                   /* ticks */\r\n    uint32 hz;                      /* tick rate */\r\n    uint32 last_hz;                 /* prior tick rate */\r\n    uint32 rtime;                   /* real time (usecs) */\r\n    uint32 vtime;                   /* virtual time (usecs) */\r\n    double gtime;                   /* instruction time */\r\n    uint32 nxintv;                  /* next interval */\r\n    int32 based;                    /* base delay */\r\n    int32 currd;                    /* current delay */\r\n    int32 initd;                    /* initial delay */\r\n    uint32 elapsed;                 /* seconds since init */\r\n    uint32 calibrations;            /* calibration count */\r\n    double clock_skew_max;          /* asynchronous max skew */\r\n    double clock_tick_size;         /* 1/hz */\r\n    uint32 calib_initializations;   /* Initialization Count */\r\n    double calib_tick_time;         /* ticks time */\r\n    double calib_tick_time_tot;     /* ticks time - total*/\r\n    uint32 calib_ticks_acked;       /* ticks Acked */\r\n    uint32 calib_ticks_acked_tot;   /* ticks Acked - total */\r\n    uint32 clock_ticks;             /* ticks delivered since catchup base */\r\n    uint32 clock_ticks_tot;         /* ticks delivered since catchup base - total */\r\n    double clock_init_base_time;    /* reference time for clock initialization */\r\n    double clock_tick_start_time;   /* reference time when ticking started */\r\n    double clock_catchup_base_time; /* reference time for catchup ticks */\r\n    uint32 clock_catchup_ticks;     /* Record of catchups */\r\n    uint32 clock_catchup_ticks_tot; /* Record of catchups - total */\r\n    uint32 clock_catchup_ticks_curr;/* Record of catchups in this second */\r\n    t_bool clock_catchup_pending;   /* clock tick catchup pending */\r\n    t_bool clock_catchup_eligible;  /* clock tick catchup eligible */\r\n    uint32 clock_time_idled;        /* total time idled */\r\n    uint32 clock_time_idled_last;   /* total time idled as of the previous second */\r\n    uint32 clock_calib_skip_idle;   /* Calibrations skipped due to idling */\r\n    uint32 clock_calib_gap2big;     /* Calibrations skipped Gap Too Big */\r\n    uint32 clock_calib_backwards;   /* Calibrations skipped Clock Running Backwards */\r\n    } RTC;\r\n\r\nRTC rtcs[SIM_NTIMERS+1];\r\nUNIT sim_timer_units[SIM_NTIMERS+1];/* Clock assist units                         */\r\n                                    /* one for each timer and one for an internal */\r\n                                    /* clock if no clocks are registered.         */\r\n\r\n\r\nstatic t_bool sim_catchup_ticks = TRUE;\r\n#if defined (SIM_ASYNCH_CLOCKS) && !defined (SIM_ASYNCH_IO)\r\n#undef SIM_ASYNCH_CLOCKS\r\n#endif\r\nt_bool sim_asynch_timer = FALSE;\r\n\r\n\r\n#if defined (SIM_ASYNCH_CLOCKS)\r\nUNIT * volatile sim_wallclock_queue = QUEUE_LIST_END;\r\nUNIT * volatile sim_wallclock_entry = NULL;\r\n#endif\r\n\r\n/* Forward Declarations */\r\n\r\nt_stat sim_timer_set_async (int32 flag, CONST char *cptr);\r\nt_stat sim_timer_set_catchup (int32 flag, CONST char *cptr);\r\nt_stat sim_timer_set_calib (int32 flag, CONST char *cptr);\r\nt_stat sim_timer_set_stop (int32 flag, CONST char *cptr);\r\nt_stat sim_timer_set_uncalib_base (int32 flag, CONST char *cptr);\r\n\r\n\r\nuint32 sim_os_msec (void)\r\n{\r\nif (sim_timer_calib_enabled)\r\n    return _sim_os_msec ();\r\nreturn (uint32)((1000.0 * sim_gtime ()) / sim_precalibrate_ips);\r\n}\r\n\r\n#define sleep1Samples       100\r\n\r\nstatic uint32 _compute_minimum_sleep (void)\r\n{\r\nuint32 i, tot, tim;\r\n\r\nsim_os_set_thread_priority (PRIORITY_ABOVE_NORMAL);\r\n#if defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1)\r\nreal_sim_idle_ms_sleep (2);         /* Start sampling on a tick boundary */\r\nfor (i = 0, tot = 0; i < sleep1Samples; i++)\r\n    tot += real_sim_idle_ms_sleep (1);\r\ntim = tot / sleep1Samples;          /* Truncated average */\r\nreal_sim_os_sleep_min_ms = tim;\r\nreal_sim_idle_ms_sleep (2);         /* Start sampling on a tick boundary */\r\nfor (i = 0, tot = 0; i < sleep1Samples; i++)\r\n    tot += real_sim_idle_ms_sleep (real_sim_os_sleep_min_ms + 1);\r\ntim = tot / sleep1Samples;          /* Truncated average */\r\nreal_sim_os_sleep_inc_ms = tim - real_sim_os_sleep_min_ms;\r\n#endif /* defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1) */\r\nsim_idle_ms_sleep (2);              /* Start sampling on a tick boundary */\r\nfor (i = 0, tot = 0; i < sleep1Samples; i++)\r\n    tot += sim_idle_ms_sleep (1);\r\ntim = tot / sleep1Samples;          /* Truncated average */\r\nsim_os_sleep_min_ms = tim;\r\nsim_idle_ms_sleep (2);              /* Start sampling on a tick boundary */\r\nfor (i = 0, tot = 0; i < sleep1Samples; i++)\r\n    tot += sim_idle_ms_sleep (sim_os_sleep_min_ms + 1);\r\ntim = tot / sleep1Samples;          /* Truncated average */\r\nsim_os_sleep_inc_ms = tim - sim_os_sleep_min_ms;\r\nsim_os_set_thread_priority (PRIORITY_NORMAL);\r\nreturn sim_os_sleep_min_ms;\r\n}\r\n\r\n#if defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1)\r\n\r\n#define sim_idle_ms_sleep   real_sim_idle_ms_sleep\r\n#define sim_os_msec         real_sim_os_msec\r\n#define sim_os_ms_sleep     real_sim_os_ms_sleep\r\n\r\n#endif /* defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1) */\r\n\r\n#if defined(SIM_ASYNCH_IO)\r\nuint32 sim_idle_ms_sleep (unsigned int msec)\r\n{\r\nstruct timespec start_time, end_time, done_time, delta_time;\r\nuint32 delta_ms;\r\nt_bool timedout = FALSE;\r\n\r\nclock_gettime(CLOCK_REALTIME, &start_time);\r\nend_time = start_time;\r\nend_time.tv_sec += (msec/1000);\r\nend_time.tv_nsec += 1000000*(msec%1000);\r\nif (end_time.tv_nsec >= 1000000000) {\r\n  end_time.tv_sec += end_time.tv_nsec/1000000000;\r\n  end_time.tv_nsec = end_time.tv_nsec%1000000000;\r\n  }\r\npthread_mutex_lock (&sim_asynch_lock);\r\nsim_idle_wait = TRUE;\r\nif (pthread_cond_timedwait (&sim_asynch_wake, &sim_asynch_lock, &end_time))\r\n    timedout = TRUE;\r\nsim_idle_wait = FALSE;\r\npthread_mutex_unlock (&sim_asynch_lock);\r\nif (!timedout)\r\n    sim_asynch_check = 0;                 /* force check of asynch queue now */\r\nclock_gettime(CLOCK_REALTIME, &done_time);\r\nif (!timedout) {\r\n    AIO_UPDATE_QUEUE;\r\n    }\r\nsim_timespec_diff (&delta_time, &done_time, &start_time);\r\ndelta_ms = (uint32)((delta_time.tv_sec * 1000) + ((delta_time.tv_nsec + 500000) / 1000000));\r\nreturn delta_ms;\r\n}\r\n#else\r\nuint32 sim_idle_ms_sleep (unsigned int msec)\r\n{\r\nreturn sim_os_ms_sleep (msec);\r\n}\r\n#endif\r\n\r\n/* Mark the need for the sim_os_set_thread_priority routine, */\r\n/* allowing the feature and/or platform dependent code to provide it */\r\n#define NEED_THREAD_PRIORITY\r\n\r\n/* If we've got pthreads support then use pthreads mechanisms */\r\n#if defined(USE_READER_THREAD)\r\n\r\n#undef NEED_THREAD_PRIORITY\r\n\r\n#if defined(_WIN32)\r\n/* On Windows there are several potentially disjoint threading APIs */\r\n/* in use (base win32 pthreads, libSDL provided threading, and direct */\r\n/* calls to beginthreadex), so go directly to the Win32 threading APIs */\r\n/* to manage thread priority */\r\nt_stat sim_os_set_thread_priority (int below_normal_above)\r\n{\r\nconst static int val[3] = {THREAD_PRIORITY_BELOW_NORMAL, THREAD_PRIORITY_NORMAL, THREAD_PRIORITY_ABOVE_NORMAL};\r\n\r\nif ((below_normal_above < -1) || (below_normal_above > 1))\r\n    return SCPE_ARG;\r\nSetThreadPriority (GetCurrentThread(), val[1 + below_normal_above]);\r\nreturn SCPE_OK;\r\n}\r\n#else\r\n/* Native pthreads priority implementation */\r\nt_stat sim_os_set_thread_priority (int below_normal_above)\r\n{\r\nint sched_policy, min_prio, max_prio;\r\nstruct sched_param sched_priority;\r\n\r\nif ((below_normal_above < -1) || (below_normal_above > 1))\r\n    return SCPE_ARG;\r\n\r\npthread_getschedparam (pthread_self(), &sched_policy, &sched_priority);\r\nmin_prio = sched_get_priority_min(sched_policy);\r\nmax_prio = sched_get_priority_max(sched_policy);\r\nswitch (below_normal_above) {\r\n    case PRIORITY_BELOW_NORMAL:\r\n        sched_priority.sched_priority = min_prio;\r\n        break;\r\n    case PRIORITY_NORMAL:\r\n        sched_priority.sched_priority = (max_prio + min_prio) / 2;\r\n        break;\r\n    case PRIORITY_ABOVE_NORMAL:\r\n        sched_priority.sched_priority = max_prio;\r\n        break;\r\n    }\r\npthread_setschedparam (pthread_self(), sched_policy, &sched_priority);\r\nreturn SCPE_OK;\r\n}\r\n#endif\r\n#endif  /* defined(USE_READER_THREAD) */\r\n\r\n/* OS-dependent timer and clock routines */\r\n\r\n/* VMS */\r\n\r\n#if defined (VMS)\r\n\r\n#if defined (__VAX)\r\n#define sys$gettim SYS$GETTIM\r\n#define sys$setimr SYS$SETIMR\r\n#define lib$emul LIB$EMUL\r\n#define sys$waitfr SYS$WAITFR\r\n#define lib$subx LIB$SUBX\r\n#define lib$ediv LIB$EDIV\r\n#define sys$getjpiw SYS$GETJPIW\r\n#endif\r\n\r\n#include <starlet.h>\r\n#include <jpidef.h>\r\n#include <lib$routines.h>\r\n#include <unistd.h>\r\n\r\nconst t_bool rtc_avail = TRUE;\r\n\r\nstatic uint32 _sim_os_msec (void)\r\n{\r\nuint32 quo, htod, tod[2];\r\nint32 i;\r\n\r\nsys$gettim (tod);                                       /* time 0.1usec */\r\n\r\n/* To convert to msec, must divide a 64b quantity by 10000.  This is actually done\r\n   by dividing the 96b quantity 0'time by 10000, producing 64b of quotient, the\r\n   high 32b of which are discarded.  This can probably be done by a clever multiply...\r\n*/\r\n\r\nquo = htod = 0;\r\nfor (i = 0; i < 64; i++) {                              /* 64b quo */\r\n    htod = (htod << 1) | ((tod[1] >> 31) & 1);          /* shift divd */\r\n    tod[1] = (tod[1] << 1) | ((tod[0] >> 31) & 1);\r\n    tod[0] = tod[0] << 1;\r\n    quo = quo << 1;                                     /* shift quo */\r\n    if (htod >= 10000) {                                /* divd work? */\r\n        htod = htod - 10000;                            /* subtract */\r\n        quo = quo | 1;                                  /* set quo bit */\r\n        }\r\n    }\r\nreturn quo;\r\n}\r\n\r\nvoid sim_os_sleep (unsigned int sec)\r\n{\r\nsleep (sec);\r\n}\r\n\r\nuint32 sim_os_ms_sleep_init (void)\r\n{\r\nreturn _compute_minimum_sleep ();\r\n}\r\n\r\nuint32 sim_os_ms_sleep (unsigned int msec)\r\n{\r\nuint32 stime = sim_os_msec ();\r\nuint32 qtime[2];\r\nint32 nsfactor = -10000;\r\nstatic int32 zero = 0;\r\n\r\nlib$emul (&msec, &nsfactor, &zero, qtime);\r\nsys$setimr (2, qtime, 0, 0);\r\nsys$waitfr (2);\r\nreturn sim_os_msec () - stime;\r\n}\r\n\r\n#ifdef NEED_CLOCK_GETTIME\r\nint clock_gettime(int clk_id, struct timespec *tp)\r\n{\r\nuint32 secs, ns, tod[2], unixbase[2] = {0xd53e8000, 0x019db1de};\r\n\r\nif (clk_id != CLOCK_REALTIME)\r\n  return -1;\r\n\r\nsys$gettim (tod);                                       /* time 0.1usec */\r\nlib$subx(tod, unixbase, tod);                           /* convert to unix base */\r\nlib$ediv(&10000000, tod, &secs, &ns);                   /* isolate seconds & 100ns parts */\r\ntp->tv_sec = secs;\r\ntp->tv_nsec = ns*100;\r\nreturn 0;\r\n}\r\n#endif /* CLOCK_REALTIME */\r\n\r\ntypedef struct {\r\n    unsigned short status;\r\n    unsigned short count;\r\n    unsigned int dev_status; } IOSB;\r\n\r\ntypedef struct {\r\n    unsigned short buffer_size;\r\n    unsigned short item_code;\r\n    void *buffer_address;\r\n    void *return_length_address;\r\n    } ITEM;\r\n\r\nt_stat sim_os_process_cpu_times (double *system, double *user)\r\n{\r\nt_uint64 CPUtime = 0;\r\nITEM items[] = { {sizeof (CPUtime), JPI$_CPUTIM, &CPUtime, NULL},\r\n                 {                0,             0,      NULL, NULL}};\r\nIOSB iosb;\r\n\r\nmemset (&iosb, 0, sizeof (iosb));\r\n\r\nsys$getjpiw (1, NULL, NULL, items, &iosb, NULL, 0);\r\n\r\n*system = 0.0;\r\n*user = (double)(CPUtime) / 100.0;\r\nreturn SCPE_OK;\r\n}\r\n\r\n#elif defined (_WIN32)\r\n\r\n/* Win32 routines */\r\n\r\nconst t_bool rtc_avail = TRUE;\r\n\r\nstatic uint32 _sim_os_msec (void)\r\n{\r\nreturn timeGetTime ();                      /* use Multi-Media time source */\r\n}\r\n\r\nvoid sim_os_sleep (unsigned int sec)\r\n{\r\nSleep (sec * 1000);\r\n}\r\n\r\nstatic TIMECAPS timers;\r\n\r\nvoid sim_timer_exit (void)\r\n{\r\ntimeEndPeriod (timers.wPeriodMin);\r\n}\r\n\r\nuint32 sim_os_ms_sleep_init (void)\r\n{\r\nMMRESULT mm_status;\r\n\r\nmm_status = timeGetDevCaps (&timers, sizeof (timers));\r\nif (mm_status != TIMERR_NOERROR) {\r\n    fprintf (stderr, \"timeGetDevCaps() returned: 0x%X, Last Error: 0x%X\\n\", mm_status, (unsigned int)GetLastError());\r\n    return 0;\r\n    }\r\nif (timers.wPeriodMin == 0) {\r\n    fprintf (stderr, \"Unreasonable MultiMedia timer minimum value of 0\\n\");\r\n    return 0;\r\n    }\r\nmm_status = timeBeginPeriod (timers.wPeriodMin);\r\nif (mm_status != TIMERR_NOERROR) {\r\n    fprintf (stderr, \"timeBeginPeriod() returned: 0x%X, Last Error: 0x%X\\n\", mm_status, (unsigned int)GetLastError());\r\n    return 0;\r\n    }\r\natexit (sim_timer_exit);\r\n/* return measured actual minimum sleep time */\r\nreturn _compute_minimum_sleep ();\r\n}\r\n\r\nuint32 sim_os_ms_sleep (unsigned int msec)\r\n{\r\nuint32 stime = sim_os_msec();\r\n\r\nSleep (msec);\r\nreturn sim_os_msec () - stime;\r\n}\r\n\r\n#if defined(NEED_CLOCK_GETTIME)\r\nint clock_gettime(int clk_id, struct timespec *tp)\r\n{\r\nt_uint64 now, unixbase;\r\n\r\nif (clk_id != CLOCK_REALTIME)\r\n    return -1;\r\nunixbase = 116444736;\r\nunixbase *= 1000000000;\r\nGetSystemTimeAsFileTime((FILETIME*)&now);\r\nnow -= unixbase;\r\ntp->tv_sec = (long)(now/10000000);\r\ntp->tv_nsec = (now%10000000)*100;\r\nreturn 0;\r\n}\r\n#endif\r\n\r\nt_stat sim_os_process_cpu_times (double *system, double *user)\r\n{\r\nt_uint64 ftCreation, ftExit, ftKernel, ftUser;\r\n\r\nGetProcessTimes (GetCurrentProcess(), (FILETIME *)&ftCreation, (FILETIME *)&ftExit, (FILETIME *)&ftKernel, (FILETIME *)&ftUser);\r\n*system = (double)(ftKernel / 10000000) + (((double)(ftKernel % 10000000)) / 10000000.0);\r\n*user = (double)(ftUser / 10000000) + (((double)(ftUser % 10000000)) / 10000000.0);\r\nreturn SCPE_OK;\r\n}\r\n\r\n#else\r\n\r\n/* UNIX routines */\r\n\r\n#include <time.h>\r\n#include <sys/time.h>\r\n#include <unistd.h>\r\n#define NANOS_PER_MILLI     1000000\r\n#define MILLIS_PER_SEC      1000\r\n\r\nconst t_bool rtc_avail = TRUE;\r\n\r\nstatic uint32 _sim_os_msec (void)\r\n{\r\nstruct timeval cur;\r\nstruct timezone foo;\r\nuint32 msec;\r\n\r\ngettimeofday (&cur, &foo);\r\nmsec = (((uint32) cur.tv_sec) * 1000) + (((uint32) cur.tv_usec) / 1000);\r\nreturn msec;\r\n}\r\n\r\nvoid sim_os_sleep (unsigned int sec)\r\n{\r\nsleep (sec);\r\n}\r\n\r\nuint32 sim_os_ms_sleep_init (void)\r\n{\r\nreturn _compute_minimum_sleep ();\r\n}\r\n\r\n#include <sys/time.h>\r\n#include <sys/resource.h>\r\n\r\nt_stat sim_os_process_cpu_times (double *system, double *user)\r\n{\r\nstruct rusage usage;\r\n\r\n*system = 0.0;\r\n*user = 0.0;\r\nif (0 == getrusage (RUSAGE_SELF, &usage)) {\r\n    *system = ((double)usage.ru_stime.tv_sec) + ((double)usage.ru_stime.tv_usec / 1000000.0);\r\n    *user =   ((double)usage.ru_utime.tv_sec) + ((double)usage.ru_utime.tv_usec / 1000000.0);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n#if !defined(_POSIX_SOURCE)\r\n#ifdef NEED_CLOCK_GETTIME\r\ntypedef int clockid_t;\r\nint clock_gettime(clockid_t clk_id, struct timespec *tp)\r\n{\r\nstruct timeval cur;\r\nstruct timezone foo;\r\n\r\nif (clk_id != CLOCK_REALTIME)\r\n  return -1;\r\ngettimeofday (&cur, &foo);\r\ntp->tv_sec = cur.tv_sec;\r\ntp->tv_nsec = cur.tv_usec*1000;\r\nreturn 0;\r\n}\r\n#endif /* CLOCK_REALTIME */\r\n#endif /* !defined(_POSIX_SOURCE) && defined(SIM_ASYNCH_IO) */\r\n\r\nuint32 sim_os_ms_sleep (unsigned int milliseconds)\r\n{\r\nuint32 stime = sim_os_msec ();\r\nstruct timespec treq;\r\n\r\ntreq.tv_sec = milliseconds / MILLIS_PER_SEC;\r\ntreq.tv_nsec = (milliseconds % MILLIS_PER_SEC) * NANOS_PER_MILLI;\r\n(void) nanosleep (&treq, NULL);\r\nreturn sim_os_msec () - stime;\r\n}\r\n\r\n#if defined(NEED_THREAD_PRIORITY)\r\n#undef NEED_THREAD_PRIORITY\r\n#include <sys/time.h>\r\n#include <sys/resource.h>\r\n\r\nt_stat sim_os_set_thread_priority (int below_normal_above)\r\n{\r\nif ((below_normal_above < -1) || (below_normal_above > 1))\r\n    return SCPE_ARG;\r\n\r\nerrno = 0;\r\nswitch (below_normal_above) {\r\n    case PRIORITY_BELOW_NORMAL:\r\n        if ((getpriority (PRIO_PROCESS, 0) <= 0) &&     /* at or above normal pri? */\r\n            (errno == 0))\r\n            setpriority (PRIO_PROCESS, 0, 10);\r\n        break;\r\n    case PRIORITY_NORMAL:\r\n        if (getpriority (PRIO_PROCESS, 0) != 0)         /* at or above normal pri? */\r\n            setpriority (PRIO_PROCESS, 0, 0);\r\n        break;\r\n    case PRIORITY_ABOVE_NORMAL:\r\n        if ((getpriority (PRIO_PROCESS, 0) <= 0) &&     /* at or above normal pri? */\r\n            (errno == 0))\r\n            setpriority (PRIO_PROCESS, 0, -10);\r\n        break;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n#endif  /* defined(NEED_THREAD_PRIORITY) */\r\n\r\n#endif\r\n\r\n/* If one hasn't been provided yet, then just stub it */\r\n#if defined(NEED_THREAD_PRIORITY)\r\nt_stat sim_os_set_thread_priority (int below_normal_above)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n#endif\r\n\r\n#if defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1)\r\n/* Make sure to use the substitute routines */\r\n#undef sim_idle_ms_sleep\r\n#undef sim_os_msec\r\n#undef sim_os_ms_sleep\r\n#endif /* defined(MS_MIN_GRANULARITY) && (MS_MIN_GRANULARITY != 1) */\r\n\r\n/* diff = min - sub */\r\nvoid\r\nsim_timespec_diff (struct timespec *diff, struct timespec *min, const struct timespec *sub)\r\n{\r\n/* move the minuend value to the difference and operate there. */\r\n*diff = *min;\r\n/* Borrow as needed for the nsec value */\r\nwhile (sub->tv_nsec > diff->tv_nsec) {\r\n    --diff->tv_sec;\r\n    diff->tv_nsec += 1000000000;\r\n    }\r\ndiff->tv_nsec -= sub->tv_nsec;\r\ndiff->tv_sec -= sub->tv_sec;\r\n/* Normalize the result */\r\nwhile (diff->tv_nsec >= 1000000000) {\r\n    ++diff->tv_sec;\r\n    diff->tv_nsec -= 1000000000;\r\n    }\r\n}\r\n\r\n/* Forward declarations */\r\n\r\nstatic double _timespec_to_double (struct timespec *time);\r\nstatic void _double_to_timespec (struct timespec *time, double dtime);\r\nstatic t_bool _rtcn_tick_catchup_check (RTC *rtc, int32 time);\r\nstatic void _rtcn_configure_calibrated_clock (int32 newtmr);\r\nstatic t_bool _sim_coschedule_cancel (UNIT *uptr);\r\nstatic t_bool _sim_wallclock_cancel (UNIT *uptr);\r\nstatic t_bool _sim_wallclock_is_active (UNIT *uptr);\r\nt_stat sim_timer_show_idle_mode (FILE* st, UNIT* uptr, int32 val, CONST void *  desc);\r\n\r\n\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nstatic int sim_timespec_compare (struct timespec *a, struct timespec *b)\r\n{\r\nwhile (a->tv_nsec >= 1000000000) {\r\n    a->tv_nsec -= 1000000000;\r\n    ++a->tv_sec;\r\n    }\r\nwhile (b->tv_nsec >= 1000000000) {\r\n    b->tv_nsec -= 1000000000;\r\n    ++b->tv_sec;\r\n    }\r\nif (a->tv_sec < b->tv_sec)\r\n    return -1;\r\nif (a->tv_sec > b->tv_sec)\r\n    return 1;\r\nif (a->tv_nsec < b->tv_nsec)\r\n    return -1;\r\nif (a->tv_nsec > b->tv_nsec)\r\n    return 1;\r\nelse\r\n    return 0;\r\n}\r\n#endif /* defined(SIM_ASYNCH_CLOCKS) */\r\n\r\n/* OS independent clock calibration package */\r\n\r\nstatic uint32 sim_idle_cyc_ms = 0;                          /* Cycles per millisecond while not idling */\r\nstatic uint32 sim_idle_cyc_sleep = 0;                       /* Cycles per minimum sleep interval */\r\nstatic double sim_idle_end_time = 0.0;                      /* Time when last idle completed */\r\n\r\nUNIT sim_stop_unit;                                     /* Stop unit                         */\r\nUNIT sim_internal_timer_unit;                           /* Internal calibration timer */\r\nint32 sim_internal_timer_time;                          /* Pending internal timer delay */\r\nUNIT sim_throttle_unit;                                 /* one for throttle */\r\n\r\nt_stat sim_throt_svc (UNIT *uptr);\r\nt_stat sim_timer_tick_svc (UNIT *uptr);\r\nt_stat sim_timer_stop_svc (UNIT *uptr);\r\n\r\n\r\n#define DBG_IDL       TIMER_DBG_IDLE        /* idling */\r\n#define DBG_QUE       TIMER_DBG_QUEUE       /* queue activities */\r\n#define DBG_MUX       TIMER_DBG_MUX         /* tmxr queue activities */\r\n#define DBG_TRC       0x008                 /* tracing */\r\n#define DBG_CAL       0x010                 /* calibration activities */\r\n#define DBG_TIM       0x020                 /* timer thread activities */\r\n#define DBG_THR       0x040                 /* throttle activities */\r\n#define DBG_ACK       0x080                 /* interrupt acknowledgement activities */\r\n#define DBG_CHK       0x100                 /* check scheduled activation time*/\r\n#define DBG_INT       0x200                 /* internal timer activities */\r\n#define DBG_GET       0x400                 /* get_time activities */\r\n#define DBG_TIK       0x800                 /* tick activities */\r\nDEBTAB sim_timer_debug[] = {\r\n  {\"TRACE\",   DBG_TRC, \"Trace routine calls\"},\r\n  {\"IDLE\",    DBG_IDL, \"Idling activities\"},\r\n  {\"QUEUE\",   DBG_QUE, \"Event queuing activities\"},\r\n  {\"IACK\",    DBG_ACK, \"interrupt acknowledgement activities\"},\r\n  {\"CALIB\",   DBG_CAL, \"Calibration activities\"},\r\n  {\"TICK\",    DBG_TIK, \"Calibration tick activities\"},\r\n  {\"TIME\",    DBG_TIM, \"Activation and scheduling activities\"},\r\n  {\"GETTIME\", DBG_GET, \"get_time activities\"},\r\n  {\"INTER\",   DBG_INT, \"Internal timer activities\"},\r\n  {\"THROT\",   DBG_THR, \"Throttling activities\"},\r\n  {\"MUX\",     DBG_MUX, \"Tmxr scheduling activities\"},\r\n  {\"CHECK\",   DBG_CHK, \"Check scheduled activation time\"},\r\n  {0}\r\n};\r\n\r\n/* Forward device declarations */\r\nextern DEVICE sim_timer_dev;\r\nextern DEVICE sim_throttle_dev;\r\nextern DEVICE sim_stop_dev;\r\n\r\n\r\nvoid sim_rtcn_init_all (void)\r\n{\r\nint32 tmr;\r\nRTC *rtc;\r\n\r\nfor (tmr = 0; tmr <= SIM_NTIMERS; tmr++) {\r\n    rtc = &rtcs[tmr];\r\n    if (rtc->initd != 0)\r\n        sim_rtcn_init (rtc->initd, tmr);\r\n    }\r\n}\r\n\r\nint32 sim_rtcn_init (int32 time, int32 tmr)\r\n{\r\nreturn sim_rtcn_init_unit (NULL, time, tmr);\r\n}\r\n\r\nint32 sim_rtcn_init_unit (UNIT *uptr, int32 time, int32 tmr)\r\n{\r\nreturn sim_rtcn_init_unit_ticks (uptr, time, tmr, 0);\r\n}\r\n\r\nint32 sim_rtcn_init_unit_ticks (UNIT *uptr, int32 time, int32 tmr, int32 ticksper)\r\n{\r\nRTC *rtc;\r\n\r\nif (time == 0)\r\n    time = 1;\r\nif (tmr == SIM_INTERNAL_CLK)\r\n    tmr = SIM_NTIMERS;\r\nelse {\r\n    if ((tmr < 0) || (tmr >= SIM_NTIMERS))\r\n        return time;\r\n    }\r\nrtc = &rtcs[tmr];\r\n/*\r\n * If we'd previously succeeded in calibrating a tick value, then use that\r\n * delay as a better default to setup when we're re-initialized.\r\n * Re-initializing happens on any boot.\r\n */\r\nif (rtc->currd)\r\n    time = rtc->currd;\r\nif (!uptr)\r\n    uptr = rtc->clock_unit;\r\nif (ticksper)\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_init_unit_ticks(unit=%s, time=%d, tmr=%d, ticks=%d)\\n\", uptr ? sim_uname(uptr) : \"\", time, tmr, ticksper);\r\nelse\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_init_unit(unit=%s, time=%d, tmr=%d)\\n\", uptr ? sim_uname(uptr) : \"\", time, tmr);\r\nif (uptr) {\r\n    if (!rtc->clock_unit)\r\n        sim_register_clock_unit_tmr (uptr, tmr);\r\n    }\r\nrtc->gtime = sim_gtime();\r\nrtc->rtime = sim_is_running ? sim_os_msec () : sim_stop_time;\r\nrtc->vtime = rtc->rtime;\r\nrtc->nxintv = 1000;\r\nrtc->ticks = 0;\r\nrtc->last_hz = rtc->hz;\r\nrtc->hz = ticksper;\r\nrtc->based = time;\r\nrtc->currd = time;\r\nrtc->initd = time;\r\nrtc->elapsed = 0;\r\nrtc->calibrations = 0;\r\nrtc->clock_ticks_tot += rtc->clock_ticks;\r\nrtc->clock_ticks = 0;\r\nrtc->calib_tick_time_tot += rtc->calib_tick_time;\r\nrtc->calib_tick_time = 0;\r\nrtc->clock_catchup_pending = FALSE;\r\nrtc->clock_catchup_eligible = FALSE;\r\nrtc->clock_catchup_ticks_tot += rtc->clock_catchup_ticks;\r\nrtc->clock_catchup_ticks = 0;\r\nrtc->clock_catchup_ticks_curr = 0;\r\nrtc->calib_ticks_acked_tot += rtc->calib_ticks_acked;\r\nrtc->calib_ticks_acked = 0;\r\n++rtc->calib_initializations;\r\nrtc->clock_init_base_time = sim_timenow_double ();\r\n_rtcn_configure_calibrated_clock (tmr);\r\nreturn time;\r\n}\r\n\r\nint32 sim_rtcn_calb_tick (int32 tmr)\r\n{\r\nRTC *rtc = &rtcs[tmr];\r\n\r\nreturn sim_rtcn_calb (rtc->hz, tmr);\r\n}\r\n\r\nint32 sim_rtcn_calb (uint32 ticksper, int32 tmr)\r\n{\r\nuint32 new_rtime, delta_rtime, last_idle_pct, catchup_ticks_curr;\r\nint32 delta_vtime;\r\ndouble new_gtime;\r\nint32 new_currd;\r\nint32 itmr;\r\nRTC *rtc;\r\n\r\nif (tmr == SIM_INTERNAL_CLK)\r\n    tmr = SIM_NTIMERS;\r\nelse {\r\n    if ((tmr < 0) || (tmr >= SIM_NTIMERS))\r\n        return 10000;\r\n    }\r\nrtc = &rtcs[tmr];\r\nif (rtc->hz != ticksper) {                          /* changing tick rate? */\r\n    uint32 prior_hz = rtc->hz;\r\n\r\n    if (tmr == sim_calb_tmr_last)                   /* restarting after having previously been the calibrated timer? */\r\n        ticksper = rtc->last_hz;                    /* Use the prior tick rate */\r\n    if (rtc->hz == 0)\r\n        rtc->clock_tick_start_time = sim_timenow_double ();\r\n    if ((rtc->last_hz != 0) && (rtc->last_hz != ticksper) && (ticksper != 0))\r\n        rtc->currd = (int32)(sim_timer_inst_per_sec () / ticksper);\r\n    rtc->last_hz = rtc->hz;\r\n    rtc->hz = ticksper;\r\n    _rtcn_configure_calibrated_clock (tmr);\r\n    if (ticksper != 0) {\r\n        RTC *crtc = &rtcs[sim_calb_tmr];\r\n\r\n        rtc->clock_tick_size = 1.0 / ticksper;\r\n        sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(ticksper=%d,tmr=%d) currd=%d, prior_hz=%d\\n\", ticksper, tmr, rtc->currd, (int)prior_hz);\r\n\r\n        if ((tmr != sim_calb_tmr) && rtc->clock_unit && (ticksper > crtc->hz)) {\r\n            sim_catchup_ticks = TRUE;\r\n            sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(%d) - forcing catchup ticks for %s ticking at %d, host tick rate %ds\\n\", tmr, sim_uname (rtc->clock_unit), ticksper, sim_os_tick_hz);\r\n            _rtcn_tick_catchup_check (rtc, 0);\r\n            }\r\n        }\r\n    else\r\n        sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(ticksper=%d,tmr=%d) timer stopped currd was %d, prior_hz=%d\\n\", ticksper, tmr, rtc->currd, (int)prior_hz);\r\n    }\r\nif (ticksper == 0)                                      /* running? */\r\n    return 10000;\r\nif (rtc->clock_unit == NULL) {                      /* Not using TIMER units? */\r\n    rtc->clock_ticks += 1;\r\n    rtc->calib_tick_time += rtc->clock_tick_size;\r\n    }\r\nif (rtc->clock_catchup_pending) {                   /* catchup tick? */\r\n    ++rtc->clock_catchup_ticks;                     /* accumulating which were catchups */\r\n    ++rtc->clock_catchup_ticks_curr;\r\n    rtc->clock_catchup_pending = FALSE;\r\n    }\r\nrtc->ticks += 1;                                    /* count ticks */\r\nif (rtc->ticks < ticksper)                          /* 1 sec yet? */\r\n    return rtc->currd;\r\ncatchup_ticks_curr = rtc->clock_catchup_ticks_curr;\r\nrtc->clock_catchup_ticks_curr = 0;\r\nrtc->ticks = 0;                                     /* reset ticks */\r\nrtc->elapsed += 1;                                  /* count sec */\r\nif (!rtc_avail)                                     /* no timer? */\r\n    return rtc->currd;\r\nif (sim_calb_tmr != tmr) {\r\n    rtc->currd = (int32)(sim_timer_inst_per_sec()/ticksper);\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(tmr=%d) calibrated against internal system tmr=%d, tickper=%d (result: %d)\\n\", tmr, sim_calb_tmr, ticksper, rtc->currd);\r\n    return rtc->currd;\r\n    }\r\nnew_rtime = sim_os_msec ();                         /* wall time */\r\nif (!sim_signaled_int_char &&\r\n    ((new_rtime - sim_last_poll_kbd_time) > 1000)) {\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(tmr=%d) gratuitous keyboard poll after %d msecs\\n\", tmr, (int)(new_rtime - sim_last_poll_kbd_time));\r\n    (void)sim_poll_kbd ();\r\n    }\r\n++rtc->calibrations;                                /* count calibrations */\r\nsim_debug (DBG_TRC, &sim_timer_dev, \"sim_rtcn_calb(ticksper=%d, tmr=%d)\\n\", ticksper, tmr);\r\nif (new_rtime < rtc->rtime) {                       /* time running backwards? */\r\n    /* This happens when the value returned by sim_os_msec wraps (as an uint32) */\r\n    /* Wrapping will happen initially sometime before a simulator has been running */\r\n    /* for 49 days approximately every 49 days thereafter. */\r\n    ++rtc->clock_calib_backwards;                   /* Count statistic */\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"time running backwards - OldTime: %u, NewTime: %u, result: %d\\n\", rtc->rtime, new_rtime, rtc->currd);\r\n    rtc->vtime = rtc->rtime = new_rtime;            /* reset wall time */\r\n    rtc->nxintv = 1000;\r\n    rtc->based = rtc->currd;\r\n    if (rtc->clock_catchup_eligible) {\r\n        rtc->clock_catchup_base_time = sim_timenow_double();\r\n        rtc->calib_tick_time = 0.0;\r\n        }\r\n    return rtc->currd;                              /* can't calibrate */\r\n    }\r\ndelta_rtime = new_rtime - rtc->rtime;               /* elapsed wtime */\r\nrtc->rtime = new_rtime;                             /* adv wall time */\r\nrtc->vtime += 1000;                                 /* adv sim time */\r\nif (delta_rtime > 30000) {                          /* gap too big? */\r\n    /* This simulator process has somehow been suspended for a significant */\r\n    /* amount of time.  This will certainly happen if the host system has  */\r\n    /* slept or hibernated.  It also might happen when a simulator         */\r\n    /* developer stops the simulator at a breakpoint (a process, not simh  */\r\n    /* breakpoint).  To accomodate this, we set the calibration state to   */\r\n    /* ignore what happened and proceed from here.                         */\r\n    ++rtc->clock_calib_gap2big;                     /* Count statistic */\r\n    rtc->vtime = rtc->rtime;                        /* sync virtual and real time */\r\n    rtc->nxintv = 1000;                             /* reset next interval */\r\n    rtc->gtime = sim_gtime();                       /* save instruction time */\r\n    rtc->based = rtc->currd;\r\n    if (rtc->clock_catchup_eligible)\r\n        rtc->calib_tick_time += ((double)delta_rtime / 1000.0);/* advance tick time */\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"gap too big: delta = %d - result: %d\\n\", delta_rtime, rtc->currd);\r\n    return rtc->currd;                              /* can't calibr */\r\n    }\r\nlast_idle_pct = 0;                                  /* normally force calibration */\r\nif (tmr != SIM_NTIMERS) {\r\n    if (delta_rtime != 0)                           /* avoid divide by zero  */\r\n        last_idle_pct = MIN(100, (uint32)(100.0 * (((double)(rtc->clock_time_idled - rtc->clock_time_idled_last)) / ((double)delta_rtime))));\r\n    rtc->clock_time_idled_last = rtc->clock_time_idled;\r\n    if (last_idle_pct > sim_idle_calib_pct) {\r\n        rtc->rtime = new_rtime;                     /* save wall time */\r\n        rtc->vtime += 1000;                         /* adv sim time */\r\n        rtc->gtime = sim_gtime();                   /* save instruction time */\r\n        rtc->based = rtc->currd;\r\n        ++rtc->clock_calib_skip_idle;\r\n        sim_debug (DBG_CAL, &sim_timer_dev, \"skipping calibration due to idling (%d%%) - result: %d\\n\", last_idle_pct, rtc->currd);\r\n        return rtc->currd;                          /* avoid calibrating idle checks */\r\n        }\r\n    }\r\nnew_gtime = sim_gtime();\r\nif ((last_idle_pct == 0) && (delta_rtime != 0)) {\r\n    sim_idle_cyc_ms = (uint32)((new_gtime - rtc->gtime) / delta_rtime);\r\n    if ((sim_idle_rate_ms != 0) && (delta_rtime > 1))\r\n        sim_idle_cyc_sleep = (uint32)((new_gtime - rtc->gtime) / (delta_rtime / sim_idle_rate_ms));\r\n    }\r\nif (sim_asynch_timer || (catchup_ticks_curr > 0)) {\r\n    /* An asynchronous clock or when catchup ticks have  */\r\n    /* occurred, we merely needs to divide the number of */\r\n    /* instructions actually executed by the clock rate. */\r\n    new_currd = (int32)((new_gtime - rtc->gtime)/ticksper);\r\n    /* avoid excessive swings in the calibrated result */\r\n    if (new_currd > 10*rtc->currd)              /* don't swing big too fast */\r\n        new_currd = 10*rtc->currd;\r\n    else {\r\n        if (new_currd < rtc->currd/10)          /* don't swing small too fast */\r\n            new_currd = rtc->currd/10;\r\n        }\r\n    rtc->based = rtc->currd = new_currd;\r\n    rtc->gtime = new_gtime;                     /* save instruction time */\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(%s tmr=%d, tickper=%d) catchups=%u, idle=%d%% result: %d\\n\",\r\n                    sim_asynch_timer ? \"asynch\" : \"catchup\", tmr, ticksper, catchup_ticks_curr, last_idle_pct, rtc->currd);\r\n    return rtc->currd;                          /* calibrated result */\r\n    }\r\nrtc->gtime = new_gtime;                         /* save instruction time */\r\n/* This self regulating algorithm depends directly on the assumption */\r\n/* that this routine is called back after processing the number of */\r\n/* instructions which was returned the last time it was called. */\r\nif (delta_rtime == 0)                           /* gap too small? */\r\n    rtc->based = rtc->based * ticksper;         /* slew wide */\r\nelse\r\n    rtc->based = (int32) (((double) rtc->based * (double) rtc->nxintv) /\r\n                                ((double) delta_rtime));/* new base rate */\r\ndelta_vtime = rtc->vtime - rtc->rtime;          /* gap */\r\nif (delta_vtime > SIM_TMAX)                     /* limit gap */\r\n    delta_vtime = SIM_TMAX;\r\nelse {\r\n    if (delta_vtime < -SIM_TMAX)\r\n        delta_vtime = -SIM_TMAX;\r\n    }\r\nrtc->nxintv = 1000 + delta_vtime;                   /* next wtime */\r\nrtc->currd = (int32) (((double) rtc->based * (double) rtc->nxintv) /\r\n    1000.0);                                        /* next delay */\r\nif (rtc->based <= 0)                                /* never negative or zero! */\r\n    rtc->based = 1;\r\nif (rtc->currd <= 0)                                /* never negative or zero! */\r\n    rtc->currd = 1;\r\nsim_debug (DBG_CAL, &sim_timer_dev, \"sim_rtcn_calb(tmr=%d, tickper=%d) (delta_rtime=%d, delta_vtime=%d, base=%d, nxintv=%u, catchups=%u, idle=%d%%, result: %d)\\n\",\r\n                                    tmr, ticksper, (int)delta_rtime, (int)delta_vtime, rtc->based, rtc->nxintv, catchup_ticks_curr, last_idle_pct, rtc->currd);\r\n/* Adjust calibration for other timers which depend on this timer's calibration */\r\nfor (itmr=0; itmr<=SIM_NTIMERS; itmr++) {\r\n    RTC *irtc = &rtcs[itmr];\r\n\r\n    if ((itmr != tmr) && (irtc->hz != 0))\r\n        irtc->currd = (rtc->currd * ticksper) / irtc->hz;\r\n    }\r\nAIO_SET_INTERRUPT_LATENCY(rtc->currd * ticksper);   /* set interrupt latency */\r\nreturn rtc->currd;\r\n}\r\n\r\n/* Prior interfaces - default to timer 0 */\r\n\r\nint32 sim_rtc_init (int32 time)\r\n{\r\nreturn sim_rtcn_init (time, 0);\r\n}\r\n\r\nint32 sim_rtc_calb (uint32 ticksper)\r\n{\r\nreturn sim_rtcn_calb (ticksper, 0);\r\n}\r\n\r\n/* sim_timer_init - get minimum sleep time available on this host */\r\n\r\nt_bool sim_timer_init (void)\r\n{\r\nint tmr;\r\nuint32 clock_start, clock_last, clock_now;\r\n\r\nsim_debug (DBG_TRC, &sim_timer_dev, \"sim_timer_init()\\n\");\r\n/* Clear the event queue before initializing the timer subsystem */\r\nwhile (sim_clock_queue != QUEUE_LIST_END)\r\n    sim_cancel (sim_clock_queue);\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    rtc->timer_unit = &sim_timer_units[tmr];\r\n    rtc->timer_unit->action = &sim_timer_tick_svc;\r\n    rtc->timer_unit->flags = UNIT_DIS | UNIT_IDLE;\r\n    if (rtc->clock_cosched_queue)\r\n        while (rtc->clock_cosched_queue != QUEUE_LIST_END)\r\n            sim_cancel (rtc->clock_cosched_queue);\r\n    rtc->clock_cosched_queue = QUEUE_LIST_END;\r\n    }\r\nsim_stop_unit.action = &sim_timer_stop_svc;\r\nSIM_INTERNAL_UNIT.flags = UNIT_IDLE;\r\nsim_register_internal_device (&sim_timer_dev);          /* Register Clock Assist device */\r\nsim_register_internal_device (&sim_throttle_dev);       /* Register Throttle Device */\r\nsim_throttle_unit.action = &sim_throt_svc;\r\nsim_register_clock_unit_tmr (&SIM_INTERNAL_UNIT, SIM_INTERNAL_CLK);\r\nsim_idle_enab = FALSE;                                  /* init idle off */\r\nsim_idle_rate_ms = sim_os_ms_sleep_init ();             /* get OS timer rate */\r\nsim_set_rom_delay_factor (sim_get_rom_delay_factor ()); /* initialize ROM delay factor */\r\n\r\nsim_stop_time = clock_last = clock_start = sim_os_msec ();\r\nsim_os_clock_resoluton_ms = 1000;\r\ndo {\r\n    uint32 clock_diff;\r\n\r\n    clock_now = sim_os_msec ();\r\n    clock_diff = clock_now - clock_last;\r\n    if ((clock_diff > 0) && (clock_diff < sim_os_clock_resoluton_ms))\r\n        sim_os_clock_resoluton_ms = clock_diff;\r\n    clock_last = clock_now;\r\n    } while (clock_now < clock_start + 100);\r\nif ((sim_os_clock_resoluton_ms != 0) && (sim_idle_rate_ms >= sim_os_clock_resoluton_ms))\r\n    sim_os_tick_hz = 1000/(sim_os_clock_resoluton_ms * (sim_idle_rate_ms/sim_os_clock_resoluton_ms));\r\nelse {\r\n    fprintf (stderr, \"Can't properly determine host system clock capabilities.\\n\");\r\n    fprintf (stderr, \"Minimum Host Sleep Time:       %u ms\\n\", sim_os_sleep_min_ms);\r\n    fprintf (stderr, \"Minimum Host Sleep Incr Time:  %u ms\\n\", sim_os_sleep_inc_ms);\r\n    fprintf (stderr, \"Idle Rate Milliseconds:        %u ms\\n\", sim_idle_rate_ms);\r\n    fprintf (stderr, \"Host Clock Resolution:         %u ms\\n\", sim_os_clock_resoluton_ms);\r\n    sim_idle_rate_ms = 0;                       /* Force error return */\r\n    }\r\nreturn ((sim_idle_rate_ms == 0) || (sim_os_clock_resoluton_ms == 0));\r\n}\r\n\r\n/* sim_timer_idle_capable - tell if the host is Idle capable and what the host OS tick size is */\r\n\r\nt_bool sim_timer_idle_capable (uint32 *host_ms_sleep_1, uint32 *host_tick_ms)\r\n{\r\nif (host_tick_ms)\r\n    *host_tick_ms = sim_os_clock_resoluton_ms;\r\nif (host_ms_sleep_1)\r\n    *host_ms_sleep_1 = sim_os_sleep_min_ms;\r\nreturn (sim_idle_rate_ms != 0);\r\n}\r\n\r\n/* sim_show_timers - show running timer information */\r\nt_stat sim_show_timers (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char* desc)\r\n{\r\nint tmr, clocks;\r\nstruct timespec now;\r\ntime_t time_t_now;\r\nint32 calb_tmr = (sim_calb_tmr == -1) ? sim_calb_tmr_last : sim_calb_tmr;\r\ndouble inst_per_sec = sim_timer_inst_per_sec ();\r\nconst char *calibration_type = \"\";\r\n\r\nfprintf (st, \"Minimum Host Sleep Time:        %d ms (%dHz)\\n\", sim_os_sleep_min_ms, sim_os_tick_hz);\r\nif (sim_os_sleep_min_ms != sim_os_sleep_inc_ms)\r\n    fprintf (st, \"Minimum Host Sleep Incr Time:   %d ms\\n\", sim_os_sleep_inc_ms);\r\nfprintf (st, \"Host Clock Resolution:          %d ms\\n\", sim_os_clock_resoluton_ms);\r\nif (sim_timer_calib_enabled)\r\n    fprintf (st, \"Execution Rate:                 %s %s/sec\\n\", sim_fmt_numeric (inst_per_sec), sim_vm_interval_units);\r\nif (sim_idle_enab) {\r\n    fprintf (st, \"Idling:                         Enabled\\n\");\r\n    fprintf (st, \"Time before Idling starts:      %d seconds\\n\", sim_idle_stable);\r\n    }\r\nif (sim_throt_type != SIM_THROT_NONE) {\r\n    sim_show_throt (st, NULL, uptr, val, desc);\r\n    }\r\nif (sim_timer_calib_enabled) {\r\n    fprintf (st, \"Calibrated Timer:               %s\\n\", (calb_tmr == -1) ? \"Undetermined\" :\r\n                                                         ((calb_tmr == SIM_NTIMERS) ? \"Internal Timer\" :\r\n                                                         (rtcs[calb_tmr].clock_unit ? sim_uname(rtcs[calb_tmr].clock_unit) : \"\")));\r\n    if (calb_tmr != SIM_NTIMERS)\r\n        fprintf (st, \"Catchup Ticks:                  %s\\n\", sim_catchup_ticks ? \"Enabled\" : \"Disabled\");\r\n    fprintf (st, \"Pre-Calibration Estimated Rate: %s %s/sec\\n\", sim_fmt_numeric ((double)sim_precalibrate_ips), sim_vm_interval_units);\r\n    if (sim_idle_calib_pct == 100)\r\n        fprintf (st, \"Calibration:                    Always\\n\");\r\n    else\r\n        fprintf (st, \"Calibration:                    Skipped when Idle exceeds %d%%\\n\", sim_idle_calib_pct);\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\n    fprintf (st, \"Asynchronous Clocks:            %s\\n\", sim_asynch_timer ? \"Active\" : \"Available\");\r\n#endif\r\n    }\r\nelse {\r\n    char datebuf[20];\r\n    struct tm *base;\r\n    struct timespec pseudo_now;\r\n    char timebuf[16] = \"\";\r\n    char msecs[16] = \"\";\r\n\r\n    fprintf (st, \"Calibration Disabled:           running at %s %s per pseudo second\\n\",\r\n                                                    sim_fmt_numeric ((double)sim_precalibrate_ips), sim_vm_interval_units);\r\n    calibration_type = \"Pseudo \";\r\n    base = localtime (&sim_timer_uncalib_base_time.tv_sec);\r\n    strftime (datebuf, sizeof (datebuf), \"%a %b %d\", base);\r\n    if ((base->tm_hour != 0) || (base->tm_min != 0) || (base->tm_sec != 0) ||\r\n        (sim_timer_uncalib_base_time.tv_nsec != 0))\r\n        strftime (timebuf, sizeof (timebuf), \" %H:%M:%S\", base);\r\n    if (sim_timer_uncalib_base_time.tv_nsec != 0)\r\n        snprintf (msecs, sizeof (msecs), \".%03d\", (int)(sim_timer_uncalib_base_time.tv_nsec / 1000000));\r\n    strlcat (timebuf, msecs, sizeof (timebuf));\r\n    fprintf (st, \"Base Pseudo Time of Day Date:   %s%s %d\\n\", datebuf, timebuf, base->tm_year + 1900);\r\n    if (sim_gtime() > 0) {\r\n        double d_temp;\r\n\r\n        pseudo_now = sim_timer_uncalib_base_time;\r\n        pseudo_now.tv_sec += (time_t)(sim_gtime() / sim_precalibrate_ips);\r\n        d_temp = (pseudo_now.tv_nsec / 1000000000.0) + fmod (sim_gtime(), (double)sim_precalibrate_ips) / (double)sim_precalibrate_ips;\r\n        if (d_temp > 1.0) {\r\n            ++pseudo_now.tv_sec;\r\n            d_temp -= 1.0;\r\n            }\r\n        pseudo_now.tv_nsec += (int)(d_temp * 1000000000.0);\r\n        base = localtime (&pseudo_now.tv_sec);\r\n        strftime (datebuf, sizeof (datebuf), \"%a %b %d\", base);\r\n        if ((base->tm_hour != 0) || (base->tm_min != 0) || (base->tm_sec != 0) ||\r\n            (pseudo_now.tv_nsec != 0))\r\n            strftime (timebuf, sizeof (timebuf), \" %H:%M:%S\", base);\r\n        if (pseudo_now.tv_nsec != 0)\r\n            snprintf (msecs, sizeof (msecs), \".%03d\", (int)(pseudo_now.tv_nsec / 1000000));\r\n        strlcat (timebuf, msecs, sizeof (timebuf));\r\n        fprintf (st, \"Pseudo Time of Day Date Now:    %s%s %d\\n\", datebuf, timebuf, base->tm_year + 1900);\r\n        }\r\n    }\r\nif (sim_time_at_sim_prompt != 0.0) {\r\n    double prompt_time = 0.0;\r\n    if (!sim_is_running)\r\n        prompt_time = ((double)(sim_os_msec () - sim_stop_time)) / 1000.0;\r\n    fprintf (st, \"Time at sim> prompt:            %s\\n\", sim_fmt_secs (sim_time_at_sim_prompt + prompt_time));\r\n    }\r\n\r\nfprintf (st, \"\\n\");\r\nfor (tmr=clocks=0; tmr<=SIM_NTIMERS; ++tmr) {\r\n    RTC *rtc = &rtcs[tmr];\r\n    const char *pseudo = \"\";\r\n    const char *pseudo_space = \"       \";\r\n\r\n    if (0 == rtc->initd)\r\n        continue;\r\n\r\n    if (!sim_timer_calib_enabled) {\r\n        pseudo = \"Pseudo \";\r\n        pseudo_space = \"\";\r\n        }\r\n\r\n    if (rtc->clock_unit) {\r\n        ++clocks;\r\n        fprintf (st, \"%s clock device is %s%s%s\\n\", sim_name,\r\n                                                    (tmr == SIM_NTIMERS) ? \"Internal Calibrated Timer(\" : \"\",\r\n                                                    sim_uname(rtc->clock_unit),\r\n                                                    (tmr == SIM_NTIMERS) ? \")\" : \"\");\r\n        }\r\n\r\n    fprintf (st, \"%s%s%sTimer %d:\\n\", calibration_type, sim_asynch_timer ? \"Asynchronous \" : \"\", rtc->hz ? \"Calibrated \" : \"Uncalibrated \", tmr);\r\n    if (rtc->hz) {\r\n        fprintf (st, \"  Running at:                %d Hz\\n\", rtc->hz);\r\n        fprintf (st, \"  Tick Size:                 %s\\n\", sim_fmt_secs (rtc->clock_tick_size));\r\n        fprintf (st, \"  Ticks in current second:   %d\\n\",   rtc->ticks);\r\n        }\r\n    fprintf (st, \"  Seconds Running:           %s (%s)\\n\",   sim_fmt_numeric ((double)rtc->elapsed), sim_fmt_secs ((double)rtc->elapsed));\r\n    if (tmr == calb_tmr) {\r\n        fprintf (st, \"  Calibration Opportunities: %s\\n\",   sim_fmt_numeric ((double)rtc->calibrations));\r\n        if (sim_idle_calib_pct && (sim_idle_calib_pct != 100))\r\n            fprintf (st, \"  Calib Skip when Idle >:    %u%%\\n\",   sim_idle_calib_pct);\r\n        if (rtc->clock_calib_skip_idle)\r\n            fprintf (st, \"  Calibs Skip While Idle:    %s\\n\",   sim_fmt_numeric ((double)rtc->clock_calib_skip_idle));\r\n        if (rtc->clock_calib_backwards)\r\n            fprintf (st, \"  Calibs Skip Backwards:     %s\\n\",   sim_fmt_numeric ((double)rtc->clock_calib_backwards));\r\n        if (rtc->clock_calib_gap2big)\r\n            fprintf (st, \"  Calibs Skip Gap Too Big:   %s\\n\",   sim_fmt_numeric ((double)rtc->clock_calib_gap2big));\r\n        }\r\n    if (rtc->gtime) {\r\n        if (strcmp (sim_vm_interval_units, \"instructions\") == 0)\r\n            fprintf (st, \"  Instructions Since Init:   %s\\n\", sim_fmt_numeric (rtc->gtime));\r\n        else\r\n            fprintf (st, \"  Cycles Since Init:         %s\\n\", sim_fmt_numeric (rtc->gtime));\r\n        }\r\n    if ((!sim_asynch_timer) && (sim_throt_type == SIM_THROT_NONE)) {\r\n        fprintf (st, \"  Host Real Time:            %s msecs\\n\",   sim_fmt_numeric ((double)rtc->rtime));\r\n        fprintf (st, \"  Simulated Virtual Time:    %s msecs\\n\",   sim_fmt_numeric ((double)rtc->vtime));\r\n        fprintf (st, \"  Next Calibration Interval: %s msecs\\n\",   sim_fmt_numeric ((double)rtc->nxintv));\r\n        if (strcmp (sim_vm_interval_units, \"instructions\") == 0) {\r\n            fprintf (st, \"  Previous Insts Per Tick:   %s\\n\",   sim_fmt_numeric ((double)rtc->based));\r\n            fprintf (st, \"  Initial Insts Per Tick:    %s\\n\",   sim_fmt_numeric ((double)rtc->initd));\r\n            }\r\n        else {\r\n            fprintf (st, \"  Previous Cycles Per Tick:  %s\\n\",   sim_fmt_numeric ((double)rtc->based));\r\n            fprintf (st, \"  Initial Cycles Per Tick:   %s\\n\",   sim_fmt_numeric ((double)rtc->initd));\r\n            }\r\n        }\r\n    if (strcmp (sim_vm_interval_units, \"instructions\") == 0)\r\n        fprintf (st, \"  Current Insts Per Tick:    %s\\n\",   sim_fmt_numeric ((double)rtc->currd));\r\n    else\r\n        fprintf (st, \"  Current Cycles Per Tick:   %s\\n\",   sim_fmt_numeric ((double)rtc->currd));\r\n    fprintf (st, \"  Initializations:           %d\\n\",   rtc->calib_initializations);\r\n    fprintf (st, \"  Ticks:                     %s\\n\", sim_fmt_numeric ((double)(rtc->clock_ticks)));\r\n    if (rtc->clock_ticks_tot+rtc->clock_ticks != rtc->clock_ticks)\r\n        fprintf (st, \"  Total Ticks:               %s\\n\", sim_fmt_numeric ((double)(rtc->clock_ticks_tot+rtc->clock_ticks)));\r\n    if (rtc->clock_skew_max != 0.0)\r\n        fprintf (st, \"  Peak Clock Skew:           %s%s\\n\", sim_fmt_secs (fabs(rtc->clock_skew_max)), (rtc->clock_skew_max < 0) ? \" fast\" : \" slow\");\r\n    if (rtc->calib_ticks_acked)\r\n        fprintf (st, \"  Ticks Acked:               %s\\n\",   sim_fmt_numeric ((double)rtc->calib_ticks_acked));\r\n    if (rtc->calib_ticks_acked_tot+rtc->calib_ticks_acked != rtc->calib_ticks_acked)\r\n        fprintf (st, \"  Total Ticks Acked:         %s\\n\",   sim_fmt_numeric ((double)(rtc->calib_ticks_acked_tot+rtc->calib_ticks_acked)));\r\n    if (rtc->calib_tick_time)\r\n        fprintf (st, \"  Tick Time:                 %s\\n\",   sim_fmt_secs (rtc->calib_tick_time));\r\n    if (rtc->calib_tick_time_tot+rtc->calib_tick_time != rtc->calib_tick_time)\r\n        fprintf (st, \"  Total Tick Time:           %s\\n\",   sim_fmt_secs (rtc->calib_tick_time_tot+rtc->calib_tick_time));\r\n    if (rtc->clock_catchup_ticks)\r\n        fprintf (st, \"  Catchup Ticks Sched:       %s\\n\",   sim_fmt_numeric ((double)rtc->clock_catchup_ticks));\r\n    if (rtc->clock_catchup_ticks_curr)\r\n        fprintf (st, \"  Catchup Ticks this second: %s\\n\",   sim_fmt_numeric ((double)rtc->clock_catchup_ticks_curr));\r\n    if (rtc->clock_catchup_ticks_tot+rtc->clock_catchup_ticks != rtc->clock_catchup_ticks)\r\n        fprintf (st, \"  Total Catchup Ticks Sched: %s\\n\",   sim_fmt_numeric ((double)(rtc->clock_catchup_ticks_tot+rtc->clock_catchup_ticks)));\r\n    if (rtc->clock_init_base_time) {\r\n        _double_to_timespec (&now, rtc->clock_init_base_time);\r\n        time_t_now = (time_t)now.tv_sec;\r\n        fprintf (st, \"  Initialize Base Time:      %8.8s.%03d\\n\", 11+ctime(&time_t_now), (int)(now.tv_nsec/1000000));\r\n        }\r\n    if (rtc->clock_tick_start_time) {\r\n        _double_to_timespec (&now, rtc->clock_tick_start_time);\r\n        time_t_now = (time_t)now.tv_sec;\r\n        fprintf (st, \"  %sTick Start Time:%s    %8.8s.%03d\\n\", pseudo, pseudo_space, 11+ctime(&time_t_now), (int)(now.tv_nsec/1000000));\r\n        }\r\n    sim_rtcn_get_time (&now, 0);\r\n    time_t_now = (time_t)now.tv_sec;\r\n    fprintf (st, \"  %sWall Clock Time Now:%s%8.8s.%03d\\n\", pseudo, pseudo_space, 11+ctime(&time_t_now), (int)(now.tv_nsec/1000000));\r\n    if (sim_catchup_ticks && rtc->clock_catchup_eligible) {\r\n        _double_to_timespec (&now, rtc->clock_catchup_base_time+rtc->calib_tick_time);\r\n        time_t_now = (time_t)now.tv_sec;\r\n        fprintf (st, \"  %sCatchup Tick Time:%s  %8.8s.%03d\\n\", pseudo, pseudo_space, 11+ctime(&time_t_now), (int)(now.tv_nsec/1000000));\r\n        _double_to_timespec (&now, rtc->clock_catchup_base_time);\r\n        time_t_now = (time_t)now.tv_sec;\r\n        fprintf (st, \"  %sCatchup Base Time:%s  %8.8s.%03d\\n\", pseudo, pseudo_space, 11+ctime(&time_t_now), (int)(now.tv_nsec/1000000));\r\n        }\r\n    if (rtc->clock_time_idled)\r\n        fprintf (st, \"  Total Time Idled:          %s\\n\",   sim_fmt_secs (rtc->clock_time_idled/1000.0));\r\n    }\r\nif (clocks == 0)\r\n    fprintf (st, \"%s clock device is not specified, co-scheduling is unavailable\\n\", sim_name);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_show_clock_queues (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr)\r\n{\r\nint tmr;\r\n\r\n#if defined (SIM_ASYNCH_CLOCKS)\r\npthread_mutex_lock (&sim_timer_lock);\r\nif (sim_asynch_timer) {\r\n    const char *tim;\r\n    struct timespec due;\r\n    time_t time_t_due;\r\n\r\n    if (sim_wallclock_queue == QUEUE_LIST_END)\r\n        fprintf (st, \"%s wall clock event queue empty\\n\", sim_name);\r\n    else {\r\n        fprintf (st, \"%s wall clock event queue status\\n\", sim_name);\r\n        for (uptr = sim_wallclock_queue; uptr != QUEUE_LIST_END; uptr = uptr->a_next) {\r\n            if ((dptr = find_dev_from_unit (uptr)) != NULL) {\r\n                fprintf (st, \"  %s\", sim_dname (dptr));\r\n                if (dptr->numunits > 1)\r\n                    fprintf (st, \" unit %d\", (int32) (uptr - dptr->units));\r\n                }\r\n            else\r\n                fprintf (st, \"  Unknown\");\r\n            tim = sim_fmt_secs(uptr->a_usec_delay/1000000.0);\r\n            _double_to_timespec (&due, uptr->a_due_time);\r\n            time_t_due = (time_t)due.tv_sec;\r\n            fprintf (st, \" after %s due at %8.8s.%06d\\n\", tim, 11+ctime(&time_t_due), (int)(due.tv_nsec/1000));\r\n            }\r\n        }\r\n    }\r\n#endif /* SIM_ASYNCH_CLOCKS */\r\nfor (tmr=0; tmr<=SIM_NTIMERS; ++tmr) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == NULL)\r\n        continue;\r\n    if (rtc->clock_cosched_queue != QUEUE_LIST_END) {\r\n        int32 accum;\r\n\r\n        fprintf (st, \"%s #%d clock (%s) co-schedule event queue status\\n\",\r\n                 sim_name, tmr, sim_uname(rtc->clock_unit));\r\n        accum = 0;\r\n        for (uptr = rtc->clock_cosched_queue; uptr != QUEUE_LIST_END; uptr = uptr->next) {\r\n            if ((dptr = find_dev_from_unit (uptr)) != NULL) {\r\n                fprintf (st, \"  %s\", sim_dname (dptr));\r\n                if (dptr->numunits > 1)\r\n                    fprintf (st, \" unit %d\", (int32) (uptr - dptr->units));\r\n                }\r\n            else\r\n                fprintf (st, \"  Unknown\");\r\n            if (accum == 0)\r\n                fprintf (st, \" on next tick\");\r\n            else\r\n                fprintf (st, \" after %d tick%s\", accum, (accum > 1) ? \"s\" : \"\");\r\n            if (uptr->usecs_remaining)\r\n                fprintf (st, \" plus %.0f usecs\", uptr->usecs_remaining);\r\n            fprintf (st, \"\\n\");\r\n            accum = accum + uptr->time;\r\n            }\r\n        }\r\n    }\r\n#if defined (SIM_ASYNCH_IO)\r\npthread_mutex_unlock (&sim_timer_lock);\r\n#endif /* SIM_ASYNCH_IO */\r\nreturn SCPE_OK;\r\n}\r\n\r\nREG sim_timer_reg[] = {\r\n    { DRDATAD (IDLE_CYC_MS,      sim_idle_cyc_ms,        32, \"Cycles Per Millisecond\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (IDLE_CYC_SLEEP,   sim_idle_cyc_sleep,     32, \"Cycles Per Minimum Sleep\"), PV_RSPC|REG_RO},\r\n    { DBRDATAD (IDLE_END_TIME,   sim_idle_end_time,          \"Time when last idle completed\") },\r\n    { DRDATAD (IDLE_STABLE,      sim_idle_stable,        32, \"IDLE stability delay\"), PV_RSPC},\r\n    { FLDATAD (IDLE_ENABLED,     sim_idle_enab,           0, \"Idle Enabled\"), REG_RO},\r\n    { DRDATAD (IDLE_MIN_SLEEP,   sim_idle_rate_ms,       32, \"Idle Minimum Sleep Time\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (IDLE_STABLE_TIME, sim_idle_stable,        32, \"Idle Skip before Stability Seconds\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (IDLE_SKIP_CAL_PCT,sim_idle_calib_pct,     32, \"Idle Skip Calibration Percentage\"), PV_RSPC|REG_RO},\r\n    { DBRDATAD (TIMER_STOP_TIME, sim_timer_stop_time,        \"Execution Stop Time\") },\r\n    { DRDATAD (OS_SLEEP_MIN_MS,  sim_os_sleep_min_ms,    32, \"Minimum Host Sleep Time\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (OS_SLEEP_INC_MS,  sim_os_sleep_inc_ms,    32, \"Minimum Host Sleep Increment Time\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (OS_CLOCK_RES_MS,  sim_os_clock_resoluton_ms, 32, \"Host Clock Resolution\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (OS_TICK_HZ,       sim_os_tick_hz,         32, \"OS Tick Rate (HZ)\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (ROM_DELAY,        sim_rom_delay,          32, \"ROM memory reference delay\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (TICK_RATE_0,      rtcs[0].hz,             32, \"Timer 0 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_0,      rtcs[0].currd,          32, \"Timer 0 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_1,      rtcs[1].hz,             32, \"Timer 1 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_1,      rtcs[1].currd,          32, \"Timer 1 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_2,      rtcs[2].hz,             32, \"Timer 2 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_2,      rtcs[2].currd,          32, \"Timer 2 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_3,      rtcs[3].hz,             32, \"Timer 3 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_3,      rtcs[3].currd,          32, \"Timer 3 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_4,      rtcs[4].hz,             32, \"Timer 4 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_4,      rtcs[4].currd,          32, \"Timer 4 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_5,      rtcs[5].hz,             32, \"Timer 5 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_5,      rtcs[5].currd,          32, \"Timer 5 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_6,      rtcs[6].hz,             32, \"Timer 6 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_6,      rtcs[6].currd,          32, \"Timer 6 Tick Size\") },\r\n    { DRDATAD (TICK_RATE_7,      rtcs[7].hz,             32, \"Timer 7 Ticks Per Second\") },\r\n    { DRDATAD (TICK_SIZE_7,      rtcs[7].currd,          32, \"Timer 7 Tick Size\") },\r\n    { DRDATAD (INTERNAL_TICK_RATE,sim_int_clk_tps,       32, \"Internal Timer Ticks Per Second\") },\r\n    { DRDATAD (INTERNAL_TICK_SIZE,rtcs[SIM_NTIMERS].currd,32, \"Internal Timer Tick Size\") },\r\n    { DRDATAD (CALIB_TIMR,       sim_calb_tmr,           32, \"System Calibrated Timer\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (CALIB_TIMR_LAST,  sim_calb_tmr_last,      32, \"Previous Calibrated Timer before sim>\"), PV_RSPC|REG_RO},\r\n    { DBRDATAD (INST_PER_SEC_LAST,sim_inst_per_sec_last,     \"Previous Instructions Per Sec before sim>\") },\r\n    { DRDATAD (STOP_TIME,        sim_stop_time,          32, \"Time when siminst() exited\"), PV_RSPC|REG_RO},\r\n    { DBRDATAD (SIM_PROMPT_TIME, sim_time_at_sim_prompt,     \"time spent processing commands from sim> prompt\") },\r\n    { DRDATAD (VM_INITIAL_IPS,   sim_vm_initial_ips,     32, \"Initial Instructions Per Second\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (PRECALIBRATE_IPS, sim_precalibrate_ips,   32, \"Precalibrate Instructions Per Second\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (INTER_CLK_TPS,     sim_int_clk_tps,       32, \"Internal Clock Ticks Per Second\") },\r\n    { FLDATAD (TIMER_CALIB_ENABLED, sim_timer_calib_enabled, 0, \"Timer Calibration Enabled\"), },\r\n    { FLDATAD (THROT_WAS_ACTIVE, sim_throttle_has_been_active, 0, \"Throttle has been Active\"), },\r\n    { FLDATAD (CATCHUP_TICKS,    sim_catchup_ticks,       0, \"Catchup Ticks Enabled\"), REG_RO},\r\n    { FLDATAD (ASYNC_TIMER,      sim_asynch_timer,        0, \"Asynchronous Clocks Enabled\"), REG_RO},\r\n    { NULL }\r\n    };\r\n\r\nREG sim_throttle_reg[] = {\r\n    { DRDATAD (THROT_MS_START,   sim_throt_ms_start,     32, \"Throttle measurement start time\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (THROT_MS_STOP,    sim_throt_ms_stop,      32, \"Throttle measurement stop time\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (THROT_TYPE,       sim_throt_type,         32, \"Throttle type\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (THROT_VAL,        sim_throt_val,          32, \"Throttle mode value\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (THROT_STATE,      sim_throt_state,        32, \"Throttle state\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (THROT_SLEEP_TIME, sim_throt_sleep_time,   32, \"Throttle sleep time\"), PV_RSPC|REG_RO},\r\n    { DRDATAD (THROT_WAIT,       sim_throt_wait,         32, \"Throttle execution interval before sleep\"), PV_RSPC|REG_RO},\r\n    { DBRDATAD (THROT_CPS,       sim_throt_cps,              \"Desired throttling Cycles per second\") },\r\n    { DBRDATAD (THROT_PEAK_CPS,  sim_throt_peak_cps,         \"Peak cycles per second rate\") },\r\n    { DBRDATAD (THROT_START_TIME,sim_throt_inst_start,       \"Time when actual throttling started\") },\r\n    { DRDATAD (THROT_DELAY,      sim_throt_delay,        32, \"Seconds before throttling starts\"), PV_RSPC},\r\n    { DRDATAD (THROT_DRIFT_PCT,  sim_throt_drift_pct,    32, \"Percent of throttle drift before correction\"), PV_RSPC},\r\n    { NULL }\r\n    };\r\n\r\n/* Clear, Set and show catchup */\r\n\r\n/* Set/Clear catchup */\r\n\r\nt_stat sim_timer_set_catchup (int32 flag, CONST char *cptr)\r\n{\r\nif (flag) {\r\n    if (!sim_catchup_ticks)\r\n        sim_catchup_ticks = TRUE;\r\n    }\r\nelse {\r\n    if (sim_catchup_ticks) {\r\n        sim_catchup_ticks = FALSE;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_timer_show_catchup (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nfprintf (st, \"Calibrated Ticks%s\", sim_catchup_ticks ? \" with Catchup Ticks\" : \"\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Enable/Disable calibration, specify idle calibration percentage */\r\n\r\nt_stat sim_timer_set_calib (int32 arg, CONST char *cptr)\r\n{\r\nCONST char *tptr;\r\nchar c;\r\nt_value val, units = 1;\r\nint tmr, clocks;\r\n\r\nif (arg != 0) {                         /* Enabling Calibration? */\r\n    t_stat r = SCPE_OK;\r\n\r\n    sim_timer_calib_enabled = TRUE;\r\n    if ((cptr != NULL) && (*cptr != '\\0')) { /* Calibration idle threshold percent? */\r\n        int32 newpct;\r\n        char gbuf[CBUFSIZE];\r\n\r\n        get_glyph (cptr, gbuf, 0);      /* get argument */\r\n        if (isdigit (gbuf[0]))\r\n            newpct = (int32) get_uint (gbuf, 10, 100, &r);\r\n        else {\r\n            if (MATCH_CMD (gbuf, \"ALWAYS\") == 0)\r\n                newpct = 100;\r\n            else\r\n                r = SCPE_ARG;\r\n            }\r\n        if ((r == SCPE_OK) && (newpct != 0)) {\r\n            sim_idle_calib_pct = (uint32)newpct;\r\n            return r;\r\n            }\r\n        return sim_messagef (SCPE_ARG, \"Invalid calibration idle percentage: %s\\n\", gbuf);\r\n        }\r\n    }\r\n\r\n/* Disabling Calibration */\r\nif (!sim_timer_calib_enabled)\r\n    return sim_messagef (SCPE_OK, \"calibration already disabled running at %s %s per pseudo second\\n\",\r\n                    sim_fmt_numeric ((double)sim_precalibrate_ips), sim_vm_interval_units);\r\nif (sim_throt_type != SIM_THROT_NONE)\r\n    return sim_messagef (SCPE_NOFNC, \"calibration can't be disabled when throttling\\n\");\r\nif (sim_idle_enab)\r\n    return sim_messagef (SCPE_NOFNC, \"calibration can't be disabled with idle detection enabled\\n\");\r\nif ((cptr == NULL) || (*cptr == '\\0')) {\r\n    if (sim_timer_uncalib_base_time.tv_sec == 0)\r\n        sim_rtcn_get_time (&sim_timer_uncalib_base_time, 0);\r\n    sim_timer_calib_enabled = FALSE;\r\n    sim_time_at_sim_prompt = 0.0;\r\n    sim_reset_time ();\r\n    reset_all_p (0);\r\n    sim_stop_time = sim_os_msec ();\r\n    set_cmd (0, \"NOASYNC\");\r\n    return sim_messagef (SCPE_OK, \"calibration disabled running at %s %s per pseudo second\\n\",\r\n                    sim_fmt_numeric ((double)sim_precalibrate_ips), sim_vm_interval_units);\r\n    }\r\nval = strtotv (cptr, &tptr, 10);\r\nif (cptr == tptr)\r\n    return sim_messagef (SCPE_ARG, \"Invalid NOCALIBRATE rate specification: %s\\n\", cptr);\r\nc = (char)toupper (*tptr++);\r\nif (c == 'M')\r\n    units = 1000000;\r\nelse {\r\n    if (c == 'K')\r\n        units = 1000;\r\n    else\r\n        return sim_messagef (SCPE_ARG, \"Invalid NOCALIBRATE rate specification: %s\\n\", cptr);\r\n    }\r\nsim_timer_set_async (0, NULL);\r\nif (sim_timer_uncalib_base_time.tv_sec == 0)\r\n    sim_rtcn_get_time (&sim_timer_uncalib_base_time, 0);\r\nsim_timer_calib_enabled = FALSE;\r\nsim_time_at_sim_prompt = 0.0;\r\nsim_reset_time ();\r\nsim_precalibrate_ips = (uint32)(val * units);\r\nfor (tmr=clocks=0; tmr<=SIM_NTIMERS; ++tmr) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->hz != 0)\r\n        rtc->initd = rtc->based = rtc->currd = sim_precalibrate_ips / rtc->hz;\r\n    if (rtc->last_hz != 0)\r\n        rtc->initd = rtc->based = rtc->currd = sim_precalibrate_ips / rtc->last_hz;\r\n    }\r\nreset_all_p (0);\r\nsim_stop_time = sim_os_msec ();\r\nset_cmd (0, \"NOASYNC\");\r\nreturn sim_messagef (SCPE_OK, \"calibration disabled running at %s %s per pseudo second\\n\",\r\n                sim_fmt_numeric ((double)sim_precalibrate_ips), sim_vm_interval_units);\r\n}\r\n\r\nt_stat sim_show_calibration (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nif (sim_timer_calib_enabled)\r\n    fprintf (st, \"calibration enabled\");\r\nelse\r\n    fprintf (st, \"calibration disabled running at %s %s per pseudo second\",\r\n                    sim_fmt_numeric ((double)sim_precalibrate_ips), sim_vm_interval_units);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_timer_set_uncalib_base (int32 arg, CONST char *cptr)\r\n{\r\nstruct tm base;\r\nint msecs = 0;\r\ntime_t secs;\r\nint fields;\r\n\r\nif ((cptr == NULL) || (*cptr == '\\0')) {\r\n    sim_messagef (SCPE_ARG, \"Missing base date/time specification.\\n\");\r\n    return sim_messagef (SCPE_ARG, \"Valid format is: BASE=YYYY/MM/DD-HH:MM:SS.MSEC\\n\");\r\n    }\r\nif (!sim_timer_calib_enabled)\r\n    return sim_messagef (SCPE_ARG,\"Pseudo Clock base date/time must be set before disabling calibration.\\n\");\r\nmemset (&base, 0, sizeof (base));\r\nmsecs = 0;\r\nfields = sscanf (cptr, \"%d/%d/%d-%d:%d:%d.%d\", &base.tm_year, &base.tm_mon, &base.tm_mday, &base.tm_hour, &base.tm_min, &base.tm_sec, &msecs);\r\nbase.tm_mon -= 1;\r\nbase.tm_year -= 1900;\r\nsecs = mktime (&base);\r\nif ((fields < 3) || (secs == (time_t)-1) || (msecs > 999)) {\r\n    sim_messagef (SCPE_ARG, \"Unexpected date/time specification: %s\\n\", cptr);\r\n    return sim_messagef (SCPE_ARG, \"Valid format is: BASE=YYYY/MM/DD-HH:MM:SS.MSEC\\n\");\r\n    }\r\nsim_timer_uncalib_base_time.tv_sec = secs;\r\nsim_timer_uncalib_base_time.tv_nsec = msecs * 1000000;\r\nsim_messagef (SCPE_OK, \"%4d/%d/%d-%02d:%02d:%02d.%03d will be used as the simulation start\\n\",\r\n                        base.tm_year + 1900, base.tm_mon + 1, base.tm_mday, base.tm_hour, base.tm_min, base.tm_sec, msecs);\r\nsim_messagef (SCPE_OK, \"wall clock time when calibration is disabled\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set stop time */\r\n\r\nt_stat sim_timer_set_stop (int32 flag, CONST char *cptr)\r\n{\r\nt_stat r;\r\nt_value stop_time;\r\n\r\nif (cptr == NULL)\r\n    return SCPE_ARG;\r\nstop_time = get_uint (cptr, 10, T_VALUE_MAX, &r);\r\nif (r != SCPE_OK)\r\n    return r;\r\nif (stop_time <= (t_value)sim_gtime())\r\n    return SCPE_ARG;\r\nsim_register_internal_device (&sim_stop_dev);           /* Register Stop Device */\r\nsim_timer_stop_time = (double)stop_time;\r\nsim_activate_abs (&sim_stop_unit, (int32)(sim_timer_stop_time - sim_gtime()));\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Set/Clear asynch */\r\n\r\nt_stat sim_timer_set_async (int32 flag, CONST char *cptr)\r\n{\r\nif (flag) {\r\n    if (sim_asynch_enabled && (!sim_asynch_timer)) {\r\n        sim_asynch_timer = TRUE;\r\n        sim_timer_change_asynch ();\r\n        }\r\n    }\r\nelse {\r\n    if (sim_asynch_timer) {\r\n        sim_asynch_timer = FALSE;\r\n        sim_timer_change_asynch ();\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic CTAB set_timer_tab[] = {\r\n#if defined (SIM_ASYNCH_CLOCKS)\r\n    { \"ASYNCH\",     &sim_timer_set_async, 1 },\r\n    { \"NOASYNCH\",   &sim_timer_set_async, 0 },\r\n#endif\r\n    { \"CATCHUP\",    &sim_timer_set_catchup,      1 },\r\n    { \"NOCATCHUP\",  &sim_timer_set_catchup,      0 },\r\n    { \"CALIBRATE\",  &sim_timer_set_calib,        1 },\r\n    { \"NOCALIBRATE\",&sim_timer_set_calib,        0 },\r\n    { \"UNCALIBRATE\",&sim_timer_set_calib,        0 },\r\n    { \"STOP\",       &sim_timer_set_stop,         0 },\r\n    { \"BASETIME\",   &sim_timer_set_uncalib_base, 0 },\r\n    { NULL, NULL, 0 }\r\n    };\r\n\r\nMTAB sim_timer_mod[] = {\r\n  { 0 },\r\n};\r\n\r\nstatic t_stat sim_timer_clock_reset (DEVICE *dptr);\r\n\r\nstatic const char *sim_timer_description (DEVICE *dptr)\r\n{\r\nreturn \"Clock Assist facilities\";\r\n}\r\n\r\nstatic const char *sim_int_timer_description (DEVICE *dptr)\r\n{\r\nreturn \"Internal Timer\";\r\n}\r\n\r\nstatic const char *sim_int_stop_description (DEVICE *dptr)\r\n{\r\nreturn \"Stop facility\";\r\n}\r\n\r\nstatic const char *sim_throttle_description (DEVICE *dptr)\r\n{\r\nreturn \"Throttle facility\";\r\n}\r\n\r\n\r\nDEVICE sim_timer_dev = {\r\n    \"INT-CLOCK\", sim_timer_units, sim_timer_reg, sim_timer_mod,\r\n    SIM_NTIMERS+1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, &sim_timer_clock_reset, NULL, NULL, NULL,\r\n    NULL, DEV_DEBUG | DEV_NOSAVE, 0,\r\n    sim_timer_debug};\r\n\r\nDEVICE sim_int_timer_dev = {\r\n    \"INT-TIMER\", &sim_internal_timer_unit, NULL, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE};\r\n\r\nDEVICE sim_stop_dev = {\r\n    \"INT-STOP\", &sim_stop_unit, NULL, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    sim_int_stop_description};\r\n\r\nDEVICE sim_throttle_dev = {\r\n    \"INT-THROTTLE\", &sim_throttle_unit, sim_throttle_reg, NULL,\r\n    1, 0, 0, 0, 0, 0,\r\n    NULL, NULL, NULL, NULL, NULL, NULL,\r\n    NULL, DEV_NOSAVE};\r\n\r\n/* SET CLOCK command */\r\n\r\nt_stat sim_set_timers (int32 arg, CONST char *cptr)\r\n{\r\nchar *cvptr, gbuf[CBUFSIZE];\r\nCTAB *ctptr;\r\nt_stat r;\r\n\r\nif ((cptr == NULL) || (*cptr == 0))\r\n    return SCPE_2FARG;\r\nwhile (*cptr != 0) {                                    /* do all mods */\r\n    cptr = get_glyph_nc (cptr, gbuf, ',');              /* get modifier */\r\n    if ((cvptr = strchr (gbuf, '=')))                   /* = value? */\r\n        *cvptr++ = 0;\r\n    get_glyph (gbuf, gbuf, 0);                          /* modifier to UC */\r\n    if ((ctptr = find_ctab (set_timer_tab, gbuf))) {    /* match? */\r\n        r = ctptr->action (ctptr->arg, cvptr);          /* do the rest */\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        }\r\n    else\r\n        return sim_messagef (SCPE_NOPARAM, \"Invalid timer parameter: %s\\n\", gbuf);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* sim_idle - idle simulator until next event or for specified interval\r\n\r\n   Inputs:\r\n        tmr =   calibrated timer to use\r\n\r\n   Must solve the linear equation\r\n\r\n        ms_to_wait = w * ms_per_wait\r\n\r\n   Or\r\n        w = ms_to_wait / ms_per_wait\r\n*/\r\n\r\nt_bool sim_idle (uint32 tmr, int sin_cyc)\r\n{\r\nuint32 w_ms, w_idle, act_ms;\r\nint32 act_cyc;\r\nstatic t_bool in_nowait = FALSE;\r\ndouble cyc_since_idle;\r\nRTC *rtc = &rtcs[tmr];\r\n\r\nif (rtc->hz == 0)                                       /* specified timer is not running? */\r\n    tmr = sim_calb_tmr;                                 /* use calibrated timer instead */\r\nrtc = &rtcs[tmr];\r\nif (rtc->clock_catchup_pending) {                       /* Catchup clock tick pending due to ack? */\r\n    sim_debug (DBG_TIK, &sim_timer_dev, \"sim_idle(tmr=%d, sin_cyc=%d) - accelerating pending catch-up tick before idling %s\\n\", tmr, sin_cyc, sim_uname (rtc->clock_unit));\r\n    sim_activate_abs (&sim_timer_units[tmr], 0);\r\n    sim_interval -= sin_cyc;\r\n    return FALSE;\r\n    }\r\nif (_rtcn_tick_catchup_check (rtc, -1)) {               /* Check for slow clock tick? */\r\n    sim_interval -= sin_cyc;\r\n    return FALSE;\r\n    }\r\nif ((!sim_idle_enab)                             ||     /* idling disabled */\r\n    ((sim_clock_queue == QUEUE_LIST_END) &&             /* or clock queue empty? */\r\n     (!sim_asynch_timer))||                             /*     and not asynch? */\r\n    ((sim_clock_queue != QUEUE_LIST_END) &&             /* or clock queue not empty */\r\n     ((sim_clock_queue->flags & UNIT_IDLE) == 0))||     /*   and event not idle-able? */\r\n    (rtc->elapsed < sim_idle_stable)) {             /* or calibrated timer not stable? */\r\n    sim_debug (DBG_IDL, &sim_timer_dev, \"Can't idle: %s - elapsed: %d and %d/%d\\n\", !sim_idle_enab ? \"idle disabled\" :\r\n                                                                             ((rtc->elapsed < sim_idle_stable) ? \"not stable\" :\r\n                                                                                                                     ((sim_clock_queue != QUEUE_LIST_END) ? sim_uname (sim_clock_queue) :\r\n                                                                                                                                                            \"\")), rtc->elapsed, rtc->ticks, rtc->hz);\r\n    sim_interval -= sin_cyc;\r\n    return FALSE;\r\n    }\r\n/*\r\n   When a simulator is in an instruction path (or under other conditions\r\n   which would indicate idling), the countdown of sim_interval may not\r\n   be happening at a pace which is consistent with the rate it happens\r\n   when not in the 'idle capable' state.  The consequence of this is that\r\n   the clock calibration may produce calibrated results which vary much\r\n   more than they do when not in the idle able state.  Sim_idle also uses\r\n   the calibrated tick size to approximate an adjustment to sim_interval\r\n   to reflect the number of instructions which would have executed during\r\n   the actual idle time, so consistent calibrated numbers produce better\r\n   adjustments.\r\n\r\n   To negate this effect, we accumulate the time actually idled here.\r\n   sim_rtcn_calb compares the accumulated idle time during the most recent\r\n   second and if it exceeds the percentage defined by sim_idle_calib_pct\r\n   calibration is suppressed. Thus recalibration only happens if things\r\n   didn't idle too much.\r\n\r\n   we also check check sim_idle_enab above so that all simulators can avoid\r\n   directly checking sim_idle_enab before calling sim_idle so that all of\r\n   the bookkeeping on sim_idle_idled is done here in sim_timer where it\r\n   means something, while not idling when it isn't enabled.\r\n   */\r\nsim_debug (DBG_TRC, &sim_timer_dev, \"sim_idle(tmr=%d, sin_cyc=%d)\\n\", tmr, sin_cyc);\r\nif (sim_idle_cyc_ms == 0) {\r\n    sim_idle_cyc_ms = (rtc->currd * rtc->hz) / 1000;/* cycles per msec */\r\n    if (sim_idle_rate_ms != 0)\r\n        sim_idle_cyc_sleep = (rtc->currd * rtc->hz) / (1000 / sim_idle_rate_ms);/* cycles per minimum sleep */\r\n    }\r\nif ((sim_idle_rate_ms == 0) || (sim_idle_cyc_ms == 0)) {/* not possible? */\r\n    sim_interval -= sin_cyc;\r\n    sim_debug (DBG_IDL, &sim_timer_dev, \"not possible idle_rate_ms=%d - cyc/ms=%d\\n\", sim_idle_rate_ms, sim_idle_cyc_ms);\r\n    return FALSE;\r\n    }\r\nw_ms = (uint32) sim_interval / sim_idle_cyc_ms;         /* ms to wait */\r\n/* When the host system has a clock tick which is less frequent than the    */\r\n/* simulated system's clock, idling will cause delays which will miss       */\r\n/* simulated clock ticks.  To accomodate this, and still allow idling, if   */\r\n/* the simulator acknowledges the processing of clock ticks, then catchup   */\r\n/* ticks can be used to make up for missed ticks. */\r\nif (rtc->clock_catchup_eligible)\r\n    w_idle = (sim_interval * 1000) / rtc->currd;        /* 1000 * pending fraction of tick */\r\nelse\r\n    w_idle = (w_ms * 1000) / sim_idle_rate_ms;          /* 1000 * intervals to wait */\r\nif ((w_idle < 500) || (w_ms == 0)) {                    /* shorter than 1/2 the interval or */\r\n    sim_interval -= sin_cyc;                            /* minimal sleep time? */\r\n    if (!in_nowait)\r\n        sim_debug (DBG_IDL, &sim_timer_dev, \"no wait, too short: %d msecs\\n\", w_idle);\r\n    in_nowait = TRUE;\r\n    return FALSE;\r\n    }\r\nif (w_ms > 1000) {                                      /* too long a wait (runaway calibration) */\r\n    sim_printf (\"sim_idle() - waiting too long:  w_ms=%d msecs, w_idle=%d msecs, sim_interval=%d, rtc->currd=%d, sim_idle_cyc_ms=%d\\n\", w_ms, w_idle, sim_interval, rtc->currd, sim_idle_cyc_ms);\r\n    exdep_cmd (EX_E, \"INT-CLOCK STATE\");\r\n    sim_show_timers (stdout, NULL, NULL, 0, \"\");\r\n    SIM_SCP_ABORT (\"sim_idle() - waiting too long\");\r\n    }\r\nin_nowait = FALSE;\r\nif (sim_clock_queue == QUEUE_LIST_END)\r\n    sim_debug (DBG_IDL, &sim_timer_dev, \"sleeping for %d ms - pending event in %d %s\\n\", w_ms, sim_interval, sim_vm_interval_units);\r\nelse\r\n    sim_debug (DBG_IDL, &sim_timer_dev, \"sleeping for %d ms - pending event on %s in %d %s\\n\", w_ms, sim_uname(sim_clock_queue), sim_interval, sim_vm_interval_units);\r\ncyc_since_idle = sim_gtime() - sim_idle_end_time;       /* time since prior idle completed */\r\nact_ms = sim_idle_ms_sleep (w_ms);                      /* wait */\r\nrtc->clock_time_idled += act_ms;\r\nact_cyc = act_ms * sim_idle_cyc_ms;                     /* Total potential cycles executed while sleeping */\r\n                                                        /* In general, sleeps will end at the boundary of host OS ticks */\r\nif (cyc_since_idle > sim_idle_cyc_sleep)                /* executed more than a sleep interval's cycles */\r\n    act_cyc -= sim_idle_cyc_sleep / 2;                  /* adjust for half a sleep interval's worth of cycles */\r\nelse\r\n    act_cyc -= (int32)cyc_since_idle;                   /* adjust for cycles executed */\r\nsim_interval = sim_interval - act_cyc;                  /* count down sim_interval to reflect idle period */\r\nsim_idle_end_time = sim_gtime();                        /* save idle completed time */\r\nif (sim_clock_queue == QUEUE_LIST_END)\r\n    sim_debug (DBG_IDL, &sim_timer_dev, \"slept for %d ms - pending event in %d %s\\n\", act_ms, sim_interval, sim_vm_interval_units);\r\nelse\r\n    sim_debug (DBG_IDL, &sim_timer_dev, \"slept for %d ms - pending event on %s in %d %s\\n\", act_ms, sim_uname(sim_clock_queue), sim_interval, sim_vm_interval_units);\r\nreturn TRUE;\r\n}\r\n\r\n/* Set idling - implicitly disables throttling */\r\n\r\nt_stat sim_set_idle (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nt_stat r;\r\nuint32 v;\r\n\r\nif (sim_timer_calib_enabled == FALSE)\r\n    return sim_messagef (SCPE_NOFNC, \"Iding is not available when calibration is disabled\\n\");\r\nif (cptr && *cptr) {\r\n    v = (uint32) get_uint (cptr, 10, SIM_IDLE_STMAX, &r);\r\n    if ((r != SCPE_OK) || (v < SIM_IDLE_STMIN))\r\n        return sim_messagef (SCPE_ARG, \"Invalid Stability value: %s.  Valid values range from %d to %d.\\n\", cptr, SIM_IDLE_STMIN, SIM_IDLE_STMAX);\r\n    sim_idle_stable = v;\r\n    }\r\nsim_idle_enab = TRUE;\r\nif (sim_throt_type != SIM_THROT_NONE) {\r\n    sim_set_throt (0, NULL);\r\n    sim_printf (\"Throttling disabled\\n\");\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Clear idling */\r\n\r\nt_stat sim_clr_idle (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nsim_idle_enab = FALSE;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show idling */\r\n\r\nt_stat sim_show_idle (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nif (sim_idle_enab)\r\n    fprintf (st, \"idle enabled\");\r\nelse\r\n    fprintf (st, \"idle disabled\");\r\nif (sim_switches & SWMASK ('D'))\r\n    fprintf (st, \", stability wait = %ds, minimum sleep resolution = %dms\", sim_idle_stable, sim_os_sleep_min_ms);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Throttling package */\r\n\r\nt_stat sim_set_throt (int32 arg, CONST char *cptr)\r\n{\r\nCONST char *tptr;\r\nchar c;\r\nuint32 saved_throt_type = sim_throt_type;\r\nint factor = 1;\r\nt_value val, val2 = 0;\r\n\r\nif (arg == 0) {\r\n    if ((cptr != NULL) && (*cptr != 0))\r\n        return sim_messagef (SCPE_ARG, \"Unexpected NOTHROTTLE argument: %s\\n\", cptr);\r\n    sim_throt_type = SIM_THROT_NONE;\r\n    sim_throt_cancel ();\r\n    return SCPE_OK;\r\n    }\r\nif (sim_timer_calib_enabled == FALSE)\r\n    return sim_messagef (SCPE_NOFNC, \"Throttling is not available when calibration is disabled\\n\");\r\nif (sim_idle_rate_ms == 0)\r\n    return sim_messagef (SCPE_NOFNC, \"Throttling is not available, Minimum OS sleep time is %dms\\n\", sim_os_sleep_min_ms);\r\nif (*cptr == '\\0')\r\n    return sim_messagef (SCPE_ARG, \"Missing throttle mode specification\\n\");\r\nval = strtotv (cptr, &tptr, 10);\r\nif (cptr == tptr)\r\n    return sim_messagef (SCPE_ARG, \"Invalid throttle specification: %s\\n\", cptr);\r\nsim_throt_sleep_time = sim_idle_rate_ms;\r\nc = (char)toupper (*tptr++);\r\nif (c == 'M') {\r\n    factor = 1000000;\r\n    if (*tptr != '\\0')\r\n        c = (char)toupper (*tptr++);\r\n    }\r\nelse {\r\n    if (c == 'K') {\r\n        factor = 1000;\r\n        if (*tptr != '\\0')\r\n            c = (char)toupper (*tptr++);\r\n        }\r\n    }\r\nif (c == '/') {\r\n    if (val == 0)\r\n        return sim_messagef (SCPE_ARG, \"Invalid %s count specifier: %s\\n\", cptr, sim_vm_interval_units);\r\n    val2 = strtotv (tptr, &tptr, 10);\r\n    if (val2 == 0)\r\n        return sim_messagef (SCPE_ARG, \"Invalid throttle delay specifier: %s\\n\", cptr);\r\n    if ((*tptr != '\\0') && (*tptr != '='))\r\n        return sim_messagef (SCPE_ARG, \"Invalid throttle delay specifier: %s\\n\", cptr);\r\n    }\r\nif (c == 'M')\r\n    sim_throt_type = SIM_THROT_MCYC;\r\nelse {\r\n    if (c == 'K')\r\n        sim_throt_type = SIM_THROT_KCYC;\r\n    else {\r\n        if ((c == '%') && (val > 0) && (val < 100))\r\n            sim_throt_type = SIM_THROT_PCT;\r\n        else {\r\n            if ((c == '/') && (val2 != 0))\r\n                sim_throt_type = SIM_THROT_SPC;\r\n            else\r\n                return sim_messagef (SCPE_ARG, \"Invalid throttle specification: %s\\n\", cptr);\r\n            }\r\n        }\r\n    }\r\nif (sim_throttle_has_been_active) {\r\n    sim_throt_type = saved_throt_type;\r\n    sim_messagef (SCPE_ARG, \"Throttling was previously active.\\n\");\r\n    return sim_messagef (SCPE_ARG, \"Restart the simulator to change the throttling mode\\n\");\r\n    }\r\nif ((sim_precalibrate_ips != SIM_INITIAL_IPS) &&\r\n    ((val * factor) > sim_precalibrate_ips)) {\r\n    sim_throt_type = saved_throt_type;\r\n    return sim_messagef (SCPE_ARG, \"The current host CPU is too slow to simulate at %s %s per sec.\\n\", cptr, sim_vm_interval_units);\r\n    }\r\nif (sim_idle_enab) {\r\n    sim_printf (\"Idling disabled\\n\");\r\n    sim_clr_idle (NULL, 0, NULL, NULL);\r\n    }\r\nsim_throt_val = (uint32) val;\r\nif (sim_throt_type != SIM_THROT_SPC)\r\n    sim_throt_cps = sim_precalibrate_ips;       /* Set initial value while correct one is determined */\r\nelse {                                          /* otherwise use best guess based on measured execution and sleep times */\r\n    int32 tmr;\r\n    RTC *rtc = NULL;\r\n\r\n    if (sim_throt_type == SIM_THROT_SPC) {\r\n        if (val2 >= sim_idle_rate_ms) {\r\n            sim_throt_sleep_time = (uint32) val2;\r\n            sim_throt_val = (uint32) (val * factor);\r\n            }\r\n        else {\r\n            if ((sim_idle_rate_ms % val2) == 0) {\r\n                sim_throt_sleep_time = sim_idle_rate_ms;\r\n                sim_throt_val = (uint32) (val * factor * (sim_idle_rate_ms / val2));\r\n                }\r\n            else {\r\n                sim_throt_sleep_time = sim_idle_rate_ms;\r\n                sim_throt_val = (uint32) (val * factor * (1 + (sim_idle_rate_ms / val2)));\r\n                }\r\n            }\r\n        sim_throt_state = SIM_THROT_STATE_THROTTLE;     /* force state */\r\n        sim_throt_wait = sim_throt_val;\r\n        }\r\n\r\n    sim_throt_delay = 1;\r\n    sim_throt_cps = (int32)((1000.0 * sim_throt_val) / (double)sim_throt_sleep_time);\r\n    sim_inst_per_sec_last = sim_throt_cps;      /* Reflect the throttle rate for where cps is needed */\r\n    /* Run through all timers and adjust the calibration for each */\r\n    /* one that is running to reflect the throttle specified rate */\r\n    for (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n        rtc = &rtcs[tmr];\r\n        if (rtc->hz) {                                      /* running? */\r\n            rtc->currd = (int32)(sim_throt_cps / rtc->hz);/* use throttle calibration */\r\n            rtc->ticks = rtc->hz - 1;                     /* force clock calibration on next tick */\r\n            rtc->rtime = sim_throt_ms_start - 1000 + 1000/rtc->hz;/* adjust calibration parameters to reflect throttled rate */\r\n            rtc->gtime = sim_throt_inst_start - sim_throt_cps + sim_throt_cps/rtc->hz;\r\n            rtc->nxintv = 1000;\r\n            rtc->based = rtc->currd;\r\n            if (rtc->clock_unit)\r\n                sim_activate_abs (rtc->clock_unit, rtc->currd);/* reschedule next tick */\r\n            }\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_show_throt (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr)\r\n{\r\nif (sim_idle_rate_ms == 0)\r\n    fprintf (st, \"Throttling:                    Not Available\\n\");\r\nelse {\r\n    switch (sim_throt_type) {\r\n\r\n    case SIM_THROT_MCYC:\r\n        fprintf (st, \"Throttle:                      %d mega %s per second\\n\", sim_throt_val, sim_vm_interval_units);\r\n        if (sim_throt_wait)\r\n            fprintf (st, \"Throttling by sleeping for:    %d ms every %d %s\\n\", sim_throt_sleep_time, sim_throt_wait, sim_vm_interval_units);\r\n        break;\r\n\r\n    case SIM_THROT_KCYC:\r\n        fprintf (st, \"Throttle:                      %d kilo %s per second\\n\", sim_throt_val, sim_vm_interval_units);\r\n        if (sim_throt_wait)\r\n            fprintf (st, \"Throttling by sleeping for:    %d ms every %d %s\\n\", sim_throt_sleep_time, sim_throt_wait, sim_vm_interval_units);\r\n        break;\r\n\r\n    case SIM_THROT_PCT:\r\n        if (sim_throt_wait) {\r\n            fprintf (st, \"Throttle:                      %d%% of %s %s per second\\n\", sim_throt_val, sim_fmt_numeric (sim_throt_peak_cps), sim_vm_interval_units);\r\n            fprintf (st, \"Throttling by sleeping for:    %d ms every %d %s\\n\", sim_throt_sleep_time, sim_throt_wait, sim_vm_interval_units);\r\n            }\r\n        else\r\n            fprintf (st, \"Throttle:                      %d%%\\n\", sim_throt_val);\r\n        break;\r\n\r\n    case SIM_THROT_SPC:\r\n        if (sim_throt_cps > 0.0) {\r\n            fprintf (st, \"Throttle:                      %s\", sim_fmt_numeric ((double)sim_throt_val));\r\n            fprintf (st, \"/%d (about %s %s per second)\\n\", sim_throt_sleep_time, sim_fmt_numeric (sim_throt_cps), sim_vm_interval_units);\r\n            }\r\n        else\r\n            fprintf (st, \"Throttle:                      %d/%d\\n\", sim_throt_val, sim_throt_sleep_time);\r\n        fprintf (st, \"Throttling by sleeping for:    %d ms every %d %s\\n\", sim_throt_sleep_time, sim_throt_val, sim_vm_interval_units);\r\n        break;\r\n\r\n    default:\r\n        fprintf (st, \"Throttling:                    Disabled\\n\");\r\n        break;\r\n        }\r\n    if (sim_throt_type != SIM_THROT_NONE) {\r\n        if (sim_throt_state != SIM_THROT_STATE_THROTTLE)\r\n            fprintf (st, \"Throttle State:                %s - wait: %d\\n\", (sim_throt_state == SIM_THROT_STATE_INIT) ? \"Waiting for Init\" : \"Timing\", sim_throt_wait);\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nvoid sim_throt_sched (void)\r\n{\r\nif (sim_throt_type != SIM_THROT_NONE) {\r\n    if (sim_throt_state == SIM_THROT_STATE_THROTTLE) {  /* Previously calibrated? */\r\n        /* Reset recalibration reference times */\r\n        sim_throt_ms_start = sim_os_msec ();\r\n        sim_throt_inst_start = sim_gtime ();\r\n        /* Start with prior calibrated delay */\r\n        sim_activate (&sim_throttle_unit, sim_throt_wait);\r\n        }\r\n    else {\r\n        /* Start calibration initially */\r\n        sim_throt_state = SIM_THROT_STATE_INIT;\r\n        sim_activate (&sim_throttle_unit, SIM_THROT_WINIT);\r\n        }\r\n    sim_throttle_has_been_active = TRUE;\r\n    }\r\n}\r\n\r\nvoid sim_throt_cancel (void)\r\n{\r\nsim_cancel (&sim_throttle_unit);\r\n}\r\n\r\n/* Throttle service\r\n\r\n   Throttle service has three distinct states used while dynamically\r\n   determining a throttling interval:\r\n\r\n       SIM_THROT_STATE_INIT     take initial measurement\r\n       SIM_THROT_STATE_TIME     take final measurement, calculate wait values\r\n       SIM_THROT_STATE_THROTTLE periodic waits to slow down the CPU\r\n*/\r\nt_stat sim_throt_svc (UNIT *uptr)\r\n{\r\nint32 tmr;\r\nuint32 delta_ms;\r\ndouble a_cps, d_cps, delta_inst;\r\nRTC *rtc = NULL;\r\n\r\nif (sim_calb_tmr != -1)\r\n    rtc = &rtcs[sim_calb_tmr];\r\nswitch (sim_throt_state) {\r\n\r\n    case SIM_THROT_STATE_INIT:                          /* take initial reading */\r\n        if ((sim_calb_tmr != -1) && (rtc->hz != 0)) {\r\n            if (rtc->calibrations < sim_throt_delay) {\r\n                sim_throt_ms_start = sim_os_msec ();\r\n                sim_throt_inst_start = sim_gtime ();\r\n                sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc(INIT) Deferring until stable (%d more seconds)\\n\", (int)(sim_throt_delay - rtc->calibrations));\r\n                return sim_activate (uptr, rtc->hz * rtc->currd);\r\n                }\r\n            sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc(INIT) Computing Throttling values based on the last second's execution rate\\n\");\r\n            sim_throt_state = SIM_THROT_STATE_TIME;\r\n            if (sim_throt_peak_cps < (double)(rtc->hz * rtc->currd))\r\n                sim_throt_peak_cps = (double)rtc->hz * rtc->currd;\r\n            return sim_throt_svc (uptr);\r\n            }\r\n        else\r\n            sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc(INIT) Calibrated timer not available. Falling back to legacy method\\n\");\r\n        sim_idle_ms_sleep (sim_idle_rate_ms);           /* start on a tick boundary to calibrate */\r\n        sim_throt_ms_start = sim_os_msec ();\r\n        sim_throt_inst_start = sim_gtime ();\r\n        if (sim_throt_type != SIM_THROT_SPC) {          /* dynamic? */\r\n            switch (sim_throt_type) {\r\n                case SIM_THROT_PCT:\r\n                    sim_throt_wait = (int32)((sim_throt_peak_cps * sim_throt_val) / 100.0);\r\n                    break;\r\n                case SIM_THROT_KCYC:\r\n                    sim_throt_wait = sim_throt_val * 1000;\r\n                    break;\r\n                case SIM_THROT_MCYC:\r\n                    sim_throt_wait = sim_throt_val * 1000000;\r\n                    break;\r\n                }\r\n            sim_throt_state = SIM_THROT_STATE_TIME;     /* next state */\r\n            }\r\n        else {                                          /* Non dynamic? */\r\n            sim_throt_wait = sim_throt_val;\r\n            sim_throt_state = SIM_THROT_STATE_THROTTLE; /* force state */\r\n            sim_throt_cps = (int32)((1000.0 * sim_throt_val) / (double)sim_throt_sleep_time);\r\n            }\r\n        sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc(INIT) Starting.  Values wait = %d\\n\", sim_throt_wait);\r\n        break;                                          /* reschedule */\r\n\r\n    case SIM_THROT_STATE_TIME:                          /* take final reading */\r\n        sim_throt_ms_stop = sim_os_msec ();\r\n        delta_ms = sim_throt_ms_stop - sim_throt_ms_start;\r\n        delta_inst = sim_gtime () - sim_throt_inst_start;\r\n        if (delta_ms < SIM_THROT_MSMIN) {               /* not enough time? */\r\n            if (delta_inst >= 100000000.0) {            /* too many inst? */\r\n                sim_throt_state = SIM_THROT_STATE_INIT; /* fails in 32b! */\r\n                sim_printf (\"Can't throttle.  Host CPU is too fast with a minimum sleep time of %d ms\\n\", sim_idle_rate_ms);\r\n                sim_set_throt (0, NULL);                /* disable throttling */\r\n                return SCPE_OK;\r\n                }\r\n            sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Not enough time.  %d ms executing %.f %s.\\n\",\r\n                                (int)delta_ms, delta_inst, sim_vm_interval_units);\r\n            sim_throt_wait = (int32)(delta_inst * SIM_THROT_WMUL);\r\n            sim_throt_inst_start = sim_gtime();\r\n            sim_idle_ms_sleep (sim_idle_rate_ms);       /* start on a tick boundary to calibrate */\r\n            sim_throt_ms_start = sim_os_msec ();\r\n            }\r\n        else {                                          /* long enough */\r\n            a_cps = (((double) delta_inst) * 1000.0) / (double) delta_ms;\r\n            if (sim_throt_type == SIM_THROT_MCYC)       /* calc desired cps */\r\n                d_cps = (double) sim_throt_val * 1000000.0;\r\n            else\r\n                if (sim_throt_type == SIM_THROT_KCYC)\r\n                    d_cps = (double) sim_throt_val * 1000.0;\r\n                else\r\n                    d_cps = (sim_throt_peak_cps * sim_throt_val) / 100.0;\r\n            if (d_cps >= a_cps) {\r\n                /* the initial throttling calibration measures a slower cps rate than the desired cps rate, */\r\n                sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() CPU too slow.  Values a_cps = %f, d_cps = %f\\n\",\r\n                                                    a_cps, d_cps);\r\n                /* if the measured rate is well below the measured peak rate? */\r\n                if (sim_throt_peak_cps >= (2.0 * d_cps)) {\r\n                    /* distrust the measured rate and instead use half the peak rate as measured\r\n                       cps rate. */\r\n                    sim_printf (\"*********** WARNING ***********\\n\");\r\n                    sim_printf (\"Host CPU could be too slow to simulate %s %s per second\\n\", sim_fmt_numeric(d_cps), sim_vm_interval_units);\r\n                    sim_printf (\"Host CPU did only simulate %s %s per second\\n\", sim_fmt_numeric(a_cps), sim_vm_interval_units);\r\n                    sim_printf (\"But peak rate was: %s %s per second\\n\", sim_fmt_numeric(sim_throt_peak_cps), sim_vm_interval_units);\r\n\r\n                    a_cps = (sim_throt_peak_cps / 2.0) + 1.0;\r\n\r\n                    sim_printf (\"Assuming rate: %s %s per second\\n\", sim_fmt_numeric(a_cps), sim_vm_interval_units);\r\n                    }\r\n                else {\r\n                    sim_throt_state = SIM_THROT_STATE_INIT;\r\n                    sim_printf (\"*********** WARNING ***********\\n\");\r\n                    sim_printf (\"Host CPU is too slow to simulate %s %s per second\\n\", sim_fmt_numeric(d_cps), sim_vm_interval_units);\r\n                    sim_printf (\"Host CPU did only simulate %s %s per second\\n\", sim_fmt_numeric(a_cps), sim_vm_interval_units);\r\n                    sim_printf (\"Peak rate: %s %s per second\\n\", sim_fmt_numeric(sim_throt_peak_cps), sim_vm_interval_units);\r\n                    sim_printf (\"Throttling disabled.\\n\");\r\n                    sim_set_throt (0, NULL);\r\n                    return SCPE_OK;\r\n                    }\r\n                }\r\n            while (1) {\r\n                sim_throt_wait = (int32)                /* cycles between sleeps */\r\n                    ((a_cps * d_cps * ((double) sim_throt_sleep_time)) /\r\n                     (1000.0 * (a_cps - d_cps)));\r\n                if (sim_throt_wait >= SIM_THROT_WMIN)   /* long enough? */\r\n                    break;\r\n                sim_throt_sleep_time += sim_os_sleep_inc_ms;\r\n                sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Wait too small, increasing sleep time to %d ms.  Values a_cps = %f, d_cps = %f, wait = %d\\n\",\r\n                                                    sim_throt_sleep_time, a_cps, d_cps, sim_throt_wait);\r\n                }\r\n            sim_throt_ms_start = sim_throt_ms_stop;\r\n            sim_throt_inst_start = sim_gtime();\r\n            sim_throt_state = SIM_THROT_STATE_THROTTLE;\r\n            sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Throttle values a_cps = %f, d_cps = %f, wait = %d, sleep = %d ms\\n\",\r\n                                                a_cps, d_cps, sim_throt_wait, sim_throt_sleep_time);\r\n            sim_throt_cps = d_cps;                  /* save the desired rate */\r\n            /* Run through all timers and adjust the calibration for each */\r\n            /* one that is running to reflect the throttle specified rate */\r\n            for (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n                rtc = &rtcs[tmr];\r\n                if (rtc->hz) {                                      /* running? */\r\n                    rtc->currd = (int32)(sim_throt_cps / rtc->hz);/* use throttle calibration */\r\n                    rtc->ticks = rtc->hz - 1;                     /* force clock calibration on next tick */\r\n                    rtc->rtime = sim_throt_ms_start - 1000 + 1000/rtc->hz;/* adjust calibration parameters to reflect throttled rate */\r\n                    rtc->gtime = sim_throt_inst_start - sim_throt_cps + sim_throt_cps/rtc->hz;\r\n                    rtc->nxintv = 1000;\r\n                    rtc->based = rtc->currd;\r\n                    if (rtc->clock_unit)\r\n                        sim_activate_abs (rtc->clock_unit, rtc->currd);/* reschedule next tick */\r\n                    }\r\n                }\r\n            }\r\n        break;\r\n\r\n    case SIM_THROT_STATE_THROTTLE:                      /* throttling */\r\n        sim_idle_ms_sleep (sim_throt_sleep_time);\r\n        delta_ms = sim_os_msec () - sim_throt_ms_start;\r\n        if (delta_ms >= 10000) {                        /* recompute every 10 sec */\r\n            double delta_insts = sim_gtime() - sim_throt_inst_start;\r\n\r\n            a_cps = (delta_insts * 1000.0) / (double) delta_ms;\r\n            if (sim_throt_type != SIM_THROT_SPC) {      /* when not dynamic throttling */\r\n                if (sim_throt_type == SIM_THROT_MCYC)   /* calc desired cps */\r\n                    d_cps = (double) sim_throt_val * 1000000.0;\r\n                else\r\n                    if (sim_throt_type == SIM_THROT_KCYC)\r\n                        d_cps = (double) sim_throt_val * 1000.0;\r\n                    else\r\n                        d_cps = (sim_throt_peak_cps * sim_throt_val) / 100.0;\r\n                if (fabs(100.0 * (d_cps - a_cps) / d_cps) > (double)sim_throt_drift_pct) {\r\n                    sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Recalibrating throttle based on values a_cps = %f, d_cps = %f deviating by %.2f%% from the desired value\\n\",\r\n                                                        a_cps, d_cps, fabs(100.0 * (d_cps - a_cps) / d_cps));\r\n                    if ((a_cps > d_cps) &&                      /* too fast? */\r\n                        ((100.0 * (a_cps - d_cps) / d_cps) > (100 - sim_throt_drift_pct))) {\r\n                        sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Restarting calibrating throttle going too fast: a_cps = %f, d_cps = %f deviating by %.2f%% from the desired value\\n\",\r\n                                                            a_cps, d_cps, fabs(100.0 * (d_cps - a_cps) / d_cps));\r\n                        while (1) {\r\n                            sim_throt_wait = (int32)            /* cycles between sleeps */\r\n                                ((sim_throt_peak_cps * d_cps * ((double) sim_throt_sleep_time)) /\r\n                                 (1000.0 * (sim_throt_peak_cps - d_cps)));\r\n                            if (sim_throt_wait >= SIM_THROT_WMIN)/* long enough? */\r\n                                break;\r\n                            sim_throt_sleep_time += sim_os_sleep_inc_ms;\r\n                            sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Wait too small, increasing sleep time to %d ms.  Values a_cps = %f, d_cps = %f, wait = %d\\n\",\r\n                                                                sim_throt_sleep_time, sim_throt_peak_cps, d_cps, sim_throt_wait);\r\n                            }\r\n                        }\r\n                    else {                                      /* slow or within reasonable range */\r\n                        sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Adjusting wait before sleep interval by %d\\n\",\r\n                                                            (int32)(((d_cps - a_cps) * (double)sim_throt_wait) / d_cps));\r\n                        sim_throt_wait += (int32)(((d_cps - a_cps) * (double)sim_throt_wait) / d_cps);\r\n                        }\r\n                    sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Throttle values a_cps = %f, d_cps = %f, wait = %d, sleep = %d ms\\n\",\r\n                                                        a_cps, d_cps, sim_throt_wait, sim_throt_sleep_time);\r\n                    sim_throt_cps = d_cps;                      /* save the desired rate */\r\n                    sim_throt_ms_start = sim_os_msec ();\r\n                    sim_throt_inst_start = sim_gtime();\r\n                    }\r\n                }\r\n            else {                                      /* record instruction rate */\r\n                sim_throt_cps = (int32)a_cps;\r\n                sim_debug (DBG_THR, &sim_timer_dev, \"sim_throt_svc() Recalibrating Special %d/%u Cycles Per Second of %f\\n\",\r\n                                                    sim_throt_wait, sim_throt_sleep_time, sim_throt_cps);\r\n                sim_throt_inst_start = sim_gtime();\r\n                sim_throt_ms_start = sim_os_msec ();\r\n                }\r\n            }\r\n        break;\r\n        }\r\n\r\nsim_activate (uptr, sim_throt_wait);                    /* reschedule */\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Clock assist activities */\r\nt_stat sim_timer_tick_svc (UNIT *uptr)\r\n{\r\nint32 tmr = (int32)(uptr-sim_timer_units);\r\nt_stat stat;\r\nRTC *rtc = &rtcs[tmr];\r\n\r\nrtc->clock_ticks += 1;\r\nrtc->calib_tick_time += rtc->clock_tick_size;\r\n/*\r\n * Some devices may depend on executing during the same instruction or\r\n * immediately after the clock tick event.  To satisfy this, we directly\r\n * run the clock event here and if it completes successfully, schedule any\r\n * currently coschedule units to run now.  Ticks should never return a\r\n * non-success status, while co-schedule activities might, so they are\r\n * queued to run from sim_process_event\r\n */\r\nsim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_tick_svc(tmr=%d) - scheduling %s - cosched interval: %d\\n\", tmr, sim_uname (rtc->clock_unit), rtc->cosched_interval);\r\nif (rtc->clock_unit->action == NULL)\r\n    return SCPE_IERR;\r\nstat = rtc->clock_unit->action (rtc->clock_unit);\r\n--rtc->cosched_interval;                    /* Countdown ticks */\r\nif (rtc->clock_cosched_queue != QUEUE_LIST_END)\r\n    rtc->clock_cosched_queue->time = rtc->cosched_interval;\r\nif ((stat == SCPE_OK)                               &&\r\n    (rtc->cosched_interval <= 0)                &&\r\n    (rtc->clock_cosched_queue != QUEUE_LIST_END)) {\r\n    UNIT *sptr = rtc->clock_cosched_queue;\r\n    UNIT *cptr = QUEUE_LIST_END;\r\n\r\n    if (rtc->clock_catchup_eligible) {      /* calibration started? */\r\n        double skew;\r\n\r\n        skew = (sim_timenow_double () - (rtc->calib_tick_time+rtc->clock_catchup_base_time));\r\n\r\n        if (fabs(skew) > fabs(rtc->clock_skew_max))\r\n            rtc->clock_skew_max = skew;\r\n        }\r\n    /* Gather any queued events which are scheduled for right now */\r\n    do {\r\n        cptr = rtc->clock_cosched_queue;\r\n        rtc->clock_cosched_queue = cptr->next;\r\n        if (rtc->clock_cosched_queue != QUEUE_LIST_END) {\r\n            rtc->clock_cosched_queue->time += rtc->cosched_interval;\r\n            rtc->cosched_interval = rtc->clock_cosched_queue->time;\r\n            }\r\n        else\r\n            rtc->cosched_interval  = 0;\r\n        } while ((rtc->cosched_interval <= 0) &&\r\n                 (rtc->clock_cosched_queue != QUEUE_LIST_END));\r\n    if (cptr != QUEUE_LIST_END)\r\n        cptr->next = QUEUE_LIST_END;\r\n    /* Now dispatch that list (in order). */\r\n    while (sptr != QUEUE_LIST_END) {\r\n        cptr = sptr;\r\n        sptr = sptr->next;\r\n        cptr->next = NULL;\r\n        cptr->cancel = NULL;\r\n        cptr->time = 0;\r\n        if (cptr->usecs_remaining) {\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"Rescheduling %s after %.0f usecs %s%s\\n\", sim_uname (cptr), cptr->usecs_remaining, (sptr != QUEUE_LIST_END) ? \"- next: \" : \"\", (sptr != QUEUE_LIST_END) ? sim_uname (sptr) : \"\");\r\n            stat = sim_timer_activate_after (cptr, cptr->usecs_remaining);\r\n            }\r\n        else {\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"Activating %s now %s%s\\n\", sim_uname (cptr), (sptr != QUEUE_LIST_END) ? \"- next: \" : \"\", (sptr != QUEUE_LIST_END) ? sim_uname (sptr) : \"\");\r\n            stat = _sim_activate (cptr, 0);\r\n            }\r\n        if (stat != SCPE_OK) {\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"Activating %s failed: %s\\n\", sim_uname (cptr), sim_error_text (stat));\r\n            break;\r\n            }\r\n        }\r\n    }\r\nreturn stat;\r\n}\r\n\r\nt_stat sim_timer_stop_svc (UNIT *uptr)\r\n{\r\nreturn SCPE_STOP;\r\n}\r\n\r\nvoid sim_rtcn_set_debug_basetime (const struct timespec *basetime)\r\n{\r\nsim_timer_uncalib_base_time = *basetime;\r\n}\r\n\r\nconst struct timespec *sim_rtcn_get_debug_basetime (void)\r\n{\r\nreturn &sim_timer_uncalib_base_time;\r\n}\r\n\r\nvoid sim_rtcn_debug_time (struct timespec *now)\r\n{\r\nif (sim_timer_calib_enabled)\r\n    clock_gettime (CLOCK_REALTIME, now);\r\nelse\r\n    _double_to_timespec (now, _timespec_to_double (&sim_timer_uncalib_base_time) + ((double)sim_os_msec () / 1000.0));\r\n}\r\n\r\nvoid sim_rtcn_get_time (struct timespec *now, int tmr)\r\n{\r\nsim_debug (DBG_GET, &sim_timer_dev, \"sim_rtcn_get_time(tmr=%d)\\n\", tmr);\r\nsim_rtcn_debug_time (now);\r\n}\r\n\r\ntime_t sim_get_time (time_t *now)\r\n{\r\nstruct timespec ts_now;\r\n\r\nsim_debug (DBG_GET, &sim_timer_dev, \"sim_get_time()\\n\");\r\nsim_rtcn_get_time (&ts_now, 0);\r\nif (now)\r\n    *now = ts_now.tv_sec;\r\nreturn ts_now.tv_sec;\r\n}\r\n\r\n/*\r\n * If the host system has a relatively large clock tick (as compared to\r\n * the desired simulated hz) ticks will naturally be scheduled late and\r\n * these delays will accumulate.  The net result will be unreasonably\r\n * slow ticks being delivered to the simulated system.\r\n * Additionally, when a simulator is idling and/or throttling, it will\r\n * deliberately call sim_os_ms_sleep and those sleep operations will be\r\n * variable and subject to the host system's minimum sleep resolution\r\n * which can exceed the desired sleep interval and add to the concept\r\n * of slow tick delivery to the simulated system.\r\n * We accomodate these problems and make up for lost ticks by injecting\r\n * catch-up ticks to the simulator.\r\n *\r\n * When necessary, catch-up ticks are scheduled to run under one\r\n * of two conditions:\r\n *   1) after indicated number of instructions in a call by the simulator\r\n *      to sim_rtcn_tick_ack.  sim_rtcn_tick_ack exists to provide a\r\n *      mechanism to inform the simh timer facilities when the simulated\r\n *      system has accepted the most recent clock tick interrupt.\r\n *   2) immediately when the simulator calls sim_idle\r\n *\r\n * catchup ticks are only scheduled (eligible to happen) under these\r\n * conditions after at least one tick has been acknowledged.\r\n *\r\n * The clock tick UNIT that will be scheduled to run for catchup ticks\r\n * must be specified with sim_rtcn_init_unit().\r\n */\r\n\r\n/* _rtcn_tick_catchup_check - idle simulator until next event or for specified interval\r\n\r\n   Inputs:\r\n        RTC =   calibrated timer to check/schedule\r\n        time =  instruction delay for next tick\r\n\r\n   Returns TRUE if a catchup tick has been scheduled\r\n*/\r\n\r\nstatic t_bool _rtcn_tick_catchup_check (RTC *rtc, int32 time)\r\n{\r\nint32 tmr;\r\nt_bool bReturn = FALSE;\r\n\r\nif (!sim_catchup_ticks)\r\n    return FALSE;\r\nif (time == -1) {\r\n    for (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n        rtc = &rtcs[tmr];\r\n        if ((rtc->hz > 0) && rtc->clock_catchup_eligible)\r\n            {\r\n            double tnow = sim_timenow_double();\r\n\r\n            if (tnow > (rtc->clock_catchup_base_time + (rtc->calib_tick_time + rtc->clock_tick_size))) {\r\n                if (!rtc->clock_catchup_pending) {\r\n                    sim_debug (DBG_TIK, &sim_timer_dev, \"_rtcn_tick_catchup_check(%d) - scheduling catchup tick %d for %s which is behind %s\\n\", time, 1 + rtc->ticks, sim_uname (rtc->clock_unit), sim_fmt_secs (tnow - (rtc->clock_catchup_base_time + (rtc->calib_tick_time + rtc->clock_tick_size))));\r\n                    rtc->clock_catchup_pending = TRUE;\r\n                    sim_activate_abs (rtc->timer_unit, 0);\r\n                    bReturn = TRUE;\r\n                    }\r\n                else\r\n                    sim_debug (DBG_TIK, &sim_timer_dev, \"_rtcn_tick_catchup_check(%d) - already pending catchup tick %d for %s which is behind %s\\n\", time, 1 + rtc->ticks, sim_uname (rtc->clock_unit), sim_fmt_secs (tnow - (rtc->clock_catchup_base_time + (rtc->calib_tick_time + rtc->clock_tick_size))));\r\n                }\r\n            }\r\n        }\r\n    }\r\nif ((!rtc->clock_catchup_eligible) &&           /* not eligible yet? */\r\n    (time != -1)) {                             /* called from ack? */\r\n    rtc->clock_catchup_base_time = sim_timenow_double();\r\n    rtc->clock_ticks_tot += rtc->clock_ticks;\r\n    rtc->clock_ticks = 0;\r\n    rtc->calib_tick_time_tot += rtc->calib_tick_time;\r\n    rtc->calib_tick_time = 0.0;\r\n    rtc->clock_catchup_ticks_tot += rtc->clock_catchup_ticks;\r\n    rtc->clock_catchup_ticks = 0;\r\n    rtc->calib_ticks_acked_tot += rtc->calib_ticks_acked;\r\n    rtc->calib_ticks_acked = 0;\r\n    rtc->clock_catchup_eligible = TRUE;\r\n    sim_debug (DBG_QUE, &sim_timer_dev, \"_rtcn_tick_catchup_check() - Enabling catchup ticks for %s\\n\", sim_uname (rtc->clock_unit));\r\n    bReturn = TRUE;\r\n    }\r\nif ((rtc->hz > 0) &&\r\n    rtc->clock_catchup_eligible)\r\n    {\r\n    double tnow = sim_timenow_double();\r\n\r\n    if (tnow > (rtc->clock_catchup_base_time + (rtc->calib_tick_time + rtc->clock_tick_size))) {\r\n        if (!rtc->clock_catchup_pending) {\r\n            sim_debug (DBG_TIK, &sim_timer_dev, \"_rtcn_tick_catchup_check(%d) - scheduling catchup tick %d for %s which is behind %s\\n\", time, 1 + rtc->ticks, sim_uname (rtc->clock_unit), sim_fmt_secs (tnow - (rtc->clock_catchup_base_time + (rtc->calib_tick_time + rtc->clock_tick_size))));\r\n            rtc->clock_catchup_pending = TRUE;\r\n            sim_activate_abs (rtc->timer_unit, (time < 0) ? 0 : time);\r\n            }\r\n        else\r\n            sim_debug (DBG_TIK, &sim_timer_dev, \"_rtcn_tick_catchup_check(%d) - already pending catchup tick %d for %s which is behind %s\\n\", time, 1 + rtc->ticks, sim_uname (rtc->clock_unit), sim_fmt_secs (tnow - (rtc->clock_catchup_base_time + (rtc->calib_tick_time + rtc->clock_tick_size))));\r\n        return TRUE;\r\n        }\r\n    }\r\nreturn bReturn;\r\n}\r\n\r\nt_stat sim_rtcn_tick_ack (uint32 time, int32 tmr)\r\n{\r\nRTC *rtc;\r\n\r\nif ((tmr < 0) || (tmr > SIM_NTIMERS))\r\n    return SCPE_TIMER;\r\nrtc = &rtcs[tmr];\r\nsim_debug (DBG_ACK, &sim_timer_dev, \"sim_rtcn_tick_ack - for %s\\n\", sim_uname (rtc->clock_unit));\r\n_rtcn_tick_catchup_check (rtc, (int32)time);\r\n++rtc->calib_ticks_acked;\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nstatic double _timespec_to_double (struct timespec *time)\r\n{\r\nreturn ((double)time->tv_sec)+(double)(time->tv_nsec)/1000000000.0;\r\n}\r\n\r\nstatic void _double_to_timespec (struct timespec *time, double dtime)\r\n{\r\ndouble int_part = floor(dtime);\r\n\r\ntime->tv_sec = (time_t)int_part;\r\ntime->tv_nsec = (long)((dtime - int_part)*1000000000.0);\r\n}\r\n\r\ndouble sim_timenow_double (void)\r\n{\r\nstruct timespec now;\r\n\r\nsim_rtcn_get_time (&now, 0);\r\nreturn _timespec_to_double (&now);\r\n}\r\n\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\n\r\npthread_t           sim_timer_thread;           /* Wall Clock Timing Thread Id */\r\npthread_cond_t      sim_timer_startup_cond;\r\nt_bool              sim_timer_thread_running = FALSE;\r\n\r\nstatic void *\r\n_timer_thread(void *arg)\r\n{\r\nint sched_policy;\r\nstruct sched_param sched_priority;\r\n\r\n/* Boost Priority for this I/O thread vs the CPU instruction execution\r\n   thread which, in general, won't be readily yielding the processor when\r\n   this thread needs to run */\r\npthread_getschedparam (pthread_self(), &sched_policy, &sched_priority);\r\n++sched_priority.sched_priority;\r\npthread_setschedparam (pthread_self(), sched_policy, &sched_priority);\r\n\r\nsim_debug (DBG_TIM, &sim_timer_dev, \"_timer_thread() - starting\\n\");\r\n\r\npthread_mutex_lock (&sim_timer_lock);\r\nsim_timer_thread_running = TRUE;\r\npthread_cond_signal (&sim_timer_startup_cond);   /* Signal we're ready to go */\r\nwhile (sim_asynch_timer && sim_is_running) {\r\n    struct timespec start_time, stop_time;\r\n    struct timespec due_time;\r\n    double wait_usec;\r\n    int32 inst_delay;\r\n    double inst_per_sec;\r\n    UNIT *uptr, *cptr, *prvptr;\r\n\r\n    if (sim_wallclock_entry) {                          /* something to insert in queue? */\r\n\r\n        sim_debug (DBG_TIM, &sim_timer_dev, \"_timer_thread() - timing %s for %s\\n\",\r\n                   sim_uname(sim_wallclock_entry), sim_fmt_secs (sim_wallclock_entry->a_usec_delay/1000000.0));\r\n\r\n        uptr = sim_wallclock_entry;\r\n        sim_wallclock_entry = NULL;\r\n\r\n        prvptr = NULL;\r\n        for (cptr = sim_wallclock_queue; cptr != QUEUE_LIST_END; cptr = cptr->a_next) {\r\n            if (uptr->a_due_time < cptr->a_due_time)\r\n                break;\r\n            prvptr = cptr;\r\n            }\r\n        if (prvptr == NULL) {                           /* insert at head */\r\n            cptr = uptr->a_next = sim_wallclock_queue;\r\n            sim_wallclock_queue = uptr;\r\n            }\r\n        else {\r\n            cptr = uptr->a_next = prvptr->a_next;       /* insert at prvptr */\r\n            prvptr->a_next = uptr;\r\n            }\r\n        }\r\n\r\n    /* determine wait time */\r\n    if (sim_wallclock_queue != QUEUE_LIST_END) {\r\n        /* due time adjusted by 1/2 a minimal sleep interval */\r\n        /* the goal being to let the last fractional part of the due time */\r\n        /* be done by counting instructions */\r\n        _double_to_timespec (&due_time, sim_wallclock_queue->a_due_time-(((double)sim_idle_rate_ms)*0.0005));\r\n        }\r\n    else {\r\n        due_time.tv_sec = 0x7FFFFFFF;                   /* Sometime when 32 bit time_t wraps */\r\n        due_time.tv_nsec = 0;\r\n        }\r\n    clock_gettime(CLOCK_REALTIME, &start_time);\r\n    wait_usec = floor(1000000.0*(_timespec_to_double (&due_time) - _timespec_to_double (&start_time)));\r\n    if (sim_wallclock_queue == QUEUE_LIST_END)\r\n        sim_debug (DBG_TIM, &sim_timer_dev, \"_timer_thread() - waiting forever\\n\");\r\n    else\r\n        sim_debug (DBG_TIM, &sim_timer_dev, \"_timer_thread() - waiting for %.0f usecs until %.6f for %s\\n\", wait_usec, sim_wallclock_queue->a_due_time, sim_uname(sim_wallclock_queue));\r\n    if ((wait_usec <= 0.0) ||\r\n        (0 != pthread_cond_timedwait (&sim_timer_wake, &sim_timer_lock, &due_time))) {\r\n\r\n        if (sim_wallclock_queue == QUEUE_LIST_END)      /* queue empty? */\r\n            continue;                                   /* wait again */\r\n        inst_per_sec = sim_timer_inst_per_sec ();\r\n\r\n        uptr = sim_wallclock_queue;\r\n        sim_wallclock_queue = uptr->a_next;\r\n        uptr->a_next = NULL;                            /* hygiene */\r\n\r\n        clock_gettime(CLOCK_REALTIME, &stop_time);\r\n        if (1 != sim_timespec_compare (&due_time, &stop_time))\r\n            inst_delay = 0;\r\n        else\r\n            inst_delay = (int32)(inst_per_sec*(_timespec_to_double(&due_time)-_timespec_to_double(&stop_time)));\r\n        sim_debug (DBG_TIM, &sim_timer_dev, \"_timer_thread() - slept %.0fms - activating(%s,%d)\\n\",\r\n                   1000.0*(_timespec_to_double (&stop_time)-_timespec_to_double (&start_time)), sim_uname(uptr), inst_delay);\r\n        sim_activate (uptr, inst_delay);\r\n        }\r\n    else {/* Something wants to adjust the queue since the wait condition was signaled */\r\n        }\r\n    }\r\nsim_timer_thread_running = FALSE;\r\npthread_mutex_unlock (&sim_timer_lock);\r\n\r\nsim_debug (DBG_TIM, &sim_timer_dev, \"_timer_thread() - exiting\\n\");\r\n\r\nreturn NULL;\r\n}\r\n\r\n#endif /* defined(SIM_ASYNCH_CLOCKS) */\r\n\r\n/*\r\n   In the event that there are no active calibrated clock devices,\r\n   no instruction rate calibration will be performed.  This is more\r\n   likely on simpler simulators which don't have a full spectrum of\r\n   standard devices or possibly when a clock device exists but its\r\n   use is optional.\r\n\r\n   Additionally, when a host system has a natural clock tick (\r\n   or minimal sleep time) which is greater than the tick size that\r\n   a simulator wants to run a clock at, we run this clock at the\r\n   rate implied by the host system's minimal sleep time or 50Hz.\r\n\r\n   To solve this we merely run an internal clock at 100Hz.\r\n */\r\n\r\nstatic t_stat sim_timer_clock_tick_svc (UNIT *uptr)\r\n{\r\nsim_debug(DBG_INT, &sim_timer_dev, \"sim_timer_clock_tick_svc()\\n\");\r\nsim_rtcn_calb (sim_int_clk_tps, SIM_INTERNAL_CLK);\r\nsim_activate_after (uptr, 1000000/sim_int_clk_tps);     /* reactivate unit */\r\nreturn SCPE_OK;\r\n}\r\n\r\n/*\r\n  This routine exists to assure that there is a single reliably calibrated\r\n  clock properly counting instruction execution relative to time.  The best\r\n  way to assure reliable calibration is to use a clock which ticks no\r\n  faster than the host system's clock.  This is optimal so that accurate\r\n  time measurements are taken.  If the simulated system doesn't have a\r\n  clock with an appropriate tick rate, an internal clock is run that meets\r\n  this requirement, OR when asynch clocks are enabled, the internal clock\r\n  is always run.\r\n\r\n  Some simulators have clocks that have dynamically programmable tick\r\n  rates. Such a clock is only a reliable candidate to be the calibrated\r\n  clock if it uses a single tick rate rather than changing the tick rate\r\n  on the fly.  Generally most systems like this, under normal conditions\r\n  don't change their tick rates unless they're running something that is\r\n  examining the behavior of the clock system (like a diagnostic).  Under\r\n  these conditions this clock is removed from the potential selection as\r\n  \"the\" calibrated clock all others are relative to and if necessary, an\r\n  internal calibrated clock is selected.  Additionally, any timer device\r\n  which is used in a way where the tick rate changes should never be a\r\n  calibrated clock.  The logic here will detect that and merely force\r\n  that clock to use calibration from the underlying calibrated clock.\r\n */\r\nstatic void _rtcn_configure_calibrated_clock (int32 newtmr)\r\n{\r\nint32 tmr;\r\nRTC *rtc, *crtc;\r\n\r\n/* Look for a timer running slower or the same as the host system clock */\r\nsim_int_clk_tps = MIN(CLK_TPS, sim_os_tick_hz);\r\nfor (tmr=0; tmr<SIM_NTIMERS; tmr++) {\r\n    rtc = &rtcs[tmr];\r\n    if ((rtc->hz) &&                        /* is calibrated AND */\r\n        (rtc->hz <= (uint32)sim_os_tick_hz) && /* slower than OS tick rate AND */\r\n        (rtc->clock_unit))                  /* clock has been registered AND */\r\n        break;\r\n    }\r\nif (tmr == SIM_NTIMERS) {                   /* None found? */\r\n    if ((tmr != newtmr) && (!sim_is_active (&SIM_INTERNAL_UNIT))) {\r\n        if ((sim_calb_tmr != SIM_NTIMERS) &&/* not internal timer? */\r\n            (sim_calb_tmr != -1)) {         /* previously active? */\r\n            crtc = &rtcs[sim_calb_tmr];\r\n            if (!crtc->hz) {                /* now stopped? */\r\n                sim_debug (DBG_CAL, &sim_timer_dev, \"_rtcn_configure_calibrated_clock(newtmr=%d) - Cleaning up stopped timer %s support\\n\", newtmr, sim_uname(crtc->clock_unit));\r\n                /* Migrate any coscheduled devices to the standard queue */\r\n                /* with appropriate usecs_remaining reflecting their currently */\r\n                /* scheduled firing time.  sim_process_event() will coschedule */\r\n                /* appropriately. */\r\n                /* temporarily restore prior hz to get correct remaining time */\r\n                crtc->hz = crtc->last_hz;\r\n                while (crtc->clock_cosched_queue != QUEUE_LIST_END) {\r\n                    UNIT *uptr = crtc->clock_cosched_queue;\r\n                    double usecs_remaining = sim_timer_activate_time_usecs (uptr) - 1;\r\n\r\n                    _sim_coschedule_cancel (uptr);\r\n                    _sim_activate (uptr, 1);\r\n                    uptr->usecs_remaining = usecs_remaining;\r\n                    }\r\n                crtc->hz = 0;                           /* back to 0 */\r\n                if (crtc->clock_unit)\r\n                    sim_cancel (crtc->clock_unit);\r\n                sim_cancel (crtc->timer_unit);\r\n                }\r\n            }\r\n        /* Start the internal timer */\r\n        sim_calb_tmr = SIM_NTIMERS;\r\n        sim_debug (DBG_CAL|DBG_INT, &sim_timer_dev, \"_rtcn_configure_calibrated_clock(newtmr=%d) - Starting Internal Calibrated Timer at %dHz\\n\", newtmr, sim_int_clk_tps);\r\n        SIM_INTERNAL_UNIT.action = &sim_timer_clock_tick_svc;\r\n        SIM_INTERNAL_UNIT.flags = UNIT_IDLE;\r\n        sim_register_internal_device (&sim_int_timer_dev);      /* Register Internal timer device */\r\n        sim_rtcn_init_unit_ticks (&SIM_INTERNAL_UNIT, (int32)((CLK_INIT*CLK_TPS)/sim_int_clk_tps), SIM_INTERNAL_CLK, sim_int_clk_tps);\r\n        SIM_INTERNAL_UNIT.action (&SIM_INTERNAL_UNIT);          /* Force tick to activate timer */\r\n        }\r\n    return;\r\n    }\r\nif ((tmr == newtmr) &&\r\n    (sim_calb_tmr == newtmr))               /* already set? */\r\n    return;\r\nif (sim_calb_tmr == SIM_NTIMERS) {          /* was old the internal timer? */\r\n    sim_debug (DBG_CAL|DBG_INT, &sim_timer_dev, \"_rtcn_configure_calibrated_clock(newtmr=%d) - Stopping Internal Calibrated Timer, New Timer = %d (%dHz)\\n\", newtmr, tmr, rtc->hz);\r\n    rtcs[SIM_NTIMERS].initd = 0;\r\n    rtcs[SIM_NTIMERS].hz = 0;\r\n    sim_register_clock_unit_tmr (NULL, SIM_INTERNAL_CLK);\r\n    sim_cancel (&SIM_INTERNAL_UNIT);\r\n    sim_cancel (&sim_timer_units[SIM_NTIMERS]);\r\n    }\r\nelse {\r\n    if (sim_calb_tmr != -1) {\r\n        crtc = &rtcs[sim_calb_tmr];\r\n        if (crtc->hz == 0) {\r\n            /* Migrate any coscheduled devices to the standard queue */\r\n            /* with appropriate usecs_remaining reflecting their currently */\r\n            /* scheduled firing time.  sim_process_event() will coschedule */\r\n            /* appropriately. */\r\n            /* temporarily restore prior hz to get correct remaining time */\r\n            crtc->hz = crtc->last_hz;\r\n            while (crtc->clock_cosched_queue != QUEUE_LIST_END) {\r\n                UNIT *uptr = crtc->clock_cosched_queue;\r\n                double usecs_remaining = sim_timer_activate_time_usecs (uptr) - 1;\r\n\r\n                _sim_coschedule_cancel (uptr);\r\n                _sim_activate (uptr, 1);\r\n                uptr->usecs_remaining = usecs_remaining;\r\n                }\r\n            crtc->hz = 0;                          /* back to 0 */\r\n            }\r\n        sim_debug (DBG_CAL|DBG_INT, &sim_timer_dev, \"_rtcn_configure_calibrated_clock(newtmr=%d) - Changing Calibrated Timer from %d (%dHz) to %d (%dHz)\\n\", newtmr, sim_calb_tmr, crtc->last_hz, tmr, rtc->hz);\r\n        }\r\n    sim_calb_tmr = tmr;\r\n    }\r\nsim_calb_tmr = tmr;\r\n}\r\n\r\nstatic t_stat sim_timer_clock_reset (DEVICE *dptr)\r\n{\r\nsim_debug (DBG_TRC, &sim_timer_dev, \"sim_timer_clock_reset()\\n\");\r\n_rtcn_configure_calibrated_clock (sim_calb_tmr);\r\nsim_timer_dev.description = &sim_timer_description;\r\nsim_throttle_dev.description = &sim_throttle_description;\r\nsim_int_timer_dev.description = &sim_int_timer_description;\r\nsim_stop_dev.description = &sim_int_stop_description;\r\nif (sim_switches & SWMASK ('P')) {\r\n    sim_cancel (&SIM_INTERNAL_UNIT);\r\n    sim_calb_tmr = -1;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nvoid sim_start_timer_services (void)\r\n{\r\nint32 tmr;\r\nuint32 sim_prompt_time = (sim_gtime () > 0) ?                       /* running? */\r\n                            (sim_timer_calib_enabled ?              /* with calibrated clocks? */\r\n                                (sim_os_msec () - sim_stop_time) :  /*   yes, delta time since stopped */\r\n                                 100) :                             /*   100ms prompt time without calibration */\r\n                            0;                                      /* not running yet so count as 0 */\r\nint32 registered_units = 0;\r\n\r\nsim_time_at_sim_prompt +=  (((double)sim_prompt_time) / 1000.0);\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->initd) {                /* calibrated clock initialized? */\r\n        rtc->rtime += sim_prompt_time;\r\n        rtc->vtime += sim_prompt_time;\r\n        sim_debug (DBG_CAL, &sim_timer_dev, \"sim_start_timer_services(tmr=%d) - adjusting calibration real time by %d ms\\n\", tmr, (int)sim_prompt_time);\r\n        if (rtc->clock_catchup_eligible)\r\n            rtc->calib_tick_time += (((double)sim_prompt_time) / 1000.0);\r\n        if (rtc->clock_unit)\r\n            ++registered_units;\r\n        }\r\n    }\r\nif (sim_calb_tmr == -1) {\r\n    sim_debug (DBG_CAL, &sim_timer_dev, \"sim_start_timer_services() - starting from scratch\\n\");\r\n    _rtcn_configure_calibrated_clock (sim_calb_tmr);\r\n    }\r\nelse {\r\n    if (sim_calb_tmr == SIM_NTIMERS) {\r\n        sim_debug (DBG_CAL, &sim_timer_dev, \"sim_start_timer_services() - restarting internal timer after %d %s\\n\",\r\n                                            sim_internal_timer_time, sim_vm_interval_units);\r\n        sim_activate (&SIM_INTERNAL_UNIT, sim_internal_timer_time);\r\n        }\r\n    }\r\nif (sim_timer_stop_time > sim_gtime())\r\n    sim_activate_abs (&sim_stop_unit, (int32)(sim_timer_stop_time - sim_gtime()));\r\nsim_idle_end_time = sim_gtime();\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\npthread_mutex_lock (&sim_timer_lock);\r\nif (sim_asynch_timer) {\r\n    pthread_attr_t attr;\r\n\r\n    sim_debug (DBG_TRC, &sim_timer_dev, \"sim_start_timer_services() - starting\\n\");\r\n    pthread_cond_init (&sim_timer_startup_cond, NULL);\r\n    pthread_attr_init (&attr);\r\n    pthread_attr_setscope (&attr, PTHREAD_SCOPE_SYSTEM);\r\n    pthread_create (&sim_timer_thread, &attr, _timer_thread, NULL);\r\n    pthread_attr_destroy( &attr);\r\n    pthread_cond_wait (&sim_timer_startup_cond, &sim_timer_lock); /* Wait for thread to stabilize */\r\n    pthread_cond_destroy (&sim_timer_startup_cond);\r\n    }\r\npthread_mutex_unlock (&sim_timer_lock);\r\n#endif\r\n}\r\n\r\nvoid sim_stop_timer_services (void)\r\n{\r\nint tmr;\r\n\r\nsim_debug (DBG_TRC, &sim_timer_dev, \"sim_stop_timer_services(sim_interval=%d, sim_calb_tmr=%d)\\n\", sim_interval, sim_calb_tmr);\r\n\r\nif (sim_interval < 0)\r\n    sim_interval = 0;               /* No catching up after stopping */\r\n\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    int32 accum;\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit) {\r\n        int32 clock_time = _sim_activate_time (rtc->timer_unit);\r\n\r\n        /* Stop clock assist unit and make sure the clock unit has a tick queued */\r\n        if (sim_is_active (rtc->timer_unit)) {\r\n            sim_cancel (rtc->timer_unit);\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"sim_stop_timer_services() - tmr=%d scheduling %s after %d\\n\", tmr, sim_uname (rtc->clock_unit), clock_time);\r\n            _sim_activate (rtc->clock_unit, clock_time);\r\n            }\r\n        /* Move coscheduled units to the standard event queue */\r\n        /* scheduled to fire at the same time as the related */\r\n        /* clock unit is to fire with excess time reflected in */\r\n        /* the unit usecs_remaining value */\r\n        accum = rtc->cosched_interval;\r\n        while (rtc->clock_cosched_queue != QUEUE_LIST_END) {\r\n            UNIT *cptr = rtc->clock_cosched_queue;\r\n            double usecs_remaining = cptr->usecs_remaining;\r\n\r\n            rtc->clock_cosched_queue = cptr->next;\r\n            cptr->next = NULL;\r\n            cptr->cancel = NULL;\r\n            accum += cptr->time;\r\n            cptr->usecs_remaining = 0.0;\r\n            _sim_activate (cptr, clock_time);\r\n            cptr->usecs_remaining = usecs_remaining + floor(1000000.0 * (accum - ((accum > 0) ? 1 : 0)) * rtc->clock_tick_size);\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"sim_stop_timer_services() - tmr=%d scheduling %s after %d and %.0f usecs\\n\", tmr, sim_uname (cptr), clock_time, cptr->usecs_remaining);\r\n            }\r\n        rtc->cosched_interval = 0;\r\n        }\r\n    }\r\n\r\nif (sim_calb_tmr == SIM_NTIMERS) {\r\n    if (!sim_is_active (&SIM_INTERNAL_UNIT))\r\n        sim_debug (DBG_QUE, &sim_timer_dev, \"sim_stop_timer_services() - Unexpected - Internal timer(%d) %s is set but not queued for ticks\\n\", sim_calb_tmr, sim_uname (&SIM_INTERNAL_UNIT));\r\n    else {\r\n        sim_internal_timer_time = sim_activate_time (&SIM_INTERNAL_UNIT) - 1;\r\n        sim_debug (DBG_QUE, &sim_timer_dev, \"sim_stop_timer_services() - Internal timer(%d) %s queued after %d\\n\", sim_calb_tmr, sim_uname (&SIM_INTERNAL_UNIT), sim_internal_timer_time);\r\n        }\r\n    }\r\nsim_cancel (&SIM_INTERNAL_UNIT);                    /* Make sure Internal Timer is stopped */\r\nsim_cancel (&sim_timer_units[SIM_NTIMERS]);\r\nsim_calb_tmr_last = sim_calb_tmr;                   /* Save calibrated timer value for display */\r\nsim_inst_per_sec_last = sim_timer_inst_per_sec ();  /* Save execution rate for display */\r\nsim_stop_time = sim_os_msec ();                     /* record when execution stopped */\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\npthread_mutex_lock (&sim_timer_lock);\r\nif (sim_timer_thread_running) {\r\n    sim_debug (DBG_TRC, &sim_timer_dev, \"sim_stop_timer_services() - stopping\\n\");\r\n    pthread_cond_signal (&sim_timer_wake);\r\n    pthread_mutex_unlock (&sim_timer_lock);\r\n    pthread_join (sim_timer_thread, NULL);\r\n    /* Any wallclock queued events are now migrated to the normal event queue */\r\n    while (sim_wallclock_queue != QUEUE_LIST_END) {\r\n        UNIT *uptr = sim_wallclock_queue;\r\n        double inst_delay_d = uptr->a_due_gtime - sim_gtime ();\r\n        int32 inst_delay;\r\n\r\n        uptr->cancel (uptr);\r\n        if (inst_delay_d < 0.0)\r\n            inst_delay_d = 0.0;\r\n        /* Bound delay to avoid overflow.  */\r\n        /* Long delays are usually canceled before they expire */\r\n        if (inst_delay_d > (double)0x7FFFFFFF)\r\n            inst_delay_d = (double)0x7FFFFFFF;\r\n        inst_delay = (int32)inst_delay_d;\r\n        if ((inst_delay == 0) && (inst_delay_d != 0.0))\r\n            inst_delay = 1;     /* Minimum non-zero delay is 1 instruction */\r\n        _sim_activate (uptr, inst_delay);            /* queue it now */\r\n        }\r\n    }\r\nelse\r\n    pthread_mutex_unlock (&sim_timer_lock);\r\n#endif\r\n}\r\n\r\nt_stat sim_timer_change_asynch (void)\r\n{\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nif (sim_asynch_enabled && sim_asynch_timer)\r\n    sim_start_timer_services ();\r\nelse\r\n    sim_stop_timer_services ();\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Instruction Execution rate. */\r\n/*  returns a double since it is mostly used in double expressions and\r\n    to avoid overflow if/when strange timing delays might produce unexpected results */\r\n\r\ndouble sim_timer_inst_per_sec (void)\r\n{\r\ndouble inst_per_sec = sim_inst_per_sec_last;\r\nRTC *rtc;\r\n\r\nif (sim_calb_tmr == -1)\r\n    return inst_per_sec;\r\nrtc = &rtcs[sim_calb_tmr];\r\ninst_per_sec = ((double)rtc->currd) * rtc->hz;\r\nif (inst_per_sec == 0.0)\r\n    inst_per_sec = ((double)rtc->currd) * sim_int_clk_tps;\r\nreturn inst_per_sec;\r\n}\r\n\r\nt_stat sim_timer_activate (UNIT *uptr, int32 interval)\r\n{\r\nAIO_VALIDATE(uptr);\r\nreturn sim_timer_activate_after (uptr, (double)((interval * 1000000.0) / sim_timer_inst_per_sec ()));\r\n}\r\n\r\nt_stat sim_timer_activate_after (UNIT *uptr, double usec_delay)\r\n{\r\nUNIT *ouptr = uptr;\r\nint inst_delay, tmr;\r\ndouble inst_delay_d, inst_per_usec;\r\nt_stat stat;\r\nRTC *crtc;\r\n\r\nAIO_VALIDATE(uptr);\r\n/* If this is a clock unit, we need to schedule the related timer unit instead */\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == uptr) {\r\n        uptr = rtc->timer_unit;\r\n        break;\r\n        }\r\n    }\r\nif (sim_is_active (uptr))                               /* already active? */\r\n    return SCPE_OK;\r\nif (usec_delay < 0.0) {\r\n    sim_printf (\"sim_timer_activate_after(%s, %.0f usecs) - surprising negative usec value\\n\",\r\n                sim_uname(uptr), usec_delay);\r\n    SIM_SCP_ABORT (\"negative usec value\");\r\n    }\r\nif ((sim_is_running) || (tmr <= SIM_NTIMERS))\r\n    uptr->usecs_remaining = 0.0;\r\nelse {                                      /* defer non timer wallclock activations until a calibrated timer is in effect */\r\n    uptr->usecs_remaining = usec_delay;\r\n    usec_delay = 0.0;\r\n    }\r\n/*\r\n * Handle long delays by aligning with the calibrated timer's calibration\r\n * activities.  Delays which would expire prior to the next calibration\r\n * are specifically scheduled directly based on the the current instruction\r\n * execution rate.  Longer delays are coscheduled to fire on the first tick\r\n * after the next calibration and at that time are either scheduled directly\r\n * or re-coscheduled for the next calibration time, repeating until the total\r\n * desired time has elapsed.\r\n */\r\ninst_per_usec = sim_timer_inst_per_sec () / 1000000.0;\r\ninst_delay_d = floor(inst_per_usec * usec_delay);\r\ninst_delay = (int32)inst_delay_d;\r\nif ((inst_delay == 0) && (usec_delay != 0))\r\n    inst_delay_d = inst_delay = 1;  /* Minimum non-zero delay is 1 instruction */\r\nif (uptr->usecs_remaining != 0.0)   /* No calibrated timer yet, wait one cycle */\r\n    inst_delay_d = inst_delay = 1;  /* Minimum non-zero delay is 1 instruction */\r\nif (sim_calb_tmr != -1) {\r\n    crtc = &rtcs[sim_calb_tmr];\r\n    if (crtc->hz) {                 /* Calibrated Timer available? */\r\n        int32 inst_til_tick = sim_activate_time (crtc->timer_unit) - 1;\r\n        int32 ticks_til_calib = crtc->hz - crtc->ticks;\r\n        double usecs_per_tick = floor (1000000.0 / crtc->hz);\r\n        int32 inst_til_calib = inst_til_tick + ((ticks_til_calib - 1) * crtc->currd);\r\n        uint32 usecs_til_calib = (uint32)ceil(inst_til_calib / inst_per_usec);\r\n\r\n        if ((uptr != crtc->timer_unit) &&                   /* Not scheduling calibrated timer */\r\n            (inst_til_tick > 0)) {                          /* and tick not pending? */\r\n            if (inst_delay_d > (double)inst_til_calib) {    /* long wait? */\r\n                stat = sim_clock_coschedule_tmr (uptr, sim_calb_tmr, ticks_til_calib - 1);\r\n                uptr->usecs_remaining = (stat == SCPE_OK) ? usec_delay - usecs_til_calib : 0.0;\r\n                sim_debug (DBG_TIM, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - coscheduling with with calibrated timer(%d), ticks=%d, usecs_remaining=%.0f usecs, inst_til_tick=%d, ticks_til_calib=%d, usecs_til_calib=%u\\n\",\r\n                           sim_uname(uptr), usec_delay, sim_calb_tmr, ticks_til_calib, uptr->usecs_remaining, inst_til_tick, ticks_til_calib, usecs_til_calib);\r\n                sim_debug (DBG_CHK, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - result = %.0f usecs, %.0f usecs\\n\",\r\n                           sim_uname(uptr), usec_delay, sim_timer_activate_time_usecs (ouptr), sim_timer_activate_time_usecs (uptr));\r\n                return stat;\r\n                }\r\n            if ((usec_delay > (2 * usecs_per_tick)) &&\r\n                (ticks_til_calib > 1)) {                    /* long wait? */\r\n                double usecs_til_tick = floor (inst_til_tick / inst_per_usec);\r\n\r\n                stat = sim_clock_coschedule_tmr (uptr, sim_calb_tmr, 0);\r\n                uptr->usecs_remaining = (stat == SCPE_OK) ? usec_delay - usecs_til_tick : 0.0;\r\n                sim_debug (DBG_TIM, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - coscheduling with with calibrated timer(%d), ticks=%d, usecs_remaining=%.0f usecs, inst_til_tick=%d, usecs_til_tick=%.0f\\n\",\r\n                           sim_uname(uptr), usec_delay, sim_calb_tmr, 0, uptr->usecs_remaining, inst_til_tick, usecs_til_tick);\r\n                sim_debug (DBG_CHK, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - result = %.0f usecs, %.0f usecs\\n\",\r\n                           sim_uname(uptr), usec_delay, sim_timer_activate_time_usecs (ouptr), sim_timer_activate_time_usecs (uptr));\r\n                if (usecs_til_tick > usec_delay) {\r\n                    sim_printf (\"sim_timer_activate_after(%s, %.0f usecs) - coscheduling with with calibrated timer(%d), ticks=%d, usecs_remaining=%.0f usecs, inst_til_tick=%d, usecs_til_tick=%.0f\\n\",\r\n                                sim_uname(uptr), usec_delay, sim_calb_tmr, 0, uptr->usecs_remaining, inst_til_tick, usecs_til_tick);\r\n                    SIM_SCP_ABORT (\"unexpected negative time remnant\");\r\n                    }\r\n                return stat;\r\n                }\r\n            }\r\n        }\r\n    }\r\n/*\r\n * We're here to schedule if:\r\n * No Calibrated Timer, OR\r\n * Scheduling the Calibrated Timer OR\r\n * Short delay\r\n */\r\n/*\r\n * Bound delay to avoid overflow.\r\n * Long delays are usually canceled before they expire, however bounding the\r\n * delay will cause sim_activate_time to return inconsistent results when\r\n * truncation has happened.\r\n */\r\nif (inst_delay_d > (double)0x7fffffff)\r\n    inst_delay_d = (double)0x7fffffff;              /* Bound delay to avoid overflow.  */\r\ninst_delay = (int32)inst_delay_d;\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nif ((sim_asynch_timer) &&\r\n    (usec_delay > sim_idle_rate_ms*1000.0)) {\r\n    double d_now = sim_timenow_double ();\r\n    UNIT *cptr, *prvptr;\r\n\r\n    uptr->a_usec_delay = usec_delay;\r\n    uptr->a_due_time = d_now + (usec_delay / 1000000.0);\r\n    uptr->a_due_gtime = sim_gtime () + (sim_timer_inst_per_sec () * (usec_delay / 1000000.0));\r\n    uptr->cancel = &_sim_wallclock_cancel;              /* bind cleanup method */\r\n    uptr->a_is_active = &_sim_wallclock_is_active;\r\n    if (tmr <= SIM_NTIMERS) {                            /* Timer Unit? */\r\n        RTC *rtc = &rtcs[tmr];\r\n\r\n        rtc->clock_unit->cancel = &_sim_wallclock_cancel;\r\n        rtc->clock_unit->a_is_active = &_sim_wallclock_is_active;\r\n        }\r\n\r\n    sim_debug (DBG_TIM, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - queueing wallclock addition at %.6f\\n\",\r\n               sim_uname(uptr), usec_delay, uptr->a_due_time);\r\n\r\n    pthread_mutex_lock (&sim_timer_lock);\r\n    for (cptr = sim_wallclock_queue, prvptr = NULL; cptr != QUEUE_LIST_END; cptr = cptr->a_next) {\r\n        if (uptr->a_due_time < cptr->a_due_time)\r\n            break;\r\n        prvptr = cptr;\r\n        }\r\n    if (prvptr == NULL) {                           /* inserting at head */\r\n        uptr->a_next = QUEUE_LIST_END;              /* Temporarily mark as active */\r\n        if (sim_timer_thread_running) {\r\n            while (sim_wallclock_entry) {               /* wait for any prior entry has been digested */\r\n                sim_debug (DBG_TIM, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - queue insert entry %s busy waiting for 1ms\\n\",\r\n                           sim_uname(uptr), usec_delay, sim_uname(sim_wallclock_entry));\r\n                pthread_mutex_unlock (&sim_timer_lock);\r\n                sim_os_ms_sleep (1);\r\n                pthread_mutex_lock (&sim_timer_lock);\r\n                }\r\n            }\r\n        sim_wallclock_entry = uptr;\r\n        pthread_mutex_unlock (&sim_timer_lock);\r\n        pthread_cond_signal (&sim_timer_wake);      /* wake the timer thread to deal with it */\r\n        return SCPE_OK;\r\n        }\r\n    else {                                          /* inserting at prvptr */\r\n        uptr->a_next = prvptr->a_next;\r\n        prvptr->a_next = uptr;\r\n        pthread_mutex_unlock (&sim_timer_lock);\r\n        return SCPE_OK;\r\n        }\r\n    }\r\n#endif\r\nstat = _sim_activate (uptr, inst_delay);                /* queue it now */\r\nsim_debug (DBG_TIM, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - queue addition at %d - remnant: %.0f\\n\",\r\n           sim_uname(uptr), usec_delay, inst_delay, uptr->usecs_remaining);\r\nsim_debug (DBG_CHK, &sim_timer_dev, \"sim_timer_activate_after(%s, %.0f usecs) - result = %.0f usecs, %.0f usecs\\n\",\r\n           sim_uname(uptr), usec_delay, sim_timer_activate_time_usecs (ouptr), sim_timer_activate_time_usecs (uptr));\r\nreturn stat;\r\n}\r\n\r\n/* Clock coscheduling routines */\r\n\r\nt_stat sim_register_clock_unit_tmr (UNIT *uptr, int32 tmr)\r\n{\r\nRTC *rtc;\r\n\r\nif (tmr == SIM_INTERNAL_CLK)\r\n    tmr = SIM_NTIMERS;\r\nelse {\r\n    if ((tmr < 0) || (tmr > SIM_NTIMERS))\r\n        return SCPE_IERR;\r\n    }\r\nrtc = &rtcs[tmr];\r\nif (NULL == uptr) {                         /* deregistering? */\r\n    /* Migrate any coscheduled devices to the standard queue */\r\n    /* they will fire and subsequently requeue themselves */\r\n    while (rtc->clock_cosched_queue != QUEUE_LIST_END) {\r\n        UNIT *uptr = rtc->clock_cosched_queue;\r\n        double usecs_remaining = sim_timer_activate_time_usecs (uptr);\r\n\r\n        _sim_coschedule_cancel (uptr);\r\n        _sim_activate (uptr, 1);\r\n        uptr->usecs_remaining = usecs_remaining;\r\n        }\r\n    if (rtc->clock_unit) {\r\n        sim_cancel (rtc->clock_unit);\r\n        rtc->clock_unit->dynflags &= ~UNIT_TMR_UNIT;\r\n        }\r\n    rtc->clock_unit = NULL;\r\n    sim_cancel (rtc->timer_unit);\r\n    return SCPE_OK;\r\n    }\r\nif (rtc->clock_unit == NULL)\r\n    rtc->clock_cosched_queue = QUEUE_LIST_END;\r\nrtc->clock_unit = uptr;\r\nuptr->dynflags |= UNIT_TMR_UNIT;\r\nrtc->timer_unit->flags = ((tmr == SIM_NTIMERS) ? 0 : UNIT_DIS) |\r\n                          (rtc->clock_unit ? UNIT_IDLE : 0);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Default timer is 0, otherwise use a calibrated one if it exists */\r\nint32 sim_rtcn_calibrated_tmr (void)\r\n{\r\nreturn ((rtcs[0].currd && rtcs[0].hz) ? 0 : ((sim_calb_tmr != -1) ? sim_calb_tmr : 0));\r\n}\r\n\r\nint32 sim_rtcn_tick_size (int32 tmr)\r\n{\r\nRTC *rtc = &rtcs[tmr];\r\n\r\nreturn (rtc->currd) ? rtc->currd : 10000;\r\n}\r\n\r\nt_stat sim_register_clock_unit (UNIT *uptr)\r\n{\r\nreturn sim_register_clock_unit_tmr (uptr, 0);\r\n}\r\n\r\nt_stat sim_clock_coschedule (UNIT *uptr, int32 interval)\r\n{\r\nint32 tmr = sim_rtcn_calibrated_tmr ();\r\nint32 ticks = (interval + (sim_rtcn_tick_size (tmr)/2))/sim_rtcn_tick_size (tmr);/* Convert to ticks */\r\n\r\nsim_debug (DBG_QUE, &sim_timer_dev, \"sim_clock_coschedule(%s, interval=%d, ticks=%d)\\n\", sim_uname(uptr), interval, ticks);\r\nreturn sim_clock_coschedule_tmr (uptr, tmr, ticks);\r\n}\r\n\r\nt_stat sim_clock_coschedule_abs (UNIT *uptr, int32 interval)\r\n{\r\nsim_debug (DBG_QUE, &sim_timer_dev, \"sim_clock_coschedule_abs(%s, interval=%d)\\n\", sim_uname(uptr), interval);\r\nsim_cancel (uptr);\r\nreturn sim_clock_coschedule (uptr, interval);\r\n}\r\n\r\n/* ticks - 0 means on the next tick, 1 means the second tick, etc.  */\r\n\r\nt_stat sim_clock_coschedule_tmr (UNIT *uptr, int32 tmr, int32 ticks)\r\n{\r\nRTC *rtc;\r\n\r\nif (ticks < 0)\r\n    return SCPE_ARG;\r\nif (sim_is_active (uptr)) {\r\n    sim_debug (DBG_TIM, &sim_timer_dev, \"sim_clock_coschedule_tmr(%s, tmr=%d, ticks=%d) - already active\\n\", sim_uname (uptr), tmr, ticks);\r\n    return SCPE_OK;\r\n    }\r\nif (tmr == SIM_INTERNAL_CLK)\r\n    tmr = SIM_NTIMERS;\r\nelse {\r\n    if ((tmr < 0) || (tmr > SIM_NTIMERS))\r\n        return sim_activate (uptr, MAX(1, ticks) * 10000);\r\n    }\r\nrtc = &rtcs[tmr];\r\nif ((NULL == rtc->clock_unit) || (rtc->hz == 0)) {\r\n    sim_debug (DBG_TIM, &sim_timer_dev, \"sim_clock_coschedule_tmr(%s, tmr=%d, ticks=%d) - no clock activating after %d %s\\n\", sim_uname (uptr), tmr, ticks, ticks * (rtc->currd ? rtc->currd : rtcs[sim_rtcn_calibrated_tmr ()].currd), sim_vm_interval_units);\r\n    return sim_activate (uptr, ticks * (rtc->currd ? rtc->currd : rtcs[sim_rtcn_calibrated_tmr ()].currd));\r\n    }\r\nelse {\r\n    UNIT *cptr, *prvptr;\r\n    int32 accum;\r\n\r\n    if (rtc->clock_cosched_queue != QUEUE_LIST_END)\r\n        rtc->clock_cosched_queue->time = rtc->cosched_interval;\r\n    prvptr = NULL;\r\n    accum = 0;\r\n    for (cptr = rtc->clock_cosched_queue; cptr != QUEUE_LIST_END; cptr = cptr->next) {\r\n        if (ticks < (accum + cptr->time))\r\n            break;\r\n        accum += cptr->time;\r\n        prvptr = cptr;\r\n        }\r\n    if (prvptr == NULL) {\r\n        cptr = uptr->next = rtc->clock_cosched_queue;\r\n        rtc->clock_cosched_queue = uptr;\r\n        }\r\n    else {\r\n        cptr = uptr->next = prvptr->next;\r\n        prvptr->next = uptr;\r\n        }\r\n    uptr->time = ticks - accum;\r\n    if (cptr != QUEUE_LIST_END)\r\n        cptr->time = cptr->time - uptr->time;\r\n    uptr->cancel = &_sim_coschedule_cancel;             /* bind cleanup method */\r\n    if (uptr == rtc->clock_cosched_queue)\r\n        rtc->cosched_interval = rtc->clock_cosched_queue->time;\r\n    sim_debug (DBG_QUE, &sim_timer_dev, \"sim_clock_coschedule_tmr(%s, tmr=%d, ticks=%d, hz=%d) - queueing for clock co-schedule, interval now: %d\\n\", sim_uname (uptr), tmr, ticks, rtc->hz, rtc->cosched_interval);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat sim_clock_coschedule_tmr_abs (UNIT *uptr, int32 tmr, int32 ticks)\r\n{\r\nsim_cancel (uptr);\r\nreturn sim_clock_coschedule_tmr (uptr, tmr, ticks);\r\n}\r\n\r\n/* Cancel a unit on the coschedule queue */\r\nstatic t_bool _sim_coschedule_cancel (UNIT *uptr)\r\n{\r\nAIO_UPDATE_QUEUE;\r\nif (uptr->next) {                           /* On a queue? */\r\n    int tmr;\r\n    UNIT *nptr;\r\n\r\n    for (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n        RTC *rtc = &rtcs[tmr];\r\n\r\n        if (rtc->clock_unit) {\r\n            if (uptr == rtc->clock_cosched_queue) {\r\n                nptr = rtc->clock_cosched_queue = uptr->next;\r\n                uptr->next = NULL;\r\n                }\r\n            else {\r\n                UNIT *cptr;\r\n\r\n                for (cptr = rtc->clock_cosched_queue;\r\n                     (cptr != QUEUE_LIST_END);\r\n                     cptr = cptr->next) {\r\n                    if (cptr->next == uptr) {\r\n                        nptr = cptr->next = (uptr)->next;\r\n                        uptr->next = NULL;\r\n                        break;\r\n                        }\r\n                    }\r\n                }\r\n            if (uptr->next == NULL) {           /* found? */\r\n                uptr->cancel = NULL;\r\n                uptr->usecs_remaining = 0;\r\n                if (nptr != QUEUE_LIST_END)\r\n                    nptr->time += uptr->time;\r\n                sim_debug (DBG_QUE, &sim_timer_dev, \"Canceled Clock Coscheduled Event for %s\\n\", sim_uname(uptr));\r\n                return TRUE;\r\n                }\r\n            }\r\n        }\r\n    }\r\nreturn FALSE;\r\n}\r\n\r\nt_bool sim_timer_is_active (UNIT *uptr)\r\n{\r\nint32 tmr;\r\n\r\nif (!(uptr->dynflags & UNIT_TMR_UNIT))\r\n    return FALSE;\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == uptr)\r\n        return sim_is_active (&sim_timer_units[tmr]);\r\n    }\r\nreturn FALSE;\r\n}\r\n\r\nt_bool sim_timer_cancel (UNIT *uptr)\r\n{\r\nint32 tmr;\r\n\r\nif (!(uptr->dynflags & UNIT_TMR_UNIT))\r\n    return SCPE_IERR;\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == uptr)\r\n        return sim_cancel (&sim_timer_units[tmr]);\r\n    }\r\nreturn SCPE_IERR;\r\n}\r\n\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nstatic t_bool _sim_wallclock_cancel (UNIT *uptr)\r\n{\r\nint32 tmr;\r\nt_bool b_return = FALSE;\r\n\r\nAIO_UPDATE_QUEUE;\r\npthread_mutex_lock (&sim_timer_lock);\r\n/* If this is a clock unit, we need to cancel both this and the related timer unit */\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == uptr) {\r\n        uptr = &sim_timer_units[tmr];\r\n        break;\r\n        }\r\n    }\r\nif (uptr->a_next) {\r\n    UNIT *cptr;\r\n\r\n    if (uptr == sim_wallclock_entry) {  /* Pending on the queue? */\r\n        sim_wallclock_entry = NULL;\r\n        uptr->a_next = NULL;\r\n        sim_debug (DBG_QUE, &sim_timer_dev, \"Canceled Queue Pending Timer Event for %s\\n\", sim_uname(uptr));\r\n        }\r\n    else {\r\n        if (uptr == sim_wallclock_queue) {\r\n            sim_wallclock_queue = uptr->a_next;\r\n            uptr->a_next = NULL;\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"Canceled Top Timer Event for %s\\n\", sim_uname(uptr));\r\n            pthread_cond_signal (&sim_timer_wake);\r\n            }\r\n        else {\r\n            for (cptr = sim_wallclock_queue;\r\n                (cptr != QUEUE_LIST_END);\r\n                cptr = cptr->a_next) {\r\n                if (cptr->a_next == (uptr)) {\r\n                    cptr->a_next = (uptr)->a_next;\r\n                    uptr->a_next = NULL;\r\n                    sim_debug (DBG_QUE, &sim_timer_dev, \"Canceled Timer Event for %s\\n\", sim_uname(uptr));\r\n                    break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    if (uptr->a_next == NULL) {         /* Was canceled? */\r\n        uptr->a_due_time = uptr->a_due_gtime = uptr->a_usec_delay = 0;\r\n        uptr->cancel = NULL;\r\n        uptr->a_is_active = NULL;\r\n        if (tmr <= SIM_NTIMERS) {                        /* Timer Unit? */\r\n            RTC *rtc = &rtcs[tmr];\r\n\r\n            rtc->clock_unit->cancel = NULL;\r\n            rtc->clock_unit->a_is_active = NULL;\r\n            }\r\n        b_return = TRUE;\r\n        }\r\n    }\r\npthread_mutex_unlock (&sim_timer_lock);\r\nreturn b_return;\r\n}\r\n\r\nstatic t_bool _sim_wallclock_is_active (UNIT *uptr)\r\n{\r\nint32 tmr;\r\n\r\nif (uptr->a_next)\r\n    return TRUE;\r\n/* If this is a clock unit, we need to examine the related timer unit instead */\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == uptr)\r\n        return (sim_timer_units[tmr].a_next != NULL);\r\n    }\r\nreturn FALSE;\r\n}\r\n#endif /* defined(SIM_ASYNCH_CLOCKS) */\r\n\r\nint32 _sim_timer_activate_time (UNIT *uptr)\r\n{\r\nUNIT *cptr;\r\nint32 tmr;\r\n\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nif (uptr->a_is_active == &_sim_wallclock_is_active) {\r\n    double d_result;\r\n\r\n    pthread_mutex_lock (&sim_timer_lock);\r\n    if (uptr == sim_wallclock_entry) {\r\n        d_result = uptr->a_due_gtime - sim_gtime ();\r\n        if (d_result < 0.0)\r\n            d_result = 0.0;\r\n        if (d_result > (double)0x7FFFFFFE)\r\n            d_result = (double)0x7FFFFFFE;\r\n        pthread_mutex_unlock (&sim_timer_lock);\r\n        return ((int32)d_result) + 1;\r\n        }\r\n    for (cptr = sim_wallclock_queue;\r\n         cptr != QUEUE_LIST_END;\r\n         cptr = cptr->a_next)\r\n        if (uptr == cptr) {\r\n            d_result = uptr->a_due_gtime - sim_gtime ();\r\n            if (d_result < 0.0)\r\n                d_result = 0.0;\r\n            if (d_result > (double)0x7FFFFFFE)\r\n                d_result = (double)0x7FFFFFFE;\r\n            pthread_mutex_unlock (&sim_timer_lock);\r\n            return ((int32)d_result) + 1;\r\n            }\r\n    pthread_mutex_unlock (&sim_timer_lock);\r\n    }\r\nif (uptr->a_next)\r\n    return uptr->a_event_time + 1;\r\n#endif /* defined(SIM_ASYNCH_CLOCKS) */\r\n\r\nif (uptr->cancel == &_sim_coschedule_cancel) {\r\n    for (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n        int32 accum = 0;\r\n        RTC *rtc = &rtcs[tmr];\r\n\r\n\r\n        for (cptr = rtc->clock_cosched_queue; cptr != QUEUE_LIST_END; cptr = cptr->next) {\r\n            if (cptr == rtc->clock_cosched_queue) {\r\n                if (rtc->cosched_interval > 0)\r\n                    accum += rtc->cosched_interval;\r\n                }\r\n            else\r\n                accum += cptr->time;\r\n            if (cptr == uptr)\r\n                return (rtc->currd * accum) + sim_activate_time (&sim_timer_units[tmr]);\r\n            }\r\n        }\r\n    }\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    if ((uptr == &sim_timer_units[tmr]) && (uptr->next)){\r\n        return _sim_activate_time (&sim_timer_units[tmr]);\r\n        }\r\n    }\r\nreturn -1;                                          /* Not found. */\r\n}\r\n\r\ndouble sim_timer_activate_time_usecs (UNIT *uptr)\r\n{\r\nUNIT *cptr;\r\nint32 tmr;\r\ndouble result = -1.0;\r\n\r\n/* If this is a clock unit, we need to return the related clock assist unit instead */\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->clock_unit == uptr) {\r\n        uptr = &sim_timer_units[tmr];\r\n        break;\r\n        }\r\n    }\r\n\r\nif (!sim_is_active (uptr)) {\r\n    sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) - not active\\n\", sim_uname (uptr));\r\n    return result;\r\n    }\r\n#if defined(SIM_ASYNCH_CLOCKS)\r\nif (uptr->a_is_active == &_sim_wallclock_is_active) {\r\n    pthread_mutex_lock (&sim_timer_lock);\r\n    if (uptr == sim_wallclock_entry) {\r\n        result = uptr->a_due_gtime - sim_gtime ();\r\n        if (result < 0.0)\r\n            result = 0.0;\r\n        pthread_mutex_unlock (&sim_timer_lock);\r\n        result = uptr->usecs_remaining + (1000000.0 * (result / sim_timer_inst_per_sec ())) + 1;\r\n        sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) wallclock_entry - %.0f usecs, inst_per_sec=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec ());\r\n        return result;\r\n        }\r\n    for (cptr = sim_wallclock_queue;\r\n         cptr != QUEUE_LIST_END;\r\n         cptr = cptr->a_next)\r\n        if (uptr == cptr) {\r\n            result = uptr->a_due_gtime - sim_gtime ();\r\n            if (result < 0.0)\r\n                result = 0.0;\r\n            pthread_mutex_unlock (&sim_timer_lock);\r\n            result = uptr->usecs_remaining + (1000000.0 * (result / sim_timer_inst_per_sec ())) + 1;\r\n            sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) wallclock - %.0f usecs, inst_per_sec=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec ());\r\n            return result;\r\n            }\r\n    pthread_mutex_unlock (&sim_timer_lock);\r\n    }\r\nif (uptr->a_next) {\r\n    result = uptr->usecs_remaining + (1000000.0 * (uptr->a_event_time / sim_timer_inst_per_sec ())) + 1;\r\n    sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) asynch - %.0f usecs, inst_per_sec=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec ());\r\n    return result;\r\n    }\r\n#endif /* defined(SIM_ASYNCH_CLOCKS) */\r\n\r\nif (uptr->cancel == &_sim_coschedule_cancel) {\r\n    for (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n        int32 accum = 0;\r\n        RTC *rtc = &rtcs[tmr];\r\n\r\n        for (cptr = rtc->clock_cosched_queue; cptr != QUEUE_LIST_END; cptr = cptr->next) {\r\n            if (cptr == rtc->clock_cosched_queue) {\r\n                if (rtc->cosched_interval > 0)\r\n                    accum += rtc->cosched_interval;\r\n                }\r\n            else\r\n                accum += cptr->time;\r\n            if (cptr == uptr) {\r\n                result = uptr->usecs_remaining + ceil(1000000.0 * ((rtc->currd * accum) + sim_activate_time (&sim_timer_units[tmr]) - 1) / sim_timer_inst_per_sec ());\r\n                sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) coscheduled - %.0f usecs, inst_per_sec=%.0f, tmr=%d, ticksize=%d, ticks=%d, inst_til_tick=%d, usecs_remaining=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec (), tmr, rtc->currd, accum, sim_activate_time (&sim_timer_units[tmr]) - 1, uptr->usecs_remaining);\r\n                return result;\r\n                }\r\n            }\r\n        }\r\n    }\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if ((uptr == rtc->clock_unit) && (uptr->next)) {\r\n        result = rtc->clock_unit->usecs_remaining + (1000000.0 * (sim_activate_time (&sim_timer_units[tmr]) - 1)) / sim_timer_inst_per_sec ();\r\n        sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) clock - %.0f usecs, inst_per_sec=%.0f, usecs_remaining=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec (), uptr->usecs_remaining);\r\n        return result;\r\n        }\r\n    if ((uptr == &sim_timer_units[tmr]) && (uptr->next)){\r\n        result = uptr->usecs_remaining + (1000000.0 * (sim_activate_time (uptr) - 1)) / sim_timer_inst_per_sec ();\r\n        sim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) clock - %.0f usecs, inst_per_sec=%.0f, usecs_remaining=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec (), uptr->usecs_remaining);\r\n        return result;\r\n        }\r\n    }\r\nresult = uptr->usecs_remaining + (1000000.0 * (sim_activate_time (uptr) - 1)) / sim_timer_inst_per_sec ();\r\nsim_debug (DBG_QUE, &sim_timer_dev, \"sim_timer_activate_time_usecs(%s) clock - %.0f usecs, inst_per_sec=%.0f, usecs_remaining=%.0f\\n\", sim_uname (uptr), result, sim_timer_inst_per_sec (), uptr->usecs_remaining);\r\nreturn result;                                          /* Not found. */\r\n}\r\n\r\n/* read only memory delayed support\r\n\r\n   Some simulation activities need a 'regulated' memory access\r\n   time to meet timing assumptions in the code being executed.\r\n\r\n   The default calibration determines a way to limit activities\r\n   to 1MHz for each call to sim_rom_read_with_delay().  If a\r\n   simulator needs a different delay factor, the 1 MHz initial\r\n   value can be queried with sim_get_rom_delay_factor() and the\r\n   result can be adjusted as necessary and the operating delay\r\n   can be set with sim_set_rom_delay_factor().\r\n*/\r\n\r\nSIM_NOINLINE static int32 _rom_swapb(int32 val)\r\n{\r\nreturn ((val << 24) & 0xff000000) | (( val << 8) & 0xff0000) |\r\n    ((val >> 8) & 0xff00) | ((val >> 24) & 0xff);\r\n}\r\n\r\nstatic volatile int32 rom_loopval = 0;\r\n\r\nSIM_NOINLINE int32 sim_rom_read_with_delay (int32 val)\r\n{\r\nuint32 i, l = sim_rom_delay;\r\n\r\nfor (i = 0; i < l; i++)\r\n    rom_loopval |= (rom_loopval + val) ^ _rom_swapb (_rom_swapb (rom_loopval + val));\r\nreturn val + rom_loopval;\r\n}\r\n\r\nSIM_NOINLINE uint32 sim_get_rom_delay_factor (void)\r\n{\r\n/* Calibrate the loop delay factor at startup.\r\n   Do this 4 times and use the largest value computed.\r\n   The goal here is to come up with a delay factor which will throttle\r\n   a 6 byte delay loop running from ROM address space to execute\r\n   1 instruction per usec */\r\n\r\nif (sim_rom_delay == 0) {\r\n    uint32 i, ts, te, c = 10000, samples = 0;\r\n    while (1) {\r\n        c = c * 2;\r\n        te = sim_os_msec();\r\n        while (te == (ts = sim_os_msec ()));            /* align on ms tick */\r\n\r\n/* This is merely a busy wait with some \"work\" that won't get optimized\r\n   away by a good compiler. loopval always is zero.  To avoid smart compilers,\r\n   the loopval variable is referenced in the function arguments so that the\r\n   function expression is not loop invariant.  It also must be referenced\r\n   by subsequent code to avoid the whole computation being eliminated. */\r\n\r\n        for (i = 0; i < c; i++)\r\n            rom_loopval |= (rom_loopval + ts) ^ _rom_swapb (_rom_swapb (rom_loopval + ts));\r\n        te = sim_os_msec ();\r\n        if ((te - ts) < 50)                         /* sample big enough? */\r\n            continue;\r\n        if (sim_rom_delay < (rom_loopval + (c / (te - ts) / 1000) + 1))\r\n            sim_rom_delay = rom_loopval + (c / (te - ts) / 1000) + 1;\r\n        if (++samples >= 4)\r\n            break;\r\n        c = c / 2;\r\n        }\r\n    if (sim_rom_delay < 5)\r\n        sim_rom_delay = 5;\r\n    }\r\nreturn sim_rom_delay;\r\n}\r\n\r\nvoid sim_set_rom_delay_factor (uint32 delay)\r\n{\r\nsim_rom_delay = delay;\r\n}\r\n\r\n/* sim_timer_precalibrate_execution_rate\r\n *\r\n * The point of this routine is to run a bunch of simulator provided\r\n * instructions that don't do anything, but run in an effective loop.\r\n * That loop is run for some 5 million instructions and based on\r\n * the time those 5 million instructions take to execute the effective\r\n * execution rate is determined.  That rate is used to avoid the initial\r\n * 3 to 5 seconds that normal clock calibration takes.\r\n *\r\n */\r\nvoid sim_timer_precalibrate_execution_rate (void)\r\n{\r\nconst char **cmd = sim_clock_precalibrate_commands;\r\nuint32 start, end;\r\nint32 saved_switches = sim_switches;\r\nint32 tmr;\r\nUNIT precalib_unit = { UDATA (&sim_timer_stop_svc, 0, 0) };\r\n\r\nif (cmd == NULL)\r\n    return;\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Starting sim_timer_precalibrate_execution_rate()\\n\");\r\nsim_run_boot_prep (RU_GO);\r\nwhile (sim_clock_queue != QUEUE_LIST_END)\r\n    sim_cancel (sim_clock_queue);\r\nwhile (*cmd)\r\n     exdep_cmd (EX_D, *(cmd++));\r\nsim_switches = saved_switches;\r\nsim_cancel (&SIM_INTERNAL_UNIT);\r\nstart = sim_os_msec();\r\ndo {\r\n    sim_activate (&precalib_unit, sim_precalibrate_ips);\r\n    sim_instr();\r\n    end = sim_os_msec();\r\n    } while ((end - start) < SIM_PRE_CALIBRATE_MIN_MS);\r\nsim_precalibrate_ips = (int32)(1000.0 * (sim_precalibrate_ips / (double)(end - start)));\r\n\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->hz)\r\n        rtc->initd = rtc->currd = (int32)(((double)sim_precalibrate_ips) / rtc->hz);\r\n    }\r\nreset_all_p (0);\r\nsim_run_boot_prep (RU_GO);\r\nfor (tmr=0; tmr<=SIM_NTIMERS; tmr++) {\r\n    RTC *rtc = &rtcs[tmr];\r\n\r\n    if (rtc->calib_initializations)\r\n        rtc->calib_initializations = 1;\r\n    }\r\nsim_inst_per_sec_last = sim_precalibrate_ips;\r\nsim_idle_stable = 0;\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Precalibration Rate: %s %s Per Sec\\n\", sim_fmt_numeric (sim_inst_per_sec_last), sim_vm_interval_units);\r\nsim_debug (SIM_DBG_INIT, &sim_scp_dev, \"Done sim_timer_precalibrate_execution_rate()\\n\");\r\n}\r\n\r\ndouble\r\nsim_host_speed_factor (void)\r\n{\r\nif (sim_precalibrate_ips > sim_vm_initial_ips)\r\n    return 1.0;\r\nreturn (double)sim_vm_initial_ips / (double)sim_precalibrate_ips;\r\n}\r\n"
        },
        {
          "name": "sim_timer.h",
          "type": "blob",
          "size": 8.1484375,
          "content": "/* sim_timer.h: simulator timer library headers\r\n\r\n   Copyright (c) 1993-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   28-Apr-07    RMS     Added sim_rtc_init_all\r\n   17-Oct-06    RMS     Added idle support\r\n   02-Jan-04    RMS     Split out from SCP\r\n*/\r\n\r\n#ifndef SIM_TIMER_H_\r\n#define SIM_TIMER_H_   0\r\n\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n/* Pick up a struct timespec definition if it is available */\r\n#include <time.h>\r\n#if defined(__struct_timespec_defined)\r\n#define _TIMESPEC_DEFINED\r\n#endif\r\n\r\n#if defined (__APPLE__)\r\n#define HAVE_STRUCT_TIMESPEC     /* OSX defined the structure but doesn't tell us */\r\n#endif\r\n\r\n/* on HP-UX, CLOCK_REALTIME is enum, not preprocessor define */\r\n#if !defined(CLOCK_REALTIME) && !defined(__hpux)\r\n#define CLOCK_REALTIME 1\r\n#define NEED_CLOCK_GETTIME 1\r\n#if  defined(_MSC_VER)      /* Visual Studio/Visual C++ */\r\n#if _MSC_VER >= 1900        /* Visual Studio Community (2015) */\r\n#define HAVE_STRUCT_TIMESPEC\r\n#define _TIMESPEC_DEFINED\r\n#endif /* _MSC_VER >= 1900 */\r\n#endif /* defined(_MSC_VER) */\r\n#if !defined(HAVE_STRUCT_TIMESPEC)\r\n#define HAVE_STRUCT_TIMESPEC\r\n#if !defined(_TIMESPEC_DEFINED)\r\n#define _TIMESPEC_DEFINED\r\nstruct timespec {\r\n    time_t tv_sec;\r\n    long   tv_nsec;\r\n};\r\n#endif /* !defined(_TIMESPEC_DEFINED) */\r\n#endif /* !defined(HAVE_STRUCT_TIMESPEC) */\r\nint clock_gettime(int clock_id, struct timespec *tp);\r\n#endif\r\n\r\n\r\n#define SIM_NTIMERS     8                           /* # timers */\r\n#define SIM_TMAX        500                         /* max timer makeup */\r\n\r\n#define SIM_INITIAL_IPS 5000000                     /* uncalibrated assumption */\r\n                                                    /* about instructions per second */\r\n#define SIM_PRE_CALIBRATE_MIN_MS    100             /* minimum time to run precalibration activities */\r\n\r\n#define SIM_IDLE_CAL    10                          /* ms to calibrate */\r\n#define SIM_IDLE_STMIN  2                           /* min sec for stability */\r\n#define SIM_IDLE_STDFLT 20                          /* dft sec for stability */\r\n#define SIM_IDLE_STMAX  600                         /* max sec for stability */\r\n\r\n#define SIM_THROT_WINIT           1000              /* cycles to skip */\r\n#define SIM_THROT_WST             10000             /* initial wait */\r\n#define SIM_THROT_WMUL            4                 /* multiplier */\r\n#define SIM_THROT_WMIN            50                /* min wait */\r\n#define SIM_THROT_DRIFT_PCT_DFLT  5                 /* drift percentage for recalibrate */\r\n#define SIM_THROT_MSMIN           10                /* min for measurement */\r\n#define SIM_THROT_NONE            0                 /* throttle parameters */\r\n#define SIM_THROT_MCYC            1                 /* MegaCycles Per Sec */\r\n#define SIM_THROT_KCYC            2                 /* KiloCycles Per Sec */\r\n#define SIM_THROT_PCT             3                 /* Max Percent of host CPU */\r\n#define SIM_THROT_SPC             4                 /* Specific periodic Delay */\r\n#define SIM_THROT_STATE_INIT      0                 /* Starting */\r\n#define SIM_THROT_STATE_TIME      1                 /* Checking Time */\r\n#define SIM_THROT_STATE_THROTTLE  2                 /* Throttling  */\r\n\r\n#define TIMER_DBG_IDLE  0x001                       /* Debug Flag for Idle Debugging */\r\n#define TIMER_DBG_QUEUE 0x002                       /* Debug Flag for Asynch Queue Debugging */\r\n#define TIMER_DBG_MUX   0x004                       /* Debug Flag for Asynch Queue Debugging */\r\n\r\nt_bool sim_timer_init (void);\r\nvoid sim_timespec_diff (struct timespec *diff, struct timespec *min, const struct timespec *sub);\r\ndouble sim_timenow_double (void);\r\nint32 sim_rtcn_init (int32 time, int32 tmr);\r\nint32 sim_rtcn_init_unit (UNIT *uptr, int32 time, int32 tmr);\r\nint32 sim_rtcn_init_unit_ticks (UNIT *uptr, int32 time, int32 tmr, int32 ticksper);\r\nvoid sim_rtcn_set_debug_basetime (const struct timespec *basetime);\r\nconst struct timespec *sim_rtcn_get_debug_basetime (void);\r\nvoid sim_rtcn_debug_time (struct timespec *now);\r\nvoid sim_rtcn_get_time (struct timespec *now, int tmr);\r\ntime_t sim_get_time (time_t *now);\r\nt_stat sim_rtcn_tick_ack (uint32 time, int32 tmr);\r\nvoid sim_rtcn_init_all (void);\r\nint32 sim_rtcn_calb (uint32 ticksper, int32 tmr);\r\nint32 sim_rtcn_calb_tick (int32 tmr);\r\nint32 sim_rtc_init (int32 time);\r\nint32 sim_rtc_calb (uint32 ticksper);\r\nt_stat sim_set_timers (int32 arg, CONST char *cptr);\r\nt_stat sim_show_timers (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char* desc);\r\nt_stat sim_show_clock_queues (FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, CONST char *cptr);\r\nt_bool sim_idle (uint32 tmr, int sin_cyc);\r\nt_stat sim_set_throt (int32 arg, CONST char *cptr);\r\nt_stat sim_show_throt (FILE *st, DEVICE *dnotused, UNIT *unotused, int32 flag, CONST char *cptr);\r\nt_stat sim_set_idle (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_clr_idle (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat sim_show_idle (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nvoid sim_throt_sched (void);\r\nvoid sim_throt_cancel (void);\r\nuint32 sim_os_msec (void);\r\nvoid sim_os_sleep (unsigned int sec);\r\nuint32 sim_os_ms_sleep (unsigned int msec);\r\nuint32 sim_os_ms_sleep_init (void);\r\nvoid sim_start_timer_services (void);\r\nvoid sim_stop_timer_services (void);\r\nt_stat sim_timer_change_asynch (void);\r\nt_stat sim_timer_activate (UNIT *uptr, int32 interval);\r\nt_stat sim_timer_activate_after (UNIT *uptr, double usec_delay);\r\nint32 _sim_timer_activate_time (UNIT *uptr);\r\ndouble sim_timer_activate_time_usecs (UNIT *uptr);\r\nt_bool sim_timer_is_active (UNIT *uptr);\r\nt_bool sim_timer_cancel (UNIT *uptr);\r\nt_stat sim_register_clock_unit (UNIT *uptr);\r\nt_stat sim_register_clock_unit_tmr (UNIT *uptr, int32 tmr);\r\nt_stat sim_clock_coschedule (UNIT *uptr, int32 interval);\r\nt_stat sim_clock_coschedule_abs (UNIT *uptr, int32 interval);\r\nt_stat sim_clock_coschedule_tmr (UNIT *uptr, int32 tmr, int32 ticks);\r\nt_stat sim_clock_coschedule_tmr_abs (UNIT *uptr, int32 tmr, int32 ticks);\r\ndouble sim_timer_inst_per_sec (void);\r\nvoid sim_timer_precalibrate_execution_rate (void);\r\nint32 sim_rtcn_tick_size (int32 tmr);\r\nint32 sim_rtcn_calibrated_tmr (void);\r\nt_bool sim_timer_idle_capable (uint32 *host_ms_sleep_1, uint32 *host_tick_ms);\r\n#define PRIORITY_BELOW_NORMAL  -1\r\n#define PRIORITY_NORMAL         0\r\n#define PRIORITY_ABOVE_NORMAL   1\r\nt_stat sim_os_set_thread_priority (int below_normal_above);\r\nuint32 sim_get_rom_delay_factor (void);\r\nvoid sim_set_rom_delay_factor (uint32 delay);\r\nint32 sim_rom_read_with_delay (int32 val);\r\ndouble sim_host_speed_factor (void);\r\nt_stat sim_os_process_cpu_times (double *system, double *user);\r\n\r\nextern t_bool sim_idle_enab;                        /* idle enabled flag */\r\nextern volatile t_bool sim_idle_wait;               /* idle waiting flag */\r\nextern t_bool sim_asynch_timer;\r\nextern DEVICE sim_timer_dev;\r\nextern UNIT * volatile sim_clock_cosched_queue[SIM_NTIMERS+1];\r\nextern const t_bool rtc_avail;\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "sim_tmxr.c",
          "type": "blob",
          "size": 242.4951171875,
          "content": "/* sim_tmxr.c: Telnet terminal multiplexer library\r\n\r\n   Copyright (c) 2001-2011, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   Based on the original DZ11 simulator by Thord Nilson, as updated by\r\n   Arthur Krewat.\r\n\r\n   12-Oct-12    MP      Revised serial port support to not require changes to\r\n                        any code in TMXR library using code.  Added support\r\n                        for per line listener ports and outgoing tcp connections.\r\n   02-Jun-11    MP      Fixed telnet option negotiation loop with some clients\r\n                        Added Option Negotiation and Debugging Support\r\n   17-Jan-11    MP      Added Buffered line capabilities\r\n   16-Jan-11    MP      Made option negotiation more reliable\r\n   20-Nov-08    RMS     Added three new standardized SHOW routines\r\n   05-Nov-08    JDB     Moved logging call after connection check in tmxr_putc_ln\r\n   03-Nov-08    JDB     Added TMXR null check to tmxr_find_ldsc\r\n   07-Oct-08    JDB     Added initial serial port support\r\n   30-Sep-08    JDB     Reverted tmxr_find_ldsc to original implementation\r\n   27-May-08    JDB     Added line connection order to tmxr_poll_conn,\r\n                        added tmxr_set_lnorder and tmxr_show_lnorder\r\n   14-May-08    JDB     Print device and line to which connection was made\r\n   11-Apr-07    JDB     Worked around Telnet negotiation problem with QCTerm\r\n   16-Aug-05    RMS     Fixed C++ declaration and cast problems\r\n   29-Jun-05    RMS     Extended tmxr_dscln to support unit array devices\r\n                        Fixed bug in SET LOG/NOLOG\r\n   04-Jan-04    RMS     Changed TMXR ldsc to be pointer to linedesc array\r\n                        Added tmxr_linemsg, circular output pointers, logging\r\n                        (from Mark Pizzolato)\r\n   29-Dec-03    RMS     Added output stall support\r\n   01-Nov-03    RMS     Cleaned up attach routine\r\n   09-Mar-03    RMS     Fixed bug in SHOW CONN\r\n   22-Dec-02    RMS     Fixed bugs in IAC+IAC receive and transmit sequences\r\n                        Added support for received break (all from by Mark Pizzolato)\r\n                        Fixed bug in attach\r\n   31-Oct-02    RMS     Fixed bug in 8b (binary) support\r\n   22-Aug-02    RMS     Added tmxr_open_master, tmxr_close_master\r\n   30-Dec-01    RMS     Added tmxr_fstats, tmxr_dscln, renamed tmxr_fstatus\r\n   03-Dec-01    RMS     Changed tmxr_fconns for extended SET/SHOW\r\n   20-Oct-01    RMS     Fixed bugs in read logic (found by Thord Nilson).\r\n                        Added tmxr_rqln, tmxr_tqln\r\n\r\n   This library includes:\r\n\r\n   tmxr_poll_conn -                     poll for connection\r\n   tmxr_reset_ln -                      reset line (drops Telnet/tcp and serial connections)\r\n   tmxr_detach_ln -                     reset line and close per line listener and outgoing destination\r\n   tmxr_getc_ln -                       get character for line\r\n   tmxr_get_packet_ln -                 get packet from line\r\n   tmxr_get_packet_ln_ex -              get packet from line with separator byte\r\n   tmxr_poll_rx -                       poll receive\r\n   tmxr_putc_ln -                       put character for line\r\n   tmxr_put_packet_ln -                 put packet on line\r\n   tmxr_put_packet_ln_ex -              put packet on line with separator byte\r\n   tmxr_poll_tx -                       poll transmit\r\n   tmxr_send_buffered_data -            transmit buffered data\r\n   tmxr_set_modem_control_passthru -    enable modem control on a multiplexer\r\n   tmxr_clear_modem_control_passthru -  disable modem control on a multiplexer\r\n   tmxr_set_port_speed_control -        Declare that tmxr_set_config_line is used\r\n   tmxr_clear_port_speed_control -      Declare that tmxr_set_config_line is not used\r\n   tmxr_set_backlog -                   set listen backlog\r\n   tmxr_set_line_port_speed_control -   Declare that tmxr_set_config_line is used for line\r\n   tmxr_clear_line_port_speed_control - Declare that tmxr_set_config_line is not used for line\r\n   tmxr_set_get_modem_bits -            set and/or get a line modem bits\r\n   tmxr_set_line_loopback -             enable or disable loopback mode on a line\r\n   tmxr_get_line_loopback -             returns the current loopback status of a line\r\n   tmxr_set_line_halfduplex -           enable or disable halfduplex mode on a line\r\n   tmxr_get_line_halfduplex -           returns the current halfduplex status of a line\r\n   tmxr_set_config_line -               set port speed, character size, parity and stop bits\r\n   tmxr_open_master -                   open master connection\r\n   tmxr_close_master -                  close master connection\r\n   tmxr_attach  -                       attach terminal multiplexor to listening port\r\n   tmxr_detach  -                       detach terminal multiplexor to listening port\r\n   tmxr_attach_help  -                  help routine for attaching multiplexer devices\r\n   tmxr_set_line_unit -                 set the unit which polls for input for a given line\r\n   tmxr_ex      -                       (null) examine\r\n   tmxr_dep     -                       (null) deposit\r\n   tmxr_msg     -                       send message to socket\r\n   tmxr_linemsg -                       send message to line\r\n   tmxr_linemsgf -                      send formatted message to line\r\n   tmxr_fconns  -                       output connection status\r\n   tmxr_fstats  -                       output connection statistics\r\n   tmxr_set_log -                       enable logging for line\r\n   tmxr_set_nolog -                     disable logging for line\r\n   tmxr_show_log -                      show logging status for line\r\n   tmxr_dscln   -                       disconnect line (SET routine)\r\n   tmxr_rqln    -                       number of available characters for line\r\n   tmxr_tqln    -                       number of buffered characters for line\r\n   tmxr_tpqln    -                      number of buffered packet characters for line\r\n   tmxr_tpbusyln -                      transmit packet busy status for line\r\n   tmxr_set_lnorder -                   set line connection order\r\n   tmxr_show_lnorder -                  show line connection order\r\n   tmxr_show_summ -                     show connection summary\r\n   tmxr_show_cstat -                    show line connections or status\r\n   tmxr_show_lines -                    show number of lines\r\n   tmxr_show_open_devices -             show info about all open tmxr devices\r\n\r\n   All routines are OS-independent.\r\n\r\n\r\n    This library supports the simulation of multiple-line terminal multiplexers.\r\n    It may also be used to create single-line \"multiplexers\" to provide\r\n    additional terminals beyond the simulation console.  It may also be used to\r\n    create single-line or multi-line simulated synchronous (BiSync) devices.\r\n    Multiplexer lines may be connected to terminal emulators supporting the\r\n    Telnet protocol via sockets, or to hardware terminals via host serial\r\n    ports.  Concurrent Telnet and serial connections may be mixed on a given\r\n    multiplexer.\r\n\r\n    When connecting via sockets, the simulated multiplexer is attached to a\r\n    listening port on the host system:\r\n\r\n      sim> attach MUX 23\r\n      Listening on port 23\r\n\r\n    Once attached, the listening port must be polled for incoming connections.\r\n    When a connection attempt is received, it will be associated with the next\r\n    multiplexer line in the user-specified line order, or with the next line in\r\n    sequence if no order has been specified.  Individual lines may be connected\r\n    to serial ports or remote systems via TCP (telnet or not as desired), OR\r\n    they may have separate listening TCP ports.\r\n\r\n    Logging of Multiplexer Line output:\r\n\r\n    The traffic going out multiplexer lines can be logged to files.  A single\r\n    line multiplexer can log it's traffic with the following command:\r\n\r\n        sim> atta MUX 23,Log=LogFileName\r\n        sim> atta MUX Connect=ser0,Log=LogFileName\r\n\r\n    Specifying a Log value for a multi-line multiplexer is specifying a\r\n    template filename.  The actual file name used for each line will be\r\n    the indicated filename with _n appended (n being the line number).\r\n\r\n    Buffered Multiplexer Line:\r\n\r\n    A Multiplexer Line Buffering has been implemented.  A Buffered Line will\r\n    have a copy of the last 'buffer size' bytes of output retained in a line\r\n    specific buffer.  The contents of this buffer will be transmitted out any\r\n    new connection on that line when a new telnet session is established.\r\n\r\n    This capability is most useful for the Console Telnet session.  When a\r\n    Console Telnet session is Buffered, a simulator will start (via BOOT CPU\r\n    or whatever is appropriate for a particular simulator) without needing to\r\n    have an active telnet connection.  When a Telnet connection comes along\r\n    for the telnet port, the contents of the saved buffer (which wraps on\r\n    overflow) are presented on the telnet session as output before session\r\n    traffic.  This allows the connecting telnet client to see what happened\r\n    before he connected since the likely reason he might be connecting to the\r\n    console of a background simulator is to troubleshoot unusual behavior,\r\n    the details of which may have already been sent to the console.\r\n\r\n    Serial Port support:\r\n\r\n    Serial ports may be specified as an operating system specific device names\r\n    or using simh generic serial names.  simh generic names are of the form\r\n    serN, where N is from 0 thru one less than the maximum number of serial\r\n    ports on the local system.  The mapping of simh generic port names to OS\r\n    specific names can be displayed using the following command:\r\n\r\n        sim> show serial\r\n        Serial devices:\r\n         ser0   COM1 (\\Device\\Serial0)\r\n         ser1   COM3 (Winachcf0)\r\n\r\n        sim> attach MUX Line=2,Connect=ser0\r\n\r\n    or equivalently\r\n\r\n        sim> attach MUX Line=2,Connect=COM1\r\n\r\n    An optional configuration string may be present after the port name.  If\r\n    present, it must be separated from the port name with a semicolon and has\r\n    this form:\r\n\r\n       <rate>-<charsize><parity><stopbits>\r\n\r\n    where:\r\n\r\n      rate     = communication rate in bits per second\r\n      charsize = character size in bits (5-8, including optional parity)\r\n      parity   = parity designator (N/E/O/M/S for no/even/odd/mark/space parity)\r\n      stopbits = number of stop bits (1, 1.5, or 2)\r\n\r\n     As an example:\r\n\r\n        9600-8n1\r\n\r\n    The supported rates, sizes, and parity options are host-specific.  If\r\n    a configuration string is not supplied, then the default of 9600-8N1\r\n    is used.\r\n\r\n    An attachment to a serial port with the '-V' switch will cause a\r\n    connection message to be output to the connected serial port.\r\n    This will help to confirm the correct port has been connected and\r\n    that the port settings are reasonable for the connected device.\r\n    This would be done as:\r\n\r\n        sim> attach -V MUX Connect=SerN\r\n\r\n\r\n    Line specific tcp listening ports are supported.  These are configured\r\n    using commands of the form:\r\n\r\n        sim> attach MUX Line=2,port{;notelnet}|{;nomessage}\r\n\r\n    Direct computer to computer connections (Virtual Null Modem cables) may\r\n    be established using the telnet protocol or via raw tcp sockets.\r\n\r\n        sim> attach MUX Line=2,Connect=host:port{;notelnet}\r\n\r\n    Computer to computer virtual connections can be one way (as illustrated\r\n    above) or symmetric.  A symmetric connection is configured by combining\r\n    a one way connection with a tcp listening port on the same line:\r\n\r\n        sim> attach MUX Line=2,Connect=host:port,listenport\r\n\r\n    When symmetric virtual connections are configured, incoming connections\r\n    on the specified listening port are checked to assure that they actually\r\n    come from the specified connection destination host system.\r\n\r\n\r\n\r\n     The command syntax for a single line device (MX) is:\r\n\r\n        sim> attach MX port{;backlog=n}{;notelnet}|{;nomessage}\r\n        sim> attach MX Connect=serN{;config}\r\n        sim> attach MX Connect=COM9{;config}\r\n        sim> attach MX Connect=host:port{;notelnet}|{;nomessage}\r\n\r\n     The command syntax for ANY multi-line device is:\r\n\r\n        sim> attach MX port{;backlog=n}{;notelnet}|{;nomessage} ; Defines the master listening port for the mux and optionally allows non-telnet (i.e. raw socket) operation for all lines.\r\n        sim> attach MX Line=n,port{;backlog=n}{;notelnet}|{;nomessage}  ; Defines a line specific listen port for a particular line. Each line can have a separate listen port and the mux can have its own as well.  Optionally disable telnet wire protocol (i.e. raw socket)\r\n        sim> attach MX Line=n,Connect=serN{;config}        ; Connects line n to simh generic serial port N (port list visible with the sim> SHOW SERIAL command), the optional \";config\" data specifies the speed, parity and stop bits for the connection\r\n                                                           ; DTR (and RTS) will be raised at attach time and will drop at detach/disconnect time\r\n        sim> attach MX Line=n,Connect=host:port{;notelnet} ; Causes a connection to be established to the designated host:port.  The actual connection will happen in a non-blocking fashion and will be completed and/or re-established by the normal tmxr_poll_conn activities\r\n\r\n     All connections configured for any multiplexer device are unconfigured by:\r\n\r\n        sim> detach MX                              ; detaches ALL connections/ports/sessions on the MUX.\r\n\r\n    Console serial connections are achieved by:\r\n\r\n        sim> set console serial=serN{;config}\r\n    or\r\n        sim> set console serial=COM2{;config}\r\n\r\n    A line specific listening port (12366) can be specified by the following:\r\n\r\n        sim> attach MUX Line=2,12366\r\n\r\n    A line specific remote telnet (or raw tcp) destination can be specified\r\n    by the following:\r\n\r\n        sim> attach MUX Line=2,Connect=remotehost:port\r\n\r\n    If a connection to a remotehost:port wants a raw binary data channel\r\n    (instead of a telnet session) the following would be used:\r\n\r\n        sim> attach MUX Line=2,Connect=remotehost:port;notelnet\r\n\r\n    A single line multiplexor can indicate any of the above line options\r\n    without specifying a line number:\r\n\r\n        sim> attach MUX Connect=ser0;9600-8N1\r\n        sim> attach MUX 12366{;notelnet}|{;nomessage}\r\n        sim> attach MUX Connect=remotehost:port\r\n        sim> attach MUX Connect=remotehost:port;notelnet\r\n\r\n    A multiplexor can disconnect all (telnet, serial and outgoing) previous\r\n    attachments with:\r\n\r\n        sim> detach MUX\r\n\r\n   A device emulation may choose to implement a command interface to\r\n   disconnect specific individual lines.  This would usually be done via\r\n   a Unit Modifier table entry (MTAB) which dispatches the command\r\n   \"SET dev DISCONNECT[=line]\" to tmxr_dscln.  This will cause a telnet\r\n   connection to be closed, but a serial port will normally have DTR\r\n   dropped for 500ms and raised again (thus hanging up a modem on that\r\n   serial port).\r\n\r\n     sim> set MUX disconnect=2\r\n\r\n    Full Modem Control serial port support.\r\n\r\n    This library supports devices which wish to emulate full modem\r\n    control/signalling for serial ports.  Any device emulation which wishes\r\n    to support this functionality for attached serial ports must call\r\n    \"tmxr_set_modem_control_passthru\" before any call to tmxr_attach.\r\n    This disables automatic DTR (&RTS) manipulation by this library.\r\n    Responsibility for manipulating DTR falls on the simulated operating\r\n    system.  Calling tmxr_set_modem_control_passthru would usually be in\r\n    a device reset routine.  It may also be called by a device attach\r\n    routine based on user specified options.\r\n    Once support for full modem control has been declared by a device\r\n    emulation for a particular TMXR device, this library will make no\r\n    direct effort to manipulate modem bits while connected to serial ports.\r\n    The \"tmxr_set_get_modem_bits\" API exists to allow the device emulation\r\n    layer to query and control modem signals.  The \"tmxr_set_config_line\"\r\n    API exists to allow the device emulation layer to change port settings\r\n    (baud rate, parity and stop bits).  A modem_control enabled line\r\n    merely passes the VM's port status bits, data and settings through to\r\n    and from the serial port.\r\n\r\n    The \"tmxr_set_get_modem_bits\" and \"tmxr_set_config_line\" APIs will\r\n    ONLY work on a modem control enabled TMXR device.\r\n\r\n*/\r\n\r\n#define NOT_MUX_USING_CODE /* sim_tmxr library define */\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_scp_private.h\"\r\n#include \"sim_serial.h\"\r\n#include \"sim_sock.h\"\r\n#include \"sim_timer.h\"\r\n#include \"sim_tmxr.h\"\r\n#include \"sim_ether.h\"\r\n#include \"scp.h\"\r\n\r\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\r\n\r\n/* Telnet protocol constants - negatives are for init'ing signed char data */\r\n\r\n/* Commands */\r\n#define TN_IAC          0xFFu /* -1 */                  /* protocol delim */\r\n#define TN_DONT         0xFEu /* -2 */                  /* dont */\r\n#define TN_DO           0xFDu /* -3 */                  /* do */\r\n#define TN_WONT         0xFCu /* -4 */                  /* wont */\r\n#define TN_WILL         0xFBu /* -5 */                  /* will */\r\n#define TN_SB           0xFAu /* -6 */                  /* sub-option negotiation */\r\n#define TN_GA           0xF9u /* -7 */                  /* go ahead */\r\n#define TN_EL           0xF8u /* -8 */                  /* erase line */\r\n#define TN_EC           0xF7u /* -9 */                  /* erase character */\r\n#define TN_AYT          0xF6u /* -10 */                 /* are you there */\r\n#define TN_AO           0xF5u /* -11 */                 /* abort output */\r\n#define TN_IP           0xF4u /* -12 */                 /* interrupt process */\r\n#define TN_BRK          0xF3u /* -13 */                 /* break */\r\n#define TN_DATAMK       0xF2u /* -14 */                 /* data mark */\r\n#define TN_NOP          0xF1u /* -15 */                 /* no operation */\r\n#define TN_SE           0xF0u /* -16 */                 /* end sub-option negot */\r\n\r\n/* Options */\r\n\r\n#define TN_BIN            0                             /* bin */\r\n#define TN_ECHO           1                             /* echo */\r\n#define TN_SGA            3                             /* sga */\r\n#define TN_STATUS         5                             /* option status query */\r\n#define TN_TIMING         6                             /* Timing Mark */\r\n#define TN_NAOCRD        10                             /* Output Carriage-Return Disposition */\r\n#define TN_NAOHTS        11                             /* Output Horizontal Tab Stops */\r\n#define TN_NAOHTD        12                             /* Output Horizontal Tab Stop Disposition */\r\n#define TN_NAOFFD        13                             /* Output Formfeed Disposition */\r\n#define TN_NAOVTS        14                             /* Output Vertical Tab Stop */\r\n#define TN_NAOVTD        15                             /* Output Vertical Tab Stop Disposition */\r\n#define TN_NAOLFD        16                             /* Output Linefeed Disposition */\r\n#define TN_EXTEND        17                             /* Extended Ascii */\r\n#define TN_LOGOUT        18                             /* Logout */\r\n#define TN_BM            19                             /* Byte Macro */\r\n#define TN_DET           20                             /* Data Entry Terminal */\r\n#define TN_SENDLO        23                             /* Send Location */\r\n#define TN_TERMTY        24                             /* Terminal Type */\r\n#define TN_ENDREC        25                             /* Terminal Type */\r\n#define TN_TUID          26                             /* TACACS User Identification */\r\n#define TN_OUTMRK        27                             /* Output Marking */\r\n#define TN_TTYLOC        28                             /* Terminal Location Number */\r\n#define TN_3270          29                             /* 3270 Regime */\r\n#define TN_X3PAD         30                             /* X.3 PAD */\r\n#define TN_NAWS          31                             /* Negotiate About Window Size */\r\n#define TN_TERMSP        32                             /* Terminal Speed */\r\n#define TN_TOGFLO        33                             /* Remote Flow Control */\r\n#define TN_LINE          34                             /* line mode */\r\n#define TN_XDISPL        35                             /* X Display Location */\r\n#define TN_ENVIRO        36                             /* Environment */\r\n#define TN_AUTH          37                             /* Authentication */\r\n#define TN_ENCRYP        38                             /* Data Encryption */\r\n#define TN_NEWENV        39                             /* New Environment */\r\n#define TN_TN3270        40                             /* TN3270 Enhancements */\r\n#define TN_CHARST        42                             /* CHARSET */\r\n#define TN_COMPRT        44                             /* Com Port Control */\r\n#define TN_KERMIT        47                             /* KERMIT */\r\n\r\n#define TN_CR           015                             /* carriage return */\r\n#define TN_LF           012                             /* line feed */\r\n#define TN_NUL          000                             /* null */\r\n\r\n/* Telnet line states */\r\n\r\n#define TNS_NORM        000                             /* normal */\r\n#define TNS_IAC         001                             /* IAC seen */\r\n#define TNS_WILL        002                             /* WILL seen */\r\n#define TNS_WONT        003                             /* WONT seen */\r\n#define TNS_SKIP        004                             /* skip next cmd */\r\n#define TNS_CRPAD       005                             /* CR padding */\r\n#define TNS_DO          006                             /* DO request pending rejection */\r\n\r\n/* Telnet Option Sent Flags */\r\n\r\n#define TNOS_DONT       001                             /* Don't has been sent */\r\n#define TNOS_WONT       002                             /* Won't has been sent */\r\n\r\n/* Lifted from ddcmp.c in the framer firmware */\r\nstruct status_msg_t\r\n{\r\n    uint8 dc1;\r\n    uint8 on;                     /* \"on\" flags */\r\n    uint16 mflags;\r\n    uint32 speed;\r\n    uint32 txspeed;\r\n    uint32 rxframes;\r\n    uint32 rxbytes;\r\n    uint32 txframes;\r\n    uint32 txbytes;\r\n    uint32 hcrc_err;\r\n    uint32 crc_err;\r\n    uint32 len_err;\r\n    uint32 nobuf_err;\r\n    uint32 last_cmd_sts;          /* Response code from last command */\r\n    uint32 freq;                  /* Measured frequency */\r\n    char version[64];\r\n};\r\n#define ON_ACT 1\r\n#define ON_SYN 2\r\n#define ON_CLKOK 4\r\n\r\n/* This struct is internal to sim_tmxr, used when a line is attached\r\n * to a DDCMP synchronous framer device (a USB peripheral that looks\r\n * like an Ethernet interface).\r\n */\r\ntypedef struct framer_data {\r\n    ETH_DEV *eth;                   /* Ethernet device pointer if framer */\r\n    uint16 fmode;                   /* Framer mode from attach command */\r\n    uint32 fspeed;                  /* Framer link speed from attach command */\r\n    struct status_msg_t status;     /* Last received status message */\r\n    int status_cnt;                 /* Count of status messages seen */\r\n    t_bool connect_pending;         /* True if connected not yet reported */\r\n} FRAMER;\r\n\r\nstatic BITFIELD tmxr_modem_bits[] = {\r\n  BIT(DTR),                                 /* Data Terminal Ready */\r\n  BIT(RTS),                                 /* Request To Send     */\r\n  BIT(DCD),                                 /* Data Carrier Detect */\r\n  BIT(RNG),                                 /* Ring Indicator      */\r\n  BIT(CTS),                                 /* Clear To Send       */\r\n  BIT(DSR),                                 /* Data Set Ready      */\r\n  ENDBITS\r\n};\r\n\r\nstatic u_char mantra[] = {                  /* Telnet Option Negotiation Mantra */\r\n    TN_IAC, TN_WILL, TN_LINE,\r\n    TN_IAC, TN_WILL, TN_SGA,\r\n    TN_IAC, TN_WILL, TN_ECHO,\r\n    TN_IAC, TN_WILL, TN_BIN,\r\n    TN_IAC, TN_DO, TN_BIN\r\n    };\r\n\r\n#define TMXR_GUARD  ((int32)(lp->serport ? 1 : sizeof(mantra)))/* buffer guard */\r\n\r\n#define TMXR_LINE_DISABLED (-1)\r\n\r\n/* Local routines */\r\nstatic void tmxr_setup_framer(TMLN *line, ETH_PACK *packet, int len);\r\nstatic int  tmxr_framer_read (TMLN *line, char *buf, int nbytes);\r\nstatic int  tmxr_framer_write (TMLN *line, const char *buf, int32 length);\r\n\r\nstatic void tmxr_add_to_open_list (TMXR* mux);\r\n\r\n/* Initialize the line state.\r\n\r\n   Reset the line state to represent an idle line.  Note that we do not clear\r\n   all of the line structure members, so a connected line remains connected\r\n   after this call.\r\n\r\n   Because a line break is represented by a flag in the \"receive break status\"\r\n   array, we must zero that array in order to clear any pending break\r\n   indications.\r\n*/\r\n\r\nstatic void tmxr_init_line (TMLN *lp)\r\n{\r\nlp->tsta = 0;                                           /* init telnet state */\r\nlp->xmte = 1;                                           /* enable transmit */\r\nlp->dstb = 0;                                           /* default bin mode */\r\nlp->rxbpr = lp->rxbpi = lp->rxcnt = lp->rxpcnt = 0;     /* init receive indexes */\r\nif (!lp->txbfd || lp->notelnet)                         /* if not buffered telnet */\r\n    lp->txbpr = lp->txbpi = lp->txcnt = lp->txpcnt = 0; /*   init transmit indexes */\r\nlp->txdrp = lp->txstall = 0;\r\ntmxr_set_get_modem_bits (lp, 0, 0, NULL);\r\nif (lp->mp && (!lp->mp->buffered) && (!lp->txbfd)) {\r\n    lp->txbfd = 0;\r\n    lp->txbsz = TMXR_MAXBUF;\r\n    lp->txb = (char *)realloc (lp->txb, lp->txbsz);\r\n    lp->rxbsz = TMXR_MAXBUF;\r\n    lp->rxb = (char *)realloc(lp->rxb, lp->rxbsz);\r\n    lp->rbr = (char *)realloc(lp->rbr, lp->rxbsz);\r\n    }\r\nif (lp->loopback) {\r\n    lp->lpbsz = lp->rxbsz;\r\n    lp->lpb = (char *)realloc(lp->lpb, lp->lpbsz);\r\n    lp->lpbcnt = lp->lpbpi = lp->lpbpr = 0;\r\n    }\r\nif (lp->rxpb) {\r\n    lp->rxpboffset = lp->rxpbsize = 0;\r\n    free (lp->rxpb);\r\n    lp->rxpb = NULL;\r\n    }\r\nif (lp->txpb) {\r\n    lp->txpbsize = lp->txppsize = lp->txppoffset = 0;\r\n    free (lp->txpb);\r\n    lp->txpb = NULL;\r\n    }\r\nmemset (lp->rbr, 0, lp->rxbsz);                         /* clear break status array */\r\n}\r\n\r\n\r\n/* Report a connection to a line.\r\n\r\n   If the indicated line (lp) is speaking the telnet wire protocol, a\r\n   notification of the form:\r\n\r\n      Connected to the <sim> simulator <dev> device, line <n>\r\n\r\n   is sent to the newly connected line.  If the device has only one line, the\r\n   \"line <n>\" part is omitted.  If the device has not been defined, the \"<dev>\r\n   device\" part is omitted.\r\n\r\n*/\r\n\r\nstatic void tmxr_report_connection (TMXR *mp, TMLN *lp)\r\n{\r\nint32 unwritten, psave;\r\nchar cmsg[160];\r\nchar dmsg[80] = \"\";\r\nchar lmsg[80] = \"\";\r\nchar msgbuf[512] = \"\";\r\n\r\nif (((!lp->notelnet) && (!lp->nomessage)) || (sim_switches & SWMASK ('V'))) {\r\n    sprintf (cmsg, \"\\n\\r\\nConnected to the %s simulator \", sim_name);\r\n\r\n    if (mp->dptr) {                                     /* device defined? */\r\n        sprintf (dmsg, \"%s device\",                     /* report device name */\r\n                       sim_dname (mp->dptr));\r\n\r\n        if (mp->lines > 1)                              /* more than one line? */\r\n            sprintf (lmsg, \", line %d\", (int)(lp-mp->ldsc));/* report the line number */\r\n        }\r\n\r\n    sprintf (msgbuf, \"%s%s%s\\r\\n\\n\", cmsg, dmsg, lmsg);\r\n    }\r\n\r\nif (!mp->buffered) {\r\n    lp->txbpi = 0;                                      /* init buf pointers */\r\n    lp->txbpr = (int32)(lp->txbsz - strlen (msgbuf));\r\n    lp->rxcnt = lp->txcnt = lp->txdrp = lp->txstall = 0;/* init counters */\r\n    lp->rxpcnt = lp->txpcnt = 0;\r\n    }\r\nelse\r\n    if (lp->txcnt > lp->txbsz)\r\n        lp->txbpr = (lp->txbpi + 1) % lp->txbsz;\r\n    else\r\n        lp->txbpr = (int32)(lp->txbsz - strlen (msgbuf));\r\n\r\npsave = lp->txbpi;                                      /* save insertion pointer */\r\nlp->txbpi = lp->txbpr;                                  /* insert connection message */\r\nif ((lp->serport) && (!sim_is_running)) {\r\n    sim_os_ms_sleep (TMXR_DTR_DROP_TIME);               /* Wait for DTR to be noticed */\r\n    lp->ser_connect_pending = FALSE;                    /* Mark line as ready for action */\r\n    lp->conn = TRUE;\r\n    }\r\ntmxr_linemsg (lp, msgbuf);                              /* beginning of buffer */\r\nlp->txbpi = psave;                                      /* restore insertion pointer */\r\n\r\nunwritten = tmxr_send_buffered_data (lp);               /* send the message */\r\n\r\nif ((lp->serport) && (!sim_is_running)) {\r\n    lp->ser_connect_pending = TRUE;                     /* Mark line as not yet ready for action */\r\n    lp->conn = FALSE;\r\n    }\r\nif (unwritten == 0)                                     /* buffer now empty? */\r\n    lp->xmte = 1;                                       /* reenable transmission if paused */\r\n\r\nlp->txcnt -= (int32)strlen (msgbuf);                    /* adjust statistics */\r\n}\r\n\r\n\r\n/* Report a disconnection to a line.\r\n\r\n   A notification of the form:\r\n\r\n      Disconnected from the <sim> simulator\r\n\r\n   is sent to the line about to be disconnected.  We do not flush the buffer\r\n   here, because the disconnect routines will do that just after calling us.\r\n*/\r\n\r\nstatic void tmxr_report_disconnection (TMLN *lp)\r\n{\r\nif (lp->notelnet || lp->nomessage)\r\n    return;\r\ntmxr_linemsgf (lp, \"\\r\\nDisconnected from the %s simulator\\r\\n\\n\", sim_name);/* report disconnection */\r\n}\r\n\r\nstatic int32 loop_write_ex (TMLN *lp, char *buf, int32 length, t_bool prefix_datagram)\r\n{\r\nint32 written = 0;\r\nint32 loopfree = lp->lpbsz - lp->lpbcnt;\r\n\r\nif (lp->datagram && prefix_datagram) {\r\n    if ((size_t)loopfree < (size_t)(length + sizeof(length)))\r\n        return written;\r\n    loop_write_ex (lp, (char *)&length, sizeof(length), FALSE);\r\n    }\r\nwhile (length) {\r\n    int32 chunksize;\r\n\r\n    loopfree = lp->lpbsz - lp->lpbcnt;\r\n    if (loopfree == 0)\r\n        break;\r\n    if (loopfree < length)\r\n        length = loopfree;\r\n    if (lp->lpbpi >= lp->lpbpr)\r\n        chunksize = lp->lpbsz - lp->lpbpi;\r\n    else\r\n        chunksize = lp->lpbpr - lp->lpbpi;\r\n    if (chunksize > length)\r\n        chunksize = length;\r\n    memcpy (&lp->lpb[lp->lpbpi], buf, chunksize);\r\n    buf += chunksize;\r\n    length -= chunksize;\r\n    written += chunksize;\r\n    lp->lpbpi = (lp->lpbpi + chunksize) % lp->lpbsz;\r\n    }\r\nlp->lpbcnt += written;\r\nreturn written;\r\n}\r\n\r\nstatic int32 loop_write (TMLN *lp, char *buf, int32 length)\r\n{\r\nreturn loop_write_ex (lp, buf, length, TRUE);\r\n}\r\n\r\nstatic int32 loop_read_ex (TMLN *lp, char *buf, int32 bufsize)\r\n{\r\nint32 bytesread = 0;\r\n\r\nwhile (bufsize > 0) {\r\n    int32 chunksize;\r\n    int32 loopused = lp->lpbcnt;\r\n\r\n    if (loopused < bufsize)\r\n        bufsize = loopused;\r\n    if (loopused == 0)\r\n        break;\r\n    if (lp->lpbpi > lp->lpbpr)\r\n        chunksize = lp->lpbpi - lp->lpbpr;\r\n    else\r\n        chunksize = lp->lpbsz - lp->lpbpr;\r\n    if (chunksize > bufsize)\r\n        chunksize = bufsize;\r\n    memcpy (buf, &lp->lpb[lp->lpbpr], chunksize);\r\n    buf += chunksize;\r\n    bufsize -= chunksize;\r\n    bytesread += chunksize;\r\n    lp->lpbpr = (lp->lpbpr + chunksize) % lp->lpbsz;\r\n    }\r\nlp->lpbcnt -= bytesread;\r\nreturn bytesread;\r\n}\r\n\r\nstatic int32 loop_read (TMLN *lp, char *buf, int32 bufsize)\r\n{\r\nif (lp->datagram) {\r\n    int32 pktsize;\r\n\r\n    if (lp->lpbcnt < (int32)sizeof(pktsize))\r\n        return 0;\r\n    if ((sizeof(pktsize) != loop_read_ex (lp, (char *)&pktsize, sizeof(pktsize))) ||\r\n        (pktsize > bufsize))\r\n        return -1;\r\n    bufsize = pktsize;\r\n    }\r\nreturn loop_read_ex (lp, buf, bufsize);\r\n}\r\n\r\n/* Read from a line.\r\n\r\n   Up to \"length\" characters are read into the character buffer associated with\r\n   line \"lp\".  The actual number of characters read is returned.  If no\r\n   characters are available, 0 is returned.  If an error occurred while reading,\r\n   -1 is returned.\r\n\r\n   If a line break was detected on serial input, the associated receive break\r\n   status flag will be set.  Line break indication for Telnet connections is\r\n   embedded in the Telnet protocol and must be determined externally.\r\n*/\r\n\r\nstatic int32 tmxr_read (TMLN *lp, int32 length)\r\n{\r\nint32 i = lp->rxbpi;\r\n\r\nif (lp->loopback)\r\n    return loop_read (lp, &(lp->rxb[i]), length);\r\nif (lp->serport)                                        /* serial port connection? */\r\n    return sim_read_serial (lp->serport, &(lp->rxb[i]), length, &(lp->rbr[i]));\r\nelse {\r\n    if (lp->framer)\r\n        return tmxr_framer_read (lp,  &(lp->rxb[i]), length);\r\n    else                                                    /* Telnet connection */\r\n        return sim_read_sock (lp->sock, &(lp->rxb[i]), length);\r\n    }\r\n}\r\n\r\n\r\n/* Write to a line.\r\n\r\n   Up to \"length\" characters are written from the character buffer associated\r\n   with \"lp\".  The actual number of characters written is returned.  If an error\r\n   occurred while writing, -1 is returned.\r\n*/\r\n\r\nstatic int32 tmxr_write (TMLN *lp, int32 length)\r\n{\r\nint32 written = 0;\r\nint32 i = lp->txbpr;\r\n\r\nif ((lp->txbps) && (sim_gtime () < lp->txnexttime) && (sim_is_running))\r\n    return 0;\r\n\r\nif (lp->loopback)\r\n    return loop_write (lp, &(lp->txb[i]), length);\r\n\r\nif (lp->serport) {                                      /* serial port connection? */\r\n    written = sim_write_serial (lp->serport, &(lp->txb[i]), length);\r\n    }\r\nelse {\r\n    if (lp->framer)\r\n        written = tmxr_framer_write (lp,  &(lp->txb[i]), length);\r\n    else {\r\n        if (lp->sock) {                                     /* Telnet connection */\r\n            written = sim_write_sock (lp->sock, &(lp->txb[i]), length);\r\n\r\n            if (written == SOCKET_ERROR) {                  /* did an error occur? */\r\n                lp->txdone = TRUE;\r\n                if (lp->datagram)\r\n                    return written;                         /* ignore errors on datagram sockets */\r\n                else\r\n                    return -1;                              /* return error indication */\r\n                }\r\n            }\r\n        else {\r\n            if ((lp->conn == TMXR_LINE_DISABLED) ||\r\n                ((lp->conn == 0) && lp->txbfd)){\r\n                written = length;                           /* Count here output timing is correct */\r\n                if (lp->conn == TMXR_LINE_DISABLED)\r\n                    lp->txdrp += length;                    /* Record as having been dropped on the floor */\r\n                }\r\n            }\r\n        }\r\n    }\r\nif (written > 0) {\r\n    lp->txdone = FALSE;\r\n    if ((lp->txbps) && (sim_is_running))\r\n        lp->txnexttime = floor (sim_gtime () + ((written * lp->txdeltausecs * sim_timer_inst_per_sec ()) / USECS_PER_SECOND));\r\n    }\r\nreturn written;\r\n}\r\n\r\n\r\n/* Remove a character from the read buffer.\r\n\r\n   The character at position \"p\" in the read buffer associated with line \"lp\" is\r\n   removed by moving all of the following received characters down one position.\r\n   The receive break status array is adjusted accordingly.\r\n*/\r\n\r\nstatic void tmxr_rmvrc (TMLN *lp, int32 p)\r\n{\r\nfor ( ; p < lp->rxbpi; p++) {                           /* work from \"p\" through end of buffer */\r\n    lp->rxb[p] = lp->rxb[p + 1];                        /* slide following character down */\r\n    lp->rbr[p] = lp->rbr[p + 1];                        /* adjust break status too */\r\n    }\r\n\r\nlp->rbr[p] = 0;                                         /* clear potential break from vacated slot */\r\nlp->rxbpi = lp->rxbpi - 1;                              /* drop buffer insert index */\r\n}\r\n\r\n\r\n/* Find a line descriptor indicated by unit or number.\r\n\r\n   If \"uptr\" is NULL, then the line descriptor is determined by the line number\r\n   passed in \"val\".  If \"uptr\" is not NULL, then it must point to a unit\r\n   associated with a line, and the line descriptor is determined by the unit\r\n   number, which is derived by the position of the unit in the device's unit\r\n   array.\r\n\r\n   Note: This routine may be called with a UNIT that does not belong to the\r\n   device indicated in the TMXR structure.  That is, the multiplexer lines may\r\n   belong to a device other than the one attached to the socket (the HP 2100 MUX\r\n   device is one example).  Therefore, we must look up the device from the unit\r\n   at each call, rather than depending on the DEVICE pointer stored in the TMXR.\r\n*/\r\n\r\nstatic TMLN *tmxr_find_ldsc (UNIT *uptr, int32 val, const TMXR *mp)\r\n{\r\nif (mp == NULL)                                         /* invalid multiplexer descriptor? */\r\n    return NULL;                                        /* programming error! */\r\nif (uptr) {                                             /* called from SET? */\r\n    DEVICE *dptr = find_dev_from_unit (uptr);           /* find device */\r\n    if (dptr == NULL)                                   /* what?? */\r\n        return NULL;\r\n    val = (int32) (uptr - dptr->units);                 /* implicit line # */\r\n    }\r\nif ((val < 0) || (val >= mp->lines))                    /* invalid line? */\r\n    return NULL;\r\nreturn mp->ldsc + val;                                  /* line descriptor */\r\n}\r\n\r\n\r\n/* Get a line descriptor indicated by a string or unit.\r\n\r\n   A pointer to the line descriptor associated with multiplexer \"mp\" and unit\r\n   \"uptr\" or specified by string \"cptr\" is returned.  If \"uptr\" is non-null,\r\n   then the unit number within its associated device implies the line number.\r\n   If \"uptr\" is null, then the string \"cptr\" is parsed for a decimal line\r\n   number.  If the line number is missing, malformed, or outside of the range of\r\n   line numbers associated with \"mp\", then NULL is returned with status set to\r\n   SCPE_ARG.\r\n\r\n   Implementation note:\r\n\r\n    1. A return status of SCPE_IERR implies a programming error (passing an\r\n       invalid pointer or an invalid unit).\r\n*/\r\n\r\nstatic TMLN *tmxr_get_ldsc (UNIT *uptr, const char *cptr, TMXR *mp, t_stat *status)\r\n{\r\nt_value  ln;\r\nTMLN    *lp = NULL;\r\nt_stat   code = SCPE_OK;\r\n\r\nif (mp == NULL)                                         /* missing mux descriptor? */\r\n    code = SCPE_IERR;                                   /* programming error! */\r\n\r\nelse if (uptr) {                                        /* implied line form? */\r\n    lp = tmxr_find_ldsc (uptr, mp->lines, mp);          /* determine line from unit */\r\n\r\n    if (lp == NULL)                                     /* invalid line number? */\r\n        code = SCPE_IERR;                               /* programming error! */\r\n    }\r\n\r\nelse if (cptr == NULL)                                  /* named line form, parameter supplied? */\r\n    code = SCPE_MISVAL;                                 /* no, so report missing */\r\n\r\nelse {\r\n    ln = get_uint (cptr, 10, mp->lines - 1, &code);     /* get line number */\r\n\r\n    if (code == SCPE_OK)                                /* line number OK? */\r\n        lp = mp->ldsc + (int32) ln;                     /* use as index to determine line */\r\n    }\r\n\r\nif (status)                                             /* return value pointer supplied? */\r\n    *status = code;                                     /* store return status value */\r\n\r\nreturn lp;                                              /* return pointer to line descriptor */\r\n}\r\n\r\n/* Generate the Attach string which will fully configure the multiplexer\r\n\r\n   Inputs:\r\n        old     =       pointer to the original configuration string which will be replaced\r\n        *mp     =       pointer to multiplexer\r\n\r\n   Output:\r\n        a complete attach string for the current state of the multiplexer\r\n\r\n*/\r\nstatic char *growstring(char **string, size_t growth)\r\n{\r\n*string = (char *)realloc (*string, 1 + (*string ? strlen (*string) : 0) + growth);\r\nreturn *string + strlen(*string);\r\n}\r\n\r\nstatic char *tmxr_mux_attach_string(char *old, TMXR *mp)\r\n{\r\nchar* tptr = NULL;\r\nint32 i;\r\nTMLN *lp;\r\n\r\nfree (old);\r\ntptr = (char *) calloc (1, 1);\r\n\r\nif (tptr == NULL)                                       /* no more mem? */\r\n    return tptr;\r\n\r\nif (mp->port) {                                         /* copy port */\r\n    char backlog[32] = \"\";\r\n\r\n    if (mp->backlog != 0)\r\n        snprintf (backlog, sizeof (backlog), \";backlog=%u\", mp->backlog);\r\n    sprintf (growstring(&tptr, 33 + strlen (mp->port)), \"%s%s%s\", mp->port, backlog,\r\n                                                                mp->notelnet ? \";notelnet\" :\r\n                                                                               (mp->nomessage ? \";nomessage\" :\r\n                                                                                                \"\"));\r\n    if (mp->acl) {                                      /* copy acl in pieces */\r\n        char gbuf[CBUFSIZE];\r\n        const char *c = mp->acl;\r\n\r\n        while (*c != '\\0') {\r\n            c = get_glyph_nc (c, gbuf, ',');\r\n            sprintf (growstring(&tptr, 9 + strlen (gbuf)), \";%s=%s\", (gbuf[0] == '+') ? \"Accept\" : \"Reject\", gbuf + 1);\r\n            }\r\n        }\r\n    }\r\nif (mp->logfiletmpl[0])                                 /* logfile info */\r\n    sprintf (growstring(&tptr, 7 + strlen (mp->logfiletmpl)), \",Log=%s\", mp->logfiletmpl);\r\nif (mp->buffered)\r\n    sprintf (growstring(&tptr, 10 + 10), \",Buffered=%d\", mp->buffered);\r\nwhile ((*tptr == ',') || (*tptr == ' '))\r\n    memmove (tptr, tptr+1, strlen(tptr+1)+1);\r\nfor (i=0; i<mp->lines; ++i) {\r\n    char *lptr;\r\n    lp = mp->ldsc + i;\r\n\r\n    lptr = tmxr_line_attach_string(lp);\r\n    if (lptr) {\r\n        sprintf (growstring(&tptr, 10+strlen(lptr)), \"%s%s\", *tptr ? \",\" : \"\", lptr);\r\n        free (lptr);\r\n        }\r\n    }\r\nif (mp->lines == 1)\r\n    while ((*tptr == ',') || (*tptr == ' '))\r\n        memmove (tptr, tptr+1, strlen(tptr+1)+1);\r\nif (*tptr == '\\0') {\r\n    free (tptr);\r\n    tptr = NULL;\r\n    }\r\nreturn tptr;\r\n}\r\n\r\n\r\n\r\n/* Global routines */\r\n\r\n\r\n/* Return the Line specific attach setup currently configured for a given line\r\n\r\n   Inputs:\r\n        *lp     =       pointer to terminal line descriptor\r\n   Outputs:\r\n        a string which can be used to reconfigure the line,\r\n        NULL if the line isn't configured\r\n\r\n   Note: The returned string is dynamically allocated memory and must be freed\r\n         when it is no longer needed by calling free\r\n\r\n*/\r\n\r\nchar *tmxr_line_attach_string(TMLN *lp)\r\n{\r\nchar* tptr = NULL;\r\n\r\ntptr = (char *) calloc (1, 1);\r\n\r\nif (tptr == NULL)                                       /* no more mem? */\r\n    return tptr;\r\n\r\nif (lp->destination || lp->port || lp->txlogname || (lp->conn == TMXR_LINE_DISABLED)) {\r\n    if ((lp->mp->lines > 1) || (lp->port))\r\n        sprintf (growstring(&tptr, 32), \"Line=%d\", (int)(lp-lp->mp->ldsc));\r\n    if (lp->conn == TMXR_LINE_DISABLED)\r\n        sprintf (growstring(&tptr, 32), \",Disabled\");\r\n    if (lp->modem_control != lp->mp->modem_control)\r\n        sprintf (growstring(&tptr, 32), \",%s\", lp->modem_control ? \"Modem\" : \"NoModem\");\r\n    if (lp->txbfd && (lp->txbsz != lp->mp->buffered))\r\n        sprintf (growstring(&tptr, 32), \",Buffered=%d\", lp->txbsz);\r\n    if (!lp->txbfd && (lp->mp->buffered > 0))\r\n        sprintf (growstring(&tptr, 32), \",UnBuffered\");\r\n    if (lp->mp->datagram != lp->datagram)\r\n        sprintf (growstring(&tptr, 8), \",%s\", lp->datagram ? \"UDP\" : \"TCP\");\r\n    if (lp->mp->packet != lp->packet)\r\n        sprintf (growstring(&tptr, 8), \",Packet\");\r\n    if (lp->port) {\r\n        char backlog[32] = \"\";\r\n\r\n        if (lp->backlog != 0)\r\n            snprintf (backlog, sizeof (backlog), \";backlog=%u\", lp->backlog);\r\n        sprintf (growstring(&tptr, 64 + strlen (lp->port)), \",%s%s%s%s\", lp->port, backlog,\r\n                                                                       ((lp->mp->notelnet != lp->notelnet) && (!lp->datagram)) ? (lp->notelnet ? \";notelnet\" : \";telnet\") : \"\",\r\n                                                                       ((lp->mp->nomessage != lp->nomessage) && (!lp->datagram)) ? (lp->nomessage ? \";nomessage\" : \";message\") : \"\");\r\n        if (lp->acl) {                                      /* copy acl in pieces */\r\n            char gbuf[CBUFSIZE];\r\n            const char *c = lp->acl;\r\n\r\n            while (*c != '\\0') {\r\n                c = get_glyph_nc (c, gbuf, ',');\r\n                sprintf (growstring(&tptr, 9 + strlen (gbuf)), \";%s=%s\", (gbuf[0] == '+') ? \"Accept\" : \"Reject\", gbuf + 1);\r\n                }\r\n            }\r\n        }\r\n    if (lp->destination) {\r\n        if (lp->serport) {\r\n            char portname[CBUFSIZE];\r\n\r\n            get_glyph_nc (lp->destination, portname, ';');\r\n            sprintf (growstring(&tptr, 25 + strlen (lp->destination)), \",Connect=%s%s%s\", portname, strcmp(\"9600-8N1\", lp->serconfig ? lp->serconfig : \"\") ? \";\" : \"\", strcmp(\"9600-8N1\", lp->serconfig ? lp->serconfig : \"\") ? lp->serconfig : \"\");\r\n            }\r\n        else\r\n            sprintf (growstring(&tptr, 25 + strlen (lp->destination)), \",Connect=%s%s\", lp->destination, ((lp->mp->notelnet != lp->notelnet) && (!lp->datagram)) ? (lp->notelnet ? \";notelnet\" : \";telnet\") : \"\");\r\n        }\r\n    if (lp->txlogname)\r\n        sprintf (growstring(&tptr, 12 + strlen (lp->txlogname)), \",Log=%s\", lp->txlogname);\r\n    if (lp->loopback)\r\n        sprintf (growstring(&tptr, 12 ), \",Loopback\");\r\n    }\r\nif (*tptr == '\\0') {\r\n    free (tptr);\r\n    tptr = NULL;\r\n    }\r\nreturn tptr;\r\n}\r\n\r\n/*\r\n\r\nSet the connection polling interval\r\n\r\n*/\r\nt_stat tmxr_connection_poll_interval (TMXR *mp, uint32 seconds)\r\n{\r\nif (0 == seconds)\r\n    return SCPE_ARG;\r\nmp->poll_interval = seconds;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Poll for new connection\r\n\r\n   Called from unit service routine to test for new connection\r\n\r\n   Inputs:\r\n        *mp     =       pointer to terminal multiplexer descriptor\r\n   Outputs:\r\n        line number activated, -1 if none\r\n\r\n   If a connection order is defined for the descriptor, and the first value is\r\n   not -1 (indicating default order), then the order array is used to find an\r\n   open line.  Otherwise, a search is made of all lines in numerical sequence.\r\n\r\n*/\r\n\r\nint32 tmxr_poll_conn (TMXR *mp)\r\n{\r\nSOCKET newsock;\r\nTMLN *lp;\r\nint32 *op;\r\nint32 i, j;\r\nint32 ringing = -1;\r\nchar *address;\r\nchar msg[512];\r\nuint32 poll_time = sim_os_msec ();\r\n\r\nmemset (msg, 0, sizeof (msg));\r\nif (mp->last_poll_time == 0) {                          /* first poll initializations */\r\n    UNIT *uptr = mp->uptr;\r\n\r\n    if (!uptr)                                          /* Attached ? */\r\n        return -1;                                      /* No connections are possible! */\r\n\r\n    uptr->tmxr = (void *)mp;                            /* Connect UNIT to TMXR */\r\n    uptr->dynflags |= UNIT_TM_POLL;                     /* Tag as polling unit */\r\n\r\n    if (mp->poll_interval == 0)                         /* Assure reasonable polling interval */\r\n        mp->poll_interval = TMXR_DEFAULT_CONNECT_POLL_INTERVAL;\r\n\r\n    for (i=0; i < mp->lines; i++) {\r\n        if (mp->ldsc[i].uptr) {\r\n            mp->ldsc[i].uptr->tmxr = (void *)mp;        /* Connect UNIT to TMXR */\r\n            mp->ldsc[i].uptr->dynflags |= UNIT_TM_POLL; /* Tag as polling unit */\r\n            }\r\n        else\r\n            mp->ldsc[i].uptr = uptr;                    /* default line input polling to primary poll unit */\r\n        if (mp->ldsc[i].o_uptr) {\r\n            mp->ldsc[i].o_uptr->tmxr = (void *)mp;      /* Connect UNIT to TMXR */\r\n            mp->ldsc[i].o_uptr->dynflags |= UNIT_TM_POLL;/* Tag as polling unit */\r\n            }\r\n        else\r\n            mp->ldsc[i].o_uptr = uptr;                  /* default line output polling to primary poll unit */\r\n        }\r\n    }\r\n\r\nif (sim_is_running &&\r\n    ((poll_time - mp->last_poll_time) < mp->poll_interval*1000))\r\n    return -1;                                          /* too soon to try */\r\n\r\nsrand((unsigned int)poll_time);\r\ntmxr_debug_trace (mp, \"tmxr_poll_conn()\");\r\n\r\nmp->last_poll_time = poll_time;\r\n\r\n/* Check for a pending Telnet/tcp connection */\r\n\r\nif (mp->master) {\r\n    if (mp->ring_sock != INVALID_SOCKET) {  /* Use currently 'ringing' socket if one is active */\r\n        newsock = mp->ring_sock;\r\n        mp->ring_sock = INVALID_SOCKET;\r\n        address = mp->ring_ipad;\r\n        mp->ring_ipad = NULL;\r\n        }\r\n    else\r\n        newsock = sim_accept_conn_ex (mp->master, &address, (mp->packet ? SIM_SOCK_OPT_NODELAY : 0));/* poll connect */\r\n\r\n    if (newsock != INVALID_SOCKET) {                    /* got a live one? */\r\n        snprintf (msg, sizeof (msg) - 1, \"tmxr_poll_conn() - Connection from %s\", address);\r\n        tmxr_debug_connect (mp, msg);\r\n        op = mp->lnorder;                               /* get line connection order list pointer */\r\n        i = mp->lines;                                  /* play it safe in case lines == 0 */\r\n        ++mp->sessions;                                 /* count the new session */\r\n\r\n        if (mp->acl) {\r\n            if (sim_addr_acl_check (address, mp->acl) != 0) {\r\n                tmxr_debug_connect (mp, \"tmxr_poll_conn() - Connection Specifically rejected by ACL\");\r\n                sim_close_sock (newsock);\r\n                newsock = INVALID_SOCKET;\r\n                free (address);\r\n                ++mp->acl_rejected_sessions;\r\n                }\r\n            else\r\n                ++mp->acl_accepted_sessions;\r\n            }\r\n\r\n        if (newsock != INVALID_SOCKET) {\r\n            for (j = 0; j < mp->lines; j++, i++) {          /* find next avail line */\r\n                if (op && (*op >= 0) && (*op < mp->lines))  /* order list present and valid? */\r\n                    i = *op++;                              /* get next line in list to try */\r\n                else                                        /* no list or not used or range error */\r\n                    i = j;                                  /* get next sequential line */\r\n\r\n                lp = mp->ldsc + i;                          /* get pointer to line descriptor */\r\n                if ((lp->conn == FALSE) &&                  /* is the line available? */\r\n                    (lp->destination == NULL) &&\r\n                    (lp->master == 0) &&\r\n                    (lp->ser_connect_pending == FALSE) &&\r\n                    (lp->modem_control ? ((lp->modembits & TMXR_MDM_DTR) != 0) : TRUE))\r\n                    break;                                  /* yes, so stop search */\r\n                }\r\n\r\n            if (i >= mp->lines) {                           /* all busy? */\r\n                int32 ringable_count = 0;\r\n\r\n                for (j = 0; j < mp->lines; j++, i++) {      /* find next avail line */\r\n                    lp = mp->ldsc + j;                      /* get pointer to line descriptor */\r\n                    if (lp->framer)\r\n                        continue;\r\n\r\n                    if ((lp->conn == FALSE) &&              /* is the line available? */\r\n                        (lp->destination == NULL) &&\r\n                        (lp->master == 0) &&\r\n                        (lp->ser_connect_pending == FALSE) &&\r\n                        ((lp->modembits & TMXR_MDM_DTR) == 0)) {\r\n                        ++ringable_count;\r\n                        lp->modembits |= TMXR_MDM_RNG;\r\n                        tmxr_debug_connect_line (lp, \"tmxr_poll_conn() - Ringing line\");\r\n                        }\r\n                    }\r\n                if (ringable_count > 0) {\r\n                    ringing = -2;\r\n                    if (mp->ring_start_time == 0) {\r\n                        mp->ring_start_time = poll_time;\r\n                        mp->ring_sock = newsock;\r\n                        mp->ring_ipad = address;\r\n                        }\r\n                    else {\r\n                        if ((poll_time - mp->ring_start_time) < TMXR_MODEM_RING_TIME*1000) {\r\n                            mp->ring_sock = newsock;\r\n                            mp->ring_ipad = address;\r\n                            }\r\n                        else {                                      /* Timeout waiting for DTR */\r\n                            int ln;\r\n\r\n                            /* turn off pending ring signals */\r\n                            for (ln = 0; ln < lp->mp->lines; ln++) {\r\n                                TMLN *tlp = lp->mp->ldsc + ln;\r\n                                if (((tlp->destination == NULL) && (tlp->master == 0)) &&\r\n                                    (tlp->modembits & TMXR_MDM_RNG) && (tlp->conn == FALSE))\r\n                                    tlp->modembits &= ~TMXR_MDM_RNG;\r\n                                }\r\n                            mp->ring_start_time = 0;\r\n                            tmxr_msg (newsock, \"No answer on any connection\\r\\n\");\r\n                            tmxr_debug_connect (mp, \"tmxr_poll_conn() - No Answer - All connections busy\");\r\n                            sim_close_sock (newsock);\r\n                            free (address);\r\n                            }\r\n                        }\r\n                    }\r\n                else {\r\n                    tmxr_msg (newsock, \"All connections busy\\r\\n\");\r\n                    tmxr_debug_connect (mp, \"tmxr_poll_conn() - All connections busy\");\r\n                    sim_close_sock (newsock);\r\n                    free (address);\r\n                    }\r\n                }\r\n            else {\r\n                lp = mp->ldsc + i;                          /* get line desc */\r\n                lp->conn = TRUE;                            /* record connection */\r\n                lp->sock = newsock;                         /* save socket */\r\n                free (address);\r\n                sim_getnames_sock (lp->sock, NULL, &address);\r\n                lp->ipad = address;                         /* ip address */\r\n                tmxr_init_line (lp);                        /* init line */\r\n                lp->notelnet = mp->notelnet;                /* apply mux default telnet setting */\r\n                lp->nomessage = mp->nomessage;              /* apply mux default telnet setting */\r\n                if (!lp->notelnet) {\r\n                    sim_write_sock (newsock, (char *)mantra, sizeof(mantra));\r\n                    tmxr_debug (TMXR_DBG_XMT, lp, \"Sending\", (char *)mantra, sizeof(mantra));\r\n                    lp->telnet_sent_opts = (uint8 *)realloc (lp->telnet_sent_opts, 256);\r\n                    memset (lp->telnet_sent_opts, 0, 256);\r\n                    }\r\n                tmxr_report_connection (mp, lp);\r\n                lp->cnms = sim_os_msec ();                  /* time of connection */\r\n                return i;\r\n                }\r\n            }\r\n        }                                               /* end if newsock */\r\n    }\r\n\r\n/* Look for per line listeners or outbound connecting sockets */\r\nfor (i = 0; i < mp->lines; i++) {                       /* check each line in sequence */\r\n    int j, r = rand();\r\n    lp = mp->ldsc + i;                                  /* get pointer to line descriptor */\r\n\r\n    /* Check for pending serial port connection notification */\r\n\r\n    if (lp->ser_connect_pending) {\r\n        lp->ser_connect_pending = FALSE;\r\n        lp->conn = TRUE;\r\n        return i;\r\n        }\r\n\r\n    /* Framer: report connected. */\r\n    if (lp->framer) {\r\n        if (lp->framer->connect_pending) {\r\n            /* Say \"connected\" when first asked */\r\n            lp->framer->connect_pending = FALSE;\r\n            lp->conn = TRUE;                            /* record connection */\r\n            return i;\r\n            }\r\n        continue;\r\n        }\r\n\r\n    /* Don't service network connections for loopbacked lines */\r\n\r\n    if (lp->loopback)\r\n        continue;\r\n\r\n    /* If two simulators are configured with symmetric virtual null modem\r\n       cables pointing at each other, there may be a problem establishing\r\n       a connection if both systems happen to be checking for the success\r\n       of their connections in the exact same order.  They can each observe\r\n       success in their respective outgoing connections, which haven't\r\n       actually been 'accept'ed on the peer end of the connection.\r\n       We address this issue by checking for the success of an outgoing\r\n       connection and the arrival of an incoming one in a random order.\r\n     */\r\n    for (j=0; j<2; j++)\r\n        switch ((j+r)&1) {\r\n            case 0:\r\n                if (lp->connecting) {                           /* connecting? */\r\n                    char *sockname, *peername;\r\n\r\n                    switch (sim_check_conn(lp->connecting, FALSE))\r\n                        {\r\n                        case 1:                                 /* successful connection */\r\n                            lp->conn = TRUE;                    /* record connection */\r\n                            lp->sock = lp->connecting;          /* it now looks normal */\r\n                            lp->connecting = 0;\r\n                            lp->ipad = (char *)realloc (lp->ipad, 1+strlen (lp->destination));\r\n                            strcpy (lp->ipad, lp->destination);\r\n                            lp->cnms = sim_os_msec ();\r\n                            sim_getnames_sock (lp->sock, &sockname, &peername);\r\n                            snprintf (msg, sizeof (msg) -1, \"tmxr_poll_conn() - Outgoing Line Connection to %s (%s->%s) established\", lp->destination, sockname, peername);\r\n                            tmxr_debug_connect_line (lp, msg);\r\n                            free (sockname);\r\n                            free (peername);\r\n                            if (!lp->notelnet) {\r\n                                sim_write_sock (lp->sock, (char *)mantra, sizeof(mantra));\r\n                                tmxr_debug (TMXR_DBG_XMT, lp, \"Sending\", (char *)mantra, sizeof(mantra));\r\n                                lp->telnet_sent_opts = (uint8 *)realloc (lp->telnet_sent_opts, 256);\r\n                                memset (lp->telnet_sent_opts, 0, 256);\r\n                                }\r\n                            return i;\r\n                        case -1:                                /* failed connection */\r\n                            snprintf (msg, sizeof (msg) -1, \"tmxr_poll_conn() - Outgoing Line Connection to %s failed\", lp->destination);\r\n                            tmxr_debug_connect_line (lp, msg);\r\n                            tmxr_reset_ln (lp);                 /* retry */\r\n                            break;\r\n                        }\r\n                    }\r\n                break;\r\n            case 1:\r\n                if (lp->master) {                                   /* Check for a pending Telnet/tcp connection */\r\n                    while (INVALID_SOCKET != (newsock = sim_accept_conn_ex (lp->master, &address, (lp->packet ? SIM_SOCK_OPT_NODELAY : 0)))) {/* got a live one? */\r\n                        char *sockname, *peername;\r\n\r\n                        sim_getnames_sock (newsock, &sockname, &peername);\r\n                        snprintf (msg, sizeof (msg) -1, \"tmxr_poll_conn() - Incoming Line Connection from %s (%s->%s)\", address, peername, sockname);\r\n                        tmxr_debug_connect_line (lp, msg);\r\n                        free (sockname);\r\n                        free (peername);\r\n                        ++lp->sessions;                             /* count the new session */\r\n\r\n                        if (lp->acl) {                              /* Restrict connection with ACL rules? */\r\n                            if (sim_addr_acl_check (address, lp->acl) != 0) {\r\n                                snprintf (msg, sizeof (msg) -1, \"tmxr_poll_conn() - ACL Rejecting line connection from: %s\", address);\r\n                                tmxr_debug_connect_line (lp, msg);\r\n                                sim_close_sock (newsock);\r\n                                free (address);\r\n                                ++lp->acl_rejected_sessions;\r\n                                continue;                               /* Go back for another connection */\r\n                                }\r\n                            else\r\n                                ++lp->acl_accepted_sessions;\r\n                            }\r\n                        if (lp->destination) {                      /* Virtual Null Modem Cable? */\r\n                            char host[sizeof(msg) - 64];\r\n\r\n                            if (sim_parse_addr (lp->destination, host, sizeof(host), NULL, NULL, 0, NULL, address)) {\r\n                                tmxr_msg (newsock, \"Rejecting connection from unexpected source\\r\\n\");\r\n                                snprintf (msg, sizeof (msg) -1, \"tmxr_poll_conn() - Rejecting line connection from: %s, Expected: %s\", address, host);\r\n                                tmxr_debug_connect_line (lp, msg);\r\n                                sim_close_sock (newsock);\r\n                                free (address);\r\n                                continue;                           /* Try for another connection */\r\n                                }\r\n                            if (lp->connecting) {\r\n                                snprintf (msg, sizeof (msg) -1, \"tmxr_poll_conn() - aborting outgoing line connection attempt to: %s\", lp->destination);\r\n                                tmxr_debug_connect_line (lp, msg);\r\n                                sim_close_sock (lp->connecting);    /* abort our as yet unconnected socket */\r\n                                lp->connecting = 0;\r\n                                }\r\n                            }\r\n                        if (lp->conn == FALSE) {                    /* is the line available? */\r\n                            if ((!lp->modem_control) || (lp->modembits & TMXR_MDM_DTR)) {\r\n                                lp->conn = TRUE;                    /* record connection */\r\n                                lp->sock = newsock;                 /* save socket */\r\n                                lp->ipad = address;                 /* ip address */\r\n                                tmxr_init_line (lp);                /* init line */\r\n                                if (!lp->notelnet) {\r\n                                    sim_write_sock (lp->sock, (char *)mantra, sizeof(mantra));\r\n                                    tmxr_debug (TMXR_DBG_XMT, lp, \"Sending\", (char *)mantra, sizeof(mantra));\r\n                                    lp->telnet_sent_opts = (uint8 *)realloc (lp->telnet_sent_opts, 256);\r\n                                    memset (lp->telnet_sent_opts, 0, 256);\r\n                                    }\r\n                                tmxr_report_connection (mp, lp);\r\n                                lp->cnms = sim_os_msec ();          /* time of connection */\r\n                                return i;\r\n                                }\r\n                            else {\r\n                                tmxr_msg (newsock, \"Line connection not available\\r\\n\");\r\n                                tmxr_debug_connect_line (lp, \"tmxr_poll_conn() - Line connection not available\");\r\n                                sim_close_sock (newsock);\r\n                                free (address);\r\n                                }\r\n                            }\r\n                        else {\r\n                            tmxr_msg (newsock, \"Line connection busy\\r\\n\");\r\n                            tmxr_debug_connect_line (lp, \"tmxr_poll_conn() - Line connection busy\");\r\n                            sim_close_sock (newsock);\r\n                            free (address);\r\n                            }\r\n                        }\r\n                    }\r\n                break;\r\n            }\r\n\r\n    /* Check for needed outgoing connection initiation */\r\n\r\n    if (lp->destination && (!lp->sock) && (!lp->connecting) && (!lp->serport) &&\r\n        (!lp->modem_control || (lp->modembits & TMXR_MDM_DTR))) {\r\n        snprintf (msg, sizeof (msg) - 1, \"tmxr_poll_conn() - establishing outgoing connection to: %s\", lp->destination);\r\n        tmxr_debug_connect_line (lp, msg);\r\n        lp->connecting = sim_connect_sock_ex (lp->datagram ? lp->port : NULL, lp->destination, \"localhost\", NULL, (lp->datagram ? SIM_SOCK_OPT_DATAGRAM : 0)  |\r\n                                                                                                                  (lp->mp->packet ? SIM_SOCK_OPT_NODELAY : 0));\r\n        }\r\n\r\n    }\r\n\r\nreturn ringing;                                         /* no new connections made */\r\n}\r\n\r\n/* Reset a line.\r\n\r\n   The telnet/tcp or serial session associated with multiplexer descriptor \"mp\" and\r\n   line descriptor \"lp\" is disconnected.  An associated tcp socket is\r\n   closed; a serial port is closed if the closeserial parameter is true, otherwise\r\n   for non modem control serial lines DTR is dropped and raised again after 500ms\r\n   to signal the attached serial device.\r\n*/\r\n\r\nstatic t_stat tmxr_reset_ln_ex (TMLN *lp, t_bool closeserial)\r\n{\r\nchar msg[512];\r\n\r\ntmxr_debug_trace_line (lp, \"tmxr_reset_ln_ex()\");\r\n\r\nif (lp->txlog)\r\n    fflush (lp->txlog);                                 /* flush log */\r\n\r\ntmxr_send_buffered_data (lp);                           /* send any buffered data */\r\n\r\nsprintf (msg, \"tmxr_reset_ln_ex(%s)\", closeserial ? \"TRUE\" : \"FALSE\");\r\ntmxr_debug_connect_line (lp, msg);\r\n\r\nif (lp->serport) {\r\n    if (closeserial) {\r\n        sim_close_serial (lp->serport);\r\n        lp->serport = 0;\r\n        lp->ser_connect_pending = FALSE;\r\n        free (lp->destination);\r\n        lp->destination = NULL;\r\n        free (lp->serconfig);\r\n        lp->serconfig = NULL;\r\n        lp->cnms = 0;\r\n        lp->xmte = 1;\r\n        }\r\n    else\r\n        if (!lp->modem_control) {                       /* serial connection? */\r\n            sim_control_serial (lp->serport, 0, TMXR_MDM_DTR|TMXR_MDM_RTS, NULL);/* drop DTR and RTS */\r\n            sim_os_ms_sleep (TMXR_DTR_DROP_TIME);\r\n            sim_control_serial (lp->serport, TMXR_MDM_DTR|TMXR_MDM_RTS, 0, NULL);/* raise DTR and RTS */\r\n            }\r\n    }\r\nelse                                                    /* Telnet connection */\r\n    if (lp->sock) {\r\n        sim_close_sock (lp->sock);                      /* close socket */\r\n        free (lp->telnet_sent_opts);\r\n        lp->telnet_sent_opts = NULL;\r\n        lp->sock = 0;\r\n        lp->conn = FALSE;\r\n        lp->cnms = 0;\r\n        lp->xmte = 1;\r\n        }\r\nfree(lp->ipad);\r\nlp->ipad = NULL;\r\nif ((lp->destination) && (!lp->serport)) {\r\n    if (lp->connecting) {\r\n        sim_close_sock (lp->connecting);\r\n        lp->connecting = 0;\r\n        }\r\n    if ((!lp->modem_control) || (lp->modembits & TMXR_MDM_DTR)) {\r\n        sprintf (msg, \"tmxr_reset_ln_ex() - connecting to %s\", lp->destination);\r\n        tmxr_debug_connect_line (lp, msg);\r\n        lp->connecting = sim_connect_sock_ex (lp->datagram ? lp->port : NULL, lp->destination, \"localhost\", NULL, (lp->datagram ? SIM_SOCK_OPT_DATAGRAM : 0) |\r\n                                                                                                                  (lp->packet ? SIM_SOCK_OPT_NODELAY : 0));\r\n        }\r\n    }\r\ntmxr_init_line (lp);                                /* initialize line state */\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat tmxr_close_ln (TMLN *lp)\r\n{\r\ntmxr_debug_trace_line (lp, \"tmxr_close_ln()\");\r\ntmxr_debug_connect_line (lp, \"tmxr_close_ln()\");\r\nreturn tmxr_reset_ln_ex (lp, TRUE);\r\n}\r\n\r\nt_stat tmxr_reset_ln (TMLN *lp)\r\n{\r\ntmxr_debug_trace_line (lp, \"tmxr_reset_ln()\");\r\nreturn tmxr_reset_ln_ex (lp, FALSE);\r\n}\r\n\r\n/* Enable modem control pass thru\r\n\r\n   Inputs:\r\n        none\r\n\r\n   Output:\r\n        none\r\n\r\n   Implementation note:\r\n\r\n    1  Calling this API disables any actions on the part of this\r\n       library to directly manipulate DTR (&RTS) on serial ports.\r\n\r\n    2  Calling this API enables the tmxr_set_get_modem_bits and\r\n       tmxr_set_config_line APIs.\r\n\r\n*/\r\nstatic t_stat tmxr_clear_modem_control_passthru_state (TMXR *mp, t_bool state)\r\n{\r\nint i;\r\n\r\nif (mp->modem_control == state)\r\n    return SCPE_OK;\r\nif (mp->master)\r\n    return SCPE_ALATT;\r\nfor (i=0; i<mp->lines; ++i) {\r\n    TMLN *lp;\r\n\r\n    lp = mp->ldsc + i;\r\n    if ((lp->master)     ||\r\n        (lp->sock)       ||\r\n        (lp->connecting) ||\r\n        (lp->serport))\r\n        return SCPE_ALATT;\r\n    }\r\nmp->modem_control = state;\r\nfor (i=0; i<mp->lines; ++i)\r\n    mp->ldsc[i].modem_control = state;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat tmxr_set_modem_control_passthru (TMXR *mp)\r\n{\r\nreturn tmxr_clear_modem_control_passthru_state (mp, TRUE);\r\n}\r\n\r\n/* Disable modem control pass thru\r\n\r\n   Inputs:\r\n        none\r\n\r\n   Output:\r\n        none\r\n\r\n   Implementation note:\r\n\r\n    1  Calling this API enables this library's direct manipulation\r\n       of DTR (&RTS) on serial ports.\r\n\r\n    2  Calling this API disables the tmxr_set_get_modem_bits and\r\n       tmxr_set_config_line APIs.\r\n\r\n    3  This API will only change the state of the modem control processing\r\n       of this library if there are no listening ports, serial ports or\r\n       outgoing connections associated with the specified multiplexer\r\n\r\n*/\r\nt_stat tmxr_clear_modem_control_passthru (TMXR *mp)\r\n{\r\nreturn tmxr_clear_modem_control_passthru_state (mp, FALSE);\r\n}\r\n\r\n/* Declare that all lines on a mux have telnet disabled or enabled.\r\n\r\n   This would best be called in a device reset routine and left.\r\n\r\n   If the device implementor wants to make this behavior a user option\r\n   we've got to reject the attempt to set or clear this mode if any\r\n   ports on the MUX are attached.\r\n*/\r\nstatic t_stat tmxr_set_notelnet_state (TMXR *mp, t_bool state)\r\n{\r\nint i;\r\n\r\nif (mp->master)\r\n    return SCPE_ALATT;\r\nfor (i=0; i<mp->lines; ++i) {\r\n    TMLN *lp;\r\n\r\n    lp = mp->ldsc + i;\r\n    if ((lp->master)     ||\r\n        (lp->sock)       ||\r\n        (lp->connecting) ||\r\n        (lp->serport))\r\n        return SCPE_ALATT;\r\n    }\r\nmp->notelnet = state;\r\nfor (i=0; i<mp->lines; ++i)\r\n    mp->ldsc[i].notelnet = state;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Disable Telnet on lines in a mux\r\n\r\n   Inputs:\r\n        none\r\n\r\n   Output:\r\n        SCPE_OK or SCPE_ALATT\r\n\r\n*/\r\nt_stat tmxr_set_notelnet (TMXR *mp)\r\n{\r\nreturn tmxr_set_notelnet_state (mp, TRUE);\r\n}\r\n\r\n/* Enable Telnet on lines in a mux\r\n\r\n   Inputs:\r\n        none\r\n\r\n   Output:\r\n        SCPE_OK or SCPE_ALATT\r\n\r\n*/\r\nt_stat tmxr_clear_notelnet (TMXR *mp)\r\n{\r\nreturn tmxr_set_notelnet_state (mp, FALSE);\r\n}\r\n\r\n/* Declare that all lines on a mux will or won't spit out a message\r\n   on incoming telnet connects.\r\n\r\n   This would best be called in a device reset routine and left.\r\n\r\n   If the device implementor wants to make this behavior a user option\r\n   we've got to reject the attempt to set or clear this mode if any\r\n   ports on the MUX are attached.\r\n*/\r\nstatic t_stat tmxr_set_nomessage_state (TMXR *mp, t_bool state)\r\n{\r\nint i;\r\n\r\nif (mp->master)\r\n    return SCPE_ALATT;\r\nfor (i=0; i<mp->lines; ++i) {\r\n    TMLN *lp;\r\n\r\n    lp = mp->ldsc + i;\r\n    if ((lp->master)     ||\r\n        (lp->sock)       ||\r\n        (lp->connecting) ||\r\n        (lp->serport))\r\n        return SCPE_ALATT;\r\n    }\r\nmp->nomessage = state;\r\nfor (i=0; i<mp->lines; ++i)\r\n    mp->ldsc[i].nomessage = state;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Disable Connect time message in incoming Telnet connections to all\r\n   lines in a mux\r\n\r\n   Inputs:\r\n        none\r\n\r\n   Output:\r\n        SCPE_OK or SCPE_ALATT\r\n\r\n*/\r\nt_stat tmxr_set_nomessage (TMXR *mp)\r\n{\r\nreturn tmxr_set_nomessage_state (mp, TRUE);\r\n}\r\n\r\n/* Enable Connect time message in incoming Telnet connections to all\r\n   lines in a mux\r\n\r\n   Inputs:\r\n        none\r\n\r\n   Output:\r\n        SCPE_OK or SCPE_ALATT\r\n\r\n*/\r\nt_stat tmxr_clear_nomessage (TMXR *mp)\r\n{\r\nreturn tmxr_set_nomessage_state (mp, FALSE);\r\n}\r\n\r\n/* Declare that tmxr_set_config_line is used.\r\n\r\n   This would best be called in a device reset routine and left set.\r\n\r\n   If the device implementor wants to make this behavior a user option\r\n   we've got to reject the attempt to set or clear this mode if any\r\n   ports on the MUX are attached.\r\n*/\r\nt_stat tmxr_set_port_speed_control (TMXR *mp)\r\n{\r\nint i;\r\n\r\nif (!mp->port_speed_control && mp->uptr && !(mp->uptr->flags & UNIT_ATT))\r\n    return sim_messagef (SCPE_ALATT, \"Can't change speed mode while attached.\\n:\");\r\nmp->port_speed_control = TRUE;\r\nfor (i=0; i<mp->lines; ++i)\r\n    mp->ldsc[i].port_speed_control = mp->port_speed_control;\r\nsim_debug (TMXR_DBG_CFG, mp->dptr, \"Speed Mode: Enabled\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Declare that tmxr_set_config_line is not used.\r\n\r\n   This should be only be called after a previous call to\r\n   tmxr_set_port_speed_control since the default is cleared.  It can not\r\n   be called if any ports on the device are attached.\r\n*/\r\nt_stat tmxr_clear_port_speed_control (TMXR *mp)\r\n{\r\nint i;\r\n\r\nif (mp->port_speed_control && mp->uptr && !(mp->uptr->flags & UNIT_ATT))\r\n    return sim_messagef (SCPE_ALATT, \"Can't change speed mode while attached.\\n:\");\r\nmp->port_speed_control = FALSE;\r\nfor (i=0; i<mp->lines; ++i)\r\n    mp->ldsc[i].port_speed_control = mp->port_speed_control;\r\nsim_debug (TMXR_DBG_CFG, mp->dptr, \"Speed Mode: Disabled\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Specify a non-default listen backlog.\r\n\r\n   The default listen backlog is 0.  This API overrides that default.\r\n*/\r\nt_stat tmxr_set_backlog (TMXR *mp, int32 backlog)\r\n{\r\nmp->backlog = backlog;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Declare that tmxr_set_config_line is used for line.\r\n\r\n   This would best be called in a device reset routine and left set.\r\n\r\n   If the device implementor wants to make this behavior a user option\r\n   we've got to reject the attempt to set or clear this mode if any\r\n   ports on the MUX are attached.\r\n*/\r\nt_stat tmxr_set_line_port_speed_control (TMXR *mp, int line)\r\n{\r\nif (mp->uptr && !(mp->uptr->flags & UNIT_ATT))\r\n    return sim_messagef (SCPE_ALATT, \"Can't change speed mode while attached.\\n:\");\r\nif (line >= mp->lines)\r\n    return sim_messagef (SCPE_ARG, \"Invalid line for multiplexer: %d\\n\", line);\r\nmp->ldsc[line].port_speed_control = TRUE;\r\nsim_debug (TMXR_DBG_CFG, mp->dptr, \"Speed Mode: Enabled for line %d\\n\", line);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Declare that tmxr_set_config_line is not used for line.\r\n\r\n   This should be only be called after a previous call to\r\n   tmxr_set_port_speed_control since the default is cleared.  It can not\r\n   be called if any ports on the device are attached.\r\n*/\r\nt_stat tmxr_clear_line_port_speed_control (TMXR *mp, int line)\r\n{\r\nif (mp->uptr && !(mp->uptr->flags & UNIT_ATT))\r\n    return sim_messagef (SCPE_ALATT, \"Can't change speed mode while attached.\\n:\");\r\nif (line >= mp->lines)\r\n    return sim_messagef (SCPE_ARG, \"Invalid line for multiplexer: %d\\n\", line);\r\nmp->ldsc[line].port_speed_control = FALSE;\r\nsim_debug (TMXR_DBG_CFG, mp->dptr, \"Speed Mode: Disabled for line %d\\n\", line);\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Manipulate the modem control bits of a specific line\r\n\r\n   Inputs:\r\n        *lp     =       pointer to terminal line descriptor\r\n        bits_to_set     TMXR_MDM_DTR and/or TMXR_MDM_RTS as desired\r\n        bits_to_clear   TMXR_MDM_DTR and/or TMXR_MDM_RTS as desired\r\n\r\n   Output:\r\n        status_bits     if non NULL, returns all of the current signal\r\n                        state bits (incoming: DCD, RNG, CTS, DSR) along\r\n                        with the specifically settable bits (DTR, RTS)\r\n\r\n   Implementation note:\r\n\r\n       If a line is connected to a serial port, then these values\r\n       affect and reflect the state of the serial port.  If the line\r\n       is connected to a network socket (or could be) then the network\r\n       session state is set, cleared and/or returned.  If the line is\r\n       connected to a DDCMP sync framer, only DTR and RTS set/clear\r\n       are acted on, and the returned modem state bits are constructed\r\n       based on the framer state.  For the framer, setting DTR starts\r\n       the framer, and clearing DTR stops it.\r\n*/\r\nt_stat tmxr_set_get_modem_bits (TMLN *lp, int32 bits_to_set, int32 bits_to_clear, int32 *status_bits)\r\n{\r\nint32 before_modem_bits, incoming_state;\r\nDEVICE *dptr;\r\n\r\ntmxr_debug_trace_line (lp, \"tmxr_set_get_modem_bits()\");\r\n\r\nif ((bits_to_set & ~(TMXR_MDM_OUTGOING)) ||         /* Assure only settable bits */\r\n    (bits_to_clear & ~(TMXR_MDM_OUTGOING)) ||\r\n    (bits_to_set & bits_to_clear))                  /* and can't set and clear the same bits */\r\n    return SCPE_ARG;\r\nif (lp->framer) {\r\n    /* DDCMP framer attached, ignore set except for DTR and RTS.\r\n     * Given the most recently received framer status, report DSR if\r\n     * the framer is currently on, and CTS and Carrier Detect if a\r\n     * carrier has been received.\r\n     */\r\n    bits_to_set &= TMXR_MDM_DTR | TMXR_MDM_RTS;\r\n    bits_to_clear &= TMXR_MDM_DTR | TMXR_MDM_RTS;\r\n    if ((bits_to_set & TMXR_MDM_DTR) && !(lp->modembits & TMXR_MDM_DTR)) {\r\n        /* DTR being set, start framer if we're using one.  Use DMC\r\n         * mode for now.\r\n         */\r\n        tmxr_start_framer (lp, TRUE);\r\n        }\r\n    else {\r\n        if ((bits_to_clear & TMXR_MDM_DTR) && (lp->modembits & TMXR_MDM_DTR))\r\n            /* DTR being cleared, stop framer if we're using one. */\r\n            tmxr_stop_framer (lp);\r\n        }\r\n    incoming_state = lp->modembits | bits_to_set;\r\n    incoming_state &= ~bits_to_clear;\r\n    if (lp->framer->status.on)\r\n        incoming_state |= TMXR_MDM_DSR;\r\n    if (lp->framer->status.on & ON_SYN)\r\n        /* Carrier detected */\r\n        incoming_state |= TMXR_MDM_CTS | TMXR_MDM_DCD;\r\n    lp->modembits = incoming_state;\r\n    if (status_bits)\r\n        *status_bits = incoming_state;\r\n    return SCPE_OK;\r\n}\r\nbefore_modem_bits = lp->modembits;\r\nlp->modembits |= bits_to_set;\r\nlp->modembits &= ~bits_to_clear;\r\nif ((lp->sock) || (lp->serport) || (lp->loopback)) {\r\n    if (lp->modembits & TMXR_MDM_DTR) {\r\n        incoming_state = TMXR_MDM_DSR;\r\n        if (lp->modembits & TMXR_MDM_RTS)\r\n            incoming_state |= TMXR_MDM_CTS;\r\n        if (lp->halfduplex) {\r\n            if (incoming_state & TMXR_MDM_CTS)\r\n                incoming_state |= TMXR_MDM_DCD;\r\n            }\r\n        else\r\n            incoming_state |= TMXR_MDM_DCD;\r\n        }\r\n    else\r\n        incoming_state = TMXR_MDM_DCD | TMXR_MDM_DSR | ((lp->modembits & TMXR_MDM_DTR) ? 0 : TMXR_MDM_RNG);\r\n    }\r\nelse {\r\n    if (((before_modem_bits & TMXR_MDM_DTR) == 0) &&    /* Upward transition of DTR? */\r\n        ((lp->modembits & TMXR_MDM_DTR) != 0)     &&\r\n        (lp->conn == FALSE)                       &&    /* Not connected */\r\n        (lp->modembits & TMXR_MDM_RNG)) {               /* and Ring Signal Present */\r\n        if ((lp->destination == NULL) &&\r\n            (lp->master == 0) &&\r\n            (lp->mp && (lp->mp->ring_sock))) {\r\n            int ln;\r\n\r\n            lp->conn = TRUE;                            /* record connection */\r\n            lp->sock = lp->mp->ring_sock;               /* save socket */\r\n            lp->mp->ring_sock = INVALID_SOCKET;\r\n            lp->ipad = lp->mp->ring_ipad;               /* ip address */\r\n            lp->mp->ring_ipad = NULL;\r\n            lp->mp->ring_start_time = 0;\r\n            tmxr_init_line (lp);                        /* init line */\r\n            lp->notelnet = lp->mp->notelnet;            /* apply mux default telnet setting */\r\n            lp->nomessage = lp->mp->nomessage;          /* apply mux default telnet setting */\r\n            if (!lp->notelnet) {\r\n                sim_write_sock (lp->sock, (char *)mantra, sizeof(mantra));\r\n                tmxr_debug (TMXR_DBG_XMT, lp, \"Sending\", (char *)mantra, sizeof(mantra));\r\n                lp->telnet_sent_opts = (uint8 *)realloc (lp->telnet_sent_opts, 256);\r\n                memset (lp->telnet_sent_opts, 0, 256);\r\n                }\r\n            tmxr_report_connection (lp->mp, lp);\r\n            lp->cnms = sim_os_msec ();                  /* time of connection */\r\n            lp->modembits &= ~TMXR_MDM_RNG;             /* turn off ring on this line*/\r\n            /* turn off other pending ring signals */\r\n            for (ln = 0; ln < lp->mp->lines; ln++) {\r\n                TMLN *tlp = lp->mp->ldsc + ln;\r\n                if (((tlp->destination == NULL) && (tlp->master == 0)) &&\r\n                    (tlp->modembits & TMXR_MDM_RNG) && (tlp->conn == FALSE))\r\n                    tlp->modembits &= ~TMXR_MDM_RNG;\r\n                }\r\n            }\r\n        }\r\n    if (!lp->conn)\r\n        lp->modembits &= ~(TMXR_MDM_DCD | TMXR_MDM_CTS);\r\n    if ((lp->master) || (lp->mp && lp->mp->master) ||\r\n        (lp->port && lp->destination))\r\n        incoming_state = TMXR_MDM_DSR;\r\n    else\r\n        incoming_state = 0;\r\n    }\r\nlp->modembits |= incoming_state;\r\ndptr = (lp->dptr ? lp->dptr : (lp->mp ? lp->mp->dptr : NULL));\r\nif ((lp->modembits != before_modem_bits) && (sim_deb && lp->mp && dptr)) {\r\n    sim_debug_bits (TMXR_DBG_MDM, dptr, tmxr_modem_bits, before_modem_bits, lp->modembits, FALSE);\r\n    sim_debug (TMXR_DBG_MDM, dptr, \" - Line %d - %p\\n\", (int)(lp-lp->mp->ldsc), lp->txb);\r\n    }\r\nif (status_bits)\r\n    *status_bits = (lp->modembits & (TMXR_MDM_INCOMING | TMXR_MDM_OUTGOING));\r\nif (lp->mp && lp->modem_control) {                  /* This API ONLY works on modem_control enabled multiplexer lines */\r\n    if ((bits_to_set | bits_to_clear) || status_bits) {/* Anything to do? */\r\n        if (lp->loopback) {\r\n            if ((lp->modembits ^ before_modem_bits) & TMXR_MDM_DTR) { /* DTR changed? */\r\n                lp->ser_connect_pending = (lp->modembits & TMXR_MDM_DTR);\r\n                lp->conn = !(lp->modembits & TMXR_MDM_DTR);\r\n                }\r\n            return SCPE_OK;\r\n            }\r\n        if (lp->serport) {\r\n            t_stat r = sim_control_serial (lp->serport, bits_to_set, bits_to_clear, status_bits);\r\n            if (status_bits && (r == SCPE_OK))\r\n                lp->modembits = (lp->modembits & ~TMXR_MDM_INCOMING) | *status_bits;\r\n            return r;\r\n            }\r\n        if ((lp->sock) || (lp->connecting)) {\r\n            if ((before_modem_bits & bits_to_clear & TMXR_MDM_DTR) != 0) { /* drop DTR? */\r\n                if (lp->sock)\r\n                    tmxr_report_disconnection (lp);     /* report closure */\r\n                tmxr_reset_ln (lp);\r\n                }\r\n            }\r\n        else {\r\n            if ((lp->destination) &&                    /* Virtual Null Modem Cable */\r\n                (bits_to_set & ~before_modem_bits &     /* and DTR being Raised */\r\n                 TMXR_MDM_DTR)) {\r\n                char msg[512];\r\n\r\n                sprintf (msg, \"tmxr_set_get_modem_bits() - establishing outgoing connection to: %s\", lp->destination);\r\n                tmxr_debug_connect_line (lp, msg);\r\n                lp->connecting = sim_connect_sock_ex (lp->datagram ? lp->port : NULL, lp->destination, \"localhost\", NULL, (lp->datagram ? SIM_SOCK_OPT_DATAGRAM : 0) |\r\n                                                                                                                          (lp->packet ? SIM_SOCK_OPT_NODELAY : 0));\r\n                }\r\n            }\r\n        }\r\n    return SCPE_OK;\r\n    }\r\nif ((lp->sock) || (lp->connecting)) {\r\n    if ((before_modem_bits & bits_to_clear & TMXR_MDM_DTR) != 0) { /* drop DTR? */\r\n        if (lp->sock)\r\n            tmxr_report_disconnection (lp);     /* report closure */\r\n        tmxr_reset_ln (lp);\r\n        }\r\n    }\r\nif ((lp->serport) && (!lp->loopback))\r\n    sim_control_serial (lp->serport, 0, 0, status_bits);\r\nreturn SCPE_INCOMP;\r\n}\r\n\r\n/* Enable or Disable loopback mode on a line\r\n\r\n   Inputs:\r\n        lp -                the line to change\r\n        enable_loopback -   enable or disable flag\r\n\r\n   Output:\r\n        none\r\n\r\n   Implementation note:\r\n\r\n    1) When enabling loopback mode, this API will disconnect any currently\r\n       connected TCP or Serial session.\r\n    2) When disabling loopback mode, prior network connections and/or\r\n       serial port connections will be restored.\r\n\r\n*/\r\nt_stat tmxr_set_line_loopback (TMLN *lp, t_bool enable_loopback)\r\n{\r\nDEVICE *dptr = (lp->dptr ? lp->dptr : (lp->mp ? lp->mp->dptr : NULL));\r\n\r\nif (lp->loopback == (enable_loopback != FALSE))\r\n    return SCPE_OK;                 /* Nothing to do */\r\nlp->loopback = (enable_loopback != FALSE);\r\nif (lp->loopback) {\r\n    lp->lpbsz = lp->rxbsz;\r\n    lp->lpb = (char *)realloc(lp->lpb, lp->lpbsz);\r\n    lp->lpbcnt = lp->lpbpi = lp->lpbpr = 0;\r\n    if (!lp->conn)\r\n        lp->ser_connect_pending = TRUE;\r\n    }\r\nelse {\r\n    free (lp->lpb);\r\n    lp->lpb = NULL;\r\n    lp->lpbsz = 0;\r\n    }\r\nsim_debug (TMXR_DBG_CFG, dptr, \"Loopback %s for line %d\\n\", enable_loopback ? \"Enabled\" : \"Disabled\", (int)(lp - lp->mp->ldsc));\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_bool tmxr_get_line_loopback (TMLN *lp)\r\n{\r\nreturn (lp->loopback != FALSE);\r\n}\r\n\r\n/* Enable or Disable halfduplex mode on a line\r\n\r\n   Inputs:\r\n        lp -                the line to change\r\n        enable_halfduplex - enable or disable flag\r\n\r\n   Output:\r\n        none\r\n\r\n   When a network connected line is in halfduplex mode, DCD modem signal\r\n   track with CTS.  When not in halfduplex mode the DCD modem signal for\r\n   network connected lines tracks with DSR.\r\n\r\n*/\r\nt_stat tmxr_set_line_halfduplex (TMLN *lp, t_bool enable_halfduplex)\r\n{\r\nDEVICE *dptr = (lp->dptr ? lp->dptr : (lp->mp ? lp->mp->dptr : NULL));\r\n\r\nif (lp->halfduplex == (enable_halfduplex != FALSE))\r\n    return SCPE_OK;                 /* Nothing to do */\r\nlp->halfduplex = (enable_halfduplex != FALSE);\r\nsim_debug (TMXR_DBG_CFG, dptr, \"Half Duplex %s for line %d\\n\", enable_halfduplex ? \"Enabled\" : \"Disabled\", (int)(lp - lp->mp->ldsc));\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_bool tmxr_get_line_halfduplex (TMLN *lp)\r\n{\r\nreturn (lp->halfduplex != FALSE);\r\n}\r\n\r\nt_stat tmxr_set_config_line (TMLN *lp, CONST char *config)\r\n{\r\nt_stat r;\r\nDEVICE *dptr = (lp->dptr ? lp->dptr : (lp->mp ? lp->mp->dptr : NULL));\r\nchar *prior = lp->serconfig ? strdup (lp->serconfig) : NULL;\r\n\r\ntmxr_debug_trace_line (lp, \"tmxr_set_config_line()\");\r\nif (lp->serport) {\r\n    r = sim_config_serial (lp->serport, config);\r\n    if (r == SCPE_OK)\r\n        r = tmxr_set_line_speed (lp, config);\r\n    }\r\nelse {\r\n    lp->serconfig = (char *)realloc (lp->serconfig, 1 + strlen (config));\r\n    strcpy (lp->serconfig, config);\r\n    r = tmxr_set_line_speed (lp, lp->serconfig);;\r\n    if (r != SCPE_OK) {\r\n        free (lp->serconfig);\r\n        lp->serconfig = NULL;\r\n        }\r\n    }\r\nsim_debug (TMXR_DBG_CFG, dptr, \"Line %d changed from %s to %s\\n\", (int)(lp - lp->mp->ldsc), prior ? prior : \"\", lp->serconfig);\r\nfree (prior);\r\nif ((r == SCPE_OK) && (lp->mp) && (lp->mp->uptr))   /* Record port state for proper restore */\r\n    lp->mp->uptr->filename = tmxr_mux_attach_string (lp->mp->uptr->filename, lp->mp);\r\nreturn r;\r\n}\r\n\r\n\r\n/* Get character from specific line\r\n\r\n   Inputs:\r\n        *lp     =       pointer to terminal line descriptor\r\n   Output:\r\n        (TMXR_VALID | char) or 0 if no data is currently available\r\n                            on the specified line.\r\n\r\n   Implementation note:\r\n\r\n    1. If a line break was detected coincident with the current character, the\r\n       receive break status associated with the character is cleared, and\r\n       SCPE_BREAK is ORed into the return value.\r\n*/\r\n\r\nint32 tmxr_getc_ln (TMLN *lp)\r\n{\r\nint32 j;\r\nt_stat val = 0;\r\nuint32 tmp;\r\ndouble sim_gtime_now = sim_gtime ();\r\n\r\ntmxr_debug_trace_line (lp, \"tmxr_getc_ln()\");\r\nif (((lp->conn || lp->txbfd) && lp->rcve) &&            /* (conn or buffered) & enb & */\r\n    ((!lp->rxbps) ||                                    /* (!rate limited || enough time passed)? */\r\n     (sim_gtime_now >= lp->rxnexttime))) {\r\n    if (!sim_send_poll_data (lp->send, &val)) {         /* injected input characters available? */\r\n        j = lp->rxbpi - lp->rxbpr;                      /* # input chrs */\r\n        if (j) {                                        /* any? */\r\n            tmp = lp->rxb[lp->rxbpr];                   /* get char */\r\n            val = TMXR_VALID | (tmp & 0377);            /* valid + chr */\r\n            if (lp->rbr[lp->rxbpr]) {                   /* break? */\r\n                lp->rbr[lp->rxbpr] = 0;                 /* clear status */\r\n                val = val | SCPE_BREAK;                 /* indicate to caller */\r\n                }\r\n            lp->rxbpr = lp->rxbpr + 1;                  /* adv pointer */\r\n            }\r\n        }\r\n    }                                                   /* end if conn */\r\nif (lp->rxbpi == lp->rxbpr)                             /* empty? zero ptrs */\r\n    lp->rxbpi = lp->rxbpr = 0;\r\nif (val) {                                              /* Got something? */\r\n    if (lp->rxbps)\r\n        lp->rxnexttime = floor (sim_gtime_now + ((lp->rxdeltausecs * sim_timer_inst_per_sec ()) / USECS_PER_SECOND));\r\n    else\r\n        lp->rxnexttime = floor (sim_gtime_now + ((lp->mp->uptr->wait * sim_timer_inst_per_sec ()) / USECS_PER_SECOND));\r\n    }\r\ntmxr_debug_return(lp, val);\r\nreturn val;\r\n}\r\n\r\n/* Get packet from specific line\r\n\r\n   Inputs:\r\n        *lp     =       pointer to terminal line descriptor\r\n        **pbuf  =       pointer to pointer of packet contents\r\n        *psize  =       pointer to packet size\r\n        frame_byte -    byte which separates packets in the tcp stream\r\n                        (0 means no separation character)\r\n\r\n   Output:\r\n        SCPE_LOST       link state lost\r\n        SCPE_OK         Packet returned OR no packet available\r\n\r\n   Implementation notes:\r\n\r\n    1. If a packet is not yet available, then the pbuf address returned is\r\n       NULL, but success (SCPE_OK) is returned\r\n*/\r\n\r\nt_stat tmxr_get_packet_ln (TMLN *lp, const uint8 **pbuf, size_t *psize)\r\n{\r\nreturn tmxr_get_packet_ln_ex (lp, pbuf, psize, 0);\r\n}\r\n\r\nt_stat tmxr_get_packet_ln_ex (TMLN *lp, const uint8 **pbuf, size_t *psize, uint8 frame_byte)\r\n{\r\nint32 c;\r\nsize_t pktsize;\r\nsize_t fc_size = (frame_byte ? 1 : 0);\r\n\r\nwhile (TMXR_VALID & (c = tmxr_getc_ln (lp))) {\r\n    if (lp->rxpboffset + 3 > lp->rxpbsize) {\r\n        lp->rxpbsize += 512;\r\n        lp->rxpb = (uint8 *)realloc (lp->rxpb, lp->rxpbsize);\r\n        }\r\n    if ((lp->rxpboffset == 0) && (fc_size) && (c != frame_byte)) {\r\n        tmxr_debug (TMXR_DBG_PRCV, lp, \"Received Unexpected Framing Byte\", (char *)&lp->rxpb[lp->rxpboffset], 1);\r\n        continue;\r\n        }\r\n    if ((lp->datagram) && (lp->rxpboffset == fc_size)) {\r\n        /* Datagram packet length is provided as a part of the natural datagram\r\n           delivery, for TCP lines, we read the packet length from the data stream.\r\n           So, here we stuff packet size into head of packet buffer so it looks like\r\n           it was delivered by TCP and the below return logic doesn't have to worry */\r\n        lp->rxpb[lp->rxpboffset++] = (uint8)(((1 + lp->rxbpi - lp->rxbpr) >> 8) & 0xFF);\r\n        lp->rxpb[lp->rxpboffset++] = (uint8)((1 + lp->rxbpi - lp->rxbpr) & 0xFF);\r\n        }\r\n    lp->rxpb[lp->rxpboffset++] = c & 0xFF;\r\n    if (lp->rxpboffset >= (2 + fc_size)) {\r\n        pktsize = (lp->rxpb[0+fc_size] << 8) | lp->rxpb[1+fc_size];\r\n        if (pktsize == (lp->rxpboffset - 2)) {\r\n            ++lp->rxpcnt;\r\n            *pbuf = &lp->rxpb[2+fc_size];\r\n            *psize = pktsize;\r\n            lp->rxpboffset = 0;\r\n            tmxr_debug (TMXR_DBG_PRCV, lp, \"Received Packet\", (char *)&lp->rxpb[2+fc_size], pktsize);\r\n            return SCPE_OK;\r\n            }\r\n        }\r\n    }\r\n*pbuf = NULL;\r\n*psize = 0;\r\nif (lp->conn)\r\n    return SCPE_OK;\r\nreturn SCPE_LOST;\r\n}\r\n\r\n/* Poll for input\r\n\r\n   Inputs:\r\n        *mp     =       pointer to terminal multiplexer descriptor\r\n   Outputs:     none\r\n*/\r\n\r\nvoid tmxr_poll_rx (TMXR *mp)\r\n{\r\nint32 i, nbytes, j;\r\nTMLN *lp;\r\n\r\ntmxr_debug_trace (mp, \"tmxr_poll_rx()\");\r\nfor (i = 0; i < mp->lines; i++) {                       /* loop thru lines */\r\n    lp = mp->ldsc + i;                                  /* get line desc */\r\n    if (!(lp->sock || lp->serport || lp->loopback || lp->framer) ||\r\n        !(lp->rcve))                                    /* skip if not connected */\r\n        continue;\r\n\r\n    nbytes = 0;\r\n    if (lp->rxbpi == 0)                                 /* need input? */\r\n        nbytes = tmxr_read (lp,                         /* yes, read */\r\n            lp->rxbsz - TMXR_GUARD);                    /* leave spc for Telnet cruft */\r\n    else {\r\n        if (lp->tsta)                                   /* in Telnet seq? */\r\n            nbytes = tmxr_read (lp,                     /* yes, read to end */\r\n                                    lp->rxbsz - lp->rxbpi);\r\n        }\r\n\r\n    if (nbytes < 0) {                                   /* line error? */\r\n        if (!lp->datagram) {                            /* ignore errors reading UDP sockets */\r\n            if (!lp->txbfd || lp->notelnet)\r\n                lp->txbpi = lp->txbpr = 0;              /* Drop the data we already know we can't send */\r\n            tmxr_close_ln (lp);                         /* disconnect line */\r\n            }\r\n        }\r\n\r\n    else if (nbytes > 0) {                              /* if data rcvd */\r\n\r\n        tmxr_debug (TMXR_DBG_RCV, lp, \"Received\", &(lp->rxb[lp->rxbpi]), nbytes);\r\n\r\n        j = lp->rxbpi;                                  /* start of data */\r\n        lp->rxbpi = lp->rxbpi + nbytes;                 /* adv pointers */\r\n        lp->rxcnt = lp->rxcnt + nbytes;\r\n\r\n/* Examine new data, remove TELNET cruft before making input available */\r\n\r\n        if (!lp->notelnet) {                            /* Are we looking for telnet interpretation? */\r\n            for (; j < lp->rxbpi; ) {                   /* loop thru char */\r\n                u_char tmp = (u_char)lp->rxb[j];        /* get char */\r\n                switch (lp->tsta) {                     /* case tlnt state */\r\n\r\n                case TNS_NORM:                          /* normal */\r\n                    if (tmp == TN_IAC) {                /* IAC? */\r\n                        lp->tsta = TNS_IAC;             /* change state */\r\n                        tmxr_rmvrc (lp, j);             /* remove char */\r\n                        break;\r\n                        }\r\n                    if ((tmp == TN_CR) && lp->dstb)     /* CR, no bin */\r\n                        lp->tsta = TNS_CRPAD;           /* skip pad char */\r\n                    j = j + 1;                          /* advance j */\r\n                    break;\r\n\r\n                case TNS_IAC:                           /* IAC prev */\r\n                    if (tmp == TN_IAC) {                /* IAC + IAC */\r\n                        lp->tsta = TNS_NORM;            /* treat as normal */\r\n                        j = j + 1;                      /* advance j */\r\n                        break;                          /* keep IAC */\r\n                        }\r\n                    if (tmp == TN_BRK) {                /* IAC + BRK? */\r\n                        lp->tsta = TNS_NORM;            /* treat as normal */\r\n                        lp->rxb[j] = 0;                 /* char is null */\r\n                        lp->rbr[j] = 1;                 /* flag break */\r\n                        j = j + 1;                      /* advance j */\r\n                        break;\r\n                        }\r\n                    switch (tmp) {\r\n                    case TN_WILL:                       /* IAC + WILL? */\r\n                        lp->tsta = TNS_WILL;\r\n                        break;\r\n                    case TN_WONT:                       /* IAC + WONT? */\r\n                        lp->tsta = TNS_WONT;\r\n                        break;\r\n                    case TN_DO:                         /* IAC + DO? */\r\n                        lp->tsta = TNS_DO;\r\n                        break;\r\n                    case TN_DONT:                       /* IAC + DONT? */\r\n                        lp->tsta = TNS_SKIP;            /* IAC + other */\r\n                        break;\r\n                    case TN_GA: case TN_EL:             /* IAC + other 2 byte types */\r\n                    case TN_EC: case TN_AYT:\r\n                    case TN_AO: case TN_IP:\r\n                    case TN_NOP:\r\n                        lp->tsta = TNS_NORM;            /* ignore */\r\n                        break;\r\n                    case TN_SB:                         /* IAC + SB sub-opt negotiation */\r\n                    case TN_DATAMK:                     /* IAC + data mark */\r\n                    case TN_SE:                         /* IAC + SE sub-opt end */\r\n                        lp->tsta = TNS_NORM;            /* ignore */\r\n                        break;\r\n                        }\r\n                    tmxr_rmvrc (lp, j);                 /* remove char */\r\n                    break;\r\n\r\n                case TNS_WILL:                          /* IAC+WILL prev */\r\n                    if ((tmp == TN_STATUS) ||\r\n                        (tmp == TN_TIMING) ||\r\n                        (tmp == TN_NAOCRD) ||\r\n                        (tmp == TN_NAOHTS) ||\r\n                        (tmp == TN_NAOHTD) ||\r\n                        (tmp == TN_NAOFFD) ||\r\n                        (tmp == TN_NAOVTS) ||\r\n                        (tmp == TN_NAOVTD) ||\r\n                        (tmp == TN_NAOLFD) ||\r\n                        (tmp == TN_EXTEND) ||\r\n                        (tmp == TN_LOGOUT) ||\r\n                        (tmp == TN_BM)     ||\r\n                        (tmp == TN_DET)    ||\r\n                        (tmp == TN_SENDLO) ||\r\n                        (tmp == TN_TERMTY) ||\r\n                        (tmp == TN_ENDREC) ||\r\n                        (tmp == TN_TUID)   ||\r\n                        (tmp == TN_OUTMRK) ||\r\n                        (tmp == TN_TTYLOC) ||\r\n                        (tmp == TN_3270)   ||\r\n                        (tmp == TN_X3PAD)  ||\r\n                        (tmp == TN_NAWS)   ||\r\n                        (tmp == TN_TERMSP) ||\r\n                        (tmp == TN_TOGFLO) ||\r\n                        (tmp == TN_XDISPL) ||\r\n                        (tmp == TN_ENVIRO) ||\r\n                        (tmp == TN_AUTH)   ||\r\n                        (tmp == TN_ENCRYP) ||\r\n                        (tmp == TN_NEWENV) ||\r\n                        (tmp == TN_TN3270) ||\r\n                        (tmp == TN_CHARST) ||\r\n                        (tmp == TN_COMPRT) ||\r\n                        (tmp == TN_KERMIT)) {\r\n                        /* Reject (DONT) these 'uninteresting' options only one time to avoid loops */\r\n                        if (0 == (lp->telnet_sent_opts[tmp] & TNOS_DONT)) {\r\n                            lp->notelnet = TRUE;                /* Temporarily disable so */\r\n                            tmxr_putc_ln (lp, TN_IAC);          /* IAC gets injected bare */\r\n                            lp->notelnet = FALSE;\r\n                            tmxr_putc_ln (lp, TN_DONT);\r\n                            tmxr_putc_ln (lp, tmp);\r\n                            lp->telnet_sent_opts[tmp] |= TNOS_DONT;/* Record DONT sent */\r\n                            }\r\n                        }\r\n                    /* fall through */\r\n                case TNS_WONT:           /* IAC+WILL/WONT prev */\r\n                    if (tmp == TN_BIN) {                /* BIN? */\r\n                        if (lp->tsta == TNS_WILL) {\r\n                            lp->dstb = 0;\r\n                            }\r\n                        else {\r\n                            lp->dstb = 1;\r\n                            }\r\n                        }\r\n                    tmxr_rmvrc (lp, j);                 /* remove it */\r\n                    lp->tsta = TNS_NORM;                /* next normal */\r\n                    break;\r\n\r\n                /* Negotiation with the HP terminal emulator \"QCTerm\" is not working.\r\n                   QCTerm says \"WONT BIN\" but sends bare CRs.  RFC 854 says:\r\n\r\n                     Note that \"CR LF\" or \"CR NUL\" is required in both directions\r\n                     (in the default ASCII mode), to preserve the symmetry of the\r\n                     NVT model.  ...The protocol requires that a NUL be inserted\r\n                     following a CR not followed by a LF in the data stream.\r\n\r\n                   Until full negotiation is implemented, we work around the problem\r\n                   by checking the character following the CR in non-BIN mode and\r\n                   strip it only if it is LF or NUL.  This should not affect\r\n                   conforming clients.\r\n                */\r\n\r\n                case TNS_CRPAD:                         /* only LF or NUL should follow CR */\r\n                    lp->tsta = TNS_NORM;                /* next normal */\r\n                    if ((tmp == TN_LF) ||               /* CR + LF ? */\r\n                        (tmp == TN_NUL))                /* CR + NUL? */\r\n                        tmxr_rmvrc (lp, j);             /* remove it */\r\n                    break;\r\n\r\n                case TNS_DO:                            /* pending DO request */\r\n                    if ((tmp == TN_STATUS) ||\r\n                        (tmp == TN_TIMING) ||\r\n                        (tmp == TN_NAOCRD) ||\r\n                        (tmp == TN_NAOHTS) ||\r\n                        (tmp == TN_NAOHTD) ||\r\n                        (tmp == TN_NAOFFD) ||\r\n                        (tmp == TN_NAOVTS) ||\r\n                        (tmp == TN_NAOVTD) ||\r\n                        (tmp == TN_NAOLFD) ||\r\n                        (tmp == TN_EXTEND) ||\r\n                        (tmp == TN_LOGOUT) ||\r\n                        (tmp == TN_BM)     ||\r\n                        (tmp == TN_DET)    ||\r\n                        (tmp == TN_SENDLO) ||\r\n                        (tmp == TN_TERMTY) ||\r\n                        (tmp == TN_ENDREC) ||\r\n                        (tmp == TN_TUID)   ||\r\n                        (tmp == TN_OUTMRK) ||\r\n                        (tmp == TN_TTYLOC) ||\r\n                        (tmp == TN_3270)   ||\r\n                        (tmp == TN_X3PAD)  ||\r\n                        (tmp == TN_NAWS)   ||\r\n                        (tmp == TN_TERMSP) ||\r\n                        (tmp == TN_TOGFLO) ||\r\n                        (tmp == TN_XDISPL) ||\r\n                        (tmp == TN_ENVIRO) ||\r\n                        (tmp == TN_AUTH)   ||\r\n                        (tmp == TN_ENCRYP) ||\r\n                        (tmp == TN_NEWENV) ||\r\n                        (tmp == TN_TN3270) ||\r\n                        (tmp == TN_CHARST) ||\r\n                        (tmp == TN_COMPRT) ||\r\n                        (tmp == TN_KERMIT)) {\r\n                        /* Reject (WONT) these 'uninteresting' options only one time to avoid loops */\r\n                        if (0 == (lp->telnet_sent_opts[tmp] & TNOS_WONT)) {\r\n                            lp->notelnet = TRUE;                /* Temporarily disable so */\r\n                            tmxr_putc_ln (lp, TN_IAC);          /* IAC gets injected bare */\r\n                            lp->notelnet = FALSE;\r\n                            tmxr_putc_ln (lp, TN_WONT);\r\n                            tmxr_putc_ln (lp, tmp);\r\n                            if (lp->conn)                       /* Still connected ? */\r\n                                lp->telnet_sent_opts[tmp] |= TNOS_WONT;/* Record WONT sent */\r\n                            }\r\n                        }\r\n                    /* fall through */\r\n                case TNS_SKIP: default:                 /* skip char */\r\n                    tmxr_rmvrc (lp, j);                 /* remove char */\r\n                    lp->tsta = TNS_NORM;                /* next normal */\r\n                    break;\r\n                    }                                   /* end case state */\r\n                }                                       /* end for char */\r\n            if (nbytes != (lp->rxbpi-lp->rxbpr)) {\r\n                tmxr_debug (TMXR_DBG_RCV, lp, \"Remaining\", &(lp->rxb[lp->rxbpr]), lp->rxbpi-lp->rxbpr);\r\n                }\r\n            }\r\n        }                                               /* end else nbytes */\r\n    }                                                   /* end for lines */\r\nfor (i = 0; i < mp->lines; i++) {                       /* loop thru lines */\r\n    lp = mp->ldsc + i;                                  /* get line desc */\r\n    if (lp->rxbpi == lp->rxbpr)                         /* if buf empty, */\r\n        lp->rxbpi = lp->rxbpr = 0;                      /* reset pointers */\r\n    }                                                   /* end for */\r\n}\r\n\r\n\r\nstatic int32 tmxr_rqln_bare (const TMLN *lp, t_bool speed)\r\n{\r\nif (speed) {\r\n    if ((lp->send != NULL) &&\r\n        (lp->send->extoff < lp->send->insoff)) {/* buffered SEND data? */\r\n        if (sim_gtime () < lp->send->next_time) /* too soon? */\r\n            return 0;\r\n        else\r\n            return 1;\r\n        }\r\n    if (lp->rxbps) {                        /* consider speed and rate limiting? */\r\n        if (sim_gtime () < lp->rxnexttime)  /* too soon? */\r\n            return 0;\r\n        else\r\n            return ((lp->rxbpi - lp->rxbpr + ((lp->rxbpi < lp->rxbpr)? lp->rxbsz : 0)) > 0) ? 1 : 0;\r\n        }\r\n    }\r\nreturn (lp->rxbpi - lp->rxbpr + ((lp->rxbpi < lp->rxbpr)? lp->rxbsz : 0));\r\n}\r\n\r\n/* Return count of available characters ready to be read for line */\r\n\r\nint32 tmxr_rqln (const TMLN *lp)\r\n{\r\nreturn tmxr_rqln_bare (lp, TRUE);\r\n}\r\n\r\nint32 tmxr_input_pending_ln (TMLN *lp)\r\n{\r\nreturn (lp->rxbpi - lp->rxbpr);\r\n}\r\n\r\n\r\n/* Store character in line buffer\r\n\r\n   Inputs:\r\n        *lp     =       pointer to line descriptor\r\n        chr     =       character\r\n   Outputs:\r\n        status  =       ok, connection lost, or stall\r\n\r\n   Implementation note:\r\n\r\n    1. If the line is not connected, SCPE_LOST is returned.\r\n*/\r\n\r\nt_stat tmxr_putc_ln (TMLN *lp, int32 chr)\r\n{\r\nif ((lp->conn == FALSE) &&                              /* no conn & not buffered telnet? */\r\n    (!lp->txbfd || lp->notelnet)) {\r\n    ++lp->txdrp;                                        /* lost */\r\n    return SCPE_LOST;\r\n    }\r\ntmxr_debug_trace_line (lp, \"tmxr_putc_ln()\");\r\n#define TXBUF_AVAIL(lp) ((lp->serport ? 2: lp->txbsz) - tmxr_tqln (lp))\r\n#define TXBUF_CHAR(lp, c) {                               \\\r\n    lp->txb[lp->txbpi++] = (char)(c);                     \\\r\n    lp->txbpi %= lp->txbsz;                               \\\r\n    if (lp->txbpi == lp->txbpr)                           \\\r\n        lp->txbpr = (1+lp->txbpr)%lp->txbsz, ++lp->txdrp; \\\r\n    }\r\nif ((lp->xmte == 0) && (TXBUF_AVAIL(lp) > 1) &&\r\n    ((lp->txbps == 0) || (lp->txnexttime <= sim_gtime ())))\r\n    lp->xmte = 1;                                       /* enable line transmit */\r\nif ((lp->conn && (TXBUF_AVAIL(lp) > 1)) ||              /* connected and room for char (+ IAC)? OR */\r\n    (!lp->conn && !lp->notelnet && lp->txbfd)) {        /* not connected and buffered ? */\r\n    if ((TN_IAC == (u_char) chr) && (!lp->notelnet))    /* char == IAC in telnet session? */\r\n        TXBUF_CHAR (lp, TN_IAC);                        /* stuff extra IAC char */\r\n    TXBUF_CHAR (lp, chr);                               /* buffer char & adv pointer */\r\n    if (((!lp->txbfd) &&\r\n         (TXBUF_AVAIL (lp) <= TMXR_GUARD)) ||           /* near full? */\r\n        (lp->txbps))                                    /* or we're rate limiting output */\r\n        lp->xmte = 0;                                   /* disable line transmit until space available or character time has passed */\r\n    if (lp->txlog) {                                    /* log if available */\r\n        extern TMLN *sim_oline;                         /* Make sure to avoid recursion */\r\n        TMLN *save_oline = sim_oline;                   /* when logging to a socket */\r\n\r\n        sim_oline = NULL;                               /* save output socket */\r\n        fputc (chr, lp->txlog);                         /* log to actual file */\r\n        sim_oline = save_oline;                         /* restore output socket */\r\n        }\r\n    sim_exp_check (lp->expect, chr);                    /* process expect rules as needed */\r\n    if (!sim_is_running &&                              /* attach message or other non simulation time message? */\r\n        !sim_is_remote_console_master_line (lp)) {\r\n        tmxr_send_buffered_data (lp);                   /* put data on wire */\r\n        sim_os_ms_sleep(((lp->txbps) && (lp->txdeltausecs > 1000)) ? /* rate limiting output slower than 1000 cps */\r\n                        (lp->txdeltausecs - 1000) / 1000 :\r\n                        1);                             /* wait an approximate character delay */\r\n        }\r\n    return SCPE_OK;                                     /* char sent */\r\n    }\r\n++lp->txstall; lp->xmte = 0;                            /* no room, dsbl line */\r\nreturn SCPE_STALL;                                      /* char not sent */\r\n}\r\n\r\n/* Store packet in line buffer\r\n\r\n   Inputs:\r\n        *lp     =       pointer to line descriptor\r\n        *buf    =       pointer to packet data\r\n        size    =       size of packet\r\n        frame_char =    inter-packet framing character (0 means no frame character)\r\n\r\n   Outputs:\r\n        status  =       ok, connection lost, or stall\r\n\r\n   Implementation notes:\r\n\r\n    1. If the line is not connected, SCPE_LOST is returned.\r\n    2. If prior packet transmission still in progress, SCPE_STALL is\r\n       returned and no packet data is stored.  The caller must retry later.\r\n*/\r\nt_stat tmxr_put_packet_ln (TMLN *lp, const uint8 *buf, size_t size)\r\n{\r\nreturn tmxr_put_packet_ln_ex (lp, buf, size, 0);\r\n}\r\n\r\nt_stat tmxr_put_packet_ln_ex (TMLN *lp, const uint8 *buf, size_t size, uint8 frame_byte)\r\n{\r\nt_stat r;\r\nsize_t fc_size = (frame_byte ? 1 : 0);\r\nsize_t pktlen_size = (lp->datagram ? 0 : 2);\r\n\r\nif ((!lp->conn) && (!lp->loopback))\r\n    return SCPE_LOST;\r\nif (lp->txppoffset < lp->txppsize) {\r\n    tmxr_debug (TMXR_DBG_PXMT, lp, \"Skipped Sending Packet - Transmit Busy\", (char *)&lp->txpb[3], size);\r\n    return SCPE_STALL;\r\n    }\r\nif (lp->txpbsize < size + pktlen_size + fc_size) {\r\n    lp->txpbsize = size + pktlen_size + fc_size;\r\n    lp->txpb = (uint8 *)realloc (lp->txpb, lp->txpbsize);\r\n    }\r\nlp->txpb[0] = frame_byte;\r\nif (!lp->datagram) {\r\n    lp->txpb[0+fc_size] = (size >> 8) & 0xFF;\r\n    lp->txpb[1+fc_size] = size & 0xFF;\r\n    }\r\nmemcpy (lp->txpb + pktlen_size + fc_size, buf, size);\r\nlp->txppsize = size + pktlen_size + fc_size;\r\nlp->txppoffset = 0;\r\ntmxr_debug (TMXR_DBG_PXMT, lp, \"Sending Packet\", (char *)&lp->txpb[pktlen_size+fc_size], size);\r\n++lp->txpcnt;\r\nwhile ((lp->txppoffset < lp->txppsize) &&\r\n       (SCPE_OK == (r = tmxr_putc_ln (lp, lp->txpb[lp->txppoffset]))))\r\n   ++lp->txppoffset;\r\ntmxr_send_buffered_data (lp);\r\nreturn (lp->conn || lp->loopback) ? SCPE_OK : SCPE_LOST;\r\n}\r\n\r\n/* Poll for output\r\n\r\n   Inputs:\r\n        *mp     =       pointer to terminal multiplexer descriptor\r\n   Outputs:\r\n        none\r\n*/\r\n\r\nvoid tmxr_poll_tx (TMXR *mp)\r\n{\r\nint32 i, nbytes;\r\nTMLN *lp;\r\ndouble sim_gtime_now = sim_gtime ();\r\n\r\ntmxr_debug_trace (mp, \"tmxr_poll_tx()\");\r\nfor (i = 0; i < mp->lines; i++) {                       /* loop thru lines */\r\n    lp = mp->ldsc + i;                                  /* get line desc */\r\n    if ((!lp->conn) && (!lp->txbfd))                    /* skip if !conn and !buffered */\r\n        continue;\r\n    nbytes = tmxr_send_buffered_data (lp);              /* buffered bytes */\r\n    if (nbytes == 0) {                                  /* buf empty? enab line */\r\n        if ((lp->xmte == 0) &&\r\n            ((lp->txbps == 0) ||\r\n             (lp->txnexttime <= sim_gtime_now)))\r\n            lp->xmte = 1;                               /* enable line transmit */\r\n        }\r\n    }                                                   /* end for */\r\n}\r\n\r\n\r\n/* Send buffered data across network\r\n\r\n   Inputs:\r\n        *lp     =       pointer to line descriptor\r\n   Outputs:\r\n        returns number of bytes still buffered\r\n*/\r\n\r\nint32 tmxr_send_buffered_data (TMLN *lp)\r\n{\r\nint32 nbytes, sbytes;\r\nt_stat r;\r\n\r\ntmxr_debug_trace_line (lp, \"tmxr_send_buffered_data()\");\r\nnbytes = tmxr_tqln(lp);                                 /* avail bytes */\r\nif (nbytes) {                                           /* >0? write */\r\n    if (lp->txbpr < lp->txbpi)                          /* no wrap? */\r\n        sbytes = tmxr_write (lp, nbytes);               /* write all data */\r\n    else\r\n        sbytes = tmxr_write (lp, lp->txbsz - lp->txbpr);/* write to end buf */\r\n    if (sbytes >= 0) {                                  /* ok? */\r\n        tmxr_debug (TMXR_DBG_XMT, lp, \"Sent\", &(lp->txb[lp->txbpr]), sbytes);\r\n        lp->txbpr = (lp->txbpr + sbytes);               /* update remove ptr */\r\n        if (lp->txbpr >= lp->txbsz)                     /* wrap? */\r\n            lp->txbpr = 0;\r\n        lp->txcnt = lp->txcnt + sbytes;                 /* update counts */\r\n        nbytes = nbytes - sbytes;\r\n        if ((nbytes == 0) && (lp->datagram))            /* if Empty buffer on datagram line */\r\n            lp->txbpi = lp->txbpr = 0;                  /* Start next packet at beginning of buffer */\r\n        }\r\n    if (sbytes < 0) {                                   /* I/O Error? */\r\n        lp->txbpi = lp->txbpr = 0;                      /* Drop the data we already know we can't send */\r\n        lp->rxpboffset = lp->txppoffset = lp->txppsize = 0;/* Drop the data we already know we can't send */\r\n        tmxr_close_ln (lp);                             /*  close line/port on error */\r\n        return nbytes;                                  /*  done now. */\r\n        }\r\n    if (nbytes && (lp->txbpr == 0))     {               /* more data and wrap? */\r\n        sbytes = tmxr_write (lp, nbytes);\r\n        if (sbytes > 0) {                               /* ok */\r\n            tmxr_debug (TMXR_DBG_XMT, lp, \"Sent\", lp->txb, sbytes);\r\n            lp->txbpr = (lp->txbpr + sbytes);           /* update remove ptr */\r\n            if (lp->txbpr >= lp->txbsz)                 /* wrap? */\r\n                lp->txbpr = 0;\r\n            lp->txcnt = lp->txcnt + sbytes;             /* update counts */\r\n            nbytes = nbytes - sbytes;\r\n            }\r\n        }\r\n    }                                                   /* end if nbytes */\r\nwhile ((lp->txppoffset < lp->txppsize) &&               /* buffered packet data? */\r\n       (lp->txbsz > nbytes) &&                          /* and room in xmt buffer */\r\n       (SCPE_OK == (r = tmxr_putc_ln (lp, lp->txpb[lp->txppoffset]))))\r\n   ++lp->txppoffset;\r\nif ((nbytes == 0) && (tmxr_tqln(lp) > 0))\r\n    return tmxr_send_buffered_data (lp);\r\nreturn tmxr_tqln(lp) + tmxr_tpqln(lp);\r\n}\r\n\r\n\r\n/* Return count of buffered characters for line */\r\n\r\nint32 tmxr_tqln (const TMLN *lp)\r\n{\r\nreturn (lp->txbpi - lp->txbpr + ((lp->txbpi < lp->txbpr)? lp->txbsz: 0));\r\n}\r\n\r\n/* Return count of buffered packet characters for line */\r\n\r\nint32 tmxr_tpqln (const TMLN *lp)\r\n{\r\nreturn (lp->txppsize - lp->txppoffset);\r\n}\r\n\r\n/* Return transmit packet busy status for line */\r\n\r\nt_bool tmxr_tpbusyln (const TMLN *lp)\r\n{\r\nreturn (0 != (lp->txppsize - lp->txppoffset));\r\n}\r\n\r\n/* Return transmitted data complete status */\r\n/* 0 - not done, 1 - just now done, -1 - previously done. */\r\n\r\nint32 tmxr_txdone_ln (TMLN *lp)\r\n{\r\nif (lp->txdone)\r\n    return -1;                      /* previously done */\r\nif ((lp->conn == 0) ||\r\n    (lp->txbps == 0) ||\r\n    (lp->txnexttime <= sim_gtime ())) {\r\n    lp->txdone = TRUE;              /* done now */\r\n    return 1;\r\n    }\r\nreturn 0;                           /* not done */\r\n}\r\n\r\nstatic void _mux_detach_line (TMLN *lp, t_bool close_listener, t_bool close_connecting)\r\n{\r\nif (lp->framer) {\r\n    /* DDCMP framer in use, close that up.  Begin by making sure it is\r\n     * stopped.\r\n     */\r\n    tmxr_stop_framer (lp);\r\n    /* Finished with the framer's Ethernet interface */\r\n    eth_close (lp->framer->eth);\r\n    free (lp->framer->eth);\r\n    free (lp->framer);\r\n    lp->framer = NULL;\r\n    }\r\nif (close_listener && lp->master) {\r\n    sim_close_sock (lp->master);\r\n    lp->master = 0;\r\n    free (lp->port);\r\n    lp->port = NULL;\r\n    }\r\nif (lp->sock) {                             /* if existing tcp, drop it */\r\n    tmxr_report_disconnection (lp);         /* report disconnection */\r\n    tmxr_reset_ln (lp);\r\n    }\r\nif (close_connecting) {\r\n    free (lp->destination);\r\n    lp->destination = NULL;\r\n    if (lp->connecting) {                   /* if existing outgoing tcp, drop it */\r\n        lp->sock = lp->connecting;\r\n        lp->connecting = 0;\r\n        tmxr_reset_ln (lp);\r\n        }\r\n    }\r\nif (lp->serport) {                          /* close current serial connection */\r\n    tmxr_reset_ln (lp);\r\n    sim_control_serial (lp->serport, 0, TMXR_MDM_DTR|TMXR_MDM_RTS, NULL);/* drop DTR and RTS */\r\n    sim_close_serial (lp->serport);\r\n    lp->serport = 0;\r\n    free (lp->serconfig);\r\n    lp->serconfig = NULL;\r\n    free (lp->destination);\r\n    lp->destination = NULL;\r\n    }\r\ntmxr_set_line_loopback (lp, FALSE);\r\n}\r\n\r\nt_stat tmxr_detach_ln (TMLN *lp)\r\n{\r\nUNIT *uptr = NULL;\r\n\r\ntmxr_debug_trace_line (lp, \"tmxr_detach_ln()\");\r\n_mux_detach_line (lp, TRUE, TRUE);\r\nif (lp->mp) {\r\n    if (lp->uptr)\r\n        uptr = lp->uptr;\r\n    else\r\n        uptr = lp->mp->uptr;\r\n    }\r\nif (uptr && uptr->filename) {\r\n    /* Revise the unit's connect string to reflect the current attachments */\r\n    uptr->filename = tmxr_mux_attach_string (uptr->filename, lp->mp);\r\n    /* No connections or listeners exist, then we're equivalent to being fully detached.  We should reflect that */\r\n    if (uptr->filename == NULL)\r\n        tmxr_detach (lp->mp, uptr);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic int32 _tmln_speed_delta (CONST char *cptr)\r\n{\r\nstatic struct {\r\n    const char *bps;\r\n    int32 delta;\r\n    } *spd, speeds[] = {\r\n    {\"50\",      TMLN_SPD_50_BPS},\r\n    {\"75\",      TMLN_SPD_75_BPS},\r\n    {\"110\",     TMLN_SPD_110_BPS},\r\n    {\"134\",     TMLN_SPD_134_BPS},\r\n    {\"150\",     TMLN_SPD_150_BPS},\r\n    {\"300\",     TMLN_SPD_300_BPS},\r\n    {\"600\",     TMLN_SPD_600_BPS},\r\n    {\"1200\",    TMLN_SPD_1200_BPS},\r\n    {\"1800\",    TMLN_SPD_1800_BPS},\r\n    {\"2000\",    TMLN_SPD_2000_BPS},\r\n    {\"2400\",    TMLN_SPD_2400_BPS},\r\n    {\"3600\",    TMLN_SPD_3600_BPS},\r\n    {\"4800\",    TMLN_SPD_4800_BPS},\r\n    {\"7200\",    TMLN_SPD_7200_BPS},\r\n    {\"9600\",    TMLN_SPD_9600_BPS},\r\n    {\"19200\",   TMLN_SPD_19200_BPS},\r\n    {\"25000\",   TMLN_SPD_25000_BPS},\r\n    {\"38400\",   TMLN_SPD_38400_BPS},\r\n    {\"40000\",   TMLN_SPD_40000_BPS},\r\n    {\"50000\",   TMLN_SPD_50000_BPS},\r\n    {\"57600\",   TMLN_SPD_57600_BPS},\r\n    {\"76800\",   TMLN_SPD_76800_BPS},\r\n    {\"80000\",   TMLN_SPD_80000_BPS},\r\n    {\"115200\",  TMLN_SPD_115200_BPS},\r\n    {\"0\",       0}};                    /* End of List, last valid value */\r\nint nspeed;\r\nchar speed[24];\r\nint nfactor = 1;\r\n\r\nnspeed = (uint32)strtotv (cptr, &cptr, 10);\r\nif ((*cptr != '\\0') && (*cptr != '-') && (*cptr != '*'))\r\n    return -1;\r\nif (*cptr == '*') {\r\n    nfactor = (uint32)strtotv (cptr+1, NULL, 10);\r\n    if ((nfactor < 1) || (nfactor > 32))\r\n        return -1;\r\n    }\r\nsprintf (speed, \"%d\", nspeed);\r\n\r\nspd = speeds;\r\nwhile (1) {\r\n    if (0 == strcmp(spd->bps, speed))\r\n        return spd->delta;\r\n    if (spd->delta == 0)\r\n        break;\r\n    ++spd;\r\n    }\r\nreturn -1;\r\n}\r\n\r\nt_stat tmxr_set_line_modem_control (TMLN *lp, t_bool enab_disab)\r\n{\r\nlp->modem_control = enab_disab;\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat tmxr_set_line_speed (TMLN *lp, CONST char *speed)\r\n{\r\nUNIT *uptr;\r\nCONST char *cptr;\r\nt_stat r;\r\nuint32 rxbps;\r\n\r\nif (!speed || !*speed)\r\n    return SCPE_2FARG;\r\nif (_tmln_speed_delta (speed) < 0)\r\n    return SCPE_ARG;\r\nrxbps = (uint32)strtotv (speed, &cptr, 10);\r\nif (*cptr == '*') {\r\n    uint32 bpsfactor = (uint32) get_uint (cptr+1, 10, 32, &r);\r\n\r\n    if (r != SCPE_OK)\r\n        return r;\r\n    lp->bpsfactor = bpsfactor;\r\n    if (!(lp->serport) &&               /* Not a serial port */\r\n        (speed == cptr)) {              /* AND just changing bps factor? */\r\n        char speedbps[16];\r\n\r\n        sprintf (speedbps, \"%d\", lp->rxbps);\r\n        lp->rxdeltausecs = (uint32)(_tmln_speed_delta (speedbps) / lp->bpsfactor);\r\n        lp->txdeltausecs = lp->rxdeltausecs;\r\n        return SCPE_OK;                 /* Done now */\r\n        }\r\n    }\r\nlp->rxbps = rxbps;                      /* use supplied speed */\r\nif ((lp->bpsfactor == 0.0) ||           /* factor unspecified */\r\n    (lp->serport))                      /* OR serial port */\r\n    lp->bpsfactor = 1.0;                /* No bps factor */\r\nlp->rxdeltausecs = (uint32)(_tmln_speed_delta (speed) / lp->bpsfactor);\r\nlp->rxnexttime = 0.0;\r\nuptr = lp->uptr;\r\nif ((!uptr) && (lp->mp))\r\n    uptr = lp->mp->uptr;\r\nif (uptr)\r\n    uptr->wait = lp->rxdeltausecs;\r\nlp->txbps = lp->rxbps;\r\nlp->txdeltausecs = lp->rxdeltausecs;\r\nif (lp->o_uptr)\r\n    lp->o_uptr->wait = lp->txdeltausecs;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic const char* _tmxr_getname(int number, char* name)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int count = eth_devices(ETH_MAX_DEVICE, list, TRUE);\r\n\r\n  if ((number < 0) || (count <= number))\r\n      return NULL;\r\n  if (list[number].eth_api != ETH_API_PCAP) {\r\n    sim_printf (\"Tmxr: Synchronous line device not found.  You may need to run as root\\n\");\r\n    return NULL;\r\n    }\r\n\r\n  strcpy(name, list[number].name);\r\n  return name;\r\n}\r\n\r\n/* Open a master listening socket (and all of the other variances of connections).\r\n\r\n   A listening socket for the port number described by \"cptr\" is opened for the\r\n   multiplexer associated with descriptor \"mp\".  If the open is successful, all\r\n   lines not currently otherwise connected (via serial, outgoing or direct\r\n   listener) are initialized for Telnet connections.\r\n\r\n   Initialization for all connection styles (MUX wide listener, per line serial,\r\n   listener, outgoing, logging, buffering) are handled by this routine.\r\n\r\n*/\r\n\r\nt_stat tmxr_open_master (TMXR *mp, CONST char *cptr)\r\n{\r\nint32 i, line, nextline = -1;\r\nchar tbuf[CBUFSIZE], listen[CBUFSIZE], destination[CBUFSIZE],\r\n     logfiletmpl[CBUFSIZE], buffered[CBUFSIZE], hostport[CBUFSIZE],\r\n     port[CBUFSIZE], option[CBUFSIZE], speed[CBUFSIZE], dev_name[CBUFSIZE],\r\n     acl[CBUFSIZE];\r\nchar framer[CBUFSIZE],fr_eth[CBUFSIZE];\r\nint num;\r\nint8 fr_mode;\r\nint32 fr_speed;\r\nFRAMER *framer_s;\r\nETH_DEV *eth;\r\nSOCKET sock;\r\nSERHANDLE serport;\r\nCONST char *tptr = cptr;\r\nt_bool nolog, notelnet, listennotelnet, nomessage, listennomessage, modem_control, loopback, datagram, packet, disabled;\r\nint32 listenbacklog;\r\nTMLN *lp;\r\nt_stat r = SCPE_OK;\r\n\r\nsnprintf (dev_name, sizeof(dev_name), \"%s%s\", mp->uptr ? sim_dname (find_dev_from_unit (mp->uptr)) : \"\", mp->uptr ? \" \" : \"\");\r\nif (*tptr == '\\0')\r\n    return SCPE_ARG;\r\nfor (i = 0; i < mp->lines; i++) {               /* initialize lines */\r\n    lp = mp->ldsc + i;\r\n    lp->mp = mp;                                /* set the back pointer */\r\n    lp->modem_control = mp->modem_control;\r\n    if (lp->bpsfactor == 0.0)\r\n        lp->bpsfactor = 1.0;\r\n    }\r\nnotelnet = listennotelnet = mp->notelnet;\r\nnomessage = listennomessage = mp->nomessage;\r\nlistenbacklog = mp->backlog;\r\nmp->ring_sock = INVALID_SOCKET;\r\nfree (mp->ring_ipad);\r\nmp->ring_ipad = NULL;\r\nmp->ring_start_time = 0;\r\ntmxr_debug_trace (mp, \"tmxr_open_master()\");\r\nwhile (*tptr) {\r\n    line = nextline;\r\n    memset(logfiletmpl, '\\0', sizeof(logfiletmpl));\r\n    memset(listen,      '\\0', sizeof(listen));\r\n    memset(destination, '\\0', sizeof(destination));\r\n    memset(buffered,    '\\0', sizeof(buffered));\r\n    memset(port,        '\\0', sizeof(port));\r\n    memset(acl,         '\\0', sizeof(acl));\r\n    memset(option,      '\\0', sizeof(option));\r\n    memset(speed,       '\\0', sizeof(speed));\r\n    memset(framer,      '\\0', sizeof(framer));\r\n    nolog = loopback = disabled = FALSE;\r\n    datagram = mp->datagram;\r\n    packet = mp->packet;\r\n    if (mp->buffered)\r\n        sprintf(buffered, \"%d\", mp->buffered);\r\n    if (line != -1) {\r\n        notelnet = listennotelnet = mp->notelnet;\r\n        nomessage = listennomessage = mp->nomessage;\r\n        }\r\n    modem_control = mp->modem_control;\r\n    while (*tptr) {\r\n        tptr = get_glyph_nc (tptr, tbuf, ',');\r\n        if (!tbuf[0])\r\n            break;\r\n        cptr = tbuf;\r\n        if (!isdigit(*cptr)) {\r\n            char gbuf[CBUFSIZE];\r\n            CONST char *init_cptr = cptr;\r\n\r\n            cptr = get_glyph (cptr, gbuf, '=');\r\n            if (0 == MATCH_CMD (gbuf, \"LINE\")) {\r\n                if ((NULL == cptr) || ('\\0' == *cptr))\r\n                    return sim_messagef (SCPE_2FARG, \"Missing Line Specifier\\n\");\r\n                nextline = (int32) get_uint (cptr, 10, mp->lines-1, &r);\r\n                if (r)\r\n                    return sim_messagef (SCPE_ARG, \"Invalid Line Specifier: %s\\n\", cptr);\r\n                break;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"LOG\")) {\r\n                if ((NULL == cptr) || ('\\0' == *cptr))\r\n                    return sim_messagef (SCPE_2FARG, \"Missing Log Specifier\\n\");\r\n                strlcpy(logfiletmpl, cptr, sizeof(logfiletmpl));\r\n                continue;\r\n                }\r\n             if (0 == MATCH_CMD (gbuf, \"LOOPBACK\")) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected Loopback Specifier: %s\\n\", cptr);\r\n                loopback = TRUE;\r\n                continue;\r\n                }\r\n           if ((0 == MATCH_CMD (gbuf, \"NOBUFFERED\")) ||\r\n                (0 == MATCH_CMD (gbuf, \"UNBUFFERED\"))) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected Unbuffered Specifier: %s\\n\", cptr);\r\n                buffered[0] = '\\0';\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"BUFFERED\")) {\r\n                if ((NULL == cptr) || ('\\0' == *cptr))\r\n                    strcpy (buffered, \"32768\");\r\n                else {\r\n                    i = (int32) get_uint (cptr, 10, 1024*1024*10, &r);\r\n                    if (r || (i == 0))\r\n                        return sim_messagef (SCPE_ARG, \"Invalid Buffer Size Specifier: %s\\n\", cptr);\r\n                    sprintf(buffered, \"%d\", i);\r\n                    }\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"NOLOG\")) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected NoLog Specifier: %s\\n\", cptr);\r\n                nolog = TRUE;\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"NOMODEM\")) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected NoModem Specifier: %s\\n\", cptr);\r\n                modem_control = FALSE;\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"MODEM\")) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected Modem Specifier: %s\\n\", cptr);\r\n                modem_control = TRUE;\r\n                continue;\r\n                }\r\n            if ((0 == MATCH_CMD (gbuf, \"DATAGRAM\")) || (0 == MATCH_CMD (gbuf, \"UDP\"))) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected Datagram Specifier: %s\\n\", cptr);\r\n                nomessage = notelnet = datagram = TRUE;\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"PACKET\")) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected Packet Specifier: %s\\n\", cptr);\r\n                packet = TRUE;\r\n                continue;\r\n                }\r\n            if ((0 == MATCH_CMD (gbuf, \"STREAM\")) || (0 == MATCH_CMD (gbuf, \"TCP\"))) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2MARG, \"Unexpected Stream Specifier: %s\\n\", cptr);\r\n                datagram = FALSE;\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"CONNECT\")) {\r\n                if ((NULL == cptr) || ('\\0' == *cptr))\r\n                    return sim_messagef (SCPE_2FARG, \"Missing Connect Specifier\\n\");\r\n                strlcpy (destination, cptr, sizeof(destination));\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"SYNC\")) {\r\n                if ((NULL == cptr) || ('\\0' == *cptr))\r\n                    return sim_messagef (SCPE_2FARG, \"Missing Framer Specifier\\n\");\r\n                strlcpy (framer, cptr, sizeof(framer));\r\n                nomessage = notelnet = datagram = TRUE;\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"DISABLED\")) {\r\n                if ((NULL != cptr) && ('\\0' != *cptr))\r\n                    return sim_messagef (SCPE_2FARG, \"Unexpected Disabled Specifier: %s\\n\", cptr);\r\n                disabled = TRUE;\r\n                continue;\r\n                }\r\n            if (0 == MATCH_CMD (gbuf, \"SPEED\")) {\r\n                if ((NULL == cptr) || ('\\0' == *cptr) ||\r\n                    (_tmln_speed_delta (cptr) < 0))\r\n                    return sim_messagef (SCPE_ARG, \"Invalid Speed Specifier: %s\\n\", (cptr ? cptr : \"\"));\r\n                if (mp->port_speed_control &&\r\n                    ((_tmln_speed_delta (cptr) > 0) || (*cptr != '*')) &&\r\n                    (!(sim_switches & SIM_SW_REST)))\r\n                    return sim_messagef (SCPE_ARG, \"%s simulator programmatically sets %sport speed\\n\", sim_name, dev_name);\r\n                strlcpy (speed, cptr, sizeof(speed));\r\n                continue;\r\n                }\r\n            cptr = get_glyph (gbuf, port, ';');\r\n            if (sim_parse_addr (port, NULL, 0, NULL, NULL, 0, NULL, NULL))\r\n                return sim_messagef (SCPE_ARG, \"Invalid Port Specifier: %s\\n\", port);\r\n            memset (acl, '\\0', sizeof (acl));\r\n            while (cptr && *cptr) {\r\n                char *tptr = gbuf + (cptr - gbuf);\r\n\r\n                cptr = get_glyph (cptr, tptr, ';');\r\n                if (0 == MATCH_CMD (tptr, \"NOTELNET\"))\r\n                    listennotelnet = TRUE;\r\n                else\r\n                    if (0 == MATCH_CMD (tptr, \"TELNET\"))\r\n                        listennotelnet = FALSE;\r\n                    else\r\n                        if (0 == MATCH_CMD (tptr, \"NOMESSAGE\"))\r\n                            listennomessage = TRUE;\r\n                        else\r\n                            if (0 == MATCH_CMD (tptr, \"MESSAGE\"))\r\n                                listennomessage = FALSE;\r\n                            else\r\n                                if (0 == memcmp (option, \"ACCEPT=\", 7)) {\r\n                                    if (sim_addr_acl_check (option + 7, NULL))\r\n                                        return sim_messagef (SCPE_ARG, \"Invalid Accept Criteria: %s\\n\", option + 7);\r\n                                    if (acl[0] != '\\0')\r\n                                        strlcat (acl, \",\", sizeof (acl));\r\n                                    strlcat (acl, \"+\", sizeof (acl));       /* Tag as Accept rule */\r\n                                    strlcat (acl, option + 7, sizeof (acl));\r\n                                    }\r\n                                else\r\n                                    if (0 == memcmp (option, \"REJECT=\", 7)) {\r\n                                        if (sim_addr_acl_check (option + 7, NULL))\r\n                                            return sim_messagef (SCPE_ARG, \"Invalid Reject Criteria: %s\\n\", option + 7);\r\n                                        if (acl[0] != '\\0')\r\n                                            strlcat (acl, \",\", sizeof (acl));\r\n                                        strlcat (acl, \"-\", sizeof (acl));   /* Tag as Reject rule */\r\n                                        strlcat (acl, option + 7, sizeof (acl));\r\n                                        }\r\n                                    else {\r\n                                        if (*tptr)\r\n                                            return sim_messagef (SCPE_ARG, \"Invalid Specifier: %s\\n\", tptr);\r\n                                        }\r\n                }\r\n            cptr = init_cptr;\r\n            }\r\n        cptr = get_glyph_nc (cptr, port, ';');\r\n        sock = sim_master_sock (port, &r);                  /* make master socket to validate port */\r\n        if (r)\r\n            return sim_messagef (SCPE_ARG, \"Invalid Port Specifier: %s\\n\", port);\r\n        if (sock == INVALID_SOCKET)                             /* open error */\r\n            return sim_messagef (SCPE_OPENERR, \"Can't open network port: %s\\n\", port);\r\n        sim_close_sock (sock);\r\n        sim_os_ms_sleep (2);                                    /* let the close finish (required on some platforms) */\r\n        strcpy (listen, port);\r\n        memset (acl, '\\0', sizeof (acl));\r\n        cptr = get_glyph (cptr, option, ';');\r\n        while (option[0]) {\r\n            if (0 == MATCH_CMD (option, \"NOTELNET\"))\r\n                listennotelnet = TRUE;\r\n            else\r\n                if (0 == MATCH_CMD (option, \"TELNET\"))\r\n                    listennotelnet = FALSE;\r\n                else\r\n                    if (0 == MATCH_CMD (option, \"NOMESSAGE\"))\r\n                        listennomessage = TRUE;\r\n                    else\r\n                        if (0 == MATCH_CMD (option, \"MESSAGE\"))\r\n                            listennomessage = FALSE;\r\n                        else\r\n                            if (0 == memcmp (option, \"ACCEPT=\", 7)) {\r\n                                if (sim_addr_acl_check (option + 7, NULL))\r\n                                    return sim_messagef (SCPE_ARG, \"Invalid Accept Criteria: %s\\n\", option + 7);\r\n                                if (acl[0] != '\\0')\r\n                                    strlcat (acl, \",\", sizeof (acl));\r\n                                strlcat (acl, \"+\", sizeof (acl));       /* Tag as Accept rule */\r\n                                strlcat (acl, option + 7, sizeof (acl));\r\n                                }\r\n                            else\r\n                                if (0 == memcmp (option, \"REJECT=\", 7)) {\r\n                                    if (sim_addr_acl_check (option + 7, NULL))\r\n                                        return sim_messagef (SCPE_ARG, \"Invalid Reject Criteria: %s\\n\", option + 7);\r\n                                    if (acl[0] != '\\0')\r\n                                        strlcat (acl, \",\", sizeof (acl));\r\n                                    strlcat (acl, \"-\", sizeof (acl));   /* Tag as Reject rule */\r\n                                    strlcat (acl, option + 7, sizeof (acl));\r\n                                    }\r\n                                else\r\n                                    if (0 == memcmp (option, \"BACKLOG=\", 8)) {\r\n                                        listenbacklog = (int32) get_uint (option + 8, 10, SOMAXCONN, &r);\r\n                                        if (r)\r\n                                            return sim_messagef (SCPE_ARG, \"Invalid Listen Backlog: %s\\n\", option + 8);\r\n                                        }\r\n                                    else\r\n                                        return sim_messagef (SCPE_ARG, \"Invalid Specifier: %s\\n\", option);\r\n            cptr = get_glyph (cptr, option, ';');\r\n            }\r\n        }\r\n    if (disabled) {\r\n        if (destination[0] || listen[0] || loopback || framer[0])\r\n            return sim_messagef (SCPE_ARG, \"Can't disable line with%s%s%s%s%s%s%s\\n\", destination[0] ? \" CONNECT=\" : \"\", destination, listen[0] ? \" \" : \"\", listen, loopback ? \" LOOPBACK\" : \"\", framer[0] ? \" SYNC=\" : \"\", framer);\r\n        }\r\n    if (destination[0]) {\r\n        /* Validate destination */\r\n        if (framer[0])\r\n            return sim_messagef (SCPE_ARG, \"Can't combine CONNECT=%s with SYNC=%s\\n\", destination, framer);\r\n        serport = sim_open_serial (destination, NULL, &r);\r\n        if (serport != INVALID_HANDLE) {\r\n            sim_close_serial (serport);\r\n            if (strchr (destination, ';') && (mp->modem_control || mp->port_speed_control) && !(sim_switches & SIM_SW_REST))\r\n                return sim_messagef (SCPE_ARG, \"%sSerial line parameters can only be set within simulated OS: %s\\n\", dev_name, 1 + strchr (destination, ';'));\r\n            }\r\n        else {\r\n            char *eptr;\r\n\r\n            memset (hostport, '\\0', sizeof(hostport));\r\n            strlcpy (hostport, destination, sizeof(hostport));\r\n            if ((eptr = strchr (hostport, ';')))\r\n                *(eptr++) = '\\0';\r\n            if (eptr) {\r\n                get_glyph (eptr, eptr, 0);          /* upcase this string */\r\n                if (0 == MATCH_CMD (eptr, \"NOTELNET\"))\r\n                    notelnet = TRUE;\r\n                else\r\n                    if (0 == MATCH_CMD (eptr, \"TELNET\"))\r\n                        if (datagram)\r\n                            return sim_messagef (SCPE_ARG, \"Telnet invalid on Datagram socket\\n\");\r\n                        else\r\n                            notelnet = FALSE;\r\n                        else\r\n                            return sim_messagef (SCPE_ARG, \"Unexpected specifier: %s\\n\", eptr);\r\n                }\r\n            sock = sim_connect_sock_ex (NULL, hostport, \"localhost\", NULL, (datagram ? SIM_SOCK_OPT_DATAGRAM : 0) |\r\n                                                                           (packet ? SIM_SOCK_OPT_NODELAY : 0));\r\n            if (sock != INVALID_SOCKET)\r\n                sim_close_sock (sock);\r\n            else\r\n                return sim_messagef (SCPE_ARG, \"Invalid destination: %s\\n\", hostport);\r\n            }\r\n        }\r\n    if (framer[0]) {\r\n        if (listen[0] || loopback || (!notelnet) || (!datagram))\r\n            return sim_messagef (SCPE_ARG, \"Can't combined SYNC=%s with%s%s%s%s%s\\n\", framer,\r\n                    listen[0] ? \" \" : \"\", listen, loopback ? \" LOOPBACK\" : \"\",\r\n                                                  notelnet ? \"\" : \" TELNET\",\r\n                                                  datagram ? \"\" : \" STREAM\");\r\n        /* Validate framer spec */\r\n        cptr = get_glyph_nc (framer, fr_eth, ':');\r\n        cptr = get_glyph (cptr, option, ':');\r\n        if (0 == MATCH_CMD (option, \"INTEGRAL\") ||\r\n            0 == MATCH_CMD (option, \"COAX\"))\r\n            fr_mode = 1;\r\n        else {\r\n            if (0 == MATCH_CMD (option, \"LOOPBACK\"))\r\n                fr_mode = 1 | 4;  /* Integral modem, loopback */\r\n            else\r\n                if (0 == MATCH_CMD (option, \"RS232_DCE\"))\r\n                    fr_mode = 2;\r\n                else\r\n                    if (0 == MATCH_CMD (option, \"RS232_DTE\"))\r\n                        fr_mode = 0;\r\n                    else\r\n                        return sim_messagef (SCPE_ARG, \"Invalid framer mode: %s\\n\", cptr);\r\n            }\r\n        /* Speed is a third value in the SYNC argument.  We don't\r\n         * use the SPEED parameter because that only accepts the\r\n         * standard UART rates, which for the most part are not normal\r\n         * DDCMP line rates.\r\n         */\r\n        fr_speed = 0;\r\n        if (cptr)\r\n            fr_speed = atoi (cptr);\r\n        /* Note that the framer ignores the speed parameter for DTE\r\n         * mode, but we require it here in order to have a speed value\r\n         * to control the scheduling machinery.  It would be possible\r\n         * to make it optional and default it to some useable value\r\n         * like 56k, or to default it that way and then later set it\r\n         * according to the measured data rate reported by the framer.\r\n         * For now, don't bother.\r\n         *\r\n         * Also, while the minimum speed is usually 500 bps, it is 56k\r\n         * for integral modem mode -- the transformer coupling does\r\n         * not work reliably at speeds lower than that, and this\r\n         * matches the lowest speed supported by DEC hardware for that\r\n         * interface type.\r\n         */\r\n        if (fr_speed < 500 || fr_speed > 1000000 ||\r\n            (fr_speed < 56000 && (fr_mode & 1))) {\r\n            return sim_messagef (SCPE_ARG, \"Invalid framer speed %d\\n\", fr_speed);\r\n            }\r\n        }\r\n    if (line == -1) {\r\n        if (disabled)\r\n            return sim_messagef (SCPE_ARG, \"Must specify line to disable\\n\");\r\n        if (framer[0])\r\n            return sim_messagef (SCPE_ARG, \"Must specify line for framer\\n\");\r\n        if (modem_control != mp->modem_control)\r\n            return SCPE_ARG;\r\n        if (logfiletmpl[0]) {\r\n            strlcpy(mp->logfiletmpl, logfiletmpl, sizeof(mp->logfiletmpl));\r\n            for (i = 0; i < mp->lines; i++) {\r\n                char gbuf[CBUFSIZE];\r\n\r\n                lp = mp->ldsc + i;\r\n                sim_close_logfile (&lp->txlogref);\r\n                free (lp->txlogname);\r\n                lp->txlogname = NULL;\r\n                if (mp->lines > 1)\r\n                    snprintf(gbuf, sizeof (gbuf), \"%s_%d\", mp->logfiletmpl, i);\r\n                else\r\n                    strlcpy (gbuf, mp->logfiletmpl, sizeof (gbuf));\r\n                r = tmxr_set_log (lp->o_uptr, i, gbuf, mp);\r\n                if (r != SCPE_OK) {\r\n                    free (lp->txlogname);\r\n                    lp->txlogname = NULL;\r\n                    break;\r\n                    }\r\n                }\r\n            }\r\n        mp->buffered = atoi(buffered);\r\n        for (i = 0; i < mp->lines; i++) { /* initialize line buffers */\r\n            lp = mp->ldsc + i;\r\n            if (mp->buffered) {\r\n                lp->txbsz = mp->buffered;\r\n                lp->txbfd = 1;\r\n                lp->rxbsz = mp->buffered;\r\n                }\r\n            else {\r\n                lp->txbsz = TMXR_MAXBUF;\r\n                lp->txbfd = 0;\r\n                lp->rxbsz = TMXR_MAXBUF;\r\n                }\r\n            lp->txbpi = lp->txbpr = 0;\r\n            lp->txb = (char *)realloc(lp->txb, lp->txbsz);\r\n            lp->rxb = (char *)realloc(lp->rxb, lp->rxbsz);\r\n            lp->rbr = (char *)realloc(lp->rbr, lp->rxbsz);\r\n            }\r\n        if (nolog) {\r\n            mp->logfiletmpl[0] = '\\0';\r\n            for (i = 0; i < mp->lines; i++) { /* close line logs */\r\n                lp = mp->ldsc + i;\r\n                free(lp->txlogname);\r\n                lp->txlogname = NULL;\r\n                if (lp->txlog) {\r\n                    sim_close_logfile (&lp->txlogref);\r\n                    lp->txlog = NULL;\r\n                    }\r\n                }\r\n            }\r\n        if (lp->framer)\r\n            continue;                                       /* skip framer lines */\r\n        if ((listen[0]) && (!datagram)) {\r\n            sock = sim_master_sock_ex (listen, &r,          /* make master socket */\r\n                                       ((sim_switches & SWMASK ('U')) ? SIM_SOCK_OPT_REUSEADDR : 0) |\r\n                                       (mp->packet ? SIM_SOCK_OPT_NODELAY : 0)                      |\r\n                                       SIM_SOCK_OPT_SET_BACKLOG(listenbacklog));\r\n\r\n            if (r)\r\n                return sim_messagef (SCPE_ARG, \"Invalid network listen port: %s\\n\", listen);\r\n            if (sock == INVALID_SOCKET)                     /* open error */\r\n                return sim_messagef (SCPE_OPENERR, \"Can't open network socket for listen port: %s\\n\", listen);\r\n            if (mp->port) {                                 /* close prior listener */\r\n                sim_close_sock (mp->master);\r\n                mp->master = 0;\r\n                free (mp->port);\r\n                mp->port = NULL;\r\n                }\r\n            sim_messagef (SCPE_OK, \"Listening on port %s\\n\", listen);\r\n            mp->port = (char *)realloc (mp->port, 1 + strlen (listen));\r\n            strcpy (mp->port, listen);                      /* save port */\r\n            mp->master = sock;                              /* save master socket */\r\n            mp->ring_sock = INVALID_SOCKET;\r\n            free (mp->ring_ipad);\r\n            mp->ring_ipad = NULL;\r\n            mp->ring_start_time = 0;\r\n            mp->notelnet = listennotelnet;                  /* save desired telnet behavior flag */\r\n            mp->nomessage = listennomessage;                /* save desired telnet behavior flag */\r\n            mp->backlog = listenbacklog;                    /* save desired listening port backlog */\r\n            if (acl[0])\r\n                mp->acl = strdup (acl);                     /* save specified access control list */\r\n            for (i = 0; i < mp->lines; i++) {               /* initialize lines */\r\n                lp = mp->ldsc + i;\r\n                lp->mp = mp;                                /* set the back pointer */\r\n                lp->packet = mp->packet;\r\n\r\n                if (lp->serport) {                          /* serial port attached? */\r\n                    tmxr_reset_ln (lp);                     /* close current serial connection */\r\n                    sim_control_serial (lp->serport, 0, TMXR_MDM_DTR|TMXR_MDM_RTS, NULL);/* drop DTR and RTS */\r\n                    sim_close_serial (lp->serport);\r\n                    lp->serport = 0;\r\n                    free (lp->serconfig);\r\n                    lp->serconfig = NULL;\r\n                    }\r\n                else {\r\n                    if (speed[0])\r\n                        tmxr_set_line_speed (lp, speed);\r\n                    }\r\n                tmxr_init_line (lp);                        /* initialize line state */\r\n                lp->sock = 0;                               /* clear the socket */\r\n                }\r\n            }\r\n        if (loopback) {\r\n            if (mp->lines > 1)\r\n                return sim_messagef (SCPE_ARG, \"Ambiguous Loopback specification\\n\");\r\n            sim_messagef (SCPE_OK, \"Operating in loopback mode\\n\");\r\n            for (i = 0; i < mp->lines; i++) {\r\n                lp = mp->ldsc + i;\r\n                tmxr_set_line_loopback (lp, loopback);\r\n                if (speed[0])\r\n                    tmxr_set_line_speed (lp, speed);\r\n                }\r\n            }\r\n        if (destination[0]) {\r\n            if (mp->lines > 1)\r\n                return sim_messagef (SCPE_ARG, \"Ambiguous Destination specification\\n\");\r\n            lp = &mp->ldsc[0];\r\n            serport = sim_open_serial (destination, lp, &r);\r\n            if (serport != INVALID_HANDLE) {\r\n                _mux_detach_line (lp, TRUE, TRUE);\r\n                if (lp->mp && lp->mp->master) {             /* if existing listener, close it */\r\n                    sim_close_sock (lp->mp->master);\r\n                    lp->mp->master = 0;\r\n                    free (lp->mp->port);\r\n                    lp->mp->port = NULL;\r\n                    }\r\n                lp->destination = (char *)malloc(1+strlen(destination));\r\n                strcpy (lp->destination, destination);\r\n                lp->mp = mp;\r\n                lp->serport = serport;\r\n                lp->ser_connect_pending = TRUE;\r\n                lp->notelnet = TRUE;\r\n                tmxr_init_line (lp);                        /* init the line state */\r\n                if (!lp->mp->modem_control)                 /* raise DTR and RTS for non modem control lines */\r\n                    sim_control_serial (lp->serport, TMXR_MDM_DTR|TMXR_MDM_RTS, 0, NULL);\r\n                lp->cnms = sim_os_msec ();                  /* record time of connection */\r\n                if (sim_switches & SWMASK ('V'))            /* -V flag reports connection on port */\r\n                    tmxr_report_connection (mp, lp);        /* report the connection to the line */\r\n                }\r\n            else {\r\n                lp->datagram = datagram;\r\n                if (datagram) {\r\n                    if (listen[0]) {\r\n                        lp->port = (char *)realloc (lp->port, 1 + strlen (listen));\r\n                        strcpy (lp->port, listen);           /* save port */\r\n                        }\r\n                    else\r\n                        return sim_messagef (SCPE_ARG, \"Missing listen port for Datagram socket\\n\");\r\n                    }\r\n                lp->packet = packet;\r\n                sock = sim_connect_sock_ex (datagram ? listen : NULL, hostport, \"localhost\", NULL, (datagram ? SIM_SOCK_OPT_DATAGRAM : 0) |\r\n                                                                                                   (packet ? SIM_SOCK_OPT_NODELAY : 0));\r\n                if (sock != INVALID_SOCKET) {\r\n                    _mux_detach_line (lp, FALSE, TRUE);\r\n                    lp->destination = (char *)malloc(1+strlen(hostport));\r\n                    strcpy (lp->destination, hostport);\r\n                    lp->mp = mp;\r\n                    if (!lp->modem_control || (lp->modembits & TMXR_MDM_DTR)) {\r\n                        lp->connecting = sock;\r\n                        lp->ipad = (char *)malloc (1 + strlen (lp->destination));\r\n                        strcpy (lp->ipad, lp->destination);\r\n                        }\r\n                    else\r\n                        sim_close_sock (sock);\r\n                    lp->notelnet = notelnet;\r\n                    lp->nomessage = nomessage;\r\n                    tmxr_init_line (lp);                    /* init the line state */\r\n                    if (speed[0] && (!datagram))\r\n                        tmxr_set_line_speed (lp, speed);\r\n                    return SCPE_OK;\r\n                    }\r\n                else\r\n                    return sim_messagef (SCPE_ARG, \"Can't open %s socket on %s%s%s\\n\", datagram ? \"Datagram\" : \"Stream\", datagram ? listen : \"\", datagram ? \"<->\" : \"\", hostport);\r\n                }\r\n            }\r\n        if (speed[0] &&\r\n            (destination[0] == '\\0') &&\r\n            (listen[0] == '\\0') &&\r\n            (!loopback)) {\r\n            for (i = 0; i < mp->lines; i++) {\r\n                lp = mp->ldsc + i;\r\n                tmxr_set_line_speed (lp, speed);\r\n                }\r\n            }\r\n        }\r\n    else {                                                  /* line specific attach */\r\n        lp = &mp->ldsc[line];\r\n        lp->mp = mp;\r\n        if (framer[0]) {\r\n            /* translate name of type \"sync<num>\" to real eth device name */\r\n            if ((strlen(fr_eth) == 5 || strlen(fr_eth) == 6)\r\n                && (tolower(fr_eth[0]) == 's')\r\n                && (tolower(fr_eth[1]) == 'y')\r\n                && (tolower(fr_eth[2]) == 'n')\r\n                && (tolower(fr_eth[3]) == 'c')\r\n                && isdigit(fr_eth[4])\r\n                && (strlen(fr_eth) == 5 || isdigit(fr_eth[5]))\r\n                ) {\r\n                num = atoi(&fr_eth[4]);\r\n                if (_tmxr_getname(num, fr_eth) == NULL) /* didn't translate */\r\n                    return SCPE_OPENERR;\r\n            }\r\n            /* Open the Ethernet device */\r\n            framer_s = (FRAMER *)malloc (sizeof (FRAMER));\r\n            memset (framer_s, 0, sizeof (*framer_s));\r\n            eth = (ETH_DEV *)malloc (sizeof (ETH_DEV));\r\n            memset (eth, 0, sizeof (*eth));\r\n            eth->dptr = mp->dptr;\r\n            framer_s->eth = eth;\r\n            framer_s->connect_pending = TRUE;\r\n            r = eth_open (eth, fr_eth, mp->dptr, 0);\r\n            if (r != SCPE_OK) {\r\n                sim_messagef (r, \"Eth open error %d\\n\", r);\r\n                free (eth);\r\n                free (framer_s);\r\n                return r;\r\n                }\r\n            /* Set the filters: our address, not all multi, not promiscuous */\r\n            r = eth_filter (eth, 1, &(eth->host_nic_phy_hw_addr), 0, 0);\r\n            if (r != SCPE_OK) {\r\n                sim_messagef (r, \"Eth set address filter error %d\\n\", r);\r\n                eth_close (eth);\r\n                free (eth);\r\n                free (framer_s);\r\n                return r;\r\n                }\r\n            lp = &mp->ldsc[line];\r\n            lp->framer = framer_s;\r\n            lp->datagram = lp->notelnet = TRUE;\r\n            /* Remember these parameters for later; the framer is\r\n             * started separately; in the DMC/DMP emulation this is\r\n             * done at DDCMP startup to allow a DMP driver to select\r\n             * the mode via the device API. */\r\n            framer_s->fmode = fr_mode;\r\n            framer_s->fspeed = fr_speed;\r\n            /* Set the scheduling parameters from the line speed */\r\n            lp->txdeltausecs = lp->rxdeltausecs = (uint32) (8000000 / fr_speed);\r\n            tmxr_init_line (lp);                /* initialize line state */\r\n            }\r\n        if (logfiletmpl[0]) {\r\n            sim_close_logfile (&lp->txlogref);\r\n            lp->txlog = NULL;\r\n            lp->txlogname = (char *)realloc (lp->txlogname, 1 + strlen (logfiletmpl));\r\n            strcpy (lp->txlogname, logfiletmpl);\r\n            r = sim_open_logfile (lp->txlogname, TRUE, &lp->txlog, &lp->txlogref);\r\n            if (r == SCPE_OK)\r\n                setvbuf(lp->txlog, NULL, _IOFBF, 65536);\r\n            else {\r\n                free (lp->txlogname);\r\n                lp->txlogname = NULL;\r\n                return sim_messagef (r, \"Can't open log file: %s\\n\", logfiletmpl);\r\n                }\r\n            }\r\n        if (buffered[0] == '\\0') {\r\n            lp->rxbsz = lp->txbsz = TMXR_MAXBUF;\r\n            lp->txbfd = 0;\r\n            }\r\n        else {\r\n            lp->rxbsz = lp->txbsz = atoi(buffered);\r\n            lp->txbfd = 1;\r\n            }\r\n        lp->txbpi = lp->txbpr = 0;\r\n        lp->txb = (char *)realloc (lp->txb, lp->txbsz);\r\n        lp->rxb = (char *)realloc(lp->rxb, lp->rxbsz);\r\n        lp->rbr = (char *)realloc(lp->rbr, lp->rxbsz);\r\n        lp->packet = packet;\r\n        if (nolog) {\r\n            free(lp->txlogname);\r\n            lp->txlogname = NULL;\r\n            if (lp->txlog) {\r\n                sim_close_logfile (&lp->txlogref);\r\n                lp->txlog = NULL;\r\n                }\r\n            }\r\n        if ((listen[0]) && (!datagram)) {\r\n            if ((mp->lines == 1) && (mp->master))\r\n                return sim_messagef (SCPE_ARG, \"Single Line MUX can have either line specific OR MUX listener but NOT both\\n\");\r\n            if (listenbacklog != mp->backlog)\r\n                lp->backlog = listenbacklog;\r\n            else\r\n                lp->backlog = mp->backlog;\r\n            sock = sim_master_sock_ex (listen, &r,          /* make master socket */\r\n                                       ((sim_switches & SWMASK ('U')) ? SIM_SOCK_OPT_REUSEADDR : 0) |\r\n                                       (lp->packet ? SIM_SOCK_OPT_NODELAY : 0)                      |\r\n                                       SIM_SOCK_OPT_SET_BACKLOG(lp->backlog));\r\n            if (r)\r\n                return sim_messagef (SCPE_ARG, \"Invalid Listen Specification: %s\\n\", listen);\r\n            if (sock == INVALID_SOCKET)                     /* open error */\r\n                return sim_messagef (SCPE_OPENERR, \"Can't listen on port: %s\\n\", listen);\r\n            _mux_detach_line (lp, TRUE, FALSE);\r\n            sim_messagef (SCPE_OK, \"Line %d Listening on port %s\\n\", line, listen);\r\n            lp->port = (char *)realloc (lp->port, 1 + strlen (listen));\r\n            strcpy (lp->port, listen);                       /* save port */\r\n            lp->master = sock;                              /* save master socket */\r\n            if (listennotelnet != mp->notelnet)\r\n                lp->notelnet = listennotelnet;\r\n            else\r\n                lp->notelnet = mp->notelnet;\r\n            if (listennomessage != mp->nomessage)\r\n                lp->nomessage = listennomessage;\r\n            else\r\n                lp->nomessage = mp->nomessage;\r\n            if (acl[0])\r\n                lp->acl = strdup (acl);\r\n            }\r\n        if (destination[0]) {\r\n            serport = sim_open_serial (destination, lp, &r);\r\n            if (serport != INVALID_HANDLE) {\r\n                _mux_detach_line (lp, TRUE, TRUE);\r\n                lp->destination = (char *)malloc(1+strlen(destination));\r\n                strcpy (lp->destination, destination);\r\n                lp->serport = serport;\r\n                lp->ser_connect_pending = TRUE;\r\n                lp->notelnet = TRUE;\r\n                tmxr_init_line (lp);                        /* init the line state */\r\n                if (!lp->mp->modem_control)                 /* raise DTR and RTS for non modem control lines */\r\n                    sim_control_serial (lp->serport, TMXR_MDM_DTR|TMXR_MDM_RTS, 0, NULL);\r\n                lp->cnms = sim_os_msec ();                  /* record time of connection */\r\n                if (sim_switches & SWMASK ('V'))            /* -V flag reports connection on port */\r\n                    tmxr_report_connection (mp, lp);        /* report the connection to the line */\r\n                }\r\n            else {\r\n                if (!lp->framer) {\r\n                    lp->datagram = datagram;\r\n                    if (datagram) {\r\n                        if (listen[0]) {\r\n                            lp->port = (char *)realloc (lp->port, 1 + strlen (listen));\r\n                            strcpy (lp->port, listen);          /* save port */\r\n                            }\r\n                        else\r\n                            return sim_messagef (SCPE_ARG, \"Missing listen port for Datagram socket\\n\");\r\n                        }\r\n                    sock = sim_connect_sock_ex (datagram ? listen : NULL, hostport, \"localhost\", NULL, (datagram ? SIM_SOCK_OPT_DATAGRAM : 0) |\r\n                                                                                                       (packet ? SIM_SOCK_OPT_NODELAY : 0));\r\n                    if (sock != INVALID_SOCKET) {\r\n                        _mux_detach_line (lp, FALSE, TRUE);\r\n                        lp->destination = (char *)malloc(1+strlen(hostport));\r\n                        strcpy (lp->destination, hostport);\r\n                        if (!lp->modem_control || (lp->modembits & TMXR_MDM_DTR)) {\r\n                            lp->connecting = sock;\r\n                            lp->ipad = (char *)malloc (1 + strlen (lp->destination));\r\n                            strcpy (lp->ipad, lp->destination);\r\n                            }\r\n                        else\r\n                            sim_close_sock (sock);\r\n                        lp->notelnet = notelnet;\r\n                        lp->nomessage = nomessage;\r\n                        tmxr_init_line (lp);                    /* init the line state */\r\n                        }\r\n                    else\r\n                        return sim_messagef (SCPE_ARG, \"Can't open %s socket on %s%s%s\\n\", datagram ? \"Datagram\" : \"Stream\", datagram ? listen : \"\", datagram ? \"<->\" : \"\", hostport);\r\n                    }\r\n                }\r\n            }\r\n        if (loopback) {\r\n            tmxr_set_line_loopback (lp, loopback);\r\n            sim_messagef (SCPE_OK, \"Line %d operating in loopback mode\\n\", line);\r\n            }\r\n        if (disabled)\r\n            lp->conn = TMXR_LINE_DISABLED;                  /* Mark as not available */\r\n        lp->modem_control = modem_control;\r\n        if (speed[0] && (!datagram) && (!lp->serport))\r\n            tmxr_set_line_speed (lp, speed);\r\n        r = SCPE_OK;\r\n        }\r\n    }\r\nif (r == SCPE_OK)\r\n    tmxr_add_to_open_list (mp);\r\nreturn r;\r\n}\r\n\r\n\r\n/* Declare which unit polls for input\r\n\r\n   Inputs:\r\n        *mp     =       the mux\r\n        line    =       the line number\r\n        *uptr_poll =    the unit which polls\r\n\r\n   Outputs:\r\n        none\r\n\r\n   Implementation note:\r\n\r\n      - This routine must be called before the MUX is attached.\r\n      - Only devices which poll on a unit different from the unit provided\r\n        at MUX attach time need call this function.  Calling this API is\r\n        necessary for asynchronous multiplexer support and if speed limited\r\n        behaviors are desired.\r\n\r\n*/\r\n\r\nt_stat tmxr_set_line_unit (TMXR *mp, int line, UNIT *uptr_poll)\r\n{\r\nif ((line < 0) || (line >= mp->lines))\r\n    return SCPE_ARG;\r\nif (mp->ldsc[line].uptr)\r\n    mp->ldsc[line].uptr->dynflags &= ~UNIT_TM_POLL;\r\nmp->ldsc[line].uptr = uptr_poll;\r\nif (uptr_poll->tmxr)                /* associated with a TMXR? */\r\n    mp->ldsc[line].uptr->dynflags |= UNIT_TM_POLL;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Declare which unit performs output transmission in its unit service\r\n   routine for a particular line.\r\n\r\n   Inputs:\r\n        *mp     =       the mux\r\n        line    =       the line number\r\n        *uptr_poll =    the unit which polls for output\r\n\r\n   Outputs:\r\n        none\r\n\r\n   Implementation notes:\r\n\r\n      - This routine must be called before the MUX is attached.\r\n      - Only devices which poll on a unit different from the unit provided\r\n        at MUX attach time need call this function ABD different from the\r\n        unit which polls for input.  Calling this API is necessary for\r\n        asynchronous multiplexer support and if speed limited behaviors are\r\n        desired.\r\n\r\n\r\n*/\r\n\r\nt_stat tmxr_set_line_output_unit (TMXR *mp, int line, UNIT *uptr_poll)\r\n{\r\nif ((line < 0) || (line >= mp->lines))\r\n    return SCPE_ARG;\r\nif (mp->ldsc[line].o_uptr)\r\n    mp->ldsc[line].o_uptr->dynflags &= ~UNIT_TM_POLL;\r\nmp->ldsc[line].o_uptr = uptr_poll;\r\nif (uptr_poll->tmxr)                /* associated with a TMXR? */\r\n    mp->ldsc[line].o_uptr->dynflags |= UNIT_TM_POLL;\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Declare which units are the console input and out devices\r\n\r\n   Inputs:\r\n        *rxuptr =    the console input unit\r\n        *txuptr =    the console output unit\r\n\r\n   Outputs:\r\n        none\r\n\r\n   Implementation note:\r\n\r\n        This routine is exported by the tmxr library so that it gets\r\n        defined to code which uses it by including sim_tmxr.h.  Including\r\n        sim_tmxr.h is necessary so that sim_activate is properly defined\r\n        in the caller's code to actually call tmxr_activate.\r\n\r\n*/\r\n\r\nt_stat tmxr_set_console_units (UNIT *rxuptr, UNIT *txuptr)\r\n{\r\nextern TMXR sim_con_tmxr;\r\n\r\ntmxr_set_line_unit (&sim_con_tmxr, 0, rxuptr);\r\ntmxr_set_line_output_unit (&sim_con_tmxr, 0, txuptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nstatic TMXR **tmxr_open_devices = NULL;\r\nstatic int tmxr_open_device_count = 0;\r\n\r\nstatic void tmxr_add_to_open_list (TMXR* mux)\r\n{\r\nint i;\r\nt_bool found = FALSE;\r\n\r\nfor (i=0; i<tmxr_open_device_count; ++i)\r\n    if (tmxr_open_devices[i] == mux) {\r\n        found = TRUE;\r\n        break;\r\n        }\r\nif (!found) {\r\n    tmxr_open_devices = (TMXR **)realloc(tmxr_open_devices, (tmxr_open_device_count+1)*sizeof(*tmxr_open_devices));\r\n    tmxr_open_devices[tmxr_open_device_count++] = mux;\r\n    for (i=0; i<mux->lines; i++) {\r\n        if (mux->ldsc[i].send == NULL)\r\n            mux->ldsc[i].send = (SEND *)calloc (1, sizeof (SEND));\r\n        if (mux->ldsc[i].expect == NULL)\r\n            mux->ldsc[i].expect = (EXPECT *)calloc (1, sizeof (EXPECT));\r\n        mux->ldsc[i].send->after = mux->ldsc[i].send->delay = 0;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void _tmxr_remove_from_open_list (TMXR* mux)\r\n{\r\nint i, j;\r\n\r\nfor (i=0; i<tmxr_open_device_count; ++i)\r\n    if (tmxr_open_devices[i] == mux) {\r\n        for (j=i+1; j<tmxr_open_device_count; ++j)\r\n            tmxr_open_devices[j-1] = tmxr_open_devices[j];\r\n        --tmxr_open_device_count;\r\n        break;\r\n        }\r\n}\r\n\r\nstatic t_stat _tmxr_locate_line_send_expect (const char *cptr, TMLN **lp, SEND **snd, EXPECT **exp)\r\n{\r\nchar gbuf[CBUFSIZE];\r\nDEVICE *dptr;\r\nint i;\r\nt_stat r;\r\n\r\nif (snd)\r\n    *snd = NULL;\r\nif (exp)\r\n    *exp = NULL;\r\ncptr = get_glyph(cptr, gbuf, ':');\r\ndptr = find_dev (gbuf);                 /* device match? */\r\nif (!dptr)\r\n    return SCPE_ARG;\r\n\r\nfor (i=0; i<tmxr_open_device_count; ++i)\r\n    if (tmxr_open_devices[i]->dptr == dptr) {\r\n        int line = (int)get_uint (cptr, 10, tmxr_open_devices[i]->lines, &r);\r\n        if (r != SCPE_OK)\r\n            return r;\r\n        if (lp)\r\n            *lp = &tmxr_open_devices[i]->ldsc[line];\r\n        if (snd)\r\n            *snd = tmxr_open_devices[i]->ldsc[line].send;\r\n        if (exp)\r\n            *exp = tmxr_open_devices[i]->ldsc[line].expect;\r\n        return SCPE_OK;\r\n        }\r\nreturn SCPE_ARG;\r\n}\r\n\r\nt_stat tmxr_locate_line_send (const char *cptr, SEND **snd)\r\n{\r\nreturn _tmxr_locate_line_send_expect (cptr, NULL, snd, NULL);\r\n}\r\n\r\nt_stat tmxr_locate_line_expect (const char *cptr, EXPECT **exp)\r\n{\r\nreturn _tmxr_locate_line_send_expect (cptr, NULL, NULL, exp);\r\n}\r\n\r\nt_stat tmxr_locate_line (const char *cptr, TMLN **lp)\r\n{\r\nreturn _tmxr_locate_line_send_expect (cptr, lp, NULL, NULL);\r\n}\r\n\r\nstatic const char *_tmxr_send_expect_line_name (const SEND *snd, const EXPECT *exp)\r\n{\r\nstatic char line_name[CBUFSIZE];\r\nint i, j;\r\n\r\nstrcpy (line_name, \"\");\r\nfor (i=0; i<tmxr_open_device_count; ++i)\r\n    for (j=0; j<tmxr_open_devices[i]->lines; ++j)\r\n        if ((snd == tmxr_open_devices[i]->ldsc[j].send) ||\r\n            (exp == tmxr_open_devices[i]->ldsc[j].expect)) {\r\n            if (tmxr_open_devices[i]->lines > 1)\r\n                snprintf (line_name, sizeof (line_name), \"%s:%d\", tmxr_open_devices[i]->ldsc[j].send->dptr->name, j);\r\n            else\r\n                strlcpy (line_name, tmxr_open_devices[i]->ldsc[j].send->dptr->name, sizeof (line_name));\r\n            break;\r\n            }\r\nreturn line_name;\r\n}\r\n\r\nconst char *tmxr_send_line_name (const SEND *snd)\r\n{\r\nif (snd == sim_cons_get_send ())\r\n    return \"CONSOLE\";\r\nelse\r\n    return _tmxr_send_expect_line_name (snd, NULL);\r\n}\r\n\r\nconst char *tmxr_expect_line_name (const EXPECT *exp)\r\n{\r\nif (exp == sim_cons_get_expect ())\r\n    return \"CONSOLE\";\r\nelse\r\n    return _tmxr_send_expect_line_name (NULL, exp);\r\n}\r\n\r\nstatic DEBTAB tmxr_debug[] = {\r\n  {\"XMT\",       TMXR_DBG_XMT,       \"Transmit Data\"},\r\n  {\"RCV\",       TMXR_DBG_RCV,       \"Received Data\"},\r\n  {\"RET\",       TMXR_DBG_RET,       \"Returned Received Data\"},\r\n  {\"MODEM\",     TMXR_DBG_MDM,       \"Modem Signals\"},\r\n  {\"CONNECT\",   TMXR_DBG_CON,       \"Connection Activities\"},\r\n  {\"TRACE\",     TMXR_DBG_TRC,       \"trace routine calls\"},\r\n  {\"XMTPKT\",    TMXR_DBG_PXMT,      \"Transmit Packet Data\"},\r\n  {\"RCVPKT\",    TMXR_DBG_PRCV,      \"Received Packet Data\"},\r\n  {\"EXPECT\",    TMXR_DBG_EXP,       \"Expect Activities\"},\r\n  {\"SEND\",      TMXR_DBG_SEND,      \"Send Activities\"},\r\n  {0}\r\n};\r\n\r\nt_stat tmxr_add_debug (DEVICE *dptr)\r\n{\r\nif (DEV_TYPE(dptr) != DEV_MUX)\r\n    return SCPE_OK;\r\nreturn sim_add_debug_flags (dptr, tmxr_debug);\r\n}\r\n\r\n/* Attach unit to master socket */\r\n\r\nt_stat tmxr_attach (TMXR *mp, UNIT *uptr, CONST char *cptr)\r\n{\r\nt_stat r;\r\nint32 i;\r\n\r\nif (mp->dptr == NULL)                                   /* has device been set? */\r\n    mp->dptr = find_dev_from_unit (uptr);               /* no, so set device now */\r\n\r\nif (mp->uptr == NULL)                                   /* has polling unit been set? */\r\n    mp->uptr = uptr;                                    /* save unit for polling */\r\nr = tmxr_open_master (mp, cptr);                        /* open master socket */\r\nif (r != SCPE_OK)                                       /* error? */\r\n    return r;\r\nuptr->filename = tmxr_mux_attach_string (uptr->filename, mp);/* save */\r\nif (uptr->filename == NULL)                             /* avoid dangling NULL pointer */\r\n    uptr->filename = (char *)calloc (1, 1);             /* provide an empty string */\r\nuptr->flags = uptr->flags | UNIT_ATT;                   /* no more errors */\r\nuptr->tmxr = (void *)mp;\r\nif ((mp->lines > 1) ||\r\n    ((mp->master == 0) &&\r\n     (mp->ldsc[0].connecting == 0) &&\r\n     (mp->ldsc[0].serport == 0)))\r\n    uptr->dynflags = uptr->dynflags | UNIT_ATTMULT;     /* allow multiple attach commands */\r\n\r\nuptr->dynflags |= UNIT_TM_POLL;                         /* tag as polling unit */\r\nif (mp->dptr) {\r\n    for (i=0; i<mp->lines; i++) {\r\n        mp->ldsc[i].expect->dptr = mp->dptr;\r\n        mp->ldsc[i].expect->dbit = TMXR_DBG_EXP;\r\n        mp->ldsc[i].send->dptr = mp->dptr;\r\n        mp->ldsc[i].send->dbit = TMXR_DBG_SEND;\r\n        if (mp->ldsc[i].uptr == NULL)\r\n            mp->ldsc[i].uptr = mp->uptr;\r\n        mp->ldsc[i].uptr->tmxr = (void *)mp;\r\n        mp->ldsc[i].uptr->dynflags |= UNIT_TM_POLL;     /* tag as polling unit */\r\n        if (mp->ldsc[i].o_uptr == NULL)\r\n            mp->ldsc[i].o_uptr = mp->ldsc[i].uptr;\r\n        mp->ldsc[i].o_uptr->tmxr = (void *)mp;\r\n        mp->ldsc[i].o_uptr->dynflags |= UNIT_TM_POLL;   /* tag as polling unit */\r\n        }\r\n    }\r\ntmxr_add_to_open_list (mp);\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nt_stat tmxr_startup (void)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat tmxr_shutdown (void)\r\n{\r\nif (tmxr_open_device_count)\r\n    return SCPE_IERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nt_stat tmxr_show_open_device (FILE* st, TMXR *mp)\r\n{\r\nint j;\r\nTMLN *lp;\r\nUNIT *o_uptr = mp->ldsc[0].o_uptr;\r\nUNIT *uptr = mp->ldsc[0].uptr;\r\nchar *attach;\r\n\r\nfprintf(st, \"Multiplexer device: %s\", (mp->dptr ? sim_dname (mp->dptr) : \"\"));\r\nif (mp->lines > 1) {\r\n    fprintf(st, \", \");\r\n    tmxr_show_lines(st, NULL, 0, mp);\r\n    }\r\nif (mp->packet)\r\n    fprintf(st, \", Packet\");\r\nif (mp->datagram)\r\n    fprintf(st, \", UDP\");\r\nif (mp->notelnet)\r\n    fprintf(st, \", Telnet=disabled\");\r\nif ((!mp->notelnet) && (mp->nomessage))\r\n    fprintf(st, \", Message=disabled\");\r\nif (mp->modem_control)\r\n    fprintf(st, \", ModemControl=enabled\");\r\nif (mp->buffered)\r\n    fprintf(st, \", Buffered=%d\", mp->buffered);\r\nfor (j = 1; j < mp->lines; j++)\r\n    if (o_uptr != mp->ldsc[j].o_uptr)\r\n        break;\r\nif (j == mp->lines)\r\n    fprintf(st, \", Output Unit: %s\", sim_uname (o_uptr));\r\nelse\r\n    o_uptr = NULL;\r\nfor (j = 1; j < mp->lines; j++)\r\n    if (uptr != mp->ldsc[j].uptr)\r\n        break;\r\nif (j == mp->lines) {\r\n    fprintf(st, \",\\n    Input Polling Unit: %s\", sim_uname (uptr));\r\n    if (uptr != mp->uptr)\r\n        fprintf(st, \", Connection Polling Unit: %s\", sim_uname (mp->uptr));\r\n    }\r\nattach = tmxr_mux_attach_string (NULL, mp);\r\nif (attach)\r\n    fprintf(st, \",\\n    attached to %s, \", attach);\r\nfree (attach);\r\ntmxr_show_summ(st, NULL, 0, mp);\r\nfprintf(st, \", sessions=%d\", mp->sessions);\r\nif (mp->acl_accepted_sessions)\r\n    fprintf(st, \", accepted=%d\", mp->acl_accepted_sessions);\r\nif (mp->acl_rejected_sessions)\r\n    fprintf(st, \", rejected=%d\", mp->acl_rejected_sessions);\r\nif (mp->lines == 1) {\r\n    if (mp->ldsc->rxbps) {\r\n        fprintf(st, \", Speed=%d\", mp->ldsc->rxbps);\r\n        if (mp->ldsc->bpsfactor != 1.0)\r\n            fprintf(st, \"*%.0f\", mp->ldsc->bpsfactor);\r\n        fprintf(st, \" bps\");\r\n        }\r\n    }\r\nfprintf(st, \"\\n\");\r\nif (mp->ring_start_time) {\r\n    fprintf (st, \"    incoming Connection from: %s ringing for %d milliseconds\\n\", mp->ring_ipad, sim_os_msec () - mp->ring_start_time);\r\n    }\r\nfor (j = 0; j < mp->lines; j++) {\r\n    lp = mp->ldsc + j;\r\n    if (mp->lines > 1) {\r\n        if (lp->dptr && (mp->dptr != lp->dptr))\r\n            fprintf (st, \"Device: %s \", sim_dname(lp->dptr));\r\n        fprintf (st, \"Line: %d\", j);\r\n        if (lp->conn == TMXR_LINE_DISABLED)\r\n            fprintf (st, \" - Disabled\");\r\n        if (mp->notelnet != lp->notelnet)\r\n            fprintf (st, \" - %stelnet\", lp->notelnet ? \"no\" : \"\");\r\n        if ((!lp->notelnet) && (mp->nomessage != lp->nomessage))\r\n            fprintf (st, \" - %smessage\", lp->nomessage ? \"no\" : \"\");\r\n        if (lp->uptr && (lp->uptr != lp->mp->uptr))\r\n            fprintf (st, \" - Unit: %s\", sim_uname (lp->uptr));\r\n        if ((lp->o_uptr != o_uptr) && lp->o_uptr && (lp->o_uptr != lp->mp->uptr) && (lp->o_uptr != lp->uptr))\r\n            fprintf (st, \" - Output Unit: %s\", sim_uname (lp->o_uptr));\r\n        if (mp->modem_control != lp->modem_control)\r\n            fprintf(st, \", ModemControl=%s\", lp->modem_control ? \"enabled\" : \"disabled\");\r\n        if (lp->loopback)\r\n            fprintf(st, \", Loopback\");\r\n        if (lp->rxbps) {\r\n            fprintf(st, \", Speed=%d\", lp->rxbps);\r\n            if (lp->bpsfactor != 1.0)\r\n                fprintf(st, \"*%.0f\", lp->bpsfactor);\r\n            fprintf(st, \" bps\");\r\n            }\r\n        else {\r\n            if (lp->bpsfactor != 1.0)\r\n                fprintf(st, \", Speed=*%.0f bps\", lp->bpsfactor);\r\n            }\r\n        if (lp->sessions) {\r\n            fprintf(st, \", Sessions=%d\", lp->sessions);\r\n            if (lp->acl_accepted_sessions)\r\n                fprintf(st, \", Accepted=%d\", lp->acl_accepted_sessions);\r\n            if (lp->acl_rejected_sessions)\r\n                fprintf(st, \", Rejected=%d\", lp->acl_rejected_sessions);\r\n            }\r\n        fprintf (st, \"\\n\");\r\n        }\r\n    if ((!lp->sock) && (!lp->connecting) && (!lp->serport) && (!lp->master)) {\r\n        if ((lp->modem_control) || (lp->txbfd))\r\n            tmxr_fconns (st, lp, -1);\r\n        continue;\r\n        }\r\n    tmxr_fconns (st, lp, -1);\r\n    tmxr_fstats (st, lp, -1);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nt_stat tmxr_show_open_devices (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char* cptr)\r\n{\r\nint i;\r\nchar gbuf[CBUFSIZE];\r\n\r\ncptr = get_glyph (cptr, gbuf, 0);\r\nif (*cptr)\r\n    return SCPE_2MARG;\r\nif ((0 == tmxr_open_device_count) &&\r\n    (gbuf[0] == '\\0'))\r\n    fprintf(st, \"No Attached Multiplexer Devices\\n\");\r\nelse {\r\n    for (i=0; i<tmxr_open_device_count; ++i) {\r\n        TMXR *mp = tmxr_open_devices[i];\r\n\r\n        if ((gbuf[0] == '\\0') ||\r\n            (0 == strcmp (gbuf, mp->dptr->name))) {\r\n            tmxr_show_open_device (st, mp);\r\n            if (gbuf[0] != '\\0')\r\n                break;\r\n            }\r\n        }\r\n    if ((gbuf[0] != '\\0') &&\r\n        (i == tmxr_open_device_count))\r\n        return sim_messagef (SCPE_ARG, \"Multiplexer device %s not found or attached\\n\", gbuf);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat tmxr_flush_log_files (void)\r\n{\r\nint i, j;\r\n\r\nfor (i=0; i<tmxr_open_device_count; ++i) {\r\n    TMXR *mp = tmxr_open_devices[i];\r\n\r\n    for (j=0; j<mp->lines; ++j)\r\n        if (mp->ldsc[j].txlog)\r\n            fflush (mp->ldsc[j].txlog);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Close a master listening socket.\r\n\r\n   The listening socket associated with multiplexer descriptor \"mp\" is closed\r\n   and deallocated.  In addition, all current Telnet sessions are disconnected.\r\n   Serial and outgoing sessions are also disconnected.\r\n*/\r\n\r\nt_stat tmxr_close_master (TMXR *mp)\r\n{\r\nint32 i;\r\nTMLN *lp;\r\n\r\nfor (i = 0; i < mp->lines; i++) {  /* loop thru conn */\r\n    lp = mp->ldsc + i;\r\n\r\n    if (!lp->destination && lp->sock) {            /* not serial and is connected? */\r\n        tmxr_report_disconnection (lp);                 /* report disconnection */\r\n        tmxr_reset_ln (lp);                             /* disconnect line */\r\n        }\r\n    else {\r\n        if (lp->sock) {\r\n            tmxr_report_disconnection (lp);             /* report disconnection */\r\n            tmxr_reset_ln (lp);\r\n            }\r\n        if (lp->serport) {\r\n            sim_control_serial (lp->serport, 0, TMXR_MDM_DTR|TMXR_MDM_RTS, NULL);/* drop DTR and RTS */\r\n            tmxr_close_ln (lp);\r\n            }\r\n        free (lp->destination);\r\n        lp->destination = NULL;\r\n        free (lp->acl);\r\n        lp->acl = NULL;\r\n        if (lp->connecting) {\r\n            lp->sock = lp->connecting;\r\n            lp->connecting = 0;\r\n            tmxr_reset_ln (lp);\r\n            }\r\n        lp->conn = FALSE;\r\n        }\r\n    if (lp->master) {\r\n        sim_close_sock (lp->master);                    /* close master socket */\r\n        lp->master = 0;\r\n        free (lp->port);\r\n        lp->port = NULL;\r\n        }\r\n    lp->txbfd = 0;\r\n    free (lp->txb);\r\n    lp->txb = NULL;\r\n    free (lp->rxb);\r\n    lp->rxb = NULL;\r\n    free (lp->rbr);\r\n    lp->rbr = NULL;\r\n    lp->modembits = 0;\r\n    }\r\n\r\nif (mp->master)\r\n    sim_close_sock (mp->master);                        /* close master socket */\r\nmp->master = 0;\r\nfree (mp->port);\r\nmp->port = NULL;\r\nif (mp->ring_sock != INVALID_SOCKET) {\r\n    sim_close_sock (mp->ring_sock);\r\n    mp->ring_sock = INVALID_SOCKET;\r\n    free (mp->ring_ipad);\r\n    mp->ring_ipad = NULL;\r\n    mp->ring_start_time = 0;\r\n    }\r\n_tmxr_remove_from_open_list (mp);\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Detach unit from master socket and close all active network connections\r\n   and/or serial ports.\r\n\r\n   Note that we return SCPE_OK, regardless of whether a listening socket was\r\n   attached.\r\n*/\r\n\r\nt_stat tmxr_detach (TMXR *mp, UNIT *uptr)\r\n{\r\nint32 i;\r\nchar portname[CBUFSIZE];\r\n\r\nif (!(uptr->flags & UNIT_ATT))                          /* attached? */\r\n    return SCPE_OK;\r\nfor (i=0; i < mp->lines; i++) {\r\n    mp->ldsc[i].uptr->dynflags &= ~UNIT_TM_POLL;                    /* no polling */\r\n    mp->ldsc[i].uptr->tmxr = NULL;\r\n    mp->ldsc[i].o_uptr->dynflags &= ~UNIT_TM_POLL;                  /* no polling */\r\n    mp->ldsc[i].o_uptr->tmxr = NULL;\r\n    sprintf (portname, \"%s:%d\", mp->dptr->name, i);\r\n    expect_cmd (0, portname);                           /* clear dangling expects */\r\n    send_cmd (0, portname);                             /* clear dangling send data */\r\n    }\r\ntmxr_close_master (mp);                                 /* close master socket */\r\nfree (uptr->filename);                                  /* free setup string */\r\nuptr->filename = NULL;\r\nuptr->tmxr = NULL;\r\nmp->last_poll_time = 0;\r\nuptr->flags &= ~(UNIT_ATT);                             /* not attached */\r\nuptr->dynflags &= ~UNIT_TM_POLL;                        /* no polling */\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic int32 _tmxr_activate_delay (UNIT *uptr, int32 interval)\r\n{\r\nTMXR *mp = (TMXR *)uptr->tmxr;\r\nint32 i, sooner = interval, due;\r\ndouble sim_gtime_now = sim_gtime ();\r\n\r\nfor (i=0; i<mp->lines; i++) {\r\n    TMLN *lp = &mp->ldsc[i];\r\n\r\n    if (uptr == lp->uptr) {                     /* read polling unit? */\r\n        if ((lp->send != NULL) &&\r\n            (lp->send->extoff < lp->send->insoff) &&\r\n            (sim_gtime_now < lp->send->next_time))\r\n            due = (int32)(lp->send->next_time - sim_gtime_now);\r\n        else {\r\n            if ((lp->rxbps)        &&           /* while rate limiting? */\r\n                (tmxr_rqln_bare (lp, FALSE))) { /* with pending input data */\r\n                if (lp->rxnexttime > sim_gtime_now)\r\n                    due = (int32)(lp->rxnexttime - sim_gtime_now);\r\n                else\r\n                    due = sim_processing_event ? 1 : 0; /* avoid potential infinite loop if called from service routine */\r\n                }\r\n            else\r\n                due = interval;\r\n            }\r\n        sooner = MIN(sooner, due);\r\n        }\r\n    if ((lp->conn || lp->txbfd) &&      /* Connected (or buffered)? */\r\n        (uptr == lp->o_uptr) &&         /* output completion unit? */\r\n        (lp->txbps)) {                  /* while rate limiting */\r\n        if ((tmxr_tqln(lp)) &&          /* pending output data */\r\n            (lp->txnexttime < sim_gtime_now))/* that can be transmitted now? */\r\n            tmxr_send_buffered_data (lp);/* flush it */\r\n        if (lp->txnexttime > sim_gtime_now)\r\n            due = (int32)(lp->txnexttime - sim_gtime_now);\r\n        else {\r\n            if (tmxr_tqln(lp) == 0)         /* no pending output data */\r\n                due = interval;             /* No rush */\r\n            else\r\n                due = sim_processing_event ? 1 : 0; /* avoid potential infinite loop if called from service routine */\r\n            }\r\n        sooner = MIN(sooner, due);\r\n        }\r\n    }\r\nreturn sooner;\r\n}\r\n\r\nt_stat tmxr_activate (UNIT *uptr, int32 interval)\r\n{\r\nint32 sooner;\r\n\r\nif (uptr->dynflags & UNIT_TMR_UNIT)\r\n    return sim_timer_activate (uptr, interval);         /* Handle the timer case */\r\nif (!(uptr->dynflags & UNIT_TM_POLL))\r\n    return _sim_activate (uptr, interval);              /* Handle the non mux case */\r\nsooner = _tmxr_activate_delay (uptr, interval);\r\nif (sooner != interval) {\r\n    sim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_activate() - scheduling %s after %d instructions rather than %d instructions\\n\", sim_uname (uptr), sooner, interval);\r\n    return _sim_activate (uptr, sooner);                /* Handle the busy case */\r\n    }\r\nsim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_activate() - scheduling %s after %d instructions\\n\", sim_uname (uptr), interval);\r\nreturn _sim_activate (uptr, interval);\r\n}\r\n\r\nt_stat tmxr_activate_abs (UNIT *uptr, int32 interval)\r\n{\r\nAIO_VALIDATE(uptr);             /* Can't call asynchronously */\r\nsim_cancel (uptr);\r\nreturn tmxr_activate (uptr, interval);\r\n}\r\n\r\nt_stat tmxr_activate_after (UNIT *uptr, uint32 usecs_walltime)\r\n{\r\nint32 sooner;\r\n\r\nif (uptr->dynflags & UNIT_TMR_UNIT)\r\n    return _sim_activate_after (uptr, (double)usecs_walltime);  /* Handle the timer case */\r\nif (!(uptr->dynflags & UNIT_TM_POLL))\r\n    return _sim_activate_after (uptr, (double)usecs_walltime);  /* Handle the non mux case */\r\nsooner = _tmxr_activate_delay (uptr, 0x7FFFFFFF);\r\nif (sooner != 0x7FFFFFFF) {\r\n    if (sooner < 0) {\r\n        sim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_activate_after() - scheduling %s for %u usecs produced overflow interval %d instructions, scheduling for %d instructions\\n\", sim_uname (uptr), usecs_walltime, sooner, 0x7FFFFFFF);\r\n        sooner = _tmxr_activate_delay (uptr, 0x7FFFFFFF);   /* Breakpoint here on unexpected value */\r\n        }\r\n    sim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_activate_after() - scheduling %s after %d instructions rather than %u usecs\\n\", sim_uname (uptr), sooner, usecs_walltime);\r\n    return _sim_activate (uptr, sooner);                        /* Handle the busy case directly */\r\n    }\r\nsim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_activate_after() - scheduling %s after %.0f usecs\\n\", sim_uname (uptr), (double)usecs_walltime);\r\nreturn _sim_activate_after (uptr, (double)usecs_walltime);\r\n}\r\n\r\nt_stat tmxr_activate_after_abs (UNIT *uptr, uint32 usecs_walltime)\r\n{\r\nsim_cancel (uptr);\r\nreturn tmxr_activate_after (uptr, usecs_walltime);\r\n}\r\n\r\nt_stat tmxr_clock_coschedule (UNIT *uptr, int32 interval)\r\n{\r\nint32 tmr = sim_rtcn_calibrated_tmr ();\r\nint32 ticks = (interval + (sim_rtcn_tick_size (tmr)/2))/sim_rtcn_tick_size (tmr);/* Convert to ticks */\r\n\r\nreturn tmxr_clock_coschedule_tmr (uptr, tmr, ticks);\r\n}\r\n\r\nt_stat tmxr_clock_coschedule_abs (UNIT *uptr, int32 interval)\r\n{\r\nsim_cancel (uptr);\r\nreturn tmxr_clock_coschedule (uptr, interval);\r\n}\r\n\r\nt_stat tmxr_clock_coschedule_tmr (UNIT *uptr, int32 tmr, int32 ticks)\r\n{\r\nint32 interval = ticks * sim_rtcn_tick_size (tmr);\r\nint32 sooner;\r\n\r\nif (uptr->dynflags & UNIT_TMR_UNIT)\r\n    return sim_clock_coschedule_tmr (uptr, tmr, ticks); /* Handle the timer case */\r\nif (!(uptr->dynflags & UNIT_TM_POLL))\r\n    return sim_clock_coschedule_tmr (uptr, tmr, ticks); /* Handle the non mux case */\r\nsooner = _tmxr_activate_delay (uptr, interval);\r\nif (sooner != interval) {\r\n    sim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_clock_coschedule_tmr(tmr=%d) - scheduling %s after %d instructions rather than %d ticks (%d instructions)\\n\", tmr, sim_uname (uptr), sooner, ticks, interval);\r\n    return _sim_activate (uptr, sooner);                /* Handle the busy case directly */\r\n    }\r\nsim_debug (TIMER_DBG_MUX, &sim_timer_dev, \"tmxr_clock_coschedule_tmr(tmr=%d) - coscheduling %s after interval %d ticks\\n\", tmr, sim_uname (uptr), ticks);\r\nreturn sim_clock_coschedule_tmr (uptr, tmr, ticks);\r\n}\r\n\r\nt_stat tmxr_clock_coschedule_tmr_abs (UNIT *uptr, int32 tmr, int32 ticks)\r\n{\r\nsim_cancel (uptr);\r\nreturn tmxr_clock_coschedule_tmr (uptr, tmr, ticks);\r\n}\r\n\r\n/* Generic Multiplexer attach help */\r\n\r\nt_stat tmxr_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr)\r\n{\r\nTMXR *mux = (TMXR *)dptr->help_ctx;\r\nt_bool single_line = FALSE;               /* default to Multi-Line help */\r\nt_bool port_speed_control = FALSE;\r\nt_bool modem_control = FALSE;\r\n\r\nif (mux) {\r\n    single_line = (mux->lines == 1);\r\n    port_speed_control = mux->port_speed_control;\r\n    modem_control = mux->modem_control;\r\n    }\r\n\r\nif (!flag)\r\n    fprintf (st, \"%s Multiplexer Attach Help\\n\\n\", dptr->name);\r\nif (single_line) {          /* Single Line Multiplexer */\r\n    fprintf (st, \"The %s multiplexer may be connected to terminal emulators supporting the\\n\", dptr->name);\r\n    fprintf (st, \"Telnet protocol via sockets, or to hardware terminals via host serial\\n\");\r\n    fprintf (st, \"ports.\\n\\n\");\r\n    if (modem_control) {\r\n        fprintf (st, \"The %s device is a full modem control device and therefore is capable of\\n\", dptr->name);\r\n        fprintf (st, \"passing port configuration information and modem signals.\\n\");\r\n        }\r\n    fprintf (st, \"A Telnet listening port can be configured with:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s {interface:}port{;backlog=n}\\n\\n\", dptr->name);\r\n    fprintf (st, \"Connections to the specified port, by default, will be unrestricted.\\n\");\r\n    fprintf (st, \"Connections from particular IPv4 or IPv6 addresses can be restricted\\n\");\r\n    fprintf (st, \"or allowed based on rules you can add to the \\\"{interface:}port\\\"\\n\");\r\n    fprintf (st, \"specifier on the attach command.  You can add as many rules as you need\\n\");\r\n    fprintf (st, \"to the attach command specified with \\\";ACCEPT=rule-detail\\\" or\\n\");\r\n    fprintf (st, \"\\\";REJECT=rule-detail\\\" where rule-detail can be an IP address, hostname\\n\");\r\n    fprintf (st, \"or network block in CIDR form.  Rules are interpreted in order and if,\\n\");\r\n    fprintf (st, \"while processing the list, the end is reached the connection will be\\n\");\r\n    fprintf (st, \"rejected.\\n\\n\");\r\n    fprintf (st, \"The -U switch can be specified on the attach command that specifies\\n\");\r\n    fprintf (st, \"a listening port.  This will allow a listening port to be reused if\\n\");\r\n    fprintf (st, \"some prior connections haven't completely shutdown.\\n\\n\");\r\n    fprintf (st, \"Line buffering can be enabled for the %s device with:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Buffer{=bufsize}\\n\\n\", dptr->name);\r\n    fprintf (st, \"Line buffering can be disabled for the %s device with:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s NoBuffer\\n\\n\", dptr->name);\r\n    fprintf (st, \"The default buffer size is 32k bytes, the max buffer size is 1024k bytes\\n\\n\");\r\n    fprintf (st, \"The outbound traffic the %s device can be logged to a file with:\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Log=LogFileName\\n\\n\", dptr->name);\r\n    fprintf (st, \"File logging can be disabled for the %s device with:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s NoLog\\n\\n\", dptr->name);\r\n    fprintf (st, \"The %s device may be connected to a serial port on the host system.\\n\", dptr->name);\r\n    }\r\nelse {\r\n    fprintf (st, \"%s multiplexer lines may be connected to terminal emulators supporting the\\n\", dptr->name);\r\n    fprintf (st, \"Telnet protocol via sockets, or to hardware terminals via host serial\\n\");\r\n    fprintf (st, \"ports.  Concurrent Telnet and serial connections may be mixed on a given\\n\");\r\n    fprintf (st, \"multiplexer.\\n\\n\");\r\n    if (modem_control) {\r\n        fprintf (st, \"The %s device is a full modem control device and therefore is capable of\\n\", dptr->name);\r\n        fprintf (st, \"passing port configuration information and modem signals on all lines.\\n\");\r\n        }\r\n    fprintf (st, \"Modem Control signalling behaviors can be enabled/disabled on a specific\\n\");\r\n    fprintf (st, \"multiplexer line with:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,Modem\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,NoModem\\n\\n\", dptr->name);\r\n    fprintf (st, \"A Telnet listening port can be configured with:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s {interface:}port\\n\\n\", dptr->name);\r\n    fprintf (st, \"The -U switch can be specified on the attach command that specifies\\n\");\r\n    fprintf (st, \"a listening port.  This will allow a listening port to be reused if\\n\");\r\n    fprintf (st, \"some prior connections haven't completely shutdown.\\n\\n\");\r\n    if (mux)\r\n        fprintf (st, \"Line buffering for all %d lines on the %s device can be configured with:\\n\\n\", mux->lines, dptr->name);\r\n    else\r\n        fprintf (st, \"Line buffering for all lines on the %s device can be configured with:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Buffer{=bufsize}\\n\\n\", dptr->name);\r\n    if (mux)\r\n        fprintf (st, \"Line buffering for all %d lines on the %s device can be disabled with:\\n\\n\", mux->lines, dptr->name);\r\n    else\r\n        fprintf (st, \"Line buffering for all lines on the %s device can be disabled with:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s NoBuffer\\n\\n\", dptr->name);\r\n    fprintf (st, \"The default buffer size is 32k bytes, the max buffer size is 1024k bytes\\n\\n\");\r\n    fprintf (st, \"The outbound traffic for the lines of the %s device can be logged to files\\n\", dptr->name);\r\n    fprintf (st, \"with:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s Log=LogFileName\\n\\n\", dptr->name);\r\n    fprintf (st, \"The log file name for each line uses the above LogFileName as a template\\n\");\r\n    fprintf (st, \"for the actual file name which will be LogFileName_n where n is the line\\n\");\r\n    fprintf (st, \"number.\\n\\n\");\r\n    fprintf (st, \"Multiplexer lines may be connected to serial ports on the host system.\\n\");\r\n    }\r\nfprintf (st, \"Serial ports may be specified as an operating system specific device names\\n\");\r\nfprintf (st, \"or using simh generic serial names.  simh generic names are of the form\\n\");\r\nfprintf (st, \"serN, where N is from 0 thru one less than the maximum number of serial\\n\");\r\nfprintf (st, \"ports on the local system.  The mapping of simh generic port names to OS \\n\");\r\nfprintf (st, \"specific names can be displayed using the following command:\\n\\n\");\r\nfprintf (st, \"   sim> SHOW SERIAL\\n\");\r\nfprintf (st, \"   Serial devices:\\n\");\r\nfprintf (st, \"    ser0   COM1 (\\\\Device\\\\Serial0)\\n\");\r\nfprintf (st, \"    ser1   COM3 (Winachcf0)\\n\\n\");\r\nif (single_line) {          /* Single Line Multiplexer */\r\n    fprintf (st, \"   sim> ATTACH %s Connect=ser0\\n\\n\", dptr->name);\r\n    fprintf (st, \"or equivalently:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s Connect=COM1\\n\\n\", dptr->name);\r\n    }\r\nelse {\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,Connect=ser0\\n\\n\", dptr->name);\r\n    fprintf (st, \"or equivalently:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,Connect=COM1\\n\\n\", dptr->name);\r\n    if (mux)\r\n        fprintf (st, \"Valid line numbers are from 0 thru %d\\n\\n\", mux->lines-1);\r\n    }\r\nif (single_line) {          /* Single Line Multiplexer */\r\n    if (port_speed_control) {\r\n        fprintf (st, \"The data rate for the %s device is set programmatically within\\n\", dptr->name);\r\n        fprintf (st, \"the running simulator.  When connected via a telnet session, a\\n\");\r\n        fprintf (st, \"speed increase factor can be specified with a SPEED=*factor on\\n\");\r\n        fprintf (st, \"the ATTACH command.\\n\");\r\n        }\r\n    else {\r\n        fprintf (st, \"The data rate for the %s device can be controlled by\\n\", dptr->name);\r\n        fprintf (st, \"specifying SPEED=nnn{*factor} on the the ATTACH command.\\n\");\r\n        }\r\n    }\r\nelse {\r\n    if (port_speed_control) {\r\n        fprintf (st, \"The data rates for the lines of the %s device are set\\n\", dptr->name);\r\n        fprintf (st, \"programmatically within the running simulator.  When connected\\n\");\r\n        fprintf (st, \"via telnet sessions, a speed increase factor can be specified with\\n\");\r\n        fprintf (st, \"a SPEED=*factor on the ATTACH command.\\n\");\r\n        }\r\n    else {\r\n        fprintf (st, \"The data rate for all lines or a particular line of a the %s\\n\", dptr->name);\r\n        fprintf (st, \"device can be controlled by specifying SPEED=nnn{*fac} on the ATTACH\\n\");\r\n        fprintf (st, \"command.\\n\");\r\n        }\r\n    }\r\nif (!port_speed_control) {\r\n    fprintf (st, \"SPEED values can be any one of:\\n\\n\");\r\n    fprintf (st, \"    0 50 75 110 134 150 300 600 1200 1800 2000 2400\\n\");\r\n    fprintf (st, \"    3600 4800 7200 9600 19200 38400 57600 76800 115200\\n\\n\");\r\n    fprintf (st, \"A SPEED value of 0 causes input data to be delivered to the simulated\\n\");\r\n    fprintf (st, \"port as fast as it arrives.\\n\\n\");\r\n    }\r\nelse {\r\n    fprintf (st, \"\\n\");\r\n    }\r\nfprintf (st, \"Some simulated systems run very much faster than the original system\\n\");\r\nfprintf (st, \"which is being simulated.  To accommodate this, multiplexer lines \\n\");\r\nfprintf (st, \"connected via telnet sessions may include a factor which will increase\\n\");\r\nfprintf (st, \"the input and output data delivery rates by the specified factor.\\n\");\r\nfprintf (st, \"A factor is specified with a speed \");\r\nif (!port_speed_control) {\r\n    fprintf (st, \"value of the form \\\"speed*factor\\\"\\n\");\r\n    fprintf (st, \"Factor values can range from 1 thru 32.\\n\");\r\n    fprintf (st, \"Example:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s 1234,SPEED=2400\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s 1234,SPEED=9600*8\\n\", dptr->name);\r\n    if (!single_line)\r\n        fprintf (st, \"   sim> ATTACH %s Line=2,SPEED=2400\\n\", dptr->name);\r\n    fprintf (st, \"\\n\");\r\n    }\r\nelse {\r\n    fprintf (st, \"value of the form \\\"*factor\\\"\\n\");\r\n    fprintf (st, \"Factor values can range from 1 thru 32.\\n\");\r\n    fprintf (st, \"Example:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s 1234,SPEED=*8\\n\", dptr->name);\r\n    if (!single_line)\r\n        fprintf (st, \"   sim> ATTACH %s Line=2,SPEED=*4\\n\", dptr->name);\r\n    fprintf (st, \"\\n\");\r\n    fprintf (st, \"If an attach command specifies a speed multiply factor, that value will\\n\");\r\n    fprintf (st, \"persist independent of any programatic action by the simulated system to\\n\");\r\n    fprintf (st, \"change the port speed.\\n\\n\");\r\n    }\r\nif (!port_speed_control) {\r\n    fprintf (st, \"An optional serial port configuration string may be present after the port\\n\");\r\n    fprintf (st, \"name.  If present, it must be separated from the port name with a semicolon\\n\");\r\n    fprintf (st, \"and has this form:\\n\\n\");\r\n    fprintf (st, \"   <rate>-<charsize><parity><stopbits>\\n\\n\");\r\n    fprintf (st, \"where:\\n\");\r\n    fprintf (st, \"   rate     = communication rate in bits per second\\n\");\r\n    fprintf (st, \"   charsize = character size in bits (5-8, including optional parity)\\n\");\r\n    fprintf (st, \"   parity   = parity designator (N/E/O/M/S for no/even/odd/mark/space parity)\\n\");\r\n    fprintf (st, \"   stopbits = number of stop bits (1, 1.5, or 2)\\n\\n\");\r\n    fprintf (st, \"As an example:\\n\\n\");\r\n    fprintf (st, \"   9600-8n1\\n\\n\");\r\n    fprintf (st, \"The supported rates, sizes, and parity options are host-specific.  If\\n\");\r\n    fprintf (st, \"a configuration string is not supplied, then the default of 9600-8N1\\n\");\r\n    fprintf (st, \"is used.\\n\");\r\n    fprintf (st, \"Note: The serial port configuration option is only available on multiplexer\\n\");\r\n    fprintf (st, \"      lines which are not operating with full modem control behaviors enabled.\\n\");\r\n    fprintf (st, \"      Lines with full modem control behaviors enabled have all of their\\n\");\r\n    fprintf (st, \"      configuration managed by the Operating System running within the\\n\");\r\n    fprintf (st, \"      simulator.\\n\\n\");\r\n    }\r\nfprintf (st, \"An attachment to a serial port with the '-V' switch will cause a\\n\");\r\nfprintf (st, \"connection message to be output to the connected serial port.\\n\");\r\nfprintf (st, \"This will help to confirm the correct port has been connected and\\n\");\r\nfprintf (st, \"that the port settings are reasonable for the connected device.\\n\");\r\nfprintf (st, \"This would be done as:\\n\\n\");\r\nif (single_line)            /* Single Line Multiplexer */\r\n    fprintf (st, \"   sim> ATTACH -V %s Connect=SerN\\n\", dptr->name);\r\nelse {\r\n    fprintf (st, \"   sim> ATTACH -V %s Line=n,Connect=SerN\\n\\n\", dptr->name);\r\n    fprintf (st, \"Line specific tcp listening ports are supported.  These are configured\\n\");\r\n    fprintf (st, \"using commands of the form:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,{interface:}port{;notelnet}{;nomessage}{;backlog=n}\\n\\n\", dptr->name);\r\n    fprintf (st, \"Connections to the specified port, by default, will be unrestricted.\\n\");\r\n    fprintf (st, \"Connections from particular IPv4 or IPv6 addresses can be restricted\\n\");\r\n    fprintf (st, \"or allowed based on rules you can add to the \\\"{interface:}port\\\"\\n\");\r\n    fprintf (st, \"specifier on the attach command.  You can add as many rules as you need\\n\");\r\n    fprintf (st, \"to the attach command specified with \\\";ACCEPT=rule-detail\\\" or\\n\");\r\n    fprintf (st, \"\\\";REJECT=rule-detail\\\" where rule-detail can be an IP address, hostname\\n\");\r\n    fprintf (st, \"or network block in CIDR form.  Rules are interpreted in order and if,\\n\");\r\n    fprintf (st, \"while processing the list, the end is reached the connection will be\\n\");\r\n    fprintf (st, \"rejected.\\n\\n\");\r\n    }\r\nfprintf (st, \"Direct computer to computer connections (Virtual Null Modem cables) may\\n\");\r\nfprintf (st, \"be established using the telnet protocol or via raw tcp sockets.\\n\\n\");\r\nfprintf (st, \"   sim> ATTACH %s Line=n,Connect=host:port{;notelnet}|{;nomessage}\\n\\n\", dptr->name);\r\nfprintf (st, \"Computer to computer virtual connections can be one way (as illustrated\\n\");\r\nfprintf (st, \"above) or symmetric.  A symmetric connection is configured by combining\\n\");\r\nif (single_line) {          /* Single Line Multiplexer */\r\n    fprintf (st, \"a one way connection with a tcp listening port on the same line:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s listenport,Connect=host:port\\n\\n\", dptr->name);\r\n    }\r\nelse {\r\n    fprintf (st, \"a one way connection with a tcp listening port on the same line:\\n\\n\");\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,listenport,Connect=host:port\\n\\n\", dptr->name);\r\n    }\r\nfprintf (st, \"When symmetric virtual connections are configured, incoming connections\\n\");\r\nfprintf (st, \"on the specified listening port are checked to assure that they actually\\n\");\r\nfprintf (st, \"come from the specified connection destination host system.\\n\\n\");\r\nif (single_line) {          /* Single Line Multiplexer */\r\n    fprintf (st, \"The %s device can be attached in LOOPBACK mode:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Loopback\\n\\n\", dptr->name);\r\n    }\r\nelse {\r\n    fprintf (st, \"A line on the %s device can be attached in LOOPBACK mode:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,Loopback\\n\\n\", dptr->name);\r\n    fprintf (st, \"A line on the %s device can be specifically disabled:\\n\\n\", dptr->name);\r\n    fprintf (st, \"   sim> ATTACH %s Line=n,Disable\\n\\n\", dptr->name);\r\n    }\r\nfprintf (st, \"When operating in LOOPBACK mode, all outgoing data arrives as input and\\n\");\r\nfprintf (st, \"outgoing modem signals (if enabled) (DTR and RTS) are reflected in the\\n\");\r\nfprintf (st, \"incoming modem signals (DTR->(DCD and DSR), RTS->CTS)\\n\\n\");\r\nif (single_line)            /* Single Line Multiplexer */\r\n    fprintf (st, \"The connection configured for the %s device is unconfigured by:\\n\\n\", dptr->name);\r\nelse\r\n    fprintf (st, \"All connections configured for the %s device are unconfigured by:\\n\\n\", dptr->name);\r\nfprintf (st, \"   sim> DETACH %s\\n\\n\", dptr->name);\r\nif (dptr->modifiers) {\r\n    MTAB *mptr;\r\n\r\n    for (mptr = dptr->modifiers; mptr->mask != 0; mptr++)\r\n        if (mptr->valid == &tmxr_dscln) {\r\n            fprintf (st, \"A specific line on the %s device can be disconnected with:\\n\\n\", dptr->name);\r\n            fprintf (st, \"   sim> SET %s %s=n\\n\\n\", dptr->name, mptr->mstring);\r\n            fprintf (st, \"This will cause a telnet connection to be closed, but a serial port will\\n\");\r\n            fprintf (st, \"normally have DTR dropped for 500ms and raised again (thus hanging up a\\n\");\r\n            fprintf (st, \"modem on that serial port).\\n\\n\");\r\n            fprintf (st, \"Any lines connected to serial port can be manually closed by unplugging\\n\");\r\n            fprintf (st, \"the serial cable from the host computer.  Dynamically adding or removing\\n\");\r\n            fprintf (st, \"a serial port from a mux while the simulated operating system is running\\n\");\r\n            fprintf (st, \"is guaranteed to have an inconsistent state between the running OS and\\n\");\r\n            fprintf (st, \"the simulated port state.  Restart the simulator without the serial port\\n\");\r\n            fprintf (st, \"attached.\\n\\n\");\r\n            }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Stub examine and deposit */\r\n\r\nt_stat tmxr_ex (t_value *vptr, t_addr addr, UNIT *uptr, int32 sw)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nt_stat tmxr_dep (t_value val, t_addr addr, UNIT *uptr, int32 sw)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\n\r\n/* Write a message directly to a socket */\r\n\r\nvoid tmxr_msg (SOCKET sock, const char *msg)\r\n{\r\nif ((sock) && (sock != INVALID_SOCKET))\r\n    sim_write_sock (sock, msg, (int32)strlen (msg));\r\n}\r\n\r\n\r\n/* Write a message to a line */\r\n\r\nvoid tmxr_linemsg (TMLN *lp, const char *msg)\r\n{\r\nwhile (*msg) {\r\n    while (SCPE_STALL == tmxr_putc_ln (lp, (int32)(*msg)))\r\n        if (lp->txbsz == tmxr_send_buffered_data (lp))\r\n            sim_os_ms_sleep (10);\r\n    ++msg;\r\n    }\r\n}\r\n\r\n\r\n/* Write a formatted message to a line */\r\n\r\nvoid tmxr_linemsgf (TMLN *lp, const char *fmt, ...)\r\n{\r\nva_list arglist;\r\n\r\nva_start (arglist, fmt);\r\ntmxr_linemsgvf (lp, fmt, arglist);\r\nva_end (arglist);\r\n}\r\n\r\nvoid tmxr_linemsgvf (TMLN *lp, const char *fmt, va_list arglist)\r\n{\r\nchar stackbuf[STACKBUFSIZE];\r\nint32 bufsize = sizeof(stackbuf);\r\nchar *buf = stackbuf;\r\nint32 i, len;\r\n\r\nbuf[bufsize-1] = '\\0';\r\nwhile (1) {                                         /* format passed string, args */\r\n#if defined(NO_vsnprintf)\r\n    len = vsprintf (buf, fmt, arglist);\r\n#else                                               /* !defined(NO_vsnprintf) */\r\n    len = vsnprintf (buf, bufsize-1, fmt, arglist);\r\n#endif                                              /* NO_vsnprintf */\r\n\r\n/* If the formatted result didn't fit into the buffer, then grow the buffer and try again */\r\n\r\n    if ((len < 0) || (len >= bufsize-1)) {\r\n        if (buf != stackbuf)\r\n            free (buf);\r\n        bufsize = bufsize * 2;\r\n        if (bufsize < len + 2)\r\n            bufsize = len + 2;\r\n        buf = (char *) malloc (bufsize);\r\n        if (buf == NULL)                            /* out of memory */\r\n            return;\r\n        buf[bufsize-1] = '\\0';\r\n        continue;\r\n        }\r\n    break;\r\n    }\r\n\r\n/* Output the formatted data expanding newlines where they exist */\r\n\r\nfor (i = 0; i < len; ++i) {\r\n    if (('\\n' == buf[i]) && ((i == 0) || ('\\r' != buf[i-1]))) {\r\n        while (SCPE_STALL == tmxr_putc_ln (lp, '\\r'))\r\n            if (lp->txbsz == tmxr_send_buffered_data (lp))\r\n                sim_os_ms_sleep (10);\r\n        }\r\n    while (SCPE_STALL == tmxr_putc_ln (lp, buf[i]))\r\n        if (lp->txbsz == tmxr_send_buffered_data (lp))\r\n            sim_os_ms_sleep (10);\r\n    }\r\nif (buf != stackbuf)\r\n    free (buf);\r\n}\r\n\r\n\r\n/* Print connections - used only in named SHOW command */\r\n\r\nvoid tmxr_fconns (FILE *st, const TMLN *lp, int32 ln)\r\n{\r\nint32 hr, mn, sc;\r\nuint32 ctime;\r\n\r\nif (ln >= 0)\r\n    fprintf (st, \"line %d: \", ln);\r\n\r\nif ((lp->sock) || (lp->connecting)) {                   /* tcp connection? */\r\n    if (lp->destination)                                /* remote connection? */\r\n        if (lp->datagram)\r\n            fprintf (st, \"Datagram Connection from %s to remote port %s\\n\", lp->port, lp->destination);/* print port name */\r\n        else\r\n            fprintf (st, \"Connection to remote port %s\\n\", lp->destination);/* print port name */\r\n    else                                                /* incoming connection */\r\n        fprintf (st, \"Connection from IP address %s\\n\", lp->ipad);\r\n    }\r\nelse\r\n    if ((lp->destination) && (!lp->serport))            /* remote connection? */\r\n        fprintf (st, \"Connecting to remote port %s\\n\", lp->destination);/* print port name */\r\nif (lp->sock) {\r\n    char *sockname, *peername;\r\n\r\n    sim_getnames_sock (lp->sock, &sockname, &peername);\r\n    fprintf (st, \"Connection %s->%s\\n\", sockname, peername);\r\n    free (sockname);\r\n    free (peername);\r\n    }\r\n\r\nif ((lp->port) && (!lp->datagram)) {\r\n    fprintf (st, \"Listening on port %s\\n\", lp->port);   /* print port name */\r\n    if (lp->acl)\r\n        fprintf (st, \"Connections will be accepted/rejected based on: %s\\n\", lp->acl);\r\n    }\r\n\r\nif (lp->serport)                                        /* serial connection? */\r\n    fprintf (st, \"Connected to serial port %s\\n\", lp->destination);  /* print port name */\r\n\r\nif (lp->cnms) {\r\n    ctime = (sim_os_msec () - lp->cnms) / 1000;\r\n    hr = ctime / 3600;\r\n    mn = (ctime / 60) % 60;\r\n    sc = ctime % 60;\r\n    if (ctime)\r\n        fprintf (st, \" %s %02d:%02d:%02d\\n\", lp->connecting ? \"Connecting for\" : \"Connected\", hr, mn, sc);\r\n    }\r\nelse\r\n    fprintf (st, \" Line disconnected%s\\n\", lp->txbfd ? \" (buffered)\" : \"\");\r\n\r\nif (lp->modem_control) {\r\n    fprintf (st, \" Modem Bits: %s%s%s%s%s%s\\n\", (lp->modembits & TMXR_MDM_DTR) ? \"DTR \" : \"\",\r\n                                                (lp->modembits & TMXR_MDM_RTS) ? \"RTS \" : \"\",\r\n                                                (lp->modembits & TMXR_MDM_DCD) ? \"DCD \" : \"\",\r\n                                                (lp->modembits & TMXR_MDM_RNG) ? \"RNG \" : \"\",\r\n                                                (lp->modembits & TMXR_MDM_CTS) ? \"CTS \" : \"\",\r\n                                                (lp->modembits & TMXR_MDM_DSR) ? \"DSR \" : \"\");\r\n    }\r\n\r\nif ((lp->serport == 0) && (lp->sock) && (!lp->datagram))\r\n    fprintf (st, \" %s\\n\", (lp->notelnet) ? \"Telnet disabled (RAW data)\" : \"Telnet protocol\");\r\nif ((!lp->notelnet) && (lp->nomessage))\r\n    fprintf (st, \" Telnet connect message disabled\\n\");\r\nif ((lp->send != NULL) && (lp->send->buffer))\r\n    sim_show_send_input (st, lp->send);\r\nif ((lp->expect != NULL) && (lp->expect->buf))\r\n    sim_exp_showall (st, lp->expect);\r\nif (lp->txlog)\r\n    fprintf (st, \" Logging to %s\\n\", lp->txlogname);\r\n}\r\n\r\n\r\n/* Print statistics - used only in named SHOW command */\r\n\r\nvoid tmxr_fstats (FILE *st, const TMLN *lp, int32 ln)\r\n{\r\nstatic const char *enab = \"on\";\r\nstatic const char *dsab = \"off\";\r\n\r\nif (ln >= 0)\r\n    fprintf (st, \"Line %d:\", ln);\r\nif ((!lp->sock) && (!lp->connecting) && (!lp->serport) && (!lp->framer))\r\n    fprintf (st, \" not connected\\n\");\r\nelse {\r\n    if (ln >= 0)\r\n        fprintf (st, \"\\n\");\r\n    fprintf (st, \"  input (%s)\", (lp->rcve? enab: dsab));\r\n    if (lp->rxcnt)\r\n        fprintf (st, \" queued/total = %d/%d\", tmxr_rqln (lp), lp->rxcnt);\r\n    if (lp->rxpcnt)\r\n        fprintf (st, \" packets = %d\", lp->rxpcnt);\r\n    fprintf (st, \"\\n  output (%s)\", (lp->xmte? enab: dsab));\r\n    if (lp->txcnt || lp->txbpi)\r\n        fprintf (st, \" queued/total = %d/%d\", tmxr_tqln (lp), lp->txcnt);\r\n    if (lp->txpcnt || tmxr_tpqln (lp))\r\n        fprintf (st, \" packet data queued/packets sent = %d/%d\",\r\n            tmxr_tpqln (lp), lp->txpcnt);\r\n    fprintf (st, \"\\n\");\r\n    if ((lp->rxbps) || (lp->txbps)) {\r\n        if ((lp->rxbps == lp->txbps))\r\n            fprintf (st, \"  speed = %u\", lp->rxbps);\r\n        else\r\n            fprintf (st, \"  speed = %u/%u\", lp->rxbps, lp->txbps);\r\n        if (lp->bpsfactor > 1.0)\r\n            fprintf (st, \"*%.0f\", lp->bpsfactor);\r\n        fprintf (st, \" bps\\n\");\r\n        }\r\n    }\r\nif (lp->txbfd)\r\n    fprintf (st, \"  output buffer size = %d\\n\", lp->txbsz);\r\nif (lp->txcnt || lp->txbpi)\r\n    fprintf (st, \"  bytes in buffer = %d\\n\",\r\n               ((lp->txcnt > 0) && (lp->txcnt > lp->txbsz)) ? lp->txbsz : lp->txbpi);\r\nif (lp->txdrp)\r\n    fprintf (st, \"  dropped = %d\\n\", lp->txdrp);\r\nif (lp->txstall)\r\n    fprintf (st, \"  stalled = %d\\n\", lp->txstall);\r\n}\r\n\r\n\r\n/* Disconnect a line.\r\n\r\n   Disconnect a line of the multiplexer associated with descriptor \"desc\" from a\r\n   tcp session or a serial port.  Two calling sequences are supported:\r\n\r\n    1. If \"val\" is zero, then \"uptr\" is implicitly associated with the line\r\n       number corresponding to the position of the unit in the zero-based array\r\n       of units belonging to the associated device, and \"cptr\" is ignored.  For\r\n       example, if \"uptr\" points to unit 3 in a given device, then line 3 will\r\n       be disconnected.\r\n\r\n    2. If \"val\" is non-zero, then \"cptr\" points to a string that is parsed for\r\n       an explicit line number, and \"uptr\" is ignored.  For example, if \"cptr\"\r\n       points to the string \"3\", then line 3 will be disconnected.\r\n\r\n   If the line was connected to a tcp session, the socket associated with the\r\n   line will be closed.  If the line was connected to a serial port, the port\r\n   will NOT be closed, but DTR will be dropped.  After a 500ms delay DTR will\r\n   be raised again.\r\n\r\n   Implementation notes:\r\n\r\n    1. This function is usually called as an MTAB processing routine.\r\n*/\r\n\r\nt_stat tmxr_dscln (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nTMXR *mp = (TMXR *) desc;\r\nTMLN *lp;\r\nt_stat status;\r\n\r\nif (val)                                                        /* explicit line? */\r\n    uptr = NULL;                                                /* indicate to get routine */\r\n\r\ntmxr_debug_trace (mp, \"tmxr_dscln()\");\r\n\r\nlp = tmxr_get_ldsc (uptr, cptr, mp, &status);                   /* get referenced line */\r\n\r\nif (lp == NULL)                                                 /* bad line number? */\r\n    return status;                                              /* report it */\r\n\r\nif ((lp->sock) || (lp->serport)) {                              /* connection active? */\r\n    if ((!lp->notelnet) && (!lp->nomessage))\r\n        tmxr_linemsg (lp, \"\\r\\nOperator disconnected line\\r\\n\\n\");/* report closure */\r\n    if (lp->serport && (sim_switches & SWMASK ('C'))) {\r\n        sim_messagef (SCPE_OK, \"If you really feel the need to disconnect this serial port, unplug the cable\\n\");\r\n        sim_messagef (SCPE_OK, \"from the serial port on your system.  Alternatively, you should restart the\\n\");\r\n        sim_messagef (SCPE_OK, \"simulator without attaching the serial port in your configuration.\\n\");\r\n        }\r\n    return tmxr_reset_ln_ex (lp, FALSE);                        /* drop the line */\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Enable logging for line */\r\n\r\nt_stat tmxr_set_log (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nTMXR *mp = (TMXR *) desc;\r\nTMLN *lp;\r\nt_stat r;\r\nint32 nbytes, boffset;\r\n\r\nif (cptr == NULL)                                       /* no file name? */\r\n    return SCPE_2FARG;\r\nlp = tmxr_find_ldsc (uptr, val, mp);                    /* find line desc */\r\nif (lp == NULL)\r\n    return SCPE_IERR;\r\nif (lp->txlog)                                          /* close existing log */\r\n    tmxr_set_nolog (NULL, val, NULL, desc);\r\nlp->txlogname = (char *) calloc (CBUFSIZE, sizeof (char)); /* alloc namebuf */\r\nif (lp->txlogname == NULL)                              /* can't? */\r\n    return SCPE_MEM;\r\nstrlcpy (lp->txlogname, cptr, CBUFSIZE);                /* save file name */\r\nr = sim_open_logfile (cptr, TRUE, &lp->txlog, &lp->txlogref);/* open log */\r\nif ((r != SCPE_OK) || (lp->txlog == NULL)) {            /* error? */\r\n    free (lp->txlogname);                               /* free buffer */\r\n    return SCPE_OPENERR;\r\n    }\r\nif (mp->uptr)                                           /* attached?, then update attach string */\r\n    lp->mp->uptr->filename = tmxr_mux_attach_string (lp->mp->uptr->filename, lp->mp);\r\nif (lp->conn) { /* If we're connected, flush the buffer out now */\r\n    while (tmxr_send_buffered_data (lp) > 0)\r\n        sim_os_ms_sleep (10);\r\n    }\r\nelse {\r\n    if (lp->txcnt > lp->txbsz) {\r\n        boffset = (lp->txbpi + 1) % lp->txbsz;\r\n        nbytes = lp->txbsz;                             /* avail buffered bytes */\r\n        }\r\n    else {\r\n        boffset = 0;\r\n        nbytes = lp->txbpi;\r\n        }\r\n    while (nbytes) {                                    /* >0? write */\r\n        int32 sbytes;\r\n\r\n        if (boffset < lp->txbpi)                        /* no wrap? */\r\n            sbytes = fwrite (&(lp->txb[boffset]), 1, nbytes, lp->txlog);/* write all data */\r\n        else\r\n            sbytes = fwrite (&(lp->txb[boffset]), 1, lp->txbsz - boffset, lp->txlog);/* write to end buf */\r\n        if (sbytes >= 0) {                              /* ok? */\r\n            boffset += sbytes;                          /* update remove ptr */\r\n            if (boffset >= lp->txbsz)                   /* wrap? */\r\n                boffset = 0;\r\n            nbytes -= sbytes;                           /* update remaining count */\r\n            }\r\n        else\r\n            break;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Disable logging for line */\r\n\r\nt_stat tmxr_set_nolog (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nTMXR *mp = (TMXR *) desc;\r\nTMLN *lp;\r\n\r\nif (cptr)                                               /* no arguments */\r\n    return SCPE_2MARG;\r\nlp = tmxr_find_ldsc (uptr, val, mp);                    /* find line desc */\r\nif (lp == NULL)\r\n    return SCPE_IERR;\r\nif (lp->txlog) {                                        /* logging? */\r\n    sim_close_logfile (&lp->txlogref);                  /* close log */\r\n    free (lp->txlogname);                               /* free namebuf */\r\n    lp->txlog = NULL;\r\n    lp->txlogname = NULL;\r\n    }\r\nif (mp->uptr)\r\n    lp->mp->uptr->filename = tmxr_mux_attach_string (lp->mp->uptr->filename, lp->mp);\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Show logging status for line */\r\n\r\nt_stat tmxr_show_log (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nconst TMXR *mp = (const TMXR *) desc;\r\nTMLN *lp;\r\n\r\nlp = tmxr_find_ldsc (uptr, val, mp);                    /* find line desc */\r\nif (lp == NULL)\r\n    return SCPE_IERR;\r\nif (lp->txlog)\r\n    fprintf (st, \"logging to %s\", lp->txlogname);\r\nelse fprintf (st, \"no logging\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\n/* Set the line connection order.\r\n\r\n   This validation routine is called to set the connection order for the\r\n   multiplexer whose TMXR pointer is passed in the \"desc\" parameter.  It parses\r\n   the line order list, specified by the \"cptr\" parameter, of commands such as:\r\n\r\n      SET <dev> LINEORDER=4-7\r\n      SET <dev> LINEORDER=1;5;2-4;7;ALL\r\n      SET <dev> LINEORDER=ALL\r\n\r\n   Assuming an 8-channel multiplexer, the first form sets the connection order\r\n   to line numbers 4, 5, 6, and 7.  The remaining lines will not be connected; a\r\n   connection attempt will be refused with \"All connections busy.\"  The second\r\n   form sets the connection order to line 1, 5, 2, 3, 4, 7, 0, and 6.  The\r\n   trailing \"ALL\" parameter causes any unspecified lines to be added to the\r\n   connection order in ascending value.  The third form sets the order to lines\r\n   0-7, which is the default order in the absence of a line connection order\r\n   array.\r\n\r\n   The range of accepted line numbers, including those implied by \"ALL\", can be\r\n   restricted by specifying a non-zero \"val\" parameter, with the upper 16 bits\r\n   specifying the maximum line number, and the lower 16 bits specifying the\r\n   minimum line number.  If a minimum is specified but a maximum is not (i.e.,\r\n   is zero), the maximum is the last line number defined by the multiplexer\r\n   descriptor.\r\n\r\n   The \"uptr\" parameter is not used.\r\n\r\n   On entry, \"cptr\" points to the value portion of the command string, which may\r\n   be either a semicolon-separated list of line ranges or the keyword \"ALL\".  If\r\n   \"ALL\" is specified, it must be the last (or only) item in the list.\r\n\r\n   If a line connection order array is not defined in the multiplexer\r\n   descriptor, or a line range string is not present, or the optional minimum\r\n   and maximum restrictions in the \"val\" parameter are not valid, the command is\r\n   rejected.  If the specified range encompasses all of the lines defined by the\r\n   multiplexer, the first value of the connection order array is set to -1 to\r\n   indicate sequential connection order.  Otherwise, the line values in the\r\n   array are set to the order specified by the command string.  If fewer values\r\n   are supplied than there are lines supported by the device, and the final\r\n   parameter is not ALL, the remaining lines will be inaccessible and are\r\n   indicated by a -1 value after the last specified value.\r\n\r\n   If an error occurs, the original line order is not disturbed.\r\n*/\r\n\r\nt_stat tmxr_set_lnorder (UNIT *uptr, int32 val, CONST char *cptr, void *desc)\r\n{\r\nTMXR   *mp = (TMXR *) desc;\r\nchar   *tbuf = NULL;\r\nchar   *tptr;\r\nt_addr low, high, min, max;\r\nint32  *list;\r\nt_bool *set;\r\nuint32 line, idx;\r\nt_addr lncount = (t_addr) (mp->lines - 1);\r\nt_stat result = SCPE_OK;\r\n\r\nif (mp->lnorder == NULL)                                /* if the connection order array is not defined */\r\n    return SCPE_NXPAR;                                  /*   then report a \"Non-existent parameter\" error */\r\n\r\nelse if ((cptr == NULL) || (*cptr == '\\0'))             /* otherwise if a line range was not supplied */\r\n    return SCPE_MISVAL;                                 /*   then report a \"Missing value\" error */\r\n\r\nelse {                                                  /* otherwise */\r\n    min = (t_addr) (val & 0xFFFF);                      /*   split the restriction into */\r\n    max = (t_addr) ((val >> 16) & 0xFFFF);              /*     minimum and maximum line numbers */\r\n\r\n    if (max == 0)                                       /* if the maximum line number isn't specified */\r\n        max = lncount;                                  /*   then use the defined maximum */\r\n\r\n    if (min > lncount || max > lncount || min > max)    /* if the restriction isn't valid */\r\n        return SCPE_IERR;                               /*   then report an \"Internal error\" */\r\n    }\r\n\r\nlist = (int32 *) calloc (mp->lines, sizeof (int32));    /* allocate the new line order array */\r\n\r\nif (list == NULL)                                       /* if the allocation failed */\r\n    return SCPE_MEM;                                    /*   then report a \"Memory exhausted\" error */\r\n\r\nset = (t_bool *) calloc (mp->lines, sizeof (t_bool));   /* allocate the line set tracking array */\r\n\r\nif (set == NULL) {                                      /* if the allocation failed */\r\n    free (list);                                        /*   then free the successful list allocation */\r\n    return SCPE_MEM;                                    /*      and report a \"Memory exhausted\" error */\r\n    }\r\n\r\ntbuf = (char *) calloc (strlen(cptr)+2, sizeof(*cptr));\r\nif (tbuf == NULL) {                                     /* if the allocation failed */\r\n    free (set);                                         /*   then free the line set tracking array */\r\n    free (list);                                        /*        and successful list allocation */\r\n    return SCPE_MEM;                                    /*      and report a \"Memory exhausted\" error */\r\n    }\r\n\r\nstrcpy (tbuf, cptr);\r\ntptr = tbuf + strlen (tbuf);                            /* append a semicolon */\r\n*tptr++ = ';';                                          /*   to the command string */\r\n*tptr = '\\0';                                           /*   to make parsing easier for get_range */\r\ncptr = tbuf;\r\n\r\nidx = 0;                                                /* initialize the index of ordered values */\r\n\r\nwhile (*cptr != '\\0') {                                     /* while characters remain in the command string */\r\n    if (strncasecmp (cptr, \"ALL;\", 4) == 0) {               /*   if the parameter is \"ALL\" */\r\n        if ((val != 0) || ((idx > 0) && (idx <= max)))      /*     then if some lines are restricted or unspecified */\r\n            for (line = (uint32)min; line <= (uint32)max; line++)/*  then fill them in sequentially */\r\n                if (set [line] == FALSE)                    /*         setting each unspecified line */\r\n                    list [idx++] = line;                    /*           into the line order */\r\n\r\n        cptr = cptr + 4;                                /* advance past \"ALL\" and the trailing semicolon */\r\n\r\n        if (*cptr != '\\0')                              /* if \"ALL\" is not the last parameter */\r\n            result = sim_messagef (SCPE_2MARG,          /*   then report extraneous items */\r\n                            \"Too many args: %s\\n\", cptr);\r\n\r\n        break;                                          /* \"ALL\" terminates the order list */\r\n        }\r\n\r\n    cptr = get_range (NULL, cptr, &low, &high, 10, max, ';');   /* get a line range */\r\n\r\n    if (cptr == NULL) {                                 /* if a parsing error occurred */\r\n        result = SCPE_ARG;                              /*   then report an invalid argument */\r\n        break;                                          /*     and terminate the parse */\r\n        }\r\n\r\n    else if ((low < min) ||\r\n             (low > max) ||\r\n             (high > max)) {                            /* otherwise if the line number is invalid */\r\n        result = SCPE_SUB;                              /*   then report the subscript is out of range */\r\n        break;                                          /*     and terminate the parse */\r\n        }\r\n\r\n    else                                                /* otherwise it's a valid range */\r\n        for (line = (uint32)low; line <= (uint32)high; line++)/* so add the line(s) to the order */\r\n            if (set [line] == FALSE) {                  /* if the line number has not been specified */\r\n                set [line] = TRUE;                      /*   then now it is */\r\n                list [idx++] = line;                    /*     and add it to the connection order */\r\n                }\r\n    }\r\n\r\nif (result == SCPE_OK) {                                /* if the assignment succeeded */\r\n    if (idx <= max)                                     /*   then if any lines were not specified */\r\n        list [idx] = -1;                                /*     then terminate the order list after the last one */\r\n\r\n    memcpy (mp->lnorder, list,                          /* copy the working array to the connection array */\r\n            mp->lines * sizeof (int32));\r\n    }\r\n\r\nfree (list);                                            /* free the list allocation */\r\nfree (set);                                             /*   and the set allocation */\r\nfree (tbuf);                                            /*   and the arg copy with ; */\r\n\r\nreturn result;                                          /* return the status */\r\n}\r\n\r\n/* Show the line connection order.\r\n\r\n   Parameters:\r\n    - st   = stream on which output is to be written\r\n    - uptr = (not used)\r\n    - val  = (not used)\r\n    - desc = pointer to multiplexer's TMXR structure\r\n\r\n   If a connection order array is not defined in the multiplexer descriptor, the\r\n   command is rejected.  If the first value of the connection order array is set\r\n   to -1, then the connection order is sequential.  Otherwise, the line values\r\n   in the array are printed as a semicolon-separated list.  Ranges are printed\r\n   where possible to shorten the output.  A -1 value within the array indicates\r\n   the end of the order list.\r\n*/\r\n\r\nt_stat tmxr_show_lnorder (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nint32 i, j, low, last;\r\nconst TMXR *mp = (const TMXR *) desc;\r\nint32 *iptr = mp->lnorder;\r\nt_bool first = TRUE;\r\n\r\nif (iptr == NULL)                                       /* connection order undefined? */\r\n    return SCPE_NXPAR;                                  /* \"Non-existent parameter\" error */\r\n\r\nif (*iptr < 0)                                          /* sequential order indicated? */\r\n    fprintf (st, \"Order=0-%d\\n\", mp->lines - 1);        /* print full line range */\r\n\r\nelse {\r\n    low = last = *iptr++;                               /* set first line value */\r\n\r\n    for (j = 1; last != -1; j++) {                      /* print the remaining lines in the order list */\r\n        if (j < mp->lines)                              /* more lines to process? */\r\n            i = *iptr++;                                /* get next line in list */\r\n        else                                            /* final iteration */\r\n            i = -1;                                     /* get \"tie-off\" value */\r\n\r\n        if (i != last + 1) {                            /* end of a range? */\r\n            if (first) {                                /* first line to print? */\r\n                fputs (\"Order=\", st);                   /* print header */\r\n                first = FALSE;\r\n                }\r\n\r\n            else                                        /* not first line printed */\r\n                fputc (';', st);                        /* print separator */\r\n\r\n            if (low == last)                            /* range null? */\r\n                fprintf (st, \"%d\", last);               /* print single line value */\r\n\r\n            else                                        /* range established */\r\n                fprintf (st, \"%d-%d\", low, last);       /* print start and end line */\r\n\r\n            low = i;                                    /* start new range */\r\n            }\r\n\r\n        last = i;                                       /* note value for range check */\r\n        }\r\n    }\r\n\r\nif (first == FALSE)                                     /* sanity check for lines == 0 */\r\n    fputc ('\\n', st);\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show summary processor */\r\n\r\nt_stat tmxr_show_summ (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nconst TMXR *mp = (const TMXR *) desc;\r\nint32 i, t;\r\n\r\nif (mp == NULL)\r\n    return SCPE_IERR;\r\nfor (i = t = 0; i < mp->lines; i++)\r\n    if ((mp->ldsc[i].sock != 0) || (mp->ldsc[i].serport != 0))\r\n        t = t + 1;\r\nif (mp->lines > 1)\r\n    fprintf (st, \"%d current connection%s\", t, (t != 1) ? \"s\" : \"\");\r\nelse\r\n    fprintf (st, \"%s\", (t == 1) ? \"connected\" : \"disconnected\");\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show conn/stat processor */\r\n\r\nt_stat tmxr_show_cstat (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nconst TMXR *mp = (const TMXR *) desc;\r\nint32 i, any;\r\n\r\nif (mp == NULL)\r\n    return SCPE_IERR;\r\nfor (i = any = 0; i < mp->lines; i++) {\r\n    if ((mp->ldsc[i].sock != 0) ||\r\n        (mp->ldsc[i].serport != 0) || mp->ldsc[i].modem_control) {\r\n        if ((mp->ldsc[i].sock != 0) || (mp->ldsc[i].serport != 0))\r\n            any++;\r\n        if (val)\r\n            tmxr_fconns (st, &mp->ldsc[i], i);\r\n        else\r\n            if ((mp->ldsc[i].sock != 0) || (mp->ldsc[i].serport != 0))\r\n                tmxr_fstats (st, &mp->ldsc[i], i);\r\n        }\r\n    }\r\nif (any == 0)\r\n    fprintf (st, (mp->lines == 1? \"disconnected\\n\": \"all disconnected\\n\"));\r\nreturn SCPE_OK;\r\n}\r\n\r\n/* Show synchronous devices */\r\n\r\nt_stat tmxr_show_sync_devices (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char *desc)\r\n{\r\nreturn tmxr_show_sync (st, uptr, val, NULL);\r\n}\r\n\r\nt_stat tmxr_show_sync (FILE* st, UNIT* uptr, int32 val, CONST void *desc)\r\n{\r\n  ETH_LIST  list[ETH_MAX_DEVICE];\r\n  int number, fcnt = 0;\r\n\r\n  number = eth_devices(ETH_MAX_DEVICE, list, TRUE);\r\n  fprintf(st, \"DDCMP synchronous link devices:\\n\");\r\n  if (number == -1)\r\n    fprintf(st, \"  network support not available in simulator\\n\");\r\n  else\r\n    if (number == 0)\r\n      fprintf(st, \"  no ddcmp synchronous link devices are available\\n\");\r\n    else {\r\n      int i;\r\n      for (i=0; i<number; i++) {\r\n          fprintf(st,\" sync%d\\t%s\\n\", i, list[i].name);\r\n          fcnt++;\r\n      }\r\n    }\r\n  return SCPE_OK;\r\n}\r\n\r\n/* Show number of lines */\r\n\r\nt_stat tmxr_show_lines (FILE *st, UNIT *uptr, int32 val, CONST void *desc)\r\n{\r\nconst TMXR *mp = (const TMXR *) desc;\r\n\r\nif (mp == NULL)\r\n    return SCPE_IERR;\r\nfprintf (st, \"lines=%d\", mp->lines);\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nstatic struct {\r\n    u_char value;\r\n    const char *name;\r\n    } tn_chars[] =\r\n    {\r\n        {TN_IAC,    \"TN_IAC\"},                /* protocol delim */\r\n        {TN_DONT,   \"TN_DONT\"},               /* dont */\r\n        {TN_DO,     \"TN_DO\"},                 /* do */\r\n        {TN_WONT,   \"TN_WONT\"},               /* wont */\r\n        {TN_WILL,   \"TN_WILL\"},               /* will */\r\n        {TN_SB,     \"TN_SB\"},                 /* sub-option negotiation */\r\n        {TN_GA,     \"TN_SG\"},                 /* go ahead */\r\n        {TN_EL,     \"TN_EL\"},                 /* erase line */\r\n        {TN_EC,     \"TN_EC\"},                 /* erase character */\r\n        {TN_AYT,    \"TN_AYT\"},                /* are you there */\r\n        {TN_AO,     \"TN_AO\"},                 /* abort output */\r\n        {TN_IP,     \"TN_IP\"},                 /* interrupt process */\r\n        {TN_BRK,    \"TN_BRK\"},                /* break */\r\n        {TN_DATAMK, \"TN_DATAMK\"},             /* data mark */\r\n        {TN_NOP,    \"TN_NOP\"},                /* no operation */\r\n        {TN_SE,     \"TN_SE\"},                 /* end sub-option negot */\r\n        /* Options */\r\n        {TN_BIN,    \"TN_BIN\"},                /* bin */\r\n        {TN_ECHO,   \"TN_ECHO\"},               /* echo */\r\n        {TN_SGA,    \"TN_SGA\"},                /* sga */\r\n        {TN_STATUS, \"TN_STATUS\"},             /* option status query */\r\n        {TN_TIMING, \"TN_TIMING\"},             /* Timing Mark */\r\n        {TN_NAOCRD, \"TN_NAOCRD\"},             /* Output Carriage-Return Disposition */\r\n        {TN_NAOHTS, \"TN_NAOHTS\"},             /* Output Horizontal Tab Stops */\r\n        {TN_NAOHTD, \"TN_NAOHTD\"},             /* Output Horizontal Tab Stop Disposition */\r\n        {TN_NAOFFD, \"TN_NAOFFD\"},             /* Output Formfeed Disposition */\r\n        {TN_NAOVTS, \"TN_NAOVTS\"},             /* Output Vertical Tab Stop */\r\n        {TN_NAOVTD, \"TN_NAOVTD\"},             /* Output Vertical Tab Stop Disposition */\r\n        {TN_NAOLFD, \"TN_NAOLFD\"},             /* Output Linefeed Disposition */\r\n        {TN_EXTEND, \"TN_EXTEND\"},             /* Extended Ascii */\r\n        {TN_LOGOUT, \"TN_LOGOUT\"},             /* Logout */\r\n        {TN_BM,     \"TN_BM\"},                 /* Byte Macro */\r\n        {TN_DET,    \"TN_DET\"},                /* Data Entry Terminal */\r\n        {TN_SENDLO, \"TN_SENDLO\"},             /* Send Location */\r\n        {TN_TERMTY, \"TN_TERMTY\"},             /* Terminal Type */\r\n        {TN_ENDREC, \"TN_ENDREC\"},             /* Terminal Type */\r\n        {TN_TUID,   \"TN_TUID\"},               /* TACACS User Identification */\r\n        {TN_OUTMRK, \"TN_OUTMRK\"},             /* Output Marking */\r\n        {TN_TTYLOC, \"TN_TTYLOC\"},             /* Terminal Location Number */\r\n        {TN_3270,   \"TN_3270\"},               /* 3270 Regime */\r\n        {TN_X3PAD,  \"TN_X3PAD\"},              /* X.3 PAD */\r\n        {TN_NAWS,   \"TN_NAWS\"},               /* Negotiate About Window Size */\r\n        {TN_TERMSP, \"TN_TERMSP\"},             /* Terminal Speed */\r\n        {TN_TOGFLO, \"TN_TOGFLO\"},             /* Remote Flow Control */\r\n        {TN_LINE,   \"TN_LINE\"},               /* line mode */\r\n        {TN_XDISPL, \"TN_XDISPL\"},             /* X Display Location */\r\n        {TN_ENVIRO, \"TN_ENVIRO\"},             /* Environment */\r\n        {TN_AUTH,   \"TN_AUTH\"},               /* Authentication */\r\n        {TN_ENCRYP, \"TN_ENCRYP\"},             /* Data Encryption */\r\n        {TN_NEWENV, \"TN_NEWENV\"},             /* New Environment */\r\n        {TN_TN3270, \"TN_TN3270\"},             /* TN3270 Enhancements */\r\n        {TN_CHARST, \"TN_CHARST\"},             /* CHARSET */\r\n        {TN_COMPRT, \"TN_COMPRT\"},             /* Com Port Control */\r\n        {TN_KERMIT, \"TN_KERMIT\"},             /* KERMIT */\r\n        {0, NULL}};\r\n\r\nstatic char *tmxr_debug_buf = NULL;\r\nstatic size_t tmxr_debug_buf_used = 0;\r\nstatic size_t tmxr_debug_buf_size = 0;\r\n\r\nstatic void tmxr_buf_debug_char (char value)\r\n{\r\nif (tmxr_debug_buf_used+2 > tmxr_debug_buf_size) {\r\n    tmxr_debug_buf_size += 1024;\r\n    tmxr_debug_buf = (char *)realloc (tmxr_debug_buf, tmxr_debug_buf_size);\r\n    }\r\ntmxr_debug_buf[tmxr_debug_buf_used++] = value;\r\ntmxr_debug_buf[tmxr_debug_buf_used] = '\\0';\r\n}\r\n\r\nstatic void tmxr_buf_debug_string (const char *string)\r\n{\r\nwhile (*string)\r\n    tmxr_buf_debug_char (*string++);\r\n}\r\n\r\nstatic void tmxr_buf_debug_telnet_option (u_char chr)\r\n{\r\nint j;\r\n\r\nfor (j=0; 1; ++j) {\r\n    if (NULL == tn_chars[j].name) {\r\n        if (isprint(chr))\r\n            tmxr_buf_debug_char (chr);\r\n        else {\r\n            tmxr_buf_debug_char ('_');\r\n            if ((chr >= 1) && (chr <= 26)) {\r\n                tmxr_buf_debug_char ('^');\r\n                tmxr_buf_debug_char ('A' + chr - 1);\r\n                }\r\n            else {\r\n                char octal[8];\r\n\r\n                sprintf(octal, \"\\\\%03o\", (u_char)chr);\r\n                tmxr_buf_debug_string (octal);\r\n                }\r\n            tmxr_buf_debug_char ('_');\r\n            }\r\n        break;\r\n        }\r\n    if ((u_char)chr == tn_chars[j].value) {\r\n        tmxr_buf_debug_char ('_');\r\n        tmxr_buf_debug_string (tn_chars[j].name);\r\n        tmxr_buf_debug_char ('_');\r\n        break;\r\n        }\r\n    }\r\n}\r\n\r\nstatic int tmxr_buf_debug_telnet_options (u_char *buf, int bufsize)\r\n{\r\nint optsize = 2;\r\n\r\ntmxr_buf_debug_telnet_option ((u_char)buf[0]);\r\ntmxr_buf_debug_telnet_option ((u_char)buf[1]);\r\nswitch ((u_char)buf[1]) {\r\n    case TN_IAC:\r\n    default:\r\n        return optsize;\r\n        break;\r\n    case TN_WILL:\r\n    case TN_WONT:\r\n    case TN_DO:\r\n    case TN_DONT:\r\n        ++optsize;\r\n        tmxr_buf_debug_telnet_option ((u_char)buf[2]);\r\n        break;\r\n    }\r\nreturn optsize;\r\n}\r\n\r\nvoid _tmxr_debug (uint32 dbits, TMLN *lp, const char *msg, char *buf, int bufsize)\r\n{\r\nDEVICE *dptr = (lp->dptr ? lp->dptr : (lp->mp ? lp->mp->dptr : NULL));\r\n\r\nif ((dptr) && (dbits & dptr->dctrl)) {\r\n    int i;\r\n\r\n    tmxr_debug_buf_used = 0;\r\n    if (tmxr_debug_buf)\r\n        tmxr_debug_buf[tmxr_debug_buf_used] = '\\0';\r\n\r\n    if (lp->notelnet) {\r\n        int same, group, sidx, oidx;\r\n        char outbuf[80], strbuf[18];\r\n        static char hex[] = \"0123456789ABCDEF\";\r\n\r\n        for (i=same=0; i<bufsize; i += 16) {\r\n            if ((i > 0) && (0 == memcmp(&buf[i], &buf[i-16], 16))) {\r\n                ++same;\r\n                continue;\r\n                }\r\n            if (same > 0) {\r\n                if (lp->mp->lines > 1)\r\n                    sim_debug (dbits, dptr, \"Line:%d %04X thru %04X same as above\\n\", (int)(lp-lp->mp->ldsc), i-(16*same), i-1);\r\n                else\r\n                    sim_debug (dbits, dptr, \"%04X thru %04X same as above\\n\", i-(16*same), i-1);\r\n                same = 0;\r\n                }\r\n            group = (((bufsize - i) > 16) ? 16 : (bufsize - i));\r\n            for (sidx=oidx=0; sidx<group; ++sidx) {\r\n                outbuf[oidx++] = ' ';\r\n                outbuf[oidx++] = hex[(buf[i+sidx]>>4)&0xf];\r\n                outbuf[oidx++] = hex[buf[i+sidx]&0xf];\r\n                if (isprint((u_char)buf[i+sidx]))\r\n                    strbuf[sidx] = buf[i+sidx];\r\n                else\r\n                    strbuf[sidx] = '.';\r\n                }\r\n            outbuf[oidx] = '\\0';\r\n            strbuf[sidx] = '\\0';\r\n            if (lp->mp->lines > 1)\r\n                sim_debug (dbits, dptr, \"Line:%d %04X%-48s %s\\n\", (int)(lp-lp->mp->ldsc), i, outbuf, strbuf);\r\n            else\r\n                sim_debug (dbits, dptr, \"%04X%-48s %s\\n\", i, outbuf, strbuf);\r\n            }\r\n        if (same > 0) {\r\n            if (lp->mp->lines > 1)\r\n                sim_debug (dbits, dptr, \"Line:%d %04X thru %04X same as above\\n\", (int)(lp-lp->mp->ldsc), i-(16*same), bufsize-1);\r\n            else\r\n                sim_debug (dbits, dptr, \"%04X thru %04X same as above\\n\", i-(16*same), bufsize-1);\r\n            }\r\n        }\r\n    else {\r\n        tmxr_debug_buf_used = 0;\r\n        if (tmxr_debug_buf)\r\n            tmxr_debug_buf[tmxr_debug_buf_used] = '\\0';\r\n        for (i=0; i<bufsize; ++i) {\r\n            switch ((u_char)buf[i]) {\r\n                case TN_CR:\r\n                    tmxr_buf_debug_string (\"_TN_CR_\");\r\n                    break;\r\n                case TN_LF:\r\n                    tmxr_buf_debug_string (\"_TN_LF_\");\r\n                    break;\r\n                case TN_IAC:\r\n                    if (!lp->notelnet) {\r\n                        i += (tmxr_buf_debug_telnet_options ((u_char *)(&buf[i]), bufsize-i) - 1);\r\n                        break;\r\n                        }\r\n                    /* fall through */\r\n                default:\r\n                    if (isprint((u_char)buf[i]))\r\n                        tmxr_buf_debug_char (buf[i]);\r\n                    else {\r\n                        tmxr_buf_debug_char ('_');\r\n                        if ((buf[i] >= 1) && (buf[i] <= 26)) {\r\n                            tmxr_buf_debug_char ('^');\r\n                            tmxr_buf_debug_char ('A' + buf[i] - 1);\r\n                            }\r\n                        else {\r\n                            char octal[8];\r\n\r\n                            sprintf(octal, \"\\\\%03o\", (u_char)buf[i]);\r\n                            tmxr_buf_debug_string (octal);\r\n                            }\r\n                        tmxr_buf_debug_char ('_');\r\n                        }\r\n                    break;\r\n                }\r\n            }\r\n        if (lp->mp->lines > 1)\r\n            sim_debug (dbits, dptr, \"Line:%d %s %d bytes '%s'\\n\", (int)(lp-lp->mp->ldsc), msg, bufsize, tmxr_debug_buf);\r\n        else\r\n            sim_debug (dbits, dptr, \"%s %d bytes '%s'\\n\", msg, bufsize, tmxr_debug_buf);\r\n        }\r\n    if ((lp->rxnexttime != 0.0) || (lp->txnexttime != 0.0)) {\r\n        if (lp->rxnexttime != 0.0)\r\n            sim_debug (dbits, dptr, \" rxnexttime=%.0f (%.0f usecs)\", lp->rxnexttime, ((lp->rxnexttime - sim_gtime ()) / sim_timer_inst_per_sec ()) * 1000000.0);\r\n        if (lp->txnexttime != 0.0)\r\n            sim_debug (dbits, dptr, \" txnexttime=%.0f (%.0f usecs)\", lp->txnexttime, ((lp->txnexttime - sim_gtime ()) / sim_timer_inst_per_sec ()) * 1000000.0);\r\n        sim_debug (dbits, dptr, \"\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n/* Testing of sim_sock and tmxr */\r\n\r\nstatic struct lnorder_test {\r\n    const char *orderspec;\r\n    int32 valspec;\r\n    t_stat expected_stat;\r\n    int32 expected_orderlist[8];\r\n    } lnorders[] = {\r\n        {NULL,            0,         SCPE_MISVAL},\r\n        {\"\",              0,         SCPE_MISVAL},\r\n        {\"4-7\",  0x3FFF3FFF,         SCPE_IERR},\r\n        {\"6-8\",           0,         SCPE_SUB},\r\n        {\"9-11\",          0,         SCPE_SUB},\r\n        {\"4-7\",           0,         SCPE_OK,\r\n               {  4,  5,  6,  7, -1}},\r\n        {\"1;5;2-4;7;ALL\", 0,         SCPE_OK,\r\n               {  1,  5,  2,  3,  4,  7,  0,  6}},\r\n        {\"ALL\",           0,         SCPE_OK,\r\n               {  -1}},\r\n    };\r\n\r\nstatic t_stat _lnorder_test (TMXR *tmxr,\r\n                             struct lnorder_test *t)\r\n{\r\nt_stat r;\r\nchar msg[80] = \"\";\r\nint i;\r\n\r\nr = tmxr_set_lnorder (NULL, t->valspec, t->orderspec, tmxr);\r\nif (r != t->expected_stat) {\r\n    snprintf (msg, sizeof (msg), \"Unexpected lnorder result status for \\\"%s\\\" Expected: %s\", t->orderspec, sim_error_text (t->expected_stat));\r\n    return sim_messagef (SCPE_ARG, \"%s, Got: %s\\n\", msg, sim_error_text (r));\r\n    }\r\nif (r == SCPE_OK) {\r\n    for (i = 0; i<8; i++)\r\n        if (t->expected_orderlist[i] != tmxr->lnorder[i])\r\n            return sim_messagef (SCPE_ARG, \"Unexpected order entry for line %d: %d vs %d\\n\", i, tmxr->lnorder[i], t->expected_orderlist[i]);\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat sim_tmxr_test_lnorder (TMXR *tmxr)\r\n{\r\nuint32 i;\r\nint32 *saved_lnorder = tmxr->lnorder;\r\nint32 saved_lines = tmxr->lines;\r\n\r\ntmxr->lnorder = (int32 *)calloc (tmxr->lines, sizeof (*tmxr->lnorder));\r\nif (tmxr->lines >= 8) {\r\n    tmxr->lines = 8;\r\n    for (i = 0; i < (sizeof (lnorders)/sizeof (lnorders[0])); ++i)\r\n        _lnorder_test (tmxr, &lnorders[i]);\r\n    }\r\nfree (tmxr->lnorder);\r\ntmxr->lnorder = saved_lnorder;\r\ntmxr->lines = saved_lines;\r\nreturn SCPE_OK;\r\n}\r\n\r\n\r\nt_stat tmxr_sock_test (DEVICE *dptr, const char *cptr)\r\n{\r\nchar cmd[CBUFSIZE], host[CBUFSIZE], port[CBUFSIZE];\r\nint line;\r\nTMXR *tmxr;\r\nTMLN *ln;\r\nint32 tmp1, tmp2;\r\nt_stat stat = SCPE_OK;\r\nSOCKET sock_mux = INVALID_SOCKET;\r\nSOCKET sock_line = INVALID_SOCKET;\r\nSIM_TEST_INIT;\r\n\r\nsim_printf (\"Testing %s:\\n\", dptr->name);\r\nSIM_TEST(sim_parse_addr (\"\", NULL, 0, \"localhost\", NULL, 0, \"1234\", NULL) != -1);\r\nSIM_TEST(sim_parse_addr (\"\", host, 0, \"localhost\", NULL, 0, \"1234\", NULL) != -1);\r\nSIM_TEST(sim_parse_addr (\"\", host, sizeof(host), \"localhost\", port, 0, \"1234\", NULL) != -1);\r\nSIM_TEST((sim_parse_addr (\"\", host, sizeof(host), \"localhost\", port, sizeof(port), \"1234\", NULL) == -1) || (strcmp(host, \"localhost\")) || (strcmp(port,\"1234\")));\r\nSIM_TEST(sim_addr_acl_check (\"127.0.0.1\", NULL) == -1);\r\nSIM_TEST(sim_addr_acl_check (\"127.0.0.1/0\", NULL) != -1);\r\nSIM_TEST(sim_addr_acl_check (\"127.0.0.1/32\", NULL) == -1);\r\nSIM_TEST(sim_addr_acl_check (\"127.0.0.1/64\", NULL) != -1);\r\nSIM_TEST(sim_addr_acl_check (\"127.0.0.6\", \"+127.0.0.1/32,-127.0.0.2\") != -1);\r\nSIM_TEST(sim_addr_acl_check (\"127.0.0.2\", \"+127.0.0.1,-127.0.0.2/32,+127.0.0.3\") != -1);\r\nSIM_TEST(sim_parse_addr (\"\", host, sizeof(host), \"localhost\", port, sizeof(port), \"1234\", \"127.0.0.1\") == -1);\r\nSIM_TEST((sim_parse_addr (\"localhost:6666\", host, sizeof(host), \"localhost\", port, sizeof(port), \"1234\", NULL) == -1) || (strcmp(host, \"localhost\")) || (strcmp(port,\"6666\")));\r\nSIM_TEST(sim_parse_addr (\"localhost:66666\", host, sizeof(host), \"localhost\", port, sizeof(port), \"1234\", NULL) != -1);\r\nSIM_TEST((sim_parse_addr (\"localhost:telnet\", host, sizeof(host), \"localhost\", port, sizeof(port), \"1234\", NULL) == -1) || (strcmp(host, \"localhost\")) || (strcmp(port,\"telnet\")));\r\nSIM_TEST((sim_parse_addr (\"telnet\", host, sizeof(host), \"localhost\", port, sizeof(port), \"1234\", NULL) == -1) || (strcmp(host, \"localhost\")) || (strcmp(port,\"telnet\")));\r\ndptr->dctrl = 0xFFFFFFFF;\r\ndptr->dctrl &= ~TMXR_DBG_TRC;\r\nsprintf (cmd, \"%s -u localhost:65500;telnet;nomessage\", dptr->name);\r\nSIM_TEST(attach_cmd (0, cmd));\r\ntmxr = (TMXR *)dptr->units->tmxr;\r\nln = &tmxr->ldsc[tmxr->lines - 1];\r\nSIM_TEST(detach_cmd (0, dptr->name));\r\nsprintf (cmd, \"%s -u localhost:65500;notelnet\", dptr->name);\r\nSIM_TEST(attach_cmd (0, cmd));\r\ntmxr = (TMXR *)dptr->units->tmxr;\r\nln = &tmxr->ldsc[tmxr->lines - 1];\r\nSIM_TEST(detach_cmd (0, dptr->name));\r\nif (tmxr->lines > 1) {\r\n    tmxr->modem_control = FALSE;\r\n    for (line=0; line < tmxr->lines; line++)\r\n        tmxr->ldsc[line].modem_control = FALSE;\r\n    snprintf (cmd + strlen (cmd), sizeof (cmd) - strlen (cmd), \",Line=%d,localhost:65501\", tmxr->lines - 1);\r\n    snprintf (cmd + strlen (cmd), sizeof (cmd) - strlen (cmd), \",Line=0,connect=localhost:65500\");\r\n    SIM_TEST(attach_cmd (0, cmd));\r\n    sock_line = sim_connect_sock_ex (NULL, \"localhost:65501\", NULL, NULL, 0);\r\n    sim_os_ms_sleep (100);\r\n    SIM_TEST((((tmp1 = tmxr_poll_conn (tmxr)) == tmxr->lines - 1) || (tmp1 == 1)) ? SCPE_OK : SCPE_IERR);\r\n    sock_mux = sim_connect_sock (\"\", \"localhost\", \"65500\");\r\n    sim_os_ms_sleep (100);\r\n    SIM_TEST(((tmp2 = tmxr_poll_conn (tmxr)) == 0) || (tmp2 == 2) ? SCPE_OK : SCPE_IERR);\r\n    show_cmd (0, \"MUX\");\r\n    sim_close_sock (sock_mux);\r\n    sock_mux = INVALID_SOCKET;\r\n    sim_close_sock (sock_line);\r\n    sock_line = INVALID_SOCKET;\r\n    SIM_TEST(detach_cmd (0, dptr->name));\r\n    SIM_TEST(sim_tmxr_test_lnorder (tmxr));\r\n    }\r\nreturn stat;\r\n}\r\n\r\nstatic int framer_await_status (TMLN *line, int cnt)\r\n{\r\nint i, stat, attempt, flen;\r\nETH_PACK framer_rpkt;\r\n\r\ni = line->framer->status_cnt;\r\nattempt = 0;\r\nwhile (attempt < 5) {\r\n    stat = eth_read (line->framer->eth, &framer_rpkt, NULL);\r\n    if (stat) {\r\n        flen  = framer_rpkt.msg[14] + (framer_rpkt.msg[15] << 8);\r\n        if (framer_rpkt.msg[18] == 021) {\r\n            /* DC1, so it's a framer status message.  Save it. */\r\n            if (flen > sizeof (struct status_msg_t))\r\n                flen = sizeof (struct status_msg_t);\r\n            memcpy (&line->framer->status, framer_rpkt.msg + 18, flen);\r\n            line->framer->status_cnt++;\r\n            continue;\r\n            }\r\n        }\r\n    if (i != line->framer->status_cnt)\r\n        return 1;\r\n    attempt++;\r\n    sim_os_ms_sleep (50);\r\n    }\r\ntmxr_debug_trace_line (line, \"no status received\\n\");\r\nreturn 0;\r\n}\r\n\r\nstatic void tmxr_setup_framer(TMLN *line, ETH_PACK *packet, int len)\r\n{\r\n/* First clear everything */\r\nmemset (packet, 0, sizeof (*packet));\r\n/* Set up the MAC header */\r\nmemcpy (&packet->msg[0], line->framer->eth->physical_addr, 6);\r\nmemcpy (&packet->msg[6], line->framer->eth->physical_addr, 6);\r\n/* Framer address is one higher than host interface MAC address */\r\npacket->msg[5]++;\r\n/* Set ethertype 60-06 */\r\npacket->msg[12] = 0x60;\r\npacket->msg[13] = 0x06;\r\n/* Set length */\r\npacket->msg[14] = len & 0xff;\r\npacket->msg[15] = len >> 8;\r\n/* Set length and padded length */\r\nlen += 16;  /* Add in header length */\r\nif (len < 60)\r\n    len = 60;\r\npacket->len = len;\r\npacket->crc_len = len + 4;\r\n}\r\n\r\nvoid tmxr_start_framer (TMLN *line, int dmc_mode)\r\n{\r\nt_stat ret;\r\nint cnt;\r\nETH_PACK framer_start;\r\n\r\nif (!line->framer)\r\n    /* Not a framer line, NOP */\r\n    return;\r\n\r\ntmxr_setup_framer (line, &framer_start, 8);\r\nframer_start.msg[16] = 0x11;\r\nframer_start.msg[17] = 1;       /* Command 1: start framer */\r\n/* Set DMC mode (DDCMP 3.1) if requested */\r\nif (dmc_mode)\r\n    line->framer->fmode |= 32;\r\nelse\r\n    line->framer->fmode &= ~32;\r\n/* Set mode in the command buffer */\r\nframer_start.msg[18] = line->framer->fmode & 0xff;\r\nframer_start.msg[19] = line->framer->fmode >> 8;\r\n/* Set speed in the command buffer */\r\nframer_start.msg[20] = line->framer->fspeed & 0xff;\r\nframer_start.msg[21] = (line->framer->fspeed >> 8) & 0xff;\r\nframer_start.msg[22] = (line->framer->fspeed >> 16) & 0xff;\r\nframer_start.msg[23] = line->framer->fspeed >> 24;\r\n/* Send the request */\r\ncnt = line->framer->status_cnt;\r\nret = eth_write (line->framer->eth, &framer_start, NULL);\r\nframer_await_status (line, cnt);\r\n}\r\n\r\nvoid tmxr_stop_framer (TMLN *line)\r\n{\r\nt_stat ret;\r\nint cnt;\r\nETH_PACK framer_stop;\r\n\r\nif (!line->framer)\r\n    /* Not a framer line, NOP */\r\n    return;\r\n\r\ntmxr_setup_framer (line, &framer_stop, 2);\r\nframer_stop.msg[16] = 0x11;\r\nframer_stop.msg[17] = 2;       /* Command 2: stop framer */\r\n/* Send the request */\r\ncnt = line->framer->status_cnt;\r\nret = eth_write (line->framer->eth, &framer_stop, NULL);\r\n/* Mark the framer off right now */\r\nline->framer->status.on = 0;\r\nframer_await_status (line, cnt);\r\n}\r\n\r\nstatic int  tmxr_framer_read (TMLN *line, char *buf, int nbytes)\r\n{\r\nint stat, flen, fstat;\r\nETH_PACK framer_rpkt;\r\n\r\nwhile (1) {\r\n    stat = eth_read (line->framer->eth, &framer_rpkt, NULL);\r\n    if (!stat)\r\n        return 0;\r\n    /* Size reported by framer includes status, subtract that */\r\n    flen  = (framer_rpkt.msg[14] + (framer_rpkt.msg[15] << 8)) - 2;\r\n    fstat = framer_rpkt.msg[16] + (framer_rpkt.msg[17] << 8);\r\n    if (framer_rpkt.msg[18] == 021) {\r\n        /* DC1, so it's a framer status message.  Save it. */\r\n        if (flen > sizeof (struct status_msg_t))\r\n            flen = sizeof (struct status_msg_t);\r\n        memcpy (&line->framer->status,\r\n                framer_rpkt.msg + 18, flen);\r\n        /* report interesting bits */\r\n        sim_debug (TMXR_DBG_RCV, line->dptr,\r\n                   \"framer status, on %d, last_cmd_sts %d\\n\",\r\n                   line->framer->status.on,\r\n                   line->framer->status.last_cmd_sts);\r\n        line->framer->status_cnt++;\r\n        /* Look for another packet */\r\n        continue;\r\n        }\r\n    else {\r\n        /* Real DDCMP packet.  Pass the buffer pointer/len */\r\n        if (flen > nbytes)\r\n            flen = nbytes;\r\n        memcpy (buf, framer_rpkt.msg + 18, flen);\r\n        return flen;\r\n        }\r\n    }\r\n}\r\n\r\nstatic int tmxr_framer_write (TMLN *line, const char *buf, int32 length)\r\n{\r\nt_stat ret;\r\nETH_PACK framer_tx;\r\n\r\ntmxr_setup_framer (line, &framer_tx, length);\r\nmemcpy (&framer_tx.msg[16], buf, length);\r\n/* Send the request */\r\nret = eth_write (line->framer->eth, &framer_tx, NULL);\r\n/* Always report the whole thing was written */\r\nreturn length;\r\n}\r\n\r\n"
        },
        {
          "name": "sim_tmxr.h",
          "type": "blob",
          "size": 22.8115234375,
          "content": "/* sim_tmxr.h: terminal multiplexer definitions\r\n\r\n   Copyright (c) 2001-2008, Robert M Supnik\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   ROBERT M SUPNIK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of Robert M Supnik shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from Robert M Supnik.\r\n\r\n   Based on the original DZ11 simulator by Thord Nilson, as updated by\r\n   Arthur Krewat.\r\n\r\n   10-Oct-12    MP      Added extended attach support for serial, per line\r\n                        listener and outgoing connections\r\n   17-Jan-11    MP      Added buffered line capabilities\r\n   20-Nov-08    RMS     Added three new standardized SHOW routines\r\n   07-Oct-08    JDB     Added serial port support to TMXR, TMLN\r\n   27-May-08    JDB     Added lnorder to TMXR structure,\r\n                        added tmxr_set_lnorder and tmxr_set_lnorder\r\n   14-May-08    JDB     Added dptr to TMXR structure\r\n   04-Jan-04    RMS     Changed TMXR ldsc to be pointer to linedesc array\r\n                        Added tmxr_linemsg, logging (from Mark Pizzolato)\r\n   29-Dec-03    RMS     Added output stall support, increased buffer size\r\n   22-Dec-02    RMS     Added break support (from Mark Pizzolato)\r\n   20-Aug-02    RMS     Added tmxr_open_master, tmxr_close_master, tmxr.port\r\n   30-Dec-01    RMS     Renamed tmxr_fstatus, added tmxr_fstats\r\n   20-Oct-01    RMS     Removed tmxr_getchar, formalized buffer guard,\r\n                        added tmxr_rqln, tmxr_tqln\r\n*/\r\n\r\n#ifndef SIM_TMXR_H_\r\n#define SIM_TMXR_H_    0\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifndef SIMH_SERHANDLE_DEFINED\r\n#define SIMH_SERHANDLE_DEFINED 0\r\ntypedef struct SERPORT *SERHANDLE;\r\n#endif\r\n\r\n#include \"sim_defs.h\"\r\n#include \"sim_sock.h\"\r\n\r\n#define TMXR_V_VALID    15\r\n#define TMXR_VALID      (1 << TMXR_V_VALID)\r\n#define TMXR_MAXBUF     256                             /* buffer size */\r\n\r\n#define TMXR_DTR_DROP_TIME 500                          /* milliseconds to drop DTR for 'pseudo' modem control */\r\n#define TMXR_MODEM_RING_TIME 3                          /* seconds to wait for DTR for incoming connections */\r\n#define TMXR_DEFAULT_CONNECT_POLL_INTERVAL 1            /* seconds between connection polls */\r\n\r\n#define TMXR_DBG_XMT    0x00100000                       /* Debug Transmit Data */\r\n#define TMXR_DBG_RCV    0x00200000                       /* Debug Received Data */\r\n#define TMXR_DBG_RET    0x00400000                       /* Debug Returned Received Data */\r\n#define TMXR_DBG_MDM    0x00800000                       /* Debug Modem Signals */\r\n#define TMXR_DBG_CFG    0x01000000                       /* Debug Line Configuration Activities */\r\n#define TMXR_DBG_CON    0x02000000                       /* Debug Connection Activities */\r\n#define TMXR_DBG_ASY    0x04000000                       /* Debug Asynchronous Activities - unused */\r\n#define TMXR_DBG_TRC    0x08000000                       /* Debug trace routine calls */\r\n#define TMXR_DBG_PXMT   0x10000000                       /* Debug Transmit Packet Data */\r\n#define TMXR_DBG_PRCV   0x20000000                       /* Debug Received Packet Data */\r\n#define TMXR_DBG_EXP    0x40000000                       /* Debug Expect Activities */\r\n#define TMXR_DBG_SEND   0x80000000                       /* Debug Send Activities */\r\n\r\n/* Modem Control Bits */\r\n\r\n#define TMXR_MDM_DTR        0x01    /* Data Terminal Ready */\r\n#define TMXR_MDM_RTS        0x02    /* Request To Send     */\r\n#define TMXR_MDM_DCD        0x04    /* Data Carrier Detect */\r\n#define TMXR_MDM_RNG        0x08    /* Ring Indicator      */\r\n#define TMXR_MDM_CTS        0x10    /* Clear To Send       */\r\n#define TMXR_MDM_DSR        0x20    /* Data Set Ready      */\r\n#define TMXR_MDM_INCOMING   (TMXR_MDM_DCD|TMXR_MDM_RNG|TMXR_MDM_CTS|TMXR_MDM_DSR)  /* Settable Modem Bits */\r\n#define TMXR_MDM_OUTGOING   (TMXR_MDM_DTR|TMXR_MDM_RTS)  /* Settable Modem Bits */\r\n\r\n/* Receive line speed limits */\r\n\r\n#define TMLN_SPD_50_BPS     200000 /* usec per character */\r\n#define TMLN_SPD_75_BPS     133333 /* usec per character */\r\n#define TMLN_SPD_110_BPS     90909 /* usec per character */\r\n#define TMLN_SPD_134_BPS     74626 /* usec per character */\r\n#define TMLN_SPD_150_BPS     66666 /* usec per character */\r\n#define TMLN_SPD_300_BPS     33333 /* usec per character */\r\n#define TMLN_SPD_600_BPS     16666 /* usec per character */\r\n#define TMLN_SPD_1200_BPS     8333 /* usec per character */\r\n#define TMLN_SPD_1800_BPS     5555 /* usec per character */\r\n#define TMLN_SPD_2000_BPS     5000 /* usec per character */\r\n#define TMLN_SPD_2400_BPS     4166 /* usec per character */\r\n#define TMLN_SPD_3600_BPS     2777 /* usec per character */\r\n#define TMLN_SPD_4800_BPS     2083 /* usec per character */\r\n#define TMLN_SPD_7200_BPS     1388 /* usec per character */\r\n#define TMLN_SPD_9600_BPS     1041 /* usec per character */\r\n#define TMLN_SPD_19200_BPS     520 /* usec per character */\r\n#define TMLN_SPD_25000_BPS     400 /* usec per character */\r\n#define TMLN_SPD_38400_BPS     260 /* usec per character */\r\n#define TMLN_SPD_40000_BPS     250 /* usec per character */\r\n#define TMLN_SPD_50000_BPS     200 /* usec per character */\r\n#define TMLN_SPD_57600_BPS     173 /* usec per character */\r\n#define TMLN_SPD_76800_BPS     130 /* usec per character */\r\n#define TMLN_SPD_80000_BPS     125 /* usec per character */\r\n#define TMLN_SPD_115200_BPS     86 /* usec per character */\r\n\r\n/* Internal struct */\r\nstruct framer_data;\r\n\r\ntypedef struct tmln TMLN;\r\ntypedef struct tmxr TMXR;\r\nstruct loopbuf {\r\n    int32               bpr;                          /* xmt buf remove */\r\n    int32               bpi;                          /* xmt buf insert */\r\n    int32               size;\r\n    };\r\n\r\nstruct tmln {\r\n    int                 conn;                           /* line connected flag */\r\n    SOCKET              sock;                           /* connection socket */\r\n    char                *ipad;                          /* IP address */\r\n    SOCKET              master;                         /* line specific master socket */\r\n    char                *port;                          /* line specific listening port */\r\n    char                *acl;                           /* Access control list (CIDR) to accept or reject connects from */\r\n    uint32              backlog;                        /* line specific listening backlog */\r\n    int32               acl_accepted_sessions;          /* count of ACL accepted tcp connections */\r\n    int32               acl_rejected_sessions;          /* count of ACL rejected tcp connections */\r\n    int32               sessions;                       /* count of tcp connections received */\r\n    uint32              cnms;                           /* conn time */\r\n    int32               tsta;                           /* Telnet state */\r\n    int32               rcve;                           /* rcv enable */\r\n    int32               xmte;                           /* xmt enable */\r\n    int32               dstb;                           /* disable Telnet binary mode */\r\n    t_bool              notelnet;                       /* raw binary data (no telnet interpretation) */\r\n    t_bool              nomessage;                      /* no connect/disconnect message on line even if telnet */\r\n    uint8               *telnet_sent_opts;              /* Telnet Options which we have sent a DON'T/WON'T */\r\n    int32               rxbpr;                          /* rcv buf remove */\r\n    int32               rxbpi;                          /* rcv buf insert */\r\n    int32               rxbsz;                          /* rcv buffer size */\r\n    int32               rxcnt;                          /* rcv count */\r\n    int32               rxpcnt;                         /* rcv packet count */\r\n    int32               txbpr;                          /* xmt buf remove */\r\n    int32               txbpi;                          /* xmt buf insert */\r\n    int32               txcnt;                          /* xmt count */\r\n    int32               txpcnt;                         /* xmt packet count */\r\n    int32               txdrp;                          /* xmt drop count */\r\n    int32               txstall;                        /* xmt stall count */\r\n    int32               txbsz;                          /* xmt buffer size */\r\n    int32               txbfd;                          /* xmt buffered flag */\r\n    t_bool              modem_control;                  /* line supports modem control behaviors */\r\n    t_bool              port_speed_control;             /* line programmatically sets port speed */\r\n    int32               modembits;                      /* modem bits which are currently set */\r\n    FILE                *txlog;                         /* xmt log file */\r\n    FILEREF             *txlogref;                      /* xmt log file reference */\r\n    char                *txlogname;                     /* xmt log file name */\r\n    char                *rxb;                           /* rcv buffer */\r\n    char                *rbr;                           /* rcv break */\r\n    char                *txb;                           /* xmt buffer */\r\n    uint8               *rxpb;                          /* rcv packet buffer */\r\n    uint32              rxpbsize;                       /* rcv packet buffer size */\r\n    uint32              rxpboffset;                     /* rcv packet buffer offset */\r\n    uint32              rxbps;                          /* rcv bps speed (0 - unlimited) */\r\n    double              bpsfactor;                      /* receive speed factor (scaled to usecs) */\r\n#define USECS_PER_SECOND 1000000.0\r\n    uint32              rxdeltausecs;                   /* rcv inter character min time (usecs) */\r\n    double              rxnexttime;                     /* min time for next receive character */\r\n    uint32              txbps;                          /* xmt bps speed (0 - unlimited) */\r\n    uint32              txdeltausecs;                   /* xmt inter character min time (usecs) */\r\n    double              txnexttime;                     /* min time for next transmit character */\r\n    t_bool              txdone;                         /* sent data complete indicator - private */\r\n    uint8               *txpb;                          /* xmt packet buffer */\r\n    uint32              txpbsize;                       /* xmt packet buffer size */\r\n    uint32              txppsize;                       /* xmt packet packet size */\r\n    uint32              txppoffset;                     /* xmt packet buffer offset */\r\n    TMXR                *mp;                            /* back pointer to mux */\r\n    char                *serconfig;                     /* line config */\r\n    SERHANDLE           serport;                        /* serial port handle */\r\n    t_bool              ser_connect_pending;            /* serial connection notice pending */\r\n    SOCKET              connecting;                     /* Outgoing socket while connecting */\r\n    char                *destination;                   /* Outgoing destination address:port */\r\n    t_bool              loopback;                       /* Line in loopback mode */\r\n    t_bool              halfduplex;                     /* Line in half-duplex mode */\r\n    t_bool              datagram;                       /* Line is datagram packet oriented */\r\n    t_bool              packet;                         /* Line is packet oriented */\r\n    int32               lpbpr;                          /* loopback buf remove */\r\n    int32               lpbpi;                          /* loopback buf insert */\r\n    int32               lpbcnt;                         /* loopback buf used count */\r\n    int32               lpbsz;                          /* loopback buffer size */\r\n    char                *lpb;                           /* loopback buffer */\r\n    UNIT                *uptr;                          /* input polling unit (default to mp->uptr) */\r\n    UNIT                *o_uptr;                        /* output polling unit (default to lp->uptr)*/\r\n    DEVICE              *dptr;                          /* line specific device */\r\n    EXPECT              *expect;                        /* Expect rules */\r\n    SEND                *send;                          /* Send input state */\r\n    struct framer_data  *framer;                        /* ddcmp framer data */\r\n    };\r\n\r\nstruct tmxr {\r\n    int32               lines;                          /* # lines */\r\n    char                *port;                          /* listening port */\r\n    SOCKET              master;                         /* master socket */\r\n    TMLN                *ldsc;                          /* line descriptors */\r\n    int32               *lnorder;                       /* line connection order */\r\n    DEVICE              *dptr;                          /* multiplexer device */\r\n    char                *acl;                           /* Access control list (CIDR) to accept or reject connects from */\r\n    int32               acl_accepted_sessions;          /* count of ACL accepted tcp connections */\r\n    int32               acl_rejected_sessions;          /* count of ACL rejected tcp connections */\r\n    uint32              backlog;                        /* listen backlog */\r\n    UNIT                *uptr;                          /* polling unit (connection) */\r\n    char                logfiletmpl[FILENAME_MAX];      /* template logfile name */\r\n    int32               txcount;                        /* count of transmit bytes */\r\n    int32               buffered;                       /* Buffered Line Behavior and Buffer Size Flag */\r\n    int32               sessions;                       /* count of tcp connections received */\r\n    uint32              poll_interval;                  /* frequency of connection polls (seconds) */\r\n    uint32              last_poll_time;                 /* time of last connection poll */\r\n    uint32              ring_start_time;                /* time ring signal was raised */\r\n    char                *ring_ipad;                     /* incoming connection address awaiting DTR */\r\n    SOCKET              ring_sock;                      /* incoming connection socket awaiting DTR */\r\n    t_bool              notelnet;                       /* default telnet capability for incoming connections */\r\n    t_bool              nomessage;                      /* no connect/disconnect message on line even if telnet */\r\n    t_bool              modem_control;                  /* multiplexer supports modem control behaviors */\r\n    t_bool              port_speed_control;             /* multiplexer programmatically sets port speed */\r\n    t_bool              packet;                         /* Lines are packet oriented */\r\n    t_bool              datagram;                       /* Lines use datagram packet transport */\r\n    };\r\n\r\nint32 tmxr_poll_conn (TMXR *mp);\r\nt_stat tmxr_reset_ln (TMLN *lp);\r\nt_stat tmxr_detach_ln (TMLN *lp);\r\nint32 tmxr_input_pending_ln (TMLN *lp);\r\nint32 tmxr_getc_ln (TMLN *lp);\r\nt_stat tmxr_get_packet_ln (TMLN *lp, const uint8 **pbuf, size_t *psize);\r\nt_stat tmxr_get_packet_ln_ex (TMLN *lp, const uint8 **pbuf, size_t *psize, uint8 frame_byte);\r\nvoid tmxr_poll_rx (TMXR *mp);\r\nt_stat tmxr_putc_ln (TMLN *lp, int32 chr);\r\nt_stat tmxr_put_packet_ln (TMLN *lp, const uint8 *buf, size_t size);\r\nt_stat tmxr_put_packet_ln_ex (TMLN *lp, const uint8 *buf, size_t size, uint8 frame_byte);\r\nvoid tmxr_poll_tx (TMXR *mp);\r\nint32 tmxr_send_buffered_data (TMLN *lp);\r\nt_stat tmxr_open_master (TMXR *mp, CONST char *cptr);\r\nt_stat tmxr_close_master (TMXR *mp);\r\nt_stat tmxr_connection_poll_interval (TMXR *mp, uint32 seconds);\r\nt_stat tmxr_attach (TMXR *mp, UNIT *uptr, CONST char *cptr);\r\n#define tmxr_attach_ex(mp, uptr, cptr, async) tmxr_attach (mp, uptr, cptr)\r\nt_stat tmxr_detach (TMXR *mp, UNIT *uptr);\r\nt_stat tmxr_attach_help(FILE *st, DEVICE *dptr, UNIT *uptr, int32 flag, const char *cptr);\r\nchar *tmxr_line_attach_string(TMLN *lp);\r\nt_stat tmxr_set_modem_control_passthru (TMXR *mp);\r\nt_stat tmxr_clear_modem_control_passthru (TMXR *mp);\r\nt_stat tmxr_set_notelnet (TMXR *mp);\r\nt_stat tmxr_clear_notelnet (TMXR *mp);\r\nt_stat tmxr_set_nomessage (TMXR *mp);\r\nt_stat tmxr_clear_nomessage (TMXR *mp);\r\nt_stat tmxr_set_port_speed_control (TMXR *mp);\r\nt_stat tmxr_clear_port_speed_control (TMXR *mp);\r\nt_stat tmxr_set_backlog (TMXR *mp, int32 backlog);\r\nt_stat tmxr_set_line_port_speed_control (TMXR *mp, int line);\r\nt_stat tmxr_clear_line_port_speed_control (TMXR *mp, int line);\r\nt_stat tmxr_set_get_modem_bits (TMLN *lp, int32 bits_to_set, int32 bits_to_clear, int32 *incoming_bits);\r\nt_stat tmxr_set_line_loopback (TMLN *lp, t_bool enable_loopback);\r\nt_bool tmxr_get_line_loopback (TMLN *lp);\r\nt_stat tmxr_set_line_halfduplex (TMLN *lp, t_bool enable_loopback);\r\nt_bool tmxr_get_line_halfduplex (TMLN *lp);\r\nt_stat tmxr_set_line_speed (TMLN *lp, CONST char *speed);\r\nt_stat tmxr_set_config_line (TMLN *lp, CONST char *config);\r\nt_stat tmxr_set_line_modem_control (TMLN *lp, t_bool enab_disab);\r\nt_stat tmxr_set_line_unit (TMXR *mp, int line, UNIT *uptr_poll);\r\nt_stat tmxr_set_line_output_unit (TMXR *mp, int line, UNIT *uptr_poll);\r\nt_stat tmxr_set_console_units (UNIT *rxuptr, UNIT *txuptr);\r\nt_stat tmxr_ex (t_value *vptr, t_addr addr, UNIT *uptr, int32 sw);\r\nt_stat tmxr_dep (t_value val, t_addr addr, UNIT *uptr, int32 sw);\r\nvoid tmxr_msg (SOCKET sock, const char *msg);\r\nvoid tmxr_linemsg (TMLN *lp, const char *msg);\r\nvoid tmxr_linemsgf (TMLN *lp, const char *fmt, ...);\r\nvoid tmxr_linemsgvf (TMLN *lp, const char *fmt, va_list args);\r\nvoid tmxr_fconns (FILE *st, const TMLN *lp, int32 ln);\r\nvoid tmxr_fstats (FILE *st, const TMLN *lp, int32 ln);\r\nt_stat tmxr_set_log (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat tmxr_set_nolog (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat tmxr_show_log (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat tmxr_dscln (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nint32 tmxr_rqln (const TMLN *lp);\r\nint32 tmxr_tqln (const TMLN *lp);\r\nint32 tmxr_tpqln (const TMLN *lp);\r\nint32 tmxr_txdone_ln (TMLN *lp);\r\nt_bool tmxr_tpbusyln (const TMLN *lp);\r\nt_stat tmxr_set_lnorder (UNIT *uptr, int32 val, CONST char *cptr, void *desc);\r\nt_stat tmxr_show_lnorder (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat tmxr_show_summ (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat tmxr_show_cstat (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat tmxr_show_lines (FILE *st, UNIT *uptr, int32 val, CONST void *desc);\r\nt_stat tmxr_show_open_devices (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char* desc);\r\nt_stat tmxr_show_sync_devices (FILE* st, DEVICE *dptr, UNIT* uptr, int32 val, CONST char *desc);\r\nt_stat tmxr_show_sync (FILE* st, UNIT* uptr, int32 val, CONST void *desc);\r\nt_stat tmxr_flush_log_files (void);\r\nt_stat tmxr_activate (UNIT *uptr, int32 interval);\r\nt_stat tmxr_activate_abs (UNIT *uptr, int32 interval);\r\nt_stat tmxr_activate_after (UNIT *uptr, uint32 usecs_walltime);\r\nt_stat tmxr_activate_after_abs (UNIT *uptr, uint32 usecs_walltime);\r\nt_stat tmxr_clock_coschedule (UNIT *uptr, int32 interval);\r\nt_stat tmxr_clock_coschedule_abs (UNIT *uptr, int32 interval);\r\nt_stat tmxr_clock_coschedule_tmr (UNIT *uptr, int32 tmr, int32 ticks);\r\nt_stat tmxr_clock_coschedule_tmr_abs (UNIT *uptr, int32 tmr, int32 ticks);\r\nt_stat tmxr_locate_line_send (const char *dev_line, SEND **snd);\r\nt_stat tmxr_locate_line_expect (const char *dev_line, EXPECT **exp);\r\nt_stat tmxr_locate_line (const char *dev_line, TMLN **lp);\r\nconst char *tmxr_send_line_name (const SEND *snd);\r\nconst char *tmxr_expect_line_name (const EXPECT *exp);\r\nt_stat tmxr_startup (void);\r\nt_stat tmxr_shutdown (void);\r\nt_stat tmxr_sock_test (DEVICE *dptr, const char *cptr);\r\n/* Framer support.  These are a NOP if called on a non-framer line. */\r\nvoid tmxr_start_framer (TMLN *line, int dmc_mode);\r\nvoid tmxr_stop_framer (TMLN *line);\r\n\r\nvoid _tmxr_debug (uint32 dbits, TMLN *lp, const char *msg, char *buf, int bufsize);\r\n#define tmxr_debug(dbits, lp, msg, buf, bufsize) do {if (sim_deb && (lp)->mp && (lp)->mp->dptr && ((dbits) & (lp)->mp->dptr->dctrl)) _tmxr_debug (dbits, lp, msg, buf, bufsize); } while (0)\r\n#define tmxr_debug_msg(dbits, lp, msg) do {if (sim_deb && (lp)->mp && (lp)->mp->dptr && ((dbits) & (lp)->mp->dptr->dctrl)) sim_debug (dbits, (lp)->mp->dptr, \"%s\", msg); } while (0)\r\n#define tmxr_debug_return(lp, val) do {if (sim_deb && (val) && (lp)->mp && (lp)->mp->dptr && (TMXR_DBG_RET & (lp)->mp->dptr->dctrl)) { if ((lp)->rxbps) sim_debug (TMXR_DBG_RET, (lp)->mp->dptr, \"Ln%d: 0x%x - Next after: %.0f\\n\", (int)((lp)-(lp)->mp->ldsc), val, (lp)->rxnexttime); else sim_debug (TMXR_DBG_RET, (lp)->mp->dptr, \"Ln%d: 0x%x\\n\", (int)((lp)-(lp)->mp->ldsc), val); } } while (0)\r\n#define tmxr_debug_trace(mp, msg) do {if (sim_deb && (mp)->dptr && (TMXR_DBG_TRC & (mp)->dptr->dctrl)) sim_debug (TMXR_DBG_TRC, mp->dptr, \"%s\\n\", (msg)); } while (0)\r\n#define tmxr_debug_trace_line(lp, msg) do {if (sim_deb && (lp)->mp && (lp)->mp->dptr && (TMXR_DBG_TRC & (lp)->mp->dptr->dctrl)) sim_debug (TMXR_DBG_TRC, (lp)->mp->dptr, \"Ln%d:%s\\n\", (int)((lp)-(lp)->mp->ldsc), (msg)); } while (0)\r\n#define tmxr_debug_connect(mp, msg) do {if (sim_deb && (mp)->dptr && (TMXR_DBG_CON & (mp)->dptr->dctrl)) sim_debug (TMXR_DBG_CON, mp->dptr, \"%s\\n\", (msg)); } while (0)\r\n#define tmxr_debug_connect_line(lp, msg) do {if (sim_deb && (lp)->mp && (lp)->mp->dptr && (TMXR_DBG_CON & (lp)->mp->dptr->dctrl)) sim_debug (TMXR_DBG_CON, (lp)->mp->dptr, \"Ln%d:%s\\n\", (int)((lp)-(lp)->mp->ldsc), (msg)); } while (0)\r\nt_stat tmxr_add_debug (DEVICE *dptr);\r\n\r\n#if (!defined(NOT_MUX_USING_CODE))\r\n#define sim_activate tmxr_activate\r\n#define sim_activate_abs tmxr_activate_abs\r\n#define sim_activate_after tmxr_activate_after\r\n#define sim_activate_after_abs tmxr_activate_after_abs\r\n#define sim_clock_coschedule tmxr_clock_coschedule\r\n#define sim_clock_coschedule_abs tmxr_clock_coschedule_abs\r\n#define sim_clock_coschedule_tmr tmxr_clock_coschedule_tmr\r\n#define sim_clock_coschedule_tmr_abs tmxr_clock_coschedule_tmr_abs\r\n#endif\r\n\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* _SIM_TMXR_H_ */\r\n"
        },
        {
          "name": "sim_video.c",
          "type": "blob",
          "size": 103.478515625,
          "content": "/* sim_video.c: Bitmap video output\r\n\r\n   Copyright (c) 2011-2013, Matt Burke\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n\r\n   08-Nov-2013  MB      Added globals for current mouse status\r\n   11-Jun-2013  MB      First version\r\n*/\r\n\r\n#if defined(HAVE_LIBPNG) && defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL)\r\n/*\r\n    png.h is included here (before sim_video.h) since some older\r\n    versions of png.h report errors when included after setjmp.h\r\n    which is included in sim_defs.h.\r\n*/\r\n#include <png.h>\r\n#if defined(HAVE_ZLIB)\r\n#include <zlib.h>\r\n#endif\r\n#endif\r\n\r\n#include \"sim_video.h\"\r\n#include \"scp.h\"\r\n\r\n#include \"sim_scp_private.h\"\r\n\r\nint vid_active = 0;\r\nint32 vid_cursor_x;\r\nint32 vid_cursor_y;\r\nt_bool vid_mouse_b1 = FALSE;\r\nt_bool vid_mouse_b2 = FALSE;\r\nt_bool vid_mouse_b3 = FALSE;\r\nstatic VID_QUIT_CALLBACK vid_quit_callback = NULL;\r\nstatic VID_GAMEPAD_CALLBACK motion_callback[10];\r\nstatic VID_GAMEPAD_CALLBACK button_callback[10];\r\nstatic int vid_gamepad_inited = 0;\r\nstatic t_bool sim_libpng_available = FALSE;\r\n\r\nt_stat vid_register_quit_callback (VID_QUIT_CALLBACK callback)\r\n{\r\nvid_quit_callback = callback;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat register_callback (void **array, int n, void *callback)\r\n{\r\n    int i, j = -1;\r\n\r\n    if (!vid_gamepad_inited) {\r\n        return SCPE_NOATT;\r\n        }\r\n\r\n    for (i = 0; i < n; i++) {\r\n        if (array[i] == callback)\r\n            return SCPE_ALATT;\r\n        if (array[i] == NULL)\r\n            j = i;\r\n        }\r\n\r\n    if (j != -1) {\r\n        array[j] = callback;\r\n        return SCPE_OK;\r\n        }\r\n\r\n    return SCPE_NXM;\r\n}\r\n\r\nt_stat vid_register_gamepad_motion_callback (VID_GAMEPAD_CALLBACK callback)\r\n{\r\n    int n = sizeof (motion_callback) / sizeof (callback);\r\n    return register_callback ((void **)motion_callback, n, (void *)callback);\r\n}\r\n\r\nt_stat vid_register_gamepad_button_callback (VID_GAMEPAD_CALLBACK callback)\r\n{\r\n    int n = sizeof (button_callback) / sizeof (callback);\r\n    return register_callback ((void **)button_callback, n, (void *)callback);\r\n}\r\n\r\nt_stat vid_show (FILE* st, DEVICE *dptr,  UNIT* uptr, int32 val, CONST char* desc)\r\n{\r\nreturn vid_show_video (st, uptr, val, desc);\r\n}\r\n\r\n#if defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL)\r\n\r\nstatic const char *vid_dname (DEVICE *dev)\r\n{\r\nreturn dev ? sim_dname(dev) : \"Video Device\";\r\n}\r\n\r\nstatic int vid_gamepad_ok = 0; /* Or else just joysticks. */\r\n\r\nchar vid_release_key[64] = \"Ctrl-Right-Shift\";\r\n\r\n#if defined(__APPLE__)\r\n#define SDL_MAIN_AVAILABLE\r\n#endif\r\n\r\n#include <SDL.h>\r\n#include <SDL_thread.h>\r\n\r\nstatic const char *key_names[] =\r\n    {\"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"F10\", \"F11\", \"F12\",\r\n     \"0\",   \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",\r\n     \"A\",   \"B\",  \"C\",  \"D\",  \"E\",  \"F\",  \"G\",  \"H\",  \"I\",  \"J\",\r\n     \"K\",   \"L\",  \"M\",  \"N\",  \"O\",  \"P\",  \"Q\",  \"R\",  \"S\",  \"T\",\r\n     \"U\",   \"V\",  \"W\",  \"X\",  \"Y\",  \"Z\",\r\n     \"BACKQUOTE\",   \"MINUS\",   \"EQUALS\", \"LEFT_BRACKET\", \"RIGHT_BRACKET\",\r\n     \"SEMICOLON\", \"SINGLE_QUOTE\", \"BACKSLASH\", \"LEFT_BACKSLASH\", \"COMMA\",\r\n     \"PERIOD\", \"SLASH\", \"PRINT\", \"SCRL_LOCK\", \"PAUSE\", \"ESC\", \"BACKSPACE\",\r\n     \"TAB\", \"ENTER\", \"SPACE\", \"INSERT\", \"DELETE\", \"HOME\", \"END\", \"PAGE_UP\",\r\n     \"PAGE_DOWN\", \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\", \"CAPS_LOCK\", \"NUM_LOCK\",\r\n     \"ALT_L\", \"ALT_R\", \"CTRL_L\", \"CTRL_R\", \"SHIFT_L\", \"SHIFT_R\",\r\n     \"WIN_L\", \"WIN_R\", \"MENU\", \"KP_ADD\", \"KP_SUBTRACT\", \"KP_END\", \"KP_DOWN\",\r\n     \"KP_PAGE_DOWN\", \"KP_LEFT\", \"KP_RIGHT\", \"KP_HOME\", \"KP_UP\", \"KP_PAGE_UP\",\r\n     \"KP_INSERT\", \"KP_DELETE\", \"KP_5\", \"KP_ENTER\", \"KP_MULTIPLY\", \"KP_DIVIDE\"\r\n     };\r\n\r\nconst char *vid_key_name (uint32 key)\r\n{\r\nstatic char tmp_key_name[40];\r\n\r\n    if (key < sizeof(key_names)/sizeof(key_names[0]))\r\n        sprintf (tmp_key_name, \"SIM_KEY_%s\", key_names[key]);\r\n    else\r\n        sprintf (tmp_key_name, \"UNKNOWN KEY: %d\", key);\r\n    return tmp_key_name;\r\n}\r\n\r\n#if defined(HAVE_LIBPNG)\r\n/* From: https://github.com/driedfruit/SDL_SavePNG */\r\n\r\n/*\r\n * Save an SDL_Surface as a PNG file.\r\n *\r\n * Returns 0 success or -1 on failure, the error message is then retrievable\r\n * via SDL_GetError().\r\n */\r\n#define SDL_SavePNG(surface, file) \\\r\n        SDL_SavePNG_RW(surface, SDL_RWFromFile(file, \"wb\"), 1)\r\n\r\n/*\r\n * SDL_SavePNG -- libpng-based SDL_Surface writer.\r\n *\r\n * This code is free software, available under zlib/libpng license.\r\n * http://www.libpng.org/pub/png/src/libpng-LICENSE.txt\r\n * This code has been slightly modified to leverage indirect pointers\r\n * to the various png routines.\r\n */\r\n#include <SDL.h>\r\n\r\n#define SUCCESS 0\r\n#define ERROR -1\r\n\r\n#define USE_ROW_POINTERS\r\n\r\n#if SDL_BYTEORDER == SDL_BIG_ENDIAN\r\n#define rmask 0xFF000000\r\n#define gmask 0x00FF0000\r\n#define bmask 0x0000FF00\r\n#define amask 0x000000FF\r\n#else\r\n#define rmask 0x000000FF\r\n#define gmask 0x0000FF00\r\n#define bmask 0x00FF0000\r\n#define amask 0xFF000000\r\n#endif\r\n\r\n/* libpng callbacks */\r\nstatic void png_error_SDL(png_structp ctx, png_const_charp str)\r\n{\r\n    SDL_SetError(\"libpng: %s\\n\", str);\r\n}\r\nstatic void png_write_SDL(png_structp png_ptr, png_bytep data, png_size_t length)\r\n{\r\n    SDL_RWops *rw = (SDL_RWops*)p_png_get_io_ptr(png_ptr);\r\n    SDL_RWwrite(rw, data, sizeof(png_byte), length);\r\n}\r\n\r\nstatic SDL_Surface *SDL_PNGFormatAlpha(SDL_Surface *src)\r\n{\r\n    SDL_Surface *surf;\r\n    SDL_Rect rect = { 0 };\r\n\r\n    /* NO-OP for images < 32bpp and 32bpp images that already have Alpha channel */\r\n    if (src->format->BitsPerPixel <= 24 || src->format->Amask) {\r\n        src->refcount++;\r\n        return src;\r\n    }\r\n\r\n    /* Convert 32bpp alpha-less image to 24bpp alpha-less image */\r\n    rect.w = src->w;\r\n    rect.h = src->h;\r\n    surf = SDL_CreateRGBSurface(src->flags, src->w, src->h, 24,\r\n        src->format->Rmask, src->format->Gmask, src->format->Bmask, 0);\r\n    SDL_LowerBlit(src, &rect, surf, &rect);\r\n\r\n    return surf;\r\n}\r\n\r\nstatic int SDL_SavePNG_RW(SDL_Surface *surface, SDL_RWops *dst, int freedst)\r\n{\r\n    png_structp png_ptr;\r\n    png_infop info_ptr;\r\n    png_colorp pal_ptr;\r\n    SDL_Palette *pal;\r\n    int i, colortype;\r\n#ifdef USE_ROW_POINTERS\r\n    png_bytep *row_pointers;\r\n#endif\r\n    /* Initialize and do basic error checking */\r\n    if (!dst)\r\n    {\r\n        SDL_SetError(\"Argument 2 to SDL_SavePNG_RW can't be NULL, expecting SDL_RWops*\\n\");\r\n        return (ERROR);\r\n    }\r\n    if (!surface)\r\n    {\r\n        SDL_SetError(\"Argument 1 to SDL_SavePNG_RW can't be NULL, expecting SDL_Surface*\\n\");\r\n        if (freedst) SDL_RWclose(dst);\r\n        return (ERROR);\r\n    }\r\n    png_ptr = p_png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, png_error_SDL, NULL); /* err_ptr, err_fn, warn_fn */\r\n    if (!png_ptr)\r\n    {\r\n        SDL_SetError(\"Unable to png_create_write_struct on %s\\n\", PNG_LIBPNG_VER_STRING);\r\n        if (freedst) SDL_RWclose(dst);\r\n        return (ERROR);\r\n    }\r\n    info_ptr = p_png_create_info_struct(png_ptr);\r\n    if (!info_ptr)\r\n    {\r\n        SDL_SetError(\"Unable to png_create_info_struct\\n\");\r\n        p_png_destroy_write_struct(&png_ptr, NULL);\r\n        if (freedst) SDL_RWclose(dst);\r\n        return (ERROR);\r\n    }\r\n#if defined(PNG_SETJMP_SUPPORTED)\r\n    if (setjmp(*p_png_set_longjmp_fn(png_ptr, longjmp, sizeof (jmp_buf))))    /* All other errors, see also \"png_error_SDL\" */\r\n    {\r\n        p_png_destroy_write_struct(&png_ptr, &info_ptr);\r\n        if (freedst) SDL_RWclose(dst);\r\n        return (ERROR);\r\n    }\r\n#endif\r\n    /* Setup our RWops writer */\r\n    p_png_set_write_fn(png_ptr, dst, png_write_SDL, NULL); /* w_ptr, write_fn, flush_fn */\r\n\r\n    /* Prepare chunks */\r\n    colortype = PNG_COLOR_MASK_COLOR;\r\n    if (surface->format->BytesPerPixel > 0\r\n    &&  surface->format->BytesPerPixel <= 8\r\n    && (pal = surface->format->palette))\r\n    {\r\n        colortype |= PNG_COLOR_MASK_PALETTE;\r\n        pal_ptr = (png_colorp)malloc(pal->ncolors * sizeof(png_color));\r\n        for (i = 0; i < pal->ncolors; i++) {\r\n            pal_ptr[i].red   = pal->colors[i].r;\r\n            pal_ptr[i].green = pal->colors[i].g;\r\n            pal_ptr[i].blue  = pal->colors[i].b;\r\n        }\r\n        p_png_set_PLTE(png_ptr, info_ptr, pal_ptr, pal->ncolors);\r\n        free(pal_ptr);\r\n    }\r\n    else if (surface->format->BytesPerPixel > 3 || surface->format->Amask)\r\n        colortype |= PNG_COLOR_MASK_ALPHA;\r\n\r\n    p_png_set_IHDR(png_ptr, info_ptr, surface->w, surface->h, 8, colortype,\r\n        PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\r\n\r\n//    png_set_packing(png_ptr);\r\n\r\n    /* Allow BGR surfaces */\r\n    if (surface->format->Rmask == bmask\r\n    && surface->format->Gmask == gmask\r\n    && surface->format->Bmask == rmask)\r\n        p_png_set_bgr(png_ptr);\r\n\r\n    /* Write everything */\r\n    p_png_write_info(png_ptr, info_ptr);\r\n#ifdef USE_ROW_POINTERS\r\n    row_pointers = (png_bytep*) malloc(sizeof(png_bytep)*surface->h);\r\n    for (i = 0; i < surface->h; i++)\r\n        row_pointers[i] = (png_bytep)(Uint8*)surface->pixels + i * surface->pitch;\r\n    p_png_write_image(png_ptr, row_pointers);\r\n    free(row_pointers);\r\n#else\r\n    for (i = 0; i < surface->h; i++)\r\n        p_png_write_row(png_ptr, (png_bytep)(Uint8*)surface->pixels + i * surface->pitch);\r\n#endif\r\n    p_png_write_end(png_ptr, info_ptr);\r\n\r\n    /* Done */\r\n    p_png_destroy_write_struct(&png_ptr, &info_ptr);\r\n    if (freedst) SDL_RWclose(dst);\r\n    return (SUCCESS);\r\n}\r\n#endif /* defined(HAVE_LIBPNG) */\r\n\r\n/*\r\n    Some platforms (OS X), require that ALL input event processing be\r\n    performed by the main thread of the process.\r\n\r\n    To satisfy this requirement, we leverage the SDL_MAIN functionality\r\n    which does:\r\n\r\n             #defines main SDL_main\r\n\r\n     and we define the main() entry point here.  Locally, we run the\r\n     application's SDL_main in a separate thread, and while that thread\r\n     is running, the main thread performs event handling and dispatch.\r\n\r\n */\r\n\r\n#define EVENT_REDRAW      1                              /* redraw event for SDL */\r\n#define EVENT_CLOSE       2                              /* close event for SDL */\r\n#define EVENT_CURSOR      3                              /* new cursor for SDL */\r\n#define EVENT_WARP        4                              /* warp mouse position for SDL */\r\n#define EVENT_DRAW        5                              /* draw/blit region for SDL */\r\n#define EVENT_SHOW        6                              /* show SDL capabilities */\r\n#define EVENT_OPEN        7                              /* vid_open request */\r\n#define EVENT_EXIT        8                              /* program exit */\r\n#define EVENT_SCREENSHOT  9                              /* produce screenshot of video window */\r\n#define EVENT_BEEP       10                              /* audio beep */\r\n#define EVENT_FULLSCREEN 11                              /* fullscreen */\r\n#define EVENT_SIZE       12                              /* set window size */\r\n#define EVENT_LOGICAL    13                              /* set window logical size */\r\n#define MAX_EVENTS       20                              /* max events in queue */\r\n\r\ntypedef struct {\r\n    SIM_KEY_EVENT events[MAX_EVENTS];\r\n    SDL_sem *sem;\r\n    int32 head;\r\n    int32 tail;\r\n    int32 count;\r\n    } KEY_EVENT_QUEUE;\r\n\r\ntypedef struct {\r\n    SIM_MOUSE_EVENT events[MAX_EVENTS];\r\n    SDL_sem *sem;\r\n    int32 head;\r\n    int32 tail;\r\n    int32 count;\r\n    } MOUSE_EVENT_QUEUE;\r\n\r\nint vid_thread (void* arg);\r\nint vid_video_events (VID_DISPLAY *vptr);\r\nvoid vid_show_video_event (void);\r\nvoid vid_screenshot_event (void);\r\nvoid vid_beep_event (void);\r\nstatic void vid_beep_setup (int duration_ms, int tone_frequency);\r\nstatic void vid_beep_cleanup (void);\r\nstatic void vid_controllers_setup (DEVICE *dptr);\r\nstatic void vid_controllers_cleanup (void);\r\n\r\nstruct VID_DISPLAY {\r\nt_bool vid_active_window;\r\nt_bool vid_mouse_captured;\r\nint32 vid_flags;                                        /* Open Flags */\r\nint32 vid_width;\r\nint32 vid_height;\r\nt_bool vid_ready;\r\nchar vid_title[128];\r\nSDL_Texture *vid_texture;                               /* video buffer in GPU */\r\nSDL_Renderer *vid_renderer;\r\nSDL_Window *vid_window;                                 /* window handle */\r\nSDL_PixelFormat *vid_format;\r\nuint32 vid_windowID;\r\nSDL_mutex *vid_draw_mutex;                              /* window update mutex */\r\nSDL_Cursor *vid_cursor;                                 /* current cursor */\r\nt_bool vid_cursor_visible;                              /* cursor visibility state */\r\nDEVICE *vid_dev;\r\nt_bool vid_key_state[SDL_NUM_SCANCODES];\r\nVID_DISPLAY *next;\r\nt_bool vid_blending;\r\nSDL_Rect *vid_dst_last;\r\nSDL_Rect vid_rect;\r\nuint32 *vid_data_last;\r\n};\r\n\r\nSDL_Thread *vid_thread_handle = NULL;                   /* event thread handle */\r\n\r\nstatic VID_DISPLAY vid_first;\r\n\r\nKEY_EVENT_QUEUE vid_key_events;                         /* keyboard events */\r\nMOUSE_EVENT_QUEUE vid_mouse_events;                     /* mouse events */\r\n\r\nstatic VID_DISPLAY *vid_get_event_window (SDL_Event *ev, Uint32 windowID)\r\n{\r\nstatic Uint32 lastID = 0xffffffff;\r\nstatic VID_DISPLAY *last_display = NULL;\r\nVID_DISPLAY *vptr;\r\nSDL_KeyboardEvent *kev;\r\nSDL_MouseButtonEvent *bev;\r\nSDL_MouseMotionEvent *mev;\r\nSDL_WindowEvent *wev;\r\nSDL_UserEvent *uev;\r\nSDL_version ver;\r\n\r\nif (windowID == lastID)\r\n    return last_display;\r\n\r\nfor (vptr = &vid_first; vptr != NULL; vptr = vptr->next) {\r\n    if (windowID == vptr->vid_windowID) {\r\n        lastID = windowID;\r\n        return last_display = vptr;\r\n        }\r\n    }\r\n\r\nswitch (ev->type) {\r\n    case SDL_KEYDOWN:\r\n    case SDL_KEYUP:\r\n        kev = (SDL_KeyboardEvent *)ev;\r\n        sim_messagef (SCPE_OK, \"Unrecognized key event.\\n\");\r\n        sim_messagef (SCPE_OK, \"  type = %u\\n\", kev->type);\r\n        sim_messagef (SCPE_OK, \"  timestamp = %u\\n\", kev->timestamp);\r\n        sim_messagef (SCPE_OK, \"  windowID = %u\\n\", kev->windowID);\r\n        sim_messagef (SCPE_OK, \"  state = %u\\n\", kev->state);\r\n        sim_messagef (SCPE_OK, \"  repeat = %u\\n\", kev->repeat);\r\n        sim_messagef (SCPE_OK, \"  scancode = %d\\n\", kev->keysym.scancode);\r\n        sim_messagef (SCPE_OK, \"  sym = %d\\n\", kev->keysym.sym);\r\n        sim_messagef (SCPE_OK, \"  mod = %u\\n\", kev->keysym.mod);\r\n        break;\r\n    case SDL_MOUSEBUTTONDOWN:\r\n    case SDL_MOUSEBUTTONUP:\r\n        bev = (SDL_MouseButtonEvent *)ev;\r\n        sim_messagef (SCPE_OK, \"Unrecognized mouse button event.\\n\");\r\n        sim_messagef (SCPE_OK, \"  type = %u\\n\", bev->type);\r\n        sim_messagef (SCPE_OK, \"  timestamp = %u\\n\", bev->timestamp);\r\n        sim_messagef (SCPE_OK, \"  windowID = %u\\n\", bev->windowID);\r\n        sim_messagef (SCPE_OK, \"  which = %u\\n\", bev->which);\r\n        sim_messagef (SCPE_OK, \"  button = %u\\n\", bev->button);\r\n        sim_messagef (SCPE_OK, \"  state = %u\\n\", bev->state);\r\n        sim_messagef (SCPE_OK, \"  clicks = %u\\n\", bev->clicks);\r\n        sim_messagef (SCPE_OK, \"  x = %d\\n\", bev->x);\r\n        sim_messagef (SCPE_OK, \"  y = %d\\n\", bev->y);\r\n        break;\r\n    case SDL_MOUSEMOTION:\r\n        mev = (SDL_MouseMotionEvent *)ev;\r\n        sim_messagef (SCPE_OK, \"Unrecognized mouse motion event.\\n\");\r\n        sim_messagef (SCPE_OK, \"  type = %u\\n\", mev->type);\r\n        sim_messagef (SCPE_OK, \"  timestamp = %u\\n\", mev->timestamp);\r\n        sim_messagef (SCPE_OK, \"  windowID = %u\\n\", mev->windowID);\r\n        sim_messagef (SCPE_OK, \"  which = %u\\n\", mev->which);\r\n        sim_messagef (SCPE_OK, \"  state = %u\\n\", mev->state);\r\n        sim_messagef (SCPE_OK, \"  x = %d\\n\", mev->x);\r\n        sim_messagef (SCPE_OK, \"  y = %d\\n\", mev->y);\r\n        sim_messagef (SCPE_OK, \"  xrel = %d\\n\", mev->xrel);\r\n        sim_messagef (SCPE_OK, \"  yrel = %d\\n\", mev->yrel);\r\n        break;\r\n    case SDL_WINDOWEVENT:\r\n        wev = (SDL_WindowEvent *)ev;\r\n        sim_messagef (SCPE_OK, \"Unrecognized window event.\\n\");\r\n        sim_messagef (SCPE_OK, \"  type = %u\\n\", wev->type);\r\n        sim_messagef (SCPE_OK, \"  timestamp = %u\\n\", wev->timestamp);\r\n        sim_messagef (SCPE_OK, \"  windowID = %u\\n\", wev->windowID);\r\n        sim_messagef (SCPE_OK, \"  event = %u\\n\", wev->event);\r\n        sim_messagef (SCPE_OK, \"  data1 = %d\\n\", wev->data1);\r\n        sim_messagef (SCPE_OK, \"  data2 = %d\\n\", wev->data2);\r\n        break;\r\n    case SDL_USEREVENT:\r\n        uev = (SDL_UserEvent *)ev;\r\n        if (uev->code == EVENT_SCREENSHOT)\r\n            return &vid_first;      /* Currently only support screenshot of the first windown */\r\n        sim_messagef (SCPE_OK, \"Unrecognized user event.\\n\");\r\n        sim_messagef (SCPE_OK, \"  type = %u\\n\", uev->type);\r\n        sim_messagef (SCPE_OK, \"  timestamp = %u\\n\", uev->timestamp);\r\n        sim_messagef (SCPE_OK, \"  windowID = %u\\n\", uev->windowID);\r\n        sim_messagef (SCPE_OK, \"  code = %d\\n\", uev->code);\r\n        sim_messagef (SCPE_OK, \"  data1 = %p\\n\", uev->data1);\r\n        sim_messagef (SCPE_OK, \"  data2 = %p\\n\", uev->data2);\r\n        break;\r\n    default:\r\n        sim_messagef (SCPE_OK, \"Unrecognized event type %u\\n\", ev->type);\r\n        break;\r\n    }\r\n\r\nSDL_GetVersion(&ver);\r\n\r\nsim_messagef (SCPE_IERR,\r\n              \"\\nSIMH has encountered a bug in SDL2 (or in SIMH's use of SDL2).\\n\");\r\nsim_messagef (SCPE_IERR,\r\n              \"Create an issue at https://github.com/simh/simh/issues and report\\n\");\r\nsim_messagef (SCPE_IERR,\r\n              \"your simulator setup and the above details\\n\");\r\nreturn NULL;\r\n}\r\n\r\n#if defined (SDL_MAIN_AVAILABLE)\r\n#if defined (main)\r\n#undef main\r\n#endif\r\n\r\nstatic int main_argc;\r\nstatic char **main_argv;\r\nstatic SDL_Thread *vid_main_thread_handle;\r\n\r\nint main_thread (void *arg)\r\n{\r\nSDL_Event user_event;\r\nint stat;\r\n\r\nstat = SDL_main (main_argc, main_argv);\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.code = EVENT_EXIT;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (10);\r\nreturn stat;\r\n}\r\n\r\nint main (int argc, char *argv[])\r\n{\r\nSDL_Event event;\r\nint status;\r\n\r\nmain_argc = argc;\r\nmain_argv = argv;\r\n\r\nSDL_SetHint (SDL_HINT_RENDER_DRIVER, \"software\");\r\nSDL_SetHint (SDL_HINT_VIDEO_ALLOW_SCREENSAVER, \"1\");\r\n\r\nstatus = SDL_Init (SDL_INIT_EVENTS);\r\n\r\nif (status) {\r\n    fprintf (stderr, \"SDL Video subsystem can't initialize: %s\\n\", SDL_GetError ());\r\n    exit (1);\r\n    }\r\n\r\nvid_main_thread_handle = SDL_CreateThread (main_thread , \"simh-main\", NULL);\r\n\r\nif (vid_main_thread_handle == NULL) {\r\n    fprintf (stderr, \"SDL_CreateThread failed: %s\\n\", SDL_GetError ());\r\n    exit (1);\r\n    }\r\n\r\nvid_beep_setup (400, 660);\r\n\r\nmemset (&event, 0, sizeof (event));\r\n\r\nwhile (1) {\r\n    int status = SDL_WaitEvent (&event);\r\n    if (status == 1) {\r\n        if (event.type == SDL_USEREVENT) {\r\n            if (event.user.code == EVENT_EXIT)\r\n                break;\r\n            if (event.user.code == EVENT_OPEN) {\r\n                SDL_Init (SDL_INIT_VIDEO);\r\n                vid_video_events ((VID_DISPLAY *)event.user.data1);\r\n            }\r\n            else {\r\n                if (event.user.code == EVENT_SHOW)\r\n                    vid_show_video_event ();\r\n                else {\r\n                    if (event.user.code == EVENT_SCREENSHOT)\r\n                        vid_screenshot_event ();\r\n                    else {\r\n                        sim_printf (\"main(): Unexpected User event: %d\\n\", event.user.code);\r\n                        break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        else {\r\n//          sim_printf (\"main(): Ignoring unexpected event: %d\\n\", event.type);\r\n            }\r\n        }\r\n    else {\r\n        if (status < 0)\r\n            sim_printf (\"main() - ` error: %s\\n\", SDL_GetError());\r\n        }\r\n    }\r\nSDL_WaitThread (vid_main_thread_handle, &status);\r\nvid_beep_cleanup ();\r\nSDL_Quit ();\r\nreturn status;\r\n}\r\n\r\nstatic t_stat vid_create_window (VID_DISPLAY *vptr)\r\n{\r\nint wait_count = 0;\r\nSDL_Event user_event;\r\n\r\nvptr->vid_ready = FALSE;\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.code = EVENT_OPEN;\r\nuser_event.user.data1 = vptr;\r\nuser_event.user.data2 = NULL;\r\nSDL_PushEvent (&user_event);\r\n\r\nwhile ((!vptr->vid_ready) && (++wait_count < 100))  /* Wait up to 10 seconds for video startup */\r\n    sim_os_ms_sleep (100);\r\nif (!vptr->vid_ready) {\r\n    vid_close ();\r\n    return SCPE_OPENERR;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n#else\r\nstatic int vid_create_window (VID_DISPLAY *vptr)\r\n{\r\nint wait_count = 0;\r\n\r\nif (vid_thread_handle == NULL)\r\n    vid_thread_handle = SDL_CreateThread (vid_thread, \"vid-thread\", vptr);\r\nelse {\r\n    SDL_Event user_event;\r\n    vptr->vid_ready = FALSE;\r\n    user_event.type = SDL_USEREVENT;\r\n    user_event.user.code = EVENT_OPEN;\r\n    user_event.user.data1 = vptr;\r\n    user_event.user.data2 = NULL;\r\n    SDL_PushEvent (&user_event);\r\n    }\r\n\r\nif (vid_thread_handle == NULL) {\r\n    vid_close ();\r\n    return SCPE_OPENERR;\r\n    }\r\nwhile ((!vptr->vid_ready) && (++wait_count < 100))  /* Wait up to 10 seconds for video startup */\r\n    sim_os_ms_sleep (100);\r\nif (!vptr->vid_ready) {\r\n    vid_close ();\r\n    return SCPE_OPENERR;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n#endif\r\n\r\nstatic void vid_controllers_setup (DEVICE *dev)\r\n{\r\nSDL_Joystick *y;\r\nSDL_version ver;\r\nint i, n;\r\n\r\nif (vid_gamepad_inited++)\r\n    return;\r\n\r\n/* Check that the SDL_GameControllerFromInstanceID function is\r\n   available at run time. */\r\nSDL_GetVersion(&ver);\r\nvid_gamepad_ok = (ver.major > 2 ||\r\n                  (ver.major == 2 && (ver.minor > 0 || ver.patch >= 4)));\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_JOYSTICK, dev, \"SDL %d.%d.%d %s support game controllers.\\n\", ver.major, ver.minor, ver.patch, vid_gamepad_ok ? \"DOES\" : \"DOES NOT\");\r\n\r\nif (vid_gamepad_ok)\r\n    SDL_InitSubSystem(SDL_INIT_GAMECONTROLLER);\r\nelse\r\n    SDL_InitSubSystem(SDL_INIT_JOYSTICK);\r\n\r\nif (SDL_JoystickEventState (SDL_ENABLE) < 0) {\r\n    if (vid_gamepad_ok)\r\n        SDL_QuitSubSystem(SDL_INIT_GAMECONTROLLER);\r\n    else\r\n        SDL_QuitSubSystem(SDL_INIT_JOYSTICK);\r\n    sim_printf (\"%s: vid_controllers_setup(): SDL_JoystickEventState error: %s\\n\", vid_dname(dev), SDL_GetError());\r\n    return;\r\n    }\r\n\r\nif (vid_gamepad_ok && SDL_GameControllerEventState (SDL_ENABLE) < 0) {\r\n    if (vid_gamepad_ok)\r\n        SDL_QuitSubSystem(SDL_INIT_GAMECONTROLLER);\r\n    else\r\n        SDL_QuitSubSystem(SDL_INIT_JOYSTICK);\r\n    sim_printf (\"%s: vid_controllers_setup(): SDL_GameControllerEventState error: %s\\n\", vid_dname(dev), SDL_GetError());\r\n    return;\r\n    }\r\n\r\nn = SDL_NumJoysticks();\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_JOYSTICK, dev, \"Game controllers found: %d\\n\", n);\r\n\r\nfor (i = 0; i < n; i++) {\r\n    if (vid_gamepad_ok && SDL_IsGameController (i)) {\r\n        SDL_GameController *x = SDL_GameControllerOpen (i);\r\n        if (x != NULL) {\r\n            sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_JOYSTICK, dev,\r\n            \"Game controller: %s\\n\", SDL_GameControllerNameForIndex(i));\r\n            }\r\n        }\r\n    else {\r\n        y = SDL_JoystickOpen (i);\r\n        if (y != NULL) {\r\n            sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_JOYSTICK, dev,\r\n            \"%s\\n\", SDL_JoystickNameForIndex(i));\r\n            sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_JOYSTICK, dev,\r\n            \"Number of axes: %d, buttons: %d\\n\",\r\n            SDL_JoystickNumAxes(y),\r\n            SDL_JoystickNumButtons(y));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstatic void vid_controllers_cleanup (void)\r\n{\r\nif (0 == (--vid_gamepad_inited)) {\r\n    memset (motion_callback, 0, sizeof motion_callback);\r\n    memset (button_callback, 0, sizeof button_callback);\r\n    if (vid_gamepad_ok)\r\n        SDL_QuitSubSystem(SDL_INIT_GAMECONTROLLER);\r\n    else\r\n        SDL_QuitSubSystem(SDL_INIT_JOYSTICK);\r\n    }\r\n}\r\n\r\nstatic t_stat vid_init_window (VID_DISPLAY *vptr, DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags)\r\n{\r\nt_stat stat;\r\n\r\nif ((strlen(sim_name) + 7 + (dptr ? strlen (dptr->name) : 0) + (title ? strlen (title) : 0)) < sizeof (vptr->vid_title))\r\n    sprintf (vptr->vid_title, \"%s%s%s%s%s\", sim_name, dptr ? \" - \" : \"\", dptr ? dptr->name : \"\", title ? \" - \" : \"\", title ? title : \"\");\r\nelse\r\n    sprintf (vptr->vid_title, \"%s\", sim_name);\r\nvptr->vid_flags = flags;\r\nvptr->vid_active_window = TRUE;\r\nvptr->vid_width = width;\r\nvptr->vid_height = height;\r\nvptr->vid_mouse_captured = FALSE;\r\nvptr->vid_cursor_visible = (vptr->vid_flags & SIM_VID_INPUTCAPTURED);\r\nvptr->vid_blending = FALSE;\r\nvptr->vid_ready = FALSE;\r\n\r\nif (!vid_active) {\r\n    vid_key_events.head = 0;\r\n    vid_key_events.tail = 0;\r\n    vid_key_events.count = 0;\r\n    vid_key_events.sem = SDL_CreateSemaphore (1);\r\n    vid_mouse_events.head = 0;\r\n    vid_mouse_events.tail = 0;\r\n    vid_mouse_events.count = 0;\r\n    vid_mouse_events.sem = SDL_CreateSemaphore (1);\r\n}\r\n\r\nvptr->vid_dev = dptr;\r\n\r\nmemset (motion_callback, 0, sizeof motion_callback);\r\nmemset (button_callback, 0, sizeof button_callback);\r\n\r\nstat = vid_create_window (vptr);\r\nif (stat != SCPE_OK)\r\n    return stat;\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE, vptr->vid_dev, \"vid_open() - Success\\n\");\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_open_window (VID_DISPLAY **vptr, DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags)\r\n{\r\nt_stat r;\r\n*vptr = (VID_DISPLAY *)malloc (sizeof (VID_DISPLAY));\r\nif (*vptr == NULL)\r\n    return SCPE_NXM;\r\n(*vptr)->next = vid_first.next;\r\nvid_first.next = *vptr;\r\nr = vid_init_window (*vptr, dptr, title, width, height, flags);\r\nif (r != SCPE_OK) {\r\n    vid_first.next = (*vptr)->next;\r\n    free (*vptr);\r\n    *vptr = NULL;\r\n    return r;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_open (DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags)\r\n{\r\nif (!vid_first.vid_active_window)\r\n    return vid_init_window (&vid_first, dptr, title, width, height, flags);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_close_window (VID_DISPLAY *vptr)\r\n{\r\nSDL_Event user_event;\r\nint status;\r\n\r\nif (vptr->vid_ready) {\r\n    sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE, vptr->vid_dev, \"vid_close()\\n\");\r\n    user_event.type = SDL_USEREVENT;\r\n    user_event.user.windowID = vptr->vid_windowID;\r\n    user_event.user.code = EVENT_CLOSE;\r\n    user_event.user.data1 = NULL;\r\n    user_event.user.data2 = NULL;\r\n\r\n    while (SDL_PushEvent (&user_event) < 0)\r\n        sim_os_ms_sleep (10);\r\n    vptr->vid_dev = NULL;\r\n    }\r\nif (vid_thread_handle && vid_active <= 1) {\r\n    SDL_WaitThread (vid_thread_handle, &status);\r\n    vid_thread_handle = NULL;\r\n    }\r\nwhile (vptr->vid_ready)\r\n    sim_os_ms_sleep (10);\r\n\r\nvptr->vid_active_window = FALSE;\r\nif (!vid_active && vid_mouse_events.sem) {\r\n    SDL_DestroySemaphore(vid_mouse_events.sem);\r\n    vid_mouse_events.sem = NULL;\r\n    }\r\nif (!vid_active && vid_key_events.sem) {\r\n    SDL_DestroySemaphore(vid_key_events.sem);\r\n    vid_key_events.sem = NULL;\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_close (void)\r\n{\r\nif (vid_first.vid_active_window)\r\n    return vid_close_window (&vid_first);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_close_all (void)\r\n{\r\nVID_DISPLAY *vptr;\r\nvid_close ();\r\nfor (vptr = vid_first.next; vptr != NULL; vptr = vptr->next)\r\n    vid_close_window (vptr);\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_poll_kb (SIM_KEY_EVENT *ev)\r\n{\r\nif (SDL_SemTryWait (vid_key_events.sem) == 0) {         /* get lock */\r\n    if (vid_key_events.count > 0) {                     /* events in queue? */\r\n        *ev = vid_key_events.events[vid_key_events.head++];\r\n        vid_key_events.count--;\r\n        if (vid_key_events.head == MAX_EVENTS)\r\n            vid_key_events.head = 0;\r\n        SDL_SemPost (vid_key_events.sem);\r\n        return SCPE_OK;\r\n        }\r\n    SDL_SemPost (vid_key_events.sem);\r\n    }\r\nreturn SCPE_EOF;\r\n}\r\n\r\nt_stat vid_poll_mouse (SIM_MOUSE_EVENT *ev)\r\n{\r\nt_stat stat = SCPE_EOF;\r\nSIM_MOUSE_EVENT *nev;\r\n\r\nif (SDL_SemTryWait (vid_mouse_events.sem) == 0) {\r\n    if (vid_mouse_events.count > 0) {\r\n        stat = SCPE_OK;\r\n        *ev = vid_mouse_events.events[vid_mouse_events.head++];\r\n        vid_mouse_events.count--;\r\n        if (vid_mouse_events.head == MAX_EVENTS)\r\n            vid_mouse_events.head = 0;\r\n        nev = &vid_mouse_events.events[vid_mouse_events.head];\r\n        if ((vid_mouse_events.count > 0) &&\r\n            (0 == (ev->x_rel + nev->x_rel)) &&\r\n            (0 == (ev->y_rel + nev->y_rel)) &&\r\n            (ev->b1_state == nev->b1_state) &&\r\n            (ev->b2_state == nev->b2_state) &&\r\n            (ev->b3_state == nev->b3_state)) {\r\n            if ((++vid_mouse_events.head) == MAX_EVENTS)\r\n                vid_mouse_events.head = 0;\r\n            vid_mouse_events.count--;\r\n            stat = SCPE_EOF;\r\n            sim_debug (SIM_VID_DBG_MOUSE, ev->dev, \"vid_poll_mouse: ignoring bouncing events\\n\");\r\n            }\r\n        }\r\n    if (SDL_SemPost (vid_mouse_events.sem))\r\n        sim_printf (\"vid_poll_mouse(): SDL_SemPost error: %s\\n\", SDL_GetError());\r\n    }\r\nreturn stat;\r\n}\r\n\r\nuint32 vid_map_rgb_window (VID_DISPLAY *vptr, uint8 r, uint8 g, uint8 b)\r\n{\r\nreturn SDL_MapRGB (vptr->vid_format, r, g, b);\r\n}\r\n\r\nuint32 vid_map_rgb (uint8 r, uint8 g, uint8 b)\r\n{\r\nreturn vid_map_rgb_window (&vid_first, r, g, b);\r\n}\r\n\r\nuint32 vid_map_rgba_window (VID_DISPLAY *vptr, uint8 r, uint8 g, uint8 b, uint8 a)\r\n{\r\nreturn SDL_MapRGBA (vptr->vid_format, r, g, b, a);\r\n}\r\n\r\nvoid vid_draw_window (VID_DISPLAY *vptr, int32 x, int32 y, int32 w, int32 h, uint32 *buf)\r\n{\r\nSDL_Event user_event;\r\nSDL_Rect *vid_dst, *last;\r\nuint32 *vid_data;\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"vid_draw(%d, %d, %d, %d)\\n\", x, y, w, h);\r\n\r\nSDL_LockMutex (vptr->vid_draw_mutex);                         /* Synchronize to check region dimensions */\r\nlast = vptr->vid_dst_last;\r\nif (last                               &&               /* As yet unprocessed draw rectangle? */\r\n    (last->x == x) && (last->y == y) &&                 /* AND identical position? */\r\n    (last->w == w) && (last->h == h)) {                 /* AND identical dimensions? */\r\n    memcpy (vptr->vid_data_last, buf, w*h*sizeof(*buf));/* Replace region contents */\r\n    SDL_UnlockMutex (vptr->vid_draw_mutex);                   /* Done */\r\n    return;\r\n    }\r\nSDL_UnlockMutex (vptr->vid_draw_mutex);\r\n\r\nvid_dst = (SDL_Rect *)malloc (sizeof(*vid_dst));\r\nif (!vid_dst) {\r\n    sim_printf (\"%s: vid_draw() memory allocation error\\n\", vid_dname(vptr->vid_dev));\r\n    return;\r\n    }\r\nvid_dst->x = x;\r\nvid_dst->y = y;\r\nvid_dst->w = w;\r\nvid_dst->h = h;\r\nvid_data = (uint32 *)malloc (w*h*sizeof(*buf));\r\nif (!vid_data) {\r\n    sim_printf (\"%s: vid_draw() memory allocation error\\n\", vid_dname(vptr->vid_dev));\r\n    free (vid_dst);\r\n    return;\r\n    }\r\nmemcpy (vid_data, buf, w*h*sizeof(*buf));\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.windowID = vptr->vid_windowID;\r\nuser_event.user.code = EVENT_DRAW;\r\nuser_event.user.data1 = (void *)vid_dst;\r\nuser_event.user.data2 = (void *)vid_data;\r\nSDL_LockMutex (vptr->vid_draw_mutex);         /* protect vid_dst_last & vid_data_last */\r\nvptr->vid_dst_last = vid_dst;\r\nvptr->vid_data_last = vid_data;\r\nSDL_UnlockMutex (vptr->vid_draw_mutex);       /* done protection */\r\nif (SDL_PushEvent (&user_event) < 0) {\r\n    sim_printf (\"%s: vid_draw() SDL_PushEvent error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    free (vid_dst);\r\n    free (vid_data);\r\n    }\r\n}\r\n\r\nvoid vid_draw (int32 x, int32 y, int32 w, int32 h, uint32 *buf)\r\n{\r\nvid_draw_window (&vid_first, x, y, w, h, buf);\r\n}\r\n\r\nt_stat vid_set_cursor_window (VID_DISPLAY *vptr, t_bool visible, uint32 width, uint32 height, uint8 *data, uint8 *mask, uint32 hot_x, uint32 hot_y)\r\n{\r\nSDL_Cursor *cursor = SDL_CreateCursor (data, mask, width, height, hot_x, hot_y);\r\nSDL_Event user_event;\r\n\r\nsim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"vid_set_cursor(%s, %d, %d) Setting New Cursor\\n\", visible ? \"visible\" : \"invisible\", width, height);\r\nif (sim_deb) {\r\n    uint32 i, j;\r\n\r\n    for (i=0; i<height; i++) {\r\n        sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"Cursor:  \");\r\n        for (j=0; j<width; j++) {\r\n            int byte = (j + i*width) >> 3;\r\n            int bit = 7 - ((j + i*width) & 0x7);\r\n            static char mode[] = \"TWIB\";\r\n\r\n            sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"%c\", mode[(((data[byte]>>bit)&1)<<1)|((mask[byte]>>bit)&1)]);\r\n            }\r\n        sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"\\n\");\r\n        }\r\n    }\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.windowID = vptr->vid_windowID;\r\nuser_event.user.code = EVENT_CURSOR;\r\nuser_event.user.data1 = cursor;\r\nuser_event.user.data2 = (void *)((size_t)visible);\r\n\r\nif (SDL_PushEvent (&user_event) < 0) {\r\n    sim_printf (\"%s: vid_set_cursor() SDL_PushEvent error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    SDL_FreeCursor (cursor);\r\n    }\r\n\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_set_cursor (t_bool visible, uint32 width, uint32 height, uint8 *data, uint8 *mask, uint32 hot_x, uint32 hot_y)\r\n{\r\nreturn vid_set_cursor_window (&vid_first, visible, width, height, data, mask, hot_x, hot_y);\r\n}\r\n\r\nvoid vid_set_cursor_position_window (VID_DISPLAY *vptr, int32 x, int32 y)\r\n{\r\nint32 x_delta = vid_cursor_x - x;\r\nint32 y_delta = vid_cursor_y - y;\r\n\r\nif (vptr->vid_flags & SIM_VID_INPUTCAPTURED)\r\n    return;\r\n\r\nif ((x_delta) || (y_delta)) {\r\n    sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"vid_set_cursor_position(%d, %d) - Cursor position changed\\n\", x, y);\r\n    /* Any queued mouse motion events need to have their relative\r\n       positions adjusted since they were queued based on different info. */\r\n    if (SDL_SemWait (vid_mouse_events.sem) == 0) {\r\n        int32 i;\r\n        SIM_MOUSE_EVENT *ev;\r\n\r\n        for (i=0; i<vid_mouse_events.count; i++) {\r\n            ev = &vid_mouse_events.events[(vid_mouse_events.head + i)%MAX_EVENTS];\r\n            sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"Pending Mouse Motion Event Adjusted from: (%d, %d) to (%d, %d)\\n\", ev->x_rel, ev->y_rel, ev->x_rel + x_delta, ev->y_rel + y_delta);\r\n            ev->x_rel += x_delta;\r\n            ev->y_rel += y_delta;\r\n            }\r\n        if (SDL_SemPost (vid_mouse_events.sem))\r\n            sim_printf (\"%s: vid_set_cursor_position(): SDL_SemPost error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n        }\r\n    else {\r\n        sim_printf (\"%s: vid_set_cursor_position(): SDL_SemWait error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n        }\r\n    vid_cursor_x = x;\r\n    vid_cursor_y = y;\r\n    if (vptr->vid_cursor_visible) {\r\n        SDL_Event user_event;\r\n\r\n        user_event.type = SDL_USEREVENT;\r\n        user_event.user.windowID = vptr->vid_windowID;\r\n        user_event.user.code = EVENT_WARP;\r\n        user_event.user.data1 = NULL;\r\n        user_event.user.data2 = NULL;\r\n\r\n        if (SDL_PushEvent (&user_event) < 0)\r\n            sim_printf (\"%s: vid_set_cursor_position() SDL_PushEvent error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n        sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"vid_set_cursor_position() - Warp Queued\\n\");\r\n        }\r\n    else {\r\n        sim_debug (SIM_VID_DBG_CURSOR, vptr->vid_dev, \"vid_set_cursor_position() - Warp Skipped\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid vid_set_cursor_position (int32 x, int32 y)\r\n{\r\nvid_set_cursor_position_window (&vid_first, x, y);\r\n}\r\n\r\nvoid vid_refresh_window (VID_DISPLAY *vptr)\r\n{\r\nSDL_Event user_event;\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"vid_refresh() - Queueing Refresh Event\\n\");\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.windowID = vptr->vid_windowID;\r\nuser_event.user.code = EVENT_REDRAW;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\n\r\nif (SDL_PushEvent (&user_event) < 0)\r\n    sim_printf (\"%s: vid_refresh() SDL_PushEvent error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n}\r\n\r\nvoid vid_refresh (void)\r\n{\r\nvid_refresh_window (&vid_first);\r\n}\r\n\r\nint vid_map_key (int key)\r\n{\r\nswitch (key) {\r\n\r\n    case SDLK_BACKSPACE:\r\n        return SIM_KEY_BACKSPACE;\r\n\r\n    case SDLK_TAB:\r\n        return SIM_KEY_TAB;\r\n\r\n    case SDLK_RETURN:\r\n        return SIM_KEY_ENTER;\r\n\r\n    case SDLK_ESCAPE:\r\n        return SIM_KEY_ESC;\r\n\r\n    case SDLK_SPACE:\r\n        return SIM_KEY_SPACE;\r\n\r\n    case SDLK_QUOTE:\r\n        return SIM_KEY_SINGLE_QUOTE;\r\n\r\n    case SDLK_COMMA:\r\n        return SIM_KEY_COMMA;\r\n\r\n    case SDLK_MINUS:\r\n        return SIM_KEY_MINUS;\r\n\r\n    case SDLK_PERIOD:\r\n        return SIM_KEY_PERIOD;\r\n\r\n    case SDLK_SLASH:\r\n        return SIM_KEY_SLASH;\r\n\r\n    case SDLK_0:\r\n        return SIM_KEY_0;\r\n\r\n    case SDLK_1:\r\n        return SIM_KEY_1;\r\n\r\n    case SDLK_2:\r\n        return SIM_KEY_2;\r\n\r\n    case SDLK_3:\r\n        return SIM_KEY_3;\r\n\r\n    case SDLK_4:\r\n        return SIM_KEY_4;\r\n\r\n    case SDLK_5:\r\n        return SIM_KEY_5;\r\n\r\n    case SDLK_6:\r\n        return SIM_KEY_6;\r\n\r\n    case SDLK_7:\r\n        return SIM_KEY_7;\r\n\r\n    case SDLK_8:\r\n        return SIM_KEY_8;\r\n\r\n    case SDLK_9:\r\n        return SIM_KEY_9;\r\n\r\n    case SDLK_SEMICOLON:\r\n        return SIM_KEY_SEMICOLON;\r\n\r\n    case SDLK_EQUALS:\r\n        return SIM_KEY_EQUALS;\r\n\r\n    case SDLK_LEFTBRACKET:\r\n        return SIM_KEY_LEFT_BRACKET;\r\n\r\n    case SDLK_BACKSLASH:\r\n        return SIM_KEY_BACKSLASH;\r\n\r\n    case SDLK_RIGHTBRACKET:\r\n        return SIM_KEY_RIGHT_BRACKET;\r\n\r\n    case SDLK_BACKQUOTE:\r\n        return SIM_KEY_BACKQUOTE;\r\n\r\n    case SDLK_a:\r\n        return SIM_KEY_A;\r\n\r\n    case SDLK_b:\r\n        return SIM_KEY_B;\r\n\r\n    case SDLK_c:\r\n        return SIM_KEY_C;\r\n\r\n    case SDLK_d:\r\n        return SIM_KEY_D;\r\n\r\n    case SDLK_e:\r\n        return SIM_KEY_E;\r\n\r\n    case SDLK_f:\r\n        return SIM_KEY_F;\r\n\r\n    case SDLK_g:\r\n        return SIM_KEY_G;\r\n\r\n    case SDLK_h:\r\n        return SIM_KEY_H;\r\n\r\n    case SDLK_i:\r\n        return SIM_KEY_I;\r\n\r\n    case SDLK_j:\r\n        return SIM_KEY_J;\r\n\r\n    case SDLK_k:\r\n        return SIM_KEY_K;\r\n\r\n    case SDLK_l:\r\n        return SIM_KEY_L;\r\n\r\n    case SDLK_m:\r\n        return SIM_KEY_M;\r\n\r\n    case SDLK_n:\r\n        return SIM_KEY_N;\r\n\r\n    case SDLK_o:\r\n        return SIM_KEY_O;\r\n\r\n    case SDLK_p:\r\n        return SIM_KEY_P;\r\n\r\n    case SDLK_q:\r\n        return SIM_KEY_Q;\r\n\r\n    case SDLK_r:\r\n        return SIM_KEY_R;\r\n\r\n    case SDLK_s:\r\n        return SIM_KEY_S;\r\n\r\n    case SDLK_t:\r\n        return SIM_KEY_T;\r\n\r\n    case SDLK_u:\r\n        return SIM_KEY_U;\r\n\r\n    case SDLK_v:\r\n        return SIM_KEY_V;\r\n\r\n    case SDLK_w:\r\n        return SIM_KEY_W;\r\n\r\n    case SDLK_x:\r\n        return SIM_KEY_X;\r\n\r\n    case SDLK_y:\r\n        return SIM_KEY_Y;\r\n\r\n    case SDLK_z:\r\n        return SIM_KEY_Z;\r\n\r\n    case SDLK_DELETE:\r\n        return SIM_KEY_DELETE;\r\n    case SDLK_KP_0:\r\n        return SIM_KEY_KP_INSERT;\r\n\r\n    case SDLK_KP_1:\r\n        return SIM_KEY_KP_END;\r\n\r\n    case SDLK_KP_2:\r\n        return SIM_KEY_KP_DOWN;\r\n\r\n    case SDLK_KP_3:\r\n        return SIM_KEY_KP_PAGE_DOWN;\r\n\r\n    case SDLK_KP_4:\r\n        return SIM_KEY_KP_LEFT;\r\n\r\n    case SDLK_KP_5:\r\n        return SIM_KEY_KP_5;\r\n\r\n    case SDLK_KP_6:\r\n        return SIM_KEY_KP_RIGHT;\r\n\r\n    case SDLK_KP_7:\r\n        return SIM_KEY_KP_HOME;\r\n\r\n    case SDLK_KP_8:\r\n        return SIM_KEY_KP_UP;\r\n\r\n    case SDLK_KP_9:\r\n        return SIM_KEY_KP_PAGE_UP;\r\n\r\n    case SDLK_KP_PERIOD:\r\n        return SIM_KEY_KP_DELETE;\r\n\r\n    case SDLK_KP_DIVIDE:\r\n        return SIM_KEY_KP_DIVIDE;\r\n\r\n    case SDLK_KP_MULTIPLY:\r\n        return SIM_KEY_KP_MULTIPLY;\r\n\r\n    case SDLK_KP_MINUS:\r\n        return SIM_KEY_KP_SUBTRACT;\r\n\r\n    case SDLK_KP_PLUS:\r\n        return SIM_KEY_KP_ADD;\r\n\r\n    case SDLK_KP_ENTER:\r\n        return SIM_KEY_KP_ENTER;\r\n\r\n    case SDLK_UP:\r\n        return SIM_KEY_UP;\r\n\r\n    case SDLK_DOWN:\r\n        return SIM_KEY_DOWN;\r\n\r\n    case SDLK_RIGHT:\r\n        return SIM_KEY_RIGHT;\r\n\r\n    case SDLK_LEFT:\r\n        return SIM_KEY_LEFT;\r\n\r\n    case SDLK_INSERT:\r\n        return SIM_KEY_INSERT;\r\n\r\n    case SDLK_HOME:\r\n        return SIM_KEY_HOME;\r\n\r\n    case SDLK_END:\r\n        return SIM_KEY_END;\r\n\r\n    case SDLK_PAGEUP:\r\n        return SIM_KEY_PAGE_UP;\r\n\r\n    case SDLK_PAGEDOWN:\r\n        return SIM_KEY_PAGE_DOWN;\r\n\r\n    case SDLK_F1:\r\n        return SIM_KEY_F1;\r\n\r\n    case SDLK_F2:\r\n        return SIM_KEY_F2;\r\n\r\n    case SDLK_F3:\r\n        return SIM_KEY_F3;\r\n\r\n    case SDLK_F4:\r\n        return SIM_KEY_F4;\r\n\r\n    case SDLK_F5:\r\n        return SIM_KEY_F5;\r\n\r\n    case SDLK_F6:\r\n        return SIM_KEY_F6;\r\n\r\n    case SDLK_F7:\r\n        return SIM_KEY_F7;\r\n\r\n    case SDLK_F8:\r\n        return SIM_KEY_F8;\r\n\r\n    case SDLK_F9:\r\n        return SIM_KEY_F9;\r\n\r\n    case SDLK_F10:\r\n        return SIM_KEY_F10;\r\n\r\n    case SDLK_F11:\r\n        return SIM_KEY_F11;\r\n\r\n    case SDLK_F12:\r\n        return SIM_KEY_F12;\r\n\r\n    case SDLK_NUMLOCKCLEAR:\r\n        return SIM_KEY_NUM_LOCK;\r\n\r\n    case SDLK_CAPSLOCK:\r\n        return SIM_KEY_CAPS_LOCK;\r\n\r\n    case SDLK_SCROLLLOCK:\r\n        return SIM_KEY_SCRL_LOCK;\r\n\r\n    case SDLK_RSHIFT:\r\n        return SIM_KEY_SHIFT_R;\r\n\r\n    case SDLK_LSHIFT:\r\n        return SIM_KEY_SHIFT_L;\r\n\r\n    case SDLK_RCTRL:\r\n        return SIM_KEY_CTRL_R;\r\n\r\n    case SDLK_LCTRL:\r\n        return SIM_KEY_CTRL_L;\r\n\r\n    case SDLK_RALT:\r\n        return SIM_KEY_ALT_R;\r\n\r\n    case SDLK_LALT:\r\n        return SIM_KEY_ALT_L;\r\n\r\n    case SDLK_LGUI:\r\n        return SIM_KEY_WIN_L;\r\n\r\n    case SDLK_RGUI:\r\n        return SIM_KEY_WIN_R;\r\n\r\n    case SDLK_PRINTSCREEN:\r\n        return SIM_KEY_PRINT;\r\n\r\n    case SDLK_PAUSE:\r\n        return SIM_KEY_PAUSE;\r\n\r\n    case SDLK_MENU:\r\n        return SIM_KEY_MENU;\r\n\r\n    default:\r\n        return SIM_KEY_UNKNOWN;\r\n        }\r\n}\r\n\r\nvoid vid_joy_motion (SDL_JoyAxisEvent *event)\r\n{\r\n    int n = sizeof motion_callback / sizeof (VID_GAMEPAD_CALLBACK);\r\n    int i;\r\n\r\n    for (i = 0; i < n; i++) {\r\n        if (motion_callback[i]) {\r\n            motion_callback[i](event->which, event->axis, event->value);\r\n            }\r\n        }\r\n}\r\n\r\nvoid vid_joy_button (SDL_JoyButtonEvent *event)\r\n{\r\n    int n = sizeof button_callback / sizeof (VID_GAMEPAD_CALLBACK);\r\n    int i;\r\n\r\n    for (i = 0; i < n; i++) {\r\n        if (button_callback[i]) {\r\n            button_callback[i](event->which, event->button, event->state);\r\n            }\r\n        }\r\n}\r\n\r\nvoid vid_controller_motion (SDL_ControllerAxisEvent *event)\r\n{\r\n    SDL_JoyAxisEvent e;\r\n    e.which = event->which;\r\n    e.axis = event->axis;\r\n    e.value = event->value;\r\n    vid_joy_motion (&e);\r\n}\r\n\r\nvoid vid_controller_button (SDL_ControllerButtonEvent *event)\r\n{\r\n    /* SDL_GameControllerFromInstanceID is only available from SDL\r\n       version 2.0.4, so check the version at compile time.  The\r\n       version is also checked at run time. */\r\n#if (SDL_MAJOR_VERSION > 2) || (SDL_MAJOR_VERSION == 2 && \\\r\n    (SDL_MINOR_VERSION > 0) || (SDL_PATCHLEVEL >= 4))\r\n\r\n    SDL_JoyButtonEvent e;\r\n    SDL_GameControllerButtonBind b;\r\n    SDL_GameController *c;\r\n    SDL_GameControllerButton button = (SDL_GameControllerButton)event->button;\r\n\r\n    c = SDL_GameControllerFromInstanceID (event->which);\r\n    b = SDL_GameControllerGetBindForButton (c, button);\r\n    e.which = event->which;\r\n    e.button = b.value.button;\r\n    e.state = event->state;\r\n    vid_joy_button (&e);\r\n#endif\r\n}\r\n\r\nvoid vid_key (SDL_KeyboardEvent *event)\r\n{\r\nSIM_KEY_EVENT ev;\r\nVID_DISPLAY *vptr = vid_get_event_window ((SDL_Event *)event, event->windowID);\r\nif (vptr == NULL)\r\n   return;\r\n\r\nif (vptr->vid_mouse_captured) {\r\n    static const Uint8 *KeyStates = NULL;\r\n    static int numkeys;\r\n\r\n    if (!KeyStates)\r\n        KeyStates = SDL_GetKeyboardState(&numkeys);\r\n    if ((vptr->vid_flags & SIM_VID_INPUTCAPTURED) &&\r\n        (event->state == SDL_PRESSED) &&\r\n        KeyStates[SDL_SCANCODE_RSHIFT] &&\r\n        (KeyStates[SDL_SCANCODE_LCTRL] || KeyStates[SDL_SCANCODE_RCTRL])) {\r\n        sim_debug (SIM_VID_DBG_KEY, vptr->vid_dev, \"vid_key() - Cursor Release\\n\");\r\n        if (SDL_SetRelativeMouseMode(SDL_FALSE) < 0)    /* release cursor, show cursor */\r\n            sim_printf (\"%s: vid_key(): SDL_SetRelativeMouseMode error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n        vptr->vid_mouse_captured = FALSE;\r\n        return;\r\n        }\r\n    }\r\nif (!sim_is_running)\r\n    return;\r\nif (SDL_SemWait (vid_key_events.sem) == 0) {\r\n    if (vid_key_events.count < MAX_EVENTS) {\r\n        ev.key = vid_map_key (event->keysym.sym);\r\n        ev.dev = vptr->vid_dev;\r\n        ev.vptr = vptr;\r\n        sim_debug (SIM_VID_DBG_KEY, vptr->vid_dev, \"Keyboard Event: State: %s, Keysym(scancode,sym): (%d,%d) - %s\\n\", (event->state == SDL_PRESSED) ? \"PRESSED\" : \"RELEASED\", event->keysym.scancode, event->keysym.sym, vid_key_name(ev.key));\r\n        if (event->state == SDL_PRESSED) {\r\n            if (!vptr->vid_key_state[event->keysym.scancode]) {/* Key was not down before */\r\n                vptr->vid_key_state[event->keysym.scancode] = TRUE;\r\n                ev.state = SIM_KEYPRESS_DOWN;\r\n                }\r\n            else\r\n                ev.state = SIM_KEYPRESS_REPEAT;\r\n            }\r\n        else {\r\n            vptr->vid_key_state[event->keysym.scancode] = FALSE;\r\n            ev.state = SIM_KEYPRESS_UP;\r\n            }\r\n        vid_key_events.events[vid_key_events.tail++] = ev;\r\n        vid_key_events.count++;\r\n        if (vid_key_events.tail == MAX_EVENTS)\r\n            vid_key_events.tail = 0;\r\n        }\r\n    else {\r\n        sim_debug (SIM_VID_DBG_KEY, vptr->vid_dev, \"Keyboard Event DISCARDED: State: %s, Keysym: Scancode: %d, Keysym: %d\\n\", (event->state == SDL_PRESSED) ? \"PRESSED\" : \"RELEASED\", event->keysym.scancode, event->keysym.sym);\r\n        }\r\n    if (SDL_SemPost (vid_key_events.sem))\r\n        sim_printf (\"%s: vid_key(): SDL_SemPost error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    }\r\n}\r\n\r\nvoid vid_mouse_move (SDL_MouseMotionEvent *event)\r\n{\r\nSDL_Event dummy_event;\r\nSDL_MouseMotionEvent *dev = (SDL_MouseMotionEvent *)&dummy_event;\r\nSIM_MOUSE_EVENT ev;\r\nVID_DISPLAY *vptr = vid_get_event_window ((SDL_Event *)event, event->windowID);\r\nif (vptr == NULL)\r\n   return;\r\n\r\nif ((!vptr->vid_mouse_captured) && (vptr->vid_flags & SIM_VID_INPUTCAPTURED))\r\n    return;\r\n\r\nif (!sim_is_running)\r\n    return;\r\nif (!vptr->vid_cursor_visible)\r\n    return;\r\nsim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Move Event: pos:(%d,%d) rel:(%d,%d) buttons:(%d,%d,%d)\\n\",\r\n           event->x, event->y, event->xrel, event->yrel, (event->state & SDL_BUTTON(SDL_BUTTON_LEFT)) ? 1 : 0, (event->state & SDL_BUTTON(SDL_BUTTON_MIDDLE)) ? 1 : 0, (event->state & SDL_BUTTON(SDL_BUTTON_RIGHT)) ? 1 : 0);\r\nwhile (SDL_PeepEvents (&dummy_event, 1, SDL_GETEVENT, SDL_MOUSEMOTION, SDL_MOUSEMOTION)) {\r\n    /* Coalesce motion activity to avoid thrashing */\r\n    event->xrel += dev->xrel;\r\n    event->yrel += dev->yrel;\r\n    event->x = dev->x;\r\n    event->y = dev->y;\r\n    event->state = dev->state;\r\n    sim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Move Event: Additional Event Coalesced:pos:(%d,%d) rel:(%d,%d) buttons:(%d,%d,%d)\\n\",\r\n        dev->x, dev->y, dev->xrel, dev->yrel, (dev->state & SDL_BUTTON(SDL_BUTTON_LEFT)) ? 1 : 0, (dev->state & SDL_BUTTON(SDL_BUTTON_MIDDLE)) ? 1 : 0, (dev->state & SDL_BUTTON(SDL_BUTTON_RIGHT)) ? 1 : 0);\r\n    };\r\nif (SDL_SemWait (vid_mouse_events.sem) == 0) {\r\n    if (!vptr->vid_mouse_captured) {\r\n        event->xrel = (event->x - vid_cursor_x);\r\n        event->yrel = (event->y - vid_cursor_y);\r\n        }\r\n    vid_mouse_b1 = (event->state & SDL_BUTTON(SDL_BUTTON_LEFT)) ? TRUE : FALSE;\r\n    vid_mouse_b2 = (event->state & SDL_BUTTON(SDL_BUTTON_MIDDLE)) ? TRUE : FALSE;\r\n    vid_mouse_b3 = (event->state & SDL_BUTTON(SDL_BUTTON_RIGHT)) ? TRUE : FALSE;\r\n    sim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Move Event: pos:(%d,%d) rel:(%d,%d) buttons:(%d,%d,%d) - Count: %d vid_cursor:(%d,%d)\\n\",\r\n                                            event->x, event->y, event->xrel, event->yrel, (event->state & SDL_BUTTON(SDL_BUTTON_LEFT)) ? 1 : 0, (event->state & SDL_BUTTON(SDL_BUTTON_MIDDLE)) ? 1 : 0, (event->state & SDL_BUTTON(SDL_BUTTON_RIGHT)) ? 1 : 0, vid_mouse_events.count, vid_cursor_x, vid_cursor_y);\r\n    if (vid_mouse_events.count < MAX_EVENTS) {\r\n        SIM_MOUSE_EVENT *tail = &vid_mouse_events.events[(vid_mouse_events.tail+MAX_EVENTS-1)%MAX_EVENTS];\r\n\r\n        ev.dev = vptr->vid_dev;\r\n        ev.x_rel = event->xrel;\r\n        ev.y_rel = event->yrel;\r\n        ev.b1_state = vid_mouse_b1;\r\n        ev.b2_state = vid_mouse_b2;\r\n        ev.b3_state = vid_mouse_b3;\r\n        ev.x_pos = event->x;\r\n        ev.y_pos = event->y;\r\n        if ((vid_mouse_events.count > 0) &&             /* Is there a tail event? */\r\n            (ev.b1_state == tail->b1_state) &&          /* With the same button state? */\r\n            (ev.b2_state == tail->b2_state) &&\r\n            (ev.b3_state == tail->b3_state)) {          /* Merge the motion */\r\n            tail->x_rel += ev.x_rel;\r\n            tail->y_rel += ev.y_rel;\r\n            tail->x_pos = ev.x_pos;\r\n            tail->y_pos = ev.y_pos;\r\n            sim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Move Event: Coalesced into pending event: (%d,%d)\\n\",\r\n                tail->x_rel, tail->y_rel);\r\n            }\r\n        else {                                          /* Add a new event */\r\n            vid_mouse_events.events[vid_mouse_events.tail++] = ev;\r\n            vid_mouse_events.count++;\r\n            if (vid_mouse_events.tail == MAX_EVENTS)\r\n                vid_mouse_events.tail = 0;\r\n            }\r\n        }\r\n    else {\r\n        sim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Move Event Discarded: Count: %d\\n\", vid_mouse_events.count);\r\n        }\r\n    if (SDL_SemPost (vid_mouse_events.sem))\r\n        sim_printf (\"%s: vid_mouse_move(): SDL_SemPost error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    }\r\n}\r\n\r\nvoid vid_mouse_button (SDL_MouseButtonEvent *event)\r\n{\r\nSDL_Event dummy_event;\r\nSIM_MOUSE_EVENT ev;\r\nt_bool state;\r\nVID_DISPLAY *vptr = vid_get_event_window ((SDL_Event *)event, event->windowID);\r\nif (vptr == NULL)\r\n   return;\r\n\r\nif ((!vptr->vid_mouse_captured) && (vptr->vid_flags & SIM_VID_INPUTCAPTURED)) {\r\n    if ((event->state == SDL_PRESSED) &&\r\n        (event->button == SDL_BUTTON_LEFT)) {               /* left click and cursor not captured? */\r\n        sim_debug (SIM_VID_DBG_KEY, vptr->vid_dev, \"vid_mouse_button() - Cursor Captured\\n\");\r\n        if (SDL_SetRelativeMouseMode (SDL_TRUE) < 0)        /* lock cursor to window, hide cursor */\r\n            sim_printf (\"%s: vid_mouse_button(): SDL_SetRelativeMouseMode error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n        SDL_WarpMouseInWindow (NULL, vptr->vid_width/2, vptr->vid_height/2);/* back to center */\r\n        SDL_PumpEvents ();\r\n        while (SDL_PeepEvents (&dummy_event, 1, SDL_GETEVENT, SDL_MOUSEMOTION, SDL_MOUSEMOTION)) {};\r\n        vptr->vid_mouse_captured = TRUE;\r\n        }\r\n    return;\r\n    }\r\nif (!sim_is_running)\r\n    return;\r\nstate = (event->state == SDL_PRESSED) ? TRUE : FALSE;\r\nif (SDL_SemWait (vid_mouse_events.sem) == 0) {\r\n    switch (event->button) {\r\n        case SDL_BUTTON_LEFT:\r\n            vid_mouse_b1 = state;\r\n            break;\r\n        case SDL_BUTTON_MIDDLE:\r\n            vid_mouse_b2 = state;\r\n            break;\r\n        case SDL_BUTTON_RIGHT:\r\n            vid_mouse_b3 = state;\r\n            break;\r\n            }\r\n    sim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Button Event: State: %d, Button: %d, (%d,%d)\\n\", event->state, event->button, event->x, event->y);\r\n    if (vid_mouse_events.count < MAX_EVENTS) {\r\n        ev.dev = vptr->vid_dev;\r\n        ev.x_rel = 0;\r\n        ev.y_rel = 0;\r\n        ev.x_pos = event->x;\r\n        ev.y_pos = event->y;\r\n        ev.b1_state = vid_mouse_b1;\r\n        ev.b2_state = vid_mouse_b2;\r\n        ev.b3_state = vid_mouse_b3;\r\n        vid_mouse_events.events[vid_mouse_events.tail++] = ev;\r\n        vid_mouse_events.count++;\r\n        if (vid_mouse_events.tail == MAX_EVENTS)\r\n            vid_mouse_events.tail = 0;\r\n        }\r\n    else {\r\n        sim_debug (SIM_VID_DBG_MOUSE, vptr->vid_dev, \"Mouse Button Event Discarded: Count: %d\\n\", vid_mouse_events.count);\r\n        }\r\n    if (SDL_SemPost (vid_mouse_events.sem))\r\n        sim_printf (\"%s: Mouse Button Event: SDL_SemPost error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    }\r\n}\r\n\r\nvoid vid_set_window_size (VID_DISPLAY *vptr, int32 w, int32 h)\r\n{\r\nSDL_Event user_event;\r\n\r\nvptr->vid_rect.h = h;\r\nvptr->vid_rect.w = w;\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.windowID = vptr->vid_windowID;\r\nuser_event.user.code = EVENT_SIZE;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (100);\r\n#else\r\n    SDL_SetWindowSize(vptr->vid_window, w, h);\r\n#endif\r\n}\r\n\r\nvoid vid_render_set_logical_size (VID_DISPLAY *vptr, int32 w, int32 h)\r\n{\r\nSDL_Event user_event;\r\n\r\nvptr->vid_rect.h = h;\r\nvptr->vid_rect.w = w;\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.windowID = vptr->vid_windowID;\r\nuser_event.user.code = EVENT_LOGICAL;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (100);\r\n#else\r\n    SDL_RenderSetLogicalSize(vptr->vid_renderer, w, h);\r\n#endif\r\n}\r\n\r\nt_bool vid_is_fullscreen_window (VID_DISPLAY *vptr)\r\n{\r\nreturn SDL_GetWindowFlags (vptr->vid_window) & SDL_WINDOW_FULLSCREEN_DESKTOP;\r\n}\r\n\r\nt_bool vid_is_fullscreen (void)\r\n{\r\nreturn vid_is_fullscreen_window (&vid_first);\r\n}\r\n\r\nt_stat vid_set_fullscreen_window (VID_DISPLAY *vptr, t_bool flag)\r\n{\r\nSDL_Event user_event;\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.windowID = vptr->vid_windowID;\r\nuser_event.user.code = EVENT_FULLSCREEN;\r\nuser_event.user.data1 = (flag) ? vptr : NULL;\r\nuser_event.user.data2 = NULL;\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (100);\r\n#else\r\nif (flag)\r\n    SDL_SetWindowFullscreen (vptr->vid_window, SDL_WINDOW_FULLSCREEN_DESKTOP);\r\nelse\r\n    SDL_SetWindowFullscreen (vptr->vid_window, 0);\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_set_fullscreen (t_bool flag)\r\n{\r\nreturn vid_set_fullscreen_window (&vid_first, flag);\r\n}\r\n\r\nstatic void vid_stretch(VID_DISPLAY *vptr, SDL_Rect *r)\r\n{\r\n/* Return in r a rectangle with the same aspect ratio as the video\r\n   buffer but scaled to fit precisely in the output window.  Normally,\r\n   the buffer and the window have the same sizes, but if the window is\r\n   resized, or fullscreen is in effect, they are not. */\r\nint w, h;\r\nSDL_GetRendererOutputSize(vptr->vid_renderer, &w, &h);\r\nif ((double)h / vptr->vid_height < (double)w / vptr->vid_width) {\r\n    r->w = vptr->vid_width * h / vptr->vid_height;\r\n    r->h = h;\r\n    r->x = (w - r->w) / 2;\r\n    r->y = 0;\r\n    }\r\nelse {\r\n    r->w = w;\r\n    r->h = vptr->vid_height * w / vptr->vid_width;\r\n    r->x = 0;\r\n    r->y = (h - r->h) / 2;\r\n    }\r\nif (vptr->vid_flags & SIM_VID_IGNORE_VBAR) {\r\n    r->w = w;\r\n    r->h = h;\r\n    r->x = 0;\r\n    r->y = 0;\r\n    }\r\n}\r\n\r\nvoid vid_update (VID_DISPLAY *vptr)\r\n{\r\nSDL_Rect vid_dst;\r\nvid_stretch(vptr, &vid_dst);\r\nsim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"Video Update Event: \\n\");\r\nif (sim_deb)\r\n    fflush (sim_deb);\r\nif (vptr->vid_blending)\r\n    SDL_RenderPresent (vptr->vid_renderer);\r\nelse {\r\n    if (SDL_RenderClear (vptr->vid_renderer))\r\n        sim_printf (\"%s: Video Update Event: SDL_RenderClear error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    if (SDL_RenderCopy (vptr->vid_renderer, vptr->vid_texture, NULL, &vid_dst))\r\n        sim_printf (\"%s: Video Update Event: SDL_RenderCopy error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    SDL_RenderPresent (vptr->vid_renderer);\r\n    }\r\n}\r\n\r\nvoid vid_update_cursor (VID_DISPLAY *vptr, SDL_Cursor *cursor, t_bool visible)\r\n{\r\nif (!cursor)\r\n    return;\r\nsim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"Cursor Update Event: Previously %s, Now %s, New Cursor object at: %p, Old Cursor object at: %p\\n\",\r\n                            SDL_ShowCursor(-1) ? \"visible\" : \"invisible\", visible ? \"visible\" : \"invisible\", cursor, vptr->vid_cursor);\r\nSDL_SetCursor (cursor);\r\nif ((vptr->vid_window == SDL_GetMouseFocus ()) && visible)\r\n    SDL_WarpMouseInWindow (NULL, vid_cursor_x, vid_cursor_y);/* sync position */\r\nif ((vptr->vid_cursor != cursor) && (vptr->vid_cursor))\r\n    SDL_FreeCursor (vptr->vid_cursor);\r\nvptr->vid_cursor = cursor;\r\nSDL_ShowCursor (visible);\r\nvptr->vid_cursor_visible = visible;\r\n}\r\n\r\nvoid vid_warp_position (VID_DISPLAY *vptr)\r\n{\r\nsim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"Mouse Warp Event: Warp to: (%d,%d)\\n\", vid_cursor_x, vid_cursor_y);\r\n\r\nSDL_PumpEvents ();\r\nSDL_WarpMouseInWindow (NULL, vid_cursor_x, vid_cursor_y);\r\nSDL_PumpEvents ();\r\n}\r\n\r\nvoid vid_draw_region (VID_DISPLAY *vptr, SDL_UserEvent *event)\r\n{\r\nSDL_Rect *vid_dst = (SDL_Rect *)event->data1;\r\nuint32 *buf = (uint32 *)event->data2;\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"Draw Region Event: (%d,%d,%d,%d)\\n\", vid_dst->x, vid_dst->x, vid_dst->w, vid_dst->h);\r\n\r\nSDL_LockMutex (vptr->vid_draw_mutex);\r\nif (vid_dst == vptr->vid_dst_last) {\r\n    vptr->vid_dst_last = NULL;\r\n    vptr->vid_data_last = NULL;\r\n    }\r\nSDL_UnlockMutex (vptr->vid_draw_mutex);\r\n\r\nif (vptr->vid_blending) {\r\n    SDL_UpdateTexture(vptr->vid_texture, vid_dst, buf, vid_dst->w*sizeof(*buf));\r\n    SDL_RenderCopy (vptr->vid_renderer, vptr->vid_texture, vid_dst, vid_dst);\r\n    }\r\nelse\r\n    if (SDL_UpdateTexture(vptr->vid_texture, vid_dst, buf, vid_dst->w*sizeof(*buf)))\r\n        sim_printf (\"%s: vid_draw_region() - SDL_UpdateTexture error: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n\r\nfree (vid_dst);\r\nfree (buf);\r\nevent->data1 = NULL;\r\n}\r\n\r\nstatic int vid_new_window (VID_DISPLAY *vptr)\r\n{\r\nSDL_CreateWindowAndRenderer (vptr->vid_width, vptr->vid_height, SDL_WINDOW_SHOWN, &vptr->vid_window, &vptr->vid_renderer);\r\n\r\nif ((vptr->vid_window == NULL) || (vptr->vid_renderer == NULL)) {\r\n    sim_printf (\"%s: Error Creating Video Window: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    SDL_Quit ();\r\n    return 0;\r\n    }\r\n\r\nvptr->vid_draw_mutex = SDL_CreateMutex();\r\n\r\nif (vptr->vid_draw_mutex == NULL) {\r\n    fprintf (stderr, \"%s: SDL_CreateMutex failed: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError ());\r\n    SDL_Quit ();\r\n    return 0;\r\n    }\r\n\r\nSDL_SetRenderDrawColor (vptr->vid_renderer, 0, 0, 0, 255);\r\nSDL_RenderClear (vptr->vid_renderer);\r\nSDL_RenderPresent (vptr->vid_renderer);\r\n\r\nvptr->vid_texture = SDL_CreateTexture (vptr->vid_renderer,\r\n                                 SDL_PIXELFORMAT_ARGB8888,\r\n                                 SDL_TEXTUREACCESS_STREAMING,\r\n                                 vptr->vid_width, vptr->vid_height);\r\nif (!vptr->vid_texture) {\r\n    sim_printf (\"%s: Error configuring Video environment: %s\\n\", vid_dname(vptr->vid_dev), SDL_GetError());\r\n    SDL_DestroyRenderer(vptr->vid_renderer);\r\n    vptr->vid_renderer = NULL;\r\n    SDL_DestroyWindow(vptr->vid_window);\r\n    vptr->vid_window = NULL;\r\n    SDL_Quit ();\r\n    return 0;\r\n    }\r\n\r\nvptr->vid_format = SDL_AllocFormat (SDL_PIXELFORMAT_ARGB8888);\r\n\r\n#ifdef SDL_WINDOW_RESIZABLE\r\nif (vptr->vid_flags & SIM_VID_RESIZABLE) {\r\n    SDL_SetWindowResizable(vptr->vid_window, SDL_TRUE);\r\n    SDL_RenderSetIntegerScale(vptr->vid_renderer, SDL_TRUE);\r\n}\r\n#endif\r\n\r\nSDL_StopTextInput ();\r\n\r\nvptr->vid_windowID = SDL_GetWindowID (vptr->vid_window);\r\n\r\nif (vptr->vid_flags & SIM_VID_INPUTCAPTURED) {\r\n    char title[150];\r\n\r\n    memset (title, 0, sizeof(title));\r\n    strlcpy (title, vptr->vid_title, sizeof(title));\r\n    strlcat (title, \"                                             ReleaseKey=\", sizeof(title));\r\n    strlcat (title, vid_release_key, sizeof(title));\r\n    SDL_SetWindowTitle (vptr->vid_window, title);\r\n    }\r\nelse\r\n    SDL_SetWindowTitle (vptr->vid_window, vptr->vid_title);\r\n\r\nmemset (&vptr->vid_key_state, 0, sizeof(vptr->vid_key_state));\r\nvptr->vid_dst_last = NULL;\r\nvptr->vid_data_last = NULL;\r\n\r\nvid_active++;\r\nreturn 1;\r\n}\r\n\r\nt_stat vid_set_alpha_mode (VID_DISPLAY *vptr, int mode)\r\n{\r\nSDL_BlendMode x;\r\nswitch (mode) {\r\n    case SIM_ALPHA_NONE:\r\n        vptr->vid_blending = FALSE;\r\n        x = SDL_BLENDMODE_NONE;\r\n        break;\r\n    case SIM_ALPHA_BLEND:\r\n        vptr->vid_blending = TRUE;\r\n        x = SDL_BLENDMODE_BLEND;\r\n        break;\r\n    case SIM_ALPHA_ADD:\r\n        vptr->vid_blending = TRUE;\r\n        x = SDL_BLENDMODE_ADD;\r\n        break;\r\n    case SIM_ALPHA_MOD:\r\n        vptr->vid_blending = TRUE;\r\n        x = SDL_BLENDMODE_MOD;\r\n        break;\r\n    default:\r\n        return SCPE_ARG;\r\n    }\r\nif (SDL_SetTextureBlendMode (vptr->vid_texture, x))\r\n    return SCPE_IERR;\r\nif (SDL_SetRenderDrawBlendMode (vptr->vid_renderer, x))\r\n    return SCPE_IERR;\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic void vid_destroy (VID_DISPLAY *vptr)\r\n{\r\nVID_DISPLAY *parent;\r\nvptr->vid_ready = FALSE;\r\nif (vptr->vid_cursor) {\r\n    SDL_FreeCursor (vptr->vid_cursor);\r\n    vptr->vid_cursor = NULL;\r\n    }\r\nSDL_DestroyTexture(vptr->vid_texture);\r\nvptr->vid_texture = NULL;\r\nSDL_DestroyRenderer(vptr->vid_renderer);\r\nvptr->vid_renderer = NULL;\r\nSDL_DestroyWindow(vptr->vid_window);\r\nvptr->vid_window = NULL;\r\nSDL_DestroyMutex (vptr->vid_draw_mutex);\r\nvptr->vid_draw_mutex = NULL;\r\nfor (parent = &vid_first; parent != NULL; parent = parent->next) {\r\n    if (parent->next == vptr)\r\n        parent->next = vptr->next;\r\n    }\r\nvid_active--;\r\n}\r\n\r\nint vid_video_events (VID_DISPLAY *vptr0)\r\n{\r\nSDL_Event event;\r\nstatic const char *eventtypes[SDL_LASTEVENT];\r\nstatic const char *windoweventtypes[256];\r\nstatic t_bool initialized = FALSE;\r\n\r\nif (!initialized) {\r\n    initialized = TRUE;\r\n\r\n    eventtypes[SDL_QUIT] = \"QUIT\";          /**< User-requested quit */\r\n\r\n    /* These application events have special meaning on iOS, see README-ios.txt for details */\r\n    eventtypes[SDL_APP_TERMINATING] = \"APP_TERMINATING\";   /**< The application is being terminated by the OS\r\n                                     Called on iOS in applicationWillTerminate()\r\n                                     Called on Android in onDestroy()\r\n                                */\r\n    eventtypes[SDL_APP_LOWMEMORY] = \"APP_LOWMEMORY\";          /**< The application is low on memory, free memory if possible.\r\n                                     Called on iOS in applicationDidReceiveMemoryWarning()\r\n                                     Called on Android in onLowMemory()\r\n                                */\r\n    eventtypes[SDL_APP_WILLENTERBACKGROUND] = \"APP_WILLENTERBACKGROUND\"; /**< The application is about to enter the background\r\n                                     Called on iOS in applicationWillResignActive()\r\n                                     Called on Android in onPause()\r\n                                */\r\n    eventtypes[SDL_APP_DIDENTERBACKGROUND] = \"APP_DIDENTERBACKGROUND\"; /**< The application did enter the background and may not get CPU for some time\r\n                                     Called on iOS in applicationDidEnterBackground()\r\n                                     Called on Android in onPause()\r\n                                */\r\n    eventtypes[SDL_APP_WILLENTERFOREGROUND] = \"APP_WILLENTERFOREGROUND\"; /**< The application is about to enter the foreground\r\n                                     Called on iOS in applicationWillEnterForeground()\r\n                                     Called on Android in onResume()\r\n                                */\r\n    eventtypes[SDL_APP_DIDENTERFOREGROUND] = \"APP_DIDENTERFOREGROUND\"; /**< The application is now interactive\r\n                                     Called on iOS in applicationDidBecomeActive()\r\n                                     Called on Android in onResume()\r\n                                */\r\n\r\n    /* Window events */\r\n    eventtypes[SDL_WINDOWEVENT] = \"WINDOWEVENT\"; /**< Window state change */\r\n    eventtypes[SDL_SYSWMEVENT] = \"SYSWMEVENT\";             /**< System specific event */\r\n\r\n    windoweventtypes[SDL_WINDOWEVENT_NONE] = \"NONE\";                /**< Never used */\r\n    windoweventtypes[SDL_WINDOWEVENT_SHOWN] = \"SHOWN\";              /**< Window has been shown */\r\n    windoweventtypes[SDL_WINDOWEVENT_HIDDEN] = \"HIDDEN\";            /**< Window has been hidden */\r\n    windoweventtypes[SDL_WINDOWEVENT_EXPOSED] = \"EXPOSED\";          /**< Window has been exposed and should be\r\n                                                                         redrawn */\r\n    windoweventtypes[SDL_WINDOWEVENT_MOVED] = \"MOVED\";              /**< Window has been moved to data1, data2\r\n                                     */\r\n    windoweventtypes[SDL_WINDOWEVENT_RESIZED] = \"RESIZED\";          /**< Window has been resized to data1xdata2 */\r\n    windoweventtypes[SDL_WINDOWEVENT_SIZE_CHANGED] = \"SIZE_CHANGED\";/**< The window size has changed, either as a result of an API call or through the system or user changing the window size. */\r\n    windoweventtypes[SDL_WINDOWEVENT_MINIMIZED] = \"MINIMIZED\";      /**< Window has been minimized */\r\n    windoweventtypes[SDL_WINDOWEVENT_MAXIMIZED] = \"MAXIMIZED\";      /**< Window has been maximized */\r\n    windoweventtypes[SDL_WINDOWEVENT_RESTORED] = \"RESTORED\";        /**< Window has been restored to normal size\r\n                                                                         and position */\r\n    windoweventtypes[SDL_WINDOWEVENT_ENTER] = \"ENTER\";              /**< Window has gained mouse focus */\r\n    windoweventtypes[SDL_WINDOWEVENT_LEAVE] = \"LEAVE\";              /**< Window has lost mouse focus */\r\n    windoweventtypes[SDL_WINDOWEVENT_FOCUS_GAINED] = \"FOCUS_GAINED\";/**< Window has gained keyboard focus */\r\n    windoweventtypes[SDL_WINDOWEVENT_FOCUS_LOST] = \"FOCUS_LOST\";    /**< Window has lost keyboard focus */\r\n    windoweventtypes[SDL_WINDOWEVENT_CLOSE] = \"CLOSE\";              /**< The window manager requests that the\r\n                                                                         window be closed */\r\n\r\n    /* Keyboard events */\r\n    eventtypes[SDL_KEYDOWN] = \"KEYDOWN\";                            /**< Key pressed */\r\n    eventtypes[SDL_KEYUP] = \"KEYUP\";                                /**< Key released */\r\n    eventtypes[SDL_TEXTEDITING] = \"TEXTEDITING\";                    /**< Keyboard text editing (composition) */\r\n    eventtypes[SDL_TEXTINPUT] = \"TEXTINPUT\";                        /**< Keyboard text input */\r\n\r\n    /* Mouse events */\r\n    eventtypes[SDL_MOUSEMOTION] = \"MOUSEMOTION\";                    /**< Mouse moved */\r\n    eventtypes[SDL_MOUSEBUTTONDOWN] = \"MOUSEBUTTONDOWN\";            /**< Mouse button pressed */\r\n    eventtypes[SDL_MOUSEBUTTONUP] = \"MOUSEBUTTONUP\";                /**< Mouse button released */\r\n    eventtypes[SDL_MOUSEWHEEL] = \"MOUSEWHEEL\";                      /**< Mouse wheel motion */\r\n\r\n    /* Joystick events */\r\n    eventtypes[SDL_JOYAXISMOTION] = \"JOYAXISMOTION\";                /**< Joystick axis motion */\r\n    eventtypes[SDL_JOYBALLMOTION] = \"JOYBALLMOTION\";                /**< Joystick trackball motion */\r\n    eventtypes[SDL_JOYHATMOTION] = \"JOYHATMOTION\";                  /**< Joystick hat position change */\r\n    eventtypes[SDL_JOYBUTTONDOWN] = \"JOYBUTTONDOWN\";                /**< Joystick button pressed */\r\n    eventtypes[SDL_JOYBUTTONUP] = \"JOYBUTTONUP\";                    /**< Joystick button released */\r\n    eventtypes[SDL_JOYDEVICEADDED] = \"JOYDEVICEADDED\";              /**< A new joystick has been inserted into the system */\r\n    eventtypes[SDL_JOYDEVICEREMOVED] = \"JOYDEVICEREMOVED\";          /**< An opened joystick has been removed */\r\n\r\n    /* Game controller events */\r\n    eventtypes[SDL_CONTROLLERAXISMOTION] = \"CONTROLLERAXISMOTION\";          /**< Game controller axis motion */\r\n    eventtypes[SDL_CONTROLLERBUTTONDOWN] = \"CONTROLLERBUTTONDOWN\";          /**< Game controller button pressed */\r\n    eventtypes[SDL_CONTROLLERBUTTONUP] = \"CONTROLLERBUTTONUP\";              /**< Game controller button released */\r\n    eventtypes[SDL_CONTROLLERDEVICEADDED] = \"CONTROLLERDEVICEADDED\";        /**< A new Game controller has been inserted into the system */\r\n    eventtypes[SDL_CONTROLLERDEVICEREMOVED] = \"CONTROLLERDEVICEREMOVED\";    /**< An opened Game controller has been removed */\r\n    eventtypes[SDL_CONTROLLERDEVICEREMAPPED] = \"CONTROLLERDEVICEREMAPPED\";  /**< The controller mapping was updated */\r\n\r\n    /* Touch events */\r\n    eventtypes[SDL_FINGERDOWN] = \"FINGERDOWN\";\r\n    eventtypes[SDL_FINGERUP] = \"FINGERUP\";\r\n    eventtypes[SDL_FINGERMOTION] = \"FINGERMOTION\";\r\n\r\n    /* Gesture events */\r\n    eventtypes[SDL_DOLLARGESTURE] = \"DOLLARGESTURE\";\r\n    eventtypes[SDL_DOLLARRECORD] = \"DOLLARRECORD\";\r\n    eventtypes[SDL_MULTIGESTURE] = \"MULTIGESTURE\";\r\n\r\n    /* Clipboard events */\r\n    eventtypes[SDL_CLIPBOARDUPDATE] = \"CLIPBOARDUPDATE\"; /**< The clipboard changed */\r\n\r\n    /* Drag and drop events */\r\n    eventtypes[SDL_DROPFILE] = \"DROPFILE\"; /**< The system requests a file open */\r\n\r\n#if (SDL_MINOR_VERSION > 0) || (SDL_PATCHLEVEL >= 3)\r\n    /* Render events */\r\n    eventtypes[SDL_RENDER_TARGETS_RESET] = \"RENDER_TARGETS_RESET\"; /**< The render targets have been reset */\r\n#endif\r\n\r\n#if (SDL_MINOR_VERSION > 0) || (SDL_PATCHLEVEL >= 4)\r\n    /* Render events */\r\n    eventtypes[SDL_RENDER_DEVICE_RESET] = \"RENDER_DEVICE_RESET\"; /**< The render device has been reset */\r\n#endif\r\n\r\n    /** Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,\r\n     *  and should be allocated with SDL_RegisterEvents()\r\n     */\r\n    eventtypes[SDL_USEREVENT] = \"USEREVENT\";\r\n\r\n    /**\r\n     * The SDL_HINT_VIDEO_ALLOW_SCREENSAVER at init time enables\r\n     * the screensaver.  Once a video window is created, we default\r\n     * to being consistent with behavior since SDL 2.0.2 and we disable\r\n     * the screen saver.\r\n     *\r\n     * We allow an environment variable SDL_VIDEO_ALLOW_SCREENSAVER\r\n     * to specifically change this to enable the screensaver if the\r\n     * value is \"1\".\r\n     */\r\n    if ((getenv (\"SDL_VIDEO_ALLOW_SCREENSAVER\") == NULL) ||\r\n        (strcmp (getenv (\"SDL_VIDEO_ALLOW_SCREENSAVER\"), \"1\") != 0)) {\r\n        if (SDL_IsScreenSaverEnabled () == SDL_TRUE)\r\n            SDL_DisableScreenSaver ();\r\n        }\r\n    else {\r\n        if (SDL_IsScreenSaverEnabled () == SDL_FALSE)\r\n            SDL_EnableScreenSaver ();\r\n        }\r\n    }\r\n\r\nsim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE, vptr0->vid_dev, \"vid_thread() - Starting\\n\");\r\n\r\nsim_os_set_thread_priority (PRIORITY_ABOVE_NORMAL);\r\n\r\nif (!vid_new_window (vptr0)) {\r\n    return 0;\r\n    }\r\n\r\nvid_beep_setup (400, 660);\r\nvid_controllers_setup (vptr0->vid_dev);\r\n\r\nvptr0->vid_ready = TRUE;\r\nsim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE|SIM_VID_DBG_CURSOR, vptr0->vid_dev, \"vid_thread() - Started\\n\");\r\n\r\nwhile (vid_active) {\r\n    int status = SDL_WaitEvent (&event);\r\n    if (status == 1) {\r\n        VID_DISPLAY *vptr;\r\n        switch (event.type) {\r\n\r\n            case SDL_KEYDOWN:\r\n            case SDL_KEYUP:\r\n                vid_key (&event.key);\r\n                break;\r\n\r\n            case SDL_MOUSEBUTTONDOWN:\r\n            case SDL_MOUSEBUTTONUP:\r\n                vid_mouse_button (&event.button);\r\n                break;\r\n\r\n            case SDL_MOUSEMOTION:\r\n                vid_mouse_move (&event.motion);\r\n                break;\r\n\r\n            case SDL_JOYAXISMOTION:\r\n                vid_joy_motion (&event.jaxis);\r\n                break;\r\n\r\n            case SDL_JOYBUTTONUP:\r\n            case SDL_JOYBUTTONDOWN:\r\n                vid_joy_button (&event.jbutton);\r\n                break;\r\n\r\n            case SDL_CONTROLLERAXISMOTION:\r\n                vid_controller_motion (&event.caxis);\r\n                break;\r\n\r\n            case SDL_CONTROLLERBUTTONUP:\r\n            case SDL_CONTROLLERBUTTONDOWN:\r\n                vid_controller_button (&event.cbutton);\r\n                break;\r\n\r\n            case SDL_WINDOWEVENT:\r\n                vptr = vid_get_event_window (&event, event.window.windowID);\r\n                if (vptr != NULL) {\r\n                    sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE|SIM_VID_DBG_CURSOR, vptr->vid_dev, \"vid_thread() - Window Event: %d - %s\\n\", event.window.event, windoweventtypes[event.window.event]);\r\n                    switch (event.window.event) {\r\n                        case SDL_WINDOWEVENT_ENTER:\r\n                             if (vptr->vid_flags & SIM_VID_INPUTCAPTURED)\r\n                                 SDL_WarpMouseInWindow (NULL, vptr->vid_width/2, vptr->vid_height/2);   /* center position */\r\n                            break;\r\n                        case SDL_WINDOWEVENT_EXPOSED:\r\n                            vid_update (vptr);\r\n                            break;\r\n                        case SDL_WINDOWEVENT_SIZE_CHANGED:\r\n                            vid_update (vptr);\r\n                            break;\r\n                        default:\r\n                            sim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"Did not handle window event: %d - %s\\n\", event.window.event, windoweventtypes[event.window.event]);\r\n                            break;\r\n                        }\r\n                    }\r\n                break;\r\n\r\n            case SDL_USEREVENT:\r\n                /* There are 11 user events generated */\r\n                /* EVENT_REDRAW      to update the display */\r\n                /* EVENT_DRAW        to update a region in the display texture */\r\n                /* EVENT_SHOW        to display the current SDL video capabilities */\r\n                /* EVENT_CURSOR      to change the current cursor */\r\n                /* EVENT_WARP        to warp the cursor position */\r\n                /* EVENT_OPEN        to open a new window */\r\n                /* EVENT_CLOSE       to wake up this thread and let */\r\n                /*                   it notice vid_active has changed */\r\n                /* EVENT_SCREENSHOT  to take a screenshot */\r\n                /* EVENT_BEEP        to emit a beep sound */\r\n                /* EVENT_FULLSCREEN  to change fullscreen */\r\n                /* EVENT_SIZE        to change screen size */\r\n                /* EVENT_LOGICAL     to change screen size */\r\n                while (vid_active && event.user.code) {\r\n                    /* Handle Beep first since it isn't a window oriented event */\r\n                    if (event.user.code == EVENT_BEEP) {\r\n                        vid_beep_event ();\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        continue;\r\n                        }\r\n                    if (event.user.code != EVENT_OPEN) {\r\n                        vptr = vid_get_event_window (&event, event.user.windowID);\r\n                        if (vptr == NULL) {\r\n                            sim_printf (\"vid_thread() - Ignored event not bound to a window\\n\");\r\n                            event.user.code = 0;    /* Mark as done */\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (event.user.code == EVENT_REDRAW) {\r\n                        vptr = vid_get_event_window (&event, event.user.windowID);\r\n                        vid_update (vptr);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        while (SDL_PeepEvents (&event, 1, SDL_GETEVENT, SDL_USEREVENT, SDL_USEREVENT)) {\r\n                            if ((event.user.code == EVENT_REDRAW) &&\r\n                                (vptr == vid_get_event_window (&event, event.user.windowID))) {\r\n                                /* Only do a single video update to the same window between waiting for events */\r\n                                sim_debug (SIM_VID_DBG_VIDEO, vptr->vid_dev, \"vid_thread() - Ignored extra REDRAW Event\\n\");\r\n                                event.user.code = 0;    /* Mark as done */\r\n                                continue;\r\n                                }\r\n                            break;\r\n                            }\r\n                        }\r\n                    if (event.user.code == EVENT_CURSOR) {\r\n                        vid_update_cursor (vptr, (SDL_Cursor *)(event.user.data1), (t_bool)((size_t)event.user.data2));\r\n                        event.user.data1 = NULL;\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_WARP) {\r\n                        vid_warp_position (vptr);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_CLOSE) {\r\n                        vid_destroy (vptr);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_DRAW) {\r\n                        vid_draw_region (vptr, (SDL_UserEvent*)&event);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_SHOW) {\r\n                        vid_show_video_event ();\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_SCREENSHOT) {\r\n                        vid_screenshot_event ();\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_SIZE) {\r\n                        SDL_SetWindowSize (vptr->vid_window, vptr->vid_rect.w, vptr->vid_rect.h);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_LOGICAL) {\r\n                        SDL_RenderSetLogicalSize (vptr->vid_renderer, vptr->vid_rect.w, vptr->vid_rect.h);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_FULLSCREEN) {\r\n                        if (event.user.data1 != NULL)\r\n                            SDL_SetWindowFullscreen (vptr->vid_window, SDL_WINDOW_FULLSCREEN_DESKTOP);\r\n                        else\r\n                            SDL_SetWindowFullscreen (vptr->vid_window, 0);\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_BEEP) {\r\n                        vid_beep_event ();\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code == EVENT_OPEN) {\r\n                        VID_DISPLAY *vptr = (VID_DISPLAY *)event.user.data1;\r\n                        vid_new_window (vptr);\r\n                        vptr->vid_ready = TRUE;\r\n                        event.user.code = 0;    /* Mark as done */\r\n                        }\r\n                    if (event.user.code != 0) {\r\n                        sim_printf (\"vid_thread(): Unexpected user event code: %d\\n\", event.user.code);\r\n                        }\r\n                    }\r\n                break;\r\n            case SDL_QUIT:\r\n                sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE|SIM_VID_DBG_CURSOR, vptr0->vid_dev, \"vid_thread() - QUIT Event - %s\\n\", vid_quit_callback ? \"Signaled\" : \"Ignored\");\r\n                if (vid_quit_callback)\r\n                    vid_quit_callback ();\r\n                break;\r\n\r\n            default:\r\n                sim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE|SIM_VID_DBG_CURSOR, vptr0->vid_dev, \"vid_thread() - Ignored Event: Type: %s(%d)\\n\", eventtypes[event.type], event.type);\r\n                break;\r\n            }\r\n        }\r\n    else {\r\n        if (status < 0)\r\n            sim_printf (\"%s: vid_thread() - SDL_WaitEvent error: %s\\n\", vid_dname(vptr0->vid_dev), SDL_GetError());\r\n        }\r\n    }\r\nvid_controllers_cleanup ();\r\nvid_beep_cleanup ();\r\nsim_debug (SIM_VID_DBG_VIDEO|SIM_VID_DBG_KEY|SIM_VID_DBG_MOUSE|SIM_VID_DBG_CURSOR, vptr0->vid_dev, \"vid_thread() - Exiting\\n\");\r\nreturn 0;\r\n}\r\n\r\nint vid_thread (void *arg)\r\n{\r\nVID_DISPLAY *vptr = (VID_DISPLAY *)arg;\r\nint stat;\r\n\r\nSDL_SetHint (SDL_HINT_RENDER_DRIVER, \"software\");\r\n\r\nstat = SDL_Init (SDL_INIT_VIDEO);\r\n\r\nif (stat) {\r\n    sim_printf (\"SDL Video subsystem can't initialize\\n\");\r\n    return 0;\r\n    }\r\nvid_video_events (vptr);\r\nSDL_Quit ();\r\nreturn 0;\r\n}\r\n\r\n/* Optionally dynamically locate and load png support */\r\n#if defined(SIM_HAVE_DLOPEN)\r\n#include <dlfcn.h>\r\n#endif\r\n\r\nconst char *vid_version(void)\r\n{\r\nstatic char SDLVersion[200];\r\nSDL_version compiled = { 0}, running = { 0};\r\n\r\nif (SDLVersion[0] != '\\0')              /* If we already did this, */\r\n    return (const char *)SDLVersion;    /*  the result will be the same */\r\n\r\n#if defined(SIM_DLOPEN_EXTENSION) && defined(HAVE_LIBPNG)\r\nif (1) {\r\n    struct PNG_Entry *p;\r\n    void *hPNGLib = 0;                 /* handle to Library */\r\n\r\n#if defined(SIM_DLOPEN_EXTENSION)\r\n    hPNGLib = dlopen(\"libpng.\" __STR(SIM_DLOPEN_EXTENSION), RTLD_NOW|RTLD_GLOBAL);\r\n    if (!hPNGLib)\r\n        hPNGLib = dlopen(\"libpng.\" __STR(SIM_DLOPEN_EXTENSION) \".2\", RTLD_NOW|RTLD_GLOBAL);\r\n    if (!hPNGLib)\r\n        hPNGLib = dlopen(\"libpng.\" __STR(SIM_DLOPEN_EXTENSION) \".3\", RTLD_NOW|RTLD_GLOBAL);\r\n#endif\r\n\r\n    for (p = libpng_entries; p->entry_name != NULL; p++) {\r\n        if (*p->entry_pointer == NULL)\r\n            *p->entry_pointer = dlsym(hPNGLib, p->entry_name);\r\n        }\r\n    }\r\n#endif /* defined(SIM_DLOPEN_EXTENSION) && defined(HAVE_LIBPNG) */\r\n\r\nsim_libpng_available = (*libpng_entries->entry_pointer != NULL);\r\nSDL_GetVersion(&running);\r\n\r\nSDL_VERSION(&compiled);\r\n\r\nSDLVersion[sizeof (SDLVersion) - 1] = '\\0';\r\nif ((compiled.major == running.major) &&\r\n    (compiled.minor == running.minor) &&\r\n    (compiled.patch == running.patch))\r\n    snprintf(SDLVersion, sizeof (SDLVersion) - 1, \"SDL Version %d.%d.%d\",\r\n                        compiled.major, compiled.minor, compiled.patch);\r\nelse\r\n    snprintf(SDLVersion, sizeof (SDLVersion) - 1, \"SDL Version (Compiled: %d.%d.%d, Runtime: %d.%d.%d)\",\r\n                        compiled.major, compiled.minor, compiled.patch,\r\n                        running.major, running.minor, running.patch);\r\n#if defined (HAVE_LIBPNG)\r\nif (sim_libpng_available) {\r\n    png_structp png = p_png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\r\n\r\n    if (strcmp (PNG_LIBPNG_VER_STRING, p_png_get_libpng_ver (png))) {\r\n        snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                            \", PNG Version (Compiled: %s, Runtime: %s - png screenshots disabled)\",\r\n                            PNG_LIBPNG_VER_STRING, p_png_get_libpng_ver (png));\r\n        sim_libpng_available = FALSE;\r\n        }\r\n    else\r\n        snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                            \", PNG Version %s\", PNG_LIBPNG_VER_STRING);\r\n    p_png_destroy_read_struct(&png, NULL, NULL);\r\n#if defined (ZLIB_VERSION)\r\n    if (strcmp (ZLIB_VERSION, p_zlibVersion ()))\r\n        snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                            \", zlib: (Compiled: %s, Runtime: %s)\", ZLIB_VERSION, p_zlibVersion ());\r\n    else\r\n        snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                            \", zlib: %s\", ZLIB_VERSION);\r\n#endif\r\n    }\r\nelse\r\n    snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                        \", PNG Not currently available\");\r\n#endif\r\nreturn (const char *)SDLVersion;\r\n}\r\n\r\nt_stat vid_set_release_key (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nt_stat vid_show_release_key (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nVID_DISPLAY *vptr;\r\nfor (vptr = &vid_first; vptr != NULL; vptr = vptr->next) {\r\n    if (vptr->vid_flags & SIM_VID_INPUTCAPTURED) {\r\n        fprintf (st, \"ReleaseKey=%s\", vid_release_key);\r\n        return SCPE_OK;\r\n        }\r\n    }\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat _vid_show_video (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nint i;\r\nVID_DISPLAY *vptr;\r\n\r\nfprintf (st, \"Video support using SDL: %s\\n\", vid_version());\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nfprintf (st, \"  SDL Events being processed on the main process thread\\n\");\r\n#endif\r\nif (!vid_active) {\r\n#if !defined (SDL_MAIN_AVAILABLE)\r\n    int stat = SDL_Init(SDL_INIT_VIDEO);\r\n\r\n    if (stat)\r\n        return sim_messagef (SCPE_OPENERR, \"SDL_Init() failed.  Video subsystem is unavailable.\\n\");\r\n#endif\r\n    }\r\nelse {\r\n    for (vptr = &vid_first; vptr != NULL; vptr = vptr->next) {\r\n        if (!vptr->vid_active_window)\r\n            continue;\r\n        fprintf (st, \"  Currently Active Video Window: (%d by %d pixels)\\n\", vptr->vid_width, vptr->vid_height);\r\n        fprintf (st, \"  \");\r\n        vid_show_release_key (st, uptr, val, desc);\r\n        }\r\n    fprintf (st, \"\\n\");\r\n    fprintf (st, \"  SDL Video Driver: %s\\n\", SDL_GetCurrentVideoDriver());\r\n    }\r\nfor (i = 0; i < SDL_GetNumVideoDisplays(); ++i) {\r\n    SDL_DisplayMode display;\r\n\r\n    if (SDL_GetCurrentDisplayMode(i, &display)) {\r\n        fprintf (st, \"Could not get display mode for video display #%d: %s\", i, SDL_GetError());\r\n        }\r\n    else {\r\n        fprintf (st, \"  Display %s(#%d): current display mode is %dx%dpx @ %dhz. \\n\", SDL_GetDisplayName(i), i, display.w, display.h, display.refresh_rate);\r\n        }\r\n    }\r\nfprintf (st, \"  Available SDL Renderers:\\n\");\r\nfor (i = 0; i < SDL_GetNumRenderDrivers(); ++i) {\r\n    SDL_RendererInfo info;\r\n\r\n    if (SDL_GetRenderDriverInfo (i, &info)) {\r\n        fprintf (st, \"Could not get render driver info for driver #%d: %s\", i, SDL_GetError());\r\n        }\r\n    else {\r\n        uint32 j, k;\r\n        static struct {uint32 format; const char *name;} PixelFormats[] = {\r\n            {SDL_PIXELFORMAT_INDEX1LSB,     \"Index1LSB\"},\r\n            {SDL_PIXELFORMAT_INDEX1MSB,     \"Index1MSB\"},\r\n            {SDL_PIXELFORMAT_INDEX4LSB,     \"Index4LSB\"},\r\n            {SDL_PIXELFORMAT_INDEX4MSB,     \"Index4MSB\"},\r\n            {SDL_PIXELFORMAT_INDEX8,        \"Index8\"},\r\n            {SDL_PIXELFORMAT_RGB332,        \"RGB332\"},\r\n            {SDL_PIXELFORMAT_RGB444,        \"RGB444\"},\r\n            {SDL_PIXELFORMAT_RGB555,        \"RGB555\"},\r\n            {SDL_PIXELFORMAT_BGR555,        \"BGR555\"},\r\n            {SDL_PIXELFORMAT_ARGB4444,      \"ARGB4444\"},\r\n            {SDL_PIXELFORMAT_RGBA4444,      \"RGBA4444\"},\r\n            {SDL_PIXELFORMAT_ABGR4444,      \"ABGR4444\"},\r\n            {SDL_PIXELFORMAT_BGRA4444,      \"BGRA4444\"},\r\n            {SDL_PIXELFORMAT_ARGB1555,      \"ARGB1555\"},\r\n            {SDL_PIXELFORMAT_RGBA5551,      \"RGBA5551\"},\r\n            {SDL_PIXELFORMAT_ABGR1555,      \"ABGR1555\"},\r\n            {SDL_PIXELFORMAT_BGRA5551,      \"BGRA5551\"},\r\n            {SDL_PIXELFORMAT_RGB565,        \"RGB565\"},\r\n            {SDL_PIXELFORMAT_BGR565,        \"BGR565\"},\r\n            {SDL_PIXELFORMAT_RGB24,         \"RGB24\"},\r\n            {SDL_PIXELFORMAT_BGR24,         \"BGR24\"},\r\n            {SDL_PIXELFORMAT_RGB888,        \"RGB888\"},\r\n            {SDL_PIXELFORMAT_RGBX8888,      \"RGBX8888\"},\r\n            {SDL_PIXELFORMAT_BGR888,        \"BGR888\"},\r\n            {SDL_PIXELFORMAT_BGRX8888,      \"BGRX8888\"},\r\n            {SDL_PIXELFORMAT_ARGB8888,      \"ARGB8888\"},\r\n            {SDL_PIXELFORMAT_RGBA8888,      \"RGBA8888\"},\r\n            {SDL_PIXELFORMAT_ABGR8888,      \"ABGR8888\"},\r\n            {SDL_PIXELFORMAT_BGRA8888,      \"BGRA8888\"},\r\n            {SDL_PIXELFORMAT_ARGB2101010,   \"ARGB2101010\"},\r\n            {SDL_PIXELFORMAT_YV12,          \"YV12\"},\r\n            {SDL_PIXELFORMAT_IYUV,          \"IYUV\"},\r\n            {SDL_PIXELFORMAT_YUY2,          \"YUY2\"},\r\n            {SDL_PIXELFORMAT_UYVY,          \"UYVY\"},\r\n            {SDL_PIXELFORMAT_YVYU,          \"YVYU\"},\r\n            {SDL_PIXELFORMAT_UNKNOWN,       \"Unknown\"}};\r\n\r\n        fprintf (st, \"     Render #%d - %s\\n\", i, info.name);\r\n        fprintf (st, \"        Flags: 0x%X - \", info.flags);\r\n        if (info.flags & SDL_RENDERER_SOFTWARE)\r\n            fprintf (st, \"Software|\");\r\n        if (info.flags & SDL_RENDERER_ACCELERATED)\r\n            fprintf (st, \"Accelerated|\");\r\n        if (info.flags & SDL_RENDERER_PRESENTVSYNC)\r\n            fprintf (st, \"PresentVSync|\");\r\n        if (info.flags & SDL_RENDERER_TARGETTEXTURE)\r\n            fprintf (st, \"TargetTexture|\");\r\n        fprintf (st, \"\\n\");\r\n        if ((info.max_texture_height != 0) || (info.max_texture_width != 0))\r\n            fprintf (st, \"        Max Texture: %d by %d\\n\", info.max_texture_height, info.max_texture_width);\r\n        fprintf (st, \"        Pixel Formats:\\n\");\r\n        for (j=0; j<info.num_texture_formats; j++) {\r\n            for (k=0; 1; k++) {\r\n                if (PixelFormats[k].format == info.texture_formats[j]) {\r\n                    fprintf (st, \"            %s\\n\", PixelFormats[k].name);\r\n                    break;\r\n                    }\r\n                if (PixelFormats[k].format == SDL_PIXELFORMAT_UNKNOWN) {\r\n                    fprintf (st, \"            %s - 0x%X\\n\", PixelFormats[k].name, info.texture_formats[j]);\r\n                    break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\nif (vid_active) {\r\n    SDL_RendererInfo info;\r\n\r\n    info.name = \"\";\r\n\r\n    for (vptr = &vid_first; vptr != NULL; vptr = vptr->next) {\r\n        if (vptr->vid_active_window) {\r\n            SDL_GetRendererInfo (vptr->vid_renderer, &info);\r\n            break;\r\n            }\r\n        }\r\n    fprintf (st, \"  Currently Active Renderer: %s\\n\", info.name);\r\n    }\r\nif (1) {\r\n    static const char *hints[] = {\r\n#if defined (SDL_HINT_FRAMEBUFFER_ACCELERATION)\r\n                SDL_HINT_FRAMEBUFFER_ACCELERATION   ,\r\n#endif\r\n#if defined (SDL_HINT_RENDER_DRIVER)\r\n                SDL_HINT_RENDER_DRIVER              ,\r\n#endif\r\n#if defined (SDL_HINT_RENDER_OPENGL_SHADERS)\r\n                SDL_HINT_RENDER_OPENGL_SHADERS      ,\r\n#endif\r\n#if defined (SDL_HINT_RENDER_DIRECT3D_THREADSAFE)\r\n                SDL_HINT_RENDER_DIRECT3D_THREADSAFE ,\r\n#endif\r\n#if defined (SDL_HINT_RENDER_DIRECT3D11_DEBUG)\r\n                SDL_HINT_RENDER_DIRECT3D11_DEBUG    ,\r\n#endif\r\n#if defined (SDL_HINT_RENDER_SCALE_QUALITY)\r\n                SDL_HINT_RENDER_SCALE_QUALITY       ,\r\n#endif\r\n#if defined (SDL_HINT_RENDER_VSYNC)\r\n                SDL_HINT_RENDER_VSYNC               ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_ALLOW_SCREENSAVER)\r\n                SDL_HINT_VIDEO_ALLOW_SCREENSAVER    ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_X11_XVIDMODE)\r\n                SDL_HINT_VIDEO_X11_XVIDMODE         ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_X11_XINERAMA)\r\n                SDL_HINT_VIDEO_X11_XINERAMA         ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_X11_XRANDR)\r\n                SDL_HINT_VIDEO_X11_XRANDR           ,\r\n#endif\r\n#if defined (SDL_HINT_GRAB_KEYBOARD)\r\n                SDL_HINT_GRAB_KEYBOARD              ,\r\n#endif\r\n#if defined (SDL_HINT_MOUSE_RELATIVE_MODE_WARP)\r\n                SDL_HINT_MOUSE_RELATIVE_MODE_WARP    ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS)\r\n                SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS   ,\r\n#endif\r\n#if defined (SDL_HINT_IDLE_TIMER_DISABLED)\r\n                SDL_HINT_IDLE_TIMER_DISABLED ,\r\n#endif\r\n#if defined (SDL_HINT_ORIENTATIONS)\r\n                SDL_HINT_ORIENTATIONS ,\r\n#endif\r\n#if defined (SDL_HINT_ACCELEROMETER_AS_JOYSTICK)\r\n                SDL_HINT_ACCELEROMETER_AS_JOYSTICK ,\r\n#endif\r\n#if defined (SDL_HINT_XINPUT_ENABLED)\r\n                SDL_HINT_XINPUT_ENABLED ,\r\n#endif\r\n#if defined (SDL_HINT_GAMECONTROLLERCONFIG)\r\n                SDL_HINT_GAMECONTROLLERCONFIG ,\r\n#endif\r\n#if defined (SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS)\r\n                SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS ,\r\n#endif\r\n#if defined (SDL_HINT_ALLOW_TOPMOST)\r\n                SDL_HINT_ALLOW_TOPMOST ,\r\n#endif\r\n#if defined (SDL_HINT_TIMER_RESOLUTION)\r\n                SDL_HINT_TIMER_RESOLUTION ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_HIGHDPI_DISABLED)\r\n                SDL_HINT_VIDEO_HIGHDPI_DISABLED ,\r\n#endif\r\n#if defined (SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK)\r\n                SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_WIN_D3DCOMPILER)\r\n                SDL_HINT_VIDEO_WIN_D3DCOMPILER              ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT)\r\n                SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT    ,\r\n#endif\r\n#if defined (SDL_HINT_WINRT_PRIVACY_POLICY_URL)\r\n                SDL_HINT_WINRT_PRIVACY_POLICY_URL ,\r\n#endif\r\n#if defined (SDL_HINT_WINRT_PRIVACY_POLICY_LABEL)\r\n                SDL_HINT_WINRT_PRIVACY_POLICY_LABEL ,\r\n#endif\r\n#if defined (SDL_HINT_WINRT_HANDLE_BACK_BUTTON)\r\n                SDL_HINT_WINRT_HANDLE_BACK_BUTTON ,\r\n#endif\r\n#if defined (SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES)\r\n                SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES,\r\n#endif\r\n                NULL};\r\n    fprintf (st, \"  Currently Active SDL Hints:\\n\");\r\n    for (i=0; hints[i]; i++) {\r\n        if (SDL_GetHint (hints[i]))\r\n            fprintf (st, \"      %s = %s\\n\", hints[i], SDL_GetHint (hints[i]));\r\n        }\r\n    }\r\n#if !defined (SDL_MAIN_AVAILABLE)\r\nif (!vid_active)\r\n    SDL_Quit();\r\n#endif\r\nreturn SCPE_OK;\r\n}\r\n\r\nstatic t_stat _show_stat;\r\nstatic FILE *_show_st;\r\nstatic UNIT *_show_uptr;\r\nstatic int32 _show_val;\r\nstatic CONST void *_show_desc;\r\n\r\nvoid vid_show_video_event (void)\r\n{\r\n_show_stat = _vid_show_video (_show_st, _show_uptr, _show_val, _show_desc);\r\n}\r\n\r\nt_stat vid_show_video (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nSDL_Event user_event;\r\n\r\n_show_stat = -1;\r\n_show_st = st;\r\n_show_uptr = uptr;\r\n_show_val = val;\r\n_show_desc = desc;\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.code = EVENT_SHOW;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (10);\r\n#else\r\nvid_show_video_event ();\r\n#endif\r\nwhile (_show_stat == -1)\r\n    SDL_Delay (20);\r\nreturn _show_stat;\r\n}\r\n\r\nstatic t_stat _vid_screenshot (VID_DISPLAY *vptr, const char *filename)\r\n{\r\nint stat;\r\nchar *fullname = NULL;\r\n\r\nif (!vid_active) {\r\n    sim_printf (\"No video display is active\\n\");\r\n    return SCPE_UDIS | SCPE_NOMESSAGE;\r\n    }\r\nfullname = (char *)malloc (strlen(filename) + 5);\r\nif (!fullname)\r\n    return SCPE_MEM;\r\nif (1) {\r\n    SDL_Surface *sshot = sim_end ? SDL_CreateRGBSurface(0, vptr->vid_width, vptr->vid_height, 32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000) :\r\n                                   SDL_CreateRGBSurface(0, vptr->vid_width, vptr->vid_height, 32, 0x0000ff00, 0x000ff000, 0xff000000, 0x000000ff) ;\r\n    SDL_RenderReadPixels(vptr->vid_renderer, NULL, SDL_PIXELFORMAT_ARGB8888, sshot->pixels, sshot->pitch);\r\n    if (sim_libpng_available) {\r\n        if (!match_ext (filename, \"bmp\")) {\r\n            sprintf (fullname, \"%s%s\", filename, match_ext (filename, \"png\") ? \"\" : \".png\");\r\n            stat = SDL_SavePNG(sshot, fullname);\r\n            }\r\n        else {\r\n            sprintf (fullname, \"%s\", filename);\r\n            stat = SDL_SaveBMP(sshot, fullname);\r\n            }\r\n        }\r\n    else {\r\n        sprintf (fullname, \"%s%s\", filename, match_ext (filename, \"bmp\") ? \"\" : \".bmp\");\r\n        stat = SDL_SaveBMP(sshot, fullname);\r\n        }\r\n    SDL_FreeSurface(sshot);\r\n    }\r\nif (stat) {\r\n    sim_printf (\"Error saving screenshot to %s: %s\\n\", fullname, SDL_GetError());\r\n    free (fullname);\r\n    return SCPE_IOERR | SCPE_NOMESSAGE;\r\n    }\r\nelse {\r\n    if (!sim_quiet)\r\n        sim_printf (\"Screenshot saved to %s\\n\", fullname);\r\n    free (fullname);\r\n    return SCPE_OK;\r\n    }\r\n}\r\n\r\nstatic t_stat _screenshot_stat;\r\nstatic const char *_screenshot_filename;\r\n\r\nvoid vid_screenshot_event (void)\r\n{\r\nVID_DISPLAY *vptr;\r\nint i = 0, n;\r\nchar *name = (char *)malloc (strlen (_screenshot_filename) + 5);\r\nchar *extension = strrchr ((char *)_screenshot_filename, '.');\r\nif (name == NULL) {\r\n    _screenshot_stat = SCPE_NXM;\r\n    return;\r\n    }\r\nif (extension)\r\n    n = extension - _screenshot_filename;\r\nelse {\r\n    n = strlen (_screenshot_filename);\r\n    extension = (char *)\"\";\r\n    }\r\nstrncpy (name, _screenshot_filename, n);\r\nfor (vptr = &vid_first; vptr != NULL; vptr = vptr->next) {\r\n    if (vid_active > 1)\r\n        sprintf (name + n, \"%d%s\", i++, extension);\r\n    else\r\n        sprintf (name + n, \"%s\", extension);\r\n    _screenshot_stat = _vid_screenshot (vptr, name);\r\n    if (_screenshot_stat != SCPE_OK) {\r\n        free (name);\r\n        return;\r\n        }\r\n    }\r\nfree (name);\r\n}\r\n\r\nt_stat vid_screenshot (const char *filename)\r\n{\r\nSDL_Event user_event;\r\n\r\n_screenshot_stat = -1;\r\n_screenshot_filename = filename;\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.code = EVENT_SCREENSHOT;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (10);\r\n#else\r\nvid_screenshot_event ();\r\n#endif\r\nwhile (_screenshot_stat == -1)\r\n    SDL_Delay (20);\r\nreturn _screenshot_stat;\r\n}\r\n\r\n#include <SDL_audio.h>\r\n\r\nconst int AMPLITUDE = 20000;\r\nconst int SAMPLE_FREQUENCY = 11025;\r\nstatic int16 *vid_beep_data;\r\nstatic int vid_beep_offset;\r\nstatic int vid_beep_duration;\r\nstatic int vid_beep_samples;\r\n\r\nstatic void vid_audio_callback(void *ctx, Uint8 *stream, int length)\r\n{\r\nint i, sum, remnant = ((vid_beep_samples - vid_beep_offset) * sizeof (*vid_beep_data));\r\n\r\nif (length > remnant) {\r\n    memset (stream + remnant, 0, length - remnant);\r\n    length = remnant;\r\n    if (remnant == 0) {\r\n        SDL_PauseAudio(1);\r\n        return;\r\n        }\r\n    }\r\nmemcpy (stream, &vid_beep_data[vid_beep_offset], length);\r\nfor (i=sum=0; i<length; i++)\r\n    sum += stream[i];\r\nvid_beep_offset += length / sizeof(*vid_beep_data);\r\n}\r\n\r\nstatic void vid_beep_setup (int duration_ms, int tone_frequency)\r\n{\r\nif (!vid_beep_data) {\r\n    int i;\r\n    SDL_AudioSpec desiredSpec;\r\n\r\n    SDL_InitSubSystem (SDL_INIT_AUDIO);\r\n    memset (&desiredSpec, 0, sizeof(desiredSpec));\r\n    desiredSpec.freq = SAMPLE_FREQUENCY;\r\n    desiredSpec.format = AUDIO_S16SYS;\r\n    desiredSpec.channels = 1;\r\n    desiredSpec.samples = 2048;\r\n    desiredSpec.callback = vid_audio_callback;\r\n\r\n    SDL_OpenAudio(&desiredSpec, NULL);\r\n\r\n    vid_beep_samples = (int)((SAMPLE_FREQUENCY * duration_ms) / 1000.0);\r\n    vid_beep_duration = duration_ms;\r\n    vid_beep_data = (int16 *)malloc (sizeof(*vid_beep_data) * vid_beep_samples);\r\n    for (i=0; i<vid_beep_samples; i++)\r\n        vid_beep_data[i] = (int16)(AMPLITUDE * sin(((double)(i * M_PI * tone_frequency)) / SAMPLE_FREQUENCY));\r\n    }\r\n}\r\n\r\nstatic void vid_beep_cleanup (void)\r\n{\r\nSDL_CloseAudio();\r\nfree (vid_beep_data);\r\nvid_beep_data = NULL;\r\nSDL_QuitSubSystem (SDL_INIT_AUDIO);\r\n}\r\n\r\nvoid vid_beep_event (void)\r\n{\r\nvid_beep_offset = 0;                /* reset to beginning of sample set */\r\nSDL_PauseAudio (0);                 /* Play sound */\r\n}\r\n\r\nvoid vid_beep (void)\r\n{\r\nSDL_Event user_event;\r\n\r\nuser_event.type = SDL_USEREVENT;\r\nuser_event.user.code = EVENT_BEEP;\r\nuser_event.user.data1 = NULL;\r\nuser_event.user.data2 = NULL;\r\n#if defined (SDL_MAIN_AVAILABLE)\r\nwhile (SDL_PushEvent (&user_event) < 0)\r\n    sim_os_ms_sleep (10);\r\n#else\r\nvid_beep_event ();\r\n#endif\r\nSDL_Delay (vid_beep_duration + 100);/* Wait for sound to finish */\r\n}\r\n\r\n#else /* !(defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL)) */\r\n/* Non-implemented versions */\r\n\r\nt_stat vid_open (DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nt_stat vid_close (void)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_close_all (void)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_poll_kb (SIM_KEY_EVENT *ev)\r\n{\r\nreturn SCPE_EOF;\r\n}\r\n\r\nt_stat vid_poll_mouse (SIM_MOUSE_EVENT *ev)\r\n{\r\nreturn SCPE_EOF;\r\n}\r\n\r\nuint32 vid_map_rgb (uint8 r, uint8 g, uint8 b)\r\n{\r\nreturn 0;\r\n}\r\n\r\nvoid vid_draw (int32 x, int32 y, int32 w, int32 h, uint32 *buf)\r\n{\r\nreturn;\r\n}\r\n\r\nt_stat vid_set_cursor (t_bool visible, uint32 width, uint32 height, uint8 *data, uint8 *mask, uint32 hot_x, uint32 hot_y)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nvoid vid_set_cursor_position (int32 x, int32 y)\r\n{\r\nreturn;\r\n}\r\n\r\nvoid vid_refresh (void)\r\n{\r\nreturn;\r\n}\r\n\r\nvoid vid_beep (void)\r\n{\r\nreturn;\r\n}\r\n\r\n#if defined(HAVE_LIBSDL)\r\n#include <SDL.h>\r\n#if defined(HAVE_LIBSDL_TTF)\r\n#include <SDL_ttf.h>\r\n#endif\r\n#endif\r\n\r\nconst char *vid_version (void)\r\n{\r\n#if defined(HAVE_LIBSDL)\r\nstatic char SDLVersion[200] = \"\";\r\nSDL_version compiled = { 0}, running = { 0};\r\n\r\nSDL_GetVersion(&running);\r\n\r\nSDL_VERSION(&compiled);\r\n\r\nSDLVersion[sizeof (SDLVersion) - 1] = '\\0';\r\nif ((compiled.major == running.major) &&\r\n    (compiled.minor == running.minor) &&\r\n    (compiled.patch == running.patch))\r\n    snprintf(SDLVersion, sizeof (SDLVersion), \"SDL Version %d.%d.%d\",\r\n                        compiled.major, compiled.minor, compiled.patch);\r\nelse\r\n    snprintf(SDLVersion, sizeof (SDLVersion), \"SDL Version (Compiled: %d.%d.%d, Runtime: %d.%d.%d)\",\r\n                        compiled.major, compiled.minor, compiled.patch,\r\n                        running.major, running.minor, running.patch);\r\n#if defined(HAVE_LIBSDL_TTF)\r\nSDL_TTF_VERSION(&compiled);\r\nrunning = *TTF_Linked_Version();\r\nif ((compiled.major == running.major) &&\r\n    (compiled.minor == running.minor) &&\r\n    (compiled.patch == running.patch))\r\n    snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                        \", SDL TTF Version %d.%d.%d\",\r\n                        compiled.major, compiled.minor, compiled.patch);\r\nelse\r\n    snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                        \", SDL TTF Version (Compiled: %d.%d.%d, Runtime: %d.%d.%d)\",\r\n                        compiled.major, compiled.minor, compiled.patch,\r\n                        running.major, running.minor, running.patch);\r\n#define _SDL_TTF_VERSION_ATLEAST(X, Y, Z)                                               \\\r\n    ((SDL_TTF_MAJOR_VERSION >= X) &&                                                    \\\r\n     (SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION >= Y) &&                       \\\r\n     (SDL_TTF_MAJOR_VERSION > X || SDL_TTF_MINOR_VERSION > Y || SDL_TTF_PATCHLEVEL >= Z))\r\n#if _SDL_TTF_VERSION_ATLEAST(2, 0, 18)\r\nif (1) {\r\n    int major, minor, patch;\r\n\r\n    TTF_Init();\r\n    TTF_GetFreeTypeVersion(&major, &minor, &patch);\r\n    snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                        \", FreeType Version %d.%d.%d\",\r\n                        major, minor, patch);\r\n    TTF_GetHarfBuzzVersion(&major, &minor, &patch);\r\n    if ((major != 0) || (minor != 0) || (patch != 0))\r\n        snprintf(&SDLVersion[strlen (SDLVersion)], sizeof (SDLVersion) - (strlen (SDLVersion) + 1),\r\n                            \", HarfBuzz Version %d.%d.%d\",\r\n                            major, minor, patch);\r\n    }\r\n#endif /* _SDL_TTF_VERSION_ATLEAST(2, 0, 18) */\r\n#endif /* HAVE_LIBSDL_TTF */\r\nreturn (const char *)SDLVersion;\r\n#else\r\nreturn \"No Video Support\";\r\n#endif\r\n}\r\n\r\nt_stat vid_set_release_key (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nt_stat vid_show_release_key (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nfprintf (st, \"no release key\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_show_video (FILE* st, UNIT* uptr, int32 val, CONST void* desc)\r\n{\r\nfprintf (st, \"video support unavailable\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_screenshot (const char *filename)\r\n{\r\nsim_printf (\"video support unavailable\\n\");\r\nreturn SCPE_NOFNC|SCPE_NOMESSAGE;\r\n}\r\n\r\nt_bool vid_is_fullscreen (void)\r\n{\r\nsim_printf (\"video support unavailable\\n\");\r\nreturn FALSE;\r\n}\r\n\r\nt_stat vid_set_fullscreen (t_bool flag)\r\n{\r\nsim_printf (\"video support unavailable\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nt_stat vid_open_window (VID_DISPLAY **vptr, DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags)\r\n{\r\n*vptr = NULL;\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nt_stat vid_close_window (VID_DISPLAY *vptr)\r\n{\r\nreturn SCPE_OK;\r\n}\r\n\r\nuint32 vid_map_rgb_window (VID_DISPLAY *vptr, uint8 r, uint8 g, uint8 b)\r\n{\r\nreturn 0;\r\n}\r\n\r\nvoid vid_draw_window (VID_DISPLAY *vptr, int32 x, int32 y, int32 w, int32 h, uint32 *buf)\r\n{\r\nreturn;\r\n}\r\n\r\nvoid vid_refresh_window (VID_DISPLAY *vptr)\r\n{\r\nreturn;\r\n}\r\n\r\nt_stat vid_set_cursor_window (VID_DISPLAY *vptr, t_bool visible, uint32 width, uint32 height, uint8 *data, uint8 *mask, uint32 hot_x, uint32 hot_y)\r\n{\r\nreturn SCPE_NOFNC;\r\n}\r\n\r\nt_bool vid_is_fullscreen_window (VID_DISPLAY *vptr)\r\n{\r\nsim_printf (\"video support unavailable\\n\");\r\nreturn FALSE;\r\n}\r\n\r\nt_stat vid_set_fullscreen_window (VID_DISPLAY *vptr, t_bool flag)\r\n{\r\nsim_printf (\"video support unavailable\\n\");\r\nreturn SCPE_OK;\r\n}\r\n\r\nvoid vid_set_cursor_position_window (VID_DISPLAY *vptr, int32 x, int32 y)\r\n{\r\nreturn;\r\n}\r\n\r\nvoid vid_set_window_size (VID_DISPLAY *vptr, int32 w, int32 h)\r\n{\r\nreturn;\r\n}\r\n\r\nvoid vid_render_set_logical_size (VID_DISPLAY *vptr, int32 w, int32 h)\r\n{\r\nreturn;\r\n}\r\n\r\nconst char *vid_key_name (uint32 key)\r\n{\r\nreturn \"\";\r\n}\r\n\r\n#endif /* defined(USE_SIM_VIDEO) */\r\n"
        },
        {
          "name": "sim_video.h",
          "type": "blob",
          "size": 10.8544921875,
          "content": "/* sim_video.c: Bitmap video output\r\n\r\n   Copyright (c) 2011-2013, Matt Burke\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining a\r\n   copy of this software and associated documentation files (the \"Software\"),\r\n   to deal in the Software without restriction, including without limitation\r\n   the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n   and/or sell copies of the Software, and to permit persons to whom the\r\n   Software is furnished to do so, subject to the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be included in\r\n   all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\r\n   THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n   IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   Except as contained in this notice, the name of the author shall not be\r\n   used in advertising or otherwise to promote the sale, use or other dealings\r\n   in this Software without prior written authorization from the author.\r\n\r\n   08-Nov-2013  MB      Added globals for current mouse status\r\n   11-Jun-2013  MB      First version\r\n*/\r\n\r\n#ifndef SIM_VIDEO_H_\r\n#define SIM_VIDEO_H_     0\r\n\r\n#include \"sim_defs.h\"\r\n\r\n#ifdef  __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#define SIM_KEYPRESS_DOWN      0                        /* key states */\r\n#define SIM_KEYPRESS_UP        1\r\n#define SIM_KEYPRESS_REPEAT    2\r\n\r\n\r\n#define SIM_KEY_F1             0                        /* key syms */\r\n#define SIM_KEY_F2             1\r\n#define SIM_KEY_F3             2\r\n#define SIM_KEY_F4             3\r\n#define SIM_KEY_F5             4\r\n#define SIM_KEY_F6             5\r\n#define SIM_KEY_F7             6\r\n#define SIM_KEY_F8             7\r\n#define SIM_KEY_F9             8\r\n#define SIM_KEY_F10            9\r\n#define SIM_KEY_F11            10\r\n#define SIM_KEY_F12            11\r\n\r\n#define SIM_KEY_0              12\r\n#define SIM_KEY_1              13\r\n#define SIM_KEY_2              14\r\n#define SIM_KEY_3              15\r\n#define SIM_KEY_4              16\r\n#define SIM_KEY_5              17\r\n#define SIM_KEY_6              18\r\n#define SIM_KEY_7              19\r\n#define SIM_KEY_8              20\r\n#define SIM_KEY_9              21\r\n\r\n#define SIM_KEY_A              22\r\n#define SIM_KEY_B              23\r\n#define SIM_KEY_C              24\r\n#define SIM_KEY_D              25\r\n#define SIM_KEY_E              26\r\n#define SIM_KEY_F              27\r\n#define SIM_KEY_G              28\r\n#define SIM_KEY_H              29\r\n#define SIM_KEY_I              30\r\n#define SIM_KEY_J              31\r\n#define SIM_KEY_K              32\r\n#define SIM_KEY_L              33\r\n#define SIM_KEY_M              34\r\n#define SIM_KEY_N              35\r\n#define SIM_KEY_O              36\r\n#define SIM_KEY_P              37\r\n#define SIM_KEY_Q              38\r\n#define SIM_KEY_R              39\r\n#define SIM_KEY_S              40\r\n#define SIM_KEY_T              41\r\n#define SIM_KEY_U              42\r\n#define SIM_KEY_V              43\r\n#define SIM_KEY_W              44\r\n#define SIM_KEY_X              45\r\n#define SIM_KEY_Y              46\r\n#define SIM_KEY_Z              47\r\n\r\n#define SIM_KEY_BACKQUOTE      48\r\n#define SIM_KEY_MINUS          49\r\n#define SIM_KEY_EQUALS         50\r\n#define SIM_KEY_LEFT_BRACKET   51\r\n#define SIM_KEY_RIGHT_BRACKET  52\r\n#define SIM_KEY_SEMICOLON      53\r\n#define SIM_KEY_SINGLE_QUOTE   54\r\n#define SIM_KEY_BACKSLASH      55\r\n#define SIM_KEY_LEFT_BACKSLASH 56\r\n#define SIM_KEY_COMMA          57\r\n#define SIM_KEY_PERIOD         58\r\n#define SIM_KEY_SLASH          59\r\n\r\n#define SIM_KEY_PRINT          60\r\n#define SIM_KEY_SCRL_LOCK      61\r\n#define SIM_KEY_PAUSE          62\r\n\r\n#define SIM_KEY_ESC            63\r\n#define SIM_KEY_BACKSPACE      64\r\n#define SIM_KEY_TAB            65\r\n#define SIM_KEY_ENTER          66\r\n#define SIM_KEY_SPACE          67\r\n#define SIM_KEY_INSERT         68\r\n#define SIM_KEY_DELETE         69\r\n#define SIM_KEY_HOME           70\r\n#define SIM_KEY_END            71\r\n#define SIM_KEY_PAGE_UP        72\r\n#define SIM_KEY_PAGE_DOWN      73\r\n#define SIM_KEY_UP             74\r\n#define SIM_KEY_DOWN           75\r\n#define SIM_KEY_LEFT           76\r\n#define SIM_KEY_RIGHT          77\r\n\r\n#define SIM_KEY_CAPS_LOCK      78\r\n#define SIM_KEY_NUM_LOCK       79\r\n\r\n#define SIM_KEY_ALT_L          80\r\n#define SIM_KEY_ALT_R          81\r\n#define SIM_KEY_CTRL_L         82\r\n#define SIM_KEY_CTRL_R         83\r\n#define SIM_KEY_SHIFT_L        84\r\n#define SIM_KEY_SHIFT_R        85\r\n#define SIM_KEY_WIN_L          86\r\n#define SIM_KEY_WIN_R          87\r\n#define SIM_KEY_MENU           88\r\n\r\n#define SIM_KEY_KP_ADD         89\r\n#define SIM_KEY_KP_SUBTRACT    90\r\n#define SIM_KEY_KP_END         91\r\n#define SIM_KEY_KP_DOWN        92\r\n#define SIM_KEY_KP_PAGE_DOWN   93\r\n#define SIM_KEY_KP_LEFT        94\r\n#define SIM_KEY_KP_RIGHT       95\r\n#define SIM_KEY_KP_HOME        96\r\n#define SIM_KEY_KP_UP          97\r\n#define SIM_KEY_KP_PAGE_UP     98\r\n#define SIM_KEY_KP_INSERT      99\r\n#define SIM_KEY_KP_DELETE      100\r\n#define SIM_KEY_KP_5           101\r\n#define SIM_KEY_KP_ENTER       102\r\n#define SIM_KEY_KP_MULTIPLY    103\r\n#define SIM_KEY_KP_DIVIDE      104\r\n\r\n#define SIM_KEY_UNKNOWN        200\r\n\r\n#define SIM_ALPHA_NONE         1\r\n#define SIM_ALPHA_BLEND        2\r\n#define SIM_ALPHA_ADD          3\r\n#define SIM_ALPHA_MOD          4\r\n\r\ntypedef struct VID_DISPLAY VID_DISPLAY;\r\n\r\nstruct mouse_event {\r\n    int32 x_rel;                                          /* X axis relative motion */\r\n    int32 y_rel;                                          /* Y axis relative motion */\r\n    int32 x_pos;                                          /* X axis position */\r\n    int32 y_pos;                                          /* Y axis position */\r\n    t_bool b1_state;                                      /* state of button 1 */\r\n    t_bool b2_state;                                      /* state of button 2 */\r\n    t_bool b3_state;                                      /* state of button 3 */\r\n    DEVICE *dev;                                          /* which device */\r\n    VID_DISPLAY *vptr;                                    /* which display */\r\n    };\r\n\r\nstruct key_event {\r\n    uint32 key;                                           /* key sym */\r\n    uint32 state;                                         /* key state change */\r\n    DEVICE *dev;                                          /* which device */\r\n    VID_DISPLAY *vptr;                                    /* which display */\r\n    };\r\n\r\ntypedef struct mouse_event SIM_MOUSE_EVENT;\r\ntypedef struct key_event SIM_KEY_EVENT;\r\n\r\nt_stat vid_open (DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags);\r\n#define SIM_VID_INPUTCAPTURED       1                       /* Mouse and Keyboard input captured (calling */\r\n                                                            /* code responsible for cursor display in video) */\r\n#define SIM_VID_IGNORE_VBAR         2                       /* ignore video buffer aspect ratio */\r\n#define SIM_VID_RESIZABLE           4                       /* video screen is resizable */\r\ntypedef void (*VID_QUIT_CALLBACK)(void);\r\nt_stat vid_register_quit_callback (VID_QUIT_CALLBACK callback);\r\ntypedef void (*VID_GAMEPAD_CALLBACK)(int, int, int);\r\nt_stat vid_register_gamepad_motion_callback (VID_GAMEPAD_CALLBACK);\r\nt_stat vid_register_gamepad_button_callback (VID_GAMEPAD_CALLBACK);\r\nt_stat vid_close (void);\r\nt_stat vid_poll_kb (SIM_KEY_EVENT *ev);\r\nt_stat vid_poll_mouse (SIM_MOUSE_EVENT *ev);\r\nuint32 vid_map_rgb (uint8 r, uint8 g, uint8 b);\r\nvoid vid_draw (int32 x, int32 y, int32 w, int32 h, uint32 *buf);\r\nvoid vid_beep (void);\r\nvoid vid_refresh (void);\r\nconst char *vid_version (void);\r\nconst char *vid_key_name (uint32 key);\r\nt_stat vid_set_cursor (t_bool visible, uint32 width, uint32 height, uint8 *data, uint8 *mask, uint32 hot_x, uint32 hot_y);\r\nt_stat vid_set_release_key (FILE* st, UNIT* uptr, int32 val, CONST void* desc);\r\nt_stat vid_show_release_key (FILE* st, UNIT* uptr, int32 val, CONST void* desc);\r\nt_stat vid_show_video (FILE* st, UNIT* uptr, int32 val, CONST void* desc);\r\nt_stat vid_show (FILE* st, DEVICE *dptr,  UNIT* uptr, int32 val, CONST char* desc);\r\nt_stat vid_screenshot (const char *filename);\r\nt_bool vid_is_fullscreen (void);\r\nt_stat vid_set_fullscreen (t_bool flag);\r\n\r\nextern int vid_active;\r\nvoid vid_set_cursor_position (int32 x, int32 y);        /* cursor position (set by calling code) */\r\nvoid vid_set_window_size (VID_DISPLAY *vptr, int32 x, int32 y);            /* window size (set by calling code) */\r\nvoid vid_render_set_logical_size (VID_DISPLAY *vptr, int32 w, int32 h);\r\n\r\nt_stat vid_open_window (VID_DISPLAY **vptr, DEVICE *dptr, const char *title, uint32 width, uint32 height, int flags);\r\nt_stat vid_close_window (VID_DISPLAY *vptr);\r\nt_stat vid_close_all (void);\r\nuint32 vid_map_rgb_window (VID_DISPLAY *vptr, uint8 r, uint8 g, uint8 b);\r\nuint32 vid_map_rgba_window (VID_DISPLAY *vptr, uint8 r, uint8 g, uint8 b, uint8 a);\r\nvoid vid_draw_window (VID_DISPLAY *vptr, int32 x, int32 y, int32 w, int32 h, uint32 *buf);\r\nvoid vid_refresh_window (VID_DISPLAY *vptr);\r\nt_stat vid_set_cursor_window (VID_DISPLAY *vptr, t_bool visible, uint32 width, uint32 height, uint8 *data, uint8 *mask, uint32 hot_x, uint32 hot_y);\r\nt_bool vid_is_fullscreen_window (VID_DISPLAY *vptr);\r\nt_stat vid_set_fullscreen_window (VID_DISPLAY *vptr, t_bool flag);\r\nvoid vid_set_cursor_position_window (VID_DISPLAY *vptr, int32 x, int32 y);        /* cursor position (set by calling code) */\r\nt_stat vid_set_alpha_mode (VID_DISPLAY *vptr, int mode);\r\n\r\n/* A device simulator can optionally set the vid_display_kb_event_process\r\n * routine pointer to the address of a routine.\r\n * Simulator code which uses the display library which processes window\r\n * keyboard data with code in display/sim_ws.c can use this routine to\r\n * explicitly get access to keyboard events that arrive in the display\r\n * window.  This routine should return 0 if it has handled the event that\r\n * was passed, and non zero if it didn't handle it.  If the routine address\r\n * is not set or a non zero return value occurs, then the keyboard event\r\n * will be processed by the display library which may then be handled as\r\n * console character input if the device console code is implemented to\r\n * accept this.\r\n */\r\nextern int (*vid_display_kb_event_process)(SIM_KEY_EVENT *kev);\r\n\r\n#define SIM_VID_DBG_JOYSTICK 0x08000000\r\n#define SIM_VID_DBG_MOUSE    0x10000000\r\n#define SIM_VID_DBG_CURSOR   0x20000000\r\n#define SIM_VID_DBG_KEY      0x40000000\r\n#define SIM_VID_DBG_VIDEO    0x80000000\r\n\r\n#ifdef  __cplusplus\r\n}\r\n#endif\r\n\r\n#if defined(USE_SIM_VIDEO) && defined(HAVE_LIBSDL)\r\n\r\n#if defined(__APPLE__)\r\n#define SDL_MAIN_AVAILABLE\r\n#endif\r\n\r\n#include <SDL.h>\r\n#endif /* HAVE_LIBSDL */\r\n\r\n#endif\r\n"
        },
        {
          "name": "slirp",
          "type": "tree",
          "content": null
        },
        {
          "name": "slirp_glue",
          "type": "tree",
          "content": null
        },
        {
          "name": "swtp6800",
          "type": "tree",
          "content": null
        },
        {
          "name": "tt2500",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}