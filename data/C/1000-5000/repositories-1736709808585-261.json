{
  "metadata": {
    "timestamp": 1736709808585,
    "page": 261,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "google/honggfuzz",
      "stars": 3109,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.3955078125,
          "content": "BasedOnStyle: Google\nAlignAfterOpenBracket: DontAlign\nAlignConsecutiveAssignments: true\nAlignConsecutiveDeclarations: true\nAlignConsecutiveMacros: true\nAlignEscapedNewlines: Right\nAlignOperands: true\nAllowShortFunctionsOnASingleLine: false\nAlwaysBreakBeforeMultilineStrings: false\nColumnLimit: 100\nForEachMacros:\n  - TAILQ_FOREACH_HF\nIndentCaseLabels: false\nIndentWidth: 4\nSpacesBeforeTrailingComments: 4\n"
        },
        {
          "name": ".clangd",
          "type": "blob",
          "size": 0.15625,
          "content": "CompileFlags:\n  Add: [-std=c11, -xc, -I., -I.., -fblocks, -D_HF_ARCH_LINUX, -D_GNU_SOURCE, -Wall, -Wextra, -Werror, -Wno-format-truncation, -Wno-override-init]\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.017578125,
          "content": "honggfuzz.c ident\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.216796875,
          "content": "*.o\n*.so\n*.dylib\n*.dSYM\n*.a\nhonggfuzz\nMakefile.bak\nhfuzz_cc/hfuzz-cc\nmac/mach_exc.h\nmac/mach_excUser.c\nmac/mach_excServer.h\nmac/mach_excServer.c\nlibs\nobj\nexamples/badcode/targets/badcode1\nexamples/badcode/targets/badcode2\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.2802734375,
          "content": "[submodule \"third_party/android/capstone\"]\n\tpath = third_party/android/capstone\n\turl = https://github.com/aquynh/capstone\n\tbranch = 4.0.2\n[submodule \"third_party/android/libunwind\"]\n\tpath = third_party/android/libunwind\n\turl = https://github.com/libunwind/libunwind.git\n\tbranch = v1.6.2\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 10.208984375,
          "content": "2023-09-21 - Version 2.6\n       - Pastis patch\n       - env NO_COLOR support\n       - fix problems with linux/bfd ```init_disassemble_info```\n       - Support ```--exit_on_time```\n       - ```strlcat``` supported in libhfuzz/memorycmp\n       - Some patches for MacOSX, sadly no support for ARM yet\n       - added missing ```add missing disassemble_free_target()```\n       - using ```rfork()``` under FreeBSD\n       - support for enabling/disabling ASLR under FreeBSD\n\n2022-01-01 - Version 2.5\n        - fixed build for Android NDK >= 23\n        - fixed build for CygWin\n        - improved hfuzz-cc, so it supports -x<language> correctly\n        - error returned if unknown cmd-line parameters are provided\n        - support for thread CPU pinning\n        - various fixes for *BSD\n        - increased number of dictionary entries (to 8192)\n\n2021-02-24 - Version 2.4\n        - better NetBSD support (compatiblity)\n        - fixed mangle_getLen() #360\n        - disabled --linux_net_ns by default, as the Linux kernel dies under heavy load of new net namespaces\n        - added support for address compression in IntelPT mode\n        - simplified input_skipFactor() which now yields better results (faster coverage acquisition)\n        - added --save_smaller for the use with Rust fuzzing\n        - fixed Android build under MacOSX\n        - simplified some mangle() functions\n\n2020-07-22 - Version 2.3\n        - honggfuzz.h - split run_t into substructs\n        - clang-format options in .clang-format\n        - added missing mutex initializers\n        - removed unncessary comparisons to 'true' and 'false'\n        - improved NetBSD compatibility\n        - removed unnecessary memory fences (speed ups)\n        - faster searching through the binary for const 4/8-byte values\n        - removed unnecessary includes with iwyu\n        - libhfnetdriver - general improvements around local socket fuzzing and timeouts\n\n2020-04-24 - Version 2.2\n        - Added 8bitcnt instrumentation - use hfuzz-cc/hfuzz-8bitcnt-(gcc|clang) for that\n        - PC-guard instrumentation now uses edge counting\n        - --experimental_const_feedback is now set to true by default\n        - additional string instrumentation wrappers: glib, lcms\n        - additional mutators: splicing, changing ascii numbers\n        - additional integer comparison instrumentation (adding integers to the dynamic dictionary)\n        - fixed linking with ld.lld\n        - removed `sanitizer-coverage-prune-blocks` from hfuzz-cc.c\n        - most mutators have now either overwrite or insert versions\n        - fixed memory barriers in libhfuzz/\n        - implemented skip_factor which dictates how often a given input is fuzzed\n        - lowered the default timeout to 1 second\n        - honggfuzz now uses microseconds, instead of milliseconds across the code\n        - added some new functions to libhfcommon/files\n        - enabled more aggressive inlining in hfuzz-cc/\n        - fixed compilation dependency under MacOS X\n\n2020-03-03 - Version 2.1\n        - string/int comparison enabled for targets built with *SAN, but w/o hfuzz-cc\n        - Parallel work made faster by using faster ATOMIC constructs (check first, then update)\n        - Implement --experimental_const_feedback - const string/integer feedback (used as an additional dictionary)\n        - Sanitizer report files are \"better\"-deleted (i.e. based on PID and not TID)\n        - New patches for fuzzing added (e.g. for bind-9.16.0/9.15.7)\n        - Buffered output enabled in display.c\n        - Some functions moved from per-arch arch.c to common subproc.c\n        - Compilation under MacOS X 10.15 (Catalina) is now supported\n        - Added suport for bfd/binutils-2.33\n\n2019-12-07 - Version 2.0\n        - Coverage-based corpus minimizer with '-M'\n        - QEmu mode: coverage feedback for Linux binaries\n        - *SAN sanitizer stack-parsing improved for Linux and for POSIX\n        - Move signal functionality to libhfcommon/\n        - Fixed Android builds with newer unwind and capstone\n        - NetDriver: more functionality - e.g. specifying custom addresses and custom tmpfs mount points\n        - Examples: for /usr/bin/file, newer ISC Bind patch, improved OpenSSL code\n\n2019-05-22 - Version 1.9\n        - Don't include netdriver if not needed\n        - Updated examples (bind/openssl)\n        - Add missing TEMP_FAILURE_RETRY() wrappers\n        - Add additional _HF_STATE_DYNAMIC_SWITCH_TO_MAIN state\n\n2019-02-23 - Version 1.8\n        - Native support for NetBSD\n        - Multiple smaller changes wrt threading - e.g. introducing the signal thread\n        - Removed the support for -p (pid fuzzing), honggfuzz net driver, or persistent fuzzing mode should be used instead\n        - Reimplementation of memory comparison routines, now verified with glibc's test-suite\n        - Improved hfuzz-cc/clang/gcc - e.g. for the MacOSX platform, also using -fno-sanitize=fuzzer if -fsanitize=fuzzer is specified, + some samba code wrappers\n        - Examples: new corpora for some of those, new patch for ISC Bind (9.13.5)\n\n2018-08-23 - Version 1.7\n        - Native support for NetBSD\n        - ASCII only fuzzing\n        - Updated corpora for ISC Bind\n        - Printing final stats upon exit\n        - Refreshed support for Intel PT\n        - Support for __sanitizer_cov_trace_div\n        - Updated fuzzing examples for OpenSSL\n\n2018-04-19 - Version 1.6 (rev aeaad48)\n        - Fixed Dockerfile\n        - Fixed a few format problems with file reporting\n        - Updated display formatting\n        - Make it work under WSL (Windows Subsystem for Linux)\n\n2018-02-22 - Version 1.5 (rev 3b1b70b)\n        - Persistent fuzzing now works with MacOS-X\n        - Fixed some examples/ to make it work with MacOS-X\n        - Should compile cleanly with newer MacOS-X versions\n\n2018-02-07 - Version 1.4 (rev 28c7d9e)\n        - Socketfuzzer by @dobin\n        - TCP fuzzer (HonggFuzzer NetDriver) in libhfnetdriver\n        - Display: changed layout a bit\n        - Fix some compilation isuses for MacOS-X\n        - Make it compile with OpenBSD\n        - Better examples/ dir: Apache HTTP, ISC Bind\n        - Added persistent and netdriver signatures\n        - Added missing symbols for newer -fsanitize-coverage (const)\n        - Changed internal structures (global vs run)\n        - Android: Make it compile with newer SDKs\n\n2017-12-09 - Version 1.3 (rev dd9f149)\n        - Software instrumentation - support for cmp_const __sanitizer_cov_trace_const funcs\n        - Refreshed (mostly) OpenSSL corpora\n        - Mangling: additional function for ASCII numbers\n        - Support for RLIMIT_DATA limiting\n        - Better UI scrolling\n        - Simplified Intel PT decoder\n        - Removed defer{} / fblocks from libhfuzz\n        - Google-style intendation with clang-format\n        - Faster locks over global corpora of files\n\n2017-11-01 - Version 1.2 (rev 8e04633)\n        - Software-based coverage feedback (-z) is now enabled by default, can be disabled with (-x)\n        - Better sigprocmask manipulation before executing a process\n        - Updated fuzzing corpora for ssl packages\n        - Updated Apache HTTPD compilation script/patch, corpora, config and string instrumentation\n        - Updated ISC Bind config and fuzzing corpora\n        - Fixes for the Android build (thanks to Zach Riggle and Anestis Bechtsoudis)\n        - Indentation fixes, now clang-format is used\n\n2017-06-23 - Version 1.1 (rev ee3a530)\n        - Simplified and improved hfuzz_cc compiler\n        - More string instrumentation in libhfuzz\n        - Android: works with Android-NDK 15 and newer only\n        - Dockerfile\n        - Refreshed docs\n        - Linux: Faster BTS/PT due to less PMU state resets\n        - Linux: tests and by-pass for the Linux' fork-when-multithreaded problem\n        - libFuzzer/AFL style dictionaries\n        - Runnable under docker/oss-fuzz\n\n2017-05-23 - Version 1.0 (rev 4332ae9)\n        - Multiple stability improvements for most of the supported architectures\n        - More examples in examples/ (e.g. Linux kernel IP for BTS/PT)\n        - Documentation updates\n        - Added honggfuzz compiler wrapper in hfuzz_cc/\n        - Reworked buffer mangling logic\n\n2016-02-14 - Version 0.9 (rev b0d1118)\n        - Clang >= 4.0 -fsanitize-coverage=trace-pc-guard,indirect-calls,trace-cmp support\n        - Multiple examples in examples/\n        - --pprocess_cmd for input post-processing\n\n2016-09-01 - Version 0.8 (rev 6b9efac)\n        - Clang >= 4.0 -fsanitize-coverage=trace-pc,indirect-calls,trace-cmp support\n        - GCC/Clang -finstrument-functions support\n        - Persistent fuzzing mode (-P) for Linux and POSIX\n        - Mutiple smaller fixes (display, stability)\n\n2016-03-15 - Version 0.7 (rev 6d01e82)\n        - Asan code-coverage (SANCOV) available for all platforms (incl. Windows)\n        - Support for Intel PT under Linux v4.0 and newer (and Broadwell/Skylake/newer Intel CPUs)\n        - Should work under: Linux, FreeBSD, Mac OS X, Windows/Cygwin, possibly other POSIX-compliant systems\n\n2015-08-14 - Version 0.6 (rev aa61adb)\n        - Improvements to feedback-driven fuzzing. Using bloom-style filter to record branches (much faster).\n        - Using multiple hardware-assisted feedback signals at once.\n        - Multiple small things: usage notes, logging\n\n2015-02-26 - Version 0.5 (revision 284)\n        - Feedback-driven fuzzing on Linux (using Intel's BTS with Linux perf infrastructure for branch counting) (-Dp option)\n        - Compiles cleanly and works under FreeBSD 10.1\n        - Uses libbfd/libunwind (under Linux) to disassemble offending instructions\n        - Many smaller fixes\n\n2015-02-01 - Version 0.4 (revision 72)\n        - Switch from udis86 to capstone (Capstone is available in many Linux distros as opposed to udis86)\n        - OSX 10.10 support\n        - Many smaller fixes (esp. for MacOS)\n\n2011-07-02 - Version 0.3 (revision 37)\n        - Honggfuzz now allows attaching to an external process (-p) (Linux only)\n        - -f no longer required when -c (external command) is specified\n        - Smaller fixes (typos)\n\n2011-06-02 - Version 0.2 (revision 26)\n        - MacOS fixes (parsing DiagnosticReports) - solves http://code.google.com/p/honggfuzz/issues/detail?id=2\n        - getopt() returns 'int' and not 'char' (could hang the process in a forever-loop)\n        - Formatting changes\n        - Updated comments/usage\n\n2010-12-13 - Initial release 0.1 (revision 13)\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.3828125,
          "content": "# How to contribute\n\nWant to contribute? Great! First, read this page (including the small print at the end).\n\n### Before you contribute\nBefore we can use your code, you must sign the\n[Google Individual Contributor License Agreement](https://developers.google.com/open-source/cla/individual?csw=1)\n(CLA), which you can do online. The CLA is necessary mainly because you own the\ncopyright to your changes, even after your contribution becomes part of our\ncodebase, so we need your permission to use and distribute your code. We also\nneed to be sure of various other things—for instance that you'll tell us if you\nknow that your code infringes on other people's patents. You don't have to sign\nthe CLA until after you've submitted your code for review and a member has\napproved it, but you must do it before we can put your code into our codebase.\nBefore you start working on a larger contribution, you should get in touch with\nus first through the issue tracker with your idea so that we can help out and\npossibly guide you. Coordinating up front makes it much easier to avoid\nfrustration later on.\n\n### Code reviews\nAll submissions, including submissions by project members, require review. We\nuse Github pull requests for this purpose.\n\n### The small print\nContributions made by corporations are covered by a different agreement than\nthe one above, the Software Grant and Corporate Contributor License Agreement.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.369140625,
          "content": "FROM ubuntu:rolling\n\nENV DEBIAN_FRONTEND noninteractive\n\nRUN apt-get -y update && apt-get install -y \\\n    gcc \\\n    git \\\n    make \\\n    pkg-config \\\n\tlibipt-dev \\\n\tlibunwind8-dev \\\n\tbinutils-dev \\\n&& rm -rf /var/lib/apt/lists/* && rm -rf /honggfuzz\n\nRUN git clone --depth=1 https://github.com/google/honggfuzz.git\n\nWORKDIR /honggfuzz\n\nRUN make && cp /honggfuzz/honggfuzz /bin\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 20.447265625,
          "content": "#   honggfuzz - Makefile\n#   -----------------------------------------\n#\n#   Author: Robert Swiecki <swiecki@google.com>\n#\n#   Copyright 2010-2015 by Google Inc. All Rights Reserved.\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n#\n#   NOTE: xcrun is within xcode...xcode is required on OSX.\n#\n\n# Common for all architectures\nCC ?= gcc\nLD = $(CC)\nBIN := honggfuzz\nHFUZZ_CC_BIN := hfuzz_cc/hfuzz-cc\nHFUZZ_CC_SRCS := hfuzz_cc/hfuzz-cc.c\nCOMMON_CFLAGS := -std=c11 -I/usr/local/include -D_GNU_SOURCE -Wall -Wextra -Werror -Wno-format-truncation -Wno-override-init -I.\nCOMMON_LDFLAGS := -pthread -L/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib -lm\nCOMMON_SRCS := $(sort $(wildcard *.c))\nCFLAGS ?= -O3 -mtune=native -funroll-loops\nLDFLAGS ?=\nLIBS_CFLAGS ?= -fPIC -fno-stack-protector -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0  # fortify-source intercepts some functions, so we disable it for libraries\nGREP_COLOR ?=\nBUILD_OSSFUZZ_STATIC ?= false # for https://github.com/google/oss-fuzz\nBUILD_LINUX_NO_BFD ?= false # for users who don't want to use libbfd/binutils\n\nREALOS = $(shell uname -s)\nOS ?= $(shell uname -s)\nMARCH ?= $(shell uname -m)\nKERNEL ?= $(shell uname -r)\n\nifeq ($(OS)$(findstring Microsoft,$(KERNEL)),Linux) # matches Linux but excludes WSL (Windows Subsystem for Linux)\n    ARCH := LINUX\n\n    ARCH_CFLAGS := -D_FILE_OFFSET_BITS=64\n    ARCH_SRCS := $(sort $(wildcard linux/*.c))\n    ARCH_LDFLAGS := -L/usr/local/include\n    ifeq ($(BUILD_OSSFUZZ_STATIC),true)\n            ARCH_LDFLAGS += -Wl,-Bstatic \\\n                            `pkg-config --libs --static libunwind-ptrace libunwind-generic` \\\n                            -lopcodes -lbfd -liberty -lz \\\n                            -Wl,-Bdynamic\n    else\n            ARCH_LDFLAGS += -lunwind-ptrace -lunwind-generic -lunwind  -llzma \\\n                            -lopcodes -lbfd\n    endif\n    ifeq ($(BUILD_LINUX_NO_BFD),true)\n            ARCH_CFLAGS += -D_HF_LINUX_NO_BFD\n    endif\n    ARCH_LDFLAGS += -lrt -ldl -lm\n\n    ifeq (\"$(wildcard /usr/local/include/intel-pt.h)\",\"/usr/local/include/intel-pt.h\")\n        ARCH_CFLAGS += -D_HF_LINUX_INTEL_PT_LIB\n        ARCH_CFLAGS += -I/usr/local/include\n        ARCH_LDFLAGS += -L/usr/local/lib -lipt -Wl,--rpath=/usr/local/lib\n    endif\n    ifeq (\"$(wildcard /usr/include/intel-pt.h)\",\"/usr/include/intel-pt.h\")\n        ARCH_CFLAGS += -D_HF_LINUX_INTEL_PT_LIB\n        ARCH_LDFLAGS += -lipt\n    endif\n\n# OS Linux\nelse ifeq ($(OS),Darwin)\n    ARCH := DARWIN\n\n    ARCH_SRCS := $(sort $(wildcard mac/*.c) mac/mach_excServer.c mac/mach_excUser.c)\n\n    # MacOS-X grep seem to use colors unconditionally\n    GREP_COLOR = --color=never\n\n    # Figure out which crash reporter to use.\n    CRASHWRANGLER := third_party/mac\n    OS_VERSION := $(shell sw_vers -productVersion)\n    OS_MAJOR_VERSION := $(shell echo $(OS_VERSION) | cut -f1 -d.)\n    OS_MINOR_VERSION := $(shell echo $(OS_VERSION) | cut -f2 -d.)\n\n    ifeq ($(OS_MAJOR_VERSION), 13)\n        CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n    else ifeq ($(OS_MAJOR_VERSION), 12)\n        CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n    else ifeq ($(OS_MAJOR_VERSION), 11)\n        CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n    else ifeq ($(OS_MAJOR_VERSION), 10)\n        ifeq ($(OS_MINOR_VERSION), 15)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n        else ifeq ($(OS_MINOR_VERSION), 14)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n        else ifeq ($(OS_MINOR_VERSION), 13)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n        else ifeq ($(OS_MINOR_VERSION), 12)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Sierra.o\n        else ifeq ($(OS_MINOR_VERSION), 11)\n            # El Capitan didn't break compatibility\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Yosemite.o\n        else ifeq ($(OS_MINOR_VERSION), 10)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Yosemite.o\n        else ifeq ($(OS_MINOR_VERSION), 9)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Mavericks.o\n        else ifeq ($(OS_MINOR_VERSION), 8)\n            CRASH_REPORT := $(CRASHWRANGLER)/CrashReport_Mountain_Lion.o\n        endif\n    endif\n\n    ifeq ($(CRASH_REPORT), )\n        $(error Unsupported MAC OS X version)\n    endif\n\n    # Figure out which XCode SDK to use.\n    OSX_SDK_VERSION := $(shell xcrun --show-sdk-version)\n    SDK_NAME_V := macosx$(OSX_SDK_VERSION)\n    SDK_V := $(shell xcrun --sdk $(SDK_NAME) --show-sdk-path 2>/dev/null)\n    SDK_NAME := macosx\n    SDK := $(shell xcrun --sdk $(SDK_NAME) --show-sdk-path 2>/dev/null)\n\n    CC := $(shell xcrun --sdk $(SDK_NAME) --find cc)\n    LD := $(shell xcrun --sdk $(SDK_NAME) --find cc)\n    ARCH_CFLAGS := -isysroot $(SDK) \\\n                   -x objective-c -pedantic -fblocks \\\n                   -Wno-unused-parameter \\\n                   -Wimplicit -Wunused -Wcomment -Wchar-subscripts -Wuninitialized \\\n                   -Wreturn-type -Wpointer-arith -Wno-gnu-case-range -Wno-gnu-designator \\\n                   -Wno-deprecated-declarations -Wno-unknown-pragmas -Wno-attributes \\\n                   -Wno-embedded-directive\n    ARCH_LDFLAGS := -F/System/Library/PrivateFrameworks -framework CoreSymbolication -framework IOKit \\\n                    -F$(SDK_V)/System/Library/Frameworks -F$(SDK_V)/System/Library/PrivateFrameworks \\\n                    -F$(SDK)/System/Library/Frameworks -F$(SDK)/System/Library/PrivateFrameworks \\\n                    -framework Foundation -framework ApplicationServices -framework Symbolication \\\n                    -framework CoreServices -framework CrashReporterSupport -framework CoreFoundation \\\n                    -framework CommerceKit $(CRASH_REPORT)\n\n    XCODE_VER := $(shell xcodebuild -version | grep $(GREP_COLOR) \"^Xcode\" | cut -d \" \" -f2)\n# OS Darwin\nelse ifeq ($(OS),NetBSD)\n    ARCH := NETBSD\n\n    ARCH_SRCS := $(sort $(wildcard netbsd/*.c))\n    ARCH_CFLAGS := -I/usr/pkg/include \\\n                   -D_KERNTYPES\n    ARCH_LDFLAGS := -L/usr/local/lib -L/usr/pkg/lib \\\n                    -lcapstone -lrt -lm \\\n                    -Wl,--rpath=/usr/pkg/lib\n\n# OS NetBSD\nelse\n    ARCH := POSIX\n\n    ARCH_SRCS := $(sort $(wildcard posix/*.c))\n    ARCH_CFLAGS := -Wno-initializer-overrides \\\n                   -Wno-unknown-warning-option -Wno-unknown-pragmas\n    ARCH_LDFLAGS := -L/usr/local/lib -lm\n    ifeq ($(OS),SunOS)\n        ARCH_CFLAGS += -m64 -D_POSIX_C_SOURCE=200809L -D__EXTENSIONS__=1\n\tARCH_LDFLAGS += -m64 -lkstat -lsocket -lnsl -lkvm\n    endif\n    ifneq ($(REALOS),OpenBSD)\n    ifneq ($(REALOS),Darwin)\n        ARCH_LDFLAGS += -lrt\n    endif\n    endif\n# OS Posix\nendif\n\nCFLAGS_BLOCKS :=\nCOMPILER = $(shell $(CC) -v 2>&1 | \\\n  grep $(GREP_COLOR) -oE '((gcc|clang) version|LLVM version.*clang)' | \\\n  grep $(GREP_COLOR) -oE '(clang|gcc)' | head -n1)\nifeq ($(COMPILER),clang)\n  ARCH_CFLAGS += -Wno-initializer-overrides -Wno-unknown-warning-option\n  ARCH_CFLAGS += -Wno-gnu-empty-initializer -Wno-format-pedantic\n  ARCH_CFLAGS += -Wno-gnu-statement-expression\n  ARCH_CFLAGS += -mllvm -inline-threshold=2000\n  CFLAGS_BLOCKS = -fblocks\n\n  ifneq ($(REALOS),Darwin)\n    ARCH_LDFLAGS += -Wl,-Bstatic -lBlocksRuntime -Wl,-Bdynamic\n  endif\nendif\nifeq ($(COMPILER),gcc)\n  ARCH_CFLAGS += -finline-limit=4000\nendif\n\nSRCS := $(COMMON_SRCS) $(ARCH_SRCS)\nOBJS := $(SRCS:.c=.o)\n\nLHFUZZ_SRCS := $(sort $(wildcard libhfuzz/*.c))\nLHFUZZ_OBJS := $(LHFUZZ_SRCS:.c=.o)\nLHFUZZ_ARCH := libhfuzz/libhfuzz.a\nLHFUZZ_SHARED := libhfuzz/libhfuzz.so\nHFUZZ_INC ?= $(shell pwd)\n\nLCOMMON_SRCS := $(sort $(wildcard libhfcommon/*.c))\nLCOMMON_OBJS := $(LCOMMON_SRCS:.c=.o)\nLCOMMON_ARCH := libhfcommon/libhfcommon.a\n\nLNETDRIVER_SRCS := $(sort $(wildcard libhfnetdriver/*.c))\nLNETDRIVER_OBJS := $(LNETDRIVER_SRCS:.c=.o)\nLNETDRIVER_ARCH := libhfnetdriver/libhfnetdriver.a\n\n# Respect external user defines\nCFLAGS += $(COMMON_CFLAGS) $(ARCH_CFLAGS) -D_HF_ARCH_${ARCH}\nLDFLAGS += $(COMMON_LDFLAGS) $(ARCH_LDFLAGS)\n\nifdef DEBUG\n    CFLAGS += -g -ggdb -g3\n    LDFLAGS += -g -ggdb -g3\nendif\n\n# Control Android builds\nANDROID_API           ?= android-30 # Minimal working version is android-30 (ndk 22)\nANDROID_DEBUG_ENABLED ?= false\nANDROID_APP_ABI       ?= arm64-v8a\nANDROID_SKIP_CLEAN    ?= false\nNDK_BUILD_ARGS :=\n\nifeq ($(ANDROID_DEBUG_ENABLED),true)\n  NDK_BUILD_ARGS += V=1 NDK_DEBUG=1 APP_OPTIM=debug\nendif\n\n# By default ndk-build cleans all project files to ensure that no semi-completed\n# builds reach the app package. The following flag disables this check. It's mainly\n# purposed to be used with android-all rule where we want recursive invocations\n# to keep previous targets' binaries.\nifeq ($(ANDROID_SKIP_CLEAN),true)\n  NDK_BUILD_ARGS += NDK_APP.local.cleaned_binaries=true\nendif\n\nANDROID_NDK_TOOLCHAIN_VER := clang\n# clang works only against APIs >= 23\nifeq ($(ANDROID_APP_ABI),$(filter $(ANDROID_APP_ABI),armeabi-v7a))\n  ANDROID_NDK_TOOLCHAIN ?= arm-linux-androideabi-clang\n  ANDROID_NDK_COMPILER_PREFIX := armv7a-linux-androideabi\n  ANDROID_ARCH_CPU := arm\nelse ifeq ($(ANDROID_APP_ABI),$(filter $(ANDROID_APP_ABI),x86))\n  ANDROID_NDK_TOOLCHAIN ?= x86-clang\n  ANDROID_NDK_COMPILER_PREFIX := i686-linux-android\n  ANDROID_ARCH_CPU := x86\nelse ifeq ($(ANDROID_APP_ABI),$(filter $(ANDROID_APP_ABI),arm64-v8a))\n  ANDROID_NDK_TOOLCHAIN ?= aarch64-linux-android-clang\n  ANDROID_NDK_COMPILER_PREFIX := aarch64-linux-android\n  ANDROID_ARCH_CPU := arm64\nelse ifeq ($(ANDROID_APP_ABI),$(filter $(ANDROID_APP_ABI),x86_64))\n  ANDROID_NDK_TOOLCHAIN ?= x86_64-clang\n  ANDROID_NDK_COMPILER_PREFIX := x86_64-linux-android\n  ANDROID_ARCH_CPU := x86_64\nelse\n   $(error Unsuported / Unknown APP_API '$(ANDROID_APP_ABI)')\nendif\n\n\nSUBDIR_ROOTS := linux mac netbsd posix libhfuzz libhfcommon libhfnetdriver\nDIRS := . $(shell find $(SUBDIR_ROOTS) -type d)\nCLEAN_PATTERNS := *.o *~ core *.a *.dSYM *.la *.so *.dylib\nSUBDIR_GARBAGE := $(foreach DIR,$(DIRS),$(addprefix $(DIR)/,$(CLEAN_PATTERNS)))\nMAC_GARGBAGE := $(wildcard mac/mach_exc*)\nANDROID_GARBAGE := obj libs\n\nCLEAN_TARGETS := core Makefile.bak \\\n  $(OBJS) $(BIN) $(HFUZZ_CC_BIN) \\\n  $(LHFUZZ_ARCH) $(LHFUZZ_SHARED) $(LHFUZZ_OBJS) \\\n  $(LCOMMON_ARCH) $(LCOMMON_OBJS) \\\n  $(LNETDRIVER_ARCH) $(LNETDRIVER_OBJS) \\\n  $(MAC_GARGBAGE) $(ANDROID_GARBAGE) $(SUBDIR_GARBAGE)\n\nall: $(BIN) $(HFUZZ_CC_BIN) $(LHFUZZ_ARCH) $(LHFUZZ_SHARED) $(LCOMMON_ARCH) $(LNETDRIVER_ARCH)\n\n%.o: %.c\n\t$(CC) -c $(CFLAGS) $(CFLAGS_BLOCKS) -o $@ $<\n\nmac/mach_exc.h mac/mach_excServer.c mac/mach_excServer.h mac/mach_excUser.c &:\n\tmig -header mac/mach_exc.h -user mac/mach_excUser.c -sheader mac/mach_excServer.h \\\n\t\t-server mac/mach_excServer.c $(SDK)/usr/include/mach/mach_exc.defs\n\nmac/arch.o: mac/arch.c mac/mach_exc.h mac/mach_excServer.h\n\t$(CC) -c $(CFLAGS) $(CFLAGS_BLOCKS) -o $@ $<\n\n%.so: %.c\n\t$(CC) -fPIC -shared $(CFLAGS) -o $@ $<\n\n%.dylib: %.c\n\t$(CC) -fPIC -shared $(CFLAGS) -o $@ $<\n\n$(BIN): $(OBJS) $(LCOMMON_ARCH)\n\t$(LD) -o $(BIN) $(OBJS) $(LCOMMON_ARCH) $(LDFLAGS)\n\n$(HFUZZ_CC_BIN): $(LCOMMON_ARCH) $(LHFUZZ_ARCH) $(LNETDRIVER_ARCH) $(HFUZZ_CC_SRCS)\n\t$(LD) -o $@ $(HFUZZ_CC_SRCS) $(LCOMMON_ARCH) $(LDFLAGS) $(CFLAGS) $(CFLAGS_BLOCKS) -D_HFUZZ_INC_PATH=$(HFUZZ_INC)\n\n$(LCOMMON_OBJS): $(LCOMMON_SRCS)\n\t$(CC) -c $(CFLAGS) $(LIBS_CFLAGS) -o $@ $(@:.o=.c)\n\n$(LCOMMON_ARCH): $(LCOMMON_OBJS)\n\t$(AR) rcs $(LCOMMON_ARCH) $(LCOMMON_OBJS)\n\n$(LHFUZZ_OBJS): $(LHFUZZ_SRCS)\n\t$(CC) -c $(CFLAGS) $(LIBS_CFLAGS) -o $@ $(@:.o=.c)\n\n$(LHFUZZ_ARCH): $(LHFUZZ_OBJS)\n\t$(AR) rcs $(LHFUZZ_ARCH) $(LHFUZZ_OBJS)\n\n$(LHFUZZ_SHARED): $(LHFUZZ_OBJS) $(LCOMMON_OBJS)\n\t$(LD) -shared $(LHFUZZ_OBJS) $(LCOMMON_OBJS) $(LDFLAGS) -o $@\n\n$(LNETDRIVER_OBJS): $(LNETDRIVER_SRCS)\n\t$(CC) -c $(CFLAGS) $(LIBS_CFLAGS) -o $@ $(@:.o=.c)\n\n$(LNETDRIVER_ARCH): $(LNETDRIVER_OBJS)\n\t$(AR) rcs $(LNETDRIVER_ARCH) $(LNETDRIVER_OBJS)\n\n.PHONY: clean\nclean:\n\t$(RM) -r $(CLEAN_TARGETS)\n\n.PHONY: indent\nindent:\n\tclang-format -i -sort-includes  *.c *.h */*.c */*.h\n\n.PHONY: depend\ndepend: all\n\tmakedepend -Y. -Y* -- *.c */*.c\n\n.PHONY: android\nandroid:\n\t$(info ***************************************************************)\n\t$(info *                 Use Android NDK 22 or newer                 *)\n\t$(info ***************************************************************)\n\t@ANDROID_API=$(ANDROID_API) ANDROID_NDK_COMPILER_PREFIX=$(ANDROID_NDK_COMPILER_PREFIX) third_party/android/scripts/compile-libunwind.sh \\\n\tthird_party/android/libunwind $(ANDROID_ARCH_CPU)\n\n\t@ANDROID_API=$(ANDROID_API) ANDROID_NDK_COMPILER_PREFIX=$(ANDROID_NDK_COMPILER_PREFIX) third_party/android/scripts/compile-capstone.sh \\\n\tthird_party/android/capstone $(ANDROID_ARCH_CPU)\n\n\t@ANDROID_API=$(ANDROID_API) ANDROID_NDK_COMPILER_PREFIX=$(ANDROID_NDK_COMPILER_PREFIX) third_party/android/scripts/compile-libBlocksRuntime.sh \\\n\tthird_party/android/libBlocksRuntime $(ANDROID_ARCH_CPU)\n\n\tndk-build NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./android/Android.mk \\\n    APP_PLATFORM=$(ANDROID_API) APP_ABI=$(ANDROID_APP_ABI) \\\n    NDK_TOOLCHAIN=$(ANDROID_NDK_TOOLCHAIN) NDK_TOOLCHAIN_VERSION=$(ANDROID_NDK_TOOLCHAIN_VER) \\\n    $(NDK_BUILD_ARGS) APP_MODULES='honggfuzz hfuzz hfnetdriver'\n\n# Loop all ABIs and pass-through flags since visibility is lost due to sub-process\n.PHONY: android-all\nandroid-all:\n\t@echo \"Cleaning workspace:\"\n\t$(MAKE) clean\n\t@echo \"\"\n\n\tfor abi in armeabi-v7a arm64-v8a x86 x86_64; do \\\n\t  ANDROID_APP_ABI=$$abi ANDROID_SKIP_CLEAN=true \\\n\t  ANDROID_API=$(ANDROID_API) ANDROID_DEBUG_ENABLED=$(ANDROID_DEBUG_ENABLED) \\\n\t  $(MAKE) android || { \\\n\t    echo \"Recursive make failed\"; exit 1; }; \\\n\t  echo \"\"; \\\n\tdone\n\n.PHONY: android-clean-deps\nandroid-clean-deps:\n\t@for cpu in arm arm64 x86 x86_64; do \\\n\t  make -C \"third_party/android/capstone\" clean; \\\n\t  rm -rf \"third_party/android/capstone/$$cpu\"; \\\n\t  make -C \"third_party/android/libunwind\" clean; \\\n\t  rm -rf \"third_party/android/libunwind/$$cpu\"; \\\n\t  ndk-build -C \"third_party/android/libBlocksRuntime\" \\\n\t    NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=Android.mk clean; \\\n\t  rm -rf \"third_party/android/libBlocksRuntime/$$cpu\"; \\\n\tdone\n\nPREFIX\t\t?= /usr/local\nBIN_PATH\t= $(PREFIX)/bin\nINC_PATH\t= $(PREFIX)/include\n\ninstall: all\n\tmkdir -p -m 755 $${DESTDIR}$(BIN_PATH)\n\tinstall -m 755 honggfuzz $${DESTDIR}$(BIN_PATH)\n\tinstall -m 755 hfuzz_cc/hfuzz-cc $${DESTDIR}$(BIN_PATH)\n\tinstall -m 755 hfuzz_cc/hfuzz-clang $${DESTDIR}$(BIN_PATH)\n\tinstall -m 755 hfuzz_cc/hfuzz-clang++ $${DESTDIR}$(BIN_PATH)\n\tinstall -m 755 hfuzz_cc/hfuzz-gcc $${DESTDIR}$(BIN_PATH)\n\tinstall -m 755 hfuzz_cc/hfuzz-g++ $${DESTDIR}$(BIN_PATH)\n\tinstall -d $${DESTDIR}$(INC_PATH)/libhfcommon\n\tinstall -d $${DESTDIR}$(INC_PATH)/libhfuzz\n\tinstall -d $${DESTDIR}$(INC_PATH)/libhnetdriver\n\tinstall -m 755 includes/libhfcommon/*.h $${DESTDIR}$(INC_PATH)/libhfcommon\n\tinstall -m 755 includes/libhfuzz/*.h $${DESTDIR}$(INC_PATH)/libhfuzz\n\tinstall -m 755 includes/libhfnetdriver/*.h $${DESTDIR}$(INC_PATH)/libhnetdriver\n\n# DO NOT DELETE\n\ncmdline.o: cmdline.h honggfuzz.h libhfcommon/util.h display.h\ncmdline.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\ncmdline.o: libhfcommon/log.h\ndisplay.o: display.h honggfuzz.h libhfcommon/util.h libhfcommon/common.h\ndisplay.o: libhfcommon/log.h\nfuzz.o: fuzz.h honggfuzz.h libhfcommon/util.h arch.h input.h\nfuzz.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nfuzz.o: libhfcommon/log.h report.h sanitizers.h socketfuzzer.h subproc.h\nhonggfuzz.o: cmdline.h honggfuzz.h libhfcommon/util.h display.h fuzz.h\nhonggfuzz.o: input.h libhfcommon/common.h libhfcommon/files.h\nhonggfuzz.o: libhfcommon/common.h libhfcommon/log.h socketfuzzer.h subproc.h\ninput.o: input.h honggfuzz.h libhfcommon/util.h fuzz.h libhfcommon/common.h\ninput.o: libhfcommon/files.h libhfcommon/common.h libhfcommon/log.h mangle.h\ninput.o: subproc.h\nmangle.o: mangle.h honggfuzz.h libhfcommon/util.h input.h\nmangle.o: libhfcommon/common.h libhfcommon/log.h\nreport.o: report.h honggfuzz.h libhfcommon/util.h sanitizers.h\nreport.o: libhfcommon/common.h libhfcommon/log.h\nsanitizers.o: sanitizers.h honggfuzz.h libhfcommon/util.h cmdline.h\nsanitizers.o: libhfcommon/common.h libhfcommon/log.h\nsocketfuzzer.o: socketfuzzer.h honggfuzz.h libhfcommon/util.h\nsocketfuzzer.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nsocketfuzzer.o: libhfcommon/log.h libhfcommon/ns.h\nsubproc.o: subproc.h honggfuzz.h libhfcommon/util.h arch.h fuzz.h\nsubproc.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nsubproc.o: libhfcommon/log.h\nhfuzz_cc/hfuzz-cc.o: honggfuzz.h libhfcommon/util.h libhfcommon/common.h\nhfuzz_cc/hfuzz-cc.o: libhfcommon/files.h libhfcommon/common.h\nhfuzz_cc/hfuzz-cc.o: libhfcommon/log.h\nlibhfcommon/files.o: libhfcommon/files.h libhfcommon/common.h\nlibhfcommon/files.o: libhfcommon/log.h libhfcommon/util.h\nlibhfcommon/log.o: libhfcommon/log.h libhfcommon/common.h libhfcommon/util.h\nlibhfcommon/ns.o: libhfcommon/ns.h libhfcommon/common.h libhfcommon/files.h\nlibhfcommon/ns.o: libhfcommon/log.h libhfcommon/util.h\nlibhfcommon/util.o: libhfcommon/util.h libhfcommon/common.h\nlibhfcommon/util.o: libhfcommon/files.h libhfcommon/log.h\nlibhfnetdriver/netdriver.o: libhfnetdriver/netdriver.h honggfuzz.h\nlibhfnetdriver/netdriver.o: libhfcommon/util.h libhfcommon/common.h\nlibhfnetdriver/netdriver.o: libhfcommon/files.h libhfcommon/common.h\nlibhfnetdriver/netdriver.o: libhfcommon/log.h libhfcommon/ns.h\nlibhfuzz/fetch.o: libhfuzz/fetch.h honggfuzz.h libhfcommon/util.h\nlibhfuzz/fetch.o: libhfcommon/files.h libhfcommon/common.h libhfcommon/log.h\nlibhfuzz/instrument.o: libhfuzz/instrument.h honggfuzz.h libhfcommon/util.h\nlibhfuzz/instrument.o: libhfcommon/common.h libhfcommon/files.h\nlibhfuzz/instrument.o: libhfcommon/common.h libhfcommon/log.h\nlibhfuzz/linux.o: libhfcommon/common.h libhfcommon/files.h\nlibhfuzz/linux.o: libhfcommon/common.h libhfcommon/log.h libhfcommon/ns.h\nlibhfuzz/linux.o: libhfuzz/libhfuzz.h\nlibhfuzz/memorycmp.o: libhfcommon/common.h libhfcommon/util.h\nlibhfuzz/memorycmp.o: libhfuzz/instrument.h\nlibhfuzz/performance.o: libhfuzz/performance.h honggfuzz.h libhfcommon/util.h\nlibhfuzz/performance.o: libhfcommon/log.h libhfuzz/instrument.h\nlibhfuzz/persistent.o: honggfuzz.h libhfcommon/util.h libhfcommon/common.h\nlibhfuzz/persistent.o: libhfcommon/files.h libhfcommon/common.h\nlibhfuzz/persistent.o: libhfcommon/log.h libhfuzz/fetch.h\nlibhfuzz/persistent.o: libhfuzz/instrument.h libhfuzz/libhfuzz.h\nlibhfuzz/persistent.o: libhfuzz/performance.h\nlinux/arch.o: arch.h honggfuzz.h libhfcommon/util.h fuzz.h\nlinux/arch.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nlinux/arch.o: libhfcommon/log.h libhfcommon/ns.h linux/perf.h linux/trace.h\nlinux/arch.o: sanitizers.h subproc.h\nlinux/bfd.o: linux/bfd.h linux/unwind.h sanitizers.h honggfuzz.h\nlinux/bfd.o: libhfcommon/util.h libhfcommon/common.h libhfcommon/files.h\nlinux/bfd.o: libhfcommon/common.h libhfcommon/log.h\nlinux/perf.o: linux/perf.h honggfuzz.h libhfcommon/util.h\nlinux/perf.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nlinux/perf.o: libhfcommon/log.h linux/pt.h\nlinux/pt.o: linux/pt.h honggfuzz.h libhfcommon/util.h libhfcommon/common.h\nlinux/pt.o: libhfcommon/log.h\nlinux/trace.o: linux/trace.h honggfuzz.h libhfcommon/util.h\nlinux/trace.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nlinux/trace.o: libhfcommon/log.h linux/bfd.h linux/unwind.h sanitizers.h\nlinux/trace.o: report.h socketfuzzer.h subproc.h\nlinux/unwind.o: linux/unwind.h sanitizers.h honggfuzz.h libhfcommon/util.h\nlinux/unwind.o: libhfcommon/common.h libhfcommon/log.h\nmac/arch.o: arch.h honggfuzz.h libhfcommon/util.h fuzz.h libhfcommon/common.h\nmac/arch.o: libhfcommon/files.h libhfcommon/common.h libhfcommon/log.h\nmac/arch.o: subproc.h\nnetbsd/arch.o: arch.h honggfuzz.h libhfcommon/util.h fuzz.h\nnetbsd/arch.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nnetbsd/arch.o: libhfcommon/log.h libhfcommon/ns.h netbsd/trace.h subproc.h\nnetbsd/trace.o: netbsd/trace.h honggfuzz.h libhfcommon/util.h\nnetbsd/trace.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nnetbsd/trace.o: libhfcommon/log.h netbsd/unwind.h sanitizers.h report.h\nnetbsd/trace.o: subproc.h\nnetbsd/unwind.o: netbsd/unwind.h sanitizers.h honggfuzz.h libhfcommon/util.h\nnetbsd/unwind.o: libhfcommon/common.h libhfcommon/log.h\nposix/arch.o: arch.h honggfuzz.h libhfcommon/util.h fuzz.h\nposix/arch.o: libhfcommon/common.h libhfcommon/files.h libhfcommon/common.h\nposix/arch.o: libhfcommon/log.h report.h sanitizers.h subproc.h\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.728515625,
          "content": "# Honggfuzz\n\n## Description\n\nA security oriented, feedback-driven, evolutionary, easy-to-use fuzzer with interesting analysis options. See the [Usage document](https://github.com/google/honggfuzz/blob/master/docs/USAGE.md) for a primer on Honggfuzz use.\n\n## Code\n\n  * Latest stable version: [2.6](https://github.com/google/honggfuzz/releases)\n  * [Changelog](https://github.com/google/honggfuzz/blob/master/CHANGELOG)\n\n## Installation\n```\nsudo apt-get install binutils-dev libunwind-dev libblocksruntime-dev clang\nmake\n```\n\n## Features\n\n  * It's __multi-process__ and __multi-threaded__: there's no need to run multiple copies of your fuzzer, as honggfuzz can unlock potential of all your available CPU cores with a single running instance. The file corpus is automatically shared and improved between all fuzzed processes.\n  * It's blazingly fast when the [persistent fuzzing mode](https://github.com/google/honggfuzz/blob/master/docs/PersistentFuzzing.md) is used. A simple/empty _LLVMFuzzerTestOneInput_ function can be tested with __up to 1mo iterations per second__ on a relatively modern CPU (e.g. i7-6700K).\n  * Has a [solid track record](#trophies) of uncovered security bugs: the __only__ (to the date) __vulnerability in OpenSSL with the [critical](https://www.openssl.org/news/secadv/20160926.txt) score mark__ was discovered by honggfuzz. See the [Trophies](#trophies) paragraph for the summary of findings to the date.\n  * Uses low-level interfaces to monitor processes (e.g. _ptrace_ under Linux and NetBSD). As opposed to other fuzzers, it __will discover and report hijacked/ignored signals from crashes__ (intercepted and potentially hidden by a fuzzed program).\n  * Easy-to-use, feed it a simple corpus directory (can even be empty for the [feedback-driven fuzzing](https://github.com/google/honggfuzz/blob/master/docs/FeedbackDrivenFuzzing.md)), and it will work its way up, expanding it by utilizing feedback-based coverage metrics.\n  * Supports several (more than any other coverage-based feedback-driven fuzzer) hardware-based (CPU: branch/instruction counting, __Intel BTS__, __Intel PT__) and software-based [feedback-driven fuzzing](https://github.com/google/honggfuzz/blob/master/docs/FeedbackDrivenFuzzing.md) modes. Also, see the new __[qemu mode](https://github.com/google/honggfuzz/tree/master/qemu_mode)__ for blackbox binary fuzzing.\n  * Works (at least) under GNU/Linux, FreeBSD, NetBSD, Mac OS X, Windows/CygWin and [Android](https://github.com/google/honggfuzz/blob/master/docs/Android.md).\n  * Supports the __persistent fuzzing mode__ (long-lived process calling a fuzzed API repeatedly). More on that can be found [here](https://github.com/google/honggfuzz/blob/master/docs/PersistentFuzzing.md).\n  * It comes with the __[examples](https://github.com/google/honggfuzz/tree/master/examples) directory__, consisting of real world fuzz setups for widely-used software (e.g. Apache HTTPS, OpenSSL, libjpeg etc.).\n  * Provides a __[corpus minimization](https://github.com/google/honggfuzz/blob/master/docs/USAGE.md#corpus-minimization--m)__ mode.\n\n---\n\n<p align=\"center\">\n <img src=\"https://raw.githubusercontent.com/google/honggfuzz/master/screenshot-honggfuzz-1.png\" width=\"75%\" height=\"75%\">\n</p>\n\n---\n\n## Requirements\n\n  * **Linux** - The BFD library (libbfd-dev) and libunwind (libunwind-dev/libunwind8-dev), clang-5.0 or higher for software-based coverage modes\n  * **FreeBSD** - gmake, clang-5.0 or newer\n  * **NetBSD** - gmake, clang, capstone, libBlocksRuntime\n  * **Android** - Android SDK/NDK. Also see [this detailed doc](https://github.com/google/honggfuzz/blob/master/docs/Android.md) on how to build and run it\n  * **Windows** - CygWin\n  * **Darwin/OS X** - Xcode 10.8+\n  * if **Clang/LLVM** is used to compile honggfuzz - link it with the BlocksRuntime Library (libblocksruntime-dev)\n\n## Trophies\n\nHonggfuzz has been used to find a few interesting security problems in major software packages; An incomplete list:\n\n  * Dozens of security problems via the [OSS-Fuzz](https://bugs.chromium.org/p/oss-fuzz/issues/list?q=honggfuzz&can=1) project\n  * [Pre-auth remote crash in __OpenSSH__](https://anongit.mindrot.org/openssh.git/commit/?id=28652bca29046f62c7045e933e6b931de1d16737)\n  * __Apache HTTPD__\n    * [Remote crash in __mod\\_http2__ • CVE-2017-7659](http://seclists.org/oss-sec/2017/q2/504)\n    * [Use-after-free in __mod\\_http2__ • CVE-2017-9789](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9789)\n    * [Memory leak in __mod\\_auth\\_digest__ • CVE-2017-9788](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9788)\n    * [Out of bound access • CVE-2018-1301](http://seclists.org/oss-sec/2018/q1/265)\n    * [Write after free in HTTP/2 • CVE-2018-1302](http://seclists.org/oss-sec/2018/q1/268)\n    * [Out of bound read • CVE-2018-1303](http://seclists.org/oss-sec/2018/q1/266)\n  * Various __SSL__ libs\n    * [Remote OOB read in __OpenSSL__ • CVE-2015-1789]( https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-1789)\n    * [Remote Use-after-Free (potential RCE, rated as __critical__) in __OpenSSL__ • CVE-2016-6309](https://www.openssl.org/news/secadv/20160926.txt)\n    * [Remote OOB write in __OpenSSL__ • CVE-2016-7054](https://www.openssl.org/news/secadv/20161110.txt)\n    * [Remote OOB read in __OpenSSL__ • CVE-2017-3731](https://www.openssl.org/news/secadv/20170126.txt)\n    * [Uninitialized mem use in __OpenSSL__](https://github.com/openssl/openssl/commit/bd5d27c1c6d3f83464ddf5124f18a2cac2cbb37f)\n    * [Crash in __LibreSSL__](https://github.com/openbsd/src/commit/c80d04452814d5b0e397817ce4ed34edb4eb520d)\n    * [Invalid free in __LibreSSL__](https://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-2.6.2-relnotes.txt)\n    * [Uninitialized mem use in __BoringSSL__](https://github.com/boringssl/boringssl/commit/7dccc71e08105b100c3acd56fa5f6fc1ba9b71d3)\n  * [Adobe __Flash__ memory corruption • CVE-2015-0316](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-0316)\n  * [Multiple bugs in the __libtiff__ library](http://bugzilla.maptools.org/buglist.cgi?query_format=advanced;emailreporter1=1;email1=robert@swiecki.net;product=libtiff;emailtype1=substring)\n  * [Multiple bugs in the __librsvg__ library](https://bugzilla.gnome.org/buglist.cgi?query_format=advanced;emailreporter1=1;email1=robert%40swiecki.net;product=librsvg;emailtype1=substring)\n  * [Multiple bugs in the __poppler__ library](http://lists.freedesktop.org/archives/poppler/2010-November/006726.html)\n  * [Multiple exploitable bugs in __IDA-Pro__](https://www.hex-rays.com/bugbounty.shtml)\n  * [Remote DoS in __Crypto++__ • CVE-2016-9939](http://www.openwall.com/lists/oss-security/2016/12/12/7)\n  * Programming language interpreters\n    * [__PHP/Python/Ruby__](https://github.com/dyjakan/interpreter-bugs)\n    * [PHP WDDX](https://bugs.php.net/bug.php?id=74145)\n    * [PHP](https://bugs.php.net/bug.php?id=74194)\n    * Perl: [#1](https://www.nntp.perl.org/group/perl.perl5.porters/2018/03/msg250072.html), [#2](https://github.com/Perl/perl5/issues/16468), [#3](https://github.com/Perl/perl5/issues/16015)\n  * [Double-free in __LibXMP__](https://github.com/cmatsuoka/libxmp/commit/bd1eb5cfcd802820073504c234c3f735e96c3355)\n  * [Heap buffer overflow in SAPCAR • CVE-2017-8852](https://www.coresecurity.com/blog/sapcar-heap-buffer-overflow-crash-exploit)\n  * [Crashes in __libbass__](http://seclists.org/oss-sec/2017/q4/185)\n  * __FreeType 2__:\n    * [CVE-2010-2497](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2497)\n    * [CVE-2010-2498](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2498)\n    * [CVE-2010-2499](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2499)\n    * [CVE-2010-2500](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2500)\n    * [CVE-2010-2519](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2519)\n    * [CVE-2010-2520](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2520)\n    * [CVE-2010-2527](https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2010-2527)\n  * Stack corruption issues in the Windows OpenType parser: [#1](https://github.com/xinali/AfdkoFuzz/blob/4eadcb19eacb2fb73e4b0f0b34f382a9331bb3b4/CrashesAnalysis/CrashesAnalysis_3/README.md), [#2](https://github.com/xinali/AfdkoFuzz/blob/master/CVE-2019-1117/README.md), [#3](https://github.com/xinali/AfdkoFuzz/tree/f6d6562dd19403cc5a1f8cef603ee69425b68b20/CVE-2019-1118)\n  * [Infinite loop in __NGINX Unit__](https://github.com/nginx/unit/commit/477e8177b70acb694759e62d830b8a311a736324)\n  * A couple of problems in the [__MATLAB MAT File I/O Library__](https://sourceforge.net/projects/matio): [#1](https://github.com/tbeu/matio/commit/406438f497931f45fb3edf6de17d3a59a922c257), [#2](https://github.com/tbeu/matio/commit/406438f497931f45fb3edf6de17d3a59a922c257), [#3](https://github.com/tbeu/matio/commit/a55b9c2c01582b712d5a643699a13b5c41687db1), [#4](https://github.com/tbeu/matio/commit/3e6283f37652e29e457ab9467f7738a562594b6b), [#5](https://github.com/tbeu/matio/commit/783ee496a6914df68e77e6019054ad91e8ed6420)\n  * [__NASM__](https://github.com/netwide-assembler/nasm) [#1](https://bugzilla.nasm.us/show_bug.cgi?id=3392501), [#2](https://bugzilla.nasm.us/show_bug.cgi?id=3392750), [#3](https://bugzilla.nasm.us/show_bug.cgi?id=3392751), [#4](https://bugzilla.nasm.us/show_bug.cgi?id=3392760),  [#5](https://bugzilla.nasm.us/show_bug.cgi?id=3392761), [#6](https://bugzilla.nasm.us/show_bug.cgi?id=3392762), [#7](https://bugzilla.nasm.us/show_bug.cgi?id=3392792), [#8](https://bugzilla.nasm.us/show_bug.cgi?id=3392793), [#9](https://bugzilla.nasm.us/show_bug.cgi?id=3392795), [#10](https://bugzilla.nasm.us/show_bug.cgi?id=3392796)\n  * __Samba__ [tdbdump + tdbtool](http://seclists.org/oss-sec/2018/q2/206), [#2](https://github.com/samba-team/samba/commit/183da1f9fda6f58cdff5cefad133a86462d5942a), [#3](https://github.com/samba-team/samba/commit/33e9021cbee4c17ee2f11d02b99902a742d77293), [#4](https://github.com/samba-team/samba/commit/ac1be895d2501dc79dcff2c1e03549fe5b5a930c), [#5](https://github.com/samba-team/samba/commit/b1eda993b658590ebb0a8225e448ce399946ed83), [#6](https://github.com/samba-team/samba/commit/f7f92803f600f8d302cdbb668c42ca8b186a797f) [CVE-2019-14907](https://www.samba.org/samba/security/CVE-2019-14907.html) [CVE-2020-10745](https://www.samba.org/samba/security/CVE-2020-10745.html) [CVE-2021-20277](https://www.samba.org/samba/security/CVE-2021-20277.html) [LPRng_time](https://github.com/smokey57/samba/commit/fc267567a072c9483bbcc5cc18e150244bc5376b)\n  * [Crash in __djvulibre__](https://github.com/barak/djvulibre/commit/89d71b01d606e57ecec2c2930c145bb20ba5bbe3)\n  * [Multiple crashes in __VLC__](https://www.pentestpartners.com/security-blog/double-free-rce-in-vlc-a-honggfuzz-how-to/)\n  * [Buffer overflow in __ClassiCube__](https://github.com/UnknownShadow200/ClassiCube/issues/591)\n  * [Heap buffer-overflow (or UAF) in __MPV__](https://github.com/mpv-player/mpv/issues/6808)\n  * [Heap buffer-overflow in __picoc__](https://gitlab.com/zsaleeba/picoc/issues/44)\n  * Crashes in __OpenCOBOL__: [#1](https://sourceforge.net/p/open-cobol/bugs/586/), [#2](https://sourceforge.net/p/open-cobol/bugs/587/)\n  * DoS in __ProFTPD__: [#1](https://twitter.com/SecReLabs/status/1186548245553483783) • [#2](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18217)\n  * [Multiple security problems in ImageIO (iOS/MacOS)](https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html)\n  * [Memory corruption in __htmldoc__](https://github.com/michaelrsweet/htmldoc/issues/370)\n  * [Memory corruption in __OpenDetex__](https://github.com/pkubowicz/opendetex/issues/60)\n  * [Memory corruption in __Yabasic__](https://github.com/marcIhm/yabasic/issues/36)\n  * [Memory corruption in __Xfig__](https://sourceforge.net/p/mcj/tickets/67/)\n  * [Memory corruption in __LibreOffice__](https://github.com/LibreOffice/core/commit/0754e581b0d8569dd08cf26f88678754f249face)\n  * [Memory corruption in __ATasm__](https://sourceforge.net/p/atasm/bugs/8/)\n  * [Memory corruption in __oocborrt__](https://warcollar.com/cve-2020-24753.html) • [CVE-2020-24753](https://nvd.nist.gov/vuln/detail/CVE-2020-24753)\n  * [Memory corruption in __LibRaw__](https://github.com/LibRaw/LibRaw/issues/309)\n  * [NULL-ptr deref in __peg-markdown__](https://github.com/jgm/peg-markdown/issues/43)\n  * [Uninitialized value in __MD4C__](https://github.com/mity/md4c/issues/130) • [CVE-2020-26148](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-26148)\n  * [17 new bugs in __fwupd__](https://github.com/google/oss-fuzz/pull/4823#issue-537143670)\n  * [Assertion in __libvips__](https://github.com/libvips/libvips/issues/1890)\n  * [Crash in __libocispec__)(https://github.com/containers/libocispec/commit/6079cd9490096cfb46752bd7491c71253418a02c)\n  * __Rust__:\n    * panic() in regex [#1](https://github.com/rust-lang/regex/issues/464), [#2](https://github.com/rust-lang/regex/issues/465), [#3](https://github.com/rust-lang/regex/issues/465#issuecomment-381412816)\n    * panic() in h2 [#1](https://github.com/carllerche/h2/pull/260), [#2](https://github.com/carllerche/h2/pull/261), [#3](https://github.com/carllerche/h2/pull/262)\n    * panic() in sleep-parser [#1](https://github.com/datrs/sleep-parser/issues/3)\n    * panic() in lewton [#1](https://github.com/RustAudio/lewton/issues/27)\n    * panic()/DoS in Ethereum-Parity [#1](https://srlabs.de/bites/ethereum_dos/)\n    * crash() in Parts - a GPT partition manager [#1](https://github.com/DianaNites/parts/commit/d8ab05d48d87814f362e94f01c93d9eeb4f4abf4)\n    * crashes in rust-bitcoin/rust-lightning [#1](https://github.com/rust-bitcoin/rust-lightning/commit/a9aa3c37fe182dd266e0faebc788e0c9ee724783)\n  * ... and more\n\n## Projects utilizing or inspired-by Honggfuzz\n\n  * [__QuickFuzz__ by CIFASIS](https://github.com/CIFASIS/QuickFuzz)\n  * [__OSS-Fuzz__](https://github.com/google/oss-fuzz)\n  * [__Frog And Fuzz__](https://github.com/warsang/FrogAndFuzz/tree/develop)\n  * [__interpreters fuzzing__: by dyjakan](https://github.com/dyjakan/interpreter-bugs)\n  * [__riufuzz__: honggfuzz with AFL-like UI](https://github.com/riusksk/riufuzz)\n  * [__h2fuzz__: fuzzing Apache's HTTP/2 implementation](https://github.com/icing/h2fuzz)\n  * [__honggfuzz-dharma__: honggfuzz with dharma grammar fuzzer](https://github.com/Sbouber/honggfuzz-dharma)\n  * [__Owl__: a system for finding concurrency attacks](https://github.com/hku-systems/owl)\n  * [__honggfuzz-docker-apps__](https://github.com/skysider/honggfuzz_docker_apps)\n  * [__FFW__: Fuzzing For Worms](https://github.com/dobin/ffw)\n  * [__honggfuzz-rs__: fuzzing Rust with Honggfuzz](https://docs.rs/honggfuzz/)\n  * [__roughenough-fuzz__](https://github.com/int08h/roughenough-fuzz)\n  * [__Monkey__: a HTTP server](https://github.com/monkey/monkey/blob/master/FUZZ.md)\n  * [__Killerbeez API__: a modular fuzzing framework](https://github.com/grimm-co/killerbeez)\n  * [__FuzzM__: a gray box model-based fuzzing framework](https://github.com/collins-research/FuzzM)\n  * [__FuzzOS__: by Mozilla Security](https://github.com/MozillaSecurity/fuzzos)\n  * [__Android__: by OHA](https://android.googlesource.com/platform/external/honggfuzz)\n  * [__QDBI__: by Quarkslab](https://project.inria.fr/FranceJapanICST/files/2019/04/19-Kyoto-Fuzzing_Binaries_using_Dynamic_Instrumentation.pdf)\n  * [__fuzzer-test-suite__: by Google](https://github.com/google/fuzzer-test-suite)\n  * [__DeepState__: by Trail-of-Bits](https://github.com/trailofbits/deepstate)\n  * [__Quiche-HTTP/3__: by Cloudflare](https://github.com/cloudflare/quiche/pull/179)\n  * [__Bolero__: fuzz and property testing framework](https://github.com/camshaft/bolero)\n  * [__pwnmachine__: a vagrantfile for exploit development on Linux](https://github.com/kapaw/pwnmachine/commit/9cbfc6f1f9547ed2d2a5d296f6d6cd8fac0bb7e1)\n  * [__Quick700__: analyzing effectiveness of fuzzers on web browsers and web servers](https://github.com/Quick700/Quick700)\n  * [__python-hfuzz__: gluing honggfuzz and python3](https://github.com/thebabush/python-hfuzz)\n  * [__go-hfuzz__: gluing honggfuzz and go](https://github.com/thebabush/go-hfuzz)\n  * [__Magma__: a ground-truth fuzzing benchmark](https://github.com/HexHive/magma)\n  * [__arbitrary-model-tests__: a procedural macro for testing stateful models](https://github.com/jakubadamw/arbitrary-model-tests)\n  * [__Clusterfuzz__: the fuzzing engine behind OSS-fuzz/Chrome-fuzzing](https://github.com/google/clusterfuzz/issues/1128)\n  * [__Apache HTTP Server__](https://github.com/apache/httpd/commit/d7328a07d7d293deb5ce62a60c2ce6029104ebad)\n  * [__centos-fuzz__](https://github.com/truelq/centos-fuzz)\n  * [__FLUFFI__: Fully Localized Utility For Fuzzing Instantaneously by Siemens](https://github.com/siemens/fluffi)\n  * [__Fluent Bit__: a fast log processor and forwarder for Linux](https://github.com/fluent/fluent-bit/search?q=honggfuzz&unscoped_q=honggfuzz)\n  * [__Samba__: a SMB server](https://github.com/samba-team/samba/blob/2a90202052558c945e02675d1331e65aeb15f9fa/lib/fuzzing/README.md)\n  * [__universal-fuzzing-docker__: by nnamon](https://github.com/nnamon/universal-fuzzing-docker)\n  * [__Canokey Core__: core implementations of an open-source secure key](https://github.com/canokeys/canokey-core/search?q=honggfuzz&unscoped_q=honggfuzz)\n  * [__uberfuzz2__: a cooperative fuzzing framework](https://github.com/acidghost/uberfuzz2)\n  * [__TiKV__: a distributed transactional key-value database](https://github.com/tikv/tikv/tree/99a922564face31bdb59b5b38962339f79e0015c/fuzz)\n  * [__fuzz-monitor__](https://github.com/acidghost/fuzz-monitor/search?q=honggfuzz&unscoped_q=honggfuzz)\n  * [__libmutator__: a C library intended to generate random test cases by mutating legitimate test cases](https://github.com/denandz/libmutator)\n  * [__StatZone__: a DNS zone file analyzer](https://github.com/fcambus/statzone)\n  * [__shub-fuzz/honggfuzz__: singularity image for honggfuzz](https://github.com/shub-fuzz/honggfuzz)\n  * [__Code Intelligence__: fuzzing-as-a-service](https://www.code-intelligence.com/technology.html)\n  * [__SpecFuzz__: fuzzing for Spectre vulnerabilities](https://github.com/OleksiiOleksenko/SpecFuzz)\n  * [__rcc__: a Rust C compiler](https://github.com/jyn514/rcc#testing)\n  * [__EIP1962Fuzzing__: Fuzzy testing of various EIP1962 implementations](https://github.com/matter-labs/eip1962_fuzzing)\n  * [__wasm-fuzz__: Fuzzing of wasmer](https://github.com/wasmerio/wasm-fuzz/blob/master/honggfuzz.md), [blog post](https://medium.com/wasmer/fuzz-testing-in-webassembly-vms-3a301f982e5a)\n  * [__propfuzz__: Rust tools to combine coverage-guided fuzzing with property-based testing - from Facebook](https://github.com/facebookincubator/propfuzz)\n  * [__Bitcoin Core__: fuzzing](https://github.com/Nampu898/btc-2/blob/2af56d6d5c387c3208d3d5aae8d428a3d610446f/doc/fuzzing.md#fuzzing-bitcoin-core-using-honggfuzz)\n  * [__ESP32-Fuzzing-Framework__: A Fuzzing Framework for ESP32 applications](https://github.com/MaxCamillo/esp32-fuzzing-framework/tree/5130a3c7bf9796fdeb44346eec3dcdc7e507a62b)\n  * [__Fuzzbench__: Fuzzer Benchmarking As a Service](https://www.fuzzbench.com/)\n  * [__rumpsyscallfuzz__: NetBSD Rump Kernel fuzzing](https://github.com/adityavardhanpadala/rumpsyscallfuzz)\n  * [__libnbd__: fuzzing libnbd with honggfuzz](https://github.com/libguestfs/libnbd/commit/329c5235f81ab0d1849946bab5e5c4119b35e140)\n  * [__EnsmallenGraph__: Rust library to run node2vec-like weighted random walks on very big graphs](https://github.com/LucaCappelletti94/ensmallen_graph/)\n  * [__Oasis Core__](https://github.com/oasisprotocol/oasis-core/)\n  * [__bp7-rs__: Rust implementation of dtn bundle protocol 7](https://github.com/dtn7/bp7-rs)\n  * [__WHATWG__: URL C++ library](https://github.com/rmisev/url_whatwg/commit/0bb2821ccab170c7b12b45524a2196eb7bf35e0b)\n  * [__Xaya Core / Chimera__: A decentralized open source information registration and transfer system](https://github.com/xaya/xaya/commit/b337bd7bc0873ace317ad8e1ebbd3842da3f81d5)\n  * [__OpenWRT__: A Linux operating system targeting embedded devices](https://github.com/ynezz/openwrt-ci/commit/70956d056b1d041c28b76e9e06574d511b428f68)\n  * [__RcppDeepStateTools__: A Linux-specific R package, with R functions for running the DeepState test harness](https://github.com/akhikolla/RcppDeepStateTools/commit/0b85b0b8b2ab357a0840f45957e2cb285d98d430)\n  * [__Materialize__: A streaming database for real-time applications](https://github.com/MaterializeInc/materialize/pull/5519/commits/5eb09adb687c4980fc899582cefaa5e43d6e8ce7)\n  * [__Rust-Bitcoin__](https://github.com/rust-bitcoin/rust-lightning/pull/782)\n  * [__Substrate__: A next-generation framework for blockchain innovation](https://github.com/rakanalh/substrate/pull/5)\n  * [__Solana__: A fast, secure, and censorship resistant blockchain](https://github.com/solana-labs/solana/issues/14707)\n  * [__fwupd__: A project that aims to make updating firmware on Linux automatic, safe and reliable](https://github.com/fwupd/fwupd/pull/2666)\n  * [__polkadot__: Implementation of a https://polkadot.network node in Rust based on the Substrate framework](https://github.com/paritytech/polkadot/pull/2021/commits/b731cfa34e330489ecd832b058e82ce2b88f75f5)\n  * [__systemd__: is tested by honggfuzz](https://github.com/systemd/systemd/commit/d2c3f14fed67e7246adfdeeb5957c0d0497d7dc7)\n  * [__freetype__: is tested by honggfuzz](https://github.com/freetype/freetype2-testing/commit/e401ce29d7bfe37cfd0085c244e213c913221b5f)\n  * [__ghostscript__: is tested by honggfuzz](https://github.com/google/oss-fuzz/commit/365df31265438684a50c500e7d9355744fd7965d)\n  * [__Fuzzme__: fuzzing templates for programming languages and fuzzers](https://github.com/ForAllSecure/fuzzme)\n  * [__P0__: Fuzzing ImageIO](https://googleprojectzero.blogspot.com/2020/04/fuzzing-imageio.html)\n    * [__TrapFuzz__: by P0](https://github.com/googleprojectzero/p0tools/tree/master/TrapFuzz)\n  * [__Rust's fuzztest__](https://docs.rs/crate/fuzztest)\n    * [_and multiple Rust projects_](https://github.com/search?q=%22extern+crate+honggfuzz%22&type=Code)\n\n## Contact\n\n  * User mailing list: [honggfuzz@googlegroups.com](mailto:honggfuzz@googlegroups.com), sign up with [this link](https://groups.google.com/forum/#!forum/honggfuzz).\n\n__This is NOT an official Google product__\n"
        },
        {
          "name": "android",
          "type": "tree",
          "content": null
        },
        {
          "name": "arch.h",
          "type": "blob",
          "size": 1.1767578125,
          "content": "/*\n *\n * honggfuzz - architecture dependent code\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_ARCH_H_\n#define _HF_ARCH_H_\n\n#include \"honggfuzz.h\"\n\nextern bool arch_launchChild(run_t* run);\n\nextern bool arch_archInit(honggfuzz_t* fuzz);\n\nextern bool arch_archThreadInit(run_t* run);\n\nextern pid_t arch_fork(run_t* run);\n\nextern void arch_reapChild(run_t* run);\n\nextern void arch_reapKill(void);\n\nextern void arch_prepareParent(run_t* run);\n\nextern void arch_prepareParentAfterFork(run_t* run);\n\n#endif /* _HF_ARCH_H_ */\n"
        },
        {
          "name": "cmdline.c",
          "type": "blob",
          "size": 35.328125,
          "content": "/*\n\n   honggfuzz - cmdline parsing\n\n   -----------------------------------------\n\n   Copyright 2014 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include \"cmdline.h\"\n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <limits.h>\n#if defined(_HF_ARCH_LINUX)\n#include <sched.h>\n#endif /* defined(_HF_ARCH_LINUX) */\n#include <pthread.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/mman.h>\n#include <sys/queue.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"display.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/files.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n\nstruct custom_option {\n    struct option opt;\n    const char*   descr;\n};\n\nstatic bool checkFor_FILE_PLACEHOLDER(const char* const* args) {\n    for (int x = 0; args[x]; x++) {\n        if (strstr(args[x], _HF_FILE_PLACEHOLDER)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool cmdlineCheckBinaryType(honggfuzz_t* hfuzz) {\n    int      fd;\n    off_t    fileSz;\n    uint8_t* map = files_mapFile(hfuzz->exe.cmdline[0], &fileSz, &fd, /* isWriteable= */ false);\n    if (!map) {\n        /* It's not a critical error */\n        return true;\n    }\n    defer {\n        if (munmap(map, fileSz) == -1) {\n            PLOG_W(\"munmap(%p, %zu)\", map, (size_t)fileSz);\n        }\n        close(fd);\n    };\n\n    if (memmem(map, fileSz, _HF_PERSISTENT_SIG, strlen(_HF_PERSISTENT_SIG))) {\n        LOG_I(\"Persistent signature found in '%s'. Enabling persistent fuzzing mode\",\n            hfuzz->exe.cmdline[0]);\n        hfuzz->exe.persistent = true;\n    }\n    if (memmem(map, fileSz, _HF_NETDRIVER_SIG, strlen(_HF_NETDRIVER_SIG))) {\n        LOG_I(\"NetDriver signature found '%s'\", hfuzz->exe.cmdline[0]);\n        hfuzz->exe.netDriver = true;\n    }\n    return true;\n}\n\nstatic void cmdlineHelp(const char* pname, struct custom_option* opts) {\n    LOG_HELP_BOLD(\"Usage: %s [options] -- path_to_command [args]\", pname);\n    LOG_HELP_BOLD(\"Options:\");\n    for (int i = 0; opts[i].opt.name; i++) {\n        if (isprint(opts[i].opt.val) && opts[i].opt.val < 0x80) {\n            LOG_HELP_BOLD(\" --%s%s%c %s\", opts[i].opt.name, \"|-\", opts[i].opt.val,\n                opts[i].opt.has_arg == required_argument ? \"VALUE\" : \"\");\n        } else {\n            LOG_HELP_BOLD(\" --%s %s\", opts[i].opt.name,\n                opts[i].opt.has_arg == required_argument ? \"VALUE\" : \"\");\n        }\n        LOG_HELP(\"\\t%s\", opts[i].descr);\n    }\n    LOG_HELP_BOLD(\"\\nExamples:\");\n    LOG_HELP(\n        \" Run the binary over a mutated file chosen from the directory. Disable fuzzing feedback \"\n        \"(static mode):\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" -i input_dir -x -- /usr/bin/djpeg \" _HF_FILE_PLACEHOLDER);\n    LOG_HELP(\" As above, provide input over STDIN:\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" -i input_dir -x -s -- /usr/bin/djpeg\");\n    LOG_HELP(\" Use compile-time instrumentation (-fsanitize-coverage=trace-pc-guard,...):\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" -i input_dir -- /usr/bin/djpeg \" _HF_FILE_PLACEHOLDER);\n    LOG_HELP(\" Use persistent mode w/o instrumentation:\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" -i input_dir -P -x -- /usr/bin/djpeg_persistent_mode\");\n    LOG_HELP(\" Use persistent mode and compile-time (-fsanitize-coverage=trace-pc-guard,...) \"\n             \"instrumentation:\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" -i input_dir -P -- /usr/bin/djpeg_persistent_mode\");\n#if defined(_HF_ARCH_LINUX)\n    LOG_HELP(\n        \" Run the binary with dynamically generate inputs, maximize total no. of instructions:\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" --linux_perf_instr -- /usr/bin/djpeg \" _HF_FILE_PLACEHOLDER);\n    LOG_HELP(\" As above, maximize total no. of branches:\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" --linux_perf_branch -- /usr/bin/djpeg \" _HF_FILE_PLACEHOLDER);\n    LOG_HELP(\" As above, maximize unique branches (edges) via Intel BTS:\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" --linux_perf_bts_edge -- /usr/bin/djpeg \" _HF_FILE_PLACEHOLDER);\n    LOG_HELP(\n        \" As above, maximize unique code blocks via Intel Processor Trace (requires libipt.so):\");\n    LOG_HELP_BOLD(\"  \" PROG_NAME \" --linux_perf_ipt_block -- /usr/bin/djpeg \" _HF_FILE_PLACEHOLDER);\n#endif /* defined(_HF_ARCH_LINUX) */\n}\n\nstatic void cmdlineUsage(const char* pname, struct custom_option* opts) {\n    cmdlineHelp(pname, opts);\n    exit(EXIT_SUCCESS);\n}\n\nbool cmdlineAddEnv(honggfuzz_t* hfuzz, char* env) {\n    size_t      enveqlen = strlen(env);\n    const char* eqpos    = strchr(env, '=');\n    if (eqpos) {\n        enveqlen = (uintptr_t)eqpos - (uintptr_t)env + 1;\n    }\n\n    for (size_t i = 0; i < ARRAYSIZE(hfuzz->exe.env_ptrs); i++) {\n        if (hfuzz->exe.env_ptrs[i] == NULL) {\n            LOG_D(\"Adding envar '%s' at pos: %zu\", env, i);\n            hfuzz->exe.env_ptrs[i] = hfuzz->exe.env_vals[i];\n            snprintf(hfuzz->exe.env_vals[i], sizeof(hfuzz->exe.env_vals[i]), \"%s\", env);\n            return true;\n        }\n        if (strncmp(hfuzz->exe.env_vals[i], env, enveqlen) == 0) {\n            LOG_W(\"Replacing envar '%s' with '%s'\", hfuzz->exe.env_vals[i], env);\n            snprintf(hfuzz->exe.env_vals[i], sizeof(hfuzz->exe.env_vals[i]), \"%s\", env);\n            hfuzz->exe.env_ptrs[i] = hfuzz->exe.env_vals[i];\n            return true;\n        }\n    }\n    LOG_E(\"No more space for new envars (max.%zu)\", ARRAYSIZE(hfuzz->exe.env_ptrs));\n    return false;\n}\n\ntristate_t cmdlineParseTriState(const char* optname, const char* optarg) {\n    if (!optarg) {\n        LOG_F(\"Option '--%s' needs an argument (true|false|maybe)\", optname);\n    }\n    /* Probably '-' belongs to the next option */\n    if (optarg[0] == '-') {\n        LOG_F(\"Option '--%s' needs an argument (true|false|maybe)\", optname);\n    }\n    if ((strcasecmp(optarg, \"0\") == 0) || (strcasecmp(optarg, \"false\") == 0) ||\n        (strcasecmp(optarg, \"n\") == 0) || (strcasecmp(optarg, \"no\") == 0)) {\n        return HF_NO;\n    }\n    if ((strcasecmp(optarg, \"1\") == 0) || (strcasecmp(optarg, \"true\") == 0) ||\n        (strcasecmp(optarg, \"y\") == 0) || (strcasecmp(optarg, \"yes\") == 0)) {\n        return HF_YES;\n    }\n    if ((strcasecmp(optarg, \"-1\") == 0) || (strcasecmp(optarg, \"maybe\") == 0) ||\n        (strcasecmp(optarg, \"m\") == 0) || (strcasecmp(optarg, \"if_supported\") == 0)) {\n        return HF_MAYBE;\n    }\n    LOG_F(\"Unknown value for option --%s=%s. Use true, false or maybe\", optname, optarg);\n    return HF_NO;\n}\n\nbool cmdlineParseTrueFalse(const char* optname, const char* optarg) {\n    if (!optarg) {\n        LOG_F(\"Option '--%s' needs an argument (true|false)\", optname);\n    }\n    /* Probably '-' belong to the next option */\n    if (optarg[0] == '-') {\n        LOG_F(\"Option '--%s' needs an argument (true|false)\", optname);\n    }\n    if ((strcasecmp(optarg, \"0\") == 0) || (strcasecmp(optarg, \"false\") == 0) ||\n        (strcasecmp(optarg, \"n\") == 0) || (strcasecmp(optarg, \"no\") == 0)) {\n        return false;\n    }\n    if ((strcasecmp(optarg, \"1\") == 0) || (strcasecmp(optarg, \"true\") == 0) ||\n        (strcasecmp(optarg, \"y\") == 0) || (strcasecmp(optarg, \"yes\") == 0)) {\n        return true;\n    }\n    LOG_F(\"Unknown value for option --%s=%s. Use true or false\", optname, optarg);\n    return false;\n}\n\nrlim_t cmdlineParseRLimit(int res, const char* optarg, unsigned long mul) {\n    struct rlimit cur;\n    if (getrlimit(res, &cur) == -1) {\n        PLOG_F(\"getrlimit(%d)\", res);\n    }\n    if (strcasecmp(optarg, \"max\") == 0) {\n        return cur.rlim_max;\n    }\n    if (strcasecmp(optarg, \"def\") == 0) {\n        return cur.rlim_cur;\n    }\n    if (!util_isANumber(optarg)) {\n        LOG_F(\"RLIMIT %d needs a numeric or 'max'/'def' value ('%s' provided)\", res, optarg);\n    }\n    rlim_t val = strtoul(optarg, NULL, 0) * mul;\n    if ((unsigned long)val == ULONG_MAX && errno != 0) {\n        PLOG_F(\"strtoul('%s', 0)\", optarg);\n    }\n    return val;\n}\n\nstatic bool cmdlineVerify(honggfuzz_t* hfuzz) {\n    if (!cmdlineCheckBinaryType(hfuzz)) {\n        LOG_E(\"Couldn't test binary for signatures\");\n        return false;\n    }\n    if (hfuzz->exe.netDriver && hfuzz->arch_linux.useNetNs == HF_MAYBE) {\n        LOG_I(\"The binary uses netdriver, disabling network namespacing\");\n        hfuzz->arch_linux.useNetNs = HF_NO;\n    }\n\n    if (!hfuzz->exe.fuzzStdin && !hfuzz->exe.persistent &&\n        !checkFor_FILE_PLACEHOLDER(hfuzz->exe.cmdline)) {\n        LOG_E(\"You must specify '\" _HF_FILE_PLACEHOLDER\n              \"' if the -s (stdin fuzzing) or --persistent options are not set\");\n        return false;\n    }\n\n    if (hfuzz->threads.threadsMax >= _HF_THREAD_MAX) {\n        LOG_E(\"Too many fuzzing threads specified %zu (>= _HF_THREAD_MAX (%u))\",\n            hfuzz->threads.threadsMax, _HF_THREAD_MAX);\n        return false;\n    }\n    if (hfuzz->threads.threadsMax == 0) {\n        LOG_E(\"Too few fuzzing threads specified: %zu\", hfuzz->threads.threadsMax);\n        return false;\n    }\n\n    if (strchr(hfuzz->io.fileExtn, '/')) {\n        LOG_E(\"The file extension contains the '/' character: '%s'\", hfuzz->io.fileExtn);\n        return false;\n    }\n\n    if (hfuzz->io.outputDir && mkdir(hfuzz->io.outputDir, 0700) == -1 && errno != EEXIST) {\n        PLOG_E(\"Couldn't create the output directory '%s'\", hfuzz->io.outputDir);\n        return false;\n    }\n\n    if (strlen(hfuzz->io.workDir) == 0) {\n        if (getcwd(hfuzz->io.workDir, sizeof(hfuzz->io.workDir)) == NULL) {\n            PLOG_W(\"getcwd() failed. Using '.'\");\n            snprintf(hfuzz->io.workDir, sizeof(hfuzz->io.workDir), \".\");\n        }\n    }\n    if (mkdir(hfuzz->io.workDir, 0700) == -1 && errno != EEXIST) {\n        PLOG_E(\"Couldn't create the workspace directory '%s'\", hfuzz->io.workDir);\n        return false;\n    }\n    if (hfuzz->io.crashDir == NULL) {\n        hfuzz->io.crashDir = hfuzz->io.workDir;\n    }\n    if (mkdir(hfuzz->io.crashDir, 0700) && errno != EEXIST) {\n        PLOG_E(\"Couldn't create the crash directory '%s'\", hfuzz->io.crashDir);\n        return false;\n    }\n\n    if (hfuzz->mutate.mutationsPerRun == 0U && hfuzz->cfg.useVerifier) {\n        LOG_I(\"Verifier enabled with mutationsPerRun == 0, activating the dry run mode\");\n    }\n\n    if (hfuzz->io.maxFileSz > _HF_INPUT_MAX_SIZE) {\n        LOG_E(\"Maximum file size '%zu' bigger than the maximum size '%zu'\", hfuzz->io.maxFileSz,\n            (size_t)_HF_INPUT_MAX_SIZE);\n        return false;\n    }\n\n    return true;\n}\n\nbool cmdlineParse(int argc, char* argv[], honggfuzz_t* hfuzz) {\n    *hfuzz = (honggfuzz_t){\n        .threads =\n            {\n                .threadsFinished  = 0,\n                .threadsMax       = ({\n                    long ncpus = sysconf(_SC_NPROCESSORS_ONLN);\n                    (ncpus <= 1 ? 1 : ncpus / 2);\n                }),\n                .threadsActiveCnt = 0,\n                .pinThreadToCPUs  = 0,\n                .mainThread       = pthread_self(),\n                .mainPid          = getpid(),\n            },\n        .io =\n            {\n                .inputDir         = NULL,\n                .outputDir        = NULL,\n                .inputDirPtr      = NULL,\n                .fileCnt          = 0,\n                .testedFileCnt    = 0,\n                .maxFileSz        = 0,\n                .newUnitsAdded    = 0,\n                .fileExtn         = \"fuzz\",\n                .workDir          = {},\n                .crashDir         = NULL,\n                .covDirNew        = NULL,\n                .saveUnique       = true,\n                .saveSmaller      = false,\n                .dynfileqMaxSz    = 0U,\n                .dynfileqCnt      = 0U,\n                .dynfileqCurrent  = NULL,\n                .dynfileq2Current = NULL,\n                .exportFeedback   = false,\n                .dynamicInputDir  = NULL,\n                .statsFileName    = NULL,\n                .statsFileFd      = -1,\n            },\n        .exe =\n            {\n                .argc                  = 0,\n                .cmdline               = NULL,\n                .nullifyStdio          = true,\n                .fuzzStdin             = false,\n                .externalCommand       = NULL,\n                .postExternalCommand   = NULL,\n                .feedbackMutateCommand = NULL,\n                .persistent            = false,\n                .netDriver             = false,\n                .asLimit               = 0U,\n                .rssLimit              = 0U,\n                .dataLimit             = 0U,\n                .stackLimit            = 0U,\n                .clearEnv              = false,\n                .env_ptrs              = {},\n                .env_vals              = {},\n            },\n        .timing =\n            {\n                .timeStart              = time(NULL),\n                .runEndTime             = 0,\n                .tmOut                  = 1,\n                .lastCovUpdate          = time(NULL),\n                .exitOnTime             = 0,\n                .timeOfLongestUnitUSecs = 0,\n                .tmoutVTALRM            = false,\n            },\n        .mutate =\n            {\n                .mutationsMax    = 0,\n                .dictionary      = {},\n                .dictionaryCnt   = 0,\n                .dictionaryFile  = NULL,\n                .mutationsPerRun = 5,\n                .maxInputSz      = 0,\n            },\n        .display =\n            {\n                .useScreen        = true,\n                .lastDisplayUSecs = util_timeNowUSecs(),\n                .cmdline_txt[0]   = '\\0',\n            },\n        .cfg =\n            {\n                .useVerifier       = false,\n                .exitUponCrash     = false,\n                .exitCodeUponCrash = 0,\n                .reportFile        = NULL,\n                .dynFileIterExpire = 0,\n                .only_printable    = false,\n                .minimize          = false,\n                .switchingToFDM    = false,\n            },\n        .sanitizer =\n            {\n                .enable     = false,\n                .del_report = false,\n            },\n        .feedback =\n            {\n                .covFeedbackMap        = NULL,\n                .covFeedbackFd         = -1,\n                .cmpFeedbackMap        = NULL,\n                .cmpFeedbackFd         = -1,\n                .cmpFeedback           = true,\n                .blocklistFile         = NULL,\n                .blocklist             = NULL,\n                .blocklistCnt          = 0,\n                .skipFeedbackOnTimeout = false,\n                .dynFileMethod         = _HF_DYNFILE_SOFT,\n                .state                 = _HF_STATE_UNSET,\n                .hwCnts =\n                    {\n                        .cpuInstrCnt  = 0ULL,\n                        .cpuBranchCnt = 0ULL,\n                        .bbCnt        = 0ULL,\n                        .newBBCnt     = 0ULL,\n                        .softCntPc    = 0ULL,\n                        .softCntCmp   = 0ULL,\n                    },\n            },\n        .cnts =\n            {\n                .mutationsCnt       = 0,\n                .crashesCnt         = 0,\n                .uniqueCrashesCnt   = 0,\n                .verifiedCrashesCnt = 0,\n                .blCrashesCnt       = 0,\n                .timeoutedCnt       = 0,\n            },\n        .socketFuzzer =\n            {\n                .enabled      = false,\n                .serverSocket = -1,\n                .clientSocket = -1,\n            },\n        .mutex =\n            {\n                .dynfileq = PTHREAD_RWLOCK_INITIALIZER,\n                .feedback = PTHREAD_MUTEX_INITIALIZER,\n                .report   = PTHREAD_MUTEX_INITIALIZER,\n                .state    = PTHREAD_MUTEX_INITIALIZER,\n                .input    = PTHREAD_MUTEX_INITIALIZER,\n                .timing   = PTHREAD_MUTEX_INITIALIZER,\n            },\n\n        /* Linux code */\n        .arch_linux =\n            {\n                .exeFd                = -1,\n                .dynamicCutOffAddr    = ~(0ULL),\n                .disableRandomization = true,\n                .ignoreAddr           = NULL,\n                .symsBlFile           = NULL,\n                .symsBlCnt            = 0,\n                .symsBl               = NULL,\n                .symsWlFile           = NULL,\n                .symsWlCnt            = 0,\n                .symsWl               = NULL,\n                .cloneFlags           = 0,\n                .useNetNs             = HF_NO,\n                .kernelOnly           = false,\n                .useClone             = true,\n            },\n        /* NetBSD code */\n        .arch_netbsd =\n            {\n                .ignoreAddr = NULL,\n                .symsBlFile = NULL,\n                .symsBlCnt  = 0,\n                .symsBl     = NULL,\n                .symsWlFile = NULL,\n                .symsWlCnt  = 0,\n                .symsWl     = NULL,\n            },\n    };\n\n    TAILQ_INIT(&hfuzz->io.dynfileq);\n\n    // clang-format off\n    struct custom_option custom_opts[] = {\n        { { \"help\", no_argument, NULL, 'h' }, \"Help plz..\" },\n        { { \"input\", required_argument, NULL, 'i' }, \"Path to a directory containing initial file corpus\" },\n        { { \"output\", required_argument, NULL, 'o' }, \"Output data (new dynamic coverage corpus, or the minimized coverage corpus) is written to this directory (default: input directory is re-used)\" },\n        { { \"persistent\", no_argument, NULL, 'P' }, \"Enable persistent fuzzing (use hfuzz_cc/hfuzz-clang to compile code). This will be auto-detected!!!\" },\n        { { \"instrument\", no_argument, NULL, 'z' }, \"*DEFAULT-MODE-BY-DEFAULT* Enable compile-time instrumentation (use hfuzz_cc/hfuzz-clang to compile code)\" },\n        { { \"minimize\", no_argument, NULL, 'M' }, \"Minimize the input corpus. It will most likely delete some corpus files (from the --input directory) if no --output is used!\" },\n        { { \"noinst\", no_argument, NULL, 'x' }, \"Static mode only, disable any instrumentation (hw/sw) feedback\" },\n        { { \"keep_output\", no_argument, NULL, 'Q' }, \"Don't close children's stdin, stdout, stderr; can be noisy\" },\n        { { \"timeout\", required_argument, NULL, 't' }, \"Timeout in seconds (default: 1 (second))\" },\n        { { \"threads\", required_argument, NULL, 'n' }, \"Number of concurrent fuzzing threads (default: number of CPUs / 2)\" },\n        { { \"stdin_input\", no_argument, NULL, 's' }, \"Provide fuzzing input on STDIN, instead of \" _HF_FILE_PLACEHOLDER },\n        { { \"mutations_per_run\", required_argument, NULL, 'r' }, \"Maximal number of mutations per one run (default: 6)\" },\n        { { \"logfile\", required_argument, NULL, 'l' }, \"Log file\" },\n        { { \"version\", no_argument, NULL, '!' }, \"Just how the version and exit\" },\n        { { \"verbose\", no_argument, NULL, 'v' }, \"Disable ANSI console; use simple log output\" },\n        { { \"verifier\", no_argument, NULL, 'V' }, \"Enable crashes verifier\" },\n        { { \"debug\", no_argument, NULL, 'd' }, \"Show debug messages (level >= 4)\" },\n        { { \"quiet\", no_argument, NULL, 'q' }, \"Show only warnings and more serious messages (level <= 1)\" },\n        { { \"extension\", required_argument, NULL, 'e' }, \"Input file extension (e.g. 'swf'), (default: 'fuzz')\" },\n        { { \"workspace\", required_argument, NULL, 'W' }, \"Workspace directory to save crashes & runtime files (default: '.')\" },\n        { { \"crashdir\", required_argument, NULL, 0x600 }, \"Directory where crashes are saved to (default: workspace directory)\" },\n        { { \"covdir_all\", required_argument, NULL, 'o' }, \"** DEPRECATED ** use --output\" },\n        { { \"covdir_new\", required_argument, NULL, 0x602 }, \"New coverage (beyond the dry-run fuzzing phase) is written to this separate directory\" },\n        { { \"dict\", required_argument, NULL, 'w' }, \"Dictionary file. Format:http://llvm.org/docs/LibFuzzer.html#dictionaries\" },\n        { { \"stackhash_bl\", required_argument, NULL, 'B' }, \"Stackhashes blocklist file (one entry per line)\" },\n        { { \"mutate_cmd\", required_argument, NULL, 'c' }, \"External command producing fuzz files (instead of internal mutators)\" },\n        { { \"pprocess_cmd\", required_argument, NULL, 0x111 }, \"External command postprocessing files produced by internal mutators\" },\n        { { \"ffmutate_cmd\", required_argument, NULL, 0x110 }, \"External command mutating files which have effective coverage feedback\" },\n        { { \"run_time\", required_argument, NULL, 0x109 }, \"Number of seconds this fuzzing session will last (default: 0 [no limit])\" },\n        { { \"exit_on_time\", required_argument, NULL, 0x10A }, \"Stop fuzzing session if no new coverage was found for this number of seconds (default: 0 [no limit])\" },\n        { { \"iterations\", required_argument, NULL, 'N' }, \"Number of fuzzing iterations (default: 0 [no limit])\" },\n        { { \"rlimit_as\", required_argument, NULL, 0x100 }, \"Per process RLIMIT_AS in MiB (default: 0 [default limit])\" },\n        { { \"rlimit_rss\", required_argument, NULL, 0x101 }, \"Per process RLIMIT_RSS in MiB (default: 0 [default limit]). It will also set *SAN's soft_rss_limit_mb\" },\n        { { \"rlimit_data\", required_argument, NULL, 0x102 }, \"Per process RLIMIT_DATA in MiB (default: 0 [default limit])\" },\n        { { \"rlimit_core\", required_argument, NULL, 0x103 }, \"Per process RLIMIT_CORE in MiB (default: 0 [no cores are produced])\" },\n        { { \"rlimit_stack\", required_argument, NULL, 0x104 }, \"Per process RLIMIT_STACK in MiB (default: 0 [default limit])\" },\n        { { \"report\", required_argument, NULL, 'R' }, \"Write report to this file (default: '<workdir>/\" _HF_REPORT_FILE \"')\" },\n        { { \"max_file_size\", required_argument, NULL, 'F' }, \"Maximal size of files processed by the fuzzer in bytes (default: 1048576 = 1MB)\" },\n        { { \"clear_env\", no_argument, NULL, 0x108 }, \"Clear all environment variables before executing the binary\" },\n        { { \"env\", required_argument, NULL, 'E' }, \"Pass this environment variable, can be used multiple times\" },\n        { { \"save_all\", no_argument, NULL, 'u' }, \"Save all test-cases (not only the unique ones) by appending the current time-stamp to the filenames\" },\n        { { \"save_smaller\", no_argument, NULL, 'U' }, \"Save smaller test-cases, renaming first filename with .orig suffix\" },\n        { { \"tmout_sigvtalrm\", no_argument, NULL, 'T' }, \"Treat time-outs as crashes - use SIGVTALRM to kill timeouting processes (default: use SIGKILL)\" },\n        { { \"sanitizers\", no_argument, NULL, 'S' }, \"** DEPRECATED ** Enable sanitizers settings (default: false)\" },\n        { { \"sanitizers_del_report\", required_argument, NULL, 0x10F }, \"Delete sanitizer report after use (default: false)\" },\n        { { \"monitor_sigabrt\", required_argument, NULL, 0x105 }, \"** DEPRECATED ** SIGABRT is always monitored\" },\n        { { \"no_fb_timeout\", required_argument, NULL, 0x106 }, \"Skip feedback if the process has timeouted (default: false)\" },\n        { { \"exit_upon_crash\", no_argument, NULL, 0x107 }, \"Exit upon seeing the first crash\" },\n        { { \"exit_code_upon_crash\", required_argument, NULL, 0x113 }, \"Exit code to use upon seeing the first crash\" },\n        { { \"socket_fuzzer\", no_argument, NULL, 0x10B }, \"Instrument external fuzzer via socket\" },\n        { { \"netdriver\", no_argument, NULL, 0x10C }, \"Use netdriver (libhfnetdriver/). In most cases it will be autodetected through a binary signature\" },\n        { { \"only_printable\", no_argument, NULL, 0x10D }, \"Only generate printable inputs\" },\n        { { \"export_feedback\", no_argument, NULL, 0x10E }, \"Export the coverage feedback structure as ./hfuzz-feedback\" },\n        { { \"const_feedback\", required_argument, NULL, 0x112 }, \"Use constant integer/string values from fuzzed programs to mangle input files via a dynamic dictionary (default: true)\" },\n        { { \"pin_thread_cpu\", required_argument, NULL, 0x114 }, \"Pin a single execution thread to this many consecutive CPUs (default: 0 = no CPU pinning)\" },\n        { { \"dynamic_input\", required_argument, NULL, 0x115 }, \"Path to a directory containing the dynamic file corpus\" },\n        { { \"statsfile\", required_argument, NULL, 0x116 }, \"Stats file\" },\n\n#if defined(_HF_ARCH_LINUX)\n        { { \"linux_symbols_bl\", required_argument, NULL, 0x504 }, \"Symbols blocklist filter file (one entry per line)\" },\n        { { \"linux_symbols_wl\", required_argument, NULL, 0x505 }, \"Symbols allowlist filter file (one entry per line)\" },\n        { { \"linux_symbols_al\", required_argument, NULL, 0x505 }, \"Symbols allowlist filter file (one entry per line)\" },\n        { { \"linux_addr_low_limit\", required_argument, NULL, 0x500 }, \"Address limit (from si.si_addr) below which crashes are not reported, (default: 0)\" },\n        { { \"linux_keep_aslr\", no_argument, NULL, 0x501 }, \"Don't disable ASLR randomization, might be useful with MSAN\" },\n        { { \"linux_perf_ignore_above\", required_argument, NULL, 0x503 }, \"Ignore perf events which report IPs above this address\" },\n        { { \"linux_perf_instr\", no_argument, NULL, 0x510 }, \"Use PERF_COUNT_HW_INSTRUCTIONS perf\" },\n        { { \"linux_perf_branch\", no_argument, NULL, 0x511 }, \"Use PERF_COUNT_HW_BRANCH_INSTRUCTIONS perf\" },\n        { { \"linux_perf_bts_edge\", no_argument, NULL, 0x513 }, \"Use Intel BTS to count unique edges\" },\n        { { \"linux_perf_ipt_block\", no_argument, NULL, 0x514 }, \"Use Intel Processor Trace to count unique blocks (requires libipt.so)\" },\n        { { \"linux_perf_kernel_only\", no_argument, NULL, 0x515 }, \"Gather kernel-only coverage with Intel PT and with Intel BTS\" },\n        { { \"linux_ns_net\", required_argument, NULL, 0x0530 }, \"Use Linux NET namespace isolation (yes/no/maybe [default:no])\" },\n        { { \"linux_ns_pid\", no_argument, NULL, 0x0531 }, \"Use Linux PID namespace isolation\" },\n        { { \"linux_ns_ipc\", no_argument, NULL, 0x0532 }, \"Use Linux IPC namespace isolation\" },\n#endif // defined(_HF_ARCH_LINUX)\n\n#if defined(_HF_ARCH_NETBSD)\n        { { \"netbsd_symbols_bl\", required_argument, NULL, 0x504 }, \"Symbols blocklist filter file (one entry per line)\" },\n        { { \"netbsd_symbols_wl\", required_argument, NULL, 0x505 }, \"Symbols allowlist filter file (one entry per line)\" },\n        { { \"netbsd_symbols_al\", required_argument, NULL, 0x505 }, \"Symbols allowlist filter file (one entry per line)\" },\n        { { \"netbsd_addr_low_limit\", required_argument, NULL, 0x500 }, \"Address limit (from si.si_addr) below which crashes are not reported, (default: 0)\" },\n#endif // defined(_HF_ARCH_NETBSD)\n#if defined(__FreeBSD__)\n        { { \"fbsd_keep_aslr\", no_argument, NULL, 0x501 }, \"Don't disable ASLR randomization, might be useful with MSAN\" },\n#endif\n        { { 0, 0, 0, 0 }, NULL },\n    };\n    // clang-format on\n\n    struct option opts[ARRAYSIZE(custom_opts)];\n    for (size_t i = 0; i < ARRAYSIZE(custom_opts); i++) {\n        opts[i] = custom_opts[i].opt;\n    }\n\n    enum llevel_t ll        = INFO;\n    const char*   logfile   = NULL;\n    int           opt_index = 0;\n    for (;;) {\n        int c = getopt_long(\n            argc, argv, \"-?!hQvVsuUPxf:i:o:dqe:W:r:c:F:t:R:n:N:l:p:g:E:w:B:zMTS\", opts, &opt_index);\n        if (c < 0) {\n            break;\n        }\n\n        switch (c) {\n        case '!':\n            LOG_HELP(PROG_NAME \" \" PROG_VERSION);\n            exit(0);\n        case 'h':\n            logRedirectLogFD(STDOUT_FILENO);\n            cmdlineUsage(argv[0], custom_opts);\n            break;\n        case '?':\n            cmdlineHelp(argv[0], custom_opts);\n            return false;\n        case 'i':\n        case 'f': /* Synonym for -i, stands for -f(iles) */\n            hfuzz->io.inputDir = optarg;\n            break;\n        case 'x':\n            hfuzz->feedback.dynFileMethod = _HF_DYNFILE_NONE;\n            break;\n        case 'Q':\n            hfuzz->exe.nullifyStdio = false;\n            break;\n        case 'v':\n            hfuzz->display.useScreen = false;\n            break;\n        case 'V':\n            hfuzz->cfg.useVerifier = true;\n            break;\n        case 's':\n            hfuzz->exe.fuzzStdin = true;\n            break;\n        case 'u':\n            hfuzz->io.saveUnique = false;\n            break;\n        case 'U':\n            hfuzz->io.saveSmaller = true;\n            break;\n        case 'l':\n            logfile = optarg;\n            break;\n        case 'd':\n            ll = DEBUG;\n            break;\n        case 'q':\n            ll = WARNING;\n            break;\n        case 'e':\n            hfuzz->io.fileExtn = optarg;\n            break;\n        case 'W':\n            snprintf(hfuzz->io.workDir, sizeof(hfuzz->io.workDir), \"%s\", optarg);\n            break;\n        case 0x600:\n            hfuzz->io.crashDir = optarg;\n            break;\n        case 'o':\n            hfuzz->io.outputDir = optarg;\n            break;\n        case 0x602:\n            hfuzz->io.covDirNew = optarg;\n            break;\n        case 'r':\n            hfuzz->mutate.mutationsPerRun = strtoul(optarg, NULL, 10);\n            break;\n        case 'c':\n            hfuzz->exe.externalCommand = optarg;\n            break;\n        case 'S':\n            hfuzz->sanitizer.enable = true;\n            break;\n        case 0x10F:\n            hfuzz->sanitizer.del_report = cmdlineParseTrueFalse(opts[opt_index].name, optarg);\n            break;\n        case 0x10B:\n            hfuzz->socketFuzzer.enabled = true;\n            hfuzz->timing.tmOut         = 0; /* Disable process timeout checks */\n            break;\n        case 0x10C:\n            hfuzz->exe.netDriver = true;\n            break;\n        case 0x10D:\n            hfuzz->cfg.only_printable = true;\n            break;\n        case 0x10E:\n            hfuzz->io.exportFeedback = true;\n            break;\n        case 0x112:\n            hfuzz->feedback.cmpFeedback = cmdlineParseTrueFalse(opts[opt_index].name, optarg);\n            break;\n        case 'z':\n            hfuzz->feedback.dynFileMethod |= _HF_DYNFILE_SOFT;\n            break;\n        case 'M':\n            hfuzz->cfg.minimize = true;\n            break;\n        case 'F':\n            hfuzz->io.maxFileSz = strtoul(optarg, NULL, 0);\n            break;\n        case 't':\n            hfuzz->timing.tmOut = atol(optarg);\n            break;\n        case 'R':\n            hfuzz->cfg.reportFile = optarg;\n            break;\n        case 'n':\n            if (optarg[0] == 'a') {\n                long ncpus                = sysconf(_SC_NPROCESSORS_ONLN);\n                hfuzz->threads.threadsMax = (ncpus < 1 ? 1 : ncpus);\n            } else {\n                if (!util_isANumber(optarg)) {\n                    LOG_E(\"'-n %s' is not a number\", optarg);\n                    return false;\n                }\n                hfuzz->threads.threadsMax = strtoul(optarg, NULL, 0);\n            }\n            break;\n        case 0x109: {\n            time_t p = atol(optarg);\n            if (p > 0) {\n                hfuzz->timing.runEndTime = time(NULL) + p;\n            }\n        } break;\n        case 0x10A:\n            hfuzz->timing.exitOnTime = atol(optarg);\n            break;\n        case 'N':\n            hfuzz->mutate.mutationsMax = atol(optarg);\n            break;\n        case 0x100:\n            hfuzz->exe.asLimit = strtoull(optarg, NULL, 0);\n            break;\n        case 0x101:\n            hfuzz->exe.rssLimit = strtoull(optarg, NULL, 0);\n            break;\n        case 0x102:\n            hfuzz->exe.dataLimit = strtoull(optarg, NULL, 0);\n            break;\n        case 0x103:\n            hfuzz->exe.coreLimit = strtoull(optarg, NULL, 0);\n            break;\n        case 0x104:\n            hfuzz->exe.stackLimit = strtoull(optarg, NULL, 0);\n            break;\n        case 0x111:\n            hfuzz->exe.postExternalCommand = optarg;\n            break;\n        case 0x110:\n            hfuzz->exe.feedbackMutateCommand = optarg;\n            break;\n        case 0x106:\n            hfuzz->feedback.skipFeedbackOnTimeout = true;\n            break;\n        case 0x107:\n            hfuzz->cfg.exitUponCrash = true;\n            break;\n        case 0x113:\n            hfuzz->cfg.exitCodeUponCrash = strtoul(optarg, NULL, 0);\n            break;\n        case 0x114:\n            hfuzz->threads.pinThreadToCPUs = strtoul(optarg, NULL, 0);\n            break;\n        case 0x108:\n            hfuzz->exe.clearEnv = true;\n            break;\n        case 'P':\n            hfuzz->exe.persistent = true;\n            break;\n        case 'T':\n            hfuzz->timing.tmoutVTALRM = true;\n            break;\n        case 'E':\n            if (!cmdlineAddEnv(hfuzz, optarg)) {\n                return false;\n            }\n            break;\n        case 'w':\n            hfuzz->mutate.dictionaryFile = optarg;\n            break;\n        case 'B':\n            hfuzz->feedback.blocklistFile = optarg;\n            break;\n#if defined(_HF_ARCH_LINUX)\n        case 0x500:\n            hfuzz->arch_linux.ignoreAddr = (void*)strtoul(optarg, NULL, 0);\n            break;\n        case 0x501:\n            hfuzz->arch_linux.disableRandomization = false;\n            break;\n        case 0x503:\n            hfuzz->arch_linux.dynamicCutOffAddr = strtoull(optarg, NULL, 0);\n            break;\n        case 0x504:\n            hfuzz->arch_linux.symsBlFile = optarg;\n            break;\n        case 0x505:\n            hfuzz->arch_linux.symsWlFile = optarg;\n            break;\n        case 0x510:\n            hfuzz->feedback.dynFileMethod |= _HF_DYNFILE_INSTR_COUNT;\n            break;\n        case 0x511:\n            hfuzz->feedback.dynFileMethod |= _HF_DYNFILE_BRANCH_COUNT;\n            break;\n        case 0x513:\n            hfuzz->feedback.dynFileMethod |= _HF_DYNFILE_BTS_EDGE;\n            break;\n        case 0x514:\n            hfuzz->feedback.dynFileMethod |= _HF_DYNFILE_IPT_BLOCK;\n            break;\n        case 0x515:\n            hfuzz->arch_linux.kernelOnly = true;\n            break;\n        case 0x530:\n            hfuzz->arch_linux.useNetNs = cmdlineParseTriState(opts[opt_index].name, optarg);\n            if (hfuzz->arch_linux.useNetNs == HF_YES) {\n                hfuzz->arch_linux.cloneFlags |= (CLONE_NEWUSER | CLONE_NEWNET);\n            }\n            break;\n        case 0x531:\n            hfuzz->arch_linux.cloneFlags |= (CLONE_NEWUSER | CLONE_NEWPID);\n            break;\n        case 0x532:\n            hfuzz->arch_linux.cloneFlags |= (CLONE_NEWUSER | CLONE_NEWIPC);\n            break;\n#endif /* defined(_HF_ARCH_LINUX) */\n#if defined(_HF_ARCH_NETBSD)\n        case 0x500:\n            hfuzz->arch_netbsd.ignoreAddr = (void*)strtoul(optarg, NULL, 0);\n            break;\n        case 0x504:\n            hfuzz->arch_netbsd.symsBlFile = optarg;\n            break;\n        case 0x505:\n            hfuzz->arch_netbsd.symsWlFile = optarg;\n            break;\n#endif /* defined(_HF_ARCH_NETBSD) */\n#if defined(__FreeBSD__)\n        case 0x501:\n            hfuzz->arch_linux.disableRandomization = false;\n            break;\n#endif\n        case 0x115:\n            hfuzz->io.dynamicInputDir = optarg;\n            break;\n        case 0x116:\n            hfuzz->io.statsFileName = optarg;\n            break;\n        default:\n            cmdlineHelp(argv[0], custom_opts);\n            return false;\n        }\n    }\n\n    logInitLogFile(logfile, -1, ll);\n\n    hfuzz->exe.argc    = argc - optind;\n    hfuzz->exe.cmdline = (const char* const*)&argv[optind];\n    if (hfuzz->exe.argc <= 0) {\n        LOG_E(\"No fuzz command provided\");\n        cmdlineHelp(argv[0], custom_opts);\n        return false;\n    }\n    if (!files_exists(hfuzz->exe.cmdline[0])) {\n        LOG_E(\"Your fuzzed binary '%s' doesn't seem to exist\", hfuzz->exe.cmdline[0]);\n        return false;\n    }\n    if (!cmdlineVerify(hfuzz)) {\n        return false;\n    }\n\n    display_createTargetStr(hfuzz);\n\n    return true;\n}\n"
        },
        {
          "name": "cmdline.h",
          "type": "blob",
          "size": 1.0380859375,
          "content": "/*\n *\n *   honggfuzz - cmdline parsing\n *   -----------------------------------------\n *\n *   Copyright 2015 Google Inc. All Rights Reserved.\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n *\n */\n\n#ifndef _HF_CMDLINE_H_\n#define _HF_CMDLINE_H_\n\n#include <stdbool.h>\n#include <sys/resource.h>\n\n#include \"honggfuzz.h\"\n\nrlim_t cmdlineParseRLimit(int res, const char* optarg, unsigned long mul);\n\nbool cmdlineAddEnv(honggfuzz_t* hfuzz, char* env);\n\nbool cmdlineParse(int argc, char* argv[], honggfuzz_t* hfuzz);\n\n#endif /* _HF_CMDLINE_H_ */\n"
        },
        {
          "name": "display.c",
          "type": "blob",
          "size": 16.1806640625,
          "content": "/*\n *\n * honggfuzz - display statistics\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include \"display.h\"\n\n#include <errno.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n#include <sys/resource.h>\n#include <sys/sysctl.h>\n#if defined(__OpenBSD__)\n#include <sys/sched.h>\n#endif\n#endif\n\n#if defined(__sun)\n#include <kstat.h>\n#endif\n\n#if defined(__APPLE__)\n#include <mach/mach.h>\n#include <mach/task_info.h>\n#endif\n\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n\n#define ESC_CLEAR_ALL           \"\\033[2J\"\n#define ESC_CLEAR_LINE          \"\\033[2K\"\n#define ESC_CLEAR_ABOVE         \"\\033[1J\"\n#define ESC_TERM_RESET          \"\\033c\"\n#define ESC_NAV(x, y)           \"\\033[\" #x \";\" #y \"H\"\n#define ESC_BOLD                \"\\033[1m\"\n#define ESC_RED                 \"\\033[31m\"\n#define ESC_RESET               \"\\033[0m\"\n#define ESC_SCROLL_REGION(x, y) \"\\033[\" #x \";\" #y \"r\"\n#define ESC_SCROLL_DISABLE      \"\\033[?7h\"\n#define ESC_SCROLL_RESET        \"\\033[r\"\n#define ESC_NAV_DOWN(x)         \"\\033[\" #x \"B\"\n#define ESC_NAV_HORIZ(x)        \"\\033[\" #x \"G\"\n#define ESC_RESET_SETTINGS      \"\\033[!p\"\n\nstatic char displayBuf[1024 * 1024];\nstatic void display_start(void) {\n    memset(displayBuf, '\\0', sizeof(displayBuf));\n}\n\nstatic void display_stop(void) {\n    TEMP_FAILURE_RETRY(write(logFd(), displayBuf, strlen(displayBuf)));\n}\n\n__attribute__((format(printf, 1, 2))) static void display_put(const char* fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    util_vssnprintf(displayBuf, sizeof(displayBuf), fmt, args);\n    va_end(args);\n}\n\nstatic void display_imm(const char* str) {\n    TEMP_FAILURE_RETRY(write(logFd(), str, strlen(str)));\n}\n\nstatic void display_printKMG(uint64_t val) {\n    if (val >= 1000000000000ULL) {\n        display_put(\" [%.02LfT]\", (long double)val / 1000000000.0L);\n    } else if (val >= 1000000000UL) {\n        display_put(\" [%.02LfG]\", (long double)val / 1000000000.0L);\n    } else if (val >= 1000000UL) {\n        display_put(\" [%.02LfM]\", (long double)val / 1000000.0L);\n    } else if (val >= 1000UL) {\n        display_put(\" [%.02Lfk]\", (long double)val / 1000.0L);\n    }\n}\n\nstatic unsigned getCpuUse(int numCpus) {\n    static uint64_t prevUserT   = 0UL;\n    static uint64_t prevNiceT   = 0UL;\n    static uint64_t prevSystemT = 0UL;\n    static uint64_t prevIdleT   = 0UL;\n    uint64_t        userT       = 0UL;\n    uint64_t        niceT       = 0UL;\n    uint64_t        systemT     = 0UL;\n    uint64_t        idleT       = 0UL;\n\n#if defined(__linux__) || defined(__CYGWIN__)\n    FILE* f = fopen(\"/proc/stat\", \"re\");\n    if (UNLIKELY(f == NULL)) {\n        return 0;\n    }\n    defer {\n        fclose(f);\n    };\n    if (fscanf(f, \"cpu  %\" PRIu64 \"%\" PRIu64 \"%\" PRIu64 \"%\" PRIu64, &userT, &niceT, &systemT,\n            &idleT) != 4) {\n        LOG_W(\"fscanf('/proc/stat') != 4\");\n        return 0;\n    }\n#elif defined(__FreeBSD__) || defined(__DragonFly__)\n    long   ticks      = (1000 / sysconf(_SC_CLK_TCK));\n    long   off        = 0;\n    size_t cpuDataLen = sizeof(long) * CPUSTATES * numCpus;\n    long*  cpuData    = malloc(cpuDataLen);\n    if (UNLIKELY(cpuData == NULL)) {\n        return 0;\n    }\n\n    if (sysctlbyname(\"kern.cp_times\", cpuData, &cpuDataLen, NULL, 0) != 0) {\n        LOG_W(\"sysctlbyname('kern.cp_times') != 0\");\n        free(cpuData);\n        return 0;\n    }\n\n    userT = niceT = systemT = idleT = 0;\n\n    for (int i = 0; i < numCpus; i++) {\n        userT += cpuData[CP_USER + off] * ticks;\n        niceT += cpuData[CP_NICE + off] * ticks;\n        systemT += cpuData[CP_SYS + off] * ticks;\n        idleT += cpuData[CP_IDLE + off] * ticks;\n        off += CPUSTATES;\n    }\n\n    free(cpuData);\n#elif defined(__NetBSD__)\n    long ticks = (1000 / sysconf(_SC_CLK_TCK));\n\n    userT = niceT = systemT = idleT = 0;\n\n    for (int i = 0; i < numCpus; i++) {\n        uint64_t cpuData[CPUSTATES];\n        size_t   cpuDataLen = sizeof(cpuData);\n        char     mib[24]    = {0};\n        snprintf(mib, sizeof(mib), \"kern.cp_time.%d\", i);\n        if (sysctlbyname(mib, &cpuData, &cpuDataLen, NULL, 0) != 0) {\n            LOG_W(\"sysctlbyname('kern.cp_time') != 0\");\n            return 0;\n        }\n        userT += cpuData[CP_USER] * ticks;\n        niceT += cpuData[CP_NICE] * ticks;\n        systemT += cpuData[CP_SYS] * ticks;\n        idleT += cpuData[CP_IDLE] * ticks;\n    }\n#elif defined(__OpenBSD__)\n    long ticks = (1000 / sysconf(_SC_CLK_TCK));\n\n    userT = niceT = systemT = idleT = 0;\n\n    for (int i = 0; i < numCpus; i++) {\n        uint64_t cpuData[CPUSTATES];\n        size_t   cpuDataLen = sizeof(cpuData);\n        int      mib[3]     = {CTL_KERN, KERN_CPTIME2, i};\n        if (sysctl(mib, 3, &cpuData, &cpuDataLen, NULL, 0) != 0) {\n            LOG_W(\"sysctl('KERN_CPTIME2') != 0\");\n            return 0;\n        }\n        userT += cpuData[CP_USER] * ticks;\n        niceT += cpuData[CP_NICE] * ticks;\n        systemT += cpuData[CP_SYS] * ticks;\n        idleT += cpuData[CP_IDLE] * ticks;\n    }\n#elif defined(__sun)\n    kstat_ctl_t* kctl = kstat_open();\n    for (int i = 0; i < numCpus; i++) {\n        kstat_named_t* data;\n        kstat_t*       cpu = kstat_lookup(kctl, \"cpu\", i, NULL);\n        if (!cpu) {\n            LOG_W(\"kstat_lookup('cpu_info') != 0\");\n            continue;\n        }\n        kstat_read(kctl, cpu, NULL);\n        data = kstat_data_lookup(cpu, \"cpu_ticks_user\");\n        userT += data->value.ui64;\n        data = kstat_data_lookup(cpu, \"cpu_ticks_kernel\");\n        systemT += data->value.ui64;\n        data = kstat_data_lookup(cpu, \"cpu_ticks_idle\");\n        idleT += data->value.ui64;\n    }\n\n    kstat_close(kctl);\n#else\n    host_cpu_load_info_data_t avg;\n    mach_msg_type_number_t    num = HOST_CPU_LOAD_INFO_COUNT;\n    userT = niceT = systemT = idleT = 0;\n\n    if (host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&avg, &num) ==\n        KERN_SUCCESS) {\n        userT   = avg.cpu_ticks[CPU_STATE_USER];\n        niceT   = avg.cpu_ticks[CPU_STATE_NICE];\n        systemT = avg.cpu_ticks[CPU_STATE_SYSTEM];\n        idleT   = avg.cpu_ticks[CPU_STATE_IDLE];\n    }\n\n#endif\n\n    uint64_t userCycles   = (userT - prevUserT);\n    uint64_t niceCycles   = (niceT - prevNiceT);\n    uint64_t systemCycles = (systemT - prevSystemT);\n    uint64_t idleCycles   = (idleT - prevIdleT);\n\n    prevUserT   = userT;\n    prevNiceT   = niceT;\n    prevSystemT = systemT;\n    prevIdleT   = idleT;\n\n    uint64_t allCycles = userCycles + niceCycles + systemCycles + idleCycles;\n    if (UNLIKELY(allCycles == 0)) {\n        return 0;\n    }\n\n    return ((userCycles + niceCycles + systemCycles) * numCpus * 100) / (allCycles);\n}\n\nstatic void getDuration(time_t elapsed_second, char* buf, size_t bufSz) {\n    if (elapsed_second < 0) {\n        snprintf(buf, bufSz, \"----\");\n        return;\n    }\n\n    unsigned int day, hour, min, second;\n    day            = elapsed_second / 24 / 3600;\n    elapsed_second = elapsed_second - day * 24 * 3600;\n    hour           = elapsed_second / 3600;\n    min            = (elapsed_second - 3600 * hour) / 60;\n    second         = elapsed_second - hour * 3600 - min * 60;\n    snprintf(buf, bufSz, \"%u days %02u hrs %02u mins %02u secs\", day, hour, min, second);\n}\n\nvoid display_createTargetStr(honggfuzz_t* hfuzz) {\n    if (!hfuzz->exe.cmdline[0]) {\n        LOG_W(\"Your fuzzed binary is not specified\");\n        snprintf(hfuzz->display.cmdline_txt, sizeof(hfuzz->display.cmdline_txt), \"[EMPTY]\");\n        return;\n    }\n\n    static char tmpstr[1024 * 128] = {0};\n    snprintf(tmpstr, sizeof(tmpstr), \"%s\", hfuzz->exe.cmdline[0]);\n    for (int i = 1; i < hfuzz->exe.argc; i++) {\n        util_ssnprintf(tmpstr, sizeof(tmpstr), \" %s\", hfuzz->exe.cmdline[i]);\n    }\n\n    size_t len = strlen(tmpstr);\n    if (len <= (sizeof(hfuzz->display.cmdline_txt) - 1)) {\n        snprintf(hfuzz->display.cmdline_txt, sizeof(hfuzz->display.cmdline_txt), \"%s\", tmpstr);\n        return;\n    }\n\n    snprintf(hfuzz->display.cmdline_txt, sizeof(hfuzz->display.cmdline_txt), \"%.32s.....%s\", tmpstr,\n        &tmpstr[len - 27]);\n}\n\nvoid display_display(honggfuzz_t* hfuzz) {\n    if (!logIsTTY()) {\n        return;\n    }\n\n    const time_t  curr_sec          = time(NULL);\n    const time_t  elapsed_sec       = curr_sec - hfuzz->timing.timeStart;\n    const int64_t curr_time_usecs   = util_timeNowUSecs();\n    const int64_t elapsed_usecs     = curr_time_usecs - hfuzz->display.lastDisplayUSecs;\n    hfuzz->display.lastDisplayUSecs = curr_time_usecs;\n\n    char lastCovStr[64];\n    getDuration(curr_sec - ATOMIC_GET(hfuzz->timing.lastCovUpdate), lastCovStr, sizeof(lastCovStr));\n    char timeStr[64];\n    if (ATOMIC_GET(hfuzz->timing.runEndTime)) {\n        getDuration(ATOMIC_GET(hfuzz->timing.runEndTime) - curr_sec, timeStr, sizeof(timeStr));\n    } else {\n        getDuration(elapsed_sec, timeStr, sizeof(timeStr));\n    }\n\n    size_t curr_exec_cnt = ATOMIC_GET(hfuzz->cnts.mutationsCnt);\n    /*\n     * We increase the mutation counter unconditionally in threads, but if it's\n     * above hfuzz->mutationsMax we don't really execute the fuzzing loop.\n     * Therefore at the end of fuzzing, the mutation counter might be higher\n     * than hfuzz->mutationsMax\n     */\n    if (hfuzz->mutate.mutationsMax > 0 && curr_exec_cnt > hfuzz->mutate.mutationsMax) {\n        curr_exec_cnt = hfuzz->mutate.mutationsMax;\n    }\n    int exeProgress = 0;\n    if (hfuzz->mutate.mutationsMax > 0) {\n        exeProgress = (curr_exec_cnt * 100) / hfuzz->mutate.mutationsMax;\n    }\n\n    static size_t prev_exec_cnt = 0UL;\n    size_t        exec_per_usecs =\n        elapsed_usecs ? ((curr_exec_cnt - prev_exec_cnt) * 1000000) / elapsed_usecs : 0;\n    prev_exec_cnt = curr_exec_cnt;\n\n    display_start();\n\n    display_put(ESC_NAV(13, 1) ESC_CLEAR_ABOVE ESC_NAV(1, 1));\n    display_put(\"------------------------[\" ESC_BOLD \"%31s \" ESC_RESET \"]----------------------\\n\",\n        timeStr);\n    display_put(\"  Iterations : \" ESC_BOLD \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET, curr_exec_cnt);\n    display_printKMG(curr_exec_cnt);\n    if (hfuzz->mutate.mutationsMax) {\n        display_put(\" (out of: \" ESC_BOLD \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET \" [%d%%])\",\n            hfuzz->mutate.mutationsMax, exeProgress);\n    }\n    switch (ATOMIC_GET(hfuzz->feedback.state)) {\n    case _HF_STATE_STATIC:\n        display_put(\"\\n        Mode : \" ESC_BOLD \"Static\" ESC_RESET \"\\n\");\n        break;\n    case _HF_STATE_DYNAMIC_DRY_RUN: {\n        if (ATOMIC_GET(hfuzz->cfg.switchingToFDM)) {\n            display_put(\"\\n  Mode [2/3] : \" ESC_BOLD\n                        \"Switching to the Feedback Driven Mode\" ESC_RESET \" [%zu/%zu]\\n\",\n                hfuzz->io.testedFileCnt, hfuzz->io.fileCnt);\n        } else {\n            display_put(\"\\n  Mode [1/3] : \" ESC_BOLD \"Feedback Driven Dry Run\" ESC_RESET\n                        \" [%zu/%zu]\\n\",\n                hfuzz->io.testedFileCnt, hfuzz->io.fileCnt);\n        }\n    } break;\n    case _HF_STATE_DYNAMIC_MAIN:\n        display_put(\"\\n  Mode [3/3] : \" ESC_BOLD \"Feedback Driven Mode\" ESC_RESET \"\\n\");\n        break;\n    case _HF_STATE_DYNAMIC_MINIMIZE:\n        display_put(\"\\n  Mode [3/3] : \" ESC_BOLD \"Corpus Minimization\" ESC_RESET \"\\n\");\n        break;\n    default:\n        display_put(\"\\n        Mode : \" ESC_BOLD \"Unknown\" ESC_RESET \"\\n\");\n        break;\n    }\n    display_put(\"      Target : \" ESC_BOLD \"%s\" ESC_RESET \"\\n\", hfuzz->display.cmdline_txt);\n\n    static long num_cpu = 0;\n    if (num_cpu == 0) {\n        num_cpu = sysconf(_SC_NPROCESSORS_ONLN);\n    }\n    if (num_cpu <= 0) {\n        num_cpu = 1;\n    }\n    unsigned cpuUse = getCpuUse(num_cpu);\n    display_put(\"     Threads : \" ESC_BOLD \"%zu\" ESC_RESET \", CPUs: \" ESC_BOLD \"%ld\" ESC_RESET\n                \", CPU%%: \" ESC_BOLD \"%u\" ESC_RESET \"%% [\" ESC_BOLD \"%lu\" ESC_RESET \"%%/CPU]\\n\",\n        hfuzz->threads.threadsMax, num_cpu, cpuUse, cpuUse / num_cpu);\n\n    size_t tot_exec_per_sec = elapsed_sec ? (curr_exec_cnt / elapsed_sec) : 0;\n    display_put(\"       Speed : \" ESC_BOLD \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET \"/sec [avg: \" ESC_BOLD\n                \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET \"]\\n\",\n        exec_per_usecs, tot_exec_per_sec);\n\n    uint64_t crashesCnt = ATOMIC_GET(hfuzz->cnts.crashesCnt);\n    /* colored the crash count as red when exist crash */\n    display_put(\"     Crashes : \" ESC_BOLD \"%s\"\n                \"%zu\" ESC_RESET \" [unique: %s\" ESC_BOLD \"%zu\" ESC_RESET \", blocklist: \" ESC_BOLD\n                \"%zu\" ESC_RESET \", verified: \" ESC_BOLD \"%zu\" ESC_RESET \"]\\n\",\n        crashesCnt > 0 ? ESC_RED : \"\", hfuzz->cnts.crashesCnt, crashesCnt > 0 ? ESC_RED : \"\",\n        ATOMIC_GET(hfuzz->cnts.uniqueCrashesCnt), ATOMIC_GET(hfuzz->cnts.blCrashesCnt),\n        ATOMIC_GET(hfuzz->cnts.verifiedCrashesCnt));\n    display_put(\"    Timeouts : \" ESC_BOLD \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET \" [%lu sec]\\n\",\n        ATOMIC_GET(hfuzz->cnts.timeoutedCnt), (unsigned long)hfuzz->timing.tmOut);\n    /* Feedback data sources. Common headers. */\n    display_put(\" Corpus Size : \" ESC_BOLD \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET \", max: \" ESC_BOLD\n                \"%\" _HF_NONMON_SEP \"zu\" ESC_RESET \" bytes, init: \" ESC_BOLD \"%\" _HF_NONMON_SEP\n                \"zu\" ESC_RESET \" files\\n\",\n        hfuzz->io.dynfileqCnt, hfuzz->mutate.maxInputSz, ATOMIC_GET(hfuzz->io.fileCnt));\n    display_put(\"  Cov Update : \" ESC_BOLD \"%s\" ESC_RESET \" ago\\n\" ESC_RESET, lastCovStr);\n    display_put(\"    Coverage :\");\n\n    /* HW perf specific counters */\n    if (hfuzz->feedback.dynFileMethod == 0) {\n        display_put(\" [none]\");\n    }\n    if (hfuzz->feedback.dynFileMethod & _HF_DYNFILE_INSTR_COUNT) {\n        display_put(\" hwi: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET,\n            ATOMIC_GET(hfuzz->feedback.hwCnts.cpuInstrCnt));\n    }\n    if (hfuzz->feedback.dynFileMethod & _HF_DYNFILE_BRANCH_COUNT) {\n        display_put(\" hwb: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET,\n            ATOMIC_GET(hfuzz->feedback.hwCnts.cpuBranchCnt));\n    }\n    if (hfuzz->feedback.dynFileMethod & _HF_DYNFILE_BTS_EDGE) {\n        display_put(\" bts: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET,\n            ATOMIC_GET(hfuzz->feedback.hwCnts.bbCnt));\n    }\n    if (hfuzz->feedback.dynFileMethod & _HF_DYNFILE_IPT_BLOCK) {\n        display_put(\" ipt: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET,\n            ATOMIC_GET(hfuzz->feedback.hwCnts.bbCnt));\n    }\n    if (hfuzz->feedback.dynFileMethod & _HF_DYNFILE_SOFT) {\n        uint64_t softCntPc   = ATOMIC_GET(hfuzz->feedback.hwCnts.softCntPc);\n        uint64_t softCntEdge = ATOMIC_GET(hfuzz->feedback.hwCnts.softCntEdge);\n        uint64_t softCntCmp  = ATOMIC_GET(hfuzz->feedback.hwCnts.softCntCmp);\n        uint64_t guardNb     = ATOMIC_GET(hfuzz->feedback.covFeedbackMap->guardNb);\n        display_put(\" edge: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET \"/\"\n                    \"%\" _HF_NONMON_SEP PRIu64 \" [%\" PRId64 \"%%]\",\n            softCntEdge, guardNb, guardNb ? ((softCntEdge * 100) / guardNb) : 0);\n        display_put(\" pc: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET, softCntPc);\n        display_put(\" cmp: \" ESC_BOLD \"%\" _HF_NONMON_SEP PRIu64 ESC_RESET, softCntCmp);\n    }\n\n    display_put(\"\\n---------------------------------- [ \" ESC_BOLD \"LOGS\" ESC_RESET\n                \" ] ------------------/ \" ESC_BOLD \"%s %s \" ESC_RESET \"/-\",\n        PROG_NAME, PROG_VERSION);\n    display_put(ESC_SCROLL_REGION(13, ) ESC_NAV_HORIZ(1) ESC_NAV_DOWN(500));\n\n    MX_SCOPED_LOCK(logMutexGet());\n    display_stop();\n}\n\nstatic void display_fini(void) {\n    display_imm(ESC_SCROLL_RESET ESC_NAV_DOWN(500));\n}\n\nvoid display_clear(void) {\n    display_imm(ESC_CLEAR_ALL);\n    display_imm(ESC_NAV_DOWN(500));\n}\n\nvoid display_init(void) {\n    atexit(display_fini);\n    display_clear();\n}\n"
        },
        {
          "name": "display.h",
          "type": "blob",
          "size": 0.9853515625,
          "content": "/*\n *\n * honggfuzz - display statistics\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_DISPLAY_H_\n#define _HF_DISPLAY_H_\n\n#include \"honggfuzz.h\"\n\nextern void display_display(honggfuzz_t* hfuzz);\nextern void display_init(void);\nextern void display_clear(void);\nextern void display_createTargetStr(honggfuzz_t* hfuzz);\n\n#endif\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz.c",
          "type": "blob",
          "size": 22.400390625,
          "content": "/*\n *\n * honggfuzz - fuzzing routines\n * -----------------------------------------\n *\n * Authors: Robert Swiecki <swiecki@google.com>\n *          Felix Gröbert <groebert@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include \"fuzz.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"arch.h\"\n#include \"honggfuzz.h\"\n#include \"input.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/files.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n#include \"report.h\"\n#include \"sanitizers.h\"\n#include \"socketfuzzer.h\"\n#include \"subproc.h\"\n\nstatic time_t termTimeStamp = 0;\n\nbool fuzz_isTerminating(void) {\n    if (ATOMIC_GET(termTimeStamp) != 0) {\n        return true;\n    }\n    return false;\n}\n\nvoid fuzz_setTerminating(void) {\n    if (ATOMIC_GET(termTimeStamp) != 0) {\n        return;\n    }\n    ATOMIC_SET(termTimeStamp, time(NULL));\n}\n\nbool fuzz_shouldTerminate() {\n    if (ATOMIC_GET(termTimeStamp) == 0) {\n        return false;\n    }\n    if ((time(NULL) - ATOMIC_GET(termTimeStamp)) > 5) {\n        return true;\n    }\n    return false;\n}\n\nfuzzState_t fuzz_getState(honggfuzz_t* hfuzz) {\n    return ATOMIC_GET(hfuzz->feedback.state);\n}\n\nstatic void fuzz_setDynamicMainState(run_t* run) {\n    /* All threads need to indicate willingness to switch to the DYNAMIC_MAIN state. Count them! */\n    static uint32_t cnt = 0;\n    ATOMIC_PRE_INC(cnt);\n\n    MX_SCOPED_LOCK(&run->global->mutex.state);\n\n    if (fuzz_getState(run->global) != _HF_STATE_DYNAMIC_DRY_RUN) {\n        /* Already switched out of the Dry Run */\n        return;\n    }\n\n    LOG_I(\"Entering phase 2/3: Switching to the Feedback Driven Mode\");\n    ATOMIC_SET(run->global->cfg.switchingToFDM, true);\n\n    for (;;) {\n        /* Check if all threads have already reported in for changing state */\n        if (ATOMIC_GET(cnt) == run->global->threads.threadsMax) {\n            break;\n        }\n        if (fuzz_isTerminating()) {\n            return;\n        }\n        util_sleepForMSec(10); /* Check every 10ms */\n    }\n\n    ATOMIC_SET(run->global->cfg.switchingToFDM, false);\n\n    if (run->global->cfg.minimize) {\n        LOG_I(\"Entering phase 3/3: Corpus Minimization\");\n        ATOMIC_SET(run->global->feedback.state, _HF_STATE_DYNAMIC_MINIMIZE);\n        return;\n    }\n\n    /*\n     * If the initial fuzzing yielded no useful coverage, just add a single empty file to the\n     * dynamic corpus, so the dynamic phase doesn't fail because of lack of useful inputs\n     */\n    if (run->global->io.dynfileqCnt == 0) {\n        dynfile_t dynfile = {\n            .size          = 0,\n            .cov           = {},\n            .idx           = 0,\n            .fd            = -1,\n            .timeExecUSecs = 1,\n            .path          = \"[DYNAMIC-0-SIZE]\",\n            .timedout      = false,\n            .data          = (uint8_t*)\"\",\n        };\n        dynfile_t* tmp_dynfile = run->dynfile;\n        run->dynfile           = &dynfile;\n        input_addDynamicInput(run);\n        run->dynfile = tmp_dynfile;\n    }\n    snprintf(run->dynfile->path, sizeof(run->dynfile->path), \"[DYNAMIC]\");\n\n    if (run->global->io.maxFileSz == 0 && run->global->mutate.maxInputSz > _HF_INPUT_DEFAULT_SIZE) {\n        size_t newsz = (run->global->io.dynfileqMaxSz >= _HF_INPUT_DEFAULT_SIZE)\n                           ? run->global->io.dynfileqMaxSz\n                           : _HF_INPUT_DEFAULT_SIZE;\n        newsz        = (newsz + newsz / 4); /* Add 25% overhead for growth */\n        if (newsz > run->global->mutate.maxInputSz) {\n            newsz = run->global->mutate.maxInputSz;\n        }\n        LOG_I(\"Setting maximum input size to %zu bytes (previously %zu bytes)\", newsz,\n            run->global->mutate.maxInputSz);\n        run->global->mutate.maxInputSz = newsz;\n    }\n\n    LOG_I(\"Entering phase 3/3: Dynamic Main (Feedback Driven Mode)\");\n    ATOMIC_SET(run->global->feedback.state, _HF_STATE_DYNAMIC_MAIN);\n}\n\nstatic void fuzz_minimizeRemoveFiles(run_t* run) {\n    if (run->global->io.outputDir) {\n        LOG_I(\"Minimized files were copied to '%s'\", run->global->io.outputDir);\n        return;\n    }\n    if (!input_getDirStatsAndRewind(run->global)) {\n        return;\n    }\n    for (;;) {\n        char   fname[PATH_MAX];\n        size_t len;\n        if (!input_getNext(run, fname, &len, /* rewind= */ false)) {\n            break;\n        }\n        if (!input_inDynamicCorpus(run, fname, len)) {\n            if (input_removeStaticFile(run->global->io.inputDir, fname)) {\n                LOG_I(\"Removed unnecessary '%s'\", fname);\n            }\n        }\n    }\n    LOG_I(\"Corpus minimization done\");\n}\n\nstatic void fuzz_perfFeedback(run_t* run) {\n    if (run->global->feedback.skipFeedbackOnTimeout && run->tmOutSignaled) {\n        return;\n    }\n    if (run->global->feedback.dynFileMethod == _HF_DYNFILE_NONE) {\n        return;\n    }\n\n    MX_SCOPED_LOCK(&run->global->mutex.feedback);\n    defer {\n        wmb();\n    };\n\n    uint64_t softNewPC   = 0;\n    uint64_t softCurPC   = 0;\n    uint64_t softNewEdge = 0;\n    uint64_t softCurEdge = 0;\n    uint64_t softNewCmp  = 0;\n    uint64_t softCurCmp  = 0;\n\n    if (run->global->feedback.dynFileMethod & _HF_DYNFILE_SOFT) {\n        softNewPC = ATOMIC_GET(run->global->feedback.covFeedbackMap->pidNewPC[run->fuzzNo]);\n        ATOMIC_CLEAR(run->global->feedback.covFeedbackMap->pidNewPC[run->fuzzNo]);\n        softCurPC = ATOMIC_GET(run->global->feedback.covFeedbackMap->pidTotalPC[run->fuzzNo]);\n        ATOMIC_CLEAR(run->global->feedback.covFeedbackMap->pidTotalPC[run->fuzzNo]);\n\n        softNewEdge = ATOMIC_GET(run->global->feedback.covFeedbackMap->pidNewEdge[run->fuzzNo]);\n        ATOMIC_CLEAR(run->global->feedback.covFeedbackMap->pidNewEdge[run->fuzzNo]);\n        softCurEdge = ATOMIC_GET(run->global->feedback.covFeedbackMap->pidTotalEdge[run->fuzzNo]);\n        ATOMIC_CLEAR(run->global->feedback.covFeedbackMap->pidTotalEdge[run->fuzzNo]);\n\n        softNewCmp = ATOMIC_GET(run->global->feedback.covFeedbackMap->pidNewCmp[run->fuzzNo]);\n        ATOMIC_CLEAR(run->global->feedback.covFeedbackMap->pidNewCmp[run->fuzzNo]);\n        softCurCmp = ATOMIC_GET(run->global->feedback.covFeedbackMap->pidTotalCmp[run->fuzzNo]);\n        ATOMIC_CLEAR(run->global->feedback.covFeedbackMap->pidTotalCmp[run->fuzzNo]);\n    }\n\n    rmb();\n\n    int64_t diff0 = (int64_t)run->global->feedback.hwCnts.cpuInstrCnt - run->hwCnts.cpuInstrCnt;\n    int64_t diff1 = (int64_t)run->global->feedback.hwCnts.cpuBranchCnt - run->hwCnts.cpuBranchCnt;\n\n    /* Any increase in coverage (edge, pc, cmp, hw) counters forces adding input to the corpus */\n    if (run->hwCnts.newBBCnt > 0 || softNewPC > 0 || softNewEdge > 0 || softNewCmp > 0 ||\n        diff0 < 0 || diff1 < 0) {\n        if (diff0 < 0) {\n            run->global->feedback.hwCnts.cpuInstrCnt = run->hwCnts.cpuInstrCnt;\n        }\n        if (diff1 < 0) {\n            run->global->feedback.hwCnts.cpuBranchCnt = run->hwCnts.cpuBranchCnt;\n        }\n        run->global->feedback.hwCnts.bbCnt += run->hwCnts.newBBCnt;\n        run->global->feedback.hwCnts.softCntPc += softNewPC;\n        run->global->feedback.hwCnts.softCntEdge += softNewEdge;\n        run->global->feedback.hwCnts.softCntCmp += softNewCmp;\n\n        LOG_I(\"Sz:%zu Tm:%\" _HF_NONMON_SEP PRIu64 \"us (i/b/h/e/p/c) New:%\" PRIu64 \"/%\" PRIu64\n              \"/%\" PRIu64 \"/%\" PRIu64 \"/%\" PRIu64 \"/%\" PRIu64 \", Cur:%\" PRIu64 \"/%\" PRIu64\n              \"/%\" PRIu64 \"/%\" PRIu64 \"/%\" PRIu64 \"/%\" PRIu64,\n            run->dynfile->size, util_timeNowUSecs() - run->timeStartedUSecs,\n            run->hwCnts.cpuInstrCnt, run->hwCnts.cpuBranchCnt, run->hwCnts.newBBCnt, softNewEdge,\n            softNewPC, softNewCmp, run->hwCnts.cpuInstrCnt, run->hwCnts.cpuBranchCnt,\n            run->global->feedback.hwCnts.bbCnt, run->global->feedback.hwCnts.softCntEdge,\n            run->global->feedback.hwCnts.softCntPc, run->global->feedback.hwCnts.softCntCmp);\n\n        if (run->global->io.statsFileName) {\n            const time_t curr_sec      = time(NULL);\n            const time_t elapsed_sec   = curr_sec - run->global->timing.timeStart;\n            size_t       curr_exec_cnt = ATOMIC_GET(run->global->cnts.mutationsCnt);\n            /*\n             * We increase the mutation counter unconditionally in threads, but if it's\n             * above hfuzz->mutationsMax we don't really execute the fuzzing loop.\n             * Therefore at the end of fuzzing, the mutation counter might be higher\n             * than hfuzz->mutationsMax\n             */\n            if (run->global->mutate.mutationsMax > 0 &&\n                curr_exec_cnt > run->global->mutate.mutationsMax) {\n                curr_exec_cnt = run->global->mutate.mutationsMax;\n            }\n            size_t tot_exec_per_sec = elapsed_sec ? (curr_exec_cnt / elapsed_sec) : 0;\n\n            dprintf(run->global->io.statsFileFd,\n                \"%lu, %lu, %lu, %lu, \"\n                \"%\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                curr_sec,                                 /* unix_time */\n                run->global->timing.lastCovUpdate,        /* last_cov_update */\n                curr_exec_cnt,                            /* total_exec */\n                tot_exec_per_sec,                         /* exec_per_sec */\n                run->global->cnts.crashesCnt,             /* crashes */\n                run->global->cnts.uniqueCrashesCnt,       /* unique_crashes */\n                run->global->cnts.timeoutedCnt,           /* hangs */\n                run->global->feedback.hwCnts.softCntEdge, /* edge_cov */\n                run->global->feedback.hwCnts.softCntPc    /* block_cov */\n            );\n        }\n\n        /* Update per-input coverage metrics */\n        run->dynfile->cov[0] = softCurEdge + softCurPC + run->hwCnts.bbCnt;\n        run->dynfile->cov[1] = softCurCmp;\n        run->dynfile->cov[2] = run->hwCnts.cpuInstrCnt + run->hwCnts.cpuBranchCnt;\n        run->dynfile->cov[3] = run->dynfile->size ? (64 - util_Log2(run->dynfile->size)) : 64;\n        input_addDynamicInput(run);\n\n        if (run->global->socketFuzzer.enabled) {\n            LOG_D(\"SocketFuzzer: fuzz: new BB (perf)\");\n            fuzz_notifySocketFuzzerNewCov(run->global);\n        }\n    }\n}\n\n/* Return value indicates whether report file should be updated with the current verified crash */\nstatic bool fuzz_runVerifier(run_t* run) {\n    if (!run->crashFileName[0] || !run->backtrace) {\n        return false;\n    }\n\n    uint64_t backtrace = run->backtrace;\n\n    char origCrashPath[PATH_MAX];\n    snprintf(origCrashPath, sizeof(origCrashPath), \"%s\", run->crashFileName);\n    /* Workspace is inherited, just append a extra suffix */\n    char verFile[PATH_MAX];\n    snprintf(verFile, sizeof(verFile), \"%s.verified\", origCrashPath);\n\n    if (files_exists(verFile)) {\n        LOG_D(\"Crash file to verify '%s' is already verified as '%s'\", origCrashPath, verFile);\n        return false;\n    }\n\n    for (int i = 0; i < _HF_VERIFIER_ITER; i++) {\n        LOG_I(\"Launching verifier for HASH: %\" PRIx64 \" (iteration: %d out of %d)\", run->backtrace,\n            i + 1, _HF_VERIFIER_ITER);\n        run->timeStartedUSecs = util_timeNowUSecs();\n        run->backtrace        = 0;\n        run->access           = 0;\n        run->exception        = 0;\n        run->mainWorker       = false;\n\n        if (!subproc_Run(run)) {\n            LOG_F(\"subproc_Run()\");\n        }\n\n        /* If stack hash doesn't match skip name tag and exit */\n        if (run->backtrace != backtrace) {\n            LOG_E(\"Verifier stack mismatch: (original) %\" PRIx64 \" != (new) %\" PRIx64, backtrace,\n                run->backtrace);\n            run->backtrace = backtrace;\n            return true;\n        }\n\n        LOG_I(\"Verifier for HASH: %\" PRIx64 \" (iteration: %d, left: %d). MATCH!\", run->backtrace,\n            i + 1, _HF_VERIFIER_ITER - i - 1);\n    }\n\n    /* Copy file with new suffix & remove original copy */\n    int fd = TEMP_FAILURE_RETRY(open(verFile, O_CREAT | O_EXCL | O_WRONLY, 0600));\n    if (fd == -1 && errno == EEXIST) {\n        LOG_I(\"It seems that '%s' already exists, skipping\", verFile);\n        return false;\n    }\n    if (fd == -1) {\n        PLOG_E(\"Couldn't create '%s'\", verFile);\n        return true;\n    }\n    defer {\n        close(fd);\n    };\n    if (!files_writeToFd(fd, run->dynfile->data, run->dynfile->size)) {\n        LOG_E(\"Couldn't save verified file as '%s'\", verFile);\n        unlink(verFile);\n        return true;\n    }\n\n    LOG_I(\"Verified crash for HASH: %\" PRIx64 \" and saved it as '%s'\", backtrace, verFile);\n    ATOMIC_PRE_INC(run->global->cnts.verifiedCrashesCnt);\n\n    return true;\n}\n\nstatic bool fuzz_fetchInput(run_t* run) {\n    {\n        fuzzState_t st = fuzz_getState(run->global);\n        if (st == _HF_STATE_DYNAMIC_DRY_RUN) {\n            run->mutationsPerRun = 0U;\n            if (input_prepareStaticFile(run, /* rewind= */ false, /* mangle= */ false)) {\n                return true;\n            }\n            fuzz_setDynamicMainState(run);\n            run->mutationsPerRun = run->global->mutate.mutationsPerRun;\n        }\n    }\n\n    if (fuzz_getState(run->global) == _HF_STATE_DYNAMIC_MINIMIZE) {\n        fuzz_minimizeRemoveFiles(run);\n        return false;\n    }\n\n    if (fuzz_getState(run->global) == _HF_STATE_DYNAMIC_MAIN) {\n        if (run->global->exe.externalCommand) {\n            if (!input_prepareExternalFile(run)) {\n                LOG_E(\"input_prepareExternalFile() failed\");\n                return false;\n            }\n        } else if (run->global->exe.feedbackMutateCommand) {\n            if (!input_prepareDynamicInput(run, false)) {\n                LOG_E(\"input_prepareDynamicInput(() failed\");\n                return false;\n            }\n        } else if (!input_prepareDynamicInput(run, true)) {\n            LOG_E(\"input_prepareDynamicInput() failed\");\n            return false;\n        }\n    }\n\n    if (fuzz_getState(run->global) == _HF_STATE_STATIC) {\n        if (run->global->exe.externalCommand) {\n            if (!input_prepareExternalFile(run)) {\n                LOG_E(\"input_prepareExternalFile() failed\");\n                return false;\n            }\n        } else if (run->global->exe.feedbackMutateCommand) {\n            if (!input_prepareStaticFile(run, /* rewind= */ true, /* mangle= */ false)) {\n                LOG_E(\"input_prepareStaticFile() failed\");\n                return false;\n            }\n        } else if (!input_prepareStaticFile(run, /* rewind= */ true, /* mangle= */ true)) {\n            LOG_E(\"input_prepareStaticFile() failed\");\n            return false;\n        }\n    }\n\n    if (run->global->exe.postExternalCommand &&\n        !input_postProcessFile(run, run->global->exe.postExternalCommand)) {\n        LOG_E(\"input_postProcessFile('%s') failed\", run->global->exe.postExternalCommand);\n        return false;\n    }\n\n    if (run->global->exe.feedbackMutateCommand &&\n        !input_postProcessFile(run, run->global->exe.feedbackMutateCommand)) {\n        LOG_E(\"input_postProcessFile('%s') failed\", run->global->exe.feedbackMutateCommand);\n        return false;\n    }\n\n    return true;\n}\n\nstatic void fuzz_fuzzLoop(run_t* run) {\n    run->timeStartedUSecs = util_timeNowUSecs();\n    run->crashFileName[0] = '\\0';\n    run->pc               = 0;\n    run->backtrace        = 0;\n    run->access           = 0;\n    run->exception        = 0;\n    run->report[0]        = '\\0';\n    run->mainWorker       = true;\n    run->mutationsPerRun  = run->global->mutate.mutationsPerRun;\n    run->tmOutSignaled    = false;\n\n    run->hwCnts.cpuInstrCnt  = 0;\n    run->hwCnts.cpuBranchCnt = 0;\n    run->hwCnts.bbCnt        = 0;\n    run->hwCnts.newBBCnt     = 0;\n\n    if (!fuzz_fetchInput(run)) {\n        if (run->global->cfg.minimize && fuzz_getState(run->global) == _HF_STATE_DYNAMIC_MINIMIZE) {\n            fuzz_setTerminating();\n            return;\n        }\n        LOG_F(\"Cound't prepare input for fuzzing\");\n    }\n    if (!subproc_Run(run)) {\n        LOG_F(\"Couldn't run fuzzed command\");\n    }\n\n    if (run->global->feedback.dynFileMethod != _HF_DYNFILE_NONE) {\n        fuzz_perfFeedback(run);\n    }\n    if (run->global->cfg.useVerifier && !fuzz_runVerifier(run)) {\n        return;\n    }\n    report_saveReport(run);\n}\n\nstatic void fuzz_fuzzLoopSocket(run_t* run) {\n    run->timeStartedUSecs = util_timeNowUSecs();\n    run->crashFileName[0] = '\\0';\n    run->pc               = 0;\n    run->backtrace        = 0;\n    run->access           = 0;\n    run->exception        = 0;\n    run->report[0]        = '\\0';\n    run->mainWorker       = true;\n    run->mutationsPerRun  = run->global->mutate.mutationsPerRun;\n    run->tmOutSignaled    = false;\n\n    run->hwCnts.cpuInstrCnt  = 0;\n    run->hwCnts.cpuBranchCnt = 0;\n    run->hwCnts.bbCnt        = 0;\n    run->hwCnts.newBBCnt     = 0;\n\n    LOG_I(\"------------------------------------------------------\");\n\n    /* First iteration: Start target\n       Other iterations: re-start target, if necessary\n       subproc_Run() will decide by itself if a restart is necessary, via\n       subproc_New()\n    */\n    LOG_D(\"------[ 1: subproc_run\");\n    if (!subproc_Run(run)) {\n        LOG_W(\"Couldn't run server\");\n    }\n\n    /* Tell the external fuzzer to send data to target\n       The fuzzer will notify us when finished; block until then.\n    */\n    LOG_D(\"------[ 2: fetch input\");\n    if (!fuzz_waitForExternalInput(run)) {\n        /* Fuzzer could not connect to target, and told us to\n           restart it. Do it on the next iteration.\n           or: it crashed by fuzzing. Restart it too.\n           */\n        LOG_D(\"------[ 2.1: Target down, will restart it\");\n        run->pid = 0;    // make subproc_Run() restart it on next iteration\n        return;\n    }\n\n    LOG_D(\"------[ 3: feedback\");\n    if (run->global->feedback.dynFileMethod != _HF_DYNFILE_NONE) {\n        fuzz_perfFeedback(run);\n    }\n    if (run->global->cfg.useVerifier && !fuzz_runVerifier(run)) {\n        return;\n    }\n\n    report_saveReport(run);\n}\n\nstatic void* fuzz_threadNew(void* arg) {\n    honggfuzz_t* hfuzz  = (honggfuzz_t*)arg;\n    unsigned int fuzzNo = ATOMIC_POST_INC(hfuzz->threads.threadsActiveCnt);\n    LOG_I(\"Launched new fuzzing thread, no. #%u\", fuzzNo);\n\n    if (!util_PinThreadToCPUs(fuzzNo, hfuzz->threads.pinThreadToCPUs)) {\n        PLOG_W(\"Pinning thread #%u to %\" PRIu32 \" CPUs failed\", fuzzNo,\n            hfuzz->threads.pinThreadToCPUs);\n    }\n\n    run_t run = {\n        .global         = hfuzz,\n        .pid            = 0,\n        .dynfile        = (dynfile_t*)util_Calloc(sizeof(dynfile_t) + hfuzz->io.maxFileSz),\n        .fuzzNo         = fuzzNo,\n        .persistentSock = -1,\n        .tmOutSignaled  = false,\n    };\n    defer {\n        free(run.dynfile);\n    };\n\n    /* Do not try to handle input files with socketfuzzer */\n    char mapname[32];\n    snprintf(mapname, sizeof(mapname), \"hf-%u-input\", fuzzNo);\n    if (!hfuzz->socketFuzzer.enabled) {\n        if (!(run.dynfile->data = files_mapSharedMem(hfuzz->mutate.maxInputSz, &(run.dynfile->fd),\n                  mapname, /* nocore= */ true, /* exportmap= */ false))) {\n            LOG_F(\"Couldn't create an input file of size: %zu, name:'%s'\", hfuzz->mutate.maxInputSz,\n                mapname);\n        }\n    }\n    defer {\n        if (run.dynfile->fd != -1) {\n            close(run.dynfile->fd);\n        }\n    };\n\n    snprintf(mapname, sizeof(mapname), \"hf-%u-perthreadmap\", fuzzNo);\n    if ((run.perThreadCovFeedbackFd = files_createSharedMem(sizeof(feedback_t), mapname,\n             /* exportmap= */ run.global->io.exportFeedback)) == -1) {\n        LOG_F(\"files_createSharedMem(name='%s', sz=%zu, dir='%s') failed\", mapname,\n            sizeof(feedback_t), run.global->io.workDir);\n    }\n    defer {\n        if (run.perThreadCovFeedbackFd != -1) {\n            close(run.perThreadCovFeedbackFd);\n        }\n    };\n\n    if (!arch_archThreadInit(&run)) {\n        LOG_F(\"Could not initialize the thread\");\n    }\n\n    for (;;) {\n        /* Check if dry run mode with verifier enabled */\n        if (run.global->mutate.mutationsPerRun == 0U && run.global->cfg.useVerifier &&\n            !hfuzz->socketFuzzer.enabled) {\n            if (ATOMIC_POST_INC(run.global->cnts.mutationsCnt) >= run.global->io.fileCnt) {\n                break;\n            }\n        }\n        /* Check for max iterations limit if set */\n        else if ((ATOMIC_POST_INC(run.global->cnts.mutationsCnt) >=\n                     run.global->mutate.mutationsMax) &&\n                 run.global->mutate.mutationsMax) {\n            break;\n        }\n\n        if (hfuzz->socketFuzzer.enabled) {\n            fuzz_fuzzLoopSocket(&run);\n        } else {\n            fuzz_fuzzLoop(&run);\n        }\n\n        if (fuzz_isTerminating()) {\n            break;\n        }\n\n        if (run.global->cfg.exitUponCrash && ATOMIC_GET(run.global->cnts.crashesCnt) > 0) {\n            LOG_I(\"Seen a crash. Terminating all fuzzing threads\");\n            fuzz_setTerminating();\n            break;\n        }\n    }\n\n    arch_reapKill();\n\n    if (run.pid) {\n        kill(run.pid, SIGKILL);\n    }\n\n    size_t j = ATOMIC_PRE_INC(run.global->threads.threadsFinished);\n    LOG_I(\"Terminating thread no. #%\" PRId32 \", left: %zu\", fuzzNo, hfuzz->threads.threadsMax - j);\n    return NULL;\n}\n\nvoid fuzz_threadsStart(honggfuzz_t* hfuzz) {\n    if (!arch_archInit(hfuzz)) {\n        LOG_F(\"Couldn't prepare arch for fuzzing\");\n    }\n    if (!sanitizers_Init(hfuzz)) {\n        LOG_F(\"Couldn't prepare sanitizer options\");\n    }\n\n    if (hfuzz->socketFuzzer.enabled) {\n        /* Don't do dry run with socketFuzzer */\n        LOG_I(\"Entering phase - Feedback Driven Mode (SocketFuzzer)\");\n        hfuzz->feedback.state = _HF_STATE_DYNAMIC_MAIN;\n    } else if (hfuzz->feedback.dynFileMethod != _HF_DYNFILE_NONE) {\n        LOG_I(\"Entering phase 1/3: Dry Run\");\n        hfuzz->feedback.state = _HF_STATE_DYNAMIC_DRY_RUN;\n    } else {\n        LOG_I(\"Entering phase: Static\");\n        hfuzz->feedback.state = _HF_STATE_STATIC;\n    }\n\n    for (size_t i = 0; i < hfuzz->threads.threadsMax; i++) {\n        if (!subproc_runThread(\n                hfuzz, &hfuzz->threads.threads[i], fuzz_threadNew, /* joinable= */ true)) {\n            PLOG_F(\"Couldn't run a thread #%zu\", i);\n        }\n    }\n}\n"
        },
        {
          "name": "fuzz.h",
          "type": "blob",
          "size": 1.0009765625,
          "content": "/*\n *\n * honggfuzz - fuzzing routines\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_FUZZ_H_\n#define _HF_FUZZ_H_\n\n#include <honggfuzz.h>\n#include <stdbool.h>\n\nextern void        fuzz_threadsStart(honggfuzz_t* fuzz);\nextern bool        fuzz_isTerminating(void);\nextern void        fuzz_setTerminating(void);\nextern bool        fuzz_shouldTerminate(void);\nextern fuzzState_t fuzz_getState(honggfuzz_t* hfuzz);\n\n#endif\n"
        },
        {
          "name": "hfuzz_cc",
          "type": "tree",
          "content": null
        },
        {
          "name": "honggfuzz.c",
          "type": "blob",
          "size": 14.5107421875,
          "content": "/*\n *\n * honggfuzz - the main file\n * -----------------------------------------\n *\n * Authors: Robert Swiecki <swiecki@google.com>\n *          Felix Gröbert <groebert@google.com>\n *\n * Copyright 2010-2019 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n\n#if defined(__FreeBSD__)\n#include <sys/procctl.h>\n#endif\n\n#include \"cmdline.h\"\n#include \"display.h\"\n#include \"fuzz.h\"\n#include \"input.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/files.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n#include \"socketfuzzer.h\"\n#include \"subproc.h\"\n\nstatic int  sigReceived = 0;\nstatic bool clearWin    = false;\n\n/*\n * CygWin/MinGW incorrectly copies stack during fork(), so we need to keep some\n * structures in the data section\n */\nhonggfuzz_t hfuzz;\n\nstatic void exitWithMsg(const char* msg, int exit_code) {\n    HF_ATTR_UNUSED ssize_t sz = write(STDERR_FILENO, msg, strlen(msg));\n    for (;;) {\n        exit(exit_code);\n        _exit(exit_code);\n        abort();\n        __builtin_trap();\n    }\n}\n\nstatic void sigHandler(int sig) {\n    /* We should not terminate upon SIGALRM delivery */\n    if (sig == SIGALRM) {\n        if (fuzz_shouldTerminate()) {\n            exitWithMsg(\"Terminating forcefully\\n\", EXIT_FAILURE);\n        }\n        return;\n    }\n    if (sig == SIGWINCH) {\n        ATOMIC_SET(clearWin, true);\n        return;\n    }\n\n    /* It's handled in the signal thread */\n    if (sig == SIGCHLD) {\n        return;\n    }\n\n    if (ATOMIC_GET(sigReceived) != 0) {\n        exitWithMsg(\"Repeated termination signal caught\\n\", EXIT_FAILURE);\n    }\n\n    ATOMIC_SET(sigReceived, sig);\n}\n\nstatic void setupRLimits(void) {\n    struct rlimit rlim;\n    if (getrlimit(RLIMIT_NOFILE, &rlim) == -1) {\n        PLOG_W(\"getrlimit(RLIMIT_NOFILE)\");\n        return;\n    }\n    if (rlim.rlim_cur >= 1024) {\n        return;\n    }\n    if (rlim.rlim_max < 1024) {\n        LOG_E(\"RLIMIT_NOFILE max limit < 1024 (%zu). Expect troubles!\", (size_t)rlim.rlim_max);\n        return;\n    }\n    rlim.rlim_cur = HF_MIN(1024, rlim.rlim_max);    // we don't need more\n    if (setrlimit(RLIMIT_NOFILE, &rlim) == -1) {\n        PLOG_E(\"Couldn't setrlimit(RLIMIT_NOFILE, cur=%zu/max=%zu)\", (size_t)rlim.rlim_cur,\n            (size_t)rlim.rlim_max);\n    }\n}\n\nstatic void setupMainThreadTimer(void) {\n    const struct itimerval it = {\n        .it_value =\n            {\n                .tv_sec  = 1,\n                .tv_usec = 0,\n            },\n        .it_interval =\n            {\n                .tv_sec  = 0,\n                .tv_usec = 1000ULL * 200ULL,\n            },\n    };\n    if (setitimer(ITIMER_REAL, &it, NULL) == -1) {\n        PLOG_F(\"setitimer(ITIMER_REAL)\");\n    }\n}\n\nstatic void setupSignalsPreThreads(void) {\n    /* Block signals which should be handled or blocked in the main thread */\n    sigset_t ss;\n    sigemptyset(&ss);\n    sigaddset(&ss, SIGTERM);\n    sigaddset(&ss, SIGINT);\n    sigaddset(&ss, SIGQUIT);\n    sigaddset(&ss, SIGALRM);\n    sigaddset(&ss, SIGPIPE);\n    /* Linux/arch uses it to discover events from persistent fuzzing processes */\n    sigaddset(&ss, SIGIO);\n    /* Let the signal thread catch SIGCHLD */\n    sigaddset(&ss, SIGCHLD);\n    /* This is checked for via sigwaitinfo/sigtimedwait */\n    sigaddset(&ss, SIGWINCH);\n    if (sigprocmask(SIG_SETMASK, &ss, NULL) != 0) {\n        PLOG_F(\"sigprocmask(SIG_SETMASK)\");\n    }\n\n    struct sigaction sa = {\n        .sa_handler = sigHandler,\n        .sa_flags   = 0,\n    };\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGTERM, &sa, NULL) == -1) {\n        PLOG_F(\"sigaction(SIGTERM) failed\");\n    }\n    if (sigaction(SIGINT, &sa, NULL) == -1) {\n        PLOG_F(\"sigaction(SIGINT) failed\");\n    }\n    if (sigaction(SIGQUIT, &sa, NULL) == -1) {\n        PLOG_F(\"sigaction(SIGQUIT) failed\");\n    }\n    if (sigaction(SIGALRM, &sa, NULL) == -1) {\n        PLOG_F(\"sigaction(SIGALRM) failed\");\n    }\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        PLOG_F(\"sigaction(SIGCHLD) failed\");\n    }\n    if (sigaction(SIGWINCH, &sa, NULL) == -1) {\n        PLOG_F(\"sigaction(SIGWINCH) failed\");\n    }\n}\n\nstatic void setupSignalsMainThread(void) {\n    /* Unblock signals which should be handled by the main thread */\n    sigset_t ss;\n    sigemptyset(&ss);\n    sigaddset(&ss, SIGTERM);\n    sigaddset(&ss, SIGINT);\n    sigaddset(&ss, SIGQUIT);\n    sigaddset(&ss, SIGALRM);\n    sigaddset(&ss, SIGWINCH);\n    if (pthread_sigmask(SIG_UNBLOCK, &ss, NULL) != 0) {\n        PLOG_F(\"pthread_sigmask(SIG_UNBLOCK)\");\n    }\n}\n\nstatic void printSummary(honggfuzz_t* hfuzz) {\n    uint64_t exec_per_sec = 0;\n    uint64_t elapsed_sec  = time(NULL) - hfuzz->timing.timeStart;\n    if (elapsed_sec) {\n        exec_per_sec = hfuzz->cnts.mutationsCnt / elapsed_sec;\n    }\n    uint64_t guardNb = ATOMIC_GET(hfuzz->feedback.covFeedbackMap->guardNb);\n    uint64_t branch_percent_cov =\n        guardNb ? ((100 * ATOMIC_GET(hfuzz->feedback.hwCnts.softCntEdge)) / guardNb) : 0;\n    struct rusage usage;\n    if (getrusage(RUSAGE_CHILDREN, &usage)) {\n        PLOG_W(\"getrusage  failed\");\n        usage.ru_maxrss = 0;    // 0 means something went wrong with rusage\n    }\n#ifdef _HF_ARCH_DARWIN\n    usage.ru_maxrss >>= 20;\n#else\n    usage.ru_maxrss >>= 10;\n#endif\n    LOG_I(\"Summary iterations:%zu time:%\" PRIu64 \" speed:%\" PRIu64 \" \"\n          \"crashes_count:%zu timeout_count:%zu new_units_added:%zu \"\n          \"slowest_unit_ms:%\" PRId64 \" guard_nb:%\" PRIu64 \" branch_coverage_percent:%\" PRIu64 \" \"\n          \"peak_rss_mb:%lu\",\n        hfuzz->cnts.mutationsCnt, elapsed_sec, exec_per_sec, hfuzz->cnts.crashesCnt,\n        hfuzz->cnts.timeoutedCnt, hfuzz->io.newUnitsAdded,\n        hfuzz->timing.timeOfLongestUnitUSecs / 1000U, hfuzz->feedback.covFeedbackMap->guardNb,\n        branch_percent_cov, usage.ru_maxrss);\n}\n\nstatic void pingThreads(honggfuzz_t* hfuzz) {\n    for (size_t i = 0; i < hfuzz->threads.threadsMax; i++) {\n        if (pthread_kill(hfuzz->threads.threads[i], SIGCHLD) != 0 && errno != EINTR && errno != 0) {\n            PLOG_W(\"pthread_kill(thread=%zu, SIGCHLD)\", i);\n        }\n    }\n}\n\nstatic void* signalThread(void* arg) {\n    honggfuzz_t* hfuzz = (honggfuzz_t*)arg;\n\n    sigset_t ss;\n    sigemptyset(&ss);\n    sigaddset(&ss, SIGCHLD);\n    if (pthread_sigmask(SIG_UNBLOCK, &ss, NULL) != 0) {\n        PLOG_F(\"Couldn't unblock SIGCHLD in the signal thread\");\n    }\n\n    for (;;) {\n        int sig = 0;\n        errno   = 0;\n        int ret = sigwait(&ss, &sig);\n        if (ret == EINTR) {\n            continue;\n        }\n        if (ret != 0 && errno == EINTR) {\n            continue;\n        }\n        if (ret != 0) {\n            PLOG_F(\"sigwait(SIGCHLD)\");\n        }\n        if (fuzz_isTerminating()) {\n            break;\n        }\n        if (sig == SIGCHLD) {\n            pingThreads(hfuzz);\n        }\n    }\n\n    return NULL;\n}\n\nstatic uint8_t mainThreadLoop(honggfuzz_t* hfuzz) {\n    setupSignalsMainThread();\n    setupMainThreadTimer();\n\n    for (;;) {\n        if (hfuzz->io.dynamicInputDir) {\n            LOG_D(\"Loading files from the dynamic input queue...\");\n            input_enqueueDynamicInputs(hfuzz);\n        }\n\n        if (hfuzz->display.useScreen) {\n            if (ATOMIC_XCHG(clearWin, false)) {\n                display_clear();\n            }\n            display_display(hfuzz);\n        }\n        if (ATOMIC_GET(sigReceived) > 0) {\n            LOG_I(\"Signal %d (%s) received, terminating\", ATOMIC_GET(sigReceived),\n                strsignal(ATOMIC_GET(sigReceived)));\n            break;\n        }\n        if (ATOMIC_GET(hfuzz->threads.threadsFinished) >= hfuzz->threads.threadsMax) {\n            break;\n        }\n        if (hfuzz->timing.runEndTime > 0 && (time(NULL) > hfuzz->timing.runEndTime)) {\n            LOG_I(\"Maximum run time reached, terminating\");\n            break;\n        }\n        if (hfuzz->timing.exitOnTime > 0 &&\n            time(NULL) - ATOMIC_GET(hfuzz->timing.lastCovUpdate) > hfuzz->timing.exitOnTime) {\n            LOG_I(\"No new coverage was found for the last %ld seconds, terminating\",\n                hfuzz->timing.exitOnTime);\n            break;\n        }\n        pingThreads(hfuzz);\n        pause();\n    }\n\n    fuzz_setTerminating();\n\n    for (;;) {\n        if (ATOMIC_GET(hfuzz->threads.threadsFinished) >= hfuzz->threads.threadsMax) {\n            break;\n        }\n        pingThreads(hfuzz);\n        util_sleepForMSec(50); /* 50ms */\n    }\n    if (hfuzz->cfg.exitUponCrash && ATOMIC_GET(hfuzz->cnts.crashesCnt) > 0) {\n        return hfuzz->cfg.exitCodeUponCrash;\n    } else {\n        return EXIT_SUCCESS;\n    }\n}\n\nstatic const char* strYesNo(bool yes) {\n    return (yes ? \"true\" : \"false\");\n}\n\nstatic const char* getGitVersion() {\n    static char version[] = \"$Id$\";\n    if (strlen(version) == 47) {\n        version[45] = '\\0';\n        return &version[5];\n    }\n    return \"UNKNOWN\";\n}\n\nint main(int argc, char** argv) {\n    /*\n     * Work around CygWin/MinGW\n     */\n    char** myargs = (char**)util_Calloc(sizeof(char*) * (argc + 1));\n    defer {\n        free(myargs);\n    };\n\n    int i;\n    for (i = 0U; i < argc; i++) {\n        myargs[i] = argv[i];\n    }\n    myargs[i] = NULL;\n\n    if (!cmdlineParse(argc, myargs, &hfuzz)) {\n        LOG_F(\"Parsing of the cmd-line arguments failed\");\n    }\n    if (hfuzz.io.inputDir && access(hfuzz.io.inputDir, R_OK) == -1) {\n        PLOG_F(\"Input directory '%s' is not readable\", hfuzz.io.inputDir);\n    }\n    if (hfuzz.io.outputDir && access(hfuzz.io.outputDir, W_OK) == -1) {\n        PLOG_F(\"Output directory '%s' is not writeable\", hfuzz.io.outputDir);\n    }\n    if (hfuzz.cfg.minimize) {\n        LOG_I(\"Minimization mode enabled. Setting number of threads to 1\");\n        hfuzz.threads.threadsMax = 1;\n    }\n\n    char tmstr[64];\n    util_getLocalTime(\"%F.%H.%M.%S\", tmstr, sizeof(tmstr), time(NULL));\n    LOG_I(\"Start time:'%s' bin:'%s', input:'%s', output:'%s', persistent:%s, stdin:%s, \"\n          \"mutation_rate:%u, timeout:%ld, max_runs:%zu, threads:%zu, minimize:%s, git_commit:%s\",\n        tmstr, hfuzz.exe.cmdline[0], hfuzz.io.inputDir,\n        hfuzz.io.outputDir ? hfuzz.io.outputDir : hfuzz.io.inputDir, strYesNo(hfuzz.exe.persistent),\n        strYesNo(hfuzz.exe.fuzzStdin), hfuzz.mutate.mutationsPerRun, (long)hfuzz.timing.tmOut,\n        hfuzz.mutate.mutationsMax, hfuzz.threads.threadsMax, strYesNo(hfuzz.cfg.minimize),\n        getGitVersion());\n\n    sigemptyset(&hfuzz.exe.waitSigSet);\n    sigaddset(&hfuzz.exe.waitSigSet, SIGIO);   /* Persistent socket data */\n    sigaddset(&hfuzz.exe.waitSigSet, SIGCHLD); /* Ping from the signal thread */\n\n    if (hfuzz.display.useScreen) {\n        display_init();\n    }\n\n    if (hfuzz.socketFuzzer.enabled) {\n        LOG_I(\"No input file corpus loaded, the external socket_fuzzer is responsible for \"\n              \"creating the fuzz data\");\n        setupSocketFuzzer(&hfuzz);\n    } else if (!input_init(&hfuzz)) {\n        LOG_F(\"Couldn't load input corpus\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (hfuzz.mutate.dictionaryFile && !input_parseDictionary(&hfuzz)) {\n        LOG_F(\"Couldn't parse dictionary file ('%s')\", hfuzz.mutate.dictionaryFile);\n    }\n\n    if (hfuzz.feedback.blocklistFile && !input_parseBlacklist(&hfuzz)) {\n        LOG_F(\"Couldn't parse stackhash blocklist file ('%s')\", hfuzz.feedback.blocklistFile);\n    }\n#define hfuzzl hfuzz.arch_linux\n    if (hfuzzl.symsBlFile &&\n        ((hfuzzl.symsBlCnt = files_parseSymbolFilter(hfuzzl.symsBlFile, &hfuzzl.symsBl)) == 0)) {\n        LOG_F(\"Couldn't parse symbols blocklist file ('%s')\", hfuzzl.symsBlFile);\n    }\n\n    if (hfuzzl.symsWlFile &&\n        ((hfuzzl.symsWlCnt = files_parseSymbolFilter(hfuzzl.symsWlFile, &hfuzzl.symsWl)) == 0)) {\n        LOG_F(\"Couldn't parse symbols allowlist file ('%s')\", hfuzzl.symsWlFile);\n    }\n\n    if (!(hfuzz.feedback.covFeedbackMap =\n                files_mapSharedMem(sizeof(feedback_t), &hfuzz.feedback.covFeedbackFd,\n                    \"hf-covfeedback\", /* nocore= */ true, /* export= */ hfuzz.io.exportFeedback))) {\n        LOG_F(\"files_mapSharedMem(name='hf-covfeddback', sz=%zu, dir='%s') failed\",\n            sizeof(feedback_t), hfuzz.io.workDir);\n    }\n    if (hfuzz.feedback.cmpFeedback) {\n        if (!(hfuzz.feedback.cmpFeedbackMap = files_mapSharedMem(sizeof(cmpfeedback_t),\n                  &hfuzz.feedback.cmpFeedbackFd, \"hf-cmpfeedback\", /* nocore= */ true,\n                  /* export= */ hfuzz.io.exportFeedback))) {\n            LOG_F(\"files_mapSharedMem(name='hf-cmpfeedback', sz=%zu, dir='%s') failed\",\n                sizeof(cmpfeedback_t), hfuzz.io.workDir);\n        }\n    }\n    /* Stats file. */\n    if (hfuzz.io.statsFileName) {\n        hfuzz.io.statsFileFd =\n            TEMP_FAILURE_RETRY(open(hfuzz.io.statsFileName, O_CREAT | O_RDWR | O_TRUNC, 0640));\n\n        if (hfuzz.io.statsFileFd == -1) {\n            PLOG_F(\"Couldn't open statsfile open('%s')\", hfuzz.io.statsFileName);\n        } else {\n            dprintf(hfuzz.io.statsFileFd, \"# unix_time, last_cov_update, total_exec, exec_per_sec, \"\n                                          \"crashes, unique_crashes, hangs, edge_cov, block_cov\\n\");\n        }\n    }\n\n    setupRLimits();\n    setupSignalsPreThreads();\n    fuzz_threadsStart(&hfuzz);\n\n    pthread_t sigthread;\n    if (!subproc_runThread(&hfuzz, &sigthread, signalThread, /* joinable= */ false)) {\n        LOG_F(\"Couldn't start the signal thread\");\n    }\n\n    uint8_t exitcode = mainThreadLoop(&hfuzz);\n\n    /* Clean-up global buffers */\n    if (hfuzz.feedback.blocklist) {\n        free(hfuzz.feedback.blocklist);\n    }\n#if defined(_HF_ARCH_LINUX)\n    if (hfuzz.arch_linux.symsBl) {\n        free(hfuzz.arch_linux.symsBl);\n    }\n    if (hfuzz.arch_linux.symsWl) {\n        free(hfuzz.arch_linux.symsWl);\n    }\n#elif defined(_HF_ARCH_NETBSD)\n    if (hfuzz.arch_netbsd.symsBl) {\n        free(hfuzz.arch_netbsd.symsBl);\n    }\n    if (hfuzz.arch_netbsd.symsWl) {\n        free(hfuzz.arch_netbsd.symsWl);\n    }\n#endif\n    if (hfuzz.socketFuzzer.enabled) {\n        cleanupSocketFuzzer();\n    }\n    /* Stats file. */\n    if (hfuzz.io.statsFileName) {\n        close(hfuzz.io.statsFileFd);\n    }\n\n    printSummary(&hfuzz);\n\n    return exitcode;\n}\n"
        },
        {
          "name": "honggfuzz.h",
          "type": "blob",
          "size": 11.240234375,
          "content": "/*\n *\n * honggfuzz - core structures and macros\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_HONGGFUZZ_H_\n#define _HF_HONGGFUZZ_H_\n\n#include <dirent.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <sys/param.h>\n#include <sys/queue.h>\n#include <sys/types.h>\n#include <time.h>\n\n#include \"libhfcommon/util.h\"\n\n#define PROG_NAME    \"honggfuzz\"\n#define PROG_VERSION \"2.6\"\n\n/* Name of the template which will be replaced with the proper name of the file */\n#define _HF_FILE_PLACEHOLDER \"___FILE___\"\n\n/* Default name of the report created with some architectures */\n#define _HF_REPORT_FILE \"HONGGFUZZ.REPORT.TXT\"\n\n/* Default stack-size of created threads. */\n#define _HF_PTHREAD_STACKSIZE (1024ULL * 1024ULL * 2ULL) /* 2MB */\n\n/* Name of envvar which indicates sequential number of fuzzer */\n#define _HF_THREAD_NO_ENV \"HFUZZ_THREAD_NO\"\n\n/* Name of envvar which indicates that the netDriver should be used */\n#define _HF_THREAD_NETDRIVER_ENV \"HFUZZ_USE_NETDRIVER\"\n\n/* Name of envvar which indicates honggfuzz's log level in use */\n#define _HF_LOG_LEVEL_ENV \"HFUZZ_LOG_LEVEL\"\n\n/* Number of crash verifier iterations before tag crash as stable */\n#define _HF_VERIFIER_ITER 5\n\n/* Size (in bytes) for report data to be stored in stack before written to file */\n#define _HF_REPORT_SIZE 32768\n\n/* Perf bitmap size */\n#define _HF_PERF_BITMAP_SIZE_16M   (1024U * 1024U * 16U)\n#define _HF_PERF_BITMAP_BITSZ_MASK 0x7FFFFFFULL\n/* Maximum number of PC guards (=trace-pc-guard) we support */\n#define _HF_PC_GUARD_MAX (1024ULL * 1024ULL * 64ULL)\n\n/* Maximum size of the input file in bytes (1 MiB) */\n#define _HF_INPUT_MAX_SIZE (1024ULL * 1024ULL)\n\n/* Default maximum size of produced inputs */\n#define _HF_INPUT_DEFAULT_SIZE (1024ULL * 8)\n\n/* Per-thread bitmap */\n#define _HF_PERTHREAD_BITMAP_FD 1018\n/* FD used to report back used int/str constants from the fuzzed process */\n#define _HF_CMP_BITMAP_FD 1019\n/* FD used to log inside the child process */\n#define _HF_LOG_FD 1020\n/* FD used to represent the input file */\n#define _HF_INPUT_FD 1021\n/* FD used to pass coverage feedback from the fuzzed process */\n#define _HF_COV_BITMAP_FD 1022\n#define _HF_BITMAP_FD     _HF_COV_BITMAP_FD /* Old name for _HF_COV_BITMAP_FD */\n/* FD used to pass data to a persistent process */\n#define _HF_PERSISTENT_FD 1023\n\n/* Input file as a string */\n#define _HF_INPUT_FILE_PATH \"/dev/fd/\" HF_XSTR(_HF_INPUT_FD)\n\n/* Maximum number of supported execve() args */\n#define _HF_ARGS_MAX 2048\n\n/* Message indicating that the fuzzed process is ready for new data */\nstatic const uint8_t HFReadyTag = 'R';\n\n/* Maximum number of active fuzzing threads */\n#define _HF_THREAD_MAX 1024U\n\n/* Persistent-binary signature - if found within file, it means it's a persistent mode binary */\n#define _HF_PERSISTENT_SIG \"\\x01_LIBHFUZZ_PERSISTENT_BINARY_SIGNATURE_\\x02\\xFF\"\n/* HF NetDriver signature - if found within file, it means it's a NetDriver-based binary */\n#define _HF_NETDRIVER_SIG \"\\x01_LIBHFUZZ_NETDRIVER_BINARY_SIGNATURE_\\x02\\xFF\"\n\n/* printf() nonmonetary separator. According to MacOSX's man it's supported there as well */\n#define _HF_NONMON_SEP \"'\"\n\ntypedef enum {\n    _HF_DYNFILE_NONE         = 0x0,\n    _HF_DYNFILE_INSTR_COUNT  = 0x1,\n    _HF_DYNFILE_BRANCH_COUNT = 0x2,\n    _HF_DYNFILE_BTS_EDGE     = 0x10,\n    _HF_DYNFILE_IPT_BLOCK    = 0x20,\n    _HF_DYNFILE_SOFT         = 0x40,\n} dynFileMethod_t;\n\ntypedef struct {\n    uint64_t cpuInstrCnt;\n    uint64_t cpuBranchCnt;\n    uint64_t bbCnt;\n    uint64_t newBBCnt;\n    uint64_t softCntPc;\n    uint64_t softCntEdge;\n    uint64_t softCntCmp;\n} hwcnt_t;\n\ntypedef enum {\n    _HF_STATE_UNSET = 0,\n    _HF_STATE_STATIC,\n    _HF_STATE_DYNAMIC_DRY_RUN,\n    _HF_STATE_DYNAMIC_MAIN,\n    _HF_STATE_DYNAMIC_MINIMIZE,\n} fuzzState_t;\n\ntypedef enum {\n    HF_MAYBE = -1,\n    HF_NO    = 0,\n    HF_YES   = 1,\n} tristate_t;\n\nstruct _dynfile_t {\n    size_t             size;\n    uint64_t           cov[4];\n    size_t             idx;\n    int                fd;\n    uint64_t           timeExecUSecs;\n    char               path[PATH_MAX];\n    struct _dynfile_t* src;\n    uint32_t           refs;\n    fuzzState_t        phase;\n    bool               timedout;\n    uint8_t*           data;\n    TAILQ_ENTRY(_dynfile_t) pointers;\n};\n\ntypedef struct _dynfile_t dynfile_t;\n\nstruct strings_t {\n    size_t len;\n    TAILQ_ENTRY(strings_t) pointers;\n    char s[];\n};\n\ntypedef struct {\n    uint8_t  pcGuardMap[_HF_PC_GUARD_MAX];\n    uint8_t  bbMapPc[_HF_PERF_BITMAP_SIZE_16M];\n    uint32_t bbMapCmp[_HF_PERF_BITMAP_SIZE_16M];\n    uint64_t pidNewPC[_HF_THREAD_MAX];\n    uint64_t pidNewEdge[_HF_THREAD_MAX];\n    uint64_t pidNewCmp[_HF_THREAD_MAX];\n    uint64_t guardNb;\n    uint64_t pidTotalPC[_HF_THREAD_MAX];\n    uint64_t pidTotalEdge[_HF_THREAD_MAX];\n    uint64_t pidTotalCmp[_HF_THREAD_MAX];\n} feedback_t;\n\ntypedef struct {\n    uint32_t cnt;\n    struct {\n        uint8_t  val[32];\n        uint32_t len;\n    } valArr[1024 * 16];\n} cmpfeedback_t;\n\ntypedef struct {\n    struct {\n        size_t    threadsMax;\n        size_t    threadsFinished;\n        uint32_t  threadsActiveCnt;\n        pthread_t mainThread;\n        pid_t     mainPid;\n        uint32_t  pinThreadToCPUs;\n        pthread_t threads[_HF_THREAD_MAX];\n    } threads;\n    struct {\n        const char* inputDir;\n        const char* outputDir;\n        DIR*        inputDirPtr;\n        size_t      fileCnt;\n        size_t      testedFileCnt;\n        const char* fileExtn;\n        size_t      maxFileSz;\n        size_t      newUnitsAdded;\n        char        workDir[PATH_MAX];\n        const char* crashDir;\n        const char* covDirNew;\n        bool        saveUnique;\n        bool        saveSmaller;\n        size_t      dynfileqMaxSz;\n        size_t      dynfileqCnt;\n        dynfile_t*  dynfileqCurrent;\n        dynfile_t*  dynfileq2Current;\n        TAILQ_HEAD(dyns_t, _dynfile_t) dynfileq;\n        bool        exportFeedback;\n        const char* dynamicInputDir;\n        const char* statsFileName;\n        int         statsFileFd;\n    } io;\n    struct {\n        int                argc;\n        const char* const* cmdline;\n        bool               nullifyStdio;\n        bool               fuzzStdin;\n        const char*        externalCommand;\n        const char*        postExternalCommand;\n        const char*        feedbackMutateCommand;\n        bool               netDriver;\n        bool               persistent;\n        uint64_t           asLimit;\n        uint64_t           rssLimit;\n        uint64_t           dataLimit;\n        uint64_t           coreLimit;\n        uint64_t           stackLimit;\n        bool               clearEnv;\n        char*              env_ptrs[128];\n        char               env_vals[128][4096];\n        sigset_t           waitSigSet;\n    } exe;\n    struct {\n        time_t  timeStart;\n        time_t  runEndTime;\n        time_t  tmOut;\n        time_t  lastCovUpdate;\n        time_t  exitOnTime;\n        int64_t timeOfLongestUnitUSecs;\n        bool    tmoutVTALRM;\n    } timing;\n    struct {\n        struct {\n            uint8_t val[512];\n            size_t  len;\n        } dictionary[8192];\n        size_t      dictionaryCnt;\n        const char* dictionaryFile;\n        size_t      mutationsMax;\n        unsigned    mutationsPerRun;\n        size_t      maxInputSz;\n    } mutate;\n    struct {\n        bool    useScreen;\n        char    cmdline_txt[65];\n        int64_t lastDisplayUSecs;\n    } display;\n    struct {\n        bool        useVerifier;\n        bool        exitUponCrash;\n        uint8_t     exitCodeUponCrash;\n        const char* reportFile;\n        size_t      dynFileIterExpire;\n        bool        only_printable;\n        bool        minimize;\n        bool        switchingToFDM;\n    } cfg;\n    struct {\n        bool enable;\n        bool del_report;\n    } sanitizer;\n    struct {\n        fuzzState_t     state;\n        feedback_t*     covFeedbackMap;\n        int             covFeedbackFd;\n        cmpfeedback_t*  cmpFeedbackMap;\n        int             cmpFeedbackFd;\n        bool            cmpFeedback;\n        const char*     blocklistFile;\n        uint64_t*       blocklist;\n        size_t          blocklistCnt;\n        bool            skipFeedbackOnTimeout;\n        uint64_t        maxCov[4];\n        dynFileMethod_t dynFileMethod;\n        hwcnt_t         hwCnts;\n    } feedback;\n    struct {\n        size_t mutationsCnt;\n        size_t crashesCnt;\n        size_t uniqueCrashesCnt;\n        size_t verifiedCrashesCnt;\n        size_t blCrashesCnt;\n        size_t timeoutedCnt;\n    } cnts;\n    struct {\n        bool enabled;\n        int  serverSocket;\n        int  clientSocket;\n    } socketFuzzer;\n    struct {\n        pthread_rwlock_t dynfileq;\n        pthread_mutex_t  feedback;\n        pthread_mutex_t  report;\n        pthread_mutex_t  state;\n        pthread_mutex_t  input;\n        pthread_mutex_t  timing;\n    } mutex;\n\n    /* For the Linux code */\n    struct {\n        int         exeFd;\n        uint64_t    dynamicCutOffAddr;\n        bool        disableRandomization;\n        void*       ignoreAddr;\n        const char* symsBlFile;\n        char**      symsBl;\n        size_t      symsBlCnt;\n        const char* symsWlFile;\n        char**      symsWl;\n        size_t      symsWlCnt;\n        uintptr_t   cloneFlags;\n        tristate_t  useNetNs;\n        bool        kernelOnly;\n        bool        useClone;\n    } arch_linux;\n    /* For the NetBSD code */\n    struct {\n        void*       ignoreAddr;\n        const char* symsBlFile;\n        char**      symsBl;\n        size_t      symsBlCnt;\n        const char* symsWlFile;\n        char**      symsWl;\n        size_t      symsWlCnt;\n    } arch_netbsd;\n} honggfuzz_t;\n\ntypedef enum {\n    _HF_RS_UNKNOWN                   = 0,\n    _HF_RS_WAITING_FOR_INITIAL_READY = 1,\n    _HF_RS_WAITING_FOR_READY         = 2,\n    _HF_RS_SEND_DATA                 = 3,\n} runState_t;\n\ntypedef struct {\n    honggfuzz_t* global;\n    pid_t        pid;\n    int64_t      timeStartedUSecs;\n    char         crashFileName[PATH_MAX];\n    uint64_t     pc;\n    uint64_t     backtrace;\n    uint64_t     access;\n    int          exception;\n    char         report[_HF_REPORT_SIZE];\n    bool         mainWorker;\n    unsigned     mutationsPerRun;\n    dynfile_t*   dynfile;\n    bool         staticFileTryMore;\n    uint32_t     fuzzNo;\n    int          persistentSock;\n    runState_t   runState;\n    bool         tmOutSignaled;\n    char*        args[_HF_ARGS_MAX + 1];\n    int          perThreadCovFeedbackFd;\n    unsigned     triesLeft;\n    dynfile_t*   current;\n    hwcnt_t      hwCnts;\n\n    struct {\n        /* For Linux code */\n        uint8_t* perfMmapBuf;\n        uint8_t* perfMmapAux;\n        int      cpuInstrFd;\n        int      cpuBranchFd;\n        int      cpuIptBtsFd;\n    } arch_linux;\n} run_t;\n\n#endif\n"
        },
        {
          "name": "includes",
          "type": "tree",
          "content": null
        },
        {
          "name": "input.c",
          "type": "blob",
          "size": 28.359375,
          "content": "/*\n * honggfuzz - file operations\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2020 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include \"input.h\"\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/queue.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"fuzz.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/files.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n#include \"mangle.h\"\n#include \"subproc.h\"\n\nvoid input_setSize(run_t* run, size_t sz) {\n    if (run->dynfile->size == sz) {\n        return;\n    }\n    if (sz > run->global->mutate.maxInputSz) {\n        PLOG_F(\"Too large size requested: %zu > maxSize: %zu\", sz, run->global->mutate.maxInputSz);\n    }\n    /* ftruncate of a mmaped file fails under CygWin, it's also painfully slow under MacOS X */\n#if !defined(__CYGWIN__) && !defined(_HF_ARCH_DARWIN)\n    if (TEMP_FAILURE_RETRY(ftruncate(run->dynfile->fd, sz)) == -1) {\n        PLOG_W(\"ftruncate(run->dynfile->fd=%d, sz=%zu)\", run->dynfile->fd, sz);\n    }\n#endif /* !defined(__CYGWIN__) && !defined(_HF_ARCH_DARWIN) */\n    run->dynfile->size = sz;\n}\n\nbool input_getDirStatsAndRewind(honggfuzz_t* hfuzz) {\n    rewinddir(hfuzz->io.inputDirPtr);\n\n    size_t fileCnt = 0U;\n    for (;;) {\n        errno                = 0;\n        struct dirent* entry = readdir(hfuzz->io.inputDirPtr);\n        if (entry == NULL && errno == EINTR) {\n            continue;\n        }\n        if (entry == NULL && errno != 0) {\n            PLOG_W(\"readdir('%s')\", hfuzz->io.inputDir);\n            return false;\n        }\n        if (entry == NULL) {\n            break;\n        }\n\n        char path[PATH_MAX];\n        snprintf(path, sizeof(path), \"%s/%s\", hfuzz->io.inputDir, entry->d_name);\n\n        LOG_D(\"Analyzing file '%s'\", path);\n\n        struct stat st;\n        if (stat(path, &st) == -1) {\n            LOG_W(\"Couldn't stat() the '%s' file\", path);\n            continue;\n        }\n        if (!S_ISREG(st.st_mode)) {\n            LOG_D(\"'%s' is not a regular file, skipping\", path);\n            continue;\n        }\n        if (hfuzz->io.maxFileSz && st.st_size > (off_t)hfuzz->io.maxFileSz) {\n            LOG_D(\"File '%s' is bigger than maximal defined file size (-F): %\" PRIu64 \" > %zu\",\n                path, (uint64_t)st.st_size, hfuzz->io.maxFileSz);\n        }\n        if ((size_t)st.st_size > hfuzz->mutate.maxInputSz) {\n            hfuzz->mutate.maxInputSz = st.st_size;\n        }\n        fileCnt++;\n    }\n\n    ATOMIC_SET(hfuzz->io.fileCnt, fileCnt);\n    if (hfuzz->io.maxFileSz) {\n        hfuzz->mutate.maxInputSz = hfuzz->io.maxFileSz;\n    } else if (hfuzz->mutate.maxInputSz < _HF_INPUT_DEFAULT_SIZE) {\n        hfuzz->mutate.maxInputSz = _HF_INPUT_DEFAULT_SIZE;\n    } else if (hfuzz->mutate.maxInputSz > _HF_INPUT_MAX_SIZE) {\n        hfuzz->mutate.maxInputSz = _HF_INPUT_MAX_SIZE;\n    }\n\n    if (hfuzz->io.fileCnt == 0U) {\n        LOG_W(\"No usable files in the input directory '%s'\", hfuzz->io.inputDir);\n    }\n\n    LOG_D(\"Analyzed '%s' directory: maxInputSz:%zu, number of usable files:%zu\", hfuzz->io.inputDir,\n        hfuzz->mutate.maxInputSz, hfuzz->io.fileCnt);\n\n    rewinddir(hfuzz->io.inputDirPtr);\n\n    return true;\n}\n\nbool input_getNext(run_t* run, char fname[PATH_MAX], size_t* len, bool rewind) {\n    MX_SCOPED_LOCK(&run->global->mutex.input);\n\n    if (run->global->io.fileCnt == 0U) {\n        LOG_W(\"No useful files in the input directory\");\n        return false;\n    }\n\n    for (;;) {\n        errno                = 0;\n        struct dirent* entry = readdir(run->global->io.inputDirPtr);\n        if (entry == NULL && errno == EINTR) {\n            continue;\n        }\n        if (entry == NULL && errno != 0) {\n            PLOG_W(\"readdir_r('%s')\", run->global->io.inputDir);\n            return false;\n        }\n        if (entry == NULL && !rewind) {\n            return false;\n        }\n        if (entry == NULL && rewind) {\n            rewinddir(run->global->io.inputDirPtr);\n            continue;\n        }\n        char path[PATH_MAX];\n        snprintf(path, PATH_MAX, \"%s/%s\", run->global->io.inputDir, entry->d_name);\n        struct stat st;\n        if (stat(path, &st) == -1) {\n            LOG_W(\"Couldn't stat() the '%s' file\", path);\n            continue;\n        }\n        if (!S_ISREG(st.st_mode)) {\n            LOG_D(\"'%s' is not a regular file, skipping\", path);\n            continue;\n        }\n\n        snprintf(fname, PATH_MAX, \"%s\", entry->d_name);\n        *len = st.st_size;\n        return true;\n    }\n}\n\nbool input_init(honggfuzz_t* hfuzz) {\n    hfuzz->io.fileCnt = 0U;\n\n    if (!hfuzz->io.inputDir) {\n        LOG_W(\"No input file/dir specified\");\n        return false;\n    }\n\n    int dir_fd = TEMP_FAILURE_RETRY(open(hfuzz->io.inputDir, O_DIRECTORY | O_RDONLY | O_CLOEXEC));\n    if (dir_fd == -1) {\n        PLOG_W(\"open('%s', O_DIRECTORY|O_RDONLY|O_CLOEXEC)\", hfuzz->io.inputDir);\n        return false;\n    }\n    if ((hfuzz->io.inputDirPtr = fdopendir(dir_fd)) == NULL) {\n        PLOG_W(\"fdopendir(dir='%s', fd=%d)\", hfuzz->io.inputDir, dir_fd);\n        close(dir_fd);\n        return false;\n    }\n    if (!input_getDirStatsAndRewind(hfuzz)) {\n        hfuzz->io.fileCnt = 0U;\n        LOG_W(\"input_getDirStatsAndRewind('%s')\", hfuzz->io.inputDir);\n        return false;\n    }\n\n    return true;\n}\n\nbool input_parseDictionary(honggfuzz_t* hfuzz) {\n    LOG_I(\"Parsing dictionary file '%s'\", hfuzz->mutate.dictionaryFile);\n\n    FILE* fDict = fopen(hfuzz->mutate.dictionaryFile, \"rb\");\n    if (fDict == NULL) {\n        PLOG_W(\"Couldn't open '%s' - R/O mode\", hfuzz->mutate.dictionaryFile);\n        return false;\n    }\n    defer {\n        fclose(fDict);\n    };\n\n    char*  lineptr = NULL;\n    size_t n       = 0;\n    defer {\n        free(lineptr);\n    };\n    for (;;) {\n        ssize_t len = getdelim(&lineptr, &n, '\\n', fDict);\n        if (len == -1) {\n            break;\n        }\n        if (hfuzz->mutate.dictionaryCnt == ARRAYSIZE(hfuzz->mutate.dictionary)) {\n            LOG_W(\"Maximum number of dictionary entries '%zu' alread loaded. Skipping the rest\",\n                ARRAYSIZE(hfuzz->mutate.dictionary));\n            break;\n        }\n        if (len > 1 && lineptr[len - 1] == '\\n') {\n            lineptr[len - 1] = '\\0';\n            len--;\n        }\n        if (lineptr[0] == '#') {\n            continue;\n        }\n        if (lineptr[0] == '\\n') {\n            continue;\n        }\n        if (lineptr[0] == '\\0') {\n            continue;\n        }\n\n        const char* start = strchr(lineptr, '\"');\n        char*       end   = strrchr(lineptr, '\"');\n        if (!start || !end) {\n            LOG_W(\"Malformed dictionary line '%s', skipping\", lineptr);\n            continue;\n        }\n        if ((uintptr_t)start == (uintptr_t)end) {\n            LOG_W(\"Malformed dictionary line '%s', skipping\", lineptr);\n            continue;\n        }\n        *end = '\\0';\n\n        char bufv[1025] = {};\n        if (sscanf(&start[1], \"%1024c\", bufv) != 1) {\n            LOG_W(\"Malformed dictionary line '%s', skipping\", lineptr);\n            continue;\n        }\n\n        LOG_D(\"Parsing dictionary word: '%s'\", bufv);\n\n        len              = util_decodeCString(bufv);\n        size_t dictEntry = ATOMIC_POST_INC(hfuzz->mutate.dictionaryCnt);\n        len              = HF_MIN((size_t)len, sizeof(hfuzz->mutate.dictionary[dictEntry].val));\n        memcpy(hfuzz->mutate.dictionary[dictEntry].val, bufv, len);\n        hfuzz->mutate.dictionary[dictEntry].len = len;\n\n        LOG_D(\"Dictionary: loaded word: '%s' (len=%zd)\", bufv, len);\n    }\n    LOG_I(\"Loaded %zu words from the dictionary '%s'\", hfuzz->mutate.dictionaryCnt,\n        hfuzz->mutate.dictionaryFile);\n    return true;\n}\n\nbool input_parseBlacklist(honggfuzz_t* hfuzz) {\n    FILE* fBl = fopen(hfuzz->feedback.blocklistFile, \"rb\");\n    if (fBl == NULL) {\n        PLOG_W(\"Couldn't open '%s' - R/O mode\", hfuzz->feedback.blocklistFile);\n        return false;\n    }\n    defer {\n        fclose(fBl);\n    };\n\n    char* lineptr = NULL;\n    /* lineptr can be NULL, but it's fine for free() */\n    defer {\n        free(lineptr);\n    };\n    size_t n = 0;\n    for (;;) {\n        if (getline(&lineptr, &n, fBl) == -1) {\n            break;\n        }\n\n        if ((hfuzz->feedback.blocklist = util_Realloc(hfuzz->feedback.blocklist,\n                 (hfuzz->feedback.blocklistCnt + 1) * sizeof(hfuzz->feedback.blocklist[0]))) ==\n            NULL) {\n            PLOG_W(\"realloc failed (sz=%zu)\",\n                (hfuzz->feedback.blocklistCnt + 1) * sizeof(hfuzz->feedback.blocklist[0]));\n            return false;\n        }\n\n        hfuzz->feedback.blocklist[hfuzz->feedback.blocklistCnt] = strtoull(lineptr, 0, 16);\n        LOG_D(\"Blacklist: loaded %'\" PRIu64 \"'\",\n            hfuzz->feedback.blocklist[hfuzz->feedback.blocklistCnt]);\n\n        /* Verify entries are sorted so we can use interpolation search */\n        if (hfuzz->feedback.blocklistCnt >= 1) {\n            if (hfuzz->feedback.blocklist[hfuzz->feedback.blocklistCnt - 1] >\n                hfuzz->feedback.blocklist[hfuzz->feedback.blocklistCnt]) {\n                LOG_F(\"Blacklist file not sorted. Use 'tools/createStackBlacklist.sh' to sort \"\n                      \"records\");\n                return false;\n            }\n        }\n        hfuzz->feedback.blocklistCnt += 1;\n    }\n\n    if (hfuzz->feedback.blocklistCnt > 0) {\n        LOG_I(\"Loaded %zu stack hash(es) from the blocklist file\", hfuzz->feedback.blocklistCnt);\n    } else {\n        LOG_F(\"Empty stack hashes blocklist file '%s'\", hfuzz->feedback.blocklistFile);\n    }\n    return true;\n}\n\nstatic void input_generateFileName(dynfile_t* dynfile, const char* dir, char fname[PATH_MAX]) {\n    uint64_t crc64f = util_CRC64(dynfile->data, dynfile->size);\n    uint64_t crc64r = util_CRC64Rev(dynfile->data, dynfile->size);\n    if (dir) {\n        snprintf(fname, PATH_MAX, \"%s/%016\" PRIx64 \"%016\" PRIx64 \".%08\" PRIx32 \".honggfuzz.cov\",\n            dir, crc64f, crc64r, (uint32_t)dynfile->size);\n    } else {\n        snprintf(fname, PATH_MAX, \"%016\" PRIx64 \"%016\" PRIx64 \".%08\" PRIx32 \".honggfuzz.cov\",\n            crc64f, crc64r, (uint32_t)dynfile->size);\n    }\n}\n\nbool input_writeCovFile(const char* dir, dynfile_t* dynfile) {\n    char fname[PATH_MAX];\n    input_generateFileName(dynfile, dir, fname);\n\n    if (files_exists(fname)) {\n        LOG_D(\"File '%s' already exists in the output corpus directory '%s'\", fname, dir);\n        return true;\n    }\n\n    LOG_D(\"Adding file '%s' to the corpus directory '%s'\", fname, dir);\n\n    if (!files_writeBufToFile(\n            fname, dynfile->data, dynfile->size, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC)) {\n        LOG_W(\"Couldn't write buffer to file '%s' (sz=%zu)\", fname, dynfile->size);\n        return false;\n    }\n\n    return true;\n}\n\n/* true if item1 is bigger than item2 */\nstatic bool input_cmpCov(dynfile_t* item1, dynfile_t* item2) {\n    for (size_t j = 0; j < ARRAYSIZE(item1->cov); j++) {\n        if (item1->cov[j] > item2->cov[j]) {\n            return true;\n        }\n        if (item1->cov[j] < item2->cov[j]) {\n            return false;\n        }\n    }\n    /* Both are equal */\n    return false;\n}\n\n#define TAILQ_FOREACH_HF(var, head, field)                                                         \\\n    for ((var) = TAILQ_FIRST((head)); (var); (var) = TAILQ_NEXT((var), field))\n\nvoid input_addDynamicInput(run_t* run) {\n    ATOMIC_SET(run->global->timing.lastCovUpdate, time(NULL));\n\n    dynfile_t* dynfile     = (dynfile_t*)util_Calloc(sizeof(dynfile_t));\n    dynfile->size          = run->dynfile->size;\n    dynfile->timeExecUSecs = util_timeNowUSecs() - run->timeStartedUSecs;\n    dynfile->data          = (uint8_t*)util_AllocCopy(run->dynfile->data, run->dynfile->size);\n    dynfile->src           = run->dynfile->src;\n    memcpy(dynfile->cov, run->dynfile->cov, sizeof(dynfile->cov));\n    if (run->dynfile->src) {\n        ATOMIC_POST_INC(run->dynfile->src->refs);\n    }\n    dynfile->phase    = fuzz_getState(run->global);\n    dynfile->timedout = run->tmOutSignaled;\n    input_generateFileName(dynfile, NULL, dynfile->path);\n\n    MX_SCOPED_RWLOCK_WRITE(&run->global->mutex.dynfileq);\n\n    dynfile->idx = ATOMIC_PRE_INC(run->global->io.dynfileqCnt);\n\n    run->global->feedback.maxCov[0] = HF_MAX(run->global->feedback.maxCov[0], dynfile->cov[0]);\n    run->global->feedback.maxCov[1] = HF_MAX(run->global->feedback.maxCov[1], dynfile->cov[1]);\n    run->global->feedback.maxCov[2] = HF_MAX(run->global->feedback.maxCov[2], dynfile->cov[2]);\n    run->global->feedback.maxCov[3] = HF_MAX(run->global->feedback.maxCov[3], dynfile->cov[3]);\n\n    run->global->io.dynfileqMaxSz = HF_MAX(run->global->io.dynfileqMaxSz, dynfile->size);\n\n    /* Sort it by coverage - put better coverage earlier in the list */\n    dynfile_t* iter = NULL;\n    TAILQ_FOREACH_HF (iter, &run->global->io.dynfileq, pointers) {\n        if (input_cmpCov(dynfile, iter)) {\n            TAILQ_INSERT_BEFORE(iter, dynfile, pointers);\n            break;\n        }\n    }\n    if (iter == NULL) {\n        TAILQ_INSERT_TAIL(&run->global->io.dynfileq, dynfile, pointers);\n    }\n\n    if (run->global->socketFuzzer.enabled) {\n        /* Don't add coverage data to files in socketFuzzer mode */\n        return;\n    }\n\n    const char* outDir =\n        run->global->io.outputDir ? run->global->io.outputDir : run->global->io.inputDir;\n    if (!input_writeCovFile(outDir, dynfile)) {\n        LOG_E(\"Couldn't save the coverage data to '%s'\", run->global->io.outputDir);\n    }\n\n    /* No need to add files to the new coverage dir, if it's not the main phase */\n    if (fuzz_getState(run->global) != _HF_STATE_DYNAMIC_MAIN) {\n        return;\n    }\n\n    ATOMIC_POST_INC(run->global->io.newUnitsAdded);\n\n    if (run->global->io.covDirNew && !input_writeCovFile(run->global->io.covDirNew, dynfile)) {\n        LOG_E(\"Couldn't save the new coverage data to '%s'\", run->global->io.covDirNew);\n    }\n}\n\nbool input_inDynamicCorpus(run_t* run, const char* fname, size_t len) {\n    MX_SCOPED_RWLOCK_WRITE(&run->global->mutex.dynfileq);\n\n    dynfile_t* iter = NULL;\n    TAILQ_FOREACH_HF (iter, &run->global->io.dynfileq, pointers) {\n        if (strncmp(iter->path, fname, PATH_MAX) == 0 && iter->size == len) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic inline int input_speedFactor(run_t* run, dynfile_t* dynfile) {\n    /* Slower the input, lower the chance of it being tested */\n    uint64_t avg_usecs_per_input =\n        ((uint64_t)(time(NULL) - run->global->timing.timeStart) * 1000000);\n    avg_usecs_per_input /= ATOMIC_GET(run->global->cnts.mutationsCnt);\n    avg_usecs_per_input /= run->global->threads.threadsMax;\n\n    /* Cap both vals to 1us-1s */\n    avg_usecs_per_input   = HF_CAP(avg_usecs_per_input, 1U, 1000000U);\n    uint64_t sample_usecs = HF_CAP(dynfile->timeExecUSecs, 1U, 1000000U);\n\n    if (sample_usecs >= avg_usecs_per_input) {\n        return (int)(sample_usecs / avg_usecs_per_input);\n    } else {\n        return -(int)(avg_usecs_per_input / sample_usecs);\n    }\n}\n\nstatic inline int input_skipFactor(run_t* run, dynfile_t* dynfile) {\n    int penalty = 0;\n\n#if 1\n    if (dynfile->timedout) {\n        penalty += 50;\n    }\n#endif\n\n#if 1\n    penalty -= HF_CAP(input_speedFactor(run, dynfile), -10, 10);\n#endif\n\n#if 1\n    {\n        /* Inputs with lower total coverage -> lower chance of being tested */\n        static const int scaleMap[200] = {\n            [95 ... 199] = -10,\n            [80 ... 94]  = -2,\n            [50 ... 79]  = 0,\n            [11 ... 49]  = 1,\n            [0 ... 10]   = 2,\n        };\n\n        uint64_t maxCov0 = ATOMIC_GET(run->global->feedback.maxCov[0]);\n        if (maxCov0) {\n            const unsigned percentile = (dynfile->cov[0] * 100) / maxCov0;\n            penalty += scaleMap[percentile];\n        }\n    }\n#endif\n\n#if 1\n    {\n        /* Older inputs -> lower chance of being tested */\n        static const int scaleMap[200] = {\n            [98 ... 199] = -20,\n            [91 ... 97]  = -2,\n            [81 ... 90]  = -1,\n            [71 ... 80]  = 0,\n            [41 ... 70]  = 1,\n            [0 ... 40]   = 2,\n        };\n\n        if (dynfile->phase == _HF_STATE_DYNAMIC_MAIN) {\n            const unsigned percentile = (dynfile->idx * 100) / run->global->io.dynfileqCnt;\n            penalty += scaleMap[percentile];\n        }\n    }\n#endif\n\n#if 1\n    {\n        /* If the input wasn't source of other inputs so far, make it less likely to be tested */\n        penalty += HF_CAP((2 - (int)dynfile->refs), -10, 2);\n    }\n#endif\n\n#if 1\n    {\n        /* Add penalty for the input being too big - 0 is for 1kB inputs */\n        if (dynfile->size > 0) {\n            penalty += HF_CAP(((int)util_Log2(dynfile->size) - 10), -5, 5);\n        }\n    }\n#endif\n\n    return penalty;\n}\n\nbool input_prepareDynamicInput(run_t* run, bool needs_mangle) {\n    if (ATOMIC_GET(run->global->io.dynfileqCnt) == 0) {\n        LOG_F(\"The dynamic file corpus is empty. This shouldn't happen\");\n    }\n\n    for (;;) {\n        MX_SCOPED_RWLOCK_WRITE(&run->global->mutex.dynfileq);\n\n        if (run->global->io.dynfileqCurrent == NULL) {\n            run->global->io.dynfileqCurrent = TAILQ_FIRST(&run->global->io.dynfileq);\n        }\n\n        if (run->triesLeft) {\n            run->triesLeft--;\n            break;\n        }\n\n        run->current                    = run->global->io.dynfileqCurrent;\n        run->global->io.dynfileqCurrent = TAILQ_NEXT(run->global->io.dynfileqCurrent, pointers);\n\n        int skip_factor = input_skipFactor(run, run->current);\n        if (skip_factor <= 0) {\n            run->triesLeft = -(skip_factor);\n            break;\n        }\n\n        if ((util_rnd64() % skip_factor) == 0) {\n            break;\n        }\n    }\n\n    input_setSize(run, run->current->size);\n    run->dynfile->idx           = run->current->idx;\n    run->dynfile->timeExecUSecs = run->current->timeExecUSecs;\n    run->dynfile->src           = run->current;\n    run->dynfile->refs          = 0;\n    run->dynfile->phase         = fuzz_getState(run->global);\n    run->dynfile->timedout      = run->current->timedout;\n    memcpy(run->dynfile->cov, run->current->cov, sizeof(run->dynfile->cov));\n    snprintf(run->dynfile->path, sizeof(run->dynfile->path), \"%s\", run->current->path);\n    memcpy(run->dynfile->data, run->current->data, run->current->size);\n\n    if (needs_mangle) {\n        mangle_mangleContent(run);\n    }\n\n    return true;\n}\n\nbool input_dynamicQueueGetNext(char fname[PATH_MAX], DIR* dynamicDirPtr, char* dynamicWorkDir) {\n    static pthread_mutex_t input_mutex = PTHREAD_MUTEX_INITIALIZER;\n    MX_SCOPED_LOCK(&input_mutex);\n\n    for (;;) {\n        errno                = 0;\n        struct dirent* entry = readdir(dynamicDirPtr);\n        if (entry == NULL && errno == EINTR) {\n            continue;\n        }\n        if (entry == NULL && errno != 0) {\n            PLOG_W(\"readdir_r('%s')\", dynamicWorkDir);\n            return false;\n        }\n        if (entry == NULL) {\n            return false;\n        }\n        char path[PATH_MAX];\n        snprintf(path, PATH_MAX, \"%s/%s\", dynamicWorkDir, entry->d_name);\n        struct stat st;\n        if (stat(path, &st) == -1) {\n            LOG_W(\"Couldn't stat() the '%s' file\", path);\n            continue;\n        }\n        if (!S_ISREG(st.st_mode)) {\n            LOG_D(\"'%s' is not a regular file, skipping\", path);\n            continue;\n        }\n\n        snprintf(fname, PATH_MAX, \"%s/%s\", dynamicWorkDir, entry->d_name);\n        return true;\n    }\n}\n\nvoid input_enqueueDynamicInputs(honggfuzz_t* hfuzz) {\n    char dynamicWorkDir[PATH_MAX];\n\n    snprintf(dynamicWorkDir, sizeof(dynamicWorkDir), \"%s\", hfuzz->io.dynamicInputDir);\n\n    int dynamicDirFd = TEMP_FAILURE_RETRY(open(dynamicWorkDir, O_DIRECTORY | O_RDONLY | O_CLOEXEC));\n    if (dynamicDirFd == -1) {\n        PLOG_W(\"open('%s', O_DIRECTORY|O_RDONLY|O_CLOEXEC)\", dynamicWorkDir);\n        return;\n    }\n\n    DIR* dynamicDirPtr;\n    if ((dynamicDirPtr = fdopendir(dynamicDirFd)) == NULL) {\n        PLOG_W(\"fdopendir(dir='%s', fd=%d)\", dynamicWorkDir, dynamicDirFd);\n        close(dynamicDirFd);\n        return;\n    }\n\n    char dynamicInputFileName[PATH_MAX];\n    for (;;) {\n        if (!input_dynamicQueueGetNext(dynamicInputFileName, dynamicDirPtr, dynamicWorkDir)) {\n            break;\n        }\n\n        int dynamicFileFd;\n        if ((dynamicFileFd = open(dynamicInputFileName, O_RDWR)) == -1) {\n            PLOG_E(\"Error opening dynamic input file: %s\", dynamicInputFileName);\n            continue;\n        }\n\n        /* Get file status. */\n        struct stat dynamicFileStat;\n        size_t      dynamicFileSz;\n\n        if (fstat(dynamicFileFd, &dynamicFileStat) == -1) {\n            PLOG_E(\"Error getting file status: %s\", dynamicInputFileName);\n            close(dynamicFileFd);\n            continue;\n        }\n\n        dynamicFileSz = dynamicFileStat.st_size;\n\n        uint8_t* dynamicFile = (uint8_t*)mmap(\n            NULL, dynamicFileSz, PROT_READ | PROT_WRITE, MAP_SHARED, dynamicFileFd, 0);\n\n        if (dynamicFile == MAP_FAILED) {\n            PLOG_E(\"Error mapping dynamic input file: %s\", dynamicInputFileName);\n            close(dynamicFileFd);\n            continue;\n        }\n\n        LOG_I(\"Loading dynamic input file: %s (%lu)\", dynamicInputFileName, dynamicFileSz);\n\n        run_t tmp_run;\n        tmp_run.global        = hfuzz;\n        dynfile_t tmp_dynfile = {\n            .size          = dynamicFileSz,\n            .cov           = {0xff, 0xff, 0xff, 0xff},\n            .idx           = 0,\n            .fd            = -1,\n            .timeExecUSecs = 1,\n            .path          = \"\",\n            .timedout      = false,\n            .data          = dynamicFile,\n        };\n        tmp_run.timeStartedUSecs = util_timeNowUSecs() - 1;\n        tmp_run.tmOutSignaled    = false;\n        memcpy(tmp_dynfile.path, dynamicInputFileName, PATH_MAX);\n        tmp_run.dynfile = &tmp_dynfile;\n        input_addDynamicInput(&tmp_run);\n        // input_addDynamicInput(hfuzz, dynamicFile, dynamicFileSz, (uint64_t[4]){0xff, 0xff, 0xff,\n        // 0xff}, dynamicInputFileName);\n\n        /* Unmap input file. */\n        if (munmap((void*)dynamicFile, dynamicFileSz) == -1) {\n            PLOG_E(\"Error unmapping input file!\");\n        }\n\n        /* Close input file. */\n        if (close(dynamicFileFd) == -1) {\n            PLOG_E(\"Error closing input file!\");\n        }\n\n        /* Remove enqueued file from the directory. */\n        unlink(dynamicInputFileName);\n    }\n    closedir(dynamicDirPtr);\n}\n\nconst uint8_t* input_getRandomInputAsBuf(run_t* run, size_t* len) {\n    if (run->global->feedback.dynFileMethod == _HF_DYNFILE_NONE) {\n        LOG_W(\n            \"The dynamic input queue is empty because no instrumentation mode (-x) was requested\");\n        *len = 0;\n        return NULL;\n    }\n\n    if (ATOMIC_GET(run->global->io.dynfileqCnt) == 0) {\n        *len = 0;\n        return NULL;\n    }\n\n    dynfile_t* current = NULL;\n    {\n        MX_SCOPED_RWLOCK_WRITE(&run->global->mutex.dynfileq);\n\n        if (run->global->io.dynfileq2Current == NULL) {\n            run->global->io.dynfileq2Current = TAILQ_FIRST(&run->global->io.dynfileq);\n        }\n\n        current                          = run->global->io.dynfileq2Current;\n        run->global->io.dynfileq2Current = TAILQ_NEXT(run->global->io.dynfileq2Current, pointers);\n    }\n\n    *len = current->size;\n    return current->data;\n}\n\nstatic bool input_shouldReadNewFile(run_t* run) {\n    if (fuzz_getState(run->global) != _HF_STATE_DYNAMIC_DRY_RUN) {\n        input_setSize(run, run->global->mutate.maxInputSz);\n        return true;\n    }\n\n    if (!run->staticFileTryMore) {\n        run->staticFileTryMore = true;\n        /* Start with 4 bytes, increase the size in following iterations */\n        input_setSize(run, HF_MIN(4U, run->global->mutate.maxInputSz));\n        return true;\n    }\n\n    /* Increase size of the current file by a factor of 2, and return it instead of a new file */\n    size_t newsz = run->dynfile->size * 2;\n    if (newsz >= run->global->mutate.maxInputSz) {\n        /* That's the largest size for this specific file that will be ever used */\n        newsz                  = run->global->mutate.maxInputSz;\n        run->staticFileTryMore = false;\n    }\n\n    input_setSize(run, newsz);\n    return false;\n}\n\nbool input_prepareStaticFile(run_t* run, bool rewind, bool needs_mangle) {\n    if (input_shouldReadNewFile(run)) {\n        for (;;) {\n            size_t flen;\n            if (!input_getNext(run, run->dynfile->path, &flen, /* rewind= */ rewind)) {\n                return false;\n            }\n            if (needs_mangle) {\n                break;\n            }\n            if (!input_inDynamicCorpus(run, run->dynfile->path, HF_MIN(flen, run->dynfile->size))) {\n                break;\n            }\n            LOG_D(\"Skipping '%s' (dynamic corpus size=%zu, file size=%zu) as it's already in the \"\n                  \"dynamic corpus\",\n                run->dynfile->path, run->dynfile->size, flen);\n        }\n        run->global->io.testedFileCnt++;\n    }\n\n    LOG_D(\"Reading '%s' (max size=%zu)\", run->dynfile->path, run->dynfile->size);\n\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", run->global->io.inputDir, run->dynfile->path);\n\n    ssize_t fileSz = files_readFileToBufMax(path, run->dynfile->data, run->dynfile->size);\n    if (fileSz < 0) {\n        LOG_E(\"Couldn't read contents of '%s'\", path);\n        return false;\n    }\n\n    if (run->staticFileTryMore && ((size_t)fileSz < run->dynfile->size)) {\n        /* The file is smaller than the requested size, no need to re-read it anymore */\n        run->staticFileTryMore = false;\n    }\n\n    input_setSize(run, fileSz);\n    util_memsetInline(run->dynfile->cov, '\\0', sizeof(run->dynfile->cov));\n    run->dynfile->idx      = 0;\n    run->dynfile->src      = NULL;\n    run->dynfile->refs     = 0;\n    run->dynfile->phase    = fuzz_getState(run->global);\n    run->dynfile->timedout = false;\n\n    if (needs_mangle) {\n        mangle_mangleContent(run);\n    }\n\n    return true;\n}\n\nbool input_removeStaticFile(const char* dir, const char* name) {\n    char path[PATH_MAX];\n    snprintf(path, sizeof(path), \"%s/%s\", dir, name);\n    if (unlink(path) == -1 && errno != EEXIST) {\n        PLOG_E(\"unlink('%s') failed\", path);\n        return false;\n    }\n    return true;\n}\n\nbool input_prepareExternalFile(run_t* run) {\n    snprintf(run->dynfile->path, sizeof(run->dynfile->path), \"[EXTERNAL]\");\n\n    int fd = files_writeBufToTmpFile(run->global->io.workDir, (const uint8_t*)\"\", 0, 0);\n    if (fd == -1) {\n        LOG_E(\"Couldn't write input file to a temporary buffer\");\n        return false;\n    }\n    defer {\n        close(fd);\n    };\n\n    char fname[PATH_MAX];\n    snprintf(fname, sizeof(fname), \"/dev/fd/%d\", fd);\n\n    const char* const argv[] = {run->global->exe.externalCommand, fname, NULL};\n    if (subproc_System(run, argv) != 0) {\n        LOG_E(\"Subprocess '%s' returned abnormally\", run->global->exe.externalCommand);\n        return false;\n    }\n    LOG_D(\"Subporcess '%s' finished with success\", run->global->exe.externalCommand);\n\n    input_setSize(run, run->global->mutate.maxInputSz);\n    ssize_t sz = files_readFromFdSeek(fd, run->dynfile->data, run->global->mutate.maxInputSz, 0);\n    if (sz == -1) {\n        LOG_E(\"Couldn't read file from fd=%d\", fd);\n        return false;\n    }\n\n    input_setSize(run, (size_t)sz);\n    return true;\n}\n\nbool input_postProcessFile(run_t* run, const char* cmd) {\n    int fd =\n        files_writeBufToTmpFile(run->global->io.workDir, run->dynfile->data, run->dynfile->size, 0);\n    if (fd == -1) {\n        LOG_E(\"Couldn't write input file to a temporary buffer\");\n        return false;\n    }\n    defer {\n        close(fd);\n    };\n\n    char fname[PATH_MAX];\n    snprintf(fname, sizeof(fname), \"/dev/fd/%d\", fd);\n\n    const char* const argv[] = {cmd, fname, NULL};\n    if (subproc_System(run, argv) != 0) {\n        LOG_E(\"Subprocess '%s' returned abnormally\", cmd);\n        return false;\n    }\n    LOG_D(\"Subporcess '%s' finished with success\", cmd);\n\n    input_setSize(run, run->global->mutate.maxInputSz);\n    ssize_t sz = files_readFromFdSeek(fd, run->dynfile->data, run->global->mutate.maxInputSz, 0);\n    if (sz == -1) {\n        LOG_E(\"Couldn't read file from fd=%d\", fd);\n        return false;\n    }\n\n    input_setSize(run, (size_t)sz);\n\n    return true;\n}\n"
        },
        {
          "name": "input.h",
          "type": "blob",
          "size": 2.380859375,
          "content": "/*\n *\n * honggfuzz - fetching input for fuzzing\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_INPUT_H_\n#define _HF_INPUT_H_\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\n#include \"honggfuzz.h\"\n\nextern void           input_setSize(run_t* run, size_t sz);\nextern bool           input_getDirStatsAndRewind(honggfuzz_t* hfuzz);\nextern bool           input_getNext(run_t* run, char fname[PATH_MAX], size_t* len, bool rewind);\nextern bool           input_init(honggfuzz_t* hfuzz);\nextern bool           input_parseDictionary(honggfuzz_t* hfuzz);\nextern void           input_freeDictionary(honggfuzz_t* hfuzz);\nextern bool           input_parseBlacklist(honggfuzz_t* hfuzz);\nextern bool           input_writeCovFile(const char* dir, dynfile_t* dynfile);\nextern void           input_addDynamicInput(run_t* run);\nextern bool           input_inDynamicCorpus(run_t* run, const char* fname, size_t len);\nextern void           input_renumerateInputs(honggfuzz_t* hfuzz);\nextern bool           input_prepareDynamicInput(run_t* run, bool needs_mangle);\nextern const uint8_t* input_getRandomInputAsBuf(run_t* run, size_t* len);\nextern bool           input_prepareStaticFile(run_t* run, bool rewind, bool needs_mangle);\nextern bool           input_removeStaticFile(const char* dir, const char* name);\nextern bool           input_prepareExternalFile(run_t* run);\nextern bool           input_postProcessFile(run_t* run, const char* cmd);\nextern bool           input_prepareDynamicFileForMinimization(run_t* run);\nextern bool           input_dynamicQueueGetNext(\n              char fname[PATH_MAX], DIR* dynamicDirPtr, char* dynamicWorkDir);\nextern void input_enqueueDynamicInputs(honggfuzz_t* hfuzz);\n\n#endif /* ifndef _HF_INPUT_H_ */\n"
        },
        {
          "name": "libhfcommon",
          "type": "tree",
          "content": null
        },
        {
          "name": "libhfnetdriver",
          "type": "tree",
          "content": null
        },
        {
          "name": "libhfuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux",
          "type": "tree",
          "content": null
        },
        {
          "name": "mac",
          "type": "tree",
          "content": null
        },
        {
          "name": "mangle.c",
          "type": "blob",
          "size": 28.9033203125,
          "content": "/*\n *\n * honggfuzz - run->dynfile->datafer mangling routines\n * -----------------------------------------\n *\n * Author:\n * Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include \"mangle.h\"\n\n#include <ctype.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <time.h>\n\n#include \"input.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n\nstatic inline size_t mangle_LenLeft(run_t* run, size_t off) {\n    if (off >= run->dynfile->size) {\n        LOG_F(\"Offset is too large: off:%zu >= len:%zu\", off, run->dynfile->size);\n    }\n    return (run->dynfile->size - off - 1);\n}\n\n/*\n * Get a random value <1:max>, but prefer smaller ones\n * Based on an idea by https://twitter.com/gamozolabs\n */\nstatic inline size_t mangle_getLen(size_t max) {\n    if (max > _HF_INPUT_MAX_SIZE) {\n        LOG_F(\"max (%zu) > _HF_INPUT_MAX_SIZE (%zu)\", max, (size_t)_HF_INPUT_MAX_SIZE);\n    }\n    if (max == 0) {\n        LOG_F(\"max == 0\");\n    }\n    if (max == 1) {\n        return 1;\n    }\n\n    /* Give 50% chance the the uniform distribution */\n    if (util_rnd64() & 1) {\n        return (size_t)util_rndGet(1, max);\n    }\n\n    /* effectively exprand() */\n    return (size_t)util_rndGet(1, util_rndGet(1, max));\n}\n\n/* Prefer smaller values here, so use mangle_getLen() */\nstatic inline size_t mangle_getOffSet(run_t* run) {\n    return mangle_getLen(run->dynfile->size) - 1;\n}\n\n/* Offset which can be equal to the file size */\nstatic inline size_t mangle_getOffSetPlus1(run_t* run) {\n    size_t reqlen = HF_MIN(run->dynfile->size + 1, _HF_INPUT_MAX_SIZE);\n    return mangle_getLen(reqlen) - 1;\n}\n\nstatic inline void mangle_Move(run_t* run, size_t off_from, size_t off_to, size_t len) {\n    if (off_from >= run->dynfile->size) {\n        return;\n    }\n    if (off_to >= run->dynfile->size) {\n        return;\n    }\n    if (off_from == off_to) {\n        return;\n    }\n\n    size_t len_from = run->dynfile->size - off_from;\n    len             = HF_MIN(len, len_from);\n\n    size_t len_to = run->dynfile->size - off_to;\n    len           = HF_MIN(len, len_to);\n\n    memmove(&run->dynfile->data[off_to], &run->dynfile->data[off_from], len);\n}\n\nstatic inline void mangle_Overwrite(\n    run_t* run, size_t off, const uint8_t* src, size_t len, bool printable) {\n    if (len == 0) {\n        return;\n    }\n    size_t maxToCopy = run->dynfile->size - off;\n    if (len > maxToCopy) {\n        len = maxToCopy;\n    }\n\n    memmove(&run->dynfile->data[off], src, len);\n    if (printable) {\n        util_turnToPrintable(&run->dynfile->data[off], len);\n    }\n}\n\nstatic inline size_t mangle_Inflate(run_t* run, size_t off, size_t len, bool printable) {\n    if (run->dynfile->size >= run->global->mutate.maxInputSz) {\n        return 0;\n    }\n    if (len > (run->global->mutate.maxInputSz - run->dynfile->size)) {\n        len = run->global->mutate.maxInputSz - run->dynfile->size;\n    }\n\n    input_setSize(run, run->dynfile->size + len);\n    mangle_Move(run, off, off + len, run->dynfile->size);\n    if (printable) {\n        memset(&run->dynfile->data[off], ' ', len);\n    }\n\n    return len;\n}\n\nstatic inline void mangle_Insert(\n    run_t* run, size_t off, const uint8_t* val, size_t len, bool printable) {\n    len = mangle_Inflate(run, off, len, printable);\n    mangle_Overwrite(run, off, val, len, printable);\n}\n\nstatic inline void mangle_UseValue(run_t* run, const uint8_t* val, size_t len, bool printable) {\n    if (util_rnd64() & 1) {\n        mangle_Overwrite(run, mangle_getOffSet(run), val, len, printable);\n    } else {\n        mangle_Insert(run, mangle_getOffSetPlus1(run), val, len, printable);\n    }\n}\n\nstatic inline void mangle_UseValueAt(\n    run_t* run, size_t off, const uint8_t* val, size_t len, bool printable) {\n    if (util_rnd64() & 1) {\n        mangle_Overwrite(run, off, val, len, printable);\n    } else {\n        mangle_Insert(run, off, val, len, printable);\n    }\n}\n\nstatic void mangle_MemSwap(run_t* run, bool printable HF_ATTR_UNUSED) {\n    /* No big deal if those two are overlapping */\n    size_t off1    = mangle_getOffSet(run);\n    size_t maxlen1 = run->dynfile->size - off1;\n    size_t off2    = mangle_getOffSet(run);\n    size_t maxlen2 = run->dynfile->size - off2;\n    size_t len     = mangle_getLen(HF_MIN(maxlen1, maxlen2));\n\n    if (off1 == off2) {\n        return;\n    }\n\n    for (size_t i = 0; i < (len / 2); i++) {\n        /*\n         * First - from the head, next from the tail. Don't worry about layout of the overlapping\n         * part - there's no good solution to that, and it can be left somewhat scrambled,\n         * while still preserving the entropy\n         */\n        const uint8_t tmp1                       = run->dynfile->data[off2 + i];\n        run->dynfile->data[off2 + i]             = run->dynfile->data[off1 + i];\n        run->dynfile->data[off1 + i]             = tmp1;\n        const uint8_t tmp2                       = run->dynfile->data[off2 + (len - 1) - i];\n        run->dynfile->data[off2 + (len - 1) - i] = run->dynfile->data[off1 + (len - 1) - i];\n        run->dynfile->data[off1 + (len - 1) - i] = tmp2;\n    }\n}\n\nstatic void mangle_MemCopy(run_t* run, bool printable HF_ATTR_UNUSED) {\n    size_t off = mangle_getOffSet(run);\n    size_t len = mangle_getLen(run->dynfile->size - off);\n\n    /* Use a temp buf, as Insert/Inflate can change source bytes */\n    uint8_t* tmpbuf = (uint8_t*)util_Malloc(len);\n    defer {\n        free(tmpbuf);\n    };\n    memmove(tmpbuf, &run->dynfile->data[off], len);\n\n    mangle_UseValue(run, tmpbuf, len, printable);\n}\n\nstatic void mangle_Bytes(run_t* run, bool printable) {\n    uint16_t buf;\n    if (printable) {\n        util_rndBufPrintable((uint8_t*)&buf, sizeof(buf));\n    } else {\n        buf = util_rnd64();\n    }\n\n    /* Overwrite with random 1-2-byte values */\n    size_t toCopy = util_rndGet(1, 2);\n    mangle_UseValue(run, (const uint8_t*)&buf, toCopy, printable);\n}\n\nstatic void mangle_ByteRepeat(run_t* run, bool printable) {\n    size_t off     = mangle_getOffSet(run);\n    size_t destOff = off + 1;\n    size_t maxSz   = run->dynfile->size - destOff;\n\n    /* No space to repeat */\n    if (!maxSz) {\n        mangle_Bytes(run, printable);\n        return;\n    }\n\n    size_t len = mangle_getLen(maxSz);\n    if (util_rnd64() & 0x1) {\n        len = mangle_Inflate(run, destOff, len, printable);\n    }\n    memset(&run->dynfile->data[destOff], run->dynfile->data[off], len);\n}\n\nstatic void mangle_Bit(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    run->dynfile->data[off] ^= (uint8_t)(1U << util_rndGet(0, 7));\n    if (printable) {\n        util_turnToPrintable(&(run->dynfile->data[off]), 1);\n    }\n}\n\nstatic const struct {\n    const uint8_t val[8];\n    const size_t  size;\n} mangleMagicVals[] = {\n    /* 1B - No endianness */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x0A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x0B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x0C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x0D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x0F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x7E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x7F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    {\"\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 1},\n    /* 2B - NE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x80\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFF\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    /* 2B - BE */\n    {\"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x09\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x0A\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x0B\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x0C\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x0D\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x0F\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x7E\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x7F\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x81\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x7E\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x7F\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x80\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFF\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    /* 2B - LE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x0A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x0B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x0C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x0D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x0F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x7E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x7F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFF\\x7E\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFF\\x7F\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\x01\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    {\"\\xFE\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\", 2},\n    /* 4B - NE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x01\\x01\\x01\\x01\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x80\\x80\\x80\\x80\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFF\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\", 4},\n    /* 4B - BE */\n    {\"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x0A\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x0B\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x0C\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x0D\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x0E\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x0F\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x7E\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x7F\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x81\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\xC0\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\xFE\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\xFF\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x7E\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x7F\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x80\\x00\\x00\\x01\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFF\\xFF\\xFF\\xFE\\x00\\x00\\x00\\x00\", 4},\n    /* 4B - LE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x0A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x0B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x0C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x0D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x0F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x7E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x7F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFF\\xFF\\xFF\\x7E\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFF\\xFF\\xFF\\x7F\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", 4},\n    {\"\\x01\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", 4},\n    {\"\\xFE\\xFF\\xFF\\xFF\\x00\\x00\\x00\\x00\", 4},\n    /* 8B - NE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\", 8},\n    {\"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\", 8},\n    {\"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 8},\n    /* 8B - BE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x06\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0A\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0B\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0C\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0D\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0E\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0F\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7E\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x7F\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x81\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xC0\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFE\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\", 8},\n    {\"\\x7E\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 8},\n    {\"\\x7F\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 8},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", 8},\n    {\"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFE\", 8},\n    /* 8B - LE */\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x0A\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x0B\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x0C\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x0D\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x0F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x7E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x7F\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\x81\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\xC0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\xFE\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\xFF\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", 8},\n    {\"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x7E\", 8},\n    {\"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\x7F\", 8},\n    {\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\", 8},\n    {\"\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x80\", 8},\n    {\"\\xFE\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\", 8},\n};\n\nstatic void mangle_Magic(run_t* run, bool printable) {\n    uint64_t choice = util_rndGet(0, ARRAYSIZE(mangleMagicVals) - 1);\n    mangle_UseValue(run, mangleMagicVals[choice].val, mangleMagicVals[choice].size, printable);\n}\n\nstatic void mangle_StaticDict(run_t* run, bool printable) {\n    if (run->global->mutate.dictionaryCnt == 0) {\n        mangle_Bytes(run, printable);\n        return;\n    }\n    uint64_t choice = util_rndGet(0, run->global->mutate.dictionaryCnt - 1);\n    mangle_UseValue(run, run->global->mutate.dictionary[choice].val,\n        run->global->mutate.dictionary[choice].len, printable);\n}\n\nstatic inline const uint8_t* mangle_FeedbackDict(run_t* run, size_t* len) {\n    if (!run->global->feedback.cmpFeedback) {\n        return NULL;\n    }\n    cmpfeedback_t* cmpf = run->global->feedback.cmpFeedbackMap;\n    uint32_t       cnt  = ATOMIC_GET(cmpf->cnt);\n    if (cnt == 0) {\n        return NULL;\n    }\n    if (cnt > ARRAYSIZE(cmpf->valArr)) {\n        cnt = ARRAYSIZE(cmpf->valArr);\n    }\n    uint32_t choice = util_rndGet(0, cnt - 1);\n    *len            = (size_t)ATOMIC_GET(cmpf->valArr[choice].len);\n    if (*len == 0) {\n        return NULL;\n    }\n    return cmpf->valArr[choice].val;\n}\n\nstatic void mangle_ConstFeedbackDict(run_t* run, bool printable) {\n    size_t         len;\n    const uint8_t* val = mangle_FeedbackDict(run, &len);\n    if (val == NULL) {\n        mangle_Bytes(run, printable);\n        return;\n    }\n    mangle_UseValue(run, val, len, printable);\n}\n\nstatic void mangle_MemSet(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    size_t len = mangle_getLen(run->dynfile->size - off);\n    int    val = printable ? (int)util_rndPrintable() : (int)util_rndGet(0, UINT8_MAX);\n\n    if (util_rnd64() & 1) {\n        len = mangle_Inflate(run, off, len, printable);\n    }\n\n    memset(&run->dynfile->data[off], val, len);\n}\n\nstatic void mangle_MemClr(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    size_t len = mangle_getLen(run->dynfile->size - off);\n    int    val = printable ? ' ' : 0;\n\n    if (util_rnd64() & 1) {\n        len = mangle_Inflate(run, off, len, printable);\n    }\n\n    memset(&run->dynfile->data[off], val, len);\n}\n\nstatic void mangle_RandomBuf(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    size_t len = mangle_getLen(run->dynfile->size - off);\n\n    if (util_rnd64() & 1) {\n        len = mangle_Inflate(run, off, len, printable);\n    }\n\n    if (printable) {\n        util_rndBufPrintable(&run->dynfile->data[off], len);\n    } else {\n        util_rndBuf(&run->dynfile->data[off], len);\n    }\n}\n\nstatic inline void mangle_AddSubWithRange(\n    run_t* run, size_t off, size_t varLen, uint64_t range, bool printable) {\n    int64_t delta = (int64_t)util_rndGet(0, range * 2) - (int64_t)range;\n\n    switch (varLen) {\n    case 1: {\n        run->dynfile->data[off] += delta;\n        break;\n    }\n    case 2: {\n        int16_t val;\n        util_memcpyInline(&val, &run->dynfile->data[off], sizeof(val));\n        if (util_rnd64() & 0x1) {\n            val += delta;\n        } else {\n            /* Foreign endianess */\n            val = __builtin_bswap16(val);\n            val += delta;\n            val = __builtin_bswap16(val);\n        }\n        mangle_Overwrite(run, off, (uint8_t*)&val, varLen, printable);\n        break;\n    }\n    case 4: {\n        int32_t val;\n        util_memcpyInline(&val, &run->dynfile->data[off], sizeof(val));\n        if (util_rnd64() & 0x1) {\n            val += delta;\n        } else {\n            /* Foreign endianess */\n            val = __builtin_bswap32(val);\n            val += delta;\n            val = __builtin_bswap32(val);\n        }\n        mangle_Overwrite(run, off, (uint8_t*)&val, varLen, printable);\n        break;\n    }\n    case 8: {\n        int64_t val;\n        util_memcpyInline(&val, &run->dynfile->data[off], sizeof(val));\n        if (util_rnd64() & 0x1) {\n            val += delta;\n        } else {\n            /* Foreign endianess */\n            val = __builtin_bswap64(val);\n            val += delta;\n            val = __builtin_bswap64(val);\n        }\n        mangle_Overwrite(run, off, (uint8_t*)&val, varLen, printable);\n        break;\n    }\n    default: {\n        LOG_F(\"Unknown variable length size: %zu\", varLen);\n    }\n    }\n}\n\nstatic void mangle_AddSub(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n\n    /* 1,2,4,8 */\n    size_t varLen = 1U << util_rndGet(0, 3);\n    if ((run->dynfile->size - off) < varLen) {\n        varLen = 1;\n    }\n\n    uint64_t range;\n    switch (varLen) {\n    case 1:\n        range = 16;\n        break;\n    case 2:\n        range = 4096;\n        break;\n    case 4:\n        range = 1048576;\n        break;\n    case 8:\n        range = 268435456;\n        break;\n    default:\n        LOG_F(\"Invalid operand size: %zu\", varLen);\n    }\n\n    mangle_AddSubWithRange(run, off, varLen, range, printable);\n}\n\nstatic void mangle_IncByte(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    if (printable) {\n        run->dynfile->data[off] = (run->dynfile->data[off] - 32 + 1) % 95 + 32;\n    } else {\n        run->dynfile->data[off] += (uint8_t)1UL;\n    }\n}\n\nstatic void mangle_DecByte(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    if (printable) {\n        run->dynfile->data[off] = (run->dynfile->data[off] - 32 + 94) % 95 + 32;\n    } else {\n        run->dynfile->data[off] -= (uint8_t)1UL;\n    }\n}\n\nstatic void mangle_NegByte(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    if (printable) {\n        run->dynfile->data[off] = 94 - (run->dynfile->data[off] - 32) + 32;\n    } else {\n        run->dynfile->data[off] = ~(run->dynfile->data[off]);\n    }\n}\n\nstatic void mangle_Expand(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n    size_t len;\n    if (util_rnd64() % 16) {\n        len = mangle_getLen(HF_MIN(16, run->global->mutate.maxInputSz - off));\n    } else {\n        len = mangle_getLen(run->global->mutate.maxInputSz - off);\n    }\n\n    mangle_Inflate(run, off, len, printable);\n}\n\nstatic void mangle_Shrink(run_t* run, bool printable HF_ATTR_UNUSED) {\n    if (run->dynfile->size <= 2U) {\n        return;\n    }\n\n    size_t off_start = mangle_getOffSet(run);\n    size_t len       = mangle_LenLeft(run, off_start);\n    if (len == 0) {\n        return;\n    }\n    if (util_rnd64() % 16) {\n        len = mangle_getLen(HF_MIN(16, len));\n    } else {\n        len = mangle_getLen(len);\n    }\n    size_t off_end     = off_start + len;\n    size_t len_to_move = run->dynfile->size - off_end;\n\n    mangle_Move(run, off_end, off_start, len_to_move);\n    input_setSize(run, run->dynfile->size - len);\n}\n\nstatic void mangle_ASCIINum(run_t* run, bool printable) {\n    size_t len = util_rndGet(2, 8);\n\n    char buf[20];\n    snprintf(buf, sizeof(buf), \"%-19\" PRId64, (int64_t)util_rnd64());\n\n    mangle_UseValue(run, (const uint8_t*)buf, len, printable);\n}\n\nstatic void mangle_ASCIINumChange(run_t* run, bool printable) {\n    size_t off = mangle_getOffSet(run);\n\n    /* Find a digit */\n    for (; off < run->dynfile->size; off++) {\n        if (isdigit(run->dynfile->data[off])) {\n            break;\n        }\n    }\n    size_t left = run->dynfile->size - off;\n    if (left == 0) {\n        return;\n    }\n\n    size_t   len = 0;\n    uint64_t val = 0;\n    /* 20 is maximum lenght of a string representing a 64-bit unsigned value */\n    for (len = 0; (len < 20) && (len < left); len++) {\n        char c = run->dynfile->data[off + len];\n        if (!isdigit(c)) {\n            break;\n        }\n        val *= 10;\n        val += (c - '0');\n    }\n\n    switch (util_rndGet(0, 7)) {\n    case 0:\n        val++;\n        break;\n    case 1:\n        val--;\n        break;\n    case 2:\n        val *= 2;\n        break;\n    case 3:\n        val /= 2;\n        break;\n    case 4:\n        val = util_rnd64();\n        break;\n    case 5:\n        val += util_rndGet(1, 256);\n        break;\n    case 6:\n        val -= util_rndGet(1, 256);\n        break;\n    case 7:\n        val = ~(val);\n        break;\n    default:\n        LOG_F(\"Invalid choice\");\n    };\n\n    char buf[20];\n    snprintf(buf, sizeof(buf), \"%-19\" PRIu64, val);\n\n    mangle_UseValueAt(run, off, (const uint8_t*)buf, len, printable);\n}\n\nstatic void mangle_Splice(run_t* run, bool printable) {\n    if (run->global->feedback.dynFileMethod == _HF_DYNFILE_NONE) {\n        mangle_Bytes(run, printable);\n        return;\n    }\n\n    size_t         sz  = 0;\n    const uint8_t* buf = input_getRandomInputAsBuf(run, &sz);\n    if (!buf) {\n        LOG_E(\"input_getRandomInputAsBuf() returned no input\");\n        mangle_Bytes(run, printable);\n        return;\n    }\n    if (!sz) {\n        mangle_Bytes(run, printable);\n        return;\n    }\n\n    size_t remoteOff = mangle_getLen(sz) - 1;\n    size_t len       = mangle_getLen(sz - remoteOff);\n    mangle_UseValue(run, &buf[remoteOff], len, printable);\n}\n\nstatic void mangle_Resize(run_t* run, bool printable) {\n    ssize_t oldsz = run->dynfile->size;\n    ssize_t newsz = 0;\n\n    uint64_t choice = util_rndGet(0, 32);\n    switch (choice) {\n    case 0: /* Set new size arbitrarily */\n        newsz = (ssize_t)util_rndGet(1, run->global->mutate.maxInputSz);\n        break;\n    case 1 ... 4: /* Increase size by a small value */\n        newsz = oldsz + (ssize_t)util_rndGet(0, 8);\n        break;\n    case 5: /* Increase size by a larger value */\n        newsz = oldsz + (ssize_t)util_rndGet(9, 128);\n        break;\n    case 6 ... 9: /* Decrease size by a small value */\n        newsz = oldsz - (ssize_t)util_rndGet(0, 8);\n        break;\n    case 10: /* Decrease size by a larger value */\n        newsz = oldsz - (ssize_t)util_rndGet(9, 128);\n        break;\n    case 11 ... 32: /* Do nothing */\n        newsz = oldsz;\n        break;\n    default:\n        LOG_F(\"Illegal value from util_rndGet: %\" PRIu64, choice);\n        break;\n    }\n    if (newsz < 1) {\n        newsz = 1;\n    }\n    if (newsz > (ssize_t)run->global->mutate.maxInputSz) {\n        newsz = run->global->mutate.maxInputSz;\n    }\n\n    input_setSize(run, (size_t)newsz);\n    if (newsz > oldsz) {\n        if (printable) {\n            memset(&run->dynfile->data[oldsz], ' ', newsz - oldsz);\n        }\n    }\n}\n\nvoid mangle_mangleContent(run_t* run) {\n    static void (*const mangleFuncs[])(run_t* run, bool printable) = {\n        mangle_Shrink,\n        mangle_Expand,\n        mangle_Bit,\n        mangle_IncByte,\n        mangle_DecByte,\n        mangle_NegByte,\n        mangle_AddSub,\n        mangle_MemSet,\n        mangle_MemClr,\n        mangle_MemSwap,\n        mangle_MemCopy,\n        mangle_Bytes,\n        mangle_ASCIINum,\n        mangle_ASCIINumChange,\n        mangle_ByteRepeat,\n        mangle_Magic,\n        mangle_StaticDict,\n        mangle_ConstFeedbackDict,\n        mangle_RandomBuf,\n        mangle_Splice,\n    };\n\n    if (run->mutationsPerRun == 0U) {\n        return;\n    }\n    if (run->dynfile->size == 0U) {\n        mangle_Resize(run, /* printable= */ run->global->cfg.only_printable);\n    }\n\n    const uint64_t changesCnt = util_rndGet(1, run->global->mutate.mutationsPerRun);\n\n    /* If last coverage acquisition was more than 5 secs ago, use splicing more frequently */\n    if ((time(NULL) - ATOMIC_GET(run->global->timing.lastCovUpdate)) > 5) {\n        if (util_rnd64() & 0x1) {\n            mangle_Splice(run, run->global->cfg.only_printable);\n        }\n    }\n\n    for (uint64_t x = 0; x < changesCnt; x++) {\n        if (run->global->feedback.cmpFeedback && (util_rnd64() & 0x1)) {\n            /*\n             * mangle_ConstFeedbackDict() is quite powerful if the dynamic feedback dictionary\n             * exists. If so, give it 50% chance of being used among all mangling functions.\n             */\n            mangle_ConstFeedbackDict(run, /* printable= */ run->global->cfg.only_printable);\n        } else {\n            uint64_t choice = util_rndGet(0, ARRAYSIZE(mangleFuncs) - 1);\n            mangleFuncs[choice](run, /* printable= */ run->global->cfg.only_printable);\n        }\n    }\n\n    wmb();\n}\n"
        },
        {
          "name": "mangle.h",
          "type": "blob",
          "size": 0.8671875,
          "content": "/*\n *\n * honggfuzz - buffer mangling routines\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_MANGLE_H_\n#define _HF_MANGLE_H_\n\n#include \"honggfuzz.h\"\n\nextern void mangle_mangleContent(run_t* run);\n\n#endif\n"
        },
        {
          "name": "netbsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "patches",
          "type": "tree",
          "content": null
        },
        {
          "name": "posix",
          "type": "tree",
          "content": null
        },
        {
          "name": "qemu_mode",
          "type": "tree",
          "content": null
        },
        {
          "name": "report.c",
          "type": "blob",
          "size": 6.009765625,
          "content": "/*\n *\n * honggfuzz - reporting\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include \"report.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdio.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n\nstatic int reportFD = -1;\n\n#if defined(_HF_ARCH_LINUX)\nstatic void report_printdynFileMethod(run_t* run) {\n    dprintf(reportFD, \" dynFileMethod   : \");\n    if (run->global->feedback.dynFileMethod == 0)\n        dprintf(reportFD, \"NONE\\n\");\n    else {\n        if (run->global->feedback.dynFileMethod & _HF_DYNFILE_INSTR_COUNT)\n            dprintf(reportFD, \"INSTR_COUNT \");\n        if (run->global->feedback.dynFileMethod & _HF_DYNFILE_BRANCH_COUNT)\n            dprintf(reportFD, \"BRANCH_COUNT \");\n        if (run->global->feedback.dynFileMethod & _HF_DYNFILE_BTS_EDGE)\n            dprintf(reportFD, \"BTS_EDGE_COUNT \");\n        if (run->global->feedback.dynFileMethod & _HF_DYNFILE_IPT_BLOCK)\n            dprintf(reportFD, \"IPT_BLOCK_COUNT \");\n\n        dprintf(reportFD, \"\\n\");\n    }\n}\n#endif\n\nstatic void report_printTargetCmd(run_t* run) {\n    dprintf(reportFD, \" fuzzTarget      : \");\n    for (int x = 0; run->global->exe.cmdline[x]; x++) {\n        dprintf(reportFD, \"%s \", run->global->exe.cmdline[x]);\n    }\n    dprintf(reportFD, \"\\n\");\n}\n\nvoid report_saveReport(run_t* run) {\n    if (run->report[0] == '\\0') {\n        return;\n    }\n\n    MX_SCOPED_LOCK(&run->global->mutex.report);\n\n    if (reportFD == -1) {\n        char reportFName[PATH_MAX];\n        if (run->global->cfg.reportFile == NULL) {\n            snprintf(reportFName, sizeof(reportFName), \"%s/%s\", run->global->io.workDir,\n                _HF_REPORT_FILE);\n        } else {\n            snprintf(reportFName, sizeof(reportFName), \"%s\", run->global->cfg.reportFile);\n        }\n\n        reportFD =\n            TEMP_FAILURE_RETRY(open(reportFName, O_WRONLY | O_CREAT | O_APPEND | O_CLOEXEC, 0644));\n        if (reportFD == -1) {\n            PLOG_F(\"Couldn't open('%s') for writing\", reportFName);\n        }\n    }\n\n    char localtmstr[HF_STR_LEN];\n    util_getLocalTime(\"%F.%H:%M:%S\", localtmstr, sizeof(localtmstr), time(NULL));\n\n    dprintf(reportFD,\n        \"=====================================================================\\n\"\n        \"TIME: %s\\n\"\n        \"=====================================================================\\n\"\n        \"FUZZER ARGS:\\n\"\n        \" mutationsPerRun : %u\\n\"\n        \" externalCmd     : %s\\n\"\n        \" fuzzStdin       : %s\\n\"\n        \" timeout         : %ld (sec)\\n\"\n#if defined(_HF_ARCH_LINUX) || defined(_HF_ARCH_NETBSD)\n        \" ignoreAddr      : %p\\n\"\n#endif\n        \" ASLimit         : %\" PRIu64 \" (MiB)\\n\"\n        \" RSSLimit        : %\" PRIu64 \" (MiB)\\n\"\n        \" DATALimit       : %\" PRIu64 \" (MiB)\\n\"\n        \" wordlistFile    : %s\\n\",\n        localtmstr, run->global->mutate.mutationsPerRun,\n        run->global->exe.externalCommand == NULL ? \"NULL\" : run->global->exe.externalCommand,\n        run->global->exe.fuzzStdin ? \"TRUE\" : \"FALSE\", (long)run->global->timing.tmOut,\n#if defined(_HF_ARCH_LINUX)\n        run->global->arch_linux.ignoreAddr,\n#elif defined(_HF_ARCH_NETBSD)\n        run->global->arch_netbsd.ignoreAddr,\n#endif\n        run->global->exe.asLimit, run->global->exe.rssLimit, run->global->exe.dataLimit,\n        run->global->mutate.dictionaryFile == NULL ? \"NULL\" : run->global->mutate.dictionaryFile);\n\n#if defined(_HF_ARCH_LINUX)\n    report_printdynFileMethod(run);\n#endif\n\n    report_printTargetCmd(run);\n\n    dprintf(reportFD,\n        \"%s\"\n        \"=====================================================================\\n\",\n        run->report);\n}\n\nvoid report_appendReport(pid_t pid, run_t* run, funcs_t* funcs, size_t funcCnt, uint64_t pc,\n    uint64_t crashAddr, int signo, const char* instr, const char description[HF_STR_LEN]) {\n    util_ssnprintf(run->report, sizeof(run->report), \"CRASH:\\n\");\n    util_ssnprintf(run->report, sizeof(run->report), \"DESCRIPTION: %s\\n\", description);\n    util_ssnprintf(run->report, sizeof(run->report), \"ORIG_FNAME: %s\\n\", run->dynfile->path);\n    util_ssnprintf(run->report, sizeof(run->report), \"FUZZ_FNAME: %s\\n\", run->crashFileName);\n    util_ssnprintf(run->report, sizeof(run->report), \"PID: %d\\n\", (int)pid);\n    util_ssnprintf(\n        run->report, sizeof(run->report), \"SIGNAL: %s (%d)\\n\", util_sigName(signo), signo);\n    util_ssnprintf(run->report, sizeof(run->report), \"PC: 0x%\" PRIx64 \"\\n\", pc);\n    util_ssnprintf(run->report, sizeof(run->report), \"FAULT ADDRESS: 0x%\" PRIx64 \"\\n\", crashAddr);\n    util_ssnprintf(run->report, sizeof(run->report), \"INSTRUCTION: %s\\n\", instr);\n    util_ssnprintf(\n        run->report, sizeof(run->report), \"STACK HASH: %016\" PRIx64 \"\\n\", run->backtrace);\n    util_ssnprintf(run->report, sizeof(run->report), \"STACK:\\n\");\n    for (size_t i = 0; i < funcCnt; i++) {\n        util_ssnprintf(run->report, sizeof(run->report), \" <0x%016tx> \", (uintptr_t)funcs[i].pc);\n        util_ssnprintf(run->report, sizeof(run->report), \"[func:%s file:%s line:%zu module:%s]\\n\",\n            funcs[i].func, funcs[i].file, funcs[i].line, funcs[i].module);\n    }\n\n// libunwind is not working for 32bit targets in 64bit systems\n#if defined(__aarch64__)\n    if (funcCnt == 0) {\n        util_ssnprintf(run->report, sizeof(run->report),\n            \" !ERROR: If 32bit fuzz target\"\n            \" in aarch64 system, try ARM 32bit build\\n\");\n    }\n#endif\n\n    return;\n}\n"
        },
        {
          "name": "report.h",
          "type": "blob",
          "size": 1.109375,
          "content": "/*\n *\n * honggfuzz - reporting\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_REPORT_H_\n#define _HF_REPORT_H_\n\n#include <stdint.h>\n\n#include \"honggfuzz.h\"\n#include \"libhfcommon/util.h\"\n#include \"sanitizers.h\"\n\nextern void report_saveReport(run_t* run);\nextern void report_appendReport(pid_t pid, run_t* run, funcs_t* funcs, size_t funcCnt, uint64_t pc,\n    uint64_t crashAddr, int signo, const char* instr, const char description[HF_STR_LEN]);\n\n#endif\n"
        },
        {
          "name": "sanitizers.c",
          "type": "blob",
          "size": 12.13671875,
          "content": "#include \"sanitizers.h\"\n\n#include <ctype.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"cmdline.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n\n/*\n * Common sanitizer flags if --sanitizers is enabled\n */\n#define kSAN_COMMON                                                                                \\\n    \"symbolize=1:\"                                                                                 \\\n    \"detect_leaks=0:\"                                                                              \\\n    \"disable_coredump=0:\"                                                                          \\\n    \"detect_odr_violation=0:\"                                                                      \\\n    \"allocator_may_return_null=1:\"                                                                 \\\n    \"allow_user_segv_handler=0:\"                                                                   \\\n    \"handle_segv=2:\"                                                                               \\\n    \"handle_sigbus=2:\"                                                                             \\\n    \"handle_abort=2:\"                                                                              \\\n    \"handle_sigill=2:\"                                                                             \\\n    \"handle_sigfpe=2:\"                                                                             \\\n    \"abort_on_error=1\"\n\n/* --{ ASan }-- */\n/*\n * Sanitizer specific flags (notice that if enabled 'abort_on_error' has priority\n * over exitcode')\n */\n#define kASAN_OPTS kSAN_COMMON\n\n/* --{ UBSan }-- */\n#define kUBSAN_OPTS kSAN_COMMON\n\n/* --{ MSan }-- */\n#define kMSAN_OPTS kSAN_COMMON \":wrap_signals=0:print_stats=1\"\n\n/* --{ LSan }-- */\n#define kLSAN_OPTS kSAN_COMMON\n\n/* If no sanitzer support was requested, simply abort() on errors */\n#define kSAN_REGULAR                                                                               \\\n    \"symbolize=1:\"                                                                                 \\\n    \"detect_leaks=0:\"                                                                              \\\n    \"disable_coredump=0:\"                                                                          \\\n    \"detect_odr_violation=0:\"                                                                      \\\n    \"allocator_may_return_null=1:\"                                                                 \\\n    \"allow_user_segv_handler=1:\"                                                                   \\\n    \"handle_segv=0:\"                                                                               \\\n    \"handle_sigbus=0:\"                                                                             \\\n    \"handle_abort=0:\"                                                                              \\\n    \"handle_sigill=0:\"                                                                             \\\n    \"handle_sigfpe=0:\"                                                                             \\\n    \"abort_on_error=1\"\n\nstatic void sanitizers_AddFlag(honggfuzz_t* hfuzz, const char* env, const char* val) {\n    if (getenv(env)) {\n        LOG_W(\"The '%s' envar is already set. Not overriding it!\", env);\n        return;\n    }\n\n    char buf[4096] = {};\n    if (hfuzz->sanitizer.enable) {\n        snprintf(buf, sizeof(buf), \"%s=%s:log_path=%s/%s\", env, val, hfuzz->io.workDir, kLOGPREFIX);\n    } else {\n        snprintf(buf, sizeof(buf), \"%s=%s:log_path=%s/%s\", env, kSAN_REGULAR, hfuzz->io.workDir,\n            kLOGPREFIX);\n    }\n    /*\n     * It will make ASAN to start background thread to check RSS mem use, which\n     * will prevent the NetDrvier from using unshare(CLONE_NEWNET), which cannot\n     * be used in multi-threaded contexts\n     */\n    if (!hfuzz->exe.netDriver && hfuzz->exe.rssLimit) {\n        util_ssnprintf(buf, sizeof(buf), \":soft_rss_limit_mb=%\" PRId64, hfuzz->exe.rssLimit);\n    }\n\n    cmdlineAddEnv(hfuzz, buf);\n    LOG_D(\"%s\", buf);\n}\n\nbool sanitizers_Init(honggfuzz_t* hfuzz) {\n    sanitizers_AddFlag(hfuzz, \"ASAN_OPTIONS\", kASAN_OPTS);\n    sanitizers_AddFlag(hfuzz, \"UBSAN_OPTIONS\", kUBSAN_OPTS);\n    sanitizers_AddFlag(hfuzz, \"MSAN_OPTIONS\", kMSAN_OPTS);\n    sanitizers_AddFlag(hfuzz, \"LSAN_OPTIONS\", kLSAN_OPTS);\n\n    return true;\n}\n\n/* Get numeric value of the /proc/<pid>/status \"Tgid: <PID>\" field */\nstatic pid_t sanitizers_PidForTid(pid_t pid) {\n    char status_path[PATH_MAX];\n    snprintf(status_path, sizeof(status_path), \"/proc/%d/status\", (int)pid);\n    FILE* f = fopen(status_path, \"rb\");\n    if (UNLIKELY(!f)) {\n        return pid;\n    }\n    defer {\n        fclose(f);\n    };\n    char*  lineptr = NULL;\n    size_t n       = 0;\n    defer {\n        free(lineptr);\n    };\n\n    while (getline(&lineptr, &n, f) > 0) {\n        int retpid;\n        if (sscanf(lineptr, \"Tgid:%d\", &retpid) == 1) {\n            LOG_D(\"Tid %d has Pid %d\", (int)pid, retpid);\n            return (pid_t)retpid;\n        }\n    }\n    return pid;\n}\n\nsize_t sanitizers_parseReport(run_t* run, pid_t pid, funcs_t* funcs, uint64_t* pc,\n    uint64_t* crashAddr, char description[HF_STR_LEN]) {\n    char        crashReport[PATH_MAX];\n    const char* crashReportCpy = crashReport;\n\n    /* Under Linux the crash is seen in TID, but the sanitizer report is created for PID */\n    pid = sanitizers_PidForTid(pid);\n    snprintf(crashReport, sizeof(crashReport), \"%s/%s.%d\", run->global->io.workDir, kLOGPREFIX,\n        (int)pid);\n\n    FILE* fReport = fopen(crashReport, \"rb\");\n    if (fReport == NULL) {\n        PLOG_D(\"fopen('%s', 'rb')\", crashReport);\n        return 0;\n    }\n    defer {\n        fclose(fReport);\n        if (run->global->sanitizer.del_report) {\n            unlink(crashReportCpy);\n        }\n    };\n\n    bool         headerFound = false;\n    bool         frameFound  = false;\n    unsigned int frameIdx    = 0;\n\n    char*  lineptr = NULL;\n    size_t n       = 0;\n    defer {\n        free(lineptr);\n    };\n    for (;;) {\n        if (getline(&lineptr, &n, fReport) == -1) {\n            break;\n        }\n\n        /* First step is to identify header */\n        if (!headerFound) {\n            int reportpid = 0;\n            if (sscanf(lineptr, \"==%d==ERROR: \", &reportpid) != 1) {\n                continue;\n            }\n            if (reportpid != pid) {\n                LOG_W(\n                    \"SAN report found in '%s', but its PID:%d is different from the needed PID:%d\",\n                    crashReport, reportpid, (int)pid);\n                break;\n            }\n            headerFound = true;\n            sscanf(lineptr,\n                \"==%*d==ERROR: %*[^:]: %*[^ ] on address 0x%\" PRIx64 \" at pc 0x%\" PRIx64, crashAddr,\n                pc);\n            sscanf(lineptr,\n                \"==%*d==ERROR: %*[^:]: %*[^ ] on %*s address 0x%\" PRIx64 \" (pc 0x%\" PRIx64,\n                crashAddr, pc);\n            sscanf(lineptr, \"==%*d==ERROR: %\" HF_XSTR(HF_STR_LEN_MINUS_1) \"[^\\n]\", description);\n        } else {\n            char* pLineLC = lineptr;\n            /* Trim leading spaces */\n            while (*pLineLC != '\\0' && isspace((unsigned char)*pLineLC)) {\n                ++pLineLC;\n            }\n\n            /* End separator for crash thread stack trace is an empty line */\n            if ((*pLineLC == '\\0') && (frameIdx != 0)) {\n                break;\n            }\n\n            if (sscanf(pLineLC, \"#%u\", &frameIdx) != 1) {\n                continue;\n            }\n            if (frameIdx >= _HF_MAX_FUNCS) {\n                frameIdx = _HF_MAX_FUNCS - 1;\n                break;\n            }\n\n            frameFound = true;\n            snprintf(funcs[frameIdx].func, sizeof(funcs[frameIdx].func), \"UNKNOWN\");\n\n            /*\n             * Frames with demangled symbols and with debug info\n             *     A::A(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>,\n             * std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char,\n             * std::char_traits<char>, std::allocator<char> > > >) /home/fuzz/test/fork.cc:12:51\n             */\n            if (sscanf(pLineLC,\n                    \"#%*u 0x%p in %\" HF_XSTR(_HF_FUNC_NAME_SZ_MINUS_1) \"[^)]) %\" HF_XSTR(\n                        _HF_FUNC_NAME_SZ_MINUS_1) \"[^:]:%zu\",\n                    &funcs[frameIdx].pc, funcs[frameIdx].func, funcs[frameIdx].file,\n                    &funcs[frameIdx].line) == 4) {\n                util_ssnprintf(funcs[frameIdx].func, sizeof(funcs[frameIdx].func), \")\");\n                continue;\n            }\n\n            /*\n             * Frames with demangled symbols but w/o debug info\n             *     #0 0x59d74e in printf_common(void*, char const*, __va_list_tag*)\n             * (/home/smbd/smbd+0x59d74e)\n             */\n            if (sscanf(pLineLC, \"#%*u 0x%p in %\" HF_XSTR(_HF_FUNC_NAME_SZ_MINUS_1) \"[^)]) (%[^)])\",\n                    &funcs[frameIdx].pc, funcs[frameIdx].func, funcs[frameIdx].module) == 3) {\n                util_ssnprintf(funcs[frameIdx].func, sizeof(funcs[frameIdx].func), \")\");\n                continue;\n            }\n            /*\n             * Frames with symbols but w/o debug info\n             *     #0 0x7ffff59a3668 in start_thread (/lib/x86_64-linux-gnu/libpthread.so.0+0x9668)\n             */\n            if (sscanf(pLineLC,\n                    \"#%*u 0x%p in %\" HF_XSTR(_HF_FUNC_NAME_SZ_MINUS_1) \"s%*[^(](%\" HF_XSTR(\n                        HF_STR_LEN_MINUS_1) \"[^)]\",\n                    &funcs[frameIdx].pc, funcs[frameIdx].func, funcs[frameIdx].module) == 3) {\n                continue;\n            }\n            /*\n             * Frames with symbols and with debug info\n             *     #0 0x1e94738 in smb2_signing_decrypt_pdu /home/test/signing.c:617:3\n             */\n            if (sscanf(pLineLC,\n                    \"#%*u 0x%p in %\" HF_XSTR(_HF_FUNC_NAME_SZ_MINUS_1) \"[^ ] %\" HF_XSTR(\n                        HF_STR_LEN_MINUS_1) \"[^:\\n]:%zu\",\n                    &funcs[frameIdx].pc, funcs[frameIdx].func, funcs[frameIdx].file,\n                    &funcs[frameIdx].line) == 4) {\n                continue;\n            }\n            /*\n             * Frames w/o symbols\n             *     #0 0x565584f4  (/mnt/z/test+0x34f4)\n             */\n            if (sscanf(pLineLC, \"#%*u 0x%p%*[^(](%\" HF_XSTR(HF_STR_LEN_MINUS_1) \"[^)\\n]\",\n                    &funcs[frameIdx].pc, funcs[frameIdx].module) == 2) {\n                continue;\n            }\n            /*\n             * Frames w/o symbols, but with debug info\n             *     #0 0x7ffff57cf08f  /build/glibc-bBRi4l/.../erms.S:199\n             */\n            if (sscanf(pLineLC, \"#%*u 0x%p  %\" HF_XSTR(HF_STR_LEN_MINUS_1) \"[^:]:%zu\",\n                    &funcs[frameIdx].pc, funcs[frameIdx].file, &funcs[frameIdx].line) == 3) {\n                continue;\n            }\n        }\n    }\n\n    return (!frameFound) ? 0 : (frameIdx + 1);\n}\n\n/*\n * Size in characters required to store a string representation of a\n * register value (0xdeadbeef style))\n */\n#define REGSIZEINCHAR (2 * sizeof(uint64_t) + 3)\n\nuint64_t sanitizers_hashCallstack(run_t* run, funcs_t* funcs, size_t funcCnt, bool enableMasking) {\n    size_t numFrames = 7;\n    /*\n     * If sanitizer fuzzing enabled increase number of major frames, since top 7-9 frames will be\n     * occupied with sanitizer runtime library & libc symbols\n     */\n    if (run->global->sanitizer.enable) {\n        numFrames = 14;\n    }\n\n    uint64_t hash = 0;\n    for (size_t i = 0; i < funcCnt && i < numFrames; i++) {\n        /*\n         * Convert PC to char array to be compatible with hash function\n         */\n        char pcStr[REGSIZEINCHAR] = {0};\n        snprintf(pcStr, REGSIZEINCHAR, \"0x%016\" PRIx64, (uint64_t)(long)funcs[i].pc);\n\n        /*\n         * Hash the last three nibbles\n         */\n        hash ^= util_hash(&pcStr[strlen(pcStr) - 3], 3);\n    }\n\n    /*\n     * If only one frame, hash is not safe to be used for uniqueness. We mask it\n     * here with a constant prefix, so analyzers can pick it up and create filenames\n     * accordingly. 'enableMasking' is controlling masking for cases where it should\n     * not be enabled (e.g. fuzzer worker is from verifier).\n     */\n    if (enableMasking && funcCnt == 1) {\n        hash |= _HF_SINGLE_FRAME_MASK;\n    }\n\n    return hash;\n}\n"
        },
        {
          "name": "sanitizers.h",
          "type": "blob",
          "size": 2.23046875,
          "content": "/*\n *\n * honggfuzz - sanitizers configuration\n * -----------------------------------------------\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_SANITIZERS_H_\n#define _HF_SANITIZERS_H_\n\n#include <stdbool.h>\n#include <stdint.h>\n\n#include \"honggfuzz.h\"\n#include \"libhfcommon/util.h\"\n\n/* Prefix for sanitizer report files */\n#define kLOGPREFIX \"HF.sanitizer.log\"\n\n/* String buffer size for function names in stack traces produced from libunwind */\n#define _HF_FUNC_NAME_SZ         256    // Should be alright for mangled C++ procs too\n#define _HF_FUNC_NAME_SZ_MINUS_1 255    // For scanf()\n#define _HF_MAX_FUNCS            80\n\n/* Constant prefix used for single frame crashes stackhash masking */\n#define _HF_SINGLE_FRAME_MASK 0xBADBAD0000000000\n\ntypedef struct {\n    void* pc;\n\n    /* If ASan custom parsing, function not available without symbolication */\n    char func[_HF_FUNC_NAME_SZ];\n\n    /*\n     * If libuwind proc maps is used to retrieve map name\n     * If ASan custom parsing it's retrieved from generated report file\n     */\n    char module[HF_STR_LEN];\n\n    /*\n     * Original source file\n     */\n    char file[HF_STR_LEN];\n\n    /*\n     * If libunwind + bfd symbolizer, line is actual symbol file line\n     * If libunwind + custom (e.g. Android), line is offset from function symbol\n     * If ASan custom parsing, line is offset from matching map load base address\n     */\n    size_t line;\n} funcs_t;\n\nextern bool     sanitizers_Init(honggfuzz_t* hfuzz);\nextern size_t   sanitizers_parseReport(run_t* run, pid_t pid, funcs_t* funcs, uint64_t* pc,\n      uint64_t* crashAddr, char description[HF_STR_LEN]);\nextern uint64_t sanitizers_hashCallstack(\n    run_t* run, funcs_t* funcs, size_t funcCnt, bool enableMasking);\n\n#endif /* _HF_SANITIZERS_H_ */\n"
        },
        {
          "name": "screenshot-honggfuzz-1.png",
          "type": "blob",
          "size": 576.626953125,
          "content": null
        },
        {
          "name": "socketfuzzer.c",
          "type": "blob",
          "size": 4.1806640625,
          "content": "#include \"socketfuzzer.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <pthread.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"honggfuzz.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/files.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/ns.h\"\n#include \"libhfcommon/util.h\"\n\nbool fuzz_waitForExternalInput(run_t* run) {\n    /* if the target crashed, we need to identify here and return false,\n        so honggfuzz will restart it, and the fuzzing loop */\n    if (run->crashFileName[0] != '\\0') {\n        LOG_E(\"Target has crashed.\");\n        return false;\n    }\n\n    /* tell the external fuzzer to do his thing */\n    if (!fuzz_prepareSocketFuzzer(run)) {\n        LOG_E(\"fuzz_prepareSocketFuzzer() failed\");\n    }\n\n    /* the external fuzzer may inform us of a crash */\n    int result = fuzz_waitforSocketFuzzer(run);\n    if (result == 2) {\n        return false;\n    }\n\n    return true;\n}\n\nbool fuzz_prepareSocketFuzzer(run_t* run) {\n    // Notify fuzzer that he should send teh things\n    LOG_D(\"fuzz_prepareSocketFuzzer: SEND Fuzz\");\n    return files_sendToSocket(\n        run->global->socketFuzzer.clientSocket, (uint8_t*)\"Fuzz\", strlen(\"Fuzz\"));\n}\n\n/* Return values:\n    0: error\n    1: okay\n    2: target unresponsive\n*/\nint fuzz_waitforSocketFuzzer(run_t* run) {\n    ssize_t ret;\n    uint8_t buf[16];\n\n    // Wait until the external fuzzer did his thing\n    memset(buf, 0, 16);\n    ret = files_readFromFd(run->global->socketFuzzer.clientSocket, buf, 4);\n    LOG_D(\"fuzz_waitforSocketFuzzer: RECV: %s\", buf);\n\n    // We dont care what we receive, its just to block here\n    if (ret < 0) {\n        LOG_E(\"fuzz_waitforSocketFuzzer: received: %zu\", ret);\n    }\n\n    if (memcmp(buf, \"okay\", 4) == 0) {\n        return 1;\n    } else if (memcmp(buf, \"bad!\", 4) == 0) {\n        return 2;\n    } else if (memcmp(buf, \"halt\", 4) == 0) {\n        LOG_D(\"External fuzzer ordered us to shut down.\");\n        if (run->pid) {\n            kill(run->pid, SIGKILL);\n        }\n        exit(0);\n    }\n\n    return 0;\n}\n\nbool fuzz_notifySocketFuzzerNewCov(honggfuzz_t* hfuzz) {\n    // Tell the fuzzer that the thing he sent reached new BB's\n    bool ret = files_sendToSocket(hfuzz->socketFuzzer.clientSocket, (uint8_t*)\"New!\", 4);\n    LOG_D(\"fuzz_notifySocketFuzzer: SEND: New!\");\n    if (!ret) {\n        LOG_E(\"fuzz_notifySocketFuzzer\");\n    }\n\n    return true;\n}\n\nbool fuzz_notifySocketFuzzerCrash(run_t* run) {\n    bool ret = files_sendToSocket(run->global->socketFuzzer.clientSocket, (uint8_t*)\"Cras\", 4);\n    LOG_D(\"fuzz_notifySocketFuzzer: SEND: Crash\");\n    if (!ret) {\n        LOG_E(\"fuzz_notifySocketFuzzer\");\n    }\n\n    return true;\n}\n\nbool setupSocketFuzzer(honggfuzz_t* run) {\n    int                s, len;\n    socklen_t          t;\n    struct sockaddr_un local, remote;\n    char               socketPath[512];\n    snprintf(socketPath, sizeof(socketPath), \"/tmp/honggfuzz_socket.%i\", (int)getpid());\n\n    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n        perror(\"socket\");\n        return false;\n    }\n\n    local.sun_family = AF_UNIX;\n    strcpy(local.sun_path, socketPath);\n    unlink(local.sun_path);\n    len = strlen(local.sun_path) + sizeof(local.sun_family);\n    if (bind(s, (struct sockaddr*)&local, len) == -1) {\n        perror(\"bind\");\n        return false;\n    }\n\n    if (listen(s, 5) == -1) {\n        perror(\"listen\");\n        return false;\n    }\n\n    printf(\"Waiting for SocketFuzzer connection on socket: %s\\n\", socketPath);\n    t = sizeof(remote);\n    if ((run->socketFuzzer.clientSocket =\n                TEMP_FAILURE_RETRY(accept(s, (struct sockaddr*)&remote, &t))) == -1) {\n        perror(\"accept\");\n        return false;\n    }\n\n    run->socketFuzzer.serverSocket = s;\n    printf(\"A SocketFuzzer client connected. Continuing.\\n\");\n\n    return true;\n}\n\nvoid cleanupSocketFuzzer() {\n    char socketPath[512];\n    snprintf(socketPath, sizeof(socketPath), \"/tmp/honggfuzz_socket.%i\", (int)getpid());\n    unlink(socketPath);\n}\n"
        },
        {
          "name": "socketfuzzer.h",
          "type": "blob",
          "size": 0.32421875,
          "content": "#include \"honggfuzz.h\"\n\nbool fuzz_waitForExternalInput(run_t* run);\n\nbool fuzz_prepareSocketFuzzer(run_t* run);\nint  fuzz_waitforSocketFuzzer(run_t* run);\n\nbool fuzz_notifySocketFuzzerNewCov(honggfuzz_t* hfuzz);\nbool fuzz_notifySocketFuzzerCrash(run_t* run);\n\nbool setupSocketFuzzer(honggfuzz_t* hfuzz);\nvoid cleanupSocketFuzzer();\n"
        },
        {
          "name": "socketfuzzer",
          "type": "tree",
          "content": null
        },
        {
          "name": "subproc.c",
          "type": "blob",
          "size": 18.80078125,
          "content": "/*\n *\n * honggfuzz - routines dealing with subprocesses\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *         Felix Gröbert <groebert@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#include \"subproc.h\"\n\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"arch.h\"\n#include \"fuzz.h\"\n#include \"libhfcommon/common.h\"\n#include \"libhfcommon/files.h\"\n#include \"libhfcommon/log.h\"\n#include \"libhfcommon/util.h\"\n\nextern char** environ;\n\nconst char* subproc_StatusToStr(int status) {\n    static __thread char str[256];\n\n    if (WIFEXITED(status)) {\n        snprintf(str, sizeof(str), \"EXITED, exit code: %d\", WEXITSTATUS(status));\n        return str;\n    }\n\n    if (WIFSIGNALED(status)) {\n        snprintf(str, sizeof(str), \"SIGNALED, signal: %d (%s)\", WTERMSIG(status),\n            strsignal(WTERMSIG(status)));\n        return str;\n    }\n    if (WIFCONTINUED(status)) {\n        snprintf(str, sizeof(str), \"CONTINUED\");\n        return str;\n    }\n\n    if (!WIFSTOPPED(status)) {\n        snprintf(str, sizeof(str), \"UNKNOWN STATUS: %d\", status);\n        return str;\n    }\n\n    /* Must be in a stopped state */\n    if (WSTOPSIG(status) == (SIGTRAP | 0x80)) {\n        snprintf(str, sizeof(str), \"STOPPED (linux syscall): %d (%s)\", WSTOPSIG(status),\n            strsignal(WSTOPSIG(status)));\n        return str;\n    }\n#if defined(PTRACE_EVENT_STOP)\n#define __LINUX_WPTRACEEVENT(x) ((x & 0xff0000) >> 16)\n    if (WSTOPSIG(status) == SIGTRAP && __LINUX_WPTRACEEVENT(status) != 0) {\n        switch (__LINUX_WPTRACEEVENT(status)) {\n        case PTRACE_EVENT_FORK:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - fork - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_VFORK:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - vfork - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_CLONE:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - clone - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_EXEC:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - exec - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_VFORK_DONE:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - vfork_done - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_EXIT:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - exit - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_SECCOMP:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - seccomp - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        case PTRACE_EVENT_STOP:\n            snprintf(str, sizeof(str), \"EVENT (Linux) - stop - with signal: %d (%s)\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        default:\n            snprintf(str, sizeof(str), \"EVENT (Linux) UNKNOWN (%d): with signal: %d (%s)\",\n                __LINUX_WPTRACEEVENT(status), WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n            return str;\n        }\n    }\n#endif /*  defined(PTRACE_EVENT_STOP)  */\n\n    snprintf(str, sizeof(str), \"STOPPED with signal: %d (%s)\", WSTOPSIG(status),\n        strsignal(WSTOPSIG(status)));\n    return str;\n}\n\nstatic bool subproc_persistentSendFileIndicator(run_t* run) {\n    uint64_t len = (uint64_t)run->dynfile->size;\n    if (!files_sendToSocketNB(run->persistentSock, (uint8_t*)&len, sizeof(len))) {\n        PLOG_W(\"files_sendToSocketNB(len=%zu)\", sizeof(len));\n        return false;\n    }\n    return true;\n}\n\nstatic bool subproc_persistentGetReady(run_t* run) {\n    uint8_t rcv;\n    if (recv(run->persistentSock, &rcv, sizeof(rcv), MSG_DONTWAIT) != sizeof(rcv)) {\n        return false;\n    }\n    if (rcv != HFReadyTag) {\n        LOG_E(\"Received invalid message from the persistent process: '%c' (0x%\" PRIx8\n              \") , expected '%c' (0x%\" PRIx8 \")\",\n            rcv, rcv, HFReadyTag, HFReadyTag);\n        return false;\n    }\n    return true;\n}\n\nbool subproc_persistentModeStateMachine(run_t* run) {\n    if (!run->global->exe.persistent) {\n        return false;\n    }\n\n    for (;;) {\n        switch (run->runState) {\n        case _HF_RS_WAITING_FOR_INITIAL_READY: {\n            if (!subproc_persistentGetReady(run)) {\n                return false;\n            }\n            run->runState = _HF_RS_SEND_DATA;\n        }; break;\n        case _HF_RS_SEND_DATA: {\n            if (!subproc_persistentSendFileIndicator(run)) {\n                LOG_E(\"Could not send the file size indicator to the persistent process. \"\n                      \"Killing the process pid=%d\",\n                    (int)run->pid);\n                kill(run->pid, SIGKILL);\n                return false;\n            }\n            run->runState = _HF_RS_WAITING_FOR_READY;\n        }; break;\n        case _HF_RS_WAITING_FOR_READY: {\n            if (!subproc_persistentGetReady(run)) {\n                return false;\n            }\n            run->runState = _HF_RS_SEND_DATA;\n            /* The current persistent round is done */\n            return true;\n        }; break;\n        default:\n            LOG_F(\"Unknown runState: %d\", run->runState);\n        }\n    }\n}\n\nstatic void subproc_prepareExecvArgs(run_t* run) {\n    size_t x = 0;\n    for (x = 0; x < _HF_ARGS_MAX && x < (size_t)run->global->exe.argc; x++) {\n        const char* ph_str = strstr(run->global->exe.cmdline[x], _HF_FILE_PLACEHOLDER);\n        if (!strcmp(run->global->exe.cmdline[x], _HF_FILE_PLACEHOLDER)) {\n            run->args[x] = _HF_INPUT_FILE_PATH;\n        } else if (ph_str) {\n            static __thread char argData[PATH_MAX];\n            snprintf(argData, sizeof(argData), \"%.*s%s\",\n                (int)(ph_str - run->global->exe.cmdline[x]), run->global->exe.cmdline[x],\n                _HF_INPUT_FILE_PATH);\n            run->args[x] = argData;\n        } else {\n            run->args[x] = (char*)run->global->exe.cmdline[x];\n        }\n    }\n    run->args[x] = NULL;\n}\n\nstatic bool subproc_PrepareExecv(run_t* run) {\n    util_ParentDeathSigIfAvail(SIGKILL);\n\n    /*\n     * The address space limit. If big enough - roughly the size of RAM used\n     */\n#ifdef RLIMIT_AS\n    if (run->global->exe.asLimit) {\n        const struct rlimit rl = {\n            .rlim_cur = run->global->exe.asLimit * 1024ULL * 1024ULL,\n            .rlim_max = run->global->exe.asLimit * 1024ULL * 1024ULL,\n        };\n        if (setrlimit(RLIMIT_AS, &rl) == -1) {\n            PLOG_W(\"Couldn't enforce the RLIMIT_AS resource limit, ignoring\");\n        }\n    }\n#endif /* ifdef RLIMIT_AS */\n#ifdef RLIMIT_RSS\n    if (run->global->exe.rssLimit) {\n        const struct rlimit rl = {\n            .rlim_cur = run->global->exe.rssLimit * 1024ULL * 1024ULL,\n            .rlim_max = run->global->exe.rssLimit * 1024ULL * 1024ULL,\n        };\n        if (setrlimit(RLIMIT_RSS, &rl) == -1) {\n            PLOG_W(\"Couldn't enforce the RLIMIT_RSS resource limit, ignoring\");\n        }\n    }\n#endif /* ifdef RLIMIT_RSS */\n#ifdef RLIMIT_DATA\n    if (run->global->exe.dataLimit) {\n        const struct rlimit rl = {\n            .rlim_cur = run->global->exe.dataLimit * 1024ULL * 1024ULL,\n            .rlim_max = run->global->exe.dataLimit * 1024ULL * 1024ULL,\n        };\n        if (setrlimit(RLIMIT_DATA, &rl) == -1) {\n            PLOG_W(\"Couldn't enforce the RLIMIT_DATA resource limit, ignoring\");\n        }\n    }\n#endif /* ifdef RLIMIT_DATA */\n#ifdef RLIMIT_CORE\n    const struct rlimit rl = {\n        .rlim_cur = run->global->exe.coreLimit * 1024ULL * 1024ULL,\n        .rlim_max = run->global->exe.coreLimit * 1024ULL * 1024ULL,\n    };\n    if (setrlimit(RLIMIT_CORE, &rl) == -1) {\n        PLOG_W(\"Couldn't enforce the RLIMIT_CORE resource limit, ignoring\");\n    }\n#endif /* ifdef RLIMIT_CORE */\n#ifdef RLIMIT_STACK\n    if (run->global->exe.stackLimit) {\n        const struct rlimit rl = {\n            .rlim_cur = run->global->exe.stackLimit * 1024ULL * 1024ULL,\n            .rlim_max = run->global->exe.stackLimit * 1024ULL * 1024ULL,\n        };\n        if (setrlimit(RLIMIT_STACK, &rl) == -1) {\n            PLOG_W(\"Couldn't enforce the RLIMIT_STACK resource limit, ignoring\");\n        }\n    }\n#endif /* ifdef RLIMIT_STACK */\n\n    if (run->global->exe.clearEnv) {\n        environ = NULL;\n    }\n    for (size_t i = 0; i < ARRAYSIZE(run->global->exe.env_ptrs) && run->global->exe.env_ptrs[i];\n        i++) {\n        putenv(run->global->exe.env_ptrs[i]);\n    }\n    char fuzzNo[128];\n    snprintf(fuzzNo, sizeof(fuzzNo), \"%\" PRId32, run->fuzzNo);\n    setenv(_HF_THREAD_NO_ENV, fuzzNo, 1);\n    if (run->global->exe.netDriver) {\n        setenv(_HF_THREAD_NETDRIVER_ENV, \"1\", 1);\n    }\n\n    /* Make sure it's a new process group / session, so waitpid can wait for -(run->pid) */\n    setsid();\n\n    util_closeStdio(/* close_stdin= */ run->global->exe.nullifyStdio,\n        /* close_stdout= */ run->global->exe.nullifyStdio,\n        /* close_stderr= */ run->global->exe.nullifyStdio);\n\n    /* The coverage bitmap/feedback structure */\n    if (TEMP_FAILURE_RETRY(dup2(run->global->feedback.covFeedbackFd, _HF_COV_BITMAP_FD)) == -1) {\n        PLOG_E(\"dup2(%d, _HF_COV_BITMAP_FD=%d)\", run->global->feedback.covFeedbackFd,\n            _HF_COV_BITMAP_FD);\n        return false;\n    }\n    /* The const comparison bitmap/feedback structure */\n    if (run->global->feedback.cmpFeedback &&\n        TEMP_FAILURE_RETRY(dup2(run->global->feedback.cmpFeedbackFd, _HF_CMP_BITMAP_FD)) == -1) {\n        PLOG_E(\"dup2(%d, _HF_CMP_BITMAP_FD=%d)\", run->global->feedback.cmpFeedbackFd,\n            _HF_CMP_BITMAP_FD);\n        return false;\n    }\n\n    /* The per-thread coverage feedback bitmap */\n    if (TEMP_FAILURE_RETRY(dup2(run->perThreadCovFeedbackFd, _HF_PERTHREAD_BITMAP_FD)) == -1) {\n        PLOG_E(\"dup2(%d, _HF_CMP_PERTHREAD_FD=%d)\", run->perThreadCovFeedbackFd,\n            _HF_PERTHREAD_BITMAP_FD);\n        return false;\n    }\n\n    /* Do not try to handle input files with socketfuzzer */\n    if (!run->global->socketFuzzer.enabled) {\n        /* The input file to _HF_INPUT_FD */\n        if (TEMP_FAILURE_RETRY(dup2(run->dynfile->fd, _HF_INPUT_FD)) == -1) {\n            PLOG_E(\"dup2('%d', _HF_INPUT_FD='%d')\", run->dynfile->fd, _HF_INPUT_FD);\n            return false;\n        }\n        if (lseek(_HF_INPUT_FD, 0, SEEK_SET) == (off_t)-1) {\n            PLOG_E(\"lseek(_HF_INPUT_FD=%d, 0, SEEK_SET)\", _HF_INPUT_FD);\n            return false;\n        }\n        if (run->global->exe.fuzzStdin &&\n            TEMP_FAILURE_RETRY(dup2(run->dynfile->fd, STDIN_FILENO)) == -1) {\n            PLOG_E(\"dup2(_HF_INPUT_FD=%d, STDIN_FILENO=%d)\", run->dynfile->fd, STDIN_FILENO);\n            return false;\n        }\n    }\n\n    /* The log FD */\n    if ((run->global->exe.netDriver || run->global->exe.persistent)) {\n        if (TEMP_FAILURE_RETRY(dup2(logFd(), _HF_LOG_FD)) == -1) {\n            PLOG_E(\"dup2(%d, _HF_LOG_FD=%d)\", logFd(), _HF_LOG_FD);\n            return false;\n        }\n        char llstr[32];\n        snprintf(llstr, sizeof(llstr), \"%d\", logGetLevel());\n        setenv(_HF_LOG_LEVEL_ENV, llstr, 1);\n    }\n\n    sigset_t sset;\n    sigemptyset(&sset);\n    if (sigprocmask(SIG_SETMASK, &sset, NULL) == -1) {\n        PLOG_W(\"sigprocmask(empty_set)\");\n    }\n\n    subproc_prepareExecvArgs(run);\n    return true;\n}\n\nstatic bool subproc_New(run_t* run) {\n    if (run->pid) {\n        return true;\n    }\n\n    int sv[2];\n    if (run->global->exe.persistent) {\n        if (run->persistentSock != -1) {\n            close(run->persistentSock);\n        }\n\n        int sock_type = SOCK_STREAM;\n#if defined(SOCK_CLOEXEC)\n        sock_type |= SOCK_CLOEXEC;\n#endif\n        if (socketpair(AF_UNIX, sock_type, 0, sv) == -1) {\n            PLOG_W(\"socketpair(AF_UNIX, SOCK_STREAM, 0, sv)\");\n            return false;\n        }\n        run->persistentSock = sv[0];\n    }\n\n    LOG_D(\"Forking new process for thread: %\" PRId32, run->fuzzNo);\n\n    run->pid = arch_fork(run);\n    if (run->pid == -1) {\n        PLOG_E(\"Couldn't fork\");\n        run->pid = 0;\n        return false;\n    }\n    /* The child process */\n    if (!run->pid) {\n        logMutexReset();\n        /*\n         * Reset sighandlers, and set alarm(1). It's a guarantee against dead-locks\n         * in the child, where we ensure here that the child process will either\n         * execve or get signaled by SIGALRM within 1 second.\n         *\n         * Those deadlocks typically stem from the fact, that malloc() can behave weirdly\n         * when fork()-ing a single thread of a process: e.g. with glibc < 2.24\n         * (or, Ubuntu's 2.23-0ubuntu6). For more see\n         * http://changelogs.ubuntu.com/changelogs/pool/main/g/glibc/glibc_2.23-0ubuntu7/changelog\n         */\n        alarm(1);\n        signal(SIGALRM, SIG_DFL);\n\n        if (run->global->exe.persistent) {\n            if (TEMP_FAILURE_RETRY(dup2(sv[1], _HF_PERSISTENT_FD)) == -1) {\n                PLOG_F(\"dup2('%d', '%d')\", sv[1], _HF_PERSISTENT_FD);\n            }\n            close(sv[0]);\n            close(sv[1]);\n        }\n\n        if (!subproc_PrepareExecv(run)) {\n            LOG_E(\"subproc_PrepareExecv() failed\");\n            exit(EXIT_FAILURE);\n        }\n\n        LOG_D(\"Launching '%s' on file '%s' (%s mode)\", run->args[0],\n            run->global->exe.persistent ? \"PERSISTENT_MODE\" : _HF_INPUT_FILE_PATH,\n            run->global->exe.fuzzStdin ? \"stdin\" : \"file\");\n\n        if (!arch_launchChild(run)) {\n            LOG_E(\"Error launching child process\");\n            kill(run->global->threads.mainPid, SIGTERM);\n            _exit(1);\n        }\n        abort();\n    }\n\n    /* Parent */\n    LOG_D(\"Launched new process, pid=%d, thread: %\" PRId32 \" (concurrency: %zd)\", (int)run->pid,\n        run->fuzzNo, run->global->threads.threadsMax);\n\n    arch_prepareParentAfterFork(run);\n\n    if (run->global->exe.persistent) {\n        close(sv[1]);\n        run->runState = _HF_RS_WAITING_FOR_INITIAL_READY;\n        LOG_I(\"Persistent mode: Launched new persistent pid=%d\", (int)run->pid);\n    }\n\n    return true;\n}\n\nbool subproc_Run(run_t* run) {\n    if (!subproc_New(run)) {\n        LOG_E(\"subproc_New()\");\n        return false;\n    }\n\n    arch_prepareParent(run);\n    arch_reapChild(run);\n\n    int64_t diffUSecs = util_timeNowUSecs() - run->timeStartedUSecs;\n\n    {\n        MX_SCOPED_LOCK(&run->global->mutex.timing);\n        if (diffUSecs >= ATOMIC_GET(run->global->timing.timeOfLongestUnitUSecs)) {\n            ATOMIC_SET(run->global->timing.timeOfLongestUnitUSecs, diffUSecs);\n        }\n    }\n\n    return true;\n}\n\nuint8_t subproc_System(run_t* run, const char* const argv[]) {\n    pid_t pid = arch_fork(run);\n    if (pid == -1) {\n        PLOG_E(\"Couldn't fork\");\n        return 255;\n    }\n    if (!pid) {\n        logMutexReset();\n\n        setsid();\n        util_closeStdio(\n            /* close_stdin= */ true, /* close_stdout= */ false, /* close_stderr= */ false);\n\n        sigset_t sset;\n        sigemptyset(&sset);\n        if (sigprocmask(SIG_SETMASK, &sset, NULL) == -1) {\n            PLOG_W(\"sigprocmask(empty_set)\");\n        }\n\n        execv(argv[0], (char* const*)&argv[0]);\n        PLOG_F(\"Couldn't execute '%s'\", argv[0]);\n        return 255;\n    }\n\n    int flags = 0;\n#if defined(__WNOTHREAD)\n    flags |= __WNOTHREAD;\n#endif /* defined(__WNOTHREAD) */\n#if defined(__WALL)\n    flags |= __WALL;\n#endif /* defined(__WALL) */\n\n    for (;;) {\n        int status;\n        int ret = TEMP_FAILURE_RETRY(wait4(pid, &status, flags, NULL));\n        if (ret == -1) {\n            PLOG_E(\"wait4() for process pid=%d\", (int)pid);\n            return 255;\n        }\n        if (ret != pid) {\n            LOG_E(\"wait4() returned %d, but waited for %d\", ret, (int)pid);\n            return 255;\n        }\n        if (WIFSIGNALED(status)) {\n            LOG_E(\"Command '%s' terminated with signal: %d\", argv[0], WTERMSIG(status));\n            return (100 + WTERMSIG(status));\n        }\n        if (WIFEXITED(status)) {\n            if (WEXITSTATUS(status) == 0) {\n                return 0U;\n            }\n            LOG_E(\"Command '%s' returned with exit code %d\", argv[0], WEXITSTATUS(status));\n            return 1U;\n        }\n\n        LOG_D(\"wait4() returned with status: %d\", status);\n    }\n}\n\nvoid subproc_checkTimeLimit(run_t* run) {\n    if (!run->global->timing.tmOut) {\n        return;\n    }\n\n    int64_t curUSecs  = util_timeNowUSecs();\n    int64_t diffUSecs = curUSecs - run->timeStartedUSecs;\n\n    if (run->tmOutSignaled && (diffUSecs > ((run->global->timing.tmOut + 1) * 1000000))) {\n        /* Has this instance been already signaled due to timeout? Just, SIGKILL it */\n        LOG_W(\"pid=%d has already been signaled due to timeout. Killing it with SIGKILL\",\n            (int)run->pid);\n        kill(run->pid, SIGKILL);\n        return;\n    }\n\n    if ((diffUSecs > (run->global->timing.tmOut * 1000000)) && !run->tmOutSignaled) {\n        run->tmOutSignaled = true;\n        LOG_W(\"pid=%d took too much time (limit %ld s). Killing it with %s\", (int)run->pid,\n            (long)run->global->timing.tmOut,\n            run->global->timing.tmoutVTALRM ? \"SIGVTALRM\" : \"SIGKILL\");\n        if (run->global->timing.tmoutVTALRM) {\n            kill(run->pid, SIGVTALRM);\n        } else {\n            kill(run->pid, SIGKILL);\n        }\n        ATOMIC_POST_INC(run->global->cnts.timeoutedCnt);\n    }\n}\n\nvoid subproc_checkTermination(run_t* run) {\n    if (fuzz_isTerminating()) {\n        LOG_D(\"Killing pid=%d\", (int)run->pid);\n        kill(run->pid, SIGKILL);\n    }\n}\n\nbool subproc_runThread(\n    honggfuzz_t* hfuzz, pthread_t* thread, void* (*thread_func)(void*), bool joinable) {\n    pthread_attr_t attr;\n\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(\n        &attr, joinable ? PTHREAD_CREATE_JOINABLE : PTHREAD_CREATE_DETACHED);\n    pthread_attr_setstacksize(&attr, _HF_PTHREAD_STACKSIZE);\n    pthread_attr_setguardsize(&attr, (size_t)sysconf(_SC_PAGESIZE));\n\n    if (pthread_create(thread, &attr, thread_func, (void*)hfuzz) < 0) {\n        PLOG_W(\"Couldn't create a new thread\");\n        return false;\n    }\n\n    pthread_attr_destroy(&attr);\n\n    return true;\n}\n"
        },
        {
          "name": "subproc.h",
          "type": "blob",
          "size": 1.3828125,
          "content": "/*\n *\n * honggfuzz - routines dealing with subprocesses\n * -----------------------------------------\n *\n * Author: Robert Swiecki <swiecki@google.com>\n *\n * Copyright 2010-2018 by Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * permissions and limitations under the License.\n *\n */\n\n#ifndef _HF_SUBPROC_H_\n#define _HF_SUBPROC_H_\n\n#include <pthread.h>\n\n#include \"honggfuzz.h\"\n\n/* Missing WIFCONTINUED in Android */\n#ifndef WIFCONTINUED\n#define WIFCONTINUED(x) WEXITSTATUS(0)\n#endif\n\nextern const char* subproc_StatusToStr(int status);\n\nextern bool subproc_Run(run_t* run);\n\nextern bool subproc_persistentModeStateMachine(run_t* run);\n\nextern uint8_t subproc_System(run_t* run, const char* const argv[]);\n\nextern void subproc_checkTimeLimit(run_t* run);\n\nextern void subproc_checkTermination(run_t* run);\n\nbool subproc_runThread(\n    honggfuzz_t* hfuzz, pthread_t* thread, void* (*thread_func)(void*), bool joinable);\n\n#endif\n"
        },
        {
          "name": "third_party",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}