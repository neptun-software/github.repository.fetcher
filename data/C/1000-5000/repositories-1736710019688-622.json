{
  "metadata": {
    "timestamp": 1736710019688,
    "page": 622,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ZerBea/hcxtools",
      "stars": 2060,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1025390625,
          "content": "hcxeiutool\nhcxhash2cap\nhcxhashtool\nhcxpcapngtool\nhcxpmktool\nhcxpsktool\nhcxwltool\nwhoismac\nwlancap2wpasec\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4287109375,
          "content": "dist: focal\nsudo: false\ncache:\n  ccache: true\n\nlanguage: none\n \nmatrix:\n include:\n   - os: linux\n     addons:\n       apt:\n         sources:\n           - ubuntu-toolchain-r-test\n         packages:\n           - gcc-latest\n           - ccache\n           - make\n           - libcurl4-gnutls-dev\n     env:\n       - MATRIX_EVAL=\"CC=gcc-latest DO_INSTALL=1\"\nbefore_install:\n  - eval \"${MATRIX_EVAL}\"\n  - export \"CC=ccache $CC\"\nscript:\n  - \"make\"\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.3837890625,
          "content": "PRODUCTION\t\t:= 0\nPRODUCTION_VERSION\t:= 6.3.5\nPRODUCTION_YEAR\t\t:= 2024\n\nifeq ($(PRODUCTION),1)\nVERSION_TAG\t\t:= $(PRODUCTION_VERSION)\nelse\nVERSION_TAG\t\t:= $(shell git describe --tags || echo $(PRODUCTION_VERSION))\nendif\nVERSION_YEAR\t\t:= $(shell echo $(PRODUCTION_YEAR))\n\nPREFIX\t\t?= /usr\nBINDIR\t\t= $(DESTDIR)$(PREFIX)/bin\n\nHOSTOS\t\t:= $(shell uname -s)\n\nCC\t\t?= gcc\nCFLAGS\t\t?= -O3 -Wall -Wextra -Wpedantic\nCFLAGS\t\t+= -std=gnu99\nDEFS\t\t= -DVERSION_TAG=\\\"$(VERSION_TAG)\\\" -DVERSION_YEAR=\\\"$(VERSION_YEAR)\\\"\nDEFS\t\t+= -DWANTZLIB\n\nINSTALL\t\t?= install\nINSTFLAGS\t=\nPKG_CONFIG ?= pkg-config\n\nifeq ($(HOSTOS), Linux)\nINSTFLAGS += -D\nendif\n\nOPENSSL_LIBS=$(shell $(PKG_CONFIG) --libs openssl)\nOPENSSL_CFLAGS=$(shell $(PKG_CONFIG) --cflags openssl)\nCURL_LIBS=$(shell $(PKG_CONFIG) --libs libcurl)\nCURL_CFLAGS=$(shell $(PKG_CONFIG) --cflags libcurl)\nZ_LIBS=$(shell $(PKG_CONFIG) --libs zlib)\nZ_CFLAGS=$(shell $(PKG_CONFIG) --cflags zlib)\n\nTOOLS=\nTOOLS+=hcxpcapngtool\nhcxpcapngtool_libs=$(OPENSSL_LIBS) $(Z_LIBS)\nhcxpcapngtool_cflags=$(OPENSSL_CFLAGS) $(Z_CFLAGS)\nTOOLS+=hcxhashtool\nhcxhashtool_libs=$(OPENSSL_LIBS) $(CURL_LIBS)\nhcxhashtool_cflags=$(OPENSSL_CFLAGS) $(CURL_CFLAGS)\nTOOLS+=hcxpsktool\nhcxpsktool_libs=$(OPENSSL_LIBS)\nhcxpsktool_cflags=$(OPENSSL_CFLAGS)\nTOOLS+=hcxpmktool\nhcxpmktool_libs=$(OPENSSL_LIBS)\nhcxpmktool_cflags=$(OPENSSL_CFLAGS)\nTOOLS+=hcxeiutool\nTOOLS+=hcxwltool\nTOOLS+=hcxhash2cap\nTOOLS+=wlancap2wpasec\nwlancap2wpasec_libs=$(OPENSSL_LIBS) $(CURL_LIBS)\nwlancap2wpasec_cflags=$(OPENSSL_CFLAGS) $(CURL_CFLAGS)\nTOOLS+=whoismac\nwhoismac_libs=$(OPENSSL_LIBS) $(CURL_LIBS)\nwhoismac_cflags=$(OPENSSL_CFLAGS) $(CURL_CFLAGS)\n\n.PHONY: all build install clean uninstall\n\nall: build\n\nbuild: $(TOOLS)\n\n.deps:\n\tmkdir -p .deps\n\n# $1: tool name\ndefine tool-build\n$(1)_src ?= $(1).c\n$(1)_libs ?=\n$(1)_cflags ?=\n\n$(1): $$($(1)_src) | .deps\n\t$$(CC) $$(CFLAGS) $$($(1)_cflags) $$(CPPFLAGS) -MMD -MF .deps/$$@.d -o $$@ $$($(1)_src) $$($(1)_libs) $$(LDFLAGS) $$(DEFS)\n\n.deps/$(1).d: $(1)\n\n.PHONY: $(1).install\n$(1).install: $(1)\n\t$$(INSTALL) $$(INSTFLAGS) -m 0755 $(1) $$(BINDIR)/$(1)\n\n.PHONY: $(1).clean\n$(1).clean:\n\trm -f .deps/$(1).d\n\trm -f $(1)\n\n.PHONY: $(1).uninstall\n$(1).uninstall:\n\trm -rf $$(BINDIR)/$(1)\n\nendef\n\n$(foreach tool,$(TOOLS),$(eval $(call tool-build,$(tool))))\n\ninstall: $(patsubst %,%.install,$(TOOLS))\n\nclean: $(patsubst %,%.clean,$(TOOLS))\n\trm -rf .deps\n\trm -f *.o *~\n\nuninstall: $(patsubst %,%.uninstall,$(TOOLS))\n\n-include .deps/*.d\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.724609375,
          "content": "hcxtools\n=========\n\nA small set of tools to convert packets from capture files to hash files for use with Hashcat or John the Ripper. \n\nThese tools are 100% compatible with Hashcat and John the Ripper and are endorsed by Hashcat.\n\nBrief Description\n------------------\n\nThe main purpose of hcxtools is to detect weak points within one's own WiFi network by analyzing the hashes.\nTherefore, the conversion of the dump file to WPA-PBKDF2-PMKID+EAPOL hash file allows the user to check if the WLAN-KEY or PMK was transmitted unencrypted.\nOr upload the \"uncleaned\" dump file (pcapng, pcap, cap) [here](https://wpa-sec.stanev.org/?submit) to find out if your AP or the CLIENT is vulnerable by using common wordlists or a weak password generation algorithm.\n\n* Support for Hashcat hash-modes: 4800, 5500, 2200x, 16100, 250x (deprecated), and 1680x (deprecated).\n  \n* Support for John the Ripper hash-modes: WPAPSK-PMK, PBKDF2-HMAC-SHA1, chap, netntlm, and tacacs-plus.\n\n* Support for gzip (.gz) single file compression.\n\nAn overview of Hashcat mode 22000. - (https://hashcat.net/wiki/doku.php?id=cracking_wpawpa2)\n\nOld but still applicable write-up by **atom** of the Hashcat forums covering a new attack on WPA/WPA2 using PMKID. - (https://hashcat.net/forum/thread-7717.html)\n\nHashcat mode 22000 write-up by **atom** of the Hashcat forums. - (https://hashcat.net/forum/thread-10253.html)\n\n**Unsupported:** Windows OS, macOS, Android, emulators or wrappers!\n\nWhat Don't hcxtools Do?\n------------------------\n\n* They do not crack WPA PSK related hashes. (Use Hashcat or JtR to recover the PSK.)\n\n* They do not crack WEP. (Use the aircrack-ng suite instead.)\n\n* They do not crack WPS. (Use Reaver or Bully instead.)\n\n* They do not decrypt encrypted traffic. (Use tshark or Wireshark to do so.)\n\nDetailed Description\n---------------------\n\n| Tool           | Description                                                                                                            |\n| -------------- | ---------------------------------------------------------------------------------------------------------------------- |\n| hcxpcapngtool  | Tool to convert raw capture files to Hashcat and JtR readable formats.                                                 |\n| hcxhashtool    | Tool to filter hashes from HC22000 files based on user input.                                                          |\n| hcxpsktool     | Tool to get weak PSK candidates from hash files or user input.                                                         |\n| hcxpmktool     | Tool to calculate and verify a PSK and/or a PMK.                                                                       |\n| hcxeiutool     | Tool to prepare -E -I -U output of hcxpcapngtool for use by Hashcat + rule or JtR + rule.                              |\n| hcxwltool      | Tool to calculate candidates for Hashcat and JtR based on mixed wordlists.                                             |\n| hcxhash2cap    | Tool to convert hash files (PMKID&EAPOL, PMKID, EAPOL-hccapx, EAPOL-hccap, WPAPSK-john) to cap.                        |\n| wlancap2wpasec | Tool to upload multiple (gzip compressed) pcapng, pcap and cap files to https://wpa-sec.stanev.org                     |\n| whoismac       | Tool to show vendor information and/or download oui reference list.                                                    |\n\nWorkflow\n---------\n\nhcxdumptool -> hcxpcapngtool -> hcxhashtool (additional hcxpsktool/hcxeiutool) -> hashcat or JtR\n\nInstall Guide\n--------------\n\nOn most distributions hcxtools are available through the package manager.\n\nIf you decide to compile latest git head, make sure that your distribution is updated to it's latest version and make sure that all header files and dependencies have been installed!\n\n### Clone Repository\n---------------------\n\n```\ngit clone https://github.com/ZerBea/hcxtools.git\ncd hcxtools\n```\n\n### Compile & Install\n----------------------\n\n```\nmake -j $(nproc)\n```\n\nInstall to `/usr/bin`:\n```\nmake install (as super user)\n```\n\nOr install to `/usr/local/bin`:\n```\nmake install PREFIX=/usr/local (as super user)\n```\n\nRequirements\n--------------\n\n* Knowledge of radio technology.\n* Knowledge of electromagnetic-wave engineering.\n* Detailed knowledge of 802.11 protocol.\n* Detailed knowledge of key derivation functions.\n* Detailed knowledge of Linux\n* Operating system: Linux (recommended: kernel >= 6.4, mandatory: kernel >= 5.10)\n* Recommendation: Arch Linux (notebooks and desktop systems), OpenWRT (small systems like Raspberry Pi, WiFi router)\n* gcc >= 13 recommended (deprecated versions are not supported: https://gcc.gnu.org/)\n* libopenssl (>= 3.0) and openssl-dev installed\n* librt and librt-dev installed. (Should be installed by default.)\n* zlib and zlib-dev installed. (For gzip compressed cap/pcap/pcapng files.)\n* libcurl (>= 7.56) and curl-dev installed. (Used by whoismac and wlancap2wpasec.)\n* pkg-config installed.\n* Make sure that the version of hcxpcapngtool always fits to the version of hcxdumptool \n\n**If you decide to compile latest git head, make sure that your distribution is updated to it's latest version!**\n\nUseful Scripts\n---------------\n\n| Script       | Description                                              |\n| ------------ | -------------------------------------------------------- |\n| piwritecard  | Example script to restore SD-Card                        |\n| piwreadcard  | Example script to backup SD-Card                         |\n| hcxgrep.py   | Extract records from m22000 hashline/hccapx/pmkid file based on regexp   |\n\nNotice\n-------\n\n* Most output files will be appended to existing files (with the exception of pcapng, pcap, cap files).\n\n* It is recommended to use hash mode 22000 (22001) instead of deprecated hash modes 2500 (2501) and 16800 (16801).\n\n* hcxtools are designed to be analysis tools. This means that everything is converted by default and unwanted information must be filtered out! \n\n**Warning:** Do not merge dump files! This WILL destroy hash values assigned by custom blocks!\n\n* Tools do not perform NONCE ERROR CORRECTIONS! In case of a packet loss, you'll get a wrong PTK.\n\n* This branch is pretty closely synced to the Hashcat and John the Ripper repositories.\n\nBitmask Message Pair Field (hcxpcapngtool)\n-------------------------------------------\n\nbit 0-2\n\n000 = M1+M2, EAPOL from M2 (challenge)\n\n001 = M1+M4, EAPOL from M4 if not zeroed (authorized)\n\n010 = M2+M3, EAPOL from M2 (authorized)\n\n011 = M2+M3, EAPOL from M3 (authorized) - unused\n\n100 = M3+M4, EAPOL from M3 (authorized) - unused\n\n101 = M3+M4, EAPOL from M4 if not zeroed (authorized)\n\n3: reserved\n\n4: ap-less attack (set to 1) - no nonce-error-corrections necessary\n\n5: LE router detected (set to 1) - nonce-error-corrections only for LE necessary\n\n6: BE router detected (set to 1) - nonce-error-corrections only for BE necessary\n\n7: not replaycount checked (set to 1) - replaycount not checked, nonce-error-corrections definitely necessary\n\nWarning\n--------\n\nYou might expect me to recommend that everyone should be using hcxdumptool/hcxtools. But the fact of the matter is, hcxdumptool/hcxtools is NOT recommended to be used by inexperienced users or newbies.\n\nIf you are not familiar with Linux in general or you do not have at least a basic level of knowledge as mentioned in section \"Requirements\", hcxdumptool/hcxtools is probably not what you are looking for.\nHowever, if you have that knowledge hcxdumptool/hcxtools can do magic for you.\n\nThe entire toolkit (hcxdumptool and hcxtools) is designed to be an analysis toolkit. \n\nUseful Links\n--------------\n\nhttps://pcapng.com/\n\nhttps://www.kernel.org/doc/html/latest/\n\nhttps://www.kernel.org/doc/html/latest/bpf/index.html\n\nhttps://www.freecodecamp.org/news/the-linux-commands-handbook/\n\nhttps://en.wikipedia.org/wiki/Wpa2\n\nhttps://en.wikipedia.org/wiki/802.11_Frame_Types\n\nhttps://en.wikipedia.org/wiki/IEEE_802.11i-2004\n"
        },
        {
          "name": "changelog",
          "type": "blob",
          "size": 66.75,
          "content": "11.11.2024\n==========\nrelease v6.3.5\nhcxhashtool: added new option to filter ESSID \n--essid-regex=<regex>        : filter ESSID by regular expression\n\nseveral fixes and improvements\n\n\n04.03.2024\n==========\nREADME.md: removed entire instructions how to compile hcxtools on different distributions\n           check the distribution's page how to update the ditribution, how to install missing dependencies and missing header files\n\n\n25.02.2024\n==========\nrelease v6.3.4\n\n\n26.01.2024\n==========\nhcxpcapngtool: added option to store a BSSID file to syn with external GPS data\n--lts=<file>                 : output BSSID list to sync with external GPS data\n                               format: LINUX timestamp <tab> MAC_AP <tab> ESSID\n\n\n14.12.2023\n==========\nhcxhashtool: added new option to import ancient hccap file\n--hccap-in=<file>            : inputput ancient hccap file\n\n\n13.12.2023\n==========\nhcxhashtool: changed options hccapx and hccap\n--hccapx-out=<file>          : output to deprecated hccapx file\n--hccap-out=<file>           : output to ancient hccap file\n\nhcxhashtool: added new option to import deprecated hccapx file\n--hccapx-in=<file>           : inputput deprecated hccapx file\n\n\n01.11.2023\n==========\nrelease v6.3.2\n\n\n26.09.2023\n==========\nhcxpsktool: added simple pattern generator based on analysis of wpa-sec\n--simple            : include simple pattern\n\n\n04.07.2023\n==========\nadded -Wpedantic to compiler flags and fixed all warnings\n\n\n30.06.2023\n==========\nrelease v6.3.1\n\n\n13.05.2023\n==========\nhcxhashtool: allow to print ESSID list to stdout\n-E <file>   : output ESSID list (autohex enabled)\n-E stdout   : output ESSID list to stdout (autohex enabled)\n\n\n10.05.2023\n==========\nhcxpcapngtool: added new option store PMKIDs coming from a CLIENT to a separate hash file.\n--pmkid-client=<file>              : output WPA-(MESH/REPEATER)-PMKID hash file (hashcat -m 22000)\nto sucessfully recover the PSK from this PMKIDs, it is mandatory to store all PMKIDs coming from a CLIENT to this file\n\nadded information about source to the end of WPA*01 hash line:\nPMKID from ACCESS POINT: WPA*01*PMKID*MAC_AP*MAC_CLIENT*ESSID***01\nPMKID from CLIENT      : WPA*01*PMKID*MAC_AP*MAC_CLIENT*ESSID***10\n\n\n05.05.2023\n==========\nrelease v6.3.0\nhcxhashtool/whoismac: do not overwrite oui.txt in case of download ERROR\n\n\n10.03.2023\n==========\nrelease v6.2.9\nhcxpcapngtool moved default timestamp from usec to nsec (timeval to timespec)\n\n\n10.03.2023\n==========\nrelease v6.2.8\nmoved to EVP API 3.0 (from now on OpenSSL >= 3.0 is mandatory)\nhcxpcapngtool: handle nsec timestamps \n\n\n24.12.2022\n==========\nhcxpcapngtool: added detection of entire RADIUS detection\nRADIUS AUTHENTICATION (REQUEST)..........: 2\nRADIUS AUTHENTICATION (CHALLENGE)........: 1\nRADIUS AUTHENTICATION (ACCEPT)...........: 1\n\n\n23.12.2022\n==========\nwlancap2wpasec: moved to curl_mime_xxx\nfrom now on curl >= 7.56 is mandatory\n\n\n14.12.2022\n==========\nhcxhashtool: added new option -L to write unfiltered and unsorted ESSID list (usefull for hashcat -a9 option)\n\n\n25.11.2022\n==========\nhcxhashtool: added new option --essid-partx to filter case insensitive\nmore information here:\nhttps://hashcat.net/forum/thread-6661-post-56782.html#pid56782\n\n\n17.11.2022\n==========\nhcxpcapngtool: added detection of TACAS plus v2 and v3\n\n\n13.11.2022\n==========\nremoved deprecated tools:\n\n| deprecated     | obsolete and - no longer under maintenance - will be removed, when OpenSSL switching to version 3.0.0                  |\n| -------------- | ---------------------------------------------------------------------------------------------------------------------- |\n| hcxmactool     | Various MAC based filter operations on HCCAPX and PMKID files - convert hccapx and/or PMKID to new hashline format     |\n| hcxpmkidtool   | CPU based tools to verify a PMKID                                                                                      |\n| hcxessidtool   | Various ESSID based filter operations on HCCAPX and PMKID files                                                        |\n| hcxhashcattool | Convert old hashcat (<= 5.1.0) separate potfile (2500 and/or 16800) to new potfile format                              |\n\nimproved hcxpmktool (tool to verify a single hc22000 hash):\n$ hcxpmktool --help\nhcxpmktool 6.2.7-51-g60b1801  (C) 2022 ZeroBeat\nusage  : hcxpmktool <options>\n\nshort options:\n-l <hash line> : input hashcat hash line (-m 22000)\n-e <ESSID>     : input Network Name (ESSID)\n-p <PSK>       : input Pre Shared Key (PSK) or Plain Master Key (PMK)\n-p -           : read Pre Shared Key (PSK) from stdin\n               : small lists only\n\nlong options:\n--help         : show this help\n--version      : show version\n\nexit codes:\n0 = PSK/PMK confirmed\n1 = ERROR occurred\n2 = PSK/PMK unconfirmed\n\nexamples:\nget 22000 hashes from here:\nhttps://hashcat.net/wiki/doku.php?id=example_hashes\n\nverify PMKID hash (WPA*01) by PSK\n$ hcxpmktool -l WPA*01*4d4fe7aac3a2cecab195321ceb99a7d0*fc690c158264*f4747f87f9f4*686173686361742d6573736964*** -p hashcat!\n\nHASH FORMAT.: PMKID (WPA*01)\nESSID.......: hashcat-essid\nMAC_AP......: fc690c158264\nMAC_CLIENT..: f4747f87f9f4\nPSK.........: hashcat!\nPMK.........: 88f43854ae7b1624fc2ab7724859e795130f4843c7535729e819cf92f39535dc (calculated)\nPMKID.......: 4d4fe7aac3a2cecab195321ceb99a7d0 (confirmed)\n\n\nverify PMKID hash (WPA*01) by PMK\n$ hcxpmktool -l WPA*01*4d4fe7aac3a2cecab195321ceb99a7d0*fc690c158264*f4747f87f9f4*686173686361742d6573736964*** -p 88f43854ae7b1624fc2ab7724859e795130f4843c7535729e819cf92f39535dc\n\nHASH FORMAT.: PMKID (WPA*01)\nESSID.......: hashcat-essid\nMAC_AP......: fc690c158264\nMAC_CLIENT..: f4747f87f9f4\nPMK.........: 88f43854ae7b1624fc2ab7724859e795130f4843c7535729e819cf92f39535dc\nPMKID.......: 4d4fe7aac3a2cecab195321ceb99a7d0 (confirmed)\n\n\nverify EAPOL hash (WPA*02) by PSK\n$ hcxpmktool -l WPA*02*024022795224bffca545276c3762686f*6466b38ec3fc*225edc49b7aa*54502d4c494e4b5f484153484341545f54455354*10e3be3b005a629e89de088d6a2fdc489db83ad4764f2d186b9cde15446e972e*0103007502010a0000000000000000000148ce2ccba9c1fda130ff2fbbfb4fd3b063d1a93920b0f7df54a5cbf787b16171000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001630140100000fac040100000fac040100000fac028000*a2 -p hashcat!\n\nHASH FORMAT.: EAPOL (WPA*02)\nESSID.......: TP-LINK_HASHCAT_TEST\nMAC_AP......: 6466b38ec3fc\nMAC_CLIENT..: 225edc49b7aa\nPSK.........: hashcat!\nPMK.........: 0857172bd4d3ebb34cf00f3619726008d27558926d963a547332fab033023b82 (calculated)\nKEY VERSION.: WPA2\nNONCE AP....: 10e3be3b005a629e89de088d6a2fdc489db83ad4764f2d186b9cde15446e972e\nNONCE CLIENT: 48ce2ccba9c1fda130ff2fbbfb4fd3b063d1a93920b0f7df54a5cbf787b16171\nKCK.........: 57d0f2ff5faef56f9b94390aebf4474d (calculated)\nKEK.........: 9913af266f6e00225edc49b7aa6466b3 (calculated)\nTK..........: 8ec3fc10e3be3b005a629e89de088d6a (calculated)\nTKIP TX MIC.: 2fdc489db83ad476 (calculated)\nTKIP RX MIC.: 4f2d186b9cde1544 (calculated)\nMIC.........: 024022795224bffca545276c3762686f (confirmed)\n\n\nverify EAPOL hash (WPA*02) by PMK\n$ hcxpmktool -l WPA*02*024022795224bffca545276c3762686f*6466b38ec3fc*225edc49b7aa*54502d4c494e4b5f484153484341545f54455354*10e3be3b005a629e89de088d6a2fdc489db83ad4764f2d186b9cde15446e972e*0103007502010a0000000000000000000148ce2ccba9c1fda130ff2fbbfb4fd3b063d1a93920b0f7df54a5cbf787b16171000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001630140100000fac040100000fac040100000fac028000*a2 -p 0857172bd4d3ebb34cf00f3619726008d27558926d963a547332fab033023b82\n\nHASH FORMAT.: EAPOL (WPA*02)\nESSID.......: TP-LINK_HASHCAT_TEST\nMAC_AP......: 6466b38ec3fc\nMAC_CLIENT..: 225edc49b7aa\nPMK.........: 0857172bd4d3ebb34cf00f3619726008d27558926d963a547332fab033023b82\nKEY VERSION.: WPA2\nNONCE AP....: 10e3be3b005a629e89de088d6a2fdc489db83ad4764f2d186b9cde15446e972e\nNONCE CLIENT: 48ce2ccba9c1fda130ff2fbbfb4fd3b063d1a93920b0f7df54a5cbf787b16171\nKCK.........: 57d0f2ff5faef56f9b94390aebf4474d (calculated)\nKEK.........: 9913af266f6e00225edc49b7aa6466b3 (calculated)\nTK..........: 8ec3fc10e3be3b005a629e89de088d6a (calculated)\nTKIP TX MIC.: 2fdc489db83ad476 (calculated)\nTKIP RX MIC.: 4f2d186b9cde1544 (calculated)\nMIC.........: 024022795224bffca545276c3762686f (confirmed)\n\n\nif either PMKID or MIC is confirmed, exit code is 2\n$ echo $?\n2\n\n\n12.11.2022\n==========\nstart moving to OpenSSL 3.0 EVP API\nthis is a huge step forward an will break backward compatibility\nhttps://wiki.openssl.org/index.php/OpenSSL_3.0\n\n\n10.07.2022\n==========\nhcxpcapngtool: added option to add a timestamp to the converted 22000 hash line\n--add-timestamp   : add date/time to hash line\n                    this must be filtered out before feeding hashcat with the hash, e.g. by awk:\n                    cat hash.hc22000 | awk '{print $1}' > hashremovedtimestamp.hc22000\n\nWarning: hashcat doesn't accept this hash line - the time stamp must be removed before running hashcat on it\n\n\n01.06.2022\n==========\nhcxpsktool: added new option\n--asus              : include weak ASUS RT-AC58U candidates (ASUS_XX)\n\n\n26.04.2022\n==========\nhcxpsktool: fixed stdout bug\nrelease v6.2.7\n\n\n22.04.2022\n==========\nrelease v6.2.6\nstill supporting OpenSSL 1.1\n\n\n09.04.2022\n==========\nhcxpsktool: added new option\n--alticeoptimum     : include weak Altice/Optimum candidates (MyAltice)\n\n\n01.12.2021\n==========\nrelease v6.2.5\nstill supporting OpenSSL 1.1\n\n\n23.10.2021\n==========\nadded generic hcxtools.1 man page \n\n\n22.10.2021\n==========\nremoved manpages, because they are only a duplicate of the help menu\nmoved installation path from /usr/local/bin to /usr/bin\n\n\n14.10.2021\n==========\nhcxpsktool: renamed option --askeyarris to --spectrum\n\n\n25.09.2021\n==========\nhcxhashtool: added new option to filter by replay count not checked (nonce-error-corrections mandatory)\n--rc-not                     : filter EAPOL pairs by replaycount status not checked\n\n\n17.09.2021\n==========\nhcxhashtool: renamed option --notauthorized to --challenge\n             added additional information about filtered MESSAGE PAIRS for this options\n\n\n14.09.2021\n==========\nrelease v6.2.4\nThis is the last version, supporting OpenSSL 1.1\nNext version 6.3.0 will need OpenSSL 3.0.0\n\n\n01.09.2021\n==========\nhcxpcapngtool: added new option to retrieve information about the ACCESS POINT\n               As initial start, if transmitted, MAC_AP, MANUFACTURER, MODELNAME, SERIALNUMBER and DEVICENAME are stored (delimited by tab).\n-D <file> : output device information list\n            format MAC <tab> MANUFACTURER <tab> MODELNAME <tab> SERIALNUMBER <tab> DEVICENAME <tab> UUID E\n\n\n28.08.2021\n==========\nwlancap2wpasec: added upload progress information\nwhoismac: added download progress information\nhcxhashtool: added download progress information\nhcxhashtool: added more info options (https://github.com/ZerBea/hcxtools/issues/195)\n--info=<file>                : output detailed information about content of hash file\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info=stdout                : stdout output detailed information about content of hash file\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info-vendor=<file>         : output detailed information about ACCESS POINT and CLIENT VENDORs\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info-vendor-ap=<file>      : output detailed information about ACCESS POINT VENDORs\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info-vendor-client=<file>  : output detailed information about ACCESS POINT VENDORs\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info-vendor=stdout         : stdout output detailed information about ACCESS POINT and CLIENT VENDORs\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info-vendor-ap=stdout      : stdout output detailed information about ACCESS POINT VENDORs\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n--info-vendor-client=stdout  : stdout output detailed information about ACCESS POINT VENDORs\n                               not in combination with --vendor, --vendor-ap or --vendor-client\n\n\n27.08.2021\n==========\nhcxhashtool: VENDOR search is not longer case sensitive (https://github.com/ZerBea/hcxtools/issues/195)\nhcxhashtool: improved filtering by VENDOR\n--vendor=<VENDOR>            : filter AP or CLIENT by (part of) VENDOR name\n--vendor-ap=<VENDOR>         : filter AP by (part of) VENDOR name\n--vendor-client=<VENDOR>     : filter CLIENT by (part of) VENDOR name\n\n\n25.08.2021\n==========\nhcxpcapngtool: advanced handling of BEACON and PROBERESPOSNE frames\n               distinguish between SSID set, SSID unset and SSID zeroed\n\n\n20.06.2021\n==========\nMakefile: added compiler flag to disable zlib support\n\n\n04.06.2021\n==========\nhcxpcapngtool: improved CSV output:\n--csv=<file>                       : output ACCESS POINT information in CSV format\n                                     delimiter: tabulator (0x08)\n                                     columns:\n                                     YYYY-MM-DD HH:MM:SS MAC_AP ESSID ENC_TYPE CIPHER AKM COUNTRY_INFO CHANNEL RSSI GPS(DM.m) GPS(D.d) GPSFIX\n                                     to convert it to other formats, use bash tools or scripting languages\n                                     GPS FIX:\n                                     0 = fix not available or invalid\n                                     1 = fix valid (GPS SPS mode)\n                                     2 = fix valid (differential GPS SPS Mode)\n                                     3 = not supported\n                                     4 = not supported\n                                     5 = not supported\n                                     6 = fix valid (Dead Reckoning Mode)\n\n\n28.05.2021\n==========\nhcxpsktool: added new option to use an exclude ESSID combinations\n--noessidcombination: exclude ESSID combinations\n\n\n17.05.2021\n==========\nrelease v 6.2.0\nget ready for gcc 11.1.0\nfixed CVE-2021-32286\n\n\n12.05.2021\n==========\nhcxpsktool: added new option to print only candidates based on ACCESS POINT MAC\n--maconly     : print only candidates based on ACCESS POINT MAC\n\n\n17.03.2021\n==========\nhcxhashtool: added new option to use an exclude MAC filter list\n--mac-skiplist=<file>        : exclude MAC from file\n                               format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\n\n\n09.03.2021\n==========\nrelease v 6.1.5\nget ready for OpenSSL 3.0\n\n\n28.02.2021\n==========\nadded new tool to calculate a PMK and verify a 22000 hashline\n\nhcxpmktool 6.1.5-72-g585fe37  (C) 2021 ZeroBeat\nusage  : hcxpmktool <options>\n\nshort options:\n-i <hash line> : input hashcat hash line (-m 22000)\n-e <ESSID>     : input ESSID\n                 default: use ESSID from hash line\n-p <PSK>       : input Pre Shared Key\n-m <PMK>       : input Plain Master KEY\n\nlong options:\n--help         : show this help\n--version      : show version\n\n\n09.02.2021\n==========\nstarted to prepare to use openssl 3.0\nMany structures have been made opaque in OpenSSL 3.0 since OpenSSL 1.0.2\nhttps://wiki.openssl.org/index.php/OpenSSL_3.0\nit is recommended to upgrade to at least OpenSSL 1.1 \n\n\n04.02.2021\n==========\nhcxpcapngtool: fixed handling of BE pcapng files on BE systems\n\n\n14.01.2021\n==========\nrelease v 6.1.5\n\n\n02.01.2021\n==========\nhcxhashtool: added new option --mac-list\n--mac-list=<file>            : filter by MAC file\n                             : format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\n\n\n31.12.2020\n==========\nhcxpcapngtool: added new option --csv\n--csv=<file>                       : output ACCESS POINT information in CSV format\n                                     delimiter: tabulator (0x08)\n                                     columns:\n                                     YYYY-MM-DD HH:MM:SS MAC_AP ESSID ENC_TYPE CIPHER AKM COUNTRY_INFO CHANNEL RSSI LATITUDE QUADRANT LONGITUDE QUADRANT\n\n\n10.12.2020\n==========\nMakefile: make use of pkg-config\n\n\n02.12.2020\n==========\nrelease v 6.1.4\n\n\n21.11.2020\n==========\nhcxhashtool: added new option to filter by ESSID list\n--essid-list=<file>          : filter by ESSID file\n\nhcxpcapngtool: show openSSL version in status\n\n\n27.10.2020\n==========\nhcxeiutool: new tool to prepare -E -I -U output of hcxpcapngtool for use by hashcat + rule\n\n$ hcxeiutool -h\nhcxeiutool 6.1.3-37-gbdc5a67 (C) 2020 ZeroBeat\nusage:\nhcxeiutool <options>\n\noptions:\n-i <file> : input wordlist\n-d <file> : output digit wordlist\n-x <file> : output xdigit wordlist\n-c <file> : output character wordlist (A-Za-z - other characters removed)\n-s <file> : output character wordlist (A-Za-z - other characters replaced by 0x0d)\n-h        : show this help\n-v        : show version\n\n--help           : show this help\n--version        : show version\n\nexample:\n$ hcxdumptool -i <interface> -o dump.pcapng --enable_status=31\n$ hcxpcapngtool -o test.22000 -E elist dump.pcapng\n$ hcxeiutool -i elist -d digitlist -x xdigitlist -c charlist -s sclist\n$ cat elist digitlist xdigitlist charlist sclist > wordlisttmp\n$ hashcat --stdout -r <rule> charlist >> wordlisttmp\n$ hashcat --stdout -r <rule> sclist >> wordlisttmp\n$ cat wordlisttmp | sort | uniq > wordlist\n$ hashcat -m 22000 dump.pcapng wordlist\n\n\n15.10.2020\n==========\nhcxpcapngtool: added handling of BSD loopback header (DLT_NULL)\n\n\n13.10.2020\n==========\nhcxpcapngtool: added new option --tacacs-plus\n--tacacs-plus=<file>               : output TACACS+ (hashcat -m 16100, john tacacs-plus)\n\nhcxpcapngtool: merged options --eapleap and --eapmschapv2 to --eapleap due to same hash format\n--eapleap=<file>                   : output EAP LEAP and MSCHAPV2 CHALLENGE (hashcat -m 5500, john netntlm)\n--prefix=<file>                    : convert everything to lists using this prefix (overrides single options):\n                                      -o <file.22000>      : output PMKID/EAPOL hash file\n                                      -E <file.essid>      : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\n                                      -I <file.identitiy>  : output unsorted identity list to use as input wordlist for cracker\n                                      -U <file.username>   : output unsorted username list to use as input wordlist for cracker\n                                     --eapmd5=<file.4800>  : output EAP MD5 CHALLENGE (hashcat -m 4800)\n                                     --eapleap=<file.5500> : output EAP LEAP and MSCHAPV2 CHALLENGE (hashcat -m 5500, john netntlm)\n                                     --nmea=<file.nmea>    : output GPS data in NMEA format\n\n\n12.10.2020\n==========\nhcxpcapngtool: added new option --eapmschapv2\n--eapmschapv2=<file>               : output EAP MSCHAPV2 CHALLENGE (hashcat -m 5500, john netntlm)\n\n\n11.10.2020\n==========\nhcxpsktool: added new option --ee\n--ee          : include weak EE BrightBox candidates\n\n\n09.10.2020\n==========\nrelease v 6.1.3\n\n\n05.10.2020\n==========\nrefactored weak candidate list based on wpa-sec analysis\n\n\n28.09.2020\n==========\nremoved deprecated wlanpmk2hcx\n\n\n18.09.2020\n==========\nhcxpcapngtool: added new option -R\n-R <file> : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\n            retrieved from PROBEREQUEST frames only\n\n\n17.09.2020\n==========\nrelease v 6.1.2\n\n\n10.09.2020\n==========\nremoved deprecated wlanhcx2ssid, wlanhcxinfo aand wlanhcxcat\n\n\n07.09.2020\n==========\nremoved deprecated wlanhcx2john, wlanjohn2hcx and wlanwkp2hcx\n\n\n04.09.2020\n==========\nremoved deprecated hcxpcaptool - use hcxpcapngtool instead\n\n\n19.08.2020\n==========\nhcxpsktool: added new option:\n--egn         : include Bulgarian EGN\n\n\n06.08.2020\n==========\nrelease v 6.1.1\nimproved warnings\nfixed handling of short options\nadded several new weak candidates\n\n\n29.06.2020\n==========\nrelease v 6.1.0\n\n\n27.07.2020\n==========\nhcxhashtool: added new options to get full benefit aof reuse of PBKDF2\n--hcx-min=<digit>            : disregard hashes with occurrence lower than hcx-min/ESSID\n--hcx-max=<digit>            : disregard hashes with occurrence higher than hcx-min/ESSID\n\n\n19.06.2020\n==========\nhcxpsktool: splitted NETGEAR and ASKEY/ARRIS weak candidate list\n--netgear     : include weak NETGEAR / ORBI candidates\n--askeyarris  : include weak MySpectrumWiFI / SpectrumSetup / MyCharterWiFI candidates\n\n\n15.06.2020\n==========\nrelease v 6.0.3\n\n\n27.05.2020\n==========\nhcxpcapngtool: added counter for AKM defined EAPOL messages\nASSOCIATIONREQUEST (SAE SHA256)..........: 1\n...\nEAPOL M1 messages........................: 44361\nEAPOL M1 messages (AKM defined)..........: 2\nEAPOL M2 messages........................: 1631\nEAPOL M2 messages (AKM defined)..........: 3\n\n\n20.05.2020\n==========\nhcxpcapngtool: print warning if out of sequence time stamps detected\n               hcxdumptool < 6.0.5 was affected, too and hcxpcapngtool will show you this warning\n               hcxdumptool 6.0.6 is fixed\n               improved conversion speed\n\n18.05.2020\n==========\nhcxpcapngtool: handle wrong time stamps in pwnagotchi cap files on --nonce-error-corrections > 0\nIn that case we can't rely on EAPOL TIME OUT \n\n\n01.05.2020\n==========\nhcxpcapngtool: handle vendor defined action frames (eg: AWDL)\n\n\n06.04.2020\n==========\nrelease v 6.0.2\nhcxpcapngtool: improved NC speed and more bug fixes\n\n\n03.04.2020\n==========\nrelease v 6.0.1\nhcxpcapngtool: improved NC speed and some bug fixes\nremoved deprecated wlanhc2hcx\nremoved deprecated wlancow2hcxpmk\n\n\n02.04.2020\n==========\nrelease v 6.0.0\n\n\n30.03.2020\n==========\nhcxhash2cap: added new option to convert PMKID&EAPOL (hashcat -m 22000) to cap file\n--pmkid-eapol=<file> : input PMKID EAPOL combi hash file\n\n\n14.03.2020\n==========\nmoved to v 6.0.0\ncomplete rewrite from scratch\nfull support of new hashline PMKID+EAPOL (hashcat -m 22000 and JtR)\nhttps://github.com/hashcat/hashcat/issues/1816\nhttps://github.com/magnumripper/JohnTheRipper/issues/4183\n\nsupport EAP-LEAP\nsupport EAP-MD5\nseveral bug fixes\nimproved summary\nimproved detection of cipher and AKM suites\nimproved detection of malformed frames (caused by device, driver or monitor mode)\nread more about monitor mode caused bit errors here:\nhttp://www.ict-optimix.eu/images/a/ad/WiFiBitError.pdf\nIn monitor mode the adapter does not check to see if the cyclic redundancy check (CRC)\nvalues are correct for packets captured, so some captured packets may be corrupted.\nhcxpsktool: added new weak candidates\n\n\nhcxpcapngtool: new tool\n$ hcxpcapngtool -h\nhcxpcapngtool 6.0.0 (C) 2020 ZeroBeat\nusage:\nhcxpcapngtool <options>\nhcxpcapngtool <options> input.pcapng\nhcxpcapngtool <options> *.pcapng\nhcxpcapngtool <options> *.pcap\nhcxpcapngtool <options> *.cap\nhcxpcapngtool <options> *.*\n\nshort options:\n-o <file> : output PMKID/EAPOL hash file\n            hashcat -m 22000/22001 and JtR wpapsk-opencl/wpapsk-pmk-opencl\n-E <file> : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\n-I <file> : output unsorted identity list to use as input wordlist for cracker\n-U <file> : output unsorted username list to use as input wordlist for cracker\n-h        : show this help\n-v        : show version\n\nlong options:\n--all                              : convert all possible hashes instead of only the best one\n                                     that can lead to much overhead hashes\n                                     use hcxhashtool to filter hashes\n                                     need hashcat --nonce-error-corrections >= 8\n--eapoltimeout=<digit>             : set EAPOL TIMEOUT (milliseconds)\n                                   : default: 5000 ms\n--nonce-error-corrections=<digit>  : set nonce error correction\n                                     warning: values > 0 can lead to uncrackable handshakes\n                                   : default: 0\n--ignore-ie                        : do not use CIPHER and AKM information\n                                     this will convert all frames regadless of\n                                     CIPHER and/OR AKM information,\n                                     and can lead to uncrackable hashes\n--max-essids=<digit>               : maximum allowed ESSIDs\n                                     default: 1 ESSID\n                                     disregard ESSID changes and take ESSID with highest ranking\n--eapmd5=<file>                    : output EAP MD5 CHALLENGE (hashcat -m 4800)\n--eapmd5-john=<file>               : output EAP MD5 CHALLENGE (john chap)\n--eapleap=<file>                   : output EAP LEAP CHALLENGE (hashcat -m 5500, john netntlm)\n--nmea=<file>                      : output GPS data in NMEA format\n                                     format: NMEA 0183 $GPGGA, $GPRMC, $GPWPL\n                                     to convert it to gpx, use GPSBabel:\n                                     gpsbabel -i nmea -f hcxdumptool.nmea -o gpx -F file.gpx\n                                     to display the track, open file.gpx with viking\n--log=<file>                       : output logfile\n--raw-out=<file>                   : output frames in HEX ASCII\n                                   : format: TIMESTAMP*LINKTYPE*FRAME*CHECKSUM\n--raw-in=<file>                    : input frames in HEX ASCII\n                                   : format: TIMESTAMP*LINKTYPE*FRAME*CHECKSUM\n--pmkid=<file>                     : output deprecated PMKID file (delimter *)\n--hccapx=<file>                    : output deprecated hccapx v4 file\n--hccap=<file>                     : output deprecated hccap file\n--john=<file>                      : output deprecated PMKID/EAPOL (JtR wpapsk-opencl/wpapsk-pmk-opencl)\n--prefix=<file>                    : convert everything to lists using this prefix (overrides single options):\n                                      -o <file.22000>      : output PMKID/EAPOL hash file\n                                      -E <file.essid>      : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\n                                      -I <file.identitiy>  : output unsorted identity list to use as input wordlist for cracker\n                                      -U <file.username>   : output unsorted username list to use as input wordlist for cracker\n                                     --eapmd5=<file.4800>  : output EAP MD5 CHALLENGE (hashcat -m 4800)\n                                     --eapleap=<file.5500> : output EAP LEAP CHALLENGE (hashcat -m 5500, john netntlm)\n                                     --nmea=<file.nmea>    : output GPS data in NMEA format\n--help                             : show this help\n--version                          : show version\n\nbitmask for message pair field:\n0: MP info (https://hashcat.net/wiki/doku.php?id=hccapx)\n1: MP info (https://hashcat.net/wiki/doku.php?id=hccapx)\n2: MP info (https://hashcat.net/wiki/doku.php?id=hccapx)\n3: x (unused)\n4: ap-less attack (set to 1) - no nonce-error-corrections necessary\n5: LE router detected (set to 1) - nonce-error-corrections only for LE necessary\n6: BE router detected (set to 1) - nonce-error-corrections only for BE necessary\n7: not replaycount checked (set to 1) - replaycount not checked, nonce-error-corrections definitely necessary\n\nDo not edit, merge or convert pcapng files! This will remove optional comment fields!\nDetection of bit errors does not work on cleaned dump files!\nDo not use hcxpcapngtool in combination with third party cap/pcap/pcapng cleaning tools (except: tshark and/or Wireshark)!\nIt is much better to run gzip to compress the files. Wireshark, tshark and hcxpcapngtool will understand this.\n\n\nhcxhashtool: new tool\n$ hcxhashtool -h\nhcxhashtool 6.0.0 (C) 2020 ZeroBeat\nusage:\nhcxhashtool <options>\n\noptions:\n-i <file>   : input PMKID/EAPOL hash file\n-o <file>   : output PMKID/EAPOL hash file\n-E <file>   : output ESSID list (autohex enabled)\n-d          : download http://standards-oui.ieee.org/oui.txt\n            : and save to ~/.hcxtools/oui.txt\n            : internet connection required\n-h          : show this help\n-v          : show version\n\n--essid-group                : convert to ESSID groups in working directory\n                               full advantage of reuse of PBKDF2\n                               not on old hash formats\n--oui-group                  : convert to OUI groups in working directory\n                               not on old hash formats\n--mac-group-ap               : convert APs to MAC groups in working directory\n                               not on old hash formats\n--mac-group-client           : convert CLIENTs to MAC groups in working directory\n                               not on old hash formats\n--type                       : filter by hash type\n                             : default PMKID (1) and EAPOL (2)\n--essid-len                  : filter by ESSID length\n                             : default ESSID length: 0...32\n--essid-min                  : filter by ESSID minimum length\n                             : default ESSID minimum length: 0\n--essid-max                  : filter by ESSID maximum length\n                             : default ESSID maximum length: 32\n--essid=<ESSID>              : filter by ESSID\n--essid-part=<part of ESSID> : filter by part of ESSID\n--mac-ap=<MAC>               : filter AP by MAC\n                             : format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\n--mac-client=<MAC>           : filter CLIENT by MAC\n                             : format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\n--oui-ap=<OUI>               : filter AP by OUI\n                             : format: 001122, 00:11:22, 00-11-22 (hex)\n--oui-client=<OUI>           : filter CLIENT by OUI\n                             : format: 001122, 00:11:22, 00-11-22 (hex)\n--vendor=<VENDOR>            : filter by (part of) VENDOR name\n--authorized                 : filter EAPOL pairs by status authorized\n--notauthorized              : filter EAPOL pairs by status not authorized\n--rc                         : filter EAPOL pairs by replaycount status checked\n--apless                     : filter EAPOL pairs by status M2 requested from client\n--info=<file>                : output detailed information about content of hash file\n--info=stdout                : stdout output detailed information about content of hash file\n--vendorlist                 : stdout output VENDOR list sorted by OUI\n--psk=<PSK>                  : pre-shared key to test\n                             : due to PBKDF2 calculation this is a very slow process\n                             : no nonce error corrections\n--pmk=<PMK>                  : plain master key to test\n                             : no nonce error corrections\n--hccapx=<file>              : output to deprecated hccapx file\n--hccap=<file>               : output to ancient hccap file\n--hccap-single               : output to ancient hccap single files (MAC + count)\n--john=<file>                : output to deprecated john file\n--help                       : show this help\n--version                    : show version\n\n\n| deprecated     | obsolete when hashcat and JtR moved to new PMKID/EAPOL hash line - no longer under maintenance                       |\n| -------------- | -------------------------------------------------------------------------------------------------------------------- |\n| whoismac       | Show vendor information and/or download oui reference list                                                           |\n| hcxmactool     | Various MAC based filter operations on HCCAPX and PMKID files - convert hccapx and/or PMKID to new hashline format   |\n| hcxpcaptool    | Shows info of pcap/pcapng file and convert it to other hashformats accepted by hashcat and John the Ripper           |\n| hcxpmkidtool   | CPU based tools to verfiy a PMKID                                                                                    |\n| hcxessidtool   | Various ESSID based filter operations on HCCAPX and PMKID files                                                      |\n| hcxhashcattool | Convert old hashcat (<= 5.1.0) separate potfile (2500 and/or 16800) to new potfile format                            |\n| wlanhc2hcx     | Converts hccap to hccapx                                                                                             |\n| wlanwkp2hcx    | Converts wpk (ELMCOMSOFT EWSA projectfile) to hccapx                                                                 |\n| wlanhcx2ssid   | Strips BSSID, ESSID, OUI                                                                                             |\n| wlanhcxinfo    | Shows detailed info from contents of hccapxfile                                                                      |\n| wlanhcxcat     | Simple password recovery tool for WPA/WPA2/WPA2 SHA256 AES-128-CMAC (hash-modes 2500, 2501)                          |\n| wlanpmk2hcx    | Converts plainmasterkey and ESSID for use with hashcat hash-mode 12000 or john PBKDF2-HMAC-SHA1                      |\n| wlanjohn2hcx   | Converts john wpapsk hashfiles for use with hashcat hash-modes 2500, 2501                                            |\n| wlancow2hcxpmk | Converts pre-computed cowpatty hashfiles for use with hashcat hash-mode 2501                                         |\n| wlanhcx2john   | Converts hccapx to format expected by John the Ripper                                                                |\n\n\n05.01.2020\n==========\nhcxhashtool: added new options\n-d          : download http://standards-oui.ieee.org/oui.txt\n            : and save to ~/.hcxtools/oui.txt\n            : internet connection required\n\n--info=<file>          : output detailed information about content of hash file\n--info=stdout          : stdout output detailed information about content of hash file\n\n\n03.01.2020\n==========\nstarted to remove deprecated tools\nwlanhcxmnc: removed\n\n\n19.12.2019\n==========\nhacxhashtool: added new tool initial \nthis tool will work on new PMKID EAPOL hash line and replace all older hcxtools\nwhen all functions implemented.\n\n\n19.12.2019\n==========\nhcxpcapngtool: move -j to --john because format is deprecated and JtR will move to new format, too\nhttps://github.com/hashcat/hashcat/issues/1816#issuecomment-567423392\n\n\n17.12.2019\n==========\nhcxpsktool: added support for hashcat 22000 (crossover PMKID - EAPOL hashline)\n-c <file>   : input PMKID/EAPOL hash file (hashcat -m 22000)\n\n\n16.12.2019\n==========\nprepare new tool hcxpcapngtool for hashcat hashmode 22000 (crossover PMKID - EAPOL hashline)\nhighly experemental\nnot all features build in\nformat of hashmode 22000 may change on hashcat and hcxpcapngtool until final release\nhcxpcaptool will replaced by hcxpcapngtool if everything is working like expected\nonly testing purpose to verify hashcat's new hash mode 22000\n\n\n09.12.2019\n==========\nhcxpsktool : added new weak candidates\n--phome : include PEGATRON HOME candidates\n\n\n08.12.2019\n==========\nmove to v5.3.0\n\n\n29.09.2019\n==========\nhcxpmkidtool: added new tool to verify a PMKID (CPU based)\noptions:\n-p <pmkid>  : input PMKID\n              PMKID:MAC_AP:MAC_STA:ESSID(XDIGIT)\n              PMKID*MAC_AP*MAC_STA*ESSID(XDIGIT)\n-w <file>   : input wordlist (8...63 characters)\n              output: PMK:ESSID (XDIGIT):password\n-W <word>   : input single word (8...63 characters)\n              output: PMK:ESSID (XDIGIT):password\n-K <pmk>    : input single PMK\n              output: PMK:ESSID (XDIGIT)\n              format:\n-h          : show this help\n-v          : show version\n\n--help      : show this help\n--version   : show version\n\nhcxpmkidtool is designed to verify an existing PSK or and existing PMK.\nIt is not designed to run big wordlists!\n\n\n25.09.2019\n==========\nwlanhashhcx:  removed\nhcxmactool:   added new tool (MAC based counterpart to ESSID based hcxessidtool)\noptions:\n-o <oui>    : filter access point by OUI\n-n <nic>    : filter access point by NIC\n-m <mac>    : filter access point by MAC\n-a <vendor> : filter access point by VENDOR name\n-O <oui>    : filter client by OUI\n-N <nic>    : filter client point by NIC\n-M <mac>    : filter client point by MAC\n-A <vendor> : filter client by VENDOR name\n-h          : show this help\n-v          : show version\n\n--pmkidin=<file>       : input PMKID file 1\n--pmkidout=<file>      : output PMKID file 1\n--hccapxin=<file>      : input HCCAPX file\n--hccapxout=<file>     : output HCCAPX file\n--help                 : show this help\n--version              : show version\n\n\n24.09.2019\n==========\nhcxessidtool: added new options and improved help\n--pmkidgroupout=<file> : output ESSID groups from ESSIDs present in PMKID1\n--hccapxgroupout=<file>: output ESSID groups from ESSIDs present in HCCAPX1\n\n\n15.09.2019\n==========\nhcxpcaptool: added new option and improved help\n--ignore-mac     : do not check MAC addresses\n                   this will allow to use ESSIDs from frames with damaged broadcast MAC address\n\n\n14.09.2019\n==========\nhcxpcaptool  : improved detection of damaged ESSIDs\n\n\n13.09.2019\n==========\nhcxessidtool: added new options\n--essidout=<file>      : output ESSID list\n--essidmacapout=<file> : output MAC_AP:ESSID list\n\n\n12.09.2019\n==========\nremoved     : wlanhcx2essid (deprecated)\nadded       : hcxessidtool\noptions:\n-e <essid>  : filter by ESSID\n-E <essid>  : filter by part of ESSID\n-l <essid>  : filter by ESSID length\n-h          : show this help\n-v          : show version\n\n--pmkid1=<file>        : input PMKID file 1\n--pmkid2=<file>        : input PMKID file 2\n--pmkidout12=<file>    : output only lines present in both PMKID file 1 and PMKID file 2\n--pmkidout1=<file>     : output only lines present in PMKID file 1\n--pmkidout2=<file>     : output only lines present in PMKID file 2\n--pmkidout=<file>      : output only ESSID filtered lines present in PMKID file 1\n--hccapx1=<file>       : input HCCAPX file 1\n--hccapx2=<file>       : input HCCAPX file 2\n--hccapxout12=<file>   : output only lines present in both HCCAPX file 1 and HCCAPX file 2\n--hccapxout1=<file>    : output only lines present in HCCAPX file1\n--hccapxout2=<file>    : output only lines present in HCCAPX file 2\n--hccapxout=<file>     : output only ESSID filtered lines present in HCCAPX file 1\n--help                 : show this help\n--version              : show version\n\nMain purpose is to get full adcantage or reuse of PBKDF2\nwhile merging (only) the same ESSIDs from different hash files\nexamples:\nhcxessidtool --pmkid1=file1.16800 --pmkid2=file2.16800 --pmkidout12=joint.16800\nhcxessidtool --pmkid1=file1.16800 -l 10 --pmkidout=filtered.16800\n\n\n03.09.2019\n==========\nmove to v5.2.2\nfixed bug in damaged ESSID handling\n\n\n01.09.2019\n==========\nhcxpcaptool: show capture device vendor\n\n\n28.08.2019\n==========\nmoved to v5.2.1\nhcxpsktool : added new weak candidates\nhcxdumptool: added additional warnings about handling of pcapng files ( im\n             imrpoved status out: count zeroed PMKIDs\n\n\n19.08.2019\n==========\nmove to v5.2.0\n\n\n11.08.2019\n==========\nhcxpcaptool: print time of first packet and time of last packet\n             this will not work on cap files with zeroed time stamps \n\n\n10.08.2019\n==========\nhcxpcaptool: removed option --replaycountcheck\n             added option --ignore-replaycount to allow conversion of not replaycount checked handshakes\n             if we have no replaycount matching handshake - in that case nc must be used!\n\nRemarks:\ntotal best handshakes and total best PMKIDs can be different to realy written ones:\n\nbest handshakes (total)..........: 190 (ap-less: 122)\nbest PMKIDs (total)..............: 30\n\nsummary output file(s):\n-----------------------\n175 handshake(s) written to /tmp/test.hccapx\nmessage pair M12E2...............: 157\nmessage pair M32E2...............: 16\nmessage pair M34E4...............: 2\n29 PMKID(s) written to /tmp/test.16800\n\nThat depend on this additional options and the quality of the cap file:\n--ignore-fake-frames              : do not convert fake frames\n--ignore-zeroed-pmks              : do not convert frames which use a zeroed plainmasterkey (PMK)\n--ignore-replaycount              : allow not replaycount checked best handshakes\n--time-error-corrections=<digit>  : maximum time gap between EAPOL frames - EAPOL TIMEOUT (default: 600s)\n--nonce-error-corrections=<digit> : maximum replycount/nonce gap to be converted (default: 8)\n                                    example: --nonce-error-corrections=60 \n                                    convert handshakes up to a possible packetloss of 59 packets\n                                    hashcat nonce-error-corrections should be twice as much as hcxpcaptool value\n--max-essid-changes=<digit>       : allow maximum ESSID changes (default: 1 - no ESSID change is allowed)\n\n\n\n09.08.2019\n==========\nhcxpcaptool: added summary (replaycount check) and print warning if result is not replaycount checked\n             (in this case nc is necessary)\n\n             added warning if an ESSID change is detected.\n             this can be handled by increase the value of option --max-essid-changes\n \n             added new option --replaycountcheck\n--replaycountcheck                : convert only replaycount checked frames\n\n\n26.06.2019\n==========\nhcxpcaptool: added new option --max-essid-changes\n--max-essid-changes=<digit>       : allow maximum ESSID changes (default: 8) \n\nuseful on merged cap files with many ESSID changes for a single mac_ap\nor on damaged ESSIDs\n\n\n23.06.2019\n==========\nhcxpcaptool: fixed several big endian issues\n             show information about handshakes and PMKIDs calculated by a zeroed PMK\n             added new options --ignore-zeroed-pmks and --prefix-out=<file>\n--ignore-zeroed-pmks              : do not convert frames which use a zeroed plainmasterkey (PMK)\n\nThis option is useful to reduce the commandline length if all lists are requested:\n--prefix-out=<file>               : convert everything to lists using this prefix (overrides single options):\n                                    hccapx (-o) file.hccapx\n                                    PMKID (-k) file.16800\n                                    netntlm (--netntlm-out) file.5500\n                                    md5 (--md5-out) file.4800\n                                    tacacsplus (--tacacsplus) file.16100\n                                    wordlist (-E) file.essidlist\n                                    identitylist (-I) file.identitylist \n                                    usernamelist (-U) file.userlist\n                                    imsilist (-M) file.imsilist\n                                    networklist (-network-out) file.networklist\n                                    trafficlist (-T) file.networklist\n                                    clientlist (-X) file.clientlist\n                                    deviceinfolist (-D) file.deviceinfolist\n\n\n20.06.2019\n==========\nhcxpcaptool: complete refactoring of pcapng engine \n\n\n19.06.2019\n==========\nhcxpcaptool: added new option -D\n-D <file> : output unsorted device information list\n            format = MAC:DEVICEINFO string\n\n\n16.06.2019\n==========\nhcxpcaptool: refactored complete tag walk engine due to several stack smashing issues (fsanitize=address)\n             added new option to detect known fake frames\n--ignore-fake-frames              : do not convert fake frames\n\n\n14.06.2019\n==========\nhcxpcaptool: complete rewrite of RSN-IE PMKID detection within association frames and reassociation frames\n\n\n07.06.2019\n==========\nhcxpcaptool: added new option to filter output by a single MAC address\n             all packets which doesn't contain this MAC in address 1, address 2 or address 3 are ignored.\n--filtermac=<mac>                 : filter output by MAC address\n                                    format: 112233445566\n\n\n07.06.2019\n==========\nhcxpcaptool: detect and convert PMKIDs from clients\nread more here:\nhttps://hashcat.net/forum/thread-6661-post-44869.html#pid44869\n\n\n30.05.2019\n==========\nhcxtools moved to v5.1.6 due to a bug in v5.1.5\n\nhcxpcaptool: added 2 new options to convert raw PMKIDs\n-K <file> : output raw PMKID file (hashcat hashmode -m 16801 new format)\n-Z <file> : output raw PMKID file (hashcat hashmode -m 16801 old format and john)\n\nuse this options if you would like to verify a PMKID and yo don't have an ESSID\nread more here:\nhttps://github.com/ZerBea/hcxtools/issues/92#issuecomment-497128717\n\n\n19.05.2019\n==========\nadded new useful script: hcxgrep.py\n\nWorks like grep, but for hccapx/pmkid hashfiles - those are detected\nautomagically. It also can read from stdin and writes on stdout.\n\nIt tries to be as close to grep commandline options, this is -h:\n\nusage: hcxgrep.py [-h] [-f FILE] [-v] [-t {essid,mac_ap,mac_sta}]\n                  [PATTERNS] [infile]\n\nExtract records from hccapx/pmkid file based on regexp\n\npositional arguments:\n  PATTERNS              RegExp pattern\n  infile                hccapx/pmkid file to process\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -f FILE, --file FILE  Obtain patterns from FILE, one per line.\n  -v, --invert-match    Invert the sense of matching, to select non-matching\n                        nets\n  -t {essid,mac_ap,mac_sta}, --type {essid,mac_ap,mac_sta}\n                        Field to apply matching, default essid\n\nBy default it greps by essid, but you can choose with -t also to grep\nover mac_ap or mac_sta, passed as lowercase hex strings. It also can\nread multiple patterns from external file, like those attached. It's\ncomposed from routerkeygen and matches essids with _ or - in them. Of\ncourse this have many false positives and the default PSK can be\nchanged, but one can easy get those nets he needs to try custom\nwordlists or etc.\n\n\n\n16.04.2019\n==========\nfinally removed wlanhcx2psk in favor of hcxpsktool\n\n\n08.04.2019\n==========\nhcxpcaptool: from now on only PBKDF2 based hashes (EAPOL and PMKID) are converted running options -k -z and -o\n             raw option -O will convert all EAPOL handshakes.\n\n\n02.04.2019\n==========\nDue to hashcat changes:\n\"WPA/WPA2 cracking: In the potfile, replace password with PMK in order\nto detect already cracked networks across all WPA modes\"\nhttps://github.com/hashcat/hashcat/commit/b8d609ba1604f4fed62198ae5000e205dcc87f70\n \nhcxpcaptool: added new option -k to convert dumpfile to new hashcat PMKID format\n\n-k <file> : output PMKID file (hashcat hashmode -m 16800 new format)\n-z <file> : output PMKID file (hashcat hashmode -m 16800 old format and john)\n\nuse hcxhashcattool to convert old 2500 and old 16800 potfile to new hashcat potfile Format:\n-p <file> : input old hashcat potfile\n            accepted potfiles: 2500 or 16800\n-P <file> : output new potfile file (PMK:ESSID:PSK)\n\nhcxhashcattool -p oldhashcat.2500.pot -P newhashcat.potfile \nhcxhashcattool -p oldhashcat.16800.pot -P newhashcat.potfile\n\n\n30.03.2019\n==========\nhcxpcaptool: retrieve IMSI from UMTS Authentication and Key Agreement (EAP-AKA)\n             and EAP-SIM (GSM Subscriber Modules) Authentication\n\n\n19.03.2019\n==========\nwlanhcx2ssid: use systemwide oui.txt (/usr/share/ieee-data/oui.txt), if exist\nwhoismac: use systemwide oui.txt (/usr/share/ieee-data/oui.txt), if exist\n\n\n18.03.2019\n==========\nwlancap2wpasec: added man 1 page\nhcxpcaptool: added new option -M to collect IMSI numbers\n-M <file> : output unsorted IMSI number list\n\n\n17.03.2019\n==========\nhcxpcaptool: added man 1 page\nhcxpsktool: added man 1 page\nhcxhash2cap: added man 1 page\n\n\n09.03.2019\n==========\nhcxtools moved to version 5.1.3 due to change of pcapng comment field\n\n\n07.03.2019\n==========\nhcxpcaptool added GPX comment field for GPS time from GPS device \n\n<?xml version=\"1.0\"?>\n<gpx version=\"1.0\" creator=\"hcxpcaptool\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxmlns=\"http://www.topografix.com/GPX/1/0\"\nxsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd\">\n<name>test3.gpx</name>\n<trk>\n  <name>dntest.pcapng</name>\n  <trkseg>\n  <trkpt lat=\"49.126353\" lon=\"4.626187\">\n    <ele>129.500000</ele>\n    <time>2019-03-06T22:27:45Z</time>\n    <name>1af87c9124a3</name>\n    <cmt>GPS-TIME:2019-03-06T22:28:00Z</cmt>\n  </trkpt>\n\n\n26.02.2019\n==========\nhcxtools moved to version 5.1.3 due to several bug fixes\n\n\n18.02.2019\n==========\nhcxtools moved to version 5.1.2 due to implementation of serveral new options\n\n\n14.02.2019\n==========\nwlancap2wpasec: added new option -e\n-e <email address> : set email address, if requiered\n\n\n13.02.2019\n==========\nhcxpsktool added full support (option -j) for john\n-i <file> : input EAPOL hash file (hashcat)\n-j <file> : input EAPOL hash file (john)\n-z <file> : input PMKID hash file (hashcat and john)\n\n\n12.02.2019\n==========\nhcxpcaptool: added new option -X\n-X <file> : output client probelist\n          : format: mac_sta:probed ESSID (autohex enabled)\n\n\nadded new tool: hcxwltool\nwhile hcxpsktool is designed to run on hcxpcaptool -o and -z output,\nhcxwltool is designed to run on hcapcaptool -E, -I and -U output\n\n$ hcxwltool -h\nhcxwltool 5.1.1 (C) 2019 ZeroBeat\nusage:\nhcxwltool <options>\n\noptions:\n-i        : input worlist\n-o <file> : output wordlist to file\n-h        : show this help\n-v        : show version\n\n--straight       : output format untouched\n--digit          : output format only digits\n--xdigit         : output format only xdigits\n--lower          : output format only lower\n--upper          : output format only upper\n--capital        : output format only capital\n--length=<digit> : password lenght (8...32)\n--help           : show this help\n--version        : show version\n\nexamples:\nhcxwltool -i wordlist --straight | sort | uniq |  | sort | uniq | hashcat -m 2500 hashfile.hccapx\nhcxwltool -i wordlist --gigit --length=10 | sort | uniq |  | sort | uniq | hashcat -m 2500 hashfile.hccapx\nhcxwltool -i wordlist --digit | sort | uniq | hashcat -m 16800 hashfile.16800\nhcxwltool -i wordlist --xdigit | sort | uniq | john --stdin --format=wpapsk-opencl hashfile.16800\n\n\n11.02.2019\n==========\nwhoismac: added two new options to convert ESSID HEX to ASCII or ESSID ASCII to HEX \n-e <ESSID>    : input ESSID\n-x <xdigit>   : input ESSID in hex\n\nexample:\n$ whoismac -e default\n64656661756c74\n\nnow search for this essid, running simple bash commands:\ncat hashfile.16800 | grep 64656661756c74\n\n\n02.02.2019\n==========\nrelease hcxtools v 5.1.1\nremoved....: wlanhcx2psk\nreplaced by: hcxpsktool\n\nremoved....: wlanhcx2cap\nreplaced by: hcxhash2cap\nno more libcap dependency!\n\n\n01.02.2019\n==========\nhcxhash2cap: added new option to canvert john WPAPSK has file to cap\nhcxhash2cap will replace wlanhcx2cap, soon\n$ hcxhash2cap -h\nhcxhash2cap 5.1.0 (C) 2019 ZeroBeat\nusage:\nhcxhash2cap <options>\n\noptions:\n-c <file> : output cap file\n            if no cap file is selected, output will be written to single cap files\n            format: mac_sta.cap (mac_sta.cap_x)\n\n--pmkid=<file>  : input PMKID hash file\n--hccapx=<file> : input hashcat hccapx file\n--hccap=<file>  : input hashcat hccap file\n--john=<file>   : input John the Ripper WPAPSK hash file\n--help          : show this help\n--version       : show version\n\n\n31.01.2019\n==========\nhcxhash2cap: added new options to convert hccapx to cap and hccap to cap\n\n\n29.01.2019\n==========\naded new tool: hcxhash2cap\n\n\n22.01.2019\n==========\nhcxpcaptool: in preparation of hccapx successor, hcxpcaptool now count oversized (>0xff) EAPOLframes\n             EAPOL packets (oversized)....: xx\nread more here:\nhttps://github.com/hashcat/hashcat/issues/1816\n\n\n13.12.2018\n==========\nhcxpcaptool: removed options -x and -X (old hccap format)\nhcxpcaptool: added options --hccap-out and --hccap-raw-out (old hccap format)\n--hccap-out=<file>                : output old hccap file (hashcat -m 2500)\n--hccap-raw-out=<file>            : output raw old hccap file (hashcat -m 2500)\n\n\n09.12.2018\n==========\nhcxpcaptool: detect EAPOL GROUP KEYs\nhcxpcaptool: move option -H to --hexdump-out\nhcxpcaptool: added new options (--eapol-out, --network-out)\n--eapol-out=<file>                : output EAPOL packets in hex\n                                    format = mac_ap:mac_sta:eapol\n--network-out=<file>              : output network information\n                                    format = mac_ap:ESSID\n--hexdump-out=<file>              : output dump raw packets in hex\n\n\n05.12.2018\n==========\nmoved to v 5.1.0 (according to hashcat)\nhcxpcaptool:  detect EAPOL RC4 KEYs\n\n\n04.12.2018\n==========\nhcxpcaptool: fixed bug in FCS on BE systems\nhcxpcaptool: detect MESH-IDs\n\n\n26.11.2018\n==========\nseveral big endian fixes\nswitched to version 5.0.1\n\n\n19.11.2018\n==========\nhcxpcaptool: improved detection of ESSID changes in merged capfiles\n\n\n30.10.2018\n==========\nhcxtools moved to version 5.0.0\n\nhcxpsktool: added NETGEARxx list\n--netgear : include NETGEAR candidates\n\n\n03.10.2018\n==========\nhcxpcaptool: use GMT time\n\n\n30.09.2018\n==========\nhcxhashcattool: accept 16800 potfiles\n\n\n29.09.2018\n==========\nhcxpcaptool: removed option -Z\nAllow hashfile for -m 16800 to be used with -m 16801\nhttps://github.com/hashcat/hashcat/commit/1b980cf01000c81dfd0ca085593f8c1d66d43188\n\nadded new option -g\n-g <file> : output GPS file\\n\"\n            format = GPX (accepted for example by Viking and GPSBabel)\\n\"\n\n\n24.09.2018\n==========\nwhoismac new option to get VENDOR information from a hashcat 2500 potfile line\n-P <hashline> : input EAPOL hashline from potfile\n\n\n20.09.2018\n==========\nprepare new tool (experimental): hcxpsktool (supports hccapx and 16800 hashfile)\nhcxpsktool will replace wlanhcx2psk, when all wlanhcx2psk functions are added\n\n\n15.09.2018\n==========\nhcxpcaptool: added detection of Cisco Systems, Inc VENDOR information in authentication\n\n\n06.09.2018\n==========\nhcxpcaptool: added detection of Netgear VENDOR information in authentication\n\n\n04.09.2018\n==========\nhcxpcaptool: try to detect and remove damaged ESSIDs\n\n\n26.08.2018\n==========\nwhoismac added new option -p to get information about VENDOR and print ESSID in ASCII\n\"-p <hashline> : input PMKID hashline\\n\"\n\n\n17.08.2018\n==========\nhcxpcaptool skip unknown option (thanks to magnumripper)\nhcxpcaptool detect Wilibox Delibrant Group LLC authentication\nhcxpcaptool detect NETWORK EAP authentication system\n\n\n07.08.2018\n==========\nadded communication between hcxdumtool and hcxpcaptool via pcapng option fields:\n62108 for REPLAYCOUNT uint64_t\n62109 for ANONCE uint8_t[32]\n\n\n03.08.2018\n==========\nhcxtools release 4.2.0\n\nTodo:\nhcxdumptool 4.2.0 will randomize ap-less attacks.\nhcxpcaptool will convert this handshakes correctly, but will not detect them as ap-less attack\nThis feature will be added in hcxtools 4.2.1\n\n\n01.08.2018\n==========\nmoved raspberry pi stuff and dumper stuff to hcxdumptool repository\nfrom now on hcxtools only includes conversion tools\n\n\n25.07.2018\n==========\nhcxtools moved to 4.2.0 rc1\nhcxpcaptool:\nadded hashmodes -m 16800 and -m 16801\nand new options:\n-z <file> : output PMKID file (hashcat hashmode -m 16800 - WPA*-PMKID-PBKDF2)\n-Z <file> : output PMKID file (hashcat hashmode -m 16801 - WPA*-PMKID-PMK)\nuse hcxpcaptool as dumper/attacker, convert with hcxpcaptool, retrieve PSK using hashcat\n\nremoved wlandump-ng (old scool, deprecated)\nremoved wlancap2hcx (old scool, deprecated)\n\n\n17.07.2018\n==========\nhcxpcaptool:\nshow detailed file stats on pcapng files - go in sync with (upcomming) hcxdumptool 4.2.0\n\n\n17.07.2018\n==========\nhcxpcaptool:\nadded detection of all EAP types:\nEAP_PACKET\nEAPOL_START\nEAPOL_LOGOFF\nEAPOL_KEY\nEAPOL_ASF\nEAPOL_MKA\n\n\n15.07.2018\n==========\nwlanhcx2psk:\nadded more weak candidates based on OSINT from wpa-sec\n\n\n07.07.2018\n==========\nhcxpcaptool:\nadded detection of BROADCOM specific authentication\n\n\n01.07.2018\n==========\nhcxpcaptool:\nadded detection of FILS authentication algorithm\n\n\n27.06.2018\n==========\nhcxpcaptool:\nadded detection of authentication algorithms\n\n\n23.06.2018\n==========\nhcxpcaptool:\nadded full support for AVS header (DLT_IEEE802_11_RADIO_AVS)\n\n\n22.06.2018\n==========\nhcxpcaptool:\nadded full support for TaZmen Sniffer Protocol (TZSP)\n\n\n21.06.2018\n==========\nhcxpcaptool:\nadded detection of TaZmen Sniffer Protocol (TZSP)\n\n\n20.06.2018\n==========\nhcxpcaptool:\nadded conversion of WDS packets\n\n\n19.06.2018\n==========\nhcxpcaptool:\nadded detection of RADIUS authentication with Ethernet II header\n\n\n05.05.2018\n==========\nhcxpcaptool:\nimproved detection of broken ESSIDs\nimproved detection of broken EAPOL frames\n\nwlanhcx2ssid (option -F):\nimproved detection of broken ESSIDs\nomproved detection of broken EAPOL frames\n\n\n12.03.2018\n==========\nmoved to v 4.1.5\nadded new options wlancap2wpasec\n$ wlancap2wpasec -h\nwlancap2wpasec 4.1.5 (C) 2018 ZeroBeat\nusage: wlancap2wpasec <options> [input.cap] [input.cap] ...\n       wlancap2wpasec <options> *.cap\n       wlancap2wpasec <options> *.*\n\noptions:\n-k <key>     : wpa-sec user key\n-u <url>     : set user defined URL\n               default = https://wpa-sec.stanev.org\n-t <seconds> : set connection timeout\n               default = 30 seconds\n-R           : remove cap if upload was successful\n-h           : this help\n\n\n25.02.2018\n==========\nsplit repository!\nmoved hcxdumptool to https://github.com/ZerBea/hcxdumptool\nmove pioff to https://github.com/ZerBea/hcxdumptool/hcxpioff\nfrom now on, hcxtools will be the mostly \"portable part\"\n\n\n17.02.2018\n==========\nhcxpcaptool\nadded nonce fuzzing logic for john and old hashcat (hccap) according to bitmask:\n0: MP info\n1: MP info\n2: MP inf\n3: x (unused)\n4: ap-less attack (set to 1) - no nonce-error-corrections neccessary\n5: LE router detected (set to 1) - nonce-error-corrections only for LE neccessary\n6: BE router detected (set to 1) - nonce-error-corrections only for BE neccessary\n7: not replaycount checked (set to 1) - replaycount not checked, nonce-error-corrections definitely neccessary\n\n\n15.02.2018\n==========\nhcxpcaptool\nadded detection of router endianess and ap-less attacks:\nbitmask for message_pair file:\n0: MP info\n1: MP info\n2: MP inf\n3: x (unused)\n4: ap-less attack (set to 1) - no nonce-error-corrections neccessary\n5: LE router detected (set to 1) - nonce-error-corrections only for LE neccessary\n6: BE router detected (set to 1) - nonce-error-corrections only for BE neccessary\n7: not replaycount checked (set to 1) - replaycount not checked, nonce-error-corrections definitely neccessary\n\nusing bit 4 to 7, hcxtools are able to interact with hascat - that will increase speed for hashcat.\n\n\n09.02.2018\n==========\nhcxpcaptool\nadded full implementation of PPP-CHAP authentication\nadded detection of RADIUS (UDP destination 1812)\nnew dependency: libopenssl\n\n\n07.02.2018\n==========\nhcxpcaptool\nadded full implementation of TACACS+\n--tacacsplus-out=<file>           : output TACACS+ authentication file (hashcat -m 16100, john tacacs-plus)\n\n\n05.02.2018\n==========\nhcxpcaptool\nimproved help menu\nignore empty usernames\nadded new option\n--md5-john-out=<file>             : output MD5 challenge file (john chap)\n\n\n04.02.2018\n==========\nhcxpcaptool\ncontinued implementation of EAP (RADIUS): netNTLMv1, MD5 challenge\nadded new options\n-U <file> : output username list (unsorted)\n--netntlm-out=<file>              : output netNTLMv1 file\t(hashcat -m 5500, john netntlm)\n--md5-out=<file>                  : output MD5 challenge file\t(hashcat -m 4800, john chap)\n\n\n03.02.2018\n==========\nadded hcxphashcattool (calculate PMKs from hashcat -m 2500 potfile)\n$ hcxhashcattool -h\nhcxhashcattool 4.1.0 (C) 2018 ZeroBeat\nusage:\nhcxhashcattool <options>\n\noptions:\n-p <file> : input hashcat -m 2500 potfile\n-P <file> : output PMK file (PMK:ESSID:PSK)\n-h        : show this help\n-v        : show version\n\n\n01.02.2018\n==========\nhcxpcaptool\nadded detection of TCP and UDP network protocol\nneccessary for IP based authentications\n\n\n31.01.2018\n==========\nhcxtools moved to v 4.1.0\nand starts into the 3. generation with\n- hcxdumptool (will replace wlandump-ng) and\n- hcxpcaptool (will replace wlancap2hcx)\n\n\n29.01.2018\n==========\nhcxpcaptool\nimproved detection of handshakes\nremoved options -A -S ( will improve them and add them later again)\n\n\n17.01.2018\n==========\nhcxpcaptool\nadded new options\n-O <file> : output raw hccapx file\n-x <file> : output hccap file\n-X <file> : output raw hccap file\n-j <file> : output john WPAPSK-PMK file\n-J <file> : output raw john WPAPSK-PMK file\n--time-error-corrections  : maximum allowed time gap (default: 10000ms)\n--nonce-error-corrections : maximum allowed nonce gap (default: 8)\n                          : should be the same value as in hashcat\noption -O is designed for third party tools which like to strip handshakes by themselves\noptions -x and -X are designed for use on older systems and old hashcat version\n\n\n16.01.2018\n==========\nhcxpcaptool\nadded new option -o\n-o <file> : output hccapx file\nconvert cap/pcap/pcapng to hccapx\n\n\n15.01.2018\n==========\nhcxpcaptool\nadded new option -V\n-V        : verbose (but slow) status output\nRunning hcxpcaptool without options on cap/pcap/pcapng files\nshows only limited stauts output\nIf you need detailed informations, use -V\n\n\n14.01.2018\n==========\nhcxpcaptool\nadded suport for gzip compressed cap/pcap/pcapng files\nnew dependency: zlib\n\n\n14.01.2018\n==========\nhcxpcaptool\nadded new options -P -I\n-I <file> : output identities list\n-P <file> : output possible WPA/WPA2 plainmasterkey list\n\n\n13.01.2018\n==========\nhcxpcaptool\nadded new option\n-S <file> : output station EAPOL information list\ndate::timestamp:mac_sta:mac_ap:epol_len:eapol\nmoved internal to tv_usec timestamp\n\n\n12.01.2018\n==========\nhcxdumptool\nadded new option\n-C <digit>     : comma separated scanlist (1,3,5,7...)\nsupport for scanlist\n\nhcxpcaptool\nadded new option\n-A <file> : output access point anonce information list (forensics purpose)\ndate:mac_sta:mac_ap:keyver(1=M1, 2=M3, 3=M1+M3):replaycount(in hex):anonce\n\n\n11.01.2018\n==========\nhcxpcaptool\nadded new options\n-E <file> : output wordlist (autohex enabled) to use as wordlist\n-T <file> : output traffic information list\n\n\n10.01.2018\n==========\nhcxpcaptool\nadded option -H\n-H        : dump raw packets in hex\n\n\n09.01.2018\n==========\n- move hcxtools to v 4.0.2\n- renamed wlandump-rs to hcxdumptool\n- removed wlancapinfo -> replaced by hcxpcaptool\n  +get rid of libpcap dependency)\n  +added full pcapng support\n\n$ hcxpcaptool -h\nhcxpcaptool 4.0.2 (C) 2017 ZeroBeat\nusage:\nhcxpcaptool <options>\nhcxpcaptool <options> [input.pcap] [input.pcap] ...\nhcxpcaptool <options> *.cap\nhcxpcaptool <options> *.*\n\noptions:\n-h        : show this help\n-v        : show version\n\n\n07.01.2018\n==========\nwlandump-rs\nadded option -l\n-l             : enable capture of IPv4/IPv6 packets\n\n\n06.01.2018\n==========\nwlandump-ng\nadded option -l\n-l             : enable capture of IPv4/IPv6 packets\n\n\n21.12.2017\n==========\nwlancap2hcx\nremoved option -x\nnow wlancap2hcx looks first for association/re-associationrequests\nor for directed proberequests or for proberesponseses\nand at last (if no other frames found in the cap) for a beacon\n\n\n21.12.2017\n==========\nwlancap2hcx\nadded new option to remove handshakes that that belong to the same authentication sequence\n-D        : remove handshakes that belong to the same authentication sequence\n          : you must use nonce-error-corrections on that file!\n\nwlanhcx2ssid\nadded new option to remove handshakes that that belong to the same authentication sequence\n-D <file> : remove handshakes that belong to the same authentication sequence\n          : you must use nonce-error-corrections on that file!\n\n\n17.12.2017\n==========\nmoved to version 4.0.1\n\nadded wlandump-rs\n- use raw sockets instead of libpcap\n- faster and more aggressive than wlandump-ng\n- able to capture more handchakes than wlandump-ng\n- automatic use channel 14 and 5GHz channels if driver supports this\n- improvements on scan engine\n- improvements on authentication engine\n- use ap blacklist instead of BPF\n\n$ wlandump-rs -h\nwlandump-rs 4.0.1 (C) 2017 ZeroBeat\nusage: wlandump-rs <options>\n\noptions:\n-i <interface> : interface\n-o <dump file> : output file in pcapformat including radiotap header (LINKTYPE_IEEE802_11_RADIOTAP)\n-c <digit>     : set channel (default = channel 1)\n-t <seconds>   : stay time on channel before hopping to the next channel\n               : default = 5 seconds\n-B <file>      : blacklist (do not deauthenticate clients from this hosts - format: xxxxxxxxxxxx)\n-I             : show suitable wlan interfaces and quit\n-T <maxerrors> : terminate after <xx> maximal errors\n               : default: 1000000\n-D             : enable to transmit deauthentication- and disassociation-frames\n-P             : enable poweroff\n-s             : enable status messages\n-h             : show this help\n-v             : show version\n\n\n16.12.2017\n==========\nwlancap2wpasec\n-----------\nadded option to remove cap file if upload was successful\n-R           : remove cap if upload was successful\n\n\n05.12.2017\n==========\nwlanhcx2ssid\n-----------\nadded option to strip damaged records from hccapx file\n-F <file>     : strip bad records and write only flawless records to hccapx file\nDetected errors (more follows later):\n- bad keytype in EAPOL frame\n\n\n21.11.2017\n==========\nwlancap2hcx\n-----------\nadded detection and conversation of TACACS+ Authentication\n-t <file> : output TACACS+ file (hashcat -m 16100, john tacacs-plus)\n\n\n21.11.2017\n==========\nwlandump-ng\n-----------\nadded new option -P for use with hard coded GPIO switch\n-P : terminate program and poweroff raspberry pi by GPIO switch\n   : default: terminate program and do not power off\n\n\n20.11.2017\n==========\nwlandump-ng\n-----------\ndo not terminate wlandum-ng if channel set failed\ninstead reset channel back to 1\n\n\n31.10.2017\n==========\nwlandump-ng\n-----------\nimproved status: added beacons, proberequests, proberesponses, associationrequests and reassociationrequests\nwarning in help mennu that driver must support 5GHz\n\n\n29.10.2017\n==========\nwlanrcascan\n-----------\nadded option -l (loopcount)\n\nwlandump-ng\n-----------\nadded detection of fast BSS transition (fast roaming)\n\nwlancap2hcx\n-----------\nadded detection of fast BSS transition (fast roaming)\n\n\n28.10.2017\n==========\n- added changelog\n- merged wlanresponse and wlandump-ng\n\nbash_profile\n------------\nadapted to new wlandump-ng\n\nwlanresponse\n------------\n- removed\n\nwlandump-ng\n-----------\n- waterfall status\n- improved deauthentication\n  stop when retrieved one complete handshake (M1-M4) from ap <-> client\n- improved disassociation\n  stop when retrieved one complete handshake (M1-M4) from ap <-> client\n- send one undirected proberequest to broadcast after channel change\n- improved expanded EAPOL handling\n- improved authentication\n- improved beaconing on proberequests\n- now wlandump-ng is passive by default (only receive) - transmit must be enabled\n- changed / new options:\n  -R         : enable to respond to all requests\n  -D         : enable deauthentications\n  -d         : enable disassociations\n  -E <digit> : stop deauthentications and disassociations if xx complete handshakes received\n             : default = 1 complete handshake (M1-M4)\n  -U         : send one undirected proberequest to broadcast after channel change\n  -B         : enable beaconing on last proberequest\n  \"-s        : enable status messages\\n\"\n\nlocaltime, channel, mac_ap, mac_sta, information\n11:02:52  11 xxxxxxxxxxxx <-> xxxxxxxxxxxx M1M2 handshake (forced)          \n11:01:45  11 xxxxxxxxxxxx <-> xxxxxxxxxxxx M1M2 handshake (forced-retransmission)          \n11:03:57  11 xxxxxxxxxxxx <-> xxxxxxxxxxxx M1M2 handshake (not verified)          \n11:03:57  11 xxxxxxxxxxxx <-> xxxxxxxxxxxx M2M3 handshake (verified)          \n11:03:57  11 xxxxxxxxxxxx <-> xxxxxxxxxxxx M3M4 handshake (established) \n16:36:13   1 xxxxxxxxxxxx --> xxxxxxxxxxxx identity request: hello          \n16:36:13   1 xxxxxxxxxxxx <-- xxxxxxxxxxxx identity response: WFA-SimpleConfig-Registrar-1-0          \n16:36:14   1 xxxxxxxxxxxx --> xxxxxxxxxxxx WPS-M1 message          \n16:36:14   1 xxxxxxxxxxxx <-- xxxxxxxxxxxx WPS-M2 message          \n16:36:16   1 xxxxxxxxxxxx --> xxxxxxxxxxxx WPS-M3 message          \n16:36:16   1 xxxxxxxxxxxx <-- xxxxxxxxxxxx WPS-M4 message          \n16:36:16   1 xxxxxxxxxxxx --> xxxxxxxxxxxx WPS-M5 message          \n16:36:16   1 xxxxxxxxxxxx <-- xxxxxxxxxxxx WPS-M6 message          \n16:36:16   1 xxxxxxxxxxxx --> xxxxxxxxxxxx WPS-M7 message          \n16:36:16   1 xxxxxxxxxxxx <-- xxxxxxxxxxxx WPS-M8 message          \n\n"
        },
        {
          "name": "hcxeiutool.c",
          "type": "blob",
          "size": 6.697265625,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"include/hcxeiutool.h\"\n#include \"include/strings.c\"\n#include \"include/fileops.c\"\n\n/*===========================================================================*/\n/* global variable */\n\nstatic FILE *fh_digitlist;\nstatic FILE *fh_xdigitlist;\nstatic FILE *fh_charlist;\nstatic FILE *fh_cslist;\n/*===========================================================================*/\nstatic void separatewords(int len, char *line)\n{\nstatic int c, cl, cs, cw, cd, cx;\nstatic char word[LINE_MAX][WORD_MAX];\n\ncs = 0;\ncw = 0;\ncd = 0;\ncx = 0;\ncl = CSWORD;\nmemset(word, 0, sizeof(word));\nfor(c = 0; c < len; c++)\n\t{\n\tif((line[c] >= '0') && (line[c] <= '9'))\n\t\t{\n\t\tword[DIGITWORD][cd] = line[c];\n\t\tcd++;\n\t\t}\n\tif(isxdigit((unsigned char)line[c]))\n\t\t{\n\t\tword[XDIGITWORD][cx] = line[c];\n\t\tcx++;\n\t\t}\n\tif(((line[c] >= 'A') && (line[c] <= 'Z')) || ((line[c] >= 'a') && (line[c] <= 'z')))\n\t\t{\n\t\tword[CHARWORD][cw] = line[c];\n\t\tword[cl][cs] = line[c];\n\t\tcw++;\n\t\tcs++;\n\t\t}\n\telse\n\t\t{\n\t\tcl++;\n\t\tcs = 0;\n\t\t}\n\t}\nif(memcmp(word[DIGITWORD], word[XDIGITWORD], WORD_MAX) == 0) word[XDIGITWORD][0] = 0;\nif(memcmp(word[CSWORD], word[XDIGITWORD], WORD_MAX) == 0) word[XDIGITWORD][0] = 0;\nif(memcmp(word[CSWORD], word[CHARWORD], WORD_MAX) == 0) word[CHARWORD][0] = 0;\n\nif(fh_digitlist != NULL)\n\t{\n\tif(strnlen(word[DIGITWORD], WORD_MAX) > 3) fprintf(fh_digitlist, \"%s\\n\", word[DIGITWORD]);\n\t}\nif(fh_xdigitlist != NULL)\n\t{\n\tif(strnlen(word[XDIGITWORD], WORD_MAX) > 3) fprintf(fh_xdigitlist, \"%s\\n\", word[XDIGITWORD]);\n\t}\nif(fh_charlist != NULL)\n\t{\n\tif(strnlen(word[CHARWORD], WORD_MAX) > 3) fprintf(fh_charlist, \"%s\\n\", word[CHARWORD]);\n\t}\nif(fh_cslist != NULL)\n\t{\n\tfor(c = CSWORD; c < LINE_MAX; c++)\n\t\t{\n\t\tif(strnlen(word[c], WORD_MAX) > 3) fprintf(fh_cslist, \"%s\\n\", word[c]);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processwordlist(FILE *fh_in)\n{\nstatic int len;\n\nstatic char hexid[] = \"$HEX[\";\nstatic char linein[LINEIN_MAX];\n\nwhile((len = fgetline(fh_in, LINEIN_MAX, linein)) != -1)\n\t{\n\tif(memcmp(&linein, &hexid, 5) == 0) continue;\n\tif(len < 64) separatewords(len, linein);\n\t}\nreturn;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic void version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage:\\n\"\n\t\"%s <options>\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-i <file> : input wordlist\\n\"\n\t\"-d <file> : output digit wordlist\\n\"\n\t\"-x <file> : output xdigit wordlist\\n\"\n\t\"-c <file> : output character wordlist (A-Za-z - other characters removed)\\n\"\n\t\"-s <file> : output character wordlist (A-Za-z - other characters replaced by 0x0a)\\n\"\n\t\"            recommended option for processing with rules\\n\"\n\t\"-h        : show this help\\n\"\n\t\"-v        : show version\\n\"\n\t\"\\n\"\n\t\"--help           : show this help\\n\"\n\t\"--version        : show version\\n\"\n\t\"\\n\"\n\t\"example:\\n\"\n\t\"$ hcxdumptool -i <interface> -w dump.pcapng\\n\"\n\t\"$ hcxpcapngtool -o hash.22000 -E elist dump.pcapng\\n\"\n\t\"$ hcxeiutool -i elist -d digitlist -x xdigitlist -c charlist -s sclist\\n\"\n\t\"$ cat elist digitlist xdigitlist charlist sclist > wordlisttmp\\n\"\n\t\"$ hashcat --stdout -r <rule> charlist >> wordlisttmp\\n\"\n\t\"$ hashcat --stdout -r <rule> sclist >> wordlisttmp\\n\"\n\t\"$ cat wordlisttmp | sort | uniq > wordlist\\n\"\n\t\"$ hashcat -m 22000 hash.22000 wordlist\\n\" \n\t\"\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic FILE *fh_wordlistin = NULL;\nstatic char *wordlistinname = NULL;\nstatic char *digitname = NULL;\nstatic char *xdigitname = NULL;\nstatic char *charname = NULL;\nstatic char *csname = NULL;\n\nstatic const char *short_options = \"i:d:x:c:s:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCX_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCX_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\n\nfh_digitlist = NULL;\nfh_xdigitlist = NULL;\nfh_charlist = NULL;\nfh_cslist = NULL;\n\nwhile((auswahl = getopt_long (argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCX_INPUT_WORDLIST:\n\t\twordlistinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_OUTPUT_DIGITLIST:\n\t\tdigitname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_OUTPUT_XDIGITLIST:\n\t\txdigitname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_OUTPUT_CHARLIST:\n\t\tcharname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_OUTPUT_CSLIST:\n\t\tcsname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\n\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\n\");\n\treturn EXIT_SUCCESS;\n\t}\n\nif(wordlistinname == NULL)\n\t{\n\tfprintf(stderr, \"no input wordlist selected\\n\");\n\treturn EXIT_SUCCESS;\n\t}\n\nif((fh_wordlistin = fopen(wordlistinname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"error opening file %s: %s\\n\", wordlistinname, strerror(errno));\n\texit(EXIT_FAILURE);\n\t}\n\nif(digitname != NULL)\n\t{\n\tif((fh_digitlist = fopen(digitname, \"a+\")) == NULL)\n\t\t{\n\t\tfprintf(stderr, \"error opening file %s: %s\\n\", digitname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(xdigitname != NULL)\n\t{\n\tif((fh_xdigitlist = fopen(xdigitname, \"a+\")) == NULL)\n\t\t{\n\t\tfprintf(stderr, \"error opening file %s: %s\\n\", xdigitname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(charname != NULL)\n\t{\n\tif((fh_charlist = fopen(charname, \"a+\")) == NULL)\n\t\t{\n\t\tfprintf(stderr, \"error opening file %s: %s\\n\", charname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(csname != NULL)\n\t{\n\tif((fh_cslist = fopen(csname, \"a+\")) == NULL)\n\t\t{\n\t\tfprintf(stderr, \"error opening file %s: %s\\n\", csname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nprocesswordlist(fh_wordlistin);\n\nif(fh_cslist != NULL) fclose(fh_cslist);\nif(fh_charlist != NULL) fclose(fh_charlist);\nif(fh_xdigitlist != NULL) fclose(fh_xdigitlist);\nif(fh_digitlist != NULL) fclose(fh_digitlist);\nfclose(fh_wordlistin);\n\nreturn EXIT_SUCCESS;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "hcxhash2cap.c",
          "type": "blob",
          "size": 48.482421875,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#else\n#include <arpa/inet.h>\n#endif\n\n#include \"include/hcxhash2cap.h\"\n#include \"include/hashcatops.h\"\n#include \"include/pcap.c\"\n#include \"include/ieee80211.c\"\n#include \"include/strings.c\"\n#include \"include/byteops.c\"\n#include \"include/fileops.c\"\n\n#define ARCH_INDEX(x)\t((unsigned int)(unsigned char)(x))\n\n/*===========================================================================*/\n/* global var */\n\nstatic struct timeval tv;\nstatic uint64_t timestamp;\n\nstatic int mybeaconsequence;\nstatic int myaponlinetime;\nstatic uint8_t myapchannel;\nstatic unsigned long long int pmkideapolcapwritten;\nstatic unsigned long long int pmkideapolcapskipped;\nstatic unsigned long long int pmkcapwritten;\nstatic unsigned long long int pmkcapskipped;\nstatic unsigned long long int hccapxcapwritten;\nstatic unsigned long long int hccapxcapskipped;\nstatic unsigned long long int hccapcapwritten;\nstatic unsigned long long int hccapcapskipped;\nstatic unsigned long long int johnwritten;\nstatic unsigned long long int johnskipped;\n\n/*===========================================================================*/\nstatic void globalinit(void)\n{\n\nsrand(time(NULL));\ngettimeofday(&tv, NULL);\ntimestamp = ((uint64_t)tv.tv_sec * 1000000) + tv.tv_usec;\nmybeaconsequence = rand() %4096;\nmyaponlinetime = rand();\nmyapchannel = (rand() %12) +1;\npmkcapwritten = 0;\npmkcapskipped = 0;\nhccapxcapwritten = 0;\nhccapxcapskipped = 0;\nhccapcapwritten = 0;\nhccapcapskipped = 0;\njohnwritten = 0;\njohnskipped = 0;\n}\n/*===========================================================================*/\nstatic void writecapm1wpa1(int fd_cap, uint8_t *macsta, uint8_t *macap, uint8_t *anonce, uint8_t keyversion, uint16_t keylen, uint64_t rc)\n{\nstatic int c;\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic wpakey_t *wpak;\n\nstatic const uint8_t m1wpa1data[] =\n{\n0x88, 0x02, 0x3a, 0x01,\n0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n0x00, 0x00, 0x06, 0x00,\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n0x01, 0x03, 0x00, 0x5f, 0xfe,\n0x00, 0x89, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xed, 0x57, 0x5c, 0x4b, 0xca, 0xa7, 0x7a, 0xf1, 0x9e, 0x32, 0x94, 0x32, 0x63, 0x91, 0xad, 0x7d,\n0x9c, 0xbc, 0x6a, 0xb4, 0xad, 0x04, 0xf1, 0x23, 0x80, 0xb4, 0x44, 0xbe, 0xb5, 0x8d, 0x2a, 0xdd,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00,\n};\n#define M1WPA1DATA_SIZE sizeof(m1wpa1data)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = M1WPA1DATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmemcpy(&packetout[PCAPREC_SIZE], &m1wpa1data, M1WPA1DATA_SIZE);\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmemcpy(mach->addr1, macsta, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\npacketout[PCAPREC_SIZE +0x22] = keyversion;\nwpak = (wpakey_t*)(packetout +PCAPREC_SIZE +0x26);\n#ifdef BIG_ENDIAN_HOST\nrc = byte_swap_64(rc);\n#endif\nwpak->keylen = keylen;\nwpak->replaycount = rc;\nfor(c = 0; c < 32; c++)\n\t{\n\tpacketout[PCAPREC_SIZE +0x33 +c] = anonce[c];\n\t}\nif(write(fd_cap, packetout, PCAPREC_SIZE +M1WPA1DATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write EAPOL packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecapm1wpa2(int fd_cap, uint8_t *macsta, uint8_t *macap, uint8_t *anonce, uint8_t keyversion, uint16_t keylen, uint64_t rc)\n{\nstatic int c;\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic wpakey_t *wpak;\n\nstatic const uint8_t m1wpa2data[] =\n{\n0x88, 0x02, 0x3a, 0x01,\n0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n0x00, 0x00, 0x06, 0x00,\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n0x02, 0x03, 0x00, 0x5f, 0x02,\n0x00, 0x8a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xed, 0x57, 0x5c, 0x4b, 0xca, 0xa7, 0x7a, 0xf1, 0x9e, 0x32, 0x94, 0x32, 0x63, 0x91, 0xad, 0x7d,\n0x9c, 0xbc, 0x6a, 0xb4, 0xad, 0x04, 0xf1, 0x23, 0x80, 0xb4, 0x44, 0xbe, 0xb5, 0x8d, 0x2a, 0xdd,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00,\n};\n#define M1WPA2DATA_SIZE sizeof(m1wpa2data)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = M1WPA2DATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\n\nmemcpy(&packetout[PCAPREC_SIZE], &m1wpa2data, M1WPA2DATA_SIZE);\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmemcpy(mach->addr1, macsta, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\npacketout[PCAPREC_SIZE +0x22] = keyversion;\nwpak = (wpakey_t*)(packetout +PCAPREC_SIZE +0x26);\n#ifdef BIG_ENDIAN_HOST\nrc = byte_swap_64(rc);\n#endif\nwpak->keylen = keylen;\nwpak->replaycount = rc;\nfor(c = 0; c < 32; c++)\n\t{\n\tpacketout[PCAPREC_SIZE +0x33 +c] = anonce[c];\n\t}\nif(write(fd_cap, packetout, PCAPREC_SIZE +M1WPA2DATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write EAPOL packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecapm1wpa2keyver3(int fd_cap, uint8_t *macsta, uint8_t *macap, uint8_t *anonce, uint8_t keyversion, uint16_t keylen, uint64_t rc)\n{\nstatic int c;\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic wpakey_t *wpak;\n\nstatic const uint8_t m1wpa2keyver3data[] =\n{\n0x88, 0x02, 0x3a, 0x01,\n0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n0x00, 0x00, 0x06, 0x00,\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n0x02, 0x03, 0x00, 0x5f, 0x02,\n0x00, 0x8b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xed, 0x57, 0x5c, 0x4b, 0xca, 0xa7, 0x7a, 0xf1, 0x9e, 0x32, 0x94, 0x32, 0x63, 0x91, 0xad, 0x7d,\n0x9c, 0xbc, 0x6a, 0xb4, 0xad, 0x04, 0xf1, 0x23, 0x80, 0xb4, 0x44, 0xbe, 0xb5, 0x8d, 0x2a, 0xdd,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00,\n};\n#define M1WPA2KEYVER3DATA_SIZE sizeof(m1wpa2keyver3data)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = M1WPA2KEYVER3DATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmemcpy(&packetout[PCAPREC_SIZE], &m1wpa2keyver3data, M1WPA2KEYVER3DATA_SIZE);\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmemcpy(mach->addr1, macsta, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\npacketout[PCAPREC_SIZE +0x22] = keyversion;\nwpak = (wpakey_t*)(packetout +PCAPREC_SIZE +0x26);\n#ifdef BIG_ENDIAN_HOST\nrc = byte_swap_64(rc);\n#endif\nwpak->keylen = keylen;\nwpak->replaycount = rc;\nfor(c = 0; c < 32; c++)\n\t{\n\tpacketout[PCAPREC_SIZE +0x33 +c] = anonce[c];\n\t}\nif(write(fd_cap, packetout, PCAPREC_SIZE +M1WPA2KEYVER3DATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write EAPOL packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecappmkidwpa2(int fd_cap, uint8_t *macsta, uint8_t *macap, uint8_t *pmkid)\n{\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic const uint8_t pmkiddata[] =\n{\n0x88, 0x02, 0x3a, 0x01,\n0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n0x00, 0x00, 0x06, 0x00,\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n0x02, 0x03, 0x00, 0x75, 0x02,\n0x00, 0x8a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x91, 0x1b, 0xd9, 0xcb, 0x88, 0x9a, 0xcf, 0x5b, 0x0f, 0x62, 0xbf, 0x0d, 0x87, 0x6c, 0x33, 0x30,\n0x8a, 0xbf, 0x58, 0x8b, 0xc3, 0x80, 0x4c, 0x15, 0xc0, 0x42, 0x3c, 0xf2, 0x4c, 0x07, 0xa7, 0x25,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x16,\n0xdd, 0x14, 0x00, 0x0f, 0xac, 0x04,\n0x7e, 0xf1, 0x33, 0x3c, 0xb6, 0xf9, 0x03, 0x73, 0xfc, 0x2a, 0xc7, 0x59, 0x37, 0xfd, 0x24, 0x3a\n};\n#define PMKIDDATA_SIZE sizeof(pmkiddata)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = PMKIDDATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmemcpy(&packetout[PCAPREC_SIZE], &pmkiddata, PMKIDDATA_SIZE);\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmemcpy(mach->addr1, macsta, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\nmemcpy(&packetout[PCAPREC_SIZE +0x8b], pmkid, 16);\nif(write(fd_cap, packetout, PCAPREC_SIZE +PMKIDDATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write EAPOL packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecapm2(int fd_cap, uint8_t *macsta, uint8_t *macap, uint8_t eapollen, uint8_t *eapol, uint8_t *mic)\n{\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\n\nstatic const uint8_t m2data[] =\n{\n0x88, 0x01, 0x3a, 0x01,\n0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n0x21, 0x22, 0x23, 0x24, 0x25, 0x26,\n0x00, 0x00, 0x06, 0x00,\n0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00, 0x88, 0x8e,\n};\n#define M2DATA_SIZE sizeof(m2data)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = M2DATA_SIZE +eapollen;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmemcpy(&packetout[PCAPREC_SIZE], &m2data, M2DATA_SIZE);\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmemcpy(mach->addr1, macap, 6);\nmemcpy(mach->addr2, macsta, 6);\nmemcpy(mach->addr3, macap, 6);\nmemcpy(&packetout[PCAPREC_SIZE +M2DATA_SIZE], eapol, eapollen);\nmemcpy(&packetout[PCAPREC_SIZE +M2DATA_SIZE +0x51], mic, 16);\nif(write(fd_cap, packetout, PCAPREC_SIZE +M2DATA_SIZE +eapollen) < 0)\n\t{\n\tperror(\"\\nfailed to write EAPOL packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecapbeaconwpa1(int fd_cap, uint8_t *macap, uint8_t essidlen, uint8_t *essid)\n{\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic capap_t *capap;\n\nstatic const uint8_t beacondata[] =\n{\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n0x03, 0x01, 0x06,\n0xdd, 0x16, 0x00, 0x50, 0xf2, 0x01, 0x01, 0x00, 0x00, 0x50, 0xf2, 0x04, 0x01, 0x00, 0x00, 0x50,\n0xf2, 0x04, 0x01, 0x00, 0x00, 0x50, 0xf2, 0x02,\n0xdd, 0x17, 0xff, 0xff, 0xff,\n0x00, 0xd9, 0x20, 0x21, 0x9b, 0x9b, 0x6a, 0xc9, 0x59, 0x49, 0x42, 0xe6, 0x55, 0x6a, 0x06, 0xa3, 0x23, 0x94, 0x2d, 0x94\n};\n#define BEACONDATA_SIZE sizeof(beacondata)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +BEACONDATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmach->type = IEEE80211_FTYPE_MGMT;\nmach->subtype = IEEE80211_STYPE_BEACON;\nmemcpy(mach->addr1, &mac_broadcast, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\nmach->sequence = mybeaconsequence++ << 4;\nif(mybeaconsequence >= 4096)\n\t{\n\tmybeaconsequence = 0;\n\t}\ncapap = (capap_t*)(packetout +PCAPREC_SIZE +MAC_SIZE_NORM);\ncapap->timestamp = myaponlinetime++;\ncapap->beaconintervall = 0x64;\ncapap->capabilities = 0x431;\npacketout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +1] = essidlen;\nmemcpy(&packetout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2], essid, essidlen);\nmemcpy(&packetout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen], &beacondata, BEACONDATA_SIZE);\npacketout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +0x0c] = myapchannel;\nif(write(fd_cap, packetout, PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +BEACONDATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write beacon packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecapbeaconwpa2(int fd_cap, uint8_t *macap, uint8_t essidlen, uint8_t *essid)\n{\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic capap_t *capap;\n\nstatic const uint8_t beacondata[] =\n{\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n0x03, 0x01, 0x06,\n0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00,\n0x00, 0x0f, 0xac, 0x02, 0x0c, 0x00,\n0xdd, 0x17, 0xff, 0xff, 0xff,\n0x00, 0xd9, 0x20, 0x21, 0x9b, 0x9b, 0x6a, 0xc9, 0x59, 0x49, 0x42, 0xe6, 0x55, 0x6a, 0x06, 0xa3, 0x23, 0x94, 0x2d, 0x94\n};\n#define BEACONDATA_SIZE sizeof(beacondata)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +BEACONDATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmach->type = IEEE80211_FTYPE_MGMT;\nmach->subtype = IEEE80211_STYPE_BEACON;\nmemcpy(mach->addr1, &mac_broadcast, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\nmach->sequence = mybeaconsequence++ << 4;\nif(mybeaconsequence >= 4096)\n\t{\n\tmybeaconsequence = 0;\n\t}\ncapap = (capap_t*)(packetout +PCAPREC_SIZE +MAC_SIZE_NORM);\ncapap->timestamp = myaponlinetime++;\ncapap->beaconintervall = 0x64;\ncapap->capabilities = 0x431;\npacketout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +1] = essidlen;\nmemcpy(&packetout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2], essid, essidlen);\nmemcpy(&packetout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen], &beacondata, BEACONDATA_SIZE);\npacketout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +0x0c] = myapchannel;\nif(write(fd_cap, packetout, PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +BEACONDATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write beacon packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecapbeaconwpa2keyver3(int fd_cap, uint8_t *macap, uint8_t essidlen, uint8_t *essid)\n{\nstatic pcaprec_hdr_t *pcaph;\nstatic mac_t *mach;\nstatic capap_t *capap;\n\nstatic const uint8_t beacondata[] =\n{\n0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x8c, 0x12, 0x98, 0x24,\n0x03, 0x01, 0x06,\n0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00,\n0x00, 0x0f, 0xac, 0x06, 0xcc, 0x00,\n0xdd, 0x17, 0xff, 0xff, 0xff,\n0x00, 0xd9, 0x20, 0x21, 0x9b, 0x9b, 0x6a, 0xc9, 0x59, 0x49, 0x42, 0xe6, 0x55, 0x6a, 0x06, 0xa3, 0x23, 0x94, 0x2d, 0x94\n};\n#define BEACONDATA_SIZE sizeof(beacondata)\n\nstatic uint8_t packetout[0xff];\n\nmemset(&packetout, 0, 0xff);\npcaph = (pcaprec_hdr_t*)packetout;\npcaph->ts_sec = timestamp /1000000;\npcaph->ts_usec = timestamp %1000000;\npcaph->incl_len = MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +BEACONDATA_SIZE;\npcaph->orig_len = pcaph->incl_len;\ntimestamp++;\nmach = (mac_t*)(packetout +PCAPREC_SIZE);\nmach->type = IEEE80211_FTYPE_MGMT;\nmach->subtype = IEEE80211_STYPE_BEACON;\nmemcpy(mach->addr1, &mac_broadcast, 6);\nmemcpy(mach->addr2, macap, 6);\nmemcpy(mach->addr3, macap, 6);\nmach->sequence = mybeaconsequence++ << 4;\nif(mybeaconsequence >= 4096)\n\t{\n\tmybeaconsequence = 0;\n\t}\ncapap = (capap_t*)(packetout +PCAPREC_SIZE +MAC_SIZE_NORM);\ncapap->timestamp = myaponlinetime++;\ncapap->beaconintervall = 0x64;\ncapap->capabilities = 0x431;\npacketout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +1] = essidlen;\nmemcpy(&packetout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2], essid, essidlen);\nmemcpy(&packetout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen], &beacondata, BEACONDATA_SIZE);\npacketout[PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +0x0c] = myapchannel;\nif(write(fd_cap, packetout, PCAPREC_SIZE +MAC_SIZE_NORM +CAPABILITIESAP_SIZE +2 +essidlen +BEACONDATA_SIZE) < 0)\n\t{\n\tperror(\"\\nfailed to write beacon packet\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic uint16_t getfield(char *lineptr, size_t bufflen, uint8_t *buff)\n{\nstatic size_t p;\nstatic uint8_t idx0;\nstatic uint8_t idx1;\n\nstatic const uint8_t hashmap[] =\n{\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567\n0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;<=>?\n0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PQRSTUVW\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XYZ[\\]^_\n0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // `abcdefg\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // hijklmno\n};\n\nmemset(buff, 0, bufflen);\np = 0;\nwhile((lineptr[p] != '*') && (lineptr[p] != 0) && (p /2 <= bufflen))\n\t{\n\tif(! isxdigit((unsigned char)lineptr[p +0])) return 0;\n\tif(! isxdigit((unsigned char)lineptr[p +1])) return 0;\n\tif((lineptr[p +1] == '*') || (lineptr[p +1] == 0)) return 0;\n\tidx0 = ((uint8_t)lineptr[p +0] &0x1F) ^0x10;\n\tidx1 = ((uint8_t)lineptr[p +1] &0x1F) ^0x10;\n\tbuff[p /2] = (uint8_t)(hashmap[idx0] <<4) | hashmap[idx1];\n\tp += 2;\n\tif((p /2) > PMKIDEAPOL_BUFFER_LEN) return 0;\n\t}\nreturn p /2;\n}\n/*===========================================================================*/\nstatic void processpmkideapolfile(char *pmkideapolname, int fd_cap)\n{\nstatic int len;\nstatic int oflen;\nstatic int aktread = 1;\nstatic FILE *fhpmkideapol;\nstatic uint16_t essidlen;\nstatic uint16_t noncelen;\nstatic uint16_t eapauthlen;\nstatic uint16_t mplen;\nstatic int fd_singlecap;\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint16_t keyinfo;\nstatic uint8_t keyver;\nstatic uint64_t rc;\n\nstatic const char wpa01[] = { \"WPA*01*\" };\nstatic const char wpa02[] = { \"WPA*02*\" };\n\nstatic char linein[PMKIDEAPOL_LINE_LEN +1];\nstatic uint8_t buffer[PMKIDEAPOL_LINE_LEN +1];\nstatic uint8_t macap[6];\nstatic uint8_t macsta[6];\nstatic uint8_t hash[16];\nstatic uint8_t anonce[32];\nstatic uint8_t eapol[EAPOL_AUTHLEN_MAX];\nstatic uint8_t essid[ESSID_LEN_MAX];\nstatic char singlecapname[PATH_MAX +2];\n\nif((fhpmkideapol = fopen(pmkideapolname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening hash file failed %s\\n\", pmkideapolname);\n\treturn;\n\t}\nwhile(1)\n\t{\n\tif((len = fgetline(fhpmkideapol, PMKIDEAPOL_LINE_LEN, linein)) == -1) break;\n\taktread++;\n\tif(len < 68)\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif((memcmp(&linein, &wpa01, 7) != 0) && (memcmp(&linein, &wpa02, 7) != 0))\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif((linein[39] != '*') && (linein[52] != '*') && (linein[65] != '*'))\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(getfield(&linein[7], PMKIDEAPOL_LINE_LEN, buffer) != 16)\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(&hash, &buffer, 16);\n\n\tif(getfield(&linein[40], PMKIDEAPOL_LINE_LEN, buffer) != 6)\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(&macap, &buffer, 6);\n\tif(getfield(&linein[53], PMKIDEAPOL_LINE_LEN, buffer) != 6)\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(&macsta, &buffer, 6);\n\tessidlen = getfield(&linein[66], PMKIDEAPOL_LINE_LEN, buffer);\n\tif(essidlen > 32)\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(&essid, &buffer, essidlen);\n\tif(memcmp(&linein, &wpa01, 7) == 0)\n\t\t{\n\t\tif(fd_cap == 0)\n\t\t\t{\n\t\t\tsnprintf(singlecapname, 18, \"%02x%02x%02x%02x%02x%02x.cap\", macsta[0], macsta[1], macsta[2], macsta[3], macsta[4], macsta[5]);\n\t\t\tfd_singlecap = hcxopencapdump(singlecapname);\n\t\t\tif(fd_singlecap == -1)\n\t\t\t\t{\n\t\t\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\twritecapbeaconwpa2(fd_singlecap, macap, essidlen, essid);\n\t\t\twritecappmkidwpa2(fd_singlecap, macsta, macap, hash);\n\t\t\tpmkideapolcapwritten++;\n\t\t\tclose(fd_singlecap);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_cap, macap, essidlen, essid);\n\t\t\twritecappmkidwpa2(fd_cap, macsta, macap, hash);\n\t\t\tpmkideapolcapwritten++;\n\t\t\t}\n\t\t}\n\telse if(memcmp(&linein, &wpa02, 7) == 0)\n\t\t{\n\t\toflen = 66 +essidlen *2 +1;\n\t\tnoncelen = getfield(&linein[oflen], PMKIDEAPOL_LINE_LEN, buffer);\n\t\tif(noncelen > 32)\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tmemcpy(&anonce, &buffer, 32);\n\t\toflen += 65;\n\t\teapauthlen = getfield(&linein[oflen], PMKIDEAPOL_LINE_LEN, buffer);\n\t\tif(eapauthlen > EAPOL_AUTHLEN_MAX)\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tmemcpy(&eapol, &buffer, eapauthlen);\n\t\toflen += eapauthlen *2 +1;\n\t\tmplen = getfield(&linein[oflen], PMKIDEAPOL_LINE_LEN, buffer);\n\t\tif(mplen > 1)\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\teapa = (eapauth_t*)eapol;\n\t\tif(eapa->type != EAPOL_KEY)\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(eapauthlen != ntohs(eapa->len) +4)\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\twpak = (wpakey_t*)(eapol +EAPAUTH_SIZE);\n\t\tkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\t\tif((keyver == 0) || (keyver > 3))\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tkeyinfo = (getkeyinfo(ntohs(wpak->keyinfo)));\n\t\tif(keyinfo == 3)\n\t\t\t{\n\t\t\tpmkideapolcapskipped++;\n\t\t\tcontinue;\n\t\t\t}\n\t\trc = wpak->replaycount;\n\t\t#ifdef BIG_ENDIAN_HOST\n\t\trc = byte_swap_64(rc);\n\t\t#endif\n\t\tif(keyinfo == 4)\n\t\t\t{\n\t\t\trc--;\n\t\t\t}\n\n\t\tif(fd_cap == 0)\n\t\t\t{\n\t\t\tsnprintf(singlecapname, 18, \"%02x%02x%02x%02x%02x%02x.cap\", macsta[0], macsta[1], macsta[2], macsta[3], macsta[4], macsta[5]);\n\t\t\tfd_singlecap = hcxopencapdump(singlecapname);\n\t\t\tif(fd_singlecap == -1)\n\t\t\t\t{\n\t\t\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\tif(keyver == 1)\n\t\t\t\t{\n\t\t\t\twritecapbeaconwpa1(fd_singlecap, macap, essidlen, essid);\n\t\t\t\twritecapm1wpa1(fd_singlecap, macsta, macap, anonce, eapa->version, wpak->keylen, rc);\n\t\t\t\twritecapm2(fd_singlecap, macsta, macap, eapauthlen, eapol, hash);\n\t\t\t\tpmkideapolcapwritten++;\n\t\t\t\t}\n\t\t\telse if(keyver == 2)\n\t\t\t\t{\n\t\t\t\twritecapbeaconwpa2(fd_singlecap, macap, essidlen, essid);\n\t\t\t\twritecapm1wpa2(fd_singlecap, macsta, macap, anonce, eapa->version, wpak->keylen, rc);\n\t\t\t\twritecapm2(fd_singlecap, macsta, macap, eapauthlen, eapol, hash);\n\t\t\t\tpmkideapolcapwritten++;\n\t\t\t\t}\n\t\t\telse if(keyver == 3)\n\t\t\t\t{\n\t\t\t\twritecapbeaconwpa2keyver3(fd_singlecap, macap, essidlen, essid);\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, macsta, macap, anonce, eapa->version, wpak->keylen, rc);\n\t\t\t\twritecapm2(fd_singlecap, macsta, macap, eapauthlen, eapol, hash);\n\t\t\t\tpmkideapolcapwritten++;\n\t\t\t\t}\n\t\t\tclose(fd_singlecap);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif(keyver == 1)\n\t\t\t\t{\n\t\t\t\twritecapbeaconwpa1(fd_cap, macap, essidlen, essid);\n\t\t\t\twritecapm1wpa1(fd_cap, macsta, macap, anonce, eapa->version, wpak->keylen, rc);\n\t\t\t\twritecapm2(fd_cap, macsta, macap, eapauthlen, eapol, hash);\n\t\t\t\tpmkideapolcapwritten++;\n\t\t\t\t}\n\t\t\telse if(keyver == 2)\n\t\t\t\t{\n\t\t\t\twritecapbeaconwpa2(fd_cap, macap, essidlen, essid);\n\t\t\t\twritecapm1wpa2(fd_cap, macsta, macap, anonce, eapa->version, wpak->keylen, rc);\n\t\t\t\twritecapm2(fd_cap, macsta, macap, eapauthlen, eapol, hash);\n\t\t\t\tpmkideapolcapwritten++;\n\t\t\t\t}\n\t\t\telse if(keyver == 3)\n\t\t\t\t{\n\t\t\t\twritecapbeaconwpa2keyver3(fd_cap, macap, essidlen, essid);\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, macsta, macap, anonce, eapa->version, wpak->keylen, rc);\n\t\t\t\twritecapm2(fd_cap, macsta, macap, eapauthlen, eapol, hash);\n\t\t\t\tpmkideapolcapwritten++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tpmkideapolcapskipped++;\n\t\tcontinue;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processpmkidfile(char *pmkidname, int fd_cap)\n{\nstatic int len;\nstatic int aktread = 1;\nstatic int essidlen;\nstatic int fd_singlecap;\nstatic FILE *fhpmkid;\n\nstatic char linein[PMKID_LINE_LEN];\nstatic uint8_t macap[6];\nstatic uint8_t macsta[6];\nstatic uint8_t pmkid[16];\nstatic uint8_t essid[ESSID_LEN_MAX];\nstatic char singlecapname[PATH_MAX +2];\n\nif((fhpmkid = fopen(pmkidname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening hash file failed %s\\n\", pmkidname);\n\treturn;\n\t}\nwhile(1)\n\t{\n\tif((len = fgetline(fhpmkid, PMKID_LINE_LEN, linein)) == -1)\n\t\t{\n\t\tbreak;\n\t\t}\n\tif((len < 61) || ((len > 59 +(ESSID_LEN_MAX *2))))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(((linein[32] != '*') && (linein[45] != '*') && (linein[58] != '*')) && ((linein[32] != ':') && (linein[45] != ':') && (linein[58] != ':')))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tessidlen = len -59;\n\tif((essidlen %2) != 0)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif((essidlen < 2) ||  (essidlen > 64))\n\t\t{\n\t\tfprintf(stderr, \"reading ESSID %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hex2bin(&linein[0], pmkid, 16) == -1)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hex2bin(&linein[33], macap, 6) == -1)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hex2bin(&linein[46], macsta, 6) == -1)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hex2bin(&linein[59], essid, essidlen/2) == -1)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\tpmkcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(fd_cap == 0)\n\t\t{\n\t\tsnprintf(singlecapname, 18, \"%02x%02x%02x%02x%02x%02x.cap\", macsta[0], macsta[1], macsta[2], macsta[3], macsta[4], macsta[5]);\n\t\tfd_singlecap = hcxopencapdump(singlecapname);\n\t\tif(fd_singlecap == -1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\twritecapbeaconwpa2(fd_singlecap, macap, essidlen /2, essid);\n\t\twritecappmkidwpa2(fd_singlecap, macsta, macap, pmkid);\n\t\tpmkcapwritten++;\n\t\tclose(fd_singlecap);\n\t\t}\n\telse\n\t\t{\n\t\twritecapbeaconwpa2(fd_cap, macap, essidlen /2, essid);\n\t\twritecappmkidwpa2(fd_cap, macsta, macap, pmkid);\n\t\tpmkcapwritten++;\n\t\t}\n\taktread++;\n\t}\nfclose(fhpmkid);\nreturn;\n}\n/*===========================================================================*/\nstatic void processhccapxfile(char *hccapxname, int fd_cap)\n{\nstatic struct stat statinfo;\nstatic hccapx_t *hcxptr;\nstatic int fd_singlecap;\nstatic FILE *fhhcx;\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint16_t keyinfo;\nstatic uint8_t keyver;\nstatic uint64_t rc;\n\nstatic uint8_t hcxdata[HCCAPX_SIZE];\nstatic char singlecapname[PATH_MAX +2];\n\nif(stat(hccapxname, &statinfo) != 0)\n\t{\n\tfprintf(stderr, \"can't stat %s\\n\", hccapxname);\n\treturn;\n\t}\nif((statinfo.st_size %HCCAPX_SIZE) != 0)\n\t{\n\tfprintf(stderr, \"file corrupt\\n\");\n\treturn;\n\t}\nif((fhhcx = fopen(hccapxname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"error opening file %s\", hccapxname);\n\treturn;\n\t}\nhcxptr = (hccapx_t*)hcxdata;\nwhile(fread(&hcxdata, HCCAPX_SIZE, 1, fhhcx) == 1)\n\t{\n\tif(hcxptr->signature != HCCAPX_SIGNATURE)\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif((hcxptr->version != 3) && (hcxptr->version != 4))\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif((hcxptr->essid_len == 0) || (hcxptr->essid_len > ESSID_LEN_MAX))\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\teapa = (eapauth_t*)hcxptr->eapol;\n\tif(eapa->type != EAPOL_KEY)\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hcxptr->eapol_len != ntohs(eapa->len) +4)\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\twpak = (wpakey_t*)(hcxptr->eapol +EAPAUTH_SIZE);\n\tkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\tif(keyver != hcxptr->keyver)\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(keyver > 3)\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\tkeyinfo = (getkeyinfo(ntohs(wpak->keyinfo)));\n\tif(keyinfo == 3)\n\t\t{\n\t\thccapxcapskipped++;\n\t\tcontinue;\n\t\t}\n\trc = wpak->replaycount;\n\t#ifdef BIG_ENDIAN_HOST\n\trc = byte_swap_64(rc);\n\t#endif\n\tif(keyinfo == 4)\n\t\t{\n\t\trc--;\n\t\t}\n\tif(fd_cap == 0)\n\t\t{\n\t\tsnprintf(singlecapname, 18, \"%02x%02x%02x%02x%02x%02x.cap\", hcxptr->mac_sta[0], hcxptr->mac_sta[1], hcxptr->mac_sta[2], hcxptr->mac_sta[3], hcxptr->mac_sta[4], hcxptr->mac_sta[5]);\n\t\tfd_singlecap = hcxopencapdump(singlecapname);\n\t\tif(fd_singlecap == -1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif(keyver == 1)\n\t\t\t{\n\t\t\twritecapbeaconwpa1(fd_singlecap, hcxptr->mac_ap, hcxptr->essid_len, hcxptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcxptr->nonce_ap, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_ap, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_sta, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->eapol_len, hcxptr->eapol, hcxptr->keymic);\n\t\t\thccapxcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 2)\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_singlecap, hcxptr->mac_ap, hcxptr->essid_len, hcxptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcxptr->nonce_ap, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_ap, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_sta, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->eapol_len, hcxptr->eapol, hcxptr->keymic);\n\t\t\thccapxcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 3)\n\t\t\t{\n\t\t\twritecapbeaconwpa2keyver3(fd_singlecap, hcxptr->mac_ap, hcxptr->essid_len, hcxptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcxptr->nonce_ap, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_ap, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_sta, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->eapol_len, hcxptr->eapol, hcxptr->keymic);\n\t\t\thccapxcapwritten++;\n\t\t\t}\n\t\tclose(fd_singlecap);\n\t\t}\n\telse\n\t\t{\n\t\tif(keyver == 1)\n\t\t\t{\n\t\t\twritecapbeaconwpa1(fd_cap, hcxptr->mac_ap, hcxptr->essid_len, hcxptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcxptr->nonce_ap, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_ap, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_sta, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->eapol_len, hcxptr->eapol, hcxptr->keymic);\n\t\t\thccapxcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 2)\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_cap, hcxptr->mac_ap, hcxptr->essid_len, hcxptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcxptr->nonce_ap, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_ap, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_sta, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->eapol_len, hcxptr->eapol, hcxptr->keymic);\n\t\t\thccapxcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 3)\n\t\t\t{\n\t\t\twritecapbeaconwpa2keyver3(fd_cap, hcxptr->mac_ap, hcxptr->essid_len, hcxptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcxptr->nonce_ap, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_ap, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->nonce_sta, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcxptr->mac_sta, hcxptr->mac_ap, hcxptr->eapol_len, hcxptr->eapol, hcxptr->keymic);\n\t\t\thccapxcapwritten++;\n\t\t\t}\n\t\t}\n\t}\nfclose(fhhcx);\nreturn;\n}\n/*===========================================================================*/\nstatic void processhccapfile(char *hccapname, int fd_cap)\n{\nstatic struct stat statinfo;\nstatic hccap_t *hcptr;\nstatic int fd_singlecap;\nstatic FILE *fhhc;\nstatic uint8_t essidlen;\nstatic int c;\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint16_t keyinfo;\nstatic uint8_t keyver;\nstatic uint64_t rc;\n\nstatic uint8_t hcdata[HCCAP_SIZE];\nstatic char singlecapname[PATH_MAX +2];\n\nif(stat(hccapname, &statinfo) != 0)\n\t{\n\tfprintf(stderr, \"can't stat %s\\n\", hccapname);\n\treturn;\n\t}\n\nif((statinfo.st_size %HCCAP_SIZE) != 0)\n\t{\n\tfprintf(stderr, \"file corrupt\\n\");\n\treturn;\n\t}\n\nif((fhhc = fopen(hccapname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"error opening file %s\", hccapname);\n\treturn;\n\t}\n\nhcptr = (hccap_t*)hcdata;\nwhile(fread(&hcdata, HCCAP_SIZE, 1, fhhc) == 1)\n\t{\n\tessidlen = 0;\n\tfor(c = 0; c < ESSID_LEN_MAX; c++)\n\t\t{\n\t\tif(hcptr->essid[c] == 0)\n\t\t\t{\n\t\t\tbreak;\n\t\t\t}\n\t\tessidlen++;\n\t\t}\n\n\tif((essidlen == 0) || (essidlen > ESSID_LEN_MAX))\n\t\t{\n\t\thccapcapskipped++;\n\t\tcontinue;\n\t\t}\n\n\teapa = (eapauth_t*)hcptr->eapol;\n\tif(eapa->type != EAPOL_KEY)\n\t\t{\n\t\thccapcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hcptr->eapol_size != ntohs(eapa->len) +4)\n\t\t{\n\t\thccapcapskipped++;\n\t\tcontinue;\n\t\t}\n\n\twpak = (wpakey_t*)(hcptr->eapol +EAPAUTH_SIZE);\n\tkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\tif(keyver != hcptr->keyver)\n\t\t{\n\t\thccapcapskipped++;\n\t\tcontinue;\n\t\t}\n\tif(keyver > 3)\n\t\t{\n\t\thccapcapskipped++;\n\t\tcontinue;\n\t\t}\n\tkeyinfo = (getkeyinfo(ntohs(wpak->keyinfo)));\n\tif(keyinfo == 3)\n\t\t{\n\t\thccapcapskipped++;\n\t\tcontinue;\n\t\t}\n\trc = wpak->replaycount;\n\t#ifdef BIG_ENDIAN_HOST\n\trc = byte_swap_64(rc);\n\t#endif\n\tif(keyinfo == 4)\n\t\t{\n\t\trc--;\n\t\t}\n\tif(fd_cap == 0)\n\t\t{\n\t\tsnprintf(singlecapname, 18, \"%02x%02x%02x%02x%02x%02x.cap\", hcptr->mac2[0], hcptr->mac2[1], hcptr->mac2[2], hcptr->mac2[3], hcptr->mac2[4], hcptr->mac2[5]);\n\t\tfd_singlecap = hcxopencapdump(singlecapname);\n\t\tif(fd_singlecap == -1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif(keyver == 1)\n\t\t\t{\n\t\t\twritecapbeaconwpa1(fd_singlecap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 2)\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_singlecap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 3)\n\t\t\t{\n\t\t\twritecapbeaconwpa2keyver3(fd_singlecap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\tclose(fd_singlecap);\n\t\t}\n\telse\n\t\t{\n\t\tif(keyver == 1)\n\t\t\t{\n\t\t\twritecapbeaconwpa1(fd_cap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\n\t\t\twritecapm2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 2)\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_cap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 3)\n\t\t\t{\n\t\t\twritecapbeaconwpa2keyver3(fd_cap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\t}\n\t}\nfclose(fhhc);\nreturn;\n}\n/*===========================================================================*/\nstatic void processjohnfile(char *johnname, int fd_cap)\n{\nstatic int len;\nstatic int i;\nstatic FILE *fhjohn;\nstatic int essidlen;\nstatic int hashlen;\nstatic char *ptressid;\nstatic char *ptreapol;\nstatic char *ptreapol2;\nstatic uint8_t *johnptr;\nstatic const char *pos;\nstatic hccap_t *hcptr;\nstatic int fd_singlecap;\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint16_t keyinfo;\nstatic uint8_t keyver;\nstatic uint64_t rc;\n\n\nstatic const char itoa64[65] = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nstatic char singlecapname[PATH_MAX +2];\nstatic char linein[JOHN_LINE_LEN];\nstatic uint8_t hcdata[HCCAP_SIZE];\nstatic unsigned char atoi64[0x100];\n\nif((fhjohn = fopen(johnname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening hash file failed %s\\n\", johnname);\n\treturn;\n\t}\n\nmemset(atoi64, 0x7F, sizeof(atoi64));\nfor(pos = itoa64; pos <= &itoa64[63]; pos++)\n\t{\n\tatoi64[ARCH_INDEX(*pos)] = pos - itoa64;\n\t}\n\nhcptr = (hccap_t*)hcdata;\nwhile(1)\n\t{\n\tif((len = fgetline(fhjohn, JOHN_LINE_LEN, linein)) == -1)\n\t\t{\n\t\tbreak;\n\t\t}\n\tif(len < 534)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tptressid =strstr(linein, \":$WPAPSK$\");\n\tif(ptressid == NULL)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tptressid += 9;\n\tptreapol =strrchr(linein, '#');\n\tif(ptreapol == NULL)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tptreapol++;\n\tessidlen = ptreapol -ptressid -1;\n\tif((essidlen == 0) || (essidlen > ESSID_LEN_MAX))\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tptreapol2 = strchr(ptreapol, ':');\n\tif(ptreapol2 == NULL)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\thashlen = ptreapol2 - ptreapol;\n\tif(hashlen != 475)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tmemset(&hcdata, 0, HCCAP_SIZE);\n\tmemcpy(&hcdata, ptressid, essidlen);\n\tjohnptr = hcdata +36;\n\tfor (i = 0; i < 118; i++)\n\t\t{\n\t\tjohnptr[0] = (atoi64[ARCH_INDEX(ptreapol[0])] << 2) | (atoi64[ARCH_INDEX(ptreapol[1])] >> 4);\n\t\tjohnptr[1] = (atoi64[ARCH_INDEX(ptreapol[1])] << 4) | (atoi64[ARCH_INDEX(ptreapol[2])] >> 2);\n\t\tjohnptr[2] = (atoi64[ARCH_INDEX(ptreapol[2])] << 6) | (atoi64[ARCH_INDEX(ptreapol[3])]);\n\t\tjohnptr += 3;\n\t\tptreapol += 4;\n\t\t}\n\tjohnptr[0] = (atoi64[ARCH_INDEX(ptreapol[0])] << 2) | (atoi64[ARCH_INDEX(ptreapol[1])] >> 4);\n\tjohnptr[1] = (atoi64[ARCH_INDEX(ptreapol[1])] << 4) | (atoi64[ARCH_INDEX(ptreapol[2])] >> 2);\n\n\teapa = (eapauth_t*)hcptr->eapol;\n\tif(eapa->type != EAPOL_KEY)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tif(hcptr->eapol_size != ntohs(eapa->len) +4)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\n\twpak = (wpakey_t*)(hcptr->eapol +EAPAUTH_SIZE);\n\tkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\tif(keyver != hcptr->keyver)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tif(keyver > 3)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\tkeyinfo = (getkeyinfo(ntohs(wpak->keyinfo)));\n\tif(keyinfo == 3)\n\t\t{\n\t\tjohnskipped++;\n\t\tcontinue;\n\t\t}\n\trc = wpak->replaycount;\n\t#ifdef BIG_ENDIAN_HOST\n\trc = byte_swap_64(rc);\n\t#endif\n\tif(keyinfo == 4)\n\t\t{\n\t\trc--;\n\t\t}\n\tif(fd_cap == 0)\n\t\t{\n\t\tsnprintf(singlecapname, 18, \"%02x%02x%02x%02x%02x%02x.cap\", hcptr->mac2[0], hcptr->mac2[1], hcptr->mac2[2], hcptr->mac2[3], hcptr->mac2[4], hcptr->mac2[5]);\n\t\tfd_singlecap = hcxopencapdump(singlecapname);\n\t\tif(fd_singlecap == -1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif(keyver == 1)\n\t\t\t{\n\t\t\twritecapbeaconwpa1(fd_singlecap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 2)\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_singlecap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 3)\n\t\t\t{\n\t\t\twritecapbeaconwpa2keyver3(fd_singlecap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_singlecap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\tclose(fd_singlecap);\n\t\t}\n\telse\n\t\t{\n\t\tif(keyver == 1)\n\t\t\t{\n\t\t\twritecapbeaconwpa1(fd_cap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa1(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 2)\n\t\t\t{\n\t\t\twritecapbeaconwpa2(fd_cap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\telse if(keyver == 3)\n\t\t\t{\n\t\t\twritecapbeaconwpa2keyver3(fd_cap, hcptr->mac1, essidlen, (uint8_t*)hcptr->essid);\n\t\t\tif(memcmp(wpak->nonce, hcptr->nonce1, 32) != 0)\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce1, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\twritecapm1wpa2keyver3(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->nonce2, eapa->version, wpak->keylen, rc);\n\t\t\t\t}\n\t\t\twritecapm2(fd_cap, hcptr->mac2, hcptr->mac1, hcptr->eapol_size, hcptr->eapol, hcptr->keymic);\n\t\t\thccapcapwritten++;\n\t\t\t}\n\t\t}\n\t}\nfclose(fhjohn);\nreturn;\n}\n/*===========================================================================*/\nstatic void removeemptycap(char *filenametoremove)\n{\nstruct stat statinfo;\n\nif(filenametoremove == NULL)\n\t{\n\treturn;\n\t}\nif(stat(filenametoremove, &statinfo) != 0)\n\t{\n\treturn;\n\t}\nif(statinfo.st_size == 24)\n\t{\n\tremove(filenametoremove);\n\treturn;\n\t}\nreturn;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic void version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage:\\n\"\n\t\"%s <options>\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-c <file> : output cap file\\n\"\n\t\"            if no cap file is selected, output will be written to single cap files\\n\"\n\t\"            format: mac_sta.cap (mac_sta.cap_x)\\n\"\n\t\"-h        : show this help\\n\"\n\t\"-v        : show version\\n\"\n\t\"\\n\"\n\t\"--pmkid-eapol=<file> : input PMKID EAPOL (22000) combi hash file\\n\"\n\t\"--pmkid=<file>       : input deprecated PMKID (16800) hash file\\n\"\n\t\"--hccapx=<file>      : input deprecated hccapx (2500) hash file\\n\"\n\t\"--hccap=<file>       : input ancient hccap (2500) file\\n\"\n\t\"--john=<file>        : input John the Ripper WPAPSK hash file\\n\"\n\t\"--help               : show this help\\n\"\n\t\"--version            : show version\\n\"\n\t\"\\n\"\n\t\"Important notice:\\n\"\n\t\"Conversion from a dump file to a hash file is not loss less.\\n\"\n\t\"Hash files that contain EAPOL M3 MESSAGEs can't be converted back to a cap file.\\n\"\n\t\"\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic int fd_cap = 0;\nstatic char *pmkideapolname = NULL;\nstatic char *pmkidname = NULL;\nstatic char *hccapxname = NULL;\nstatic char *hccapname = NULL;\nstatic char *johnname = NULL;\nstatic char *capname = NULL;\n\nstatic const char *short_options = \"c:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"pmkid-eapol\",\t\t\trequired_argument,\tNULL,\tHCXP_PMKID_EAPOL},\n\t{\"pmkid\",\t\t\trequired_argument,\tNULL,\tHCXP_PMKID},\n\t{\"hccapx\",\t\t\trequired_argument,\tNULL,\tHCXP_HCCAPX},\n\t{\"hccap\",\t\t\trequired_argument,\tNULL,\tHCXP_HCCAP},\n\t{\"john\",\t\t\trequired_argument,\tNULL,\tHCXP_JOHN},\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCXP_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCXP_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\n\nwhile((auswahl = getopt_long (argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCXP_PMKID_EAPOL:\n\t\tpmkideapolname = optarg;\n\t\tbreak;\n\n\t\tcase HCXP_PMKID:\n\t\tpmkidname = optarg;\n\t\tbreak;\n\n\t\tcase HCXP_HCCAPX:\n\t\thccapxname = optarg;\n\t\tbreak;\n\n\t\tcase HCXP_HCCAP:\n\t\thccapname = optarg;\n\t\tbreak;\n\n\t\tcase HCXP_JOHN:\n\t\tjohnname = optarg;\n\t\tbreak;\n\n\t\tcase HCXP_CAP:\n\t\tcapname = optarg;\n\t\tbreak;\n\n\t\tcase HCXP_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCXP_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\n\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\n\");\n\treturn EXIT_SUCCESS;\n\t}\n\nglobalinit();\n\nif(capname != NULL)\n\t{\n\tfd_cap = hcxopencapdump(capname);\n\tif(fd_cap == -1)\n\t\t{\n\t\tfprintf(stderr, \"could not create cap file\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(pmkideapolname != NULL)\n\t{\n\tprocesspmkideapolfile(pmkideapolname, fd_cap);\n\t}\n\nif(pmkidname != NULL)\n\t{\n\tprocesspmkidfile(pmkidname, fd_cap);\n\t}\n\nif(hccapxname != NULL)\n\t{\n\tprocesshccapxfile(hccapxname, fd_cap);\n\t}\n\nif(hccapname != NULL)\n\t{\n\tprocesshccapfile(hccapname, fd_cap);\n\t}\n\nif(johnname != NULL)\n\t{\n\tprocessjohnfile(johnname, fd_cap);\n\t}\n\nif(fd_cap != 0)\n\t{\n\tclose(fd_cap);\n\tremoveemptycap(capname);\n\t}\nif(pmkideapolcapwritten > 0)\n\t{\n\tfprintf(stdout, \"PMKIDs/EAPOL messages written to capfile(s): %llu (%llu skipped)\\n\", pmkideapolcapwritten, pmkideapolcapskipped);\n\t}\nif(pmkcapwritten > 0)\n\t{\n\tfprintf(stdout, \"PMKIDs written to capfile(s): %llu (%llu skipped)\\n\", pmkcapwritten, pmkcapskipped);\n\t}\nif(hccapxcapwritten > 0)\n\t{\n\tfprintf(stdout, \"EAPOLs written to capfile(s): %llu (%llu skipped)\\n\", hccapxcapwritten, hccapxcapskipped);\n\t}\nif(hccapcapwritten > 0)\n\t{\n\tfprintf(stdout, \"EAPOLs written to capfile(s): %llu (%llu skipped)\\n\", hccapcapwritten, hccapcapskipped);\n\t}\nif(johnwritten > 0)\n\t{\n\tfprintf(stdout, \"EAPOLs written to capfile(s): %llu (%llu skipped)\\n\", johnwritten, johnskipped);\n\t}\n\nreturn EXIT_SUCCESS;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "hcxhashtool.c",
          "type": "blob",
          "size": 99.9033203125,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <regex.h>\n\n#if defined (__APPLE__) || defined(__OpenBSD__)\n#include <sys/socket.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#else\n#include <arpa/inet.h>\n#endif\n\n#include <curl/curl.h>\n#include <openssl/core.h>\n#include <openssl/crypto.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <openssl/params.h>\n#include <openssl/types.h>\n\n#include \"include/hcxhashtool.h\"\n#include \"include/strings.c\"\n#include \"include/fileops.c\"\n#include \"include/ieee80211.c\"\n#include \"include/byteops.c\"\n\n/*===========================================================================*/\nstruct hccapx_s\n{\n uint32_t\tsignature;\n#define HCCAPX_SIGNATURE 0x58504348\n uint32_t\tversion;\n#define HCCAPX_VERSION 4\n uint8_t\tmessage_pair;\n uint8_t\tessid_len;\n uint8_t\tessid[32];\n uint8_t\tkeyver;\n uint8_t\tkeymic[16];\n uint8_t\tap[6];\n uint8_t\tanonce[32];\n uint8_t\tclient[6];\n uint8_t\tsnonce[32];\n uint16_t\teapol_len;\n uint8_t\teapol[256];\n} __attribute__((packed));\ntypedef struct hccapx_s hccapx_t;\n#define\tHCCAPX_SIZE (sizeof(hccapx_t))\n/*---------------------------------------------------------------------------*/\nstruct hccap_s\n{\n  char essid[36];\n  unsigned char ap[6];\n  unsigned char client[6];\n  unsigned char snonce[32];\n  unsigned char anonce[32];\n  unsigned char eapol[256];\n  int eapol_size;\n  int keyver;\n  unsigned char keymic[16];\n};\ntypedef struct hccap_s hccap_t;\n#define\tHCCAP_SIZE (sizeof(hccap_t))\n/*===========================================================================*/\n/* global var */\nstatic const char *usedoui;\nstatic int ouicount;\nstatic int ouilistcount;\nstatic ouilist_t *ouilist;\nstatic hashlist_t *hashlist;\nstatic long int pbkdf2count;\nstatic long int pbkdf2readerrorcount;\nstatic long int hashlistcount;\nstatic long int readcount;\nstatic long int readerrorcount;\nstatic long int correctedcount;\nstatic long int pmkideapolcount;\nstatic long int pmkidcount;\nstatic long int eapolcount;\nstatic long int pmkidwrittencount;\nstatic long int eapolwrittencount;\nstatic long int essidwrittencount;\nstatic long int essidrawwrittencount;\nstatic long int hccapxwrittencount;\nstatic long int hccapwrittencount;\nstatic long int johnpmkidwrittencount;\nstatic long int johneapolwrittencount;\n\nstatic EVP_MAC *hmac;\nstatic EVP_MAC *cmac;\nstatic EVP_MAC_CTX *ctxhmac;\nstatic EVP_MAC_CTX *ctxcmac;\nstatic OSSL_PARAM paramsmd5[3];\nstatic OSSL_PARAM paramssha1[3];\nstatic OSSL_PARAM paramssha256[3];\nstatic OSSL_PARAM paramsaes128[3];\n\nstatic int hashtype;\nstatic int essidlen;\nstatic int essidlenmin;\nstatic int essidlenmax;\nstatic int filteressidlen;\nstatic char *filteressidptr;\nstatic regex_t essidregex;\nstatic int filteressidpartlen;\nstatic char *filteressidpartptr;\nstatic char *filteressidregexptr;\n\nstatic char *filtervendorptr;\nstatic char *filtervendorapptr;\nstatic char *filtervendorclientptr;\n\nstatic bool flagpsk;\nstatic bool flagpmk;\nstatic bool flagessidgroup;\nstatic bool flagmacapgroup;\nstatic bool flagmacclientgroup;\nstatic bool flagouigroup;\nstatic bool flagvendorout;\nstatic bool flaghccapsingleout;\nstatic bool caseflag;\nstatic bool statusflag;\n\nstatic bool flagfiltermacap;\nstatic uint8_t filtermacap[6];\n\nstatic bool flagfiltermacclient;\nstatic uint8_t filtermacclient[6];\n\nstatic bool flagfilterouiap;\nstatic uint8_t filterouiap[3];\n\nstatic bool flagfilterouiclient;\nstatic uint8_t filterouiclient[3];\n\nstatic bool flagfilterauthorized;\nstatic bool flagfilterchallenge;\nstatic bool flagfilterrcchecked;\nstatic bool flagfilterrcnotchecked;\nstatic bool flagfilterapless;\n\nstatic int pskptrlen;\nstatic char *pskptr;\nstatic uint8_t pmk[32];\n/*===========================================================================*/\nstatic void closelists(void)\n{\nif(hashlist != NULL) free(hashlist);\nif(ouilist != NULL) free(ouilist);\nif(filteressidregexptr != NULL) regfree(&essidregex);\nif(ctxhmac != NULL)\n\t{\n\tEVP_MAC_CTX_free(ctxhmac);\n\tEVP_MAC_free(hmac);\n\t}\nif(ctxcmac != NULL)\n\t{\n\tEVP_MAC_CTX_free(ctxcmac);\n\tEVP_MAC_free(cmac);\n\t}\nEVP_cleanup();\nCRYPTO_cleanup_all_ex_data();\nERR_free_strings();\nreturn;\n}\n/*===========================================================================*/\nstatic bool initlists(void)\n{\nouicount = 0;\nouilistcount = OUILIST_MAX;\nhashlistcount = HASHLIST_MAX;\nreadcount = 0;\ncorrectedcount = 0;\nreaderrorcount = 0;\npmkideapolcount = 0;\nreaderrorcount = 0;\npmkidcount = 0;\neapolcount = 0;\npmkidwrittencount = 0;\neapolwrittencount = 0;\nessidwrittencount = 0;\nessidrawwrittencount = 0;\njohnpmkidwrittencount = 0;\njohneapolwrittencount = 0;\nhccapxwrittencount = 0;\nhccapwrittencount = 0;\nif((hashlist = (hashlist_t*)calloc(hashlistcount, HASHLIST_SIZE)) == NULL) return false;\nif((ouilist = (ouilist_t*)calloc(ouilistcount, OUILIST_SIZE)) == NULL) return false;\n\nERR_load_crypto_strings();\nOpenSSL_add_all_algorithms();\n\nhmac = NULL;\nctxhmac = NULL;\ncmac = NULL;\nctxcmac = NULL;\n\nhmac = EVP_MAC_fetch(NULL, \"hmac\", NULL);\nif(hmac == NULL) return false;\ncmac = EVP_MAC_fetch(NULL, \"cmac\", NULL);\nif(cmac == NULL) return false;\n\nchar md5[] = \"md5\";\nparamsmd5[0] = OSSL_PARAM_construct_utf8_string(\"digest\", md5, 0);\nparamsmd5[1] = OSSL_PARAM_construct_end();\n\nchar sha1[] = \"sha1\";\nparamssha1[0] = OSSL_PARAM_construct_utf8_string(\"digest\", sha1, 0);\nparamssha1[1] = OSSL_PARAM_construct_end();\n\nchar sha256[] = \"sha256\";\nparamssha256[0] = OSSL_PARAM_construct_utf8_string(\"digest\", sha256, 0);\nparamssha256[1] = OSSL_PARAM_construct_end();\n\nchar aes[] = \"aes-1280-cbc\";\nparamsaes128[0] = OSSL_PARAM_construct_utf8_string(\"cipher\", aes, 0);\nparamsaes128[1] = OSSL_PARAM_construct_end();\n\nctxhmac = EVP_MAC_CTX_new(hmac);\nif(ctxhmac == NULL) return false;\nctxcmac = EVP_MAC_CTX_new(cmac);\nif(ctxcmac == NULL) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic char *getvendor(uint8_t *mac)\n{\nstatic ouilist_t * zeiger;\nstatic char unknown[] = \"Unknown\";\n\nfor(zeiger = ouilist; zeiger < ouilist +ouicount; zeiger++)\n\t{\n\tif(memcmp(zeiger->oui, mac, 3) == 0) return zeiger->vendor;\n\tif(memcmp(zeiger->oui, mac, 3) > 0) return unknown;\n\t}\nreturn unknown;\n}\n/*===========================================================================*/\nstatic void printstatus(void)\n{\nstatic char *vendor;\n\nfprintf(stdout, \"\\nOUI information file..........: %s\\n\", usedoui);\nif(ouicount > 0)\t\tfprintf(stdout, \"OUI entries...................: %d\\n\", ouicount);\nif(readcount > 0)\t\tfprintf(stdout, \"total lines read..............: %ld\\n\", readcount);\nif(flagvendorout == true)\n\t{\n\tfprintf(stdout, \"\\n\");\n\treturn;\n\t}\nif(pbkdf2count > 0)\t\t\tfprintf(stdout, \"PBKDF2 lines..................: %ld\\n\", pbkdf2count);\nif(pbkdf2readerrorcount > 0)\t\tfprintf(stdout, \"PBKDF2 errors.................: %ld\\n\", pbkdf2readerrorcount);\nif(readerrorcount > 0)\t\t\tfprintf(stdout, \"read/format errors.........  .: %ld\\n\", readerrorcount);\nif(correctedcount > 0)\t\t\tfprintf(stdout, \"corrected read/format errors  : %ld\\n\", correctedcount);\nif(pmkideapolcount > 0)\t\t\tfprintf(stdout, \"valid hash lines..............: %ld\\n\", pmkideapolcount);\nif(pmkidcount > 0)\t\t\tfprintf(stdout, \"PMKID hash lines..............: %ld\\n\", pmkidcount);\nif(eapolcount > 0)\t\t\tfprintf(stdout, \"EAPOL hash lines..............: %ld\\n\", eapolcount);\nif(essidlenmin != 0)\t\t\tfprintf(stdout, \"filter by ESSID len min.......: %d\\n\", essidlenmin);\nif(essidlenmax != 32)\t\t\tfprintf(stdout, \"filter by ESSID len max.......: %d\\n\", essidlenmax);\nif(filteressidptr != NULL)\t\tfprintf(stdout, \"filter by ESSID...............: %s\\n\", filteressidptr);\nif(filteressidpartptr != NULL)\t\tfprintf(stdout, \"filter by part of ESSID.......: %s\\n\", filteressidpartptr);\nif(filteressidregexptr != NULL)\t\tfprintf(stdout, \"filter by ESSID RegEx.........: %s\\n\", filteressidregexptr);\nif(flagfiltermacap == true)\n\t{\n\tvendor = getvendor(filtermacap);\n\tfprintf(stdout, \"filter by MAC.................: %02x%02x%02x%02x%02x%02x (%s)\\n\", filtermacap[0], filtermacap[1], filtermacap[2], filtermacap[3], filtermacap[4], filtermacap[5], vendor);\n\t}\nif(flagfiltermacclient == true)\n\t{\n\tvendor = getvendor(filtermacclient);\n\tfprintf(stdout, \"filter by MAC.................: %02x%02x%02x%02x%02x%02x (%s)\\n\", filtermacclient[0], filtermacclient[1], filtermacclient[2], filtermacclient[3], filtermacclient[4], filtermacclient[5], vendor);\n\t}\n\nif(flagfilterouiap == true)\n\t{\n\tvendor = getvendor(filterouiap);\n\tfprintf(stdout, \"filter AP by OUI..............: %02x%02x%02x (%s)\\n\", filterouiap[0], filterouiap[1], filterouiap[2], vendor);\n\t}\nif(filtervendorptr != NULL)\t\tfprintf(stdout, \"filter AP and CLIENT by VENDOR: %s\\n\", filtervendorptr);\nif(filtervendorapptr != NULL)\t\tfprintf(stdout, \"filter AP by VENDOR...........: %s\\n\", filtervendorapptr);\nif(filtervendorclientptr != NULL)\tfprintf(stdout, \"filter CLIENT by VENDOR.......: %s\\n\", filtervendorclientptr);\nif(flagfilterouiclient == true)\n\t{\n\tvendor = getvendor(filterouiclient);\n\tfprintf(stdout, \"filter CLIENT by OUI..........: %02x%02x%02x (%s)\\n\", filterouiclient[0], filterouiclient[1], filterouiclient[2], vendor);\n\t}\nif(flagfilterapless == true)\t\tfprintf(stdout, \"filter by M2..................: requested from client (AP-LESS)\\n\");\nif(flagfilterrcchecked == true)\t\tfprintf(stdout, \"filter by NC..................: nonce-error-corrections not necessary\\n\");\nif(flagfilterrcnotchecked == true)\tfprintf(stdout, \"filter by NC..................: nonce-error-corrections necessary\\n\");\nif(flagfilterauthorized == true)\tfprintf(stdout, \"filter by status..............: authorized (M1M4, M2M3 or M3M4)\\n\");\nif(flagfilterchallenge == true)\tfprintf(stdout, \"filter by status..............: challenge (M1M2)\\n\");\nif(pmkidwrittencount > 0)\t\tfprintf(stdout, \"PMKID written.................: %ld\\n\", pmkidwrittencount);\nif(eapolwrittencount > 0)\t\tfprintf(stdout, \"EAPOL written.................: %ld\\n\", eapolwrittencount);\nif(johnpmkidwrittencount > 0)\t\tfprintf(stdout, \"PMKID written to john.........: %ld\\n\", johnpmkidwrittencount);\nif(johneapolwrittencount > 0)\t\tfprintf(stdout, \"EAPOL written to john.........: %ld\\n\", johneapolwrittencount);\nif(hccapxwrittencount > 0)\t\tfprintf(stdout, \"EAPOL written to hccapx.......: %ld\\n\", hccapxwrittencount);\nif(hccapwrittencount > 0)\t\tfprintf(stdout, \"EAPOL written to hccap........: %ld\\n\", hccapwrittencount);\nif(essidwrittencount > 0)\t\tfprintf(stdout, \"ESSID (unique) written........: %ld\\n\", essidwrittencount);\nif(essidrawwrittencount > 0)\t\tfprintf(stdout, \"ESSID written.................: %ld\\n\", essidrawwrittencount);\nfprintf(stdout, \"\\n\");\nreturn;\n}\n/*===========================================================================*/\nstatic void testeapolpmk(hashlist_t *zeiger)\n{\nstatic int keyver;\nstatic int p;\nstatic wpakey_t *wpak;\nstatic uint8_t *pkeptr;\n\nstatic uint8_t eapoltmp[1024];\nstatic uint8_t pkedata[102];\n\nwpak = (wpakey_t*)&zeiger->eapol[EAPAUTH_SIZE];\nkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\nif((keyver == 1) || (keyver == 2))\n\t{\n\tmemset(&pkedata, 0, sizeof(pkedata));\n\tpkeptr = pkedata;\n\tmemcpy(pkeptr, \"Pairwise key expansion\", 23);\n\tif(memcmp(zeiger->ap, zeiger->client, 6) < 0)\n\t\t{\n\t\tmemcpy(pkeptr +23, zeiger->ap, 6);\n\t\tmemcpy(pkeptr +29, zeiger->client, 6);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(pkeptr +23, zeiger->client, 6);\n\t\tmemcpy(pkeptr +29, zeiger->ap, 6);\n\t\t}\n\tif(memcmp(zeiger->nonce, wpak->nonce, 32) < 0)\n\t\t{\n\t\tmemcpy (pkeptr +35, zeiger->nonce, 32);\n\t\tmemcpy (pkeptr +67, wpak->nonce, 32);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy (pkeptr +35, wpak->nonce, 32);\n\t\tmemcpy (pkeptr +67, zeiger->nonce, 32);\n\t\t}\n\tif(!EVP_MAC_init(ctxhmac, pmk, 32, paramssha1)) return;\n\tif(!EVP_MAC_update(ctxhmac, pkedata, 100)) return;\n\tif(!EVP_MAC_final(ctxhmac, pkedata, NULL, 100)) return;\n\tfprintf(stdout, \"\\n\");\n\tif(keyver == 2)\n\t\t{\n\t\tmemset(eapoltmp, 0, 1024);\n\t\tmemcpy(eapoltmp, zeiger->eapol, zeiger->eapauthlen);\n\t\tif(!EVP_MAC_init(ctxhmac, pkedata, 16, paramssha1)) return;\n\t\tif(!EVP_MAC_update(ctxhmac, eapoltmp, zeiger->eapauthlen)) return;\n\t\tif(!EVP_MAC_final(ctxhmac, eapoltmp, NULL, zeiger->eapauthlen)) return;\n\t\t}\n\tif(keyver == 1)\n\t\t{\n\t\tmemset(eapoltmp, 0, 1024);\n\t\tmemcpy(eapoltmp, zeiger->eapol, zeiger->eapauthlen);\n\t\tif(!EVP_MAC_init(ctxhmac, pkedata, 16, paramsmd5)) return;\n\t\tif(!EVP_MAC_update(ctxhmac, eapoltmp, zeiger->eapauthlen)) return;\n\t\tif(!EVP_MAC_final(ctxhmac, eapoltmp, NULL, zeiger->eapauthlen)) return;\n\t\t}\n\t}\nelse if(keyver == 3)\n\t{\n\tmemset(&pkedata, 0, sizeof(pkedata));\n\tpkedata[0] = 1;\n\tpkedata[1] = 0;\n\tpkeptr = pkedata +2;\n\tmemcpy(pkeptr, \"Pairwise key expansion\", 22);\n\tif(memcmp(zeiger->ap, zeiger->client, 6) < 0)\n\t\t{\n\t\tmemcpy(pkeptr +22, zeiger->ap, 6);\n\t\tmemcpy(pkeptr +28, zeiger->client, 6);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(pkeptr +22, zeiger->client, 6);\n\t\tmemcpy(pkeptr +28, zeiger->ap, 6);\n\t\t}\n\tif(memcmp(zeiger->nonce, wpak->nonce, 32) < 0)\n\t\t{\n\t\tmemcpy (pkeptr +34, zeiger->nonce, 32);\n\t\tmemcpy (pkeptr +66, wpak->nonce, 32);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy (pkeptr +34, wpak->nonce, 32);\n\t\tmemcpy (pkeptr +66, zeiger->nonce, 32);\n\t\t}\n\tpkedata[100] = 0x80;\n\tpkedata[101] = 1;\n\tif(!EVP_MAC_init(ctxhmac, pmk, 32, paramssha256)) return;\n\tif(!EVP_MAC_update(ctxhmac, pkedata, 102)) return;\n\tif(!EVP_MAC_final(ctxhmac, pkedata, NULL, 102)) return;\n\tmemset(eapoltmp, 0, 1024);\n\tmemcpy(eapoltmp, zeiger->eapol, zeiger->eapauthlen);\n\tif(!EVP_MAC_init(ctxcmac, pkedata, 16, paramsaes128)) return;\n\tif(!EVP_MAC_update(ctxcmac, eapoltmp, zeiger->eapauthlen)) return;\n\tif(!EVP_MAC_final(ctxcmac, eapoltmp, NULL, zeiger->eapauthlen)) return;\n\t}\nelse return;\nif(memcmp(eapoltmp, zeiger->hash, 16) == 0)\n\t{\n\tfor(p = 0; p < 6; p++) fprintf(stdout, \"%02x\", zeiger->client[p]);\n\tfprintf(stdout, \":\");\n\tfor(p = 0; p < 6; p++) fprintf(stdout, \"%02x\", zeiger->ap[p]);\n\tif(zeiger->essidlen != 0)\n\t\t{\n\t\tif(ispotfilestring(zeiger->essidlen, (char*)zeiger->essid) == true) fprintf(stdout, \":%.*s\", zeiger->essidlen, zeiger->essid);\n\t\telse\n\t\t\t{\n\t\t\tfprintf(stdout, \":$HEX[\");\n\t\t\tfor(p = 0; p < zeiger->essidlen; p++) fprintf(stdout, \"%02x\", zeiger->essid[p]);\n\t\t\tfprintf(stdout, \"]\");\n\t\t\t}\n\t\t}\n\telse fprintf(stdout, \":\");\n\tfprintf(stdout, \":%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", \n\t\tpmk[0], pmk[1], pmk[2], pmk[3], pmk[4], pmk[5], pmk[6], pmk[7],\n\t\tpmk[8], pmk[9], pmk[10], pmk[11], pmk[12], pmk[13], pmk[14], pmk[15],\n\t\tpmk[16], pmk[17], pmk[18], pmk[19], pmk[20], pmk[21], pmk[22], pmk[23],\n\t\tpmk[24], pmk[25], pmk[26], pmk[27], pmk[28], pmk[29], pmk[30], pmk[31]);\n\tif(pskptr != NULL)\n\t\t{\n\t\tif(ispotfilestring(pskptrlen, pskptr) == true) fprintf(stdout, \":%s\", pskptr);\n\t\telse\n\t\t\t{\n\t\t\tfprintf(stdout, \":$HEX[\");\n\t\t\tfor(p = 0; p < pskptrlen; p++) fprintf(stdout, \"%02x\", pskptr[p]);\n\t\t\tfprintf(stdout, \"]\");\n\t\t\t}\n\t\t}\n\tfprintf(stdout, \"\\n\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testpmkidpmk(hashlist_t *zeiger)\n{\nstatic int p;\nstatic const char *pmkname = \"PMK Name\";\nstatic uint8_t message[20];\n\nmemcpy(message, pmkname, 8);\nmemcpy(&message[8], zeiger->ap, 6);\nmemcpy(&message[14], zeiger->client, 6);\nif(!EVP_MAC_init(ctxhmac, pmk, 32, paramssha1)) return;\nif(!EVP_MAC_update(ctxhmac, message, 20)) return;\nif(!EVP_MAC_final(ctxhmac, message, NULL, 20)) return;\nif(memcmp(message, zeiger->hash, 16) == 0)\n\t{\n\tfor(p = 0; p < 6; p++) fprintf(stdout, \"%02x\", zeiger->client[p]);\n\tfprintf(stdout, \":\");\n\tfor(p = 0; p < 6; p++) fprintf(stdout, \"%02x\", zeiger->ap[p]);\n\tif(zeiger->essidlen != 0)\n\t\t{\n\t\tif(ispotfilestring(zeiger->essidlen, (char*)zeiger->essid) == true) fprintf(stdout, \":%.*s\", zeiger->essidlen, zeiger->essid);\n\t\telse\n\t\t\t{\n\t\t\tfprintf(stdout, \":$HEX[\");\n\t\t\tfor(p = 0; p < zeiger->essidlen; p++) fprintf(stdout, \"%02x\", zeiger->essid[p]);\n\t\t\tfprintf(stdout, \"]\");\n\t\t\t}\n\t\t}\n\telse fprintf(stdout, \":\");\n\tfprintf(stdout, \":%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", \n\t\tpmk[0], pmk[1], pmk[2], pmk[3], pmk[4], pmk[5], pmk[6], pmk[7],\n\t\tpmk[8], pmk[9], pmk[10], pmk[11], pmk[12], pmk[13], pmk[14], pmk[15],\n\t\tpmk[16], pmk[17], pmk[18], pmk[19], pmk[20], pmk[21], pmk[22], pmk[23],\n\t\tpmk[24], pmk[25], pmk[26], pmk[27], pmk[28], pmk[29], pmk[30], pmk[31]);\n\tif(pskptr != NULL)\n\t\t{\n\t\tif(ispotfilestring(pskptrlen, pskptr) == true) fprintf(stdout, \":%s\", pskptr);\n\t\telse\n\t\t\t{\n\t\t\tfprintf(stdout, \":$HEX[\");\n\t\t\tfor(p = 0; p < pskptrlen; p++) fprintf(stdout, \"%02x\", pskptr[p]);\n\t\t\tfprintf(stdout, \"]\");\n\t\t\t}\n\t\t}\n\tfprintf(stdout, \"\\n\");\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testhashfilepmk(void)\n{\nstatic hashlist_t *zeiger;\n\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tif(zeiger->type == HCX_TYPE_PMKID) testpmkidpmk(zeiger);\n\telse if (zeiger->type == HCX_TYPE_EAPOL) testeapolpmk(zeiger);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic bool dopbkdf2(int psklen, char *psk, int essidlen, uint8_t *essid)\n{\nif(PKCS5_PBKDF2_HMAC_SHA1(psk, psklen, essid, essidlen, 4096, 32, pmk) == 0) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic void testhashfilepsk(void)\n{\nstatic hashlist_t *zeiger, *zeigerold;\n\nzeigerold = hashlist;\nif(dopbkdf2(pskptrlen, pskptr, zeigerold->essidlen, zeigerold->essid) == true)\n\t{\n\tif(zeigerold->type == HCX_TYPE_PMKID) testpmkidpmk(zeigerold);\n\tif(zeigerold->type == HCX_TYPE_EAPOL) testeapolpmk(zeigerold);\n\t}\nfor(zeiger = hashlist +1; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tif((zeigerold->essidlen == zeiger->essidlen) && (memcmp(zeigerold->essid, zeiger->essid, zeigerold->essidlen) == 0))\n\t\t{\n\t\tif(zeiger->type == HCX_TYPE_PMKID) testpmkidpmk(zeiger);\n\t\tif(zeiger->type == HCX_TYPE_EAPOL) testeapolpmk(zeiger);\n\t\t}\n\telse\n\t\t{\n\t\tif(dopbkdf2(pskptrlen, pskptr, zeiger->essidlen, zeiger->essid) == true)\n\t\t\t{\n\t\t\tif(zeiger->type == HCX_TYPE_PMKID) testpmkidpmk(zeiger);\n\t\t\tif(zeiger->type == HCX_TYPE_EAPOL) testeapolpmk(zeiger);\n\t\t\t}\n\t\t}\n\tzeigerold = zeiger;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic bool isoui(uint8_t *macap, uint8_t *macclient)\n{\nstatic ouilist_t *zeiger;\n\nfor(zeiger = ouilist; zeiger < ouilist +ouicount; zeiger++)\n\t{\n\tif(((zeiger->type &TYPE_AP) == TYPE_AP) && (memcmp(macap, zeiger->oui, 3) == 0)) return true;\n\tif(((zeiger->type &TYPE_CLIENT) == TYPE_CLIENT) && (memcmp(macclient, zeiger->oui, 3) == 0)) return true;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic bool ispartof(int plen, uint8_t *pbuff, int slen, uint8_t *sbuff)\n{\nstatic int p;\nstatic uint8_t buffers[32];\nstatic uint8_t bufferp[32];\n\nif(plen > slen) return false;\nif(caseflag == false)\n\t{\n\tfor(p = 0; p <= slen -plen; p++)\n\t\t{\n\t\tif(memcmp(&sbuff[p], pbuff, plen) == 0) return true;\n\t\t}\n\treturn false;\n\t}\nelse\n\t{\n\tmemset(buffers, 0, 32);\n\tfor(p = 0; p < slen; p++)\n\t\t{\n\t\tif(isupper(sbuff[p])) buffers[p] = tolower(sbuff[p]);\n\t\telse buffers[p] = sbuff[p];\n\t\t}\n\tmemset(bufferp, 0, 32);\n\tfor(p = 0; p < plen; p++)\n\t\t{\n\t\tif(isupper(pbuff[p])) bufferp[p] = tolower(pbuff[p]);\n\t\telse bufferp[p] = pbuff[p];\n\t\t}\n\tfor(p = 0; p <= slen -plen; p++)\n\t\t{\n\t\tif(memcmp(&buffers[p], bufferp, plen) == 0) return true;\n\t\t}\n\treturn false;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic void hccap2base(unsigned char *in, unsigned char b, FILE *fh_john)\n{\nstatic const char itoa64[65] = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfprintf(fh_john, \"%c\", (itoa64[in[0] >> 2]));\nfprintf(fh_john, \"%c\", (itoa64[((in[0] & 0x03) << 4) | (in[1] >> 4)]));\nif(b)\n\t{\n\tfprintf(fh_john, \"%c\", (itoa64[((in[1] & 0x0f) << 2) | (in[2] >> 6)]));\n\tfprintf(fh_john, \"%c\", (itoa64[in[2] & 0x3f]));\n\t}\nelse fprintf(fh_john, \"%c\", (itoa64[((in[1] & 0x0f) << 2)]));\nreturn;\n}\n/*===========================================================================*/\nstatic void writejohnrecord(FILE *fh_john, hashlist_t *zeiger)\n{\nstatic wpakey_t *wpak;\nstatic int i;\nstatic char essid[ESSID_LEN_MAX+1];\nstatic unsigned char *hcpos;\nstatic hccap_t hccap;\n\nif((zeiger->essidlen < essidlenmin) || (zeiger->essidlen > essidlenmax)) return;\nif(((zeiger->type &hashtype) != HCX_TYPE_PMKID) && ((zeiger->type &hashtype) != HCX_TYPE_EAPOL)) return;\nif(flagfiltermacap == true) if(memcmp(&filtermacap, zeiger->ap, 6) != 0) return;\nif(flagfiltermacclient == true) if(memcmp(&filtermacclient, zeiger->client, 6) != 0) return;\nif(flagfilterouiap == true) if(memcmp(&filterouiap, zeiger->ap, 3) != 0) return;\nif(flagfilterouiclient == true) if(memcmp(&filterouiclient, zeiger->client, 3) != 0) return;\nif(filteressidptr != NULL)\n\t{\n\tif(zeiger->essidlen != filteressidlen) return;\n\tif(memcmp(zeiger->essid, filteressidptr, zeiger->essidlen) != 0) return;\n\t}\nif(filteressidpartptr != NULL)\n\t{\n\tif(ispartof(filteressidpartlen, (uint8_t*)filteressidpartptr, zeiger->essidlen, zeiger->essid) == false) return;\n\t}\nif(filteressidregexptr != NULL)\n\t{\n\tstrncpy(essid, (char*)zeiger->essid, zeiger->essidlen);\n\tessid[zeiger->essidlen] = '\\0';\n\tif(regexec(&essidregex, essid, 0, NULL, 0) == REG_NOMATCH) return;\n\t}\nif((filtervendorptr != NULL) || (filtervendorapptr != NULL) || (filtervendorclientptr != NULL))\n\t{\n\tif(isoui(zeiger->ap, zeiger->client) == false) return;\n\t}\nif((flagfilterapless == true) && ((zeiger->mp &0x10) != 0x10)) return;\nif((flagfilterrcchecked == true) && ((zeiger->mp &0x80) == 0x80)) return;\nif((flagfilterrcnotchecked == true) && ((zeiger->mp &0x80) != 0x80)) return;\nif((flagfilterauthorized == true) && ((zeiger->mp &0x07) == 0x00)) return;\nif((flagfilterchallenge == true) && ((zeiger->mp &0x07) != 0x01)) return;\n\nif(zeiger->type == HCX_TYPE_PMKID)\n\t{\n\tfprintf(fh_john, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\tzeiger->hash[0], zeiger->hash[1], zeiger->hash[2], zeiger->hash[3], zeiger->hash[4], zeiger->hash[5], zeiger->hash[6], zeiger->hash[7],\n\t\tzeiger->hash[8], zeiger->hash[9], zeiger->hash[10], zeiger->hash[11], zeiger->hash[12], zeiger->hash[13], zeiger->hash[14], zeiger->hash[15],\n\t\tzeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5],\n\t\tzeiger->client[0], zeiger->client[1], zeiger->client[2], zeiger->client[3], zeiger->client[4], zeiger->client[5]);\n\tfor(i = 0; i < zeiger->essidlen; i++) fprintf(fh_john, \"%02x\", zeiger->essid[i]);\n\tfprintf(fh_john, \"\\n\");\n\tjohnpmkidwrittencount++;\n\treturn;\n\t}\nwpak = (wpakey_t*)(zeiger->eapol +EAPAUTH_SIZE);\nmemset(&hccap, 0, sizeof(hccap_t));\nmemcpy(&hccap.essid, zeiger->essid, zeiger->essidlen);\nmemcpy(&hccap.ap, zeiger->ap, 6);\nmemcpy(&hccap.client, zeiger->client, 6);\nmemcpy(&hccap.anonce, zeiger->nonce, 32);\nmemcpy(&hccap.snonce, wpak->nonce, 32);\nmemcpy(&hccap.keymic, zeiger->hash, 16);\nhccap.keyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nhccap.eapol_size = zeiger->eapauthlen;\nmemcpy(&hccap.eapol, zeiger->eapol, zeiger->eapauthlen);\n#ifdef BIG_ENDIAN_HOST\nhccap.eapol_size = byte_swap_16(hccap.eapol_size);\n#endif\n\nfprintf(fh_john, \"%.*s:$WPAPSK$%.*s#\", zeiger->essidlen, zeiger->essid, zeiger->essidlen, zeiger->essid);\nhcpos = (unsigned char*)&hccap;\nfor (i = 36; i + 3 < (int)HCCAP_SIZE; i += 3) hccap2base(&hcpos[i], 1, fh_john);\nhccap2base(&hcpos[i], 0, fh_john);\nfprintf(fh_john, \":%02x-%02x-%02x-%02x-%02x-%02x:%02x-%02x-%02x-%02x-%02x-%02x:%02x%02x%02x%02x%02x%02x\",\nzeiger->client[0], zeiger->client[1], zeiger->client[2], zeiger->client[3], zeiger->client[4], zeiger->client[5],\nzeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5],\nzeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5]);\nif(hccap.keyver == 1) fprintf(fh_john, \"::WPA\");\nelse fprintf(fh_john, \"::WPA2\");\nif((zeiger->mp &0x7) == 0) fprintf(fh_john, \":not verified\");\nelse fprintf(fh_john, \":verified\");\nfprintf(fh_john, \":converted by hcxhashtool\\n\");\njohneapolwrittencount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void writejohnfile(char *johnoutname)\n{\nstatic FILE *fh_john;\nstatic hashlist_t *zeiger;\nstatic struct stat statinfo;\n\nif(johnoutname != NULL)\n\t{\n\tif((fh_john = fopen(johnoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", johnoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\t}\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++) writejohnrecord(fh_john, zeiger);\nif(fh_john != NULL) fclose(fh_john);\nif(johnoutname != NULL)\n\t{\n\tif(stat(johnoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(johnoutname);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writehccaprecord(FILE *fh_hccap, hashlist_t *zeiger)\n{\nstruct hccap_s\n{\n  char essid[36];\n  unsigned char ap[6];\n  unsigned char client[6];\n  unsigned char snonce[32];\n  unsigned char anonce[32];\n  unsigned char eapol[256];\n  int eapol_size;\n  int keyver;\n  unsigned char keymic[16];\n};\ntypedef struct hccap_s hccap_t;\n#define\tHCCAP_SIZE (sizeof(hccap_t))\n\nstatic wpakey_t *wpak;\nstatic hccap_t hccap;\nstatic char essid[ESSID_LEN_MAX+1];\n\nif(zeiger->type == HCX_TYPE_PMKID) return;\nif((zeiger->essidlen < essidlenmin) || (zeiger->essidlen > essidlenmax)) return;\nif(((zeiger->type &hashtype) != HCX_TYPE_PMKID) && ((zeiger->type &hashtype) != HCX_TYPE_EAPOL)) return;\nif(flagfiltermacap == true) if(memcmp(&filtermacap, zeiger->ap, 6) != 0) return;\nif(flagfiltermacclient == true) if(memcmp(&filtermacclient, zeiger->client, 6) != 0) return;\nif(flagfilterouiap == true) if(memcmp(&filterouiap, zeiger->ap, 3) != 0) return;\nif(flagfilterouiclient == true) if(memcmp(&filterouiclient, zeiger->client, 3) != 0) return;\nif(filteressidptr != NULL)\n\t{\n\tif(zeiger->essidlen != filteressidlen) return;\n\tif(memcmp(zeiger->essid, filteressidptr, zeiger->essidlen) != 0) return;\n\t}\nif(filteressidpartptr != NULL)\n\t{\n\tif(ispartof(filteressidpartlen, (uint8_t*)filteressidpartptr, zeiger->essidlen, zeiger->essid) == false) return;\n\t}\nif(filteressidregexptr != NULL)\n\t{\n\tstrncpy(essid, (char *) zeiger->essid, zeiger->essidlen);\n    essid[zeiger->essidlen] = '\\0';\n\tif(regexec(&essidregex, essid, 0, NULL, 0) == REG_NOMATCH) return;\n\t}\nif((filtervendorptr != NULL) || (filtervendorapptr != NULL) || (filtervendorclientptr != NULL))\n\t{\n\tif(isoui(zeiger->ap, zeiger->client) == false) return;\n\t}\nif((flagfilterapless == true) && ((zeiger->mp &0x10) != 0x10)) return;\nif((flagfilterrcchecked == true) && ((zeiger->mp &0x80) == 0x80)) return;\nif((flagfilterrcnotchecked == true) && ((zeiger->mp &0x80) != 0x80)) return;\nif((flagfilterauthorized == true) && ((zeiger->mp &0x07) == 0x00)) return;\nif((flagfilterchallenge == true) && ((zeiger->mp &0x07) != 0x01)) return;\n\nwpak = (wpakey_t*)(zeiger->eapol +EAPAUTH_SIZE);\nmemset(&hccap, 0, sizeof(hccap_t));\nmemcpy(&hccap.essid, zeiger->essid, zeiger->essidlen);\nmemcpy(&hccap.ap, zeiger->ap, 6);\nmemcpy(&hccap.client, zeiger->client, 6);\nmemcpy(&hccap.anonce, zeiger->nonce, 32);\nmemcpy(&hccap.snonce, wpak->nonce, 32);\nmemcpy(&hccap.keymic, zeiger->hash, 16);\nhccap.keyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nhccap.eapol_size = zeiger->eapauthlen;\nmemcpy(&hccap.eapol, zeiger->eapol, zeiger->eapauthlen);\n#ifdef BIG_ENDIAN_HOST\nhccap.eapol_size = byte_swap_16(hccap.eapol_size);\n#endif\nfwrite(&hccap, HCCAP_SIZE, 1, fh_hccap);\nhccapwrittencount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void writehccapsinglefile(void)\n{\nstatic int c;\nstatic FILE *fh_hccap;\nstatic hashlist_t *zeiger;\nstatic struct stat statinfo;\nstatic char groupoutname[PATH_MAX];\n\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tc = 0;\n\tdo\n\t\t{\n\t\tsnprintf(groupoutname, PATH_MAX -1, \"%02x%02x%02x%02x%02x%02x-%04d.hccap\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5], c);\n\t\tc++;\n\t\t}\n\twhile (stat(groupoutname, &statinfo) == 0); \n\tif((fh_hccap = fopen(groupoutname, \"a\")) == NULL) continue;\n\twritehccaprecord(fh_hccap, zeiger);\n\tif(fh_hccap != NULL) fclose(fh_hccap);\n\tif(stat(groupoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(groupoutname);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writehccapfile(char *hccapoutname)\n{\nstatic FILE *fh_hccap;\nstatic hashlist_t *zeiger;\nstatic struct stat statinfo;\n\nif(hccapoutname != NULL)\n\t{\n\tif((fh_hccap = fopen(hccapoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", hccapoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\t}\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++) writehccaprecord(fh_hccap, zeiger);\nif(fh_hccap != NULL) fclose(fh_hccap);\nif(hccapoutname != NULL)\n\t{\n\tif(stat(hccapoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(hccapoutname);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writehccapxrecord(FILE *fh_hccapx, hashlist_t *zeiger)\n{\nstatic wpakey_t *wpak;\nstatic hccapx_t hccapx;\nstatic char essid[ESSID_LEN_MAX+1];\n\nif(zeiger->type == HCX_TYPE_PMKID) return;\nif((zeiger->essidlen < essidlenmin) || (zeiger->essidlen > essidlenmax)) return;\nif(((zeiger->type &hashtype) != HCX_TYPE_PMKID) && ((zeiger->type &hashtype) != HCX_TYPE_EAPOL)) return;\nif(flagfiltermacap == true) if(memcmp(&filtermacap, zeiger->ap, 6) != 0) return;\nif(flagfiltermacclient == true) if(memcmp(&filtermacclient, zeiger->client, 6) != 0) return;\nif(flagfilterouiap == true) if(memcmp(&filterouiap, zeiger->ap, 3) != 0) return;\nif(flagfilterouiclient == true) if(memcmp(&filterouiclient, zeiger->client, 3) != 0) return;\nif(filteressidptr != NULL)\n\t{\n\tif(zeiger->essidlen != filteressidlen) return;\n\tif(memcmp(zeiger->essid, filteressidptr, zeiger->essidlen) != 0) return;\n\t}\nif(filteressidpartptr != NULL)\n\t{\n\tif(ispartof(filteressidpartlen, (uint8_t*)filteressidpartptr, zeiger->essidlen, zeiger->essid) == false) return;\n\t}\nif(filteressidregexptr != NULL)\n\t{\n\tstrncpy(essid, (char *) zeiger->essid, zeiger->essidlen);\n    essid[zeiger->essidlen] = '\\0';\n\tif(regexec(&essidregex, essid, 0, NULL, 0) == REG_NOMATCH) return;\n\t}\nif((filtervendorptr != NULL) || (filtervendorapptr != NULL) || (filtervendorclientptr != NULL))\n\t{\n\tif(isoui(zeiger->ap, zeiger->client) == false) return;\n\t}\nif((flagfilterapless == true) && ((zeiger->mp &0x10) != 0x10)) return;\nif((flagfilterrcchecked == true) && ((zeiger->mp &0x80) == 0x80)) return;\nif((flagfilterrcnotchecked == true) && ((zeiger->mp &0x80) != 0x80)) return;\nif((flagfilterauthorized == true) && ((zeiger->mp &0x07) == 0x00)) return;\nif((flagfilterchallenge == true) && ((zeiger->mp &0x07) != 0x01)) return;\n\nwpak = (wpakey_t*)(zeiger->eapol +EAPAUTH_SIZE);\nmemset (&hccapx, 0, sizeof(hccapx_t));\nhccapx.signature = HCCAPX_SIGNATURE;\nhccapx.version = HCCAPX_VERSION;\nhccapx.message_pair = zeiger->mp;\nhccapx.essid_len = zeiger->essidlen;\nmemcpy(&hccapx.essid, zeiger->essid, zeiger->essidlen);\nmemcpy(&hccapx.ap, zeiger->ap, 6);\nmemcpy(&hccapx.client, zeiger->client, 6);\nmemcpy(&hccapx.anonce, zeiger->nonce, 32);\nmemcpy(&hccapx.snonce, wpak->nonce, 32);\nhccapx.eapol_len = zeiger->eapauthlen;\nmemcpy(&hccapx.eapol, zeiger->eapol, zeiger->eapauthlen);\nhccapx.keyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nmemcpy(&hccapx.keymic, zeiger->hash, 16);\n#ifdef BIG_ENDIAN_HOST\nhccapx.signature = byte_swap_32(hccapx.signature);\nhccapx.version = byte_swap_32(hccapx.version);\nhccapx.eapol_len = byte_swap_16(hccapx.eapol_len);\n#endif\nfwrite (&hccapx, sizeof(hccapx_t), 1, fh_hccapx);\nhccapxwrittencount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void writehccapxfile(char *hccapxoutname)\n{\nstatic FILE *fh_hccapx;\nstatic hashlist_t *zeiger;\nstatic struct stat statinfo;\n\nif(hccapxoutname != NULL)\n\t{\n\tif((fh_hccapx = fopen(hccapxoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", hccapxoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\t}\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++) writehccapxrecord(fh_hccapx, zeiger);\nif(fh_hccapx != NULL) fclose(fh_hccapx);\nif(hccapxoutname != NULL)\n\t{\n\tif(stat(hccapxoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(hccapxoutname);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processessidraw(char *essidrawoutname)\n{\nstatic long int pc;\nstatic hashlist_t *zeiger;\nstatic FILE *fh_essid;\nstatic struct stat statinfo;\n\nif((fh_essid = fopen(essidrawoutname, \"a\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening file %s: %s\\n\", essidrawoutname, strerror(errno));\n\treturn;\n\t}\nfor(pc = 0; pc < pmkideapolcount; pc++)\n\t{\n\tzeiger = hashlist +pc;\n\tfwriteessidstr(zeiger->essidlen, zeiger->essid, fh_essid);\n\tessidrawwrittencount++;\n\t}\nfclose(fh_essid);\nif(stat(essidrawoutname, &statinfo) == 0)\n\t{\n\tif(statinfo.st_size == 0) remove(essidrawoutname);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processessid(char *essidoutname)\n{\nstatic long int pc;\nstatic hashlist_t *zeiger, *zeigerold;\nstatic FILE *fh_essid;\nstatic struct stat statinfo;\n\nif(strcmp(essidoutname, \"stdout\") != 0)\n\t{\n\tif((fh_essid = fopen(essidoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", essidoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\tzeigerold = NULL;\n\tqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\n\tfor(pc = 0; pc < pmkideapolcount; pc++)\n\t\t{\n\t\tzeiger = hashlist +pc;\n\t\tif(zeigerold != NULL)\n\t\t\t{\n\t\t\tif(memcmp(zeiger->essid, zeigerold->essid, ESSID_LEN_MAX) == 0) continue;\n\t\t\t}\n\t\tfwriteessidstr(zeiger->essidlen, zeiger->essid, fh_essid);\n\t\tessidwrittencount++;\n\t\tzeigerold = zeiger;\n\t\t}\n\tfclose(fh_essid);\n\tif(stat(essidoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(essidoutname);\n\t\t}\n\t}\nelse\n\t{\n\tstatusflag = false;\n\tzeigerold = NULL;\n\tqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\n\tfor(pc = 0; pc < pmkideapolcount; pc++)\n\t\t{\n\t\tzeiger = hashlist +pc;\n\t\tif(zeigerold != NULL)\n\t\t\t{\n\t\t\tif(memcmp(zeiger->essid, zeigerold->essid, ESSID_LEN_MAX) == 0) continue;\n\t\t\t}\n\t\tfwriteessidstr(zeiger->essidlen, zeiger->essid, stdout);\n\t\tessidwrittencount++;\n\t\tzeigerold = zeiger;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writepmkideapolhashline(FILE *fh_pmkideapol, hashlist_t *zeiger)\n{\nstatic int p;\nstatic char essid[ESSID_LEN_MAX+1];\n\nif((zeiger->essidlen < essidlenmin) || (zeiger->essidlen > essidlenmax)) return;\nif(((zeiger->type &hashtype) != HCX_TYPE_PMKID) && ((zeiger->type &hashtype) != HCX_TYPE_EAPOL)) return;\nif(flagfiltermacap == true) if(memcmp(&filtermacap, zeiger->ap, 6) != 0) return;\nif(flagfiltermacclient == true) if(memcmp(&filtermacclient, zeiger->client, 6) != 0) return;\nif(flagfilterouiap == true) if(memcmp(&filterouiap, zeiger->ap, 3) != 0) return;\nif(flagfilterouiclient == true) if(memcmp(&filterouiclient, zeiger->client, 3) != 0) return;\nif(filteressidptr != NULL)\n\t{\n\tif(zeiger->essidlen != filteressidlen) return;\n\tif(memcmp(zeiger->essid, filteressidptr, zeiger->essidlen) != 0) return;\n\t}\nif(filteressidpartptr != NULL)\n\t{\n\tif(ispartof(filteressidpartlen, (uint8_t*)filteressidpartptr, zeiger->essidlen, zeiger->essid) == false) return;\n\t}\nif(filteressidregexptr != NULL)\n\t{\n\tstrncpy(essid, (char *) zeiger->essid, zeiger->essidlen);\n    essid[zeiger->essidlen] = '\\0';\n    //p = regexec(&essidregex, essid, 0, NULL, 0);\n    //printf(\"%d\\n\", p);\n\tif(regexec(&essidregex, essid, 0, NULL, 0) == REG_NOMATCH) return;\n\t}\nif((filtervendorptr != NULL) || (filtervendorapptr != NULL) || (filtervendorclientptr != NULL))\n\t{\n\tif(isoui(zeiger->ap, zeiger->client) == false) return;\n\t}\nif((flagfilterapless == true) && ((zeiger->mp &0x10) != 0x10)) return;\nif((flagfilterrcchecked == true) && ((zeiger->mp &0x80) == 0x80)) return;\nif((flagfilterrcnotchecked == true) && ((zeiger->mp &0x80) != 0x80)) return;\nif((flagfilterauthorized == true) && ((zeiger->mp &0x07) == 0x00)) return;\nif((flagfilterchallenge == true) && ((zeiger->mp &0x07) != 0x01)) return;\nif(zeiger->type == HCX_TYPE_PMKID)\n\t{\n\tfprintf(fh_pmkideapol, \"WPA*%02d*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\tzeiger->type,\n\t\tzeiger->hash[0], zeiger->hash[1], zeiger->hash[2], zeiger->hash[3], zeiger->hash[4], zeiger->hash[5], zeiger->hash[6], zeiger->hash[7],\n\t\tzeiger->hash[8], zeiger->hash[9], zeiger->hash[10], zeiger->hash[11], zeiger->hash[12], zeiger->hash[13], zeiger->hash[14], zeiger->hash[15],\n\t\tzeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5],\n\t\tzeiger->client[0], zeiger->client[1], zeiger->client[2], zeiger->client[3], zeiger->client[4], zeiger->client[5]);\n\tfor(p = 0; p < zeiger->essidlen; p++) fprintf(fh_pmkideapol, \"%02x\", zeiger->essid[p]);\n\tfprintf(fh_pmkideapol, \"***\\n\");\n\tpmkidwrittencount++;\n\treturn;\n\t}\nif(zeiger->type == HCX_TYPE_EAPOL)\n\t{\n\tfprintf(fh_pmkideapol, \"WPA*%02d*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\tzeiger->type,\n\t\tzeiger->hash[0], zeiger->hash[1], zeiger->hash[2], zeiger->hash[3], zeiger->hash[4], zeiger->hash[5], zeiger->hash[6], zeiger->hash[7],\n\t\tzeiger->hash[8], zeiger->hash[9], zeiger->hash[10], zeiger->hash[11], zeiger->hash[12], zeiger->hash[13], zeiger->hash[14], zeiger->hash[15],\n\t\tzeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5],\n\t\tzeiger->client[0], zeiger->client[1], zeiger->client[2], zeiger->client[3], zeiger->client[4], zeiger->client[5]);\n\tfor(p = 0; p < zeiger->essidlen; p++) fprintf(fh_pmkideapol, \"%02x\", zeiger->essid[p]);\n\tfprintf(fh_pmkideapol, \"*\");\n\tfprintf(fh_pmkideapol, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*\",\n\t\tzeiger->nonce[0], zeiger->nonce[1], zeiger->nonce[2], zeiger->nonce[3], zeiger->nonce[4], zeiger->nonce[5], zeiger->nonce[6], zeiger->nonce[7],\n\t\tzeiger->nonce[8], zeiger->nonce[9], zeiger->nonce[10], zeiger->nonce[11], zeiger->nonce[12], zeiger->nonce[13], zeiger->nonce[14], zeiger->nonce[15],\n\t\tzeiger->nonce[16], zeiger->nonce[17], zeiger->nonce[18], zeiger->nonce[19], zeiger->nonce[20], zeiger->nonce[21], zeiger->nonce[22], zeiger->nonce[23],\n\t\tzeiger->nonce[24], zeiger->nonce[25], zeiger->nonce[26], zeiger->nonce[27], zeiger->nonce[28], zeiger->nonce[29], zeiger->nonce[30], zeiger->nonce[31]);\n\tfor(p = 0; p < zeiger->eapauthlen; p++) fprintf(fh_pmkideapol, \"%02x\", zeiger->eapol[p]);\n\tfprintf(fh_pmkideapol, \"*%02x\\n\", zeiger->mp);\n\teapolwrittencount++;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeeapolpmkidessidgroups(void)\n{\nstatic int cei;\nstatic int ceo;\nstatic hashlist_t *zeiger;\nstatic FILE *fh_pmkideapol;\nstatic struct stat statinfo;\nstatic const char digit[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n\nstatic char groupoutname[PATH_MAX];\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tgroupoutname[0] = 0;\n\tif((zeiger->essidlen < essidlenmin) || (zeiger->essidlen > essidlenmax)) continue;\n\tif(((zeiger->type &hashtype) != HCX_TYPE_PMKID) && ((zeiger->type &hashtype) != HCX_TYPE_EAPOL)) continue;\n\tceo = 0;\n\tfor (cei = 0; cei < zeiger->essidlen; cei++)\n\t\t{\n\t\tgroupoutname[ceo] = digit[(zeiger->essid[cei] & 0xff) >> 4];\n\t\tceo++;\n\t\tgroupoutname[ceo] = digit[zeiger->essid[cei] & 0x0f];\n\t\tceo++;\n\t\t}\n\tgroupoutname[ceo] = 0;\n\tstrcat(&groupoutname[ceo], \".22000\");\n\tif((fh_pmkideapol = fopen(groupoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", groupoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\twritepmkideapolhashline(fh_pmkideapol, zeiger);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tif(groupoutname[0] != 0)\n\t\t{\n\t\tif(stat(groupoutname, &statinfo) == 0)\n\t\t\t{\n\t\t\tif(statinfo.st_size == 0) remove(groupoutname);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeeapolpmkidouigroups(void)\n{\nstatic hashlist_t *zeiger;\nstatic FILE *fh_pmkideapol;\nstatic struct stat statinfo;\nstatic char groupoutname[PATH_MAX];\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tsnprintf(groupoutname, PATH_MAX -1, \"%02x%02x%02x.22000\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2]);\n\tif((fh_pmkideapol = fopen(groupoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", groupoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\twritepmkideapolhashline(fh_pmkideapol, zeiger);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tif(groupoutname[0] != 0)\n\t\t{\n\t\tif(stat(groupoutname, &statinfo) == 0)\n\t\t\t{\n\t\t\tif(statinfo.st_size == 0) remove(groupoutname);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeeapolpmkidmacapgroups(void)\n{\nstatic hashlist_t *zeiger;\nstatic FILE *fh_pmkideapol;\nstatic struct stat statinfo;\nstatic char groupoutname[PATH_MAX];\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tsnprintf(groupoutname, PATH_MAX -1, \"%02x%02x%02x%02x%02x%02x.22000\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5]);\n\tif((fh_pmkideapol = fopen(groupoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", groupoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\twritepmkideapolhashline(fh_pmkideapol, zeiger);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tif(groupoutname[0] != 0)\n\t\t{\n\t\tif(stat(groupoutname, &statinfo) == 0)\n\t\t\t{\n\t\t\tif(statinfo.st_size == 0) remove(groupoutname);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeeapolpmkidmacclientgroups(void)\n{\nstatic hashlist_t *zeiger;\nstatic FILE *fh_pmkideapol;\nstatic struct stat statinfo;\nstatic char groupoutname[PATH_MAX];\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tsnprintf(groupoutname, PATH_MAX -1, \"%02x%02x%02x%02x%02x%02x.22000\", zeiger->client[0], zeiger->client[1], zeiger->client[2], zeiger->client[3], zeiger->client[4], zeiger->client[5]);\n\tif((fh_pmkideapol = fopen(groupoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", groupoutname, strerror(errno));\n\t\treturn;\n\t\t}\n\twritepmkideapolhashline(fh_pmkideapol, zeiger);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tif(groupoutname[0] != 0)\n\t\t{\n\t\tif(stat(groupoutname, &statinfo) == 0)\n\t\t\t{\n\t\t\tif(statinfo.st_size == 0) remove(groupoutname);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writelceapolpmkidfile(char *pmkideapoloutname, long int lcmin, long int lcmax)\n{\nstatic long int lc;\nstatic FILE *fh_pmkideapol;\nstatic hashlist_t *zeiger;\nstatic hashlist_t *zeiger2;\nstatic hashlist_t *zeigerbegin;\nstatic hashlist_t *zeigerend;\nstatic struct stat statinfo;\n\nif(lcmax == 0) lcmax = pmkideapolcount;\nif(lcmin > lcmax) return;\nif(pmkideapoloutname != NULL)\n\t{\n\tif((fh_pmkideapol = fopen(pmkideapoloutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", pmkideapoloutname, strerror(errno));\n\t\treturn;\n\t\t}\n\t}\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essid);\nzeigerbegin = hashlist;\nlc = 0;\nfor(zeiger = hashlist +1; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t{\n\tif(memcmp(zeigerbegin->essid, zeiger->essid, ESSID_LEN_MAX) == 0)\n\t\t{\n\t\tzeigerend = zeiger;\n\t\tlc++;\n\t\t}\n\telse\n\t\t{\n\t\tif(((zeigerend -zeigerbegin) >= lcmin) && ((zeigerend -zeigerbegin) <= lcmax))\n\t\t\t{\n\t\t\tfor(zeiger2 = zeigerbegin; zeiger2 <= zeigerend; zeiger2++) writepmkideapolhashline(fh_pmkideapol, zeiger2);\n\t\t\t}\n\t\tlc = 0;\n\t\tzeigerbegin = zeiger;\n\t\t}\n\t}\nif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\nif(pmkideapoloutname != NULL)\n\t{\n\tif(stat(pmkideapoloutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkideapoloutname);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeeapolpmkidfile(char *pmkideapoloutname)\n{\nstatic FILE *fh_pmkideapol;\nstatic hashlist_t *zeiger;\nstatic struct stat statinfo;\n\nif(pmkideapoloutname != NULL)\n\t{\n\tif((fh_pmkideapol = fopen(pmkideapoloutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", pmkideapoloutname, strerror(errno));\n\t\treturn;\n\t\t}\n\t}\nfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++) writepmkideapolhashline(fh_pmkideapol, zeiger);\nif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\nif(pmkideapoloutname != NULL)\n\t{\n\tif(stat(pmkideapoloutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkideapoloutname);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writepmkideapolhashlineinfo(FILE *fh_pmkideapol, hashlist_t *zeiger)\n{\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint8_t keyver;\nstatic uint8_t keyinfo;\nstatic uint64_t rc;\nstatic char *vendor;\nstatic char essid[ESSID_LEN_MAX+1];\n\nif((zeiger->essidlen < essidlenmin) || (zeiger->essidlen > essidlenmax)) return;\nif(((zeiger->type &hashtype) != HCX_TYPE_PMKID) && ((zeiger->type &hashtype) != HCX_TYPE_EAPOL)) return;\nif(flagfiltermacap == true) if(memcmp(&filtermacap, zeiger->ap, 6) != 0) return;\nif(flagfiltermacclient == true) if(memcmp(&filtermacclient, zeiger->client, 6) != 0) return;\nif(flagfilterouiap == true) if(memcmp(&filterouiap, zeiger->ap, 3) != 0) return;\nif(flagfilterouiclient == true) if(memcmp(&filterouiclient, zeiger->client, 3) != 0) return;\nif(filteressidptr != NULL)\n\t{\n\tif(zeiger->essidlen != filteressidlen) return;\n\tif(memcmp(zeiger->essid, filteressidptr, zeiger->essidlen) != 0) return;\n\t}\nif(filteressidpartptr != NULL)\n\t{\n\tif(ispartof(filteressidpartlen, (uint8_t*)filteressidpartptr, zeiger->essidlen, zeiger->essid) == false) return;\n\t}\nif(filteressidregexptr != NULL)\n\t{\n\tstrncpy(essid, (char *) zeiger->essid, zeiger->essidlen);\n    essid[zeiger->essidlen] = '\\0';\n\tif(regexec(&essidregex, essid, 0, NULL, 0) == REG_NOMATCH) return;\n\t}\nif((filtervendorptr != NULL) || (filtervendorapptr != NULL) || (filtervendorclientptr != NULL))\n\t{\n\tif(isoui(zeiger->ap, zeiger->client) == false) return;\n\t}\nif((flagfilterapless == true) && ((zeiger->mp &0x10) != 0x10)) return;\nif((flagfilterrcchecked == true) && ((zeiger->mp &0x80) == 0x80)) return;\nif((flagfilterrcnotchecked == true) && ((zeiger->mp &0x80) != 0x80)) return;\nif((flagfilterauthorized == true) && ((zeiger->mp &0x07) == 0x00)) return;\nif((flagfilterchallenge == true) && ((zeiger->mp &0x07) != 0x01)) return;\n\nfprintf(fh_pmkideapol, \"SSID.......: %.*s\\n\", zeiger->essidlen, zeiger->essid);\nvendor = getvendor(zeiger->ap);\nfprintf(fh_pmkideapol, \"MAC_AP.....: %02x%02x%02x%02x%02x%02x (%s)\\n\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2], zeiger->ap[3], zeiger->ap[4], zeiger->ap[5], vendor);\nvendor = getvendor(zeiger->client);\nfprintf(fh_pmkideapol, \"MAC_CLIENT.: %02x%02x%02x%02x%02x%02x (%s)\\n\", zeiger->client[0], zeiger->client[1], zeiger->client[2], zeiger->client[3], zeiger->client[4], zeiger->client[5], vendor);\nif(zeiger->type == HCX_TYPE_PMKID)\n\t{\n\tfprintf(fh_pmkideapol, \"PMKID......: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\tzeiger->hash[0], zeiger->hash[1], zeiger->hash[2], zeiger->hash[3], zeiger->hash[4], zeiger->hash[5], zeiger->hash[6], zeiger->hash[7],\n\t\tzeiger->hash[8], zeiger->hash[9], zeiger->hash[10], zeiger->hash[11], zeiger->hash[12], zeiger->hash[13], zeiger->hash[14], zeiger->hash[15]);\n\t}\nif(zeiger->type == HCX_TYPE_EAPOL)\n\t{\n\teapa = (eapauth_t*)zeiger->eapol;\n\twpak = (wpakey_t*)&zeiger->eapol[EAPAUTH_SIZE];\n\tif(eapa->version == 1) fprintf(fh_pmkideapol, \"VERSION....: 802.1X-2001 (1)\\n\");\n\tif(eapa->version == 2) fprintf(fh_pmkideapol, \"VERSION....: 802.1X-2004 (2)\\n\");\n\tkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\tif(keyver == 1) fprintf(fh_pmkideapol, \"KEY VERSION: WPA1\\n\");\n\tif(keyver == 2) fprintf(fh_pmkideapol, \"KEY VERSION: WPA2\\n\");\n\tif(keyver == 3) fprintf(fh_pmkideapol, \"KEY VERSION: WPA2 key version 3\\n\");\n\t#ifndef BIG_ENDIAN_HOST\n\trc = byte_swap_64(wpak->replaycount);\n\t#else\n\trc = wpak->replaycount;\n\t#endif\n\tfprintf(fh_pmkideapol, \"REPLAYCOUNT: %\" PRIu64 \"\\n\", rc);\n\tif((zeiger->mp & 0x20) == 0x20) fprintf(fh_pmkideapol, \"ROUTER TYPE: little endian (LE)\\n\");\n\telse if((zeiger->mp & 0x40) == 0x40) fprintf(fh_pmkideapol, \"ROUTER TYPE: big endian (BE)\\n\");\n\tif((zeiger->mp & 0xf0) == 0x10) fprintf(fh_pmkideapol, \"NC INFO....: NC deactivated\\n\");\n\telse if((zeiger->mp & 0x80) == 0x80) fprintf(fh_pmkideapol, \"NC INFO....: hashcat default NC activated\\n\");\n\telse fprintf(fh_pmkideapol, \"NC INFO....: NC not detected\\n\");\n\tkeyinfo = (getkeyinfo(ntohs(wpak->keyinfo)));\n\tfprintf(fh_pmkideapol, \"EAPOL MSG..: %d\\n\", keyinfo);\n\tif((zeiger->mp & 0x07) == 0x00) fprintf(fh_pmkideapol, \"MP M1M2 E2.: challenge\\n\");\n\tif((zeiger->mp & 0x07) == 0x01) fprintf(fh_pmkideapol, \"MP M1M4 E4.: authorized\\n\");\n\tif((zeiger->mp & 0x07) == 0x02) fprintf(fh_pmkideapol, \"MP M2M3 E2.: authorized\\n\");\n\tif((zeiger->mp & 0x07) == 0x03) fprintf(fh_pmkideapol, \"MP M2M3 E3.: authorized\\n\");\n\tif((zeiger->mp & 0x07) == 0x04) fprintf(fh_pmkideapol, \"MP M3M4 E3.: authorized\\n\");\n\tif((zeiger->mp & 0x07) == 0x05) fprintf(fh_pmkideapol, \"MP M3M4 E4.: authorized\\n\");\n\tfprintf(fh_pmkideapol, \"MIC........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\tzeiger->hash[0], zeiger->hash[1], zeiger->hash[2], zeiger->hash[3], zeiger->hash[4], zeiger->hash[5], zeiger->hash[6], zeiger->hash[7],\n\t\tzeiger->hash[8], zeiger->hash[9], zeiger->hash[10], zeiger->hash[11], zeiger->hash[12], zeiger->hash[13], zeiger->hash[14], zeiger->hash[15]);\n\t}\nfprintf(fh_pmkideapol, \"HASHLINE...: \");\nwritepmkideapolhashline(fh_pmkideapol, zeiger);\nfprintf(fh_pmkideapol, \"\\n\");\nreturn;\n}\n/*===========================================================================*/\nstatic void writevendorapinfofile(char *vendorinfooutname)\n{\nstatic char *vendor;\nstatic hashlist_t *zeiger;\nstatic FILE *fh_info;\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_macap);\nif(strcmp(vendorinfooutname, \"stdout\") != 0)\n\t{\n\tif((fh_info = fopen(vendorinfooutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", vendorinfooutname, strerror(errno));\n\t\treturn;\n\t\t}\n\tvendor = getvendor(hashlist->ap);\n\tfprintf(fh_info, \"%02x%02x%02x\\t%s\\t[ACCESS POINT]\\n\", hashlist->ap[0], hashlist->ap[1], hashlist->ap[2], vendor);\n\tfor(zeiger = hashlist +1; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t\t{\n\t\tif(memcmp((zeiger -1)->ap, zeiger->ap, 3) != 0)\n\t\t\t{\n\t\t\tvendor = getvendor(zeiger->ap);\n\t\t\tfprintf(fh_info, \"%02x%02x%02x\\t%s\\t[ACCESS POINT]\\n\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2], vendor);\n\t\t\t}\n\t\t}\n\tfclose(fh_info);\n\t}\nelse\n\t{\n\tvendor = getvendor(hashlist->ap);\n\tfprintf(stdout, \"%02x%02x%02x\\t%s\\t[ACCESS POINT]\\n\", hashlist->ap[0], hashlist->ap[1], hashlist->ap[2], vendor);\n\tfor(zeiger = hashlist +1; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t\t{\n\t\tif(memcmp((zeiger -1)->ap, zeiger->ap, 3) != 0)\n\t\t\t{\n\t\t\tvendor = getvendor(zeiger->ap);\n\t\t\tfprintf(stdout, \"%02x%02x%02x\\t%s\\t[ACCESS POINT]\\n\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2], vendor);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writevendorclientinfofile(char *vendorinfooutname)\n{\nstatic char *vendor;\nstatic hashlist_t *zeiger;\nstatic FILE *fh_info;\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_macclient);\nif(strcmp(vendorinfooutname, \"stdout\") != 0)\n\t{\n\tif((fh_info = fopen(vendorinfooutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", vendorinfooutname, strerror(errno));\n\t\treturn;\n\t\t}\n\tvendor = getvendor(hashlist->client);\n\tfprintf(fh_info, \"%02x%02x%02x\\t%s\\t[CLIENT]\\n\", hashlist->client[0], hashlist->client[1], hashlist->client[2], vendor);\n\tfor(zeiger = hashlist +1; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t\t{\n\t\tif(memcmp((zeiger -1)->client, zeiger->client, 3) != 0)\n\t\t\t{\n\t\t\tvendor = getvendor(zeiger->client);\n\t\t\tfprintf(fh_info, \"%02x%02x%02x\\t%s\\t[CLIENT]\\n\", zeiger->client[0], zeiger->client[1], zeiger->client[2], vendor);\n\t\t\t}\n\t\t}\n\tfclose(fh_info);\n\t}\nelse\n\t{\n\tvendor = getvendor(hashlist->ap);\n\tfprintf(stdout, \"%02x%02x%02x\\t%s\\t[CLIENT]\\n\", hashlist->ap[0], hashlist->ap[1], hashlist->ap[2], vendor);\n\tfor(zeiger = hashlist +1; zeiger < hashlist +pmkideapolcount; zeiger++)\n\t\t{\n\t\tif(memcmp((zeiger -1)->ap, zeiger->ap, 3) != 0)\n\t\t\t{\n\t\t\tvendor = getvendor(zeiger->ap);\n\t\t\tfprintf(stdout, \"%02x%02x%02x\\t%s\\t[CLIENT]\\n\", zeiger->ap[0], zeiger->ap[1], zeiger->ap[2], vendor);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeinfofile(char *infooutname)\n{\nstatic hashlist_t *zeiger;\nstatic FILE *fh_info;\n\nif(strcmp(infooutname, \"stdout\") != 0)\n\t{\n\tif((fh_info = fopen(infooutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", infooutname, strerror(errno));\n\t\treturn;\n\t\t}\n\tfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++) writepmkideapolhashlineinfo(fh_info, zeiger);\n\tfclose(fh_info);\n\t}\nelse\n\t{\n\tfor(zeiger = hashlist; zeiger < hashlist +pmkideapolcount; zeiger++) writepmkideapolhashlineinfo(stdout, zeiger);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic uint16_t getfield(char *lineptr, size_t bufflen, uint8_t *buff)\n{\nstatic size_t p;\nstatic uint8_t idx0;\nstatic uint8_t idx1;\nstatic const uint8_t hashmap[] =\n{\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567\n0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;<=>?\n0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PQRSTUVW\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XYZ[\\]^_\n0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // `abcdefg\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // hijklmno\n};\n\nmemset(buff, 0, bufflen);\np = 0;\nwhile((lineptr[p] != '*') && (lineptr[p] != 0) && (p /2 <= bufflen))\n\t{\n\tif(!isxdigit((unsigned char)lineptr[p +0])) return 0;\n\tif(!isxdigit((unsigned char)lineptr[p +1])) return 0;\n\tif((lineptr[p +1] == '*') || (lineptr[p +1] == 0)) return 0;\n\tidx0 = ((uint8_t)lineptr[p +0] &0x1F) ^0x10;\n\tidx1 = ((uint8_t)lineptr[p +1] &0x1F) ^0x10;\n\tbuff[p /2] = (uint8_t)(hashmap[idx0] <<4) | hashmap[idx1];\n\tp += 2;\n\t}\nreturn p /2;\n}\n/*===========================================================================*/\nstatic void removepmkideapol(char *macskipname)\n{\nstatic int len;\nstatic int p1, p2;\nstatic FILE *fh_maclistin;\nstatic long int i, f, r;\nstatic int maclistskipcount, maclistskipmax;\nstatic maclist_t *maclistskip, *zeiger, *maclistskipnew;\nstatic hashlist_t *zeigerhash;\nstatic char linein[PMKIDEAPOL_BUFFER_LEN];\n\nmaclistskipmax = 1000;\nif((maclistskip = (maclist_t*)calloc(maclistskipmax, MACLIST_SIZE)) == NULL) return;\nif((fh_maclistin = fopen(macskipname, \"r\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening file %s: %s\\n\", macskipname, strerror(errno));\n\treturn;\n\t}\nzeiger = maclistskip;\nmaclistskipcount = 0;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_maclistin, PMKIDEAPOL_BUFFER_LEN, linein)) == -1) break;\n\tif(len < 12) continue;\n\tif(len > 17)\n\t\t{\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < 17; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)linein[p1]))\n\t\t\t\t{\n\t\t\t\tlinein[p2] = linein[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\tlinein[p2] = 0;\n\t\tlen = p2;\n\t\t}\n\tlinein[12] = 0;\n\tif(getfield(linein, 6, zeiger->mac) != 6) continue;\n\tmaclistskipcount++;\n\tif(maclistskipcount >= maclistskipmax)\n\t\t{\n\t\tmaclistskipmax += 1000;\n\t\tmaclistskipnew = (maclist_t*)realloc(maclistskip, maclistskipmax *MACLIST_SIZE);\n\t\tif(maclistskipnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tmaclistskip = maclistskipnew;\n\t\t}\n\tzeiger = maclistskip +maclistskipcount;\n\t}\nif(fh_maclistin != NULL) fclose(fh_maclistin);\nqsort(maclistskip, maclistskipcount, MACLIST_SIZE, sort_maclistin);\n\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_macap);\nzeigerhash = hashlist;\nzeiger = maclistskip;\nf = 0;\nr = 0;\nfor(i = 0; i < pmkideapolcount; i++)\n\t{\n\tf = 0;\n\twhile(f < maclistskipcount)\n\t\t{\n\t\tif(memcmp((zeigerhash +i)->ap, (zeiger +f)->mac, 6) == 0)\n\t\t\t{\n\t\t\t(zeigerhash +i)->type = HS_REMOVED;\n\t\t\tr++;\n\t\t\t}\n\t\tif(memcmp((zeiger +f)->mac, (zeigerhash +i)->ap, 6) >= 0) break;\n\t\tf++;\n\t\t}\n\t}\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_type);\npmkidcount -= r;\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_macclient);\nzeigerhash = hashlist;\nzeiger = maclistskip;\nf = 0;\nr = 0;\nfor(i = 0; i < pmkideapolcount; i++)\n\t{\n\tif(memcmp((zeigerhash +i)->client, (zeiger +f)->mac, 6) > 0)\n\twhile(f < maclistskipcount)\n\t\t{\n\t\tif(memcmp((zeiger +f)->mac, (zeigerhash +i)->client, 6) >= 0) break;\n\t\tf++;\n\t\t}\n\tif(memcmp((zeigerhash +i)->client, (zeiger +f)->mac, 6) == 0)\n\t\t{\n\t\t(zeigerhash +i)->type = HS_REMOVED;\n\t\tr++;\n\t\t}\n\t}\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_type);\npmkidcount -= r;\nif(maclistskip != NULL) free(maclistskip);\nreturn;\n}\n/*===========================================================================*/\nstatic void processmacfile(char *maclistinname, char *pmkideapoloutname)\n{\nstatic int len;\nstatic int p1, p2;\nstatic FILE *fh_maclistin;\nstatic FILE *fh_pmkideapol;\nstatic struct stat statinfo;\nstatic int maclistincount, maclistinmax;\nstatic maclist_t *maclistin, *zeiger, *maclistinnew;\nstatic hashlist_t *zeigerhash;\nstatic int i, o;\n\nstatic char linein[PMKIDEAPOL_BUFFER_LEN];\n\nmaclistinmax = 1000;\nif((maclistin = (maclist_t*)calloc(maclistinmax, MACLIST_SIZE)) == NULL) return;\nif((fh_maclistin = fopen(maclistinname, \"r\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening file %s: %s\\n\", maclistinname, strerror(errno));\n\treturn;\n\t}\nzeiger = maclistin;\nmaclistincount = 0;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_maclistin, PMKIDEAPOL_BUFFER_LEN, linein)) == -1) break;\n\tif(len == 17)\n\t\t{\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < 17; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)linein[p1]))\n\t\t\t\t{\n\t\t\t\tlinein[p2] = linein[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\tlinein[p2] = 0;\n\t\tlen = p2;\n\t\t}\n\tif(len != 12) continue;\n\tif(getfield(linein, 6, zeiger->mac) != 6) continue;\n\tmaclistincount++;\n\tif(maclistincount >= maclistinmax)\n\t\t{\n\t\tmaclistinmax += 1000;\n\t\tmaclistinnew = (maclist_t*)realloc(maclistin, maclistinmax *MACLIST_SIZE);\n\t\tif(maclistinnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stdout, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tmaclistin = maclistinnew;\n\t\t}\n\tzeiger = maclistin +maclistincount;\n\t}\nif(fh_maclistin != NULL) fclose(fh_maclistin);\nqsort(maclistin, maclistincount, MACLIST_SIZE, sort_maclistin);\nif(pmkideapoloutname != NULL)\n\t{\n\tif((fh_pmkideapol = fopen(pmkideapoloutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", pmkideapoloutname, strerror(errno));\n\t\tfree(maclistin);\n\t\treturn;\n\t\t}\n\t}\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_macap);\nzeiger = maclistin;\nzeigerhash = hashlist;\no = 0;\nfor(i = 0; i < maclistincount; i++)\n\t{\n\twhile(o < pmkideapolcount)\n\t\t{\n\t\tif(memcmp((zeigerhash +o)->ap, (zeiger +i)->mac, 6) > 0) break;\n\t\tif(memcmp((zeigerhash +o)->ap, (zeiger +i)->mac, 6) == 0) writepmkideapolhashline(fh_pmkideapol, zeigerhash +o);\n\t\to++;\n\t\t}\n\t}\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_macclient);\nzeiger = maclistin;\nzeigerhash = hashlist;\no = 0;\nfor(i = 0; i < maclistincount; i++)\n\t{\n\twhile(o < pmkideapolcount)\n\t\t{\n\t\tif(memcmp((zeigerhash +o)->client, (zeiger +i)->mac, 6) > 0) break;\n\t\tif(memcmp((zeigerhash +o)->client, (zeiger +i)->mac, 6) == 0) writepmkideapolhashline(fh_pmkideapol, zeigerhash +o);\n\t\to++;\n\t\t}\n\t}\nif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\nif(pmkideapoloutname != NULL)\n\t{\n\tif(stat(pmkideapoloutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkideapoloutname);\n\t\t}\n\t}\nif(maclistin != NULL) free(maclistin);\nreturn;\n}\n/*===========================================================================*/\nstatic void processessidfile(char *essidlistinname, char *pmkideapoloutname)\n{\nstatic int len;\nstatic int i, o;\nstatic FILE *fh_essidlistin;\nstatic FILE *fh_pmkideapol;\nstatic struct stat statinfo;\nstatic int essidlistincount, essidlistinmax;\nstatic essidlist_t *essidlistin, *zeiger, *essidlistinnew;\nstatic hashlist_t *zeigerhash;\nstatic char hexpfx[] = { \"$HEX[\" };\nstatic char linein[PMKIDEAPOL_BUFFER_LEN];\n\nessidlistinmax = 1000;\nif((essidlistin = (essidlist_t*)calloc(essidlistinmax, ESSIDLIST_SIZE)) == NULL) return;\nif((fh_essidlistin = fopen(essidlistinname, \"r\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening file %s: %s\\n\", essidlistinname, strerror(errno));\n\treturn;\n\t}\nzeiger = essidlistin;\nessidlistincount = 0;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_essidlistin, PMKIDEAPOL_BUFFER_LEN, linein)) == -1) break;\n\tif((len < 1) || (len > 70)) continue;\n\tmemset(zeiger->essid, 0, 33);\n\tif((len >= 8) && ((len %2) == 0) && (linein[len -1] == ']') && (memcmp(linein, hexpfx, 5) == 0))\n\t\t{\n\t\tlinein[len -1] = 0;\n\t\tzeiger->essidlen = getfield(&linein[5], 32, zeiger->essid);\n\t\t}\n\telse if(len <= 32)\n\t\t{\n\t\tzeiger->essidlen = len;\n\t\tmemcpy(zeiger->essid, linein, len);\n\t\t}\n\telse continue;\n\tessidlistincount++;\n\tif(essidlistincount >= essidlistinmax)\n\t\t{\n\t\tessidlistinmax += 1000;\n\t\tessidlistinnew = (essidlist_t*)realloc(essidlistin, essidlistinmax *ESSIDLIST_SIZE);\n\t\tif(essidlistinnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tessidlistin = essidlistinnew;\n\t\t}\n\tzeiger = essidlistin +essidlistincount;\n\t}\nif(fh_essidlistin != NULL) fclose(fh_essidlistin);\nqsort(essidlistin, essidlistincount, ESSIDLIST_SIZE, sort_essidlistin);\nqsort(hashlist, pmkideapolcount, HASHLIST_SIZE, sort_hashlist_by_essidlen);\nif(pmkideapoloutname == NULL)\n\t{\n\tif(essidlistin != NULL) free(essidlistin);\n\treturn;\n\t}\nif((fh_pmkideapol = fopen(pmkideapoloutname, \"a\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening file %s: %s\\n\", pmkideapoloutname, strerror(errno));\n\tfree(essidlistin);\n\treturn;\n\t}\nzeiger = essidlistin;\nzeigerhash = hashlist;\no = 0;\nfor(i = 0; i < essidlistincount; i++)\n\t{\n\twhile(o < pmkideapolcount)\n\t\t{\n\t\tif((zeigerhash +o)->essidlen < (zeiger +i)->essidlen)\n\t\t\t{\n\t\t\to++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif((zeigerhash +o)->essidlen > (zeiger +i)->essidlen) break;\n\t\tif((memcmp((zeigerhash +o)->essid, (zeiger +i)->essid, (zeigerhash +o)->essidlen)) > 0) break;\n\t\tif((memcmp((zeigerhash +o)->essid, (zeiger +i)->essid, (zeigerhash +o)->essidlen)) == 0) writepmkideapolhashline(fh_pmkideapol, zeigerhash +o);\n\t\to++;\n\t\t}\n\t}\nif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\nif(pmkideapoloutname != NULL)\n\t{\n\tif(stat(pmkideapoloutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkideapoloutname);\n\t\t}\n\t}\nif(essidlistin != NULL) free(essidlistin);\nreturn;\n}\n/*===========================================================================*/\nstatic void readpmkideapolfile(FILE *fh_pmkideapol)\n{\nstatic int len;\nstatic int oflen;\nstatic uint16_t essidlen;\nstatic uint16_t noncelen;\nstatic uint16_t eapauthlen;\nstatic uint16_t mplen;\nstatic hashlist_t *zeiger, *hashlistnew;\nstatic const char wpa01[] = { \"WPA*01*\" };\nstatic const char wpa02[] = { \"WPA*02*\" };\n\nstatic char linein[PMKIDEAPOL_LINE_LEN +1];\nstatic uint8_t buffer[PMKIDEAPOL_LINE_LEN +1];\n\nzeiger = hashlist;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_pmkideapol, PMKIDEAPOL_LINE_LEN, linein)) == -1) break;\n\treadcount++;\n\tif(len < 68)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif((memcmp(&linein, &wpa01, 7) != 0) && (memcmp(&linein, &wpa02, 7) != 0))\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif((linein[39] != '*') && (linein[52] != '*') && (linein[65] != '*'))\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif(getfield(&linein[7], PMKIDEAPOL_LINE_LEN, buffer) != 16)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(zeiger->hash, &buffer, 16);\n\n\tif(getfield(&linein[40], PMKIDEAPOL_LINE_LEN, buffer) != 6)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(zeiger->ap, &buffer, 6);\n\n\tif(getfield(&linein[53], PMKIDEAPOL_LINE_LEN, buffer) != 6)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(zeiger->client, &buffer, 6);\n\tessidlen = getfield(&linein[66], PMKIDEAPOL_LINE_LEN, buffer);\n\tif(essidlen > 32)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(zeiger->essid, &buffer, essidlen);\n\tzeiger->essidlen = essidlen;\n\tif(memcmp(&linein, &wpa01, 7) == 0)\n\t\t{\n\t\tzeiger->type = HS_PMKID;\n\t\tpmkidcount++;\n\t\t}\n\telse if(memcmp(&linein, &wpa02, 7) == 0)\n\t\t{\n\t\toflen = 66 +essidlen *2 +1;\n\t\tnoncelen = getfield(&linein[oflen], PMKIDEAPOL_LINE_LEN, buffer);\n\t\tif(noncelen > 32)\n\t\t\t{\n\t\t\treaderrorcount++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tmemcpy(zeiger->nonce, &buffer, 32);\n\t\toflen += 65;\n\t\teapauthlen = getfield(&linein[oflen], PMKIDEAPOL_LINE_LEN, buffer);\n\t\tif(eapauthlen > EAPOL_AUTHLEN_MAX +4)\n\t\t\t{\n\t\t\treaderrorcount++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tmemcpy(zeiger->eapol, &buffer, eapauthlen);\n\t\tzeiger->eapauthlen = eapauthlen;\n\t\toflen += eapauthlen *2 +1;\n\t\tmplen = getfield(&linein[oflen], PMKIDEAPOL_LINE_LEN, buffer);\n\t\tif(mplen > 1)\n\t\t\t{\n\t\t\treaderrorcount++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tzeiger->mp = buffer[0];\n\t\tzeiger->type = HS_EAPOL;\n\t\teapolcount++;\n\t\t}\n\telse\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tpmkideapolcount = pmkidcount +eapolcount;\n\tif(pmkideapolcount >= hashlistcount)\n\t\t{\n\t\thashlistcount += HASHLIST_MAX;\n\t\thashlistnew = (hashlist_t*)realloc(hashlist, hashlistcount *HASHLIST_SIZE);\n\t\tif(hashlistnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\thashlist = hashlistnew;\n\t\t}\n\tzeiger = hashlist +pmkideapolcount;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic int get_keyinfo(uint16_t kyif)\n{\nif(kyif & WPA_KEY_INFO_ACK)\n\t{\n\tif(kyif & WPA_KEY_INFO_INSTALL) return 3; /* handshake 3 */\n\telse return 1; /* handshake 1 */\n\t}\nelse\n\t{\n\tif(kyif & WPA_KEY_INFO_SECURE) return 4; /* handshake 4 */\n\telse return 2; /* handshake 2 */\n\t}\nreturn 0;\n}\n/*===========================================================================*/\nstatic void readhccapxfile(int fd_hccapxin, long int hccapxrecords)\n{\nstatic long int c;\nstatic hccapx_t *hccapxptr;\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint8_t keyver;\nstatic uint16_t keylen;\nstatic hashlist_t *zeiger, *hashlistnew;\nstatic uint8_t hccapxblock[HCCAPX_SIZE];\n\nhccapxptr = (hccapx_t*)hccapxblock;\nzeiger = hashlist;\nfor(c = 0; c < hccapxrecords; c++)\n\t{\n\treadcount++;\n\tif(read(fd_hccapxin, hccapxblock, HCCAPX_SIZE) != HCCAPX_SIZE)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif(hccapxptr->signature != HCCAPX_SIGNATURE)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif((hccapxptr->version != 3) && (hccapxptr->version != 4))\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif((hccapxptr->essid_len == 0) || (hccapxptr->essid_len > ESSID_LEN_MAX))\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\twpak = (wpakey_t*)&hccapxptr->eapol[EAPAUTH_SIZE];\n\tif((keyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK) == 0)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif(keyver != hccapxptr->keyver)\n\t\t{\n\t\treaderrorcount++;\n\t\tif(keyver > 3) continue;\n\t\tif(keyver == 0) continue;\n\t\tcorrectedcount++;\n\t\t}\n\teapa = (eapauth_t*)hccapxptr->eapol;\n\tkeylen = ntohs(eapa->len) +EAPAUTH_SIZE;\n\tif(keylen != hccapxptr->eapol_len)\n\t\t{\n\t\treaderrorcount++;\n\t\tif(keylen > 255) continue;\n\t\tcorrectedcount++;\n\t\t}\n\tmemcpy(zeiger->ap, hccapxptr->ap, 6);\n\tmemcpy(zeiger->client, hccapxptr->client, 6);\n\tmemcpy(zeiger->essid, hccapxptr->essid, hccapxptr->essid_len);\n\tzeiger->essidlen = hccapxptr->essid_len;\n\tmemcpy(zeiger->hash, hccapxptr->keymic, 16);\n\tzeiger->eapauthlen = keylen;\n\tmemcpy(zeiger->eapol, hccapxptr->eapol, hccapxptr->eapol_len);\n\tif(memcmp(hccapxptr->anonce, wpak->nonce, 32) != 0) memcpy(zeiger->nonce, hccapxptr->anonce, 32);\n\telse if(memcmp(hccapxptr->snonce, wpak->nonce, 32) != 0) memcpy(zeiger->nonce, hccapxptr->snonce, 32);\n\telse\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tzeiger->type = HS_EAPOL;\n\tzeiger->mp = hccapxptr->message_pair;\n\teapolcount++;\n\tpmkideapolcount = pmkidcount +eapolcount;\n\tif(pmkideapolcount >= hashlistcount)\n\t\t{\n\t\thashlistcount += HASHLIST_MAX;\n\t\thashlistnew = (hashlist_t*)realloc(hashlist, hashlistcount *HASHLIST_SIZE);\n\t\tif(hashlistnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\thashlist = hashlistnew;\n\t\t}\n\tzeiger = hashlist +pmkideapolcount;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void readhccapfile(int fd_hccapin, long int hccaprecords)\n{\nstatic long int c;\nuint8_t el;\nstatic hccap_t *hccapptr;\nstatic eapauth_t *eapa;\nstatic wpakey_t *wpak;\nstatic uint8_t keyver;\nstatic uint16_t keylen;\nstatic uint16_t keyinfo = 0;\n\nstatic hashlist_t *zeiger, *hashlistnew;\nstatic uint8_t hccapblock[HCCAP_SIZE];\n\nhccapptr = (hccap_t*)hccapblock;\nzeiger = hashlist;\nfor(c = 0; c < hccaprecords; c++)\n\t{\n\treadcount++;\n\tif(read(fd_hccapin, hccapblock, HCCAP_SIZE) != HCCAP_SIZE)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\twpak = (wpakey_t*)&hccapptr->eapol[EAPAUTH_SIZE];\n\tif((keyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK) == 0)\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tif(keyver != hccapptr->keyver)\n\t\t{\n\t\treaderrorcount++;\n\t\tif(keyver > 3) continue;\n\t\tif(keyver == 0) continue;\n\t\tcorrectedcount++;\n\t\t}\n\teapa = (eapauth_t*)hccapptr->eapol;\n\tkeylen = ntohs(eapa->len) +EAPAUTH_SIZE;\n\tif(keylen != hccapptr->eapol_size)\n\t\t{\n\t\treaderrorcount++;\n\t\tif(keylen > 255) continue;\n\t\tcorrectedcount++;\n\t\tcontinue;\n\t\t}\n\tmemcpy(zeiger->ap, hccapptr->ap, 6);\n\tmemcpy(zeiger->client, hccapptr->client, 6);\n\tel = 0;\n\twhile(el < ESSID_LEN_MAX)\n\t\t{\n\t\tif(hccapptr->essid[el] == 0) break;\n\t\tel++;\n\t\t}\n\tmemcpy(zeiger->essid, hccapptr->essid, el);\n\tzeiger->essidlen = el;\n\tmemcpy(zeiger->hash, hccapptr->keymic, 16);\n\tzeiger->eapauthlen = keylen;\n\tmemcpy(zeiger->eapol, hccapptr->eapol, hccapptr->eapol_size);\n\tif(memcmp(hccapptr->anonce, wpak->nonce, 32) != 0) memcpy(zeiger->nonce, hccapptr->anonce, 32);\n\telse if(memcmp(hccapptr->snonce, wpak->nonce, 32) != 0) memcpy(zeiger->nonce, hccapptr->snonce, 32);\n\telse\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\tzeiger->type = HS_EAPOL;\n\tkeyinfo = (get_keyinfo(ntohs(wpak->keyinfo)));\n\tif(keyinfo == 2) zeiger->mp = 0x80;\n\telse if(keyinfo == 4) zeiger->mp = 0x81;\n\telse if(keyinfo == 3) zeiger->mp = 0x03;\n\telse\n\t\t{\n\t\treaderrorcount++;\n\t\tcontinue;\n\t\t}\n\teapolcount++;\n\tpmkideapolcount = pmkidcount +eapolcount;\n\tif(pmkideapolcount >= hashlistcount)\n\t\t{\n\t\thashlistcount += HASHLIST_MAX;\n\t\thashlistnew = (hashlist_t*)realloc(hashlist, hashlistcount *HASHLIST_SIZE);\n\t\tif(hashlistnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\thashlist = hashlistnew;\n\t\t}\n\tzeiger = hashlist +pmkideapolcount;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic bool readbpkdf2file(char *pkdf2inname)\n{\nstatic int len;\nstatic char *pskpos;\nstatic FILE *fh_pbkdf2;\nstatic char linein[PBKDF2_LINE_LEN +1];\n\nif((fh_pbkdf2 = fopen(pkdf2inname, \"r\")) == NULL)\n\t{\n\tfprintf(stdout, \"error opening file %s: %s\\n\", pkdf2inname, strerror(errno));\n\treturn false;\n\t}\npbkdf2count = 0;\npbkdf2readerrorcount = 0;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_pbkdf2, PBKDF2_LINE_LEN, linein)) == -1) break;\n\tif(len < 76)\n\t\t{\n\t\tpbkdf2readerrorcount++;\n\t\tcontinue;\n\t\t}\n\tif(linein[64] != '*')\n\t\t{\n\t\tpbkdf2readerrorcount++;\n\t\tcontinue;\n\t\t}\n\tpskpos = strchr(&linein[65], ':');\n\tif(pskpos == NULL)\n\t\t{\n\t\tpbkdf2readerrorcount++;\n\t\tcontinue;\n\t\t}\n\tpskpos[0] = 0;\n\tfprintf(stdout, \"%s %s\\n\", &linein[65], pskpos +1);\n\tpbkdf2count++;\n\t}\nfclose(fh_pbkdf2);\nreturn true;\n}\n/*===========================================================================*/\nstatic void showvendorlist(void)\n{\nstatic ouilist_t *zeiger;\n\nfprintf(stdout, \"\\n\");\nfor(zeiger = ouilist; zeiger < ouilist +ouicount; zeiger++) fprintf(stdout, \"%02x%02x%02x %s\\n\", zeiger->oui[0], zeiger->oui[1], zeiger->oui[2], zeiger->vendor); \nreturn;\n}\n/*===========================================================================*/\nstatic int isvendor(int len, char *linein)\n{\nstatic int c;\nstatic int ret;\n\nfor(c = 7; c < len; c++)\n\t{\n\tif(islower((unsigned char)linein[c])) linein[c] = toupper((unsigned char)linein[c]);\n\t}\nret = 0;\nif(filtervendorptr != NULL)\n\t{\n\tif(strstr(&linein[7], filtervendorptr) != NULL) ret |= TYPE_AP + TYPE_CLIENT;\n\t}\nif(filtervendorapptr != NULL)\n\t{\n\tif(strstr(&linein[7], filtervendorapptr) != NULL) ret |= TYPE_AP;\n\t}\nif(filtervendorclientptr != NULL)\n\t{\n\tif(strstr(&linein[7], filtervendorclientptr) != NULL) ret |= TYPE_CLIENT;\n\t}\nreturn ret;\n}\n/*===========================================================================*/\nstatic void readoui(void)\n{\nstatic int len;\nstatic uid_t uid;\nstatic struct passwd *pwd;\nstatic struct stat statinfo;\nstatic ouilist_t *zeiger, *ouilistnew;\nstatic FILE *fh_oui;\nstatic char *vendorptr;\nstatic const char *ouinameuser = \"/.hcxtools/oui.txt\";\nstatic const char *ouinamesystemwide = \"/usr/share/ieee-data/oui.txt\";\nstatic const char *ouina = \"N/A\";\nstatic char ouinameuserpath[PATH_MAX +1];\nstatic char linein[OUI_LINE_LEN +1];\n\nusedoui = ouina;\nuid = getuid();\npwd = getpwuid(uid);\nif(pwd == NULL) return;\nstrncpy(ouinameuserpath, pwd->pw_dir, PATH_MAX -1);\nstrncat(ouinameuserpath, ouinameuser, PATH_MAX -1);\nif(stat(ouinameuserpath, &statinfo) == 0) usedoui = ouinameuserpath;\nelse if(stat(ouinameuser, &statinfo) == 0) usedoui = ouinamesystemwide;\nelse return;\nif((fh_oui = fopen(usedoui, \"r\")) == NULL) return;\nzeiger = ouilist;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_oui, OUI_LINE_LEN, linein)) == -1) break;\n\tif(len < 20) continue;\n\tlinein[6] = 0;\n\tif(getfield(linein, OUI_LINE_LEN, zeiger->oui) != 3) continue;\n\tif(strstr(&linein[7], \"(base 16)\") == NULL) continue;\n\tzeiger->type = 0;\n\tif((filtervendorptr != NULL) || (filtervendorapptr != NULL) || (filtervendorclientptr != NULL))\n\t\t{\n\t\tzeiger->type = isvendor(len, linein);\n\t\tif(zeiger->type == 0) continue;\n\t\t}\n\tvendorptr = strrchr(&linein[7], '\\t');\n\tif(vendorptr == NULL) continue;\n\tif(vendorptr++ == 0) continue;\n\tstrncpy(zeiger->vendor, vendorptr, VENDOR_LEN_MAX -1);\n\touicount++;\n\tif(ouicount >= ouilistcount)\n\t\t{\n\t\touilistcount += OUILIST_MAX;\n\t\touilistnew = (ouilist_t*)realloc(ouilist, ouilistcount *OUILIST_SIZE);\n\t\tif(ouilistnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\touilist = ouilistnew;\n\t\t}\n\tzeiger = ouilist +ouicount;\n\t}\nfclose(fh_oui);\nqsort(ouilist, ouicount, OUILIST_SIZE, sort_ouilist_by_oui);\nreturn;\n}\n/*===========================================================================*/\nstatic void downloadoui(void)\n{\nstatic uid_t uid;\nstatic size_t bread;\nstatic struct passwd *pwd;\nstatic CURLcode ret;\nstatic CURL *hnd;\nstatic FILE *fhoui;\nstatic FILE *fhouitmp;\nstatic struct stat statinfo;\nstatic const char *ouipath = \"/.hcxtools\";\nstatic const char *ouiname = \"/oui.txt\";\nstatic char ouinameuserpath[PATH_MAX];\nstatic char ouibuff[OUIBUFFER_MAX];\n\nuid = getuid();\npwd = getpwuid(uid);\nif(pwd == NULL) return;\nstrncpy(ouinameuserpath, pwd->pw_dir, PATH_MAX -1);\nstrncat(ouinameuserpath, ouipath, PATH_MAX -1);\nif(stat(ouinameuserpath, &statinfo) == -1)\n\t{\n\tif(mkdir(ouinameuserpath, 0755) == -1)\n\t\t{\n\t\tfprintf(stderr, \"failed to create conf dir\\n\");\n\t\treturn;\n\t\t}\n\t}\nstrncat(ouinameuserpath, ouiname, PATH_MAX -1);\nfprintf(stdout, \"start downloading oui from https://standards-oui.ieee.org to: %s\\n\", ouinameuserpath);\nif((fhouitmp = tmpfile()) == NULL)\n\t{\n\tfprintf(stderr, \"\\nfailed to create temporary download file\\n\");\n\treturn;\n\t}\nhnd = curl_easy_init ();\ncurl_easy_setopt(hnd, CURLOPT_URL, \"https://standards-oui.ieee.org/oui/oui.txt\");\ncurl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 5L);\ncurl_easy_setopt(hnd, CURLOPT_WRITEDATA, fhouitmp) ;\ncurl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 0L);\nret = curl_easy_perform(hnd);\ncurl_easy_cleanup(hnd);\nif(ret != 0)\n\t{\n\tfprintf(stderr, \"\\ndownload not successful\\n\");\n\treturn;\n\t}\nrewind(fhouitmp);\nif((fhoui = fopen(ouinameuserpath, \"w\")) == NULL)\n\t{\n\tfprintf(stderr, \"\\nfailed to create %s\\n\", ouiname);\n\treturn;\n\t}\nwhile (!feof(fhouitmp))\n\t{\n\tbread = fread(ouibuff, 1, sizeof(ouibuff), fhouitmp);\n\tif(bread > 0) fwrite(ouibuff, 1, bread, fhoui);\n\t}\nfclose(fhoui);\nfprintf(stdout, \"\\ndownload finished\\n\");\nreturn;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic void version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage:\\n\"\n\t\"%s <options>\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-i <file>   : input PMKID/EAPOL hash file\\n\"\n\t\"-o <file>   : output PMKID/EAPOL hash file\\n\"\n\t\"-E <file>   : output ESSID list (autohex enabled)\\n\"\n\t\"-E stdout   : output ESSID list to stdout (autohex enabled)\\n\"\n\t\"-L <file>   : output ESSID list (unfiltered and unsorted)\\n\"\n\t\"              useful in combination with hashcat -a9 option\\n\"\n\t\"-d          : download https://standards-oui.ieee.org/oui.txt\\n\"\n\t\"              and save to ~/.hcxtools/oui.txt\\n\"\n\t\"              internet connection required\\n\"\n//\t\"-p          : input PBKDF2 file (hashcat potfile 22000 format)\\n\" \n\t\"-h          : show this help\\n\"\n\t\"-v          : show version\\n\"\n\t\"\\n\"\n\t\"--essid-group                : convert to ESSID groups in working directory\\n\"\n\t\"                               full advantage of reuse of PBKDF2\\n\"\n\t\"                               not on old hash formats\\n\"\n\t\"--oui-group                  : convert to OUI groups in working directory\\n\"\n\t\"                               not on old hash formats\\n\"\n\t\"--mac-group-ap               : convert APs to MAC groups in working directory\\n\"\n\t\"                               not on old hash formats\\n\"\n\t\"--mac-group-client           : convert CLIENTs to MAC groups in working directory\\n\"\n\t\"                               not on old hash formats\\n\"\n\t\"--type=<digit>               : filter by hash type\\n\"\n\t\"                               bitmask:\\n\"\n\t\"                                1 = PMKID\\n\"\n\t\"                                2 = EAPOL\\n\"\n\t\"                               default PMKID and EAPOL (1+2=3)\\n\"\n\t\"--hcx-min=<digit>            : disregard hashes with occurrence lower than hcx-min/ESSID\\n\"\n\t\"--hcx-max=<digit>            : disregard hashes with occurrence higher than hcx-max/ESSID\\n\"\n\t\"--essid-len                  : filter by ESSID length\\n\"\n\t\"                               default ESSID length: %d...%d\\n\"\n\t\"--essid-min                  : filter by ESSID minimum length\\n\"\n\t\"                               default ESSID minimum length: %d\\n\"\n\t\"--essid-max                  : filter by ESSID maximum length\\n\"\n\t\"                               default ESSID maximum length: %d\\n\"\n\t\"--essid=<ESSID>              : filter by ESSID\\n\"\n\t\"--essid-part=<part of ESSID> : filter by part of ESSID (case sensitive)\\n\"\n\t\"--essid-partx=<part of ESSID>: filter by part of ESSID (case insensitive)\\n\"\n\t\"                               locale and wide characters are ignored\\n\"\n\t\"--essid-list=<file>          : filter by ESSID file\\n\"\n\t\"--essid-regex=<regex>        : filter ESSID by regular expression\\n\"\n\t\"--mac-ap=<MAC>               : filter AP by MAC\\n\"\n\t\"                               format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\\n\"\n\t\"--mac-client=<MAC>           : filter CLIENT by MAC\\n\"\n\t\"                               format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\\n\"\n\t\"--mac-list=<file>            : filter by MAC file\\n\"\n\t\"                               format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\\n\"\n\t\"--mac-skiplist=<file>        : exclude MAC from file\\n\"\n\t\"                               format: 001122334455, 00:11:22:33:44:55, 00-11-22-33-44-55 (hex)\\n\"\n\t\"--oui-ap=<OUI>               : filter AP by OUI\\n\"\n\t\"                               format: 001122, 00:11:22, 00-11-22 (hex)\\n\"\n\t\"--oui-client=<OUI>           : filter CLIENT by OUI\\n\"\n\t\"                               format: 001122, 00:11:22, 00-11-22 (hex)\\n\"\n\t\"--vendor=<VENDOR>            : filter AP or CLIENT by (part of) VENDOR name\\n\"\n\t\"--vendor-ap=<VENDOR>         : filter AP by (part of) VENDOR name\\n\"\n\t\"--vendor-client=<VENDOR>     : filter CLIENT by (part of) VENDOR name\\n\",\n\teigenname, VERSION_TAG, VERSION_YEAR, eigenname, ESSID_LEN_MIN, ESSID_LEN_MAX, ESSID_LEN_MIN, ESSID_LEN_MAX);\n\nfprintf(stdout, \"--authorized                 : filter EAPOL pairs by status authorized (M2M3, M3M4, M1M4)\\n\"\n\t\"--challenge                  : filter EAPOL pairs by status CHALLENGE (M1M2, M1M2ROGUE)\\n\"\n\t\"--rc                         : filter EAPOL pairs by replaycount status checked\\n\"\n\t\"--rc-not                     : filter EAPOL pairs by replaycount status not checked\\n\"\n\t\"--apless                     : filter EAPOL pairs by status M1M2ROGUE (M2 requested from CLIENT)\\n\"\n\t\"--info=<file>                : output detailed information about content of hash file\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info=stdout                : stdout output detailed information about content of hash file\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info-vendor=<file>         : output detailed information about ACCESS POINT and CLIENT VENDORs\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info-vendor-ap=<file>      : output detailed information about ACCESS POINT VENDORs\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info-vendor-client=<file>  : output detailed information about CLIENT VENDORs\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info-vendor=stdout         : stdout output detailed information about ACCESS POINT and CLIENT VENDORs\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info-vendor-ap=stdout      : stdout output detailed information about ACCESS POINT VENDORs\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--info-vendor-client=stdout  : stdout output detailed information about CLIENT VENDORs\\n\"\n\t\"                               no filter options available\\n\"\n\t\"--psk=<PSK>                  : pre-shared key to test\\n\"\n\t\"                               due to PBKDF2 calculation this is a very slow process\\n\"\n\t\"                               no nonce error corrections\\n\"\n\t\"--pmk=<PMK>                  : plain master key to test\\n\"\n\t\"                               no nonce error corrections\\n\"\n\t\"--hccapx-in=<file>           : input deprecated hccapx file\\n\"\n\t\"                                MESSSAGEPAIR is taken from the hccapx source\\n\"\n\t\"--hccapx-out=<file>          : output to deprecated hccapx file\\n\"\n\t\"--hccap-in=<file>            : input ancient hccap file\\n\"\n\t\"--hccap-out=<file>           : output to ancient hccap file\\n\"\n\t\"                                MESSSAGEPAIR is calculated from the EAPOL MESSAGE\\n\"\n\t\"                                due to missing information, the worst case value is calculated\\n\"\n\t\"--hccap-single               : output to ancient hccap single files (MAC + count)\\n\"\n\t\"--john=<file>                : output to deprecated john file\\n\"\n\t\"--vendorlist                 : stdout output complete OUI list sorted by OUI\\n\"\n\t\"--help                       : show this help\\n\"\n\t\"--version                    : show version\\n\"\n\t\"\\n\"\n\t\"Important notice:\\n\"\n\t\"%s does not do NONCE ERROR CORRECTIONS\\n\"\n\t\"in case of a packet loss, you get a wrong PTK\\n\",\n\teigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic int l;\nstatic int lcmin;\nstatic int lcmax;\nstatic int p1, p2;\nstatic int hashtypein;\nstatic int essidlenin;\nstatic FILE *fh_pmkideapol;\nstatic int fd_hccapxin;\nstatic int fd_hccapin;\nstatic char *pbkdf2inname;\nstatic char *pmkideapolinname;\nstatic char *pmkideapoloutname;\nstatic char *essidoutname;\nstatic char *essidrawoutname;\nstatic char *essidinname;\nstatic char *macinname;\nstatic char *macskipname;\nstatic char *hccapxinname;\nstatic char *hccapxoutname;\nstatic char *hccapinname;\nstatic char *hccapoutname;\nstatic char *johnoutname;\nstatic char *infooutname;\nstatic char *infovendoroutname;\nstatic char *infovendorapoutname;\nstatic char *infovendorclientoutname;\nstatic char *ouiinstring;\nstatic char *macinstring;\nstatic char *pmkinstring;\nstatic struct stat statinfo;\n\nstatic const char *short_options = \"i:o:E:L:dp:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"type\",\t\t\trequired_argument,\tNULL,\tHCX_HASH_TYPE},\n\t{\"hcx-min\",\t\t\trequired_argument,\tNULL,\tHCX_HASH_MIN},\n\t{\"hcx-max\",\t\t\trequired_argument,\tNULL,\tHCX_HASH_MAX},\n\t{\"essid-min\",\t\t\trequired_argument,\tNULL,\tHCX_ESSID_MIN},\n\t{\"essid-group\",\t\t\tno_argument,\t\tNULL,\tHCX_ESSID_GROUP},\n\t{\"essid-len\",\t\t\trequired_argument,\tNULL,\tHCX_ESSID_LEN},\n\t{\"essid-min\",\t\t\trequired_argument,\tNULL,\tHCX_ESSID_MIN},\n\t{\"essid-max\",\t\t\trequired_argument,\tNULL,\tHCX_ESSID_MAX},\n\t{\"essid\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_ESSID},\n\t{\"essid-part\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_ESSID_PART},\n\t{\"essid-partx\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_ESSID_PARTX},\n\t{\"essid-list\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_ESSID_LIST_IN},\n\t{\"essid-regex\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_ESSID_REGEX},\n\t{\"mac-ap\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_MAC_AP},\n\t{\"mac-client\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_MAC_CLIENT},\n\t{\"mac-list\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_MAC_LIST_IN},\n\t{\"mac-skiplist\",\t\trequired_argument,\tNULL,\tHCX_FILTER_MAC_LIST_SKIP},\n\t{\"mac-group-ap\",\t\tno_argument,\t\tNULL,\tHCX_MAC_GROUP_AP},\n\t{\"mac-group-client\",\t\tno_argument,\t\tNULL,\tHCX_MAC_GROUP_CLIENT},\n\t{\"oui-group\",\t\t\tno_argument,\t\tNULL,\tHCX_OUI_GROUP},\n\t{\"oui-ap\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_OUI_AP},\n\t{\"oui-client\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_OUI_CLIENT},\n\t{\"vendor\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_VENDOR},\n\t{\"vendor-ap\",\t\t\trequired_argument,\tNULL,\tHCX_FILTER_VENDOR_AP},\n\t{\"vendor-client\",\t\trequired_argument,\tNULL,\tHCX_FILTER_VENDOR_CLIENT},\n\t{\"rc\",\t\t\t\tno_argument,\t\tNULL,\tHCX_FILTER_RC},\n\t{\"rc-not\",\t\t\tno_argument,\t\tNULL,\tHCX_FILTER_RC_NOT},\n\t{\"authorized\",\t\t\tno_argument,\t\tNULL,\tHCX_FILTER_M12},\n\t{\"challenge\",\t\t\tno_argument,\t\tNULL,\tHCX_FILTER_M1234},\n\t{\"apless\",\t\t\tno_argument,\t\tNULL,\tHCX_FILTER_M1M2ROGUE},\n\t{\"psk\",\t\t\t\trequired_argument,\tNULL,\tHCX_PSK},\n\t{\"pmk\",\t\t\t\trequired_argument,\tNULL,\tHCX_PMK},\n\t{\"info\",\t\t\trequired_argument,\tNULL,\tHCX_INFO_OUT},\n\t{\"info-vendor\",\t\t\trequired_argument,\tNULL,\tHCX_INFO_VENDOR_OUT},\n\t{\"info-vendor-ap\",\t\trequired_argument,\tNULL,\tHCX_INFO_VENDOR_AP_OUT},\n\t{\"info-vendor-client\",\t\trequired_argument,\tNULL,\tHCX_INFO_VENDOR_CLIENT_OUT},\n\t{\"hccapx-in\",\t\t\trequired_argument,\tNULL,\tHCX_HCCAPX_IN},\n\t{\"hccapx-out\",\t\t\trequired_argument,\tNULL,\tHCX_HCCAPX_OUT},\n\t{\"hccap-in\",\t\t\trequired_argument,\tNULL,\tHCX_HCCAP_IN},\n\t{\"hccap-out\",\t\t\trequired_argument,\tNULL,\tHCX_HCCAP_OUT},\n\t{\"hccap-single\",\t\tno_argument,\t\tNULL,\tHCX_HCCAP_SINGLE_OUT},\n\t{\"john\",\t\t\trequired_argument,\tNULL,\tHCX_JOHN_OUT},\n\t{\"vendorlist\",\t\t\tno_argument,\t\tNULL,\tHCX_VENDOR_OUT},\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCX_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCX_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\npbkdf2inname = NULL;\nfh_pmkideapol = NULL;\npmkideapolinname = NULL;\npmkideapoloutname = NULL;\nessidoutname = NULL;\nessidrawoutname = NULL;\nessidinname = NULL;\nmacinname = NULL;\nmacskipname = NULL;\ninfooutname = NULL;\ninfovendoroutname = NULL;\ninfovendorapoutname = NULL;\ninfovendorclientoutname = NULL;\nhccapxinname = NULL;\nhccapxoutname = NULL;\nhccapinname = NULL;\nhccapoutname = NULL;\njohnoutname = NULL;\nouiinstring = NULL;\nmacinstring = NULL;\npmkinstring = NULL;\nfilteressidptr = NULL;\nfilteressidpartptr = NULL;\nfilteressidregexptr = NULL;\nfiltervendorptr = NULL;\nfiltervendorapptr = NULL;\nfiltervendorclientptr = NULL;\nfd_hccapxin = 0;\nfd_hccapin = 0;\nflagfiltermacap = false;\nflagfiltermacclient = false;\nflagfilterouiap = false;\nflagfilterouiclient = false;\nflagfilterauthorized = false;\nflagfilterchallenge = false;\nflagfilterrcchecked = false;\nflagfilterrcnotchecked = false;\nflagfilterapless = false;\nflagpsk = false;\nflagpmk = false;\nflagessidgroup = false;\nflagmacapgroup = false;\nflagmacclientgroup = false;\nflagouigroup = false;\nflagvendorout = false;\nflaghccapsingleout = false;\ncaseflag = false;\nhashtypein = 0;\nhashtype = HCX_TYPE_PMKID | HCX_TYPE_EAPOL;\nessidlenin = ESSID_LEN_MAX;\nessidlen = ESSID_LEN_MAX;\nessidlenmin = ESSID_LEN_MIN;\nessidlenmax = ESSID_LEN_MAX;\nlcmin = 0;\nlcmax = 0;\nstatusflag = true;\n\nwhile((auswahl = getopt_long (argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCX_PMKIDEAPOL_IN:\n\t\tif((hccapxinname != NULL) || (hccapinname != NULL)) \n\t\t\t{\n\t\t\tfprintf(stderr, \"only one input hash format is allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tpmkideapolinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_PMKIDEAPOL_OUT:\n\t\tpmkideapoloutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ESSID_OUT:\n\t\tessidoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ESSID_RAW_OUT:\n\t\tessidrawoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_VENDOR_OUT:\n\t\tflagvendorout = true;\n\t\tbreak;\n\n\t\tcase HCX_INFO_OUT:\n\t\tinfooutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_INFO_VENDOR_OUT:\n\t\tinfovendoroutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_INFO_VENDOR_AP_OUT:\n\t\tinfovendorapoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_INFO_VENDOR_CLIENT_OUT:\n\t\tinfovendorclientoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ESSID_GROUP:\n\t\tflagessidgroup = true;\n\t\tbreak;\n\n\t\tcase HCX_HASH_TYPE:\n\t\thashtypein |= strtol(optarg, NULL, 10);\n\t\tif((hashtypein < HCX_TYPE_PMKID) || (hashtypein > (HCX_TYPE_PMKID + HCX_TYPE_EAPOL)))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only hash types 1 and 2 allowed (values 1, 2 or 3)\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_ESSID_LEN:\n\t\tessidlenin = strtol(optarg, NULL, 10);\n\t\tif((essidlenin < 0) || (essidlenin > ESSID_LEN_MAX))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only values 0...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tessidlenmin = essidlenin;\n\t\tessidlenmax = essidlenin;\n\t\tbreak;\n\n\t\tcase HCX_ESSID_MIN:\n\t\tessidlenin = strtol(optarg, NULL, 10);\n\t\tif((essidlenin < 0) || (essidlenin > ESSID_LEN_MAX))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only values 0...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tessidlenmin = essidlenin;\n\t\tbreak;\n\n\t\tcase HCX_ESSID_MAX:\n\t\tessidlenin = strtol(optarg, NULL, 10);\n\t\tif((essidlenin < 0) || (essidlenin > ESSID_LEN_MAX))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only values 0...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tessidlenmax = essidlenin;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_ESSID:\n\t\tfilteressidptr = optarg;\n\t\tfilteressidlen = strlen(filteressidptr);\n\t\tif((filteressidlen  < 1) || (filteressidlen > ESSID_LEN_MAX))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only values 0...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_FILTER_ESSID_PART:\n\t\tfilteressidpartptr = optarg;\n\t\tfilteressidpartlen = strlen(filteressidpartptr);\n\t\tif((filteressidpartlen  < 1) || (filteressidpartlen > ESSID_LEN_MAX))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only values 0...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tcaseflag = false;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_ESSID_PARTX:\n\t\tfilteressidpartptr = optarg;\n\t\tfilteressidpartlen = strlen(filteressidpartptr);\n\t\tif((filteressidpartlen  < 1) || (filteressidpartlen > ESSID_LEN_MAX))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only values 0...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tcaseflag = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_ESSID_LIST_IN:\n\t\tessidinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_ESSID_REGEX:\n\t\tfilteressidregexptr = optarg;\n\t\tp1 = regcomp(&essidregex, filteressidregexptr, REG_EXTENDED);\n\t\tif(p1)\n\t\t\t{\n\t\t\tfprintf(stderr, \"Could not compile regex\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_HASH_MIN:\n\t\tlcmin = strtol(optarg, NULL, 10);\n\t\tbreak;\n\n\t\tcase HCX_HASH_MAX:\n\t\tlcmax = strtol(optarg, NULL, 10);\n\t\tbreak;\n\n\t\tcase HCX_MAC_GROUP_AP:\n\t\tflagmacapgroup = true;\n\t\tbreak;\n\n\t\tcase HCX_MAC_GROUP_CLIENT:\n\t\tflagmacclientgroup = true;\n\t\tbreak;\n\n\t\tcase HCX_OUI_GROUP:\n\t\tflagouigroup = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_OUI_AP:\n\t\tl= strlen(optarg);\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)optarg[p1]))\n\t\t\t\t{\n\t\t\t\toptarg[p2] = optarg[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\toptarg[6] = 0;\n\t\touiinstring = optarg;\n\t\tif(getfield(ouiinstring, 3, filterouiap) != 3)\n\t\t\t{\n\t\t\tfprintf(stderr, \"wrong OUI format\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tflagfilterouiap = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_MAC_AP:\n\t\tl= strlen(optarg);\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)optarg[p1]))\n\t\t\t\t{\n\t\t\t\toptarg[p2] = optarg[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\toptarg[12] = 0;\n\t\tmacinstring = optarg;\n\t\tif(getfield(macinstring, 6, filtermacap) != 6)\n\t\t\t{\n\t\t\tfprintf(stderr, \"wrong MAC format $\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tflagfiltermacap = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_MAC_CLIENT:\n\t\tl= strlen(optarg);\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)optarg[p1]))\n\t\t\t\t{\n\t\t\t\toptarg[p2] = optarg[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\toptarg[12] = 0;\n\t\tmacinstring = optarg;\n\t\tif(getfield(macinstring, 6, filtermacclient) != 6)\n\t\t\t{\n\t\t\tfprintf(stderr, \"wrong MAC format\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tflagfiltermacclient = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_MAC_LIST_IN:\n\t\tmacinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_MAC_LIST_SKIP:\n\t\tmacskipname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_OUI_CLIENT:\n\t\tl= strlen(optarg);\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)optarg[p1]))\n\t\t\t\t{\n\t\t\t\toptarg[p2] = optarg[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\toptarg[6] = 0;\n\t\touiinstring = optarg;\n\t\tif(getfield(ouiinstring, 3, filterouiclient) != 3)\n\t\t\t{\n\t\t\tfprintf(stderr, \"wrong OUI format\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tflagfilterouiclient = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_VENDOR:\n\t\tfiltervendorptr = optarg;\n\t\tl = strlen(filtervendorptr);\n\t\tif(l < 3)\n\t\t\t{\n\t\t\tfprintf(stderr, \"at least three characters of the VENDOR name are mandatory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(islower((unsigned char)filtervendorptr[p1])) filtervendorptr[p1] = toupper((unsigned char)filtervendorptr[p1]);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_FILTER_VENDOR_AP:\n\t\tfiltervendorapptr = optarg;\n\t\tl = strlen(filtervendorapptr);\n\t\tif(l < 3)\n\t\t\t{\n\t\t\tfprintf(stderr, \"at least three characters of the VENDOR name are mandatory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(islower((unsigned char)filtervendorapptr[p1])) filtervendorapptr[p1] = toupper((unsigned char)filtervendorapptr[p1]);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_FILTER_VENDOR_CLIENT:\n\t\tfiltervendorclientptr = optarg;\n\t\tl = strlen(filtervendorclientptr);\n\t\tif(l < 3)\n\t\t\t{\n\t\t\tfprintf(stderr, \"at least three characters of the VENDOR name are mandatory\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(islower((unsigned char)filtervendorclientptr[p1])) filtervendorclientptr[p1] = toupper((unsigned char)filtervendorclientptr[p1]);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_FILTER_RC:\n\t\tflagfilterrcchecked = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_RC_NOT:\n\t\tflagfilterrcnotchecked = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_M12:\n\t\tflagfilterauthorized = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_M1234:\n\t\tflagfilterchallenge = true;\n\t\tbreak;\n\n\t\tcase HCX_FILTER_M1M2ROGUE:\n\t\tflagfilterapless = true;\n\t\tbreak;\n\n\t\tcase HCX_PSK:\n\t\tpskptr = optarg;\n\t\tpskptrlen = strlen(pskptr);\n\t\tif((pskptrlen < 0) || (pskptrlen > 63))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only 0...63 characters allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tflagpsk = true;\n\t\tbreak;\n\n\t\tcase HCX_PMK:\n\t\tpmkinstring = optarg;\n\t\tif(getfield(pmkinstring, 32, pmk) != 32)\n\t\t\t{\n\t\t\tfprintf(stderr, \"wrong PMK length\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tflagpmk = true;\n\t\tbreak;\n\n\t\tcase HCX_DOWNLOAD_OUI:\n\t\tdownloadoui();\n\t\tbreak;\n\n\t\tcase HCX_PBKDF2_IN:\n//\t\tpbkdf2inname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HCCAPX_IN:\n\t\tif((pmkideapolinname != NULL) || (hccapinname != NULL))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only one input hash format is allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\thccapxinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HCCAP_IN:\n\t\tif((pmkideapolinname != NULL) || (hccapxinname != NULL))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only one input hash format is allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\thccapinname = optarg;\n\t\tbreak;\n\n\n\t\tcase HCX_HCCAPX_OUT:\n\t\thccapxoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HCCAP_OUT:\n\t\thccapoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HCCAP_SINGLE_OUT:\n\t\tflaghccapsingleout = true;\n\t\tbreak;\n\n\t\tcase HCX_JOHN_OUT:\n\t\tjohnoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\n\nif(essidlenmin > essidlenmax)\n\t{\n\tfprintf(stderr, \"minimum ESSID length is > maximum ESSID length\\n\");\n\texit(EXIT_FAILURE);\n\t}\n\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\n\");\n\treturn EXIT_SUCCESS;\n\t}\n\nif(initlists() == false) exit(EXIT_FAILURE);\nif(pbkdf2inname != NULL) readbpkdf2file(pbkdf2inname);\nif((infooutname != NULL) || (infovendoroutname != NULL) || (infovendorapoutname != NULL) || (infovendorclientoutname != NULL))\n\t{\n\tfiltervendorptr = NULL;\n\tfiltervendorapptr = NULL;\n\tfiltervendorclientptr = NULL;\n\t}\nreadoui();\nif((ouicount > 0) && (flagvendorout == true))\n\t{\n\tshowvendorlist();\n\tprintstatus();\n\tcloselists();\n\treturn EXIT_SUCCESS;\n\t}\nif(pmkideapolinname != NULL)\n\t{\n\tif((fh_pmkideapol = fopen(pmkideapolinname, \"r\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", pmkideapolinname, strerror(errno));\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\treadpmkideapolfile(fh_pmkideapol);\n\t}\nif(hccapxinname != NULL)\n\t{\n\tif(stat(hccapxinname, &statinfo) != 0)\n\t\t{\n\t\tfprintf(stderr, \"can't stat %s\\n\", hccapxinname);\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\tif((statinfo.st_size %HCCAPX_SIZE) != 0)\n\t\t{\n\t\tfprintf(stderr, \"file is corrupt\\n\");\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\tif((fd_hccapxin = open(hccapxinname, O_RDONLY)) == -1)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", hccapxinname, strerror(errno));\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\treadhccapxfile(fd_hccapxin, statinfo.st_size / HCCAPX_SIZE);\n\t}\n\nif(hccapinname != NULL)\n\t{\n\tif(stat(hccapinname, &statinfo) != 0)\n\t\t{\n\t\tfprintf(stderr, \"can't stat %s\\n\", hccapinname);\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\tif((statinfo.st_size %HCCAP_SIZE) != 0)\n\t\t{\n\t\tfprintf(stderr, \"file is corrupt\\n\");\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\tif((fd_hccapin = open(hccapinname, O_RDONLY)) == -1)\n\t\t{\n\t\tfprintf(stdout, \"error opening file %s: %s\\n\", hccapinname, strerror(errno));\n\t\tcloselists();\n\t\texit(EXIT_FAILURE);\n\t\t}\n\treadhccapfile(fd_hccapin, statinfo.st_size / HCCAP_SIZE);\n\t}\n\nif(pmkideapolcount == 0)\n\t{\n\tfprintf(stdout, \"no hashes loaded\\n\");\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tcloselists();\n\treturn EXIT_SUCCESS;\n\t}\n\nif(essidrawoutname != 0) processessidraw(essidrawoutname);\n\nif(infooutname != NULL)\n\t{\n\twriteinfofile(infooutname);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tcloselists();\n\treturn EXIT_SUCCESS;\n\t}\n\nif(infovendoroutname != NULL)\n\t{\n\twritevendorapinfofile(infovendoroutname);\n\twritevendorclientinfofile(infovendoroutname);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tcloselists();\n\treturn EXIT_SUCCESS;\n\t}\nelse if(infovendorapoutname != NULL)\n\t{\n\twritevendorapinfofile(infovendorapoutname);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tcloselists();\n\treturn EXIT_SUCCESS;\n\t}\nelse if(infovendorclientoutname != NULL)\n\t{\n\twritevendorclientinfofile(infovendorclientoutname);\n\tif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\n\tcloselists();\n\treturn EXIT_SUCCESS;\n\t}\n\nif(macskipname != NULL) removepmkideapol(macskipname);\n\nif(hashtypein > 0) hashtype = hashtypein;\n\nif(essidoutname != NULL) processessid(essidoutname);\nif((pmkideapoloutname != NULL) && (essidinname == NULL))\n\t{\n\tif((lcmin == 0) && (lcmax == 0)) writeeapolpmkidfile(pmkideapoloutname);\n\telse writelceapolpmkidfile(pmkideapoloutname, lcmin, lcmax);\n\t}\nif(flagessidgroup == true) writeeapolpmkidessidgroups();\nif(flagmacapgroup == true) writeeapolpmkidmacapgroups();\nif(flagmacclientgroup == true) writeeapolpmkidmacclientgroups();\nif(flagouigroup == true) writeeapolpmkidouigroups();\nif(flagpsk == true) testhashfilepsk();\nif(flagpmk == true) testhashfilepmk();\nif(hccapxoutname != NULL) writehccapxfile(hccapxoutname);\nif(hccapoutname != NULL) writehccapfile(hccapoutname);\nif(flaghccapsingleout == true) writehccapsinglefile();\nif(johnoutname != NULL) writejohnfile(johnoutname);\nif((pmkideapoloutname != NULL) && (essidinname != NULL)) processessidfile(essidinname, pmkideapoloutname);\nif(macinname != NULL) processmacfile(macinname, pmkideapoloutname);\nif(statusflag == true) printstatus();\nif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\nif(fd_hccapxin != 0) close(fd_hccapxin);\ncloselists();\nreturn EXIT_SUCCESS;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "hcxpcapngtool.c",
          "type": "blob",
          "size": 251.619140625,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <libgen.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <unistd.h>\n#if defined (__APPLE__) || defined(__OpenBSD__)\n#include <sys/socket.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#else\n#include <arpa/inet.h>\n#endif\n\n#include <openssl/core.h>\n#include <openssl/crypto.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <openssl/params.h>\n#include <openssl/types.h>\n\n#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define BIG_ENDIAN_HOST\n#endif\n\n#include \"include/hcxpcapngtool.h\"\n#include \"include/ieee80211.c\"\n#include \"include/strings.c\"\n#include \"include/byteops.c\"\n#include \"include/fileops.c\"\n#include \"include/hashops.c\"\n#include \"include/pcap.c\"\n#ifdef WANTZLIB\n#include \"include/gzops.c\"\n#endif\n\n/*===========================================================================*/\nstruct hccap_s\n{\n char essid[36];\n unsigned char ap[6];\n unsigned char client[6];\n unsigned char snonce[32];\n unsigned char anonce[32];\n unsigned char eapol[256];\n int eapol_size;\n int keyver;\n unsigned char keymic[16];\n};\ntypedef struct hccap_s hccap_t;\n#define\tHCCAP_SIZE (sizeof(hccap_t))\n/*===========================================================================*/\nstruct hccapx_s\n{\n uint32_t\tsignature;\n#define HCCAPX_SIGNATURE 0x58504348\n uint32_t\tversion;\n#define HCCAPX_VERSION 4\n uint8_t\tmessage_pair;\n uint8_t\tessid_len;\n uint8_t\tessid[32];\n uint8_t\tkeyver;\n uint8_t\tkeymic[16];\n uint8_t\tap[6];\n uint8_t\tanonce[32];\n uint8_t\tclient[6];\n uint8_t\tsnonce[32];\n uint16_t\teapol_len;\n uint8_t\teapol[256];\n} __attribute__((packed));\ntypedef struct hccapx_s hccapx_t;\n#define\tHCCAPX_SIZE (sizeof(hccapx_t))\n/*===========================================================================*/\n/*===========================================================================*/\n/* global var */\nstatic EVP_MAC *hmac;\nstatic EVP_MAC *cmac;\nstatic EVP_MAC_CTX *ctxhmac;\nstatic EVP_MAC_CTX *ctxcmac;\nstatic OSSL_PARAM paramsmd5[3];\nstatic OSSL_PARAM paramssha1[3];\nstatic OSSL_PARAM paramssha256[3];\nstatic OSSL_PARAM paramsaes128[3];\n\nstatic size_t magicblockcount;\nstatic maclist_t *aplist, *aplistptr;\nstatic messagelist_t *messagelist;\nstatic handshakelist_t *handshakelist, *handshakelistptr;\nstatic pmkidlist_t *pmkidlist, *pmkidlistptr;\nstatic eapmd5msglist_t *eapmd5msglist;\nstatic eapmd5hashlist_t *eapmd5hashlist, *eapmd5hashlistptr;\nstatic eapleaphashlist_t *eapleaphashlist, *eapleaphashlistptr;\nstatic eapleapmsglist_t *eapleapmsglist;\nstatic eapmschapv2hashlist_t *eapmschapv2hashlist, *eapmschapv2hashlistptr;\nstatic eapmschapv2msglist_t *eapmschapv2msglist;\nstatic tacacsplist_t *tacacsplist, *tacacsplistptr;\n\nstatic char *jtrbasenamedeprecated;\n\nstatic FILE *fh_pmkideapol;\nstatic FILE *fh_pmkideapolclient;\nstatic FILE *fh_eapmd5;\nstatic FILE *fh_eapmd5john;\nstatic FILE *fh_eapleap;\nstatic FILE *fh_tacacsp;\nstatic FILE *fh_essid;\nstatic FILE *fh_essidproberequest;\nstatic FILE *fh_deviceinfo;\nstatic FILE *fh_identity;\nstatic FILE *fh_username;\nstatic FILE *fh_nmea;\nstatic FILE *fh_csv;\nstatic FILE *fh_raw_out;\nstatic FILE *fh_lts;\nstatic FILE *fh_log;\nstatic FILE *fh_pmkideapoljtrdeprecated;\nstatic FILE *fh_pmkiddeprecated;\nstatic FILE *fh_hccapxdeprecated;\nstatic FILE *fh_hccapdeprecated;\n\nstatic int maclistmax;\nstatic int handshakelistmax;\nstatic int pmkidlistmax;\nstatic int eapmd5hashlistmax;\nstatic int eapleaphashlistmax;\nstatic int eapmschapv2hashlistmax;\nstatic int tacacsplistmax;\nstatic int fd_pcap;\n\nstatic int gzipstat;\nstatic int pcapngstat;\nstatic int capstat;\n\nstatic int endianness;\nstatic uint16_t versionmajor;\nstatic uint16_t versionminor;\n\nstatic int opensslversionmajor;\nstatic int opensslversionminor;\n\nstatic uint32_t iface;\nstatic uint32_t dltlinktype[MAX_INTERFACE_ID +1];\nstatic uint32_t timeresolval[MAX_INTERFACE_ID +1];\n\nstatic long int radiotaperrorcount;\n\nstatic long int nmeacount;\nstatic long int nmeaerrorcount;\nstatic long int rawpacketcount;\nstatic long int pcapreaderrors;\nstatic long int skippedpacketcount;\nstatic long int zeroedtimestampcount;\nstatic long int fcsframecount;\nstatic long int fcsgoodframecount;\nstatic long int fcsbadframecount;\nstatic long int band24count;\nstatic long int band5count;\nstatic long int band6count;\nstatic long int wdscount;\nstatic long int actioncount;\nstatic long int actionessidcount;\nstatic long int awdlcount;\nstatic long int beaconcount;\nstatic long int beaconssidunsetcount;\nstatic long int beaconssidzeroedcount;\nstatic long int beaconssidoversizedcount;\nstatic long int beaconhcxcount;\nstatic long int beaconerrorcount;\nstatic long int broadcastmacerrorcount;\nstatic long int pagcount;\nstatic long int proberesponsecount;\nstatic long int proberesponsessidunsetcount;\nstatic long int proberesponsessidzeroedcount;\nstatic long int proberequestundirectedcount;\nstatic long int proberequestdirectedcount;\nstatic long int mgtreservedcount;\nstatic long int deauthenticationcount;\nstatic long int disassociationcount;\nstatic long int authenticationcount;\nstatic long int authopensystemcount;\nstatic long int authseacount;\nstatic long int authsharedkeycount;\nstatic long int authfbtcount;\nstatic long int authfilscount;\nstatic long int authfilspfs;\nstatic long int authfilspkcount;\nstatic long int authnetworkeapcount;\nstatic long int authunknowncount;\nstatic long int associationrequestcount;\nstatic long int associationrequestpskcount;\nstatic long int associationrequestftpskcount;\nstatic long int associationrequestpsk256count;\nstatic long int associationrequestsae256count;\nstatic long int associationrequestsae384bcount;\nstatic long int associationrequestowecount;\nstatic long int reassociationrequestcount;\nstatic long int reassociationrequestpskcount;\nstatic long int reassociationrequestftpskcount;\nstatic long int reassociationrequestpsk256count;\nstatic long int reassociationrequestsae256count;\nstatic long int reassociationrequestsae384bcount;\nstatic long int reassociationrequestowecount;\nstatic long int ipv4count;\nstatic long int icmp4count;\nstatic long int ipv6count;\nstatic long int icmp6count;\nstatic long int tcpcount;\nstatic long int udpcount;\nstatic long int grecount;\nstatic long int protochapcount;\nstatic long int protochapreqcount;\nstatic long int protochaprespcount;\nstatic long int protochapsuccesscount;\nstatic long int protopapcount;\nstatic long int tacacspcount;\nstatic long int tacacspauthencount;\nstatic long int tacacspauthorcount;\nstatic long int tacacspacctcount;\nstatic long int tacacsunknowncount;\nstatic long int tacacspwrittencount;\nstatic long int wepenccount;\nstatic long int wpaenccount;\nstatic long int eapcount;\nstatic long int eapsimcount;\nstatic long int eapakacount;\nstatic long int eappeapcount;\nstatic long int eapmd5count;\nstatic long int eapmd5hashcount;\nstatic long int eapleapcount;\nstatic long int eapleaphashcount;\nstatic long int eapmschapv2count;\nstatic long int eapmschapv2hashcount;\nstatic long int eaptlscount;\nstatic long int eapexpandedcount;\nstatic long int eapidcount;\nstatic long int eapcodereqcount;\nstatic long int eapcoderespcount;\nstatic long int radiusrequestcount;\nstatic long int radiuschallengecount;\nstatic long int radiusacceptcount;\nstatic long int radiusrejectcount;\nstatic long int zeroedpmkidpskcount;\nstatic long int zeroedpmkidpmkcount;\nstatic long int zeroedeapolpskcount;\nstatic long int zeroedeapolpmkcount;\nstatic long int pmkidcount;\nstatic long int pmkidbestcount;\nstatic long int pmkidroguecount;\nstatic long int pmkiduselesscount;\nstatic long int pmkidfaultycount;\nstatic long int pmkidakmcount;\nstatic long int pmkidwrittenhcount;\nstatic long int pmkidclientwrittenhcount;\nstatic long int pmkidwrittenjcountdeprecated;\nstatic long int pmkidwrittencountdeprecated;\nstatic long int eapolrc4count;\nstatic long int eapolrsncount;\nstatic long int eapolwpacount;\nstatic long int eapolmsgcount;\nstatic long int eapolrelayedcount;\nstatic long int eapolnccount;\nstatic long int eapolmsgerrorcount;\nstatic long int eapolmsgtimestamperrorcount;\nstatic long int eapolmpcount;\nstatic long int eapolmpbestcount;\nstatic long int eapolm1count;\nstatic long int eapolm1kdv0count;\nstatic long int eapolm1ancount;\nstatic long int eapolm1errorcount;\nstatic long int eapolm2count;\nstatic long int eapolm2oversizedcount;\nstatic long int eapolm2kdv0count;\nstatic long int eapolm2ftpskcount;\nstatic long int eapolm2errorcount;\nstatic long int eapolm3count;\nstatic long int eapolm3oversizedcount;\nstatic long int eapolm3kdv0count;\nstatic long int eapolm3errorcount;\nstatic long int eapolm4count;\nstatic long int eapolm4oversizedcount;\nstatic long int eapolm4zeroedcount;\nstatic long int eapolm4kdv0count;\nstatic long int eapolm4errorcount;\nstatic long int eapolwrittencount;\nstatic long int eapolncwrittencount;\nstatic long int eapolaplesscount;\nstatic long int eapolwrittenjcountdeprecated;\nstatic long int eapolwrittenhcpxcountdeprecated;\nstatic long int eapolncwrittenhcpxcountdeprecated;\nstatic long int eapolwrittenhcpcountdeprecated;\nstatic long int eapolm12e2count;\nstatic long int eapolm14e4count;\nstatic long int eapolm32e2count;\nstatic long int eapolm32e3count;\nstatic long int eapolm34e3count;\nstatic long int eapolm34e4count;\nstatic long int eapmd5writtencount;\nstatic long int eapmd5johnwrittencount;\nstatic long int eapleapwrittencount;\nstatic long int eapmschapv2writtencount;\nstatic long int identitycount;\nstatic long int usernamecount;\n\nstatic uint64_t rcgapmax;\n\nstatic long int taglenerrorcount;\nstatic long int essidcount;\nstatic long int essiderrorcount;\nstatic long int deviceinfocount;\nstatic long int sequenceerrorcount;\nstatic long int essiddupemax;\n\nstatic long int malformedcount;\n\nstatic uint64_t timestampstart;\nstatic uint64_t timestampmin;\nstatic uint64_t timestampmax;\nstatic uint64_t timestampdiff;\nstatic uint64_t eaptimegapmax;\nstatic uint64_t captimestampold;\n\nstatic uint64_t eapoltimeoutvalue;\nstatic uint64_t ncvalue;\nstatic int essidsvalue;\n\nstatic uint16_t frequency;\n\nstatic int nmealen;\n\nstatic bool addtimestampflag;\nstatic bool ignoreieflag;\nstatic bool donotcleanflag;\nstatic bool ancientdumpfileformat;\nstatic bool radiotappresent;\nstatic bool ieee80211flag;\n\n\nstatic const uint8_t fakenonce1[] =\n{\n0x07, 0xbc, 0x92, 0xea, 0x2f, 0x5a, 0x1e, 0xe2, 0x54, 0xf6, 0xb1, 0xb7, 0xe0, 0xaa, 0xd3, 0x53,\n0xf4, 0x5b, 0x0a, 0xac, 0xf9, 0xc9, 0x90, 0x2f, 0x90, 0xd8, 0x78, 0x80, 0xb7, 0x03, 0x0a, 0x20\n};\n\nstatic const uint8_t fakenonce2[] =\n{\n0x95, 0x30, 0xd1, 0xc7, 0xc3, 0x55, 0xb9, 0xab, 0xe6, 0x83, 0xd6, 0xf3, 0x7e, 0xcb, 0x78, 0x02,\n0x75, 0x1f, 0x53, 0xcc, 0xb5, 0x81, 0xd1, 0x52, 0x3b, 0xb4, 0xba, 0xad, 0x23, 0xab, 0x01, 0x07\n};\n\nstatic char rssi;\nstatic int interfacechannel;\nstatic uint8_t myaktap[6];\nstatic uint8_t myaktclient[6];\nstatic uint8_t myaktanonce[32];\nstatic uint8_t myaktsnonce[32];\nstatic uint64_t myaktreplaycount;\n\nstatic char pcapnghwinfo[OPTIONLEN_MAX];\nstatic char pcapngosinfo[OPTIONLEN_MAX];\nstatic char pcapngapplinfo[OPTIONLEN_MAX];\nstatic char pcapngoptioninfo[OPTIONLEN_MAX];\nstatic char pcapngweakcandidate[OPTIONLEN_MAX];\nstatic uint8_t pcapngdeviceinfo[6];\nstatic uint8_t pcapngtimeresolution;\nstatic char nmeasentence[OPTIONLEN_MAX];\nstatic char gpwplold[OPTIONLEN_MAX];\n\nstatic char zeroedpsk[8];\nstatic uint8_t zeroedpmk[32];\nstatic uint8_t calculatedpmk[32];\n\nstatic uint16_t usedfrequency[0xffff];\n\nstatic uint8_t beaconchannel[CHANNEL_MAX];\n/*===========================================================================*/\n/*\nstatic inline void debugprint(int len, uint8_t *ptr)\n{\nstatic int p;\n\nfprintf(stdout, \"\\nRAW: \");\n\nfor(p = 0; p < len; p++)\n\t{\n\tfprintf(stdout, \"%02x\", ptr[p]);\n\t}\nfprintf(stdout, \"\\n\");\nreturn;\n}\n*/\n/*===========================================================================*/\nstatic void closelists(void)\n{\nif(aplist != NULL) free(aplist);\nif(messagelist != NULL) free(messagelist);\nif(handshakelist != NULL) free(handshakelist);\nif(pmkidlist != NULL) free(pmkidlist);\nif(eapmd5msglist != NULL) free(eapmd5msglist);\nif(eapmd5hashlist != NULL) free(eapmd5hashlist);\nif(eapleapmsglist != NULL) free(eapleapmsglist);\nif(eapleaphashlist != NULL) free(eapleaphashlist);\nif(eapmschapv2msglist != NULL) free(eapmschapv2msglist);\nif(eapmschapv2hashlist != NULL) free(eapmschapv2hashlist);\nif(tacacsplist != NULL) free(tacacsplist);\nreturn;\n}\n/*===========================================================================*/\nstatic bool initlists(void)\n{\nstatic const char nastring[] = { \"N/A\" };\n\nmaclistmax = MACLIST_MAX;\nif((aplist = (maclist_t*)calloc((maclistmax +1), MACLIST_SIZE)) == NULL) return false;\naplistptr = aplist;\n\nif((messagelist = (messagelist_t*)calloc((MESSAGELIST_MAX +1), MESSAGELIST_SIZE)) == NULL) return false;\n\nhandshakelistmax = HANDSHAKELIST_MAX;\nif((handshakelist = (handshakelist_t*)calloc((handshakelistmax +1), HANDSHAKELIST_SIZE)) == NULL) return false;\nhandshakelistptr = handshakelist;\n\npmkidlistmax = PMKIDLIST_MAX;\nif((pmkidlist = (pmkidlist_t*)calloc((pmkidlistmax +1),PMKIDLIST_SIZE)) == NULL) return false;\npmkidlistptr = pmkidlist;\n\nif((eapmd5msglist = (eapmd5msglist_t*)calloc((EAPMD5MSGLIST_MAX +1), EAPMD5MSGLIST_SIZE)) == NULL) return false;\n\neapmd5hashlistmax = EAPMD5HASHLIST_MAX;\nif((eapmd5hashlist = (eapmd5hashlist_t*)calloc((eapmd5hashlistmax +1), EAPMD5HASHLIST_SIZE)) == NULL) return false;\neapmd5hashlistptr = eapmd5hashlist;\n\nif((eapleapmsglist = (eapleapmsglist_t*)calloc((EAPLEAPMSGLIST_MAX +1), EAPLEAPMSGLIST_SIZE)) == NULL) return false;\n\neapleaphashlistmax = EAPLEAPHASHLIST_MAX;\nif((eapleaphashlist = (eapleaphashlist_t*)calloc((eapleaphashlistmax +1), EAPLEAPHASHLIST_SIZE)) == NULL) return false;\neapleaphashlistptr = eapleaphashlist;\n\nif((eapmschapv2msglist = (eapmschapv2msglist_t*)calloc((EAPMSCHAPV2MSGLIST_MAX +1), EAPMSCHAPV2MSGLIST_SIZE)) == NULL) return false;\n\neapmschapv2hashlistmax = EAPMSCHAPV2HASHLIST_MAX;\nif((eapmschapv2hashlist = (eapmschapv2hashlist_t*)calloc((eapmschapv2hashlistmax +1), EAPMSCHAPV2HASHLIST_SIZE)) == NULL) return false;\neapmschapv2hashlistptr = eapmschapv2hashlist;\n\ntacacsplistmax = TACACSPLIST_MAX;\nif((tacacsplist = (tacacsplist_t*)calloc((TACACSPLIST_MAX +1), TACACSPLIST_SIZE)) == NULL) return false;\ntacacsplistptr = tacacsplist;\n\nmemset(&pcapnghwinfo, 0, OPTIONLEN_MAX);\nmemset(&pcapngosinfo, 0, OPTIONLEN_MAX);\nmemset(&pcapngapplinfo, 0, OPTIONLEN_MAX);\nmemset(&pcapngoptioninfo, 0, OPTIONLEN_MAX);\nmemset(&pcapngweakcandidate, 0 ,OPTIONLEN_MAX);\nmemset(&pcapngdeviceinfo, 0 ,6);\npcapngtimeresolution = TSRESOL_USEC;\nmemset(&myaktap, 0 ,6);\nmemset(&myaktclient, 0 ,6);\nmemset(&nmeasentence, 0, OPTIONLEN_MAX);\nmemset(&gpwplold, 0, OPTIONLEN_MAX);\n\nmemcpy(&pcapnghwinfo, nastring, 3);\nmemcpy(&pcapngosinfo, nastring, 3);\nmemcpy(&pcapngapplinfo, nastring, 3);\nmemcpy(&pcapngoptioninfo, nastring, 3);\nmemcpy(&pcapngweakcandidate, nastring, 3);\n\nieee80211flag = false;\n\nradiotaperrorcount = 0;\nnmeacount = 0;\nnmeaerrorcount = 0;\nendianness = 0;\nrawpacketcount = 0;\npcapreaderrors = 0;\nskippedpacketcount = 0;\nzeroedtimestampcount = 0;\nfcsframecount = 0;\nfcsgoodframecount = 0;\nfcsbadframecount = 0;\nband24count = 0;\nband5count = 0;\nband6count = 0;\nwdscount = 0;\nactioncount = 0;\nactionessidcount = 0;\nawdlcount = 0;\nbeaconcount = 0;\nbeaconssidunsetcount = 0;\nbeaconssidzeroedcount = 0;\nbeaconssidoversizedcount = 0;\nbeaconhcxcount = 0;\nbeaconerrorcount = 0;\nbroadcastmacerrorcount = 0;\npagcount = 0;\nproberesponsecount = 0;\nproberesponsessidunsetcount = 0;\nproberesponsessidzeroedcount = 0;\nproberequestundirectedcount = 0;\nproberequestdirectedcount = 0;\nmgtreservedcount = 0;\ndeauthenticationcount = 0;\ndisassociationcount = 0;\nauthenticationcount = 0;\nauthopensystemcount = 0;\nauthseacount = 0;\nauthsharedkeycount = 0;\nauthfbtcount = 0;\nauthfilscount = 0;\nauthfilspfs = 0;\nauthfilspkcount = 0;\nauthnetworkeapcount = 0;\nauthunknowncount = 0;\nassociationrequestcount = 0;\nassociationrequestpskcount = 0;\nassociationrequestftpskcount = 0;\nassociationrequestpsk256count = 0;\nassociationrequestsae256count = 0;\nassociationrequestsae384bcount = 0;\nassociationrequestowecount = 0;\nreassociationrequestcount = 0;\nreassociationrequestpskcount = 0;\nreassociationrequestpsk256count = 0;\nreassociationrequestsae256count = 0;\nreassociationrequestsae384bcount = 0;\nreassociationrequestowecount = 0;\nipv4count = 0;\nicmp4count = 0;\nipv6count = 0;\nicmp6count = 0;\ntcpcount = 0;\nudpcount = 0;\ngrecount = 0;\nprotochapcount = 0;\nprotochapreqcount = 0;\nprotochaprespcount = 0;\nprotochapsuccesscount = 0;\nprotopapcount = 0;\ntacacspcount = 0;\ntacacspauthencount = 0;\ntacacspauthorcount = 0;\ntacacspacctcount = 0;\ntacacsunknowncount = 0;\ntacacspwrittencount = 0;\nwepenccount = 0;\nwpaenccount = 0;\neapcount = 0;\neapsimcount = 0;\neapakacount = 0;\neappeapcount = 0;\neapmd5count = 0;\neapmd5hashcount = 0;\neapleapcount = 0;\neapleaphashcount = 0;\neapmschapv2count = 0;\neapmschapv2hashcount = 0;\neaptlscount = 0;\neapexpandedcount = 0;\neapidcount = 0;\neapcodereqcount = 0;\neapcoderespcount = 0;\nradiusrequestcount = 0;\nradiuschallengecount = 0;\nradiusacceptcount = 0;\nradiusrejectcount = 0;\nzeroedpmkidpskcount = 0;\nzeroedpmkidpmkcount = 0;\nzeroedeapolpskcount = 0;\nzeroedeapolpmkcount = 0;\npmkidcount = 0;\npmkidbestcount = 0;\npmkidroguecount = 0;\npmkiduselesscount = 0;\npmkidfaultycount = 0;\npmkidakmcount = 0;\npmkidwrittenhcount = 0;\npmkidclientwrittenhcount = 0;\neapolwrittenjcountdeprecated = 0;\npmkidwrittenjcountdeprecated = 0;\npmkidwrittencountdeprecated = 0;\neapolrc4count = 0;\neapolrsncount = 0;\neapolwpacount = 0;\neapolmsgcount = 0;\neapolrelayedcount = 0;\neapolnccount = 0;\neapolmsgerrorcount = 0;\neapolmsgtimestamperrorcount = 0;\neapolmpbestcount = 0;\neapolmpcount = 0;\neapolm1count = 0;\neapolm1kdv0count = 0;\neapolm1ancount = 0;\neapolm1errorcount = 0;\neapolm2count = 0;\neapolm2oversizedcount = 0;\neapolm2kdv0count = 0;\neapolm2ftpskcount = 0;\neapolm2errorcount = 0;\neapolm3count = 0;\neapolm3oversizedcount = 0;\neapolm3kdv0count = 0;\neapolm3errorcount = 0;\neapolm4count = 0;\neapolm4oversizedcount = 0;\neapolm4zeroedcount = 0;\neapolm4kdv0count = 0;\neapolm4errorcount = 0;\neapolwrittencount = 0;\neapolncwrittencount = 0;\neapolaplesscount = 0;\neapolwrittenjcountdeprecated = 0;\neapolwrittenhcpxcountdeprecated = 0;\neapolwrittenhcpcountdeprecated = 0;\neapolm12e2count = 0;\neapolm14e4count = 0;\neapolm32e2count = 0;\neapolm32e3count = 0;\neapolm34e3count = 0;\neapolm34e4count = 0;\neapmd5writtencount = 0;\neapmd5johnwrittencount = 0;\neapleapwrittencount = 0;\neapmschapv2writtencount = 0;\nidentitycount = 0;\nusernamecount = 0;\ntaglenerrorcount = 0;\nessidcount = 0;\nessiderrorcount = 0;\ndeviceinfocount = 0;\nsequenceerrorcount = 0;\nessiddupemax = 0;\nrcgapmax = 0;\neaptimegapmax = 0;\nmalformedcount = 0;\ntimestampmin = 0;\ntimestampmax = 0;\ntimestampdiff = 0;\ntimestampstart = 0;\ncaptimestampold = 0;\n\nmemset(&zeroedpsk, 0, 8);\nmemset(&zeroedpmk, 0, 32);\nmemset(&beaconchannel, 0, sizeof(beaconchannel));\n\nmemset(&usedfrequency, 0, sizeof(usedfrequency));\nreturn true;\n}\n/*===========================================================================*/\nstatic void printcontentinfo(void)\n{\nstatic int c;\nstatic uint8_t i;\nstatic uint16_t p;\n\nif(nmeacount > 0)\t\t\tfprintf(stdout, \"NMEA PROTOCOL............................: %ld\\n\", nmeacount);\nif(nmeaerrorcount > 0)\t\t\tfprintf(stdout, \"NMEA PROTOCOL checksum errors............: %ld\\n\", nmeaerrorcount);\nif(endianness == 0)\t\t\tfprintf(stdout, \"endianness (capture system)..............: little endian\\n\");\nelse\t\t\t\t\tfprintf(stdout, \"endianness (capture system)..............: big endian\\n\");\nif(rawpacketcount > 0)\t\t\tfprintf(stdout, \"packets inside...........................: %ld\\n\", rawpacketcount);\nif(skippedpacketcount > 0)\t\tfprintf(stdout, \"skipped packets..........................: %ld\\n\", skippedpacketcount);\nif(fcsframecount > 0)\t\t\tfprintf(stdout, \"frames with FCS (radiotap)...............: %ld\\n\", fcsframecount);\nif(fcsgoodframecount > 0)\t\tfprintf(stdout, \"frames with correct FCS (crc)............: %ld\\n\", fcsgoodframecount);\nif(fcsbadframecount > 0)\t\tfprintf(stdout, \"frames with bad FCS (radiotap)...........: %ld\\n\", fcsbadframecount);\nif(band24count > 0)\t\t\tfprintf(stdout, \"packets received on 2.4 GHz..............: %ld\\n\", band24count);\nif(band5count > 0)\t\t\tfprintf(stdout, \"packets received on 5 GHz................: %ld\\n\", band5count);\nif(band6count > 0)\t\t\tfprintf(stdout, \"packets received on 6 GHz................: %ld\\n\", band6count);\nif(wdscount > 0)\t\t\tfprintf(stdout, \"WIRELESS DISTRIBUTION SYSTEM.............: %ld\\n\", wdscount);\nif(deviceinfocount > 0)\t\t\tfprintf(stdout, \"frames containing device information.....: %ld\\n\", deviceinfocount);\nif(essidcount > 0)\t\t\tfprintf(stdout, \"ESSID (total unique).....................: %ld\\n\", essidcount);\nif(essiddupemax > 0)\n\t{\n\tif((essidsvalue > 1) || (donotcleanflag == true)) fprintf(stdout, \"ESSID changes (detected maximum).........: %ld\\n\", essiddupemax);\n\telse fprintf(stdout, \"ESSID changes (detected maximum).........: %ld (information: option --max-essids=%ld and --all recommended)\\n\", essiddupemax, essiddupemax +1);\n\t}\nif(beaconcount > 0)\n\t{\n\tfprintf(stdout, \"BEACON (total)...........................: %ld\\n\", beaconcount);\n\tif((beaconchannel[0] &GHZ24) == GHZ24)\n\t\t{\n\t\tfprintf(stdout, \"BEACON on 2.4 GHz channel (from IE_TAG)..: \");\n\t\tfor(i = 1; i <= 14; i++)\n\t\t\t{\n\t\t\tif(beaconchannel[i] != 0) fprintf(stdout, \"%d \", i);\n\t\t\t}\n\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\tif((beaconchannel[0] &GHZ5) == GHZ5)\n\t\t{\n\t\tfprintf(stdout, \"BEACON on 5/6 GHz channel (from IE_TAG)..: \");\n\t\tfor(i = 15; i < CHANNEL_MAX; i++)\n\t\t\t{\n\t\t\tif(beaconchannel[i] != 0) fprintf(stdout, \"%d \", i);\n\t\t\t}\n\t\tfprintf(stdout, \"\\n\");\n\t\t}\n\t}\nif(beaconssidunsetcount > 0)\t\tfprintf(stdout, \"BEACON (SSID wildcard/unset).............: %ld\\n\", beaconssidunsetcount);\nif(beaconssidzeroedcount > 0)\t\tfprintf(stdout, \"BEACON (SSID zeroed).....................: %ld\\n\", beaconssidzeroedcount);\nif(beaconssidoversizedcount > 0)\tfprintf(stdout, \"BEACON (oversized SSID length)...........: %ld\\n\", beaconssidoversizedcount);\nif(pagcount > 0)\t\t\tfprintf(stdout, \"BEACON (pwnagotchi)......................: %ld\\n\", pagcount);\nif(beaconhcxcount > 0)\t\t\tfprintf(stdout, \"BEACON (hcxhash2cap).....................: %ld\\n\", beaconhcxcount);\nif(actioncount > 0)\t\t\tfprintf(stdout, \"ACTION (total)...........................: %ld\\n\", actioncount);\nif(actionessidcount > 0)\t\tfprintf(stdout, \"ACTION (containing ESSID)................: %ld\\n\", actionessidcount);\nif(awdlcount > 0)\t\t\tfprintf(stdout, \"AWDL (Apple Wireless Direct Link)........: %ld\\n\", awdlcount);\nif(proberequestundirectedcount > 0)\tfprintf(stdout, \"PROBEREQUEST (undirected)................: %ld\\n\", proberequestundirectedcount);\nif(proberequestdirectedcount > 0)\tfprintf(stdout, \"PROBEREQUEST (directed)..................: %ld\\n\", proberequestdirectedcount);\nif(proberesponsecount > 0)\t\tfprintf(stdout, \"PROBERESPONSE (total)....................: %ld\\n\", proberesponsecount);\nif(proberesponsessidunsetcount > 0)\tfprintf(stdout, \"PROBERESPONSE (SSID unset)...............: %ld\\n\", proberesponsessidunsetcount);\nif(proberesponsessidzeroedcount > 0)\tfprintf(stdout, \"PROBERESPONSE (SSID zeroed)..............: %ld\\n\", proberesponsessidzeroedcount);\nif(deauthenticationcount > 0)\t\tfprintf(stdout, \"DEAUTHENTICATION (total).................: %ld\\n\", deauthenticationcount);\nif(disassociationcount > 0)\t\tfprintf(stdout, \"DISASSOCIATION (total)...................: %ld\\n\", disassociationcount);\nif(authenticationcount > 0)\t\tfprintf(stdout, \"AUTHENTICATION (total)...................: %ld\\n\", authenticationcount);\nif(authopensystemcount > 0)\t\tfprintf(stdout, \"AUTHENTICATION (OPEN SYSTEM).............: %ld\\n\", authopensystemcount);\nif(authseacount > 0)\t\t\tfprintf(stdout, \"AUTHENTICATION (SAE).....................: %ld\\n\", authseacount);\nif(authsharedkeycount > 0)\t\tfprintf(stdout, \"AUTHENTICATION (SHARED KEY)..............: %ld\\n\", authsharedkeycount);\nif(authfbtcount > 0)\t\t\tfprintf(stdout, \"AUTHENTICATION (FBT).....................: %ld\\n\", authfbtcount);\nif(authfilscount > 0)\t\t\tfprintf(stdout, \"AUTHENTICATION (FILS)....................: %ld\\n\", authfilscount);\nif(authfilspfs > 0)\t\t\tfprintf(stdout, \"AUTHENTICATION (FILS PFS)................: %ld\\n\", authfilspfs);\nif(authfilspkcount > 0)\t\t\tfprintf(stdout, \"AUTHENTICATION (FILS PK..................: %ld\\n\", authfilspkcount);\nif(authnetworkeapcount > 0)\t\tfprintf(stdout, \"AUTHENTICATION (NETWORK EAP).............: %ld\\n\", authnetworkeapcount);\nif(authunknowncount > 0)\t\tfprintf(stdout, \"AUTHENTICATION (unknown).................: %ld\\n\", authunknowncount);\nif(associationrequestcount > 0)\t\tfprintf(stdout, \"ASSOCIATIONREQUEST (total)...............: %ld\\n\", associationrequestcount);\nif(associationrequestpskcount > 0)\tfprintf(stdout, \"ASSOCIATIONREQUEST (PSK).................: %ld\\n\", associationrequestpskcount);\nif(associationrequestftpskcount > 0)\tfprintf(stdout, \"ASSOCIATIONREQUEST (FT using PSK)........: %ld\\n\", associationrequestftpskcount);\nif(associationrequestpsk256count > 0)\tfprintf(stdout, \"ASSOCIATIONREQUEST (PSK SHA256)..........: %ld\\n\", associationrequestpsk256count);\nif(associationrequestsae256count > 0)\tfprintf(stdout, \"ASSOCIATIONREQUEST (SAE SHA256)..........: %ld\\n\", associationrequestsae256count);\nif(associationrequestsae384bcount > 0)\tfprintf(stdout, \"ASSOCIATIONREQUEST (SAE SHA384 SUITE B)..: %ld\\n\", associationrequestsae384bcount);\nif(associationrequestowecount > 0)\tfprintf(stdout, \"ASSOCIATIONREQUEST (OWE).................: %ld\\n\", associationrequestowecount);\nif(reassociationrequestcount > 0)\tfprintf(stdout, \"REASSOCIATIONREQUEST (total).............: %ld\\n\", reassociationrequestcount);\nif(reassociationrequestpskcount > 0)\tfprintf(stdout, \"REASSOCIATIONREQUEST (PSK)...............: %ld\\n\", reassociationrequestpskcount);\nif(reassociationrequestftpskcount > 0)\tfprintf(stdout, \"REASSOCIATIONREQUEST (FT using PSK)......: %ld\\n\", reassociationrequestftpskcount);\nif(reassociationrequestpsk256count > 0)\tfprintf(stdout, \"REASSOCIATIONREQUEST (PSK SHA256)........: %ld\\n\", reassociationrequestpsk256count);\nif(reassociationrequestsae256count > 0)\tfprintf(stdout, \"REASSOCIATIONREQUEST (SAE SHA256)........: %ld\\n\", reassociationrequestsae256count);\nif(reassociationrequestsae384bcount > 0)fprintf(stdout, \"REASSOCIATIONREQUEST (SAE SHA384 SUITE B): %ld\\n\", reassociationrequestsae384bcount);\nif(reassociationrequestowecount > 0)\tfprintf(stdout, \"REASSOCIATIONREQUEST (OWE)...............: %ld\\n\", reassociationrequestowecount);\nif(mgtreservedcount > 0)\t\tfprintf(stdout, \"RESERVED MANAGEMENT frame................: %ld\\n\", mgtreservedcount);\nif(wpaenccount > 0)\t\t\tfprintf(stdout, \"WPA encrypted............................: %ld\\n\", wpaenccount);\nif(wepenccount > 0)\t\t\tfprintf(stdout, \"WEP encrypted............................: %ld\\n\", wepenccount);\nif(ipv4count > 0)\t\t\tfprintf(stdout, \"IPv4 (total).............................: %ld\\n\", ipv4count);\nif(icmp4count > 0)\t\t\tfprintf(stdout, \"ICMPv4...................................: %ld\\n\", icmp4count);\nif(ipv6count > 0)\t\t\tfprintf(stdout, \"IPv6 (total).............................: %ld\\n\", ipv6count);\nif(icmp6count > 0)\t\t\tfprintf(stdout, \"ICMPv6...................................: %ld\\n\", icmp6count);\nif(tcpcount > 0)\t\t\tfprintf(stdout, \"TCP (total)..............................: %ld\\n\", tcpcount);\nif(udpcount > 0)\t\t\tfprintf(stdout, \"UDP (total)..............................: %ld\\n\", udpcount);\nif(grecount > 0)\t\t\tfprintf(stdout, \"GRE (total)..............................: %ld\\n\", grecount);\nif(protochapcount > 0)\t\t\tfprintf(stdout, \"PPP-CHAP (total).........................: %ld\\n\", protochapcount);\nif(protochapreqcount > 0)\t\tfprintf(stdout, \"PPP-CHAP request.........................: %ld\\n\", protochapreqcount);\nif(protochaprespcount > 0)\t\tfprintf(stdout, \"PPP-CHAP response........................: %ld\\n\", protochaprespcount);\nif(protochapsuccesscount > 0)\t\tfprintf(stdout, \"PPP-CHAP success.........................: %ld\\n\", protochapsuccesscount);\nif(protopapcount > 0)\t\t\tfprintf(stdout, \"PPP-PAP..................................: %ld\\n\", protopapcount);\nif(tacacspcount > 0)\t\t\tfprintf(stdout, \"TACACS+..................................: %ld\\n\", tacacspcount);\nif(tacacspauthencount > 0)\t\tfprintf(stdout, \"TACACS+ AUTHEN...........................: %ld\\n\", tacacspauthencount);\nif(tacacspauthorcount > 0)\t\tfprintf(stdout, \"TACACS+ AUTHOR...........................: %ld (not supported by hashcat/JtR)\\n\", tacacspauthorcount);\nif(tacacspacctcount > 0)\t\tfprintf(stdout, \"TACACS+ ACCT.............................: %ld (not supported by hashcat/JtR)\\n\", tacacspacctcount);\nif(tacacsunknowncount > 0)\t\tfprintf(stdout, \"TACACS+ unknown version..................: %ld (not supported by hashcat/JtR)\\n\", tacacsunknowncount);\nif(tacacspwrittencount > 0)\t\tfprintf(stdout, \"TACACS+ written..........................: %ld\\n\", tacacspwrittencount);\nif(identitycount > 0)\t\t\tfprintf(stdout, \"IDENTITIES...............................: %ld\\n\", identitycount);\nif(usernamecount > 0)\t\t\tfprintf(stdout, \"USERNAMES................................: %ld\\n\", usernamecount);\nif(radiusrequestcount > 0)\tfprintf(stdout, \"RADIUS AUTHENTICATION (REQUEST)..........: %ld\\n\", radiusrequestcount);\nif(radiuschallengecount > 0)\tfprintf(stdout, \"RADIUS AUTHENTICATION (CHALLENGE)........: %ld\\n\", radiuschallengecount);\nif(radiusacceptcount > 0)\tfprintf(stdout, \"RADIUS AUTHENTICATION (ACCEPT)...........: %ld\\n\", radiusacceptcount);\nif(radiusrejectcount > 0)\tfprintf(stdout, \"RADIUS AUTHENTICATION (REJECT)...........: %ld\\n\", radiusrejectcount);\nif(eapcount > 0)\t\t\tfprintf(stdout, \"EAP (total)..............................: %ld\\n\", eapcount);\nif(eapexpandedcount > 0)\t\tfprintf(stdout, \"EAP-EXPANDED.............................: %ld\\n\", eapexpandedcount);\nif(eapcodereqcount > 0)\t\t\tfprintf(stdout, \"EAP CODE request.........................: %ld\\n\", eapcodereqcount);\nif(eapcoderespcount > 0)\t\tfprintf(stdout, \"EAP CODE response........................: %ld\\n\", eapcoderespcount);\nif(eapidcount > 0)\t\t\tfprintf(stdout, \"EAP ID...................................: %ld\\n\", eapidcount);\nif(eapsimcount > 0)\t\t\tfprintf(stdout, \"EAP-SIM..................................: %ld\\n\", eapsimcount);\nif(eapakacount > 0)\t\t\tfprintf(stdout, \"EAP-AKA..................................: %ld\\n\", eapakacount);\nif(eappeapcount > 0)\t\t\tfprintf(stdout, \"EAP-PEAP.................................: %ld\\n\", eappeapcount);\nif(eapmd5count > 0)\t\t\tfprintf(stdout, \"EAP-MD5 messages.........................: %ld\\n\", eapmd5count);\nif(eapmd5hashcount > 0)\t\t\tfprintf(stdout, \"EAP-MD5 pairs............................: %ld\\n\", eapmd5hashcount);\nif(eapmd5writtencount > 0)\t\tfprintf(stdout, \"EAP-MD5 pairs written....................: %ld\\n\", eapmd5writtencount);\nif(eapmd5johnwrittencount > 0)\t\tfprintf(stdout, \"EAP-MD5 pairs written to JtR.............: %ld\\n\", eapmd5johnwrittencount);\nif(eapleapcount > 0)\t\t\tfprintf(stdout, \"EAP-LEAP messages........................: %ld\\n\", eapleapcount);\nif(eapleapwrittencount > 0)\t\tfprintf(stdout, \"EAP-LEAP pairs written...................: %ld\\n\", eapleapwrittencount);\nif(eapmschapv2count > 0)\t\tfprintf(stdout, \"EAP-MSCHAPV2 messages....................: %ld\\n\", eapmschapv2count);\nif(eapmschapv2writtencount > 0)\t\tfprintf(stdout, \"EAP-MSCHAPV2 pairs written...............: %ld\\n\", eapmschapv2writtencount);\nif(eaptlscount > 0)\t\t\tfprintf(stdout, \"EAP-TLS messages.........................: %ld\\n\", eaptlscount);\nif(eapolmsgcount > 0)\t\t\tfprintf(stdout, \"EAPOL messages (total)...................: %ld\\n\", eapolmsgcount);\nif(eapolrelayedcount > 0)\t\tfprintf(stdout, \"EAPOL messages relayed (ignored).........: %ld\\n\", eapolrelayedcount);\nif(eapolrc4count > 0)\t\t\tfprintf(stdout, \"EAPOL RC4 messages.......................: %ld\\n\", eapolrc4count);\nif(eapolrsncount > 0)\t\t\tfprintf(stdout, \"EAPOL RSN messages.......................: %ld\\n\", eapolrsncount);\nif(eapolwpacount > 0)\t\t\tfprintf(stdout, \"EAPOL WPA messages.......................: %ld\\n\", eapolwpacount);\nif(eaptimegapmax > 0) fprintf(stdout, \"EAPOLTIME gap (measured maximum msec)....: %\" PRIu64 \"\\n\", eaptimegapmax / 1000000);\nif(rcgapmax > 1024) rcgapmax = 1024;\nif((eapolnccount > 0) && (eapolmpcount > 0))\n\t{\n\tprintf (\"EAPOL ANONCE error corrections (NC)......: working\\n\");\n\tif(rcgapmax > 0) fprintf(stdout, \"REPLAYCOUNT gap (suggested NC)...........: %\" PRIu64 \"\\n\", (rcgapmax *2 +1));\n\tif(rcgapmax == 0) fprintf(stdout, \"REPLAYCOUNT gap (recommended NC).........: 8\\n\");\n\t}\nif(eapolnccount == 0)\n\t{\n\tfprintf(stdout, \"EAPOL ANONCE error corrections (NC)......: not detected\\n\");\n\tif(rcgapmax > 0) fprintf(stdout, \"REPLAYCOUNT gap (measured maximum).......: %\" PRIu64 \"\\n\", rcgapmax);\n\t}\nif(eapolm1count > 0)\t\t\tfprintf(stdout, \"EAPOL M1 messages (total)................: %ld\\n\", eapolm1count);\nif(eapolm1kdv0count > 0)\t\tfprintf(stdout, \"EAPOL M1 messages (KDV:0 AKM defined)....: %ld (not supported by hashcat/JtR)\\n\", eapolm1kdv0count);\nif(eapolm2count > 0)\t\t\tfprintf(stdout, \"EAPOL M2 messages (total)................: %ld\\n\", eapolm2count);\nif(eapolm2oversizedcount > 0)\t\tfprintf(stdout, \"EAPOL M2 messages (oversized)............: %ld\\n\", eapolm2oversizedcount);\nif(eapolm2kdv0count > 0)\t\tfprintf(stdout, \"EAPOL M2 messages (KDV:0 AKM defined)....: %ld (not supported by hashcat/JtR)\\n\", eapolm2kdv0count);\nif(eapolm2ftpskcount > 0)\t\tfprintf(stdout, \"EAPOL M2 messages (FT using PSK).........: %ld (not supported by hashcat/JtR)\\n\", eapolm2ftpskcount);\nif(eapolm3count > 0)\t\t\tfprintf(stdout, \"EAPOL M3 messages (total)................: %ld\\n\", eapolm3count);\nif(eapolm3oversizedcount > 0)\t\tfprintf(stdout, \"EAPOL M3 messages (oversized)............: %ld\\n\", eapolm3oversizedcount);\nif(eapolm3kdv0count > 0)\t\tfprintf(stdout, \"EAPOL M3 messages (KDV:0 AKM defined)....: %ld (not supported by hashcat/JtR)\\n\", eapolm3kdv0count);\nif(eapolm4count > 0)\t\t\tfprintf(stdout, \"EAPOL M4 messages (total)................: %ld\\n\", eapolm4count);\nif(eapolm4oversizedcount > 0)\t\tfprintf(stdout, \"EAPOL M4 messages (oversized)............: %ld\\n\", eapolm4oversizedcount);\nif(eapolm4zeroedcount > 0)\t\tfprintf(stdout, \"EAPOL M4 messages (zeroed NONCE).........: %ld\\n\", eapolm4zeroedcount);\nif(eapolm4kdv0count > 0)\t\tfprintf(stdout, \"EAPOL M4 messages (KDV:0 AKM defined)....: %ld (not supported by hashcat/JtR)\\n\", eapolm4kdv0count);\nif(eapolmpcount > 0)\t\t\tfprintf(stdout, \"EAPOL pairs (total)......................: %ld\\n\", eapolmpcount);\nif(zeroedeapolpskcount > 0)\t\tfprintf(stdout, \"EAPOL (from zeroed PSK)..................: %ld (not converted by default options - use --all)\\n\", zeroedeapolpskcount);\nif(zeroedeapolpmkcount > 0)\t\tfprintf(stdout, \"EAPOL (from zeroed PMK)..................: %ld (not converted by default options - use --all)\\n\", zeroedeapolpmkcount);\nif(donotcleanflag == false)\n\t{\n\tif(eapolmpbestcount > 0)\t\tfprintf(stdout, \"EAPOL pairs (best).......................: %ld\\n\", eapolmpbestcount);\n\t}\nelse\n\t{\n\tif(eapolmpbestcount > 0)\t\tfprintf(stdout, \"EAPOL pairs (useful).....................: %ld\\n\", eapolmpbestcount);\n\t}\nif(eapolaplesscount > 0)\t\tfprintf(stdout, \"EAPOL ROGUE pairs........................: %ld\\n\", eapolaplesscount);\nif(eapolwrittencount > 0)\t\tfprintf(stdout, \"EAPOL pairs written to 22000 hash file...: %ld (RC checked)\\n\", eapolwrittencount);\nif(eapolncwrittencount > 0)\t\tfprintf(stdout, \"EAPOL pairs written to 22000 hash file...: %ld (RC not checked)\\n\", eapolncwrittencount);\nif(eapolwrittenhcpxcountdeprecated > 0)\tfprintf(stdout, \"EAPOL pairs written to old format hccapx.: %ld (RC checked)\\n\", eapolwrittenhcpxcountdeprecated);\nif(eapolncwrittenhcpxcountdeprecated > 0)\tfprintf(stdout, \"EAPOL pairs written to old format hccapx.: %ld (RC not checked)\\n\", eapolncwrittenhcpxcountdeprecated);\nif(eapolwrittenhcpcountdeprecated > 0)\tfprintf(stdout, \"EAPOL pairs written to old format hccap..: %ld (RC checked)\\n\", eapolwrittenhcpcountdeprecated);\nif(eapolwrittenjcountdeprecated > 0)\tfprintf(stdout, \"EAPOL pairs written to old format JtR....: %ld (RC checked)\\n\", eapolwrittenjcountdeprecated);\nif(eapolm12e2count > 0)\t\t\tfprintf(stdout, \"EAPOL M12E2 (challenge)..................: %ld\\n\", eapolm12e2count);\nif(eapolm14e4count > 0)\t\t\tfprintf(stdout, \"EAPOL M14E4 (authorized).................: %ld\\n\", eapolm14e4count);\nif(eapolm32e2count > 0)\t\t\tfprintf(stdout, \"EAPOL M32E2 (authorized).................: %ld\\n\", eapolm32e2count);\nif(eapolm32e3count > 0)\t\t\tfprintf(stdout, \"EAPOL M32E3 (authorized).................: %ld\\n\", eapolm32e3count);\nif(eapolm34e3count > 0)\t\t\tfprintf(stdout, \"EAPOL M34E3 (authorized).................: %ld\\n\", eapolm34e3count);\nif(eapolm34e4count > 0)\t\t\tfprintf(stdout, \"EAPOL M34E4 (authorized).................: %ld\\n\", eapolm34e4count);\nif(pmkiduselesscount > 0)\t\tfprintf(stdout, \"RSN PMKID (useless)......................: %ld\\n\", pmkiduselesscount);\nif(pmkidfaultycount > 0)\t\tfprintf(stdout, \"RSN PMKID (faulty).......................: %ld\\n\", pmkidfaultycount);\nif(pmkidcount > 0)\t\t\tfprintf(stdout, \"RSN PMKID (total)........................: %ld\\n\", pmkidcount);\nif(zeroedpmkidpskcount > 0)\t\tfprintf(stdout, \"RSN PMKID (from zeroed PSK)..............: %ld (not converted by default options - use --all)\\n\", zeroedpmkidpskcount);\nif(zeroedpmkidpmkcount > 0)\t\tfprintf(stdout, \"RSN PMKID (from zeroed PMK)..............: %ld (not converted by default options - use --all)\\n\", zeroedpmkidpmkcount);\nif(donotcleanflag == false)\n\t{\n\tif(pmkidbestcount > 0)\t\t\tfprintf(stdout, \"RSN PMKID (best).........................: %ld\\n\", pmkidbestcount);\n\t}\nelse\n\t{\n\tif(pmkidbestcount > 0)\t\t\tfprintf(stdout, \"RSN PMKID (useful).......................: %ld\\n\", pmkidbestcount);\n\t}\nif(pmkidroguecount > 0)\t\t\tfprintf(stdout, \"RSN PMKID ROGUE..........................: %ld\\n\", pmkidroguecount);\nif(pmkidakmcount > 0)\t\t\tfprintf(stdout, \"RSN PMKID (KDV:0 AKM defined)............: %ld (PMK not recoverable)\\n\", pmkidakmcount);\nif(pmkidwrittenhcount > 0)\t\tfprintf(stdout, \"RSN PMKID written to 22000 hash file.....: %ld\\n\", pmkidwrittenhcount);\nif(pmkidclientwrittenhcount > 0)\tfprintf(stdout, \"RSN PMKID written to 22000 hash file.....: %ld (possible MESH/REPEATER PMKIDs)\\n\", pmkidclientwrittenhcount);\nif(pmkidwrittenjcountdeprecated > 0)\tfprintf(stdout, \"RSN PMKID written to old format JtR......: %ld\\n\", pmkidwrittenjcountdeprecated);\nif(pmkidwrittencountdeprecated > 0)\tfprintf(stdout, \"RSN PMKID written to old format (1680x)..: %ld\\n\", pmkidwrittencountdeprecated);\nif(pcapreaderrors > 0)\t\t\tfprintf(stdout, \"packet read error........................: %ld\\n\", pcapreaderrors);\nif(radiotaperrorcount > 0)\t\tfprintf(stdout, \"packet with damaged radiotap header......: %ld\\n\", radiotaperrorcount);\nif(zeroedtimestampcount > 0)\t\tfprintf(stdout, \"packets with zeroed timestamps...........: %ld\\n\", zeroedtimestampcount);\nif(eapolmsgtimestamperrorcount > 0)\tfprintf(stdout, \"EAPOL frames with wrong timestamp........: %ld\\n\", eapolmsgtimestamperrorcount);\nmalformedcount = beaconerrorcount +broadcastmacerrorcount +taglenerrorcount +essiderrorcount +eapolmsgerrorcount;\nif(malformedcount > 0)\t\t\tfprintf(stdout, \"malformed packets (total)................: %ld\\n\", malformedcount);\nbeaconerrorcount += broadcastmacerrorcount;\nif(beaconerrorcount > 0)\t\tfprintf(stdout, \"BEACON error (total malformed packets)...: %ld\\n\", beaconerrorcount);\nif(broadcastmacerrorcount > 0)\t\tfprintf(stdout, \"BROADCAST MAC error (malformed packets)..: %ld\\n\", broadcastmacerrorcount);\nif(taglenerrorcount > 0)\t\tfprintf(stdout, \"IE TAG length error (malformed packets)..: %ld\\n\", taglenerrorcount);\nif(essiderrorcount > 0)\t\t\tfprintf(stdout, \"ESSID error (malformed packets)..........: %ld\\n\", essiderrorcount);\neapolmsgerrorcount = eapolmsgerrorcount +eapolm1errorcount +eapolm2errorcount +eapolm3errorcount +eapolm4errorcount;\nif(eapolmsgerrorcount > 0)\t\tfprintf(stdout, \"EAPOL messages (malformed packets).......: %ld\\n\", eapolmsgerrorcount);\nif(radiotappresent == true)\n\t{\n\tc = 0;\n\tfprintf(stdout, \"\\nfrequency statistics from radiotap header (frequency: received packets)\\n\"\n\t\t\t\"-----------------------------------------------------------------------\\n\");\n\tfor(p = 2412; p <= 7115; p ++)\n\t\t{\n\t\tif(usedfrequency[p] != 0)\n\t\t\t{\n\t\t\tfprintf(stdout, \"% 5d: %d\\t\", p, usedfrequency[p]);\n\t\t\tc++;\n\t\t\tif((c %4) == 0) fprintf(stdout, \"\\n\");\n\t\t\t}\n\t\t}\n\tfprintf(stdout, \"\\n\");\n\t}\nif(zeroedtimestampcount > 0)\n\t{\n\tfprintf(stdout, \"\\nWarning: missing timestamps!\\n\"\n\t\t\"This dump file contains frames with zeroed timestamps.\\n\"\n\t\t\"It prevent calculation of EAPOL TIMEOUT values.\\n\"\n\t\t\"That is a bug of the capturing/cleaning tool.\\n\");\n\t}\nif(eapolmsgtimestamperrorcount > 0)\n\t{\n\tfprintf(stdout, \"\\nWarning: wrong timestamps!\\n\"\n\t\t\"This dump file contains frames with wrong timestamps.\\n\"\n\t\t\"It prevent calculation of EAPOL TIMEOUT values.\\n\"\n\t\t\"That is a bug of the capturing/cleaning tool.\\n\");\n\t}\nif(sequenceerrorcount > 0)\n\t{\n\tfprintf(stdout, \"\\nWarning: out of sequence timestamps!\\n\"\n\t\t\"This dump file contains frames with out of sequence timestamps.\\n\"\n\t\t\"That is a bug of the capturing/cleaning tool.\\n\");\n\t}\nif(ancientdumpfileformat == true)\n\t{\n\tfprintf(stdout, \"\\nInformation: limited dump file format detected!\\n\"\n\t\t\"This file format is a very basic format to save captured network data.\\n\"\n\t\t\"It is recommended to use PCAP Next Generation dump file format (or pcapng for short) instead. \"\n\t\t\"The PCAP Next Generation dump file format is an attempt to overcome the limitations \"\n\t\t\"of the currently widely used (but very limited) libpcap (cap, pcap) format.\\n\"\n\t\t\"https://www.wireshark.org/docs/wsug_html_chunked/AppFiles.html#ChAppFilesCaptureFilesSection\\n\"\n\t\t\"https://github.com/pcapng/pcapng\\n\");\n\t}\nif(ieee80211flag == false)\n\t{\n\tfprintf(stdout, \"\\n\");\n\treturn;\n\t}\nif(radiotappresent == false)\n\t{\n\tfprintf(stdout, \"\\nInformation: radiotap header is missing!\\n\"\n\t\t\"Radiotap is a de facto standard for 802.11 frame injection and \"\n\t\t\"reception. The radiotap header format is a mechanism to supply \"\n\t\t\"additional information about frames, from the driver to userspace applications.\\n\"\n\t\t\"https://www.radiotap.org/\\n\");\n\t}\nif(magicblockcount > 1)\n\t{\n\tfprintf(stdout, \"\\nWarning: this dump file contains more than one custom block!\\n\"\n\t\t\"This always happens if dump files are merged!\\n\"\n\t\t\"Do not merge dump files, because this destroys assigned hash values!\\n\");\n\t}\nif(((deauthenticationcount +disassociationcount) >= 100) && ((deauthenticationcount +disassociationcount) <= 10000))\n\t{\n\tfprintf(stdout, \"\\nWarning: too many deauthentication/disassociation frames detected!\\n\"\n\t\t\"That can cause that an ACCESS POINT change channel, reset EAPOL TIMER, \"\n\t\t\"renew ANONCE and set PMKID to zero. \"\n\t\t\"This could prevent to calculate a valid EAPOL MESSAGE PAIR, to get a valid PMKID \"\n\t\t\"or to decrypt the traffic.\\n\");\n\t}\nif((deauthenticationcount +disassociationcount) > 10000)\n\t{\n\tfprintf(stdout, \"\\nWarning: excessive number of deauthentication/disassociation frames detected!\\n\"\n\t\t\"That can cause that an ACCESS POINT change channel, reset EAPOL TIMER, \"\n\t\t\"renew ANONCE and set PMKID to zero. \"\n\t\t\"This could prevent to calculate a valid EAPOL MESSAGE PAIR, to get a valid PMKID \"\n\t\t\"or to decrypt the traffic.\\n\");\n\t}\nif(((beaconcount + proberesponsecount) == 0) && ((associationrequestcount + reassociationrequestcount) == 0))\n\t{\n\tfprintf(stdout, \"\\nInformation: missing frames!\\n\"\n\t\t\"This dump file does not contain BEACON or PROBERESPONSE frames.\\n\"\n\t\t\"This frames contain the ESSID which is mandatory to calculate a PMK.\\n\"\n\t\t\"It always happens if the capture file was cleaned or \"\n\t\t\"it could happen if filter options are used during capturing. \"\n\t\t\"That makes it impossible to recover the PSK.\\n\");\n\t}\nif(proberequestundirectedcount == 0)\n\t{\n\tfprintf(stdout, \"\\nInformation: missing frames!\\n\"\n\t\t\"This dump file does not contain undirected proberequest frames.\\n\"\n\t\t\"An undirected proberequest may contain information about the PSK. \"\n\t\t\"It always happens if the capture file was cleaned or \"\n\t\t\"it could happen if filter options are used during capturing.\\n\"\n\t\t\"That makes it hard to recover the PSK.\\n\");\n\t}\nif((authenticationcount +associationrequestcount +reassociationrequestcount) == 0)\n\t{\n\tfprintf(stdout, \"\\nInformation: missing frames!\\n\"\n\t\t\"This dump file does not contain important frames like authentication, association or reassociation.\\n\"\n\t\t\"It always happens if the capture file was cleaned or \"\n\t\t\"it could happen if filter options are used during capturing. \"\n\t\t\"That makes it hard to recover the PSK.\\n\");\n\tif(timestampdiff < 60000000000) fprintf(stdout, \"Duration of the dump tool was a way too short to capture enough additional information.\\n\");\n\t}\nif(eapolm1ancount <= 1)\n\t{\n\tfprintf(stdout, \"\\nInformation: missing frames!\\n\"\n\t\t\"This dump file does not contain enough EAPOL M1 frames.\\n\"\n\t\t\"It always happens if the capture file was cleaned or \"\n\t\t\"it could happen if filter options are used during capturing.\\n\"\n\t\t\"That makes it impossible to calculate nonce-error-correction values.\\n\"\n\t\t\"https://hashcat.net/forum/thread-6361.html\\n\");\n\tif(timestampdiff < 60000000000) fprintf(stdout, \"Duration of the dump tool was a way too short to capture enough additional information.\\n\");\n\t}\nif((eapolm1count + eapolm2count + eapolm4count > 0) && (eapolm3count == 0))\n\t{\n\tfprintf(stdout, \"\\nInformation: missing EAPOL M3 frames!\\n\"\n\t\t\"This dump file does not contain EAPOL M3 frames (possible packet loss).\\n\"\n\t\t\"It strongly recommended to recapture the traffic or \"\n\t\t\"to use --all option to convert all possible EAPOL MESSAGE PAIRs.\\n\");\n\t}\nif(malformedcount > 5)\n\t{\n\tfprintf(stdout, \"\\nInformation: malformed packets detected!\\n\"\n\t\t\"In monitor mode the adapter does not check to see if the cyclic redundancy check (CRC) \"\n\t\t\"values are correct for packets captured. The device is able to detect the Physical Layer \"\n\t\t\"Convergence Procedure (PLCP) preamble and is able to synchronize to it, but if there is \"\n\t\t\"a bit error in the payload it can lead to unexpected results.\\n\"\n\t\t\"Please analyze the dump file with tshark or Wireshark or make a better capture!\\n\");\n\t}\nif((eapolwrittencount +eapolncwrittencount +eapolwrittenhcpxcountdeprecated +eapolncwrittenhcpxcountdeprecated +eapolwrittenhcpcountdeprecated\n\t+eapolwrittenjcountdeprecated +pmkidwrittenhcount +pmkidwrittenjcountdeprecated +pmkidwrittencountdeprecated\n\t+eapmd5writtencount +eapmd5johnwrittencount +eapleapwrittencount +eapmschapv2writtencount +tacacspwrittencount) == 0)\n\t{\n\tfprintf(stdout, \"\\nInformation: no hashes written to hash files\\n\");\n\t}\nfprintf(stdout, \"\\n\");\nreturn;\n}\n/*===========================================================================*/\nstatic void printlinklayerinfo(void)\n{\nstatic uint32_t c;\nstatic time_t tvmin;\nstatic time_t tvmax;\nstatic char timestringmin[32];\nstatic char timestringmax[32];\n\nradiotappresent = false;\ntvmin = timestampmin /1000000000;\nstrftime(timestringmin, 32, \"%d.%m.%Y %H:%M:%S\", gmtime(&tvmin));\ntvmax = timestampmax /1000000000;\ntimestampdiff = timestampmax - timestampmin;\nstrftime(timestringmax, 32, \"%d.%m.%Y %H:%M:%S\", gmtime(&tvmax));\nfprintf(stdout, \"timestamp minimum (timestamp)............: %s (%ld)\\n\", timestringmin, tvmin);\nfprintf(stdout, \"timestamp maximum (timestamp)............: %s (%ld)\\n\", timestringmax, tvmax);\nif(timestampdiff > 0)\n\t{\n\tif(timestampdiff > 60000000000) fprintf(stdout, \"duration of the dump tool (minutes)......: %\" PRIu64 \"\\n\", timestampdiff / 60000000000);\n\telse fprintf(stdout, \"duration of the dump tool (seconds)......: %\" PRIu64 \"\\n\", timestampdiff / 1000000000);\n\t}\nfprintf(stdout, \"used capture interfaces..................: %d\\n\", iface);\nfor(c = 0; c < iface; c++)\n\t{\n\tif(c > 0)\n\t\t{\n\t\tif(dltlinktype[c] == dltlinktype[c -1]) continue;\n\t\t}\n\tif(dltlinktype[c] == DLT_IEEE802_11_RADIO)\n\t\t{\n\t\tfprintf(stdout, \"link layer header type...................: DLT_IEEE802_11_RADIO (%d)\\n\", dltlinktype[c]);\n\t\tradiotappresent = true;\n\t\t}\n\telse if(dltlinktype[c] == DLT_IEEE802_11)\t\tfprintf(stdout, \"link layer header type...................: DLT_IEEE802_11 (%d) very basic format without any additional information about the quality\\n\", dltlinktype[c]);\n\telse if(dltlinktype[c] == DLT_PPI)\t\t\tfprintf(stdout, \"link layer header type...................: DLT_PPI (%d)\\n\", dltlinktype[c]);\n\telse if(dltlinktype[c] == DLT_PRISM_HEADER)\t\tfprintf(stdout, \"link layer header type...................: DLT_PRISM_HEADER (%d)\\n\", dltlinktype[c]);\n\telse if(dltlinktype[c] == DLT_IEEE802_11_RADIO_AVS)\tfprintf(stdout, \"link layer header type...................: DLT_IEEE802_11_RADIO_AVS (%d)\\n\", dltlinktype[c]);\n\telse if(dltlinktype[c] == DLT_EN10MB)\t\t\tfprintf(stdout, \"link layer header type...................: DLT_EN10MB (%d)\\n\", dltlinktype[c]);\n\telse if(dltlinktype[c] == DLT_NULL)\t\t\tfprintf(stdout, \"link layer header type...................: DLT_NULL (BSD LO) (%d)\\n\", dltlinktype[c]);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void outputwordlists(void)\n{\nstatic int wecl;\nstatic maclist_t *zeigermac, *zeigermacold;\n\nzeigermacold = NULL;\nqsort(aplist, aplistptr -aplist, MACLIST_SIZE, sort_maclist_by_essidlen);\nwecl = strlen(pcapngweakcandidate);\nif((wecl > 0) && (wecl < 64) && (strcmp(pcapngweakcandidate, \"N/A\") != 0))\n\t{\n\tif(fh_essid != NULL) fprintf(fh_essid, \"%s\\n\", pcapngweakcandidate);\n\t}\nfor(zeigermac = aplist; zeigermac < aplistptr; zeigermac++)\n\t{\n\tif((zeigermacold != NULL) && (zeigermac->essidlen == zeigermacold->essidlen))\n\t\t{\n\t\tif(memcmp(zeigermac->essid, zeigermacold->essid, zeigermac->essidlen) == 0) continue;\n\t\t}\n\tif(fh_essid != NULL) fwriteessidstr(zeigermac->essidlen, zeigermac->essid, fh_essid);\n\tif((fh_essidproberequest != NULL) && (zeigermac->status == ST_PROBE_REQ)) fwriteessidstr(zeigermac->essidlen, zeigermac->essid, fh_essidproberequest);\n\tif((fh_essidproberequest != NULL) && (zeigermac->status == ST_ACT_MR_REQ)) fwriteessidstr(zeigermac->essidlen, zeigermac->essid, fh_essidproberequest);\n\tessidcount++;\n\tzeigermacold = zeigermac;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void outputdeviceinfolist(void)\n{\nstatic int p;\nstatic maclist_t *zeigermac;\n\nif(fh_deviceinfo == NULL) return;\nqsort(aplist, aplistptr -aplist, MACLIST_SIZE, sort_maclist_by_manufacturer);\nfor(zeigermac = aplist; zeigermac < aplistptr; zeigermac++)\n\t{\n\tif((zeigermac->manufacturerlen == 0) && (zeigermac->modellen == 0) && (zeigermac->serialnumberlen == 0) && (zeigermac->devicenamelen == 0) && (zeigermac->enrolleelen == 0)) continue;\n\tif((zeigermac->manufacturer[0] == 0) && (zeigermac->model[0] == 0) && (zeigermac->serialnumber[0] == 0) && (zeigermac->devicename[0] == 0)) continue;\n\tfor(p = 0; p < 6; p++) fprintf(fh_deviceinfo, \"%02x\", zeigermac->addr[p]);\n\tfwritedeviceinfostr(zeigermac->manufacturerlen, zeigermac->manufacturer, fh_deviceinfo);\n\tfwritedeviceinfostr(zeigermac->modellen, zeigermac->model, fh_deviceinfo);\n\tfwritedeviceinfostr(zeigermac->serialnumberlen, zeigermac->serialnumber, fh_deviceinfo);\n\tfwritedeviceinfostr(zeigermac->devicenamelen, zeigermac->devicename, fh_deviceinfo);\n\tif(zeigermac->enrolleelen != 0)\n\t\t{\n\t\tfprintf(fh_deviceinfo, \"\\t\");\n\t\tfor(p = 0; p < zeigermac->enrolleelen; p++) fprintf(fh_deviceinfo, \"%02x\", zeigermac->enrollee[p]);\n\t\t}\n\tfwritedeviceinfostr(zeigermac->essidlen, zeigermac->essid, fh_deviceinfo);\n\tfprintf(fh_deviceinfo, \"\\n\");\n\tdeviceinfocount++;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writecsv(uint64_t timestamp, uint8_t *mac, tags_t *tags)\n{\nstatic int c;\nstatic int p;\nstatic time_t tvo;\nstatic float latitude;\nstatic char ew;\nstatic float longitude;\nstatic float latm, lonm;\nstatic int fix;\nstatic int satcount;\nstatic float hdop;\nstatic float altitude;\nstatic char altunit;\nstatic char ns;\nstatic const char gpgga[] = \"$GPGGA\";\nstatic const char gprmc[] = \"$GPRMC\";\n\nstatic char timestring[24];\n\nif(tags->essidlen == 0) return;\nif(tags->essid[0] == 0) return;\ntvo = timestamp /1000000000;\nstrftime(timestring, 24, \"%Y-%m-%d\\t%H:%M:%S\", gmtime(&tvo));\nif((tags->essidlen != 0) && (tags->essid[0] != 0)) fprintf(fh_csv, \"%s\\t%02x:%02x:%02x:%02x:%02x:%02x\\t%.*s\\t\", timestring, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], tags->essidlen, tags->essid);\nelse fprintf(fh_csv, \"%s\\t%02x:%02x:%02x:%02x:%02x:%02x\\t<HIDDEN ESSID>\\t\", timestring, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\nif(tags->kdversion == 0) fprintf(fh_csv, \"OPEN\");\nif((tags->kdversion & KV_WPAIE) == KV_WPAIE) fprintf(fh_csv, \"[WPA1]\");\nif((tags->kdversion & KV_RSNIE) == KV_RSNIE) fprintf(fh_csv, \"[WPA2]\");\nfprintf(fh_csv, \"\\t\");\nif((tags->cipher & TCS_TKIP) == TCS_TKIP) fprintf(fh_csv, \"[TKIP]\");\nif((tags->cipher & TCS_CCMP) == TCS_CCMP) fprintf(fh_csv, \"[CCMP]\");\nif((tags->cipher & TCS_WEP40) == TCS_WEP40) fprintf(fh_csv, \"[WEP40]\");\nif((tags->cipher & TCS_WEP104) == TCS_WEP104) fprintf(fh_csv, \"[WEP104]\");\nif((tags->cipher & TCS_WRAP) == TCS_WRAP) fprintf(fh_csv, \"[WRAP]\");\nif((tags->cipher & TCS_BIP) == TCS_BIP) fprintf(fh_csv, \"[BIP]\");\nif((tags->cipher & TCS_NOT_ALLOWED) == TCS_NOT_ALLOWED) fprintf(fh_csv, \"[NOT_ALLOWED]\");\nfprintf(fh_csv, \"\\t\");\nif((tags->akm & TAK_PSK) == TAK_PSK) fprintf(fh_csv, \"[PSK]\");\nif((tags->akm & TAK_PSKSHA256) == TAK_PSKSHA256) fprintf(fh_csv, \"[PSK_SHA256]\");\nif((tags->akm & TAK_PMKSA) == TAK_PMKSA) fprintf(fh_csv, \"[PMKSA]\");\nif((tags->akm & TAK_PMKSA256) == TAK_PMKSA256) fprintf(fh_csv, \"[PMKSA_SHA256]\");\nif((tags->akm & TAK_FT) == TAK_FT) fprintf(fh_csv, \"[FT]\");\nif((tags->akm & TAK_FT_PSK) == TAK_FT_PSK) fprintf(fh_csv, \"[FT_PSK]\");\nif((tags->akm & TAK_FT_SAE) == TAK_FT_SAE) fprintf(fh_csv, \"[FT_SAE]\");\nif((tags->akm & TAK_TDLS) == TAK_TDLS) fprintf(fh_csv, \"[TDLS]\");\nif((tags->akm & TAK_SAE_SHA256) == TAK_SAE_SHA256) fprintf(fh_csv, \"[SAE_SHA256]\");\nif((tags->akm & TAK_SAE_SHA256B) == TAK_SAE_SHA256B) fprintf(fh_csv, \"[SAE_SHA256B]\");\nif((tags->akm & TAK_SAE_SHA384B) == TAK_SAE_SHA384B) fprintf(fh_csv, \"[SAE_SHA384B]\");\nif((tags->akm & TAK_AP_PKA) == TAK_AP_PKA) fprintf(fh_csv, \"[AP_PKA]\");\nif((tags->akm & TAK_OWE) == TAK_OWE) fprintf(fh_csv, \"[OWE]\");\nfprintf(fh_csv, \"\\t\");\nif((tags->country[0] >= 'A') && (tags->country[0] <= 'Z') && (tags->country[1] >= 'A') && (tags->country[1] <= 'Z')) fprintf(fh_csv,\"%c%c\\t\", tags->country[0], tags->country[1]);\nelse fprintf(fh_csv,\"00\\t\");\nif(tags->channel != 0) fprintf(fh_csv,\"%d\\t\", tags->channel);\nelse fprintf(fh_csv,\"%d\\t\", interfacechannel);\nfprintf(fh_csv, \"%d\\t\", rssi);\np = 7;\nc = 0;\nlatitude = 0;\nlongitude = 0;\new = 'E';\nns = 'S';\nlatm = 0;\nlonm = 0;\nfix = 0;\nsatcount = 0;\nhdop = 0;\naltitude = 0;\naltunit = 'M';\nif(nmealen < 48)\n\t{\n\tfprintf(fh_csv, \"%f\\t%c\\t%f\\t%c\\t%f\\t%f\\t%d\\t%d\\t%f\\t%f\\t%c\\n\", latitude, ew, longitude, ns, latm, lonm, fix, satcount, hdop, altitude, altunit);\n\treturn;\n\t}\nif(memcmp(&gpgga, nmeasentence, 6) == 0)\n\t{\n\twhile((nmeasentence[p] != 0) && (c < 1))\n\t\t{\n\t\tif(nmeasentence[p] == ',') c++;\n\t\tp++;\n\t\t}\n\tsscanf(&nmeasentence[p],\"%f,%c,%f,%c,%d,%d,%f,%f,%c\", &latitude, &ew, &longitude, &ns, &fix, &satcount, &hdop, &altitude, &altunit);\n\tif(latitude != 0) latm = ((int)latitude) /100 + (((int)latitude) %100 +latitude -(int)latitude)/60;\n\tif(longitude != 0) lonm = ((int)longitude) /100 + (((int)longitude) %100 +longitude -(int)longitude)/60;\n\tif(ew == 'W') latm =-latm;\n\tif(ns == 'S') lonm =-lonm;\n\tfprintf(fh_csv, \"%f\\t%c\\t%f\\t%c\\t%f\\t%f\\t%d\\t%d\\t%f\\t%f\\t%c\\n\", latitude, ew, longitude, ns, latm, lonm, fix, satcount, hdop, altitude, altunit);\n\treturn;\n\t}\nif(memcmp(&gprmc, nmeasentence, 6) == 0)\n\t{\n\twhile((nmeasentence[p] != 0) && (c < 2))\n\t\t{\n\t\tif(nmeasentence[p] == ',') c++;\n\t\tp++;\n\t\t}\n\tsscanf(&nmeasentence[p],\"%f,%c,%f,%c\", &latitude, &ew, &longitude, &ns);\n\tif(latitude != 0) latm = ((int)latitude) /100 + (((int)latitude) %100 +latitude -(int)latitude)/60;\n\tif(longitude != 0) lonm = ((int)longitude) /100 + (((int)longitude) %100 +longitude -(int)longitude)/60;\n\tif(ew == 'W') latm =-latm;\n\tif(ns == 'S') lonm =-lonm;\n\tfprintf(fh_csv, \"%f\\t%c\\t%f\\t%c\\t%f\\t%f\\t%d\\t%d\\t%f\\t%f\\t%c\\n\", latitude, ew, longitude, ns, latm, lonm, fix, satcount, hdop, altitude, altunit);\n\treturn;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writegpwpl(uint8_t *mac)\n{\nstatic int c;\nstatic int cs;\nstatic int cc, ca, ce;\nstatic int gpwpllen;\nstatic char *gpwplptr;\nstatic const char gpgga[] = \"$GPGGA\";\nstatic const char gprmc[] = \"$GPRMC\";\nstatic char gpwpl[NMEA_MAX];\n\nif(nmealen < 48) return;\ngpwpl[0] = 0;\nc = 0;\ncc = 0;\nca = 0;\nce = 0;\nif(memcmp(&gprmc, nmeasentence, 6) == 0)\n\t{\n\twhile(nmeasentence[c] != 0)\n\t\t{\n\t\tif(nmeasentence[c] == ',')\n\t\t\t{\n\t\t\tcc++;\n\t\t\tif(cc == 3) ca = c +1;\n\t\t\tif(cc == 7)\n\t\t\t\t{\n\t\t\t\tce = c;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tc++;\n\t\t}\n\tif(ce > ca) snprintf(gpwpl, NMEA_MAX-1, \"$GPWPL,%.*s,%02x%02x%02x%02x%02x%02x*\", ce-ca, &nmeasentence[ca], mac[0] , mac[1], mac[2], mac[3], mac[4], mac[5]);\n\t}\nelse if(memcmp(&gpgga, nmeasentence, 6) == 0)\n\t{\n\twhile(nmeasentence[c] != 0)\n\t\t{\n\t\tif(nmeasentence[c] == ',')\n\t\t\t{\n\t\t\tcc++;\n\t\t\tif(cc == 2) ca = c +1;\n\t\t\tif(cc == 6)\n\t\t\t\t{\n\t\t\t\tce = c;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tc++;\n\t\t}\n\tif(ce > ca) snprintf(gpwpl, NMEA_MAX-1, \"$GPWPL,%.*s,%02x%02x%02x%02x%02x%02x*\", ce-ca, &nmeasentence[ca], mac[0] , mac[1], mac[2], mac[3], mac[4], mac[5]);\n\t}\nelse return;\nif(gpwpl[0] == 0) return;\ngpwplptr = gpwpl+1;\nc = 0;\ncs = 0;\nwhile(gpwplptr[c] != '*')\n\t{\n\tcs ^= gpwplptr[c];\n\tgpwplptr++;\n\t}\nsnprintf(gpwplptr +1, NMEA_MAX -44, \"%02x\", cs);\ngpwpllen = strlen(gpwpl);\nif(memcmp(&gpwplold, &gpwpl, gpwpllen) != 0) fprintf(fh_nmea, \"%s\\n\", gpwpl);\nmemcpy(&gpwplold, &gpwpl, gpwpllen);\nreturn;\n}\n/*===========================================================================*/\nstatic void outputtacacsplist(void)\n{\nstatic uint32_t c;\nstatic tacacsplist_t *zeiger, *zeigerold;\n\nif(tacacsplist == tacacsplistptr) return;\nzeiger = tacacsplist;\nzeigerold = tacacsplist;\nif(fh_tacacsp != NULL)\n\t{\n\tfprintf(fh_tacacsp, \"$tacacs-plus$0$%08x$\", zeiger->sessionid);\n\tfor(c = 0; c < zeiger->len; c++) fprintf(fh_tacacsp, \"%02x\", zeiger->data[c]);\n\tfprintf(fh_tacacsp, \"$%02x%02x\\n\", zeiger->version, zeiger->sequencenr);\n\ttacacspwrittencount++;\n\t}\nfor(zeiger = tacacsplist +1; zeiger < tacacsplistptr; zeiger++)\n\t{\n\tif((zeigerold->sessionid == zeiger->sessionid) && (zeigerold->sequencenr == zeiger->sequencenr) && (zeigerold->len == zeiger->len) && (memcmp(zeigerold->data, zeiger->data, zeiger->len) == 0)) continue;\n\tif(fh_tacacsp != NULL)\n\t\t{\n\t\tfprintf(fh_tacacsp, \"$tacacs-plus$0$%08x$\", zeiger->sessionid);\n\t\tfor(c = 0; c < zeiger->len; c++) fprintf(fh_tacacsp, \"%02x\", zeiger->data[c]);\n\t\tfprintf(fh_tacacsp, \"$%02x%02x\\n\", zeiger->version, zeiger->sequencenr);\n\t\ttacacspwrittencount++;\n\t\t}\n\tzeigerold = zeiger;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processtacacsppacket(uint32_t restlen, uint8_t *tacacspptr)\n{\nstatic uint32_t authlen;\nstatic tacacsp_t *tacacsp;\nstatic tacacsplist_t *tacacsplistnew;\n\nif(restlen < (uint32_t)TACACSP_SIZE) return;\ntacacsp = (tacacsp_t*)tacacspptr;\ntacacspcount++;\nif(tacacsp->version != TACACSP_VERSION)\n\t{\n\ttacacsunknowncount++;\n\treturn;\n\t}\nif(tacacsp->type == TACACSP_AUTHOR)\n\t{\n\ttacacspauthorcount++;\n\treturn;\n\t}\nif(tacacsp->type == TACACSP_ACCT)\n\t{\n\ttacacspacctcount++;\n\treturn;\n\t}\nif(tacacsp->type != TACACSP_AUTHEN)\n\t{\n\ttacacsunknowncount++;\n\treturn;\n\t}\nauthlen = ntohl(tacacsp->len);\nif((authlen > restlen -TACACSP_SIZE) || (authlen > TACACSPMAX_LEN)) return;\nif(tacacsplistptr >= tacacsplist +tacacsplistmax)\n\t{\n\ttacacsplistnew = (tacacsplist_t*)realloc(tacacsplist, (tacacsplistmax +TACACSPLIST_MAX) *TACACSPLIST_SIZE);\n\tif(tacacsplistnew == NULL)\n\t\t{\n\t\tprintf(\"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\ttacacsplist = tacacsplistnew;\n\ttacacsplistptr = tacacsplistnew +tacacsplistmax;\n\ttacacsplistmax += TACACSPLIST_MAX;\n\t}\nmemset(tacacsplistptr, 0, TACACSPLIST_SIZE);\ntacacsplistptr->version = tacacsp->version;\ntacacsplistptr->sequencenr = tacacsp->sequencenr;\ntacacsplistptr->sessionid = ntohl(tacacsp->sessionid);\ntacacsplistptr->len = authlen;\nmemcpy(tacacsplistptr->data, tacacsp->data, authlen);\ntacacsplistptr++;\ntacacspauthencount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processprotochappacket(uint32_t restlen, uint8_t *chapptr)\n{\nstatic chap_t *chap;\n\nif(restlen < (uint32_t)CHAP_SIZE) return;\nchap = (chap_t*)chapptr;\nif(chap->code == CHAP_CODE_REQ) protochapreqcount++;\nelse if(chap->code == CHAP_CODE_RESP) protochaprespcount++;\nelse if(chap->code == CHAP_CODE_SUCCESS) protochapsuccesscount++;\nprotochapcount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processprotopapppacket(void)\n{\n\nprotopapcount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processptppacket(uint32_t restlen, uint8_t *ptpptr)\n{\nstatic ptp_t *ptp;\n\nif(restlen < (uint32_t)PTP_SIZE) return;\nptp = (ptp_t*)ptpptr;\nif(ntohs(ptp->type) == PROTO_CHAP) processprotochappacket(restlen -PTP_SIZE, ptpptr +PTP_SIZE);\nelse if(ntohs(ptp->type) == PROTO_PAP) processprotopapppacket();\nreturn;\n}\n/*===========================================================================*/\nstatic void processgrepacket(uint32_t restlen, uint8_t *greptr)\n{\nstatic gre_t *gre;\nstatic uint32_t ofco;\n\nif(restlen < (uint32_t)GRE_SIZE) return;\ngre = (gre_t*)greptr;\nif((ntohs(gre->flags) & GRE_MASK_VERSION) != 0x1) return; /* only GRE v1 supported */\nofco = 0;\nif((ntohs(gre->flags) & GRE_FLAG_SNSET) == GRE_FLAG_SNSET) ofco += 4;\nif((ntohs(gre->flags) & GRE_FLAG_ACKSET) == GRE_FLAG_ACKSET) ofco +=4;\nif(ntohs(gre->type) == GREPROTO_PPP) processptppacket(restlen -GRE_SIZE -ofco, greptr +GRE_SIZE +ofco);\ngrecount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processradiuspacket(uint64_t timestamp, uint32_t restlen, uint8_t *radiusptr)\n{\nstatic radius_t *radius;\nstatic uint16_t radiuslen;\n\nif(restlen < RADIUS_MIN_SIZE) return;\nradius = (radius_t*)radiusptr;\nradiuslen = ntohs(radius->len);\nif(restlen != radiuslen) return;\nif(radius->code ==RADIUS_ACCESS_REQUEST) radiusrequestcount++;\nelse if(radius->code == RADIUS_ACCESS_ACCEPT) radiusacceptcount++;\nelse if(radius->code == RADIUS_ACCESS_REJECT) radiusrejectcount++;\nelse if(radius->code == RADIUS_ACCESS_CHALLENGE) radiuschallengecount++;\ntimestamp = timestamp;\nreturn;\n}\n/*===========================================================================*/\nstatic void processudppacket(uint64_t timestamp, uint32_t restlen, uint8_t *udpptr)\n{\nstatic udp_t *udp;\nstatic uint16_t udplen;\nstatic uint16_t udpsourceport;\nstatic uint16_t udpdestinationport;\n\nif(restlen < UDP_SIZE) return;\nudp = (udp_t*)udpptr;\nudplen = ntohs(udp->len);\nif(restlen < udplen) return;\nudpcount++;\nudpsourceport = ntohs(udp->sourceport);\nudpdestinationport = ntohs(udp->destinationport);\nif((udpsourceport == UDP_RADIUS_PORT) || (udpdestinationport == UDP_RADIUS_PORT)) processradiuspacket(timestamp, restlen -UDP_SIZE, udpptr +UDP_SIZE);\nreturn;\n}\n/*===========================================================================*/\nstatic void processtcppacket(uint64_t timestamp, uint32_t restlen, uint8_t *tcpptr)\n{\nstatic uint32_t tcplen;\nstatic tcp_t *tcp;\nstatic tacacsp_t *tacacsp;\n\nif(restlen < TCP_SIZE_MIN) return;\ntcp = (tcp_t*)tcpptr;\ntcplen = byte_swap_8(tcp->len) *4;\nif(restlen < tcplen) return;\nif(restlen >= (uint32_t)TCP_SIZE_MIN +(uint32_t)TACACSP_SIZE)\n\t{\n\ttacacsp = (tacacsp_t*)(tcpptr +tcplen);\n\tif(tacacsp->version == TACACSP_VERSION) processtacacsppacket(restlen -tcplen, tcpptr +tcplen);\n\t}\ntcpcount++;\n//dummy code to satisfy gcc untill full code is implemented\ntimestamp = timestamp;\nreturn;\n}\n/*===========================================================================*/\nstatic void processicmp4(void)\n{\nicmp4count++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processipv4(uint64_t timestamp, uint32_t restlen, uint8_t *ipv4ptr)\n{\nstatic ipv4_t *ipv4;\nstatic uint32_t ipv4len;\n\nif(restlen < IPV4_SIZE_MIN) return;\nipv4 = (ipv4_t*)ipv4ptr;\nif((ipv4->ver_hlen & 0xf0) != 0x40) return;\nipv4len = (ipv4->ver_hlen & 0x0f) *4;\nif(restlen < ipv4len) return;\nif(ipv4->nextprotocol == NEXTHDR_TCP) processtcppacket(timestamp, ntohs(ipv4->len) -ipv4len, ipv4ptr +ipv4len);\nelse if(ipv4->nextprotocol == NEXTHDR_UDP) processudppacket(timestamp, ntohs(ipv4->len) -ipv4len, ipv4ptr +ipv4len);\nelse if(ipv4->nextprotocol == NEXTHDR_ICMP4) processicmp4();\nelse if(ipv4->nextprotocol == NEXTHDR_GRE) processgrepacket(ntohs(ipv4->len) -ipv4len, ipv4ptr +ipv4len);\nipv4count++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processicmp6(void)\n{\nicmp6count++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processipv6(uint64_t timestamp, uint16_t restlen, uint8_t *ipv6ptr)\n{\nstatic ipv6_t *ipv6;\n\nif(restlen < IPV6_SIZE) return;\nipv6 = (ipv6_t*)ipv6ptr;\nif((ntohl(ipv6->ver_class) & 0xf0000000) != 0x60000000) return;\nif(restlen < ntohs(ipv6->len)) return;\nif(ipv6->nextprotocol == NEXTHDR_TCP) processtcppacket(timestamp, restlen, ipv6ptr +IPV6_SIZE);\nelse if(ipv6->nextprotocol == NEXTHDR_UDP) processudppacket(timestamp, restlen, ipv6ptr +IPV6_SIZE);\nelse if(ipv6->nextprotocol == NEXTHDR_ICMP6) processicmp6();\nelse if(ipv6->nextprotocol == NEXTHDR_GRE) processgrepacket(restlen, ipv6ptr +IPV6_SIZE);\nipv6count++;\nreturn;\n}\n/*===========================================================================*/\nstatic inline bool mschapv2_challenge_hash(uint8_t *peer_challenge, uint8_t *auth_challenge, uint8_t *username, size_t usernamelen, uint8_t *challenge)\n{\nstatic unsigned int shalen;\nstatic EVP_MD_CTX* mdctx;\nstatic uint8_t shahash[EVP_MAX_MD_SIZE];\n\nshalen = 40;\nmdctx = EVP_MD_CTX_create();\nif(mdctx == NULL) return false;\nif(EVP_DigestInit_ex(mdctx, EVP_sha1(), NULL) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn false;\n\t}\nshalen = MSCHAPV2_CHALLENGE_LEN_MAX;\nif(EVP_DigestUpdate(mdctx, peer_challenge, MSCHAPV2_CHALLENGE_PEER_LEN_MAX) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn false;\n\t}\nif(EVP_DigestUpdate(mdctx, auth_challenge, MSCHAPV2_CHALLENGE_PEER_LEN_MAX) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn false;\n\t}\nif(EVP_DigestUpdate(mdctx, username, usernamelen) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn false;\n\t}\nif(EVP_DigestFinal_ex(mdctx, shahash, &shalen) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn false;\n\t}\nEVP_MD_CTX_free(mdctx);\nmemcpy(challenge, shahash, MSCHAPV2_CHALLENGE_LEN_MAX);\nreturn true;\n}\n/*===========================================================================*/\nstatic inline size_t mschapv2_username_clean(uint8_t *username, size_t usernamelen, uint8_t *usernameclean)\n{\nstatic char *ptr;\n\nptr = (char*)memchr(username, '\\\\', usernamelen);\nif(ptr == NULL)\n\t{\n\tmemcpy(usernameclean, username, usernamelen);\n\treturn usernamelen;\n\t}\nmemcpy(usernameclean, ptr +1, username +usernamelen -(uint8_t*)ptr -1);\nreturn (username +usernamelen -(uint8_t*)ptr -1);\n}\n/*===========================================================================*/\nstatic void outputeapmschapv2hashlist(void)\n{\nstatic eapmschapv2hashlist_t *zeiger, *zeigerold;\nstatic uint8_t challenge[MSCHAPV2_CHALLENGE_LEN_MAX];\nstatic uint8_t usernameclean[MSCHAPV2USERNAME_LEN_MAX];\nstatic size_t usernamecleanlen;\n\nzeiger = eapmschapv2hashlist;\nzeigerold = NULL;\nqsort(eapmschapv2hashlist, eapmschapv2hashlistptr -eapmschapv2hashlist, EAPMSCHAPV2HASHLIST_SIZE, sort_eapmschapv2hashlist_by_id);\nfor(zeiger = eapmschapv2hashlist; zeiger < eapmschapv2hashlistptr; zeiger++)\n\t{\n\tif((zeigerold != NULL) && (zeigerold->id == zeiger->id) && (zeigerold->mschapv2usernamelen == zeiger->mschapv2usernamelen) && (memcmp(zeigerold->mschapv2username, zeiger->mschapv2username, zeiger->mschapv2usernamelen) == 0) && (memcmp(zeigerold->mschapv2request, zeiger->mschapv2request, MSCHAPV2REQ_LEN_MAX) == 0) && (memcmp(zeigerold->mschapv2response, zeiger->mschapv2response, MSCHAPV2RESP_LEN_MAX) == 0)) continue;\n\tif(fh_eapleap != NULL)\n\t\t{\n\t\tusernamecleanlen = mschapv2_username_clean(zeiger->mschapv2username, zeiger->mschapv2usernamelen, usernameclean);\n\t\tif(mschapv2_challenge_hash(zeiger->mschapv2response, zeiger->mschapv2request, usernameclean, usernamecleanlen, challenge) == false) continue;\n\t\tfprintf(fh_eapleap, \"%.*s::::%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t(int)zeiger->mschapv2usernamelen, zeiger->mschapv2username,\n\t\t\tzeiger->mschapv2response[24], zeiger->mschapv2response[25], zeiger->mschapv2response[26], zeiger->mschapv2response[27], zeiger->mschapv2response[28], zeiger->mschapv2response[29], zeiger->mschapv2response[30], zeiger->mschapv2response[31],\n\t\t\tzeiger->mschapv2response[32], zeiger->mschapv2response[33], zeiger->mschapv2response[34], zeiger->mschapv2response[35], zeiger->mschapv2response[36], zeiger->mschapv2response[37], zeiger->mschapv2response[38], zeiger->mschapv2response[39],\n\t\t\tzeiger->mschapv2response[40], zeiger->mschapv2response[41], zeiger->mschapv2response[42], zeiger->mschapv2response[43], zeiger->mschapv2response[44], zeiger->mschapv2response[45], zeiger->mschapv2response[46], zeiger->mschapv2response[47],\n\t\t\tchallenge[0], challenge[1], challenge[2], challenge[3], challenge[4], challenge[5], challenge[6], challenge[7]);\n\t\teapmschapv2writtencount++;\n\t\t}\n\tzeigerold = zeiger;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void addeapmschapv2hash(uint8_t id, uint8_t mschapv2usernamelen, uint8_t *mschapv2username, uint8_t *mschapv2request, uint8_t *mschapv2response)\n{\nstatic eapmschapv2hashlist_t *eapmschapv2hashlistnew;\n\neapmschapv2hashcount++;\nif(eapmschapv2hashlistptr >= eapmschapv2hashlist +eapmschapv2hashlistmax)\n\t{\n\teapmschapv2hashlistnew = (eapmschapv2hashlist_t*)realloc(eapmschapv2hashlist, (eapmschapv2hashlistmax +EAPMSCHAPV2HASHLIST_MAX) *EAPMSCHAPV2HASHLIST_SIZE);\n\tif(eapmschapv2hashlistnew == NULL)\n\t\t{\n\t\tprintf(\"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\teapmschapv2hashlist = eapmschapv2hashlistnew;\n\teapmschapv2hashlistptr = eapmschapv2hashlistnew +eapmschapv2hashlistmax;\n\teapmschapv2hashlistmax += EAPMSCHAPV2HASHLIST_MAX;\n\t}\nmemset(eapmschapv2hashlistptr, 0, EAPMSCHAPV2HASHLIST_SIZE);\neapmschapv2hashlistptr->id = id;\nmemcpy(eapmschapv2hashlistptr->mschapv2request, mschapv2request, MSCHAPV2REQ_LEN_MAX);\nmemcpy(eapmschapv2hashlistptr->mschapv2response, mschapv2response, MSCHAPV2RESP_LEN_MAX);\neapmschapv2hashlistptr->mschapv2usernamelen = mschapv2usernamelen;\nmemcpy(eapmschapv2hashlistptr->mschapv2username, mschapv2username, mschapv2usernamelen);\neapmschapv2hashlistptr++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processexteapmschapv2(uint64_t eaptimestamp, uint8_t *macto, uint8_t *macfm, uint8_t eapcode, uint32_t restlen, uint8_t *eapmschapv2ptr)\n{\nstatic eapmschapv2_t *eapmschapv2;\nstatic uint16_t eaplen;\nstatic uint16_t mschapv2len;\nstatic eapmschapv2msglist_t *zeiger;\nstatic uint32_t mschapv2usernamelen;\nstatic uint8_t *mschapv2usernameptr;\n\neapmschapv2count++;\neapmschapv2 = (eapmschapv2_t*)eapmschapv2ptr;\neaplen = ntohs(eapmschapv2->eaplen);\nmschapv2len = ntohs(eapmschapv2->mschapv2len);\nif(eaplen > restlen) return;\nif((eapcode == EAP_CODE_REQ) && (eapmschapv2->opcode == EAP_MSCHAPV2_OPCODE_REQ))\n\t{\n\tzeiger = eapmschapv2msglist +EAPMSCHAPV2MSGLIST_MAX;\n\tif(eapmschapv2->mschapv2valuesize != MSCHAPV2REQ_LEN_MAX) return;\n\tmemset(zeiger, 0, EAPMSCHAPV2MSGLIST_SIZE);\n\tzeiger->timestamp = eaptimestamp;\n\tmemcpy(zeiger->ap, macfm, 6);\n\tmemcpy(zeiger->client, macto, 6);\n\tzeiger->type = EAP_CODE_REQ;\n\tzeiger->id = eapmschapv2->id;\n\tmemcpy(zeiger->mschapv2request, eapmschapv2->mschapv2data, eapmschapv2->mschapv2valuesize);\n\tmschapv2usernamelen = eaplen -EAPMSCHAPV2_SIZE -eapmschapv2->mschapv2valuesize;\n\tif(mschapv2usernamelen > MSCHAPV2USERNAME_LEN_MAX) return;\n\tif(EAPMSCHAPV2_SIZE +MSCHAPV2REQ_LEN_MAX +mschapv2usernamelen > restlen) return;\n\tmschapv2usernameptr = eapmschapv2ptr +EAPMSCHAPV2_SIZE +eapmschapv2->mschapv2valuesize;\n\tif((fh_identity != 0) && (mschapv2usernamelen > 0))\n\t\t{\n\t\tfwritestring(mschapv2usernamelen, mschapv2usernameptr, fh_identity);\n\t\tidentitycount++;\n\t\t}\n\tqsort(eapmschapv2msglist, EAPMSCHAPV2MSGLIST_MAX +1, EAPMSCHAPV2MSGLIST_SIZE, sort_eapmschapv2msglist_by_timestamp);\n\t}\nelse if((eapcode == EAP_CODE_RESP) && (eapmschapv2->opcode == EAP_MSCHAPV2_OPCODE_RESP))\n\t{\n\tzeiger = eapmschapv2msglist +EAPMSCHAPV2MSGLIST_MAX;\n\tif(mschapv2len != eaplen -EXTEAP_SIZE) return;\n\tif(memcmp(&zeroed32, eapmschapv2->mschapv2data +MSCHAPV2_CHALLENGE_PEER_LEN_MAX +MSCHAPV2_RESERVED_LEN_MAX, MSCHAPV2_NTRESPONSE_LEN_MAX) == 0) return;\n\tif(eapmschapv2->mschapv2valuesize != MSCHAPV2RESP_LEN_MAX) return;\n\tmemset(zeiger, 0, EAPMSCHAPV2MSGLIST_SIZE);\n\tzeiger->timestamp = eaptimestamp;\n\tmemcpy(zeiger->ap, macto, 6);\n\tmemcpy(zeiger->client, macfm, 6);\n\tzeiger->type = EAP_CODE_RESP;\n\tzeiger->id = eapmschapv2->id;\n\tmemcpy(zeiger->mschapv2response, eapmschapv2->mschapv2data, eapmschapv2->mschapv2valuesize);\n\tmschapv2usernamelen = restlen -EAPMSCHAPV2_SIZE -eapmschapv2->mschapv2valuesize;\n\tif(mschapv2usernamelen == 0) return;\n\tif(mschapv2usernamelen > MSCHAPV2USERNAME_LEN_MAX) return;\n\tif(EAPMSCHAPV2_SIZE +MSCHAPV2REQ_LEN_MAX +mschapv2usernamelen > restlen) return;\n\tmschapv2usernameptr = eapmschapv2ptr +EAPMSCHAPV2_SIZE +eapmschapv2->mschapv2valuesize;\n\tzeiger->mschapv2usernamelen = mschapv2usernamelen;\n\tmemcpy(zeiger->mschapv2username, mschapv2usernameptr, mschapv2usernamelen);\n\tif(fh_username != 0)\n\t\t{\n\t\tfwritestring(mschapv2usernamelen, mschapv2usernameptr, fh_username);\n\t\tusernamecount++;\n\t\t}\n\tfor(zeiger = eapmschapv2msglist; zeiger < eapmschapv2msglist +EAPMSCHAPV2MSGLIST_MAX; zeiger++)\n\t\t{\n\t\tif((zeiger->type) != EAP_CODE_REQ) continue;\n\t\tif((zeiger->id) != eapmschapv2->id) continue;\n\t\tif(memcmp(zeiger->ap, macto, 6) != 0) continue;\n\t\tif(memcmp(zeiger->client, macfm, 6) != 0) continue;\n\t\tzeiger->mschapv2usernamelen = mschapv2usernamelen;\n\t\tmemcpy(zeiger->mschapv2username, mschapv2usernameptr, mschapv2usernamelen);\n\t\taddeapmschapv2hash(eapmschapv2->id, zeiger->mschapv2usernamelen, zeiger->mschapv2username, zeiger->mschapv2request, eapmschapv2->mschapv2data);\n\t\t}\n\tqsort(eapmschapv2msglist, EAPMSCHAPV2MSGLIST_MAX +1, EAPMSCHAPV2MSGLIST_SIZE, sort_eapmschapv2msglist_by_timestamp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void outputeapleaphashlist(void)\n{\nstatic eapleaphashlist_t *zeiger, *zeigerold;\n\nzeiger = eapleaphashlist;\nzeigerold = eapleaphashlist;\nif(memcmp(&zeroed32, zeiger->leaprequest, LEAPREQ_LEN_MAX) == 0) return;\nqsort(eapleaphashlist, eapleaphashlistptr -eapleaphashlist, EAPLEAPHASHLIST_SIZE, sort_eapleaphashlist_by_id);\nif(fh_eapleap != NULL)\n\t{\n\tfprintf(fh_eapleap, \"%.*s::::%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\tzeiger->leapusernamelen, zeiger->leapusername,\n\t\tzeiger->leapresponse[0], zeiger->leapresponse[1], zeiger->leapresponse[2], zeiger->leapresponse[3], zeiger->leapresponse[4], zeiger->leapresponse[5], zeiger->leapresponse[6], zeiger->leapresponse[7],\n\t\tzeiger->leapresponse[8], zeiger->leapresponse[9], zeiger->leapresponse[10], zeiger->leapresponse[11], zeiger->leapresponse[12], zeiger->leapresponse[13], zeiger->leapresponse[14], zeiger->leapresponse[15],\n\t\tzeiger->leapresponse[16], zeiger->leapresponse[17], zeiger->leapresponse[18], zeiger->leapresponse[19], zeiger->leapresponse[20], zeiger->leapresponse[21], zeiger->leapresponse[22], zeiger->leapresponse[23],\n\t\tzeiger->leaprequest[0], zeiger->leaprequest[1], zeiger->leaprequest[2], zeiger->leaprequest[3], zeiger->leaprequest[4], zeiger->leaprequest[5], zeiger->leaprequest[6], zeiger->leaprequest[7]);\n\teapleapwrittencount++;\n\t}\nfor(zeiger = eapleaphashlist +1; zeiger < eapleaphashlistptr; zeiger++)\n\t{\n\tif((zeigerold->id == zeiger->id) && (zeigerold->leapusernamelen == zeiger->leapusernamelen) && (memcmp(zeigerold->leapusername, zeiger->leapusername, zeiger->leapusernamelen) == 0) && (memcmp(zeigerold->leaprequest, zeiger->leaprequest, LEAPREQ_LEN_MAX) == 0) && (memcmp(zeigerold->leapresponse, zeiger->leapresponse, LEAPRESP_LEN_MAX) == 0)) continue;\n\tif(fh_eapleap != NULL)\n\t\t{\n\t\tfprintf(fh_eapleap, \"%.*s::::%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\tzeiger->leapusernamelen, zeiger->leapusername,\n\t\t\tzeiger->leapresponse[0], zeiger->leapresponse[1], zeiger->leapresponse[2], zeiger->leapresponse[3], zeiger->leapresponse[4], zeiger->leapresponse[5], zeiger->leapresponse[6], zeiger->leapresponse[7],\n\t\t\tzeiger->leapresponse[8], zeiger->leapresponse[9], zeiger->leapresponse[10], zeiger->leapresponse[11], zeiger->leapresponse[12], zeiger->leapresponse[13], zeiger->leapresponse[14], zeiger->leapresponse[15],\n\t\t\tzeiger->leapresponse[16], zeiger->leapresponse[17], zeiger->leapresponse[18], zeiger->leapresponse[19], zeiger->leapresponse[20], zeiger->leapresponse[21], zeiger->leapresponse[22], zeiger->leapresponse[23],\n\t\t\tzeiger->leaprequest[0], zeiger->leaprequest[1], zeiger->leaprequest[2], zeiger->leaprequest[3], zeiger->leaprequest[4], zeiger->leaprequest[5], zeiger->leaprequest[6], zeiger->leaprequest[7]);\n\t\teapleapwrittencount++;\n\t\t}\n\tzeigerold = zeiger;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void addeapleaphash(uint8_t id, uint8_t leapusernamelen, uint8_t *leapusername, uint8_t *leaprequest, uint8_t *leapresponse)\n{\nstatic eapleaphashlist_t *eapleaphashlistnew;\n\neapleaphashcount++;\nif(eapleaphashlistptr >= eapleaphashlist +eapleaphashlistmax)\n\t{\n\teapleaphashlistnew = (eapleaphashlist_t*)realloc(eapleaphashlist, (eapleaphashlistmax +EAPLEAPHASHLIST_MAX) *EAPLEAPHASHLIST_SIZE);\n\tif(eapleaphashlistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\teapleaphashlist = eapleaphashlistnew;\n\teapleaphashlistptr = eapleaphashlistnew +eapleaphashlistmax;\n\teapleaphashlistmax += EAPLEAPHASHLIST_MAX;\n\t}\nmemset(eapleaphashlistptr, 0, EAPLEAPHASHLIST_SIZE);\neapleaphashlistptr->id = id;\nmemcpy(eapleaphashlistptr->leaprequest, leaprequest, LEAPREQ_LEN_MAX);\nmemcpy(eapleaphashlistptr->leapresponse, leapresponse, LEAPRESP_LEN_MAX);\neapleaphashlistptr->leapusernamelen = leapusernamelen;\nmemcpy(eapleaphashlistptr->leapusername, leapusername, leapusernamelen);\neapleaphashlistptr++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processexteapleap(uint64_t eaptimestamp, uint8_t *macto, uint8_t *macfm, uint8_t eapcode, uint32_t restlen, uint8_t *eapleapptr)\n{\nstatic eapleap_t *eapleap;\nstatic uint32_t eapleaplen;\nstatic eapleapmsglist_t *zeiger;\nstatic uint32_t leapusernamelen;\nstatic uint8_t *leapusernameptr;\n\neapleapcount++;\neapleap = (eapleap_t*)eapleapptr;\neapleaplen = ntohs(eapleap->eapleaplen);\nif(eapleaplen > restlen) return;\nif(eapleap->version != 1) return;\nif(eapleap->reserved != 0) return;\nif(eapcode == EAP_CODE_REQ)\n\t{\n\tzeiger = eapleapmsglist +EAPLEAPMSGLIST_MAX;\n\tif(eapleap->leaplen != LEAPREQ_LEN_MAX) return;\n\tif(eapleap->leaplen > eapleaplen -EAPLEAP_SIZE) return;\n\tif(eapleap->leaplen == eapleaplen -EAPLEAP_SIZE) return;\n\tif(memcmp(&zeroed32, eapleap->leapdata, LEAPREQ_LEN_MAX) == 0) return;\n\tmemset(zeiger, 0, EAPLEAPMSGLIST_SIZE);\n\tzeiger->timestamp = eaptimestamp;\n\tmemcpy(zeiger->ap, macfm, 6);\n\tmemcpy(zeiger->client, macto, 6);\n\tzeiger->type = EAP_CODE_REQ;\n\tzeiger->id = eapleap->id;\n\tmemcpy(zeiger->leaprequest, eapleap->leapdata, LEAPREQ_LEN_MAX);\n\tleapusernamelen = eapleaplen -EAPLEAP_SIZE -LEAPREQ_LEN_MAX;\n\tif(leapusernamelen == 0) return;\n\tif(leapusernamelen > LEAPUSERNAME_LEN_MAX) return;\n\tif(EAPLEAP_SIZE +LEAPREQ_LEN_MAX +leapusernamelen > restlen) return;\n\tleapusernameptr = eapleapptr +EAPLEAP_SIZE +LEAPREQ_LEN_MAX;\n\tzeiger->leapusernamelen = leapusernamelen;\n\tmemcpy(zeiger->leapusername, leapusernameptr, leapusernamelen);\n\tif(fh_username != 0)\n\t\t{\n\t\tfwritestring(leapusernamelen, leapusernameptr, fh_username);\n\t\tusernamecount++;\n\t\t}\n\tqsort(eapleapmsglist, EAPLEAPMSGLIST_MAX +1, EAPLEAPMSGLIST_SIZE, sort_eapleapmsglist_by_timestamp);\n\t}\nelse if(eapcode == EAP_CODE_RESP)\n\t{\n\tzeiger = eapleapmsglist +EAPLEAPMSGLIST_MAX;\n\tif(eapleap->leaplen != LEAPRESP_LEN_MAX) return;\n\tif(eapleap->leaplen > eapleaplen -EAPLEAP_SIZE) return;\n\tif(memcmp(&zeroed32, eapleap->leapdata, LEAPRESP_LEN_MAX) == 0) return;\n\tmemset(zeiger, 0, EAPLEAPMSGLIST_SIZE);\n\tzeiger->timestamp = eaptimestamp;\n\tmemcpy(zeiger->ap, macto, 6);\n\tmemcpy(zeiger->client, macfm, 6);\n\tzeiger->type = EAP_CODE_RESP;\n\tzeiger->id = eapleap->id;\n\tmemcpy(zeiger->leapresponse, eapleap->leapdata, LEAPRESP_LEN_MAX);\n\tfor(zeiger = eapleapmsglist; zeiger < eapleapmsglist +EAPLEAPMSGLIST_MAX; zeiger++)\n\t\t{\n\t\tif((zeiger->type) != EAP_CODE_REQ) continue;\n\t\tif((zeiger->id) != eapleap->id) continue;\n\t\tif(memcmp(zeiger->ap, macto, 6) != 0) continue;\n\t\tif(memcmp(zeiger->client, macfm, 6) != 0) continue;\n\t\taddeapleaphash(eapleap->id, zeiger->leapusernamelen, zeiger->leapusername, zeiger->leaprequest, eapleap->leapdata);\n\t\t}\n\tqsort(eapleapmsglist, EAPLEAPMSGLIST_MAX +1, EAPLEAPMSGLIST_SIZE, sort_eapleapmsglist_by_timestamp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void outputeapmd5hashlist(void)\n{\nstatic eapmd5hashlist_t *zeiger, *zeigerold;\n\nzeiger = eapmd5hashlist;\nzeigerold = eapmd5hashlist;\nif(memcmp(&zeroed32, zeiger->md5request, EAPMD5_LEN_MAX) == 0) return;\nqsort(eapmd5hashlist, eapmd5hashlistptr -eapmd5hashlist, EAPMD5HASHLIST_SIZE, sort_eapmd5hashlist_by_id);\nif(fh_eapmd5 != 0)\n\t{\n\tfprintf(fh_eapmd5, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x\\n\",\n\t\t\tzeiger->md5response[0], zeiger->md5response[1], zeiger->md5response[2], zeiger->md5response[3], zeiger->md5response[4], zeiger->md5response[5], zeiger->md5response[6], zeiger->md5response[7],\n\t\t\tzeiger->md5response[8], zeiger->md5response[9], zeiger->md5response[10], zeiger->md5response[11], zeiger->md5response[12], zeiger->md5response[13], zeiger->md5response[14], zeiger->md5response[15],\n\t\t\tzeiger->md5request[0], zeiger->md5request[1], zeiger->md5request[2], zeiger->md5request[3], zeiger->md5request[4], zeiger->md5request[5], zeiger->md5request[6], zeiger->md5request[7],\n\t\t\tzeiger->md5request[8], zeiger->md5request[9], zeiger->md5request[10], zeiger->md5request[11], zeiger->md5request[12], zeiger->md5request[13], zeiger->md5request[14], zeiger->md5request[15],\n\t\t\tzeiger->id);\n\t\t\teapmd5writtencount++;\n\t}\nif(fh_eapmd5john != 0)\n\t{\n\tfprintf(fh_eapmd5john, \"$chap$%x*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\tzeiger->id,\n\t\t\tzeiger->md5request[0], zeiger->md5request[1], zeiger->md5request[2], zeiger->md5request[3], zeiger->md5request[4], zeiger->md5request[5], zeiger->md5request[6], zeiger->md5request[7],\n\t\t\tzeiger->md5request[8], zeiger->md5request[9], zeiger->md5request[10], zeiger->md5request[11], zeiger->md5request[12], zeiger->md5request[13], zeiger->md5request[14], zeiger->md5request[15],\n\t\t\tzeiger->md5response[0], zeiger->md5response[1], zeiger->md5response[2], zeiger->md5response[3], zeiger->md5response[4], zeiger->md5response[5], zeiger->md5response[6], zeiger->md5response[7],\n\t\t\tzeiger->md5response[8], zeiger->md5response[9], zeiger->md5response[10], zeiger->md5response[11], zeiger->md5response[12], zeiger->md5response[13], zeiger->md5response[14], zeiger->md5response[15]);\n\t\t\teapmd5johnwrittencount++;\n\t}\nfor(zeiger = eapmd5hashlist +1; zeiger < eapmd5hashlistptr; zeiger++)\n\t{\n\tif((zeigerold->id == zeiger->id) && (memcmp(zeigerold->md5request, zeiger->md5request, EAPMD5_LEN_MAX) == 0) && (memcmp(zeigerold->md5response, zeiger->md5response, EAPMD5_LEN_MAX) == 0)) continue;\n\tif(fh_eapmd5 != 0)\n\t\t{\n\t\tfprintf(fh_eapmd5, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x:%02x\\n\",\n\t\t\t\tzeiger->md5response[0], zeiger->md5response[1], zeiger->md5response[2], zeiger->md5response[3], zeiger->md5response[4], zeiger->md5response[5], zeiger->md5response[6], zeiger->md5response[7],\n\t\t\t\tzeiger->md5response[8], zeiger->md5response[9], zeiger->md5response[10], zeiger->md5response[11], zeiger->md5response[12], zeiger->md5response[13], zeiger->md5response[14], zeiger->md5response[15],\n\t\t\t\tzeiger->md5request[0], zeiger->md5request[1], zeiger->md5request[2], zeiger->md5request[3], zeiger->md5request[4], zeiger->md5request[5], zeiger->md5request[6], zeiger->md5request[7],\n\t\t\t\tzeiger->md5request[8], zeiger->md5request[9], zeiger->md5request[10], zeiger->md5request[11], zeiger->md5request[12], zeiger->md5request[13], zeiger->md5request[14], zeiger->md5request[15],\n\t\t\t\tzeiger->id);\n\t\teapmd5writtencount++;\n\t\t}\n\tif(fh_eapmd5john != 0)\n\t\t{\n\t\tfprintf(fh_eapmd5john, \"$chap$%x*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t\tzeiger->id,\n\t\t\t\tzeiger->md5request[0], zeiger->md5request[1], zeiger->md5request[2], zeiger->md5request[3], zeiger->md5request[4], zeiger->md5request[5], zeiger->md5request[6], zeiger->md5request[7],\n\t\t\t\tzeiger->md5request[8], zeiger->md5request[9], zeiger->md5request[10], zeiger->md5request[11], zeiger->md5request[12], zeiger->md5request[13], zeiger->md5request[14], zeiger->md5request[15],\n\t\t\t\tzeiger->md5response[0], zeiger->md5response[1], zeiger->md5response[2], zeiger->md5response[3], zeiger->md5response[4], zeiger->md5response[5], zeiger->md5response[6], zeiger->md5response[7],\n\t\t\t\tzeiger->md5response[8], zeiger->md5response[9], zeiger->md5response[10], zeiger->md5response[11], zeiger->md5response[12], zeiger->md5response[13], zeiger->md5response[14], zeiger->md5response[15]);\n\t\t\t\teapmd5johnwrittencount++;\n\t\t}\n\tzeigerold = zeiger;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void addeapmd5hash(uint8_t id, uint8_t *challenge, uint8_t *response)\n{\nstatic eapmd5hashlist_t *eapmd5hashlistnew;\n\neapmd5hashcount++;\nif(eapmd5hashlistptr >= eapmd5hashlist +eapmd5hashlistmax)\n\t{\n\teapmd5hashlistnew = (eapmd5hashlist_t*)realloc(eapmd5hashlist, (eapmd5hashlistmax +EAPMD5HASHLIST_MAX) *EAPMD5HASHLIST_SIZE);\n\tif(eapmd5hashlistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\teapmd5hashlist = eapmd5hashlistnew;\n\teapmd5hashlistptr = eapmd5hashlistnew +eapmd5hashlistmax;\n\teapmd5hashlistmax += EAPMD5HASHLIST_MAX;\n\t}\nmemset(eapmd5hashlistptr, 0, EAPMD5HASHLIST_SIZE);\neapmd5hashlistptr->id = id;\nmemcpy(eapmd5hashlistptr->md5request, challenge, EAPMD5_LEN_MAX);\nmemcpy(eapmd5hashlistptr->md5response, response, EAPMD5_LEN_MAX);\neapmd5hashlistptr++;\nreturn;\n}\n/*===========================================================================*/\nstatic void processexteapmd5(uint64_t eaptimestamp, uint8_t *macto, uint8_t *macfm, uint8_t eapcode, uint32_t restlen, uint8_t *eapmd5ptr)\n{\nstatic eapmd5_t *eapmd5;\nstatic uint32_t eapmd5len;\nstatic eapmd5msglist_t *zeiger;\n\neapmd5count++;\neapmd5 = (eapmd5_t*)eapmd5ptr;\neapmd5len = ntohs(eapmd5->eapmd5len);\nif(eapmd5len != restlen) return;\nif(eapmd5->md5len != EAPMD5_LEN_MAX) return;\nif(memcmp(&zeroed32, eapmd5->md5data, EAPMD5_LEN_MAX) == 0) return;\nif(eapcode == EAP_CODE_REQ)\n\t{\n\tzeiger = eapmd5msglist +EAPMD5MSGLIST_MAX;\n\tmemset(zeiger, 0, EAPMD5MSGLIST_SIZE );\n\tzeiger->timestamp = eaptimestamp;\n\tmemcpy(zeiger->ap, macfm, 6);\n\tmemcpy(zeiger->client, macto, 6);\n\tzeiger->type = EAP_CODE_REQ;\n\tzeiger->id = eapmd5->id;\n\tmemcpy(zeiger->md5, eapmd5->md5data, EAPMD5_LEN_MAX);\n\tqsort(eapmd5msglist, EAPMD5MSGLIST_MAX +1, EAPMD5MSGLIST_SIZE, sort_eapmd5msglist_by_timestamp);\n\t}\nelse if(eapcode == EAP_CODE_RESP)\n\t{\n\tzeiger = eapmd5msglist +EAPMD5MSGLIST_MAX;\n\tmemset(zeiger, 0, EAPMD5MSGLIST_SIZE );\n\tzeiger->timestamp = eaptimestamp;\n\tmemcpy(zeiger->ap, macto, 6);\n\tmemcpy(zeiger->client, macfm, 6);\n\tzeiger->type = EAP_CODE_RESP;\n\tzeiger->id = eapmd5->id;\n\tmemcpy(zeiger->md5, eapmd5->md5data, EAPMD5_LEN_MAX);\n\tfor(zeiger = eapmd5msglist; zeiger < eapmd5msglist +EAPMD5MSGLIST_MAX; zeiger++)\n\t\t{\n\t\tif((zeiger->type) != EAP_CODE_REQ) continue;\n\t\tif((zeiger->id) != eapmd5->id) continue;\n\t\tif(memcmp(zeiger->ap, macto, 6) != 0) continue;\n\t\tif(memcmp(zeiger->client, macfm, 6) != 0) continue;\n\t\taddeapmd5hash(eapmd5->id, zeiger->md5, eapmd5->md5data);\n\t\t}\n\tqsort(eapmd5msglist, EAPMD5MSGLIST_MAX +1, EAPMD5MSGLIST_SIZE, sort_eapmd5msglist_by_timestamp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void hccap2base(unsigned char *in, unsigned char b)\n{\nstatic const char itoa64[65] = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfprintf(fh_pmkideapoljtrdeprecated, \"%c\", (itoa64[in[0] >> 2]));\nfprintf(fh_pmkideapoljtrdeprecated, \"%c\", (itoa64[((in[0] & 0x03) << 4) | (in[1] >> 4)]));\nif(b)\n\t{\n\tfprintf(fh_pmkideapoljtrdeprecated, \"%c\", (itoa64[((in[1] & 0x0f) << 2) | (in[2] >> 6)]));\n\tfprintf(fh_pmkideapoljtrdeprecated, \"%c\", (itoa64[in[2] & 0x3f]));\n\t}\nelse fprintf(fh_pmkideapoljtrdeprecated, \"%c\", (itoa64[((in[1] & 0x0f) << 2)]));\nreturn;\n}\n/*===========================================================================*/\nstatic bool testfaultypmkid(uint8_t *faultypmkid)\n{\nstatic const uint8_t faultypmkid1[4] =\n{\n0x00, 0x00, 0x6e, 0x00\n};\n\nif(memcmp(&faultypmkid1, faultypmkid, 4) == 0)\n\t{\n\tpmkidfaultycount++;\n\treturn true;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic bool testpmkid(uint8_t *testpmk, uint8_t *macsta, uint8_t *macap, uint8_t *pmkid)\n{\nstatic const char *pmkname = \"PMK Name\";\nstatic uint8_t pmkidcalc[64];\n\nmemcpy(pmkidcalc, pmkname, 8);\nmemcpy(&pmkidcalc[8], macap, 6);\nmemcpy(&pmkidcalc[14], macsta, 6);\n\nif(!EVP_MAC_init(ctxhmac, testpmk, 32, paramssha1)) return false;\nif(!EVP_MAC_update(ctxhmac, pmkidcalc, 20)) return false;\nif(!EVP_MAC_final(ctxhmac, pmkidcalc, NULL, 20)) return false;\nif(memcmp(pmkid, pmkidcalc, 16) != 0) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool testeapolpmk(uint8_t *testpmk, uint8_t keyver, uint8_t *macsta, uint8_t *macap, uint8_t *nonceap, uint8_t eapollen, uint8_t *eapolmessage)\n{\nstatic uint8_t *pkeptr;\nstatic wpakey_t *wpakzero, *wpak;\nstatic uint8_t pkedata[102];\nstatic uint8_t eapoltmp[1024];\n\nmemset(eapoltmp, 0, sizeof(eapoltmp));\nmemcpy(eapoltmp, eapolmessage, eapollen);\nwpakzero = (wpakey_t*)(eapoltmp +EAPAUTH_SIZE);\nwpak = (wpakey_t*)(eapolmessage +EAPAUTH_SIZE);\nmemset(wpakzero->keymic, 0, 16);\n\nif((keyver == 1) || (keyver == 2))\n\t{\n\tmemset(&pkedata, 0, sizeof(pkedata));\n\tpkeptr = pkedata;\n\tmemcpy(pkeptr, \"Pairwise key expansion\", 23);\n\tif(memcmp(macap, macsta, 6) < 0)\n\t\t{\n\t\tmemcpy(pkeptr +23, macap, 6);\n\t\tmemcpy(pkeptr +29, macsta, 6);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(pkeptr +23, macsta, 6);\n\t\tmemcpy(pkeptr +29, macap, 6);\n\t\t}\n\tif(memcmp(nonceap, wpak->nonce, 32) < 0)\n\t\t{\n\t\tmemcpy (pkeptr +35, nonceap, 32);\n\t\tmemcpy (pkeptr +67, wpak->nonce, 32);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy (pkeptr +35, wpak->nonce, 32);\n\t\tmemcpy (pkeptr +67, nonceap, 32);\n\t\t}\n\tif(!EVP_MAC_init(ctxhmac, testpmk, 32, paramssha1)) return false;\n\tif(!EVP_MAC_update(ctxhmac, pkedata, 100)) return false;\n\tif(!EVP_MAC_final(ctxhmac, pkedata, NULL, 100)) return false;\n\tif(keyver == 2)\n\t\t{\n\t\tif(!EVP_MAC_init(ctxhmac, pkedata, 16, paramssha1)) return false;\n\t\tif(!EVP_MAC_update(ctxhmac, eapoltmp, eapollen)) return false;\n\t\tif(!EVP_MAC_final(ctxhmac, eapoltmp, NULL, eapollen)) return false;\n\t\t}\n\tif(keyver == 1)\n\t\t{\n\t\tif(!EVP_MAC_init(ctxhmac, pkedata, 16, paramsmd5)) return false;\n\t\tif(!EVP_MAC_update(ctxhmac, eapoltmp, eapollen)) return false;\n\t\tif(!EVP_MAC_final(ctxhmac, eapoltmp, NULL, eapollen)) return false;\n\t\t}\n\t}\nelse if(keyver == 3)\n\t{\n\tmemset(&pkedata, 0, sizeof(pkedata));\n\tpkedata[0] = 1;\n\tpkedata[1] = 0;\n\tpkeptr = pkedata +2;\n\tmemcpy(pkeptr, \"Pairwise key expansion\", 22);\n\tif(memcmp(macap, macsta, 6) < 0)\n\t\t{\n\t\tmemcpy(pkeptr +22, macap, 6);\n\t\tmemcpy(pkeptr +28, macsta, 6);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(pkeptr +22, macsta, 6);\n\t\tmemcpy(pkeptr +28, macap, 6);\n\t\t}\n\tif(memcmp(nonceap, wpak->nonce, 32) < 0)\n\t\t{\n\t\tmemcpy (pkeptr +34, nonceap, 32);\n\t\tmemcpy (pkeptr +66, wpak->nonce, 32);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy (pkeptr +34, wpak->nonce, 32);\n\t\tmemcpy (pkeptr +66, nonceap, 32);\n\t\t}\n\tpkedata[100] = 0x80;\n\tpkedata[101] = 1;\n\tif(!EVP_MAC_init(ctxhmac, testpmk, 32, paramssha256)) return false;\n\tif(!EVP_MAC_update(ctxhmac, pkedata, 102)) return false;\n\tif(!EVP_MAC_final(ctxhmac, pkedata, NULL, 102)) return false;\n\tif(!EVP_MAC_init(ctxcmac, pkedata, 16, paramsaes128)) return false;\n\tif(!EVP_MAC_update(ctxcmac, eapoltmp, eapollen)) return false;\n\tif(!EVP_MAC_final(ctxcmac, eapoltmp, NULL, eapollen)) return false;\n\t}\nif(memcmp(wpak->keymic, eapoltmp, 16) == 0) return true;\nreturn false;\n}\n/*===========================================================================*/\nstatic bool testzeroedpsk(uint8_t essidlen, uint8_t *essid)\n{\nif(PKCS5_PBKDF2_HMAC_SHA1(zeroedpsk, 8, essid, essidlen, 4096, 32, calculatedpmk) == 0) return false;\nreturn true;\n}\n/*===========================================================================*/\n/*\nstatic void getnc(handshakelist_t *zeigerhsakt)\n{\nstatic handshakelist_t *zeigerhs, *zeigerhsold;\n\nzeigerhsold = zeigerhsakt;\nfor(zeigerhs = zeigerhsakt; zeigerhs < handshakelistptr; zeigerhs++)\n\t{\n\tif(memcmp(zeigerhs->ap, zeigerhsold->ap, 6) != 0) return;\n\t\t{\n\t\tzeigerhsakt->status |= zeigerhs->status &0xe0;\n\t\tzeigerhsold->status |= zeigerhs->status &0xe0;\n\t\t}\n\tzeigerhsold = zeigerhs;\n\t}\nreturn;\n}\n*/\n/*===========================================================================*/\nstatic handshakelist_t *gethandshake(maclist_t *zeigermac, handshakelist_t *zeigerhsakt)\n{\nstatic int p;\nstatic handshakelist_t *zeigerhs, *zeigerhsold;\nstatic wpakey_t *wpak, *wpaktemp;\nstatic int i;\nstatic unsigned char *hcpos;\nstatic uint8_t keyvertemp;\nstatic uint8_t eapoltemp[EAPOL_AUTHLEN_MAX];\nstatic hccapx_t hccapx;\nstatic hccap_t hccap;\nstatic time_t tvhs;\n\nstatic char timestringhs[32];\n\nzeigerhsold = NULL;\nfor(zeigerhs = zeigerhsakt; zeigerhs < handshakelistptr; zeigerhs++)\n\t{\n\ttvhs = zeigerhs->timestamp /1000000000;\n\tstrftime(timestringhs, 32, \"%d.%m.%Y %H:%M:%S\", localtime(&tvhs));\n\tif(donotcleanflag == false)\n\t\t{\n\t\tif(memcmp(&mac_broadcast, zeigerhs->client, 6) == 0) continue;\n\t\tif(memcmp(&mac_broadcast, zeigerhs->ap, 6) == 0) continue;\n\t\tif(zeigerhsold != NULL)\n\t\t\t{\n\t\t\tif((memcmp(zeigerhs->ap, zeigerhsold->ap, 6) == 0) && (memcmp(zeigerhs->client, zeigerhsold->client, 6) == 0)) continue;\n\t\t\t}\n\t\t}\n\tif(memcmp(zeigermac->addr, zeigerhs->ap, 6) == 0)\n\t\t{\n\t\teapolmpbestcount++;\n\t\tif((zeigerhs->status &ST_APLESS) == ST_APLESS) eapolaplesscount++;\n\t\tif((zeigerhs->status &7) == ST_M12E2) eapolm12e2count++;\n\t\tif((zeigerhs->status &7) == ST_M14E4) eapolm14e4count++;\n\t\tif((zeigerhs->status &7) == ST_M32E2) eapolm32e2count++;\n\t\tif((zeigerhs->status &7) == ST_M32E3)\n\t\t\t{\n\t\t\tzeigerhs->status = (zeigerhs->status & 0x07) + 0x10;\n\t\t\teapolm32e3count++;\n\t\t\t}\n\t\tif((zeigerhs->status &7) == ST_M34E3)\n\t\t\t{\n\t\t\tzeigerhs->status = (zeigerhs->status & 0x07) + 0x10;\n\t\t\teapolm34e3count++;\n\t\t\t}\n\t\tif((zeigerhs->status &7) == ST_M34E4) eapolm34e4count++;\n\t\tif((zeigerhs->status & ST_ENDIANESS) != 0)\n\t\t\t{\n\t\t\tzeigerhs->status |= 0x80;\n//\t\t\tzeigerhs->status &= ~(1 << 7);\n\t\t\t}\n\t\tif((ncvalue > 0) && ((zeigerhs->status & 0x10) == 0)) zeigerhs->status |= 0x80;\n\n\n\t\twpak = (wpakey_t*)(zeigerhs->eapol +EAPAUTH_SIZE);\n\t\tkeyvertemp = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\t\tmemcpy(&eapoltemp, zeigerhs->eapol, zeigerhs->eapauthlen);\n\t\twpaktemp = (wpakey_t*)(eapoltemp +EAPAUTH_SIZE);\n\t\tmemset(wpaktemp->keymic, 0, 16);\n\t\tif(donotcleanflag == false)\n\t\t\t{\n\t\t\tif(testzeroedpsk(zeigermac->essidlen, zeigermac->essid) == true)\n\t\t\t\t{\n\t\t\t\tif(testeapolpmk(calculatedpmk, keyvertemp, zeigerhs->client, zeigerhs->ap, zeigerhs->anonce, zeigerhs->eapauthlen, zeigerhs->eapol) == true)\n\t\t\t\t\t{\n\t\t\t\t\tzeroedeapolpskcount++;\n\t\t\t\t\teapolmpbestcount--;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(fh_pmkideapol != 0)\n\t\t\t{\n\t\t\t//WPA*TYPE*PMKID-ODER-MIC*MACAP*MACSTA*ESSID_HEX*ANONCE*EAPOL*MP\n\t\t\tfprintf(fh_pmkideapol, \"WPA*%02d*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\t\t\tHCX_TYPE_EAPOL,\n\t\t\t\twpak->keymic[0], wpak->keymic[1], wpak->keymic[2], wpak->keymic[3], wpak->keymic[4], wpak->keymic[5], wpak->keymic[6], wpak->keymic[7],\n\t\t\t\twpak->keymic[8], wpak->keymic[9], wpak->keymic[10], wpak->keymic[11], wpak->keymic[12], wpak->keymic[13], wpak->keymic[14], wpak->keymic[15],\n\t\t\t\tzeigerhs->ap[0], zeigerhs->ap[1], zeigerhs->ap[2], zeigerhs->ap[3], zeigerhs->ap[4], zeigerhs->ap[5],\n\t\t\t\tzeigerhs->client[0], zeigerhs->client[1], zeigerhs->client[2], zeigerhs->client[3], zeigerhs->client[4], zeigerhs->client[5]);\n\t\t\tfor(p = 0; p < zeigermac->essidlen; p++) fprintf(fh_pmkideapol, \"%02x\", zeigermac->essid[p]);\n\t\t\tfprintf(fh_pmkideapol, \"*\");\n\t\t\tfprintf(fh_pmkideapol, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*\",\n\t\t\t\tzeigerhs->anonce[0], zeigerhs->anonce[1], zeigerhs->anonce[2], zeigerhs->anonce[3], zeigerhs->anonce[4], zeigerhs->anonce[5], zeigerhs->anonce[6], zeigerhs->anonce[7],\n\t\t\t\tzeigerhs->anonce[8], zeigerhs->anonce[9], zeigerhs->anonce[10], zeigerhs->anonce[11], zeigerhs->anonce[12], zeigerhs->anonce[13], zeigerhs->anonce[14], zeigerhs->anonce[15],\n\t\t\t\tzeigerhs->anonce[16], zeigerhs->anonce[17], zeigerhs->anonce[18], zeigerhs->anonce[19], zeigerhs->anonce[20], zeigerhs->anonce[21], zeigerhs->anonce[22], zeigerhs->anonce[23],\n\t\t\t\tzeigerhs->anonce[24], zeigerhs->anonce[25], zeigerhs->anonce[26], zeigerhs->anonce[27], zeigerhs->anonce[28], zeigerhs->anonce[29], zeigerhs->anonce[30], zeigerhs->anonce[31]);\n\t\t\tfor(p = 0; p < zeigerhs->eapauthlen; p++) fprintf(fh_pmkideapol, \"%02x\", eapoltemp[p]);\n\t\t\tif(addtimestampflag == false) fprintf(fh_pmkideapol, \"*%02x\\n\", zeigerhs->status);\n\t\t\telse fprintf(fh_pmkideapol, \"*%02x\\t%s\\t%\" PRIu64 \"\\n\", zeigerhs->status, timestringhs, zeigerhs->timestampgap);\n\t\t\tif(zeigerhs->rcgap == 0) eapolwrittencount++;\n\t\t\telse eapolncwrittencount++;\n\t\t\t}\n\t\tif((fh_pmkideapoljtrdeprecated != 0) && (zeigerhs->rcgap == 0))\n\t\t\t{\n\t\t\tmemset (&hccap, 0, sizeof(hccap_t));\n\t\t\tmemcpy(&hccap.ap, zeigerhs->ap, 6);\n\t\t\tmemcpy(&hccap.client, zeigerhs->client, 6);\n\t\t\tmemcpy(&hccap.anonce, zeigerhs->anonce, 32);\n\t\t\tmemcpy(&hccap.snonce, wpak->nonce, 32);\n\t\t\tmemcpy(&hccap.keymic, &wpak->keymic, 16);\n\t\t\thccap.keyver = keyvertemp;\n\t\t\thccap.eapol_size = zeigerhs->eapauthlen;\n\t\t\tmemcpy(&hccap.eapol, &eapoltemp, zeigerhs->eapauthlen);\n\t\t\t#ifdef BIG_ENDIAN_HOST\n\t\t\thccap.eapol_size = byte_swap_16(hccap.eapol_size);\n\t\t\t#endif\n\t\t\tfprintf(fh_pmkideapoljtrdeprecated, \"%.*s:$WPAPSK$%.*s#\", zeigermac->essidlen, zeigermac->essid, zeigermac->essidlen, zeigermac->essid);\n\t\t\thcpos = (unsigned char*)&hccap;\n\t\t\tfor (i = 36; i + 3 < (int)HCCAP_SIZE; i += 3) hccap2base(&hcpos[i], 1);\n\t\t\thccap2base(&hcpos[i], 0);\n\t\t\tfprintf(fh_pmkideapoljtrdeprecated, \":%02x-%02x-%02x-%02x-%02x-%02x:%02x-%02x-%02x-%02x-%02x-%02x:%02x%02x%02x%02x%02x%02x\",\n\t\t\t\tzeigerhs->client[0], zeigerhs->client[1], zeigerhs->client[2], zeigerhs->client[3], zeigerhs->client[4], zeigerhs->client[5],\n\t\t\t\tzeigerhs->ap[0], zeigerhs->ap[1], zeigerhs->ap[2], zeigerhs->ap[3], zeigerhs->ap[4], zeigerhs->ap[5],\n\t\t\t\tzeigerhs->ap[0], zeigerhs->ap[1], zeigerhs->ap[2], zeigerhs->ap[3], zeigerhs->ap[4], zeigerhs->ap[5]);\n\t\t\tif(keyvertemp == 1) fprintf(fh_pmkideapoljtrdeprecated, \"::WPA\");\n\t\t\telse fprintf(fh_pmkideapoljtrdeprecated, \"::WPA2\");\n\t\t\tif((zeigerhs->status &0x7) == 0) fprintf(fh_pmkideapoljtrdeprecated, \":not verified\");\n\t\t\telse fprintf(fh_pmkideapoljtrdeprecated, \":verified\");\n\t\t\tfprintf(fh_pmkideapoljtrdeprecated, \":%s\\n\", basename(jtrbasenamedeprecated));\n\t\t\teapolwrittenjcountdeprecated++;\n\t\t\t}\n\t\tif(fh_hccapxdeprecated != 0)\n\t\t\t{\n\t\t\tmemset (&hccapx, 0, sizeof(hccapx_t));\n\t\t\thccapx.signature = HCCAPX_SIGNATURE;\n\t\t\thccapx.version = HCCAPX_VERSION;\n\t\t\thccapx.message_pair = zeigerhs->status;\n\t\t\thccapx.essid_len = zeigermac->essidlen;\n\t\t\tmemcpy(&hccapx.essid, zeigermac->essid, zeigermac->essidlen);\n\t\t\tmemcpy(&hccapx.ap, zeigerhs->ap, 6);\n\t\t\tmemcpy(&hccapx.client, zeigerhs->client, 6);\n\t\t\tmemcpy(&hccapx.anonce, zeigerhs->anonce, 32);\n\t\t\tmemcpy(&hccapx.snonce, wpak->nonce, 32);\n\t\t\thccapx.eapol_len = zeigerhs->eapauthlen;\n\t\t\tmemcpy(&hccapx.eapol, &eapoltemp, zeigerhs->eapauthlen);\n\t\t\thccapx.keyver = keyvertemp;\n\t\t\tmemcpy(&hccapx.keymic, wpak->keymic, 16);\n\t\t\t#ifdef BIG_ENDIAN_HOST\n\t\t\thccapx.signature = byte_swap_32(hccapx.signature);\n\t\t\thccapx.version = byte_swap_32(hccapx.version);\n\t\t\thccapx.eapol_len = byte_swap_16(hccapx.eapol_len);\n\t\t\t#endif\n\t\t\tfwrite (&hccapx, sizeof(hccapx_t), 1, fh_hccapxdeprecated);\n\t\t\tif(zeigerhs->rcgap == 0) eapolwrittenhcpxcountdeprecated++;\n\t\t\telse eapolncwrittenhcpxcountdeprecated++;\n\t\t\t}\n\t\tif((fh_hccapdeprecated != 0) && (zeigerhs->rcgap == 0))\n\t\t\t{\n\t\t\tmemset(&hccap, 0, sizeof(hccap_t));\n\t\t\tmemcpy(&hccap.essid, zeigermac->essid, zeigermac->essidlen);\n\t\t\tmemcpy(&hccap.ap, zeigerhs->ap, 6);\n\t\t\tmemcpy(&hccap.client, zeigerhs->client, 6);\n\t\t\tmemcpy(&hccap.anonce, zeigerhs->anonce, 32);\n\t\t\tmemcpy(&hccap.snonce, wpak->nonce, 32);\n\t\t\tmemcpy(&hccap.keymic, wpak->keymic, 16);\n\t\t\thccap.keyver = keyvertemp;\n\t\t\thccap.eapol_size = zeigerhs->eapauthlen;\n\t\t\tmemcpy(&hccap.eapol, &eapoltemp, zeigerhs->eapauthlen);\n\t\t\t#ifdef BIG_ENDIAN_HOST\n\t\t\thccap.eapol_size = byte_swap_16(hccap.eapol_size);\n\t\t\t#endif\n\t\t\tfwrite(&hccap, HCCAP_SIZE, 1, fh_hccapdeprecated);\n\t\t\teapolwrittenhcpcountdeprecated++;\n\t\t\t}\n\t\t}\n\tif(memcmp(zeigerhs->ap, zeigermac->addr, 6) > 0)\n\t\t{\n\t\tzeigerhsakt = zeigerhs;\n\t\treturn zeigerhsakt;\n\t\t}\n\tzeigerhsold = zeigerhs;\n\t}\nreturn zeigerhsakt;\n}\n/*===========================================================================*/\nstatic pmkidlist_t *getpmkid(maclist_t *zeigermac, pmkidlist_t *zeigerpmkidakt)\n{\nstatic int p;\nstatic pmkidlist_t *zeigerpmkid, *zeigerpmkidold;\nstatic time_t tvhs;\nstatic char timestringhs[32];\n\nzeigerpmkidold = NULL;\nfor(zeigerpmkid = zeigerpmkidakt; zeigerpmkid < pmkidlistptr; zeigerpmkid++)\n\t{\n\ttvhs = zeigerpmkid->timestamp /1000000000;\n\tstrftime(timestringhs, 32, \"%d.%m.%Y %H:%M:%S\", localtime(&tvhs));\n\tif(((zeigerpmkid->status &PMKID_APPSK256) == PMKID_APPSK256) && ((zeigermac->akm &TAK_PSKSHA256) != TAK_PSKSHA256))\n\t\t{\n\t\tif(ignoreieflag == false) continue;\n\t\t}\n\tif(donotcleanflag == false)\n\t\t{\n\t\tif(memcmp(&mac_broadcast, zeigerpmkid->client, 6) == 0) continue;\n\t\tif(memcmp(&mac_broadcast, zeigerpmkid->ap, 6) == 0) continue;\n\t\tif(zeigerpmkidold != NULL)\n\t\t\t{\n\t\t\tif((memcmp(zeigerpmkid->ap, zeigerpmkidold->ap, 6) == 0) && (memcmp(zeigerpmkid->client, zeigerpmkidold->client, 6) == 0)) continue;\n\t\t\t}\n\t\t}\n\tif(memcmp(zeigermac->addr, zeigerpmkid->ap, 6) == 0)\n\t\t{\n\t\tif(donotcleanflag == false)\n\t\t\t{\n\t\t\tif(testzeroedpsk(zeigermac->essidlen, zeigermac->essid) == true)\n\t\t\t\t{\n\t\t\t\tif(testpmkid(calculatedpmk, zeigerpmkid->client, zeigerpmkid->ap, zeigerpmkid->pmkid) == true)\n\t\t\t\t\t{\n\t\t\t\t\tzeroedpmkidpskcount++;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(memcmp(&myaktclient, zeigerpmkid->client, 6) == 0) pmkidroguecount++;\n\t\tpmkidbestcount++;\n\t\tif(fh_pmkideapol != 0)\n\t\t\t{\n\t\t\t//WPA*TYPE*PMKID-ODER-MIC*MACAP*MACSTA*ESSID_HEX*ANONCE*EAPOL*MP\n\t\t\tfprintf(fh_pmkideapol, \"WPA*%02d*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\t\t\tHCX_TYPE_PMKID,\n\t\t\t\tzeigerpmkid->pmkid[0], zeigerpmkid->pmkid[1], zeigerpmkid->pmkid[2], zeigerpmkid->pmkid[3], zeigerpmkid->pmkid[4], zeigerpmkid->pmkid[5], zeigerpmkid->pmkid[6], zeigerpmkid->pmkid[7],\n\t\t\t\tzeigerpmkid->pmkid[8], zeigerpmkid->pmkid[9], zeigerpmkid->pmkid[10], zeigerpmkid->pmkid[11], zeigerpmkid->pmkid[12], zeigerpmkid->pmkid[13], zeigerpmkid->pmkid[14], zeigerpmkid->pmkid[15],\n\t\t\t\tzeigerpmkid->ap[0], zeigerpmkid->ap[1], zeigerpmkid->ap[2], zeigerpmkid->ap[3], zeigerpmkid->ap[4], zeigerpmkid->ap[5],\n\t\t\t\tzeigerpmkid->client[0], zeigerpmkid->client[1], zeigerpmkid->client[2], zeigerpmkid->client[3], zeigerpmkid->client[4], zeigerpmkid->client[5]);\n\t\t\tfor(p = 0; p < zeigermac->essidlen; p++) fprintf(fh_pmkideapol, \"%02x\", zeigermac->essid[p]);\n\t\t\tif(addtimestampflag == false) fprintf(fh_pmkideapol, \"***%02x\\n\", zeigerpmkid->status);\n\t\t\telse fprintf(fh_pmkideapol, \"***%02x\\t%s\\n\",  zeigerpmkid->status, timestringhs);\n\t\t\tpmkidwrittenhcount++;\n\t\t\t}\n\t\tif((fh_pmkideapolclient != 0) && ((zeigerpmkid->status & PMKID_CLIENT) == PMKID_CLIENT))\n\t\t\t{\n\t\t\t//WPA*TYPE*PMKID-ODER-MIC*MACAP*MACSTA*ESSID_HEX*ANONCE*EAPOL*MP\n\t\t\tfprintf(fh_pmkideapolclient, \"WPA*%02d*%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\t\t\tHCX_TYPE_PMKID,\n\t\t\t\tzeigerpmkid->pmkid[0], zeigerpmkid->pmkid[1], zeigerpmkid->pmkid[2], zeigerpmkid->pmkid[3], zeigerpmkid->pmkid[4], zeigerpmkid->pmkid[5], zeigerpmkid->pmkid[6], zeigerpmkid->pmkid[7],\n\t\t\t\tzeigerpmkid->pmkid[8], zeigerpmkid->pmkid[9], zeigerpmkid->pmkid[10], zeigerpmkid->pmkid[11], zeigerpmkid->pmkid[12], zeigerpmkid->pmkid[13], zeigerpmkid->pmkid[14], zeigerpmkid->pmkid[15],\n\t\t\t\tzeigerpmkid->ap[0], zeigerpmkid->ap[1], zeigerpmkid->ap[2], zeigerpmkid->ap[3], zeigerpmkid->ap[4], zeigerpmkid->ap[5],\n\t\t\t\tzeigerpmkid->client[0], zeigerpmkid->client[1], zeigerpmkid->client[2], zeigerpmkid->client[3], zeigerpmkid->client[4], zeigerpmkid->client[5]);\n\t\t\tfor(p = 0; p < zeigermac->essidlen; p++) fprintf(fh_pmkideapolclient, \"%02x\", zeigermac->essid[p]);\n\t\t\tif(addtimestampflag == false) fprintf(fh_pmkideapolclient, \"***%02x\\n\",  zeigerpmkid->status & PMKID_CLIENT);\n\t\t\telse fprintf(fh_pmkideapolclient, \"***%02x\\t%s\\n\",  zeigerpmkid->status, timestringhs);\n\t\t\tpmkidclientwrittenhcount++;\n\t\t\t}\n\t\tif(fh_pmkideapoljtrdeprecated != 0)\n\t\t\t{\n\t\t\tfprintf(fh_pmkideapoljtrdeprecated, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\t\t\tzeigerpmkid->pmkid[0], zeigerpmkid->pmkid[1], zeigerpmkid->pmkid[2], zeigerpmkid->pmkid[3], zeigerpmkid->pmkid[4], zeigerpmkid->pmkid[5], zeigerpmkid->pmkid[6], zeigerpmkid->pmkid[7],\n\t\t\t\tzeigerpmkid->pmkid[8], zeigerpmkid->pmkid[9], zeigerpmkid->pmkid[10], zeigerpmkid->pmkid[11], zeigerpmkid->pmkid[12], zeigerpmkid->pmkid[13], zeigerpmkid->pmkid[14], zeigerpmkid->pmkid[15],\n\t\t\t\tzeigerpmkid->ap[0], zeigerpmkid->ap[1], zeigerpmkid->ap[2], zeigerpmkid->ap[3], zeigerpmkid->ap[4], zeigerpmkid->ap[5],\n\t\t\t\tzeigerpmkid->client[0], zeigerpmkid->client[1], zeigerpmkid->client[2], zeigerpmkid->client[3], zeigerpmkid->client[4], zeigerpmkid->client[5]);\n\t\t\tfor(p = 0; p < zeigermac->essidlen; p++) fprintf(fh_pmkideapoljtrdeprecated, \"%02x\", zeigermac->essid[p]);\n\t\t\tfprintf(fh_pmkideapoljtrdeprecated, \"\\n\");\n\t\t\tpmkidwrittenjcountdeprecated++;\n\t\t\t}\n\t\tif(fh_pmkiddeprecated != 0)\n\t\t\t{\n\t\t\tfprintf(fh_pmkiddeprecated, \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*%02x%02x%02x%02x%02x%02x*\",\n\t\t\t\tzeigerpmkid->pmkid[0], zeigerpmkid->pmkid[1], zeigerpmkid->pmkid[2], zeigerpmkid->pmkid[3], zeigerpmkid->pmkid[4], zeigerpmkid->pmkid[5], zeigerpmkid->pmkid[6], zeigerpmkid->pmkid[7],\n\t\t\t\tzeigerpmkid->pmkid[8], zeigerpmkid->pmkid[9], zeigerpmkid->pmkid[10], zeigerpmkid->pmkid[11], zeigerpmkid->pmkid[12], zeigerpmkid->pmkid[13], zeigerpmkid->pmkid[14], zeigerpmkid->pmkid[15],\n\t\t\t\tzeigerpmkid->ap[0], zeigerpmkid->ap[1], zeigerpmkid->ap[2], zeigerpmkid->ap[3], zeigerpmkid->ap[4], zeigerpmkid->ap[5],\n\t\t\t\tzeigerpmkid->client[0], zeigerpmkid->client[1], zeigerpmkid->client[2], zeigerpmkid->client[3], zeigerpmkid->client[4], zeigerpmkid->client[5]);\n\t\t\tfor(p = 0; p < zeigermac->essidlen; p++) fprintf(fh_pmkiddeprecated, \"%02x\", zeigermac->essid[p]);\n\t\t\tfprintf(fh_pmkiddeprecated, \"\\n\");\n\t\t\tpmkidwrittencountdeprecated++;\n\t\t\t}\n\t\t}\n\tif(memcmp(zeigerpmkid->ap, zeigermac->addr, 6) > 0)\n\t\t{\n\t\tzeigerpmkidakt = zeigerpmkid;\n\t\treturn zeigerpmkidakt;\n\t\t}\n\tzeigerpmkidold = zeigerpmkid;\n\t}\nreturn zeigerpmkidakt;\n}\n/*===========================================================================*/\nstatic void outputwpalists(void)\n{\nstatic maclist_t *zeigermac, *zeigermacold;\nstatic handshakelist_t *zeigerhsakt;\nstatic pmkidlist_t *zeigerpmkidakt;\nstatic int essiddupecount;\n\nqsort(aplist, aplistptr -aplist, MACLIST_SIZE, sort_maclist_by_mac_count);\nqsort(pmkidlist, pmkidlistptr -pmkidlist, PMKIDLIST_SIZE, sort_pmkidlist_by_mac);\nif(ncvalue == 0) qsort(handshakelist, handshakelistptr -handshakelist, HANDSHAKELIST_SIZE, sort_handshakelist_by_timegap);\nelse qsort(handshakelist, handshakelistptr -handshakelist, HANDSHAKELIST_SIZE, sort_handshakelist_by_rcgap);\n\nzeigerhsakt = handshakelist;\nzeigerpmkidakt = pmkidlist;\nzeigermacold = aplist;\n\nif((zeigermacold->type & AP) == AP)\n\t{\n\tif(zeigermacold->essidlen != 0)\n\t\t{\n\t\tif(ignoreieflag == true)\n\t\t\t{\n\t\t\tzeigerpmkidakt = getpmkid(zeigermacold, zeigerpmkidakt);\n\t\t\tzeigerhsakt = gethandshake(zeigermacold, zeigerhsakt);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif(((zeigermacold->akm &TAK_PSK) == TAK_PSK) || ((zeigermacold->akm &TAK_PSKSHA256) == TAK_PSKSHA256))\n\t\t\t\t{\n\t\t\t\tzeigerpmkidakt = getpmkid(zeigermacold, zeigerpmkidakt);\n\t\t\t\tzeigerhsakt = gethandshake(zeigermacold, zeigerhsakt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nessiddupecount = 0;\nfor(zeigermac = aplist +1; zeigermac < aplistptr; zeigermac++)\n\t{\n\tif(zeigermac->essidlen == 0) continue;\n\tif((zeigermac->type & AP) != AP)\n\t\t{\n\t\tessiddupecount = 0;\n\t\tcontinue;\n\t\t}\n\tif((zeigermacold->type & AP) == AP)\n\t\t{\n\t\tif(memcmp(zeigermacold->addr, zeigermac->addr, 6) == 0)\n\t\t\t{\n\t\t\tessiddupecount++;\n\t\t\tif(essiddupecount >= essiddupemax) essiddupemax = essiddupecount;\n\t\t\tif(essiddupecount >= essidsvalue) continue;\n\t\t\t}\n\t\telse essiddupecount = 0;\n\t\t}\n\tif(ignoreieflag == true)\n\t\t{\n\t\tzeigerpmkidakt = getpmkid(zeigermac, zeigerpmkidakt);\n\t\tzeigerhsakt = gethandshake(zeigermac, zeigerhsakt);\n\t\t}\n\telse\n\t\t{\n\t\tif(((zeigermac->akm &TAK_PSK) == TAK_PSK) || ((zeigermac->akm &TAK_PSKSHA256) == TAK_PSKSHA256))\n\t\t\t{\n\t\t\tzeigerpmkidakt = getpmkid(zeigermac, zeigerpmkidakt);\n\t\t\tzeigerhsakt = gethandshake(zeigermac, zeigerhsakt);\n\t\t\t}\n\t\t}\n\tzeigermacold = zeigermac;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void cleanupmac(void)\n{\nstatic maclist_t *zeiger;\nstatic maclist_t *zeigerold;\n\nif(aplistptr == aplist) return;\nqsort(aplist, aplistptr -aplist, MACLIST_SIZE, sort_maclist_by_mac);\nzeigerold = aplist;\nfor(zeiger = aplist +1; zeiger < aplistptr; zeiger++)\n\t{\n\tif(memcmp(zeigerold->addr, zeiger->addr, 6) == 0)\n\t\t{\n\t\tif(zeigerold->essidlen == zeiger->essidlen)\n\t\t\t{\n\t\t\tif(memcmp(zeigerold->essid, zeiger->essid, zeigerold->essidlen) == 0)\n\t\t\t\t{\n\t\t\t\tzeigerold->timestamp = zeiger->timestamp;\n\t\t\t\tzeigerold->type |= zeiger->type;\n\t\t\t\tzeigerold->status |= zeiger->status;\n\t\t\t\tzeigerold->count += 1;\n\t\t\t\tzeigerold->groupcipher |= zeiger->groupcipher;\n\t\t\t\tzeigerold->cipher |= zeiger->cipher;\n\t\t\t\tzeigerold->akm |= zeiger->akm;\n\t\t\t\tif(zeigerold->manufacturerlen == 0)\n\t\t\t\t\t{\n\t\t\t\t\tmemcpy(zeigerold->manufacturer, zeiger->manufacturer, zeiger->manufacturerlen);\n\t\t\t\t\tzeigerold->manufacturerlen = zeiger->manufacturerlen;\n\t\t\t\t\t}\n\t\t\t\tif(zeigerold->modellen == 0)\n\t\t\t\t\t{\n\t\t\t\t\tmemcpy(zeigerold->model, zeiger->model, zeiger->modellen);\n\t\t\t\t\tzeigerold->modellen = zeiger->modellen;\n\t\t\t\t\t}\n\t\t\t\tif(zeigerold->serialnumberlen == 0)\n\t\t\t\t\t{\n\t\t\t\t\tmemcpy(zeigerold->serialnumber, zeiger->serialnumber, zeiger->serialnumberlen);\n\t\t\t\t\tzeigerold->serialnumberlen = zeiger->serialnumberlen;\n\t\t\t\t\t}\n\t\t\t\tif(zeigerold->devicenamelen == 0)\n\t\t\t\t\t{\n\t\t\t\t\tmemcpy(zeigerold->devicename, zeiger->devicename, zeiger->devicenamelen);\n\t\t\t\t\tzeigerold->devicenamelen = zeiger->devicenamelen;\n\t\t\t\t\t}\n\t\t\t\tif(zeigerold->enrolleelen == 0)\n\t\t\t\t\t{\n\t\t\t\t\tmemcpy(zeigerold->enrollee, zeiger->enrollee, zeiger->enrolleelen);\n\t\t\t\t\tzeigerold->enrolleelen = zeiger->enrolleelen;\n\t\t\t\t\t}\n\t\t\t\tzeiger->type = REMOVED;\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tzeigerold = zeiger;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic bool cleanbackhandshake(void)\n{\nstatic int c;\nstatic handshakelist_t *zeiger;\nreturn false;\n\nif(donotcleanflag == true) return false;\n\nfor(c = 0; c < 20; c ++)\n\t{\n\tzeiger--;\n\tif(zeiger < handshakelist) return false;\n\tif(memcmp(zeiger->ap, handshakelistptr->ap, 6) != 0) continue;\n\tif(memcmp(zeiger->client, handshakelistptr->client, 6) != 0) continue;\n\tif(memcmp(zeiger->anonce, handshakelistptr->anonce, 32) != 0) continue;\n\tif(zeiger->eapauthlen != handshakelistptr->eapauthlen) continue;\n\tif(memcmp(zeiger->eapol, handshakelistptr->eapol, handshakelistptr->eapauthlen) != 0) continue;\n\tif(zeiger->timestampgap > handshakelistptr->timestampgap) zeiger->timestampgap = handshakelistptr->timestampgap;\n\tif(zeiger->rcgap > handshakelistptr->rcgap) zeiger->rcgap = (zeiger->rcgap &0xe0) | handshakelistptr->rcgap;\n\tif(zeiger->status < handshakelistptr->status) zeiger->status = handshakelistptr->status;\n\tzeiger->messageap |= handshakelistptr->messageap;\n\tzeiger->messageclient |= handshakelistptr->messageclient;\n\tzeiger->timestamp |= handshakelistptr->timestamp;\n\treturn true;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic void addhandshake(uint64_t eaptimegap, uint64_t rcgap, messagelist_t *msgclient, messagelist_t *msgap, uint8_t keyver, uint8_t mpfield)\n{\nstatic handshakelist_t *handshakelistnew;\nstatic messagelist_t *zeiger;\n\neapolmpcount++;\nif((mpfield &ST_APLESS) != ST_APLESS)\n\t{\n\tfor(zeiger = messagelist; zeiger < messagelist +MESSAGELIST_MAX; zeiger++)\n\t\t{\n\t\tif((zeiger->status &ST_APLESS) != ST_APLESS)\n\t\t\t{\n\t\t\tif(memcmp(msgap->ap, zeiger->ap, 6) == 0) mpfield |= zeiger->status & 0xe0;\n\t\t\t}\n\t\t}\n\t}\nif(msgap->timestamp == msgclient->timestamp) eapolmsgtimestamperrorcount++;\nif(testeapolpmk(zeroedpmk, keyver, msgclient->client, msgap->ap, msgap->nonce, msgclient->eapauthlen, msgclient->eapol) == false)\n\t{\n\tif(handshakelistptr >= handshakelist +handshakelistmax)\n\t\t{\n\t\thandshakelistnew = (handshakelist_t*)realloc(handshakelist, (handshakelistmax +HANDSHAKELIST_MAX) *HANDSHAKELIST_SIZE);\n\t\tif(handshakelistnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\thandshakelist = handshakelistnew;\n\t\thandshakelistptr = handshakelistnew +handshakelistmax;\n\t\thandshakelistmax += HANDSHAKELIST_MAX;\n\t\t}\n\tmemset(handshakelistptr, 0, HANDSHAKELIST_SIZE);\n\thandshakelistptr->timestampgap = eaptimegap;\n\thandshakelistptr->status = mpfield;\n\thandshakelistptr->rcgap = rcgap;\n\tif(handshakelistptr->rcgap > 0)\n\t\t{\n\t\tif((handshakelistptr->status & ST_ENDIANESS) == 0) handshakelistptr->status |= ST_NC;\n\t\t}\n\thandshakelistptr->messageap = msgap->message;\n\thandshakelistptr->messageclient = msgclient->message;\n\tmemcpy(handshakelistptr->ap, msgap->ap, 6);\n\tmemcpy(handshakelistptr->client, msgclient->client, 6);\n\tmemcpy(handshakelistptr->pmkid, msgap->pmkid, 32);\n\tif((msgap->eapauthlen != 0) && (((mpfield &ST_M32E3) == ST_M32E3) || ((mpfield &ST_M34E3) == ST_M34E3)))\n\t\t{\n\t\tmemcpy(handshakelistptr->anonce, msgclient->nonce, 32);\n\t\thandshakelistptr->eapauthlen = msgap->eapauthlen;\n\t\tmemcpy(handshakelistptr->eapol, msgap->eapol, msgap->eapauthlen);\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(handshakelistptr->anonce, msgap->nonce, 32);\n\t\thandshakelistptr->eapauthlen = msgclient->eapauthlen;\n\t\tmemcpy(handshakelistptr->eapol, msgclient->eapol, msgclient->eapauthlen);\n\t\t}\n\thandshakelistptr->timestamp = msgclient->timestamp;\n\tif(cleanbackhandshake() == false) handshakelistptr++;\n\t}\nelse\n\t{\n\tzeroedeapolpmkcount++;\n\tif(donotcleanflag == true)\n\t\t{\n\t\tif(handshakelistptr >= handshakelist +handshakelistmax)\n\t\t\t{\n\t\t\thandshakelistnew = (handshakelist_t*)realloc(handshakelist, (handshakelistmax +HANDSHAKELIST_MAX) *HANDSHAKELIST_SIZE);\n\t\t\tif(handshakelistnew == NULL)\n\t\t\t\t{\n\t\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\thandshakelist = handshakelistnew;\n\t\t\thandshakelistptr = handshakelistnew +handshakelistmax;\n\t\t\thandshakelistmax += HANDSHAKELIST_MAX;\n\t\t\t}\n\t\tmemset(handshakelistptr, 0, HANDSHAKELIST_SIZE);\n\t\thandshakelistptr->timestampgap = eaptimegap;\n\t\thandshakelistptr->status = mpfield;\n\t\thandshakelistptr->rcgap = rcgap;\n\t\tif(handshakelistptr->rcgap > 0)\n\t\t\t{\n\t\t\tif((handshakelistptr->status & ST_ENDIANESS) == 0) handshakelistptr->status |= ST_NC;\n\t\t\t}\n\t\thandshakelistptr->messageap = msgap->message;\n\t\thandshakelistptr->messageclient = msgclient->message;\n\t\tmemcpy(handshakelistptr->ap, msgap->ap, 6);\n\t\tmemcpy(handshakelistptr->client, msgclient->client, 6);\n\t\tmemcpy(handshakelistptr->anonce, msgap->nonce, 32);\n\t\tmemcpy(handshakelistptr->pmkid, msgap->pmkid, 32);\n\t\tif(mpfield != ST_M32E3)\n\t\t\t{\n\t\t\tmemcpy(handshakelistptr->anonce, msgap->nonce, 32);\n\t\t\thandshakelistptr->eapauthlen = msgclient->eapauthlen;\n\t\t\tmemcpy(handshakelistptr->eapol, msgclient->eapol, msgclient->eapauthlen);\n\t\t\t}\n\t\telse if(msgap->eapauthlen != 0)\n\t\t\t{\n\t\t\tmemcpy(handshakelistptr->anonce, msgclient->nonce, 32);\n\t\t\thandshakelistptr->eapauthlen = msgap->eapauthlen;\n\t\t\tmemcpy(handshakelistptr->eapol, msgap->eapol, msgap->eapauthlen);\n\t\t\t}\n\t\thandshakelistptr->timestamp = msgclient->timestamp;\n\t\tif(cleanbackhandshake() == false) handshakelistptr++;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic bool cleanbackpmkid(void)\n{\nstatic int c;\nstatic pmkidlist_t *zeiger;\n\nif(donotcleanflag == true) return false;\nzeiger = pmkidlistptr;\nfor(c = 0; c < 20; c ++)\n\t{\n\tzeiger--;\n\tif(zeiger < pmkidlist) return false;\n\tif(memcmp(zeiger->ap, pmkidlistptr->ap, 6) != 0) continue;\n\tif(memcmp(zeiger->client, pmkidlistptr->client, 6) != 0) continue;\n\tif(memcmp(zeiger->pmkid, pmkidlistptr->pmkid, 16) != 0) continue;\n\tzeiger->status |= pmkidlistptr->status;\n\treturn true;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic void addpmkid(uint64_t timestamp, uint8_t *macclient, uint8_t *macap, uint8_t *pmkid, uint8_t pmkidstatus)\n{\nstatic pmkidlist_t *pmkidlistnew;\n\npmkidcount++;\nif((pmkidstatus & PMKID_CLIENT) == PMKID_CLIENT)\n\t{\n\tif(testfaultypmkid(pmkid) == true) return;\n\t}\nif(testpmkid(zeroedpmk, macclient, macap, pmkid) == false)\n\t{\n\tif(pmkidlistptr >= pmkidlist +pmkidlistmax)\n\t\t{\n\t\tpmkidlistnew = (pmkidlist_t*)realloc(pmkidlist, (pmkidlistmax +PMKIDLIST_MAX) *PMKIDLIST_SIZE);\n\t\tif(pmkidlistnew == NULL)\n\t\t\t{\n\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tpmkidlist = pmkidlistnew;\n\t\tpmkidlistptr = pmkidlistnew +pmkidlistmax;\n\t\tpmkidlistmax += PMKIDLIST_MAX;\n\t\t}\n\tmemset(pmkidlistptr, 0, PMKIDLIST_SIZE);\n\tmemcpy(pmkidlistptr->ap, macap, 6);\n\tmemcpy(pmkidlistptr->client, macclient, 6);\n\tmemcpy(pmkidlistptr->pmkid, pmkid, 16);\n\tpmkidlistptr->timestamp = timestamp;\n\tpmkidlistptr->status |= pmkidstatus;\n\tif(cleanbackpmkid() == false) pmkidlistptr++;\n\t}\nelse\n\t{\n\tzeroedpmkidpmkcount++;\n\tif(donotcleanflag == true)\n\t\t{\n\t\tif(pmkidlistptr >= pmkidlist +pmkidlistmax)\n\t\t\t{\n\t\t\tpmkidlistnew = (pmkidlist_t*)realloc(pmkidlist, (pmkidlistmax +PMKIDLIST_MAX) *PMKIDLIST_SIZE);\n\t\t\tif(pmkidlistnew == NULL)\n\t\t\t\t{\n\t\t\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\tpmkidlist = pmkidlistnew;\n\t\t\tpmkidlistptr = pmkidlistnew +maclistmax;\n\t\t\tpmkidlistmax += PMKIDLIST_MAX;\n\t\t\t}\n\t\tmemset(pmkidlistptr, 0, PMKIDLIST_SIZE);\n\t\tmemcpy(pmkidlistptr->ap, macap, 6);\n\t\tmemcpy(pmkidlistptr->client, macclient, 6);\n\t\tmemcpy(pmkidlistptr->pmkid, pmkid, 16);\n\t\tpmkidlistptr->status |= pmkidstatus;\n\t\tif(cleanbackpmkid() == false) pmkidlistptr++;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211exteap(uint64_t eaptimestamp, uint8_t *macto, uint8_t *macfm, uint32_t restlen, uint8_t *eapptr)\n{\nstatic eapauth_t *eapauth;\nstatic uint32_t authlen;\nstatic exteap_t *exteap;\nstatic uint32_t exteaplen;\nstatic uint32_t idstrlen;\n\neapcount++;\nif(restlen < (int)EAPAUTH_SIZE) return;\neapauth = (eapauth_t*)eapptr;\nauthlen = ntohs(eapauth->len);\nif(authlen > restlen) return;\nexteap = (exteap_t*)(eapptr +EAPAUTH_SIZE);\nexteaplen = ntohs(exteap->len);\nif(exteaplen > authlen) return;\nidstrlen = exteaplen -EXTEAP_SIZE;\nif(exteap->type == EAP_TYPE_SIM) eapsimcount++;\nelse if(exteap->type == EAP_TYPE_AKA) eapakacount++;\nelse if(exteap->type == EAP_TYPE_PEAP) eappeapcount++;\nelse if(exteap->type == EAP_TYPE_TLS) eaptlscount++;\nelse if(exteap->type == EAP_TYPE_EXPAND) eapexpandedcount++;\nelse if(exteap->type == EAP_TYPE_MD5) processexteapmd5(eaptimestamp, macto, macfm, exteap->code, exteaplen, eapptr +EAPAUTH_SIZE);\nelse if(exteap->type == EAP_TYPE_LEAP) processexteapleap(eaptimestamp, macto, macfm, exteap->code, exteaplen, eapptr +EAPAUTH_SIZE);\nelse if(exteap->type == EAP_TYPE_MSEAP) processexteapmschapv2(eaptimestamp, macto, macfm, exteap->code, exteaplen, eapptr +EAPAUTH_SIZE);\n\nif(exteap->code == EAP_CODE_REQ)\n\t{\n\teapcodereqcount++;\n\tif(exteap->type == EAP_TYPE_ID)\n\t\t{\n\t\tif(idstrlen > 1)\n\t\t\t{\n\t\t\tif(eapptr[EAPAUTH_SIZE +EXTEAP_SIZE] != 0)\n\t\t\t\t{\n\t\t\t\tidentitycount++;\n\t\t\t\tif(fh_identity != NULL) fwritestring(idstrlen, &eapptr[EAPAUTH_SIZE +EXTEAP_SIZE], fh_identity);\n\t\t\t\t}\n\t\t\telse if(eapptr[EAPAUTH_SIZE +EXTEAP_SIZE +1] != 0)\n\t\t\t\t{\n\t\t\t\tidentitycount++;\n\t\t\t\tif(fh_identity != NULL) fwritestring(idstrlen -1, &eapptr[EAPAUTH_SIZE +EXTEAP_SIZE +1], fh_identity);\n\t\t\t\t}\n\t\t\t}\n\t\teapidcount++;\n\t\t}\n\t}\nelse if(exteap->code == EAP_CODE_RESP)\n\t{\n\teapcoderespcount++;\n\tif(exteap->type == EAP_TYPE_ID)\n\t\t{\n\t\tif(idstrlen > 1)\n\t\t\t{\n\t\t\tif(eapptr[EAPAUTH_SIZE +EXTEAP_SIZE] != 0)\n\t\t\t\t{\n\t\t\t\tidentitycount++;\n\t\t\t\tif(fh_identity != NULL) fwritestring(idstrlen, &eapptr[EAPAUTH_SIZE +EXTEAP_SIZE], fh_identity);\n\t\t\t\t}\n\t\t\telse if(eapptr[EAPAUTH_SIZE +EXTEAP_SIZE +1] != 0)\n\t\t\t\t{\n\t\t\t\tidentitycount++;\n\t\t\t\tif(fh_identity != NULL) fwritestring(idstrlen -1, &eapptr[EAPAUTH_SIZE +EXTEAP_SIZE +1], fh_identity);\n\t\t\t\t}\n\t\t\t}\n\t\teapidcount++;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic bool gettagwps(int wpslen, uint8_t *tagptr, tags_t *zeiger)\n{\nstatic wpsie_t *wpsptr;\n\nwpslen -= WPSVENDOR_SIZE;\ntagptr += WPSVENDOR_SIZE;\nif(wpslen < (int)WPSIE_SIZE) return true;\nzeiger->wpsinfo = 1;\nwpsptr = (wpsie_t*)tagptr;\nif(ntohs(wpsptr->type) != WPS_VERSION) return true;\nif(ntohs(wpsptr->len) != 1) return true;\nif(wpsptr->data[0] != 0x10) return true;\ntagptr += ntohs(wpsptr->len) +WPSIE_SIZE;\nwpslen -= ntohs(wpsptr->len) +WPSIE_SIZE;\nwhile(0 < wpslen)\n\t{\n\twpsptr = (wpsie_t*)tagptr;\n\tif((ntohs(wpsptr->type) == WPS_MANUFACTURER) && (ntohs(wpsptr->len) > 0) && (ntohs(wpsptr->len) < DEVICE_INFO_MAX))\n\t\t{\n\t\tzeiger->manufacturerlen = ntohs(wpsptr->len);\n\t\tmemcpy(zeiger->manufacturer, wpsptr->data, zeiger->manufacturerlen);\n\t\t}\n\telse if((ntohs(wpsptr->type) == WPS_MODELNAME) && (ntohs(wpsptr->len) > 0) && (ntohs(wpsptr->len) < DEVICE_INFO_MAX))\n\t\t{\n\t\tzeiger->modellen = ntohs(wpsptr->len);\n\t\tmemcpy(zeiger->model, wpsptr->data, zeiger->modellen);\n\t\t}\n\telse if((ntohs(wpsptr->type) == WPS_SERIALNUMBER) && (ntohs(wpsptr->len) > 0) && (ntohs(wpsptr->len) < DEVICE_INFO_MAX))\n\t\t{\n\t\tzeiger->serialnumberlen = ntohs(wpsptr->len);\n\t\tmemcpy(zeiger->serialnumber, wpsptr->data, zeiger->serialnumberlen);\n\t\t}\n\telse if((ntohs(wpsptr->type) == WPS_DEVICENAME) && (ntohs(wpsptr->len) > 0) && (ntohs(wpsptr->len) < DEVICE_INFO_MAX))\n\t\t{\n\t\tzeiger->devicenamelen = ntohs(wpsptr->len);\n\t\tmemcpy(zeiger->devicename, wpsptr->data, zeiger->devicenamelen);\n\t\t}\n\telse if((ntohs(wpsptr->type) == WPS_UUIDE) && (ntohs(wpsptr->len) == WPS_ENROLLEE_LEN))\n\t\t{\n\t\tzeiger->enrolleelen = ntohs(wpsptr->len);\n\t\tmemcpy(zeiger->enrollee, wpsptr->data, zeiger->enrolleelen);\n\t\t}\n\ttagptr += ntohs(wpsptr->len) +WPSIE_SIZE;\n\twpslen -= ntohs(wpsptr->len) +WPSIE_SIZE;\n\t}\nif(wpslen != 0) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool gettagwpa(int wpalen, uint8_t *ieptr, tags_t *zeiger)\n{\nstatic int c;\nstatic wpaie_t *wpaptr;\nstatic int wpatype;\nstatic suite_t *gsuiteptr;\nstatic suitecount_t *csuitecountptr;\nstatic suite_t *csuiteptr;\nstatic int csuitecount;\nstatic suitecount_t *asuitecountptr;\nstatic suite_t *asuiteptr;\nstatic int asuitecount;\n\nwpaptr = (wpaie_t*)ieptr;\nwpalen -= WPAIE_SIZE;\nieptr += WPAIE_SIZE;\n#ifndef BIG_ENDIAN_HOST\nwpatype = wpaptr->type;\n#else\nwpatype = byte_swap_16(wpaptr->type);\n#endif\nif(wpatype != VT_WPA_IE) return false;\nzeiger->kdversion |= KV_WPAIE;\ngsuiteptr = (suite_t*)ieptr;\nif(memcmp(gsuiteptr->oui, &ouimscorp, 3) == 0)\n\t{\n\tif(gsuiteptr->type == CS_WEP40) zeiger->groupcipher |= TCS_WEP40;\n\tif(gsuiteptr->type == CS_TKIP) zeiger->groupcipher |= TCS_TKIP;\n\tif(gsuiteptr->type == CS_WRAP) zeiger->groupcipher |= TCS_WRAP;\n\tif(gsuiteptr->type == CS_CCMP) zeiger->groupcipher |= TCS_CCMP;\n\tif(gsuiteptr->type == CS_WEP104) zeiger->groupcipher |= TCS_WEP104;\n\tif(gsuiteptr->type == CS_BIP) zeiger->groupcipher |= TCS_BIP;\n\tif(gsuiteptr->type == CS_NOT_ALLOWED) zeiger->groupcipher = TCS_NOT_ALLOWED;\n\t}\nwpalen -= SUITE_SIZE;\nieptr += SUITE_SIZE;\ncsuitecountptr = (suitecount_t*)ieptr;\nwpalen -= SUITECOUNT_SIZE;\nieptr += SUITECOUNT_SIZE;\n#ifndef BIG_ENDIAN_HOST\ncsuitecount = csuitecountptr->count;\n#else\ncsuitecount = byte_swap_16(csuitecountptr->count);\n#endif\nif(csuitecount *4 > wpalen)\n\t{\n\ttaglenerrorcount++;\n\treturn false;\n\t}\nfor(c = 0; c < csuitecount; c++)\n\t{\n\tcsuiteptr = (suite_t*)ieptr;\n\tif(memcmp(csuiteptr->oui, &ouimscorp, 3) == 0)\n\t\t{\n\t\tif(csuiteptr->type == CS_WEP40) zeiger->cipher |= TCS_WEP40;\n\t\tif(csuiteptr->type == CS_TKIP) zeiger->cipher |= TCS_TKIP;\n\t\tif(csuiteptr->type == CS_WRAP) zeiger->cipher |= TCS_WRAP;\n\t\tif(csuiteptr->type == CS_CCMP) zeiger->cipher |= TCS_CCMP;\n\t\tif(csuiteptr->type == CS_WEP104) zeiger->cipher |= TCS_WEP104;\n\t\tif(csuiteptr->type == CS_BIP) zeiger->cipher |= TCS_BIP;\n\t\tif(csuiteptr->type == CS_NOT_ALLOWED) zeiger->cipher |= TCS_NOT_ALLOWED;\n\t\t}\n\twpalen -= SUITE_SIZE;\n\tieptr += SUITE_SIZE;\n\tif(wpalen == 0) return true;\n\tif(wpalen < 0) return false;\n\t}\nasuitecountptr = (suitecount_t*)ieptr;\nwpalen -= SUITECOUNT_SIZE;\nieptr += SUITECOUNT_SIZE;\n#ifndef BIG_ENDIAN_HOST\nasuitecount = asuitecountptr->count;\n#else\nasuitecount = byte_swap_16(asuitecountptr->count);\n#endif\nif(asuitecount *4 > wpalen)\n\t{\n\ttaglenerrorcount++;\n\treturn false;\n\t}\nfor(c = 0; c < asuitecount; c++)\n\t{\n\tasuiteptr = (suite_t*)ieptr;\n\tif(memcmp(asuiteptr->oui, &ouimscorp, 3) == 0)\n\t\t{\n\t\tif(asuiteptr->type == AK_PMKSA) zeiger->akm |= TAK_PMKSA;\n\t\tif(asuiteptr->type == AK_PSK) zeiger->akm |= TAK_PSK;\n\t\tif(asuiteptr->type == AK_FT) zeiger->akm |= TAK_FT;\n\t\tif(asuiteptr->type == AK_FT_PSK) zeiger->akm |= TAK_FT_PSK;\n\t\tif(asuiteptr->type == AK_PMKSA256) zeiger->akm |= TAK_PMKSA256;\n\t\tif(asuiteptr->type == AK_PSKSHA256) zeiger->akm |= TAK_PSKSHA256;\n\t\tif(asuiteptr->type == AK_TDLS) zeiger->akm |= TAK_TDLS;\n\t\tif(asuiteptr->type == AK_SAE_SHA256) zeiger->akm |= TAK_SAE_SHA256;\n\t\tif(asuiteptr->type == AK_FT_SAE) zeiger->akm |= TAK_FT_SAE;\n\t\tif(asuiteptr->type == AK_SAE_SHA384B) zeiger->akm |= TAK_SAE_SHA384B;\n\t\tif(asuiteptr->type == AK_OWE) zeiger->akm |= TAK_OWE;\n\t\t}\n\twpalen -= SUITE_SIZE;\n\tieptr += SUITE_SIZE;\n\tif(wpalen == 0) return true;\n\tif(wpalen < 0) return false;\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic bool gettagvendor(int vendorlen, uint8_t *ieptr, tags_t *zeiger)\n{\nstatic wpaie_t *wpaptr;\n\nstatic const uint8_t hcxoui[] =\n{\n0xff, 0xff, 0xff, 0x00, 0xd9, 0x20, 0x21, 0x9b, 0x9b, 0x6a, 0xc9, 0x59, 0x49, 0x42, 0xe6, 0x55,\n0x6a, 0x06, 0xa3, 0x23, 0x94, 0x2d, 0x94\n};\n\nwpaptr = (wpaie_t*)ieptr;\nif(memcmp(wpaptr->oui, &ouimscorp, 3) == 0)\n\t{\n\tif((wpaptr->ouitype == VT_WPA_IE) && (vendorlen >= WPAIE_LEN_MIN))\n\t\t{\n\t\tif(gettagwpa(vendorlen, ieptr, zeiger) == false) return false;\n\t\treturn true;\n\t\t}\n\tif((wpaptr->ouitype == VT_WPS_IE) && (vendorlen >= (int)WPSIE_SIZE))\n\t\t{\n\t\tif(gettagwps(vendorlen, ieptr, zeiger) == false) return false;\n\t\treturn true;\n\t\t}\n\treturn true;\n\t}\nif(vendorlen == 0x17)\n\t{\n\tif(memcmp(&hcxoui, ieptr, 0x17) == 0) beaconhcxcount++;\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic bool gettagrsn(int rsnlen, uint8_t *ieptr, tags_t *zeiger)\n{\nstatic int c;\nstatic rsnie_t *rsnptr;\nstatic int rsnver;\nstatic suite_t *gsuiteptr;\nstatic suitecount_t *csuitecountptr;\nstatic suite_t *csuiteptr;\nstatic int csuitecount;\nstatic suitecount_t *asuitecountptr;\nstatic suite_t *asuiteptr;\nstatic int asuitecount;\nstatic rsnpmkidlist_t *rsnpmkidlistptr;\nstatic int rsnpmkidcount;\n\nstatic const uint8_t foxtrott[4] = { 0xff, 0xff, 0xff, 0xff };\n\nrsnptr = (rsnie_t*)ieptr;\n#ifndef BIG_ENDIAN_HOST\nrsnver = rsnptr->version;\n#else\nrsnver = byte_swap_16(rsnptr->version);\n#endif\nif(rsnver != 1) return true;\nzeiger->kdversion |= KV_RSNIE;\nrsnlen -= RSNIE_SIZE;\nieptr += RSNIE_SIZE;\ngsuiteptr = (suite_t*)ieptr;\nif(memcmp(gsuiteptr->oui, &suiteoui, 3) == 0)\n\t{\n\tif(gsuiteptr->type == CS_WEP40) zeiger->groupcipher |= TCS_WEP40;\n\tif(gsuiteptr->type == CS_TKIP) zeiger->groupcipher |= TCS_TKIP;\n\tif(gsuiteptr->type == CS_WRAP) zeiger->groupcipher |= TCS_WRAP;\n\tif(gsuiteptr->type == CS_CCMP) zeiger->groupcipher |= TCS_CCMP;\n\tif(gsuiteptr->type == CS_GCMP) zeiger->groupcipher |= TCS_GCMP;\n\tif(gsuiteptr->type == CS_WEP104) zeiger->groupcipher |= TCS_WEP104;\n\tif(gsuiteptr->type == CS_BIP) zeiger->groupcipher |= TCS_BIP;\n\tif(gsuiteptr->type == CS_NOT_ALLOWED) zeiger->groupcipher |= TCS_NOT_ALLOWED;\n\t}\nrsnlen -= SUITE_SIZE;\nieptr += SUITE_SIZE;\ncsuitecountptr = (suitecount_t*)ieptr;\nrsnlen -= SUITECOUNT_SIZE;\nieptr += SUITECOUNT_SIZE;\n#ifndef BIG_ENDIAN_HOST\ncsuitecount = csuitecountptr->count;\n#else\ncsuitecount = byte_swap_16(csuitecountptr->count);\n#endif\nif(csuitecount *4 > rsnlen)\n\t{\n\ttaglenerrorcount++;\n\treturn false;\n\t}\nfor(c = 0; c < csuitecount; c++)\n\t{\n\tcsuiteptr = (suite_t*)ieptr;\n\tif(memcmp(csuiteptr->oui, &suiteoui, 3) == 0)\n\t\t{\n\t\tif(csuiteptr->type == CS_WEP40) zeiger->cipher |= TCS_WEP40;\n\t\tif(csuiteptr->type == CS_TKIP) zeiger->cipher |= TCS_TKIP;\n\t\tif(csuiteptr->type == CS_WRAP) zeiger->cipher |= TCS_WRAP;\n\t\tif(csuiteptr->type == CS_CCMP) zeiger->cipher |= TCS_CCMP;\n\t\tif(csuiteptr->type == CS_GCMP) zeiger->cipher |= TCS_GCMP;\n\t\tif(csuiteptr->type == CS_WEP104) zeiger->cipher |= TCS_WEP104;\n\t\tif(csuiteptr->type == CS_BIP) zeiger->cipher |= TCS_BIP;\n\t\tif(csuiteptr->type == CS_NOT_ALLOWED) zeiger->cipher |= TCS_NOT_ALLOWED;\n\t\t}\n\trsnlen -= SUITE_SIZE;\n\tieptr += SUITE_SIZE;\n\tif(rsnlen < 0) return false;\n\tif(rsnlen == 0) return true;\n\t}\nasuitecountptr = (suitecount_t*)ieptr;\nrsnlen -= SUITECOUNT_SIZE;\nieptr += SUITECOUNT_SIZE;\n#ifndef BIG_ENDIAN_HOST\nasuitecount = asuitecountptr->count;\n#else\nasuitecount = byte_swap_16(asuitecountptr->count);\n#endif\nif(asuitecount *4 > rsnlen)\n\t{\n\ttaglenerrorcount++;\n\treturn false;\n\t}\nfor(c = 0; c < asuitecount; c++)\n\t{\n\tasuiteptr = (suite_t*)ieptr;\n\tif(memcmp(asuiteptr->oui, &suiteoui, 3) == 0)\n\t\t{\n\t\tif(asuiteptr->type == AK_PMKSA) zeiger->akm |= TAK_PMKSA;\n\t\tif(asuiteptr->type == AK_PSK) zeiger->akm |= TAK_PSK;\n\t\tif(asuiteptr->type == AK_FT) zeiger->akm |= TAK_FT;\n\t\tif(asuiteptr->type == AK_FT_PSK) zeiger->akm |= TAK_FT_PSK;\n\t\tif(asuiteptr->type == AK_PMKSA256) zeiger->akm |= TAK_PMKSA256;\n\t\tif(asuiteptr->type == AK_PSKSHA256) zeiger->akm |= TAK_PSKSHA256;\n\t\tif(asuiteptr->type == AK_TDLS) zeiger->akm |= TAK_TDLS;\n\t\tif(asuiteptr->type == AK_SAE_SHA256) zeiger->akm |= TAK_SAE_SHA256;\n\t\tif(asuiteptr->type == AK_FT_SAE) zeiger->akm |= TAK_FT_SAE;\n\t\tif(asuiteptr->type == AK_SAE_SHA384B) zeiger->akm |= TAK_SAE_SHA384B;\n\t\tif(asuiteptr->type == AK_OWE) zeiger->akm |= TAK_OWE;\n\t\t}\n\trsnlen -= SUITE_SIZE;\n\tieptr += SUITE_SIZE;\n\tif(rsnlen < 0) return false;\n\tif(rsnlen == 0) return true;\n\t}\nrsnlen -= RSNCAPABILITIES_SIZE;\nieptr += RSNCAPABILITIES_SIZE;\nif(rsnlen <= 0) return true;\nrsnpmkidlistptr = (rsnpmkidlist_t*)ieptr;\n#ifndef BIG_ENDIAN_HOST\nrsnpmkidcount = rsnpmkidlistptr->count;\n#else\nrsnpmkidcount = byte_swap_16(rsnpmkidlistptr->count);\n#endif\nif(rsnpmkidcount == 0) return true;\nrsnlen -= RSNPMKIDLIST_SIZE;\nieptr += RSNPMKIDLIST_SIZE;\nif(rsnlen < 16) return true;\nif(((zeiger->akm &TAK_PSK) == TAK_PSK) || ((zeiger->akm &TAK_PSKSHA256) == TAK_PSKSHA256))\n\t{\n\tif(memcmp(&zeroed32, ieptr, 16) == 0) return true;\n\tfor(c = 0; c < 12; c++)\n\t\t{\n\t\tif(memcmp(&zeroed32, &ieptr[c], 4) == 0) return false;\n\t\tif(memcmp(&foxtrott, &ieptr[c], 4) == 0) return false;\n\t\t}\n\tmemcpy(zeiger->pmkid, ieptr, 16);\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic bool isessidvalid(int essidlen, uint8_t *essid)\n{\nstatic int c;\nstatic const uint8_t foxtrott[4] = { 0xff, 0xff, 0xff, 0xff };\n\nif(essidlen > ESSID_LEN_MAX) return false;\nif(essidlen == 0) return true;\nif(memcmp(&zeroed32, essid, essidlen) == 0) return true;\nif(essid[essidlen -1] == 0)\n\t{\n\tessiderrorcount++;\n\treturn false;\n\t}\nfor(c = 0; c< essidlen -4; c++)\n\t{\n\tif(memcmp(&zeroed32, &essid[c], 4) == 0)\n\t\t{\n\t\tessiderrorcount++;\n\t\treturn false;\n\t\t}\n\tif(memcmp(&foxtrott, &essid[c], 4) == 0)\n\t\t{\n\t\tessiderrorcount++;\n\t\treturn false;\n\t\t}\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic bool gettags(int infolen, uint8_t *infoptr, tags_t *zeiger)\n{\nstatic ietag_t *tagptr;\nstatic uint8_t tagok;\nstatic bool ef;\n\nmemset(zeiger, 0, TAGS_SIZE);\nef = false;\ntagok = 0;\nwhile(0 < infolen)\n\t{\n\tif(infolen == 4) return true;\n\ttagptr = (ietag_t*)infoptr;\n\tif(tagptr->len == 0)\n\t\t{\n\t\tinfoptr += tagptr->len +IETAG_SIZE;\n\t\tinfolen -= tagptr->len +IETAG_SIZE;\n\t\tcontinue;\n\t\t}\n\tif(tagptr->len > infolen)\n\t\t{\n\t\ttaglenerrorcount++;\n\t\treturn false;\n\t\t}\n\tif(tagptr->id == TAG_SSID)\n\t\t{\n\t\tif((tagok & TAG_SSID_OK) == 0)\n\t\t\t{\n\t\t\tif(tagptr->len > ESSID_LEN_MAX)\n\t\t\t\t{\n\t\t\t\ttaglenerrorcount++;\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tif(isessidvalid(tagptr->len, &tagptr->data[0]) == false) return false;\n\t\t\t\t{\n\t\t\t\tef = true;\n\t\t\t\tmemcpy(zeiger->essid, &tagptr->data[0], tagptr->len);\n\t\t\t\tzeiger->essidlen = tagptr->len;\n\t\t\t\t}\n\t\t\ttagok |= TAG_SSID_OK;\n\t\t\t}\n\t\t}\n\telse if(tagptr->id == TAG_CHAN)\n\t\t{\n\t\tif((tagok & TAG_CHAN_OK) == 0)\n\t\t\t{\n\t\t\tif(tagptr->len == 1)\n\t\t\t\t{\n\t\t\t\tzeiger->channel = tagptr->data[0];\n\t\t\t\ttagok |= TAG_CHAN_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse if(tagptr->id == TAG_COUNTRY)\n\t\t{\n\t\tif(tagptr->len > 2)\n\t\t\t{\n\t\t\tif((tagok & TAG_COUNTRY_OK) == 0)\n\t\t\t\t{\n\t\t\t\tzeiger->country[0] = tagptr->data[0];\n\t\t\t\tzeiger->country[1] = tagptr->data[1];\n\t\t\t\ttagok |= TAG_COUNTRY_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse if(tagptr->id == TAG_RSN)\n\t\t{\n\t\tif(tagptr->len >= RSNIE_LEN_MIN)\n\t\t\t{\n\t\t\tif(gettagrsn(tagptr->len, tagptr->data, zeiger) == false)\n\t\t\t\t{\n\t\t\t\ttaglenerrorcount++;\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse if(tagptr->id == TAG_VENDOR)\n\t\t{\n\t\tif(tagptr->len >= VENDORIE_SIZE)\n\t\t\t{\n\t\t\tif(gettagvendor(tagptr->len, tagptr->data, zeiger) == false)\n\t\t\t\t{\n\t\t\t\ttaglenerrorcount++;\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tinfoptr += tagptr->len +IETAG_SIZE;\n\tinfolen -= tagptr->len +IETAG_SIZE;\n\t}\nif((infolen != 0) && (infolen != 4) && (ef == false))\n\t{\n\ttaglenerrorcount++;\n\treturn false;\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic void process80211eapol_m4(uint64_t eaptimestamp, uint8_t *macap, uint8_t *macclient, uint8_t *macsrc, uint32_t restlen, uint8_t *eapauthptr)\n{\nstatic int c;\nstatic messagelist_t *zeiger;\nstatic uint8_t *wpakptr;\nstatic wpakey_t *wpak;\nstatic eapauth_t *eapauth;\nstatic uint16_t authlen;\nstatic uint64_t eaptimegap;\nstatic uint8_t keyver;\nstatic uint64_t rc;\nstatic uint64_t rcgap;\nstatic uint8_t mpfield;\n\nstatic const uint8_t foxtrott[4] = { 0xff, 0xff, 0xff, 0xff };\n\neapolm4count++;\neapolmsgcount++;\nif(memcmp(macap, macsrc, 6) != 0)\n\t{\n\teapolrelayedcount++;\n\treturn;\n\t}\neapauth = (eapauth_t*)eapauthptr;\nauthlen = ntohs(eapauth->len);\nif(authlen == 0) return;\nif(authlen +EAPAUTH_SIZE > restlen) return;\nif((authlen +EAPAUTH_SIZE) > EAPOL_AUTHLEN_MAX)\n\t{\n\teapolm4oversizedcount++;\n\treturn;\n\t}\nwpakptr = eapauthptr +EAPAUTH_SIZE;\nwpak = (wpakey_t*)wpakptr;\nkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nif((keyver == 0) || (keyver > 3))\n\t{\n\teapolm4kdv0count++;\n\treturn;\n\t}\nif(ntohs(wpak->wpadatalen) > (restlen -EAPAUTH_SIZE -WPAKEY_SIZE))\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M4 wpa data len > eap authentication len: %ld\\n\", rawpacketcount);\n\teapolm4errorcount++;\n\treturn;\n\t}\n#ifndef BIG_ENDIAN_HOST\nrc = byte_swap_64(wpak->replaycount);\n#else\nrc = wpak->replaycount;\n#endif\nif(memcmp(&zeroed32, wpak->keymic, 16) == 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M4 key mic zeroed: %ld\\n\", rawpacketcount);\n\teapolm4errorcount++;\n\treturn;\n\t}\nfor(c = 0; c < 12; c++)\n\t{\n\tif(memcmp(&zeroed32, &wpak->keymic[c], 4) == 0)\n\t\t{\n\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M4 key mic possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\teapolm4errorcount++;\n\t\treturn;\n\t\t}\n\tif(memcmp(&foxtrott, &wpak->keymic[c], 4) == 0)\n\t\t{\n\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M4 key mic possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\teapolm4errorcount++;\n\t\treturn;\n\t\t}\n\t}\nif(memcmp(&zeroed32, wpak->keyid, 8) != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M4 key id != 0: %ld\\n\", rawpacketcount);\n\teapolm4errorcount++;\n\treturn;\n\t}\nif(memcmp(&zeroed32, wpak->nonce, 32) == 0)\n\t{\n\teapolm4zeroedcount++;\n\treturn;\n\t}\nif((memcmp(&fakenonce1, wpak->nonce, 32) == 0) && (rc == 17)) return;\nif((memcmp(&fakenonce2, wpak->nonce, 32) == 0) && (rc == 17)) return;\nzeiger = messagelist +MESSAGELIST_MAX;\nmemset(zeiger, 0, MESSAGELIST_SIZE);\nzeiger->timestamp = eaptimestamp;\nzeiger->eapolmsgcount = eapolmsgcount;\nmemcpy(zeiger->client, macclient, 6);\nmemcpy(zeiger->ap, macap, 6);\nzeiger->message = HS_M4;\nzeiger->rc = rc;\nmemcpy(zeiger->nonce, wpak->nonce, 32);\nif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t{\n\tzeiger->eapauthlen = authlen +EAPAUTH_SIZE;\n\tmemcpy(zeiger->eapol, eapauthptr, zeiger->eapauthlen);\n\t}\nmpfield = 0;\nfor(zeiger = messagelist; zeiger < messagelist +MESSAGELIST_MAX; zeiger++)\n\t{\n\tif(zeiger->timestamp == 0) break;\n\tif((zeiger->message &HS_M3) == HS_M3)\n\t\t{\n\t\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\t\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\t\tif(zeiger->rc >= rc) rcgap = zeiger->rc -rc;\n\t\telse rcgap = rc -zeiger->rc;\n\t\tif(rcgap > rcgapmax) rcgapmax = rcgap;\n\t\tif(rcgap > ncvalue) continue;\n\t\tif(eaptimestamp > zeiger->timestamp) eaptimegap = eaptimestamp -zeiger->timestamp;\n\t\telse eaptimegap = zeiger->timestamp -eaptimestamp;\n\t\tif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t\t\t{\n\t\t\tmpfield = ST_M34E4;\n\t\t\tif(eaptimegap > eaptimegapmax) eaptimegapmax = eaptimegap;\n\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, messagelist +MESSAGELIST_MAX, zeiger, keyver, mpfield);\n\t\t\tif(donotcleanflag == true)\n\t\t\t\t{\n\t\t\t\tmpfield = ST_M34E3;\n\t\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, messagelist +MESSAGELIST_MAX, zeiger, keyver, mpfield);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif((zeiger->message &HS_M1) != HS_M1) continue;\n\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\tif(zeiger->rc >= rc -1) rcgap = zeiger->rc -rc +1;\n\telse rcgap = rc +1 -zeiger->rc;\n\tif(zeiger->rc != myaktreplaycount)\n\t\t{\n\t\tif(rcgap > rcgapmax) rcgapmax = rcgap;\n\t\t}\n\tif(rcgap > ncvalue) continue;\n\tif(eaptimestamp > zeiger->timestamp) eaptimegap = eaptimestamp -zeiger->timestamp;\n\telse eaptimegap = zeiger->timestamp -eaptimestamp;\n\tif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t\t{\n\t\tmpfield = ST_M14E4;\n\t\tif(myaktreplaycount > 0)\n\t\t\t{\n\t\t\tif(zeiger->rc == myaktreplaycount) continue;\n\t\t\t}\n\t\tif(eaptimegap > eaptimegapmax) eaptimegapmax = eaptimegap;\n\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, messagelist +MESSAGELIST_MAX, zeiger, keyver, mpfield);\n\t\t}\n\t}\nqsort(messagelist, MESSAGELIST_MAX +1, MESSAGELIST_SIZE, sort_messagelist_by_timestamp);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211eapol_m3(uint64_t eaptimestamp, uint8_t *macclient, uint8_t *macap, uint8_t *macsrc, uint32_t restlen, uint8_t *eapauthptr)\n{\nstatic int c;\nstatic messagelist_t *zeiger;\nstatic messagelist_t *zeigerakt;\nstatic uint8_t *wpakptr;\nstatic wpakey_t *wpak;\nstatic eapauth_t *eapauth;\nstatic uint16_t authlen;\nstatic uint64_t eaptimegap;\nstatic uint8_t keyver;\nstatic uint64_t rc;\nstatic uint64_t rcgap;\nstatic uint8_t mpfield;\n\nstatic const uint8_t foxtrott[4] = { 0xff, 0xff, 0xff, 0xff };\n\neapolm3count++;\neapolmsgcount++;\nif(memcmp(macap, macsrc, 6) != 0)\n\t{\n\teapolrelayedcount++;\n\treturn;\n\t}\nzeigerakt = messagelist +MESSAGELIST_MAX;\neapauth = (eapauth_t*)eapauthptr;\nauthlen = ntohs(eapauth->len);\nif(authlen == 0) return;\nif(authlen > restlen) return;\nif((authlen +EAPAUTH_SIZE) > EAPOL_AUTHLEN_MAX)\n\t{\n\teapolm3oversizedcount++;\n\treturn;\n\t}\nwpakptr = eapauthptr +EAPAUTH_SIZE;\nwpak = (wpakey_t*)wpakptr;\nkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nif((keyver == 0) || (keyver > 3))\n\t{\n\teapolm3kdv0count++;\n\treturn;\n\t}\nif(ntohs(wpak->wpadatalen) > (restlen -EAPAUTH_SIZE -WPAKEY_SIZE))\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M3 wpa data len > eap authentication len: %ld\\n\", rawpacketcount);\n\teapolm3errorcount++;\n\treturn;\n\t}\n#ifndef BIG_ENDIAN_HOST\nrc = byte_swap_64(wpak->replaycount);\n#else\nrc = wpak->replaycount;\n#endif\nif(memcmp(&zeroed32, wpak->keymic, 16) == 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M3 key mic zeroed: %ld\\n\", rawpacketcount);\n\teapolm3errorcount++;\n\treturn;\n\t}\nfor(c = 0; c < 12; c++)\n\t{\n\tif(memcmp(&zeroed32, &wpak->keymic[c], 4) == 0)\n\t\t{\n\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M3 key mic possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\teapolm3errorcount++;\n\t\treturn;\n\t\t}\n\tif(memcmp(&foxtrott, &wpak->keymic[c], 4) == 0)\n\t\t{\n\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M3 key mic possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\teapolm3errorcount++;\n\t\treturn;\n\t\t}\n\t}\nif(memcmp(&zeroed32, wpak->keyid, 8) != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M3 key id != 0: %ld\\n\", rawpacketcount);\n\teapolm3errorcount++;\n\treturn;\n\t}\nmemset(zeigerakt, 0, MESSAGELIST_SIZE);\nzeigerakt->timestamp = eaptimestamp;\nzeigerakt->eapolmsgcount = eapolmsgcount;\nmemcpy(zeigerakt->client, macclient, 6);\nmemcpy(zeigerakt->ap, macap, 6);\nzeigerakt->message = HS_M3;\nzeigerakt->rc = rc;\nmemcpy(zeigerakt->nonce, wpak->nonce, 32);\nif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t{\n\tzeigerakt->eapauthlen = authlen +EAPAUTH_SIZE;\n\tmemcpy(zeigerakt->eapol, eapauthptr, zeigerakt->eapauthlen);\n\t}\nfor(zeiger = messagelist; zeiger < messagelist +MESSAGELIST_MAX; zeiger++)\n\t{\n\tif(zeiger->timestamp == 0) break;\n\tif(((zeiger->message &HS_M1) == HS_M1) || ((zeiger->message &HS_M3) == HS_M3))\n\t\t{\n\t\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\t\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\t\tif((memcmp(zeiger->nonce, wpak->nonce, 28) == 0) && (memcmp(&zeiger->nonce[28], &wpak->nonce[28], 4) != 0))\n\t\t\t{\n\t\t\teapolnccount++;\n\t\t\tif(memcmp(&zeiger->nonce[30], &wpak->nonce[30], 2) != 0)\n\t\t\t\t{\n\t\t\t\tzeiger->status = ST_LE +ST_NC;\n\t\t\t\t(messagelist +MESSAGELIST_MAX)->status = ST_LE +ST_NC;\n\t\t\t\t}\n\t\t\telse if(memcmp(&zeiger->nonce[28], &wpak->nonce[28], 2) != 0)\n\t\t\t\t{\n\t\t\t\tzeiger->status = ST_BE +ST_NC;\n\t\t\t\t(messagelist +MESSAGELIST_MAX)->status = ST_BE +ST_NC;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nmpfield = 0;\nfor(zeiger = messagelist; zeiger < messagelist +MESSAGELIST_MAX; zeiger++)\n\t{\n\tif(zeiger->timestamp == 0) break;\n\tif((zeiger->message &HS_M2) == HS_M2)\n\t\t{\n\t\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\t\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\t\tif(zeiger->rc >= rc -1) rcgap = zeiger->rc -rc +1;\n\t\telse rcgap = rc +1 -zeiger->rc;\n\t\tif(zeiger->rc != myaktreplaycount)\n\t\t\t{\n\t\t\tif(rcgap > rcgapmax) rcgapmax = rcgap;\n\t\t\t}\n\t\tif(rcgap > ncvalue) continue;\n\t\tif(eaptimestamp > zeiger->timestamp) eaptimegap = eaptimestamp -zeiger->timestamp;\n\t\telse eaptimegap = zeiger->timestamp -eaptimestamp;\n\t\tif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t\t\t{\n\t\t\tmpfield = ST_M32E2;\n\t\t\tif(myaktreplaycount > 0)\n\t\t\t\t{\n\t\t\t\tif(zeiger->rc == myaktreplaycount) continue;\n\t\t\t\t}\n\t\t\tif(eaptimegap > eaptimegapmax) eaptimegapmax = eaptimegap;\n\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, zeiger, messagelist +MESSAGELIST_MAX, keyver, mpfield);\n\t\t\tif(donotcleanflag == true)\n\t\t\t\t{\n\t\t\t\tmpfield = ST_M32E3;\n\t\t\t\tif(myaktreplaycount > 0)\n\t\t\t\t\t{\n\t\t\t\t\tif(zeiger->rc == myaktreplaycount) continue;\n\t\t\t\t\t}\n\t\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, zeiger, messagelist +MESSAGELIST_MAX, keyver, mpfield);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif((zeiger->message &HS_M4) != HS_M4) continue;\n\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\tif(zeiger->rc >= rc) rcgap = zeiger->rc -rc;\n\telse rcgap = rc -zeiger->rc;\n\tif(rcgap > rcgapmax) rcgapmax = rcgap;\n\tif(rcgap > ncvalue) continue;\n\tif(eaptimestamp > zeiger->timestamp) eaptimegap = eaptimestamp -zeiger->timestamp;\n\telse eaptimegap = zeiger->timestamp -eaptimestamp;\n\tif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t\t{\n\t\tmpfield = ST_M34E4;\n\t\tif(myaktreplaycount > 0)\n\t\t\t{\n\t\t\tif(zeiger->rc == myaktreplaycount) continue;\n\t\t\t}\n\t\tif(eaptimegap > eaptimegapmax) eaptimegapmax = eaptimegap;\n\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, zeiger, messagelist +MESSAGELIST_MAX, keyver, mpfield);\n\t\tif(donotcleanflag == true)\n\t\t\t{\n\t\t\tmpfield = ST_M34E3;\n\t\t\tif(myaktreplaycount > 0)\n\t\t\t\t{\n\t\t\t\tif(zeiger->rc == myaktreplaycount) continue;\n\t\t\t\t}\n\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, zeiger, messagelist +MESSAGELIST_MAX, keyver, mpfield);\n\t\t\t}\n\t\t}\n\t}\nqsort(messagelist, MESSAGELIST_MAX +1, MESSAGELIST_SIZE, sort_messagelist_by_timestamp);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211eapol_m2(uint64_t eaptimestamp, uint8_t *macap, uint8_t *macclient, uint8_t *macsrc, uint32_t restlen, uint8_t *eapauthptr)\n{\nstatic int c;\nstatic messagelist_t *zeiger;\nstatic uint8_t *wpakptr;\nstatic wpakey_t *wpak;\nstatic eapauth_t *eapauth;\nstatic uint16_t authlen;\nstatic uint64_t eaptimegap;\nstatic uint8_t keyver;\nstatic uint64_t rc;\nstatic uint64_t rcgap;\nstatic uint8_t mpfield;\nstatic uint16_t wpainfolen;\nstatic tags_t tags;\n\nstatic const uint8_t foxtrott[4] = { 0xff, 0xff, 0xff, 0xff };\n\neapolm2count++;\neapolmsgcount++;\nif(memcmp(macap, macsrc, 6) != 0)\n\t{\n\teapolrelayedcount++;\n\treturn;\n\t}\neapauth = (eapauth_t*)eapauthptr;\nauthlen = ntohs(eapauth->len);\nif(authlen == 0) return;\nif(authlen +EAPAUTH_SIZE > restlen) return;\nif((authlen +EAPAUTH_SIZE) > EAPOL_AUTHLEN_MAX)\n\t{\n\teapolm2oversizedcount++;\n\treturn;\n\t}\nwpakptr = eapauthptr +EAPAUTH_SIZE;\nwpak = (wpakey_t*)wpakptr;\nkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nif((keyver == 0) || (keyver > 3))\n\t{\n\teapolm2kdv0count++;\n\treturn;\n\t}\nwpainfolen = ntohs(wpak->wpadatalen);\nif(wpainfolen > (restlen -EAPAUTH_SIZE -WPAKEY_SIZE))\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 wpa data len > eap authentication len: %ld\\n\", rawpacketcount);\n\teapolm2errorcount++;\n\treturn;\n\t}\n#ifndef BIG_ENDIAN_HOST\nrc = byte_swap_64(wpak->replaycount);\n#else\nrc = wpak->replaycount;\n#endif\nif(memcmp(&zeroed32, wpak->nonce, 32) == 0) return;\nif(memcmp(&zeroed32, wpak->keymic, 16) == 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 key mic zeroed: %ld\\n\", rawpacketcount);\n\teapolm2errorcount++;\n\treturn;\n\t}\nfor(c = 0; c < 12; c++)\n\t{\n\tif(memcmp(&zeroed32, &wpak->keymic[c], 4) == 0)\n\t\t{\n\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 key mic possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\teapolm2errorcount++;\n\t\treturn;\n\t\t}\n\tif(memcmp(&foxtrott, &wpak->keymic[c], 4) == 0)\n\t\t{\n\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 key mic possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\teapolm2errorcount++;\n\t\treturn;\n\t\t}\n\t}\nif(memcmp(&zeroed32, wpak->keyiv, 16) != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 key iv != 0: %ld\\n\", rawpacketcount);\n\teapolm2errorcount++;\n\treturn;\n\t}\nif(wpak->keyrsc != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 key rsc != 0: %ld\\n\", rawpacketcount);\n\teapolm2errorcount++;\n\treturn;\n\t}\nif(memcmp(&zeroed32, wpak->keyid, 8) != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M2 key id != 0: %ld\\n\", rawpacketcount);\n\teapolm2errorcount++;\n\treturn;\n\t}\nif((memcmp(&fakenonce1, wpak->nonce, 32) == 0) && (rc == 17)) return;\nif((memcmp(&fakenonce2, wpak->nonce, 32) == 0) && (rc == 17)) return;\nzeiger = messagelist +MESSAGELIST_MAX;\nmemset(zeiger, 0, MESSAGELIST_SIZE);\nzeiger->timestamp = eaptimestamp;\nzeiger->eapolmsgcount = eapolmsgcount;\nmemcpy(zeiger->client, macclient, 6);\nmemcpy(zeiger->ap, macap, 6);\nzeiger->message = HS_M2;\nzeiger->rc = rc;\nmemcpy(zeiger->nonce, wpak->nonce, 32);\nif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t{\n\tzeiger->eapauthlen = authlen +EAPAUTH_SIZE;\n\tmemcpy(zeiger->eapol, eapauthptr, zeiger->eapauthlen);\n\t}\nif(wpainfolen >= RSNIE_LEN_MIN)\n\t{\n\tif(gettags(wpainfolen, wpakptr +WPAKEY_SIZE, &tags) == false) return;\n\tif((tags.akm &TAK_FT_PSK) == TAK_FT_PSK) eapolm2ftpskcount++;\n\tif(((tags.akm &TAK_PSK) != TAK_PSK) && ((tags.akm &TAK_PSKSHA256) != TAK_PSKSHA256))\n\t\t{\n\t\tif(ignoreieflag == false) return;\n\t\t}\n\tif(memcmp(&zeroed32, tags.pmkid, 16) != 0)\n\t\t{\n\t\tzeiger->message |= HS_PMKID;\n\t\tmemcpy(zeiger->pmkid, tags.pmkid, 16);\n\t\taddpmkid(eaptimestamp, macclient, macap, tags.pmkid, PMKID_CLIENT);\n\t\t}\n\t}\nmpfield = 0;\nfor(zeiger = messagelist; zeiger < messagelist +MESSAGELIST_MAX; zeiger++)\n\t{\n\tif(zeiger->timestamp == 0) break;\n\tif((zeiger->message &HS_M1) == HS_M1)\n\t\t{\n\t\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\t\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\t\tif(zeiger->rc >= rc) rcgap = zeiger->rc -rc;\n\t\telse rcgap = rc -zeiger->rc;\n\t\tif((rc != myaktreplaycount) && (zeiger->rc != myaktreplaycount))\n\t\t\t{\n\t\t\tif(rcgap > rcgapmax) rcgapmax = rcgap;\n\t\t\t}\n\t\tif(rcgap > ncvalue) continue;\n\t\tif(eaptimestamp > zeiger->timestamp) eaptimegap = eaptimestamp -zeiger->timestamp;\n\t\telse eaptimegap = zeiger->timestamp -eaptimestamp;\n\t\tif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t\t\t{\n\t\t\tmpfield = ST_M12E2;\n\t\t\tif(myaktreplaycount > 0)\n\t\t\t\t{\n\t\t\t\tif((rc == myaktreplaycount) && (memcmp(&myaktanonce, zeiger->nonce, 32) == 0))\n\t\t\t\t\t{\n\t\t\t\t\teaptimegap = 0;\n\t\t\t\t\tmpfield |= ST_APLESS;\n\t\t\t\t\t}\n\t\t\t\tif(rcgap != 0) continue;\n\t\t\t\t}\n\t\t\tif(eaptimegap > eaptimegapmax) eaptimegapmax = eaptimegap;\n\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, messagelist +MESSAGELIST_MAX, zeiger, keyver, mpfield);\n\t\t\t}\n\t\t}\n\tif((zeiger->message &HS_M3) != HS_M3) continue;\n\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\tif(zeiger->rc >= rc +1) rcgap = zeiger->rc -rc -1;\n\telse rcgap = rc +1 -zeiger->rc;\n\tif(rc != myaktreplaycount)\n\t\t{\n\t\tif(rcgap > rcgapmax) rcgapmax = rcgap;\n\t\t}\n\tif(rcgap > ncvalue) continue;\n\tif(eaptimestamp > zeiger->timestamp) eaptimegap = eaptimestamp -zeiger->timestamp;\n\telse eaptimegap = zeiger->timestamp -eaptimestamp;\n\tif((authlen +EAPAUTH_SIZE) <= EAPOL_AUTHLEN_MAX)\n\t\t{\n\t\tmpfield = ST_M32E2;\n\t\tif(eaptimegap > eaptimegapmax) eaptimegapmax = eaptimegap;\n\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, messagelist +MESSAGELIST_MAX, zeiger, keyver, mpfield);\n\t\tif(donotcleanflag == true)\n\t\t\t{\n\t\t\tmpfield = ST_M32E3;\n\t\t\tif(eaptimegap <= eapoltimeoutvalue) addhandshake(eaptimegap, rcgap, messagelist +MESSAGELIST_MAX, zeiger, keyver, mpfield);\n\t\t\t}\n\t\t}\n\t}\nqsort(messagelist, MESSAGELIST_MAX +1, MESSAGELIST_SIZE, sort_messagelist_by_timestamp);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211eapol_m1(uint64_t eaptimestamp, uint8_t *macclient, uint8_t *macap, uint8_t *macsrc, uint32_t restlen, uint8_t *eapauthptr)\n{\nstatic int c;\nstatic messagelist_t *zeiger;\nstatic uint8_t *wpakptr;\nstatic wpakey_t *wpak;\nstatic eapauth_t *eapauth;\nstatic uint16_t authlen;\nstatic pmkid_t *pmkid;\nstatic uint8_t keyver;\nstatic uint64_t rc;\n\nstatic const uint8_t foxtrott[4] = { 0xff, 0xff, 0xff, 0xff };\n\neapolm1count++;\neapolmsgcount++;\nif(memcmp(macap, macsrc, 6) != 0)\n\t{\n\teapolrelayedcount++;\n\treturn;\n\t}\neapauth = (eapauth_t*)eapauthptr;\nauthlen = ntohs(eapauth->len);\nif(authlen > restlen)\n\t{\n\teapolm1errorcount++;\n\treturn;\n\t}\nwpakptr = eapauthptr +EAPAUTH_SIZE;\nwpak = (wpakey_t*)wpakptr;\nkeyver = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\nif((keyver == 0) || (keyver > 3))\n\t{\n\teapolm1kdv0count++;\n\tif(authlen >= (int)(WPAKEY_SIZE +PMKID_SIZE))\n\t\t{\n\t\tpmkid = (pmkid_t*)(wpakptr +WPAKEY_SIZE);\n\t\tif(pmkid->id != TAG_VENDOR) return;\n\t\tif((pmkid->len == 0x14) && (pmkid->type == 0x04))\n\t\t\t{\n\t\t\tif(memcmp(&zeroed32, pmkid->pmkid, 16) == 0)\n\t\t\t\t{\n\t\t\t\tpmkiduselesscount++;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tpmkidakmcount++;\n\t\t\t\tpmkidcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn;\n\t}\nif(ntohs(wpak->wpadatalen) > (restlen -EAPAUTH_SIZE -WPAKEY_SIZE))\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M1 wpa data len > eap authentication len: %ld\\n\", rawpacketcount);\n\teapolm1errorcount++;\n\treturn;\n\t}\n#ifndef BIG_ENDIAN_HOST\nrc = byte_swap_64(wpak->replaycount);\n#else\nrc = wpak->replaycount;\n#endif\nif(wpak->keyrsc != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M1 key rc != 0: %ld\\n\", rawpacketcount);\n\teapolm1errorcount++;\n\treturn;\n\t}\nif(memcmp(&zeroed32, wpak->keyid, 8) != 0)\n\t{\n\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M1 key id != 0: %ld\\n\", rawpacketcount);\n\teapolm1errorcount++;\n\treturn;\n\t}\nif((memcmp(&fakenonce1, wpak->nonce, 32) == 0) && (rc == 17)) return;\nif((memcmp(&fakenonce2, wpak->nonce, 32) == 0) && (rc == 17)) return;\nzeiger = messagelist +MESSAGELIST_MAX;\nmemset(zeiger, 0, MESSAGELIST_SIZE);\nzeiger->timestamp = eaptimestamp;\nzeiger->eapolmsgcount = eapolmsgcount;\nmemcpy(zeiger->client, macclient, 6);\nmemcpy(zeiger->ap, macap, 6);\nzeiger->message = HS_M1;\nzeiger->status = ST_NC;\nzeiger->rc = rc;\nmemcpy(zeiger->nonce, wpak->nonce, 32);\nif((zeiger->rc == myaktreplaycount) && (memcmp(&myaktanonce, zeiger->nonce, 32) == 0))\n\t{\n\tzeiger->status = ST_APLESS;\n\teapolm1ancount++;\n\tqsort(messagelist, MESSAGELIST_MAX +1, MESSAGELIST_SIZE, sort_messagelist_by_timestamp);\n\treturn;\n\t}\nif(authlen >= (int)(WPAKEY_SIZE +PMKID_SIZE))\n\t{\n\tpmkid = (pmkid_t*)(wpakptr +WPAKEY_SIZE);\n\tif(pmkid->id != TAG_VENDOR) return;\n\tif((pmkid->len == 0x14) && (pmkid->type == 0x04))\n\t\t{\n\t\tzeiger->message |= HS_PMKID;\n\t\tif(memcmp(&zeroed32, pmkid->pmkid, 16) == 0)\n\t\t\t{\n\t\t\tpmkiduselesscount++;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tfor(c = 0; c < 12; c++)\n\t\t\t\t{\n\t\t\t\tif(memcmp(&zeroed32, &pmkid->pmkid[c], 4) == 0)\n\t\t\t\t\t{\n\t\t\t\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M1 possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\t\t\t\teapolm1errorcount++;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\tif(memcmp(&foxtrott, &pmkid->pmkid[c], 4) == 0)\n\t\t\t\t\t{\n\t\t\t\t\tif(fh_log != NULL) fprintf(fh_log, \"EAPOL M1 possible plcp bit error: %ld\\n\", rawpacketcount);\n\t\t\t\t\teapolm1errorcount++;\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tmemcpy(zeiger->pmkid, pmkid->pmkid, 16);\n\t\t\tif(keyver != 3) addpmkid(eaptimestamp, macclient, macsrc, pmkid->pmkid, PMKID_AP);\n\t\t\telse addpmkid(eaptimestamp, macclient, macsrc, pmkid->pmkid, PMKID_AP | PMKID_APPSK256);\n\t\t\t}\n\t\t}\n\telse pmkiduselesscount++;\n\t}\nfor(zeiger = messagelist; zeiger < messagelist +MESSAGELIST_MAX +1; zeiger++)\n\t{\n\tif(zeiger->timestamp == 0) break;\n\tif(((zeiger->message &HS_M1) != HS_M1) && ((zeiger->message &HS_M3) != HS_M3)) continue;\n\tif(memcmp(zeiger->ap, macap, 6) != 0) continue;\n\tif(memcmp(zeiger->client, macclient, 6) != 0) continue;\n\teapolm1ancount++;\n\tif((memcmp(zeiger->nonce, wpak->nonce, 28) == 0) && (memcmp(&zeiger->nonce[28], &wpak->nonce[28], 4) != 0))\n\t\t{\n\t\teapolnccount++;\n\t\tif(memcmp(&zeiger->nonce[30], &wpak->nonce[30], 2) != 0)\n\t\t\t{\n\t\t\tzeiger->status = ST_LE +ST_NC;\n\t\t\t(messagelist +MESSAGELIST_MAX)->status = ST_LE +ST_NC;\n\t\t\t}\n\t\telse if(memcmp(&zeiger->nonce[28], &wpak->nonce[28], 2) != 0)\n\t\t\t{\n\t\t\tzeiger->status = ST_BE +ST_NC;\n\t\t\t(messagelist +MESSAGELIST_MAX)->status = ST_BE +ST_NC;\n\t\t\t}\n\t\t}\n\t}\nqsort(messagelist, MESSAGELIST_MAX +1, MESSAGELIST_SIZE, sort_messagelist_by_timestamp);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211rc4key(void)\n{\neapolrc4count++;\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211eapol(uint64_t eaptimestamp, uint8_t *macto, uint8_t *macfm, uint8_t *macsrc, uint32_t eapauthlen, uint8_t *eapauthptr)\n{\nstatic eapauth_t *eapauth;\nstatic uint32_t authlen;\nstatic uint8_t *wpakptr;\nstatic wpakey_t *wpak;\nstatic uint16_t keyinfo;\nstatic uint16_t keylen;\n\neapauth = (eapauth_t*)eapauthptr;\nauthlen = ntohs(eapauth->len);\nif(authlen > eapauthlen)\n\t{\n\teapolmsgerrorcount++;\n\treturn;\n\t}\nwpakptr = eapauthptr +EAPAUTH_SIZE;\nwpak = (wpakey_t*)wpakptr;\nkeyinfo = (getkeyinfo(ntohs(wpak->keyinfo)));\nif(wpak->keydescriptor == EAP_KDT_RC4)\n\t{\n\tprocess80211rc4key();\n\treturn;\n\t}\nelse if(wpak->keydescriptor == EAP_KDT_WPA) eapolwpacount++;\nelse if(wpak->keydescriptor == EAP_KDT_RSN) eapolrsncount++;\nelse return;\nif(authlen < WPAKEY_SIZE)\n\t{\n\teapolmsgerrorcount++;\n\treturn;\n\t}\nkeylen = ntohs(wpak->keylen);\nif((keylen != 0) && (keylen != 16) && (keylen != 32))\n\t{\n\teapolmsgerrorcount++;\n\treturn;\n\t}\nif(keyinfo == 1) process80211eapol_m1(eaptimestamp, macto, macfm, macsrc, eapauthlen, eapauthptr);\nelse if(keyinfo == 2)\n\t{\n\tif(authlen != 0x5f) process80211eapol_m2(eaptimestamp, macto, macfm, macsrc, eapauthlen, eapauthptr);\n\telse process80211eapol_m4(eaptimestamp, macto, macfm, macsrc, eapauthlen, eapauthptr);\n\t}\nelse if(keyinfo == 3) process80211eapol_m3(eaptimestamp, macto, macfm, macsrc, eapauthlen, eapauthptr);\nelse if(keyinfo == 4) process80211eapol_m4(eaptimestamp, macto, macfm, macsrc, eapauthlen, eapauthptr);\n\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211eap(uint64_t eaptimestamp, uint8_t *macto, uint8_t *macfm, uint8_t *macsrc, uint32_t restlen, uint8_t *eapptr)\n{\nstatic eapauth_t *eapauth;\n\neapauth = (eapauth_t*)eapptr;\nif(restlen < (int)EAPAUTH_SIZE) return;\nif(eapauth->type == EAPOL_KEY)\n\t{\n\tprocess80211eapol(eaptimestamp, macto, macfm, macsrc, restlen, eapptr);\n\t}\nelse if(eapauth->type == EAP_PACKET) process80211exteap(eaptimestamp, macto, macfm, restlen, eapptr);\n//else if(eapauth->type == EAPOL_ASF) process80211exteap_asf();\n//else if(eapauth->type == EAPOL_MKA) process80211exteap_mka();\nelse if(eapauth->type == EAPOL_START)\n\t{\n\t}\nelse if(eapauth->type == EAPOL_START)\n\t{\n\t}\nelse if(eapauth->type == EAPOL_LOGOFF)\n\t{\n\t}\nif(fh_nmea != NULL) writegpwpl(macfm);\nreturn;\n}\n/*===========================================================================*/\nstatic bool cleanbackmac(void)\n{\nstatic int c;\nstatic maclist_t *zeiger;\n\nzeiger = aplistptr;\nfor(c = 0; c < 20; c ++)\n\t{\n\tzeiger--;\n\tif(zeiger < aplist) return false;\n\tif(zeiger->type != aplistptr->type) continue;\n\tif(zeiger->essidlen != aplistptr->essidlen) continue;\n\tif(memcmp(zeiger->addr, aplistptr->addr, 6) != 0) continue;\n\tif(memcmp(zeiger->essid, aplistptr->essid, aplistptr->essidlen) != 0) continue;\n\tzeiger->timestamp = aplistptr->timestamp;\n\tzeiger->count += 1;\n\tzeiger->status |= aplistptr->status;\n\tzeiger->type |= aplistptr->type;\n\tzeiger->groupcipher |= aplistptr->groupcipher;\n\tzeiger->cipher |= aplistptr->cipher;\n\tzeiger->akm |= aplistptr->akm;\n\tif(zeiger->manufacturerlen == 0)\n\t\t{\n\t\tmemcpy(zeiger->manufacturer, aplistptr->manufacturer, aplistptr->manufacturerlen);\n\t\tzeiger->manufacturerlen = aplistptr->manufacturerlen;\n\t\t}\n\tif(zeiger->modellen == 0)\n\t\t{\n\t\tmemcpy(zeiger->model, aplistptr->model, aplistptr->modellen);\n\t\tzeiger->modellen = aplistptr->modellen;\n\t\t}\n\tif(zeiger->serialnumberlen == 0)\n\t\t{\n\t\tmemcpy(zeiger->serialnumber, aplistptr->serialnumber, aplistptr->serialnumberlen);\n\t\tzeiger->serialnumberlen = aplistptr->serialnumberlen;\n\t\t}\n\tif(zeiger->devicenamelen == 0)\n\t\t{\n\t\tmemcpy(zeiger->devicename, aplistptr->devicename, aplistptr->devicenamelen);\n\t\tzeiger->devicenamelen = aplistptr->devicenamelen;\n\t\t}\n\tif(zeiger->enrolleelen == 0)\n\t\t{\n\t\tmemcpy(zeiger->enrollee, aplistptr->enrollee, aplistptr->enrolleelen);\n\t\tzeiger->enrolleelen = aplistptr->enrolleelen;\n\t\t}\n\treturn true;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic void process80211reassociation_req(uint64_t reassociationrequesttimestamp, uint8_t *macclient, uint8_t *macap, uint32_t reassociationrequestlen, uint8_t *reassociationrequestptr)\n{\nstatic int clientinfolen;\nstatic uint8_t *clientinfoptr;\nstatic maclist_t *aplistnew;\nstatic tags_t tags;\n\nreassociationrequestcount++;\nclientinfoptr = reassociationrequestptr +CAPABILITIESREQSTA_SIZE;\nclientinfolen = reassociationrequestlen -CAPABILITIESREQSTA_SIZE;\nif(clientinfolen < (int)IETAG_SIZE) return;\nif(gettags(clientinfolen, clientinfoptr, &tags) == false) return;\nif(tags.essidlen == 0) return;\nif(tags.essid[0] == 0) return;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nif(fh_nmea != NULL) writegpwpl(macclient);\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = reassociationrequesttimestamp;\naplistptr->count = 1;\naplistptr->type = AP;\nmemcpy(aplistptr->addr, macap, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\naplistptr->groupcipher = tags.groupcipher;\naplistptr->cipher = tags.cipher;\naplistptr->akm = tags.akm;\nif(ignoreieflag == true)\n\t{\n\tif(memcmp(&zeroed32, tags.pmkid, 16) != 0) addpmkid(reassociationrequesttimestamp, macclient, macap, tags.pmkid, PMKID_CLIENT);\n\t}\nelse if(((tags.akm &TAK_PSK) == TAK_PSK) || ((tags.akm &TAK_PSKSHA256) == TAK_PSKSHA256))\n\t{\n\tif(memcmp(&zeroed32, tags.pmkid, 16) != 0) addpmkid(reassociationrequesttimestamp, macclient, macap, tags.pmkid, PMKID_CLIENT);\n\t}\nelse if((tags.akm &TAK_FT_PSK) == TAK_FT_PSK) reassociationrequestftpskcount++;\n\nif((tags.akm &TAK_PSK) == TAK_PSK) reassociationrequestpskcount++;\nelse if((tags.akm &TAK_FT_PSK) == TAK_FT_PSK) reassociationrequestftpskcount++;\nelse if((tags.akm &TAK_PSKSHA256) == TAK_PSKSHA256) reassociationrequestpsk256count++;\nelse if((tags.akm &TAK_SAE_SHA256) == TAK_SAE_SHA256) reassociationrequestsae256count++;\nelse if((tags.akm &TAK_SAE_SHA384B) == TAK_SAE_SHA384B) reassociationrequestsae384bcount++;\nelse if((tags.akm &TAK_OWE) == TAK_OWE) reassociationrequestowecount++;\nif(cleanbackmac() == false) aplistptr++;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = reassociationrequesttimestamp;\naplistptr->count = 1;\naplistptr->status = ST_REASSOC_REQ;\naplistptr->type = CLIENT;\nmemcpy(aplistptr->addr, macclient, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\naplistptr->groupcipher = tags.groupcipher;\naplistptr->cipher = tags.cipher;\naplistptr->akm = tags.akm;\nif(cleanbackmac() == false) aplistptr++;\nif(fh_nmea != NULL) writegpwpl(macclient);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211association_req(uint64_t associationrequesttimestamp, uint8_t *macclient, uint8_t *macap, uint32_t associationrequestlen, uint8_t *associationrequestptr)\n{\nstatic int clientinfolen;\nstatic uint8_t *clientinfoptr;\nstatic maclist_t *aplistnew;\nstatic tags_t tags;\n\nassociationrequestcount++;\nclientinfoptr = associationrequestptr +CAPABILITIESSTA_SIZE;\nclientinfolen = associationrequestlen -CAPABILITIESSTA_SIZE;\nif(clientinfolen < (int)IETAG_SIZE) return;\nif(gettags(clientinfolen, clientinfoptr, &tags) == false) return;\nif(tags.essidlen == 0) return;\nif(tags.essid[0] == 0) return;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = associationrequesttimestamp;\naplistptr->count = 1;\naplistptr->status = ST_ASSOC_REQ;\naplistptr->type = AP;\nmemcpy(aplistptr->addr, macap, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\naplistptr->groupcipher = tags.groupcipher;\naplistptr->cipher = tags.cipher;\naplistptr->akm = tags.akm;\nif(ignoreieflag == true)\n\t{\n\tif(memcmp(&zeroed32, tags.pmkid, 16) != 0) addpmkid(associationrequesttimestamp, macclient, macap, tags.pmkid, PMKID_CLIENT);\n\t}\nelse if(((tags.akm &TAK_PSK) == TAK_PSK) || ((tags.akm &TAK_PSKSHA256) == TAK_PSKSHA256))\n\t{\n\tif(memcmp(&zeroed32, tags.pmkid, 16) != 0) addpmkid(associationrequesttimestamp, macclient, macap, tags.pmkid, PMKID_CLIENT);\n\t}\nif((tags.akm &TAK_PSK) == TAK_PSK) associationrequestpskcount++;\nelse if((tags.akm &TAK_FT_PSK) == TAK_FT_PSK) associationrequestftpskcount++;\nelse if((tags.akm &TAK_PSKSHA256) == TAK_PSKSHA256) associationrequestpsk256count++;\nelse if((tags.akm &TAK_SAE_SHA256) == TAK_SAE_SHA256) associationrequestsae256count++;\nelse if((tags.akm &TAK_SAE_SHA384B) == TAK_SAE_SHA384B) associationrequestsae384bcount++;\nelse if((tags.akm &TAK_OWE) == TAK_OWE) associationrequestowecount++;\nif(cleanbackmac() == false) aplistptr++;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = associationrequesttimestamp;\naplistptr->count = 1;\naplistptr->status = ST_ASSOC_REQ;\naplistptr->type = CLIENT;\nmemcpy(aplistptr->addr, macclient, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\naplistptr->groupcipher = tags.groupcipher;\naplistptr->cipher = tags.cipher;\naplistptr->akm = tags.akm;\nif(cleanbackmac() == false) aplistptr++;\nif(fh_nmea != NULL) writegpwpl(macclient);\nreturn;\n}\n/*===========================================================================*/\nstatic inline void process80211authentication(uint8_t *macfm, uint32_t authenticationlen, uint8_t *authenticationptr)\n{\nstatic authf_t *auth;\n\nauthenticationcount++;\nauth = (authf_t*)authenticationptr;\nif(authenticationlen < (int)AUTHENTICATIONFRAME_SIZE) return;\nif(auth->algorithm == OPEN_SYSTEM)\tauthopensystemcount++;\nelse if(auth->algorithm == SAE)\tauthseacount++;\nelse if(auth->algorithm == SHARED_KEY) authsharedkeycount++;\nelse if(auth->algorithm == FBT)\tauthfbtcount++;\nelse if(auth->algorithm == FILS) authfilscount++;\nelse if(auth->algorithm == FILSPFS) authfilspfs++;\nelse if(auth->algorithm == FILSPK) authfilspkcount++;\nelse if(auth->algorithm == NETWORKEAP) authnetworkeapcount++;\nelse authunknowncount++;\nif(fh_nmea != NULL) writegpwpl(macfm);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211probe_req_direct(uint64_t proberequesttimestamp, uint8_t *macclient, uint8_t *macap, uint32_t proberequestlen, uint8_t *proberequestptr)\n{\nstatic maclist_t *aplistnew;\nstatic tags_t tags;\n\nproberequestdirectedcount++;\nif(proberequestlen < (int)IETAG_SIZE) return;\nif(gettags(proberequestlen, proberequestptr, &tags) == false) return;\nif(tags.essidlen == 0) return;\nif(tags.essid[0] == 0) return;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = proberequesttimestamp;\naplistptr->count = 1;\naplistptr->status = ST_PROBE_REQ;\naplistptr->type = AP;\nmemcpy(aplistptr->addr, macap, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\nif(cleanbackmac() == false) aplistptr++;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = proberequesttimestamp;\naplistptr->count = 1;\naplistptr->status = ST_PROBE_REQ;\naplistptr->type = CLIENT;\nmemcpy(aplistptr->addr, macclient, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\nif(cleanbackmac() == false) aplistptr++;\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211probe_req(uint64_t proberequesttimestamp, uint8_t *macclient, uint32_t proberequestlen, uint8_t *proberequestptr)\n{\nstatic maclist_t *aplistnew;\nstatic tags_t tags;\n\nproberequestundirectedcount++;\nif(proberequestlen < (int)IETAG_SIZE) return;\nif(gettags(proberequestlen, proberequestptr, &tags) == false) return;\nif(tags.essidlen == 0) return;\nif(tags.essid[0] == 0) return;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = proberequesttimestamp;\naplistptr->count = 1;\naplistptr->status = ST_PROBE_REQ;\naplistptr->type = CLIENT;\nmemcpy(aplistptr->addr, macclient, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\nif(cleanbackmac() == false) aplistptr++;\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211probe_resp(uint64_t proberesponsetimestamp, uint8_t *macap, uint32_t proberesponselen, uint8_t *proberesponseptr)\n{\nstatic size_t i;\nstatic int apinfolen;\nstatic maclist_t *aplistnew;\nstatic uint8_t *apinfoptr;\nstatic time_t tvproberesponse;\nstatic tags_t tags;\nstatic bool naf;\n\nproberesponsecount++;\napinfoptr = proberesponseptr +CAPABILITIESAP_SIZE;\napinfolen = proberesponselen -CAPABILITIESAP_SIZE;\nif(proberesponselen < (int)IETAG_SIZE) return;\nif(gettags(apinfolen, apinfoptr, &tags) == false) return;\nif(tags.essidlen == 0)\n\t{\n\tproberesponsessidunsetcount++;\n\treturn;\n\t}\nif(tags.essidlen > 32)\n\t{\n\tbeaconssidoversizedcount++;\n\treturn;\n\t}\nif(memcmp(&tags.essid, &zeroed32, tags.essidlen) == 0)\n\t{\n\tproberesponsessidzeroedcount++;\n\treturn;\n\t}\nif(tags.essid[0] == 0) return;\nif(fh_lts != NULL)\n\t{\n\tif(tags.essidlen > 0) \n\t\t{\n\t\tnaf = false;\n\t\tfor(i = 0; i < tags.essidlen; i++)\n\t\t\t{\n\t\t\tif(tags.essid[i] < 0x20)\n\t\t\t\t{\n\t\t\t\tnaf = true;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif(naf == false)\n\t\t\t{\n\t\t\ttvproberesponse = proberesponsetimestamp /1000000000;\n\t\t\tfprintf(fh_lts, \"%ld\\t%d\\t%02x%02x%02x%02x%02x%02x\\t%.*s\\n\", tvproberesponse, rssi, macap[0], macap[1], macap[2], macap[3], macap[4], macap[5], tags.essidlen, tags.essid);\n\t\t\t}\n\t\t}\n\t}\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = proberesponsetimestamp;\naplistptr->count = 1;\naplistptr->status = ST_PROBE_RESP;\naplistptr->type = AP;\nmemcpy(aplistptr->addr, macap, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\naplistptr->groupcipher = tags.groupcipher;\naplistptr->cipher = tags.cipher;\naplistptr->akm = tags.akm;\naplistptr->manufacturerlen = tags.manufacturerlen;\nmemcpy(aplistptr->manufacturer, tags.manufacturer, tags.manufacturerlen);\naplistptr->modellen = tags.modellen;\nmemcpy(aplistptr->model, tags.model, tags.modellen);\naplistptr->serialnumberlen = tags.serialnumberlen;\nmemcpy(aplistptr->serialnumber, tags.serialnumber, tags.serialnumberlen);\naplistptr->devicenamelen = tags.devicenamelen;\nmemcpy(aplistptr->devicename, tags.devicename, tags.devicenamelen);\naplistptr->enrolleelen = tags.enrolleelen;\nmemcpy(aplistptr->enrollee, tags.enrollee, tags.enrolleelen);\nif(fh_csv != NULL) writecsv(proberesponsetimestamp, macap, &tags);\nif(cleanbackmac() == false) aplistptr++;\nif(fh_nmea != NULL) writegpwpl(macap);\nreturn;\n}\n/*===========================================================================*/\nstatic inline bool processpag(uint8_t *macap, int vendorlen, uint8_t *ieptr)\n{\nstatic int c, p;\nstatic const uint8_t mac_pwag[6] =\n{\n0xde, 0xad, 0xbe, 0xef, 0xde, 0xad\n};\n\nif(ieptr[1] != 0xff) return false;\nif(vendorlen <= 0x78) return false;\nif(memcmp(&mac_pwag, macap, 6) != 0) return false;\nfor(p = 2; p < vendorlen -75 ; p++)\n\t{\n\tif(memcmp(&ieptr[p], \"identity\", 8) == 0)\n\t\t{\n\t\tfor(c = 0; c < 64; c++)\n\t\t\t{\n\t\t\tif(!isxdigit((unsigned char)ieptr[p +11 +c])) return false;\n\t\t\t}\n\t\tpagcount++;\n\t\treturn true;\n\t\t}\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic void process80211beacon(uint64_t beacontimestamp, uint8_t *macbc, uint8_t *macap, uint32_t beaconlen, uint8_t *beaconptr)\n{\nstatic size_t i;\nstatic int apinfolen;\nstatic uint8_t *apinfoptr;\nstatic time_t tvbeacon;\nstatic maclist_t *aplistnew;\nstatic tags_t tags;\nstatic bool naf;\n\nbeaconcount++;\nif(memcmp(&mac_broadcast, macbc, 6) != 0)\n\t{\n\tbroadcastmacerrorcount++;\n\treturn;\n\t}\napinfoptr = beaconptr +CAPABILITIESAP_SIZE;\napinfolen = beaconlen -CAPABILITIESAP_SIZE;\nif(apinfoptr[0] == TAG_PAG)\n\t{\n\tif(processpag(macap, apinfolen, apinfoptr) == true) return;\n\t}\nif(beaconlen < (int)IETAG_SIZE)\n\t{\n\tbeaconerrorcount++;\n\treturn;\n\t}\nif(gettags(apinfolen, apinfoptr, &tags) == false)\n\t{\n\tbeaconerrorcount++;\n\tif(tags.essidlen > 32) beaconssidoversizedcount++;\n\treturn;\n\t}\nif(tags.essidlen == 0)\n\t{\n\tbeaconssidunsetcount++;\n\treturn;\n\t}\nif(memcmp(&tags.essid, &zeroed32, tags.essidlen) == 0)\n\t{\n\tbeaconssidzeroedcount++;\n\treturn;\n\t}\nif(fh_lts != NULL)\n\t{\n\tif((tags.essidlen > 0) && (tags.essidlen <= 32) && (tags.essid[0] != 0)) \n\t\t{\n\t\tnaf = false;\n\t\tfor(i = 0; i < tags.essidlen; i++)\n\t\t\t{\n\t\t\tif(tags.essid[i] < 0x20)\n\t\t\t\t{\n\t\t\t\tnaf = true;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif(naf == false)\n\t\t\t{\n\t\t\ttvbeacon = beacontimestamp /1000000000;\n\t\t\tfprintf(fh_lts, \"%ld\\t%d\\t%02x%02x%02x%02x%02x%02x\\t%.*s\\n\", tvbeacon, rssi, macap[0], macap[1], macap[2], macap[3], macap[4], macap[5], tags.essidlen, tags.essid);\n\t\t\t}\n\t\t}\n\t}\nif((tags.channel > 0) && (tags.channel <= 14))\n\t{\n\tbeaconchannel[0] |= GHZ24;\n\tbeaconchannel[tags.channel]++;\n\t}\nif((tags.channel > 14) && (tags.channel < CHANNEL_MAX))\n\t{\n\tbeaconchannel[0] |= GHZ5;\n\tbeaconchannel[tags.channel]++;\n\t}\nif(tags.essid[0] == 0) return;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = beacontimestamp;\naplistptr->count = 1;\naplistptr->status = ST_BEACON;\naplistptr->type = AP;\nmemcpy(aplistptr->addr, macap, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\naplistptr->groupcipher = tags.groupcipher;\naplistptr->cipher = tags.cipher;\naplistptr->akm = tags.akm;\naplistptr->manufacturerlen = tags.manufacturerlen;\nmemcpy(aplistptr->manufacturer, tags.manufacturer, tags.manufacturerlen);\naplistptr->modellen = tags.modellen;\nmemcpy(aplistptr->model, tags.model, tags.modellen);\naplistptr->serialnumberlen = tags.serialnumberlen;\nmemcpy(aplistptr->serialnumber, tags.serialnumber, tags.serialnumberlen);\naplistptr->devicenamelen = tags.devicenamelen;\nmemcpy(aplistptr->devicename, tags.devicename, tags.devicenamelen);\naplistptr->enrolleelen = tags.enrolleelen;\nmemcpy(aplistptr->enrollee, tags.enrollee, tags.enrolleelen);\nif(fh_csv != NULL) writecsv(beacontimestamp, macap, &tags);\nif(cleanbackmac() == false) aplistptr++;\nif(fh_nmea != NULL) writegpwpl(macap);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211actionmeasurement(uint64_t actiontimestamp, uint8_t *macclient, uint32_t packetlen, uint8_t *packetptr)\n{\nstatic maclist_t *aplistnew;\nstatic tags_t tags;\nstatic actmm_t *actmm;\n\nif(packetlen < ACTIONMEASUREMENTFRAME_SIZE) return;\nactmm = (actmm_t*)packetptr;\nif(actmm->actioncode != ACT_MM_NRREQ) return;\npacketlen -= (int)ACTIONMEASUREMENTFRAME_SIZE;\npacketptr += (int)ACTIONMEASUREMENTFRAME_SIZE;\nif(packetlen < (int)IETAG_SIZE) return;\nif(gettags(packetlen, packetptr, &tags) == false) return;\nif(tags.essidlen == 0) return;\nif(tags.essid[0] == 0) return;\nif(aplistptr >= aplist +maclistmax)\n\t{\n\taplistnew = (maclist_t*)realloc(aplist, (maclistmax +MACLIST_MAX) *MACLIST_SIZE);\n\tif(aplistnew == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory for internal list\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\taplist = aplistnew;\n\taplistptr = aplistnew +maclistmax;\n\tmaclistmax += MACLIST_MAX;\n\t}\nmemset(aplistptr, 0, MACLIST_SIZE);\naplistptr->timestamp = actiontimestamp;\naplistptr->count = 1;\naplistptr->status = ST_ACT_MR_REQ;\naplistptr->type = CLIENT;\nmemcpy(aplistptr->addr, macclient, 6);\naplistptr->essidlen = tags.essidlen;\nmemcpy(aplistptr->essid, tags.essid, tags.essidlen);\nif(cleanbackmac() == false) aplistptr++;\nactionessidcount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211actionvendor(uint32_t packetlen, uint8_t *packetptr)\n{\nstatic actvf_t *actvf;\n\nif(packetlen < ACTIONVENDORFRAME_SIZE) return;\nactvf = (actvf_t*)packetptr;\nif(memcmp(actvf->vendor, &ouiapple, 3) == 0) awdlcount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211action(uint64_t actiontimestamp, uint8_t *macclient, uint32_t packetlen, uint8_t *packetptr)\n{\nstatic actf_t *actf;\n\nif(packetlen < ACTIONFRAME_SIZE) return;\nactf = (actf_t*)packetptr;\nactioncount++;\nif(actf->categoriecode == CAT_VENDOR) process80211actionvendor(packetlen, packetptr);\nelse if(actf->categoriecode == CAT_RADIO_MEASUREMENT) process80211actionmeasurement(actiontimestamp, macclient, packetlen, packetptr);\nreturn;\n}\n/*===========================================================================*/\nstatic void process80211packet(uint64_t packetimestamp, uint32_t packetlen, uint8_t *packetptr)\n{\nstatic mac_t *macfrx;\nstatic uint32_t payloadlen;\nstatic uint8_t *payloadptr;\nstatic uint8_t *llcptr;\nstatic llc_t *llc;\nstatic uint8_t *mpduptr;\nstatic mpdu_t *mpdu;\n\nieee80211flag = true;\n\nif(packetlen < (int)MAC_SIZE_NORM) return;\nmacfrx = (mac_t*)packetptr;\n\nif((macfrx->from_ds == 1) && (macfrx->to_ds == 1))\n\t{\n\tpayloadptr = packetptr +MAC_SIZE_LONG;\n\tpayloadlen = packetlen -MAC_SIZE_LONG;\n\twdscount++;\n\t}\nelse\n\t{\n\tpayloadptr = packetptr +MAC_SIZE_NORM;\n\tpayloadlen = packetlen -MAC_SIZE_NORM;\n\t}\nif(macfrx->type == IEEE80211_FTYPE_MGMT)\n\t{\n\tif(macfrx->subtype == IEEE80211_STYPE_BEACON) process80211beacon(packetimestamp, macfrx->addr1, macfrx->addr2, payloadlen, payloadptr);\n\telse if(macfrx->subtype == IEEE80211_STYPE_PROBE_RESP) process80211probe_resp(packetimestamp, macfrx->addr2, payloadlen, payloadptr);\n\telse if(macfrx->subtype == IEEE80211_STYPE_AUTH) process80211authentication(macfrx->addr2, payloadlen, payloadptr);\n\telse if(macfrx->subtype == IEEE80211_STYPE_ASSOC_REQ) process80211association_req(packetimestamp, macfrx->addr2, macfrx->addr1, payloadlen, payloadptr);\n\telse if(macfrx->subtype == IEEE80211_STYPE_REASSOC_REQ) process80211reassociation_req(packetimestamp, macfrx->addr2, macfrx->addr1, payloadlen, payloadptr);\n\telse if(macfrx->subtype == IEEE80211_STYPE_PROBE_REQ)\n\t\t{\n\t\tif(memcmp(&mac_broadcast, macfrx->addr1, 6) == 0) process80211probe_req(packetimestamp, macfrx->addr2, payloadlen, payloadptr);\n\t\telse process80211probe_req_direct(packetimestamp, macfrx->addr2, macfrx->addr1, payloadlen, payloadptr);\n\t\t}\n\telse if(macfrx->subtype == IEEE80211_STYPE_ACTION) process80211action(packetimestamp, macfrx->addr2, payloadlen, payloadptr);\n\telse if(macfrx->subtype == IEEE80211_STYPE_DEAUTH)\n\t\t{\n\t\tif(macfrx->retry == 0) deauthenticationcount++;\n\t\t}\n\telse if(macfrx->subtype == IEEE80211_STYPE_DISASSOC)\n\t\t{\n\t\tif(macfrx->retry == 0) disassociationcount++;\n\t\t}\n\telse if(macfrx->subtype == IEEE80211_STYPE_MGTRESERVED) mgtreservedcount++;\n\t}\nelse if(macfrx->type == IEEE80211_FTYPE_DATA)\n\t{\n\tif((macfrx->subtype &IEEE80211_STYPE_QOS_DATA) == IEEE80211_STYPE_QOS_DATA)\n\t\t{\n\t\tpayloadptr += QOS_SIZE;\n\t\tpayloadlen -= QOS_SIZE;\n\t\t}\n\tif(payloadlen < (int)LLC_SIZE) return;\n\tllcptr = payloadptr;\n\tllc = (llc_t*)llcptr;\n\tif(((ntohs(llc->type)) == LLC_TYPE_AUTH) && (llc->dsap == LLC_SNAP) && (llc->ssap == LLC_SNAP))\n\t\t{\n\t\tprocess80211eap(packetimestamp, macfrx->addr1, macfrx->addr2, macfrx->addr3, payloadlen -LLC_SIZE, payloadptr +LLC_SIZE);\n\t\t}\n\telse if(((ntohs(llc->type)) == LLC_TYPE_IPV4) && (llc->dsap == LLC_SNAP) && (llc->ssap == LLC_SNAP))\n\t\t{\n\t\tprocessipv4(packetimestamp, payloadlen -LLC_SIZE, payloadptr +LLC_SIZE);\n\t\t}\n\telse if(((ntohs(llc->type)) == LLC_TYPE_IPV6) && (llc->dsap == LLC_SNAP) && (llc->ssap == LLC_SNAP))\n\t\t{\n\t\tprocessipv6(packetimestamp, payloadlen -LLC_SIZE, payloadptr +LLC_SIZE);\n\t\t}\n\telse if(macfrx->prot ==1)\n\t\t{\n\t\tmpduptr = payloadptr;\n\t\tmpdu = (mpdu_t*)mpduptr;\n\t\tif(((mpdu->keyid >> 5) &1) == 1) wpaenccount++;\n\t\telse if(((mpdu->keyid >> 5) &1) == 0) wepenccount++;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processethernetpacket(uint64_t timestamp, uint32_t caplen, uint8_t *packetptr)\n{\nstatic eth2_t *eth2;\n\nif(caplen < LLC_SIZE) return;\neth2 = (eth2_t*)packetptr;\nif(ntohs(eth2->ether_type) == LLC_TYPE_IPV4)\n\t{\n\tprocessipv4(timestamp, caplen -ETH2_SIZE, packetptr +ETH2_SIZE);\n\t}\nelse if(ntohs(eth2->ether_type) == LLC_TYPE_IPV6)\n\t{\n\tprocessipv6(timestamp, caplen -ETH2_SIZE, packetptr +ETH2_SIZE);\n\t}\n/*\nif(ntohs(eth2->ether_type) == LLC_TYPE_AUTH)\n\t{\n\tprocess80211networkauthentication(tv_sec, tv_usec, caplen, eth2->addr1, eth2->addr2, packet_ptr);\n\t}\n*/\nreturn;\n}\n/*===========================================================================*/\nstatic void processlobapacket(uint64_t timestamp, uint32_t caplen, uint8_t *packetptr)\n{\nstatic loba_t *loba;\nif(caplen < LOBA_SIZE) return;\nloba = (loba_t*)packetptr;\n#ifdef BIG_ENDIAN_HOST\nloba->family = byte_swap_32(loba->family);\n#endif\nif(loba->family == LOBA_IPV4) processipv4(timestamp, caplen -LOBA_SIZE, packetptr +LOBA_SIZE);\nelse if(loba->family == LOBA_IPV624) processipv6(timestamp, caplen -LOBA_SIZE, packetptr +LOBA_SIZE);\nelse if(loba->family == LOBA_IPV628) processipv6(timestamp, caplen -LOBA_SIZE, packetptr +LOBA_SIZE);\nelse if(loba->family == LOBA_IPV630) processipv6(timestamp, caplen -LOBA_SIZE, packetptr +LOBA_SIZE);\nreturn;\n}\n/*===========================================================================*/\nstatic bool getradiotapfield(uint16_t rthlen, uint8_t *capptr)\n{\nstatic int i;\nstatic uint16_t pf;\nstatic rth_t *rth;\nstatic uint32_t *pp;\n\nfrequency = 0;\nrth = (rth_t*)capptr;\npf = RTH_SIZE;\nif((rth->it_present & IEEE80211_RADIOTAP_EXT) == IEEE80211_RADIOTAP_EXT)\n\t{\n\tpp = (uint32_t*)capptr;\n\tfor(i = 2; i < rthlen /4; i++)\n\t\t{\n\t\t#ifdef BIG_ENDIAN_HOST\n\t\tpp[i] = byte_swap_32(pp[i]);\n\t\t#endif\n\t\tpf += 4;\n\t\tif((pp[i] & IEEE80211_RADIOTAP_EXT) != IEEE80211_RADIOTAP_EXT) break;\n\t\t}\n\t}\nif((rth->it_present & IEEE80211_RADIOTAP_TSFT) == IEEE80211_RADIOTAP_TSFT)\n\t{\n\tif(pf > rthlen) return false;\n\tif((pf %8) != 0) pf += 4;\n\tpf += 8;\n\t}\nif((rth->it_present & IEEE80211_RADIOTAP_FLAGS) == IEEE80211_RADIOTAP_FLAGS)\n\t{\n\tif(pf > rthlen) return false;\n\tif((capptr[pf] & 0x50) == 0x50)\n\t\t{\n\t\tfcsbadframecount++;\n\t\tif(donotcleanflag == false) return false;\n\t\t}\n\telse if((capptr[pf] & 0x50) == 0x10)\n\t\t{\n\t\tfcsframecount++;\n\t\t}\n\tpf += 1;\n\t}\nif((rth->it_present & IEEE80211_RADIOTAP_RATE) == IEEE80211_RADIOTAP_RATE) pf += 1;\nif((rth->it_present & IEEE80211_RADIOTAP_CHANNEL) == IEEE80211_RADIOTAP_CHANNEL)\n\t{\n\tif(pf > rthlen) return false;\n\tif((pf %2) != 0) pf += 1;\n\tfrequency = (capptr[pf +1] << 8) + capptr[pf];\n\tusedfrequency[frequency] += 1;\n\tif(frequency == 2484)\n\t\t{\n\t\tinterfacechannel = 14;\n\t\tband24count++;\n\t\t}\n\telse if(frequency < 2484)\n\t\t{\n\t\tinterfacechannel = (frequency -2407)/5;\n\t\tband24count++;\n\t\t}\n\telse if(frequency >= 4910 && frequency <= 4980) \n\t\t{\n\t\tinterfacechannel = (frequency - 4000)/5;\n\t\tband5count++;\n\t\t}\n\telse if(frequency < 5925)\n\t\t{\n\t\tinterfacechannel = (frequency -5000)/5;\n\t\tband5count++;\n\t\t}\n\telse if(frequency == 5935)\n\t\t{\n\t\tinterfacechannel = 2;\n\t\tband6count++;\n\t\t}\n\telse if((frequency >= 5955) && (frequency <= 7115))\n\t\t{\n\t\tinterfacechannel = (frequency -5950)/5;\n\t\tband6count++;\n\t\t}\n\tpf += 4;\n\t}\nif((rth->it_present & IEEE80211_RADIOTAP_FHSS) == IEEE80211_RADIOTAP_FHSS)\n\t\t{\n\t\tif((pf %2) != 0) pf += 1;\n\t\tpf += 2;\n\t\t}\nif((rth->it_present & IEEE80211_RADIOTAP_DBM_ANTSIGNAL) == IEEE80211_RADIOTAP_DBM_ANTSIGNAL)\n\t{\n\tif(pf > rthlen)\n\t\t{\n\t\tif(donotcleanflag == false) return false;\n\t\treturn true;\n\t\t}\n\trssi = capptr[pf];\n\t}\nreturn true;\n}\n/*===========================================================================*/\nstatic void processlinktype(uint64_t captimestamp, uint32_t linktype, uint32_t caplen, uint8_t *capptr)\n{\nstatic uint8_t cs;\nstatic uint32_t p;\nstatic rth_t *rth;\nstatic uint32_t packetlen;\nstatic uint8_t *packetptr;\nstatic ppi_t *ppi;\nstatic prism_t *prism;\nstatic avs_t *avs;\nstatic fcs_t *fcs;\nstatic uint32_t crc;\n\nrssi = 0;\ninterfacechannel = 0;\nif(fh_raw_out != NULL)\n\t{\n\tcs = captimestamp &0xff;\n\tcs ^= (captimestamp >> 8) &0xff;\n\tcs ^= (captimestamp >> 16) &0xff;\n\tcs ^= (captimestamp >> 24) &0xff;\n\tcs ^= (captimestamp >> 32) &0xff;\n\tcs ^= (captimestamp >> 40) &0xff;\n\tcs ^= (captimestamp >> 48) &0xff;\n\tcs ^= (captimestamp >> 56) &0xff;\n\tcs ^= linktype &0xff;\n\tcs ^= (linktype >> 8) &0xff;\n\tcs ^= (linktype >> 16) &0xff;\n\tcs ^= (linktype >> 24) &0xff;\n\t#ifndef BIG_ENDIAN_HOST\n\tfprintf(fh_raw_out, \"%016\" PRIx64 \"*%08x*\", captimestamp, linktype);\n\t#else\n\tfprintf(fh_raw_out, \"%016\" PRIx64 \"*%08x*\", byte_swap_64(captimestamp), byte_swap_32(linktype));\n\t#endif\n\tfor(p = 0; p < caplen; p++)\n\t\t{\n\t\tfprintf(fh_raw_out, \"%02x\", capptr[p]);\n\t\tcs ^= capptr[p];\n\t\t}\n\tfprintf(fh_raw_out, \"*%02x\\n\", cs);\n\t}\n\nif(captimestamp < captimestampold) sequenceerrorcount++;\ncaptimestampold = captimestamp;\nif(timestampmin == 0) timestampmin = captimestamp;\nif(timestampmin > captimestamp) timestampmin = captimestamp;\nif(timestampmax < captimestamp) timestampmax = captimestamp;\nif(captimestamp == 0)\n\t{\n\tcaptimestamp = timestampstart;\n\ttimestampstart += (eapoltimeoutvalue -2);\n\tzeroedtimestampcount++;\n\t}\nif(linktype == DLT_IEEE802_11_RADIO)\n\t{\n\tif(caplen < RTH_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tradiotaperrorcount++;\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read radiotap header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\trth = (rth_t*)capptr;\n\t#ifdef BIG_ENDIAN_HOST\n\trth->it_len = byte_swap_16(rth->it_len);\n\trth->it_present = byte_swap_32(rth->it_present);\n\t#endif\n\tif(rth->it_len >= caplen)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tradiotaperrorcount++;\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read radiotap header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tif(rth->it_version != 0)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tradiotaperrorcount++;\n\t\tif(fh_log != NULL) fprintf(fh_log, \"unsupported radiotap header version: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tif(getradiotapfield(rth->it_len, capptr) == false)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tradiotaperrorcount++;\n\t\treturn;\n\t\t}\n\tpacketlen = caplen -rth->it_len;\n\tpacketptr = capptr +rth->it_len;\n\t}\nelse if(linktype == DLT_IEEE802_11)\n\t{\n\tpacketptr = capptr;\n\tpacketlen = caplen;\n\t}\nelse if(linktype == DLT_PPI)\n\t{\n\tif(caplen < PPI_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read ppi header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read ppi header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tppi = (ppi_t*)capptr;\n\t#ifdef BIG_ENDIAN_HOST\n\tppi->pph_len = byte_swap_16(ppi->pph_len);\n\t#endif\n\tif(ppi->pph_len > caplen)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read ppi header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read ppi header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tpacketlen = caplen -ppi->pph_len;\n\tpacketptr = capptr +ppi->pph_len;\n\t}\nelse if(linktype == DLT_PRISM_HEADER)\n\t{\n\tif(caplen < PRISM_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read prism header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read prism header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tprism = (prism_t*)capptr;\n\t#ifdef BIG_ENDIAN_HOST\n\tprism->msgcode = byte_swap_32(prism->msgcode);\n\tprism->msglen = byte_swap_32(prism->msglen);\n\tprism->frmlen.data = byte_swap_32(prism->frmlen.data);\n\t#endif\n\tif(prism->msglen > caplen)\n\t\t{\n\t\tif(prism->frmlen.data > caplen)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"failed to read prism header\\n\");\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read prism header: %ld\\n\", rawpacketcount);\n\t\t\treturn;\n\t\t\t}\n\t\tprism->msglen = caplen -prism->frmlen.data;\n\t\t}\n\tpacketlen = caplen -prism->msglen;\n\tpacketptr = capptr +prism->msglen;\n\t}\nelse if(linktype == DLT_IEEE802_11_RADIO_AVS)\n\t{\n\tif(caplen < AVS_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read avs header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read avs header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tavs = (avs_t*)capptr;\n\t#ifdef BIG_ENDIAN_HOST\n\tavs->len = byte_swap_32(avs->len);\n\t#endif\n\tif(avs->len > caplen)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read avs header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read avs header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tpacketlen = caplen -avs->len;\n\tpacketptr = capptr +avs->len;\n\t}\nelse if(linktype == DLT_EN10MB)\n\t{\n\tif(caplen < ETH2_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read ethernet header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read ethernet header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tprocessethernetpacket(captimestamp, caplen, capptr);\n\treturn;\n\t}\nelse if(linktype == DLT_NULL)\n\t{\n\tif(caplen < LOBA_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read loopback header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read loopback header: %ld\\n\", rawpacketcount);\n\t\treturn;\n\t\t}\n\tprocesslobapacket(captimestamp, caplen, capptr);\n\treturn;\n\t}\nelse\n\t{\n\tfprintf(stdout, \"unsupported network type %d\\n\", linktype);\n\tif(fh_log != NULL) fprintf(fh_log, \"unsupported network type %d: %ld\\n\", linktype, rawpacketcount);\n\treturn;\n\t}\n\nif(packetlen < 4)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"failed to read packet\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"failed to read packet (len < 4): %ld\\n\", rawpacketcount);\n\treturn;\n\t}\nfcs = (fcs_t*)(packetptr +packetlen -4);\ncrc = fcscrc32check(packetptr, packetlen -4);\n#ifdef BIG_ENDIAN_HOST\ncrc = byte_swap_32(crc);\n#endif\nif(crc == fcs->fcs)\n\t{\n\tfcsgoodframecount++;\n\tpacketlen -= 4;\n\t}\nprocess80211packet(captimestamp, packetlen, packetptr);\nreturn;\n}\n/*===========================================================================*/\nvoid processcap(int fd, char *eigenname, char *pcaporgname, char *pcapinname)\n{\nstatic unsigned int res;\nstatic off_t resseek;\nstatic pcap_hdr_t pcapfhdr;\nstatic pcaprec_hdr_t pcaprhdr;\nstatic uint64_t timestampcap;\nstatic uint8_t packet[MAXPACPSNAPLEN];\n\nancientdumpfileformat = true;\nmagicblockcount = 0;\nfprintf(stdout, \"%s %s reading from %s...\\n\", basename(eigenname), VERSION_TAG, basename(pcapinname));\niface = 1;\nres = read(fd, &pcapfhdr, PCAPHDR_SIZE);\nif(res != PCAPHDR_SIZE)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"failed to read pcap header\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"failed to read pcap header: %s\\n\", basename(pcapinname));\n\treturn;\n\t}\n\n#ifdef BIG_ENDIAN_HOST\npcapfhdr.magic_number\t= byte_swap_32(pcapfhdr.magic_number);\npcapfhdr.version_major\t= byte_swap_16(pcapfhdr.version_major);\npcapfhdr.version_minor\t= byte_swap_16(pcapfhdr.version_minor);\npcapfhdr.thiszone\t= byte_swap_32(pcapfhdr.thiszone);\npcapfhdr.sigfigs\t= byte_swap_32(pcapfhdr.sigfigs);\npcapfhdr.snaplen\t= byte_swap_32(pcapfhdr.snaplen);\npcapfhdr.network\t= byte_swap_32(pcapfhdr.network);\n#endif\n\nif(pcapfhdr.magic_number == PCAPMAGICNUMBERBE)\n\t{\n\tpcapfhdr.magic_number\t= byte_swap_32(pcapfhdr.magic_number);\n\tpcapfhdr.version_major\t= byte_swap_16(pcapfhdr.version_major);\n\tpcapfhdr.version_minor\t= byte_swap_16(pcapfhdr.version_minor);\n\tpcapfhdr.thiszone\t= byte_swap_32(pcapfhdr.thiszone);\n\tpcapfhdr.sigfigs\t= byte_swap_32(pcapfhdr.sigfigs);\n\tpcapfhdr.snaplen\t= byte_swap_32(pcapfhdr.snaplen);\n\tpcapfhdr.network\t= byte_swap_32(pcapfhdr.network);\n\tendianness = 1;\n\t}\n\nversionmajor = pcapfhdr.version_major;\nversionminor = pcapfhdr.version_minor;\n\ndltlinktype[0] = pcapfhdr.network;\nif(pcapfhdr.version_major != PCAP_MAJOR_VER)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"unsupported major pcap version\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"unsupported major pcap version: %d\\n\", pcapfhdr.version_major);\n\treturn;\n\t}\nif(pcapfhdr.version_minor != PCAP_MINOR_VER)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"unsupported minor pcap version\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"unsupported minor pcap version: %d\\n\", pcapfhdr.version_minor);\n\treturn;\n\t}\nif(pcapfhdr.snaplen > MAXPACPSNAPLEN)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"detected oversized snaplen (%d)\\n\", pcapfhdr.snaplen);\n\tif(fh_log != NULL) fprintf(fh_log, \"detected oversized snaplen (%d): %d\\n\", pcapfhdr.snaplen, pcapfhdr.version_minor);\n\t}\n\nwhile(1)\n\t{\n\tres = read(fd, &pcaprhdr, PCAPREC_SIZE);\n\tif(res == 0) break;\n\tif(res != PCAPREC_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read pcap packet header for packet %ld\\n\", rawpacketcount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read pcap packet header: %ld\\n\", rawpacketcount);\n\t\tbreak;\n\t\t}\n\n\t#ifdef BIG_ENDIAN_HOST\n\tpcaprhdr.ts_sec\t\t= byte_swap_32(pcaprhdr.ts_sec);\n\tpcaprhdr.ts_usec\t= byte_swap_32(pcaprhdr.ts_usec);\n\tpcaprhdr.incl_len\t= byte_swap_32(pcaprhdr.incl_len);\n\tpcaprhdr.orig_len\t= byte_swap_32(pcaprhdr.orig_len);\n\t#endif\n\tif(endianness == 1)\n\t\t{\n\t\tpcaprhdr.ts_sec\t\t= byte_swap_32(pcaprhdr.ts_sec);\n\t\tpcaprhdr.ts_usec\t= byte_swap_32(pcaprhdr.ts_usec);\n\t\tpcaprhdr.incl_len\t= byte_swap_32(pcaprhdr.incl_len);\n\t\tpcaprhdr.orig_len\t= byte_swap_32(pcaprhdr.orig_len);\n\t\t}\n\tif(pcaprhdr.incl_len > pcapfhdr.snaplen)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tif(fh_log != NULL) fprintf(fh_log, \"inclusive length > snaplen: %ld\\n\", rawpacketcount);\n\t\t}\n\tif(pcaprhdr.incl_len < MAXPACPSNAPLEN)\n\t\t{\n\t\trawpacketcount++;\n\t\tres = read(fd, &packet, pcaprhdr.incl_len);\n\t\tif(res != pcaprhdr.incl_len)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"failed to read packet %ld\\n\", rawpacketcount);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"packet error: %ld\\n\", rawpacketcount);\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tskippedpacketcount++;\n\t\tresseek = lseek(fd, pcaprhdr.incl_len, SEEK_CUR);\n\t\tif(resseek < 0)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"failed to set file pointer\\n\");\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to set file pointer: %s\\n\", basename(pcapinname));\n\t\t\tbreak;\n\t\t\t}\n\t\tcontinue;\n\t\t}\n\tif(pcaprhdr.incl_len > 0)\n\t\t{\n\t\ttimestampcap = ((uint64_t)pcaprhdr.ts_sec *1000000) + pcaprhdr.ts_usec;\n\t\ttimestampcap *= 1000;\n\t\tprocesslinktype(timestampcap, pcapfhdr.network, pcaprhdr.incl_len, packet);\n\t\t}\n\t}\n\nfprintf(stdout, \"\\nsummary capture file\\n\"\n\t\"--------------------\\n\"\n\t\"file name................................: %s\\n\"\n\t\"version (pcap/cap).......................: %d.%d (very basic format without any additional information)\\n\"\n\t, basename(pcaporgname), versionmajor, versionminor\n\t);\nprintlinklayerinfo();\ncleanupmac();\noutputdeviceinfolist();\noutputwpalists();\noutputeapmd5hashlist();\noutputeapleaphashlist();\noutputeapmschapv2hashlist();\noutputtacacsplist();\noutputwordlists();\nprintcontentinfo();\nreturn;\n}\n/*===========================================================================*/\nstatic int pcapngoptionwalk(uint32_t blocktype, uint8_t *optr, int restlen)\n{\nstatic int csn, csc, pn;\nstatic int padding;\nstatic option_header_t *option;\n\nwhile(0 < restlen)\n\t{\n\toption = (option_header_t*)optr;\n\t#ifdef BIG_ENDIAN_HOST\n\toption->option_code = byte_swap_16(option->option_code);\n\toption->option_length = byte_swap_16(option->option_length);\n\t#endif\n\tif(endianness == 1)\n\t\t{\n\t\toption->option_code = byte_swap_16(option->option_code);\n\t\toption->option_length = byte_swap_16(option->option_length);\n\t\t}\n\tif(option->option_code == SHB_EOC) return 0;\n\tpadding = 0;\n\tif(option->option_length > OPTIONLEN_MAX) return option->option_length;\n\tif((option->option_length %4)) padding = 4 -(option->option_length %4);\n\tif(option->option_code == SHB_HARDWARE)\n\t\t{\n\t\tif(option->option_length < OPTIONLEN_MAX)\n\t\t\t{\n\t\t\tmemset(&pcapnghwinfo, 0, OPTIONLEN_MAX);\n\t\t\tmemcpy(&pcapnghwinfo, option->data, option->option_length);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == SHB_OS)\n\t\t{\n\t\tif(option->option_length < OPTIONLEN_MAX)\n\t\t\t{\n\t\t\tmemset(&pcapngosinfo, 0, OPTIONLEN_MAX);\n\t\t\tmemcpy(&pcapngosinfo, option->data, option->option_length);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == SHB_USER_APPL)\n\t\t{\n\t\tif(option->option_length < OPTIONLEN_MAX)\n\t\t\t{\n\t\t\tmemset(&pcapngapplinfo, 0, OPTIONLEN_MAX);\n\t\t\tmemcpy(&pcapngapplinfo, option->data, option->option_length);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == IF_MACADDR)\n\t\t{\n\t\tif(option->option_length == 6)\n\t\t\t{\n\t\t\tmemset(&pcapngdeviceinfo, 0, 6);\n\t\t\tmemcpy(&pcapngdeviceinfo, option->data, 6);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == IF_TSRESOL)\n\t\t{\n\t\tif(option->option_length == 1) pcapngtimeresolution = option->data[0];\n\t\t}\n\telse if(option->option_code == SHB_CUSTOM_OPT)\n\t\t{\n\t\tif(option->option_length > 40)\n\t\t\t{\n\t\t\tif((memcmp(&option->data[0], &hcxmagic, 4) == 0) && (memcmp(&option->data[4], &hcxmagic, 32) == 0)) restlen = pcapngoptionwalk(blocktype, optr +OH_SIZE +36, option->option_length -36);\n\t\t\telse if((memcmp(&option->data[1], &hcxmagic, 4) == 0) && (memcmp(&option->data[5], &hcxmagic, 32) == 0)) restlen = pcapngoptionwalk(blocktype, optr +OH_SIZE +1 +36, option->option_length -36);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == OPTIONCODE_MACORIG)\n\t\t{\n\t\tif(option->option_length == 6)\n\t\t\t{\n\t\t\tmemset(&pcapngdeviceinfo, 0, 6);\n\t\t\tmemcpy(&pcapngdeviceinfo, option->data, 6);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == OPTIONCODE_MACAP)\n\t\t{\n\t\tif(option->option_length == 6) memcpy(&myaktap, &option->data, 6);\n\t\t}\n\telse if(option->option_code == OPTIONCODE_RC)\n\t\t{\n\t\tif(option->option_length == 8)\n\t\t\t{\n\t\t\tmyaktreplaycount = option->data[0x07] & 0xff;\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x06] & 0xff);\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x05] & 0xff);\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x04] & 0xff);\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x03] & 0xff);\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x02] & 0xff);\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x01] & 0xff);\n\t\t\tmyaktreplaycount = (myaktreplaycount << 8) + (option->data[0x00] & 0xff);\n\t\t\tif(endianness == 1) myaktreplaycount = byte_swap_64(myaktreplaycount);\n\t\t\t}\n\t\t}\n\telse if(option->option_code == OPTIONCODE_ANONCE)\n\t\t{\n\t\tif(option->option_length == 32) memcpy(&myaktanonce, &option->data, 32);\n\t\t}\n\telse if(option->option_code == OPTIONCODE_MACCLIENT)\n\t\t{\n\t\tif(option->option_length == 6) memcpy(&myaktclient, &option->data, 6);\n\t\t}\n\telse if(option->option_code == OPTIONCODE_SNONCE)\n\t\t{\n\t\tif(option->option_length == 32) memcpy(&myaktsnonce, &option->data, 32);\n\t\t}\n\telse if(option->option_code == OPTIONCODE_WEAKCANDIDATE)\n\t\t{\n\t\tif(option->option_length < 64) memcpy(&pcapngweakcandidate, &option->data, option->option_length);\n\t\t}\n\telse if(option->option_code == OPTIONCODE_NMEA)\n\t\t{\n\t\tmemset(&nmeasentence, 0, OPTIONLEN_MAX);\n\t\tif(option->option_length >= 48)\n\t\t\t{\n\t\t\tnmealen = option->option_length;\n\t\t\tmemcpy(&nmeasentence, &option->data, option->option_length);\n\t\t\tcsc = 0;\n\t\t\tcsn = 0;\n\t\t\tpn = 1;\n\t\t\twhile((nmeasentence[pn] != 0) && (nmeasentence[pn] != '*'))\n\t\t\t\t{\n\t\t\t\tcsn ^= nmeasentence[pn];\n\t\t\t\tpn++;\n\t\t\t\t}\n\t\t\tif(nmeasentence[pn] == '*')\n\t\t\t\t{\n\t\t\t\tcsc = strtol(&nmeasentence[option->option_length -2], NULL, 16);\n\t\t\t\tif(csn == csc)\n\t\t\t\t\t{\n\t\t\t\t\tif(fh_nmea!= NULL) fprintf(fh_nmea, \"%s\\n\", nmeasentence);\n\t\t\t\t\tnmeacount++;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tnmealen = 0;\n\t\t\t\t\tnmeaerrorcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\toptr += option->option_length +padding +OH_SIZE;\n\trestlen -= option->option_length +padding +OH_SIZE;\n\t}\nreturn 0;\n}\n/*===========================================================================*/\nvoid processpcapng(int fd, char *eigenname, char *pcaporgname, char *pcapinname)\n{\nstatic unsigned int res;\nstatic off_t fdsize;\nstatic off_t aktseek;\nstatic off_t resseek;\nstatic uint32_t snaplen;\nstatic uint32_t blocktype;\nstatic uint32_t blocklen;\nstatic uint32_t blockmagic;\nstatic uint64_t timestamppcapng;\nstatic int padding;\nstatic block_header_t *pcapngbh;\nstatic section_header_block_t *pcapngshb;\nstatic interface_description_block_t *pcapngidb;\nstatic packet_block_t *pcapngpb;\nstatic enhanced_packet_block_t *pcapngepb;\nstatic custom_block_t *pcapngcb;\n\nstatic int interfaceid[MAX_INTERFACE_ID];\nstatic uint8_t pcpngblock[2 *MAXPACPSNAPLEN];\nstatic uint8_t packet[MAXPACPSNAPLEN];\n\nmagicblockcount = 0;\nancientdumpfileformat = false;\nfprintf(stdout, \"%s %s reading from %s...\\n\", basename(eigenname), VERSION_TAG, basename(pcapinname));\niface = 0;\nnmealen = 0;\nmemset(&interfaceid, 0, sizeof(int) *MAX_INTERFACE_ID);\nfdsize = lseek(fd, 0, SEEK_END);\nif(fdsize < 0)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"failed to get file size\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"failed to get file size: %s\\n\", basename(pcapinname));\n\treturn;\n\t}\n\naktseek = lseek(fd, 0L, SEEK_SET);\nif(aktseek < 0)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"failed to set file pointer\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"failed to set file pointer: %s\\n\", basename(pcapinname));\n\treturn;\n\t}\n\nsnaplen = 0;\nmemset(&packet, 0, MAXPACPSNAPLEN);\nwhile(1)\n\t{\n\taktseek = lseek(fd, 0, SEEK_CUR);\n\tif(aktseek < 0)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to set file pointer\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to set file pointer: %s\\n\", basename(pcapinname));\n\t\tbreak;\n\t\t}\n\tres = read(fd, &pcpngblock, BH_SIZE);\n\tif(res == 0)\n\t\t{\n\t\tbreak;\n\t\t}\n\tif(res != BH_SIZE)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read block header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read block header: %s\\n\", basename(pcapinname));\n\t\tbreak;\n\t\t}\n\tpcapngbh = (block_header_t*)pcpngblock;\n\tblocktype = pcapngbh->block_type;\n\tblocklen = pcapngbh->total_length;\n\tblockmagic = pcapngbh->byte_order_magic;\n\t#ifdef BIG_ENDIAN_HOST\n\tblocktype = byte_swap_32(blocktype);\n\tblocklen = byte_swap_32(blocklen);\n\tblockmagic = byte_swap_32(blockmagic);\n\t#endif\n\tif(blocktype == PCAPNGBLOCKTYPE)\n\t\t{\n\t\tif(blockmagic == PCAPNGMAGICNUMBERBE) endianness = 1;\n\t\t}\n\tif(endianness == 1)\n\t\t{\n\t\tblocktype = byte_swap_32(blocktype);\n\t\tblocklen = byte_swap_32(blocklen);\n\t\t}\n\tif((blocklen > (2 *MAXPACPSNAPLEN)) || ((blocklen %4) != 0))\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read pcapng block header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read pcapng block header: %ld\\n\", rawpacketcount);\n\t\tbreak;\n\t\t}\n\tresseek = lseek(fd, aktseek, SEEK_SET);\n\tif(resseek < 0)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to set file pointer\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to set file pointer: %s\\n\", basename(pcapinname));\n\t\tbreak;\n\t\t}\n\tres = read(fd, &pcpngblock, blocklen);\n\tif((res < BH_SIZE) || (res != blocklen))\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read pcapng block header\\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read pcapng block header: %ld\\n\", rawpacketcount);\n\t\tbreak;\n\t\t}\n\tif(memcmp(&pcpngblock[4], &pcpngblock[ blocklen -4], 4) != 0)\n\t\t{\n\t\tpcapreaderrors++;\n\t\tfprintf(stdout, \"failed to read pcapng block header \\n\");\n\t\tif(fh_log != NULL) fprintf(fh_log, \"failed to read pcapng block header: %ld\\n\", rawpacketcount);\n\t\tbreak;\n\t\t}\n\tif(blocktype == PCAPNGBLOCKTYPE)\n\t\t{\n\t\tpcapngshb = (section_header_block_t*)pcpngblock;\n\t\t#ifdef BIG_ENDIAN_HOST\n\t\tpcapngshb->major_version\t= byte_swap_16(pcapngshb->major_version);\n\t\tpcapngshb->minor_version\t= byte_swap_16(pcapngshb->minor_version);\n\t\tpcapngshb->section_length\t= byte_swap_64(pcapngshb->section_length);\n\t\t#endif\n\t\tif(endianness == 1)\n\t\t\t{\n\t\t\tpcapngshb->major_version\t= byte_swap_16(pcapngshb->major_version);\n\t\t\tpcapngshb->minor_version\t= byte_swap_16(pcapngshb->minor_version);\n\t\t\tpcapngshb->section_length\t= byte_swap_64(pcapngshb->section_length);\n\t\t\t}\n\t\tversionmajor = pcapngshb->major_version;\n\t\tversionminor = pcapngshb->minor_version;\n\t\tif(pcapngshb->major_version != PCAPNG_MAJOR_VER)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"unsupported major pcapng version\\n\");\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"unsupported major pcapng version: %d\\n\", pcapngshb->major_version);\n\t\t\tbreak;\n\t\t\t}\n\t\tif(pcapngshb->minor_version != PCAPNG_MINOR_VER)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"unsupported minor pcapng version\\n\");\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"unsupported minor pcapng version: %d\\n\", pcapngshb->minor_version);\n\t\t\tbreak;\n\t\t\t}\n\t\tif(pcapngoptionwalk(blocktype, pcapngshb->data, blocklen -SHB_SIZE) != 0) pcapreaderrors++;\n\t\t}\n\telse if(blocktype == IDBID)\n\t\t{\n\t\tpcapngidb = (interface_description_block_t*)pcpngblock;\n\t\t#ifdef BIG_ENDIAN_HOST\n\t\tpcapngidb->linktype\t= byte_swap_16(pcapngidb->linktype);\n\t\tpcapngidb->snaplen\t= byte_swap_32(pcapngidb->snaplen);\n\t\t#endif\n\t\tif(endianness == 1)\n\t\t\t{\n\t\t\tpcapngidb->linktype\t= byte_swap_16(pcapngidb->linktype);\n\t\t\tpcapngidb->snaplen\t= byte_swap_32(pcapngidb->snaplen);\n\t\t\t}\n\t\tsnaplen = pcapngidb->snaplen;\n\t\tif(pcapngoptionwalk(blocktype, pcapngidb->data, blocklen -IDB_SIZE) != 0) pcapreaderrors++;\n\t\tif(snaplen > MAXPACPSNAPLEN)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"detected oversized snaplen (%d)\\n\", snaplen);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"detected oversized snaplen: %ld\\n\", rawpacketcount);\n\t\t\t}\n\t\tif(iface >= MAX_INTERFACE_ID)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"maximum of supported interfaces reached: %d\\n\", iface);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"maximum of supported interfaces reached: %d\\n\", iface);\n\t\t\tcontinue;\n\t\t\t}\n\t\tdltlinktype[iface] = pcapngidb->linktype;\n\t\ttimeresolval[iface] = pcapngtimeresolution;\n\t\tiface++;\n\t\t}\n\telse if(blocktype == PBID)\n\t\t{\n\t\tpcapngpb = (packet_block_t*)pcpngblock;\n\t\t#ifdef BIG_ENDIAN_HOST\n\t\tpcapngpb->caplen = byte_swap_32(pcapngpb->caplen);\n\t\t#endif\n\t\tif(endianness == 1) pcapngpb->caplen\t= byte_swap_32(pcapngpb->caplen);\n\t\ttimestamppcapng = 0;\n\t\tif(pcapngpb->caplen > MAXPACPSNAPLEN)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"caplen > MAXSNAPLEN (%d > %d)\\n\", pcapngpb->caplen, MAXPACPSNAPLEN);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"caplen > MAXSNAPLEN: %ld\\n\", rawpacketcount);\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(pcapngpb->caplen > blocklen)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"caplen > blocklen (%d > %d)\\n\", pcapngpb->caplen, blocklen);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"caplen > blocklen: %ld\\n\", rawpacketcount);\n\t\t\tcontinue;\n\t\t\t}\n\t\trawpacketcount++;\n\t\tprocesslinktype(timestamppcapng, dltlinktype[0], pcapngpb->caplen, pcapngpb->data);\n\t\t}\n\telse if(blocktype == SPBID) continue;\n\telse if(blocktype == NRBID) continue;\n\telse if(blocktype == ISBID) continue;\n\telse if(blocktype == EPBID)\n\t\t{\n\t\tpcapngepb = (enhanced_packet_block_t*)pcpngblock;\n\t\t#ifdef BIG_ENDIAN_HOST\n\t\tpcapngepb->interface_id\t\t= byte_swap_32(pcapngepb->interface_id);\n\t\tpcapngepb->timestamp_high\t= byte_swap_32(pcapngepb->timestamp_high);\n\t\tpcapngepb->timestamp_low\t= byte_swap_32(pcapngepb->timestamp_low);\n\t\tpcapngepb->caplen\t\t= byte_swap_32(pcapngepb->caplen);\n\t\tpcapngepb->len\t\t\t= byte_swap_32(pcapngepb->len);\n\t\t#endif\n\t\tif(endianness == 1)\n\t\t\t{\n\t\t\tpcapngepb->interface_id\t\t= byte_swap_32(pcapngepb->interface_id);\n\t\t\tpcapngepb->timestamp_high\t= byte_swap_32(pcapngepb->timestamp_high);\n\t\t\tpcapngepb->timestamp_low\t= byte_swap_32(pcapngepb->timestamp_low);\n\t\t\tpcapngepb->caplen\t\t= byte_swap_32(pcapngepb->caplen);\n\t\t\tpcapngepb->len\t\t\t= byte_swap_32(pcapngepb->len);\n\t\t\t}\n\t\tif(pcapngepb->interface_id >= iface)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"maximum of supported interfaces reached: %d\\n\", iface);\n\t\t\tif(fh_log != NULL) fprintf(stdout, \"maximum of supported interfaces reached: %d\\n\", iface);\n\t\t\tcontinue;\n\t\t\t}\n\t\ttimestamppcapng = pcapngepb->timestamp_high;\n\t\ttimestamppcapng = (timestamppcapng << 32) +pcapngepb->timestamp_low;\n\n\t\tif(timeresolval[pcapngepb->interface_id] == TSRESOL_USEC)\n\t\t\t{\n\t\t\ttimestamppcapng = pcapngepb->timestamp_high;\n\t\t\ttimestamppcapng = (timestamppcapng << 32) +pcapngepb->timestamp_low;\n\t\t\ttimestamppcapng *= 1000;\n\t\t\t}\n\t\tif(pcapngepb->caplen != pcapngepb->len)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"caplen != len (%d != %d)\\n\", pcapngepb->caplen, pcapngepb->len);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"caplen != len: %ld\\n\", rawpacketcount);\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(pcapngepb->caplen > MAXPACPSNAPLEN)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"caplen > MAXSNAPLEN (%d > %d)\\n\", pcapngepb->caplen, MAXPACPSNAPLEN);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"caplen > MAXSNAPLEN: %ld\\n\", rawpacketcount);\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(pcapngepb->caplen > blocklen)\n\t\t\t{\n\t\t\tpcapreaderrors++;\n\t\t\tfprintf(stdout, \"caplen > blocklen (%d > %d)\\n\", pcapngepb->caplen, blocklen);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"caplen > blocklen: %ld\\n\", rawpacketcount);\n\t\t\tcontinue;\n\t\t\t}\n\t\trawpacketcount++;\n\t\tprocesslinktype(timestamppcapng, dltlinktype[pcapngepb->interface_id], pcapngepb->caplen, pcapngepb->data);\n\t\tpadding = 0;\n\t\tif((pcapngepb->caplen %4) != 0) padding = 4 -(pcapngepb->caplen %4);\n\t\tif(pcapngoptionwalk(blocktype, pcapngepb->data +pcapngepb->caplen +padding, blocklen -EPB_SIZE -pcapngepb->caplen -padding) != 0) pcapreaderrors++;\n\t\t}\n\telse if(blocktype == CBID)\n\t\t{\n\t\tpcapngcb = (custom_block_t*)pcpngblock;\n\t\tif(blocklen < CB_SIZE)\n\t\t\t{\n\t\t\tskippedpacketcount++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(memcmp(pcapngcb->pen, &hcxmagic, 4) != 0)\n\t\t\t{\n\t\t\tskippedpacketcount++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(memcmp(pcapngcb->hcxm, &hcxmagic, 32) != 0)\n\t\t\t{\n\t\t\tskippedpacketcount++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tmagicblockcount++;\n\t\tif(pcapngoptionwalk(blocktype, pcapngcb->data, blocklen -CB_SIZE) != 0) pcapreaderrors++;\n\t\t}\n\telse\n\t\t{\n\t\tskippedpacketcount++;\n\t\t}\n\t}\nfprintf(stdout, \"\\nsummary capture file\\n\"\n\t\"--------------------\\n\"\n\t\"file name................................: %s\\n\"\n\t\"version (pcapng).........................: %d.%d\\n\"\n\t\"operating system.........................: %s\\n\"\n\t\"application..............................: %s\\n\"\n\t\"interface name...........................: %s\\n\"\n\t\"interface vendor.........................: %02x%02x%02x\\n\"\n\t\"openSSL version..........................: %d.%d\\n\"\n\t\"weak candidate...........................: %s\\n\"\n\t\"MAC ACCESS POINT.........................: %02x%02x%02x%02x%02x%02x (incremented on every new client)\\n\"\n\t\"MAC CLIENT...............................: %02x%02x%02x%02x%02x%02x\\n\"\n\t\"REPLAYCOUNT..............................: %\" PRIu64 \"\\n\"\n\t\"ANONCE...................................: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n\t\"SNONCE...................................: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\"\n\t, basename(pcaporgname), versionmajor, versionminor,\n\tpcapngosinfo, pcapngapplinfo, pcapnghwinfo, pcapngdeviceinfo[0], pcapngdeviceinfo[1], pcapngdeviceinfo[2],\n\topensslversionmajor, opensslversionminor,\n\tpcapngweakcandidate,\n\tmyaktap[0], myaktap[1], myaktap[2], myaktap[3], myaktap[4], myaktap[5],\n\tmyaktclient[0], myaktclient[1], myaktclient[2], myaktclient[3], myaktclient[4], myaktclient[5],\n\tmyaktreplaycount,\n\tmyaktanonce[0], myaktanonce[1], myaktanonce[2], myaktanonce[3], myaktanonce[4], myaktanonce[5], myaktanonce[6], myaktanonce[7],\n\tmyaktanonce[8], myaktanonce[9], myaktanonce[10], myaktanonce[11], myaktanonce[12], myaktanonce[13], myaktanonce[14], myaktanonce[15],\n\tmyaktanonce[16], myaktanonce[17], myaktanonce[18], myaktanonce[19], myaktanonce[20], myaktanonce[21], myaktanonce[22], myaktanonce[23],\n\tmyaktanonce[24], myaktanonce[25], myaktanonce[26], myaktanonce[27], myaktanonce[28], myaktanonce[29], myaktanonce[30], myaktanonce[31],\n\tmyaktsnonce[0], myaktsnonce[1], myaktsnonce[2], myaktsnonce[3], myaktsnonce[4], myaktsnonce[5], myaktsnonce[6], myaktsnonce[7],\n\tmyaktsnonce[8], myaktsnonce[9], myaktsnonce[10], myaktsnonce[11], myaktsnonce[12], myaktsnonce[13], myaktsnonce[14], myaktsnonce[15],\n\tmyaktsnonce[16], myaktsnonce[17], myaktsnonce[18], myaktsnonce[19], myaktsnonce[20], myaktsnonce[21], myaktsnonce[22], myaktsnonce[23],\n\tmyaktsnonce[24], myaktsnonce[25], myaktsnonce[26], myaktsnonce[27], myaktsnonce[28], myaktsnonce[29], myaktsnonce[30], myaktsnonce[31]\n\t);\nprintlinklayerinfo();\ncleanupmac();\noutputdeviceinfolist();\noutputwpalists();\noutputwordlists();\noutputeapmd5hashlist();\noutputeapleaphashlist();\noutputeapmschapv2hashlist();\noutputtacacsplist();\nprintcontentinfo();\nreturn;\n}\n/*===========================================================================*/\nstatic bool processtrackfile(char *trackinname)\n{\nstatic FILE *fh_trackin;\n\nif((fh_trackin = fopen(trackinname, \"r\")) == NULL)\n\t{\n\n\t}\n\n\nfclose(fh_trackin);\nreturn true;\n}\n/*===========================================================================*/\nstatic bool processcapfile(char *eigenname, char *pcapinname)\n{\nstatic int resseek;\nstatic uint32_t magicnumber;\nstatic char *pcapnameptr;\n#ifdef WANTZLIB\nstatic char *pcaptempnameptr;\nstatic char tmpoutname[PATH_MAX +1];\n#endif\n\n#ifdef WANTZLIB\npcaptempnameptr = NULL;\n#endif\npcapnameptr = pcapinname;\n#ifdef WANTZLIB\nancientdumpfileformat = false;\nradiotappresent = false;\nif(testgzipfile(pcapinname) == true)\n\t{\n\tmemset(&tmpoutname, 0, PATH_MAX);\n\tsnprintf(tmpoutname, PATH_MAX, \"/tmp/%s.tmp\", basename(pcapinname));\n\tif(decompressgz(pcapinname, tmpoutname) == false) return false;\n\tgzipstat++;\n\tpcaptempnameptr = tmpoutname;\n\tpcapnameptr = tmpoutname;\n\t}\n#endif\njtrbasenamedeprecated = pcapinname;\nfd_pcap = open(pcapnameptr, O_RDONLY);\nif(fd_pcap == -1)\n\t{\n\tfprintf(stdout, \"failed to open %s: %s\\n\", pcapnameptr, strerror(errno));\n\treturn false;\n\t}\nmagicnumber = getmagicnumber(fd_pcap);\nresseek = lseek(fd_pcap, 0L, SEEK_SET);\nif(resseek < 0)\n\t{\n\tpcapreaderrors++;\n\tfprintf(stdout, \"failed to set file pointer\\n\");\n\tif(fh_log != NULL) fprintf(fh_log, \"failed to set file pointer: %s\\n\", pcapinname);\n\treturn false;\n\t}\nif(magicnumber == PCAPNGBLOCKTYPE)\n\t{\n\tif(initlists() == true)\n\t\t{\n\t\tprocesspcapng(fd_pcap, eigenname, pcapinname, pcapnameptr);\n\t\tpcapngstat++;\n\t\tclose(fd_pcap);\n\t\tcloselists();\n\t\t}\n\t}\nelse if((magicnumber == PCAPMAGICNUMBER) || (magicnumber == PCAPMAGICNUMBERBE))\n\t{\n\tif(magicnumber == PCAPMAGICNUMBERBE) endianness = 1;\n\tif(initlists() == true)\n\t\t{\n\t\tprocesscap(fd_pcap, eigenname, pcapinname, pcapnameptr);\n\t\tcapstat++;\n\t\tclose(fd_pcap);\n\t\tcloselists();\n\t\t}\n\t}\nelse\n\t{\n\tfprintf(stdout, \"unsupported dump file format: %s\\n\", pcapinname);\n\treturn false;\n\t}\n#ifdef WANTZLIB\nif(pcaptempnameptr != NULL) remove(pcaptempnameptr);\n#endif\nreturn true;\n}\n/*===========================================================================*/\nstatic bool processrawfile(char *rawinname)\n{\nstatic int len;\nstatic int pos;\nstatic long int linecount;\nstatic FILE *fh_raw_in;\nstatic uint64_t timestampraw;\nstatic uint16_t linktyperaw;\nstatic uint8_t cs, ct;\nstatic uint32_t caplenraw;\nuint8_t idx0;\nuint8_t idx1;\nstatic char *csptr;\nstatic char *stopptr = NULL;\n\nstatic uint8_t hashmap[] =\n{\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // 01234567\n0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 89:;<=>?\n0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // @ABCDEFG\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // HIJKLMNO\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PQRSTUVW\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // XYZ[\\]^_\n0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, // `abcdefg\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // hijklmno\n};\n\nstatic char linein[RAW_LEN_MAX];\nstatic uint8_t packet[MAXPACPSNAPLEN];\n\nif(initlists() == false) return false;\nif((fh_raw_in = fopen(rawinname, \"r\")) == NULL)\n\t{\n\tfprintf(stdout, \"failed to open raw file %s\\n\", rawinname);\n\treturn false;\n\t}\nlinecount = 0;\nwhile(1)\n\t{\n\tif((len = fgetline(fh_raw_in, RAW_LEN_MAX, linein)) == -1) break;\n\tlinecount++;\n\tif(len < 30) continue;\n\tif((linein[16] != '*') && (linein[25] != '*'))\n\t\t{\n\t\tfprintf(stdout, \"delimiter error line: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"delimiter error line: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\tcsptr = strchr(linein +26, '*');\n\tif(csptr == NULL)\n\t\t{\n\t\tfprintf(stdout, \"delimiter error line: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"delimiter error line: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\tif(((csptr -linein) %2) != 0)\n\t\t{\n\t\tfprintf(stdout, \"delimiter error line: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"delimiter error line: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\tif((len -(csptr -linein)) < 3)\n\t\t{\n\t\tfprintf(stdout, \"delimiter error line: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"delimiter error line: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\ttimestampraw = strtoull(linein, &stopptr, 16);\n\tif((stopptr == NULL) || ((stopptr -linein) != 16))\n\t\t{\n\t\tfprintf(stdout, \"timestamp error line: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"timestamp error line: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\t#ifdef BIG_ENDIAN_HOST\n\ttimestampraw = byte_swap_64(timestampraw);\n\t#endif\n\tlinktyperaw = strtoul(&linein[17], &stopptr, 16);\n\tif((stopptr == NULL) || ((stopptr -linein) != 25))\n\t\t{\n\t\tfprintf(stdout, \"linktype error line: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"linktype error line: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\t#ifdef BIG_ENDIAN_HOST\n\tlinktyperaw = byte_swap_16(linktyperaw);\n\t#endif\n\tcs = timestampraw &0xff;\n\tcs ^= (timestampraw >> 8) &0xff;\n\tcs ^= (timestampraw >> 16) &0xff;\n\tcs ^= (timestampraw >> 24) &0xff;\n\tcs ^= (timestampraw >> 32) &0xff;\n\tcs ^= (timestampraw >> 40) &0xff;\n\tcs ^= (timestampraw >> 48) &0xff;\n\tcs ^= (timestampraw >> 56) &0xff;\n\tcs ^= linktyperaw &0xff;\n\tcs ^= (linktyperaw >> 8) &0xff;\n\tcs ^= (linktyperaw >> 16) &0xff;\n\tcs ^= (linktyperaw >> 24) &0xff;\n\tcaplenraw = 0;\n\tfor (pos = 0; ((pos < MAXPACPSNAPLEN) && (pos < RAW_LEN_MAX)); pos += 2)\n\t\t{\n\t\tif(linein[26 +pos] == 0)\n\t\t\t{\n\t\t\tfprintf(stdout, \"frame error line: %ld\\n\", linecount);\n\t\t\tif(fh_log != NULL) fprintf(fh_log, \"frame error line: %ld\\n\", linecount);\n\t\t\tpcapreaderrors++;\n\t\t\tcontinue;\n\t\t\t}\n\t\tif(linein[26 +pos] == '*') break;\n\t\tidx0 = ((uint8_t)linein[26 +pos +0] & 0x1F) ^ 0x10;\n\t\tidx1 = ((uint8_t)linein[26 +pos +1] & 0x1F) ^ 0x10;\n\t\tpacket[pos/2] = (uint8_t)(hashmap[idx0] << 4) | hashmap[idx1];\n\t\tcs ^= packet[pos/2];\n\t\tcaplenraw++;\n\t\t};\n\tif((len -pos -26) < 3)\n\t\t{\n\t\tfprintf(stdout, \"line length error: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"line length error: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\tct = strtoul(&linein[26 +pos +1], &stopptr, 16);\n\tif((stopptr == NULL) || ((stopptr -linein) != len))\n\t\t{\n\t\tfprintf(stdout, \"line length error: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"line length error: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\tif(ct != cs)\n\t\t{\n\t\tfprintf(stdout, \"checksum error: %ld\\n\", linecount);\n\t\tif(fh_log != NULL) fprintf(fh_log, \"checksum error: %ld\\n\", linecount);\n\t\tpcapreaderrors++;\n\t\tcontinue;\n\t\t}\n\tprocesslinktype(timestampraw, linktyperaw, caplenraw, packet);\n\trawpacketcount++;\n\t}\n\nfprintf(stdout, \"\\nsummary raw file\\n\"\n\t\"----------------\\n\"\n\t\"file name................................: %s\\n\"\n\t\"lines read...............................: %ld\\n\"\n\t, basename(rawinname),linecount);\n\nprintlinklayerinfo();\ncleanupmac();\noutputdeviceinfolist();\noutputwpalists();\noutputwordlists();\noutputeapmd5hashlist();\noutputeapleaphashlist();\noutputeapmschapv2hashlist();\nprintcontentinfo();\nfclose(fh_raw_in);\nreturn true ;\n}\n/*===========================================================================*/\nstatic bool testfilename(char *filename1, char *filename2)\n{\nif(filename1 == NULL) return false;\nif(filename2 == NULL) return false;\nif(strcmp(filename1, filename2) != 0) return false;\nfprintf(stdout, \"same file names for different file types is not allowed: %s - %s\\n\", filename1, filename2);\nreturn true;\n}\n/*===========================================================================*/\nstatic bool evpdeinitwpa(void)\n{\nif(ctxhmac != NULL)\n\t{\n\tEVP_MAC_CTX_free(ctxhmac);\n\tEVP_MAC_free(hmac);\n\t}\nif(ctxcmac != NULL)\n\t{\n\tEVP_MAC_CTX_free(ctxcmac);\n\tEVP_MAC_free(cmac);\n\t}\nEVP_cleanup();\nCRYPTO_cleanup_all_ex_data();\nERR_free_strings();\nreturn true;\n}\n/*===========================================================================*/\nstatic bool evpinitwpa(void)\n{\nstatic unsigned long opensslversion;\n\nERR_load_crypto_strings();\nOpenSSL_add_all_algorithms();\nERR_load_crypto_strings();\nOpenSSL_add_all_algorithms();\nopensslversion = OpenSSL_version_num();\nopensslversionmajor = (opensslversion & 0x10000000L) >> 28;\nopensslversionminor = (opensslversion & 0x01100000L) >> 20;\n\n\nhmac = NULL;\nctxhmac = NULL;\ncmac = NULL;\nctxcmac = NULL;\n\nhmac = EVP_MAC_fetch(NULL, \"hmac\", NULL);\nif(hmac == NULL) return false;\ncmac = EVP_MAC_fetch(NULL, \"cmac\", NULL);\nif(cmac == NULL) return false;\n\nchar md5[] = \"md5\";\nparamsmd5[0] = OSSL_PARAM_construct_utf8_string(\"digest\", md5, 0);\nparamsmd5[1] = OSSL_PARAM_construct_end();\n\nchar sha1[] = \"sha1\";\nparamssha1[0] = OSSL_PARAM_construct_utf8_string(\"digest\", sha1, 0);\nparamssha1[1] = OSSL_PARAM_construct_end();\n\nchar sha256[] = \"sha256\";\nparamssha256[0] = OSSL_PARAM_construct_utf8_string(\"digest\", sha256, 0);\nparamssha256[1] = OSSL_PARAM_construct_end();\n\nchar aes[] = \"aes-1280-cbc\";\nparamsaes128[0] = OSSL_PARAM_construct_utf8_string(\"cipher\", aes, 0);\nparamsaes128[1] = OSSL_PARAM_construct_end();\n\nctxhmac = EVP_MAC_CTX_new(hmac);\nif(ctxhmac == NULL) return false;\nctxcmac = EVP_MAC_CTX_new(cmac);\nif(ctxcmac == NULL) return false;\nreturn true;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nvoid version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nvoid usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"convert pcapng, pcap and cap files to hash formats that hashcat and JtR use\\n\"\n\t\"usage:\\n\"\n\t\"%s <options>\\n\"\n\t\"%s <options> input.pcapng\\n\"\n\t\"%s <options> *.pcapng\\n\"\n\t\"%s <options> *.pcap\\n\"\n\t\"%s <options> *.cap\\n\"\n\t\"%s <options> *.*\\n\"\n\t\"\\n\"\n\t\"short options:\\n\"\n\t\"-o <file> : output WPA-PBKDF2-PMKID+EAPOL hash file (hashcat -m 22000)\\n\"\n\t\"            get full advantage of reuse of PBKDF2 on PMKID and EAPOL\\n\"\n\t\"-E <file> : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\\n\"\n\t\"            retrieved from every frame that contain an ESSID\\n\"\n\t\"-R <file> : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\\n\"\n\t\"            retrieved from PROBEREQUEST frames only\\n\"\n\t\"-I <file> : output unsorted identity list to use as input wordlist for cracker\\n\"\n\t\"-U <file> : output unsorted username list to use as input wordlist for cracker\\n\"\n\t\"-D <file> : output device information list\\n\"\n\t\"            format MAC MANUFACTURER MODELNAME SERIALNUMBER DEVICENAME UUID ESSID\\n\"\n\t\"-h        : show this help\\n\"\n\t\"-v        : show version\\n\"\n\t\"\\n\"\n\t\"long options:\\n\"\n\t\"--all                              : convert all possible hashes instead of only the best one\\n\"\n\t\"                                     that can lead to much overhead hashes\\n\"\n\t\"                                     use hcxhashtool to filter hashes\\n\"\n\t\"                                     need hashcat --nonce-error-corrections >= 8\\n\"\n\t\"--eapoltimeout=<digit>             : set EAPOL TIMEOUT (milliseconds)\\n\"\n\t\"                                   : default: %llu ms\\n\"\n\t\"--nonce-error-corrections=<digit>  : set nonce error correction\\n\"\n\t\"                                     warning: values > 0 can lead to uncrackable handshakes\\n\"\n\t\"                                   : default: %d\\n\"\n\t\"--ignore-ie                        : do not use CIPHER and AKM information\\n\"\n\t\"                                     this will convert all frames regadless of\\n\"\n\t\"                                     CIPHER and/OR AKM information,\\n\"\n\t\"                                     and can lead to uncrackable hashes\\n\"\n\t\"--max-essids=<digit>               : maximum allowed ESSIDs\\n\"\n\t\"                                     default: %d ESSID\\n\"\n\t\"                                     disregard ESSID changes and take ESSID with highest ranking\\n\"\n\t\"--eapmd5=<file>                    : output EAP MD5 CHALLENGE (hashcat -m 4800)\\n\"\n\t\"--eapmd5-john=<file>               : output EAP MD5 CHALLENGE (john chap)\\n\"\n\t\"--eapleap=<file>                   : output EAP LEAP and MSCHAPV2 CHALLENGE (hashcat -m 5500, john netntlm)\\n\"\n\t\"--tacacs-plus=<file>               : output TACACS PLUS v1 (hashcat -m 16100, john tacacs-plus)\\n\"\n//\t\"--track=<file>                     : input TRACK file (No,Latitude,Longitude,Altitude,Date,Time)\\n\"\n//\t\"                                      gpsbabel -t -i GPS_IN_FORMAT -f GPS_IN_FILE -o unicsv -F TRACK_FILE\\n\"\n//\t\"                                      gpsbabel -t -i GPS_IN_FORMAT -f GPS_IN_FILE -x track,move=TIME_ADJUST_TO_SYSTEM_CLOCKTIME -o unicsv -F TRACK_FILE\\n\"\n\t\"--nmea=<file>                      : output GPS data in NMEA 0183 format\\n\"\n\t\"                                     format: NMEA 0183 $GPGGA, $GPRMC, $GPWPL\\n\"\n\t\"                                     to convert it to gpx, use GPSBabel:\\n\"\n\t\"                                     gpsbabel -i nmea -f hcxdumptool.nmea -o gpx,gpxver=1.1 -F hcxdumptool.gpx\\n\"\n\t\"                                     to display the track, open file.gpx with viking\\n\"\n\t\"--csv=<file>                       : output ACCESS POINT information in CSV format\\n\"\n\t\"                                     delimiter: tabulator (0x08)\\n\"\n\t\"                                     columns:\\n\"\n\t\"                                     YYYY-MM-DD HH:MM:SS MAC_AP ESSID ENC_TYPE CIPHER AKM COUNTRY_INFO CHANNEL RSSI GPS(DM.m) GPS(D.d) GPSFIX SATCOUNT HDOP ALTITUDE UNIT\\n\"\n\t\"                                     GPS FIX:\\n\"\n\t\"                                     0 = fix not available or invalid\\n\"\n\t\"                                     1 = fix valid (GPS SPS mode)\\n\"\n\t\"                                     2 = fix valid (differential GPS SPS Mode)\\n\"\n\t\"                                     3 = not supported\\n\"\n\t\"                                     4 = not supported\\n\"\n\t\"                                     5 = not supported\\n\"\n\t\"                                     6 = fix valid (Dead Reckoning Mode)\\n\"\n\t\"                                     to convert it to other formats, use bash tools or scripting languages\\n\"\n\t\"\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname, eigenname, eigenname, eigenname, eigenname,\n\tEAPOLTIMEOUT / 1000000, NONCEERRORCORRECTION, ESSIDSMAX);\n\nfprintf(stdout, \"--log=<file>                       : output logfile\\n\"\n\t\"--raw-out=<file>                   : output frames in HEX ASCII\\n\"\n\t\"                                   : format: TIMESTAMP*LINKTYPE*FRAME*CHECKSUM\\n\"\n\t\"--raw-in=<file>                    : input frames in HEX ASCII\\n\"\n\t\"                                   : format: TIMESTAMP*LINKTYPE*FRAME*CHECKSUM\\n\"\n\t\"--lts=<file>                       : output BSSID list to sync with external GPS data\\n\"\n\t\"                                     format: LINUX timestamp <tab> RSSI <tab> MAC_AP <tab> ESSID\\n\"\n\t\"--pmkid-client=<file>              : output WPA-(MESH/REPEATER)-PMKID hash file (hashcat -m 22000)\\n\"\n\t\"--pmkid=<file>                     : output deprecated PMKID file (delimiter *)\\n\"\n\t\"--hccapx=<file>                    : output deprecated hccapx v4 file\\n\"\n\t\"--hccap=<file>                     : output deprecated hccap file\\n\"\n\t\"--john=<file>                      : output deprecated PMKID/EAPOL (JtR wpapsk-opencl/wpapsk-pmk-opencl)\\n\");\n\nfprintf(stdout, \"--prefix=<file>                    : convert everything to lists using this prefix (overrides single options):\\n\"\n\t\"                                      -o <file.22000>           : output PMKID/EAPOL hash file\\n\"\n\t\"                                      -E <file.essid>           : output wordlist (autohex enabled on non ASCII characters) to use as input wordlist for cracker\\n\"\n\t\"                                      -I <file.identity>        : output unsorted identity list to use as input wordlist for cracker\\n\"\n\t\"                                      -U <file.username>        : output unsorted username list to use as input wordlist for cracker\\n\"\n\t\"                                     --eapmd5=<file.4800>       : output EAP MD5 CHALLENGE (hashcat -m 4800)\\n\"\n\t\"                                     --eapleap=<file.5500>      : output EAP LEAP and MSCHAPV2 CHALLENGE (hashcat -m 5500, john netntlm)\\n\"\n\t\"                                     --tacacs-plus=<file.16100> : output TACACS+ (hashcat -m 16100, john tacacs-plus)\\n\"\n\t\"                                     --nmea=<file.nmea>         : output GPS data in NMEA 0183 format\\n\"\n\t\"--add-timestamp                    : add date/time and EAPOL TIME gap (time between two EAPOL MESSAGEs in nsec) to hash line\\n\"\n\t\"                                     this must be filtered out before feeding hashcat with the hash, e.g. by awk:\\n\"\n\t\"                                     cat hash.hc22000 | awk '{print $1}' > hashremovedtimestamp.hc22000\\n\"\n\t\"--help                             : show this help\\n\"\n\t\"--version                          : show version\\n\"\n\n\"bitmask of PMKID hash line (WPA*01) message pair field:\\n\"\n\t\"0: reserved\\n\"\n\t\"1: PMKID taken from AP\\n\"\n\t\"2: PMKID taken from AP possible PSKSHA256 FT using PSK\\n\"\n\t\"3: reserved\\n\"\n\t\"4: PMKID taken from CLIENT (wlan.da: possible MESH or REPEATER)\\n\"\n\t\"5: reserved\\n\"\n\t\"6: reserved\\n\"\n\t\"7: reserved\\n\"\n\t\"\\n\"\n\t\"bitmask of EAPOL hash line (WPA*02) message pair field:\\n\"\n\t\"2,1,0:\\n\"\n\t\" 000 = M1+M2, EAPOL from M2 (challenge)\\n\"\n\t\" 001 = M1+M4, EAPOL from M4 (authorized) - usable if NONCE_CLIENT is not zeroed \\n\"\n\t\" 010 = M2+M3, EAPOL from M2 (authorized)\\n\"\n\t\" 011 = M2+M3, EAPOL from M3 (authorized) - usable by option --all\\n\"\n\t\" 100 = M3+M4, EAPOL from M3 (authorized) - usable by option --all\\n\"\n\t\" 101 = M3+M4, EAPOL from M4 (authorized) - usable if NONCE_CLIENT is not zeroed\\n\"\n\t\"3: reserved\\n\"\n\t\"4: NC (set to 1) - nonce-error-corrections deactivated on M1M2ROGUE, M2M3E3 and M3M4E3\\n\"\n\t\"5: LE router detected (set to 1) - nonce-error-corrections required only on LE\\n\"\n\t\"6: BE router detected (set to 1) - nonce-error-corrections required only on BE\\n\"\n\t\"7: NC (set to 1) - nonce-error-corrections activated\\n\"\n\t\"\\n\"\n\t\"Do not edit, merge or convert pcapng files! This will remove optional comment fields!\\n\"\n\t\"Detection of bit errors does not work on cleaned dump files!\\n\"\n\t\"Do not use %s in combination with third party cap/pcap/pcapng cleaning tools (except: tshark and/or Wireshark)!\\n\"\n\t\"It is much better to run gzip to compress the files. Wireshark, tshark and hcxpcapngtool will understand this.\\n\"\n\t\"Output is appended to existing files.\\n\"\n\t\"Recommended tools to show additional 802.11 fields or to decrypt WiFi traffic: Wireshark and/or tshark\\n\"\n\t\"Recommended tool to filter converted hash by several options: hcxhashtool\\n\"\n\t\"Recommended tool to get default or standard PSKs: hcxpsktool\\n\"\n\t\"Recommended tool to calculate wordlists based on ESSID: hcxeiutool\\n\"\n\t\"Recommended tools to retrieve PSK from hash: hashcat, JtR\\n\",\n\teigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nvoid usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic int exitcode;\nstatic char *pmkideapoloutname;\nstatic char *pmkidclientoutname;\nstatic char *eapmd5outname;\nstatic char *eapmd5johnoutname;\nstatic char *eapleapoutname;\nstatic char *tacacspoutname;\nstatic char *essidoutname;\nstatic char *essidproberequestoutname;\nstatic char *deviceinfooutname;\nstatic char *identityoutname;\nstatic char *usernameoutname;\nstatic char *trackinname;\nstatic char *nmeaoutname;\nstatic char *csvoutname;\nstatic char *logoutname;\nstatic char *rawoutname;\nstatic char *ltsoutname;\nstatic char *rawinname;\nstatic char *pmkideapoljtroutnamedeprecated;\nstatic char *pmkidoutnamedeprecated;\nstatic char *hccapxoutnamedeprecated;\nstatic char *hccapoutnamedeprecated;\n\nstatic const char *prefixoutname;\nstatic const char *pmkideapolsuffix = \".22000\";\nstatic const char *eapmd5suffix = \".4800\";\nstatic const char *eapleapsuffix = \".5500\";\nstatic const char *tacacspsuffix = \".16100\";\nstatic const char *essidsuffix = \".essid\";\nstatic const char *essidproberequestsuffix = \".essidproberequest\";\nstatic const char *identitysuffix = \".identity\";\nstatic const char *usernamesuffix = \".username\";\nstatic const char *nmeasuffix = \".nmea\";\nstatic const char *csvsuffix = \".csv\";\nstatic const char *deviceinfosuffix = \".deviceinfo\";\n\nstatic char pmkideapolprefix[PATH_MAX];\nstatic char eapmd5prefix[PATH_MAX];\nstatic char eapleapprefix[PATH_MAX];\nstatic char tacacspprefix[PATH_MAX];\nstatic char essidprefix[PATH_MAX];\nstatic char essidproberequestprefix[PATH_MAX];\nstatic char identityprefix[PATH_MAX];\nstatic char usernameprefix[PATH_MAX];\nstatic char nmeaprefix[PATH_MAX];\nstatic char csvprefix[PATH_MAX];\nstatic char deviceinfoprefix[PATH_MAX];\n\nstruct timeval tv;\nstatic struct stat statinfo;\n\nstatic const char *short_options = \"o:E:R:I:U:D:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"all\",\t\t\t\tno_argument,\t\tNULL,\tHCX_CONVERT_ALL},\n\t{\"eapoltimeout\",\t\trequired_argument,\tNULL,\tHCX_EAPOL_TIMEOUT},\n\t{\"nonce-error-corrections\",\trequired_argument,\tNULL,\tHCX_NC},\n\t{\"ignore-ie\",\t\t\tno_argument,\t\tNULL,\tHCX_IE},\n\t{\"max-essids\",\t\t\trequired_argument,\tNULL,\tHCX_ESSIDS},\n\t{\"track-in\",\t\t\trequired_argument,\tNULL,\tHCX_TRACK_IN},\n\t{\"nmea\",\t\t\trequired_argument,\tNULL,\tHCX_NMEA_OUT},\n\t{\"csv\",\t\t\t\trequired_argument,\tNULL,\tHCX_CSV_OUT},\n\t{\"raw-out\",\t\t\trequired_argument,\tNULL,\tHCX_RAW_OUT},\n\t{\"raw-in\",\t\t\trequired_argument,\tNULL,\tHCX_RAW_IN},\n\t{\"lts\",\t\t\t\trequired_argument,\tNULL,\tHCX_LTS},\n\t{\"log\",\t\t\t\trequired_argument,\tNULL,\tHCX_LOG_OUT},\n\t{\"pmkid-client\",\t\trequired_argument,\tNULL,\tHCX_PMKID_CLIENT_OUT},\n\t{\"pmkid\",\t\t\trequired_argument,\tNULL,\tHCX_PMKID_OUT_DEPRECATED},\n\t{\"eapmd5\",\t\t\trequired_argument,\tNULL,\tHCX_EAPMD5_OUT},\n\t{\"eapmd5-john\",\t\t\trequired_argument,\tNULL,\tHCX_EAPMD5_JOHN_OUT},\n\t{\"eapleap\",\t\t\trequired_argument,\tNULL,\tHCX_EAPLEAP_OUT},\n\t{\"tacacs-plus\",\t\t\trequired_argument,\tNULL,\tHCX_TACACSP_OUT},\n\t{\"hccapx\",\t\t\trequired_argument,\tNULL,\tHCX_HCCAPX_OUT_DEPRECATED},\n\t{\"hccap\",\t\t\trequired_argument,\tNULL,\tHCX_HCCAP_OUT_DEPRECATED},\n\t{\"john\",\t\t\trequired_argument,\tNULL,\tHCX_PMKIDEAPOLJTR_OUT_DEPRECATED},\n\t{\"prefix\",\t\t\trequired_argument,\tNULL,\tHCX_PREFIX_OUT},\n\t{\"add-timestamp\",\t\tno_argument,\t\tNULL,\tHCX_ADD_TIMESTAMP},\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCX_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCX_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\nexitcode = EXIT_SUCCESS;\naddtimestampflag = false;\nignoreieflag = false;\ndonotcleanflag = false;\neapoltimeoutvalue = EAPOLTIMEOUT;\nncvalue = NONCEERRORCORRECTION;\nessidsvalue = ESSIDSMAX;\n\npmkideapoloutname = NULL;\neapmd5outname = NULL;\neapmd5johnoutname = NULL;\neapleapoutname = NULL;\ntacacspoutname = NULL;\nessidoutname = NULL;\nessidproberequestoutname = NULL;\nidentityoutname = NULL;\nusernameoutname = NULL;\ndeviceinfooutname = NULL;\ntrackinname = NULL;\nnmeaoutname = NULL;\ncsvoutname = NULL;\nlogoutname = NULL;\nrawoutname = NULL;\nltsoutname = NULL;\nrawinname = NULL;\nprefixoutname = NULL;\npmkideapoljtroutnamedeprecated = NULL;\npmkidoutnamedeprecated = NULL;\nhccapxoutnamedeprecated = NULL;\nhccapoutnamedeprecated = NULL;\n\nfh_pmkideapol = NULL;\nfh_pmkideapolclient = NULL;\nfh_eapmd5 = NULL;\nfh_eapmd5john = NULL;\nfh_eapleap = NULL;\nfh_tacacsp = NULL;\nfh_essid = NULL;\nfh_essidproberequest = NULL;\nfh_deviceinfo= NULL;\nfh_identity = NULL;\nfh_username = NULL;\nfh_nmea = NULL;\nfh_csv = NULL;\nfh_log = NULL;\nfh_raw_out = NULL;\nfh_lts = NULL;\nfh_pmkideapoljtrdeprecated = NULL;\nfh_pmkiddeprecated = NULL;\nfh_hccapxdeprecated = NULL;\nfh_hccapdeprecated = NULL;\n\ngzipstat = 0;\ncapstat = 0;\npcapngstat = 0;\nwhile((auswahl = getopt_long (argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCX_EAPOL_TIMEOUT:\n\t\teapoltimeoutvalue = strtoull(optarg, NULL, 10);\n\t\tif(eapoltimeoutvalue <= 0)\n\t\t\t{\n\t\t\tfprintf(stderr, \"EAPOL TIMEOUT must be > 0\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\teapoltimeoutvalue *= 1000000;\n\t\tbreak;\n\n\t\tcase HCX_NC:\n\t\tncvalue = strtol(optarg, NULL, 10);\n\t\tbreak;\n\n\t\tcase HCX_IE:\n\t\tignoreieflag = true;\n\t\tbreak;\n\n\t\tcase HCX_CONVERT_ALL:\n\t\tdonotcleanflag = true;\n\t\tbreak;\n\n\t\tcase HCX_ESSIDS:\n\t\tessidsvalue = strtol(optarg, NULL, 10);\n\t\tbreak;\n\n\t\tcase HCX_PMKIDEAPOL_OUT:\n\t\tpmkideapoloutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_PMKID_CLIENT_OUT:\n\t\tpmkidclientoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_EAPMD5_OUT:\n\t\teapmd5outname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_EAPMD5_JOHN_OUT:\n\t\teapmd5johnoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_EAPLEAP_OUT:\n\t\teapleapoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_TACACSP_OUT:\n\t\ttacacspoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ESSID_OUT:\n\t\tessidoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_LTS:\n\t\tltsoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ESSIDPROBEREQUEST_OUT:\n\t\tessidproberequestoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_IDENTITY_OUT:\n\t\tidentityoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_USERNAME_OUT:\n\t\tusernameoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_DEVICEINFO_OUT:\n\t\tdeviceinfooutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_TRACK_IN:\n\t\ttrackinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_NMEA_OUT:\n\t\tnmeaoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_CSV_OUT:\n\t\tcsvoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_RAW_OUT:\n\t\trawoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_RAW_IN:\n\t\trawinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_LOG_OUT:\n\t\tlogoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_ADD_TIMESTAMP:\n\t\taddtimestampflag = true;\n\t\tbreak;\n\n\t\tcase HCX_PMKIDEAPOLJTR_OUT_DEPRECATED:\n\t\tpmkideapoljtroutnamedeprecated = optarg;\n\t\tbreak;\n\n\t\tcase HCX_PMKID_OUT_DEPRECATED:\n\t\tpmkidoutnamedeprecated = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HCCAPX_OUT_DEPRECATED:\n\t\thccapxoutnamedeprecated = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HCCAP_OUT_DEPRECATED:\n\t\thccapoutnamedeprecated = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_PREFIX_OUT:\n\t\tprefixoutname = optarg;\n\t\tif(strlen(prefixoutname) > PREFIX_BUFFER_MAX)\n\t\t\t{\n\t\t\tfprintf(stderr, \"prefix must be < %d\\n\", PATH_MAX -12);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\n\ngettimeofday(&tv, NULL);\ntimestampstart = ((uint64_t)tv.tv_sec *1000000) + tv.tv_usec;\n\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\nrun %s --help to get more information\\n\", (basename(argv[0])));\n\texit(EXIT_FAILURE);\n\t}\n\nif((optind == argc) && (rawinname == NULL))\n\t{\n\tfprintf(stdout, \"no input file(s) selected\\n\");\n\texit(EXIT_FAILURE);\n\t}\n\nif(evpinitwpa() == false) exit(EXIT_FAILURE);\n\nif(testfilename(pmkideapoloutname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, eapmd5outname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, eapleapoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, tacacspoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, nmeaoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, csvoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, rawoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(pmkideapoloutname, logoutname) == true) exit(EXIT_FAILURE);\n\nif(testfilename(eapmd5outname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, eapleapoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, tacacspoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, nmeaoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, csvoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, rawoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapmd5outname, logoutname) == true) exit(EXIT_FAILURE);\n\nif(testfilename(eapleapoutname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, tacacspoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, nmeaoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, csvoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, rawoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(eapleapoutname, logoutname) == true) exit(EXIT_FAILURE);\n\nif(testfilename(tacacspoutname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, nmeaoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, csvoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, rawoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(tacacspoutname, logoutname) == true) exit(EXIT_FAILURE);\n\nif(testfilename(nmeaoutname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, rawoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(nmeaoutname, logoutname) == true) exit(EXIT_FAILURE);\n\nif(testfilename(rawoutname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(rawoutname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(rawoutname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(rawoutname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(rawoutname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(rawoutname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(rawoutname, logoutname) == true) exit(EXIT_FAILURE);\n\nif(testfilename(logoutname, essidoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(logoutname, essidproberequestoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(logoutname, identityoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(logoutname, usernameoutname) == true) exit(EXIT_FAILURE);\nif(testfilename(logoutname, deviceinfooutname) == true) exit(EXIT_FAILURE);\nif(testfilename(logoutname, eapmd5johnoutname) == true) exit(EXIT_FAILURE);\n\nif(prefixoutname != NULL)\n\t{\n\tstrncpy(pmkideapolprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(pmkideapolprefix, pmkideapolsuffix, PREFIX_BUFFER_MAX);\n\tpmkideapoloutname = pmkideapolprefix;\n\n\tstrncpy(essidprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(essidprefix, essidsuffix, PREFIX_BUFFER_MAX);\n\tessidoutname = essidprefix;\n\n\tstrncpy(essidproberequestprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(essidproberequestprefix, essidproberequestsuffix, PREFIX_BUFFER_MAX);\n\tessidproberequestoutname = essidprefix;\n\n\tstrncpy(identityprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(identityprefix, identitysuffix, PREFIX_BUFFER_MAX);\n\tidentityoutname = identityprefix;\n\n\tstrncpy(usernameprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(usernameprefix, usernamesuffix, PREFIX_BUFFER_MAX);\n\tusernameoutname = usernameprefix;\n\n\tstrncpy(deviceinfoprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(deviceinfoprefix, deviceinfosuffix, PREFIX_BUFFER_MAX);\n\tdeviceinfooutname = deviceinfoprefix;\n\n\tstrncpy(eapmd5prefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(eapmd5prefix, eapmd5suffix, PREFIX_BUFFER_MAX);\n\teapmd5outname = eapmd5prefix;\n\n\tstrncpy(eapleapprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(eapleapprefix, eapleapsuffix, PREFIX_BUFFER_MAX);\n\teapleapoutname = eapleapprefix;\n\n\tstrncpy(tacacspprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(tacacspprefix, tacacspsuffix, PREFIX_BUFFER_MAX);\n\ttacacspoutname = tacacspprefix;\n\n\tstrncpy(nmeaprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(nmeaprefix, nmeasuffix, PREFIX_BUFFER_MAX);\n\tnmeaoutname = nmeaprefix;\n\n\tstrncpy(csvprefix, prefixoutname, PREFIX_BUFFER_MAX);\n\tstrncat(csvprefix, csvsuffix, PREFIX_BUFFER_MAX);\n\tcsvoutname = csvprefix;\n\t}\nif((pmkideapoloutname != NULL) && (nmeaoutname != NULL))\n\t{\n\tif(strcmp(pmkideapoloutname, nmeaoutname) == 0)\n\t\t{\n\t\tfprintf(stdout, \"same file names for different file types not allowed: %s - %s\\n\", pmkideapoloutname, usernameoutname);\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(pmkideapoloutname != NULL)\n\t{\n\tif((fh_pmkideapol = fopen(pmkideapoloutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", pmkideapoloutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(eapmd5outname != NULL)\n\t{\n\tif((fh_eapmd5 = fopen(eapmd5outname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", eapmd5outname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(eapmd5johnoutname != NULL)\n\t{\n\tif((fh_eapmd5john = fopen(eapmd5johnoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", eapmd5johnoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(eapleapoutname != NULL)\n\t{\n\tif((fh_eapleap = fopen(eapleapoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", eapleapoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(tacacspoutname != NULL)\n\t{\n\tif((fh_tacacsp = fopen(tacacspoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", tacacspoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(essidoutname != NULL)\n\t{\n\tif((fh_essid = fopen(essidoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", essidoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(ltsoutname != NULL)\n\t{\n\tif((fh_lts = fopen(ltsoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", ltsoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(essidproberequestoutname != NULL)\n\t{\n\tif((fh_essidproberequest = fopen(essidproberequestoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", essidproberequestoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(identityoutname != NULL)\n\t{\n\tif((fh_identity = fopen(identityoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", identityoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(usernameoutname != NULL)\n\t{\n\tif((fh_username = fopen(usernameoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", usernameoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(deviceinfooutname != NULL)\n\t{\n\tif((fh_deviceinfo = fopen(deviceinfooutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", deviceinfooutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(nmeaoutname != NULL)\n\t{\n\tif((fh_nmea = fopen(nmeaoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", nmeaoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(csvoutname != NULL)\n\t{\n\tif((fh_csv = fopen(csvoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", csvoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(rawoutname != NULL)\n\t{\n\tif((fh_raw_out = fopen(rawoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\",rawoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(logoutname != NULL)\n\t{\n\tif((fh_log = fopen(logoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\",logoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(pmkidclientoutname != NULL)\n\t{\n\tif((fh_pmkideapolclient = fopen(pmkidclientoutname, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", pmkidclientoutname, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(pmkideapoljtroutnamedeprecated != NULL)\n\t{\n\tif((fh_pmkideapoljtrdeprecated = fopen(pmkideapoljtroutnamedeprecated, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", pmkideapoljtroutnamedeprecated, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(pmkidoutnamedeprecated != NULL)\n\t{\n\tif((fh_pmkiddeprecated = fopen(pmkidoutnamedeprecated, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", pmkidoutnamedeprecated, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(hccapxoutnamedeprecated != NULL)\n\t{\n\tif((fh_hccapxdeprecated = fopen(hccapxoutnamedeprecated, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", hccapxoutnamedeprecated, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(hccapoutnamedeprecated != NULL)\n\t{\n\tif((fh_hccapdeprecated = fopen(hccapoutnamedeprecated, \"a\")) == NULL)\n\t\t{\n\t\tfprintf(stdout, \"failed to open file %s: %s\\n\", hccapoutnamedeprecated, strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\nif(trackinname != NULL)\n\t{\n\tif(processtrackfile(trackinname) == false) exitcode = EXIT_FAILURE;\n\t}\n\nfor(index = optind; index < argc; index++)\n\t{\n\tif(processcapfile(argv[0], argv[index]) == false) exitcode = EXIT_FAILURE;\n\t}\n\nif(rawinname != NULL) processrawfile(rawinname);\n\nif(fh_pmkideapol != NULL) fclose(fh_pmkideapol);\nif(fh_pmkideapolclient != NULL) fclose(fh_pmkideapolclient);\nif(fh_eapmd5 != NULL) fclose(fh_eapmd5);\nif(fh_eapmd5john != NULL) fclose(fh_eapmd5john);\nif(fh_eapleap != NULL) fclose(fh_eapleap);\nif(fh_tacacsp != NULL) fclose(fh_tacacsp);\nif(fh_essid != NULL) fclose(fh_essid);\nif(fh_essidproberequest != NULL) fclose(fh_essidproberequest);\nif(fh_identity != NULL) fclose(fh_identity);\nif(fh_username != NULL) fclose(fh_username);\nif(fh_deviceinfo != NULL) fclose(fh_deviceinfo);\nif(fh_nmea != NULL) fclose(fh_nmea);\nif(fh_csv != NULL) fclose(fh_csv);\nif(fh_raw_out != NULL) fclose(fh_raw_out);\nif(fh_lts != NULL) fclose(fh_lts);\nif(fh_log != NULL) fclose(fh_log);\nif(fh_pmkideapoljtrdeprecated != NULL) fclose(fh_pmkideapoljtrdeprecated);\nif(fh_pmkiddeprecated != NULL) fclose(fh_pmkiddeprecated);\nif(fh_hccapxdeprecated != NULL) fclose(fh_hccapxdeprecated);\nif(fh_hccapdeprecated != NULL) fclose(fh_hccapdeprecated);\n\nif(pmkideapoloutname != NULL)\n\t{\n\tif(stat(pmkideapoloutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkideapoloutname);\n\t\t}\n\t}\nif(pmkidclientoutname != NULL)\n\t{\n\tif(stat(pmkidclientoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkidclientoutname);\n\t\t}\n\t}\nif(eapmd5outname != NULL)\n\t{\n\tif(stat(eapmd5outname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(eapmd5outname);\n\t\t}\n\t}\nif(eapmd5johnoutname != NULL)\n\t{\n\tif(stat(eapmd5johnoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(eapmd5johnoutname);\n\t\t}\n\t}\nif(eapleapoutname != NULL)\n\t{\n\tif(stat(eapleapoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(eapleapoutname);\n\t\t}\n\t}\nif(tacacspoutname != NULL)\n\t{\n\tif(stat(tacacspoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(tacacspoutname);\n\t\t}\n\t}\nif(essidoutname != NULL)\n\t{\n\tif(stat(essidoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(essidoutname);\n\t\t}\n\t}\nif(essidproberequestoutname != NULL)\n\t{\n\tif(stat(essidproberequestoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(essidproberequestoutname);\n\t\t}\n\t}\nif(identityoutname != NULL)\n\t{\n\tif(stat(identityoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(identityoutname);\n\t\t}\n\t}\nif(usernameoutname != NULL)\n\t{\n\tif(stat(usernameoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(usernameoutname);\n\t\t}\n\t}\nif(deviceinfooutname != NULL)\n\t{\n\tif(stat(deviceinfooutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(deviceinfooutname);\n\t\t}\n\t}\nif(nmeaoutname != NULL)\n\t{\n\tif(stat(nmeaoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(nmeaoutname);\n\t\t}\n\t}\nif(csvoutname != NULL)\n\t{\n\tif(stat(csvoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(csvoutname);\n\t\t}\n\t}\nif(rawoutname != NULL)\n\t{\n\tif(stat(rawoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(rawoutname);\n\t\t}\n\t}\nif(logoutname != NULL)\n\t{\n\tif(stat(logoutname, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(logoutname);\n\t\t}\n\t}\n\nif(pmkideapoljtroutnamedeprecated != NULL)\n\t{\n\tif(stat(pmkideapoljtroutnamedeprecated, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkideapoljtroutnamedeprecated);\n\t\t}\n\t}\nif(pmkidoutnamedeprecated != NULL)\n\t{\n\tif(stat(pmkidoutnamedeprecated, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(pmkidoutnamedeprecated);\n\t\t}\n\t}\nif(hccapxoutnamedeprecated != NULL)\n\t{\n\tif(stat(hccapxoutnamedeprecated, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(hccapxoutnamedeprecated);\n\t\t}\n\t}\nif(hccapoutnamedeprecated != NULL)\n\t{\n\tif(stat(hccapoutnamedeprecated, &statinfo) == 0)\n\t\t{\n\t\tif(statinfo.st_size == 0) remove(hccapoutnamedeprecated);\n\t\t}\n\t}\nif((gzipstat == 0) && (pcapngstat == 0) && (capstat == 0)) return exitcode;\nfprintf(stdout, \"\\nsession summary\\n---------------\\n\");\nif(gzipstat > 0)\t\tfprintf(stdout, \"gzip compressed dump files............: %d\\n\", gzipstat);\nif(pcapngstat > 0)\t\tfprintf(stdout, \"processed pcapng files................: %d\\n\", pcapngstat);\nif(capstat > 0)\t\t\tfprintf(stdout, \"processed cap files...................: %d\\n\", capstat);\nfprintf(stdout, \"\\n\");\nif(evpdeinitwpa() == false) exit(EXIT_FAILURE);\nreturn exitcode;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "hcxpmktool.c",
          "type": "blob",
          "size": 24.0029296875,
          "content": "#define _GNU_SOURCE\n#include <getopt.h>\n#include <libgen.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#ifdef _WIN32\n#include <winsock2.h>\n#else\n#include <arpa/inet.h>\n#endif\n\n#include <openssl/core.h>\n#include <openssl/crypto.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <openssl/params.h>\n#include <openssl/types.h>\n\n#include \"include/hcxpmktool.h\"\n#include \"include/ieee80211.h\"\n#include \"include/strings.c\"\n#include \"include/fileops.c\"\n\n/*===========================================================================*/\n/* global variable */\n\nstatic uint16_t status;\nstatic int exitcode;\n\nstatic EVP_MAC *hmac;\nstatic EVP_MAC *cmac;\nstatic EVP_MAC_CTX *ctxhmac;\nstatic EVP_MAC_CTX *ctxcmac;\nstatic OSSL_PARAM paramsmd5[3];\nstatic OSSL_PARAM paramssha1[3];\nstatic OSSL_PARAM paramssha256[3];\nstatic OSSL_PARAM paramsaes128[3];\nstatic uint8_t pmkcalculated[128];\nstatic uint8_t pmkidcalculated[128];\nstatic uint8_t ptkcalculated[256];\nstatic uint8_t miccalculated[128];\n\nstatic int psklen;\nstatic char *pskstring;\nstatic ssize_t essidlen;\nstatic uint8_t essid[34];\nstatic uint8_t macap[8];\nstatic uint8_t macclient[8];\nstatic uint8_t pmkid[18];\nstatic uint8_t mic[18];\nstatic uint8_t anonce[34];\nstatic size_t eapollen;\nstatic uint8_t eapol[1024];\nstatic eapauth_t *eapptr;\nstatic size_t eapauthlen;\nstatic wpakey_t *wpak;\nstatic int keyversion;\n/*===========================================================================*/\nstatic void showresult(void)\n{\nfprintf(stdout, \"\\n\");\nif((status & HAS_PMKID_LINE) == HAS_PMKID_LINE)\n\t{\n\tfprintf(stdout, \"HASH FORMAT.: PMKID (WPA*01)\\n\");\n\t}\nif((status & HAS_EAPOL_LINE) == HAS_EAPOL_LINE)\n\t{\n\tfprintf(stdout, \"HASH FORMAT.: EAPOL (WPA*02)\\n\");\n\t}\nif((status & HAS_ESSID) == HAS_ESSID)\n\t{\n\tfprintf(stdout, \"ESSID.......: %s\\n\", essid);\n\t}\nif((status & HAS_MACAP) == HAS_MACAP)\n\t{\n\tfprintf(stdout, \"MAC_AP......: %02x%02x%02x%02x%02x%02x\\n\",\n\tmacap[0], macap[1], macap[2], macap[3], macap[4], macap[5]);\n\t}\nif((status & HAS_MACCLIENT) == HAS_MACCLIENT)\n\t{\n\tfprintf(stdout, \"MAC_CLIENT..: %02x%02x%02x%02x%02x%02x\\n\",\n\tmacclient[0], macclient[1], macclient[2], macclient[3], macclient[4], macclient[5]);\n\t}\nif((status & HAS_PSK) == HAS_PSK)\n\t{\n\tfprintf(stdout, \"PSK.........: %s\\n\", pskstring);\n\t}\nif((status & HAS_PMK_CALC) == HAS_PMK_CALC)\n\t{\n\tfprintf(stdout, \"PMK.........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x (calculated)\\n\",\n\tpmkcalculated[0], pmkcalculated[1], pmkcalculated[2], pmkcalculated[3], pmkcalculated[4], pmkcalculated[5], pmkcalculated[6], pmkcalculated[7], pmkcalculated[8], pmkcalculated[9], pmkcalculated[10], pmkcalculated[11], pmkcalculated[12], pmkcalculated[13], pmkcalculated[14], pmkcalculated[15],\n\tpmkcalculated[16], pmkcalculated[17], pmkcalculated[18], pmkcalculated[19], pmkcalculated[20], pmkcalculated[21], pmkcalculated[22], pmkcalculated[23], pmkcalculated[24], pmkcalculated[25], pmkcalculated[26], pmkcalculated[27], pmkcalculated[28], pmkcalculated[29], pmkcalculated[30], pmkcalculated[31]);\n\t}\nif((status & HAS_PMK) == HAS_PMK)\n\t{\n\tfprintf(stdout, \"PMK.........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\tpmkcalculated[0], pmkcalculated[1], pmkcalculated[2], pmkcalculated[3], pmkcalculated[4], pmkcalculated[5], pmkcalculated[6], pmkcalculated[7], pmkcalculated[8], pmkcalculated[9], pmkcalculated[10], pmkcalculated[11], pmkcalculated[12], pmkcalculated[13], pmkcalculated[14], pmkcalculated[15],\n\tpmkcalculated[16], pmkcalculated[17], pmkcalculated[18], pmkcalculated[19], pmkcalculated[20], pmkcalculated[21], pmkcalculated[22], pmkcalculated[23], pmkcalculated[24], pmkcalculated[25], pmkcalculated[26], pmkcalculated[27], pmkcalculated[28], pmkcalculated[29], pmkcalculated[30], pmkcalculated[31]);\n\t}\nif((status & HAS_PMKID) == HAS_PMKID)\n\t{\n\tfprintf(stdout, \"PMKID.......: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n\tpmkid[0], pmkid[1], pmkid[2], pmkid[3], pmkid[4], pmkid[5], pmkid[6], pmkid[7], pmkid[8], pmkid[9], pmkid[10], pmkid[11], pmkid[12], pmkid[13], pmkid[14], pmkid[15]);\n\tif(((status & HAS_PMKID_CALC) == HAS_PMKID_CALC) || ((status & HAS_PMK) == HAS_PMK))\n\t\t{\n\t\tif(memcmp(pmkid, pmkidcalculated, 16) == 0)\n\t\t\t{\n\t\t\texitcode = EXIT_SUCCESS_CONFIRMED;\n\t\t\tfprintf(stdout, \" (confirmed)\\n\");\n\t\t\t}\n\t\telse fprintf(stdout, \" (not confirmed)\\n\");\n\t\t}\n\telse fprintf(stdout, \" (not confirmed)\\n\");\n\t}\nif((status & HAS_MIC) == HAS_MIC)\n\t{\n\tif(keyversion == 2) fprintf(stdout, \"KEY VERSION.: WPA2\\n\");\n\telse if(keyversion == 1) fprintf(stdout, \"KEY VERSION.: WPA1\\n\");\n\telse if(keyversion == 3) fprintf(stdout, \"KEY VERSION.: WPA2 KEY VERSION 3\\n\");\n\tfprintf(stdout, \"NONCE 1.....: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\tanonce[0], anonce[1], anonce[2], anonce[3], anonce[4], anonce[5], anonce[6], anonce[7], anonce[8], anonce[9], anonce[10], anonce[11], anonce[12], anonce[13], anonce[14], anonce[15],\n\tanonce[16], anonce[17], anonce[18], anonce[19], anonce[20], anonce[21], anonce[22], anonce[23], anonce[24], anonce[25], anonce[26], anonce[27], anonce[28], anonce[29], anonce[30], anonce[31]);\n\tfprintf(stdout, \"NONCE 2.....: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\twpak->nonce[0], wpak->nonce[1], wpak->nonce[2], wpak->nonce[3], wpak->nonce[4], wpak->nonce[5], wpak->nonce[6], wpak->nonce[7], wpak->nonce[8], wpak->nonce[9], wpak->nonce[10], wpak->nonce[11], wpak->nonce[12], wpak->nonce[13], wpak->nonce[14], wpak->nonce[15],\n\twpak->nonce[16], wpak->nonce[17], wpak->nonce[18], wpak->nonce[19], wpak->nonce[20], wpak->nonce[21], wpak->nonce[22], wpak->nonce[23], wpak->nonce[24], wpak->nonce[25], wpak->nonce[26], wpak->nonce[27], wpak->nonce[28], wpak->nonce[29], wpak->nonce[30], wpak->nonce[31]);\n\tif((status & HAS_PTK_CALC) == HAS_PTK_CALC)\n\t\t{\n\t\tfprintf(stdout, \"PTK.........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x (calculated)\\n\",\n\t\tptkcalculated[0], ptkcalculated[1], ptkcalculated[2], ptkcalculated[3], ptkcalculated[4], ptkcalculated[5], ptkcalculated[6], ptkcalculated[7], ptkcalculated[8], ptkcalculated[9], ptkcalculated[10], ptkcalculated[11], ptkcalculated[12], ptkcalculated[13], ptkcalculated[14], ptkcalculated[15],\n\t\tptkcalculated[16], ptkcalculated[17], ptkcalculated[18], ptkcalculated[19], ptkcalculated[20], ptkcalculated[21], ptkcalculated[22], ptkcalculated[23], ptkcalculated[24], ptkcalculated[25], ptkcalculated[26], ptkcalculated[27], ptkcalculated[28], ptkcalculated[29], ptkcalculated[30], ptkcalculated[31]);\n\n\t\tfprintf(stdout, \"KCK.........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x (calculated)\\n\",\n\t\tptkcalculated[0], ptkcalculated[1], ptkcalculated[2], ptkcalculated[3], ptkcalculated[4], ptkcalculated[5], ptkcalculated[6], ptkcalculated[7], ptkcalculated[8], ptkcalculated[9], ptkcalculated[10], ptkcalculated[11], ptkcalculated[12], ptkcalculated[13], ptkcalculated[14], ptkcalculated[15]);\n\n\t\tfprintf(stdout, \"KEK.........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x (calculated)\\n\",\n\t\tptkcalculated[16], ptkcalculated[17], ptkcalculated[18], ptkcalculated[19], ptkcalculated[20], ptkcalculated[21], ptkcalculated[22], ptkcalculated[23], ptkcalculated[24], ptkcalculated[25], ptkcalculated[26], ptkcalculated[27], ptkcalculated[28], ptkcalculated[29], ptkcalculated[30], ptkcalculated[31]);\n\t\t}\n\tfprintf(stdout, \"MIC.........: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n\tmic[0], mic[1], mic[2], mic[3], mic[4], mic[5], mic[6], mic[7], mic[8], mic[9], mic[10], mic[11], mic[12], mic[13], mic[14], mic[15]);\n\tif(memcmp(mic, miccalculated, 16) == 0)\n\t\t{\n\t\tfprintf(stdout, \" (confirmed)\\n\");\n\t\tif(status & HAS_PMKID_CALC)\n\t\t\t{\n\t\t\tfprintf(stdout, \"PMKID.......: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x (calculated)\\n\",\n\t\t\tpmkidcalculated[0], pmkidcalculated[1], pmkidcalculated[2], pmkidcalculated[3], pmkidcalculated[4], pmkidcalculated[5], pmkidcalculated[6], pmkidcalculated[7], pmkidcalculated[8], pmkidcalculated[9], pmkidcalculated[10], pmkidcalculated[11], pmkidcalculated[12], pmkidcalculated[13], pmkidcalculated[14], pmkidcalculated[15]);\n\t\t\t}\n\t\texitcode = EXIT_SUCCESS_CONFIRMED;\n\t\t}\n\telse fprintf(stdout, \" (not confirmed)\\n\");\n\t}\nfprintf(stdout, \"\\n\");\nreturn;\n}\n/*===========================================================================*/\nstatic bool genmicwpa2kv3(void)\n{\nstatic uint8_t eapoltmp[1024];\n\nmemset(eapoltmp, 0, 1024);\nmemcpy(eapoltmp, eapol, eapollen);\nif(!EVP_MAC_init(ctxcmac, ptkcalculated, 16, paramsaes128)) return false;\nif(!EVP_MAC_update(ctxcmac, eapoltmp, eapollen)) return false;\nif(!EVP_MAC_final(ctxcmac, eapoltmp, NULL, eapollen)) return false;\nmemcpy(miccalculated, eapoltmp, 16);\nreturn true;\n}\n/*===========================================================================*/\nstatic bool genmicwpa1(void)\n{\nstatic uint8_t eapoltmp[1024];\n\nmemset(eapoltmp, 0, 1024);\nmemcpy(eapoltmp, eapol, eapollen);\nif(!EVP_MAC_init(ctxhmac, ptkcalculated, 16, paramsmd5)) return false;\nif(!EVP_MAC_update(ctxhmac, eapoltmp, eapollen)) return false;\nif(!EVP_MAC_final(ctxhmac, eapoltmp, NULL, eapollen)) return false;\nmemcpy(miccalculated, eapoltmp, 16);\nreturn true;\n}\n/*===========================================================================*/\nstatic bool genmicwpa2(void)\n{\nstatic uint8_t eapoltmp[1024];\n\nmemset(eapoltmp, 0, 1024);\nmemcpy(eapoltmp, eapol, eapollen);\nif(!EVP_MAC_init(ctxhmac, ptkcalculated, 16, paramssha1)) return false;\nif(!EVP_MAC_update(ctxhmac, eapoltmp, eapollen)) return false;\nif(!EVP_MAC_final(ctxhmac, eapoltmp, NULL, eapollen)) return false;\nmemcpy(miccalculated, eapoltmp, 16);\nreturn true;\n}\n/*===========================================================================*/\nstatic bool genptkwpa2kv3(void)\n{\nstatic uint8_t *pkeptr;\n\nmemset(&ptkcalculated, 0, 128);\npkeptr = ptkcalculated;\npkeptr[0] = 1;\npkeptr[1] = 0;\npkeptr += 2;\nmemcpy(pkeptr, \"Pairwise key expansion\", 22);\nif(memcmp(macap, macclient, 6) < 0)\n\t{\n\tmemcpy(pkeptr +22, macap, 6);\n\tmemcpy(pkeptr +28, macclient, 6);\n\t}\nelse\n\t{\n\tmemcpy(pkeptr +22, macclient, 6);\n\tmemcpy(pkeptr +28, macap, 6);\n\t}\nif(memcmp(anonce, wpak->nonce, 32) < 0)\n\t{\n\tmemcpy (pkeptr +34, anonce, 32);\n\tmemcpy (pkeptr +66, wpak->nonce, 32);\n\t}\nelse\n\t{\n\tmemcpy (pkeptr +34, wpak->nonce, 32);\n\tmemcpy (pkeptr +66, anonce, 32);\n\t}\n\nptkcalculated[100] = 0x80;\nptkcalculated[101] = 1;\nif(!EVP_MAC_init(ctxhmac, pmkcalculated, 32, paramssha256)) return false;\nif(!EVP_MAC_update(ctxhmac, ptkcalculated, 102)) return false;\nif(!EVP_MAC_final(ctxhmac, ptkcalculated, NULL, 128)) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool genptkwpa12(void)\n{\nstatic uint8_t *pkeptr;\n\npkeptr = ptkcalculated;\nmemcpy(pkeptr, \"Pairwise key expansion\", 23);\nif(memcmp(macap, macclient, 6) < 0)\n\t{\n\tmemcpy(pkeptr +23, macap, 6);\n\tmemcpy(pkeptr +29, macclient, 6);\n\t}\nelse\n\t{\n\tmemcpy(pkeptr +23, macclient, 6);\n\tmemcpy(pkeptr +29, macap, 6);\n\t}\nif(memcmp(anonce,  wpak->nonce, 32) < 0)\n\t{\n\tmemcpy (pkeptr +35, anonce, 32);\n\tmemcpy (pkeptr +67, wpak->nonce, 32);\n\t}\nelse\n\t{\n\tmemcpy (pkeptr +35, wpak->nonce, 32);\n\tmemcpy (pkeptr +67, anonce, 32);\n\t}\nif(!EVP_MAC_init(ctxhmac, pmkcalculated, 32, paramssha1)) return false;\nif(!EVP_MAC_update(ctxhmac, ptkcalculated, 100)) return false;\nif(!EVP_MAC_final(ctxhmac, ptkcalculated, NULL, 128)) return false;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool genpmkid(void)\n{\nstatic const char *pmkname = \"PMK Name\";\n\nmemcpy(pmkidcalculated, pmkname, 8);\nmemcpy(pmkidcalculated +8, macap, 6);\nmemcpy(pmkidcalculated +14, macclient, 6);\nif(!EVP_MAC_init(ctxhmac, pmkcalculated, 32, paramssha1)) return false;\nif(!EVP_MAC_update(ctxhmac, pmkidcalculated, 20)) return false;\nif(!EVP_MAC_final(ctxhmac, pmkidcalculated, NULL, 20)) return false;\nstatus |= HAS_PMKID_CALC;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool genpmk(char *psk)\n{\nmemset(pmkcalculated, 0, 32);\nif(PKCS5_PBKDF2_HMAC_SHA1(psk, psklen, essid, essidlen, 4096, 32, pmkcalculated) == 0) return false;\nstatus |= HAS_PMK_CALC;\nreturn true;\n}\n/*===========================================================================*/\nstatic bool parsehashlinestring(char *hashlinestring)\n{\nstatic size_t hlen;\nstatic size_t plen;\nstatic ssize_t flen;\n\nstatic const char *wpa1 = \"WPA*01*\";\nstatic const char *wpa2 = \"WPA*02*\";\n\nhlen = strlen(hashlinestring);\nif(hlen < 71) return false;\nplen = 7;\nif(memcmp(wpa1, hashlinestring, 7) == 0)\n\t{\n\tflen = hex2bin(&hashlinestring[plen], pmkid, 16);\n\tif(flen != 16) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = hex2bin(&hashlinestring[plen], macap, 6);\n\tif(flen != 6) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = hex2bin(&hashlinestring[plen], macclient, 6);\n\tif(flen != 6) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tessidlen = hex2bin(&hashlinestring[plen], essid, 34);\n\tif((essidlen <= 0) || (essidlen > 32)) return false;\n\tplen += essidlen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tstatus |= HAS_PMKID_LINE;\n\tstatus |= HAS_PMKID;\n\tstatus |= HAS_ESSID;\n\tstatus |= HAS_MACAP;\n\tstatus |= HAS_MACCLIENT;\n\treturn true;\n\t}\nif(memcmp(wpa2, hashlinestring, 7) == 0)\n\t{\n\tflen = hex2bin(&hashlinestring[plen], mic, 16);\n\tif(flen != 16) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = hex2bin(&hashlinestring[plen], macap, 6);\n\tif(flen != 6) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = hex2bin(&hashlinestring[plen], macclient, 6);\n\tif(flen != 6) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = getfieldlen(&hashlinestring[plen], 34);\n\tif((flen %2) != 0) return false;\n\tflen /= 2;\n\tif((flen <= 0) || (flen > 32)) return false;\n\tessidlen = hex2bin(&hashlinestring[plen], essid, flen);\n\tif((essidlen <= 0) || (essidlen > 32)) return false;\n\tplen += essidlen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = hex2bin(&hashlinestring[plen], anonce, 32);\n\tif(flen == -1) return false;\n\tplen += flen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\tflen = getfieldlen(&hashlinestring[plen], 1024);\n\tif((flen %2) != 0) return false;\n\tflen /= 2;\n\tif((flen <= 0) || (flen > 1024)) return false;\n\teapollen = hex2bin(&hashlinestring[plen], eapol, flen);\n\teapptr = (eapauth_t*)eapol;\n\teapauthlen = ntohs(eapptr->len);\n\tif(eapollen < eapauthlen +4) return false;\n\tplen += eapollen *2;\n\tif(hashlinestring[plen++] != '*') return false;\n\twpak = (wpakey_t*)(eapol +EAPAUTH_SIZE);\n\tkeyversion = ntohs(wpak->keyinfo) & WPA_KEY_INFO_TYPE_MASK;\n\tstatus |= HAS_EAPOL_LINE;\n\tstatus |= HAS_MIC;\n\tstatus |= HAS_ESSID;\n\tstatus |= HAS_MACAP;\n\tstatus |= HAS_MACCLIENT;\n\treturn true;\n\t}\nreturn false;\n}\n/*===========================================================================*/\nstatic bool evpdeinitwpa(void)\n{\nif(ctxhmac != NULL)\n\t{\n\tEVP_MAC_CTX_free(ctxhmac);\n\tEVP_MAC_free(hmac);\n\t}\nif(ctxcmac != NULL)\n\t{\n\tEVP_MAC_CTX_free(ctxcmac);\n\tEVP_MAC_free(cmac);\n\t}\nEVP_cleanup();\nCRYPTO_cleanup_all_ex_data();\nERR_free_strings();\nreturn true;\n}\n/*===========================================================================*/\nstatic bool evpinitwpa(void)\n{\nERR_load_crypto_strings();\nOpenSSL_add_all_algorithms();\n\nhmac = NULL;\nctxhmac = NULL;\ncmac = NULL;\nctxcmac = NULL;\n\nhmac = EVP_MAC_fetch(NULL, \"hmac\", NULL);\nif(hmac == NULL) return false;\ncmac = EVP_MAC_fetch(NULL, \"cmac\", NULL);\nif(cmac == NULL) return false;\n\nchar md5[] = \"md5\";\nparamsmd5[0] = OSSL_PARAM_construct_utf8_string(\"digest\", md5, 0);\nparamsmd5[1] = OSSL_PARAM_construct_end();\n\nchar sha1[] = \"sha1\";\nparamssha1[0] = OSSL_PARAM_construct_utf8_string(\"digest\", sha1, 0);\nparamssha1[1] = OSSL_PARAM_construct_end();\n\nchar sha256[] = \"sha256\";\nparamssha256[0] = OSSL_PARAM_construct_utf8_string(\"digest\", sha256, 0);\nparamssha256[1] = OSSL_PARAM_construct_end();\n\nchar aes[] = \"aes-128-cbc\";\nparamsaes128[0] = OSSL_PARAM_construct_utf8_string(\"cipher\", aes, 0);\nparamsaes128[1] = OSSL_PARAM_construct_end();\n\nctxhmac = EVP_MAC_CTX_new(hmac);\nif(ctxhmac == NULL) return false;\nctxcmac = EVP_MAC_CTX_new(cmac);\nif(ctxcmac == NULL) return false;\nreturn true;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic inline void version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic inline void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s  (C) %s ZeroBeat\\n\"\n\t\"usage  : %s <options>\\n\"\n\t\"\\n\"\n\t\"short options:\\n\"\n\t\"-l <hash line> : input hashcat hash line (-m 22000)\\n\"\n\t\"-e <ESSID>     : input Network Name (ESSID)\\n\"\n\t\"-p <PSK>       : input Pre Shared Key (PSK) or Plain Master Key (PMK)\\n\"\n\t\"-p -           : read Pre Shared Key (PSK) from stdin\\n\"\n\t\"               : small lists only\\n\"\n\t\"\\n\"\n\t\"long options:\\n\"\n\t\"--help         : show this help\\n\"\n\t\"--version      : show version\\n\\n\"\n\t\"exit codes:\\n\"\n\t\"0 = PSK/PMK confirmed\\n\"\n\t\"1 = ERROR occurred\\n\"\n\t\"2 = PSK/PMK unconfirmed\\n\"\n\t\"\\n\"\n\t\"Important notice:\\n\"\n\t\"%s does not do NONCE ERROR CORRECTIONS\\n\"\n\t\"in case of a packet loss, you get a wrong PTK\\n\"\n\t\"\\n\",\n\teigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic inline void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic char *hashlinestring;\nstatic char pskbuffer[128];\n\nstatic const char *short_options = \"l:e:p:m:a:c:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCX_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCX_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\nexitcode = EXIT_SUCCESS_UNCONFIRMED;\nstatus = 0;\nessidlen = 0;\nhashlinestring = NULL;\npskstring = NULL;\n\nwhile((auswahl = getopt_long(argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCX_HASHLINE:\n\t\thashlinestring = optarg;\n\t\tbreak;\n\n\t\tcase HCX_PSK:\n\t\tpskstring = optarg;\n\t\tbreak;\n\n\t\tcase HCX_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\nrun %s --help to get more information\\n\", (basename(argv[0])));\n\texit(EXIT_FAILURE);\n\t}\nif(evpinitwpa() == false)\n\t{\n\tfprintf(stderr, \"\\nEVP API error\\n\");\n\treturn EXIT_FAILURE;\n\t}\nif(hashlinestring != NULL)\n\t{\n\tif(parsehashlinestring(hashlinestring) == false)\n\t\t{\n\t\tfprintf(stdout, \"hash line error\\n\");\n\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\nif(pskstring != NULL)\n\t{\n\tpsklen = strlen(pskstring);\n\tif((psklen >= 8) &&(psklen < 63)) \n\t\t{\n\t\tstatus |= HAS_PSK;\n\t\tif((status & HAS_ESSID) == HAS_ESSID)\n\t\t\t{\n\t\t\tif(genpmk(pskstring) == false)\n\t\t\t\t{\n\t\t\t\tfprintf(stderr, \"\\nPMK error\\n\");\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\telse if(psklen == 64) \n\t\t{\n\t\tif(hex2bin(pskstring, pmkcalculated, 32) != 32)\n\t\t\t{\n\t\t\tfprintf(stderr, \"\\nPMK error\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\tstatus |= HAS_PMK;\n\t\t}\n\telse if(strncmp(pskstring, \"-\", 1) == 0)\n\t\t{\n\t\tif((status & HAS_ESSID) == HAS_ESSID)\n\t\t\t{\n\t\t\tif((status & HAS_PMKID) == HAS_PMKID)\n\t\t\t\t{\n\t\t\t\twhile(1)\n\t\t\t\t\t{\n\t\t\t\t\tif((psklen = fgetline(stdin, 128, pskbuffer)) == -1) break;\n\t\t\t\t\tif((psklen < 8) || (psklen > 63)) continue;\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif(genpmk(pskbuffer) == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfprintf(stderr, \"\\nPMK error\\n\");\n\t\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(genpmkid() == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfprintf(stderr, \"\\nPMK error\\n\");\n\t\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(memcmp(pmkid, pmkidcalculated, 16) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpskstring = pskbuffer;\n\t\t\t\t\t\t\tstatus |= HAS_PSK;\n\t\t\t\t\t\t\tshowresult();\n\t\t\t\t\t\t\texit(EXIT_SUCCESS_CONFIRMED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(evpdeinitwpa() == false)\n\t\t\t\t\t{\n\t\t\t\t\tfprintf(stdout, \"EVP API error\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t}\n\t\t\tif((status & HAS_MIC) == HAS_MIC)\n\t\t\t\t{\n\t\t\t\tif(keyversion == 2)\n\t\t\t\t\t{\n\t\t\t\t\twhile(1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif((psklen = fgetline(stdin, 128, pskbuffer)) == -1) break;\n\t\t\t\t\t\tif((psklen < 8) || (psklen > 63)) continue;\n\t\t\t\t\t\tif(genpmk(pskbuffer) == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(genptkwpa12() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(genmicwpa2() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(memcmp(mic, miccalculated, 16) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(genpmkid() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\t\tpskstring = pskbuffer;\n\t\t\t\t\t\t\tstatus |= HAS_PSK;\n\t\t\t\t\t\t\tstatus |= HAS_PTK_CALC;\n\t\t\t\t\t\t\tstatus |= HAS_PMKID_CALC;\n\t\t\t\t\t\t\tshowresult();\n\t\t\t\t\t\t\texit(EXIT_SUCCESS_CONFIRMED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tif(evpdeinitwpa() == false) exit(EXIT_FAILURE);\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\t}\n\t\t\t\tif(keyversion == 1)\n\t\t\t\t\t{\n\t\t\t\t\twhile(1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif((psklen = fgetline(stdin, 128, pskbuffer)) == -1) break;\n\t\t\t\t\t\tif((psklen < 8) || (psklen > 63)) continue;\n\t\t\t\t\t\tif(genpmk(pskbuffer) == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(genptkwpa12() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(genmicwpa1() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(memcmp(mic, miccalculated, 16) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(genpmkid() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\t\tpskstring = pskbuffer;\n\t\t\t\t\t\t\tstatus |= HAS_PSK;\n\t\t\t\t\t\t\tstatus |= HAS_PTK_CALC;\n\t\t\t\t\t\t\tstatus |= HAS_PMKID_CALC;\n\t\t\t\t\t\t\tshowresult();\n\t\t\t\t\t\t\texit(EXIT_SUCCESS_CONFIRMED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tif(evpdeinitwpa() == false) exit(EXIT_FAILURE);\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\t}\n\t\t\t\tif(keyversion == 3)\n\t\t\t\t\t{\n\t\t\t\t\twhile(1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tif((psklen = fgetline(stdin, 128, pskbuffer)) == -1) break;\n\t\t\t\t\t\tif((psklen < 8) || (psklen > 63)) continue;\n\t\t\t\t\t\tif(genpmk(pskbuffer) == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(genptkwpa2kv3() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(genmicwpa2kv3() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\tif(memcmp(mic, miccalculated, 16) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(genpmkid() == false) exit(EXIT_FAILURE);\n\t\t\t\t\t\t\tpskstring = pskbuffer;\n\t\t\t\t\t\t\tstatus |= HAS_PSK;\n\t\t\t\t\t\t\tstatus |= HAS_PTK_CALC;\n\t\t\t\t\t\t\tstatus |= HAS_PMKID_CALC;\n\t\t\t\t\t\t\tshowresult();\n\t\t\t\t\t\t\texit(EXIT_SUCCESS_CONFIRMED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tif(evpdeinitwpa() == false) exit(EXIT_FAILURE);\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\t}\n\t\t\t\tif(evpdeinitwpa() == false) exit(EXIT_FAILURE);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nif((((status & HAS_PMK_CALC) == HAS_PMK_CALC) || ((status & HAS_PMK) == HAS_PMK)) && ((status & HAS_PMKID) == HAS_PMKID))\n\t{\n\tif(genpmkid() == false)\n\t\t{\n\t\tfprintf(stderr, \"\\nPMKID error\\n\");\n\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\nif((status & HAS_EAPOL_LINE) == HAS_EAPOL_LINE)\n\t{\n\tif((keyversion == 0) || (keyversion > 3))\n\t\t{\n\t\tfprintf(stderr, \"\\nkey version error\\n\");\n\t\treturn EXIT_FAILURE;\n\t\t}\n\tif(((status & HAS_PMK_CALC) == HAS_PMK_CALC) || ((status & HAS_PMK) == HAS_PMK))\n\t\t{\n\t\tif(keyversion < 3)\n\t\t\t{\n\t\t\tif(genptkwpa12() == false) return false;\n\t\t\tif(keyversion == 2)\n\t\t\t\t{\n\t\t\t\tif(genmicwpa2() == false) return false;\n\t\t\t\tif(genpmkid() == false) return false;\n\t\t\t\tstatus |= HAS_PTK_CALC;\n\t\t\t\tstatus |= HAS_PMKID_CALC;\n\t\t\t\t}\n\t\t\tif(keyversion == 1)\n\t\t\t\t{\n\t\t\t\tif(genmicwpa1() == false) return false;\n\t\t\t\tif(genpmkid() == false) return false;\n\t\t\t\tstatus |= HAS_PTK_CALC;\n\t\t\t\tstatus |= HAS_PMKID_CALC;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif(genptkwpa2kv3() == false) return false;\n\t\t\tif(genmicwpa2kv3() == false) return false;\n\t\t\tif(genpmkid() == false) return false;\n\t\t\tstatus |= HAS_PTK_CALC;\n\t\t\tstatus |= HAS_PMKID_CALC;\n\t\t\t}\n\t\t}\n\t}\n\nshowresult();\n\nif(evpdeinitwpa() == false)\n\t{\n\tfprintf(stdout, \"EVP API error\\n\");\n\texit(EXIT_FAILURE);\n\t}\nexit(exitcode);\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "hcxpsktool.c",
          "type": "blob",
          "size": 106.263671875,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/crypto.h>\n#include <openssl/err.h>\n#include <openssl/evp.h>\n#include <openssl/types.h>\n\n#include \"include/hcxpsktool.h\"\n#include \"include/hashcatops.h\"\n#include \"include/strings.c\"\n#include \"include/fileops.c\"\n/*===========================================================================*/\n/* global var */\n\nstatic apessidl_t *apessidliste;\nstatic int apessidcount;\nstatic unsigned int thisyear;\n\nstatic bool airtelflag;\nstatic bool alticeoptimumflag;\nstatic bool asusflag;\nstatic bool digit10flag;\nstatic bool easyboxflag;\nstatic bool eeflag;\nstatic bool eeupperflag;\nstatic bool egnflag;\nstatic bool eudateflag;\nstatic bool hb5flag;\nstatic bool maconlyflag;\nstatic bool netgearflag;\nstatic bool noessidcombinationflag;\nstatic bool phomeflag;\nstatic bool podaflag;\nstatic bool simpleflag;\nstatic bool spectrumflag;\nstatic bool tendaflag;\nstatic bool ukrtelecomflag;\nstatic bool usdateflag;\nstatic bool weakpassflag;\nstatic bool wpskeysflag;\nstatic bool znidflag;\n\nstatic uint8_t essidglen;\n/*===========================================================================*/\nstatic void globalinit(void)\n{\nstatic time_t t;\nstatic struct tm *tm;\n\napessidliste = NULL;\napessidcount = 0;\nessidglen = 32;\nt = time(NULL);\ntm = localtime(&t);\nthisyear = tm->tm_year +1900;\nERR_load_crypto_strings();\nOpenSSL_add_all_algorithms();\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\nstatic void writepsk(FILE *fhout, const char *pskstring)\n{\nstatic bool lflag = false;\nstatic bool uflag = false;\nstatic int p, l;\nstatic char lowerpskstring[PSKSTRING_LEN_MAX] = { 0 };\nstatic char upperpskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nl = strlen(pskstring);\nif((l < 8) || (l > PSKSTRING_LEN_MAX)) return;\nfprintf(fhout,\"%s\\n\", pskstring);\nfor(p = 0; p < l; p++)\n\t{\n\tif(islower((unsigned char)pskstring[p]))\n\t\t{\n\t\tupperpskstring[p] = toupper((unsigned char)pskstring[p]);\n\t\tuflag = true;\n\t\t}\n\telse upperpskstring[p] = pskstring[p];\n\tif(isupper((unsigned char)pskstring[p]))\n\t\t{\n\t\tlowerpskstring[p] = tolower((unsigned char)pskstring[p]);\n\t\tlflag = true;\n\t\t}\n\telse lowerpskstring[p] = pskstring[p];\n\t}\nupperpskstring[p] = 0;\nlowerpskstring[p] = 0;\nif(uflag == true) fprintf(fhout,\"%s\\n\", upperpskstring);\nif(lflag == true) fprintf(fhout,\"%s\\n\", lowerpskstring);\nif((lowerpskstring[0] >= 'a') && (lowerpskstring[0] <= 'z'))\n\t{\n\tlowerpskstring[0] = toupper((unsigned char)lowerpskstring[0]);\n\tfprintf(fhout,\"%s\\n\", lowerpskstring);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywritedigit10(FILE *fhout)\n{\nstatic int i;\nstatic uint16_t f1, f2;\nstatic unsigned long long int ec, el, eu;\nstatic unsigned int digestmd5len;\nstatic EVP_MD_CTX* mdctx;\n\nstatic uint32_t fixseed1[] =\n{\n0xb100, 0xb300, 0xf200, 0xf800, 0xf900, 0xfa00\n};\n#define FIXSEED1_SIZE sizeof(fixseed1) /sizeof(uint32_t)\n\nstatic char message[PSKSTRING_LEN_MAX];\nstatic uint8_t digestmd5[EVP_MAX_MD_SIZE];\n\nfor(f1 = 0; f1 < FIXSEED1_SIZE; f1++)\n\t{\n\tfor(f2 = 0; f2 <=0xff; f2++)\n\t\t{\n\t\tfor(ec = 0; ec <= 0xffff; ec++)\n\t\t\t{\n\t\t\tsnprintf(message, PSKSTRING_LEN_MAX, \"D0542D-01%010lld\", ec | (fixseed1[f1] +f2) << 16);\n\t\t\tdigestmd5len = 16;\n\t\t\tmdctx = EVP_MD_CTX_create();\n\t\t\tif(mdctx == NULL) continue;\n\t\t\tif(EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) == 0)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_free(mdctx);\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif(EVP_DigestUpdate(mdctx, message, 19) == 0)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_free(mdctx);\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tif(EVP_DigestFinal_ex(mdctx, digestmd5, &digestmd5len) == 0)\n\t\t\t\t{\n\t\t\t\tEVP_MD_CTX_free(mdctx);\n\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\tEVP_MD_CTX_free(mdctx);\n\t\t\t}\n\t\tel = 0;\n\t\teu = 0;\n\t\tfor(i = 0; i < 8; i++)\n\t\t\t{\n\t\t\teu = (el >> 0x18 | ((eu << 8) &0xffffffff)) &0xffffffff;\n\t\t\tel = (((el << 8) &0xffffffff) | digestmd5[i + 8]) &0xffffffff;\n\t\t\t}\n\t\tfprintf(fhout, \"%010lld\\n\", ((eu << 32) +el) %0x2540be400);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywritenetgear(FILE *fhout)\n{\nstatic size_t ca, cs;\nstatic int cn;\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nstatic const char *firstword[] =\n{\n\"absurd\", \"ancient\", \"aquatic\",\n\"basic\", \"bass\", \"big\", \"black\", \"blue\", \"bold\", \"brave\", \"breezy\",\n\"bright\", \"brown\",\n\"calm\", \"cheerful\", \"chilly\", \"chummy\", \"classy\", \"clever\", \"cloudy\", \"cool\",\n\"crispy\", \"curly\",\n\"daily\", \"deep\", \"delightful\", \"dizzy\", \"dynamic\",\n\"eagle\", \"elated\", \"elegant\", \"epic\", \"excited\", \"exotic\", \"extra\",\n\"famous\", \"fancy\", \"fearless\", \"festive\", \"fluffy\", \"four\", \"free\", \"fresh\",\n\"friendly\", \"funny\", \"fuzzy\",\n\"gentle\", \"gifted\", \"gigantic\", \"graceful\", \"grand\", \"great\", \"green\",\n\"happy\", \"heavy\", \"helpful\", \"hot\", \"hungry\", \"husky\",\n\"icy\", \"imaginary\",\n\"jagged\", \"jagger\", \"jolly\", \"joyous\", \"juicy\", \"justic\",\n\"kind\",\n\"large\", \"light\", \"little\", \"lime\", \"lively\", \"long\", \"loud\", \"lucky\",\n\"lunar\",\n\"magical\", \"manic\", \"melodic\", \"mighty\", \"misty\", \"modern\",\n\"narrow\", \"new\", \"nifty\", \"noisy\",\n\"odd\", \"orange\",\n\"pastel\", \"perfect\", \"phobic\", \"pink\", \"plain\", \"polite\", \"precious\", \"purple\",\n\"quaint\", \"quick\", \"quiet\",\n\"rapid\", \"red\", \"rocky\", \"round\", \"royal\", \"ruby\", \"rustic\",\n\"savage\", \"shiny\", \"simple\", \"silent\", \"silky\", \"silly\", \"slow\", \"small\",\n\"smiley\", \"smiling\", \"smooth\", \"strong\", \"sunny\", \"sweet\",\n\"tablet\", \"thirsty\", \"thoughtful\", \"tiny\",\n\"ultra\", \"uneven\", \"unusual\",\n\"vanilla\", \"vast\",\n\"watery\", \"white\", \"wide\", \"windy\", \"witty\", \"wonderful\",\n\"yellow\", \"young\",\n\"zany\"\n};\n\nstatic const char *secondword[] =\n{\n\"airplane\", \"apple\",\n\"balloon\", \"banana\", \"bangle\", \"bay\", \"berry\", \"bike\", \"bird\", \"blue\",\n\"boat\", \"bolt\", \"boot\", \"box\", \"brain\", \"bread\", \"breeze\", \"bug\",\n\"butter\",\n\"canary\", \"canoe\", \"car\", \"carrot\", \"cartoon\", \"cat\", \"cello\", \"chair\",\n\"cheese\", \"coconut\", \"cold\", \"comet\", \"couture\", \"cream\", \"curtain\",\n\"daisy\", \"deer\", \"diamond\", \"dog\", \"domain\",\n\"earth\", \"ecasa\", \"elephant\",\n\"field\", \"finch\", \"fire\", \"fish\", \"flamingo\", \"flower\", \"flute\",\n\"gate\", \"gadfly\", \"giant\", \"goat\", \"grasshopper\",\n\"hat\", \"hill\", \"hippo\", \"house\",\n\"ink\", \"iris\",\n\"jade\", \"jet\", \"jetcar\", \"jungle\",\n\"kangaroo\", \"kayak\",\n\"lake\", \"lemon\", \"lightning\", \"link\", \"lion\", \"lotus\",\n\"mango\", \"mesa\", \"mint\", \"mobile\", \"moon\", \"mountain\",\n\"nest\", \"net\",\n\"oboe\", \"ocean\", \"octopus\", \"onion\", \"orchestra\", \"owl\",\n\"panda\", \"phoenix\", \"piano\", \"pineapple\", \"planet\", \"player\", \"plum\", \"police\",\n\"pond\", \"poodle\", \"potato\", \"prairie\",\n\"quail\",\n\"rabbit\", \"raccoon\", \"raven\", \"rise\", \"river\", \"road\", \"rosebud\",\n\"sea\", \"sheep\", \"ship\", \"shoe\", \"shrub\", \"skates\", \"sky\", \"snail\",\n\"shoe\", \"socks\", \"sparrow\", \"spider\", \"squash\", \"squirrel\", \"star\", \"stone\",\n\"street\", \"sun\",\n\"table\", \"tail\", \"teapot\", \"time\", \"tomato\", \"trail\", \"train\", \"tree\",\n\"truck\", \"trumpet\", \"tuba\", \"tulip\", \"turkey\",\n\"umbrella\", \"unicorn\", \"unit\",\n\"valley\", \"vase\", \"vinyl\", \"violet\", \"violin\",\n\"water\", \"way\", \"wind\", \"window\", \"wombat\",\n\"zoo\"\n};\n\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tfor (cn = 0; cn < 1000; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%03d\", firstword[ca], secondword[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tfor (cn = 0; cn < 100; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%02d\", firstword[ca], secondword[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tfor (cn = 0; cn < 10; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%d\", firstword[ca], secondword[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s\", firstword[ca], secondword[cs]);\n\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywritespectrum(FILE *fhout)\n{\nstatic size_t ca, cs;\nstatic int cn;\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nstatic const char *firstword[] =\n{\n\"absurd\", \"acre\", \"active\", \"actual\", \"adorable\", \"agency\", \"agent\", \"ago\",\n\"album\", \"alive\", \"all\", \"alter\", \"anchor\", \"ancient\", \"angry\", \"apart\",\n\"aquatic\", \"author\", \"aware\", \"away\", \"bakery\", \"barrel\", \"basic\", \"basket\",\n\"bench\", \"better\", \"black\", \"blue\", \"bold\", \"born\", \"botany\", \"brave\",\n\"breezy\", \"brew\", \"bridge\", \"brief\", \"bright\", \"broad\", \"brown\", \"busy\",\n\"calm\", \"camera\", \"chance\", \"check\", \"cheerful\", \"chilly\", \"choice\", \"chorus\",\n\"chummy\", \"classy\", \"clean\", \"clerk\", \"clever\", \"close\", \"cloudy\", \"clumsy\",\n\"coffee\", \"cold\", \"common\", \"content\", \"cool\", \"cosmic\", \"crispy\", \"curly\",\n\"daily\", \"damp\", \"dear\", \"decent\", \"deep\", \"degree\", \"desert\", \"dig\",\n\"direct\", \"dizzy\", \"dnamic\", \"domain\", \"double\", \"due\", \"dusty\", \"duty\",\n\"dynamic\", \"each\", \"eager\", \"eagle\", \"east\", \"easy\", \"eggplant\", \"either\",\n\"elated\", \"elegant\", \"empty\", \"energy\", \"engine\", \"enough\", \"entire\", \"epic\",\n\"epicn\", \"errand\", \"even\", \"evenp\", \"every\", \"exact\", \"excited\", \"exotic\",\n\"expert\", \"extra\", \"fair\", \"famous\", \"fancy\", \"farmer\", \"fast\", \"fearless\",\n\"festive\", \"few\", \"finish\", \"first\", \"fit\", \"fluent\", \"fluffy\", \"formal\",\n\"former\", \"free\", \"freep\", \"fresh\", \"friend\", \"friendly\", \"front\", \"frosty\",\n\"full\", \"funny\", \"furry\", \"future\", \"fuzzy\", \"gallon\", \"genius\", \"gentle\",\n\"giddy\", \"gifted\", \"glad\", \"global\", \"gold\", \"good\", \"goofy\", \"grain\",\n\"grand\", \"grateful\", \"great\", \"green\", \"grumpy\", \"guitar\", \"happy\", \"harbor\",\n\"hearty\", \"heavy\", \"height\", \"helpful\", \"high\", \"hockey\", \"home\", \"honest\",\n\"honor\", \"hot\", \"hotel\", \"hour\", \"hungry\", \"husky\", \"icy\", \"idea\",\n\"ideal\", \"imaginary\", \"immune\", \"input\", \"internal\", \"invent\", \"islan\", \"island\",\n\"jacket\", \"jagged\", \"jazz\", \"jeans\", \"jewel\", \"jolly\", \"joyous\", \"judge\",\n\"juicy\", \"just\", \"kettle\", \"key\", \"kind\", \"king\", \"kite\", \"knight\",\n\"known\", \"ladder\", \"ladderspace\", \"large\", \"last\", \"latter\", \"lazy\", \"leader\",\n\"least\", \"left\", \"legal\", \"less\", \"light\", \"like\", \"little\", \"lively\",\n\"living\", \"long\", \"lost\", \"lotus\", \"loud\", \"love\", \"loyal\", \"lucky\",\n\"magical\", \"major\", \"manic\", \"many\", \"marble\", \"market\", \"master\", \"medium\",\n\"mellow\", \"melodic\", \"middle\", \"mighty\", \"minute\", \"mirror\", \"misty\", \"mobile\",\n\"modern\", \"month\", \"most\", \"much\", \"museum\", \"narrow\", \"nature\", \"nearby\",\n\"neat\", \"nest\", \"new\", \"newj\", \"next\", \"nice\", \"nifty\", \"night\",\n\"nine\", \"noble\", \"noisy\", \"normal\", \"north\", \"novel\", \"oasis\", \"object\",\n\"ocean\", \"odd\", \"olive\", \"one\", \"only\", \"open\", \"orange\", \"other\",\n\"outlet\", \"oxygen\", \"palm\", \"palmw\", \"parade\", \"party\", \"past\", \"pastel\",\n\"patron\", \"perfect\", \"phobic\", \"phone\", \"pink\", \"plain\", \"plane\", \"pledge\",\n\"plenty\", \"plus\", \"pocket\", \"polite\", \"pony\", \"pool\", \"praise\", \"precious\",\n\"prior\", \"prize\", \"proof\", \"proper\", \"prose\", \"proud\", \"purple\", \"quaint\",\n\"quick\", \"quiet\", \"quote\", \"rain\", \"rainy\", \"rapid\", \"rare\", \"ready\",\n\"real\", \"reason\", \"recent\", \"red\", \"remedy\", \"remote\", \"review\", \"reward\",\n\"rich\", \"rocket\", \"rocky\", \"root\", \"rough\", \"round\", \"royal\", \"runner\",\n\"rusti\", \"rustic\", \"safe\", \"safety\", \"salt\", \"salute\", \"scary\", \"scout\",\n\"select\", \"senior\", \"shadow\", \"shelf\", \"shiny\", \"short\", \"silent\", \"silky\",\n\"silly\", \"silver\", \"simple\", \"sleepy\", \"slight\", \"slow\", \"small\", \"smart\",\n\"smiley\", \"smiling\", \"smooth\", \"soccer\", \"solid\", \"some\", \"south\", \"space\",\n\"spare\", \"square\", \"stable\", \"statue\", \"stealth\", \"still\", \"stock\", \"street\",\n\"strict\", \"strong\", \"studio\", \"such\", \"sudden\", \"summit\", \"sunny\", \"super\",\n\"sure\", \"sweet\", \"swift\", \"tablet\", \"tall\", \"teal\", \"terrific\", \"that\",\n\"theory\", \"thick\", \"think\", \"thirsty\", \"this\", \"tight\", \"timber\", \"tiny\",\n\"top\", \"total\", \"tough\", \"town\", \"train\", \"turtle\", \"uneven\", \"union\",\n\"unique\", \"unite\", \"unusual\", \"upset\", \"urban\", \"useful\", \"usual\", \"valley\",\n\"vanilla\", \"vast\", \"verse\", \"violet\", \"violin\", \"voyage\", \"wagon\", \"walnut\",\n\"warm\", \"watch\", \"watery\", \"weekly\", \"west\", \"whale\", \"what\", \"wide\",\n\"wild\", \"windy\", \"wine\", \"winter\", \"wise\", \"witty\", \"wonderful\", \"wooden\",\n\"worth\", \"writer\", \"yacht\", \"yard\", \"year\", \"yellow\", \"young\", \"youngs\",\n\"zany\", \"zeal\", \"zebra\", \"zone\"\n};\n\nstatic const char *secondword[] =\n{\n\"\", \"acre\", \"actor\", \"ad\", \"advice\", \"affect\", \"agency\", \"air\",\n\"airplane\", \"album\", \"anchor\", \"apple\", \"area\", \"art\", \"aspect\", \"ature\",\n\"author\", \"ave\", \"bakery\", \"ball\", \"balloon\", \"banana\", \"barrel\", \"basis\",\n\"basket\", \"beach\", \"bead\", \"bear\", \"beer\", \"bench\", \"berry\", \"bike\",\n\"bird\", \"board\", \"boat\", \"bolt\", \"bonus\", \"book\", \"boot\", \"botany\",\n\"box\", \"brain\", \"bread\", \"breeze\", \"bridge\", \"bubble\", \"bug\", \"bunny\",\n\"bus\", \"butter\", \"butterfly\", \"cafe\", \"camera\", \"canoe\", \"car\", \"card\",\n\"carrot\", \"cartoon\", \"cat\", \"cello\", \"chair\", \"check\", \"cheek\", \"cheese\",\n\"chill\", \"chorus\", \"city\", \"clerk\", \"client\", \"clock\", \"coat\", \"coconut\",\n\"coffee\", \"comet\", \"cookie\", \"cosmic\", \"country\", \"county\", \"course\", \"cow\",\n\"cream\", \"crown\", \"currency\", \"curtain\", \"daisy\", \"data\", \"day\", \"dealer\",\n\"deeper\", \"deer\", \"degree\", \"desert\", \"desk\", \"diamond\", \"dinner\", \"dirt\",\n\"disk\", \"dog\", \"doll\", \"domain\", \"drama\", \"drawer\", \"dremedy\", \"driver\",\n\"duty\", \"eagle\", \"ear\", \"earth\", \"editor\", \"effort\", \"energy\", \"engine\",\n\"epic\", \"errand\", \"error\", \"est\", \"estate\", \"event\", \"extent\", \"fact\",\n\"famous\", \"farmer\", \"field\", \"fig\", \"film\", \"finch\", \"finish\", \"fire\",\n\"fish\", \"flo\", \"flower\", \"fluent\", \"flute\", \"form\", \"formal\", \"fox\",\n\"friend\", \"gadfly\", \"gallon\", \"garden\", \"gate\", \"gene\", \"genius\", \"giant\",\n\"girl\", \"global\", \"goal\", \"grain\", \"green\", \"guest\", \"guide\", \"guitar\",\n\"guppy\", \"hair\", \"hall\", \"hand\", \"harbor\", \"hat\", \"height\", \"hill\",\n\"hippo\", \"hockey\", \"home\", \"hone\", \"honor\", \"horse\", \"hotel\", \"house\",\n\"idea\", \"idol\", \"immune\", \"income\", \"ink\", \"input\", \"invent\", \"iris\",\n\"island\", \"jacket\", \"jade\", \"jazz\", \"jeans\", \"jet\", \"jewel\", \"judge\",\n\"jungle\", \"kayak\", \"kettle\", \"key\", \"king\", \"kite\", \"knight\", \"ladder\",\n\"lake\", \"law\", \"lawn\", \"leader\", \"lemon\", \"length\", \"life\", \"light\",\n\"lion\", \"list\", \"lotus\", \"loyal\", \"major\", \"mall\", \"mango\", \"map\",\n\"marble\", \"market\", \"math\", \"meal\", \"media\", \"memory\", \"menu\", \"mesa\",\n\"method\", \"mint\", \"mirror\", \"mobile\", \"moment\", \"month\", \"moon\", \"movie\",\n\"mud\", \"museum\", \"music\", \"nail\", \"nation\", \"nature\", \"nest\", \"news\",\n\"night\", \"noble\", \"north\", \"number\", \"oasis\", \"object\", \"oboe\", \"ocean\",\n\"octopus\", \"office\", \"onion\", \"orange\", \"outlet\", \"owl\", \"own\", \"owner\",\n\"oxygen\", \"palm\", \"panda\", \"pant\", \"paper\", \"parade\", \"park\", \"parm\",\n\"patron\", \"peach\", \"pear\", \"pencil\", \"people\", \"phoenix\", \"phone\", \"piano\",\n\"pizza\", \"place\", \"planet\", \"player\", \"pledge\", \"plum\", \"pocket\", \"poem\",\n\"poet\", \"poetry\", \"policy\", \"pond\", \"poodle\", \"potato\", \"prairie\", \"praise\",\n\"prose\", \"puppy\", \"quail\", \"quaint\", \"quick\", \"quote\", \"rabbit\", \"raccoon\",\n\"radio\", \"raft\", \"rain\", \"rairie\", \"ratio\", \"raven\", \"reason\", \"region\",\n\"remedy\", \"review\", \"reward\", \"river\", \"road\", \"robin\", \"rock\", \"rocket\",\n\"role\", \"rose\", \"rosebud\", \"runner\", \"safety\", \"salad\", \"salute\", \"sample\",\n\"scout\", \"sea\", \"sector\", \"seed\", \"series\", \"shark\", \"sheep\", \"shelf\",\n\"ship\", \"shoe\", \"shrub\", \"side\", \"singer\", \"skates\", \"sky\", \"sled\",\n\"snail\", \"snake\", \"snall\", \"soccer\", \"socks\", \"sofa\", \"soks\", \"song\",\n\"soup\", \"space\", \"spark\", \"sparrow\", \"speech\", \"spider\", \"spoon\", \"squash\",\n\"squirrel\", \"squirrelp\", \"stable\", \"star\", \"state\", \"statue\", \"steak\", \"storm\",\n\"story\", \"stove\", \"straw\", \"street\", \"studio\", \"study\", \"summit\", \"sun\",\n\"table\", \"tablet\", \"tea\", \"teapot\", \"teapoty\", \"teen\", \"tennis\", \"tent\",\n\"thanks\", \"theory\", \"tiger\", \"timber\", \"time\", \"tomato\", \"tooth\", \"topic\",\n\"town\", \"trail\", \"train\", \"tree\", \"truck\", \"trumpet\", \"truth\", \"tuba\",\n\"tulip\", \"turkey\", \"turtle\", \"two\", \"type\", \"ungle\", \"unicorn\", \"union\",\n\"unit\", \"unite\", \"urban\", \"useful\", \"valley\", \"value\", \"vase\", \"verse\",\n\"video\", \"violet\", \"violin\", \"volume\", \"voyage\", \"wagon\", \"walnut\", \"watch\",\n\"wate\", \"water\", \"way\", \"wealth\", \"week\", \"west\", \"whale\", \"while\",\n\"wind\", \"window\", \"windy\", \"winner\", \"wolf\", \"work\", \"world\", \"writer\",\n\"yacht\", \"yard\", \"year\", \"youth\", \"zeal\", \"zebra\", \"zone\", \"zoo\"\n};\n\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tfor (cn = 0; cn < 1000; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%03d\", firstword[ca], secondword[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tfor (cn = 0; cn < 100; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%02d\", firstword[ca], secondword[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tfor (cn = 0; cn < 10; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%d\", firstword[ca], secondword[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nfor(ca = 0; ca < (sizeof(firstword) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(secondword) / sizeof(char *)); cs++)\n\t\t{\n\t\tif(strcmp(firstword[ca], secondword[cs]) == 0) continue;\n\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s\", firstword[ca], secondword[cs]);\n\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywritephome(FILE *fhout)\n{\nstatic size_t ca, cs;\nstatic int cn;\n\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nstatic const char *five[] =\n{\n\"about\", \"again\", \"agree\", \"ahead\", \"aisle\", \"alert\", \"alley\", \"allow\", \"amaze\", \"angle\", \"apple\", \"apron\", \"arrow\",\n\"attic\", \"award\",\n\"bacon\", \"badge\", \"bagel\", \"baked\", \"basic\", \"beard\", \"begin\", \"being\", \"below\", \"berry\", \"bison\", \"block\", \"bloom\", \"board\",\n\"boast\", \"bonus\", \"booth\", \"bored\", \"brace\", \"bread\", \"brick\", \"bring\", \"brush\", \"brook\", \"build\", \"built\",\n\"cabin\", \"cause\", \"chair\", \"camel\", \"canal\", \"chair\", \"charm\", \"chart\", \"charm\", \"chase\", \"check\", \"cheer\", \"chime\",\n\"chord\", \"chore\", \"chose\", \"chunk\", \"cough\", \"class\", \"clear\", \"coast\", \"cocoa\", \"cough\", \"cover\", \"count\", \"court\",\n\"creak\", \"cream\", \"creek\", \"crumb\", \"curve\",\n\"daily\", \"dairy\", \"daisy\", \"dance\", \"delay\", \"diner\", \"dodge\", \"dough\", \"dozed\", \"drain\", \"dried\", \"drink\",\n\"eager\", \"eagle\", \"earth\", \"eight\", \"elbow\", \"elect\", \"empty\", \"enter\", \"entry\", \"equal\", \"event\", \"exact\",\n\"fancy\", \"favor\", \"feast\", \"fence\", \"fever\", \"field\", \"fifty\"\n};\n\nstatic const char *six[] =\n{\n\"across\", \"action\", \"advice\", \"almost\", \"always\", \"amount\", \"anchor\", \"animal\", \"answer\", \"anyone\", \"anyway\", \"appear\",\n\"arctic\", \"around\", \"arrive\", \"artist\", \"autumn\", \"awhile\",\n\"baking\", \"banana\", \"basket\", \"become\", \"beside\", \"better\", \"borrow\", \"bottle\", \"breezy\", \"bridge\", \"bright\", \"bucket\",\n\"buckle\", \"button\",\n\"cactus\", \"called\", \"career\", \"carpet\", \"camera\", \"candid\", \"canvas\", \"canyon\", \"castle\", \"cattle\", \"caught\", \"celery\",\n\"cellar\", \"center\", \"chance\", \"change\", \"charge\", \"cheery\", \"chores\", \"chosen\", \"circle\", \"cities\", \"clever\", \"collar\",\n\"column\", \"comedy\", \"common\", \"copied\", \"corral\", \"county\", \"course\", \"create\", \"crumbs\", \"crunch\",\n\"degree\", \"depend\", \"design\", \"detail\", \"diesel\", \"dimmed\", \"dinner\", \"direct\",\n\"easier\", \"effect\", \"eighty\", \"eleven\", \"energy\", \"engine\", \"entire\", \"escape\",\n\"factor\", \"famous\", \"fasten\", \"faucet\", \"filter\", \"finish\", \"flight\", \"flower\", \"folded\", \"follow\", \"forest\",\n\"garden\", \"gather\", \"guitar\",\n\"happen\", \"harbor\", \"hardly\", \"health\"\n};\n\nfor(ca = 0; ca < (sizeof(five) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(six) / sizeof(char *)); cs++)\n\t\t{\n\t\tfor (cn = 0; cn < 10000; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%04d%s\", five[ca], cn, six[cs]);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%04d%s\", six[cs], cn, five[ca]);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywritetenda(FILE *fhout)\n{\nstatic size_t ca, cs;\nstatic int cn;\n\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nstatic const char *word[] =\n{\n\"able\", \"about\", \"above\", \"actor\", \"after\", \"again\", \"alone\", \"also\", \"apple\",\n\"baby\", \"back\", \"bath\", \"bean\", \"best\", \"bike\", \"bird\", \"blue\", \"body\", \"book\",\n\"cafe\", \"cake\", \"calm\", \"card\", \"carry\", \"cash\", \"chair\", \"child\", \"cold\", \"come\", \"cool\", \"cute\",\n\"daily\", \"dance\", \"dark\", \"dash\", \"dear\", \"desk\", \"done\", \"door\", \"down\", \"duck\", \"duty\",\n\"each\", \"early\", \"earth\", \"east\", \"easy\", \"edit\", \"envy\", \"even\", \"every\", \"exist\", \"exit\",\n\"face\", \"fact\", \"fall\", \"fast\", \"feed\", \"feel\", \"fill\", \"fish\", \"five\", \"four\",\n\"game\", \"ghost\", \"girl\", \"giude\", \"give\", \"good\", \"green\", \"group\", \"guest\",\n\"hair\", \"hand\", \"happy\", \"hard\", \"have\", \"haven\", \"head\", \"high\", \"hike\", \"horse\", \"house\",\n\"into\",\n\"jade\", \"jazz\", \"jean\", \"jeep\", \"join\", \"joke\", \"juice\", \"july\", \"june\",\n\"keep\", \"kind\",\n\"lable\", \"labor\", \"lack\", \"lake\", \"land\", \"light\", \"like\", \"live\", \"lock\", \"loop\", \"lose\",\n\"mail\", \"main\", \"major\", \"make\", \"math\", \"meet\", \"milk\", \"moon\", \"more\", \"most\", \"mouth\", \"much\",\n\"name\", \"near\", \"need\", \"nine\", \"none\", \"north\", \"nose\", \"note\",\n\"occur\", \"ocean\", \"once\", \"open\", \"over\",\n\"pace\", \"pain\", \"park\", \"part\", \"pass\", \"past\", \"path\", \"photo\", \"piece\", \"pink\",\n\"queen\", \"quest\", \"quick\", \"quit\", \"quite\",\n\"rainy\", \"reach\", \"read\", \"rice\", \"ride\", \"road\", \"room\", \"rope\", \"rose\", \"rule\", \"rush\",\n\"safe\", \"said\", \"sale\", \"salt\", \"same\", \"sick\", \"soul\", \"soup\", \"south\", \"sunny\",\n\"table\", \"take\", \"tale\", \"talk\", \"tall\", \"team\", \"tell\", \"test\", \"think\", \"ture\",\n\"under\", \"unit\", \"upper\",\n\"walk\", \"waste\", \"water\", \"weak\", \"week\", \"west\", \"what\", \"where\", \"wind\", \"word\"\n};\n\nfor(ca = 0; ca < (sizeof(word) / sizeof(char *)); ca++)\n\t{\n\tfor(cs = 0; cs < (sizeof(word) / sizeof(char *)); cs++)\n\t\t{\n\t\tif (ca == cs) continue;\n\t\tfor (cn = 0; cn < 1000; cn++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%s%03d\", word[ca], word[cs], cn);\n\t\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t\t}\n\t\t}\n\tfor (cn = 0; cn < 10000; cn++)\n\t\t{\n\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%s%04d\", word[ca], cn);\n\t\tfprintf(fhout,\"%s\\n\", pskstring);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteee(FILE *fhout, bool upper)\n{\nstatic size_t w3, w4, w5;\n\nstatic char pskstring[16] = { 0 };\n\nconst char *pskmask = \"%s-%s-%s\\n\";\n\nchar** uword3 = NULL;\nchar** uword4 = NULL;\nchar** uword5 = NULL;\n\nstatic const char *word3[] =\n{\n\"abs\", \"ace\", \"act\", \"add\", \"ado\", \"age\", \"ago\", \"aid\", \"ail\", \"aim\", \"all\", \"amp\",\n\"any\", \"ape\", \"apt\", \"art\", \"ask\",\n\"bad\", \"bay\", \"bee\", \"beg\", \"bet\", \"bid\", \"big\", \"bow\", \"box\", \"bud\", \"bug\", \"bun\",\n\"bus\", \"buy\",\n\"cad\", \"cam\", \"can\", \"cob\", \"cog\", \"cop\", \"cud\", \"cup\", \"cut\",\n\"dam\", \"did\", \"die\", \"dig\", \"dim\", \"dip\", \"dog\", \"dry\", \"dub\", \"due\", \"dug\",\n\"ear\", \"ego\", \"elk\", \"end\", \"era\", \"eye\",\n\"fab\", \"fan\", \"far\", \"fat\", \"fax\", \"fee\", \"few\", \"fin\", \"fit\", \"fix\", \"fly\", \"fog\",\n\"fox\", \"fry\",\n\"gap\", \"gel\", \"gem\", \"get\", \"god\",\n\"hem\", \"hid\", \"hip\", \"hit\", \"hop\", \"hot\", \"how\", \"hub\",\n\"ice\", \"icy\", \"ink\", \"inn\",\n\"jar\", \"jet\", \"job\", \"jog\", \"jot\",\n\"key\",\n\"lag\", \"lap\", \"law\", \"lay\", \"led\", \"leg\", \"let\", \"lid\", \"lie\", \"lip\", \"lit\", \"lob\",\n\"lop\", \"lot\", \"low\",\n\"mad\", \"map\", \"max\", \"mid\", \"mix\", \"mob\", \"mop\", \"mow\", \"mud\", \"mug\",\n\"nag\", \"nap\", \"net\", \"new\", \"nod\", \"nor\", \"not\", \"now\",\n\"oar\", \"oat\", \"odd\", \"off\", \"oil\", \"old\", \"one\", \"opt\", \"our\", \"out\", \"owe\", \"own\",\n\"pad\", \"pal\", \"pay\", \"pea\", \"peg\", \"pen\", \"per\", \"pet\", \"pie\", \"pin\", \"ply\", \"pop\",\n\"pro\", \"pub\", \"put\",\n\"ran\", \"rat\", \"raw\", \"red\", \"rid\", \"rig\", \"rob\", \"rot\", \"rug\", \"run\",\n\"sad\", \"sea\", \"set\", \"sew\", \"shy\", \"sim\", \"sin\", \"sip\", \"sir\", \"sit\", \"six\", \"sow\",\n\"soy\", \"spy\",\n\"tad\", \"tag\", \"tap\", \"tax\", \"ten\", \"tic\", \"tip\", \"ton\", \"top\", \"tow\", \"toy\", \"try\",\n\"two\",\n\"use\",\n\"van\", \"vex\", \"vow\",\n\"wet\", \"win\", \"won\"\n};\n\nstatic const char *word4[] =\n{\n\"able\", \"acre\", \"aqua\", \"arch\", \"area\",\n\"bait\", \"bake\", \"bald\", \"ball\", \"bark\", \"base\", \"bath\", \"bats\", \"bead\", \"beat\", \"bell\", \"best\",\n\"boat\", \"boil\", \"bold\", \"bore\", \"both\", \"busy\",\n\"calm\", \"camp\", \"cape\", \"card\", \"case\", \"cash\", \"cent\", \"chef\", \"city\", \"clad\", \"clay\", \"club\",\n\"clue\", \"coat\", \"cook\", \"cool\", \"cope\", \"copy\", \"cute\",\n\"dame\", \"damp\", \"dare\", \"dash\", \"date\", \"days\", \"deaf\", \"deal\", \"desk\", \"dial\", \"dish\", \"dive\",\n\"door\", \"duty\", \"dove\", \"down\", \"draw\", \"drop\",\n\"each\", \"east\", \"edge\", \"edit\", \"epic\", \"even\", \"ever\", \"exit\",\n\"face\", \"fair\", \"fake\", \"fast\", \"fall\", \"fame\", \"fast\", \"fine\", \"firm\", \"flag\", \"flee\", \"foam\",\n\"fold\", \"foot\", \"four\", \"full\", \"fund\", \"fuse\",\n\"gaps\", \"gate\", \"gave\", \"gear\", \"gift\", \"glad\", \"gown\", \"gray\",\n\"half\", \"hang\", \"hard\", \"hats\", \"head\", \"heat\", \"hide\", \"high\", \"hill\", \"hint\", \"hire\", \"hold\",\n\"hook\", \"huge\", \"hurt\", \"hymn\",\n\"idea\", \"iron\",\n\"jets\", \"joke\", \"judo\",\n\"keen\", \"kiss\",\n\"lace\", \"lack\", \"land\", \"late\", \"lawn\", \"lazy\", \"less\", \"link\", \"live\", \"loaf\", \"loan\", \"logo\",\n\"look\", \"lord\", \"loss\", \"loud\",\n\"melt\", \"menu\", \"mere\", \"mill\", \"mine\", \"mint\", \"mist\", \"mode\", \"moon\", \"most\", \"move\", \"much\",\n\"name\", \"neat\", \"need\", \"nest\", \"noon\", \"nude\",\n\"oars\", \"oust\",\n\"pace\", \"pads\", \"page\", \"paid\", \"pain\", \"pale\", \"pane\", \"park\", \"pars\", \"part\", \"pass\", \"past\",\n\"pear\", \"pegs\", \"pens\", \"pier\", \"pine\", \"pins\", \"pint\", \"pity\", \"plan\", \"poem\", \"poet\", \"pond\",\n\"pool\", \"poor\", \"post\", \"pure\",\n\"rack\", \"rare\", \"real\", \"rest\", \"rich\", \"riot\", \"ripe\", \"road\", \"roam\", \"room\", \"root\", \"rude\",\n\"rule\",\n\"safe\", \"sail\", \"sale\", \"same\", \"sand\", \"save\", \"scan\", \"seal\", \"seat\", \"seem\", \"send\", \"sent\",\n\"shin\", \"shop\", \"shut\", \"sick\", \"side\", \"sift\", \"sign\", \"silk\", \"sing\", \"skip\", \"slim\", \"slip\",\n\"slum\", \"soap\", \"soil\", \"sold\", \"solo\", \"sore\", \"sour\", \"spit\", \"step\", \"stew\", \"sure\",\n\"tall\", \"teak\", \"team\", \"tear\", \"tent\", \"then\", \"tide\", \"time\", \"tone\", \"tour\", \"town\", \"trim\",\n\"trod\", \"true\", \"tube\", \"tune\", \"turn\",\n\"used\",\n\"vain\", \"vast\", \"vend\", \"vote\",\n\"wait\", \"walk\", \"want\", \"ward\", \"warn\", \"wave\", \"west\", \"wild\", \"wind\", \"wing\", \"wire\", \"wise\",\n\"worm\",\n\"zone\"\n};\n\nstatic const char *word5[] =\n{\n\"aback\", \"acres\", \"adapt\", \"agent\", \"agony\", \"ahead\", \"alarm\", \"alert\", \"align\", \"alien\", \"allot\", \"amble\",\n\"angle\", \"ankle\", \"arena\", \"armed\", \"arrow\", \"audio\", \"award\",\n\"beams\", \"bland\", \"blank\", \"bleak\", \"bless\", \"boast\", \"boost\", \"bored\", \"bread\", \"bring\", \"broke\", \"buyer\",\n\"cable\", \"cakes\", \"canoe\", \"cards\", \"cargo\", \"cause\", \"chair\", \"cheap\", \"chips\", \"choke\", \"climb\", \"clove\",\n\"coact\", \"coins\", \"comic\", \"cough\", \"count\", \"cover\", \"crane\", \"crash\", \"crude\", \"cruel\", \"cubic\", \"curry\",\n\"dairy\", \"delay\", \"dance\", \"dense\", \"desks\", \"diner\", \"dines\", \"dozen\", \"draft\", \"dream\", \"drink\", \"drown\",\n\"drunk\", \"dusts\", \"dusty\",\n\"early\", \"eight\", \"elder\", \"enter\", \"equal\", \"equip\", \"erode\", \"evens\", \"event\", \"exact\", \"exams\", \"excel\",\n\"extra\",\n\"fancy\", \"fares\", \"fence\", \"fibre\", \"fifty\", \"filed\", \"files\", \"final\", \"first\", \"floor\", \"flour\", \"flute\",\n\"focus\", \"foggy\", \"front\", \"fruit\",\n\"genie\", \"giant\", \"glare\", \"glaze\", \"gleam\", \"glory\", \"glows\", \"grave\", \"great\", \"grids\", \"group\", \"grove\",\n\"guess\", \"guest\",\n\"harps\", \"hawks\", \"heavy\", \"house\", \"humor\",\n\"ideal\", \"index\", \"infer\", \"inked\", \"ivory\",\n\"judge\",\n\"knock\",\n\"laces\", \"large\", \"lawny\", \"learn\", \"light\", \"lilac\", \"linen\", \"lofts\", \"loose\", \"lucky\", \"lunar\", \"lyric\",\n\"madam\", \"magic\", \"major\", \"malts\", \"manor\", \"maple\", \"march\", \"marry\", \"merit\", \"moist\", \"molar\", \"motto\",\n\"mourn\", \"mouse\", \"muddy\",\n\"nacho\", \"novel\", \"nurse\",\n\"odeon\", \"offer\", \"optic\",\n\"pages\", \"panda\", \"pants\", \"pause\", \"peace\", \"pedal\", \"pesto\", \"piano\", \"piece\", \"piety\", \"pings\", \"pious\",\n\"pivot\", \"place\", \"plant\", \"plate\", \"pound\", \"prime\", \"prize\", \"probe\", \"prose\", \"proud\", \"prune\", \"puppy\",\n\"pylon\",\n\"quiet\",\n\"rally\", \"refer\", \"remit\", \"renew\", \"repel\", \"reset\", \"roach\", \"rocky\", \"roofs\", \"rooks\", \"rough\", \"royal\",\n\"rusty\",\n\"salad\", \"scarf\", \"scoop\", \"scoot\", \"scope\", \"score\", \"scorn\", \"shaft\", \"share\", \"sharp\", \"sheds\", \"shine\",\n\"share\", \"shiny\", \"shirt\", \"shore\", \"shrub\", \"silly\", \"sixty\", \"skate\", \"socks\", \"sound\", \"spade\", \"spare\",\n\"spend\", \"spent\", \"squad\", \"stack\", \"stand\", \"stare\", \"stars\", \"start\", \"stats\", \"steam\", \"stick\", \"stoop\",\n\"storm\", \"story\", \"sunny\", \"sweat\", \"swept\", \"swift\", \"swing\", \"sword\",\n\"tally\", \"talon\", \"tempt\", \"tench\", \"tents\", \"these\", \"thick\", \"thief\", \"those\", \"tidal\", \"tiger\", \"title\",\n\"today\", \"track\", \"train\", \"tread\", \"trend\", \"trick\", \"trust\", \"tuned\", \"twigs\", \"twist\",\n\"unbid\", \"unbox\", \"uncap\", \"upend\", \"upper\", \"upset\",\n\"valid\", \"vends\", \"verge\", \"verse\", \"vines\", \"visit\",\n\"weary\", \"wheat\", \"wheel\", \"whole\", \"worth\", \"wound\", \"wrist\",\n\"yeast\",\n\"zooms\"\n};\n\nif (upper)\n    {\n    uword3 = create_upper_array(word3, sizeof(word3) / sizeof(char *));\n    uword4 = create_upper_array(word4, sizeof(word4) / sizeof(char *));\n    uword5 = create_upper_array(word5, sizeof(word5) / sizeof(char *));\n    }\n\nfor(w3 = 0; w3 < (sizeof(word3) / sizeof(char *)); w3++)\n\t{\n\tfor(w4 = 0; w4 < (sizeof(word4) / sizeof(char *)); w4++)\n\t\t{\n\t\tfor(w5 = 0; w5 < (sizeof(word5) / sizeof(char *)); w5++)\n\t\t\t{\n\t\t\tif (upper)\n\t\t\t    {\n\t\t\t    snprintf(pskstring, 16, pskmask, uword3[w3],  word4[w4],  word5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word3[w3], uword4[w4],  word5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word3[w3],  word4[w4], uword5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask, uword3[w3],  word5[w5],  word4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word3[w3], uword5[w5],  word4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word3[w3],  word5[w5], uword4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask, uword4[w4],  word3[w3],  word5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word4[w4], uword3[w3],  word5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word4[w4],  word3[w3], uword5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask, uword4[w4],  word5[w5],  word3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word4[w4], uword5[w5],  word3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word4[w4],  word5[w5], uword3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask, uword5[w5],  word3[w3],  word4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word5[w5], uword3[w3],  word4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word5[w5],  word3[w3], uword4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask, uword5[w5],  word4[w4],  word3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word5[w5], uword4[w4],  word3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    snprintf(pskstring, 16, pskmask,  word5[w5],  word4[w4], uword3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    snprintf(pskstring, 16, pskmask,  word3[w3],  word4[w4],  word5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask,  word3[w3],  word5[w5],  word4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask,  word4[w4],  word3[w3],  word5[w5]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask,  word4[w4],  word5[w5],  word3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask,  word5[w5],  word3[w3],  word4[w4]);\n\t\t\t    fputs(pskstring, fhout);\n\n\t\t\t    snprintf(pskstring, 16, pskmask,  word5[w5],  word4[w4],  word3[w3]);\n\t\t\t    fputs(pskstring, fhout);\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t}\n\nif (upper)\n    {\n    free_array(uword3, sizeof(word3) / sizeof(char *));\n    free_array(uword4, sizeof(word4) / sizeof(char *));\n    free_array(uword5, sizeof(word5) / sizeof(char *));\n    }\n\nreturn;\n}\n/*===========================================================================*/\n/* source: soxrok2212, https://github.com/soxrok2212/PSKracker/tree/master/dicts/altice-optimum */\nstatic void keywritealticeoptimum(FILE *fhout)\n{\nstatic unsigned int w, i;\nchar si[7] = {0};\n\nstatic const char *word[] =\n{\n\"amber\", \"aqua\", \"auburn\",\n\"beige\", \"blue\", \"brick\", \"bronze\", \"burgundy\",\n\"chestnut\", \"cobalt\", \"copper\", \"coral\", \"cordovan\", \"crimson\", \"cyan\",\n\"emerald\",\n\"garnet\", \"gold\", \"granite\", \"green\", \"grey\",\n\"indigo\",\n\"jade\",\n\"lavender\", \"lemon\", \"lime\", \"linen\",\n\"magenta\", \"maroon\", \"mauve\",\n\"navy\",\n\"olive\", \"orange\", \"orchid\",\n\"peach\", \"periwinkle\", \"pewter\", \"pink\", \"plum\", \"purple\",\n\"rose\",\n\"sage\", \"sepia\", \"sienna\", \"silver\", \"slate\",\n\"taupe\", \"teal\", \"turquoise\"\n};\n\nfor (i = 0; i < 1000000; i++)\n{\n    sprintf(si, \"%06d\", i);\n    for (w = 0; w < (sizeof(word) / sizeof(char *)); w++ )\n\t    {\n\t        // 2-4\n\t        //fprintf(fhout, \"%s-%.2s-%.4s\\n\", word[w], si, si+2);\n\t        fprintf(fhout, \"%.2s-%s-%.4s\\n\", si, word[w], si+2);\n\t        fprintf(fhout, \"%.2s-%.4s-%s\\n\", si, si+2, word[w]);\n\t        // 3-3\n\t        fprintf(fhout, \"%s-%.3s-%.3s\\n\", word[w], si, si+3);\n\t        fprintf(fhout, \"%.3s-%s-%.3s\\n\", si, word[w], si+3);\n\t        fprintf(fhout, \"%.3s-%.3s-%s\\n\", si, si+3, word[w]);\n\t        // 4-2\n\t        fprintf(fhout, \"%s-%.4s-%.2s\\n\", word[w], si, si+4);\n\t        fprintf(fhout, \"%.4s-%s-%.2s\\n\", si, word[w], si+4);\n\t        //fprintf(fhout, \"%.4s-%.2s-%s\\n\", si, si+4, word[w]);\n\t    }\n}\n\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteasus(FILE *fhout)\n{\nstatic unsigned int w, i;\n\nstatic const char *word[] =\n{\n\"account\", \"actor\", \"alpha\", \"amazing\", \"answer\", \"anyway\", \"athlete\", \"autumn\", \"avenue\",\n\"bakery\", \"balcony\", \"banking\", \"battery\", \"bedroom\", \"bicycle\", \"birthday\", \"browser\",\n\"calendar\", \"camping\", \"category\", \"center\", \"charming\", \"cinema\", \"cocoa\", \"coffee\", \"cupid\",\n\"december\", \"delivery\", \"delta\", \"dollar\", \"donkey\", \"drama\", \"dream\",\n\"economy\", \"enjoy\", \"eternity\", \"everyday\", \"examiner\", \"export\", \"extra\", \"eyebrow\",\n\"february\", \"feeling\", \"flower\", \"fortune\", \"founder\", \"four\",\n\"gasoline\", \"giant\", \"glory\", \"golden\", \"grape\", \"guide\",\n\"haircut\", \"handsome\", \"harmony\", \"hawk\", \"header\", \"hiking\", \"hometown\", \"honor\",\n\"hundred\", \"hunter\",\n\"jaguar\", \"jazz\", \"jogging\", \"july\", \"june\", \"jumper\", \"junior\", \"justdoit\",\n\"keeper\", \"keyboard\", \"kingdom\", \"kiss\", \"kitchen\", \"knife\", \"knuckle\",\n\"leopard\", \"letter\", \"lighting\", \"literacy\", \"lucky\", \"lunar\",\n\"majesty\", \"mankind\", \"mars\", \"memory\", \"mercy\", \"momentum\", \"morning\", \"museum\",\n\"network\", \"next\", \"night\", \"noodle\", \"notebook\", \"nurse\",\n\"painter\", \"pajamas\", \"panda\", \"parttime\", \"passion\", \"popcorn\", \"puma\", \"puppet\", \"pyramid\",\n\"random\", \"ranking\", \"reading\", \"relax\", \"remark\", \"revenue\", \"ribbon\",\n\"salon\", \"saturday\", \"science\", \"sexy\", \"soccer\", \"sour\", \"spider\", \"star\", \"sugar\", \"sunday\"\n};\n\nfor (w = 0; w < (sizeof(word) / sizeof(char *)); w++ )\n\t{\n\tfor (i = 0; i < 10000; i++)\n\t\t{\n\t\tfprintf(fhout, \"%s_%04d\\n\", word[w], i);\n\t\t}\n\t}\n\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteweakpass(FILE *fhout)\n{\nstatic size_t w;\nstatic unsigned int y;\n\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\nstatic const char *weakword[] =\n{\n\"00000000\", \"0000000000\", \"01234567\", \"0123456789\", \"0123456789012345\", \"022844444\", \"0987654321\",\n\"1029384756\", \"11111111\", \"1111111111\", \"111222333\", \"11223344\", \"1122334455\", \"11235813\",\n\"1123581321\", \"12121212\", \"123123123\", \"123321123\", \"12341234\", \"12344321\", \"1234512345\",\n\"123454321\", \"1234554321\", \"12345678\", \"123456789\", \"1234567890\", \"12345678910\",\n\"123456789a\", \"12345678a\", \"1234567a\", \"123456abc\", \"12345qwert\", \"1234abcd\",\n\"1234qwer\", \"123654789\", \"12369874\", \"123698745\", \"123789456\", \"123qweasd\",\n\"123qweasdzxc\", \"12qwaszx\", \"1357924680\", \"147258369\", \"147852369\", \"14789632\",\n\"147896325\", \"192837465\", \"1a2b3c4d\", \"1q2w3e4r\", \"1q2w3e4r\", \"1q2w3e4r5t\",\n\"1q2w3e4r5t6y\", \"1qaz2wsx\", \"1qazxsw2\", \"22222222\", \"321654987\", \"4815162342\",\n\"55555555\", \"741852963\", \"76543210\", \"77777777\", \"789456123\", \"87654321\",\n\"88888888\", \"963852741\", \"987654321\", \"9876543210\", \"999999999\", \"a1234567\",\n\"a123456789\", \"a1b2c3d4\", \"a1b2c3d4e5\", \"a1s2d3f4\", \"Aa123456\", \"aaaaaaaa\",\n\"aaaaaaaaaa\", \"abc12345\", \"abcd1234\", \"abcdefgh\", \"adgjmptw\", \"alexander\",\n\"Alexandra\", \"Amsterdam\", \"Anderson\", \"Angelina\", \"Apollo13\", \"asdasdasd\",\n\"asdf1234\", \"asdfasdf\", \"asdfghjk\", \"asdfghjkl\", \"Assassin\", \"Atlantis\",\n\"Australia\", \"azertyuiop\", \"Babygirl\", \"Barcelona\", \"Baseball\", \"Basketball\",\n\"Benjamin\", \"BigDaddy\", \"BlaBlaBla\", \"BlahBlah\", \"Blink182\", \"Blizzard\",\n\"Brooklyn\", \"Bullshit\", \"Butterfly\", \"California\", \"CallofDuty\", \"Carolina\",\n\"Caroline\", \"Carpediem\", \"Catherine\", \"Champion\", \"Changeme\", \"Charlie1\",\n\"Charlotte\", \"Cheyenne\", \"Chocolate\", \"Christian\", \"Christina\", \"Christine\",\n\"Christopher\", \"Cocacola\", \"Colorado\", \"Computer\", \"Corvette\", \"Courtney\",\n\"Creative\", \"Danielle\", \"Darkness\", \"December\", \"Dolphins\", \"DragonBall\",\n\"drowssap\", \"Einstein\", \"Elephant\", \"Elizabeth\", \"Evolution\", \"Facebook\",\n\"Fernando\", \"Fireball\", \"Firebird\", \"Football\", \"Football1\", \"free-tau\", \"Franklin\",\n\"FuckYou2\", \"Gangster\", \"Garfield\", \"Giovanni\", \"Godzilla\", \"Goldfish\",\n\"GoodLuck\", \"GreenDay\", \"Hallo123\", \"Hardcore\", \"Harrison\", \"HarryPotter\",\n\"Hello123\", \"HelloKitty\", \"helloworld123\", \"Hercules\", \"IceCream\", \"idontknow\", \"iloveyou\",\n\"Infinity\", \"Internet\", \"Inuyasha\", \"Isabella\", \"Isabelle\", \"JamesBond\",\n\"Jennifer\", \"Jonathan\", \"Jordan23\", \"justdoit\", \"Juventus\", \"Kamikaze\",\n\"Kawasaki\", \"Kimberly\", \"KingKong\", \"Kristina\", \"LasVegas\", \"Leonardo\",\n\"LinkinPark\", \"Liverpool\", \"Logitech\", \"Lollipop\", \"LoveLove\", \"Manchester\",\n\"Marlboro\", \"Marshall\", \"Maverick\", \"Mercedes\", \"Metallica\", \"Michael1\",\n\"Michelle\", \"Microsoft\", \"Midnight\", \"Mitchell\", \"MoonLight\", \"MotherFucker\",\n\"Motorola\", \"Napoleon\", \"NewCastle\", \"Nicholas\", \"Nightmare\", \"Nintendo\",\n\"November\", \"Pa55w0rd\", \"Pa55word\", \"Pakistan\", \"Panasonic\", \"Paradise\",\n\"Passport\", \"Passw0rd\", \"Password1\", \"Password123\", \"Passwort\", \"Patricia\",\n\"Pavilion\", \"PeterPan\", \"Pineapple\", \"Platinum\", \"Playstation\", \"PoohBear\",\n\"Portugal\", \"Precious\", \"Predator\", \"Princess\", \"P@ssw0rd\", \"q1w2e3r4\",\n\"q1w2e3r4t5\", \"qazwsx123\", \"qazwsxedc\", \"qweasdzxc\", \"qwer1234\", \"qwerasdf\",\n\"qwert123\", \"qwerty12\", \"qwerty123\", \"qwertyui\", \"qwertyuiop\", \"Rammstein\",\n\"RealMadrid\", \"Remember\", \"Rockstar\", \"Ronaldo7\", \"RunEscape\", \"Rush2112\",\n\"Samantha\", \"Savannah\", \"Scarface\", \"Scorpion\", \"Scotland\", \"Sebastian\",\n\"Security\", \"September\", \"Serenity\", \"Simpsons\", \"Skateboard\", \"Skittles\",\n\"Skywalker\", \"Slipknot\", \"smartbro\", \"Snickers\", \"Snowball\", \"Snowboard\", \"Something\",\n\"Southpark\", \"Spiderman\", \"Spitfire\", \"SpongeBob\", \"Starcraft\", \"Stargate\",\n\"StarTrek\", \"StarWars\", \"Steelers\", \"Stephanie\", \"Strawberry\", \"Sunflower\",\n\"Sunshine\", \"Superman\", \"Superstar\", \"Swordfish\", \"TaxiLinQ\",  \"Terminator\",\n\"TestTest\", \"Tinkerbell\", \"TrustNo1\", \"Twilight\", \"Undertaker\", \"Valentina\",\n\"Valentine\", \"Veronica\", \"Victoria\", \"Warcraft\", \"Warhammer\", \"Welcome1\",\n\"Westside\", \"WhatEver\", \"Williams\", \"Wolverine\", \"Wordpass\", \"zaq12wsx\",\n\"zaq1xsw2\"\n};\n\nfor(w = 0; w < (sizeof(weakword) /sizeof(weakword[0])); w++)\n\twritepsk(fhout, weakword[w]);\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"abcd%04d\", y);\n\twritepsk(fhout, pskstring);\n\t}\n\nfor(y = 0; y < 1000; y++)\n\t{\n\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%03d%03d%03d\", y, y, y);\n\twritepsk(fhout, pskstring);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywritesimple(FILE *fhout)\n{\nstatic int a,b,c;\n\nfor(a =0x20; a < 0x7f; a++)\n for(b = 0x20; b < 0x7f; b++)\n\t{\n\tfprintf(fhout, \"12341234%c%c\\n\", a, b);\n\tfprintf(fhout, \"%c%c12341234\\n\", a, b);\n\tfprintf(fhout, \"1234512345%c%c\\n\", a, b);\n\tfprintf(fhout, \"%c%c1234512345\\n\", a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", a, a, b, b, a, a, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", a, a, b, b, a, a, b, b, a, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c%c\\n\", a, a, b, b, a, a, b, b, a, a, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", a, b, a, b, a, b, a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", a, b, a, b, a, b, a, b, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", a, b, a, b, a, b, a, b, a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c\\n\", a, b, a, b, a, b, a, b, a, b, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c%c\\n\", a, b, a, b, a, b, a, b, a, b, a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", a, b, b, b, b, b, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", a, b, b, b, b, b, b, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", a, b, b, b, b, b, b, b, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c\\n\", a, b, b, b, b, b, b, b, b, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c%c\\n\", a, b, b, b, b, b, b, b, b, b, b, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", b, b, b, b, b, b, b, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", b, b, b, b, b, b, b, b, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", b, b, b, b, b, b, b, b, b, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c\\n\", b, b, b, b, b, b, b, b, b, b, a);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c%c%c\\n\", b, b, b, b, b, b, b, b, b, b, b, a);\n\t}\nfor(a =0x20; a < 0x7f; a++)\n for(b =0x20; b < 0x7f; b++)\n  for(c =0x20; c < 0x7f; c++)\n\t{\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", a, b, c, a, b, c, a, b, c);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", a, a, a, b, b, b, c, c, c);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", a, c, c, c, c, c, c, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", a, c, c, c, c, c, c, c, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", a, c, c, c, c, c, c, c, c, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", a, b, c, c, c, c, c, c);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", a, b, c, c, c, c, c, c, c);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", a, b, c, c, c, c, c, c, c, c);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c\\n\", c, c, c, c, c, c, a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c\\n\", c, c, c, c, c, c, c, a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", c, c, c, c, c, c, c, c, a, b);\n\tfprintf(fhout, \"%c%c%c%c%c%c%c%c%c%c\\n\", a, b, b, b, b, c, c, c, c, a);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteeudate(FILE *fhout)\n{\nstatic unsigned int d, m, y;\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfor(d = 1; d <= 28; d++)\n\t\t{\n\t\tfor(m = 1; m <= 12; m++)\n\t\t\t{\n\t\t\tfprintf(fhout, \"%02d%02d%04d\\n\", d, m, y);\n\t\t\tfprintf(fhout, \"%02d.%02d.%04d\\n\", d, m, y);\n\t\t\t}\n\t\t}\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfor(d = 29; d <= 30; d++)\n\t\t{\n\t\tfor(m = 1; m <= 12; m++)\n\t\t\t{\n\t\t\tfprintf(fhout, \"%02d%02d%04d\\n\", d, m, y);\n\t\t\tfprintf(fhout, \"%02d.%02d.%04d\\n\", d, m, y);\n\t\t\t}\n\t\t}\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfprintf(fhout, \"3101%04d\\n\", y);\n\tfprintf(fhout, \"3103%04d\\n\", y);\n\tfprintf(fhout, \"3105%04d\\n\", y);\n\tfprintf(fhout, \"3107%04d\\n\", y);\n\tfprintf(fhout, \"3108%04d\\n\", y);\n\tfprintf(fhout, \"3110%04d\\n\", y);\n\tfprintf(fhout, \"3112%04d\\n\", y);\n\tfprintf(fhout, \"31.01.%04d\\n\", y);\n\tfprintf(fhout, \"31.03.%04d\\n\", y);\n\tfprintf(fhout, \"31.05.%04d\\n\", y);\n\tfprintf(fhout, \"31.07.%04d\\n\", y);\n\tfprintf(fhout, \"31.08.%04d\\n\", y);\n\tfprintf(fhout, \"31.10.%04d\\n\", y);\n\tfprintf(fhout, \"31.12.%04d\\n\", y);\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tif (((y %4 == 0) && (y %100 != 0)) || (y %400 == 0))\n\t\t{\n\t\tfprintf(fhout, \"2902%04d\\n\", y);\n\t\tfprintf(fhout, \"29.02.%04d\\n\", y);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteusdate(FILE *fhout)\n{\nstatic unsigned int d, m, y;\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfor(d = 1; d <= 28; d++)\n\t\t{\n\t\tfor(m = 1; m <= 12; m++)\n\t\t\t{\n\t\t\tfprintf(fhout, \"%02d%02d%04d\\n\", m, d, y);\n\t\t\tfprintf(fhout, \"%02d.%02d.%04d\\n\", m, d, y);\n\t\t\t}\n\t\t}\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfor(d = 29; d <= 30; d++)\n\t\t{\n\t\tfor(m = 1; m <= 12; m++)\n\t\t\t{\n\t\t\tfprintf(fhout, \"%02d%02d%04d\\n\", m, d, y);\n\t\t\tfprintf(fhout, \"%02d.%02d.%04d\\n\", m, d, y);\n\t\t\t}\n\t\t}\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfprintf(fhout, \"0131%04d\\n\", y);\n\tfprintf(fhout, \"0331%04d\\n\", y);\n\tfprintf(fhout, \"0531%04d\\n\", y);\n\tfprintf(fhout, \"0731%04d\\n\", y);\n\tfprintf(fhout, \"0831%04d\\n\", y);\n\tfprintf(fhout, \"1031%04d\\n\", y);\n\tfprintf(fhout, \"1231%04d\\n\", y);\n\tfprintf(fhout, \"01.31.%04d\\n\", y);\n\tfprintf(fhout, \"03.31.%04d\\n\", y);\n\tfprintf(fhout, \"05.31.%04d\\n\", y);\n\tfprintf(fhout, \"07.31.%04d\\n\", y);\n\tfprintf(fhout, \"08.31.%04d\\n\", y);\n\tfprintf(fhout, \"10.31.%04d\\n\", y);\n\tfprintf(fhout, \"12.31.%04d\\n\", y);\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tif (((y %4 == 0) && (y %100 != 0)) || (y %400 == 0))\n\t\t{\n\t\tfprintf(fhout, \"0229%04d\\n\", y);\n\t\tfprintf(fhout, \"02.29.%04d\\n\", y);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteyearyear(FILE *fhout)\n{\nstatic unsigned int y, y2, y3;\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfor(y2 = 1900; y2 <= thisyear; y2++)\n\t\t{\n\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%04d%04d\", y, y2);\n\t\twritepsk(fhout, pskstring);\n\t\t}\n\t}\n\nfor(y = 1900; y <= thisyear; y++)\n\t{\n\tfor(y2 = 1900; y2 <= thisyear; y2++)\n\t\t{\n\t\tfor(y3 = 1900; y3 <= thisyear; y3++)\n\t\t\t{\n\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%04d%04d%04d\", y, y2, y3);\n\t\t\twritepsk(fhout, pskstring);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void keywriteegn(FILE *fhout)\n{\nstatic unsigned int y, m, d, mc, i, j, c;\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\nstatic unsigned int w[] = {2, 4, 8, 5, 10, 9, 7, 3, 6};\n\nfor(y = 1950; y <= thisyear; y++)\n\t{\n\tif (y < 2000) mc = 0; else mc = 40;\n\tfor(m = 1; m <= 12; m++)\n\t\t{\n\t\tfor(d = 1; d <= 31; d++)\n\t\t\t{\n\t\t\tif (m == 2)\n\t\t\t\t{\n\t\t\t\tif ((((y % 4 == 0) && (y % 100 != 0)) || (y % 400 == 0)))\n\t\t\t\t\t{\n\t\t\t\t\tif (d > 29) continue;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\tif (d > 28) continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif ((m == 4 || m == 6 || m == 9 || m == 11) && d > 30) continue;\n\t\t\tfor (i = 0; i < 1000; i++)\n\t\t\t\t{\n\t\t\t\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%02d%02d%02d%03d\", y % 100, m + mc, d, i);\n\t\t\t\tc = 0;\n\t\t\t\tfor (j = 0; j < 9; j++)\n\t\t\t\t\t{\n\t\t\t\t\tc += (pskstring[j] - 48) * w[j];\n\t\t\t\t\t}\n\t\t\t\tc %= 11;\n\t\t\t\tif (c == 10) c = 0;\n\t\t\t\tpskstring[9] = c + 48;\n\t\t\t\tpskstring[10] = 0;\n\t\t\t\twritepsk(fhout, pskstring);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void preparebssidessid(FILE *fhout, unsigned long long int macaddr, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k2;\nstatic int ek;\nstatic char *ev;\nstatic unsigned int oui;\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen >= 6)\n\t{\n\tif((isxdigit((unsigned char)essid[essidlen -6])) && (isxdigit((unsigned char)essid[essidlen -5])) && (isxdigit((unsigned char)essid[essidlen -4])) && (isxdigit((unsigned char)essid[essidlen -3])) && (isxdigit((unsigned char)essid[essidlen -2])) && (isxdigit((unsigned char)essid[essidlen -1])))\n\t\t{\n\t\tev = (char*)(essid +essidlen -6);\n\t\tek = strtol(ev, NULL, 16);\n\t\toui = (macaddr &0xffffff000000L) >> 24;\n\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%06x%06x\", oui, ek);\n\t\twritepsk(fhout, essidtmp);\n\t\t}\n\t}\nreturn;\nif(essidlen >= 4)\n\t{\n\tif((isxdigit((unsigned char)essid[essidlen -4])) && (isxdigit((unsigned char)essid[essidlen -3])) && (isxdigit((unsigned char)essid[essidlen -2])) && (isxdigit((unsigned char)essid[essidlen -1])))\n\t\t{\n\t\tev = (char*)(essid +7);\n\t\tek = strtol(ev, NULL, 16);\n\t\tfor(k2 = ek -10;  k2 < ek +10; k2++)\n\t\t\t{\n\t\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%08llx%04x\", (macaddr >> 16), (k2 &0xffff));\n\t\t\twritepsk(fhout, essidtmp);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processbssidsessids(FILE *fhout)\n{\nstatic int c;\nstatic apessidl_t *zeiger;\nstatic apessidl_t *zeiger1;\n\nqsort(apessidliste, apessidcount, APESSIDLIST_SIZE, sort_apessidlist_by_ap);\nzeiger = apessidliste;\nfor(c = 0; c < apessidcount; c++)\n\t{\n\tif(c == 0) preparebssidessid(fhout, zeiger->macaddr, zeiger->essidlen, zeiger->essid);\n\telse\n\t\t{\n\t\tzeiger1 = zeiger -1;\n\t\tif((zeiger->macaddr != zeiger1->macaddr) || (zeiger->essidlen != zeiger1->essidlen) || (memcmp(zeiger->essid, zeiger1->essid, zeiger->essidlen) != 0))\n\t\t\t{\n\t\t\tpreparebssidessid(fhout, zeiger->macaddr, zeiger->essidlen, zeiger->essid);\n\t\t\t}\n\t\t}\n\tzeiger++;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writeessidadd(FILE *fhout, char *essid)\n{\nstatic unsigned int c, d;\nstatic char essidstring[PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX] = { 0 };\n\nfor(c = 22222; c <= 99999; c += 11111)\n\t{\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d\", essid, c);\n\twritepsk(fhout, essidstring);\n\t}\n\nif(essidglen <= 2)\n\t{\n\tfor(c = thisyear +1; c < 1000000; c++)\n\t\t{\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d\", essid, c);\n\t\twritepsk(fhout, essidstring);\n\t\t}\n\t}\n\nif(essidglen <= 3)\n\t{\n\tfor(c = thisyear +1; c < 100000; c++)\n\t\t{\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d\", essid, c);\n\t\twritepsk(fhout, essidstring);\n\t\t}\n\t}\n\nif(essidglen <= 12)\n\t{\n\tfor(c = thisyear +1; c < 10000; c++)\n\t\t{\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d\", essid, c);\n\t\twritepsk(fhout, essidstring);\n\t\t}\n\t}\n\nif(essidglen > 12)\n\t{\n\tfor(c = 2222; c <= 9999; c += 1111)\n\t\t{\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d\", essid, c);\n\t\twritepsk(fhout, essidstring);\n\t\t}\n\t}\n\nfor(c = 0; c <= thisyear; c++)\n\t{\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%04d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%04d!\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%04d%s\", c, essid);\n\twritepsk(fhout, essidstring);\n\t}\n\nfor(c = 100; c < 1000; c++)\n\t{\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%05d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%04d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d!\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%d%s\", c, essid);\n\twritepsk(fhout, essidstring);\n\t}\n\nfor(c = 10; c < 100; c++)\n\t{\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%04d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%03d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%d!\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%d%s\", c, essid);\n\twritepsk(fhout, essidstring);\n\t}\n\nfor(c = 0; c < 10; c++)\n\t{\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%04d\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%03d\", essid, c);\n\twritepsk(fhout, essidstring);\n\t}\n\nfor(c = 0; c <= 99; c++)\n\t{\n\tfor(d = 0; d <= 99; d++)\n\t\t{\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%02d%s%02d\", c, essid, d);\n\t\twritepsk(fhout, essidstring);\n\t\t}\n\t}\n\nfor(c = 0x21; c < 0x7f; c++)\n\t{\n\tfor(d = 0x21; d < 0x7f; d++)\n\t\t{\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%c%c%s%c%c\", c, d, essid, d, c);\n\t\twritepsk(fhout, essidstring);\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%c%c\", essid, c, d);\n\t\twritepsk(fhout, essidstring);\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%c%c%s\", c, d, essid);\n\t\twritepsk(fhout, essidstring);\n\t\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%c%s%c\", c, essid, d);\n\t\twritepsk(fhout, essidstring);\n\t\t}\n\t}\n\nfor(c = 0x21; c < 0x7f; c++)\n\t{\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%c\", essid, c);\n\twritepsk(fhout, essidstring);\n\tsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%c%s\", c, essid);\n\twritepsk(fhout, essidstring);\n\t}\n\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s1234567890\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s123456789\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s12345678\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s1234567\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s123456\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s12345\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s9876543210\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s987654321\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s87654321\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s7654321\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s654321\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s54321\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s4711\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"1234567890%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"123456789%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"12345678%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"1234567%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"123456%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"12345%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"9876543210%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"987654321%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"87654321%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"7654321%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"654321%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"54321%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s@adsl\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s@Home\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s@WiFi\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s@1234\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%sWiFi\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s@dsl\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s@123\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX, \"%s%s%s\", essid, essid, essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s%s\", essid, essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"%s\", essid);\nwritepsk(fhout, essidstring);\n\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"Family%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"Familie%s\", essid);\nwritepsk(fhout, essidstring);\nsnprintf(essidstring, PSKSTRING_LEN_MAX +PSKSTRING_LEN_MAX , \"Familia%s\", essid);\nwritepsk(fhout, essidstring);\nreturn;\n}\n/*===========================================================================*/\nstatic bool writeessidremoved(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int pi;\nstatic int po;\nstatic int essidlentmp;\nstatic bool removeflag;\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\npo = 0;\nremoveflag = false;\nessidlentmp = essidlen;\nmemset(&essidtmp, 0, PSKSTRING_LEN_MAX);\nfor(pi = 0; pi < essidlen; pi++)\n\t{\n\tif(((essid[pi] >= 'A') && (essid[pi] <= 'Z')) || ((essid[pi] >= 'a') && (essid[pi] <= 'z')))\n\t\t{\n\t\tessidtmp[po] = essid[pi];\n\t\tpo++;\n\t\t}\n\telse\n\t\t{\n\t\tessidlentmp--;\n\t\tremoveflag = true;\n\t\t}\n\t}\nwriteessidadd(fhout, (char*)essid);\nif(removeflag == true) writeessidadd(fhout, essidtmp);\nreturn removeflag;\n}\n/*===========================================================================*/\nstatic void writeessidsweeped(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int l1, l2;\nstatic uint8_t sweepstring[PSKSTRING_LEN_MAX] = { 0 };\n\nfor(l1 = 2; l1 <= essidlen; l1++)\n\t{\n\tfor(l2 = 0; l2 <= essidlen -l1; l2++)\n\t\t{\n\t\tmemset(&sweepstring, 0, PSKSTRING_LEN_MAX);\n\t\tmemcpy(&sweepstring, &essid[l2], l1);\n\t\twriteessidremoved(fhout, l1, sweepstring);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testairtel(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *air = \"Airtel_\";\n\nif(airtelflag == true) return;\nif(essidlen < 7) return;\nif(memcmp(essid, air, 7) != 0) return;\nfprintf(fhout, \"Airtel@123\\n\");\nfor(k = 0; k < 100000; k++) fprintf(fhout, \"air%05d\\n\", k);\nairtelflag = true;\nreturn;\n}\n/*===========================================================================*/\nstatic void testalcatellinkzone(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *ali = \"Alcatel LINKZONE \";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen != 21) return;\nif(memcmp(essid, ali, 17) != 0) return;\nif((!isdigit((unsigned char)essid[17])) || (!isdigit((unsigned char)essid[18])) || (!isdigit((unsigned char)essid[19])) || (!isdigit((unsigned char)essid[20]))) return;\nfor(k1 = 0; k1 < 10000; k1++)\n\t{\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%04d%c%c%c%c\", k1, essid[17], essid[18], essid[19], essid[20]);\n\twritepsk(fhout, essidtmp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testarrisizzi(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int c;\nstatic uint32_t i;\nstatic const char *izzi = \"IZZI-\";\n\nstatic int fixseed2[] =\n{\n0x001C15, 0x189C27, 0x3C0461, 0x509551, 0x704FB8, 0x8871B1, 0x8C61A3, 0x9CC8FC,\n0xA811FC, 0xD4AB82, 0xF0AF85, 0xF82DC0, 0xF88B37, 0xF8F532, 0xFCAE34\n};\n#define FIXSEED2_SIZE sizeof(fixseed2) /sizeof(int)\n\nif(essidlen < 9) return;\nif(memcmp(essid, izzi, 5) != 0) return;\nif((!isxdigit((unsigned char)essid[5])) || (!isxdigit((unsigned char)essid[6])) || (!isxdigit((unsigned char)essid[7])) || (!isxdigit((unsigned char)essid[8]))) return;\nfor(i = 0; i < FIXSEED2_SIZE; i++)\n\t{\n\tfor(c = 0; c < 0x100; c++) fprintf(fhout, \"%06X%02X%lc%lc%lc%lc\\n\", fixseed2[i], c, essid[5], essid[6], essid[7], essid[8]);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testarristg(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *dg860A = \"DG860A\";\nstatic const char *tg852g = \"TG852G\";\nstatic const char *tg862g = \"TG862G\";\nstatic const char *dg1670A = \"DG1670A\";\nstatic const char *sbg6580 = \"SBG6580\";\nstatic const char *tg1672g = \"TG1672G\";\n\nif(essidlen >= 8)\n\t{\n\tif((!isxdigit((unsigned char)essid[6])) || (!isxdigit((unsigned char)essid[7]))) return;\n\tif(memcmp(essid, dg860A, 6) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"DG860A%04X%c%c\\n\", k1, essid[6], essid[7]);\n\t\treturn;\n\t\t}\n\tif(memcmp(essid, tg852g, 6) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"TG852G%04X%c%c\\n\", k1, essid[6], essid[7]);\n\t\treturn;\n\t\t}\n\tif(memcmp(essid, tg862g, 6) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"TG862G%04X%c%c\\n\", k1, essid[6], essid[7]);\n\t\treturn;\n\t\t}\n\t}\nif(essidlen >= 9)\n\t{\n\tif((!isxdigit((unsigned char)essid[7])) || (!isxdigit((unsigned char)essid[8]))) return;\n\tif(memcmp(essid, dg1670A, 7) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"DG1670A%04X%c%c\\n\", k1, essid[7], essid[8]);\n\t\treturn;\n\t\t}\n\tif(memcmp(essid, sbg6580, 7) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"SBG6580%04X%c%c\\n\", k1, essid[7], essid[8]);\n\t\treturn;\n\t\t}\n\tif(memcmp(essid, tg1672g, 7) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"TG1672G%04X%c%c\\n\", k1, essid[7], essid[8]);\n\t\treturn;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testaxtelxtremo(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *axtelxtremo = \"AXTEL XTREMO-\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen != 17) return;\nif(memcmp(essid, axtelxtremo, 13) != 0) return;\nif((!isxdigit((unsigned char)essid[13])) || (!isxdigit((unsigned char)essid[14])) || (!isxdigit((unsigned char)essid[15])) || (!isxdigit((unsigned char)essid[16]))) return;\nfor(k1 = 0; k1 < 10000; k1++)\n\t{\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%04d%c%c%c%c\", k1, essid[13], essid[14], essid[15], essid[16]);\n\twritepsk(fhout, essidtmp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testattwifi(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1, k2, k3, k4;\nstatic const char *attwifi = \"ATT-WIFI-\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen != 13) return;\nif(memcmp(essid, attwifi, 9) != 0) return;\nif((!isdigit((unsigned char)essid[9])) || (!isdigit((unsigned char)essid[10])) || (!isdigit((unsigned char)essid[11])) || (!isdigit((unsigned char)essid[12]))) return;\nfor(k1 = 0; k1 < 10; k1++)\n\tfor(k2 = 0; k2 < 10; k2++)\n\t\tfor(k3 = 0; k3 < 10; k3++)\n\t\t\tfor(k4 = 0; k4 < 10; k4++)\n\t\t\t\t{\n\t\t\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%d%c%d%c%d%c%d%c\", k1, essid[9], k2, essid[10], k3, essid[12], k4, essid[11]);\n\t\t\t\twritepsk(fhout, essidtmp);\n\t\t\t\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testcabovisao(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *cabovisao = \"Cabovisao-\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen != 14) return;\nif(memcmp(essid, cabovisao, 10) != 0) return;\nif((!isxdigit((unsigned char)essid[10])) || (!isxdigit((unsigned char)essid[11])) || (!isxdigit((unsigned char)essid[12])) || (!isxdigit((unsigned char)essid[13]))) return;\nfor(k1 = 0; k1 < 0x100; k1++)\n\t{\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"2ce412%02x%c%c%c%c\", k1, essid[10], essid[11], essid[12], essid[13]);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"e0ca94%02x%c%c%c%c\", k1, essid[10], essid[11], essid[12], essid[13]);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"e0cec3%02x%c%c%c%c\", k1, essid[10], essid[11], essid[12], essid[13]);\n\twritepsk(fhout, essidtmp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testcg3000dv2(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *cg3000dv2 = \"CG3000DV2\";\n\nif(essidlen < 11) return;\nif(memcmp(essid, cg3000dv2, 9) != 0) return;\nif((!isxdigit((unsigned char)essid[9])) || (!isxdigit((unsigned char)essid[10]))) return;\nfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"CG3000DV2%04X%c%c\\n\", k1, essid[9], essid[10]);\nreturn;\n}\n/*===========================================================================*/\nstatic void testcpsrf(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *cpcrf1 = \"CoolpadSurf_\";\nstatic const char *cpcrf2 = \"Coolpad Surf \";\n\nif(essidlen < 16) return;\nif(memcmp(essid, cpcrf1, 12) == 0)\n\t{\n\tif((!isdigit((unsigned char)essid[12])) || (!isdigit((unsigned char)essid[13])) || (!isdigit((unsigned char)essid[14])) || (!isdigit((unsigned char)essid[15]))) return;\n\tfor(k1 = 0; k1 < 10000; k1++) fprintf(fhout, \"%04d%.*s\\n\", k1, 4, &essid[12]);\n\treturn;\n\t}\nif(essidlen < 17) return;\nif(memcmp(essid, cpcrf2, 13) == 0)\n\t{\n\tif((!isdigit((unsigned char)essid[13])) || (!isdigit((unsigned char)essid[14])) || (!isdigit((unsigned char)essid[15])) || (!isdigit((unsigned char)essid[16]))) return;\n\tfor(k1 = 0; k1 < 10000; k1++) fprintf(fhout, \"%04d%.*s\\n\", k1, 4, &essid[13]);\n\treturn;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testeasybox(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int b;\nstatic int s10, s9, s8 , s7;\nstatic int m12, m11, m10 ,m9;\nstatic int f1, f2;\nstatic int k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\nstatic const char *easybox = \"EasyBox-\";\n\nif(easyboxflag == true) return;\nif(essidlen != 14) return;\nif(memcmp(essid, easybox, 8) != 0) return;\nif((!isxdigit((unsigned char)essid[8])) || (!isxdigit((unsigned char)essid[9])) || (!isxdigit((unsigned char)essid[10])) || (!isxdigit((unsigned char)essid[11])) || (!isdigit((unsigned char)essid[12])) || (!isdigit((unsigned char)essid[13]))) return;\nfor (b = 0; b <= 0xffff; b++)\n\t{\n\tm12 =  b &0x000f;\n\tm11 = (b &0x00f0) >> 4;\n\tm10 = (b &0x0f00) >> 8;\n\tm9 =  (b &0xf000) >> 12;\n\ts10 = b %10;\n\ts9 = (b /10) %10;\n\ts8 = (b /100) %10;\n\ts7 = (b /1000) %10;\n\tf1 = (s7 +s8 +m11 +m12) & 0xf;\n\tf2 = (m9 +m10 +s9 +s10) & 0xf;\n\tk1 = f1 ^s10;\n\tk2 = f2 ^m10;\n\tk3 = m11 ^s10;\n\tk4 = f1 ^s9;\n\tk5 = f2 ^m11;\n\tk6 = m12 ^s9;\n\tk7 = f1 ^s8;\n\tk8 = f2 ^m12;\n\tk9 = f1 ^f2;\n\tfprintf (fhout, \"%X%X%X%X%X%X%X%X%X\\n\", k1, k2, k3, k4, k5, k6, k7, k8, k9);\n\t}\neasyboxflag = true;\nreturn;\n}\n/*===========================================================================*/\nstatic void testglocal(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1, k2, k3, k4;\nstatic const char *glocalme = \"GlocalMe_\";\n\nif(essidlen != 14) return;\nif(memcmp(essid, glocalme , 9) != 0) return;\nif((!isdigit((unsigned char)essid[9])) || (!isdigit((unsigned char)essid[10])) || (!isdigit((unsigned char)essid[11])) || (!isdigit((unsigned char)essid[12])) || (!isdigit((unsigned char)essid[13]))) return;\nk2 = essid[11];\nk3 = essid[12];\nfor(k1 = 0; k1 < 100000; k1++)\n\t{\n\tfor(k4 = 0; k4 < 10; k4++) fprintf(fhout, \"%05d%c%c%d\\n\", k1, k2, k3, k4);\n\t}\n\nreturn;\n}\n/*===========================================================================*/\nstatic void testhotbox(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1, k2;\nstatic char *ev;\nstatic const char *hotbox = \"HOTBOX\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen < 7) return;\nif(memcmp(essid, hotbox , 6) != 0) return;\nif(hb5flag == false)\n\t{\n\tfor(k1 = 500000000; k1 < 560000000; k1++) fprintf(fhout, \"%010d\\n\", k1);\n\tfor(k1 = 770000000; k1 < 780000000; k1++) fprintf(fhout, \"%010d\\n\", k1);\n\t}\nhb5flag = true;\nif(essidlen != 11) return;\nif(essid[6] != '-') return;\nif((!isxdigit((unsigned char)essid[7])) || (!isxdigit((unsigned char)essid[8])) || (!isxdigit((unsigned char)essid[9])) || (!isxdigit((unsigned char)essid[10]))) return;\nev = (char*)(essid +7);\nk2 = strtol(ev, NULL, 16);\nfor(k1 = 0; k1 < 0x100; k1++)\n\t{\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"086a0a%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"2ce412%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"4c17eb%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"6c2e85%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"700b01%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"7c034c%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"7cb733%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"a0648f%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"b4eeb4%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"c0ac54%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"d86ce9%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"d8fb5e%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"e0cec3%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"e8d11b%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"fcb4e6%02x%04x\", k1, k2);\n\twritepsk(fhout, essidtmp);\n\t}\nfor(k1 = 500000000; k1 < 560000000; k1++) fprintf(fhout, \"%010d\\n\", k1);\nreturn;\n}\n/*===========================================================================*/\nstatic void testmtel(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1, k2;\nstatic const char *a1 = \"A1_\";\nstatic const char *mtel = \"M-Tel_\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen == 7)\n\t{\n\tif(memcmp(essid, a1, 3) == 0)\n\t\t{\n\t\tif((isxdigit((unsigned char)essid[3])) && (isxdigit((unsigned char)essid[4])) && (isxdigit((unsigned char)essid[5])) && (isxdigit((unsigned char)essid[6])))\n\t\t\t{\n\t\t\tfor(k1 = 0; k1 < 0x100; k1++)\n\t\t\t\tfor(k2 = 0; k2 < 0x100; k2++)\n\t\t\t\t\t{\n\t\t\t\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"48575443%02X%c%c%c%c%02X\", k1, essid[3], essid[4], essid[5], essid[6], k2);\n\t\t\t\t\twritepsk(fhout, essidtmp);\n\t\t\t\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"48575443%02X%02X%c%c%c%c\", k1, k2, essid[3], essid[4], essid[5], essid[6]);\n\t\t\t\t\twritepsk(fhout, essidtmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn;\n\t}\nif(essidlen == 10)\n\t{\n\tif(memcmp(essid, mtel, 6) == 0)\n\t\t{\n\t\tif((isxdigit((unsigned char)essid[6])) && (isxdigit((unsigned char)essid[7])) && (isxdigit((unsigned char)essid[8])) && (isxdigit((unsigned char)essid[9])))\n\t\t\t{\n\t\t\tfor(k1 = 0; k1 < 0x100; k1++)\n\t\t\t\t{\n\t\t\t\tfor(k2 = 0; k2 < 0x100; k2++)\n\t\t\t\t\t{\n\t\t\t\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"48575443%02X%c%c%c%c%02X\", k1, essid[6], essid[7], essid[8], essid[9], k2);\n\t\t\t\t\twritepsk(fhout, essidtmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testmywifi(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *mywifi = \"MY WIFI \";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen != 12) return;\nif(memcmp(essid, mywifi, 8) != 0) return;\nfor(k1 = 0; k1 < 10000; k1++)\n\t{\n\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"MYWIFI%04d\", k1);\n\twritepsk(fhout, essidtmp);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testnet2g(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *net2g = \"NET_2G\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen < 12) return;\nif(memcmp(essid, net2g, 6) != 0) return;\nif((isxdigit((unsigned char)essid[6])) && (isxdigit((unsigned char)essid[7])) && (isxdigit((unsigned char)essid[8])) && (isxdigit((unsigned char)essid[9])) && (isxdigit((unsigned char)essid[10])) && (isxdigit((unsigned char)essid[11])))\n\t{\n\tfor(k = 0; k < 0x100; k++)\n\t\t{\n\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%02X%lc%lc%lc%lc%lc%lc\", k, essid[6], essid[7], essid[8], essid[9], essid[10], essid[11]);\n\t\twritepsk(fhout, essidtmp);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testnetv(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *net2g = \"Net-Virtua\";\n\nif(essidlen < 15) return;\nif(memcmp(essid, net2g, 10) != 0) return;\nif((isdigit((unsigned char)essid[11])) && (isdigit((unsigned char)essid[12])) && (isdigit((unsigned char)essid[13])) && (isdigit((unsigned char)essid[14])))\n\t{\n    for(k = 0; k < 1000; k++)\n\t    {\n\t    fprintf(fhout,   \"%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"15%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"16%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"24%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"31%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"33%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"37%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"38%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"40%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"61%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    fprintf(fhout, \"71%03d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    }\n    for(k = 0; k < 10000; k++)\n\t    {\n\t    fprintf(fhout, \"%04d%lc%lc%lc%lc0\\n\", k, essid[11], essid[12], essid[13], essid[14]);\n\t    }\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testpoda(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *poda = \"PODA_\";\n\nif(podaflag == true) return;\nif(essidlen < 5) return;\nif(memcmp(essid, poda, 5) != 0) return;\nfor(k = 0; k < 1000000; k++) fprintf(fhout, \"%06d%06d\\n\", k, k);\npodaflag = true;\nreturn;\n}\n/*===========================================================================*/\nstatic void testroamingman(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1, k2, k3;\nstatic char *ev;\nstatic const char *roamingman =  \"Roamingman_\";\n\nif(essidlen != 16) return;\nif((!isdigit((unsigned char)essid[11])) || (!isdigit((unsigned char)essid[12])) || (!isdigit((unsigned char)essid[13])) || (!isdigit((unsigned char)essid[14])) || (!isdigit((unsigned char)essid[15]))) return;\nif(memcmp(essid, roamingman, 11) != 0) return;\nev = (char*)(essid +11);\nk2 = strtol(ev, NULL, 10);\nfor(k3 = k2 -10; k3 < k2 +10; k3++)\n\t{\n\tfor(k1 = 0; k1 < 1000; k1++)\n\t\t{\n\t\tif(k3 < 0) fprintf(fhout, \"%03d%05d\\n\", k1, k3 +100000);\n\t\telse if(k3 > 99999) fprintf(fhout, \"%03d%05d\\n\", k1, k3 -100000);\n\t\telse fprintf(fhout, \"%03d%05d\\n\", k1, k3);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testrtk(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *rtk = \"RTK-\";\n\nif(essidlen == 10)\n\t{\n\tif((isxdigit((unsigned char)essid[4])) && (isxdigit((unsigned char)essid[5])) && (isxdigit((unsigned char)essid[6])) && (isxdigit((unsigned char)essid[7])) && (isxdigit((unsigned char)essid[8])) && (isxdigit((unsigned char)essid[9])))\n\t\t{\n\t\tif(memcmp(essid, rtk, 4) == 0)\n\t\t\t{\n\t\t\tfor(k1 = 0; k1 < 0x100000; k1++)\n\t\t\t\t{\n\t\t\t\tfprintf(fhout, \"454C54585C0%05X\\n\", k1);\n\t\t\t\tfprintf(fhout, \"454C54585C1%05X\\n\", k1);\n\t\t\t\tfprintf(fhout, \"53434F4D1A0%05X\\n\", k1);\n\t\t\t\tfprintf(fhout, \"ELTX1A0%05X\\n\", k1);\n\t\t\t\tfprintf(fhout, \"ELTX5C0%05X\\n\", k1);\n\t\t\t\t}\n\t\t\t}\n\t\treturn;\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testtechnicolor(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *tc8715d = \"TC8715D\";\nstatic const char *tc8717t = \"TC8717T\";\n\nif(essidlen >= 9)\n\t{\n\tif((!isxdigit((unsigned char)essid[7])) || (!isxdigit((unsigned char)essid[8]))) return;\n\tif(memcmp(essid, tc8715d, 7) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"TC8715D%04X%c%c\\n\", k1, essid[7], essid[8]);\n\t\t}\n\tif(memcmp(essid, tc8717t, 7) == 0)\n\t\t{\n\t\tfor(k1 = 0; k1 < 0x10000; k1++) fprintf(fhout, \"TC8717T%04X%c%c\\n\", k1, essid[7], essid[8]);\n\t\t}\n\treturn;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testtelered(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic uint32_t i;\nstatic int c;\nstatic const char *telered = \"TeleRed-\";\n\nstatic uint32_t fix[] =\n{\n0x324b, 0x96e6, 0x9c67, 0xa266, 0xcfe2\n};\n#define FIX_SIZE sizeof(fix) /sizeof(int)\n\nif(essidlen < 12) return;\nif(memcmp(essid, telered, 8) != 0) return;\nif((!isxdigit((unsigned char)essid[8])) || (!isxdigit((unsigned char)essid[9])) || (!isxdigit((unsigned char)essid[10])) || (!isxdigit((unsigned char)essid[11]))) return;\n\nfor(i = 0; i < FIX_SIZE; i++)\n\t{\n\tfor(c = 0; c < 0x100; c++) fprintf(fhout, \"%04X%02X%lc%lc%lc%lc\\n\", fix[i], c, essid[8], essid[9], essid[10], essid[11]);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testukrtelecom(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *ukrtelekom = \"UKrtelecom\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(ukrtelecomflag == true) return;\nif(essidlen < 10) return;\nif(memcmp(essid, ukrtelekom, 10) != 0) return;\nfor(k = 0; k < 10000; k++)\n\t\t{\n\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"UKR_%04d\", k);\n\t\twritepsk(fhout, essidtmp);\n\t\t}\nukrtelecomflag = true;\nreturn;\n}\n/*===========================================================================*/\nstatic void testwe(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\n\nif(essidlen != 8) return;\nif(essid[0] != 'W') return;\nif(essid[1] != 'E') return;\nif(!isxdigit((unsigned char)essid[6])) return;\nif(!isxdigit((unsigned char)essid[7])) return;\nfor(k1 = 0; k1 < 0x100000; k1++) fprintf(fhout, \"%c%c0%05x\\n\", tolower(essid[6]), tolower(essid[7]), k1);\nreturn;\n}\n/*===========================================================================*/\nstatic void testwifirsu(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1;\nstatic const char *wifirsu = \"WiFiRSU_\";\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif(essidlen < 10) return;\nif(memcmp(essid, wifirsu, 8) != 0) return;\nif(essidlen == 10)\n\t{\n\tif((!isxdigit((unsigned char)essid[8])) || (!isxdigit((unsigned char)essid[9]))) return;\n\tfor(k1 = 0; k1 < 0x10000; k1++)\n\t\t{\n\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"88%04x%c%c\", k1, essid[8], essid[9]);\n\t\twritepsk(fhout, essidtmp);\n\t\t}\n\treturn;\n\t}\nif(essidlen == 13)\n\t{\n\tif((!isxdigit((unsigned char)essid[8])) || (!isxdigit((unsigned char)essid[9])) || (!isxdigit((unsigned char)essid[10])) || (!isxdigit((unsigned char)essid[11])) || (!isxdigit((unsigned char)essid[12]))) return;\n\tfor(k1 = 0; k1 < 0x10; k1++)\n\t\t{\n\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"88%x%c%c%c%c%c\", k1, essid[8], essid[9], essid[10], essid[11], essid[12]);\n\t\twritepsk(fhout, essidtmp);\n\t\t}\n\treturn;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testwlan(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k1, k2, k3, k4, k5, k6 ,k7 ,k8, k9;\nstatic const char *wifirsu = \"WLAN-\";\n\nstatic const char hextable[] = \"0123456789ABCDEF\";\n\nif(essidlen != 11) return;\nif(memcmp(essid, wifirsu, 5) != 0) return;\nif((!isxdigit((unsigned char)essid[5])) || (!isxdigit((unsigned char)essid[6])) || (!isxdigit((unsigned char)essid[7])) || (!isxdigit((unsigned char)essid[8])) || (!isdigit((unsigned char)essid[9])) || (!isdigit((unsigned char)essid[10]))) return;\nk1 = essid[9];\nk2 = 0;\nk3 = essid[10];\nk4 = essid[8];\nk5 = 0;\nk6 = 0;\nk7 = 0;\nk8 = essid[6];\nk9 = essid[7];\nfor(k2 = 0; k2 < 10; k2++)\n\t{\n\tfor(k5 = 0; k5 <= 0xffff; k5++)\n\t\t{\n\t\tfprintf(fhout, \"SP-%c%d%c%c%04X%d\\n\", k1, k2, k3, k4, k5, k2);\n\t\tfprintf(fhout, \"SP%c%d%c%c%04X%d\\n\", k1, k2, k3, k4, k5, k2);\n\t\t}\n\t}\nfor(k2 = 0; k2 < 10; k2++)\n\t{\n\tfor(k5 = 0; k5 <= 0x0f; k5++)\n\t\t{\n\t\tfor(k6 = 0; k6 <= 0x0f; k6++)\n\t\t\t{\n\t\t\tfor(k7 = 0; k7 < 100; k7++) fprintf(fhout, \"%c%d%c%02d%02d%02d%02d%d%02d%02d\\n\", k1, k2, k3, k4, hextable[k5], hextable[k6], k7, k2, k8, k9);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void testx2g(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *x2g = \"_2G\";\n\nif(essidlen < 9) return;\nif(memcmp(&essid[essidlen -9], x2g, 2) != 0) return;\nif((!isdigit((unsigned char)essid[essidlen -1])) || (!isdigit((unsigned char)essid[essidlen -2])) || (!isdigit((unsigned char)essid[essidlen -3])) || (!isdigit((unsigned char)essid[essidlen -4])) || (!isdigit((unsigned char)essid[essidlen -5])) || (!isdigit((unsigned char)essid[essidlen -6]))) return;\nfor(k = 0; k < 0x100; k++) fprintf(fhout, \"%02X%s\\n\", k, &essid[essidlen -6]);\nreturn;\n}\n/*===========================================================================*/\nstatic void testzhone(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int k;\nstatic const char *zhone = \"Zhone_\";\n\nif(znidflag == true) return;\nif(essidlen < 6) return;\nif(memcmp(essid, zhone, 6) != 0) return;\nfor(k = 0; k < 10000000; k++) fprintf(fhout, \"znid30%07d\\n\", k);\nfor(k = 0; k < 10000000; k++) fprintf(fhout, \"znid31%07d\\n\", k);\nznidflag = true;\nreturn;\n}\n/*===========================================================================*/\nstatic void prepareessid(FILE *fhout, uint8_t essidlen, uint8_t *essid)\n{\nstatic int pi, po;\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\nif((essidlen == 0) || (essidlen > 32)) return;\ntestairtel(fhout, essidlen, essid);\ntestalcatellinkzone(fhout, essidlen, essid);\ntestarrisizzi(fhout, essidlen, essid);\ntestarristg(fhout, essidlen, essid);\ntestattwifi(fhout, essidlen, essid);\ntestaxtelxtremo(fhout, essidlen, essid);\ntestcabovisao(fhout, essidlen, essid);\ntestcg3000dv2(fhout, essidlen, essid);\ntestcpsrf(fhout, essidlen, essid);\ntesteasybox(fhout, essidlen, essid);\ntestglocal(fhout, essidlen, essid);\ntesthotbox(fhout, essidlen, essid);\ntestmtel(fhout, essidlen, essid);\ntestmywifi(fhout, essidlen, essid);\ntestnet2g(fhout, essidlen, essid);\ntestnetv(fhout, essidlen, essid);\ntestpoda(fhout, essidlen, essid);\ntestroamingman(fhout, essidlen, essid);\ntestrtk(fhout, essidlen, essid);\ntesttechnicolor(fhout, essidlen, essid);\ntesttelered(fhout, essidlen, essid);\ntestukrtelecom(fhout, essidlen, essid);\ntestwe(fhout, essidlen, essid);\ntestwifirsu(fhout, essidlen, essid);\ntestwlan(fhout, essidlen, essid);\ntestx2g(fhout, essidlen, essid);\ntestzhone(fhout, essidlen, essid);\nif(noessidcombinationflag == true) return;\nwriteessidsweeped(fhout, essidlen, essid);\npo = 0;\nmemset(&essidtmp, 0, PSKSTRING_LEN_MAX);\nfor(pi = essidlen -1; pi >= 0; pi--)\n\t{\n\tessidtmp[po] = essid[pi];\n\tpo++;\n\t}\nwritepsk(fhout, essidtmp);\nreturn;\n}\n/*===========================================================================*/\nstatic void processessids(FILE *fhout)\n{\nstatic int c;\nstatic apessidl_t *zeiger;\n\nqsort(apessidliste, apessidcount, APESSIDLIST_SIZE, sort_apessidlist_by_essid);\nzeiger = apessidliste;\nif( apessidcount == 0) return;\nessidglen = zeiger->essidlen;\nprepareessid(fhout, zeiger->essidlen, zeiger->essid);\nfor(c = 1; c < apessidcount; c++)\n\t{\n\tif(zeiger->essidlen != (zeiger -1)->essidlen)\n\t\t{\n\t\tessidglen = zeiger->essidlen;\n\t\tprepareessid(fhout, zeiger->essidlen, zeiger->essid);\n\t\t}\n\telse if(memcmp(zeiger->essid, (zeiger -1)->essid, zeiger->essidlen) != 0)\n\t\t{\n\t\tessidglen = zeiger->essidlen;\n\t\tprepareessid(fhout, zeiger->essidlen, zeiger->essid);\n\t\t}\n\tzeiger++;\n\t}\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\nstatic void writebssidmd5(FILE *fhout, unsigned long long int macaddr)\n{\nstatic int k;\nstatic int p;\nstatic unsigned int digestmd5len;\nstatic EVP_MD_CTX* mdctx;\nstatic char message[PSKSTRING_LEN_MAX];\nstatic uint8_t digestmd5[EVP_MAX_MD_SIZE];\n\nstatic char keystring[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nsnprintf(message, 14, \"%012llX\", macaddr);\ndigestmd5len = 16;\nmdctx = EVP_MD_CTX_create();\nif(mdctx == NULL) return;\nif(EVP_DigestInit_ex(mdctx, EVP_md5(), NULL) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn;\n\t}\nif(EVP_DigestUpdate(mdctx, message, 12) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn;\n\t}\nif(EVP_DigestFinal_ex(mdctx, digestmd5, &digestmd5len) == 0)\n\t{\n\tEVP_MD_CTX_free(mdctx);\n\treturn;\n\t}\nEVP_MD_CTX_free(mdctx);\n\nfor (p = 0; p < 10; p++) fprintf(fhout, \"%02x\",digestmd5[p]);\nfprintf(fhout, \"\\n\");\nfor (p = 0; p < 8; p++)\n\t{\n\tk = (digestmd5[p] %26);\n\tfprintf(fhout, \"%c\",keystring[k]);\n\t}\nfprintf(fhout, \"\\n\");\n\nfor (p = 0; p < 10; p++)\n\t{\n\tk = (digestmd5[p] %26);\n\tfprintf(fhout, \"%c\",keystring[k]);\n\t}\nfprintf(fhout, \"\\n\");\n\nfor (p = 0; p < 15 ; p +=2)\n\t{\n\tk = (digestmd5[p] %26);\n\tfprintf(fhout, \"%c\",keystring[k]);\n\t}\nfprintf(fhout, \"\\n\");\n\nfor (p = 1; p < 16 ; p +=2)\n\t{\n\tk = (digestmd5[p] %26);\n\tfprintf(fhout, \"%c\",keystring[k]);\n\t}\nfprintf(fhout, \"\\n\");\nreturn;\n}\n/*===========================================================================*/\nstatic unsigned int wpspinchecksum(unsigned int pin)\n{\nstatic int accum = 0;\n\nwhile (pin)\n\t{\n\taccum += 3 * (pin % 10);\n\tpin /= 10;\n\taccum += pin % 10;\n\tpin /= 10;\n\t}\nreturn (10 - accum % 10) % 10;\n}\n/*---------------------------------------------------------------------------*/\nstatic void writebssidwps(FILE *fhout, unsigned long long int macaddr)\n{\nstatic int pin;\n\npin = (macaddr & 0xffffff) % 10000000;\npin = ((pin * 10) + wpspinchecksum(pin));\nfprintf(fhout, \"%08d\\n\", pin);\n\npin = (((macaddr >> 24) &0xff) *256 *256) +(((macaddr >> 16) &0xff) *256) + ((macaddr >> 8) &0xff);\npin = pin % 10000000;\npin = ((pin * 10) + wpspinchecksum(pin));\nfprintf(fhout, \"%08d\\n\", pin);\nreturn;\n}\n/*===========================================================================*/\nstatic void writewpsall(FILE *fhout)\n{\nstatic int c, cs;\n\nfor(c = 0; c < 10000000; c++)\n\t{\n\tcs = wpspinchecksum(c);\n\tfprintf(fhout, \"%07d%d\\n\", c, cs);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void writebssid(FILE *fhout, unsigned long long int macaddr)\n{\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"0%012llx\", macaddr);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"2%012llx\", macaddr);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"m%012llx\", macaddr);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"555A5053%08llX\", macaddr &0xffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"8747%06llx\", macaddr &0xffffff);\nwritepsk(fhout, pskstring);\n\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%012llx\", macaddr);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%011llx\", macaddr &0xfffffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%010llx\", macaddr &0xffffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%09llx\", macaddr &0xfffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%08llx\", macaddr &0xffffffff);\nwritepsk(fhout, pskstring);\n\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%011llx\", (macaddr >> 4) &0xfffffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%010llx\", (macaddr >> 8) &0xffffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%09llx\",(macaddr >> 12) &0xfffffffff);\nwritepsk(fhout, pskstring);\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%08llx\", (macaddr >> 16) &0xffffffff);\nwritepsk(fhout, pskstring);\n\nsnprintf(pskstring, PSKSTRING_LEN_MAX, \"%010lld\", (macaddr) &0xffffff);\nwritepsk(fhout, pskstring);\n\nwritebssidmd5(fhout, macaddr);\nwritebssidwps(fhout, macaddr);\nreturn;\n}\n/*===========================================================================*/\nstatic void test000559(FILE *fhout, unsigned long long int macaddr)\n{\nstatic int k1;\nstatic unsigned long long int oui;\n\nstatic char essidtmp[PSKSTRING_LEN_MAX] = { 0 };\n\noui = macaddr &0xffffff000000L;\noui = oui >> 24;\nif(oui == 0x000559)\n\t{\n\tfor(k1 = 0; k1 < 10000; k1++)\n\t\t{\n\t\tsnprintf(essidtmp, PSKSTRING_LEN_MAX, \"%012llX-%04d\", macaddr, k1);\n\t\twritepsk(fhout, essidtmp);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void preparebssid(FILE *fhout, unsigned long long int macaddr)\n{\nstatic int c;\nstatic unsigned long long int oui;\nstatic unsigned long long int nic;\nstatic unsigned int nici;\nstatic int swap;\nstatic int me;\nstatic char pskstring[PSKSTRING_LEN_MAX] = { 0 };\n\nfprintf(fhout, \"%012llX\\n\", macaddr &0xffffffffff);\n\nnici = macaddr &0xffffff;\nfprintf(fhout, \"SPN3983%06X\\n\", nici);\n\nnici = ~macaddr &0xffffff;\nfprintf(fhout, \"wlan%06x\\n\", nici);\n\nnici = ~macaddr &0xffffffff;\nfprintf(fhout, \"%08x\\n\", nici);\n\nnici = (~macaddr >> 8) &0xffffffff;\nfprintf(fhout, \"%08x\\n\", nici);\n\nfor (c = 0x01; c < 0x10; c ++)\n\t{\n\tnici = ~(macaddr -c) &0xffffff;\n\tfprintf(fhout, \"wlan%06x\\n\", nici);\n\n\tnici = ~(macaddr -c) &0xffffffff;\n\tfprintf(fhout, \"%08x\\n\", nici);\n\n\tnici = ((~macaddr -c) >> 8) &0xffffffff;\n\tfprintf(fhout, \"%08x\\n\", nici);\n\t}\n\nme = macaddr &0xffffff;\nfprintf(fhout, \"05%6d\\n\", me);\noui = macaddr &0xffffff000000L;\nnic = (macaddr -0x7f) &0xffffffL;\nfor(c = 0; c <= 0xff; c++) writebssid(fhout, oui +((nic +c) &0xffffffL));\nif(oui == 0xccb171000000L)\n\t{\n\tfor(c = 0; c <= 0xff; c++) fprintf(fhout, \"CCB071%06llX\\n\", ((nic +c) &0xffffffL));\n\t}\nswap = (nic >> 8) & 0xffff;\n\t{\n\tswap = (swap & 0xf000) >> 12 | (swap & 0x0f00) >> 4 | (swap & 0x00f0) << 4 | (swap & 0x000f) << 12;\n\tsnprintf(pskstring, PSKSTRING_LEN_MAX, \"000000%04X\", swap);\n\tfprintf(fhout, \"%s\\n\", pskstring);\n\t}\ntest000559(fhout, macaddr);\nreturn;\n}\n/*===========================================================================*/\nstatic void processbssids(FILE *fhout)\n{\nstatic int c;\nstatic apessidl_t *zeiger;\nstatic apessidl_t *zeiger1;\n\nqsort(apessidliste, apessidcount, APESSIDLIST_SIZE, sort_apessidlist_by_ap);\nzeiger = apessidliste;\nfor(c = 0; c < apessidcount; c++)\n\t{\n\tif(c == 0) preparebssid(fhout, zeiger->macaddr);\n\telse\n\t\t{\n\t\tzeiger1 = zeiger -1;\n\t\tif(zeiger->macaddr != zeiger1->macaddr) preparebssid(fhout, zeiger->macaddr);\n\t\t}\n\tzeiger++;\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void processadditionals(FILE *fhout)\n{\nif((eudateflag == true) || (usdateflag == true)) keywriteyearyear(fhout);\nif(alticeoptimumflag == true) keywritealticeoptimum(fhout);\nif(asusflag == true) keywriteasus(fhout);\nif(digit10flag == true) keywritedigit10(fhout);\nif(eeflag == true) keywriteee(fhout, false);\nif(eeupperflag == true) keywriteee(fhout, true);\nif(egnflag == true) keywriteegn(fhout);\nif(eudateflag == true) keywriteeudate(fhout);\nif(netgearflag == true) keywritenetgear(fhout);\nif(phomeflag == true) keywritephome(fhout);\nif(simpleflag == true) keywritesimple(fhout);\nif(spectrumflag == true) keywritespectrum(fhout);\nif(tendaflag == true) keywritetenda(fhout);\nif(usdateflag == true) keywriteusdate(fhout);\nif(weakpassflag == true) keywriteweakpass(fhout);\nif(wpskeysflag == true) writewpsall(fhout);\nreturn;\n}\n/*===========================================================================*/\n/*===========================================================================*/\nstatic void addapessid(uint64_t macaddr, uint8_t essidlen, uint8_t *essid)\n{\nstatic apessidl_t *zeiger;\n\nif(essidlen > ESSID_LEN_MAX) return;\nif(apessidliste == NULL)\n\t{\n\tapessidliste = (apessidl_t*)malloc(APESSIDLIST_SIZE);\n\tif(apessidliste == NULL)\n\t\t{\n\t\tfprintf(stderr, \"failed to allocate memory\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\tmemset(apessidliste, 0, APESSIDLIST_SIZE);\n\tapessidliste->macaddr = macaddr;\n\tapessidliste->essidlen = essidlen;\n\tmemcpy(apessidliste->essid, essid, essidlen);\n\tapessidcount++;\n\treturn;\n\t}\nzeiger = apessidliste +apessidcount -1;\nif((zeiger->macaddr == macaddr) && (zeiger->essidlen == essidlen) && (memcmp(zeiger->essid, essid, essidlen) == 0)) return;\nzeiger = (apessidl_t*)realloc(apessidliste, (apessidcount +1) *APESSIDLIST_SIZE);\nif(zeiger == NULL)\n\t{\n\tfprintf(stderr, \"failed to allocate memory\\n\");\n\texit(EXIT_FAILURE);\n\t}\napessidliste = zeiger;\nzeiger = apessidliste +apessidcount;\nmemset(zeiger, 0, APESSIDLIST_SIZE);\nzeiger->macaddr = macaddr;\nzeiger->essidlen = essidlen;\nmemcpy(zeiger->essid, essid, essidlen);\napessidcount++;\nreturn;\n}\n/*===========================================================================*/\nstatic void readpmkidfile(char *pmkidname)\n{\nstatic int len;\nstatic int aktread = 1;\nstatic ssize_t essidlen;\nstatic char *macaddrstop = NULL;\nstatic unsigned long long int macaddr;\nstatic FILE *fh_file;\n\nstatic char linein[PMKID_LINE_LEN];\nstatic uint8_t essid[ESSID_LEN_MAX];\n\nif((fh_file = fopen(pmkidname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening hash file failed %s\\n\", pmkidname);\n\treturn;\n\t}\n\nwhile(1)\n\t{\n\tif((len = fgetline(fh_file, PMKID_LINE_LEN, linein)) == -1) break;\n\tif((len < 61) || ((len > 59 +(ESSID_LEN_MAX *2))))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tif(((linein[32] != ':') && (linein[45] != ':') && (linein[58] != ':')) && ((linein[32] != '*') && (linein[45] != '*') && (linein[58] != '*')))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tessidlen = len -59;\n\tif((essidlen %2) != 0)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tmacaddr = strtoull(linein +33, &macaddrstop, 16);\n\tif((macaddrstop -linein) != 45)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tif(hex2bin(&linein[59], essid, essidlen/2) != -1) addapessid(macaddr, essidlen/2, essid);\n\taktread++;\n\t}\nfclose(fh_file);\nreturn;\n}\n/*===========================================================================*/\nstatic void readpmkideapolfile(char *pmkideapolname)\n{\nstatic int len;\nstatic int aktread = 1;\nstatic ssize_t essidlen;\nstatic char *macaddrstop = NULL;\nstatic char *essidstop = NULL;\nstatic unsigned long long int macaddr;\nstatic FILE *fh_file;\n\nstatic const char hlid1[] = { \"WPA*01*\" };\nstatic const char hlid2[] = { \"WPA*02*\" };\n\nstatic char linein[PMKIDEAPOL_LINE_LEN];\nstatic uint8_t essid[ESSID_LEN_MAX];\n\nif((fh_file = fopen(pmkideapolname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening hash file failed %s\\n\", pmkideapolname);\n\treturn;\n\t}\nwhile(1)\n\t{\n\tif((len = fgetline(fh_file, PMKIDEAPOL_LINE_LEN, linein)) == -1) break;\n\tif(len < 68)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tif((memcmp(&hlid1, linein, 7) != 0) && (memcmp(&hlid2, linein, 7) != 0))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tif((linein[3] != '*') && (linein[6] != '*') && (linein[39] != '*') && (linein[52] != '*') && (linein[65] != '*'))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tessidstop = strchr(&linein[66], '*');\n\tif(essidstop == NULL)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tessidlen = essidstop -linein -66;\n\tif((essidlen %2) != 0)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tmacaddr = strtoull(linein +40, &macaddrstop, 16);\n\tif((macaddrstop -linein) != 52)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tif(hex2bin(&linein[66], essid, essidlen/2) != -1) addapessid(macaddr, essidlen/2, essid);\n\taktread++;\n\t}\nfclose(fh_file);\nreturn;\n}\n/*===========================================================================*/\nstatic int getwpapskfmt(int lenlinein, char *linein)\n{\nstatic int p;\nstatic const char *johnformat = \"$WPAPSK$\";\n\nfor(p = 0; p < lenlinein -8; p++)\n\t{\n\tif(memcmp(&linein[p], johnformat, 8) == 0) return p;\n\t}\nreturn 0;\n}\n/*===========================================================================*/\nstatic void readjohnfile(char *johnname)\n{\nstatic int len;\nstatic int aktread = 1;\nstatic int essidlen;\nstatic int macp;\nstatic char *macaddrstop = NULL;\nstatic unsigned long long int macaddr;\nstatic FILE *fh_file;\n\nstatic char linein[JOHN_LINE_LEN];\n\nif((fh_file = fopen(johnname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening hash file failed %s\\n\", johnname);\n\treturn;\n\t}\nwhile(1)\n\t{\n\tif((len = fgetline(fh_file, JOHN_LINE_LEN, linein)) == -1) break;\n\tif(len < 475)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tessidlen = getwpapskfmt(len, linein);\n\tif(essidlen == 0)\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tif(essidlen < 2)\n\t\t{\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tessidlen--;\n\tif(memcmp(linein, &linein[essidlen +9], essidlen) != 0)\n\t\t{\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\n\tmacp = (essidlen *2) +10;\n\twhile((macp < essidlen) || (linein[macp] != ':'))\n\t\t{\n\t\tmacp++;\n\t\t}\n\n\tif((linein[macp +18] != ':') || (linein[macp +36] != ':') || (linein[macp +49] != ':'))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\n\tmacaddr = strtoull(linein +macp +37, &macaddrstop, 16);\n\tif((macaddrstop -linein) != (macp +49))\n\t\t{\n\t\tfprintf(stderr, \"reading hash line %d failed: %s\\n\", aktread, linein);\n\t\taktread++;\n\t\tcontinue;\n\t\t}\n\tfprintf(stdout, \"%llx %.*s\\n\", macaddr, essidlen,  linein);\n\taddapessid(macaddr, essidlen, (uint8_t*)linein);\n\taktread++;\n\t}\nfclose(fh_file);\nreturn;\n}\n/*===========================================================================*/\nstatic void readhccapxfile(char *hccapxname)\n{\nstatic struct stat statinfo;\nstatic hccapx_t *hcxptr;\nstatic FILE *fhhcx;\nstatic unsigned long long int macaddr;\n\nstatic uint8_t hcxdata[HCCAPX_SIZE];\n\nif(stat(hccapxname, &statinfo) != 0)\n\t{\n\tfprintf(stderr, \"can't stat %s\\n\", hccapxname);\n\treturn;\n\t}\nif((statinfo.st_size %HCCAPX_SIZE) != 0)\n\t{\n\tfprintf(stderr, \"file corrupt\\n\");\n\treturn;\n\t}\nif((fhhcx = fopen(hccapxname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"error opening file %s\", hccapxname);\n\treturn;\n\t}\nhcxptr = (hccapx_t*)hcxdata;\nwhile(fread(&hcxdata, HCCAPX_SIZE, 1, fhhcx) == 1)\n\t{\n\tif(hcxptr->signature != HCCAPX_SIGNATURE) continue;\n\tif((hcxptr->version != 3) && (hcxptr->version != 4)) continue;\n\tif(hcxptr->essid_len > ESSID_LEN_MAX) continue;\n\tmacaddr = 0;\n\tmacaddr = hcxptr->mac_ap[0];\n\tmacaddr = (macaddr << 8) + hcxptr->mac_ap[1];\n\tmacaddr = (macaddr << 8) + hcxptr->mac_ap[2];\n\tmacaddr = (macaddr << 8) + hcxptr->mac_ap[3];\n\tmacaddr = (macaddr << 8) + hcxptr->mac_ap[4];\n\tmacaddr = (macaddr << 8) + hcxptr->mac_ap[5];\n\taddapessid(macaddr, hcxptr->essid_len, hcxptr->essid);\n\t}\nfclose(fhhcx);\nreturn;\n}\n/*===========================================================================*/\nstatic void readcommandline(char *macapname, char *essidname)\n{\nstatic int essidlen = 0;\nstatic ssize_t essidlenuh = 0;\nstatic char *macaddrstop = NULL;\nstatic unsigned long long int macaddr = 0xffffffffffffL;\nstatic uint8_t essid[ESSID_LEN_MAX];\n\nif(macapname != NULL)\n\t{\n\tmacaddr = strtoull(macapname, &macaddrstop, 16);\n\tif((macaddrstop -macapname) != 12) fprintf(stderr, \"invalid MAC specified\\n\");\n\t}\nmemset(&essid, 0, ESSID_LEN_MAX);\nif(essidname != NULL)\n\t{\n\tessidlen = strlen(essidname);\n\tessidlenuh = ishexify(essidname);\n\tif((essidlenuh > 0) && (essidlenuh <= ESSID_LEN_MAX))\n\t\t{\n\t\tif(hex2bin(&essidname[5], essid, essidlenuh) != -1) addapessid(macaddr, essidlenuh, essid);\n\t\treturn;\n\t\t}\n\tmemset(&essid, 0, ESSID_LEN_MAX);\n\tif(essidlen <= ESSID_LEN_MAX) memcpy(&essid, essidname, essidlen);\n\t}\naddapessid(macaddr, essidlen, essid);\nreturn;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic void version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage:\\n\"\n\t\"%s <options>\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-c <file>   : input PMKID/EAPOL hash file (hashcat -m 22000/22001)\\n\"\n\t\"-i <file>   : input EAPOL hash file (hashcat -m 2500/2501)\\n\"\n\t\"-j <file>   : input EAPOL hash file (john)\\n\"\n\t\"-z <file>   : input PMKID hash file (hashcat -m 16800/16801 and john)\\n\"\n\t\"-e <char>   : input ESSID\\n\"\n\t\"-b <xdigit> : input MAC access point\\n\"\n\t\"              format: 112233445566\\n\"\n\t\"-o <file>   : output PSK file\\n\"\n\t\"              default: stdout\\n\"\n\t\"              output list must be sorted unique!\\n\"\n\t\"-h          : show this help\\n\"\n\t\"-v          : show version\\n\"\n\t\"\\n\"\n\t\"--maconly           : print only candidates based on ACCESS POINT MAC\\n\"\n\t\"--noessidcombination: exclude ESSID combinations\\n\"\n\t\"--netgear           : include weak NETGEAR / ORBI / NTGR_VMB / ARLO_VMB / FoxtelHub candidates\\n\"\n\t\"--spectrum          : include weak MySpectrumWiFi / SpectrumSetup / MyCharterWiFi candidates\\n\"\n\t\"                      list will be > 2.2GB\\n\"\n\t\"--digit10           : include weak 10 digit candidates (INFINITUM, ALHN, INEA, VodafoneNet, VIVACOM)\\n\"\n\t\"                      list will be > 1GB\\n\"\n\t\"--phome             : include weak PEGATRON / Vantiva candidates (CBCI, HOME, [SP/XF]SETUP)\\n\"\n\t\"                      list will be > 2.9GB\\n\"\n\t\"--tenda             : include weak Tenda / NOVA / NOVE / BrosTrend candidates\\n\"\n\t\"--ee                : include weak 5GHz-EE / BrightBox / EE / EE-BrightBox candidates\\n\"\n\t\"                      list will be > 1.3GB\\n\"\n\t\"--eeupper           : include weak EE-Hub candidates\\n\"\n\t\"                      list will be > 3.8GB\\n\"\n\t\"--alticeoptimum     : include weak Altice/Optimum candidates (MyAltice, MyOptimum)\\n\"\n\t\"                      list will be > 4.6GB\\n\"\n\t\"--asus              : include weak ASUS RT-AC candidates (ASUS_XX, RT-AC)\\n\"\n\t\"--weakpass          : include weak password candidates\\n\"\n\t\"--eudate            : include complete european dates\\n\"\n\t\"--usdate            : include complete american dates\\n\"\n\t\"--wpskeys           : include complete WPS keys\\n\"\n\t\"--egn               : include Bulgarian EGN\\n\"\n\t\"--simple            : include simple pattern\\n\"\n\t\"--help              : show this help\\n\"\n\t\"--version           : show version\\n\"\n\t\"\\n\"\n\t\"if hcxpsktool recovered your password, you should change it immediately!\\n\\n\",\n\teigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic FILE *fhpsk;\n\nstatic char *pmkideapolname = NULL;\nstatic char *hccapxname = NULL;\nstatic char *johnname = NULL;\nstatic char *pmkidname = NULL;\nstatic char *essidname = NULL;\nstatic char *macapname = NULL;\nstatic char *pskname = NULL;\n\nairtelflag = false;\nalticeoptimumflag = false;\nasusflag = false;\ndigit10flag = false;\neasyboxflag = false;\neeflag = false;\negnflag = false;\neudateflag = false;\nhb5flag = false;\nmaconlyflag = false;\nnetgearflag = false;\nnoessidcombinationflag = false;\nphomeflag = false;\npodaflag = false;\nsimpleflag = false;\nspectrumflag = false;\ntendaflag = false;\nukrtelecomflag = false;\nusdateflag = false;\nweakpassflag = false;\nwpskeysflag = false;\nznidflag = false;\n\nstatic const char *short_options = \"c:i:j:z:o:e:b:o:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"alticeoptimum\",\t\tno_argument,\t\tNULL,\tHCXD_ALTICEOPTIMUM},\n\t{\"asus\",\t\t\tno_argument,\t\tNULL,\tHCXD_ASUS},\n\t{\"digit10\",\t\t\tno_argument,\t\tNULL,\tHCXD_DIGIT10},\n\t{\"ee\",\t\t\t\tno_argument,\t\tNULL,\tHCXD_EE},\n\t{\"eeupper\",\t\t\tno_argument,\t\tNULL,\tHCXD_EEUPPER},\n\t{\"egn\",\t\t\t\tno_argument,\t\tNULL,\tHCXD_EGN},\n\t{\"eudate\",\t\t\tno_argument,\t\tNULL,\tHCXD_EUDATE},\n\t{\"maconly\",\t\t\tno_argument,\t\tNULL,\tHCXD_MACONLY},\n\t{\"netgear\",\t\t\tno_argument,\t\tNULL,\tHCXD_NETGEAR},\n\t{\"noessidcombination\",\t\tno_argument,\t\tNULL,\tHCXD_NOESSIDCOMBINATION},\n\t{\"phome\",\t\t\tno_argument,\t\tNULL,\tHCXD_PHOME},\n\t{\"simple\",\t\t\tno_argument,\t\tNULL,\tHCXD_SIMPLE},\n\t{\"spectrum\",\t\t\tno_argument,\t\tNULL,\tHCXD_SPECTRUM},\n\t{\"tenda\",\t\t\tno_argument,\t\tNULL,\tHCXD_TENDA},\n\t{\"usdate\",\t\t\tno_argument,\t\tNULL,\tHCXD_USDATE},\n\t{\"weakpass\",\t\t\tno_argument,\t\tNULL,\tHCXD_WEAKPASS},\n\t{\"wpskeys\",\t\t\tno_argument,\t\tNULL,\tHCXD_WPSKEYS},\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCXD_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCXD_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\nwhile((auswahl = getopt_long (argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCXD_MACONLY:\n\t\tmaconlyflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_NETGEAR:\n\t\tnetgearflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_SPECTRUM:\n\t\tspectrumflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_NOESSIDCOMBINATION:\n\t\tnoessidcombinationflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_DIGIT10:\n\t\tdigit10flag = true;\n\t\tbreak;\n\n\t\tcase HCXD_PHOME:\n\t\tphomeflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_TENDA:\n\t\ttendaflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_EE:\n\t\teeflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_EEUPPER:\n\t\teeupperflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_ALTICEOPTIMUM:\n\t\talticeoptimumflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_ASUS:\n\t\tasusflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_WEAKPASS:\n\t\tweakpassflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_EUDATE:\n\t\teudateflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_USDATE:\n\t\tusdateflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_WPSKEYS:\n\t\twpskeysflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_EGN:\n\t\tegnflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_SIMPLE:\n\t\tsimpleflag = true;\n\t\tbreak;\n\n\t\tcase HCXD_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCXD_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase 'c':\n\t\tpmkideapolname = optarg;\n\t\tbreak;\n\n\t\tcase 'i':\n\t\thccapxname = optarg;\n\t\tbreak;\n\n\t\tcase 'j':\n\t\tjohnname = optarg;\n\t\tbreak;\n\n\t\tcase 'z':\n\t\tpmkidname = optarg;\n\t\tbreak;\n\n\t\tcase 'e':\n\t\tessidname = optarg;\n\t\tbreak;\n\n\t\tcase 'b':\n\t\tmacapname = optarg;\n\t\tif(strlen(macapname) != 12)\n\t\t\t{\n\t\t\tfprintf(stderr, \"invalid MAC specified\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase 'o':\n\t\tpskname = optarg;\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\n\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\n\");\n\treturn EXIT_SUCCESS;\n\t}\n\nglobalinit();\n\nif((macapname != NULL) || (essidname != NULL))\n\t{\n\treadcommandline(macapname, essidname);\n\t}\n\nif(pmkideapolname != NULL)\n\t{\n\treadpmkideapolfile(pmkideapolname);\n\t}\n\nif(pmkidname != NULL)\n\t{\n\treadpmkidfile(pmkidname);\n\t}\n\nif(hccapxname != NULL)\n\t{\n\treadhccapxfile(hccapxname);\n\t}\n\nif(johnname != NULL)\n\t{\n\treadjohnfile(johnname);\n\t}\n\nif(apessidliste == NULL)\n\t{\n\tfprintf(stderr, \"no hashes loaded\\n\");\n\t}\n\nif(pskname != NULL)\n\t{\n\tif((fhpsk = fopen(pskname, \"w\")) == NULL)\n\t\t{\n\t\tfprintf(stderr, \"error opening psk file %s\\n\", pskname);\n\t\texit(EXIT_FAILURE);\n\t\t}\n\tprocessbssids(fhpsk);\n\tif(maconlyflag == false)\n\t\t{\n\t\tprocessessids(fhpsk);\n\t\tprocessbssidsessids(fhpsk);\n\t\tprocessadditionals(fhpsk);\n\t\t}\n\t}\nelse\n\t{\n\tprocessbssids(stdout);\n\tif(maconlyflag == false)\n\t\t{\n\t\tprocessessids(stdout);\n\t\tprocessbssidsessids(stdout);\n\t\tprocessadditionals(stdout);\n\t\t}\n\t}\n\nif(pskname != NULL)\n\t{\n\tfclose(fhpsk);\n\t}\n\nEVP_cleanup();\nCRYPTO_cleanup_all_ex_data();\nERR_free_strings();\n\nreturn EXIT_SUCCESS;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "hcxwltool.c",
          "type": "blob",
          "size": 14.0771484375,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <getopt.h>\n#include <libgen.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"include/hcxwltool.h\"\n#include \"include/strings.c\"\n#include \"include/fileops.c\"\n\n/*===========================================================================*/\n/* global variable */\n\nstatic bool wantstraight;\nstatic bool wantdigit;\nstatic bool wantxdigit;\nstatic bool wantlower;\nstatic bool wantupper;\nstatic bool wantcapital;\nstatic int sweeplen;\n/*===========================================================================*/\nstatic void printstraightlower(FILE *fh_out, int len, char *linein)\n{\nstatic int p,px;\n\nstatic char lineout[LINEIN_MAX] = { 0 };\n\npx = 0;\nfor(p = 0; p < len; p++)\n\t{\n\tif(isupper((unsigned char)linein[p]))\n\t\t{\n\t\tlineout[p] = tolower((unsigned char)linein[p]);\n\t\t}\n\telse\n\t\t{\n\t\tlineout[p] = linein[p];\n\t\t}\n\tif(isxdigit((unsigned char)lineout[p]))\n\t\t{\n\t\tpx++;\n\t\t}\n\t}\nlineout[p] = 0;\n\nif(p != px)\n\t{\n\tfprintf(fh_out, \"%s\\n\", lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printstraightupper(FILE *fh_out, int len, char *linein)\n{\nstatic int p, px;\n\nstatic char lineout[LINEIN_MAX] = { 0 };\n\npx = 0;\nfor(p = 0; p < len; p++)\n\t{\n\tif(islower((unsigned char)linein[p]))\n\t\t{\n\t\tlineout[p] = toupper((unsigned char)linein[p]);\n\t\t}\n\telse\n\t\t{\n\t\tlineout[p] = linein[p];\n\t\t}\n\tif(isxdigit((unsigned char)lineout[p]))\n\t\t{\n\t\tpx++;\n\t\t}\n\t}\nlineout[p] = 0;\n\nif(p != px)\n\t{\n\tfprintf(fh_out, \"%s\\n\", lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printstraightcapital(FILE *fh_out, int len, char *linein)\n{\nstatic int p,px;\n\nstatic char lineout[LINEIN_MAX] = { 0 };\n\npx = 0;\nfor(p = 0; p < len; p++)\n\t{\n\tif(isupper((unsigned char)linein[p]))\n\t\t{\n\t\tlineout[p] = tolower((unsigned char)linein[p]);\n\t\t}\n\telse\n\t\t{\n\t\tlineout[p] = linein[p];\n\t\t}\n\tif(isxdigit((unsigned char)lineout[p]))\n\t\t{\n\t\tpx++;\n\t\t}\n\t}\nlineout[p] = 0;\n\nif((p != px) && ((lineout[0] >= 'a') && (lineout[0] <= 'z')))\n\t{\n\tlineout[0] = toupper((unsigned char)linein[0]);\n\tfprintf(fh_out, \"%s\\n\", lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printstraightstraight(FILE *fh_out, char *linein)\n{\n\nfprintf(fh_out, \"%s\\n\", linein);\n\nreturn;\n}\n/*===========================================================================*/\nstatic void printstraigthsweep(FILE *fh_out, int slen, int len, char *linein)\n{\nstatic int l;\nstatic char lineout[LINEIN_MAX] = { 0 };\n\nif(len >= slen)\n\t{\n\tfor(l = 0; l <= len -slen; l++)\n\t\t{\n\t\tmemcpy(&lineout, &linein[l], slen);\n\t\tlineout[slen] = 0;\n\t\tif(wantlower == true)\n\t\t\t{\n\t\t\tprintstraightlower(fh_out, slen, lineout);\n\t\t\t}\n\t\tif(wantupper == true)\n\t\t\t{\n\t\t\tprintstraightupper(fh_out, slen, lineout);\n\t\t\t}\n\t\tif(wantcapital == true)\n\t\t\t{\n\t\t\tprintstraightcapital(fh_out, slen, lineout);\n\t\t\t}\n\t\tif((wantlower == false) && (wantupper == false) && (wantcapital == false))\n\t\t\t{\n\t\t\tprintstraightstraight(fh_out, lineout);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void handlestraight(FILE *fh_out, int len, char *linein)\n{\nif(sweeplen == 0)\n\t{\n\tif(wantlower == true)\n\t\t{\n\t\tprintstraightlower(fh_out, len, linein);\n\t\t}\n\tif(wantupper == true)\n\t\t{\n\t\tprintstraightupper(fh_out, len, linein);\n\t\t}\n\tif(wantcapital == true)\n\t\t{\n\t\tprintstraightcapital(fh_out, len, linein);\n\t\t}\n\tif((wantlower == false) && (wantupper == false) && (wantcapital == false))\n\t\t{\n\t\tprintstraightstraight(fh_out, linein);\n\t\t}\n\t}\nelse\n\t{\n\tprintstraigthsweep(fh_out, sweeplen, len,linein);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printxdigitlower(FILE *fh_out, int len, char *linein)\n{\nstatic int p, pd;\n\nstatic char lineout[LINEIN_MAX] = { 0 };\n\npd = 0;\nfor(p = 0; p < len; p++)\n\t{\n\tif(isupper((unsigned char)linein[p]))\n\t\t{\n\t\tlineout[p] = tolower((unsigned char)linein[p]);\n\t\t}\n\telse\n\t\t{\n\t\tlineout[p] = linein[p];\n\t\t}\n\tif(isdigit((unsigned char)lineout[p]))\n\t\t{\n\t\tpd++;\n\t\t}\n\t}\nlineout[p] = 0;\n\nif(p != pd)\n\t{\n\tfprintf(fh_out, \"%s\\n\", lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printxdigitupper(FILE *fh_out, int len, char *linein)\n{\nstatic int p, pd;\n\nstatic char lineout[LINEIN_MAX] = { 0 };\n\npd = 0;\nfor(p = 0; p < len; p++)\n\t{\n\tif(islower((unsigned char)linein[p]))\n\t\t{\n\t\tlineout[p] = toupper((unsigned char)linein[p]);\n\t\t}\n\telse\n\t\t{\n\t\tlineout[p] = linein[p];\n\t\t}\n\tif(isdigit((unsigned char)lineout[p]))\n\t\t{\n\t\tpd++;\n\t\t}\n\t}\nlineout[p] = 0;\n\nif(p != pd)\n\t{\n\tfprintf(fh_out, \"%s\\n\", lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printxdigitstraight(FILE *fh_out, int len, char *linein)\n{\nstatic int p, pd;\n\npd = 0;\nfor(p = 0; p < len; p++)\n\t{\n\tif(isdigit((unsigned char)linein[p]))\n\t\t{\n\t\tpd++;\n\t\t}\n\t}\n\nif(p != pd)\n\t{\n\tfprintf(fh_out, \"%s\\n\", linein);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printxdigitsweep(FILE *fh_out, int slen, int len, char *linein)\n{\nstatic int l;\nstatic char lineout[LINEIN_MAX] = { 0 };\n\nif(len >= slen)\n\t{\n\tfor(l = 0; l <= len -slen; l++)\n\t\t{\n\t\tmemcpy(&lineout, &linein[l], slen);\n\t\tlineout[slen] = 0;\n\t\tif(wantlower == true)\n\t\t\t{\n\t\t\tprintxdigitlower(fh_out, slen, lineout);\n\t\t\t}\n\t\tif(wantupper == true)\n\t\t\t{\n\t\t\tprintxdigitupper(fh_out, slen, lineout);\n\t\t\t}\n\t\tif((wantlower == false) && (wantupper == false))\n\t\t\t{\n\t\t\tprintxdigitstraight(fh_out, slen, lineout);\n\t\t\t}\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void handlexdigit(FILE *fh_out, int len, char *linein)\n{\nstatic int i, o;\nstatic char lineout[LINEIN_MAX] = { 0 };\n\no = 0;\nfor(i = 0; i < len; i++)\n\t{\n\tif(isxdigit((unsigned char)linein[i]))\n\t\t{\n\t\tlineout[o] = linein[i];\n\t\to++;\n\t\t}\n\t}\nlineout[o] = 0;\nif((o < 8) || (o > 63))\n\t{\n\treturn;\n\t}\n\nif(sweeplen == 0)\n\t{\n\tif(wantlower == true)\n\t\t{\n\t\tprintxdigitlower(fh_out, o, lineout);\n\t\t}\n\tif(wantupper == true)\n\t\t{\n\t\tprintxdigitupper(fh_out, o, lineout);\n\t\t}\n\tif((wantlower == false) && (wantupper == false))\n\t\t{\n\t\tprintxdigitstraight(fh_out, o, lineout);\n\t\t}\n\n\t}\nelse\n\t{\n\tprintxdigitsweep(fh_out, sweeplen, o,lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void printdigitsweep(FILE *fh_out, int slen, int len, char *linein)\n{\nstatic int l;\nstatic char lineout[LINEIN_MAX] = { 0 };\n\nif(len >= slen)\n\t{\n\tfor(l = 0; l <= len -slen; l++)\n\t\t{\n\t\tmemcpy(&lineout, &linein[l], slen);\n\t\tlineout[slen] = 0;\n\t\tfprintf(fh_out, \"%s\\n\", lineout);\n\t\t}\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic void handledigit(FILE *fh_out, int len, char *linein)\n{\nstatic int i, o;\nstatic char lineout[LINEIN_MAX] = { 0 };\n\no = 0;\nfor(i = 0; i < len; i++)\n\t{\n\tif(isdigit((unsigned char)linein[i]))\n\t\t{\n\t\tlineout[o] = linein[i];\n\t\to++;\n\t\t}\n\t}\nlineout[o] = 0;\nif((o < 8) || (o > 63))\n\t{\n\treturn;\n\t}\n\nif(sweeplen == 0)\n\t{\n\tfprintf(fh_out, \"%s\\n\", lineout);\n\t}\nelse\n\t{\n\tprintdigitsweep(fh_out, sweeplen, o, lineout);\n\t}\nreturn;\n}\n/*===========================================================================*/\nstatic int handleignore(int len, char *linein)\n{\n\nstatic const char *wlan = \"WLAN-\";\nstatic const char *skyroam = \"#Skyroam_\";\nstatic const char *huitube3 = \"3HuiTube_\";\nstatic const char *pocket3 = \"3Pocket_\";\nstatic const char *mobilewifi3 = \"3MobileWiFi-\";\nstatic const char *tube3 = \"3Tube_\";\nstatic const char *web3 = \"3Web\";\nstatic const char *webcube = \"WebCube\";\nstatic const char *neo3 = \"3neo_\";\n\nstatic const char *wifi4g = \"4G Wi-Fi 3Danmark-\";\n\nif(len == 11)\n\t{\n\tif(memcmp(wlan, linein, 5) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(webcube, linein, 7) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 12)\n\t{\n\tif(memcmp(skyroam, linein, 9) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(web3, linein, 4) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(webcube, linein, 7) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 13)\n\t{\n\tif(memcmp(skyroam, linein, 9) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(webcube, linein, 7) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 14)\n\t{\n\tif(memcmp(skyroam, linein, 9) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(web3, linein, 4) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(webcube, linein, 7) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 15)\n\t{\n\tif(memcmp(webcube, linein, 7) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 16)\n\t{\n\tif(memcmp(pocket3, linein, 8) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(mobilewifi3, linein, 11) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(neo3, linein, 5) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 17)\n\t{\n\tif(memcmp(tube3, linein, 6) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 18)\n\t{\n\tif(memcmp(huitube3, linein, 9) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\tif(memcmp(wifi4g, linein, 18) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 20)\n\t{\n\tif(memcmp(huitube3, linein, 9) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nif(len == 22)\n\t{\n\tif(memcmp(wifi4g, linein, 18) == 0)\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\n\nreturn len;\n}\n/*===========================================================================*/\nstatic int handlehex(int len, char *line)\n{\nstatic const char *token = \"$HEX[\";\n\nif(len >= 6)\n\t{\n\tif((memcmp(line, token, 5) == 0) && (line[len -1] == ']'))\n\t\t{\n\t\treturn 0;\n\t\t}\n\t}\nreturn len;\n}\n/*===========================================================================*/\nstatic void processwordlist(char *wordlistinname, FILE *fh_out)\n{\nstatic int len;\nstatic FILE *fh_in;\n\nstatic char linein[LINEIN_MAX];\n\nif((fh_in = fopen(wordlistinname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"opening wordlist failed %s\\n\", wordlistinname);\n\treturn;\n\t}\n\nwhile(1)\n\t{\n\tif((len = fgetline(fh_in, LINEIN_MAX, linein)) == -1)\n\t\t{\n\t\tbreak;\n\t\t}\n\tif((len < 8) || (len > 70))\n\t\t{\n\t\tcontinue;\n\t\t}\n\tif(handlehex(len, linein) == 0)\n\t\t{\n\t\tcontinue;\n\t\t}\n\tif(wantstraight == true)\n\t\t{\n\t\tif(handleignore(len, linein) != 0)\n\t\t\t{\n\t\t\thandlestraight(fh_out, len, linein);\n\t\t\t}\n\t\t}\n\tif(wantdigit == true)\n\t\t{\n\t\thandledigit(fh_out, len, linein);\n\t\t}\n\tif(wantxdigit == true)\n\t\t{\n\t\thandlexdigit(fh_out, len, linein);\n\t\t}\n\t}\nfclose(fh_in);\nreturn;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic void version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage:\\n\"\n\t\"%s <options>\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-i <file> : input wordlist\\n\"\n\t\"-o <file> : output wordlist to file\\n\"\n\t\"-h        : show this help\\n\"\n\t\"-v        : show version\\n\"\n\t\"\\n\"\n\t\"--straight       : output format untouched\\n\"\n\t\"--digit          : output format only digits\\n\"\n\t\"--xdigit         : output format only xdigits\\n\"\n\t\"--lower          : output format only lower\\n\"\n\t\"--upper          : output format only upper\\n\"\n\t\"--capital        : output format only capital\\n\"\n\t\"--length=<digit> : password length (8...32)\\n\"\n\t\"--help           : show this help\\n\"\n\t\"--version        : show version\\n\"\n\t\"\\n\"\n\t\"examples:\\n\"\n\t\"hcxwltool -i wordlist --straight | sort | uniq | hashcat -m 22000 hashfile.hc22000\\n\"\n\t\"hcxwltool -i wordlist --digit --length=10 | sort | uniq | hashcat -m 22000 hashfile.hc22000\\n\"\n\t\"hcxwltool -i wordlist --digit | sort | uniq | hashcat -m 22000 hashfile.hc22000\\n\"\n\t\"hcxwltool -i wordlist --xdigit | sort | uniq | john --stdin --format=wpapsk-opencl john.hashfile\\n\"\n\t\"\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usageerror(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s by ZeroBeat\\n\"\n\t\"usage: %s -h for help\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int index;\nstatic FILE *fh_out;\n\nstatic char *wordlistinname = NULL;\nstatic char *wordlistoutname = NULL;\n\nstatic const char *short_options = \"i:o:hv\";\nstatic const struct option long_options[] =\n{\n\t{\"straight\",\t\t\tno_argument,\t\tNULL,\tHCX_STRAIGHT},\n\t{\"digit\",\t\t\tno_argument,\t\tNULL,\tHCX_DIGIT},\n\t{\"xdigit\",\t\t\tno_argument,\t\tNULL,\tHCX_XDIGIT},\n\t{\"lower\",\t\t\tno_argument,\t\tNULL,\tHCX_LOWER},\n\t{\"upper\",\t\t\tno_argument,\t\tNULL,\tHCX_UPPER},\n\t{\"capital\",\t\t\tno_argument,\t\tNULL,\tHCX_CAPITAL},\n\t{\"length\",\t\t\trequired_argument,\tNULL,\tHCX_SWEEP_LEN},\n\t{\"version\",\t\t\tno_argument,\t\tNULL,\tHCX_VERSION},\n\t{\"help\",\t\t\tno_argument,\t\tNULL,\tHCX_HELP},\n\t{NULL,\t\t\t\t0,\t\t\tNULL,\t0}\n};\n\nwantstraight = false;\nwantdigit = false;\nwantxdigit = false;\nwantlower = false;\nwantupper = false;\nwantcapital = false;\nsweeplen = 0;\n\nauswahl = -1;\nindex = 0;\noptind = 1;\noptopt = 0;\n\nwhile((auswahl = getopt_long (argc, argv, short_options, long_options, &index)) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase HCX_INPUT_WORDLIST:\n\t\twordlistinname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_OUTPUT_WORDLIST:\n\t\twordlistoutname = optarg;\n\t\tbreak;\n\n\t\tcase HCX_STRAIGHT:\n\t\twantstraight = true;\n\t\tbreak;\n\n\t\tcase HCX_DIGIT:\n\t\twantdigit = true;\n\t\tbreak;\n\n\t\tcase HCX_XDIGIT:\n\t\twantxdigit = true;\n\t\tbreak;\n\n\t\tcase HCX_LOWER:\n\t\twantlower = true;\n\t\tbreak;\n\n\t\tcase HCX_UPPER:\n\t\twantupper = true;\n\t\tbreak;\n\n\t\tcase HCX_CAPITAL:\n\t\twantcapital = true;\n\t\tbreak;\n\n\t\tcase HCX_SWEEP_LEN:\n\t\tsweeplen = strtol(optarg, NULL, 10);\n\t\tif((sweeplen < 8) || (sweeplen > 32))\n\t\t\t{\n\t\t\tfprintf(stderr, \"only 8...32 allowed\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase HCX_HELP:\n\t\tusage(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase HCX_VERSION:\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tcase '?':\n\t\tusageerror(basename(argv[0]));\n\t\tbreak;\n\t\t}\n\t}\n\nif(argc < 2)\n\t{\n\tfprintf(stderr, \"no option selected\\n\");\n\treturn EXIT_SUCCESS;\n\t}\n\nif(wordlistoutname != 0)\n\t{\n\tif((fh_out = fopen(wordlistoutname, \"w\")) == NULL)\n\t\t{\n\t\tperror(\"failed to open output file\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nelse\n\t{\n\tfh_out = stdout;\n\t}\n\nif(wordlistinname != NULL)\n\t{\n\tprocesswordlist(wordlistinname, fh_out);\n\t}\n\nif(wordlistoutname != 0)\n\t{\n\tfclose(fh_out);\n\t}\n\nreturn EXIT_SUCCESS;\n}\n/*===========================================================================*/\n"
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "license.txt",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2000-2024 ZeroBeat\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 1.4677734375,
          "content": "project(\n  'hcxtools',\n  'c',\n  version: '6.3.2',\n  default_options: ['warning_level=3'],\n)\n\nvyear = 2024\n\nif true\n  vtag = meson.project_version()\nelse\n  gcmd = run_command('git describe --tags')\n  if gcmd.returncode() == 0\n    vtag = gcmd.stdout()\n  else\n    vtag = meson.project_version()\n  endif\nendif\n\nadd_project_arguments('-DVERSION_TAG=\"@0@\"'.format(vtag), language: 'c')\nadd_project_arguments('-DVERSION_YEAR=\"@0@\"'.format(vyear), language: 'c')\n\ncc = meson.get_compiler('c')\n\ncurl_dep = dependency('libcurl', required: get_option('curl'))\nopenssl_dep = dependency('openssl', required: get_option('openssl'))\nwinsock_dep = cc.find_library('ws2_32', required: host_machine.system() == 'windows')\nzlib_dep = dependency('zlib', required: get_option('zlib'))\nif zlib_dep.found()\n  add_project_arguments('-DWANTZLIB', language: 'c')\nendif\n\ntools = {\n  'hcxeiutool': [],\n  'hcxwltool': [],\n  'hcxhash2cap': winsock_dep,\n}\n\nif curl_dep.found()\n  tools += {'wlancap2wpasec': curl_dep}\n  if host_machine.system() != 'windows'\n    tools += {'whoismac': curl_dep}\n  endif\nendif\n\nif openssl_dep.found()\n  tools += {\n    'hcxpcapngtool': [openssl_dep, winsock_dep, zlib_dep],\n    'hcxpsktool': openssl_dep,\n    'hcxpmktool': [openssl_dep, winsock_dep],\n  }\n  if host_machine.system() != 'windows' and curl_dep.found()\n    tools += {'hcxhashtool': [curl_dep, openssl_dep]}\n  endif\nendif\n\nforeach t, d : tools\n  executable(\n    t,\n    '@0@.c'.format(t),\n    dependencies: d,\n    install: true,\n  )\nendforeach\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 0.2587890625,
          "content": "option('curl', type: 'feature',\n  description: 'Build tools relying on libcurl',\n)\n\noption('openssl', type: 'feature',\n  description: 'Build tools relying on OpenSSL',\n)\n\noption('zlib', type: 'feature',\n  description: 'Build with zlib support for hcxpcapngtool',\n)\n"
        },
        {
          "name": "usefulscripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "whoismac.c",
          "type": "blob",
          "size": 13.857421875,
          "content": "#define _GNU_SOURCE\n#include <ctype.h>\n#include <libgen.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <curl/curl.h>\n\n#include \"include/strings.c\"\n#include \"include/fileops.c\"\n\n#define LINEBUFFER_MAX\t256\n#define OUIBUFFER_MAX\t8192\n\nstatic const char *ouiurl = \"https://standards-oui.ieee.org/oui/oui.txt\";\n\n/*===========================================================================*/\nstatic bool downloadoui(char *ouiname)\n{\nstatic size_t bread;\nstatic CURLcode ret;\nstatic CURL *hnd;\nstatic FILE *fhoui;\nstatic FILE *fhouitmp;\nstatic char ouibuff[OUIBUFFER_MAX];\n\nfprintf(stdout, \"start downloading oui from https://standards-oui.ieee.org to: %s\\n\", ouiname);\nif((fhouitmp = tmpfile()) == NULL)\n\t{\n\tfprintf(stderr, \"failed to create temporary download file\\n\");\n\treturn false;\n\t}\nhnd = curl_easy_init ();\ncurl_easy_setopt(hnd, CURLOPT_URL, ouiurl);\ncurl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L);\ncurl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 5L);\ncurl_easy_setopt(hnd, CURLOPT_WRITEDATA, fhouitmp);\ncurl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 0L);\nret = curl_easy_perform(hnd);\ncurl_easy_cleanup(hnd);\nif(ret != 0)\n\t{\n\tfprintf(stderr, \"\\ndownload not successful\\n\");\n\texit(EXIT_FAILURE);\n\t}\nrewind(fhouitmp);\nif((fhoui = fopen(ouiname, \"w\")) == NULL)\n\t{\n\tfprintf(stderr, \"\\nerror creating file %s\\n\", ouiname);\n\texit(EXIT_FAILURE);\n\t}\nwhile (!feof(fhouitmp))\n\t{\n\tbread = fread(ouibuff, 1, sizeof(ouibuff), fhouitmp);\n\tif(bread > 0) fwrite(ouibuff, 1, bread, fhoui);\n\t}\nfclose(fhoui);\nfprintf(stdout, \"\\ndownload finished\\n\");\nreturn true;\n}\n/*===========================================================================*/\nstatic void getessidinfo(char *essidname)\n{\nstatic int l, p;\nstatic uint8_t essidbuffer[66];\n\nl = strlen(essidname);\nif((l < 2) || (l > 64))\n\t{\n\tfprintf(stderr, \"not a valid ESSID hex string\\n\");\n\treturn;\n\t}\nif((l %2) != 0)\n\t{\n\tfprintf(stderr, \"not a valid hex string\\n\");\n\treturn;\n\t}\nfor(p = 0; p < l; p++)\n\t{\n\tif(!isxdigit((unsigned char)essidname[p]))\n\t\t{\n\t\tfprintf(stderr, \"not a valid hex string\\n\");\n\t\treturn;\n\t\t}\n\t}\n\nmemset(&essidbuffer, 0, 66);\nif(hex2bin(essidname, essidbuffer, l /2) == -1)\n\t{\n\tfprintf(stderr, \"not a valid ESSID hex string\\n\");\n\treturn;\n\t}\nfprintf(stdout, \"%s\\n\", essidbuffer);\nreturn;\n}\n/*===========================================================================*/\nstatic void gethexessidinfo(char *hexessidname)\n{\nstatic int l, p;\nl = strlen(hexessidname);\nfor(p = 0; p < l; p++)\n\t{\n\tfprintf(stdout, \"%02x\", hexessidname[p]);\n\t}\nfprintf(stdout, \"\\n\");\nreturn;\n}\n/*===========================================================================*/\nstatic void get16800info(char *ouiname, char *hash16800line)\n{\nstatic int len;\nstatic int l, l1;\nstatic FILE* fhoui;\nstatic char *vendorptr;\nstatic char *essidptr;\nstatic char *passwdptr;\n\nstatic unsigned long long int macap;\nstatic unsigned long long int macsta;\nstatic unsigned long long int ouiap;\nstatic unsigned long long int ouista;\nstatic unsigned long long int vendoroui;\n\nstatic char linein[LINEBUFFER_MAX];\nstatic uint8_t essidbuffer[66];\nstatic char vendorapname[256];\nstatic char vendorstaname[256];\n\nsscanf(&hash16800line[33], \"%12llx\", &macap);\nouiap = macap >> 24;\nsscanf(&hash16800line[46], \"%12llx\", &macsta);\nouista = macsta >> 24;\n\nessidptr = hash16800line +59;\nl = strlen(essidptr);\n\npasswdptr = strrchr(essidptr, ':');\nif(passwdptr != NULL)\n\t{\n\tl1 = strlen(passwdptr);\n\tif(l1 > 1)\n\t\t{\n\t\tl -= l1;\n\t\t}\n\t}\nif((l%2 != 0) || (l > 64))\n\t{\n\tfprintf(stderr, \"xxx wrong ESSID length %s\\n\", essidptr);\n\treturn;\n\t}\nmemset(&essidbuffer, 0, 66);\nif(hex2bin(essidptr, essidbuffer, l /2) == -1)\n\t{\n\tfprintf(stderr, \"wrong ESSID %s\\n\", essidptr);\n\treturn;\n\t}\n\nif ((fhoui = fopen(ouiname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"unable to open database %s\\n\", ouiname);\n\texit (EXIT_FAILURE);\n\t}\n\nstrncpy(vendorapname, \"unknown\", 8);\nstrncpy(vendorstaname, \"unknown\", 8);\n\nwhile((len = fgetline(fhoui, LINEBUFFER_MAX, linein)) != -1)\n\t{\n\tif (len < 10)\n\t\tcontinue;\n\tif(strstr(linein, \"(base 16)\") != NULL)\n\t\t{\n\t\tsscanf(linein, \"%06llx\", &vendoroui);\n\t\tif(ouiap == vendoroui)\n\t\t\t{\n\t\t\tvendorptr = strrchr(linein, '\\t');\n\t\t\tif(vendorptr != NULL)\n\t\t\t\t{\n\t\t\t\tstrncpy(vendorapname, vendorptr +1,255);\n\t\t\t\t}\n\t\t\t}\n\t\tif(ouista == vendoroui)\n\t\t\t{\n\t\t\tvendorptr = strrchr(linein, '\\t');\n\t\t\tif(vendorptr != NULL)\n\t\t\t\t{\n\t\t\t\tstrncpy(vendorstaname, vendorptr +1,255);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nif(isasciistring(l /2, essidbuffer) == true)\n\t{\n\tfprintf(stdout, \"\\nESSID..: %s\\n\", essidbuffer);\n\t}\nelse\n\t{\n\tfprintf(stdout, \"\\nESSID..: $HEX[%s]\\n\", essidbuffer);\n\t}\n\nfprintf(stdout, \"MAC_AP.: %012llx\\n\"\n\t\t\"VENDOR.: %s\\n\"\n\t\t\"MAC_STA: %012llx\\n\"\n\t\t\"VENDOR.: %s\\n\\n\"\n\t\t, macap, vendorapname, macsta, vendorstaname);\n\nfclose(fhoui);\nreturn;\n}\n/*===========================================================================*/\nstatic void get2500info(char *ouiname, char *hash2500line)\n{\nstatic int len;\nstatic int l, l1;\nstatic FILE* fhoui;\nstatic char *vendorptr;\nstatic char *essidptr;\nstatic char *passwdptr;\n\nstatic unsigned long long int macap;\nstatic unsigned long long int macsta;\nstatic unsigned long long int ouiap;\nstatic unsigned long long int ouista;\nstatic unsigned long long int vendoroui;\n\nstatic char linein[LINEBUFFER_MAX];\nstatic uint8_t essidbuffer[72];\nstatic char vendorapname[256];\nstatic char vendorstaname[256];\n\nsscanf(&hash2500line[33], \"%12llx\", &macap);\nouiap = macap >> 24;\nsscanf(&hash2500line[46], \"%12llx\", &macsta);\nouista = macsta >> 24;\n\nessidptr = hash2500line +59;\nl = strlen(essidptr);\npasswdptr = strrchr(hash2500line, ':');\nif((passwdptr -hash2500line) > 59)\n\t{\n\tif(passwdptr != NULL)\n\t\t{\n\t\tl1 = strlen(passwdptr);\n\t\tif(l1 > 1)\n\t\t\t{\n\t\t\tl -= l1;\n\t\t\t}\n\t\t}\n\t}\nif(l > 70)\n\t{\n\tfprintf(stderr, \"wrong ESSID length %s %d\\n\", essidptr, l);\n\treturn;\n\t}\nmemset(&essidbuffer, 0, 72);\nmemcpy(&essidbuffer, essidptr, l);\n\nif ((fhoui = fopen(ouiname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"unable to open database %s\\n\", ouiname);\n\texit (EXIT_FAILURE);\n\t}\n\nstrncpy(vendorapname, \"unknown\", 8);\nstrncpy(vendorstaname, \"unknown\", 8);\n\nwhile((len = fgetline(fhoui, LINEBUFFER_MAX, linein)) != -1)\n\t{\n\tif (len < 10)\n\t\tcontinue;\n\tif(strstr(linein, \"(base 16)\") != NULL)\n\t\t{\n\t\tsscanf(linein, \"%06llx\", &vendoroui);\n\t\tif(ouiap == vendoroui)\n\t\t\t{\n\t\t\tvendorptr = strrchr(linein, '\\t');\n\t\t\tif(vendorptr != NULL)\n\t\t\t\t{\n\t\t\t\tstrncpy(vendorapname, vendorptr +1,255);\n\t\t\t\t}\n\t\t\t}\n\t\tif(ouista == vendoroui)\n\t\t\t{\n\t\t\tvendorptr = strrchr(linein, '\\t');\n\t\t\tif(vendorptr != NULL)\n\t\t\t\t{\n\t\t\t\tstrncpy(vendorstaname, vendorptr +1,255);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nfprintf(stdout, \"\\nESSID..: %s\\n\", essidbuffer);\nfprintf(stdout, \"MAC_AP.: %012llx\\n\"\n\t\t\"VENDOR.: %s\\n\"\n\t\t\"MAC_STA: %012llx\\n\"\n\t\t\"VENDOR.: %s\\n\\n\"\n\t\t, macap, vendorapname, macsta, vendorstaname);\n\nfclose(fhoui);\nreturn;\n}\n/*===========================================================================*/\nstatic void getoui(char *ouiname, unsigned long long int oui)\n{\nstatic int len;\nstatic FILE* fhoui;\nstatic char *vendorptr;\nstatic unsigned long long int vendoroui;\nstatic char linein[LINEBUFFER_MAX];\nstatic char vendorapname[256];\n#ifdef BIG_ENDIAN_HOST\nint lsb = oui & 0xf;\n#else\nint lsb = (oui >> 16) & 0xf;\n#endif\n\nif ((fhoui = fopen(ouiname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"unable to open database %s\\n\", ouiname);\n\texit (EXIT_FAILURE);\n\t}\n\nstrncpy(vendorapname, \"unknown\", 8);\nwhile((len = fgetline(fhoui, LINEBUFFER_MAX, linein)) != -1)\n\t{\n\tif (len < 10)\n\t\tcontinue;\n\n\tif(strstr(linein, \"(base 16)\") != NULL)\n\t\t{\n\t\tsscanf(linein, \"%06llx\", &vendoroui);\n\t\tif(oui == vendoroui)\n\t\t\t{\n\t\t\tvendorptr = strrchr(linein, '\\t');\n\t\t\tif(vendorptr != NULL)\n\t\t\t\t{\n\t\t\t\tstrncpy(vendorapname, vendorptr +1,255);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nfprintf(stdout, \"\\nVENDOR: %s (%s)%s\\n\\n\", vendorapname,\n        oui == 0xffffff ? \"broadcast\" : lsb & 2 ? \"LAA - likely randomized!\" : \"UAA\",\n        oui == 0xffffff ? \"\" : lsb & 1 ? \", multicast\" : \", unicast\");\n\nfclose(fhoui);\nreturn;\n}\n/*===========================================================================*/\nstatic void getvendor(char *ouiname, char *vendorstring)\n{\nstatic int len;\n\nstatic FILE* fhoui;\nstatic char *vendorptr;\nstatic unsigned long long int vendoroui;\n\nchar linein[LINEBUFFER_MAX];\n\n\nif ((fhoui = fopen(ouiname, \"r\")) == NULL)\n\t{\n\tfprintf(stderr, \"unable to open database %s\\n\", ouiname);\n\texit (EXIT_FAILURE);\n\t}\n\nwhile((len = fgetline(fhoui, LINEBUFFER_MAX, linein)) != -1)\n\t{\n\tif (len < 10)\n\t\tcontinue;\n\n\tif(strstr(linein, \"(base 16)\") != NULL)\n\t\t{\n\t\tif(strstr(linein, vendorstring) != NULL)\n\t\t\t{\n\t\t\tsscanf(linein, \"%06llx\", &vendoroui);\n\t\t\tvendorptr = strrchr(linein, '\\t');\n\t\t\tfprintf(stdout, \"%06llx%s\\n\", vendoroui, vendorptr);\n\t\t\t}\n\t\t}\n\t}\nfclose(fhoui);\nreturn;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage: %s <options>\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-d            : download %s\\n\"\n\t\"              : and save to ~/.hcxtools/oui.txt\\n\"\n\t\"              : internet connection required\\n\"\n\t\"-m <mac>      : mac (six bytes of mac addr) or \\n\"\n\t\"              : oui (fist three bytes of mac addr)\\n\"\n\t\"-p <hashline> : input PMKID and/or EAPOL hashline (hashmode 22000 or 16800)\\n\"\n\t\"-P <hashline> : input EAPOL hashline from potfile (hashcat <= 5.1.0)\\n\"\n\t\"-e <ESSID>    : input ESSID\\n\"\n\t\"-x <xdigit>   : input ESSID in hex\\n\"\n\t\"-v <vendor>   : vendor name\\n\"\n\t\"-h            : this help screen\\n\"\n\t\"\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname, ouiurl);\nexit(EXIT_SUCCESS);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstatic int auswahl;\nstatic int mode = 0;\nstatic int ret;\nstatic int l;\nstatic int p1, p2;\nstatic unsigned long long int oui = 0;\nstatic char *hashlineend;\n\nstatic uid_t uid;\nstatic struct passwd *pwd;\nstatic struct stat statinfo;\nstatic char *vendorname = NULL;\nstatic char *hexessidname = NULL;\nstatic char *essidname = NULL;\nstatic char *hash16800line = NULL;\nstatic char *hash2500line = NULL;\nstatic char *ouiname = NULL;\nstatic char confdirname[] = \".hcxtools\";\nstatic char ouinameuser[] = \".hcxtools/oui.txt\";\nstatic char ouinamesystemwide[] = \"/usr/share/ieee-data/oui.txt\";\n\nstatic char pmkidtype[] = {\"WPA*01*\" };\nstatic char eapoltype[] = {\"WPA*02*\" };\nstatic char pmkidtypeend[] = {\"***\" };\n\nwhile ((auswahl = getopt(argc, argv, \"m:v:p:P:e:x:dh\")) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase 'd':\n\t\tmode = 'd';\n\t\tbreak;\n\n\t\tcase 'm':\n\t\tl= strlen(optarg);\n\t\tif((l > 17) || (l < 6))\n\t\t\t{\n\t\t\tfprintf(stderr, \"error wrong oui size %s (need eg. 11:22:33:44:55:aa or 112233)\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tp2 = 0;\n\t\tfor(p1 = 0; p1 < l; p1++)\n\t\t\t{\n\t\t\tif(isxdigit((unsigned char)optarg[p1]))\n\t\t\t\t{\n\t\t\t\toptarg[p2] = optarg[p1];\n\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t}\n\t\toptarg[6] = 0;\n\t\tfor(p1 = 0; p1 < 6; p1++)\n\t\t\t{\n\t\t\tif(!isxdigit((unsigned char)optarg[p1]))\n\t\t\t\t{\n\t\t\t\tfprintf(stderr, \"error wrong oui %s (need eg. 11:22:33:44:55:aa or 112233)\\n\", optarg);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t}\n\t\toui = strtoull(optarg, NULL, 16);\n\t\tmode = 'm';\n\t\tbreak;\n\n\t\tcase 'p':\n\t\thash16800line = optarg;\n\t\tl = strlen(hash16800line);\n\t\tif(l < 61)\n\t\t\t{\n\t\t\tfprintf(stderr, \"error hashline too short %s\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif(memcmp(&pmkidtype, hash16800line, 7) == 0)\n\t\t\t{\n\t\t\thash16800line += 7;\n\t\t\tl -=7;\n\t\t\tif(memcmp(&pmkidtypeend, &hash16800line[l -3], 3) == 0) hash16800line[l -3] = 0;\n\t\t\t}\n\t\tif(memcmp(&eapoltype, hash16800line, 7) == 0)\n\t\t\t{\n\t\t\thash16800line += 7;\n\t\t\thashlineend = strchr(&hash16800line[59], '*');\n\t\t\tif(hashlineend != NULL) hashlineend[0] = 0;\n\t\t\t}\n\t\tif(((hash16800line[32] != ':') && (hash16800line[45] != ':') && (hash16800line[58] != ':')) && ((hash16800line[32] != '*') && (hash16800line[45] != '*') && (hash16800line[58] != '*')))\n\t\t\t{\n\t\t\tfprintf(stderr, \"error hashline wrong format %s\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tmode = 'p';\n\t\tbreak;\n\n\t\tcase 'P':\n\t\thash2500line = optarg;\n\t\tl = strlen(hash2500line);\n\t\tif(l < 61)\n\t\t\t{\n\t\t\tfprintf(stderr, \"error hashline too short %s\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tif((hash2500line[32] != ':') && (hash2500line[45] != ':') && (hash2500line[58] != ':'))\n\t\t\t{\n\t\t\tfprintf(stderr, \"error hashline wrong format %s\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\tmode = 'P';\n\t\tbreak;\n\n\t\tcase 'v':\n\t\tvendorname = optarg;\n\t\tmode = 'v';\n\t\tbreak;\n\n\t\tcase 'e':\n\t\thexessidname = optarg;\n\t\tmode = 'e';\n\t\tbreak;\n\n\t\tcase 'x':\n\t\tessidname = optarg;\n\t\tmode = 'x';\n\t\tbreak;\n\n\t\tdefault:\n\t\tusage(basename(argv[0]));\n\t\t}\n\t}\n\nif(argc > 3)\n\t{\n\tfprintf(stderr, \"only one argument allowed\\n\");\n\texit(EXIT_FAILURE);\n\t}\nuid = getuid();\npwd = getpwuid(uid);\nif(pwd == NULL)\n\t{\n\tfprintf(stderr, \"failed to get home dir\\n\");\n\texit(EXIT_FAILURE);\n\t}\nret = chdir(pwd->pw_dir);\nif(ret == -1)\n\t{\n\tfprintf(stderr, \"failed to change dir\\n\");\n\t}\nif(stat(confdirname, &statinfo) == -1)\n\t{\n\tif(mkdir(confdirname,0755) == -1)\n\t\t{\n\t\tfprintf(stderr, \"failed to create conf dir\\n\");\n\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\nif(mode == 'd')\n\t{\n\tdownloadoui(ouinameuser);\n\treturn EXIT_SUCCESS;\n\t}\n\nif(stat(ouinamesystemwide, &statinfo) == 0)\n\t{\n\touiname = ouinamesystemwide;\n\t}\nif(stat(ouinameuser, &statinfo) == 0)\n\t{\n\touiname = ouinameuser;\n\t}\nif(ouiname == NULL)\n\t{\n\tfprintf(stderr, \"failed read oui.txt\\n\"\n\t\t\t\"use download option -d to download it\\n\"\n\t\t\t\"or download file %s\\n\"\n\t\t\t\"and save it to ~/.hcxtools/oui.txt\\n\", ouiurl);\n\texit(EXIT_FAILURE);\n\t}\nif(stat(ouiname, &statinfo) < 0)\n\t{\n\tfprintf(stderr, \"failed read oui.txt\\n\"\n\t\t\t\"use download option -d to download it\\n\"\n\t\t\t\"or download file %s\\n\"\n\t\t\t\"and save it to ~/.hcxtools/oui.txt\\n\", ouiurl);\n\texit(EXIT_FAILURE);\n\t}\nif(mode == 'm')\n\t{\n\tgetoui(ouiname, oui);\n\t}\nelse if(mode == 'p')\n\t{\n\tget16800info(ouiname, hash16800line);\n\t}\nelse if(mode == 'P')\n\t{\n\tget2500info(ouiname, hash2500line);\n\t}\n\nelse if(mode == 'v')\n\t{\n\tgetvendor(ouiname, vendorname);\n\t}\n\nelse if(mode == 'e')\n\t{\n\tgethexessidinfo(hexessidname);\n\t}\n\nelse if(mode == 'x')\n\t{\n\tgetessidinfo(essidname);\n\t}\n\nelse\n\t{\n\tusage(basename(argv[0]));\n\treturn EXIT_FAILURE;\n\t}\n\nreturn EXIT_SUCCESS;\n}\n"
        },
        {
          "name": "wlancap2wpasec.c",
          "type": "blob",
          "size": 7.283203125,
          "content": "#define _GNU_SOURCE\n#include <libgen.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <curl/curl.h>\n\n/*===========================================================================*/\n/* globale Konstante */\n\nstruct memory\n{\nchar *response;\nsize_t size;\n};\n\nstatic long int uploadcountok;\nstatic long int uploadcountfailed;\nstatic const char *wpasecurl = \"https://wpa-sec.stanev.org\";\nstatic bool removeflag = false;\nstatic struct memory *curlmem;\n/*===========================================================================*/\nstatic int testwpasec(long int timeout)\n{\nCURL *curl;\nCURLcode res = CURLE_OK;\n\nfprintf(stdout, \"connecting to %s\\n\", wpasecurl);\ncurl_global_init(CURL_GLOBAL_ALL);\ncurl = curl_easy_init();\nif(curl)\n\t{\n\tcurl_easy_setopt(curl, CURLOPT_URL, wpasecurl);\n\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);\n\tcurl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n\tres = curl_easy_perform(curl);\n\tif(res != CURLE_OK)\n\t\tfprintf(stderr, \"couldn't connect to %s: %s\\n\", wpasecurl, curl_easy_strerror(res));\n\tcurl_easy_cleanup(curl);\n\t}\ncurl_global_cleanup();\nreturn res;\n}\n/*===========================================================================*/\nstatic size_t cb(void *data, size_t size, size_t nmemb, void *userp)\n{\nchar *ptr;\nsize_t realsize = size *nmemb;\ncurlmem = (struct memory*)userp;\n \nptr = (char*)realloc(curlmem->response, curlmem->size +realsize +1);\nif(ptr == NULL) return 0;\ncurlmem->response = ptr;\nmemcpy(&(curlmem->response[curlmem->size]), data, realsize);\ncurlmem->size += realsize;\ncurlmem->response[curlmem->size] = 0;\nreturn realsize;\n}\n/*===========================================================================*/\nstatic bool sendcap2wpasec(char *sendcapname, long int timeout, char *keyheader, char *emailheader)\n{\nCURL *curl;\nCURLcode res;\ncurl_mime *mime;\ncurl_mimepart *part;\nbool uploadflag = true;\nint ret;\n\nstruct curl_slist *headerlist=NULL;\nstatic const char buf[] = \"Expect:\";\nstruct memory chunk;\n\nfprintf(stdout, \"uploading %s to %s\\n\", sendcapname, wpasecurl);\nmemset(&chunk, 0, sizeof(chunk));\ncurl_global_init(CURL_GLOBAL_ALL);\n\ncurl = curl_easy_init();\nmime = curl_mime_init(curl);\npart = curl_mime_addpart(mime);\n\ncurl_mime_filedata(part, sendcapname);\ncurl_mime_type(part, \"file\");\ncurl_mime_name(part, \"file\");\n\nif(emailheader != NULL)\n\t{\n\tcurl_mime_data(part, emailheader, CURL_ZERO_TERMINATED);\n\tcurl_mime_name(part, \"email\");\n\t}\n\nheaderlist = curl_slist_append(headerlist, buf);\nif(curl)\n\t{\n\tcurl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);\n\tcurl_easy_setopt(curl, CURLOPT_URL, wpasecurl);\n\tcurl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, timeout);\n\tcurl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);\n\tif(keyheader) curl_easy_setopt(curl, CURLOPT_COOKIE, keyheader);\n\tres = curl_easy_perform(curl);\n\tif(res == CURLE_OK)\n\t\t{\n\t\tif(curlmem->response != NULL)\n\t\t\t{\n\t\t\tfprintf(stdout, \"\\n%s\\n\\n\", curlmem->response);\n\t\t\tif(removeflag == true)\n\t\t\t\t{\n\t\t\t\tret = remove(sendcapname);\n\t\t\t\tif(ret != 0) fprintf(stdout, \"couldn't remove %s\\n\", sendcapname);\n\t\t\t\t}\n\t\t\tfree(curlmem->response);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tfprintf(stdout, \"upload not confirmed by server\\n\");\n\t\t\tuploadflag = false;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tfprintf(stderr, \"\\n\\x1B[31mupload to %s failed: %s\\x1B[0m\\n\\n\", wpasecurl, curl_easy_strerror(res));\n\t\tuploadflag = false;\n\t\t}\n\tcurl_easy_cleanup(curl);\n\tcurl_mime_free(mime);\n\tcurl_slist_free_all(headerlist);\n\t}\nreturn uploadflag;\n}\n/*===========================================================================*/\n__attribute__ ((noreturn))\nvoid version(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\", eigenname, VERSION_TAG, VERSION_YEAR);\nexit(EXIT_SUCCESS);\n}\n/*---------------------------------------------------------------------------*/\n__attribute__ ((noreturn))\nstatic void usage(char *eigenname)\n{\nfprintf(stdout, \"%s %s (C) %s ZeroBeat\\n\"\n\t\"usage: %s <options>  [input.pcapng] [input.pcap] [input.cap] [input.pcapng.gz]...\\n\"\n\t\"       %s <options> *.pcapng\\n\"\n\t\"       %s <options> *.gz\\n\"\n\t\"       %s <options> *.*\\n\"\n\t\"\\n\"\n\t\"options:\\n\"\n\t\"-k <key>           : wpa-sec user key\\n\"\n\t\"-u <url>           : set user defined URL\\n\"\n\t\"                     default = %s\\n\"\n\t\"-t <seconds>       : set connection timeout\\n\"\n\t\"                     default = 30 seconds\\n\"\n\t\"-e <email address> : set email address, if required\\n\"\n\t\"-R                 : remove cap if upload was successful\\n\"\n\t\"-h                 : this help\\n\"\n\t\"-v                 : show version\\n\"\n\t\"\\n\"\n\t\"Do not merge different cap files to a single cap file.\\n\"\n\t\"This will lead to unexpected behaviour on ESSID changes\\n\"\n\t\"or different link layer types.\\n\"\n\t\"To ‎remove unnecessary packets, run tshark:\\n\"\n\t\"tshark -r input.cap -R \\\"(wlan.fc.type_subtype == 0x00 || wlan.fc.type_subtype == 0x02 || wlan.fc.type_subtype == 0x04 || wlan.fc.type_subtype == 0x05 || wlan.fc.type_subtype == 0x08 || eapol)\\\" -2 -F pcapng -w output.pcapng\\n\"\n\t\"To reduce the size of the cap file, compress it with gzip:\\n\"\n\t\"gzip capture.pcapng\\n\"\n\t\"\\n\"\n\t\"\\n\", eigenname, VERSION_TAG, VERSION_YEAR, eigenname, eigenname, eigenname, eigenname, wpasecurl);\nexit(EXIT_FAILURE);\n}\n/*===========================================================================*/\nint main(int argc, char *argv[])\n{\nstruct stat statinfo;\nint auswahl;\nint index;\nchar keyheader[4+32+1+2] = {0};\nchar *emailaddr = NULL;\nlong int timeout = 30;\nuploadcountok = 0;\nuploadcountfailed = 0;\n\nsetbuf(stdout, NULL);\nwhile ((auswahl = getopt(argc, argv, \"k:u:t:e:Rhv\")) != -1)\n\t{\n\tswitch (auswahl)\n\t\t{\n\t\tcase 'k':\n\t\tif((strlen(optarg) == 32) && (optarg[strspn(optarg, \"0123456789abcdefABCDEF\")] == 0))\n\t\t\t{\n\t\t\tsnprintf(keyheader, sizeof(keyheader), \"key=%s\", optarg);\n\t\t\tfprintf(stdout, \"\\x1B[32muser key set\\x1B[0m\\n\");\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tfprintf(stdout, \"wrong user key value\\n\");\n\t\t\t}\n\t\tbreak;\n\n\t\tcase 'u':\n\t\twpasecurl = optarg;\n\t\tbreak;\n\n\t\tcase 't':\n\t\ttimeout = strtol(optarg, NULL, 10);\n\t\tif(timeout < 1)\n\t\t\t{\n\t\t\tfprintf(stdout, \"wrong connection timeout\\nsetting connection timeout to 30 seconds\\n\");\n\t\t\ttimeout = 30;\n\t\t\t}\n\t\tbreak;\n\n\t\tcase 'e':\n\t\temailaddr = optarg;\n\t\tif(strlen(emailaddr) > 120)\n\t\t\t{\n\t\t\tfprintf(stderr, \"email address is too long\\n\");\n\t\t\texit (EXIT_FAILURE);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase 'R':\n\t\tremoveflag = true;\n\t\tbreak;\n\n\t\tcase 'v':\n\t\tversion(basename(argv[0]));\n\t\tbreak;\n\n\t\tdefault:\n\t\tusage(basename(argv[0]));\n\t\t}\n\t}\n\nif(testwpasec(timeout) != CURLE_OK) return EXIT_SUCCESS;\n\nfor(index = optind; index < argc; index++)\n\t{\n\tif(stat(argv[index], &statinfo) == 0)\n\t\t{\n\t\tif(sendcap2wpasec(argv[index], timeout, keyheader, emailaddr) == false)\n\t\t\t{\n\t\t\tif(sendcap2wpasec(argv[index], 60, keyheader, emailaddr) == true) uploadcountok++;\n\t\t\telse uploadcountfailed++;\n\t\t\t}\n\t\telse uploadcountok++;\n\t\t}\n\telse fprintf(stdout, \"file not found: %s\\n\", argv[index]);\n\t}\n\nif(uploadcountok == 1) fprintf(stdout, \"\\x1B[32m%ld cap uploaded to %s\\x1B[0m\\n\", uploadcountok, wpasecurl);\nif(uploadcountok > 1) fprintf(stdout, \"\\x1B[32m%ld caps uploaded to %s\\x1B[0m\\n\", uploadcountok, wpasecurl);\nif(uploadcountfailed == 1) fprintf(stdout, \"\\x1B[31m%ld cap failed to upload to %s\\x1B[0m\\n\", uploadcountfailed, wpasecurl);\nif(uploadcountfailed > 1) fprintf(stdout, \"\\x1B[31m%ld caps failed to upload to %s\\x1B[0m\\n\", uploadcountfailed, wpasecurl);\nreturn EXIT_SUCCESS;\n}\n"
        }
      ]
    }
  ]
}