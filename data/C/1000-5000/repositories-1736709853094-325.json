{
  "metadata": {
    "timestamp": 1736709853094,
    "page": 325,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Legrandin/pycryptodome",
      "stars": 2903,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7490234375,
          "content": "# Ignore these files:\nMANIFEST\n\n# Backup files\n*~\n*.bak\n\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# C extensions\n*.so\n\n# Distribution / packaging\n.Python\nenv/\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# PyInstaller\n#  Usually these files are written by a python script from a template\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\n*.manifest\n*.spec\n\n# Installer logs\npip-log.txt\npip-delete-this-directory.txt\n\n# Unit test / coverage reports\nhtmlcov/\n.tox/\n.coverage\n.coverage.*\n.cache\nnosetests.xml\ncoverage.xml\n*,cover\n\n# Translations\n*.mo\n*.pot\n\n# Django stuff:\n*.log\n\n# Sphinx documentation\n/Doc/apidoc/\n/Doc/_build\n\n# PyBuilder\ntarget/\n\n"
        },
        {
          "name": ".readthedocs.yaml",
          "type": "blob",
          "size": 0.158203125,
          "content": "version: 2\npython:\n  install:\n    - requirements: Doc/requirements.txt\nbuild:\n  os: ubuntu-22.04\n  tools:\n    python: \"3.11\"\nsphinx:\n  configuration: Doc/conf.py\n"
        },
        {
          "name": "AUTHORS.rst",
          "type": "blob",
          "size": 0.74609375,
          "content": "Simon Arneaud\nNevins Bartolomeo\nThorsten E. Behrens\nTim Berners-Lee\nFrédéric Bertolus\nIan Bicking\nJoris Bontje\nAntoon Bosselaers\nAndrea Bottoni\nJean-Paul Calderone\nSergey Chernov\nGeremy Condra\nJan Dittberner\nAndrew Eland\nPhilippe Frycia\nPeter Gutmann\nHirendra Hindocha\nNikhil Jhingan\nSebastian Kayser\nRyan Kelly\nAndrew M. Kuchling\nPiers Lauder\nLegrandin\nM.-A. Lemburg\nWim Lewis\nDarsey C. Litzenberger\nRichard Mitchell\nMark Moraes\nLim Chee Siang\nBryan Olson\nWallace Owen\nColin Plumb\nRobey Pointer\nLorenz Quack\nSebastian Ramacher\nJeethu Rao\nJames P. Rutledge\nMatt Schreiner\nPeter Simmons\nJanne Snabb\nTom St. Denis\nAnders Sundman\nPaul Swartz\nFabrizio Tarizzo\nKevin M. Turner\nBarry A. Warsaw\nEric Young\nHannes van Niekerk\nStefan Seering\nKoki Takahashi\nLauro de Lima\n"
        },
        {
          "name": "Changelog.rst",
          "type": "blob",
          "size": 33.544921875,
          "content": "Changelog\n=========\n\n3.21.0 (30 September 2024)\n++++++++++++++++++++++++++\n\nNew features\n---------------\n* By setting the PYCRYPTODOME_DISABLE_GMP environment variable,\n  the GMP library will not be used even if detected.\n* Add support for Curve25519 / X25519.\n* Add support for Curve448 / X448.\n* Add attribute ``curve`` to EccPoint and EccXPoint classes,\n  with the canonical name of the curve.\n* GH#781: the label for the SP800_108_Counter KDF may now\n  contain zero bytes. Thanks to Julien Rische.\n* GH#814: RSA keys for PSS can be imported.\n\nResolved issues\n---------------\n* GH#810: fixed negation of Ed25519 points.\n* GH#819: accept an RFC5916 ECPrivateKey even if it doesn't\n  contain any of the optional elements\n  (parameters [0] and publicKey[1]).\n\nOther changes\n-------------\n* Remove support for Python 3.5.\n\n3.20.0 (9 January 2024)\n++++++++++++++++++++++++++\n\nNew features\n---------------\n* Added support for TurboSHAKE128 and TurboSHAKE256.\n* Added method ``Crypto.Hash.new()`` to generate a hash\n  object given a hash name.\n* Added support for AES-GCM encryption of PBES2 and PKCS#8\n  containers.\n* Added support for SHA-2 and SHA-3 algorithms in PBKDF2\n  when creating PBES2 and PKCS#8 containers.\n* Export of RSA keys accepts the ``prot_params`` dictionary\n  as parameter to control the number of iterations for PBKDF2\n  and scrypt.\n* C unit tests also run on non-x86 architectures.\n\nResolved issues\n---------------\n* GH#787: Fixed autodetect logic for GCC 14 in combination with LTO.\n\n3.19.1 (28 December 2023)\n++++++++++++++++++++++++++\n\nResolved issues\n---------------\n* Fixed a side-channel leakage with OAEP decryption that could be\n  exploited to carry out a Manger attack (CVE-2023-52323). Thanks to Hubert Kario.\n\n3.19.0 (16 September 2023)\n++++++++++++++++++++++++++\n\nNew features\n---------------\n* The ``update()`` methods of TupleHash128 and TupleHash256 objects\n  can now hash multiple items (byte strings) at once.\n  Thanks to Sylvain Pelissier.\n* Added support for ECDH, with ``Crypto.Protocol.DH``.\n\nResolved issues\n---------------\n* GH#754: due to a bug in ``cffi``, do not use it on Windows with Python 3.12+.\n\n3.18.0 (18 May 2023)\n++++++++++++++++++++++++++\n\nNew features\n---------------\n* Added support for DER BOOLEAN encodings.\n* The library now compiles on Windows ARM64. Thanks to Niyas Sait.\n\nResolved issues\n---------------\n* GH#722: ``nonce`` attribute was not correctly set for XChaCha20_Poly1305 ciphers. Thanks to Liam Haber.\n* GH#728: Workaround for a possible x86 emulator bug in Windows for ARM64.\n* GH#739: OID encoding for arc 2 didn't accept children larger than 39. Thanks to James.\n* Correctly check that the scalar matches the point when importing an ECC private key.\n\n3.17.0 (29 January 2023)\n++++++++++++++++++++++++++\n\nNew features\n---------------\n* Added support for the Counter Mode KDF defined in SP 800-108 Rev 1.\n* Reduce the minimum tag length for the EAX cipher to 2 bytes.\n* An RSA object has 4 new properties for the CRT coefficients:\n  ``dp``, ``dq``, ``invq`` and ``invq`` (``invp`` is the same value\n  as the existing ``u``).\n\nResolved issues\n---------------\n* GH#526: improved typing for ``RSA.construct``.\n* GH#534: reduced memory consumption when using a large number\n  of cipher objects.\n* GH#598: fixed missing error handling for ``Util.number.inverse``.\n* GH#629: improved typing for ``AES.new`` and the various\n  mode-specific types it returns. Thanks to Greg Werbin.\n* GH#653: added workaround for an alleged GCC compiler bug\n  that affected Ed25519 code compiled for AVX2.\n* GH#658: attribute ``curve`` of an ECC key was not always\n  the preferred curve name, as it used to be in v3.15.0\n  (independently of the curve name specified when generating\n  the key).\n* GH#637: fixed typing for legacy modules ``PKCS1_v1_5`` and ``PKCS1_PSS``,\n  as their ``verify()`` returned a boolean.\n* GH#664: with OCB mode, nonces of maximum length (15 bytes)\n  were actually used as 14 bytes nonces.\n  After this fix, data that was encrypted in past using the\n  (default) nonce length of 15 bytes can still be decrypted\n  by reducing the nonce to its first 14 bytes.\n* GH#705: improved typing for ``nonce``, ``iv``, and ``IV`` parameters\n  of cipher objects.\n\nOther changes\n-------------\n* Build PyPy wheels only for versions 3.8 and 3.9, and not for 3.7 anymore.\n\n3.16.0 (26 November 2022)\n++++++++++++++++++++++++++\n\nNew features\n------------\n* Build wheels for musl Linux. Thanks to Ben Raz.\n\nResolved issues\n---------------\n* GH#639: ARC4 now also works with 'keys' as short as 8 bits.\n* GH#669: fix segfaults when running in a manylinux2010 i686 image.\n\n3.15.0 (22 June 2022)\n++++++++++++++++++++++++++\n\nNew features\n------------\n* Add support for curves Ed25519 and Ed448, including export and import of keys.\n* Add support for EdDSA signatures.\n* Add support for Asymmetric Key Packages (RFC5958) to import private keys.\n\nResolved issues\n---------------\n* GH#620: for ``Crypto.Util.number.getPrime`` , do not sequentially\n  scan numbers searching for a prime.\n\n3.14.1 (5 February 2022)\n++++++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#595: Fixed memory leak for GMP integers.\n  Thanks to Witalij Siebert and Pablo Quílez.\n\n3.14.0 (30 January 2022)\n++++++++++++++++++++++++++\n\nNew features\n------------\n* Add support for curve NIST P-192.\n\n3.13.0 (23 January 2022)\n++++++++++++++++++++++++++\n\nNew features\n------------\n* Add support for curve NIST P-224.\n\nResolved issues\n---------------\n* GH#590: Fixed typing info for ``Crypto.PublicKey.ECC``.\n\nOther changes\n-------------\n* Relaxed ECDSA requirements for FIPS 186 signatures and accept any SHA-2 or SHA-3 hash.\n  ``sign()`` and ``verify()`` will be performed even if the hash is stronger than the ECC key.\n\n3.12.0 (4 December 2021)\n++++++++++++++++++++++++++\n\nNew features\n------------\n* ECC keys in the SEC1 format can be exported and imported.\n* Add support for KMAC128, KMAC256, TupleHash128, and TupleHash256 (NIST SP-800 185).\n* Add support for KangarooTwelve.\n\nResolved issues\n---------------\n* GH#563: An asymmetric key could not be imported as a ``memoryview``.\n* GH#566: cSHAKE128/256 generated a wrong output for customization strings\n  longer than 255 bytes.\n* GH#582: CBC decryption generated the wrong plaintext when the input and the output were the same buffer.\n  Thanks to Michael K. Ashburn.\n\n3.11.0 (8 October 2021)\n++++++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#512: Especially for very small bit sizes, ``Crypto.Util.number.getPrime()`` was\n  occasionally generating primes larger than given the bit size. Thanks to Koki Takahashi.\n* GH#552: Correct typing annotations for ``PKCS115_Cipher.decrypt()``.\n* GH#555: ``decrypt()`` method of a PKCS#1v1.5 cipher returned a ``bytearray`` instead of ``bytes``.\n* GH#557: External DSA domain parameters were accepted even when the modulus (``p``) was not prime.\n  This affected ``Crypto.PublicKey.DSA.generate()`` and ``Crypto.PublicKey.DSA.construct()``.\n  Thanks to Koki Takahashi.\n\nNew features\n------------\n* Added cSHAKE128 and cSHAKE256 (of SHA-3 family). Thanks to Michael Schaffner.\n* GH#558: The flag RTLD_DEEPBIND passed to ``dlopen()`` is not well supported by\n  `address sanitizers <https://github.com/google/sanitizers/issues/611>`_.\n  It is now possible to set the environment variable ``PYCRYPTDOME_DISABLE_DEEPBIND``\n  to drop that flag and allow security testing.\n\n3.10.4 (25 September 2021)\n++++++++++++++++++++++++++\n\nResolved issues\n---------------\n* Output of ``Crypto.Util.number.long_to_bytes()`` was not always a multiple of ``blocksize``.\n\n3.10.3 (22 September 2021)\n++++++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#376: Fixed symbol conflict between different versions of ``libgmp``.\n* GH#481: Improved robustness of PKCS#1v1.5 decryption against timing attacks.\n* GH#506 and GH#509: Fixed segmentation faults on Apple M1 and other Aarch64 SoCs,\n  when the GMP library was accessed via ``ctypes``. Do not use GMP's own sscanf\n  and snprintf routines: instead, use simpler conversion routines.\n* GH#510: Workaround for ``cffi`` calling ``ctypes.util.find_library()``, which\n  invokes ``gcc`` and ``ld`` on Linux, considerably slowing down all imports.\n  On certain configurations, that may also leave temporary files behind.\n* GH#517: Fix RSAES-OAEP, as it didn't always fail when zero padding was incorrect.\n\nNew features\n------------\n* Added support for SHA-3 hash functions to HMAC.\n\nOther changes\n-------------\n* The Windows wheels of Python 2.7 now require the VS2015 runtime to be installed in the system,\n  because Microsoft stopped distributing the VS2008 compiler in April 2021.\n  VS2008 was used to compile the Python 2.7 extensions.\n\n3.10.1 (9 February 2021)\n++++++++++++++++++++++++\n\nOther changes\n-------------\n* Python 3 wheels use ``abi3`` ABI tag.\n* Remove Appveyor CI.\n\n3.10.0 (6 February 2021)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n* Fixed a potential memory leak when initializing block ciphers.\n* GH#466: ``Crypto.Math.miller_rabin_test()`` was still using the system random\n  source and not the one provided as parameter.\n* GH#469: RSA objects have the method ``public_key()`` like ECC objects.\n  The old method ``publickey()`` is still available for backward compatibility.\n* GH#476: ``Crypto.Util.Padding.unpad()`` was raising an incorrect exception\n  in case of zero-length inputs. Thanks to Captainowie.\n* GH#491: better exception message when ``Counter.new()`` is called with an integer\n  ``initial_value`` than doesn't fit into ``nbits`` bits.\n* GH#496: added missing ``block_size`` member for ECB cipher objects. Thanks to willem.\n* GH#500: ``nonce`` member of an XChaCha20 cipher object was not matching the original nonce.\n  Thanks to Charles Machalow.\n\nOther changes\n-------------\n* The bulk of the test vectors have been moved to the separate\n  package ``pycryptodome-test-vectors``. As result, packages ``pycryptodome`` and\n  ``pycryptodomex`` become significantly smaller (from 14MB to 3MB).\n* Moved CI tests and build service from Travis CI to GitHub Actions.\n\nBreaks in compatibility\n-----------------------\n* Drop support for Python 2.6 and 3.4.\n\n3.9.9 (2 November 2020)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#435: Fixed ``Crypto.Util.number.size`` for negative numbers.\n\nNew features\n------------\n* Build Python 3.9 wheels on Windows.\n\n3.9.8 (23 June 2020)\n++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#426: The Shamir's secret sharing implementation is not actually compatible with ``ssss``.\n  Added an optional parameter to enable interoperability.\n* GH#427: Skip altogether loading of ``gmp.dll`` on Windows.\n* GH#420: Fix incorrect CFB decryption when the input and the output are the same buffer.\n\nNew features\n------------\n* Speed up Shamir's secret sharing routines. Thanks to ncarve.\n\n3.9.7 (20 February 2020)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#381: Make notarization possible again on OS X when using wheels.\n  Thanks to Colin Atkinson.\n\n3.9.6 (2 February 2020)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n* Fix building of wheels for OS X by explicitly setting `sysroot` location.\n\n3.9.5 (1 February 2020)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n* RSA OAEP decryption was not verifying that all ``PS`` bytes are zero.\n* GH#372: fixed memory leak for operations that use memoryviews when `cffi` is not installed.\n* Fixed wrong ASN.1 OID for HMAC-SHA512 in PBE2.\n\nNew features\n------------\n* Updated Wycheproof test vectors to version 0.8r12.\n\n3.9.4 (18 November 2019)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#341: Prevent ``key_to_english`` from creating invalid data when fed with\n  keys of length not multiple of 8. Thanks to vstoykovbg.\n* GH#347: Fix blocking RSA signing/decryption when key has very small factor.\n  Thanks to Martijn Pieters.\n\n3.9.3 (12 November 2019)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n* GH#308: Align stack of functions using SSE2 intrinsics to avoid crashes,\n  when compiled with gcc on 32-bit x86 platforms.\n\n3.9.2 (10 November 2019)\n++++++++++++++++++++++++\n\nNew features\n------------\n* Add Python 3.8 wheels for Mac.\n\nResolved issues\n---------------\n* GH#308: Avoid allocating arrays of ``__m128i`` on the stack, to cope with buggy compilers.\n* GH#322: Remove blanket ``-O3`` optimization for gcc and clang, to cope with buggy compilers.\n* GH#337: Fix typing stubs for signatures.\n* GH#338: Deal with gcc installations that don't have ``x86intrin.h``.\n\n3.9.1 (1 November 2019)\n++++++++++++++++++++++++\n\nNew features\n------------\n* Add Python 3.8 wheels for Linux and Windows.\n\nResolved issues\n---------------\n\n* GH#328: minor speed-up when importing RSA.\n\n3.9.0 (27 August 2019)\n+++++++++++++++++++++++\n\nNew features\n------------\n\n* Add support for loading PEM files encrypted with AES256-CBC.\n* Add support for XChaCha20 and XChaCha20-Poly1305 ciphers.\n* Add support for bcrypt key derivation function (``Crypto.Protocol.KDF.bcrypt``).\n* Add support for left multiplication of an EC point by a scalar.\n* Add support for importing ECC and RSA keys in the new OpenSSH format.\n\nResolved issues\n---------------\n\n* GH#312: it was not possible to invert an EC point anymore.\n* GH#316: fix printing of DSA keys.\n* GH#317: ``DSA.generate()`` was not always using the ``randfunc`` input.\n* GH#285: the MD2 hash had block size of 64 bytes instead of 16; as result the HMAC construction gave incorrect results.\n\n3.8.2 (30 May 2019)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#291: fix strict aliasing problem, emerged with GCC 9.1.\n\n3.8.1 (4 April 2019)\n+++++++++++++++++++++++\n\nNew features\n------------\n\n* Add support for loading PEM files encrypted with AES192-CBC and AES256-GCM.\n* When importing ECC keys in PEM format, ignore the redundant EC PARAMS section that was included by certain openssl commands.\n\nResolved issues\n---------------\n\n* ``repr()`` did not work for ``ECC.EccKey`` objects.\n* Fix installation in development mode (``setup install develop`` or ``pip install -e .``).\n* Minimal length for Blowfish cipher is 32 bits, not 40 bits.\n* Various updates to docs.\n\n3.8.0 (23 March 2019)\n+++++++++++++++++++++++\n\nNew features\n------------\n\n* Speed-up ECC performance. ECDSA is 33 times faster on the NIST P-256 curve.\n* Added support for NIST P-384 and P-521 curves.\n* ``EccKey`` has new methods ``size_in_bits()`` and ``size_in_bytes()``.\n* Support HMAC-SHA224, HMAC-SHA256, HMAC-SHA384, and HMAC-SHA512 in PBE2/PBKDF2.\n\nResolved issues\n---------------\n\n* DER objects were not rejected if their length field had a leading zero.\n* Allow legacy RC2 ciphers to have 40-bit keys.\n* ASN.1 Object IDs did not allow the value 0 in the path.\n\nBreaks in compatibility\n-----------------------\n\n* ``point_at_infinity()`` becomes an instance method for ``Crypto.PublicKey.ECC.EccKey``, from a static one.\n\n3.7.3 (19 January 2019)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#258: False positive on PSS signatures when externally provided salt is too long.\n* Include type stub files for ``Crypto.IO`` and ``Crypto.Util``.\n\n3.7.2 (26 November 2018)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#242: Fixed compilation problem on ARM platforms.\n\n3.7.1 (25 November 2018)\n++++++++++++++++++++++++\n\nNew features\n------------\n\n* Added type stubs to enable static type checking with mypy. Thanks to Michael Nix.\n* New ``update_after_digest`` flag for CMAC.\n\nResolved issues\n---------------\n\n* GH#232: Fixed problem with gcc 4.x when compiling ``ghash_clmul.c``.\n* GH#238: Incorrect digest value produced by CMAC after cloning the object.\n* Method ``update()`` of an EAX cipher object was returning the underlying CMAC object,\n  instead of the EAX object itself.\n* Method ``update()`` of a CMAC object was not throwing an exception after the digest\n  was computed (with ``digest()`` or ``verify()``).\n\n3.7.0 (27 October 2018)\n+++++++++++++++++++++++\n\nNew features\n------------\n\n* Added support for Poly1305 MAC (with AES and ChaCha20 ciphers for key derivation).\n* Added support for ChaCha20-Poly1305 AEAD cipher.\n* New parameter ``output`` for ``Crypto.Util.strxor.strxor``, ``Crypto.Util.strxor.strxor_c``,\n  ``encrypt`` and ``decrypt`` methods in symmetric ciphers (``Crypto.Cipher`` package).\n  ``output`` is a pre-allocated buffer (a ``bytearray`` or a writeable ``memoryview``)\n  where the result must be stored.\n  This requires less memory for very large payloads; it is also more efficient when\n  encrypting (or decrypting) several small payloads.\n\nResolved issues\n---------------\n\n* GH#266: AES-GCM hangs when processing more than 4GB at a time on x86 with PCLMULQDQ instruction.\n\nBreaks in compatibility\n-----------------------\n\n* Drop support for Python 3.3.\n* Remove ``Crypto.Util.py3compat.unhexlify`` and ``Crypto.Util.py3compat.hexlify``.\n* With the old Python 2.6, use only ``ctypes`` (and not ``cffi``) to interface to native code.\n\n3.6.6 (17 August 2018)\n++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#198: Fix vulnerability on AESNI ECB with payloads smaller than 16 bytes (CVE-2018-15560).\n\n3.6.5 (12 August 2018)\n++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#187: Fixed incorrect AES encryption/decryption with AES acceleration on x86\n  due to gcc's optimization and strict aliasing rules.\n* GH#188: More prime number candidates than necessary where discarded as composite\n  due to the limited way D values were searched in the Lucas test.\n* Fixed ResouceWarnings and DeprecationWarnings.\n* Workaround for Python 3.7.0 bug on Windows (https://bugs.python.org/issue34108).\n\n3.6.4 (10 July 2018)\n+++++++++++++++++++++\n\nNew features\n------------\n\n* Build Python 3.7 wheels on Linux, Windows and Mac.\n\nResolved issues\n---------------\n\n* GH#178: Rename ``_cpuid`` module to make upgrades more robust.\n* More meaningful exceptions in case of mismatch in IV length (CBC/OFB/CFB modes).\n* Fix compilation issues on Solaris 10/11.\n\n3.6.3 (21 June 2018)\n+++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#175: Fixed incorrect results for CTR encryption/decryption with more than 8 blocks.\n\n3.6.2 (19 June 2018)\n+++++++++++++++++++++\n\nNew features\n------------\n* ChaCha20 accepts 96 bit nonces (in addition to 64 bit nonces)\n  as defined in RFC7539.\n* Accelerate AES-GCM on x86 using PCLMULQDQ instruction.\n* Accelerate AES-ECB and AES-CTR on x86 by pipelining AESNI instructions.\n* As result of the two improvements above, on x86 (Broadwell):\n\n  - AES-ECB and AES-CTR are 3x faster\n  - AES-GCM is 9x faster\n\nResolved issues\n---------------\n\n* On Windows, MPIR library was stilled pulled in if renamed to ``gmp.dll``.\n\nBreaks in compatibility\n-----------------------\n\n* In ``Crypto.Util.number``, functions ``floor_div`` and ``exact_div``\n  have been removed. Also, ``ceil_div`` is limited to non-negative terms only.\n\n3.6.1 (15 April 2018)\n+++++++++++++++++++++\n\nNew features\n------------\n* Added Google Wycheproof tests (https://github.com/google/wycheproof)\n  for RSA, DSA, ECDSA, GCM, SIV, EAX, CMAC.\n* New parameter ``mac_len`` (length of MAC tag) for CMAC.\n\nResolved issues\n---------------\n\n* In certain circumstances (at counter wrapping, which happens on average after\n  32 GB) AES GCM produced wrong ciphertexts.\n* Method ``encrypt()`` of AES SIV cipher could be still called,\n  whereas only ``encrypt_and_digest()`` is allowed.\n\n3.6.0 (8 April 2018)\n++++++++++++++++++++\n\nNew features\n------------\n* Introduced ``export_key`` and deprecated ``exportKey`` for DSA and RSA key\n  objects.\n* Ciphers and hash functions accept ``memoryview`` objects in input.\n* Added support for SHA-512/224 and SHA-512/256.\n\nResolved issues\n---------------\n\n* Reintroduced ``Crypto.__version__`` variable as in PyCrypto.\n* Fixed compilation problem with MinGW.\n\n3.5.1 (8 March 2018)\n++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#142. Fix mismatch with declaration and definition of addmul128.\n\n3.5.0 (7 March 2018)\n++++++++++++++++++++\n\nNew features\n------------\n* Import and export of ECC curves in compressed form.\n* The initial counter for a cipher in CTR mode can be a byte string\n  (in addition to an integer).\n* Faster PBKDF2 for HMAC-based PRFs (at least 20x for short passwords,\n  more for longer passwords). Thanks to Christian Heimes for pointing\n  out the implementation was under-optimized.\n* The salt for PBKDF2 can be either a string or bytes (GH#67).\n* Ciphers and hash functions accept data as `bytearray`, not just\n  binary strings.\n* The old SHA-1 and MD5 hash functions are available even when Python's\n  own `hashlib` does not include them.\n\nResolved issues\n---------------\n\n* Without libgmp, modular exponentiation (since v3.4.8) crashed\n  on 32-bit big-endian systems.\n\nBreaks in compatibility\n-----------------------\n\n* Removed support for Python < 2.6.\n\n3.4.12 (5 February 2018)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#129. pycryptodomex could only be installed via wheels.\n\n3.4.11 (5 February 2018)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#121. the record list was still not correct due to PEP3147\n  and __pycache__ directories. Thanks again to John O'Brien.\n\n3.4.10 (2 February 2018)\n++++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* When creating ElGamal keys, the generator wasn't a square residue:\n  ElGamal encryption done with those keys cannot be secure under\n  the DDH assumption. Thanks to Weikeng Chen.\n\n3.4.9 (1 February 2018)\n+++++++++++++++++++++++\n\nNew features\n------------\n* More meaningful error messages while importing an ECC key.\n\nResolved issues\n---------------\n\n* GH#123 and #125. The SSE2 command line switch was not always passed on 32-bit x86 platforms.\n* GH#121. The record list (--record) was not always correctly filled for the\n  pycryptodomex package. Thanks to John W. O'Brien.\n\n3.4.8 (27 January 2018)\n+++++++++++++++++++++++\n\nNew features\n------------\n\n* Added a native extension in pure C for modular exponentiation, optimized for SSE2 on x86.\n  In the process, we drop support for the arbitrary arithmetic library MPIR\n  on Windows, which is painful to compile and deploy.\n  The custom  modular exponentiation is 130% (160%) slower on an Intel CPU in 32-bit (64-bit) mode,\n  compared to MPIR. Still, that is much faster that CPython's own `pow()` function which\n  is 900% (855%) slower than MPIR. Support for the GMP library on Unix remains.\n* Added support for *manylinux* wheels.\n* Support for Python 3.7.\n\nResolved issues\n---------------\n\n* The DSA parameter 'p' prime was created with 255 bits cleared\n  (but still with the correct strength).\n* GH#106. Not all docs were included in the tar ball.\n  Thanks to Christopher Hoskin.\n* GH#109. ECDSA verification failed for DER encoded signatures.\n  Thanks to Alastair Houghton.\n* Human-friendly messages for padding errors with ECB and CBC.\n\n3.4.7 (26 August 2017)\n++++++++++++++++++++++\n\nNew features\n------------\n\n* API documentation is made with sphinx instead of epydoc.\n* Start using ``importlib`` instead of ``imp`` where available.\n\nResolved issues\n---------------\n\n* GH#82. Fixed PEM header for RSA/DSA public keys.\n\n3.4.6 (18 May 2017)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* GH#65. Keccak, SHA3, SHAKE and the seek functionality for ChaCha20 were\n  not working on big endian machines. Fixed. Thanks to Mike Gilbert.\n* A few fixes in the documentation.\n\n3.4.5 (6 February 2017)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* The library can also be compiled using MinGW.\n\n3.4.4 (1 February 2017)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* Removed use of ``alloca()``.\n* [Security] Removed implementation of deprecated \"quick check\" feature of PGP block cipher mode.\n* Improved the performance of ``scrypt`` by converting some Python to C.\n\n3.4.3 (17 October 2016)\n+++++++++++++++++++++++\n\nResolved issues\n---------------\n\n* Undefined warning was raised with libgmp version < 5\n* Forgot inclusion of ``alloca.h``\n* Fixed a warning about type mismatch raised by recent versions of cffi\n\n3.4.2 (8 March 2016)\n++++++++++++++++++++\n\n\nResolved issues\n---------------\n\n* Fix renaming of package for ``install`` command.\n\n\n3.4.1 (21 February 2016)\n++++++++++++++++++++++++\n\nNew features\n------------\n\n* Added option to install the library under the ``Cryptodome`` package\n  (instead of ``Crypto``).\n\n3.4 (7 February 2016)\n+++++++++++++++++++++\n\nNew features\n------------\n\n* Added ``Crypto.PublicKey.ECC`` module (NIST P-256 curve only), including export/import of ECC keys.\n* Added support for ECDSA (FIPS 186-3 and RFC6979).\n* For CBC/CFB/OFB/CTR cipher objects, ``encrypt()`` and ``decrypt()`` cannot be intermixed.\n* CBC/CFB/OFB, the cipher objects have both ``IV`` and ``iv`` attributes.\n  ``new()`` accepts ``IV`` as well as ``iv`` as parameter.\n* For CFB/OPENPGP cipher object, ``encrypt()`` and ``decrypt()`` do not require the plaintext\n  or ciphertext pieces to have length multiple of the CFB segment size.\n* Added dedicated tests for all cipher modes, including NIST test vectors\n* CTR/CCM/EAX/GCM/SIV/Salsa20/ChaCha20 objects expose the ``nonce`` attribute.\n* For performance reasons, CCM cipher optionally accepted a pre-declaration of\n  the length of the associated data, but never checked if the actual data passed\n  to the cipher really matched that length. Such check is now enforced.\n* CTR cipher objects accept parameter ``nonce`` and possibly ``initial_value`` in\n  alternative to ``counter`` (which is deprecated).\n* All ``iv``/``IV`` and ``nonce`` parameters are optional. If not provided,\n  they will be randomly generated (exception: ``nonce`` for CTR mode in case\n  of block sizes smaller than 16 bytes).\n* Refactored ARC2 cipher.\n* Added ``Crypto.Cipher.DES3.adjust_key_parity()`` function.\n* Added ``RSA.import_key`` as an alias to the deprecated ``RSA.importKey``\n  (same for the ``DSA`` module).\n* Added ``size_in_bits()`` and ``size_in_bytes()`` methods to ``RsaKey``.\n\nResolved issues\n---------------\n\n* RSA key size is now returned correctly in ``RsaKey.__repr__()`` method (kudos to *hannesv*).\n* CTR mode does not modify anymore ``counter`` parameter passed to ``new()`` method.\n* CTR raises ``OverflowError`` instead of ``ValueError`` when the counter wraps around.\n* PEM files with Windows newlines could not be imported.\n* ``Crypto.IO.PEM`` and ``Crypto.IO.PKCS8`` used to accept empty passphrases.\n* GH#6: NotImplementedError now raised for unsupported methods ``sign``, ``verify``,\n  ``encrypt``, ``decrypt``, ``blind``, ``unblind`` and ``size`` in objects ``RsaKey``, ``DsaKey``,\n  ``ElGamalKey``.\n\nBreaks in compatibility\n-----------------------\n\n* Parameter ``segment_size`` cannot be 0 for the CFB mode.\n* For OCB ciphers, a final call without parameters to ``encrypt`` must end a sequence\n  of calls to ``encrypt`` with data (similarly for ``decrypt``).\n* Key size for ``ARC2``, ``ARC4`` and ``Blowfish`` must be at least 40 bits long (still very weak).\n* DES3 (Triple DES module) does not allow keys that degenerate to Single DES.\n* Removed method ``getRandomNumber`` in ``Crypto.Util.number``.\n* Removed module ``Crypto.pct_warnings``.\n* Removed attribute ``Crypto.PublicKey.RSA.algorithmIdentifier``.\n\n3.3.1 (1 November 2015)\n+++++++++++++++++++++++\n\nNew features\n------------\n\n* Opt-in for ``update()`` after ``digest()`` for SHA-3, keccak, BLAKE2 hashes\n\nResolved issues\n---------------\n\n* Removed unused SHA-3 and keccak test vectors, therefore significantly reducing\n  the package from 13MB to 3MB.\n\nBreaks in compatibility\n-----------------------\n\n* Removed method ``copy()`` from BLAKE2 hashes\n* Removed ability to ``update()`` a BLAKE2 hash after the first call to ``(hex)digest()``\n\n3.3 (29 October 2015)\n+++++++++++++++++++++\n\nNew features\n------------\n\n* Windows wheels bundle the MPIR library\n* Detection of faults occurring during secret RSA operations\n* Detection of non-prime (weak) q value in DSA domain parameters\n* Added original Keccak hash family (b=1600 only).\n  In the process, simplified the C code base for SHA-3.\n* Added SHAKE128 and SHAKE256 (of SHA-3 family)\n\nResolved issues\n---------------\n\n* GH#3: gcc 4.4.7 unhappy about double typedef\n\nBreaks in compatibility\n-----------------------\n\n* Removed method ``copy()`` from all SHA-3 hashes\n* Removed ability to ``update()`` a SHA-3 hash after the first call to ``(hex)digest()``\n\n3.2.1 (9 September 2015)\n++++++++++++++++++++++++\n\nNew features\n------------\n\n* Windows wheels are automatically built on Appveyor\n\n3.2 (6 September 2015)\n++++++++++++++++++++++\n\nNew features\n------------\n\n* Added hash functions BLAKE2b and BLAKE2s.\n* Added stream cipher ChaCha20.\n* Added OCB cipher mode.\n* CMAC raises an exception whenever the message length is found to be\n  too large and the chance of collisions not negligeable.\n* New attribute ``oid`` for Hash objects with ASN.1 Object ID\n* Added ``Crypto.Signature.pss`` and ``Crypto.Signature.pkcs1_15``\n* Added NIST test vectors (roughly 1200) for PKCS#1 v1.5 and PSS signatures.\n\nResolved issues\n---------------\n\n* tomcrypt_macros.h asm error #1\n\nBreaks in compatibility\n-----------------------\n\n* Removed keyword ``verify_x509_cert`` from module method ``importKey`` (RSA and DSA).\n* Reverted to original PyCrypto behavior of method ``verify`` in ``PKCS1_v1_5``\n  and ``PKCS1_PSS``.\n\n3.1 (15 March 2015)\n+++++++++++++++++++\n\nNew features\n------------\n\n* Speed up execution of Public Key algorithms on PyPy, when backed\n  by the Gnu Multiprecision (GMP) library.\n* GMP headers and static libraries are not required anymore at the time\n  PyCryptodome is built. Instead, the code will automatically use the\n  GMP dynamic library (.so/.DLL) if found in the system at runtime.\n* Reduced the amount of C code by almost 40% (4700 lines).\n  Modularized and simplified all code (C and Python) related to block ciphers.\n  Pycryptodome is now free of CPython extensions.\n* Add support for CI in Windows via Appveyor.\n* RSA and DSA key generation more closely follows FIPS 186-4 (though it is\n  not 100% compliant).\n\nResolved issues\n---------------\n\n* None\n\nBreaks in compatibility\n-----------------------\n\n* New dependency on ctypes with Python 2.4.\n* The ``counter`` parameter of a CTR mode cipher must be generated via\n  ``Crypto.Util.Counter``. It cannot be a generic callable anymore.\n* Removed the ``Crypto.Random.Fortuna`` package (due to lack of test vectors).\n* Removed the ``Crypto.Hash.new`` function.\n* The ``allow_wraparound`` parameter of ``Crypto.Util.Counter`` is ignored.\n  An exception is always generated if the counter is reused.\n* ``DSA.generate``, ``RSA.generate`` and ``ElGamal.generate`` do not\n  accept the ``progress_func`` parameter anymore.\n* Removed ``Crypto.PublicKey.RSA.RSAImplementation``.\n* Removed ``Crypto.PublicKey.DSA.DSAImplementation``.\n* Removed ambiguous method ``size()`` from RSA, DSA and ElGamal keys.\n\n3.0 (24 June 2014)\n++++++++++++++++++\n\nNew features\n------------\n\n* Initial support for PyPy.\n* SHA-3 hash family based on the April 2014 draft of FIPS 202.\n  See modules ``Crypto.Hash.SHA3_224/256/384/512``.\n  Initial Keccak patch by Fabrizio Tarizzo.\n* Salsa20 stream cipher. See module ``Crypto.Cipher.Salsa20``.\n  Patch by Fabrizio Tarizzo.\n* Colin Percival's ``scrypt`` key derivation function (``Crypto.Protocol.KDF.scrypt``).\n* Proper interface to FIPS 186-3 DSA. See module ``Crypto.Signature.DSS``.\n* Deterministic DSA (RFC6979). Again, see ``Crypto.Signature.DSS``.\n* HMAC-based Extract-and-Expand key derivation function\n  (``Crypto.Protocol.KDF.HKDF``, RFC5869).\n* Shamir's Secret Sharing protocol, compatible with *ssss* (128 bits only).\n  See module ``Crypto.Protocol.SecretSharing``.\n* Ability to generate a DSA key given the domain parameters.\n* Ability to test installation with a simple ``python -m Crypto.SelfTest``.\n\nResolved issues\n---------------\n\n* LP#1193521: ``mpz_powm_sec()`` (and Python) crashed when modulus was odd.\n* Benchmarks work again (they broke when ECB stopped working if\n  an IV was passed. Patch by Richard Mitchell.\n* LP#1178485: removed some catch-all exception handlers.\n  Patch by Richard Mitchell.\n* LP#1209399: Removal of Python wrappers caused HMAC to silently\n  produce the wrong data with SHA-2 algorithms.\n* LP#1279231: remove dead code that does nothing in SHA-2 hashes.\n  Patch by Richard Mitchell.\n* LP#1327081: AESNI code accesses memory beyond buffer end.\n* Stricter checks on ciphertext and plaintext size for textbook RSA\n  (kudos to sharego).\n\nBreaks in compatibility\n-----------------------\n\n* Removed support for Python < 2.4.\n* Removed the following methods from all 3 public key object types (RSA, DSA, ElGamal):\n\n  - ``sign``\n  - ``verify``\n  - ``encrypt``\n  - ``decrypt``\n  - ``blind``\n  - ``unblind``\n\n  Code that uses such methods is doomed anyway. It should be fixed ASAP to\n  use the algorithms available in ``Crypto.Signature`` and ``Crypto.Cipher``.\n* The 3 public key object types (RSA, DSA, ElGamal) are now unpickable.\n* Symmetric ciphers do not have a default mode anymore (used to be ECB).\n  An expression like ``AES.new(key)`` will now fail. If ECB is the desired mode,\n  one has to explicitly use ``AES.new(key, AES.MODE_ECB)``.\n* Unsuccessful verification of a signature will now raise an exception [reverted in 3.2].\n* Removed the ``Crypto.Random.OSRNG`` package.\n* Removed the ``Crypto.Util.winrandom`` module.\n* Removed the ``Crypto.Random.randpool`` module.\n* Removed the ``Crypto.Cipher.XOR`` module.\n* Removed the ``Crypto.Protocol.AllOrNothing`` module.\n* Removed the ``Crypto.Protocol.Chaffing`` module.\n* Removed the parameters ``disabled_shortcut`` and ``overflow`` from ``Crypto.Util.Counter.new``.\n\nOther changes\n-------------\n\n* ``Crypto.Random`` stops being a userspace CSPRNG. It is now a pure wrapper over ``os.urandom``.\n* Added certain resistance against side-channel attacks for GHASH (GCM) and DSA.\n* More test vectors for ``HMAC-RIPEMD-160``.\n* Update ``libtomcrypt`` headers and code to v1.17 (kudos to Richard Mitchell).\n* RSA and DSA keys are checked for consistency as they are imported.\n* Simplified build process by removing autoconf.\n* Speed optimization to PBKDF2.\n* Add support for MSVC.\n* Replaced HMAC code with a BSD implementation. Clarified that starting from the fork,\n  all contributions are released under the BSD license.\n"
        },
        {
          "name": "Doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "FuturePlans.rst",
          "type": "blob",
          "size": 0.921875,
          "content": "Future releases will include:\n\n- Update `Crypto.Signature.DSS` to FIPS 186-4\n- Make all hash objects non-copyable and immutable after the first digest\n- Add alias 'segment_bits' to parameter 'segment_size' for CFB\n- Coverage testing\n- Implement AES with bitslicing\n- Add unit tests for PEM I/O\n- Move old ciphers into a Museum submodule\n- Add more ECC curves\n- Import/export of ECC keys with compressed points\n- Add algorithms:\n    - Elliptic Curves (ECIES, ECDH)\n    - Camellia, GOST\n    - Diffie-Hellman\n    - bcrypt\n    - argon2\n    - SRP\n- Add more key management:\n    - Export/import of DSA domain parameters\n    - JWK\n- Add support for CMS/PKCS#7\n- Add support for RNG backed by PKCS#11 and/or KMIP\n- Add support for Format-Preserving Encryption\n- Remove dependency on libtomcrypto headers\n- Speed up (T)DES with a bitsliced implementation\n- Run lint on the C code\n- Add (minimal) support for PGP\n- Add (minimal) support for PKIX / X.509\n"
        },
        {
          "name": "INSTALL.rst",
          "type": "blob",
          "size": 7.66796875,
          "content": "Installation\n------------\n\nThe installation procedure depends on the package you want the library to be in.\nPyCryptodome can be used as:\n\n #. **An almost drop-in replacement for the old PyCrypto library**.\n    You install it with::\n\n        pip install pycryptodome\n   \n    In this case, all modules are installed under the ``Crypto`` package.\n    You can test everything is right with::\n\t\t\n        pip install pycryptodome-test-vectors\n        python -m Crypto.SelfTest\n   \n    One must avoid having both PyCrypto and PyCryptodome installed\n    at the same time, as they will interfere with each other.\n    This option is therefore recommended only when you are sure that\n    the whole application is deployed in a ``virtualenv``.\n\n #. **A library independent of the old PyCrypto**.\n    You install it with::\n\n        pip install pycryptodomex\n   \n    You can test everything is right with::\n\t\t\n        pip install pycryptodome-test-vectors\n        python -m Cryptodome.SelfTest\n  \n    In this case, all modules are installed under the ``Cryptodome`` package.\n    The old PyCrypto and PyCryptodome can coexist.\n\n.. note::\n\n  If you intend to run PyCryptodome with Python 2.7 under Windows, you must first install\n  the `Microsoft Visual C++ 2015 Redistributable <https://www.microsoft.com/en-us/download/details.aspx?id=52685>`_.\n  That is not necessary if you use Python 3.\n\nThe procedures below go a bit more in detail, by explaining\nhow to setup the environment for compiling the C extensions\nfor each OS, and how to install the GMP library.\n\nCompiling in Linux Ubuntu\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. note::\n    If you want to install under the ``Crypto`` package, replace\n    below ``pycryptodomex`` with ``pycryptodome``.\n\nFor Python 2.x::\n\n        $ sudo apt-get install build-essential python-dev\n        $ pip install pycryptodomex\n        $ pip install pycryptodome-test-vectors\n        $ python -m Cryptodome.SelfTest\n\nFor Python 3.x::\n\n        $ sudo apt-get install build-essential python3-dev\n        $ pip install pycryptodomex\n        $ pip install pycryptodome-test-vectors\n        $ python3 -m Cryptodome.SelfTest\n\nFor PyPy::\n\n        $ sudo apt-get install build-essential pypy-dev\n        $ pip install pycryptodomex\n        $ pip install pycryptodome-test-vectors\n        $ pypy -m Cryptodome.SelfTest\n\nCompiling in Linux Fedora\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. note::\n    If you want to install under the ``Crypto`` package, replace\n    below ``pycryptodomex`` with ``pycryptodome``.\n\nFor Python 2.x::\n\n        $ sudo yum install gcc gmp python-devel\n        $ pip install pycryptodomex\n        $ pip install pycryptodome-test-vectors\n        $ python -m Cryptodome.SelfTest\n\nFor Python 3.x::\n\n        $ sudo yum install gcc gmp python3-devel\n        $ pip install pycryptodomex\n        $ pip install pycryptodome-test-vectors\n        $ python3 -m Cryptodome.SelfTest\n\nFor PyPy::\n\n        $ sudo yum install gcc gmp pypy-devel\n        $ pip install pycryptodomex\n        $ pip install pycryptodome-test-vectors\n        $ pypy -m Cryptodome.SelfTest\n\n\nWindows (from sources)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. note::\n    If you want to install under the ``Crypto`` package, replace\n    below ``pycryptodomex`` with ``pycryptodome``. That being the case and if you want to run the test, instead of ``Cryptodome.SelfTest``, run ``Crypto.SelfTest``.\n\nWindows does not come with a C compiler like most Unix systems.\nThe simplest way to compile the *PyCryptodome* extensions from\nsource code is to install the minimum set of Visual Studio\ncomponents freely made available by Microsoft.\n\n#. **[Once only]** Download `Build Tools for Visual Studio 2019 <https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019>`_.\n   In the installer, select the *C++ build tools*, the *Windows 10 SDK*, and the latest version of *MSVC v142 x64/x86 build tools*.\n\n#. Compile and install PyCryptodome::\n\n        > pip install pycryptodomex --no-binary :all:\n\n#. To make sure everything work fine, run the test suite::\n\n        > pip install pycryptodome-test-vectors\n        > python -m Cryptodome.SelfTest\n\nDocumentation\n~~~~~~~~~~~~~\n\nProject documentation is written in reStructuredText and it is stored under ``Doc/src``.\nTo publish it as HTML files, you need to install `sphinx <http://www.sphinx-doc.org/en/stable/>`_ and\nuse::\n\n    > make -C Doc/ html\n\nIt will then be available under ``Doc/_build/html/``.\n\nPGP verification\n~~~~~~~~~~~~~~~~\n\nAll source packages and wheels on PyPI are cryptographically signed.\nThey can be verified with the following PGP key::\n\n -----BEGIN PGP PUBLIC KEY BLOCK-----\n \n mQINBFTXjPgBEADc3j7vnma9MXRshBPPXXenVpthQD6lrF/3XaBT2RptSf/viOD+\n tz85du5XVp+r0SYYGeMNJCQ9NsztxblN/lnKgkfWRmSrB+V6QGS+e3bR5d9OIxzN\n 7haPxBnyRj//hCT/kKis6fa7N9wtwKBBjbaSX+9vpt7Rrt203sKfcChA4iR3EG89\n TNQoc/kGGmwk/gyjfU38726v0NOhMKJp2154iQQVZ76hTDk6GkOYHTcPxdkAj4jS\n Dd74M9sOtoOlyDLHOLcWNnlWGgZjtz0z0qSyFXRSuOfggTxrepWQgKWXXzgVB4Jo\n 0bhmXPAV8vkX5BoG6zGkYb47NGGvknax6jCvFYTCp1sOmVtf5UTVKPplFm077tQg\n 0KZNAvEQrdWRIiQ1cCGCoF2Alex3VmVdefHOhNmyY7xAlzpP0c8z1DsgZgMnytNn\n GPusWeqQVijRxenl+lyhbkb9ZLDq7mOkCRXSze9J2+5aLTJbJu3+Wx6BEyNIHP/f\n K3E77nXvC0oKaYTbTwEQSBAggAXP+7oQaA0ea2SLO176xJdNfC5lkQEtMMSZI4gN\n iSqjUxXW2N5qEHHex1atmTtk4W9tQEw030a0UCxzDJMhD0aWFKq7wOxoCQ1q821R\n vxBH4cfGWdL/1FUcuCMSUlc6fhTM9pvMXgjdEXcoiLSTdaHuVLuqmF/E0wARAQAB\n tB9MZWdyYW5kaW4gPGhlbGRlcmlqc0BnbWFpbC5jb20+iQI4BBMBAgAiBQJU14z4\n AhsDBgsJCAcDAgYVCAIJCgsEFgIDAQIeAQIXgAAKCRDabO+N4RaZEn7IEACpApha\n vRwPB+Dv87aEyVmjZ96Nb3mxHdeP2uSmUxAODzoB5oJJ1QL6HRxEVlU8idjdf73H\n DX39ZC7izD+oYIve9sNwTbKqJCZaTxlTDdgSF1N57eJOlELAy+SqpHtaMJPk7SfJ\n l/iYoUYxByPLZU1wDwZEDNzt9RCGy3bd/vF/AxWjdUJJPh3E4j5hswvIGSf8/Tp3\n MDROU1BaNBOd0CLvBHok8/xavwO6Dk/fE4hJhd5uZcEPtd1GJcPq51z2yr7PGUcb\n oERsKZyG8cgfd7j8qoTd6jMIW6fBVHdxiMxW6/Z45X/vVciQSzzEl/yjPUW42kyr\n Ib6M16YmnDzp8bl4NNFvvR9uWvOdUkep2Bi8s8kBMJ7G9rHHJcdVy/tP1ECS9Bse\n hN4v5oJJ4v5mM/MiWRGKykZULWklonpiq6CewYkmXQDMRnjGXhjCWrB6LuSIkIXd\n gKvDNpJ8yEhAfmpvA4I3laMoof/tSZ7ZuyLSZGLKl6hoNIB13HCn4dnjNBeaXCWX\n pThgeOWxV6u1fhz4CeC1Hc8WOYr8S7G8P10Ji6owOcj/a1QuCW8XDB2omCTXlhFj\n zpC9dX8HgmUVnbPNiMjphihbKXoOcunRx4ZvqIa8mnTbI4tHtR0K0tI4MmbpcVOZ\n 8IFJ0nZJXuZiL57ijLREisPYmHfBHAgmh1j/W7kCDQRU14z4ARAA3QATRgvOSYFh\n nJOnIz6PO3G9kXWjJ8wvp3yE1/PwwTc3NbVUSNCW14xgM2Ryhn9NVh8iEGtPGmUP\n 4vu7rvuLC2rBs1joBTyqf0mDghlZrb5ZjXv5LcG9SA6FdAXRU6T+b1G2ychKkhEh\n d/ulLw/TKLds9zHhE+hkAagLQ5jqjcQN0iX5EYaOukiPUGmnd9fOEGi9YMYtRdrH\n +3bZxUpsRStLBWJ6auY7Bla8NJOhaWpr5p/ls+mnDWoqf+tXCCps1Da/pfHKYDFc\n 2VVdyM/VfNny9eaczYpnj5hvIAACWChgGDBwxPh2DGdUfiQi/QqrK96+F7ulqz6V\n 2exX4CL0cPv5fUpQqSU/0R5WApM9bl2+wljFhoCXlydU9HNn+0GatGzEoo3yrV/m\n PXv7d6NdZxyOqgxu/ai/z++F2pWUXSBxZN3Gv28boFKQhmtthTcFudNUtQOchhn8\n Pf/ipVISqrsZorTx9Qx4fPScEWjwbh84Uz20bx0sQs1oYcek2YG5RhEdzqJ6W78R\n S/dbzlNYMXGdkxB6C63m8oiGvw0hdN/iGVqpNAoldFmjnFqSgKpyPwfLmmdstJ6f\n xFZdGPnKexCpHbKr9fg50jZRenIGai79qPIiEtCZHIdpeemSrc7TKRPV3H2aMNfG\n L5HTqcyaM2+QrMtHPMoOFzcjkigLimMAEQEAAYkCHwQYAQIACQUCVNeM+AIbDAAK\n CRDabO+N4RaZEo7lD/45J6z2wbL8aIudGEL0aY3hfmW3qrUyoHgaw35KsOY9vZwb\n cZuJe0RlYptOreH/NrbR5SXODfhd2sxYyyvXBOuZh9i7OOBsrAd5UE01GCvToPwh\n 7IpMV3GSSAB4P8XyJh20tZqiZOYKhmbf29gUDzqAI6GzUa0U8xidUKpW2zqYGZjp\n wk3RI1fS7tyi/0N8B9tIZF48kbvpFDAjF8w7NSCrgRquAL7zJZIG5o5zXJM/ffF3\n 67Dnz278MbifdM/HJ+Tj0R0Uvvki9Z61nT653SoUgvILQyC72XI+x0+3GQwsE38a\n 5aJNZ1NBD3/v+gERQxRfhM5iLFLXK0Xe4K2XFM1g0yN4L4bQPbhSCq88g9Dhmygk\n XPbBsrK0NKPVnyGyUXM0VpgRbot11hxx02jC3HxS1nlLF+oQdkKFzJAMOU7UbpX/\n oO+286J1FmpG+fihIbvp1Quq48immtnzTeLZbYCsG4mrM+ySYd0Er0G8TBdAOTiN\n 3zMbGX0QOO2fOsJ1d980cVjHn5CbAo8C0A/4/R2cXAfpacbvTiNq5BVk9NKa2dNb\n kmnTStP2qILWmm5ASXlWhOjWNmptvsUcK+8T+uQboLioEv19Ob4j5Irs/OpOuP0K\n v4woCi9+03HMS42qGSe/igClFO3+gUMZg9PJnTJhuaTbytXhUBgBRUPsS+lQAQ==\n =DpoI\n -----END PGP PUBLIC KEY BLOCK-----\n\n.. _pypi: https://pypi.python.org/pypi/pycryptodome\n.. _get-pip.py: https://bootstrap.pypa.io/get-pip.py\n.. _GMP: http://gmplib.org\n"
        },
        {
          "name": "LICENSE.rst",
          "type": "blob",
          "size": 2.857421875,
          "content": "The source code in PyCryptodome is partially in the public domain\nand partially released under the BSD 2-Clause license.\n\nIn either case, there are minimal if no restrictions on the redistribution,\nmodification and usage of the software.\n\nPublic domain\n=============\n\nAll code originating from  PyCrypto is free and unencumbered software\nreleased into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org>\n\nBSD license\n===========\n\nAll direct contributions to PyCryptodome are released under the following\nlicense. The copyright of each piece belongs to the respective author.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MANIFEST.in",
          "type": "blob",
          "size": 0.326171875,
          "content": "include MANIFEST.in\ninclude *.rst\ninclude .separate_namespace\ninclude setup.py pct-speedtest.py compiler_opt.py setup.cfg\ninclude pyproject.toml\ninclude requirements-test.txt\ngraft Doc\nprune Doc/_build\ninclude .github/workflows/*.yml\nrecursive-include src *.h *.c\ngraft src/test\nrecursive-exclude src *.pyc *.swp\nprune src/test/build\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 3.3837890625,
          "content": ".. image:: https://github.com/Legrandin/pycryptodome/workflows/Integration%20test/badge.svg?branch=master\n   :target: https://github.com/Legrandin/pycryptodome/actions\n\n.. image:: https://badge.fury.io/py/pycryptodome.svg\n   :target: https://pypi.org/project/pycryptodome\n\n.. image:: https://badge.fury.io/py/pycryptodomex.svg\n   :target: https://pypi.org/project/pycryptodomex\n\nPyCryptodome\n============\n\nPyCryptodome is a self-contained Python package of low-level\ncryptographic primitives.\n\nIt supports Python 2.7, Python 3.6 and newer, and PyPy.\n\nThe installation procedure depends on the package you want the library to be in.\nPyCryptodome can be used as:\n\n#. **an almost drop-in replacement for the old PyCrypto library**.\n   You install it with::\n\n       pip install pycryptodome\n\n   In this case, all modules are installed under the ``Crypto`` package.\n\n   One must avoid having both PyCrypto and PyCryptodome installed\n   at the same time, as they will interfere with each other.\n\n   This option is therefore recommended only when you are sure that\n   the whole application is deployed in a ``virtualenv``.\n\n#. **a library independent of the old PyCrypto**.\n   You install it with::\n\n       pip install pycryptodomex\n\n   In this case, all modules are installed under the ``Cryptodome`` package.\n   PyCrypto and PyCryptodome can coexist.\n\nFor faster public key operations in Unix, you should install `GMP`_ in your system.\n\nPyCryptodome is a fork of PyCrypto. It brings the following enhancements\nwith respect to the last official version of PyCrypto (2.6.1):\n\n* Authenticated encryption modes (GCM, CCM, EAX, SIV, OCB)\n* Accelerated AES on Intel platforms via AES-NI\n* First class support for PyPy\n* Elliptic curves cryptography (NIST P-curves; Ed25519, Ed448, Curve25519, Curve448)\n* Better and more compact API (`nonce` and `iv` attributes for ciphers,\n  automatic generation of random nonces and IVs, simplified CTR cipher mode,\n  and more)\n* SHA-3 hash algorithms (FIPS 202) and derived functions (NIST SP-800 185):\n\n  - SHAKE128 and SHA256 XOFs\n  - cSHAKE128 and cSHAKE256 XOFs\n  - KMAC128 and KMAC256\n  - TupleHash128 and TupleHash256\n\n* KangarooTwelve, TurboSHAKE128, and TurboSHAKE256 XOFs\n* Truncated hash algorithms SHA-512/224 and SHA-512/256 (FIPS 180-4)\n* BLAKE2b and BLAKE2s hash algorithms\n* Salsa20 and ChaCha20/XChaCha20 stream ciphers\n* Poly1305 MAC\n* ChaCha20-Poly1305 and XChaCha20-Poly1305 authenticated ciphers\n* scrypt, bcrypt, HKDF, and NIST SP 800 108r1 Counter Mode key derivation functions\n* Deterministic (EC)DSA and EdDSA\n* Password-protected PKCS#8 key containers\n* Shamir's Secret Sharing scheme\n* Random numbers get sourced directly from the OS (and not from a CSPRNG in userspace)\n* Simplified install process, including better support for Windows\n* Cleaner RSA and DSA key generation (largely based on FIPS 186-4)\n* Major clean ups and simplification of the code base\n\nPyCryptodome is not a wrapper to a separate C library like *OpenSSL*.\nTo the largest possible extent, algorithms are implemented in pure Python.\nOnly the pieces that are extremely critical to performance (e.g. block ciphers)\nare implemented as C extensions.\n\nFor more information, see the `homepage`_.\n\nFor security issues, please send an email to security@pycryptodome.org.\n\nAll the code can be downloaded from `GitHub`_.\n\n.. _`homepage`: https://www.pycryptodome.org\n.. _`GMP`: https://gmplib.org\n.. _GitHub: https://github.com/Legrandin/pycryptodome\n"
        },
        {
          "name": "bench_monty.py",
          "type": "blob",
          "size": 3.548828125,
          "content": "#!/usr/bin/env python3\n\nimport time\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Math import Numbers\nfrom Crypto.Math.Numbers import Integer\nfrom Crypto.Util.number import long_to_bytes\nfrom Crypto.Util._raw_api import (load_pycryptodome_raw_lib,\n                                  create_string_buffer,\n                                  c_size_t)\n\nITER = 100\n\nprint(Numbers._implementation)\n\nrsa_pem=\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA1maRsgBxvk1m1LcQMrN/oAfPq/V5/LkeUL/CdTs/DOe+dOIW\nrvfibUrhgLwg170+qIpsv2+HOA5hPIl5tbBDsgCo/4hWo7EodeNumKdWnzhS0Cjp\nZ1UQALAsGen6UugxFbiTCaq7Hhzx4stjadY31Gd1zkUj6jH2StJ5TLw2XdijXgB+\n07V2lYd/vxAtvrizISSROY5JQxTpNyaSbhOD+Ku1iJvqlU64wMocYsjp2D9BiICV\nxeZF7W0yUV/gxYwTaMrYRpThjaQ2aMb0PmHXybymM93Np671t5vDltSp9I4qmr4I\nNsxFXkNTBTVyKOk9JartRrlS3vrg9XM5vyb1qQIDAQABAoIBACzgr2KJAUYKQZoI\n75UNSYuf1vJxoaUqwpO4b+XGDv6Oi6k/oevh6z1hTS57Moy2CiWRRA4WNEGhkOzx\nAc7sJF9gD//c8/WzoXp7rqy5akJNsdfsmF6OyZi7R5/s//7Wp1+akPyXBi/ZczA7\nzoVa17jYJyqUAl6FMr6aq9VKGD8wNTjSp+YhtBMdWegjpGJfOb19UY13hPfDqPGQ\nYdp0l0/0L6HAY97C25fUYeKRp9bnIXCKUineFmwSRjYzcoVOJ/PwiuJ0vBa/0gWw\nKKTYE4ZJRDPVFt+7NfSVrLpeTh0YQ8s8MSm2ZCqF/HJEzlhF+sBxx/Yi5O4SrEP6\nvuqgzQECgYEA/E9vn6XKnJXX3hiy0XVsUQK+Ana2xn63TxmiMJtrrUjD5WCiy9kD\neTU82igdg9JJGBWOd7mkSAWxVZT9MPaQ4/Vz6ggoZcPHZokmVP7qPePNmFXX6Jdz\nhQx8HD0QcwwaYbIJ91WdoAP/cEuu+o+WPKB0CDYWrv3Dx9eTircemlECgYEA2Yk2\nWXkOdD2KlnZgHNYp23F2XP6dF4Ny5n478thlJXdexRwRDSKCN/41jfC0FlPpZBcF\n7EFTo+p7lhyJVxPBWSOIhJArMe98bdWoo+6TBuAPLisu7+i+HVRaoyHf0x3t7ViG\nJqQOGjHN0G57cgSCrpaFwE2bAZ4dkA27M8Oy99kCgYEAw+HoB0nvwyGSNht2uKcx\nMLOwULlZrUEzj3WXNaV0M1QKwkoEGb6hs7hhRf1e7LiVht01fj3iDQheZNMGvryu\nQEyPcWJj+p3EcRaJa/N8aBAzzdDXjvwF84V91W6TFr6OvMo8colFlrWD2urnLh/L\nw8XOT5Guiqz5Em2LXmZMnAECgYEAuZ1Ksq2Il8arKhd3iyNyM7xssozOnfGbaPDt\nVhkutPlV8/ou0nZPhldyetqXzzVqP+0lMKHNLGA3c66Fwbcpk1Wudu5M7R7bnRxh\n+P7olUU5rrtKIYsGLSB89hVBVnKDQbH3RaFWJyO36dFbo74Vg8ML/To6uPahYvlU\ncqbZXoECgYAOybAyRS9vivcYoKywxtI0aU1HHibPrUl3izYLfDxfWgA0S6IGcBg1\nSx6XG8GYbzkouGb30yjIpn7JB1147DH1oxf8wcHXbAsgNX4IC6rQ1Iwef9P4pORF\nicKO95pcPRhmfzuqfhEu/d/ZYjabao95baBHcrRxEbXZtjg88KVXKg==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\nc_defs = \"\"\"\nint monty_pow(const uint8_t *base,\n               const uint8_t *exp,\n               const uint8_t *modulus,\n               uint8_t       *out,\n               size_t len,\n               uint64_t seed);\n\"\"\"\n\n_raw_montgomery = load_pycryptodome_raw_lib(\"Crypto.Math._montgomery\", c_defs)\n\nkey = RSA.import_key(rsa_pem)\nmessage = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\nSIZE = key.size_in_bytes()\n\n# -----------------------------------------------------------------\nstart = time.time()\nfor x in range(ITER):\n\tresult_cpython = pow(message, key.d, key.n)\nend = time.time()\nprint(\"CPython =\", end-start)\n\n# -----------------------------------------------------------------\nbase_b = long_to_bytes(message, SIZE)\nexp_b = long_to_bytes(key.d, SIZE)\nmodulus_b = long_to_bytes(key.n, SIZE)\nout = create_string_buffer(SIZE)\n\nstart = time.time()\nfor _ in range(ITER):\n    _raw_montgomery.monty_pow(\n                base_b,\n                exp_b,\n                modulus_b,\n                out,\n                c_size_t(SIZE),\n                32\n                )\nend = time.time()\nmy_time = end-start\nprint(\"Custom modexp =\", my_time)\n\n# -----------------------------------------------------------------\nmg = Integer(message)\nmd = Integer(key.d)\nmn = Integer(key.n)\nstart = time.time()\nfor x in range(ITER):\n\tresult_gmp = pow(mg, md, mn)\nend = time.time()\ngmp_time = end - start\nprint(\"GMP =\", gmp_time)\n\n# -----------------------------------------------------------------\nprint(\"%.2f%%\" % float((my_time/gmp_time-1)*100), \"slower\")\n"
        },
        {
          "name": "compiler_opt.py",
          "type": "blob",
          "size": 12.1572265625,
          "content": "# ===================================================================\n#\n# Copyright (c) 2018, Helder Eijs <helderijs@gmail.com>\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in\n#    the documentation and/or other materials provided with the\n#    distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n# ===================================================================\n\n\nimport os\nimport sys\nimport struct\nimport distutils\nfrom distutils import ccompiler\nfrom distutils.errors import CCompilerError\n\n\ndef test_compilation(program, extra_cc_options=None, extra_libraries=None,\n                     msg=''):\n    \"\"\"Test if a certain C program can be compiled.\"\"\"\n\n    # Create a temporary file with the C program\n    if not os.path.exists(\"build\"):\n        os.makedirs(\"build\")\n    fname = os.path.join(\"build\", \"test1.c\")\n    f = open(fname, 'w')\n    f.write(program)\n    f.close()\n\n    # Name for the temporary executable\n    oname = os.path.join(\"build\", \"test1.out\")\n\n    debug = bool(os.environ.get('PYCRYPTODOME_DEBUG', None))\n    # Mute the compiler and the linker\n    if msg:\n        print(\"Testing support for %s\" % msg)\n    if not (debug or os.name == 'nt'):\n        old_stdout = os.dup(sys.stdout.fileno())\n        old_stderr = os.dup(sys.stderr.fileno())\n        dev_null = open(os.devnull, \"w\")\n        os.dup2(dev_null.fileno(), sys.stdout.fileno())\n        os.dup2(dev_null.fileno(), sys.stderr.fileno())\n\n    objects = []\n    try:\n        compiler = ccompiler.new_compiler()\n        distutils.sysconfig.customize_compiler(compiler)\n\n        if compiler.compiler_type in ['msvc']:\n            # Force creation of the manifest file (http://bugs.python.org/issue16296)\n            # as needed by VS2010\n            extra_linker_options = [\"/MANIFEST\"]\n        else:\n            extra_linker_options = []\n\n        # In Unix, force the linker step to use CFLAGS and not CC alone (see GH#180)\n        if compiler.compiler_type in ['unix']:\n            compiler.set_executables(linker_exe=compiler.compiler)\n\n        objects = compiler.compile([fname], extra_postargs=extra_cc_options)\n        compiler.link_executable(objects, oname, libraries=extra_libraries,\n                                 extra_preargs=extra_linker_options)\n        result = True\n    except (CCompilerError, OSError):\n        result = False\n    for f in objects + [fname, oname]:\n        try:\n            os.remove(f)\n        except OSError:\n            pass\n\n    # Restore stdout and stderr\n    if not (debug or os.name == 'nt'):\n        if old_stdout is not None:\n            os.dup2(old_stdout, sys.stdout.fileno())\n        if old_stderr is not None:\n            os.dup2(old_stderr, sys.stderr.fileno())\n        if dev_null is not None:\n            dev_null.close()\n    if msg:\n        if result:\n            x = \"\"\n        else:\n            x = \" not\"\n        print(\"Target does%s support %s\" % (x, msg))\n\n    return result\n\n\ndef has_stdint_h():\n    source = \"\"\"\n    #include <stdint.h>\n    int main(void) {\n        uint32_t u;\n        u = 0;\n        return u + 2;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"stdint.h header\")\n\n\ndef compiler_supports_uint128():\n    source = \"\"\"\n    int main(void)\n    {\n        __uint128_t x;\n        return 0;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"128-bit integer\")\n\n\ndef compiler_has_intrin_h():\n    # Windows\n    source = \"\"\"\n    #include <intrin.h>\n    int main(void)\n    {\n        int a, b[4];\n        __cpuid(b, a);\n        return a;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"intrin.h header\")\n\n\ndef compiler_has_cpuid_h():\n    # UNIX\n    source = \"\"\"\n    #include <cpuid.h>\n    int main(void)\n    {\n        unsigned int eax, ebx, ecx, edx;\n        __get_cpuid(1, &eax, &ebx, &ecx, &edx);\n        return eax;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"cpuid.h header\")\n\n\ndef compiler_supports_aesni():\n    source = \"\"\"\n    #include <wmmintrin.h>\n    #include <string.h>\n    __m128i f(__m128i x, __m128i y) {\n        return _mm_aesenc_si128(x, y);\n    }\n    int main(void) {\n        int ret;\n        __m128i x;\n        memset(&x, 0, sizeof(x));\n        x = f(x, x);\n        memcpy(&ret, &x, sizeof(ret));\n        return ret;\n    }\n    \"\"\"\n\n    if test_compilation(source):\n        return {'extra_cc_options': [], 'extra_macros': []}\n\n    if test_compilation(source, extra_cc_options=['-maes'], msg='AESNI intrinsics'):\n        return {'extra_cc_options': ['-maes'], 'extra_macros': []}\n\n    return False\n\n\ndef compiler_supports_clmul():\n    result = {'extra_cc_options': [], 'extra_macros' : ['HAVE_WMMINTRIN_H', 'HAVE_TMMINTRIN_H']}\n\n    source = \"\"\"\n    #include <wmmintrin.h>\n    #include <tmmintrin.h>\n\n    __m128i f(__m128i x, __m128i y) {\n        return _mm_clmulepi64_si128(x, y, 0x00);\n    }\n\n    __m128i g(__m128i a) {\n        __m128i mask;\n\n        mask = _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n        return _mm_shuffle_epi8(a, mask);\n    }\n\n    int main(void) {\n        return 0;\n    }\n    \"\"\"\n\n    if test_compilation(source):\n        return result\n\n    if test_compilation(source, extra_cc_options=['-mpclmul', '-mssse3'], msg='CLMUL intrinsics'):\n        result['extra_cc_options'].extend(['-mpclmul', '-mssse3'])\n        return result\n\n    return False\n\n\ndef compiler_has_posix_memalign():\n    source = \"\"\"\n    #include <stdlib.h>\n    int main(void) {\n        void *new_mem;\n        int res;\n        res = posix_memalign((void**)&new_mem, 16, 101);\n        return res == 0;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"posix_memalign\")\n\n\ndef compiler_has_memalign():\n    source = \"\"\"\n    #include <malloc.h>\n    int main(void) {\n        void *p;\n        p = memalign(16, 101);\n        return p != (void*)0;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"memalign\")\n\n\ndef compiler_is_clang():\n    source = \"\"\"\n    #if !defined(__clang__)\n    #error Not clang\n    #endif\n    int main(void)\n    {\n        return 0;\n    }\n    \"\"\"\n    return test_compilation(source, msg=\"clang\")\n\n\ndef compiler_is_gcc(extra_cc_options=[]):\n    source = \"\"\"\n    #if defined(__clang__) || !defined(__GNUC__)\n    #error Not GCC\n    #endif\n    int main(void)\n    {\n        return 0;\n    }\"\"\"\n    return test_compilation(source,\n                            msg=\"gcc\",\n                            extra_cc_options=extra_cc_options)\n\n\ndef compiler_supports_sse2():\n    source_template = \"\"\"\n    %s\n    int main(void)\n    {\n        __m128i r0;\n        int mask;\n        r0 = _mm_set1_epi32(0);\n        mask = _mm_movemask_epi8(r0);\n        return mask;\n    }\n    \"\"\"\n\n    source_intrin_h = source_template % \"#include <intrin.h>\"\n    source_x86intrin_h = source_template % \"#include <x86intrin.h>\"\n    source_xemmintrin_h = source_template % \"#include <xmmintrin.h>\\n#include <emmintrin.h>\"\n\n    system_bits = 8 * struct.calcsize(\"P\")\n\n    result = None\n    if test_compilation(source_intrin_h, msg=\"SSE2(intrin.h)\"):\n        result = {'extra_cc_options': [], 'extra_macros': ['HAVE_INTRIN_H', 'USE_SSE2']}\n    elif test_compilation(source_x86intrin_h, extra_cc_options=['-msse2'], msg=\"SSE2(x86intrin.h)\"):\n        result = {'extra_cc_options': ['-msse2'], 'extra_macros': ['HAVE_X86INTRIN_H', 'USE_SSE2']}\n    elif test_compilation(source_xemmintrin_h, extra_cc_options=['-msse2'], msg=\"SSE2(emmintrin.h)\"):\n        result = {'extra_cc_options': ['-msse2'], 'extra_macros': ['HAVE_EMMINTRIN_H', 'USE_SSE2']}\n    else:\n        result = False\n\n    # On 32-bit x86 platforms, gcc assumes the stack to be aligned to 16\n    # bytes, but the caller may actually only align it to 4 bytes, which\n    # make functions crash if they use SSE2 intrinsics.\n    # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=40838\n    if result and system_bits == 32 and compiler_is_gcc(extra_cc_options=['-mstackrealign']):\n        result['extra_cc_options'].append('-mstackrealign')\n\n    return result\n\n\ndef remove_extension(extensions, name):\n    idxs = [i for i, x in enumerate(extensions) if x.name == name]\n    if len(idxs) != 1:\n        raise ValueError(\"There is no or there are multiple extensions named '%s'\" % name)\n    del extensions[idxs[0]]\n\n\ndef set_compiler_options(package_root, extensions):\n    \"\"\"Environment specific settings for extension modules.\n\n    This function modifies how each module gets compiled, to\n    match the capabilities of the platform.\n    Also, it removes existing modules when not supported, such as:\n      - AESNI\n      - CLMUL\n    \"\"\"\n\n    extra_cc_options = []\n    extra_macros = []\n\n    clang = compiler_is_clang()\n    gcc = compiler_is_gcc()\n\n    if has_stdint_h():\n        extra_macros.append((\"HAVE_STDINT_H\", None))\n\n    # Endianess\n    extra_macros.append((\"PYCRYPTO_\" + sys.byteorder.upper() + \"_ENDIAN\", None))\n\n    # System\n    system_bits = 8 * struct.calcsize(\"P\")\n    extra_macros.append((\"SYS_BITS\", str(system_bits)))\n\n    # Disable any assembly in libtomcrypt files\n    extra_macros.append((\"LTC_NO_ASM\", None))\n\n    # Native 128-bit integer\n    if compiler_supports_uint128():\n        extra_macros.append((\"HAVE_UINT128\", None))\n\n    # Auto-detecting CPU features\n    cpuid_h_present = compiler_has_cpuid_h()\n    if cpuid_h_present:\n        extra_macros.append((\"HAVE_CPUID_H\", None))\n    intrin_h_present = compiler_has_intrin_h()\n    if intrin_h_present:\n        extra_macros.append((\"HAVE_INTRIN_H\", None))\n\n    # Platform-specific call for getting a block of aligned memory\n    if compiler_has_posix_memalign():\n        extra_macros.append((\"HAVE_POSIX_MEMALIGN\", None))\n    elif compiler_has_memalign():\n        extra_macros.append((\"HAVE_MEMALIGN\", None))\n\n    # SSE2\n    sse2_result = compiler_supports_sse2()\n    if sse2_result:\n        extra_cc_options.extend(sse2_result['extra_cc_options'])\n        for macro in sse2_result['extra_macros']:\n            extra_macros.append((macro, None))\n\n    # Module-specific options\n\n    # AESNI\n    aesni_result = (cpuid_h_present or intrin_h_present) and compiler_supports_aesni()\n    aesni_mod_name = package_root + \".Cipher._raw_aesni\"\n    if aesni_result:\n        print(\"Compiling support for AESNI instructions\")\n        aes_mods = [x for x in extensions if x.name == aesni_mod_name]\n        for x in aes_mods:\n            x.extra_compile_args.extend(aesni_result['extra_cc_options'])\n            for macro in aesni_result['extra_macros']:\n                x.define_macros.append((macro, None))\n    else:\n        print(\"Warning: compiler does not support AESNI instructions\")\n        remove_extension(extensions, aesni_mod_name)\n\n    # CLMUL\n    clmul_result = (cpuid_h_present or intrin_h_present) and compiler_supports_clmul()\n    clmul_mod_name = package_root + \".Hash._ghash_clmul\"\n    if clmul_result:\n        print(\"Compiling support for CLMUL instructions\")\n        clmul_mods = [x for x in extensions if x.name == clmul_mod_name]\n        for x in clmul_mods:\n            x.extra_compile_args.extend(clmul_result['extra_cc_options'])\n            for macro in clmul_result['extra_macros']:\n                x.define_macros.append((macro, None))\n    else:\n        print(\"Warning: compiler does not support CLMUL instructions\")\n        remove_extension(extensions, clmul_mod_name)\n\n    for x in extensions:\n        x.extra_compile_args.extend(extra_cc_options)\n        x.define_macros.extend(extra_macros)\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "pct-speedtest.py",
          "type": "blob",
          "size": 18.3486328125,
          "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  pct-speedtest.py: Speed test for the Python Cryptography Toolkit\n#\n# Written in 2009 by Dwayne C. Litzenberger <dlitz@dlitz.net>\n#\n# ===================================================================\n# The contents of this file are dedicated to the public domain.  To\n# the extent that dedication to the public domain is not available,\n# everyone is granted a worldwide, perpetual, royalty-free,\n# non-exclusive license to exercise all rights associated with the\n# contents of this file for any purpose whatsoever.\n# No rights are reserved.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n# ===================================================================\n\nimport time\nimport os\nimport sys\n\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_OAEP, PKCS1_v1_5 as RSAES_PKCS1_v1_5\nfrom Crypto.Signature import PKCS1_PSS, PKCS1_v1_5 as RSASSA_PKCS1_v1_5\nfrom Crypto.Cipher import (AES, ARC2, ARC4, Blowfish, CAST, DES3, DES,\n                           Salsa20, ChaCha20)\nfrom Crypto.Hash import (HMAC, MD2, MD4, MD5, SHA224, SHA256, SHA384, SHA512,\n                         CMAC, SHA3_224, SHA3_256, SHA3_384, SHA3_512,\n                         BLAKE2b, BLAKE2s)\nfrom Crypto.Random import get_random_bytes\nimport Crypto.Util.Counter\nfrom Crypto.Util.number import bytes_to_long\ntry:\n    from Crypto.Hash import SHA1\nexcept ImportError:\n    # Maybe it's called SHA\n    from Crypto.Hash import SHA as SHA1\ntry:\n    from Crypto.Hash import RIPEMD160\nexcept ImportError:\n    # Maybe it's called RIPEMD\n    try:\n        from Crypto.Hash import RIPEMD as RIPEMD160\n    except ImportError:\n        # Some builds of PyCrypto don't have the RIPEMD module\n        RIPEMD160 = None\n\ntry:\n    import hashlib\n    import hmac\nexcept ImportError: # Some builds/versions of Python don't have a hashlib module\n    hashlib = hmac = None\n\nfrom Crypto.Random import random as pycrypto_random\nimport random as stdlib_random\n\nclass BLAKE2b_512(object):\n    digest_size = 512\n    @staticmethod\n    def new(data=None):\n        return BLAKE2b.new(digest_bits=512, data=data)\n\nclass BLAKE2s_256(object):\n    digest_size = 256\n    @staticmethod\n    def new(data=None):\n        return BLAKE2s.new(digest_bits=256, data=data)\n\nclass ChaCha20_old_style(object):\n    @staticmethod\n    def new(key, nonce):\n        return ChaCha20.new(key=key, nonce=nonce)\n\nclass ModeNotAvailable(ValueError):\n    pass\n\nrng = get_random_bytes\n\nclass Benchmark:\n\n    def __init__(self):\n        self.__random_data = None\n\n    def random_keys(self, bytes, n=10**5):\n        \"\"\"Return random keys of the specified number of bytes.\n        If this function has been called before with the same number of bytes,\n        cached keys are used instead of randomly generating new ones.\n        \"\"\"\n        return self.random_blocks(bytes, n)\n\n    def random_blocks(self, bytes_per_block, blocks):\n        bytes = bytes_per_block * blocks\n        data = self.random_data(bytes)\n        retval = []\n        for i in range(blocks):\n            p = i * bytes_per_block\n            retval.append(data[p:p+bytes_per_block])\n        return retval\n\n    def random_data(self, bytes):\n        if self.__random_data is None:\n            self.__random_data = self._random_bytes(bytes)\n            return self.__random_data\n        elif bytes == len(self.__random_data):\n            return self.__random_data\n        elif bytes < len(self.__random_data):\n            return self.__random_data[:bytes]\n        else:\n            self.__random_data += self._random_bytes(bytes - len(self.__random_data))\n            return self.__random_data\n\n    def _random_bytes(self, b):\n        return os.urandom(b)\n\n    def announce_start(self, test_name):\n        sys.stdout.write(\"%s: \" % (test_name,))\n        sys.stdout.flush()\n\n    def announce_result(self, value, units):\n        sys.stdout.write(\"%.2f %s\\n\" % (value, units))\n        sys.stdout.flush()\n\n    def test_random_module(self, module_name, module):\n        self.announce_start(\"%s.choice\" % (module_name,))\n        alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        t0 = time.perf_counter()\n        for i in range(5000):\n            module.choice(alphabet)\n        t = time.perf_counter()\n        invocations_per_second = 5000 / (t - t0)\n        self.announce_result(invocations_per_second, \"invocations/sec\")\n\n    def test_pubkey_setup(self, pubkey_name, module, key_bytes):\n        self.announce_start(\"%s pubkey setup\" % (pubkey_name,))\n        keys = self.random_keys(key_bytes)[:5]\n\n        t0 = time.perf_counter()\n        for k in keys:\n            module.generate(key_bytes*8)\n        t = time.perf_counter()\n        pubkey_setups_per_second = len(keys) / (t - t0)\n        self.announce_result(pubkey_setups_per_second, \"Keys/sec\")\n\n    def test_key_setup(self, cipher_name, module, key_bytes, params):\n        self.generate_cipher(module, key_bytes, params)\n        self.announce_start(\"%s key setup\" % (cipher_name,))\n\n        for x in range(5000):\n            t0 = time.perf_counter()\n            self.generate_cipher(module, key_bytes, params)\n            t = time.perf_counter()\n\n        key_setups_per_second = 5000 / (t - t0)\n        self.announce_result(key_setups_per_second/1000, \"kKeys/sec\")\n\n    def test_encryption(self, cipher_name, module, key_bytes, params):\n        self.announce_start(\"%s encryption\" % (cipher_name,))\n\n        pt_size = 16384000\n        pt = rng(pt_size)\n        cipher = self.generate_cipher(module, key_bytes, params)\n\n        params_dict = dict([param.split('=') for param in params.split()])\n\n        # Perform encryption\n        if params_dict.get('mode') == 'MODE_SIV':\n            t0 = time.perf_counter()\n            cipher.encrypt_and_digest(pt)\n            t = time.perf_counter()\n        else:\n            t0 = time.perf_counter()\n            cipher.encrypt(pt)\n            t = time.perf_counter()\n\n        encryption_speed = pt_size / (t - t0)\n        self.announce_result(encryption_speed / 10**6, \"MBps\")\n\n    def test_hash_small(self, hash_name, hash_constructor, digest_size):\n        self.announce_start(\"%s (%d-byte inputs)\" % (hash_name, digest_size))\n\n        blocks = self.random_blocks(digest_size, 10000)\n\n        # Initialize hashes\n        t0 = time.perf_counter()\n        for b in blocks:\n            hash_constructor(b).digest()\n        t = time.perf_counter()\n\n        hashes_per_second = len(blocks) / (t - t0)\n        self.announce_result(hashes_per_second / 1000, \"kHashes/sec\")\n\n    def test_hash_large(self, hash_name, hash_constructor, digest_size):\n        self.announce_start(\"%s (single large input)\" % (hash_name,))\n\n        blocks = self.random_blocks(16384, 10000)\n\n        # Perform hashing\n        t0 = time.perf_counter()\n        h = hash_constructor()\n        for b in blocks:\n            h.update(b)\n        h.digest()\n        t = time.perf_counter()\n\n        hash_speed = len(blocks) * len(blocks[0]) / (t - t0)\n        self.announce_result(hash_speed / 10**6, \"MBps\")\n\n    def test_hmac_small(self, mac_name, hmac_constructor, digestmod, digest_size):\n        keys = iter(self.random_keys(digest_size))\n        if sys.version_info[0] == 2:\n            mac_constructor = lambda data=None: hmac_constructor(keys.next(), data, digestmod)\n        else:\n            mac_constructor = lambda data=None: hmac_constructor(keys.__next__(), data, digestmod)\n        self.test_hash_small(mac_name, mac_constructor, digest_size)\n\n    def test_hmac_large(self, mac_name, hmac_constructor, digestmod, digest_size):\n        key = self.random_keys(digest_size)[0]\n        mac_constructor = lambda data=None: hmac_constructor(key, data, digestmod)\n        self.test_hash_large(mac_name, mac_constructor, digest_size)\n\n    def test_cmac_small(self, mac_name, cmac_constructor, ciphermod, key_size):\n        keys = iter(self.random_keys(key_size))\n        if sys.version_info[0] == 2:\n            mac_constructor = lambda data=None: cmac_constructor(keys.next(), data, ciphermod)\n        else:\n            mac_constructor = lambda data=None: cmac_constructor(keys.__next__(), data, ciphermod)\n        self.test_hash_small(mac_name, mac_constructor, ciphermod.block_size)\n\n    def test_cmac_large(self, mac_name, cmac_constructor, ciphermod, key_size):\n        key = self.random_keys(key_size)[0]\n        mac_constructor = lambda data=None: cmac_constructor(key, data, ciphermod)\n        self.test_hash_large(mac_name, mac_constructor, ciphermod.block_size)\n\n    def test_pkcs1_sign(self, scheme_name, scheme_constructor, hash_name, hash_constructor, digest_size):\n        self.announce_start(\"%s signing %s (%d-byte inputs)\" % (scheme_name, hash_name, digest_size))\n\n        # Make a key\n        k = RSA.generate(2048)\n        sigscheme = scheme_constructor(k)\n\n        # Make some hashes\n        blocks = self.random_blocks(digest_size, 50)\n        hashes = []\n        for b in blocks:\n            hashes.append(hash_constructor(b))\n\n        # Perform signing\n        t0 = time.perf_counter()\n        for h in hashes:\n            sigscheme.sign(h)\n        t = time.perf_counter()\n\n        speed = len(hashes) / (t - t0)\n        self.announce_result(speed, \"sigs/sec\")\n\n    def test_pkcs1_verify(self, scheme_name, scheme_constructor, hash_name, hash_constructor, digest_size):\n        self.announce_start(\"%s verification %s (%d-byte inputs)\" % (scheme_name, hash_name, digest_size))\n\n        # Make a key\n        k = RSA.generate(2048)\n        sigscheme = scheme_constructor(k)\n\n        # Make some hashes\n        blocks = self.random_blocks(digest_size, 50)\n        hashes = []\n        for b in blocks:\n            hashes.append(hash_constructor(b))\n\n        # Make some signatures\n        signatures = []\n        for h in hashes:\n            signatures.append(sigscheme.sign(h))\n\n        # Double the list, to make timing better\n        hashes = hashes + hashes\n        signatures = signatures + signatures\n\n        # Perform verification\n        t0 = time.perf_counter()\n        for h, s in zip(hashes, signatures):\n            sigscheme.verify(h, s)\n        t = time.perf_counter()\n\n        speed = len(hashes) / (t - t0)\n        self.announce_result(speed, \"sigs/sec\")\n\n\n    def generate_cipher(self, module, key_size, params):\n        params_dict = {}\n        if params:\n            params_dict = dict([x.split(\"=\") for x in params.split(\" \")])\n\n        gen_tuple = []\n        gen_dict = {}\n\n        # 1st parameter (mandatory): key\n        if params_dict.get('ks') == \"x2\":\n            key = rng(2 * key_size)\n        else:\n            key = rng(key_size)\n        gen_tuple.append(key)\n\n        # 2nd parameter: mode\n        mode = params_dict.get(\"mode\")\n        if mode:\n            mode_value = getattr(module, mode, None)\n            if mode_value is None:\n                # Mode not available for this cipher\n                raise ModeNotAvailable()\n            gen_tuple.append(getattr(module, mode))\n\n        # 3rd parameter: IV/nonce\n        iv_length = params_dict.get(\"iv\")\n        if iv_length is None:\n            iv_length = params_dict.get(\"nonce\")\n        if iv_length:\n            if iv_length == \"bs\":\n                iv_length = module.block_size\n            iv = rng(int(iv_length))\n            gen_tuple.append(iv)\n\n        # Specific to CTR mode\n        le = params_dict.get(\"little_endian\")\n        if le:\n            if le == \"True\":\n                le = True\n            else:\n                le = False\n\n            # Remove iv from parameters\n            gen_tuple = gen_tuple[:-1]\n            ctr = Crypto.Util.Counter.new(module.block_size*8,\n                                          initial_value=bytes_to_long(iv),\n                                          little_endian=le,\n                                          allow_wraparound=True)\n            gen_dict['counter'] = ctr\n\n        # Generate cipher\n        return module.new(*gen_tuple, **gen_dict)\n\n    def run(self):\n        pubkey_specs = [\n            (\"RSA(1024)\", RSA, int(1024/8)),\n            (\"RSA(2048)\", RSA, int(2048/8)),\n            (\"RSA(4096)\", RSA, int(4096/8)),\n            ]\n        block_cipher_modes = [\n            # Mode name, key setup, parameters\n            (\"CBC\",     True,   \"mode=MODE_CBC iv=bs\"),\n            (\"CFB-8\",   False,  \"mode=MODE_CFB iv=bs\"),\n            (\"OFB\",     False,  \"mode=MODE_OFB iv=bs\"),\n            (\"ECB\",     False,  \"mode=MODE_ECB\"),\n            (\"CTR-LE\",  True,   \"mode=MODE_CTR iv=bs little_endian=True\"),\n            (\"CTR-BE\",  False,  \"mode=MODE_CTR iv=bs little_endian=False\"),\n            (\"OPENPGP\", False,  \"mode=MODE_OPENPGP iv=bs\"),\n            (\"CCM\",     True,   \"mode=MODE_CCM nonce=12\"),\n            (\"GCM\",     True,   \"mode=MODE_GCM nonce=16\"),\n            (\"EAX\",     True,   \"mode=MODE_EAX nonce=16\"),\n            (\"SIV\",     True,   \"mode=MODE_SIV ks=x2 nonce=16\"),\n            (\"OCB\",     True,   \"mode=MODE_OCB nonce=15\"),\n            ]\n        block_specs = [\n            # Cipher name, module, key size\n            (\"DES\", DES, 8),\n            (\"DES3\", DES3, 24),\n            (\"AES128\", AES, 16),\n            (\"AES192\", AES, 24),\n            (\"AES256\", AES, 32),\n            (\"Blowfish(256)\", Blowfish, 32),\n            (\"CAST(128)\", CAST, 16),\n            (\"ARC2(128)\", ARC2, 16),\n        ]\n        stream_specs = [\n            # Cipher name, module, key size, nonce size\n            (\"ARC4(128)\", ARC4, 16, 0),\n            (\"Salsa20(16)\", Salsa20, 16, 8),\n            (\"Salsa20(32)\", Salsa20, 32, 8),\n            (\"ChaCha20\", ChaCha20_old_style, 32, 8),\n        ]\n        hash_specs = [\n            (\"MD2\", MD2),\n            (\"MD4\", MD4),\n            (\"MD5\", MD5),\n            (\"SHA1\", SHA1),\n            (\"SHA224\", SHA224),\n            (\"SHA256\", SHA256),\n            (\"SHA384\", SHA384),\n            (\"SHA512\", SHA512),\n            (\"SHA3_224\", SHA3_224),\n            (\"SHA3_256\", SHA3_256),\n            (\"SHA3_384\", SHA3_384),\n            (\"SHA3_512\", SHA3_512),\n            (\"BLAKE2b\", BLAKE2b_512),\n            (\"BLAKE2s\", BLAKE2s_256),\n        ]\n        if RIPEMD160 is not None:\n            hash_specs += [(\"RIPEMD160\", RIPEMD160)]\n\n        hashlib_specs = []\n        if hashlib is not None:\n            if hasattr(hashlib, 'md5'):    hashlib_specs.append((\"hashlib.md5\",    hashlib.md5))\n            if hasattr(hashlib, 'sha1'):   hashlib_specs.append((\"hashlib.sha1\",   hashlib.sha1))\n            if hasattr(hashlib, 'sha224'): hashlib_specs.append((\"hashlib.sha224\", hashlib.sha224))\n            if hasattr(hashlib, 'sha256'): hashlib_specs.append((\"hashlib.sha256\", hashlib.sha256))\n            if hasattr(hashlib, 'sha384'): hashlib_specs.append((\"hashlib.sha384\", hashlib.sha384))\n            if hasattr(hashlib, 'sha512'): hashlib_specs.append((\"hashlib.sha512\", hashlib.sha512))\n\n        # stdlib random\n        self.test_random_module(\"stdlib random\", stdlib_random)\n\n        # Crypto.Random.random\n        self.test_random_module(\"Crypto.Random.random\", pycrypto_random)\n\n        # Crypto.PublicKey\n        for pubkey_name, module, key_bytes in pubkey_specs:\n            self.test_pubkey_setup(pubkey_name, module, key_bytes)\n\n        # Crypto.Cipher (block ciphers)\n        for cipher_name, module, key_bytes in block_specs:\n\n            # Benchmark each cipher in each of the various modes (CBC, etc)\n            for mode_name, test_ks, params in block_cipher_modes:\n\n                mode_text = \"%s-%s\" % (cipher_name, mode_name)\n                try:\n                    if test_ks:\n                        self.test_key_setup(mode_text, module, key_bytes, params)\n                    self.test_encryption(mode_text, module, key_bytes, params)\n                except ModeNotAvailable as e:\n                    pass\n\n        # Crypto.Cipher (stream ciphers)\n        for cipher_name, module, key_bytes, nonce_bytes in stream_specs:\n            params = \"\"\n            if nonce_bytes:\n                params = \"nonce=\" + str(nonce_bytes)\n            self.test_key_setup(cipher_name, module, key_bytes, params)\n            self.test_encryption(cipher_name, module, key_bytes, params)\n\n        # Crypto.Hash\n        for hash_name, module in hash_specs:\n            self.test_hash_small(hash_name, module.new, module.digest_size)\n            self.test_hash_large(hash_name, module.new, module.digest_size)\n\n        # standard hashlib\n        for hash_name, func in hashlib_specs:\n            self.test_hash_small(hash_name, func, func().digest_size)\n            self.test_hash_large(hash_name, func, func().digest_size)\n\n        # PyCrypto HMAC\n        for hash_name, module in hash_specs:\n            if not hasattr(module, \"block_size\"):\n                continue\n            self.test_hmac_small(\"HMAC-\"+hash_name, HMAC.new, module, module.digest_size)\n            self.test_hmac_large(\"HMAC-\"+hash_name, HMAC.new, module, module.digest_size)\n\n        # standard hmac + hashlib\n        for hash_name, func in hashlib_specs:\n            if not hasattr(module, \"block_size\"):\n                continue\n            self.test_hmac_small(\"hmac+\"+hash_name, hmac.HMAC, func, func().digest_size)\n            self.test_hmac_large(\"hmac+\"+hash_name, hmac.HMAC, func, func().digest_size)\n\n        # CMAC\n        for cipher_name, module, key_size in ((\"AES128\", AES, 16),):\n            self.test_cmac_small(cipher_name+\"-CMAC\", CMAC.new, module, key_size)\n            self.test_cmac_large(cipher_name+\"-CMAC\", CMAC.new, module, key_size)\n\n        # PKCS1_v1_5 (sign) + Crypto.Hash\n        for hash_name, module in hash_specs:\n            self.test_pkcs1_sign(\"PKCS#1-v1.5\", RSASSA_PKCS1_v1_5.new, hash_name, module.new, module.digest_size)\n\n        # PKCS1_PSS (sign) + Crypto.Hash\n        for hash_name, module in hash_specs:\n            self.test_pkcs1_sign(\"PKCS#1-PSS\", PKCS1_PSS.new, hash_name, module.new, module.digest_size)\n\n        # PKCS1_v1_5 (verify) + Crypto.Hash\n        for hash_name, module in hash_specs:\n            self.test_pkcs1_verify(\"PKCS#1-v1.5\", RSASSA_PKCS1_v1_5.new, hash_name, module.new, module.digest_size)\n\n        # PKCS1_PSS (verify) + Crypto.Hash\n        for hash_name, module in hash_specs:\n            self.test_pkcs1_verify(\"PKCS#1-PSS\", PKCS1_PSS.new, hash_name, module.new, module.digest_size)\n\nif __name__ == '__main__':\n    Benchmark().run()\n\n# vim:set ts=4 sw=4 sts=4 expandtab:"
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.0791015625,
          "content": "[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n"
        },
        {
          "name": "requirements-test.txt",
          "type": "blob",
          "size": 0.033203125,
          "content": "pycryptodome-test-vectors==1.0.20\n"
        },
        {
          "name": "setup.cfg",
          "type": "blob",
          "size": 0.197265625,
          "content": "[flake8]\nmax-line-length = 110\n\n[metadata]\nproject_urls =\n    Source=https://github.com/Legrandin/pycryptodome/\n    Changelog=https://www.pycryptodome.org/src/changelog\n\n[build_sphinx]\nsource-dir = Doc\n"
        },
        {
          "name": "setup.py",
          "type": "blob",
          "size": 18.1552734375,
          "content": "#! /usr/bin/env python\n#\n#  setup.py : Distutils setup script\n#\n# ===================================================================\n# The contents of this file are dedicated to the public domain.  To\n# the extent that dedication to the public domain is not available,\n# everyone is granted a worldwide, perpetual, royalty-free,\n# non-exclusive license to exercise all rights associated with the\n# contents of this file for any purpose whatsoever.\n# No rights are reserved.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n# ===================================================================\n\nfrom __future__ import print_function\n\ntry:\n    from setuptools import Extension, Command, setup\n    from setuptools.command.build_ext import build_ext\n    from setuptools.command.build_py import build_py\nexcept ImportError:\n    from distutils.core import Extension, Command, setup\n    from distutils.command.build_ext import build_ext\n    from distutils.command.build_py import build_py\n\nimport re\nimport os\nimport sys\nimport shutil\nimport struct\nimport sysconfig\n\nsys.path.append(os.getcwd())\n\nfrom compiler_opt import set_compiler_options\n\n\nuse_separate_namespace = os.path.isfile(\".separate_namespace\")\n\nproject_name = \"pycryptodome\"\npackage_root = \"Crypto\"\nother_project = \"pycryptodomex\"\nother_root = \"Cryptodome\"\n\nif use_separate_namespace:\n    project_name, other_project = other_project, project_name\n    package_root, other_root = other_root, package_root\n\nlongdesc = \"\"\"\nPyCryptodome\n============\n\nPyCryptodome is a self-contained Python package of low-level\ncryptographic primitives.\n\nIt supports Python 2.7, Python 3.6 and newer, and PyPy.\n\nYou can install it with::\n\n    pip install THIS_PROJECT\n\nAll modules are installed under the ``THIS_ROOT`` package.\n\nCheck the OTHER_PROJECT_ project for the equivalent library that\nworks under the ``OTHER_ROOT`` package.\n\nPyCryptodome is a fork of PyCrypto. It brings several enhancements\nwith respect to the last official version of PyCrypto (2.6.1),\nfor instance:\n\n* Authenticated encryption modes (GCM, CCM, EAX, SIV, OCB)\n* Accelerated AES on Intel platforms via AES-NI\n* First class support for PyPy\n* Elliptic curves cryptography (NIST P-curves; Ed25519, Ed448, Curve25519)\n* Better and more compact API (`nonce` and `iv` attributes for ciphers,\n  automatic generation of random nonces and IVs, simplified CTR cipher mode,\n  and more)\n* SHA-3 (including SHAKE XOFs) and BLAKE2 hash algorithms\n* Salsa20 and ChaCha20 stream ciphers\n* scrypt and HKDF\n* Deterministic (EC)DSA and EdDSA\n* Password-protected PKCS#8 key containers\n* Shamir's Secret Sharing scheme\n* Random numbers get sourced directly from the OS (and not from a CSPRNG in userspace)\n* Simplified install process, including better support for Windows\n* Cleaner RSA and DSA key generation (largely based on FIPS 186-4)\n* Major clean ups and simplification of the code base\n\nPyCryptodome is not a wrapper to a separate C library like *OpenSSL*.\nTo the largest possible extent, algorithms are implemented in pure Python.\nOnly the pieces that are extremely critical to performance (e.g. block ciphers)\nare implemented as C extensions.\n\nFor more information, see the `homepage`_.\n\nAll the code can be downloaded from `GitHub`_.\n\n.. _OTHER_PROJECT: https://pypi.python.org/pypi/OTHER_PROJECT\n.. _`homepage`: http://www.pycryptodome.org\n.. _GitHub: https://github.com/Legrandin/pycryptodome\n\"\"\".replace(\"THIS_PROJECT\", project_name).\\\n    replace(\"THIS_ROOT\", package_root).\\\n    replace(\"OTHER_PROJECT\", other_project).\\\n    replace(\"OTHER_ROOT\", other_root)\n\n\nclass PCTBuildExt (build_ext):\n\n    # Avoid linking Python's dynamic library\n    def get_libraries(self, ext):\n        return []\n\n\nclass PCTBuildPy(build_py):\n    def find_package_modules(self, package, package_dir, *args, **kwargs):\n        modules = build_py.find_package_modules(self, package, package_dir,\n                                                *args, **kwargs)\n\n        # Exclude certain modules\n        retval = []\n        for item in modules:\n            pkg, module = item[:2]\n            retval.append(item)\n        return retval\n\n\nclass TestCommand(Command):\n    \"Run self-test\"\n\n    # Long option name, short option name, description\n    user_options = [\n        ('skip-slow-tests', None, 'Skip slow tests'),\n        ('wycheproof-warnings', None, 'Show warnings from wycheproof tests'),\n        ('module=', 'm', 'Test a single module (e.g. Cipher, PublicKey)'),\n    ]\n\n    def initialize_options(self):\n        self.build_dir = None\n        self.skip_slow_tests = None\n        self.wycheproof_warnings = None\n        self.module = None\n\n    def finalize_options(self):\n        self.set_undefined_options('install', ('build_lib', 'build_dir'))\n        self.config = {'slow_tests': not self.skip_slow_tests,\n                       'wycheproof_warnings': self.wycheproof_warnings}\n\n    def run(self):\n        # Run sub commands\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        # Run SelfTest\n        old_path = sys.path[:]\n        self.announce(\"running self-tests on \" + package_root)\n        try:\n            sys.path.insert(0, self.build_dir)\n\n            if use_separate_namespace:\n                from Cryptodome import SelfTest\n                from Cryptodome.Math import Numbers\n            else:\n                from Crypto import SelfTest\n                from Crypto.Math import Numbers\n\n            moduleObj = None\n            if self.module:\n                if self.module.count('.') == 0:\n                    # Test a whole a sub-package\n                    full_module = package_root + \".SelfTest.\" + self.module\n                    module_name = self.module\n                else:\n                    # Test only a module\n                    # Assume only one dot is present\n                    comps = self.module.split('.')\n                    module_name = \"test_\" + comps[1]\n                    full_module = package_root + \".SelfTest.\" + comps[0] + \".\" + module_name\n                # Import sub-package or module\n                moduleObj = __import__(full_module, globals(), locals(), module_name)\n\n            print(package_root + \".Math implementation:\",\n                     str(Numbers._implementation))\n\n            SelfTest.run(module=moduleObj, verbosity=self.verbose, stream=sys.stdout, config=self.config)\n        finally:\n            # Restore sys.path\n            sys.path[:] = old_path\n\n        # Run slower self-tests\n        self.announce(\"running extended self-tests\")\n\n    sub_commands = [('build', None)]\n\n\ndef create_cryptodome_lib():\n    assert os.path.isdir(\"lib/Crypto\")\n\n    try:\n        shutil.rmtree(\"lib/Cryptodome\")\n    except OSError:\n        pass\n    for root_src, dirs, files in os.walk(\"lib/Crypto\"):\n\n        root_dst, nr_repl = re.subn('Crypto', 'Cryptodome', root_src)\n        assert nr_repl == 1\n\n        for dir_name in dirs:\n            full_dir_name_dst = os.path.join(root_dst, dir_name)\n            if not os.path.exists(full_dir_name_dst):\n                os.makedirs(full_dir_name_dst)\n\n        for file_name in files:\n            full_file_name_src = os.path.join(root_src, file_name)\n            full_file_name_dst = os.path.join(root_dst, file_name)\n\n            print(\"Copying file %s to %s\" % (full_file_name_src, full_file_name_dst))\n            shutil.copy2(full_file_name_src, full_file_name_dst)\n\n            if full_file_name_src.split(\".\")[-1] not in (\"py\", \"pyi\"):\n                if full_file_name_src != \"py.typed\":\n                    continue\n\n            if sys.version_info[0] > 2:\n                extra_param = { \"encoding\": \"utf-8\" }\n            else:\n                extra_param = {}\n            with open(full_file_name_dst, \"rt\", **extra_param) as fd:\n                content = (fd.read().\n                           replace(\"Crypto.\", \"Cryptodome.\").\n                           replace(\"Crypto \", \"Cryptodome \").\n                           replace(\"'Crypto'\", \"'Cryptodome'\").\n                           replace('\"Crypto\"', '\"Cryptodome\"'))\n            os.remove(full_file_name_dst)\n            with open(full_file_name_dst, \"wt\", **extra_param) as fd:\n                fd.write(content)\n\n\n# Parameters for setup\npackages =  [\n    \"Crypto\",\n    \"Crypto.Cipher\",\n    \"Crypto.Hash\",\n    \"Crypto.IO\",\n    \"Crypto.PublicKey\",\n    \"Crypto.Protocol\",\n    \"Crypto.Random\",\n    \"Crypto.Signature\",\n    \"Crypto.Util\",\n    \"Crypto.Math\",\n    \"Crypto.SelfTest\",\n    \"Crypto.SelfTest.Cipher\",\n    \"Crypto.SelfTest.Hash\",\n    \"Crypto.SelfTest.IO\",\n    \"Crypto.SelfTest.Protocol\",\n    \"Crypto.SelfTest.PublicKey\",\n    \"Crypto.SelfTest.Random\",\n    \"Crypto.SelfTest.Signature\",\n    \"Crypto.SelfTest.Util\",\n    \"Crypto.SelfTest.Math\",\n]\npackage_data = {\n    \"Crypto\" : [ \"py.typed\", \"*.pyi\" ],\n    \"Crypto.Cipher\" : [ \"*.pyi\" ],\n    \"Crypto.Hash\" : [ \"*.pyi\" ],\n    \"Crypto.Math\" : [ \"*.pyi\" ],\n    \"Crypto.Protocol\" : [ \"*.pyi\" ],\n    \"Crypto.PublicKey\" : [ \"*.pyi\" ],\n    \"Crypto.Random\" : [ \"*.pyi\" ],\n    \"Crypto.Signature\" : [ \"*.pyi\" ],\n    \"Crypto.IO\" : [ \"*.pyi\" ],\n    \"Crypto.Util\" : [ \"*.pyi\" ],\n}\n\next_modules = [\n    # Hash functions\n    Extension(\"Crypto.Hash._MD2\",\n        include_dirs=['src/'],\n        sources=[\"src/MD2.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._MD4\",\n        include_dirs=['src/'],\n        sources=[\"src/MD4.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._MD5\",\n        include_dirs=['src/'],\n        sources=[\"src/MD5.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._SHA1\",\n        include_dirs=['src/'],\n        sources=[\"src/SHA1.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._SHA256\",\n        include_dirs=['src/'],\n        sources=[\"src/SHA256.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._SHA224\",\n        include_dirs=['src/'],\n        sources=[\"src/SHA224.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._SHA384\",\n        include_dirs=['src/'],\n        sources=[\"src/SHA384.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._SHA512\",\n        include_dirs=['src/'],\n        sources=[\"src/SHA512.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._RIPEMD160\",\n        include_dirs=['src/'],\n        sources=[\"src/RIPEMD160.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._keccak\",\n        include_dirs=['src/'],\n        sources=[\"src/keccak.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._BLAKE2b\",\n        include_dirs=['src/'],\n        sources=[\"src/blake2b.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._BLAKE2s\",\n        include_dirs=['src/'],\n        sources=[\"src/blake2s.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._ghash_portable\",\n        include_dirs=['src/'],\n        sources=['src/ghash_portable.c'],\n        py_limited_api=True),\n    Extension(\"Crypto.Hash._ghash_clmul\",\n        include_dirs=['src/'],\n        sources=['src/ghash_clmul.c'],\n        py_limited_api=True),\n\n    # MACs\n    Extension(\"Crypto.Hash._poly1305\",\n        include_dirs=['src/'],\n        sources=[\"src/poly1305.c\"],\n        py_limited_api=True),\n\n    # Block encryption algorithms\n    Extension(\"Crypto.Cipher._raw_aes\",\n        include_dirs=['src/'],\n        sources=[\"src/AES.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_aesni\",\n        include_dirs=['src/'],\n        sources=[\"src/AESNI.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_arc2\",\n        include_dirs=['src/'],\n        sources=[\"src/ARC2.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_blowfish\",\n        include_dirs=['src/'],\n        sources=[\"src/blowfish.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_eksblowfish\",\n        include_dirs=['src/'],\n        sources=[\"src/blowfish_eks.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_cast\",\n        include_dirs=['src/'],\n        sources=[\"src/CAST.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_des\",\n        include_dirs=['src/', 'src/libtom/'],\n        sources=[\"src/DES.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_des3\",\n        include_dirs=['src/', 'src/libtom/'],\n        sources=[\"src/DES3.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Util._cpuid_c\",\n        include_dirs=['src/'],\n        sources=['src/cpuid.c'],\n        py_limited_api=True),\n\n    Extension(\"Crypto.Cipher._pkcs1_decode\",\n        include_dirs=['src/'],\n        sources=['src/pkcs1_decode.c'],\n        py_limited_api=True),\n\n    # Chaining modes\n    Extension(\"Crypto.Cipher._raw_ecb\",\n        include_dirs=['src/'],\n        sources=[\"src/raw_ecb.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_cbc\",\n        include_dirs=['src/'],\n        sources=[\"src/raw_cbc.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_cfb\",\n        include_dirs=['src/'],\n        sources=[\"src/raw_cfb.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_ofb\",\n        include_dirs=['src/'],\n        sources=[\"src/raw_ofb.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_ctr\",\n        include_dirs=['src/'],\n        sources=[\"src/raw_ctr.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._raw_ocb\",\n        sources=[\"src/raw_ocb.c\"],\n        py_limited_api=True),\n\n    # Stream ciphers\n    Extension(\"Crypto.Cipher._ARC4\",\n        include_dirs=['src/'],\n        sources=[\"src/ARC4.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._Salsa20\",\n        include_dirs=['src/', 'src/libtom/'],\n        sources=[\"src/Salsa20.c\"],\n        py_limited_api=True),\n    Extension(\"Crypto.Cipher._chacha20\",\n        include_dirs=['src/'],\n        sources=[\"src/chacha20.c\"],\n        py_limited_api=True),\n\n    # Others\n    Extension(\"Crypto.Protocol._scrypt\",\n        include_dirs=['src/'],\n        sources=[\"src/scrypt.c\"],\n        py_limited_api=True),\n\n    # Utility modules\n    Extension(\"Crypto.Util._strxor\",\n        include_dirs=['src/'],\n        sources=['src/strxor.c'],\n        py_limited_api=True),\n\n    # ECC\n    Extension(\"Crypto.PublicKey._ec_ws\",\n        include_dirs=['src/'],\n        sources=['src/ec_ws.c',\n                 'src/mont.c', 'src/p256_table.c', 'src/p384_table.c',\n                 'src/p521_table.c'],\n        py_limited_api=True,\n        ),\n    Extension(\"Crypto.PublicKey._curve25519\",\n        include_dirs=['src/'],\n        sources=['src/curve25519.c'],\n        py_limited_api=True,\n        ),\n    Extension(\"Crypto.PublicKey._curve448\",\n        include_dirs=['src/'],\n        sources=['src/curve448.c', 'src/mont1.c'],\n        py_limited_api=True,\n        ),\n    Extension(\"Crypto.PublicKey._ed25519\",\n        include_dirs=['src/'],\n        sources=['src/ed25519.c'],\n        py_limited_api=True,\n        ),\n    Extension(\"Crypto.PublicKey._ed448\",\n        include_dirs=['src/'],\n        sources=['src/ed448.c', 'src/mont2.c'],\n        py_limited_api=True,\n        ),\n\n    # Math\n    Extension(\"Crypto.Math._modexp\",\n        include_dirs=['src/'],\n        sources=['src/modexp.c', 'src/mont3.c'],\n        py_limited_api=True,\n        ),\n]\n\nif use_separate_namespace:\n\n    # Fix-up setup information\n    for i in range(len(packages)):\n        packages[i] = packages[i].replace(\"Crypto\", \"Cryptodome\")\n    new_package_data = {}\n    for k, v in package_data.items():\n        new_package_data[k.replace(\"Crypto\", \"Cryptodome\")] = v\n    package_data = new_package_data\n    for ext in ext_modules:\n        ext.name = ext.name.replace(\"Crypto\", \"Cryptodome\")\n\n    # Recreate lib/Cryptodome from scratch, unless it is the only\n    # directory available\n    if os.path.isdir(\"lib/Crypto\"):\n        create_cryptodome_lib()\n\n# Add compiler specific options.\nset_compiler_options(package_root, ext_modules)\n\n# By doing this we need to change version information in a single file\nwith open(os.path.join(\"lib\", package_root, \"__init__.py\")) as init_root:\n    for line in init_root:\n        if line.startswith(\"version_info\"):\n            version_tuple = eval(line.split(\"=\")[1])\n\nversion_string = \".\".join([str(x) for x in version_tuple])\n\n# Set the minimum ABI3 version for bdist_wheel to 3.6\n# unless Python is running without GIL (as there is no established way yet to\n# specify multiple ABI levels)\nsetup_options = {}\nif sys.version_info[0] > 2:\n    if not sysconfig.get_config_var('Py_GIL_DISABLED'):\n        setup_options['options'] = {'bdist_wheel': {'py_limited_api': 'cp36'}}\n\nsetup(\n    name=project_name,\n    version=version_string,\n    description=\"Cryptographic library for Python\",\n    long_description=longdesc,\n    author=\"Helder Eijs\",\n    author_email=\"helderijs@gmail.com\",\n    url=\"https://www.pycryptodome.org\",\n    platforms='Posix; MacOS X; Windows',\n    zip_safe=False,\n    python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: BSD License',\n        'License :: Public Domain',\n        'Intended Audience :: Developers',\n        'Operating System :: Unix',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: MacOS :: MacOS X',\n        'Topic :: Security :: Cryptography',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: 3.13',\n    ],\n    license=\"BSD, Public Domain\",\n    packages=packages,\n    package_dir={\"\": \"lib\"},\n    package_data=package_data,\n    cmdclass={\n        'build_ext': PCTBuildExt,\n        'build_py': PCTBuildPy,\n        'test': TestCommand,\n        },\n    ext_modules=ext_modules,\n    **setup_options\n)\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_vectors",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}