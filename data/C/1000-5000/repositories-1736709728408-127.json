{
  "metadata": {
    "timestamp": 1736709728408,
    "page": 127,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antirez/linenoise",
      "stars": 3854,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0361328125,
          "content": "linenoise_example\n*.dSYM\nhistory.txt\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.375,
          "content": "Copyright (c) 2010-2014, Salvatore Sanfilippo <antirez at gmail dot com>\nCopyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice,\n  this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1796875,
          "content": "linenoise_example: linenoise.h linenoise.c\n\nlinenoise_example: linenoise.c example.c\n\t$(CC) -Wall -W -Os -g -o linenoise_example linenoise.c example.c\n\nclean:\n\trm -f linenoise_example\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 14.294921875,
          "content": "# Linenoise\n\nA minimal, zero-config, BSD licensed, readline replacement used in Redis,\nMongoDB, Android and many other projects.\n\n* Single and multi line editing mode with the usual key bindings implemented.\n* History handling.\n* Completion.\n* Hints (suggestions at the right of the prompt as you type).\n* Multiplexing mode, with prompt hiding/restoring for asynchronous output.\n* About ~850 lines (comments and spaces excluded) of BSD license source code.\n* Only uses a subset of VT100 escapes (ANSI.SYS compatible).\n\n## Can a line editing library be 20k lines of code?\n\nLine editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it's just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?\n\nSo what usually happens is either:\n\n * Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (real world example of this problem: Tclsh).\n * Smaller programs not using a configure script not supporting line editing at all (A problem we had with `redis-cli`, for instance).\n \nThe result is a pollution of binaries without line editing support.\n\nSo I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporting line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to Linenoise if not.\n\n## Terminals, in 2010.\n\nApparently almost every terminal you can happen to use today has some kind of support for basic VT100 escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it, and now can work even on ANSI.SYS compatible terminals, since no\nVT220 specific sequences are used anymore.\n\nThe library is currently about 850 lines of code. In order to use it in your project just look at the *example.c* file in the source distribution, it is pretty straightforward. The library supports both a blocking mode and a multiplexing mode, see the API documentation later in this file for more information.\n\nLinenoise is BSD-licensed code, so you can use both in free software and commercial software.\n\n## Tested with...\n\n * Linux text only console ($TERM = linux)\n * Linux KDE terminal application ($TERM = xterm)\n * Linux xterm ($TERM = xterm)\n * Linux Buildroot ($TERM = vt100)\n * Mac OS X iTerm ($TERM = xterm)\n * Mac OS X default Terminal.app ($TERM = xterm)\n * OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)\n * IBM AIX 6.1\n * FreeBSD xterm ($TERM = xterm)\n * ANSI.SYS\n * Emacs comint mode ($TERM = dumb)\n\nPlease test it everywhere you can and report back!\n\n## Let's push this forward!\n\nPatches should be provided in the respect of Linenoise sensibility for small\neasy to understand code.\n\nSend feedbacks to antirez at gmail\n\n# The API\n\nLinenoise is very easy to use, and reading the example shipped with the\nlibrary should get you up to speed ASAP. Here is a list of API calls\nand how to use them. Let's start with the simple blocking mode:\n\n    char *linenoise(const char *prompt);\n\nThis is the main Linenoise call: it shows the user a prompt with line editing\nand history capabilities. The prompt you specify is used as a prompt, that is,\nit will be printed to the left of the cursor. The library returns a buffer\nwith the line composed by the user, or NULL on end of file or when there\nis an out of memory condition.\n\nWhen a tty is detected (the user is actually typing into a terminal session)\nthe maximum editable line length is `LINENOISE_MAX_LINE`. When instead the\nstandard input is not a tty, which happens every time you redirect a file\nto a program, or use it in an Unix pipeline, there are no limits to the\nlength of the line that can be returned.\n\nThe returned line should be freed with the `free()` standard system call.\nHowever sometimes it could happen that your program uses a different dynamic\nallocation library, so you may also used `linenoiseFree` to make sure the\nline is freed with the same allocator it was created.\n\nThe canonical loop used by a program using Linenoise will be something like\nthis:\n\n    while((line = linenoise(\"hello> \")) != NULL) {\n        printf(\"You wrote: %s\\n\", line);\n        linenoiseFree(line); /* Or just free(line) if you use libc malloc. */\n    }\n\n## Single line VS multi line editing\n\nBy default, Linenoise uses single line editing, that is, a single row on the\nscreen will be used, and as the user types more, the text will scroll towards\nleft to make room. This works if your program is one where the user is\nunlikely to write a lot of text, otherwise multi line editing, where multiple\nscreens rows are used, can be a lot more comfortable.\n\nIn order to enable multi line editing use the following API call:\n\n    linenoiseSetMultiLine(1);\n\nYou can disable it using `0` as argument.\n\n## History\n\nLinenoise supporst history, so that the user does not have to retype\nagain and again the same things, but can use the down and up arrows in order\nto search and re-edit already inserted lines of text.\n\nThe followings are the history API calls:\n\n    int linenoiseHistoryAdd(const char *line);\n    int linenoiseHistorySetMaxLen(int len);\n    int linenoiseHistorySave(const char *filename);\n    int linenoiseHistoryLoad(const char *filename);\n\nUse `linenoiseHistoryAdd` every time you want to add a new element\nto the top of the history (it will be the first the user will see when\nusing the up arrow).\n\nNote that for history to work, you have to set a length for the history\n(which is zero by default, so history will be disabled if you don't set\na proper one). This is accomplished using the `linenoiseHistorySetMaxLen`\nfunction.\n\nLinenoise has direct support for persisting the history into an history\nfile. The functions `linenoiseHistorySave` and `linenoiseHistoryLoad` do\njust that. Both functions return -1 on error and 0 on success.\n\n## Mask mode\n\nSometimes it is useful to allow the user to type passwords or other\nsecrets that should not be displayed. For such situations linenoise supports\na \"mask mode\" that will just replace the characters the user is typing \nwith `*` characters, like in the following example:\n\n    $ ./linenoise_example\n    hello> get mykey\n    echo: 'get mykey'\n    hello> /mask\n    hello> *********\n\nYou can enable and disable mask mode using the following two functions:\n\n    void linenoiseMaskModeEnable(void);\n    void linenoiseMaskModeDisable(void);\n\n## Completion\n\nLinenoise supports completion, which is the ability to complete the user\ninput when she or he presses the `<TAB>` key.\n\nIn order to use completion, you need to register a completion callback, which\nis called every time the user presses `<TAB>`. Your callback will return a\nlist of items that are completions for the current string.\n\nThe following is an example of registering a completion callback:\n\n    linenoiseSetCompletionCallback(completion);\n\nThe completion must be a function returning `void` and getting as input\na `const char` pointer, which is the line the user has typed so far, and\na `linenoiseCompletions` object pointer, which is used as argument of\n`linenoiseAddCompletion` in order to add completions inside the callback.\nAn example will make it more clear:\n\n    void completion(const char *buf, linenoiseCompletions *lc) {\n        if (buf[0] == 'h') {\n            linenoiseAddCompletion(lc,\"hello\");\n            linenoiseAddCompletion(lc,\"hello there\");\n        }\n    }\n\nBasically in your completion callback, you inspect the input, and return\na list of items that are good completions by using `linenoiseAddCompletion`.\n\nIf you want to test the completion feature, compile the example program\nwith `make`, run it, type `h` and press `<TAB>`.\n\n## Hints\n\nLinenoise has a feature called *hints* which is very useful when you\nuse Linenoise in order to implement a REPL (Read Eval Print Loop) for\na program that accepts commands and arguments, but may also be useful in\nother conditions.\n\nThe feature shows, on the right of the cursor, as the user types, hints that\nmay be useful. The hints can be displayed using a different color compared\nto the color the user is typing, and can also be bold.\n\nFor example as the user starts to type `\"git remote add\"`, with hints it's\npossible to show on the right of the prompt a string `<name> <url>`.\n\nThe feature works similarly to the history feature, using a callback.\nTo register the callback we use:\n\n    linenoiseSetHintsCallback(hints);\n\nThe callback itself is implemented like this:\n\n    char *hints(const char *buf, int *color, int *bold) {\n        if (!strcasecmp(buf,\"git remote add\")) {\n            *color = 35;\n            *bold = 0;\n            return \" <name> <url>\";\n        }\n        return NULL;\n    }\n\nThe callback function returns the string that should be displayed or NULL\nif no hint is available for the text the user currently typed. The returned\nstring will be trimmed as needed depending on the number of columns available\non the screen.\n\nIt is possible to return a string allocated in dynamic way, by also registering\na function to deallocate the hint string once used:\n\n    void linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *);\n\nThe free hint callback will just receive the pointer and free the string\nas needed (depending on how the hits callback allocated it).\n\nAs you can see in the example above, a `color` (in xterm color terminal codes)\ncan be provided together with a `bold` attribute. If no color is set, the\ncurrent terminal foreground color is used. If no bold attribute is set,\nnon-bold text is printed.\n\nColor codes are:\n\n    red = 31\n    green = 32\n    yellow = 33\n    blue = 34\n    magenta = 35\n    cyan = 36\n    white = 37;\n\n## Screen handling\n\nSometimes you may want to clear the screen as a result of something the\nuser typed. You can do this by calling the following function:\n\n    void linenoiseClearScreen(void);\n\n## Asyncrhronous API\n\nSometimes you want to read from the keyboard but also from sockets or other\nexternal events, and at the same time there could be input to display to the\nuser *while* the user is typing something. Let's call this the \"IRC problem\",\nsince if you want to write an IRC client with linenoise, without using\nsome fully featured libcurses approach, you will surely end having such an\nissue.\n\nFortunately now a multiplexing friendly API exists, and it is just what the\nblocking calls internally use. To start, we need to initialize a linenoise\ncontext like this:\n\n    struct linenoiseState ls;\n    char buf[1024];\n    linenoiseEditStart(&ls,-1,-1,buf,sizeof(buf),\"some prompt> \");\n\nThe two -1 and -1 arguments are the stdin/out descriptors. If they are\nset to -1, linenoise will just use the default stdin/out file descriptors.\nNow as soon as we have data from stdin (and we know it via select(2) or\nsome other way), we can ask linenoise to read the next character with:\n\n    linenoiseEditFeed(&ls);\n\nThe function returns a `char` pointer: if the user didn't yet press enter\nto provide a line to the program, it will return `linenoiseEditMore`, that\nmeans we need to call `linenoiseEditFeed()` again when more data is\navailable. If the function returns non NULL, then this is a heap allocated\ndata (to be freed with `linenoiseFree()`) representing the user input.\nWhen the function returns NULL, than the user pressed CTRL-C or CTRL-D\nwith an empty line, to quit the program, or there was some I/O error.\n\nAfter each line is received (or if you want to quit the program, and exit raw mode), the following function needs to be called:\n\n    linenoiseEditStop(&ls);\n\nTo start reading the next line, a new linenoiseEditStart() must\nbe called, in order to reset the state, and so forth, so a typical event\nhandler called when the standard input is readable, will work similarly\nto the example below:\n\n``` c\nvoid stdinHasSomeData(void) {\n    char *line = linenoiseEditFeed(&LineNoiseState);\n    if (line == linenoiseEditMore) return;\n    linenoiseEditStop(&LineNoiseState);\n    if (line == NULL) exit(0);\n\n    printf(\"line: %s\\n\", line);\n    linenoiseFree(line);\n    linenoiseEditStart(&LineNoiseState,-1,-1,LineNoiseBuffer,sizeof(LineNoiseBuffer),\"serial> \");\n}\n```\n\nNow that we have a way to avoid blocking in the user input, we can use\ntwo calls to hide/show the edited line, so that it is possible to also\nshow some input that we received (from socekts, bluetooth, whatever) on\nscreen:\n\n    linenoiseHide(&ls);\n    printf(\"some data...\\n\");\n    linenoiseShow(&ls);\n\nTo the API calls, the linenoise example C file implements a multiplexing\nexample using select(2) and the asynchronous API:\n\n```c\n    struct linenoiseState ls;\n    char buf[1024];\n    linenoiseEditStart(&ls,-1,-1,buf,sizeof(buf),\"hello> \");\n\n    while(1) {\n        // Select(2) setup code removed...\n        retval = select(ls.ifd+1, &readfds, NULL, NULL, &tv);\n        if (retval == -1) {\n            perror(\"select()\");\n            exit(1);\n        } else if (retval) {\n            line = linenoiseEditFeed(&ls);\n            /* A NULL return means: line editing is continuing.\n             * Otherwise the user hit enter or stopped editing\n             * (CTRL+C/D). */\n            if (line != linenoiseEditMore) break;\n        } else {\n            // Timeout occurred\n            static int counter = 0;\n            linenoiseHide(&ls);\n            printf(\"Async output %d.\\n\", counter++);\n            linenoiseShow(&ls);\n        }\n    }\n    linenoiseEditStop(&ls);\n    if (line == NULL) exit(0); /* Ctrl+D/C. */\n```\n\nYou can test the example by running the example program with the `--async` option.\n\n## Related projects\n\n* [Linenoise NG](https://github.com/arangodb/linenoise-ng) is a fork of Linenoise that aims to add more advanced features like UTF-8 support, Windows support and other features. Uses C++ instead of C as development language.\n* [Linenoise-swift](https://github.com/andybest/linenoise-swift) is a reimplementation of Linenoise written in Swift.\n"
        },
        {
          "name": "example.c",
          "type": "blob",
          "size": 3.9814453125,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include \"linenoise.h\"\n\nvoid completion(const char *buf, linenoiseCompletions *lc) {\n    if (buf[0] == 'h') {\n        linenoiseAddCompletion(lc,\"hello\");\n        linenoiseAddCompletion(lc,\"hello there\");\n    }\n}\n\nchar *hints(const char *buf, int *color, int *bold) {\n    if (!strcasecmp(buf,\"hello\")) {\n        *color = 35;\n        *bold = 0;\n        return \" World\";\n    }\n    return NULL;\n}\n\nint main(int argc, char **argv) {\n    char *line;\n    char *prgname = argv[0];\n    int async = 0;\n\n    /* Parse options, with --multiline we enable multi line editing. */\n    while(argc > 1) {\n        argc--;\n        argv++;\n        if (!strcmp(*argv,\"--multiline\")) {\n            linenoiseSetMultiLine(1);\n            printf(\"Multi-line mode enabled.\\n\");\n        } else if (!strcmp(*argv,\"--keycodes\")) {\n            linenoisePrintKeyCodes();\n            exit(0);\n        } else if (!strcmp(*argv,\"--async\")) {\n            async = 1;\n        } else {\n            fprintf(stderr, \"Usage: %s [--multiline] [--keycodes] [--async]\\n\", prgname);\n            exit(1);\n        }\n    }\n\n    /* Set the completion callback. This will be called every time the\n     * user uses the <tab> key. */\n    linenoiseSetCompletionCallback(completion);\n    linenoiseSetHintsCallback(hints);\n\n    /* Load history from file. The history file is just a plain text file\n     * where entries are separated by newlines. */\n    linenoiseHistoryLoad(\"history.txt\"); /* Load the history at startup */\n\n    /* Now this is the main loop of the typical linenoise-based application.\n     * The call to linenoise() will block as long as the user types something\n     * and presses enter.\n     *\n     * The typed string is returned as a malloc() allocated string by\n     * linenoise, so the user needs to free() it. */\n\n    while(1) {\n        if (!async) {\n            line = linenoise(\"hello> \");\n            if (line == NULL) break;\n        } else {\n            /* Asynchronous mode using the multiplexing API: wait for\n             * data on stdin, and simulate async data coming from some source\n             * using the select(2) timeout. */\n            struct linenoiseState ls;\n            char buf[1024];\n            linenoiseEditStart(&ls,-1,-1,buf,sizeof(buf),\"hello> \");\n            while(1) {\n\t\tfd_set readfds;\n\t\tstruct timeval tv;\n\t\tint retval;\n\n\t\tFD_ZERO(&readfds);\n\t\tFD_SET(ls.ifd, &readfds);\n\t\ttv.tv_sec = 1; // 1 sec timeout\n\t\ttv.tv_usec = 0;\n\n\t\tretval = select(ls.ifd+1, &readfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t    perror(\"select()\");\n                    exit(1);\n\t\t} else if (retval) {\n\t\t    line = linenoiseEditFeed(&ls);\n                    /* A NULL return means: line editing is continuing.\n                     * Otherwise the user hit enter or stopped editing\n                     * (CTRL+C/D). */\n                    if (line != linenoiseEditMore) break;\n\t\t} else {\n\t\t    // Timeout occurred\n                    static int counter = 0;\n                    linenoiseHide(&ls);\n\t\t    printf(\"Async output %d.\\n\", counter++);\n                    linenoiseShow(&ls);\n\t\t}\n            }\n            linenoiseEditStop(&ls);\n            if (line == NULL) exit(0); /* Ctrl+D/C. */\n        }\n\n        /* Do something with the string. */\n        if (line[0] != '\\0' && line[0] != '/') {\n            printf(\"echo: '%s'\\n\", line);\n            linenoiseHistoryAdd(line); /* Add to the history. */\n            linenoiseHistorySave(\"history.txt\"); /* Save the history on disk. */\n        } else if (!strncmp(line,\"/historylen\",11)) {\n            /* The \"/historylen\" command will change the history len. */\n            int len = atoi(line+11);\n            linenoiseHistorySetMaxLen(len);\n        } else if (!strncmp(line, \"/mask\", 5)) {\n            linenoiseMaskModeEnable();\n        } else if (!strncmp(line, \"/unmask\", 7)) {\n            linenoiseMaskModeDisable();\n        } else if (line[0] == '/') {\n            printf(\"Unreconized command: %s\\n\", line);\n        }\n        free(line);\n    }\n    return 0;\n}\n"
        },
        {
          "name": "linenoise.c",
          "type": "blob",
          "size": 44.0654296875,
          "content": "/* linenoise.c -- guerrilla line editing library against the idea that a\n * line editing lib needs to be 20,000 lines of C code.\n *\n * You can find the latest source code at:\n *\n *   http://github.com/antirez/linenoise\n *\n * Does a number of crazy assumptions that happen to be true in 99.9999% of\n * the 2010 UNIX computers around.\n *\n * ------------------------------------------------------------------------\n *\n * Copyright (c) 2010-2023, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  *  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *  *  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * ------------------------------------------------------------------------\n *\n * References:\n * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n *\n * Todo list:\n * - Filter bogus Ctrl+<char> combinations.\n * - Win32 support\n *\n * Bloat:\n * - History search like Ctrl+r in readline?\n *\n * List of escape sequences used by this program, we do everything just\n * with three sequences. In order to be so cheap we may have some\n * flickering effect with some slow terminal, but the lesser sequences\n * the more compatible.\n *\n * EL (Erase Line)\n *    Sequence: ESC [ n K\n *    Effect: if n is 0 or missing, clear from cursor to end of line\n *    Effect: if n is 1, clear from beginning of line to cursor\n *    Effect: if n is 2, clear entire line\n *\n * CUF (CUrsor Forward)\n *    Sequence: ESC [ n C\n *    Effect: moves cursor forward n chars\n *\n * CUB (CUrsor Backward)\n *    Sequence: ESC [ n D\n *    Effect: moves cursor backward n chars\n *\n * The following is used to get the terminal width if getting\n * the width with the TIOCGWINSZ ioctl fails\n *\n * DSR (Device Status Report)\n *    Sequence: ESC [ 6 n\n *    Effect: reports the current cusor position as ESC [ n ; m R\n *            where n is the row and m is the column\n *\n * When multi line mode is enabled, we also use an additional escape\n * sequence. However multi line editing is disabled by default.\n *\n * CUU (Cursor Up)\n *    Sequence: ESC [ n A\n *    Effect: moves cursor up of n chars.\n *\n * CUD (Cursor Down)\n *    Sequence: ESC [ n B\n *    Effect: moves cursor down of n chars.\n *\n * When linenoiseClearScreen() is called, two additional escape sequences\n * are used in order to clear the screen and position the cursor at home\n * position.\n *\n * CUP (Cursor position)\n *    Sequence: ESC [ H\n *    Effect: moves the cursor to upper left corner\n *\n * ED (Erase display)\n *    Sequence: ESC [ 2 J\n *    Effect: clear the whole screen\n *\n */\n\n#include <termios.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include \"linenoise.h\"\n\n#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100\n#define LINENOISE_MAX_LINE 4096\nstatic char *unsupported_term[] = {\"dumb\",\"cons25\",\"emacs\",NULL};\nstatic linenoiseCompletionCallback *completionCallback = NULL;\nstatic linenoiseHintsCallback *hintsCallback = NULL;\nstatic linenoiseFreeHintsCallback *freeHintsCallback = NULL;\nstatic char *linenoiseNoTTY(void);\nstatic void refreshLineWithCompletion(struct linenoiseState *ls, linenoiseCompletions *lc, int flags);\nstatic void refreshLineWithFlags(struct linenoiseState *l, int flags);\n\nstatic struct termios orig_termios; /* In order to restore at exit.*/\nstatic int maskmode = 0; /* Show \"***\" instead of input. For passwords. */\nstatic int rawmode = 0; /* For atexit() function to check if restore is needed*/\nstatic int mlmode = 0;  /* Multi line mode. Default is single line. */\nstatic int atexit_registered = 0; /* Register atexit just 1 time. */\nstatic int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\nstatic int history_len = 0;\nstatic char **history = NULL;\n\nenum KEY_ACTION{\n\tKEY_NULL = 0,\t    /* NULL */\n\tCTRL_A = 1,         /* Ctrl+a */\n\tCTRL_B = 2,         /* Ctrl-b */\n\tCTRL_C = 3,         /* Ctrl-c */\n\tCTRL_D = 4,         /* Ctrl-d */\n\tCTRL_E = 5,         /* Ctrl-e */\n\tCTRL_F = 6,         /* Ctrl-f */\n\tCTRL_H = 8,         /* Ctrl-h */\n\tTAB = 9,            /* Tab */\n\tCTRL_K = 11,        /* Ctrl+k */\n\tCTRL_L = 12,        /* Ctrl+l */\n\tENTER = 13,         /* Enter */\n\tCTRL_N = 14,        /* Ctrl-n */\n\tCTRL_P = 16,        /* Ctrl-p */\n\tCTRL_T = 20,        /* Ctrl-t */\n\tCTRL_U = 21,        /* Ctrl+u */\n\tCTRL_W = 23,        /* Ctrl+w */\n\tESC = 27,           /* Escape */\n\tBACKSPACE =  127    /* Backspace */\n};\n\nstatic void linenoiseAtExit(void);\nint linenoiseHistoryAdd(const char *line);\n#define REFRESH_CLEAN (1<<0)    // Clean the old prompt from the screen\n#define REFRESH_WRITE (1<<1)    // Rewrite the prompt on the screen.\n#define REFRESH_ALL (REFRESH_CLEAN|REFRESH_WRITE) // Do both.\nstatic void refreshLine(struct linenoiseState *l);\n\n/* Debugging macro. */\n#if 0\nFILE *lndebug_fp = NULL;\n#define lndebug(...) \\\n    do { \\\n        if (lndebug_fp == NULL) { \\\n            lndebug_fp = fopen(\"/tmp/lndebug.txt\",\"a\"); \\\n            fprintf(lndebug_fp, \\\n            \"[%d %d %d] p: %d, rows: %d, rpos: %d, max: %d, oldmax: %d\\n\", \\\n            (int)l->len,(int)l->pos,(int)l->oldpos,plen,rows,rpos, \\\n            (int)l->oldrows,old_rows); \\\n        } \\\n        fprintf(lndebug_fp, \", \" __VA_ARGS__); \\\n        fflush(lndebug_fp); \\\n    } while (0)\n#else\n#define lndebug(fmt, ...)\n#endif\n\n/* ======================= Low level terminal handling ====================== */\n\n/* Enable \"mask mode\". When it is enabled, instead of the input that\n * the user is typing, the terminal will just display a corresponding\n * number of asterisks, like \"****\". This is useful for passwords and other\n * secrets that should not be displayed. */\nvoid linenoiseMaskModeEnable(void) {\n    maskmode = 1;\n}\n\n/* Disable mask mode. */\nvoid linenoiseMaskModeDisable(void) {\n    maskmode = 0;\n}\n\n/* Set if to use or not the multi line mode. */\nvoid linenoiseSetMultiLine(int ml) {\n    mlmode = ml;\n}\n\n/* Return true if the terminal name is in the list of terminals we know are\n * not able to understand basic escape sequences. */\nstatic int isUnsupportedTerm(void) {\n    char *term = getenv(\"TERM\");\n    int j;\n\n    if (term == NULL) return 0;\n    for (j = 0; unsupported_term[j]; j++)\n        if (!strcasecmp(term,unsupported_term[j])) return 1;\n    return 0;\n}\n\n/* Raw mode: 1960 magic shit. */\nstatic int enableRawMode(int fd) {\n    struct termios raw;\n\n    if (!isatty(STDIN_FILENO)) goto fatal;\n    if (!atexit_registered) {\n        atexit(linenoiseAtExit);\n        atexit_registered = 1;\n    }\n    if (tcgetattr(fd,&orig_termios) == -1) goto fatal;\n\n    raw = orig_termios;  /* modify the original mode */\n    /* input modes: no break, no CR to NL, no parity check, no strip char,\n     * no start/stop output control. */\n    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n    /* output modes - disable post processing */\n    raw.c_oflag &= ~(OPOST);\n    /* control modes - set 8 bit chars */\n    raw.c_cflag |= (CS8);\n    /* local modes - choing off, canonical off, no extended functions,\n     * no signal chars (^Z,^C) */\n    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n    /* control chars - set return condition: min number of bytes and timer.\n     * We want read to return every single byte, without timeout. */\n    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n\n    /* put terminal in raw mode after flushing */\n    if (tcsetattr(fd,TCSAFLUSH,&raw) < 0) goto fatal;\n    rawmode = 1;\n    return 0;\n\nfatal:\n    errno = ENOTTY;\n    return -1;\n}\n\nstatic void disableRawMode(int fd) {\n    /* Don't even check the return value as it's too late. */\n    if (rawmode && tcsetattr(fd,TCSAFLUSH,&orig_termios) != -1)\n        rawmode = 0;\n}\n\n/* Use the ESC [6n escape sequence to query the horizontal cursor position\n * and return it. On error -1 is returned, on success the position of the\n * cursor. */\nstatic int getCursorPosition(int ifd, int ofd) {\n    char buf[32];\n    int cols, rows;\n    unsigned int i = 0;\n\n    /* Report cursor location */\n    if (write(ofd, \"\\x1b[6n\", 4) != 4) return -1;\n\n    /* Read the response: ESC [ rows ; cols R */\n    while (i < sizeof(buf)-1) {\n        if (read(ifd,buf+i,1) != 1) break;\n        if (buf[i] == 'R') break;\n        i++;\n    }\n    buf[i] = '\\0';\n\n    /* Parse it. */\n    if (buf[0] != ESC || buf[1] != '[') return -1;\n    if (sscanf(buf+2,\"%d;%d\",&rows,&cols) != 2) return -1;\n    return cols;\n}\n\n/* Try to get the number of columns in the current terminal, or assume 80\n * if it fails. */\nstatic int getColumns(int ifd, int ofd) {\n    struct winsize ws;\n\n    if (ioctl(1, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {\n        /* ioctl() failed. Try to query the terminal itself. */\n        int start, cols;\n\n        /* Get the initial position so we can restore it later. */\n        start = getCursorPosition(ifd,ofd);\n        if (start == -1) goto failed;\n\n        /* Go to right margin and get position. */\n        if (write(ofd,\"\\x1b[999C\",6) != 6) goto failed;\n        cols = getCursorPosition(ifd,ofd);\n        if (cols == -1) goto failed;\n\n        /* Restore position. */\n        if (cols > start) {\n            char seq[32];\n            snprintf(seq,32,\"\\x1b[%dD\",cols-start);\n            if (write(ofd,seq,strlen(seq)) == -1) {\n                /* Can't recover... */\n            }\n        }\n        return cols;\n    } else {\n        return ws.ws_col;\n    }\n\nfailed:\n    return 80;\n}\n\n/* Clear the screen. Used to handle ctrl+l */\nvoid linenoiseClearScreen(void) {\n    if (write(STDOUT_FILENO,\"\\x1b[H\\x1b[2J\",7) <= 0) {\n        /* nothing to do, just to avoid warning. */\n    }\n}\n\n/* Beep, used for completion when there is nothing to complete or when all\n * the choices were already shown. */\nstatic void linenoiseBeep(void) {\n    fprintf(stderr, \"\\x7\");\n    fflush(stderr);\n}\n\n/* ============================== Completion ================================ */\n\n/* Free a list of completion option populated by linenoiseAddCompletion(). */\nstatic void freeCompletions(linenoiseCompletions *lc) {\n    size_t i;\n    for (i = 0; i < lc->len; i++)\n        free(lc->cvec[i]);\n    if (lc->cvec != NULL)\n        free(lc->cvec);\n}\n\n/* Called by completeLine() and linenoiseShow() to render the current\n * edited line with the proposed completion. If the current completion table\n * is already available, it is passed as second argument, otherwise the\n * function will use the callback to obtain it.\n *\n * Flags are the same as refreshLine*(), that is REFRESH_* macros. */\nstatic void refreshLineWithCompletion(struct linenoiseState *ls, linenoiseCompletions *lc, int flags) {\n    /* Obtain the table of completions if the caller didn't provide one. */\n    linenoiseCompletions ctable = { 0, NULL };\n    if (lc == NULL) {\n        completionCallback(ls->buf,&ctable);\n        lc = &ctable;\n    }\n\n    /* Show the edited line with completion if possible, or just refresh. */\n    if (ls->completion_idx < lc->len) {\n        struct linenoiseState saved = *ls;\n        ls->len = ls->pos = strlen(lc->cvec[ls->completion_idx]);\n        ls->buf = lc->cvec[ls->completion_idx];\n        refreshLineWithFlags(ls,flags);\n        ls->len = saved.len;\n        ls->pos = saved.pos;\n        ls->buf = saved.buf;\n    } else {\n        refreshLineWithFlags(ls,flags);\n    }\n\n    /* Free the completions table if needed. */\n    if (lc != &ctable) freeCompletions(&ctable);\n}\n\n/* This is an helper function for linenoiseEdit*() and is called when the\n * user types the <tab> key in order to complete the string currently in the\n * input.\n *\n * The state of the editing is encapsulated into the pointed linenoiseState\n * structure as described in the structure definition.\n *\n * If the function returns non-zero, the caller should handle the\n * returned value as a byte read from the standard input, and process\n * it as usually: this basically means that the function may return a byte\n * read from the termianl but not processed. Otherwise, if zero is returned,\n * the input was consumed by the completeLine() function to navigate the\n * possible completions, and the caller should read for the next characters\n * from stdin. */\nstatic int completeLine(struct linenoiseState *ls, int keypressed) {\n    linenoiseCompletions lc = { 0, NULL };\n    int nwritten;\n    char c = keypressed;\n\n    completionCallback(ls->buf,&lc);\n    if (lc.len == 0) {\n        linenoiseBeep();\n        ls->in_completion = 0;\n    } else {\n        switch(c) {\n            case 9: /* tab */\n                if (ls->in_completion == 0) {\n                    ls->in_completion = 1;\n                    ls->completion_idx = 0;\n                } else {\n                    ls->completion_idx = (ls->completion_idx+1) % (lc.len+1);\n                    if (ls->completion_idx == lc.len) linenoiseBeep();\n                }\n                c = 0;\n                break;\n            case 27: /* escape */\n                /* Re-show original buffer */\n                if (ls->completion_idx < lc.len) refreshLine(ls);\n                ls->in_completion = 0;\n                c = 0;\n                break;\n            default:\n                /* Update buffer and return */\n                if (ls->completion_idx < lc.len) {\n                    nwritten = snprintf(ls->buf,ls->buflen,\"%s\",\n                        lc.cvec[ls->completion_idx]);\n                    ls->len = ls->pos = nwritten;\n                }\n                ls->in_completion = 0;\n                break;\n        }\n\n        /* Show completion or original buffer */\n        if (ls->in_completion && ls->completion_idx < lc.len) {\n            refreshLineWithCompletion(ls,&lc,REFRESH_ALL);\n        } else {\n            refreshLine(ls);\n        }\n    }\n\n    freeCompletions(&lc);\n    return c; /* Return last read character */\n}\n\n/* Register a callback function to be called for tab-completion. */\nvoid linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {\n    completionCallback = fn;\n}\n\n/* Register a hits function to be called to show hits to the user at the\n * right of the prompt. */\nvoid linenoiseSetHintsCallback(linenoiseHintsCallback *fn) {\n    hintsCallback = fn;\n}\n\n/* Register a function to free the hints returned by the hints callback\n * registered with linenoiseSetHintsCallback(). */\nvoid linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *fn) {\n    freeHintsCallback = fn;\n}\n\n/* This function is used by the callback function registered by the user\n * in order to add completion options given the input string when the\n * user typed <tab>. See the example.c source code for a very easy to\n * understand example. */\nvoid linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {\n    size_t len = strlen(str);\n    char *copy, **cvec;\n\n    copy = malloc(len+1);\n    if (copy == NULL) return;\n    memcpy(copy,str,len+1);\n    cvec = realloc(lc->cvec,sizeof(char*)*(lc->len+1));\n    if (cvec == NULL) {\n        free(copy);\n        return;\n    }\n    lc->cvec = cvec;\n    lc->cvec[lc->len++] = copy;\n}\n\n/* =========================== Line editing ================================= */\n\n/* We define a very simple \"append buffer\" structure, that is an heap\n * allocated string where we can append to. This is useful in order to\n * write all the escape sequences in a buffer and flush them to the standard\n * output in a single call, to avoid flickering effects. */\nstruct abuf {\n    char *b;\n    int len;\n};\n\nstatic void abInit(struct abuf *ab) {\n    ab->b = NULL;\n    ab->len = 0;\n}\n\nstatic void abAppend(struct abuf *ab, const char *s, int len) {\n    char *new = realloc(ab->b,ab->len+len);\n\n    if (new == NULL) return;\n    memcpy(new+ab->len,s,len);\n    ab->b = new;\n    ab->len += len;\n}\n\nstatic void abFree(struct abuf *ab) {\n    free(ab->b);\n}\n\n/* Helper of refreshSingleLine() and refreshMultiLine() to show hints\n * to the right of the prompt. */\nvoid refreshShowHints(struct abuf *ab, struct linenoiseState *l, int plen) {\n    char seq[64];\n    if (hintsCallback && plen+l->len < l->cols) {\n        int color = -1, bold = 0;\n        char *hint = hintsCallback(l->buf,&color,&bold);\n        if (hint) {\n            int hintlen = strlen(hint);\n            int hintmaxlen = l->cols-(plen+l->len);\n            if (hintlen > hintmaxlen) hintlen = hintmaxlen;\n            if (bold == 1 && color == -1) color = 37;\n            if (color != -1 || bold != 0)\n                snprintf(seq,64,\"\\033[%d;%d;49m\",bold,color);\n            else\n                seq[0] = '\\0';\n            abAppend(ab,seq,strlen(seq));\n            abAppend(ab,hint,hintlen);\n            if (color != -1 || bold != 0)\n                abAppend(ab,\"\\033[0m\",4);\n            /* Call the function to free the hint returned. */\n            if (freeHintsCallback) freeHintsCallback(hint);\n        }\n    }\n}\n\n/* Single line low level line refresh.\n *\n * Rewrite the currently edited line accordingly to the buffer content,\n * cursor position, and number of columns of the terminal.\n *\n * Flags is REFRESH_* macros. The function can just remove the old\n * prompt, just write it, or both. */\nstatic void refreshSingleLine(struct linenoiseState *l, int flags) {\n    char seq[64];\n    size_t plen = strlen(l->prompt);\n    int fd = l->ofd;\n    char *buf = l->buf;\n    size_t len = l->len;\n    size_t pos = l->pos;\n    struct abuf ab;\n\n    while((plen+pos) >= l->cols) {\n        buf++;\n        len--;\n        pos--;\n    }\n    while (plen+len > l->cols) {\n        len--;\n    }\n\n    abInit(&ab);\n    /* Cursor to left edge */\n    snprintf(seq,sizeof(seq),\"\\r\");\n    abAppend(&ab,seq,strlen(seq));\n\n    if (flags & REFRESH_WRITE) {\n        /* Write the prompt and the current buffer content */\n        abAppend(&ab,l->prompt,strlen(l->prompt));\n        if (maskmode == 1) {\n            while (len--) abAppend(&ab,\"*\",1);\n        } else {\n            abAppend(&ab,buf,len);\n        }\n        /* Show hits if any. */\n        refreshShowHints(&ab,l,plen);\n    }\n\n    /* Erase to right */\n    snprintf(seq,sizeof(seq),\"\\x1b[0K\");\n    abAppend(&ab,seq,strlen(seq));\n\n    if (flags & REFRESH_WRITE) {\n        /* Move cursor to original position. */\n        snprintf(seq,sizeof(seq),\"\\r\\x1b[%dC\", (int)(pos+plen));\n        abAppend(&ab,seq,strlen(seq));\n    }\n\n    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */\n    abFree(&ab);\n}\n\n/* Multi line low level line refresh.\n *\n * Rewrite the currently edited line accordingly to the buffer content,\n * cursor position, and number of columns of the terminal.\n *\n * Flags is REFRESH_* macros. The function can just remove the old\n * prompt, just write it, or both. */\nstatic void refreshMultiLine(struct linenoiseState *l, int flags) {\n    char seq[64];\n    int plen = strlen(l->prompt);\n    int rows = (plen+l->len+l->cols-1)/l->cols; /* rows used by current buf. */\n    int rpos = (plen+l->oldpos+l->cols)/l->cols; /* cursor relative row. */\n    int rpos2; /* rpos after refresh. */\n    int col; /* colum position, zero-based. */\n    int old_rows = l->oldrows;\n    int fd = l->ofd, j;\n    struct abuf ab;\n\n    l->oldrows = rows;\n\n    /* First step: clear all the lines used before. To do so start by\n     * going to the last row. */\n    abInit(&ab);\n\n    if (flags & REFRESH_CLEAN) {\n        if (old_rows-rpos > 0) {\n            lndebug(\"go down %d\", old_rows-rpos);\n            snprintf(seq,64,\"\\x1b[%dB\", old_rows-rpos);\n            abAppend(&ab,seq,strlen(seq));\n        }\n\n        /* Now for every row clear it, go up. */\n        for (j = 0; j < old_rows-1; j++) {\n            lndebug(\"clear+up\");\n            snprintf(seq,64,\"\\r\\x1b[0K\\x1b[1A\");\n            abAppend(&ab,seq,strlen(seq));\n        }\n    }\n\n    if (flags & REFRESH_ALL) {\n        /* Clean the top line. */\n        lndebug(\"clear\");\n        snprintf(seq,64,\"\\r\\x1b[0K\");\n        abAppend(&ab,seq,strlen(seq));\n    }\n\n    if (flags & REFRESH_WRITE) {\n        /* Write the prompt and the current buffer content */\n        abAppend(&ab,l->prompt,strlen(l->prompt));\n        if (maskmode == 1) {\n            unsigned int i;\n            for (i = 0; i < l->len; i++) abAppend(&ab,\"*\",1);\n        } else {\n            abAppend(&ab,l->buf,l->len);\n        }\n\n        /* Show hits if any. */\n        refreshShowHints(&ab,l,plen);\n\n        /* If we are at the very end of the screen with our prompt, we need to\n         * emit a newline and move the prompt to the first column. */\n        if (l->pos &&\n            l->pos == l->len &&\n            (l->pos+plen) % l->cols == 0)\n        {\n            lndebug(\"<newline>\");\n            abAppend(&ab,\"\\n\",1);\n            snprintf(seq,64,\"\\r\");\n            abAppend(&ab,seq,strlen(seq));\n            rows++;\n            if (rows > (int)l->oldrows) l->oldrows = rows;\n        }\n\n        /* Move cursor to right position. */\n        rpos2 = (plen+l->pos+l->cols)/l->cols; /* Current cursor relative row */\n        lndebug(\"rpos2 %d\", rpos2);\n\n        /* Go up till we reach the expected positon. */\n        if (rows-rpos2 > 0) {\n            lndebug(\"go-up %d\", rows-rpos2);\n            snprintf(seq,64,\"\\x1b[%dA\", rows-rpos2);\n            abAppend(&ab,seq,strlen(seq));\n        }\n\n        /* Set column. */\n        col = (plen+(int)l->pos) % (int)l->cols;\n        lndebug(\"set col %d\", 1+col);\n        if (col)\n            snprintf(seq,64,\"\\r\\x1b[%dC\", col);\n        else\n            snprintf(seq,64,\"\\r\");\n        abAppend(&ab,seq,strlen(seq));\n    }\n\n    lndebug(\"\\n\");\n    l->oldpos = l->pos;\n\n    if (write(fd,ab.b,ab.len) == -1) {} /* Can't recover from write error. */\n    abFree(&ab);\n}\n\n/* Calls the two low level functions refreshSingleLine() or\n * refreshMultiLine() according to the selected mode. */\nstatic void refreshLineWithFlags(struct linenoiseState *l, int flags) {\n    if (mlmode)\n        refreshMultiLine(l,flags);\n    else\n        refreshSingleLine(l,flags);\n}\n\n/* Utility function to avoid specifying REFRESH_ALL all the times. */\nstatic void refreshLine(struct linenoiseState *l) {\n    refreshLineWithFlags(l,REFRESH_ALL);\n}\n\n/* Hide the current line, when using the multiplexing API. */\nvoid linenoiseHide(struct linenoiseState *l) {\n    if (mlmode)\n        refreshMultiLine(l,REFRESH_CLEAN);\n    else\n        refreshSingleLine(l,REFRESH_CLEAN);\n}\n\n/* Show the current line, when using the multiplexing API. */\nvoid linenoiseShow(struct linenoiseState *l) {\n    if (l->in_completion) {\n        refreshLineWithCompletion(l,NULL,REFRESH_WRITE);\n    } else {\n        refreshLineWithFlags(l,REFRESH_WRITE);\n    }\n}\n\n/* Insert the character 'c' at cursor current position.\n *\n * On error writing to the terminal -1 is returned, otherwise 0. */\nint linenoiseEditInsert(struct linenoiseState *l, char c) {\n    if (l->len < l->buflen) {\n        if (l->len == l->pos) {\n            l->buf[l->pos] = c;\n            l->pos++;\n            l->len++;\n            l->buf[l->len] = '\\0';\n            if ((!mlmode && l->plen+l->len < l->cols && !hintsCallback)) {\n                /* Avoid a full update of the line in the\n                 * trivial case. */\n                char d = (maskmode==1) ? '*' : c;\n                if (write(l->ofd,&d,1) == -1) return -1;\n            } else {\n                refreshLine(l);\n            }\n        } else {\n            memmove(l->buf+l->pos+1,l->buf+l->pos,l->len-l->pos);\n            l->buf[l->pos] = c;\n            l->len++;\n            l->pos++;\n            l->buf[l->len] = '\\0';\n            refreshLine(l);\n        }\n    }\n    return 0;\n}\n\n/* Move cursor on the left. */\nvoid linenoiseEditMoveLeft(struct linenoiseState *l) {\n    if (l->pos > 0) {\n        l->pos--;\n        refreshLine(l);\n    }\n}\n\n/* Move cursor on the right. */\nvoid linenoiseEditMoveRight(struct linenoiseState *l) {\n    if (l->pos != l->len) {\n        l->pos++;\n        refreshLine(l);\n    }\n}\n\n/* Move cursor to the start of the line. */\nvoid linenoiseEditMoveHome(struct linenoiseState *l) {\n    if (l->pos != 0) {\n        l->pos = 0;\n        refreshLine(l);\n    }\n}\n\n/* Move cursor to the end of the line. */\nvoid linenoiseEditMoveEnd(struct linenoiseState *l) {\n    if (l->pos != l->len) {\n        l->pos = l->len;\n        refreshLine(l);\n    }\n}\n\n/* Substitute the currently edited line with the next or previous history\n * entry as specified by 'dir'. */\n#define LINENOISE_HISTORY_NEXT 0\n#define LINENOISE_HISTORY_PREV 1\nvoid linenoiseEditHistoryNext(struct linenoiseState *l, int dir) {\n    if (history_len > 1) {\n        /* Update the current history entry before to\n         * overwrite it with the next one. */\n        free(history[history_len - 1 - l->history_index]);\n        history[history_len - 1 - l->history_index] = strdup(l->buf);\n        /* Show the new entry */\n        l->history_index += (dir == LINENOISE_HISTORY_PREV) ? 1 : -1;\n        if (l->history_index < 0) {\n            l->history_index = 0;\n            return;\n        } else if (l->history_index >= history_len) {\n            l->history_index = history_len-1;\n            return;\n        }\n        strncpy(l->buf,history[history_len - 1 - l->history_index],l->buflen);\n        l->buf[l->buflen-1] = '\\0';\n        l->len = l->pos = strlen(l->buf);\n        refreshLine(l);\n    }\n}\n\n/* Delete the character at the right of the cursor without altering the cursor\n * position. Basically this is what happens with the \"Delete\" keyboard key. */\nvoid linenoiseEditDelete(struct linenoiseState *l) {\n    if (l->len > 0 && l->pos < l->len) {\n        memmove(l->buf+l->pos,l->buf+l->pos+1,l->len-l->pos-1);\n        l->len--;\n        l->buf[l->len] = '\\0';\n        refreshLine(l);\n    }\n}\n\n/* Backspace implementation. */\nvoid linenoiseEditBackspace(struct linenoiseState *l) {\n    if (l->pos > 0 && l->len > 0) {\n        memmove(l->buf+l->pos-1,l->buf+l->pos,l->len-l->pos);\n        l->pos--;\n        l->len--;\n        l->buf[l->len] = '\\0';\n        refreshLine(l);\n    }\n}\n\n/* Delete the previosu word, maintaining the cursor at the start of the\n * current word. */\nvoid linenoiseEditDeletePrevWord(struct linenoiseState *l) {\n    size_t old_pos = l->pos;\n    size_t diff;\n\n    while (l->pos > 0 && l->buf[l->pos-1] == ' ')\n        l->pos--;\n    while (l->pos > 0 && l->buf[l->pos-1] != ' ')\n        l->pos--;\n    diff = old_pos - l->pos;\n    memmove(l->buf+l->pos,l->buf+old_pos,l->len-old_pos+1);\n    l->len -= diff;\n    refreshLine(l);\n}\n\n/* This function is part of the multiplexed API of Linenoise, that is used\n * in order to implement the blocking variant of the API but can also be\n * called by the user directly in an event driven program. It will:\n *\n * 1. Initialize the linenoise state passed by the user.\n * 2. Put the terminal in RAW mode.\n * 3. Show the prompt.\n * 4. Return control to the user, that will have to call linenoiseEditFeed()\n *    each time there is some data arriving in the standard input.\n *\n * The user can also call linenoiseEditHide() and linenoiseEditShow() if it\n * is required to show some input arriving asyncronously, without mixing\n * it with the currently edited line.\n *\n * When linenoiseEditFeed() returns non-NULL, the user finished with the\n * line editing session (pressed enter CTRL-D/C): in this case the caller\n * needs to call linenoiseEditStop() to put back the terminal in normal\n * mode. This will not destroy the buffer, as long as the linenoiseState\n * is still valid in the context of the caller.\n *\n * The function returns 0 on success, or -1 if writing to standard output\n * fails. If stdin_fd or stdout_fd are set to -1, the default is to use\n * STDIN_FILENO and STDOUT_FILENO.\n */\nint linenoiseEditStart(struct linenoiseState *l, int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt) {\n    /* Populate the linenoise state that we pass to functions implementing\n     * specific editing functionalities. */\n    l->in_completion = 0;\n    l->ifd = stdin_fd != -1 ? stdin_fd : STDIN_FILENO;\n    l->ofd = stdout_fd != -1 ? stdout_fd : STDOUT_FILENO;\n    l->buf = buf;\n    l->buflen = buflen;\n    l->prompt = prompt;\n    l->plen = strlen(prompt);\n    l->oldpos = l->pos = 0;\n    l->len = 0;\n\n    /* Enter raw mode. */\n    if (enableRawMode(l->ifd) == -1) return -1;\n\n    l->cols = getColumns(stdin_fd, stdout_fd);\n    l->oldrows = 0;\n    l->history_index = 0;\n\n    /* Buffer starts empty. */\n    l->buf[0] = '\\0';\n    l->buflen--; /* Make sure there is always space for the nulterm */\n\n    /* If stdin is not a tty, stop here with the initialization. We\n     * will actually just read a line from standard input in blocking\n     * mode later, in linenoiseEditFeed(). */\n    if (!isatty(l->ifd)) return 0;\n\n    /* The latest history entry is always our current buffer, that\n     * initially is just an empty string. */\n    linenoiseHistoryAdd(\"\");\n\n    if (write(l->ofd,prompt,l->plen) == -1) return -1;\n    return 0;\n}\n\nchar *linenoiseEditMore = \"If you see this, you are misusing the API: when linenoiseEditFeed() is called, if it returns linenoiseEditMore the user is yet editing the line. See the README file for more information.\";\n\n/* This function is part of the multiplexed API of linenoise, see the top\n * comment on linenoiseEditStart() for more information. Call this function\n * each time there is some data to read from the standard input file\n * descriptor. In the case of blocking operations, this function can just be\n * called in a loop, and block.\n *\n * The function returns linenoiseEditMore to signal that line editing is still\n * in progress, that is, the user didn't yet pressed enter / CTRL-D. Otherwise\n * the function returns the pointer to the heap-allocated buffer with the\n * edited line, that the user should free with linenoiseFree().\n *\n * On special conditions, NULL is returned and errno is populated:\n *\n * EAGAIN if the user pressed Ctrl-C\n * ENOENT if the user pressed Ctrl-D\n *\n * Some other errno: I/O error.\n */\nchar *linenoiseEditFeed(struct linenoiseState *l) {\n    /* Not a TTY, pass control to line reading without character\n     * count limits. */\n    if (!isatty(l->ifd)) return linenoiseNoTTY();\n\n    char c;\n    int nread;\n    char seq[3];\n\n    nread = read(l->ifd,&c,1);\n    if (nread <= 0) return NULL;\n\n    /* Only autocomplete when the callback is set. It returns < 0 when\n     * there was an error reading from fd. Otherwise it will return the\n     * character that should be handled next. */\n    if ((l->in_completion || c == 9) && completionCallback != NULL) {\n        c = completeLine(l,c);\n        /* Return on errors */\n        if (c < 0) return NULL;\n        /* Read next character when 0 */\n        if (c == 0) return linenoiseEditMore;\n    }\n\n    switch(c) {\n    case ENTER:    /* enter */\n        history_len--;\n        free(history[history_len]);\n        if (mlmode) linenoiseEditMoveEnd(l);\n        if (hintsCallback) {\n            /* Force a refresh without hints to leave the previous\n             * line as the user typed it after a newline. */\n            linenoiseHintsCallback *hc = hintsCallback;\n            hintsCallback = NULL;\n            refreshLine(l);\n            hintsCallback = hc;\n        }\n        return strdup(l->buf);\n    case CTRL_C:     /* ctrl-c */\n        errno = EAGAIN;\n        return NULL;\n    case BACKSPACE:   /* backspace */\n    case 8:     /* ctrl-h */\n        linenoiseEditBackspace(l);\n        break;\n    case CTRL_D:     /* ctrl-d, remove char at right of cursor, or if the\n                        line is empty, act as end-of-file. */\n        if (l->len > 0) {\n            linenoiseEditDelete(l);\n        } else {\n            history_len--;\n            free(history[history_len]);\n            errno = ENOENT;\n            return NULL;\n        }\n        break;\n    case CTRL_T:    /* ctrl-t, swaps current character with previous. */\n        if (l->pos > 0 && l->pos < l->len) {\n            int aux = l->buf[l->pos-1];\n            l->buf[l->pos-1] = l->buf[l->pos];\n            l->buf[l->pos] = aux;\n            if (l->pos != l->len-1) l->pos++;\n            refreshLine(l);\n        }\n        break;\n    case CTRL_B:     /* ctrl-b */\n        linenoiseEditMoveLeft(l);\n        break;\n    case CTRL_F:     /* ctrl-f */\n        linenoiseEditMoveRight(l);\n        break;\n    case CTRL_P:    /* ctrl-p */\n        linenoiseEditHistoryNext(l, LINENOISE_HISTORY_PREV);\n        break;\n    case CTRL_N:    /* ctrl-n */\n        linenoiseEditHistoryNext(l, LINENOISE_HISTORY_NEXT);\n        break;\n    case ESC:    /* escape sequence */\n        /* Read the next two bytes representing the escape sequence.\n         * Use two calls to handle slow terminals returning the two\n         * chars at different times. */\n        if (read(l->ifd,seq,1) == -1) break;\n        if (read(l->ifd,seq+1,1) == -1) break;\n\n        /* ESC [ sequences. */\n        if (seq[0] == '[') {\n            if (seq[1] >= '0' && seq[1] <= '9') {\n                /* Extended escape, read additional byte. */\n                if (read(l->ifd,seq+2,1) == -1) break;\n                if (seq[2] == '~') {\n                    switch(seq[1]) {\n                    case '3': /* Delete key. */\n                        linenoiseEditDelete(l);\n                        break;\n                    }\n                }\n            } else {\n                switch(seq[1]) {\n                case 'A': /* Up */\n                    linenoiseEditHistoryNext(l, LINENOISE_HISTORY_PREV);\n                    break;\n                case 'B': /* Down */\n                    linenoiseEditHistoryNext(l, LINENOISE_HISTORY_NEXT);\n                    break;\n                case 'C': /* Right */\n                    linenoiseEditMoveRight(l);\n                    break;\n                case 'D': /* Left */\n                    linenoiseEditMoveLeft(l);\n                    break;\n                case 'H': /* Home */\n                    linenoiseEditMoveHome(l);\n                    break;\n                case 'F': /* End*/\n                    linenoiseEditMoveEnd(l);\n                    break;\n                }\n            }\n        }\n\n        /* ESC O sequences. */\n        else if (seq[0] == 'O') {\n            switch(seq[1]) {\n            case 'H': /* Home */\n                linenoiseEditMoveHome(l);\n                break;\n            case 'F': /* End*/\n                linenoiseEditMoveEnd(l);\n                break;\n            }\n        }\n        break;\n    default:\n        if (linenoiseEditInsert(l,c)) return NULL;\n        break;\n    case CTRL_U: /* Ctrl+u, delete the whole line. */\n        l->buf[0] = '\\0';\n        l->pos = l->len = 0;\n        refreshLine(l);\n        break;\n    case CTRL_K: /* Ctrl+k, delete from current to end of line. */\n        l->buf[l->pos] = '\\0';\n        l->len = l->pos;\n        refreshLine(l);\n        break;\n    case CTRL_A: /* Ctrl+a, go to the start of the line */\n        linenoiseEditMoveHome(l);\n        break;\n    case CTRL_E: /* ctrl+e, go to the end of the line */\n        linenoiseEditMoveEnd(l);\n        break;\n    case CTRL_L: /* ctrl+l, clear screen */\n        linenoiseClearScreen();\n        refreshLine(l);\n        break;\n    case CTRL_W: /* ctrl+w, delete previous word */\n        linenoiseEditDeletePrevWord(l);\n        break;\n    }\n    return linenoiseEditMore;\n}\n\n/* This is part of the multiplexed linenoise API. See linenoiseEditStart()\n * for more information. This function is called when linenoiseEditFeed()\n * returns something different than NULL. At this point the user input\n * is in the buffer, and we can restore the terminal in normal mode. */\nvoid linenoiseEditStop(struct linenoiseState *l) {\n    if (!isatty(l->ifd)) return;\n    disableRawMode(l->ifd);\n    printf(\"\\n\");\n}\n\n/* This just implements a blocking loop for the multiplexed API.\n * In many applications that are not event-drivern, we can just call\n * the blocking linenoise API, wait for the user to complete the editing\n * and return the buffer. */\nstatic char *linenoiseBlockingEdit(int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt)\n{\n    struct linenoiseState l;\n\n    /* Editing without a buffer is invalid. */\n    if (buflen == 0) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    linenoiseEditStart(&l,stdin_fd,stdout_fd,buf,buflen,prompt);\n    char *res;\n    while((res = linenoiseEditFeed(&l)) == linenoiseEditMore);\n    linenoiseEditStop(&l);\n    return res;\n}\n\n/* This special mode is used by linenoise in order to print scan codes\n * on screen for debugging / development purposes. It is implemented\n * by the linenoise_example program using the --keycodes option. */\nvoid linenoisePrintKeyCodes(void) {\n    char quit[4];\n\n    printf(\"Linenoise key codes debugging mode.\\n\"\n            \"Press keys to see scan codes. Type 'quit' at any time to exit.\\n\");\n    if (enableRawMode(STDIN_FILENO) == -1) return;\n    memset(quit,' ',4);\n    while(1) {\n        char c;\n        int nread;\n\n        nread = read(STDIN_FILENO,&c,1);\n        if (nread <= 0) continue;\n        memmove(quit,quit+1,sizeof(quit)-1); /* shift string to left. */\n        quit[sizeof(quit)-1] = c; /* Insert current char on the right. */\n        if (memcmp(quit,\"quit\",sizeof(quit)) == 0) break;\n\n        printf(\"'%c' %02x (%d) (type quit to exit)\\n\",\n            isprint(c) ? c : '?', (int)c, (int)c);\n        printf(\"\\r\"); /* Go left edge manually, we are in raw mode. */\n        fflush(stdout);\n    }\n    disableRawMode(STDIN_FILENO);\n}\n\n/* This function is called when linenoise() is called with the standard\n * input file descriptor not attached to a TTY. So for example when the\n * program using linenoise is called in pipe or with a file redirected\n * to its standard input. In this case, we want to be able to return the\n * line regardless of its length (by default we are limited to 4k). */\nstatic char *linenoiseNoTTY(void) {\n    char *line = NULL;\n    size_t len = 0, maxlen = 0;\n\n    while(1) {\n        if (len == maxlen) {\n            if (maxlen == 0) maxlen = 16;\n            maxlen *= 2;\n            char *oldval = line;\n            line = realloc(line,maxlen);\n            if (line == NULL) {\n                if (oldval) free(oldval);\n                return NULL;\n            }\n        }\n        int c = fgetc(stdin);\n        if (c == EOF || c == '\\n') {\n            if (c == EOF && len == 0) {\n                free(line);\n                return NULL;\n            } else {\n                line[len] = '\\0';\n                return line;\n            }\n        } else {\n            line[len] = c;\n            len++;\n        }\n    }\n}\n\n/* The high level function that is the main API of the linenoise library.\n * This function checks if the terminal has basic capabilities, just checking\n * for a blacklist of stupid terminals, and later either calls the line\n * editing function or uses dummy fgets() so that you will be able to type\n * something even in the most desperate of the conditions. */\nchar *linenoise(const char *prompt) {\n    char buf[LINENOISE_MAX_LINE];\n\n    if (!isatty(STDIN_FILENO)) {\n        /* Not a tty: read from file / pipe. In this mode we don't want any\n         * limit to the line size, so we call a function to handle that. */\n        return linenoiseNoTTY();\n    } else if (isUnsupportedTerm()) {\n        size_t len;\n\n        printf(\"%s\",prompt);\n        fflush(stdout);\n        if (fgets(buf,LINENOISE_MAX_LINE,stdin) == NULL) return NULL;\n        len = strlen(buf);\n        while(len && (buf[len-1] == '\\n' || buf[len-1] == '\\r')) {\n            len--;\n            buf[len] = '\\0';\n        }\n        return strdup(buf);\n    } else {\n        char *retval = linenoiseBlockingEdit(STDIN_FILENO,STDOUT_FILENO,buf,LINENOISE_MAX_LINE,prompt);\n        return retval;\n    }\n}\n\n/* This is just a wrapper the user may want to call in order to make sure\n * the linenoise returned buffer is freed with the same allocator it was\n * created with. Useful when the main program is using an alternative\n * allocator. */\nvoid linenoiseFree(void *ptr) {\n    if (ptr == linenoiseEditMore) return; // Protect from API misuse.\n    free(ptr);\n}\n\n/* ================================ History ================================= */\n\n/* Free the history, but does not reset it. Only used when we have to\n * exit() to avoid memory leaks are reported by valgrind & co. */\nstatic void freeHistory(void) {\n    if (history) {\n        int j;\n\n        for (j = 0; j < history_len; j++)\n            free(history[j]);\n        free(history);\n    }\n}\n\n/* At exit we'll try to fix the terminal to the initial conditions. */\nstatic void linenoiseAtExit(void) {\n    disableRawMode(STDIN_FILENO);\n    freeHistory();\n}\n\n/* This is the API call to add a new entry in the linenoise history.\n * It uses a fixed array of char pointers that are shifted (memmoved)\n * when the history max length is reached in order to remove the older\n * entry and make room for the new one, so it is not exactly suitable for huge\n * histories, but will work well for a few hundred of entries.\n *\n * Using a circular buffer is smarter, but a bit more complex to handle. */\nint linenoiseHistoryAdd(const char *line) {\n    char *linecopy;\n\n    if (history_max_len == 0) return 0;\n\n    /* Initialization on first call. */\n    if (history == NULL) {\n        history = malloc(sizeof(char*)*history_max_len);\n        if (history == NULL) return 0;\n        memset(history,0,(sizeof(char*)*history_max_len));\n    }\n\n    /* Don't add duplicated lines. */\n    if (history_len && !strcmp(history[history_len-1], line)) return 0;\n\n    /* Add an heap allocated copy of the line in the history.\n     * If we reached the max length, remove the older line. */\n    linecopy = strdup(line);\n    if (!linecopy) return 0;\n    if (history_len == history_max_len) {\n        free(history[0]);\n        memmove(history,history+1,sizeof(char*)*(history_max_len-1));\n        history_len--;\n    }\n    history[history_len] = linecopy;\n    history_len++;\n    return 1;\n}\n\n/* Set the maximum length for the history. This function can be called even\n * if there is already some history, the function will make sure to retain\n * just the latest 'len' elements if the new history length value is smaller\n * than the amount of items already inside the history. */\nint linenoiseHistorySetMaxLen(int len) {\n    char **new;\n\n    if (len < 1) return 0;\n    if (history) {\n        int tocopy = history_len;\n\n        new = malloc(sizeof(char*)*len);\n        if (new == NULL) return 0;\n\n        /* If we can't copy everything, free the elements we'll not use. */\n        if (len < tocopy) {\n            int j;\n\n            for (j = 0; j < tocopy-len; j++) free(history[j]);\n            tocopy = len;\n        }\n        memset(new,0,sizeof(char*)*len);\n        memcpy(new,history+(history_len-tocopy), sizeof(char*)*tocopy);\n        free(history);\n        history = new;\n    }\n    history_max_len = len;\n    if (history_len > history_max_len)\n        history_len = history_max_len;\n    return 1;\n}\n\n/* Save the history in the specified file. On success 0 is returned\n * otherwise -1 is returned. */\nint linenoiseHistorySave(const char *filename) {\n    mode_t old_umask = umask(S_IXUSR|S_IRWXG|S_IRWXO);\n    FILE *fp;\n    int j;\n\n    fp = fopen(filename,\"w\");\n    umask(old_umask);\n    if (fp == NULL) return -1;\n    chmod(filename,S_IRUSR|S_IWUSR);\n    for (j = 0; j < history_len; j++)\n        fprintf(fp,\"%s\\n\",history[j]);\n    fclose(fp);\n    return 0;\n}\n\n/* Load the history from the specified file. If the file does not exist\n * zero is returned and no operation is performed.\n *\n * If the file exists and the operation succeeded 0 is returned, otherwise\n * on error -1 is returned. */\nint linenoiseHistoryLoad(const char *filename) {\n    FILE *fp = fopen(filename,\"r\");\n    char buf[LINENOISE_MAX_LINE];\n\n    if (fp == NULL) return -1;\n\n    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {\n        char *p;\n\n        p = strchr(buf,'\\r');\n        if (!p) p = strchr(buf,'\\n');\n        if (p) *p = '\\0';\n        linenoiseHistoryAdd(buf);\n    }\n    fclose(fp);\n    return 0;\n}\n"
        },
        {
          "name": "linenoise.h",
          "type": "blob",
          "size": 4.4208984375,
          "content": "/* linenoise.h -- VERSION 1.0\n *\n * Guerrilla line editing library against the idea that a line editing lib\n * needs to be 20,000 lines of C code.\n *\n * See linenoise.c for more information.\n *\n * ------------------------------------------------------------------------\n *\n * Copyright (c) 2010-2023, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2010-2013, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  *  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *  *  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __LINENOISE_H\n#define __LINENOISE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stddef.h> /* For size_t. */\n\nextern char *linenoiseEditMore;\n\n/* The linenoiseState structure represents the state during line editing.\n * We pass this state to functions implementing specific editing\n * functionalities. */\nstruct linenoiseState {\n    int in_completion;  /* The user pressed TAB and we are now in completion\n                         * mode, so input is handled by completeLine(). */\n    size_t completion_idx; /* Index of next completion to propose. */\n    int ifd;            /* Terminal stdin file descriptor. */\n    int ofd;            /* Terminal stdout file descriptor. */\n    char *buf;          /* Edited line buffer. */\n    size_t buflen;      /* Edited line buffer size. */\n    const char *prompt; /* Prompt to display. */\n    size_t plen;        /* Prompt length. */\n    size_t pos;         /* Current cursor position. */\n    size_t oldpos;      /* Previous refresh cursor position. */\n    size_t len;         /* Current edited line length. */\n    size_t cols;        /* Number of columns in terminal. */\n    size_t oldrows;     /* Rows used by last refrehsed line (multiline mode) */\n    int history_index;  /* The history index we are currently editing. */\n};\n\ntypedef struct linenoiseCompletions {\n  size_t len;\n  char **cvec;\n} linenoiseCompletions;\n\n/* Non blocking API. */\nint linenoiseEditStart(struct linenoiseState *l, int stdin_fd, int stdout_fd, char *buf, size_t buflen, const char *prompt);\nchar *linenoiseEditFeed(struct linenoiseState *l);\nvoid linenoiseEditStop(struct linenoiseState *l);\nvoid linenoiseHide(struct linenoiseState *l);\nvoid linenoiseShow(struct linenoiseState *l);\n\n/* Blocking API. */\nchar *linenoise(const char *prompt);\nvoid linenoiseFree(void *ptr);\n\n/* Completion API. */\ntypedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);\ntypedef char*(linenoiseHintsCallback)(const char *, int *color, int *bold);\ntypedef void(linenoiseFreeHintsCallback)(void *);\nvoid linenoiseSetCompletionCallback(linenoiseCompletionCallback *);\nvoid linenoiseSetHintsCallback(linenoiseHintsCallback *);\nvoid linenoiseSetFreeHintsCallback(linenoiseFreeHintsCallback *);\nvoid linenoiseAddCompletion(linenoiseCompletions *, const char *);\n\n/* History API. */\nint linenoiseHistoryAdd(const char *line);\nint linenoiseHistorySetMaxLen(int len);\nint linenoiseHistorySave(const char *filename);\nint linenoiseHistoryLoad(const char *filename);\n\n/* Other utilities. */\nvoid linenoiseClearScreen(void);\nvoid linenoiseSetMultiLine(int ml);\nvoid linenoisePrintKeyCodes(void);\nvoid linenoiseMaskModeEnable(void);\nvoid linenoiseMaskModeDisable(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __LINENOISE_H */\n"
        }
      ]
    }
  ]
}