{
  "metadata": {
    "timestamp": 1736709932319,
    "page": 460,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mas-bandwidth/netcode",
      "stars": 2450,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.34765625,
          "content": "# Visual Studio\n*.db\n*.opendb\n*.vcproj\n*.vcxproj\n*.vcxproj.user\n*.vcxproj.filter\n*.vcxproj.filters\n*.sln\n\n# Makefiles\nMakefile\n*.make\n\n# Misc\n*.txt\n*.7z\n*.zip\n*.tar.gz\n\n# Sublime text\n*.sublime-project\n*.sublime-workspace\n\n# Directories we don't ever want to commit\nbin\nobj\nipch\nrelease\nRelease\nDebug\n.vs\ncov-int\ndocs\n*.exe\nvalgrind/netcode\ndocker/netcode\n"
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 1.2353515625,
          "content": "How to build netcode\n====================\n\n## Building on Windows\n\nDownload [premake 5](https://premake.github.io/download.html) and copy the **premake5** executable somewhere in your path.\n\nYou need Visual Studio to build the source code. If you don't have Visual Studio you can [download the community edition for free](https://visualstudio.microsoft.com/downloads/).\n\nOnce you have Visual Studio installed, go to the command line under the netcode directory and type:\n\n    premake5 vs2019\n\nOpen the generated netcode.sln file.\n\nNow you can build the library and run individual test programs as you would for any other Visual Studio solution.\n\n## Building on MacOS and Linux\n\nFirst, download and install [premake 5](https://premake.github.io/download.html).\n\nNext, install libsodium.\n\nLinux:\n\n    sudo apt install libsodium-dev\n\nMac:\n\n    brew install libsodium\n\nNow go to the command line under the netcode directory and enter:\n\n    premake5 gmake\n\nWhich creates makefiles which you can use to build the source via:\n\n    make -j\n\nThen you can run binaries like this:\n\n    ./bin/test\n    ./bin/server\n    ./bin/client\n\nIf you have questions please create an issue at https://github.com/mas-bandwidth/netcode and I'll do my best to help you out.\n\ncheers\n\n - Glenn\n"
        },
        {
          "name": "LICENCE",
          "type": "blob",
          "size": 1.470703125,
          "content": "Copyright © 2017 - 2024, Mas Bandwidth LLC\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n       in the documentation and/or other materials provided with the distribution.\n\n    3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n       from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\nUSE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.279296875,
          "content": "[![Build status](https://github.com/networkprotocol/netcode/workflows/CI/badge.svg)](https://github.com/networkprotocol/netcode/actions?query=workflow%3ACI)\n\n# netcode\n\n**netcode** is a secure client/server protocol built on top of UDP.\n\nIt's intended for use by real-time multiplayer games, which need a connection oriented protocol but without the head of line blocking of TCP.\n\n![connetion 2](https://github.com/user-attachments/assets/5c7e0c9b-17b6-4e84-a57b-13bdb55a9978)\n\nnetcode has the following features:\n\n* Secure client connection with connect tokens. Only clients you authorize can connect to your server. This is _perfect_ for a game where you perform matchmaking in a web backend then send clients to a server.\n* Client slot system. Servers have n slots for clients. Client are assigned to a slot when they connect to the server and are quickly denied connection if all slots are taken.\n* Fast clean disconnect on client or server side of connection to open up the slot for a new client, plus timeouts for hard disconnects.\n* Encrypted and signed packets. Packets cannot be tampered with or read by parties not involved in the connection. Cryptography is performed by the excellent [sodium library](https://libsodium.gitbook.io/doc).\n* Many security features including robust protection against maliciously crafted packets, packet replay attacks and packet amplification attacks.\n* Support for packet tagging which can significantly reduce jitter on Wi-Fi routers. Read [this article](https://learn.microsoft.com/en-us/gaming/gdk/_content/gc/networking/overviews/qos-packet-tagging) for more details.\n\nnetcode is stable and production ready.\n\n# Usage\n\nStart by generating a random 32 byte private key. Do not share your private key with _anybody_. \n\nEspecially, **do not include your private key in your client executable!**\n\nHere is a test private key:\n\n```c\nstatic uint8_t private_key[NETCODE_KEY_BYTES] = { 0x60, 0x6a, 0xbe, 0x6e, 0xc9, 0x19, 0x10, 0xea, \n                                                  0x9a, 0x65, 0x62, 0xf6, 0x6f, 0x2b, 0x30, 0xe4, \n                                                  0x43, 0x71, 0xd6, 0x2c, 0xd1, 0x99, 0x27, 0x26,\n                                                  0x6b, 0x3c, 0x60, 0xf4, 0xb7, 0x15, 0xab, 0xa1 };\n```\n\nCreate a server with the private key:\n\n```c\nchar * server_address = \"127.0.0.1:40000\";\n\nstruct netcode_server_config_t server_config;\nnetcode_default_server_config( &server_config );\nmemcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\nstruct netcode_server_t * server = netcode_server_create( server_address, &server_config, time );\nif ( !server )\n{\n    printf( \"error: failed to create server\\n\" );\n    return 1;\n}\n```\n\nThen start the server with the number of client slots you want:\n\n```c\nnetcode_server_start( server, 16 );\n```\n\nTo connect a client, your client should hit a REST API to your backend that returns a _connect token_.\n\nUsing a connect token secures your server so that only clients authorized with your backend can connect.\n\n```c\nnetcode_client_connect( client, connect_token );\n```\n\nOnce the client connects to the server, the client is assigned a client index and can exchange encrypted and signed packets with the server.\n\nFor more details please see [client.c](client.c) and [server.c](server.c)\n\n# Source Code\n\nThis repository holds the implementation of netcode in C.\n\nOther netcode implementations include:\n\n* [netcode C# implementation](https://github.com/KillaMaaki/Netcode.IO.NET)\n* [netcode Golang implementation](https://github.com/wirepair/netcode)\n* [netcode Rust implementation](https://github.com/jaynus/netcode.io) (updated fork of [vvanders/netcode.io](https://github.com/vvanders/netcode.io))\n* [netcode Rust implementation](https://github.com/benny-n/netcode) (new from scratch Rust implementation)\n* [netcode for Unity](https://github.com/KillaMaaki/Unity-Netcode.IO)\n* [netcode for UE4](https://github.com/RedpointGames/netcode.io-UE4)\n* [netcode for Typescript](https://github.com/bennychen/netcode.io-typescript)\n\nIf you'd like to create your own implementation of netcode, please read the [netcode 1.02 standard](STANDARD.md).\n\n# Contributors\n\nThese people are awesome:\n\n* [Val Vanders](https://github.com/vvanders) - Rust Implementation\n* [Walter Pearce](https://github.com/jaynus) - Rust Implementation\n* [Isaac Dawson](https://github.com/wirepair) - Golang Implementation\n* [Alan Stagner](https://github.com/KillaMaaki) - Unity integration, C# implementation\n* [Jérôme Leclercq](https://github.com/SirLynix) - Support for random connect token nonce\n* [Randy Gaul](https://github.com/RandyGaul) - Discovered vulnerability in replay protection\n* [Benny Chen](https://github.com/bennychen) - Typescript Implementation\n* [Benny Nazimov](https://github.com/benny-n) - Rust implementation\n\nThanks for your contributions to netcode!\n\n# Author\n\nThe author of this library is [Glenn Fiedler](https://www.linkedin.com/in/glenn-fiedler-11b735302/).\n\nOther open source libraries by the same author include: [reliable](https://github.com/mas-bandwidth/reliable), [serialize](https://github.com/mas-bandwidth/serialize), and [yojimbo](https://github.com/mas-bandwidth/yojimbo).\n\nIf you find this software useful, [please consider sponsoring it](https://github.com/sponsors/mas-bandwidth). Thanks!\n\n# License\n\n[BSD 3-Clause license](https://opensource.org/licenses/BSD-3-Clause).\n"
        },
        {
          "name": "STANDARD.md",
          "type": "blob",
          "size": 25.0947265625,
          "content": "# netcode 1.02\n\n**netcode** is a simple protocol for creating secure client/server connections over UDP.\n\nThis document describes the standard for this protocol so people can create their own implementations.\n\n## Architecture\n\nThere are three main components in the netcode architecture:\n\n1. The backend\n2. Dedicated servers\n3. Clients\n\nThe web backend is a typical web server, for example nginx, which authenticates clients and provides a REST API. Clients are endpoints running the netcode protocol that want to connect to dedicated server instances. Dedicated servers are instances of the server-side portion of the game or application running in data centers or the cloud.\n\nThe sequence of operations for a client connect are:\n\n1. A client authenticates with the web backend\n2. The authenticated client requests to play a game via REST call to the web backend\n3. The web backend generates a _connect token_ and returns it to that client over HTTPS\n4. The client uses the connect token to establish a connection with a dedicated server over UDP\n5. The dedicated server runs logic to ensure that only clients with a valid connect token can connect to it\n6. Once a connection is established the client and server exchange encrypted and signed UDP packets\n\n## General Conventions\n\n**netcode** is a binary protocol. \n\nAll data is written in little-endian byte order unless otherwise specified.\n\nThis applies not only to token and packet data, but also to sequence numbers converted to byte array nonce values, and associated data passed in to AEAD encryption primitives.\n\n## Connect Token\n\nA _connect token_ ensures that only authenticated clients can connect to dedicated servers.\n\nThe connect token has two parts: public and private.\n\nThe private portion is encrypted and signed with a private key shared between the web backend and dedicated server instances.\n\nPrior to encryption the private connect token data has the following binary format.\n\n    [client id] (uint64) // globally unique identifier for an authenticated client\n    [timeout seconds] (uint32) // timeout in seconds. negative values disable timeout (dev only)\n    [num server addresses] (uint32) // in [1,32]\n    <for each server address>\n    {\n        [address type] (uint8) // value of 1 = IPv4 address, 2 = IPv6 address.\n        <if IPV4 address>\n        {\n            // for a given IPv4 address: a.b.c.d:port\n            [a] (uint8)\n            [b] (uint8)\n            [c] (uint8)\n            [d] (uint8)\n            [port] (uint16)\n        }\n        <else IPv6 address>\n        {\n            // for a given IPv6 address: [a:b:c:d:e:f:g:h]:port\n            [a] (uint16)\n            [b] (uint16)\n            [c] (uint16)\n            [d] (uint16)\n            [e] (uint16)\n            [f] (uint16)\n            [g] (uint16)\n            [h] (uint16)\n            [port] (uint16)\n        }\n    }\n    [client to server key] (32 bytes)\n    [server to client key] (32 bytes)\n    [user data] (256 bytes) // user defined data specific to this protocol id\n    <zero pad to 1024 bytes>\n\nThis data is variable size but for simplicity is written to a fixed size buffer of 1024 bytes. Unused bytes are zero padded.\n\nEncryption of the private connect token data is performed with the libsodium AEAD primitive *crypto_aead_xchacha20poly1305_ietf_encrypt* using the following binary data as the _associated data_: \n\n    [version info] (13 bytes)       // \"NETCODE 1.02\" ASCII with null terminator.\n    [protocol id] (uint64)          // 64 bit value unique to this particular game/application\n    [expire timestamp] (uint64)     // 64 bit unix timestamp when this connect token expires\n\nThe nonce used for encryption is a 24 bytes number that is randomly generated for every token.\n\nEncryption is performed on the first 1024 - 16 bytes in the buffer, leaving the last 16 bytes to store the HMAC:\n\n    [encrypted private connect token] (1008 bytes)\n    [hmac of encrypted private connect token] (16 bytes)\n\nPost encryption, this is referred to as the _encrypted private connect token data_.\n\nTogether the public and private data form a _connect token_:\n\n    [version info] (13 bytes)       // \"NETCODE 1.02\" ASCII with null terminator.\n    [protocol id] (uint64)          // 64 bit value unique to this particular game/application\n    [create timestamp] (uint64)     // 64 bit unix timestamp when this connect token was created\n    [expire timestamp] (uint64)     // 64 bit unix timestamp when this connect token expires\n    [connect token nonce] (24 bytes)\n    [encrypted private connect token data] (1024 bytes)\n    [timeout seconds] (uint32)      // timeout in seconds. negative values disable timeout (dev only)\n    [num_server_addresses] (uint32) // in [1,32]\n    <for each server address>\n    {\n        [address_type] (uint8) // value of 1 = IPv4 address, 2 = IPv6 address.\n        <if IPV4 address>\n        {\n            // for a given IPv4 address: a.b.c.d:port\n            [a] (uint8)\n            [b] (uint8)\n            [c] (uint8)\n            [d] (uint8)\n            [port] (uint16)\n        }\n        <else IPv6 address>\n        {\n            // for a given IPv6 address: [a:b:c:d:e:f:g:h]:port\n            [a] (uint16)\n            [b] (uint16)\n            [c] (uint16)\n            [d] (uint16)\n            [e] (uint16)\n            [f] (uint16)\n            [g] (uint16)\n            [h] (uint16)\n            [port] (uint16)\n        }\n    }\n    [client to server key] (32 bytes)\n    [server to client key] (32 bytes)\n    <zero pad to 2048 bytes>\n\nThis data is variable size but for simplicity is written to a fixed size buffer of 2048 bytes. Unused bytes are zero padded.\n\n## Challenge Token\n\nChallenge tokens stop clients with spoofed IP packet source addresses from connecting to servers.\n\nPrior to encryption, challenge tokens have the following structure:\n\n    [client id] (uint64)\n    [user data] (256 bytes)\n    <zero pad to 300 bytes>\n\nEncryption of the challenge token data is performed with the libsodium AEAD primitive *crypto_aead_chacha20poly1305_ietf_encrypt* with no associated data, a random key generated when the dedicated server starts, and a sequence number that starts at zero and increases with each challenge token generated. The sequence number is extended by padding high bits with zero to create a 96 bit nonce.\n\nEncryption is performed on the first 300 - 16 bytes, and the last 16 bytes store the HMAC of the encrypted buffer:\n\n    [encrypted challenge token] (284 bytes)\n    [hmac of encrypted challenge token data] (16 bytes)\n    \nThis is referred to as the _encrypted challenge token data_.\n\n## Packets\n\n**netcode** has the following packets:\n\n* _connection request packet_ (0)\n* _connection denied packet_ (1)\n* _connection challenge packet_ (2)\n* _connection response packet_ (3)\n* _connection keep alive packet_ (4)\n* _connection payload packet_ (5)\n* _connection disconnect packet_ (6)\n\nThe first packet type _connection request packet_ (0) is not encrypted and has the following format:\n\n    0 (uint8) // prefix byte of zero\n    [version info] (13 bytes)       // \"NETCODE 1.02\" ASCII with null terminator.\n    [protocol id] (8 bytes)\n    [connect token expire timestamp] (8 bytes)\n    [connect token nonce] (24 bytes)\n    [encrypted private connect token data] (1024 bytes)\n    \nAll other packet types are encrypted. \n\nPrior to encryption, packet types >= 1 have the following format:\n\n    [prefix byte] (uint8) // non-zero prefix byte\n    [sequence number] (variable length 1-8 bytes)\n    [per-packet type data] (variable length according to packet type)\n\nThe low 4 bits of the prefix byte contain the packet type. \n\nThe high 4 bits contain the number of bytes for the sequence number in the range [1,8]. \n\nThe sequence number is encoded by omitting high zero bytes. For example, a sequence number of 1000 is 0x000003E8 and requires only two bytes to send its value. Therefore, the high 4 bits of the prefix byte are set to 2 and the sequence data written to the packet is:\n\n    0xE8,0x03\n    \nThe sequence number bytes are _reversed_ when written to the packet like so:\n\n    <for each sequence byte written>\n    {\n        write_byte( sequence_number & 0xFF )\n        sequence_number >>= 8\n    }\n    \nAfter the sequence number comes the per-packet type data:\n\n_connection denied packet_:\n\n    <no data>\n\n_connection challenge packet_:\n\n    [challenge token sequence] (uint64)\n    [encrypted challenge token data] (300 bytes)\n    \n_connection response packet_:\n\n    [challenge token sequence] (uint64)\n    [encrypted challenge token data] (300 bytes)\n\n_connection keep-alive packet_:\n\n    [client index] (uint32)\n    [max clients] (uint32)\n    \n_connection payload packet_:\n\n    [payload data] (1 to 1200 bytes)\n    \n_connection disconnect packet_:\n    \n    <no data>\n\nThe per-packet type data is encrypted using the libsodium AEAD primitive *crypto_aead_chacha20poly1305_ietf_encrypt* with the following binary data as the _associated data_: \n\n    [version info] (13 bytes)       // \"NETCODE 1.02\" ASCII with null terminator.\n    [protocol id] (uint64)          // 64 bit value unique to this particular game/application\n    [prefix byte] (uint8)           // prefix byte in packet. stops an attacker from modifying packet type.\n\nThe packet sequence number is extended by padding high bits with zero to create a 96 bit nonce.\n\nPackets sent from client to server are encrypted with the client to server key in the connect token.\n\nPackets sent from server to client are encrypted using the server to client key in the connect token for that client.\n\nPost encryption, packet types >= 1 have the following format:\n\n    [prefix byte] (uint8) // non-zero prefix byte: ( (num_sequence_bytes<<4) | packet_type )\n    [sequence number] (variable length 1-8 bytes)\n    [encrypted per-packet type data] (variable length according to packet type)\n    [hmac of encrypted per-packet type data] (16 bytes)\n\n## Reading Encrypted Packets\n\nThe following steps are taken when reading an encrypted packet, in this exact order:\n\n* If the packet size is less than 18 bytes then it is too small to possibly be valid, ignore the packet.\n\n* If the low 4 bits of the prefix byte are greater than or equal to 7, the packet type is invalid, ignore the packet.\n\n* The server ignores packets with type _connection challenge packet_. \n\n* The client ignores packets with type _connection request packet_ and _connection response packet_.\n\n* If the high 4 bits of the prefix byte (sequence bytes) are outside the range [1,8], ignore the packet.\n\n* If the packet size is less than 1 + sequence bytes + 16, it cannot possibly be valid, ignore the packet.\n\n* If the per-packet type data size does not match the expected size for the packet type, ignore the packet.\n\n    * 0 bytes for _connection denied packet_\n    * 308 bytes for _connection challenge packet_\n    * 308 bytes for _connection response packet_\n    * 8 bytes for _connection keep-alive packet_\n    * [1,1200] bytes for _connection payload packet_\n    * 0 bytes for _connection disconnect packet_\n\n* If the packet type fails the replay protection already received test, ignore the packet. _See the section on replay protection below for details_.\n\n* If the per-packet type data fails to decrypt, ignore the packet.\n\n* Advance the most recent replay protection sequence #. _See the section on replay protection below for details_.\n\n* If all the above checks pass, the packet is processed.\n\n## Replay Protection\n\nReplay protection stops an attacker from recording a valid packet and replaying it back at a later time in an attempt to break the protocol.\n\nTo enable replay protection, netcode does the following:\n\n* Encrypted packets are sent with 64 bit sequence numbers that start at zero and increase with each packet sent.\n\n* The sequence number is included in the packet header and can be read by the receiver of a packet prior to decryption.\n\n* The sequence number is used as the nonce for packet encryption, so any modification to the sequence number fails the encryption signature check.\n\nThe replay protection algorithm is as follows:\n\n1. Any packet older than the most recent sequence number received, minus the _replay buffer size_, is discarded on the receiver side.\n\n2. If a packet arrives that is within _replay buffer size_ of the most recent sequence number, it is accepted only if its sequence number has not already been received, otherwise it is ignored.\n\n3. After the packet has been successfully decrypted, a) if the packet sequence # is in the replay buffer window that entry is set as received, and b) the most recent sequence number is updated if the packet sequence # is > than the previous most recent sequence number received.\n\nReplay protection is applied to the following packet types on both client and server:\n\n* _connection keep alive packet_\n* _connection payload packet_\n* _connection disconnect packet_\n\nThe replay buffer size is implementation specific, but as a guide, a few seconds worth of packets at a typical send rate (20-60HZ) should be supported. Conservatively, a replay buffer size of 256 entries per-client should be sufficient for most applications.\n\n## Client State Machine\n\nThe client has the following states:\n\n* _connect token expired_ (-6)\n* _invalid connect token_ (-5)\n* _connection timed out_ (-4)\n* _connection response timed out_ (-3)\n* _connection request timed out_ (-2)\n* _connection denied_ (-1)\n* _disconnected_ (0)\n* _sending connection request_ (1)\n* _sending connection response_ (2)\n* _connected_ (3)\n\nThe initial state is disconnected (0). Negative states represent error states. The goal state is _connected_ (3).\n\n### Request Connect Token\n\nWhen a client wants to connect to a server, it requests a _connect token_ from the web backend. \n\nThe following aspects are outside the scope of this standard:\n\n1. The mechanism the client uses to request a connection token from the web backend.\n\n2. The mechanism the web backend uses to determine the set of server addresses to include in a connect token.\n\nOnce the client has obtained a connect token, its goal is to establish connection to one of the server addresses in the connect token.\n\nTo begin this process, it transitions to _sending connection request_ with the first server address in the connect token.\n\nBefore doing this, the client checks that the connect token is valid. If the number of server addresses in the connect token are outside of the range [1,32], or if any address type values in the connect token are outside of the range [0,1], or if the create timestamp is more recent than the expire timestamp, the client transitions to _invalid connect token_.\n\n### Sending Connection Request\n\nWhile in _sending connection request_ the client sends _connection request packets_ to the server at some rate, like 10HZ. \n\nWhen the client receives a _connection challenge packet_ from the server, it stores the challenge token data and transitions to _sending challenge response_. This represents a successful transition to the next stage in the connection process.\n\nAll other transitions from _sending connection request_ are failure cases. In these cases the client attempts to connect to the next server address in the connect token (eg. transitioning to _sending connection request_ state with the next server address in the connect token). Alternatively, if there are no additional server addresses to connect to, the client transitions to the appropriate error state as described in the next paragraph.\n\nIf a _connection request denied_ packet is received while in _sending connection request_ the client transitions to _connection denied_. If neither a _connection challenge packet_ or a _connection denied packet_ are received within the timeout period specified in the connect token, the client transitions to _connection request timed out_.\n\n### Sending Challenge Response\n\nWhile in _sending challenge response_ the client sends _challenge response packets_ to the server at some rate, like 10HZ. \n\nWhen the client receives a _connection keep-alive packet_ from the server, it stores the client index and max clients in the packet, and transitions to _connected_.\n\nAny _connection payload packets_ received prior to _connected_ are discarded.\n\nAll other transitions from _sending challenge response_ are failure cases. In these cases the client attempts to connect to the next server address in the connect token (eg. transitioning to _sending connection request_ with the next server address in the connect token). Alternatively, if there are no additional servers addresses to connect to, the client transitions to the appropriate error state as described in the next paragraph.\n\nIf a _connection request denied_ packet is received while in _sending challenge response_ the client transitions to _connection denied_. If neither a _connection keep-alive packet_ or a _connection denied packet_ are received within the timeout period specified in the connect token, the client transitions to _challenge response timed out_.\n\n### Connect Token Expired\n\nIf the entire client connection process (potentially across multiple server addresses) takes long enough that the connect token expires before successfully connecting to a server, the client transitions to _connect token expired_.\n\nThis length of time should be determined by subtracting the create timestamp of the connect token from its expiry timestamp.\n\n### Connected\n\nWhile _connected_ the client buffers _connection payload packets_ received from the server so their payload data can be delivered to the client application as netcode packets.\n\nWhile _connected_ the client application may send _connection payload packets_ to the server. In the absence of _connection payload packets_ sent by the client application, the client generates and sends _connection keep-alive packets_ to the server at some rate, like 10HZ.\n\nIf no _connection payload packet_ or _connection keep-alive packet_ are received from the server within the timeout period specified in the connect token, the client transitions to _connection timed out_. \n\nWhile _connected_ if the client receives a _connection disconnect_ packet from the server, it transitions to _disconnected_.\n\nIf the client wishes to disconnect from the server, it sends a number of redundant _connection disconnect packets_ before transitioning to _disconnected_.\n\n## Server-Side Connection Process\n\n### Server-Side Overview\n\nThe dedicated server must be on a publicly accessible IP address and port.\n\nThe server manages a set of n client slots, where each slot from [0,n-1] represents room for one connected client. \n\nThe maximum number of client slots per-server is implementation specific. Typical uses cases are expected in the range of [2,64] but the reference implementation supports up to 256 clients per-server. \n\nYou may support more clients per-server if your implementation is able to handle them efficiently.\n\n### Processing Connection Requests\n\nThe server follows these strict rules when processing connection requests:\n\n1. Clients must have a valid connect token to connect.\n2. Respond to a client only when absolutely necessary. \n3. Ignore any malformed request as soon as possible, with the minimum amount of work.\n4. Make sure any response packet is smaller than the request packet to avoid DDoS amplification.\n\nWhen a server receives a connection request packet from a client it contains the following data:\n\n    0 (uint8) // prefix byte of zero\n    [version info] (13 bytes)       // \"NETCODE 1.02\" ASCII with null terminator.\n    [protocol id] (8 bytes)\n    [connect token expire timestamp] (8 bytes)\n    [connect token nonce] (24 bytes)\n    [encrypted private connect token data] (1024 bytes)\n\nThis packet is not encrypted, however:\n\n* Only the dedicated server instance and the web backend can read the encrypted private connect token data, because it is encrypted with a private key shared between them.\n\n* The important aspects of the packet such as the version info, protocol id and connect token expire timestamp, are protected by the AEAD construct, and thus cannot be modified without failing the signature check.\n\nThe server takes the following steps, in this exact order, when processing a _connection request packet_:\n\n* If the packet is not the expected size of 1078 bytes, ignore the packet.\n\n* If the version info in the packet doesn't match \"NETCODE 1.02\" (13 bytes, with null terminator), ignore the packet.\n\n* If the protocol id in the packet doesn't match the expected protocol id of the dedicated server, ignore the packet.\n\n* If the connect token expire timestamp is <= the current timestamp, ignore the packet.\n\n* If the encrypted private connect token data doesn't decrypt with the private key, using the associated data constructed from: version info, protocol id and expire timestamp, ignore the packet.\n\n* If the decrypted private connect token fails to be read for any reason, for example, having a number of server addresses outside of the expected range of [1,32], or having an address type value outside of range [0,1], ignore the packet.\n\n* If the dedicated server public address is not in the list of server addresses in the private connect token, ignore the packet.\n\n* If a client from the packet IP source address and port is already connected, ignore the packet.\n\n* If a client with the client id contained in the private connect token data is already connected, ignore the packet.\n\n* If the connect token has already been used by a different packet source IP address and port, ignore the packet. \n\n* Otherwise, add the private connect token hmac + packet source IP address and port to the history of connect tokens already used.\n\n* If no client slots are available, then the server is full. Respond with a _connection denied packet_.\n\n* Add an encryption mapping for the packet source IP address and port so that packets read from that address and port are decrypted with the client to server key in the private connect token, and packets sent to that address and port are encrypted with the server to client key in the private connect token. This encryption mapping expires in _timeout_ seconds of no packets being sent to or received from that address and port, or if a client fails to establish a connection with the server within _timeout_ seconds.\n\n* If for some reason this encryption mapping cannot be added, ignore the packet.\n\n* Otherwise, respond with a _connection challenge packet_ and increment the _connection challenge sequence number_.\n\n### Processing Connection Response Packets\n\nWhen the client receives a _connection challenge packet_ from the server it responds with a _connection response packet_.\n\nThe _connection response packet_ contains the following data:\n\n    [prefix byte] (uint8) // non-zero prefix byte: ( (num_sequence_bytes<<4) | packet_type )\n    [sequence number] (variable length 1-8 bytes)\n    [challenge token sequence] (uint64)\n    [encrypted challenge token data] (360 bytes)\n\nThe server takes these steps, in this exact order, when processing a _connection response packet_:\n\n* If the _encrypted challenge token data_ fails to decrypt, ignore the packet.\n\n* If a client from the packet source address and port is already connected, ignore the packet.\n\n* If a client with the client id contained in the encrypted challenge token data is already connected, ignore the packet.\n\n* If no client slots are available, then the server is full. Respond with a _connection denied packet_.\n\n* Assign the packet IP address + port and client id to a free client slot and mark that client as connected.\n\n* Copy across the user data from the challenge token into the client slot so it is accessible to the server application.\n\n* Set the _confirmed_ flag for that client slot to false.\n\n* Respond with a _connection keep-alive_ packet.\n\n### Connected Clients\n\nOnce a client is asigned to a slot on the server, it is logically connected. \n\nThe index of this slot is used to identify clients on the server and is called the _client index_.\n\nPackets received by the server from that client's address and port are mapped to that _client index_ and processed in the context of that client.\n\nThese packets include:\n\n* _connection keep-alive packet_\n* _connection payload packet_\n* _connection disconnect packet_\n\nThe server buffers _connection payload packets_ received from connected clients client so their payload data can be delivered to the server application as netcode packets.\n\nThe server application may also send _connection payload packets_ to connected clients.\n\nIn the absence of _connection payload packets_ sent to a client, the server generates and sends _connection keep-alive packets_ to that client at some rate, like 10HZ.\n\nWhile the _confirmed_ flag for a client slot is false, each _connection payload packet_ sent to that client has a _connection keep-alive packet_ sent before it. This communicates the _client index_ and the _max clients_ to that client, which it needs to transition to a fully connected state.\n\nWhen the server receives a _connection payload packet_ or a _connection keep-alive packet_ from an unconfirmed client, it sets the _confirmed_ flag for that client slot to true, and stops prefixing _connection payload packets_ with _connection keep-alive packets_.\n\nIf the server wishes to disconnect a client, it sends a number of redundant _connection disconnect packets_ to that client before resetting that client slot.\n\nIf no _connection payload packet_ or _connection keep-alive packet_ are received from a client within the timeout period specified in the connect token, or the server receives a _connection disconnect_ packet from a client, the client slot is reset and becomes available for other clients to connect to.\n"
        },
        {
          "name": "client.c",
          "type": "blob",
          "size": 4.904296875,
          "content": "\n/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"netcode.h\"\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <signal.h>\n#include <inttypes.h>\n\n#define CONNECT_TOKEN_EXPIRY 30\n#define CONNECT_TOKEN_TIMEOUT 5\n#define PROTOCOL_ID 0x1122334455667788\n\nstatic volatile int quit = 0;\n\nvoid interrupt_handler( int signal )\n{\n    (void) signal;\n    quit = 1;\n}\n\nstatic uint8_t private_key[NETCODE_KEY_BYTES] = { 0x60, 0x6a, 0xbe, 0x6e, 0xc9, 0x19, 0x10, 0xea, \n                                                  0x9a, 0x65, 0x62, 0xf6, 0x6f, 0x2b, 0x30, 0xe4, \n                                                  0x43, 0x71, 0xd6, 0x2c, 0xd1, 0x99, 0x27, 0x26,\n                                                  0x6b, 0x3c, 0x60, 0xf4, 0xb7, 0x15, 0xab, 0xa1 };\n\nint main( int argc, char ** argv )\n{\n    (void) argc;\n    (void) argv;\n\n    if ( netcode_init() != NETCODE_OK )\n    {\n        printf( \"error: failed to initialize netcode\\n\" );\n        return 1;\n    }\n\n    netcode_log_level( NETCODE_LOG_LEVEL_INFO );\n\n    double time = 0.0;\n    double delta_time = 1.0 / 60.0;\n\n    printf( \"[client]\\n\" );\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    struct netcode_client_t * client = netcode_client_create( \"0.0.0.0\", &client_config, time );\n\n    if ( !client )\n    {\n        printf( \"error: failed to create client\\n\" );\n        return 1;\n    }\n\n    NETCODE_CONST char * server_address = ( argc != 2 ) ? \"127.0.0.1:40000\" : argv[1];        \n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n    printf( \"client id is %.16\" PRIx64 \"\\n\", client_id );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    if ( netcode_generate_connect_token( 1, &server_address, &server_address, CONNECT_TOKEN_EXPIRY, CONNECT_TOKEN_TIMEOUT, client_id, PROTOCOL_ID, private_key, user_data, connect_token ) != NETCODE_OK )\n    {\n        printf( \"error: failed to generate connect token\\n\" );\n        return 1;\n    }\n\n    netcode_client_connect( client, connect_token );\n\n    signal( SIGINT, interrupt_handler );\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; ++i )\n        packet_data[i] = (uint8_t) i;\n\n    while ( !quit )\n    {\n        netcode_client_update( client, time );\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n        {\n            netcode_client_send_packet( client, packet_data, NETCODE_MAX_PACKET_SIZE );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_client_receive_packet( client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            netcode_client_free_packet( client, packet );\n        }\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        netcode_sleep( delta_time );\n\n        time += delta_time;\n    }\n\n    if ( quit )\n    {\n        printf( \"\\nshutting down\\n\" );\n    }\n\n    netcode_client_destroy( client );\n\n    netcode_term();\n    \n    return 0;\n}\n"
        },
        {
          "name": "client_server.c",
          "type": "blob",
          "size": 6.6279296875,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"netcode.h\"\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <signal.h>\n#include <inttypes.h>\n\n#define CONNECT_TOKEN_EXPIRY 30\n#define CONNECT_TOKEN_TIMEOUT 5\n#define PROTOCOL_ID 0x1122334455667788\n\nstatic volatile int quit = 0;\n\nvoid interrupt_handler( int signal )\n{\n    (void) signal;\n    quit = 1;\n}\n\nstatic uint8_t private_key[NETCODE_KEY_BYTES] = { 0x60, 0x6a, 0xbe, 0x6e, 0xc9, 0x19, 0x10, 0xea, \n                                                  0x9a, 0x65, 0x62, 0xf6, 0x6f, 0x2b, 0x30, 0xe4, \n                                                  0x43, 0x71, 0xd6, 0x2c, 0xd1, 0x99, 0x27, 0x26,\n                                                  0x6b, 0x3c, 0x60, 0xf4, 0xb7, 0x15, 0xab, 0xa1 };\n\nint main( int argc, char ** argv )\n{\n    (void) argc;\n    (void) argv;\n\n    if ( netcode_init() != NETCODE_OK )\n    {\n        printf( \"error: failed to initialize netcode\\n\" );\n        return 1;\n    }\n\n    netcode_log_level( NETCODE_LOG_LEVEL_INFO );\n\n    double time = 0.0;\n    double delta_time = 1.0 / 60.0;\n\n    printf( \"[client/server]\\n\" );\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    struct netcode_client_t * client = netcode_client_create( \"::\", &client_config, time );\n\n    if ( !client )\n    {\n        printf( \"error: failed to create client\\n\" );\n        return 1;\n    }\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = PROTOCOL_ID;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    char * server_address = \"[::1]:40000\";\n\n    struct netcode_server_t * server = netcode_server_create( server_address, &server_config, time );\n\n    if ( !server )\n    {\n        printf( \"error: failed to create server\\n\" );\n        return 1;\n    }\n\n    netcode_server_start( server, 1 );\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n    printf( \"client id is %.16\" PRIx64 \"\\n\", client_id );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    if ( netcode_generate_connect_token( 1, (NETCODE_CONST char**) &server_address, (NETCODE_CONST char**) &server_address, CONNECT_TOKEN_EXPIRY, CONNECT_TOKEN_TIMEOUT, client_id, PROTOCOL_ID, private_key, user_data, connect_token ) != NETCODE_OK )\n    {\n        printf( \"error: failed to generate connect token\\n\" );\n        return 1;\n    }\n\n    netcode_client_connect( client, connect_token );\n\n    signal( SIGINT, interrupt_handler );\n\n    int server_num_packets_received = 0;\n    int client_num_packets_received = 0;\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; ++i )\n        packet_data[i] = (uint8_t) i;\n\n    while ( !quit )\n    {\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n        {\n            netcode_client_send_packet( client, packet_data, NETCODE_MAX_PACKET_SIZE );\n        }\n\n        if ( netcode_server_client_connected( server, 0 ) )\n        {\n            netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_client_receive_packet( client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            client_num_packets_received++;\n            netcode_client_free_packet( client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 0, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        if ( client_num_packets_received >= 10 && server_num_packets_received >= 10 )\n        {\n            if ( netcode_server_client_connected( server, 0 ) )\n            {\n                printf( \"client and server successfully exchanged packets\\n\" );\n\n                netcode_server_disconnect_client( server, 0 );\n            }\n        }\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        netcode_sleep( delta_time );\n\n        time += delta_time;\n    }\n\n    if ( quit )\n    {\n        printf( \"\\nshutting down\\n\" );\n    }\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_term();\n    \n    return 0;\n}\n"
        },
        {
          "name": "netcode.c",
          "type": "blob",
          "size": 319.03515625,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"netcode.h\"\n#include <stdlib.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <math.h>\n#include <time.h>\n\n#ifdef _MSC_VER\n#define SODIUM_STATIC\n#pragma warning(disable:4996)\n#endif // #ifdef _MSC_VER\n\n#include <sodium.h>\n\n#define NETCODE_SOCKET_IPV6         1\n#define NETCODE_SOCKET_IPV4         2\n\n#define NETCODE_CONNECT_TOKEN_NONCE_BYTES 24\n#define NETCODE_CONNECT_TOKEN_PRIVATE_BYTES 1024\n#define NETCODE_CHALLENGE_TOKEN_BYTES 300\n#define NETCODE_VERSION_INFO_BYTES 13\n#define NETCODE_MAX_PACKET_BYTES 1300\n#define NETCODE_MAX_PAYLOAD_BYTES 1200\n#define NETCODE_MAX_ADDRESS_STRING_LENGTH 256\n#define NETCODE_PACKET_QUEUE_SIZE 256\n#define NETCODE_REPLAY_PROTECTION_BUFFER_SIZE 256\n#define NETCODE_CLIENT_MAX_RECEIVE_PACKETS 64\n#define NETCODE_SERVER_MAX_RECEIVE_PACKETS ( 64 * NETCODE_MAX_CLIENTS )\n#define NETCODE_CLIENT_SOCKET_SNDBUF_SIZE ( 4 * 1024 * 1024 )\n#define NETCODE_CLIENT_SOCKET_RCVBUF_SIZE ( 4 * 1024 * 1024 )\n#define NETCODE_SERVER_SOCKET_SNDBUF_SIZE ( 4 * 1024 * 1024 )\n#define NETCODE_SERVER_SOCKET_RCVBUF_SIZE ( 4 * 1024 * 1024 )\n\n#define NETCODE_VERSION_INFO ( (uint8_t*) \"NETCODE 1.02\" )\n#define NETCODE_PACKET_SEND_RATE 10.0\n#define NETCODE_NUM_DISCONNECT_PACKETS 10\n\n#define NETCODE_ADDRESS_MAP_BUCKETS NETCODE_MAX_CLIENTS\n\n#ifndef NETCODE_ENABLE_TESTS\n#define NETCODE_ENABLE_TESTS 0\n#endif // #ifndef NETCODE_ENABLE_TESTS\n\n#ifndef NETCODE_ENABLE_LOGGING\n#define NETCODE_ENABLE_LOGGING 1\n#endif // #ifndef NETCODE_ENABLE_LOGGING\n\n// ------------------------------------------------------------------\n\n#if NETCODE_PACKET_TAGGING\n\nstatic int netcode_packet_tagging_enabled = 0;\n\nvoid netcode_enable_packet_tagging()\n{\n    netcode_packet_tagging_enabled = 1;\n}\n\n#endif // #if NETCODE_PACKET_TAGGING\n\n// ------------------------------------------------------------------\n\nstatic void netcode_default_assert_handler( NETCODE_CONST char * condition, NETCODE_CONST char * function, NETCODE_CONST char * file, int line )\n{\n    printf( \"assert failed: ( %s ), function %s, file %s, line %d\\n\", condition, function, file, line );\n    #if defined( __GNUC__ )\n    __builtin_trap();\n    #elif defined( _MSC_VER )\n    __debugbreak();\n    #endif\n    exit( 1 );\n}\n\nstatic int log_level;\nstatic int (*printf_function)( NETCODE_CONST char *, ... ) = ( int (*)( NETCODE_CONST char *, ... ) ) printf;\nvoid (*netcode_assert_function)( NETCODE_CONST char *, NETCODE_CONST char *, NETCODE_CONST char * file, int line ) = netcode_default_assert_handler;\n\nvoid netcode_log_level( int level )\n{\n    log_level = level;\n}\n\nvoid netcode_set_printf_function( int (*function)( NETCODE_CONST char *, ... ) )\n{\n    netcode_assert( function );\n    printf_function = function;\n}\n\nvoid netcode_set_assert_function( void (*function)( NETCODE_CONST char *, NETCODE_CONST char *, NETCODE_CONST char * file, int line ) )\n{\n    netcode_assert_function = function;\n}\n\n#if NETCODE_ENABLE_LOGGING\n\nvoid netcode_printf( int level, NETCODE_CONST char * format, ... ) \n{\n    if ( level > log_level )\n        return;\n    va_list args;\n    va_start( args, format );\n    char buffer[4*1024];\n    vsnprintf( buffer, sizeof(buffer), format, args );\n    printf_function( \"%s\", buffer );\n    va_end( args );\n}\n\n#else // #if NETCODE_ENABLE_LOGGING\n\nvoid netcode_printf( int level, NETCODE_CONST char * format, ... ) \n{\n    (void) level;\n    (void) format;\n}\n\n#endif // #if NETCODE_ENABLE_LOGGING\n\nvoid * netcode_default_allocate_function( void * context, size_t bytes )\n{\n    (void) context;\n    return malloc( bytes );\n}\n\nvoid netcode_default_free_function( void * context, void * pointer )\n{\n    (void) context;\n    free( pointer );\n}\n\n// ------------------------------------------------------------------\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    #define NOMINMAX\n    #define _WINSOCK_DEPRECATED_NO_WARNINGS\n    #include <winsock2.h>\n    #include <ws2def.h>\n    #include <ws2tcpip.h>\n    #include <ws2ipdef.h>\n    #include <iphlpapi.h>\n    #pragma comment( lib, \"WS2_32.lib\" )\n    #pragma comment( lib, \"IPHLPAPI.lib\" )\n\n    #ifdef SetPort\n    #undef SetPort\n    #endif // #ifdef SetPort\n\n    #include <iphlpapi.h>\n    #pragma comment( lib, \"IPHLPAPI.lib\" )\n    \n#elif NETCODE_PLATFORM == NETCODE_PLATFORM_MAC || NETCODE_PLATFORM == NETCODE_PLATFORM_UNIX\n\n    #include <netdb.h>\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <netinet/in.h>\n    #include <ifaddrs.h>\n    #include <net/if.h>\n    #include <fcntl.h>\n    #include <netdb.h>\n    #include <arpa/inet.h>\n    #include <unistd.h>\n    #include <errno.h>\n\n#else\n\n    #error netcode - unknown platform!\n\n#endif\n\nint netcode_parse_address( NETCODE_CONST char * address_string_in, struct netcode_address_t * address )\n{\n    netcode_assert( address_string_in );\n    netcode_assert( address );\n\n    memset( address, 0, sizeof( struct netcode_address_t ) );\n\n    // first try to parse the string as an IPv6 address:\n    // 1. if the first character is '[' then it's probably an ipv6 in form \"[addr6]:portnum\"\n    // 2. otherwise try to parse as a raw IPv6 address using inet_pton\n\n    #define NETCODE_ADDRESS_BUFFER_SAFETY 32\n\n    char buffer[NETCODE_MAX_ADDRESS_STRING_LENGTH + NETCODE_ADDRESS_BUFFER_SAFETY*2];\n\n    char * address_string = buffer + NETCODE_ADDRESS_BUFFER_SAFETY;\n    strncpy( address_string, address_string_in, NETCODE_MAX_ADDRESS_STRING_LENGTH - 1 );\n    address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH-1] = '\\0';\n\n    int address_string_length = (int) strlen( address_string );\n\n    if ( address_string[0] == '[' )\n    {\n        int base_index = address_string_length - 1;\n        \n        int i;\n        for ( i = 0; i < 6; i++ )         // note: no need to search past 6 characters as \":65535\" is longest possible port value\n        {\n            int index = base_index - i;\n            if ( index < 3 )\n                return NETCODE_ERROR;\n            if ( address_string[index] == ':' )\n            {\n                address->port = (uint16_t) ( atoi( &address_string[index + 1] ) );\n                address_string[index-1] = '\\0';\n            }\n        }\n        address_string += 1;\n    }\n\n    struct in6_addr sockaddr6;\n    if ( inet_pton( AF_INET6, address_string, &sockaddr6 ) == 1 )\n    {\n        address->type = NETCODE_ADDRESS_IPV6;\n        int i;\n        for ( i = 0; i < 8; i++ )\n        {\n            address->data.ipv6[i] = ntohs( ( (uint16_t*) &sockaddr6 ) [i] );\n        }\n        return NETCODE_OK;\n    }\n\n    // otherwise it's probably an IPv4 address:\n    // 1. look for \":portnum\", if found save the portnum and strip it out\n    // 2. parse remaining ipv4 address via inet_pton\n\n    address_string_length = (int) strlen( address_string );\n    int base_index = address_string_length - 1;\n    int i;\n    for ( i = 0; i < 6; i++ )\n    {\n        int index = base_index - i;\n        if ( index < 0 )\n            break;\n        if ( address_string[index] == ':' )\n        {\n            address->port = (uint16_t) atoi( &address_string[index+1] );\n            address_string[index] = '\\0';\n        }\n    }\n\n    struct sockaddr_in sockaddr4;\n    if ( inet_pton( AF_INET, address_string, &sockaddr4.sin_addr ) == 1 )\n    {\n        address->type = NETCODE_ADDRESS_IPV4;\n        address->data.ipv4[3] = (uint8_t) ( ( sockaddr4.sin_addr.s_addr & 0xFF000000 ) >> 24 );\n        address->data.ipv4[2] = (uint8_t) ( ( sockaddr4.sin_addr.s_addr & 0x00FF0000 ) >> 16 );\n        address->data.ipv4[1] = (uint8_t) ( ( sockaddr4.sin_addr.s_addr & 0x0000FF00 ) >> 8  );\n        address->data.ipv4[0] = (uint8_t) ( ( sockaddr4.sin_addr.s_addr & 0x000000FF )       );\n        return NETCODE_OK;\n    }\n\n    return NETCODE_ERROR;\n}\n\nchar * netcode_address_to_string( struct netcode_address_t * address, char * buffer )\n{\n    netcode_assert( address );\n    netcode_assert( buffer );\n\n    if ( address->type == NETCODE_ADDRESS_IPV6 )\n    {\n        if ( address->port == 0 )\n        {\n            uint16_t ipv6_network_order[8];\n            int i;\n            for ( i = 0; i < 8; i++ )\n                ipv6_network_order[i] = htons( address->data.ipv6[i] );\n            inet_ntop( AF_INET6, (void*) ipv6_network_order, buffer, NETCODE_MAX_ADDRESS_STRING_LENGTH );\n            return buffer;\n        }\n        else\n        {\n            char address_string[INET6_ADDRSTRLEN];\n            uint16_t ipv6_network_order[8];\n            int i;\n            for ( i = 0; i < 8; i++ )\n                ipv6_network_order[i] = htons( address->data.ipv6[i] );\n            inet_ntop( AF_INET6, (void*) ipv6_network_order, address_string, INET6_ADDRSTRLEN );\n            snprintf( buffer, NETCODE_MAX_ADDRESS_STRING_LENGTH, \"[%s]:%d\", address_string, address->port );\n            return buffer;\n        }\n    }\n    else if ( address->type == NETCODE_ADDRESS_IPV4 )\n    {\n        if ( address->port != 0 )\n        {\n            snprintf( buffer, NETCODE_MAX_ADDRESS_STRING_LENGTH, \"%d.%d.%d.%d:%d\", \n                address->data.ipv4[0], \n                address->data.ipv4[1], \n                address->data.ipv4[2], \n                address->data.ipv4[3], \n                address->port );\n        }\n        else\n        {\n            snprintf( buffer, NETCODE_MAX_ADDRESS_STRING_LENGTH, \"%d.%d.%d.%d\", \n                address->data.ipv4[0], \n                address->data.ipv4[1], \n                address->data.ipv4[2], \n                address->data.ipv4[3] );\n        }\n        return buffer;\n    }\n    else\n    {\n        snprintf( buffer, NETCODE_MAX_ADDRESS_STRING_LENGTH, \"%s\", \"NONE\" );\n        return buffer;\n    }\n}\n\nint netcode_address_equal( struct netcode_address_t * a, struct netcode_address_t * b )\n{\n    netcode_assert( a );\n    netcode_assert( b );\n\n    if ( a->type != b->type )\n        return 0;\n\n    if ( a->port != b->port )\n        return 0;\n\n    if ( a->type == NETCODE_ADDRESS_IPV4 )\n    {\n        int i;\n        for ( i = 0; i < 4; i++ )\n        {\n            if ( a->data.ipv4[i] != b->data.ipv4[i] )\n                return 0;\n        }\n    }\n    else if ( a->type == NETCODE_ADDRESS_IPV6 )\n    {\n        int i;\n        for ( i = 0; i < 8; i++ )\n        {\n            if ( a->data.ipv6[i] != b->data.ipv6[i] )\n                return 0;\n        }\n    }\n    else\n    {\n        return 0;\n    }\n\n    return 1;\n}\n\n// ----------------------------------------------------------------\n\nstruct netcode_t\n{\n    int initialized;\n};\n\nstatic struct netcode_t netcode;\n\nint netcode_init()\n{\n    netcode_assert( !netcode.initialized );\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    WSADATA WsaData;         \n    if ( WSAStartup( MAKEWORD(2,2), &WsaData ) != NO_ERROR )\n        return NETCODE_ERROR;\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    if ( sodium_init() == -1 )\n        return NETCODE_ERROR;\n\n    netcode.initialized = 1;\n\n    return NETCODE_OK;\n}\n\nvoid netcode_term()\n{\n    netcode_assert( netcode.initialized );\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    WSACleanup();\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    netcode.initialized = 0;\n}\n\n// ----------------------------------------------------------------\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\ntypedef uint32_t netcode_socket_handle_t;\n#else // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\ntypedef size_t netcode_socket_handle_t;\n#endif // #if NETCODE_PLATFORM == NETCODe_PLATFORM_WINDOWS\n\nstruct netcode_socket_t\n{\n    struct netcode_address_t address;\n    netcode_socket_handle_t handle;\n};\n\nstruct netcode_socket_holder_t\n{\n    struct netcode_socket_t ipv4;\n    struct netcode_socket_t ipv6;\n};\n\n#define NETCODE_SOCKET_ERROR_NONE                                    0\n#define NETCODE_SOCKET_ERROR_CREATE_FAILED                           1\n#define NETCODE_SOCKET_ERROR_SET_NON_BLOCKING_FAILED                 2\n#define NETCODE_SOCKET_ERROR_SOCKOPT_IPV6_ONLY_FAILED                3\n#define NETCODE_SOCKET_ERROR_SOCKOPT_RCVBUF_FAILED                   4\n#define NETCODE_SOCKET_ERROR_SOCKOPT_SNDBUF_FAILED                   5\n#define NETCODE_SOCKET_ERROR_BIND_IPV4_FAILED                        6\n#define NETCODE_SOCKET_ERROR_BIND_IPV6_FAILED                        7\n#define NETCODE_SOCKET_ERROR_GET_SOCKNAME_IPV4_FAILED                8\n#define NETCODE_SOCKET_ERROR_GET_SOCKNAME_IPV6_FAILED                9\n#define NETCODE_SOCKET_ERROR_DISABLE_UDP_PORT_CONNRESET_FAILED      10\n#define NETCODE_SOCKET_ERROR_ENABLE_PACKET_TAGGING_FAILED           11\n\nvoid netcode_socket_destroy( struct netcode_socket_t * socket )\n{\n    netcode_assert( socket );\n    netcode_assert( netcode.initialized );\n\n    if ( socket->handle != 0 )\n    {\n        #if NETCODE_PLATFORM == NETCODE_PLATFORM_MAC || NETCODE_PLATFORM == NETCODE_PLATFORM_UNIX\n        close( socket->handle );\n        #elif NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n        closesocket( socket->handle );\n        #else\n        #error unsupported platform\n        #endif\n        socket->handle = 0;\n    }\n}\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS && NETCODE_PACKET_TAGGING\n\n#include <windows.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <ws2ipdef.h>\n#include <wininet.h>\n#include <iphlpapi.h>\n\n#ifdef __MINGW32__\ntypedef UINT32 QOS_FLOWID, *PQOS_FLOWID;\n#ifndef QOS_NON_ADAPTIVE_FLOW\n#define QOS_NON_ADAPTIVE_FLOW 0x00000002\n#endif // #ifndef QOS_NON_ADAPTIVE_FLOW\n#endif // #ifdef __MINGW32__\n#include <qos2.h>\n\n#pragma comment( lib, \"Qwave.lib\" )\n\nstatic int netcode_set_socket_codepoint( SOCKET socket, QOS_TRAFFIC_TYPE trafficType, QOS_FLOWID flowId, PSOCKADDR addr ) \n{\n    QOS_VERSION QosVersion = { 1 , 0 };\n    HANDLE qosHandle;\n    if ( QOSCreateHandle( &QosVersion, &qosHandle ) == FALSE )\n    {\n        return GetLastError();\n    }\n    if ( QOSAddSocketToFlow( qosHandle, socket, addr, trafficType, QOS_NON_ADAPTIVE_FLOW, &flowId ) == FALSE )\n    {\n        return GetLastError();\n    }\n    return 0;\n}\n\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS && NETCODE_PACKET_TAGGING\n\nint netcode_socket_create( struct netcode_socket_t * s, struct netcode_address_t * address, int send_buffer_size, int receive_buffer_size )\n{\n    netcode_assert( s );\n    netcode_assert( address );\n    netcode_assert( netcode.initialized );\n\n    netcode_assert( address->type != NETCODE_ADDRESS_NONE );\n\n    s->address = *address;\n\n    // create socket\n\n    s->handle = socket( ( address->type == NETCODE_ADDRESS_IPV6 ) ? AF_INET6 : AF_INET, SOCK_DGRAM, IPPROTO_UDP );\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    if ( s->handle == (uint32_t)INVALID_SOCKET )\n#else // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    if ( s->handle <= 0 )\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to create socket\\n\" );\n        return NETCODE_SOCKET_ERROR_CREATE_FAILED;\n    }\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    // IMPORTANT: tell windows we don't want to receive any connection reset messages for this socket\n    // If we don't do this, clients disconnecting hard will cause recvfrom on the server to repeatedly error out \n    // due to ICMP disconnected packets, causing long periods where the server doesn't receive any packets from clients.\n\n    #define SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)\n    BOOL bNewBehavior = FALSE;\n    DWORD dwBytesReturned = 0;\n    if ( WSAIoctl( s->handle, SIO_UDP_CONNRESET, &bNewBehavior, sizeof(bNewBehavior), NULL, 0, &dwBytesReturned, NULL, NULL ) != 0 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to disable UDP CONNRESET (port unreachable) message reporting on socket\\n\" );\n        netcode_socket_destroy( s );\n        return NETCODE_SOCKET_ERROR_DISABLE_UDP_PORT_CONNRESET_FAILED;\n    }\n\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    // force IPv6 only if necessary\n\n    if ( address->type == NETCODE_ADDRESS_IPV6 )\n    {\n        int yes = 1;\n        if ( setsockopt( s->handle, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&yes, sizeof(yes) ) != 0 )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to set socket ipv6 only\\n\" );\n            netcode_socket_destroy( s );\n            return NETCODE_SOCKET_ERROR_SOCKOPT_IPV6_ONLY_FAILED;\n        }\n    }\n\n    // increase socket send and receive buffer sizes\n\n    if ( setsockopt( s->handle, SOL_SOCKET, SO_SNDBUF, (char*)&send_buffer_size, sizeof(int) ) != 0 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to set socket send buffer size\\n\" );\n        netcode_socket_destroy( s );\n        return NETCODE_SOCKET_ERROR_SOCKOPT_SNDBUF_FAILED;\n    }\n\n    if ( setsockopt( s->handle, SOL_SOCKET, SO_RCVBUF, (char*)&receive_buffer_size, sizeof(int) ) != 0 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to set socket receive buffer size\\n\" );\n        netcode_socket_destroy( s );\n        return NETCODE_SOCKET_ERROR_SOCKOPT_RCVBUF_FAILED;\n    }\n\n    // bind to port\n\n    if ( address->type == NETCODE_ADDRESS_IPV6 )\n    {\n        struct sockaddr_in6 socket_address;\n        memset( &socket_address, 0, sizeof( struct sockaddr_in6 ) );\n        socket_address.sin6_family = AF_INET6;\n        int i;\n        for ( i = 0; i < 8; i++ )\n        {\n            ( (uint16_t*) &socket_address.sin6_addr ) [i] = htons( address->data.ipv6[i] );\n        }\n        socket_address.sin6_port = htons( address->port );\n\n        if ( bind( s->handle, (struct sockaddr*) &socket_address, sizeof( socket_address ) ) < 0 )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to bind socket (ipv6)\\n\" );\n            netcode_socket_destroy( s );\n            return NETCODE_SOCKET_ERROR_BIND_IPV6_FAILED;\n        }\n    }\n    else\n    {\n        struct sockaddr_in socket_address;\n        memset( &socket_address, 0, sizeof( socket_address ) );\n        socket_address.sin_family = AF_INET;\n        socket_address.sin_addr.s_addr = ( ( (uint32_t) address->data.ipv4[0] ) )       | \n                                         ( ( (uint32_t) address->data.ipv4[1] ) << 8 )  | \n                                         ( ( (uint32_t) address->data.ipv4[2] ) << 16 ) | \n                                         ( ( (uint32_t) address->data.ipv4[3] ) << 24 );\n        socket_address.sin_port = htons( address->port );\n\n        if ( bind( s->handle, (struct sockaddr*) &socket_address, sizeof( socket_address ) ) < 0 )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to bind socket (ipv4)\\n\" );\n            netcode_socket_destroy( s );\n            return NETCODE_SOCKET_ERROR_BIND_IPV4_FAILED;\n        }\n    }\n\n    // if bound to port 0 find the actual port we got\n\n    if ( address->port == 0 )\n    {\n        if ( address->type == NETCODE_ADDRESS_IPV6 )\n        {\n            struct sockaddr_in6 sin;\n            socklen_t len = sizeof( sin );\n            if ( getsockname( s->handle, (struct sockaddr*)&sin, &len ) == -1 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to get socket port (ipv6)\\n\" );\n                netcode_socket_destroy( s );\n                return NETCODE_SOCKET_ERROR_GET_SOCKNAME_IPV6_FAILED;\n            }\n            s->address.port = ntohs( sin.sin6_port );\n        }\n        else\n        {\n            struct sockaddr_in sin;\n            socklen_t len = sizeof( sin );\n            if ( getsockname( s->handle, (struct sockaddr*)&sin, &len ) == -1 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to get socket port (ipv4)\\n\" );\n                netcode_socket_destroy( s );\n                return NETCODE_SOCKET_ERROR_GET_SOCKNAME_IPV4_FAILED;\n            }\n            s->address.port = ntohs( sin.sin_port );\n        }\n    }\n\n    // set non-blocking io\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_MAC || NETCODE_PLATFORM == NETCODE_PLATFORM_UNIX\n\n    int non_blocking = 1;\n    if ( fcntl( s->handle, F_SETFL, O_NONBLOCK, non_blocking ) == -1 )\n    {\n        netcode_socket_destroy( s );\n        return NETCODE_SOCKET_ERROR_SET_NON_BLOCKING_FAILED;\n    }\n\n#elif NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    DWORD nonBlocking = 1;\n    if ( ioctlsocket( s->handle, FIONBIO, &nonBlocking ) != 0 )\n    {\n        netcode_socket_destroy( s );\n        return NETCODE_SOCKET_ERROR_SET_NON_BLOCKING_FAILED;\n    }\n\n#else\n\n    #error unsupported platform\n\n#endif\n\n#if NETCODE_PACKET_TAGGING\n\n    // tag packets as low latency\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_MAC\n\n    if ( netcode_packet_tagging_enabled )\n    {\n        if ( address->type == NETCODE_ADDRESS_IPV6 )\n        {\n            int tos = 46;\n            if ( setsockopt( s->handle, IPPROTO_IPV6, IPV6_TCLASS, (NETCODE_CONST char *)&tos, sizeof(tos) ) != 0 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to enable packet tagging (ipv6)\\n\" );\n                netcode_socket_destroy( s );\n                return NETCODE_SOCKET_ERROR_ENABLE_PACKET_TAGGING_FAILED;\n            }\n        }\n        else\n        {\n            int tos = 46;\n            if ( setsockopt( s->handle, IPPROTO_IP, IP_TOS, (NETCODE_CONST char *)&tos, sizeof(tos) ) != 0 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to enable packet tagging (ipv4)\\n\" );\n                netcode_socket_destroy( s );\n                return NETCODE_SOCKET_ERROR_ENABLE_PACKET_TAGGING_FAILED;\n            }\n        }\n    }\n\n#elif NETCODE_PLATFORM == NETCODE_PLATFORM_LINUX\n\n    if ( netcode_packet_tagging_enabled )\n    {\n        if ( address->type == NETCODE_ADDRESS_IPV6 )\n        {\n            int tos = 46;\n            if ( setsockopt( socket->handle, IPPROTO_IPV6, IPV6_TCLASS, (NETCODE_CONST char *)&tos, sizeof(tos) ) != 0 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to enable packet tagging (ipv6)\\n\" );\n                netcode_socket_destroy( s );\n                return NETCODE_SOCKET_ERROR_ENABLE_PACKET_TAGGING_FAILED;\n            }\n        }\n        else\n        {\n            int tos = 46;\n            if ( setsockopt( socket->handle, IPPROTO_IP, IP_TOS, (NETCODE_CONST char *)&tos, sizeof(tos) ) != 0 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to enable packet tagging (ipv4)\\n\" );\n                netcode_socket_destroy( s );\n                return NETCODE_SOCKET_ERROR_ENABLE_PACKET_TAGGING_FAILED;\n            }\n        }\n    }\n\n#elif NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    if ( netcode_packet_tagging_enabled )\n    {\n        struct sockaddr_storage addr;\n        memset( &addr, 0, sizeof(addr) );\n        addr.ss_family = ( address->type == NETCODE_ADDRESS_IPV6 ) ? AF_INET6 : AF_INET;\n        netcode_set_socket_codepoint( s->handle, QOSTrafficTypeAudioVideo, 0, (PSOCKADDR) &addr );\n    }\n\n#endif\n\n#endif // #if NETCODE_PACKET_TAGGING\n\n    return NETCODE_SOCKET_ERROR_NONE;\n}\n\nvoid netcode_socket_send_packet( struct netcode_socket_t * socket, struct netcode_address_t * to, void * packet_data, int packet_bytes )\n{\n    netcode_assert( socket );\n    netcode_assert( socket->handle != 0 );\n    netcode_assert( to );\n    netcode_assert( to->type == NETCODE_ADDRESS_IPV6 || to->type == NETCODE_ADDRESS_IPV4 );\n    netcode_assert( packet_data );\n    netcode_assert( packet_bytes > 0 );\n\n    if ( to->type == NETCODE_ADDRESS_IPV6 )\n    {\n        struct sockaddr_in6 socket_address;\n        memset( &socket_address, 0, sizeof( socket_address ) );\n        socket_address.sin6_family = AF_INET6;\n        int i;\n        for ( i = 0; i < 8; i++ )\n        {\n            ( (uint16_t*) &socket_address.sin6_addr ) [i] = htons( to->data.ipv6[i] );\n        }\n        socket_address.sin6_port = htons( to->port );\n        int result = sendto( socket->handle, (char*) packet_data, packet_bytes, 0, (struct sockaddr*) &socket_address, sizeof( struct sockaddr_in6 ) );\n        (void) result;\n    }\n    else if ( to->type == NETCODE_ADDRESS_IPV4 )\n    {\n        struct sockaddr_in socket_address;\n        memset( &socket_address, 0, sizeof( socket_address ) );\n        socket_address.sin_family = AF_INET;\n        socket_address.sin_addr.s_addr = ( ( (uint32_t) to->data.ipv4[0] ) )        | \n                                         ( ( (uint32_t) to->data.ipv4[1] ) << 8 )   | \n                                         ( ( (uint32_t) to->data.ipv4[2] ) << 16 )  | \n                                         ( ( (uint32_t) to->data.ipv4[3] ) << 24 );\n        socket_address.sin_port = htons( to->port );\n        int result = sendto( socket->handle, (NETCODE_CONST char*) packet_data, packet_bytes, 0, (struct sockaddr*) &socket_address, sizeof( struct sockaddr_in ) );\n        (void) result;\n    }\n}\n\nint netcode_socket_receive_packet( struct netcode_socket_t * socket, struct netcode_address_t * from, void * packet_data, int max_packet_size )\n{\n    netcode_assert( socket );\n    netcode_assert( socket->handle != 0 );\n    netcode_assert( from );\n    netcode_assert( packet_data );\n    netcode_assert( max_packet_size > 0 );\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    typedef int socklen_t;\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    \n    struct sockaddr_storage sockaddr_from;\n    socklen_t from_length = sizeof( sockaddr_from );\n\n    int result = recvfrom( socket->handle, (char*) packet_data, max_packet_size, 0, (struct sockaddr*) &sockaddr_from, &from_length );\n\n#if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    if ( result == SOCKET_ERROR )\n    {\n        int error = WSAGetLastError();\n\n        if ( error == WSAEWOULDBLOCK )\n            return 0;\n\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: recvfrom failed with error %d\\n\", error );\n\n        return 0;\n    }\n#else // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n    if ( result <= 0 )\n    {\n        if ( errno == EAGAIN )\n            return 0;\n\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: recvfrom failed with error %d\\n\", errno );\n\n        return 0;\n    }\n#endif // #if NETCODE_PLATFORM == NETCODE_PLATFORM_WINDOWS\n\n    if ( sockaddr_from.ss_family == AF_INET6 )\n    {\n        struct sockaddr_in6 * addr_ipv6 = (struct sockaddr_in6*) &sockaddr_from;\n        from->type = NETCODE_ADDRESS_IPV6;\n        int i;\n        for ( i = 0; i < 8; i++ )\n        {\n            from->data.ipv6[i] = ntohs( ( (uint16_t*) &addr_ipv6->sin6_addr ) [i] );\n        }\n        from->port = ntohs( addr_ipv6->sin6_port );\n    }\n    else if ( sockaddr_from.ss_family == AF_INET )\n    {\n        struct sockaddr_in * addr_ipv4 = (struct sockaddr_in*) &sockaddr_from;\n        from->type = NETCODE_ADDRESS_IPV4;\n        from->data.ipv4[0] = (uint8_t) ( ( addr_ipv4->sin_addr.s_addr & 0x000000FF ) );\n        from->data.ipv4[1] = (uint8_t) ( ( addr_ipv4->sin_addr.s_addr & 0x0000FF00 ) >> 8 );\n        from->data.ipv4[2] = (uint8_t) ( ( addr_ipv4->sin_addr.s_addr & 0x00FF0000 ) >> 16 );\n        from->data.ipv4[3] = (uint8_t) ( ( addr_ipv4->sin_addr.s_addr & 0xFF000000 ) >> 24 );\n        from->port = ntohs( addr_ipv4->sin_port );\n    }\n    else\n    {\n        netcode_assert( 0 );\n        return 0;\n    }\n  \n    netcode_assert( result >= 0 );\n\n    int bytes_read = result;\n\n    return bytes_read;\n}\n\n// ----------------------------------------------------------------\n\nvoid netcode_write_uint8( uint8_t ** p, uint8_t value )\n{\n    **p = value;\n    ++(*p);\n}\n\nvoid netcode_write_uint16( uint8_t ** p, uint16_t value )\n{\n    (*p)[0] = value & 0xFF;\n    (*p)[1] = value >> 8;\n    *p += 2;\n}\n\nvoid netcode_write_uint32( uint8_t ** p, uint32_t value )\n{\n    (*p)[0] = value & 0xFF;\n    (*p)[1] = ( value >> 8  ) & 0xFF;\n    (*p)[2] = ( value >> 16 ) & 0xFF;\n    (*p)[3] = value >> 24;\n    *p += 4;\n}\n\nvoid netcode_write_uint64( uint8_t ** p, uint64_t value )\n{\n    (*p)[0] = value & 0xFF;\n    (*p)[1] = ( value >> 8  ) & 0xFF;\n    (*p)[2] = ( value >> 16 ) & 0xFF;\n    (*p)[3] = ( value >> 24 ) & 0xFF;\n    (*p)[4] = ( value >> 32 ) & 0xFF;\n    (*p)[5] = ( value >> 40 ) & 0xFF;\n    (*p)[6] = ( value >> 48 ) & 0xFF;\n    (*p)[7] = value >> 56;\n    *p += 8;\n}\n\nvoid netcode_write_bytes( uint8_t ** p, uint8_t * byte_array, int num_bytes )\n{\n    int i;\n    for ( i = 0; i < num_bytes; i++ )\n    {\n        netcode_write_uint8( p, byte_array[i] );\n    }\n}\n\nuint8_t netcode_read_uint8( uint8_t ** p )\n{\n    uint8_t value = **p;\n    ++(*p);\n    return value;\n}\n\nuint16_t netcode_read_uint16( uint8_t ** p )\n{\n    uint16_t value;\n    value = (*p)[0];\n    value |= ( ( (uint16_t)( (*p)[1] ) ) << 8 );\n    *p += 2;\n    return value;\n}\n\nuint32_t netcode_read_uint32( uint8_t ** p )\n{\n    uint32_t value;\n    value  = (*p)[0];\n    value |= ( ( (uint32_t)( (*p)[1] ) ) << 8 );\n    value |= ( ( (uint32_t)( (*p)[2] ) ) << 16 );\n    value |= ( ( (uint32_t)( (*p)[3] ) ) << 24 );\n    *p += 4;\n    return value;\n}\n\nuint64_t netcode_read_uint64( uint8_t ** p )\n{\n    uint64_t value;\n    value  = (*p)[0];\n    value |= ( ( (uint64_t)( (*p)[1] ) ) << 8  );\n    value |= ( ( (uint64_t)( (*p)[2] ) ) << 16 );\n    value |= ( ( (uint64_t)( (*p)[3] ) ) << 24 );\n    value |= ( ( (uint64_t)( (*p)[4] ) ) << 32 );\n    value |= ( ( (uint64_t)( (*p)[5] ) ) << 40 );\n    value |= ( ( (uint64_t)( (*p)[6] ) ) << 48 );\n    value |= ( ( (uint64_t)( (*p)[7] ) ) << 56 );\n    *p += 8;\n    return value;\n}\n\nvoid netcode_read_bytes( uint8_t ** p, uint8_t * byte_array, int num_bytes )\n{\n    int i;\n    for ( i = 0; i < num_bytes; i++ )\n    {\n        byte_array[i] = netcode_read_uint8( p );\n    }\n}\n\n// ----------------------------------------------------------------\n\nvoid netcode_generate_key( uint8_t * key )\n{\n    netcode_assert( key );\n    randombytes_buf( key, NETCODE_KEY_BYTES );\n}\n\nvoid netcode_generate_nonce( uint8_t * nonce )\n{\n    netcode_assert( nonce );\n    randombytes_buf( nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n}\n\nvoid netcode_random_bytes( uint8_t * data, int bytes )\n{\n    netcode_assert( data );\n    netcode_assert( bytes > 0 );\n    randombytes_buf( data, bytes );\n}\n\nint netcode_encrypt_aead_bignonce( uint8_t * message, uint64_t message_length, \n                                   uint8_t * additional, uint64_t additional_length,\n                                   NETCODE_CONST uint8_t * nonce,\n                                   NETCODE_CONST uint8_t * key )\n{\n    unsigned long long encrypted_length;\n\n    int result = crypto_aead_xchacha20poly1305_ietf_encrypt( message, &encrypted_length,\n                                                             message, (unsigned long long) message_length,\n                                                             additional, (unsigned long long) additional_length,\n                                                             NULL, nonce, key );\n    \n    if ( result != 0 )\n        return NETCODE_ERROR;\n\n    netcode_assert( encrypted_length == message_length + NETCODE_MAC_BYTES );\n\n    return NETCODE_OK;\n}\n\nint netcode_decrypt_aead_bignonce( uint8_t * message, uint64_t message_length, \n                                   uint8_t * additional, uint64_t additional_length,\n                                   uint8_t * nonce,\n                                   uint8_t * key )\n{\n    unsigned long long decrypted_length;\n\n    int result = crypto_aead_xchacha20poly1305_ietf_decrypt( message, &decrypted_length,\n                                                             NULL,\n                                                             message, (unsigned long long) message_length,\n                                                             additional, (unsigned long long) additional_length,\n                                                             nonce, key );\n\n    if ( result != 0 )\n        return NETCODE_ERROR;\n\n    netcode_assert( decrypted_length == message_length - NETCODE_MAC_BYTES );\n\n    return NETCODE_OK;\n}\n\nint netcode_encrypt_aead( uint8_t * message, uint64_t message_length, \n                          uint8_t * additional, uint64_t additional_length,\n                          NETCODE_CONST uint8_t * nonce,\n                          NETCODE_CONST uint8_t * key )\n{\n    unsigned long long encrypted_length;\n\n    int result = crypto_aead_chacha20poly1305_ietf_encrypt( message, &encrypted_length,\n                                                            message, (unsigned long long) message_length,\n                                                            additional, (unsigned long long) additional_length,\n                                                            NULL, nonce, key );\n    \n    if ( result != 0 )\n        return NETCODE_ERROR;\n\n    netcode_assert( encrypted_length == message_length + NETCODE_MAC_BYTES );\n\n    return NETCODE_OK;\n}\n\nint netcode_decrypt_aead( uint8_t * message, uint64_t message_length, \n                          uint8_t * additional, uint64_t additional_length,\n                          uint8_t * nonce,\n                          uint8_t * key )\n{\n    unsigned long long decrypted_length;\n\n    int result = crypto_aead_chacha20poly1305_ietf_decrypt( message, &decrypted_length,\n                                                            NULL,\n                                                            message, (unsigned long long) message_length,\n                                                            additional, (unsigned long long) additional_length,\n                                                            nonce, key );\n\n    if ( result != 0 )\n        return NETCODE_ERROR;\n\n    netcode_assert( decrypted_length == message_length - NETCODE_MAC_BYTES );\n\n    return NETCODE_OK;\n}\n\n// ----------------------------------------------------------------\n\nstruct netcode_connect_token_private_t\n{\n    uint64_t client_id;\n    int timeout_seconds;\n    int num_server_addresses;\n    struct netcode_address_t server_addresses[NETCODE_MAX_SERVERS_PER_CONNECT];\n    uint8_t client_to_server_key[NETCODE_KEY_BYTES];\n    uint8_t server_to_client_key[NETCODE_KEY_BYTES];\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n};\n\nvoid netcode_generate_connect_token_private( struct netcode_connect_token_private_t * connect_token, \n                                             uint64_t client_id, \n                                             int timeout_seconds,\n                                             int num_server_addresses, \n                                             struct netcode_address_t * server_addresses, \n                                             uint8_t * user_data )\n{\n    netcode_assert( connect_token );\n    netcode_assert( num_server_addresses > 0 );\n    netcode_assert( num_server_addresses <= NETCODE_MAX_SERVERS_PER_CONNECT );\n    netcode_assert( server_addresses );\n    netcode_assert( user_data );\n\n    connect_token->client_id = client_id;\n    connect_token->timeout_seconds = timeout_seconds;\n    connect_token->num_server_addresses = num_server_addresses;\n    \n    int i;\n    for ( i = 0; i < num_server_addresses; i++ )\n    {\n        memcpy( &connect_token->server_addresses[i], &server_addresses[i], sizeof( struct netcode_address_t ) );\n    }\n\n    netcode_generate_key( connect_token->client_to_server_key );\n    netcode_generate_key( connect_token->server_to_client_key );\n\n    if ( user_data != NULL )\n    {\n        memcpy( connect_token->user_data, user_data, NETCODE_USER_DATA_BYTES );\n    }\n    else\n    {\n        memset( connect_token->user_data, 0, NETCODE_USER_DATA_BYTES );\n    }\n}\n\nvoid netcode_write_connect_token_private( struct netcode_connect_token_private_t * connect_token, uint8_t * buffer, int buffer_length )\n{\n    (void) buffer_length;\n\n    netcode_assert( connect_token );\n    netcode_assert( connect_token->num_server_addresses > 0 );\n    netcode_assert( connect_token->num_server_addresses <= NETCODE_MAX_SERVERS_PER_CONNECT );\n    netcode_assert( buffer );\n    netcode_assert( buffer_length >= NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    uint8_t * start = buffer;\n\n    (void) start;\n\n    netcode_write_uint64( &buffer, connect_token->client_id );\n\n    netcode_write_uint32( &buffer, connect_token->timeout_seconds );\n\n    netcode_write_uint32( &buffer, connect_token->num_server_addresses );\n\n    int i,j;\n\n    for ( i = 0; i < connect_token->num_server_addresses; i++ )\n    {\n        if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV4 )\n        {\n            netcode_write_uint8( &buffer, NETCODE_ADDRESS_IPV4 );\n            for ( j = 0; j < 4; j++ )\n            {\n                netcode_write_uint8( &buffer, connect_token->server_addresses[i].data.ipv4[j] );\n            }\n            netcode_write_uint16( &buffer, connect_token->server_addresses[i].port );\n        }\n        else if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV6 )\n        {\n            netcode_write_uint8( &buffer, NETCODE_ADDRESS_IPV6 );\n            for ( j = 0; j < 8; j++ )\n            {\n                netcode_write_uint16( &buffer, connect_token->server_addresses[i].data.ipv6[j] );\n            }\n            netcode_write_uint16( &buffer, connect_token->server_addresses[i].port );\n        }\n        else\n        {\n            netcode_assert( 0 );\n        }\n    }\n\n    netcode_write_bytes( &buffer, connect_token->client_to_server_key, NETCODE_KEY_BYTES );\n\n    netcode_write_bytes( &buffer, connect_token->server_to_client_key, NETCODE_KEY_BYTES );\n\n    netcode_write_bytes( &buffer, connect_token->user_data, NETCODE_USER_DATA_BYTES );\n\n    netcode_assert( buffer - start <= NETCODE_CONNECT_TOKEN_PRIVATE_BYTES - NETCODE_MAC_BYTES );\n\n    memset( buffer, 0, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES - ( buffer - start ) );\n}\n\nint netcode_encrypt_connect_token_private( uint8_t * buffer, \n                                           int buffer_length, \n                                           uint8_t * version_info, \n                                           uint64_t protocol_id, \n                                           uint64_t expire_timestamp, \n                                           NETCODE_CONST uint8_t * nonce, \n                                           NETCODE_CONST uint8_t * key )\n{\n    netcode_assert( buffer );\n    netcode_assert( buffer_length == NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n    netcode_assert( key );\n\n    (void) buffer_length;\n\n    uint8_t additional_data[NETCODE_VERSION_INFO_BYTES+8+8];\n    {\n        uint8_t * p = additional_data;\n        netcode_write_bytes( &p, version_info, NETCODE_VERSION_INFO_BYTES );\n        netcode_write_uint64( &p, protocol_id );\n        netcode_write_uint64( &p, expire_timestamp );\n    }\n\n    return netcode_encrypt_aead_bignonce( buffer, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES - NETCODE_MAC_BYTES, additional_data, sizeof( additional_data ), nonce, key );\n}\n\nint netcode_decrypt_connect_token_private( uint8_t * buffer, \n                                           int buffer_length, \n                                           uint8_t * version_info, \n                                           uint64_t protocol_id, \n                                           uint64_t expire_timestamp, \n                                           uint8_t * nonce, \n                                           uint8_t * key )\n{\n    netcode_assert( buffer );\n    netcode_assert( buffer_length == NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n    netcode_assert( key );\n\n    (void) buffer_length;\n\n    uint8_t additional_data[NETCODE_VERSION_INFO_BYTES+8+8];\n    {\n        uint8_t * p = additional_data;\n        netcode_write_bytes( &p, version_info, NETCODE_VERSION_INFO_BYTES );\n        netcode_write_uint64( &p, protocol_id );\n        netcode_write_uint64( &p, expire_timestamp );\n    }\n    return netcode_decrypt_aead_bignonce( buffer, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, additional_data, sizeof( additional_data ), nonce, key );\n}\n\nint netcode_read_connect_token_private( uint8_t * buffer, int buffer_length, struct netcode_connect_token_private_t * connect_token )\n{\n    netcode_assert( buffer );\n    netcode_assert( connect_token );\n\n    if ( buffer_length < NETCODE_CONNECT_TOKEN_PRIVATE_BYTES )\n        return NETCODE_ERROR;\n    \n    connect_token->client_id = netcode_read_uint64( &buffer );\n\n    connect_token->timeout_seconds = (int) netcode_read_uint32( &buffer );\n\n    connect_token->num_server_addresses = netcode_read_uint32( &buffer );\n\n    if ( connect_token->num_server_addresses <= 0 )\n        return NETCODE_ERROR;\n\n    if ( connect_token->num_server_addresses > NETCODE_MAX_SERVERS_PER_CONNECT )\n        return NETCODE_ERROR;\n\n    int i,j;\n\n    for ( i = 0; i < connect_token->num_server_addresses; i++ )\n    {\n        connect_token->server_addresses[i].type = netcode_read_uint8( &buffer );\n\n        if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV4 )\n        {\n            for ( j = 0; j < 4; j++ )\n            {\n                connect_token->server_addresses[i].data.ipv4[j] = netcode_read_uint8( &buffer );\n            }\n            connect_token->server_addresses[i].port = netcode_read_uint16( &buffer );\n        }\n        else if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV6 )\n        {\n            for ( j = 0; j < 8; j++ )\n            {\n                connect_token->server_addresses[i].data.ipv6[j] = netcode_read_uint16( &buffer );\n            }\n            connect_token->server_addresses[i].port = netcode_read_uint16( &buffer );\n        }\n        else\n        {\n            return NETCODE_ERROR;\n        }\n    }\n\n    netcode_read_bytes( &buffer, connect_token->client_to_server_key, NETCODE_KEY_BYTES );\n\n    netcode_read_bytes( &buffer, connect_token->server_to_client_key, NETCODE_KEY_BYTES );\n\n    netcode_read_bytes( &buffer, connect_token->user_data, NETCODE_USER_DATA_BYTES );\n\n    return NETCODE_OK;\n}\n\n// -----------------------------------------------\n\nstruct netcode_challenge_token_t\n{\n    uint64_t client_id;\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n};\n\nvoid netcode_write_challenge_token( struct netcode_challenge_token_t * challenge_token, uint8_t * buffer, int buffer_length )\n{\n    (void) buffer_length;\n\n    netcode_assert( challenge_token );\n    netcode_assert( buffer );\n    netcode_assert( buffer_length >= NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    memset( buffer, 0, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    uint8_t * start = buffer;\n\n    (void) start;\n\n    netcode_write_uint64( &buffer, challenge_token->client_id );\n\n    netcode_write_bytes( &buffer, challenge_token->user_data, NETCODE_USER_DATA_BYTES ); \n\n    netcode_assert( buffer - start <= NETCODE_CHALLENGE_TOKEN_BYTES - NETCODE_MAC_BYTES );\n}\n\nint netcode_encrypt_challenge_token( uint8_t * buffer, int buffer_length, uint64_t sequence, uint8_t * key )\n{\n    netcode_assert( buffer );\n    netcode_assert( buffer_length >= NETCODE_CHALLENGE_TOKEN_BYTES );\n    netcode_assert( key );\n\n    (void) buffer_length;\n\n    uint8_t nonce[12];\n    {\n        uint8_t * p = nonce;\n        netcode_write_uint32( &p, 0 );\n        netcode_write_uint64( &p, sequence );\n    }\n\n    return netcode_encrypt_aead( buffer, NETCODE_CHALLENGE_TOKEN_BYTES - NETCODE_MAC_BYTES, NULL, 0, nonce, key );\n}\n\nint netcode_decrypt_challenge_token( uint8_t * buffer, int buffer_length, uint64_t sequence, uint8_t * key )\n{\n    netcode_assert( buffer );\n    netcode_assert( buffer_length >= NETCODE_CHALLENGE_TOKEN_BYTES );\n    netcode_assert( key );\n\n    (void) buffer_length;\n\n    uint8_t nonce[12];\n    {\n        uint8_t * p = nonce;\n        netcode_write_uint32( &p, 0 );\n        netcode_write_uint64( &p, sequence );\n    }\n\n    return netcode_decrypt_aead( buffer, NETCODE_CHALLENGE_TOKEN_BYTES, NULL, 0, nonce, key );\n}\n\nint netcode_read_challenge_token( uint8_t * buffer, int buffer_length, struct netcode_challenge_token_t * challenge_token )\n{\n    netcode_assert( buffer );\n    netcode_assert( challenge_token );\n\n    if ( buffer_length < NETCODE_CHALLENGE_TOKEN_BYTES )\n        return NETCODE_ERROR;\n\n    uint8_t * start = buffer;\n\n    (void) start;\n    \n    challenge_token->client_id = netcode_read_uint64( &buffer );\n\n    netcode_read_bytes( &buffer, challenge_token->user_data, NETCODE_USER_DATA_BYTES );\n\n    netcode_assert( buffer - start == 8 + NETCODE_USER_DATA_BYTES );\n\n    return NETCODE_OK;\n}\n\n// ----------------------------------------------------------------\n\n#define NETCODE_CONNECTION_REQUEST_PACKET           0\n#define NETCODE_CONNECTION_DENIED_PACKET            1\n#define NETCODE_CONNECTION_CHALLENGE_PACKET         2\n#define NETCODE_CONNECTION_RESPONSE_PACKET          3\n#define NETCODE_CONNECTION_KEEP_ALIVE_PACKET        4\n#define NETCODE_CONNECTION_PAYLOAD_PACKET           5\n#define NETCODE_CONNECTION_DISCONNECT_PACKET        6\n#define NETCODE_CONNECTION_NUM_PACKETS              7\n\nstruct netcode_connection_request_packet_t\n{\n    uint8_t packet_type;\n    uint8_t version_info[NETCODE_VERSION_INFO_BYTES];\n    uint64_t protocol_id;\n    uint64_t connect_token_expire_timestamp;\n    uint8_t connect_token_nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n    uint8_t connect_token_data[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n};\n\nstruct netcode_connection_denied_packet_t\n{\n    uint8_t packet_type;\n};\n\nstruct netcode_connection_challenge_packet_t\n{\n    uint8_t packet_type;\n    uint64_t challenge_token_sequence;\n    uint8_t challenge_token_data[NETCODE_CHALLENGE_TOKEN_BYTES];\n};\n\nstruct netcode_connection_response_packet_t\n{\n    uint8_t packet_type;\n    uint64_t challenge_token_sequence;\n    uint8_t challenge_token_data[NETCODE_CHALLENGE_TOKEN_BYTES];\n};\n\nstruct netcode_connection_keep_alive_packet_t\n{\n    uint8_t packet_type;\n    int client_index;\n    int max_clients;\n};\n\nstruct netcode_connection_payload_packet_t\n{\n    uint8_t packet_type;\n    uint32_t payload_bytes;\n    uint8_t payload_data[1];\n};\n\nstruct netcode_connection_disconnect_packet_t\n{\n    uint8_t packet_type;\n};\n\nstruct netcode_connection_payload_packet_t * netcode_create_payload_packet( int payload_bytes, void * allocator_context, void* (*allocate_function)(void*,size_t) )\n{\n    netcode_assert( payload_bytes >= 0 );\n    netcode_assert( payload_bytes <= NETCODE_MAX_PAYLOAD_BYTES );\n\n    if ( allocate_function == NULL )\n    {\n        allocate_function = netcode_default_allocate_function;\n    }\n\n    struct netcode_connection_payload_packet_t * packet = (struct netcode_connection_payload_packet_t*) \n        allocate_function( allocator_context, sizeof( struct netcode_connection_payload_packet_t ) + payload_bytes );\n\n    if ( !packet )\n        return NULL;\n    \n    packet->packet_type = NETCODE_CONNECTION_PAYLOAD_PACKET;\n    packet->payload_bytes = payload_bytes;\n\n    return packet;\n}\n\nstruct netcode_context_t\n{\n    uint8_t write_packet_key[NETCODE_KEY_BYTES];\n    uint8_t read_packet_key[NETCODE_KEY_BYTES];\n};\n\nint netcode_sequence_number_bytes_required( uint64_t sequence )\n{\n    int i;\n    uint64_t mask = 0xFF00000000000000UL;\n    for ( i = 0; i < 7; i++ )\n    {\n        if ( sequence & mask )\n            break;\n        mask >>= 8;\n    }\n    return 8 - i;\n}\n\nint netcode_write_packet( void * packet, uint8_t * buffer, int buffer_length, uint64_t sequence, uint8_t * write_packet_key, uint64_t protocol_id )\n{\n    netcode_assert( packet );\n    netcode_assert( buffer );\n    netcode_assert( write_packet_key );\n\n    (void) buffer_length;\n\n    uint8_t packet_type = ((uint8_t*)packet)[0];\n\n    if ( packet_type == NETCODE_CONNECTION_REQUEST_PACKET )\n    {\n        // connection request packet: first byte is zero\n\n        netcode_assert( buffer_length >= 1 + 13 + 8 + 8 + NETCODE_CONNECT_TOKEN_NONCE_BYTES + NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n        struct netcode_connection_request_packet_t * p = (struct netcode_connection_request_packet_t*) packet;\n\n        uint8_t * start = buffer;\n\n        netcode_write_uint8( &buffer, NETCODE_CONNECTION_REQUEST_PACKET );\n        netcode_write_bytes( &buffer, p->version_info, NETCODE_VERSION_INFO_BYTES );\n        netcode_write_uint64( &buffer, p->protocol_id );\n        netcode_write_uint64( &buffer, p->connect_token_expire_timestamp );\n        netcode_write_bytes( &buffer, p->connect_token_nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n        netcode_write_bytes( &buffer, p->connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n        netcode_assert( buffer - start == 1 + 13 + 8 + 8 + NETCODE_CONNECT_TOKEN_NONCE_BYTES + NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n        return (int) ( buffer - start );\n    }\n    else\n    {\n        // *** encrypted packets ***\n\n        // write the prefix byte (this is a combination of the packet type and number of sequence bytes)\n\n        uint8_t * start = buffer;\n\n        uint8_t sequence_bytes = (uint8_t) netcode_sequence_number_bytes_required( sequence );\n\n        netcode_assert( sequence_bytes >= 1 );\n        netcode_assert( sequence_bytes <= 8 );\n\n        netcode_assert( packet_type <= 0xF );\n\n        uint8_t prefix_byte = packet_type | ( sequence_bytes << 4 );\n\n        netcode_write_uint8( &buffer, prefix_byte );\n\n        // write the variable length sequence number [1,8] bytes.\n\n        uint64_t sequence_temp = sequence;\n\n        int i;\n        for ( i = 0; i < sequence_bytes; i++ )\n        {\n            netcode_write_uint8( &buffer, (uint8_t) ( sequence_temp & 0xFF ) );\n            sequence_temp >>= 8;\n        }\n\n        // write packet data according to type. this data will be encrypted.\n\n        uint8_t * encrypted_start = buffer;\n\n        switch ( packet_type )\n        {\n            case NETCODE_CONNECTION_DENIED_PACKET:\n            {\n                // ...\n            }\n            break;\n\n            case NETCODE_CONNECTION_CHALLENGE_PACKET:\n            {\n                struct netcode_connection_challenge_packet_t * p = (struct netcode_connection_challenge_packet_t*) packet;\n                netcode_write_uint64( &buffer, p->challenge_token_sequence );\n                netcode_write_bytes( &buffer, p->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n            }\n            break;\n\n            case NETCODE_CONNECTION_RESPONSE_PACKET:\n            {\n                struct netcode_connection_response_packet_t * p = (struct netcode_connection_response_packet_t*) packet;\n                netcode_write_uint64( &buffer, p->challenge_token_sequence );\n                netcode_write_bytes( &buffer, p->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n            }\n            break;\n\n            case NETCODE_CONNECTION_KEEP_ALIVE_PACKET:\n            {\n                struct netcode_connection_keep_alive_packet_t * p = (struct netcode_connection_keep_alive_packet_t*) packet;\n                netcode_write_uint32( &buffer, p->client_index );\n                netcode_write_uint32( &buffer, p->max_clients );\n            }\n            break;\n\n            case NETCODE_CONNECTION_PAYLOAD_PACKET:\n            {\n                struct netcode_connection_payload_packet_t * p = (struct netcode_connection_payload_packet_t*) packet;\n\n                netcode_assert( p->payload_bytes <= NETCODE_MAX_PAYLOAD_BYTES );\n\n                netcode_write_bytes( &buffer, p->payload_data, p->payload_bytes );\n            }\n            break;\n\n            case NETCODE_CONNECTION_DISCONNECT_PACKET:\n            {\n                // ...\n            }\n            break;\n\n            default:\n                netcode_assert( 0 );\n        }\n\n        netcode_assert( buffer - start <= buffer_length - NETCODE_MAC_BYTES );\n\n        uint8_t * encrypted_finish = buffer;\n\n        // encrypt the per-packet packet written with the prefix byte, protocol id and version as the associated data. this must match to decrypt.\n\n        uint8_t additional_data[NETCODE_VERSION_INFO_BYTES+8+1];\n        {\n            uint8_t * p = additional_data;\n            netcode_write_bytes( &p, NETCODE_VERSION_INFO, NETCODE_VERSION_INFO_BYTES );\n            netcode_write_uint64( &p, protocol_id );\n            netcode_write_uint8( &p, prefix_byte );\n        }\n\n        uint8_t nonce[12];\n        {\n            uint8_t * p = nonce;\n            netcode_write_uint32( &p, 0 );\n            netcode_write_uint64( &p, sequence );\n        }\n\n        if ( netcode_encrypt_aead( encrypted_start, \n                                   encrypted_finish - encrypted_start, \n                                   additional_data, sizeof( additional_data ), \n                                   nonce, write_packet_key ) != NETCODE_OK )\n        {\n            return NETCODE_ERROR;\n        }\n\n        buffer += NETCODE_MAC_BYTES;\n\n        netcode_assert( buffer - start <= buffer_length );\n\n        return (int) ( buffer - start );\n    }\n}\n\nstruct netcode_replay_protection_t\n{\n    uint64_t most_recent_sequence;\n    uint64_t received_packet[NETCODE_REPLAY_PROTECTION_BUFFER_SIZE];\n};\n\nvoid netcode_replay_protection_reset( struct netcode_replay_protection_t * replay_protection )\n{\n    netcode_assert( replay_protection );\n    replay_protection->most_recent_sequence = 0;\n    memset( replay_protection->received_packet, 0xFF, sizeof( replay_protection->received_packet ) );\n}\n\nint netcode_replay_protection_already_received( struct netcode_replay_protection_t * replay_protection, uint64_t sequence )\n{\n    netcode_assert( replay_protection );\n\n    if ( sequence + NETCODE_REPLAY_PROTECTION_BUFFER_SIZE <= replay_protection->most_recent_sequence )\n        return 1;\n    \n    int index = (int) ( sequence % NETCODE_REPLAY_PROTECTION_BUFFER_SIZE );\n\n    if ( replay_protection->received_packet[index] == UINT64_MAX )\n        return 0;\n\n    if ( replay_protection->received_packet[index] >= sequence )\n        return 1;\n\n    return 0;\n}\n\nvoid netcode_replay_protection_advance_sequence( struct netcode_replay_protection_t * replay_protection, uint64_t sequence )\n{\n    netcode_assert( replay_protection );\n\n    if ( sequence > replay_protection->most_recent_sequence )\n        replay_protection->most_recent_sequence = sequence;\n\n    int index = (int) ( sequence % NETCODE_REPLAY_PROTECTION_BUFFER_SIZE );\n\n    replay_protection->received_packet[index] = sequence;\n}\n\nvoid * netcode_read_packet( uint8_t * buffer, \n                            int buffer_length, \n                            uint64_t * sequence, \n                            uint8_t * read_packet_key, \n                            uint64_t protocol_id, \n                            uint64_t current_timestamp, \n                            uint8_t * private_key, \n                            uint8_t * allowed_packets, \n                            struct netcode_replay_protection_t * replay_protection, \n                            void * allocator_context, \n                            void* (*allocate_function)(void*,size_t) )\n{\n    netcode_assert( sequence );\n    netcode_assert( allowed_packets );\n\n    *sequence = 0;\n\n    if ( allocate_function == NULL )\n    {\n        allocate_function = netcode_default_allocate_function;\n    }\n\n    if ( buffer_length < 1 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored packet. buffer length is less than 1\\n\" );\n        return NULL;\n    }\n\n    uint8_t * start = buffer;\n\n    uint8_t prefix_byte = netcode_read_uint8( &buffer );\n\n    if ( prefix_byte == NETCODE_CONNECTION_REQUEST_PACKET )\n    {\n        // connection request packet: first byte is zero\n\n        if ( !allowed_packets[NETCODE_CONNECTION_REQUEST_PACKET] )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. packet type is not allowed\\n\" );\n            return NULL;\n        }\n\n        if ( buffer_length != 1 + NETCODE_VERSION_INFO_BYTES + 8 + 8 + NETCODE_CONNECT_TOKEN_NONCE_BYTES + NETCODE_CONNECT_TOKEN_PRIVATE_BYTES )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. bad packet length (expected %d, got %d)\\n\", 1 + NETCODE_VERSION_INFO_BYTES + 8 + 8 + NETCODE_CONNECT_TOKEN_NONCE_BYTES + NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, buffer_length );\n            return NULL;\n        }\n\n        if ( !private_key )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. no private key\\n\" );\n            return NULL;\n        }\n\n        uint8_t version_info[NETCODE_VERSION_INFO_BYTES];\n        netcode_read_bytes( &buffer, version_info, NETCODE_VERSION_INFO_BYTES );\n        if ( version_info[0]  != 'N' || \n             version_info[1]  != 'E' || \n             version_info[2]  != 'T' || \n             version_info[3]  != 'C' || \n             version_info[4]  != 'O' ||\n             version_info[5]  != 'D' ||\n             version_info[6]  != 'E' ||\n             version_info[7]  != ' ' || \n             version_info[8]  != '1' ||\n             version_info[9]  != '.' ||\n             version_info[10] != '0' ||\n             version_info[11] != '2' ||\n             version_info[12] != '\\0' )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. bad version info\\n\" );\n            return NULL;\n        }\n\n        uint64_t packet_protocol_id = netcode_read_uint64( &buffer );\n        if ( packet_protocol_id != protocol_id )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. wrong protocol id. expected %.16\" PRIx64 \", got %.16\" PRIx64 \"\\n\", \n                protocol_id, packet_protocol_id );\n            return NULL;\n        }\n\n        uint64_t packet_connect_token_expire_timestamp = netcode_read_uint64( &buffer );\n        if ( packet_connect_token_expire_timestamp <= current_timestamp )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. connect token expired\\n\" );\n            return NULL;\n        }\n\n        uint8_t packet_connect_token_nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n        netcode_read_bytes(&buffer, packet_connect_token_nonce, sizeof(packet_connect_token_nonce));\n\n        netcode_assert( buffer - start == 1 + NETCODE_VERSION_INFO_BYTES + 8 + 8 + NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n\n        if ( netcode_decrypt_connect_token_private( buffer, \n                                                    NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, \n                                                    version_info, \n                                                    protocol_id, \n                                                    packet_connect_token_expire_timestamp, \n                                                    packet_connect_token_nonce, \n                                                    private_key ) != NETCODE_OK )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. connect token failed to decrypt\\n\" );\n            return NULL;\n        }\n\n        struct netcode_connection_request_packet_t * packet = (struct netcode_connection_request_packet_t*) \n            allocate_function( allocator_context, sizeof( struct netcode_connection_request_packet_t ) );\n\n        if ( !packet )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection request packet. failed to allocate packet\\n\" );\n            return NULL;\n        }\n\n        packet->packet_type = NETCODE_CONNECTION_REQUEST_PACKET;\n        memcpy( packet->version_info, version_info, NETCODE_VERSION_INFO_BYTES );\n        packet->protocol_id = packet_protocol_id;\n        packet->connect_token_expire_timestamp = packet_connect_token_expire_timestamp;\n        memcpy( packet->connect_token_nonce, packet_connect_token_nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n        netcode_read_bytes( &buffer, packet->connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n        netcode_assert( buffer - start == 1 + NETCODE_VERSION_INFO_BYTES + 8 + 8 + NETCODE_CONNECT_TOKEN_NONCE_BYTES + NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n        return packet;\n    }\n    else\n    {\n        // *** encrypted packets ***\n\n        if ( !read_packet_key )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. no read packet key for this address\\n\" );\n            return NULL;\n        }\n\n        if ( buffer_length < 1 + 1 + NETCODE_MAC_BYTES )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. packet is too small to be valid (%d bytes)\\n\", buffer_length );\n            return NULL;\n        }\n\n        // extract the packet type and number of sequence bytes from the prefix byte\n\n        int packet_type = prefix_byte & 0xF;\n\n        if ( packet_type >= NETCODE_CONNECTION_NUM_PACKETS )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. packet type %d is invalid\\n\", packet_type );\n            return NULL;\n        }\n\n        if ( !allowed_packets[packet_type] )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. packet type %d is not allowed\\n\", packet_type );\n            return NULL;\n        }\n\n        int sequence_bytes = prefix_byte >> 4;\n\n        if ( sequence_bytes < 1 || sequence_bytes > 8 )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. sequence bytes %d is out of range [1,8]\\n\", sequence_bytes );\n            return NULL;\n        }\n\n        if ( buffer_length < 1 + sequence_bytes + NETCODE_MAC_BYTES )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. buffer is too small for sequence bytes + encryption mac\\n\" );\n            return NULL;\n        }\n\n        // read variable length sequence number [1,8]\n\n        int i;\n        for ( i = 0; i < sequence_bytes; i++ )\n        {\n            uint8_t value = netcode_read_uint8( &buffer );\n            (*sequence) |= ( uint64_t) ( value ) << ( 8 * i );\n        }\n\n        // ignore the packet if it has already been received\n\n        if ( replay_protection && packet_type >= NETCODE_CONNECTION_KEEP_ALIVE_PACKET )\n        {\n            if ( netcode_replay_protection_already_received( replay_protection, *sequence ) )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored packet. sequence %.16\" PRIx64 \" already received (replay protection)\\n\", *sequence );\n                return NULL;\n            }\n        }\n\n        // decrypt the per-packet type data\n\n        uint8_t additional_data[NETCODE_VERSION_INFO_BYTES+8+1];\n        {\n            uint8_t * p = additional_data;\n            netcode_write_bytes( &p, NETCODE_VERSION_INFO, NETCODE_VERSION_INFO_BYTES );\n            netcode_write_uint64( &p, protocol_id );\n            netcode_write_uint8( &p, prefix_byte );\n        }\n\n        uint8_t nonce[12];\n        {\n            uint8_t * p = nonce;\n            netcode_write_uint32( &p, 0 );\n            netcode_write_uint64( &p, *sequence );\n        }\n\n        int encrypted_bytes = (int) ( buffer_length - ( buffer - start ) );\n\n        if ( encrypted_bytes < NETCODE_MAC_BYTES )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. encrypted payload is too small\\n\" );\n            return NULL;\n        }\n\n        if ( netcode_decrypt_aead( buffer, encrypted_bytes, additional_data, sizeof( additional_data ), nonce, read_packet_key ) != NETCODE_OK )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored encrypted packet. failed to decrypt\\n\" );\n            return NULL;\n        }\n\n        int decrypted_bytes = encrypted_bytes - NETCODE_MAC_BYTES;\n\n        // update the latest replay protection sequence #\n\n        if ( replay_protection && packet_type >= NETCODE_CONNECTION_KEEP_ALIVE_PACKET )\n        {\n            netcode_replay_protection_advance_sequence( replay_protection, *sequence );\n        }\n\n        // process the per-packet type data that was just decrypted\n        \n        switch ( packet_type )\n        {\n            case NETCODE_CONNECTION_DENIED_PACKET:\n            {\n                if ( decrypted_bytes != 0 )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection denied packet. decrypted packet data is wrong size\\n\" );\n                    return NULL;\n                }\n\n                struct netcode_connection_denied_packet_t * packet = (struct netcode_connection_denied_packet_t*) \n                    allocate_function( allocator_context, sizeof( struct netcode_connection_denied_packet_t ) );\n\n                if ( !packet )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection denied packet. could not allocate packet struct\\n\" );\n                    return NULL;\n                }\n                \n                packet->packet_type = NETCODE_CONNECTION_DENIED_PACKET;\n                \n                return packet;\n            }\n            break;\n\n            case NETCODE_CONNECTION_CHALLENGE_PACKET:\n            {\n                if ( decrypted_bytes != 8 + NETCODE_CHALLENGE_TOKEN_BYTES )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection challenge packet. decrypted packet data is wrong size\\n\" );\n                    return NULL;\n                }\n\n                struct netcode_connection_challenge_packet_t * packet = (struct netcode_connection_challenge_packet_t*) \n                    allocate_function( allocator_context, sizeof( struct netcode_connection_challenge_packet_t ) );\n\n                if ( !packet )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection challenge packet. could not allocate packet struct\\n\" );\n                    return NULL;\n                }\n                \n                packet->packet_type = NETCODE_CONNECTION_CHALLENGE_PACKET;\n                packet->challenge_token_sequence = netcode_read_uint64( &buffer );\n                netcode_read_bytes( &buffer, packet->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n                \n                return packet;\n            }\n            break;\n\n            case NETCODE_CONNECTION_RESPONSE_PACKET:\n            {\n                if ( decrypted_bytes != 8 + NETCODE_CHALLENGE_TOKEN_BYTES )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection response packet. decrypted packet data is wrong size\\n\" );\n                    return NULL;\n                }\n\n                struct netcode_connection_response_packet_t * packet = (struct netcode_connection_response_packet_t*) \n                    allocate_function( allocator_context, sizeof( struct netcode_connection_response_packet_t ) );\n\n                if ( !packet )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection response packet. could not allocate packet struct\\n\" );\n                    return NULL;\n                }\n                \n                packet->packet_type = NETCODE_CONNECTION_RESPONSE_PACKET;\n                packet->challenge_token_sequence = netcode_read_uint64( &buffer );\n                netcode_read_bytes( &buffer, packet->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n                \n                return packet;\n            }\n            break;\n\n            case NETCODE_CONNECTION_KEEP_ALIVE_PACKET:\n            {\n                if ( decrypted_bytes != 8 )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection keep alive packet. decrypted packet data is wrong size\\n\" );\n                    return NULL;\n                }\n\n                struct netcode_connection_keep_alive_packet_t * packet = (struct netcode_connection_keep_alive_packet_t*) \n                    allocate_function( allocator_context, sizeof( struct netcode_connection_keep_alive_packet_t ) );\n\n                if ( !packet )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection keep alive packet. could not allocate packet struct\\n\" );\n                    return NULL;\n                }\n                \n                packet->packet_type = NETCODE_CONNECTION_KEEP_ALIVE_PACKET;\n                packet->client_index = netcode_read_uint32( &buffer );\n                packet->max_clients = netcode_read_uint32( &buffer );\n                \n                return packet;\n            }\n            break;\n            \n            case NETCODE_CONNECTION_PAYLOAD_PACKET:\n            {\n                if ( decrypted_bytes < 1 )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection payload packet. payload is too small\\n\" );\n                    return NULL;\n                }\n\n                if ( decrypted_bytes > NETCODE_MAX_PAYLOAD_BYTES )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection payload packet. payload is too large\\n\" );\n                    return NULL;\n                }\n\n                struct netcode_connection_payload_packet_t * packet = netcode_create_payload_packet( decrypted_bytes, allocator_context, allocate_function );\n\n                if ( !packet )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection payload packet. could not allocate packet struct\\n\" );\n                    return NULL;\n                }\n                \n                memcpy( packet->payload_data, buffer, decrypted_bytes );\n                \n                return packet;\n            }\n            break;\n\n            case NETCODE_CONNECTION_DISCONNECT_PACKET:\n            {\n                if ( decrypted_bytes != 0 )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection disconnect packet. decrypted packet data is wrong size\\n\" );\n                    return NULL;\n                }\n\n                struct netcode_connection_disconnect_packet_t * packet = (struct netcode_connection_disconnect_packet_t*) \n                    allocate_function( allocator_context, sizeof( struct netcode_connection_disconnect_packet_t ) );\n\n                if ( !packet )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"ignored connection disconnect packet. could not allocate packet struct\\n\" );\n                    return NULL;\n                }\n                \n                packet->packet_type = NETCODE_CONNECTION_DISCONNECT_PACKET;\n                \n                return packet;\n            }\n            break;\n\n            default:\n                return NULL;\n        }\n    }\n}\n\n// ----------------------------------------------------------------\n\nstruct netcode_connect_token_t\n{\n    uint8_t version_info[NETCODE_VERSION_INFO_BYTES];\n    uint64_t protocol_id;\n    uint64_t create_timestamp;\n    uint64_t expire_timestamp;\n    uint8_t nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n    uint8_t private_data[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n    int timeout_seconds;\n    int num_server_addresses;\n    struct netcode_address_t server_addresses[NETCODE_MAX_SERVERS_PER_CONNECT];\n    uint8_t client_to_server_key[NETCODE_KEY_BYTES];\n    uint8_t server_to_client_key[NETCODE_KEY_BYTES];\n};\n\nvoid netcode_write_connect_token( struct netcode_connect_token_t * connect_token, uint8_t * buffer, int buffer_length )\n{\n    netcode_assert( connect_token );\n    netcode_assert( buffer );\n    netcode_assert( buffer_length >= NETCODE_CONNECT_TOKEN_BYTES );\n\n    uint8_t * start = buffer;\n\n    (void) start;\n    (void) buffer_length;\n\n    netcode_write_bytes( &buffer, connect_token->version_info, NETCODE_VERSION_INFO_BYTES );\n\n    netcode_write_uint64( &buffer, connect_token->protocol_id );\n\n    netcode_write_uint64( &buffer, connect_token->create_timestamp );\n\n    netcode_write_uint64( &buffer, connect_token->expire_timestamp );\n\n    netcode_write_bytes( &buffer, connect_token->nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n\n    netcode_write_bytes( &buffer, connect_token->private_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    int i,j;\n\n    netcode_write_uint32( &buffer, connect_token->timeout_seconds );\n\n    netcode_write_uint32( &buffer, connect_token->num_server_addresses );\n\n    for ( i = 0; i < connect_token->num_server_addresses; i++ )\n    {\n        if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV4 )\n        {\n            netcode_write_uint8( &buffer, NETCODE_ADDRESS_IPV4 );\n            for ( j = 0; j < 4; j++ )\n            {\n                netcode_write_uint8( &buffer, connect_token->server_addresses[i].data.ipv4[j] );\n            }\n            netcode_write_uint16( &buffer, connect_token->server_addresses[i].port );\n        }\n        else if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV6 )\n        {\n            netcode_write_uint8( &buffer, NETCODE_ADDRESS_IPV6 );\n            for ( j = 0; j < 8; j++ )\n            {\n                netcode_write_uint16( &buffer, connect_token->server_addresses[i].data.ipv6[j] );\n            }\n            netcode_write_uint16( &buffer, connect_token->server_addresses[i].port );\n        }\n        else\n        {\n            netcode_assert( 0 );\n        }\n    }\n\n    netcode_write_bytes( &buffer, connect_token->client_to_server_key, NETCODE_KEY_BYTES );\n\n    netcode_write_bytes( &buffer, connect_token->server_to_client_key, NETCODE_KEY_BYTES );\n\n    netcode_assert( buffer - start <= NETCODE_CONNECT_TOKEN_BYTES );\n\n    memset( buffer, 0, NETCODE_CONNECT_TOKEN_BYTES - ( buffer - start ) );\n}\n\nint netcode_read_connect_token( uint8_t * buffer, int buffer_length, struct netcode_connect_token_t * connect_token )\n{\n    netcode_assert( buffer );\n    netcode_assert( connect_token );\n\n    if ( buffer_length != NETCODE_CONNECT_TOKEN_BYTES )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: read connect data has bad buffer length (%d)\\n\", buffer_length );\n        return NETCODE_ERROR;\n    }\n\n    netcode_read_bytes( &buffer, connect_token->version_info, NETCODE_VERSION_INFO_BYTES );\n    if ( connect_token->version_info[0]  != 'N' || \n         connect_token->version_info[1]  != 'E' || \n         connect_token->version_info[2]  != 'T' || \n         connect_token->version_info[3]  != 'C' || \n         connect_token->version_info[4]  != 'O' ||\n         connect_token->version_info[5]  != 'D' ||\n         connect_token->version_info[6]  != 'E' ||\n         connect_token->version_info[7]  != ' ' || \n         connect_token->version_info[8]  != '1' ||\n         connect_token->version_info[9]  != '.' ||\n         connect_token->version_info[10] != '0' ||\n         connect_token->version_info[11] != '2' ||\n         connect_token->version_info[12] != '\\0' )\n    {\n        connect_token->version_info[12] = '\\0';\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: read connect data has bad version info (got %s, expected %s)\\n\", connect_token->version_info, NETCODE_VERSION_INFO );\n        return NETCODE_ERROR;\n    }\n\n    connect_token->protocol_id = netcode_read_uint64( &buffer );\n\n    connect_token->create_timestamp = netcode_read_uint64( &buffer );\n\n    connect_token->expire_timestamp = netcode_read_uint64( &buffer );\n\n    if ( connect_token->create_timestamp > connect_token->expire_timestamp )\n        return NETCODE_ERROR;\n\n    netcode_read_bytes( &buffer, connect_token->nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n\n    netcode_read_bytes( &buffer, connect_token->private_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    connect_token->timeout_seconds = (int) netcode_read_uint32( &buffer );\n\n    connect_token->num_server_addresses = netcode_read_uint32( &buffer );\n\n    if ( connect_token->num_server_addresses <= 0 || connect_token->num_server_addresses > NETCODE_MAX_SERVERS_PER_CONNECT )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: read connect data has bad number of server addresses (%d)\\n\", connect_token->num_server_addresses );\n        return NETCODE_ERROR;\n    }\n\n    int i,j;\n\n    for ( i = 0; i < connect_token->num_server_addresses; i++ )\n    {\n        connect_token->server_addresses[i].type = netcode_read_uint8( &buffer );\n\n        if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV4 )\n        {\n            for ( j = 0; j < 4; j++ )\n            {\n                connect_token->server_addresses[i].data.ipv4[j] = netcode_read_uint8( &buffer );\n            }\n            connect_token->server_addresses[i].port = netcode_read_uint16( &buffer );\n        }\n        else if ( connect_token->server_addresses[i].type == NETCODE_ADDRESS_IPV6 )\n        {\n            for ( j = 0; j < 8; j++ )\n            {\n                connect_token->server_addresses[i].data.ipv6[j] = netcode_read_uint16( &buffer );\n            }\n            connect_token->server_addresses[i].port = netcode_read_uint16( &buffer );\n        }\n        else\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: read connect data has bad address type (%d)\\n\", connect_token->server_addresses[i].type );\n            return NETCODE_ERROR;\n        }\n    }\n\n    netcode_read_bytes( &buffer, connect_token->client_to_server_key, NETCODE_KEY_BYTES );\n\n    netcode_read_bytes( &buffer, connect_token->server_to_client_key, NETCODE_KEY_BYTES );\n    \n    return NETCODE_OK;\n}\n\n// ----------------------------------------------------------------\n\nstruct netcode_packet_queue_t\n{\n    void * allocator_context;\n    void * (*allocate_function)(void*,size_t);\n    void (*free_function)(void*,void*);\n    int num_packets;\n    int start_index;\n    void * packet_data[NETCODE_PACKET_QUEUE_SIZE];\n    uint64_t packet_sequence[NETCODE_PACKET_QUEUE_SIZE];\n};\n\nvoid netcode_packet_queue_init( struct netcode_packet_queue_t * queue, \n                                void * allocator_context, \n                                void * (*allocate_function)(void*,size_t), \n                                void (*free_function)(void*,void*) )\n{\n    if ( allocate_function == NULL )\n    {\n        allocate_function = netcode_default_allocate_function;\n    }\n\n    if ( free_function == NULL )\n    {\n        free_function = netcode_default_free_function;\n    }\n\n    netcode_assert( queue );\n\n    queue->allocator_context = allocator_context;\n    queue->allocate_function = allocate_function;\n    queue->free_function = free_function;\n    queue->num_packets = 0;\n    queue->start_index = 0;\n    memset( queue->packet_data, 0, sizeof( queue->packet_data ) );\n    memset( queue->packet_sequence, 0, sizeof( queue->packet_sequence ) );\n}\n\nvoid netcode_packet_queue_clear( struct netcode_packet_queue_t * queue )\n{\n    int i;\n    for ( i = 0; i < queue->num_packets; i++ )\n    {\n        queue->free_function( queue->allocator_context, queue->packet_data[i] );\n    }\n    queue->num_packets = 0;\n    queue->start_index = 0;\n    memset( queue->packet_data, 0, sizeof( queue->packet_data ) );\n    memset( queue->packet_sequence, 0, sizeof( queue->packet_sequence ) );\n}\n\nint netcode_packet_queue_push( struct netcode_packet_queue_t * queue, void * packet_data, uint64_t packet_sequence )\n{\n    netcode_assert( queue );\n    netcode_assert( packet_data );\n    if ( queue->num_packets == NETCODE_PACKET_QUEUE_SIZE )\n    {\n        queue->free_function( queue->allocator_context, packet_data );\n        return 0;\n    }\n    int index = ( queue->start_index + queue->num_packets ) % NETCODE_PACKET_QUEUE_SIZE;\n    queue->packet_data[index] = packet_data;\n    queue->packet_sequence[index] = packet_sequence;\n    queue->num_packets++;\n    return 1;\n}\n\nvoid * netcode_packet_queue_pop( struct netcode_packet_queue_t * queue, uint64_t * packet_sequence )\n{\n    if ( queue->num_packets == 0 )\n        return NULL;\n    void * packet = queue->packet_data[queue->start_index];\n    if ( packet_sequence )\n        *packet_sequence = queue->packet_sequence[queue->start_index];\n    queue->start_index = ( queue->start_index + 1 ) % NETCODE_PACKET_QUEUE_SIZE;\n    queue->num_packets--;\n    return packet;\n}\n\n// ----------------------------------------------------------------\n\n#define NETCODE_NETWORK_SIMULATOR_NUM_PACKET_ENTRIES ( NETCODE_MAX_CLIENTS * 256 )\n#define NETCODE_NETWORK_SIMULATOR_NUM_PENDING_RECEIVE_PACKETS ( NETCODE_MAX_CLIENTS * 64 )\n\nstruct netcode_network_simulator_packet_entry_t\n{\n    struct netcode_address_t from;\n    struct netcode_address_t to;\n    double delivery_time;\n    uint8_t * packet_data;\n    int packet_bytes;\n};\n\nstruct netcode_network_simulator_t\n{\n    void * allocator_context;\n    void * (*allocate_function)(void*,size_t);\n    void (*free_function)(void*,void*);\n    float latency_milliseconds;\n    float jitter_milliseconds;\n    float packet_loss_percent;\n    float duplicate_packet_percent;\n    double time;\n    int current_index;\n    int num_pending_receive_packets;\n    struct netcode_network_simulator_packet_entry_t packet_entries[NETCODE_NETWORK_SIMULATOR_NUM_PACKET_ENTRIES];\n    struct netcode_network_simulator_packet_entry_t pending_receive_packets[NETCODE_NETWORK_SIMULATOR_NUM_PENDING_RECEIVE_PACKETS];\n};\n\nstruct netcode_network_simulator_t * netcode_network_simulator_create( void * allocator_context, \n                                                                       void * (*allocate_function)(void*,size_t), \n                                                                       void (*free_function)(void*,void*) )\n{\n    if ( allocate_function == NULL )\n    {\n        allocate_function = netcode_default_allocate_function;\n    }\n\n    if ( free_function == NULL )\n    {\n        free_function = netcode_default_free_function;\n    }\n\n    struct netcode_network_simulator_t * network_simulator = (struct netcode_network_simulator_t*) \n        allocate_function( allocator_context, sizeof( struct netcode_network_simulator_t ) );\n\n    netcode_assert( network_simulator );\n\n    memset( network_simulator, 0, sizeof( struct netcode_network_simulator_t ) );\n\n    network_simulator->allocator_context = allocator_context;\n    network_simulator->allocate_function = allocate_function;\n    network_simulator->free_function = free_function;\n\n    return network_simulator;\n}\n\nvoid netcode_network_simulator_reset( struct netcode_network_simulator_t * network_simulator )\n{\n    netcode_assert( network_simulator );\n\n    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"network simulator reset\\n\" );\n\n    int i;\n    for ( i = 0; i < NETCODE_NETWORK_SIMULATOR_NUM_PACKET_ENTRIES; i++ )\n    {\n        network_simulator->free_function( network_simulator->allocator_context, network_simulator->packet_entries[i].packet_data );\n        memset( &network_simulator->packet_entries[i], 0, sizeof( struct netcode_network_simulator_packet_entry_t ) );\n    }\n\n    for ( i = 0; i < network_simulator->num_pending_receive_packets; i++ )\n    {\n        network_simulator->free_function( network_simulator->allocator_context, network_simulator->pending_receive_packets[i].packet_data );\n        memset( &network_simulator->pending_receive_packets[i], 0, sizeof( struct netcode_network_simulator_packet_entry_t ) );\n    }\n\n    network_simulator->current_index = 0;\n    network_simulator->num_pending_receive_packets = 0;\n}\n\nvoid netcode_network_simulator_destroy( struct netcode_network_simulator_t * network_simulator )\n{\n    netcode_assert( network_simulator );\n    netcode_network_simulator_reset( network_simulator );\n    network_simulator->free_function( network_simulator->allocator_context, network_simulator );\n}\n\nfloat netcode_random_float( float a, float b )\n{\n    netcode_assert( a < b );\n    float random = ( (float) rand() ) / (float) RAND_MAX;\n    float diff = b - a;\n    float r = random * diff;\n    return a + r;\n}\n\nvoid netcode_network_simulator_queue_packet( struct netcode_network_simulator_t * network_simulator, \n                                             struct netcode_address_t * from, \n                                             struct netcode_address_t * to, \n                                             uint8_t * packet_data, \n                                             int packet_bytes, \n                                             float delay )\n{\n    network_simulator->packet_entries[network_simulator->current_index].from = *from;\n    network_simulator->packet_entries[network_simulator->current_index].to = *to;\n    network_simulator->packet_entries[network_simulator->current_index].packet_data = \n        (uint8_t*) network_simulator->allocate_function( network_simulator->allocator_context, packet_bytes );\n    memcpy( network_simulator->packet_entries[network_simulator->current_index].packet_data, packet_data, packet_bytes );\n    network_simulator->packet_entries[network_simulator->current_index].packet_bytes = packet_bytes;\n    network_simulator->packet_entries[network_simulator->current_index].delivery_time = network_simulator->time + delay;\n    network_simulator->current_index++;\n    network_simulator->current_index %= NETCODE_NETWORK_SIMULATOR_NUM_PACKET_ENTRIES;\n}\n\nvoid netcode_network_simulator_send_packet( struct netcode_network_simulator_t * network_simulator, \n                                            struct netcode_address_t * from, \n                                            struct netcode_address_t * to, \n                                            uint8_t * packet_data, \n                                            int packet_bytes )\n{\n    netcode_assert( network_simulator );\n    netcode_assert( from );\n    netcode_assert( from->type != 0 );\n    netcode_assert( to );\n    netcode_assert( to->type != 0 );\n    netcode_assert( packet_data );\n    netcode_assert( packet_bytes > 0 );\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_BYTES );\n\n    if ( netcode_random_float( 0.0f, 100.0f ) <= network_simulator->packet_loss_percent )\n        return;\n\n    if ( network_simulator->packet_entries[network_simulator->current_index].packet_data )\n    {\n        network_simulator->free_function( network_simulator->allocator_context, network_simulator->packet_entries[network_simulator->current_index].packet_data );\n        network_simulator->packet_entries[network_simulator->current_index].packet_data = NULL;\n    }\n\n    float delay = network_simulator->latency_milliseconds / 1000.0f;\n\n    if ( network_simulator->jitter_milliseconds > 0.0 )\n        delay += netcode_random_float( -network_simulator->jitter_milliseconds, +network_simulator->jitter_milliseconds ) / 1000.0f;\n\n    netcode_network_simulator_queue_packet( network_simulator, from, to, packet_data, packet_bytes, delay );\n\n    if ( netcode_random_float( 0.0f, 100.0f ) <= network_simulator->duplicate_packet_percent )\n    {\n        netcode_network_simulator_queue_packet( network_simulator, from, to, packet_data, packet_bytes, delay + netcode_random_float( 0, 1.0 ) );\n    }\n}\n\nint netcode_network_simulator_receive_packets( struct netcode_network_simulator_t * network_simulator, \n                                               struct netcode_address_t * to, \n                                               int max_packets, \n                                               uint8_t ** packet_data, \n                                               int * packet_bytes, \n                                               struct netcode_address_t * from )\n{\n    netcode_assert( network_simulator );\n    netcode_assert( max_packets >= 0 );\n    netcode_assert( packet_data );\n    netcode_assert( packet_bytes );\n    netcode_assert( from );\n    netcode_assert( to );\n\n    int num_packets = 0;\n\n    int i;\n    for ( i = 0; i < network_simulator->num_pending_receive_packets; i++ )\n    {\n        if ( num_packets == max_packets )\n            break;\n\n        if ( !network_simulator->pending_receive_packets[i].packet_data )\n            continue;\n\n        if ( !netcode_address_equal( &network_simulator->pending_receive_packets[i].to, to ) )\n            continue;\n\n        packet_data[num_packets] = network_simulator->pending_receive_packets[i].packet_data;\n        packet_bytes[num_packets] = network_simulator->pending_receive_packets[i].packet_bytes;\n        from[num_packets] = network_simulator->pending_receive_packets[i].from;\n\n        network_simulator->pending_receive_packets[i].packet_data = NULL;\n\n        num_packets++;\n    }\n\n    netcode_assert( num_packets <= max_packets );\n\n    return num_packets;\n}\n\nvoid netcode_network_simulator_update( struct netcode_network_simulator_t * network_simulator, double time )\n{   \n    netcode_assert( network_simulator );\n\n    network_simulator->time = time;\n\n    // discard any pending receive packets that are still in the buffer\n\n    int i;\n    for ( i = 0; i < network_simulator->num_pending_receive_packets; i++ )\n    {\n        if ( network_simulator->pending_receive_packets[i].packet_data )\n        {\n            network_simulator->free_function( network_simulator->allocator_context, network_simulator->pending_receive_packets[i].packet_data );\n            network_simulator->pending_receive_packets[i].packet_data = NULL;\n        }\n    }\n\n    network_simulator->num_pending_receive_packets = 0;\n\n    // walk across packet entries and move any that are ready to be received into the pending receive buffer\n\n    for ( i = 0; i < NETCODE_NETWORK_SIMULATOR_NUM_PACKET_ENTRIES; i++ )\n    {\n        if ( !network_simulator->packet_entries[i].packet_data )\n            continue;\n\n        if ( network_simulator->num_pending_receive_packets == NETCODE_NETWORK_SIMULATOR_NUM_PENDING_RECEIVE_PACKETS )\n            break;\n\n        if ( network_simulator->packet_entries[i].packet_data && network_simulator->packet_entries[i].delivery_time <= time )\n        {\n            network_simulator->pending_receive_packets[network_simulator->num_pending_receive_packets] = network_simulator->packet_entries[i];\n            network_simulator->num_pending_receive_packets++;\n            network_simulator->packet_entries[i].packet_data = NULL;\n        }\n    }\n}\n\n// ----------------------------------------------------------------\n    \nNETCODE_CONST char * netcode_client_state_name( int client_state )\n{\n    switch ( client_state )\n    {\n        case NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED:                return \"connect token expired\";\n        case NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN:                return \"invalid connect token\";\n        case NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT:                 return \"connection timed out\";\n        case NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT:         return \"connection request timed out\";\n        case NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT:        return \"connection response timed out\";\n        case NETCODE_CLIENT_STATE_CONNECTION_DENIED:                    return \"connection denied\";\n        case NETCODE_CLIENT_STATE_DISCONNECTED:                         return \"disconnected\";\n        case NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST:           return \"sending connection request\";\n        case NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE:          return \"sending connection response\";\n        case NETCODE_CLIENT_STATE_CONNECTED:                            return \"connected\";\n        default:\n            netcode_assert( 0 );\n            return \"???\";\n    }\n}\n\nvoid netcode_default_client_config( struct netcode_client_config_t * config )\n{\n    netcode_assert( config );\n    config->allocator_context = NULL;\n    config->allocate_function = netcode_default_allocate_function;\n    config->free_function = netcode_default_free_function;\n    config->network_simulator = NULL;\n    config->callback_context = NULL;\n    config->state_change_callback = NULL;\n    config->send_loopback_packet_callback = NULL;\n    config->override_send_and_receive = 0;\n    config->send_packet_override = NULL;\n    config->receive_packet_override = NULL;\n}\n\nstruct netcode_client_t\n{\n    struct netcode_client_config_t config;\n    int state;\n    double time;\n    double connect_start_time;\n    double last_packet_send_time;\n    double last_packet_receive_time;\n    int should_disconnect;\n    int should_disconnect_state;\n    uint64_t sequence;\n    int client_index;\n    int max_clients;\n    int server_address_index;\n    struct netcode_address_t address;\n    struct netcode_address_t server_address;\n    struct netcode_connect_token_t connect_token;\n    struct netcode_socket_holder_t socket_holder;\n    struct netcode_context_t context;\n    struct netcode_replay_protection_t replay_protection;\n    struct netcode_packet_queue_t packet_receive_queue;\n    uint64_t challenge_token_sequence;\n    uint8_t challenge_token_data[NETCODE_CHALLENGE_TOKEN_BYTES];\n    uint8_t * receive_packet_data[NETCODE_CLIENT_MAX_RECEIVE_PACKETS];\n    int receive_packet_bytes[NETCODE_CLIENT_MAX_RECEIVE_PACKETS];\n    struct netcode_address_t receive_from[NETCODE_CLIENT_MAX_RECEIVE_PACKETS];\n    int loopback;\n};\n\nint netcode_client_socket_create( struct netcode_socket_t * socket,\n                                  struct netcode_address_t * address,\n                                  int send_buffer_size,\n                                  int receive_buffer_size,\n                                  NETCODE_CONST struct netcode_client_config_t * config )\n{\n    netcode_assert( socket );\n    netcode_assert( address );\n    netcode_assert( config );\n\n    if ( !config->network_simulator )\n    {\n        if ( !config->override_send_and_receive )\n        {\n            if ( netcode_socket_create( socket, address, send_buffer_size, receive_buffer_size ) != NETCODE_SOCKET_ERROR_NONE )\n            {\n                return 0;\n            }\n        }\n    }\n    else\n    {\n        if ( address->port == 0 )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: must bind to a specific port when using network simulator\\n\" );\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nstruct netcode_client_t * netcode_client_create_overload( NETCODE_CONST char * address1_string,\n                                                          NETCODE_CONST char * address2_string,\n                                                          NETCODE_CONST struct netcode_client_config_t * config,\n                                                          double time )\n{\n    netcode_assert( config );\n    netcode_assert( netcode.initialized );\n\n    struct netcode_address_t address1;\n    struct netcode_address_t address2;\n\n    memset( &address1, 0, sizeof( address1 ) );\n    memset( &address2, 0, sizeof( address2 ) );\n\n    if ( netcode_parse_address( address1_string, &address1 ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to parse client address\\n\" );\n        return NULL;\n    }\n\n    if ( address2_string != NULL && netcode_parse_address( address2_string, &address2 ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to parse client address2\\n\" );\n        return NULL;\n    }\n\n\n    struct netcode_socket_t socket_ipv4;\n    struct netcode_socket_t socket_ipv6;\n\n    memset( &socket_ipv4, 0, sizeof( socket_ipv4 ) );\n    memset( &socket_ipv6, 0, sizeof( socket_ipv6 ) );\n\n    if ( address1.type == NETCODE_ADDRESS_IPV4 || address2.type == NETCODE_ADDRESS_IPV4 )\n    {\n        if ( !netcode_client_socket_create( &socket_ipv4, address1.type == NETCODE_ADDRESS_IPV4 ? &address1 : &address2, NETCODE_CLIENT_SOCKET_SNDBUF_SIZE, NETCODE_CLIENT_SOCKET_RCVBUF_SIZE, config ) )\n        {\n            return NULL;\n        }\n    }\n\n    if ( address1.type == NETCODE_ADDRESS_IPV6 || address2.type == NETCODE_ADDRESS_IPV6 )\n    {\n        if ( !netcode_client_socket_create( &socket_ipv6, address1.type == NETCODE_ADDRESS_IPV6 ? &address1 : &address2, NETCODE_CLIENT_SOCKET_SNDBUF_SIZE, NETCODE_CLIENT_SOCKET_RCVBUF_SIZE, config ) )\n        {\n            return NULL;\n        }\n    }\n\n    struct netcode_client_t * client = (struct netcode_client_t*) config->allocate_function( config->allocator_context, sizeof( struct netcode_client_t ) );\n\n    if ( !client )\n    {\n        netcode_socket_destroy( &socket_ipv4 );\n        netcode_socket_destroy( &socket_ipv6 );\n        return NULL;\n    }\n\n    struct netcode_address_t socket_address = address1.type == NETCODE_ADDRESS_IPV4 ? socket_ipv4.address : socket_ipv6.address;\n\n    if ( !config->network_simulator )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client started on port %d\\n\", socket_address.port );\n    }\n    else\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client started on port %d (network simulator)\\n\", socket_address.port );\n    }\n\n    client->config = *config;\n    client->socket_holder.ipv4 = socket_ipv4;\n    client->socket_holder.ipv6 = socket_ipv6;\n    client->address = config->network_simulator ? address1 : socket_address;\n    client->state = NETCODE_CLIENT_STATE_DISCONNECTED;\n    client->time = time;\n    client->connect_start_time = 0.0;\n    client->last_packet_send_time = -1000.0;\n    client->last_packet_receive_time = -1000.0;\n    client->should_disconnect = 0;\n    client->should_disconnect_state = NETCODE_CLIENT_STATE_DISCONNECTED;\n    client->sequence = 0;\n    client->client_index = 0;\n    client->max_clients = 0;\n    client->server_address_index = 0;\n    client->challenge_token_sequence = 0;\n    client->loopback = 0;\n    memset( &client->server_address, 0, sizeof( struct netcode_address_t ) );\n    memset( &client->connect_token, 0, sizeof( struct netcode_connect_token_t ) );\n    memset( &client->context, 0, sizeof( struct netcode_context_t ) );\n    memset( client->challenge_token_data, 0, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    netcode_packet_queue_init( &client->packet_receive_queue, config->allocator_context, config->allocate_function, config->free_function );\n\n    netcode_replay_protection_reset( &client->replay_protection );\n\n    return client;\n}\n\nstruct netcode_client_t * netcode_client_create( NETCODE_CONST char * address,\n                                                 NETCODE_CONST struct netcode_client_config_t * config,\n                                                 double time )\n{\n    return netcode_client_create_overload( address, NULL, config, time );\n}\n\nvoid netcode_client_destroy( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    if ( !client->loopback )\n        netcode_client_disconnect( client );\n    else\n        netcode_client_disconnect_loopback( client );\n    netcode_socket_destroy( &client->socket_holder.ipv4 );\n    netcode_socket_destroy( &client->socket_holder.ipv6 );\n    netcode_packet_queue_clear( &client->packet_receive_queue );\n    client->config.free_function( client->config.allocator_context, client );\n}\n\nvoid netcode_client_set_state( struct netcode_client_t * client, int client_state )\n{\n    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client changed state from '%s' to '%s'\\n\", \n        netcode_client_state_name( client->state ), netcode_client_state_name( client_state ) );\n\n    if ( client->config.state_change_callback )\n    {\n        client->config.state_change_callback( client->config.callback_context, client->state, client_state );\n    }\n\n    client->state = client_state;\n}\n\nvoid netcode_client_reset_before_next_connect( struct netcode_client_t * client )\n{\n    client->connect_start_time = client->time;\n    client->last_packet_send_time = client->time - 1.0f;\n    client->last_packet_receive_time = client->time;\n    client->should_disconnect = 0;\n    client->should_disconnect_state = NETCODE_CLIENT_STATE_DISCONNECTED;\n    client->challenge_token_sequence = 0;\n\n    memset( client->challenge_token_data, 0, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    netcode_replay_protection_reset( &client->replay_protection );\n}\n\nvoid netcode_client_reset_connection_data( struct netcode_client_t * client, int client_state )\n{\n    netcode_assert( client );\n\n    client->sequence = 0;\n    client->loopback = 0;\n    client->client_index = 0;\n    client->max_clients = 0;\n    client->connect_start_time = 0.0;\n    client->server_address_index = 0;\n    memset( &client->server_address, 0, sizeof( struct netcode_address_t ) );\n    memset( &client->connect_token, 0, sizeof( struct netcode_connect_token_t ) );\n    memset( &client->context, 0, sizeof( struct netcode_context_t ) );\n\n    netcode_client_set_state( client, client_state );\n\n    netcode_client_reset_before_next_connect( client );\n\n    while ( 1 )\n    {\n        void * packet = netcode_packet_queue_pop( &client->packet_receive_queue, NULL );\n        if ( !packet )\n            break;\n        client->config.free_function( client->config.allocator_context, packet );\n    }\n\n    netcode_packet_queue_clear( &client->packet_receive_queue );\n}\n\nvoid netcode_client_disconnect_internal( struct netcode_client_t * client, int destination_state, int send_disconnect_packets );\n\nvoid netcode_client_connect( struct netcode_client_t * client, uint8_t * connect_token )\n{\n    netcode_assert( client );\n    netcode_assert( connect_token );\n\n    netcode_client_disconnect( client );\n\n    if ( netcode_read_connect_token( connect_token, NETCODE_CONNECT_TOKEN_BYTES, &client->connect_token ) != NETCODE_OK )\n    {\n        netcode_client_set_state( client, NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN );\n        return;\n    }\n\n    client->server_address_index = 0;\n    client->server_address = client->connect_token.server_addresses[0];\n\n    char server_address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n\n    if ( client->connect_token.num_server_addresses == 1 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connecting to server %s\\n\", \n            netcode_address_to_string( &client->server_address, server_address_string ) );\n    }\n    else\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connecting to server %s [%d/%d]\\n\", \n            netcode_address_to_string( &client->server_address, server_address_string ), client->server_address_index + 1, client->connect_token.num_server_addresses );\n    }\n\n    memcpy( client->context.read_packet_key, client->connect_token.server_to_client_key, NETCODE_KEY_BYTES );\n    memcpy( client->context.write_packet_key, client->connect_token.client_to_server_key, NETCODE_KEY_BYTES );\n\n    netcode_client_reset_before_next_connect( client );\n\n    netcode_client_set_state( client, NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST );\n}\n\nvoid netcode_client_process_packet_internal( struct netcode_client_t * client, struct netcode_address_t * from, uint8_t * packet, uint64_t sequence )\n{\n    netcode_assert( client );\n    netcode_assert( packet );\n\n    uint8_t packet_type = ( (uint8_t*) packet ) [0];\n\n    switch ( packet_type )\n    {\n        case NETCODE_CONNECTION_DENIED_PACKET:\n        {\n            if ( ( client->state == NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST || \n                   client->state == NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE ) \n                                                && \n                      netcode_address_equal( from, &client->server_address ) )\n            {\n                client->should_disconnect = 1;\n                client->should_disconnect_state = NETCODE_CLIENT_STATE_CONNECTION_DENIED;\n                client->last_packet_receive_time = client->time;\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_CHALLENGE_PACKET:\n        {\n            if ( client->state == NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST && netcode_address_equal( from, &client->server_address ) )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client received connection challenge packet from server\\n\" );\n\n                struct netcode_connection_challenge_packet_t * p = (struct netcode_connection_challenge_packet_t*) packet;\n                client->challenge_token_sequence = p->challenge_token_sequence;\n                memcpy( client->challenge_token_data, p->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n                client->last_packet_receive_time = client->time;\n\n                netcode_client_set_state( client, NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE );\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_KEEP_ALIVE_PACKET:\n        {\n            if ( netcode_address_equal( from, &client->server_address ) )\n            {\n                struct netcode_connection_keep_alive_packet_t * p = (struct netcode_connection_keep_alive_packet_t*) packet;\n\n                if ( client->state == NETCODE_CLIENT_STATE_CONNECTED )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client received connection keep alive packet from server\\n\" );\n\n                    client->last_packet_receive_time = client->time;\n                }\n                else if ( client->state == NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client received connection keep alive packet from server\\n\" );\n\n                    client->last_packet_receive_time = client->time;\n                    client->client_index = p->client_index;\n                    client->max_clients = p->max_clients;\n\n                    netcode_client_set_state( client, NETCODE_CLIENT_STATE_CONNECTED );\n\n                    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connected to server\\n\" );\n                }\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_PAYLOAD_PACKET:\n        {\n            if ( client->state == NETCODE_CLIENT_STATE_CONNECTED && netcode_address_equal( from, &client->server_address ) )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client received connection payload packet from server\\n\" );\n\n                netcode_packet_queue_push( &client->packet_receive_queue, packet, sequence );\n\n                client->last_packet_receive_time = client->time;\n\n                return;\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_DISCONNECT_PACKET:\n        {\n            if ( client->state == NETCODE_CLIENT_STATE_CONNECTED && netcode_address_equal( from, &client->server_address ) )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client received disconnect packet from server\\n\" );\n\n                client->should_disconnect = 1;\n                client->should_disconnect_state = NETCODE_CLIENT_STATE_DISCONNECTED;\n                client->last_packet_receive_time = client->time;\n            }\n        }\n        break;\n\n        default:\n            break;\n    }\n\n    client->config.free_function( client->config.allocator_context, packet );    \n}\n\nvoid netcode_client_process_packet( struct netcode_client_t * client, struct netcode_address_t * from, uint8_t * packet_data, int packet_bytes )\n{\n    (void) client;\n    (void) from;\n    (void) packet_data;\n    (void) packet_bytes;\n\n    uint8_t allowed_packets[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packets, 0, sizeof( allowed_packets ) );\n    allowed_packets[NETCODE_CONNECTION_DENIED_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_CHALLENGE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_KEEP_ALIVE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_PAYLOAD_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_DISCONNECT_PACKET] = 1;\n\n    uint64_t current_timestamp = (uint64_t) time( NULL );\n\n    uint64_t sequence;\n\n    void * packet = netcode_read_packet( packet_data, \n                                         packet_bytes, \n                                         &sequence, \n                                         client->context.read_packet_key, \n                                         client->connect_token.protocol_id, \n                                         current_timestamp, \n                                         NULL, \n                                         allowed_packets, \n                                         &client->replay_protection, \n                                         client->config.allocator_context, \n                                         client->config.allocate_function );\n\n    if ( !packet )\n        return;\n    \n    netcode_client_process_packet_internal( client, from, (uint8_t*)packet, sequence );\n}\n\nvoid netcode_client_receive_packets( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    netcode_assert( !client->loopback );\n\n    uint8_t allowed_packets[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packets, 0, sizeof( allowed_packets ) );\n    allowed_packets[NETCODE_CONNECTION_DENIED_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_CHALLENGE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_KEEP_ALIVE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_PAYLOAD_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_DISCONNECT_PACKET] = 1;\n\n    uint64_t current_timestamp = (uint64_t) time( NULL );\n\n    if ( !client->config.network_simulator )\n    {\n        // process packets received from socket\n\n        while ( 1 )\n        {\n            struct netcode_address_t from;\n            uint8_t packet_data[NETCODE_MAX_PACKET_BYTES];\n            int packet_bytes = 0;\n\n            if ( client->config.override_send_and_receive )\n            {\n                packet_bytes = client->config.receive_packet_override( client->config.callback_context, &from, packet_data, NETCODE_MAX_PACKET_BYTES );\n            }\n            else if ( client->server_address.type == NETCODE_ADDRESS_IPV4 )\n            {\n                packet_bytes = netcode_socket_receive_packet( &client->socket_holder.ipv4, &from, packet_data, NETCODE_MAX_PACKET_BYTES );\n            }\n            else if ( client->server_address.type == NETCODE_ADDRESS_IPV6 )\n            {\n                packet_bytes = netcode_socket_receive_packet( &client->socket_holder.ipv6, &from, packet_data, NETCODE_MAX_PACKET_BYTES );\n            }\n\n            if ( packet_bytes == 0 )\n                break;\n\n            uint64_t sequence;\n            void * packet = netcode_read_packet( packet_data, \n                                                 packet_bytes, \n                                                 &sequence, \n                                                 client->context.read_packet_key, \n                                                 client->connect_token.protocol_id, \n                                                 current_timestamp, \n                                                 NULL, \n                                                 allowed_packets, \n                                                 &client->replay_protection, \n                                                 client->config.allocator_context, \n                                                 client->config.allocate_function );\n\n            if ( !packet )\n                continue;\n\n            netcode_client_process_packet_internal( client, &from, (uint8_t*)packet, sequence );\n        }\n    }\n    else\n    {\n        // process packets received from network simulator\n\n        int num_packets_received = netcode_network_simulator_receive_packets( client->config.network_simulator, \n                                                                              &client->address, \n                                                                              NETCODE_CLIENT_MAX_RECEIVE_PACKETS, \n                                                                              client->receive_packet_data, \n                                                                              client->receive_packet_bytes, \n                                                                              client->receive_from );\n\n        int i;\n        for ( i = 0; i < num_packets_received; i++ )\n        {\n            uint64_t sequence;\n\n            void * packet = netcode_read_packet( client->receive_packet_data[i], \n                                                 client->receive_packet_bytes[i], \n                                                 &sequence, \n                                                 client->context.read_packet_key, \n                                                 client->connect_token.protocol_id, \n                                                 current_timestamp, \n                                                 NULL, \n                                                 allowed_packets, \n                                                 &client->replay_protection, \n                                                 client->config.allocator_context, \n                                                 client->config.allocate_function );\n\n            client->config.free_function( client->config.allocator_context, client->receive_packet_data[i] );\n\n            if ( !packet )\n                continue;\n\n            netcode_client_process_packet_internal( client, &client->receive_from[i], (uint8_t*)packet, sequence );\n        }\n    }\n}\n\nvoid netcode_client_send_packet_to_server_internal( struct netcode_client_t * client, void * packet )\n{\n    netcode_assert( client );\n    netcode_assert( !client->loopback );\n    \n    uint8_t packet_data[NETCODE_MAX_PACKET_BYTES];\n\n    int packet_bytes = netcode_write_packet( packet, \n                                             packet_data, \n                                             NETCODE_MAX_PACKET_BYTES, \n                                             client->sequence++, \n                                             client->context.write_packet_key, \n                                             client->connect_token.protocol_id );\n\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_BYTES );\n\n    if ( client->config.network_simulator )\n    {\n        netcode_network_simulator_send_packet( client->config.network_simulator, &client->address, &client->server_address, packet_data, packet_bytes );\n    }\n    else\n    {\n        if ( client->config.override_send_and_receive )\n        {\n            client->config.send_packet_override( client->config.callback_context, &client->server_address, packet_data, packet_bytes );\n        }\n        else if ( client->server_address.type == NETCODE_ADDRESS_IPV4 )\n        {\n            netcode_socket_send_packet( &client->socket_holder.ipv4, &client->server_address, packet_data, packet_bytes );\n        }\n        else if ( client->server_address.type == NETCODE_ADDRESS_IPV6 )\n        {\n            netcode_socket_send_packet( &client->socket_holder.ipv6, &client->server_address, packet_data, packet_bytes );\n        }\n    }\n\n    client->last_packet_send_time = client->time;\n}\n\nvoid netcode_client_send_packets( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    netcode_assert( !client->loopback );\n\n    switch ( client->state )\n    {\n        case NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST:\n        {\n            if ( client->last_packet_send_time + ( 1.0 / NETCODE_PACKET_SEND_RATE ) >= client->time )\n                return;\n\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client sent connection request packet to server\\n\" );\n\n            struct netcode_connection_request_packet_t packet;\n            packet.packet_type = NETCODE_CONNECTION_REQUEST_PACKET;\n            memcpy( packet.version_info, NETCODE_VERSION_INFO, NETCODE_VERSION_INFO_BYTES );\n            packet.protocol_id = client->connect_token.protocol_id;\n            packet.connect_token_expire_timestamp = client->connect_token.expire_timestamp;\n            memcpy( packet.connect_token_nonce, client->connect_token.nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n            memcpy( packet.connect_token_data, client->connect_token.private_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n            netcode_client_send_packet_to_server_internal( client, &packet );\n        }\n        break;\n\n        case NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE:\n        {\n            if ( client->last_packet_send_time + ( 1.0 / NETCODE_PACKET_SEND_RATE ) >= client->time )\n                return;\n\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client sent connection response packet to server\\n\" );\n\n            struct netcode_connection_response_packet_t packet;\n            packet.packet_type = NETCODE_CONNECTION_RESPONSE_PACKET;\n            packet.challenge_token_sequence = client->challenge_token_sequence;\n            memcpy( packet.challenge_token_data, client->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n            netcode_client_send_packet_to_server_internal( client, &packet );\n        }\n        break;\n\n        case NETCODE_CLIENT_STATE_CONNECTED:\n        {\n            if ( client->last_packet_send_time + ( 1.0 / NETCODE_PACKET_SEND_RATE ) >= client->time )\n                return;\n\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client sent connection keep alive packet to server\\n\" );\n\n            struct netcode_connection_keep_alive_packet_t packet;\n            packet.packet_type = NETCODE_CONNECTION_KEEP_ALIVE_PACKET;\n            packet.client_index = 0;\n            packet.max_clients = 0;\n\n            netcode_client_send_packet_to_server_internal( client, &packet );\n        }\n        break;\n        \n        default:\n            break;\n    }\n}\n\nint netcode_client_connect_to_next_server( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n\n    if ( client->server_address_index + 1 >= client->connect_token.num_server_addresses )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client has no more servers to connect to\\n\" );\n        return 0;\n    }\n\n    client->server_address_index++;\n    client->server_address = client->connect_token.server_addresses[client->server_address_index];\n\n    netcode_client_reset_before_next_connect( client );\n\n    char server_address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connecting to next server %s [%d/%d]\\n\", \n        netcode_address_to_string( &client->server_address, server_address_string ), \n        client->server_address_index + 1, \n        client->connect_token.num_server_addresses );\n\n    netcode_client_set_state( client, NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST );\n\n    return 1;\n}\n\nvoid netcode_client_update( struct netcode_client_t * client, double time )\n{\n    netcode_assert( client );\n\n    client->time = time;\n\n    if ( client->loopback )\n        return;\n\n    netcode_client_receive_packets( client );\n\n    netcode_client_send_packets( client );\n\n    if ( client->state > NETCODE_CLIENT_STATE_DISCONNECTED && client->state < NETCODE_CLIENT_STATE_CONNECTED )\n    {\n        uint64_t connect_token_expire_seconds = ( client->connect_token.expire_timestamp - client->connect_token.create_timestamp );            \n        if ( client->time - client->connect_start_time >= connect_token_expire_seconds )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connect failed. connect token expired\\n\" );\n            netcode_client_disconnect_internal( client, NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED, 0 );\n            return;\n        }\n    }\n\n    if ( client->should_disconnect )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client should disconnect -> %s\\n\", netcode_client_state_name( client->should_disconnect_state ) );\n        if ( netcode_client_connect_to_next_server( client ) )\n            return;\n        netcode_client_disconnect_internal( client, client->should_disconnect_state, 0 );\n        return;\n    }\n\n    switch ( client->state )\n    {\n        case NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST:\n        {\n            if ( client->connect_token.timeout_seconds > 0 && client->last_packet_receive_time + client->connect_token.timeout_seconds < time )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connect failed. connection request timed out\\n\" );\n                if ( netcode_client_connect_to_next_server( client ) )\n                    return;\n                netcode_client_disconnect_internal( client, NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT, 0 );\n                return;\n            }\n        }\n        break;\n\n        case NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE:\n        {\n            if ( client->connect_token.timeout_seconds > 0 && client->last_packet_receive_time + client->connect_token.timeout_seconds < time )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connect failed. connection response timed out\\n\" );\n                if ( netcode_client_connect_to_next_server( client ) )\n                    return;\n                netcode_client_disconnect_internal( client, NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT, 0 );\n                return;\n            }\n        }\n        break;\n\n        case NETCODE_CLIENT_STATE_CONNECTED:\n        {\n            if ( client->connect_token.timeout_seconds > 0 && client->last_packet_receive_time + client->connect_token.timeout_seconds < time )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connection timed out\\n\" );\n                netcode_client_disconnect_internal( client, NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT, 0 );\n                return;\n            }\n        }\n        break;\n\n        default:\n            break;\n    }\n}\n\nuint64_t netcode_client_next_packet_sequence( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    return client->sequence;  \n}\n\nvoid netcode_client_send_packet( struct netcode_client_t * client, NETCODE_CONST uint8_t * packet_data, int packet_bytes )\n{\n    netcode_assert( client );\n    netcode_assert( packet_data );\n    netcode_assert( packet_bytes >= 0 );\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_SIZE );\n\n    if ( client->state != NETCODE_CLIENT_STATE_CONNECTED )\n        return;\n\n    if ( !client->loopback )\n    {\n        uint8_t buffer[NETCODE_MAX_PAYLOAD_BYTES*2];\n\n        struct netcode_connection_payload_packet_t * packet = (struct netcode_connection_payload_packet_t*) buffer;\n\n        packet->packet_type = NETCODE_CONNECTION_PAYLOAD_PACKET;\n        packet->payload_bytes = packet_bytes;\n        memcpy( packet->payload_data, packet_data, packet_bytes );\n\n        netcode_client_send_packet_to_server_internal( client, packet );\n    }\n    else\n    {\n        client->config.send_loopback_packet_callback( client->config.callback_context, \n                                                      client->client_index, \n                                                      packet_data,\n                                                      packet_bytes,\n                                                      client->sequence++ );\n    }\n}\n\nuint8_t * netcode_client_receive_packet( struct netcode_client_t * client, int * packet_bytes, uint64_t * packet_sequence )\n{\n    netcode_assert( client );\n    netcode_assert( packet_bytes );\n\n    struct netcode_connection_payload_packet_t * packet = (struct netcode_connection_payload_packet_t*) \n        netcode_packet_queue_pop( &client->packet_receive_queue, packet_sequence );\n    \n    if ( packet )\n    {\n        netcode_assert( packet->packet_type == NETCODE_CONNECTION_PAYLOAD_PACKET );\n        *packet_bytes = packet->payload_bytes;\n        netcode_assert( *packet_bytes >= 0 );\n        netcode_assert( *packet_bytes <= NETCODE_MAX_PAYLOAD_BYTES );\n        return (uint8_t*) &packet->payload_data;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nvoid netcode_client_free_packet( struct netcode_client_t * client, void * packet )\n{\n    netcode_assert( client );\n    netcode_assert( packet );\n    uint8_t * packet_data = (uint8_t*) packet;\n    int offset = offsetof( struct netcode_connection_payload_packet_t, payload_data );\n    client->config.free_function( client->config.allocator_context, packet_data - offset );\n}\n\nvoid netcode_client_disconnect( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    netcode_assert( !client->loopback );\n    netcode_client_disconnect_internal( client, NETCODE_CLIENT_STATE_DISCONNECTED, 1 );\n}\n\nvoid netcode_client_disconnect_internal( struct netcode_client_t * client, int destination_state, int send_disconnect_packets )\n{\n    netcode_assert( !client->loopback );\n    netcode_assert( destination_state <= NETCODE_CLIENT_STATE_DISCONNECTED );\n\n    if ( client->state <= NETCODE_CLIENT_STATE_DISCONNECTED || client->state == destination_state )\n        return;\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client disconnected\\n\" );\n\n    if ( !client->loopback && send_disconnect_packets && client->state > NETCODE_CLIENT_STATE_DISCONNECTED )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client sent disconnect packets to server\\n\" );\n\n        int i;\n        for ( i = 0; i < NETCODE_NUM_DISCONNECT_PACKETS; i++ )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client sent disconnect packet %d\\n\", i );\n\n            struct netcode_connection_disconnect_packet_t packet;\n            packet.packet_type = NETCODE_CONNECTION_DISCONNECT_PACKET;\n\n            netcode_client_send_packet_to_server_internal( client, &packet );\n        }\n    }\n\n    netcode_client_reset_connection_data( client, destination_state );\n}\n\nint netcode_client_state( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    return client->state;\n}\n\nint netcode_client_index( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    return client->client_index;\n}\n\nint netcode_client_max_clients( struct netcode_client_t * client )\n{   \n    netcode_assert( client );\n    return client->max_clients;\n}\n\nvoid netcode_client_connect_loopback( struct netcode_client_t * client, int client_index, int max_clients )\n{\n    netcode_assert( client );\n    netcode_assert( client->state <= NETCODE_CLIENT_STATE_DISCONNECTED );\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"client connected to server via loopback as client %d\\n\", client_index );\n    client->state = NETCODE_CLIENT_STATE_CONNECTED;\n    client->client_index = client_index;\n    client->max_clients = max_clients;\n    client->loopback = 1;\n}\n\nvoid netcode_client_disconnect_loopback( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    netcode_assert( client->loopback );\n    netcode_client_reset_connection_data( client, NETCODE_CLIENT_STATE_DISCONNECTED );\n}\n\nint netcode_client_loopback( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    return client->loopback;\n}\n\nvoid netcode_client_process_loopback_packet( struct netcode_client_t * client, NETCODE_CONST uint8_t * packet_data, int packet_bytes, uint64_t packet_sequence )\n{\n    netcode_assert( client );\n    netcode_assert( client->loopback );\n    struct netcode_connection_payload_packet_t * packet = netcode_create_payload_packet( packet_bytes, client->config.allocator_context, client->config.allocate_function );\n    if ( !packet )\n        return;\n    memcpy( packet->payload_data, packet_data, packet_bytes );\n    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"client processing loopback packet from server\\n\" );\n    netcode_packet_queue_push( &client->packet_receive_queue, packet, packet_sequence );\n}\n\nuint16_t netcode_client_get_port( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    return client->address.type == NETCODE_ADDRESS_IPV4 ? client->socket_holder.ipv4.address.port : client->socket_holder.ipv6.address.port;\n}\n\nstruct netcode_address_t * netcode_client_server_address( struct netcode_client_t * client )\n{\n    netcode_assert( client );\n    return &client->server_address;\n}\n\n// ----------------------------------------------------------------\n\n#define NETCODE_MAX_ENCRYPTION_MAPPINGS ( NETCODE_MAX_CLIENTS * 4 )\n\nstruct netcode_encryption_manager_t\n{\n    int num_encryption_mappings;\n    int timeout[NETCODE_MAX_ENCRYPTION_MAPPINGS];\n    double expire_time[NETCODE_MAX_ENCRYPTION_MAPPINGS];\n    double last_access_time[NETCODE_MAX_ENCRYPTION_MAPPINGS];\n    struct netcode_address_t address[NETCODE_MAX_ENCRYPTION_MAPPINGS];\n    int client_index[NETCODE_MAX_ENCRYPTION_MAPPINGS];\n    uint8_t send_key[NETCODE_KEY_BYTES*NETCODE_MAX_ENCRYPTION_MAPPINGS];\n    uint8_t receive_key[NETCODE_KEY_BYTES*NETCODE_MAX_ENCRYPTION_MAPPINGS];\n};\n\nvoid netcode_encryption_manager_reset( struct netcode_encryption_manager_t * encryption_manager )\n{\n    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"reset encryption manager\\n\" );\n\n    netcode_assert( encryption_manager );\n\n    encryption_manager->num_encryption_mappings = 0;\n    \n    int i;\n    for ( i = 0; i < NETCODE_MAX_ENCRYPTION_MAPPINGS; i++ )\n    {\n        encryption_manager->client_index[i] = -1;\n        encryption_manager->expire_time[i] = -1.0;\n        encryption_manager->last_access_time[i] = -1000.0;\n        memset( &encryption_manager->address[i], 0, sizeof( struct netcode_address_t ) );\n    }\n\n    memset( encryption_manager->timeout, 0, sizeof( encryption_manager->timeout ) );    \n    memset( encryption_manager->send_key, 0, sizeof( encryption_manager->send_key ) );\n    memset( encryption_manager->receive_key, 0, sizeof( encryption_manager->receive_key ) );\n}\n\nint netcode_encryption_manager_entry_expired( struct netcode_encryption_manager_t * encryption_manager, int index, double time )\n{\n    return ( encryption_manager->timeout[index] > 0 && ( encryption_manager->last_access_time[index] + encryption_manager->timeout[index] ) < time ) ||\n           ( encryption_manager->expire_time[index] >= 0.0 && encryption_manager->expire_time[index] < time );\n}\n\nint netcode_encryption_manager_add_encryption_mapping( struct netcode_encryption_manager_t * encryption_manager, \n                                                       struct netcode_address_t * address, \n                                                       uint8_t * send_key, \n                                                       uint8_t * receive_key, \n                                                       double time, \n                                                       double expire_time,\n                                                       int timeout )\n{\n    int i;\n    for ( i = 0; i < encryption_manager->num_encryption_mappings; i++ )\n    {\n        if ( netcode_address_equal( &encryption_manager->address[i], address ) && !netcode_encryption_manager_entry_expired( encryption_manager, i, time ) )\n        {\n            encryption_manager->timeout[i] = timeout;\n            encryption_manager->expire_time[i] = expire_time;\n            encryption_manager->last_access_time[i] = time;\n            memcpy( encryption_manager->send_key + i * NETCODE_KEY_BYTES, send_key, NETCODE_KEY_BYTES );\n            memcpy( encryption_manager->receive_key + i * NETCODE_KEY_BYTES, receive_key, NETCODE_KEY_BYTES );\n            return 1;\n        }\n    }\n\n    for ( i = 0; i < NETCODE_MAX_ENCRYPTION_MAPPINGS; i++ )\n    {\n        if ( encryption_manager->address[i].type == NETCODE_ADDRESS_NONE || \n            ( netcode_encryption_manager_entry_expired( encryption_manager, i, time ) && encryption_manager->client_index[i] == -1 ) )\n        {\n            encryption_manager->timeout[i] = timeout;\n            encryption_manager->address[i] = *address;\n            encryption_manager->expire_time[i] = expire_time;\n            encryption_manager->last_access_time[i] = time;\n            memcpy( encryption_manager->send_key + i * NETCODE_KEY_BYTES, send_key, NETCODE_KEY_BYTES );\n            memcpy( encryption_manager->receive_key + i * NETCODE_KEY_BYTES, receive_key, NETCODE_KEY_BYTES );\n            if ( i + 1 > encryption_manager->num_encryption_mappings )\n                encryption_manager->num_encryption_mappings = i + 1;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nint netcode_encryption_manager_remove_encryption_mapping( struct netcode_encryption_manager_t * encryption_manager, struct netcode_address_t * address, double time )\n{\n    netcode_assert( encryption_manager );\n    netcode_assert( address );\n\n    int i;\n    for ( i = 0; i < encryption_manager->num_encryption_mappings; i++ )\n    {\n        if ( netcode_address_equal( &encryption_manager->address[i], address ) )\n        {\n            encryption_manager->expire_time[i] = -1.0;\n            encryption_manager->last_access_time[i] = -1000.0;\n            memset( &encryption_manager->address[i], 0, sizeof( struct netcode_address_t ) );\n            memset( encryption_manager->send_key + i * NETCODE_KEY_BYTES, 0, NETCODE_KEY_BYTES );\n            memset( encryption_manager->receive_key + i * NETCODE_KEY_BYTES, 0, NETCODE_KEY_BYTES );\n\n            if ( i + 1 == encryption_manager->num_encryption_mappings )\n            {\n                int index = i - 1;\n                while ( index >= 0 )\n                {\n                    if ( !netcode_encryption_manager_entry_expired( encryption_manager, index, time ) || encryption_manager->client_index[index] != -1 )\n                    {\n                        break;\n                    }\n                    encryption_manager->address[index].type = NETCODE_ADDRESS_NONE;\n                    index--;\n                }\n                encryption_manager->num_encryption_mappings = index + 1;\n            }\n\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nint netcode_encryption_manager_find_encryption_mapping( struct netcode_encryption_manager_t * encryption_manager, struct netcode_address_t * address, double time )\n{\n    int i;\n    for ( i = 0; i < encryption_manager->num_encryption_mappings; i++ )\n    {\n        if ( netcode_address_equal( &encryption_manager->address[i], address ) && !netcode_encryption_manager_entry_expired( encryption_manager, i, time ) )\n        {\n            encryption_manager->last_access_time[i] = time;\n            return i;\n        }\n    }\n    return -1;\n}\n\nint netcode_encryption_manager_touch( struct netcode_encryption_manager_t * encryption_manager, int index, struct netcode_address_t * address, double time )\n{\n    netcode_assert( index >= 0 );\n    netcode_assert( index < encryption_manager->num_encryption_mappings );\n    if ( !netcode_address_equal( &encryption_manager->address[index], address ) )\n        return 0;\n    encryption_manager->last_access_time[index] = time;\n    return 1;\n}\n\nvoid netcode_encryption_manager_set_expire_time( struct netcode_encryption_manager_t * encryption_manager, int index, double expire_time )\n{\n    netcode_assert( index >= 0 );\n    netcode_assert( index < encryption_manager->num_encryption_mappings );\n    encryption_manager->expire_time[index] = expire_time;\n}\n\n\nuint8_t * netcode_encryption_manager_get_send_key( struct netcode_encryption_manager_t * encryption_manager, int index )\n{\n    netcode_assert( encryption_manager );\n    if ( index == -1 )\n        return NULL;\n    netcode_assert( index >= 0 );\n    netcode_assert( index < encryption_manager->num_encryption_mappings );\n    return encryption_manager->send_key + index * NETCODE_KEY_BYTES;\n}\n\nuint8_t * netcode_encryption_manager_get_receive_key( struct netcode_encryption_manager_t * encryption_manager, int index )\n{\n    netcode_assert( encryption_manager );\n    if ( index == -1 )\n        return NULL;\n    netcode_assert( index >= 0 );\n    netcode_assert( index < encryption_manager->num_encryption_mappings );\n    return encryption_manager->receive_key + index * NETCODE_KEY_BYTES;\n}\n\nint netcode_encryption_manager_get_timeout( struct netcode_encryption_manager_t * encryption_manager, int index )\n{\n    netcode_assert( encryption_manager );\n    if ( index == -1 )\n        return 0;\n    netcode_assert( index >= 0 );\n    netcode_assert( index < encryption_manager->num_encryption_mappings );\n    return encryption_manager->timeout[index];\n}\n\n// ----------------------------------------------------------------\n\n#define NETCODE_MAX_CONNECT_TOKEN_ENTRIES ( NETCODE_MAX_CLIENTS * 8 )\n\nstruct netcode_connect_token_entry_t\n{\n    double time;\n    uint8_t mac[NETCODE_MAC_BYTES];\n    struct netcode_address_t address;\n};\n\nvoid netcode_connect_token_entries_reset( struct netcode_connect_token_entry_t * connect_token_entries )\n{\n    int i;\n    for ( i = 0; i < NETCODE_MAX_CONNECT_TOKEN_ENTRIES; i++ )\n    {\n        connect_token_entries[i].time = -1000.0;\n        memset( connect_token_entries[i].mac, 0, NETCODE_MAC_BYTES );\n        memset( &connect_token_entries[i].address, 0, sizeof( struct netcode_address_t ) );\n    }\n}\n\nint netcode_connect_token_entries_find_or_add( struct netcode_connect_token_entry_t * connect_token_entries, \n                                               struct netcode_address_t * address, \n                                               uint8_t * mac, \n                                               double time )\n{\n    netcode_assert( connect_token_entries );\n    netcode_assert( address );\n    netcode_assert( mac );\n\n    // find the matching entry for the token mac and the oldest token entry. constant time worst case. This is intentional!\n\n    int matching_token_index = -1;\n    int oldest_token_index = -1;\n    double oldest_token_time = 0.0;\n\n    int i;\n    for ( i = 0; i < NETCODE_MAX_CONNECT_TOKEN_ENTRIES; i++ )\n    {\n        if ( memcmp( mac, connect_token_entries[i].mac, NETCODE_MAC_BYTES ) == 0 )\n            matching_token_index = i;\n        \n        if ( oldest_token_index == -1 || connect_token_entries[i].time < oldest_token_time )\n        {\n            oldest_token_time = connect_token_entries[i].time;\n            oldest_token_index = i;\n        }\n    }\n\n    // if no entry is found with the mac, this is a new connect token. replace the oldest token entry.\n\n    netcode_assert( oldest_token_index != -1 );\n\n    if ( matching_token_index == -1 )\n    {\n        connect_token_entries[oldest_token_index].time = time;\n        connect_token_entries[oldest_token_index].address = *address;\n        memcpy( connect_token_entries[oldest_token_index].mac, mac, NETCODE_MAC_BYTES );\n        return 1;\n    }\n\n    // allow connect tokens we have already seen from the same address\n\n    netcode_assert( matching_token_index >= 0 );\n    netcode_assert( matching_token_index < NETCODE_MAX_CONNECT_TOKEN_ENTRIES );\n    if ( netcode_address_equal( &connect_token_entries[matching_token_index].address, address ) )\n        return 1;\n\n    return 0;\n}\n\ntypedef uint64_t netcode_fnv_t;\n\nvoid netcode_fnv_init( netcode_fnv_t * fnv )\n{\n    *fnv = 0xCBF29CE484222325;\n}\n\nvoid netcode_fnv_write( netcode_fnv_t * fnv, NETCODE_CONST uint8_t * data, size_t size )\n{\n    for ( size_t i = 0; i < size; i++ )\n    {\n        (*fnv) ^= data[i];\n        (*fnv) *= 0x00000100000001B3;\n    }\n}\n\nuint64_t netcode_fnv_finalize( netcode_fnv_t * fnv )\n{\n    return *fnv;\n}\n\nuint64_t netcode_hash_string( NETCODE_CONST char * string )\n{\n    netcode_fnv_t fnv;\n    netcode_fnv_init( &fnv );\n    netcode_fnv_write( &fnv, (uint8_t *)( string ), strlen( string ) );\n    return netcode_fnv_finalize( &fnv );\n}\n\nuint64_t netcode_hash_data( NETCODE_CONST uint8_t * data, size_t size )\n{\n    netcode_fnv_t fnv;\n    netcode_fnv_init( &fnv );\n    netcode_fnv_write( &fnv, (uint8_t *)( data ), size );\n    return netcode_fnv_finalize( &fnv );\n}\n\n// ----------------------------------------------------------------\n\n#define NETCODE_SERVER_FLAG_IGNORE_CONNECTION_REQUEST_PACKETS       1\n#define NETCODE_SERVER_FLAG_IGNORE_CONNECTION_RESPONSE_PACKETS      (1<<1)\n\nvoid netcode_default_server_config( struct netcode_server_config_t * config )\n{\n    netcode_assert( config );\n    config->allocator_context = NULL;\n    config->allocate_function = netcode_default_allocate_function;\n    config->free_function = netcode_default_free_function;\n    config->network_simulator = NULL;\n    config->callback_context = NULL;\n    config->connect_disconnect_callback = NULL;\n    config->send_loopback_packet_callback = NULL;\n    config->override_send_and_receive = 0;\n    config->send_packet_override = NULL;\n    config->receive_packet_override = NULL;\n}\n\nstruct netcode_server_t\n{\n    struct netcode_server_config_t config;\n    struct netcode_socket_holder_t socket_holder;\n    struct netcode_address_t address;\n    uint32_t flags;\n    double time;\n    int running;\n    int max_clients;\n    int num_connected_clients;\n    uint64_t global_sequence;\n    uint64_t challenge_sequence;\n    uint8_t challenge_key[NETCODE_KEY_BYTES];\n    int client_connected[NETCODE_MAX_CLIENTS];\n    int client_timeout[NETCODE_MAX_CLIENTS];\n    int client_loopback[NETCODE_MAX_CLIENTS];\n    int client_confirmed[NETCODE_MAX_CLIENTS];\n    int client_encryption_index[NETCODE_MAX_CLIENTS];\n    uint64_t client_id[NETCODE_MAX_CLIENTS];\n    uint64_t client_sequence[NETCODE_MAX_CLIENTS];\n    double client_last_packet_send_time[NETCODE_MAX_CLIENTS];\n    double client_last_packet_receive_time[NETCODE_MAX_CLIENTS];\n    uint8_t client_user_data[NETCODE_MAX_CLIENTS][NETCODE_USER_DATA_BYTES];\n    struct netcode_replay_protection_t client_replay_protection[NETCODE_MAX_CLIENTS];\n    struct netcode_packet_queue_t client_packet_queue[NETCODE_MAX_CLIENTS];\n    struct netcode_address_t client_address[NETCODE_MAX_CLIENTS];\n    struct netcode_connect_token_entry_t connect_token_entries[NETCODE_MAX_CONNECT_TOKEN_ENTRIES];\n    struct netcode_encryption_manager_t encryption_manager;\n    uint8_t * receive_packet_data[NETCODE_SERVER_MAX_RECEIVE_PACKETS];\n    int receive_packet_bytes[NETCODE_SERVER_MAX_RECEIVE_PACKETS];\n    struct netcode_address_t receive_from[NETCODE_SERVER_MAX_RECEIVE_PACKETS];\n};\n\nint netcode_server_socket_create( struct netcode_socket_t * socket,\n                                  struct netcode_address_t * address,\n                                  int send_buffer_size,\n                                  int receive_buffer_size,\n                                  NETCODE_CONST struct netcode_server_config_t * config )\n{\n    netcode_assert( socket );\n    netcode_assert( address );\n    netcode_assert( config );\n\n    if ( !config->network_simulator )\n    {\n        if ( !config->override_send_and_receive )\n        {\n            if ( netcode_socket_create( socket, address, send_buffer_size, receive_buffer_size ) != NETCODE_SOCKET_ERROR_NONE )\n            {\n                return 0;\n            }\n        }\n    }\n\n    return 1;\n}\n\nstruct netcode_server_t * netcode_server_create_overload( NETCODE_CONST char * server_address1_string, NETCODE_CONST char * server_address2_string, NETCODE_CONST struct netcode_server_config_t * config, double time )\n{\n    netcode_assert( config );\n    netcode_assert( netcode.initialized );\n\n    struct netcode_address_t server_address1;\n    struct netcode_address_t server_address2;\n\n    memset( &server_address1, 0, sizeof( server_address1 ) );\n    memset( &server_address2, 0, sizeof( server_address2 ) );\n\n    if ( netcode_parse_address( server_address1_string, &server_address1 ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to parse server public address\\n\" );\n        return NULL;\n    }\n\n    if ( server_address2_string != NULL && netcode_parse_address( server_address2_string, &server_address2 ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: failed to parse server public address2\\n\" );\n        return NULL;\n    }\n\n    struct netcode_address_t bind_address_ipv4;\n    struct netcode_address_t bind_address_ipv6;\n\n    memset( &bind_address_ipv4, 0, sizeof( bind_address_ipv4 ) );\n    memset( &bind_address_ipv6, 0, sizeof( bind_address_ipv6 ) );\n\n    struct netcode_socket_t socket_ipv4;\n    struct netcode_socket_t socket_ipv6;\n\n    memset( &socket_ipv4, 0, sizeof( socket_ipv4 ) );\n    memset( &socket_ipv6, 0, sizeof( socket_ipv6 ) );\n\n    if ( server_address1.type == NETCODE_ADDRESS_IPV4 || server_address2.type == NETCODE_ADDRESS_IPV4 )\n    {\n        bind_address_ipv4.type = NETCODE_ADDRESS_IPV4;\n        bind_address_ipv4.port = server_address1.type == NETCODE_ADDRESS_IPV4 ? server_address1.port : server_address2.port;\n\n        if ( !netcode_server_socket_create( &socket_ipv4, &bind_address_ipv4, NETCODE_SERVER_SOCKET_SNDBUF_SIZE, NETCODE_SERVER_SOCKET_RCVBUF_SIZE, config ) )\n        {\n            return NULL;\n        }\n    }\n\n    if ( server_address1.type == NETCODE_ADDRESS_IPV6 || server_address2.type == NETCODE_ADDRESS_IPV6 )\n    {\n        bind_address_ipv6.type = NETCODE_ADDRESS_IPV6;\n        bind_address_ipv6.port = server_address1.type == NETCODE_ADDRESS_IPV6 ? server_address1.port : server_address2.port;\n\n        if ( !netcode_server_socket_create( &socket_ipv6, &bind_address_ipv6, NETCODE_SERVER_SOCKET_SNDBUF_SIZE, NETCODE_SERVER_SOCKET_RCVBUF_SIZE, config ) )\n        {\n            return NULL;\n        }\n    }\n\n    struct netcode_server_t * server = (struct netcode_server_t*) config->allocate_function( config->allocator_context, sizeof( struct netcode_server_t ) );\n    if ( !server )\n    {\n        netcode_socket_destroy( &socket_ipv4 );\n        netcode_socket_destroy( &socket_ipv6 );\n        return NULL;\n    }\n\n    memset( server, 0, sizeof(struct netcode_server_t) );\n\n    if ( !config->network_simulator )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server listening on %s\\n\", server_address1_string );\n    }\n    else\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server listening on %s (network simulator)\\n\", server_address1_string );\n    }\n\n    server->config = *config;\n    server->socket_holder.ipv4 = socket_ipv4;\n    server->socket_holder.ipv6 = socket_ipv6;\n    server->address = server_address1;\n    server->time = time;\n    server->global_sequence = 1ULL << 63;\n\n    int i;\n    for ( i = 0; i < NETCODE_MAX_CLIENTS; i++ )\n    {\n        server->client_encryption_index[i] = -1;\n    }\n\n    netcode_connect_token_entries_reset( server->connect_token_entries );\n\n    netcode_encryption_manager_reset( &server->encryption_manager );\n\n    for ( i = 0; i < NETCODE_MAX_CLIENTS; i++ )\n    {\n        netcode_replay_protection_reset( &server->client_replay_protection[i] );\n    }\n\n    return server;\n}\n\nstruct netcode_server_t * netcode_server_create( NETCODE_CONST char * server_address_string, NETCODE_CONST struct netcode_server_config_t * config, double time )\n{\n    return netcode_server_create_overload( server_address_string, NULL, config, time );\n}\n\nvoid netcode_server_stop( struct netcode_server_t * server );\n\nvoid netcode_server_destroy( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    netcode_server_stop( server );\n\n    netcode_socket_destroy( &server->socket_holder.ipv4 );\n    netcode_socket_destroy( &server->socket_holder.ipv6 );\n\n    server->config.free_function( server->config.allocator_context, server );\n}\n\nvoid netcode_server_start( struct netcode_server_t * server, int max_clients )\n{\n    netcode_assert( server );\n    netcode_assert( max_clients > 0 );\n    netcode_assert( max_clients <= NETCODE_MAX_CLIENTS );\n\n    if ( server->running )\n    {\n        netcode_server_stop( server );\n    }\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server started with %d client slots\\n\", max_clients );\n\n    server->running = 1;\n    server->max_clients = max_clients;\n    server->num_connected_clients = 0;\n    server->challenge_sequence = 0;    \n    netcode_generate_key( server->challenge_key );\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {\n        netcode_packet_queue_init( &server->client_packet_queue[i], server->config.allocator_context, server->config.allocate_function, server->config.free_function );\n    }\n}\n\nvoid netcode_server_send_global_packet( struct netcode_server_t * server, void * packet, struct netcode_address_t * to, uint8_t * packet_key )\n{\n    netcode_assert( server );\n    netcode_assert( packet );\n    netcode_assert( to );\n    netcode_assert( packet_key );\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_BYTES];\n\n    int packet_bytes = netcode_write_packet( packet, packet_data, NETCODE_MAX_PACKET_BYTES, server->global_sequence, packet_key, server->config.protocol_id );\n\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_BYTES );\n\n    if ( server->config.network_simulator )\n    {\n        netcode_network_simulator_send_packet( server->config.network_simulator, &server->address, to, packet_data, packet_bytes );\n    }\n    else\n    {\n        if ( server->config.override_send_and_receive )\n        {\n            server->config.send_packet_override( server->config.callback_context, to, packet_data, packet_bytes );\n        }\n        else if ( to->type == NETCODE_ADDRESS_IPV4 )\n        {\n            netcode_socket_send_packet( &server->socket_holder.ipv4, to, packet_data, packet_bytes );\n        }\n        else if ( to->type == NETCODE_ADDRESS_IPV6 )\n        {\n            netcode_socket_send_packet( &server->socket_holder.ipv6, to, packet_data, packet_bytes );\n        }\n    }\n\n    server->global_sequence++;\n}\n\nvoid netcode_server_send_client_packet( struct netcode_server_t * server, void * packet, int client_index )\n{\n    netcode_assert( server );\n    netcode_assert( packet );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( server->client_connected[client_index] );\n    netcode_assert( !server->client_loopback[client_index] );\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_BYTES];\n\n    if ( !netcode_encryption_manager_touch( &server->encryption_manager, \n                                            server->client_encryption_index[client_index], \n                                            &server->client_address[client_index], \n                                            server->time ) )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_ERROR, \"error: encryption mapping is out of date for client %d\\n\", client_index );\n        return;\n    }\n\n    uint8_t * packet_key = netcode_encryption_manager_get_send_key( &server->encryption_manager, server->client_encryption_index[client_index] );\n\n    int packet_bytes = netcode_write_packet( packet, packet_data, NETCODE_MAX_PACKET_BYTES, server->client_sequence[client_index], packet_key, server->config.protocol_id );\n\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_BYTES );\n\n    if ( server->config.network_simulator )\n    {\n        netcode_network_simulator_send_packet( server->config.network_simulator, &server->address, &server->client_address[client_index], packet_data, packet_bytes );\n    }\n    else\n    {\n        if ( server->config.override_send_and_receive )\n        {\n            server->config.send_packet_override( server->config.callback_context, &server->client_address[client_index], packet_data, packet_bytes );\n        }\n        else\n        {\n            if ( server->client_address[client_index].type == NETCODE_ADDRESS_IPV4 )\n            {\n                netcode_socket_send_packet( &server->socket_holder.ipv4, &server->client_address[client_index], packet_data, packet_bytes );\n            }\n            else if ( server->client_address[client_index].type == NETCODE_ADDRESS_IPV6 )\n            {\n                netcode_socket_send_packet( &server->socket_holder.ipv6, &server->client_address[client_index], packet_data, packet_bytes );\n            }\n        }\n    }\n\n    server->client_sequence[client_index]++;\n\n    server->client_last_packet_send_time[client_index] = server->time;\n}\n\nvoid netcode_server_disconnect_client_internal( struct netcode_server_t * server, int client_index, int send_disconnect_packets )\n{\n    netcode_assert( server );\n    netcode_assert( server->running );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( server->client_connected[client_index] );\n    netcode_assert( !server->client_loopback[client_index] );\n    netcode_assert( server->encryption_manager.client_index[server->client_encryption_index[client_index]] == client_index );\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server disconnected client %d\\n\", client_index );\n\n    if ( server->config.connect_disconnect_callback )\n    {\n        server->config.connect_disconnect_callback( server->config.callback_context, client_index, 0 );\n    }\n\n    if ( send_disconnect_packets )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server sent disconnect packets to client %d\\n\", client_index );\n\n        int i;\n        for ( i = 0; i < NETCODE_NUM_DISCONNECT_PACKETS; i++ )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server sent disconnect packet %d\\n\", i );\n\n            struct netcode_connection_disconnect_packet_t packet;\n            packet.packet_type = NETCODE_CONNECTION_DISCONNECT_PACKET;\n\n            netcode_server_send_client_packet( server, &packet, client_index );\n        }\n    }\n\n    while ( 1 )\n    {\n        void * packet = netcode_packet_queue_pop( &server->client_packet_queue[client_index], NULL );\n        if ( !packet )\n            break;\n        server->config.free_function( server->config.allocator_context, packet );\n    }\n\n    netcode_packet_queue_clear( &server->client_packet_queue[client_index] );\n\n    netcode_replay_protection_reset( &server->client_replay_protection[client_index] );\n\n    server->encryption_manager.client_index[server->client_encryption_index[client_index]] = -1;\n\n    netcode_encryption_manager_remove_encryption_mapping( &server->encryption_manager, &server->client_address[client_index], server->time );\n\n    server->client_connected[client_index] = 0;\n    server->client_confirmed[client_index] = 0;\n    server->client_id[client_index] = 0;\n    server->client_sequence[client_index] = 0;\n    server->client_last_packet_send_time[client_index] = 0.0;\n    server->client_last_packet_receive_time[client_index] = 0.0;\n    memset( &server->client_address[client_index], 0, sizeof( struct netcode_address_t ) );\n    server->client_encryption_index[client_index] = -1;\n    memset( server->client_user_data[client_index], 0, NETCODE_USER_DATA_BYTES );\n\n    server->num_connected_clients--;\n\n    netcode_assert( server->num_connected_clients >= 0 );\n}\n\nvoid netcode_server_disconnect_client( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return;\n\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( server->client_loopback[client_index] == 0 );\n\n    if ( !server->client_connected[client_index] )\n        return;\n\n    if ( server->client_loopback[client_index] )\n        return;\n\n    netcode_server_disconnect_client_internal( server, client_index, 1 );\n}\n\nvoid netcode_server_disconnect_all_clients( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return;\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {\n        if ( server->client_connected[i] && !server->client_loopback[i] )\n        {\n            netcode_server_disconnect_client_internal( server, i, 1 );\n        }\n    }\n}\n\nvoid netcode_server_stop( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return;\n\n    netcode_server_disconnect_all_clients( server );\n\n    server->running = 0;\n    server->max_clients = 0;\n    server->num_connected_clients = 0;\n\n    server->global_sequence = 0;\n    server->challenge_sequence = 0;\n    memset( server->challenge_key, 0, NETCODE_KEY_BYTES );\n\n    netcode_connect_token_entries_reset( server->connect_token_entries );\n\n    netcode_encryption_manager_reset( &server->encryption_manager );\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server stopped\\n\" );\n}\n\nint netcode_server_find_client_index_by_id( struct netcode_server_t * server, uint64_t client_id )\n{\n    netcode_assert( server );\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {   \n        if ( server->client_connected[i] && server->client_id[i] == client_id )\n            return i;\n    }\n\n    return -1;\n}\n\nint netcode_server_find_client_index_by_address( struct netcode_server_t * server, struct netcode_address_t * address )\n{\n    netcode_assert( server );\n    netcode_assert( address );\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {   \n        if ( server->client_connected[i] && netcode_address_equal( &server->client_address[i], address ) )\n            return i;\n    }\n\n    return -1;\n}\n\nvoid netcode_server_process_connection_request_packet( struct netcode_server_t * server, \n                                                       struct netcode_address_t * from, \n                                                       struct netcode_connection_request_packet_t * packet )\n{\n    netcode_assert( server );\n\n    (void) from;\n\n    struct netcode_connect_token_private_t connect_token_private;\n    if ( netcode_read_connect_token_private( packet->connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, &connect_token_private ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. failed to read connect token\\n\" );\n        return;\n    }\n\n    int found_server_address = 0;\n    int i;\n    for ( i = 0; i < connect_token_private.num_server_addresses; i++ )\n    {\n        if ( netcode_address_equal( &server->address, &connect_token_private.server_addresses[i] ) )\n        {\n            found_server_address = 1;\n        }\n    }\n    if ( !found_server_address )\n    {   \n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. server address not in connect token whitelist\\n\" );\n        return;\n    }\n\n    if ( netcode_server_find_client_index_by_address( server, from ) != -1 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. a client with this address is already connected\\n\" );\n        return;\n    }\n\n    if ( netcode_server_find_client_index_by_id( server, connect_token_private.client_id ) != -1 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. a client with this id is already connected\\n\" );\n        return;\n    }\n\n    if ( !netcode_connect_token_entries_find_or_add( server->connect_token_entries, \n                                                     from, \n                                                     packet->connect_token_data + NETCODE_CONNECT_TOKEN_PRIVATE_BYTES - NETCODE_MAC_BYTES, \n                                                     server->time ) )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. connect token has already been used\\n\" );\n        return;\n    }\n\n    if ( server->num_connected_clients == server->max_clients )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server denied connection request. server is full\\n\" );\n\n        struct netcode_connection_denied_packet_t p;\n        p.packet_type = NETCODE_CONNECTION_DENIED_PACKET;\n        \n        netcode_server_send_global_packet( server, &p, from, connect_token_private.server_to_client_key );\n\n        return;\n    }\n\n    double expire_time = ( connect_token_private.timeout_seconds >= 0 ) ? server->time + connect_token_private.timeout_seconds : -1.0;\n\n    if ( !netcode_encryption_manager_add_encryption_mapping( &server->encryption_manager, \n                                                             from, \n                                                             connect_token_private.server_to_client_key, \n                                                             connect_token_private.client_to_server_key, \n                                                             server->time, \n                                                             expire_time,\n                                                             connect_token_private.timeout_seconds ) )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. failed to add encryption mapping\\n\" );\n        return;\n    }\n\n    struct netcode_challenge_token_t challenge_token;\n    challenge_token.client_id = connect_token_private.client_id;\n    memcpy( challenge_token.user_data, connect_token_private.user_data, NETCODE_USER_DATA_BYTES );\n\n    struct netcode_connection_challenge_packet_t challenge_packet;\n    challenge_packet.packet_type = NETCODE_CONNECTION_CHALLENGE_PACKET;\n    challenge_packet.challenge_token_sequence = server->challenge_sequence;\n    netcode_write_challenge_token( &challenge_token, challenge_packet.challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n    if ( netcode_encrypt_challenge_token( challenge_packet.challenge_token_data, \n                                          NETCODE_CHALLENGE_TOKEN_BYTES, \n                                          server->challenge_sequence, \n                                          server->challenge_key ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection request. failed to encrypt challenge token\\n\" );\n        return;\n    }\n\n    server->challenge_sequence++;\n\n    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server sent connection challenge packet\\n\" );\n\n    netcode_server_send_global_packet( server, &challenge_packet, from, connect_token_private.server_to_client_key );\n}\n\nint netcode_server_find_free_client_index( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {\n        if ( !server->client_connected[i] )\n            return i;\n    }\n\n    return -1;\n}\n\nvoid netcode_server_connect_client( struct netcode_server_t * server, \n                                    int client_index, \n                                    struct netcode_address_t * address, \n                                    uint64_t client_id, \n                                    int encryption_index,\n                                    int timeout_seconds, \n                                    void * user_data )\n{\n    netcode_assert( server );\n    netcode_assert( server->running );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( address );\n    netcode_assert( encryption_index != -1 );\n    netcode_assert( user_data );\n    netcode_assert( server->encryption_manager.client_index[encryption_index] == -1 );\n\n    server->num_connected_clients++;\n\n    netcode_assert( server->num_connected_clients <= server->max_clients );\n\n    netcode_assert( server->client_connected[client_index] == 0 );\n\n    netcode_encryption_manager_set_expire_time( &server->encryption_manager, encryption_index, -1.0 );\n    \n    server->encryption_manager.client_index[encryption_index] = client_index;\n\n    server->client_connected[client_index] = 1;\n    server->client_timeout[client_index] = timeout_seconds;\n    server->client_encryption_index[client_index] = encryption_index;\n    server->client_id[client_index] = client_id;\n    server->client_sequence[client_index] = 0;\n    server->client_address[client_index] = *address;\n    \n    netcode_assert( netcode_server_find_client_index_by_id( server, client_id ) == client_index );\n    netcode_assert( netcode_server_find_client_index_by_address( server, address ) == client_index );\n\n    server->client_last_packet_send_time[client_index] = server->time;\n    server->client_last_packet_receive_time[client_index] = server->time;\n    memcpy( server->client_user_data[client_index], user_data, NETCODE_USER_DATA_BYTES );\n\n    char address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server accepted client %s %.16\" PRIx64 \" in slot %d\\n\", \n        netcode_address_to_string( address, address_string ), client_id, client_index );\n\n    struct netcode_connection_keep_alive_packet_t packet;\n    packet.packet_type = NETCODE_CONNECTION_KEEP_ALIVE_PACKET;\n    packet.client_index = client_index;\n    packet.max_clients = server->max_clients;\n\n    netcode_server_send_client_packet( server, &packet, client_index );\n\n    if ( server->config.connect_disconnect_callback )\n    {\n        server->config.connect_disconnect_callback( server->config.callback_context, client_index, 1 );\n    }\n}\n\nvoid netcode_server_process_connection_response_packet( struct netcode_server_t * server, \n                                                        struct netcode_address_t * from, \n                                                        struct netcode_connection_response_packet_t * packet, \n                                                        int encryption_index )\n{\n    netcode_assert( server );\n\n    if ( netcode_decrypt_challenge_token( packet->challenge_token_data, \n                                          NETCODE_CHALLENGE_TOKEN_BYTES, \n                                          packet->challenge_token_sequence, \n                                          server->challenge_key ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection response. failed to decrypt challenge token\\n\" );\n        return;\n    }\n\n    struct netcode_challenge_token_t challenge_token;\n    if ( netcode_read_challenge_token( packet->challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES, &challenge_token ) != NETCODE_OK )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection response. failed to read challenge token\\n\" );\n        return;\n    }\n\n    uint8_t * packet_send_key = netcode_encryption_manager_get_send_key( &server->encryption_manager, encryption_index );\n\n    if ( !packet_send_key )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection response. no packet send key\\n\" );\n        return;\n    }\n\n    if ( netcode_server_find_client_index_by_address( server, from ) != -1 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection response. a client with this address is already connected\\n\" );\n        return;\n    }\n\n    if ( netcode_server_find_client_index_by_id( server, challenge_token.client_id ) != -1 )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server ignored connection response. a client with this id is already connected\\n\" );\n        return;\n    }\n\n    if ( server->num_connected_clients == server->max_clients )\n    {\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server denied connection response. server is full\\n\" );\n\n        struct netcode_connection_denied_packet_t p;\n        p.packet_type = NETCODE_CONNECTION_DENIED_PACKET;\n\n        netcode_server_send_global_packet( server, &p, from, packet_send_key );\n\n        return;\n    }\n\n    int client_index = netcode_server_find_free_client_index( server );\n\n    netcode_assert( client_index != -1 );\n\n    int timeout_seconds = netcode_encryption_manager_get_timeout( &server->encryption_manager, encryption_index );\n\n    netcode_server_connect_client( server, client_index, from, challenge_token.client_id, encryption_index, timeout_seconds, challenge_token.user_data );\n}\n\nvoid netcode_server_process_packet_internal( struct netcode_server_t * server, \n                                             struct netcode_address_t * from, \n                                             void * packet, \n                                             uint64_t sequence, \n                                             int encryption_index, \n                                             int client_index )\n{\n    netcode_assert( server );\n    netcode_assert( packet );\n\n    (void) from;\n    (void) sequence;\n\n    uint8_t packet_type = ( (uint8_t*) packet ) [0];\n\n    switch ( packet_type )\n    {\n        case NETCODE_CONNECTION_REQUEST_PACKET:\n        {    \n            if ( ( server->flags & NETCODE_SERVER_FLAG_IGNORE_CONNECTION_REQUEST_PACKETS ) == 0 )\n            {\n                char from_address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server received connection request from %s\\n\", netcode_address_to_string( from, from_address_string ) );\n                netcode_server_process_connection_request_packet( server, from, (struct netcode_connection_request_packet_t*) packet );\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_RESPONSE_PACKET:\n        {    \n            if ( ( server->flags & NETCODE_SERVER_FLAG_IGNORE_CONNECTION_RESPONSE_PACKETS ) == 0 )\n            {\n                char from_address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server received connection response from %s\\n\", netcode_address_to_string( from, from_address_string ) );\n                netcode_server_process_connection_response_packet( server, from, (struct netcode_connection_response_packet_t*) packet, encryption_index );\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_KEEP_ALIVE_PACKET:\n        {\n            if ( client_index != -1 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server received connection keep alive packet from client %d\\n\", client_index );\n                server->client_last_packet_receive_time[client_index] = server->time;\n                if ( !server->client_confirmed[client_index] )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server confirmed connection with client %d\\n\", client_index );\n                    server->client_confirmed[client_index] = 1;\n                }\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_PAYLOAD_PACKET:\n        {\n            if ( client_index != -1 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server received connection payload packet from client %d\\n\", client_index );\n                server->client_last_packet_receive_time[client_index] = server->time;\n                if ( !server->client_confirmed[client_index] )\n                {\n                    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server confirmed connection with client %d\\n\", client_index );\n                    server->client_confirmed[client_index] = 1;\n                }\n                netcode_packet_queue_push( &server->client_packet_queue[client_index], packet, sequence );\n                return;\n            }\n        }\n        break;\n\n        case NETCODE_CONNECTION_DISCONNECT_PACKET:\n        {\n            if ( client_index != -1 )\n            {\n                netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server received disconnect packet from client %d\\n\", client_index );\n                netcode_server_disconnect_client_internal( server, client_index, 0 );\n           }\n        }\n        break;\n\n        default:\n            break;\n    }\n\n    server->config.free_function( server->config.allocator_context, packet );\n}\n\nvoid netcode_server_process_packet( struct netcode_server_t * server, struct netcode_address_t * from, uint8_t * packet_data, int packet_bytes )\n{\n    uint8_t allowed_packets[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packets, 0, sizeof( allowed_packets ) );\n    allowed_packets[NETCODE_CONNECTION_REQUEST_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_RESPONSE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_KEEP_ALIVE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_PAYLOAD_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_DISCONNECT_PACKET] = 1;\n\n    uint64_t current_timestamp = (uint64_t) time( NULL );\n\n    uint64_t sequence;\n\n    int encryption_index = -1;\n    int client_index = netcode_server_find_client_index_by_address( server, from );\n    if ( client_index != -1 )\n    {\n        netcode_assert( client_index >= 0 );\n        netcode_assert( client_index < server->max_clients );\n        encryption_index = server->client_encryption_index[client_index];\n    }\n    else\n    {\n        encryption_index = netcode_encryption_manager_find_encryption_mapping( &server->encryption_manager, from, server->time );\n    }\n    \n    uint8_t * read_packet_key = netcode_encryption_manager_get_receive_key( &server->encryption_manager, encryption_index );\n\n    if ( !read_packet_key && packet_data[0] != 0 )\n    {\n        char address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server could not process packet because no encryption mapping exists for %s\\n\", netcode_address_to_string( from, address_string ) );\n        return;\n    }\n\n    void * packet = netcode_read_packet( packet_data, \n                                         packet_bytes, \n                                         &sequence, \n                                         read_packet_key, \n                                         server->config.protocol_id, \n                                         current_timestamp, \n                                         server->config.private_key, \n                                         allowed_packets, \n                                         ( client_index != -1 ) ? &server->client_replay_protection[client_index] : NULL, \n                                         server->config.allocator_context, \n                                         server->config.allocate_function );\n\n    if ( !packet )\n        return;\n\n    netcode_server_process_packet_internal( server, from, packet, sequence, encryption_index, client_index );\n}\n\nvoid netcode_server_read_and_process_packet( struct netcode_server_t * server, \n                                             struct netcode_address_t * from, \n                                             uint8_t * packet_data, \n                                             int packet_bytes, \n                                             uint64_t current_timestamp, \n                                             uint8_t * allowed_packets )\n{\n    if ( !server->running )\n        return;\n\n    if ( packet_bytes <= 1 )\n        return;\n\n    uint64_t sequence;\n\n    int encryption_index = -1;\n    int client_index = netcode_server_find_client_index_by_address( server, from );\n    if ( client_index != -1 )\n    {\n        netcode_assert( client_index >= 0 );\n        netcode_assert( client_index < server->max_clients );\n        encryption_index = server->client_encryption_index[client_index];\n    }\n    else\n    {\n        encryption_index = netcode_encryption_manager_find_encryption_mapping( &server->encryption_manager, from, server->time );\n    }\n    \n    uint8_t * read_packet_key = netcode_encryption_manager_get_receive_key( &server->encryption_manager, encryption_index );\n\n    if ( !read_packet_key && packet_data[0] != 0 )\n    {\n        char address_string[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n        netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server could not process packet because no encryption mapping exists for %s\\n\", netcode_address_to_string( from, address_string ) );\n        return;\n    }\n\n    void * packet = netcode_read_packet( packet_data, \n                                         packet_bytes, \n                                         &sequence, \n                                         read_packet_key, \n                                         server->config.protocol_id, \n                                         current_timestamp, \n                                         server->config.private_key, \n                                         allowed_packets, \n                                         ( client_index != -1 ) ? &server->client_replay_protection[client_index] : NULL, \n                                         server->config.allocator_context, \n                                         server->config.allocate_function );\n\n    if ( !packet )\n        return;\n\n    netcode_server_process_packet_internal( server, from, packet, sequence, encryption_index, client_index );\n}\n\nvoid netcode_server_receive_packets( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    uint8_t allowed_packets[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packets, 0, sizeof( allowed_packets ) );\n    allowed_packets[NETCODE_CONNECTION_REQUEST_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_RESPONSE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_KEEP_ALIVE_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_PAYLOAD_PACKET] = 1;\n    allowed_packets[NETCODE_CONNECTION_DISCONNECT_PACKET] = 1;\n\n    uint64_t current_timestamp = (uint64_t) time( NULL );\n\n    if ( !server->config.network_simulator )\n    {\n        // process packets received from socket\n\n        while ( 1 )\n        {\n            struct netcode_address_t from;\n            \n            uint8_t packet_data[NETCODE_MAX_PACKET_BYTES];\n            \n            int packet_bytes = 0;\n            \n            if ( server->config.override_send_and_receive )\n            {\n                packet_bytes = server->config.receive_packet_override( server->config.callback_context, &from, packet_data, NETCODE_MAX_PACKET_BYTES );\n            }\n            else\n            {\n                if (server->socket_holder.ipv4.handle != 0)\n                    packet_bytes = netcode_socket_receive_packet( &server->socket_holder.ipv4, &from, packet_data, NETCODE_MAX_PACKET_BYTES );\n\n                if ( packet_bytes == 0 && server->socket_holder.ipv6.handle != 0)\n                    packet_bytes = netcode_socket_receive_packet( &server->socket_holder.ipv6, &from, packet_data, NETCODE_MAX_PACKET_BYTES );\n            }\n\n            if ( packet_bytes == 0 )\n                break;\n\n            netcode_server_read_and_process_packet( server, &from, packet_data, packet_bytes, current_timestamp, allowed_packets );\n        }\n    }\n    else\n    {\n        // process packets received from network simulator\n\n        int num_packets_received = netcode_network_simulator_receive_packets( server->config.network_simulator, \n                                                                              &server->address, \n                                                                              NETCODE_SERVER_MAX_RECEIVE_PACKETS, \n                                                                              server->receive_packet_data, \n                                                                              server->receive_packet_bytes, \n                                                                              server->receive_from );\n\n        int i;\n        for ( i = 0; i < num_packets_received; i++ )\n        {\n            netcode_server_read_and_process_packet( server, \n                                                    &server->receive_from[i], \n                                                    server->receive_packet_data[i], \n                                                    server->receive_packet_bytes[i], \n                                                    current_timestamp, \n                                                    allowed_packets );\n\n            server->config.free_function( server->config.allocator_context, server->receive_packet_data[i] );\n        }\n    }\n}\n\nvoid netcode_server_send_packets( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return;\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {\n        if ( server->client_connected[i] && !server->client_loopback[i] &&\n             ( server->client_last_packet_send_time[i] + ( 1.0 / NETCODE_PACKET_SEND_RATE ) <= server->time ) )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server sent connection keep alive packet to client %d\\n\", i );\n            struct netcode_connection_keep_alive_packet_t packet;\n            packet.packet_type = NETCODE_CONNECTION_KEEP_ALIVE_PACKET;\n            packet.client_index = i;\n            packet.max_clients = server->max_clients;\n            netcode_server_send_client_packet( server, &packet, i );\n        }\n    }\n}\n\nvoid netcode_server_check_for_timeouts( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return;\n\n    int i;\n    for ( i = 0; i < server->max_clients; i++ )\n    {\n        if ( !server->client_connected[i] )\n            continue;\n\n        if ( server->client_timeout[i] <= 0 )\n            continue;\n\n        if ( server->client_loopback[i] )\n            continue;\n\n        if ( ( server->time - server->client_last_packet_receive_time[i] ) >= 1.0f )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server has not received a packet from client %d for %.2f seconds\\n\", i, server->time - server->client_last_packet_receive_time[i] );\n        }\n\n        if ( server->client_last_packet_receive_time[i] + server->client_timeout[i] <= server->time )\n        {\n            netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server timed out client %d\\n\", i );\n            netcode_server_disconnect_client_internal( server, i, 0 );\n        }\n    }\n}\n\nint netcode_server_client_connected( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return 0;\n\n    if ( client_index < 0 || client_index >= server->max_clients )\n        return 0;\n\n    return server->client_connected[client_index];\n}\n\nuint64_t netcode_server_client_id( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n\n    if ( !server->running )\n        return 0;\n\n    if ( client_index < 0 || client_index >= server->max_clients )\n        return 0;\n\n    return server->client_id[client_index];\n}\n\nstruct netcode_address_t * netcode_server_client_address( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n\n    if (!server->running)\n        return NULL;\n\n    if (client_index < 0 || client_index >= server->max_clients)\n        return NULL;\n\n    return &server->client_address[client_index];\n}\n\nuint64_t netcode_server_next_packet_sequence( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    if ( !server->client_connected[client_index] )\n        return 0;\n    return server->client_sequence[client_index];    \n}\n\nvoid netcode_server_send_packet( struct netcode_server_t * server, int client_index, NETCODE_CONST uint8_t * packet_data, int packet_bytes )\n{\n    netcode_assert( server );\n    netcode_assert( packet_data );\n    netcode_assert( packet_bytes >= 0 );\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_SIZE );\n\n    if ( !server->running )\n        return;\n\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    if ( !server->client_connected[client_index] )\n        return;\n\n    if ( !server->client_loopback[client_index] )\n    {\n        uint8_t buffer[NETCODE_MAX_PAYLOAD_BYTES*2];\n\n        struct netcode_connection_payload_packet_t * packet = (struct netcode_connection_payload_packet_t*) buffer;\n\n        packet->packet_type = NETCODE_CONNECTION_PAYLOAD_PACKET;\n        packet->payload_bytes = packet_bytes;\n        memcpy( packet->payload_data, packet_data, packet_bytes );\n\n        if ( !server->client_confirmed[client_index] )\n        {\n            struct netcode_connection_keep_alive_packet_t keep_alive_packet;\n            keep_alive_packet.packet_type = NETCODE_CONNECTION_KEEP_ALIVE_PACKET;\n            keep_alive_packet.client_index = client_index;\n            keep_alive_packet.max_clients = server->max_clients;\n            netcode_server_send_client_packet( server, &keep_alive_packet, client_index );\n        }\n\n        netcode_server_send_client_packet( server, packet, client_index );\n    }\n    else\n    {\n        netcode_assert( server->config.send_loopback_packet_callback );\n\n        server->config.send_loopback_packet_callback( server->config.callback_context,\n                                                      client_index, \n                                                      packet_data, \n                                                      packet_bytes, \n                                                      server->client_sequence[client_index]++ );\n\n        server->client_last_packet_send_time[client_index] = server->time;\n    }\n}\n\nuint8_t * netcode_server_receive_packet( struct netcode_server_t * server, int client_index, int * packet_bytes, uint64_t * packet_sequence )\n{\n    netcode_assert( server );\n    netcode_assert( packet_bytes );\n\n    if ( !server->running )\n        return NULL;\n\n    if ( !server->client_connected[client_index] )\n        return NULL;\n\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n\n    struct netcode_connection_payload_packet_t * packet = (struct netcode_connection_payload_packet_t*) \n        netcode_packet_queue_pop( &server->client_packet_queue[client_index], packet_sequence );\n    \n    if ( packet )\n    {\n        netcode_assert( packet->packet_type == NETCODE_CONNECTION_PAYLOAD_PACKET );\n        *packet_bytes = packet->payload_bytes;\n        netcode_assert( *packet_bytes >= 0 );\n        netcode_assert( *packet_bytes <= NETCODE_MAX_PAYLOAD_BYTES );\n        return (uint8_t*) &packet->payload_data;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nvoid netcode_server_free_packet( struct netcode_server_t * server, void * packet )\n{\n    netcode_assert( server );\n    netcode_assert( packet );\n    (void) server;\n    int offset = offsetof( struct netcode_connection_payload_packet_t, payload_data );\n    server->config.free_function( server->config.allocator_context, ( (uint8_t*) packet ) - offset );\n}\n\nint netcode_server_num_connected_clients( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n    return server->num_connected_clients;\n}\n\nvoid * netcode_server_client_user_data( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    return server->client_user_data[client_index];\n}\n\nint netcode_server_running( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n    return server->running;\n}\n\nint netcode_server_max_clients( struct netcode_server_t * server )\n{\n    return server->max_clients;\n}\n\nvoid netcode_server_update( struct netcode_server_t * server, double time )\n{\n    netcode_assert( server );\n    server->time = time;\n    netcode_server_receive_packets( server );\n    netcode_server_send_packets( server );\n    netcode_server_check_for_timeouts( server );\n}\n\nvoid netcode_server_connect_loopback_client( struct netcode_server_t * server, int client_index, uint64_t client_id, NETCODE_CONST uint8_t * user_data )\n{\n    netcode_assert( server );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( server->running );\n    netcode_assert( !server->client_connected[client_index] );\n\n    server->num_connected_clients++;\n\n    netcode_assert( server->num_connected_clients <= server->max_clients );\n\n    server->client_loopback[client_index] = 1;\n    server->client_connected[client_index] = 1;\n    server->client_confirmed[client_index] = 1;\n    server->client_encryption_index[client_index] = -1;\n    server->client_id[client_index] = client_id;\n    server->client_sequence[client_index] = 0;\n    memset( &server->client_address[client_index], 0, sizeof( struct netcode_address_t ) );\n    server->client_last_packet_send_time[client_index] = server->time;\n    server->client_last_packet_receive_time[client_index] = server->time;\n\n    if ( user_data )\n    {\n        memcpy( server->client_user_data[client_index], user_data, NETCODE_USER_DATA_BYTES );\n    }\n    else\n    {\n        memset( server->client_user_data[client_index], 0, NETCODE_USER_DATA_BYTES );\n    }\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server connected loopback client %.16\" PRIx64 \" in slot %d\\n\", client_id, client_index );\n\n    if ( server->config.connect_disconnect_callback )\n    {\n        server->config.connect_disconnect_callback( server->config.callback_context, client_index, 1 );\n    }\n}\n\nvoid netcode_server_disconnect_loopback_client( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( server->running );\n    netcode_assert( server->client_connected[client_index] );\n    netcode_assert( server->client_loopback[client_index] );\n\n    netcode_printf( NETCODE_LOG_LEVEL_INFO, \"server disconnected loopback client %d\\n\", client_index );\n\n    if ( server->config.connect_disconnect_callback )\n    {\n        server->config.connect_disconnect_callback( server->config.callback_context, client_index, 0 );\n    }\n\n    while ( 1 )\n    {\n        void * packet = netcode_packet_queue_pop( &server->client_packet_queue[client_index], NULL );\n        if ( !packet )\n            break;\n        server->config.free_function( server->config.allocator_context, packet );\n    }\n\n    netcode_packet_queue_clear( &server->client_packet_queue[client_index] );\n\n    server->client_connected[client_index] = 0;\n    server->client_loopback[client_index] = 0;\n    server->client_confirmed[client_index] = 0;\n    server->client_id[client_index] = 0;\n    server->client_sequence[client_index] = 0;\n    server->client_last_packet_send_time[client_index] = 0.0;\n    server->client_last_packet_receive_time[client_index] = 0.0;\n    memset( &server->client_address[client_index], 0, sizeof( struct netcode_address_t ) );\n    server->client_encryption_index[client_index] = -1;\n    memset( server->client_user_data[client_index], 0, NETCODE_USER_DATA_BYTES );\n\n    server->num_connected_clients--;\n\n    netcode_assert( server->num_connected_clients >= 0 );\n}\n\nint netcode_server_client_loopback( struct netcode_server_t * server, int client_index )\n{\n    netcode_assert( server );\n    netcode_assert( server->running );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    return server->client_loopback[client_index];\n}\n\nvoid netcode_server_process_loopback_packet( struct netcode_server_t * server, int client_index, NETCODE_CONST uint8_t * packet_data, int packet_bytes, uint64_t packet_sequence )\n{\n    netcode_assert( server );\n    netcode_assert( client_index >= 0 );\n    netcode_assert( client_index < server->max_clients );\n    netcode_assert( packet_data );\n    netcode_assert( packet_bytes >= 0 );\n    netcode_assert( packet_bytes <= NETCODE_MAX_PACKET_SIZE );\n    netcode_assert( server->client_connected[client_index] );\n    netcode_assert( server->client_loopback[client_index] );\n    netcode_assert( server->running );\n\n    struct netcode_connection_payload_packet_t * packet = netcode_create_payload_packet( packet_bytes, server->config.allocator_context, server->config.allocate_function );\n    if ( !packet )\n        return;\n\n    memcpy( packet->payload_data, packet_data, packet_bytes );\n\n    netcode_printf( NETCODE_LOG_LEVEL_DEBUG, \"server processing loopback packet from client %d\\n\", client_index );\n\n    server->client_last_packet_receive_time[client_index] = server->time;\n\n    netcode_packet_queue_push( &server->client_packet_queue[client_index], packet, packet_sequence );\n}\n\nuint16_t netcode_server_get_port( struct netcode_server_t * server )\n{\n    netcode_assert( server );\n    return server->address.type == NETCODE_ADDRESS_IPV4 ? server->socket_holder.ipv4.address.port : server->socket_holder.ipv6.address.port;\n}\n\n// ----------------------------------------------------------------\n\nint netcode_generate_connect_token( int num_server_addresses, \n                                    NETCODE_CONST char ** public_server_addresses, \n                                    NETCODE_CONST char ** internal_server_addresses, \n                                    int expire_seconds, \n                                    int timeout_seconds,\n                                    uint64_t client_id, \n                                    uint64_t protocol_id, \n                                    NETCODE_CONST uint8_t * private_key, \n                                    uint8_t * user_data, \n                                    uint8_t * output_buffer )\n{\n    netcode_assert( num_server_addresses > 0 );\n    netcode_assert( num_server_addresses <= NETCODE_MAX_SERVERS_PER_CONNECT );\n    netcode_assert( public_server_addresses );\n    netcode_assert( internal_server_addresses );\n    netcode_assert( private_key );\n    netcode_assert( user_data );\n    netcode_assert( output_buffer );\n\n    // parse public server addresses\n\n    struct netcode_address_t parsed_public_server_addresses[NETCODE_MAX_SERVERS_PER_CONNECT];\n    int i;\n    for ( i = 0; i < num_server_addresses; i++ )\n    {\n        if ( netcode_parse_address( public_server_addresses[i], &parsed_public_server_addresses[i] ) != NETCODE_OK )\n        {\n            return NETCODE_ERROR;\n        }\n    }\n\n    // parse internal server addresses\n\n     struct netcode_address_t parsed_internal_server_addresses[NETCODE_MAX_SERVERS_PER_CONNECT];\n    for ( i = 0; i < num_server_addresses; i++ )\n    {\n        if ( netcode_parse_address( internal_server_addresses[i], &parsed_internal_server_addresses[i] ) != NETCODE_OK )\n        {\n            return NETCODE_ERROR;\n        }\n    }\n\n    // generate a connect token\n\n    uint8_t nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n    netcode_generate_nonce(nonce);\n\n    struct netcode_connect_token_private_t connect_token_private;\n    netcode_generate_connect_token_private( &connect_token_private, client_id, timeout_seconds, num_server_addresses, parsed_internal_server_addresses, user_data );\n\n    // write it to a buffer\n\n    uint8_t connect_token_data[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n    netcode_write_connect_token_private( &connect_token_private, connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    // encrypt the buffer\n\n    uint64_t create_timestamp = time( NULL );\n    uint64_t expire_timestamp = ( expire_seconds >= 0 ) ? ( create_timestamp + expire_seconds ) : 0xFFFFFFFFFFFFFFFFULL;\n    if ( netcode_encrypt_connect_token_private( connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, NETCODE_VERSION_INFO, protocol_id, expire_timestamp, nonce, private_key ) != NETCODE_OK )\n        return NETCODE_ERROR;\n\n    // wrap a connect token around the private connect token data\n\n    struct netcode_connect_token_t connect_token;\n    memcpy( connect_token.version_info, NETCODE_VERSION_INFO, NETCODE_VERSION_INFO_BYTES );\n    connect_token.protocol_id = protocol_id;\n    connect_token.create_timestamp = create_timestamp;\n    connect_token.expire_timestamp = expire_timestamp;\n    memcpy( connect_token.nonce, nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n    memcpy( connect_token.private_data, connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n    connect_token.num_server_addresses = num_server_addresses;\n    for ( i = 0; i < num_server_addresses; i++ )\n        connect_token.server_addresses[i] = parsed_public_server_addresses[i];\n    memcpy( connect_token.client_to_server_key, connect_token_private.client_to_server_key, NETCODE_KEY_BYTES );\n    memcpy( connect_token.server_to_client_key, connect_token_private.server_to_client_key, NETCODE_KEY_BYTES );\n    connect_token.timeout_seconds = timeout_seconds;\n\n    // write the connect token to the output buffer\n\n    netcode_write_connect_token( &connect_token, output_buffer, NETCODE_CONNECT_TOKEN_BYTES );\n\n    return NETCODE_OK;\n}\n\n// ---------------------------------------------------------------\n\n#if __APPLE__\n\n// MacOS\n\n#include <unistd.h>\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n\nvoid netcode_sleep( double time )\n{\n    struct timespec ts;\n    ts.tv_sec = (time_t) time;\n    ts.tv_nsec = (long) ((time - (double) ( ts.tv_sec )) * 1000000000.0);\n    nanosleep( &ts, NULL );\n}\n\nstatic uint64_t start = 0;\nstatic mach_timebase_info_data_t timebase_info;\n\ndouble netcode_time()\n{\n    if ( start == 0 )\n    {\n        mach_timebase_info( &timebase_info );\n        start = mach_absolute_time();\n        return 0.0;\n    }\n    uint64_t current = mach_absolute_time();\n    return ( (double) ( current - start ) ) * ( (double) timebase_info.numer ) / ( (double) timebase_info.denom ) / 1000000000.0;\n}\n\n#elif __linux\n\n// linux\n\n#include <unistd.h>\n\nvoid netcode_sleep( double time )\n{\n    struct timespec ts;\n    ts.tv_sec = (time_t) time;\n    ts.tv_nsec = (long) ((time - (double) ( ts.tv_sec )) * 1000000000.0);\n    nanosleep( &ts, NULL );\n}\n\ndouble netcode_time()\n{\n    static double start = -1;\n    if ( start == -1 )\n    {\n        struct timespec ts;\n        clock_gettime( CLOCK_MONOTONIC_RAW, &ts );\n        start = ts.tv_sec + ( (double) ( ts.tv_nsec ) ) / 1000000000.0;\n        return 0.0;\n    }\n    struct timespec ts;\n    clock_gettime( CLOCK_MONOTONIC_RAW, &ts );\n    double current = ts.tv_sec + ( (double) ( ts.tv_nsec ) ) / 1000000000.0;\n    return current - start;\n}\n\n#elif defined( _WIN32 )\n\n// windows\n\n#define NOMINMAX\n#include <windows.h>\n\nvoid netcode_sleep( double time )\n{\n    int milliseconds = (int) ( time * 1000 );\n    Sleep( milliseconds );\n}\n\nstatic int timer_initialized = 0;\nstatic LARGE_INTEGER timer_frequency;\nstatic LARGE_INTEGER timer_start;\n\ndouble netcode_time()\n{\n    if ( !timer_initialized )\n    {\n        QueryPerformanceFrequency( &timer_frequency );\n        QueryPerformanceCounter( &timer_start );\n        timer_initialized = 1;\n    }\n    LARGE_INTEGER now;\n    QueryPerformanceCounter( &now );\n    return ( (double) ( now.QuadPart - timer_start.QuadPart ) ) / ( (double) ( timer_frequency.QuadPart ) );\n}\n\n#else\n\n#error unsupported platform!\n\n#endif\n\n// ---------------------------------------------------------------\n\n#if NETCODE_ENABLE_TESTS\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <time.h>\n\nstatic void check_handler( NETCODE_CONST char * condition, \n                           NETCODE_CONST char * function,\n                           NETCODE_CONST char * file,\n                           int line )\n{\n    printf( \"check failed: ( %s ), function %s, file %s, line %d\\n\", condition, function, file, line );\n#ifdef NETCODE_DEBUG\n    #if defined( __GNUC__ )\n        __builtin_trap();\n    #elif defined( _MSC_VER )\n        __debugbreak();\n    #endif\n#endif\n    exit( 1 );\n}\n\n#define check( condition )                                                                                      \\\ndo                                                                                                              \\\n{                                                                                                               \\\n    if ( !(condition) )                                                                                         \\\n    {                                                                                                           \\\n        check_handler( #condition, (NETCODE_CONST char*) __FUNCTION__, (char*) __FILE__, __LINE__ );            \\\n    }                                                                                                           \\\n} while(0)\n\nstatic void test_queue()\n{\n    struct netcode_packet_queue_t queue;\n\n    netcode_packet_queue_init( &queue, NULL, NULL, NULL );\n\n    check( queue.num_packets == 0 );\n    check( queue.start_index == 0 );\n\n    // attempting to pop a packet off an empty queue should return NULL\n\n    check( netcode_packet_queue_pop( &queue, NULL ) == NULL );\n\n    // add some packets to the queue and make sure they pop off in the correct order\n    {\n        #define NUM_PACKETS 100\n\n        void * packets[NUM_PACKETS];\n\n        int i;\n        for ( i = 0; i < NUM_PACKETS; i++ )\n        {\n            packets[i] = malloc( (i+1) * 256 );\n            check( netcode_packet_queue_push( &queue, packets[i], (uint64_t) i ) == 1 );\n        }\n\n        check( queue.num_packets == NUM_PACKETS );\n\n        for ( i = 0; i < NUM_PACKETS; i++ )\n        {\n            uint64_t sequence = 0;\n            void * packet = netcode_packet_queue_pop( &queue, &sequence );\n            check( sequence == (uint64_t) i ) ;\n            check( packet == packets[i] );\n            free( packet );\n        }\n    }\n\n    // after all entries are popped off, the queue is empty, so calls to pop should return NULL\n\n    check( queue.num_packets == 0 );\n\n    check( netcode_packet_queue_pop( &queue, NULL ) == NULL );\n\n    // test that the packet queue can be filled to max capacity\n\n    void * packets[NETCODE_PACKET_QUEUE_SIZE];\n\n    int i;\n    for ( i = 0; i < NETCODE_PACKET_QUEUE_SIZE; i++ )\n    {\n        packets[i] = malloc( i * 256 );\n        check( netcode_packet_queue_push( &queue, packets[i], (uint64_t) i ) == 1 );\n    }\n\n    check( queue.num_packets == NETCODE_PACKET_QUEUE_SIZE );\n\n    // when the queue is full, attempting to push a packet should fail and return 0\n\n    check( netcode_packet_queue_push( &queue, malloc( 100 ), 0 ) == 0 );\n\n    // make sure all packets pop off in the correct order\n\n    for ( i = 0; i < NETCODE_PACKET_QUEUE_SIZE; i++ )\n    {\n        uint64_t sequence = 0;\n        void * packet = netcode_packet_queue_pop( &queue, &sequence );\n        check( sequence == (uint64_t) i );\n        check( packet == packets[i] );\n        free( packet );\n    }\n\n    // add some packets again\n\n    for ( i = 0; i < NETCODE_PACKET_QUEUE_SIZE; i++ )\n    {\n        packets[i] = malloc( i * 256 );\n        check( netcode_packet_queue_push( &queue, packets[i], (uint64_t) i ) == 1 );\n    }\n\n    // clear the queue and make sure that all packets are freed\n\n    netcode_packet_queue_clear( &queue );\n\n    check( queue.start_index == 0 );\n    check( queue.num_packets == 0 );\n    for ( i = 0; i < NETCODE_PACKET_QUEUE_SIZE; i++ )\n        check( queue.packet_data[i] == NULL );\n}\n\nstatic void test_endian()\n{\n    uint32_t value = 0x11223344;\n\n    char * bytes = (char*) &value;\n\n#if NETCODE_LITTLE_ENDIAN\n\n    check( bytes[0] == 0x44 );\n    check( bytes[1] == 0x33 );\n    check( bytes[2] == 0x22 );\n    check( bytes[3] == 0x11 );\n\n#else // #if NETCODE_LITTLE_ENDIAN\n\n    check( bytes[3] == 0x44 );\n    check( bytes[2] == 0x33 );\n    check( bytes[1] == 0x22 );\n    check( bytes[0] == 0x11 );\n\n#endif // #if NETCODE_LITTLE_ENDIAN\n}\n\nstatic void test_sequence()\n{\n    check( netcode_sequence_number_bytes_required( 0 ) == 1 );\n    check( netcode_sequence_number_bytes_required( 0x11 ) == 1 );\n    check( netcode_sequence_number_bytes_required( 0x1122 ) == 2 );\n    check( netcode_sequence_number_bytes_required( 0x112233 ) == 3 );\n    check( netcode_sequence_number_bytes_required( 0x11223344 ) == 4 );\n    check( netcode_sequence_number_bytes_required( 0x1122334455 ) == 5 );\n    check( netcode_sequence_number_bytes_required( 0x112233445566 ) == 6 );\n    check( netcode_sequence_number_bytes_required( 0x11223344556677 ) == 7 );\n    check( netcode_sequence_number_bytes_required( 0x1122334455667788 ) == 8 );\n}\n\nstatic void test_address()\n{\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"[\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"[]\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"[]:\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \":\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"1\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"12\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"123\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"1234\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"1234.0.12313.0000\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"1234.0.12313.0000.0.0.0.0.0\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"1312313:123131:1312313:123131:1312313:123131:1312313:123131:1312313:123131:1312313:123131\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \".\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"..\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"...\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \"....\", &address ) == NETCODE_ERROR );\n        check( netcode_parse_address( \".....\", &address ) == NETCODE_ERROR );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"107.77.207.77\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV4 );\n        check( address.port == 0 );\n        check( address.data.ipv4[0] == 107 );\n        check( address.data.ipv4[1] == 77 );\n        check( address.data.ipv4[2] == 207 );\n        check( address.data.ipv4[3] == 77 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"127.0.0.1\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV4 );\n        check( address.port == 0 );\n        check( address.data.ipv4[0] == 127 );\n        check( address.data.ipv4[1] == 0 );\n        check( address.data.ipv4[2] == 0 );\n        check( address.data.ipv4[3] == 1 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"107.77.207.77:40000\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV4 );\n        check( address.port == 40000 );\n        check( address.data.ipv4[0] == 107 );\n        check( address.data.ipv4[1] == 77 );\n        check( address.data.ipv4[2] == 207 );\n        check( address.data.ipv4[3] == 77 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"127.0.0.1:40000\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV4 );\n        check( address.port == 40000 );\n        check( address.data.ipv4[0] == 127 );\n        check( address.data.ipv4[1] == 0 );\n        check( address.data.ipv4[2] == 0 );\n        check( address.data.ipv4[3] == 1 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"fe80::202:b3ff:fe1e:8329\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV6 );\n        check( address.port == 0 );\n        check( address.data.ipv6[0] == 0xfe80 );\n        check( address.data.ipv6[1] == 0x0000 );\n        check( address.data.ipv6[2] == 0x0000 );\n        check( address.data.ipv6[3] == 0x0000 );\n        check( address.data.ipv6[4] == 0x0202 );\n        check( address.data.ipv6[5] == 0xb3ff );\n        check( address.data.ipv6[6] == 0xfe1e );\n        check( address.data.ipv6[7] == 0x8329 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"::\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV6 );\n        check( address.port == 0 );\n        check( address.data.ipv6[0] == 0x0000 );\n        check( address.data.ipv6[1] == 0x0000 );\n        check( address.data.ipv6[2] == 0x0000 );\n        check( address.data.ipv6[3] == 0x0000 );\n        check( address.data.ipv6[4] == 0x0000 );\n        check( address.data.ipv6[5] == 0x0000 );\n        check( address.data.ipv6[6] == 0x0000 );\n        check( address.data.ipv6[7] == 0x0000 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"::1\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV6 );\n        check( address.port == 0 );\n        check( address.data.ipv6[0] == 0x0000 );\n        check( address.data.ipv6[1] == 0x0000 );\n        check( address.data.ipv6[2] == 0x0000 );\n        check( address.data.ipv6[3] == 0x0000 );\n        check( address.data.ipv6[4] == 0x0000 );\n        check( address.data.ipv6[5] == 0x0000 );\n        check( address.data.ipv6[6] == 0x0000 );\n        check( address.data.ipv6[7] == 0x0001 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"[fe80::202:b3ff:fe1e:8329]:40000\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV6 );\n        check( address.port == 40000 );\n        check( address.data.ipv6[0] == 0xfe80 );\n        check( address.data.ipv6[1] == 0x0000 );\n        check( address.data.ipv6[2] == 0x0000 );\n        check( address.data.ipv6[3] == 0x0000 );\n        check( address.data.ipv6[4] == 0x0202 );\n        check( address.data.ipv6[5] == 0xb3ff );\n        check( address.data.ipv6[6] == 0xfe1e );\n        check( address.data.ipv6[7] == 0x8329 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"[::]:40000\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV6 );\n        check( address.port == 40000 );\n        check( address.data.ipv6[0] == 0x0000 );\n        check( address.data.ipv6[1] == 0x0000 );\n        check( address.data.ipv6[2] == 0x0000 );\n        check( address.data.ipv6[3] == 0x0000 );\n        check( address.data.ipv6[4] == 0x0000 );\n        check( address.data.ipv6[5] == 0x0000 );\n        check( address.data.ipv6[6] == 0x0000 );\n        check( address.data.ipv6[7] == 0x0000 );\n    }\n\n    {\n        struct netcode_address_t address;\n        check( netcode_parse_address( \"[::1]:40000\", &address ) == NETCODE_OK );\n        check( address.type == NETCODE_ADDRESS_IPV6 );\n        check( address.port == 40000 );\n        check( address.data.ipv6[0] == 0x0000 );\n        check( address.data.ipv6[1] == 0x0000 );\n        check( address.data.ipv6[2] == 0x0000 );\n        check( address.data.ipv6[3] == 0x0000 );\n        check( address.data.ipv6[4] == 0x0000 );\n        check( address.data.ipv6[5] == 0x0000 );\n        check( address.data.ipv6[6] == 0x0000 );\n        check( address.data.ipv6[7] == 0x0001 );\n    }\n}\n\n#define TEST_PROTOCOL_ID            0x1122334455667788ULL\n#define TEST_CLIENT_ID              0x1ULL\n#define TEST_SERVER_PORT            40000\n#define TEST_CONNECT_TOKEN_EXPIRY   30\n#define TEST_TIMEOUT_SECONDS        15\n\nstatic void test_connect_token()\n{\n    // generate a connect token\n\n    struct netcode_address_t server_address;\n    server_address.type = NETCODE_ADDRESS_IPV4;\n    server_address.data.ipv4[0] = 127;\n    server_address.data.ipv4[1] = 0;\n    server_address.data.ipv4[2] = 0;\n    server_address.data.ipv4[3] = 1;\n    server_address.port = TEST_SERVER_PORT;\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes( user_data, NETCODE_USER_DATA_BYTES );\n\n    struct netcode_connect_token_private_t input_token;\n\n    netcode_generate_connect_token_private( &input_token, TEST_CLIENT_ID, TEST_TIMEOUT_SECONDS, 1, &server_address, user_data );\n\n    check( input_token.client_id == TEST_CLIENT_ID );\n    check( input_token.num_server_addresses == 1 );\n    check( memcmp( input_token.user_data, user_data, NETCODE_USER_DATA_BYTES ) == 0 );\n    check( netcode_address_equal( &input_token.server_addresses[0], &server_address ) );\n\n    // write it to a buffer\n\n    uint8_t buffer[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n\n    netcode_write_connect_token_private( &input_token, buffer, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    // encrypt the buffer\n\n    uint64_t expire_timestamp = time( NULL ) + 30;\n    uint8_t nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n    netcode_generate_nonce(nonce);\n    uint8_t key[NETCODE_KEY_BYTES];\n    netcode_generate_key( key );    \n\n    check( netcode_encrypt_connect_token_private( buffer, \n                                                  NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, \n                                                  NETCODE_VERSION_INFO, \n                                                  TEST_PROTOCOL_ID, \n                                                  expire_timestamp, \n                                                  nonce, \n                                                  key ) == NETCODE_OK );\n\n    // decrypt the buffer\n\n    check( netcode_decrypt_connect_token_private( buffer, \n                                                  NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, \n                                                  NETCODE_VERSION_INFO, \n                                                  TEST_PROTOCOL_ID, \n                                                  expire_timestamp, \n                                                  nonce, \n                                                  key ) == NETCODE_OK );\n\n    // read the connect token back in\n\n    struct netcode_connect_token_private_t output_token;\n\n    check( netcode_read_connect_token_private( buffer, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, &output_token ) == NETCODE_OK );\n\n    // make sure that everything matches the original connect token\n\n    check( output_token.client_id == input_token.client_id );\n    check( output_token.timeout_seconds == input_token.timeout_seconds );\n    check( output_token.num_server_addresses == input_token.num_server_addresses );\n    check( netcode_address_equal( &output_token.server_addresses[0], &input_token.server_addresses[0] ) );\n    check( memcmp( output_token.client_to_server_key, input_token.client_to_server_key, NETCODE_KEY_BYTES ) == 0 );\n    check( memcmp( output_token.server_to_client_key, input_token.server_to_client_key, NETCODE_KEY_BYTES ) == 0 );\n    check( memcmp( output_token.user_data, input_token.user_data, NETCODE_USER_DATA_BYTES ) == 0 );\n}\n\nstatic void test_challenge_token()\n{\n    // generate a challenge token\n\n    struct netcode_challenge_token_t input_token;\n\n    input_token.client_id = TEST_CLIENT_ID;\n    netcode_random_bytes( input_token.user_data, NETCODE_USER_DATA_BYTES );\n\n    // write it to a buffer\n\n    uint8_t buffer[NETCODE_CHALLENGE_TOKEN_BYTES];\n\n    netcode_write_challenge_token( &input_token, buffer, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    // encrypt the buffer\n\n    uint64_t sequence = 1000;\n    uint8_t key[NETCODE_KEY_BYTES]; \n    netcode_generate_key( key );    \n\n    check( netcode_encrypt_challenge_token( buffer, NETCODE_CHALLENGE_TOKEN_BYTES, sequence, key ) == NETCODE_OK );\n\n    // decrypt the buffer\n\n    check( netcode_decrypt_challenge_token( buffer, NETCODE_CHALLENGE_TOKEN_BYTES, sequence, key ) == NETCODE_OK );\n\n    // read the challenge token back in\n\n    struct netcode_challenge_token_t output_token;\n\n    check( netcode_read_challenge_token( buffer, NETCODE_CHALLENGE_TOKEN_BYTES, &output_token ) == NETCODE_OK );\n\n    // make sure that everything matches the original challenge token\n\n    check( output_token.client_id == input_token.client_id );\n    check( memcmp( output_token.user_data, input_token.user_data, NETCODE_USER_DATA_BYTES ) == 0 );\n}\n\nstatic void test_connection_request_packet()\n{\n    // generate a connect token\n\n    struct netcode_address_t server_address;\n    server_address.type = NETCODE_ADDRESS_IPV4;\n    server_address.data.ipv4[0] = 127;\n    server_address.data.ipv4[1] = 0;\n    server_address.data.ipv4[2] = 0;\n    server_address.data.ipv4[3] = 1;\n    server_address.port = TEST_SERVER_PORT;\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes( user_data, NETCODE_USER_DATA_BYTES );\n\n    struct netcode_connect_token_private_t input_token;\n\n    netcode_generate_connect_token_private( &input_token, TEST_CLIENT_ID, TEST_TIMEOUT_SECONDS, 1, &server_address, user_data );\n\n    check( input_token.client_id == TEST_CLIENT_ID );\n    check( input_token.num_server_addresses == 1 );\n    check( memcmp( input_token.user_data, user_data, NETCODE_USER_DATA_BYTES ) == 0 );\n    check( netcode_address_equal( &input_token.server_addresses[0], &server_address ) );\n\n    // write the conect token to a buffer (non-encrypted)\n\n    uint8_t connect_token_data[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n\n    netcode_write_connect_token_private( &input_token, connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    // copy to a second buffer then encrypt it in place (we need the unencrypted token for verification later on)\n\n    uint8_t encrypted_connect_token_data[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n\n    memcpy( encrypted_connect_token_data, connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    uint64_t connect_token_expire_timestamp = time( NULL ) + 30;\n    uint8_t connect_token_nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n    netcode_generate_nonce(connect_token_nonce);\n    uint8_t connect_token_key[NETCODE_KEY_BYTES];\n    netcode_generate_key( connect_token_key );\n\n    check( netcode_encrypt_connect_token_private( encrypted_connect_token_data, \n                                                  NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, \n                                                  NETCODE_VERSION_INFO, \n                                                  TEST_PROTOCOL_ID, \n                                                  connect_token_expire_timestamp, \n                                                  connect_token_nonce, \n                                                  connect_token_key ) == NETCODE_OK );\n\n    // setup a connection request packet wrapping the encrypted connect token\n\n    struct netcode_connection_request_packet_t input_packet;\n\n    input_packet.packet_type = NETCODE_CONNECTION_REQUEST_PACKET;\n    memcpy( input_packet.version_info, NETCODE_VERSION_INFO, NETCODE_VERSION_INFO_BYTES );\n    input_packet.protocol_id = TEST_PROTOCOL_ID;\n    input_packet.connect_token_expire_timestamp = connect_token_expire_timestamp;\n    memcpy( input_packet.connect_token_nonce, connect_token_nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n    memcpy( input_packet.connect_token_data, encrypted_connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    // write the connection request packet to a buffer\n\n    uint8_t buffer[2048];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n\n    int bytes_written = netcode_write_packet( &input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the connection request packet back in from the buffer (the connect token data is decrypted as part of the read packet validation)\n\n    uint64_t sequence = 1000;\n\n    uint8_t allowed_packets[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packets, 1, sizeof( allowed_packets ) );\n\n    struct netcode_connection_request_packet_t * output_packet = (struct netcode_connection_request_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), connect_token_key, allowed_packets, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_REQUEST_PACKET );\n    check( memcmp( output_packet->version_info, input_packet.version_info, NETCODE_VERSION_INFO_BYTES ) == 0 );\n    check( output_packet->protocol_id == input_packet.protocol_id );\n    check( output_packet->connect_token_expire_timestamp == input_packet.connect_token_expire_timestamp );\n    check( memcmp( output_packet->connect_token_nonce, input_packet.connect_token_nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES ) == 0 );\n    check( memcmp( output_packet->connect_token_data, connect_token_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES - NETCODE_MAC_BYTES ) == 0 );\n\n    free( output_packet );\n}\n\nvoid test_connection_denied_packet()\n{\n    // setup a connection denied packet\n\n    struct netcode_connection_denied_packet_t input_packet;\n\n    input_packet.packet_type = NETCODE_CONNECTION_DENIED_PACKET;\n\n    // write the packet to a buffer\n\n    uint8_t buffer[NETCODE_MAX_PACKET_BYTES];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n\n    int bytes_written = netcode_write_packet( &input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the packet back in from the buffer\n\n    uint64_t sequence;\n\n    uint8_t allowed_packet_types[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packet_types, 1, sizeof( allowed_packet_types ) );\n\n    struct netcode_connection_denied_packet_t * output_packet = (struct netcode_connection_denied_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), NULL, allowed_packet_types, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_DENIED_PACKET );\n\n    free( output_packet );\n}\n\nvoid test_connection_challenge_packet()\n{\n    // setup a connection challenge packet\n\n    struct netcode_connection_challenge_packet_t input_packet;\n\n    input_packet.packet_type = NETCODE_CONNECTION_CHALLENGE_PACKET;\n    input_packet.challenge_token_sequence = 0;\n    netcode_random_bytes( input_packet.challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    // write the packet to a buffer\n\n    uint8_t buffer[NETCODE_MAX_PACKET_BYTES];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n\n    int bytes_written = netcode_write_packet( &input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the packet back in from the buffer\n\n    uint64_t sequence;\n\n    uint8_t allowed_packet_types[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packet_types, 1, sizeof( allowed_packet_types ) );\n\n    struct netcode_connection_challenge_packet_t * output_packet = (struct netcode_connection_challenge_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), NULL, allowed_packet_types, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_CHALLENGE_PACKET );\n    check( output_packet->challenge_token_sequence == input_packet.challenge_token_sequence );\n    check( memcmp( output_packet->challenge_token_data, input_packet.challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES ) == 0 );\n\n    free( output_packet );\n}\n\nvoid test_connection_response_packet()\n{\n    // setup a connection response packet\n\n    struct netcode_connection_response_packet_t input_packet;\n\n    input_packet.packet_type = NETCODE_CONNECTION_RESPONSE_PACKET;\n    input_packet.challenge_token_sequence = 0;\n    netcode_random_bytes( input_packet.challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES );\n\n    // write the packet to a buffer\n\n    uint8_t buffer[NETCODE_MAX_PACKET_BYTES];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n    \n    int bytes_written = netcode_write_packet( &input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the packet back in from the buffer\n\n    uint64_t sequence;\n\n    uint8_t allowed_packet_types[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packet_types, 1, sizeof( allowed_packet_types ) );\n\n    struct netcode_connection_response_packet_t * output_packet = (struct netcode_connection_response_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), NULL, allowed_packet_types, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_RESPONSE_PACKET );\n    check( output_packet->challenge_token_sequence == input_packet.challenge_token_sequence );\n    check( memcmp( output_packet->challenge_token_data, input_packet.challenge_token_data, NETCODE_CHALLENGE_TOKEN_BYTES ) == 0 );\n\n    free( output_packet );\n}\n\nvoid test_connection_keep_alive_packet()\n{\n    // setup a connection keep alive packet\n\n    struct netcode_connection_keep_alive_packet_t input_packet;\n\n    input_packet.packet_type = NETCODE_CONNECTION_KEEP_ALIVE_PACKET;\n    input_packet.client_index = 10;\n    input_packet.max_clients = 16;\n\n    // write the packet to a buffer\n\n    uint8_t buffer[NETCODE_MAX_PACKET_BYTES];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n\n    int bytes_written = netcode_write_packet( &input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the packet back in from the buffer\n\n    uint64_t sequence;\n\n    uint8_t allowed_packet_types[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packet_types, 1, sizeof( allowed_packet_types ) );\n    \n    struct netcode_connection_keep_alive_packet_t * output_packet = (struct netcode_connection_keep_alive_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), NULL, allowed_packet_types, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_KEEP_ALIVE_PACKET );\n    check( output_packet->client_index == input_packet.client_index );\n    check( output_packet->max_clients == input_packet.max_clients );\n\n    free( output_packet );\n}\n\nvoid test_connection_payload_packet()\n{\n    // setup a connection payload packet\n\n    struct netcode_connection_payload_packet_t * input_packet = netcode_create_payload_packet( NETCODE_MAX_PAYLOAD_BYTES, NULL, NULL );\n\n    check( input_packet->packet_type == NETCODE_CONNECTION_PAYLOAD_PACKET );\n    check( input_packet->payload_bytes == NETCODE_MAX_PAYLOAD_BYTES );\n\n    netcode_random_bytes( input_packet->payload_data, NETCODE_MAX_PAYLOAD_BYTES );\n    \n    // write the packet to a buffer\n\n    uint8_t buffer[NETCODE_MAX_PACKET_BYTES];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n\n    int bytes_written = netcode_write_packet( input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the packet back in from the buffer\n\n    uint64_t sequence;\n\n    uint8_t allowed_packet_types[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packet_types, 1, sizeof( allowed_packet_types ) );\n\n    struct netcode_connection_payload_packet_t * output_packet = (struct netcode_connection_payload_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), NULL, allowed_packet_types, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_PAYLOAD_PACKET );\n    check( output_packet->payload_bytes == input_packet->payload_bytes );\n    check( memcmp( output_packet->payload_data, input_packet->payload_data, NETCODE_MAX_PAYLOAD_BYTES ) == 0 );\n\n    free( input_packet );\n    free( output_packet );\n}\n\nvoid test_connection_disconnect_packet()\n{\n    // setup a connection disconnect packet\n\n    struct netcode_connection_disconnect_packet_t input_packet;\n\n    input_packet.packet_type = NETCODE_CONNECTION_DISCONNECT_PACKET;\n\n    // write the packet to a buffer\n\n    uint8_t buffer[NETCODE_MAX_PACKET_BYTES];\n\n    uint8_t packet_key[NETCODE_KEY_BYTES];\n\n    netcode_generate_key( packet_key );\n\n    int bytes_written = netcode_write_packet( &input_packet, buffer, sizeof( buffer ), 1000, packet_key, TEST_PROTOCOL_ID );\n\n    check( bytes_written > 0 );\n\n    // read the packet back in from the buffer\n\n    uint64_t sequence;\n\n    uint8_t allowed_packet_types[NETCODE_CONNECTION_NUM_PACKETS];\n    memset( allowed_packet_types, 1, sizeof( allowed_packet_types ) );\n\n    struct netcode_connection_disconnect_packet_t * output_packet = (struct netcode_connection_disconnect_packet_t*) \n        netcode_read_packet( buffer, bytes_written, &sequence, packet_key, TEST_PROTOCOL_ID, time( NULL ), NULL, allowed_packet_types, NULL, NULL, NULL );\n\n    check( output_packet );\n\n    // make sure the read packet matches what was written\n    \n    check( output_packet->packet_type == NETCODE_CONNECTION_DISCONNECT_PACKET );\n\n    free( output_packet );\n}\n\nvoid test_connect_token_public()\n{\n    // generate a private connect token\n\n    struct netcode_address_t server_address;\n    server_address.type = NETCODE_ADDRESS_IPV4;\n    server_address.data.ipv4[0] = 127;\n    server_address.data.ipv4[1] = 0;\n    server_address.data.ipv4[2] = 0;\n    server_address.data.ipv4[3] = 1;\n    server_address.port = TEST_SERVER_PORT;\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes( user_data, NETCODE_USER_DATA_BYTES );\n\n    struct netcode_connect_token_private_t connect_token_private;\n\n    netcode_generate_connect_token_private( &connect_token_private, TEST_CLIENT_ID, TEST_TIMEOUT_SECONDS, 1, &server_address, user_data );\n\n    check( connect_token_private.client_id == TEST_CLIENT_ID );\n    check( connect_token_private.num_server_addresses == 1 );\n    check( memcmp( connect_token_private.user_data, user_data, NETCODE_USER_DATA_BYTES ) == 0 );\n    check( netcode_address_equal( &connect_token_private.server_addresses[0], &server_address ) );\n\n    // write it to a buffer\n\n    uint8_t connect_token_private_data[NETCODE_CONNECT_TOKEN_PRIVATE_BYTES];\n    netcode_write_connect_token_private( &connect_token_private, connect_token_private_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n\n    // encrypt the buffer\n\n    uint64_t create_timestamp = time( NULL );\n    uint64_t expire_timestamp = create_timestamp + 30;\n    uint8_t connect_token_nonce[NETCODE_CONNECT_TOKEN_NONCE_BYTES];\n    netcode_generate_nonce( connect_token_nonce );    \n    uint8_t key[NETCODE_KEY_BYTES];\n    netcode_generate_key( key );    \n    check( netcode_encrypt_connect_token_private( connect_token_private_data, \n                                                  NETCODE_CONNECT_TOKEN_PRIVATE_BYTES, \n                                                  NETCODE_VERSION_INFO, \n                                                  TEST_PROTOCOL_ID, \n                                                  expire_timestamp, \n                                                  connect_token_nonce, \n                                                  key ) == 1 );\n\n    // wrap a public connect token around the private connect token data\n\n    struct netcode_connect_token_t input_connect_token;\n    memset( &input_connect_token, 0, sizeof( struct netcode_connect_token_t ) );\n    memcpy( input_connect_token.version_info, NETCODE_VERSION_INFO, NETCODE_VERSION_INFO_BYTES );\n    input_connect_token.protocol_id = TEST_PROTOCOL_ID;\n    input_connect_token.create_timestamp = create_timestamp;\n    input_connect_token.expire_timestamp = expire_timestamp;\n    memcpy( input_connect_token.nonce, connect_token_nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES );\n    memcpy( input_connect_token.private_data, connect_token_private_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES );\n    input_connect_token.num_server_addresses = 1;\n    input_connect_token.server_addresses[0] = server_address;\n    memcpy( input_connect_token.client_to_server_key, connect_token_private.client_to_server_key, NETCODE_KEY_BYTES );\n    memcpy( input_connect_token.server_to_client_key, connect_token_private.server_to_client_key, NETCODE_KEY_BYTES );\n    input_connect_token.timeout_seconds = (int) TEST_TIMEOUT_SECONDS;\n\n    // write the connect token to a buffer\n\n    uint8_t buffer[NETCODE_CONNECT_TOKEN_BYTES];\n    netcode_write_connect_token( &input_connect_token, buffer, NETCODE_CONNECT_TOKEN_BYTES );\n\n    // read the buffer back in\n\n    struct netcode_connect_token_t output_connect_token;\n    memset( &output_connect_token, 0, sizeof( struct netcode_connect_token_t ) );\n    check( netcode_read_connect_token( buffer, NETCODE_CONNECT_TOKEN_BYTES, &output_connect_token ) == 1 );\n\n    // make sure the public connect token matches what was written\n\n    check( memcmp( output_connect_token.version_info, input_connect_token.version_info, NETCODE_VERSION_INFO_BYTES ) == 0 );\n    check( output_connect_token.protocol_id == input_connect_token.protocol_id );\n    check( output_connect_token.create_timestamp == input_connect_token.create_timestamp );\n    check( output_connect_token.expire_timestamp == input_connect_token.expire_timestamp );\n    check( memcmp( output_connect_token.nonce, input_connect_token.nonce, NETCODE_CONNECT_TOKEN_NONCE_BYTES ) == 0 );\n    check( memcmp( output_connect_token.private_data, input_connect_token.private_data, NETCODE_CONNECT_TOKEN_PRIVATE_BYTES ) == 0 );\n    check( output_connect_token.num_server_addresses == input_connect_token.num_server_addresses );\n    check( netcode_address_equal( &output_connect_token.server_addresses[0], &input_connect_token.server_addresses[0] ) );\n    check( memcmp( output_connect_token.client_to_server_key, input_connect_token.client_to_server_key, NETCODE_KEY_BYTES ) == 0 );\n    check( memcmp( output_connect_token.server_to_client_key, input_connect_token.server_to_client_key, NETCODE_KEY_BYTES ) == 0 );\n    check( output_connect_token.timeout_seconds == input_connect_token.timeout_seconds );\n}\n\nvoid test_encryption_manager()\n{\n    struct netcode_encryption_manager_t encryption_manager;\n\n    netcode_encryption_manager_reset( &encryption_manager );\n\n    double time = 100.0;\n\n    // generate some test encryption mappings\n\n    struct encryption_mapping_t\n    {\n        struct netcode_address_t address;\n        uint8_t send_key[NETCODE_KEY_BYTES];\n        uint8_t receive_key[NETCODE_KEY_BYTES];\n    };\n\n    #define NUM_ENCRYPTION_MAPPINGS 5\n\n    struct encryption_mapping_t encryption_mapping[NUM_ENCRYPTION_MAPPINGS];\n    memset( encryption_mapping, 0, sizeof( encryption_mapping ) );\n    int i;\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        encryption_mapping[i].address.type = NETCODE_ADDRESS_IPV6;\n        encryption_mapping[i].address.data.ipv6[7] = 1;\n        encryption_mapping[i].address.port = ( uint16_t) ( 20000 + i );\n        netcode_generate_key( encryption_mapping[i].send_key );\n        netcode_generate_key( encryption_mapping[i].receive_key );\n    }\n\n    // add the encryption mappings to the manager and make sure they can be looked up by address\n\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        check( encryption_index == -1 );\n\n        check( netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index ) == NULL );\n        check( netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index ) == NULL );\n\n        check( netcode_encryption_manager_add_encryption_mapping( &encryption_manager, \n                                                                  &encryption_mapping[i].address, \n                                                                  encryption_mapping[i].send_key, \n                                                                  encryption_mapping[i].receive_key, \n                                                                  time, \n                                                                  -1.0,\n                                                                  TEST_TIMEOUT_SECONDS ) );\n\n        encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        uint8_t * send_key = netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index );\n        uint8_t * receive_key = netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index );\n\n        check( send_key );\n        check( receive_key );\n\n        check( memcmp( send_key, encryption_mapping[i].send_key, NETCODE_KEY_BYTES ) == 0 );\n        check( memcmp( receive_key, encryption_mapping[i].receive_key, NETCODE_KEY_BYTES ) == 0 );\n    }\n\n    // removing an encryption mapping that doesn't exist should return 0\n    {\n        struct netcode_address_t address;\n        address.type = NETCODE_ADDRESS_IPV6;\n        address.data.ipv6[7] = 1;\n        address.port = 50000;\n\n        check( netcode_encryption_manager_remove_encryption_mapping( &encryption_manager, &address, time ) == 0 );\n    }\n\n    // remove the first and last encryption mappings\n\n    check( netcode_encryption_manager_remove_encryption_mapping( &encryption_manager, &encryption_mapping[0].address, time ) == 1 );\n\n    check( netcode_encryption_manager_remove_encryption_mapping( &encryption_manager, &encryption_mapping[NUM_ENCRYPTION_MAPPINGS-1].address, time ) == 1 );\n\n    // make sure the encryption mappings that were removed can no longer be looked up by address\n\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        uint8_t * send_key = netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index );\n        uint8_t * receive_key = netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index );\n\n        if ( i != 0 && i != NUM_ENCRYPTION_MAPPINGS - 1 )\n        {\n            check( send_key );\n            check( receive_key );\n\n            check( memcmp( send_key, encryption_mapping[i].send_key, NETCODE_KEY_BYTES ) == 0 );\n            check( memcmp( receive_key, encryption_mapping[i].receive_key, NETCODE_KEY_BYTES ) == 0 );\n        }\n        else\n        {\n            check( !send_key );\n            check( !receive_key );\n        }\n    }\n\n    // add the encryption mappings back in\n    \n    check( netcode_encryption_manager_add_encryption_mapping( &encryption_manager, \n                                                              &encryption_mapping[0].address, \n                                                              encryption_mapping[0].send_key, \n                                                              encryption_mapping[0].receive_key, \n                                                              time, \n                                                              -1.0,\n                                                              TEST_TIMEOUT_SECONDS ) );\n    \n    check( netcode_encryption_manager_add_encryption_mapping( &encryption_manager, \n                                                              &encryption_mapping[NUM_ENCRYPTION_MAPPINGS-1].address, \n                                                              encryption_mapping[NUM_ENCRYPTION_MAPPINGS-1].send_key, \n                                                              encryption_mapping[NUM_ENCRYPTION_MAPPINGS-1].receive_key, \n                                                              time, \n                                                              -1.0,\n                                                              TEST_TIMEOUT_SECONDS ) );\n\n    // all encryption mappings should be able to be looked up by address again\n\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        uint8_t * send_key = netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index );\n        uint8_t * receive_key = netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index );\n\n        check( send_key );\n        check( receive_key );\n\n        check( memcmp( send_key, encryption_mapping[i].send_key, NETCODE_KEY_BYTES ) == 0 );\n        check( memcmp( receive_key, encryption_mapping[i].receive_key, NETCODE_KEY_BYTES ) == 0 );\n    }\n\n    // check that encryption mappings time out properly\n\n    time += TEST_TIMEOUT_SECONDS * 2;\n\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        uint8_t * send_key = netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index );\n        uint8_t * receive_key = netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index );\n\n        check( !send_key );\n        check( !receive_key );\n    }\n\n    // add the same encryption mappings after timeout\n\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        check( encryption_index == -1 );\n\n        check( netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index ) == NULL );\n        check( netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index ) == NULL );\n\n        check( netcode_encryption_manager_add_encryption_mapping( &encryption_manager, \n                                                                  &encryption_mapping[i].address, \n                                                                  encryption_mapping[i].send_key, \n                                                                  encryption_mapping[i].receive_key, \n                                                                  time, \n                                                                  -1.0,\n                                                                  TEST_TIMEOUT_SECONDS ) );\n\n        encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        uint8_t * send_key = netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index );\n        uint8_t * receive_key = netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index );\n\n        check( send_key );\n        check( receive_key );\n\n        check( memcmp( send_key, encryption_mapping[i].send_key, NETCODE_KEY_BYTES ) == 0 );\n        check( memcmp( receive_key, encryption_mapping[i].receive_key, NETCODE_KEY_BYTES ) == 0 );\n    }\n\n    // reset the encryption mapping and verify that all encryption mappings have been removed\n\n    netcode_encryption_manager_reset( &encryption_manager );\n\n    for ( i = 0; i < NUM_ENCRYPTION_MAPPINGS; i++ )\n    {\n        int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[i].address, time );\n\n        uint8_t * send_key = netcode_encryption_manager_get_send_key( &encryption_manager, encryption_index );\n        uint8_t * receive_key = netcode_encryption_manager_get_receive_key( &encryption_manager, encryption_index );\n\n        check( !send_key );\n        check( !receive_key );\n    }\n\n    // test the expire time for encryption mapping works as expected\n\n    check( netcode_encryption_manager_add_encryption_mapping( &encryption_manager, \n                                                              &encryption_mapping[0].address, \n                                                              encryption_mapping[0].send_key, \n                                                              encryption_mapping[0].receive_key, \n                                                              time, \n                                                              time + 1.0,\n                                                              TEST_TIMEOUT_SECONDS ) );\n\n    int encryption_index = netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[0].address, time );\n\n    check( encryption_index != -1 );\n\n    check( netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[0].address, time + 1.1f ) == -1 );\n\n    netcode_encryption_manager_set_expire_time( &encryption_manager, encryption_index, -1.0 );\n\n    check( netcode_encryption_manager_find_encryption_mapping( &encryption_manager, &encryption_mapping[0].address, time ) == encryption_index );\n}\n\nvoid test_replay_protection()\n{\n    struct netcode_replay_protection_t replay_protection;\n\n    int i;\n    for ( i = 0; i < 2; i++ )\n    {\n        netcode_replay_protection_reset( &replay_protection );\n\n        check( replay_protection.most_recent_sequence == 0 );\n\n        // the first time we receive packets, they should not be already received\n\n        #define MAX_SEQUENCE ( NETCODE_REPLAY_PROTECTION_BUFFER_SIZE * 4 )\n\n        uint64_t sequence;\n        for ( sequence = 0; sequence < MAX_SEQUENCE; ++sequence )\n        {\n            check( netcode_replay_protection_already_received( &replay_protection, sequence ) == 0 );\n            netcode_replay_protection_advance_sequence( &replay_protection, sequence );\n        }\n\n        // old packets outside buffer should be considered already received\n\n        check( netcode_replay_protection_already_received( &replay_protection, 0 ) == 1 );\n\n        // packets received a second time should be flagged already received\n\n        for ( sequence = MAX_SEQUENCE - 10; sequence < MAX_SEQUENCE; ++sequence )\n        {\n            check( netcode_replay_protection_already_received( &replay_protection, sequence ) == 1 );\n        }\n\n        // jumping ahead to a much higher sequence should be considered not already received\n\n        check( netcode_replay_protection_already_received( &replay_protection, MAX_SEQUENCE + NETCODE_REPLAY_PROTECTION_BUFFER_SIZE ) == 0 );\n\n        // old packets should be considered already received\n\n        for ( sequence = 0; sequence < MAX_SEQUENCE; ++sequence )\n        {\n            check( netcode_replay_protection_already_received( &replay_protection, sequence ) == 1 );\n        }\n    }\n}\n\nvoid test_client_create()\n{\n    {\n        struct netcode_client_config_t client_config;\n        netcode_default_client_config( &client_config );\n\n        struct netcode_client_t * client = netcode_client_create( \"127.0.0.1:40000\", &client_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"127.0.0.1:40000\", &test_address );\n\n        check( client );\n        check( client->socket_holder.ipv4.handle != 0 );\n        check( client->socket_holder.ipv6.handle == 0 );\n        check( netcode_address_equal( &client->address, &test_address ) );\n\n        netcode_client_destroy( client );\n    }\n\n    {\n        struct netcode_client_config_t client_config;\n        netcode_default_client_config( &client_config );\n\n        struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"[::]:50000\", &test_address );\n\n        check( client );\n        check( client->socket_holder.ipv4.handle == 0 );\n        check( client->socket_holder.ipv6.handle != 0 );\n        check( netcode_address_equal( &client->address, &test_address ) );\n\n        netcode_client_destroy( client );\n    }\n\n    {\n        struct netcode_client_config_t client_config;\n        netcode_default_client_config( &client_config );\n\n        struct netcode_client_t * client = netcode_client_create_overload( \"127.0.0.1:40000\", \"[::]:50000\", &client_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"127.0.0.1:40000\", &test_address );\n\n        check( client );\n        check( client->socket_holder.ipv4.handle != 0 );\n        check( client->socket_holder.ipv6.handle != 0 );\n        check( netcode_address_equal( &client->address, &test_address ) );\n\n        netcode_client_destroy( client );\n    }\n\n    {\n        struct netcode_client_config_t client_config;\n        netcode_default_client_config( &client_config );\n\n        struct netcode_client_t * client = netcode_client_create_overload( \"[::]:50000\", \"127.0.0.1:40000\", &client_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"[::]:50000\", &test_address );\n\n        check( client );\n        check( client->socket_holder.ipv4.handle != 0 );\n        check( client->socket_holder.ipv6.handle != 0 );\n        check( netcode_address_equal( &client->address, &test_address ) );\n\n        netcode_client_destroy( client );\n    }\n}\n\nvoid test_server_create()\n{\n    {\n        struct netcode_server_config_t server_config;\n        netcode_default_server_config( &server_config );\n\n        struct netcode_server_t * server = netcode_server_create( \"127.0.0.1:40000\", &server_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"127.0.0.1:40000\", &test_address );\n\n        check( server );\n        check( server->socket_holder.ipv4.handle != 0 );\n        check( server->socket_holder.ipv6.handle == 0 );\n        check( netcode_address_equal( &server->address, &test_address ) );\n\n        netcode_server_destroy( server );\n    }\n\n    {\n        struct netcode_server_config_t server_config;\n        netcode_default_server_config( &server_config );\n\n        struct netcode_server_t * server = netcode_server_create( \"[::1]:50000\", &server_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"[::1]:50000\", &test_address );\n\n        check( server );\n        check( server->socket_holder.ipv4.handle == 0 );\n        check( server->socket_holder.ipv6.handle != 0 );\n        check( netcode_address_equal( &server->address, &test_address ) );\n\n        netcode_server_destroy( server );\n    }\n\n    {\n        struct netcode_server_config_t server_config;\n        netcode_default_server_config( &server_config );\n\n        struct netcode_server_t * server = netcode_server_create_overload( \"127.0.0.1:40000\", \"[::1]:50000\", &server_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"127.0.0.1:40000\", &test_address );\n\n        check( server );\n        check( server->socket_holder.ipv4.handle != 0 );\n        check( server->socket_holder.ipv6.handle != 0 );\n        check( netcode_address_equal( &server->address, &test_address ) );\n\n        netcode_server_destroy( server );\n    }\n\n    {\n        struct netcode_server_config_t server_config;\n        netcode_default_server_config( &server_config );\n\n        struct netcode_server_t * server = netcode_server_create_overload( \"[::1]:50000\", \"127.0.0.1:40000\", &server_config, 0.0 );\n\n        struct netcode_address_t test_address;\n        netcode_parse_address( \"[::1]:50000\", &test_address );\n\n        check( server );\n        check( server->socket_holder.ipv4.handle != 0 );\n        check( server->socket_holder.ipv6.handle != 0 );\n        check( netcode_address_equal( &server->address, &test_address ) );\n\n        netcode_server_destroy( server );\n    }\n}\n\nstatic uint8_t private_key[NETCODE_KEY_BYTES] = { 0x60, 0x6a, 0xbe, 0x6e, 0xc9, 0x19, 0x10, 0xea, \n                                                  0x9a, 0x65, 0x62, 0xf6, 0x6f, 0x2b, 0x30, 0xe4, \n                                                  0x43, 0x71, 0xd6, 0x2c, 0xd1, 0x99, 0x27, 0x26,\n                                                  0x6b, 0x3c, 0x60, 0xf4, 0xb7, 0x15, 0xab, 0xa1 };\n\nvoid test_client_server_connect()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    int server_num_packets_received = 0;\n    int client_num_packets_received = 0;\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; i++ )\n        packet_data[i] = (uint8_t) i;\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        netcode_client_send_packet( client, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            client_num_packets_received++;\n            netcode_client_free_packet( client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 0, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        if ( client_num_packets_received >= 10 && server_num_packets_received >= 10 )\n        {\n            if ( netcode_server_client_connected( server, 0 ) )\n            {\n                netcode_server_disconnect_client( server, 0 );\n            }\n        }\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( client_num_packets_received >= 10 && server_num_packets_received >= 10 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid client_server_socket_connect( NETCODE_CONST char * client_address, NETCODE_CONST char * client_address2, NETCODE_CONST char * server_address, NETCODE_CONST char * server_address2 )\n{\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n\n    struct netcode_client_t * client = netcode_client_create_overload( client_address, client_address2, &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create_overload( server_address, server_address2, &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n}\n\nvoid test_client_server_ipv4_socket_connect()\n{\n    client_server_socket_connect(\"0.0.0.0:50000\", NULL        , \"127.0.0.1:40000\", NULL         );\n    client_server_socket_connect(\"0.0.0.0:50000\", NULL        , \"127.0.0.1:40000\", \"[::1]:40000\");\n    client_server_socket_connect(\"0.0.0.0:50000\", \"[::]:50000\", \"127.0.0.1:40000\", NULL         );\n    client_server_socket_connect(\"0.0.0.0:50000\", \"[::]:50000\", \"127.0.0.1:40000\", \"[::1]:40000\");\n}\n\nvoid test_client_server_ipv6_socket_connect()\n{\n    client_server_socket_connect(\"[::]:50000\"   , NULL        , \"[::1]:40000\", NULL             );\n    client_server_socket_connect(\"[::]:50000\"   , NULL        , \"[::1]:40000\", \"127.0.0.1:40000\");\n    client_server_socket_connect(\"0.0.0.0:50000\", \"[::]:50000\", \"[::1]:40000\", NULL             );\n    client_server_socket_connect(\"0.0.0.0:50000\", \"[::]:50000\", \"[::1]:40000\", \"127.0.0.1:40000\");\n}\n\nvoid test_client_server_keep_alive()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    // connect client to server\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // pump the client and server long enough that they would timeout without keep alive packets\n\n    int num_iterations = (int) ( 1.25f * TEST_TIMEOUT_SECONDS / delta_time ) + 1;\n\n    int i;\n    for ( i = 0; i < num_iterations; i++ )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_server_multiple_clients()\n{\n    #define NUM_START_STOP_ITERATIONS 3\n\n    int max_clients[NUM_START_STOP_ITERATIONS] = { 2, 32, 5 };\n\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    int i;\n    for ( i = 0; i < NUM_START_STOP_ITERATIONS; i++ )\n    {\n        // start the server with max # of clients for this iteration\n\n        netcode_server_start( server, max_clients[i] );\n\n        // create # of client objects for this iteration and connect to server\n\n        struct netcode_client_t ** client = (struct netcode_client_t **) malloc( sizeof( struct netcode_client_t* ) * max_clients[i] );\n\n        check( client );\n\n        int j;\n        for ( j = 0; j < max_clients[i]; j++ )\n        {\n            char client_address[NETCODE_MAX_ADDRESS_STRING_LENGTH];\n            snprintf( client_address, sizeof(client_address), \"[::]:%d\", 50000 + j );\n\n            struct netcode_client_config_t client_config;\n            netcode_default_client_config( &client_config );\n            client_config.network_simulator = network_simulator;\n\n            client[j] = netcode_client_create( client_address, &client_config, time );\n\n            check( client[j] );\n\n            uint64_t client_id = j;\n            netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n            NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n            uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n            uint8_t user_data[NETCODE_USER_DATA_BYTES];\n            netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n            check( netcode_generate_connect_token( 1, \n                                                   &server_address, \n                                                   &server_address, \n                                                   TEST_CONNECT_TOKEN_EXPIRY, \n                                                   TEST_TIMEOUT_SECONDS,\n                                                   client_id, \n                                                   TEST_PROTOCOL_ID, \n                                                   private_key, \n                                                   user_data, \n                                                   connect_token ) );\n\n            netcode_client_connect( client[j], connect_token );\n        }\n\n        // make sure all clients can connect\n\n        while ( 1 )\n        {\n            netcode_network_simulator_update( network_simulator, time );\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                netcode_client_update( client[j], time );\n            }\n\n            netcode_server_update( server, time );\n\n            int num_connected_clients = 0;\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                if ( netcode_client_state( client[j] ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n                    break;\n\n                if ( netcode_client_state( client[j] ) == NETCODE_CLIENT_STATE_CONNECTED )\n                    num_connected_clients++;\n            }\n\n            if ( num_connected_clients == max_clients[i] )\n                break;\n\n            time += delta_time;\n        }\n\n        check( netcode_server_num_connected_clients( server ) == max_clients[i] );\n\n        for ( j = 0; j < max_clients[i]; j++ )\n        {\n            check( netcode_client_state( client[j] ) == NETCODE_CLIENT_STATE_CONNECTED );\n            check( netcode_server_client_connected( server, j ) == 1 );\n        }\n\n        // make sure all clients can exchange packets with the server\n\n        int * server_num_packets_received = (int*) malloc( sizeof(int) * max_clients[i] );\n        int * client_num_packets_received = (int*) malloc( sizeof(int) * max_clients[i] );\n\n        memset( server_num_packets_received, 0, sizeof(int) * max_clients[i] );\n        memset( client_num_packets_received, 0, sizeof(int) * max_clients[i] );\n\n        uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n        for ( j = 0; j < NETCODE_MAX_PACKET_SIZE; j++ )\n            packet_data[j] = (uint8_t) j;\n\n        while ( 1 )\n        {\n            netcode_network_simulator_update( network_simulator, time );\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                netcode_client_update( client[j], time );\n            }\n\n            netcode_server_update( server, time );\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                netcode_client_send_packet( client[j], packet_data, NETCODE_MAX_PACKET_SIZE );\n            }\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                netcode_server_send_packet( server, j, packet_data, NETCODE_MAX_PACKET_SIZE );\n            }\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                while ( 1 )             \n                {\n                    int packet_bytes;\n                    uint64_t packet_sequence;\n                    uint8_t * packet = netcode_client_receive_packet( client[j], &packet_bytes, &packet_sequence );\n                    if ( !packet )\n                        break;\n                    (void) packet_sequence;\n                    netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n                    netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n                    client_num_packets_received[j]++;\n                    netcode_client_free_packet( client[j], packet );\n                }\n            }\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                while ( 1 )             \n                {\n                    int packet_bytes;\n                    uint64_t packet_sequence;\n                    void * packet = netcode_server_receive_packet( server, j, &packet_bytes, &packet_sequence );\n                    if ( !packet )\n                        break;\n                    (void) packet_sequence;\n                    netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n                    netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n                    server_num_packets_received[j]++;\n                    netcode_server_free_packet( server, packet );\n                }\n            }\n\n            int num_clients_ready = 0;\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                if ( client_num_packets_received[j] >= 1 && server_num_packets_received[j] >= 1 )\n                {\n                    num_clients_ready++;\n                }\n            }\n\n            if ( num_clients_ready == max_clients[i] )\n                break;\n\n            for ( j = 0; j < max_clients[i]; j++ )\n            {\n                if ( netcode_client_state( client[j] ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n                    break;\n            }\n\n            time += delta_time;\n        }\n\n        int num_clients_ready = 0;\n\n        for ( j = 0; j < max_clients[i]; j++ )\n        {\n            if ( client_num_packets_received[j] >= 1 && server_num_packets_received[j] >= 1 )\n            {\n                num_clients_ready++;\n            }\n        }\n\n        check( num_clients_ready == max_clients[i] );\n\n        free( server_num_packets_received );\n        free( client_num_packets_received );\n        \n        netcode_network_simulator_reset( network_simulator );\n\n        for ( j = 0; j < max_clients[i]; j++ )\n        {\n            netcode_client_destroy( client[j] );\n        }\n\n        free( client );\n\n        netcode_server_stop( server );\n    }\n\n    netcode_server_destroy( server );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_server_multiple_servers()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address[] = { \"10.10.10.10:1000\", \"100.100.100.100:50000\", \"[::1]:40000\" };\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 3, server_address, server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    int server_num_packets_received = 0;\n    int client_num_packets_received = 0;\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; i++ )\n        packet_data[i] = (uint8_t) i;\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        netcode_client_send_packet( client, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            client_num_packets_received++;\n            netcode_client_free_packet( client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 0, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        if ( client_num_packets_received >= 10 && server_num_packets_received >= 10 )\n        {\n            if ( netcode_server_client_connected( server, 0 ) )\n            {\n                netcode_server_disconnect_client( server, 0 );\n            }\n        }\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( client_num_packets_received >= 10 && server_num_packets_received >= 10 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_error_connect_token_expired()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, 0, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    netcode_client_update( client, time );\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_error_invalid_connect_token()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n    netcode_random_bytes( connect_token, NETCODE_CONNECT_TOKEN_BYTES );\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    netcode_client_connect( client, connect_token );\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_error_connection_timed_out()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    // connect a client to the server\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // now disable updating the server and verify that the client times out\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_error_connection_response_timeout()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    server->flags = NETCODE_SERVER_FLAG_IGNORE_CONNECTION_RESPONSE_PACKETS;\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED  )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_error_connection_request_timeout()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 60.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    server->flags = NETCODE_SERVER_FLAG_IGNORE_CONNECTION_REQUEST_PACKETS;\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED  )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_error_connection_denied()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    // start a server and connect one client\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // now attempt to connect a second client. the connection should be denied.\n\n    struct netcode_client_t * client2 = netcode_client_create( \"[::]:50001\", &client_config, time );\n\n    check( client2 );\n\n    uint8_t connect_token2[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id2 = 0;\n    netcode_random_bytes( (uint8_t*) &client_id2, 8 );\n\n    uint8_t user_data2[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data2, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id2, TEST_PROTOCOL_ID, private_key, user_data2, connect_token2 ) );\n\n    netcode_client_connect( client2, connect_token2 );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_client_update( client2, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client2 ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_state( client2 ) == NETCODE_CLIENT_STATE_CONNECTION_DENIED );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n    \n    netcode_client_destroy( client2 );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_side_disconnect()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    // start a server and connect one client\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // disconnect client side and verify that the server sees that client disconnect cleanly, rather than timing out.\n\n    netcode_client_disconnect( client );\n\n    int i;\n    for ( i = 0; i < 10; i++ )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_server_client_connected( server, 0 ) == 0 )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_server_client_connected( server, 0 ) == 0 );\n    check( netcode_server_num_connected_clients( server ) == 0 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_server_side_disconnect()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    // start a server and connect one client\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // disconnect server side and verify that the client disconnects cleanly, rather than timing out.\n\n    netcode_server_disconnect_client( server, 0 );\n\n    int i;\n    for ( i = 0; i < 10; i++ )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_DISCONNECTED );\n    check( netcode_server_client_connected( server, 0 ) == 0 );\n    check( netcode_server_num_connected_clients( server ) == 0 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_client_reconnect()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    // start a server and connect one client\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // disconnect client on the server-side and wait until client sees the disconnect\n\n    netcode_network_simulator_reset( network_simulator );\n\n    netcode_server_disconnect_client( server, 0 );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_DISCONNECTED );\n    check( netcode_server_client_connected( server, 0 ) == 0 );\n    check( netcode_server_num_connected_clients( server ) == 0 );\n\n    // now reconnect the client and verify they connect\n\n    netcode_network_simulator_reset( network_simulator );\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nstruct test_loopback_context_t\n{\n    struct netcode_client_t * client;\n    struct netcode_server_t * server;\n    int num_loopback_packets_sent_to_client;\n    int num_loopback_packets_sent_to_server;\n};\n\nvoid client_send_loopback_packet_callback( void * _context, int client_index, NETCODE_CONST uint8_t * packet_data, int packet_bytes, uint64_t packet_sequence )\n{\n    (void) packet_sequence;\n    check( _context );\n    check( client_index == 0 );\n    check( packet_data );\n    check( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n    int i;\n    for ( i = 0; i < packet_bytes; i++ )\n    {\n        check( packet_data[i] == (uint8_t) i );\n    }\n    struct test_loopback_context_t * context = (struct test_loopback_context_t*) _context;\n    context->num_loopback_packets_sent_to_server++;\n    netcode_server_process_loopback_packet( context->server, client_index, packet_data, packet_bytes, packet_sequence );\n}\n\nvoid server_send_loopback_packet_callback( void * _context, int client_index, NETCODE_CONST uint8_t * packet_data, int packet_bytes, uint64_t packet_sequence )\n{\n    (void) packet_sequence;\n    check( _context );\n    check( client_index == 0 );\n    check( packet_data );\n    check( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n    int i;\n    for ( i = 0; i < packet_bytes; i++ )\n    {\n        check( packet_data[i] == (uint8_t) i );\n    }\n    struct test_loopback_context_t * context = (struct test_loopback_context_t*) _context;\n    context->num_loopback_packets_sent_to_client++;\n    netcode_client_process_loopback_packet( context->client, packet_data, packet_bytes, packet_sequence );\n}\n\nvoid test_disable_timeout()\n{\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * client = netcode_client_create( \"[::]:50000\", &client_config, time );\n\n    check( client );\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    netcode_server_start( server, 1 );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, -1, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( client ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    int server_num_packets_received = 0;\n    int client_num_packets_received = 0;\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; i++ )\n        packet_data[i] = (uint8_t) i;\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( client, time );\n\n        netcode_server_update( server, time );\n\n        netcode_client_send_packet( client, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            client_num_packets_received++;\n            netcode_client_free_packet( client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 0, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        if ( client_num_packets_received >= 10 && server_num_packets_received >= 10 )\n        {\n            if ( netcode_server_client_connected( server, 0 ) )\n            {\n                netcode_server_disconnect_client( server, 0 );\n            }\n        }\n\n        if ( netcode_client_state( client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += 1000.0f;        // normally this would timeout the client\n    }\n\n    check( client_num_packets_received >= 10 && server_num_packets_received >= 10 );\n\n    netcode_server_destroy( server );\n\n    netcode_client_destroy( client );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\nvoid test_loopback()\n{\n    struct test_loopback_context_t context;\n    memset( &context, 0, sizeof( context ) );\n\n    struct netcode_network_simulator_t * network_simulator = netcode_network_simulator_create( NULL, NULL, NULL );\n\n    network_simulator->latency_milliseconds = 250;\n    network_simulator->jitter_milliseconds = 250;\n    network_simulator->packet_loss_percent = 5;\n    network_simulator->duplicate_packet_percent = 10;\n\n    double time = 0.0;\n    double delta_time = 1.0 / 10.0;\n\n    // start the server\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    server_config.network_simulator = network_simulator;\n    server_config.callback_context = &context;\n    server_config.send_loopback_packet_callback = server_send_loopback_packet_callback;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( \"[::1]:40000\", &server_config, time );\n\n    check( server );\n\n    int max_clients = 2;\n\n    netcode_server_start( server, max_clients );\n\n    context.server = server;\n\n    // connect a loopback client in slot 0\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n    client_config.callback_context = &context;\n    client_config.send_loopback_packet_callback = client_send_loopback_packet_callback;\n    client_config.network_simulator = network_simulator;\n\n    struct netcode_client_t * loopback_client = netcode_client_create( \"[::]:50000\", &client_config, time );\n    check( loopback_client );\n    netcode_client_connect_loopback( loopback_client, 0, max_clients );\n    context.client = loopback_client;\n\n    check( netcode_client_index( loopback_client ) == 0 );\n    check( netcode_client_loopback( loopback_client ) == 1 );\n    check( netcode_client_max_clients( loopback_client ) == max_clients );\n    check( netcode_client_state( loopback_client ) == NETCODE_CLIENT_STATE_CONNECTED );\n\n    uint64_t client_id = 0;\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n    netcode_server_connect_loopback_client( server, 0, client_id, NULL );\n\n    check( netcode_server_client_loopback( server, 0 ) == 1 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    // connect a regular client in the other slot\n\n    struct netcode_client_t * regular_client = netcode_client_create( \"[::]:50001\", &client_config, time );\n\n    check( regular_client );\n\n    NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n    uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n    uint8_t user_data[NETCODE_USER_DATA_BYTES];\n    netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n    check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n    netcode_client_connect( regular_client, connect_token );\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( regular_client, time );\n\n        netcode_server_update( server, time );\n\n        if ( netcode_client_state( regular_client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        if ( netcode_client_state( regular_client ) == NETCODE_CLIENT_STATE_CONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( netcode_client_state( regular_client ) == NETCODE_CLIENT_STATE_CONNECTED );\n    check( netcode_client_index( regular_client ) == 1 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_client_connected( server, 1 ) == 1 );\n    check( netcode_server_client_loopback( server, 0 ) == 1 );\n    check( netcode_server_client_loopback( server, 1 ) == 0 );\n    check( netcode_server_num_connected_clients( server ) == 2 );\n\n    // test that we can exchange packets for the regular client and the loopback client\n\n    int loopback_client_num_packets_received = 0;\n    int loopback_server_num_packets_received = 0;\n    int regular_server_num_packets_received = 0;\n    int regular_client_num_packets_received = 0;\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; i++ )\n        packet_data[i] = (uint8_t) i;\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( regular_client, time );\n\n        netcode_server_update( server, time );\n\n        netcode_client_send_packet( loopback_client, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        netcode_client_send_packet( regular_client, packet_data, NETCODE_MAX_PACKET_SIZE );\n        \n        netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n        \n        netcode_server_send_packet( server, 1, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( loopback_client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            loopback_client_num_packets_received++;\n            netcode_client_free_packet( loopback_client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( regular_client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            regular_client_num_packets_received++;\n            netcode_client_free_packet( regular_client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 0, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            loopback_server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 1, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            regular_server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        if ( loopback_client_num_packets_received >= 10 && loopback_server_num_packets_received >= 10 &&\n             regular_client_num_packets_received >= 10 && regular_server_num_packets_received >= 10 )\n            break;\n\n        if ( netcode_client_state( regular_client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( loopback_client_num_packets_received >= 10 );\n    check( loopback_server_num_packets_received >= 10 );\n    check( regular_client_num_packets_received >= 10 );\n    check( regular_server_num_packets_received >= 10 );\n    check( context.num_loopback_packets_sent_to_client >= 10 );\n    check( context.num_loopback_packets_sent_to_server >= 10 );\n\n    // verify that we can disconnect the loopback client\n\n    check( netcode_server_client_loopback( server, 0 ) == 1 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 2 );\n\n    netcode_server_disconnect_loopback_client( server, 0 );    \n\n    check( netcode_server_client_loopback( server, 0 ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 0 );\n    check( netcode_server_num_connected_clients( server ) == 1 );\n\n    netcode_client_disconnect_loopback( loopback_client );\n\n    check( netcode_client_state( loopback_client ) == NETCODE_CLIENT_STATE_DISCONNECTED );\n\n    // verify that we can reconnect the loopback client\n\n    netcode_random_bytes( (uint8_t*) &client_id, 8 );\n    netcode_server_connect_loopback_client( server, 0, client_id, NULL );\n\n    check( netcode_server_client_loopback( server, 0 ) == 1 );\n    check( netcode_server_client_loopback( server, 1 ) == 0 );\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_client_connected( server, 1 ) == 1 );\n    check( netcode_server_num_connected_clients( server ) == 2 );\n\n    netcode_client_connect_loopback( loopback_client, 0, max_clients );\n    \n    check( netcode_client_index( loopback_client ) == 0 );\n    check( netcode_client_loopback( loopback_client ) == 1 );\n    check( netcode_client_max_clients( loopback_client ) == max_clients );\n    check( netcode_client_state( loopback_client ) == NETCODE_CLIENT_STATE_CONNECTED );\n\n    // verify that we can exchange packets for both regular and loopback client post reconnect\n\n    loopback_server_num_packets_received = 0;\n    loopback_client_num_packets_received = 0;\n    regular_server_num_packets_received = 0;\n    regular_client_num_packets_received = 0;\n    context.num_loopback_packets_sent_to_client = 0;\n    context.num_loopback_packets_sent_to_server = 0;\n\n    while ( 1 )\n    {\n        netcode_network_simulator_update( network_simulator, time );\n\n        netcode_client_update( regular_client, time );\n\n        netcode_server_update( server, time );\n\n        netcode_client_send_packet( loopback_client, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        netcode_client_send_packet( regular_client, packet_data, NETCODE_MAX_PACKET_SIZE );\n        \n        netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n        \n        netcode_server_send_packet( server, 1, packet_data, NETCODE_MAX_PACKET_SIZE );\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( loopback_client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            loopback_client_num_packets_received++;\n            netcode_client_free_packet( loopback_client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            uint8_t * packet = netcode_client_receive_packet( regular_client, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            regular_client_num_packets_received++;\n            netcode_client_free_packet( regular_client, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 0, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            loopback_server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        while ( 1 )             \n        {\n            int packet_bytes;\n            uint64_t packet_sequence;\n            void * packet = netcode_server_receive_packet( server, 1, &packet_bytes, &packet_sequence );\n            if ( !packet )\n                break;\n            (void) packet_sequence;\n            netcode_assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n            netcode_assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n            regular_server_num_packets_received++;\n            netcode_server_free_packet( server, packet );\n        }\n\n        if ( loopback_client_num_packets_received >= 10 && loopback_server_num_packets_received >= 10 &&\n             regular_client_num_packets_received >= 10 && regular_server_num_packets_received >= 10 )\n            break;\n\n        if ( netcode_client_state( regular_client ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            break;\n\n        time += delta_time;\n    }\n\n    check( loopback_client_num_packets_received >= 10 );\n    check( loopback_server_num_packets_received >= 10 );\n    check( regular_client_num_packets_received >= 10 );\n    check( regular_server_num_packets_received >= 10 );\n    check( context.num_loopback_packets_sent_to_client >= 10 );\n    check( context.num_loopback_packets_sent_to_server >= 10 );\n\n    // verify the regular client times out but loopback client doesn't\n\n    time += 100000.0;\n\n    netcode_server_update( server, time );\n\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_client_connected( server, 1 ) == 0 );\n\n    netcode_client_update( loopback_client, time );\n\n    check( netcode_client_state( loopback_client ) == NETCODE_CLIENT_STATE_CONNECTED );\n\n    // verify that disconnect all clients leaves loopback clients alone\n\n    netcode_server_disconnect_all_clients( server );\n\n    check( netcode_server_client_connected( server, 0 ) == 1 );\n    check( netcode_server_client_connected( server, 1 ) == 0 );\n    check( netcode_server_client_loopback( server, 0 ) == 1 );\n\n    // clean up\n\n    netcode_client_destroy( regular_client );\n\n    netcode_client_destroy( loopback_client );\n\n    netcode_server_destroy( server );\n\n    netcode_network_simulator_destroy( network_simulator );\n}\n\n#if NETCODE_PACKET_TAGGING\n\nvoid test_packet_tagging()\n{\n    // IMPORTANT: Packet tagging is off by default because it doesn't play well with some older home routers\n    // See https://learn.microsoft.com/en-us/gaming/gdk/_content/gc/networking/overviews/qos-packet-tagging\n    // However, I really recommend providing players with a way to turn it on, since it can significantly reduce\n    // jitter playing over Wi-Fi.\n\n    netcode_enable_packet_tagging();\n\n    {\n        NETCODE_CONST char * server_address = \"127.0.0.1:40000\";\n\n        struct netcode_server_config_t server_config;\n        netcode_default_server_config( &server_config );\n\n        struct netcode_server_t * server = netcode_server_create( server_address, &server_config, 0.0 );\n\n        check( server );\n\n        struct netcode_client_config_t client_config;\n        netcode_default_client_config( &client_config );\n\n        struct netcode_client_t * client = netcode_client_create( \"127.0.0.1:50000\", &client_config, 0.0 );\n\n        check( client );\n\n        uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n        uint64_t client_id = 0;\n        netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n        uint8_t user_data[NETCODE_USER_DATA_BYTES];\n        netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n        check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n        netcode_client_connect( client, connect_token );\n\n        netcode_client_destroy( client );\n\n        netcode_server_destroy( server );\n    }\n\n    {\n        NETCODE_CONST char * server_address = \"[::1]:40000\";\n\n        struct netcode_server_config_t server_config;\n        netcode_default_server_config( &server_config );\n\n        struct netcode_server_t * server = netcode_server_create( server_address, &server_config, 0.0 );\n\n        check( server );\n\n        struct netcode_client_config_t client_config;\n        netcode_default_client_config( &client_config );\n\n        struct netcode_client_t * client = netcode_client_create( \"[::1]:50000\", &client_config, 0.0 );\n\n        check( client );\n\n        uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n        uint64_t client_id = 0;\n        netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n        uint8_t user_data[NETCODE_USER_DATA_BYTES];\n        netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n        check( netcode_generate_connect_token( 1, &server_address, &server_address, TEST_CONNECT_TOKEN_EXPIRY, TEST_TIMEOUT_SECONDS, client_id, TEST_PROTOCOL_ID, private_key, user_data, connect_token ) );\n\n        netcode_client_connect( client, connect_token );\n\n        netcode_client_destroy( client );\n\n        netcode_server_destroy( server );\n    }\n}\n\n#endif // #if NETCODE_PACKET_TAGGING\n\n#define RUN_TEST( test_function )                                           \\\n    do                                                                      \\\n    {                                                                       \\\n        printf( #test_function \"\\n\" );                                      \\\n        test_function();                                                    \\\n    }                                                                       \\\n    while (0)\n\nvoid netcode_test()\n{\n    //while ( 1 )\n    {\n        RUN_TEST( test_queue );\n        RUN_TEST( test_endian );\n        RUN_TEST( test_address );\n        RUN_TEST( test_sequence );\n        RUN_TEST( test_connect_token );\n        RUN_TEST( test_challenge_token );\n        RUN_TEST( test_connection_request_packet );\n        RUN_TEST( test_connection_denied_packet );\n        RUN_TEST( test_connection_challenge_packet );\n        RUN_TEST( test_connection_response_packet );\n        RUN_TEST( test_connection_keep_alive_packet );\n        RUN_TEST( test_connection_payload_packet );\n        RUN_TEST( test_connection_disconnect_packet );\n        RUN_TEST( test_connect_token_public );\n        RUN_TEST( test_encryption_manager );\n        RUN_TEST( test_replay_protection );\n        RUN_TEST( test_client_create );\n        RUN_TEST( test_server_create );\n        RUN_TEST( test_client_server_connect );\n        RUN_TEST( test_client_server_ipv4_socket_connect );\n        RUN_TEST( test_client_server_ipv6_socket_connect );\n        RUN_TEST( test_client_server_keep_alive );\n        RUN_TEST( test_client_server_multiple_clients );\n        RUN_TEST( test_client_server_multiple_servers );\n        RUN_TEST( test_client_error_connect_token_expired );\n        RUN_TEST( test_client_error_invalid_connect_token );\n        RUN_TEST( test_client_error_connection_timed_out );\n        RUN_TEST( test_client_error_connection_response_timeout );\n        RUN_TEST( test_client_error_connection_request_timeout );\n        RUN_TEST( test_client_error_connection_denied );\n        RUN_TEST( test_client_side_disconnect );\n        RUN_TEST( test_server_side_disconnect );\n        RUN_TEST( test_client_reconnect );\n        RUN_TEST( test_disable_timeout );\n        RUN_TEST( test_loopback );\n#if NETCODE_PACKET_TAGGING\n        RUN_TEST( test_packet_tagging );\n#endif // #if NETCODE_PACKET_TAGGING\n    }\n}\n\n#endif // #if NETCODE_ENABLE_TESTS\n"
        },
        {
          "name": "netcode.h",
          "type": "blob",
          "size": 12.5908203125,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef NETCODE_H\n#define NETCODE_H\n\n#include <stdint.h>\n#include <stddef.h>\n\n#if !defined(NETCODE_DEBUG) && !defined(NETCODE_RELEASE)\n#if defined(NDEBUG)\n#define NETCODE_RELEASE\n#else\n#define NETCODE_DEBUG\n#endif\n#elif defined(NETCODE_DEBUG) && defined(NETCODE_RELEASE)\n#error Can only define one of debug & release\n#endif\n\n#if    defined(__386__) || defined(i386)    || defined(__i386__)  \\\n    || defined(__X86)   || defined(_M_IX86)                       \\\n    || defined(_M_X64)  || defined(__x86_64__)                    \\\n    || defined(alpha)   || defined(__alpha) || defined(__alpha__) \\\n    || defined(_M_ALPHA)                                          \\\n    || defined(ARM)     || defined(_ARM)    || defined(__arm__)   \\\n    || defined(__aarch64__)                                       \\\n    || defined(WIN32)   || defined(_WIN32)  || defined(__WIN32__) \\\n    || defined(_WIN32_WCE) || defined(__NT__)                     \\\n    || defined(__MIPSEL__)\n  #define NETCODE_LITTLE_ENDIAN 1\n#else\n  #define NETCODE_BIG_ENDIAN 1\n#endif\n\n#define NETCODE_PLATFORM_WINDOWS    1\n#define NETCODE_PLATFORM_MAC        2\n#define NETCODE_PLATFORM_UNIX       3\n\n#if defined(_WIN32)\n#define NETCODE_PLATFORM NETCODE_PLATFORM_WINDOWS\n#elif defined(__APPLE__)\n#define NETCODE_PLATFORM NETCODE_PLATFORM_MAC\n#else\n#define NETCODE_PLATFORM NETCODE_PLATFORM_UNIX\n#endif\n\n#define NETCODE_CONNECT_TOKEN_BYTES 2048\n#define NETCODE_KEY_BYTES 32\n#define NETCODE_MAC_BYTES 16\n#define NETCODE_USER_DATA_BYTES 256\n#define NETCODE_MAX_SERVERS_PER_CONNECT 32\n\n#define NETCODE_CLIENT_STATE_CONNECT_TOKEN_EXPIRED              -6\n#define NETCODE_CLIENT_STATE_INVALID_CONNECT_TOKEN              -5\n#define NETCODE_CLIENT_STATE_CONNECTION_TIMED_OUT               -4\n#define NETCODE_CLIENT_STATE_CONNECTION_RESPONSE_TIMED_OUT      -3\n#define NETCODE_CLIENT_STATE_CONNECTION_REQUEST_TIMED_OUT       -2\n#define NETCODE_CLIENT_STATE_CONNECTION_DENIED                  -1\n#define NETCODE_CLIENT_STATE_DISCONNECTED                       0\n#define NETCODE_CLIENT_STATE_SENDING_CONNECTION_REQUEST         1\n#define NETCODE_CLIENT_STATE_SENDING_CONNECTION_RESPONSE        2\n#define NETCODE_CLIENT_STATE_CONNECTED                          3\n\n#define NETCODE_MAX_CLIENTS         256\n#define NETCODE_MAX_PACKET_SIZE     1200\n\n#define NETCODE_LOG_LEVEL_NONE      0\n#define NETCODE_LOG_LEVEL_ERROR     1\n#define NETCODE_LOG_LEVEL_INFO      2\n#define NETCODE_LOG_LEVEL_DEBUG     3\n\n#define NETCODE_OK                  1\n#define NETCODE_ERROR               0\n\n#define NETCODE_ADDRESS_NONE        0\n#define NETCODE_ADDRESS_IPV4        1\n#define NETCODE_ADDRESS_IPV6        2\n\n#ifdef __cplusplus\n#define NETCODE_CONST const\nextern \"C\" {\n#else\n#if defined(__STDC__)\n#define NETCODE_CONST const\n#else\n#define NETCODE_CONST\n#endif\n#endif\n\nint netcode_init();\n\nvoid netcode_term();\n\n#ifndef NETCODE_PACKET_TAGGING\n#define NETCODE_PACKET_TAGGING 1\n#endif // #ifndef NETCODE_PACKET_TAGGING\n\n#if NETCODE_PACKET_TAGGING\nvoid netcode_enable_packet_tagging();\n#endif // #if NETCODE_PACKET_TAGGING\n\nstruct netcode_address_t\n{\n    union { uint8_t ipv4[4]; uint16_t ipv6[8]; } data;\n    uint16_t port;\n    uint8_t type;\n};\n\nint netcode_parse_address( NETCODE_CONST char * address_string_in, struct netcode_address_t * address );\n\nchar * netcode_address_to_string( struct netcode_address_t * address, char * buffer );\n\nint netcode_address_equal( struct netcode_address_t * a, struct netcode_address_t * b );\n\nstruct netcode_client_config_t\n{\n    void * allocator_context;\n    void * (*allocate_function)(void*,size_t);\n    void (*free_function)(void*,void*);\n    struct netcode_network_simulator_t * network_simulator;\n    void * callback_context;\n    void (*state_change_callback)(void*,int,int);\n    void (*send_loopback_packet_callback)(void*,int,NETCODE_CONST uint8_t*,int,uint64_t);\n    int override_send_and_receive;\n    void (*send_packet_override)(void*,struct netcode_address_t*,NETCODE_CONST uint8_t*,int);\n    int (*receive_packet_override)(void*,struct netcode_address_t*,uint8_t*,int);\n};\n\nvoid netcode_default_client_config( struct netcode_client_config_t * config );\n\nstruct netcode_client_t * netcode_client_create( NETCODE_CONST char * address, NETCODE_CONST struct netcode_client_config_t * config, double time );\n\nvoid netcode_client_destroy( struct netcode_client_t * client );\n\nvoid netcode_client_connect( struct netcode_client_t * client, uint8_t * connect_token );\n\nvoid netcode_client_update( struct netcode_client_t * client, double time );\n\nuint64_t netcode_client_next_packet_sequence( struct netcode_client_t * client );\n\nvoid netcode_client_send_packet( struct netcode_client_t * client, NETCODE_CONST uint8_t * packet_data, int packet_bytes );\n\nuint8_t * netcode_client_receive_packet( struct netcode_client_t * client, int * packet_bytes, uint64_t * packet_sequence );\n\nvoid netcode_client_free_packet( struct netcode_client_t * client, void * packet );\n\nvoid netcode_client_disconnect( struct netcode_client_t * client );\n\nint netcode_client_state( struct netcode_client_t * client );\n\nint netcode_client_index( struct netcode_client_t * client );\n\nint netcode_client_max_clients( struct netcode_client_t * client );\n\nvoid netcode_client_connect_loopback( struct netcode_client_t * client, int client_index, int max_clients );\n\nvoid netcode_client_disconnect_loopback( struct netcode_client_t * client );\n\nvoid netcode_client_process_packet( struct netcode_client_t * client, struct netcode_address_t * from, uint8_t * packet_data, int packet_bytes );\n\nint netcode_client_loopback( struct netcode_client_t * client );\n\nvoid netcode_client_process_loopback_packet( struct netcode_client_t * client, NETCODE_CONST uint8_t * packet_data, int packet_bytes, uint64_t packet_sequence );\n\nuint16_t netcode_client_get_port( struct netcode_client_t * client );\n\nstruct netcode_address_t * netcode_client_server_address( struct netcode_client_t * client );\n\nint netcode_generate_connect_token( int num_server_addresses, \n                                    NETCODE_CONST char ** public_server_addresses, \n                                    NETCODE_CONST char ** internal_server_addresses, \n                                    int expire_seconds,\n                                    int timeout_seconds, \n                                    uint64_t client_id, \n                                    uint64_t protocol_id, \n                                    NETCODE_CONST uint8_t * private_key, \n                                    uint8_t * user_data, \n                                    uint8_t * connect_token );\n\nstruct netcode_server_config_t\n{\n    uint64_t protocol_id;\n    uint8_t private_key[NETCODE_KEY_BYTES];\n    void * allocator_context;\n    void * (*allocate_function)(void*,size_t);\n    void (*free_function)(void*,void*);\n    struct netcode_network_simulator_t * network_simulator;\n    void * callback_context;\n    void (*connect_disconnect_callback)(void*,int,int);\n    void (*send_loopback_packet_callback)(void*,int,NETCODE_CONST uint8_t*,int,uint64_t);\n    int override_send_and_receive;\n    void (*send_packet_override)(void*,struct netcode_address_t*,NETCODE_CONST uint8_t*,int);\n    int (*receive_packet_override)(void*,struct netcode_address_t*,uint8_t*,int);\n};\n\nvoid netcode_default_server_config( struct netcode_server_config_t * config );\n\nstruct netcode_server_t * netcode_server_create( NETCODE_CONST char * server_address, NETCODE_CONST struct netcode_server_config_t * config, double time );\n\nvoid netcode_server_destroy( struct netcode_server_t * server );\n\nvoid netcode_server_start( struct netcode_server_t * server, int max_clients );\n\nvoid netcode_server_stop( struct netcode_server_t * server );\n\nint netcode_server_running( struct netcode_server_t * server );\n\nint netcode_server_max_clients( struct netcode_server_t * server );\n\nvoid netcode_server_update( struct netcode_server_t * server, double time );\n\nint netcode_server_client_connected( struct netcode_server_t * server, int client_index );\n\nuint64_t netcode_server_client_id( struct netcode_server_t * server, int client_index );\n\nstruct netcode_address_t * netcode_server_client_address( struct netcode_server_t * server, int client_index );\n\nvoid netcode_server_disconnect_client( struct netcode_server_t * server, int client_index );\n\nvoid netcode_server_disconnect_all_clients( struct netcode_server_t * server );\n\nuint64_t netcode_server_next_packet_sequence( struct netcode_server_t * server, int client_index );\n\nvoid netcode_server_send_packet( struct netcode_server_t * server, int client_index, NETCODE_CONST uint8_t * packet_data, int packet_bytes );\n\nuint8_t * netcode_server_receive_packet( struct netcode_server_t * server, int client_index, int * packet_bytes, uint64_t * packet_sequence );\n\nvoid netcode_server_free_packet( struct netcode_server_t * server, void * packet );\n\nint netcode_server_num_connected_clients( struct netcode_server_t * server );\n\nvoid * netcode_server_client_user_data( struct netcode_server_t * server, int client_index );\n\nvoid netcode_server_process_packet( struct netcode_server_t * server, struct netcode_address_t * from, uint8_t * packet_data, int packet_bytes );\n\nvoid netcode_server_connect_loopback_client( struct netcode_server_t * server, int client_index, uint64_t client_id, NETCODE_CONST uint8_t * user_data );\n\nvoid netcode_server_disconnect_loopback_client( struct netcode_server_t * server, int client_index );\n\nint netcode_server_client_loopback( struct netcode_server_t * server, int client_index );\n\nvoid netcode_server_process_loopback_packet( struct netcode_server_t * server, int client_index, NETCODE_CONST uint8_t * packet_data, int packet_bytes, uint64_t packet_sequence );\n\nuint16_t netcode_server_get_port( struct netcode_server_t * server );\n\nvoid netcode_log_level( int level );\n\nvoid netcode_set_printf_function( int (*function)( NETCODE_CONST char *, ... ) );\n\nextern void (*netcode_assert_function)( NETCODE_CONST char *, NETCODE_CONST char *, NETCODE_CONST char * file, int line );\n\n#ifndef NDEBUG\n#define netcode_assert( condition )                                                         \\\ndo                                                                                          \\\n{                                                                                           \\\n    if ( !(condition) )                                                                     \\\n    {                                                                                       \\\n        netcode_assert_function( #condition, __FUNCTION__, __FILE__, __LINE__ );            \\\n        exit(1);                                                                            \\\n    }                                                                                       \\\n} while(0)\n#else\n#define netcode_assert( ignore ) ((void)0)\n#endif\n\nvoid netcode_set_assert_function( void (*function)( NETCODE_CONST char * /*condition*/, \n                                  NETCODE_CONST char * /*function*/, \n                                  NETCODE_CONST char * /*file*/, \n                                  int /*line*/ ) );\n\nvoid netcode_random_bytes( uint8_t * data, int bytes );\n\nvoid netcode_sleep( double seconds );\n\ndouble netcode_time();\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // #ifndef NETCODE_H\n"
        },
        {
          "name": "premake5.lua",
          "type": "blob",
          "size": 2.5888671875,
          "content": "\nsolution \"netcode\"\n    kind \"ConsoleApp\"\n    language \"C\"\n    configurations { \"Debug\", \"Release\" }\n    includedirs { \"sodium\" }\n    targetdir \"bin/\"\n    rtti \"Off\"\n    warnings \"Extra\"\n    flags { \"FatalWarnings\" }\n    staticruntime \"On\"\n    floatingpoint \"Fast\"\n    filter \"configurations:Debug\"\n        symbols \"On\"\n        defines { \"NETCODE_DEBUG\" }\n    filter \"configurations:Release\"\n        symbols \"Off\"\n        optimize \"Speed\"\n        defines { \"NETCODE_RELEASE\" }\n\nproject \"sodium\"\n    kind \"StaticLib\"\n    language \"C\"\n    files {\n        \"sodium/**.c\",\n        \"sodium/**.h\",\n    }\n    filter { \"system:not windows\", \"platforms:*x64 or *avx or *avx2\" }\n        files {\n            \"sodium/**.S\"\n        }\n    filter { \"action:gmake*\" }\n        buildoptions { \"-Wno-unused-parameter\", \"-Wno-unused-function\", \"-Wno-unknown-pragmas\", \"-Wno-unused-variable\", \"-Wno-type-limits\" }\n\nproject \"test\"\n    files { \"test.cpp\" }\n    links { \"sodium\" }\n\nproject \"soak\"\n    files { \"soak.c\", \"netcode.c\" }\n    links { \"sodium\" }\n\nproject \"profile\"\n    files { \"profile.c\", \"netcode.c\" }    \n    links { \"sodium\" }\n\nproject \"client\"\n    files { \"client.c\", \"netcode.c\" }\n    links { \"sodium\" }\n\nproject \"server\"\n    files { \"server.c\", \"netcode.c\" }\n    links { \"sodium\" }\n\nproject \"client_server\"\n    files { \"client_server.c\", \"netcode.c\" }\n    links { \"sodium\" }\n\nnewaction\n{\n    trigger     = \"clean\",\n\n    description = \"Clean all build files and output\",\n\n    execute = function ()\n\n        files_to_delete = \n        {\n            \"Makefile\",\n            \"*.make\",\n            \"*.txt\",\n            \"*.zip\",\n            \"*.tar.gz\",\n            \"*.db\",\n            \"*.opendb\",\n            \"*.vcproj\",\n            \"*.vcxproj\",\n            \"*.vcxproj.user\",\n            \"*.vcxproj.filters\",\n            \"*.sln\",\n            \"*.xcodeproj\",\n            \"*.xcworkspace\"\n        }\n\n        directories_to_delete = \n        {\n            \"obj\",\n            \"ipch\",\n            \"bin\",\n            \".vs\",\n            \"Debug\",\n            \"Release\",\n            \"release\",\n            \"cov-int\",\n            \"docs\",\n            \"xml\",\n            \"docker/netcode\",\n            \"valgrind/netcode\"\n        }\n\n        for i,v in ipairs( directories_to_delete ) do\n          os.rmdir( v )\n        end\n\n        if not os.ishost \"windows\" then\n            os.execute \"find . -name .DS_Store -delete\"\n            for i,v in ipairs( files_to_delete ) do\n              os.execute( \"rm -f \" .. v )\n            end\n        else\n            for i,v in ipairs( files_to_delete ) do\n              os.execute( \"del /F /Q  \" .. v )\n            end\n        end\n\n    end\n}\n"
        },
        {
          "name": "profile.c",
          "type": "blob",
          "size": 9.3876953125,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"netcode.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <assert.h>\n#include <signal.h>\n#include <inttypes.h>\n\n#define MAX_SERVERS NETCODE_MAX_SERVERS_PER_CONNECT\n#define MAX_CLIENTS MAX_SERVERS * NETCODE_MAX_CLIENTS\n#define SERVER_BASE_PORT 40000\n#define CONNECT_TOKEN_EXPIRY 45\n#define CONNECT_TOKEN_TIMEOUT 5\n#define PROTOCOL_ID 0x1122334455667788\n\nstatic volatile int quit = 0;\n\nvoid interrupt_handler( int signal )\n{\n    (void) signal;\n    quit = 1;\n}\n\nint random_int( int a, int b )\n{\n    assert( a < b );\n    int result = a + rand() % ( b - a + 1 );\n    assert( result >= a );\n    assert( result <= b );\n    return result;\n}\n\nfloat random_float( float a, float b )\n{\n    assert( a < b );\n    float random = ( (float) rand() ) / (float) RAND_MAX;\n    float diff = b - a;\n    float r = random * diff;\n    return a + r;\n}\n\nstruct netcode_server_t * server[MAX_SERVERS];\nstruct netcode_client_t * client[MAX_CLIENTS];\nuint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\nuint8_t private_key[NETCODE_KEY_BYTES];\n\nvoid profile_initialize()\n{\n    printf( \"initializing\\n\" );\n\n    netcode_init();\n\n    memset( server, 0, sizeof( server ) );\n    memset( client, 0, sizeof( client ) );\n\n    netcode_random_bytes( private_key, NETCODE_KEY_BYTES );\n\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; ++i )\n    {\n        packet_data[i] = (uint8_t) i;\n    }\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = PROTOCOL_ID;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    for ( i = 0; i < MAX_SERVERS; ++i )\n    {\n        char server_address[256];\n\t\t#if _MSC_VER > 1600\n        sprintf_s( server_address, 256, \"127.0.0.1:%d\", SERVER_BASE_PORT + i );\n\t\t#else\n        sprintf( server_address, \"127.0.0.1:%d\", SERVER_BASE_PORT + i );\n\t\t#endif\n        server[i] = netcode_server_create( server_address, &server_config, 0.0 );\n    }\n\n    struct netcode_client_config_t client_config;\n    netcode_default_client_config( &client_config );\n\n    for ( i = 0; i < MAX_CLIENTS; ++i )\n    {\n        client[i] = netcode_client_create( \"0.0.0.0\", &client_config, 0.0 );\n    }\n}\n\nvoid profile_shutdown()\n{\n    printf( \"shutdown\\n\" );\n\n    int i;\n\n    for ( i = 0; i < MAX_SERVERS; ++i )\n    {\n        if ( server[i] != NULL )\n        {\n            netcode_server_destroy( server[i] );\n            server[i] = NULL;\n        }\n    }\n\n    for ( i = 0; i < MAX_CLIENTS; ++i )\n    {\n        if ( client[i] != NULL )\n        {\n            netcode_client_destroy( client[i] );\n            client[i] = NULL;\n        }\n    }\n\n    netcode_term();\n}\n\nvoid profile_iteration( double time )\n{\n    printf( \".\" );\n    fflush( stdout );\n\n    int i;\n\n    for ( i = 0; i < MAX_SERVERS; ++i )\n    {\n        if ( server[i] != NULL )\n        {\n            if ( !netcode_server_running( server[i] ) )\n            {\n                netcode_server_start( server[i], random_int( 1, NETCODE_MAX_CLIENTS ) );\n            }\n\n            if ( netcode_server_running( server[i] ) )\n            {\n                int max_clients = netcode_server_max_clients( server[i] );\n                int client_index;\n                for ( client_index = 0; client_index < max_clients; ++client_index )\n                {\n                    if ( netcode_server_client_connected( server[i], client_index ) )\n                    {\n                        netcode_server_send_packet( server[i], 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n                    }\n                }\n\n                for ( client_index = 0; client_index < max_clients; ++client_index )\n                {\n                    if ( netcode_server_client_connected( server[i], client_index ) )\n                    {\n                        while ( 1 )             \n                        {\n                            int packet_bytes;\n                            uint64_t packet_sequence;\n                            void * packet = netcode_server_receive_packet( server[i], client_index, &packet_bytes, &packet_sequence );\n                            if ( !packet )\n                                break;\n                            (void) packet_sequence;\n                            assert( memcmp( packet, packet_data, packet_bytes ) == 0 );            \n                            netcode_server_free_packet( server[i], packet );\n                        }\n                    }\n                }\n            }\n\n            netcode_server_update( server[i], time );\n        }\n        \n    }\n\n    for ( i = 0; i < MAX_CLIENTS; ++i )\n    {\n        if ( client[i] != NULL )\n        {\n            if ( netcode_client_state( client[i] ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            {\n                uint64_t client_id = 0;\n                netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n                uint8_t user_data[NETCODE_USER_DATA_BYTES];\n                netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n                uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n                int num_server_addresses = 0;\n                char * server_address[NETCODE_MAX_SERVERS_PER_CONNECT];\n                int j;\n                for ( j = 0; j < MAX_SERVERS; ++j )\n                {\n                    if ( num_server_addresses == NETCODE_MAX_SERVERS_PER_CONNECT )\n                        break;\n\n                    if ( server[j] && netcode_server_running( server[j] ) )\n                    {\n                        server_address[num_server_addresses] = (char*) malloc( 256 ); \n\t\t\t\t\t\t#if _MSC_VER > 1600\n                        sprintf_s( server_address[num_server_addresses], 256, \"127.0.0.1:%d\", SERVER_BASE_PORT + j );\n\t\t\t\t\t\t#else\n                        sprintf( server_address[num_server_addresses], \"127.0.0.1:%d\", SERVER_BASE_PORT + j );\n\t\t\t\t\t\t#endif\n                        num_server_addresses++;\n                    }\n                }\n\n                if ( num_server_addresses > 0 && netcode_generate_connect_token( num_server_addresses, (NETCODE_CONST char**) server_address, (NETCODE_CONST char**) server_address, CONNECT_TOKEN_EXPIRY, CONNECT_TOKEN_TIMEOUT, client_id, PROTOCOL_ID, private_key, user_data, connect_token ) )\n                {\n                    netcode_client_connect( client[i], connect_token );\n                }\n\n                for ( j = 0; j < num_server_addresses; ++j )\n                {\n                    free( server_address[j] );\n                }\n            }\n            \n            if ( netcode_client_state( client[i] ) == NETCODE_CLIENT_STATE_CONNECTED ) \n            {\n                netcode_client_send_packet( client[i], packet_data, NETCODE_MAX_PACKET_SIZE );\n\n                while ( 1 )             \n                {\n                    int packet_bytes;\n                    uint64_t packet_sequence;\n                    void * packet = netcode_client_receive_packet( client[i], &packet_bytes, &packet_sequence );\n                    if ( !packet )\n                        break;\n                    (void) packet_sequence;\n                    assert( memcmp( packet, packet_data, packet_bytes ) == 0 );\n                    netcode_client_free_packet( client[i], packet );\n                }\n            }\n\n            netcode_client_update( client[i], time );\n        }\n    }\n}\n\nint main( int argc, char ** argv )\n{\n    int num_iterations = 100;\n\n    if ( argc == 2 )\n        num_iterations = atoi( argv[1] );\n\n    profile_initialize();\n\n    printf( \"profiling\" );\n\n    signal( SIGINT, interrupt_handler );\n\n    double time = 0.0;\n    double delta_time = 0.1;\n\n    if ( num_iterations > 0 )\n    {\n        int i;\n        for ( i = 0; i < num_iterations; ++i )\n        {\n            if ( quit )\n                break;\n\n            profile_iteration( time );\n\n            time += delta_time;\n        }\n    }\n    else\n    {\n        while ( !quit )\n        {\n            profile_iteration( time );\n\n            time += delta_time;\n        }\n    }\n\n    profile_shutdown();\n\t\n    return 0;\n}\n"
        },
        {
          "name": "server.c",
          "type": "blob",
          "size": 4.466796875,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"netcode.h\"\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <signal.h>\n#include <inttypes.h>\n\nstatic volatile int quit = 0;\n\nvoid interrupt_handler( int signal )\n{\n    (void) signal;\n    quit = 1;\n}\n\nstatic uint8_t private_key[NETCODE_KEY_BYTES] = { 0x60, 0x6a, 0xbe, 0x6e, 0xc9, 0x19, 0x10, 0xea, \n                                                  0x9a, 0x65, 0x62, 0xf6, 0x6f, 0x2b, 0x30, 0xe4, \n                                                  0x43, 0x71, 0xd6, 0x2c, 0xd1, 0x99, 0x27, 0x26,\n                                                  0x6b, 0x3c, 0x60, 0xf4, 0xb7, 0x15, 0xab, 0xa1 };\n\nint main( int argc, char ** argv )\n{\n    (void) argc;\n    (void) argv;\n\n    if ( netcode_init() != NETCODE_OK )\n    {\n        printf( \"error: failed to initialize netcode\\n\" );\n        return 1;\n    }\n\n    netcode_log_level( NETCODE_LOG_LEVEL_INFO );\n\n    double time = 0.0;\n    double delta_time = 1.0 / 60.0;\n\n    printf( \"[server]\\n\" );\n\n    #define TEST_PROTOCOL_ID 0x1122334455667788\n\n    char * server_address = \"127.0.0.1:40000\";\n    if ( argc == 2 )\n        server_address = argv[1];\n\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = TEST_PROTOCOL_ID;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    struct netcode_server_t * server = netcode_server_create( server_address, &server_config, time );\n\n    if ( !server )\n    {\n        printf( \"error: failed to create server\\n\" );\n        return 1;\n    }\n\n    netcode_server_start( server, NETCODE_MAX_CLIENTS );\n\n    signal( SIGINT, interrupt_handler );\n\n    uint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; ++i )\n        packet_data[i] = (uint8_t) i;\n\n    while ( !quit )\n    {\n        netcode_server_update( server, time );\n\n        if ( netcode_server_client_connected( server, 0 ) )\n        {\n            netcode_server_send_packet( server, 0, packet_data, NETCODE_MAX_PACKET_SIZE );\n        }\n\n        int client_index;\n        for ( client_index = 0; client_index < NETCODE_MAX_CLIENTS; ++client_index )\n        {\n            while ( 1 )             \n            {\n                int packet_bytes;\n                uint64_t packet_sequence;\n                void * packet = netcode_server_receive_packet( server, client_index, &packet_bytes, &packet_sequence );\n                if ( !packet )\n                    break;\n                (void) packet_sequence;\n                assert( packet_bytes == NETCODE_MAX_PACKET_SIZE );\n                assert( memcmp( packet, packet_data, NETCODE_MAX_PACKET_SIZE ) == 0 );            \n                netcode_server_free_packet( server, packet );\n            }\n        }\n\n        netcode_sleep( delta_time );\n\n        time += delta_time;\n    }\n\n    if ( quit )\n    {\n        printf( \"\\nshutting down\\n\" );\n    }\n\n    netcode_server_destroy( server );\n\n    netcode_term();\n    \n    return 0;\n}\n"
        },
        {
          "name": "soak.c",
          "type": "blob",
          "size": 10.962890625,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"netcode.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <assert.h>\n#include <signal.h>\n#include <inttypes.h>\n\n#define MAX_SERVERS 2\n#define MAX_CLIENTS 64\n#define SERVER_BASE_PORT 20000\n#define CONNECT_TOKEN_EXPIRY 45\n#define CONNECT_TOKEN_TIMEOUT 5\n#define PROTOCOL_ID 0x1122334455667788\n\nstatic volatile int quit = 0;\n\nvoid interrupt_handler( int signal )\n{\n    (void) signal;\n    quit = 1;\n}\n\nint random_int( int a, int b )\n{\n    assert( a < b );\n    int result = a + rand() % ( b - a + 1 );\n    assert( result >= a );\n    assert( result <= b );\n    return result;\n}\n\nfloat random_float( float a, float b )\n{\n    assert( a < b );\n    float random = ( (float) rand() ) / (float) RAND_MAX;\n    float diff = b - a;\n    float r = random * diff;\n    return a + r;\n}\n\nstruct netcode_server_t * server[MAX_SERVERS];\nstruct netcode_client_t * client[MAX_CLIENTS];\nuint8_t packet_data[NETCODE_MAX_PACKET_SIZE];\nuint8_t private_key[NETCODE_KEY_BYTES];\n\nvoid soak_initialize()\n{\n    printf( \"initializing\\n\" );\n\n    netcode_init();\n\n    netcode_log_level( NETCODE_LOG_LEVEL_INFO );\n\n    memset( server, 0, sizeof( server ) );\n    memset( client, 0, sizeof( client ) );\n\n    netcode_random_bytes( private_key, NETCODE_KEY_BYTES );\n\n    int i;\n    for ( i = 0; i < NETCODE_MAX_PACKET_SIZE; ++i )\n    {\n        packet_data[i] = (uint8_t) i;\n    }\n}\n\nvoid soak_shutdown()\n{\n    printf( \"shutdown\\n\" );\n\n    int i;\n\n    for ( i = 0; i < MAX_SERVERS; ++i )\n    {\n        if ( server[i] != NULL )\n        {\n            netcode_server_destroy( server[i] );\n            server[i] = NULL;\n        }\n    }\n\n    for ( i = 0; i < MAX_CLIENTS; ++i )\n    {\n        if ( client[i] != NULL )\n        {\n            netcode_client_destroy( client[i] );\n            client[i] = NULL;\n        }\n    }\n\n    netcode_term();\n}\n\nvoid soak_iteration( double time )\n{\n    int i;\n\n    /*\n    struct netcode_server_config_t server_config;\n    netcode_default_server_config( &server_config );\n    server_config.protocol_id = PROTOCOL_ID;\n    memcpy( &server_config.private_key, private_key, NETCODE_KEY_BYTES );\n\n    for ( i = 0; i < MAX_SERVERS; ++i )\n    {\n        if ( server[i] == NULL && random_int( 0, 10 ) == 0 )\n        {\n            char server_address[256];\n\t\t\t#if _MSC_VER > 1600\n\t\t\tsprintf_s( server_address, 256, \"127.0.0.1:%d\", SERVER_BASE_PORT + i );\n\t\t\t#else\n\t\t\tsprintf( server_address, \"127.0.0.1:%d\", SERVER_BASE_PORT + i );\n\t\t\t#endif\n        \n            server[i] = netcode_server_create( server_address, &server_config, time );\n\n            printf( \"created server %p\\n\", server[i] );\n        }\n\n        if ( server[i] != NULL && netcode_server_num_connected_clients( server[i] ) == netcode_server_max_clients( server[i] ) && random_int( 0, 10000 ) == 0 )\n        {\n            printf( \"destroy server %p\\n\", server[i] );\n            netcode_server_destroy( server[i] );\n            server[i] = NULL;\n        }\n    }\n    */\n\n    for ( i = 0; i < MAX_CLIENTS; ++i )\n    {\n        if ( client[i] == NULL && random_int( 0, 10 ) == 0 )\n        {\n            struct netcode_client_config_t client_config;\n            netcode_default_client_config( &client_config );\n            client[i] = netcode_client_create( \"0.0.0.0\", &client_config, time );\n            if ( client[i] != NULL )\n            {\n                printf( \"created client %d: %p\\n\", i, client[i] );\n            }\n            else\n            {\n                printf( \"failed to create client\\n\" );\n                exit( 1 );\n            }\n        }\n\n        if ( client[i] != NULL && random_int( 0, 1000 ) == 0 )\n        {\n            printf( \"destroy client %d: %p\\n\", i, client[i] );\n            netcode_client_destroy( client[i] );\n            client[i] = NULL;\n        }\n    }\n\n    /*\n    for ( i = 0; i < MAX_SERVERS; ++i )\n    {\n        if ( server[i] != NULL )\n        {\n            if ( random_int( 0, 10 ) == 0 && !netcode_server_running( server[i] ) )\n            {\n                netcode_server_start( server[i], random_int( 1, NETCODE_MAX_CLIENTS ) );\n            }\n\n            if ( random_int( 0, 1000 ) == 0 && netcode_server_num_connected_clients( server[i] ) == netcode_server_max_clients( server[i] ) && netcode_server_running( server[i] ) )\n            {\n                netcode_server_stop( server[i] );\n            }\n\n            if ( netcode_server_running( server[i] ) )\n            {\n                int max_clients = netcode_server_max_clients( server[i] );\n                int client_index;\n                for ( client_index = 0; client_index < max_clients; ++client_index )\n                {\n                    if ( netcode_server_client_connected( server[i], client_index ) )\n                    {\n                        netcode_server_send_packet( server[i], 0, packet_data, random_int( 1, NETCODE_MAX_PACKET_SIZE ) );\n                    }\n                }\n\n                for ( client_index = 0; client_index < max_clients; ++client_index )\n                {\n                    if ( netcode_server_client_connected( server[i], client_index ) )\n                    {\n                        while ( 1 )             \n                        {\n                            int packet_bytes;\n                            uint64_t packet_sequence;\n                            void * packet = netcode_server_receive_packet( server[i], client_index, &packet_bytes, &packet_sequence );\n                            if ( !packet )\n                                break;\n                            (void) packet_sequence;\n                            assert( memcmp( packet, packet_data, packet_bytes ) == 0 );            \n                            netcode_server_free_packet( server[i], packet );\n                        }\n                    }\n                }\n            }\n\n            netcode_server_update( server[i], time );\n        }  \n    }\n    */\n\n    for ( i = 0; i < MAX_CLIENTS; ++i )\n    {\n        if ( client[i] != NULL )\n        {\n            if ( random_int( 0, 10 ) == 0 && netcode_client_state( client[i] ) <= NETCODE_CLIENT_STATE_DISCONNECTED )\n            {\n                uint64_t client_id = 0;\n                netcode_random_bytes( (uint8_t*) &client_id, 8 );\n\n                uint8_t user_data[NETCODE_USER_DATA_BYTES];\n                netcode_random_bytes(user_data, NETCODE_USER_DATA_BYTES);\n\n                uint8_t connect_token[NETCODE_CONNECT_TOKEN_BYTES];\n\n                int num_server_addresses = 0;\n                char * server_address[NETCODE_MAX_SERVERS_PER_CONNECT];\n                int j;\n                for ( j = 0; j < MAX_SERVERS; ++j )\n                {\n                    if ( num_server_addresses == NETCODE_MAX_SERVERS_PER_CONNECT )\n                        break;\n\n                    if ( server[j] && netcode_server_running( server[j] ) )\n                    {\n                        server_address[num_server_addresses] = (char*) malloc( 256 ); \n\t\t\t\t\t\t#if _MSC_VER > 1600\n                        sprintf_s( server_address[num_server_addresses], 256, \"127.0.0.1:%d\", SERVER_BASE_PORT + j );\n\t\t\t\t\t\t#else\n                        sprintf( server_address[num_server_addresses], \"127.0.0.1:%d\", SERVER_BASE_PORT + j );\n\t\t\t\t\t\t#endif\n                        num_server_addresses++;\n                    }\n                }\n\n                if ( num_server_addresses > 0 && netcode_generate_connect_token( num_server_addresses, (NETCODE_CONST char**) server_address, (NETCODE_CONST char**) server_address, CONNECT_TOKEN_EXPIRY, CONNECT_TOKEN_TIMEOUT, client_id, PROTOCOL_ID, private_key, user_data, connect_token ) )\n                {\n                    netcode_client_connect( client[i], connect_token );\n                }\n\n                for ( j = 0; j < num_server_addresses; ++j )\n                {\n                    free( server_address[j] );\n                }\n            }\n            \n            if ( random_int( 0, 100 ) == 0 && netcode_client_state( client[i] ) == NETCODE_CLIENT_STATE_CONNECTED )\n            {\n                netcode_client_disconnect( client[i] );\n            }\n\n            if ( netcode_client_state( client[i] ) == NETCODE_CLIENT_STATE_CONNECTED ) \n            {\n                netcode_client_send_packet( client[i], packet_data, random_int( 1, NETCODE_MAX_PACKET_SIZE ) );\n\n                while ( 1 )             \n                {\n                    int packet_bytes;\n                    uint64_t packet_sequence;\n                    void * packet = netcode_client_receive_packet( client[i], &packet_bytes, &packet_sequence );\n                    if ( !packet )\n                        break;\n                    (void) packet_sequence;\n                    assert( memcmp( packet, packet_data, packet_bytes ) == 0 );\n                    netcode_client_free_packet( client[i], packet );\n                }\n            }\n\n            netcode_client_update( client[i], time );\n        }\n    }\n}\n\nint main( int argc, char ** argv )\n{\n    int num_iterations = -1;\n\n    if ( argc == 2 )\n        num_iterations = atoi( argv[1] );\n\n    printf( \"[soak]\\nnum_iterations = %d\\n\", num_iterations );\n\n    soak_initialize();\n\n    printf( \"starting\\n\" );\n\n    signal( SIGINT, interrupt_handler );\n\n    double time = 0.0;\n    double delta_time = 0.1;\n\n    if ( num_iterations > 0 )\n    {\n        int i;\n        for ( i = 0; i < num_iterations; ++i )\n        {\n            if ( quit )\n                break;\n\n            soak_iteration( time );\n\n            time += delta_time;\n        }\n    }\n    else\n    {\n        while ( !quit )\n        {\n            soak_iteration( time );\n\n            time += delta_time;\n        }\n    }\n\n    soak_shutdown();\n\t\n    return 0;\n}\n"
        },
        {
          "name": "sodium",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.cpp",
          "type": "blob",
          "size": 1.8642578125,
          "content": "/*\n    netcode\n\n    Copyright © 2017 - 2024, Mas Bandwidth LLC\n\n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n        1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n        2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer \n           in the documentation and/or other materials provided with the distribution.\n\n        3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived \n           from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, \n    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, \n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, \n    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define NETCODE_ENABLE_TESTS 1\n\n#include \"netcode.h\"\n#include \"netcode.c\"\n#include <stdio.h>\n#include <assert.h>\n\nint main( int argc, char ** argv )\n{\n\t(void) argc;\n\t(void) argv;\n\n    printf( \"\\n\" );\n\n\tnetcode_init();\n\n    netcode_test();\n\n    netcode_term();\n\t\n    printf( \"\\n*** ALL TESTS PASSED ***\\n\\n\" );\n\n    return 0;\n}\n"
        }
      ]
    }
  ]
}