{
  "metadata": {
    "timestamp": 1736709871948,
    "page": 357,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "winshining/nginx-http-flv-module",
      "stars": 2796,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.89453125,
          "content": "Project author:\n\n  Roman Arutyunyan\n    Moscow, Russia\n  Contacts:\n    arut@qip.ru\n    arutyunyan.roman@gmail.com\n\n  Winshining\n    Beijing, China\n  Contacts:\n    winshining@163.com\n\n  Gnolizuh\n    Beijing, China\n  Contacts:\n    huzilong_007@163.com\n    huzilong@kingsoft.com\n\n  han4235\n    Suzhou, China\n  Contacts:\n    https://github.com/han4235\n\n  plainheart\n    Zhengzhou, China\n  Contacts:\n    https://github.com/plainheart\n\n  HeyJupiter:\n    Seattle, US\n  Contacts:\n    https://github.com/HeyJupiter\n\n  Vladimir Vainer\n    -\n  Contacts:\n    https://github.com/ferreus\n\n  ever4Keny\n    China\n  Contacts:\n    https://github.com/ever4Keny\n\n  spacewander\n    Guangzhou, China\n  Contacts:\n    spacewanderlzx@gmail.com\n\n  ham3r\n    -\n  Contacts:\n    https://github.com/ham3r\n\n  deamos\n    Scranton, PA\n  Contacts:\n    https://github.com/deamos\n\n  vacing\n    Shenzhen, China\n  Contacts:\n    https://github.com/vacing\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.5419921875,
          "content": "BSD 2-Clause License\n\nCopyright (c) 2012-2017, Roman Arutyunyan\nCopyright (c) 2017-2024, Winshining\nCopyright (c) 2018, han4235, Vladimir Vainer\nCopyright (c) 2018-2019, plainheart, HeyJupiter\nCopyright (c) 2019, ever4Keny\nCopyright (c) 2020, spacewander, ham3r\nCopyright (c) 2022, deamons\nCopyright (c) 2024, vacing\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.CN.md",
          "type": "blob",
          "size": 14.853515625,
          "content": "# nginx-http-flv-module\n\n![nginx-http-flv-module workflow](https://github.com/winshining/nginx-http-flv-module/actions/workflows/nginx-http-flv-module.yml/badge.svg?branch=master)\n\n一款基于 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 的流媒体服务器。\n\n[English README](https://github.com/winshining/nginx-http-flv-module/blob/master/README.md)。\n\n如果您喜欢这个模块，可以通过赞赏来支持我的工作，非常感谢！\n\n![reward_qrcode_winshining](https://gitee.com/winshining/nginx-http-flv-module/raw/master/qrcode/reward_qrcode_winshining.png)\n\n### 感谢\n\n* Igor Sysoev，[NGINX](http://nginx.org) 的作者。\n\n* Roman Arutyunyan，[nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 的作者。\n\n* 贡献者，详情见 [AUTHORS](https://github.com/winshining/nginx-http-flv-module/blob/master/AUTHORS)。\n\n## 功能\n\n* [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 提供的所有功能。\n\n* nginx-http-flv-module 的其他功能与 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 的对比：\n\n|           功能           | nginx-http-flv-module | nginx-rtmp-module |                  备注                    |\n| :----------------------: | :-------------------: | :---------------: | :--------------------------------------: |\n|     HTTP-FLV (播放)      |           √           |         x         |     支持 HTTPS-FLV 和 chunked 回复       |\n|         GOP 缓存         |           √           |         x         |                                          |\n|         虚拟主机         |           √           |         x         |                                          |\n|   省略 `listen` 配置项   |           √           |       见备注      |        配置中必须有一个 `listen`         |\n| RTMP/HTTP-FLV 纯音频支持 |           √           |       见备注      |`wait_video` 或 `wait_key` 开启后无法工作 |\n|       HLS 单轨支持       |           √           |         x         |                                          |\n|     `reuseport` 支持     |           √           |         x         |                                          |\n|     定时打印访问记录     |           √           |         x         |                                          |\n|   JSON 风格的数据信息    |           √           |         x         |                                          |\n|      录制的数据信息      |           √           |         x         |                                          |\n|        大小端无关        |           √           |       见备注      |        `big-endian` 分支部分支持         |\n\n## 兼容性\n\n[NGINX](http://nginx.org) 的版本**应该**大于或者等于 1.2.6，与其他版本的兼容性未知。\n\n## 支持的系统\n\n* Linux（推荐）/ FreeBSD / MacOS / Windows（受限）。\n\n## 支持的播放器\n\n* [VLC](http://www.videolan.org) (RTMP & HTTP-FLV) / [OBS](https://obsproject.com) (RTMP & HTTP-FLV) / [JW Player](https://www.jwplayer.com) (RTMP) / [flv.js](https://github.com/Bilibili/flv.js) (HTTP-FLV).\n\n### 注意\n\n* Adobe 将在 2020 年 12 月 31 日之后停止对 [flash 播放器](https://www.adobe.com/products/flashplayer.html) 的官方支持，详情见 [Adobe Flash Player EOL General Information Page](https://www.adobe.com/products/flashplayer/end-of-life.html)。主流浏览器随后将移除 flash 播放器，使用 flash 播放器的插件将不再可用。\n\n* [flv.js](https://github.com/Bilibili/flv.js) 只能运行在支持 [Media Source Extensions](https://www.w3.org/TR/media-source) 的浏览器上。\n\n## 依赖\n\n* 在类 Unix 系统上，需要 GNU make，用于调用编译器来编译软件。\n\n* 在类 Unix 系统上，需要 GCC。或者在 Windows 上，需要 MSVC，用于编译软件。\n\n* 在类 Unix 系统上，需要 GDB，用于调试软件（可选）。\n\n* [FFmpeg](http://ffmpeg.org) 或者 [OBS](https://obsproject.com)，用于发布媒体流。\n\n* [VLC](http://www.videolan.org)（推荐）或者 [flv.js](https://github.com/Bilibili/flv.js)（推荐），用于播放媒体流。\n\n* 如果 NGINX 要支持正则表达式，需要 [PCRE库](http://www.pcre.org)。\n\n* 如果 NGINX 要支持加密访问，需要 [OpenSSL库](https://www.openssl.org)。\n\n* 如果 NGINX 要支持压缩，需要 [zlib库](http://www.zlib.net)。\n\n## 创建\n\n### 注意\n\nnginx-http-flv-module 包含了 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 所有的功能，所以**不要**将 nginx-http-flv-module 和 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 一起编译。\n\n### 在 Windows 上\n\n编译步骤请参考 [Building nginx on the Win32 platform with Visual C](http://nginx.org/en/docs/howto_build_on_win32.html)，不要忘了在 `Run configure script` 步骤中添加 `--add-module=/path/to/nginx-http-flv-module`。\n\n#### 注意\n\n如果使用没有完整支持 x64 的编译器来编译此模块，例如 VS2010，请务必使用默认设置（目标机器类型 x86）。\n\n### 在类 Unix 系统上\n\n下载 [NGINX](http://nginx.org) 和 nginx-http-flv-module。\n\n将它们解压到某一路径。\n\n打开 NGINX 的源代码路径并执行：\n\n#### 将模块编译进 [NGINX](http://nginx.org)\n\n    ./configure --add-module=/path/to/nginx-http-flv-module\n    make\n    make install\n\n或者\n\n#### 将模块编译为动态模块\n\n    ./configure --add-dynamic-module=/path/to/nginx-http-flv-module\n    make\n    make install\n\n#### 注意\n\n如果将模块编译为动态模块，那么 [NGINX](http://nginx.org) 的版本号**必须**大于或者等于 1.9.11。\n\n## 使用方法\n\n关于 [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) 用法的详情，请参考 [README.md](https://github.com/arut/nginx-rtmp-module/blob/master/README.md)。\n\n### 发布\n\n为了简单起见，不用转码：\n\n    ffmpeg -re -i MEDIA_FILE_NAME -c copy -f flv rtmp://example.com[:port]/appname/streamname\n\n#### 注意\n\n一些旧版本的 [FFmpeg](http://ffmpeg.org) 不支持选项 `-c copy`，可以使用选项 `-vcodec copy -acodec copy` 替代。\n\n`appname` 用于匹配 rtmp 配置块中的 application 块（更多详情见下文）。\n\n`streamname` 可以随意指定，但是**不能**省略。\n\n**RTMP 默认端口**为 **1935**，如果要使用其他端口，必须指定 `:port`。\n\n### 播放\n\n#### HTTP-FLV 方式\n\n    http://example.com[:port]/dir?[port=xxx&]app=appname&stream=streamname\n\n#### 注意\n\n* 如果使用 [ffplay](http://www.ffmpeg.org/ffplay.html) 命令行方式播放流，那么**必须**为上述的 url 加上引号，否则 url 中的参数会被丢弃（有些不太智能的 shell 会把 \"&\" 解释为\"后台运行\"）。\n\n* 如果使用 [flv.js](https://github.com/Bilibili/flv.js) 播放流，那么请保证发布的流被正确编码，因为 [flv.js](https://github.com/Bilibili/flv.js) **只支持 H.264 编码的视频和 AAC/MP3 编码的音频**。\n\n参数 `dir` 用于匹配 http 配置块中的 location 块（更多详情见下文）。\n\n**HTTP 默认端口**为 **80**, 如果使用了其他端口，必须指定 `:port`。\n\n**RTMP 默认端口**为 **1935**，如果使用了其他端口，必须指定 `port=xxx`。\n\n参数 `app` 的值（appname）用来匹配 application 块，但是如果请求的 `app` 出现在多个 server 块中，并且这些 server 块有相同的地址和端口配置，那么还需要用匹配主机名的 `server_name` 配置项来区分请求的是哪个 application 块，否则，将匹配第一个 application 块。\n\n参数 `stream` 的值（streamname）用来匹配发布的流的名称。\n\n#### 例子\n\n假设在 `http` 配置块中的 `listen` 配置项是：\n\n    http {\n        ...\n        server {\n            listen 8080; #不是默认的 80 端口\n            ...\n\n            location /live {\n                flv_live on;\n            }\n        }\n    }\n\n在 `rtmp` 配置块中的 `listen` 配置项是：\n\n    rtmp {\n        ...\n        server {\n            listen 1985; #不是默认的 1935 端口\n            ...\n\n            application myapp {\n                live on;\n            }\n        }\n    }\n\n并且发布的流的名称是 `mystream`，那么基于 HTTP 的播放 url 是：\n\n    http://example.com:8080/live?port=1985&app=myapp&stream=mystream\n\n#### 注意\n\n由于一些播放器不支持 HTTP 块传输, 这种情况下最好在指定了 `flv_live on;` 的 location 中指定 `chunked_transfer_encoding off`，否则播放会失败。\n\n#### RTMP 方式\n\n    rtmp://example.com[:port]/appname/streamname\n\n#### HLS 方式\n\n    http://example.com[:port]/dir/streamname.m3u8\n\n#### DASH 方式\n\n    http://example.com[:port]/dir/streamname.mpd\n\n## 示例图片\n\n### RTMP ([JW Player](https://www.jwplayer.com)) & HTTP-FLV ([VLC](http://www.videolan.org))\n\n![RTMP & HTTP-FLV](samples/jwplayer_vlc.png)\n\n### HTTP-FLV ([flv.js](https://github.com/Bilibili/flv.js))\n\n![HTTP-FLV](samples/flv.js.png)\n\n## nginx.conf 实例\n\n### 注意\n\n配置项 `rtmp_auto_push`，`rtmp_auto_push_reconnect` 和 `rtmp_socket_dir` 在 Windows 上不起作用，除了 Windows 10 17063 以及后续版本之外，因为多进程模式的 `relay` 需要 Unix domain socket 的支持，详情请参考 [Unix domain socket on Windows 10](https://blogs.msdn.microsoft.com/commandline/2017/12/19/af_unix-comes-to-windows)。\n\n最好将配置项 `worker_processes` 设置为 1，因为在多进程模式下，`ngx_rtmp_stat_module` 可能不会从指定的 worker 进程获取统计数据，因为 HTTP 请求是被随机分配给 worker 进程的。`ngx_rtmp_control_module` 也有同样的问题。这个问题可以通过这个补丁 [per-worker-listener](https://github.com/arut/nginx-patches/blob/master/per-worker-listener) 优化。\n\n另外，`vhost` 功能在单进程模式下没有问题，但是在多进程模式下还不能完全正确运行，等待修复。例如，下面的配置在多进程模式下是没有问题的：\n\n    rtmp {\n        ...\n        server {\n            listen 1935;\n            server_name domain_name;\n\n            application myapp {\n                ...\n            }\n        }\n    }\n\n而使用下面的配置，当 publisher 在第二个 `server` 上发布媒体流，播放请求以该配置（不管端口是不是 1935）访问非 publisher 的 worker 进程时是有问题的：\n\n    rtmp {\n        ...\n        server {\n            listen 1935;\n            server_name 1st_domain_name;\n\n            application myapp {\n                ...\n            }\n        }\n\n        server {\n            listen 1945;\n            server_name 2nd_domain_name;\n\n            application myapp {\n                ...\n            }\n        }\n    }\n\n如果 [NGINX](http://nginx.org) 是以多进程模式运行并且平台支持 socket 选项 `SO_REUSEPORT`，那么在配置项 `listen` 后添加选项 `reuseport` 可以解决惊群问题。\n\n    rtmp {\n        ...\n\n        server {\n            listen 1935 reuseport;\n            ...\n        }\n    }\n\n### 配置实例\n\n    worker_processes  1; #运行在 Windows 上时，设置为 1，因为 Windows 不支持 Unix domain socket\n    #worker_processes  auto; #1.3.8 和 1.2.5 以及之后的版本\n\n    #worker_cpu_affinity  0001 0010 0100 1000; #只能用于 FreeBSD 和 Linux\n    #worker_cpu_affinity  auto; #1.9.10 以及之后的版本\n\n    error_log logs/error.log error;\n\n    #如果此模块被编译为动态模块并且要使用与 RTMP 相关的功\n    #能时，必须指定下面的配置项并且它必须位于 events 配置\n    #项之前，否则 NGINX 启动时不会加载此模块或者加载失败\n\n    #load_module modules/ngx_http_flv_live_module.so;\n\n    events {\n        worker_connections  4096;\n    }\n\n    http {\n        include       mime.types;\n        default_type  application/octet-stream;\n\n        keepalive_timeout  65;\n\n        server {\n            listen       80;\n\n            location / {\n                root   /var/www;\n                index  index.html index.htm;\n            }\n\n            error_page   500 502 503 504  /50x.html;\n            location = /50x.html {\n                root   html;\n            }\n\n            location /live {\n                flv_live on; #打开 HTTP 播放 FLV 直播流功能\n                chunked_transfer_encoding on; #支持 'Transfer-Encoding: chunked' 方式回复\n\n                add_header 'Access-Control-Allow-Origin' '*'; #添加额外的 HTTP 头\n                add_header 'Access-Control-Allow-Credentials' 'true'; #添加额外的 HTTP 头\n            }\n\n            location /hls {\n                types {\n                    application/vnd.apple.mpegurl m3u8;\n                    video/mp2t ts;\n                }\n\n                root /tmp;\n                add_header 'Cache-Control' 'no-cache';\n            }\n\n            location /dash {\n                root /tmp;\n                add_header 'Cache-Control' 'no-cache';\n            }\n\n            location /stat {\n                #推流播放和录制统计数据的配置\n\n                rtmp_stat all;\n                rtmp_stat_stylesheet stat.xsl;\n            }\n\n            location /stat.xsl {\n                root /var/www/rtmp; #指定 stat.xsl 的位置\n            }\n\n            #如果需要 JSON 风格的 stat, 不用指定 stat.xsl\n            #但是需要指定一个新的配置项 rtmp_stat_format\n\n            #location /stat {\n            #    rtmp_stat all;\n            #    rtmp_stat_format json;\n            #}\n\n            location /control {\n                rtmp_control all; #rtmp 控制模块的配置\n            }\n        }\n    }\n\n    rtmp_auto_push on;\n    rtmp_auto_push_reconnect 1s;\n    rtmp_socket_dir /tmp;\n\n    rtmp {\n        out_queue           4096;\n        out_cork            8;\n        max_streams         128;\n        timeout             15s;\n        drop_idle_publisher 15s;\n\n        log_interval 5s; #log 模块在 access.log 中记录日志的间隔时间，对调试非常有用\n        log_size     1m; #log 模块用来记录日志的缓冲区大小\n\n        server {\n            listen 1935;\n            server_name www.test.*; #用于虚拟主机名后缀通配\n\n            application myapp {\n                live on;\n                gop_cache on; #打开 GOP 缓存，减少首屏等待时间\n            }\n\n            application hls {\n                live on;\n                hls on;\n                hls_path /tmp/hls;\n            }\n\n            application dash {\n                live on;\n                dash on;\n                dash_path /tmp/dash;\n            }\n        }\n\n        server {\n            listen 1935;\n            server_name *.test.com; #用于虚拟主机名前缀通配\n\n            application myapp {\n                live on;\n                gop_cache on; #打开 GOP 缓存，减少首屏等待时间\n            }\n        }\n\n        server {\n            listen 1935;\n            server_name www.test.com; #用于虚拟主机名完全匹配\n\n            application myapp {\n                live on;\n                gop_cache on; #打开 GOP 缓存，减少首屏等待时间\n            }\n        }\n    }\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.3125,
          "content": "# nginx-http-flv-module\n\n![nginx-http-flv-module workflow](https://github.com/winshining/nginx-http-flv-module/actions/workflows/nginx-http-flv-module.yml/badge.svg?branch=master)\n\nA media streaming server based on [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module).\n\n[中文说明](https://github.com/winshining/nginx-http-flv-module/blob/master/README.CN.md).\n\nDonate if you like this module. Many thanks to you!\n\n<a href=\"https://www.paypal.me/ShingWong\" target=\"_blank\"><img src=\"https://www.paypalobjects.com/digitalassets/c/website/marketing/apac/C2/logos-buttons/optimize/44_Grey_PayPal_Pill_Button.png\" alt=\"PayPal\" /></a>\n\n### Credits\n\n* Igor Sysoev, the creator of [NGINX](http://nginx.org).\n\n* Roman Arutyunyan, who created [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module).\n\n* Contributors, refer to [AUTHORS](https://github.com/winshining/nginx-http-flv-module/blob/master/AUTHORS) for details.\n\n## Features\n\n* All features [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) provides.\n\n* Other features provided by nginx-http-flv-module vs [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module):\n\n|         Features                   | nginx-http-flv-module | nginx-rtmp-module |                    Remarks                     |\n| :--------------------------------: | :-------------------: | :---------------: | :--------------------------------------------: |\n|        HTTP-FLV (for play)         |           √           |         x         |    HTTPS-FLV and chunked response supported    |\n|             GOP cache              |           √           |         x         |                                                |\n|            Virtual Host            |           √           |         x         |                                                |\n|      Omit `listen` directive       |           √           |    See remarks    | There MUST be at least one `listen` directive  |\n|Audio-only support for RTMP/HTTP-FLV|           √           |    See remarks    | Won't work if `wait_video` or `wait_key` is on |\n|    Single-track support for HLS    |           √           |         x         |                                                |\n|        `reuseport` support         |           √           |         x         |                                                |\n|        Timer for access log        |           √           |         x         |                                                |\n|       JSON style statistics        |           √           |         x         |                                                |\n|     Statistics for recordings      |           √           |         x         |                                                |\n|     Independent of endianness      |           √           |    See remarks    |   Partially supported in branch `big-endian`   |\n\n## Compatibility\n\nThe [NGINX](http://nginx.org) version **SHOULD** be equal to or greater than 1.2.6, the compatibility with other versions is unknown.\n\n## Systems supported\n\n* Linux (recommended) / FreeBSD / MacOS / Windows (limited).\n\n## Players supported\n\n* [VLC](http://www.videolan.org) (RTMP & HTTP-FLV) / [OBS](https://obsproject.com) (RTMP & HTTP-FLV) / [JW Player](https://www.jwplayer.com) (RTMP) / [flv.js](https://github.com/Bilibili/flv.js) (HTTP-FLV).\n\n### Note\n\n* [Flash player](https://www.adobe.com/products/flashplayer.html) will be no longer supported officially by Adobe after December 31, 2020, refer to [Adobe Flash Player EOL General Information Page](https://www.adobe.com/products/flashplayer/end-of-life.html) for details. Plugins that use flash player won't work after the major browsers subsequently remove flash player.\n\n* [flv.js](https://github.com/Bilibili/flv.js) can only run with browsers that support [Media Source Extensions](https://www.w3.org/TR/media-source).\n\n## Prerequisites\n\n* GNU make for activating compiler on Unix-like systems to compile software.\n\n* GCC for compilation on Unix-like systems or MSVC for compilation on Windows.\n\n* GDB for debug on Unix-like systems.\n\n* [FFmpeg](http://ffmpeg.org) or [OBS](https://obsproject.com) for publishing media streams.\n\n* [VLC](http://www.videolan.org) (recommended) or [flv.js](https://github.com/Bilibili/flv.js) (recommended) for playing media streams.\n\n* [PCRE](http://www.pcre.org) for NGINX if regular expressions needed.\n\n* [OpenSSL](https://www.openssl.org) for NGINX if encrypted access needed.\n\n* [zlib](http://www.zlib.net) for NGINX if compression needed.\n\n## Build\n\n### Note\n\nnginx-http-flv-module has all features that [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module) provides, so **DON'T** compile nginx-http-flv-module along with [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module).\n\n### On Windows\n\nFor details about build steps, please refer to [Building nginx on the Win32 platform with Visual C](http://nginx.org/en/docs/howto_build_on_win32.html), and don't forget to add `--add-module=/path/to/nginx-http-flv-module` in `Run configure script` step.\n\n#### Note\n\nIf some compilers which do not support x64 perfectly, VS2010 for example, are used to compile the module, please make sure that the default settings are used (target machine type x86).\n\n### On Unix-like systems\n\nDownload [NGINX](http://nginx.org) and nginx-http-flv-module.\n\nUncompress them.\n\ncd to NGINX source directory & run this:\n\n#### Compile the module into [NGINX](http://nginx.org)\n\n    ./configure --add-module=/path/to/nginx-http-flv-module\n    make\n    make install\n\nor\n\n#### Compile the module as a dynamic module\n\n    ./configure --add-dynamic-module=/path/to/nginx-http-flv-module\n    make\n    make install\n\n#### Note\n\nIf the module is compiled as a dynamic module, the [NGINX](http://nginx.org) version **MUST** be equal to or greater than 1.9.11.\n\n## Usage\n\nFor details of usages of [nginx-rtmp-module](https://github.com/arut/nginx-rtmp-module), please refer to [README.md](https://github.com/arut/nginx-rtmp-module/blob/master/README.md).\n\n### Publish\n\nFor simplicity, transcoding is not used (so **-c copy** is used):\n\n    ffmpeg -re -i MEDIA_FILE_NAME -c copy -f flv rtmp://example.com[:port]/appname/streamname\n\n#### Note\n\nSome legacy versions of [FFmpeg](http://ffmpeg.org) don't support the option `-c copy`, the options `-vcodec copy -acodec copy` can be used instead.\n\nThe `appname` is used to match an application block in rtmp block (see below for details).\n\nThe `streamname` can be specified at will but can **NOT** be omitted.\n\nThe **default port for RTMP** is **1935**, if some other ports were used, `:port` must be specified.\n\n### Play\n\n#### via HTTP-FLV\n\n    http://example.com[:port]/dir?[port=xxx&]app=appname&stream=streamname\n\n#### Note\n\n* If [ffplay](http://www.ffmpeg.org/ffplay.html) is used in command line to play the stream, the url above **MUST** be enclosed by quotation marks, or arguments in url will be discarded (some shells not so smart will interpret \"&\" as \"run in background\").\n\n* If [flv.js](https://github.com/Bilibili/flv.js) is used to play the stream, make sure that the published stream is encoded properly, for [flv.js](https://github.com/Bilibili/flv.js) supports **ONLY H.264 encoded video and AAC/MP3 encoded audio**.\n\nThe `dir` is used to match location blocks in http block (see below for details).\n\nThe **default port for HTTP** is **80**, if some other ports were used, `:port` must be specified.\n\nThe **default port for RTMP** is **1935**, if some other ports were used, `port=xxx` must be specified.\n\nThe value of `app` (appname) is used to match an application block, but if the requested `app` appears in several server blocks and those blocks have the same address and port configuration, host name matches `server_name` directive will be additionally used to identify the requested application block, otherwise the first one is matched.\n\nThe value of `stream` (streamname) is used to match the name of published stream.\n\n#### Example\n\nAssume that `listen` directive specified in `http` block is:\n\n    http {\n        ...\n        server {\n            listen 8080; #not default port 80\n            ...\n\n            location /live {\n                flv_live on;\n            }\n        }\n    }\n\nAnd `listen` directive specified in `rtmp` block is:\n\n    rtmp {\n        ...\n        server {\n            listen 1985; #not default port 1935\n            ...\n\n            application myapp {\n                live on;\n            }\n        }\n    }\n\nAnd the name of published stream is `mystream`, then the url of playback based on HTTP is:\n\n    http://example.com:8080/live?port=1985&app=myapp&stream=mystream\n\n#### Note\n\nSince some players don't support HTTP chunked transmission, it's better to specify `chunked_transfer_encoding off;` in location where `flv_live on;` is specified in this case, or play will fail.\n\n#### via RTMP\n\n    rtmp://example.com[:port]/appname/streamname\n\n#### via HLS\n\n    http://example.com[:port]/dir/streamname.m3u8\n\n#### via DASH\n\n    http://example.com[:port]/dir/streamname.mpd\n\n## Sample Pictures\n\n### RTMP ([JW Player](https://www.jwplayer.com)) & HTTP-FLV ([VLC](http://www.videolan.org))\n\n![RTMP & HTTP-FLV](samples/jwplayer_vlc.png)\n\n### HTTP-FLV ([flv.js](https://github.com/Bilibili/flv.js))\n\n![HTTP-FLV](samples/flv.js.png)\n\n## Example nginx.conf\n\n### Note\n\nThe directives `rtmp_auto_push`, `rtmp_auto_push_reconnect` and `rtmp_socket_dir` will not function on Windows except on Windows 10 17063 and later versions, because `relay` in multiple processes mode needs help of Unix domain socket, please refer to [Unix domain socket on Windows 10](https://blogs.msdn.microsoft.com/commandline/2017/12/19/af_unix-comes-to-windows) for details.\n\nIt's better to specify the directive `worker_processes` as 1, because `ngx_rtmp_stat_module` may not get statistics from a specified worker process in multi-processes mode, for HTTP requests are randomly distributed to worker processes. `ngx_rtmp_control_module` has the same problem. The problem can be optimized by this patch [per-worker-listener](https://github.com/arut/nginx-patches/blob/master/per-worker-listener).\n\nIn addtion, `vhost` feature is OK in single process mode but not perfect in multi-processes mode yet, waiting to be fixed. For example, the following configuration is OK in multi-processes mode:\n\n    rtmp {\n        ...\n        server {\n            listen 1935;\n            server_name domain_name;\n\n            application myapp {\n                ...\n            }\n        }\n    }\n\nWhile the following configuration doesn't work properly for play requests distinated to the second `server` (whether port is 1935 or not) of non-publisher worker processes:\n\n    rtmp {\n        ...\n        server {\n            listen 1935;\n            server_name 1st_domain_name;\n\n            application myapp {\n                ...\n            }\n        }\n\n        server {\n            listen 1945;\n            server_name 2nd_domain_name;\n\n            application myapp {\n                ...\n            }\n        }\n    }\n\nIf [NGINX](http://nginx.org) is running in muti-processes mode and socket option `SO_REUSEPORT` is supported by platform, adding option `reuseport` for the directive `listen` will resolve the thundering herd problem.\n\n    rtmp {\n        ...\n\n        server {\n            listen 1935 reuseport;\n            ...\n        }\n    }\n\n### Example configuration\n\n    worker_processes  1; #should be 1 for Windows, for it doesn't support Unix domain socket\n    #worker_processes  auto; #from versions 1.3.8 and 1.2.5\n\n    #worker_cpu_affinity  0001 0010 0100 1000; #only available on FreeBSD and Linux\n    #worker_cpu_affinity  auto; #from version 1.9.10\n\n    error_log logs/error.log error;\n\n    #if the module is compiled as a dynamic module and features relevant\n    #to RTMP are needed, the command below MUST be specified and MUST be\n    #located before events directive, otherwise the module won't be loaded\n    #or will be loaded unsuccessfully when NGINX is started\n\n    #load_module modules/ngx_http_flv_live_module.so;\n\n    events {\n        worker_connections  4096;\n    }\n\n    http {\n        include       mime.types;\n        default_type  application/octet-stream;\n\n        keepalive_timeout  65;\n\n        server {\n            listen       80;\n\n            location / {\n                root   /var/www;\n                index  index.html index.htm;\n            }\n\n            error_page   500 502 503 504  /50x.html;\n            location = /50x.html {\n                root   html;\n            }\n\n            location /live {\n                flv_live on; #open flv live streaming (subscribe)\n                chunked_transfer_encoding  on; #open 'Transfer-Encoding: chunked' response\n\n                add_header 'Access-Control-Allow-Origin' '*'; #add additional HTTP header\n                add_header 'Access-Control-Allow-Credentials' 'true'; #add additional HTTP header\n            }\n\n            location /hls {\n                types {\n                    application/vnd.apple.mpegurl m3u8;\n                    video/mp2t ts;\n                }\n\n                root /tmp;\n                add_header 'Cache-Control' 'no-cache';\n            }\n\n            location /dash {\n                root /tmp;\n                add_header 'Cache-Control' 'no-cache';\n            }\n\n            location /stat {\n                #configuration of streaming & recording statistics\n\n                rtmp_stat all;\n                rtmp_stat_stylesheet stat.xsl;\n            }\n\n            location /stat.xsl {\n                root /var/www/rtmp; #specify in where stat.xsl located\n            }\n\n            #if JSON style stat needed, no need to specify\n            #stat.xsl but a new directive rtmp_stat_format\n\n            #location /stat {\n            #    rtmp_stat all;\n            #    rtmp_stat_format json;\n            #}\n\n            location /control {\n                rtmp_control all; #configuration of control module of rtmp\n            }\n        }\n    }\n\n    rtmp_auto_push on;\n    rtmp_auto_push_reconnect 1s;\n    rtmp_socket_dir /tmp;\n\n    rtmp {\n        out_queue           4096;\n        out_cork            8;\n        max_streams         128;\n        timeout             15s;\n        drop_idle_publisher 15s;\n\n        log_interval 5s; #interval used by log module to log in access.log, it is very useful for debug\n        log_size     1m; #buffer size used by log module to log in access.log\n\n        server {\n            listen 1935;\n            server_name www.test.*; #for suffix wildcard matching of virtual host name\n\n            application myapp {\n                live on;\n                gop_cache on; #open GOP cache for reducing the wating time for the first picture of video\n            }\n\n            application hls {\n                live on;\n                hls on;\n                hls_path /tmp/hls;\n            }\n\n            application dash {\n                live on;\n                dash on;\n                dash_path /tmp/dash;\n            }\n        }\n\n        server {\n            listen 1935;\n            server_name *.test.com; #for prefix wildcard matching of virtual host name\n\n            application myapp {\n                live on;\n                gop_cache on; #open GOP cache for reducing the wating time for the first picture of video\n            }\n        }\n\n        server {\n            listen 1935;\n            server_name www.test.com; #for completely matching of virtual host name\n\n            application myapp {\n                live on;\n                gop_cache on; #open GOP cache for reducing the wating time for the first picture of video\n            }\n        }\n    }\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 7.4423828125,
          "content": "ngx_addon_name=\"ngx_http_flv_live_module\"\n\nRTMP_CORE_MODULES=\"                                         \\\n                ngx_rtmp_module                             \\\n                ngx_rtmp_core_module                        \\\n                ngx_rtmp_cmd_module                         \\\n                ngx_rtmp_gop_cache_module                   \\\n                ngx_rtmp_codec_module                       \\\n                ngx_rtmp_access_module                      \\\n                ngx_rtmp_record_module                      \\\n                ngx_rtmp_live_module                        \\\n                ngx_rtmp_flv_live_index_module              \\\n                ngx_rtmp_play_module                        \\\n                ngx_rtmp_flv_module                         \\\n                ngx_rtmp_mp4_module                         \\\n                ngx_rtmp_netcall_module                     \\\n                ngx_rtmp_relay_module                       \\\n                ngx_rtmp_exec_module                        \\\n                ngx_rtmp_auto_push_module                   \\\n                ngx_rtmp_auto_push_index_module             \\\n                ngx_rtmp_log_module                         \\\n                ngx_rtmp_limit_module                       \\\n                ngx_rtmp_hls_module                         \\\n                ngx_rtmp_dash_module                        \\\n                ngx_rtmp_notify_module                      \\\n                \"\n\n\nRTMP_HTTP_MODULES=\"                                         \\\n                ngx_rtmp_stat_module                        \\\n                ngx_rtmp_control_module                     \\\n                ngx_http_flv_live_module                    \\\n                \"\n\n\nRTMP_DEPS=\"                                                     \\\n                $ngx_addon_dir/ngx_rtmp_amf.h                   \\\n                $ngx_addon_dir/ngx_rtmp_bandwidth.h             \\\n                $ngx_addon_dir/ngx_rtmp_cmd_module.h            \\\n                $ngx_addon_dir/ngx_rtmp_gop_cache_module.h      \\\n                $ngx_addon_dir/ngx_rtmp_codec_module.h          \\\n                $ngx_addon_dir/ngx_rtmp_eval.h                  \\\n                $ngx_addon_dir/ngx_rtmp.h                       \\\n                $ngx_addon_dir/ngx_rtmp_version.h               \\\n                $ngx_addon_dir/ngx_rtmp_live_module.h           \\\n                $ngx_addon_dir/ngx_rtmp_netcall_module.h        \\\n                $ngx_addon_dir/ngx_rtmp_play_module.h           \\\n                $ngx_addon_dir/ngx_rtmp_record_module.h         \\\n                $ngx_addon_dir/ngx_rtmp_relay_module.h          \\\n                $ngx_addon_dir/ngx_rtmp_streams.h               \\\n                $ngx_addon_dir/ngx_rtmp_bitop.h                 \\\n                $ngx_addon_dir/ngx_rtmp_proxy_protocol.h        \\\n                $ngx_addon_dir/ngx_rtmp_variables.h             \\\n                $ngx_addon_dir/hls/ngx_rtmp_hls_module.h        \\\n                $ngx_addon_dir/hls/ngx_rtmp_mpegts.h            \\\n                $ngx_addon_dir/hls/ngx_rtmp_mpegts_crc.h        \\\n                $ngx_addon_dir/dash/ngx_rtmp_mp4.h              \\\n                \"\n\n\nRTMP_CORE_SRCS=\"                                                \\\n                $ngx_addon_dir/ngx_rtmp.c                       \\\n                $ngx_addon_dir/ngx_rtmp_init.c                  \\\n                $ngx_addon_dir/ngx_rtmp_handshake.c             \\\n                $ngx_addon_dir/ngx_rtmp_handler.c               \\\n                $ngx_addon_dir/ngx_rtmp_amf.c                   \\\n                $ngx_addon_dir/ngx_rtmp_send.c                  \\\n                $ngx_addon_dir/ngx_rtmp_shared.c                \\\n                $ngx_addon_dir/ngx_rtmp_eval.c                  \\\n                $ngx_addon_dir/ngx_rtmp_receive.c               \\\n                $ngx_addon_dir/ngx_rtmp_core_module.c           \\\n                $ngx_addon_dir/ngx_rtmp_cmd_module.c            \\\n                $ngx_addon_dir/ngx_rtmp_gop_cache_module.c      \\\n                $ngx_addon_dir/ngx_rtmp_codec_module.c          \\\n                $ngx_addon_dir/ngx_rtmp_access_module.c         \\\n                $ngx_addon_dir/ngx_rtmp_record_module.c         \\\n                $ngx_addon_dir/ngx_rtmp_live_module.c           \\\n                $ngx_addon_dir/ngx_rtmp_flv_live_index_module.c \\\n                $ngx_addon_dir/ngx_rtmp_play_module.c           \\\n                $ngx_addon_dir/ngx_rtmp_flv_module.c            \\\n                $ngx_addon_dir/ngx_rtmp_mp4_module.c            \\\n                $ngx_addon_dir/ngx_rtmp_netcall_module.c        \\\n                $ngx_addon_dir/ngx_rtmp_relay_module.c          \\\n                $ngx_addon_dir/ngx_rtmp_bandwidth.c             \\\n                $ngx_addon_dir/ngx_rtmp_exec_module.c           \\\n                $ngx_addon_dir/ngx_rtmp_auto_push_module.c      \\\n                $ngx_addon_dir/ngx_rtmp_notify_module.c         \\\n                $ngx_addon_dir/ngx_rtmp_log_module.c            \\\n                $ngx_addon_dir/ngx_rtmp_limit_module.c          \\\n                $ngx_addon_dir/ngx_rtmp_bitop.c                 \\\n                $ngx_addon_dir/ngx_rtmp_proxy_protocol.c        \\\n                $ngx_addon_dir/ngx_rtmp_variables.c             \\\n                $ngx_addon_dir/ngx_rtmp_parse.c                 \\\n                $ngx_addon_dir/hls/ngx_rtmp_hls_module.c        \\\n                $ngx_addon_dir/dash/ngx_rtmp_dash_module.c      \\\n                $ngx_addon_dir/hls/ngx_rtmp_mpegts.c            \\\n                $ngx_addon_dir/hls/ngx_rtmp_mpegts_crc.c        \\\n                $ngx_addon_dir/dash/ngx_rtmp_mp4.c              \\\n                \"\n\n\nRTMP_HTTP_DEPS=\"                                                \\\n                $ngx_addon_dir/ngx_http_flv_live_module.h       \\\n                \"\n\n\nRTMP_HTTP_SRCS=\"                                                \\\n                $ngx_addon_dir/ngx_rtmp_stat_module.c           \\\n                $ngx_addon_dir/ngx_rtmp_control_module.c        \\\n                $ngx_addon_dir/ngx_http_flv_live_module.c       \\\n                \"\n\nif [ -f auto/module ] ; then\n    ngx_module_incs=$ngx_addon_dir\n    ngx_module_deps=\"$RTMP_DEPS $RTMP_HTTP_DEPS\"\n\n    if [ $ngx_module_link = DYNAMIC ] ; then\n        ngx_module_name=\"$ngx_addon_name $RTMP_CORE_MODULES $RTMP_HTTP_MODULES\"\n        ngx_module_srcs=\"$RTMP_CORE_SRCS $RTMP_HTTP_SRCS\"\n\n        . auto/module\n\n        dynamic_modules=`eval echo '$'\"${ngx_module}_MODULES\" | sed -e \"s/ \\{0,\\}$ngx_addon_name//\"`\n        eval ${ngx_module}_MODULES=\\\"$dynamic_modules\\\"\n        unset dynamic_modules\n\n        order_modules=`eval echo '$'\"${ngx_module}_ORDER\"`\n        if [ -n \"$order_modules\" ]\n        then\n            eval ${ngx_module}_ORDER=\\\"`echo \"$order_modules\" | sed -e \"s/ \\{0,\\}$ngx_addon_name//\"`\\\"\n            unset order_modules\n        fi\n    else\n        ngx_module_type=CORE\n        ngx_module_name=$RTMP_CORE_MODULES\n        ngx_module_deps=$RTMP_DEPS\n        ngx_module_srcs=$RTMP_CORE_SRCS\n\n        . auto/module\n\n\n        ngx_module_type=HTTP\n        ngx_module_name=$RTMP_HTTP_MODULES\n        ngx_module_deps=$RTMP_HTTP_DEPS\n        ngx_module_srcs=$RTMP_HTTP_SRCS\n\n        . auto/module\n    fi\n\nelse\n    CORE_MODULES=\"$CORE_MODULES $RTMP_CORE_MODULES\"\n    HTTP_MODULES=\"$HTTP_MODULES $RTMP_HTTP_MODULES\"\n\n    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $RTMP_DEPS $RTMP_HTTP_DEPS\"\n    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $RTMP_CORE_SRCS $RTMP_HTTP_SRCS\"\n\n    CFLAGS=\"$CFLAGS -I$ngx_addon_dir\"\nfi\n\nUSE_OPENSSL=YES\n\n"
        },
        {
          "name": "dash",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "hls",
          "type": "tree",
          "content": null
        },
        {
          "name": "ngx_http_flv_live_module.c",
          "type": "blob",
          "size": 67.8720703125,
          "content": "\n/*\n * Copyright (C) Winshining\n */\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include \"ngx_http_flv_live_module.h\"\n#include \"ngx_rtmp_bandwidth.h\"\n\n\nstatic ngx_rtmp_play_pt         next_play;\nstatic ngx_rtmp_close_stream_pt next_close_stream;\n\n\nngx_rtmp_play_pt                http_flv_live_next_play;\nngx_rtmp_close_stream_pt        http_flv_live_next_close_stream;\n\n\nstatic ngx_int_t ngx_http_flv_live_init(ngx_conf_t *cf);\nstatic void *ngx_http_flv_live_create_loc_conf(ngx_conf_t *cf);\nstatic char *ngx_http_flv_live_merge_loc_conf(ngx_conf_t *cf,\n    void *parent, void *child);\n\n\nstatic ngx_int_t ngx_http_flv_live_handler(ngx_http_request_t *r);\nstatic void ngx_http_flv_live_cleanup(void *data);\nstatic ngx_int_t ngx_http_flv_live_init_process(ngx_cycle_t *cycle);\n\nstatic void ngx_http_flv_live_send_tail(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_http_flv_live_send_message(ngx_rtmp_session_t *s,\n    ngx_chain_t *out, ngx_uint_t priority);\nstatic ngx_chain_t *ngx_http_flv_live_meta_message(ngx_rtmp_session_t *,\n    ngx_chain_t *in);\nstatic ngx_chain_t *ngx_http_flv_live_append_message(ngx_rtmp_session_t *s,\n    ngx_rtmp_header_t *h, ngx_rtmp_header_t *lh, ngx_chain_t *in);\nstatic void ngx_http_flv_live_free_message(ngx_rtmp_session_t *s,\n    ngx_chain_t *in);\nstatic ngx_int_t ngx_http_flv_live_join(ngx_rtmp_session_t *s, u_char *name,\n    unsigned int publisher);\nstatic ngx_chain_t *ngx_http_flv_live_append_shared_bufs(\n    ngx_rtmp_core_srv_conf_t *cscf, ngx_rtmp_header_t *h, ngx_chain_t *in,\n    ngx_flag_t chunked);\n\nstatic void ngx_http_flv_live_close_http_request(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_http_flv_live_headers_filter(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_http_flv_live_header_filter(ngx_rtmp_session_t *s);\n\n#if (nginx_version <= 1003014)\nstatic void ngx_http_do_free_request(ngx_http_request_t *r, ngx_int_t rc);\nstatic void ngx_http_do_log_request(ngx_http_request_t *r);\n#endif\n\n\ntypedef struct ngx_http_header_val_s  ngx_http_header_val_t;\n\ntypedef ngx_int_t (*ngx_http_set_header_pt)(ngx_http_request_t *r,\n    ngx_http_header_val_t *hv, ngx_str_t *value);\n\n\ntypedef struct {\n    ngx_str_t                  name;\n    ngx_uint_t                 offset;\n    ngx_http_set_header_pt     handler;\n} ngx_http_set_header_t;\n\n\nstruct ngx_http_header_val_s {\n    ngx_http_complex_value_t   value;\n    ngx_str_t                  key;\n    ngx_http_set_header_pt     handler;\n    ngx_uint_t                 offset;\n#if (nginx_version >= 1007005)\n    ngx_uint_t                 always;  /* unsigned  always:1 */\n#endif\n};\n\n\ntypedef enum {\n    NGX_HTTP_EXPIRES_OFF,\n} ngx_http_expires_t;\n\n\ntypedef struct {\n    ngx_http_expires_t         expires;\n    time_t                     expires_time;\n#if (nginx_version >= 1007009)\n    ngx_http_complex_value_t  *expires_value;\n#endif\n    ngx_array_t               *headers;\n} ngx_http_headers_conf_t;\n\n\nextern ngx_module_t    ngx_http_headers_filter_module;\n\n\nstatic u_char ngx_http_server_string[] = \"Server: nginx\" CRLF;\nstatic u_char ngx_http_server_full_string[] = \"Server: \" NGINX_VER CRLF;\n#if (nginx_version >= 1011010)\nstatic u_char ngx_http_server_build_string[] = \"Server: \" NGINX_VER_BUILD CRLF;\n#endif\n\n\nstatic ngx_str_t ngx_http_status_lines[] = {\n\n    ngx_string(\"200 OK\"),\n    ngx_null_string,  /* \"201 Created\" */\n    ngx_null_string,  /* \"202 Accepted\" */\n    ngx_null_string,  /* \"203 Non-Authoritative Information\" */\n    ngx_null_string,  /* \"204 No Content\" */\n    ngx_null_string,  /* \"205 Reset Content\" */\n    ngx_null_string,  /* \"206 Partial Content\" */\n\n    /* ngx_null_string, */  /* \"207 Multi-Status\" */\n\n#define NGX_HTTP_LAST_2XX  207\n#define NGX_HTTP_OFF_3XX   (NGX_HTTP_LAST_2XX - 200)\n\n    /* ngx_null_string, */  /* \"300 Multiple Choices\" */\n\n    ngx_string(\"301 Moved Permanently\"),\n    ngx_string(\"302 Moved Temporarily\"),\n    ngx_null_string,  /* \"303 See Other\" */\n    ngx_null_string,  /* \"304 Not Modified\" */\n    ngx_null_string,  /* \"305 Use Proxy\" */\n    ngx_null_string,  /* \"306 unused\" */\n    ngx_string(\"307 Temporary Redirect\"),\n\n#define NGX_HTTP_LAST_3XX  308\n#define NGX_HTTP_OFF_4XX   (NGX_HTTP_LAST_3XX - 301 + NGX_HTTP_OFF_3XX)\n\n    ngx_string(\"400 Bad Request\"),\n    ngx_null_string,  /* \"401 Unauthorized\" */\n    ngx_null_string,  /* \"402 Payment Required\" */\n    ngx_string(\"403 Forbidden\"),\n    ngx_string(\"404 Not Found\"),\n    ngx_string(\"405 Not Allowed\"),\n    ngx_null_string,  /* \"406 Not Acceptable\" */\n    ngx_null_string,  /* \"407 Proxy Authentication Required\" */\n    ngx_null_string,  /* \"408 Request Time-out\" */\n    ngx_null_string,  /* \"409 Conflict\" */\n    ngx_null_string,  /* \"410 Gone\" */\n    ngx_null_string,  /* \"411 Length Required\" */\n    ngx_null_string,  /* \"412 Precondition Failed\" */\n    ngx_null_string,  /* \"413 Request Entity Too Large\" */\n    ngx_null_string,  /* \"414 Request-URI Too Large\" */\n    ngx_null_string,  /* \"415 Unsupported Media Type\" */\n    ngx_null_string,  /* \"416 Requested Range Not Satisfiable\" */\n    ngx_null_string,  /* \"417 Expectation Failed\" */\n    ngx_null_string,  /* \"418 unused\" */\n    ngx_null_string,  /* \"419 unused\" */\n    ngx_null_string,  /* \"420 unused\" */\n    ngx_null_string,  /* \"421 Misdirected Request\" */\n\n    /* ngx_null_string, */  /* \"422 Unprocessable Entity\" */\n    /* ngx_null_string, */  /* \"423 Locked\" */\n    /* ngx_null_string, */  /* \"424 Failed Dependency\" */\n\n#define NGX_HTTP_LAST_4XX  422\n#define NGX_HTTP_OFF_5XX   (NGX_HTTP_LAST_4XX - 400 + NGX_HTTP_OFF_4XX)\n\n    ngx_string(\"500 Internal Server Error\"),\n    ngx_null_string,  /* \"501 Not Implemented\" */\n    ngx_null_string,  /* \"502 Bad Gateway\" */\n    ngx_string(\"503 Service Temporarily Unavailable\"),\n    ngx_null_string,  /* \"504 Gateway Time-out\" */\n    ngx_null_string,        /* \"505 HTTP Version Not Supported\" */\n    ngx_null_string,        /* \"506 Variant Also Negotiates\" */\n    ngx_null_string,  /* \"507 Insufficient Storage\" */\n\n    /* ngx_null_string, */  /* \"508 unused\" */\n    /* ngx_null_string, */  /* \"509 unused\" */\n    /* ngx_null_string, */  /* \"510 Not Extended\" */\n\n#define NGX_HTTP_LAST_5XX  508\n\n};\n\n\nextern ngx_rtmp_live_proc_handler_t  ngx_rtmp_live_proc_handler;\nstatic ngx_rtmp_live_proc_handler_t  ngx_http_flv_live_proc_handler = {\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    ngx_http_flv_live_send_message,\n    ngx_http_flv_live_meta_message,\n    ngx_http_flv_live_append_message,\n    ngx_http_flv_live_free_message\n};\n\nngx_rtmp_live_proc_handler_t  *ngx_rtmp_live_proc_handlers[] = {\n    &ngx_rtmp_live_proc_handler,\n    &ngx_http_flv_live_proc_handler\n};\n\n\nstatic ngx_int_t ngx_http_flv_live_init_handlers(ngx_cycle_t *cycle);\n\n\nstatic ngx_int_t ngx_http_flv_live_request(ngx_rtmp_session_t *s,\n    ngx_rtmp_header_t *h, ngx_chain_t *in);\n\nstatic void ngx_http_flv_live_free_request(ngx_rtmp_session_t *s);\n\n\nstatic void ngx_http_flv_live_read_handler(ngx_event_t *rev);\nstatic void ngx_http_flv_live_write_handler(ngx_event_t *wev);\n\nstatic ngx_int_t ngx_http_flv_live_send(ngx_rtmp_session_t *s);\nstatic void ngx_http_flv_live_correct_timestamp(ngx_rtmp_session_t *s,\n    ngx_flag_t correct);\n\nstatic ngx_int_t ngx_http_flv_live_preprocess(ngx_http_request_t *r,\n    ngx_rtmp_connection_t *rconn);\n\nstatic ngx_rtmp_session_t *ngx_http_flv_live_init_connection(\n    ngx_http_request_t *r, ngx_rtmp_connection_t *rconn);\nstatic ngx_rtmp_session_t *ngx_http_flv_live_init_session(\n    ngx_http_request_t *r, ngx_rtmp_addr_conf_t *add_conf);\nstatic ngx_int_t ngx_http_flv_live_connect_init(ngx_rtmp_session_t *s,\n    ngx_str_t *app, ngx_str_t *stream);\n\n\nstatic ngx_http_module_t ngx_http_flv_live_module_ctx = {\n    NULL,\n    ngx_http_flv_live_init,            /* postconfiguration */\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    ngx_http_flv_live_create_loc_conf, /* create location configuration */\n    ngx_http_flv_live_merge_loc_conf   /* merge location configuration */\n};\n\n\nstatic ngx_command_t ngx_http_flv_live_commands[] = {\n    { ngx_string(\"flv_live\"),\n      NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_http_flv_live_conf_t, flv_live),\n      NULL },\n\n    ngx_null_command\n};\n\n\nngx_module_t ngx_http_flv_live_module = {\n    NGX_MODULE_V1,\n    &ngx_http_flv_live_module_ctx,\n    ngx_http_flv_live_commands,\n    NGX_HTTP_MODULE,\n    NULL,\n    NULL,\n    ngx_http_flv_live_init_process,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_int_t\nngx_http_flv_live_init(ngx_conf_t *cf)\n{\n    ngx_http_handler_pt       *h;\n    ngx_http_core_main_conf_t *cmcf;\n\n    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);\n\n    /* insert in the NGX_HTTP_CONTENT_PHASE */\n    h = ngx_array_push(&cmcf->phases[NGX_HTTP_CONTENT_PHASE].handlers);\n    if (h == NULL) {\n        return NGX_ERROR;\n    }\n\n    *h = ngx_http_flv_live_handler;\n\n    return NGX_OK;\n}\n\n\nstatic void *\nngx_http_flv_live_create_loc_conf(ngx_conf_t *cf)\n{\n    ngx_http_flv_live_conf_t  *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_flv_live_conf_t));\n    if (conf == NULL) {\n        return NULL;\n    }\n\n    conf->flv_live = NGX_CONF_UNSET;\n\n    return (void *) conf;\n}\n\n\nstatic char *\nngx_http_flv_live_merge_loc_conf(ngx_conf_t *cf,\n    void *parent, void *child)\n{\n    ngx_http_flv_live_conf_t *prev = parent;\n    ngx_http_flv_live_conf_t *conf = child;\n\n    ngx_conf_merge_value(conf->flv_live, prev->flv_live, 0);\n\n    return NGX_CONF_OK;\n}\n\n\nngx_int_t\nngx_http_flv_live_init_handlers(ngx_cycle_t *cycle)\n{\n    ngx_rtmp_core_main_conf_t *cmcf;\n    ngx_rtmp_handler_pt       *h;\n\n    cmcf = ngx_rtmp_cycle_get_module_main_conf(cycle, ngx_rtmp_core_module);\n    if (cmcf == NULL) {\n        return NGX_OK;\n    }\n\n    /* rtmp live conf aready exsits, so add additional event handlers */\n    h = ngx_array_push(&cmcf->events[NGX_HTTP_FLV_LIVE_REQUEST]);\n    *h = ngx_http_flv_live_request;\n\n    next_play = http_flv_live_next_play;\n    next_close_stream = http_flv_live_next_close_stream;\n\n    http_flv_live_next_play = NULL;\n    http_flv_live_next_close_stream = NULL;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_init_process(ngx_cycle_t *cycle)\n{\n    return ngx_http_flv_live_init_handlers(cycle);\n}\n\n\n/*\n * chunk format:\n * hex1\\r\\n\n * content1(hex1)\\r\\n\n * hex2\\r\\n\n * content2(hex2)\\r\\n\n * ...\n * 0\\r\\n\\r\\n\n */\nngx_int_t\nngx_http_flv_live_send_header(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t        *cscf;\n    ngx_http_core_loc_conf_t        *clcf;\n    ngx_http_request_t              *r;\n    ngx_rtmp_live_ctx_t             *live_ctx;\n    ngx_rtmp_codec_ctx_t            *codec_ctx;\n    ngx_list_part_t                 *part;\n    ngx_table_elt_t                 *e, *header;\n    u_char                          *p;\n    ngx_chain_t                      cl_flv_hdr, *pkt;\n    ngx_buf_t                        buf_flv_hdr;\n    ngx_uint_t                       i;\n    ngx_str_t                        chunked_flv_header;\n    ngx_str_t                        consec_flv_header;\n    u_char                           chunked_flv_header_data[18];\n    ngx_flag_t                       connection_header;\n\n    /**\n     * |F|L|V|ver|00000101|header_size|0|0|0|0|, ngx_http_flv_module.c\n     * for more details, please refer to http://www.adobe.com/devnet/f4v.html\n     **/\n    u_char flv_header[] = \"FLV\\x1\\0\\0\\0\\0\\x9\\0\\0\\0\\0\";\n\n    r = s->data;\n\n    r->headers_out.status = NGX_HTTP_OK;\n\n    ngx_str_set(&r->headers_out.content_type, \"video/x-flv\");\n\n    /* fill HTTP header 'Connection' according to headers_in */\n    r->keepalive = 0;\n\n    connection_header = 0;\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (header[i].hash == 0) {\n            continue;\n        }\n\n        if (ngx_strcasecmp(header[i].key.data, (u_char *) \"connection\") == 0) {\n            connection_header = 1;\n            if (ngx_strcasecmp(header[i].value.data, (u_char *) \"keep-alive\")\n                == 0)\n            {\n                r->keepalive = 1;\n            }\n\n            break;\n        }\n    }\n\n    if (!connection_header && r->http_version == NGX_HTTP_VERSION_11) {\n        r->keepalive = 1;\n    }\n\n    live_ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (live_ctx && !live_ctx->active) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                \"flv live: try to send header when session not active\");\n\n        return NGX_ERROR;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    codec_ctx = ngx_rtmp_get_module_ctx(s->publisher, ngx_rtmp_codec_module);\n    if (codec_ctx->video_codec_id != 0) {\n        flv_header[4] |= 0x1;\n    }\n\n    if (codec_ctx->audio_codec_id != 0\n        && codec_ctx->audio_codec_id != NGX_RTMP_AUDIO_UNCOMPRESSED)\n    {\n        flv_header[4] |= (0x1 << 2);\n    }\n\n    if (clcf->chunked_transfer_encoding &&\n        r->http_version == NGX_HTTP_VERSION_11)\n    {\n        r->chunked = 1;\n\n        p = chunked_flv_header_data;\n        *p++ = 'd';\n        *p++ = CR;\n        *p++ = LF;\n        ngx_memmove(p, flv_header, 13);\n        p += 13;\n        *p++ = CR;\n        *p++ = LF;\n        chunked_flv_header.data = chunked_flv_header_data;\n        chunked_flv_header.len = 18;\n\n        buf_flv_hdr.pos = chunked_flv_header.data;\n        buf_flv_hdr.last = chunked_flv_header.data + chunked_flv_header.len;\n    } else {\n        consec_flv_header.data = flv_header;\n        consec_flv_header.len = 13;\n\n        buf_flv_hdr.pos = consec_flv_header.data;\n        buf_flv_hdr.last = consec_flv_header.data + consec_flv_header.len;\n    }\n\n    e = r->headers_out.expires;\n    if (e == NULL) {\n\n        e = ngx_list_push(&r->headers_out.headers);\n        if (e == NULL) {\n            return NGX_ERROR;\n        }\n\n        r->headers_out.expires = e;\n\n        e->hash = 1;\n        ngx_str_set(&e->key, \"Expires\");\n    }\n\n    e->value.data = (u_char *) \"-1\";\n    e->value.len = ngx_strlen(\"-1\");\n\n    if (ngx_http_flv_live_headers_filter(s) == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    buf_flv_hdr.start = buf_flv_hdr.pos;\n    buf_flv_hdr.end = buf_flv_hdr.last;\n\n    cl_flv_hdr.buf = &buf_flv_hdr;\n    cl_flv_hdr.next = NULL;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    pkt = ngx_rtmp_append_shared_bufs(cscf, NULL, &cl_flv_hdr);\n    if (pkt == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_http_flv_live_send_message(s, pkt, 0);\n    ngx_rtmp_free_shared_chain(cscf, pkt);\n\n    return NGX_OK;\n}\n\n\n/**\n * for adding non-standard HTTP headers \n **/\nstatic ngx_int_t\nngx_http_flv_live_headers_filter(ngx_rtmp_session_t *s)\n{\n    ngx_str_t                 value;\n    ngx_uint_t                i;\n#if (nginx_version >= 1007005)\n    ngx_uint_t                safe_status;\n#endif\n    ngx_http_header_val_t    *h;\n    ngx_http_headers_conf_t  *conf;\n    ngx_http_request_t       *r;\n\n    r = s->data;\n\n    conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module);\n\n    /* force */\n    conf->expires = NGX_HTTP_EXPIRES_OFF;\n\n    if (conf->headers == NULL) {\n        return ngx_http_flv_live_header_filter(s);\n    }\n\n#if (nginx_version >= 1007005)\n    switch (r->headers_out.status) {\n\n    case NGX_HTTP_OK:\n    case NGX_HTTP_CREATED:\n    case NGX_HTTP_NO_CONTENT:\n    case NGX_HTTP_PARTIAL_CONTENT:\n    case NGX_HTTP_MOVED_PERMANENTLY:\n    case NGX_HTTP_MOVED_TEMPORARILY:\n    case NGX_HTTP_SEE_OTHER:\n    case NGX_HTTP_NOT_MODIFIED:\n    case NGX_HTTP_TEMPORARY_REDIRECT:\n        safe_status = 1;\n        break;\n\n    default:\n        safe_status = 0;\n    }\n#endif\n\n    if (conf->headers) {\n        h = conf->headers->elts;\n        for (i = 0; i < conf->headers->nelts; i++) {\n\n#if (nginx_version >= 1007005)\n            if (!safe_status && !h[i].always) {\n                continue;\n            }\n#endif\n\n            if (ngx_http_complex_value(r, &h[i].value, &value) != NGX_OK) {\n                return NGX_ERROR;\n            }\n\n            if (h[i].handler(r, &h[i], &value) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_flv_live_header_filter(s);\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_header_filter(ngx_rtmp_session_t *s)\n{\n    u_char                    *p;\n    size_t                     len;\n    ngx_str_t                  *status_line;\n    ngx_buf_t                 *b;\n    ngx_uint_t                 status, i;\n    ngx_chain_t                out, *pkt;\n    ngx_list_part_t           *part;\n    ngx_table_elt_t           *header;\n    ngx_http_core_loc_conf_t  *clcf;\n    ngx_rtmp_core_srv_conf_t  *cscf;\n    ngx_http_request_t        *r;\n\n    r = s->data;\n\n    if (r->header_sent) {\n        return NGX_OK;\n    }\n\n    r->header_sent = 1;\n\n    if (r->chunked && r->http_version < NGX_HTTP_VERSION_11) {\n        ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,\n                      \"flv live: chunked only supported by HTTP/1.1\");\n\n        r->chunked = 0;\n    }\n\n    len = sizeof(\"HTTP/1.x \") - 1 + sizeof(CRLF) - 1\n          /* the end of the header */\n          + sizeof(CRLF) - 1;\n\n    /* status line */\n\n    if (r->headers_out.status_line.len) {\n        len += r->headers_out.status_line.len;\n        status_line = &r->headers_out.status_line;\n#if (NGX_SUPPRESS_WARN)\n        status = 0;\n#endif\n\n    } else {\n\n        status = r->headers_out.status;\n\n        if (status >= NGX_HTTP_OK\n            && status < NGX_HTTP_LAST_2XX)\n        {\n            /* 2XX */\n\n            status -= NGX_HTTP_OK;\n            status_line = &ngx_http_status_lines[status];\n            len += ngx_http_status_lines[status].len;\n\n        } else if (status >= NGX_HTTP_MOVED_PERMANENTLY\n                   && status < NGX_HTTP_LAST_3XX)\n        {\n            /* 3XX */\n\n            status = status - NGX_HTTP_MOVED_PERMANENTLY + NGX_HTTP_OFF_3XX;\n            status_line = &ngx_http_status_lines[status];\n            len += ngx_http_status_lines[status].len;\n\n        } else if (status >= NGX_HTTP_BAD_REQUEST\n                   && status < NGX_HTTP_LAST_4XX)\n        {\n            /* 4XX */\n            status = status - NGX_HTTP_BAD_REQUEST\n                            + NGX_HTTP_OFF_4XX;\n\n            status_line = &ngx_http_status_lines[status];\n            len += ngx_http_status_lines[status].len;\n\n        } else if (status >= NGX_HTTP_INTERNAL_SERVER_ERROR\n                   && status < NGX_HTTP_LAST_5XX)\n        {\n            /* 5XX */\n            status = status - NGX_HTTP_INTERNAL_SERVER_ERROR\n                            + NGX_HTTP_OFF_5XX;\n\n            status_line = &ngx_http_status_lines[status];\n            len += ngx_http_status_lines[status].len;\n\n        } else {\n            len += NGX_INT_T_LEN + 1 /* SP */;\n            status_line = NULL;\n        }\n\n        if (status_line && status_line->len == 0) {\n            status = r->headers_out.status;\n            len += NGX_INT_T_LEN + 1 /* SP */;\n            status_line = NULL;\n        }\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (r->headers_out.server == NULL) {\n#if (nginx_version >= 1011010)\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            len += sizeof(ngx_http_server_full_string) - 1;\n\n        } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n            len += sizeof(ngx_http_server_build_string) - 1;\n\n        } else {\n            len += sizeof(ngx_http_server_string) - 1;\n        }\n#else\n        len += clcf->server_tokens ? sizeof(ngx_http_server_full_string) - 1 :\n                                     sizeof(ngx_http_server_string) - 1;\n#endif\n    }\n\n    if (r->headers_out.date == NULL) {\n        len += sizeof(\"Date: Mon, 28 Sep 1970 06:00:00 GMT\" CRLF) - 1;\n    }\n\n    if (r->headers_out.content_type.len) {\n        len += sizeof(\"Content-Type: \") - 1\n               + r->headers_out.content_type.len + 2;\n\n        if (r->headers_out.content_type_len == r->headers_out.content_type.len\n            && r->headers_out.charset.len)\n        {\n            len += sizeof(\"; charset=\") - 1 + r->headers_out.charset.len;\n        }\n    }\n\n    if (r->headers_out.content_length == NULL\n        && r->headers_out.content_length_n >= 0)\n    {\n        len += sizeof(\"Content-Length: \") - 1 + NGX_OFF_T_LEN + 2;\n    }\n\n    if (r->headers_out.last_modified == NULL\n        && r->headers_out.last_modified_time != -1)\n    {\n        len += sizeof(\"Last-Modified: Mon, 28 Sep 1970 06:00:00 GMT\" CRLF) - 1;\n    }\n\n    if (r->chunked) {\n        len += sizeof(\"Transfer-Encoding: chunked\" CRLF) - 1;\n    }\n\n    if (r->keepalive) {\n        len += sizeof(\"Connection: keep-alive\" CRLF) - 1;\n\n        /*\n         * MSIE and Opera ignore the \"Keep-Alive: timeout=<N>\" header.\n         * MSIE keeps the connection alive for about 60-65 seconds.\n         * Opera keeps the connection alive very long.\n         * Mozilla keeps the connection alive for N plus about 1-10 seconds.\n         * Konqueror keeps the connection alive for about N seconds.\n         */\n\n        if (clcf->keepalive_header) {\n            len += sizeof(\"Keep-Alive: timeout=\") - 1 + NGX_TIME_T_LEN + 2;\n        }\n\n    } else {\n        len += sizeof(\"Connection: close\" CRLF) - 1;\n    }\n\n    part = &r->headers_out.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (header[i].hash == 0) {\n            continue;\n        }\n\n        len += header[i].key.len + sizeof(\": \") - 1 + header[i].value.len\n               + sizeof(CRLF) - 1;\n    }\n\n    b = ngx_create_temp_buf(r->pool, len);\n    if (b == NULL) {\n        return NGX_ERROR;\n    }\n\n    /* \"HTTP/1.x \" */\n    if (r->http_version == NGX_HTTP_VERSION_10) {\n        b->last = ngx_cpymem(b->last, \"HTTP/1.0 \", sizeof(\"HTTP/1.x \") - 1);\n    } else {\n        b->last = ngx_cpymem(b->last, \"HTTP/1.1 \", sizeof(\"HTTP/1.x \") - 1);\n    }\n\n    /* status line */\n    if (status_line) {\n        b->last = ngx_copy(b->last, status_line->data, status_line->len);\n\n    } else {\n        b->last = ngx_sprintf(b->last, \"%03ui \", status);\n    }\n    *b->last++ = CR; *b->last++ = LF;\n\n    if (r->headers_out.server == NULL) {\n#if (nginx_version >= 1011010)\n        if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {\n            p = ngx_http_server_full_string;\n            len = sizeof(ngx_http_server_full_string) - 1;\n\n        } else if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_BUILD) {\n            p = ngx_http_server_build_string;\n            len = sizeof(ngx_http_server_build_string) - 1;\n\n        } else {\n#else\n        if (clcf->server_tokens) {\n            p = (u_char *) ngx_http_server_full_string;\n            len = sizeof(ngx_http_server_full_string) - 1;\n\n        } else {\n#endif\n            p = ngx_http_server_string;\n            len = sizeof(ngx_http_server_string) - 1;\n        }\n\n        b->last = ngx_cpymem(b->last, p, len);\n    }\n\n    if (r->headers_out.date == NULL) {\n        b->last = ngx_cpymem(b->last, \"Date: \", sizeof(\"Date: \") - 1);\n        b->last = ngx_cpymem(b->last, ngx_cached_http_time.data,\n                             ngx_cached_http_time.len);\n\n        *b->last++ = CR; *b->last++ = LF;\n    }\n\n    if (r->headers_out.content_type.len) {\n        b->last = ngx_cpymem(b->last, \"Content-Type: \",\n                             sizeof(\"Content-Type: \") - 1);\n        p = b->last;\n        b->last = ngx_copy(b->last, r->headers_out.content_type.data,\n                           r->headers_out.content_type.len);\n\n        if (r->headers_out.content_type_len == r->headers_out.content_type.len\n            && r->headers_out.charset.len)\n        {\n            b->last = ngx_cpymem(b->last, \"; charset=\",\n                                 sizeof(\"; charset=\") - 1);\n            b->last = ngx_copy(b->last, r->headers_out.charset.data,\n                               r->headers_out.charset.len);\n\n            /* update r->headers_out.content_type for possible logging */\n\n            r->headers_out.content_type.len = b->last - p;\n            r->headers_out.content_type.data = p;\n        }\n\n        *b->last++ = CR; *b->last++ = LF;\n    }\n\n    if (r->chunked) {\n        b->last = ngx_cpymem(b->last, \"Transfer-Encoding: chunked\" CRLF,\n                             sizeof(\"Transfer-Encoding: chunked\" CRLF) - 1);\n    }\n\n    if (r->keepalive) {\n        b->last = ngx_cpymem(b->last, \"Connection: keep-alive\" CRLF,\n                             sizeof(\"Connection: keep-alive\" CRLF) - 1);\n\n        if (clcf->keepalive_header) {\n            b->last = ngx_sprintf(b->last, \"Keep-Alive: timeout=%T\" CRLF,\n                                  clcf->keepalive_header);\n        }\n\n    } else {\n        b->last = ngx_cpymem(b->last, \"Connection: close\" CRLF,\n                             sizeof(\"Connection: close\" CRLF) - 1);\n    }\n\n    part = &r->headers_out.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (header[i].hash == 0) {\n            continue;\n        }\n\n        b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n        *b->last++ = ':'; *b->last++ = ' ';\n\n        b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);\n        *b->last++ = CR; *b->last++ = LF;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"%*s\", (size_t) (b->last - b->pos), b->pos);\n\n    /* the end of HTTP header */\n    *b->last++ = CR;\n    *b->last++ = LF;\n\n    r->header_size = b->last - b->pos;\n\n    out.buf = b;\n    out.next = NULL;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    pkt = ngx_rtmp_append_shared_bufs(cscf, NULL, &out);\n    if (pkt == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_http_flv_live_send_message(s, pkt, 0);\n    ngx_rtmp_free_shared_chain(cscf, pkt);\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_http_flv_live_send_tail(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t *cscf;\n    ngx_chain_t               cl_resp_hdr, *pkt;\n    ngx_buf_t                 buf_resp_hdr;\n\n    const ngx_str_t response_tail = ngx_string(\"0\" CRLF CRLF);\n\n    buf_resp_hdr.pos = response_tail.data;\n    buf_resp_hdr.last = response_tail.data + response_tail.len;\n    buf_resp_hdr.start = buf_resp_hdr.pos;\n    buf_resp_hdr.end = buf_resp_hdr.last;\n\n    cl_resp_hdr.buf = &buf_resp_hdr;\n    cl_resp_hdr.next = NULL;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    pkt = ngx_rtmp_append_shared_bufs(cscf, NULL, &cl_resp_hdr);\n    ngx_http_flv_live_send_message(s, pkt, 0);\n    ngx_rtmp_free_shared_chain(cscf, pkt);\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_send_message(ngx_rtmp_session_t *s,\n    ngx_chain_t *out, ngx_uint_t priority)\n{\n    ngx_uint_t                      nmsg;\n\n    nmsg = (s->out_last + s->out_queue - s->out_pos) % s->out_queue + 1;\n\n    if (priority > 3) {\n        priority = 3;\n    }\n\n    /* drop packet?\n     * Note we always leave 1 slot free */\n    if (nmsg + priority * s->out_queue / 4 >= s->out_queue) {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"flv live: HTTP drop message bufs=%ui, priority=%ui\",\n                nmsg, priority);\n\n        return NGX_AGAIN;\n    }\n\n    s->out[s->out_last++] = out;\n    s->out_last %= s->out_queue;\n\n    ngx_rtmp_acquire_shared_chain(out);\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"flv live: HTTP send nmsg=%ui, priority=%ui #%ui\",\n            nmsg, priority, s->out_last);\n\n    if (priority && s->out_buffer && nmsg < s->out_cork) {\n        return NGX_OK;\n    }\n\n    if (!s->connection->write->active) {\n        ngx_http_flv_live_write_handler(s->connection->write);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_request(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n    ngx_chain_t *in)\n{\n    static ngx_rtmp_play_t       v;\n\n    ngx_int_t                    rc;\n    ngx_http_request_t          *r;\n    ngx_http_flv_live_ctx_t     *ctx;\n\n    r = s->data;\n    ctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n\n    rc = ngx_http_flv_live_connect_init(s, &ctx->app, &ctx->stream);\n    if (rc != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (s->notify_connect) {\n        return NGX_OK;\n    }\n\n    ngx_memzero(&v, sizeof(ngx_rtmp_play_t));\n\n    ngx_memcpy(v.name, ctx->stream.data, ngx_min(ctx->stream.len,\n            sizeof(v.name) - 1));\n    ngx_memcpy(v.args, s->args.data, ngx_min(s->args.len,\n            sizeof(v.args) - 1));\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n           \"flv live: name='%s' args='%s' start=%i duration=%i \"\n           \"reset=%i silent=%i\",\n           v.name, v.args, (ngx_int_t) v.start,\n           (ngx_int_t) v.duration, (ngx_int_t) v.reset,\n           (ngx_int_t) v.silent);\n\n    return ngx_rtmp_play(s, &v);\n}\n\n\n/* +--------------+                              +-------------+\n * |   Client     |              |               |    Server   |\n * +------+-------+              |               +------+------+\n *        |               Handshaking done              |\n *        |                      |                      |\n *        |                      |                      |\n *        |----------- Command Message(connect) ------->|\n *        |                                             |\n *        |<------- Window Acknowledgement Size --------|\n *        |                                             |\n *        |<----------- Set Peer Bandwidth -------------|\n *        |                                             |\n *        |-------- Window Acknowledgement Size ------->|\n *        |                                             |\n *        |<------ User Control Message(StreamBegin) ---|\n *        |                                             |\n *        |<------------ Command Message ---------------|\n *        |        (_result- connect response)          |\n *\n * omit the user control message feedback\n */\nvoid\nngx_http_flv_live_set_status(ngx_rtmp_session_t *s, unsigned active)\n{\n    ngx_rtmp_live_ctx_t        *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n\n    ctx->active = active;\n\n    ctx->cs[0].active = 0;\n    ctx->cs[0].dropped = 0;\n\n    ctx->cs[1].active = 0;\n    ctx->cs[1].dropped = 0;\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_join(ngx_rtmp_session_t *s, u_char *name,\n    unsigned int publisher)\n{\n    ngx_rtmp_live_ctx_t            *ctx;\n    ngx_rtmp_live_stream_t        **stream;\n    ngx_rtmp_live_app_conf_t       *lacf;\n\n    /* only for subscribers */\n    if (publisher) {\n        return NGX_DECLINED;\n    }\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx && ctx->stream) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"flv live: already joined\");\n\n        return NGX_DECLINED;\n    }\n\n    if (ctx == NULL) {\n        ctx = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_live_ctx_t));\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_live_module);\n    }\n\n    ngx_memzero(ctx, sizeof(*ctx));\n\n    ctx->session = s;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"flv live: join '%s'\", name);\n\n    stream = ngx_rtmp_live_get_stream(s, name, lacf->idle_streams);\n\n    if (stream == NULL ||\n        !(publisher || (*stream)->publishing || lacf->idle_streams))\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                \"flv live: stream not found\");\n\n        return NGX_ERROR;\n    }\n\n    ctx->stream = *stream;\n    ctx->publishing = publisher;\n    ctx->next = (*stream)->ctx;\n    ctx->protocol = NGX_RTMP_PROTOCOL_HTTP;\n\n    (*stream)->ctx = ctx;\n\n    if (ctx->stream->pub_ctx) {\n        s->publisher = ctx->stream->pub_ctx->session;\n    }\n\n    if (lacf->buflen) {\n        s->out_buffer = 1;\n    }\n\n    ctx->cs[0].csid = NGX_RTMP_CSID_VIDEO;\n    ctx->cs[1].csid = NGX_RTMP_CSID_AUDIO;\n\n    if (!ctx->publishing && ctx->stream->active) {\n        ngx_http_flv_live_set_status(s, 1);\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_http_flv_live_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_live_app_conf_t        *lacf;\n    ngx_http_request_t              *r;\n\n    r = s->data;\n    if (r == NULL) {\n        goto next;\n    }\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL || !lacf->live) {\n        goto next;\n    }\n\n#if (nginx_version >= 1013001)\n        /**\n         * when playing from pull, the downstream requests on the most\n         * of time return before the upstream requests, flv.js always\n         * sends HTTP header 'Connection: keep-alive', but Nginx has\n         * deleted r->blocked in ngx_http_finalize_request, that causes\n         * ngx_http_set_keepalive to run the cleanup handlers to close\n         * the connection between downstream and server, so play fails\n         **/\n        r->keepalive = 0;\n#endif\n\n    /* join stream as a subscriber */\n\n    if (ngx_http_flv_live_join(s, v->name, 0) == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"flv live play: name='%s' start=%uD duration=%uD reset=%d\",\n            v->name, (uint32_t) v->start,\n            (uint32_t) v->duration, (uint32_t) v->reset);\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic void\nngx_http_flv_live_close_http_request(ngx_rtmp_session_t *s)\n{\n    ngx_http_request_t         *r;\n\n    r = s->data;\n    if (r && r->connection && !r->connection->destroyed) {\n        if (r->chunked) {\n            ngx_http_flv_live_send_tail(s);\n        }\n    }\n}\n\n\nngx_int_t\nngx_http_flv_live_close_stream(ngx_rtmp_session_t *s,\n    ngx_rtmp_close_stream_t *v)\n{\n    ngx_rtmp_live_ctx_t        *ctx, **cctx, *unlink;\n    ngx_http_request_t         *r;\n    ngx_rtmp_live_app_conf_t   *lacf;\n    ngx_rtmp_live_stream_t    **stream;\n    ngx_flag_t                  passive;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        goto next;\n    }\n\n    passive = 0;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    if (ctx->stream == NULL) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"flv live: not joined\");\n\n        goto next;\n    }\n\n    if (ctx->protocol == NGX_RTMP_PROTOCOL_RTMP) {\n        /* close RTMP live play */\n        if (!ctx->publishing) {\n            goto next;\n        }\n\n        /* close all http flv live streams */\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"flv live: push closed '%s', close live streams subscribed\",\n                        ctx->stream->name);\n\n        passive = 1;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"flv live: leave '%s'\", ctx->stream->name);\n\n    if (passive) {\n        for (cctx = &ctx->stream->ctx; *cctx; /* void */) {\n            if ((*cctx)->protocol == NGX_RTMP_PROTOCOL_HTTP &&\n                !lacf->idle_streams)\n            {\n                ngx_http_flv_live_close_http_request((*cctx)->session);\n\n                if (!(*cctx)->publishing && (*cctx)->stream->active) {\n                    ngx_http_flv_live_set_status((*cctx)->session, 0);\n                }\n\n                ngx_http_flv_live_free_request((*cctx)->session);\n                ngx_rtmp_finalize_session((*cctx)->session);\n\n                unlink = *cctx;\n\n                *cctx = (*cctx)->next;\n\n                unlink->next = NULL;\n            } else {\n                cctx = &(*cctx)->next;\n            }\n        }\n    } else {\n        for (cctx = &ctx->stream->ctx; *cctx; /* void */) {\n            if (*cctx == ctx) {\n                if (!ctx->publishing && ctx->stream->active) {\n                    ngx_http_flv_live_set_status(s, 0);\n                }\n\n                *cctx = ctx->next;\n\n                if (ctx->stream->pub_ctx == NULL &&\n                    ctx->stream->ctx == NULL)\n                {\n                    stream = ngx_rtmp_live_get_stream(s, ctx->stream->name, 0);\n                    if (stream) {\n                        *stream = (*stream)->next;\n\n                        ctx->stream->next = lacf->free_streams;\n                        lacf->free_streams = ctx->stream;\n                    }\n                }\n\n                ctx->next = NULL;\n                ctx->stream = NULL;\n\n                ngx_http_flv_live_free_request(s);\n                s->connection->destroyed = 1;\n\n                break;\n            } else {\n                cctx = &(*cctx)->next;\n            }\n        }\n    }\n\n    /**\n     * close only http requests here, the other\n     * requests were left for next_close_stream\n     **/\n\nnext:\n    if (s->notify_connect || s->notify_play) {\n        r = s->data;\n        if (r) {\n            ngx_http_flv_live_free_request(s);\n            s->connection->destroyed = 1;\n        }\n    }\n\n    return next_close_stream(s, v);\n}\n\n\nstatic void\nngx_http_flv_live_free_request(ngx_rtmp_session_t *s)\n{\n    ngx_connection_t               *c;\n    ngx_http_request_t             *r;\n    ngx_http_cleanup_t            **cln;\n\n    r = s->data;\n    if (r) {\n        for (cln = &r->cleanup; *cln; /* void */) {\n            if ((*cln)->handler == ngx_http_flv_live_cleanup) {\n                *cln = (*cln)->next;\n                break;\n            }\n\n            cln = &(*cln)->next;\n        }\n\n        c = r->connection;\n\n#if (nginx_version <= 1003014)\n        ngx_http_do_free_request(r, 0);\n#else\n        ngx_http_free_request(r, 0);\n#endif\n\n#if (NGX_HTTP_SSL)\n        if (c->ssl) {\n            ngx_ssl_shutdown(c);\n        }\n#endif\n\n        /* for later processing */\n        c->destroyed = 0;\n    }\n}\n\n\n#if (nginx_version <= 1003014)\nstatic void\nngx_http_do_free_request(ngx_http_request_t *r, ngx_int_t rc)\n{\n    ngx_log_t                 *log;\n    ngx_pool_t                *pool;\n    struct linger              linger;\n    ngx_http_cleanup_t        *cln;\n    ngx_http_log_ctx_t        *ctx;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    log = r->connection->log;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, log, 0, \"http close request\");\n\n    if (r->pool == NULL) {\n        ngx_log_error(NGX_LOG_ALERT, log, 0, \"http request already closed\");\n        return;\n    }\n\n    cln = r->cleanup;\n    r->cleanup = NULL;\n\n    while (cln) {\n        if (cln->handler) {\n            cln->handler(cln->data);\n        }\n\n        cln = cln->next;\n    }\n\n#if (NGX_STAT_STUB)\n\n    if (r->stat_reading) {\n        (void) ngx_atomic_fetch_add(ngx_stat_reading, -1);\n    }\n\n    if (r->stat_writing) {\n        (void) ngx_atomic_fetch_add(ngx_stat_writing, -1);\n    }\n\n#endif\n\n    if (rc > 0 && (r->headers_out.status == 0 || r->connection->sent == 0)) {\n        r->headers_out.status = rc;\n    }\n\n    log->action = \"logging request\";\n\n    ngx_http_do_log_request(r);\n\n    log->action = \"closing request\";\n\n    if (r->connection->timedout) {\n        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n        if (clcf->reset_timedout_connection) {\n            linger.l_onoff = 1;\n            linger.l_linger = 0;\n \n            if (setsockopt(r->connection->fd, SOL_SOCKET, SO_LINGER,\n                           (const void *) &linger, sizeof(struct linger)) == -1)\n            {\n                ngx_log_error(NGX_LOG_ALERT, log, ngx_socket_errno,\n                              \"setsockopt(SO_LINGER) failed\");\n            }\n        }\n    }\n\n    /* the various request strings were allocated from r->pool */\n    ctx = log->data;\n    ctx->request = NULL;\n\n    r->request_line.len = 0;\n\n    r->connection->destroyed = 1;\n\n    /*\n     * Setting r->pool to NULL will increase probability to catch double close\n     * of request since the request object is allocated from its own pool.\n     */\n\n    pool = r->pool;\n    r->pool = NULL;\n\n    ngx_destroy_pool(pool);\n}\n\n\nstatic void\nngx_http_do_log_request(ngx_http_request_t *r)\n{\n    ngx_uint_t                  i, n;\n    ngx_http_handler_pt        *log_handler;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    log_handler = cmcf->phases[NGX_HTTP_LOG_PHASE].handlers.elts;\n    n = cmcf->phases[NGX_HTTP_LOG_PHASE].handlers.nelts;\n\n    for (i = 0; i < n; i++) {\n        log_handler[i](r);\n    }\n}\n#endif\n\n\nstatic void\nngx_http_flv_live_read_handler(ngx_event_t *rev)\n{\n    ngx_connection_t           *c;\n    ngx_http_request_t         *r;\n    ngx_rtmp_session_t         *s;\n    ngx_int_t                   n;\n    ngx_http_flv_live_ctx_t    *ctx;\n    u_char                      buf[NGX_BUFF_MAX_SIZE];\n\n    c = rev->data;\n    if (c->destroyed) {\n        return;\n    }\n\n    r = c->data;\n    ctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n    s = ctx->s;\n\n    for ( ;; ) {\n        n = c->recv(c, buf, sizeof(buf));\n\n        if (n == NGX_AGAIN) {\n            ngx_add_timer(c->read, s->timeout);\n\n            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n            }\n\n            break;\n        } else if (n == 0 || n == -1) {\n            ngx_rtmp_finalize_session(s);\n            break;\n        }\n    }\n}\n\n\nstatic void\nngx_http_flv_live_write_handler(ngx_event_t *wev)\n{\n    ngx_connection_t           *c;\n    ngx_http_request_t         *r;\n    ngx_rtmp_session_t         *s;\n    ngx_int_t                   n;\n    ngx_rtmp_live_ctx_t        *lctx;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_http_flv_live_ctx_t    *ctx;\n\n    c = wev->data;\n    if (c->destroyed) {\n        return;\n    }\n\n    r = c->data;\n    ctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n    s = ctx->s;\n\n    if (wev->timedout) {\n        ngx_log_error(NGX_LOG_ERR, c->log, NGX_ETIMEDOUT,\n                \"flv live: client timed out\");\n        c->timedout = 1;\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    if (wev->timer_set) {\n        ngx_del_timer(wev);\n    }\n\n    if (s->out_chain == NULL && s->out_pos != s->out_last) {\n        s->out_chain = s->out[s->out_pos];\n        s->out_bpos = s->out_chain->buf->pos;\n    }\n\n    while (s->out_chain) {\n        n = ngx_http_flv_live_send(s);\n\n        if (n == NGX_AGAIN || n == 0) {\n            ngx_add_timer(c->write, s->timeout);\n            if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n            }\n            return;\n        }\n\n        if (n < 0) {\n            ngx_rtmp_finalize_session(s);\n            return;\n        }\n\n        s->out_bytes += n;\n        s->ping_reset = 1;\n        ngx_rtmp_update_bandwidth(&ngx_rtmp_bw_out, n);\n        s->out_bpos += n;\n\n        if (s->out_bpos == s->out_chain->buf->last) {\n            s->out_chain = s->out_chain->next;\n            if (s->out_chain == NULL) {\n                cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n                ngx_rtmp_free_shared_chain(cscf, s->out[s->out_pos]);\n                s->out[s->out_pos] = NULL;\n                ++s->out_pos;\n                s->out_pos %= s->out_queue;\n                if (s->out_pos == s->out_last) {\n                    break;\n                }\n                s->out_chain = s->out[s->out_pos];\n            }\n            s->out_bpos = s->out_chain->buf->pos;\n        }\n    }\n\n    lctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (lctx && !lctx->publishing && !wev->timer_set) {\n        ngx_add_timer(wev, s->timeout);\n    }\n\n    if (wev->active) {\n        ngx_del_event(wev, NGX_WRITE_EVENT, 0);\n    }\n\n    ngx_event_process_posted((ngx_cycle_t *) ngx_cycle, &s->posted_dry_events);\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_send(ngx_rtmp_session_t *s)\n{\n    ngx_int_t            n;\n    ngx_connection_t    *c;\n    ngx_http_request_t  *r;\n\n    c = s->connection;\n    r = s->data;\n\n    if (r->chunked) {\n        if (s->out_chain == s->out[s->out_pos]) {\n            n = c->send(c, s->out_bpos, s->out_chain->buf->last - s->out_bpos);\n            if (n == NGX_AGAIN || n == 0 || n < 0) {\n                return n;\n            }\n\n            if (n != s->out_chain->buf->last - s->out_bpos ||\n                s->out_chain->next == NULL)\n            {\n                return n;\n            }\n\n            s->out_chain = s->out_chain->next;\n\n            s->out_bytes += n;\n            s->out_bpos = s->out_chain->buf->pos;\n            s->ping_reset = 1;\n            ngx_rtmp_update_bandwidth(&ngx_rtmp_bw_out, n);\n        }\n    }\n\n    ngx_http_flv_live_correct_timestamp(s, 1);\n    n = c->send(c, s->out_bpos, s->out_chain->buf->last - s->out_bpos);\n    ngx_http_flv_live_correct_timestamp(s, 0);\n\n    return n;\n}\n\n\nstatic void\nngx_http_flv_live_correct_timestamp(ngx_rtmp_session_t *s, ngx_flag_t correct)\n{\n    uint8_t       type;\n    uint32_t      timestamp;\n    u_char       *p;\n    ngx_chain_t  *cl;\n    ngx_buf_t    *b;\n\n    cl = s->out_chain;\n    if (cl == NULL) {\n        return;\n    }\n\n    b = cl->buf;\n    if (b->start + NGX_RTMP_MAX_CHUNK_HEADER != b->pos) {\n        type = b->pos[0] & 0x1f;\n\n        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                       \"flv live: type=%uD, correct=%uD, offset_timestamp=%uD\",\n                       type, correct, s->offset_timestamp);\n\n        if (type != NGX_RTMP_MSG_VIDEO && type != NGX_RTMP_MSG_AUDIO) {\n            return;\n        }\n\n        p = b->pos + 4;\n        timestamp = ngx_rtmp_n3_to_h4(p);\n        timestamp |= ((uint32_t) p[3] << 24);\n\n        if (correct) {\n            timestamp -= s->offset_timestamp;\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                           \"flv live: correct timestamp=%uD\", timestamp);\n        } else {\n            timestamp += s->offset_timestamp;\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                           \"flv live: recover timestamp=%uD\", timestamp);\n        }\n\n        p = b->pos + 4;\n        ngx_rtmp_h4_to_n3(p, timestamp);\n        p += 3;\n        *p++ = (u_char) (timestamp >> 24);\n    }\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_preprocess(ngx_http_request_t *r,\n    ngx_rtmp_connection_t *rconn)\n{\n    ngx_http_flv_live_ctx_t     *ctx;\n    ngx_listening_t             *ls;\n    struct sockaddr             *local_sockaddr;\n\n    struct sockaddr_in          *ls_sin, *sin;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6         *ls_sin6, *sin6;\n#endif\n\n    ngx_rtmp_in_addr_t          *addr;\n#if (NGX_HAVE_INET6)\n    ngx_rtmp_in6_addr_t         *addr6;\n#endif\n\n    ngx_rtmp_port_t             *rport;\n\n    ngx_str_t                    arg_app = ngx_string(\"app\");\n    ngx_str_t                    arg_stream = ngx_string(\"stream\");\n    ngx_str_t                    arg_port = ngx_string(\"port\");\n    ngx_int_t                    in_port;\n    ngx_uint_t                   i, n;\n    ngx_flag_t                   port_match, addr_match;\n    unsigned short               sa_family;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n\n    /**\n     * if requested args are escaped, for example, urls in the\n     * history list of vlc for Android (or all mobile platforms)\n     **/\n    if (r->args.len == 0 && r->uri.len) {\n        ngx_http_split_args(r, &r->uri, &r->args);\n    }\n\n    if (ngx_http_arg(r, arg_port.data, arg_port.len, &ctx->port) != NGX_OK) {\n        /* no port in args */\n        ctx->port.len = ngx_strlen(\"1935\");\n        ctx->port.data = ngx_pcalloc(r->pool, ctx->port.len + 1);\n        if (ctx->port.data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(ctx->port.data, (const void *) \"1935\", ctx->port.len);\n        in_port = 1935;\n    } else {\n        in_port = ngx_atoi(ctx->port.data, ctx->port.len);\n        if (in_port == NGX_ERROR || (in_port < 0 || in_port > 65535)) {\n            return NGX_ERROR;\n        }\n    }\n\n    in_port = htons(in_port);\n\n    port_match = 1;\n    addr_match = 1;\n\n    ls = ngx_cycle->listening.elts;\n    for (n = 0; n < ngx_cycle->listening.nelts; ++n, ++ls) {\n        if (ls->handler == ngx_rtmp_init_connection) {\n            local_sockaddr = r->connection->local_sockaddr;\n            sa_family = local_sockaddr->sa_family;\n\n            if (sa_family != ls->sockaddr->sa_family) {\n#if (NGX_HAVE_INET6)\n                if (ls->sockaddr->sa_family == AF_INET6) {\n                    if (ls->ipv6only) {\n#endif\n                        continue;\n#if (NGX_HAVE_INET6)\n                    } else {\n                        if (local_sockaddr->sa_family != AF_INET) {\n                            continue;\n                        }\n\n                        sa_family = AF_INET6;\n                    }\n                }\n#endif\n            }\n\n            switch (sa_family) {\n\n#if (NGX_HAVE_INET6)\n            case AF_INET6:\n                ls_sin6 = (struct sockaddr_in6 *) ls->sockaddr;\n                if (in_port != ls_sin6->sin6_port) {\n                    port_match = 0;\n                }\n\n                break;\n#endif\n\n            default:\n                ls_sin = (struct sockaddr_in *) ls->sockaddr;\n                if (in_port != ls_sin->sin_port) {\n                    port_match = 0;\n                }\n            }\n\n            if (!port_match) {\n                port_match = 1;\n                continue;\n            }\n\n            rport = ls->servers;\n\n            if (rport->naddrs > 1) {\n                /**\n                 * listen xxx.xxx.xxx.xxx:port\n                 * listen port\n                 **/\n                switch (sa_family) {\n\n#if (NGX_HAVE_INET6)\n                case AF_INET6:\n                    sin6 = (struct sockaddr_in6 *) ls->sockaddr;\n\n                    addr6 = rport->addrs;\n\n                    /* the last address is \"*\" */\n\n                    for (i = 0; i < rport->naddrs - 1; i++) {\n                        if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16)\n                            == 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    rconn->addr_conf = &addr6[i].conf;\n\n                    break;\n#endif\n\n                default:\n                    sin = (struct sockaddr_in *) ls->sockaddr;\n\n                    addr = rport->addrs;\n\n                    /* the last address is \"*\" */\n\n                    for (i = 0; i < rport->naddrs - 1; i++) {\n                        if (addr[i].addr == sin->sin_addr.s_addr) {\n                            break;\n                        }\n                    }\n\n                    rconn->addr_conf = &addr[i].conf;\n                }\n            } else {\n                switch (sa_family) {\n\n#if (NGX_HAVE_INET6)\n                case AF_INET6:\n                    sin6 = (struct sockaddr_in6 *) ls->sockaddr;\n\n                    addr6 = rport->addrs;\n                    if (ngx_memcmp(&addr6[0].addr6, &sin6->sin6_addr, 16)) {\n                        addr_match = 0;\n                    } else {\n                        rconn->addr_conf = &addr6[0].conf;\n                    }\n\n                    break;\n#endif\n\n                default:\n                    sin = (struct sockaddr_in *) ls->sockaddr;\n\n                    addr = rport->addrs;\n                    if (addr[0].addr != sin->sin_addr.s_addr) {\n                        addr_match = 0;\n                    } else {\n                        rconn->addr_conf = &addr[0].conf;\n                    }\n                }\n            }\n\n            if (!addr_match) {\n                addr_match = 1;\n                continue;\n            }\n\n            break;\n        }\n    }\n\n    if (n == ngx_cycle->listening.nelts) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                \"flv live: failed to find configured port: '%V'\", &ctx->port);\n\n        return NGX_ERROR;\n    }\n\n    if (ngx_http_arg(r, arg_app.data, arg_app.len, &ctx->app) != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"flv live: app args MUST be specified\");\n\n        return NGX_ERROR;\n    }\n\n    if (ngx_http_arg(r, arg_stream.data, arg_stream.len,\n                     &ctx->stream) != NGX_OK)\n    {\n        ctx->stream.data = (u_char *) \"\";\n        ctx->stream.len = 0;\n    }\n\n    return NGX_OK;\n}\n\n\nngx_rtmp_session_t *\nngx_http_flv_live_init_connection(ngx_http_request_t *r,\n    ngx_rtmp_connection_t *rconn)\n{\n    ngx_rtmp_session_t        *s;\n    ngx_connection_t          *c;\n    void                      *data;\n\n    c = r->connection;\n\n    /* the default server configuration for the address:port */\n    rconn->conf_ctx = rconn->addr_conf->default_server->ctx;\n\n    ++ngx_rtmp_naccepted;\n\n    data = c->data;\n    c->data = rconn;\n\n    ngx_log_error(NGX_LOG_INFO, c->log, 0,\n            \"flv live: *%ui client connected '%V'\", c->number, &c->addr_text);\n\n    s = ngx_http_flv_live_init_session(r, rconn->addr_conf);\n    c->data = data;\n\n    if (s == NULL) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                \"flv live: failed to init connection for session\");\n\n        return NULL;\n    }\n\n    /* only auto-pushed connections are\n     * done through unix socket */\n\n    s->auto_pushed = 0;\n\n    c->write->handler = ngx_http_flv_live_write_handler;\n    c->read->handler = ngx_http_flv_live_read_handler;\n\n    if (c->write->active) {\n        if (ngx_del_event(c->write, NGX_WRITE_EVENT, 0) != NGX_OK) {\n            return NULL;\n        }\n    }\n\n    return s;\n}\n\n\nstatic ngx_rtmp_session_t *\nngx_http_flv_live_init_session(ngx_http_request_t *r,\n    ngx_rtmp_addr_conf_t *addr_conf)\n{\n    ngx_rtmp_session_t             *s;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_rtmp_error_log_ctx_t       *ctx;\n    ngx_connection_t               *c;\n\n    c = r->connection;\n\n    s = ngx_pcalloc(c->pool, sizeof(ngx_rtmp_session_t));\n    if (s == NULL) {\n        /* let other handlers process */\n        goto failed;\n    }\n\n    s->rtmp_connection = c->data;\n\n    s->main_conf = addr_conf->default_server->ctx->main_conf;\n    s->srv_conf = addr_conf->default_server->ctx->srv_conf;\n\n    s->addr_text = &addr_conf->addr_text;\n\n    s->connection = c;\n\n    ctx = ngx_palloc(c->pool, sizeof(ngx_rtmp_error_log_ctx_t));\n    if (ctx == NULL) {\n        goto failed;\n    }\n\n    ctx->client = &c->addr_text;\n    ctx->session = s;\n\n    c->log->connection = c->number;\n    c->log->handler = ngx_rtmp_log_error;\n    c->log->data = ctx;\n    c->log->action = NULL;\n\n    c->log_error = NGX_ERROR_INFO;\n\n    s->ctx = ngx_pcalloc(c->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (s->ctx == NULL) {\n        goto failed;\n    }\n\n    s->out_pool = ngx_create_pool(4096, c->log);\n    if (s->out_pool == NULL) {\n        goto failed;\n    }\n\n    s->out = ngx_pcalloc(s->out_pool, sizeof(ngx_chain_t *)\n                         * ((ngx_rtmp_core_srv_conf_t *)\n                            addr_conf->default_server->ctx->srv_conf\n                            [ngx_rtmp_core_module.ctx_index])->out_queue);\n    if (s->out == NULL) {\n        goto failed;\n    }\n\n    s->in_streams_pool = ngx_create_pool(4096, c->log);\n    if (s->in_streams_pool == NULL) {\n        goto failed;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    s->out_queue = cscf->out_queue;\n    s->out_cork = cscf->out_cork;\n    s->in_streams = ngx_pcalloc(s->in_streams_pool, sizeof(ngx_rtmp_stream_t)\n            * cscf->max_streams);\n    if (s->in_streams == NULL) {\n        goto failed;\n    }\n\n#if (nginx_version >= 1007005)\n    ngx_queue_init(&s->posted_dry_events);\n#endif\n\n    s->epoch = ngx_current_msec;\n    s->timeout = cscf->timeout;\n    s->buflen = cscf->buflen;\n    ngx_rtmp_set_chunk_size(s, NGX_RTMP_DEFAULT_CHUNK_SIZE);\n\n    if (ngx_rtmp_fire_event(s, NGX_RTMP_CONNECT, NULL, NULL) != NGX_OK) {\n        goto failed;\n    }\n\n    s->data = (void *) r;\n\n    return s;\n\nfailed:\n    if (s && s->out_pool) {\n        ngx_destroy_pool(s->out_pool);\n        s->out_pool = NULL;\n    }\n\n    if (s && s->in_streams_pool) {\n        ngx_destroy_pool(s->in_streams_pool);\n        s->in_streams_pool = NULL;\n    }\n\n    return NULL;\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_connect_init(ngx_rtmp_session_t *s, ngx_str_t *app,\n    ngx_str_t *stream)\n{\n    ngx_rtmp_connect_t           v;\n    ngx_connection_t            *c;\n    ngx_http_request_t          *r;\n    u_char                       name[NGX_RTMP_MAX_NAME];\n\n    r = s->data;\n    c = s->connection;\n\n    ngx_memzero(&v, sizeof(ngx_rtmp_connect_t));\n\n    ngx_memcpy(v.app, app->data, ngx_min(app->len, sizeof(v.app) - 1));\n    ngx_memcpy(v.args, r->args.data, ngx_min(r->args.len, sizeof(v.args) - 1));\n    ngx_memcpy(v.flashver, \"flv_live 1.1\", ngx_strlen(\"flv_live 1.1\"));\n\n    *ngx_snprintf(v.tc_url, NGX_RTMP_MAX_URL, \"http://%V/%V\",\n            &r->headers_in.host->value, app) = 0;\n\n#define NGX_RTMP_SET_STRPAR(name)                                          \\\n    s->name.len = ngx_strlen(v.name);                                      \\\n    s->name.data = ngx_palloc(c->pool, s->name.len);                       \\\n    ngx_memcpy(s->name.data, v.name, s->name.len)\n\n    NGX_RTMP_SET_STRPAR(app);\n    NGX_RTMP_SET_STRPAR(args);\n    NGX_RTMP_SET_STRPAR(flashver);\n    NGX_RTMP_SET_STRPAR(tc_url);\n\n#undef NGX_RTMP_SET_STRPAR\n\n    ngx_memzero(name, NGX_RTMP_MAX_NAME);\n    ngx_memcpy(name, stream->data,\n               ngx_min(stream->len, NGX_RTMP_MAX_NAME - 1));\n\n    if (ngx_rtmp_process_request_line(s, name, v.args,\n            (const u_char *) \"flv live connect\") != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_process_virtual_host(s) != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"flv live: failed to process virtual host\");\n\n        return NGX_ERROR;\n    }\n\n    s->stream.len = stream->len;\n    s->stream.data = ngx_pstrdup(c->pool, stream);\n\n    return ngx_rtmp_connect(s, &v);\n}\n\n\nstatic ngx_chain_t *\nngx_http_flv_live_meta_message(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t        *cscf;\n    ngx_http_request_t              *r;\n    ngx_chain_t                     *meta, *iter, *out;\n    u_char                          *p, *save;\n    uint8_t                          fmt;\n    uint32_t                         csid;\n    ngx_int_t                        thsize;\n    ngx_rtmp_header_t                ch;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    r = s->data;\n    if (r == NULL || (r->connection && r->connection->destroyed)) {\n        return NULL;\n    }\n\n    /* remove RTMP header in meta */\n    meta = in;\n    p = meta->buf->pos;\n    save = meta->buf->pos;\n    if (meta->buf->last == p) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"flv live: no meta\");\n\n        return NULL;\n    }\n\n    fmt = (*p >> 6) & 0x03;\n    if (fmt) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"flv live: non-type 0 format chunk message header\");\n\n        return NULL;\n    }\n\n    csid = *p++ & 0x3f;\n    if (csid == 0) {\n        if (meta->buf->last - p < 1) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"flv live: incorrect basic header 2\");\n\n            return NULL;\n        }\n\n        p += 1;\n    } else if (csid == 1) {\n        if (meta->buf->last - p < 2) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"flv live: incorrect basic header 3\");\n\n            return NULL;\n        }\n\n        p += 2;\n    }\n\n    thsize = p - meta->buf->pos;\n\n    /*\n     * Chunk Message Header - Type 0\n     * |timestamp(3B)|msg len(3B)|msg type id(1B)|msg stream id(4B)|\n     */\n    if (meta->buf->last - p <= 11) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"flv live: incorrect chunk message header\");\n\n        return NULL;\n    }\n\n    p += 11;\n    meta->buf->pos = p;\n\n    for (iter = meta->next; iter; iter = iter->next) {\n        iter->buf->pos += thsize;\n    }\n\n    ch.timestamp = 0;\n    ch.type = NGX_RTMP_MSG_AMF_META;\n\n    out = ngx_http_flv_live_append_message(s, &ch, NULL, meta);\n\n    in->buf->pos = save;\n    for (iter = meta->next; iter; iter = iter->next) {\n        iter->buf->pos -= thsize;\n    }\n\n    return out;\n}\n\n\nstatic ngx_chain_t *\nngx_http_flv_live_append_message(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n    ngx_rtmp_header_t *lh, ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t        *cscf;\n    ngx_http_request_t              *r;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    r = s->data;\n    if (r == NULL || r->connection == NULL || r->connection->destroyed) {\n        return NULL;\n    }\n\n    if (h->type == NGX_RTMP_MSG_VIDEO || h->type == NGX_RTMP_MSG_AUDIO) {\n        if (!s->offset_timestamp_set) {\n            s->offset_timestamp_set = 1;\n            s->offset_timestamp = h->timestamp;\n        } else if (h->timestamp == 0) {\n            s->offset_timestamp = 0;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                       \"flv live: timestamp=%uD, offset_timestamp=%uD\",\n                       h->timestamp, s->offset_timestamp);\n    }\n\n    return ngx_http_flv_live_append_shared_bufs(cscf, h, in, r->chunked);\n}\n\n\n/*\n * Brief format:\n * |Tag|PreviousTagSize|\n * Detailed format:\n * |Reserved(2b)+Filter(1b)+TagType(5b)|DataLength(3B)|TimeStamp(3B)|\n * TimeStampExt(1B)|StreamID(3B)|Data(DataLengthB)|PreviousTagSize|\n */\nstatic ngx_chain_t *\nngx_http_flv_live_append_shared_bufs(ngx_rtmp_core_srv_conf_t *cscf,\n    ngx_rtmp_header_t *h, ngx_chain_t *in, ngx_flag_t chunked)\n{\n    ngx_chain_t        *tag, *chunk_head, *chunk_tail, chunk,\n                       *iter, *last_in, **tail, prev_tag_size;\n    u_char             *pos,\n#if !(NGX_WIN32)\n                        chunk_item[ngx_strlen(\"0000000000000000\" CRLF) + 1];\n#else\n                        chunk_item[19];\n#endif\n    uint32_t            data_size, size;\n    off_t               tag_size;\n    ngx_buf_t           prev_tag_size_buf, chunk_buf;\n\n    for (data_size = 0, iter = in, last_in = iter; iter; iter = iter->next) {\n        last_in = iter;\n        data_size += (iter->buf->last - iter->buf->pos);\n    }\n\n    tail = &last_in->next;\n    *tail = &prev_tag_size;\n\n    tag_size = data_size + NGX_FLV_TAG_HEADER_SIZE;\n\n    prev_tag_size.buf = &prev_tag_size_buf;\n    prev_tag_size.next = NULL;\n\n    prev_tag_size_buf.start = (u_char *) &size;\n    prev_tag_size_buf.end = prev_tag_size_buf.start + sizeof(uint32_t);\n    prev_tag_size_buf.pos = prev_tag_size_buf.start;\n    prev_tag_size_buf.last = prev_tag_size_buf.end;\n\n    pos = prev_tag_size_buf.pos;\n    *(uint32_t *) pos = htonl(tag_size);\n    pos += 4;\n\n    /* ngx_rtmp_alloc_shared_buf returns the memory:\n     * |4B|sizeof(ngx_chain_t)|sizeof(ngx_buf_t)|NGX_RTMP_MAX_CHUNK_HEADER|\n     * chunk_size|\n     * the tag->buf->pos points to the addr of last part of memory\n     */\n    tag = ngx_rtmp_append_shared_bufs(cscf, NULL, in);\n    if (tag == NULL) {\n        return NULL;\n    }\n\n    /* it links to the local variable, unlink it */\n    *tail = NULL;\n\n    tag->buf->pos -= NGX_FLV_TAG_HEADER_SIZE;\n    pos = tag->buf->pos;\n\n    /* type, 5bits */\n    *pos++ = (u_char) (h->type & 0x1f);\n\n    /* data length, 3B */\n    ngx_rtmp_h4_to_n3(pos, data_size);\n    pos += 3;\n\n    /* timestamp, 3B + ext, 1B */\n    ngx_rtmp_h4_to_n3(pos, h->timestamp);\n    pos += 3;\n    *pos++ = (u_char) (h->timestamp >> 24);\n\n    /* streamId, 3B, always be 0 */\n    *pos++ = 0;\n    *pos++ = 0;\n    *pos++ = 0;\n\n    /* add chunk header and tail */\n    if (chunked) {\n        /* 4 is the size of previous tag size itself */\n        *ngx_sprintf(chunk_item, \"%xO\" CRLF, tag_size + 4) = 0;\n\n        chunk_buf.start = chunk_item;\n        chunk_buf.pos = chunk_buf.start;\n        chunk_buf.end = chunk_buf.start + ngx_strlen(chunk_item);\n        chunk_buf.last = chunk_buf.end;\n\n        chunk.buf = &chunk_buf;\n        chunk.next = NULL;\n\n        chunk_head = ngx_rtmp_append_shared_bufs(cscf, NULL, &chunk);\n        if (chunk_head == NULL) {\n            return NULL;\n        }\n\n        for (iter = tag, last_in = iter; iter; iter = iter->next) {\n            last_in = iter;\n        }\n\n        /* save the memory, very likely */\n#if !(NGX_WIN32)\n        if (__builtin_expect(last_in->buf->last + 2 <= last_in->buf->end, 1)) {\n#else\n        if (last_in->buf->last + 2 <= last_in->buf->end) {\n#endif\n            *last_in->buf->last++ = CR;\n            *last_in->buf->last++ = LF;\n        } else {\n            *ngx_sprintf(chunk_item, CRLF) = 0;\n            chunk_buf.start = chunk_item;\n            chunk_buf.pos = chunk_buf.start;\n            chunk_buf.end = chunk_buf.start + ngx_strlen(chunk_item);\n            chunk_buf.last = chunk_buf.end;\n\n            chunk.buf = &chunk_buf;\n            chunk.next = NULL;\n\n            chunk_tail = ngx_rtmp_append_shared_bufs(cscf, NULL, &chunk);\n            if (chunk_tail == NULL) {\n                return NULL;\n            }\n\n            tail = &last_in->next;\n            *tail = chunk_tail;\n        }\n\n        chunk_head->next = tag;\n\n        return chunk_head;\n    }\n\n    return tag;\n}\n\n\nstatic void\nngx_http_flv_live_free_message(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t *cscf;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return;\n    }\n\n    ngx_rtmp_free_shared_chain(cscf, in);\n}\n\n\nstatic void\nngx_http_flv_live_close_session_handler(ngx_rtmp_session_t *s)\n{\n    ngx_connection_t               *c;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n\n    c = s->connection;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, \"flv live: close session\");\n\n    ngx_rtmp_fire_event(s, NGX_RTMP_DISCONNECT, NULL, NULL);\n\n    if (s->ping_evt.timer_set) {\n        ngx_del_timer(&s->ping_evt);\n    }\n\n    if (s->in_old_pool) {\n        ngx_destroy_pool(s->in_old_pool);\n    }\n\n    if (s->in_pool) {\n        ngx_destroy_pool(s->in_pool);\n    }\n\n    while (s->out_pos != s->out_last) {\n        ngx_rtmp_free_shared_chain(cscf, s->out[s->out_pos]);\n\n        s->out_pos++;\n        s->out_pos %= s->out_queue;\n    }\n\n    if (s->in_streams_pool) {\n        ngx_destroy_pool(s->in_streams_pool);\n    }\n\n    if (s->out_pool) {\n        ngx_destroy_pool(s->out_pool);\n    }\n}\n\n\nstatic void\nngx_http_flv_live_cleanup(void *data)\n{\n    ngx_rtmp_session_t       *s;\n\n    s = data;\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n            \"flv live: close connection\");\n\n    ngx_http_flv_live_close_session_handler(s);\n}\n\n\nstatic ngx_int_t\nngx_http_flv_live_handler(ngx_http_request_t *r)\n{\n    ngx_int_t                        rc;\n    ngx_http_flv_live_conf_t        *hfcf;\n    ngx_http_cleanup_t              *cln;\n    ngx_http_flv_live_ctx_t         *ctx;\n    ngx_rtmp_session_t              *s;\n    ngx_rtmp_connection_t           *rconn;\n\n    if (ngx_exiting || ngx_terminate) {\n        return NGX_HTTP_CLOSE;\n    }\n\n    hfcf = ngx_http_get_module_loc_conf(r, ngx_http_flv_live_module);\n    if (!hfcf->flv_live) {\n        return NGX_DECLINED;\n    }\n\n    if (!(r->method & (NGX_HTTP_GET))) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"flv live: HTTP method was not \\\"GET\\\"\");\n\n        return NGX_HTTP_NOT_ALLOWED;\n    }\n\n    if (r->http_version == NGX_HTTP_VERSION_9\n#if (NGX_HTTP_V2)\n        || r->http_version == NGX_HTTP_VERSION_20\n#endif\n       )\n    {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"flv live: HTTP version 0.9 or 2.0 not supported\");\n\n        return NGX_HTTP_NOT_ALLOWED;\n    }\n\n    if (r->uri.data[r->uri.len - 1] == '/') {\n        return NGX_DECLINED;\n    }\n\n    rc = ngx_http_discard_request_body(r);\n\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_flv_live_ctx_t));\n\n        if (ctx == NULL) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        ngx_http_set_ctx(r, ctx, ngx_http_flv_live_module);\n    }\n\n    rconn = ngx_pcalloc(r->pool, sizeof(ngx_rtmp_connection_t));\n    if (rconn == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (ngx_http_flv_live_preprocess(r, rconn) != NGX_OK) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    s = ngx_http_flv_live_init_connection(r, rconn);\n    if (s == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    ctx->s = s;\n\n    /* live, ranges not allowed */\n    r->allow_ranges = 0;\n    r->read_event_handler = ngx_http_test_reading;\n\n    cln = ngx_http_cleanup_add(r, 0);\n    if (cln == NULL) {\n        return NGX_DECLINED;\n    }\n\n    cln->handler = ngx_http_flv_live_cleanup;\n    cln->data = s;\n\n    if (ngx_rtmp_fire_event(s, NGX_HTTP_FLV_LIVE_REQUEST, NULL, NULL)\n        != NGX_OK)\n    {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    r->main->count++;\n\n    return NGX_DONE;\n}\n"
        },
        {
          "name": "ngx_http_flv_live_module.h",
          "type": "blob",
          "size": 2.0595703125,
          "content": "\n/*\n * Copyright (C) Winshining\n */\n\n#ifndef _NGX_HTTP_FLV_LIVE_H_INCLUDED_\n#define _NGX_HTTP_FLV_LIVE_H_INCLUDED_\n\n\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_live_module.h\"\n#include \"ngx_rtmp_codec_module.h\"\n\n\n#define NGX_HASH_MAX_SIZE              0x80\n#define NGX_HASH_MAX_BUKET_SIZE        0x40\n#define NGX_BUFF_MAX_SIZE              0x80\n#define NGX_FLV_TAG_HEADER_SIZE        11\n\n\nextern ngx_module_t ngx_rtmp_module;\n\n\nextern ngx_rtmp_play_pt                http_flv_live_next_play;\nextern ngx_rtmp_close_stream_pt        http_flv_live_next_close_stream;\n\n\n#define ngx_rtmp_cycle_get_module_main_conf(cycle, module)                \\\n    (cycle->conf_ctx[ngx_rtmp_module.index] ?                             \\\n        ((ngx_rtmp_conf_ctx_t *) cycle->conf_ctx[ngx_rtmp_module.index])  \\\n            ->main_conf[module.ctx_index]:                                \\\n        NULL)\n\n\ntypedef struct ngx_http_flv_live_ctx_s {\n    ngx_rtmp_session_t  *s;\n    ngx_flag_t           header_sent;\n\n    ngx_str_t            app;\n    ngx_str_t            port;\n    ngx_str_t            stream;\n} ngx_http_flv_live_ctx_t;\n\n\ntypedef struct ngx_http_flv_live_conf_s {\n    ngx_flag_t    flv_live;\n} ngx_http_flv_live_conf_t;\n\n\ntypedef struct {\n    ngx_chain_t  *meta;\n    ngx_chain_t  *apkt;\n    ngx_chain_t  *acopkt;\n    ngx_chain_t  *rpkt;\n\n    ngx_int_t (*send_message_pt)(ngx_rtmp_session_t *s,\n        ngx_chain_t *out, ngx_uint_t priority);\n    ngx_chain_t *(*meta_message_pt)(ngx_rtmp_session_t *s,\n        ngx_chain_t *in);\n    ngx_chain_t *(*append_message_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_rtmp_header_t *lh,\n        ngx_chain_t *in);\n    void (*free_message_pt)(ngx_rtmp_session_t *s,\n        ngx_chain_t *in);\n} ngx_rtmp_live_proc_handler_t;\n\n\nngx_int_t ngx_http_flv_live_play(ngx_rtmp_session_t *s,\n    ngx_rtmp_play_t *v);\nngx_int_t ngx_http_flv_live_close_stream(ngx_rtmp_session_t *s,\n    ngx_rtmp_close_stream_t *v);\n\nngx_int_t ngx_http_flv_live_send_header(ngx_rtmp_session_t *s);\nvoid ngx_http_flv_live_set_status(ngx_rtmp_session_t *s, unsigned active);\n\n\n#endif\n\n"
        },
        {
          "name": "ngx_rtmp.c",
          "type": "blob",
          "size": 36.6123046875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <nginx.h>\n#include \"ngx_rtmp.h\"\n\n\nstatic char *ngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic ngx_int_t ngx_rtmp_optimize_servers(ngx_conf_t *cf,\n    ngx_rtmp_core_main_conf_t *cmcf, ngx_array_t *ports);\nstatic ngx_int_t ngx_rtmp_server_names(ngx_conf_t *cf,\n    ngx_rtmp_core_main_conf_t *cmcf, ngx_rtmp_conf_addr_t *addr);\nstatic int ngx_libc_cdecl ngx_rtmp_cmp_dns_wildcards(const void *one,\n    const void *two);\n\nstatic ngx_int_t ngx_rtmp_init_listening(ngx_conf_t *cf,\n    ngx_rtmp_conf_port_t *port);\nstatic ngx_listening_t *ngx_rtmp_add_listening(ngx_conf_t *cf,\n    ngx_rtmp_conf_addr_t *addr);\n\nstatic ngx_int_t ngx_rtmp_add_addrs(ngx_conf_t *cf, ngx_rtmp_port_t *mport,\n    ngx_rtmp_conf_addr_t *addr);\n#if (NGX_HAVE_INET6)\nstatic ngx_int_t ngx_rtmp_add_addrs6(ngx_conf_t *cf, ngx_rtmp_port_t *mport,\n    ngx_rtmp_conf_addr_t *addr);\n#endif\nstatic ngx_int_t ngx_rtmp_cmp_conf_addrs(const void *one, const void *two);\nstatic ngx_int_t ngx_rtmp_find_virtual_server(ngx_connection_t *c,\n    ngx_rtmp_virtual_names_t *virtual_names, ngx_str_t *host,\n    ngx_rtmp_session_t *s, ngx_rtmp_core_srv_conf_t **cscfp);\nstatic ngx_int_t ngx_rtmp_init_events(ngx_conf_t *cf,\n        ngx_rtmp_core_main_conf_t *cmcf);\nstatic ngx_int_t ngx_rtmp_init_event_handlers(ngx_conf_t *cf,\n        ngx_rtmp_core_main_conf_t *cmcf);\nstatic char * ngx_rtmp_merge_applications(ngx_conf_t *cf,\n        ngx_array_t *applications, void **app_conf, ngx_rtmp_module_t *module,\n        ngx_uint_t ctx_index);\nstatic ngx_int_t ngx_rtmp_init_process(ngx_cycle_t *cycle);\n\n\n#if (nginx_version >= 1007011)\nngx_queue_t                         ngx_rtmp_init_queue;\n#elif (nginx_version >= 1007005)\nngx_thread_volatile ngx_queue_t     ngx_rtmp_init_queue;\n#else\nngx_thread_volatile ngx_event_t    *ngx_rtmp_init_queue;\n#endif\n\n\nngx_uint_t  ngx_rtmp_max_module;\n\n\nstatic ngx_command_t  ngx_rtmp_commands[] = {\n\n    { ngx_string(\"rtmp\"),\n      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,\n      ngx_rtmp_block,\n      0,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_core_module_t  ngx_rtmp_module_ctx = {\n    ngx_string(\"rtmp\"),\n    NULL,\n    NULL\n};\n\n\nngx_module_t  ngx_rtmp_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_module_ctx,                  /* module context */\n    ngx_rtmp_commands,                     /* module directives */\n    NGX_CORE_MODULE,                       /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    ngx_rtmp_init_process,                 /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic char *\nngx_rtmp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                        *rv;\n    ngx_uint_t                   m, mi, s;\n    ngx_conf_t                   pcf;\n    ngx_module_t               **modules;\n    ngx_rtmp_module_t           *module;\n    ngx_rtmp_conf_ctx_t         *ctx;\n    ngx_rtmp_core_srv_conf_t    *cscf, **cscfp;\n    ngx_rtmp_core_main_conf_t   *cmcf;\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *(ngx_rtmp_conf_ctx_t **) conf = ctx;\n\n    /* count the number of the rtmp modules and set up their indices */\n\n#if (nginx_version >= 1009011)\n\n    ngx_rtmp_max_module = ngx_count_modules(cf->cycle, NGX_RTMP_MODULE);\n\n#else\n\n    ngx_rtmp_max_module = 0;\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        ngx_modules[m]->ctx_index = ngx_rtmp_max_module++;\n    }\n\n#endif\n\n\n    /* the rtmp main_conf context, it is the same in the all rtmp contexts */\n\n    ctx->main_conf = ngx_pcalloc(cf->pool,\n                                 sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->main_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the rtmp null srv_conf context, it is used to merge\n     * the server{}s' srv_conf's\n     */\n\n    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the rtmp null app_conf context, it is used to merge\n     * the server{}s' app_conf's\n     */\n\n    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * create the main_conf's, the null srv_conf's, and the null app_conf's\n     * of the all rtmp modules\n     */\n\n#if (nginx_version >= 1009011)\n    modules = cf->cycle->modules;\n#else\n    modules = ngx_modules;\n#endif\n\n    for (m = 0; modules[m]; m++) {\n        if (modules[m]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[m]->ctx;\n        mi = modules[m]->ctx_index;\n\n        if (module->create_main_conf) {\n            ctx->main_conf[mi] = module->create_main_conf(cf);\n            if (ctx->main_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module->create_srv_conf) {\n            ctx->srv_conf[mi] = module->create_srv_conf(cf);\n            if (ctx->srv_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module->create_app_conf) {\n            ctx->app_conf[mi] = module->create_app_conf(cf);\n            if (ctx->app_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    pcf = *cf;\n    cf->ctx = ctx;\n\n    for (m = 0; modules[m]; m++) {\n        if (modules[m]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[m]->ctx;\n\n        if (module->preconfiguration) {\n            if (module->preconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    /* parse inside the rtmp{} block */\n\n    cf->module_type = NGX_RTMP_MODULE;\n    cf->cmd_type = NGX_RTMP_MAIN_CONF;\n    rv = ngx_conf_parse(cf, NULL);\n\n    if (rv != NGX_CONF_OK) {\n        *cf = pcf;\n        return rv;\n    }\n\n\n    /* init rtmp{} main_conf's, merge the server{}s' srv_conf's */\n\n    cmcf = ctx->main_conf[ngx_rtmp_core_module.ctx_index];\n    cscfp = cmcf->servers.elts;\n\n    for (m = 0; modules[m]; m++) {\n        if (modules[m]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[m]->ctx;\n        mi = modules[m]->ctx_index;\n\n        /* init rtmp{} main_conf's */\n\n        cf->ctx = ctx;\n\n        if (module->init_main_conf) {\n            rv = module->init_main_conf(cf, ctx->main_conf[mi]);\n            if (rv != NGX_CONF_OK) {\n                *cf = pcf;\n                return rv;\n            }\n        }\n\n        for (s = 0; s < cmcf->servers.nelts; s++) {\n\n            /* merge the server{}s' srv_conf's */\n\n            cf->ctx = cscfp[s]->ctx;\n\n            if (module->merge_srv_conf) {\n                rv = module->merge_srv_conf(cf,\n                                            ctx->srv_conf[mi],\n                                            cscfp[s]->ctx->srv_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n\n            if (module->merge_app_conf) {\n\n                /* merge the server{}'s app_conf */\n\n                /*ctx->app_conf = cscfp[s]->ctx->app_conf;*/\n\n                rv = module->merge_app_conf(cf,\n                                            ctx->app_conf[mi],\n                                            cscfp[s]->ctx->app_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n\n                /* merge the applications{}' app_conf's */\n\n                cscf = cscfp[s]->ctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n\n                rv = ngx_rtmp_merge_applications(cf, &cscf->applications,\n                                            cscfp[s]->ctx->app_conf,\n                                            module, mi);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n\n        }\n    }\n\n    cf->ctx = ctx;\n\n    if (ngx_rtmp_init_events(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    for (m = 0; modules[m]; m++) {\n        if (modules[m]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[m]->ctx;\n\n        if (module->postconfiguration) {\n            if (module->postconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    *cf = pcf;\n\n    cscfp = cmcf->servers.elts;\n    for (s = 0; s < cmcf->servers.nelts; s++) {\n        cscfp[s]->index = s;\n    }\n\n    if (ngx_rtmp_init_event_handlers(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_rtmp_optimize_servers(cf, cmcf, cmcf->ports) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_merge_applications(ngx_conf_t *cf, ngx_array_t *applications,\n            void **app_conf, ngx_rtmp_module_t *module, ngx_uint_t ctx_index)\n{\n    char                           *rv;\n    ngx_rtmp_conf_ctx_t            *ctx, saved;\n    ngx_rtmp_core_app_conf_t      **cacfp;\n    ngx_uint_t                      n;\n    ngx_rtmp_core_app_conf_t       *cacf;\n\n    if (applications == NULL) {\n        return NGX_CONF_OK;\n    }\n\n    ctx = (ngx_rtmp_conf_ctx_t *) cf->ctx;\n    saved = *ctx;\n\n    cacfp = applications->elts;\n    for (n = 0; n < applications->nelts; ++n, ++cacfp) {\n\n        ctx->app_conf = (*cacfp)->app_conf;\n\n        rv = module->merge_app_conf(cf, app_conf[ctx_index],\n                (*cacfp)->app_conf[ctx_index]);\n        if (rv != NGX_CONF_OK) {\n            return rv;\n        }\n\n        cacf = (*cacfp)->app_conf[ngx_rtmp_core_module.ctx_index];\n        rv = ngx_rtmp_merge_applications(cf, &cacf->applications,\n                                         (*cacfp)->app_conf,\n                                         module, ctx_index);\n        if (rv != NGX_CONF_OK) {\n            return rv;\n        }\n    }\n\n    *ctx = saved;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_init_events(ngx_conf_t *cf, ngx_rtmp_core_main_conf_t *cmcf)\n{\n    size_t                      n;\n\n    for(n = 0; n < NGX_RTMP_MAX_EVENT; ++n) {\n        if (ngx_array_init(&cmcf->events[n], cf->pool, 1,\n                sizeof(ngx_rtmp_handler_pt)) != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    if (ngx_array_init(&cmcf->amf, cf->pool, 1,\n                sizeof(ngx_rtmp_amf_handler_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_init_event_handlers(ngx_conf_t *cf, ngx_rtmp_core_main_conf_t *cmcf)\n{\n    ngx_hash_init_t             calls_hash;\n    ngx_rtmp_handler_pt        *eh;\n    ngx_rtmp_amf_handler_t     *h;\n    ngx_hash_key_t             *ha;\n    size_t                      n, m;\n\n    static size_t               pm_events[] = {\n        NGX_RTMP_MSG_CHUNK_SIZE,\n        NGX_RTMP_MSG_ABORT,\n        NGX_RTMP_MSG_ACK,\n        NGX_RTMP_MSG_ACK_SIZE,\n        NGX_RTMP_MSG_BANDWIDTH\n    };\n\n    static size_t               amf_events[] = {\n        NGX_RTMP_MSG_AMF_CMD,\n        NGX_RTMP_MSG_AMF_META,\n        NGX_RTMP_MSG_AMF_SHARED,\n        NGX_RTMP_MSG_AMF3_CMD,\n        NGX_RTMP_MSG_AMF3_META,\n        NGX_RTMP_MSG_AMF3_SHARED\n    };\n\n    /* init standard protocol events */\n    for(n = 0; n < sizeof(pm_events) / sizeof(pm_events[0]); ++n) {\n        eh = ngx_array_push(&cmcf->events[pm_events[n]]);\n        *eh = ngx_rtmp_protocol_message_handler;\n    }\n\n    /* init amf events */\n    for(n = 0; n < sizeof(amf_events) / sizeof(amf_events[0]); ++n) {\n        eh = ngx_array_push(&cmcf->events[amf_events[n]]);\n        *eh = ngx_rtmp_amf_message_handler;\n    }\n\n    /* init user protocol events */\n    eh = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_USER]);\n    *eh = ngx_rtmp_user_message_handler;\n\n    /* aggregate to audio/video map */\n    eh = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_AGGREGATE]);\n    *eh = ngx_rtmp_aggregate_message_handler;\n\n    /* init amf callbacks */\n    ngx_array_init(&cmcf->amf_arrays, cf->pool, 1, sizeof(ngx_hash_key_t));\n\n    h = cmcf->amf.elts;\n    for(n = 0; n < cmcf->amf.nelts; ++n, ++h) {\n        ha = cmcf->amf_arrays.elts;\n        for(m = 0; m < cmcf->amf_arrays.nelts; ++m, ++ha) {\n            if (h->name.len == ha->key.len\n                    && !ngx_strncmp(h->name.data, ha->key.data, ha->key.len))\n            {\n                break;\n            }\n        }\n        if (m == cmcf->amf_arrays.nelts) {\n            ha = ngx_array_push(&cmcf->amf_arrays);\n            ha->key = h->name;\n            ha->key_hash = ngx_hash_key_lc(ha->key.data, ha->key.len);\n            ha->value = ngx_array_create(cf->pool, 1,\n                    sizeof(ngx_rtmp_handler_pt));\n            if (ha->value == NULL) {\n                return NGX_ERROR;\n            }\n        }\n\n        eh = ngx_array_push((ngx_array_t*)ha->value);\n        *eh = h->handler;\n    }\n\n    calls_hash.hash = &cmcf->amf_hash;\n    calls_hash.key = ngx_hash_key_lc;\n    calls_hash.max_size = 512;\n    calls_hash.bucket_size = ngx_cacheline_size;\n    calls_hash.name = \"amf_hash\";\n    calls_hash.pool = cf->pool;\n    calls_hash.temp_pool = NULL;\n\n    if (ngx_hash_init(&calls_hash, cmcf->amf_arrays.elts, cmcf->amf_arrays.nelts)\n            != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_optimize_servers(ngx_conf_t *cf, ngx_rtmp_core_main_conf_t *cmcf,\n    ngx_array_t *ports)\n{\n    ngx_uint_t             p, a;\n    ngx_rtmp_conf_port_t  *port;\n    ngx_rtmp_conf_addr_t  *addr;\n\n    if (ports == NULL) {\n        return NGX_OK;\n    }\n\n    port = ports->elts;\n    for (p = 0; p < ports->nelts; p++) {\n\n        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,\n                 sizeof(ngx_rtmp_conf_addr_t), ngx_rtmp_cmp_conf_addrs);\n\n        /*\n         * check whether all name-based servers have the same\n         * configuration as a default server for given address:port\n         */\n\n        addr = port[p].addrs.elts;\n        for (a = 0; a < port[p].addrs.nelts; a++) {\n\n            if (addr[a].servers.nelts > 1\n#if (NGX_PCRE)\n                || addr[a].default_server->captures\n#endif\n               )\n            {\n                if (ngx_rtmp_server_names(cf, cmcf, &addr[a]) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n\n        if (ngx_rtmp_init_listening(cf, &port[p]) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_server_names(ngx_conf_t *cf, ngx_rtmp_core_main_conf_t *cmcf,\n    ngx_rtmp_conf_addr_t *addr)\n{\n    ngx_int_t                   rc;\n    ngx_uint_t                  n, s;\n    ngx_hash_init_t             hash;\n    ngx_hash_keys_arrays_t      ha;\n    ngx_rtmp_server_name_t     *name;\n    ngx_rtmp_core_srv_conf_t  **cscfp;\n#if (NGX_PCRE)\n    ngx_uint_t                  regex, i;\n\n    regex = 0;\n#endif\n\n    ngx_memzero(&ha, sizeof(ngx_hash_keys_arrays_t));\n\n    ha.temp_pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf->log);\n    if (ha.temp_pool == NULL) {\n        return NGX_ERROR;\n    }\n\n    ha.pool = cf->pool;\n\n    if (ngx_hash_keys_array_init(&ha, NGX_HASH_LARGE) != NGX_OK) {\n        goto failed;\n    }\n\n    cscfp = addr->servers.elts;\n\n    for (s = 0; s < addr->servers.nelts; s++) {\n\n        name = cscfp[s]->server_names.elts;\n\n        for (n = 0; n < cscfp[s]->server_names.nelts; n++) {\n\n#if (NGX_PCRE)\n            if (name[n].regex) {\n                regex++;\n                continue;\n            }\n#endif\n\n            rc = ngx_hash_add_key(&ha, &name[n].name, name[n].server,\n                                  NGX_HASH_WILDCARD_KEY);\n\n            if (rc == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n\n            if (rc == NGX_DECLINED) {\n                ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                              \"invalid server name or wildcard \\\"%V\\\" on %s\",\n                              &name[n].name, addr->opt.addr);\n                return NGX_ERROR;\n            }\n\n            if (rc == NGX_BUSY) {\n                ngx_log_error(NGX_LOG_WARN, cf->log, 0,\n                              \"conflicting server name \\\"%V\\\" on %s, ignored\",\n                              &name[n].name, addr->opt.addr);\n            }\n        }\n    }\n\n    hash.key = ngx_hash_key_lc;\n    hash.max_size = cmcf->server_names_hash_max_size;\n    hash.bucket_size = cmcf->server_names_hash_bucket_size;\n    hash.name = \"server_names_hash\";\n    hash.pool = cf->pool;\n\n    if (ha.keys.nelts) {\n        hash.hash = &addr->hash;\n        hash.temp_pool = NULL;\n\n        if (ngx_hash_init(&hash, ha.keys.elts, ha.keys.nelts) != NGX_OK) {\n            goto failed;\n        }\n    }\n\n    if (ha.dns_wc_head.nelts) {\n\n        ngx_qsort(ha.dns_wc_head.elts, (size_t) ha.dns_wc_head.nelts,\n                  sizeof(ngx_hash_key_t), ngx_rtmp_cmp_dns_wildcards);\n\n        hash.hash = NULL;\n        hash.temp_pool = ha.temp_pool;\n\n        if (ngx_hash_wildcard_init(&hash, ha.dns_wc_head.elts,\n                                   ha.dns_wc_head.nelts)\n            != NGX_OK)\n        {\n            goto failed;\n        }\n\n        addr->wc_head = (ngx_hash_wildcard_t *) hash.hash;\n    }\n\n    if (ha.dns_wc_tail.nelts) {\n\n        ngx_qsort(ha.dns_wc_tail.elts, (size_t) ha.dns_wc_tail.nelts,\n                  sizeof(ngx_hash_key_t), ngx_rtmp_cmp_dns_wildcards);\n\n        hash.hash = NULL;\n        hash.temp_pool = ha.temp_pool;\n\n        if (ngx_hash_wildcard_init(&hash, ha.dns_wc_tail.elts,\n                                   ha.dns_wc_tail.nelts)\n            != NGX_OK)\n        {\n            goto failed;\n        }\n\n        addr->wc_tail = (ngx_hash_wildcard_t *) hash.hash;\n    }\n\n    ngx_destroy_pool(ha.temp_pool);\n\n#if (NGX_PCRE)\n\n    if (regex == 0) {\n        return NGX_OK;\n    }\n\n    addr->nregex = regex;\n    addr->regex = ngx_palloc(cf->pool, regex * sizeof(ngx_rtmp_server_name_t));\n    if (addr->regex == NULL) {\n        return NGX_ERROR;\n    }\n\n    i = 0;\n\n    for (s = 0; s < addr->servers.nelts; s++) {\n\n        name = cscfp[s]->server_names.elts;\n\n        for (n = 0; n < cscfp[s]->server_names.nelts; n++) {\n            if (name[n].regex) {\n                addr->regex[i++] = name[n];\n            }\n        }\n    }\n\n#endif\n\n    return NGX_OK;\n\nfailed:\n\n    ngx_destroy_pool(ha.temp_pool);\n\n    return NGX_ERROR;\n}\n\n\nstatic int ngx_libc_cdecl\nngx_rtmp_cmp_dns_wildcards(const void *one, const void *two)\n{\n    ngx_hash_key_t  *first, *second;\n\n    first = (ngx_hash_key_t *) one;\n    second = (ngx_hash_key_t *) two;\n\n    return ngx_dns_strcmp(first->key.data, second->key.data);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_init_listening(ngx_conf_t *cf, ngx_rtmp_conf_port_t *port)\n{\n    ngx_uint_t                 i, last, bind_wildcard;\n    ngx_listening_t           *ls;\n    ngx_rtmp_port_t           *rport;\n    ngx_rtmp_conf_addr_t      *addr;\n\n    addr = port->addrs.elts;\n    last = port->addrs.nelts;\n\n    /*\n     * If there is a binding to an \"*:port\" then we need to bind() to\n     * the \"*:port\" only and ignore other implicit bindings.  The bindings\n     * have been already sorted: explicit bindings are on the start, then\n     * implicit bindings go, and wildcard binding is in the end.\n     */\n\n    if (addr[last - 1].opt.wildcard) {\n        addr[last - 1].opt.bind = 1;\n        bind_wildcard = 1;\n\n    } else {\n        bind_wildcard = 0;\n    }\n\n    i = 0;\n\n    while (i < last) {\n\n        if (bind_wildcard && !addr[i].opt.bind) {\n            i++;\n            continue;\n        }\n\n        ls = ngx_rtmp_add_listening(cf, &addr[i]);\n        if (ls == NULL) {\n            return NGX_ERROR;\n        }\n\n        rport = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_port_t));\n        if (rport == NULL) {\n            return NGX_ERROR;\n        }\n\n        /* used in ngx_rtmp_init_connection */\n        ls->servers = rport;\n\n        rport->naddrs = i + 1;\n\n        switch (ls->sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n            case AF_INET6:\n                if (ngx_rtmp_add_addrs6(cf, rport, addr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n#endif\n            default: /* AF_INET */\n                if (ngx_rtmp_add_addrs(cf, rport, addr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n        }\n\n#if (nginx_version >= 1009001 && nginx_version <= 1015001)\n        if (ngx_clone_listening(cf, ls) != NGX_OK) {\n            return NGX_ERROR;\n        }\n#endif\n\n        addr++;\n        last--;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_listening_t *\nngx_rtmp_add_listening(ngx_conf_t *cf, ngx_rtmp_conf_addr_t *addr)\n{\n    ngx_listening_t           *ls;\n    ngx_rtmp_core_srv_conf_t  *cscf;\n\n    ls = ngx_create_listening(cf, &addr->opt.sockaddr.sockaddr,\n                              addr->opt.socklen);\n    if (ls == NULL) {\n        return NULL;\n    }\n\n    ls->addr_ntop = 1;\n\n    ls->handler = ngx_rtmp_init_connection;\n\n    cscf = addr->default_server;\n    ls->pool_size = cscf->connection_pool_size;\n\n    ls->logp = &cf->cycle->new_log;\n    ls->log.data = &ls->addr_text;\n    ls->log.handler = ngx_accept_log_error;\n\n#if (NGX_WIN32)\n    {\n        ngx_iocp_conf_t  *iocpcf = NULL;\n\n        if (ngx_get_conf(cf->cycle->conf_ctx, ngx_events_module)) {\n            iocpcf = ngx_event_get_conf(cf->cycle->conf_ctx, ngx_iocp_module);\n        }\n        if (iocpcf && iocpcf->acceptex_read) {\n            ls->post_accept_buffer_size = 1024;\n        }\n    }\n#endif\n\n    ls->backlog = addr->opt.backlog;\n    ls->rcvbuf = addr->opt.rcvbuf;\n    ls->sndbuf = addr->opt.sndbuf;\n\n    ls->keepalive = addr->opt.so_keepalive;\n#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n    ls->keepidle = addr->opt.tcp_keepidle;\n    ls->keepintvl = addr->opt.tcp_keepintvl;\n    ls->keepcnt = addr->opt.tcp_keepcnt;\n#endif\n\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n    ls->accept_filter = addr->opt.accept_filter;\n#endif\n\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n    ls->deferred_accept = addr->opt.deferred_accept;\n#endif\n\n#if (NGX_HAVE_INET6)\n    ls->ipv6only = addr->opt.ipv6only;\n#endif\n\n#if (NGX_HAVE_SETFIB)\n    ls->setfib = addr->opt.setfib;\n#endif\n\n#if (NGX_HAVE_TCP_FASTOPEN)\n    ls->fastopen = addr->opt.fastopen;\n#endif\n\n#if (NGX_HAVE_REUSEPORT)\n    ls->reuseport = addr->opt.reuseport;\n#endif\n\n    return ls;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_add_addrs(ngx_conf_t *cf, ngx_rtmp_port_t *mport,\n    ngx_rtmp_conf_addr_t *addr)\n{\n    ngx_uint_t                 i;\n    ngx_rtmp_in_addr_t        *addrs;\n    struct sockaddr_in        *sin;\n    ngx_rtmp_virtual_names_t  *vn;\n\n    u_char                    *p, buf[NGX_SOCKADDR_STRLEN];\n    size_t                     len;\n\n    mport->addrs = ngx_pcalloc(cf->pool,\n                               mport->naddrs * sizeof(ngx_rtmp_in_addr_t));\n    if (mport->addrs == NULL) {\n        return NGX_ERROR;\n    }\n\n    addrs = mport->addrs;\n\n    for (i = 0; i < mport->naddrs; i++) {\n\n        sin = &addr[i].opt.sockaddr.sockaddr_in;\n        addrs[i].addr = sin->sin_addr.s_addr;\n        addrs[i].conf.default_server = addr[i].default_server;\n        addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;\n\n        len = ngx_sock_ntop(&addr[i].opt.sockaddr.sockaddr,\n#if (nginx_version >= 1005003)\n                            addr[i].opt.socklen,\n#endif\n                            buf, NGX_SOCKADDR_STRLEN, 1);\n\n        p = ngx_pcalloc(cf->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(p, buf, len);\n        addrs[i].conf.addr_text.len = len;\n        addrs[i].conf.addr_text.data = p;\n\n        if (addr[i].hash.buckets == NULL\n            && (addr[i].wc_head == NULL\n                || addr[i].wc_head->hash.buckets == NULL)\n            && (addr[i].wc_tail == NULL\n                || addr[i].wc_tail->hash.buckets == NULL)\n#if (NGX_PCRE)\n            && addr[i].nregex == 0\n#endif\n            )\n        {\n            continue;\n        }\n\n        vn = ngx_palloc(cf->pool, sizeof(ngx_rtmp_virtual_names_t));\n        if (vn == NULL) {\n            return NGX_ERROR;\n        }\n\n        addrs[i].conf.virtual_names = vn;\n\n        vn->names.hash = addr[i].hash;\n        vn->names.wc_head = addr[i].wc_head;\n        vn->names.wc_tail = addr[i].wc_tail;\n#if (NGX_PCRE)\n        vn->nregex = addr[i].nregex;\n        vn->regex = addr[i].regex;\n#endif\n    }\n\n    return NGX_OK;\n}\n\n\n#if (NGX_HAVE_INET6)\n\nstatic ngx_int_t\nngx_rtmp_add_addrs6(ngx_conf_t *cf, ngx_rtmp_port_t *mport,\n    ngx_rtmp_conf_addr_t *addr)\n{\n    ngx_uint_t                 i;\n    ngx_rtmp_in6_addr_t       *addrs6;\n    struct sockaddr_in6       *sin6;\n    ngx_rtmp_virtual_names_t  *vn;\n\n    u_char                    *p, buf[NGX_SOCKADDR_STRLEN];\n    size_t                     len;\n\n    mport->addrs = ngx_pcalloc(cf->pool,\n                               mport->naddrs * sizeof(ngx_rtmp_in6_addr_t));\n    if (mport->addrs == NULL) {\n        return NGX_ERROR;\n    }\n\n    addrs6 = mport->addrs;\n\n    for (i = 0; i < mport->naddrs; i++) {\n\n        sin6 = &addr[i].opt.sockaddr.sockaddr_in6;\n        addrs6[i].addr6 = sin6->sin6_addr;\n        addrs6[i].conf.default_server = addr[i].default_server;\n        addrs6[i].conf.proxy_protocol = addr[i].opt.proxy_protocol;\n\n        len = ngx_sock_ntop(&addr[i].opt.sockaddr.sockaddr,\n#if (nginx_version >= 1005003)\n                            addr[i].opt.socklen,\n#endif\n                            buf, NGX_SOCKADDR_STRLEN, 1);\n\n        p = ngx_pcalloc(cf->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(p, buf, len);\n        addrs6[i].conf.addr_text.len = len;\n        addrs6[i].conf.addr_text.data = p;\n\n        if (addr[i].hash.buckets == NULL\n            && (addr[i].wc_head == NULL\n                || addr[i].wc_head->hash.buckets == NULL)\n            && (addr[i].wc_tail == NULL\n                || addr[i].wc_tail->hash.buckets == NULL)\n#if (NGX_PCRE)\n            && addr[i].nregex == 0\n#endif\n            )\n        {\n            continue;\n        }\n\n        vn = ngx_palloc(cf->pool, sizeof(ngx_rtmp_virtual_names_t));\n        if (vn == NULL) {\n            return NGX_ERROR;\n        }\n\n        addrs6[i].conf.virtual_names = vn;\n\n        vn->names.hash = addr[i].hash;\n        vn->names.wc_head = addr[i].wc_head;\n        vn->names.wc_tail = addr[i].wc_tail;\n#if (NGX_PCRE)\n        vn->nregex = addr[i].nregex;\n        vn->regex = addr[i].regex;\n#endif\n    }\n\n    return NGX_OK;\n}\n\n#endif\n\n\nstatic ngx_int_t\nngx_rtmp_cmp_conf_addrs(const void *one, const void *two)\n{\n    ngx_rtmp_conf_addr_t  *first, *second;\n\n    first = (ngx_rtmp_conf_addr_t *) one;\n    second = (ngx_rtmp_conf_addr_t *) two;\n\n    if (first->opt.wildcard) {\n        /* a wildcard address must be the last resort, shift it to the end */\n        return 1;\n    }\n\n    if (second->opt.wildcard) {\n        /* a wildcard address must be the last resort, shift it to the end */\n        return -1;\n    }\n\n    if (first->opt.bind && !second->opt.bind) {\n        /* shift explicit bind()ed addresses to the start */\n        return -1;\n    }\n\n    if (!first->opt.bind && second->opt.bind) {\n        /* shift explicit bind()ed addresses to the start */\n        return 1;\n    }\n\n    /* do not sort by default */\n\n    return 0;\n}\n\n\nngx_int_t\nngx_rtmp_fire_event(ngx_rtmp_session_t *s, ngx_uint_t evt,\n        ngx_rtmp_header_t *h, ngx_chain_t *in)\n{\n    ngx_rtmp_core_main_conf_t      *cmcf;\n    ngx_array_t                    *ch;\n    ngx_rtmp_handler_pt            *hh;\n    size_t                          n;\n\n    cmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_core_module);\n\n    ch = &cmcf->events[evt];\n    hh = ch->elts;\n    for(n = 0; n < ch->nelts; ++n, ++hh) {\n        if (*hh && (*hh)(s, h, in) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n    return NGX_OK;\n}\n\n\nvoid *\nngx_rtmp_rmemcpy(void *dst, const void* src, size_t n)\n{\n    u_char     *d, *s;\n\n    d = dst;\n    s = (u_char*)src + n - 1;\n\n    while(s >= (u_char*)src) {\n        *d++ = *s--;\n    }\n\n    return dst;\n}\n\n\nu_char *\nngx_rtmp_h4_to_n3(u_char *dst, uint32_t h)\n{\n    dst[0] = (u_char) (h >> 16);\n    dst[1] = (u_char) (h >> 8);\n    dst[2] = (u_char) h;\n\n    return dst;\n}\n\n\nuint32_t\nngx_rtmp_n3_to_h4(u_char *n)\n{\n    return ((uint32_t) n[0] << 16) | ((uint32_t) n[1] << 8) | (uint32_t) n[2];\n}\n\n\nstatic ngx_int_t\nngx_rtmp_init_process(ngx_cycle_t *cycle)\n{\n#if (nginx_version >= 1007005)\n    ngx_queue_init(&ngx_rtmp_init_queue);\n#endif\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_process_virtual_host(ngx_rtmp_session_t *s)\n{\n    u_char     *p;\n    ngx_int_t   rc;\n    ngx_str_t   host;\n    ngx_str_t   hschema, rschema, *schema;\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    hschema.data = (u_char *)\"http://\";\n    hschema.len = ngx_strlen(hschema.data);\n\n    rschema.data = (u_char *) \"rtmp://\";\n    rschema.len = ngx_strlen(rschema.data);\n\n    do {\n        schema = &hschema;\n\n        if (s->tc_url.len > schema->len\n            && ngx_strncasecmp(s->tc_url.data, schema->data, schema->len) == 0)\n        {\n            break;\n        }\n\n        schema = &rschema;\n\n        if (s->tc_url.len > schema->len\n            && ngx_strncasecmp(s->tc_url.data, schema->data, schema->len) == 0)\n        {\n            break;\n        }\n\n        return NGX_ERROR;\n    } while (0);\n\n    s->host_start = s->tc_url.data + schema->len;\n\n    p = ngx_strlchr(s->host_start, s->tc_url.data + s->tc_url.len, ':');\n    if (p) {\n        s->host_end = p;\n    } else {\n        p = ngx_strlchr(s->host_start, s->tc_url.data + s->tc_url.len, '/');\n        s->host_end = p ? p : (s->host_start + s->tc_url.len - schema->len);\n    }\n\nnext:\n    host.len = s->host_end - s->host_start;\n    host.data = s->host_start;\n\n    rc = ngx_rtmp_validate_host(&host, s->connection->pool, 0);\n\n    if (rc == NGX_DECLINED) {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                      \"client send invalid host in request line\");\n        return NGX_ERROR;\n    }\n\n#if 0\n    /* TODO: send error details to client */\n    if (rc == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (ngx_rtmp_set_virtual_server(s, &host) == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_validate_host(ngx_str_t *host, ngx_pool_t *pool, ngx_uint_t alloc)\n{\n    u_char  *h, ch;\n    size_t   i, dot_pos, host_len;\n\n    enum {\n        sw_usual = 0,\n        sw_literal,\n        sw_rest\n    } state;\n\n    dot_pos = host->len;\n    host_len = host->len;\n\n    h = host->data;\n\n    state = sw_usual;\n\n    for (i = 0; i < host->len; i++) {\n        ch = h[i];\n\n        switch (ch) {\n\n        case '.':\n            if (dot_pos == i - 1) {\n                return NGX_DECLINED;\n            }\n            dot_pos = i;\n            break;\n\n        case ':':\n            if (state == sw_usual) {\n                host_len = i;\n                state = sw_rest;\n            }\n            break;\n\n        case '[':\n            if (i == 0) {\n                state = sw_literal;\n            }\n            break;\n\n        case ']':\n            if (state == sw_literal) {\n                host_len = i + 1;\n                state = sw_rest;\n            }\n            break;\n\n        case '\\0':\n            return NGX_DECLINED;\n\n        default:\n\n            if (ngx_path_separator(ch)) {\n                return NGX_DECLINED;\n            }\n\n            if (ch >= 'A' && ch <= 'Z') {\n                alloc = 1;\n            }\n\n            break;\n        }\n    }\n\n    if (dot_pos == host_len - 1) {\n        host_len--;\n    }\n\n    if (host_len == 0) {\n        return NGX_DECLINED;\n    }\n\n    if (alloc) {\n        host->data = ngx_pnalloc(pool, host_len);\n        if (host->data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(host->data, h, host_len);\n    }\n\n    host->len = host_len;\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_set_virtual_server(ngx_rtmp_session_t *s, ngx_str_t *host)\n{\n    ngx_int_t                  rc;\n    ngx_int_t                  i;\n    ngx_rtmp_connection_t     *rconn;\n    ngx_rtmp_core_srv_conf_t  *cscf, *dcscf;\n    ngx_rtmp_stream_t         *in_streams;\n\n#if (NGX_SUPPRESS_WARN)\n    cscf = NULL;\n#endif\n\n    rconn = s->rtmp_connection;\n\n    rc = ngx_rtmp_find_virtual_server(s->connection,\n                                      rconn->addr_conf->virtual_names,\n                                      host, s, &cscf);\n\n    if (rc == NGX_ERROR) {\n        ngx_rtmp_finalize_session(s);\n        return NGX_ERROR;\n    }\n\n    if (rc == NGX_DECLINED) {\n        return NGX_OK;\n    }\n\n    dcscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    /* reinitialization */\n    s->server_changed = 1;\n    s->srv_conf = cscf->ctx->srv_conf;\n\n    if (dcscf->out_queue != cscf->out_queue) {\n        /* use new pool */\n        s->out_temp_pool = ngx_create_pool(4096, s->connection->log);\n        if (s->out_temp_pool == NULL) {\n            ngx_rtmp_finalize_session(s);\n            return NGX_ERROR;\n        }\n\n        /* save memory */\n        ngx_destroy_pool(s->out_pool);\n        s->out_pool = s->out_temp_pool;\n\n        /* send not used yet, need not copy data */\n        s->out = ngx_pcalloc(s->out_pool, sizeof(ngx_chain_t *)\n                    * ((ngx_rtmp_core_srv_conf_t *)\n                        cscf->ctx->srv_conf[ngx_rtmp_core_module\n                            .ctx_index])->out_queue);\n\n        s->out_queue = cscf->out_queue;\n    }\n\n    if (dcscf->max_streams != cscf->max_streams) {\n        /* use new pool */\n        s->in_streams_temp_pool = ngx_create_pool(4096, s->connection->log);\n        if (s->in_streams_temp_pool == NULL) {\n            ngx_rtmp_finalize_session(s);\n            return NGX_ERROR;\n        }\n\n        in_streams = ngx_pcalloc(s->in_streams_temp_pool,\n                           sizeof(ngx_rtmp_stream_t) * cscf->max_streams);\n        if (in_streams == NULL) {\n            ngx_rtmp_finalize_session(s);\n            return NGX_ERROR;\n        }\n\n        /* copy data from s->in_streams to in_streams */\n        ngx_memmove(in_streams, s->in_streams, sizeof(ngx_rtmp_stream_t)\n                    * ngx_min(dcscf->max_streams, cscf->max_streams));\n\n        if (dcscf->max_streams > cscf->max_streams) {\n            for (i = cscf->max_streams; i < dcscf->max_streams; i++) {\n                if (s->in_streams[i].hdr.csid) {\n                    ngx_rtmp_finalize_session(s);\n                    return NGX_ERROR;\n                }\n            }\n        }\n\n        s->in_streams = in_streams;\n\n        /* save memory */\n        ngx_destroy_pool(s->in_streams_pool);\n        s->in_streams_pool = s->in_streams_temp_pool;\n    }\n\n    s->out_cork = cscf->out_cork;\n    s->timeout = cscf->timeout;\n    s->buflen = cscf->buflen;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_find_virtual_server(ngx_connection_t *c,\n    ngx_rtmp_virtual_names_t *virtual_names, ngx_str_t *host,\n    ngx_rtmp_session_t *s, ngx_rtmp_core_srv_conf_t **cscfp)\n{\n    ngx_rtmp_core_srv_conf_t  *cscf;\n\n    if (virtual_names == NULL) {\n        return NGX_DECLINED;\n    }\n\n    cscf = ngx_hash_find_combined(&virtual_names->names,\n                                  ngx_hash_key(host->data, host->len),\n                                  host->data, host->len);\n\n    if (cscf) {\n        *cscfp = cscf;\n        return NGX_OK;\n    }\n\n#if (NGX_PCRE)\n\n    if (host->len && virtual_names->nregex) {\n        ngx_int_t                n;\n        ngx_uint_t               i;\n        ngx_rtmp_server_name_t  *sn;\n\n        sn = virtual_names->regex;\n\n        for (i = 0; i < virtual_names->nregex; i++) {\n\n            n = ngx_rtmp_regex_exec(s, sn[i].regex, host);\n\n            if (n == NGX_DECLINED) {\n                continue;\n            }\n\n            if (n == NGX_OK) {\n                *cscfp = sn[i].server;\n                return NGX_OK;\n            }\n\n            return NGX_ERROR;\n        }\n    }\n\n#endif /* NGX_PCRE */\n\n    return NGX_DECLINED;\n}\n\n\n#if (nginx_version <= 1011001)\nin_port_t\nngx_inet_get_port(struct sockaddr *sa)\n{\n    struct sockaddr_in   *sin;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6  *sin6;\n#endif\n\n    switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        sin6 = (struct sockaddr_in6 *) sa;\n        return ntohs(sin6->sin6_port);\n#endif\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    case AF_UNIX:\n        return 0;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) sa;\n        return ntohs(sin->sin_port);\n    }\n}\n\n\nvoid\nngx_inet_set_port(struct sockaddr *sa, in_port_t port)\n{\n    struct sockaddr_in   *sin;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6  *sin6;\n#endif\n\n    switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        sin6 = (struct sockaddr_in6 *) sa;\n        sin6->sin6_port = htons(port);\n        break;\n#endif\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    case AF_UNIX:\n        break;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) sa;\n        sin->sin_port = htons(port);\n        break;\n    }\n}\n#endif\n"
        },
        {
          "name": "ngx_rtmp.h",
          "type": "blob",
          "size": 25.8779296875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#ifndef _NGX_RTMP_H_INCLUDED_\n#define _NGX_RTMP_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_event_connect.h>\n#include <nginx.h>\n\n#include \"ngx_rtmp_amf.h\"\n#include \"ngx_rtmp_bandwidth.h\"\n\n\ntypedef struct ngx_rtmp_core_srv_conf_s  ngx_rtmp_core_srv_conf_t;\ntypedef struct ngx_rtmp_session_s        ngx_rtmp_session_t;\ntypedef struct ngx_rtmp_virtual_names_s  ngx_rtmp_virtual_names_t;\n\n\n#include \"ngx_rtmp_variables.h\"\n\n\n#if (NGX_WIN32)\ntypedef __int8              int8_t;\ntypedef unsigned __int8     uint8_t;\n#endif\n\n\ntypedef struct {\n    void                  **main_conf;\n    void                  **srv_conf;\n    void                  **app_conf;\n} ngx_rtmp_conf_ctx_t;\n\n\ntypedef struct {\n    ngx_str_t                  addr_text;\n\n    /* the default server configuration for this address:port */\n    ngx_rtmp_core_srv_conf_t  *default_server;\n\n    ngx_rtmp_virtual_names_t  *virtual_names;\n\n    unsigned                   proxy_protocol:1;\n} ngx_rtmp_addr_conf_t;\n\ntypedef struct {\n    in_addr_t               addr;\n    ngx_rtmp_addr_conf_t    conf;\n} ngx_rtmp_in_addr_t;\n\n\n#if (NGX_HAVE_INET6)\n\ntypedef struct {\n    struct in6_addr         addr6;\n    ngx_rtmp_addr_conf_t    conf;\n} ngx_rtmp_in6_addr_t;\n\n#endif\n\n\ntypedef struct {\n    /* ngx_rtmp_in_addr_t or ngx_rtmp_in_addr6_t */\n    void                   *addrs;\n    ngx_uint_t              naddrs;\n} ngx_rtmp_port_t;\n\n\ntypedef struct {\n    int                     family;\n    in_port_t               port;\n    ngx_array_t             addrs;       /* array of ngx_rtmp_conf_addr_t */\n} ngx_rtmp_conf_port_t;\n\n\n#if (nginx_version <= 1010003)\ntypedef union {\n    struct sockaddr           sockaddr;\n    struct sockaddr_in        sockaddr_in;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6       sockaddr_in6;\n#endif\n#if (NGX_HAVE_UNIX_DOMAIN)\n    struct sockaddr_un        sockaddr_un;\n#endif\n} ngx_sockaddr_t;\n#endif\n\n\ntypedef struct {\n    ngx_sockaddr_t             sockaddr;\n    socklen_t                  socklen;\n\n    unsigned                   set:1;\n    unsigned                   default_server:1;\n    unsigned                   bind:1;\n    unsigned                   wildcard:1;\n#if (NGX_HAVE_INET6)\n    unsigned                   ipv6only:1;\n#endif\n    unsigned                   deferred_accept:1;\n    unsigned                   reuseport:1;\n    unsigned                   so_keepalive:2;\n    unsigned                   proxy_protocol:1;\n\n    int                        backlog;\n    int                        rcvbuf;\n    int                        sndbuf;\n#if (NGX_HAVE_SETFIB)\n    int                        setfib;\n#endif\n#if (NGX_HAVE_TCP_FASTOPEN)\n    int                        fastopen;\n#endif\n#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n    int                        tcp_keepidle;\n    int                        tcp_keepintvl;\n    int                        tcp_keepcnt;\n#endif\n\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n    char                      *accept_filter;\n#endif\n\n    u_char                     addr[NGX_SOCKADDR_STRLEN + 1];\n} ngx_rtmp_listen_opt_t;\n\n\ntypedef struct {\n#if (NGX_PCRE)\n    ngx_rtmp_regex_t          *regex;\n#endif\n    ngx_rtmp_core_srv_conf_t  *server;  /* virtual name server conf */\n    ngx_str_t                  name;\n} ngx_rtmp_server_name_t;\n\n\ntypedef struct {\n    ngx_rtmp_listen_opt_t   opt;\n\n    ngx_hash_t              hash;\n    ngx_hash_wildcard_t    *wc_head;\n    ngx_hash_wildcard_t    *wc_tail;\n\n#if (NGX_PCRE)\n    ngx_uint_t              nregex;\n    ngx_rtmp_server_name_t  *regex;\n#endif\n\n    /* the default server configuration for this address:port */\n    ngx_rtmp_core_srv_conf_t *default_server;\n    ngx_array_t               servers;  /* array of ngx_rtmp_core_srv_conf_t */\n} ngx_rtmp_conf_addr_t;\n\n\ntypedef struct {\n    ngx_rtmp_addr_conf_t             *addr_conf;\n    ngx_rtmp_conf_ctx_t              *conf_ctx;\n\n    ngx_buf_t                       **busy;\n    ngx_int_t                         nbusy;\n\n    ngx_buf_t                       **free;\n    ngx_int_t                         nfree;\n} ngx_rtmp_connection_t;\n\n\n#define NGX_RTMP_VERSION                3\n\n#define NGX_LOG_DEBUG_RTMP              NGX_LOG_DEBUG_CORE\n\n#define NGX_RTMP_DEFAULT_CHUNK_SIZE     128\n\n\n/* RTMP message types */\n#define NGX_RTMP_MSG_CHUNK_SIZE         1\n#define NGX_RTMP_MSG_ABORT              2\n#define NGX_RTMP_MSG_ACK                3\n#define NGX_RTMP_MSG_USER               4\n#define NGX_RTMP_MSG_ACK_SIZE           5\n#define NGX_RTMP_MSG_BANDWIDTH          6\n#define NGX_RTMP_MSG_EDGE               7\n#define NGX_RTMP_MSG_AUDIO              8\n#define NGX_RTMP_MSG_VIDEO              9\n#define NGX_RTMP_MSG_AMF3_META          15\n#define NGX_RTMP_MSG_AMF3_SHARED        16\n#define NGX_RTMP_MSG_AMF3_CMD           17\n#define NGX_RTMP_MSG_AMF_META           18\n#define NGX_RTMP_MSG_AMF_SHARED         19\n#define NGX_RTMP_MSG_AMF_CMD            20\n#define NGX_RTMP_MSG_AGGREGATE          22\n#define NGX_RTMP_MSG_MAX                22\n\n#define NGX_RTMP_MAX_CHUNK_SIZE         10485760\n\n#define NGX_RTMP_CONNECT                NGX_RTMP_MSG_MAX + 1\n#define NGX_RTMP_DISCONNECT             NGX_RTMP_MSG_MAX + 2\n#define NGX_RTMP_HANDSHAKE_DONE         NGX_RTMP_MSG_MAX + 3\n#define NGX_HTTP_FLV_LIVE_REQUEST       NGX_RTMP_MSG_MAX + 4\n#define NGX_RTMP_MAX_EVENT              NGX_RTMP_MSG_MAX + 5\n\n\n/* RMTP control message types */\n#define NGX_RTMP_USER_STREAM_BEGIN      0\n#define NGX_RTMP_USER_STREAM_EOF        1\n#define NGX_RTMP_USER_STREAM_DRY        2\n#define NGX_RTMP_USER_SET_BUFLEN        3\n#define NGX_RTMP_USER_RECORDED          4\n#define NGX_RTMP_USER_PING_REQUEST      6\n#define NGX_RTMP_USER_PING_RESPONSE     7\n#define NGX_RTMP_USER_UNKNOWN           8\n#define NGX_RTMP_USER_BUFFER_END        31\n\n\n/* Chunk header:\n *   max 3  basic header\n * + max 11 message header\n * + max 4  extended header (timestamp) */\n#define NGX_RTMP_MAX_CHUNK_HEADER       18\n\n\nenum {\n    NGX_RTMP_PROTOCOL_RTMP = 0,\n    NGX_RTMP_PROTOCOL_HTTP\n};\n\n\n#define NGX_RTMP_INTERNAL_SERVER_ERROR  500\n\n\ntypedef struct {\n    uint32_t                csid;       /* chunk stream id */\n    uint32_t                timestamp;  /* timestamp (delta) */\n    uint32_t                mlen;       /* message length */\n    uint8_t                 type;       /* message type id */\n    uint32_t                msid;       /* message stream id */\n} ngx_rtmp_header_t;\n\n\ntypedef struct {\n    ngx_rtmp_header_t       hdr;\n    uint32_t                dtime;\n    uint32_t                len;        /* current fragment length */\n    uint8_t                 ext;\n    ngx_chain_t            *in;\n} ngx_rtmp_stream_t;\n\n\n/* disable zero-sized array warning by msvc */\n\n#if (NGX_WIN32)\n#pragma warning(push)\n#pragma warning(disable:4200)\n#endif\n\n\nstruct ngx_rtmp_session_s {\n    uint32_t                       signature;  /* \"RTMP\" */ /* <-- FIXME wtf */\n\n    ngx_int_t                      port;\n    ngx_buf_t                     *request_line;\n    ngx_str_t                      uri;\n    ngx_str_t                      unparsed_uri;\n\n    time_t                         start_sec;\n    ngx_msec_t                     start_msec;\n\n    ngx_event_t                    close;\n\n    void                         **ctx;\n    void                         **main_conf;\n    void                         **srv_conf;\n    void                         **app_conf;\n\n    void                          *data;\n    ngx_event_t                    push_evt;\n\n    ngx_str_t                     *addr_text;\n    ngx_flag_t                     connected;\n\n#if (nginx_version >= 1007005)\n    ngx_queue_t                    posted_dry_events;\n#else\n    ngx_event_t                   *posted_dry_events;\n#endif\n\n    ngx_rtmp_variable_value_t     *variables;\n\n    /* client buffer time in msec */\n    uint32_t                       buflen;\n    uint32_t                       ack_size;\n\n    /* connection parameters */\n    ngx_str_t                      app;\n    ngx_str_t                      stream;\n    ngx_str_t                      args;\n    ngx_str_t                      flashver;\n    ngx_str_t                      swf_url;\n    ngx_str_t                      tc_url;\n    uint32_t                       acodecs;\n    uint32_t                       vcodecs;\n    ngx_str_t                      page_url;\n\n    /* handshake data */\n    ngx_buf_t                     *hs_buf;\n    u_char                        *hs_digest;\n    unsigned                       hs_old:1;\n    ngx_uint_t                     hs_stage;\n\n    /* connection timestamps */\n    ngx_msec_t                     epoch;\n    ngx_msec_t                     peer_epoch;\n    ngx_msec_t                     base_time;\n    uint32_t                       current_time;\n\n    /* ping */\n    ngx_event_t                    ping_evt;\n    unsigned                       ping_active:1;\n    unsigned                       ping_reset:1;\n\n    /* auto-pushed? */\n    unsigned                       auto_pushed:1;\n    unsigned                       relay:1;\n    unsigned                       static_relay:1;\n\n    /* URI with \"/.\" and on Win32 with \"//\" */\n    unsigned                       complex_uri:1;\n    /* URI with \"%\" */\n    unsigned                       quoted_uri:1;\n    /* URI with \"+\" */\n    unsigned                       plus_in_uri:1;\n    /* URI with \" \" */\n    unsigned                       space_in_uri:1;\n\n    unsigned                       offset_timestamp_set:1;\n\n    uint32_t                       offset_timestamp;\n\n    u_char                        *uri_start;\n    u_char                        *uri_end;\n    u_char                        *args_start;\n    u_char                        *schema_start;\n    u_char                        *schema_end;\n    u_char                        *host_start;\n    u_char                        *host_end;\n    u_char                        *port_start;\n    u_char                        *port_end;\n\n    unsigned                       keepalive:1;\n\n    unsigned                       valid_unparsed_uri:1;\n\n#if (NGX_PCRE)\n    ngx_uint_t                     ncaptures;\n    int                           *captures;\n    u_char                        *captures_data;\n#endif\n\n    ngx_rtmp_connection_t         *rtmp_connection;\n\n    ngx_rtmp_session_t            *publisher;\n\n    ngx_pool_t                    *in_streams_pool;\n    ngx_pool_t                    *in_streams_temp_pool;\n\n    ngx_pool_t                    *out_pool;\n    ngx_pool_t                    *out_temp_pool;\n\n    unsigned                       server_changed:1;\n    unsigned                       notify_connect:1;\n    unsigned                       notify_play:1;\n\n    /* input stream 0 (reserved by RTMP spec)\n     * is used as free chain link */\n\n    ngx_rtmp_stream_t             *in_streams;\n    uint32_t                       in_csid;\n    ngx_uint_t                     in_chunk_size;\n    ngx_pool_t                    *in_pool;\n    uint32_t                       in_bytes;\n    uint32_t                       in_last_ack;\n\n    ngx_pool_t                    *in_old_pool;\n    ngx_int_t                      in_chunk_size_changing;\n\n    ngx_connection_t              *connection;\n\n    /* circular buffer of RTMP message pointers */\n    ngx_msec_t                     timeout;\n    uint32_t                       out_bytes;\n    size_t                         out_pos, out_last;\n    ngx_chain_t                   *out_chain;\n    u_char                        *out_bpos;\n    unsigned                       out_buffer:1;\n    size_t                         out_queue;\n    size_t                         out_cork;\n    ngx_chain_t                  **out;\n};\n\n\n#if (NGX_WIN32)\n#pragma warning(pop)\n#endif\n\n\n/* handler result code:\n *  NGX_ERROR - error\n *  NGX_OK    - success, may continue\n *  NGX_DONE  - success, input parsed, reply sent; need no\n *      more calls on this event */\ntypedef ngx_int_t (*ngx_rtmp_handler_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\n\n\ntypedef struct {\n    ngx_str_t               name;\n    ngx_rtmp_handler_pt     handler;\n} ngx_rtmp_amf_handler_t;\n\n\ntypedef struct {\n    ngx_array_t              servers;    /* ngx_rtmp_core_srv_conf_t */\n\n    ngx_array_t              events[NGX_RTMP_MAX_EVENT];\n\n    ngx_hash_t               amf_hash;\n    ngx_array_t              amf_arrays;\n    ngx_array_t              amf;\n\n    ngx_hash_t               variables_hash;\n\n    ngx_array_t              variables;         /* ngx_http_variable_t */\n    ngx_array_t              prefix_variables;  /* ngx_http_variable_t */\n    ngx_uint_t               ncaptures;\n\n    ngx_uint_t               server_names_hash_max_size;\n    ngx_uint_t               server_names_hash_bucket_size;\n\n    ngx_uint_t               variables_hash_max_size;\n    ngx_uint_t               variables_hash_bucket_size;\n\n    ngx_hash_keys_arrays_t  *variables_keys;\n    ngx_array_t             *ports;  /* ngx_rtmp_conf_port_t */\n} ngx_rtmp_core_main_conf_t;\n\n\n/* global main conf for stats */\nextern ngx_rtmp_core_main_conf_t   *ngx_rtmp_core_main_conf;\n\n\nstruct ngx_rtmp_core_srv_conf_s {\n    /* array of the ngx_rtmp_server_name_t, \"server_name\" directive */\n    ngx_array_t             server_names;\n\n    ngx_array_t             applications; /* ngx_rtmp_core_app_conf_t */\n\n    ngx_uint_t              index; /* index in server array */\n\n    ngx_msec_t              timeout;\n    ngx_msec_t              ping;\n    ngx_msec_t              ping_timeout;\n    ngx_flag_t              so_keepalive;\n    ngx_int_t               max_streams;\n\n    ngx_uint_t              ack_window;\n\n    ngx_int_t               chunk_size;\n    ngx_pool_t             *pool;\n    ngx_chain_t            *free;\n    ngx_chain_t            *free_hs;\n    size_t                  max_message;\n    ngx_flag_t              play_time_fix;\n    ngx_flag_t              publish_time_fix;\n    ngx_flag_t              busy;\n    size_t                  out_queue;\n    size_t                  out_cork;\n    ngx_msec_t              buflen;\n\n    ngx_rtmp_conf_ctx_t    *ctx;\n\n    ngx_str_t               server_name;\n\n    size_t                  connection_pool_size;\n\n    ngx_flag_t              merge_slashes;\n\n    unsigned                listen:1;\n#if (NGX_PCRE)\n    unsigned                captures:1;\n#endif\n\n    in_port_t               port;\n};\n\n\nstruct ngx_rtmp_virtual_names_s {\n    ngx_hash_combined_t        names;\n\n    ngx_uint_t                 nregex;\n    ngx_rtmp_server_name_t    *regex;\n};\n\n\ntypedef struct {\n    ngx_array_t             applications; /* ngx_rtmp_core_app_conf_t */\n    ngx_str_t               name;\n    void                  **app_conf;\n\n#if (NGX_PCRE)\n    ngx_rtmp_regex_t       *regex;\n#endif\n\n    size_t                  send_lowat;\n\n    ngx_msec_t              send_timeout;\n    ngx_msec_t              resolver_timeout;\n\n    ngx_resolver_t         *resolver;\n\n    ngx_flag_t              tcp_nopush;\n    ngx_flag_t              tcp_nodelay;\n} ngx_rtmp_core_app_conf_t;\n\n\ntypedef struct {\n    ngx_str_t              *client;\n    ngx_rtmp_session_t     *session;\n} ngx_rtmp_error_log_ctx_t;\n\n\ntypedef struct {\n    ngx_int_t             (*preconfiguration)(ngx_conf_t *cf);\n    ngx_int_t             (*postconfiguration)(ngx_conf_t *cf);\n\n    void                 *(*create_main_conf)(ngx_conf_t *cf);\n    char                 *(*init_main_conf)(ngx_conf_t *cf, void *conf);\n\n    void                 *(*create_srv_conf)(ngx_conf_t *cf);\n    char                 *(*merge_srv_conf)(ngx_conf_t *cf, void *prev,\n                                    void *conf);\n\n    void                 *(*create_app_conf)(ngx_conf_t *cf);\n    char                 *(*merge_app_conf)(ngx_conf_t *cf, void *prev,\n                                    void *conf);\n} ngx_rtmp_module_t;\n\n#define NGX_RTMP_MODULE                 0x504D5452     /* \"RTMP\" */\n\n#define NGX_RTMP_MAIN_CONF              0x02000000\n#define NGX_RTMP_SRV_CONF               0x04000000\n#define NGX_RTMP_APP_CONF               0x08000000\n#define NGX_RTMP_REC_CONF               0x10000000\n#define NGX_RTMP_UPS_CONF               0x20000000\n\n#define NGX_RTMP_MAIN_CONF_OFFSET  offsetof(ngx_rtmp_conf_ctx_t, main_conf)\n#define NGX_RTMP_SRV_CONF_OFFSET   offsetof(ngx_rtmp_conf_ctx_t, srv_conf)\n#define NGX_RTMP_APP_CONF_OFFSET   offsetof(ngx_rtmp_conf_ctx_t, app_conf)\n\n\n#define ngx_rtmp_get_module_ctx(s, module)     (s)->ctx[module.ctx_index]\n#define ngx_rtmp_set_ctx(s, c, module)         s->ctx[module.ctx_index] = c;\n#define ngx_rtmp_delete_ctx(s, module)         s->ctx[module.ctx_index] = NULL;\n\n\n#define ngx_rtmp_get_module_main_conf(s, module)                             \\\n    (s)->main_conf[module.ctx_index]\n#define ngx_rtmp_get_module_srv_conf(s, module)  (s)->srv_conf[module.ctx_index]\n#define ngx_rtmp_get_module_app_conf(s, module)  ((s)->app_conf ? \\\n    (s)->app_conf[module.ctx_index] : NULL)\n\n#define ngx_rtmp_conf_get_module_main_conf(cf, module)                       \\\n    ((ngx_rtmp_conf_ctx_t *) cf->ctx)->main_conf[module.ctx_index]\n#define ngx_rtmp_conf_get_module_srv_conf(cf, module)                        \\\n    ((ngx_rtmp_conf_ctx_t *) cf->ctx)->srv_conf[module.ctx_index]\n#define ngx_rtmp_conf_get_module_app_conf(cf, module)                        \\\n    ((ngx_rtmp_conf_ctx_t *) cf->ctx)->app_conf[module.ctx_index]\n\n\n#ifdef NGX_DEBUG\nchar *ngx_rtmp_message_type(uint8_t type);\nchar *ngx_rtmp_user_message_type(uint16_t evt);\n#endif\n\nvoid ngx_rtmp_init_connection(ngx_connection_t *c);\nngx_rtmp_session_t *ngx_rtmp_init_session(ngx_connection_t *c,\n     ngx_rtmp_addr_conf_t *addr_conf);\nvoid ngx_rtmp_finalize_session(ngx_rtmp_session_t *s);\nvoid ngx_rtmp_handshake(ngx_rtmp_session_t *s);\nvoid ngx_rtmp_client_handshake(ngx_rtmp_session_t *s, unsigned async);\nvoid ngx_rtmp_free_handshake_buffers(ngx_rtmp_session_t *s);\nvoid ngx_rtmp_cycle(ngx_rtmp_session_t *s);\nvoid ngx_rtmp_reset_ping(ngx_rtmp_session_t *s);\n\nngx_chain_t *ngx_rtmp_alloc_in_buf(ngx_rtmp_session_t *s);\nngx_int_t ngx_rtmp_finalize_set_chunk_size(ngx_rtmp_session_t *s);\n\nngx_int_t ngx_rtmp_fire_event(ngx_rtmp_session_t *s, ngx_uint_t evt,\n     ngx_rtmp_header_t *h, ngx_chain_t *in);\n\n\nngx_int_t ngx_rtmp_set_chunk_size(ngx_rtmp_session_t *s, ngx_uint_t size);\n\n\n/* Bit reverse: we need big-endians in many places  */\nvoid *ngx_rtmp_rmemcpy(void *dst, const void *src, size_t n);\nu_char *ngx_rtmp_h4_to_n3(u_char *dst, uint32_t h);\nuint32_t ngx_rtmp_n3_to_h4(u_char *n);\n\n\nstatic ngx_inline uint16_t\nngx_rtmp_r16(uint16_t n)\n{\n#if (NGX_HAVE_LITTLE_ENDIAN)\n    return (n << 8) | (n >> 8);\n#else\n    return n;\n#endif\n}\n\n\nstatic ngx_inline uint32_t\nngx_rtmp_r32(uint32_t n)\n{\n#if (NGX_HAVE_LITTLE_ENDIAN)\n    return (n << 24) | ((n << 8) & 0xff0000) | ((n >> 8) & 0xff00) | (n >> 24);\n#else\n    return n;\n#endif\n}\n\n\nstatic ngx_inline uint64_t\nngx_rtmp_r64(uint64_t n)\n{\n#if (NGX_HAVE_LITTLE_ENDIAN)\n    return (uint64_t) ngx_rtmp_r32((uint32_t) n) << 32 |\n                      ngx_rtmp_r32((uint32_t) (n >> 32));\n#else\n    return n;\n#endif\n}\n\n\n/* Receiving messages */\nngx_int_t ngx_rtmp_receive_message(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\nngx_int_t ngx_rtmp_protocol_message_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\nngx_int_t ngx_rtmp_user_message_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\nngx_int_t ngx_rtmp_aggregate_message_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\nngx_int_t ngx_rtmp_amf_message_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\nngx_int_t ngx_rtmp_amf_shared_object_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in);\n\n\n/* Shared output buffers */\n\n/* Store refcount in negative bytes of shared buffer */\n\n#define NGX_RTMP_REFCOUNT_TYPE              uint32_t\n#define NGX_RTMP_REFCOUNT_BYTES             sizeof(NGX_RTMP_REFCOUNT_TYPE)\n\n#define ngx_rtmp_ref(b)                     \\\n    *((NGX_RTMP_REFCOUNT_TYPE*)(b) - 1)\n\n#define ngx_rtmp_ref_set(b, v)              \\\n    ngx_rtmp_ref(b) = v\n\n#define ngx_rtmp_ref_get(b)                 \\\n    ++ngx_rtmp_ref(b)\n\n#define ngx_rtmp_ref_put(b)                 \\\n    --ngx_rtmp_ref(b)\n\nngx_chain_t *ngx_rtmp_alloc_shared_buf(ngx_rtmp_core_srv_conf_t *cscf);\nvoid ngx_rtmp_free_shared_chain(ngx_rtmp_core_srv_conf_t *cscf,\n        ngx_chain_t *in);\nngx_chain_t *ngx_rtmp_append_shared_bufs(ngx_rtmp_core_srv_conf_t *cscf,\n        ngx_chain_t *head, ngx_chain_t *in);\n\n#define ngx_rtmp_acquire_shared_chain(in)   \\\n    ngx_rtmp_ref_get(in);                   \\\n\n\n/* Sending messages */\nvoid ngx_rtmp_prepare_message(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_rtmp_header_t *lh, ngx_chain_t *out);\nngx_int_t ngx_rtmp_send_message(ngx_rtmp_session_t *s, ngx_chain_t *out,\n        ngx_uint_t priority);\n\n/* Note on priorities:\n * the bigger value the lower the priority.\n * priority=0 is the highest */\n\n\n#define NGX_RTMP_LIMIT_SOFT         0\n#define NGX_RTMP_LIMIT_HARD         1\n#define NGX_RTMP_LIMIT_DYNAMIC      2\n\n/* Protocol control messages */\nngx_chain_t *ngx_rtmp_create_chunk_size(ngx_rtmp_session_t *s,\n        uint32_t chunk_size);\nngx_chain_t *ngx_rtmp_create_abort(ngx_rtmp_session_t *s,\n        uint32_t csid);\nngx_chain_t *ngx_rtmp_create_ack(ngx_rtmp_session_t *s,\n        uint32_t seq);\nngx_chain_t *ngx_rtmp_create_ack_size(ngx_rtmp_session_t *s,\n        uint32_t ack_size);\nngx_chain_t *ngx_rtmp_create_bandwidth(ngx_rtmp_session_t *s,\n        uint32_t ack_size, uint8_t limit_type);\n\nngx_int_t ngx_rtmp_send_chunk_size(ngx_rtmp_session_t *s,\n        uint32_t chunk_size);\nngx_int_t ngx_rtmp_send_abort(ngx_rtmp_session_t *s,\n        uint32_t csid);\nngx_int_t ngx_rtmp_send_ack(ngx_rtmp_session_t *s,\n        uint32_t seq);\nngx_int_t ngx_rtmp_send_ack_size(ngx_rtmp_session_t *s,\n        uint32_t ack_size);\nngx_int_t ngx_rtmp_send_bandwidth(ngx_rtmp_session_t *s,\n        uint32_t ack_size, uint8_t limit_type);\n\n/* User control messages */\nngx_chain_t *ngx_rtmp_create_stream_begin(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_chain_t *ngx_rtmp_create_stream_eof(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_chain_t *ngx_rtmp_create_stream_dry(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_chain_t *ngx_rtmp_create_set_buflen(ngx_rtmp_session_t *s,\n        uint32_t msid, uint32_t buflen_msec);\nngx_chain_t *ngx_rtmp_create_recorded(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_chain_t *ngx_rtmp_create_ping_request(ngx_rtmp_session_t *s,\n        uint32_t timestamp);\nngx_chain_t *ngx_rtmp_create_ping_response(ngx_rtmp_session_t *s,\n        uint32_t timestamp);\n\nngx_int_t ngx_rtmp_send_stream_begin(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_int_t ngx_rtmp_send_stream_eof(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_int_t ngx_rtmp_send_stream_dry(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_int_t ngx_rtmp_send_set_buflen(ngx_rtmp_session_t *s,\n        uint32_t msid, uint32_t buflen_msec);\nngx_int_t ngx_rtmp_send_recorded(ngx_rtmp_session_t *s,\n        uint32_t msid);\nngx_int_t ngx_rtmp_send_ping_request(ngx_rtmp_session_t *s,\n        uint32_t timestamp);\nngx_int_t ngx_rtmp_send_ping_response(ngx_rtmp_session_t *s,\n        uint32_t timestamp);\n\n/* AMF sender/receiver */\nngx_int_t ngx_rtmp_append_amf(ngx_rtmp_session_t *s,\n        ngx_chain_t **first, ngx_chain_t **last,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts);\nngx_int_t ngx_rtmp_receive_amf(ngx_rtmp_session_t *s, ngx_chain_t *in,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts);\n\nngx_chain_t *ngx_rtmp_create_amf(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts);\nngx_int_t ngx_rtmp_send_amf(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts);\n\n/* AMF status sender */\nngx_chain_t *ngx_rtmp_create_status(ngx_rtmp_session_t *s, char *code,\n        char *level, char *desc);\nngx_chain_t *ngx_rtmp_create_play_status(ngx_rtmp_session_t *s, char *code,\n        char *level, ngx_uint_t duration, ngx_uint_t bytes);\nngx_chain_t *ngx_rtmp_create_sample_access(ngx_rtmp_session_t *s);\n\nngx_int_t ngx_rtmp_send_status(ngx_rtmp_session_t *s, char *code,\n        char *level, char *desc);\nngx_int_t ngx_rtmp_send_play_status(ngx_rtmp_session_t *s, char *code,\n        char *level, ngx_uint_t duration, ngx_uint_t bytes);\nngx_int_t ngx_rtmp_send_sample_access(ngx_rtmp_session_t *s);\n\n\n/* Frame types */\n#define NGX_RTMP_VIDEO_KEY_FRAME            1\n#define NGX_RTMP_VIDEO_INTER_FRAME          2\n#define NGX_RTMP_VIDEO_DISPOSABLE_FRAME     3\n\n\nstatic ngx_inline ngx_int_t\nngx_rtmp_get_video_frame_type(ngx_chain_t *in)\n{\n    return (in->buf->pos[0] & 0xf0) >> 4;\n}\n\n\nstatic ngx_inline ngx_int_t\nngx_rtmp_is_codec_header(ngx_chain_t *in)\n{\n    return in->buf->pos + 1 < in->buf->last && in->buf->pos[1] == 0;\n}\n\n\nextern ngx_rtmp_bandwidth_t                 ngx_rtmp_bw_out;\nextern ngx_rtmp_bandwidth_t                 ngx_rtmp_bw_in;\n\n\nextern ngx_uint_t                           ngx_rtmp_naccepted;\n#if (nginx_version >= 1007011)\nextern ngx_queue_t                          ngx_rtmp_init_queue;\n#elif (nginx_version >= 1007005)\nextern ngx_thread_volatile ngx_queue_t      ngx_rtmp_init_queue;\n#else\nextern ngx_thread_volatile ngx_event_t     *ngx_rtmp_init_queue;\n#endif\n\nextern ngx_uint_t                           ngx_rtmp_max_module;\nextern ngx_module_t                         ngx_rtmp_core_module;\n\n\nu_char *ngx_rtmp_log_error(ngx_log_t *log, u_char *buf, size_t len);\n\n\nngx_int_t ngx_rtmp_parse_request_line(ngx_rtmp_session_t *s, ngx_buf_t *b);\nngx_int_t ngx_rtmp_process_request_uri(ngx_rtmp_session_t *s);\nngx_int_t ngx_rtmp_parse_complex_uri(ngx_rtmp_session_t *s,\n    ngx_uint_t merge_slashes);\n\nngx_int_t ngx_rtmp_process_virtual_host(ngx_rtmp_session_t *s);\nngx_int_t ngx_rtmp_validate_host(ngx_str_t *host, ngx_pool_t *pool,\n    ngx_uint_t alloc);\nngx_int_t ngx_rtmp_set_virtual_server(ngx_rtmp_session_t *s, ngx_str_t *host);\nngx_int_t ngx_rtmp_process_request_line(ngx_rtmp_session_t *s,\n    const u_char *name, const u_char *args, const u_char *cmd);\n#if (nginx_version <= 1011001)\nin_port_t ngx_inet_get_port(struct sockaddr *sa);\nvoid ngx_inet_set_port(struct sockaddr *sa, in_port_t port);\n#endif\n\nngx_int_t ngx_rtmp_send_fcpublish(ngx_rtmp_session_t *s, u_char *desc);\nngx_int_t ngx_rtmp_send_fcunpublish(ngx_rtmp_session_t *s, u_char *desc);\n\n#endif /* _NGX_RTMP_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_access_module.c",
          "type": "blob",
          "size": 11.48828125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n\n\nstatic ngx_rtmp_publish_pt          next_publish;\nstatic ngx_rtmp_play_pt             next_play;\n\n\n#define NGX_RTMP_ACCESS_PUBLISH     0x01\n#define NGX_RTMP_ACCESS_PLAY        0x02\n\n\nstatic char * ngx_rtmp_access_rule(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic ngx_int_t ngx_rtmp_access_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_access_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_access_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\n\n\ntypedef struct {\n    in_addr_t               mask;\n    in_addr_t               addr;\n    ngx_uint_t              deny;\n    ngx_uint_t              flags;\n} ngx_rtmp_access_rule_t;\n\n\n#if (NGX_HAVE_INET6)\n\ntypedef struct {\n    struct in6_addr         addr;\n    struct in6_addr         mask;\n    ngx_uint_t              deny;\n    ngx_uint_t              flags;\n} ngx_rtmp_access_rule6_t;\n\n#endif\n\n\ntypedef struct {\n    ngx_array_t             rules;     /* array of ngx_rtmp_access_rule_t */\n#if (NGX_HAVE_INET6)\n    ngx_array_t             rules6;    /* array of ngx_rtmp_access_rule6_t */\n#endif\n} ngx_rtmp_access_app_conf_t;\n\n\nstatic ngx_command_t  ngx_rtmp_access_commands[] = {\n\n    { ngx_string(\"allow\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE12,\n      ngx_rtmp_access_rule,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"deny\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE12,\n      ngx_rtmp_access_rule,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_access_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_access_postconfiguration,      /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_access_create_app_conf,        /* create app configuration */\n    ngx_rtmp_access_merge_app_conf,         /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_access_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_access_module_ctx,            /* module context */\n    ngx_rtmp_access_commands,               /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void *\nngx_rtmp_access_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_access_app_conf_t      *aacf;\n\n    aacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_access_app_conf_t));\n    if (aacf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&aacf->rules, cf->pool, 1,\n                       sizeof(ngx_rtmp_access_rule_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n#if (NGX_HAVE_INET6)\n    if (ngx_array_init(&aacf->rules6, cf->pool, 1,\n                       sizeof(ngx_rtmp_access_rule6_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n#endif\n\n    return aacf;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_access_merge_rules(ngx_array_t *prev, ngx_array_t *rules)\n{\n    void   *p;\n\n    if (prev->nelts == 0) {\n        return NGX_OK;\n    }\n\n    if (rules->nelts == 0) {\n        *rules = *prev;\n        return NGX_OK;\n    }\n\n    p = ngx_array_push_n(rules, prev->nelts);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(p, prev->elts, prev->size * prev->nelts);\n\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_rtmp_access_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_access_app_conf_t *prev = parent;\n    ngx_rtmp_access_app_conf_t *conf = child;\n\n    if (ngx_rtmp_access_merge_rules(&prev->rules, &conf->rules) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n#if (NGX_HAVE_INET6)\n    if (ngx_rtmp_access_merge_rules(&prev->rules6, &conf->rules6) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_access_found(ngx_rtmp_session_t *s, ngx_uint_t deny)\n{\n    if (deny) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"access forbidden by rule\");\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_access_inet(ngx_rtmp_session_t *s, in_addr_t addr, ngx_uint_t flag)\n{\n    ngx_uint_t                  i;\n    ngx_rtmp_access_rule_t     *rule;\n    ngx_rtmp_access_app_conf_t *ascf;\n\n    ascf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_access_module);\n\n    rule = ascf->rules.elts;\n    for (i = 0; i < ascf->rules.nelts; i++) {\n\n        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                       \"access: %08XD %08XD %08XD\",\n                       addr, rule[i].mask, rule[i].addr);\n\n        if ((addr & rule[i].mask) == rule[i].addr && (flag & rule[i].flags)) {\n            return ngx_rtmp_access_found(s, rule[i].deny);\n        }\n    }\n\n    return NGX_OK;\n}\n\n\n#if (NGX_HAVE_INET6)\n\nstatic ngx_int_t\nngx_rtmp_access_inet6(ngx_rtmp_session_t *s, u_char *p, ngx_uint_t flag)\n{\n    ngx_uint_t                  n;\n    ngx_uint_t                  i;\n    ngx_rtmp_access_rule6_t    *rule6;\n    ngx_rtmp_access_app_conf_t *ascf;\n\n    ascf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_access_module);\n\n    rule6 = ascf->rules6.elts;\n    for (i = 0; i < ascf->rules6.nelts; i++) {\n\n#if (NGX_DEBUG)\n        {\n        size_t  cl, ml, al;\n        u_char  ct[NGX_INET6_ADDRSTRLEN];\n        u_char  mt[NGX_INET6_ADDRSTRLEN];\n        u_char  at[NGX_INET6_ADDRSTRLEN];\n\n        cl = ngx_inet6_ntop(p, ct, NGX_INET6_ADDRSTRLEN);\n        ml = ngx_inet6_ntop(rule6[i].mask.s6_addr, mt, NGX_INET6_ADDRSTRLEN);\n        al = ngx_inet6_ntop(rule6[i].addr.s6_addr, at, NGX_INET6_ADDRSTRLEN);\n\n        ngx_log_debug6(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                       \"access: %*s %*s %*s\", cl, ct, ml, mt, al, at);\n        }\n#endif\n\n        for (n = 0; n < 16; n++) {\n            if ((p[n] & rule6[i].mask.s6_addr[n]) != rule6[i].addr.s6_addr[n]) {\n                goto next;\n            }\n        }\n\n        if (flag & rule6[i].flags) {\n            return ngx_rtmp_access_found(s, rule6[i].deny);\n        }\n\n    next:\n        continue;\n    }\n\n    return NGX_OK;\n}\n\n#endif\n\n\nstatic ngx_int_t\nngx_rtmp_access(ngx_rtmp_session_t *s, ngx_uint_t flag)\n{\n    struct sockaddr_in             *sin;\n    ngx_rtmp_access_app_conf_t     *ascf;\n#if (NGX_HAVE_INET6)\n    u_char                         *p;\n    in_addr_t                       addr;\n    struct sockaddr_in6            *sin6;\n#endif\n\n    ascf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_access_module);\n    if (ascf == NULL) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, s->connection->log, 0,\n                       \"access: NULL app conf\");\n        return NGX_ERROR;\n    }\n\n    /* relay etc */\n    if (s->connection->sockaddr == NULL) {\n        return NGX_OK;\n    }\n\n    switch (s->connection->sockaddr->sa_family) {\n\n    case AF_INET:\n        sin = (struct sockaddr_in *) s->connection->sockaddr;\n        return ngx_rtmp_access_inet(s, sin->sin_addr.s_addr, flag);\n\n#if (NGX_HAVE_INET6)\n\n    case AF_INET6:\n        sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;\n        p = sin6->sin6_addr.s6_addr;\n\n        if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {\n            addr  = p[12] << 24;\n            addr += p[13] << 16;\n            addr += p[14] << 8;\n            addr += p[15];\n            return ngx_rtmp_access_inet(s, htonl(addr), flag);\n        }\n\n        return ngx_rtmp_access_inet6(s, p, flag);\n\n#endif\n    }\n\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_rtmp_access_rule(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_access_app_conf_t         *ascf = conf;\n\n    ngx_int_t                           rc;\n    ngx_uint_t                          all;\n    ngx_str_t                          *value;\n    ngx_cidr_t                          cidr;\n    ngx_rtmp_access_rule_t             *rule;\n#if (NGX_HAVE_INET6)\n    ngx_rtmp_access_rule6_t            *rule6;\n#endif\n    size_t                              n;\n    ngx_uint_t                          flags;\n\n    ngx_memzero(&cidr, sizeof(ngx_cidr_t));\n\n    value = cf->args->elts;\n\n    n = 1;\n    flags = 0;\n\n    if (cf->args->nelts == 2) {\n\n        flags = NGX_RTMP_ACCESS_PUBLISH | NGX_RTMP_ACCESS_PLAY;\n\n    } else {\n\n        for(; n < cf->args->nelts - 1; ++n) {\n\n            if (value[n].len == sizeof(\"publish\") - 1 &&\n                ngx_strcmp(value[1].data, \"publish\") == 0)\n            {\n                flags |= NGX_RTMP_ACCESS_PUBLISH;\n                continue;\n\n            }\n\n            if (value[n].len == sizeof(\"play\") - 1 &&\n                ngx_strcmp(value[1].data, \"play\") == 0)\n            {\n                flags |= NGX_RTMP_ACCESS_PLAY;\n                continue;\n\n            }\n\n            ngx_log_error(NGX_LOG_ERR, cf->log, 0,\n                          \"unexpected access specified: '%V'\", &value[n]);\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    all = (value[n].len == 3 && ngx_strcmp(value[n].data, \"all\") == 0);\n\n    if (!all) {\n\n        rc = ngx_ptocidr(&value[n], &cidr);\n\n        if (rc == NGX_ERROR) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid parameter \\\"%V\\\"\", &value[1]);\n            return NGX_CONF_ERROR;\n        }\n\n        if (rc == NGX_DONE) {\n            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                               \"low address bits of %V are meaningless\",\n                               &value[1]);\n        }\n    }\n\n    switch (cidr.family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n    case 0: /* all */\n\n        rule6 = ngx_array_push(&ascf->rules6);\n        if (rule6 == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        rule6->mask = cidr.u.in6.mask;\n        rule6->addr = cidr.u.in6.addr;\n        rule6->deny = (value[0].data[0] == 'd') ? 1 : 0;\n        rule6->flags = flags;\n\n        if (!all) {\n            break;\n        }\n\n        /* \"all\" passes through */\n#endif\n        /* fall through */\n\n    default: /* AF_INET */\n\n        rule = ngx_array_push(&ascf->rules);\n        if (rule == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        rule->mask = cidr.u.in.mask;\n        rule->addr = cidr.u.in.addr;\n        rule->deny = (value[0].data[0] == 'd') ? 1 : 0;\n        rule->flags = flags;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_access_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    if (ngx_rtmp_access(s, NGX_RTMP_ACCESS_PUBLISH) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_access_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    if (ngx_rtmp_access(s, NGX_RTMP_ACCESS_PLAY) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_access_postconfiguration(ngx_conf_t *cf)\n{\n    /* chain handlers */\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_access_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_access_play;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_amf.c",
          "type": "blob",
          "size": 16.15625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_amf.h\"\n#include \"ngx_rtmp.h\"\n#include <string.h>\n\n\nstatic ngx_inline void*\nngx_rtmp_amf_reverse_copy(void *dst, void* src, size_t len)\n{\n    if (dst == NULL || src == NULL) {\n        return NULL;\n    }\n\n#if (NGX_HAVE_LITTLE_ENDIAN)\n    ngx_rtmp_rmemcpy(dst, src, len);\n#else\n    ngx_memcpy(dst, src, len);\n#endif\n\n    return dst;\n}\n\n#define NGX_RTMP_AMF_DEBUG_SIZE 16\n\n#ifdef NGX_DEBUG\nstatic void\nngx_rtmp_amf_debug(const char* op, ngx_log_t *log, u_char *p, size_t n)\n{\n    u_char          hstr[3 * NGX_RTMP_AMF_DEBUG_SIZE + 1];\n    u_char          str[NGX_RTMP_AMF_DEBUG_SIZE + 1];\n    u_char         *hp, *sp;\n    static u_char   hex[] = \"0123456789ABCDEF\";\n    size_t          i;\n\n    hp = hstr;\n    sp = str;\n\n    for(i = 0; i < n && i < NGX_RTMP_AMF_DEBUG_SIZE; ++i) {\n        *hp++ = ' ';\n        if (p) {\n            *hp++ = hex[(*p & 0xf0) >> 4];\n            *hp++ = hex[*p & 0x0f];\n            *sp++ = (*p >= 0x20 && *p <= 0x7e) ?\n                *p : (u_char)'?';\n            ++p;\n        } else {\n            *hp++ = 'X';\n            *hp++ = 'X';\n            *sp++ = '?';\n        }\n    }\n    *hp = *sp = '\\0';\n\n    ngx_log_debug4(NGX_LOG_DEBUG_RTMP, log, 0,\n            \"AMF %s (%d)%s '%s'\", op, n, hstr, str);\n}\n#endif\n\nstatic ngx_int_t\nngx_rtmp_amf_get(ngx_rtmp_amf_ctx_t *ctx, void *p, size_t n)\n{\n    size_t          size;\n    ngx_chain_t    *l;\n    size_t          offset;\n    u_char         *pos, *last;\n#ifdef NGX_DEBUG\n    void           *op = p;\n    size_t          on = n;\n#endif\n\n    if (!n)\n        return NGX_OK;\n\n    for(l = ctx->link, offset = ctx->offset; l; l = l->next, offset = 0) {\n\n        pos  = l->buf->pos + offset;\n        last = l->buf->last;\n\n        if (last >= pos + n) {\n            if (p) {\n                p = ngx_cpymem(p, pos, n);\n            }\n            ctx->offset = offset + n;\n            ctx->link = l;\n\n#ifdef NGX_DEBUG\n            ngx_rtmp_amf_debug(\"read\", ctx->log, (u_char*)op, on);\n#endif\n\n            return NGX_OK;\n        }\n\n        size = last - pos;\n\n        if (p) {\n            p = ngx_cpymem(p, pos, size);\n        }\n\n        n -= size;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, ctx->log, 0,\n            \"AMF read eof (%d)\", n);\n\n    return NGX_DONE;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_put(ngx_rtmp_amf_ctx_t *ctx, void *p, size_t n)\n{\n    ngx_buf_t       *b;\n    size_t          size;\n    ngx_chain_t    *l, *ln;\n\n#ifdef NGX_DEBUG\n    ngx_rtmp_amf_debug(\"write\", ctx->log, (u_char*)p, n);\n#endif\n\n    l = ctx->link;\n\n    if (ctx->link && ctx->first == NULL) {\n        ctx->first = ctx->link;\n    }\n\n    while(n) {\n        b = l ? l->buf : NULL;\n\n        if (b == NULL || b->last == b->end) {\n\n            ln = ctx->alloc(ctx->arg);\n            if (ln == NULL) {\n                return NGX_ERROR;\n            }\n\n            if (ctx->first == NULL) {\n                ctx->first = ln;\n            }\n\n            if (l) {\n                l->next = ln;\n            }\n\n            l = ln;\n            ctx->link = l;\n            b = l->buf;\n        }\n\n        size = b->end - b->last;\n\n        if (size >= n) {\n            b->last = ngx_cpymem(b->last, p, n);\n            return NGX_OK;\n        }\n\n        b->last = ngx_cpymem(b->last, p, size);\n        p = (u_char*)p + size;\n        n -= size;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_read_object(ngx_rtmp_amf_ctx_t *ctx, ngx_rtmp_amf_elt_t *elts,\n        size_t nelts)\n{\n    uint8_t                 type;\n    uint16_t                len;\n    size_t                  n, namelen, maxlen;\n    ngx_int_t               rc;\n    u_char                  buf[2];\n\n    maxlen = 0;\n    for(n = 0; n < nelts; ++n) {\n        namelen = elts[n].name.len;\n        if (namelen > maxlen)\n            maxlen = namelen;\n    }\n\n    for( ;; ) {\n\n#if !(NGX_WIN32)\n        char    name[maxlen];\n#else\n        char    name[1024];\n        if (maxlen > sizeof(name)) {\n            return NGX_ERROR;\n        }\n#endif\n        /* read key */\n        switch (ngx_rtmp_amf_get(ctx, buf, 2)) {\n        case NGX_DONE:\n            /* Envivio sends unfinalized arrays */\n            return NGX_OK;\n        case NGX_OK:\n            break;\n        default:\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_amf_reverse_copy(&len, buf, 2);\n\n        if (!len)\n            break;\n\n        if (len <= maxlen) {\n            rc = ngx_rtmp_amf_get(ctx, name, len);\n\n        } else {\n            rc = ngx_rtmp_amf_get(ctx, name, maxlen);\n            if (rc != NGX_OK)\n                return NGX_ERROR;\n            rc = ngx_rtmp_amf_get(ctx, 0, len - maxlen);\n        }\n\n        if (rc != NGX_OK)\n            return NGX_ERROR;\n\n        /* TODO: if we require array to be sorted on name\n         * then we could be able to use binary search */\n        for(n = 0; n < nelts\n                && (len != elts[n].name.len\n                    || ngx_strncmp(name, elts[n].name.data, len));\n                ++n);\n\n        if (ngx_rtmp_amf_read(ctx, n < nelts ? &elts[n] : NULL, 1) != NGX_OK)\n            return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_amf_get(ctx, &type, 1) != NGX_OK\n        || type != NGX_RTMP_AMF_END)\n    {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_read_array(ngx_rtmp_amf_ctx_t *ctx, ngx_rtmp_amf_elt_t *elts,\n        size_t nelts)\n{\n    uint32_t                len;\n    size_t                  n;\n    u_char                  buf[4];\n\n    /* read length */\n    if (ngx_rtmp_amf_get(ctx, buf, 4) != NGX_OK)\n        return NGX_ERROR;\n\n    ngx_rtmp_amf_reverse_copy(&len, buf, 4);\n\n    for (n = 0; n < len; ++n) {\n        if (ngx_rtmp_amf_read(ctx, n < nelts ? &elts[n] : NULL, 1) != NGX_OK)\n            return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_read_variant(ngx_rtmp_amf_ctx_t *ctx, ngx_rtmp_amf_elt_t *elts,\n        size_t nelts)\n{\n    uint8_t                 type;\n    ngx_int_t               rc;\n    size_t                  n;\n    ngx_rtmp_amf_elt_t      elt;\n\n    rc = ngx_rtmp_amf_get(ctx, &type, 1);\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    ngx_memzero(&elt, sizeof(elt));\n    for (n = 0; n < nelts; ++n, ++elts) {\n        if (type == elts->type) {\n            elt.data = elts->data;\n            elt.len  = elts->len;\n        }\n    }\n\n    elt.type = type | NGX_RTMP_AMF_TYPELESS;\n\n    return ngx_rtmp_amf_read(ctx, &elt, 1);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_is_compatible_type(uint8_t t1, uint8_t t2)\n{\n    return t1 == t2\n        || (t1 == NGX_RTMP_AMF_OBJECT && t2 == NGX_RTMP_AMF_MIXED_ARRAY)\n        || (t2 == NGX_RTMP_AMF_OBJECT && t1 == NGX_RTMP_AMF_MIXED_ARRAY);\n}\n\n\nngx_int_t\nngx_rtmp_amf_read(ngx_rtmp_amf_ctx_t *ctx, ngx_rtmp_amf_elt_t *elts,\n        size_t nelts)\n{\n    void                       *data;\n    ngx_int_t                   type;\n    uint8_t                     type8;\n    size_t                      n;\n    uint16_t                    len;\n    ngx_int_t                   rc;\n    u_char                      buf[8];\n    uint32_t                    max_index;\n\n    for(n = 0; n < nelts; ++n) {\n\n        if (elts && elts->type & NGX_RTMP_AMF_TYPELESS) {\n            type = elts->type & ~NGX_RTMP_AMF_TYPELESS;\n            data = elts->data;\n\n        } else {\n            switch (ngx_rtmp_amf_get(ctx, &type8, 1)) {\n                case NGX_DONE:\n                    if (elts && elts->type & NGX_RTMP_AMF_OPTIONAL) {\n                        return NGX_OK;\n                    }\n\n                    /* fall through */\n\n                case NGX_ERROR:\n                    return NGX_ERROR;\n            }\n            type = type8;\n            data = (elts &&\n                    ngx_rtmp_amf_is_compatible_type(\n                                 (uint8_t) (elts->type & 0xff), (uint8_t) type))\n                ? elts->data\n                : NULL;\n\n            if (elts && (elts->type & NGX_RTMP_AMF_CONTEXT)) {\n                if (data) {\n                    *(ngx_rtmp_amf_ctx_t *) data = *ctx;\n                }\n                data = NULL;\n            }\n        }\n\n        switch (type) {\n            case NGX_RTMP_AMF_NUMBER:\n                if (ngx_rtmp_amf_get(ctx, buf, 8) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                ngx_rtmp_amf_reverse_copy(data, buf, 8);\n                break;\n\n            case NGX_RTMP_AMF_BOOLEAN:\n                if (ngx_rtmp_amf_get(ctx, data, 1) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_STRING:\n                if (ngx_rtmp_amf_get(ctx, buf, 2) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                ngx_rtmp_amf_reverse_copy(&len, buf, 2);\n\n                if (data == NULL) {\n                    rc = ngx_rtmp_amf_get(ctx, data, len);\n\n                } else if (elts && elts->len <= len) {\n                    rc = ngx_rtmp_amf_get(ctx, data, elts->len - 1);\n                    if (rc != NGX_OK)\n                        return NGX_ERROR;\n                    ((char*)data)[elts->len - 1] = 0;\n                    rc = ngx_rtmp_amf_get(ctx, NULL, len - elts->len + 1);\n\n                } else {\n                    rc = ngx_rtmp_amf_get(ctx, data, len);\n                    ((char*)data)[len] = 0;\n                }\n\n                if (rc != NGX_OK) {\n                    return NGX_ERROR;\n                }\n\n                break;\n\n            case NGX_RTMP_AMF_NULL:\n            case NGX_RTMP_AMF_ARRAY_NULL:\n                break;\n\n            case NGX_RTMP_AMF_MIXED_ARRAY:\n                if (ngx_rtmp_amf_get(ctx, &max_index, 4) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n\n                /* fall through */\n\n            case NGX_RTMP_AMF_OBJECT:\n                if (ngx_rtmp_amf_read_object(ctx, data,\n                    data && elts ? elts->len / sizeof(ngx_rtmp_amf_elt_t) : 0\n                    ) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_ARRAY:\n                if (ngx_rtmp_amf_read_array(ctx, data,\n                    data && elts ? elts->len / sizeof(ngx_rtmp_amf_elt_t) : 0\n                    ) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_VARIANT_:\n                if (ngx_rtmp_amf_read_variant(ctx, data,\n                    data && elts ? elts->len / sizeof(ngx_rtmp_amf_elt_t) : 0\n                    ) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_INT8:\n                if (ngx_rtmp_amf_get(ctx, data, 1) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_INT16:\n                if (ngx_rtmp_amf_get(ctx, buf, 2) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                ngx_rtmp_amf_reverse_copy(data, buf, 2);\n                break;\n\n            case NGX_RTMP_AMF_INT32:\n                if (ngx_rtmp_amf_get(ctx, buf, 4) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                ngx_rtmp_amf_reverse_copy(data, buf, 4);\n                break;\n\n            case NGX_RTMP_AMF_END:\n                return NGX_OK;\n\n            default:\n                return NGX_ERROR;\n        }\n\n        if (elts) {\n            ++elts;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_write_object(ngx_rtmp_amf_ctx_t *ctx,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    uint16_t                len;\n    size_t                  n;\n    u_char                  buf[2];\n\n    for(n = 0; n < nelts; ++n) {\n\n        len = (uint16_t) elts[n].name.len;\n\n        if (ngx_rtmp_amf_put(ctx,\n                    ngx_rtmp_amf_reverse_copy(buf,\n                        &len, 2), 2) != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        if (ngx_rtmp_amf_put(ctx, elts[n].name.data, len) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_rtmp_amf_write(ctx, &elts[n], 1) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    if (ngx_rtmp_amf_put(ctx, \"\\0\\0\", 2) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_amf_write_array(ngx_rtmp_amf_ctx_t *ctx,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    uint32_t                len;\n    size_t                  n;\n    u_char                  buf[4];\n\n    len = nelts;\n    if (ngx_rtmp_amf_put(ctx,\n                ngx_rtmp_amf_reverse_copy(buf,\n                    &len, 4), 4) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    for(n = 0; n < nelts; ++n) {\n        if (ngx_rtmp_amf_write(ctx, &elts[n], 1) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_amf_write(ngx_rtmp_amf_ctx_t *ctx,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    size_t                  n;\n    ngx_int_t               type;\n    uint8_t                 type8;\n    void                   *data;\n    uint16_t                len;\n    uint32_t                max_index;\n    u_char                  buf[8];\n\n    for(n = 0; n < nelts; ++n) {\n\n        type = elts[n].type;\n        data = elts[n].data;\n        len  = (uint16_t) elts[n].len;\n\n        if (type & NGX_RTMP_AMF_TYPELESS) {\n            type &= ~NGX_RTMP_AMF_TYPELESS;\n        } else {\n            type8 = (uint8_t)type;\n            if (ngx_rtmp_amf_put(ctx, &type8, 1) != NGX_OK)\n                return NGX_ERROR;\n        }\n\n        switch(type) {\n            case NGX_RTMP_AMF_NUMBER:\n                if (ngx_rtmp_amf_put(ctx,\n                            ngx_rtmp_amf_reverse_copy(buf,\n                                data, 8), 8) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_BOOLEAN:\n                if (ngx_rtmp_amf_put(ctx, data, 1) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_STRING:\n                if (len == 0 && data) {\n                    len = (uint16_t) ngx_strlen((u_char*) data);\n                }\n\n                if (ngx_rtmp_amf_put(ctx,\n                            ngx_rtmp_amf_reverse_copy(buf,\n                                &len, 2), 2) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n\n                if (ngx_rtmp_amf_put(ctx, data, len) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_NULL:\n            case NGX_RTMP_AMF_ARRAY_NULL:\n                break;\n\n            case NGX_RTMP_AMF_MIXED_ARRAY:\n                max_index = 0;\n                if (ngx_rtmp_amf_put(ctx, &max_index, 4) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n\n                /* fall through */\n\n            case NGX_RTMP_AMF_OBJECT:\n                type8 = NGX_RTMP_AMF_END;\n                if (ngx_rtmp_amf_write_object(ctx, data,\n                        elts[n].len / sizeof(ngx_rtmp_amf_elt_t)) != NGX_OK\n                    || ngx_rtmp_amf_put(ctx, &type8, 1) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_ARRAY:\n                if (ngx_rtmp_amf_write_array(ctx, data,\n                        elts[n].len / sizeof(ngx_rtmp_amf_elt_t)) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_INT8:\n                if (ngx_rtmp_amf_put(ctx, data, 1) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_INT16:\n                if (ngx_rtmp_amf_put(ctx,\n                            ngx_rtmp_amf_reverse_copy(buf,\n                                data, 2), 2) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            case NGX_RTMP_AMF_INT32:\n                if (ngx_rtmp_amf_put(ctx,\n                            ngx_rtmp_amf_reverse_copy(buf,\n                                data, 4), 4) != NGX_OK)\n                {\n                    return NGX_ERROR;\n                }\n                break;\n\n            default:\n                return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n\n"
        },
        {
          "name": "ngx_rtmp_amf.h",
          "type": "blob",
          "size": 1.8876953125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_AMF_H_INCLUDED_\n#define _NGX_RTMP_AMF_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n/* basic types */\n#define NGX_RTMP_AMF_NUMBER             0x00\n#define NGX_RTMP_AMF_BOOLEAN            0x01\n#define NGX_RTMP_AMF_STRING             0x02\n#define NGX_RTMP_AMF_OBJECT             0x03\n#define NGX_RTMP_AMF_NULL               0x05\n#define NGX_RTMP_AMF_ARRAY_NULL         0x06\n#define NGX_RTMP_AMF_MIXED_ARRAY        0x08\n#define NGX_RTMP_AMF_END                0x09\n#define NGX_RTMP_AMF_ARRAY              0x0a\n\n/* extended types */\n#define NGX_RTMP_AMF_INT8               0x0100\n#define NGX_RTMP_AMF_INT16              0x0101\n#define NGX_RTMP_AMF_INT32              0x0102\n#define NGX_RTMP_AMF_VARIANT_           0x0103\n\n/* r/w flags */\n#define NGX_RTMP_AMF_OPTIONAL           0x1000\n#define NGX_RTMP_AMF_TYPELESS           0x2000\n#define NGX_RTMP_AMF_CONTEXT            0x4000\n\n#define NGX_RTMP_AMF_VARIANT            (NGX_RTMP_AMF_VARIANT_\\\n                                        |NGX_RTMP_AMF_TYPELESS)\n\n\ntypedef struct {\n    ngx_int_t                           type;\n    ngx_str_t                           name;\n    void                               *data;\n    size_t                              len;\n} ngx_rtmp_amf_elt_t;\n\n\ntypedef ngx_chain_t * (*ngx_rtmp_amf_alloc_pt)(void *arg);\n\n\ntypedef struct {\n    ngx_chain_t                        *link, *first;\n    size_t                              offset;\n    ngx_rtmp_amf_alloc_pt               alloc;\n    void                               *arg;\n    ngx_log_t                          *log;\n} ngx_rtmp_amf_ctx_t;\n\n\n/* reading AMF */\nngx_int_t ngx_rtmp_amf_read(ngx_rtmp_amf_ctx_t *ctx,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts);\n\n/* writing AMF */\nngx_int_t ngx_rtmp_amf_write(ngx_rtmp_amf_ctx_t *ctx,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts);\n\n\n#endif /* _NGX_RTMP_AMF_H_INCLUDED_ */\n\n"
        },
        {
          "name": "ngx_rtmp_auto_push_module.c",
          "type": "blob",
          "size": 20.8896484375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining \n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_relay_module.h\"\n\n\nstatic ngx_rtmp_publish_pt          next_publish;\nstatic ngx_rtmp_delete_stream_pt    next_delete_stream;\n\n\nstatic ngx_int_t ngx_rtmp_auto_push_init_process(ngx_cycle_t *cycle);\nstatic void ngx_rtmp_auto_push_exit_process(ngx_cycle_t *cycle);\nstatic void * ngx_rtmp_auto_push_create_conf(ngx_cycle_t *cf);\nstatic char * ngx_rtmp_auto_push_init_conf(ngx_cycle_t *cycle, void *conf);\n#if (NGX_HAVE_UNIX_DOMAIN)\nstatic ngx_int_t ngx_rtmp_auto_push_publish(ngx_rtmp_session_t *s,\n       ngx_rtmp_publish_t *v);\nstatic ngx_int_t ngx_rtmp_auto_push_delete_stream(ngx_rtmp_session_t *s,\n       ngx_rtmp_delete_stream_t *v);\n#endif\n\n\ntypedef struct ngx_rtmp_auto_push_ctx_s ngx_rtmp_auto_push_ctx_t;\n\nstruct ngx_rtmp_auto_push_ctx_s {\n    ngx_int_t                      *slots; /* NGX_MAX_PROCESSES */\n    u_char                          name[NGX_RTMP_MAX_NAME];\n    u_char                          args[NGX_RTMP_MAX_ARGS];\n    ngx_event_t                     push_evt;\n};\n\n\ntypedef struct {\n    ngx_flag_t                      auto_push;\n    ngx_str_t                       socket_dir;\n    ngx_msec_t                      push_reconnect;\n} ngx_rtmp_auto_push_conf_t;\n\n\nstatic ngx_command_t  ngx_rtmp_auto_push_commands[] = {\n\n    { ngx_string(\"rtmp_auto_push\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_rtmp_auto_push_conf_t, auto_push),\n      NULL },\n\n    { ngx_string(\"rtmp_auto_push_reconnect\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_rtmp_auto_push_conf_t, push_reconnect),\n      NULL },\n\n    { ngx_string(\"rtmp_socket_dir\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_rtmp_auto_push_conf_t, socket_dir),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_core_module_t  ngx_rtmp_auto_push_module_ctx = {\n    ngx_string(\"rtmp_auto_push\"),\n    ngx_rtmp_auto_push_create_conf,         /* create conf */\n    ngx_rtmp_auto_push_init_conf            /* init conf */\n};\n\n\nngx_module_t  ngx_rtmp_auto_push_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_auto_push_module_ctx,         /* module context */\n    ngx_rtmp_auto_push_commands,            /* module directives */\n    NGX_CORE_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    ngx_rtmp_auto_push_init_process,        /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    ngx_rtmp_auto_push_exit_process,        /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_auto_push_index_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    NULL,                                   /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    NULL,                                   /* create app configuration */\n    NULL                                    /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_auto_push_index_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_auto_push_index_module_ctx,   /* module context */\n    NULL,                                   /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\n#define NGX_RTMP_AUTO_PUSH_SOCKNAME         \"nginx-http-flv\"\n\n\nstatic ngx_int_t\nngx_rtmp_auto_push_init_process(ngx_cycle_t *cycle)\n{\n#if (NGX_HAVE_UNIX_DOMAIN)\n    ngx_rtmp_auto_push_conf_t   *apcf;\n    ngx_listening_t             *ls, *lss;\n    struct sockaddr_un          *saun;\n#if (nginx_version >= 1009011)\n    ngx_event_t                 *rev;\n    ngx_connection_t            *c;\n    ngx_module_t               **modules;\n    ngx_int_t                    i, auto_push_index, event_core_index;\n#endif\n    int                          reuseaddr;\n    ngx_socket_t                 s;\n    size_t                       n;\n    ngx_file_info_t              fi;\n    ngx_pid_t                    pid;\n\n    if (ngx_process != NGX_PROCESS_WORKER) {\n        return NGX_OK;\n    }\n\n    apcf = (ngx_rtmp_auto_push_conf_t *) ngx_get_conf(cycle->conf_ctx,\n                                                    ngx_rtmp_auto_push_module);\n    if (apcf->auto_push == 0) {\n        return NGX_OK;\n    }\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_auto_push_publish;\n\n    next_delete_stream = ngx_rtmp_delete_stream;\n    ngx_rtmp_delete_stream = ngx_rtmp_auto_push_delete_stream;\n\n    reuseaddr = 1;\n    s = (ngx_socket_t) -1;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, cycle->log, 0,\n            \"auto_push: creating sockets\");\n\n    /*TODO: clone all RTMP listenings? */\n    ls = cycle->listening.elts;\n    lss = NULL;\n    for (n = 0; n < cycle->listening.nelts; ++n, ++ls) {\n        if (ls->handler == ngx_rtmp_init_connection) {\n            lss = ls;\n            break;\n        }\n    }\n\n    if (lss == NULL) {\n        return NGX_OK;\n    }\n\n    ls = ngx_array_push(&cycle->listening);\n    if (ls == NULL) {\n        return NGX_ERROR;\n    }\n\n    *ls = *lss;\n\n    /* Disable unix socket client address extraction\n     * from accept call\n     * Nginx generates bad addr_text with this enabled */\n    ls->addr_ntop = 0;\n\n    ls->socklen = sizeof(struct sockaddr_un);\n    saun = ngx_pcalloc(cycle->pool, ls->socklen);\n    ls->sockaddr = (struct sockaddr *) saun;\n    if (ls->sockaddr == NULL) {\n        return NGX_ERROR;\n    }\n    saun->sun_family = AF_UNIX;\n    pid = ngx_getpid();\n    *ngx_snprintf((u_char *) saun->sun_path, sizeof(saun->sun_path),\n                  \"%V/\" NGX_RTMP_AUTO_PUSH_SOCKNAME \".%P\",\n                  &apcf->socket_dir, pid)\n        = 0;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, cycle->log, 0,\n                   \"auto_push: create socket '%s'\",\n                   saun->sun_path);\n\n    if (ngx_file_info(saun->sun_path, &fi) != ENOENT) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, cycle->log, 0,\n                       \"auto_push: delete existing socket '%s'\",\n                       saun->sun_path);\n        ngx_delete_file(saun->sun_path);\n    }\n\n    ls->addr_text.data = (u_char *) saun->sun_path;\n    ls->addr_text.len = ngx_strlen(saun->sun_path);\n\n    s = ngx_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (s == -1) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                      ngx_socket_n \" %s failed\", saun->sun_path);\n        return NGX_ERROR;\n    }\n\n    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n                   (const void *) &reuseaddr, sizeof(int))\n        == -1)\n    {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                \"setsockopt(SO_REUSEADDR) %s failed\", saun->sun_path);\n        goto sock_error;\n    }\n\n    if (!(ngx_event_flags & NGX_USE_AIO_EVENT)) {\n        if (ngx_nonblocking(s) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                          ngx_nonblocking_n \" %s failed\", saun->sun_path);\n            return NGX_ERROR;\n        }\n    }\n\n    if (bind(s, (struct sockaddr *) saun, sizeof(*saun)) == -1) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                      ngx_nonblocking_n \" %s bind failed\", saun->sun_path);\n        goto sock_error;\n    }\n\n    if (listen(s, NGX_LISTEN_BACKLOG) == -1) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                      \"listen() to %s, backlog %d failed\",\n                      saun->sun_path, NGX_LISTEN_BACKLOG);\n        goto sock_error;\n    }\n\n    ls->fd = s;\n    ls->listen = 1;\n\n    /* Socket option `SO_REUSEPORT` has been supported since nginx-1.9.1,\n     * if option `reuseport` is added for the directive `listen`, listening \n     * structure of unix domain socket in the non-first process will not be \n     * initialized, in fact `reuseport` is useless for a unix domain socket \n     * on which there is only a process listening */ \n\n#if (NGX_HAVE_REUSEPORT)\n    ls->reuseport = 0;\n#endif\n\n    /* for dynamic module */\n#if (nginx_version >= 1009011)\n    auto_push_index = -1;\n    event_core_index = -1;\n\n    modules = cycle->modules;\n\n    for (i = 0; modules[i]; ++i) {\n        if (ngx_strcmp(modules[i]->name, \"ngx_event_core_module\") == 0) {\n            event_core_index = i;\n        }\n\n        if (ngx_strcmp(modules[i]->name, \"ngx_rtmp_auto_push_module\") == 0) {\n            auto_push_index = i;\n        }\n\n        if (auto_push_index != -1 && event_core_index != -1) {\n            break;\n        }\n    }\n\n    if (auto_push_index > event_core_index) {\n        c = ngx_get_connection(ls->fd, cycle->log);\n        if (c == NULL) {\n            goto sock_error;\n        }\n\n        rev = c->read;\n\n#if (nginx_version >= 1009013)\n        c->type = ls->type;\n#endif\n        c->log = &ls->log;\n\n        c->listening = ls;\n        ls->connection = c;\n\n        rev->log = c->log;\n        rev->accept = 1;\n\n#if (NGX_HAVE_DEFERRED_ACCEPT)\n        rev->deferred_accept = ls->deferred_accept;\n#endif\n\n#if (nginx_version >= 1009013)\n        rev->handler = (c->type == SOCK_STREAM) ? ngx_event_accept\n                                                : ngx_event_recvmsg;\n#else\n        rev->handler = ngx_event_accept;\n#endif\n\n        if (ngx_add_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {\n            return NGX_ERROR;\n        }\n    }\n#endif\n\n    return NGX_OK;\n\nsock_error:\n    if (s != (ngx_socket_t) -1 && ngx_close_socket(s) == -1) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_socket_errno,\n                ngx_close_socket_n \" %s failed\", saun->sun_path);\n    }\n    ngx_delete_file(saun->sun_path);\n\n    return NGX_ERROR;\n\n#else  /* NGX_HAVE_UNIX_DOMAIN */\n\n    return NGX_OK;\n\n#endif /* NGX_HAVE_UNIX_DOMAIN */\n}\n\n\nstatic void\nngx_rtmp_auto_push_exit_process(ngx_cycle_t *cycle)\n{\n#if (NGX_HAVE_UNIX_DOMAIN)\n    ngx_rtmp_auto_push_conf_t  *apcf;\n    u_char                      path[NGX_MAX_PATH];\n\n    ngx_listening_t             *ls;\n    ngx_connection_t            *c;\n    size_t                       n;\n    ngx_pid_t                    pid;\n\n    apcf = (ngx_rtmp_auto_push_conf_t *) ngx_get_conf(cycle->conf_ctx,\n                                                    ngx_rtmp_auto_push_module);\n    if (apcf->auto_push == 0) {\n        return;\n    }\n\n    ls = cycle->listening.elts;\n\n    for (n = 0; n < cycle->listening.nelts; ++n, ++ls) {\n        if ((ls->handler == ngx_rtmp_init_connection) &&\n            (ls->sockaddr && ls->sockaddr->sa_family == AF_UNIX))\n        {\n            c = ls->connection;\n\n            if (c) {\n                if (c->read->active) {\n                    if (!(ngx_event_flags & NGX_USE_IOCP_EVENT)) {\n\n                        /*\n                         * delete the old accept events that were bound to\n                         * the old cycle read events array\n                         */\n\n                        ngx_del_event(c->read,\n                                      NGX_READ_EVENT, NGX_CLOSE_EVENT);\n\n                        ngx_free_connection(c);\n\n                        c->fd = (ngx_socket_t) -1;\n                    }\n                }\n            }\n\n            if (ngx_close_socket(ls->fd) == -1) {\n                ngx_log_error(NGX_LOG_ERR, cycle->log, ngx_socket_errno,\n                              ngx_close_socket_n \"%V failed\",\n                              &ls->addr_text);\n            }\n\n            ls->fd = (ngx_socket_t) -1;\n\n            break;\n        }\n    }\n\n    pid = ngx_getpid();\n    *ngx_snprintf(path, sizeof(path),\n                  \"%V/\" NGX_RTMP_AUTO_PUSH_SOCKNAME \".%P\",\n                  &apcf->socket_dir, pid)\n         = 0;\n\n    ngx_delete_file(path);\n\n#endif\n}\n\n\nstatic void *\nngx_rtmp_auto_push_create_conf(ngx_cycle_t *cycle)\n{\n    ngx_rtmp_auto_push_conf_t       *apcf;\n\n    apcf = ngx_pcalloc(cycle->pool, sizeof(ngx_rtmp_auto_push_conf_t));\n    if (apcf == NULL) {\n        return NULL;\n    }\n\n    apcf->auto_push = NGX_CONF_UNSET;\n    apcf->push_reconnect = NGX_CONF_UNSET_MSEC;\n\n    return apcf;\n}\n\n\nstatic char *\nngx_rtmp_auto_push_init_conf(ngx_cycle_t *cycle, void *conf)\n{\n    ngx_rtmp_auto_push_conf_t      *apcf = conf;\n\n    ngx_conf_init_value(apcf->auto_push, 0);\n    ngx_conf_init_msec_value(apcf->push_reconnect, 100);\n\n    if (apcf->socket_dir.len == 0) {\n        ngx_str_set(&apcf->socket_dir, \"/tmp\");\n    }\n\n    return NGX_CONF_OK;\n}\n\n\n#if (NGX_HAVE_UNIX_DOMAIN)\nstatic void\nngx_rtmp_auto_push_reconnect(ngx_event_t *ev)\n{\n    ngx_rtmp_session_t             *s = ev->data;\n\n    ngx_rtmp_auto_push_conf_t      *apcf;\n    ngx_rtmp_auto_push_ctx_t       *ctx;\n    ngx_int_t                      *slot;\n    ngx_int_t                       n;\n    ngx_rtmp_relay_target_t         at;\n    u_char                          path[sizeof(\"unix:\") + NGX_MAX_PATH];\n    u_char                          flash_ver[sizeof(\"APSH ,\") +\n                                              NGX_INT_T_LEN * 2];\n    u_char                          play_path[NGX_RTMP_MAX_NAME];\n    ngx_str_t                       name;\n    u_char                         *p;\n    ngx_str_t                      *u;\n    ngx_pid_t                       pid;\n    ngx_int_t                       npushed;\n    ngx_core_conf_t                *ccf;\n    ngx_file_info_t                 fi;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"auto_push: reconnect\");\n\n    apcf = (ngx_rtmp_auto_push_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                                    ngx_rtmp_auto_push_module);\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_auto_push_index_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    name.data = ctx->name;\n    name.len = ngx_strlen(name.data);\n\n    ngx_memzero(&at, sizeof(at));\n    ngx_str_set(&at.page_url, \"nginx-auto-push\");\n    at.tag = &ngx_rtmp_auto_push_module;\n\n    if (s->app.len) {\n        at.app.data = s->app.data;\n        at.app.len = s->app.len;\n    }\n\n    if (ctx->args[0]) {\n        at.play_path.data = play_path;\n        at.play_path.len = ngx_snprintf(play_path, sizeof(play_path),\n                                        \"%s?%s\", ctx->name, ctx->args) -\n                           play_path;\n    }\n\n    slot = ctx->slots;\n    npushed = 0;\n\n    for (n = 0; n < NGX_MAX_PROCESSES; ++n, ++slot) {\n        if (n == ngx_process_slot) {\n            continue;\n        }\n\n        pid = ngx_processes[n].pid;\n        if (pid == 0 || pid == NGX_INVALID_PID) {\n            continue;\n        }\n\n        if (*slot) {\n            npushed++;\n            continue;\n        }\n\n        at.data = &ngx_processes[n];\n\n        ngx_memzero(&at.url, sizeof(at.url));\n        u = &at.url.url;\n        p = ngx_snprintf(path, sizeof(path) - 1,\n                         \"unix:%V/\" NGX_RTMP_AUTO_PUSH_SOCKNAME \".%P\",\n                         &apcf->socket_dir, pid);\n        *p = 0;\n\n        if (ngx_file_info(path + sizeof(\"unix:\") - 1, &fi) != NGX_OK) {\n            ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"auto_push: \" ngx_file_info_n \" failed: \"\n                           \"slot=%i pid=%P socket='%s'\" \"url='%V' name='%s'\",\n                           n, pid, path, u, ctx->name);\n            continue;\n        }\n\n        u->data = path;\n        u->len = p - path;\n        if (ngx_parse_url(s->connection->pool, &at.url) != NGX_OK) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"auto_push: auto-push parse_url failed \"\n                          \"url='%V' name='%s'\",\n                          u, ctx->name);\n            continue;\n        }\n\n        p = ngx_snprintf(flash_ver, sizeof(flash_ver) - 1, \"APSH %i,%i\",\n                         (ngx_int_t) ngx_process_slot, (ngx_int_t) ngx_pid);\n        at.flash_ver.data = flash_ver;\n        at.flash_ver.len = p - flash_ver;\n\n        ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"auto_push: connect slot=%i pid=%P socket='%s' name='%s'\",\n                       n, pid, path, ctx->name);\n\n        if (ngx_rtmp_relay_push(s, &name, &at) == NGX_OK) {\n            *slot = 1;\n            npushed++;\n            continue;\n        }\n\n        ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                      \"auto_push: connect failed: slot=%i pid=%P socket='%s'\"\n                      \"url='%V' name='%s'\",\n                      n, pid, path, u, ctx->name);\n    }\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                           ngx_core_module);\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"auto_push: pushed=%i total=%i failed=%i\",\n                   npushed, ccf->worker_processes,\n                   ccf->worker_processes - 1 - npushed);\n\n    if (ccf->worker_processes == npushed + 1) {\n        return;\n    }\n\n    /* several workers failed */\n\n    slot = ctx->slots;\n\n    for (n = 0; n < NGX_MAX_PROCESSES; ++n, ++slot) {\n        pid = ngx_processes[n].pid;\n\n        if (n == ngx_process_slot || *slot == 1 ||\n            pid == 0 || pid == NGX_INVALID_PID)\n        {\n            continue;\n        }\n\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"auto_push: connect failed: slot=%i pid=%P name='%s'\",\n                      n, pid, ctx->name);\n    }\n\n    if (!ctx->push_evt.timer_set) {\n        ngx_add_timer(&ctx->push_evt, apcf->push_reconnect);\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_auto_push_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_auto_push_conf_t      *apcf;\n    ngx_rtmp_auto_push_ctx_t       *ctx;\n\n    if (s->auto_pushed || (s->relay && !s->static_relay)) {\n        goto next;\n    }\n\n    apcf = (ngx_rtmp_auto_push_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                                    ngx_rtmp_auto_push_module);\n    if (apcf->auto_push == 0) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_auto_push_index_module);\n    if (ctx == NULL) {\n        ctx = ngx_palloc(s->connection->pool,\n                         sizeof(ngx_rtmp_auto_push_ctx_t));\n        if (ctx == NULL) {\n            goto next;\n        }\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_auto_push_index_module);\n\n    }\n    ngx_memzero(ctx, sizeof(*ctx));\n\n    ctx->push_evt.data = s;\n    ctx->push_evt.log = s->connection->log;\n    ctx->push_evt.handler = ngx_rtmp_auto_push_reconnect;\n\n    ctx->slots = ngx_pcalloc(s->connection->pool,\n                             sizeof(ngx_int_t) * NGX_MAX_PROCESSES);\n    if (ctx->slots == NULL) {\n        goto next;\n    }\n\n    ngx_memcpy(ctx->name, v->name, sizeof(ctx->name));\n    ngx_memcpy(ctx->args, v->args, sizeof(ctx->args));\n\n    ngx_rtmp_auto_push_reconnect(&ctx->push_evt);\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_auto_push_delete_stream(ngx_rtmp_session_t *s,\n    ngx_rtmp_delete_stream_t *v)\n{\n    ngx_rtmp_auto_push_conf_t      *apcf;\n    ngx_rtmp_auto_push_ctx_t       *ctx, *pctx;\n    ngx_rtmp_relay_ctx_t           *rctx;\n    ngx_int_t                       slot;\n\n    apcf = (ngx_rtmp_auto_push_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                                    ngx_rtmp_auto_push_module);\n    if (apcf->auto_push == 0) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_auto_push_index_module);\n    if (ctx) {\n        if (ctx->push_evt.timer_set) {\n            ngx_del_timer(&ctx->push_evt);\n        }\n        goto next;\n    }\n\n    /* skip non-relays & publishers */\n    rctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (rctx == NULL ||\n        rctx->tag != &ngx_rtmp_auto_push_module ||\n        rctx->publish == NULL)\n    {\n        goto next;\n    }\n\n    slot = (ngx_process_t *) rctx->data - &ngx_processes[0];\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"auto_push: disconnect slot=%i app='%V' name='%V'\",\n                   slot, &rctx->app, &rctx->name);\n\n    pctx = ngx_rtmp_get_module_ctx(rctx->publish->session,\n                                   ngx_rtmp_auto_push_index_module);\n    if (pctx == NULL) {\n        goto next;\n    }\n\n    pctx->slots[slot] = 0;\n\n    /* push reconnect */\n    if (!pctx->push_evt.timer_set) {\n        ngx_add_timer(&pctx->push_evt, apcf->push_reconnect);\n    }\n\nnext:\n    return next_delete_stream(s, v);\n}\n#endif /* NGX_HAVE_UNIX_DOMAIN */\n"
        },
        {
          "name": "ngx_rtmp_bandwidth.c",
          "type": "blob",
          "size": 0.5751953125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_bandwidth.h\"\n\n\nvoid\nngx_rtmp_update_bandwidth(ngx_rtmp_bandwidth_t *bw, uint32_t bytes)\n{\n    if (ngx_cached_time->sec > bw->intl_end) {\n        bw->bandwidth = ngx_cached_time->sec >\n            bw->intl_end + NGX_RTMP_BANDWIDTH_INTERVAL\n            ? 0\n            : bw->intl_bytes / NGX_RTMP_BANDWIDTH_INTERVAL;\n        bw->intl_bytes = 0;\n        bw->intl_end = ngx_cached_time->sec + NGX_RTMP_BANDWIDTH_INTERVAL;\n    }\n\n    bw->bytes += bytes;\n    bw->intl_bytes += bytes;\n}\n"
        },
        {
          "name": "ngx_rtmp_bandwidth.h",
          "type": "blob",
          "size": 0.5703125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_BANDWIDTH_H_INCLUDED_\n#define _NGX_RTMP_BANDWIDTH_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n/* Bandwidth update interval in seconds */\n#define NGX_RTMP_BANDWIDTH_INTERVAL     10\n\n\ntypedef struct {\n    uint64_t            bytes;\n    uint64_t            bandwidth;      /* bytes/sec */\n\n    time_t              intl_end;\n    uint64_t            intl_bytes;\n} ngx_rtmp_bandwidth_t;\n\n\nvoid ngx_rtmp_update_bandwidth(ngx_rtmp_bandwidth_t *bw, uint32_t bytes);\n\n\n#endif /* _NGX_RTMP_BANDWIDTH_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_bitop.c",
          "type": "blob",
          "size": 1.037109375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_bitop.h\"\n\n\nvoid\nngx_rtmp_bit_init_reader(ngx_rtmp_bit_reader_t *br, u_char *pos, u_char *last)\n{\n    ngx_memzero(br, sizeof(ngx_rtmp_bit_reader_t));\n\n    br->pos = pos;\n    br->last = last;\n}\n\n\nuint64_t\nngx_rtmp_bit_read(ngx_rtmp_bit_reader_t *br, ngx_uint_t n)\n{\n    uint64_t    v;\n    ngx_uint_t  d;\n\n    v = 0;\n\n    while (n) {\n\n        if (br->pos >= br->last) {\n            br->err = 1;\n            return 0;\n        }\n\n        d = (br->offs + n > 8 ? (ngx_uint_t) (8 - br->offs) : n);\n\n        v <<= d;\n        v += (*br->pos >> (8 - br->offs - d)) & ((u_char) 0xff >> (8 - d));\n\n        br->offs += d;\n        n -= d;\n\n        if (br->offs == 8) {\n            br->pos++;\n            br->offs = 0;\n        }\n    }\n\n    return v;\n}\n\n\nuint64_t\nngx_rtmp_bit_read_golomb(ngx_rtmp_bit_reader_t *br)\n{\n    ngx_uint_t  n;\n\n    for (n = 0; ngx_rtmp_bit_read(br, 1) == 0 && !br->err; n++);\n\n    return ((uint64_t) 1 << n) + ngx_rtmp_bit_read(br, n) - 1;\n}\n"
        },
        {
          "name": "ngx_rtmp_bitop.h",
          "type": "blob",
          "size": 1.138671875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_BITOP_H_INCLUDED_\n#define _NGX_RTMP_BITOP_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\ntypedef struct {\n    u_char      *pos;\n    u_char      *last;\n    ngx_uint_t   offs;\n    ngx_uint_t   err;\n} ngx_rtmp_bit_reader_t;\n\n\nvoid ngx_rtmp_bit_init_reader(ngx_rtmp_bit_reader_t *br, u_char *pos,\n    u_char *last);\nuint64_t ngx_rtmp_bit_read(ngx_rtmp_bit_reader_t *br, ngx_uint_t n);\nuint64_t ngx_rtmp_bit_read_golomb(ngx_rtmp_bit_reader_t *br);\n\n\n#define ngx_rtmp_bit_read_err(br) ((br)->err)\n\n#define ngx_rtmp_bit_read_eof(br) ((br)->pos == (br)->last)\n\n#define ngx_rtmp_bit_read_8(br)                                               \\\n    ((uint8_t) ngx_rtmp_bit_read(br, 8))\n\n#define ngx_rtmp_bit_read_16(br)                                              \\\n    ((uint16_t) ngx_rtmp_bit_read(br, 16))\n\n#define ngx_rtmp_bit_read_32(br)                                              \\\n    ((uint32_t) ngx_rtmp_bit_read(br, 32))\n\n#define ngx_rtmp_bit_read_64(br)                                              \\\n    ((uint64_t) ngx_rtmp_bit_read(br, 64))\n\n\n#endif /* _NGX_RTMP_BITOP_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_cmd_module.c",
          "type": "blob",
          "size": 25.7099609375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_streams.h\"\n\n\n#define NGX_RTMP_FMS_VERSION        \"FMS/3,0,1,123\"\n#define NGX_RTMP_CAPABILITIES       31\n\n\nstatic ngx_int_t ngx_rtmp_cmd_connect(ngx_rtmp_session_t *s,\n       ngx_rtmp_connect_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_disconnect(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_cmd_create_stream(ngx_rtmp_session_t *s,\n       ngx_rtmp_create_stream_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_close_stream(ngx_rtmp_session_t *s,\n       ngx_rtmp_close_stream_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_delete_stream(ngx_rtmp_session_t *s,\n       ngx_rtmp_delete_stream_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_publish(ngx_rtmp_session_t *s,\n       ngx_rtmp_publish_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_play(ngx_rtmp_session_t *s,\n       ngx_rtmp_play_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_seek(ngx_rtmp_session_t *s,\n       ngx_rtmp_seek_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_pause(ngx_rtmp_session_t *s,\n       ngx_rtmp_pause_t *v);\n\n\nstatic ngx_int_t ngx_rtmp_cmd_stream_begin(ngx_rtmp_session_t *s,\n       ngx_rtmp_stream_begin_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_stream_eof(ngx_rtmp_session_t *s,\n       ngx_rtmp_stream_eof_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_stream_dry(ngx_rtmp_session_t *s,\n       ngx_rtmp_stream_dry_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_recorded(ngx_rtmp_session_t *s,\n       ngx_rtmp_recorded_t *v);\nstatic ngx_int_t ngx_rtmp_cmd_set_buflen(ngx_rtmp_session_t *s,\n       ngx_rtmp_set_buflen_t *v);\n\n\nngx_rtmp_connect_pt         ngx_rtmp_connect;\nngx_rtmp_disconnect_pt      ngx_rtmp_disconnect;\nngx_rtmp_create_stream_pt   ngx_rtmp_create_stream;\nngx_rtmp_close_stream_pt    ngx_rtmp_close_stream;\nngx_rtmp_delete_stream_pt   ngx_rtmp_delete_stream;\nngx_rtmp_publish_pt         ngx_rtmp_publish;\nngx_rtmp_play_pt            ngx_rtmp_play;\nngx_rtmp_seek_pt            ngx_rtmp_seek;\nngx_rtmp_pause_pt           ngx_rtmp_pause;\n\n\nngx_rtmp_stream_begin_pt    ngx_rtmp_stream_begin;\nngx_rtmp_stream_eof_pt      ngx_rtmp_stream_eof;\nngx_rtmp_stream_dry_pt      ngx_rtmp_stream_dry;\nngx_rtmp_recorded_pt        ngx_rtmp_recorded;\nngx_rtmp_set_buflen_pt      ngx_rtmp_set_buflen;\n\n\nstatic ngx_int_t ngx_rtmp_cmd_postconfiguration(ngx_conf_t *cf);\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_cmd_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_cmd_postconfiguration,         /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    NULL,                                   /* create app configuration */\n    NULL                                    /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_cmd_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_cmd_module_ctx,               /* module context */\n    NULL,                                   /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nvoid\nngx_rtmp_cmd_fill_args(u_char name[NGX_RTMP_MAX_NAME],\n        u_char args[NGX_RTMP_MAX_ARGS])\n{\n    u_char      *p;\n\n    p = (u_char *)ngx_strchr(name, '?');\n    if (p == NULL) {\n        return;\n    }\n\n    *p++ = 0;\n    ngx_cpystrn(args, p, NGX_RTMP_MAX_ARGS);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_connect_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    size_t                      len;\n\n    static ngx_rtmp_connect_t   v;\n\n    static ngx_rtmp_amf_elt_t  in_cmd[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"app\"),\n          v.app, sizeof(v.app) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"flashVer\"),\n          v.flashver, sizeof(v.flashver) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"swfUrl\"),\n          v.swf_url, sizeof(v.swf_url) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"tcUrl\"),\n          v.tc_url, sizeof(v.tc_url) },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audioCodecs\"),\n          &v.acodecs, sizeof(v.acodecs) },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"videoCodecs\"),\n          &v.vcodecs, sizeof(v.vcodecs) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"pageUrl\"),\n          v.page_url, sizeof(v.page_url) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"serverName\"),\n          v.server_name, sizeof(v.server_name) },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"objectEncoding\"),\n          &v.object_encoding, 0},\n    };\n\n    static ngx_rtmp_amf_elt_t  in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_cmd, sizeof(in_cmd) },\n    };\n\n    ngx_memzero(&v, sizeof(v));\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    if (v.tc_url[0]) {\n        /* compatibility for case: rtmps -> converter -> rtmp */\n        if (ngx_strncasecmp(v.tc_url, (u_char *) \"rtmps://\", 8) == 0) {\n            ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,\n                          \"connect: rtmps tcUrl received: %s\", v.tc_url);\n\n            ngx_memmove(v.tc_url + 4, v.tc_url + 5, ngx_strlen(v.tc_url) - 5);\n        }\n    }\n\n#define NGX_RTMP_SET_STRPAR(name)                                             \\\n    s->name.len = ngx_strlen(v.name);                                         \\\n    s->name.data = ngx_palloc(s->connection->pool, s->name.len);              \\\n    ngx_memcpy(s->name.data, v.name, s->name.len)\n\n    NGX_RTMP_SET_STRPAR(app);\n    NGX_RTMP_SET_STRPAR(args);\n    NGX_RTMP_SET_STRPAR(flashver);\n    NGX_RTMP_SET_STRPAR(swf_url);\n    NGX_RTMP_SET_STRPAR(tc_url);\n    NGX_RTMP_SET_STRPAR(page_url);\n\n#undef NGX_RTMP_SET_STRPAR\n\n    if (s->auto_pushed) {\n        s->host_start = v.server_name;\n        s->host_end = v.server_name + ngx_strlen(v.server_name);\n    }\n\n    if (ngx_rtmp_process_virtual_host(s) != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"connect: failed to process virtual host\");\n\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_cmd_fill_args(v.app, v.args);\n\n    len = ngx_strlen(v.app);\n    if (len > 10 && !ngx_memcmp(v.app + len - 10, \"/_definst_\", 10)) {\n        v.app[len - 10] = 0;\n    } else if (len && v.app[len - 1] == '/') {\n        v.app[len - 1] = 0;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n            \"connect: app='%s' args='%s' flashver='%s' swf_url='%s' \"\n            \"tc_url='%s' page_url='%s' acodecs=%uD vcodecs=%uD \"\n            \"object_encoding=%ui\",\n            v.app, v.args, v.flashver, v.swf_url, v.tc_url, v.page_url,\n            (uint32_t)v.acodecs, (uint32_t)v.vcodecs,\n            (ngx_int_t)v.object_encoding);\n\n    return ngx_rtmp_connect(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_connect(ngx_rtmp_session_t *s, ngx_rtmp_connect_t *v)\n{\n    int                         tcp_nodelay;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_rtmp_core_app_conf_t  **cacfp, *cacf;\n    ngx_uint_t                  n;\n    ngx_rtmp_header_t           h;\n    ngx_connection_t           *c;\n    u_char                     *p;\n\n    static double               trans;\n    static double               capabilities = NGX_RTMP_CAPABILITIES;\n    static double               object_encoding = 0;\n\n    static ngx_rtmp_amf_elt_t  out_obj[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"fmsVer\"),\n          NGX_RTMP_FMS_VERSION, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"capabilities\"),\n          &capabilities, 0 },\n    };\n\n    static ngx_rtmp_amf_elt_t  out_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          \"status\", 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          \"NetConnection.Connect.Success\", 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          \"Connection succeeded.\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"objectEncoding\"),\n          &object_encoding, 0 }\n    };\n\n    static ngx_rtmp_amf_elt_t  out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"_result\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_obj, sizeof(out_obj) },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf, sizeof(out_inf) },\n    };\n\n    if (s->connected) {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                \"connect: duplicate connection\");\n        return NGX_ERROR;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    trans = v->trans;\n\n    /* fill session parameters */\n    s->connected = 1;\n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_CSID_AMF_INI;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n\n#define NGX_RTMP_SET_STRPAR(name)                                             \\\n    do {                                                                      \\\n        if (s->name.len != ngx_strlen(v->name)                                \\\n            || ngx_strncasecmp(s->name.data, v->name, s->name.len))           \\\n        {                                                                     \\\n            s->name.len = ngx_strlen(v->name);                                \\\n            s->name.data = ngx_palloc(s->connection->pool, s->name.len);      \\\n            ngx_memcpy(s->name.data, v->name, s->name.len);                   \\\n        }                                                                     \\\n    } while (0)\n\n    NGX_RTMP_SET_STRPAR(app);\n    NGX_RTMP_SET_STRPAR(args);\n    NGX_RTMP_SET_STRPAR(flashver);\n    NGX_RTMP_SET_STRPAR(swf_url);\n    NGX_RTMP_SET_STRPAR(tc_url);\n    NGX_RTMP_SET_STRPAR(page_url);\n\n#undef NGX_RTMP_SET_STRPAR\n\n    p = ngx_strlchr(s->app.data, s->app.data + s->app.len, '?');\n    if (p) {\n        s->app.len = (p - s->app.data);\n    }\n\n    s->acodecs = (uint32_t) v->acodecs;\n    s->vcodecs = (uint32_t) v->vcodecs;\n\n    /* find application & set app_conf */\n    cacfp = cscf->applications.elts;\n    for(n = 0; n < cscf->applications.nelts; ++n, ++cacfp) {\n        if ((*cacfp)->name.len == s->app.len &&\n            ngx_strncmp((*cacfp)->name.data, s->app.data, s->app.len) == 0)\n        {\n            /* found app! */\n            s->app_conf = (*cacfp)->app_conf;\n            break;\n        }\n    }\n\n    if (s->app_conf == NULL) {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                      \"connect: application not found: '%V'\", &s->app);\n        return NGX_ERROR;\n    }\n\n    object_encoding = v->object_encoding;\n    \n    if (s->data == NULL) {\n        cacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_core_module);\n        c = s->connection;\n\n        if (!cacf->tcp_nopush) {\n            c->tcp_nopush = NGX_TCP_NOPUSH_DISABLED;\n        }\n\n        if (c->tcp_nopush == NGX_TCP_NOPUSH_SET) {\n            if (ngx_tcp_push(c->fd) == -1) {\n                ngx_connection_error(c, ngx_socket_errno,\n                                     ngx_tcp_push_n \" failed\");\n                return NGX_ERROR;\n            }\n\n            c->tcp_nopush = NGX_TCP_NOPUSH_UNSET;\n            tcp_nodelay = ngx_tcp_nodelay_and_tcp_nopush ? 1 : 0;\n        } else {\n            tcp_nodelay = 1;\n        }\n\n        if (tcp_nodelay && cacf->tcp_nodelay && ngx_tcp_nodelay(c) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    return ngx_rtmp_send_ack_size(s, cscf->ack_window) != NGX_OK ||\n           ngx_rtmp_send_bandwidth(s, cscf->ack_window,\n                                   NGX_RTMP_LIMIT_DYNAMIC) != NGX_OK ||\n           ngx_rtmp_send_chunk_size(s, cscf->chunk_size) != NGX_OK ||\n           ngx_rtmp_send_amf(s, &h, out_elts,\n                             sizeof(out_elts) / sizeof(out_elts[0]))\n           != NGX_OK ? NGX_ERROR : NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_create_stream_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                                ngx_chain_t *in)\n{\n    static ngx_rtmp_create_stream_t     v;\n\n    static ngx_rtmp_amf_elt_t  in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, sizeof(v.trans) },\n    };\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0, \"createStream\");\n\n    return ngx_rtmp_create_stream(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_create_stream(ngx_rtmp_session_t *s, ngx_rtmp_create_stream_t *v)\n{\n    /* support one message stream per connection */\n    static double               stream;\n    static double               trans;\n    ngx_rtmp_header_t           h;\n\n    static ngx_rtmp_amf_elt_t  out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"_result\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &stream, sizeof(stream) },\n    };\n\n    trans = v->trans;\n    stream = NGX_RTMP_MSID;\n\n    ngx_memzero(&h, sizeof(h));\n\n    h.csid = NGX_RTMP_CSID_AMF_INI;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n    return ngx_rtmp_send_amf(s, &h, out_elts,\n                             sizeof(out_elts) / sizeof(out_elts[0])) == NGX_OK ?\n           NGX_DONE : NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_close_stream_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                               ngx_chain_t *in)\n{\n    static ngx_rtmp_close_stream_t     v;\n\n    static ngx_rtmp_amf_elt_t  in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.stream, 0 },\n    };\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0, \"closeStream\");\n\n    return ngx_rtmp_close_stream(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_close_stream(ngx_rtmp_session_t *s, ngx_rtmp_close_stream_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_delete_stream_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                                ngx_chain_t *in)\n{\n    static ngx_rtmp_delete_stream_t     v;\n\n    static ngx_rtmp_amf_elt_t  in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.stream, 0 },\n    };\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    return ngx_rtmp_delete_stream(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_delete_stream(ngx_rtmp_session_t *s, ngx_rtmp_delete_stream_t *v)\n{\n    ngx_rtmp_close_stream_t         cv;\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0, \"deleteStream\");\n\n    cv.stream = 0;\n\n    return ngx_rtmp_close_stream(s, &cv);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_publish_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    static ngx_rtmp_publish_t       v;\n\n    static ngx_rtmp_amf_elt_t      in_elts[] = {\n\n        /* transaction is always 0 */\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.name, sizeof(v.name) },\n\n        { NGX_RTMP_AMF_OPTIONAL | NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.type, sizeof(v.type) },\n    };\n\n    ngx_memzero(&v, sizeof(v));\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_cmd_fill_args(v.name, v.args);\n\n    if (ngx_strlen(v.name) == 0) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"publish: no stream name specified\");\n\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_process_request_line(s, v.name, v.args,\n            (const u_char *) \"publish\") != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"publish: name='%s' args='%s' type=%s silent=%d\",\n                  v.name, v.args, v.type, v.silent);\n\n    return ngx_rtmp_publish(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    return NGX_OK;\n}\n\nstatic ngx_int_t\nngx_rtmp_cmd_play_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    static ngx_rtmp_play_t          v;\n\n    static ngx_rtmp_amf_elt_t       in_elts[] = {\n\n        /* transaction is always 0 */\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.name, sizeof(v.name) },\n\n        { NGX_RTMP_AMF_OPTIONAL | NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.start, 0 },\n\n        { NGX_RTMP_AMF_OPTIONAL | NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.duration, 0 },\n\n        { NGX_RTMP_AMF_OPTIONAL | NGX_RTMP_AMF_BOOLEAN,\n          ngx_null_string,\n          &v.reset, 0 }\n    };\n\n    ngx_memzero(&v, sizeof(v));\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_cmd_fill_args(v.name, v.args);\n\n    if (ngx_strlen(v.name) == 0) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"play: no stream name specified\");\n\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_process_request_line(s, v.name, v.args,\n            (const u_char *) \"play\") != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"play: name='%s' args='%s' start=%i duration=%i \"\n                  \"reset=%i silent=%i\",\n                  v.name, v.args, (ngx_int_t) v.start,\n                  (ngx_int_t) v.duration, (ngx_int_t) v.reset,\n                  (ngx_int_t) v.silent);\n\n    return ngx_rtmp_play(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_add_timer(s->connection->write, s->timeout);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_play2_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    static ngx_rtmp_play_t          v;\n    static ngx_rtmp_close_stream_t  vc;\n\n    static ngx_rtmp_amf_elt_t       in_obj[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"start\"),\n          &v.start, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"streamName\"),\n          &v.name, sizeof(v.name) },\n    };\n\n    static ngx_rtmp_amf_elt_t       in_elts[] = {\n\n        /* transaction is always 0 */\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          &in_obj, sizeof(in_obj) }\n    };\n\n    ngx_memzero(&v, sizeof(v));\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_cmd_fill_args(v.name, v.args);\n\n    if (ngx_strlen(v.name) == 0) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"play2: no stream name specified\");\n        \n        return NGX_ERROR;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"play2: name='%s' args='%s' start=%i\",\n                  v.name, v.args, (ngx_int_t) v.start);\n\n    /* continue from current timestamp */\n\n    if (v.start < 0) {\n        v.start = s->current_time;\n    }\n\n    ngx_memzero(&vc, sizeof(vc));\n\n    /* close_stream should be synchronous */\n    ngx_rtmp_close_stream(s, &vc);\n\n    return ngx_rtmp_play(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_pause_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    static ngx_rtmp_pause_t     v;\n\n    static ngx_rtmp_amf_elt_t   in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_BOOLEAN,\n          ngx_null_string,\n          &v.pause, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.position, 0 },\n    };\n\n    ngx_memzero(&v, sizeof(v));\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"pause: pause=%i position=%i\",\n                    (ngx_int_t) v.pause, (ngx_int_t) v.position);\n\n    return ngx_rtmp_pause(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_pause(ngx_rtmp_session_t *s, ngx_rtmp_pause_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_disconnect_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                        ngx_chain_t *in)\n{\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0, \"disconnect\");\n\n    return ngx_rtmp_disconnect(s);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_disconnect(ngx_rtmp_session_t *s)\n{\n    return ngx_rtmp_delete_stream(s, NULL);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_seek_init(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    static ngx_rtmp_seek_t         v;\n\n    static ngx_rtmp_amf_elt_t      in_elts[] = {\n\n        /* transaction is always 0 */\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.offset, sizeof(v.offset) },\n    };\n\n    ngx_memzero(&v, sizeof(v));\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"seek: offset=%i\", (ngx_int_t) v.offset);\n\n    return ngx_rtmp_seek(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_seek(ngx_rtmp_session_t *s, ngx_rtmp_seek_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_stream_begin(ngx_rtmp_session_t *s, ngx_rtmp_stream_begin_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_stream_eof(ngx_rtmp_session_t *s, ngx_rtmp_stream_eof_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_stream_dry(ngx_rtmp_session_t *s, ngx_rtmp_stream_dry_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_recorded(ngx_rtmp_session_t *s,\n                      ngx_rtmp_recorded_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_set_buflen(ngx_rtmp_session_t *s, ngx_rtmp_set_buflen_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic ngx_rtmp_amf_handler_t ngx_rtmp_cmd_map[] = {\n    { ngx_string(\"connect\"),            ngx_rtmp_cmd_connect_init           },\n    { ngx_string(\"createStream\"),       ngx_rtmp_cmd_create_stream_init     },\n    { ngx_string(\"closeStream\"),        ngx_rtmp_cmd_close_stream_init      },\n    { ngx_string(\"deleteStream\"),       ngx_rtmp_cmd_delete_stream_init     },\n    { ngx_string(\"publish\"),            ngx_rtmp_cmd_publish_init           },\n    { ngx_string(\"play\"),               ngx_rtmp_cmd_play_init              },\n    { ngx_string(\"play2\"),              ngx_rtmp_cmd_play2_init             },\n    { ngx_string(\"seek\"),               ngx_rtmp_cmd_seek_init              },\n    { ngx_string(\"pause\"),              ngx_rtmp_cmd_pause_init             },\n    { ngx_string(\"pauseraw\"),           ngx_rtmp_cmd_pause_init             },\n};\n\n\nstatic ngx_int_t\nngx_rtmp_cmd_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n    ngx_rtmp_amf_handler_t             *ch, *bh;\n    size_t                              n, ncalls;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    /* redirect disconnects to deleteStream\n     * to free client modules from registering\n     * disconnect callback */\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_DISCONNECT]);\n    if (h == NULL) {\n        return NGX_ERROR;\n    }\n\n    *h = ngx_rtmp_cmd_disconnect_init;\n\n    /* register AMF callbacks */\n\n    ncalls = sizeof(ngx_rtmp_cmd_map) / sizeof(ngx_rtmp_cmd_map[0]);\n\n    ch = ngx_array_push_n(&cmcf->amf, ncalls);\n    if (ch == NULL) {\n        return NGX_ERROR;\n    }\n\n    bh = ngx_rtmp_cmd_map;\n\n    for(n = 0; n < ncalls; ++n, ++ch, ++bh) {\n        *ch = *bh;\n    }\n\n    ngx_rtmp_connect = ngx_rtmp_cmd_connect;\n    ngx_rtmp_disconnect = ngx_rtmp_cmd_disconnect;\n    ngx_rtmp_create_stream = ngx_rtmp_cmd_create_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_cmd_close_stream;\n    ngx_rtmp_delete_stream = ngx_rtmp_cmd_delete_stream;\n    ngx_rtmp_publish = ngx_rtmp_cmd_publish;\n    ngx_rtmp_play = ngx_rtmp_cmd_play;\n    ngx_rtmp_seek = ngx_rtmp_cmd_seek;\n    ngx_rtmp_pause = ngx_rtmp_cmd_pause;\n\n    ngx_rtmp_stream_begin = ngx_rtmp_cmd_stream_begin;\n    ngx_rtmp_stream_eof = ngx_rtmp_cmd_stream_eof;\n    ngx_rtmp_stream_dry = ngx_rtmp_cmd_stream_dry;\n    ngx_rtmp_recorded = ngx_rtmp_cmd_recorded;\n    ngx_rtmp_set_buflen = ngx_rtmp_cmd_set_buflen;\n\n    return NGX_OK;\n}\n\n"
        },
        {
          "name": "ngx_rtmp_cmd_module.h",
          "type": "blob",
          "size": 4.76953125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_CMD_H_INCLUDED_\n#define _NGX_RTMP_CMD_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include \"ngx_rtmp.h\"\n\n\n#define NGX_RTMP_MAX_NAME           256\n#define NGX_RTMP_MAX_URL            256\n#define NGX_RTMP_MAX_ARGS           NGX_RTMP_MAX_NAME\n\n\n/* Basic RTMP call support */\n\ntypedef struct {\n    double                          trans;\n    u_char                          app[NGX_RTMP_MAX_NAME];\n    u_char                          args[NGX_RTMP_MAX_ARGS];\n    u_char                          flashver[64];\n    u_char                          swf_url[NGX_RTMP_MAX_URL];\n    u_char                          tc_url[NGX_RTMP_MAX_URL];\n    double                          acodecs;\n    double                          vcodecs;\n    u_char                          page_url[NGX_RTMP_MAX_URL];\n    u_char                          server_name[NGX_RTMP_MAX_URL];\n    double                          object_encoding;\n} ngx_rtmp_connect_t;\n\n\ntypedef struct {\n    double                          trans;\n    double                          stream;\n} ngx_rtmp_create_stream_t;\n\n\ntypedef struct {\n    double                          stream;\n} ngx_rtmp_delete_stream_t;\n\n\ntypedef struct {\n    double                          stream;\n} ngx_rtmp_close_stream_t;\n\n\ntypedef struct {\n    u_char                          name[NGX_RTMP_MAX_NAME];\n    u_char                          args[NGX_RTMP_MAX_ARGS];\n    u_char                          type[16];\n    int                             silent;\n} ngx_rtmp_publish_t;\n\n\ntypedef struct {\n    u_char                          name[NGX_RTMP_MAX_NAME];\n    u_char                          args[NGX_RTMP_MAX_ARGS];\n    double                          start;\n    double                          duration;\n    int                             reset;\n    int                             silent;\n} ngx_rtmp_play_t;\n\n\ntypedef struct {\n    double                          offset;\n} ngx_rtmp_seek_t;\n\n\ntypedef struct {\n    uint8_t                         pause;\n    double                          position;\n} ngx_rtmp_pause_t;\n\n\ntypedef struct {\n    uint32_t                        msid;\n} ngx_rtmp_msid_t;\n\n\ntypedef ngx_rtmp_msid_t             ngx_rtmp_stream_begin_t;\ntypedef ngx_rtmp_msid_t             ngx_rtmp_stream_eof_t;\ntypedef ngx_rtmp_msid_t             ngx_rtmp_stream_dry_t;\ntypedef ngx_rtmp_msid_t             ngx_rtmp_recorded_t;\n\n\ntypedef struct {\n    uint32_t                        msid;\n    uint32_t                        buflen;\n} ngx_rtmp_set_buflen_t;\n\n\nvoid ngx_rtmp_cmd_fill_args(u_char name[NGX_RTMP_MAX_NAME],\n        u_char args[NGX_RTMP_MAX_ARGS]);\n\n\ntypedef ngx_int_t (*ngx_rtmp_connect_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_connect_t *v);\ntypedef ngx_int_t (*ngx_rtmp_disconnect_pt)(ngx_rtmp_session_t *s);\ntypedef ngx_int_t (*ngx_rtmp_create_stream_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_create_stream_t *v);\ntypedef ngx_int_t (*ngx_rtmp_close_stream_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_close_stream_t *v);\ntypedef ngx_int_t (*ngx_rtmp_delete_stream_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_delete_stream_t *v);\ntypedef ngx_int_t (*ngx_rtmp_publish_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_publish_t *v);\ntypedef ngx_int_t (*ngx_rtmp_play_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_play_t *v);\ntypedef ngx_int_t (*ngx_rtmp_seek_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_seek_t *v);\ntypedef ngx_int_t (*ngx_rtmp_pause_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_pause_t *v);\n\ntypedef ngx_int_t (*ngx_rtmp_stream_begin_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_stream_begin_t *v);\ntypedef ngx_int_t (*ngx_rtmp_stream_eof_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_stream_eof_t *v);\ntypedef ngx_int_t (*ngx_rtmp_stream_dry_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_stream_dry_t *v);\ntypedef ngx_int_t (*ngx_rtmp_recorded_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_recorded_t *v);\ntypedef ngx_int_t (*ngx_rtmp_set_buflen_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_set_buflen_t *v);\n\n\nextern ngx_rtmp_connect_pt          ngx_rtmp_connect;\nextern ngx_rtmp_disconnect_pt       ngx_rtmp_disconnect;\nextern ngx_rtmp_create_stream_pt    ngx_rtmp_create_stream;\nextern ngx_rtmp_close_stream_pt     ngx_rtmp_close_stream;\nextern ngx_rtmp_delete_stream_pt    ngx_rtmp_delete_stream;\nextern ngx_rtmp_publish_pt          ngx_rtmp_publish;\nextern ngx_rtmp_play_pt             ngx_rtmp_play;\nextern ngx_rtmp_seek_pt             ngx_rtmp_seek;\nextern ngx_rtmp_pause_pt            ngx_rtmp_pause;\n\nextern ngx_rtmp_stream_begin_pt     ngx_rtmp_stream_begin;\nextern ngx_rtmp_stream_eof_pt       ngx_rtmp_stream_eof;\nextern ngx_rtmp_stream_dry_pt       ngx_rtmp_stream_dry;\nextern ngx_rtmp_set_buflen_pt       ngx_rtmp_set_buflen;\nextern ngx_rtmp_recorded_pt         ngx_rtmp_recorded;\n\n\n#endif /*_NGX_RTMP_CMD_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_codec_module.c",
          "type": "blob",
          "size": 27.431640625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_codec_module.h\"\n#include \"ngx_rtmp_live_module.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_bitop.h\"\n\n\n#define NGX_RTMP_CODEC_META_OFF     0\n#define NGX_RTMP_CODEC_META_ON      1\n#define NGX_RTMP_CODEC_META_COPY    2\n\n\nstatic void * ngx_rtmp_codec_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_codec_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\nstatic ngx_int_t ngx_rtmp_codec_postconfiguration(ngx_conf_t *cf);\nstatic ngx_int_t ngx_rtmp_codec_reconstruct_meta(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_codec_copy_meta(ngx_rtmp_session_t *s,\n       ngx_rtmp_header_t *h, ngx_chain_t *in);\nstatic ngx_int_t ngx_rtmp_codec_prepare_meta(ngx_rtmp_session_t *s,\n       uint32_t timestamp);\nstatic ngx_int_t ngx_rtmp_codec_parse_aac_header(ngx_rtmp_session_t *s,\n       ngx_chain_t *in);\nstatic ngx_int_t ngx_rtmp_codec_parse_avc_header(ngx_rtmp_session_t *s,\n       ngx_chain_t *in);\n#if (NGX_DEBUG)\nstatic void ngx_rtmp_codec_dump_header(ngx_rtmp_session_t *s, const char *type,\n       ngx_chain_t *in);\n#endif\n\n\ntypedef struct {\n    ngx_uint_t                      meta;\n} ngx_rtmp_codec_app_conf_t;\n\n\nstatic ngx_conf_enum_t ngx_rtmp_codec_meta_slots[] = {\n    { ngx_string(\"off\"),            NGX_RTMP_CODEC_META_OFF  },\n    { ngx_string(\"on\"),             NGX_RTMP_CODEC_META_ON   },\n    { ngx_string(\"copy\"),           NGX_RTMP_CODEC_META_COPY },\n    { ngx_null_string,              0 }\n};\n\n\nstatic ngx_command_t  ngx_rtmp_codec_commands[] = {\n\n    { ngx_string(\"meta\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_enum_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_codec_app_conf_t, meta),\n      &ngx_rtmp_codec_meta_slots },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_codec_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_codec_postconfiguration,       /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_codec_create_app_conf,         /* create app configuration */\n    ngx_rtmp_codec_merge_app_conf           /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_codec_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_codec_module_ctx,             /* module context */\n    ngx_rtmp_codec_commands,                /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic const char *\naudio_codecs[] = {\n    \"\",\n    \"ADPCM\",\n    \"MP3\",\n    \"LinearLE\",\n    \"Nellymoser16\",\n    \"Nellymoser8\",\n    \"Nellymoser\",\n    \"G711A\",\n    \"G711U\",\n    \"\",\n    \"AAC\",\n    \"Speex\",\n    \"\",\n    \"\",\n    \"MP3-8K\",\n    \"DeviceSpecific\",\n    \"Uncompressed\"\n};\n\n\nstatic const char *\nvideo_codecs[] = {\n    \"\",\n    \"Jpeg\",\n    \"Sorenson-H263\",\n    \"ScreenVideo\",\n    \"On2-VP6\",\n    \"On2-VP6-Alpha\",\n    \"ScreenVideo2\",\n    \"H264\",\n};\n\n\nu_char *\nngx_rtmp_get_audio_codec_name(ngx_uint_t id)\n{\n    return (u_char *)(id < sizeof(audio_codecs) / sizeof(audio_codecs[0])\n        ? audio_codecs[id]\n        : \"\");\n}\n\n\nu_char *\nngx_rtmp_get_video_codec_name(ngx_uint_t id)\n{\n    return (u_char *)(id < sizeof(video_codecs) / sizeof(video_codecs[0])\n        ? video_codecs[id]\n        : \"\");\n}\n\n\nstatic ngx_uint_t\nngx_rtmp_codec_get_next_version()\n{\n    ngx_uint_t          v;\n    static ngx_uint_t   version;\n\n    do {\n        v = ++version;\n    } while (v == 0);\n\n    return v;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_disconnect(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_codec_ctx_t               *ctx;\n    ngx_rtmp_core_srv_conf_t           *cscf;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (ctx->avc_header) {\n        ngx_rtmp_free_shared_chain(cscf, ctx->avc_header);\n        ctx->avc_header = NULL;\n    }\n\n    if (ctx->aac_header) {\n        ngx_rtmp_free_shared_chain(cscf, ctx->aac_header);\n        ctx->aac_header = NULL;\n    }\n\n    if (ctx->meta) {\n        ngx_rtmp_free_shared_chain(cscf, ctx->meta);\n        ctx->meta = NULL;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_av(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t           *cscf;\n    ngx_rtmp_codec_ctx_t               *ctx;\n    ngx_chain_t                       **header;\n    uint8_t                             fmt;\n    static ngx_uint_t                   sample_rates[] =\n                                        { 5512, 11025, 22050, 44100 };\n\n    if (h->type != NGX_RTMP_MSG_AUDIO && h->type != NGX_RTMP_MSG_VIDEO) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_codec_ctx_t));\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_codec_module);\n    }\n\n    /* save codec */\n    if (in->buf->last - in->buf->pos < 1) {\n        return NGX_OK;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    fmt =  in->buf->pos[0];\n    if (h->type == NGX_RTMP_MSG_AUDIO) {\n        ctx->audio_codec_id = (fmt & 0xf0) >> 4;\n        ctx->audio_channels = (fmt & 0x01) + 1;\n        ctx->sample_size = (fmt & 0x02) ? 2 : 1;\n\n        if (ctx->sample_rate == 0) {\n            ctx->sample_rate = sample_rates[(fmt & 0x0c) >> 2];\n        }\n\n    } else {\n        ctx->video_codec_id = (fmt & 0x0f);\n    }\n\n    /* save AVC/AAC header */\n    if (in->buf->last - in->buf->pos < 3) {\n        return NGX_OK;\n    }\n\n    /* PacketType = 0, FLV TAG MUST be sequence header */\n    /* PacketType = 1, FLV TAG MAY be AVC NALU or AAC Raw */\n    if (!ngx_rtmp_is_codec_header(in)) {\n        return NGX_OK;\n    }\n\n    header = NULL;\n\n    /* MUST be audio / video sequence header */\n    if (h->type == NGX_RTMP_MSG_AUDIO) {\n        if (ctx->audio_codec_id == NGX_RTMP_AUDIO_AAC) {\n            header = &ctx->aac_header;\n            if (ngx_rtmp_codec_parse_aac_header(s, in) == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n        }\n    } else {\n        if (ctx->video_codec_id == NGX_RTMP_VIDEO_H264) {\n            header = &ctx->avc_header;\n            if (ngx_rtmp_codec_parse_avc_header(s, in) == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    if (header == NULL) {\n        return NGX_OK;\n    }\n\n    if (*header) {\n        ngx_rtmp_free_shared_chain(cscf, *header);\n    }\n\n    *header = ngx_rtmp_append_shared_bufs(cscf, NULL, in);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_parse_aac_header(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_uint_t              idx;\n    ngx_rtmp_codec_ctx_t   *ctx;\n    ngx_rtmp_bit_reader_t   br;\n\n    static ngx_uint_t      aac_sample_rates[] =\n        { 96000, 88200, 64000, 48000,\n          44100, 32000, 24000, 22050,\n          16000, 12000, 11025,  8000,\n           7350,     0,     0,     0 };\n\n#if (NGX_DEBUG)\n    ngx_rtmp_codec_dump_header(s, \"aac\", in);\n#endif\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n\n    if (in->buf->last - in->buf->pos < 4) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"codec: invalid audio codec header size=%ui\",\n                      in->buf->last - in->buf->pos);\n\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_bit_init_reader(&br, in->buf->pos, in->buf->last);\n\n    ngx_rtmp_bit_read(&br, 16);\n\n    ctx->aac_profile = (ngx_uint_t) ngx_rtmp_bit_read(&br, 5);\n    if (ctx->aac_profile == 31) {\n        ctx->aac_profile = (ngx_uint_t) ngx_rtmp_bit_read(&br, 6) + 32;\n    }\n\n    idx = (ngx_uint_t) ngx_rtmp_bit_read(&br, 4);\n    if (idx == 15) {\n        ctx->sample_rate = (ngx_uint_t) ngx_rtmp_bit_read(&br, 24);\n    } else {\n        ctx->sample_rate = aac_sample_rates[idx];\n    }\n\n    ctx->aac_chan_conf = (ngx_uint_t) ngx_rtmp_bit_read(&br, 4);\n\n    if (ctx->aac_profile == 5 || ctx->aac_profile == 29) {\n        \n        if (ctx->aac_profile == 29) {\n            ctx->aac_ps = 1;\n        }\n\n        ctx->aac_sbr = 1;\n\n        idx = (ngx_uint_t) ngx_rtmp_bit_read(&br, 4);\n        if (idx == 15) {\n            ctx->sample_rate = (ngx_uint_t) ngx_rtmp_bit_read(&br, 24);\n        } else {\n            ctx->sample_rate = aac_sample_rates[idx];\n        }\n\n        ctx->aac_profile = (ngx_uint_t) ngx_rtmp_bit_read(&br, 5);\n        if (ctx->aac_profile == 31) {\n            ctx->aac_profile = (ngx_uint_t) ngx_rtmp_bit_read(&br, 6) + 32;\n        }\n    }\n\n    /* MPEG-4 Audio Specific Config\n\n       5 bits: object type\n       if (object type == 31)\n         6 bits + 32: object type\n       4 bits: frequency index\n       if (frequency index == 15)\n         24 bits: frequency\n       4 bits: channel configuration\n\n       if (object_type == 5)\n           4 bits: frequency index\n           if (frequency index == 15)\n             24 bits: frequency\n           5 bits: object type\n           if (object type == 31)\n             6 bits + 32: object type\n             \n       var bits: AOT Specific Config\n     */\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"codec: aac header profile=%ui, \"\n                   \"sample_rate=%ui, chan_conf=%ui\",\n                   ctx->aac_profile, ctx->sample_rate, ctx->aac_chan_conf);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_parse_avc_header(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_uint_t              avc_config_version;\n    ngx_uint_t              profile_idc, width, height, crop_left, crop_right,\n                            crop_top, crop_bottom, frame_mbs_only, n, cf_idc,\n                            num_ref_frames;\n    ngx_rtmp_codec_ctx_t   *ctx;\n    ngx_rtmp_bit_reader_t   br;\n\n#if (NGX_DEBUG)\n    ngx_rtmp_codec_dump_header(s, \"avc\", in);\n#endif\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n\n    if (in->buf->last - in->buf->pos < 18) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"codec: invalid video codec header size=%ui\",\n                      in->buf->last - in->buf->pos);\n\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_bit_init_reader(&br, in->buf->pos, in->buf->last);\n\n    ngx_rtmp_bit_read(&br, 40);\n\n    avc_config_version = (ngx_uint_t) ngx_rtmp_bit_read_8(&br);\n    if (avc_config_version == 0) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"codec: zero configurationVersion\");\n\n        return NGX_ERROR;\n    }\n\n    ctx->avc_profile = (ngx_uint_t) ngx_rtmp_bit_read_8(&br);\n    ctx->avc_compat = (ngx_uint_t) ngx_rtmp_bit_read_8(&br);\n    ctx->avc_level = (ngx_uint_t) ngx_rtmp_bit_read_8(&br);\n\n    /* nal bytes */\n    ctx->avc_nal_bytes = (ngx_uint_t) ((ngx_rtmp_bit_read_8(&br) & 0x03) + 1);\n    if (ctx->avc_nal_bytes != 3 && ctx->avc_nal_bytes != 4) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"codec: invalid lengthSizeMinusOne value=%ui\",\n                      ctx->avc_nal_bytes - 1);\n\n        return NGX_ERROR;\n    }\n\n    /* nnals */\n    if ((ngx_rtmp_bit_read_8(&br) & 0x1f) == 0) {\n        return NGX_ERROR;\n    }\n\n    /* nal size */\n    ngx_rtmp_bit_read(&br, 16);\n\n    /* nal type */\n    if (ngx_rtmp_bit_read_8(&br) != 0x67) {\n        return NGX_OK;\n    }\n\n    /* SPS */\n\n    /* profile idc */\n    profile_idc = (ngx_uint_t) ngx_rtmp_bit_read(&br, 8);\n\n    /* flags */\n    ngx_rtmp_bit_read(&br, 8);\n\n    /* level idc */\n    ngx_rtmp_bit_read(&br, 8);\n\n    /* SPS id */\n    ngx_rtmp_bit_read_golomb(&br);\n\n    if (profile_idc == 100 || profile_idc == 110 ||\n        profile_idc == 122 || profile_idc == 244 || profile_idc == 44 ||\n        profile_idc == 83 || profile_idc == 86 || profile_idc == 118)\n    {\n        /* chroma format idc */\n        cf_idc = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n        \n        if (cf_idc == 3) {\n\n            /* separate color plane */\n            ngx_rtmp_bit_read(&br, 1);\n        }\n\n        /* bit depth luma - 8 */\n        ngx_rtmp_bit_read_golomb(&br);\n\n        /* bit depth chroma - 8 */\n        ngx_rtmp_bit_read_golomb(&br);\n\n        /* qpprime y zero transform bypass */\n        ngx_rtmp_bit_read(&br, 1);\n\n        /* seq scaling matrix present */\n        if (ngx_rtmp_bit_read(&br, 1)) {\n\n            for (n = 0; n < (cf_idc != 3 ? 8u : 12u); n++) {\n\n                /* seq scaling list present */\n                if (ngx_rtmp_bit_read(&br, 1)) {\n\n                    /* TODO: scaling_list()\n                    if (n < 6) {\n                    } else {\n                    }\n                    */\n                }\n            }\n        }\n    }\n\n    /* log2 max frame num */\n    ngx_rtmp_bit_read_golomb(&br);\n\n    /* pic order cnt type */\n    switch (ngx_rtmp_bit_read_golomb(&br)) {\n    case 0:\n\n        /* max pic order cnt */\n        ngx_rtmp_bit_read_golomb(&br);\n        break;\n\n    case 1:\n\n        /* delta pic order alwys zero */\n        ngx_rtmp_bit_read(&br, 1);\n\n        /* offset for non-ref pic */\n        ngx_rtmp_bit_read_golomb(&br);\n\n        /* offset for top to bottom field */\n        ngx_rtmp_bit_read_golomb(&br);\n\n        /* num ref frames in pic order */\n        num_ref_frames = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n\n        for (n = 0; n < num_ref_frames; n++) {\n\n            /* offset for ref frame */\n            ngx_rtmp_bit_read_golomb(&br);\n        }\n    }\n\n    /* num ref frames */\n    ctx->avc_ref_frames = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n\n    /* gaps in frame num allowed */\n    ngx_rtmp_bit_read(&br, 1);\n\n    /* pic width in mbs - 1 */\n    width = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n\n    /* pic height in map units - 1 */\n    height = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n\n    /* frame mbs only flag */\n    frame_mbs_only = (ngx_uint_t) ngx_rtmp_bit_read(&br, 1);\n\n    if (!frame_mbs_only) {\n\n        /* mbs adaprive frame field */\n        ngx_rtmp_bit_read(&br, 1);\n    }\n\n    /* direct 8x8 inference flag */\n    ngx_rtmp_bit_read(&br, 1);\n\n    /* frame cropping */\n    if (ngx_rtmp_bit_read(&br, 1)) {\n\n        crop_left = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n        crop_right = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n        crop_top = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n        crop_bottom = (ngx_uint_t) ngx_rtmp_bit_read_golomb(&br);\n\n    } else {\n\n        crop_left = 0;\n        crop_right = 0;\n        crop_top = 0;\n        crop_bottom = 0;\n    }\n\n    ctx->width = (width + 1) * 16 - (crop_left + crop_right) * 2;\n    ctx->height = (2 - frame_mbs_only) * (height + 1) * 16 -\n                  (crop_top + crop_bottom) * 2;\n\n    ngx_log_debug7(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"codec: avc header \"\n                   \"profile=%ui, compat=%ui, level=%ui, \"\n                   \"nal_bytes=%ui, ref_frames=%ui, width=%ui, height=%ui\",\n                   ctx->avc_profile, ctx->avc_compat, ctx->avc_level,\n                   ctx->avc_nal_bytes, ctx->avc_ref_frames,\n                   ctx->width, ctx->height);\n\n    return NGX_OK;\n}\n\n\n#if (NGX_DEBUG)\nstatic void\nngx_rtmp_codec_dump_header(ngx_rtmp_session_t *s, const char *type,\n    ngx_chain_t *in)\n{\n    u_char buf[256], *p, *pp;\n    u_char hex[] = \"0123456789abcdef\";\n\n    for (pp = buf, p = in->buf->pos;\n         p < in->buf->last && pp < buf + sizeof(buf) - 2;\n         ++p)\n    {\n        *pp++ = hex[*p >> 4];\n        *pp++ = hex[*p & 0x0f];\n    }\n\n    *pp = 0;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"codec: %s header %s\", type, buf);\n}\n#endif\n\n\nstatic ngx_int_t\nngx_rtmp_codec_reconstruct_meta(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_codec_ctx_t           *ctx;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_int_t                       rc;\n\n    static struct {\n        double                      width;\n        double                      height;\n        double                      duration;\n        double                      frame_rate;\n        double                      video_data_rate;\n        double                      video_codec_id;\n        double                      audio_data_rate;\n        double                      audio_codec_id;\n        u_char                      profile[32];\n        u_char                      level[32];\n    }                               v;\n\n    static ngx_rtmp_amf_elt_t       out_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"Server\"),\n          \"NGINX HTTP-FLV (https://github.com/winshining/nginx-http-flv-module)\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"width\"),\n          &v.width, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"height\"),\n          &v.height, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"displayWidth\"),\n          &v.width, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"displayHeight\"),\n          &v.height, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"duration\"),\n          &v.duration, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"framerate\"),\n          &v.frame_rate, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"fps\"),\n          &v.frame_rate, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"videodatarate\"),\n          &v.video_data_rate, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"videocodecid\"),\n          &v.video_codec_id, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audiodatarate\"),\n          &v.audio_data_rate, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audiocodecid\"),\n          &v.audio_codec_id, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"profile\"),\n          &v.profile, sizeof(v.profile) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          &v.level, sizeof(v.level) },\n    };\n\n    static ngx_rtmp_amf_elt_t       out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onMetaData\", 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf, sizeof(out_inf) },\n    };\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (ctx->meta) {\n        ngx_rtmp_free_shared_chain(cscf, ctx->meta);\n        ctx->meta = NULL;\n    }\n\n    v.width = ctx->width;\n    v.height = ctx->height;\n    v.duration = ctx->duration;\n    v.frame_rate = ctx->frame_rate;\n    v.video_data_rate = ctx->video_data_rate;\n    v.video_codec_id = ctx->video_codec_id;\n    v.audio_data_rate = ctx->audio_data_rate;\n    v.audio_codec_id = ctx->audio_codec_id;\n    ngx_memcpy(v.profile, ctx->profile, sizeof(ctx->profile));\n    ngx_memcpy(v.level, ctx->level, sizeof(ctx->level));\n\n    rc = ngx_rtmp_append_amf(s, &ctx->meta, NULL, out_elts,\n                             sizeof(out_elts) / sizeof(out_elts[0]));\n    if (rc != NGX_OK || ctx->meta == NULL) {\n        return NGX_ERROR;\n    }\n\n    return ngx_rtmp_codec_prepare_meta(s, 0);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_copy_meta(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_codec_ctx_t      *ctx;\n    ngx_rtmp_core_srv_conf_t  *cscf;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (ctx->meta) {\n        ngx_rtmp_free_shared_chain(cscf, ctx->meta);\n    }\n\n    ctx->meta = ngx_rtmp_append_shared_bufs(cscf, NULL, in);\n\n    if (ctx->meta == NULL) {\n        return NGX_ERROR;\n    }\n\n    return ngx_rtmp_codec_prepare_meta(s, h->timestamp);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_prepare_meta(ngx_rtmp_session_t *s, uint32_t timestamp)\n{\n    ngx_rtmp_header_t      h;\n    ngx_rtmp_codec_ctx_t  *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n    h.type = NGX_RTMP_MSG_AMF_META;\n    h.timestamp = timestamp;\n    ngx_rtmp_prepare_message(s, &h, NULL, ctx->meta);\n\n    ctx->meta_version = ngx_rtmp_codec_get_next_version();\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_meta_data(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    uint16_t                        len;\n    ngx_uint_t                      skip;\n    u_char                         *p;\n    ngx_rtmp_codec_app_conf_t      *cacf;\n    ngx_rtmp_codec_ctx_t           *ctx;\n\n    static struct {\n        double                      width;\n        double                      height;\n        double                      duration;\n        double                      frame_rate;\n        double                      video_data_rate;\n        double                      video_codec_id_n;\n        u_char                      video_codec_id_s[32];\n        double                      audio_data_rate;\n        double                      audio_codec_id_n;\n        u_char                      audio_codec_id_s[32];\n        u_char                      profile[32];\n        u_char                      level[32];\n    }                               v;\n\n    static ngx_rtmp_amf_elt_t       in_video_codec_id[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.video_codec_id_n, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.video_codec_id_s, sizeof(v.video_codec_id_s) },\n    };\n\n    static ngx_rtmp_amf_elt_t       in_audio_codec_id[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.audio_codec_id_n, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.audio_codec_id_s, sizeof(v.audio_codec_id_s) },\n    };\n\n    static ngx_rtmp_amf_elt_t       in_inf[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"width\"),\n          &v.width, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"height\"),\n          &v.height, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"duration\"),\n          &v.duration, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"framerate\"),\n          &v.frame_rate, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"fps\"),\n          &v.frame_rate, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"videodatarate\"),\n          &v.video_data_rate, 0 },\n\n        { NGX_RTMP_AMF_VARIANT,\n          ngx_string(\"videocodecid\"),\n          in_video_codec_id, sizeof(in_video_codec_id) },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audiodatarate\"),\n          &v.audio_data_rate, 0 },\n\n        { NGX_RTMP_AMF_VARIANT,\n          ngx_string(\"audiocodecid\"),\n          in_audio_codec_id, sizeof(in_audio_codec_id) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"profile\"),\n          &v.profile, sizeof(v.profile) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          &v.level, sizeof(v.level) },\n    };\n\n    static ngx_rtmp_amf_elt_t       in_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_inf, sizeof(in_inf) },\n    };\n\n    cacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_codec_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_codec_ctx_t));\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_codec_module);\n    }\n\n    ngx_memzero(&v, sizeof(v));\n\n    /* use -1 as a sign of unchanged data;\n     * 0 is a valid value for uncompressed audio */\n    v.audio_codec_id_n = -1;\n\n    if (in->buf->last > in->buf->pos\n        && in->buf->pos - in->buf->start >= 13\n        && in->buf->pos[-13] == NGX_RTMP_AMF_STRING)\n    {\n        p = (u_char *) &len;\n\n        *p++ = in->buf->pos[-11];\n        *p++ = in->buf->pos[-12];\n\n        if (ngx_strncasecmp(in->buf->pos - 10,\n                            (u_char *) \"onMetaData\", len) == 0)\n        {\n            in->buf->pos -= 13;\n        }\n    }\n\n    /* FFmpeg sends a string in front of actual metadata; ignore it */\n    skip = !(in->buf->last > in->buf->pos\n            && *in->buf->pos == NGX_RTMP_AMF_STRING);\n    if (ngx_rtmp_receive_amf(s, in, in_elts + skip,\n                sizeof(in_elts) / sizeof(in_elts[0]) - skip))\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                \"codec: error parsing data frame\");\n        return NGX_OK;\n    }\n\n    ctx->width = (ngx_uint_t) v.width;\n    ctx->height = (ngx_uint_t) v.height;\n    ctx->duration = v.duration;\n    ctx->frame_rate = v.frame_rate;\n    ctx->video_data_rate = v.video_data_rate;\n    ctx->video_codec_id = (ngx_uint_t) v.video_codec_id_n;\n    ctx->audio_data_rate = v.audio_data_rate;\n    ctx->audio_codec_id = (v.audio_codec_id_n == -1\n            ? 0 : v.audio_codec_id_n == 0\n            ? NGX_RTMP_AUDIO_UNCOMPRESSED : (ngx_uint_t) v.audio_codec_id_n);\n    ngx_memcpy(ctx->profile, v.profile, sizeof(v.profile));\n    ngx_memcpy(ctx->level, v.level, sizeof(v.level));\n\n    ngx_log_debug8(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"codec: data frame: \"\n            \"width=%ui height=%ui duration=%.3f frame_rate=%.3f \"\n            \"video=%s (%ui) audio=%s (%ui)\",\n            ctx->width, ctx->height, ctx->duration, ctx->frame_rate,\n            ngx_rtmp_get_video_codec_name(ctx->video_codec_id),\n            ctx->video_codec_id,\n            ngx_rtmp_get_audio_codec_name(ctx->audio_codec_id),\n            ctx->audio_codec_id);\n\n    switch (cacf->meta) {\n        case NGX_RTMP_CODEC_META_ON:\n            return ngx_rtmp_codec_reconstruct_meta(s);\n        case NGX_RTMP_CODEC_META_COPY:\n            return ngx_rtmp_codec_copy_meta(s, h, in);\n    }\n\n    /* NGX_RTMP_CODEC_META_OFF */\n\n    return NGX_OK;\n}\n\n\nstatic void *\nngx_rtmp_codec_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_codec_app_conf_t  *cacf;\n\n    cacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_codec_app_conf_t));\n    if (cacf == NULL) {\n        return NULL;\n    }\n\n    cacf->meta = NGX_CONF_UNSET_UINT;\n\n    return cacf;\n}\n\n\nstatic char *\nngx_rtmp_codec_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_codec_app_conf_t *prev = parent;\n    ngx_rtmp_codec_app_conf_t *conf = child;\n\n    ngx_conf_merge_uint_value(conf->meta, prev->meta, NGX_RTMP_CODEC_META_ON);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_codec_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n    ngx_rtmp_amf_handler_t             *ch;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_AUDIO]);\n    *h = ngx_rtmp_codec_av;\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_VIDEO]);\n    *h = ngx_rtmp_codec_av;\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_DISCONNECT]);\n    *h = ngx_rtmp_codec_disconnect;\n\n    /* register metadata handler */\n    ch = ngx_array_push(&cmcf->amf);\n    if (ch == NULL) {\n        return NGX_ERROR;\n    }\n    ngx_str_set(&ch->name, \"@setDataFrame\");\n    ch->handler = ngx_rtmp_codec_meta_data;\n\n    ch = ngx_array_push(&cmcf->amf);\n    if (ch == NULL) {\n        return NGX_ERROR;\n    }\n    ngx_str_set(&ch->name, \"onMetaData\");\n    ch->handler = ngx_rtmp_codec_meta_data;\n\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_codec_module.h",
          "type": "blob",
          "size": 3.484375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#ifndef _NGX_RTMP_CODEC_H_INCLUDED_\n#define _NGX_RTMP_CODEC_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\n/* AVC NAL unit types */\nenum {\n    NGX_RTMP_NALU_SLICE             = 1,\n    NGX_RTMP_NALU_DPA               = 2,\n    NGX_RTMP_NALU_DPB               = 3,\n    NGX_RTMP_NALU_DPC               = 4,\n    NGX_RTMP_NALU_IDR               = 5,\n    NGX_RTMP_NALU_SEI               = 6,\n    NGX_RTMP_NALU_SPS               = 7,\n    NGX_RTMP_NALU_PPS               = 8,\n    NGX_RTMP_NALU_AUD               = 9,\n    NGX_RTMP_NALU_EOSEQ             = 10,\n    NGX_RTMP_NALU_EOSTREAM          = 11,\n    NGX_RTMP_NALU_FILL              = 12,\n    NGX_RTMP_NALU_SPS_EXT           = 13,\n    NGX_RTMP_NALU_AUXILIARY_SLICE   = 19\n};\n\n\n/* AVC frame types */\nenum {\n    NGX_RTMP_FRAME_IDR              = 1,\n    NGX_RTMP_FRAME_INTER            = 2,\n    NGX_RTMP_FRAME_DISPOSABLE       = 3,\n    NGX_RTMP_FRAME_GENERATED        = 4,\n    NGX_RTMP_FRAME_VIDEOINFOCMD     = 5\n};\n\n\n/* Audio codecs */\nenum {\n    /* Uncompressed codec id is actually 0,\n     * but we use another value for consistency */\n    NGX_RTMP_AUDIO_UNCOMPRESSED     = 16,\n    NGX_RTMP_AUDIO_ADPCM            = 1,\n    NGX_RTMP_AUDIO_MP3              = 2,\n    NGX_RTMP_AUDIO_LINEAR_LE        = 3,\n    NGX_RTMP_AUDIO_NELLY16          = 4,\n    NGX_RTMP_AUDIO_NELLY8           = 5,\n    NGX_RTMP_AUDIO_NELLY            = 6,\n    NGX_RTMP_AUDIO_G711A            = 7,\n    NGX_RTMP_AUDIO_G711U            = 8,\n    NGX_RTMP_AUDIO_AAC              = 10,\n    NGX_RTMP_AUDIO_SPEEX            = 11,\n    NGX_RTMP_AUDIO_MP3_8            = 14,\n    NGX_RTMP_AUDIO_DEVSPEC          = 15\n};\n\n\n/* Video codecs */\nenum {\n    NGX_RTMP_VIDEO_JPEG             = 1,\n    NGX_RTMP_VIDEO_SORENSON_H263    = 2,\n    NGX_RTMP_VIDEO_SCREEN           = 3,\n    NGX_RTMP_VIDEO_ON2_VP6          = 4,\n    NGX_RTMP_VIDEO_ON2_VP6_ALPHA    = 5,\n    NGX_RTMP_VIDEO_SCREEN2          = 6,\n    NGX_RTMP_VIDEO_H264             = 7\n};\n\n\nu_char * ngx_rtmp_get_audio_codec_name(ngx_uint_t id);\nu_char * ngx_rtmp_get_video_codec_name(ngx_uint_t id);\n\n\n#define NGX_RTMP_SPS_MAX_LENGTH            256\n\ntypedef struct {\n    ngx_uint_t                  width;\n    ngx_uint_t                  height;\n    double                      duration;\n    double                      frame_rate;\n    double                      video_data_rate;\n    ngx_uint_t                  video_codec_id;\n    double                      audio_data_rate;\n    ngx_uint_t                  audio_codec_id;\n    ngx_uint_t                  aac_profile;\n    ngx_uint_t                  aac_chan_conf;\n    ngx_uint_t                  aac_sbr;\n    ngx_uint_t                  aac_ps;\n    ngx_uint_t                  avc_profile;\n    ngx_uint_t                  avc_compat;\n    ngx_uint_t                  avc_level;\n    ngx_uint_t                  avc_nal_bytes;\n    ngx_uint_t                  avc_ref_frames;\n    ngx_uint_t                  sample_rate;    /* 5512, 11025, 22050, 44100 */\n    ngx_uint_t                  sample_size;    /* 1=8bit, 2=16bit */\n    ngx_uint_t                  audio_channels; /* 1, 2 */\n    u_char                      profile[32];\n    u_char                      level[32];\n\n    ngx_chain_t                *avc_header;\n    ngx_chain_t                *aac_header;\n\n    ngx_chain_t                *meta;\n    ngx_uint_t                  meta_version;\n} ngx_rtmp_codec_ctx_t;\n\n\nextern ngx_module_t  ngx_rtmp_codec_module;\n\n\n#endif /* _NGX_RTMP_LIVE_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_control_module.c",
          "type": "blob",
          "size": 18.4130859375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_live_module.h\"\n#include \"ngx_rtmp_record_module.h\"\n\n\nstatic char *ngx_rtmp_control(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic void * ngx_rtmp_control_create_loc_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_control_merge_loc_conf(ngx_conf_t *cf,\n    void *parent, void *child);\n\n\ntypedef const char * (*ngx_rtmp_control_handler_t)(ngx_http_request_t *r,\n    ngx_rtmp_session_t *);\n\n\n#define NGX_RTMP_CONTROL_ALL        0xff\n#define NGX_RTMP_CONTROL_RECORD     0x01\n#define NGX_RTMP_CONTROL_DROP       0x02\n#define NGX_RTMP_CONTROL_REDIRECT   0x04\n\n\nenum {\n    NGX_RTMP_CONTROL_FILTER_CLIENT = 0,\n    NGX_RTMP_CONTROL_FILTER_PUBLISHER,\n    NGX_RTMP_CONTROL_FILTER_SUBSCRIBER\n};\n\n\ntypedef struct {\n    ngx_uint_t                      count;\n    ngx_str_t                       path;\n    ngx_uint_t                      filter;\n    ngx_str_t                       method;\n    ngx_array_t                     sessions; /* ngx_rtmp_session_t * */\n} ngx_rtmp_control_ctx_t;\n\n\ntypedef struct {\n    ngx_uint_t                      control;\n} ngx_rtmp_control_loc_conf_t;\n\n\nstatic ngx_conf_bitmask_t           ngx_rtmp_control_masks[] = {\n    { ngx_string(\"all\"),            NGX_RTMP_CONTROL_ALL       },\n    { ngx_string(\"record\"),         NGX_RTMP_CONTROL_RECORD    },\n    { ngx_string(\"drop\"),           NGX_RTMP_CONTROL_DROP      },\n    { ngx_string(\"redirect\"),       NGX_RTMP_CONTROL_REDIRECT  },\n    { ngx_null_string,              0                          }\n};\n\n\nstatic ngx_command_t  ngx_rtmp_control_commands[] = {\n\n    { ngx_string(\"rtmp_control\"),\n      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_control,\n      NGX_HTTP_LOC_CONF_OFFSET,\n      offsetof(ngx_rtmp_control_loc_conf_t, control),\n      ngx_rtmp_control_masks },\n\n    ngx_null_command\n};\n\n\nstatic ngx_http_module_t  ngx_rtmp_control_module_ctx = {\n    NULL,                               /* preconfiguration */\n    NULL,                               /* postconfiguration */\n\n    NULL,                               /* create main configuration */\n    NULL,                               /* init main configuration */\n\n    NULL,                               /* create server configuration */\n    NULL,                               /* merge server configuration */\n\n    ngx_rtmp_control_create_loc_conf,   /* create location configuration */\n    ngx_rtmp_control_merge_loc_conf,    /* merge location configuration */\n};\n\n\nngx_module_t  ngx_rtmp_control_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_control_module_ctx,       /* module context */\n    ngx_rtmp_control_commands,          /* module directives */\n    NGX_HTTP_MODULE,                    /* module type */\n    NULL,                               /* init master */\n    NULL,                               /* init module */\n    NULL,                               /* init process */\n    NULL,                               /* init thread */\n    NULL,                               /* exit thread */\n    NULL,                               /* exit process */\n    NULL,                               /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic const char *\nngx_rtmp_control_record_handler(ngx_http_request_t *r, ngx_rtmp_session_t *s)\n{\n    ngx_int_t                    rc;\n    ngx_str_t                    rec;\n    ngx_uint_t                   rn;\n    ngx_rtmp_control_ctx_t      *ctx;\n    ngx_rtmp_core_app_conf_t    *cacf;\n    ngx_rtmp_record_app_conf_t  *racf;\n\n    cacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_core_module);\n    racf = cacf->app_conf[ngx_rtmp_record_module.ctx_index];\n\n    if (ngx_http_arg(r, (u_char *) \"rec\", sizeof(\"rec\") - 1, &rec) != NGX_OK) {\n        rec.len = 0;\n    }\n\n    rn = ngx_rtmp_record_find(racf, &rec);\n    if (rn == NGX_CONF_UNSET_UINT) {\n        return \"Recorder not found\";\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n\n    if (ctx->method.len == sizeof(\"start\") - 1 &&\n        ngx_strncmp(ctx->method.data, \"start\", ctx->method.len) == 0)\n    {\n        rc = ngx_rtmp_record_open(s, rn, &ctx->path);\n\n    } else if (ctx->method.len == sizeof(\"stop\") - 1 &&\n               ngx_strncmp(ctx->method.data, \"stop\", ctx->method.len) == 0)\n    {\n        rc = ngx_rtmp_record_close(s, rn, &ctx->path);\n\n    } else {\n        return \"Undefined method\";\n    }\n\n    if (rc == NGX_ERROR) {\n        return \"Recorder error\";\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_drop_handler(ngx_http_request_t *r, ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_control_ctx_t  *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n\n    ngx_rtmp_finalize_session(s);\n\n    ++ctx->count;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_redirect_handler(ngx_http_request_t *r, ngx_rtmp_session_t *s)\n{\n    ngx_str_t                 name;\n    ngx_rtmp_play_t           vplay;\n    ngx_rtmp_publish_t        vpublish;\n    ngx_rtmp_live_ctx_t      *lctx;\n    ngx_rtmp_control_ctx_t   *ctx;\n    ngx_rtmp_close_stream_t   vc;\n\n    if (ngx_http_arg(r, (u_char *) \"newname\", sizeof(\"newname\") - 1, &name)\n        != NGX_OK)\n    {\n        return \"newname not specified\";\n    }\n\n    if (name.len >= NGX_RTMP_MAX_NAME) {\n        name.len = NGX_RTMP_MAX_NAME - 1;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n    ctx->count++;\n\n    ngx_memzero(&vc, sizeof(ngx_rtmp_close_stream_t));\n\n    /* close_stream should be synchronous */\n    ngx_rtmp_close_stream(s, &vc);\n\n    lctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n\n    if (lctx && lctx->publishing) {\n        /* publish */\n\n        ngx_memzero(&vpublish, sizeof(ngx_rtmp_publish_t));\n\n        ngx_memcpy(vpublish.name, name.data, name.len);\n\n        ngx_rtmp_cmd_fill_args(vpublish.name, vpublish.args);\n\n        if (ngx_rtmp_publish(s, &vpublish) != NGX_OK) {\n            return \"publish failed\";\n        }\n\n    } else {\n        /* play */\n\n        ngx_memzero(&vplay, sizeof(ngx_rtmp_play_t));\n\n        ngx_memcpy(vplay.name, name.data, name.len);\n\n        ngx_rtmp_cmd_fill_args(vplay.name, vplay.args);\n\n        if (ngx_rtmp_play(s, &vplay) != NGX_OK) {\n            return \"play failed\";\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_walk_session(ngx_http_request_t *r,\n    ngx_rtmp_live_ctx_t *lctx)\n{\n    ngx_str_t                addr, *paddr, clientid;\n    ngx_rtmp_session_t      *s, **ss;\n    ngx_rtmp_control_ctx_t  *ctx;\n\n    s = lctx->session;\n\n    if (s == NULL || s->connection == NULL) {\n        return NGX_CONF_OK;\n    }\n\n    if (ngx_http_arg(r, (u_char *) \"addr\", sizeof(\"addr\") - 1, &addr)\n        == NGX_OK)\n    {\n        paddr = &s->connection->addr_text;\n        if (paddr->len != addr.len ||\n            ngx_strncmp(paddr->data, addr.data, addr.len))\n        {\n            return NGX_CONF_OK;\n        }\n    }\n\n    if (ngx_http_arg(r, (u_char *) \"clientid\", sizeof(\"clientid\") - 1,\n                     &clientid)\n        == NGX_OK)\n    {\n        if (s->connection->number !=\n            (ngx_uint_t) ngx_atoi(clientid.data, clientid.len))\n        {\n            return NGX_CONF_OK;\n        }\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n\n    switch (ctx->filter) {\n        case NGX_RTMP_CONTROL_FILTER_PUBLISHER:\n            if (!lctx->publishing) {\n                return NGX_CONF_OK;\n            }\n            break;\n\n        case NGX_RTMP_CONTROL_FILTER_SUBSCRIBER:\n            if (lctx->publishing) {\n                return NGX_CONF_OK;\n            }\n            break;\n\n        case NGX_RTMP_CONTROL_FILTER_CLIENT:\n            break;\n    }\n\n    ss = ngx_array_push(&ctx->sessions);\n    if (ss == NULL) {\n        return \"allocation error\";\n    }\n\n    *ss = s;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_walk_stream(ngx_http_request_t *r,\n    ngx_rtmp_live_stream_t *ls)\n{\n    const char           *s;\n    ngx_rtmp_live_ctx_t  *lctx;\n\n    for (lctx = ls->ctx; lctx; lctx = lctx->next) {\n        s = ngx_rtmp_control_walk_session(r, lctx);\n        if (s != NGX_CONF_OK) {\n            return s;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_walk_app(ngx_http_request_t *r,\n    ngx_rtmp_core_app_conf_t *cacf)\n{\n    size_t                     len;\n    ngx_str_t                  name;\n    const char                *s;\n    ngx_uint_t                 n;\n    ngx_rtmp_live_stream_t    *ls;\n    ngx_rtmp_live_app_conf_t  *lacf;\n\n    lacf = cacf->app_conf[ngx_rtmp_live_module.ctx_index];\n\n    if (ngx_http_arg(r, (u_char *) \"name\", sizeof(\"name\") - 1, &name) != NGX_OK)\n    {\n        for (n = 0; n < (ngx_uint_t) lacf->nbuckets; ++n) {\n            for (ls = lacf->streams[n]; ls; ls = ls->next) {\n                s = ngx_rtmp_control_walk_stream(r, ls);\n                if (s != NGX_CONF_OK) {\n                    return s;\n                }\n            }\n        }\n\n        return NGX_CONF_OK;\n    }\n\n    for (ls = lacf->streams[ngx_hash_key(name.data, name.len) % lacf->nbuckets];\n         ls; ls = ls->next) \n    {\n        len = ngx_strlen(ls->name);\n        if (name.len != len || ngx_strncmp(name.data, ls->name, name.len)) {\n            continue;\n        }\n\n        s = ngx_rtmp_control_walk_stream(r, ls);\n        if (s != NGX_CONF_OK) {\n            return s;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_walk_server(ngx_http_request_t *r,\n    ngx_rtmp_core_srv_conf_t *cscf)\n{\n    ngx_str_t                   app;\n    ngx_uint_t                  n;\n    const char                 *s;\n    ngx_rtmp_core_app_conf_t  **pcacf;\n\n    if (ngx_http_arg(r, (u_char *) \"app\", sizeof(\"app\") - 1, &app) != NGX_OK) {\n        app.len = 0;\n    }\n\n    pcacf = cscf->applications.elts;\n\n    for (n = 0; n < cscf->applications.nelts; ++n, ++pcacf) {\n        if (app.len && ((*pcacf)->name.len != app.len ||\n                        ngx_strncmp((*pcacf)->name.data, app.data, app.len)))\n        {\n            continue;\n        }\n\n        s = ngx_rtmp_control_walk_app(r, *pcacf);\n        if (s != NGX_CONF_OK) {\n            return s;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic const char *\nngx_rtmp_control_walk(ngx_http_request_t *r, ngx_rtmp_control_handler_t h)\n{\n    ngx_rtmp_core_main_conf_t  *cmcf = ngx_rtmp_core_main_conf;\n\n    ngx_str_t                   srv;\n    ngx_uint_t                  sn, n;\n    const char                 *msg;\n    ngx_rtmp_session_t        **s;\n    ngx_rtmp_control_ctx_t     *ctx;\n    ngx_rtmp_core_srv_conf_t  **pcscf;\n\n    sn = 0;\n    if (ngx_http_arg(r, (u_char *) \"srv\", sizeof(\"srv\") - 1, &srv) == NGX_OK) {\n        sn = ngx_atoi(srv.data, srv.len);\n    }\n\n    if (sn >= cmcf->servers.nelts) {\n        return \"Server index out of range\";\n    }\n\n    pcscf  = cmcf->servers.elts;\n    pcscf += sn;\n\n    msg = ngx_rtmp_control_walk_server(r, *pcscf);\n    if (msg != NGX_CONF_OK) {\n        return msg;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n\n    s = ctx->sessions.elts;\n    for (n = 0; n < ctx->sessions.nelts; n++) {\n        msg = h(r, s[n]);\n        if (msg != NGX_CONF_OK) {\n            return msg;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_control_record(ngx_http_request_t *r, ngx_str_t *method)\n{\n    ngx_buf_t               *b;\n    const char              *msg;\n    ngx_chain_t              cl;\n    ngx_rtmp_control_ctx_t  *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n    ctx->filter = NGX_RTMP_CONTROL_FILTER_PUBLISHER;\n\n    msg = ngx_rtmp_control_walk(r, ngx_rtmp_control_record_handler);\n    if (msg != NGX_CONF_OK) {\n        goto error;\n    }\n\n    if (ctx->path.len == 0) {\n        return NGX_HTTP_NO_CONTENT;\n    }\n\n    /* output record path */\n\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = ctx->path.len;\n\n    b = ngx_create_temp_buf(r->pool, ctx->path.len);\n    if (b == NULL) {\n        goto error;\n    }\n\n    ngx_memzero(&cl, sizeof(cl));\n    cl.buf = b;\n\n    b->last = ngx_cpymem(b->pos, ctx->path.data, ctx->path.len);\n    b->last_buf = 1;\n\n    ngx_http_send_header(r);\n\n    return ngx_http_output_filter(r, &cl);\n\nerror:\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_control_drop(ngx_http_request_t *r, ngx_str_t *method)\n{\n    size_t                   len;\n    u_char                  *p;\n    ngx_buf_t               *b;\n    ngx_chain_t              cl;\n    const char              *msg;\n    ngx_rtmp_control_ctx_t  *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n\n    if (ctx->method.len == sizeof(\"publisher\") - 1 &&\n        ngx_memcmp(ctx->method.data, \"publisher\", ctx->method.len) == 0)\n    {\n        ctx->filter = NGX_RTMP_CONTROL_FILTER_PUBLISHER;\n\n    } else if (ctx->method.len == sizeof(\"subscriber\") - 1 &&\n               ngx_memcmp(ctx->method.data, \"subscriber\", ctx->method.len)\n               == 0)\n    {\n        ctx->filter = NGX_RTMP_CONTROL_FILTER_SUBSCRIBER;\n\n    } else if (method->len == sizeof(\"client\") - 1 &&\n               ngx_memcmp(ctx->method.data, \"client\", ctx->method.len) == 0)\n    {\n        ctx->filter = NGX_RTMP_CONTROL_FILTER_CLIENT;\n\n    } else {\n        msg = \"Undefined filter\";\n        goto error;\n    }\n\n    msg = ngx_rtmp_control_walk(r, ngx_rtmp_control_drop_handler);\n    if (msg != NGX_CONF_OK) {\n        goto error;\n    }\n\n    /* output count */\n\n    len = NGX_INT_T_LEN;\n\n    p = ngx_palloc(r->connection->pool, len);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    len = (size_t) (ngx_snprintf(p, len, \"%ui\", ctx->count) - p);\n\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = len;\n\n    b = ngx_calloc_buf(r->pool);\n    if (b == NULL) {\n        goto error;\n    }\n\n    b->start = b->pos = p;\n    b->end = b->last = p + len;\n    b->temporary = 1;\n    b->last_buf = 1;\n\n    ngx_memzero(&cl, sizeof(cl));\n    cl.buf = b;\n\n    ngx_http_send_header(r);\n\n    return ngx_http_output_filter(r, &cl);\n\nerror:\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_control_redirect(ngx_http_request_t *r, ngx_str_t *method)\n{\n    size_t                   len;\n    u_char                  *p;\n    ngx_buf_t               *b;\n    ngx_chain_t              cl;\n    const char              *msg;\n    ngx_rtmp_control_ctx_t  *ctx;\n\n    ctx = ngx_http_get_module_ctx(r, ngx_rtmp_control_module);\n\n    if (ctx->method.len == sizeof(\"publisher\") - 1 &&\n        ngx_memcmp(ctx->method.data, \"publisher\", ctx->method.len) == 0)\n    {\n        ctx->filter = NGX_RTMP_CONTROL_FILTER_PUBLISHER;\n\n    } else if (ctx->method.len == sizeof(\"subscriber\") - 1 &&\n               ngx_memcmp(ctx->method.data, \"subscriber\", ctx->method.len)\n               == 0)\n    {\n        ctx->filter = NGX_RTMP_CONTROL_FILTER_SUBSCRIBER;\n\n    } else if (ctx->method.len == sizeof(\"client\") - 1 &&\n               ngx_memcmp(ctx->method.data, \"client\", ctx->method.len) == 0)\n    {\n        ctx->filter = NGX_RTMP_CONTROL_FILTER_CLIENT;\n\n    } else {\n        msg = \"Undefined filter\";\n        goto error;\n    }\n\n    msg = ngx_rtmp_control_walk(r, ngx_rtmp_control_redirect_handler);\n    if (msg != NGX_CONF_OK) {\n        goto error;\n    }\n\n    /* output count */\n\n    len = NGX_INT_T_LEN;\n\n    p = ngx_palloc(r->connection->pool, len);\n    if (p == NULL) {\n        goto error;\n    }\n\n    len = (size_t) (ngx_snprintf(p, len, \"%ui\", ctx->count) - p);\n\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = len;\n\n    b = ngx_calloc_buf(r->pool);\n    if (b == NULL) {\n        goto error;\n    }\n\n    b->start = b->pos = p;\n    b->end = b->last = p + len;\n    b->temporary = 1;\n    b->last_buf = 1;\n\n    ngx_memzero(&cl, sizeof(cl));\n    cl.buf = b;\n\n    ngx_http_send_header(r);\n\n    return ngx_http_output_filter(r, &cl);\n\nerror:\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_control_handler(ngx_http_request_t *r)\n{\n    u_char                       *p;\n    ngx_str_t                     section, method;\n    ngx_uint_t                    n;\n    ngx_rtmp_control_ctx_t       *ctx;\n    ngx_rtmp_control_loc_conf_t  *llcf;\n\n    llcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_control_module);\n    if (llcf->control == 0) {\n        return NGX_DECLINED;\n    }\n\n    /* uri format: .../section/method?args */\n\n    ngx_str_null(&section);\n    ngx_str_null(&method);\n\n    for (n = r->uri.len; n; --n) {\n        p = &r->uri.data[n - 1];\n\n        if (*p != '/') {\n            continue;\n        }\n\n        if (method.data) {\n            section.data = p + 1;\n            section.len  = method.data - section.data - 1;\n            break;\n        }\n\n        method.data = p + 1;\n        method.len  = r->uri.data + r->uri.len - method.data;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, r->connection->log, 0,\n                   \"rtmp_control: section='%V' method='%V'\",\n                   &section, &method);\n\n    ctx = ngx_pcalloc(r->pool, sizeof(ngx_rtmp_control_ctx_t));\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_http_set_ctx(r, ctx, ngx_rtmp_control_module);\n\n    if (ngx_array_init(&ctx->sessions, r->pool, 1, sizeof(void *)) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ctx->method = method;\n\n#define NGX_RTMP_CONTROL_SECTION(flag, secname)                             \\\n    if (llcf->control & NGX_RTMP_CONTROL_##flag &&                          \\\n        section.len == sizeof(#secname) - 1 &&                              \\\n        ngx_strncmp(section.data, #secname, sizeof(#secname) - 1) == 0)     \\\n    {                                                                       \\\n        return ngx_rtmp_control_##secname(r, &method);                      \\\n    }\n\n    NGX_RTMP_CONTROL_SECTION(RECORD, record);\n    NGX_RTMP_CONTROL_SECTION(DROP, drop);\n    NGX_RTMP_CONTROL_SECTION(REDIRECT, redirect);\n\n#undef NGX_RTMP_CONTROL_SECTION\n\n    return NGX_DECLINED;\n}\n\n\nstatic void *\nngx_rtmp_control_create_loc_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_control_loc_conf_t  *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_control_loc_conf_t));\n    if (conf == NULL) {\n        return NULL;\n    }\n\n    conf->control = 0;\n\n    return conf;\n}\n\n\nstatic char *\nngx_rtmp_control_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_control_loc_conf_t  *prev = parent;\n    ngx_rtmp_control_loc_conf_t  *conf = child;\n\n    ngx_conf_merge_bitmask_value(conf->control, prev->control, 0);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_control(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_http_core_loc_conf_t  *clcf;\n\n    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n    clcf->handler = ngx_rtmp_control_handler;\n\n    return ngx_conf_set_bitmask_slot(cf, cmd, conf);\n}\n"
        },
        {
          "name": "ngx_rtmp_core_module.c",
          "type": "blob",
          "size": 42.2138671875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <nginx.h>\n#include \"ngx_rtmp.h\"\n\n\nstatic ngx_int_t ngx_rtmp_core_preconfiguration(ngx_conf_t *cf);\nstatic void *ngx_rtmp_core_create_main_conf(ngx_conf_t *cf);\nstatic char *ngx_rtmp_core_init_main_conf(ngx_conf_t *cf, void *conf);\nstatic void *ngx_rtmp_core_create_srv_conf(ngx_conf_t *cf);\nstatic char *ngx_rtmp_core_merge_srv_conf(ngx_conf_t *cf, void *parent,\n    void *child);\nstatic void *ngx_rtmp_core_create_app_conf(ngx_conf_t *cf);\nstatic char *ngx_rtmp_core_merge_app_conf(ngx_conf_t *cf, void *parent,\n    void *child);\nstatic char *ngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic ngx_int_t ngx_rtmp_add_listen(ngx_conf_t *cf,\n    ngx_rtmp_core_srv_conf_t *cscf, ngx_rtmp_listen_opt_t *lsopt);\nstatic ngx_int_t ngx_rtmp_add_addresses(ngx_conf_t *cf,\n    ngx_rtmp_core_srv_conf_t *cscf, ngx_rtmp_conf_port_t *port,\n    ngx_rtmp_listen_opt_t *lsopt);\nstatic ngx_int_t ngx_rtmp_add_address(ngx_conf_t *cf,\n    ngx_rtmp_core_srv_conf_t *cscf, ngx_rtmp_conf_port_t *port,\n    ngx_rtmp_listen_opt_t *lsopt);\nstatic ngx_int_t ngx_rtmp_add_server(ngx_conf_t *cf,\n    ngx_rtmp_core_srv_conf_t *cscf, ngx_rtmp_conf_addr_t *addr);\n\nstatic char *ngx_rtmp_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_rtmp_core_application(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_rtmp_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\n\nstatic char *ngx_rtmp_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_rtmp_core_lowat_check(ngx_conf_t *cf, void *post, void *data);\nstatic char *ngx_rtmp_core_pool_size(ngx_conf_t *cf, void *post, void *data);\n\n\nstatic ngx_conf_post_t  ngx_rtmp_core_lowat_post =\n    { ngx_rtmp_core_lowat_check };\n\nstatic ngx_conf_post_handler_pt  ngx_rtmp_core_pool_size_p =\n    ngx_rtmp_core_pool_size;\n\nngx_rtmp_core_main_conf_t      *ngx_rtmp_core_main_conf;\n\n\nstatic ngx_conf_deprecated_t  ngx_conf_deprecated_so_keepalive = {\n    ngx_conf_deprecated, \"so_keepalive\",\n    \"so_keepalive\\\" parameter of the \\\"listen\"\n};\n\n\nstatic ngx_command_t  ngx_rtmp_core_commands[] = {\n\n    { ngx_string(\"server\"),\n      NGX_RTMP_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,\n      ngx_rtmp_core_server,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"listen\"),\n      NGX_RTMP_SRV_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_core_listen,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"server_name\"),\n      NGX_RTMP_SRV_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_core_server_name,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"application\"),\n      NGX_RTMP_SRV_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE1,\n      ngx_rtmp_core_application,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"so_keepalive\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, so_keepalive),\n      &ngx_conf_deprecated_so_keepalive },\n\n    { ngx_string(\"timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, timeout),\n      NULL },\n\n    { ngx_string(\"ping\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, ping),\n      NULL },\n\n    { ngx_string(\"ping_timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, ping_timeout),\n      NULL },\n\n    { ngx_string(\"max_streams\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, max_streams),\n      NULL },\n\n    { ngx_string(\"ack_window\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, ack_window),\n      NULL },\n\n    { ngx_string(\"chunk_size\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, chunk_size),\n      NULL },\n\n    { ngx_string(\"max_message\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, max_message),\n      NULL },\n\n    { ngx_string(\"out_queue\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, out_queue),\n      NULL },\n\n    { ngx_string(\"out_cork\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, out_cork),\n      NULL },\n\n    { ngx_string(\"busy\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, busy),\n      NULL },\n\n    /* time fixes are needed for flash clients */\n    { ngx_string(\"play_time_fix\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, play_time_fix),\n      NULL },\n\n    { ngx_string(\"publish_time_fix\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, publish_time_fix),\n      NULL },\n\n    { ngx_string(\"buflen\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, buflen),\n      NULL },\n\n    { ngx_string(\"tcp_nopush\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_app_conf_t, tcp_nopush),\n      NULL },\n\n    { ngx_string(\"tcp_nodelay\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_app_conf_t, tcp_nodelay),\n      NULL },\n\n    { ngx_string(\"send_timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_app_conf_t, send_timeout),\n      NULL },\n\n    { ngx_string(\"send_lowat\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_app_conf_t, send_lowat),\n      &ngx_rtmp_core_lowat_post },\n\n    { ngx_string(\"resolver\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_core_resolver,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"resolver_timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_app_conf_t, resolver_timeout),\n      NULL },\n\n    { ngx_string(\"connection_pool_size\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, connection_pool_size),\n      &ngx_rtmp_core_pool_size_p },\n\n    { ngx_string(\"merge_slashes\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_core_srv_conf_t, merge_slashes),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_core_module_ctx = {\n    ngx_rtmp_core_preconfiguration,         /* preconfiguration */\n    NULL,                                   /* postconfiguration */\n    ngx_rtmp_core_create_main_conf,         /* create main configuration */\n    ngx_rtmp_core_init_main_conf,           /* init main configuration */\n    ngx_rtmp_core_create_srv_conf,          /* create server configuration */\n    ngx_rtmp_core_merge_srv_conf,           /* merge server configuration */\n    ngx_rtmp_core_create_app_conf,          /* create app configuration */\n    ngx_rtmp_core_merge_app_conf            /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_core_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_core_module_ctx,             /* module context */\n    ngx_rtmp_core_commands,                /* module directives */\n    NGX_RTMP_MODULE,                       /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_int_t\nngx_rtmp_core_preconfiguration(ngx_conf_t *cf)\n{\n\treturn ngx_rtmp_variables_add_core_vars(cf);\n}\n\n\nstatic void *\nngx_rtmp_core_create_main_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_core_main_conf_t));\n    if (cmcf == NULL) {\n        return NULL;\n    }\n\n    ngx_rtmp_core_main_conf = cmcf;\n\n    if (ngx_array_init(&cmcf->servers, cf->pool, 4,\n                       sizeof(ngx_rtmp_core_srv_conf_t *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    cmcf->server_names_hash_max_size = NGX_CONF_UNSET_UINT;\n    cmcf->server_names_hash_bucket_size = NGX_CONF_UNSET_UINT;\n\n    cmcf->variables_hash_max_size = NGX_CONF_UNSET_UINT;\n    cmcf->variables_hash_bucket_size = NGX_CONF_UNSET_UINT;\n\n    return cmcf;\n}\n\n\nstatic char *\nngx_rtmp_core_init_main_conf(ngx_conf_t *cf, void *conf)\n{\n    ngx_rtmp_core_main_conf_t *cmcf = conf;\n\n    ngx_conf_init_uint_value(cmcf->server_names_hash_max_size, 512);\n    ngx_conf_init_uint_value(cmcf->server_names_hash_bucket_size,\n                             ngx_cacheline_size);\n\n    cmcf->server_names_hash_bucket_size =\n            ngx_align(cmcf->server_names_hash_bucket_size, ngx_cacheline_size);\n\n    ngx_conf_init_uint_value(cmcf->variables_hash_max_size, 1024);\n    ngx_conf_init_uint_value(cmcf->variables_hash_bucket_size, 64);\n\n    cmcf->variables_hash_bucket_size =\n            ngx_align(cmcf->variables_hash_bucket_size, ngx_cacheline_size);\n\n    if (cmcf->ncaptures) {\n        cmcf->ncaptures = (cmcf->ncaptures + 1) * 3;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic void *\nngx_rtmp_core_create_srv_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_srv_conf_t   *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_core_srv_conf_t));\n    if (conf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&conf->server_names, cf->temp_pool, 4,\n                       sizeof(ngx_rtmp_server_name_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    if (ngx_array_init(&conf->applications, cf->pool, 4,\n                       sizeof(ngx_rtmp_core_app_conf_t *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    conf->timeout = NGX_CONF_UNSET_MSEC;\n    conf->ping = NGX_CONF_UNSET_MSEC;\n    conf->ping_timeout = NGX_CONF_UNSET_MSEC;\n    conf->so_keepalive = NGX_CONF_UNSET;\n    conf->max_streams = NGX_CONF_UNSET;\n    conf->chunk_size = NGX_CONF_UNSET;\n    conf->ack_window = NGX_CONF_UNSET_UINT;\n    conf->max_message = NGX_CONF_UNSET_SIZE;\n    conf->out_queue = NGX_CONF_UNSET_SIZE;\n    conf->out_cork = NGX_CONF_UNSET_SIZE;\n    conf->play_time_fix = NGX_CONF_UNSET;\n    conf->publish_time_fix = NGX_CONF_UNSET;\n    conf->buflen = NGX_CONF_UNSET_MSEC;\n    conf->busy = NGX_CONF_UNSET;\n    conf->connection_pool_size = NGX_CONF_UNSET_SIZE;\n    conf->merge_slashes = NGX_CONF_UNSET;\n\n    return conf;\n}\n\n\nstatic void\nngx_rtmp_core_free_pool_cleanup(void *data)\n{\n    ngx_rtmp_core_srv_conf_t *conf = data;\n\n    if (conf->pool != NULL) {\n        ngx_destroy_pool(conf->pool);\n        conf->pool = NULL;\n    }\n}\n\n\nstatic char *\nngx_rtmp_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_core_srv_conf_t *prev = parent;\n    ngx_rtmp_core_srv_conf_t *conf = child;\n\n    ngx_str_t                 name;\n    ngx_pool_cleanup_t       *cln;\n    ngx_rtmp_server_name_t   *sn;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n    ngx_conf_merge_msec_value(conf->ping, prev->ping, 60000);\n    ngx_conf_merge_msec_value(conf->ping_timeout, prev->ping_timeout, 30000);\n\n    ngx_conf_merge_value(conf->so_keepalive, prev->so_keepalive, 0);\n    ngx_conf_merge_value(conf->max_streams, prev->max_streams, 32);\n    ngx_conf_merge_value(conf->chunk_size, prev->chunk_size,\n                         NGX_RTMP_DEFAULT_CHUNK_SIZE);\n    ngx_conf_merge_uint_value(conf->ack_window, prev->ack_window, 5000000);\n    ngx_conf_merge_size_value(conf->max_message, prev->max_message,\n            1 * 1024 * 1024);\n    ngx_conf_merge_size_value(conf->out_queue, prev->out_queue, 256);\n    ngx_conf_merge_size_value(conf->out_cork, prev->out_cork,\n            conf->out_queue / 8);\n    ngx_conf_merge_value(conf->play_time_fix, prev->play_time_fix, 1);\n    ngx_conf_merge_value(conf->publish_time_fix, prev->publish_time_fix, 1);\n    ngx_conf_merge_msec_value(conf->buflen, prev->buflen, 1000);\n    ngx_conf_merge_value(conf->busy, prev->busy, 0);\n    ngx_conf_merge_size_value(conf->connection_pool_size,\n                              prev->connection_pool_size, 64 * sizeof(void *));\n    ngx_conf_merge_value(conf->merge_slashes, prev->merge_slashes, 1);\n\n    if (prev->pool == NULL) {\n        prev->pool = ngx_create_pool(4096, &cf->cycle->new_log);\n        if (prev->pool == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        cln = ngx_pool_cleanup_add(cf->pool, 0);\n        if (cln == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        cln->handler = ngx_rtmp_core_free_pool_cleanup;\n        cln->data = conf;\n    }\n\n    conf->pool = prev->pool;\n\n    if (conf->server_names.nelts == 0) {\n        /* the array has 4 empty preallocated elements, so push cannot fail */\n        sn = ngx_array_push(&conf->server_names);\n#if (NGX_PCRE)\n        sn->regex = NULL;\n#endif\n        sn->server = conf;\n        ngx_str_set(&sn->name, \"\");\n    }\n\n    sn = conf->server_names.elts;\n    name = sn[0].name;\n\n#if (NGX_PCRE)\n    if (sn->regex) {\n        name.len++;\n        name.data--;\n    } else\n#endif\n\n    if (name.data[0] == '.') {\n        name.len--;\n        name.data++;\n    }\n\n    conf->server_name.len = name.len;\n    conf->server_name.data = ngx_pstrdup(cf->pool, &name);\n    if (conf->server_name.data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic void *\nngx_rtmp_core_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_app_conf_t   *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_core_app_conf_t));\n    if (conf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&conf->applications, cf->pool, 1,\n                       sizeof(ngx_rtmp_core_app_conf_t *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    conf->tcp_nopush = NGX_CONF_UNSET;\n    conf->tcp_nodelay = NGX_CONF_UNSET;\n    conf->send_timeout = NGX_CONF_UNSET_MSEC;\n    conf->send_lowat = NGX_CONF_UNSET_SIZE;\n    conf->resolver_timeout = NGX_CONF_UNSET_MSEC;\n\n    return conf;\n}\n\n\nstatic char *\nngx_rtmp_core_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_core_app_conf_t *prev = parent;\n    ngx_rtmp_core_app_conf_t *conf = child;\n\n    ngx_conf_merge_value(conf->tcp_nopush, prev->tcp_nopush, 0);\n    ngx_conf_merge_value(conf->tcp_nodelay, prev->tcp_nodelay, 1);\n\n    ngx_conf_merge_msec_value(conf->send_timeout, prev->send_timeout, 60000);\n    ngx_conf_merge_size_value(conf->send_lowat, prev->send_lowat, 0);\n\n    ngx_conf_merge_msec_value(conf->resolver_timeout,\n                              prev->resolver_timeout, 30000);\n\n    if (conf->resolver == NULL) {\n\n        if (prev->resolver == NULL) {\n\n            /*\n             * create dummy resolver in rtmp {} context\n             * to inherit it in all servers\n             */\n\n            prev->resolver = ngx_resolver_create(cf, NULL, 0);\n            if (prev->resolver == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        conf->resolver = prev->resolver;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                       *rv;\n    void                       *mconf;\n    ngx_uint_t                  m;\n    ngx_conf_t                  pcf;\n    ngx_module_t              **modules;\n    ngx_rtmp_module_t          *module;\n    struct sockaddr_in         *sin;\n    ngx_rtmp_conf_ctx_t        *ctx, *rtmp_ctx;\n    ngx_rtmp_listen_opt_t       lsopt;\n    ngx_rtmp_core_srv_conf_t   *cscf, **cscfp;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    rtmp_ctx = cf->ctx;\n    ctx->main_conf = rtmp_ctx->main_conf;\n\n    /* the server{}'s srv_conf */\n\n    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n#if (nginx_version >= 1009011)\n    modules = cf->cycle->modules;\n#else\n    modules = ngx_modules;\n#endif\n\n    for (m = 0; modules[m]; m++) {\n        if (modules[m]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[m]->ctx;\n\n        if (module->create_srv_conf) {\n            mconf = module->create_srv_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->srv_conf[modules[m]->ctx_index] = mconf;\n        }\n\n        if (module->create_app_conf) {\n            mconf = module->create_app_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->app_conf[modules[m]->ctx_index] = mconf;\n        }\n    }\n\n    /* the server configuration context */\n\n    cscf = ctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n    cscf->ctx = ctx;\n\n    cmcf = ctx->main_conf[ngx_rtmp_core_module.ctx_index];\n\n    cscfp = ngx_array_push(&cmcf->servers);\n    if (cscfp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *cscfp = cscf;\n\n\n    /* parse inside server{} */\n\n    pcf = *cf;\n    cf->ctx = ctx;\n    cf->cmd_type = NGX_RTMP_SRV_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf = pcf;\n\n    if (rv == NGX_CONF_OK && !cscf->listen) {\n        ngx_memzero(&lsopt, sizeof(ngx_rtmp_listen_opt_t));\n\n        sin = &lsopt.sockaddr.sockaddr_in;\n\n        sin->sin_family = AF_INET;\n        sin->sin_port = htons(1935);\n        sin->sin_addr.s_addr = INADDR_ANY;\n\n        lsopt.socklen = sizeof(struct sockaddr_in);\n\n        lsopt.backlog = NGX_LISTEN_BACKLOG;\n        lsopt.rcvbuf = -1;\n        lsopt.sndbuf = -1;\n#if (NGX_HAVE_SETFIB)\n        lsopt.setfib = -1;\n#endif\n#if (NGX_HAVE_TCP_FASTOPEN)\n        lsopt.fastopen = -1;\n#endif\n        lsopt.wildcard = 1;\n\n        (void) ngx_sock_ntop(&lsopt.sockaddr.sockaddr,\n#if (nginx_version >= 1005003)\n                             lsopt.socklen,\n#endif\n                             lsopt.addr, NGX_SOCKADDR_STRLEN, 1);\n\n        if (ngx_rtmp_add_listen(cf, cscf, &lsopt) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        cscf->port = 1935;\n    }\n\n    return rv;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_add_listen(ngx_conf_t *cf, ngx_rtmp_core_srv_conf_t *cscf,\n    ngx_rtmp_listen_opt_t *lsopt)\n{\n    in_port_t                   p;\n    ngx_uint_t                  i;\n    struct sockaddr            *sa;\n    ngx_rtmp_conf_port_t       *port;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    if (cmcf->ports == NULL) {\n        cmcf->ports = ngx_array_create(cf->temp_pool, 2,\n                                       sizeof(ngx_rtmp_conf_port_t));\n        if (cmcf->ports == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    sa = &lsopt->sockaddr.sockaddr;\n    p = ngx_inet_get_port(sa);\n\n    port = cmcf->ports->elts;\n    for (i = 0; i < cmcf->ports->nelts; i++) {\n\n        if (p != port[i].port || sa->sa_family != port[i].family) {\n            continue;\n        }\n\n        /* a port is already in the port list */\n\n        return ngx_rtmp_add_addresses(cf, cscf, &port[i], lsopt);\n    }\n\n    /* add a port to the port list */\n\n    port = ngx_array_push(cmcf->ports);\n    if (port == NULL) {\n        return NGX_ERROR;\n    }\n\n    port->family = sa->sa_family;\n    port->port = p;\n    port->addrs.elts = NULL;\n\n    return ngx_rtmp_add_address(cf, cscf, port, lsopt);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_add_addresses(ngx_conf_t *cf, ngx_rtmp_core_srv_conf_t *cscf,\n    ngx_rtmp_conf_port_t *port, ngx_rtmp_listen_opt_t *lsopt)\n{\n#if (nginx_version <= 1005007)\n    u_char                *p, *sockaddr_data, *sa_data;\n    size_t                 len, off;\n    struct sockaddr       *sa;\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    struct sockaddr_un    *saun;\n#endif\n\n#endif\n\n#if (nginx_version >= 1005012)\n    ngx_uint_t             proxy_protocol;\n#endif\n\n    ngx_uint_t             i, default_server;\n    ngx_rtmp_conf_addr_t  *addr;\n\n    /*\n     * we cannot compare whole sockaddr struct's as kernel\n     * may fill some fields in inherited sockaddr struct's\n     */\n\n#if (nginx_version <= 1005007)\n    sa = (struct sockaddr *) &lsopt->sockaddr;\n    sockaddr_data = (u_char *) &lsopt->sockaddr;\n\n    switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        off = offsetof(struct sockaddr_in6, sin6_addr);\n        len = 16;\n        break;\n#endif\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    case AF_UNIX:\n        off = offsetof(struct sockaddr_un, sun_path);\n        len = sizeof(saun->sun_path);\n        break;\n#endif\n\n    default: /* AF_INET */\n        off = offsetof(struct sockaddr_in, sin_addr);\n        len = 4;\n        break;\n    }\n\n    p = sockaddr_data + off;\n#endif\n\n    addr = port->addrs.elts;\n\n    for (i = 0; i < port->addrs.nelts; i++) {\n#if (nginx_version <= 1005007)\n        sa_data = (u_char *) &addr[i].opt.sockaddr;\n        if (ngx_memcmp(p, sa_data + off, len) != 0)\n#else\n        if (ngx_cmp_sockaddr(&lsopt->sockaddr.sockaddr, lsopt->socklen,\n                             &addr[i].opt.sockaddr.sockaddr,\n                             addr[i].opt.socklen, 0)\n            != NGX_OK)\n#endif\n        {\n            continue;\n        }\n\n        /* the address is already in the address list */\n\n        if (ngx_rtmp_add_server(cf, cscf, &addr[i]) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        /* preserve default_server bit during listen options overwriting */\n        default_server = addr[i].opt.default_server;\n#if (nginx_version >= 1005012)\n        proxy_protocol = lsopt->proxy_protocol || addr[i].opt.proxy_protocol;\n#endif\n\n        if (lsopt->set) {\n\n            if (addr[i].opt.set) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                        \"duplicate listen options for %s\", addr[i].opt.addr);\n                return NGX_ERROR;\n            }\n\n            addr[i].opt = *lsopt;\n        }\n\n        /* check the duplicate \"default\" server for this address:port */\n\n        if (lsopt->default_server) {\n\n            if (default_server) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                        \"a duplicate default server for %s\", addr[i].opt.addr);\n                return NGX_ERROR;\n            }\n\n            default_server = 1;\n            addr[i].default_server = cscf;\n        }\n\n        addr[i].opt.default_server = default_server;\n#if (nginx_version >= 1005012)\n        addr[i].opt.proxy_protocol = proxy_protocol;\n#endif\n\n        return NGX_OK;\n    }\n\n    /* add the address to the addresses list that bound to this port */\n\n    return ngx_rtmp_add_address(cf, cscf, port, lsopt);\n}\n\n\n/*\n * add the server address, the server names and the server core module\n * configurations to the port list\n */\n\nstatic ngx_int_t\nngx_rtmp_add_address(ngx_conf_t *cf, ngx_rtmp_core_srv_conf_t *cscf,\n    ngx_rtmp_conf_port_t *port, ngx_rtmp_listen_opt_t *lsopt)\n{\n    ngx_rtmp_conf_addr_t  *addr;\n\n    if (port->addrs.elts == NULL) {\n        if (ngx_array_init(&port->addrs, cf->temp_pool, 4,\n                           sizeof(ngx_rtmp_conf_addr_t))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    addr = ngx_array_push(&port->addrs);\n    if (addr == NULL) {\n        return NGX_ERROR;\n    }\n\n    addr->opt = *lsopt;\n    addr->hash.buckets = NULL;\n    addr->hash.size = 0;\n    addr->wc_head = NULL;\n    addr->wc_tail = NULL;\n#if (NGX_PCRE)\n    addr->nregex = 0;\n    addr->regex = NULL;\n#endif\n    addr->default_server = cscf;\n    addr->servers.elts = NULL;\n\n    return ngx_rtmp_add_server(cf, cscf, addr);\n}\n\n\n/* add the server core module configuration to the address:port */\n\nstatic ngx_int_t\nngx_rtmp_add_server(ngx_conf_t *cf, ngx_rtmp_core_srv_conf_t *cscf,\n    ngx_rtmp_conf_addr_t *addr)\n{\n    ngx_uint_t                  i;\n    ngx_rtmp_core_srv_conf_t  **server;\n\n    if (addr->servers.elts == NULL) {\n        if (ngx_array_init(&addr->servers, cf->temp_pool, 4,\n                           sizeof(ngx_rtmp_core_srv_conf_t *))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n    } else {\n        server = addr->servers.elts;\n        for (i = 0; i < addr->servers.nelts; i++) {\n            if (server[i] == cscf) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"a duplicate listen %s\", addr->opt.addr);\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    server = ngx_array_push(&addr->servers);\n    if (server == NULL) {\n        return NGX_ERROR;\n    }\n\n    *server = cscf;\n\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_rtmp_core_application(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                       *rv;\n    ngx_int_t                   i;\n    ngx_uint_t                  n;\n    ngx_str_t                  *value;\n    ngx_conf_t                  save;\n    ngx_module_t              **modules;\n    ngx_rtmp_module_t          *module;\n    ngx_rtmp_conf_ctx_t        *ctx, *pctx;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_rtmp_core_app_conf_t   *cacf, **cacfp;\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    pctx = cf->ctx;\n    ctx->main_conf = pctx->main_conf;\n    ctx->srv_conf = pctx->srv_conf;\n\n    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n#if (nginx_version >= 1009011)\n    modules = cf->cycle->modules;\n#else\n    modules = ngx_modules;\n#endif\n\n    for (i = 0; modules[i]; i++) {\n        if (modules[i]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[i]->ctx;\n\n        if (module->create_app_conf) {\n            ctx->app_conf[modules[i]->ctx_index] = module->create_app_conf(cf);\n            if (ctx->app_conf[modules[i]->ctx_index] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    cacf = ctx->app_conf[ngx_rtmp_core_module.ctx_index];\n    cacf->app_conf = ctx->app_conf;\n\n    value = cf->args->elts;\n\n    cacf->name = value[1];\n    cscf = pctx->srv_conf[ngx_rtmp_core_module.ctx_index];\n\n    cacfp = cscf->applications.elts;\n    for (n = 0; n < cscf->applications.nelts; n++) {\n        if (cacf->name.len == cacfp[n]->name.len\n                && ngx_strncmp(cacf->name.data,\n                        cacfp[n]->name.data, cacf->name.len) == 0)\n        {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                    \"duplicate application: \\\"%V\\\"\", &cacf->name);\n\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    cacfp = ngx_array_push(&cscf->applications);\n    if (cacfp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *cacfp = cacf;\n\n    save = *cf;\n    cf->ctx = ctx;\n    cf->cmd_type = NGX_RTMP_APP_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf= save;\n\n    return rv;\n}\n\n\nstatic char *\nngx_rtmp_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_core_app_conf_t  *cacf = conf;\n\n    ngx_str_t  *value;\n\n    if (cacf->resolver) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    cacf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);\n    if (cacf->resolver == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_core_lowat_check(ngx_conf_t *cf, void *post, void *data)\n{\n#if (NGX_FREEBSD)\n    ssize_t *np = data;\n\n    if ((u_long) *np >= ngx_freebsd_net_inet_tcp_sendspace) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"\\\"send_lowat\\\" must be less than %d \"\n                           \"(sysctl net.inet.tcp.sendspace)\",\n                           ngx_freebsd_net_inet_tcp_sendspace);\n\n        return NGX_CONF_ERROR;\n    }\n\n#elif !(NGX_HAVE_SO_SNDLOWAT)\n    ssize_t *np = data;\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"send_lowat\\\" is not supported, ignored\");\n\n    *np = 0;\n\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_core_pool_size(ngx_conf_t *cf, void *post, void *data)\n{\n    size_t *sp = data;\n\n    if (*sp < NGX_MIN_POOL_SIZE) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"the pool size must be no less than %uz\",\n                           NGX_MIN_POOL_SIZE);\n        return NGX_CONF_ERROR;\n    }\n\n    if (*sp % NGX_POOL_ALIGNMENT) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"the pool size must be a multiple of %uz\",\n                           NGX_POOL_ALIGNMENT);\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_core_srv_conf_t *cscf = conf;\n\n    ngx_str_t              *value, size;\n    ngx_url_t               u;\n    ngx_uint_t              n;\n    ngx_rtmp_listen_opt_t   lsopt;\n\n    cscf->listen = 1;\n\n    value = cf->args->elts;\n\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    u.url = value[1];\n    u.listen = 1;\n    u.default_port = 1935;\n\n    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n        if (u.err) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"%s in \\\"%V\\\" of the \\\"listen\\\" directive\",\n                               u.err, &u.url);\n        }\n\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(&lsopt, sizeof(ngx_rtmp_listen_opt_t));\n\n    ngx_memcpy(&lsopt.sockaddr.sockaddr, &u.sockaddr, u.socklen);\n\n    lsopt.socklen = u.socklen;\n    lsopt.backlog = NGX_LISTEN_BACKLOG;\n    lsopt.rcvbuf = -1;\n    lsopt.sndbuf = -1;\n#if (NGX_HAVE_SETFIB)\n    lsopt.setfib = -1;\n#endif\n#if (NGX_HAVE_TCP_FASTOPEN)\n    lsopt.fastopen = -1;\n#endif\n    lsopt.wildcard = u.wildcard;\n#if (NGX_HAVE_INET6)\n    lsopt.ipv6only = 1;\n#endif\n\n    (void) ngx_sock_ntop(&lsopt.sockaddr.sockaddr,\n#if (nginx_version >= 1005003)\n                         lsopt.socklen,\n#endif\n                         lsopt.addr,\n                         NGX_SOCKADDR_STRLEN, 1);\n\n    for (n = 2; n < cf->args->nelts; n++) {\n\n        if (ngx_strcmp(value[n].data, \"default_server\") == 0\n            || ngx_strcmp(value[n].data, \"default\") == 0)\n        {\n            lsopt.default_server = 1;\n            continue;\n        }\n\n        if (ngx_strcmp(value[n].data, \"bind\") == 0) {\n            lsopt.set = 1;\n            lsopt.bind = 1;\n            continue;\n        }\n\n#if (NGX_HAVE_SETFIB)\n        if (ngx_strncmp(value[n].data, \"setfib=\", 7) == 0) {\n            lsopt.setfib = ngx_atoi(value[n].data + 7, value[n].len - 7);\n            lsopt.set = 1;\n            lsopt.bind = 1;\n\n            if (lsopt.setfib == NGX_ERROR) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid setfib \\\"%V\\\"\", &value[n]);\n                return NGX_CONF_ERROR;\n            }\n\n            continue;\n        }\n#endif\n\n#if (NGX_HAVE_TCP_FASTOPEN)\n        if (ngx_strncmp(value[n].data, \"fastopen=\", 9) == 0) {\n            lsopt.fastopen = ngx_atoi(value[n].data + 9, value[n].len - 9);\n            lsopt.set = 1;\n            lsopt.bind = 1;\n\n            if (lsopt.fastopen == NGX_ERROR) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid fastopen \\\"%V\\\"\", &value[n]);\n                return NGX_CONF_ERROR;\n            }\n\n            continue;\n        }\n#endif\n\n        if (ngx_strncmp(value[n].data, \"backlog=\", 8) == 0) {\n            lsopt.backlog = ngx_atoi(value[n].data + 8, value[n].len - 8);\n            lsopt.set = 1;\n            lsopt.bind = 1;\n\n            if (lsopt.backlog == NGX_ERROR || lsopt.backlog == 0) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid backlog \\\"%V\\\"\", &value[n]);\n                return NGX_CONF_ERROR;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[n].data, \"rcvbuf=\", 7) == 0) {\n            size.len = value[n].len - 7;\n            size.data = value[n].data + 7;\n\n            lsopt.rcvbuf = ngx_parse_size(&size);\n            lsopt.set = 1;\n            lsopt.bind = 1;\n\n            if (lsopt.rcvbuf == NGX_ERROR) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid rcvbuf \\\"%V\\\"\", &value[n]);\n                return NGX_CONF_ERROR;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[n].data, \"sndbuf=\", 7) == 0) {\n            size.len = value[n].len - 7;\n            size.data = value[n].data + 7;\n\n            lsopt.sndbuf = ngx_parse_size(&size);\n            lsopt.set = 1;\n            lsopt.bind = 1;\n\n            if (lsopt.sndbuf == NGX_ERROR) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"invalid sndbuf \\\"%V\\\"\", &value[n]);\n                return NGX_CONF_ERROR;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[n].data, \"accept_filter=\", 14) == 0) {\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined SO_ACCEPTFILTER)\n            lsopt.accept_filter = (char *) &value[n].data[14];\n            lsopt.set = 1;\n            lsopt.bind = 1;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"accept filters \\\"%V\\\" are not supported \"\n                               \"on this platform, ignored\",\n                               &value[n]);\n#endif\n            continue;\n        }\n\n        if (ngx_strcmp(value[n].data, \"deferred\") == 0) {\n#if (NGX_HAVE_DEFERRED_ACCEPT && defined TCP_DEFER_ACCEPT)\n            lsopt.deferred_accept = 1;\n            lsopt.set = 1;\n            lsopt.bind = 1;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"the deferred accept is not supported \"\n                               \"on this platform, ignored\");\n#endif\n            continue;\n        }\n\n        if (ngx_strncmp(value[n].data, \"ipv6only=o\", 10) == 0) {\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n            struct sockaddr  *sa;\n\n            sa = &lsopt.sockaddr.sockaddr;\n\n            if (sa->sa_family == AF_INET6) {\n\n                if (ngx_strcmp(&value[n].data[10], \"n\") == 0) {\n                    lsopt.ipv6only = 1;\n\n                } else if (ngx_strcmp(&value[n].data[10], \"ff\") == 0) {\n                    lsopt.ipv6only = 0;\n\n                } else {\n                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                       \"invalid ipv6only flags \\\"%s\\\"\",\n                                       &value[n].data[9]);\n                    return NGX_CONF_ERROR;\n                }\n\n                lsopt.set = 1;\n                lsopt.bind = 1;\n\n            } else {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"ipv6only is not supported \"\n                                   \"on addr \\\"%s\\\", ignored\", lsopt.addr);\n            }\n\n            continue;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"ipv6only is not supported \"\n                               \"on this platform\");\n            return NGX_CONF_ERROR;\n#endif\n        }\n\n        if (ngx_strcmp(value[n].data, \"reuseport\") == 0) {\n#if (NGX_HAVE_REUSEPORT)\n            lsopt.reuseport = 1;\n            lsopt.set = 1;\n            lsopt.bind = 1;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"reuseport is not supported \"\n                               \"on this platform, ignored\");\n#endif\n            continue;\n        }\n\n        if (ngx_strncmp(value[n].data, \"so_keepalive=\", 13) == 0) {\n\n            if (ngx_strcmp(&value[n].data[13], \"on\") == 0) {\n                lsopt.so_keepalive = 1;\n\n            } else if (ngx_strcmp(&value[n].data[13], \"off\") == 0) {\n                lsopt.so_keepalive = 2;\n\n            } else {\n\n#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n                u_char     *p, *end;\n                ngx_str_t   s;\n\n                end = value[n].data + value[n].len;\n                s.data = value[n].data + 13;\n\n                p = ngx_strlchr(s.data, end, ':');\n                if (p == NULL) {\n                    p = end;\n                }\n\n                if (p > s.data) {\n                    s.len = p - s.data;\n\n                    lsopt.tcp_keepidle = ngx_parse_time(&s, 1);\n                    if (lsopt.tcp_keepidle == (time_t) NGX_ERROR) {\n                        goto invalid_so_keepalive;\n                    }\n                }\n\n                s.data = (p < end) ? (p + 1) : end;\n\n                p = ngx_strlchr(s.data, end, ':');\n                if (p == NULL) {\n                    p = end;\n                }\n\n                if (p > s.data) {\n                    s.len = p - s.data;\n\n                    lsopt.tcp_keepintvl = ngx_parse_time(&s, 1);\n                    if (lsopt.tcp_keepintvl == (time_t) NGX_ERROR) {\n                        goto invalid_so_keepalive;\n                    }\n                }\n\n                s.data = (p < end) ? (p + 1) : end;\n\n                if (s.data < end) {\n                    s.len = end - s.data;\n\n                    lsopt.tcp_keepcnt = ngx_atoi(s.data, s.len);\n                    if (lsopt.tcp_keepcnt == NGX_ERROR) {\n                        goto invalid_so_keepalive;\n                    }\n                }\n\n                if (lsopt.tcp_keepidle == 0 && lsopt.tcp_keepintvl == 0\n                    && lsopt.tcp_keepcnt == 0)\n                {\n                    goto invalid_so_keepalive;\n                }\n\n                lsopt.so_keepalive = 1;\n\n#else\n\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"the \\\"so_keepalive\\\" parameter accepts \"\n                                   \"only \\\"on\\\" or \\\"off\\\" on this platform\");\n                return NGX_CONF_ERROR;\n\n#endif\n            }\n\n            lsopt.set = 1;\n            lsopt.bind = 1;\n\n            continue;\n\n#if (NGX_HAVE_KEEPALIVE_TUNABLE)\n        invalid_so_keepalive:\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid so_keepalive value: \\\"%s\\\"\",\n                               &value[n].data[13]);\n            return NGX_CONF_ERROR;\n#endif\n        }\n\n        if (ngx_strcmp(value[n].data, \"proxy_protocol\") == 0) {\n            lsopt.proxy_protocol = 1;\n            continue;\n        }\n\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid parameter \\\"%V\\\"\", &value[n]);\n        return NGX_CONF_ERROR;\n    }\n\n    cscf->port = u.port;\n\n    if (ngx_rtmp_add_listen(cf, cscf, &lsopt) == NGX_OK) {\n        return NGX_CONF_OK;\n    }\n\n    return NGX_CONF_ERROR;\n}\n\n\nstatic char *\nngx_rtmp_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_core_srv_conf_t *cscf = conf;\n\n    u_char                   ch;\n    ngx_str_t               *value;\n    ngx_uint_t               i;\n    ngx_rtmp_server_name_t  *sn;\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        ch = value[i].data[0];\n\n        if ((ch == '*' && (value[i].len < 3 || value[i].data[1] != '.'))\n            || (ch == '.' && value[i].len < 2))\n        {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"server name \\\"%V\\\" is invalid\", &value[i]);\n            return NGX_CONF_ERROR;\n        }\n\n        if (ngx_strchr(value[i].data, '/')) {\n            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                               \"server name \\\"%V\\\" has suspicious symbols\",\n                               &value[i]);\n        }\n\n        sn = ngx_array_push(&cscf->server_names);\n        if (sn == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n#if (NGX_PCRE)\n        sn->regex = NULL;\n#endif\n        sn->server = cscf;\n\n        if (ngx_strcasecmp(value[i].data, (u_char *) \"$hostname\") == 0) {\n            sn->name = cf->cycle->hostname;\n\n        } else {\n            sn->name = value[i];\n        }\n\n        if (value[i].data[0] != '~') {\n            ngx_strlow(sn->name.data, sn->name.data, sn->name.len);\n            continue;\n        }\n\n#if (NGX_PCRE)\n        {\n            u_char               *p;\n            ngx_regex_compile_t   rc;\n            u_char                errstr[NGX_MAX_CONF_ERRSTR];\n\n            if (value[i].len == 1) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"empty regex in server name \\\"%V\\\"\", &value[i]);\n                return NGX_CONF_ERROR;\n            }\n\n            value[i].len--;\n            value[i].data++;\n\n            ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n\n            rc.pattern = value[i];\n            rc.err.len = NGX_MAX_CONF_ERRSTR;\n            rc.err.data = errstr;\n\n            for (p = value[i].data; p < value[i].data + value[i].len; p++) {\n                if (*p >= 'A' && *p <= 'Z') {\n                    rc.options = NGX_REGEX_CASELESS;\n                    break;\n                }\n            }\n\n            sn->regex = ngx_rtmp_regex_compile(cf, &rc);\n            if (sn->regex == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            sn->name = value[i];\n            cscf->captures = (rc.captures > 0);\n        }\n#else\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"using regex \\\"%V\\\" \"\n                           \"requires PCRE library\", &value[i]);\n\n        return NGX_CONF_ERROR;\n#endif\n    }\n\n    return NGX_CONF_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_eval.c",
          "type": "blob",
          "size": 6.15234375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_eval.h\"\n\n\n#define NGX_RTMP_EVAL_BUFLEN    16\n\n\nstatic void\nngx_rtmp_eval_session_str(void *ctx, ngx_rtmp_eval_t *e, ngx_str_t *ret)\n{\n    *ret = *(ngx_str_t *) ((u_char *) ctx + e->offset);\n}\n\n\nstatic void\nngx_rtmp_eval_connection_str(void *ctx, ngx_rtmp_eval_t *e, ngx_str_t *ret)\n{\n    ngx_rtmp_session_t  *s = ctx;\n\n    *ret = *(ngx_str_t *) ((u_char *) s->connection + e->offset);\n}\n\n\nngx_rtmp_eval_t ngx_rtmp_eval_session[] = {\n\n    { ngx_string(\"app\"),\n      ngx_rtmp_eval_session_str,\n      offsetof(ngx_rtmp_session_t, app) },\n\n    { ngx_string(\"flashver\"),\n      ngx_rtmp_eval_session_str,\n      offsetof(ngx_rtmp_session_t, flashver) },\n\n    { ngx_string(\"swfurl\"),\n      ngx_rtmp_eval_session_str,\n      offsetof(ngx_rtmp_session_t, swf_url) },\n\n    { ngx_string(\"tcurl\"),\n      ngx_rtmp_eval_session_str,\n      offsetof(ngx_rtmp_session_t, tc_url) },\n\n    { ngx_string(\"pageurl\"),\n      ngx_rtmp_eval_session_str,\n      offsetof(ngx_rtmp_session_t, page_url) },\n\n    { ngx_string(\"addr\"),\n      ngx_rtmp_eval_connection_str,\n      offsetof(ngx_connection_t, addr_text) },\n\n    ngx_rtmp_null_eval\n};\n\n\nstatic void\nngx_rtmp_eval_append(ngx_buf_t *b, void *data, size_t len, ngx_log_t *log)\n{\n    size_t   buf_len;\n    u_char  *old;\n\n    if (b->last + len > b->end) {\n        buf_len = (2 * (b->last - b->pos) + len +\n                   NGX_RTMP_EVAL_BUFLEN - 1) & ~(NGX_RTMP_EVAL_BUFLEN - 1);\n\n        old = b->start;\n\n        b->start = ngx_alloc(buf_len, log);\n        if (b->start == NULL) {\n            return;\n        }\n\n        b->last = ngx_cpymem(b->start, b->pos, b->last - b->pos);\n        b->pos = b->start;\n        b->end = b->start + buf_len;\n\n        ngx_free(old);\n    }\n\n    b->last = ngx_cpymem(b->last, data, len);\n}\n\n\nstatic void\nngx_rtmp_eval_append_var(void *ctx, ngx_buf_t *b, ngx_rtmp_eval_t **e,\n    ngx_str_t *name, ngx_log_t *log)\n{\n    ngx_str_t           v;\n    ngx_rtmp_eval_t    *ee;\n\n    for (; *e; ++e) {\n        for (ee = *e; ee->handler; ++ee) {\n            if (ee->name.len == name->len &&\n                ngx_memcmp(ee->name.data, name->data, name->len) == 0)\n            {\n                ee->handler(ctx, ee, &v);\n                ngx_rtmp_eval_append(b, v.data, v.len, log);\n            }\n        }\n    }\n}\n\n\nngx_int_t\nngx_rtmp_eval(void *ctx, ngx_str_t *in, ngx_rtmp_eval_t **e, ngx_str_t *out,\n    ngx_log_t *log)\n{\n    u_char      c, *p;\n    ngx_str_t   name;\n    ngx_buf_t   b;\n    ngx_uint_t  n;\n\n    enum {\n        NORMAL,\n        ESCAPE,\n        NAME,\n        SNAME\n    } state = NORMAL;\n\n    b.pos = b.last = b.start = ngx_alloc(NGX_RTMP_EVAL_BUFLEN, log);\n    if (b.pos == NULL) {\n        return NGX_ERROR;\n    }\n\n    b.end = b.pos + NGX_RTMP_EVAL_BUFLEN;\n    name.data = NULL;\n\n    for (n = 0; n < in->len; ++n) {\n        p = &in->data[n];\n        c = *p;\n\n        switch (state) {\n            case SNAME:\n                if (c != '}') {\n                    continue;\n                }\n\n                name.len = p - name.data;\n                ngx_rtmp_eval_append_var(ctx, &b, e, &name, log);\n\n                state = NORMAL;\n\n                continue;\n\n            case NAME:\n                if (c == '{' && name.data == p) {\n                    ++name.data;\n                    state = SNAME;\n                    continue;\n                }\n                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n                    continue;\n                }\n\n                name.len = p - name.data;\n                ngx_rtmp_eval_append_var(ctx, &b, e, &name, log);\n\n                /* fall through */\n\n            case NORMAL:\n                switch (c) {\n                    case '$':\n                        name.data = p + 1;\n                        state = NAME;\n                        continue;\n                    case '\\\\':\n                        state = ESCAPE;\n                        continue;\n                    default:\n                        break;\n                }\n\n                /* fall through */\n\n            case ESCAPE:\n                ngx_rtmp_eval_append(&b, &c, 1, log);\n                state = NORMAL;\n                break;\n\n        }\n    }\n\n    if (state == NAME) {\n        p = &in->data[n];\n        name.len = p - name.data;\n        ngx_rtmp_eval_append_var(ctx, &b, e, &name, log);\n    }\n\n    c = 0;\n    ngx_rtmp_eval_append(&b, &c, 1, log);\n\n    out->data = b.pos;\n    out->len  = b.last - b.pos - 1;\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_eval_streams(ngx_str_t *in)\n{\n#if !(NGX_WIN32)\n    ngx_int_t   mode, create, v, close_src;\n    ngx_fd_t    dst, src;\n    u_char     *path;\n\n    path = in->data;\n\n    while (*path >= '0' && *path <= '9') {\n        path++;\n    }\n\n    switch ((char) *path) {\n\n        case '>':\n\n            v = (path == in->data ? 1 : ngx_atoi(in->data, path - in->data));\n            if (v == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n\n            dst = (ngx_fd_t) v;\n            mode = NGX_FILE_WRONLY;\n            create = NGX_FILE_TRUNCATE;\n            path++;\n\n            if (*path == (u_char) '>') {\n                mode = NGX_FILE_APPEND;\n                create = NGX_FILE_CREATE_OR_OPEN;\n                path++;\n            }\n\n            break;\n\n        case '<':\n\n            v = (path == in->data ? 0 : ngx_atoi(in->data, path - in->data));\n            if (v == NGX_ERROR) {\n                return NGX_ERROR;\n            }\n\n            dst = (ngx_fd_t) v;\n            mode = NGX_FILE_RDONLY;\n            create = NGX_FILE_OPEN;\n            path++;\n\n            break;\n\n        default:\n\n            return NGX_DONE;\n    }\n\n    if (*path == (u_char) '&') {\n\n        path++;\n        v = ngx_atoi(path, in->data + in->len - path);\n        if (v == NGX_ERROR) {\n            return NGX_ERROR;\n        }\n        src = (ngx_fd_t) v;\n        close_src = 0;\n\n    } else {\n\n        src = ngx_open_file(path, mode, create, NGX_FILE_DEFAULT_ACCESS);\n        if (src == NGX_INVALID_FILE) {\n            return NGX_ERROR;\n        }\n        close_src = 1;\n\n    }\n\n    if (src == dst) {\n        return NGX_OK;\n    }\n\n    dup2(src, dst);\n\n    if (close_src) {\n        ngx_close_file(src);\n    }\n    return NGX_OK;\n\n#else\n    return NGX_DONE;\n#endif\n}\n"
        },
        {
          "name": "ngx_rtmp_eval.h",
          "type": "blob",
          "size": 0.8232421875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_EVAL_H_INCLUDED_\n#define _NGX_RTMP_EVAL_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\ntypedef struct ngx_rtmp_eval_s ngx_rtmp_eval_t;\n\n\ntypedef void (* ngx_rtmp_eval_pt)(void *ctx, ngx_rtmp_eval_t *e,\n                                  ngx_str_t *ret);\n\n\nstruct ngx_rtmp_eval_s {\n    ngx_str_t               name;\n    ngx_rtmp_eval_pt        handler;\n    ngx_uint_t              offset;\n};\n\n\n#define ngx_rtmp_null_eval  { ngx_null_string, NULL, 0 }\n\n\n/* standard session eval variables */\nextern ngx_rtmp_eval_t      ngx_rtmp_eval_session[];\n\n\nngx_int_t ngx_rtmp_eval(void *ctx, ngx_str_t *in, ngx_rtmp_eval_t **e,\n    ngx_str_t *out, ngx_log_t *log);\n\n\nngx_int_t ngx_rtmp_eval_streams(ngx_str_t *in);\n\n\n#endif /* _NGX_RTMP_EVAL_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_exec_module.c",
          "type": "blob",
          "size": 40.76171875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_record_module.h\"\n#include \"ngx_rtmp_eval.h\"\n#include <stdlib.h>\n\n#ifdef NGX_LINUX\n#include <unistd.h>\n#endif\n\n\n#if !(NGX_WIN32)\nstatic ngx_rtmp_publish_pt              next_publish;\nstatic ngx_rtmp_play_pt                 next_play;\nstatic ngx_rtmp_close_stream_pt         next_close_stream;\nstatic ngx_rtmp_record_done_pt          next_record_done;\n#endif\n\n\nstatic ngx_int_t ngx_rtmp_exec_init_process(ngx_cycle_t *cycle);\nstatic ngx_int_t ngx_rtmp_exec_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_exec_create_main_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_exec_init_main_conf(ngx_conf_t *cf, void *conf);\nstatic void * ngx_rtmp_exec_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_exec_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\n/*static char * ngx_rtmp_exec_block(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);*/\nstatic char * ngx_rtmp_exec_conf(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic char *ngx_rtmp_exec_kill_signal(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\n\n\n#define NGX_RTMP_EXEC_RESPAWN           0x01\n#define NGX_RTMP_EXEC_KILL              0x02\n\n\n#define NGX_RTMP_EXEC_PUBLISHING        0x01\n#define NGX_RTMP_EXEC_PLAYING           0x02\n\n\nenum {\n    NGX_RTMP_EXEC_PUSH,\n    NGX_RTMP_EXEC_PULL,\n\n    NGX_RTMP_EXEC_PUBLISH,\n    NGX_RTMP_EXEC_PUBLISH_DONE,\n    NGX_RTMP_EXEC_PLAY,\n    NGX_RTMP_EXEC_PLAY_DONE,\n    NGX_RTMP_EXEC_RECORD_DONE,\n\n    NGX_RTMP_EXEC_MAX,\n\n    NGX_RTMP_EXEC_STATIC\n};\n\n\ntypedef struct {\n    ngx_str_t                           id;\n    ngx_uint_t                          type;\n    ngx_str_t                           cmd;\n    ngx_array_t                         args;       /* ngx_str_t */\n    ngx_array_t                         names;\n} ngx_rtmp_exec_conf_t;\n\n\ntypedef struct {\n    ngx_rtmp_exec_conf_t               *conf;\n    ngx_log_t                          *log;\n    ngx_rtmp_eval_t                   **eval;\n    void                               *eval_ctx;\n    unsigned                            active:1;\n    unsigned                            managed:1;\n    ngx_pid_t                           pid;\n    ngx_pid_t                          *save_pid;\n    int                                 pipefd;\n    ngx_connection_t                    dummy_conn;  /*needed by ngx_xxx_event*/\n    ngx_event_t                         read_evt, write_evt;\n    ngx_event_t                         respawn_evt;\n    ngx_msec_t                          respawn_timeout;\n    ngx_int_t                           kill_signal;\n} ngx_rtmp_exec_t;\n\n\ntypedef struct {\n    ngx_array_t                         static_conf; /* ngx_rtmp_exec_conf_t */\n    ngx_array_t                         static_exec; /* ngx_rtmp_exec_t */\n    ngx_msec_t                          respawn_timeout;\n    ngx_int_t                           kill_signal;\n    ngx_log_t                          *log;\n} ngx_rtmp_exec_main_conf_t;\n\n\ntypedef struct ngx_rtmp_exec_pull_ctx_s  ngx_rtmp_exec_pull_ctx_t;\n\nstruct ngx_rtmp_exec_pull_ctx_s {\n    ngx_pool_t                         *pool;\n    ngx_uint_t                          counter;\n    ngx_str_t                           name;\n    ngx_str_t                           app;\n    ngx_array_t                         pull_exec;   /* ngx_rtmp_exec_t */\n    ngx_rtmp_exec_pull_ctx_t           *next;\n};\n\n\ntypedef struct {\n    ngx_int_t                           active;\n    ngx_array_t                         conf[NGX_RTMP_EXEC_MAX];\n                                                     /* ngx_rtmp_exec_conf_t */\n    ngx_flag_t                          respawn;\n    ngx_flag_t                          options;\n    ngx_uint_t                          nbuckets;\n    ngx_rtmp_exec_pull_ctx_t          **pull;\n} ngx_rtmp_exec_app_conf_t;\n\n\ntypedef struct {\n    ngx_uint_t                          flags;\n    ngx_str_t                           path;     /* /tmp/rec/myfile-123.flv */\n    ngx_str_t                           filename; /* myfile-123.flv */\n    ngx_str_t                           basename; /* myfile-123 */\n    ngx_str_t                           dirname;  /* /tmp/rec */\n    ngx_str_t                           recorder;\n    u_char                              name[NGX_RTMP_MAX_NAME];\n    u_char                              args[NGX_RTMP_MAX_ARGS];\n    ngx_array_t                         push_exec;   /* ngx_rtmp_exec_t */\n    ngx_rtmp_exec_pull_ctx_t           *pull;\n} ngx_rtmp_exec_ctx_t;\n\n\n#if !(NGX_WIN32)\nstatic void ngx_rtmp_exec_respawn(ngx_event_t *ev);\nstatic ngx_int_t ngx_rtmp_exec_kill(ngx_rtmp_exec_t *e, ngx_int_t kill_signal);\nstatic ngx_int_t ngx_rtmp_exec_run(ngx_rtmp_exec_t *e);\n#endif\n\n\nstatic ngx_command_t  ngx_rtmp_exec_commands[] = {\n/*\n    { ngx_string(\"exec_block\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS|NGX_CONF_TAKE1,\n      ngx_rtmp_exec_block,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n*/\n    { ngx_string(\"exec\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PUSH * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_push\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PUSH * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_pull\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PULL * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_publish\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PUBLISH * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_publish_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PUBLISH_DONE * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_play\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PLAY * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_play_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_PLAY_DONE * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_record_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_RTMP_REC_CONF|\n                         NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, conf) +\n      NGX_RTMP_EXEC_RECORD_DONE * sizeof(ngx_array_t),\n      NULL },\n\n    { ngx_string(\"exec_static\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_exec_conf,\n      NGX_RTMP_MAIN_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_main_conf_t, static_conf),\n      NULL },\n\n    { ngx_string(\"respawn\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, respawn),\n      NULL },\n\n    { ngx_string(\"respawn_timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_MAIN_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_main_conf_t, respawn_timeout),\n      NULL },\n\n    { ngx_string(\"exec_kill_signal\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_exec_kill_signal,\n      NGX_RTMP_MAIN_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"exec_options\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_exec_app_conf_t, options),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_exec_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_exec_postconfiguration,        /* postconfiguration */\n    ngx_rtmp_exec_create_main_conf,         /* create main configuration */\n    ngx_rtmp_exec_init_main_conf,           /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_exec_create_app_conf,          /* create app configuration */\n    ngx_rtmp_exec_merge_app_conf            /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_exec_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_exec_module_ctx,              /* module context */\n    ngx_rtmp_exec_commands,                 /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    ngx_rtmp_exec_init_process,             /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void\nngx_rtmp_exec_eval_ctx_cstr(void *sctx, ngx_rtmp_eval_t *e, ngx_str_t *ret)\n{\n    ngx_rtmp_session_t  *s = sctx;\n\n    ngx_rtmp_exec_ctx_t  *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n    if (ctx == NULL) {\n        ret->len = 0;\n        return;\n    }\n\n    ret->data = (u_char *) ctx + e->offset;\n    ret->len = ngx_strlen(ret->data);\n}\n\n\nstatic void\nngx_rtmp_exec_eval_ctx_str(void *sctx, ngx_rtmp_eval_t *e, ngx_str_t *ret)\n{\n    ngx_rtmp_session_t  *s = sctx;\n\n    ngx_rtmp_exec_ctx_t  *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n    if (ctx == NULL) {\n        ret->len = 0;\n        return;\n    }\n\n    *ret = * (ngx_str_t *) ((u_char *) ctx + e->offset);\n}\n\n\nstatic void\nngx_rtmp_exec_eval_pctx_str(void *ctx, ngx_rtmp_eval_t *e, ngx_str_t *ret)\n{\n    *ret = *(ngx_str_t *) ((u_char *) ctx + e->offset);\n}\n\n\nstatic ngx_rtmp_eval_t ngx_rtmp_exec_push_specific_eval[] = {\n\n    { ngx_string(\"name\"),\n      ngx_rtmp_exec_eval_ctx_cstr,\n      offsetof(ngx_rtmp_exec_ctx_t, name) },\n\n    { ngx_string(\"args\"),\n      ngx_rtmp_exec_eval_ctx_cstr,\n      offsetof(ngx_rtmp_exec_ctx_t, args) },\n\n    ngx_rtmp_null_eval\n};\n\n\nstatic ngx_rtmp_eval_t * ngx_rtmp_exec_push_eval[] = {\n    ngx_rtmp_eval_session,\n    ngx_rtmp_exec_push_specific_eval,\n    NULL\n};\n\n\nstatic ngx_rtmp_eval_t ngx_rtmp_exec_pull_specific_eval[] = {\n\n    { ngx_string(\"name\"),\n      ngx_rtmp_exec_eval_pctx_str,\n      offsetof(ngx_rtmp_exec_pull_ctx_t, name) },\n\n    { ngx_string(\"app\"),\n      ngx_rtmp_exec_eval_pctx_str,\n      offsetof(ngx_rtmp_exec_pull_ctx_t, app) },\n\n    ngx_rtmp_null_eval\n};\n\n\nstatic ngx_rtmp_eval_t * ngx_rtmp_exec_pull_eval[] = {\n    ngx_rtmp_exec_pull_specific_eval,\n    NULL\n};\n\n\nstatic ngx_rtmp_eval_t ngx_rtmp_exec_event_specific_eval[] = {\n\n    { ngx_string(\"name\"),\n      ngx_rtmp_exec_eval_ctx_cstr,\n      offsetof(ngx_rtmp_exec_ctx_t, name) },\n\n    { ngx_string(\"args\"),\n      ngx_rtmp_exec_eval_ctx_cstr,\n      offsetof(ngx_rtmp_exec_ctx_t, args) },\n\n    { ngx_string(\"path\"),\n      ngx_rtmp_exec_eval_ctx_str,\n      offsetof(ngx_rtmp_exec_ctx_t, path) },\n\n    { ngx_string(\"filename\"),\n      ngx_rtmp_exec_eval_ctx_str,\n      offsetof(ngx_rtmp_exec_ctx_t, filename) },\n\n    { ngx_string(\"basename\"),\n      ngx_rtmp_exec_eval_ctx_str,\n      offsetof(ngx_rtmp_exec_ctx_t, basename) },\n\n    { ngx_string(\"dirname\"),\n      ngx_rtmp_exec_eval_ctx_str,\n      offsetof(ngx_rtmp_exec_ctx_t, dirname) },\n\n    { ngx_string(\"recorder\"),\n      ngx_rtmp_exec_eval_ctx_str,\n      offsetof(ngx_rtmp_exec_ctx_t, recorder) },\n\n    ngx_rtmp_null_eval\n};\n\n\nstatic ngx_rtmp_eval_t * ngx_rtmp_exec_event_eval[] = {\n    ngx_rtmp_eval_session,\n    ngx_rtmp_exec_event_specific_eval,\n    NULL\n};\n\n\nstatic void *\nngx_rtmp_exec_create_main_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_exec_main_conf_t     *emcf;\n\n    emcf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_exec_main_conf_t));\n    if (emcf == NULL) {\n        return NULL;\n    }\n\n    emcf->respawn_timeout = NGX_CONF_UNSET_MSEC;\n    emcf->kill_signal = NGX_CONF_UNSET;\n\n    if (ngx_array_init(&emcf->static_conf, cf->pool, 1,\n                       sizeof(ngx_rtmp_exec_conf_t)) != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return emcf;\n}\n\n\nstatic char *\nngx_rtmp_exec_init_main_conf(ngx_conf_t *cf, void *conf)\n{\n    ngx_rtmp_exec_main_conf_t  *emcf = conf;\n    ngx_rtmp_exec_conf_t       *ec;\n    ngx_rtmp_exec_t            *e;\n    ngx_uint_t                  n;\n\n    if (emcf->respawn_timeout == NGX_CONF_UNSET_MSEC) {\n        emcf->respawn_timeout = 5000;\n    }\n\n#if !(NGX_WIN32)\n    if (emcf->kill_signal == NGX_CONF_UNSET) {\n        emcf->kill_signal = SIGKILL;\n    }\n#endif\n\n    if (ngx_array_init(&emcf->static_exec, cf->pool,\n                       emcf->static_conf.nelts,\n                       sizeof(ngx_rtmp_exec_t)) != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    e = ngx_array_push_n(&emcf->static_exec, emcf->static_conf.nelts);\n    if (e == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    emcf->log = &cf->cycle->new_log;\n\n    ec = emcf->static_conf.elts;\n\n    for (n = 0; n < emcf->static_conf.nelts; n++, e++, ec++) {\n        ngx_memzero(e, sizeof(*e));\n        e->conf = ec;\n        e->managed = 1;\n        e->log = emcf->log;\n        e->respawn_timeout = emcf->respawn_timeout;\n        e->kill_signal = emcf->kill_signal;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic void *\nngx_rtmp_exec_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_exec_app_conf_t      *eacf;\n\n    eacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_exec_app_conf_t));\n    if (eacf == NULL) {\n        return NULL;\n    }\n\n    eacf->respawn = NGX_CONF_UNSET;\n    eacf->options = NGX_CONF_UNSET;\n    eacf->nbuckets = NGX_CONF_UNSET_UINT;\n\n    return eacf;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_merge_confs(ngx_array_t *conf, ngx_array_t *prev)\n{\n    size_t                 n;\n    ngx_rtmp_exec_conf_t  *ec, *pec;\n\n    if (prev->nelts == 0) {\n        return NGX_OK;\n    }\n\n    if (conf->nelts == 0) {\n        *conf = *prev;\n        return NGX_OK;\n    }\n\n    ec = ngx_array_push_n(conf, prev->nelts);\n    if (ec == NULL) {\n        return NGX_ERROR;\n    }\n\n    pec = prev->elts;\n    for (n = 0; n < prev->nelts; n++, ec++, pec++) {\n        *ec = *pec;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_rtmp_exec_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_exec_app_conf_t   *prev = parent;\n    ngx_rtmp_exec_app_conf_t   *conf = child;\n\n    ngx_uint_t  n;\n\n    ngx_conf_merge_value(conf->respawn, prev->respawn, 1);\n    ngx_conf_merge_uint_value(conf->nbuckets, prev->nbuckets, 1024);\n\n    for (n = 0; n < NGX_RTMP_EXEC_MAX; n++) {\n        if (ngx_rtmp_exec_merge_confs(&conf->conf[n], &prev->conf[n]) != NGX_OK)\n        {\n            return NGX_CONF_ERROR;\n        }\n\n        if (conf->conf[n].nelts) {\n            conf->active = 1;\n            prev->active = 1;\n        }\n    }\n\n    if (conf->conf[NGX_RTMP_EXEC_PULL].nelts > 0) {\n        conf->pull = ngx_pcalloc(cf->pool, sizeof(void *) * conf->nbuckets);\n        if (conf->pull == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_init_process(ngx_cycle_t *cycle)\n{\n#if !(NGX_WIN32)\n    ngx_rtmp_core_main_conf_t  *cmcf = ngx_rtmp_core_main_conf;\n    ngx_rtmp_core_srv_conf_t  **cscf;\n    ngx_rtmp_conf_ctx_t        *cctx;\n    ngx_rtmp_exec_main_conf_t  *emcf;\n    ngx_rtmp_exec_t            *e;\n    ngx_uint_t                  n;\n\n    if (cmcf == NULL || cmcf->servers.nelts == 0) {\n        return NGX_OK;\n    }\n\n    /* execs are always started by the first worker */\n    if (ngx_process_slot) {\n        return NGX_OK;\n    }\n\n    cscf = cmcf->servers.elts;\n    cctx = (*cscf)->ctx;\n    emcf = cctx->main_conf[ngx_rtmp_exec_module.ctx_index];\n\n    /* FreeBSD note:\n     * When worker is restarted, child process (ffmpeg) will\n     * not be terminated if it's connected to another\n     * (still alive) worker. That leads to starting\n     * another instance of exec_static process.\n     * Need to kill previously started processes.\n     *\n     * On Linux \"prctl\" syscall is used to kill child\n     * when nginx worker is terminated.\n     */\n\n    e = emcf->static_exec.elts;\n    for (n = 0; n < emcf->static_exec.nelts; ++n, ++e) {\n        e->respawn_evt.data = e;\n        e->respawn_evt.log = e->log;\n        e->respawn_evt.handler = ngx_rtmp_exec_respawn;\n        ngx_post_event((&e->respawn_evt), &ngx_rtmp_init_queue);\n    }\n#endif\n\n    return NGX_OK;\n}\n\n\n#if !(NGX_WIN32)\nstatic void\nngx_rtmp_exec_respawn(ngx_event_t *ev)\n{\n    ngx_rtmp_exec_run((ngx_rtmp_exec_t *) ev->data);\n}\n\n\nstatic void\nngx_rtmp_exec_child_dead(ngx_event_t *ev)\n{\n    ngx_connection_t   *dummy_conn = ev->data;\n    ngx_rtmp_exec_t    *e;\n\n    e = dummy_conn->data;\n\n    ngx_log_error(NGX_LOG_INFO, e->log, 0,\n                  \"exec: child %ui exited; %s\", (ngx_int_t) e->pid,\n                  e->respawn_timeout == NGX_CONF_UNSET_MSEC ? \"respawning\" :\n                                                               \"ignoring\");\n\n    ngx_rtmp_exec_kill(e, 0);\n\n    if (e->respawn_timeout == NGX_CONF_UNSET_MSEC) {\n        return;\n    }\n\n    if (e->respawn_timeout == 0) {\n        ngx_rtmp_exec_run(e);\n        return;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, e->log, 0,\n                   \"exec: schedule respawn %Mmsec\", e->respawn_timeout);\n\n    e->respawn_evt.data = e;\n    e->respawn_evt.log = e->log;\n    e->respawn_evt.handler = ngx_rtmp_exec_respawn;\n\n    ngx_add_timer(&e->respawn_evt, e->respawn_timeout);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_kill(ngx_rtmp_exec_t *e, ngx_int_t kill_signal)\n{\n    if (e->respawn_evt.timer_set) {\n        ngx_del_timer(&e->respawn_evt);\n    }\n\n    if (e->read_evt.active) {\n        ngx_del_event(&e->read_evt, NGX_READ_EVENT, 0);\n    }\n\n    if (e->active == 0) {\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, e->log, 0,\n                  \"exec: terminating child %ui\", (ngx_int_t) e->pid);\n\n    e->active = 0;\n    close(e->pipefd);\n    if (e->save_pid) {\n        *e->save_pid = NGX_INVALID_PID;\n    }\n\n    if (kill_signal == 0) {\n        return NGX_OK;\n    }\n\n    if (kill(e->pid, kill_signal) == -1) {\n        ngx_log_error(NGX_LOG_INFO, e->log, ngx_errno,\n                      \"exec: kill failed pid=%i\", (ngx_int_t) e->pid);\n    } else {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, e->log, 0,\n                       \"exec: killed pid=%i\", (ngx_int_t) e->pid);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_run(ngx_rtmp_exec_t *e)\n{\n    int                     fd, ret, maxfd, pipefd[2];\n    char                  **args, **arg_out;\n    ngx_pid_t               pid;\n    ngx_str_t              *arg_in, a;\n    ngx_uint_t              n;\n    ngx_rtmp_exec_conf_t   *ec;\n\n    ec = e->conf;\n\n    ngx_log_error(NGX_LOG_INFO, e->log, 0,\n                  \"exec: starting %s child '%V'\",\n                  e->managed ? \"managed\" : \"unmanaged\", &ec->cmd);\n\n    pipefd[0] = -1;\n    pipefd[1] = -1;\n\n    if (e->managed) {\n\n        if (e->active) {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, e->log, 0,\n                           \"exec: already active '%V'\", &ec->cmd);\n            return NGX_OK;\n        }\n\n        if (pipe(pipefd) == -1) {\n            ngx_log_error(NGX_LOG_INFO, e->log, ngx_errno,\n                          \"exec: pipe failed\");\n            return NGX_ERROR;\n        }\n\n        /* make pipe write end survive through exec */\n\n        ret = fcntl(pipefd[1], F_GETFD);\n\n        if (ret != -1) {\n            ret &= ~FD_CLOEXEC;\n            ret = fcntl(pipefd[1], F_SETFD, ret);\n        }\n\n        if (ret == -1) {\n\n            close(pipefd[0]);\n            close(pipefd[1]);\n\n            ngx_log_error(NGX_LOG_INFO, e->log, ngx_errno,\n                          \"exec: fcntl failed\");\n\n            return NGX_ERROR;\n        }\n    }\n\n    pid = fork();\n\n    switch (pid) {\n\n        case -1:\n\n            /* failure */\n\n            if (pipefd[0] != -1) {\n                close(pipefd[0]);\n            }\n\n            if (pipefd[1] != -1) {\n                close(pipefd[1]);\n            }\n\n            ngx_log_error(NGX_LOG_INFO, e->log, ngx_errno,\n                          \"exec: fork failed\");\n\n            return NGX_ERROR;\n\n        case 0:\n\n            /* child */\n\n#if (NGX_LINUX)\n            if (e->managed) {\n                prctl(PR_SET_PDEATHSIG, e->kill_signal, 0, 0, 0);\n            }\n#endif\n\n            /* close all descriptors but pipe write end */\n\n            maxfd = sysconf(_SC_OPEN_MAX);\n            for (fd = 0; fd < maxfd; ++fd) {\n                if (fd == pipefd[1]) {\n                    continue;\n                }\n\n                close(fd);\n            }\n\n            fd = open(\"/dev/null\", O_RDWR);\n\n            dup2(fd, STDIN_FILENO);\n            dup2(fd, STDOUT_FILENO);\n            dup2(fd, STDERR_FILENO);\n\n            args = ngx_alloc((ec->args.nelts + 2) * sizeof(char *), e->log);\n            if (args == NULL) {\n                exit(1);\n            }\n\n            arg_in = ec->args.elts;\n            arg_out = args;\n            *arg_out++ = (char *) ec->cmd.data;\n\n            for (n = 0; n < ec->args.nelts; n++, ++arg_in) {\n\n                if (e->eval == NULL) {\n                    a = *arg_in;\n                } else {\n                    ngx_rtmp_eval(e->eval_ctx, arg_in, e->eval, &a, e->log);\n                }\n\n                if (ngx_rtmp_eval_streams(&a) != NGX_DONE) {\n                    continue;\n                }\n\n                *arg_out++ = (char *) a.data;\n            }\n\n            *arg_out = NULL;\n\n#if (NGX_DEBUG)\n            {\n                char    **p;\n\n                for (p = args; *p; p++) {\n                    ngx_write_fd(STDERR_FILENO, \"'\", 1);\n                    ngx_write_fd(STDERR_FILENO, *p, strlen(*p));\n                    ngx_write_fd(STDERR_FILENO, \"' \", 2);\n                }\n\n                ngx_write_fd(STDERR_FILENO, \"\\n\", 1);\n            }\n#endif\n\n            if (execvp((char *) ec->cmd.data, args) == -1) {\n                char    *msg;\n\n                msg = strerror(errno);\n\n                ngx_write_fd(STDERR_FILENO, \"execvp error: \", 14);\n                ngx_write_fd(STDERR_FILENO, msg, strlen(msg));\n                ngx_write_fd(STDERR_FILENO, \"\\n\", 1);\n\n                exit(1);\n            }\n\n            break;\n\n        default:\n\n            /* parent */\n\n            if (pipefd[1] != -1) {\n                close(pipefd[1]);\n            }\n\n            if (pipefd[0] != -1) {\n\n                e->active = 1;\n                e->pid = pid;\n                e->pipefd = pipefd[0];\n\n                if (e->save_pid) {\n                    *e->save_pid = pid;\n                }\n\n                e->dummy_conn.fd = e->pipefd;\n                e->dummy_conn.data = e;\n                e->dummy_conn.read  = &e->read_evt;\n                e->dummy_conn.write = &e->write_evt;\n                e->read_evt.data  = &e->dummy_conn;\n                e->write_evt.data = &e->dummy_conn;\n\n                e->read_evt.log = e->log;\n                e->read_evt.handler = ngx_rtmp_exec_child_dead;\n\n                if (ngx_add_event(&e->read_evt, NGX_READ_EVENT, 0) != NGX_OK) {\n                    ngx_log_error(NGX_LOG_INFO, e->log, ngx_errno,\n                                  \"exec: failed to add child control event\");\n                }\n            }\n\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, e->log, 0,\n                           \"exec: child '%V' started pid=%i\",\n                           &ec->cmd, (ngx_int_t) pid);\n            break;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_init_ctx(ngx_rtmp_session_t *s, u_char name[NGX_RTMP_MAX_NAME],\n    u_char args[NGX_RTMP_MAX_ARGS], ngx_uint_t flags)\n{\n    ngx_uint_t                  n;\n    ngx_array_t                *push_conf;\n    ngx_rtmp_exec_t            *e;\n    ngx_rtmp_exec_ctx_t        *ctx;\n    ngx_rtmp_exec_conf_t       *ec;\n    ngx_rtmp_exec_app_conf_t   *eacf;\n    ngx_rtmp_exec_main_conf_t  *emcf;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n\n    if (ctx != NULL) {\n        goto done;\n    }\n\n    ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_exec_ctx_t));\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_exec_module);\n\n    eacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_exec_module);\n\n    emcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_exec_module);\n\n    push_conf = &eacf->conf[NGX_RTMP_EXEC_PUSH];\n\n    if (push_conf->nelts > 0) {\n\n        if (ngx_array_init(&ctx->push_exec, s->connection->pool,\n                           push_conf->nelts,\n                           sizeof(ngx_rtmp_exec_t)) != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        e = ngx_array_push_n(&ctx->push_exec, push_conf->nelts);\n\n        if (e == NULL) {\n            return NGX_ERROR;\n        }\n\n        ec = push_conf->elts;\n\n        for (n = 0; n < push_conf->nelts; n++, e++, ec++) {\n            ngx_memzero(e, sizeof(*e));\n            e->conf = ec;\n            e->managed = 1;\n            e->log = s->connection->log;\n            e->eval = ngx_rtmp_exec_push_eval;\n            e->eval_ctx = s;\n            e->kill_signal = emcf->kill_signal;\n            e->respawn_timeout = (eacf->respawn ? emcf->respawn_timeout :\n                                  NGX_CONF_UNSET_MSEC);\n        }\n    }\n\ndone:\n\n    ngx_memcpy(ctx->name, name, NGX_RTMP_MAX_NAME);\n    ngx_memcpy(ctx->args, args, NGX_RTMP_MAX_ARGS);\n\n    ctx->flags |= flags;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_init_pull_ctx(ngx_rtmp_session_t *s,\n    u_char name[NGX_RTMP_MAX_NAME])\n{\n    size_t                      len;\n    ngx_uint_t                  n;\n    ngx_pool_t                 *pool;\n    ngx_array_t                *pull_conf;\n    ngx_rtmp_exec_t            *e;\n    ngx_rtmp_exec_ctx_t        *ctx;\n    ngx_rtmp_exec_conf_t       *ec;\n    ngx_rtmp_exec_pull_ctx_t   *pctx, **ppctx;\n    ngx_rtmp_exec_app_conf_t   *eacf;\n    ngx_rtmp_exec_main_conf_t  *emcf;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n    if (ctx->pull != NULL) {\n        return NGX_OK;\n    }\n\n    eacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_exec_module);\n\n    pull_conf = &eacf->conf[NGX_RTMP_EXEC_PULL];\n\n    if (pull_conf->nelts == 0) {\n        return NGX_OK;\n    }\n\n    emcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_exec_module);\n\n    len = ngx_strlen(name);\n\n    ppctx = &eacf->pull[ngx_hash_key(name, len) % eacf->nbuckets];\n\n    for (; *ppctx; ppctx = &(*ppctx)->next) {\n        pctx = *ppctx;\n\n        if (pctx->name.len == len &&\n            ngx_strncmp(name, pctx->name.data, len) == 0)\n        {\n            goto done;\n        }\n    }\n\n    pool = ngx_create_pool(4096, emcf->log);\n    if (pool == NULL) {\n        return NGX_ERROR;\n    }\n\n    pctx = ngx_pcalloc(pool, sizeof(ngx_rtmp_exec_pull_ctx_t));\n    if (pctx == NULL) {\n        goto error;\n    }\n\n    pctx->pool = pool;\n    pctx->name.len = len;\n    pctx->name.data = ngx_palloc(pool, len);\n\n    if (pctx->name.data == NULL) {\n        goto error;\n    }\n\n    ngx_memcpy(pctx->name.data, name, len);\n\n    pctx->app.len = s->app.len;\n    pctx->app.data = ngx_palloc(pool, s->app.len);\n\n    if (pctx->app.data == NULL) {\n        goto error;\n    }\n\n    ngx_memcpy(pctx->app.data, s->app.data, s->app.len);\n\n    if (ngx_array_init(&pctx->pull_exec, pool, pull_conf->nelts,\n                       sizeof(ngx_rtmp_exec_t)) != NGX_OK)\n    {\n        goto error;\n    }\n\n    e = ngx_array_push_n(&pctx->pull_exec, pull_conf->nelts);\n    if (e == NULL) {\n        goto error;\n    }\n\n    ec = pull_conf->elts;\n    for (n = 0; n < pull_conf->nelts; n++, e++, ec++) {\n        ngx_memzero(e, sizeof(*e));\n        e->conf = ec;\n        e->managed = 1;\n        e->log = emcf->log;\n        e->eval = ngx_rtmp_exec_pull_eval;\n        e->eval_ctx = pctx;\n        e->kill_signal = emcf->kill_signal;\n        e->respawn_timeout = (eacf->respawn ? emcf->respawn_timeout :\n                                              NGX_CONF_UNSET_MSEC);\n    }\n\n    *ppctx = pctx;\n\ndone:\n\n    ctx->pull = pctx;\n    ctx->pull->counter++;\n\n    return NGX_OK;\n\nerror:\n\n    ngx_destroy_pool(pool);\n\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_filter(ngx_rtmp_session_t *s, ngx_rtmp_exec_conf_t *ec)\n{\n    size_t                len;\n    ngx_str_t            *v;\n    ngx_uint_t            n;\n    ngx_rtmp_exec_ctx_t  *ctx;\n\n    if (ec->names.nelts == 0) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n\n    len = ngx_strlen(ctx->name);\n\n    v = ec->names.elts;\n    for (n = 0; n < ec->names.nelts; n++, s++) {\n        if (v->len == len && ngx_strncmp(v->data, ctx->name, len) == 0) {\n            return NGX_OK;\n        }\n    }\n\n    return NGX_DECLINED;\n}\n\n\nstatic void\nngx_rtmp_exec_unmanaged(ngx_rtmp_session_t *s, ngx_array_t *e, const char *op)\n{\n    ngx_uint_t             n;\n    ngx_rtmp_exec_t        en;\n    ngx_rtmp_exec_conf_t  *ec;\n\n    if (e->nelts == 0) {\n        return;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"exec: %s %uz unmanaged command(s)\", op, e->nelts);\n\n    ec = e->elts;\n    for (n = 0; n < e->nelts; n++, ec++) {\n        if (ngx_rtmp_exec_filter(s, ec) != NGX_OK) {\n            continue;\n        }\n\n        ngx_memzero(&en, sizeof(ngx_rtmp_exec_t));\n\n        en.conf = ec;\n        en.eval = ngx_rtmp_exec_event_eval;\n        en.eval_ctx = s;\n        en.log = s->connection->log;\n\n        ngx_rtmp_exec_run(&en);\n    }\n}\n\n\nstatic void\nngx_rtmp_exec_managed(ngx_rtmp_session_t *s, ngx_array_t *e, const char *op)\n{\n    ngx_uint_t        n;\n    ngx_rtmp_exec_t  *en;\n\n    if (e->nelts == 0) {\n        return;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"exec: %s %uz managed command(s)\", op, e->nelts);\n\n    en = e->elts;\n    for (n = 0; n < e->nelts; n++, en++) {\n        if (ngx_rtmp_exec_filter(s, en->conf) == NGX_OK) {\n            ngx_rtmp_exec_run(en);\n        }\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_exec_ctx_t       *ctx;\n    ngx_rtmp_exec_app_conf_t  *eacf;\n\n    eacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_exec_module);\n\n    if (eacf == NULL || !eacf->active) {\n        goto next;\n    }\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    if (ngx_rtmp_exec_init_ctx(s, v->name, v->args, NGX_RTMP_EXEC_PUBLISHING)\n        != NGX_OK)\n    {\n        goto next;\n    }\n\n    ngx_rtmp_exec_unmanaged(s, &eacf->conf[NGX_RTMP_EXEC_PUBLISH], \"publish\");\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n\n    ngx_rtmp_exec_managed(s, &ctx->push_exec, \"push\");\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_exec_ctx_t       *ctx;\n    ngx_rtmp_exec_pull_ctx_t  *pctx;\n    ngx_rtmp_exec_app_conf_t  *eacf;\n\n    eacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_exec_module);\n\n    if (eacf == NULL || !eacf->active) {\n        goto next;\n    }\n\n    if (ngx_rtmp_exec_init_ctx(s, v->name, v->args, NGX_RTMP_EXEC_PLAYING)\n        != NGX_OK)\n    {\n        goto next;\n    }\n\n    ngx_rtmp_exec_unmanaged(s, &eacf->conf[NGX_RTMP_EXEC_PLAY], \"play\");\n\n    if (ngx_rtmp_exec_init_pull_ctx(s, v->name) != NGX_OK) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n    pctx = ctx->pull;\n\n    if (pctx && pctx->counter == 1) {\n        ngx_rtmp_exec_managed(s, &pctx->pull_exec, \"pull\");\n    }\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_close_stream(ngx_rtmp_session_t *s, ngx_rtmp_close_stream_t *v)\n{\n    size_t                     n;\n    ngx_rtmp_exec_t           *e;\n    ngx_rtmp_exec_ctx_t       *ctx;\n    ngx_rtmp_exec_pull_ctx_t  *pctx, **ppctx;\n    ngx_rtmp_exec_app_conf_t  *eacf;\n\n    eacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_exec_module);\n    if (eacf == NULL) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    if (ctx->flags & NGX_RTMP_EXEC_PUBLISHING) {\n        ngx_rtmp_exec_unmanaged(s, &eacf->conf[NGX_RTMP_EXEC_PUBLISH_DONE],\n                                \"publish_done\");\n    }\n\n    if (ctx->flags & NGX_RTMP_EXEC_PLAYING) {\n        ngx_rtmp_exec_unmanaged(s, &eacf->conf[NGX_RTMP_EXEC_PLAY_DONE],\n                                \"play_done\");\n    }\n\n    ctx->flags = 0;\n\n    if (ctx->push_exec.nelts > 0) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"exec: delete %uz push command(s)\",\n                       ctx->push_exec.nelts);\n\n        e = ctx->push_exec.elts;\n        for (n = 0; n < ctx->push_exec.nelts; n++, e++) {\n            ngx_rtmp_exec_kill(e, e->kill_signal);\n        }\n    }\n\n    pctx = ctx->pull;\n\n    if (pctx && --pctx->counter == 0) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"exec: delete %uz pull command(s)\",\n                       pctx->pull_exec.nelts);\n\n        e = pctx->pull_exec.elts;\n        for (n = 0; n < pctx->pull_exec.nelts; n++, e++) {\n            ngx_rtmp_exec_kill(e, e->kill_signal);\n        }\n\n        ppctx = &eacf->pull[ngx_hash_key(pctx->name.data, pctx->name.len) %\n                            eacf->nbuckets];\n\n        for (; *ppctx; ppctx = &(*ppctx)->next) {\n            if (pctx == *ppctx) {\n                *ppctx = pctx->next;\n                break;\n            }\n        }\n\n        ngx_destroy_pool(pctx->pool);\n    }\n\n    ctx->pull = NULL;\n\nnext:\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_record_done(ngx_rtmp_session_t *s, ngx_rtmp_record_done_t *v)\n{\n    u_char                     c;\n    ngx_uint_t                 ext, dir;\n    ngx_rtmp_exec_ctx_t       *ctx;\n    ngx_rtmp_exec_app_conf_t  *eacf;\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    eacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_exec_module);\n    if (eacf == NULL || !eacf->active) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_exec_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    ctx->recorder = v->recorder;\n    ctx->path = v->path;\n\n    ctx->dirname.data = ctx->path.data;\n    ctx->dirname.len = 0;\n\n    for (dir = ctx->path.len; dir > 0; dir--) {\n        c = ctx->path.data[dir - 1];\n        if (c == '/' || c == '\\\\') {\n            ctx->dirname.len = dir - 1;\n            break;\n        }\n    }\n\n    ctx->filename.data = ctx->path.data + dir;\n    ctx->filename.len = ctx->path.len - dir;\n\n    ctx->basename = ctx->filename;\n\n    for (ext = ctx->filename.len; ext > 0; ext--) {\n        if (ctx->filename.data[ext - 1] == '.') {\n            ctx->basename.len = ext - 1;\n            break;\n        }\n    }\n\n    ngx_rtmp_exec_unmanaged(s, &eacf->conf[NGX_RTMP_EXEC_RECORD_DONE],\n                            \"record_done\");\n\n    ngx_str_null(&v->recorder);\n    ngx_str_null(&v->path);\n\nnext:\n    return next_record_done(s, v);\n}\n#endif /* NGX_WIN32 */\n\n\nstatic char *\nngx_rtmp_exec_conf(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char  *p = conf;\n\n    size_t                     n, nargs;\n    ngx_str_t                 *s, *value, v;\n    ngx_array_t               *confs;\n    ngx_rtmp_exec_conf_t      *ec;\n    ngx_rtmp_exec_app_conf_t  *eacf;\n\n    confs = (ngx_array_t *) (p + cmd->offset);\n\n    eacf = ngx_rtmp_conf_get_module_app_conf(cf, ngx_rtmp_exec_module);\n\n    if (confs->nalloc == 0 && ngx_array_init(confs, cf->pool, 1,\n                                             sizeof(ngx_rtmp_exec_conf_t))\n                              != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    ec = ngx_array_push(confs);\n    if (ec == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(ec, sizeof(ngx_rtmp_exec_conf_t));\n\n    /* type is undefined for explicit execs */\n\n    ec->type = NGX_CONF_UNSET_UINT;\n    ec->cmd = value[1];\n\n    if (ngx_array_init(&ec->names, cf->pool, 1, sizeof(ngx_str_t)) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (cf->args->nelts == 2) {\n        return NGX_CONF_OK;\n    }\n\n    nargs = cf->args->nelts - 2;\n    if (ngx_array_init(&ec->args, cf->pool, nargs, sizeof(ngx_str_t)) != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    for (n = 2; n < cf->args->nelts; n++) {\n\n        v = value[n];\n\n        if (eacf->options == 1) {\n\n            if (v.len >= 5 && ngx_strncmp(v.data, \"name=\", 5) == 0) {\n\n                s = ngx_array_push(&ec->names);\n                if (s == NULL) {\n                    return NGX_CONF_ERROR;\n                }\n\n                v.data += 5;\n                v.len -= 5;\n\n                *s = v;\n\n                continue;\n            }\n        }\n\n        s = ngx_array_push(&ec->args);\n        if (s == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *s = v;\n    }\n\n    return NGX_CONF_OK;\n}\n\n/*\nstatic char *\nngx_rtmp_exec_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                       *rv;\n    ngx_str_t                  *value;\n    ngx_conf_t                  save;\n    ngx_array_t                *confs;\n    ngx_rtmp_conf_ctx_t        *ctx, *pctx;\n    ngx_rtmp_exec_conf_t       *ec, *eec;\n    ngx_rtmp_exec_app_conf_t   *eacf;\n    ngx_rtmp_exec_main_conf_t  *emcf;\n\n    value = cf->args->elts;\n\n    eacf = ngx_rtmp_conf_get_module_app_conf(cf, ngx_rtmp_exec_module);\n\n    emcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_exec_module);\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    pctx = cf->ctx;\n\n    ctx->main_conf = pctx->main_conf;\n    ctx->srv_conf  = pctx->srv_conf;\n\n    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ec = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_exec_conf_t));\n    if (ec == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ec->id = value[1];\n    ec->type = NGX_CONF_UNSET_UINT;\n\n    ctx->app_conf[ngx_rtmp_exec_module.ctx_index] = ec;\n\n    save = *cf;\n\n    cf->ctx = ctx;\n    cf->cmd_type = NGX_RTMP_EXEC_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n    *cf= save;\n\n    switch (ec->type) {\n\n        case NGX_RTMP_EXEC_STATIC:\n            confs = &emcf->static_conf;\n            break;\n\n        case NGX_CONF_UNSET_UINT:\n            return \"unspecified exec type\";\n\n        default:\n            confs = &eacf->conf[ec->type];\n    }\n\n    if (confs->nalloc == 0 && ngx_array_init(confs, cf->pool, 1,\n                                             sizeof(ngx_rtmp_exec_conf_t))\n                             != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    eec = ngx_array_push(confs);\n    if (eec == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *eec = *ec;\n\n    return rv;\n}\n*/\n\nstatic char *\nngx_rtmp_exec_kill_signal(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_exec_main_conf_t  *emcf = conf;\n\n    ngx_str_t  *value;\n\n    value = cf->args->elts;\n    value++;\n\n    emcf->kill_signal = ngx_atoi(value->data, value->len);\n    if (emcf->kill_signal != NGX_ERROR) {\n        return NGX_CONF_OK;\n    }\n\n#define NGX_RMTP_EXEC_SIGNAL(name)                                          \\\n    if (value->len == sizeof(#name) - 1 &&                                  \\\n        ngx_strncasecmp(value->data, (u_char *) #name, value->len) == 0)    \\\n    {                                                                       \\\n        emcf->kill_signal = SIG##name;                                      \\\n        return NGX_CONF_OK;                                                 \\\n    }\n\n    /* POSIX.1-1990 signals */\n\n#if !(NGX_WIN32)\n    NGX_RMTP_EXEC_SIGNAL(HUP);\n    NGX_RMTP_EXEC_SIGNAL(INT);\n    NGX_RMTP_EXEC_SIGNAL(QUIT);\n    NGX_RMTP_EXEC_SIGNAL(ILL);\n    NGX_RMTP_EXEC_SIGNAL(ABRT);\n    NGX_RMTP_EXEC_SIGNAL(FPE);\n    NGX_RMTP_EXEC_SIGNAL(KILL);\n    NGX_RMTP_EXEC_SIGNAL(SEGV);\n    NGX_RMTP_EXEC_SIGNAL(PIPE);\n    NGX_RMTP_EXEC_SIGNAL(ALRM);\n    NGX_RMTP_EXEC_SIGNAL(TERM);\n    NGX_RMTP_EXEC_SIGNAL(USR1);\n    NGX_RMTP_EXEC_SIGNAL(USR2);\n    NGX_RMTP_EXEC_SIGNAL(CHLD);\n    NGX_RMTP_EXEC_SIGNAL(CONT);\n    NGX_RMTP_EXEC_SIGNAL(STOP);\n    NGX_RMTP_EXEC_SIGNAL(TSTP);\n    NGX_RMTP_EXEC_SIGNAL(TTIN);\n    NGX_RMTP_EXEC_SIGNAL(TTOU);\n#endif\n\n#undef NGX_RMTP_EXEC_SIGNAL\n\n    return \"unknown signal\";\n}\n\n\nstatic ngx_int_t\nngx_rtmp_exec_postconfiguration(ngx_conf_t *cf)\n{\n#if !(NGX_WIN32)\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_exec_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_exec_play;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_exec_close_stream;\n\n    next_record_done = ngx_rtmp_record_done;\n    ngx_rtmp_record_done = ngx_rtmp_exec_record_done;\n\n#endif /* NGX_WIN32 */\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_flv_live_index_module.c",
          "type": "blob",
          "size": 1.2021484375,
          "content": "\n/*\n * Copyright (C) Winshining\n */\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_http_flv_live_module.h\"\n\n\nstatic ngx_rtmp_play_pt         next_play;\nstatic ngx_rtmp_close_stream_pt next_close_stream;\n\n\nstatic ngx_int_t ngx_rtmp_flv_live_index_postconfiguration(ngx_conf_t *cf);\n\n\nstatic ngx_rtmp_module_t ngx_rtmp_flv_live_module_ctx = {\n    NULL,\n    ngx_rtmp_flv_live_index_postconfiguration,  /* postconfiguration */\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\n\nstatic ngx_command_t ngx_rtmp_flv_live_index_commands[] = {\n    ngx_null_command\n};\n\n\nngx_module_t ngx_rtmp_flv_live_index_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_flv_live_module_ctx,\n    ngx_rtmp_flv_live_index_commands,\n    NGX_RTMP_MODULE,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_int_t\nngx_rtmp_flv_live_index_postconfiguration(ngx_conf_t *cf)\n{\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_http_flv_live_play;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_http_flv_live_close_stream;\n\n    http_flv_live_next_play = next_play;\n    http_flv_live_next_close_stream = next_close_stream;\n\n    return NGX_OK;\n}\n\n"
        },
        {
          "name": "ngx_rtmp_flv_module.c",
          "type": "blob",
          "size": 19,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_play_module.h\"\n#include \"ngx_rtmp_codec_module.h\"\n#include \"ngx_rtmp_streams.h\"\n\n\nstatic ngx_int_t ngx_rtmp_flv_postconfiguration(ngx_conf_t *cf);\nstatic void ngx_rtmp_flv_read_meta(ngx_rtmp_session_t *s, ngx_file_t *f);\nstatic ngx_int_t ngx_rtmp_flv_timestamp_to_offset(ngx_rtmp_session_t *s,\n       ngx_file_t *f, ngx_int_t timestamp);\nstatic ngx_int_t ngx_rtmp_flv_init(ngx_rtmp_session_t *s, ngx_file_t *f,\n       ngx_int_t aindex, ngx_int_t vindex);\nstatic ngx_int_t ngx_rtmp_flv_start(ngx_rtmp_session_t *s, ngx_file_t *f);\nstatic ngx_int_t ngx_rtmp_flv_seek(ngx_rtmp_session_t *s, ngx_file_t *f,\n       ngx_uint_t offset);\nstatic ngx_int_t ngx_rtmp_flv_stop(ngx_rtmp_session_t *s, ngx_file_t *f);\nstatic ngx_int_t ngx_rtmp_flv_send(ngx_rtmp_session_t *s, ngx_file_t *f,\n                                   ngx_uint_t *ts);\n\n\ntypedef struct {\n    ngx_uint_t                          nelts;\n    ngx_uint_t                          offset;\n} ngx_rtmp_flv_index_t;\n\n\ntypedef struct {\n    ngx_int_t                           offset;\n    ngx_int_t                           start_timestamp;\n    ngx_event_t                         write_evt;\n    uint32_t                            last_audio;\n    uint32_t                            last_video;\n    ngx_uint_t                          msg_mask;\n    uint32_t                            epoch;\n\n    unsigned                            meta_read:1;\n    ngx_rtmp_flv_index_t                filepositions;\n    ngx_rtmp_flv_index_t                times;\n} ngx_rtmp_flv_ctx_t;\n\n\n#define NGX_RTMP_FLV_BUFFER             (1024*1024)\n#define NGX_RTMP_FLV_BUFLEN_ADDON       1000\n#define NGX_RTMP_FLV_TAG_HEADER         11\n#define NGX_RTMP_FLV_DATA_OFFSET        13\n\n\nstatic u_char                           ngx_rtmp_flv_buffer[\n                                        NGX_RTMP_FLV_BUFFER];\nstatic u_char                           ngx_rtmp_flv_header[\n                                        NGX_RTMP_FLV_TAG_HEADER];\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_flv_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_flv_postconfiguration,         /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    NULL,                                   /* create app configuration */\n    NULL                                    /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_flv_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_flv_module_ctx,               /* module context */\n    NULL,                                   /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_int_t\nngx_rtmp_flv_fill_index(ngx_rtmp_amf_ctx_t *ctx, ngx_rtmp_flv_index_t *idx)\n{\n    uint32_t                        nelts;\n    ngx_buf_t                      *b;\n\n    /* we have AMF array pointed by context;\n     * need to extract its size (4 bytes) &\n     * save offset of actual array data */\n\n    b = ctx->link->buf;\n\n    if (b->last - b->pos < (ngx_int_t) ctx->offset + 4) {\n        return NGX_ERROR;\n    }\n\n    nelts = htonl(*(uint32_t *) (b->pos + ctx->offset));\n\n    idx->nelts = nelts;\n    idx->offset = ctx->offset + 4;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_init_index(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n\n    static ngx_rtmp_amf_ctx_t       filepositions_ctx;\n    static ngx_rtmp_amf_ctx_t       times_ctx;\n\n    static ngx_rtmp_amf_elt_t       in_keyframes[] = {\n\n        { NGX_RTMP_AMF_ARRAY | NGX_RTMP_AMF_CONTEXT,\n          ngx_string(\"filepositions\"),\n          &filepositions_ctx, 0 },\n\n        { NGX_RTMP_AMF_ARRAY | NGX_RTMP_AMF_CONTEXT,\n          ngx_string(\"times\"),\n          &times_ctx, 0 }\n    };\n\n    static ngx_rtmp_amf_elt_t       in_inf[] = {\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_string(\"keyframes\"),\n          in_keyframes, sizeof(in_keyframes) }\n    };\n\n    static ngx_rtmp_amf_elt_t       in_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_inf, sizeof(in_inf) },\n    };\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL || in == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: init index\");\n\n    ngx_memzero(&filepositions_ctx, sizeof(filepositions_ctx));\n    ngx_memzero(&times_ctx, sizeof(times_ctx));\n\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                             sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: init index error\");\n        return NGX_OK;\n    }\n\n    if (filepositions_ctx.link && ngx_rtmp_flv_fill_index(&filepositions_ctx,\n                                                          &ctx->filepositions)\n        != NGX_OK)\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: failed to init filepositions\");\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: filepositions nelts=%ui offset=%ui\",\n                   ctx->filepositions.nelts, ctx->filepositions.offset);\n\n    if (times_ctx.link && ngx_rtmp_flv_fill_index(&times_ctx,\n                                                  &ctx->times)\n        != NGX_OK)\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: failed to init times\");\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: times nelts=%ui offset=%ui\",\n                   ctx->times.nelts, ctx->times.offset);\n\n    return  NGX_OK;\n}\n\n\nstatic double\nngx_rtmp_flv_index_value(void *src)\n{\n    return *(double *) src;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_timestamp_to_offset(ngx_rtmp_session_t *s, ngx_file_t *f,\n    ngx_int_t timestamp)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n    ssize_t                         n, size;\n    ngx_uint_t                      offset, index, ret, nelts;\n    double                          v;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        goto rewind;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: lookup index start timestamp=%i\",\n                   timestamp);\n\n    if (ctx->meta_read == 0) {\n        ngx_rtmp_flv_read_meta(s, f);\n        ctx->meta_read = 1;\n    }\n\n    if (timestamp <= 0 || ctx->filepositions.nelts == 0\n                       || ctx->times.nelts == 0)\n    {\n        goto rewind;\n    }\n\n    /* read index table from file given offset */\n    offset = NGX_RTMP_FLV_DATA_OFFSET + NGX_RTMP_FLV_TAG_HEADER +\n             ctx->times.offset;\n\n    /* index should fit in the buffer */\n    nelts = ngx_min(ctx->times.nelts, sizeof(ngx_rtmp_flv_buffer) / 9);\n    size = nelts * 9;\n\n    n = ngx_read_file(f, ngx_rtmp_flv_buffer, size, offset);\n\n    if (n != size) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: could not read times index\");\n        goto rewind;\n    }\n\n    /*TODO: implement binary search */\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: lookup times nelts=%ui\", nelts);\n\n    for (index = 0; index < nelts - 1; ++index) {\n        v = ngx_rtmp_flv_index_value(ngx_rtmp_flv_buffer +\n                                     index * 9 + 1) * 1000;\n\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                      \"flv: lookup times index=%ui value=%ui\",\n                      index, (ngx_uint_t) v);\n\n        if (timestamp < v) {\n            break;\n        }\n    }\n\n    if (index >= ctx->filepositions.nelts) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: index out of bounds: %ui>=%ui\",\n                     index, ctx->filepositions.nelts);\n        goto rewind;\n    }\n\n    /* take value from filepositions */\n    offset = NGX_RTMP_FLV_DATA_OFFSET + NGX_RTMP_FLV_TAG_HEADER +\n             ctx->filepositions.offset + index * 9;\n\n    n = ngx_read_file(f, ngx_rtmp_flv_buffer, 8, offset + 1);\n\n    if (n != 8) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: could not read filepositions index\");\n        goto rewind;\n    }\n\n    ret = (ngx_uint_t) ngx_rtmp_flv_index_value(ngx_rtmp_flv_buffer);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: lookup index timestamp=%i offset=%ui\",\n                   timestamp, ret);\n\n    return ret;\n\nrewind:\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: lookup index timestamp=%i offset=begin\",\n                   timestamp);\n\n    return NGX_RTMP_FLV_DATA_OFFSET;\n}\n\n\nstatic void\nngx_rtmp_flv_read_meta(ngx_rtmp_session_t *s, ngx_file_t *f)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n    ssize_t                         n;\n    ngx_rtmp_header_t               h;\n    ngx_chain_t                    *out, in;\n    ngx_buf_t                       in_buf;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    uint32_t                        size;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: read meta\");\n\n    /* read tag header */\n    n = ngx_read_file(f, ngx_rtmp_flv_header, sizeof(ngx_rtmp_flv_header),\n                      NGX_RTMP_FLV_DATA_OFFSET);\n\n    if (n != sizeof(ngx_rtmp_flv_header)) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: could not read metadata tag header\");\n        return;\n    }\n\n    if (ngx_rtmp_flv_header[0] != NGX_RTMP_MSG_AMF_META) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                      \"flv: first tag is not metadata, giving up\");\n        return;\n    }\n\n    ngx_memzero(&h, sizeof(h));\n\n    h.type = NGX_RTMP_MSG_AMF_META;\n    h.msid = NGX_RTMP_MSID;\n    h.csid = NGX_RTMP_CSID_AMF;\n\n    size = ngx_rtmp_n3_to_h4(ngx_rtmp_flv_header + 1);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: metadata size=%D\", size);\n\n    if (size > sizeof(ngx_rtmp_flv_buffer)) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: too big metadata\");\n        return;\n    }\n\n    /* read metadata */\n    n = ngx_read_file(f, ngx_rtmp_flv_buffer, size,\n                      sizeof(ngx_rtmp_flv_header) +\n                      NGX_RTMP_FLV_DATA_OFFSET);\n\n    if (n != (ssize_t) size) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"flv: could not read metadata\");\n        return;\n    }\n\n    /* prepare input chain */\n    ngx_memzero(&in, sizeof(in));\n    ngx_memzero(&in_buf, sizeof(in_buf));\n\n    in.buf = &in_buf;\n    in_buf.pos  = ngx_rtmp_flv_buffer;\n    in_buf.last = ngx_rtmp_flv_buffer + size;\n\n    ngx_rtmp_flv_init_index(s, &in);\n\n    /* output chain */\n    out = ngx_rtmp_append_shared_bufs(cscf, NULL, &in);\n\n    ngx_rtmp_prepare_message(s, &h, NULL, out);\n    ngx_rtmp_send_message(s, out, 0);\n    ngx_rtmp_free_shared_chain(cscf, out);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_send(ngx_rtmp_session_t *s, ngx_file_t *f, ngx_uint_t *ts)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n    uint32_t                        last_timestamp;\n    ngx_rtmp_header_t               h, lh;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_chain_t                    *out, in;\n    ngx_buf_t                       in_buf;\n    ngx_int_t                       rc;\n    ssize_t                         n;\n    uint32_t                        buflen, end_timestamp, size;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->offset == -1) {\n        ctx->offset = ngx_rtmp_flv_timestamp_to_offset(s, f,\n                                                       ctx->start_timestamp);\n        ctx->start_timestamp = -1; /* set later from actual timestamp */\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: read tag at offset=%i\", ctx->offset);\n\n    /* read tag header */\n    n = ngx_read_file(f, ngx_rtmp_flv_header,\n                      sizeof(ngx_rtmp_flv_header), ctx->offset);\n\n    if (n != sizeof(ngx_rtmp_flv_header)) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: could not read flv tag header\");\n        return NGX_DONE;\n    }\n\n    /* parse header fields */\n    ngx_memzero(&h, sizeof(h));\n\n    h.msid = NGX_RTMP_MSID;\n    h.type = ngx_rtmp_flv_header[0];\n\n    size = ngx_rtmp_n3_to_h4(ngx_rtmp_flv_header + 1);\n    h.timestamp = ngx_rtmp_n3_to_h4(ngx_rtmp_flv_header + 4);\n    h.timestamp |= ((uint32_t) ngx_rtmp_flv_header[7] << 24);\n\n    ctx->offset += (sizeof(ngx_rtmp_flv_header) + size + 4);\n\n    last_timestamp = 0;\n\n    switch (h.type) {\n\n        case NGX_RTMP_MSG_AUDIO:\n            h.csid = NGX_RTMP_CSID_AUDIO;\n            last_timestamp = ctx->last_audio;\n            ctx->last_audio = h.timestamp;\n            break;\n\n        case NGX_RTMP_MSG_VIDEO:\n            h.csid = NGX_RTMP_CSID_VIDEO;\n            last_timestamp = ctx->last_video;\n            ctx->last_video = h.timestamp;\n            break;\n\n        default:\n            return NGX_OK;\n    }\n\n    ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: read tag type=%i size=%uD timestamp=%uD \"\n                  \"last_timestamp=%uD\",\n                  (ngx_int_t) h.type,size, h.timestamp, last_timestamp);\n\n    lh = h;\n    lh.timestamp = last_timestamp;\n\n    if (size > sizeof(ngx_rtmp_flv_buffer)) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: too big message: %D>%uz\", size,\n                      sizeof(ngx_rtmp_flv_buffer));\n        goto next;\n    }\n\n    /* read tag body */\n    n = ngx_read_file(f, ngx_rtmp_flv_buffer, size,\n                      ctx->offset - size - 4);\n\n    if (n != (ssize_t) size) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"flv: could not read flv tag\");\n        return NGX_ERROR;\n    }\n\n    /* prepare input chain */\n    ngx_memzero(&in, sizeof(in));\n    ngx_memzero(&in_buf, sizeof(in_buf));\n\n    in.buf = &in_buf;\n    in_buf.pos  = ngx_rtmp_flv_buffer;\n    in_buf.last = ngx_rtmp_flv_buffer + size;\n\n    /* output chain */\n    out = ngx_rtmp_append_shared_bufs(cscf, NULL, &in);\n\n    ngx_rtmp_prepare_message(s, &h,\n                             ctx->msg_mask & ((ngx_uint_t) 1 << h.type) ?\n                             &lh : NULL, out);\n    rc = ngx_rtmp_send_message(s, out, 0);\n    ngx_rtmp_free_shared_chain(cscf, out);\n\n    if (rc == NGX_AGAIN) {\n        return NGX_AGAIN;\n    }\n\n    if (rc != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ctx->msg_mask |= ((ngx_uint_t) 1 << h.type);\n\nnext:\n    if (ctx->start_timestamp == -1) {\n        ctx->start_timestamp = h.timestamp;\n        ctx->epoch = ngx_current_msec;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                      \"flv: start_timestamp=%i\", ctx->start_timestamp);\n        return NGX_OK;\n    }\n\n    buflen = s->buflen + NGX_RTMP_FLV_BUFLEN_ADDON;\n\n    end_timestamp = (ngx_current_msec - ctx->epoch) +\n                     ctx->start_timestamp + buflen;\n\n    ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n           \"flv: %s wait=%D timestamp=%D end_timestamp=%D bufen=%i\",\n            h.timestamp > end_timestamp ? \"schedule\" : \"advance\",\n            h.timestamp > end_timestamp ? h.timestamp - end_timestamp : 0,\n            h.timestamp, end_timestamp, (ngx_int_t) buflen);\n\n    s->current_time = h.timestamp;\n\n    /* too much data sent; schedule timeout */\n    if (h.timestamp > end_timestamp) {\n        return h.timestamp - end_timestamp;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_init(ngx_rtmp_session_t *s, ngx_file_t *f, ngx_int_t aindex,\n                  ngx_int_t vindex)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        ctx = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_flv_ctx_t));\n\n        if (ctx == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_flv_module);\n    }\n\n    ngx_memzero(ctx, sizeof(*ctx));\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_start(ngx_rtmp_session_t *s, ngx_file_t *f)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: start\");\n\n    ctx->offset = -1;\n    ctx->msg_mask = 0;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_seek(ngx_rtmp_session_t *s, ngx_file_t *f, ngx_uint_t timestamp)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: seek timestamp=%ui\", timestamp);\n\n    ctx->start_timestamp = timestamp;\n    ctx->epoch = ngx_current_msec;\n    ctx->offset = -1;\n    ctx->msg_mask = 0;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_stop(ngx_rtmp_session_t *s, ngx_file_t *f)\n{\n    ngx_rtmp_flv_ctx_t             *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_flv_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"flv: stop\");\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_flv_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_play_main_conf_t      *pmcf;\n    ngx_rtmp_play_fmt_t           **pfmt, *fmt;\n\n    pmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_play_module);\n\n    pfmt = ngx_array_push(&pmcf->fmts);\n\n    if (pfmt == NULL) {\n        return NGX_ERROR;\n    }\n\n    fmt = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_play_fmt_t));\n\n    if (fmt == NULL) {\n        return NGX_ERROR;\n    }\n\n    *pfmt = fmt;\n\n    ngx_str_set(&fmt->name, \"flv-format\");\n\n    ngx_str_null(&fmt->pfx); /* default fmt */\n    ngx_str_set(&fmt->sfx, \".flv\");\n\n    fmt->init  = ngx_rtmp_flv_init;\n    fmt->start = ngx_rtmp_flv_start;\n    fmt->seek  = ngx_rtmp_flv_seek;\n    fmt->stop  = ngx_rtmp_flv_stop;\n    fmt->send  = ngx_rtmp_flv_send;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_gop_cache_module.c",
          "type": "blob",
          "size": 28.654296875,
          "content": "\n/*\n * Copyright (C) Gnolizuh\n * Copyright (C) Winshining\n * Copyright (C) HeyJupiter\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include \"ngx_http_flv_live_module.h\"\n#include \"ngx_rtmp_gop_cache_module.h\"\n\n\nstatic ngx_rtmp_publish_pt       next_publish;\nstatic ngx_rtmp_play_pt          next_play;\nstatic ngx_rtmp_close_stream_pt  next_close_stream;\n\n\nstatic ngx_rtmp_gop_frame_t *ngx_rtmp_gop_cache_alloc_frame(\n    ngx_rtmp_session_t *s);\nstatic ngx_rtmp_gop_frame_t *ngx_rtmp_gop_cache_free_frame(\n    ngx_rtmp_session_t *s, ngx_rtmp_gop_frame_t *frame);\nstatic ngx_int_t ngx_rtmp_gop_cache_link_frame(ngx_rtmp_session_t *s,\n    ngx_rtmp_gop_frame_t *frame);\nstatic ngx_int_t ngx_rtmp_gop_cache_alloc_cache(ngx_rtmp_session_t *s);\nstatic ngx_rtmp_gop_cache_t *ngx_rtmp_gop_cache_free_cache(\n    ngx_rtmp_session_t *s, ngx_rtmp_gop_cache_t *cache);\nstatic void ngx_rtmp_gop_cache_cleanup(ngx_rtmp_session_t *s);\nstatic void ngx_rtmp_gop_cache_update(ngx_rtmp_session_t *s);\nstatic void ngx_rtmp_gop_cache_frame(ngx_rtmp_session_t *s, ngx_uint_t prio,\n    ngx_rtmp_header_t *ch, ngx_chain_t *frame);\nstatic void ngx_rtmp_gop_cache_send(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_gop_cache_av(ngx_rtmp_session_t *s,\n    ngx_rtmp_header_t *h, ngx_chain_t *in);\nstatic ngx_int_t ngx_rtmp_gop_cache_publish(ngx_rtmp_session_t *s,\n    ngx_rtmp_publish_t *v);\nstatic ngx_int_t ngx_rtmp_gop_cache_play(ngx_rtmp_session_t *s,\n    ngx_rtmp_play_t *v);\nstatic ngx_int_t ngx_rtmp_gop_cache_close_stream(ngx_rtmp_session_t *s,\n    ngx_rtmp_close_stream_t *v);\n\n\nstatic ngx_int_t ngx_rtmp_gop_cache_postconfiguration(ngx_conf_t *cf);\nstatic void *ngx_rtmp_gop_cache_create_app_conf(ngx_conf_t *cf);\nstatic char *ngx_rtmp_gop_cache_merge_app_conf(ngx_conf_t *cf,\n    void *parent, void *child);\n\n\nextern ngx_rtmp_live_proc_handler_t  *ngx_rtmp_live_proc_handlers\n                                      [NGX_RTMP_PROTOCOL_HTTP + 1];\nextern ngx_module_t                   ngx_http_flv_live_module;\n\n\nstatic ngx_command_t ngx_rtmp_gop_cache_commands[] = {\n    { ngx_string(\"gop_cache\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_gop_cache_app_conf_t, gop_cache),\n      NULL },\n\n    { ngx_string(\"gop_max_frame_count\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_gop_cache_app_conf_t, gop_max_frame_count),\n      NULL },\n\n    { ngx_string(\"gop_max_video_count\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_gop_cache_app_conf_t, gop_max_video_count),\n      NULL },\n\n    { ngx_string(\"gop_max_audio_count\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_gop_cache_app_conf_t, gop_max_audio_count),\n      NULL },\n\n    ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t ngx_rtmp_gop_cache_module_ctx = {\n    NULL,\n    ngx_rtmp_gop_cache_postconfiguration, /* postconfiguration */\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    ngx_rtmp_gop_cache_create_app_conf,   /* create application configuration */\n    ngx_rtmp_gop_cache_merge_app_conf     /* merge application configuration */\n};\n\n\nngx_module_t ngx_rtmp_gop_cache_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_gop_cache_module_ctx,\n    ngx_rtmp_gop_cache_commands,\n    NGX_RTMP_MODULE,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void *\nngx_rtmp_gop_cache_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_gop_cache_app_conf_t *gacf;\n\n    gacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_gop_cache_app_conf_t));\n    if (gacf == NULL) {\n        return NULL;\n    }\n\n    gacf->gop_cache = NGX_CONF_UNSET;\n    gacf->gop_cache_count = NGX_CONF_UNSET_SIZE;\n    gacf->gop_max_frame_count = NGX_CONF_UNSET_SIZE;\n    gacf->gop_max_audio_count = NGX_CONF_UNSET_SIZE;\n    gacf->gop_max_video_count = NGX_CONF_UNSET_SIZE;\n\n    return (void *) gacf;\n}\n\n\nstatic char *\nngx_rtmp_gop_cache_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_gop_cache_app_conf_t        *prev = parent;\n    ngx_rtmp_gop_cache_app_conf_t        *conf = child;\n\n    ngx_conf_merge_value(conf->gop_cache, prev->gop_cache, 0);\n    ngx_conf_merge_size_value(conf->gop_cache_count, prev->gop_cache_count, 2);\n    ngx_conf_merge_size_value(conf->gop_max_frame_count,\n            prev->gop_max_frame_count, 4096);\n    ngx_conf_merge_size_value(conf->gop_max_audio_count,\n            prev->gop_max_audio_count, 2048);\n    ngx_conf_merge_size_value(conf->gop_max_video_count,\n            prev->gop_max_video_count, 2048);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_rtmp_gop_frame_t *\nngx_rtmp_gop_cache_alloc_frame(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n    ngx_rtmp_gop_frame_t           *frame;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return NULL;\n    }\n\n    if (ctx->free_frame) {\n        frame = ctx->free_frame;\n        ctx->free_frame = frame->next;\n\n        return frame;\n    }\n\n    frame = ngx_pcalloc(ctx->pool, sizeof(ngx_rtmp_gop_frame_t));\n\n    return frame;\n}\n\n\nstatic ngx_rtmp_gop_frame_t *\nngx_rtmp_gop_cache_free_frame(ngx_rtmp_session_t *s,\n    ngx_rtmp_gop_frame_t *frame)\n{\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return NULL;\n    }\n\n    if (frame->frame) {\n        ngx_rtmp_free_shared_chain(cscf, frame->frame);\n        frame->frame = NULL;\n    }\n\n    if (frame->h.type == NGX_RTMP_MSG_VIDEO) {\n        ctx->video_frame_in_all--;\n    } else if (frame->h.type == NGX_RTMP_MSG_AUDIO) {\n        ctx->audio_frame_in_all--;\n    }\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n           \"gop free frame: type='%s' video_frame_in_cache=%uD \"\n           \"audio_frame_in_cache=%uD\",\n           frame->h.type == NGX_RTMP_MSG_VIDEO ? \"video\" : \"audio\",\n           ctx->video_frame_in_all, ctx->audio_frame_in_all);\n\n    return frame->next;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_link_frame(ngx_rtmp_session_t *s,\n    ngx_rtmp_gop_frame_t *frame)\n{\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n    ngx_rtmp_gop_cache_t           *cache;\n    ngx_rtmp_gop_frame_t          **iter;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    cache = ctx->cache_tail;\n    if (cache == NULL) {\n        return NGX_ERROR;\n    }\n\n    if(cache->frame_head == NULL) {\n        cache->frame_head = cache->frame_tail = frame;\n    } else {\n        iter = &cache->frame_tail->next;\n        *iter = frame;\n        cache->frame_tail = frame;\n    }\n\n    if (frame->h.type == NGX_RTMP_MSG_VIDEO) {\n        ctx->video_frame_in_all++;\n        cache->video_frame_in_this++;\n    } else if(frame->h.type == NGX_RTMP_MSG_AUDIO) {\n        ctx->audio_frame_in_all++;\n        cache->audio_frame_in_this++;\n    }\n\n    ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"gop link frame: type='%s' \"\n            \"ctx->video_frame_in_all=%uD \"\n            \"ctx->audio_frame_in_all=%uD \"\n            \"cache->video_frame_in_this=%uD \"\n            \"cache->audio_frame_in_this=%uD\",\n            frame->h.type == NGX_RTMP_MSG_VIDEO ? \"video\" : \"audio\",\n            ctx->video_frame_in_all, ctx->audio_frame_in_all,\n            cache->video_frame_in_this, cache->audio_frame_in_this);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_alloc_cache(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_codec_ctx_t           *codec_ctx;\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n    ngx_rtmp_gop_cache_t           *cache, **iter;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    codec_ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (codec_ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->free_cache) {\n        cache = ctx->free_cache;\n        ctx->free_cache = cache->next;\n\n        ngx_memzero(cache, sizeof(ngx_rtmp_gop_cache_t));\n    } else {\n        cache = ngx_pcalloc(ctx->pool, sizeof(ngx_rtmp_gop_cache_t));\n        if (cache == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    if (ctx->cache_head == NULL) {\n        ctx->cache_tail = ctx->cache_head = cache;\n    } else {\n        iter = &ctx->cache_tail->next;\n        *iter = cache;\n        ctx->cache_tail = cache;\n    }\n\n    ctx->gop_cache_count++;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n           \"gop alloc cache: gop_cache_count=%uD\", ctx->gop_cache_count);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_rtmp_gop_cache_t *\nngx_rtmp_gop_cache_free_cache(ngx_rtmp_session_t *s,\n    ngx_rtmp_gop_cache_t *cache)\n{\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n    ngx_rtmp_gop_frame_t           *frame;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return NULL;\n    }\n\n    for (frame = cache->frame_head; frame; frame = frame->next) {\n        ngx_rtmp_gop_cache_free_frame(s, frame);\n    }\n\n    if (cache->video_seq_header) {\n        ngx_rtmp_free_shared_chain(cscf, cache->video_seq_header);\n        cache->video_seq_header = NULL;\n    }\n\n    if (cache->audio_seq_header) {\n        ngx_rtmp_free_shared_chain(cscf, cache->audio_seq_header);\n        cache->audio_seq_header = NULL;\n    }\n\n    if (cache->meta) {\n        ngx_rtmp_free_shared_chain(cscf, cache->meta);\n        cache->meta_version = 0;\n        cache->meta = NULL;\n    }\n\n    cache->video_frame_in_this = 0;\n    cache->audio_frame_in_this = 0;\n\n    // recycle mem of gop frame\n    cache->frame_tail->next = ctx->free_frame;\n    ctx->free_frame = cache->frame_head;\n\n    ctx->gop_cache_count--;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n           \"gop free cache: gop_cache_count=%uD\", ctx->gop_cache_count);\n\n    return cache->next;\n}\n\n\nstatic void\nngx_rtmp_gop_cache_cleanup(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n    ngx_rtmp_gop_cache_t           *cache;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    for (cache = ctx->cache_head; cache; cache = cache->next) {\n        ngx_rtmp_gop_cache_free_cache(s, cache);\n    }\n\n    if (ctx->cache_head) {\n        ctx->cache_head->next = ctx->free_cache;\n        ctx->free_cache = ctx->cache_head;\n        ctx->cache_head = NULL;\n    }\n\n    ctx->cache_tail = NULL;\n    ctx->gop_cache_count = 0;\n    ctx->video_frame_in_all = 0;\n    ctx->audio_frame_in_all = 0;\n}\n\n\nstatic void\nngx_rtmp_gop_cache_update(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_gop_cache_app_conf_t        *gacf;\n    ngx_rtmp_gop_cache_ctx_t             *ctx;\n    ngx_rtmp_gop_cache_t                 *next;\n\n    gacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_gop_cache_module);\n    if (gacf == NULL) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    while (ctx->gop_cache_count > gacf->gop_cache_count) {\n        if (ctx->cache_head) {\n            /* remove the 1st gop */\n            next = ngx_rtmp_gop_cache_free_cache(s, ctx->cache_head);\n\n            ctx->cache_head->next = ctx->free_cache;\n            ctx->free_cache = ctx->cache_head;\n\n            ctx->cache_head = next;\n        }\n    }\n}\n\n\nstatic void\nngx_rtmp_gop_cache_frame(ngx_rtmp_session_t *s, ngx_uint_t prio,\n    ngx_rtmp_header_t *ch, ngx_chain_t *frame)\n{\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n    ngx_rtmp_codec_ctx_t           *codec_ctx;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_rtmp_gop_cache_app_conf_t  *gacf;\n    ngx_rtmp_gop_frame_t           *gf;\n\n    gacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_gop_cache_module);\n    if (gacf == NULL || !gacf->gop_cache) {\n        return;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    codec_ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (codec_ctx == NULL) {\n        return;\n    }\n\n    if (ch->type == NGX_RTMP_MSG_VIDEO) {\n        // drop non-IDR\n        if (prio != NGX_RTMP_VIDEO_KEY_FRAME && ctx->cache_head == NULL) {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                    \"gop cache: drop video non-keyframe timestamp=%uD\",\n                    ch->timestamp);\n\n            return;\n        }\n    }\n\n    // audio only\n    if (ctx->video_frame_in_all == 0 && ch->type == NGX_RTMP_MSG_AUDIO) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"gop cache: drop audio frame timestamp=%uD\",\n                       ch->timestamp);\n\n        return;\n    }\n\n    if (ch->type == NGX_RTMP_MSG_VIDEO && prio == NGX_RTMP_VIDEO_KEY_FRAME) {\n        if (ngx_rtmp_gop_cache_alloc_cache(s) != NGX_OK) {\n            return;\n        }\n    }\n\n    // save video seq header.\n    if (codec_ctx->avc_header &&\n        (ctx->cache_tail && ctx->cache_tail->video_seq_header == NULL))\n    {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"gop cache: add video seq header in new cache\");\n        ctx->cache_tail->video_seq_header = codec_ctx->avc_header;\n        ngx_rtmp_acquire_shared_chain(ctx->cache_tail->video_seq_header);\n    }\n\n    // save audio seq header.\n    if (codec_ctx->aac_header &&\n        (ctx->cache_tail && ctx->cache_tail->audio_seq_header == NULL))\n    {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"gop cache: add audio seq header in new cache\");\n        ctx->cache_tail->audio_seq_header = codec_ctx->aac_header;\n        ngx_rtmp_acquire_shared_chain(ctx->cache_tail->audio_seq_header);\n    }\n\n    // save metadata.\n    if (codec_ctx->meta &&\n        (ctx->cache_tail && ctx->cache_tail->meta == NULL))\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"gop cache: add meta in new cache, version=%ui\",\n                       codec_ctx->meta_version);\n        ctx->cache_tail->meta_version = codec_ctx->meta_version;\n        ctx->cache_tail->meta = codec_ctx->meta;\n        ngx_rtmp_acquire_shared_chain(ctx->cache_tail->meta);\n    }\n\n    gf = ngx_rtmp_gop_cache_alloc_frame(s);\n    if (gf == NULL) {\n        return;\n    }\n\n    gf->h = *ch;\n    gf->prio = prio;\n    gf->next = NULL;\n    gf->frame = ngx_rtmp_append_shared_bufs(cscf, NULL, frame);\n\n    if (ngx_rtmp_gop_cache_link_frame(s, gf) != NGX_OK) {\n        ngx_rtmp_free_shared_chain(cscf, gf->frame);\n        return;\n    }\n\n    if (ctx->video_frame_in_all > gacf->gop_max_video_count ||\n        ctx->audio_frame_in_all > gacf->gop_max_audio_count ||\n        (ctx->video_frame_in_all + ctx->audio_frame_in_all)\n        > gacf->gop_max_frame_count)\n    {\n        ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,\n               \"gop cache: video_frame_in_cache=%uD \"\n               \"audio_frame_in_cache=%uD max_video_count=%uD \"\n               \"max_audio_count=%uD gop_max_frame_count=%uD\",\n               ctx->video_frame_in_all, ctx->audio_frame_in_all,\n               gacf->gop_max_video_count, gacf->gop_max_audio_count,\n               gacf->gop_max_frame_count);\n\n        ngx_rtmp_gop_cache_cleanup(s);\n        return;\n    }\n\n    ngx_rtmp_gop_cache_update(s);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n           \"gop cache: cache packet type='%s' timestamp=%uD\",\n           gf->h.type == NGX_RTMP_MSG_AUDIO ? \"audio\" : \"video\",\n           gf->h.timestamp);\n}\n\n\nstatic void\nngx_rtmp_gop_cache_send(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_session_t                 *rs;\n    ngx_chain_t                        *pkt, *apkt, *acopkt, *meta;\n    ngx_chain_t                        *header, *coheader;\n    ngx_rtmp_live_ctx_t                *ctx, *pub_ctx;\n    ngx_http_flv_live_ctx_t            *hflctx;\n    ngx_rtmp_gop_cache_ctx_t           *gctx;\n    ngx_rtmp_live_app_conf_t           *lacf;\n    ngx_rtmp_gop_cache_t               *cache;\n    ngx_rtmp_gop_frame_t               *gf;\n    ngx_rtmp_header_t                   ch, lh, clh;\n    ngx_uint_t                          meta_version;\n    uint32_t                            delta;\n    ngx_int_t                           csidx;\n    ngx_rtmp_live_chunk_stream_t       *cs;\n    ngx_rtmp_live_proc_handler_t       *handler;\n    ngx_http_request_t                 *r;\n    ngx_rtmp_codec_ctx_t               *codec_ctx;\n    ngx_flag_t                          mandatory, error;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return;\n    }\n\n    /* pub_ctx saved the publisher info */\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL || ctx->stream == NULL ||\n        ctx->stream->pub_ctx == NULL || !ctx->stream->publishing) {\n        return;\n    }\n\n    pkt = NULL;\n    apkt = NULL;\n    acopkt = NULL;\n    header = NULL;\n    coheader = NULL;\n    meta_version = 0;\n\n    pub_ctx = ctx->stream->pub_ctx;\n    rs = pub_ctx->session;\n    s->publisher = rs;\n    handler = ngx_rtmp_live_proc_handlers[ctx->protocol];\n\n    if (rs == NULL) {\n        return;\n    }\n\n    gctx = ngx_rtmp_get_module_ctx(rs, ngx_rtmp_gop_cache_module);\n    if (gctx == NULL) {\n        return;\n    }\n\n    codec_ctx = ngx_rtmp_get_module_ctx(rs, ngx_rtmp_codec_module);\n    if (codec_ctx == NULL) {\n        return;\n    }\n\n    for (cache = gctx->cache_head; cache; cache = cache->next) {\n        if (s->connection == NULL || s->connection->destroyed) {\n            return;\n        }\n\n        if (ctx->protocol == NGX_RTMP_PROTOCOL_HTTP) {\n            r = s->data;\n            if (r == NULL) {\n                return;\n            }\n\n            hflctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n            if (!hflctx->header_sent) {\n                hflctx->header_sent = 1;\n                ngx_http_flv_live_send_header(s);\n            }\n        }\n\n        meta = NULL;\n\n        if (cache->meta && meta_version != cache->meta_version) {\n            meta = handler->meta_message_pt(s, cache->meta);\n            if (meta == NULL) {\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n\n            meta_version = cache->meta_version;\n        }\n\n        /* send metadata */\n        if (meta && meta_version != ctx->meta_version) {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"gop cache send: meta, version=%ui\", meta_version);\n\n            if (handler->send_message_pt(s, meta, 0) == NGX_ERROR) {\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n\n            ctx->meta_version = meta_version;\n            handler->free_message_pt(s, meta);\n        }\n\n        for (gf = cache->frame_head; gf; gf = gf->next) {\n            if (s->connection == NULL || s->connection->destroyed) {\n                return;\n            }\n\n            csidx = !(lacf->interleave || gf->h.type == NGX_RTMP_MSG_VIDEO);\n\n            cs = &ctx->cs[csidx];\n\n            lh = ch = gf->h;\n\n            if (cs->active) {\n                lh.timestamp = cs->timestamp;\n            }\n\n            clh = lh;\n            clh.type = (gf->h.type == NGX_RTMP_MSG_AUDIO ? NGX_RTMP_MSG_VIDEO :\n                                                           NGX_RTMP_MSG_AUDIO);\n\n            delta = ch.timestamp - lh.timestamp;\n            mandatory = 0;\n            error = 0;\n\n            if (ch.type == NGX_RTMP_MSG_AUDIO) {\n                if (codec_ctx->audio_codec_id == NGX_RTMP_AUDIO_AAC &&\n                    ngx_rtmp_is_codec_header(gf->frame))\n                {\n                    mandatory = 1;\n                }\n            } else {\n                if (codec_ctx->video_codec_id == NGX_RTMP_VIDEO_H264 &&\n                    ngx_rtmp_is_codec_header(gf->frame))\n                {\n                    mandatory = 1;\n                }\n            }\n\n            if (!cs->active) {\n                if (mandatory) {\n                    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                                   \"gop cache: skipping header\");\n\n                    continue;\n                }\n\n                switch (gf->h.type) {\n                    case NGX_RTMP_MSG_VIDEO:\n                        header = cache->video_seq_header;\n                        if (lacf->interleave) {\n                            coheader = cache->audio_seq_header;\n                        }\n                        break;\n                    default:\n                        header = cache->audio_seq_header;\n                        if (lacf->interleave) {\n                            coheader = cache->video_seq_header;\n                        }\n                }\n\n                if (header) {\n                    apkt = handler->append_message_pt(s, &lh, NULL, header);\n                    if (apkt == NULL) {\n                        error = 1;\n                        goto next;\n                    }\n                }\n\n                if (apkt && handler->send_message_pt(s, apkt, 0) != NGX_OK) {\n                    goto next;\n                }\n\n                if (coheader) {\n                    acopkt = handler->append_message_pt(s, &clh, NULL,\n                                                        coheader);\n                    if (acopkt == NULL) {\n                        error = 1;\n                        goto next;\n                    }\n                }\n\n                if (acopkt && handler->send_message_pt(s, acopkt, 0) != NGX_OK) {\n                    goto next;\n                }\n\n                cs->timestamp = lh.timestamp;\n                cs->active = 1;\n                s->current_time = cs->timestamp;\n            }\n\n            pkt = handler->append_message_pt(s, &ch, &lh, gf->frame);\n            if (pkt == NULL) {\n                error = 1;\n                goto next;\n            }\n\n            if (handler->send_message_pt(s, pkt, gf->prio) != NGX_OK) {\n                ++pub_ctx->ndropped;\n\n                cs->dropped += delta;\n\n                if (mandatory) {\n                    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                                   \"gop cache send: mandatory packet failed\");\n\n                    error = 1;\n                }\n\n                goto next;\n            }\n\n            ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                    \"gop cache send: tag type='%s' prio=%d ctimestamp=%uD \"\n                    \"ltimestamp=%uD\",\n                    gf->h.type == NGX_RTMP_MSG_AUDIO ? \"audio\" : \"video\",\n                    gf->prio, ch.timestamp, lh.timestamp);\n\n            cs->timestamp += delta;\n            s->current_time = cs->timestamp;\n\n        next:\n\n            if (pkt) {\n                handler->free_message_pt(s, pkt);\n                pkt = NULL;\n            }\n\n            if (apkt) {\n                handler->free_message_pt(s, apkt);\n                apkt = NULL;\n            }\n\n            if (acopkt) {\n                handler->free_message_pt(s, acopkt);\n                acopkt = NULL;\n            }\n\n            if (error) {\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n        }\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_av(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n    ngx_chain_t *in)\n{\n    ngx_rtmp_live_ctx_t            *ctx;\n    ngx_rtmp_gop_cache_app_conf_t  *gacf;\n    ngx_rtmp_live_app_conf_t       *lacf;\n    ngx_rtmp_live_chunk_stream_t   *cs;\n    ngx_rtmp_header_t               ch;\n    ngx_uint_t                      prio;\n    ngx_uint_t                      csidx;\n\n    gacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_gop_cache_module);\n    if (gacf == NULL || !gacf->gop_cache) {\n        return NGX_OK;\n    }\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return NGX_OK;\n    }\n\n    if (in == NULL || in->buf == NULL) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL || ctx->stream == NULL) {\n        return NGX_OK;\n    }\n\n    if (!ctx->publishing) {\n        return NGX_OK;\n    }\n\n    prio = (h->type == NGX_RTMP_MSG_VIDEO ?\n           ngx_rtmp_get_video_frame_type(in) : 0);\n\n    csidx = !(lacf->interleave || h->type == NGX_RTMP_MSG_VIDEO);\n\n    cs = &ctx->cs[csidx];\n\n    ngx_memzero(&ch, sizeof(ch));\n\n    ch.timestamp = h->timestamp;\n    ch.msid = NGX_RTMP_MSID;\n    ch.csid = cs->csid;\n    ch.type = h->type;\n\n    ngx_rtmp_gop_cache_frame(s, prio, &ch, in);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_live_ctx_t            *lctx;\n    ngx_rtmp_gop_cache_app_conf_t  *gacf;\n    ngx_rtmp_gop_cache_ctx_t       *ctx;\n\n    gacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_gop_cache_module);\n    if (gacf == NULL || !gacf->gop_cache) {\n        goto next;\n    }\n\n    lctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (lctx == NULL || !lctx->publishing) {\n        goto next;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                  \"gop cache publish: name='%s' type='%s'\",\n                  v->name, v->type);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool,\n                          sizeof(ngx_rtmp_gop_cache_ctx_t));\n        if (ctx == NULL) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"gop cache publish: failed to allocate for ctx\");\n\n            return NGX_ERROR;\n        }\n\n        ctx->pool = ngx_create_pool(NGX_GOP_CACHE_POOL_CREATE_SIZE,\n                                    s->connection->log);\n        if (ctx->pool == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_gop_cache_module);\n    }\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_gop_cache_app_conf_t  *gacf;\n#ifdef NGX_DEBUG\n    ngx_msec_t                      start, end;\n#endif\n\n    gacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_gop_cache_module);\n    if (gacf == NULL || !gacf->gop_cache) {\n        goto next;\n    }\n\n    ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"gop cache play: name='%s' start=%i duration=%i reset=%d\",\n            v->name, (ngx_int_t) v->start,\n            (ngx_int_t) v->duration, (ngx_uint_t) v->reset);\n\n#ifdef NGX_DEBUG\n    start = ngx_current_msec;\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"gop cache send: start_time=%uD\", start);\n#endif\n\n    ngx_rtmp_gop_cache_send(s);\n\n#ifdef NGX_DEBUG\n    end = ngx_current_msec;\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"gop cache send: end_time=%uD\", end);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"gop cache send: delta_time=%uD\", end - start);\n#endif\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_close_stream(ngx_rtmp_session_t *s,\n    ngx_rtmp_close_stream_t *v)\n{\n    ngx_rtmp_live_ctx_t            *ctx;\n    ngx_rtmp_gop_cache_ctx_t       *gctx;\n    ngx_rtmp_live_app_conf_t       *lacf;\n    ngx_rtmp_gop_cache_app_conf_t  *gacf;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    if (!ctx->publishing) {\n        goto next;\n    }\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL || !lacf->live) {\n        goto next;\n    }\n\n    gacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_gop_cache_module);\n    if (gacf == NULL || !gacf->gop_cache) {\n        goto next;\n    }\n\n    ngx_rtmp_gop_cache_cleanup(s);\n\n    gctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_gop_cache_module);\n    if (gctx == NULL) {\n        goto next;\n    }\n\n    if (gctx->pool) {\n        ngx_destroy_pool(gctx->pool);\n        gctx->pool = NULL;\n    }\n\nnext:\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_gop_cache_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    /* register raw event handlers */\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_AUDIO]);\n    *h = ngx_rtmp_gop_cache_av;\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_VIDEO]);\n    *h = ngx_rtmp_gop_cache_av;\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_gop_cache_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_gop_cache_play;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_gop_cache_close_stream;\n\n    return NGX_OK;\n}\n\n"
        },
        {
          "name": "ngx_rtmp_gop_cache_module.h",
          "type": "blob",
          "size": 1.57421875,
          "content": "\n/*\n * Copyright (C) Gnolizuh\n * Copyright (C) Winshining\n */\n\n#ifndef _NGX_RTMP_GOP_CACHE_H_INCLUDE_\n#define _NGX_RTMP_GOP_CACHE_H_INCLUDE_\n\n\n#define NGX_GOP_CACHE_POOL_CREATE_SIZE          4096\n\n\ntypedef struct ngx_rtmp_gop_frame_s ngx_rtmp_gop_frame_t;\ntypedef struct ngx_rtmp_gop_cache_s ngx_rtmp_gop_cache_t;\n\n\nstruct ngx_rtmp_gop_frame_s {\n    ngx_rtmp_header_t     h;\n    ngx_uint_t            prio;\n    ngx_chain_t          *frame;\n    ngx_rtmp_gop_frame_t *next;\n};\n\n\nstruct ngx_rtmp_gop_cache_s {\n    ngx_rtmp_gop_frame_t  *frame_head;\n    ngx_rtmp_gop_frame_t  *frame_tail;\n    ngx_rtmp_gop_cache_t  *next;\n\n    ngx_chain_t           *video_seq_header;\n    ngx_chain_t           *audio_seq_header;\n    ngx_chain_t           *meta;\n\n    ngx_uint_t             meta_version;\n\n    ngx_int_t              video_frame_in_this;\n    ngx_int_t              audio_frame_in_this;\n};\n\n\ntypedef struct ngx_rtmp_gop_cache_app_conf_s {\n    ngx_flag_t       gop_cache;\n    size_t           gop_cache_count;\n    size_t           gop_max_frame_count;\n    size_t           gop_max_video_count;\n    size_t           gop_max_audio_count;\n} ngx_rtmp_gop_cache_app_conf_t;\n\n\ntypedef struct ngx_rtmp_gop_cache_ctx_s {\n    ngx_pool_t                 *pool;\n    ngx_rtmp_gop_cache_t       *cache_head;\n    ngx_rtmp_gop_cache_t       *cache_tail;\n    ngx_rtmp_gop_cache_t       *free_cache;\n    ngx_rtmp_gop_frame_t       *free_frame;\n\n    size_t                      gop_cache_count;\n    size_t                      video_frame_in_all;\n    size_t                      audio_frame_in_all;\n} ngx_rtmp_gop_cache_ctx_t;\n\n\n#endif\n\n"
        },
        {
          "name": "ngx_rtmp_handler.c",
          "type": "blob",
          "size": 24.693359375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_live_module.h\"\n#include \"ngx_rtmp_amf.h\"\n\n\nstatic void ngx_rtmp_recv(ngx_event_t *rev);\nstatic void ngx_rtmp_send(ngx_event_t *rev);\nstatic void ngx_rtmp_ping(ngx_event_t *rev);\n\n\nngx_uint_t                  ngx_rtmp_naccepted;\n\n\nngx_rtmp_bandwidth_t        ngx_rtmp_bw_out;\nngx_rtmp_bandwidth_t        ngx_rtmp_bw_in;\n\n\n#ifdef NGX_DEBUG\nchar*\nngx_rtmp_message_type(uint8_t type)\n{\n    static char*    types[] = {\n        \"?\",\n        \"chunk_size\",\n        \"abort\",\n        \"ack\",\n        \"user\",\n        \"ack_size\",\n        \"bandwidth\",\n        \"edge\",\n        \"audio\",\n        \"video\",\n        \"?\",\n        \"?\",\n        \"?\",\n        \"?\",\n        \"?\",\n        \"amf3_meta\",\n        \"amf3_shared\",\n        \"amf3_cmd\",\n        \"amf_meta\",\n        \"amf_shared\",\n        \"amf_cmd\",\n        \"?\",\n        \"aggregate\"\n    };\n\n    return type < sizeof(types) / sizeof(types[0])\n        ? types[type]\n        : \"?\";\n}\n\n\nchar*\nngx_rtmp_user_message_type(uint16_t evt)\n{\n    static char*    evts[] = {\n        \"stream_begin\",\n        \"stream_eof\",\n        \"stream dry\",\n        \"set_buflen\",\n        \"recorded\",\n        \"\",\n        \"ping_request\",\n        \"ping_response\",\n    };\n\n    return evt < sizeof(evts) / sizeof(evts[0])\n        ? evts[evt]\n        : \"?\";\n}\n#endif\n\n\nvoid\nngx_rtmp_cycle(ngx_rtmp_session_t *s)\n{\n    ngx_connection_t           *c;\n\n    c = s->connection;\n\n    c->read->handler =  ngx_rtmp_recv;\n    c->write->handler = ngx_rtmp_send;\n\n    s->ping_evt.data = c;\n    s->ping_evt.log = c->log;\n    s->ping_evt.handler = ngx_rtmp_ping;\n    ngx_rtmp_reset_ping(s);\n\n    ngx_rtmp_recv(c->read);\n}\n\n\nngx_chain_t *\nngx_rtmp_alloc_in_buf(ngx_rtmp_session_t *s)\n{\n    ngx_chain_t        *cl;\n    ngx_buf_t          *b;\n    size_t              size;\n\n    if ((cl = ngx_alloc_chain_link(s->in_pool)) == NULL\n       || (cl->buf = ngx_calloc_buf(s->in_pool)) == NULL)\n    {\n        return NULL;\n    }\n\n    cl->next = NULL;\n    b = cl->buf;\n    size = s->in_chunk_size + NGX_RTMP_MAX_CHUNK_HEADER;\n\n    b->start = b->last = b->pos = ngx_palloc(s->in_pool, size);\n    if (b->start == NULL) {\n        return NULL;\n    }\n    b->end = b->start + size;\n\n    return cl;\n}\n\n\nvoid\nngx_rtmp_reset_ping(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t   *cscf;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf->ping == 0) {\n        return;\n    }\n\n    s->ping_active = 0;\n    s->ping_reset = 0;\n    ngx_add_timer(&s->ping_evt, cscf->ping);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"ping: wait %Mms\", cscf->ping);\n}\n\n\nstatic void\nngx_rtmp_ping(ngx_event_t *pev)\n{\n    ngx_connection_t           *c;\n    ngx_rtmp_session_t         *s;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n\n    c = pev->data;\n    s = c->data;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    /* i/o event has happened; no need to ping */\n    if (s->ping_reset) {\n        ngx_rtmp_reset_ping(s);\n        return;\n    }\n\n    if (s->ping_active) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                \"ping: unresponded\");\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    if (cscf->busy) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                \"ping: not busy between pings\");\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"ping: schedule %Mms\", cscf->ping_timeout);\n\n    if (ngx_rtmp_send_ping_request(s, (uint32_t)ngx_current_msec) != NGX_OK) {\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    s->ping_active = 1;\n    ngx_add_timer(pev, cscf->ping_timeout);\n}\n\n\nstatic void\nngx_rtmp_recv(ngx_event_t *rev)\n{\n    ngx_int_t                   n;\n    ngx_connection_t           *c;\n    ngx_rtmp_session_t         *s;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_rtmp_header_t          *h;\n    ngx_rtmp_stream_t          *st, *st0;\n    ngx_chain_t                *in, *head;\n    ngx_buf_t                  *b;\n    u_char                     *p, *old_pos;\n    size_t                      size, fsize, old_size;\n    uint8_t                     fmt, ext;\n    uint32_t                    csid, timestamp;\n\n    c = rev->data;\n    s = c->data;\n    b = NULL;\n    old_pos = NULL;\n    old_size = 0;\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (c->destroyed) {\n        return;\n    }\n\n    for( ;; ) {\n\n        st = &s->in_streams[s->in_csid];\n\n        /* allocate new buffer */\n        if (st->in == NULL) {\n            st->in = ngx_rtmp_alloc_in_buf(s);\n            if (st->in == NULL) {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"in buf alloc failed\");\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n        }\n\n        h  = &st->hdr;\n        in = st->in;\n        b  = in->buf;\n\n        if (old_size) {\n\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, c->log, 0,\n                    \"reusing formerly read data: %d\", old_size);\n\n            b->pos = b->start;\n\n            size = ngx_min((size_t) (b->end - b->start), old_size);\n            b->last = ngx_movemem(b->pos, old_pos, size);\n\n            if (s->in_chunk_size_changing) {\n                ngx_rtmp_finalize_set_chunk_size(s);\n            }\n\n        } else {\n\n            if (old_pos) {\n                b->pos = b->last = b->start;\n            }\n\n            n = c->recv(c, b->last, b->end - b->last);\n\n            if (n == NGX_ERROR || n == 0) {\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n\n            if (n == NGX_AGAIN) {\n                if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                    ngx_rtmp_finalize_session(s);\n                }\n                return;\n            }\n\n            s->ping_reset = 1;\n            ngx_rtmp_update_bandwidth(&ngx_rtmp_bw_in, n);\n            b->last += n;\n            s->in_bytes += n;\n\n            if (s->in_bytes >= 0xf0000000) {\n                ngx_log_debug0(NGX_LOG_DEBUG_RTMP, c->log, 0,\n                               \"resetting byte counter\");\n                s->in_bytes = 0;\n                s->in_last_ack = 0;\n            }\n\n            if (s->ack_size && s->in_bytes - s->in_last_ack >= s->ack_size) {\n\n                s->in_last_ack = s->in_bytes;\n\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, c->log, 0,\n                        \"sending RTMP ACK(%uD)\", s->in_bytes);\n\n                if (ngx_rtmp_send_ack(s, s->in_bytes)) {\n                    ngx_rtmp_finalize_session(s);\n                    return;\n                }\n            }\n        }\n\n        old_pos = NULL;\n        old_size = 0;\n\n        /* parse headers */\n        if (b->pos == b->start) {\n            p = b->pos;\n\n            /* chunk basic header */\n            fmt  = (*p >> 6) & 0x03;\n            csid = *p++ & 0x3f;\n\n            if (csid == 0) {\n                if (b->last - p < 1)\n                    continue;\n                csid = 64;\n                csid += *p++;\n\n            } else if (csid == 1) {\n                if (b->last - p < 2)\n                    continue;\n                csid = 64;\n                csid += *p++;\n                csid += ((uint32_t) *p++ << 8);\n            }\n\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, c->log, 0,\n                    \"RTMP bheader fmt=%d csid=%D\",\n                    (int)fmt, csid);\n\n            if (csid >= (uint32_t)cscf->max_streams) {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                    \"RTMP in chunk stream too big: %D >= %D\",\n                    csid, cscf->max_streams);\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n\n            /* link orphan */\n            if (s->in_csid == 0) {\n\n                /* unlink from stream #0 */\n                st->in = st->in->next;\n\n                /* link to new stream */\n                s->in_csid = csid;\n                st = &s->in_streams[csid];\n                if (st->in == NULL) {\n                    in->next = in;\n                } else {\n                    in->next = st->in->next;\n                    st->in->next = in;\n                }\n                st->in = in;\n                h = &st->hdr;\n                h->csid = csid;\n            }\n\n            ext = st->ext;\n            timestamp = st->dtime;\n            if (fmt <= 2 ) {\n                if (b->last - p < 3)\n                    continue;\n\n                /* timestamp: big-endian 3B -> little-endian 4B */\n\n                timestamp = 0;\n                timestamp |= ((uint32_t) *p++ << 16);\n                timestamp |= ((uint32_t) *p++ << 8);\n                timestamp |= *p++;\n\n                ext = (timestamp == 0x00ffffff);\n\n                if (fmt <= 1) {\n                    if (b->last - p < 4)\n                        continue;\n\n                    /* size: big-endian 3B -> little-endian 4B */\n\n                    h->mlen = 0;\n                    h->mlen |= ((uint32_t) *p++ << 16);\n                    h->mlen |= ((uint32_t) *p++ << 8);\n                    h->mlen |= *p++;\n\n                    h->type = *p++;\n\n                    if (fmt == 0) {\n                        if (b->last - p < 4)\n                            continue;\n\n                        /* stream: little-endian 4B */\n\n                        h->msid = *p++;\n                        h->msid |= ((uint32_t) *p++ << 8);\n                        h->msid |= ((uint32_t) *p++ << 16);\n                        h->msid |= ((uint32_t) *p++ << 24);\n                    }\n                }\n            }\n\n            /* extended header */\n            if (ext) {\n                if (b->last - p < 4)\n                    continue;\n\n                /* timestamp: big-endian 4B */\n\n                timestamp = 0;\n                timestamp |= ((uint32_t) *p++ << 24);\n                timestamp |= ((uint32_t) *p++ << 16);\n                timestamp |= ((uint32_t) *p++ << 8);\n                timestamp |= *p++;\n            }\n\n            if (st->len == 0) {\n                /* Messages with type=3 should\n                 * never have ext timestamp field\n                 * according to standard.\n                 * However that's not always the case\n                 * in real life */\n                st->ext = (ext && cscf->publish_time_fix);\n                if (fmt) {\n                    st->dtime = timestamp;\n                } else {\n                    h->timestamp = timestamp;\n                    st->dtime = 0;\n                }\n            }\n\n            ngx_log_debug8(NGX_LOG_DEBUG_RTMP, c->log, 0,\n                    \"RTMP mheader fmt=%d %s (%d) \"\n                    \"time=%uD+%uD mlen=%D len=%D msid=%D\",\n                    (int)fmt, ngx_rtmp_message_type(h->type), (int)h->type,\n                    h->timestamp, st->dtime, h->mlen, st->len, h->msid);\n\n            /* header done */\n            b->pos = p;\n\n            if (h->mlen > cscf->max_message) {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"too big message: %uz, %uz\",\n                                h->mlen, cscf->max_message);\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n        }\n\n        size = b->last - b->pos;\n        fsize = h->mlen - st->len;\n\n        if (size < ngx_min(fsize, s->in_chunk_size))\n            continue;\n\n        /* buffer is ready */\n\n        if (fsize > s->in_chunk_size) {\n            /* collect fragmented chunks */\n            st->len += s->in_chunk_size;\n            b->last = b->pos + s->in_chunk_size;\n            old_pos = b->last;\n            old_size = size - s->in_chunk_size;\n\n        } else {\n            /* handle! */\n            head = st->in->next;\n            st->in->next = NULL;\n            b->last = b->pos + fsize;\n            old_pos = b->last;\n            old_size = size - fsize;\n            st->len = 0;\n            h->timestamp += st->dtime;\n\n            if (ngx_rtmp_receive_message(s, h, head) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n\n            /* server configuration may change due to virtual server match */\n            if (s->server_changed) {\n                cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n                st = &s->in_streams[s->in_csid];\n\n                s->server_changed = 0;\n            }\n\n            if (s->in_chunk_size_changing) {\n                /* copy old data to a new buffer */\n                if (!old_size) {\n                    ngx_rtmp_finalize_set_chunk_size(s);\n                }\n\n            } else {\n                /* add used bufs to stream #0 */\n                st0 = &s->in_streams[0];\n                st->in->next = st0->in;\n                st0->in = head;\n                st->in = NULL;\n            }\n        }\n\n        s->in_csid = 0;\n    }\n}\n\n\nstatic void\nngx_rtmp_send(ngx_event_t *wev)\n{\n    ngx_connection_t           *c;\n    ngx_rtmp_session_t         *s;\n    ngx_int_t                   n;\n    ngx_rtmp_live_ctx_t        *lctx;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n\n    c = wev->data;\n    s = c->data;\n\n    if (c->destroyed) {\n        return;\n    }\n\n    if (wev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                \"client timed out\");\n        c->timedout = 1;\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    if (wev->timer_set) {\n        ngx_del_timer(wev);\n    }\n\n    if (s->out_chain == NULL && s->out_pos != s->out_last) {\n        s->out_chain = s->out[s->out_pos];\n        s->out_bpos = s->out_chain->buf->pos;\n    }\n\n    while (s->out_chain) {\n        n = c->send(c, s->out_bpos, s->out_chain->buf->last - s->out_bpos);\n\n        if (n == NGX_AGAIN || n == 0) {\n            ngx_add_timer(c->write, s->timeout);\n            if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n            }\n            return;\n        }\n\n        if (n < 0) {\n            ngx_rtmp_finalize_session(s);\n            return;\n        }\n\n        s->out_bytes += n;\n        s->ping_reset = 1;\n        ngx_rtmp_update_bandwidth(&ngx_rtmp_bw_out, n);\n        s->out_bpos += n;\n        if (s->out_bpos == s->out_chain->buf->last) {\n            s->out_chain = s->out_chain->next;\n            if (s->out_chain == NULL) {\n                cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n                ngx_rtmp_free_shared_chain(cscf, s->out[s->out_pos]);\n                ++s->out_pos;\n                s->out_pos %= s->out_queue;\n                if (s->out_pos == s->out_last) {\n                    break;\n                }\n                s->out_chain = s->out[s->out_pos];\n            }\n            s->out_bpos = s->out_chain->buf->pos;\n        }\n    }\n\n    lctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (lctx && !lctx->publishing && !wev->timer_set) {\n        ngx_add_timer(wev, s->timeout);\n    }\n\n    if (wev->active) {\n        ngx_del_event(wev, NGX_WRITE_EVENT, 0);\n    }\n\n    ngx_event_process_posted((ngx_cycle_t *) ngx_cycle, &s->posted_dry_events);\n}\n\n\nvoid\nngx_rtmp_prepare_message(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_rtmp_header_t *lh, ngx_chain_t *out)\n{\n    ngx_chain_t                *l;\n    u_char                     *p;\n    ngx_int_t                   hsize, thsize, nbufs;\n    uint32_t                    mlen, timestamp, ext_timestamp;\n    static uint8_t              hdrsize[] = { 12, 8, 4, 1 };\n    u_char                      th[7];\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    uint8_t                     fmt;\n    ngx_connection_t           *c;\n\n    c = s->connection;\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (h->csid >= (uint32_t)cscf->max_streams) {\n        ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                \"RTMP out chunk stream too big: %D >= %D\",\n                h->csid, cscf->max_streams);\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    /* detect packet size */\n    mlen = 0;\n    nbufs = 0;\n    for(l = out; l; l = l->next) {\n        mlen += (l->buf->last - l->buf->pos);\n        ++nbufs;\n    }\n\n    fmt = 0;\n    if (lh && lh->csid && h->msid == lh->msid) {\n        ++fmt;\n        if (h->type == lh->type && mlen && mlen == lh->mlen) {\n            ++fmt;\n            if (h->timestamp == lh->timestamp) {\n                ++fmt;\n            }\n        }\n\n        if (h->type == NGX_RTMP_MSG_VIDEO || h->type == NGX_RTMP_MSG_AUDIO) {\n            timestamp = h->timestamp - s->offset_timestamp - lh->timestamp;\n\n            if (lh->timestamp) {\n                timestamp += s->offset_timestamp;\n            }\n        } else {\n            timestamp = h->timestamp - lh->timestamp;\n        }\n    } else {\n        if (h->type == NGX_RTMP_MSG_VIDEO || h->type == NGX_RTMP_MSG_AUDIO) {\n            if (!s->offset_timestamp_set) {\n                s->offset_timestamp_set = 1;\n                s->offset_timestamp = h->timestamp;\n            } else if (h->timestamp == 0) {\n                s->offset_timestamp = 0;\n            }\n        }\n\n        timestamp = h->timestamp - s->offset_timestamp;\n    }\n\n    /*if (lh) {\n        *lh = *h;\n        lh->mlen = mlen;\n    }*/\n\n    hsize = hdrsize[fmt];\n\n    (void) nbufs;\n    ngx_log_debug8(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"RTMP prep %s (%d) fmt=%d csid=%uD timestamp=%uD \"\n            \"mlen=%uD msid=%uD nbufs=%d\",\n            ngx_rtmp_message_type(h->type), (int)h->type, (int)fmt,\n            h->csid, timestamp, mlen, h->msid, nbufs);\n\n    ext_timestamp = 0;\n    if (timestamp >= 0x00ffffff) {\n        ext_timestamp = timestamp;\n        timestamp = 0x00ffffff;\n        hsize += 4;\n    }\n\n    if (h->csid >= 64) {\n        ++hsize;\n        if (h->csid >= 320) {\n            ++hsize;\n        }\n    }\n\n    /* fill initial header */\n    out->buf->pos -= hsize;\n    p = out->buf->pos;\n\n    /* basic header */\n    *p = (fmt << 6);\n    if (h->csid >= 2 && h->csid <= 63) {\n        *p++ |= (((uint8_t)h->csid) & 0x3f);\n    } else if (h->csid >= 64 && h->csid < 320) {\n        ++p;\n        *p++ = (uint8_t)(h->csid - 64);\n    } else {\n        *p++ |= 1;\n        *p++ = (uint8_t)(h->csid - 64);\n        *p++ = (uint8_t)((h->csid - 64) >> 8);\n    }\n\n    /* create fmt3 header for successive fragments */\n    thsize = p - out->buf->pos;\n    ngx_memcpy(th, out->buf->pos, thsize);\n    th[0] |= 0xc0;\n\n    /* message header */\n    if (fmt <= 2) {\n        *p++ = (u_char) (timestamp >> 16);\n        *p++ = (u_char) (timestamp >> 8);\n        *p++ = (u_char) timestamp;\n\n        if (fmt <= 1) {\n            *p++ = (u_char) (mlen >> 16);\n            *p++ = (u_char) (mlen >> 8);\n            *p++ = (u_char) mlen;\n\n            *p++ = h->type;\n\n            if (fmt == 0) {\n                *p++ = (u_char) h->msid;\n                *p++ = (u_char) (h->msid >> 8);\n                *p++ = (u_char) (h->msid >> 16);\n                *p++ = (u_char) (h->msid >> 24);\n            }\n        }\n    }\n\n    /* extended header */\n    if (ext_timestamp) {\n        *p++ = (u_char) (ext_timestamp >> 24);\n        *p++ = (u_char) (ext_timestamp >> 16);\n        *p++ = (u_char) (ext_timestamp >> 8);\n        *p++ = (u_char) ext_timestamp;\n\n        /* This CONTRADICTS the standard\n         * but that's the way flash client\n         * wants data to be encoded;\n         * ffmpeg complains */\n        if (cscf->play_time_fix) {\n            ngx_memcpy(&th[thsize], p - 4, 4);\n            thsize += 4;\n        }\n    }\n\n    /* append headers to successive fragments */\n    for(out = out->next; out; out = out->next) {\n        out->buf->pos -= thsize;\n        ngx_memcpy(out->buf->pos, th, thsize);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_message(ngx_rtmp_session_t *s, ngx_chain_t *out,\n        ngx_uint_t priority)\n{\n    ngx_uint_t                      nmsg;\n\n    nmsg = (s->out_last + s->out_queue - s->out_pos) % s->out_queue + 1;\n\n    if (priority > 3) {\n        priority = 3;\n    }\n\n    /* drop packet?\n     * Note we always leave 1 slot free */\n    if (nmsg + priority * s->out_queue / 4 >= s->out_queue) {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"RTMP drop message bufs=%ui, priority=%ui\",\n                nmsg, priority);\n\n        return NGX_AGAIN;\n    }\n\n    s->out[s->out_last++] = out;\n    s->out_last %= s->out_queue;\n\n    ngx_rtmp_acquire_shared_chain(out);\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"RTMP send nmsg=%ui, priority=%ui #%ui\",\n            nmsg, priority, s->out_last);\n\n    if (priority && s->out_buffer && nmsg < s->out_cork) {\n        return NGX_OK;\n    }\n\n    if (!s->connection->write->active) {\n        ngx_rtmp_send(s->connection->write);\n        /*return ngx_add_event(s->connection->write, NGX_WRITE_EVENT, NGX_CLEAR_EVENT);*/\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_receive_message(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in)\n{\n    ngx_rtmp_core_main_conf_t  *cmcf;\n    ngx_array_t                *evhs;\n    size_t                      n;\n    ngx_rtmp_handler_pt        *evh;\n\n    cmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_core_module);\n\n#ifdef NGX_DEBUG\n    {\n        int             nbufs;\n        ngx_chain_t    *ch;\n\n        for(nbufs = 1, ch = in;\n                ch->next;\n                ch = ch->next, ++nbufs);\n\n        ngx_log_debug7(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"RTMP recv %s (%d) csid=%D timestamp=%D \"\n                \"mlen=%D msid=%D nbufs=%d\",\n                ngx_rtmp_message_type(h->type), (int)h->type,\n                h->csid, h->timestamp, h->mlen, h->msid, nbufs);\n    }\n#endif\n\n    if (h->type > NGX_RTMP_MSG_MAX) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"unexpected RTMP message type: %d\", (int)h->type);\n        return NGX_OK;\n    }\n\n    evhs = &cmcf->events[h->type];\n    evh = evhs->elts;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"nhandlers: %d\", evhs->nelts);\n\n    for(n = 0; n < evhs->nelts; ++n, ++evh) {\n        if (!evh) {\n            continue;\n        }\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"calling handler %d\", n);\n\n        switch ((*evh)(s, h, in)) {\n            case NGX_ERROR:\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                        \"handler %d failed\", n);\n                return NGX_ERROR;\n            case NGX_DONE:\n                return NGX_OK;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_set_chunk_size(ngx_rtmp_session_t *s, ngx_uint_t size)\n{\n    ngx_rtmp_core_srv_conf_t           *cscf;\n    ngx_chain_t                        *li, *fli, *lo, *flo;\n    ngx_buf_t                          *bi, *bo;\n    ngx_int_t                           n;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n        \"setting chunk_size=%ui\", size);\n\n    if (size > NGX_RTMP_MAX_CHUNK_SIZE) {\n        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,\n                      \"too big RTMP chunk size:%ui\", size);\n        return NGX_ERROR;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    s->in_old_pool = s->in_pool;\n    s->in_chunk_size = size;\n    s->in_pool = ngx_create_pool(4096, s->connection->log);\n\n    /* copy existing chunk data */\n    if (s->in_old_pool) {\n        s->in_chunk_size_changing = 1;\n        s->in_streams[0].in = NULL;\n\n        for(n = 1; n < cscf->max_streams; ++n) {\n            /* stream buffer is circular\n             * for all streams except for the current one\n             * (which caused this chunk size change);\n             * we can simply ignore it */\n            li = s->in_streams[n].in;\n            if (li == NULL || li->next == NULL) {\n                s->in_streams[n].in = NULL;\n                continue;\n            }\n            /* move from last to the first */\n            li = li->next;\n            fli = li;\n            lo = ngx_rtmp_alloc_in_buf(s);\n            if (lo == NULL) {\n                return NGX_ERROR;\n            }\n            flo = lo;\n            for ( ;; ) {\n                bi = li->buf;\n                bo = lo->buf;\n\n                if (bo->end - bo->last >= bi->last - bi->pos) {\n                    bo->last = ngx_cpymem(bo->last, bi->pos,\n                            bi->last - bi->pos);\n                    li = li->next;\n                    if (li == fli)  {\n                        lo->next = flo;\n                        s->in_streams[n].in = lo;\n                        break;\n                    }\n                    continue;\n                }\n\n                bi->pos += (ngx_cpymem(bo->last, bi->pos,\n                            bo->end - bo->last) - bo->last);\n                lo->next = ngx_rtmp_alloc_in_buf(s);\n                lo = lo->next;\n                if (lo == NULL) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_finalize_set_chunk_size(ngx_rtmp_session_t *s)\n{\n    if (s->in_chunk_size_changing && s->in_old_pool) {\n        ngx_destroy_pool(s->in_old_pool);\n        s->in_old_pool = NULL;\n        s->in_chunk_size_changing = 0;\n    }\n    return NGX_OK;\n}\n\n\n"
        },
        {
          "name": "ngx_rtmp_handshake.c",
          "type": "blob",
          "size": 16.7998046875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n#include <openssl/hmac.h>\n#include <openssl/sha.h>\n\n\nstatic void ngx_rtmp_handshake_send(ngx_event_t *wev);\nstatic void ngx_rtmp_handshake_recv(ngx_event_t *rev);\nstatic void ngx_rtmp_handshake_done(ngx_rtmp_session_t *s);\n\n\n/* RTMP handshake :\n *\n *          =peer1=                      =peer2=\n * challenge ----> (.....[digest1]......) ----> 1537 bytes\n * response  <---- (...........[digest2]) <---- 1536 bytes\n *\n *\n * - both packets contain random bytes except for digests\n * - digest1 position is calculated on random packet bytes\n * - digest2 is always at the end of the packet\n *\n * digest1: HMAC_SHA256(packet, peer1_partial_key)\n * digest2: HMAC_SHA256(packet, HMAC_SHA256(digest1, peer2_full_key))\n */\n\n\n/* Handshake keys */\nstatic u_char\nngx_rtmp_server_key[] = {\n    'G', 'e', 'n', 'u', 'i', 'n', 'e', ' ', 'A', 'd', 'o', 'b', 'e', ' ',\n    'F', 'l', 'a', 's', 'h', ' ', 'M', 'e', 'd', 'i', 'a', ' ',\n    'S', 'e', 'r', 'v', 'e', 'r', ' ',\n    '0', '0', '1',\n\n    0xF0, 0xEE, 0xC2, 0x4A, 0x80, 0x68, 0xBE, 0xE8, 0x2E, 0x00, 0xD0, 0xD1,\n    0x02, 0x9E, 0x7E, 0x57, 0x6E, 0xEC, 0x5D, 0x2D, 0x29, 0x80, 0x6F, 0xAB,\n    0x93, 0xB8, 0xE6, 0x36, 0xCF, 0xEB, 0x31, 0xAE\n};\n\n\nstatic u_char\nngx_rtmp_client_key[] = {\n    'G', 'e', 'n', 'u', 'i', 'n', 'e', ' ', 'A', 'd', 'o', 'b', 'e', ' ',\n    'F', 'l', 'a', 's', 'h', ' ', 'P', 'l', 'a', 'y', 'e', 'r', ' ',\n    '0', '0', '1',\n\n    0xF0, 0xEE, 0xC2, 0x4A, 0x80, 0x68, 0xBE, 0xE8, 0x2E, 0x00, 0xD0, 0xD1,\n    0x02, 0x9E, 0x7E, 0x57, 0x6E, 0xEC, 0x5D, 0x2D, 0x29, 0x80, 0x6F, 0xAB,\n    0x93, 0xB8, 0xE6, 0x36, 0xCF, 0xEB, 0x31, 0xAE\n};\n\n\nstatic const u_char\nngx_rtmp_server_version[4] = {\n    0x0D, 0x0E, 0x0A, 0x0D\n};\n\n\nstatic const u_char\nngx_rtmp_client_version[4] = {\n    0x0C, 0x00, 0x0D, 0x0E\n};\n\n\n#define NGX_RTMP_HANDSHAKE_KEYLEN                   SHA256_DIGEST_LENGTH\n#define NGX_RTMP_HANDSHAKE_BUFSIZE                  1537\n\n\n#define NGX_RTMP_HANDSHAKE_SERVER_RECV_CHALLENGE    1\n#define NGX_RTMP_HANDSHAKE_SERVER_SEND_CHALLENGE    2\n#define NGX_RTMP_HANDSHAKE_SERVER_SEND_RESPONSE     3\n#define NGX_RTMP_HANDSHAKE_SERVER_RECV_RESPONSE     4\n#define NGX_RTMP_HANDSHAKE_SERVER_DONE              5\n\n\n#define NGX_RTMP_HANDSHAKE_CLIENT_SEND_CHALLENGE    6\n#define NGX_RTMP_HANDSHAKE_CLIENT_RECV_CHALLENGE    7\n#define NGX_RTMP_HANDSHAKE_CLIENT_RECV_RESPONSE     8\n#define NGX_RTMP_HANDSHAKE_CLIENT_SEND_RESPONSE     9\n#define NGX_RTMP_HANDSHAKE_CLIENT_DONE              10\n\n\nstatic ngx_str_t            ngx_rtmp_server_full_key\n    = { sizeof(ngx_rtmp_server_key), ngx_rtmp_server_key };\nstatic ngx_str_t            ngx_rtmp_server_partial_key\n    = { 36, ngx_rtmp_server_key };\n\nstatic ngx_str_t            ngx_rtmp_client_full_key\n    = { sizeof(ngx_rtmp_client_key), ngx_rtmp_client_key };\nstatic ngx_str_t            ngx_rtmp_client_partial_key\n    = { 30, ngx_rtmp_client_key };\n\n\nstatic ngx_int_t\nngx_rtmp_make_digest(ngx_str_t *key, ngx_buf_t *src,\n        u_char *skip, u_char *dst, ngx_log_t *log)\n{\n    static HMAC_CTX        *hmac;\n    unsigned int            len;\n\n    if (hmac == NULL) {\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n        static HMAC_CTX  shmac;\n        hmac = &shmac;\n        HMAC_CTX_init(hmac);\n#else\n        hmac = HMAC_CTX_new();\n        if (hmac == NULL) {\n            return NGX_ERROR;\n        }\n#endif\n    }\n\n    HMAC_Init_ex(hmac, key->data, key->len, EVP_sha256(), NULL);\n\n    if (skip && src->pos <= skip && skip <= src->last) {\n        if (skip != src->pos) {\n            HMAC_Update(hmac, src->pos, skip - src->pos);\n        }\n        if (src->last != skip + NGX_RTMP_HANDSHAKE_KEYLEN) {\n            HMAC_Update(hmac, skip + NGX_RTMP_HANDSHAKE_KEYLEN,\n                    src->last - skip - NGX_RTMP_HANDSHAKE_KEYLEN);\n        }\n    } else {\n        HMAC_Update(hmac, src->pos, src->last - src->pos);\n    }\n\n    HMAC_Final(hmac, dst, &len);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_find_digest(ngx_buf_t *b, ngx_str_t *key, size_t base, ngx_log_t *log)\n{\n    size_t                  n, offs;\n    u_char                  digest[NGX_RTMP_HANDSHAKE_KEYLEN];\n    u_char                 *p;\n\n    offs = 0;\n    for (n = 0; n < 4; ++n) {\n        offs += b->pos[base + n];\n    }\n    offs = (offs % 728) + base + 4;\n    p = b->pos + offs;\n\n    if (ngx_rtmp_make_digest(key, b, p, digest, log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_memcmp(digest, p, NGX_RTMP_HANDSHAKE_KEYLEN) == 0) {\n        return offs;\n    }\n\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_write_digest(ngx_buf_t *b, ngx_str_t *key, size_t base,\n        ngx_log_t *log)\n{\n    size_t                  n, offs;\n    u_char                 *p;\n\n    offs = 0;\n    for (n = 8; n < 12; ++n) {\n        offs += b->pos[base + n];\n    }\n    offs = (offs % 728) + base + 12;\n    p = b->pos + offs;\n\n    if (ngx_rtmp_make_digest(key, b, p, p, log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_fill_random_buffer(ngx_buf_t *b)\n{\n    for (; b->last != b->end; ++b->last) {\n        *b->last = (u_char) rand();\n    }\n}\n\n\nstatic ngx_buf_t *\nngx_rtmp_alloc_handshake_buffer(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_chain_t                *cl;\n    ngx_buf_t                  *b;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: allocating buffer\");\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (cscf->free_hs) {\n        cl = cscf->free_hs;\n        b = cl->buf;\n        cscf->free_hs = cl->next;\n        ngx_free_chain(cscf->pool, cl);\n\n    } else {\n        b = ngx_pcalloc(cscf->pool, sizeof(ngx_buf_t));\n        if (b == NULL) {\n            return NULL;\n        }\n        b->memory = 1;\n        b->start = ngx_pcalloc(cscf->pool, NGX_RTMP_HANDSHAKE_BUFSIZE);\n        if (b->start == NULL) {\n            return NULL;\n        }\n        b->end = b->start + NGX_RTMP_HANDSHAKE_BUFSIZE;\n    }\n\n    b->pos = b->last = b->start;\n\n    return b;\n}\n\n\nvoid\nngx_rtmp_free_handshake_buffers(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_chain_t                *cl;\n\n    if (s->hs_buf == NULL) {\n        return;\n    }\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    cl = ngx_alloc_chain_link(cscf->pool);\n    if (cl == NULL) {\n        return;\n    }\n    cl->buf = s->hs_buf;\n    cl->next = cscf->free_hs;\n    cscf->free_hs = cl;\n    s->hs_buf = NULL;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_handshake_create_challenge(ngx_rtmp_session_t *s,\n        const u_char version[4], ngx_str_t *key)\n{\n    ngx_buf_t          *b;\n\n    b = s->hs_buf;\n    b->last = b->pos = b->start;\n    *b->last++ = '\\x03';\n    *(uint32_t *) b->last = htonl(s->epoch);\n    b->last += 4;\n    b->last = ngx_cpymem(b->last, version, 4);\n    ngx_rtmp_fill_random_buffer(b);\n    ++b->pos;\n    if (ngx_rtmp_write_digest(b, key, 0, s->connection->log) != NGX_OK) {\n        return NGX_ERROR;\n    }\n    --b->pos;\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_handshake_parse_challenge(ngx_rtmp_session_t *s,\n        ngx_str_t *peer_key, ngx_str_t *key)\n{\n    ngx_buf_t              *b;\n    u_char                 *p;\n    ngx_int_t               offs;\n\n    b = s->hs_buf;\n    if (*b->pos != '\\x03') {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                \"handshake: unexpected RTMP version: %i\",\n                (ngx_int_t)*b->pos);\n        return NGX_ERROR;\n    }\n    ++b->pos;\n    s->peer_epoch = ntohl(*(uint32_t *) b->pos);\n\n    p = b->pos + 4;\n    ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: peer version=%i.%i.%i.%i epoch=%uD\",\n            (ngx_int_t)p[3], (ngx_int_t)p[2],\n            (ngx_int_t)p[1], (ngx_int_t)p[0],\n            (uint32_t)s->peer_epoch);\n    if (*(uint32_t *)p == 0) {\n        s->hs_old = 1;\n        return NGX_OK;\n    }\n\n    offs = ngx_rtmp_find_digest(b, peer_key, 772, s->connection->log);\n    if (offs == NGX_ERROR) {\n        offs = ngx_rtmp_find_digest(b, peer_key, 8, s->connection->log);\n    }\n    if (offs == NGX_ERROR) {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                \"handshake: digest not found\");\n        s->hs_old = 1;\n        return NGX_OK;\n    }\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: digest found at pos=%i\", offs);\n    b->pos += offs;\n    b->last = b->pos + NGX_RTMP_HANDSHAKE_KEYLEN;\n    s->hs_digest = ngx_palloc(s->connection->pool, NGX_RTMP_HANDSHAKE_KEYLEN);\n    if (ngx_rtmp_make_digest(key, b, NULL, s->hs_digest, s->connection->log)\n            != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_handshake_create_response(ngx_rtmp_session_t *s)\n{\n    ngx_buf_t          *b;\n    u_char             *p;\n    ngx_str_t           key;\n\n    b = s->hs_buf;\n    b->pos = b->last = b->start + 1;\n    ngx_rtmp_fill_random_buffer(b);\n    if (s->hs_digest) {\n        p = b->last - NGX_RTMP_HANDSHAKE_KEYLEN;\n        key.data = s->hs_digest;\n        key.len = NGX_RTMP_HANDSHAKE_KEYLEN;\n        if (ngx_rtmp_make_digest(&key, b, p, p, s->connection->log) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_handshake_done(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_free_handshake_buffers(s);\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: done\");\n\n    if (ngx_rtmp_fire_event(s, NGX_RTMP_HANDSHAKE_DONE,\n                NULL, NULL) != NGX_OK)\n    {\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    ngx_rtmp_cycle(s);\n}\n\n\nstatic void\nngx_rtmp_handshake_recv(ngx_event_t *rev)\n{\n    ssize_t                     n;\n    ngx_connection_t           *c;\n    ngx_rtmp_session_t         *s;\n    ngx_buf_t                  *b;\n\n    c = rev->data;\n    s = c->data;\n\n    if (c->destroyed) {\n        return;\n    }\n\n    if (rev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                \"handshake: recv: client timed out\");\n        c->timedout = 1;\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    if (rev->timer_set) {\n        ngx_del_timer(rev);\n    }\n\n    b = s->hs_buf;\n\n    while (b->last != b->end) {\n        n = c->recv(c, b->last, b->end - b->last);\n\n        if (n == NGX_ERROR || n == 0) {\n            ngx_rtmp_finalize_session(s);\n            return;\n        }\n\n        if (n == NGX_AGAIN) {\n            ngx_add_timer(rev, s->timeout);\n            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n            }\n            return;\n        }\n\n        b->last += n;\n    }\n\n    if (rev->active) {\n        ngx_del_event(rev, NGX_READ_EVENT, 0);\n    }\n\n    ++s->hs_stage;\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: stage %ui\", s->hs_stage);\n\n    switch (s->hs_stage) {\n        case NGX_RTMP_HANDSHAKE_SERVER_SEND_CHALLENGE:\n            if (ngx_rtmp_handshake_parse_challenge(s,\n                    &ngx_rtmp_client_partial_key,\n                    &ngx_rtmp_server_full_key) != NGX_OK)\n            {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"handshake: error parsing challenge\");\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n            if (s->hs_old) {\n                ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                        \"handshake: old-style challenge\");\n                s->hs_buf->pos = s->hs_buf->start;\n                s->hs_buf->last = s->hs_buf->end;\n            } else if (ngx_rtmp_handshake_create_challenge(s,\n                        ngx_rtmp_server_version,\n                        &ngx_rtmp_server_partial_key) != NGX_OK)\n            {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"handshake: error creating challenge\");\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n            ngx_rtmp_handshake_send(c->write);\n            break;\n\n        case NGX_RTMP_HANDSHAKE_SERVER_DONE:\n            ngx_rtmp_handshake_done(s);\n            break;\n\n        case NGX_RTMP_HANDSHAKE_CLIENT_RECV_RESPONSE:\n            if (ngx_rtmp_handshake_parse_challenge(s,\n                    &ngx_rtmp_server_partial_key,\n                    &ngx_rtmp_client_full_key) != NGX_OK)\n            {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"handshake: error parsing challenge\");\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n            s->hs_buf->pos = s->hs_buf->last = s->hs_buf->start + 1;\n            ngx_rtmp_handshake_recv(c->read);\n            break;\n\n        case NGX_RTMP_HANDSHAKE_CLIENT_SEND_RESPONSE:\n            if (ngx_rtmp_handshake_create_response(s) != NGX_OK) {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"handshake: response error\");\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n            ngx_rtmp_handshake_send(c->write);\n            break;\n    }\n}\n\n\nstatic void\nngx_rtmp_handshake_send(ngx_event_t *wev)\n{\n    ngx_int_t                   n;\n    ngx_connection_t           *c;\n    ngx_rtmp_session_t         *s;\n    ngx_buf_t                  *b;\n\n    c = wev->data;\n    s = c->data;\n\n    if (c->destroyed) {\n        return;\n    }\n\n    if (wev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                \"handshake: send: client timed out\");\n        c->timedout = 1;\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    if (wev->timer_set) {\n        ngx_del_timer(wev);\n    }\n\n    b = s->hs_buf;\n\n    while(b->pos != b->last) {\n        n = c->send(c, b->pos, b->last - b->pos);\n\n        if (n == NGX_ERROR) {\n            ngx_rtmp_finalize_session(s);\n            return;\n        }\n\n        if (n == NGX_AGAIN || n == 0) {\n            ngx_add_timer(c->write, s->timeout);\n            if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n            }\n            return;\n        }\n\n        b->pos += n;\n    }\n\n    if (wev->active) {\n        ngx_del_event(wev, NGX_WRITE_EVENT, 0);\n    }\n\n    ++s->hs_stage;\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: stage %ui\", s->hs_stage);\n\n    switch (s->hs_stage) {\n        case NGX_RTMP_HANDSHAKE_SERVER_SEND_RESPONSE:\n            if (s->hs_old) {\n                ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                        \"handshake: old-style response\");\n                s->hs_buf->pos = s->hs_buf->start + 1;\n                s->hs_buf->last = s->hs_buf->end;\n            } else if (ngx_rtmp_handshake_create_response(s) != NGX_OK) {\n                ngx_log_error(NGX_LOG_INFO, c->log, 0,\n                        \"handshake: response error\");\n                ngx_rtmp_finalize_session(s);\n                return;\n            }\n            ngx_rtmp_handshake_send(wev);\n            break;\n\n        case NGX_RTMP_HANDSHAKE_SERVER_RECV_RESPONSE:\n            s->hs_buf->pos = s->hs_buf->last = s->hs_buf->start + 1;\n            ngx_rtmp_handshake_recv(c->read);\n            break;\n\n        case NGX_RTMP_HANDSHAKE_CLIENT_RECV_CHALLENGE:\n            s->hs_buf->pos = s->hs_buf->last = s->hs_buf->start;\n            ngx_rtmp_handshake_recv(c->read);\n            break;\n\n        case NGX_RTMP_HANDSHAKE_CLIENT_DONE:\n            ngx_rtmp_handshake_done(s);\n            break;\n    }\n}\n\n\nvoid\nngx_rtmp_handshake(ngx_rtmp_session_t *s)\n{\n    ngx_connection_t           *c;\n    ngx_time_t                 *tp;\n\n    c = s->connection;\n    c->read->handler =  ngx_rtmp_handshake_recv;\n    c->write->handler = ngx_rtmp_handshake_send;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: start server handshake\");\n\n    s->hs_buf = ngx_rtmp_alloc_handshake_buffer(s);\n    s->hs_stage = NGX_RTMP_HANDSHAKE_SERVER_RECV_CHALLENGE;\n\n    tp = ngx_timeofday();\n    s->start_sec = tp->sec;\n    s->start_msec = tp->msec;\n\n    ngx_rtmp_handshake_recv(c->read);\n}\n\n\nvoid\nngx_rtmp_client_handshake(ngx_rtmp_session_t *s, unsigned async)\n{\n    ngx_connection_t           *c;\n    ngx_time_t                 *tp;\n\n    c = s->connection;\n    c->read->handler =  ngx_rtmp_handshake_recv;\n    c->write->handler = ngx_rtmp_handshake_send;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"handshake: start client handshake\");\n\n    s->hs_buf = ngx_rtmp_alloc_handshake_buffer(s);\n    s->hs_stage = NGX_RTMP_HANDSHAKE_CLIENT_SEND_CHALLENGE;\n\n    if (ngx_rtmp_handshake_create_challenge(s,\n                ngx_rtmp_client_version,\n                &ngx_rtmp_client_partial_key) != NGX_OK)\n    {\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    tp = ngx_timeofday();\n    s->start_sec = tp->sec;\n    s->start_msec = tp->msec;\n\n    if (async) {\n        ngx_add_timer(c->write, s->timeout);\n        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n            ngx_rtmp_finalize_session(s);\n        }\n        return;\n    }\n\n    ngx_rtmp_handshake_send(c->write);\n}\n\n"
        },
        {
          "name": "ngx_rtmp_init.c",
          "type": "blob",
          "size": 10.1611328125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_proxy_protocol.h\"\n\n\nstatic void ngx_rtmp_close_connection(ngx_connection_t *c);\nstatic void ngx_rtmp_process_unix_socket(ngx_rtmp_connection_t *rconn);\n\n\nvoid\nngx_rtmp_init_connection(ngx_connection_t *c)\n{\n    ngx_uint_t                 i;\n    ngx_rtmp_port_t           *port;\n    struct sockaddr_in        *sin;\n    ngx_rtmp_in_addr_t        *addr;\n    ngx_rtmp_connection_t     *rconn;\n    ngx_rtmp_session_t        *s;\n    ngx_int_t                  unix_socket;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6       *sin6;\n    ngx_rtmp_in6_addr_t       *addr6;\n#endif\n\n    rconn = ngx_pcalloc(c->pool, sizeof(ngx_rtmp_connection_t));\n    if (rconn == NULL) {\n        ngx_rtmp_close_connection(c);\n        return;\n    }\n\n    ++ngx_rtmp_naccepted;\n\n    c->data = rconn;\n\n    /* find the server configuration for the address:port */\n\n    port = c->listening->servers;\n    unix_socket = 0;\n\n    if (port->naddrs > 1) {\n\n        /*\n         * There are several addresses on this port and one of them\n         * is the \"*:port\" wildcard so getsockname() is needed to determine\n         * the server address.\n         *\n         * AcceptEx() already gave this address.\n         */\n\n        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n            ngx_rtmp_close_connection(c);\n            return;\n        }\n\n        switch (c->local_sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            sin6 = (struct sockaddr_in6 *) c->local_sockaddr;\n\n            addr6 = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {\n                    break;\n                }\n            }\n\n            rconn->addr_conf = &addr6[i].conf;\n\n            break;\n#endif\n\n        case AF_UNIX:\n            unix_socket = 1;\n\n            ngx_rtmp_process_unix_socket(rconn);\n\n            break;\n\n        default: /* AF_INET */\n            sin = (struct sockaddr_in *) c->local_sockaddr;\n\n            addr = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (addr[i].addr == sin->sin_addr.s_addr) {\n                    break;\n                }\n            }\n\n            rconn->addr_conf = &addr[i].conf;\n\n            break;\n        }\n\n    } else {\n        switch (c->local_sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            addr6 = port->addrs;\n            rconn->addr_conf = &addr6[0].conf;\n            break;\n#endif\n\n        case AF_UNIX:\n            unix_socket = 1;\n\n            ngx_rtmp_process_unix_socket(rconn);\n\n            break;\n\n        default: /* AF_INET */\n            addr = port->addrs;\n            rconn->addr_conf = &addr[0].conf;\n            break;\n        }\n    }\n\n    /* the default server configuration for the address:port */\n    rconn->conf_ctx = rconn->addr_conf->default_server->ctx;\n\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, \"*%ui client connected '%V'\",\n                  c->number, &c->addr_text);\n\n    s = ngx_rtmp_init_session(c, rconn->addr_conf);\n    if (s == NULL) {\n        return;\n    }\n\n    /* only auto-pushed connections are\n     * done through unix socket */\n\n    s->auto_pushed = unix_socket;\n\n    if (rconn->addr_conf->proxy_protocol) {\n        ngx_rtmp_proxy_protocol(s);\n\n    } else {\n        ngx_rtmp_handshake(s);\n    }\n}\n\n\nngx_rtmp_session_t *\nngx_rtmp_init_session(ngx_connection_t *c, ngx_rtmp_addr_conf_t *addr_conf)\n{\n    ngx_rtmp_session_t             *s;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_rtmp_error_log_ctx_t       *ctx;\n\n    s = ngx_pcalloc(c->pool, sizeof(ngx_rtmp_session_t));\n    if (s == NULL) {\n        goto failed;\n    }\n\n    s->rtmp_connection = c->data;\n\n    s->main_conf = addr_conf->default_server->ctx->main_conf;\n    s->srv_conf = addr_conf->default_server->ctx->srv_conf;\n\n    s->addr_text = &addr_conf->addr_text;\n\n    c->data = s;\n    s->connection = c;\n\n    ctx = ngx_palloc(c->pool, sizeof(ngx_rtmp_error_log_ctx_t));\n    if (ctx == NULL) {\n        goto failed;\n    }\n\n    ctx->client = &c->addr_text;\n    ctx->session = s;\n\n    c->log->connection = c->number;\n    c->log->handler = ngx_rtmp_log_error;\n    c->log->data = ctx;\n    c->log->action = NULL;\n\n    c->log_error = NGX_ERROR_INFO;\n\n    s->ctx = ngx_pcalloc(c->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (s->ctx == NULL) {\n        goto failed;\n    }\n\n    s->out_pool = ngx_create_pool(4096, c->log);\n    if (s->out_pool == NULL) {\n        goto failed;\n    }\n\n    s->out = ngx_pcalloc(s->out_pool, sizeof(ngx_chain_t *)\n                         * ((ngx_rtmp_core_srv_conf_t *)\n                            addr_conf->default_server->ctx->srv_conf\n                            [ngx_rtmp_core_module.ctx_index])->out_queue);\n    if (s->out == NULL) {\n        goto failed;\n    }\n\n    s->in_streams_pool = ngx_create_pool(4096, c->log);\n    if (s->in_streams_pool == NULL) {\n        goto failed;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    s->out_queue = cscf->out_queue;\n    s->out_cork = cscf->out_cork;\n    s->in_streams = ngx_pcalloc(s->in_streams_pool, sizeof(ngx_rtmp_stream_t)\n            * cscf->max_streams);\n    if (s->in_streams == NULL) {\n        goto failed;\n    }\n\n#if (nginx_version >= 1007005)\n    ngx_queue_init(&s->posted_dry_events);\n#endif\n\n    s->epoch = ngx_current_msec;\n    s->timeout = cscf->timeout;\n    s->buflen = cscf->buflen;\n    ngx_rtmp_set_chunk_size(s, NGX_RTMP_DEFAULT_CHUNK_SIZE);\n\n\n    if (ngx_rtmp_fire_event(s, NGX_RTMP_CONNECT, NULL, NULL) != NGX_OK) {\n        ngx_rtmp_finalize_session(s);\n        return NULL;\n    }\n\n    return s;\n\nfailed:\n    if (s && s->out_pool) {\n        ngx_destroy_pool(s->out_pool);\n        s->out_pool = NULL;\n    }\n\n    if (s && s->in_streams_pool) {\n        ngx_destroy_pool(s->in_streams_pool);\n        s->in_streams_pool = NULL;\n    }\n\n    ngx_rtmp_close_connection(c);\n    return NULL;\n}\n\n\nu_char *\nngx_rtmp_log_error(ngx_log_t *log, u_char *buf, size_t len)\n{\n    u_char                     *p;\n    ngx_rtmp_session_t         *s;\n    ngx_rtmp_error_log_ctx_t   *ctx;\n\n    if (log->action) {\n        p = ngx_snprintf(buf, len, \" while %s\", log->action);\n        len -= p - buf;\n        buf = p;\n    }\n\n    ctx = log->data;\n\n    p = ngx_snprintf(buf, len, \", client: %V\", ctx->client);\n    len -= p - buf;\n    buf = p;\n\n    s = ctx->session;\n\n    if (s == NULL) {\n        return p;\n    }\n\n    p = ngx_snprintf(buf, len, \", server: %V\", s->addr_text);\n    len -= p - buf;\n    buf = p;\n\n    return p;\n}\n\n\nstatic void\nngx_rtmp_close_connection(ngx_connection_t *c)\n{\n    ngx_pool_t                         *pool;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, c->log, 0, \"close connection\");\n\n#if (NGX_STAT_STUB)\n    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);\n#endif\n\n    pool = c->pool;\n    ngx_close_connection(c);\n    ngx_destroy_pool(pool);\n}\n\n\nstatic void\nngx_rtmp_close_session_handler(ngx_event_t *e)\n{\n    ngx_rtmp_session_t                 *s;\n    ngx_connection_t                   *c;\n    ngx_rtmp_core_srv_conf_t           *cscf;\n\n    s = e->data;\n    c = s->connection;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, c->log, 0, \"close session\");\n\n    ngx_rtmp_fire_event(s, NGX_RTMP_DISCONNECT, NULL, NULL);\n\n    if (s->ping_evt.timer_set) {\n        ngx_del_timer(&s->ping_evt);\n    }\n\n    if (s->in_old_pool) {\n        ngx_destroy_pool(s->in_old_pool);\n    }\n\n    if (s->in_pool) {\n        ngx_destroy_pool(s->in_pool);\n    }\n\n    ngx_rtmp_free_handshake_buffers(s);\n\n    while (s->out_pos != s->out_last) {\n        ngx_rtmp_free_shared_chain(cscf, s->out[s->out_pos]);\n\n        s->out_pos++;\n        s->out_pos %= s->out_queue;\n    }\n\n    if (s->in_streams_pool) {\n        ngx_destroy_pool(s->in_streams_pool);\n    }\n\n    if (s->out_pool) {\n        ngx_destroy_pool(s->out_pool);\n    }\n\n    ngx_rtmp_close_connection(c);\n}\n\n\nvoid\nngx_rtmp_finalize_session(ngx_rtmp_session_t *s)\n{\n    ngx_event_t        *e;\n    ngx_connection_t   *c;\n\n    c = s->connection;\n    if (c->destroyed) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, c->log, 0, \"finalize session\");\n\n    c->destroyed = 1;\n    e = &s->close;\n    e->data = s;\n    e->handler = ngx_rtmp_close_session_handler;\n    e->log = c->log;\n\n    ngx_post_event(e, &ngx_posted_events);\n}\n\n\nstatic void\nngx_rtmp_process_unix_socket(ngx_rtmp_connection_t *rconn)\n{\n    ngx_uint_t                 i;\n    ngx_rtmp_port_t           *port;\n    struct sockaddr_in        *sin;\n    ngx_rtmp_in_addr_t        *addr;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6       *sin6;\n    ngx_rtmp_in6_addr_t       *addr6;\n#endif\n    ngx_listening_t           *ls;\n\n    ls = ngx_cycle->listening.elts;\n    for (i = 0; i < ngx_cycle->listening.nelts; ++i, ++ls) {\n        if (ls->handler == ngx_rtmp_init_connection) {\n            break;\n        }\n    }\n\n    port = ls->servers;\n\n    if (port->naddrs > 1) {\n        switch (ls->sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            sin6 = (struct sockaddr_in6 *) ls->sockaddr;\n\n            addr6 = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {\n                    break;\n                }\n            }\n\n            rconn->addr_conf = &addr6[i].conf;\n\n            break;\n#endif\n\n        default: /* AF_INET */\n            sin = (struct sockaddr_in *) ls->sockaddr;\n\n            addr = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (addr[i].addr == sin->sin_addr.s_addr) {\n                    break;\n                }\n            }\n\n            rconn->addr_conf = &addr[i].conf;\n        }\n    } else {\n        switch (ls->sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            addr6 = port->addrs;\n            rconn->addr_conf = &addr6[0].conf;\n            break;\n#endif\n\n        default: /* AF_INET */\n            addr = port->addrs;\n            rconn->addr_conf = &addr[0].conf;\n        }\n    }\n}\n\n"
        },
        {
          "name": "ngx_rtmp_limit_module.c",
          "type": "blob",
          "size": 5.4248046875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\ntypedef struct {\n    ngx_int_t       max_conn;\n    ngx_shm_zone_t *shm_zone;\n} ngx_rtmp_limit_main_conf_t;\n\n\nstatic ngx_str_t    shm_name = ngx_string(\"rtmp_limit\");\n\n\nstatic ngx_int_t ngx_rtmp_limit_postconfiguration(ngx_conf_t *cf);\nstatic void *ngx_rtmp_limit_create_main_conf(ngx_conf_t *cf);\n\n\nstatic ngx_command_t  ngx_rtmp_limit_commands[] = {\n\n    { ngx_string(\"max_connections\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_MAIN_CONF_OFFSET,\n      offsetof(ngx_rtmp_limit_main_conf_t, max_conn),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_limit_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_limit_postconfiguration,       /* postconfiguration */\n    ngx_rtmp_limit_create_main_conf,        /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    NULL,                                   /* create app configuration */\n    NULL                                    /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_limit_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_limit_module_ctx,             /* module context */\n    ngx_rtmp_limit_commands,                /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void *\nngx_rtmp_limit_create_main_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_limit_main_conf_t      *lmcf;\n\n    lmcf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_limit_main_conf_t));\n    if (lmcf == NULL) {\n        return NULL;\n    }\n\n    lmcf->max_conn = NGX_CONF_UNSET;\n\n    return lmcf;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_limit_connect(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n    ngx_chain_t *in)\n{\n    ngx_rtmp_limit_main_conf_t *lmcf;\n    ngx_slab_pool_t            *shpool;\n    ngx_shm_zone_t             *shm_zone;\n    uint32_t                   *nconn, n;\n    ngx_int_t                   rc;\n\n    lmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_limit_module);\n    if (lmcf->max_conn == NGX_CONF_UNSET) {\n        return NGX_OK;\n    }\n\n    shm_zone = lmcf->shm_zone;\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n    nconn = shm_zone->data;\n\n    ngx_shmtx_lock(&shpool->mutex);\n    n = ++*nconn;\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    rc = n > (ngx_uint_t) lmcf->max_conn ? NGX_ERROR : NGX_OK;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"limit: inc connection counter: %uD\", n);\n\n    if (rc != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"limit: too many connections: %uD > %i\",\n                      n, lmcf->max_conn);\n    }\n\n    return rc;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_limit_disconnect(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n    ngx_chain_t *in)\n{\n    ngx_rtmp_limit_main_conf_t *lmcf;\n    ngx_slab_pool_t            *shpool;\n    ngx_shm_zone_t             *shm_zone;\n    uint32_t                   *nconn, n;\n\n    lmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_limit_module);\n    if (lmcf->max_conn == NGX_CONF_UNSET) {\n        return NGX_OK;\n    }\n\n    shm_zone = lmcf->shm_zone;\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n    nconn = shm_zone->data;\n\n    ngx_shmtx_lock(&shpool->mutex);\n    n = --*nconn;\n    ngx_shmtx_unlock(&shpool->mutex);\n\n    (void) n;\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"limit: dec connection counter: %uD\", n);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_limit_shm_init(ngx_shm_zone_t *shm_zone, void *data)\n{\n    ngx_slab_pool_t    *shpool;\n    uint32_t           *nconn;\n\n    if (data) {\n        shm_zone->data = data;\n        return NGX_OK;\n    }\n\n    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n\n    nconn = ngx_slab_alloc(shpool, 4);\n    if (nconn == NULL) {\n        return NGX_ERROR;\n    }\n\n    *nconn = 0;\n\n    shm_zone->data = nconn;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_limit_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t  *cmcf;\n    ngx_rtmp_limit_main_conf_t *lmcf;\n    ngx_rtmp_handler_pt        *h;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_CONNECT]);\n    *h = ngx_rtmp_limit_connect;\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_DISCONNECT]);\n    *h = ngx_rtmp_limit_disconnect;\n\n    lmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_limit_module);\n    if (lmcf->max_conn == NGX_CONF_UNSET) {\n        return NGX_OK;\n    }\n\n    lmcf->shm_zone = ngx_shared_memory_add(cf, &shm_name, ngx_pagesize * 2,\n                                           &ngx_rtmp_limit_module);\n    if (lmcf->shm_zone == NULL) {\n        return NGX_ERROR;\n    }\n\n    lmcf->shm_zone->init = ngx_rtmp_limit_shm_init;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_live_module.c",
          "type": "blob",
          "size": 45.7353515625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include \"ngx_rtmp_live_module.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_codec_module.h\"\n#include \"ngx_http_flv_live_module.h\"\n\n\nstatic ngx_rtmp_publish_pt              next_publish;\nstatic ngx_rtmp_play_pt                 next_play;\nstatic ngx_rtmp_close_stream_pt         next_close_stream;\nstatic ngx_rtmp_pause_pt                next_pause;\nstatic ngx_rtmp_stream_begin_pt         next_stream_begin;\nstatic ngx_rtmp_stream_eof_pt           next_stream_eof;\n\n\nstatic ngx_int_t ngx_rtmp_live_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_live_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_live_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\nstatic char *ngx_rtmp_live_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic void ngx_rtmp_live_start(ngx_rtmp_session_t *s);\nstatic void ngx_rtmp_live_stop(ngx_rtmp_session_t *s);\n\nstatic ngx_int_t ngx_rtmp_live_send_message(ngx_rtmp_session_t *s,\n       ngx_chain_t *in, ngx_uint_t priority);\nstatic ngx_chain_t *ngx_rtmp_live_meta_message(ngx_rtmp_session_t *s,\n       ngx_chain_t *in);\nstatic ngx_chain_t *ngx_rtmp_live_append_message(ngx_rtmp_session_t *s,\n       ngx_rtmp_header_t *h, ngx_rtmp_header_t *lh, ngx_chain_t *in);\nstatic void ngx_rtmp_live_free_message(ngx_rtmp_session_t *s, ngx_chain_t *in);\n\n\n#define ACTION_VAR_LEN  128\n#define STREAM_VAR_LEN  1024\n\n\nngx_rtmp_live_proc_handler_t  ngx_rtmp_live_proc_handler = {\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    ngx_rtmp_live_send_message,\n    ngx_rtmp_live_meta_message,\n    ngx_rtmp_live_append_message,\n    ngx_rtmp_live_free_message\n};\n\n\nextern ngx_rtmp_live_proc_handler_t  *ngx_rtmp_live_proc_handlers\n                                      [NGX_RTMP_PROTOCOL_HTTP + 1];\nextern ngx_module_t                   ngx_http_flv_live_module;\n\nstatic ngx_command_t  ngx_rtmp_live_commands[] = {\n\n    { ngx_string(\"live\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, live),\n      NULL },\n\n    { ngx_string(\"stream_buckets\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, nbuckets),\n      NULL },\n\n    { ngx_string(\"buffer\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, buflen),\n      NULL },\n\n    { ngx_string(\"sync\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_live_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, sync),\n      NULL },\n\n    { ngx_string(\"interleave\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, interleave),\n      NULL },\n\n    { ngx_string(\"wait_key\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, wait_key),\n      NULL },\n\n    { ngx_string(\"wait_video\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, wait_video),\n      NULL },\n\n    { ngx_string(\"publish_notify\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, publish_notify),\n      NULL },\n\n    { ngx_string(\"play_restart\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, play_restart),\n      NULL },\n\n    { ngx_string(\"idle_streams\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, idle_streams),\n      NULL },\n\n    { ngx_string(\"drop_idle_publisher\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_live_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_live_app_conf_t, idle_timeout),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_live_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_live_postconfiguration,        /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_live_create_app_conf,          /* create app configuration */\n    ngx_rtmp_live_merge_app_conf            /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_live_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_live_module_ctx,              /* module context */\n    ngx_rtmp_live_commands,                 /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nngx_int_t\nngx_rtmp_live_send_message(ngx_rtmp_session_t *s,\n        ngx_chain_t *in, ngx_uint_t priority)\n{\n    return ngx_rtmp_send_message(s, in, priority);\n}\n\n\nngx_chain_t *\nngx_rtmp_live_meta_message(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t       *cscf;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    return ngx_rtmp_append_shared_bufs(cscf, NULL, in);\n}\n\n\nngx_chain_t *\nngx_rtmp_live_append_message(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_rtmp_header_t *lh, ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_chain_t                    *pkt;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    pkt = ngx_rtmp_append_shared_bufs(cscf, NULL, in);\n    if (pkt != NULL) {\n        ngx_rtmp_prepare_message(s, h, lh, pkt);\n    }\n\n    return pkt;\n}\n\n\nvoid\nngx_rtmp_live_free_message(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_rtmp_core_srv_conf_t       *cscf;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    if (cscf == NULL) {\n        return;\n    }\n\n    ngx_rtmp_free_shared_chain(cscf, in);\n}\n\n\nstatic void *\nngx_rtmp_live_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_live_app_conf_t      *lacf;\n\n    lacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_live_app_conf_t));\n    if (lacf == NULL) {\n        return NULL;\n    }\n\n    lacf->live = NGX_CONF_UNSET;\n    lacf->nbuckets = NGX_CONF_UNSET;\n    lacf->buflen = NGX_CONF_UNSET_MSEC;\n    lacf->sync = NGX_CONF_UNSET_MSEC;\n    lacf->idle_timeout = NGX_CONF_UNSET_MSEC;\n    lacf->interleave = NGX_CONF_UNSET;\n    lacf->wait_key = NGX_CONF_UNSET;\n    lacf->wait_video = NGX_CONF_UNSET;\n    lacf->publish_notify = NGX_CONF_UNSET;\n    lacf->play_restart = NGX_CONF_UNSET;\n    lacf->idle_streams = NGX_CONF_UNSET;\n\n    return lacf;\n}\n\n\nstatic void\nngx_rtmp_live_free_pool_cleanup(void *data)\n{\n    ngx_rtmp_live_app_conf_t      *lacf = data;\n\n    if (lacf->pool != NULL) {\n        ngx_destroy_pool(lacf->pool);\n        lacf->pool = NULL;\n    }\n}\n\n\nstatic char *\nngx_rtmp_live_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_pool_cleanup_t        *cln;\n    ngx_rtmp_live_app_conf_t  *prev = parent;\n    ngx_rtmp_live_app_conf_t  *conf = child;\n\n    ngx_conf_merge_value(conf->live, prev->live, 0);\n    ngx_conf_merge_value(conf->nbuckets, prev->nbuckets, 1024);\n    ngx_conf_merge_msec_value(conf->buflen, prev->buflen, 0);\n    ngx_conf_merge_msec_value(conf->sync, prev->sync, 300);\n    ngx_conf_merge_msec_value(conf->idle_timeout, prev->idle_timeout, 0);\n    ngx_conf_merge_value(conf->interleave, prev->interleave, 0);\n    ngx_conf_merge_value(conf->wait_key, prev->wait_key, 1);\n    ngx_conf_merge_value(conf->wait_video, prev->wait_video, 0);\n    ngx_conf_merge_value(conf->publish_notify, prev->publish_notify, 0);\n    ngx_conf_merge_value(conf->play_restart, prev->play_restart, 0);\n    ngx_conf_merge_value(conf->idle_streams, prev->idle_streams, 1);\n\n    conf->pool = ngx_create_pool(4096, &cf->cycle->new_log);\n    if (conf->pool == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    cln = ngx_pool_cleanup_add(cf->pool, 0);\n    if (cln == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    cln->handler = ngx_rtmp_live_free_pool_cleanup;\n    cln->data = conf;\n\n    conf->streams = ngx_pcalloc(cf->pool,\n            sizeof(ngx_rtmp_live_stream_t *) * conf->nbuckets);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_live_set_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                       *p = conf;\n    ngx_str_t                  *value;\n    ngx_msec_t                 *msp;\n\n    msp = (ngx_msec_t *) (p + cmd->offset);\n\n    value = cf->args->elts;\n\n    if (value[1].len == sizeof(\"off\") - 1 &&\n        ngx_strncasecmp(value[1].data, (u_char *) \"off\", value[1].len) == 0)\n    {\n        *msp = 0;\n        return NGX_CONF_OK;\n    }\n\n    return ngx_conf_set_msec_slot(cf, cmd, conf);\n}\n\n\nngx_rtmp_live_stream_t **\nngx_rtmp_live_get_stream(ngx_rtmp_session_t *s, u_char *name, int create)\n{\n    ngx_rtmp_live_app_conf_t   *lacf;\n    ngx_rtmp_live_stream_t    **stream;\n    size_t                      len;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return NULL;\n    }\n\n    len = ngx_strlen(name);\n    stream = &lacf->streams[ngx_hash_key(name, len) % lacf->nbuckets];\n\n    for (; *stream; stream = &(*stream)->next) {\n        if (ngx_strcmp(name, (*stream)->name) == 0) {\n            return stream;\n        }\n    }\n\n    if (!create) {\n        return NULL;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"live: create stream '%s'\", name);\n\n    if (lacf->free_streams) {\n        *stream = lacf->free_streams;\n        lacf->free_streams = lacf->free_streams->next;\n    } else {\n        *stream = ngx_palloc(lacf->pool, sizeof(ngx_rtmp_live_stream_t));\n    }\n    ngx_memzero(*stream, sizeof(ngx_rtmp_live_stream_t));\n    ngx_memcpy((*stream)->name, name,\n            ngx_min(sizeof((*stream)->name) - 1, len));\n    (*stream)->epoch = ngx_current_msec;\n\n    return stream;\n}\n\n\nstatic void\nngx_rtmp_live_idle(ngx_event_t *pev)\n{\n    ngx_connection_t           *c;\n    ngx_rtmp_session_t         *s;\n\n    c = pev->data;\n    s = c->data;\n\n    ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                  \"live: drop idle publisher\");\n\n    ngx_rtmp_finalize_session(s);\n}\n\n\nstatic void\nngx_rtmp_live_set_status(ngx_rtmp_session_t *s, ngx_chain_t *control,\n                         ngx_chain_t **status, size_t nstatus,\n                         unsigned active)\n{\n    ngx_rtmp_live_app_conf_t   *lacf;\n    ngx_rtmp_live_ctx_t        *ctx, *pctx;\n    ngx_chain_t               **cl;\n    ngx_event_t                *e;\n    size_t                      n;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: set active=%ui\", active);\n\n    if (ctx->active == active) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"live: unchanged active=%ui\", active);\n        return;\n    }\n\n    ctx->active = active;\n\n    if (ctx->publishing) {\n\n        /* publisher */\n\n        if (lacf->idle_timeout) {\n            e = &ctx->idle_evt;\n\n            if (active && !ctx->idle_evt.timer_set) {\n                e->data = s->connection;\n                e->log = s->connection->log;\n                e->handler = ngx_rtmp_live_idle;\n\n                ngx_add_timer(e, lacf->idle_timeout);\n\n            } else if (!active && ctx->idle_evt.timer_set) {\n                ngx_del_timer(e);\n            }\n        }\n\n        ctx->stream->active = active;\n\n        for (pctx = ctx->stream->ctx; pctx; pctx = pctx->next) {\n            if (pctx->publishing == 0) {\n                pctx->session->publisher = s;\n\n                if (pctx->protocol == NGX_RTMP_PROTOCOL_HTTP) {\n                    ngx_http_flv_live_set_status(pctx->session, active);\n                } else {\n                    ngx_rtmp_live_set_status(pctx->session, control, status,\n                                         nstatus, active);\n                }\n            }\n        }\n\n        return;\n    }\n\n    /* subscriber */\n\n    if (ctx->protocol == NGX_RTMP_PROTOCOL_HTTP) {\n        ngx_http_flv_live_set_status(s, active);\n    } else {\n        if (control && ngx_rtmp_send_message(s, control, 0) != NGX_OK) {\n            ngx_rtmp_finalize_session(s);\n            return;\n        }\n\n        if (!ctx->silent) {\n            cl = status;\n\n            for (n = 0; n < nstatus; ++n, ++cl) {\n                if (*cl && ngx_rtmp_send_message(s, *cl, 0) != NGX_OK) {\n                    ngx_rtmp_finalize_session(s);\n                    return;\n                }\n            }\n        }\n\n        ctx->cs[0].active = 0;\n        ctx->cs[0].dropped = 0;\n\n        ctx->cs[1].active = 0;\n        ctx->cs[1].dropped = 0;\n    }\n}\n\n\nstatic void\nngx_rtmp_live_start(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_rtmp_live_app_conf_t   *lacf;\n    ngx_chain_t                *control;\n    ngx_chain_t                *status[3];\n    size_t                      n, nstatus;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n\n    control = ngx_rtmp_create_stream_begin(s, NGX_RTMP_MSID);\n\n    nstatus = 0;\n\n    if (lacf->play_restart) {\n        status[nstatus++] = ngx_rtmp_create_status(s, \"NetStream.Play.Start\",\n                                                   \"status\", \"Start live\");\n        status[nstatus++] = ngx_rtmp_create_sample_access(s);\n    }\n\n    if (lacf->publish_notify) {\n        status[nstatus++] = ngx_rtmp_create_status(s,\n                                                 \"NetStream.Play.PublishNotify\",\n                                                 \"status\", \"Start publishing\");\n    }\n\n    ngx_rtmp_live_set_status(s, control, status, nstatus, 1);\n\n    if (control) {\n        ngx_rtmp_free_shared_chain(cscf, control);\n    }\n\n    for (n = 0; n < nstatus; ++n) {\n        ngx_rtmp_free_shared_chain(cscf, status[n]);\n    }\n}\n\n\nstatic void\nngx_rtmp_live_stop(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_rtmp_live_app_conf_t   *lacf;\n    ngx_chain_t                *control;\n    ngx_chain_t                *status[3];\n    size_t                      n, nstatus;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n\n    control = ngx_rtmp_create_stream_eof(s, NGX_RTMP_MSID);\n\n    nstatus = 0;\n\n    if (lacf->play_restart) {\n        status[nstatus++] = ngx_rtmp_create_status(s, \"NetStream.Play.Stop\",\n                                                   \"status\", \"Stop live\");\n    }\n\n    if (lacf->publish_notify) {\n        status[nstatus++] = ngx_rtmp_create_status(s,\n                                               \"NetStream.Play.UnpublishNotify\",\n                                               \"status\", \"Stop publishing\");\n    }\n\n    ngx_rtmp_live_set_status(s, control, status, nstatus, 0);\n\n    if (control) {\n        ngx_rtmp_free_shared_chain(cscf, control);\n    }\n\n    for (n = 0; n < nstatus; ++n) {\n        ngx_rtmp_free_shared_chain(cscf, status[n]);\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_stream_begin(ngx_rtmp_session_t *s, ngx_rtmp_stream_begin_t *v)\n{\n    ngx_rtmp_live_ctx_t    *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n\n    if (ctx == NULL || ctx->stream == NULL || !ctx->publishing) {\n        goto next;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: stream_begin\");\n\n    ngx_rtmp_live_start(s);\n\nnext:\n    return next_stream_begin(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_stream_eof(ngx_rtmp_session_t *s, ngx_rtmp_stream_eof_t *v)\n{\n    ngx_rtmp_live_ctx_t    *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n\n    if (ctx == NULL || ctx->stream == NULL || !ctx->publishing) {\n        goto next;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: stream_eof\");\n\n    ngx_rtmp_live_stop(s);\n\nnext:\n    return next_stream_eof(s, v);\n}\n\n\nstatic void\nngx_rtmp_live_join(ngx_rtmp_session_t *s, u_char *name, unsigned publisher)\n{\n    ngx_rtmp_live_ctx_t            *ctx;\n    ngx_rtmp_live_stream_t        **stream;\n    ngx_rtmp_live_app_conf_t       *lacf;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx && ctx->stream) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"live: already joined\");\n        return;\n    }\n\n    if (ctx == NULL) {\n        ctx = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_live_ctx_t));\n        if (ctx == NULL) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"live: failed to allocate for ctx\");\n            return;\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_live_module);\n    }\n\n    ngx_memzero(ctx, sizeof(*ctx));\n\n    ctx->session = s;\n    ctx->protocol = NGX_RTMP_PROTOCOL_RTMP;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: join '%s'\", name);\n\n    stream = ngx_rtmp_live_get_stream(s, name, publisher || lacf->idle_streams);\n\n    if (stream == NULL ||\n        !(publisher || (*stream)->publishing || lacf->idle_streams))\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"live: stream not found\");\n\n        ngx_rtmp_send_status(s, \"NetStream.Play.StreamNotFound\", \"error\",\n                             \"No such stream\");\n\n        ngx_rtmp_finalize_session(s);\n\n        return;\n    }\n\n    if (publisher) {\n        if ((*stream)->publishing) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"live: already publishing\");\n\n            ngx_rtmp_send_status(s, \"NetStream.Publish.BadName\", \"error\",\n                                 \"Already publishing\");\n\n            return;\n        }\n\n        (*stream)->publishing = 1;\n        (*stream)->pub_ctx = ctx;\n    }\n\n    ctx->stream = *stream;\n    ctx->publishing = publisher;\n    ctx->next = (*stream)->ctx;\n\n    (*stream)->ctx = ctx;\n\n    if (lacf->buflen) {\n        s->out_buffer = 1;\n    }\n\n    ctx->cs[0].csid = NGX_RTMP_CSID_VIDEO;\n    ctx->cs[1].csid = NGX_RTMP_CSID_AUDIO;\n\n    if (!ctx->publishing && ctx->stream->active) {\n        ngx_rtmp_live_start(s);\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_close_stream(ngx_rtmp_session_t *s, ngx_rtmp_close_stream_t *v)\n{\n    ngx_rtmp_session_t             *ss;\n    ngx_rtmp_live_ctx_t            *ctx, **cctx, *pctx;\n    ngx_rtmp_live_stream_t        **stream;\n    ngx_rtmp_live_app_conf_t       *lacf;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    if (ctx->stream == NULL) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"live: not joined\");\n        goto next;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: leave '%s'\", ctx->stream->name);\n\n    if (ctx->stream->publishing && ctx->publishing) {\n        ctx->stream->publishing = 0;\n    }\n\n    if (ctx->publishing) {\n        ctx->stream->pub_ctx = NULL;\n    }\n\n    for (cctx = &ctx->stream->ctx; *cctx; cctx = &(*cctx)->next) {\n        if (*cctx == ctx) {\n            *cctx = ctx->next;\n            break;\n        }\n    }\n\n    if (ctx->publishing || ctx->stream->active) {\n        ngx_rtmp_live_stop(s);\n    }\n\n    if (ctx->publishing) {\n        ngx_rtmp_send_status(s, \"NetStream.Unpublish.Success\",\n                             \"status\", \"Stop publishing\");\n        if (!lacf->idle_streams) {\n            for (pctx = ctx->stream->ctx; pctx; pctx = pctx->next) {\n                if (pctx->publishing == 0) {\n                    ss = pctx->session;\n                    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                                   \"live: no publisher\");\n                    ngx_rtmp_finalize_session(ss);\n                }\n            }\n        }\n    }\n\n    if (ctx->stream->ctx || ctx->stream->pub_ctx) {\n        ctx->stream = NULL;\n        goto next;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: delete empty stream '%s'\",\n                   ctx->stream->name);\n\n    stream = ngx_rtmp_live_get_stream(s, ctx->stream->name, 0);\n    if (stream == NULL) {\n        goto next;\n    }\n    *stream = (*stream)->next;\n\n    ctx->stream->next = lacf->free_streams;\n    lacf->free_streams = ctx->stream;\n    ctx->stream = NULL;\n\n    if (!ctx->silent && !ctx->publishing && !lacf->play_restart) {\n        ngx_rtmp_send_status(s, \"NetStream.Play.Stop\", \"status\", \"Stop live\");\n    }\n\nnext:\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_pause(ngx_rtmp_session_t *s, ngx_rtmp_pause_t *v)\n{\n    ngx_rtmp_live_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n\n    if (ctx == NULL || ctx->stream == NULL) {\n        goto next;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: pause=%i timestamp=%f\",\n                   (ngx_int_t) v->pause, v->position);\n\n    if (v->pause) {\n        if (ngx_rtmp_send_status(s, \"NetStream.Pause.Notify\", \"status\",\n                                 \"Paused live\")\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        ctx->paused = 1;\n\n        ngx_rtmp_live_stop(s);\n\n    } else {\n        if (ngx_rtmp_send_status(s, \"NetStream.Unpause.Notify\", \"status\",\n                                 \"Unpaused live\")\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        ctx->paused = 0;\n\n        ngx_rtmp_live_start(s);\n    }\n\nnext:\n    return next_pause(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_av(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                 ngx_chain_t *in)\n{\n    ngx_rtmp_live_proc_handler_t     *handler;\n    ngx_rtmp_live_ctx_t              *ctx, *pctx;\n    ngx_rtmp_codec_ctx_t             *codec_ctx;\n    ngx_chain_t                      *header, *coheader;\n    ngx_rtmp_live_app_conf_t         *lacf;\n    ngx_rtmp_session_t               *ss;\n    ngx_rtmp_header_t                 ch, lh, clh;\n    ngx_int_t                         rc, mandatory, i;\n    ngx_uint_t                        prio;\n    ngx_uint_t                        peers;\n    ngx_uint_t                        meta_version;\n    ngx_uint_t                        csidx;\n    uint32_t                          delta;\n    ngx_rtmp_live_chunk_stream_t     *cs;\n    ngx_http_request_t               *r;\n    ngx_http_flv_live_ctx_t          *hctx;\n#ifdef NGX_DEBUG\n    const char                       *type_s;\n\n    type_s = (h->type == NGX_RTMP_MSG_VIDEO ? \"video\" : \"audio\");\n#endif\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (!lacf->live || in == NULL  || in->buf == NULL) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL || ctx->stream == NULL) {\n        return NGX_OK;\n    }\n\n    if (!ctx->publishing) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"live: %s from non-publisher\", type_s);\n        return NGX_OK;\n    }\n\n    if (!ctx->stream->active) {\n        ngx_rtmp_live_start(s);\n    }\n\n    if (ctx->idle_evt.timer_set) {\n        ngx_add_timer(&ctx->idle_evt, lacf->idle_timeout);\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: %s packet timestamp=%uD\",\n                   type_s, h->timestamp);\n\n    s->current_time = h->timestamp;\n\n    peers = 0;\n    header = NULL;\n    coheader = NULL;\n    meta_version = 0;\n    mandatory = 0;\n\n    for (i = 0; i <= NGX_RTMP_PROTOCOL_HTTP; i++) {\n        handler = ngx_rtmp_live_proc_handlers[i];\n\n        handler->meta = NULL;\n        handler->rpkt = NULL;\n        handler->apkt = NULL;\n        handler->acopkt = NULL;\n    }\n\n    prio = (h->type == NGX_RTMP_MSG_VIDEO ?\n            ngx_rtmp_get_video_frame_type(in) : 0);\n\n    csidx = !(lacf->interleave || h->type == NGX_RTMP_MSG_VIDEO);\n\n    cs  = &ctx->cs[csidx];\n\n    ngx_memzero(&ch, sizeof(ch));\n\n    ch.timestamp = h->timestamp;\n    ch.msid = NGX_RTMP_MSID;\n    ch.csid = cs->csid;\n    ch.type = h->type;\n\n    lh = ch;\n\n    if (cs->active) {\n        lh.timestamp = cs->timestamp;\n    }\n\n    clh = lh;\n    clh.type = (h->type == NGX_RTMP_MSG_AUDIO ? NGX_RTMP_MSG_VIDEO :\n                                                NGX_RTMP_MSG_AUDIO);\n\n    cs->active = 1;\n    cs->timestamp = ch.timestamp;\n\n    delta = ch.timestamp - lh.timestamp;\n/*\n    if (delta >> 31) {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"live: clipping non-monotonical timestamp %uD->%uD\",\n                       lh.timestamp, ch.timestamp);\n\n        delta = 0;\n\n        ch.timestamp = lh.timestamp;\n    }\n*/\n\n    codec_ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n\n    if (codec_ctx) {\n\n        if (h->type == NGX_RTMP_MSG_AUDIO) {\n            header = codec_ctx->aac_header;\n\n            if (lacf->interleave) {\n                coheader = codec_ctx->avc_header;\n            }\n\n            if (codec_ctx->audio_codec_id == NGX_RTMP_AUDIO_AAC &&\n                ngx_rtmp_is_codec_header(in))\n            {\n                prio = 0;\n                mandatory = 1;\n            }\n\n        } else {\n            header = codec_ctx->avc_header;\n\n            if (lacf->interleave) {\n                coheader = codec_ctx->aac_header;\n            }\n\n            if (codec_ctx->video_codec_id == NGX_RTMP_VIDEO_H264 &&\n                ngx_rtmp_is_codec_header(in))\n            {\n                prio = 0;\n                mandatory = 1;\n            }\n        }\n\n        if (codec_ctx->meta) {\n            meta_version = codec_ctx->meta_version;\n        }\n    }\n\n    /* broadcast to all subscribers */\n\n    for (pctx = ctx->stream->ctx; pctx; pctx = pctx->next) {\n        if (pctx == ctx || pctx->paused) {\n            continue;\n        }\n\n        ss = pctx->session;\n        cs = &pctx->cs[csidx];\n \n        handler = ngx_rtmp_live_proc_handlers[pctx->protocol];\n\n        /* send metadata */\n        \n        if (codec_ctx) {\n            if (pctx->protocol == NGX_RTMP_PROTOCOL_HTTP) {\n                r = ss->data;\n                if (r == NULL\n                    || (r->connection && r->connection->destroyed))\n                {\n                    continue;\n                }\n\n                hctx = ngx_http_get_module_ctx(r, ngx_http_flv_live_module);\n                if (!hctx->header_sent) {\n                    hctx->header_sent = 1;\n                    ngx_http_flv_live_send_header(ss);\n                }\n            }\n        }\n\n        if (handler->meta == NULL && meta_version != pctx->meta_version) {\n            if (codec_ctx->meta) {\n                handler->meta = handler->meta_message_pt(ss, codec_ctx->meta);\n                if (handler->meta == NULL) {\n                    continue;\n                }\n            } else {\n                ngx_log_error(NGX_LOG_WARN, ss->connection->log, 0,\n                              \"live: no meta\");\n\n                pctx->meta_version = meta_version;\n            }\n        }\n\n        if (handler->meta && meta_version != pctx->meta_version) {\n            ngx_log_debug0(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                           \"live: meta\");\n\n            if (handler->send_message_pt(ss, handler->meta, 0) == NGX_OK) {\n                pctx->meta_version = meta_version;\n            }\n        }\n\n        /* sync stream */\n\n        if (cs->active && (lacf->sync && cs->dropped > lacf->sync)) {\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                           \"live: sync %s dropped=%uD\", type_s, cs->dropped);\n\n            cs->active = 0;\n            cs->dropped = 0;\n        }\n\n        /* absolute packet */\n\n        if (!cs->active) {\n\n            if (mandatory) {\n                ngx_log_debug0(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                               \"live: skipping header\");\n                continue;\n            }\n\n            if (codec_ctx->video_codec_id) {\n                if (lacf->wait_video && h->type == NGX_RTMP_MSG_AUDIO &&\n                    !pctx->cs[0].active)\n                {\n                    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                                   \"live: waiting for video\");\n                    continue;\n                }\n\n                if (lacf->wait_key && prio != NGX_RTMP_VIDEO_KEY_FRAME &&\n                   (lacf->interleave || h->type == NGX_RTMP_MSG_VIDEO))\n                {\n                    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                                   \"live: skip non-key\");\n                    continue;\n                }\n            }\n\n            if (header || coheader) {\n\n                /* send absolute codec header */\n\n                ngx_log_debug2(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                               \"live: abs %s header timestamp=%uD\",\n                               type_s, lh.timestamp);\n\n                if (header) {\n                    if (handler->apkt == NULL) {\n                        handler->apkt = handler->append_message_pt(ss, &lh,\n                                                             NULL, header);\n                        if (handler->apkt == NULL) {\n                            continue;\n                        }\n                    }\n\n                    rc = handler->send_message_pt(ss, handler->apkt, 0);\n                    if (rc != NGX_OK) {\n                        continue;\n                    }\n                }\n\n                if (coheader) {\n                    if (handler->acopkt == NULL) {\n                        handler->acopkt = handler->append_message_pt(ss, &clh,\n                                                              NULL, coheader);\n                        if (handler->acopkt == NULL) {\n                            continue;\n                        }\n                    }\n\n                    rc = handler->send_message_pt(ss, handler->acopkt, 0);\n                    if (rc != NGX_OK) {\n                        continue;\n                    }\n\n                }\n\n                cs->timestamp = lh.timestamp;\n                cs->active = 1;\n                ss->current_time = cs->timestamp;\n\n            } else {\n\n                /* send absolute packet */\n\n                ngx_log_debug2(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                               \"live: abs %s packet timestamp=%uD\",\n                               type_s, ch.timestamp);\n\n                if (handler->apkt == NULL) {\n                    handler->apkt = handler->append_message_pt(ss, &ch,\n                                                             NULL, in);\n                    if (handler->apkt == NULL) {\n                        continue;\n                    }\n                }\n\n                rc = handler->send_message_pt(ss, handler->apkt, prio);\n                if (rc != NGX_OK) {\n                    continue;\n                }\n\n                cs->timestamp = ch.timestamp;\n                cs->active = 1;\n                ss->current_time = cs->timestamp;\n\n                ++peers;\n\n                continue;\n            }\n        }\n\n        if (handler->rpkt == NULL) {\n            handler->rpkt = handler->append_message_pt(ss, &ch, &lh, in);\n            if (handler->rpkt == NULL) {\n                continue;\n            }\n        }\n\n        /* send relative packet */\n\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                       \"live: rel %s packet delta=%uD\",\n                       type_s, delta);\n\n        if (handler->send_message_pt(ss, handler->rpkt, prio) != NGX_OK) {\n            ++pctx->ndropped;\n\n            cs->dropped += delta;\n\n            if (mandatory) {\n                ngx_log_debug0(NGX_LOG_DEBUG_RTMP, ss->connection->log, 0,\n                               \"live: mandatory packet failed\");\n                ngx_rtmp_finalize_session(ss);\n            }\n\n            continue;\n        }\n\n        cs->timestamp += delta;\n        ++peers;\n        ss->current_time = cs->timestamp;\n    }\n\n    for (i = 0; i <= NGX_RTMP_PROTOCOL_HTTP; i++) {\n        handler = ngx_rtmp_live_proc_handlers[i];\n\n        if (handler->meta) {\n            handler->free_message_pt(s, handler->meta);\n            handler->meta = NULL;\n        }\n\n        if (handler->rpkt) {\n            handler->free_message_pt(s, handler->rpkt);\n            handler->rpkt = NULL;\n        }\n\n        if (handler->apkt) {\n            handler->free_message_pt(s, handler->apkt);\n            handler->apkt = NULL;\n        }\n\n        if (handler->acopkt) {\n            handler->free_message_pt(s, handler->acopkt);\n            handler->acopkt = NULL;\n        }\n    }\n\n    ngx_rtmp_update_bandwidth(&ctx->stream->bw_in, h->mlen);\n    ngx_rtmp_update_bandwidth(&ctx->stream->bw_out, h->mlen * peers);\n\n    ngx_rtmp_update_bandwidth(h->type == NGX_RTMP_MSG_AUDIO ?\n                              &ctx->stream->bw_in_audio :\n                              &ctx->stream->bw_in_video,\n                              h->mlen);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_data(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n    ngx_chain_t *in, ngx_rtmp_amf_elt_t *out_elts, ngx_uint_t out_elts_size)\n{\n    ngx_rtmp_live_proc_handler_t   *handler;\n    ngx_rtmp_live_ctx_t            *ctx, *pctx;\n    ngx_chain_t                    *data, *rpkt;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_rtmp_live_app_conf_t       *lacf;\n    ngx_rtmp_session_t             *ss;\n    ngx_rtmp_header_t               ch;\n    ngx_int_t                       rc;\n    ngx_int_t                       csidx;\n    ngx_uint_t                      prio;\n    ngx_uint_t                      peers;\n    uint32_t                        delta;\n    ngx_rtmp_live_chunk_stream_t   *cs;\n    ngx_http_request_t             *r;\n#ifdef NGX_DEBUG\n    u_char                         *msg_type;\n\n    msg_type = (u_char *)out_elts[0].data;\n#endif\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (!lacf->live || in == NULL || in->buf == NULL) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL || ctx->stream == NULL) {\n        return NGX_OK;\n    }\n\n    if (!ctx->publishing) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"live: %s from non-publisher\", msg_type);\n        return NGX_OK;\n    }\n\n    /* drop the data packet if the stream is not active */\n    if (!ctx->stream->active) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: %s packet timestamp=%uD\",\n                   msg_type, h->timestamp);\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    csidx = !(lacf->interleave || h->type == NGX_RTMP_MSG_VIDEO);\n\n    cs = &ctx->cs[csidx];\n    cs->active = 1;\n\n    peers = 0;\n    prio = 0;\n    data = NULL;\n\n    rc = ngx_rtmp_append_amf(s, &data, NULL, out_elts, out_elts_size);\n    if (rc != NGX_OK) {\n        if (data) {\n            ngx_rtmp_free_shared_chain(cscf, data);\n        }\n\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(&ch, sizeof(ch));\n    ch.timestamp = h->timestamp;\n    ch.msid = NGX_RTMP_MSID;\n    ch.csid = h->csid;\n    ch.type = NGX_RTMP_MSG_AMF_META;\n\n    delta = ch.timestamp - cs->timestamp;\n\n    rpkt = ngx_rtmp_append_shared_bufs(cscf, data, in);\n\n    for (pctx = ctx->stream->ctx; pctx; pctx = pctx->next) {\n        if (pctx == ctx || pctx->paused) {\n            continue;\n        }\n\n        ss = pctx->session;\n        handler = ngx_rtmp_live_proc_handlers[pctx->protocol];\n        if (pctx->protocol == NGX_RTMP_PROTOCOL_HTTP) {\n            r = ss->data;\n            if (r == NULL || (r->connection && r->connection->destroyed)) {\n                continue;\n            }\n\n            handler->meta = handler->append_message_pt(ss, &ch, NULL, rpkt);\n            if (handler->meta == NULL) {\n                continue;\n            }\n\n            if (handler->send_message_pt(ss, handler->meta, 0) != NGX_OK) {\n                ++pctx->ndropped;\n                cs->dropped += delta;\n                handler->free_message_pt(ss, handler->meta);\n                handler->meta = NULL;\n                continue;\n            }\n\n            handler->free_message_pt(ss, handler->meta);\n            handler->meta = NULL;\n        } else {\n            ngx_rtmp_prepare_message(s, &ch, NULL, rpkt);\n            if (ngx_rtmp_send_message(ss, rpkt, prio) != NGX_OK) {\n                ++pctx->ndropped;\n                cs->dropped += delta;\n                continue;\n            }\n        }\n\n        cs->timestamp += delta;\n        ++peers;\n        ss->current_time = cs->timestamp;\n    }\n\n    if (data) {\n        ngx_rtmp_free_shared_chain(cscf, data);\n    }\n\n    if (rpkt) {\n        ngx_rtmp_free_shared_chain(cscf, rpkt);\n    }\n\n    ngx_rtmp_update_bandwidth(&ctx->stream->bw_in, h->mlen);\n    ngx_rtmp_update_bandwidth(&ctx->stream->bw_out, h->mlen * peers);\n    ngx_rtmp_update_bandwidth(&ctx->stream->bw_in_data, h->mlen);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_on_cue_point(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                           ngx_chain_t *in)\n{\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onCuePoint\", 0 }\n    };\n\n    return ngx_rtmp_live_data(s, h, in, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_on_text_data(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                           ngx_chain_t *in)\n{\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onTextData\", 0 }\n    };\n\n    return ngx_rtmp_live_data(s, h, in, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_on_fi(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                    ngx_chain_t *in)\n{\n    static ngx_rtmp_amf_elt_t  out_elts[] = {\n\n            { NGX_RTMP_AMF_STRING,\n              ngx_null_string,\n              \"onFi\", 0 }\n    };\n\n    return ngx_rtmp_live_data(s, h, in, out_elts,\n                              sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_on_fcpublish(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                           ngx_chain_t *in)\n{\n    ngx_rtmp_live_app_conf_t  *lacf;\n\n    static struct {\n        double                 trans;\n        u_char                 action[ACTION_VAR_LEN];\n        u_char                 stream[STREAM_VAR_LEN];\n    } v;\n\n    static ngx_rtmp_amf_elt_t  in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.stream, sizeof(v.stream) },\n    };\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n                       \"live: FCPublish - no live config!\");\n        return NGX_ERROR;\n    }\n\n    if (!lacf->live || in == NULL || in->buf == NULL) {\n        ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n                       \"live: FCPublish - no live or no buffer!\");\n        return NGX_OK;\n    }\n\n    ngx_memzero(&v, sizeof(v));\n    ngx_rtmp_receive_amf(s, in, in_elts,\n            sizeof(in_elts) / sizeof(in_elts[0]));\n\n    ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n            \"live: onFCPublish: stream='%s'\", v.stream);\n\n    return ngx_rtmp_send_fcpublish(s, v.stream);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_on_fcunpublish(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                             ngx_chain_t *in)\n{\n    ngx_rtmp_live_app_conf_t   *lacf;\n\n    static struct {\n        double                  trans;\n        u_char                  action[ACTION_VAR_LEN];\n        u_char                  stream[STREAM_VAR_LEN];\n    } v;\n\n    static ngx_rtmp_amf_elt_t   in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          &v.stream, sizeof(v.stream) },\n    };\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n    if (lacf == NULL) {\n        ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n                       \"live: FCUnpublish - no live config!\");\n        return NGX_ERROR;\n    }\n\n    if (!lacf->live || in == NULL || in->buf == NULL) {\n        ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n                       \"live: FCUnpublish - no live or no buffer!\");\n        return NGX_OK;\n    }\n\n    ngx_memzero(&v, sizeof(v));\n    ngx_rtmp_receive_amf(s, in, in_elts,\n            sizeof(in_elts) / sizeof(in_elts[0]));\n\n    ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n            \"live: onFCUnpublish: stream='%s'\", v.stream);\n\n    return ngx_rtmp_send_fcunpublish(s, v.stream);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_live_app_conf_t       *lacf;\n    ngx_rtmp_live_ctx_t            *ctx;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n\n    if (lacf == NULL || !lacf->live) {\n        goto next;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: publish: name='%s' type='%s'\",\n                   v->name, v->type);\n\n    /* join stream as publisher */\n\n    ngx_rtmp_live_join(s, v->name, 1);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL || !ctx->publishing) {\n        goto next;\n    }\n\n    ctx->silent = v->silent;\n\n    if (!ctx->silent) {\n        ngx_rtmp_send_status(s, \"NetStream.Publish.Start\",\n                             \"status\", \"Start publishing\");\n    }\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_live_app_conf_t       *lacf;\n    ngx_rtmp_live_ctx_t            *ctx;\n    ngx_http_request_t             *r;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_live_module);\n\n    if (lacf == NULL || !lacf->live) {\n        goto next;\n    }\n\n    if (!s->relay) {\n        /* request from http */\n        r = s->data;\n        if (r) {\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                          \"live: play from HTTP\");\n            goto next;\n        }\n    }\n\n    ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"live: play: name='%s' start=%uD duration=%uD reset=%d\",\n                   v->name, (uint32_t) v->start,\n                   (uint32_t) v->duration, (uint32_t) v->reset);\n\n    /* join stream as subscriber */\n\n    ngx_rtmp_live_join(s, v->name, 0);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_live_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    ctx->silent = v->silent;\n\n    if (!ctx->silent && !lacf->play_restart) {\n        ngx_rtmp_send_status(s, \"NetStream.Play.Start\",\n                             \"status\", \"Start live\");\n        ngx_rtmp_send_sample_access(s);\n    }\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_live_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n    ngx_rtmp_amf_handler_t             *ch;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    /* register raw event handlers */\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_AUDIO]);\n    *h = ngx_rtmp_live_av;\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_VIDEO]);\n    *h = ngx_rtmp_live_av;\n\n    /* chain handlers */\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_live_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_live_play;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_live_close_stream;\n\n    next_pause = ngx_rtmp_pause;\n    ngx_rtmp_pause = ngx_rtmp_live_pause;\n\n    next_stream_begin = ngx_rtmp_stream_begin;\n    ngx_rtmp_stream_begin = ngx_rtmp_live_stream_begin;\n\n    next_stream_eof = ngx_rtmp_stream_eof;\n    ngx_rtmp_stream_eof = ngx_rtmp_live_stream_eof;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"onTextData\");\n    ch->handler = ngx_rtmp_live_on_text_data;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"onCuePoint\");\n    ch->handler = ngx_rtmp_live_on_cue_point;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"onFi\");\n    ch->handler = ngx_rtmp_live_on_fi;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"FCPublish\");\n    ch->handler = ngx_rtmp_live_on_fcpublish;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"FCUnpublish\");\n    ch->handler = ngx_rtmp_live_on_fcunpublish;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_live_module.h",
          "type": "blob",
          "size": 2.923828125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#ifndef _NGX_RTMP_LIVE_H_INCLUDED_\n#define _NGX_RTMP_LIVE_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_bandwidth.h\"\n#include \"ngx_rtmp_streams.h\"\n\n\ntypedef struct ngx_rtmp_live_ctx_s ngx_rtmp_live_ctx_t;\ntypedef struct ngx_rtmp_live_stream_s ngx_rtmp_live_stream_t;\n\n\ntypedef struct {\n    unsigned                            active:1;\n    uint32_t                            timestamp;\n    uint32_t                            csid;\n    uint32_t                            dropped;\n} ngx_rtmp_live_chunk_stream_t;\n\n\nstruct ngx_rtmp_live_ctx_s {\n    ngx_rtmp_session_t                 *session;\n    ngx_rtmp_live_stream_t             *stream;\n    ngx_rtmp_live_ctx_t                *next;\n    ngx_uint_t                          ndropped;\n    ngx_rtmp_live_chunk_stream_t        cs[2];\n    ngx_uint_t                          meta_version;\n    ngx_event_t                         idle_evt;\n    unsigned                            active:1;\n    unsigned                            publishing:1;\n    unsigned                            silent:1;\n    unsigned                            paused:1;\n    ngx_uint_t                          protocol;\n};\n\n\nstruct ngx_rtmp_live_stream_s {\n    u_char                              name[NGX_RTMP_MAX_NAME];\n    ngx_rtmp_live_stream_t             *next;\n    ngx_rtmp_live_ctx_t                *ctx;\n    ngx_rtmp_live_ctx_t                *pub_ctx;\n    ngx_rtmp_bandwidth_t                bw_in;\n    ngx_rtmp_bandwidth_t                bw_in_audio;\n    ngx_rtmp_bandwidth_t                bw_in_video;\n    ngx_rtmp_bandwidth_t                bw_in_data;\n    ngx_rtmp_bandwidth_t                bw_out;\n    ngx_msec_t                          epoch;\n    unsigned                            active:1;\n    unsigned                            publishing:1;\n};\n\n\ntypedef struct {\n    ngx_int_t                           nbuckets;\n    ngx_rtmp_live_stream_t            **streams;\n    ngx_flag_t                          live;\n    ngx_flag_t                          meta;\n    ngx_msec_t                          sync;\n    ngx_msec_t                          idle_timeout;\n    ngx_flag_t                          atc;\n    ngx_flag_t                          interleave;\n    ngx_flag_t                          wait_key;\n    ngx_flag_t                          wait_video;\n    ngx_flag_t                          publish_notify;\n    ngx_flag_t                          play_restart;\n    ngx_flag_t                          idle_streams;\n    ngx_msec_t                          buflen;\n    ngx_pool_t                         *pool;\n    ngx_rtmp_live_stream_t             *free_streams;\n} ngx_rtmp_live_app_conf_t;\n\n\nextern ngx_module_t  ngx_rtmp_live_module;\n\n\nngx_rtmp_live_stream_t **ngx_rtmp_live_get_stream(ngx_rtmp_session_t *s,\n    u_char *name, int create);\n\n\n#endif /* _NGX_RTMP_LIVE_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_log_module.c",
          "type": "blob",
          "size": 30.171875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_cmd_module.h\"\n\n\nstatic ngx_rtmp_publish_pt  next_publish;\nstatic ngx_rtmp_play_pt     next_play;\n\n\nstatic ngx_int_t ngx_rtmp_log_postconfiguration(ngx_conf_t *cf);\nstatic void *ngx_rtmp_log_create_main_conf(ngx_conf_t *cf);\nstatic void * ngx_rtmp_log_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_log_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\nstatic char * ngx_rtmp_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic char * ngx_rtmp_log_set_format(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic char * ngx_rtmp_log_compile_format(ngx_conf_t *cf, ngx_array_t *ops,\n       ngx_array_t *args, ngx_uint_t s);\nstatic ngx_int_t ngx_rtmp_log_flush(ngx_rtmp_session_t *s,\n       ngx_rtmp_header_t *h, ngx_chain_t *in);\n\n\ntypedef struct ngx_rtmp_log_op_s ngx_rtmp_log_op_t;\n\n\ntypedef size_t (*ngx_rtmp_log_op_getlen_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_log_op_t *op);\ntypedef u_char * (*ngx_rtmp_log_op_getdata_pt)(ngx_rtmp_session_t *s,\n        u_char *buf, ngx_rtmp_log_op_t *log);\n\n\nstruct ngx_rtmp_log_op_s {\n    ngx_rtmp_log_op_getlen_pt   getlen;\n    ngx_rtmp_log_op_getdata_pt  getdata;\n    ngx_str_t                   value;\n    ngx_uint_t                  offset;\n};\n\n\ntypedef struct {\n    ngx_str_t                   name;\n    ngx_rtmp_log_op_getlen_pt   getlen;\n    ngx_rtmp_log_op_getdata_pt  getdata;\n    ngx_uint_t                  offset;\n} ngx_rtmp_log_var_t;\n\n\ntypedef struct {\n    ngx_str_t                   name;\n    ngx_array_t                *ops; /* ngx_rtmp_log_op_t */\n} ngx_rtmp_log_fmt_t;\n\n\ntypedef struct {\n    ngx_open_file_t            *file;\n    time_t                      disk_full_time;\n    time_t                      error_log_time;\n    ngx_rtmp_log_fmt_t         *format;\n} ngx_rtmp_log_t;\n\n\ntypedef struct {\n    ngx_array_t                *logs; /* ngx_rtmp_log_t */\n    ngx_uint_t                  off;\n    ngx_msec_t                  interval;\n    size_t                      size;\n} ngx_rtmp_log_app_conf_t;\n\n\ntypedef struct {\n    ngx_array_t                 formats; /* ngx_rtmp_log_fmt_t */\n    ngx_uint_t                  combined_used;\n} ngx_rtmp_log_main_conf_t;\n\n\ntypedef struct {\n    u_char                     *line;\n    ngx_event_t                 ev;\n    unsigned                    play:1;\n    unsigned                    publish:1;\n    u_char                      name[NGX_RTMP_MAX_NAME];\n    u_char                      args[NGX_RTMP_MAX_ARGS];\n    uint32_t                    last_sent;\n    uint32_t                    last_received;\n} ngx_rtmp_log_ctx_t;\n\n\nstatic ngx_str_t ngx_rtmp_access_log = ngx_string(NGX_HTTP_LOG_PATH);\n\n\nstatic ngx_command_t  ngx_rtmp_log_commands[] = {\n\n    { ngx_string(\"access_log\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE12,\n      ngx_rtmp_log_set_log,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"log_format\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_2MORE,\n      ngx_rtmp_log_set_format,\n      NGX_RTMP_MAIN_CONF_OFFSET,\n      0,\n      NULL },\n    {\n      ngx_string(\"log_interval\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_log_app_conf_t, interval),\n      NULL \n    },\n    {\n        ngx_string(\"log_size\"),\n        NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n        ngx_conf_set_size_slot,\n        NGX_RTMP_APP_CONF_OFFSET,\n        offsetof(ngx_rtmp_log_app_conf_t, size),\n        NULL\n    },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_log_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_log_postconfiguration,         /* postconfiguration */\n    ngx_rtmp_log_create_main_conf,          /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_log_create_app_conf,           /* create app configuration */\n    ngx_rtmp_log_merge_app_conf             /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_log_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_log_module_ctx,               /* module context */\n    ngx_rtmp_log_commands,                  /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_str_t ngx_rtmp_combined_fmt =\n    ngx_string(\"$remote_addr [$time_local] $command \"\n               \"\\\"$app\\\" \\\"$name\\\" \\\"$args\\\" - \"\n               \"$bytes_received $bytes_sent \"\n               \"\\\"$pageurl\\\" \\\"$flashver\\\" ($session_readable_time)\");\n\n\nstatic size_t\nngx_rtmp_log_var_default_getlen(ngx_rtmp_session_t *s, ngx_rtmp_log_op_t *op)\n{\n    return op->value.len;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_default_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_cpymem(buf, op->value.data, op->value.len);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_connection_getlen(ngx_rtmp_session_t *s, ngx_rtmp_log_op_t *op)\n{\n    return NGX_INT_T_LEN;\n}\n\nstatic u_char *\nngx_rtmp_log_var_connection_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_sprintf(buf, \"%ui\", (ngx_uint_t) s->connection->number);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_remote_addr_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return s->connection->addr_text.len;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_remote_addr_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_cpymem(buf, s->connection->addr_text.data,\n                           s->connection->addr_text.len);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_msec_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return NGX_TIME_T_LEN + 4;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_msec_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    ngx_time_t  *tp;\n\n    tp = ngx_timeofday();\n    \n    return ngx_sprintf(buf, \"%T.%03M\", tp->sec, tp->msec);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_session_string_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return ((ngx_str_t *) ((u_char *) s + op->offset))->len;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_session_string_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    ngx_str_t  *str;\n\n    str = (ngx_str_t *) ((u_char *) s + op->offset);\n\n    return ngx_cpymem(buf, str->data, str->len);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_command_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return sizeof(\"PLAY+PUBLISH\") - 1;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_command_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    ngx_rtmp_log_ctx_t *ctx;\n    ngx_str_t          *cmd;\n    ngx_uint_t          n;\n\n    static ngx_str_t    commands[] = {\n        ngx_string(\"NONE\"),\n        ngx_string(\"PLAY\"),\n        ngx_string(\"PUBLISH\"),\n        ngx_string(\"PLAY+PUBLISH\")\n    };\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n\n    n = ctx ? (ctx->play + ctx->publish * 2) : 0;\n\n    cmd = &commands[n];\n\n    return ngx_cpymem(buf, cmd->data, cmd->len);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_context_cstring_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_max(NGX_RTMP_MAX_NAME, NGX_RTMP_MAX_ARGS);\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_context_cstring_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    ngx_rtmp_log_ctx_t *ctx;\n    u_char             *p;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if (ctx == NULL) {\n        return buf;\n    }\n\n    p = (u_char *) ctx + op->offset;\n    while (*p) {\n        *buf++ = *p++;\n    }\n\n    return buf;\n}\n\n\nstatic size_t\nngx_rtmp_log_var_session_uint32_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return NGX_INT32_LEN;\n}\n\n\n#if 0\nstatic u_char *\nngx_rtmp_log_var_session_uint32_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    uint32_t   *v;\n\n    v = (uint32_t *) ((uint8_t *) s + op->offset);\n\n    return ngx_sprintf(buf, \"%uD\", *v);\n}\n#endif\n\n\nstatic size_t\nngx_rtmp_log_var_time_local_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_cached_http_log_time.len;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_time_local_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_cpymem(buf, ngx_cached_http_log_time.data,\n                      ngx_cached_http_log_time.len);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_session_time_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return NGX_INT64_LEN;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_session_time_getdata(ngx_rtmp_session_t *s, u_char *buf,\n    ngx_rtmp_log_op_t *op)\n{\n    return ngx_sprintf(buf, \"%L\",\n                       (int64_t) (ngx_current_msec - s->epoch) / 1000);\n}\n\n\nstatic size_t\nngx_rtmp_log_var_session_readable_time_getlen(ngx_rtmp_session_t *s,\n    ngx_rtmp_log_op_t *op)\n{\n    return NGX_INT_T_LEN + sizeof(\"d 23h 59m 59s\") - 1;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_session_readable_time_getdata(ngx_rtmp_session_t *s,\n    u_char *buf, ngx_rtmp_log_op_t *op)\n{\n    int64_t     v;\n    ngx_uint_t  days, hours, minutes, seconds;\n\n    v = (ngx_current_msec - s->epoch) / 1000;\n\n    days = (ngx_uint_t) (v / (60 * 60 * 24));\n    hours = (ngx_uint_t) (v / (60 * 60) % 24);\n    minutes = (ngx_uint_t) (v / 60 % 60);\n    seconds = (ngx_uint_t) (v % 60);\n\n    if (days) {\n        buf = ngx_sprintf(buf, \"%uid \", days);\n    }\n\n    if (days || hours) {\n        buf = ngx_sprintf(buf, \"%uih \", hours);\n    }\n\n    if (days || hours || minutes) {\n        buf = ngx_sprintf(buf, \"%uim \", minutes);\n    }\n\n    buf = ngx_sprintf(buf, \"%uis\", seconds);\n\n    return buf;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_session_bytesent_getdata(ngx_rtmp_session_t *s,\n    u_char *buf, ngx_rtmp_log_op_t *op)\n{\n    ngx_rtmp_log_ctx_t  *ctx;\n    uint32_t             sent;\n \n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if (ctx == NULL) {        \n        if (s->out_bytes > 0) {\n            return ngx_sprintf(buf, \"%uD\", s->out_bytes);\n        }\n\n        *buf = '0';\n        return buf + 1;\n    }\n    \n    sent = s->out_bytes - ctx->last_sent;\n    ctx->last_sent = s->out_bytes;\n\n    if (sent > 0) {\n        return ngx_sprintf(buf, \"%uD\", sent);\n    }\n\n    *buf = '0';\n    return buf + 1;\n}\n\n\nstatic u_char *\nngx_rtmp_log_var_session_bytereceived_getdata(ngx_rtmp_session_t *s,\n    u_char *buf, ngx_rtmp_log_op_t *op)\n{\n    ngx_rtmp_log_ctx_t  *ctx;\n    uint32_t             received;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if (ctx == NULL) {\n        if (s->in_bytes > 0) {\n            return ngx_sprintf(buf, \"%uD\", s->in_bytes);\n        }\n\n        *buf = '0';\n        return buf + 1;\n    }\n\n    received = s->in_bytes - ctx->last_received;\n    ctx->last_received = s->in_bytes;\n\n    if (received > 0) {\n        return ngx_sprintf(buf, \"%uD\", received);\n    }\n\n    *buf = '0';\n    return buf + 1;\n}\n\n\nstatic ngx_rtmp_log_var_t ngx_rtmp_log_vars[] = {\n    { ngx_string(\"connection\"),\n      ngx_rtmp_log_var_connection_getlen,\n      ngx_rtmp_log_var_connection_getdata,\n      0 },\n\n    { ngx_string(\"remote_addr\"),\n      ngx_rtmp_log_var_remote_addr_getlen,\n      ngx_rtmp_log_var_remote_addr_getdata,\n      0 },\n\n    { ngx_string(\"app\"),\n      ngx_rtmp_log_var_session_string_getlen,\n      ngx_rtmp_log_var_session_string_getdata,\n      offsetof(ngx_rtmp_session_t, app) },\n\n    { ngx_string(\"flashver\"),\n      ngx_rtmp_log_var_session_string_getlen,\n      ngx_rtmp_log_var_session_string_getdata,\n      offsetof(ngx_rtmp_session_t, flashver) },\n\n    { ngx_string(\"swfurl\"),\n      ngx_rtmp_log_var_session_string_getlen,\n      ngx_rtmp_log_var_session_string_getdata,\n      offsetof(ngx_rtmp_session_t, swf_url) },\n\n    { ngx_string(\"tcurl\"),\n      ngx_rtmp_log_var_session_string_getlen,\n      ngx_rtmp_log_var_session_string_getdata,\n      offsetof(ngx_rtmp_session_t, tc_url) },\n\n    { ngx_string(\"pageurl\"),\n      ngx_rtmp_log_var_session_string_getlen,\n      ngx_rtmp_log_var_session_string_getdata,\n      offsetof(ngx_rtmp_session_t, page_url) },\n\n    { ngx_string(\"command\"),\n      ngx_rtmp_log_var_command_getlen,\n      ngx_rtmp_log_var_command_getdata,\n      0 },\n\n    { ngx_string(\"name\"),\n      ngx_rtmp_log_var_context_cstring_getlen,\n      ngx_rtmp_log_var_context_cstring_getdata,\n      offsetof(ngx_rtmp_log_ctx_t, name) },\n\n    { ngx_string(\"args\"),\n      ngx_rtmp_log_var_context_cstring_getlen,\n      ngx_rtmp_log_var_context_cstring_getdata,\n      offsetof(ngx_rtmp_log_ctx_t, args) },\n\n    { ngx_string(\"bytes_sent\"),\n      ngx_rtmp_log_var_session_uint32_getlen,\n      ngx_rtmp_log_var_session_bytesent_getdata,\n      0 },\n\n    { ngx_string(\"bytes_received\"),\n      ngx_rtmp_log_var_session_uint32_getlen,\n      ngx_rtmp_log_var_session_bytereceived_getdata,\n      0 },\n\n    { ngx_string(\"time_local\"),\n      ngx_rtmp_log_var_time_local_getlen,\n      ngx_rtmp_log_var_time_local_getdata,\n      0 },\n\n    { ngx_string(\"msec\"),\n      ngx_rtmp_log_var_msec_getlen,\n      ngx_rtmp_log_var_msec_getdata,\n      0 },\n\n    { ngx_string(\"session_time\"),\n      ngx_rtmp_log_var_session_time_getlen,\n      ngx_rtmp_log_var_session_time_getdata,\n      0 },\n\n    { ngx_string(\"session_readable_time\"),\n      ngx_rtmp_log_var_session_readable_time_getlen,\n      ngx_rtmp_log_var_session_readable_time_getdata,\n      0 },\n\n    { ngx_null_string, NULL, NULL, 0 }\n};\n\n\nstatic void *\nngx_rtmp_log_create_main_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_log_main_conf_t   *lmcf;\n    ngx_rtmp_log_fmt_t         *fmt;\n\n    lmcf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_log_main_conf_t));\n    if (lmcf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&lmcf->formats, cf->pool, 4, sizeof(ngx_rtmp_log_fmt_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    fmt = ngx_array_push(&lmcf->formats);\n    if (fmt == NULL) {\n        return NULL;\n    }\n\n    ngx_str_set(&fmt->name, \"combined\");\n\n    fmt->ops = ngx_array_create(cf->pool, 16, sizeof(ngx_rtmp_log_op_t));\n    if (fmt->ops == NULL) {\n        return NULL;\n    }\n\n    return lmcf;\n\n}\n\n\nstatic void *\nngx_rtmp_log_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_log_app_conf_t *lacf;\n\n    lacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_log_app_conf_t));\n    if (lacf == NULL) {\n        return NULL;\n    }\n\n    lacf->interval = NGX_CONF_UNSET_MSEC;\n    lacf->size = NGX_CONF_UNSET_SIZE;\n\n    return lacf;\n}\n\n\nstatic char *\nngx_rtmp_log_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_log_app_conf_t    *prev = parent;\n    ngx_rtmp_log_app_conf_t    *conf = child;\n    ngx_rtmp_log_main_conf_t   *lmcf;\n    ngx_rtmp_log_fmt_t         *fmt;\n    ngx_rtmp_log_t             *log;\n\n    ngx_conf_merge_msec_value(conf->interval, prev->interval, 0);\n    ngx_conf_merge_size_value(conf->size, prev->size, 1 * 1024 * 1024);\n\n    if (conf->logs || conf->off) {\n        return NGX_OK;\n    }\n\n    conf->logs = prev->logs;\n    conf->off = prev->off;\n\n    if (conf->logs || conf->off) {\n        return NGX_OK;\n    }\n\n    conf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_rtmp_log_t));\n    if (conf->logs == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    log = ngx_array_push(conf->logs);\n    if (log == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    log->file = ngx_conf_open_file(cf->cycle, &ngx_rtmp_access_log);\n    if (log->file == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    log->disk_full_time = 0;\n    log->error_log_time = 0;\n\n    lmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_log_module);\n    fmt = lmcf->formats.elts;\n\n    log->format = &fmt[0];\n    lmcf->combined_used = 1;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_log_set_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_log_app_conf_t    *lacf = conf;\n\n    ngx_rtmp_log_main_conf_t   *lmcf;\n    ngx_rtmp_log_fmt_t         *fmt;\n    ngx_rtmp_log_t             *log;\n    ngx_str_t                  *value, name;\n    ngx_uint_t                  n;\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n        lacf->off = 1;\n        return NGX_CONF_OK;\n    }\n\n    if (lacf->logs == NULL) {\n        lacf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_rtmp_log_t));\n        if (lacf->logs == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    log = ngx_array_push(lacf->logs);\n    if (log == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(log, sizeof(*log));\n\n    lmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_log_module);\n\n    log->file = ngx_conf_open_file(cf->cycle, &value[1]);\n    if (log->file == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (cf->args->nelts == 2) {\n        ngx_str_set(&name, \"combined\");\n        lmcf->combined_used = 1;\n\n    } else {\n        name = value[2];\n        if (ngx_strcmp(name.data, \"combined\") == 0) {\n            lmcf->combined_used = 1;\n        }\n    }\n\n    fmt = lmcf->formats.elts;\n    for (n = 0; n < lmcf->formats.nelts; ++n, ++fmt) {\n        if (fmt->name.len == name.len &&\n            ngx_strncasecmp(fmt->name.data, name.data, name.len) == 0)\n        {\n            log->format = fmt;\n            break;\n        }\n    }\n\n    if (log->format == NULL) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0, \"unknown log format \\\"%V\\\"\",\n                           &name);\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_log_set_format(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_log_main_conf_t   *lmcf = conf;\n    ngx_rtmp_log_fmt_t         *fmt;\n    ngx_str_t                  *value;\n    ngx_uint_t                  i;\n\n    value = cf->args->elts;\n\n    if (cf->cmd_type != NGX_RTMP_MAIN_CONF) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"\\\"log_format\\\" directive can only be used on \"\n                           \"\\\"rtmp\\\" level\");\n    }\n\n    fmt = lmcf->formats.elts;\n    for (i = 0; i < lmcf->formats.nelts; i++) {\n        if (fmt[i].name.len == value[1].len &&\n            ngx_strcmp(fmt[i].name.data, value[1].data) == 0)\n        {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"duplicate \\\"log_format\\\" name \\\"%V\\\"\",\n                               &value[1]);\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    fmt = ngx_array_push(&lmcf->formats);\n    if (fmt == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    fmt->name = value[1];\n\n    fmt->ops = ngx_array_create(cf->pool, 16, sizeof(ngx_rtmp_log_op_t));\n    if (fmt->ops == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    return ngx_rtmp_log_compile_format(cf, fmt->ops, cf->args, 2);\n}\n\n\nstatic char *\nngx_rtmp_log_compile_format(ngx_conf_t *cf, ngx_array_t *ops, ngx_array_t *args,\n                            ngx_uint_t s)\n{\n    size_t              i, len;\n    u_char             *data, *d, c;\n    ngx_uint_t          bracket;\n    ngx_str_t          *value, var;\n    ngx_rtmp_log_op_t  *op;\n    ngx_rtmp_log_var_t *v;\n\n    value = args->elts;\n\n    for (; s < args->nelts; ++s) {\n        i = 0;\n\n        len = value[s].len;\n        d = value[s].data;\n\n        while (i < len) {\n\n            op = ngx_array_push(ops);\n            if (op == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ngx_memzero(op, sizeof(*op));\n\n            data = &d[i];\n\n            if (d[i] == '$') {\n                if (++i == len) {\n                    goto invalid;\n                }\n\n                if (d[i] == '{') {\n                    bracket = 1;\n                    if (++i == len) {\n                        goto invalid;\n                    }\n                } else {\n                    bracket = 0;\n                }\n\n                var.data = &d[i];\n\n                for (var.len = 0; i < len; ++i, ++var.len) {\n                    c = d[i];\n\n                    if (c == '}' && bracket) {\n                        ++i;\n                        bracket = 0;\n                        break;\n                    }\n\n                    if ((c >= 'A' && c <= 'Z') ||\n                        (c >= 'a' && c <= 'z') ||\n                        (c >= '0' && c <= '9') ||\n                        (c == '_'))\n                    {\n                        continue;\n                    }\n\n                    break;\n                }\n\n                if (bracket) {\n                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                       \"missing closing bracket in \\\"%V\\\"\",\n                                       &var);\n                    return NGX_CONF_ERROR;\n                }\n\n                if (var.len == 0) {\n                    goto invalid;\n                }\n\n                for (v = ngx_rtmp_log_vars; v->name.len; ++v) {\n                    if (v->name.len == var.len &&\n                        ngx_strncmp(v->name.data, var.data, var.len) == 0)\n                    {\n                        op->getlen = v->getlen;\n                        op->getdata = v->getdata;\n                        op->offset = v->offset;\n                        break;\n                    }\n                }\n\n                if (v->name.len == 0) {\n                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                       \"unknown variable \\\"%V\\\"\", &var);\n                    return NGX_CONF_ERROR;\n                }\n\n                continue;\n            }\n\n            ++i;\n\n            while (i < len && d[i] != '$') {\n                ++i;\n            }\n\n            op->getlen = ngx_rtmp_log_var_default_getlen;\n            op->getdata = ngx_rtmp_log_var_default_getdata;\n\n            op->value.len = &d[i] - data;\n\n            op->value.data = ngx_pnalloc(cf->pool, op->value.len);\n            if (op->value.data == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ngx_memcpy(op->value.data, data, op->value.len);\n        }\n    }\n\n    return NGX_CONF_OK;\n\ninvalid:\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%s\\\"\", data);\n\n    return NGX_CONF_ERROR;\n}\n\n\nstatic void\nngx_rtmp_log_split_output_handler(ngx_event_t *ev)\n{\n    ngx_rtmp_session_t       *s;\n    ngx_rtmp_log_app_conf_t  *lacf;\n\n    s = ev->data;\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_log_module);\n    if (lacf == NULL || lacf->off || lacf->logs == NULL) {\n        return;\n    }\n\n    ngx_add_timer(ev, lacf->interval);\n    ngx_rtmp_log_flush(s, 0, 0);\n}\n\n\nstatic ngx_rtmp_log_ctx_t *\nngx_rtmp_log_set_names(ngx_rtmp_session_t *s, u_char *name, u_char *args)\n{\n    ngx_rtmp_log_ctx_t       *ctx;\n    ngx_rtmp_log_app_conf_t  *lacf;\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_log_module);\n    if (lacf == NULL || lacf->off || lacf->logs == NULL) {\n        return NULL;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_log_ctx_t));\n        if (ctx == NULL) {\n            return NULL;\n        }\n\n        ctx->line = ngx_pcalloc(s->connection->pool, lacf->size);\n        if (ctx->line == NULL) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"failed to allocate buffer for log line\");\n            return NULL;\n        }\n\n        if (lacf->interval) {\n            ctx->ev.handler = ngx_rtmp_log_split_output_handler;\n            ctx->ev.log = s->connection->log;\n            ctx->ev.data = s;\n            ctx->ev.timer_set = 0;\n            ctx->last_sent = 0;\n            ctx->last_received = 0;\n\n            ngx_add_timer(&ctx->ev, lacf->interval);\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_log_module);\n    }\n\n    ngx_memcpy(ctx->name, name, NGX_RTMP_MAX_NAME);\n    ngx_memcpy(ctx->args, args, NGX_RTMP_MAX_ARGS);\n\n    return ctx;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_log_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_log_ctx_t *ctx;\n\n    if (s->auto_pushed || s->relay) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_log_set_names(s, v->name, v->args);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    ctx->publish = 1;\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_log_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_log_ctx_t *ctx;\n\n    if (s->auto_pushed || s->relay) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_log_set_names(s, v->name, v->args);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    ctx->play = 1;\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic void\nngx_rtmp_log_write(ngx_rtmp_session_t *s, ngx_rtmp_log_t *log, u_char *buf,\n                   size_t len)\n{\n    u_char *name;\n    time_t  now;\n    ssize_t n;\n    int     err;\n\n    err = 0;\n    name = log->file->name.data;\n    n = ngx_write_fd(log->file->fd, buf, len);\n\n    if (n == (ssize_t) len) {\n        return;\n    }\n\n    now = ngx_time();\n\n    if (n == -1) {\n        err = ngx_errno;\n\n        if (err == NGX_ENOSPC) {\n            log->disk_full_time = now;\n        }\n\n        if (now - log->error_log_time > 59) {\n            ngx_log_error(NGX_LOG_ALERT, s->connection->log, err,\n                          ngx_write_fd_n \" to \\\"%s\\\" failed\", name);\n            log->error_log_time = now;\n        }\n    }\n\n    if (now - log->error_log_time > 59) {\n        ngx_log_error(NGX_LOG_ALERT, s->connection->log, err,\n                      ngx_write_fd_n \" to \\\"%s\\\" was incomplete: %z of %uz\",\n                      name, n, len);\n        log->error_log_time = now;\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_log_flush(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                   ngx_chain_t *in)\n{\n    ngx_rtmp_log_app_conf_t    *lacf;\n    ngx_rtmp_log_t             *log;\n    ngx_rtmp_log_op_t          *op;\n    ngx_rtmp_log_ctx_t         *ctx;\n    ngx_uint_t                  n, i;\n    u_char                     *p;\n    size_t                      len;\n\n    if (s->auto_pushed || s->relay) {\n        return NGX_OK;\n    }\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_log_module);\n    if (lacf == NULL || lacf->off || lacf->logs == NULL) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    log = lacf->logs->elts;\n    for (i = 0; i < lacf->logs->nelts; ++i, ++log) {\n\n        if (ngx_time() == log->disk_full_time) {\n            /* FreeBSD full disk protection;\n             * nginx http logger does the same */\n            continue;\n        }\n\n        len = 0;\n        op = log->format->ops->elts;\n        for (n = 0; n < log->format->ops->nelts; ++n, ++op) {\n            if (len + NGX_LINEFEED_SIZE <= lacf->size) {\n                len += op->getlen(s, op);\n            } else {\n                break;\n            }\n        }\n\n        len += NGX_LINEFEED_SIZE;\n\n        p = ctx->line;\n        op = log->format->ops->elts;\n        for (n = 0; n < log->format->ops->nelts; ++n, ++op) {\n            if (p + NGX_LINEFEED_SIZE <= ctx->line + lacf->size) {\n                p = op->getdata(s, p, op);\n            } else {\n                break;\n            }\n        }\n\n        ngx_linefeed(p);\n\n        ngx_rtmp_log_write(s, log, ctx->line, p - ctx->line);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_log_disconnect(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                        ngx_chain_t *in)\n{\n    ngx_rtmp_log_app_conf_t    *lacf;\n    ngx_rtmp_log_t             *log;\n    ngx_rtmp_log_op_t          *op;\n    ngx_uint_t                  n, i;\n    u_char                     *p;\n    ngx_rtmp_log_ctx_t         *ctx;\n    size_t                      len;\n\n    if (s->auto_pushed || s->relay) {\n        return NGX_OK;\n    }\n\n    lacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_log_module);\n    if (lacf == NULL || lacf->off || lacf->logs == NULL) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    log = lacf->logs->elts;\n    for (i = 0; i < lacf->logs->nelts; ++i, ++log) {\n\n        if (ngx_time() == log->disk_full_time) {\n            /* FreeBSD full disk protection;\n             * nginx http logger does the same */\n            continue;\n        }\n\n        len = 0;\n        op = log->format->ops->elts;\n        for (n = 0; n < log->format->ops->nelts; ++n, ++op) {\n            if (len + NGX_LINEFEED_SIZE <= lacf->size) {\n                len += op->getlen(s, op);\n            } else {\n                break;\n            }\n        }\n\n        len += NGX_LINEFEED_SIZE;\n\n        p = ctx->line;\n        op = log->format->ops->elts;\n        for (n = 0; n < log->format->ops->nelts; ++n, ++op) {\n            if (p + NGX_LINEFEED_SIZE <= ctx->line + lacf->size) {\n                p = op->getdata(s, p, op);\n            } else {\n                break;\n            }\n        }\n\n        ngx_linefeed(p);\n\n        ngx_rtmp_log_write(s, log, ctx->line, p - ctx->line);\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_log_module);\n    if(ctx && ctx->ev.timer_set) {\n        ngx_del_timer(&ctx->ev);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_log_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t  *cmcf;\n    ngx_rtmp_handler_pt        *h;\n    ngx_rtmp_log_main_conf_t   *lmcf;\n    ngx_array_t                 a;\n    ngx_rtmp_log_fmt_t         *fmt;\n    ngx_str_t                  *value;\n\n    lmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_log_module);\n    if (lmcf->combined_used) {\n        if (ngx_array_init(&a, cf->pool, 1, sizeof(ngx_str_t)) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        value = ngx_array_push(&a);\n        if (value == NULL) {\n            return NGX_ERROR;\n        }\n\n        *value = ngx_rtmp_combined_fmt;\n        fmt = lmcf->formats.elts;\n\n        if (ngx_rtmp_log_compile_format(cf, fmt->ops, &a, 0)\n            != NGX_CONF_OK)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_DISCONNECT]);\n    *h = ngx_rtmp_log_disconnect;\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_log_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_log_play;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_mp4_module.c",
          "type": "blob",
          "size": 69.6416015625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_play_module.h\"\n#include \"ngx_rtmp_codec_module.h\"\n#include \"ngx_rtmp_streams.h\"\n\n\nstatic ngx_int_t ngx_rtmp_mp4_postconfiguration(ngx_conf_t *cf);\nstatic ngx_int_t ngx_rtmp_mp4_init(ngx_rtmp_session_t *s,  ngx_file_t *f,\n       ngx_int_t aindex, ngx_int_t vindex);\nstatic ngx_int_t ngx_rtmp_mp4_done(ngx_rtmp_session_t *s,  ngx_file_t *f);\nstatic ngx_int_t ngx_rtmp_mp4_start(ngx_rtmp_session_t *s, ngx_file_t *f);\nstatic ngx_int_t ngx_rtmp_mp4_seek(ngx_rtmp_session_t *s,  ngx_file_t *f,\n                                   ngx_uint_t offset);\nstatic ngx_int_t ngx_rtmp_mp4_stop(ngx_rtmp_session_t *s,  ngx_file_t *f);\nstatic ngx_int_t ngx_rtmp_mp4_send(ngx_rtmp_session_t *s,  ngx_file_t *f,\n                                   ngx_uint_t *ts);\nstatic ngx_int_t ngx_rtmp_mp4_reset(ngx_rtmp_session_t *s);\n\n\n#define NGX_RTMP_MP4_MAX_FRAMES         8\n\n\n#pragma pack(push,4)\n\n\n/* disable zero-sized array warning by msvc */\n\n#if (NGX_WIN32)\n#pragma warning(push)\n#pragma warning(disable:4200)\n#endif\n\n\ntypedef struct {\n    uint32_t                            first_chunk;\n    uint32_t                            samples_per_chunk;\n    uint32_t                            sample_descrption_index;\n} ngx_rtmp_mp4_chunk_entry_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            entry_count;\n    ngx_rtmp_mp4_chunk_entry_t          entries[0];\n} ngx_rtmp_mp4_chunks_t;\n\n\ntypedef struct {\n    uint32_t                            sample_count;\n    uint32_t                            sample_delta;\n} ngx_rtmp_mp4_time_entry_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            entry_count;\n    ngx_rtmp_mp4_time_entry_t           entries[0];\n} ngx_rtmp_mp4_times_t;\n\n\ntypedef struct {\n    uint32_t                            sample_count;\n    uint32_t                            sample_offset;\n} ngx_rtmp_mp4_delay_entry_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            entry_count;\n    ngx_rtmp_mp4_delay_entry_t          entries[0];\n} ngx_rtmp_mp4_delays_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            entry_count;\n    uint32_t                            entries[0];\n} ngx_rtmp_mp4_keys_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            sample_size;\n    uint32_t                            sample_count;\n    uint32_t                            entries[0];\n} ngx_rtmp_mp4_sizes_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            field_size;\n    uint32_t                            sample_count;\n    uint32_t                            entries[0];\n} ngx_rtmp_mp4_sizes2_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            entry_count;\n    uint32_t                            entries[0];\n} ngx_rtmp_mp4_offsets_t;\n\n\ntypedef struct {\n    uint32_t                            version_flags;\n    uint32_t                            entry_count;\n    uint64_t                            entries[0];\n} ngx_rtmp_mp4_offsets64_t;\n\n\n#if (NGX_WIN32)\n#pragma warning(pop)\n#endif\n\n\n#pragma pack(pop)\n\n\ntypedef struct {\n    uint32_t                            timestamp;\n    uint32_t                            last_timestamp;\n    off_t                               offset;\n    size_t                              size;\n    ngx_int_t                           key;\n    uint32_t                            delay;\n\n    unsigned                            not_first:1;\n    unsigned                            valid:1;\n\n    ngx_uint_t                          pos;\n\n    ngx_uint_t                          key_pos;\n\n    ngx_uint_t                          chunk;\n    ngx_uint_t                          chunk_pos;\n    ngx_uint_t                          chunk_count;\n\n    ngx_uint_t                          time_pos;\n    ngx_uint_t                          time_count;\n\n    ngx_uint_t                          delay_pos;\n    ngx_uint_t                          delay_count;\n\n    ngx_uint_t                          size_pos;\n} ngx_rtmp_mp4_cursor_t;\n\n\ntypedef struct {\n    ngx_uint_t                          id;\n\n    ngx_int_t                           type;\n    ngx_int_t                           codec;\n    uint32_t                            csid;\n    u_char                              fhdr;\n    ngx_int_t                           time_scale;\n    uint64_t                            duration;\n\n    u_char                             *header;\n    size_t                              header_size;\n    unsigned                            header_sent:1;\n\n    ngx_rtmp_mp4_times_t               *times;\n    ngx_rtmp_mp4_delays_t              *delays;\n    ngx_rtmp_mp4_keys_t                *keys;\n    ngx_rtmp_mp4_chunks_t              *chunks;\n    ngx_rtmp_mp4_sizes_t               *sizes;\n    ngx_rtmp_mp4_sizes2_t              *sizes2;\n    ngx_rtmp_mp4_offsets_t             *offsets;\n    ngx_rtmp_mp4_offsets64_t           *offsets64;\n    ngx_rtmp_mp4_cursor_t               cursor;\n} ngx_rtmp_mp4_track_t;\n\n\ntypedef struct {\n    void                               *mmaped;\n    size_t                              mmaped_size;\n    ngx_fd_t                            extra;\n\n    unsigned                            meta_sent:1;\n\n    ngx_rtmp_mp4_track_t                tracks[2];\n    ngx_rtmp_mp4_track_t               *track;\n    ngx_uint_t                          ntracks;\n\n    ngx_uint_t                          width;\n    ngx_uint_t                          height;\n    ngx_uint_t                          nchannels;\n    ngx_uint_t                          sample_size;\n    ngx_uint_t                          sample_rate;\n\n    ngx_int_t                           atracks, vtracks;\n    ngx_int_t                           aindex, vindex;\n\n    uint32_t                            start_timestamp, epoch;\n} ngx_rtmp_mp4_ctx_t;\n\n\n#if (NGX_HAVE_LITTLE_ENDIAN)\n#define ngx_rtmp_mp4_make_tag(a, b, c, d)  \\\n    ((uint32_t)d << 24 | (uint32_t)c << 16 | (uint32_t)b << 8 | (uint32_t)a)\n#else\n#define ngx_rtmp_mp4_make_tag(a, b, c, d)  \\\n    ((uint32_t)a << 24 | (uint32_t)b << 16 | (uint32_t)c << 8 | (uint32_t)d)\n#endif\n\n\nstatic ngx_inline uint32_t\nngx_rtmp_mp4_to_rtmp_timestamp(ngx_rtmp_mp4_track_t *t, uint64_t ts)\n{\n    return (uint32_t) (ts * 1000 / t->time_scale);\n}\n\n\nstatic ngx_inline uint32_t\nngx_rtmp_mp4_from_rtmp_timestamp(ngx_rtmp_mp4_track_t *t, uint32_t ts)\n{\n    return (uint64_t) ts * t->time_scale / 1000;\n}\n\n\n#define NGX_RTMP_MP4_BUFLEN_ADDON       1000\n\n\nstatic u_char                           ngx_rtmp_mp4_buffer[1024*1024];\n\n\n#if (NGX_WIN32)\nstatic void *\nngx_rtmp_mp4_mmap(ngx_fd_t fd, size_t size, off_t offset, ngx_fd_t *extra)\n{\n    void           *data;\n\n    *extra = CreateFileMapping(fd, NULL, PAGE_READONLY,\n                               (DWORD) ((uint64_t) size >> 32),\n                               (DWORD) (size & 0xffffffff),\n                               NULL);\n    if (*extra == NULL) {\n        return NULL;\n    }\n\n    data = MapViewOfFile(*extra, FILE_MAP_READ,\n                         (DWORD) ((uint64_t) offset >> 32),\n                         (DWORD) (offset & 0xffffffff),\n                         size);\n\n    if (data == NULL) {\n        CloseHandle(*extra);\n    }\n\n    /*\n     * non-NULL result means map view handle is open\n     * and should be closed later\n     */\n\n    return data;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_munmap(void *data, size_t size, ngx_fd_t *extra)\n{\n    ngx_int_t  rc;\n\n    rc = NGX_OK;\n\n    if (UnmapViewOfFile(data) == 0) {\n        rc = NGX_ERROR;\n    }\n\n    if (CloseHandle(*extra) == 0) {\n        rc = NGX_ERROR;\n    }\n\n    return rc;\n}\n\n#else\n\nstatic void *\nngx_rtmp_mp4_mmap(ngx_fd_t fd, size_t size, off_t offset, ngx_fd_t *extra)\n{\n    void  *data;\n\n    data = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, offset);\n\n    /* valid address is never NULL since there's no MAP_FIXED */\n\n    return data == MAP_FAILED ? NULL : data;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_munmap(void *data, size_t size, ngx_fd_t *extra)\n{\n    return munmap(data, size);\n}\n\n#endif\n\n\nstatic ngx_int_t ngx_rtmp_mp4_parse(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_trak(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_mdhd(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_hdlr(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stsd(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stsc(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stts(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_ctts(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stss(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stsz(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stz2(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_stco(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_co64(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_avc1(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_avcC(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_mp4a(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_mp4v(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_esds(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_mp3(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_nmos(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_spex(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\n\n\ntypedef ngx_int_t (*ngx_rtmp_mp4_box_pt)(ngx_rtmp_session_t *s, u_char *pos,\n                                         u_char *last);\n\ntypedef struct {\n    uint32_t                            tag;\n    ngx_rtmp_mp4_box_pt                 handler;\n} ngx_rtmp_mp4_box_t;\n\n\nstatic ngx_rtmp_mp4_box_t                       ngx_rtmp_mp4_boxes[] = {\n    { ngx_rtmp_mp4_make_tag('t','r','a','k'),   ngx_rtmp_mp4_parse_trak   },\n    { ngx_rtmp_mp4_make_tag('m','d','i','a'),   ngx_rtmp_mp4_parse        },\n    { ngx_rtmp_mp4_make_tag('m','d','h','d'),   ngx_rtmp_mp4_parse_mdhd   },\n    { ngx_rtmp_mp4_make_tag('h','d','l','r'),   ngx_rtmp_mp4_parse_hdlr   },\n    { ngx_rtmp_mp4_make_tag('m','i','n','f'),   ngx_rtmp_mp4_parse        },\n    { ngx_rtmp_mp4_make_tag('s','t','b','l'),   ngx_rtmp_mp4_parse        },\n    { ngx_rtmp_mp4_make_tag('s','t','s','d'),   ngx_rtmp_mp4_parse_stsd   },\n    { ngx_rtmp_mp4_make_tag('s','t','s','c'),   ngx_rtmp_mp4_parse_stsc   },\n    { ngx_rtmp_mp4_make_tag('s','t','t','s'),   ngx_rtmp_mp4_parse_stts   },\n    { ngx_rtmp_mp4_make_tag('c','t','t','s'),   ngx_rtmp_mp4_parse_ctts   },\n    { ngx_rtmp_mp4_make_tag('s','t','s','s'),   ngx_rtmp_mp4_parse_stss   },\n    { ngx_rtmp_mp4_make_tag('s','t','s','z'),   ngx_rtmp_mp4_parse_stsz   },\n    { ngx_rtmp_mp4_make_tag('s','t','z','2'),   ngx_rtmp_mp4_parse_stz2   },\n    { ngx_rtmp_mp4_make_tag('s','t','c','o'),   ngx_rtmp_mp4_parse_stco   },\n    { ngx_rtmp_mp4_make_tag('c','o','6','4'),   ngx_rtmp_mp4_parse_co64   },\n    { ngx_rtmp_mp4_make_tag('a','v','c','1'),   ngx_rtmp_mp4_parse_avc1   },\n    { ngx_rtmp_mp4_make_tag('a','v','c','C'),   ngx_rtmp_mp4_parse_avcC   },\n    { ngx_rtmp_mp4_make_tag('m','p','4','a'),   ngx_rtmp_mp4_parse_mp4a   },\n    { ngx_rtmp_mp4_make_tag('m','p','4','v'),   ngx_rtmp_mp4_parse_mp4v   },\n    { ngx_rtmp_mp4_make_tag('e','s','d','s'),   ngx_rtmp_mp4_parse_esds   },\n    { ngx_rtmp_mp4_make_tag('.','m','p','3'),   ngx_rtmp_mp4_parse_mp3    },\n    { ngx_rtmp_mp4_make_tag('n','m','o','s'),   ngx_rtmp_mp4_parse_nmos   },\n    { ngx_rtmp_mp4_make_tag('s','p','e','x'),   ngx_rtmp_mp4_parse_spex   },\n    { ngx_rtmp_mp4_make_tag('w','a','v','e'),   ngx_rtmp_mp4_parse        }\n};\n\n\nstatic ngx_int_t ngx_rtmp_mp4_parse_descr(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_es(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_dc(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\nstatic ngx_int_t ngx_rtmp_mp4_parse_ds(ngx_rtmp_session_t *s, u_char *pos,\n       u_char *last);\n\n\ntypedef ngx_int_t (*ngx_rtmp_mp4_descriptor_pt)(ngx_rtmp_session_t *s,\n                                                u_char *pos, u_char *last);\n\ntypedef struct {\n    uint8_t                             tag;\n    ngx_rtmp_mp4_descriptor_pt          handler;\n} ngx_rtmp_mp4_descriptor_t;\n\n\nstatic ngx_rtmp_mp4_descriptor_t        ngx_rtmp_mp4_descriptors[] = {\n    { 0x03,   ngx_rtmp_mp4_parse_es   },    /* MPEG ES Descriptor */\n    { 0x04,   ngx_rtmp_mp4_parse_dc   },    /* MPEG DecoderConfig Descriptor */\n    { 0x05,   ngx_rtmp_mp4_parse_ds   }     /* MPEG DecoderSpec Descriptor */\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_mp4_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_mp4_postconfiguration,         /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    NULL,                                   /* create app configuration */\n    NULL                                    /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_mp4_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_mp4_module_ctx,               /* module context */\n    NULL,                                   /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_trak(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track) {\n        return NGX_OK;\n    }\n\n    ctx->track = (ctx->ntracks == sizeof(ctx->tracks) / sizeof(ctx->tracks[0]))\n                 ? NULL : &ctx->tracks[ctx->ntracks];\n\n    if (ctx->track) {\n        ngx_memzero(ctx->track, sizeof(*ctx->track));\n        ctx->track->id = ctx->ntracks;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: trying track %ui\", ctx->ntracks);\n    }\n\n    if (ngx_rtmp_mp4_parse(s, pos, last) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->track && ctx->track->type &&\n        (ctx->ntracks == 0 ||\n         ctx->tracks[0].type != ctx->tracks[ctx->ntracks].type))\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: adding track %ui\", ctx->ntracks);\n\n        if (ctx->track->type == NGX_RTMP_MSG_AUDIO) {\n            if (ctx->atracks++ != ctx->aindex) {\n                ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"mp4: skipping audio track %ui!=%ui\",\n                               ctx->atracks - 1, ctx->aindex);\n                ctx->track = NULL;\n                return NGX_OK;\n            }\n\n        } else {\n            if (ctx->vtracks++ != ctx->vindex) {\n                ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"mp4: skipping video track %i!=%i\",\n                               ctx->vtracks - 1, ctx->vindex);\n                ctx->track = NULL;\n                return NGX_OK;\n            }\n        }\n\n        ++ctx->ntracks;\n\n    } else {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: ignoring track %ui\", ctx->ntracks);\n    }\n\n    ctx->track = NULL;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_mdhd(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n    uint8_t                     version;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track == NULL) {\n        return NGX_OK;\n    }\n\n    t = ctx->track;\n\n    if (pos + 1 > last) {\n        return NGX_ERROR;\n    }\n\n    version = *(uint8_t *) pos;\n\n    switch (version) {\n        case 0:\n            if (pos + 20 > last) {\n                return NGX_ERROR;\n            }\n\n            pos += 12;\n            t->time_scale = ngx_rtmp_r32(*(uint32_t *) pos);\n            pos += 4;\n            t->duration = ngx_rtmp_r32(*(uint32_t *) pos);\n            break;\n\n        case 1:\n            if (pos + 28 > last) {\n                return NGX_ERROR;\n            }\n\n            pos += 20;\n            t->time_scale = ngx_rtmp_r32(*(uint32_t *) pos);\n            pos += 4;\n            t->duration = ngx_rtmp_r64(*(uint64_t *) pos);\n            break;\n\n        default:\n            return NGX_ERROR;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: duration time_scale=%ui duration=%uL\",\n                   t->time_scale, t->duration);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_hdlr(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    uint32_t                    type;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track == NULL) {\n        return NGX_OK;\n    }\n\n    if (pos + 12 > last) {\n        return NGX_ERROR;\n    }\n\n    type = *(uint32_t *)(pos + 8);\n\n    if (type == ngx_rtmp_mp4_make_tag('v','i','d','e')) {\n        ctx->track->type = NGX_RTMP_MSG_VIDEO;\n        ctx->track->csid = NGX_RTMP_CSID_VIDEO;\n\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: video track\");\n\n    } else if (type == ngx_rtmp_mp4_make_tag('s','o','u','n')) {\n        ctx->track->type = NGX_RTMP_MSG_AUDIO;\n        ctx->track->csid = NGX_RTMP_CSID_AUDIO;\n\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: audio track\");\n    } else {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: unknown track\");\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_video(ngx_rtmp_session_t *s, u_char *pos, u_char *last,\n                         ngx_int_t codec)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track == NULL) {\n        return NGX_OK;\n    }\n\n    ctx->track->codec = codec;\n\n    if (pos + 78 > last) {\n        return NGX_ERROR;\n    }\n\n    pos += 24;\n\n    ctx->width = ngx_rtmp_r16(*(uint16_t *) pos);\n\n    pos += 2;\n\n    ctx->height = ngx_rtmp_r16(*(uint16_t *) pos);\n\n    pos += 52;\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: video settings codec=%i, width=%ui, height=%ui\",\n                   codec, ctx->width, ctx->height);\n\n    if (ngx_rtmp_mp4_parse(s, pos, last) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ctx->track->fhdr = (u_char) ctx->track->codec;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_audio(ngx_rtmp_session_t *s, u_char *pos, u_char *last,\n                         ngx_int_t codec)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    u_char                     *p;\n    ngx_uint_t                  version;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track == NULL) {\n        return NGX_OK;\n    }\n\n    ctx->track->codec = codec;\n\n    if (pos + 28 > last) {\n        return NGX_ERROR;\n    }\n\n    pos += 8;\n\n    version = ngx_rtmp_r16(*(uint16_t *) pos);\n\n    pos += 8;\n\n    ctx->nchannels = ngx_rtmp_r16(*(uint16_t *) pos);\n\n    pos += 2;\n\n    ctx->sample_size = ngx_rtmp_r16(*(uint16_t *) pos);\n\n    pos += 6;\n\n    ctx->sample_rate = ngx_rtmp_r16(*(uint16_t *) pos);\n\n    pos += 4;\n\n    p = &ctx->track->fhdr;\n\n    *p = 0;\n\n    if (ctx->nchannels == 2) {\n        *p |= 0x01;\n    }\n\n    if (ctx->sample_size == 16) {\n        *p |= 0x02;\n    }\n\n    switch (ctx->sample_rate) {\n        case 5512:\n            break;\n\n        case 11025:\n            *p |= 0x04;\n            break;\n\n        case 22050:\n            *p |= 0x08;\n            break;\n\n        default:  /*44100 etc */\n            *p |= 0x0c;\n            break;\n    }\n\n    ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: audio settings version=%ui, codec=%i, nchannels==%ui, \"\n                   \"sample_size=%ui, sample_rate=%ui\",\n                   version, codec, ctx->nchannels, ctx->sample_size,\n                   ctx->sample_rate);\n\n    switch (version) {\n        case 1:\n            pos += 16;\n            break;\n\n        case 2:\n            pos += 36;\n    }\n\n    if (pos > last) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_mp4_parse(s, pos, last) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    *p |= (ctx->track->codec << 4);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_avc1(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    return ngx_rtmp_mp4_parse_video(s, pos, last, NGX_RTMP_VIDEO_H264);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_mp4v(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    return ngx_rtmp_mp4_parse_video(s, pos, last, NGX_RTMP_VIDEO_H264);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_avcC(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n\n    if (pos == last) {\n        return NGX_OK;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track == NULL || ctx->track->codec != NGX_RTMP_VIDEO_H264) {\n        return NGX_OK;\n    }\n\n    ctx->track->header = pos;\n    ctx->track->header_size = (size_t) (last - pos);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: video h264 header size=%uz\",\n                   ctx->track->header_size);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_mp4a(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    return ngx_rtmp_mp4_parse_audio(s, pos, last, NGX_RTMP_AUDIO_MP3);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_ds(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t     *ctx;\n    ngx_rtmp_mp4_track_t   *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->header = pos;\n    t->header_size = (size_t) (last - pos);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: decoder header size=%uz\", t->header_size);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_dc(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    uint8_t                 id;\n    ngx_rtmp_mp4_ctx_t     *ctx;\n    ngx_int_t              *pc;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx->track == NULL) {\n        return NGX_OK;\n    }\n\n    if (pos + 13 > last) {\n        return NGX_ERROR;\n    }\n\n    id = * (uint8_t *) pos;\n    pos += 13;\n    pc = &ctx->track->codec;\n\n    switch (id) {\n        case 0x21:\n            *pc = NGX_RTMP_VIDEO_H264;\n            break;\n\n        case 0x40:\n        case 0x66:\n        case 0x67:\n        case 0x68:\n            *pc = NGX_RTMP_AUDIO_AAC;\n            break;\n\n        case 0x69:\n        case 0x6b:\n            *pc = NGX_RTMP_AUDIO_MP3;\n            break;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: decoder descriptor id=%i codec=%i\",\n                   (ngx_int_t) id, *pc);\n\n    return ngx_rtmp_mp4_parse_descr(s, pos, last);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_es(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    uint16_t    id;\n    uint8_t     flags;\n\n    if (pos + 3 > last) {\n        return NGX_ERROR;\n    }\n\n    id = ngx_rtmp_r16(*(uint16_t *) pos);\n    pos += 2;\n\n    flags = *(uint8_t *) pos;\n    ++pos;\n\n    if (flags & 0x80) { /* streamDependenceFlag */\n        pos += 2;\n    }\n\n    if (flags & 0x40) { /* URL_FLag */\n        return NGX_OK;\n    }\n\n    if (flags & 0x20) { /* OCRstreamFlag */\n        pos += 2;\n    }\n\n    if (pos > last) {\n        return NGX_ERROR;\n    }\n\n    (void) id;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: es descriptor es id=%i flags=%i\",\n                   (ngx_int_t) id, (ngx_int_t) flags);\n\n    return ngx_rtmp_mp4_parse_descr(s, pos, last);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_descr(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    uint8_t                     tag, v;\n    uint32_t                    size;\n    ngx_uint_t                  n, ndesc;\n    ngx_rtmp_mp4_descriptor_t   *ds;\n\n    ndesc = sizeof(ngx_rtmp_mp4_descriptors)\n          / sizeof(ngx_rtmp_mp4_descriptors[0]);\n\n    while (pos < last) {\n        tag = *(uint8_t *) pos++;\n\n        for (size = 0, n = 0; n < 4; ++n) {\n            if (pos == last) {\n                return NGX_ERROR;\n            }\n\n            v = *(uint8_t *) pos++;\n\n            size = (size << 7) | (v & 0x7f);\n\n            if (!(v & 0x80)) {\n                break;\n            }\n        }\n\n        if (pos + size > last) {\n            return NGX_ERROR;\n        }\n\n        ds = ngx_rtmp_mp4_descriptors;;\n\n        for (n = 0; n < ndesc; ++n, ++ds) {\n            if (tag == ds->tag) {\n                break;\n            }\n        }\n\n        if (n == ndesc) {\n            ds = NULL;\n        }\n\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"mp4: descriptor%s tag=%i size=%uD\",\n                ds ? \"\" : \" unhandled\", (ngx_int_t) tag, size);\n\n        if (ds && ds->handler(s, pos, pos + size) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        pos += size;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_esds(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    if (pos + 4 > last) {\n        return NGX_ERROR;\n    }\n\n    pos += 4; /* version */\n\n    return ngx_rtmp_mp4_parse_descr(s, pos, last);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_mp3(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    return ngx_rtmp_mp4_parse_audio(s, pos, last, NGX_RTMP_AUDIO_MP3);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_nmos(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    return ngx_rtmp_mp4_parse_audio(s, pos, last, NGX_RTMP_AUDIO_NELLY);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_spex(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    return ngx_rtmp_mp4_parse_audio(s, pos, last, NGX_RTMP_AUDIO_SPEEX);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stsd(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    if (pos + 8 > last) {\n        return NGX_ERROR;\n    }\n\n    pos += 8;\n\n    ngx_rtmp_mp4_parse(s, pos, last);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stsc(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->chunks = (ngx_rtmp_mp4_chunks_t *) pos;\n\n    if (pos + sizeof(*t->chunks) + ngx_rtmp_r32(t->chunks->entry_count) *\n                                   sizeof(t->chunks->entries[0])\n        <= last)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: chunks entries=%uD\",\n                       ngx_rtmp_r32(t->chunks->entry_count));\n        return NGX_OK;\n    }\n\n    t->chunks = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stts(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->times = (ngx_rtmp_mp4_times_t *) pos;\n\n    if (pos + sizeof(*t->times) + ngx_rtmp_r32(t->times->entry_count) *\n                                  sizeof(t->times->entries[0])\n        <= last)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: times entries=%uD\",\n                       ngx_rtmp_r32(t->times->entry_count));\n        return NGX_OK;\n    }\n\n    t->times = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_ctts(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->delays = (ngx_rtmp_mp4_delays_t *) pos;\n\n    if (pos + sizeof(*t->delays) + ngx_rtmp_r32(t->delays->entry_count) *\n                                   sizeof(t->delays->entries[0])\n        <= last)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: delays entries=%uD\",\n                       ngx_rtmp_r32(t->delays->entry_count));\n        return NGX_OK;\n    }\n\n    t->delays = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stss(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->keys = (ngx_rtmp_mp4_keys_t *) pos;\n\n    if (pos + sizeof(*t->keys) + ngx_rtmp_r32(t->keys->entry_count) *\n                                  sizeof(t->keys->entries[0])\n        <= last)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: keys entries=%uD\",\n                       ngx_rtmp_r32(t->keys->entry_count));\n        return NGX_OK;\n    }\n\n    t->keys = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stsz(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->sizes = (ngx_rtmp_mp4_sizes_t *) pos;\n\n    if (pos + sizeof(*t->sizes) <= last && t->sizes->sample_size) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: sizes size=%uD\",\n                       ngx_rtmp_r32(t->sizes->sample_size));\n        return NGX_OK;\n    }\n\n    if (pos + sizeof(*t->sizes) + ngx_rtmp_r32(t->sizes->sample_count) *\n                                  sizeof(t->sizes->entries[0])\n        <= last)\n\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: sizes entries=%uD\",\n                       ngx_rtmp_r32(t->sizes->sample_count));\n        return NGX_OK;\n    }\n\n    t->sizes = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stz2(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->sizes2 = (ngx_rtmp_mp4_sizes2_t *) pos;\n\n    if (pos + sizeof(*t->sizes) + ngx_rtmp_r32(t->sizes2->sample_count) *\n                                  ngx_rtmp_r32(t->sizes2->field_size) / 8\n        <= last)\n    {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: sizes2 field_size=%uD entries=%uD\",\n                       ngx_rtmp_r32(t->sizes2->field_size),\n                       ngx_rtmp_r32(t->sizes2->sample_count));\n        return NGX_OK;\n    }\n\n    t->sizes2 = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_stco(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->offsets = (ngx_rtmp_mp4_offsets_t *) pos;\n\n    if (pos + sizeof(*t->offsets) + ngx_rtmp_r32(t->offsets->entry_count) *\n                                    sizeof(t->offsets->entries[0])\n        <= last)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: offsets entries=%uD\",\n                       ngx_rtmp_r32(t->offsets->entry_count));\n        return NGX_OK;\n    }\n\n    t->offsets = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse_co64(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    ngx_rtmp_mp4_track_t       *t;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    t = ctx->track;\n\n    if (t == NULL) {\n        return NGX_OK;\n    }\n\n    t->offsets64 = (ngx_rtmp_mp4_offsets64_t *) pos;\n\n    if (pos + sizeof(*t->offsets64) + ngx_rtmp_r32(t->offsets64->entry_count) *\n                                      sizeof(t->offsets64->entries[0])\n        <= last)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: offsets64 entries=%uD\",\n                       ngx_rtmp_r32(t->offsets64->entry_count));\n        return NGX_OK;\n    }\n\n    t->offsets64 = NULL;\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_parse(ngx_rtmp_session_t *s, u_char *pos, u_char *last)\n{\n    uint32_t                   *hdr, tag;\n    size_t                      size, nboxes;\n    ngx_uint_t                  n;\n    ngx_rtmp_mp4_box_t         *b;\n\n    while (pos != last) {\n        if (pos + 8 > last) {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: too small box: size=%i\", last - pos);\n            return NGX_ERROR;\n        }\n\n        hdr = (uint32_t *) pos;\n        size = ngx_rtmp_r32(hdr[0]);\n        if (size == 0) {\n            return NGX_ERROR;\n        }\n\n        tag  = hdr[1];\n\n        if (pos + size > last) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                          \"mp4: too big box '%*s': size=%uz\",\n                          4, &tag, size);\n            return NGX_ERROR;\n        }\n\n        b = ngx_rtmp_mp4_boxes;\n        nboxes = sizeof(ngx_rtmp_mp4_boxes) / sizeof(ngx_rtmp_mp4_boxes[0]);\n\n        for (n = 0; n < nboxes && b->tag != tag; ++n, ++b);\n\n        if (n == nboxes) {\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: box unhandled '%*s'\", 4, &tag);\n        } else {\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: box '%*s'\", 4, &tag);\n            b->handler(s, pos + 8, pos + size);\n        }\n\n        pos += size;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_next_time(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t      *cr;\n    ngx_rtmp_mp4_time_entry_t  *te;\n\n    if (t->times == NULL) {\n        return NGX_ERROR;\n    }\n\n    cr = &t->cursor;\n\n    if (cr->time_pos >= ngx_rtmp_r32(t->times->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui time[%ui/%uD] overflow\",\n                       t->id, cr->time_pos,\n                       ngx_rtmp_r32(t->times->entry_count));\n\n        return NGX_ERROR;\n    }\n\n    te = &t->times->entries[cr->time_pos];\n\n    cr->last_timestamp = cr->timestamp;\n    cr->timestamp += ngx_rtmp_r32(te->sample_delta);\n\n    cr->not_first = 1;\n\n    ngx_log_debug8(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui time[%ui] [%ui/%uD][%ui/%uD]=%uD t=%uD\",\n                   t->id, cr->pos, cr->time_pos,\n                   ngx_rtmp_r32(t->times->entry_count),\n                   cr->time_count, ngx_rtmp_r32(te->sample_count),\n                   ngx_rtmp_r32(te->sample_delta),\n                   cr->timestamp);\n\n    cr->time_count++;\n    cr->pos++;\n\n    if (cr->time_count >= ngx_rtmp_r32(te->sample_count)) {\n        cr->time_pos++;\n        cr->time_count = 0;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek_time(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t,\n                       uint32_t timestamp)\n{\n    ngx_rtmp_mp4_cursor_t      *cr;\n    ngx_rtmp_mp4_time_entry_t  *te;\n    uint32_t                    dt;\n\n    if (t->times == NULL) {\n        return NGX_ERROR;\n    }\n\n    cr = &t->cursor;\n\n    te = t->times->entries;\n\n    while (cr->time_pos < ngx_rtmp_r32(t->times->entry_count)) {\n        dt = ngx_rtmp_r32(te->sample_delta) * ngx_rtmp_r32(te->sample_count);\n\n        if (cr->timestamp + dt >= timestamp) {\n            if (te->sample_delta == 0) {\n                return NGX_ERROR;\n            }\n\n            cr->time_count = (timestamp - cr->timestamp) /\n                             ngx_rtmp_r32(te->sample_delta);\n            cr->timestamp += ngx_rtmp_r32(te->sample_delta) * cr->time_count;\n            cr->pos += cr->time_count;\n\n            break;\n        }\n\n        cr->timestamp += dt;\n        cr->pos += ngx_rtmp_r32(te->sample_count);\n        cr->time_pos++;\n        te++;\n    }\n\n    if (cr->time_pos >= ngx_rtmp_r32(t->times->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui seek time[%ui/%uD] overflow\",\n                       t->id, cr->time_pos,\n                       ngx_rtmp_r32(t->times->entry_count));\n\n        return  NGX_ERROR;\n    }\n\n    ngx_log_debug8(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui seek time[%ui] [%ui/%uD][%ui/%uD]=%uD \"\n                   \"t=%uD\",\n                   t->id, cr->pos, cr->time_pos,\n                   ngx_rtmp_r32(t->times->entry_count),\n                   cr->time_count,\n                   ngx_rtmp_r32(te->sample_count),\n                   ngx_rtmp_r32(te->sample_delta),\n                   cr->timestamp);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_update_offset(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n    ngx_uint_t                      chunk;\n\n    cr = &t->cursor;\n\n    if (cr->chunk < 1) {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui offset[%ui] underflow\",\n                       t->id, cr->chunk);\n        return NGX_ERROR;\n    }\n\n    chunk = cr->chunk - 1;\n\n    if (t->offsets) {\n        if (chunk >= ngx_rtmp_r32(t->offsets->entry_count)) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui offset[%ui/%uD] overflow\",\n                           t->id, cr->chunk,\n                           ngx_rtmp_r32(t->offsets->entry_count));\n\n            return NGX_ERROR;\n        }\n\n        cr->offset = (off_t) ngx_rtmp_r32(t->offsets->entries[chunk]);\n        cr->size = 0;\n\n        ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui offset[%ui/%uD]=%O\",\n                       t->id, cr->chunk,\n                       ngx_rtmp_r32(t->offsets->entry_count),\n                       cr->offset);\n\n        return NGX_OK;\n    }\n\n    if (t->offsets64) {\n        if (chunk >= ngx_rtmp_r32(t->offsets64->entry_count)) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui offset64[%ui/%uD] overflow\",\n                           t->id, cr->chunk,\n                           ngx_rtmp_r32(t->offsets->entry_count));\n\n            return NGX_ERROR;\n        }\n\n        cr->offset = (off_t) ngx_rtmp_r64(t->offsets64->entries[chunk]);\n        cr->size = 0;\n\n        ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui offset64[%ui/%uD]=%O\",\n                       t->id, cr->chunk,\n                       ngx_rtmp_r32(t->offsets->entry_count),\n                       cr->offset);\n\n        return NGX_OK;\n    }\n\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_next_chunk(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n    ngx_rtmp_mp4_chunk_entry_t     *ce, *nce;\n    ngx_int_t                       new_chunk;\n\n    if (t->chunks == NULL) {\n        return NGX_OK;\n    }\n\n    cr = &t->cursor;\n\n    if (cr->chunk_pos >= ngx_rtmp_r32(t->chunks->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui chunk[%ui/%uD] overflow\",\n                       t->id, cr->chunk_pos,\n                       ngx_rtmp_r32(t->chunks->entry_count));\n\n        return NGX_ERROR;\n    }\n\n    ce = &t->chunks->entries[cr->chunk_pos];\n\n    cr->chunk_count++;\n\n    if (cr->chunk_count >= ngx_rtmp_r32(ce->samples_per_chunk)) {\n        cr->chunk_count = 0;\n        cr->chunk++;\n\n        if (cr->chunk_pos + 1 < ngx_rtmp_r32(t->chunks->entry_count)) {\n            nce = ce + 1;\n            if (cr->chunk >= ngx_rtmp_r32(nce->first_chunk)) {\n                cr->chunk_pos++;\n                ce = nce;\n            }\n        }\n\n        new_chunk = 1;\n\n    } else {\n        new_chunk = 0;\n    }\n\n    ngx_log_debug7(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui chunk[%ui/%uD][%uD..%ui][%ui/%uD]\",\n                   t->id, cr->chunk_pos,\n                   ngx_rtmp_r32(t->chunks->entry_count),\n                   ngx_rtmp_r32(ce->first_chunk),\n                   cr->chunk, cr->chunk_count,\n                   ngx_rtmp_r32(ce->samples_per_chunk));\n\n\n    if (new_chunk) {\n        return ngx_rtmp_mp4_update_offset(s, t);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek_chunk(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n    ngx_rtmp_mp4_chunk_entry_t     *ce, *nce;\n    ngx_uint_t                      pos, dpos, dchunk;\n\n    cr = &t->cursor;\n\n    if (t->chunks == NULL || t->chunks->entry_count == 0) {\n        cr->chunk = 1;\n        return NGX_OK;\n    }\n\n    ce = t->chunks->entries;\n    pos = 0;\n\n    while (cr->chunk_pos + 1 < ngx_rtmp_r32(t->chunks->entry_count)) {\n        nce = ce + 1;\n\n        dpos = (ngx_rtmp_r32(nce->first_chunk) -\n                ngx_rtmp_r32(ce->first_chunk)) *\n                ngx_rtmp_r32(ce->samples_per_chunk);\n\n        if (pos + dpos > cr->pos) {\n            break;\n        }\n\n        pos += dpos;\n        ce++;\n        cr->chunk_pos++;\n    }\n\n    if (ce->samples_per_chunk == 0) {\n        return NGX_ERROR;\n    }\n\n    dchunk = (cr->pos - pos) / ngx_rtmp_r32(ce->samples_per_chunk);\n\n    cr->chunk = ngx_rtmp_r32(ce->first_chunk) + dchunk;\n    cr->chunk_pos = (ngx_uint_t) (ce - t->chunks->entries);\n    cr->chunk_count = (ngx_uint_t) (cr->pos - pos - dchunk *\n                                    ngx_rtmp_r32(ce->samples_per_chunk));\n\n    ngx_log_debug7(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui seek chunk[%ui/%uD][%uD..%ui][%ui/%uD]\",\n                   t->id, cr->chunk_pos,\n                   ngx_rtmp_r32(t->chunks->entry_count),\n                   ngx_rtmp_r32(ce->first_chunk),\n                   cr->chunk, cr->chunk_count,\n                   ngx_rtmp_r32(ce->samples_per_chunk));\n\n    return ngx_rtmp_mp4_update_offset(s, t);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_next_size(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n\n    cr = &t->cursor;\n\n    cr->offset += cr->size;\n\n    if (t->sizes) {\n        if (t->sizes->sample_size) {\n            cr->size = ngx_rtmp_r32(t->sizes->sample_size);\n\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui size fix=%uz\",\n                           t->id, cr->size);\n\n            return NGX_OK;\n        }\n\n        cr->size_pos++;\n\n        if (cr->size_pos >= ngx_rtmp_r32(t->sizes->sample_count)) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui size[%ui/%uD] overflow\",\n                           t->id, cr->size_pos,\n                           ngx_rtmp_r32(t->sizes->sample_count));\n\n            return NGX_ERROR;\n        }\n\n        cr->size = ngx_rtmp_r32(t->sizes->entries[cr->size_pos]);\n\n        ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui size[%ui/%uD]=%uz\",\n                       t->id, cr->size_pos,\n                       ngx_rtmp_r32(t->sizes->sample_count),\n                       cr->size);\n\n        return NGX_OK;\n    }\n\n    if (t->sizes2) {\n        if (cr->size_pos >= ngx_rtmp_r32(t->sizes2->sample_count)) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui size[%ui/%uD] overflow\",\n                           t->id, cr->size_pos,\n                           ngx_rtmp_r32(t->sizes2->sample_count));\n\n            return NGX_ERROR;\n        }\n\n        /*TODO*/\n\n        return NGX_OK;\n    }\n\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek_size(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t      *cr;\n    ngx_uint_t                  pos;\n\n    cr = &t->cursor;\n\n    if (cr->chunk_count > cr->pos) {\n        return NGX_ERROR;\n    }\n\n    if (t->sizes) {\n        if (t->sizes->sample_size) {\n            cr->size = ngx_rtmp_r32(t->sizes->sample_size);\n\n            cr->offset += cr->size * cr->chunk_count;\n\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui seek size fix=%uz\",\n                           t->id, cr->size);\n\n            return NGX_OK;\n        }\n\n        if (cr->pos >= ngx_rtmp_r32(t->sizes->sample_count)) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui seek size[%ui/%uD] overflow\",\n                           t->id, cr->pos,\n                           ngx_rtmp_r32(t->sizes->sample_count));\n\n            return NGX_ERROR;\n        }\n\n        for (pos = 1; pos <= cr->chunk_count; ++pos) {\n            cr->offset += ngx_rtmp_r32(t->sizes->entries[cr->pos - pos]);\n        }\n\n        cr->size_pos = cr->pos;\n        cr->size = ngx_rtmp_r32(t->sizes->entries[cr->size_pos]);\n\n        ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui seek size[%ui/%uD]=%uz\",\n                       t->id, cr->size_pos,\n                       ngx_rtmp_r32(t->sizes->sample_count),\n                       cr->size);\n\n        return NGX_OK;\n    }\n\n    if (t->sizes2) {\n        if (cr->size_pos >= ngx_rtmp_r32(t->sizes2->sample_count)) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui seek size2[%ui/%uD] overflow\",\n                           t->id, cr->size_pos,\n                           ngx_rtmp_r32(t->sizes->sample_count));\n\n            return NGX_ERROR;\n        }\n\n        cr->size_pos = cr->pos;\n\n        /* TODO */\n        return NGX_OK;\n    }\n\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_next_key(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n    uint32_t                       *ke;\n\n    cr = &t->cursor;\n\n    if (t->keys == NULL) {\n        return NGX_OK;\n    }\n\n    if (cr->key) {\n        cr->key_pos++;\n    }\n\n    if (cr->key_pos >= ngx_rtmp_r32(t->keys->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"mp4: track#%ui key[%ui/%uD] overflow\",\n                t->id, cr->key_pos,\n                ngx_rtmp_r32(t->keys->entry_count));\n\n        cr->key = 0;\n\n        return NGX_OK;\n    }\n\n    ke = &t->keys->entries[cr->key_pos];\n    cr->key = (cr->pos + 1 == ngx_rtmp_r32(*ke));\n\n    ngx_log_debug6(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui key[%ui/%uD][%ui/%uD]=%s\",\n                   t->id, cr->key_pos,\n                   ngx_rtmp_r32(t->keys->entry_count),\n                   cr->pos, ngx_rtmp_r32(*ke),\n                   cr->key ? \"match\" : \"miss\");\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek_key(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t      *cr;\n    uint32_t                   *ke;\n    ngx_int_t                   dpos;\n\n    cr = &t->cursor;\n\n    if (t->keys == NULL) {\n        return NGX_OK;\n    }\n\n    while (cr->key_pos < ngx_rtmp_r32(t->keys->entry_count)) {\n        if (ngx_rtmp_r32(t->keys->entries[cr->key_pos]) > cr->pos) {\n            break;\n        }\n\n        cr->key_pos++;\n    }\n\n    if (cr->key_pos >= ngx_rtmp_r32(t->keys->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"mp4: track#%ui seek key[%ui/%uD] overflow\",\n                t->id, cr->key_pos,\n                ngx_rtmp_r32(t->keys->entry_count));\n        return NGX_OK;\n    }\n\n    ke = &t->keys->entries[cr->key_pos];\n    /*cr->key = (cr->pos + 1 == ngx_rtmp_r32(*ke));*/\n\n    /* distance to the next keyframe */\n    dpos = ngx_rtmp_r32(*ke) - cr->pos - 1;\n    cr->key = 1;\n\n    /* TODO: range version needed */\n    for (; dpos > 0; --dpos) {\n        ngx_rtmp_mp4_next_time(s, t);\n    }\n\n/*    cr->key = (cr->pos + 1 == ngx_rtmp_r32(*ke));*/\n\n    ngx_log_debug6(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui seek key[%ui/%uD][%ui/%uD]=%s\",\n                   t->id, cr->key_pos,\n                   ngx_rtmp_r32(t->keys->entry_count),\n                   cr->pos, ngx_rtmp_r32(*ke),\n                   cr->key ? \"match\" : \"miss\");\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_next_delay(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n    ngx_rtmp_mp4_delay_entry_t     *de;\n\n    cr = &t->cursor;\n\n    if (t->delays == NULL) {\n        return NGX_OK;\n    }\n\n    if (cr->delay_pos >= ngx_rtmp_r32(t->delays->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"mp4: track#%ui delay[%ui/%uD] overflow\",\n                t->id, cr->delay_pos,\n                ngx_rtmp_r32(t->delays->entry_count));\n\n        return NGX_OK;\n    }\n\n    cr->delay_count++;\n    de = &t->delays->entries[cr->delay_pos];\n\n    if (cr->delay_count >= ngx_rtmp_r32(de->sample_count)) {\n        cr->delay_pos++;\n        de++;\n        cr->delay_count = 0;\n    }\n\n    if (cr->delay_pos >= ngx_rtmp_r32(t->delays->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"mp4: track#%ui delay[%ui/%uD] overflow\",\n                t->id, cr->delay_pos,\n                ngx_rtmp_r32(t->delays->entry_count));\n\n        return NGX_OK;\n    }\n\n    cr->delay = ngx_rtmp_r32(de->sample_offset);\n\n    ngx_log_debug6(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui delay[%ui/%uD][%ui/%uD]=%ui\",\n                   t->id, cr->delay_pos,\n                   ngx_rtmp_r32(t->delays->entry_count),\n                   cr->delay_count,\n                   ngx_rtmp_r32(de->sample_count), cr->delay);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek_delay(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    ngx_rtmp_mp4_cursor_t      *cr;\n    ngx_rtmp_mp4_delay_entry_t *de;\n    uint32_t                    pos, dpos;\n\n    cr = &t->cursor;\n\n    if (t->delays == NULL) {\n        return NGX_OK;\n    }\n\n    pos = 0;\n    de = t->delays->entries;\n\n    while (cr->delay_pos < ngx_rtmp_r32(t->delays->entry_count)) {\n        dpos = ngx_rtmp_r32(de->sample_count);\n\n        if (pos + dpos > cr->pos) {\n            cr->delay_count = cr->pos - pos;\n            cr->delay = ngx_rtmp_r32(de->sample_offset);\n            break;\n        }\n\n        cr->delay_pos++;\n        pos += dpos;\n        de++;\n    }\n\n    if (cr->delay_pos >= ngx_rtmp_r32(t->delays->entry_count)) {\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"mp4: track#%ui seek delay[%ui/%uD] overflow\",\n                t->id, cr->delay_pos,\n                ngx_rtmp_r32(t->delays->entry_count));\n\n        return NGX_OK;\n    }\n\n    ngx_log_debug6(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: track#%ui seek delay[%ui/%uD][%ui/%uD]=%ui\",\n                   t->id, cr->delay_pos,\n                   ngx_rtmp_r32(t->delays->entry_count),\n                   cr->delay_count,\n                   ngx_rtmp_r32(de->sample_count), cr->delay);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_next(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t)\n{\n    if (ngx_rtmp_mp4_next_time(s, t)  != NGX_OK ||\n        ngx_rtmp_mp4_next_key(s, t)   != NGX_OK ||\n        ngx_rtmp_mp4_next_chunk(s, t) != NGX_OK ||\n        ngx_rtmp_mp4_next_size(s, t)  != NGX_OK ||\n        ngx_rtmp_mp4_next_delay(s, t) != NGX_OK)\n    {\n        t->cursor.valid = 0;\n        return NGX_ERROR;\n    }\n\n    t->cursor.valid = 1;\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_send_meta(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_mp4_ctx_t             *ctx;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_int_t                       rc;\n    ngx_uint_t                      n;\n    ngx_rtmp_header_t               h;\n    ngx_chain_t                    *out;\n    ngx_rtmp_mp4_track_t           *t;\n    double                          d;\n\n    static struct {\n        double                      width;\n        double                      height;\n        double                      duration;\n        double                      video_codec_id;\n        double                      audio_codec_id;\n        double                      audio_sample_rate;\n    }                               v;\n\n    static ngx_rtmp_amf_elt_t       out_inf[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"width\"),\n          &v.width, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"height\"),\n          &v.height, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"displayWidth\"),\n          &v.width, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"displayHeight\"),\n          &v.height, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"duration\"),\n          &v.duration, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"videocodecid\"),\n          &v.video_codec_id, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audiocodecid\"),\n          &v.audio_codec_id, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audiosamplerate\"),\n          &v.audio_sample_rate, 0 },\n    };\n\n    static ngx_rtmp_amf_elt_t       out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onMetaData\", 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf, sizeof(out_inf) },\n    };\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    ngx_memzero(&v, sizeof(v));\n\n    v.width  = ctx->width;\n    v.height = ctx->height;\n    v.audio_sample_rate = ctx->sample_rate;\n\n    t = &ctx->tracks[0];\n    for (n = 0; n < ctx->ntracks; ++n, ++t) {\n        d = ngx_rtmp_mp4_to_rtmp_timestamp(t, t->duration) / 1000.;\n\n        if (v.duration < d) {\n            v.duration = d;\n        }\n\n        switch (t->type) {\n            case NGX_RTMP_MSG_AUDIO:\n                v.audio_codec_id = t->codec;\n                break;\n            case NGX_RTMP_MSG_VIDEO:\n                v.video_codec_id = t->codec;\n                break;\n        }\n    }\n\n    out = NULL;\n    rc = ngx_rtmp_append_amf(s, &out, NULL, out_elts,\n                             sizeof(out_elts) / sizeof(out_elts[0]));\n    if (rc != NGX_OK || out == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(&h, sizeof(h));\n\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n    h.type = NGX_RTMP_MSG_AMF_META;\n\n    ngx_rtmp_prepare_message(s, &h, NULL, out);\n    rc = ngx_rtmp_send_message(s, out, 0);\n    ngx_rtmp_free_shared_chain(cscf, out);\n\n    return rc;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek_track(ngx_rtmp_session_t *s, ngx_rtmp_mp4_track_t *t,\n                        ngx_int_t timestamp)\n{\n    ngx_rtmp_mp4_cursor_t          *cr;\n\n    cr = &t->cursor;\n    ngx_memzero(cr, sizeof(*cr));\n\n    if (ngx_rtmp_mp4_seek_time(s, t, ngx_rtmp_mp4_from_rtmp_timestamp(\n                          t, timestamp)) != NGX_OK ||\n        ngx_rtmp_mp4_seek_key(s, t)   != NGX_OK ||\n        ngx_rtmp_mp4_seek_chunk(s, t) != NGX_OK ||\n        ngx_rtmp_mp4_seek_size(s, t)  != NGX_OK ||\n        ngx_rtmp_mp4_seek_delay(s, t) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    cr->valid = 1;\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_send(ngx_rtmp_session_t *s, ngx_file_t *f, ngx_uint_t *ts)\n{\n    ngx_rtmp_mp4_ctx_t             *ctx;\n    ngx_buf_t                       in_buf;\n    ngx_rtmp_header_t               h, lh;\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_chain_t                    *out, in;\n    ngx_rtmp_mp4_track_t           *t, *cur_t;\n    ngx_rtmp_mp4_cursor_t          *cr, *cur_cr;\n    uint32_t                        buflen, end_timestamp,\n                                    timestamp, last_timestamp, rdelay,\n                                    cur_timestamp;\n    ssize_t                         ret;\n    u_char                          fhdr[5];\n    size_t                          fhdr_size;\n    ngx_int_t                       rc;\n    ngx_uint_t                      n, counter;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    ctx  = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (!ctx->meta_sent) {\n        rc = ngx_rtmp_mp4_send_meta(s);\n\n        if (rc == NGX_OK) {\n            ctx->meta_sent = 1;\n        }\n\n        return rc;\n    }\n\n    buflen = s->buflen + NGX_RTMP_MP4_BUFLEN_ADDON;\n\n    counter = 0;\n    last_timestamp = 0;\n    end_timestamp = ctx->start_timestamp +\n                    (ngx_current_msec - ctx->epoch) + buflen;\n\n    for ( ;; ) {\n        counter++;\n        if (counter > NGX_RTMP_MP4_MAX_FRAMES) {\n            return NGX_OK;\n        }\n\n        timestamp = 0;\n        t = NULL;\n\n        for (n = 0; n < ctx->ntracks; n++) {\n            cur_t = &ctx->tracks[n];\n            cur_cr = &cur_t->cursor;\n\n            if (!cur_cr->valid) {\n                continue;\n            }\n\n            cur_timestamp = ngx_rtmp_mp4_to_rtmp_timestamp(cur_t,\n                                                           cur_cr->timestamp);\n\n            if (t == NULL || cur_timestamp < timestamp) {\n                timestamp = cur_timestamp;\n                t = cur_t;\n            }\n        }\n\n        if (t == NULL) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                    \"mp4: no track\");\n            return NGX_DONE;\n        }\n\n        if (timestamp > end_timestamp) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                    \"mp4: track#%ui ahead %uD > %uD\",\n                    t->id, timestamp, end_timestamp);\n\n            if (ts) {\n                *ts = last_timestamp;\n            }\n\n            return (uint32_t) (timestamp - end_timestamp);\n        }\n\n        cr = &t->cursor;\n\n        last_timestamp = ngx_rtmp_mp4_to_rtmp_timestamp(t, cr->last_timestamp);\n\n        ngx_memzero(&h, sizeof(h));\n\n        h.msid = NGX_RTMP_MSID;\n        h.type = (uint8_t) t->type;\n        h.csid = t->csid;\n\n        lh = h;\n\n        h.timestamp  = timestamp;\n        lh.timestamp = last_timestamp;\n\n        ngx_memzero(&in, sizeof(in));\n        ngx_memzero(&in_buf, sizeof(in_buf));\n\n        if (t->header && !t->header_sent) {\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: track#%ui sending header of size=%uz\",\n                           t->id, t->header_size);\n\n            fhdr[0] = t->fhdr;\n            fhdr[1] = 0;\n\n            if (t->type == NGX_RTMP_MSG_VIDEO) {\n                fhdr[0] |= 0x10;\n                fhdr[2] = fhdr[3] = fhdr[4] = 0;\n                fhdr_size = 5;\n            } else {\n                fhdr_size = 2;\n            }\n\n            in.buf = &in_buf;\n            in_buf.pos  = fhdr;\n            in_buf.last = fhdr + fhdr_size;\n\n            out = ngx_rtmp_append_shared_bufs(cscf, NULL, &in);\n\n            in.buf = &in_buf;\n            in_buf.pos  = t->header;\n            in_buf.last = t->header + t->header_size;\n\n            ngx_rtmp_append_shared_bufs(cscf, out, &in);\n\n            ngx_rtmp_prepare_message(s, &h, NULL, out);\n            rc = ngx_rtmp_send_message(s, out, 0);\n            ngx_rtmp_free_shared_chain(cscf, out);\n\n            if (rc == NGX_AGAIN) {\n                return NGX_AGAIN;\n            }\n\n            t->header_sent = 1;\n        }\n\n        ngx_log_debug5(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui read frame offset=%O, size=%uz, \"\n                       \"timestamp=%uD, last_timestamp=%uD\",\n                       t->id, cr->offset, cr->size, timestamp,\n                       last_timestamp);\n\n        ngx_rtmp_mp4_buffer[0] = t->fhdr;\n        fhdr_size = 1;\n\n        if (t->type == NGX_RTMP_MSG_VIDEO) {\n            if (cr->key) {\n                ngx_rtmp_mp4_buffer[0] |= 0x10;\n            } else if (cr->delay) {\n                ngx_rtmp_mp4_buffer[0] |= 0x20;\n            } else {\n                ngx_rtmp_mp4_buffer[0] |= 0x30;\n            }\n\n            if (t->header) {\n                fhdr_size = 5;\n\n                rdelay = ngx_rtmp_mp4_to_rtmp_timestamp(t, cr->delay);\n\n                ngx_rtmp_mp4_buffer[1] = 1;\n                ngx_rtmp_mp4_buffer[2] = (rdelay >> 16) & 0xff;\n                ngx_rtmp_mp4_buffer[3] = (rdelay >> 8)  & 0xff;\n                ngx_rtmp_mp4_buffer[4] = rdelay & 0xff;\n            }\n\n        } else { /* NGX_RTMP_MSG_AUDIO */\n            if (t->header) {\n                fhdr_size = 2;\n                ngx_rtmp_mp4_buffer[1] = 1;\n            }\n        }\n\n        if (cr->size + fhdr_size > sizeof(ngx_rtmp_mp4_buffer)) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"mp4: track#%ui too big frame: %D>%uz\",\n                          t->id, cr->size, sizeof(ngx_rtmp_mp4_buffer));\n            goto next;\n        }\n\n        ret = ngx_read_file(f, ngx_rtmp_mp4_buffer + fhdr_size,\n                            cr->size, cr->offset);\n\n        if (ret != (ssize_t) cr->size) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"mp4: track#%ui could not read frame\", t->id);\n            goto next;\n        }\n\n        in.buf = &in_buf;\n        in_buf.pos  = ngx_rtmp_mp4_buffer;\n        in_buf.last = ngx_rtmp_mp4_buffer + cr->size + fhdr_size;\n\n        out = ngx_rtmp_append_shared_bufs(cscf, NULL, &in);\n\n        ngx_rtmp_prepare_message(s, &h, cr->not_first ? &lh : NULL, out);\n        rc = ngx_rtmp_send_message(s, out, 0);\n        ngx_rtmp_free_shared_chain(cscf, out);\n\n        if (rc == NGX_AGAIN) {\n            return NGX_AGAIN;\n        }\n\n        s->current_time = timestamp;\n\nnext:\n        if (ngx_rtmp_mp4_next(s, t) != NGX_OK) {\n            return NGX_DONE;\n        }\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_init(ngx_rtmp_session_t *s, ngx_file_t *f, ngx_int_t aindex,\n                  ngx_int_t vindex)\n{\n    ngx_rtmp_mp4_ctx_t         *ctx;\n    uint32_t                    hdr[2];\n    ssize_t                     n;\n    size_t                      offset, page_offset, size, shift;\n    uint64_t                    extended_size;\n    ngx_file_info_t             fi;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL) {\n        ctx = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_mp4_ctx_t));\n\n        if (ctx == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_mp4_module);\n    }\n\n    ngx_memzero(ctx, sizeof(*ctx));\n\n    ctx->aindex = aindex;\n    ctx->vindex = vindex;\n\n    offset = 0;\n    size   = 0;\n\n    for ( ;; ) {\n        n = ngx_read_file(f, (u_char *) &hdr, sizeof(hdr), offset);\n\n        if (n != sizeof(hdr)) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                          \"mp4: error reading file at offset=%uz \"\n                          \"while searching for moov box\", offset);\n            return NGX_ERROR;\n        }\n\n        size = (size_t) ngx_rtmp_r32(hdr[0]);\n        shift = sizeof(hdr);\n\n        if (size == 1) {\n            n = ngx_read_file(f, (u_char *) &extended_size,\n                              sizeof(extended_size), offset + sizeof(hdr));\n\n            if (n != sizeof(extended_size)) {\n                ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                              \"mp4: error reading file at offset=%uz \"\n                              \"while searching for moov box\", offset + 8);\n                return NGX_ERROR;\n            }\n\n            size = (size_t) ngx_rtmp_r64(extended_size);\n            shift += sizeof(extended_size);\n\n        } else if (size == 0) {\n            if (ngx_fd_info(f->fd, &fi) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                              \"mp4: \" ngx_fd_info_n \" failed\");\n                return NGX_ERROR;\n            }\n            size = ngx_file_size(&fi) - offset;\n        }\n\n        if (hdr[1] == ngx_rtmp_mp4_make_tag('m','o','o','v')) {\n            ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"mp4: found moov box\");\n            break;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: skipping box '%*s'\", 4, hdr + 1);\n\n        offset += size;\n    }\n\n    if (size < shift) {\n        return NGX_ERROR;\n    }\n\n    size   -= shift;\n    offset += shift;\n\n    page_offset = offset & (ngx_pagesize - 1);\n    ctx->mmaped_size = page_offset + size;\n\n    ctx->mmaped = ngx_rtmp_mp4_mmap(f->fd, ctx->mmaped_size,\n                                    offset - page_offset, &ctx->extra);\n    if (ctx->mmaped == NULL) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                      \"mp4: mmap failed at offset=%ui, size=%uz\",\n                      offset, size);\n        return NGX_ERROR;\n    }\n\n    return ngx_rtmp_mp4_parse(s, (u_char *) ctx->mmaped + page_offset,\n                                 (u_char *) ctx->mmaped + page_offset + size);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_done(ngx_rtmp_session_t *s, ngx_file_t *f)\n{\n    ngx_rtmp_mp4_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL || ctx->mmaped == NULL) {\n        return NGX_OK;\n    }\n\n    if (ngx_rtmp_mp4_munmap(ctx->mmaped, ctx->mmaped_size, &ctx->extra)\n        != NGX_OK)\n    {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                      \"mp4: munmap failed\");\n        return NGX_ERROR;\n    }\n\n    ctx->mmaped = NULL;\n    ctx->mmaped_size = 0;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_seek(ngx_rtmp_session_t *s, ngx_file_t *f, ngx_uint_t timestamp)\n{\n    ngx_rtmp_mp4_ctx_t     *ctx;\n    ngx_rtmp_mp4_track_t   *t;\n    ngx_uint_t              n;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: seek timestamp=%ui\", timestamp);\n\n    for (n = 0; n < ctx->ntracks; ++n) {\n        t = &ctx->tracks[n];\n\n        if (t->type != NGX_RTMP_MSG_VIDEO) {\n            continue;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui seek video\", n);\n\n        ngx_rtmp_mp4_seek_track(s, t, timestamp);\n\n        timestamp = ngx_rtmp_mp4_to_rtmp_timestamp(t, t->cursor.timestamp);\n\n        break;\n    }\n\n    for (n = 0; n < ctx->ntracks; ++n) {\n        t = &ctx->tracks[n];\n\n        if (t->type == NGX_RTMP_MSG_VIDEO) {\n            continue;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"mp4: track#%ui seek\", n);\n\n        ngx_rtmp_mp4_seek_track(s, &ctx->tracks[n], timestamp);\n    }\n\n    ctx->start_timestamp = timestamp;\n    ctx->epoch = ngx_current_msec;\n\n    return ngx_rtmp_mp4_reset(s);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_start(ngx_rtmp_session_t *s, ngx_file_t *f)\n{\n    ngx_rtmp_mp4_ctx_t     *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: start timestamp=%uD\", ctx->start_timestamp);\n\n    ctx->epoch = ngx_current_msec;\n\n    return NGX_OK;/*ngx_rtmp_mp4_reset(s);*/\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_reset(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_mp4_ctx_t     *ctx;\n    ngx_rtmp_mp4_cursor_t  *cr;\n    ngx_rtmp_mp4_track_t   *t;\n    ngx_uint_t              n;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    t = &ctx->tracks[0];\n    for (n = 0; n < ctx->ntracks; ++n, ++t) {\n        cr = &t->cursor;\n        cr->not_first = 0;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_stop(ngx_rtmp_session_t *s, ngx_file_t *f)\n{\n    ngx_rtmp_mp4_ctx_t     *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_mp4_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    ctx->start_timestamp += (ngx_current_msec - ctx->epoch);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"mp4: stop timestamp=%uD\", ctx->start_timestamp);\n\n    return NGX_OK;/*ngx_rtmp_mp4_reset(s);*/\n}\n\n\nstatic ngx_int_t\nngx_rtmp_mp4_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_play_main_conf_t      *pmcf;\n    ngx_rtmp_play_fmt_t           **pfmt, *fmt;\n\n    pmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_play_module);\n\n    pfmt = ngx_array_push(&pmcf->fmts);\n\n    if (pfmt == NULL) {\n        return NGX_ERROR;\n    }\n\n    fmt = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_play_fmt_t));\n\n    if (fmt == NULL) {\n        return NGX_ERROR;\n    }\n\n    *pfmt = fmt;\n\n    ngx_str_set(&fmt->name, \"mp4-format\");\n\n    ngx_str_set(&fmt->pfx, \"mp4:\");\n    ngx_str_set(&fmt->sfx, \".mp4\");\n\n    fmt->init  = ngx_rtmp_mp4_init;\n    fmt->done  = ngx_rtmp_mp4_done;\n    fmt->seek  = ngx_rtmp_mp4_seek;\n    fmt->start = ngx_rtmp_mp4_start;\n    fmt->stop  = ngx_rtmp_mp4_stop;\n    fmt->send  = ngx_rtmp_mp4_send;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_netcall_module.c",
          "type": "blob",
          "size": 19.0087890625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_netcall_module.h\"\n\n\nstatic ngx_int_t ngx_rtmp_netcall_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_netcall_create_srv_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_netcall_merge_srv_conf(ngx_conf_t *cf,\n       void *parent, void *child);\n\nstatic void ngx_rtmp_netcall_close(ngx_connection_t *cc);\nstatic void ngx_rtmp_netcall_detach(ngx_connection_t *cc);\n\nstatic void ngx_rtmp_netcall_recv(ngx_event_t *rev);\nstatic void ngx_rtmp_netcall_send(ngx_event_t *wev);\n\n\ntypedef struct {\n    ngx_msec_t                                  timeout;\n    size_t                                      bufsize;\n    ngx_log_t                                  *log;\n} ngx_rtmp_netcall_srv_conf_t;\n\n\ntypedef struct ngx_rtmp_netcall_session_s {\n    ngx_rtmp_session_t                         *session;\n    ngx_peer_connection_t                      *pc;\n    ngx_url_t                                  *url;\n    struct ngx_rtmp_netcall_session_s          *next;\n    void                                       *arg;\n    ngx_rtmp_netcall_handle_pt                  handle;\n    ngx_rtmp_netcall_filter_pt                  filter;\n    ngx_rtmp_netcall_sink_pt                    sink;\n    ngx_chain_t                                *in;\n    ngx_chain_t                                *inlast;\n    ngx_chain_t                                *out;\n    ngx_msec_t                                  timeout;\n    unsigned                                    detached:1;\n    size_t                                      bufsize;\n} ngx_rtmp_netcall_session_t;\n\n\ntypedef struct {\n    ngx_uint_t                                  nb_cs;\n    ngx_rtmp_netcall_session_t                 *cs;\n} ngx_rtmp_netcall_ctx_t;\n\n\nstatic ngx_command_t  ngx_rtmp_netcall_commands[] = {\n\n    { ngx_string(\"netcall_timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_netcall_srv_conf_t, timeout),\n      NULL },\n\n    { ngx_string(\"netcall_buffer\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      offsetof(ngx_rtmp_netcall_srv_conf_t, bufsize),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_netcall_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_netcall_postconfiguration,     /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    ngx_rtmp_netcall_create_srv_conf,       /* create server configuration */\n    ngx_rtmp_netcall_merge_srv_conf,        /* merge server configuration */\n    NULL,                                   /* create app configuration */\n    NULL                                    /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_netcall_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_netcall_module_ctx,           /* module context */\n    ngx_rtmp_netcall_commands,              /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void *\nngx_rtmp_netcall_create_srv_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_netcall_srv_conf_t     *nscf;\n\n    nscf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_netcall_srv_conf_t));\n    if (nscf == NULL) {\n        return NULL;\n    }\n\n    nscf->timeout = NGX_CONF_UNSET_MSEC;\n    nscf->bufsize = NGX_CONF_UNSET_SIZE;\n\n    nscf->log = &cf->cycle->new_log;\n\n    return nscf;\n}\n\n\nstatic char *\nngx_rtmp_netcall_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_netcall_srv_conf_t *prev = parent;\n    ngx_rtmp_netcall_srv_conf_t *conf = child;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 10000);\n    ngx_conf_merge_size_value(conf->bufsize, prev->bufsize, 1024);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_netcall_disconnect(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_netcall_ctx_t         *ctx;\n    ngx_rtmp_netcall_session_t     *cs;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_netcall_module);\n\n    if (ctx) {\n        for (cs = ctx->cs; cs; cs = cs->next) {\n            ngx_rtmp_netcall_detach(cs->pc->connection);\n        }\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_netcall_get_peer(ngx_peer_connection_t *pc, void *data)\n{\n    ngx_rtmp_netcall_session_t   *cs = data;\n\n    pc->sockaddr =(struct sockaddr *)&cs->url->sockaddr;\n    pc->socklen = cs->url->socklen;\n    pc->name = &cs->url->host;\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_netcall_free_peer(ngx_peer_connection_t *pc, void *data,\n            ngx_uint_t state)\n{\n}\n\n\nngx_int_t\nngx_rtmp_netcall_create(ngx_rtmp_session_t *s, ngx_rtmp_netcall_init_t *ci)\n{\n    ngx_rtmp_netcall_ctx_t         *ctx;\n    ngx_peer_connection_t          *pc;\n    ngx_rtmp_netcall_session_t     *cs;\n    ngx_rtmp_netcall_srv_conf_t    *nscf;\n    ngx_connection_t               *c, *cc;\n    ngx_pool_t                     *pool;\n    ngx_int_t                       rc;\n\n    pool = NULL;\n    c = s->connection;\n\n    nscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_netcall_module);\n    if (nscf == NULL) {\n        goto error;\n    }\n\n    /* get module context */\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_netcall_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(c->pool,\n                sizeof(ngx_rtmp_netcall_ctx_t));\n        if (ctx == NULL) {\n            return NGX_ERROR;\n        }\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_netcall_module);\n    } else {\n        /* I don't know why? But it works! */\n        if (ctx->nb_cs == 0) {\n            ctx->cs = NULL;\n        }\n    }\n\n    /* Create netcall pool, connection, session.\n     * Note we use shared (app-wide) log because\n     * s->connection->log might be unavailable\n     * in detached netcall when it's being closed */\n    pool = ngx_create_pool(4096, nscf->log);\n    if (pool == NULL) {\n        goto error;\n    }\n\n    pc = ngx_pcalloc(pool, sizeof(ngx_peer_connection_t));\n    if (pc == NULL) {\n        goto error;\n    }\n\n    cs = ngx_pcalloc(pool, sizeof(ngx_rtmp_netcall_session_t));\n    if (cs == NULL) {\n        goto error;\n    }\n\n    /* copy arg to connection pool */\n    if (ci->argsize) {\n        cs->arg = ngx_pcalloc(pool, ci->argsize);\n        if (cs->arg == NULL) {\n            goto error;\n        }\n        ngx_memcpy(cs->arg, ci->arg, ci->argsize);\n    }\n\n    cs->timeout = nscf->timeout;\n    cs->bufsize = nscf->bufsize;\n    cs->url = ci->url;\n    cs->session = s;\n    cs->filter = ci->filter;\n    cs->sink = ci->sink;\n    cs->handle = ci->handle;\n    if (cs->handle == NULL) {\n        cs->detached = 1;\n    }\n\n    pc->log = nscf->log;\n    pc->get = ngx_rtmp_netcall_get_peer;\n    pc->free = ngx_rtmp_netcall_free_peer;\n    pc->data = cs;\n\n    /* connect */\n    rc = ngx_event_connect_peer(pc);\n    if (rc != NGX_OK && rc != NGX_AGAIN ) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"netcall: connection failed\");\n        goto error;\n    }\n\n    cc = pc->connection;\n    cc->data = cs;\n    cc->pool = pool;\n    cs->pc = pc;\n\n    cs->out = ci->create(s, ci->arg, pool);\n    if (cs->out == NULL) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"netcall: creation failed\");\n        ngx_close_connection(pc->connection);\n        goto error;\n    }\n\n    cc->write->handler = ngx_rtmp_netcall_send;\n    cc->read->handler = ngx_rtmp_netcall_recv;\n\n    if (!cs->detached) {\n        cs->next = ctx->cs;\n        ctx->cs = cs;\n        ctx->nb_cs++;\n    }\n\n    ngx_rtmp_netcall_send(cc->write);\n\n    return c->destroyed ? NGX_ERROR : NGX_OK;\n\nerror:\n    if (pool) {\n        ngx_destroy_pool(pool);\n    }\n\n    return NGX_ERROR;\n}\n\n\nstatic void\nngx_rtmp_netcall_close(ngx_connection_t *cc)\n{\n    ngx_rtmp_netcall_session_t         *cs, **css;\n    ngx_pool_t                         *pool;\n    ngx_rtmp_session_t                 *s;\n    ngx_rtmp_netcall_ctx_t             *ctx;\n    ngx_buf_t                          *b;\n\n    cs = cc->data;\n\n    if (cc->destroyed) {\n        return;\n    }\n\n    cc->destroyed = 1;\n\n    if (!cs->detached) {\n        s = cs->session;\n        ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_netcall_module);\n\n        if (cs->in && cs->sink) {\n            cs->sink(cs->session, cs->in);\n\n            b = cs->in->buf;\n            b->pos = b->last = b->start;\n\n        }\n\n        for(css = &ctx->cs; *css; css = &((*css)->next)) {\n            if (*css == cs) {\n                *css = cs->next;\n                ctx->nb_cs--;\n                break;\n            }\n        }\n\n        if (cs->handle && cs->handle(s, cs->arg, cs->in) != NGX_OK) {\n            ngx_rtmp_finalize_session(s);\n        }\n    }\n\n    pool = cc->pool;\n    ngx_close_connection(cc);\n    ngx_destroy_pool(pool);\n}\n\n\nstatic void\nngx_rtmp_netcall_detach(ngx_connection_t *cc)\n{\n    ngx_rtmp_netcall_session_t         *cs;\n\n    cs = cc->data;\n    cs->detached = 1;\n}\n\n\nstatic void\nngx_rtmp_netcall_recv(ngx_event_t *rev)\n{\n    ngx_rtmp_netcall_session_t         *cs;\n    ngx_connection_t                   *cc;\n    ngx_chain_t                        *cl;\n    ngx_int_t                           n;\n    ngx_buf_t                          *b;\n\n    cc = rev->data;\n    cs = cc->data;\n\n    if (cc->destroyed) {\n        return;\n    }\n\n    if (rev->timedout) {\n        cc->timedout = 1;\n        ngx_rtmp_netcall_close(cc);\n        return;\n    }\n\n    if (rev->timer_set) {\n        ngx_del_timer(rev);\n    }\n\n    for ( ;; ) {\n\n        if (cs->inlast == NULL ||\n            cs->inlast->buf->last == cs->inlast->buf->end)\n        {\n            if (cs->in && cs->sink) {\n                if (!cs->detached) {\n                    if (cs->sink(cs->session, cs->in) != NGX_OK) {\n                        ngx_rtmp_netcall_close(cc);\n                        return;\n                    }\n                }\n\n                b = cs->in->buf;\n                b->pos = b->last = b->start;\n\n            } else {\n                cl = ngx_alloc_chain_link(cc->pool);\n                if (cl == NULL) {\n                    ngx_rtmp_netcall_close(cc);\n                    return;\n                }\n\n                cl->next = NULL;\n\n                cl->buf = ngx_create_temp_buf(cc->pool, cs->bufsize);\n                if (cl->buf == NULL) {\n                    ngx_rtmp_netcall_close(cc);\n                    return;\n                }\n\n                if (cs->in == NULL) {\n                    cs->in = cl;\n                } else {\n                    cs->inlast->next = cl;\n                }\n\n                cs->inlast = cl;\n            }\n        }\n\n        b = cs->inlast->buf;\n\n        n = cc->recv(cc, b->last, b->end - b->last);\n\n        if (n == NGX_ERROR || n == 0) {\n            ngx_rtmp_netcall_close(cc);\n            return;\n        }\n\n        if (n == NGX_AGAIN) {\n            if (cs->filter && cs->in\n                && cs->filter(cs->in) != NGX_AGAIN)\n            {\n                ngx_rtmp_netcall_close(cc);\n                return;\n            }\n\n            ngx_add_timer(rev, cs->timeout);\n            if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n                ngx_rtmp_netcall_close(cc);\n            }\n            return;\n        }\n\n        b->last += n;\n    }\n}\n\n\nstatic void\nngx_rtmp_netcall_send(ngx_event_t *wev)\n{\n    ngx_rtmp_netcall_session_t         *cs;\n    ngx_connection_t                   *cc;\n    ngx_chain_t                        *cl;\n\n    cc = wev->data;\n    cs = cc->data;\n\n    if (cc->destroyed) {\n        return;\n    }\n\n    if (wev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, cc->log, NGX_ETIMEDOUT,\n                \"netcall: client send timed out\");\n        cc->timedout = 1;\n        ngx_rtmp_netcall_close(cc);\n        return;\n    }\n\n    if (wev->timer_set) {\n        ngx_del_timer(wev);\n    }\n\n    cl = cc->send_chain(cc, cs->out, 0);\n\n    if (cl == NGX_CHAIN_ERROR) {\n        ngx_rtmp_netcall_close(cc);\n        return;\n    }\n\n    cs->out = cl;\n\n    /* more data to send? */\n    if (cl) {\n        ngx_add_timer(wev, cs->timeout);\n        if (ngx_handle_write_event(wev, 0) != NGX_OK) {\n            ngx_rtmp_netcall_close(cc);\n        }\n        return;\n    }\n\n    /* we've sent everything we had.\n     * now receive reply */\n    ngx_del_event(wev, NGX_WRITE_EVENT, 0);\n\n    ngx_rtmp_netcall_recv(cc->read);\n}\n\n\nngx_chain_t *\nngx_rtmp_netcall_http_format_request(ngx_int_t method, ngx_str_t *host,\n                                     ngx_str_t *uri, ngx_chain_t *args,\n                                     ngx_chain_t *body, ngx_pool_t *pool,\n                                     ngx_str_t *content_type)\n{\n    ngx_chain_t                    *al, *bl, *ret;\n    ngx_buf_t                      *b;\n    size_t                          content_length;\n    static const char              *methods[2] = { \"GET\", \"POST\" };\n    static const char               rq_tmpl[] = \" HTTP/1.0\\r\\n\"\n                                                \"Host: %V\\r\\n\"\n                                                \"Content-Type: %V\\r\\n\"\n                                                \"Connection: Close\\r\\n\"\n                                                \"Content-Length: %uz\\r\\n\"\n                                                \"\\r\\n\";\n\n    content_length = 0;\n    for (al = body; al; al = al->next) {\n        b = al->buf;\n        content_length += (b->last - b->pos);\n    }\n\n    /* create first buffer */\n\n    al = ngx_alloc_chain_link(pool);\n    if (al == NULL) {\n        return NULL;\n    }\n\n    b = ngx_create_temp_buf(pool, sizeof(\"POST\") + /* longest method + 1 */\n                                  uri->len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    b->last = ngx_snprintf(b->last, b->end - b->last, \"%s %V\",\n                           methods[method], uri);\n\n    al->buf = b;\n\n    ret = al;\n\n    if (args) {\n        *b->last++ = '?';\n        al->next = args;\n        for (al = args; al->next; al = al->next);\n    }\n\n    /* create second buffer */\n\n    bl = ngx_alloc_chain_link(pool);\n    if (bl == NULL) {\n        return NULL;\n    }\n\n    b = ngx_create_temp_buf(pool, sizeof(rq_tmpl) + host->len +\n                            content_type->len + NGX_SIZE_T_LEN);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    bl->buf = b;\n\n    b->last = ngx_snprintf(b->last, b->end - b->last, rq_tmpl,\n                           host, content_type, content_length);\n\n    al->next = bl;\n    bl->next = body;\n\n    return ret;\n}\n\n\nngx_chain_t *\nngx_rtmp_netcall_http_format_session(ngx_rtmp_session_t *s, ngx_pool_t *pool)\n{\n    ngx_chain_t                    *cl;\n    ngx_buf_t                      *b;\n    ngx_str_t                      *addr_text;\n\n    addr_text = &s->connection->addr_text;\n\n    cl = ngx_alloc_chain_link(pool);\n    if (cl == NULL) {\n        return NULL;\n    }\n\n    b = ngx_create_temp_buf(pool,\n            sizeof(\"app=\") - 1 + s->app.len * 3 +\n            sizeof(\"&flashver=\") - 1 + s->flashver.len * 3 +\n            sizeof(\"&swfurl=\") - 1 + s->swf_url.len * 3 +\n            sizeof(\"&tcurl=\") - 1 + s->tc_url.len * 3 +\n            sizeof(\"&pageurl=\") - 1 + s->page_url.len * 3 +\n            sizeof(\"&addr=\") - 1 + addr_text->len * 3 +\n            sizeof(\"&clientid=\") - 1 + NGX_INT_T_LEN\n        );\n\n    if (b == NULL) {\n        return NULL;\n    }\n\n    cl->buf = b;\n    cl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"app=\", sizeof(\"app=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, s->app.data, s->app.len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&flashver=\",\n                         sizeof(\"&flashver=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, s->flashver.data,\n                                       s->flashver.len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&swfurl=\",\n                         sizeof(\"&swfurl=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, s->swf_url.data,\n                                       s->swf_url.len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&tcurl=\",\n                         sizeof(\"&tcurl=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, s->tc_url.data,\n                                       s->tc_url.len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&pageurl=\",\n                         sizeof(\"&pageurl=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, s->page_url.data,\n                                       s->page_url.len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&addr=\", sizeof(\"&addr=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, addr_text->data,\n                                       addr_text->len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&clientid=\",\n                         sizeof(\"&clientid=\") - 1);\n    b->last = ngx_sprintf(b->last, \"%ui\", (ngx_uint_t) s->connection->number);\n\n    return cl;\n}\n\n\nngx_chain_t *\nngx_rtmp_netcall_http_skip_header(ngx_chain_t *in)\n{\n    ngx_buf_t       *b;\n\n    /* find \\n[\\r]\\n */\n    enum {\n        normal,\n        lf,\n        lfcr\n    } state = normal;\n\n    if (in == NULL) {\n        return NULL;\n    }\n\n    b = in->buf;\n\n    for ( ;; ) {\n\n        while (b->pos == b->last) {\n            in = in->next;\n            if (in == NULL) {\n                return NULL;\n            }\n            b = in->buf;\n        }\n\n        switch (*b->pos++) {\n            case '\\r':\n                state = (state == lf) ? lfcr : normal;\n                break;\n\n            case '\\n':\n                if (state != normal) {\n                    return in;\n                }\n                state = lf;\n                break;\n\n           default:\n                state = normal;\n        }\n    }\n}\n\n\nngx_chain_t *\nngx_rtmp_netcall_memcache_set(ngx_rtmp_session_t *s, ngx_pool_t *pool,\n        ngx_str_t *key, ngx_str_t *value, ngx_uint_t flags, ngx_uint_t sec)\n{\n    ngx_chain_t                    *cl;\n    ngx_buf_t                      *b;\n\n    cl = ngx_alloc_chain_link(pool);\n    if (cl == NULL) {\n        return NULL;\n    }\n\n    b = ngx_create_temp_buf(pool, sizeof(\"set \") - 1 + key->len +\n                            (1 + NGX_INT_T_LEN) * 3 +\n                            (sizeof(\"\\r\\n\") - 1) * 2 + value->len);\n\n    if (b == NULL) {\n        return NULL;\n    }\n\n    cl->next = NULL;\n    cl->buf = b;\n\n    b->last = ngx_sprintf(b->pos, \"set %V %ui %ui %ui\\r\\n%V\\r\\n\",\n                          key, flags, sec, (ngx_uint_t) value->len, value);\n\n    return cl;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_netcall_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_DISCONNECT]);\n    *h = ngx_rtmp_netcall_disconnect;\n\n    return NGX_OK;\n}\n\n"
        },
        {
          "name": "ngx_rtmp_netcall_module.h",
          "type": "blob",
          "size": 2.087890625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_NETCALL_H_INCLUDED_\n#define _NGX_RTMP_NETCALL_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\ntypedef ngx_chain_t * (*ngx_rtmp_netcall_create_pt)(ngx_rtmp_session_t *s,\n        void *arg, ngx_pool_t *pool);\ntypedef ngx_int_t (*ngx_rtmp_netcall_filter_pt)(ngx_chain_t *in);\ntypedef ngx_int_t (*ngx_rtmp_netcall_sink_pt)(ngx_rtmp_session_t *s,\n        ngx_chain_t *in);\ntypedef ngx_int_t (*ngx_rtmp_netcall_handle_pt)(ngx_rtmp_session_t *s,\n        void *arg, ngx_chain_t *in);\n\n#define NGX_RTMP_NETCALL_HTTP_GET   0\n#define NGX_RTMP_NETCALL_HTTP_POST  1\n\n\n/* If handle is NULL then netcall is created detached\n * which means it's completely independent of RTMP\n * session and its result is never visible to anyone.\n *\n * WARNING: It's not recommended to create non-detached\n * netcalls from disconect handlers. Netcall disconnect\n * handler which detaches active netcalls is executed\n * BEFORE your handler. It leads to a crash\n * after netcall connection is closed */\ntypedef struct {\n    ngx_url_t                      *url;\n    ngx_rtmp_netcall_create_pt      create;\n    ngx_rtmp_netcall_filter_pt      filter;\n    ngx_rtmp_netcall_sink_pt        sink;\n    ngx_rtmp_netcall_handle_pt      handle;\n    void                           *arg;\n    size_t                          argsize;\n} ngx_rtmp_netcall_init_t;\n\n\nngx_int_t ngx_rtmp_netcall_create(ngx_rtmp_session_t *s,\n        ngx_rtmp_netcall_init_t *ci);\n\n\n/* HTTP handling */\nngx_chain_t * ngx_rtmp_netcall_http_format_session(ngx_rtmp_session_t *s,\n        ngx_pool_t *pool);\nngx_chain_t * ngx_rtmp_netcall_http_format_request(ngx_int_t method,\n        ngx_str_t *host, ngx_str_t *uri, ngx_chain_t *args, ngx_chain_t *body,\n        ngx_pool_t *pool, ngx_str_t *content_type);\nngx_chain_t * ngx_rtmp_netcall_http_skip_header(ngx_chain_t *in);\n\n\n/* Memcache handling */\nngx_chain_t * ngx_rtmp_netcall_memcache_set(ngx_rtmp_session_t *s,\n        ngx_pool_t *pool, ngx_str_t *key, ngx_str_t *value,\n        ngx_uint_t flags, ngx_uint_t sec);\n\n\n#endif /* _NGX_RTMP_NETCALL_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_notify_module.c",
          "type": "blob",
          "size": 47.9189453125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_md5.h>\n#include <ngx_http.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_netcall_module.h\"\n#include \"ngx_rtmp_record_module.h\"\n#include \"ngx_rtmp_relay_module.h\"\n\n\nstatic ngx_rtmp_connect_pt                      next_connect;\nstatic ngx_rtmp_disconnect_pt                   next_disconnect;\nstatic ngx_rtmp_publish_pt                      next_publish;\nstatic ngx_rtmp_play_pt                         next_play;\nstatic ngx_rtmp_close_stream_pt                 next_close_stream;\nstatic ngx_rtmp_record_done_pt                  next_record_done;\n\n\nstatic char *ngx_rtmp_notify_on_srv_event(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic char *ngx_rtmp_notify_on_app_event(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic char *ngx_rtmp_notify_method(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic ngx_int_t ngx_rtmp_notify_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_notify_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_notify_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\nstatic void *ngx_rtmp_notify_create_srv_conf(ngx_conf_t *cf);\nstatic char *ngx_rtmp_notify_merge_srv_conf(ngx_conf_t *cf, void *parent,\n       void *child);\nstatic ngx_int_t ngx_rtmp_notify_done(ngx_rtmp_session_t *s, char *cbname,\n       ngx_uint_t url_idx);\n\n\nngx_str_t   ngx_rtmp_notify_urlencoded =\n            ngx_string(\"application/x-www-form-urlencoded\");\n\n\n#define NGX_RTMP_NOTIFY_PUBLISHING              0x01\n#define NGX_RTMP_NOTIFY_PLAYING                 0x02\n\n\nenum {\n    NGX_RTMP_NOTIFY_CONNECT,\n    NGX_RTMP_NOTIFY_DISCONNECT,\n    NGX_RTMP_NOTIFY_SRV_MAX\n};\n\n\nenum {\n    NGX_RTMP_NOTIFY_PLAY,\n    NGX_RTMP_NOTIFY_PUBLISH,\n    NGX_RTMP_NOTIFY_PLAY_DONE,\n    NGX_RTMP_NOTIFY_PUBLISH_DONE,\n    NGX_RTMP_NOTIFY_DONE,\n    NGX_RTMP_NOTIFY_RECORD_DONE,\n    NGX_RTMP_NOTIFY_UPDATE,\n    NGX_RTMP_NOTIFY_APP_MAX\n};\n\n\ntypedef struct {\n    ngx_url_t                                  *url[NGX_RTMP_NOTIFY_APP_MAX];\n    ngx_flag_t                                  active;\n    ngx_uint_t                                  method;\n    ngx_msec_t                                  update_timeout;\n    ngx_flag_t                                  update_strict;\n    ngx_flag_t                                  relay_redirect;\n    ngx_flag_t                                  no_resolve;\n} ngx_rtmp_notify_app_conf_t;\n\n\ntypedef struct {\n    ngx_url_t                                  *url[NGX_RTMP_NOTIFY_SRV_MAX];\n    ngx_uint_t                                  method;\n} ngx_rtmp_notify_srv_conf_t;\n\n\ntypedef struct {\n    ngx_uint_t                                  flags;\n    u_char                                      name[NGX_RTMP_MAX_NAME];\n    u_char                                      args[NGX_RTMP_MAX_ARGS];\n    ngx_event_t                                 update_evt;\n    time_t                                      start;\n} ngx_rtmp_notify_ctx_t;\n\n\ntypedef struct {\n    u_char                                     *cbname;\n    ngx_uint_t                                  url_idx;\n} ngx_rtmp_notify_done_t;\n\n\nstatic ngx_command_t  ngx_rtmp_notify_commands[] = {\n\n    { ngx_string(\"on_connect\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_srv_event,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_disconnect\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_srv_event,\n      NGX_RTMP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_publish\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_play\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_publish_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_play_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_record_done\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_RTMP_REC_CONF|\n                         NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"on_update\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_on_app_event,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"notify_method\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_rtmp_notify_method,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"notify_update_timeout\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_notify_app_conf_t, update_timeout),\n      NULL },\n\n    { ngx_string(\"notify_update_strict\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_notify_app_conf_t, update_strict),\n      NULL },\n\n    { ngx_string(\"notify_relay_redirect\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_notify_app_conf_t, relay_redirect),\n      NULL },\n\n    { ngx_string(\"notify_no_resolve\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_notify_app_conf_t, no_resolve),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_notify_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_notify_postconfiguration,      /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    ngx_rtmp_notify_create_srv_conf,        /* create server configuration */\n    ngx_rtmp_notify_merge_srv_conf,         /* merge server configuration */\n    ngx_rtmp_notify_create_app_conf,        /* create app configuration */\n    ngx_rtmp_notify_merge_app_conf          /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_notify_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_notify_module_ctx,            /* module context */\n    ngx_rtmp_notify_commands,               /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void *\nngx_rtmp_notify_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_notify_app_conf_t     *nacf;\n    ngx_uint_t                      n;\n\n    nacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_notify_app_conf_t));\n    if (nacf == NULL) {\n        return NULL;\n    }\n\n    for (n = 0; n < NGX_RTMP_NOTIFY_APP_MAX; ++n) {\n        nacf->url[n] = NGX_CONF_UNSET_PTR;\n    }\n\n    nacf->method = NGX_CONF_UNSET_UINT;\n    nacf->update_timeout = NGX_CONF_UNSET_MSEC;\n    nacf->update_strict = NGX_CONF_UNSET;\n    nacf->relay_redirect = NGX_CONF_UNSET;\n    nacf->no_resolve = NGX_CONF_UNSET;\n\n    return nacf;\n}\n\n\nstatic char *\nngx_rtmp_notify_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_notify_app_conf_t *prev = parent;\n    ngx_rtmp_notify_app_conf_t *conf = child;\n    ngx_uint_t                  n;\n\n    for (n = 0; n < NGX_RTMP_NOTIFY_APP_MAX; ++n) {\n        ngx_conf_merge_ptr_value(conf->url[n], prev->url[n], NULL);\n        if (conf->url[n]) {\n            conf->active = 1;\n        }\n    }\n\n    if (conf->active) {\n        prev->active = 1;\n    }\n\n    ngx_conf_merge_uint_value(conf->method, prev->method,\n                              NGX_RTMP_NETCALL_HTTP_POST);\n    ngx_conf_merge_msec_value(conf->update_timeout, prev->update_timeout,\n                              30000);\n    ngx_conf_merge_value(conf->update_strict, prev->update_strict, 0);\n    ngx_conf_merge_value(conf->relay_redirect, prev->relay_redirect, 0);\n    ngx_conf_merge_value(conf->no_resolve, prev->no_resolve, 1);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic void *\nngx_rtmp_notify_create_srv_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_notify_srv_conf_t     *nscf;\n    ngx_uint_t                      n;\n\n    nscf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_notify_srv_conf_t));\n    if (nscf == NULL) {\n        return NULL;\n    }\n\n    for (n = 0; n < NGX_RTMP_NOTIFY_SRV_MAX; ++n) {\n        nscf->url[n] = NGX_CONF_UNSET_PTR;\n    }\n\n    nscf->method = NGX_CONF_UNSET_UINT;\n\n    return nscf;\n}\n\n\nstatic char *\nngx_rtmp_notify_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_notify_srv_conf_t *prev = parent;\n    ngx_rtmp_notify_srv_conf_t *conf = child;\n    ngx_uint_t                  n;\n\n    for (n = 0; n < NGX_RTMP_NOTIFY_SRV_MAX; ++n) {\n        ngx_conf_merge_ptr_value(conf->url[n], prev->url[n], NULL);\n    }\n\n    ngx_conf_merge_uint_value(conf->method, prev->method,\n                              NGX_RTMP_NETCALL_HTTP_POST);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_create_request(ngx_rtmp_session_t *s, ngx_pool_t *pool,\n                                   ngx_uint_t url_idx, ngx_chain_t *args)\n{\n    ngx_rtmp_notify_app_conf_t *nacf;\n    ngx_chain_t                *al, *bl, *cl;\n    ngx_url_t                  *url;\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n\n    url = nacf->url[url_idx];\n\n    al = ngx_rtmp_netcall_http_format_session(s, pool);\n    if (al == NULL) {\n        return NULL;\n    }\n\n    al->next = args;\n\n    bl = NULL;\n\n    if (nacf->method == NGX_RTMP_NETCALL_HTTP_POST) {\n        cl = al;\n        al = bl;\n        bl = cl;\n    }\n\n    return ngx_rtmp_netcall_http_format_request(nacf->method, &url->host,\n                                                &url->uri, al, bl, pool,\n                                                &ngx_rtmp_notify_urlencoded);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_connect_create(ngx_rtmp_session_t *s, void *arg,\n        ngx_pool_t *pool)\n{\n    ngx_rtmp_connect_t             *v = arg;\n\n    ngx_rtmp_notify_srv_conf_t     *nscf;\n    ngx_url_t                      *url;\n    ngx_chain_t                    *al, *bl;\n    ngx_buf_t                      *b;\n    ngx_str_t                      *addr_text;\n    size_t                          app_len, args_len, flashver_len,\n                                    swf_url_len, tc_url_len, page_url_len;\n\n    nscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_notify_module);\n\n    al = ngx_alloc_chain_link(pool);\n    if (al == NULL) {\n        return NULL;\n    }\n\n    /* these values are still missing in session\n     * so we have to construct the request from\n     * connection struct */\n\n    app_len = ngx_strlen(v->app);\n    args_len = ngx_strlen(v->args);\n    flashver_len = ngx_strlen(v->flashver);\n    swf_url_len = ngx_strlen(v->swf_url);\n    tc_url_len = ngx_strlen(v->tc_url);\n    page_url_len = ngx_strlen(v->page_url);\n\n    addr_text = &s->connection->addr_text;\n\n    b = ngx_create_temp_buf(pool,\n            sizeof(\"call=connect\") - 1 +\n            sizeof(\"&app=\") - 1 + app_len * 3 +\n            sizeof(\"&flashver=\") - 1 + flashver_len * 3 +\n            sizeof(\"&swfurl=\") - 1 + swf_url_len * 3 +\n            sizeof(\"&tcurl=\") - 1 + tc_url_len * 3 +\n            sizeof(\"&pageurl=\") - 1 + page_url_len * 3 +\n            sizeof(\"&addr=\") - 1 + addr_text->len * 3 +\n            sizeof(\"&epoch=\") - 1 + NGX_INT32_LEN +\n            1 + args_len\n        );\n\n    if (b == NULL) {\n        return NULL;\n    }\n\n    al->buf = b;\n    al->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"app=\", sizeof(\"app=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->app, app_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&flashver=\",\n                         sizeof(\"&flashver=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->flashver, flashver_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&swfurl=\",\n                         sizeof(\"&swfurl=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->swf_url, swf_url_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&tcurl=\",\n                         sizeof(\"&tcurl=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->tc_url, tc_url_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&pageurl=\",\n                         sizeof(\"&pageurl=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->page_url, page_url_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&addr=\", sizeof(\"&addr=\") -1);\n    b->last = (u_char*) ngx_escape_uri(b->last, addr_text->data,\n                                       addr_text->len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&epoch=\", sizeof(\"&epoch=\") -1);\n    b->last = ngx_sprintf(b->last, \"%uD\", (uint32_t) s->epoch);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=connect\",\n                         sizeof(\"&call=connect\") - 1);\n\n    if (args_len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, v->args, args_len);\n    }\n\n    url = nscf->url[NGX_RTMP_NOTIFY_CONNECT];\n\n    bl = NULL;\n\n    if (nscf->method == NGX_RTMP_NETCALL_HTTP_POST) {\n        bl = al;\n        al = NULL;\n    }\n\n    return ngx_rtmp_netcall_http_format_request(nscf->method, &url->host,\n                                                &url->uri, al, bl, pool,\n                                                &ngx_rtmp_notify_urlencoded);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_disconnect_create(ngx_rtmp_session_t *s, void *arg,\n        ngx_pool_t *pool)\n{\n    ngx_rtmp_notify_srv_conf_t     *nscf;\n    ngx_url_t                      *url;\n    ngx_chain_t                    *al, *bl, *pl;\n    ngx_buf_t                      *b;\n\n    nscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_notify_module);\n\n    pl = ngx_alloc_chain_link(pool);\n    if (pl == NULL) {\n        return NULL;\n    }\n\n    b = ngx_create_temp_buf(pool,\n                            sizeof(\"&call=disconnect\") +\n                            sizeof(\"&app=\") + s->app.len * 3 +\n                            1 + s->args.len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    pl->buf = b;\n    pl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=disconnect\",\n                         sizeof(\"&call=disconnect\") - 1);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&app=\", sizeof(\"&app=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, s->app.data, s->app.len,\n                                       NGX_ESCAPE_ARGS);\n\n    if (s->args.len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, s->args.data, s->args.len);\n    }\n\n    url = nscf->url[NGX_RTMP_NOTIFY_DISCONNECT];\n\n    al = ngx_rtmp_netcall_http_format_session(s, pool);\n    if (al == NULL) {\n        return NULL;\n    }\n\n    al->next = pl;\n\n    bl = NULL;\n\n    if (nscf->method == NGX_RTMP_NETCALL_HTTP_POST) {\n        bl = al;\n        al = NULL;\n    }\n\n    return ngx_rtmp_netcall_http_format_request(nscf->method, &url->host,\n                                                &url->uri, al, bl, pool,\n                                                &ngx_rtmp_notify_urlencoded);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_publish_create(ngx_rtmp_session_t *s, void *arg,\n        ngx_pool_t *pool)\n{\n    ngx_rtmp_publish_t             *v = arg;\n\n    ngx_chain_t                    *pl;\n    ngx_buf_t                      *b;\n    size_t                          name_len, type_len, args_len;\n\n    pl = ngx_alloc_chain_link(pool);\n    if (pl == NULL) {\n        return NULL;\n    }\n\n    name_len = ngx_strlen(v->name);\n    type_len = ngx_strlen(v->type);\n    args_len = ngx_strlen(v->args);\n\n    b = ngx_create_temp_buf(pool,\n                            sizeof(\"&call=publish\") +\n                            sizeof(\"&name=\") + name_len * 3 +\n                            sizeof(\"&type=\") + type_len * 3 +\n                            1 + args_len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    pl->buf = b;\n    pl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=publish\",\n                         sizeof(\"&call=publish\") - 1);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&name=\", sizeof(\"&name=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->name, name_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&type=\", sizeof(\"&type=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->type, type_len,\n                                       NGX_ESCAPE_ARGS);\n\n    if (args_len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, v->args, args_len);\n    }\n\n    return ngx_rtmp_notify_create_request(s, pool, NGX_RTMP_NOTIFY_PUBLISH, pl);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_play_create(ngx_rtmp_session_t *s, void *arg,\n        ngx_pool_t *pool)\n{\n    ngx_rtmp_play_t                *v = arg;\n\n    ngx_chain_t                    *pl;\n    ngx_buf_t                      *b;\n    size_t                          name_len, args_len;\n\n    pl = ngx_alloc_chain_link(pool);\n    if (pl == NULL) {\n        return NULL;\n    }\n\n    name_len = ngx_strlen(v->name);\n    args_len = ngx_strlen(v->args);\n\n    b = ngx_create_temp_buf(pool,\n                            sizeof(\"&call=play\") +\n                            sizeof(\"&name=\") + name_len * 3 +\n                            sizeof(\"&start=&duration=&reset=\") +\n                            NGX_INT32_LEN * 3 + 1 + args_len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    pl->buf = b;\n    pl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=play\",\n                         sizeof(\"&call=play\") - 1);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&name=\", sizeof(\"&name=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->name, name_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_snprintf(b->last, b->end - b->last,\n                           \"&start=%uD&duration=%uD&reset=%d\",\n                           (uint32_t) v->start, (uint32_t) v->duration,\n                           v->reset & 1);\n\n    if (args_len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, v->args, args_len);\n    }\n\n    return ngx_rtmp_notify_create_request(s, pool, NGX_RTMP_NOTIFY_PLAY, pl);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_done_create(ngx_rtmp_session_t *s, void *arg,\n        ngx_pool_t *pool)\n{\n    ngx_rtmp_notify_done_t         *ds = arg;\n\n    ngx_chain_t                    *pl;\n    ngx_buf_t                      *b;\n    size_t                          cbname_len, name_len, args_len;\n    ngx_rtmp_notify_ctx_t          *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    pl = ngx_alloc_chain_link(pool);\n    if (pl == NULL) {\n        return NULL;\n    }\n\n    cbname_len = ngx_strlen(ds->cbname);\n    name_len = ctx ? ngx_strlen(ctx->name) : 0;\n    args_len = ctx ? ngx_strlen(ctx->args) : 0;\n\n    b = ngx_create_temp_buf(pool,\n                            sizeof(\"&call=\") + cbname_len +\n                            sizeof(\"&name=\") + name_len * 3 +\n                            1 + args_len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    pl->buf = b;\n    pl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=\", sizeof(\"&call=\") - 1);\n    b->last = ngx_cpymem(b->last, ds->cbname, cbname_len);\n\n    if (name_len) {\n        b->last = ngx_cpymem(b->last, (u_char*) \"&name=\", sizeof(\"&name=\") - 1);\n        b->last = (u_char*) ngx_escape_uri(b->last, ctx->name, name_len,\n                                           NGX_ESCAPE_ARGS);\n    }\n\n    if (args_len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, ctx->args, args_len);\n    }\n\n    return ngx_rtmp_notify_create_request(s, pool, ds->url_idx, pl);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_update_create(ngx_rtmp_session_t *s, void *arg,\n        ngx_pool_t *pool)\n{\n    ngx_chain_t                    *pl;\n    ngx_buf_t                      *b;\n    size_t                          name_len, args_len;\n    ngx_rtmp_notify_ctx_t          *ctx;\n    ngx_str_t                       sfx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    pl = ngx_alloc_chain_link(pool);\n    if (pl == NULL) {\n        return NULL;\n    }\n\n    if (ctx->flags & NGX_RTMP_NOTIFY_PUBLISHING) {\n        ngx_str_set(&sfx, \"_publish\");\n    } else if (ctx->flags & NGX_RTMP_NOTIFY_PLAYING) {\n        ngx_str_set(&sfx, \"_play\");\n    } else {\n        ngx_str_null(&sfx);\n    }\n\n    name_len = ctx ? ngx_strlen(ctx->name) : 0;\n    args_len = ctx ? ngx_strlen(ctx->args) : 0;\n\n    b = ngx_create_temp_buf(pool,\n                            sizeof(\"&call=update\") + sfx.len +\n                            sizeof(\"&time=\") + NGX_TIME_T_LEN +\n                            sizeof(\"&timestamp=\") + NGX_INT32_LEN +\n                            sizeof(\"&name=\") + name_len * 3 +\n                            1 + args_len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    pl->buf = b;\n    pl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=update\",\n                         sizeof(\"&call=update\") - 1);\n    b->last = ngx_cpymem(b->last, sfx.data, sfx.len);\n\n    b->last = ngx_cpymem(b->last, (u_char *) \"&time=\",\n                         sizeof(\"&time=\") - 1);\n    b->last = ngx_sprintf(b->last, \"%T\", ngx_cached_time->sec - ctx->start);\n\n    b->last = ngx_cpymem(b->last, (u_char *) \"&timestamp=\",\n                         sizeof(\"&timestamp=\") - 1);\n    b->last = ngx_sprintf(b->last, \"%D\", s->current_time);\n\n    if (name_len) {\n        b->last = ngx_cpymem(b->last, (u_char*) \"&name=\", sizeof(\"&name=\") - 1);\n        b->last = (u_char*) ngx_escape_uri(b->last, ctx->name, name_len,\n                                           NGX_ESCAPE_ARGS);\n    }\n\n    if (args_len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, ctx->args, args_len);\n    }\n\n    return ngx_rtmp_notify_create_request(s, pool, NGX_RTMP_NOTIFY_UPDATE, pl);\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_notify_record_done_create(ngx_rtmp_session_t *s, void *arg,\n                                   ngx_pool_t *pool)\n{\n    ngx_rtmp_record_done_t         *v = arg;\n\n    ngx_rtmp_notify_ctx_t          *ctx;\n    ngx_chain_t                    *pl;\n    ngx_buf_t                      *b;\n    size_t                          name_len, args_len;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    pl = ngx_alloc_chain_link(pool);\n    if (pl == NULL) {\n        return NULL;\n    }\n\n    name_len  = ngx_strlen(ctx->name);\n    args_len  = ngx_strlen(ctx->args);\n\n    b = ngx_create_temp_buf(pool,\n                            sizeof(\"&call=record_done\") +\n                            sizeof(\"&recorder=\") + v->recorder.len +\n                            sizeof(\"&name=\") + name_len * 3 +\n                            sizeof(\"&path=\") + v->path.len * 3 +\n                            1 + args_len);\n    if (b == NULL) {\n        return NULL;\n    }\n\n    pl->buf = b;\n    pl->next = NULL;\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&call=record_done\",\n                         sizeof(\"&call=record_done\") - 1);\n\n    b->last = ngx_cpymem(b->last, (u_char *) \"&recorder=\",\n                         sizeof(\"&recorder=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->recorder.data,\n                                       v->recorder.len, NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&name=\", sizeof(\"&name=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, ctx->name, name_len,\n                                       NGX_ESCAPE_ARGS);\n\n    b->last = ngx_cpymem(b->last, (u_char*) \"&path=\", sizeof(\"&path=\") - 1);\n    b->last = (u_char*) ngx_escape_uri(b->last, v->path.data, v->path.len,\n                                       NGX_ESCAPE_ARGS);\n\n    if (args_len) {\n        *b->last++ = '&';\n        b->last = (u_char *) ngx_cpymem(b->last, ctx->args, args_len);\n    }\n\n    return ngx_rtmp_notify_create_request(s, pool, NGX_RTMP_NOTIFY_RECORD_DONE,\n                                          pl);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_parse_http_retcode(ngx_rtmp_session_t *s,\n        ngx_chain_t *in)\n{\n    ngx_buf_t      *b;\n    ngx_int_t       n;\n    u_char          c;\n\n    /* find 10th character */\n\n    n = 9;\n    while (in) {\n        b = in->buf;\n        if (b->last - b->pos > n) {\n            c = b->pos[n];\n            if (c >= (u_char)'0' && c <= (u_char)'9') {\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                    \"notify: HTTP retcode: %dxx\", (int)(c - '0'));\n                switch (c) {\n                    case (u_char) '2':\n                        return NGX_OK;\n                    case (u_char) '3':\n                        return NGX_AGAIN;\n                    default:\n                        return NGX_ERROR;\n                }\n            }\n\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                    \"notify: invalid HTTP retcode: %d..\", (int)c);\n\n            return NGX_ERROR;\n        }\n        n -= (b->last - b->pos);\n        in = in->next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n            \"notify: empty or broken HTTP response\");\n\n    /*\n     * not enough data;\n     * it can happen in case of empty or broken reply\n     */\n\n    return NGX_ERROR;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_parse_http_header(ngx_rtmp_session_t *s,\n        ngx_chain_t *in, ngx_str_t *name, u_char *data, size_t len)\n{\n    ngx_buf_t      *b;\n    ngx_int_t       matched;\n    u_char         *p, c;\n    ngx_uint_t      n;\n\n    enum {\n        parse_name,\n        parse_space,\n        parse_value,\n        parse_value_newline\n    } state = parse_name;\n\n    n = 0;\n    matched = 0;\n\n    while (in) {\n        b = in->buf;\n\n        for (p = b->pos; p != b->last; ++p) {\n            c = *p;\n\n            if (c == '\\r') {\n                continue;\n            }\n\n            switch (state) {\n                case parse_value_newline:\n                    if (c == ' ' || c == '\\t') {\n                        state = parse_space;\n                        break;\n                    }\n\n                    if (matched) {\n                        return n;\n                    }\n\n                    if (c == '\\n') {\n                        return NGX_OK;\n                    }\n\n                    n = 0;\n                    state = parse_name;\n\n                    /* fall through */\n\n                case parse_name:\n                    switch (c) {\n                        case ':':\n                            matched = (n == name->len);\n                            n = 0;\n                            state = parse_space;\n                            break;\n                        case '\\n':\n                            n = 0;\n                            break;\n                        default:\n                            if (n < name->len &&\n                                ngx_tolower(c) == ngx_tolower(name->data[n]))\n                            {\n                                ++n;\n                                break;\n                            }\n                            n = name->len + 1;\n                    }\n                    break;\n\n                case parse_space:\n                    if (c == ' ' || c == '\\t') {\n                        break;\n                    }\n                    state = parse_value;\n\n                    /* fall through */\n\n                case parse_value:\n                    if (c == '\\n') {\n                        state = parse_value_newline;\n                        break;\n                    }\n\n                    if (matched && n + 1 < len) {\n                        data[n++] = c;\n                    }\n\n                    break;\n            }\n        }\n\n        in = in->next;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_notify_clear_flag(ngx_rtmp_session_t *s, ngx_uint_t flag)\n{\n    ngx_rtmp_notify_ctx_t  *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    ctx->flags &= ~flag;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_connect_handle(ngx_rtmp_session_t *s,\n        void *arg, ngx_chain_t *in)\n{\n    ngx_rtmp_connect_t     *v = arg;\n    ngx_http_request_t     *r;\n    ngx_int_t               rc;\n    u_char                  app[NGX_RTMP_MAX_NAME];\n\n    static ngx_rtmp_play_t  p;\n    static ngx_str_t        location = ngx_string(\"location\");\n\n    rc = ngx_rtmp_notify_parse_http_retcode(s, in);\n    if (rc == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    if (rc == NGX_AGAIN) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"notify: connect redirect received\");\n\n        rc = ngx_rtmp_notify_parse_http_header(s, in, &location, app,\n                                               sizeof(app) - 1);\n        if (rc > 0) {\n            *ngx_cpymem(v->app, app, rc) = 0;\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                          \"notify: connect redirect to '%s'\", v->app);\n        }\n    }\n\n    rc = next_connect(s, v);\n    if (rc == NGX_OK && s->notify_connect) {\n        r = s->data;\n        if (r) {\n            ngx_memzero(&p, sizeof(ngx_rtmp_play_t));\n            ngx_memcpy(p.name, s->stream.data,\n                       ngx_min(s->stream.len, NGX_RTMP_MAX_NAME - 1));\n            ngx_memcpy(p.args, s->args.data,\n                       ngx_min(s->args.len, NGX_RTMP_MAX_ARGS - 1));\n\n            rc = ngx_rtmp_play(s, &p);\n        }\n    }\n\n    s->notify_connect = 0;\n\n    return rc;\n}\n\n\nstatic void\nngx_rtmp_notify_set_name(u_char *dst, size_t dst_len, u_char *src,\n    size_t src_len)\n{\n    u_char     result[16], *p;\n    ngx_md5_t  md5;\n\n    ngx_md5_init(&md5);\n    ngx_md5_update(&md5, src, src_len);\n    ngx_md5_final(result, &md5);\n\n    p = ngx_hex_dump(dst, result, ngx_min((dst_len - 1) / 2, 16));\n    *p = '\\0';\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_publish_handle(ngx_rtmp_session_t *s,\n        void *arg, ngx_chain_t *in)\n{\n    ngx_rtmp_publish_t         *v = arg;\n    ngx_int_t                   rc;\n    ngx_str_t                   local_name;\n    ngx_rtmp_relay_target_t     target;\n    ngx_url_t                  *u;\n    ngx_rtmp_notify_app_conf_t *nacf;\n    u_char                      name[NGX_RTMP_MAX_NAME];\n\n    static ngx_str_t    location = ngx_string(\"location\");\n\n    rc = ngx_rtmp_notify_parse_http_retcode(s, in);\n    if (rc == NGX_ERROR) {\n        ngx_rtmp_notify_clear_flag(s, NGX_RTMP_NOTIFY_PUBLISHING);\n        return NGX_ERROR;\n    }\n\n    if (rc != NGX_AGAIN) {\n        goto next;\n    }\n\n    /* HTTP 3xx */\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"notify: publish redirect received\");\n\n    rc = ngx_rtmp_notify_parse_http_header(s, in, &location, name,\n                                           sizeof(name) - 1);\n    if (rc <= 0) {\n        goto next;\n    }\n\n    if (ngx_strncasecmp(name, (u_char *) \"rtmp://\", 7)) {\n        *ngx_cpymem(v->name, name, rc) = 0;\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                      \"notify: publish redirect to '%s'\", v->name);\n        goto next;\n    }\n\n    /* push */\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n    if (nacf->relay_redirect) {\n        ngx_rtmp_notify_set_name(v->name, NGX_RTMP_MAX_NAME, name, (size_t) rc);\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: push '%s' to '%*s'\", v->name, rc, name);\n\n    local_name.data = v->name;\n    local_name.len = ngx_strlen(v->name);\n\n    ngx_memzero(&target, sizeof(target));\n\n    u = &target.url;\n    u->url = local_name;\n    u->url.data = name + 7;\n    u->url.len = rc - 7;\n    u->default_port = 1935;\n    u->uri_part = 1;\n    u->no_resolve = nacf->no_resolve; /* want ip here */\n\n    if (ngx_parse_url(s->connection->pool, u) != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"notify: push failed '%V'\", &local_name);\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_relay_push(s, &local_name, &target);\n\nnext:\n\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_play_handle(ngx_rtmp_session_t *s,\n        void *arg, ngx_chain_t *in)\n{\n    ngx_rtmp_play_t            *v = arg;\n    ngx_int_t                   rc;\n    ngx_str_t                   local_name;\n    ngx_rtmp_relay_target_t     target;\n    ngx_url_t                  *u;\n    ngx_rtmp_notify_app_conf_t *nacf;\n    u_char                      name[NGX_RTMP_MAX_NAME];\n\n    static ngx_str_t            location = ngx_string(\"location\");\n\n    if (s->notify_play) {\n        s->notify_play = 0;\n    }\n\n    rc = ngx_rtmp_notify_parse_http_retcode(s, in);\n    if (rc == NGX_ERROR) {\n        ngx_rtmp_notify_clear_flag(s, NGX_RTMP_NOTIFY_PLAYING);\n        return NGX_ERROR;\n    }\n\n    if (rc != NGX_AGAIN) {\n        goto next;\n    }\n\n    /* HTTP 3xx */\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"notify: play redirect received\");\n\n    rc = ngx_rtmp_notify_parse_http_header(s, in, &location, name,\n                                           sizeof(name) - 1);\n    if (rc <= 0) {\n        goto next;\n    }\n\n    if (ngx_strncasecmp(name, (u_char *) \"rtmp://\", 7)) {\n        *ngx_cpymem(v->name, name, rc) = 0;\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                      \"notify: play redirect to '%s'\", v->name);\n        goto next;\n    }\n\n    /* pull */\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n    if (nacf->relay_redirect) {\n        ngx_rtmp_notify_set_name(v->name, NGX_RTMP_MAX_NAME, name, (size_t) rc);\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: pull '%s' from '%*s'\", v->name, rc, name);\n\n    local_name.data = v->name;\n    local_name.len = ngx_strlen(v->name);\n\n    ngx_memzero(&target, sizeof(target));\n\n    u = &target.url;\n    u->url = local_name;\n    u->url.data = name + 7;\n    u->url.len = rc - 7;\n    u->default_port = 1935;\n    u->uri_part = 1;\n    u->no_resolve = nacf->no_resolve; /* want ip here */\n\n    if (ngx_parse_url(s->connection->pool, u) != NGX_OK) {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                      \"notify: pull failed '%V'\", &local_name);\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_relay_pull(s, &local_name, &target);\n\nnext:\n\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_update_handle(ngx_rtmp_session_t *s,\n        void *arg, ngx_chain_t *in)\n{\n    ngx_rtmp_notify_app_conf_t *nacf;\n    ngx_rtmp_notify_ctx_t      *ctx;\n    ngx_int_t                   rc;\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n\n    rc = ngx_rtmp_notify_parse_http_retcode(s, in);\n\n    if ((!nacf->update_strict && rc == NGX_ERROR) ||\n         (nacf->update_strict && rc != NGX_OK))\n    {\n        ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                      \"notify: update failed\");\n\n        return NGX_ERROR;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"notify: schedule update %Mms\",\n                   nacf->update_timeout);\n\n    ngx_add_timer(&ctx->update_evt, nacf->update_timeout);\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_notify_update(ngx_event_t *e)\n{\n    ngx_rtmp_session_t         *s;\n    ngx_rtmp_notify_app_conf_t *nacf;\n    ngx_rtmp_netcall_init_t     ci;\n    ngx_url_t                  *url;\n\n    s = e->data;\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n\n    url = nacf->url[NGX_RTMP_NOTIFY_UPDATE];\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: update '%V'\", &url->url);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = url;\n    ci.create = ngx_rtmp_notify_update_create;\n    ci.handle = ngx_rtmp_notify_update_handle;\n\n    if (ngx_rtmp_netcall_create(s, &ci) == NGX_OK) {\n        return;\n    }\n\n    /* schedule next update on connection error */\n\n    ngx_rtmp_notify_update_handle(s, NULL, NULL);\n}\n\n\nstatic void\nngx_rtmp_notify_init(ngx_rtmp_session_t *s,\n        u_char name[NGX_RTMP_MAX_NAME], u_char args[NGX_RTMP_MAX_ARGS],\n        ngx_uint_t flags)\n{\n    ngx_rtmp_notify_ctx_t          *ctx;\n    ngx_rtmp_notify_app_conf_t     *nacf;\n    ngx_event_t                    *e;\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n    if (!nacf->active) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_notify_ctx_t));\n        if (ctx == NULL) {\n            return;\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_notify_module);\n    }\n\n    ngx_memcpy(ctx->name, name, NGX_RTMP_MAX_NAME);\n    ngx_memcpy(ctx->args, args, NGX_RTMP_MAX_ARGS);\n\n    ctx->flags |= flags;\n\n    if (nacf->url[NGX_RTMP_NOTIFY_UPDATE] == NULL ||\n        nacf->update_timeout == 0)\n    {\n        return;\n    }\n\n    if (ctx->update_evt.timer_set) {\n        return;\n    }\n\n    ctx->start = ngx_cached_time->sec;\n\n    e = &ctx->update_evt;\n\n    e->data = s;\n    e->log = s->connection->log;\n    e->handler = ngx_rtmp_notify_update;\n\n    ngx_add_timer(e, nacf->update_timeout);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"notify: schedule initial update %Mms\",\n                   nacf->update_timeout);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_connect(ngx_rtmp_session_t *s, ngx_rtmp_connect_t *v)\n{\n    ngx_rtmp_notify_srv_conf_t     *nscf;\n    ngx_rtmp_netcall_init_t         ci;\n    ngx_url_t                      *url;\n\n    if (s->auto_pushed || s->relay) {\n        goto next;\n    }\n\n    nscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_notify_module);\n\n    url = nscf->url[NGX_RTMP_NOTIFY_CONNECT];\n    if (url == NULL) {\n        goto next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: connect '%V'\", &url->url);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = url;\n    ci.create = ngx_rtmp_notify_connect_create;\n    ci.handle = ngx_rtmp_notify_connect_handle;\n    ci.arg = v;\n    ci.argsize = sizeof(*v);\n\n    s->notify_connect = 1;\n\n    return ngx_rtmp_netcall_create(s, &ci);\n\nnext:\n    return next_connect(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_disconnect(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_notify_srv_conf_t     *nscf;\n    ngx_rtmp_netcall_init_t         ci;\n    ngx_url_t                      *url;\n\n    if (s->auto_pushed || s->relay) {\n        goto next;\n    }\n\n    nscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_notify_module);\n\n    url = nscf->url[NGX_RTMP_NOTIFY_DISCONNECT];\n    if (url == NULL) {\n        goto next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: disconnect '%V'\", &url->url);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = url;\n    ci.create = ngx_rtmp_notify_disconnect_create;\n\n    ngx_rtmp_netcall_create(s, &ci);\n\nnext:\n    return next_disconnect(s);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_notify_app_conf_t     *nacf;\n    ngx_rtmp_netcall_init_t         ci;\n    ngx_url_t                      *url;\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n    if (nacf == NULL) {\n        goto next;\n    }\n\n    url = nacf->url[NGX_RTMP_NOTIFY_PUBLISH];\n\n    ngx_rtmp_notify_init(s, v->name, v->args, NGX_RTMP_NOTIFY_PUBLISHING);\n\n    if (url == NULL) {\n        goto next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: publish '%V'\", &url->url);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = url;\n    ci.create = ngx_rtmp_notify_publish_create;\n    ci.handle = ngx_rtmp_notify_publish_handle;\n    ci.arg = v;\n    ci.argsize = sizeof(*v);\n\n    return ngx_rtmp_netcall_create(s, &ci);\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_notify_app_conf_t     *nacf;\n    ngx_rtmp_netcall_init_t         ci;\n    ngx_url_t                      *url;\n\n    if (s->auto_pushed || v->silent) {\n        goto next;\n    }\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n    if (nacf == NULL) {\n        goto next;\n    }\n\n    url = nacf->url[NGX_RTMP_NOTIFY_PLAY];\n\n    ngx_rtmp_notify_init(s, v->name, v->args, NGX_RTMP_NOTIFY_PLAYING);\n\n    if (url == NULL) {\n        goto next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: play '%V'\", &url->url);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = url;\n    ci.create = ngx_rtmp_notify_play_create;\n    ci.handle = ngx_rtmp_notify_play_handle;\n    ci.arg = v;\n    ci.argsize = sizeof(*v);\n\n    s->notify_play = 1;\n\n    return ngx_rtmp_netcall_create(s, &ci);\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_close_stream(ngx_rtmp_session_t *s,\n                             ngx_rtmp_close_stream_t *v)\n{\n    ngx_rtmp_notify_ctx_t          *ctx;\n    ngx_rtmp_notify_app_conf_t     *nacf;\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_notify_module);\n\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n\n    if (nacf == NULL) {\n        goto next;\n    }\n\n    if (ctx->flags & NGX_RTMP_NOTIFY_PUBLISHING) {\n        ngx_rtmp_notify_done(s, \"publish_done\", NGX_RTMP_NOTIFY_PUBLISH_DONE);\n    }\n\n    if (ctx->flags & NGX_RTMP_NOTIFY_PLAYING) {\n        ngx_rtmp_notify_done(s, \"play_done\", NGX_RTMP_NOTIFY_PLAY_DONE);\n    }\n\n    if (ctx->flags) {\n        ngx_rtmp_notify_done(s, \"done\", NGX_RTMP_NOTIFY_DONE);\n    }\n\n    if (ctx->update_evt.timer_set) {\n        ngx_del_timer(&ctx->update_evt);\n    }\n\n    ctx->flags = 0;\n\nnext:\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_record_done(ngx_rtmp_session_t *s, ngx_rtmp_record_done_t *v)\n{\n    ngx_rtmp_netcall_init_t         ci;\n    ngx_rtmp_notify_app_conf_t     *nacf;\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n    if (nacf == NULL || nacf->url[NGX_RTMP_NOTIFY_RECORD_DONE] == NULL) {\n        goto next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: record_done recorder=%V path='%V' url='%V'\",\n                  &v->recorder, &v->path,\n                  &nacf->url[NGX_RTMP_NOTIFY_RECORD_DONE]->url);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url    = nacf->url[NGX_RTMP_NOTIFY_RECORD_DONE];\n    ci.create = ngx_rtmp_notify_record_done_create;\n    ci.arg    = v;\n\n    ngx_rtmp_netcall_create(s, &ci);\n\nnext:\n    return next_record_done(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_done(ngx_rtmp_session_t *s, char *cbname, ngx_uint_t url_idx)\n{\n    ngx_rtmp_netcall_init_t         ci;\n    ngx_rtmp_notify_done_t          ds;\n    ngx_rtmp_notify_app_conf_t     *nacf;\n    ngx_url_t                      *url;\n\n    nacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_notify_module);\n\n    url = nacf->url[url_idx];\n    if (url == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"notify: %s '%V'\", cbname, &url->url);\n\n    ds.cbname = (u_char *) cbname;\n    ds.url_idx = url_idx;\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = url;\n    ci.arg = &ds;\n    ci.create = ngx_rtmp_notify_done_create;\n\n    return ngx_rtmp_netcall_create(s, &ci);\n}\n\n\nstatic ngx_url_t *\nngx_rtmp_notify_parse_url(ngx_conf_t *cf, ngx_str_t *url)\n{\n    ngx_url_t  *u;\n    size_t      add;\n\n    add = 0;\n\n    u = ngx_pcalloc(cf->pool, sizeof(ngx_url_t));\n    if (u == NULL) {\n        return NULL;\n    }\n\n    if (ngx_strncasecmp(url->data, (u_char *) \"http://\", 7) == 0) {\n        add = 7;\n    }\n\n    u->url.len = url->len - add;\n    u->url.data = url->data + add;\n    u->default_port = 80;\n    u->uri_part = 1;\n\n    if (ngx_parse_url(cf->pool, u) != NGX_OK) {\n        if (u->err) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                    \"%s in url \\\"%V\\\"\", u->err, &u->url);\n        }\n        return NULL;\n    }\n\n    return u;\n}\n\n\nstatic char *\nngx_rtmp_notify_on_srv_event(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_notify_srv_conf_t     *nscf = conf;\n\n    ngx_str_t                      *name, *value;\n    ngx_url_t                      *u;\n    ngx_uint_t                      n;\n\n    value = cf->args->elts;\n\n    u = ngx_rtmp_notify_parse_url(cf, &value[1]);\n    if (u == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    name = &value[0];\n\n    n = 0;\n\n    switch (name->len) {\n        case sizeof(\"on_connect\") - 1:\n            n = NGX_RTMP_NOTIFY_CONNECT;\n            break;\n\n        case sizeof(\"on_disconnect\") - 1:\n            n = NGX_RTMP_NOTIFY_DISCONNECT;\n            break;\n    }\n\n    nscf->url[n] = u;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_notify_on_app_event(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_notify_app_conf_t     *nacf = conf;\n\n    ngx_str_t                      *name, *value;\n    ngx_url_t                      *u;\n    ngx_uint_t                      n;\n\n    value = cf->args->elts;\n\n    u = ngx_rtmp_notify_parse_url(cf, &value[1]);\n    if (u == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    name = &value[0];\n\n    n = 0;\n\n    switch (name->len) {\n        case sizeof(\"on_done\") - 1: /* and on_play */\n            if (name->data[3] == 'd') {\n                n = NGX_RTMP_NOTIFY_DONE;\n            } else {\n                n = NGX_RTMP_NOTIFY_PLAY;\n            }\n            break;\n\n        case sizeof(\"on_update\") - 1:\n            n = NGX_RTMP_NOTIFY_UPDATE;\n            break;\n\n        case sizeof(\"on_publish\") - 1:\n            n = NGX_RTMP_NOTIFY_PUBLISH;\n            break;\n\n        case sizeof(\"on_play_done\") - 1:\n            n = NGX_RTMP_NOTIFY_PLAY_DONE;\n            break;\n\n        case sizeof(\"on_record_done\") - 1:\n            n = NGX_RTMP_NOTIFY_RECORD_DONE;\n            break;\n\n        case sizeof(\"on_publish_done\") - 1:\n            n = NGX_RTMP_NOTIFY_PUBLISH_DONE;\n            break;\n    }\n\n    nacf->url[n] = u;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_notify_method(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_notify_app_conf_t     *nacf = conf;\n\n    ngx_rtmp_notify_srv_conf_t     *nscf;\n    ngx_str_t                      *value;\n\n    value = cf->args->elts;\n    value++;\n\n    if (value->len == sizeof(\"get\") - 1 &&\n        ngx_strncasecmp(value->data, (u_char *) \"get\", value->len) == 0)\n    {\n        nacf->method = NGX_RTMP_NETCALL_HTTP_GET;\n\n    } else if (value->len == sizeof(\"post\") - 1 &&\n               ngx_strncasecmp(value->data, (u_char *) \"post\", value->len) == 0)\n    {\n        nacf->method = NGX_RTMP_NETCALL_HTTP_POST;\n\n    } else {\n        return \"got unexpected method\";\n    }\n\n    nscf = ngx_rtmp_conf_get_module_srv_conf(cf, ngx_rtmp_notify_module);\n    nscf->method = nacf->method;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_notify_postconfiguration(ngx_conf_t *cf)\n{\n    next_connect = ngx_rtmp_connect;\n    ngx_rtmp_connect = ngx_rtmp_notify_connect;\n\n    next_disconnect = ngx_rtmp_disconnect;\n    ngx_rtmp_disconnect = ngx_rtmp_notify_disconnect;\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_notify_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_notify_play;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_notify_close_stream;\n\n    next_record_done = ngx_rtmp_record_done;\n    ngx_rtmp_record_done = ngx_rtmp_notify_record_done;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_parse.c",
          "type": "blob",
          "size": 19.0732421875,
          "content": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\n#define NGX_RTMP_PARSE_INVALID_REQUEST    11\n\n\nstatic uint32_t  usual[] = {\n    0xffffdbfe, /* 1111 1111 1111 1111  1101 1011 1111 1110 */\n\n                /* ?>=< ;:98 7654 3210  /.-, +*)( '&%$ #\"!  */\n    0x7fff37d6, /* 0111 1111 1111 1111  0011 0111 1101 0110 */\n\n                /* _^]\\ [ZYX WVUT SRQP  ONML KJIH GFED CBA@ */\n#if (NGX_WIN32)\n    0xefffffff, /* 1110 1111 1111 1111  1111 1111 1111 1111 */\n#else\n    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n#endif\n\n                /*  ~}| {zyx wvut srqp  onml kjih gfed cba` */\n    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n\n    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    0xffffffff, /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n    0xffffffff  /* 1111 1111 1111 1111  1111 1111 1111 1111 */\n};\n\n\nngx_int_t\nngx_rtmp_parse_request_line(ngx_rtmp_session_t *s, ngx_buf_t *b)\n{\n    u_char  c, ch, *p;\n    enum {\n        sw_start = 0,\n        sw_schema,\n        sw_schema_slash,\n        sw_schema_slash_slash,\n        sw_host_start,\n        sw_host,\n        sw_host_end,\n        sw_host_ip_literal,\n        sw_port,\n        sw_after_slash_in_uri,\n        sw_check_uri,\n        sw_uri\n    } state;\n\n    state = sw_start;\n\n    for (p = b->pos; p < b->last; p++) {\n        ch = *p;\n\n        switch (state) {\n\n        case sw_start:\n\n            s->schema_start = p;\n            state = sw_schema;\n\n            /* fall through */\n\n        case sw_schema:\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                break;\n            }\n\n            switch (ch) {\n            case ':':\n                s->schema_end = p;\n                state = sw_schema_slash;\n                break;\n            default:\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_schema_slash:\n            switch (ch) {\n            case '/':\n                state = sw_schema_slash_slash;\n                break;\n            default:\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_schema_slash_slash:\n            switch (ch) {\n            case '/':\n                state = sw_host_start;\n                break;\n            default:\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_host_start:\n\n            s->host_start = p;\n\n            if (ch == '[') {\n                state = sw_host_ip_literal;\n                break;\n            }\n\n            state = sw_host;\n\n            /* fall through */\n\n        case sw_host:\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                break;\n            }\n\n            if ((ch >= '0' && ch <= '9') || ch == '.' || ch == '-') {\n                break;\n            }\n\n            /* fall through */\n\n        case sw_host_end:\n\n            s->host_end = p;\n\n            switch (ch) {\n            case ':':\n                s->port_start = p + 1;\n                state = sw_port;\n                break;\n            case '/':\n                s->uri_start = p;\n                state = sw_after_slash_in_uri;\n                break;\n            default:\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_host_ip_literal:\n\n            if (ch >= '0' && ch <= '9') {\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'z') {\n                break;\n            }\n\n            switch (ch) {\n            case ':':\n                break;\n            case ']':\n                state = sw_host_end;\n                break;\n            case '-':\n            case '.':\n            case '_':\n            case '~':\n                /* unreserved */\n                break;\n            case '!':\n            case '$':\n            case '&':\n            case '\\'':\n            case '(':\n            case ')':\n            case '*':\n            case '+':\n            case ',':\n            case ';':\n            case '=':\n                /* sub-delims */\n                break;\n            default:\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        case sw_port:\n            if (ch >= '0' && ch <= '9') {\n                break;\n            }\n\n            switch (ch) {\n            case '/':\n                s->port_end = p;\n                s->uri_start = p;\n                state = sw_after_slash_in_uri;\n                break;\n            default:\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* check \"/.\", \"//\", \"%\", and \"\\\" (Win32) in URI */\n        case sw_after_slash_in_uri:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                state = sw_check_uri;\n                break;\n            }\n\n            switch (ch) {\n            case '.':\n                s->complex_uri = 1;\n                state = sw_uri;\n                break;\n            case '%':\n                s->quoted_uri = 1;\n                state = sw_uri;\n                break;\n            case '/':\n                s->complex_uri = 1;\n                state = sw_uri;\n                break;\n#if (NGX_WIN32)\n            case '\\\\':\n                s->complex_uri = 1;\n                state = sw_uri;\n                break;\n#endif\n            case '?':\n                s->args_start = p + 1;\n                state = sw_uri;\n                break;\n            case '#':\n                s->complex_uri = 1;\n                state = sw_uri;\n                break;\n            case '+':\n                s->plus_in_uri = 1;\n                break;\n            case '\\0':\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            default:\n                state = sw_check_uri;\n                break;\n            }\n            break;\n\n        /* check \"/\", \"%\" and \"\\\" (Win32) in URI */\n        case sw_check_uri:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                break;\n            }\n\n            switch (ch) {\n            case '/':\n                state = sw_after_slash_in_uri;\n                break;\n            case '.':\n                break;\n#if (NGX_WIN32)\n            case '\\\\':\n                s->complex_uri = 1;\n                state = sw_after_slash_in_uri;\n                break;\n#endif\n            case '%':\n                s->quoted_uri = 1;\n                state = sw_uri;\n                break;\n            case '?':\n                s->args_start = p + 1;\n                state = sw_uri;\n                break;\n            case '#':\n                s->complex_uri = 1;\n                state = sw_uri;\n                break;\n            case '+':\n                s->plus_in_uri = 1;\n                break;\n            case '\\0':\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n            break;\n\n        /* URI */\n        case sw_uri:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                break;\n            }\n\n            switch (ch) {\n            case '#':\n                s->complex_uri = 1;\n                break;\n            case '\\0':\n                return NGX_RTMP_PARSE_INVALID_REQUEST;\n            }\n        }\n    }\n\n    /* end of request line */\n    s->uri_end = p;\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_process_request_uri(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_core_srv_conf_t  *cscf;\n\n    if (s->args_start) {\n        s->uri.len = s->args_start - 1 - s->uri_start;\n    } else {\n        s->uri.len = s->uri_end - s->uri_start;\n    }\n\n    if (s->complex_uri || s->quoted_uri) {\n\n        s->uri.data = ngx_pnalloc(s->connection->pool, s->uri.len + 1);\n        if (s->uri.data == NULL) {\n            return NGX_ERROR;\n        }\n\n        cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n        if (ngx_rtmp_parse_complex_uri(s, cscf->merge_slashes) != NGX_OK) {\n            s->uri.len = 0;\n\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                          \"client sent invalid request\");\n            return NGX_ERROR;\n        }\n\n    } else {\n        s->uri.data = s->uri_start;\n    }\n\n    s->unparsed_uri.len = s->uri_end - s->uri_start;\n    s->unparsed_uri.data = s->uri_start;\n\n    s->valid_unparsed_uri = s->space_in_uri ? 0 : 1;\n\n    if (s->args_start && s->uri_end > s->args_start) {\n        s->args.len = s->uri_end - s->args_start;\n        s->args.data = s->args_start;\n    }\n\n#if (NGX_WIN32)\n    {\n    u_char  *p, *last;\n\n    p = s->uri.data;\n    last = s->uri.data + s->uri.len;\n\n    while (p < last) {\n\n        if (*p++ == ':') {\n\n            /*\n             * this check covers \"::$data\", \"::$index_allocation\" and\n             * \":$i30:$index_allocation\"\n             */\n\n            if (p < last && *p == '$') {\n                ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                              \"client sent unsafe win32 URI\");\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    p = s->uri.data + s->uri.len - 1;\n\n    while (p > s->uri.data) {\n\n        if (*p == ' ') {\n            p--;\n            continue;\n        }\n\n        if (*p == '.') {\n            p--;\n            continue;\n        }\n\n        break;\n    }\n\n    if (p != s->uri.data + s->uri.len - 1) {\n        s->uri.len = p + 1 - s->uri.data;\n    }\n\n    }\n#endif\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"rtmp uri: \\\"%V\\\"\", &s->uri);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"rtmp args: \\\"%V\\\"\", &s->args);\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_parse_complex_uri(ngx_rtmp_session_t *s, ngx_uint_t merge_slashes)\n{\n    u_char  c, ch, decoded, *p, *u;\n    enum {\n        sw_usual = 0,\n        sw_slash,\n        sw_dot,\n        sw_dot_dot,\n        sw_quoted,\n        sw_quoted_second\n    } state, quoted_state;\n\n#if (NGX_SUPPRESS_WARN)\n    decoded = '\\0';\n    quoted_state = sw_usual;\n#endif\n\n    state = sw_usual;\n    p = s->uri_start;\n    u = s->uri.data;\n    s->args_start = NULL;\n\n    ch = *p++;\n\n    while (p <= s->uri_end) {\n\n        /*\n         * we use \"ch = *p++\" inside the cycle, it is safe,\n         * because after the URI there is a character: '\\r'\n         */\n\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"s:%d in:'%Xd:%c'\", state, ch, ch);\n\n        switch (state) {\n\n        case sw_usual:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                *u++ = ch;\n                ch = *p++;\n                break;\n            }\n\n            switch (ch) {\n#if (NGX_WIN32)\n            case '\\\\':\n                if (u - 2 >= s->uri.data\n                    && *(u - 1) == '.' && *(u - 2) != '.')\n                {\n                    u--;\n                }\n\n                if (p == s->uri_start + s->uri.len) {\n\n                    /*\n                     * we omit the last \"\\\" to cause redirect because\n                     * the browsers do not treat \"\\\" as \"/\" in relative URL path\n                     */\n\n                    break;\n                }\n\n                state = sw_slash;\n                *u++ = '/';\n                break;\n#endif\n            case '/':\n#if (NGX_WIN32)\n                if (u - 2 >= s->uri.data\n                    && *(u - 1) == '.' && *(u - 2) != '.')\n                {\n                    u--;\n                }\n#endif\n                state = sw_slash;\n                *u++ = ch;\n                break;\n            case '%':\n                quoted_state = state;\n                state = sw_quoted;\n                break;\n            case '?':\n                s->args_start = p;\n                goto args;\n            case '#':\n                goto done;\n            case '.':\n                *u++ = ch;\n                break;\n            case '+':\n                s->plus_in_uri = 1;\n\n                /* fall through */\n\n            default:\n                *u++ = ch;\n                break;\n            }\n\n            ch = *p++;\n            break;\n\n        case sw_slash:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                state = sw_usual;\n                *u++ = ch;\n                ch = *p++;\n                break;\n            }\n\n            switch (ch) {\n#if (NGX_WIN32)\n            case '\\\\':\n                break;\n#endif\n            case '/':\n                if (!merge_slashes) {\n                    *u++ = ch;\n                }\n                break;\n            case '.':\n                state = sw_dot;\n                *u++ = ch;\n                break;\n            case '%':\n                quoted_state = state;\n                state = sw_quoted;\n                break;\n            case '?':\n                s->args_start = p;\n                goto args;\n            case '#':\n                goto done;\n            case '+':\n                s->plus_in_uri = 1;\n\n                /* fall through */\n\n            default:\n                state = sw_usual;\n                *u++ = ch;\n                break;\n            }\n\n            ch = *p++;\n            break;\n\n        case sw_dot:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                state = sw_usual;\n                *u++ = ch;\n                ch = *p++;\n                break;\n            }\n\n            switch (ch) {\n#if (NGX_WIN32)\n            case '\\\\':\n#endif\n            case '/':\n                state = sw_slash;\n                u--;\n                break;\n            case '.':\n                state = sw_dot_dot;\n                *u++ = ch;\n                break;\n            case '%':\n                quoted_state = state;\n                state = sw_quoted;\n                break;\n            case '?':\n                s->args_start = p;\n                goto args;\n            case '#':\n                goto done;\n            case '+':\n                s->plus_in_uri = 1;\n\n                /* fall through */\n\n            default:\n                state = sw_usual;\n                *u++ = ch;\n                break;\n            }\n\n            ch = *p++;\n            break;\n\n        case sw_dot_dot:\n\n            if (usual[ch >> 5] & (1U << (ch & 0x1f))) {\n                state = sw_usual;\n                *u++ = ch;\n                ch = *p++;\n                break;\n            }\n\n            switch (ch) {\n#if (NGX_WIN32)\n            case '\\\\':\n#endif\n            case '/':\n                state = sw_slash;\n                u -= 5;\n                for ( ;; ) {\n                    if (u < s->uri.data) {\n                        return NGX_RTMP_PARSE_INVALID_REQUEST;\n                    }\n                    if (*u == '/') {\n                        u++;\n                        break;\n                    }\n                    u--;\n                }\n                break;\n            case '%':\n                quoted_state = state;\n                state = sw_quoted;\n                break;\n            case '?':\n                s->args_start = p;\n                goto args;\n            case '#':\n                goto done;\n            case '+':\n                s->plus_in_uri = 1;\n\n                /* fall through */\n\n            default:\n                state = sw_usual;\n                *u++ = ch;\n                break;\n            }\n\n            ch = *p++;\n            break;\n\n        case sw_quoted:\n            s->quoted_uri = 1;\n\n            if (ch >= '0' && ch <= '9') {\n                decoded = (u_char) (ch - '0');\n                state = sw_quoted_second;\n                ch = *p++;\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'f') {\n                decoded = (u_char) (c - 'a' + 10);\n                state = sw_quoted_second;\n                ch = *p++;\n                break;\n            }\n\n            return NGX_RTMP_PARSE_INVALID_REQUEST;\n\n        case sw_quoted_second:\n            if (ch >= '0' && ch <= '9') {\n                ch = (u_char) ((decoded << 4) + ch - '0');\n\n                if (ch == '%' || ch == '#') {\n                    state = sw_usual;\n                    *u++ = ch;\n                    ch = *p++;\n                    break;\n\n                } else if (ch == '\\0') {\n                    return NGX_RTMP_PARSE_INVALID_REQUEST;\n                }\n\n                state = quoted_state;\n                break;\n            }\n\n            c = (u_char) (ch | 0x20);\n            if (c >= 'a' && c <= 'f') {\n                ch = (u_char) ((decoded << 4) + c - 'a' + 10);\n\n                if (ch == '?') {\n                    state = sw_usual;\n                    *u++ = ch;\n                    ch = *p++;\n                    break;\n\n                } else if (ch == '+') {\n                    s->plus_in_uri = 1;\n                }\n\n                state = quoted_state;\n                break;\n            }\n\n            return NGX_RTMP_PARSE_INVALID_REQUEST;\n        }\n    }\n\ndone:\n\n    s->uri.len = *u == CR ? (u - s->uri.data) : (u - s->uri.data + 1);\n\n    return NGX_OK;\n\nargs:\n\n    while (p < s->uri_end) {\n        if (*p++ != '#') {\n            continue;\n        }\n\n        s->args.len = p - 1 - s->args_start;\n        s->args.data = s->args_start;\n        s->args_start = NULL;\n\n        break;\n    }\n\n    s->uri.len = u - s->uri.data;\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_process_request_line(ngx_rtmp_session_t *s, const u_char *name,\n                              const u_char *args, const u_char *cmd)\n{\n    size_t               rlen = 0;\n\n    s->stream.len = name ? ngx_strlen(name) : 0;\n    if (s->stream.len) {\n        s->stream.data = ngx_palloc(s->connection->pool, s->stream.len);\n        if (s->stream.data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(s->stream.data, name, ngx_strlen(name));\n    }\n\n    if (s->tc_url.data[s->tc_url.len - 1] == '/') {\n        s->tc_url.len -= 1;\n    }\n\n    rlen = s->tc_url.len;\n\n    if (s->stream.len) {\n        rlen += 1 + s->stream.len;\n    }\n\n    if (args && args[0]) {\n        rlen += 1 + ngx_strlen(args);\n    }\n\n    s->request_line = ngx_create_temp_buf(s->connection->pool, rlen + 1);\n    if (s->request_line == NULL) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"%s: failed to ngx_pcalloc for request_line\", cmd);\n        return NGX_ERROR;\n    }\n\n    if (s->stream.len) {\n        if (args && args[0]) {\n            *ngx_snprintf(s->request_line->pos, rlen + 1, \"%V/%V?%s\", &s->tc_url,\n                          &s->stream, args) = CR;\n        } else {\n            *ngx_snprintf(s->request_line->pos, rlen + 1, \"%V/%V\", &s->tc_url,\n                          &s->stream) = CR;\n        }\n    } else {\n        if (args && args[0]) {\n            *ngx_snprintf(s->request_line->pos, rlen + 1, \"%V?%s\", &s->tc_url,\n                          args) = CR;\n        } else {\n            *ngx_snprintf(s->request_line->pos, rlen + 1, \"%V\", &s->tc_url)\n                          = CR;\n        }\n    }\n\n    s->request_line->last += rlen;\n\n    if (ngx_rtmp_parse_request_line(s, s->request_line) != NGX_OK) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"%s: invalid request line: '%s'\", cmd, s->request_line->pos);\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_process_request_uri(s) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    *s->request_line->last = 0;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_play_module.c",
          "type": "blob",
          "size": 32.138671875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <nginx.h>\n#include \"ngx_rtmp_play_module.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_netcall_module.h\"\n#include \"ngx_rtmp_streams.h\"\n\n\nstatic ngx_rtmp_play_pt                 next_play;\nstatic ngx_rtmp_close_stream_pt         next_close_stream;\nstatic ngx_rtmp_seek_pt                 next_seek;\nstatic ngx_rtmp_pause_pt                next_pause;\n\n\nstatic char *ngx_rtmp_play_url(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic void *ngx_rtmp_play_create_main_conf(ngx_conf_t *cf);\nstatic ngx_int_t ngx_rtmp_play_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_play_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_play_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\n\nstatic ngx_int_t ngx_rtmp_play_do_init(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_play_do_done(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_play_do_start(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_play_do_stop(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_play_do_seek(ngx_rtmp_session_t *s,\n                                       ngx_uint_t timestamp);\n\nstatic ngx_int_t ngx_rtmp_play_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v);\nstatic ngx_int_t ngx_rtmp_play_seek(ngx_rtmp_session_t *s, ngx_rtmp_seek_t *v);\nstatic ngx_int_t ngx_rtmp_play_pause(ngx_rtmp_session_t *s,\n                                     ngx_rtmp_pause_t *v);\nstatic void ngx_rtmp_play_send(ngx_event_t *e);\nstatic ngx_int_t ngx_rtmp_play_open(ngx_rtmp_session_t *s, double start);\nstatic ngx_int_t ngx_rtmp_play_remote_handle(ngx_rtmp_session_t *s,\n       void *arg, ngx_chain_t *in);\nstatic ngx_chain_t * ngx_rtmp_play_remote_create(ngx_rtmp_session_t *s,\n       void *arg, ngx_pool_t *pool);\nstatic ngx_int_t ngx_rtmp_play_open_remote(ngx_rtmp_session_t *s,\n       ngx_rtmp_play_t *v);\nstatic ngx_int_t ngx_rtmp_play_next_entry(ngx_rtmp_session_t *s,\n       ngx_rtmp_play_t *v);\nstatic ngx_rtmp_play_entry_t * ngx_rtmp_play_get_current_entry(\n       ngx_rtmp_session_t *s);\nstatic void ngx_rtmp_play_cleanup_local_file(ngx_rtmp_session_t *s);\nstatic void ngx_rtmp_play_copy_local_file(ngx_rtmp_session_t *s, u_char *name);\nstatic u_char * ngx_rtmp_play_get_local_file_path(ngx_rtmp_session_t *s);\n\n\nstatic ngx_command_t  ngx_rtmp_play_commands[] = {\n\n    { ngx_string(\"play\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_play_url,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"play_temp_path\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_play_app_conf_t, temp_path),\n      NULL },\n\n    { ngx_string(\"play_local_path\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_play_app_conf_t, local_path),\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_play_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_play_postconfiguration,        /* postconfiguration */\n    ngx_rtmp_play_create_main_conf,         /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_play_create_app_conf,          /* create app configuration */\n    ngx_rtmp_play_merge_app_conf            /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_play_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_play_module_ctx,              /* module context */\n    ngx_rtmp_play_commands,                 /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\n#define NGX_RTMP_PLAY_TMP_FILE              \"nginx-http-flv-vod.\"\n\n\nstatic void *\nngx_rtmp_play_create_main_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_play_main_conf_t      *pmcf;\n\n    pmcf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_play_main_conf_t));\n    if (pmcf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&pmcf->fmts, cf->pool, 1,\n                       sizeof(ngx_rtmp_play_fmt_t *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return pmcf;\n}\n\n\nstatic void *\nngx_rtmp_play_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_play_app_conf_t      *pacf;\n\n    pacf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_play_app_conf_t));\n    if (pacf == NULL) {\n        return NULL;\n    }\n\n    pacf->nbuckets = 1024;\n\n    return pacf;\n}\n\n\nstatic char *\nngx_rtmp_play_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_play_app_conf_t *prev = parent;\n    ngx_rtmp_play_app_conf_t *conf = child;\n    ngx_rtmp_play_entry_t   **ppe;\n\n    ngx_conf_merge_str_value(conf->temp_path, prev->temp_path, \"/tmp\");\n    ngx_conf_merge_str_value(conf->local_path, prev->local_path, \"\");\n\n    if (prev->entries.nelts == 0) {\n        goto done;\n    }\n\n    if (conf->entries.nelts == 0) {\n        conf->entries = prev->entries;\n        goto done;\n    }\n\n    ppe = ngx_array_push_n(&conf->entries, prev->entries.nelts);\n    if (ppe == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memcpy(ppe, prev->entries.elts, prev->entries.nelts * sizeof(void *));\n\ndone:\n\n    if (conf->entries.nelts == 0) {\n        return NGX_CONF_OK;\n    }\n\n    conf->ctx = ngx_pcalloc(cf->pool, sizeof(void *) * conf->nbuckets);\n    if (conf->ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_join(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t        *ctx, **pctx;\n    ngx_rtmp_play_app_conf_t   *pacf;\n    ngx_uint_t                  h;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: join\");\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n    if (ctx == NULL || ctx->joined) {\n        return NGX_ERROR;\n    }\n\n    h = ngx_hash_key(ctx->name, ngx_strlen(ctx->name));\n    pctx = &pacf->ctx[h % pacf->nbuckets];\n\n    while (*pctx) {\n        if (!ngx_strncmp((*pctx)->name, ctx->name, NGX_RTMP_MAX_NAME)) {\n            break;\n        }\n        pctx = &(*pctx)->next;\n    }\n\n    ctx->next = *pctx;\n    *pctx = ctx;\n    ctx->joined = 1;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_leave(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t        *ctx, **pctx;\n    ngx_rtmp_play_app_conf_t   *pacf;\n    ngx_uint_t                  h;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: leave\");\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n    if (ctx == NULL || !ctx->joined) {\n        return NGX_ERROR;\n    }\n\n    h = ngx_hash_key(ctx->name, ngx_strlen(ctx->name));\n    pctx = &pacf->ctx[h % pacf->nbuckets];\n\n    while (*pctx && *pctx != ctx) {\n        pctx = &(*pctx)->next;\n    }\n\n    if (*pctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    *pctx = (*pctx)->next;\n    ctx->joined = 0;\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_play_send(ngx_event_t *e)\n{\n    ngx_rtmp_session_t     *s = e->data;\n    ngx_rtmp_play_ctx_t    *ctx;\n    ngx_int_t               rc;\n    ngx_uint_t              ts;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL || ctx->fmt == NULL || ctx->fmt->send == NULL) {\n        return;\n    }\n\n    ts = 0;\n\n    rc = ctx->fmt->send(s, &ctx->file, &ts);\n\n    if (rc > 0) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: send schedule %i\", rc);\n\n        ngx_add_timer(e, rc);\n        return;\n    }\n\n    if (rc == NGX_AGAIN) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: send buffer full\");\n\n        ngx_post_event(e, &s->posted_dry_events);\n        return;\n    }\n\n    if (rc == NGX_OK) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: send restart\");\n\n        ngx_post_event(e, &ngx_posted_events);\n        return;\n    }\n\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: send done\");\n\n    ngx_rtmp_send_stream_eof(s, NGX_RTMP_MSID);\n\n    ngx_rtmp_send_play_status(s, \"NetStream.Play.Complete\", \"status\", ts, 0);\n\n    ngx_rtmp_send_status(s, \"NetStream.Play.Stop\", \"status\", \"Stopped\");\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_do_init(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->fmt && ctx->fmt->init &&\n        ctx->fmt->init(s, &ctx->file, ctx->aindex, ctx->vindex) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_do_done(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->fmt && ctx->fmt->done &&\n        ctx->fmt->done(s, &ctx->file) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_do_start(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: start\");\n\n    if (ctx->fmt && ctx->fmt->start &&\n        ctx->fmt->start(s, &ctx->file) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_post_event((&ctx->send_evt), &ngx_posted_events);\n\n    ctx->playing = 1;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_do_seek(ngx_rtmp_session_t *s, ngx_uint_t timestamp)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: seek timestamp=%ui\", timestamp);\n\n    if (ctx->fmt && ctx->fmt->seek &&\n        ctx->fmt->seek(s, &ctx->file, timestamp) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (ctx->playing) {\n        ngx_post_event((&ctx->send_evt), &ngx_posted_events);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_do_stop(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: stop\");\n\n    if (ctx->send_evt.timer_set) {\n        ngx_del_timer(&ctx->send_evt);\n    }\n\n#if (nginx_version >= 1007005)\n    if (ctx->send_evt.posted)\n#else\n    if (ctx->send_evt.prev)\n#endif\n    {\n        ngx_delete_posted_event((&ctx->send_evt));\n    }\n\n    if (ctx->fmt && ctx->fmt->stop &&\n        ctx->fmt->stop(s, &ctx->file) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    ctx->playing = 0;\n\n    return NGX_OK;\n}\n\n\n/* This function returns pointer to a static buffer */\n\nstatic u_char *\nngx_rtmp_play_get_local_file_path(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_app_conf_t       *pacf;\n    ngx_rtmp_play_ctx_t            *ctx;\n    u_char                         *p;\n    static u_char                   path[NGX_MAX_PATH + 1];\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    p = ngx_snprintf(path, NGX_MAX_PATH, \"%V/\" NGX_RTMP_PLAY_TMP_FILE \"%ui\",\n                     &pacf->temp_path, ctx->file_id);\n    *p = 0;\n\n    return path;\n}\n\n\nstatic void\nngx_rtmp_play_copy_local_file(ngx_rtmp_session_t *s, u_char *name)\n{\n    ngx_rtmp_play_app_conf_t   *pacf;\n    ngx_rtmp_play_ctx_t        *ctx;\n    u_char                     *path, *p;\n    static u_char               dpath[NGX_MAX_PATH + 1];\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n    if (pacf == NULL) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n    if (ctx == NULL || ctx->file_id == 0) {\n        return;\n    }\n\n    path = ngx_rtmp_play_get_local_file_path(s);\n\n    p = ngx_snprintf(dpath, NGX_MAX_PATH, \"%V/%s%V\", &pacf->local_path,\n                     name + ctx->pfx_size, &ctx->sfx);\n    *p = 0;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: copy local file '%s' to '%s'\", path, dpath);\n\n    if (ngx_rename_file(path, dpath) == 0) {\n        ctx->file_id = 0;\n        return;\n    }\n\n    ngx_log_error(NGX_LOG_ERR, s->connection->log, ngx_errno,\n                  \"play: error copying local file '%s' to '%s'\",\n                  path, dpath);\n\n    ngx_rtmp_play_cleanup_local_file(s);\n}\n\n\nstatic void\nngx_rtmp_play_cleanup_local_file(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_ctx_t        *ctx;\n    u_char                     *path;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n    if (ctx == NULL || ctx->file_id == 0) {\n        return;\n    }\n\n    path = ngx_rtmp_play_get_local_file_path(s);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: deleting local file '%s'\", path);\n\n    ctx->file_id = 0;\n\n    ngx_delete_file(path);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_close_stream(ngx_rtmp_session_t *s, ngx_rtmp_close_stream_t *v)\n{\n    ngx_rtmp_play_ctx_t        *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n    if (ctx == NULL) {\n        goto next;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: close_stream\");\n\n    ngx_rtmp_play_do_stop(s);\n\n    ngx_rtmp_play_do_done(s);\n\n    if (ctx->file.fd != NGX_INVALID_FILE) {\n        ngx_close_file(ctx->file.fd);\n        ctx->file.fd = NGX_INVALID_FILE;\n\n        ngx_rtmp_send_stream_eof(s, NGX_RTMP_MSID);\n\n        ngx_rtmp_send_status(s, \"NetStream.Play.Stop\", \"status\",\n                             \"Stop video on demand\");\n    }\n\n    if (ctx->file_id) {\n        ngx_rtmp_play_cleanup_local_file(s);\n    }\n\n    ngx_rtmp_play_leave(s);\n\nnext:\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_seek(ngx_rtmp_session_t *s, ngx_rtmp_seek_t *v)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n    if (ctx == NULL || ctx->file.fd == NGX_INVALID_FILE) {\n        goto next;\n    }\n\n    if (!ctx->opened) {\n        ctx->post_seek = (ngx_uint_t) v->offset;\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: post seek=%ui\", ctx->post_seek);\n        goto next;\n    }\n\n    if (ngx_rtmp_send_stream_eof(s, NGX_RTMP_MSID) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ngx_rtmp_play_do_seek(s, (ngx_uint_t) v->offset);\n\n    if (ngx_rtmp_send_status(s, \"NetStream.Seek.Notify\", \"status\", \"Seeking\")\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_send_stream_begin(s, NGX_RTMP_MSID) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\nnext:\n    return next_seek(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_pause(ngx_rtmp_session_t *s, ngx_rtmp_pause_t *v)\n{\n    ngx_rtmp_play_ctx_t            *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx == NULL || ctx->file.fd == NGX_INVALID_FILE) {\n        goto next;\n    }\n\n    if (!ctx->opened) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: pause ignored\");\n        goto next;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: pause=%i timestamp=%f\",\n                   (ngx_int_t) v->pause, v->position);\n\n    if (v->pause) {\n        if (ngx_rtmp_send_status(s, \"NetStream.Pause.Notify\", \"status\",\n                                 \"Paused video on demand\")\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_play_do_stop(s);\n\n    } else {\n        if (ngx_rtmp_send_status(s, \"NetStream.Unpause.Notify\", \"status\",\n                                 \"Unpaused video on demand\")\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_play_do_start(s); /*TODO: v->position? */\n    }\n\nnext:\n    return next_pause(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_parse_index(char type, u_char *args)\n{\n    u_char             *p, c;\n    static u_char       name[] = \"xindex=\";\n\n    name[0] = (u_char) type;\n\n    for ( ;; ) {\n        p = (u_char *) ngx_strstr(args, name);\n        if (p == NULL) {\n            return 0;\n        }\n\n        if (p != args) {\n            c = *(p - 1);\n            if (c != '?' && c != '&') {\n                args = p + 1;\n                continue;\n            }\n        }\n\n        return atoi((char *) p + (sizeof(name) - 1));\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_play_main_conf_t      *pmcf;\n    ngx_rtmp_play_app_conf_t       *pacf;\n    ngx_rtmp_play_ctx_t            *ctx;\n    u_char                         *p;\n    ngx_rtmp_play_fmt_t            *fmt, **pfmt;\n    ngx_str_t                      *pfx, *sfx;\n    ngx_str_t                       name;\n    ngx_uint_t                      n;\n\n    pmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_play_module);\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    if (pacf == NULL || pacf->entries.nelts == 0) {\n        goto next;\n    }\n\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                  \"play: play name='%s' timestamp=%i\",\n                  v->name, (ngx_int_t) v->start);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx && ctx->file.fd != NGX_INVALID_FILE) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                     \"play: already playing\");\n        goto next;\n    }\n\n    /* check for double-dot in v->name;\n     * we should not move out of play directory */\n    for (p = v->name; *p; ++p) {\n        if (ngx_path_separator(p[0]) &&\n            p[1] == '.' && p[2] == '.' &&\n            ngx_path_separator(p[3]))\n        {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                         \"play: bad name '%s'\", v->name);\n            return NGX_ERROR;\n        }\n    }\n\n    if (ctx == NULL) {\n        ctx = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_play_ctx_t));\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_play_module);\n    }\n\n    ngx_memzero(ctx, sizeof(*ctx));\n\n    ctx->session = s;\n    ctx->aindex = ngx_rtmp_play_parse_index('a', v->args);\n    ctx->vindex = ngx_rtmp_play_parse_index('v', v->args);\n\n    ctx->file.log = s->connection->log;\n\n    ngx_memcpy(ctx->name, v->name, NGX_RTMP_MAX_NAME);\n\n    name.len = ngx_strlen(v->name);\n    name.data = v->name;\n\n    pfmt = pmcf->fmts.elts;\n\n    for (n = 0; n < pmcf->fmts.nelts; ++n, ++pfmt) {\n        fmt = *pfmt;\n\n        pfx = &fmt->pfx;\n        sfx = &fmt->sfx;\n\n        if (pfx->len == 0 && ctx->fmt == NULL) {\n            ctx->fmt = fmt;\n        }\n\n        if (pfx->len && name.len >= pfx->len &&\n            ngx_strncasecmp(pfx->data, name.data, pfx->len) == 0)\n        {\n            ctx->pfx_size = pfx->len;\n            ctx->fmt = fmt;\n\n            break;\n        }\n\n        if (name.len >= sfx->len &&\n            ngx_strncasecmp(sfx->data, name.data + name.len - sfx->len,\n                            sfx->len) == 0)\n        {\n            ctx->fmt = fmt;\n        }\n    }\n\n    if (ctx->fmt == NULL) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"play: fmt not found\");\n        goto next;\n    }\n\n    ctx->file.fd = NGX_INVALID_FILE;\n    ctx->nentry = NGX_CONF_UNSET_UINT;\n    ctx->post_seek = NGX_CONF_UNSET_UINT;\n\n    sfx = &ctx->fmt->sfx;\n\n    if (name.len < sfx->len ||\n        ngx_strncasecmp(sfx->data, name.data + name.len - sfx->len,\n                        sfx->len))\n    {\n        ctx->sfx = *sfx;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: fmt=%V\", &ctx->fmt->name);\n\n    return ngx_rtmp_play_next_entry(s, v);\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_next_entry(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_play_app_conf_t   *pacf;\n    ngx_rtmp_play_ctx_t        *ctx;\n    ngx_rtmp_play_entry_t      *pe;\n    u_char                     *p;\n    static u_char               path[NGX_MAX_PATH + 1];\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    for ( ;; ) {\n\n        if (ctx->file.fd != NGX_INVALID_FILE) {\n            ngx_close_file(ctx->file.fd);\n            ctx->file.fd = NGX_INVALID_FILE;\n        }\n\n        if (ctx->file_id) {\n            ngx_rtmp_play_cleanup_local_file(s);\n        }\n\n        ctx->nentry = (ctx->nentry == NGX_CONF_UNSET_UINT ?\n                       0 : ctx->nentry + 1);\n\n        if (ctx->nentry >= pacf->entries.nelts) {\n            ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"play: all entries failed\");\n\n            ngx_rtmp_send_status(s, \"NetStream.Play.StreamNotFound\", \"error\",\n                                 \"Video on demand stream not found\");\n            break;\n        }\n\n        pe = ngx_rtmp_play_get_current_entry(s);\n\n        ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: trying %s entry %ui/%uz '%V'\",\n                       pe->url ? \"remote\" : \"local\",\n                       ctx->nentry + 1, pacf->entries.nelts,\n                       pe->url ? &pe->url->url : pe->root);\n\n        /* open remote */\n\n        if (pe->url) {\n            return ngx_rtmp_play_open_remote(s, v);\n        }\n\n        /* open local */\n\n        p = ngx_snprintf(path, NGX_MAX_PATH, \"%V/%s%V\",\n                         pe->root, v->name + ctx->pfx_size, &ctx->sfx);\n        *p = 0;\n\n        ctx->file.fd = ngx_open_file(path, NGX_FILE_RDONLY, NGX_FILE_OPEN,\n                                     NGX_FILE_DEFAULT_ACCESS);\n\n        if (ctx->file.fd == NGX_INVALID_FILE) {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, ngx_errno,\n                           \"play: error opening file '%s'\", path);\n            continue;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"play: open local file '%s'\", path);\n\n        if (ngx_rtmp_play_open(s, v->start) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        break;\n    }\n\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_open(ngx_rtmp_session_t *s, double start)\n{\n    ngx_rtmp_play_ctx_t    *ctx;\n    ngx_event_t            *e;\n    ngx_uint_t              timestamp;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx->file.fd == NGX_INVALID_FILE) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_send_stream_begin(s, NGX_RTMP_MSID) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_send_status(s, \"NetStream.Play.Start\", \"status\",\n                             \"Start video on demand\")\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_play_join(s) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    e = &ctx->send_evt;\n    e->data = s;\n    e->handler = ngx_rtmp_play_send;\n    e->log = s->connection->log;\n\n    ngx_rtmp_send_recorded(s, 1);\n\n    if (ngx_rtmp_send_sample_access(s) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_play_do_init(s) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    timestamp = ctx->post_seek != NGX_CONF_UNSET_UINT ? ctx->post_seek :\n                (start < 0 ? 0 : (ngx_uint_t) start);\n\n    if (ngx_rtmp_play_do_seek(s, timestamp) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (ngx_rtmp_play_do_start(s) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ctx->opened = 1;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_play_remote_create(ngx_rtmp_session_t *s, void *arg, ngx_pool_t *pool)\n{\n    ngx_rtmp_play_t                *v = arg;\n\n    ngx_rtmp_play_ctx_t            *ctx;\n    ngx_rtmp_play_entry_t          *pe;\n    ngx_str_t                      *addr_text, uri;\n    u_char                         *p, *name;\n    size_t                          args_len, name_len, len;\n    static ngx_str_t                text_plain = ngx_string(\"text/plain\");\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    pe = ngx_rtmp_play_get_current_entry(s);\n\n    name = v->name + ctx->pfx_size;\n\n    name_len = ngx_strlen(name);\n    args_len = ngx_strlen(v->args);\n    addr_text = &s->connection->addr_text;\n\n    len = pe->url->uri.len + 1 +\n          name_len + ctx->sfx.len +\n          sizeof(\"?addr=\") + addr_text->len * 3 +\n          1 + args_len;\n\n    uri.data = ngx_palloc(pool, len);\n    if (uri.data == NULL) {\n        return NULL;\n    }\n\n    p = uri.data;\n\n    p = ngx_cpymem(p, pe->url->uri.data, pe->url->uri.len);\n\n    if (p == uri.data || p[-1] != '/') {\n        *p++ = '/';\n    }\n\n    p = ngx_cpymem(p, name, name_len);\n    p = ngx_cpymem(p, ctx->sfx.data, ctx->sfx.len);\n    p = ngx_cpymem(p, (u_char*)\"?addr=\", sizeof(\"&addr=\") -1);\n    p = (u_char*)ngx_escape_uri(p, addr_text->data, addr_text->len,\n                                NGX_ESCAPE_ARGS);\n    if (args_len) {\n        *p++ = '&';\n        p = (u_char *) ngx_cpymem(p, v->args, args_len);\n    }\n\n    uri.len = p - uri.data;\n\n    return ngx_rtmp_netcall_http_format_request(NGX_RTMP_NETCALL_HTTP_GET,\n                                                &pe->url->host, &uri,\n                                                NULL, NULL, pool, &text_plain);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_remote_handle(ngx_rtmp_session_t *s, void *arg, ngx_chain_t *in)\n{\n    ngx_rtmp_play_t        *v = arg;\n\n    ngx_rtmp_play_ctx_t    *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    if (ctx->nbody == 0) {\n        return ngx_rtmp_play_next_entry(s, v);\n    }\n\n    if (ctx->file_id) {\n        ngx_rtmp_play_copy_local_file(s, v->name);\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: open remote file\");\n\n    if (ngx_rtmp_play_open(s, v->start) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    return next_play(s, (ngx_rtmp_play_t *)arg);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_remote_sink(ngx_rtmp_session_t *s, ngx_chain_t *in)\n{\n    ngx_rtmp_play_ctx_t    *ctx;\n    ngx_buf_t              *b;\n    ngx_int_t               rc;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    /* skip HTTP header */\n    while (in && ctx->ncrs != 2) {\n        b = in->buf;\n\n        for (; b->pos != b->last && ctx->ncrs != 2; ++b->pos) {\n            switch (*b->pos) {\n                case '\\n':\n                    ++ctx->ncrs;\n                case '\\r':\n                    break;\n                default:\n                    ctx->ncrs = 0;\n            }\n            /* 10th header byte is HTTP response header */\n            if (++ctx->nheader == 10 && *b->pos != (u_char) '2') {\n                ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                              \"play: remote HTTP response code: %cxx\",\n                              *b->pos);\n                return NGX_ERROR;\n            }\n        }\n\n        if (b->pos == b->last) {\n            in = in->next;\n        }\n    }\n\n    /* write to temp file */\n    for (; in; in = in->next) {\n        b = in->buf;\n\n        if (b->pos == b->last) {\n            continue;\n        }\n\n        rc = ngx_write_fd(ctx->file.fd, b->pos, b->last - b->pos);\n\n        if (rc == NGX_ERROR) {\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, ngx_errno,\n                          \"play: error writing to temp file\");\n            return NGX_ERROR;\n        }\n\n        ctx->nbody += rc;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_rtmp_play_entry_t *\nngx_rtmp_play_get_current_entry(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_app_conf_t   *pacf;\n    ngx_rtmp_play_ctx_t        *ctx;\n    ngx_rtmp_play_entry_t     **ppe;\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    ppe = pacf->entries.elts;\n\n    return ppe[ctx->nentry];\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_open_remote(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_play_app_conf_t       *pacf;\n    ngx_rtmp_play_ctx_t            *ctx;\n    ngx_rtmp_play_entry_t          *pe;\n    ngx_rtmp_netcall_init_t         ci;\n    u_char                         *path;\n    ngx_err_t                       err;\n    static ngx_uint_t               file_id;\n\n    pacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_play_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_play_module);\n\n    ctx->ncrs = 0;\n    ctx->nheader = 0;\n    ctx->nbody = 0;\n\n    for ( ;; ) {\n        ctx->file_id = ++file_id;\n\n        /* no zero after overflow */\n        if (ctx->file_id == 0) {\n            continue;\n        }\n\n        path = ngx_rtmp_play_get_local_file_path(s);\n\n        ctx->file.fd = ngx_open_tempfile(path, pacf->local_path.len, 0);\n\n        if (pacf->local_path.len == 0) {\n            ctx->file_id = 0;\n        }\n\n        if (ctx->file.fd != NGX_INVALID_FILE) {\n            break;\n        }\n\n        err = ngx_errno;\n\n        if (err != NGX_EEXIST) {\n            ctx->file_id = 0;\n\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, err,\n                          \"play: failed to create temp file\");\n\n            return NGX_ERROR;\n        }\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"play: temp file '%s' file_id=%ui\",\n                   path, ctx->file_id);\n\n    pe = ngx_rtmp_play_get_current_entry(s);\n\n    ngx_memzero(&ci, sizeof(ci));\n\n    ci.url = pe->url;\n    ci.create = ngx_rtmp_play_remote_create;\n    ci.sink   = ngx_rtmp_play_remote_sink;\n    ci.handle = ngx_rtmp_play_remote_handle;\n    ci.arg = v;\n    ci.argsize = sizeof(*v);\n\n    return ngx_rtmp_netcall_create(s, &ci);\n}\n\n\nstatic char *\nngx_rtmp_play_url(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_rtmp_play_app_conf_t       *pacf = conf;\n\n    ngx_rtmp_play_entry_t          *pe, **ppe;\n    ngx_str_t                       url;\n    ngx_url_t                      *u;\n    size_t                          add, n;\n    ngx_str_t                      *value;\n\n    if (pacf->entries.nalloc == 0 &&\n        ngx_array_init(&pacf->entries, cf->pool, 1, sizeof(void *)) != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    for (n = 1; n < cf->args->nelts; ++n) {\n\n        ppe = ngx_array_push(&pacf->entries);\n        if (ppe == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        pe = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_play_entry_t));\n        if (pe == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *ppe = pe;\n\n        if (ngx_strncasecmp(value[n].data, (u_char *) \"http://\", 7)) {\n\n            /* local file */\n\n            pe->root = ngx_palloc(cf->pool, sizeof(ngx_str_t));\n            if (pe->root == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            *pe->root = value[n];\n\n            continue;\n        }\n\n        /* http case */\n\n        url = value[n];\n\n        add = sizeof(\"http://\") - 1;\n\n        url.data += add;\n        url.len  -= add;\n\n        u = ngx_pcalloc(cf->pool, sizeof(ngx_url_t));\n        if (u == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        u->url.len = url.len;\n        u->url.data = url.data;\n        u->default_port = 80;\n        u->uri_part = 1;\n\n        if (ngx_parse_url(cf->pool, u) != NGX_OK) {\n            if (u->err) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                        \"%s in url \\\"%V\\\"\", u->err, &u->url);\n            }\n            return NGX_CONF_ERROR;\n        }\n\n        pe->url = u;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_play_postconfiguration(ngx_conf_t *cf)\n{\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_play_play;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_play_close_stream;\n\n    next_seek = ngx_rtmp_seek;\n    ngx_rtmp_seek = ngx_rtmp_play_seek;\n\n    next_pause = ngx_rtmp_pause;\n    ngx_rtmp_pause = ngx_rtmp_play_pause;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_play_module.h",
          "type": "blob",
          "size": 2.4765625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_PLAY_H_INCLUDED_\n#define _NGX_RTMP_PLAY_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n\n\ntypedef ngx_int_t (*ngx_rtmp_play_init_pt)  (ngx_rtmp_session_t *s,\n        ngx_file_t *f, ngx_int_t aindex, ngx_int_t vindex);\ntypedef ngx_int_t (*ngx_rtmp_play_done_pt)  (ngx_rtmp_session_t *s,\n        ngx_file_t *f);\ntypedef ngx_int_t (*ngx_rtmp_play_start_pt) (ngx_rtmp_session_t *s,\n        ngx_file_t *f);\ntypedef ngx_int_t (*ngx_rtmp_play_seek_pt)  (ngx_rtmp_session_t *s,\n        ngx_file_t *f, ngx_uint_t offs);\ntypedef ngx_int_t (*ngx_rtmp_play_stop_pt)  (ngx_rtmp_session_t *s,\n        ngx_file_t *f);\ntypedef ngx_int_t (*ngx_rtmp_play_send_pt)  (ngx_rtmp_session_t *s,\n        ngx_file_t *f, ngx_uint_t *ts);\n\n\ntypedef struct {\n    ngx_str_t               name;\n    ngx_str_t               pfx;\n    ngx_str_t               sfx;\n\n    ngx_rtmp_play_init_pt   init;\n    ngx_rtmp_play_done_pt   done;\n    ngx_rtmp_play_start_pt  start;\n    ngx_rtmp_play_seek_pt   seek;\n    ngx_rtmp_play_stop_pt   stop;\n    ngx_rtmp_play_send_pt   send;\n} ngx_rtmp_play_fmt_t;\n\n\ntypedef struct ngx_rtmp_play_ctx_s ngx_rtmp_play_ctx_t;\n\n\nstruct ngx_rtmp_play_ctx_s {\n    ngx_rtmp_session_t     *session;\n    ngx_file_t              file;\n    ngx_rtmp_play_fmt_t    *fmt;\n    ngx_event_t             send_evt;\n    unsigned                playing:1;\n    unsigned                opened:1;\n    unsigned                joined:1;\n    ngx_uint_t              ncrs;\n    ngx_uint_t              nheader;\n    ngx_uint_t              nbody;\n    size_t                  pfx_size;\n    ngx_str_t               sfx;\n    ngx_uint_t              file_id;\n    ngx_int_t               aindex, vindex;\n    ngx_uint_t              nentry;\n    ngx_uint_t              post_seek;\n    u_char                  name[NGX_RTMP_MAX_NAME];\n    ngx_rtmp_play_ctx_t    *next;\n};\n\n\ntypedef struct {\n    ngx_str_t              *root;\n    ngx_url_t              *url;\n} ngx_rtmp_play_entry_t;\n\n\ntypedef struct {\n    ngx_str_t               temp_path;\n    ngx_str_t               local_path;\n    ngx_array_t             entries; /* ngx_rtmp_play_entry_t * */\n    ngx_uint_t              nbuckets;\n    ngx_rtmp_play_ctx_t   **ctx;\n} ngx_rtmp_play_app_conf_t;\n\n\ntypedef struct {\n    ngx_array_t             fmts; /* ngx_rtmp_play_fmt_t * */\n} ngx_rtmp_play_main_conf_t;\n\n\nextern ngx_module_t         ngx_rtmp_play_module;\n\n\n#endif /* _NGX_RTMP_PLAY_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_proxy_protocol.c",
          "type": "blob",
          "size": 3.78125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <nginx.h>\n#include \"ngx_rtmp_proxy_protocol.h\"\n\n\nstatic void ngx_rtmp_proxy_protocol_recv(ngx_event_t *rev);\n\n\nvoid\nngx_rtmp_proxy_protocol(ngx_rtmp_session_t *s)\n{\n    ngx_event_t       *rev;\n    ngx_connection_t  *c;\n\n    c = s->connection;\n    rev = c->read;\n    rev->handler =  ngx_rtmp_proxy_protocol_recv;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"proxy_protocol: start\");\n\n    if (rev->ready) {\n        /* the deferred accept(), rtsig, aio, iocp */\n\n        if (ngx_use_accept_mutex) {\n            ngx_post_event(rev, &ngx_posted_events);\n            return;\n        }\n\n        rev->handler(rev);\n        return;\n    }\n\n    ngx_add_timer(rev, s->timeout);\n\n    if (ngx_handle_read_event(rev, 0) != NGX_OK) {\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n}\n\n\nstatic void\nngx_rtmp_proxy_protocol_recv(ngx_event_t *rev)\n{\n    u_char               buf[107], *p, *pp, *text;\n    size_t               len;\n    ssize_t              n;\n    ngx_err_t            err;\n    ngx_int_t            i;\n    ngx_addr_t           addr;\n    ngx_connection_t    *c;\n    ngx_rtmp_session_t  *s;\n\n    c = rev->data;\n    s = c->data;\n\n    if (c->destroyed) {\n        return;\n    }\n\n    if (rev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT,\n                \"proxy_protocol: recv: client timed out\");\n        c->timedout = 1;\n        ngx_rtmp_finalize_session(s);\n        return;\n    }\n\n    if (rev->timer_set) {\n        ngx_del_timer(rev);\n    }\n\n    n = recv(c->fd, (char *) buf, sizeof(buf), MSG_PEEK);\n\n    err = ngx_socket_errno;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, c->log, 0, \"recv(): %d\", n);\n\n    if (n == -1) {\n\n        if (err == NGX_EAGAIN) {\n            ngx_add_timer(rev, s->timeout);\n\n            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n                ngx_rtmp_finalize_session(s);\n            }\n\n            return;\n        }\n\n        ngx_rtmp_finalize_session(s);\n\n        return;\n    }\n\n    p = buf;\n\n    if (n <= 8 && ngx_strncmp(p, \"PROXY \", 6) != 0) {\n        goto bad_header;\n    }\n\n    n -= 6;\n    p += 6;\n\n    ngx_memzero(&addr, sizeof(ngx_addr_t));\n\n    if (n >= 7 && ngx_strncmp(p, \"UNKNOWN\", 7) == 0) {\n        n -= 7;\n        p += 7;\n        goto skip;\n    }\n\n    if (n < 5 || ngx_strncmp(p, \"TCP\", 3) != 0\n        || (p[3] != '4' && p[3] != '6') || p[4] != ' ')\n    {\n        goto bad_header;\n    }\n\n    n -= 5;\n    p += 5;\n\n    pp = ngx_strlchr(p, p + n, ' ');\n\n    if (pp == NULL) {\n        goto bad_header;\n    }\n\n    if (ngx_parse_addr(s->connection->pool, &addr, p, pp - p) != NGX_OK) {\n        goto bad_header;\n    }\n\n    n -= pp - p;\n    p = pp;\n\nskip:\n\n    for (i = 0; i + 1 < n; i++) {\n        if (p[i] == CR && p[i + 1] == LF) {\n            break;\n        }\n    }\n\n    if (i + 1 >= n) {\n        goto bad_header;\n    }\n\n    n = p - buf + i + 2;\n\n    if (c->recv(c, buf, n) != n) {\n        goto failed;\n    }\n\n    if (addr.socklen) {\n        text = ngx_palloc(s->connection->pool, NGX_SOCKADDR_STRLEN);\n\n        if (text == NULL) {\n            goto failed;\n        }\n\n        len = ngx_sock_ntop(addr.sockaddr,\n#if (nginx_version >= 1005003)\n                            addr.socklen,\n#endif\n                            text, NGX_SOCKADDR_STRLEN, 0);\n        if (len == 0) {\n            goto failed;\n        }\n\n        c->sockaddr = addr.sockaddr;\n        c->socklen = addr.socklen;\n        c->addr_text.data = text;\n        c->addr_text.len = len;\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, c->log, 0,\n                       \"proxy_protocol: remote_addr:'%V'\", &c->addr_text);\n    }\n\n    ngx_rtmp_handshake(s);\n\n    return;\n\nbad_header:\n\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, \"proxy_protocol: bad header\");\n\nfailed:\n\n    ngx_rtmp_finalize_session(s);\n}\n"
        },
        {
          "name": "ngx_rtmp_proxy_protocol.h",
          "type": "blob",
          "size": 0.3037109375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_PROXY_PROTOCOL_H_INCLUDED_\n#define _NGX_RTMP_PROXY_PROTOCOL_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\nvoid ngx_rtmp_proxy_protocol(ngx_rtmp_session_t *c);\n\n\n#endif /* _NGX_RTMP_PROXY_PROTOCOL_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_receive.c",
          "type": "blob",
          "size": 11.921875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_amf.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include <string.h>\n\n\nngx_int_t\nngx_rtmp_protocol_message_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in)\n{\n    ngx_buf_t              *b;\n    uint32_t                val;\n    uint8_t                 limit;\n\n    b = in->buf;\n\n    if (b->last - b->pos < 4) {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"too small buffer for %d message: %d\",\n                (int)h->type, b->last - b->pos);\n        return NGX_OK;\n    }\n\n    val = ntohl(*(uint32_t *) b->pos);\n\n    switch(h->type) {\n        case NGX_RTMP_MSG_CHUNK_SIZE:\n            /* set chunk size =val */\n            ngx_rtmp_set_chunk_size(s, val);\n            break;\n\n        case NGX_RTMP_MSG_ABORT:\n            /* abort chunk stream =val */\n            break;\n\n        case NGX_RTMP_MSG_ACK:\n            /* receive ack with sequence number =val */\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"receive ack seq=%uD\", val);\n            break;\n\n        case NGX_RTMP_MSG_ACK_SIZE:\n            /* receive window size =val */\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"receive ack_size=%uD\", val);\n            s->ack_size = val;\n            break;\n\n        case NGX_RTMP_MSG_BANDWIDTH:\n            if (b->last - b->pos >= 5) {\n                limit = *(uint8_t*)&b->pos[4];\n\n                (void)val;\n                (void)limit;\n\n                ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                    \"receive bandwidth=%uD limit=%d\",\n                    val, (int)limit);\n\n                /* receive window size =val\n                 * && limit */\n            }\n            break;\n\n        default:\n            return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_user_message_handler(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                              ngx_chain_t *in)\n{\n    ngx_buf_t              *b;\n    uint16_t                evt;\n    uint32_t                val;\n\n    b = in->buf;\n\n    if (b->last - b->pos < 6) {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"too small buffer for user message: %d\",\n                       b->last - b->pos);\n        return NGX_OK;\n    }\n\n    evt = ntohs(*(uint16_t *) b->pos);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"RTMP recv user evt %s (%i)\",\n                   ngx_rtmp_user_message_type(evt), (ngx_int_t) evt);\n\n    val = ntohl(*(uint32_t *) (b->pos + 2));\n\n    switch(evt) {\n        case NGX_RTMP_USER_STREAM_BEGIN:\n            {\n                ngx_rtmp_stream_begin_t     v;\n\n                v.msid = val;\n\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"receive: stream_begin msid=%uD\", v.msid);\n\n                return ngx_rtmp_stream_begin(s, &v);\n            }\n\n        case NGX_RTMP_USER_STREAM_EOF:\n            {\n                ngx_rtmp_stream_eof_t       v;\n\n                v.msid = val;\n\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"receive: stream_eof msid=%uD\", v.msid);\n\n                return ngx_rtmp_stream_eof(s, &v);\n            }\n\n        case NGX_RTMP_USER_STREAM_DRY:\n            {\n                ngx_rtmp_stream_dry_t       v;\n\n                v.msid = val;\n\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"receive: stream_dry msid=%uD\", v.msid);\n\n                return ngx_rtmp_stream_dry(s, &v);\n            }\n\n        case NGX_RTMP_USER_SET_BUFLEN:\n            {\n                ngx_rtmp_set_buflen_t       v;\n\n                v.msid = val;\n\n                if (b->last - b->pos < 10) {\n                    return NGX_OK;\n                }\n\n                v.buflen = ntohl(*(uint32_t *) (b->pos + 6));\n\n                ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"receive: set_buflen msid=%uD buflen=%uD\",\n                               v.msid, v.buflen);\n\n                /*TODO: move this to play module */\n                s->buflen = v.buflen;\n\n                return ngx_rtmp_set_buflen(s, &v);\n            }\n\n        case NGX_RTMP_USER_RECORDED:\n            {\n                ngx_rtmp_recorded_t       v;\n\n                v.msid = val;\n\n                ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                               \"receive: recorded msid=%uD\", v.msid);\n\n                return ngx_rtmp_recorded(s, &v);\n            }\n\n        case NGX_RTMP_USER_PING_REQUEST:\n            return ngx_rtmp_send_ping_response(s, val);\n\n        case NGX_RTMP_USER_PING_RESPONSE:\n\n            /* val = incoming timestamp */\n\n            ngx_rtmp_reset_ping(s);\n\n            return NGX_OK;\n\n        default:\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"unexpected user event: %i\", (ngx_int_t) evt);\n\n            return NGX_OK;\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_fetch(ngx_chain_t **in, u_char *ret)\n{\n    while (*in && (*in)->buf->pos >= (*in)->buf->last) {\n        *in = (*in)->next;\n    }\n\n    if (*in == NULL) {\n        return NGX_DONE;\n    }\n\n    *ret = *(*in)->buf->pos++;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_fetch_uint8(ngx_chain_t **in, uint8_t *ret)\n{\n    return ngx_rtmp_fetch(in, (u_char *) ret);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_fetch_uint32(ngx_chain_t **in, uint32_t *ret, ngx_int_t n)\n{\n    u_char      r;\n    ngx_int_t   rc;\n    uint32_t    val;\n\n    *ret = 0;\n    val = 0;\n\n    while (--n >= 0) {\n        rc = ngx_rtmp_fetch(in, &r);\n        if (rc != NGX_OK) {\n            return rc;\n        }\n\n        val = (val << 8) | r;\n    }\n\n    *ret = val;\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_aggregate_message_handler(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                                   ngx_chain_t *in)\n{\n    uint32_t            base_time, timestamp, prev_size;\n    size_t              len;\n    ngx_int_t           first;\n    u_char             *last;\n    ngx_int_t           rc;\n    ngx_buf_t          *b;\n    ngx_chain_t        *cl, *next;\n    ngx_rtmp_header_t   ch;\n\n    ch = *h;\n\n    first = 1;\n    base_time = 0;\n\n    while (in) {\n        if (ngx_rtmp_fetch_uint8(&in, &ch.type) != NGX_OK) {\n            return NGX_OK;\n        }\n\n        if (ngx_rtmp_fetch_uint32(&in, &ch.mlen, 3) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_rtmp_fetch_uint32(&in, &timestamp, 3) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_rtmp_fetch_uint8(&in, (uint8_t *) &timestamp + 3) != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        if (ngx_rtmp_fetch_uint32(&in, &ch.msid, 3) != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n        if (first) {\n            base_time = timestamp;\n            first = 0;\n        }\n\n        ngx_log_debug6(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"RTMP aggregate %s (%d) len=%uD time=%uD (+%D) msid=%uD\",\n                       ngx_rtmp_message_type(ch.type),\n                       (ngx_int_t) ch.type, ch.mlen, ch.timestamp,\n                       timestamp - base_time, ch.msid);\n\n        /* limit chain */\n\n        len = 0;\n        cl = in;\n        while (cl) {\n            b = cl->buf;\n            len += (b->last - b->pos);\n            if (len > ch.mlen) {\n                break;\n            }\n            cl = cl->next;\n        }\n\n        if (cl == NULL) {\n            ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n                          \"RTMP error parsing aggregate\");\n            return NGX_ERROR;\n        }\n\n        next = cl->next;\n        cl->next = NULL;\n        b = cl->buf;\n        last = b->last;\n        b->last -= (len - ch.mlen);\n\n        /* handle aggregated message */\n\n        ch.timestamp = h->timestamp + timestamp - base_time;\n\n        rc = ngx_rtmp_receive_message(s, &ch, in);\n\n        /* restore chain before checking the result */\n\n        in = cl;\n        in->next = next;\n        b->pos = b->last;\n        b->last = last;\n\n        if (rc != NGX_OK) {\n            return rc;\n        }\n\n        /* read 32-bit previous tag size */\n\n        if (ngx_rtmp_fetch_uint32(&in, &prev_size, 4) != NGX_OK) {\n            return NGX_OK;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"RTMP aggregate prev_size=%uD\", prev_size);\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_amf_message_handler(ngx_rtmp_session_t *s,\n        ngx_rtmp_header_t *h, ngx_chain_t *in)\n{\n    ngx_rtmp_amf_ctx_t          act;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n    ngx_array_t                *ch;\n    ngx_rtmp_handler_pt        *ph;\n    ngx_chain_t                *cl;\n    ngx_int_t                   amf_len;\n    size_t                      len, n;\n\n    static u_char               func[128];\n\n    static ngx_rtmp_amf_elt_t   elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          func,   sizeof(func) },\n    };\n\n    /* AMF command names come with string type, but shared object names\n     * come without type */\n    if (h->type == NGX_RTMP_MSG_AMF_SHARED ||\n        h->type == NGX_RTMP_MSG_AMF3_SHARED)\n    {\n        elts[0].type |= NGX_RTMP_AMF_TYPELESS;\n    } else {\n        elts[0].type &= ~NGX_RTMP_AMF_TYPELESS;\n    }\n\n    if ((h->type == NGX_RTMP_MSG_AMF3_SHARED ||\n         h->type == NGX_RTMP_MSG_AMF3_META ||\n         h->type == NGX_RTMP_MSG_AMF3_CMD)\n         && in->buf->last > in->buf->pos)\n    {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"AMF3 prefix: %ui\", (ngx_int_t)*in->buf->pos);\n        ++in->buf->pos;\n    }\n\n    cmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_core_module);\n\n    /*\n     * work around the buggy option `-map` in FFmpeg, see:\n     * https://trac.ffmpeg.org/ticket/10565\n     */\n    if (in->buf->pos[0] == NGX_RTMP_AMF_NUMBER) {\n        cl = in;\n        amf_len = 0;\n\n        while (cl) {\n            amf_len += cl->buf->last - cl->buf->pos;\n            /* type: 1B, number payload: 8B */\n            if (amf_len >= 9) {\n                break;\n            }\n\n            cl = cl->next;\n        }\n\n        if (amf_len < 9) {\n            ngx_log_error(NGX_LOG_WARN, s->connection->log, 0,\n                          \"AMF malformed: type=%d, length=%D, ignored\",\n                          NGX_RTMP_AMF_NUMBER, amf_len);\n            return NGX_OK;\n        }\n    }\n\n    /* read AMF func name & transaction id */\n    ngx_memzero(&act, sizeof(act));\n    act.link = in;\n    act.log = s->connection->log;\n    memset(func, 0, sizeof(func));\n\n    if (ngx_rtmp_amf_read(&act, elts,\n                sizeof(elts) / sizeof(elts[0])) != NGX_OK)\n    {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"AMF cmd failed\");\n        return NGX_ERROR;\n    }\n\n    /* skip name */\n    in = act.link;\n    in->buf->pos += act.offset;\n\n    len = ngx_strlen(func);\n\n    ch = ngx_hash_find(&cmcf->amf_hash,\n            ngx_hash_strlow(func, func, len), func, len);\n\n    if (ch && ch->nelts) {\n        ph = ch->elts;\n        for (n = 0; n < ch->nelts; ++n, ++ph) {\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                \"AMF func '%s' passed to handler %d/%d\",\n                func, n, ch->nelts);\n            switch ((*ph)(s, h, in)) {\n                case NGX_ERROR:\n                    return NGX_ERROR;\n                case NGX_DONE:\n                    return NGX_OK;\n            }\n        }\n    } else {\n        ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"AMF cmd '%s' no handler\", func);\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_receive_amf(ngx_rtmp_session_t *s, ngx_chain_t *in,\n        ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    ngx_rtmp_amf_ctx_t     act;\n\n    ngx_memzero(&act, sizeof(act));\n    act.link = in;\n    act.log = s->connection->log;\n\n    return ngx_rtmp_amf_read(&act, elts, nelts);\n}\n"
        },
        {
          "name": "ngx_rtmp_record_module.c",
          "type": "blob",
          "size": 35.7314453125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_netcall_module.h\"\n#include \"ngx_rtmp_codec_module.h\"\n#include \"ngx_rtmp_record_module.h\"\n\n\nngx_rtmp_record_done_pt             ngx_rtmp_record_done;\n\n\nstatic ngx_rtmp_publish_pt          next_publish;\nstatic ngx_rtmp_close_stream_pt     next_close_stream;\nstatic ngx_rtmp_stream_begin_pt     next_stream_begin;\nstatic ngx_rtmp_stream_eof_pt       next_stream_eof;\n\n\nstatic char *ngx_rtmp_record_recorder(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic ngx_int_t ngx_rtmp_record_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_record_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_record_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\nstatic ngx_int_t ngx_rtmp_record_write_frame(ngx_rtmp_session_t *s,\n       ngx_rtmp_record_rec_ctx_t *rctx,\n       ngx_rtmp_header_t *h, ngx_chain_t *in, ngx_int_t inc_nframes);\nstatic ngx_int_t ngx_rtmp_record_av(ngx_rtmp_session_t *s,\n       ngx_rtmp_header_t *h, ngx_chain_t *in);\nstatic ngx_int_t ngx_rtmp_record_node_av(ngx_rtmp_session_t *s,\n       ngx_rtmp_record_rec_ctx_t *rctx, ngx_rtmp_header_t *h, ngx_chain_t *in);\nstatic ngx_int_t ngx_rtmp_record_node_open(ngx_rtmp_session_t *s,\n       ngx_rtmp_record_rec_ctx_t *rctx);\nstatic ngx_int_t ngx_rtmp_record_node_close(ngx_rtmp_session_t *s,\n       ngx_rtmp_record_rec_ctx_t *rctx);\nstatic void  ngx_rtmp_record_make_path(ngx_rtmp_session_t *s,\n       ngx_rtmp_record_rec_ctx_t *rctx, ngx_str_t *path);\nstatic ngx_int_t ngx_rtmp_record_init(ngx_rtmp_session_t *s);\nstatic ngx_int_t ngx_rtmp_record_init_ctx(ngx_rtmp_session_t *s);\n\n\nstatic ngx_conf_bitmask_t  ngx_rtmp_record_mask[] = {\n    { ngx_string(\"off\"),                NGX_RTMP_RECORD_OFF         },\n    { ngx_string(\"all\"),                NGX_RTMP_RECORD_AUDIO       |\n                                        NGX_RTMP_RECORD_VIDEO       },\n    { ngx_string(\"audio\"),              NGX_RTMP_RECORD_AUDIO       },\n    { ngx_string(\"video\"),              NGX_RTMP_RECORD_VIDEO       },\n    { ngx_string(\"keyframes\"),          NGX_RTMP_RECORD_KEYFRAMES   },\n    { ngx_string(\"manual\"),             NGX_RTMP_RECORD_MANUAL      },\n    { ngx_null_string,                  0                           }\n};\n\n\nstatic ngx_command_t  ngx_rtmp_record_commands[] = {\n\n    { ngx_string(\"record\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_1MORE,\n      ngx_conf_set_bitmask_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, flags),\n      ngx_rtmp_record_mask },\n\n    { ngx_string(\"record_path\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, path),\n      NULL },\n\n    { ngx_string(\"record_suffix\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, suffix),\n      NULL },\n\n    { ngx_string(\"record_unique\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, unique),\n      NULL },\n\n    { ngx_string(\"record_append\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, append),\n      NULL },\n\n    { ngx_string(\"record_lock\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, lock_file),\n      NULL },\n\n    { ngx_string(\"record_max_size\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, max_size),\n      NULL },\n\n    { ngx_string(\"record_max_frames\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, max_frames),\n      NULL },\n\n    { ngx_string(\"record_interval\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, interval),\n      NULL },\n\n    { ngx_string(\"record_notify\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|\n                         NGX_RTMP_REC_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_record_app_conf_t, notify),\n      NULL },\n\n    { ngx_string(\"recorder\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE1,\n      ngx_rtmp_record_recorder,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_record_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_record_postconfiguration,      /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_record_create_app_conf,        /* create app configuration */\n    ngx_rtmp_record_merge_app_conf          /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_record_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_record_module_ctx,            /* module context */\n    ngx_rtmp_record_commands,               /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    NULL,                                   /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic void *\nngx_rtmp_record_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_record_app_conf_t      *racf;\n\n    racf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_record_app_conf_t));\n\n    if (racf == NULL) {\n        return NULL;\n    }\n\n    racf->max_size = NGX_CONF_UNSET_SIZE;\n    racf->max_frames = NGX_CONF_UNSET_SIZE;\n    racf->interval = NGX_CONF_UNSET_MSEC;\n    racf->unique = NGX_CONF_UNSET;\n    racf->append = NGX_CONF_UNSET;\n    racf->lock_file = NGX_CONF_UNSET;\n    racf->notify = NGX_CONF_UNSET;\n    racf->url = NGX_CONF_UNSET_PTR;\n\n    if (ngx_array_init(&racf->rec, cf->pool, 1, sizeof(void *)) != NGX_OK) {\n        return NULL;\n    }\n\n    return racf;\n}\n\n\nstatic char *\nngx_rtmp_record_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_record_app_conf_t     *prev = parent;\n    ngx_rtmp_record_app_conf_t     *conf = child;\n    ngx_rtmp_record_app_conf_t    **rracf;\n\n    ngx_conf_merge_str_value(conf->path, prev->path, \"\");\n    ngx_conf_merge_str_value(conf->suffix, prev->suffix, \".flv\");\n    ngx_conf_merge_size_value(conf->max_size, prev->max_size, 0);\n    ngx_conf_merge_size_value(conf->max_frames, prev->max_frames, 0);\n    ngx_conf_merge_value(conf->unique, prev->unique, 0);\n    ngx_conf_merge_value(conf->append, prev->append, 0);\n    ngx_conf_merge_value(conf->lock_file, prev->lock_file, 0);\n    ngx_conf_merge_value(conf->notify, prev->notify, 0);\n    ngx_conf_merge_msec_value(conf->interval, prev->interval,\n                              (ngx_msec_t) NGX_CONF_UNSET_MSEC);\n    ngx_conf_merge_bitmask_value(conf->flags, prev->flags, 0);\n    ngx_conf_merge_ptr_value(conf->url, prev->url, NULL);\n\n    if (conf->flags) {\n        rracf = ngx_array_push(&conf->rec);\n        if (rracf == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *rracf = conf;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_write_header(ngx_file_t *file)\n{\n    static u_char       flv_header[] = {\n        0x46, /* 'F' */\n        0x4c, /* 'L' */\n        0x56, /* 'V' */\n        0x01, /* version = 1 */\n        0x05, /* 00000 1 0 1 = has audio & video */\n        0x00,\n        0x00,\n        0x00,\n        0x09, /* header size */\n        0x00,\n        0x00,\n        0x00,\n        0x00  /* PreviousTagSize0 (not actually a header) */\n    };\n\n    return ngx_write_file(file, flv_header, sizeof(flv_header), 0) == NGX_ERROR\n           ? NGX_ERROR\n           : NGX_OK;\n}\n\n\nstatic ngx_rtmp_record_rec_ctx_t *\nngx_rtmp_record_get_node_ctx(ngx_rtmp_session_t *s, ngx_uint_t n)\n{\n    ngx_rtmp_record_ctx_t          *ctx;\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n\n    if (ngx_rtmp_record_init(s) != NGX_OK) {\n        return NULL;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n\n    if (n >= ctx->rec.nelts) {\n        return NULL;\n    }\n\n    rctx = ctx->rec.elts;\n\n    return &rctx[n];\n}\n\n\nngx_int_t\nngx_rtmp_record_open(ngx_rtmp_session_t *s, ngx_uint_t n, ngx_str_t *path)\n{\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n    ngx_int_t                       rc;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: #%ui manual open\", n);\n\n    rctx = ngx_rtmp_record_get_node_ctx(s, n);\n\n    if (rctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    rc = ngx_rtmp_record_node_open(s, rctx);\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    if (path) {\n        ngx_rtmp_record_make_path(s, rctx, path);\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_record_close(ngx_rtmp_session_t *s, ngx_uint_t n, ngx_str_t *path)\n{\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n    ngx_int_t                       rc;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: #%ui manual close\", n);\n\n    rctx = ngx_rtmp_record_get_node_ctx(s, n);\n\n    if (rctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    rc = ngx_rtmp_record_node_close(s, rctx);\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    if (path) {\n        ngx_rtmp_record_make_path(s, rctx, path);\n    }\n\n    return NGX_OK;\n}\n\n\nngx_uint_t\nngx_rtmp_record_find(ngx_rtmp_record_app_conf_t *racf, ngx_str_t *id)\n{\n    ngx_rtmp_record_app_conf_t    **pracf, *rracf;\n    ngx_uint_t                      n;\n\n    pracf = racf->rec.elts;\n\n    for (n = 0; n < racf->rec.nelts; ++n, ++pracf) {\n        rracf = *pracf;\n\n        if (rracf->id.len == id->len &&\n            ngx_strncmp(rracf->id.data, id->data, id->len) == 0)\n        {\n            return n;\n        }\n    }\n\n    return NGX_CONF_UNSET_UINT;\n}\n\n\nvoid\nngx_rtmp_record_get_path(ngx_rtmp_session_t *s,\n    ngx_rtmp_record_rec_ctx_t *rctx, ngx_str_t *path)\n{\n    ngx_rtmp_record_make_path(s, rctx, path);\n}\n\n\n/* This funcion returns pointer to a static buffer */\nstatic void\nngx_rtmp_record_make_path(ngx_rtmp_session_t *s,\n                          ngx_rtmp_record_rec_ctx_t *rctx, ngx_str_t *path)\n{\n    ngx_rtmp_record_ctx_t          *ctx;\n    ngx_rtmp_record_app_conf_t     *rracf;\n    u_char                         *p, *l;\n    struct tm                       tm;\n\n    static u_char                   buf[NGX_TIME_T_LEN + 1];\n    static u_char                   pbuf[NGX_MAX_PATH + 1];\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n\n    rracf = rctx->conf;\n\n    /* create file path */\n    p = pbuf;\n    l = pbuf + sizeof(pbuf) - 1;\n\n    p = ngx_cpymem(p, rracf->path.data,\n                ngx_min(rracf->path.len, (size_t)(l - p - 1)));\n    *p++ = '/';\n    p = (u_char *)ngx_escape_uri(p, ctx->name, ngx_min(ngx_strlen(ctx->name),\n                (size_t)(l - p)), NGX_ESCAPE_URI_COMPONENT);\n\n    /* append timestamp */\n    if (rracf->unique) {\n        p = ngx_cpymem(p, buf, ngx_min(ngx_sprintf(buf, \"-%T\",\n                       rctx->timestamp) - buf, l - p));\n    }\n\n    if (ngx_strchr(rracf->suffix.data, '%')) {\n        ngx_libc_localtime(rctx->timestamp, &tm);\n        p += strftime((char *) p, l - p, (char *) rracf->suffix.data, &tm);\n    } else {\n        p = ngx_cpymem(p, rracf->suffix.data,\n                ngx_min(rracf->suffix.len, (size_t)(l - p)));\n    }\n\n    *p = 0;\n    path->data = pbuf;\n    path->len  = p - pbuf;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: %V path: '%V'\", &rracf->id, path);\n}\n\n\nstatic void\nngx_rtmp_record_notify_error(ngx_rtmp_session_t *s,\n                             ngx_rtmp_record_rec_ctx_t *rctx)\n{\n    ngx_rtmp_record_app_conf_t *rracf = rctx->conf;\n\n    rctx->failed = 1;\n\n    if (!rracf->notify) {\n        return;\n    }\n\n    ngx_rtmp_send_status(s, \"NetStream.Record.Failed\", \"error\",\n                         rracf->id.data ? (char *) rracf->id.data : \"\");\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_node_open(ngx_rtmp_session_t *s,\n                          ngx_rtmp_record_rec_ctx_t *rctx)\n{\n    ngx_rtmp_record_app_conf_t  *rracf;\n    ngx_err_t                    err;\n    ngx_str_t                    path;\n    ngx_int_t                    mode, create_mode;\n    u_char                      *p, buf[8];\n    off_t                        file_size;\n    uint32_t                     tag_size, mlen, timestamp;\n\n    rracf = rctx->conf;\n    tag_size = 0;\n    p = buf;\n\n    if (rctx->file.fd != NGX_INVALID_FILE) {\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: %V opening\", &rracf->id);\n\n    ngx_memzero(rctx, sizeof(*rctx));\n    rctx->conf = rracf;\n    rctx->last = *ngx_cached_time;\n    rctx->timestamp = ngx_cached_time->sec;\n\n    ngx_rtmp_record_make_path(s, rctx, &path);\n\n    mode = rracf->append ? NGX_FILE_RDWR : NGX_FILE_WRONLY;\n    create_mode = rracf->append ? NGX_FILE_CREATE_OR_OPEN : NGX_FILE_TRUNCATE;\n\n    ngx_memzero(&rctx->file, sizeof(rctx->file));\n    rctx->file.offset = 0;\n    rctx->file.log = s->connection->log;\n    rctx->file.fd = ngx_open_file(path.data, mode, create_mode,\n                                  NGX_FILE_DEFAULT_ACCESS);\n    ngx_str_set(&rctx->file.name, \"recorded\");\n\n    if (rctx->file.fd == NGX_INVALID_FILE) {\n        err = ngx_errno;\n\n        if (err != NGX_ENOENT) {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, err,\n                          \"record: %V failed to open file '%V'\",\n                          &rracf->id, &path);\n        }\n\n        ngx_rtmp_record_notify_error(s, rctx);\n\n        return NGX_OK;\n    }\n\n#if !(NGX_WIN32)\n    if (rracf->lock_file) {\n        err = ngx_lock_fd(rctx->file.fd);\n        if (err) {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, err,\n                          \"record: %V lock failed\", &rracf->id);\n        }\n    }\n#endif\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: %V opened '%V'\", &rracf->id, &path);\n\n    if (rracf->notify) {\n        ngx_rtmp_send_status(s, \"NetStream.Record.Start\", \"status\",\n                             rracf->id.data ? (char *) rracf->id.data : \"\");\n    }\n\n    if (rracf->append) {\n        mlen = 0;\n        file_size = 0;\n        timestamp = 0;\n\n#if (NGX_WIN32)\n        {\n            LONG  lo, hi;\n\n            lo = 0;\n            hi = 0;\n            lo = SetFilePointer(rctx->file.fd, lo, &hi, FILE_END);\n            file_size = (lo == INVALID_SET_FILE_POINTER ?\n                         (off_t) -1 : (off_t) hi << 32 | (off_t) lo);\n        }\n#else\n        file_size = lseek(rctx->file.fd, 0, SEEK_END);\n#endif\n        if (file_size == (off_t) -1) {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, ngx_errno,\n                          \"record: %V seek failed\", &rracf->id);\n            goto done;\n        }\n\n        if (file_size < 4) {\n            goto done;\n        }\n\n        if (ngx_read_file(&rctx->file, p, 4, file_size - 4) != 4) {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, ngx_errno,\n                          \"record: %V tag size read failed\", &rracf->id);\n            goto done;\n        }\n\n        tag_size = ntohl(*(uint32_t *) p);\n\n        if (tag_size == 0 || tag_size + 4 > file_size) {\n            file_size = 0;\n            goto done;\n        }\n\n        if (ngx_read_file(&rctx->file, p, 8, file_size - tag_size - 4) != 8)\n        {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, ngx_errno,\n                          \"record: %V tag read failed\", &rracf->id);\n            goto done;\n        }\n\n        mlen = ngx_rtmp_n3_to_h4(p + 1);\n\n        if (tag_size != mlen + 11) {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, ngx_errno,\n                          \"record: %V tag size mismatch: \"\n                          \"tag_size=%uD, mlen=%uD\", &rracf->id, tag_size, mlen);\n            goto done;\n        }\n\n        timestamp = ngx_rtmp_n3_to_h4(p + 4);\n        timestamp |= ((uint32_t) p[7] << 24);\n\ndone:\n        rctx->file.offset = file_size;\n        rctx->time_shift = timestamp;\n\n        ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"record: append offset=%O, time=%uD, tag_size=%uD\",\n                       file_size, timestamp, tag_size);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_init(ngx_rtmp_session_t *s)\n{\n    ngx_uint_t                      n;\n    ngx_rtmp_record_app_conf_t     *racf, **rracf;\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n    ngx_rtmp_record_ctx_t          *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n\n    if (ctx && !s->auto_pushed) {\n        return NGX_OK;\n    }\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_record_module);\n\n    if (racf == NULL || racf->rec.nelts == 0) {\n        return NGX_OK;\n    }\n\n    if (ngx_rtmp_record_init_ctx(s) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n\n    if (ngx_array_init(&ctx->rec, s->connection->pool, racf->rec.nelts,\n                       sizeof(ngx_rtmp_record_rec_ctx_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    rracf = racf->rec.elts;\n\n    rctx = ngx_array_push_n(&ctx->rec, racf->rec.nelts);\n\n    if (rctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    for (n = 0; n < racf->rec.nelts; ++n, ++rracf, ++rctx) {\n        ngx_memzero(rctx, sizeof(*rctx));\n\n        rctx->conf = *rracf;\n        rctx->file.fd = NGX_INVALID_FILE;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_init_ctx(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_record_ctx_t  *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_record_ctx_t));\n\n        if (ctx == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_record_module);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_record_start(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_record_app_conf_t     *racf;\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n    ngx_rtmp_record_ctx_t          *ctx;\n    ngx_uint_t                      n;\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_record_module);\n    if (racf == NULL || racf->rec.nelts == 0) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: start\");\n\n    rctx = ctx->rec.elts;\n    for (n = 0; n < ctx->rec.nelts; ++n, ++rctx) {\n        if (rctx->conf->flags & (NGX_RTMP_RECORD_OFF|NGX_RTMP_RECORD_MANUAL)) {\n            continue;\n        }\n        ngx_rtmp_record_node_open(s, rctx);\n    }\n}\n\n\nstatic void\nngx_rtmp_record_stop(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_record_app_conf_t     *racf;\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n    ngx_rtmp_record_ctx_t          *ctx;\n    ngx_uint_t                      n;\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_record_module);\n    if (racf == NULL || racf->rec.nelts == 0) {\n        return;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: stop\");\n\n    rctx = ctx->rec.elts;\n    for (n = 0; n < ctx->rec.nelts; ++n, ++rctx) {\n        ngx_rtmp_record_node_close(s, rctx);\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_record_app_conf_t     *racf;\n    ngx_rtmp_record_ctx_t          *ctx;\n    u_char                         *p;\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_record_module);\n\n    if (racf == NULL || racf->rec.nelts == 0) {\n        goto next;\n    }\n\n    if (s->auto_pushed) {\n        if (ngx_rtmp_record_init_ctx(s) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    } else {\n        if (ngx_rtmp_record_init(s) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n\n    ngx_memcpy(ctx->name, v->name, sizeof(ctx->name));\n    ngx_memcpy(ctx->args, v->args, sizeof(ctx->args));\n\n    /* terminate name on /../ */\n    for (p = ctx->name; *p; ++p) {\n        if (ngx_path_separator(p[0]) &&\n            p[1] == '.' && p[2] == '.' &&\n            ngx_path_separator(p[3]))\n        {\n            *p = 0;\n            break;\n        }\n    }\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: publish %ui nodes\",\n                   racf->rec.nelts);\n\n    ngx_rtmp_record_start(s);\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_stream_begin(ngx_rtmp_session_t *s, ngx_rtmp_stream_begin_t *v)\n{\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: stream_begin\");\n\n    ngx_rtmp_record_start(s);\n\nnext:\n    return next_stream_begin(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_stream_eof(ngx_rtmp_session_t *s, ngx_rtmp_stream_begin_t *v)\n{\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: stream_eof\");\n\n    ngx_rtmp_record_stop(s);\n\nnext:\n    return next_stream_eof(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_node_close(ngx_rtmp_session_t *s,\n                           ngx_rtmp_record_rec_ctx_t *rctx)\n{\n    ngx_rtmp_record_app_conf_t *rracf;\n    ngx_err_t                   err;\n    void                      **app_conf;\n    ngx_int_t                   rc;\n    ngx_rtmp_record_done_t      v;\n    u_char                      av;\n\n    rracf = rctx->conf;\n\n    if (rctx->file.fd == NGX_INVALID_FILE) {\n        return NGX_AGAIN;\n    }\n\n    if (rctx->initialized) {\n        av = 0;\n\n        if (rctx->video) {\n            av |= 0x01;\n        }\n\n        if (rctx->audio) {\n            av |= 0x04;\n        }\n\n        if (ngx_write_file(&rctx->file, &av, 1, 4) == NGX_ERROR) {\n            ngx_log_error(NGX_LOG_CRIT, s->connection->log, ngx_errno,\n                          \"record: %V error writing av mask\", &rracf->id);\n        }\n    }\n\n    if (ngx_close_file(rctx->file.fd) == NGX_FILE_ERROR) {\n        err = ngx_errno;\n        ngx_log_error(NGX_LOG_CRIT, s->connection->log, err,\n                      \"record: %V error closing file\", &rracf->id);\n\n        ngx_rtmp_record_notify_error(s, rctx);\n    }\n\n    rctx->file.fd = NGX_INVALID_FILE;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: %V closed\", &rracf->id);\n\n    if (rracf->notify) {\n        ngx_rtmp_send_status(s, \"NetStream.Record.Stop\", \"status\",\n                             rracf->id.data ? (char *) rracf->id.data : \"\");\n    }\n\n    app_conf = s->app_conf;\n\n    if (rracf->rec_conf) {\n        s->app_conf = rracf->rec_conf;\n    }\n\n    v.recorder = rracf->id;\n    ngx_rtmp_record_make_path(s, rctx, &v.path);\n\n    rc = ngx_rtmp_record_done(s, &v);\n\n    s->app_conf = app_conf;\n\n    return rc;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_close_stream(ngx_rtmp_session_t *s,\n                             ngx_rtmp_close_stream_t *v)\n{\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: close_stream\");\n\n    ngx_rtmp_record_stop(s);\n\nnext:\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_write_frame(ngx_rtmp_session_t *s,\n                            ngx_rtmp_record_rec_ctx_t *rctx,\n                            ngx_rtmp_header_t *h, ngx_chain_t *in,\n                            ngx_int_t inc_nframes)\n{\n    u_char                      hdr[11], *ph;\n    uint32_t                    timestamp, tag_size;\n    ngx_rtmp_record_app_conf_t *rracf;\n\n    rracf = rctx->conf;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"record: %V frame: mlen=%uD\",\n                   &rracf->id, h->mlen);\n\n    if (h->type == NGX_RTMP_MSG_VIDEO) {\n        rctx->video = 1;\n    } else {\n        rctx->audio = 1;\n    }\n\n    timestamp = h->timestamp - rctx->epoch;\n\n    if ((int32_t) timestamp < 0) {\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"record: %V cut timestamp=%D\", &rracf->id, timestamp);\n\n        timestamp = 0;\n    }\n\n    /* write tag header */\n    ph = hdr;\n\n    *ph++ = (u_char)h->type;\n\n    ngx_rtmp_h4_to_n3(ph, h->mlen);\n    ph += 3;\n\n    ngx_rtmp_h4_to_n3(ph, timestamp);\n    ph += 3;\n    *ph++ = (u_char) (timestamp >> 24);\n\n    *ph++ = 0;\n    *ph++ = 0;\n    *ph++ = 0;\n\n    tag_size = (ph - hdr) + h->mlen;\n\n    if (ngx_write_file(&rctx->file, hdr, ph - hdr, rctx->file.offset)\n        == NGX_ERROR)\n    {\n        ngx_rtmp_record_notify_error(s, rctx);\n\n        ngx_close_file(rctx->file.fd);\n\n        return NGX_ERROR;\n    }\n\n    /* write tag body\n     * FIXME: NGINX\n     * ngx_write_chain seems to fit best\n     * but it suffers from uncontrollable\n     * allocations.\n     * we're left with plain writing */\n    for(; in; in = in->next) {\n        if (in->buf->pos == in->buf->last) {\n            continue;\n        }\n\n        if (ngx_write_file(&rctx->file, in->buf->pos, in->buf->last\n                           - in->buf->pos, rctx->file.offset)\n            == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    /* write tag size */\n    ph = hdr;\n    *(uint32_t *) ph = htonl(tag_size);\n    ph += 4;\n\n    if (ngx_write_file(&rctx->file, hdr, ph - hdr,\n                       rctx->file.offset)\n        == NGX_ERROR)\n    {\n        return NGX_ERROR;\n    }\n\n    rctx->nframes += inc_nframes;\n\n    /* watch max size */\n    if ((rracf->max_size && rctx->file.offset >= (ngx_int_t) rracf->max_size) ||\n        (rracf->max_frames && rctx->nframes >= rracf->max_frames))\n    {\n        ngx_rtmp_record_node_close(s, rctx);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic size_t\nngx_rtmp_record_get_chain_mlen(ngx_chain_t *in)\n{\n    size_t                          ret;\n\n    for (ret = 0; in; in = in->next) {\n        ret += (in->buf->last - in->buf->pos);\n    }\n\n    return ret;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_av(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                   ngx_chain_t *in)\n{\n    ngx_rtmp_record_ctx_t          *ctx;\n    ngx_rtmp_record_rec_ctx_t      *rctx;\n    ngx_uint_t                      n;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n\n    if (ctx == NULL) {\n        return NGX_OK;\n    }\n\n    rctx = ctx->rec.elts;\n\n    for (n = 0; n < ctx->rec.nelts; ++n, ++rctx) {\n        ngx_rtmp_record_node_av(s, rctx, h, in);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_node_av(ngx_rtmp_session_t *s, ngx_rtmp_record_rec_ctx_t *rctx,\n                        ngx_rtmp_header_t *h, ngx_chain_t *in)\n{\n    ngx_time_t                      next;\n    ngx_rtmp_header_t               ch;\n    ngx_rtmp_codec_ctx_t           *codec_ctx;\n    ngx_int_t                       keyframe, brkframe;\n    ngx_rtmp_record_app_conf_t     *rracf;\n\n    rracf = rctx->conf;\n\n    if (rracf->flags & NGX_RTMP_RECORD_OFF) {\n        ngx_rtmp_record_node_close(s, rctx);\n        return NGX_OK;\n    }\n\n    keyframe = (h->type == NGX_RTMP_MSG_VIDEO)\n             ? (ngx_rtmp_get_video_frame_type(in) == NGX_RTMP_VIDEO_KEY_FRAME)\n             : 0;\n\n    brkframe = (h->type == NGX_RTMP_MSG_VIDEO)\n             ? keyframe\n             : (rracf->flags & NGX_RTMP_RECORD_VIDEO) == 0;\n\n    if (brkframe && (rracf->flags & NGX_RTMP_RECORD_MANUAL) == 0) {\n\n        if (rracf->interval != NGX_CONF_UNSET_MSEC) {\n\n            next = rctx->last;\n            next.msec += rracf->interval;\n            next.sec  += (next.msec / 1000);\n            next.msec %= 1000;\n\n            if (ngx_cached_time->sec  > next.sec ||\n               (ngx_cached_time->sec == next.sec &&\n                ngx_cached_time->msec > next.msec))\n            {\n                ngx_rtmp_record_node_close(s, rctx);\n                ngx_rtmp_record_node_open(s, rctx);\n            }\n\n        } else if (!rctx->failed) {\n            ngx_rtmp_record_node_open(s, rctx);\n        }\n    }\n\n    if ((rracf->flags & NGX_RTMP_RECORD_MANUAL) &&\n        !brkframe && rctx->nframes == 0)\n    {\n        return NGX_OK;\n    }\n\n    if (rctx->file.fd == NGX_INVALID_FILE) {\n        return NGX_OK;\n    }\n\n    if (h->type == NGX_RTMP_MSG_AUDIO &&\n       (rracf->flags & NGX_RTMP_RECORD_AUDIO) == 0)\n    {\n        return NGX_OK;\n    }\n\n    if (h->type == NGX_RTMP_MSG_VIDEO &&\n       (rracf->flags & NGX_RTMP_RECORD_VIDEO) == 0 &&\n       ((rracf->flags & NGX_RTMP_RECORD_KEYFRAMES) == 0 || !keyframe))\n    {\n        return NGX_OK;\n    }\n\n    if (!rctx->initialized) {\n\n        rctx->initialized = 1;\n        rctx->epoch = h->timestamp - rctx->time_shift;\n\n        if (rctx->file.offset == 0 &&\n            ngx_rtmp_record_write_header(&rctx->file) != NGX_OK)\n        {\n            ngx_rtmp_record_node_close(s, rctx);\n            return NGX_OK;\n        }\n    }\n\n    codec_ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n    if (codec_ctx) {\n        ch = *h;\n\n        /* AAC header */\n        if (!rctx->aac_header_sent && codec_ctx->aac_header &&\n           (rracf->flags & NGX_RTMP_RECORD_AUDIO))\n        {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"record: %V writing AAC header\", &rracf->id);\n\n            ch.type = NGX_RTMP_MSG_AUDIO;\n            ch.mlen = ngx_rtmp_record_get_chain_mlen(codec_ctx->aac_header);\n\n            if (ngx_rtmp_record_write_frame(s, rctx, &ch,\n                                            codec_ctx->aac_header, 0)\n                != NGX_OK)\n            {\n                return NGX_OK;\n            }\n\n            rctx->aac_header_sent = 1;\n        }\n\n        /* AVC header */\n        if (!rctx->avc_header_sent && codec_ctx->avc_header &&\n           (rracf->flags & (NGX_RTMP_RECORD_VIDEO|\n                            NGX_RTMP_RECORD_KEYFRAMES)))\n        {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"record: %V writing AVC header\", &rracf->id);\n\n            ch.type = NGX_RTMP_MSG_VIDEO;\n            ch.mlen = ngx_rtmp_record_get_chain_mlen(codec_ctx->avc_header);\n\n            if (ngx_rtmp_record_write_frame(s, rctx, &ch,\n                                            codec_ctx->avc_header, 0)\n                != NGX_OK)\n            {\n                return NGX_OK;\n            }\n\n            rctx->avc_header_sent = 1;\n        }\n    }\n\n    if (h->type == NGX_RTMP_MSG_VIDEO) {\n        if (codec_ctx && codec_ctx->video_codec_id == NGX_RTMP_VIDEO_H264 &&\n            !rctx->avc_header_sent)\n        {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"record: %V skipping until H264 header\", &rracf->id);\n            return NGX_OK;\n        }\n\n        if (ngx_rtmp_get_video_frame_type(in) == NGX_RTMP_VIDEO_KEY_FRAME &&\n            ((codec_ctx && codec_ctx->video_codec_id != NGX_RTMP_VIDEO_H264) ||\n             !ngx_rtmp_is_codec_header(in)))\n        {\n            rctx->video_key_sent = 1;\n        }\n\n        if (!rctx->video_key_sent) {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"record: %V skipping until keyframe\", &rracf->id);\n            return NGX_OK;\n        }\n\n    } else {\n        if (codec_ctx && codec_ctx->audio_codec_id == NGX_RTMP_AUDIO_AAC &&\n            !rctx->aac_header_sent)\n        {\n            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                           \"record: %V skipping until AAC header\", &rracf->id);\n            return NGX_OK;\n        }\n    }\n\n    return ngx_rtmp_record_write_frame(s, rctx, h, in, 1);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_done_init(ngx_rtmp_session_t *s, ngx_rtmp_record_done_t *v)\n{\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_rtmp_record_recorder(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                       *rv;\n    ngx_int_t                   i;\n    ngx_str_t                  *value;\n    ngx_conf_t                  save;\n    ngx_module_t              **modules;\n    ngx_rtmp_module_t          *module;\n    ngx_rtmp_core_app_conf_t   *cacf, **pcacf, *rcacf;\n    ngx_rtmp_record_app_conf_t *racf, **pracf, *rracf;\n    ngx_rtmp_conf_ctx_t        *ctx, *pctx;\n\n    value = cf->args->elts;\n\n    cacf = ngx_rtmp_conf_get_module_app_conf(cf, ngx_rtmp_core_module);\n\n    racf = ngx_rtmp_conf_get_module_app_conf(cf, ngx_rtmp_record_module);\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    pctx = cf->ctx;\n\n    ctx->main_conf = pctx->main_conf;\n    ctx->srv_conf  = pctx->srv_conf;\n\n    ctx->app_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_rtmp_max_module);\n    if (ctx->app_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n#if (nginx_version >= 1009011)\n    modules = cf->cycle->modules;\n#else\n    modules = ngx_modules;\n#endif\n\n    for (i = 0; modules[i]; i++) {\n        if (modules[i]->type != NGX_RTMP_MODULE) {\n            continue;\n        }\n\n        module = modules[i]->ctx;\n\n        if (module->create_app_conf) {\n            ctx->app_conf[modules[i]->ctx_index] = module->create_app_conf(cf);\n            if (ctx->app_conf[modules[i]->ctx_index] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    /* add to sub-applications */\n    rcacf = ctx->app_conf[ngx_rtmp_core_module.ctx_index];\n    rcacf->app_conf = ctx->app_conf;\n    pcacf = ngx_array_push(&cacf->applications);\n    if (pcacf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n    *pcacf = rcacf;\n\n    /* add to recorders */\n    rracf = ctx->app_conf[ngx_rtmp_record_module.ctx_index];\n    rracf->rec_conf = ctx->app_conf;\n    pracf = ngx_array_push(&racf->rec);\n    if (pracf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n    *pracf = rracf;\n\n    rracf->id = value[1];\n\n\n    save = *cf;\n    cf->ctx = ctx;\n    cf->cmd_type = NGX_RTMP_REC_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n    *cf= save;\n\n    return rv;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_record_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n\n    ngx_rtmp_record_done = ngx_rtmp_record_done_init;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_AUDIO]);\n    *h = ngx_rtmp_record_av;\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_MSG_VIDEO]);\n    *h = ngx_rtmp_record_av;\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_record_publish;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_record_close_stream;\n\n    next_stream_begin = ngx_rtmp_stream_begin;\n    ngx_rtmp_stream_begin = ngx_rtmp_record_stream_begin;\n\n    next_stream_eof = ngx_rtmp_stream_eof;\n    ngx_rtmp_stream_eof = ngx_rtmp_record_stream_eof;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_record_module.h",
          "type": "blob",
          "size": 3.0556640625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#ifndef _NGX_RTMP_RECORD_H_INCLUDED_\n#define _NGX_RTMP_RECORD_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\n#define NGX_RTMP_RECORD_OFF             0x01\n#define NGX_RTMP_RECORD_AUDIO           0x02\n#define NGX_RTMP_RECORD_VIDEO           0x04\n#define NGX_RTMP_RECORD_KEYFRAMES       0x08\n#define NGX_RTMP_RECORD_MANUAL          0x10\n\n\ntypedef struct {\n    ngx_str_t                           id;\n    ngx_uint_t                          flags;\n    ngx_str_t                           path;\n    size_t                              max_size;\n    size_t                              max_frames;\n    ngx_msec_t                          interval;\n    ngx_str_t                           suffix;\n    ngx_flag_t                          unique;\n    ngx_flag_t                          append;\n    ngx_flag_t                          lock_file;\n    ngx_flag_t                          notify;\n    ngx_url_t                          *url;\n\n    void                              **rec_conf;\n    ngx_array_t                         rec; /* ngx_rtmp_record_app_conf_t * */\n} ngx_rtmp_record_app_conf_t;\n\n\ntypedef struct {\n    ngx_rtmp_record_app_conf_t         *conf;\n    ngx_file_t                          file;\n    ngx_uint_t                          nframes;\n    uint32_t                            epoch, time_shift;\n    ngx_time_t                          last;\n    time_t                              timestamp;\n    unsigned                            failed:1;\n    unsigned                            initialized:1;\n    unsigned                            aac_header_sent:1;\n    unsigned                            avc_header_sent:1;\n    unsigned                            video_key_sent:1;\n    unsigned                            audio:1;\n    unsigned                            video:1;\n} ngx_rtmp_record_rec_ctx_t;\n\n\ntypedef struct {\n    ngx_array_t                         rec; /* ngx_rtmp_record_rec_ctx_t */\n    u_char                              name[NGX_RTMP_MAX_NAME];\n    u_char                              args[NGX_RTMP_MAX_ARGS];\n} ngx_rtmp_record_ctx_t;\n\n\nngx_uint_t ngx_rtmp_record_find(ngx_rtmp_record_app_conf_t *racf,\n           ngx_str_t *id);\n\n\n/* Manual recording control,\n * 'n' is record node index in config array.\n * Note: these functions allocate path in static buffer */\n\nngx_int_t ngx_rtmp_record_open(ngx_rtmp_session_t *s, ngx_uint_t n,\n          ngx_str_t *path);\nngx_int_t ngx_rtmp_record_close(ngx_rtmp_session_t *s, ngx_uint_t n,\n          ngx_str_t *path);\n\nvoid ngx_rtmp_record_get_path(ngx_rtmp_session_t *s,\n    ngx_rtmp_record_rec_ctx_t *rctx, ngx_str_t *path);\n\n\ntypedef struct {\n    ngx_str_t                           recorder;\n    ngx_str_t                           path;\n} ngx_rtmp_record_done_t;\n\n\ntypedef ngx_int_t (*ngx_rtmp_record_done_pt)(ngx_rtmp_session_t *s,\n        ngx_rtmp_record_done_t *v);\n\n\nextern ngx_rtmp_record_done_pt          ngx_rtmp_record_done;\n\n\nextern ngx_module_t                     ngx_rtmp_record_module;\n\n\n#endif /* _NGX_RTMP_RECORD_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_relay_module.c",
          "type": "blob",
          "size": 51.98046875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp_relay_module.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n#include \"ngx_rtmp_eval.h\"\n\n\nstatic ngx_rtmp_publish_pt          next_publish;\nstatic ngx_rtmp_play_pt             next_play;\nstatic ngx_rtmp_delete_stream_pt    next_delete_stream;\nstatic ngx_rtmp_close_stream_pt     next_close_stream;\n\n\nstatic ngx_int_t ngx_rtmp_relay_init_process(ngx_cycle_t *cycle);\nstatic ngx_int_t ngx_rtmp_relay_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_relay_create_app_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_relay_merge_app_conf(ngx_conf_t *cf,\n       void *parent, void *child);\nstatic char * ngx_rtmp_relay_push_pull(ngx_conf_t *cf, ngx_command_t *cmd,\n       void *conf);\nstatic ngx_int_t ngx_rtmp_relay_publish(ngx_rtmp_session_t *s,\n       ngx_rtmp_publish_t *v);\nstatic ngx_rtmp_relay_ctx_t * ngx_rtmp_relay_create_connection(\n       ngx_rtmp_conf_ctx_t *cctx, ngx_str_t* name,\n       ngx_rtmp_relay_target_t *target);\nstatic void ngx_rtmp_relay_eval_ctx_str(void *ctx, ngx_rtmp_eval_t *e,\n       ngx_str_t *ret);\n\n/*                _____\n * =push=        |     |---publish--->\n * ---publish--->|     |---publish--->\n *     (src)     |     |---publish--->\n *                -----  (next,relay)\n *                      need reconnect\n * =pull=         _____\n * -----play---->|     |\n * -----play---->|     |----play----->\n * -----play---->|     | (src,relay)\n *     (next)     -----\n */\n\n\ntypedef struct {\n    ngx_rtmp_conf_ctx_t         cctx;\n    ngx_rtmp_relay_target_t    *target;\n} ngx_rtmp_relay_static_t;\n\n\n#define NGX_RTMP_RELAY_CONNECT_TRANS            1\n#define NGX_RTMP_RELAY_RELEASE_STREAM_TRANS     2\n#define NGX_RTMP_RELAY_FCPUBLISH_STREAM_TRANS   3\n#define NGX_RTMP_RELAY_CREATE_STREAM_TRANS      4\n\n\n#define NGX_RTMP_RELAY_CSID_AMF_INI             3\n#define NGX_RTMP_RELAY_CSID_AMF                 5\n#define NGX_RTMP_RELAY_MSID                     1\n\n\n/* default flashVer */\n#define NGX_RTMP_RELAY_FLASHVER                 \"LNX.11,1,102,55\"\n\n\nstatic ngx_command_t  ngx_rtmp_relay_commands[] = {\n\n    { ngx_string(\"push\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_relay_push_pull,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"pull\"),\n      NGX_RTMP_APP_CONF|NGX_CONF_1MORE,\n      ngx_rtmp_relay_push_pull,\n      NGX_RTMP_APP_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"relay_buffer\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_relay_app_conf_t, buflen),\n      NULL },\n\n    { ngx_string(\"push_reconnect\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_relay_app_conf_t, push_reconnect),\n      NULL },\n\n    { ngx_string(\"pull_reconnect\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_relay_app_conf_t, pull_reconnect),\n      NULL },\n\n    { ngx_string(\"session_relay\"),\n      NGX_RTMP_MAIN_CONF|NGX_RTMP_SRV_CONF|NGX_RTMP_APP_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_flag_slot,\n      NGX_RTMP_APP_CONF_OFFSET,\n      offsetof(ngx_rtmp_relay_app_conf_t, session_relay),\n      NULL },\n\n\n      ngx_null_command\n};\n\n\nstatic ngx_rtmp_module_t  ngx_rtmp_relay_module_ctx = {\n    NULL,                                   /* preconfiguration */\n    ngx_rtmp_relay_postconfiguration,       /* postconfiguration */\n    NULL,                                   /* create main configuration */\n    NULL,                                   /* init main configuration */\n    NULL,                                   /* create server configuration */\n    NULL,                                   /* merge server configuration */\n    ngx_rtmp_relay_create_app_conf,         /* create app configuration */\n    ngx_rtmp_relay_merge_app_conf           /* merge app configuration */\n};\n\n\nngx_module_t  ngx_rtmp_relay_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_relay_module_ctx,             /* module context */\n    ngx_rtmp_relay_commands,                /* module directives */\n    NGX_RTMP_MODULE,                        /* module type */\n    NULL,                                   /* init master */\n    NULL,                                   /* init module */\n    ngx_rtmp_relay_init_process,            /* init process */\n    NULL,                                   /* init thread */\n    NULL,                                   /* exit thread */\n    NULL,                                   /* exit process */\n    NULL,                                   /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_rtmp_eval_t ngx_rtmp_relay_specific_eval[] = {\n\n    { ngx_string(\"name\"),\n      ngx_rtmp_relay_eval_ctx_str,\n      offsetof(ngx_rtmp_session_t, stream) },\n\n    { ngx_string(\"args\"),\n      ngx_rtmp_relay_eval_ctx_str,\n      offsetof(ngx_rtmp_session_t, args) },\n\n    ngx_rtmp_null_eval\n};\n\n\nstatic ngx_rtmp_eval_t *ngx_rtmp_relay_eval[] = {\n    ngx_rtmp_eval_session,\n    ngx_rtmp_relay_specific_eval,\n    NULL\n};\n\n\nstatic void\nngx_rtmp_relay_eval_ctx_str(void *ctx, ngx_rtmp_eval_t *e, ngx_str_t *ret)\n{\n    *ret = *(ngx_str_t *) ((u_char *) ctx + e->offset);\n}\n\n\nstatic void *\nngx_rtmp_relay_create_app_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_relay_app_conf_t     *racf;\n\n    racf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_relay_app_conf_t));\n    if (racf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&racf->pushes, cf->pool, 1, sizeof(void *)) != NGX_OK) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&racf->pulls, cf->pool, 1, sizeof(void *)) != NGX_OK) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&racf->static_pulls, cf->pool, 1, sizeof(void *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    if (ngx_array_init(&racf->static_events, cf->pool, 1, sizeof(void *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    racf->nbuckets = 1024;\n    racf->log = &cf->cycle->new_log;\n    racf->buflen = NGX_CONF_UNSET_MSEC;\n    racf->session_relay = NGX_CONF_UNSET;\n    racf->push_reconnect = NGX_CONF_UNSET_MSEC;\n    racf->pull_reconnect = NGX_CONF_UNSET_MSEC;\n\n    return racf;\n}\n\n\nstatic char *\nngx_rtmp_relay_merge_app_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_relay_app_conf_t  *prev = parent;\n    ngx_rtmp_relay_app_conf_t  *conf = child;\n\n    conf->ctx = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_relay_ctx_t *)\n            * conf->nbuckets);\n\n    ngx_conf_merge_value(conf->session_relay, prev->session_relay, 0);\n    ngx_conf_merge_msec_value(conf->buflen, prev->buflen, 5000);\n    ngx_conf_merge_msec_value(conf->push_reconnect, prev->push_reconnect,\n            3000);\n    ngx_conf_merge_msec_value(conf->pull_reconnect, prev->pull_reconnect,\n            3000);\n\n    return NGX_CONF_OK;\n}\n\n\nstatic void\nngx_rtmp_relay_static_pull_reconnect(ngx_event_t *ev)\n{\n    ngx_rtmp_relay_static_t    *rs = ev->data;\n\n    ngx_rtmp_relay_ctx_t       *ctx;\n    ngx_rtmp_relay_app_conf_t  *racf;\n\n    racf = ngx_rtmp_get_module_app_conf(&rs->cctx, ngx_rtmp_relay_module);\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, racf->log, 0,\n                   \"relay: reconnecting static pull\");\n\n    ctx = ngx_rtmp_relay_create_connection(&rs->cctx, &rs->target->name,\n                                           rs->target);\n    if (ctx) {\n        ctx->session->static_relay = 1;\n        ctx->static_evt = ev;\n        return;\n    }\n\n    ngx_add_timer(ev, racf->pull_reconnect);\n}\n\n\nstatic void\nngx_rtmp_relay_push_reconnect(ngx_event_t *ev)\n{\n    ngx_rtmp_session_t             *s = ev->data;\n\n    ngx_rtmp_relay_app_conf_t      *racf;\n    ngx_rtmp_relay_ctx_t           *ctx, *pctx;\n    ngx_uint_t                      n;\n    ngx_rtmp_relay_target_t        *target, **t;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"relay: push reconnect\");\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    t = racf->pushes.elts;\n    for (n = 0; n < racf->pushes.nelts; ++n, ++t) {\n        target = *t;\n\n        if (target->name.len && (ctx->name.len != target->name.len ||\n            ngx_memcmp(ctx->name.data, target->name.data, ctx->name.len)))\n        {\n            continue;\n        }\n\n        for (pctx = ctx->play; pctx; pctx = pctx->next) {\n            if (pctx->tag == &ngx_rtmp_relay_module &&\n                pctx->data == target)\n            {\n                break;\n            }\n        }\n\n        if (pctx) {\n            continue;\n        }\n\n        if (ngx_rtmp_relay_push(s, &ctx->name, target) == NGX_OK) {\n            continue;\n        }\n\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                \"relay: push reconnect failed name='%V' app='%V' \"\n                \"playpath='%V' url='%V' args='%V'\",\n                &ctx->name, &target->app, &target->play_path,\n                &target->url.url, &s->args);\n\n        if (!ctx->push_evt.timer_set) {\n            ngx_add_timer(&ctx->push_evt, racf->push_reconnect);\n        }\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_get_peer(ngx_peer_connection_t *pc, void *data)\n{\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_relay_free_peer(ngx_peer_connection_t *pc, void *data,\n            ngx_uint_t state)\n{\n}\n\n\ntypedef ngx_rtmp_relay_ctx_t * (* ngx_rtmp_relay_create_ctx_pt)\n    (ngx_rtmp_session_t *s, ngx_str_t *name, ngx_rtmp_relay_target_t *target);\n\n\nstatic ngx_int_t\nngx_rtmp_relay_copy_str(ngx_pool_t *pool, ngx_str_t *dst, ngx_str_t *src)\n{\n    if (src->len == 0) {\n        return NGX_OK;\n    }\n    dst->len = src->len;\n    dst->data = ngx_palloc(pool, src->len);\n    if (dst->data == NULL) {\n        return NGX_ERROR;\n    }\n    ngx_memcpy(dst->data, src->data, src->len);\n    return NGX_OK;\n}\n\n\nstatic ngx_rtmp_relay_ctx_t *\nngx_rtmp_relay_create_connection(ngx_rtmp_conf_ctx_t *cctx, ngx_str_t *name,\n        ngx_rtmp_relay_target_t *target)\n{\n    ngx_rtmp_relay_app_conf_t      *racf;\n    ngx_rtmp_relay_ctx_t           *rctx;\n    ngx_rtmp_addr_conf_t           *addr_conf;\n    ngx_rtmp_conf_ctx_t            *addr_ctx;\n    ngx_rtmp_session_t             *rs;\n    ngx_peer_connection_t          *pc;\n    ngx_connection_t               *c;\n    ngx_addr_t                     *addr;\n    ngx_pool_t                     *pool;\n    size_t                          len;\n    ngx_int_t                       rc;\n    ngx_str_t                       v, *uri;\n    u_char                         *first, *last, *p;\n    u_char                          buf[NGX_SOCKADDR_STRLEN];\n\n    racf = ngx_rtmp_get_module_app_conf(cctx, ngx_rtmp_relay_module);\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, racf->log, 0,\n                   \"relay: create remote context\");\n\n    pool = NULL;\n    pool = ngx_create_pool(4096, racf->log);\n    if (pool == NULL) {\n        return NULL;\n    }\n\n    rctx = ngx_pcalloc(pool, sizeof(ngx_rtmp_relay_ctx_t));\n    if (rctx == NULL) {\n        goto clear;\n    }\n\n    if (name && ngx_rtmp_relay_copy_str(pool, &rctx->name, name) != NGX_OK) {\n        goto clear;\n    }\n\n    if (ngx_rtmp_relay_copy_str(pool, &rctx->url, &target->url.url) != NGX_OK) {\n        goto clear;\n    }\n\n    rctx->tag = target->tag;\n    rctx->data = target->data;\n\n#define NGX_RTMP_RELAY_STR_COPY(to, from)                                     \\\n    if (ngx_rtmp_relay_copy_str(pool, &rctx->to, &target->from) != NGX_OK) {  \\\n        goto clear;                                                           \\\n    }\n\n    NGX_RTMP_RELAY_STR_COPY(app,        app);\n    NGX_RTMP_RELAY_STR_COPY(tc_url,     tc_url);\n    NGX_RTMP_RELAY_STR_COPY(page_url,   page_url);\n    NGX_RTMP_RELAY_STR_COPY(swf_url,    swf_url);\n    NGX_RTMP_RELAY_STR_COPY(flash_ver,  flash_ver);\n    NGX_RTMP_RELAY_STR_COPY(play_path,  play_path);\n\n    rctx->live  = target->live;\n    rctx->start = target->start;\n    rctx->stop  = target->stop;\n\n#undef NGX_RTMP_RELAY_STR_COPY\n\n    if (rctx->app.len == 0 || rctx->play_path.len == 0) {\n        /* parse uri */\n        uri = &target->url.uri;\n        first = uri->data;\n        last  = uri->data + uri->len;\n        if (first != last && *first == '/') {\n            ++first;\n        }\n\n        if (first != last) {\n\n            /* deduce app */\n            p = ngx_strlchr(first, last, '/');\n            if (p == NULL) {\n                p = last;\n            }\n\n            if (rctx->app.len == 0 && first != p) {\n                v.data = first;\n                v.len = p - first;\n                if (ngx_rtmp_relay_copy_str(pool, &rctx->app, &v) != NGX_OK) {\n                    goto clear;\n                }\n            }\n\n            /* deduce play_path */\n            if (p != last) {\n                ++p;\n            }\n\n            if (rctx->play_path.len == 0 && p != last) {\n                v.data = p;\n                v.len = last - p;\n                if (ngx_rtmp_relay_copy_str(pool, &rctx->play_path, &v)\n                        != NGX_OK)\n                {\n                    goto clear;\n                }\n            }\n        }\n    }\n\n    pc = ngx_pcalloc(pool, sizeof(ngx_peer_connection_t));\n    if (pc == NULL) {\n        goto clear;\n    }\n\n    if (target->url.naddrs == 0) {\n        ngx_log_error(NGX_LOG_ERR, racf->log, 0,\n                      \"relay: no address\");\n        goto clear;\n    }\n\n    /* get address */\n    addr = &target->url.addrs[target->counter % target->url.naddrs];\n    target->counter++;\n\n    /* copy log to keep shared log unchanged */\n    rctx->log = *racf->log;\n    pc->log = &rctx->log;\n    pc->get = ngx_rtmp_relay_get_peer;\n    pc->free = ngx_rtmp_relay_free_peer;\n\n    pc->name = ngx_palloc(pool, sizeof(ngx_str_t) + addr->name.len);\n    if (pc->name == NULL) {\n        goto clear;\n    }\n\n    pc->name->len = addr->name.len;\n    pc->name->data = (u_char *) pc->name + sizeof(ngx_str_t);\n    ngx_memcpy(pc->name->data, addr->name.data, addr->name.len);\n\n    pc->socklen = addr->socklen;\n    pc->sockaddr = (struct sockaddr *)ngx_palloc(pool, pc->socklen);\n    if (pc->sockaddr == NULL) {\n        goto clear;\n    }\n    ngx_memcpy(pc->sockaddr, addr->sockaddr, pc->socklen);\n\n    rc = ngx_event_connect_peer(pc);\n    if (rc != NGX_OK && rc != NGX_AGAIN ) {\n        ngx_log_debug0(NGX_LOG_DEBUG_RTMP, racf->log, 0,\n                \"relay: connection failed\");\n        goto clear;\n    }\n    c = pc->connection;\n    c->pool = pool;\n\n    ngx_str_set(&c->addr_text, \"ngx-relay\");\n\n    addr_conf = ngx_pcalloc(pool, sizeof(ngx_rtmp_addr_conf_t));\n    if (addr_conf == NULL) {\n        goto clear;\n    }\n\n#if (NGX_HAVE_UNIX_DOMAIN)\n    if (addr->sockaddr->sa_family == AF_UNIX) {\n        addr_conf->addr_text.len = target->url.host.len;\n        addr_conf->addr_text.data = ngx_pcalloc(pool,\n                                                addr_conf->addr_text.len);\n        if (addr_conf->addr_text.data == NULL) {\n            ngx_log_error(NGX_LOG_ERR, racf->log, 0,\n                          \"relay: allocation for unix address failed\");\n            goto clear;\n        }\n\n        ngx_memcpy(addr_conf->addr_text.data, target->url.host.data,\n                   addr_conf->addr_text.len);\n    } else\n#endif\n    {\n        len = ngx_sock_ntop(pc->sockaddr,\n#if (nginx_version >= 1005003)\n                            pc->socklen,\n#endif\n                            buf, NGX_SOCKADDR_STRLEN, 1);\n\n        addr_conf->addr_text.data = ngx_pcalloc(pool, len);\n        if (addr_conf->addr_text.data == NULL) {\n            ngx_log_error(NGX_LOG_ERR, racf->log, 0,\n                          \"relay: allocation for address failed\");\n            goto clear;\n        }\n\n        addr_conf->addr_text.len = len;\n        ngx_memcpy(addr_conf->addr_text.data, buf, len);\n    }\n\n    addr_conf->default_server = ngx_pcalloc(pool,\n                                            sizeof(ngx_rtmp_core_srv_conf_t));\n    if (addr_conf->default_server == NULL) {\n        goto clear;\n    }\n\n    addr_ctx = ngx_pcalloc(pool, sizeof(ngx_rtmp_conf_ctx_t));\n    if (addr_ctx == NULL) {\n        goto clear;\n    }\n\n    addr_conf->default_server->ctx = addr_ctx;\n    addr_ctx->main_conf = cctx->main_conf;\n    addr_ctx->srv_conf  = cctx->srv_conf;\n\n    rs = ngx_rtmp_init_session(c, addr_conf);\n    if (rs == NULL) {\n        /* no need to destroy pool */\n        return NULL;\n    }\n    rs->app_conf = cctx->app_conf;\n    rs->relay = 1;\n    rctx->session = rs;\n    ngx_rtmp_set_ctx(rs, rctx, ngx_rtmp_relay_module);\n    ngx_str_set(&rs->flashver, \"ngx-local-relay\");\n\n#if (NGX_STAT_STUB)\n    (void) ngx_atomic_fetch_add(ngx_stat_active, 1);\n#endif\n\n    ngx_rtmp_client_handshake(rs, 1);\n    return rctx;\n\nclear:\n    if (pool) {\n        ngx_destroy_pool(pool);\n    }\n    return NULL;\n}\n\n\nstatic ngx_rtmp_relay_ctx_t *\nngx_rtmp_relay_create_remote_ctx(ngx_rtmp_session_t *s, ngx_str_t *name,\n        ngx_rtmp_relay_target_t *target)\n{\n    ngx_str_t                   url;\n    ngx_url_t                   save;\n    ngx_rtmp_conf_ctx_t         cctx;\n    ngx_rtmp_relay_ctx_t       *rctx;\n\n    cctx.app_conf = s->app_conf;\n    cctx.srv_conf = s->srv_conf;\n    cctx.main_conf = s->main_conf;\n\n    rctx = NULL;\n    save = target->url;\n    ngx_memzero(&url, sizeof(ngx_str_t));\n\n    if(ngx_strlchr(target->url.url.data,\n                   target->url.url.data + target->url.url.len, '$'))\n    {\n        ngx_memzero(&url, sizeof(ngx_str_t));\n\n        if(ngx_rtmp_eval(s, &target->url.url, ngx_rtmp_relay_eval,\n                         &url, s->connection->log) == NGX_OK)\n        {\n            target->url.default_port = 1935;\n            target->url.uri_part = 1;\n            target->url.url = url;\n\n            target->url.addrs = NULL;\n            target->url.naddrs = 0;\n\n            if(ngx_parse_url(s->connection->pool, &target->url) != NGX_OK) {\n                ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                              \"relay: invalid url='%V'\", &target->url.url);\n                goto error;\n            }\n        } else {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"relay: failed to eval url='%V'\", &target->url.url);\n            goto error;\n        }\n    }\n\n    rctx = ngx_rtmp_relay_create_connection(&cctx, name, target);\n    if (rctx) {\n        rctx->server_name.data = s->host_start;\n        rctx->server_name.len = s->host_end - s->host_start;\n    }\n\nerror:\n    target->url = save;\n    if (url.len) {\n        ngx_free(url.data);\n\tngx_memzero(&url, sizeof(ngx_str_t));\n    }\n\n    return rctx;\n}\n\n\nstatic ngx_rtmp_relay_ctx_t *\nngx_rtmp_relay_create_local_ctx(ngx_rtmp_session_t *s, ngx_str_t *name,\n        ngx_rtmp_relay_target_t *target)\n{\n    ngx_rtmp_relay_ctx_t           *ctx;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"relay: create local context\");\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL) {\n        ctx = ngx_pcalloc(s->connection->pool, sizeof(ngx_rtmp_relay_ctx_t));\n        if (ctx == NULL) {\n            return NULL;\n        }\n        ngx_rtmp_set_ctx(s, ctx, ngx_rtmp_relay_module);\n    }\n    ctx->session = s;\n\n    ctx->push_evt.data = s;\n    ctx->push_evt.log = s->connection->log;\n    ctx->push_evt.handler = ngx_rtmp_relay_push_reconnect;\n\n    if (ctx->publish) {\n        return NULL;\n    }\n\n    if (ngx_rtmp_relay_copy_str(s->connection->pool, &ctx->name, name)\n            != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return ctx;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_create(ngx_rtmp_session_t *s, ngx_str_t *name,\n        ngx_rtmp_relay_target_t *target,\n        ngx_rtmp_relay_create_ctx_pt create_publish_ctx,\n        ngx_rtmp_relay_create_ctx_pt create_play_ctx)\n{\n    ngx_rtmp_relay_app_conf_t      *racf;\n    ngx_rtmp_relay_ctx_t           *publish_ctx, *play_ctx, **cctx;\n    ngx_uint_t                      hash;\n\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n    if (racf == NULL) {\n        return NGX_ERROR;\n    }\n\n    play_ctx = create_play_ctx(s, name, target);\n    if (play_ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    hash = ngx_hash_key(name->data, name->len);\n    cctx = &racf->ctx[hash % racf->nbuckets];\n    for (; *cctx; cctx = &(*cctx)->next) {\n        if ((*cctx)->name.len == name->len\n            && !ngx_memcmp(name->data, (*cctx)->name.data,\n                name->len))\n        {\n            break;\n        }\n    }\n\n    if (*cctx) {\n        play_ctx->publish = (*cctx)->publish;\n        play_ctx->next = (*cctx)->play;\n        (*cctx)->play = play_ctx;\n        return NGX_OK;\n    }\n\n    publish_ctx = create_publish_ctx(s, name, target);\n    if (publish_ctx == NULL) {\n        ngx_rtmp_finalize_session(play_ctx->session);\n        return NGX_ERROR;\n    }\n\n    publish_ctx->publish = publish_ctx;\n    publish_ctx->play = play_ctx;\n    play_ctx->publish = publish_ctx;\n    *cctx = publish_ctx;\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_relay_pull(ngx_rtmp_session_t *s, ngx_str_t *name,\n        ngx_rtmp_relay_target_t *target)\n{\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n            \"relay: create pull name='%V' app='%V' playpath='%V' \"\n            \"url='%V' args='%V'\",\n            name, &target->app, &target->play_path,\n            &target->url.url, &s->args);\n\n    return ngx_rtmp_relay_create(s, name, target,\n            ngx_rtmp_relay_create_remote_ctx,\n            ngx_rtmp_relay_create_local_ctx);\n}\n\n\nngx_int_t\nngx_rtmp_relay_push(ngx_rtmp_session_t *s, ngx_str_t *name,\n        ngx_rtmp_relay_target_t *target)\n{\n    ngx_log_error(NGX_LOG_INFO, s->connection->log, 0,\n            \"relay: create push name='%V' app='%V' playpath='%V' \"\n            \"url='%V' args='%V'\",\n            name, &target->app, &target->play_path,\n            &target->url.url, &s->args);\n\n    return ngx_rtmp_relay_create(s, name, target,\n            ngx_rtmp_relay_create_local_ctx,\n            ngx_rtmp_relay_create_remote_ctx);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_publish(ngx_rtmp_session_t *s, ngx_rtmp_publish_t *v)\n{\n    ngx_rtmp_relay_app_conf_t      *racf;\n    ngx_rtmp_relay_target_t        *target, **t;\n    ngx_str_t                       name;\n    size_t                          n;\n    ngx_rtmp_relay_ctx_t           *ctx;\n\n    if (s->auto_pushed) {\n        goto next;\n    }\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx && s->relay) {\n        goto next;\n    }\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n    if (racf == NULL || racf->pushes.nelts == 0) {\n        goto next;\n    }\n\n    name.len = ngx_strlen(v->name);\n    name.data = v->name;\n\n    t = racf->pushes.elts;\n    for (n = 0; n < racf->pushes.nelts; ++n, ++t) {\n        target = *t;\n\n        if (target->name.len && (name.len != target->name.len ||\n            ngx_memcmp(name.data, target->name.data, name.len)))\n        {\n            continue;\n        }\n\n        if (ngx_rtmp_relay_push(s, &name, target) == NGX_OK) {\n            continue;\n        }\n\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                \"relay: push failed name='%V' app='%V' \"\n                \"playpath='%V' url='%V' args='%V'\",\n                &name, &target->app, &target->play_path,\n                &target->url.url, &s->args);\n\n        /* ctx == NULL && s->relay == 0, BOOM! */\n        ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n        if (ctx && !ctx->push_evt.timer_set) {\n            ngx_add_timer(&ctx->push_evt, racf->push_reconnect);\n        }\n    }\n\nnext:\n    return next_publish(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_play(ngx_rtmp_session_t *s, ngx_rtmp_play_t *v)\n{\n    ngx_rtmp_relay_app_conf_t      *racf;\n    ngx_rtmp_relay_target_t        *target, **t;\n    ngx_str_t                       name;\n    size_t                          n;\n    ngx_rtmp_relay_ctx_t           *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx && s->relay) {\n        goto next;\n    }\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n    if (racf == NULL || racf->pulls.nelts == 0) {\n        goto next;\n    }\n\n    name.len = ngx_strlen(v->name);\n    name.data = v->name;\n\n    t = racf->pulls.elts;\n    for (n = 0; n < racf->pulls.nelts; ++n, ++t) {\n        target = *t;\n\n        if (target->name.len && (name.len != target->name.len ||\n            ngx_memcmp(name.data, target->name.data, name.len)))\n        {\n            continue;\n        }\n\n        if (ngx_rtmp_relay_pull(s, &name, target) == NGX_OK) {\n            continue;\n        }\n\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                \"relay: pull failed name='%V' app='%V' \"\n                \"playpath='%V' url='%V' args='%V'\",\n                &name, &target->app, &target->play_path,\n                &target->url.url, &s->args);\n    }\n\nnext:\n    return next_play(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_play_local(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_play_t             v;\n    ngx_rtmp_relay_ctx_t       *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(&v, sizeof(ngx_rtmp_play_t));\n    v.silent = 1;\n    *(ngx_cpymem(v.name, ctx->name.data,\n            ngx_min(sizeof(v.name) - 1, ctx->name.len))) = 0;\n\n    return ngx_rtmp_play(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_publish_local(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_publish_t          v;\n    ngx_rtmp_relay_ctx_t       *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(&v, sizeof(ngx_rtmp_publish_t));\n    v.silent = 1;\n    *(ngx_cpymem(v.name, ctx->name.data,\n            ngx_min(sizeof(v.name) - 1, ctx->name.len))) = 0;\n\n    return ngx_rtmp_publish(s, &v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_send_connect(ngx_rtmp_session_t *s)\n{\n    static double               trans = NGX_RTMP_RELAY_CONNECT_TRANS;\n    static double               acodecs = 3575;\n    static double               vcodecs = 252;\n\n    static ngx_rtmp_amf_elt_t   out_cmd[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"app\"),\n          NULL, 0 }, /* <-- fill */\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"tcUrl\"),\n          NULL, 0 }, /* <-- fill */\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"pageUrl\"),\n          NULL, 0 }, /* <-- fill */\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"swfUrl\"),\n          NULL, 0 }, /* <-- fill */\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"flashVer\"),\n          NULL, 0 }, /* <-- fill */\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"serverName\"),\n          NULL, 0 }, /* <-- fill */\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"audioCodecs\"),\n          &acodecs, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"videoCodecs\"),\n          &vcodecs, 0 }\n    };\n\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"connect\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_cmd, sizeof(out_cmd) }\n    };\n\n    ngx_rtmp_core_app_conf_t   *cacf;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_rtmp_relay_ctx_t       *ctx;\n    ngx_rtmp_header_t           h;\n    size_t                      len, url_len;\n    u_char                     *p, *url_end;\n\n\n    cacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_core_module);\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (cacf == NULL || ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    /* app */\n    if (ctx->app.len) {\n        out_cmd[0].data = ctx->app.data;\n        out_cmd[0].len  = ctx->app.len;\n    } else {\n        out_cmd[0].data = cacf->name.data;\n        out_cmd[0].len  = cacf->name.len;\n    }\n\n    /* tcUrl */\n    if (ctx->tc_url.len) {\n        out_cmd[1].data = ctx->tc_url.data;\n        out_cmd[1].len  = ctx->tc_url.len;\n    } else {\n        len = sizeof(\"rtmp://\") - 1 + ctx->url.len +\n            sizeof(\"/\") - 1 + ctx->app.len;\n        p = ngx_palloc(s->connection->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n        out_cmd[1].data = p;\n        p = ngx_cpymem(p, \"rtmp://\", sizeof(\"rtmp://\") - 1);\n\n        url_len = ctx->url.len;\n        url_end = ngx_strlchr(ctx->url.data, ctx->url.data + ctx->url.len, '/');\n        if (url_end) {\n            url_len = (size_t) (url_end - ctx->url.data);\n        }\n\n        p = ngx_cpymem(p, ctx->url.data, url_len);\n        *p++ = '/';\n        p = ngx_cpymem(p, ctx->app.data, ctx->app.len);\n        out_cmd[1].len = p - (u_char *)out_cmd[1].data;\n    }\n\n    /* pageUrl */\n    out_cmd[2].data = ctx->page_url.data;\n    out_cmd[2].len  = ctx->page_url.len;\n\n    /* swfUrl */\n    out_cmd[3].data = ctx->swf_url.data;\n    out_cmd[3].len  = ctx->swf_url.len;\n\n    /* flashVer */\n    if (ctx->flash_ver.len) {\n        out_cmd[4].data = ctx->flash_ver.data;\n        out_cmd[4].len  = ctx->flash_ver.len;\n    } else {\n        out_cmd[4].data = NGX_RTMP_RELAY_FLASHVER;\n        out_cmd[4].len  = sizeof(NGX_RTMP_RELAY_FLASHVER) - 1;\n    }\n\n    /* used in ngx_rtmp_set_virtual_server when auto_pushed */\n    out_cmd[5].data = ctx->server_name.data;\n    out_cmd[5].len = ctx->server_name.len;\n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_RELAY_CSID_AMF_INI;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n    return ngx_rtmp_send_chunk_size(s, cscf->chunk_size) != NGX_OK\n        || ngx_rtmp_send_ack_size(s, cscf->ack_window) != NGX_OK\n        || ngx_rtmp_send_amf(s, &h, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0])) != NGX_OK\n        ? NGX_ERROR\n        : NGX_OK;\n}\n\n\n#if 0\nstatic ngx_int_t\nngx_rtmp_relay_send_release_stream(ngx_rtmp_session_t *s)\n{\n    static double               trans = NGX_RTMP_RELAY_RELEASE_STREAM_TRANS;\n\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"releaseStream\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"stream\"),\n          NULL, 0 }\n    };\n\n    ngx_rtmp_header_t           h;\n\n    ngx_rtmp_core_app_conf_t   *cacf;\n    ngx_rtmp_relay_ctx_t       *ctx;\n\n    cacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_core_module);\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (cacf == NULL || ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->name.len) {\n        out_elts[3].data = ctx->name.data;\n        out_elts[3].len  = ctx->name.len;\n    } \n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_RELAY_CSID_AMF_INI;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n    return ngx_rtmp_send_amf(s, &h, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_send_fcpublish(ngx_rtmp_session_t *s)\n{\n    static double               trans = NGX_RTMP_RELAY_FCPUBLISH_STREAM_TRANS;\n\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"FCPublish\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"stream\"),\n          NULL, 0 }\n    };\n\n    ngx_rtmp_header_t           h;\n\n    ngx_rtmp_core_app_conf_t   *cacf;\n    ngx_rtmp_relay_ctx_t       *ctx;\n\n    cacf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_core_module);\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (cacf == NULL || ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->name.len) {\n        out_elts[3].data = ctx->name.data;\n        out_elts[3].len  = ctx->name.len;\n    } \n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_RELAY_CSID_AMF_INI;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n    return ngx_rtmp_send_amf(s, &h, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0]));\n}\n#endif\n\n\nstatic ngx_int_t\nngx_rtmp_relay_send_create_stream(ngx_rtmp_session_t *s)\n{\n    static double               trans = NGX_RTMP_RELAY_CREATE_STREAM_TRANS;\n\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"createStream\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 }\n    };\n\n    ngx_rtmp_header_t           h;\n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_RELAY_CSID_AMF_INI;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n#if 0\n    return ngx_rtmp_relay_send_release_stream(s) != NGX_OK\n           || ngx_rtmp_relay_send_fcpublish(s) != NGX_OK \n           || ngx_rtmp_send_amf(s, &h, out_elts,\n              sizeof(out_elts) / sizeof(out_elts[0])) != NGX_OK\n           ? NGX_ERROR\n           : NGX_OK;\n#endif\n\n    return ngx_rtmp_send_amf(s, &h, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_send_publish(ngx_rtmp_session_t *s)\n{\n    static double               trans;\n\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"publish\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          NULL, 0 }, /* <- to fill */\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"live\", 0 }\n    };\n\n    ngx_rtmp_header_t           h;\n    ngx_rtmp_relay_ctx_t       *ctx;\n\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->play_path.len) {\n        out_elts[3].data = ctx->play_path.data;\n        out_elts[3].len  = ctx->play_path.len;\n    } else {\n        out_elts[3].data = ctx->name.data;\n        out_elts[3].len  = ctx->name.len;\n    }\n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_RELAY_CSID_AMF;\n    h.msid = NGX_RTMP_RELAY_MSID;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n    return ngx_rtmp_send_amf(s, &h, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_send_play(ngx_rtmp_session_t *s)\n{\n    static double               trans;\n    static double               start, duration;\n\n    static ngx_rtmp_amf_elt_t   out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"play\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          NULL, 0 }, /* <- fill */\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &start, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &duration, 0 },\n    };\n\n    ngx_rtmp_header_t           h;\n    ngx_rtmp_relay_ctx_t       *ctx;\n    ngx_rtmp_relay_app_conf_t  *racf;\n\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (racf == NULL || ctx == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (ctx->play_path.len) {\n        out_elts[3].data = ctx->play_path.data;\n        out_elts[3].len  = ctx->play_path.len;\n    } else {\n        out_elts[3].data = ctx->name.data;\n        out_elts[3].len  = ctx->name.len;\n    }\n\n    if (ctx->live) {\n        start = -1000;\n        duration = -1000;\n    } else {\n        start    = (ctx->start ? ctx->start : -2000);\n        duration = (ctx->stop  ? ctx->stop - ctx->start : -1000);\n    }\n\n    ngx_memzero(&h, sizeof(h));\n    h.csid = NGX_RTMP_RELAY_CSID_AMF;\n    h.msid = NGX_RTMP_RELAY_MSID;\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n\n    return ngx_rtmp_send_amf(s, &h, out_elts,\n            sizeof(out_elts) / sizeof(out_elts[0])) != NGX_OK\n           || ngx_rtmp_send_set_buflen(s, NGX_RTMP_RELAY_MSID,\n                   racf->buflen) != NGX_OK\n           ? NGX_ERROR\n           : NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_on_result(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_relay_ctx_t       *ctx;\n    static struct {\n        double                  trans;\n        u_char                  level[32];\n        u_char                  code[128];\n        u_char                  desc[1024];\n    } v;\n\n    static ngx_rtmp_amf_elt_t   in_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          &v.level, sizeof(v.level) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          &v.code, sizeof(v.code) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          &v.desc, sizeof(v.desc) },\n    };\n\n    static ngx_rtmp_amf_elt_t   in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_inf, sizeof(in_inf) },\n    };\n\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL || !s->relay) {\n        return NGX_OK;\n    }\n\n    ngx_memzero(&v, sizeof(v));\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"relay: _result: level='%s' code='%s' description='%s'\",\n            v.level, v.code, v.desc);\n\n    switch ((ngx_int_t)v.trans) {\n        case NGX_RTMP_RELAY_CONNECT_TRANS:\n            return ngx_rtmp_relay_send_create_stream(s);\n\n        case NGX_RTMP_RELAY_CREATE_STREAM_TRANS:\n            if (ctx->publish != ctx && !s->static_relay) {\n                if (ngx_rtmp_relay_send_publish(s) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                return ngx_rtmp_relay_play_local(s);\n\n            } else {\n                if (ngx_rtmp_relay_send_play(s) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n                return ngx_rtmp_relay_publish_local(s);\n            }\n\n        default:\n            return NGX_OK;\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_on_error(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_relay_ctx_t       *ctx;\n    static struct {\n        double                  trans;\n        u_char                  level[32];\n        u_char                  code[128];\n        u_char                  desc[1024];\n    } v;\n\n    static ngx_rtmp_amf_elt_t   in_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          &v.level, sizeof(v.level) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          &v.code, sizeof(v.code) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          &v.desc, sizeof(v.desc) },\n    };\n\n    static ngx_rtmp_amf_elt_t   in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_inf, sizeof(in_inf) },\n    };\n\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL || !s->relay) {\n        return NGX_OK;\n    }\n\n    ngx_memzero(&v, sizeof(v));\n    if (ngx_rtmp_receive_amf(s, in, in_elts,\n                sizeof(in_elts) / sizeof(in_elts[0])))\n    {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"relay: _error: level='%s' code='%s' description='%s'\",\n            v.level, v.code, v.desc);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_on_status(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_relay_ctx_t       *ctx;\n    static struct {\n        double                  trans;\n        u_char                  level[32];\n        u_char                  code[128];\n        u_char                  desc[1024];\n    } v;\n\n    static ngx_rtmp_amf_elt_t   in_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          &v.level, sizeof(v.level) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          &v.code, sizeof(v.code) },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          &v.desc, sizeof(v.desc) },\n    };\n\n    static ngx_rtmp_amf_elt_t   in_elts[] = {\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &v.trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_inf, sizeof(in_inf) },\n    };\n\n    static ngx_rtmp_amf_elt_t   in_elts_meta[] = {\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          in_inf, sizeof(in_inf) },\n    };\n\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL || !s->relay) {\n        return NGX_OK;\n    }\n\n    ngx_memzero(&v, sizeof(v));\n    if (h->type == NGX_RTMP_MSG_AMF_META) {\n        ngx_rtmp_receive_amf(s, in, in_elts_meta,\n                sizeof(in_elts_meta) / sizeof(in_elts_meta[0]));\n    } else {\n        ngx_rtmp_receive_amf(s, in, in_elts,\n                sizeof(in_elts) / sizeof(in_elts[0]));\n    }\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n            \"relay: onStatus: level='%s' code='%s' description='%s'\",\n            v.level, v.code, v.desc);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_handshake_done(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n        ngx_chain_t *in)\n{\n    ngx_rtmp_relay_ctx_t   *ctx;\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL || !s->relay) {\n        return NGX_OK;\n    }\n\n    return ngx_rtmp_relay_send_connect(s);\n}\n\n\nstatic void\nngx_rtmp_relay_close(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_relay_app_conf_t          *racf;\n    ngx_rtmp_relay_ctx_t               *ctx, **cctx, **next;\n    ngx_uint_t                          hash;\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n\n    ctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_relay_module);\n    if (ctx == NULL) {\n        return;\n    }\n\n    if (s->static_relay) {\n        ngx_add_timer(ctx->static_evt, racf->pull_reconnect);\n    }\n\n    if (ctx->publish == NULL) {\n        return;\n    }\n\n    /* play end disconnect? */\n    if (ctx->publish != ctx) {\n        for (cctx = &ctx->publish->play; *cctx; cctx = &(*cctx)->next) {\n            if (*cctx == ctx) {\n                *cctx = ctx->next;\n                break;\n            }\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, ctx->session->connection->log, 0,\n                \"relay: play disconnect app='%V' name='%V'\",\n                &ctx->app, &ctx->name);\n\n        /* push reconnect */\n        if (s->relay && ctx->tag == &ngx_rtmp_relay_module &&\n            !ctx->publish->push_evt.timer_set)\n        {\n            ngx_add_timer(&ctx->publish->push_evt, racf->push_reconnect);\n        }\n\n#ifdef NGX_DEBUG\n        {\n            ngx_uint_t  n = 0;\n            for (cctx = &ctx->publish->play; *cctx; cctx = &(*cctx)->next, ++n);\n            ngx_log_debug3(NGX_LOG_DEBUG_RTMP, ctx->session->connection->log, 0,\n                \"relay: play left after disconnect app='%V' name='%V': %ui\",\n                &ctx->app, &ctx->name, n);\n        }\n#endif\n\n        if (ctx->publish->play == NULL && ctx->publish->session->relay) {\n            ngx_log_debug2(NGX_LOG_DEBUG_RTMP,\n                 ctx->publish->session->connection->log, 0,\n                \"relay: publish disconnect empty app='%V' name='%V'\",\n                &ctx->app, &ctx->name);\n            ngx_rtmp_finalize_session(ctx->publish->session);\n        }\n\n        ctx->publish = NULL;\n\n        return;\n    }\n\n    /* publish end disconnect */\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, ctx->session->connection->log, 0,\n            \"relay: publish disconnect app='%V' name='%V'\",\n            &ctx->app, &ctx->name);\n\n    if (ctx->push_evt.timer_set) {\n        ngx_del_timer(&ctx->push_evt);\n    }\n\n    for (cctx = &ctx->play; *cctx; /* cctx = &(*cctx)->next */) {\n        (*cctx)->publish = NULL;\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, (*cctx)->session->connection->log,\n            0, \"relay: play disconnect orphan app='%V' name='%V'\",\n            &(*cctx)->app, &(*cctx)->name);\n\n        next = &(*cctx)->next;\n\n        ngx_rtmp_finalize_session((*cctx)->session);\n\n        cctx = next;\n    }\n    ctx->publish = NULL;\n\n    hash = ngx_hash_key(ctx->name.data, ctx->name.len);\n    cctx = &racf->ctx[hash % racf->nbuckets];\n    for (; *cctx && *cctx != ctx; cctx = &(*cctx)->next);\n    if (*cctx) {\n        *cctx = ctx->next;\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_close_stream(ngx_rtmp_session_t *s, ngx_rtmp_close_stream_t *v)\n{\n    ngx_rtmp_relay_app_conf_t  *racf;\n\n    racf = ngx_rtmp_get_module_app_conf(s, ngx_rtmp_relay_module);\n    if (racf && !racf->session_relay) {\n        ngx_rtmp_relay_close(s);\n    }\n\n    return next_close_stream(s, v);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_delete_stream(ngx_rtmp_session_t *s, ngx_rtmp_delete_stream_t *v)\n{\n    ngx_rtmp_relay_close(s);\n\n    return next_delete_stream(s, v);\n}\n\n\nstatic char *\nngx_rtmp_relay_push_pull(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_str_t                          *value, v, n;\n    ngx_rtmp_relay_app_conf_t          *racf;\n    ngx_rtmp_relay_target_t            *target, **t;\n    ngx_url_t                          *u;\n    ngx_uint_t                          i;\n    ngx_int_t                           is_pull, is_static;\n    ngx_event_t                       **ee, *e;\n    ngx_rtmp_relay_static_t            *rs;\n    u_char                             *p;\n\n    value = cf->args->elts;\n\n    racf = ngx_rtmp_conf_get_module_app_conf(cf, ngx_rtmp_relay_module);\n\n    is_pull = (value[0].data[3] == 'l');\n    is_static = 0;\n\n    target = ngx_pcalloc(cf->pool, sizeof(*target));\n    if (target == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    target->tag = &ngx_rtmp_relay_module;\n    target->data = target;\n\n    u = &target->url;\n    u->default_port = 1935;\n    u->uri_part = 1;\n    u->url = value[1];\n\n    if (ngx_strncasecmp(u->url.data, (u_char *) \"rtmp://\", 7) == 0) {\n        u->url.data += 7;\n        u->url.len  -= 7;\n    }\n\n    if (ngx_parse_url(cf->pool, u) != NGX_OK) {\n        if (u->err) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                    \"%s in url \\\"%V\\\"\", u->err, &u->url);\n        }\n        return NGX_CONF_ERROR;\n    }\n\n    value += 2;\n    for (i = 2; i < cf->args->nelts; ++i, ++value) {\n        p = ngx_strlchr(value->data, value->data + value->len, '=');\n\n        if (p == NULL) {\n            n = *value;\n            ngx_str_set(&v, \"1\");\n\n        } else {\n            n.data = value->data;\n            n.len  = p - value->data;\n\n            v.data = p + 1;\n            v.len  = value->data + value->len - p - 1;\n        }\n\n#define NGX_RTMP_RELAY_STR_PAR(name, var)                                     \\\n        if (n.len == sizeof(name) - 1                                         \\\n            && ngx_strncasecmp(n.data, (u_char *) name, n.len) == 0)          \\\n        {                                                                     \\\n            target->var = v;                                                  \\\n            continue;                                                         \\\n        }\n\n#define NGX_RTMP_RELAY_NUM_PAR(name, var)                                     \\\n        if (n.len == sizeof(name) - 1                                         \\\n            && ngx_strncasecmp(n.data, (u_char *) name, n.len) == 0)          \\\n        {                                                                     \\\n            target->var = ngx_atoi(v.data, v.len);                            \\\n            continue;                                                         \\\n        }\n\n        NGX_RTMP_RELAY_STR_PAR(\"app\",         app);\n        NGX_RTMP_RELAY_STR_PAR(\"name\",        name);\n        NGX_RTMP_RELAY_STR_PAR(\"tcUrl\",       tc_url);\n        NGX_RTMP_RELAY_STR_PAR(\"pageUrl\",     page_url);\n        NGX_RTMP_RELAY_STR_PAR(\"swfUrl\",      swf_url);\n        NGX_RTMP_RELAY_STR_PAR(\"flashVer\",    flash_ver);\n        NGX_RTMP_RELAY_STR_PAR(\"playPath\",    play_path);\n        NGX_RTMP_RELAY_NUM_PAR(\"live\",        live);\n        NGX_RTMP_RELAY_NUM_PAR(\"start\",       start);\n        NGX_RTMP_RELAY_NUM_PAR(\"stop\",        stop);\n\n#undef NGX_RTMP_RELAY_STR_PAR\n#undef NGX_RTMP_RELAY_NUM_PAR\n\n        if (n.len == sizeof(\"static\") - 1 &&\n            ngx_strncasecmp(n.data, (u_char *) \"static\", n.len) == 0 &&\n            ngx_atoi(v.data, v.len))\n        {\n            is_static = 1;\n            continue;\n        }\n\n        return \"unsuppored parameter\";\n    }\n\n    if (is_static) {\n\n        if (!is_pull) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"static push is not allowed\");\n            return NGX_CONF_ERROR;\n        }\n\n        if (ngx_strlchr(target->url.url.data,\n                        target->url.url.data + target->url.url.len, '$'))\n        {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"variable is not allowed\");\n            return NGX_CONF_ERROR;\n        }\n\n        if (target->name.len == 0) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"stream name missing in static pull \"\n                               \"declaration\");\n            return NGX_CONF_ERROR;\n        }\n\n        ee = ngx_array_push(&racf->static_events);\n        if (ee == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        e = ngx_pcalloc(cf->pool, sizeof(ngx_event_t));\n        if (e == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *ee = e;\n\n        rs = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_relay_static_t));\n        if (rs == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        rs->target = target;\n\n        e->data = rs;\n        e->log = &cf->cycle->new_log;\n        e->handler = ngx_rtmp_relay_static_pull_reconnect;\n\n        t = ngx_array_push(&racf->static_pulls);\n\n    } else if (is_pull) {\n        t = ngx_array_push(&racf->pulls);\n\n    } else {\n        t = ngx_array_push(&racf->pushes);\n    }\n\n    if (t == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *t = target;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_init_process(ngx_cycle_t *cycle)\n{\n#if !(NGX_WIN32)\n    ngx_rtmp_core_main_conf_t  *cmcf = ngx_rtmp_core_main_conf;\n    ngx_rtmp_core_srv_conf_t  **pcscf, *cscf;\n    ngx_rtmp_core_app_conf_t  **pcacf, *cacf;\n    ngx_rtmp_relay_app_conf_t  *racf;\n    ngx_uint_t                  n, m, k;\n    ngx_rtmp_relay_static_t    *rs;\n    ngx_event_t               **pevent, *event;\n\n    if (cmcf == NULL || cmcf->servers.nelts == 0) {\n        return NGX_OK;\n    }\n\n    /* only first worker does static pulling */\n\n    if (ngx_process_slot) {\n        return NGX_OK;\n    }\n\n    pcscf = cmcf->servers.elts;\n    for (n = 0; n < cmcf->servers.nelts; ++n, ++pcscf) {\n\n        cscf = *pcscf;\n        pcacf = cscf->applications.elts;\n\n        for (m = 0; m < cscf->applications.nelts; ++m, ++pcacf) {\n\n            cacf = *pcacf;\n            racf = cacf->app_conf[ngx_rtmp_relay_module.ctx_index];\n            pevent = racf->static_events.elts;\n\n            for (k = 0; k < racf->static_events.nelts; ++k, ++pevent) {\n                event = *pevent;\n\n                rs = event->data;\n                rs->cctx = *cscf->ctx;\n                rs->cctx.app_conf = cacf->app_conf;\n\n                ngx_post_event(event, &ngx_rtmp_init_queue);\n            }\n        }\n    }\n#endif\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_relay_postconfiguration(ngx_conf_t *cf)\n{\n    ngx_rtmp_core_main_conf_t          *cmcf;\n    ngx_rtmp_handler_pt                *h;\n    ngx_rtmp_amf_handler_t             *ch;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n\n    h = ngx_array_push(&cmcf->events[NGX_RTMP_HANDSHAKE_DONE]);\n    *h = ngx_rtmp_relay_handshake_done;\n\n\n    next_publish = ngx_rtmp_publish;\n    ngx_rtmp_publish = ngx_rtmp_relay_publish;\n\n    next_play = ngx_rtmp_play;\n    ngx_rtmp_play = ngx_rtmp_relay_play;\n\n    next_delete_stream = ngx_rtmp_delete_stream;\n    ngx_rtmp_delete_stream = ngx_rtmp_relay_delete_stream;\n\n    next_close_stream = ngx_rtmp_close_stream;\n    ngx_rtmp_close_stream = ngx_rtmp_relay_close_stream;\n\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"_result\");\n    ch->handler = ngx_rtmp_relay_on_result;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"_error\");\n    ch->handler = ngx_rtmp_relay_on_error;\n\n    ch = ngx_array_push(&cmcf->amf);\n    ngx_str_set(&ch->name, \"onStatus\");\n    ch->handler = ngx_rtmp_relay_on_status;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_relay_module.h",
          "type": "blob",
          "size": 2.9130859375,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_RELAY_H_INCLUDED_\n#define _NGX_RTMP_RELAY_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\ntypedef struct {\n    ngx_url_t                       url;\n    ngx_str_t                       app;\n    ngx_str_t                       name;\n    ngx_str_t                       tc_url;\n    ngx_str_t                       page_url;\n    ngx_str_t                       swf_url;\n    ngx_str_t                       flash_ver;\n    ngx_str_t                       play_path;\n    ngx_int_t                       live;\n    ngx_int_t                       start;\n    ngx_int_t                       stop;\n\n    void                           *tag;     /* usually module reference */\n    void                           *data;    /* module-specific data */\n    ngx_uint_t                      counter; /* mutable connection counter */\n} ngx_rtmp_relay_target_t;\n\n\ntypedef struct ngx_rtmp_relay_ctx_s ngx_rtmp_relay_ctx_t;\n\nstruct ngx_rtmp_relay_ctx_s {\n    ngx_str_t                       server_name;\n    ngx_str_t                       name;\n    ngx_str_t                       url;\n    ngx_log_t                       log;\n    ngx_rtmp_session_t             *session;\n    ngx_rtmp_relay_ctx_t           *publish;\n    ngx_rtmp_relay_ctx_t           *play;\n    ngx_rtmp_relay_ctx_t           *next;\n\n    ngx_str_t                       app;\n    ngx_str_t                       tc_url;\n    ngx_str_t                       page_url;\n    ngx_str_t                       swf_url;\n    ngx_str_t                       flash_ver;\n    ngx_str_t                       play_path;\n    ngx_int_t                       live;\n    ngx_int_t                       start;\n    ngx_int_t                       stop;\n\n    ngx_event_t                     push_evt;\n    ngx_event_t                    *static_evt;\n    void                           *tag;\n    void                           *data;\n};\n\n\ntypedef struct {\n    ngx_array_t                 pulls;         /* ngx_rtmp_relay_target_t * */\n    ngx_array_t                 pushes;        /* ngx_rtmp_relay_target_t * */\n    ngx_array_t                 static_pulls;  /* ngx_rtmp_relay_target_t * */\n    ngx_array_t                 static_events; /* ngx_event_t * */\n    ngx_log_t                  *log;\n    ngx_uint_t                  nbuckets;\n    ngx_msec_t                  buflen;\n    ngx_flag_t                  session_relay;\n    ngx_msec_t                  push_reconnect;\n    ngx_msec_t                  pull_reconnect;\n    ngx_rtmp_relay_ctx_t        **ctx;\n} ngx_rtmp_relay_app_conf_t;\n\n\nextern ngx_module_t                 ngx_rtmp_relay_module;\n\n\nngx_int_t ngx_rtmp_relay_pull(ngx_rtmp_session_t *s, ngx_str_t *name,\n                              ngx_rtmp_relay_target_t *target);\nngx_int_t ngx_rtmp_relay_push(ngx_rtmp_session_t *s, ngx_str_t *name,\n                              ngx_rtmp_relay_target_t *target);\n\n\n#endif /* _NGX_RTMP_RELAY_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_send.c",
          "type": "blob",
          "size": 18.5634765625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_amf.h\"\n#include \"ngx_rtmp_streams.h\"\n#include \"ngx_rtmp_cmd_module.h\"\n\n\n#define NGX_RTMP_USER_START(s, tp)                                          \\\n    ngx_rtmp_header_t               __h;                                    \\\n    ngx_chain_t                    *__l;                                    \\\n    ngx_buf_t                      *__b;                                    \\\n    ngx_rtmp_core_srv_conf_t       *__cscf;                                 \\\n                                                                            \\\n    __cscf = ngx_rtmp_get_module_srv_conf(                                  \\\n            s, ngx_rtmp_core_module);                                       \\\n    memset(&__h, 0, sizeof(__h));                                           \\\n    __h.type = tp;                                                          \\\n    __h.csid = 2;                                                           \\\n    __l = ngx_rtmp_alloc_shared_buf(__cscf);                                \\\n    if (__l == NULL) {                                                      \\\n        return NULL;                                                        \\\n    }                                                                       \\\n    __b = __l->buf;\n\n#define NGX_RTMP_UCTL_START(s, type, utype)                                 \\\n    NGX_RTMP_USER_START(s, type);                                           \\\n    *(__b->last++) = (u_char)((utype) >> 8);                                \\\n    *(__b->last++) = (u_char)(utype);\n\n#define NGX_RTMP_USER_OUT1(v)                                               \\\n    *(__b->last++) = (u_char) v;\n\n#define NGX_RTMP_USER_OUT4(v)                                               \\\n    *(__b->last++) = (u_char) (v >> 24);                                    \\\n    *(__b->last++) = (u_char) (v >> 16);                                    \\\n    *(__b->last++) = (u_char) (v >> 8);                                     \\\n    *(__b->last++) = (u_char) v;\n\n#define NGX_RTMP_USER_END(s)                                                \\\n    ngx_rtmp_prepare_message(s, &__h, NULL, __l);                           \\\n    return __l;\n\n\nstatic ngx_int_t\nngx_rtmp_send_shared_packet(ngx_rtmp_session_t *s, ngx_chain_t *cl)\n{\n    ngx_rtmp_core_srv_conf_t       *cscf;\n    ngx_http_request_t             *r;\n    ngx_int_t                       rc;\n\n    if (cl == NULL) {\n        return NGX_ERROR;\n    }\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    if (!s->relay) {\n        /* rquest from http */\n        r = s->data;\n        if (r) {\n            ngx_rtmp_free_shared_chain(cscf, cl);\n\n            return NGX_OK;\n        }\n    }\n\n    rc = ngx_rtmp_send_message(s, cl, 0);\n\n    ngx_rtmp_free_shared_chain(cscf, cl);\n\n    return rc;\n}\n\n\n/* Protocol control messages */\n\nngx_chain_t *\nngx_rtmp_create_chunk_size(ngx_rtmp_session_t *s, uint32_t chunk_size)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"chunk_size=%uD\", chunk_size);\n\n    {\n        NGX_RTMP_USER_START(s, NGX_RTMP_MSG_CHUNK_SIZE);\n\n        NGX_RTMP_USER_OUT4(chunk_size);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_chunk_size(ngx_rtmp_session_t *s, uint32_t chunk_size)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_chunk_size(s, chunk_size));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_abort(ngx_rtmp_session_t *s, uint32_t csid)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: abort csid=%uD\", csid);\n\n    {\n        NGX_RTMP_USER_START(s, NGX_RTMP_MSG_ABORT);\n\n        NGX_RTMP_USER_OUT4(csid);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_abort(ngx_rtmp_session_t *s, uint32_t csid)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_abort(s, csid));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_ack(ngx_rtmp_session_t *s, uint32_t seq)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: ack seq=%uD\", seq);\n\n    {\n        NGX_RTMP_USER_START(s, NGX_RTMP_MSG_ACK);\n\n        NGX_RTMP_USER_OUT4(seq);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_ack(ngx_rtmp_session_t *s, uint32_t seq)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_ack(s, seq));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_ack_size(ngx_rtmp_session_t *s, uint32_t ack_size)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: ack_size=%uD\", ack_size);\n\n    {\n        NGX_RTMP_USER_START(s, NGX_RTMP_MSG_ACK_SIZE);\n\n        NGX_RTMP_USER_OUT4(ack_size);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_ack_size(ngx_rtmp_session_t *s, uint32_t ack_size)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_ack_size(s, ack_size));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_bandwidth(ngx_rtmp_session_t *s, uint32_t ack_size,\n                          uint8_t limit_type)\n{\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: bandwidth ack_size=%uD limit=%d\",\n                   ack_size, (int)limit_type);\n\n    {\n        NGX_RTMP_USER_START(s, NGX_RTMP_MSG_BANDWIDTH);\n\n        NGX_RTMP_USER_OUT4(ack_size);\n        NGX_RTMP_USER_OUT1(limit_type);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_bandwidth(ngx_rtmp_session_t *s, uint32_t ack_size,\n                        uint8_t limit_type)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_bandwidth(s, ack_size, limit_type));\n}\n\n\n/* User control messages */\n\nngx_chain_t *\nngx_rtmp_create_stream_begin(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: stream_begin msid=%uD\", msid);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_STREAM_BEGIN);\n\n        NGX_RTMP_USER_OUT4(msid);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_stream_begin(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_stream_begin(s, msid));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_stream_eof(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: stream_end msid=%uD\", msid);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_STREAM_EOF);\n\n        NGX_RTMP_USER_OUT4(msid);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_stream_eof(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_stream_eof(s, msid));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_stream_dry(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: stream_dry msid=%uD\", msid);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_STREAM_DRY);\n\n        NGX_RTMP_USER_OUT4(msid);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_stream_dry(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_stream_dry(s, msid));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_set_buflen(ngx_rtmp_session_t *s, uint32_t msid,\n                           uint32_t buflen_msec)\n{\n    ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: set_buflen msid=%uD buflen=%uD\",\n                   msid, buflen_msec);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_SET_BUFLEN);\n\n        NGX_RTMP_USER_OUT4(msid);\n        NGX_RTMP_USER_OUT4(buflen_msec);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_set_buflen(ngx_rtmp_session_t *s, uint32_t msid,\n        uint32_t buflen_msec)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_set_buflen(s, msid, buflen_msec));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_recorded(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: recorded msid=%uD\", msid);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_RECORDED);\n\n        NGX_RTMP_USER_OUT4(msid);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_recorded(ngx_rtmp_session_t *s, uint32_t msid)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_recorded(s, msid));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_ping_request(ngx_rtmp_session_t *s, uint32_t timestamp)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: ping_request timestamp=%uD\", timestamp);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_PING_REQUEST);\n\n        NGX_RTMP_USER_OUT4(timestamp);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_ping_request(ngx_rtmp_session_t *s, uint32_t timestamp)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_ping_request(s, timestamp));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_ping_response(ngx_rtmp_session_t *s, uint32_t timestamp)\n{\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: ping_response timestamp=%uD\", timestamp);\n\n    {\n        NGX_RTMP_UCTL_START(s, NGX_RTMP_MSG_USER, NGX_RTMP_USER_PING_RESPONSE);\n\n        NGX_RTMP_USER_OUT4(timestamp);\n\n        NGX_RTMP_USER_END(s);\n    }\n}\n\n\nngx_int_t\nngx_rtmp_send_ping_response(ngx_rtmp_session_t *s, uint32_t timestamp)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_ping_response(s, timestamp));\n}\n\n\nstatic ngx_chain_t *\nngx_rtmp_alloc_amf_buf(void *arg)\n{\n    return ngx_rtmp_alloc_shared_buf((ngx_rtmp_core_srv_conf_t *)arg);\n}\n\n\n/* AMF sender */\n\n/* NOTE: this function does not free shared bufs on error */\nngx_int_t\nngx_rtmp_append_amf(ngx_rtmp_session_t *s,\n                    ngx_chain_t **first, ngx_chain_t **last,\n                    ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    ngx_rtmp_amf_ctx_t          act;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n    ngx_int_t                   rc;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    memset(&act, 0, sizeof(act));\n    act.arg = cscf;\n    act.alloc = ngx_rtmp_alloc_amf_buf;\n    act.log = s->connection->log;\n\n    if (first) {\n        act.first = *first;\n    }\n\n    if (last) {\n        act.link = *last;\n    }\n\n    rc = ngx_rtmp_amf_write(&act, elts, nelts);\n\n    if (first) {\n        *first = act.first;\n    }\n\n    if (last) {\n        *last = act.link;\n    }\n\n    return rc;\n}\n\n\nngx_chain_t *\nngx_rtmp_create_amf(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                    ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    ngx_chain_t                *first;\n    ngx_int_t                   rc;\n    ngx_rtmp_core_srv_conf_t   *cscf;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: amf nelts=%ui\", nelts);\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    first = NULL;\n\n    rc = ngx_rtmp_append_amf(s, &first, NULL, elts, nelts);\n\n    if (rc != NGX_OK && first) {\n        ngx_rtmp_free_shared_chain(cscf, first);\n        first = NULL;\n    }\n\n    if (first) {\n        ngx_rtmp_prepare_message(s, h, NULL, first);\n    }\n\n    return first;\n}\n\n\nngx_int_t\nngx_rtmp_send_amf(ngx_rtmp_session_t *s, ngx_rtmp_header_t *h,\n                  ngx_rtmp_amf_elt_t *elts, size_t nelts)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_amf(s, h, elts, nelts));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_status(ngx_rtmp_session_t *s, char *code, char* level,\n                       char *desc)\n{\n    ngx_rtmp_header_t               h;\n    static double                   trans;\n\n    static ngx_rtmp_amf_elt_t       out_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          NULL, 0 },\n    };\n\n    static ngx_rtmp_amf_elt_t       out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onStatus\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf,\n          sizeof(out_inf) },\n    };\n\n    ngx_log_debug3(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: status code='%s' level='%s' desc='%s'\",\n                   code, level, desc);\n\n    out_inf[0].data = level;\n    out_inf[1].data = code;\n    out_inf[2].data = desc;\n\n    memset(&h, 0, sizeof(h));\n\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n\n    return ngx_rtmp_create_amf(s, &h, out_elts,\n                               sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nngx_int_t\nngx_rtmp_send_status(ngx_rtmp_session_t *s, char *code, char* level, char *desc)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_status(s, code, level, desc));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_play_status(ngx_rtmp_session_t *s, char *code, char* level,\n                            ngx_uint_t duration, ngx_uint_t bytes)\n{\n    ngx_rtmp_header_t               h;\n    static double                   dduration;\n    static double                   dbytes;\n\n    static ngx_rtmp_amf_elt_t       out_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"duration\"),\n          &dduration, 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_string(\"bytes\"),\n          &dbytes, 0 },\n    };\n\n    static ngx_rtmp_amf_elt_t       out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onPlayStatus\", 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf,\n          sizeof(out_inf) },\n    };\n\n    ngx_log_debug4(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                   \"create: play_status code='%s' level='%s' \"\n                   \"duration=%ui bytes=%ui\",\n                   code, level, duration, bytes);\n\n    out_inf[0].data = code;\n    out_inf[1].data = level;\n\n    dduration = duration;\n    dbytes = bytes;\n\n    memset(&h, 0, sizeof(h));\n\n    h.type = NGX_RTMP_MSG_AMF_META;\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n    h.timestamp = duration;\n\n    return ngx_rtmp_create_amf(s, &h, out_elts,\n                               sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nngx_int_t\nngx_rtmp_send_play_status(ngx_rtmp_session_t *s, char *code, char* level,\n                          ngx_uint_t duration, ngx_uint_t bytes)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_play_status(s, code, level, duration, bytes));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_fcpublish(ngx_rtmp_session_t *s, u_char *desc)\n{\n    ngx_rtmp_header_t               h;\n    static double                   trans;\n\n    static ngx_rtmp_amf_elt_t       out_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          \"status\", 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          \"NetStream.Publish.Start\", 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          NULL, 0 },\n    };\n\n    static ngx_rtmp_amf_elt_t       out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onFCPublish\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf,\n          sizeof(out_inf) },\n    };\n\n    ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n                   \"create: fcpublish - set structure data\");\n\n    out_inf[2].data = desc;\n    trans = 0;\n\n    memset(&h, 0, sizeof(h));\n\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n\n    return ngx_rtmp_create_amf(s, &h, out_elts,\n                               sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nngx_int_t\nngx_rtmp_send_fcpublish(ngx_rtmp_session_t *s, u_char *desc)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_fcpublish(s, desc));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_fcunpublish(ngx_rtmp_session_t *s, u_char *desc)\n{\n    ngx_rtmp_header_t               h;\n    static double                   trans;\n\n    static ngx_rtmp_amf_elt_t       out_inf[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"level\"),\n          \"status\", 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"code\"),\n          \"NetStream.Unpublish.Success\", 0 },\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_string(\"description\"),\n          NULL, 0 },\n    };\n\n    static ngx_rtmp_amf_elt_t       out_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"onFCUnpublish\", 0 },\n\n        { NGX_RTMP_AMF_NUMBER,\n          ngx_null_string,\n          &trans, 0 },\n\n        { NGX_RTMP_AMF_NULL,\n          ngx_null_string,\n          NULL, 0 },\n\n        { NGX_RTMP_AMF_OBJECT,\n          ngx_null_string,\n          out_inf,\n          sizeof(out_inf) },\n    };\n\n    ngx_log_error(NGX_LOG_DEBUG, s->connection->log, 0,\n                   \"create: fcunpublish - set structure data\");\n\n    out_inf[2].data = desc;\n    trans = 0;\n\n    memset(&h, 0, sizeof(h));\n\n    h.type = NGX_RTMP_MSG_AMF_CMD;\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n\n    return ngx_rtmp_create_amf(s, &h, out_elts,\n                               sizeof(out_elts) / sizeof(out_elts[0]));\n}\n\n\nngx_int_t\nngx_rtmp_send_fcunpublish(ngx_rtmp_session_t *s, u_char *desc)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_fcunpublish(s, desc));\n}\n\n\nngx_chain_t *\nngx_rtmp_create_sample_access(ngx_rtmp_session_t *s)\n{\n    ngx_rtmp_header_t               h;\n\n    static int                      access = 1;\n\n    static ngx_rtmp_amf_elt_t       access_elts[] = {\n\n        { NGX_RTMP_AMF_STRING,\n          ngx_null_string,\n          \"|RtmpSampleAccess\", 0 },\n\n        { NGX_RTMP_AMF_BOOLEAN,\n          ngx_null_string,\n          &access, 0 },\n\n        { NGX_RTMP_AMF_BOOLEAN,\n          ngx_null_string,\n          &access, 0 },\n    };\n\n    memset(&h, 0, sizeof(h));\n\n    h.type = NGX_RTMP_MSG_AMF_META;\n    h.csid = NGX_RTMP_CSID_AMF;\n    h.msid = NGX_RTMP_MSID;\n\n    return ngx_rtmp_create_amf(s, &h, access_elts,\n                               sizeof(access_elts) / sizeof(access_elts[0]));\n}\n\n\nngx_int_t\nngx_rtmp_send_sample_access(ngx_rtmp_session_t *s)\n{\n    return ngx_rtmp_send_shared_packet(s,\n           ngx_rtmp_create_sample_access(s));\n}\n"
        },
        {
          "name": "ngx_rtmp_shared.c",
          "type": "blob",
          "size": 2.5673828125,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include \"ngx_rtmp.h\"\n\n\nngx_chain_t *\nngx_rtmp_alloc_shared_buf(ngx_rtmp_core_srv_conf_t *cscf)\n{\n    u_char                     *p;\n    ngx_chain_t                *out;\n    ngx_buf_t                  *b;\n    size_t                      size;\n\n    if (cscf->free) {\n        out = cscf->free;\n        cscf->free = out->next;\n\n    } else {\n\n        size = cscf->chunk_size + NGX_RTMP_MAX_CHUNK_HEADER;\n\n        p = ngx_pcalloc(cscf->pool, NGX_RTMP_REFCOUNT_BYTES\n                + sizeof(ngx_chain_t)\n                + sizeof(ngx_buf_t)\n                + size);\n        if (p == NULL) {\n            return NULL;\n        }\n\n        p += NGX_RTMP_REFCOUNT_BYTES;\n        out = (ngx_chain_t *)p;\n\n        p += sizeof(ngx_chain_t);\n        out->buf = (ngx_buf_t *)p;\n\n        p += sizeof(ngx_buf_t);\n        out->buf->start = p;\n        out->buf->end = p + size;\n    }\n\n    out->next = NULL;\n    b = out->buf;\n    b->pos = b->last = b->start + NGX_RTMP_MAX_CHUNK_HEADER;\n    b->memory = 1;\n\n    /* buffer has refcount =1 when created! */\n    ngx_rtmp_ref_set(out, 1);\n\n    return out;\n}\n\n\nvoid\nngx_rtmp_free_shared_chain(ngx_rtmp_core_srv_conf_t *cscf, ngx_chain_t *in)\n{\n    ngx_chain_t        *cl;\n\n    if (ngx_rtmp_ref_put(in)) {\n        return;\n    }\n\n    for (cl = in; ; cl = cl->next) {\n        if (cl->next == NULL) {\n            cl->next = cscf->free;\n            cscf->free = in;\n            return;\n        }\n    }\n}\n\n\nngx_chain_t *\nngx_rtmp_append_shared_bufs(ngx_rtmp_core_srv_conf_t *cscf,\n        ngx_chain_t *head, ngx_chain_t *in)\n{\n    ngx_chain_t                    *l, **ll;\n    u_char                         *p;\n    size_t                          size;\n\n    ll = &head;\n    p = in->buf->pos;\n    l = head;\n\n    if (l) {\n        for(; l->next; l = l->next);\n        ll = &l->next;\n    }\n\n    for ( ;; ) {\n\n        if (l == NULL || l->buf->last == l->buf->end) {\n            l = ngx_rtmp_alloc_shared_buf(cscf);\n            if (l == NULL || l->buf == NULL) {\n                break;\n            }\n\n            *ll = l;\n            ll = &l->next;\n        }\n\n        while (l->buf->end - l->buf->last >= in->buf->last - p) {\n            l->buf->last = ngx_cpymem(l->buf->last, p,\n                    in->buf->last - p);\n            in = in->next;\n            if (in == NULL) {\n                goto done;\n            }\n            p = in->buf->pos;\n        }\n\n        size = l->buf->end - l->buf->last;\n        l->buf->last = ngx_cpymem(l->buf->last, p, size);\n        p += size;\n    }\n\ndone:\n    *ll = NULL;\n\n    return head;\n}\n"
        },
        {
          "name": "ngx_rtmp_stat_module.c",
          "type": "blob",
          "size": 56.44140625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) plainheart\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n#include <nginx.h>\n#include \"ngx_rtmp.h\"\n#include \"ngx_rtmp_version.h\"\n#include \"ngx_rtmp_live_module.h\"\n#include \"ngx_rtmp_play_module.h\"\n#include \"ngx_rtmp_codec_module.h\"\n#include \"ngx_rtmp_record_module.h\"\n\n\nstatic ngx_int_t ngx_rtmp_stat_init_process(ngx_cycle_t *cycle);\nstatic char *ngx_rtmp_stat(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic ngx_int_t ngx_rtmp_stat_postconfiguration(ngx_conf_t *cf);\nstatic void * ngx_rtmp_stat_create_loc_conf(ngx_conf_t *cf);\nstatic char * ngx_rtmp_stat_merge_loc_conf(ngx_conf_t *cf,\n        void *parent, void *child);\n\n\nstatic time_t                       start_time;\n\n\n#define NGX_RTMP_STAT_ALL           0xff\n#define NGX_RTMP_STAT_GLOBAL        0x01\n#define NGX_RTMP_STAT_LIVE          0x02\n#define NGX_RTMP_STAT_CLIENTS       0x04\n#define NGX_RTMP_STAT_PLAY          0x08\n#define NGX_RTMP_STAT_RECORD        0x10\n\n#define NGX_RTMP_STAT_FORMAT_XML    0x01\n#define NGX_RTMP_STAT_FORMAT_JSON   0x02\n\n\n/*\n * global: stat-{bufs-{total,free,used}, total bytes in/out, bw in/out} - cscf\n*/\n\n\ntypedef struct {\n    ngx_uint_t                      stat;\n    ngx_str_t                       stylesheet;\n    ngx_uint_t                      format;\n} ngx_rtmp_stat_loc_conf_t;\n\n\nstatic ngx_conf_bitmask_t           ngx_rtmp_stat_masks[] = {\n    { ngx_string(\"all\"),            NGX_RTMP_STAT_ALL           },\n    { ngx_string(\"global\"),         NGX_RTMP_STAT_GLOBAL        },\n    { ngx_string(\"live\"),           NGX_RTMP_STAT_LIVE          },\n    { ngx_string(\"clients\"),        NGX_RTMP_STAT_CLIENTS       },\n    { ngx_string(\"record\"),         NGX_RTMP_STAT_RECORD        },\n    { ngx_null_string,              0 }\n};\n\n\nstatic ngx_conf_bitmask_t           ngx_rtmp_stat_format_masks[] = {\n    { ngx_string(\"xml\"),            NGX_RTMP_STAT_FORMAT_XML       },\n    { ngx_string(\"json\"),           NGX_RTMP_STAT_FORMAT_JSON      },\n    { ngx_null_string,              0 }\n};\n\n\nstatic ngx_command_t  ngx_rtmp_stat_commands[] = {\n\n    { ngx_string(\"rtmp_stat\"),\n        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,\n        ngx_rtmp_stat,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_rtmp_stat_loc_conf_t, stat),\n        ngx_rtmp_stat_masks },\n\n    { ngx_string(\"rtmp_stat_stylesheet\"),\n        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n        ngx_conf_set_str_slot,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_rtmp_stat_loc_conf_t, stylesheet),\n        NULL },\n        \n    { ngx_string(\"rtmp_stat_format\"),\n        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,\n        ngx_rtmp_stat,\n        NGX_HTTP_LOC_CONF_OFFSET,\n        offsetof(ngx_rtmp_stat_loc_conf_t, format),\n        ngx_rtmp_stat_format_masks },\n\n    ngx_null_command\n};\n\n\nstatic ngx_http_module_t  ngx_rtmp_stat_module_ctx = {\n    NULL,                               /* preconfiguration */\n    ngx_rtmp_stat_postconfiguration,    /* postconfiguration */\n\n    NULL,                               /* create main configuration */\n    NULL,                               /* init main configuration */\n\n    NULL,                               /* create server configuration */\n    NULL,                               /* merge server configuration */\n\n    ngx_rtmp_stat_create_loc_conf,      /* create location configuration */\n    ngx_rtmp_stat_merge_loc_conf        /* merge location configuration */\n};\n\n\nngx_module_t  ngx_rtmp_stat_module = {\n    NGX_MODULE_V1,\n    &ngx_rtmp_stat_module_ctx,          /* module context */\n    ngx_rtmp_stat_commands,             /* module directives */\n    NGX_HTTP_MODULE,                    /* module type */\n    NULL,                               /* init master */\n    NULL,                               /* init module */\n    ngx_rtmp_stat_init_process,         /* init process */\n    NULL,                               /* init thread */\n    NULL,                               /* exit thread */\n    NULL,                               /* exit process */\n    NULL,                               /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\n#define NGX_RTMP_STAT_BUFSIZE           256\n\n\nstatic ngx_int_t\nngx_rtmp_stat_init_process(ngx_cycle_t *cycle)\n{\n    /*\n     * HTTP process initializer is called\n     * after event module initializer\n     * so we can run posted events here\n     */\n\n    ngx_event_process_posted(cycle, &ngx_rtmp_init_queue);\n\n    return NGX_OK;\n}\n\n\n/* ngx_escape_html does not escape characters out of ASCII range\n * which are bad for xslt */\n\nstatic void *\nngx_rtmp_stat_escape(ngx_http_request_t *r, void *data, size_t len)\n{\n    u_char *p, *np;\n    void   *new_data;\n    size_t  n;\n\n    p = data;\n\n    for (n = 0; n < len; ++n, ++p) {\n        if (*p < 0x20 || *p >= 0x7f) {\n            break;\n        }\n    }\n\n    if (n == len) {\n        return data;\n    }\n\n    new_data = ngx_palloc(r->pool, len);\n    if (new_data == NULL) {\n        return NULL;\n    }\n\n    p  = data;\n    np = new_data;\n\n    for (n = 0; n < len; ++n, ++p, ++np) {\n        *np = (*p < 0x20 || *p >= 0x7f) ? (u_char) ' ' : *p;\n    }\n\n    return new_data;\n}\n\n\n#if (NGX_WIN32)\n/*\n * Fix broken MSVC memcpy optimization for 4-byte data\n * when this function is inlined\n */\n__declspec(noinline)\n#endif\n\n\nstatic void\nngx_rtmp_stat_output(ngx_http_request_t *r, ngx_chain_t ***lll,\n        void *data, size_t len, ngx_uint_t escape)\n{\n    ngx_chain_t        *cl;\n    ngx_buf_t          *b;\n    size_t              real_len;\n\n    if (len == 0) {\n        return;\n    }\n\n    if (escape) {\n        data = ngx_rtmp_stat_escape(r, data, len);\n        if (data == NULL) {\n            return;\n        }\n    }\n\n    real_len = escape\n        ? len + ngx_escape_html(NULL, data, len)\n        : len;\n\n    cl = **lll;\n    if (cl && cl->buf->last + real_len > cl->buf->end) {\n        *lll = &cl->next;\n    }\n\n    if (**lll == NULL) {\n        cl = ngx_alloc_chain_link(r->pool);\n        if (cl == NULL) {\n            return;\n        }\n        b = ngx_create_temp_buf(r->pool,\n                ngx_max(NGX_RTMP_STAT_BUFSIZE, real_len));\n        if (b == NULL || b->pos == NULL) {\n            return;\n        }\n        cl->next = NULL;\n        cl->buf = b;\n        **lll = cl;\n    }\n\n    b = (**lll)->buf;\n\n    if (escape) {\n        b->last = (u_char *)ngx_escape_html(b->last, data, len);\n    } else {\n        b->last = ngx_cpymem(b->last, data, len);\n    }\n}\n\n\n/* These shortcuts assume 2 variables exist in current context:\n *   ngx_http_request_t    *r\n *   ngx_chain_t         ***lll */\n\n/* plain data */\n#define NGX_RTMP_STAT(data, len)    ngx_rtmp_stat_output(r, lll, data, len, 0)\n\n/* escaped data */\n#define NGX_RTMP_STAT_E(data, len)  ngx_rtmp_stat_output(r, lll, data, len, 1)\n\n/* literal */\n#define NGX_RTMP_STAT_L(s)          NGX_RTMP_STAT((s), sizeof(s) - 1)\n\n/* ngx_str_t */\n#define NGX_RTMP_STAT_S(s)          NGX_RTMP_STAT((s)->data, (s)->len)\n\n/* escaped ngx_str_t */\n#define NGX_RTMP_STAT_ES(s)         NGX_RTMP_STAT_E((s)->data, (s)->len)\n\n/* C string */\n#define NGX_RTMP_STAT_CS(s)         NGX_RTMP_STAT((s), ngx_strlen(s))\n\n/* escaped C string */\n#define NGX_RTMP_STAT_ECS(s)        NGX_RTMP_STAT_E((s), ngx_strlen(s))\n\n\n#define NGX_RTMP_STAT_BW            0x01\n#define NGX_RTMP_STAT_BYTES         0x02\n#define NGX_RTMP_STAT_BW_BYTES      0x03\n\n\nstatic void\nngx_rtmp_stat_bw(ngx_http_request_t *r, ngx_chain_t ***lll,\n                 ngx_rtmp_bandwidth_t *bw, char *name,\n                 ngx_uint_t flags)\n{\n    u_char                          buf[NGX_INT64_LEN + 9];\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n\n    ngx_rtmp_update_bandwidth(bw, 0);\n\n    if (flags & NGX_RTMP_STAT_BW) {\n        if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n            NGX_RTMP_STAT_L(\"<bw_\");\n            NGX_RTMP_STAT_CS(name);\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \">%uL</bw_\",\n                                            bw->bandwidth * 8)\n                               - buf);\n            NGX_RTMP_STAT_CS(name);\n            NGX_RTMP_STAT_L(\">\\r\\n\");\n        } else {\n            NGX_RTMP_STAT_L(\"\\\"bw_\");\n            NGX_RTMP_STAT_CS(name);\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"\\\":%uL,\",\n                                            bw->bandwidth * 8)\n                               - buf);\n        }\n    }\n\n    if (flags & NGX_RTMP_STAT_BYTES) {\n        if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n            NGX_RTMP_STAT_L(\"<bytes_\");\n            NGX_RTMP_STAT_CS(name);\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \">%uL</bytes_\",\n                                            bw->bytes)\n                               - buf);\n            NGX_RTMP_STAT_CS(name);\n            NGX_RTMP_STAT_L(\">\\r\\n\");\n        } else {\n            NGX_RTMP_STAT_L(\"\\\"bytes_\");\n            NGX_RTMP_STAT_CS(name);\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"\\\":%uL,\",\n                                            bw->bytes)\n                               - buf);\n        }\n    }\n}\n\n\n#ifdef NGX_RTMP_POOL_DEBUG\nstatic void\nngx_rtmp_stat_get_pool_size(ngx_pool_t *pool, ngx_uint_t *nlarge,\n        ngx_uint_t *size)\n{\n    ngx_pool_large_t       *l;\n    ngx_pool_t             *p, *n;\n\n    *nlarge = 0;\n    for (l = pool->large; l; l = l->next) {\n        ++*nlarge;\n    }\n\n    *size = 0;\n    for (p = pool, n = pool->d.next; /* void */; p = n, n = n->d.next) {\n        *size += (p->d.last - (u_char *)p);\n        if (n == NULL) {\n            break;\n        }\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_dump_pool(ngx_http_request_t *r, ngx_chain_t ***lll,\n        ngx_pool_t *pool)\n{\n    ngx_uint_t                      nlarge, size;\n    u_char                          buf[NGX_INT_T_LEN];\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    size = 0;\n    nlarge = 0;\n    ngx_rtmp_stat_get_pool_size(pool, &nlarge, &size);\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<pool><nlarge>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%ui\", nlarge) - buf);\n        NGX_RTMP_STAT_L(\"</nlarge><size>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%ui\", size) - buf);\n        NGX_RTMP_STAT_L(\"</size></pool>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"\\\"pool\\\":{\\\"nlarge\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%ui\", nlarge) - buf);\n        NGX_RTMP_STAT_L(\",\\\"size\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%ui\", size) - buf);\n        NGX_RTMP_STAT_L(\"}\");\n    }\n}\n#endif\n\n\nstatic void\nngx_rtmp_stat_client(ngx_http_request_t *r, ngx_chain_t ***lll,\n    ngx_rtmp_session_t *s)\n{\n    u_char                          buf[NGX_INT_T_LEN];\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n\n#ifdef NGX_RTMP_POOL_DEBUG\n    ngx_rtmp_stat_dump_pool(r, lll, s->connection->pool);\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_JSON) {\n        NGX_RTMP_STAT_L(\",\");\n    }\n#endif\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<id>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%ui\",\n                      (ngx_uint_t) s->connection->number) - buf);\n        NGX_RTMP_STAT_L(\"</id>\\r\\n\");\n\n        NGX_RTMP_STAT_L(\"<address>\");\n        NGX_RTMP_STAT_ES(&s->connection->addr_text);\n        NGX_RTMP_STAT_L(\"</address>\\r\\n\");\n\n        NGX_RTMP_STAT_L(\"<time>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%i\",\n                      (ngx_int_t) (ngx_current_msec - s->epoch)) - buf);\n        NGX_RTMP_STAT_L(\"</time>\\r\\n\");\n\n        if (s->flashver.len) {\n            NGX_RTMP_STAT_L(\"<flashver>\");\n            NGX_RTMP_STAT_ES(&s->flashver);\n            NGX_RTMP_STAT_L(\"</flashver>\\r\\n\");\n        }\n\n        if (s->page_url.len) {\n            NGX_RTMP_STAT_L(\"<pageurl>\");\n            NGX_RTMP_STAT_ES(&s->page_url);\n            NGX_RTMP_STAT_L(\"</pageurl>\\r\\n\");\n        }\n\n        if (s->swf_url.len) {\n            NGX_RTMP_STAT_L(\"<swfurl>\");\n            NGX_RTMP_STAT_ES(&s->swf_url);\n            NGX_RTMP_STAT_L(\"</swfurl>\\r\\n\");\n        }\n    } else {\n        NGX_RTMP_STAT_L(\"\\\"id\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%ui\",\n                      (ngx_uint_t) s->connection->number) - buf);\n\n        NGX_RTMP_STAT_L(\",\\\"address\\\":\\\"\");\n        NGX_RTMP_STAT_ES(&s->connection->addr_text);\n\n        NGX_RTMP_STAT_L(\"\\\",\\\"time\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%i\",\n                      (ngx_int_t) (ngx_current_msec - s->epoch)) - buf);\n        NGX_RTMP_STAT_L(\",\");\n\n        if (s->flashver.len) {\n            NGX_RTMP_STAT_L(\"\\\"flashver\\\":\\\"\");\n            NGX_RTMP_STAT_ES(&s->flashver);\n            NGX_RTMP_STAT_L(\"\\\",\");\n        }\n\n        if (s->page_url.len) {\n            NGX_RTMP_STAT_L(\"\\\"pageurl\\\":\\\"\");\n            NGX_RTMP_STAT_ES(&s->page_url);\n            NGX_RTMP_STAT_L(\"\\\",\");\n        }\n\n        if (s->swf_url.len) {\n            NGX_RTMP_STAT_L(\"\\\"swfurl\\\":\\\"\");\n            NGX_RTMP_STAT_ES(&s->swf_url);\n            NGX_RTMP_STAT_L(\"\\\",\");\n        }\n    }\n}\n\n\nstatic char *\nngx_rtmp_stat_get_aac_profile(ngx_uint_t p, ngx_uint_t sbr, ngx_uint_t ps) {\n    switch (p) {\n        case 1:\n            return \"Main\";\n        case 2:\n            if (ps) {\n                return \"HEv2\";\n            }\n            if (sbr) {\n                return \"HE\";\n            }\n            return \"LC\";\n        case 3:\n            return \"SSR\";\n        case 4:\n            return \"LTP\";\n        case 5:\n            return \"SBR\";\n        default:\n            return \"\";\n    }\n}\n\n\nstatic char *\nngx_rtmp_stat_get_avc_profile(ngx_uint_t p) {\n    switch (p) {\n        case 66:\n            return \"Baseline\";\n        case 77:\n            return \"Main\";\n        case 100:\n            return \"High\";\n        default:\n            return \"\";\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_live_records(ngx_http_request_t *r, ngx_chain_t ***lll,\n    ngx_rtmp_session_t *s)\n{\n    ngx_uint_t                      i;\n    u_char                          buf[NGX_INT_T_LEN];\n    ngx_str_t                       filename;\n    ngx_file_info_t                 filebuf;\n    ngx_rtmp_record_ctx_t          *rctx;\n    ngx_rtmp_record_rec_ctx_t      *rrctx;\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    rctx = ngx_rtmp_get_module_ctx(s, ngx_rtmp_record_module);\n    if(rctx == NULL) {\n        return;\n    }\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n    rrctx = rctx->rec.elts;\n\n    for(i = 0; i < rctx->rec.nelts; ++i, ++rrctx) {\n        if (rrctx->file.fd == NGX_INVALID_FILE) {\n            continue;\n        }\n\n        if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n            NGX_RTMP_STAT_L(\"<record>\");\n\n            if(rrctx->conf) {\n                NGX_RTMP_STAT_L(\"<recorder>\");\n                NGX_RTMP_STAT_S(&rrctx->conf->id);\n                NGX_RTMP_STAT_L(\"</recorder>\\r\\n\");\n            }\n\n            NGX_RTMP_STAT_L(\"<epoch>\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", rrctx->epoch) - buf);\n            NGX_RTMP_STAT_L(\"</epoch>\\r\\n\");\n            NGX_RTMP_STAT_L(\"<time_shift>\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", rrctx->time_shift) - buf);\n            NGX_RTMP_STAT_L(\"</time_shift>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<recording/>\\r\\n\");\n            NGX_RTMP_STAT_L(\"<file>\");\n            ngx_rtmp_record_get_path(s, rrctx, &filename);\n            NGX_RTMP_STAT_S(&filename);\n            NGX_RTMP_STAT_L(\"</file>\\r\\n\");\n            NGX_RTMP_STAT_L(\"<time>\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                    \"%ui\", ngx_cached_time->sec - rrctx->timestamp) - buf);\n            NGX_RTMP_STAT_L(\"</time>\\r\\n\");\n            NGX_RTMP_STAT_L(\"<size>\");\n            ngx_file_info((const char *)filename.data, &filebuf);\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", ngx_file_size(&filebuf)) - buf);\n            NGX_RTMP_STAT_L(\"</size>\\r\\n\");\n            NGX_RTMP_STAT_L(\"<nframes>\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", rrctx->nframes) - buf);\n            NGX_RTMP_STAT_L(\"</nframes>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"</record>\\r\\n\");\n        } else {\n            NGX_RTMP_STAT_L(\"{\");\n\n            if(rrctx->conf) {\n                NGX_RTMP_STAT_L(\"\\\"recorder\\\":\\\"\");\n                NGX_RTMP_STAT_S(&rrctx->conf->id);\n                NGX_RTMP_STAT_L(\"\\\"\");\n            } else {\n                NGX_RTMP_STAT_L(\"\\\"recorder\\\":\\\"\\\"\");\n            }\n\n            NGX_RTMP_STAT_L(\",\\\"epoch\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", rrctx->epoch) - buf);\n            NGX_RTMP_STAT_L(\",\\\"time_shift\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", rrctx->time_shift) - buf);\n\n            NGX_RTMP_STAT_L(\",\\\"recording\\\":true\");\n            NGX_RTMP_STAT_L(\",\\\"file\\\":\\\"\");\n            ngx_rtmp_record_get_path(s, rrctx, &filename);\n            NGX_RTMP_STAT_S(&filename);\n            NGX_RTMP_STAT_L(\"\\\",\\\"time\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                    \"%ui\", ngx_cached_time->sec - rrctx->timestamp) - buf);\n            NGX_RTMP_STAT_L(\",\\\"size\\\":\");\n            ngx_file_info((const char *)filename.data, &filebuf);\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", ngx_file_size(&filebuf)) - buf);\n            NGX_RTMP_STAT_L(\",\\\"nframes\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                        \"%ui\", rrctx->nframes) - buf);\n\n            NGX_RTMP_STAT_L(\"}\");\n        }\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_live(ngx_http_request_t *r, ngx_chain_t ***lll,\n        ngx_rtmp_live_app_conf_t *lacf)\n{\n    ngx_rtmp_live_stream_t         *stream;\n    ngx_rtmp_codec_ctx_t           *codec;\n    ngx_rtmp_live_ctx_t            *ctx;\n    ngx_rtmp_session_t             *s;\n    ngx_int_t                       n;\n    ngx_uint_t                      nclients, total_nclients;\n    ngx_uint_t                      f;\n    ngx_flag_t                      prev;\n    u_char                          buf[NGX_INT64_LEN + 4];\n    u_char                          bbuf[NGX_INT32_LEN];\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n    u_char                         *cname;\n\n    if (!lacf->live) {\n        return;\n    }\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<live>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\",\\\"live\\\":{\");\n        NGX_RTMP_STAT_L(\"\\\"streams\\\":[\");\n    }\n\n    total_nclients = 0;\n    prev = 0;\n    for (n = 0; n < lacf->nbuckets; ++n) {\n        for (stream = lacf->streams[n]; stream; stream = stream->next) {\n            if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"<stream>\\r\\n\");\n            } else {\n                if (prev) {\n                    NGX_RTMP_STAT_L(\",\");\n                }\n\n                prev = 1;\n                NGX_RTMP_STAT_L(\"{\");\n            }\n\n            if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"<name>\");\n                NGX_RTMP_STAT_ECS(stream->name);\n                NGX_RTMP_STAT_L(\"</name>\\r\\n\");\n\n                NGX_RTMP_STAT_L(\"<time>\");\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%i\",\n                              (ngx_int_t) (ngx_current_msec - stream->epoch))\n                              - buf);\n                NGX_RTMP_STAT_L(\"</time>\\r\\n\");\n            } else {\n                NGX_RTMP_STAT_L(\"\\\"name\\\":\\\"\");\n                NGX_RTMP_STAT_ECS(stream->name);\n                NGX_RTMP_STAT_L(\"\\\",\");\n\n                NGX_RTMP_STAT_L(\"\\\"time\\\":\");\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf), \"%i\",\n                              (ngx_int_t) (ngx_current_msec - stream->epoch))\n                              - buf);\n                NGX_RTMP_STAT_L(\",\");\n            }\n\n            ngx_rtmp_stat_bw(r, lll, &stream->bw_in, \"in\",\n                             NGX_RTMP_STAT_BW_BYTES);\n            ngx_rtmp_stat_bw(r, lll, &stream->bw_out, \"out\",\n                             NGX_RTMP_STAT_BW_BYTES);\n            ngx_rtmp_stat_bw(r, lll, &stream->bw_in_audio, \"audio\",\n                             NGX_RTMP_STAT_BW);\n            ngx_rtmp_stat_bw(r, lll, &stream->bw_in_video, \"video\",\n                             NGX_RTMP_STAT_BW);\n\n            nclients = 0;\n            codec = NULL;\n\n            if (slcf->stat & NGX_RTMP_STAT_CLIENTS &&\n                slcf->format & NGX_RTMP_STAT_FORMAT_JSON)\n            {\n                NGX_RTMP_STAT_L(\"\\\"clients\\\":[\");\n            }\n\n            for (ctx = stream->ctx; ctx; ctx = ctx->next, ++nclients) {\n                s = ctx->session;\n                if (slcf->stat & NGX_RTMP_STAT_CLIENTS) {\n\n                    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                        NGX_RTMP_STAT_L(\"<client>\\r\\n\");\n                    } else {\n                        NGX_RTMP_STAT_L(\"{\");\n                    }\n\n                    ngx_rtmp_stat_client(r, lll, s);\n\n                    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                        NGX_RTMP_STAT_L(\"<dropped>\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", ctx->ndropped) - buf);\n                        NGX_RTMP_STAT_L(\"</dropped>\\r\\n\");\n\n                        NGX_RTMP_STAT_L(\"<avsync>\");\n                        if (!lacf->interleave) {\n                            NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                          \"%D\", ctx->cs[1].timestamp -\n                                          ctx->cs[0].timestamp) - bbuf);\n                        } else {\n                            NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                          \"%D\", 0) - bbuf);\n                        }\n                        NGX_RTMP_STAT_L(\"</avsync>\\r\\n\");\n\n                        NGX_RTMP_STAT_L(\"<timestamp>\");\n                        NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                      \"%D\", s->current_time) - bbuf);\n                        NGX_RTMP_STAT_L(\"</timestamp>\\r\\n\");\n\n                        if (ctx->publishing) {\n                            NGX_RTMP_STAT_L(\"<publishing/>\\r\\n\");\n                        }\n\n                        if (ctx->active) {\n                            NGX_RTMP_STAT_L(\"<active/>\\r\\n\");\n                        }\n                    } else {\n                        NGX_RTMP_STAT_L(\"\\\"dropped\\\":\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", ctx->ndropped) - buf);\n\n                        NGX_RTMP_STAT_L(\",\\\"avsync\\\":\");\n                        if (!lacf->interleave) {\n                            NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                          \"%D\", ctx->cs[1].timestamp -\n                                          ctx->cs[0].timestamp) - bbuf);\n                        } else {\n                            NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                          \"%D\", 0) - bbuf);\n                        }\n\n                        NGX_RTMP_STAT_L(\",\\\"timestamp\\\":\");\n                        NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                      \"%D\", s->current_time) - bbuf);\n\n                        NGX_RTMP_STAT_L(\",\\\"publishing\\\":\");\n                        if (ctx->publishing) {\n                            NGX_RTMP_STAT_L(\"true\");\n                        } else {\n                            NGX_RTMP_STAT_L(\"false\");\n                        }\n\n                        NGX_RTMP_STAT_L(\",\\\"active\\\":\");\n                        if (ctx->active) {\n                            NGX_RTMP_STAT_L(\"true\");\n                        } else {\n                            NGX_RTMP_STAT_L(\"false\");\n                        }\n                    }\n\n                    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                       NGX_RTMP_STAT_L(\"</client>\\r\\n\");\n                    } else {\n                        NGX_RTMP_STAT_L(\"}\");\n                        if (ctx->next) {\n                            NGX_RTMP_STAT_L(\",\");\n                        }\n                    }\n                }\n                if (ctx->publishing) {\n                    codec = ngx_rtmp_get_module_ctx(s, ngx_rtmp_codec_module);\n                }\n            }\n            total_nclients += nclients;\n\n            if (slcf->stat & NGX_RTMP_STAT_CLIENTS &&\n                slcf->format & NGX_RTMP_STAT_FORMAT_JSON)\n            {\n                NGX_RTMP_STAT_L(\"],\");\n            }\n\n            if(slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"<records>\\r\\n\");\n            } else {\n                NGX_RTMP_STAT_L(\"\\\"records\\\":[\");\n            }\n\n            for (ctx = stream->ctx; ctx; ctx = ctx->next) {\n                /* valid for only publishers */\n                if (ctx->publishing) {\n                    s = ctx->session;\n\n                    if (slcf->stat & NGX_RTMP_STAT_RECORD) {\n                        ngx_rtmp_stat_live_records(r, lll, s);\n                    }\n\n                    break;\n                }\n            }\n\n            if(slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"</records>\\r\\n\");\n            } else {\n                if (codec == NULL) {\n                    NGX_RTMP_STAT_L(\"],\");\n                } else {\n                    NGX_RTMP_STAT_L(\"]\");\n                }\n            }\n\n            if (codec) {\n                if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                    NGX_RTMP_STAT_L(\"<meta>\\r\\n\");\n\n                    NGX_RTMP_STAT_L(\"<video>\\r\\n\");\n                    NGX_RTMP_STAT_L(\"<width>\");\n                    NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                  \"%ui\", codec->width) - buf);\n                    NGX_RTMP_STAT_L(\"</width>\\r\\n<height>\");\n                    NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                  \"%ui\", codec->height) - buf);\n                    NGX_RTMP_STAT_L(\"</height>\\r\\n<frame_rate>\");\n                    NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                  \"%.3f\", codec->frame_rate) - buf);\n                    NGX_RTMP_STAT_L(\"</frame_rate>\\r\\n\");\n\n                    cname = ngx_rtmp_get_video_codec_name(codec->video_codec_id);\n                    if (*cname) {\n                        NGX_RTMP_STAT_L(\"<codec>\");\n                        NGX_RTMP_STAT_ECS(cname);\n                        NGX_RTMP_STAT_L(\"</codec>\\r\\n\");\n                    }\n                    if (codec->avc_profile) {\n                        NGX_RTMP_STAT_L(\"<profile>\");\n                        NGX_RTMP_STAT_CS(\n                            ngx_rtmp_stat_get_avc_profile(codec->avc_profile));\n                        NGX_RTMP_STAT_L(\"</profile>\\r\\n\");\n                    }\n                    if (codec->avc_compat) {\n                        NGX_RTMP_STAT_L(\"<compat>\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->avc_compat) - buf);\n                        NGX_RTMP_STAT_L(\"</compat>\\r\\n\");\n                    }\n                    if (codec->avc_level) {\n                        NGX_RTMP_STAT_L(\"<level>\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%.1f\", codec->avc_level / 10.) - buf);\n                        NGX_RTMP_STAT_L(\"</level>\\r\\n\");\n                    }\n                    NGX_RTMP_STAT_L(\"</video>\\r\\n\");\n\n                    NGX_RTMP_STAT_L(\"<audio>\\r\\n\");\n                    cname = ngx_rtmp_get_audio_codec_name(codec->audio_codec_id);\n                    if (*cname) {\n                        NGX_RTMP_STAT_L(\"<codec>\");\n                        NGX_RTMP_STAT_ECS(cname);\n                        NGX_RTMP_STAT_L(\"</codec>\\r\\n\");\n                    }\n                    if (codec->aac_profile) {\n                        NGX_RTMP_STAT_L(\"<profile>\");\n                        NGX_RTMP_STAT_CS(\n                            ngx_rtmp_stat_get_aac_profile(codec->aac_profile,\n                                                          codec->aac_sbr,\n                                                          codec->aac_ps));\n                        NGX_RTMP_STAT_L(\"</profile>\\r\\n\");\n                    }\n                    if (codec->aac_chan_conf) {\n                        NGX_RTMP_STAT_L(\"<channels>\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->aac_chan_conf) - buf);\n                        NGX_RTMP_STAT_L(\"</channels>\\r\\n\");\n                    } else if (codec->audio_channels) {\n                        NGX_RTMP_STAT_L(\"<channels>\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->audio_channels) - buf);\n                        NGX_RTMP_STAT_L(\"</channels>\\r\\n\");\n                    }\n                    if (codec->sample_rate) {\n                        NGX_RTMP_STAT_L(\"<sample_rate>\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->sample_rate) - buf);\n                        NGX_RTMP_STAT_L(\"</sample_rate>\\r\\n\");\n                    }\n                    NGX_RTMP_STAT_L(\"</audio>\\r\\n\");\n\n                    NGX_RTMP_STAT_L(\"</meta>\\r\\n\");\n                } else {\n                    NGX_RTMP_STAT_L(\",\\\"meta\\\":{\");\n\n                    NGX_RTMP_STAT_L(\"\\\"video\\\":{\");\n                    NGX_RTMP_STAT_L(\"\\\"width\\\":\");\n                    NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                  \"%ui\", codec->width) - buf);\n                    NGX_RTMP_STAT_L(\",\\\"height\\\":\");\n                    NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                  \"%ui\", codec->height) - buf);\n                    NGX_RTMP_STAT_L(\",\\\"frame_rate\\\":\");\n                    NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                  \"%.3f\", codec->frame_rate) - buf);\n\n                    cname = ngx_rtmp_get_video_codec_name(codec->video_codec_id);\n                    if (*cname) {\n                        NGX_RTMP_STAT_L(\",\\\"codec\\\":\\\"\");\n                        NGX_RTMP_STAT_ECS(cname);\n                        NGX_RTMP_STAT_L(\"\\\"\");\n                    }\n                    if (codec->avc_profile) {\n                        NGX_RTMP_STAT_L(\",\\\"profile\\\":\\\"\");\n                        NGX_RTMP_STAT_CS(ngx_rtmp_stat_get_avc_profile(\n                                         codec->avc_profile));\n                        NGX_RTMP_STAT_L(\"\\\"\");\n                    }\n                    if (codec->avc_compat) {\n                        NGX_RTMP_STAT_L(\",\\\"compat\\\":\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->avc_compat) - buf);\n                    }\n                    if (codec->avc_level) {\n                        NGX_RTMP_STAT_L(\",\\\"level\\\":\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%.1f\", codec->avc_level / 10.) - buf);\n                    }\n\n                    NGX_RTMP_STAT_L(\"},\\\"audio\\\":{\");\n                    cname = ngx_rtmp_get_audio_codec_name(codec->audio_codec_id);\n                    f = 0;\n                    if (*cname) {\n                        f = 1;\n                        NGX_RTMP_STAT_L(\"\\\"codec\\\":\\\"\");\n                        NGX_RTMP_STAT_ECS(cname);\n                    }\n                    if (codec->aac_profile) {\n                        if (f == 1) NGX_RTMP_STAT_L(\"\\\",\");\n                        f = 2;\n                        NGX_RTMP_STAT_L(\"\\\"profile\\\":\\\"\");\n                        NGX_RTMP_STAT_CS(\n                            ngx_rtmp_stat_get_aac_profile(codec->aac_profile,\n                                                          codec->aac_sbr,\n                                                          codec->aac_ps));\n                    }\n                    if (codec->aac_chan_conf) {\n                        if (f >= 1) NGX_RTMP_STAT_L(\"\\\",\");\n                        f = 3;\n                        NGX_RTMP_STAT_L(\"\\\"channels\\\":\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->aac_chan_conf) - buf);\n                    } else if (codec->audio_channels) {\n                        if (f >= 1) NGX_RTMP_STAT_L(\"\\\",\");\n                        f = 3;\n                        NGX_RTMP_STAT_L(\"\\\"channels\\\":\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->audio_channels) - buf);\n                    }\n                    if (codec->sample_rate) {\n                        if (f == 1 || f == 2) {\n                            NGX_RTMP_STAT_L(\"\\\",\");\n                        } else if (f == 3) {\n                            NGX_RTMP_STAT_L(\",\");\n                        }\n                        f = 4;\n                        NGX_RTMP_STAT_L(\"\\\"sample_rate\\\":\");\n                        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                                      \"%ui\", codec->sample_rate) - buf);\n                    }\n                    if (f == 1 || f == 2) {\n                        NGX_RTMP_STAT_L(\"\\\"\");\n                    }\n                    NGX_RTMP_STAT_L(\"}}\");\n                }\n            }\n\n            if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"<nclients>\");\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                              \"%ui\", nclients) - buf);\n                NGX_RTMP_STAT_L(\"</nclients>\\r\\n\");\n\n                if (stream->publishing) {\n                    NGX_RTMP_STAT_L(\"<publishing/>\\r\\n\");\n                }\n\n                if (stream->active) {\n                    NGX_RTMP_STAT_L(\"<active/>\\r\\n\");\n                }\n\n                NGX_RTMP_STAT_L(\"</stream>\\r\\n\");\n            } else {\n                if (codec) {\n                    NGX_RTMP_STAT_L(\",\");\n                }\n                NGX_RTMP_STAT_L(\"\\\"nclients\\\":\");\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                              \"%ui\", nclients) - buf);\n\n                NGX_RTMP_STAT_L(\",\\\"publishing\\\":\");\n                if (stream->publishing) {\n                    NGX_RTMP_STAT_L(\"true\");\n                } else {\n                    NGX_RTMP_STAT_L(\"false\");\n                }\n\n                NGX_RTMP_STAT_L(\",\\\"active\\\":\");\n                if (stream->active) {\n                    NGX_RTMP_STAT_L(\"true\");\n                } else {\n                    NGX_RTMP_STAT_L(\"false\");\n                }\n\n                NGX_RTMP_STAT_L(\"}\");\n            }\n        }\n    }\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<nclients>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", total_nclients) - buf);\n        NGX_RTMP_STAT_L(\"</nclients>\\r\\n\");\n        NGX_RTMP_STAT_L(\"</live>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"],\\\"nclients\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", total_nclients) - buf);\n        NGX_RTMP_STAT_L(\"}\");\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_play(ngx_http_request_t *r, ngx_chain_t ***lll,\n        ngx_rtmp_play_app_conf_t *pacf)\n{\n    ngx_rtmp_play_ctx_t            *ctx, *sctx;\n    ngx_rtmp_session_t             *s;\n    ngx_uint_t                      n, nclients, total_nclients;\n    ngx_flag_t                      prev;\n    u_char                          buf[NGX_INT_T_LEN];\n    u_char                          bbuf[NGX_INT32_LEN];\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    if (pacf->entries.nelts == 0) {\n        return;\n    }\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n    \n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<play>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\",\\\"play\\\":{\");\n        NGX_RTMP_STAT_L(\"\\\"streams\\\":[\");\n    }\n\n    total_nclients = 0;\n    prev = 0;\n    for (n = 0; n < pacf->nbuckets; ++n) {\n        for (ctx = pacf->ctx[n]; ctx; ) {\n            if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"<stream>\\r\\n\");\n                NGX_RTMP_STAT_L(\"<name>\");\n                NGX_RTMP_STAT_ECS(ctx->name);\n                NGX_RTMP_STAT_L(\"</name>\\r\\n\");\n            } else {\n                if (prev) {\n                    NGX_RTMP_STAT_L(\",\");\n                }\n\n                prev = 1;\n                NGX_RTMP_STAT_L(\"{\\\"name\\\":\\\"\");\n                NGX_RTMP_STAT_ECS(ctx->name);\n                NGX_RTMP_STAT_L(\"\\\",\\\"clients\\\":[\");\n            }\n\n            nclients = 0;\n            sctx = ctx;\n            for (; ctx; ctx = ctx->next) {\n                if (ngx_strcmp(ctx->name, sctx->name)) {\n                    break;\n                }\n\n                nclients++;\n\n                s = ctx->session;\n                if (slcf->stat & NGX_RTMP_STAT_CLIENTS) {\n                    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                        NGX_RTMP_STAT_L(\"<client>\\r\\n\");\n\n                        ngx_rtmp_stat_client(r, lll, s);\n\n                        NGX_RTMP_STAT_L(\"<timestamp>\");\n                        NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                      \"%D\", s->current_time) - bbuf);\n                        NGX_RTMP_STAT_L(\"</timestamp>\\r\\n\");\n\n                        NGX_RTMP_STAT_L(\"</client>\\r\\n\");\n                    } else {\n                        NGX_RTMP_STAT_L(\"{\");\n\n                        ngx_rtmp_stat_client(r, lll, s);\n\n                        NGX_RTMP_STAT_L(\"\\\"timestamp\\\":\");\n                        NGX_RTMP_STAT(bbuf, ngx_snprintf(bbuf, sizeof(bbuf),\n                                      \"%D\", s->current_time) - bbuf);\n\n                        NGX_RTMP_STAT_L(\"}\");\n                    }\n                }\n            }\n            total_nclients += nclients;\n            if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n                NGX_RTMP_STAT_L(\"<active/>\");\n                NGX_RTMP_STAT_L(\"<nclients>\");\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                              \"%ui\", nclients) - buf);\n                NGX_RTMP_STAT_L(\"</nclients>\\r\\n\");\n\n                NGX_RTMP_STAT_L(\"</stream>\\r\\n\");             \n            } else {\n                NGX_RTMP_STAT_L(\"],\");\n                NGX_RTMP_STAT_L(\"\\\"active\\\":true,\");\n                NGX_RTMP_STAT_L(\"\\\"nclients\\\":\");\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                              \"%ui\", nclients) - buf);\n                NGX_RTMP_STAT_L(\"}\");\n            }\n        }\n    }\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<nclients>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", total_nclients) - buf);\n        NGX_RTMP_STAT_L(\"</nclients>\\r\\n\");\n        NGX_RTMP_STAT_L(\"</play>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"],\\\"nclients\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", total_nclients) - buf);\n        NGX_RTMP_STAT_L(\"}\");\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_application_recorders(ngx_http_request_t *r, ngx_chain_t ***lll,\n    ngx_rtmp_core_app_conf_t *cacf)\n{\n    size_t                       n, len;\n    u_char                       flag[NGX_RTMP_MAX_URL];\n    u_char                       buf[NGX_INT_T_LEN];\n    ngx_rtmp_record_app_conf_t  *racf, *lracf, **rracf;\n    ngx_rtmp_stat_loc_conf_t    *slcf;\n\n    racf = cacf->app_conf[ngx_rtmp_record_module.ctx_index];\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n\n    if(slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<recorders>\\r\\n\");\n        NGX_RTMP_STAT_L(\"<count>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", racf->rec.nelts) - buf);\n        NGX_RTMP_STAT_L(\"</count>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\",\\\"recorders\\\":{\");\n        NGX_RTMP_STAT_L(\"\\\"count\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", racf->rec.nelts) - buf);\n        NGX_RTMP_STAT_L(\",\\\"lists\\\":[\");           \n    }\n\n    rracf = racf->rec.elts;\n    for(n = 0; n < racf->rec.nelts; ++n, ++rracf) {\n        lracf = *rracf;\n\n        if(n > 0 && n < racf->rec.nelts - 1) {\n            NGX_RTMP_STAT_L(\",\");\n        }\n\n        if(slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n            NGX_RTMP_STAT_L(\"<recorder>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<id>\");\n            NGX_RTMP_STAT_S(&lracf->id);\n            NGX_RTMP_STAT_L(\"</id>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<flags>\");\n\n            if(lracf->flags & NGX_RTMP_RECORD_OFF) {\n                NGX_RTMP_STAT_L(\"<off/>\");\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_VIDEO) {\n                NGX_RTMP_STAT_L(\"<video/>\");\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_AUDIO) {\n                NGX_RTMP_STAT_L(\"<audio/>\");\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_KEYFRAMES) {\n                NGX_RTMP_STAT_L(\"<keyframes/>\");\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_MANUAL) {\n                NGX_RTMP_STAT_L(\"<manual/>\");\n            }\n\n            NGX_RTMP_STAT_L(\"</flags>\\r\\n\");\n\n            if(lracf->unique) {\n                NGX_RTMP_STAT_L(\"<unique/>\\r\\n\");\n            }\n\n            if(lracf->append) {\n                NGX_RTMP_STAT_L(\"<append/>\\r\\n\");\n            }\n\n            if(lracf->lock_file) {\n                NGX_RTMP_STAT_L(\"<lock_file/>\\r\\n\");\n            }\n\n            if(lracf->notify) {\n                NGX_RTMP_STAT_L(\"<notify/>\\r\\n\");\n            }\n\n            NGX_RTMP_STAT_L(\"<path>\");\n            NGX_RTMP_STAT_S(&lracf->path);\n            NGX_RTMP_STAT_L(\"</path>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<max_size>\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                          \"%ui\", (ngx_uint_t)lracf->max_size) - buf);\n            NGX_RTMP_STAT_L(\"</max_size>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<max_frames>\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                          \"%ui\", (ngx_uint_t)lracf->max_frames) - buf);\n            NGX_RTMP_STAT_L(\"</max_frames>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<interval>\");\n\n            if (lracf->interval == NGX_CONF_UNSET_MSEC) {\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                              \"%d\", -1) - buf);\n            } else {\n                NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                              \"%ui\", lracf->interval) - buf);\n            }\n\n            NGX_RTMP_STAT_L(\"</interval>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"<suffix>\");\n            NGX_RTMP_STAT_S(&lracf->suffix);\n            NGX_RTMP_STAT_L(\"</suffix>\\r\\n\");\n\n            NGX_RTMP_STAT_L(\"</recorder>\\r\\n\");\n        } else {\n            NGX_RTMP_STAT_L(\"{\\\"id\\\":\\\"\");\n            NGX_RTMP_STAT_S(&lracf->id);\n            NGX_RTMP_STAT_L(\"\\\",\\\"flags\\\":[\");\n\n            ngx_memzero(flag, sizeof(flag));\n\n            if(lracf->flags & NGX_RTMP_RECORD_OFF) {\n                *ngx_snprintf(flag + ngx_strlen(flag),\n                              NGX_RTMP_MAX_URL - ngx_strlen(flag),\n                              \"%s\", \"\\\"off\\\"\") = 0;\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_VIDEO) {\n                len = ngx_strlen(flag);\n                if (len &&\n                    (len + 1) < NGX_RTMP_MAX_URL &&\n                    flag[len - 1] != ',')\n                {\n                    flag[len++] = ',';\n                }\n\n                if (NGX_RTMP_MAX_URL - len >= sizeof(\"\\\"video\\\"\")) {\n                    *ngx_snprintf(flag + ngx_strlen(flag),\n                                  NGX_RTMP_MAX_URL - len,\n                                  \"%s\", \"\\\"video\\\"\") = 0;\n                } else {\n                    if (flag[len - 1] == ',') {\n                        flag[len - 1] = 0;\n                    }\n                }\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_AUDIO) {\n                len = ngx_strlen(flag);\n                if (len &&\n                    (len + 1) < NGX_RTMP_MAX_URL &&\n                    flag[len - 1] != ',')\n                {\n                    flag[len++] = ',';\n                }\n\n                if (NGX_RTMP_MAX_URL - len >= sizeof(\"\\\"audio\\\"\")) {\n                    *ngx_snprintf(flag + ngx_strlen(flag),\n                                  NGX_RTMP_MAX_URL - len,\n                                  \"%s\", \"\\\"audio\\\"\") = 0;\n                } else {\n                    if (flag[len - 1] == ',') {\n                        flag[len - 1] = 0;\n                    }\n                }\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_KEYFRAMES) {\n                len = ngx_strlen(flag);\n                if (len &&\n                    (len + 1) < NGX_RTMP_MAX_URL &&\n                    flag[len - 1] != ',')\n                {\n                    flag[len++] = ',';\n                }\n\n                if (NGX_RTMP_MAX_URL - len >= sizeof(\"\\\"keyframes\\\"\")) {\n                    *ngx_snprintf(flag + ngx_strlen(flag),\n                                  NGX_RTMP_MAX_URL - len,\n                                  \"%s\", \"\\\"keyframes\\\"\") = 0;\n                } else {\n                    if (flag[len - 1] == ',') {\n                        flag[len - 1] = 0;\n                    }\n                }\n            }\n\n            if(lracf->flags & NGX_RTMP_RECORD_MANUAL) {\n                len = ngx_strlen(flag);\n                if (len &&\n                    (len + 1) < NGX_RTMP_MAX_URL &&\n                    flag[len - 1] != ',')\n                {\n                    flag[len++] = ',';\n                }\n\n                if (NGX_RTMP_MAX_URL - len >= sizeof(\"\\\"manual\\\"\")) {\n                    *ngx_snprintf(flag + ngx_strlen(flag),\n                                  NGX_RTMP_MAX_URL - len,\n                                  \"%s\", \"\\\"manual\\\"\") = 0;\n                } else {\n                    if (flag[len - 1] == ',') {\n                        flag[len - 1] = 0;\n                    }\n                }\n            }\n\n            NGX_RTMP_STAT_CS(flag);\n\n            NGX_RTMP_STAT_L(\"]\");\n\n            if(lracf->unique) {\n                NGX_RTMP_STAT_L(\",\\\"unique\\\":true\");\n            } else {\n                NGX_RTMP_STAT_L(\",\\\"unique\\\":false\");\n            }\n\n            if(lracf->append) {\n                NGX_RTMP_STAT_L(\",\\\"append\\\":true\");\n            } else {\n                NGX_RTMP_STAT_L(\",\\\"append\\\":false\");\n            }\n\n            if(lracf->lock_file) {\n                NGX_RTMP_STAT_L(\",\\\"lock_file\\\":true\");\n            } else {\n                NGX_RTMP_STAT_L(\",\\\"lock_file\\\":false\");\n            }\n\n            if(lracf->notify) {\n                NGX_RTMP_STAT_L(\",\\\"notify\\\":true\");\n            } else {\n                NGX_RTMP_STAT_L(\",\\\"notify\\\":false\");\n            }\n\n            NGX_RTMP_STAT_L(\",\\\"path\\\":\\\"\");\n            NGX_RTMP_STAT_S(&lracf->path);\n\n            NGX_RTMP_STAT_L(\"\\\",\\\"max_size\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                          \"%ui\", (ngx_uint_t)lracf->max_size) - buf);\n\n            NGX_RTMP_STAT_L(\",\\\"max_frames\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                          \"%ui\", (ngx_uint_t)lracf->max_frames) - buf);\n\n            NGX_RTMP_STAT_L(\",\\\"interval\\\":\");\n            NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                          \"%ui\", lracf->interval) - buf);\n\n            NGX_RTMP_STAT_L(\",\\\"suffix\\\":\\\"\");\n            NGX_RTMP_STAT_S(&lracf->suffix);\n            NGX_RTMP_STAT_L(\"\\\"}\");\n        }\n    }\n\n    if(slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"</recorders>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"]}\");\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_application(ngx_http_request_t *r, ngx_chain_t ***lll,\n        ngx_rtmp_core_srv_conf_t *cscf, ngx_rtmp_core_app_conf_t *cacf)\n{\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<application>\\r\\n\");\n        NGX_RTMP_STAT_L(\"<name>\");\n        NGX_RTMP_STAT_ES(&cacf->name);\n        NGX_RTMP_STAT_L(\"</name>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"{\");\n        NGX_RTMP_STAT_L(\"\\\"name\\\":\\\"\");\n        NGX_RTMP_STAT_ES(&cacf->name);\n        NGX_RTMP_STAT_L(\"\\\"\");\n    }\n\n    if (slcf->stat & NGX_RTMP_STAT_LIVE) {\n        ngx_rtmp_stat_live(r, lll,\n                cacf->app_conf[ngx_rtmp_live_module.ctx_index]);\n    }\n\n    if (slcf->stat & NGX_RTMP_STAT_PLAY) {\n        ngx_rtmp_stat_play(r, lll,\n                cacf->app_conf[ngx_rtmp_play_module.ctx_index]);\n    }\n\n    if (slcf->stat & NGX_RTMP_STAT_RECORD) {\n        ngx_rtmp_stat_application_recorders(r, lll, cacf);\n    }\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"</application>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"}\");\n    }\n}\n\n\nstatic void\nngx_rtmp_stat_server(ngx_http_request_t *r, ngx_chain_t ***lll,\n        ngx_rtmp_core_srv_conf_t *cscf)\n{\n    u_char                          buf[NGX_INT_T_LEN];\n    size_t                          n;\n    ngx_rtmp_core_app_conf_t      **cacf;\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<server>\\r\\n\");\n        NGX_RTMP_STAT_L(\"<port>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", cscf->port) - buf);\n        NGX_RTMP_STAT_L(\"</port>\\r\\n\");\n        NGX_RTMP_STAT_L(\"<server_index>\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", cscf->index) - buf);\n        NGX_RTMP_STAT_L(\"</server_index>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"{\");\n        NGX_RTMP_STAT_L(\"\\\"port\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", cscf->port) - buf);\n        NGX_RTMP_STAT_L(\",\");\n        NGX_RTMP_STAT_L(\"\\\"server_index\\\":\");\n        NGX_RTMP_STAT(buf, ngx_snprintf(buf, sizeof(buf),\n                      \"%ui\", cscf->index) - buf);\n        NGX_RTMP_STAT_L(\",\");\n    }\n\n#ifdef NGX_RTMP_POOL_DEBUG\n    ngx_rtmp_stat_dump_pool(r, lll, cscf->pool);\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_JSON) {\n        NGX_RTMP_STAT_L(\",\");\n    }\n#endif\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_JSON) {\n        NGX_RTMP_STAT_L(\"\\\"applications\\\":[\");\n    }\n\n    cacf = cscf->applications.elts;\n    for (n = 0; n < cscf->applications.nelts; ++n, ++cacf) {\n        ngx_rtmp_stat_application(r, lll, cscf, *cacf);\n\n        if (slcf->format & NGX_RTMP_STAT_FORMAT_JSON &&\n            n < cscf->applications.nelts - 1)\n        {\n            NGX_RTMP_STAT_L(\",\");\n        }\n    }\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"</server>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"]}\");\n    }\n}\n\n\nstatic ngx_int_t\nngx_rtmp_stat_handler(ngx_http_request_t *r)\n{\n    ngx_rtmp_stat_loc_conf_t       *slcf;\n    ngx_rtmp_core_main_conf_t      *cmcf;\n    ngx_rtmp_core_srv_conf_t      **cscf;\n    ngx_chain_t                    *cl, *l, **ll, ***lll;\n    size_t                          n;\n    off_t                           len;\n    static u_char                   tbuf[NGX_TIME_T_LEN];\n    static u_char                   nbuf[NGX_INT_T_LEN];\n\n    slcf = ngx_http_get_module_loc_conf(r, ngx_rtmp_stat_module);\n    if (slcf->stat == 0) {\n        return NGX_DECLINED;\n    }\n\n    if (slcf->format == 0) {\n        slcf->format = NGX_RTMP_STAT_FORMAT_XML;\n    }\n\n    cmcf = ngx_rtmp_core_main_conf;\n    if (cmcf == NULL) {\n        goto error;\n    }\n\n    cl = NULL;\n    ll = &cl;\n    lll = &ll;\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\r\\n\");\n        if (slcf->stylesheet.len) {\n            NGX_RTMP_STAT_L(\"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\");\n            NGX_RTMP_STAT_ES(&slcf->stylesheet);\n            NGX_RTMP_STAT_L(\"\\\" ?>\\r\\n\");\n        }\n\n        NGX_RTMP_STAT_L(\"<http-flv>\\r\\n\");\n\n    #ifdef NGINX_VERSION\n        NGX_RTMP_STAT_L(\"<nginx_version>\" NGINX_VERSION \"</nginx_version>\\r\\n\");\n    #endif\n\n    #ifdef NGINX_RTMP_VERSION\n        NGX_RTMP_STAT_L(\"<nginx_http_flv_version>\"\n                        NGINX_RTMP_VERSION\n                        \"</nginx_http_flv_version>\\r\\n\");\n    #endif\n\n    #ifdef NGX_COMPILER\n        NGX_RTMP_STAT_L(\"<compiler>\" NGX_COMPILER \"</compiler>\\r\\n\");\n    #endif\n        NGX_RTMP_STAT_L(\"<built>\" __DATE__ \" \" __TIME__ \"</built>\\r\\n\");\n\n        NGX_RTMP_STAT_L(\"<pid>\");\n        NGX_RTMP_STAT(nbuf, ngx_snprintf(nbuf, sizeof(nbuf),\n                      \"%ui\", (ngx_uint_t) ngx_getpid()) - nbuf);\n        NGX_RTMP_STAT_L(\"</pid>\\r\\n\");\n\n        NGX_RTMP_STAT_L(\"<uptime>\");\n        NGX_RTMP_STAT(tbuf, ngx_snprintf(tbuf, sizeof(tbuf),\n                      \"%T\", ngx_cached_time->sec - start_time) - tbuf);\n        NGX_RTMP_STAT_L(\"</uptime>\\r\\n\");\n\n        NGX_RTMP_STAT_L(\"<naccepted>\");\n        NGX_RTMP_STAT(nbuf, ngx_snprintf(nbuf, sizeof(nbuf),\n                      \"%ui\", ngx_rtmp_naccepted) - nbuf);\n        NGX_RTMP_STAT_L(\"</naccepted>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"{\\\"http-flv\\\":{\");\n\n    #ifdef NGINX_VERSION\n        NGX_RTMP_STAT_L(\"\\\"nginx_version\\\":\\\"\" NGINX_VERSION \"\\\",\");\n    #endif\n\n    #ifdef NGINX_RTMP_VERSION\n        NGX_RTMP_STAT_L(\"\\\"nginx_http_flv_version\\\":\\\"\"\n                        NGINX_RTMP_VERSION\n                        \"\\\",\");\n    #endif\n\n    #ifdef NGX_COMPILER\n        NGX_RTMP_STAT_L(\"\\\"compiler\\\":\\\"\" NGX_COMPILER \"\\\",\");\n    #endif\n        NGX_RTMP_STAT_L(\"\\\"built\\\":\\\"\" __DATE__ \" \" __TIME__ \"\\\",\");\n\n        NGX_RTMP_STAT_L(\"\\\"pid\\\":\");\n        NGX_RTMP_STAT(nbuf, ngx_snprintf(nbuf, sizeof(nbuf),\n                      \"%ui\", (ngx_uint_t) ngx_getpid()) - nbuf);\n        NGX_RTMP_STAT_L(\",\");\n\n        NGX_RTMP_STAT_L(\"\\\"uptime\\\":\");\n        NGX_RTMP_STAT(tbuf, ngx_snprintf(tbuf, sizeof(tbuf),\n                      \"%T\", ngx_cached_time->sec - start_time) - tbuf);\n        NGX_RTMP_STAT_L(\",\");\n\n        NGX_RTMP_STAT_L(\"\\\"naccepted\\\":\");\n        NGX_RTMP_STAT(nbuf, ngx_snprintf(nbuf, sizeof(nbuf),\n                      \"%ui\", ngx_rtmp_naccepted) - nbuf);\n        NGX_RTMP_STAT_L(\",\");\n    }\n\n    ngx_rtmp_stat_bw(r, lll, &ngx_rtmp_bw_in, \"in\", NGX_RTMP_STAT_BW_BYTES);\n    ngx_rtmp_stat_bw(r, lll, &ngx_rtmp_bw_out, \"out\", NGX_RTMP_STAT_BW_BYTES);\n    \n    if (slcf->format & NGX_RTMP_STAT_FORMAT_JSON) {\n        NGX_RTMP_STAT_L(\"\\\"servers\\\":[\");\n    }\n\n    cscf = cmcf->servers.elts;\n    for (n = 0; n < cmcf->servers.nelts; ++n, ++cscf) {\n        ngx_rtmp_stat_server(r, lll, *cscf);\n        if (n < cmcf->servers.nelts - 1 &&\n            slcf->format & NGX_RTMP_STAT_FORMAT_JSON)\n        {\n            NGX_RTMP_STAT_L(\",\");\n        }\n    }\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        NGX_RTMP_STAT_L(\"</http-flv>\\r\\n\");\n    } else {\n        NGX_RTMP_STAT_L(\"]}}\");\n    }\n\n    len = 0;\n    for (l = cl; l; l = l->next) {\n        len += (l->buf->last - l->buf->pos);\n    }\n\n    if (slcf->format & NGX_RTMP_STAT_FORMAT_XML) {\n        ngx_str_set(&r->headers_out.content_type, \"text/xml\");\n    } else {\n        ngx_str_set(&r->headers_out.content_type, \"application/json\");\n    }\n    r->headers_out.content_length_n = len;\n    r->headers_out.status = NGX_HTTP_OK;\n    ngx_http_send_header(r);\n    (*ll)->buf->last_buf = 1;\n    return ngx_http_output_filter(r, cl);\n\nerror:\n    r->headers_out.status = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    r->headers_out.content_length_n = 0;\n    return ngx_http_send_header(r);\n}\n\n\nstatic void *\nngx_rtmp_stat_create_loc_conf(ngx_conf_t *cf)\n{\n    ngx_rtmp_stat_loc_conf_t       *conf;\n\n    conf = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_stat_loc_conf_t));\n    if (conf == NULL) {\n        return NULL;\n    }\n\n    conf->stat = 0;\n\n    return conf;\n}\n\n\nstatic char *\nngx_rtmp_stat_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_rtmp_stat_loc_conf_t       *prev = parent;\n    ngx_rtmp_stat_loc_conf_t       *conf = child;\n\n    ngx_conf_merge_bitmask_value(conf->stat, prev->stat, 0);\n    ngx_conf_merge_str_value(conf->stylesheet, prev->stylesheet, \"\");\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_rtmp_stat(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_http_core_loc_conf_t  *clcf;\n\n    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n    clcf->handler = ngx_rtmp_stat_handler;\n\n    return ngx_conf_set_bitmask_slot(cf, cmd, conf);\n}\n\n\nstatic ngx_int_t\nngx_rtmp_stat_postconfiguration(ngx_conf_t *cf)\n{\n    start_time = ngx_cached_time->sec;\n\n    return NGX_OK;\n}\n"
        },
        {
          "name": "ngx_rtmp_streams.h",
          "type": "blob",
          "size": 0.369140625,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n */\n\n\n#ifndef _NGX_RTMP_STREAMS_H_INCLUDED_\n#define _NGX_RTMP_STREAMS_H_INCLUDED_\n\n\n#define NGX_RTMP_MSID                   1\n\n#define NGX_RTMP_CSID_AMF_INI           3\n#define NGX_RTMP_CSID_AMF               5\n#define NGX_RTMP_CSID_AUDIO             6\n#define NGX_RTMP_CSID_VIDEO             7\n\n\n#endif /* _NGX_RTMP_STREAMS_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_variables.c",
          "type": "blob",
          "size": 32.19921875,
          "content": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n * Copyright (C) Winshining\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <nginx.h>\n#include \"ngx_rtmp.h\"\n\nstatic ngx_rtmp_variable_t *ngx_rtmp_add_prefix_variable(ngx_conf_t *cf,\n    ngx_str_t *name, ngx_uint_t flags);\n\nstatic ngx_int_t ngx_rtmp_variable_request(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n\nstatic ngx_int_t ngx_rtmp_variable_argument(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n#if (NGX_HAVE_TCP_INFO)\nstatic ngx_int_t ngx_rtmp_variable_tcpinfo(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n#endif\n\nstatic ngx_int_t ngx_rtmp_variable_host(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_binary_remote_addr(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_remote_addr(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_remote_port(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_server_addr(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_server_port(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic void ngx_rtmp_variable_set_args(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_is_args(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_server_name(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_bytes_sent(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_request_time(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_request_id(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n\nstatic ngx_int_t ngx_rtmp_variable_connection(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n\nstatic ngx_int_t ngx_rtmp_variable_nginx_version(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_hostname(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_pid(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\nstatic ngx_int_t ngx_rtmp_variable_msec(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n\n\nstatic ngx_rtmp_variable_t  ngx_rtmp_core_variables[] = {\n    { ngx_string(\"host\"), NULL, ngx_rtmp_variable_host, 0, 0, 0 },\n\n    { ngx_string(\"binary_remote_addr\"), NULL,\n      ngx_rtmp_variable_binary_remote_addr, 0, 0, 0 },\n\n    { ngx_string(\"remote_addr\"), NULL, ngx_rtmp_variable_remote_addr, 0, 0, 0 },\n\n    { ngx_string(\"remote_port\"), NULL, ngx_rtmp_variable_remote_port, 0, 0, 0 },\n\n    { ngx_string(\"server_addr\"), NULL, ngx_rtmp_variable_server_addr, 0, 0, 0 },\n\n    { ngx_string(\"server_port\"), NULL, ngx_rtmp_variable_server_port, 0, 0, 0 },\n\n    { ngx_string(\"request_uri\"), NULL, ngx_rtmp_variable_request,\n      offsetof(ngx_rtmp_session_t, unparsed_uri), 0, 0 },\n\n    { ngx_string(\"uri\"), NULL, ngx_rtmp_variable_request,\n      offsetof(ngx_rtmp_session_t, uri),\n      NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"query_string\"), NULL, ngx_rtmp_variable_request,\n      offsetof(ngx_rtmp_session_t, args),\n      NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"args\"),\n      ngx_rtmp_variable_set_args,\n      ngx_rtmp_variable_request,\n      offsetof(ngx_rtmp_session_t, args),\n      NGX_RTMP_VAR_CHANGEABLE|NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"is_args\"), NULL, ngx_rtmp_variable_is_args,\n      0, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"server_name\"), NULL, ngx_rtmp_variable_server_name, 0, 0, 0 },\n\n    { ngx_string(\"bytes_sent\"), NULL, ngx_rtmp_variable_bytes_sent,\n      0, 0, 0 },\n\n    { ngx_string(\"request_time\"), NULL, ngx_rtmp_variable_request_time,\n      0, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"request_id\"), NULL,\n      ngx_rtmp_variable_request_id,\n      0, 0, 0 },\n\n    { ngx_string(\"connection\"), NULL,\n      ngx_rtmp_variable_connection, 0, 0, 0 },\n\n    { ngx_string(\"nginx_version\"), NULL, ngx_rtmp_variable_nginx_version,\n      0, 0, 0 },\n\n    { ngx_string(\"hostname\"), NULL, ngx_rtmp_variable_hostname,\n      0, 0, 0 },\n\n    { ngx_string(\"pid\"), NULL, ngx_rtmp_variable_pid,\n      0, 0, 0 },\n\n    { ngx_string(\"msec\"), NULL, ngx_rtmp_variable_msec,\n      0, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n#if (NGX_HAVE_TCP_INFO)\n    { ngx_string(\"tcpinfo_rtt\"), NULL, ngx_rtmp_variable_tcpinfo,\n      0, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"tcpinfo_rttvar\"), NULL, ngx_rtmp_variable_tcpinfo,\n      1, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"tcpinfo_snd_cwnd\"), NULL, ngx_rtmp_variable_tcpinfo,\n      2, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n\n    { ngx_string(\"tcpinfo_rcv_space\"), NULL, ngx_rtmp_variable_tcpinfo,\n      3, NGX_RTMP_VAR_NOCACHEABLE, 0 },\n#endif\n\n    { ngx_string(\"arg_\"), NULL, ngx_rtmp_variable_argument,\n      0, NGX_RTMP_VAR_NOCACHEABLE|NGX_RTMP_VAR_PREFIX, 0 },\n\n    { ngx_null_string, NULL, NULL, 0, 0, 0 }\n};\n\n\nngx_rtmp_variable_value_t  ngx_rtmp_variable_null_value =\n    ngx_rtmp_variable(\"\");\nngx_rtmp_variable_value_t  ngx_rtmp_variable_true_value =\n    ngx_rtmp_variable(\"1\");\n\n\nstatic ngx_uint_t  ngx_rtmp_variable_depth = 100;\n\n\nngx_rtmp_variable_t *\nngx_rtmp_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)\n{\n    ngx_int_t                   rc;\n    ngx_uint_t                  i;\n    ngx_hash_key_t             *key;\n    ngx_rtmp_variable_t        *v;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    if (name->len == 0) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid variable name \\\"$\\\"\");\n        return NULL;\n    }\n\n    if (flags & NGX_RTMP_VAR_PREFIX) {\n        return ngx_rtmp_add_prefix_variable(cf, name, flags);\n    }\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    key = cmcf->variables_keys->keys.elts;\n    for (i = 0; i < cmcf->variables_keys->keys.nelts; i++) {\n        if (name->len != key[i].key.len\n            || ngx_strncasecmp(name->data, key[i].key.data, name->len) != 0)\n        {\n            continue;\n        }\n\n        v = key[i].value;\n\n        if (!(v->flags & NGX_RTMP_VAR_CHANGEABLE)) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"the duplicate \\\"%V\\\" variable\", name);\n            return NULL;\n        }\n\n        v->flags &= flags | ~NGX_RTMP_VAR_WEAK;\n\n        return v;\n    }\n\n    v = ngx_palloc(cf->pool, sizeof(ngx_rtmp_variable_t));\n    if (v == NULL) {\n        return NULL;\n    }\n\n    v->name.len = name->len;\n    v->name.data = ngx_pnalloc(cf->pool, name->len);\n    if (v->name.data == NULL) {\n        return NULL;\n    }\n\n    ngx_strlow(v->name.data, name->data, name->len);\n\n    v->set_handler = NULL;\n    v->get_handler = NULL;\n    v->data = 0;\n    v->flags = flags;\n    v->index = 0;\n\n    rc = ngx_hash_add_key(cmcf->variables_keys, &v->name, v, 0);\n\n    if (rc == NGX_ERROR) {\n        return NULL;\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting variable name \\\"%V\\\"\", name);\n        return NULL;\n    }\n\n    return v;\n}\n\n\nstatic ngx_rtmp_variable_t *\nngx_rtmp_add_prefix_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)\n{\n    ngx_uint_t                  i;\n    ngx_rtmp_variable_t        *v;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    v = cmcf->prefix_variables.elts;\n    for (i = 0; i < cmcf->prefix_variables.nelts; i++) {\n        if (name->len != v[i].name.len\n            || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)\n        {\n            continue;\n        }\n\n        v = &v[i];\n\n        if (!(v->flags & NGX_RTMP_VAR_CHANGEABLE)) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"the duplicate \\\"%V\\\" variable\", name);\n            return NULL;\n        }\n\n        v->flags &= flags | ~NGX_RTMP_VAR_WEAK;\n\n        return v;\n    }\n\n    v = ngx_array_push(&cmcf->prefix_variables);\n    if (v == NULL) {\n        return NULL;\n    }\n\n    v->name.len = name->len;\n    v->name.data = ngx_pnalloc(cf->pool, name->len);\n    if (v->name.data == NULL) {\n        return NULL;\n    }\n\n    ngx_strlow(v->name.data, name->data, name->len);\n\n    v->set_handler = NULL;\n    v->get_handler = NULL;\n    v->data = 0;\n    v->flags = flags;\n    v->index = 0;\n\n    return v;\n}\n\n\nngx_int_t\nngx_rtmp_get_variable_index(ngx_conf_t *cf, ngx_str_t *name)\n{\n    ngx_uint_t                  i;\n    ngx_rtmp_variable_t        *v;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    if (name->len == 0) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid variable name \\\"$\\\"\");\n        return NGX_ERROR;\n    }\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    v = cmcf->variables.elts;\n\n    if (v == NULL) {\n        if (ngx_array_init(&cmcf->variables, cf->pool, 4,\n                           sizeof(ngx_rtmp_variable_t))\n            != NGX_OK)\n        {\n            return NGX_ERROR;\n        }\n\n    } else {\n        for (i = 0; i < cmcf->variables.nelts; i++) {\n            if (name->len != v[i].name.len\n                || ngx_strncasecmp(name->data, v[i].name.data, name->len) != 0)\n            {\n                continue;\n            }\n\n            return i;\n        }\n    }\n\n    v = ngx_array_push(&cmcf->variables);\n    if (v == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->name.len = name->len;\n    v->name.data = ngx_pnalloc(cf->pool, name->len);\n    if (v->name.data == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_strlow(v->name.data, name->data, name->len);\n\n    v->set_handler = NULL;\n    v->get_handler = NULL;\n    v->data = 0;\n    v->flags = 0;\n    v->index = cmcf->variables.nelts - 1;\n\n    return v->index;\n}\n\n\nngx_rtmp_variable_value_t *\nngx_rtmp_get_indexed_variable(ngx_rtmp_session_t *s, ngx_uint_t index)\n{\n    ngx_rtmp_variable_t        *v;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_core_module);\n\n    if (cmcf->variables.nelts <= index) {\n        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,\n                      \"unknown variable index: %ui\", index);\n        return NULL;\n    }\n\n    if (s->variables[index].not_found || s->variables[index].valid) {\n        return &s->variables[index];\n    }\n\n    v = cmcf->variables.elts;\n\n    if (ngx_rtmp_variable_depth == 0) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"cycle while evaluating variable \\\"%V\\\"\",\n                      &v[index].name);\n        return NULL;\n    }\n\n    ngx_rtmp_variable_depth--;\n\n    if (v[index].get_handler(s, &s->variables[index], v[index].data)\n        == NGX_OK)\n    {\n        ngx_rtmp_variable_depth++;\n\n        if (v[index].flags & NGX_RTMP_VAR_NOCACHEABLE) {\n            s->variables[index].no_cacheable = 1;\n        }\n\n        return &s->variables[index];\n    }\n\n    ngx_rtmp_variable_depth++;\n\n    s->variables[index].valid = 0;\n    s->variables[index].not_found = 1;\n\n    return NULL;\n}\n\n\nngx_rtmp_variable_value_t *\nngx_rtmp_get_flushed_variable(ngx_rtmp_session_t *s, ngx_uint_t index)\n{\n    ngx_rtmp_variable_value_t  *v;\n\n    v = &s->variables[index];\n\n    if (v->valid || v->not_found) {\n        if (!v->no_cacheable) {\n            return v;\n        }\n\n        v->valid = 0;\n        v->not_found = 0;\n    }\n\n    return ngx_rtmp_get_indexed_variable(s, index);\n}\n\n\nngx_rtmp_variable_value_t *\nngx_rtmp_get_variable(ngx_rtmp_session_t *s, ngx_str_t *name, ngx_uint_t key)\n{\n    size_t                      len;\n    ngx_uint_t                  i, n;\n    ngx_rtmp_variable_t        *v;\n    ngx_rtmp_variable_value_t  *vv;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_core_module);\n\n    v = ngx_hash_find(&cmcf->variables_hash, key, name->data, name->len);\n\n    if (v) {\n        if (v->flags & NGX_RTMP_VAR_INDEXED) {\n            return ngx_rtmp_get_flushed_variable(s, v->index);\n        }\n\n        if (ngx_rtmp_variable_depth == 0) {\n            ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                          \"cycle while evaluating variable \\\"%V\\\"\", name);\n            return NULL;\n        }\n\n        ngx_rtmp_variable_depth--;\n\n        vv = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_variable_value_t));\n\n        if (vv && v->get_handler(s, vv, v->data) == NGX_OK) {\n            ngx_rtmp_variable_depth++;\n            return vv;\n        }\n\n        ngx_rtmp_variable_depth++;\n        return NULL;\n    }\n\n    vv = ngx_palloc(s->connection->pool, sizeof(ngx_rtmp_variable_value_t));\n    if (vv == NULL) {\n        return NULL;\n    }\n\n    len = 0;\n\n    v = cmcf->prefix_variables.elts;\n    n = cmcf->prefix_variables.nelts;\n\n    for (i = 0; i < cmcf->prefix_variables.nelts; i++) {\n        if (name->len >= v[i].name.len && name->len > len\n            && ngx_strncmp(name->data, v[i].name.data, v[i].name.len) == 0)\n        {\n            len = v[i].name.len;\n            n = i;\n        }\n    }\n\n    if (n != cmcf->prefix_variables.nelts) {\n        if (v[n].get_handler(s, vv, (uintptr_t) name) == NGX_OK) {\n            return vv;\n        }\n\n        return NULL;\n    }\n\n    vv->not_found = 1;\n\n    return vv;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_request(ngx_rtmp_session_t *s, ngx_rtmp_variable_value_t *v,\n    uintptr_t data)\n{\n    ngx_str_t  *str;\n\n    str = (ngx_str_t *) ((char *) s + data);\n\n    if (str->data) {\n        v->len = str->len;\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = str->data;\n\n    } else {\n        v->not_found = 1;\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_arg(ngx_rtmp_session_t *s, u_char *name, size_t len, ngx_str_t *value)\n{\n    u_char  *p, *last;\n\n    if (s->args.len == 0) {\n        return NGX_DECLINED;\n    }\n\n    p = s->args.data;\n    last = p + s->args.len;\n\n    for ( /* void */ ; p < last; p++) {\n\n        /* we need '=' after name, so drop one char from last */\n\n        p = ngx_strlcasestrn(p, last - 1, name, len - 1);\n\n        if (p == NULL) {\n            return NGX_DECLINED;\n        }\n\n        if ((p == s->args.data || *(p - 1) == '&') && *(p + len) == '=') {\n\n            value->data = p + len + 1;\n\n            p = ngx_strlchr(p, last, '&');\n\n            if (p == NULL) {\n                p = s->args.data + s->args.len;\n            }\n\n            value->len = p - value->data;\n\n            return NGX_OK;\n        }\n    }\n\n    return NGX_DECLINED;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_argument(ngx_rtmp_session_t *s, ngx_rtmp_variable_value_t *v,\n    uintptr_t data)\n{\n    ngx_str_t *name = (ngx_str_t *) data;\n\n    u_char     *arg;\n    size_t      len;\n    ngx_str_t   value;\n\n    len = name->len - (sizeof(\"arg_\") - 1);\n    arg = name->data + sizeof(\"arg_\") - 1;\n\n    if (ngx_rtmp_arg(s, arg, len, &value) != NGX_OK) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = value.data;\n    v->len = value.len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}\n\n\n#if (NGX_HAVE_TCP_INFO)\n\nstatic ngx_int_t\nngx_rtmp_variable_tcpinfo(ngx_rtmp_session_t *s, ngx_rtmp_variable_value_t *v,\n    uintptr_t data)\n{\n    struct tcp_info  ti;\n    socklen_t        len;\n    uint32_t         value;\n\n    len = sizeof(struct tcp_info);\n    if (getsockopt(s->connection->fd, IPPROTO_TCP, TCP_INFO, &ti, &len) == -1) {\n        v->not_found = 1;\n        return NGX_OK;\n    }\n\n    v->data = ngx_pnalloc(s->connection->pool, NGX_INT32_LEN);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    switch (data) {\n    case 0:\n        value = ti.tcpi_rtt;\n        break;\n\n    case 1:\n        value = ti.tcpi_rttvar;\n        break;\n\n    case 2:\n        value = ti.tcpi_snd_cwnd;\n        break;\n\n    case 3:\n        value = ti.tcpi_rcv_space;\n        break;\n\n    /* suppress warning */\n    default:\n        value = 0;\n        break;\n    }\n\n    v->len = ngx_sprintf(v->data, \"%uD\", value) - v->data;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}\n\n#endif\n\n\nstatic ngx_int_t\nngx_rtmp_variable_host(ngx_rtmp_session_t *s, ngx_rtmp_variable_value_t *v,\n    uintptr_t data)\n{\n    v->len = s->host_end - s->host_start;\n    v->data = s->host_start;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_binary_remote_addr(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    struct sockaddr_in   *sin;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6  *sin6;\n#endif\n\n    switch (s->connection->sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        sin6 = (struct sockaddr_in6 *) s->connection->sockaddr;\n\n        v->len = sizeof(struct in6_addr);\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = sin6->sin6_addr.s6_addr;\n\n        break;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) s->connection->sockaddr;\n\n        v->len = sizeof(in_addr_t);\n        v->valid = 1;\n        v->no_cacheable = 0;\n        v->not_found = 0;\n        v->data = (u_char *) &sin->sin_addr;\n\n        break;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_remote_addr(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    v->len = s->connection->addr_text.len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = s->connection->addr_text.data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_remote_port(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    ngx_uint_t  port;\n\n    v->len = 0;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    v->data = ngx_pnalloc(s->connection->pool, sizeof(\"65535\") - 1);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    port = ngx_inet_get_port(s->connection->sockaddr);\n\n    if (port > 0 && port < 65536) {\n        v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_server_addr(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    ngx_str_t  str;\n    u_char     addr[NGX_SOCKADDR_STRLEN];\n\n    str.len = NGX_SOCKADDR_STRLEN;\n    str.data = addr;\n\n    if (ngx_connection_local_sockaddr(s->connection, &str, 0) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    str.data = ngx_pnalloc(s->connection->pool, str.len);\n    if (str.data == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(str.data, addr, str.len);\n\n    v->len = str.len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = str.data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_server_port(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    ngx_uint_t  port;\n\n    v->len = 0;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    if (ngx_connection_local_sockaddr(s->connection, NULL, 0) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    v->data = ngx_pnalloc(s->connection->pool, sizeof(\"65535\") - 1);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    port = ngx_inet_get_port(s->connection->local_sockaddr);\n\n    if (port > 0 && port < 65536) {\n        v->len = ngx_sprintf(v->data, \"%ui\", port) - v->data;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_rtmp_variable_set_args(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    s->args.len = v->len;\n    s->args.data = v->data;\n    s->valid_unparsed_uri = 0;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_is_args(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    if (s->args.len == 0) {\n        v->len = 0;\n        v->data = NULL;\n        return NGX_OK;\n    }\n\n    v->len = 1;\n    v->data = (u_char *) \"?\";\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_server_name(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    ngx_rtmp_core_srv_conf_t  *cscf;\n\n    cscf = ngx_rtmp_get_module_srv_conf(s, ngx_rtmp_core_module);\n\n    v->len = cscf->server_name.len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = cscf->server_name.data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_bytes_sent(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    u_char  *p;\n\n    p = ngx_pnalloc(s->connection->pool, NGX_OFF_T_LEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = ngx_sprintf(p, \"%O\", s->connection->sent) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_request_time(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    u_char          *p;\n    ngx_time_t      *tp;\n    ngx_msec_int_t   ms;\n\n    p = ngx_pnalloc(s->connection->pool, NGX_TIME_T_LEN + 4);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    tp = ngx_timeofday();\n\n    ms = (ngx_msec_int_t)\n             ((tp->sec - s->start_sec) * 1000 + (tp->msec - s->start_msec));\n    ms = ngx_max(ms, 0);\n\n    v->len = ngx_sprintf(p, \"%T.%03M\", (time_t) ms / 1000, ms % 1000) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_request_id(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    u_char  *id;\n\n#if (NGX_OPENSSL)\n    u_char   random_bytes[16];\n#endif\n\n    id = ngx_pnalloc(s->connection->pool, 32);\n    if (id == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    v->len = 32;\n    v->data = id;\n\n#if (NGX_OPENSSL)\n\n    if (RAND_bytes(random_bytes, 16) == 1) {\n        ngx_hex_dump(id, random_bytes, 16);\n        return NGX_OK;\n    }\n\n    ngx_ssl_error(NGX_LOG_ERR, s->connection->log, 0, \"RAND_bytes() failed\");\n\n#endif\n\n    ngx_sprintf(id, \"%08xD%08xD%08xD%08xD\",\n                (uint32_t) ngx_random(), (uint32_t) ngx_random(),\n                (uint32_t) ngx_random(), (uint32_t) ngx_random());\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_connection(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    u_char  *p;\n\n    p = ngx_pnalloc(s->connection->pool, NGX_ATOMIC_T_LEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = ngx_sprintf(p, \"%uA\", s->connection->number) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_nginx_version(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    v->len = sizeof(NGINX_VERSION) - 1;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = (u_char *) NGINX_VERSION;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_hostname(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    v->len = ngx_cycle->hostname.len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = ngx_cycle->hostname.data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_pid(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    u_char  *p;\n\n    p = ngx_pnalloc(s->connection->pool, NGX_INT64_LEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = ngx_sprintf(p, \"%P\", ngx_pid) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_rtmp_variable_msec(ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data)\n{\n    u_char      *p;\n    ngx_time_t  *tp;\n\n    p = ngx_pnalloc(s->connection->pool, NGX_TIME_T_LEN + 4);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    tp = ngx_timeofday();\n\n    v->len = ngx_sprintf(p, \"%T.%03M\", tp->sec, tp->msec) - p;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n    v->data = p;\n\n    return NGX_OK;\n}\n\n\nvoid *\nngx_rtmp_map_find(ngx_rtmp_session_t *s, ngx_rtmp_map_t *map, ngx_str_t *match)\n{\n    void        *value;\n    u_char      *low;\n    size_t       len;\n    ngx_uint_t   key;\n\n    len = match->len;\n\n    if (len) {\n        low = ngx_pnalloc(s->connection->pool, len);\n        if (low == NULL) {\n            return NULL;\n        }\n\n    } else {\n        low = NULL;\n    }\n\n    key = ngx_hash_strlow(low, match->data, len);\n\n    value = ngx_hash_find_combined(&map->hash, key, low, len);\n    if (value) {\n        return value;\n    }\n\n#if (NGX_PCRE)\n\n    if (len && map->nregex) {\n        ngx_int_t              n;\n        ngx_uint_t             i;\n        ngx_rtmp_map_regex_t  *reg;\n\n        reg = map->regex;\n\n        for (i = 0; i < map->nregex; i++) {\n\n            n = ngx_rtmp_regex_exec(s, reg[i].regex, match);\n\n            if (n == NGX_OK) {\n                return reg[i].value;\n            }\n\n            if (n == NGX_DECLINED) {\n                continue;\n            }\n\n            /* NGX_ERROR */\n\n            return NULL;\n        }\n    }\n\n#endif\n\n    return NULL;\n}\n\n\n#if (NGX_PCRE)\n\nstatic ngx_int_t\nngx_rtmp_variable_not_found(ngx_rtmp_session_t *s, ngx_rtmp_variable_value_t *v,\n    uintptr_t data)\n{\n    v->not_found = 1;\n    return NGX_OK;\n}\n\n\nngx_rtmp_regex_t *\nngx_rtmp_regex_compile(ngx_conf_t *cf, ngx_regex_compile_t *rc)\n{\n    u_char                     *p;\n    size_t                      size;\n    ngx_str_t                   name;\n    ngx_uint_t                  i, n;\n    ngx_rtmp_variable_t        *v;\n    ngx_rtmp_regex_t           *re;\n    ngx_rtmp_regex_variable_t  *rv;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    rc->pool = cf->pool;\n\n    if (ngx_regex_compile(rc) != NGX_OK) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"%V\", &rc->err);\n        return NULL;\n    }\n\n    re = ngx_pcalloc(cf->pool, sizeof(ngx_rtmp_regex_t));\n    if (re == NULL) {\n        return NULL;\n    }\n\n    re->regex = rc->regex;\n    re->ncaptures = rc->captures;\n    re->name = rc->pattern;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n    cmcf->ncaptures = ngx_max(cmcf->ncaptures, re->ncaptures);\n\n    n = (ngx_uint_t) rc->named_captures;\n\n    if (n == 0) {\n        return re;\n    }\n\n    rv = ngx_palloc(rc->pool, n * sizeof(ngx_rtmp_regex_variable_t));\n    if (rv == NULL) {\n        return NULL;\n    }\n\n    re->variables = rv;\n    re->nvariables = n;\n\n    size = rc->name_size;\n    p = rc->names;\n\n    for (i = 0; i < n; i++) {\n        rv[i].capture = 2 * ((p[0] << 8) + p[1]);\n\n        name.data = &p[2];\n        name.len = ngx_strlen(name.data);\n\n        v = ngx_rtmp_add_variable(cf, &name, NGX_RTMP_VAR_CHANGEABLE);\n        if (v == NULL) {\n            return NULL;\n        }\n\n        rv[i].index = ngx_rtmp_get_variable_index(cf, &name);\n        if (rv[i].index == NGX_ERROR) {\n            return NULL;\n        }\n\n        v->get_handler = ngx_rtmp_variable_not_found;\n\n        p += size;\n    }\n\n    return re;\n}\n\n\nngx_int_t\nngx_rtmp_regex_exec(ngx_rtmp_session_t *s, ngx_rtmp_regex_t *re, ngx_str_t *str)\n{\n    ngx_int_t                   rc, index;\n    ngx_uint_t                  i, n, len;\n    ngx_rtmp_variable_value_t  *vv;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_rtmp_get_module_main_conf(s, ngx_rtmp_core_module);\n\n    if (re->ncaptures) {\n        len = cmcf->ncaptures;\n\n        if (s->captures == NULL) {\n            s->captures = ngx_palloc(s->connection->pool, len * sizeof(int));\n            if (s->captures == NULL) {\n                return NGX_ERROR;\n            }\n        }\n\n    } else {\n        len = 0;\n    }\n\n    rc = ngx_regex_exec(re->regex, str, s->captures, len);\n\n    if (rc == NGX_REGEX_NO_MATCHED) {\n        return NGX_DECLINED;\n    }\n\n    if (rc < 0) {\n        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,\n                      ngx_regex_exec_n \" failed: %i on \\\"%V\\\" using \\\"%V\\\"\",\n                      rc, str, &re->name);\n        return NGX_ERROR;\n    }\n\n    for (i = 0; i < re->nvariables; i++) {\n\n        n = re->variables[i].capture;\n        index = re->variables[i].index;\n        vv = &s->variables[index];\n\n        vv->len = s->captures[n + 1] - s->captures[n];\n        vv->valid = 1;\n        vv->no_cacheable = 0;\n        vv->not_found = 0;\n        vv->data = &str->data[s->captures[n]];\n\n#if (NGX_DEBUG)\n        {\n        ngx_rtmp_variable_t  *v;\n\n        v = cmcf->variables.elts;\n\n        ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s->connection->log, 0,\n                       \"http regex set $%V to \\\"%v\\\"\", &v[index].name, vv);\n        }\n#endif\n    }\n\n    s->ncaptures = rc * 2;\n    s->captures_data = str->data;\n\n    return NGX_OK;\n}\n\n#endif\n\n\nngx_int_t\nngx_rtmp_variables_add_core_vars(ngx_conf_t *cf)\n{\n    ngx_rtmp_variable_t        *cv, *v;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    cmcf->variables_keys = ngx_pcalloc(cf->temp_pool,\n                                       sizeof(ngx_hash_keys_arrays_t));\n    if (cmcf->variables_keys == NULL) {\n        return NGX_ERROR;\n    }\n\n    cmcf->variables_keys->pool = cf->pool;\n    cmcf->variables_keys->temp_pool = cf->pool;\n\n    if (ngx_hash_keys_array_init(cmcf->variables_keys, NGX_HASH_SMALL)\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (ngx_array_init(&cmcf->prefix_variables, cf->pool, 8,\n                       sizeof(ngx_rtmp_variable_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    for (cv = ngx_rtmp_core_variables; cv->name.len; cv++) {\n        v = ngx_rtmp_add_variable(cf, &cv->name, cv->flags);\n        if (v == NULL) {\n            return NGX_ERROR;\n        }\n\n        *v = *cv;\n    }\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_rtmp_variables_init_vars(ngx_conf_t *cf)\n{\n    size_t                      len;\n    ngx_uint_t                  i, n;\n    ngx_hash_key_t             *key;\n    ngx_hash_init_t             hash;\n    ngx_rtmp_variable_t        *v, *av, *pv;\n    ngx_rtmp_core_main_conf_t  *cmcf;\n\n    /* set the handlers for the indexed http variables */\n\n    cmcf = ngx_rtmp_conf_get_module_main_conf(cf, ngx_rtmp_core_module);\n\n    v = cmcf->variables.elts;\n    pv = cmcf->prefix_variables.elts;\n    key = cmcf->variables_keys->keys.elts;\n\n    for (i = 0; i < cmcf->variables.nelts; i++) {\n\n        for (n = 0; n < cmcf->variables_keys->keys.nelts; n++) {\n\n            av = key[n].value;\n\n            if (v[i].name.len == key[n].key.len\n                && ngx_strncmp(v[i].name.data, key[n].key.data, v[i].name.len)\n                   == 0)\n            {\n                v[i].get_handler = av->get_handler;\n                v[i].data = av->data;\n\n                av->flags |= NGX_RTMP_VAR_INDEXED;\n                v[i].flags = av->flags;\n\n                av->index = i;\n\n                if (av->get_handler == NULL\n                    || (av->flags & NGX_RTMP_VAR_WEAK))\n                {\n                    break;\n                }\n\n                goto next;\n            }\n        }\n\n        len = 0;\n        av = NULL;\n\n        for (n = 0; n < cmcf->prefix_variables.nelts; n++) {\n            if (v[i].name.len >= pv[n].name.len && v[i].name.len > len\n                && ngx_strncmp(v[i].name.data, pv[n].name.data, pv[n].name.len)\n                   == 0)\n            {\n                av = &pv[n];\n                len = pv[n].name.len;\n            }\n        }\n\n        if (av) {\n            v[i].get_handler = av->get_handler;\n            v[i].data = (uintptr_t) &v[i].name;\n            v[i].flags = av->flags;\n\n            goto next;\n        }\n\n        if (v[i].get_handler == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                          \"unknown \\\"%V\\\" variable\", &v[i].name);\n\n            return NGX_ERROR;\n        }\n\n    next:\n        continue;\n    }\n\n\n    for (n = 0; n < cmcf->variables_keys->keys.nelts; n++) {\n        av = key[n].value;\n\n        if (av->flags & NGX_RTMP_VAR_NOHASH) {\n            key[n].key.data = NULL;\n        }\n    }\n\n\n    hash.hash = &cmcf->variables_hash;\n    hash.key = ngx_hash_key;\n    hash.max_size = cmcf->variables_hash_max_size;\n    hash.bucket_size = cmcf->variables_hash_bucket_size;\n    hash.name = \"rtmp_variables_hash\";\n    hash.pool = cf->pool;\n    hash.temp_pool = NULL;\n\n    if (ngx_hash_init(&hash, cmcf->variables_keys->keys.elts,\n                      cmcf->variables_keys->keys.nelts)\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    cmcf->variables_keys = NULL;\n\n    return NGX_OK;\n}\n\n"
        },
        {
          "name": "ngx_rtmp_variables.h",
          "type": "blob",
          "size": 2.9189453125,
          "content": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n * Copyright (C) Winshining\n */\n\n\n#ifndef _NGX_RTMP_VARIABLES_H_INCLUDED_\n#define _NGX_RTMP_VARIABLES_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\ntypedef ngx_variable_value_t  ngx_rtmp_variable_value_t;\n\n#define ngx_rtmp_variable(v)     { sizeof(v) - 1, 1, 0, 0, 0, (u_char *) v }\n\ntypedef struct ngx_rtmp_variable_s  ngx_rtmp_variable_t;\n\ntypedef void (*ngx_rtmp_set_variable_pt) (ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\ntypedef ngx_int_t (*ngx_rtmp_get_variable_pt) (ngx_rtmp_session_t *s,\n    ngx_rtmp_variable_value_t *v, uintptr_t data);\n\n\n#define NGX_RTMP_VAR_CHANGEABLE   1\n#define NGX_RTMP_VAR_NOCACHEABLE  2\n#define NGX_RTMP_VAR_INDEXED      4\n#define NGX_RTMP_VAR_NOHASH       8\n#define NGX_RTMP_VAR_WEAK         16\n#define NGX_RTMP_VAR_PREFIX       32\n\n\nstruct ngx_rtmp_variable_s {\n    ngx_str_t                     name;   /* must be first to build the hash */\n    ngx_rtmp_set_variable_pt      set_handler;\n    ngx_rtmp_get_variable_pt      get_handler;\n    uintptr_t                     data;\n    ngx_uint_t                    flags;\n    ngx_uint_t                    index;\n};\n\n\nngx_rtmp_variable_t *ngx_rtmp_add_variable(ngx_conf_t *cf, ngx_str_t *name,\n    ngx_uint_t flags);\nngx_int_t ngx_rtmp_get_variable_index(ngx_conf_t *cf, ngx_str_t *name);\nngx_rtmp_variable_value_t *ngx_rtmp_get_indexed_variable(ngx_rtmp_session_t *s,\n    ngx_uint_t index);\nngx_rtmp_variable_value_t *ngx_rtmp_get_flushed_variable(ngx_rtmp_session_t *s,\n    ngx_uint_t index);\n\nngx_rtmp_variable_value_t *ngx_rtmp_get_variable(ngx_rtmp_session_t *s,\n    ngx_str_t *name, ngx_uint_t key);\n\n\n#if (NGX_PCRE)\n\ntypedef struct {\n    ngx_uint_t                    capture;\n    ngx_int_t                     index;\n} ngx_rtmp_regex_variable_t;\n\n\ntypedef struct {\n    ngx_regex_t                  *regex;\n    ngx_uint_t                    ncaptures;\n    ngx_rtmp_regex_variable_t    *variables;\n    ngx_uint_t                    nvariables;\n    ngx_str_t                     name;\n} ngx_rtmp_regex_t;\n\n\ntypedef struct {\n    ngx_rtmp_regex_t             *regex;\n    void                         *value;\n} ngx_rtmp_map_regex_t;\n\n\nngx_rtmp_regex_t *ngx_rtmp_regex_compile(ngx_conf_t *cf,\n    ngx_regex_compile_t *rc);\nngx_int_t ngx_rtmp_regex_exec(ngx_rtmp_session_t *s, ngx_rtmp_regex_t *re,\n    ngx_str_t *str);\n\n#endif\n\n\ntypedef struct {\n    ngx_hash_combined_t           hash;\n#if (NGX_PCRE)\n    ngx_rtmp_map_regex_t         *regex;\n    ngx_uint_t                    nregex;\n#endif\n} ngx_rtmp_map_t;\n\n\nvoid *ngx_rtmp_map_find(ngx_rtmp_session_t *s, ngx_rtmp_map_t *map,\n    ngx_str_t *match);\n\n\nngx_int_t ngx_rtmp_variables_add_core_vars(ngx_conf_t *cf);\nngx_int_t ngx_rtmp_variables_init_vars(ngx_conf_t *cf);\n\n\nextern ngx_rtmp_variable_value_t  ngx_rtmp_variable_null_value;\nextern ngx_rtmp_variable_value_t  ngx_rtmp_variable_true_value;\n\n\n#endif /* _NGX_RTMP_VARIABLES_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_rtmp_version.h",
          "type": "blob",
          "size": 0.26171875,
          "content": "\n/*\n * Copyright (C) Roman Arutyunyan\n * Copyright (C) Winshining\n */\n\n\n#ifndef _NGX_RTMP_VERSION_H_INCLUDED_\n#define _NGX_RTMP_VERSION_H_INCLUDED_\n\n\n#define nginx_rtmp_version  1002012\n#define NGINX_RTMP_VERSION  \"1.2.12\"\n\n\n#endif /* _NGX_RTMP_VERSION_H_INCLUDED_ */\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "stat.xsl",
          "type": "blob",
          "size": 17.9287109375,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n\n\n<!--\n   Copyright (C) Roman Arutyunyan\n   Copyright (C) Winshining\n-->\n\n\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n\n<xsl:template match=\"/\">\n    <html>\n        <head>\n            <title>HTTP-FLV statistics</title>\n        </head>\n        <body>\n            <xsl:apply-templates select=\"http-flv\"/>\n            <hr/>\n            Generated by <a href='https://github.com/winshining/nginx-http-flv-module'>\n            nginx-http-flv-module</a>&#160;<xsl:value-of select=\"/http-flv/nginx_http_flv_version\"/>,\n            <a href=\"http://nginx.org\">nginx</a>&#160;<xsl:value-of select=\"/http-flv/nginx_version\"/>,\n            pid <xsl:value-of select=\"/http-flv/pid\"/>,\n            built <xsl:value-of select=\"/http-flv/built\"/>&#160;<xsl:value-of select=\"/http-flv/compiler\"/>\n        </body>\n    </html>\n</xsl:template>\n\n<xsl:template match=\"http-flv\">\n    <table cellspacing=\"1\" cellpadding=\"5\">\n        <tr bgcolor=\"#999999\">\n            <th>HTTP-FLV</th>\n            <th>#clients</th>\n            <th colspan=\"2\">Recorders</th>\n            <th colspan=\"2\">Server</th>\n            <th colspan=\"4\">Video</th>\n            <th colspan=\"4\">Audio</th>\n            <th>In bytes</th>\n            <th>Out bytes</th>\n            <th>In bits/s</th>\n            <th>Out bits/s</th>\n            <th>State</th>\n            <th>Time</th>\n        </tr>\n        <tr>\n            <td colspan=\"2\">Accepted: <xsl:value-of select=\"naccepted\"/></td>\n            <th bgcolor=\"#999999\">lists</th>\n            <th bgcolor=\"#999999\">#count</th>\n            <th bgcolor=\"#999999\">port</th>\n            <th bgcolor=\"#999999\">index</th>\n            <th bgcolor=\"#999999\">codec</th>\n            <th bgcolor=\"#999999\">bits/s</th>\n            <th bgcolor=\"#999999\">size</th>\n            <th bgcolor=\"#999999\">fps</th>\n            <th bgcolor=\"#999999\">codec</th>\n            <th bgcolor=\"#999999\">bits/s</th>\n            <th bgcolor=\"#999999\">freq</th>\n            <th bgcolor=\"#999999\">chan</th>\n            <td>\n                <xsl:call-template name=\"showsize\">\n                    <xsl:with-param name=\"size\" select=\"bytes_in\"/>\n                </xsl:call-template>\n            </td>\n            <td>\n                <xsl:call-template name=\"showsize\">\n                    <xsl:with-param name=\"size\" select=\"bytes_out\"/>\n                </xsl:call-template>\n            </td>\n            <td>\n                <xsl:call-template name=\"showsize\">\n                    <xsl:with-param name=\"size\" select=\"bw_in\"/>\n                    <xsl:with-param name=\"bits\" select=\"1\"/>\n                    <xsl:with-param name=\"persec\" select=\"1\"/>\n                </xsl:call-template>\n            </td>\n            <td>\n                <xsl:call-template name=\"showsize\">\n                    <xsl:with-param name=\"size\" select=\"bw_out\"/>\n                    <xsl:with-param name=\"bits\" select=\"1\"/>\n                    <xsl:with-param name=\"persec\" select=\"1\"/>\n                </xsl:call-template>\n            </td>\n            <td/>\n            <td>\n                <xsl:call-template name=\"showtime\">\n                    <xsl:with-param name=\"time\" select=\"/http-flv/uptime * 1000\"/>\n                </xsl:call-template>\n            </td>\n        </tr>\n        <xsl:apply-templates select=\"server\"/>\n    </table>\n</xsl:template>\n\n<xsl:template match=\"server\">\n    <xsl:apply-templates select=\"application\"/>\n</xsl:template>\n\n<xsl:template match=\"application\">\n    <tr bgcolor=\"#999999\">\n        <td>\n            <b><xsl:value-of select=\"name\"/></b>\n        </td>\n    </tr>\n    <xsl:apply-templates select=\"live\"/>\n    <xsl:apply-templates select=\"play\"/>\n    <xsl:apply-templates select=\"recorders\"/>\n</xsl:template>\n\n<xsl:template match=\"live\">\n    <tr bgcolor=\"#aaaaaa\">\n        <td>\n            <i>live streams</i>\n        </td>\n        <td align=\"middle\">\n            <xsl:value-of select=\"nclients\"/>\n        </td>\n    </tr>\n    <xsl:apply-templates select=\"stream\"/>\n</xsl:template>\n\n<xsl:template match=\"play\">\n    <tr bgcolor=\"#aaaaaa\">\n        <td>\n            <i>vod streams</i>\n        </td>\n        <td align=\"middle\">\n            <xsl:value-of select=\"nclients\"/>\n        </td>\n    </tr>\n    <xsl:apply-templates select=\"stream\"/>\n</xsl:template>\n\n<xsl:template match=\"recorders\">\n    <tr bgcolor=\"#aaaaaa\">\n        <td colspan=\"2\">Recorders</td>\n        <td>\n            <a href=\"\">\n                <xsl:attribute name=\"onclick\">\n                    var d=document.getElementById('<xsl:value-of select=\"../../port\"/>-<xsl:value-of select=\"../../server_index\"/>-<xsl:value-of select=\"../name\"/>-recorders');\n                    d.style.display=d.style.display=='none'?'':'none';\n                    return false;\n                </xsl:attribute>\n                <i>config</i>\n            </a>\n        </td>\n        <td align=\"middle\">\n            <xsl:value-of select=\"count\"/>\n        </td>\n    </tr>\n    <tr style=\"display:none\">\n        <xsl:attribute name=\"id\"><xsl:value-of select=\"../../port\"/>-<xsl:value-of select=\"../../server_index\"/>-<xsl:value-of select=\"../name\"/>-recorders</xsl:attribute>\n        <td colspan=\"16\">\n            <table cellspacing=\"1\" cellpadding=\"5\">\n                <tr>\n                    <th>Id</th>\n                    <th>Path</th>\n                    <th>Suffix</th>\n                    <th>Flags</th>\n                    <th>Max Size</th>\n                    <th>Max Frames</th>\n                    <th>Interval</th>\n                    <th>Unique</th>\n                    <th>Append</th>\n                    <th>Lock File</th>\n                    <th>Notify</th>\n                </tr>\n                <xsl:apply-templates select=\"recorder\"/>\n            </table>\n        </td>\n    </tr>\n</xsl:template>\n\n<xsl:template match=\"recorder\">\n    <tr bgcolor=\"#cccccc\">\n        <td>\n            <xsl:value-of select=\"id\"/>\n            <xsl:if test=\"string-length(id) = 0\">\n                [DEFAULT]\n            </xsl:if>\n        </td>\n        <td><xsl:value-of select=\"path\"/></td>\n        <td><xsl:value-of select=\"suffix\"/></td>\n        <td>\n            <xsl:if test=\"flags/video\">video<br/></xsl:if>\n            <xsl:if test=\"flags/audio\">audio<br/></xsl:if>\n            <xsl:if test=\"flags/manual\">manual</xsl:if>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n               <xsl:with-param name=\"size\" select=\"max_size\"/>\n            </xsl:call-template>\n        </td>\n        <td><xsl:value-of select=\"max_frames\"/></td>\n        <td>\n            <xsl:call-template name=\"showinterval\">\n               <xsl:with-param name=\"interval\" select=\"interval\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"binarystate\">\n                <xsl:with-param name=\"value\" select=\"unique\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"binarystate\">\n                <xsl:with-param name=\"value\" select=\"append\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"binarystate\">\n                <xsl:with-param name=\"value\" select=\"lock_file\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"binarystate\">\n                <xsl:with-param name=\"value\" select=\"notify\"/>\n            </xsl:call-template>\n        </td>\n    </tr>\n</xsl:template>\n\n<xsl:template name=\"binarystate\">\n    <xsl:param name=\"value\"/>\n    <xsl:choose>\n        <xsl:when test=\"$value\">on</xsl:when>\n        <xsl:otherwise>off</xsl:otherwise>\n    </xsl:choose>\n</xsl:template>\n\n<xsl:template match=\"stream\">\n    <tr valign=\"top\">\n        <xsl:attribute name=\"bgcolor\">\n            <xsl:choose>\n                <xsl:when test=\"active\">#cccccc</xsl:when>\n                <xsl:otherwise>#dddddd</xsl:otherwise>\n            </xsl:choose>\n        </xsl:attribute>\n        <td>\n            <a href=\"\">\n                <xsl:attribute name=\"onclick\">\n                    var d=document.getElementById('<xsl:value-of select=\"../../../port\"/>-<xsl:value-of select=\"../../../server_index\"/>-<xsl:value-of select=\"../../name\"/>-<xsl:value-of select=\"name\"/>');\n                    d.style.display=d.style.display=='none'?'':'none';\n                    return false\n                </xsl:attribute>\n                <xsl:value-of select=\"name\"/>\n                <xsl:if test=\"string-length(name) = 0\">\n                    [EMPTY]\n                </xsl:if>\n            </a>\n        </td>\n        <td align=\"middle\"> <xsl:value-of select=\"nclients\"/> </td>\n        <td align=\"middle\"> - </td>\n        <td align=\"middle\"> - </td>\n        <td align=\"middle\"> <xsl:value-of select=\"../../../port\"/> </td>\n        <td align=\"middle\"> <xsl:value-of select=\"../../../server_index\"/> </td>\n        <td>\n            <xsl:value-of select=\"meta/video/codec\"/>&#160;<xsl:value-of select=\"meta/video/profile\"/>&#160;<xsl:value-of select=\"meta/video/level\"/>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n                <xsl:with-param name=\"size\" select=\"bw_video\"/>\n                <xsl:with-param name=\"bits\" select=\"1\"/>\n                <xsl:with-param name=\"persec\" select=\"1\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:apply-templates select=\"meta/video/width\"/>\n        </td>\n        <td>\n            <xsl:value-of select=\"meta/video/frame_rate\"/>\n        </td>\n        <td>\n            <xsl:value-of select=\"meta/audio/codec\"/>&#160;<xsl:value-of select=\"meta/audio/profile\"/>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n                <xsl:with-param name=\"size\" select=\"bw_audio\"/>\n                <xsl:with-param name=\"bits\" select=\"1\"/>\n                <xsl:with-param name=\"persec\" select=\"1\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:apply-templates select=\"meta/audio/sample_rate\"/>\n        </td>\n        <td>\n            <xsl:value-of select=\"meta/audio/channels\"/>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n               <xsl:with-param name=\"size\" select=\"bytes_in\"/>\n           </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n                <xsl:with-param name=\"size\" select=\"bytes_out\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n                <xsl:with-param name=\"size\" select=\"bw_in\"/>\n                <xsl:with-param name=\"bits\" select=\"1\"/>\n                <xsl:with-param name=\"persec\" select=\"1\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n                <xsl:with-param name=\"size\" select=\"bw_out\"/>\n                <xsl:with-param name=\"bits\" select=\"1\"/>\n                <xsl:with-param name=\"persec\" select=\"1\"/>\n            </xsl:call-template>\n        </td>\n        <td><xsl:call-template name=\"streamstate\"/></td>\n        <td>\n            <xsl:call-template name=\"showtime\">\n               <xsl:with-param name=\"time\" select=\"time\"/>\n            </xsl:call-template>\n        </td>\n    </tr>\n    <tr style=\"display:none\">\n        <xsl:attribute name=\"id\">\n            <xsl:value-of select=\"../../../port\"/>-<xsl:value-of select=\"../../../server_index\"/>-<xsl:value-of select=\"../../name\"/>-<xsl:value-of select=\"name\"/>\n        </xsl:attribute>\n        <td colspan=\"16\" ngcolor=\"#eeeeee\">\n            <table cellspacing=\"1\" cellpadding=\"5\">\n                <tr>\n                    <th>Id</th>\n                    <th>State</th>\n                    <th>Address</th>\n                    <th>Flash version</th>\n                    <th>Page URL</th>\n                    <th>SWF URL</th>\n                    <th>Dropped</th>\n                    <th>Timestamp</th>\n                    <th>A-V</th>\n                    <th>Time</th>\n                </tr>\n                <xsl:apply-templates select=\"client\"/>\n            </table>\n            <xsl:apply-templates select=\"records\"/>\n        </td>\n    </tr>\n</xsl:template>\n\n<xsl:template match=\"records\">\n    <table cellspacing=\"1\" cellpadding=\"5\">\n        <tr>\n            <th>Recorder</th>\n            <th>State</th>\n            <th>Epoch</th>\n            <th>Time Shift</th>\n            <th>File Name</th>\n            <th>Time</th>\n            <th>Size</th>\n            <th>Frames</th>\n        </tr>\n        <xsl:apply-templates select=\"record\"/>\n    </table>\n</xsl:template>\n\n<xsl:template match=\"record\">\n    <tr>\n        <xsl:attribute name=\"bgcolor\">\n            <xsl:choose>\n                <xsl:when test=\"recording\">#cccccc</xsl:when>\n                <xsl:otherwise>#eeeeee</xsl:otherwise>\n            </xsl:choose>\n        </xsl:attribute>\n        <td>\n            <xsl:value-of select=\"recorder\"/>\n            <xsl:if test=\"string-length(recorder) = 0\">\n                [DEFAULT]\n            </xsl:if>\n        </td>\n        <td>\n            <xsl:choose>\n                <xsl:when test=\"recording\">recording</xsl:when>\n                <xsl:otherwise>idle</xsl:otherwise>\n            </xsl:choose>\n        </td>\n        <td><xsl:value-of select=\"epoch\"/></td>\n        <td><xsl:value-of select=\"time_shift\"/></td>\n        <td><xsl:value-of select=\"file\"/></td>\n        <td>\n            <xsl:call-template name=\"showtime\">\n               <xsl:with-param name=\"time\" select=\"time * 1000\"/>\n            </xsl:call-template>\n        </td>\n        <td>\n            <xsl:call-template name=\"showsize\">\n               <xsl:with-param name=\"size\" select=\"size\"/>\n            </xsl:call-template>\n        </td>\n        <td><xsl:value-of select=\"nframes\"/></td>\n    </tr>\n</xsl:template>\n\n<xsl:template name=\"showtime\">\n    <xsl:param name=\"time\"/>\n\n    <xsl:if test=\"$time &gt; 0\">\n        <xsl:variable name=\"sec\">\n            <xsl:value-of select=\"floor($time div 1000)\"/>\n        </xsl:variable>\n\n        <xsl:if test=\"$sec &gt;= 86400\">\n            <xsl:value-of select=\"floor($sec div 86400)\"/>d\n        </xsl:if>\n\n        <xsl:if test=\"$sec &gt;= 3600\">\n            <xsl:value-of select=\"(floor($sec div 3600)) mod 24\"/>h\n        </xsl:if>\n\n        <xsl:if test=\"$sec &gt;= 60\">\n            <xsl:value-of select=\"(floor($sec div 60)) mod 60\"/>m\n        </xsl:if>\n\n        <xsl:value-of select=\"$sec mod 60\"/>s\n    </xsl:if>\n</xsl:template>\n\n<xsl:template name=\"showsize\">\n    <xsl:param name=\"size\"/>\n    <xsl:param name=\"bits\" select=\"0\" />\n    <xsl:param name=\"persec\" select=\"0\" />\n    <xsl:variable name=\"sizen\">\n        <xsl:value-of select=\"floor($size div 1024)\"/>\n    </xsl:variable>\n    <xsl:choose>\n        <xsl:when test=\"$sizen &gt;= 1073741824\">\n            <xsl:value-of select=\"format-number($sizen div 1073741824,'#.###')\"/> T</xsl:when>\n\n        <xsl:when test=\"$sizen &gt;= 1048576\">\n            <xsl:value-of select=\"format-number($sizen div 1048576,'#.###')\"/> G</xsl:when>\n\n        <xsl:when test=\"$sizen &gt;= 1024\">\n            <xsl:value-of select=\"format-number($sizen div 1024,'#.##')\"/> M</xsl:when>\n        <xsl:when test=\"$sizen &gt;= 0\">\n            <xsl:value-of select=\"$sizen\"/> K</xsl:when>\n    </xsl:choose>\n    <xsl:if test=\"string-length($size) &gt; 0\">\n        <xsl:choose>\n            <xsl:when test=\"$bits = 1\">b</xsl:when>\n            <xsl:otherwise>B</xsl:otherwise>\n        </xsl:choose>\n        <xsl:if test=\"$persec = 1\">/s</xsl:if>\n    </xsl:if>\n</xsl:template>\n\n<xsl:template name=\"showinterval\">\n    <xsl:param name=\"interval\"/>\n\n    <xsl:if test=\"$interval &gt; 0\">\n        <xsl:variable name=\"sec\">\n            <xsl:value-of select=\"floor($interval div 1000)\"/>\n        </xsl:variable>\n\n        <xsl:if test=\"$sec &gt;= 86400\">\n            <xsl:value-of select=\"floor($sec div 86400)\"/>d\n        </xsl:if>\n\n        <xsl:if test=\"$sec &gt;= 3600\">\n            <xsl:value-of select=\"(floor($sec div 3600)) mod 24\"/>h\n        </xsl:if>\n\n        <xsl:if test=\"$sec &gt;= 60\">\n            <xsl:value-of select=\"(floor($sec div 60)) mod 60\"/>m\n        </xsl:if>\n\n        <xsl:if test=\"$sec &lt; 60\">\n            <xsl:value-of select=\"$sec mod 60\"/>s\n        </xsl:if>\n    </xsl:if>\n\n    <xsl:if test=\"$interval = -1\">Unset</xsl:if>\n</xsl:template>\n\n<xsl:template name=\"streamstate\">\n    <xsl:choose>\n        <xsl:when test=\"active\">active</xsl:when>\n        <xsl:otherwise>idle</xsl:otherwise>\n    </xsl:choose>\n</xsl:template>\n\n\n<xsl:template name=\"clientstate\">\n    <xsl:choose>\n        <xsl:when test=\"publishing\">publishing</xsl:when>\n        <xsl:otherwise>playing</xsl:otherwise>\n    </xsl:choose>\n</xsl:template>\n\n\n<xsl:template match=\"client\">\n    <tr>\n        <xsl:attribute name=\"bgcolor\">\n            <xsl:choose>\n                <xsl:when test=\"publishing\">#cccccc</xsl:when>\n                <xsl:otherwise>#eeeeee</xsl:otherwise>\n            </xsl:choose>\n        </xsl:attribute>\n        <td><xsl:value-of select=\"id\"/></td>\n        <td><xsl:call-template name=\"clientstate\"/></td>\n        <td>\n            <a target=\"_blank\">\n                <xsl:attribute name=\"href\">\n                    http://apps.db.ripe.net/search/query.html&#63;searchtext=<xsl:value-of select=\"address\"/>\n                </xsl:attribute>\n                <xsl:attribute name=\"title\">whois</xsl:attribute>\n                <xsl:value-of select=\"address\"/>\n            </a>\n        </td>\n        <td><xsl:value-of select=\"flashver\"/></td>\n        <td>\n            <a target=\"_blank\">\n                <xsl:attribute name=\"href\">\n                    <xsl:value-of select=\"pageurl\"/>\n                </xsl:attribute>\n                <xsl:value-of select=\"pageurl\"/>\n            </a>\n        </td>\n        <td><xsl:value-of select=\"swfurl\"/></td>\n        <td><xsl:value-of select=\"dropped\"/></td>\n        <td><xsl:value-of select=\"timestamp\"/></td>\n        <td><xsl:value-of select=\"avsync\"/></td>\n        <td>\n            <xsl:call-template name=\"showtime\">\n               <xsl:with-param name=\"time\" select=\"time\"/>\n            </xsl:call-template>\n        </td>\n    </tr>\n</xsl:template>\n\n<xsl:template match=\"publishing\">\n    publishing\n</xsl:template>\n\n<xsl:template match=\"active\">\n    active\n</xsl:template>\n\n<xsl:template match=\"width\">\n    <xsl:value-of select=\".\"/>x<xsl:value-of select=\"../height\"/>\n</xsl:template>\n\n</xsl:stylesheet>\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}