{
  "metadata": {
    "timestamp": 1736709754593,
    "page": 179,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hnes/libaco",
      "stars": 3537,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.6572265625,
          "content": "dist: trusty\nsudo: required\n\nnotifications:\n  email:\n    - 00hnes@gmail.com\n\nlanguage: c\n\nscript:\n    - echo $TRAVIS_EVENT_TYPE\n    - echo $TRAVIS_OS_NAME\n    - echo $CC\n    - cc --version\n    - if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] ; then brew update; brew install grep;export PATH=\"/usr/local/opt/grep/libexec/gnubin:$PATH\"; fi\n    - if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] ; then brew install gnu-sed;export PATH=\"/usr/local/opt/gnu-sed/libexec/gnubin:$PATH\"; fi\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then sudo apt-get install -qq -y libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl make build-essential valgrind gcc-multilib g++-multilib libc6-dbg libc6-dbg:i386 ; fi\n    - date\n    - grep -V\n    - sed --version\n    - export EXTRA_CFLAGS=\"\"\n    - echo \"\"\n    - bash test.sh version_check=1.2.4\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - mkdir output ; bash make.sh -o no-valgrind ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-valgrind -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - export EXTRA_CFLAGS=\"--std=c99\"\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - mkdir output ; bash make.sh -o no-valgrind ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-valgrind -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\" ; date\n\nmatrix:\n  include:\n    - os: linux\n      compiler: gcc-4.9\n      addons:\n        apt:\n          sources:\n            - ubuntu-toolchain-r-test\n          packages:\n            - gcc-4.9\n    - os: linux\n      compiler: clang-3.5\n      addons:\n        apt:\n          sources:\n            - ubuntu-toolchain-r-test\n            - llvm-toolchain-trusty-3.5\n          packages:\n            - clang-3.5\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 54.744140625,
          "content": "[![Logo of libaco](https://github.com/libaco/logo/blob/main/web/libaco_logo_blue.svg)](https://libaco.org)\n\nlibaco - A blazing fast and lightweight C asymmetric coroutine library.\n\nThe code name of this project is Arkenstone 💎\n\nAsymmetric COroutine & Arkenstone is the reason why it's been named `aco`.\n\nCurrently supports Sys V ABI of Intel386 and x86-64.\n\nHere is a brief summary of this project:\n\n- Along with the implementation of a production-ready C coroutine library, here is a detailed documentation about how to implement a *fastest* and *correct* coroutine library and also with a strict [mathematical proof](#proof-of-correctness);\n- It has no more than 700 LOC but has the full functionality which you may want from a coroutine library;\n- The [benchmark](#benchmark) part shows that a context switch between coroutines only takes about *10 ns* (in the case of standalone stack) on the AWS c5d.large machine;\n- User could choose to create a new coroutine with a *standalone stack* or with a *shared stack* (could be shared with others);\n- It is extremely memory efficient: *10,000,000* coroutines simultaneously to run cost only *2.8 GB* physical memory (run with tcmalloc, each coroutine has a *120B* copy-stack size configuration).\n\nThe phrase \"*fastest*\" in above means the fastest context switching implementation which complies to the Sys V ABI of Intel386 or AMD64.\n\n[![Build Status Travis](https://img.shields.io/travis/hnes/libaco.svg?style=flat-square&&branch=master)](https://travis-ci.org/hnes/libaco)\n[![Releases](https://img.shields.io/github/release/hnes/libaco/all.svg?style=flat-square)](https://github.com/hnes/libaco/releases)\n[![LICENSE](https://img.shields.io/github/license/hnes/libaco.svg?style=flat-square)](https://github.com/hnes/libaco/blob/master/LICENSE)\n[![中文文档](https://img.shields.io/badge/doc-en%20+%20中文-blue.svg?style=flat-square)](https://github.com/hnes/libaco/blob/master/README_zh.md)\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=libaco+-+A+blazing+fast+and+lightweight+C+asymmetric+coroutine+library&url=https://github.com/hnes/libaco&via=00hnes)\n\nIssues and PRs are welcome 🎉🎉🎉\n\nNote: Please use [releases][github-release] instead of the `master` to build the final binary.\n\nBesides this readme, you could also visit the documentation from [https://libaco.org/docs](https://libaco.org/docs). Please follow this readme if there are any differences because the documentation on the website may be lagging behind from this readme.\n\n[github-release]: https://github.com/hnes/libaco/releases\n\n# Table of Contents\n\n   * [Status](#status)\n   * [Synopsis](#synopsis)\n   * [Description](#description)\n   * [Build and Test](#build-and-test)\n      * [CFLAGS](#cflags)\n      * [Build](#build)\n      * [Test](#test)\n   * [Tutorials](#tutorials)\n   * [API](#api)\n      * [aco_thread_init](#aco_thread_init)\n      * [aco_share_stack_new](#aco_share_stack_new)\n      * [aco_share_stack_new2](#aco_share_stack_new2)\n      * [aco_share_stack_destroy](#aco_share_stack_destroy)\n      * [aco_create](#aco_create)\n      * [aco_resume](#aco_resume)\n      * [aco_yield](#aco_yield)\n      * [aco_get_co](#aco_get_co)\n      * [aco_get_arg](#aco_get_arg)\n      * [aco_exit](#aco_exit)\n      * [aco_destroy](#aco_destroy)\n      * [MACROS](#macros)\n   * [Benchmark](#benchmark)\n   * [Proof of Correctness](#proof-of-correctness)\n      * [Running Model](#running-model)\n      * [Mathematical Induction](#mathematical-induction)\n      * [Miscellaneous](#miscellaneous)\n         * [Red Zone](#red-zone)\n         * [Stack Pointer](#stack-pointer)\n   * [Best Practice](#best-practice)\n   * [TODO](#todo)\n   * [CHANGES](#changes)\n   * [Donation](#donation)\n   * [Thanks](#thanks)\n* [Copyright and License](#copyright-and-license)\n\n# Status\n\nProduction ready.\n\n# Synopsis\n\n```c\n#include \"aco.h\"    \n#include <stdio.h>\n\n// this header would override the default C `assert`;\n// you may refer the \"API : MACROS\" part for more details.\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct) {\n    printf(\"co: %p: yield to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_yield();\n    *((int*)(aco_get_arg())) = ct + 1;\n}\n\nvoid co_fp0() {\n    printf(\"co: %p: entry: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\"co: %p:  exit to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        ct++;\n    }\n    printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co: destroy and exit\\n\");\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n```\n```bash\n# default build\n$ gcc -g -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ ./test_aco_synopsis\nmain_co: yield to co: 0x1887120: 0\nco: 0x1887120: entry: 0\nco: 0x1887120: yield to main_co: 0\nmain_co: yield to co: 0x1887120: 1\nco: 0x1887120: yield to main_co: 1\nmain_co: yield to co: 0x1887120: 2\nco: 0x1887120: yield to main_co: 2\nmain_co: yield to co: 0x1887120: 3\nco: 0x1887120: yield to main_co: 3\nmain_co: yield to co: 0x1887120: 4\nco: 0x1887120: yield to main_co: 4\nmain_co: yield to co: 0x1887120: 5\nco: 0x1887120: yield to main_co: 5\nmain_co: yield to co: 0x1887120: 6\nco: 0x1887120:  exit to main_co: 6\nmain_co: destroy and exit\n# i386\n$ gcc -g -m32 -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n# share fpu and mxcsr env\n$ gcc -g -D ACO_CONFIG_SHARE_FPU_MXCSR_ENV -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis \n# with valgrind friendly support\n$ gcc -g -D ACO_USE_VALGRIND -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ valgrind --leak-check=full --tool=memcheck ./test_aco_synopsis\n```\n\nFor more information you may refer to the \"[Build and Test](#build-and-test)\" part.\n\n# Description\n\n![thread_model_0](img/thread_model_0.png)\n\nThere are 4 basic elements of an ordinary execution state: `{cpu_registers, code, heap, stack}`.\n\nSince the code information is indicated by `({E|R})?IP` register, and the address of the memory allocated from heap is normally stored in the stack directly or indirectly, thus we could simplify the 4 elements into only 2 of them: `{cpu_registers, stack}`.\n\n![thread_model_1](img/thread_model_1.png)\n\nWe define the `main co` as the coroutine who monopolizes the default stack of the current thread. And since the main co is the only user of this stack, we only need to save/restore the necessary cpu registers' state of the main co when it's been yielded-from/resumed-to (switched-out/switched-in).\n\nNext, the definition of the `non-main co` is the coroutine whose execution stack is a stack which is not the default stack of the current thread and may be shared with the other non-main co. Thus the non-main co must have a `private save stack` memory buffer to save/restore its execution stack when it is been switched-out/switched-in (because the succeeding/preceding co may would/had use/used the share stack as its execution stack).\n\n![thread_model_2](img/thread_model_2.png)\n\nThere is a special case of non-main co, that is `standalone non-main co` what we called in libaco: the share stack of the non-main coroutine has only one co user. Thus there is no need to do saving/restoring stuff of its private save stack when it is been switched-out/switched-in since there is no other co will touch the execution stack of the standalone non-main co except itself.\n\n![thread_model_3](img/thread_model_3.png)\n\nFinally, we get the big picture of libaco.\n\nThere is a \"[Proof of Correctness](#proof-of-correctness)\" part you may find really helpful if you want to dive into the internal of libaco or want to implement your own coroutine library.\n\nIt is also highly recommended to read the source code of the tutorials and benchmark next. The [benchmark](#benchmark) result is very impressive and enlightening too.\n\n# Build and Test\n\n## CFLAGS\n\n* `-m32`\n\nThe `-m32` option of gcc could help you to build the i386 application of libaco on a x86_64 machine. \n\n* C macro: `ACO_CONFIG_SHARE_FPU_MXCSR_ENV`\n\nYou could define the global C macro `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` to speed up the performance of context switching between coroutines slightly if none of your code would change the control words of FPU and MXCSR. If the macro is not defined, all the co would maintain its own copy of the FPU and MXCSR control words. It is recommended to always define this macro globally since it is very rare that one function needs to set its own special env of FPU or MXCSR instead of using the default env defined by the ISO C. But you may not need to define this macro if you are not sure of it.\n\n* C macro:`ACO_USE_VALGRIND`\n\nIf you want to use the tool memcheck of valgrind to test the application, then you may need to define the global C macro `ACO_USE_VALGRIND` to enable the friendly support of valgrind in libaco. But it is not recommended to define this macro in the final release build for the performance reason. You may also need to install the valgrind headers (package name is \"valgrind-devel\" in centos for example) to build libaco application with C macro `ACO_USE_VALGRIND` defined. (The memcheck of valgrind only works well with the standalone co currently. In the case of the shared stack used by more than one non-main co, the memcheck of valgrind would generate many false positive reports. For more information you may refer to \"[test_aco_tutorial_6.c](test_aco_tutorial_6.c)\".)\n\n* C macro:`ACO_USE_ASAN`\n\nThe global C macro `ACO_USE_ASAN` would enable the friendly support of [Address Sanitizer](https://en.wikipedia.org/wiki/AddressSanitizer) in libaco (support both gcc and clang).\n\n## Build\n\nTo build the test suites of libaco:\n\n```bash\n$ mkdir output\n$ bash make.sh\n```\n\nThere is also some detailed options in make.sh:\n\n```bash\n$bash make.sh -h\nUsage: make.sh [-o <no-m32|no-valgrind>] [-h]\n\nExample:\n    # default build\n    bash make.sh\n    # build without the i386 binary output\n    bash make.sh -o no-m32\n    # build without the valgrind supported binary output\n    bash make.sh -o no-valgrind\n    # build without the valgrind supported and i386 binary output\n    bash make.sh -o no-valgrind -o no-m32\n```\n\nIn short, using `-o no-valgrind ` if you have no valgrind headers installed, `-o no-m32` if you have no 32-bit gcc development tools installed on a AMD64 host.\n\nOn MacOS, you need to [replace](https://apple.stackexchange.com/questions/69223/how-to-replace-mac-os-x-utilities-with-gnu-core-utilities) the default `sed` and `grep` commands of MacOS with the GNU `sed` and `grep` to run `make.sh` and `test.sh` (such requirement would be removed in the future):\n\n```bash\n$ brew install grep --with-default-names\n$ brew install gnu-sed --with-default-names\n```\n\n## Test\n\n```bash\n$ cd output\n$ bash ../test.sh\n```\n\n# Tutorials\n\nThe `test_aco_tutorial_0.c` in this repository shows the basic usage of libaco. There is only one main co and one standalone non-main co in this tutorial. The comments in the source code is also very helpful.\n\nThe `test_aco_tutorial_1.c` shows the usage of some statistics of non-main co. The data structure of `aco_t` is very clear and is defined in `aco.h`.\n\nThere are one main co, one standalone non-main co and two non-main co (pointing to the same share stack) in `test_aco_tutorial_2.c`.\n\nThe `test_aco_tutorial_3.c` shows how to use libaco in a multithreaded process. Basically, one instance of libaco is designed only to work inside one certain thread to gain the maximum performance of context switching between coroutines. If you want to use libaco in multithreaded environment, simply to create one instance of libaco in each of the threads. There is no data-sharing across threads inside the libaco, and you have to deal with the data competition among multiple threads yourself (like what `gl_race_aco_yield_ct` does in this tutorial).\n\nOne of the rules in libaco is to call `aco_exit()` to terminate the execution of the non-main co instead of the default direct C style `return`, otherwise libaco will treat such behaviour as illegal and trigger the default protector whose job is to log the error information about the offending co to stderr and abort the process immediately. The `test_aco_tutorial_4.c` shows such \"offending co\" situation.\n\nYou could also define your own protector to substitute the default one (to do some customized \"last words\" stuff). But no matter in what case, the process will be aborted after the protector was executed. The `test_aco_tutorial_5.c` shows how to define the customized last word function.\n\nThe last example is a simple coroutine scheduler in `test_aco_tutorial_6.c`.\n\n# API\n\nIt would be very helpful to read the corresponding API implementation in the source code simultaneously when you are reading the following API description of libaco since the source code is pretty clear and easy to understand. And it is also recommended to read all the [tutorials](#tutorials) before reading the API document.\n\nIt is strongly recommended to read the [Best Practice](#best-practice) part before starting to write the real application of libaco (in addition to describing how to truly release libaco's extreme performance in your application, there is also a notice about the programming of libaco).\n\nNote: The version control of libaco follows the spec: [Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html). So the API in the following list have the compatibility guarantee. (Please note that there is no such guarantee for the API no in the list.)\n\n## aco_thread_init\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\nvoid aco_thread_init(aco_cofuncp_t last_word_co_fp);\n```\n\nInitializes the libaco environment in the current thread.\n\nIt will store the current control words of FPU and MXCSR into a thread-local global variable. \n\n* If the global macro `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` is not defined, the saved control words would be used as a reference value to set up the control words of the new co's FPU and MXCSR (in `aco_create`) and each co would maintain its own copy of FPU and MXCSR control words during later context switching.\n* If the global macro `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` is defined, then all the co shares the same control words of FPU and MXCSR. You may refer the \"[Build and Test](#build-and-test)\" part of this document for more information about this.\n\nAnd as it said in the `test_aco_tutorial_5.c` of the \"[Tutorials](#tutorials)\" part, when the 1st argument `last_word_co_fp` is not NULL then the function pointed by `last_word_co_fp` will substitute the default protector to do some \"last words\" stuff about the offending co before the process is aborted. In such last word function, you could use `aco_get_co` to get the pointer of the offending co. For more information, you may read `test_aco_tutorial_5.c`.\n\n## aco_share_stack_new\n\n```c\naco_share_stack_t* aco_share_stack_new(size_t sz);\n```\n\nEqual to `aco_share_stack_new2(sz, 1)`.\n\n## aco_share_stack_new2\n\n```c\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled);\n```\n\nCreates a new share stack with a advisory memory size of `sz` in bytes and may have a guard page (read-only) for the detection of stack overflow which is depending on the 2nd argument `guard_page_enabled`.\n\nTo use the default size value (2MB) if the 1st argument `sz` equals 0. After some computation of alignment and reserve, this function will ensure the final valid length of the share stack in return:\n\n* `final_valid_sz >= 4096`\n* `final_valid_sz >= sz`\n* `final_valid_sz % page_size == 0 if the guard_page_enabled != 0`\n\nAnd as close to the value of `sz` as possible.\n\nWhen the value of the 2nd argument `guard_page_enabled` is 1, the share stack in return would have one read-only guard page for the detection of stack overflow while a value 0 of `guard_page_enabled` means without such guard page.\n\nThis function will always return a valid share stack.\n\n## aco_share_stack_destroy\n\n```c\nvoid aco_share_stack_destroy(aco_share_stack_t* sstk);\n```\n\nDestory the share stack `sstk`.\n\nBe sure that all the co whose share stack is `sstk` is already destroyed when you destroy the `sstk`.\n\n## aco_create\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\naco_t* aco_create(aco_t* main_co, aco_share_stack_t* share_stack, \n        size_t save_stack_sz, aco_cofuncp_t co_fp, void* arg);\n```\n\nCreate a new co.\n\nIf it is a main_co you want to create, just call: `aco_create(NULL, NULL, 0, NULL, NULL)`. Main co is a special standalone coroutine whose share stack is the default thread stack. In the thread, main co is the coroutine who should be created and started to execute before all the other non-main coroutine does.\n\nOtherwise it is a non-main co you want to create:\n\n* The 1st argument `main_co` is the main co the co will `aco_yield` to in the future context switching. `main_co` must not be NULL;\n* The 2nd argument `share_stack` is the address of a share stack which the non-main co you want to create will use as its executing stack in the future. `share_stack` must not be NULL;\n* The 3rd argument `save_stack_sz` specifies the init size of the private save stack of this co. The unit is in bytes. A value of 0 means to use the default size 64 bytes. Since automatical resizing would happen when the private save stack is not big enough to hold the executing stack of the co when it has to yield the share stack it is occupying to another co, you usually should not worry about the value of `sz` at all. But it will bring some performance impact to the memory allocator when a huge amount (say 10,000,000) of the co resizes their private save stack continuously, so it is very wise and highly recommended to set the `save_stack_sz` with a value equal to the maximum value of `co->save_stack.max_cpsz` when the co is running (You may refer to the \"[Best Practice](#best-practice)\" part of this document for more information about such optimization);\n* The 4th argument `co_fp` is the entry function pointer of the co. `co_fp` must not be NULL;\n* The last argument `arg` is a pointer value and will set to `co->arg` of the co to create. It could be used as a input argument for the co.\n\nThis function will always return a valid co. And we name the state of the co in return as \"init\" if it is a non-main co you want to create.\n\n## aco_resume\n\n```c\nvoid aco_resume(aco_t* co);\n```\n\nYield from the caller main co and to start or continue the execution of `co`.\n\nThe caller of this function must be a main co and must be `co->main_co`. And the 1st argument `co` must be a non-main co.\n\nThe first time you resume a `co`, it starts running the function pointing by `co->fp`. If `co` has already been yielded, `aco_resume` restarts it and continues the execution.\n\nAfter the call of `aco_resume`, we name the state of the caller — main co as \"yielded\". \n\n## aco_yield\n\n```c\nvoid aco_yield();\n```\n\nYield the execution of `co` and resume `co->main_co`. The caller of this function must be a non-main co. And `co->main_co` must not be NULL.\n\nAfter the call of `aco_yield`, we name the state of the caller — `co` as \"yielded\".\n\n## aco_get_co\n\n```c\naco_t* aco_get_co();\n```\n\nReturn the pointer of the current non-main co. The caller of this function must be a non-main co.\n\n## aco_get_arg\n\n```c\nvoid* aco_get_arg();\n```\n\nEqual to `(aco_get_co()->arg)`. And also, the caller of this function must be a non-main co.\n\n## aco_exit\n\n```c\nvoid aco_exit();\n```\n\nIn addition do the same as `aco_yield()`, `aco_exit()` also set `co->is_end` to 1 thus to mark the `co` at the status of \"end\".\n\n## aco_destroy\n\n```c\nvoid aco_destroy(aco_t* co);\n```\n\nDestroy the `co`. The argument `co` must not be NULL. The private save stack would also been destroyed if the `co` is a non-main co.\n\n## MACROS\n\n### Version\n\n```c\n#define ACO_VERSION_MAJOR 1\n#define ACO_VERSION_MINOR 2\n#define ACO_VERSION_PATCH 4\n```\n\nThese 3 macros are defined in the header `aco.h` and the value of them follows the spec: [Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html).\n\n### aco_assert_override.h\n\n```c\n// provide the compiler with branch prediction information\n#define likely(x)               aco_likely(x)\n#define unlikely(x)             aco_unlikely(x)\n\n// override the default `assert` for convenience when coding\n#define assert(EX)              aco_assert(EX)\n\n// equal to `assert((ptr) != NULL)`\n#define assertptr(ptr)          aco_assertptr(ptr)\n\n// assert the successful return of memory allocation\n#define assertalloc_bool(b)     aco_assertalloc_bool(b)\n#define assertalloc_ptr(ptr)    aco_assertalloc_ptr(ptr)\n```\n\nYou could choose to include the header `\"aco_assert_override.h\"` to override the default C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" in the libaco application like [test_aco_synopsis.c](test_aco_synopsis.c) does (this header including should be at the last of the include directives list in the source file because the C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" is a C macro definition too) and define the 5 other macros in the above. Please do not include this header in the application source file if you want to use the default C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\".\n\nFor more details you may refer to the source file [aco_assert_override.h](aco_assert_override.h).\n\n# Benchmark\n\nDate: Sat Jun 30 UTC 2018.\n\nMachine: [c5d.large on AWS](https://aws.amazon.com/cn/blogs/aws/now-available-compute-intensive-c5-instances-for-amazon-ec2/).\n\nOS: RHEL-7.5 (Red Hat Enterprise Linux 7.5).\n\nHere is a brief summary of the benchmark part:\n\n* One time of the context switching between coroutines takes only about **10.29 ns** (in the case of standalone stack, where x87 and mxcsr control words are shared between coroutines);\n* One time of the context switching between coroutines takes only about **10.38 ns** (in the case of standalone stack, where each coroutine maintains their own x87 and mxcsr control words);\n* It is extremely memory efficient: it only costs **2.8 GB** of physical memory to run **10,000,000** coroutines simultaneously (with tcmalloc, where each coroutine has a **120 bytes** copy-stack size configuration).\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.shareFPUenv\n\n+build:x86_64\n+build:-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:share fpu & mxcsr control words between coroutines\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=152:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      230.00 ns/op    4347824.79 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.59 ns/op   48576413.55 op/s\n  -> acosw                                            40000000     0.412 s       10.29 ns/op   97152827.10 op/s\naco_destroy                                                  1     0.000 s      650.00 ns/op    1538461.66 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      200.00 ns/op    5000001.72 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.61 ns/op   48525164.25 op/s\n  -> acosw                                            40000000     0.412 s       10.30 ns/op   97050328.50 op/s\naco_destroy                                                  1     0.000 s      666.00 ns/op    1501501.49 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.50 ns/op   15266771.53 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.666 s       33.29 ns/op   30043022.64 op/s\naco_destroy                                            2000000     0.066 s       32.87 ns/op   30425152.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.130 s       65.22 ns/op   15332218.24 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.75 ns/op   29630018.73 op/s\naco_destroy                                            2000000     0.067 s       33.45 ns/op   29898311.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.42 ns/op   15286937.97 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.669 s       33.45 ns/op   29891277.59 op/s\naco_destroy                                            2000000     0.080 s       39.87 ns/op   25084242.29 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.224 s      111.86 ns/op    8940010.49 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.678 s       33.88 ns/op   29515473.53 op/s\naco_destroy                                            2000000     0.067 s       33.42 ns/op   29922412.68 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.74 ns/op   15211896.70 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.45 ns/op   26010724.94 op/s\naco_destroy                                            2000000     0.088 s       44.11 ns/op   22669240.25 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.240 s      123.97 ns/op    8066542.54 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.17 ns/op   30143409.55 op/s\naco_destroy                                           10000000     0.328 s       32.82 ns/op   30467658.05 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.659 s       65.94 ns/op   15165717.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.345 s       33.63 ns/op   29737708.53 op/s\naco_destroy                                           10000000     0.337 s       33.71 ns/op   29666697.09 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.654 s       65.38 ns/op   15296191.35 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.348 s       33.71 ns/op   29663992.77 op/s\naco_destroy                                           10000000     0.336 s       33.56 ns/op   29794574.96 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.653 s       65.29 ns/op   15316087.09 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.384 s       34.60 ns/op   28902221.24 op/s\naco_destroy                                           10000000     0.337 s       33.73 ns/op   29643682.93 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.652 s       65.19 ns/op   15340872.40 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.565 s       39.11 ns/op   25566255.73 op/s\naco_destroy                                           10000000     0.443 s       44.30 ns/op   22574242.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241722.94 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.947 s       47.36 ns/op   21114212.05 op/s\naco_destroy                                            2000000     0.125 s       62.35 ns/op   16039466.45 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.71 ns/op   15218784.72 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.948 s       47.39 ns/op   21101216.29 op/s\naco_destroy                                            2000000     0.125 s       62.73 ns/op   15941559.26 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.49 ns/op   15270258.18 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.069 s       53.44 ns/op   18714275.17 op/s\naco_destroy                                            2000000     0.122 s       61.05 ns/op   16378678.85 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.91 ns/op   15171336.62 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.190 s       59.48 ns/op   16813230.99 op/s\naco_destroy                                            2000000     0.123 s       61.26 ns/op   16324298.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.68 ns/op   15224361.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.828 s       91.40 ns/op   10941133.56 op/s\naco_destroy                                            2000000     0.145 s       72.56 ns/op   13781182.82 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.80 ns/op   15197461.34 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.829 s       91.47 ns/op   10932139.32 op/s\naco_destroy                                            2000000     0.149 s       74.70 ns/op   13387258.82 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.63 ns/op   15007426.35 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.224 s      211.20 ns/op    4734744.76 op/s\naco_destroy                                            1000000     0.093 s       93.36 ns/op   10711651.49 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.28 ns/op   15086953.73 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.222 s      211.12 ns/op    4736537.93 op/s\naco_destroy                                            1000000     0.094 s       94.09 ns/op   10627664.78 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.72 ns/op   14139923.59 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.191 s      209.56 ns/op    4771909.70 op/s\naco_destroy                                             100000     0.010 s      101.21 ns/op    9880747.28 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.62 ns/op   15010433.00 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.002 s      350.11 ns/op    2856228.03 op/s\naco_destroy                                             100000     0.016 s      159.69 ns/op    6262129.35 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.76 ns/op   15205994.08 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.918 s      595.90 ns/op    1678127.54 op/s\naco_destroy                                             100000     0.019 s      186.32 ns/op    5367189.85 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.03 ns/op   15865531.37 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917079.11 op/s\naco_destroy                                             100000     0.038 s      378.33 ns/op    2643225.42 op/s\n```\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.standaloneFPUenv\n\n+build:x86_64\n+build:undefined ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:each coroutine maintain each own fpu & mxcsr control words\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=160:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      273.00 ns/op    3663004.27 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.76 ns/op   48173877.75 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96347755.51 op/s\naco_destroy                                                  1     0.000 s      381.00 ns/op    2624672.26 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      212.00 ns/op    4716980.43 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.75 ns/op   48185455.26 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96370910.51 op/s\naco_destroy                                                  1     0.000 s      174.00 ns/op    5747123.38 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.63 ns/op   15237386.02 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.664 s       33.20 ns/op   30119155.82 op/s\naco_destroy                                            2000000     0.065 s       32.67 ns/op   30604542.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.33 ns/op   15305975.29 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.74 ns/op   29638360.61 op/s\naco_destroy                                            2000000     0.067 s       33.31 ns/op   30016633.42 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241767.78 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.678 s       33.88 ns/op   29518648.08 op/s\naco_destroy                                            2000000     0.079 s       39.74 ns/op   25163018.30 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.221 s      110.73 ns/op    9030660.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.684 s       34.18 ns/op   29253416.65 op/s\naco_destroy                                            2000000     0.067 s       33.40 ns/op   29938840.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.60 ns/op   15244077.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.43 ns/op   26021228.41 op/s\naco_destroy                                            2000000     0.087 s       43.74 ns/op   22863987.42 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.251 s      125.08 ns/op    7994958.59 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.19 ns/op   30133654.80 op/s\naco_destroy                                           10000000     0.329 s       32.85 ns/op   30439787.32 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.674 s       67.37 ns/op   14843796.57 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.354 s       33.84 ns/op   29548523.05 op/s\naco_destroy                                           10000000     0.339 s       33.90 ns/op   29494634.83 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.19 ns/op   14882262.88 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.361 s       34.02 ns/op   29393520.19 op/s\naco_destroy                                           10000000     0.338 s       33.77 ns/op   29609577.59 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.673 s       67.31 ns/op   14857716.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.371 s       34.27 ns/op   29181897.80 op/s\naco_destroy                                           10000000     0.339 s       33.85 ns/op   29540633.63 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.24 ns/op   14873017.10 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.548 s       38.71 ns/op   25835542.17 op/s\naco_destroy                                           10000000     0.446 s       44.61 ns/op   22415961.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.01 ns/op   15148290.52 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.22 ns/op   21177946.19 op/s\naco_destroy                                            2000000     0.124 s       61.99 ns/op   16132721.97 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.36 ns/op   15068860.85 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.20 ns/op   21187541.38 op/s\naco_destroy                                            2000000     0.124 s       62.21 ns/op   16073322.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.62 ns/op   15238955.93 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.072 s       53.61 ns/op   18652789.74 op/s\naco_destroy                                            2000000     0.121 s       60.42 ns/op   16551368.04 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.08 ns/op   15132547.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.198 s       59.88 ns/op   16699389.91 op/s\naco_destroy                                            2000000     0.121 s       60.71 ns/op   16471465.52 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.50 ns/op   15036985.95 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.853 s       92.63 ns/op   10796126.04 op/s\naco_destroy                                            2000000     0.146 s       72.87 ns/op   13723559.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.14 ns/op   15118324.13 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.855 s       92.75 ns/op   10781572.22 op/s\naco_destroy                                            2000000     0.152 s       75.79 ns/op   13194130.51 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.97 ns/op   14931921.56 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.218 s      210.90 ns/op    4741536.66 op/s\naco_destroy                                            1000000     0.093 s       93.16 ns/op   10734691.98 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.49 ns/op   15039274.31 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.216 s      210.81 ns/op    4743543.53 op/s\naco_destroy                                            1000000     0.094 s       93.97 ns/op   10641539.58 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.95 ns/op   14094724.73 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.190 s      209.52 ns/op    4772746.50 op/s\naco_destroy                                             100000     0.010 s      100.99 ns/op    9902271.51 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.49 ns/op   15040038.84 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.028 s      351.38 ns/op    2845942.55 op/s\naco_destroy                                             100000     0.016 s      159.15 ns/op    6283444.42 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.73 ns/op   15214482.36 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.879 s      593.95 ns/op    1683636.60 op/s\naco_destroy                                             100000     0.018 s      184.23 ns/op    5428119.00 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.41 ns/op   15771072.16 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917081.56 op/s\naco_destroy                                             100000     0.038 s      376.78 ns/op    2654073.13 op/s\n```\n\n# Proof of Correctness\n\nIt is essential to be very familiar with the standard of [Sys V ABI of intel386 and x86-64](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI) before you start to implement or prove a coroutine library.\n\nThe proof below has no direct description about the IP (instruction pointer), SP (stack pointer) and the saving/restoring between the private save stack and the share stack, since these things are pretty trivial and easy to understand when they are compared with the ABI constraints stuff.\n\n## Running Model\n\nIn the OS thread, the main coroutine `main_co` is the coroutine who should be created and started to execute first, before all the other non-main coroutines do.\n\nThe next diagram is a simple example of the context switching between main_co and co.\n\nIn this proof, we just assume that we are under Sys V ABI of intel386 since there is no fundamental differences between the Sys V ABI of intel386 and x86-64. We also assume that none of the code would change the control words of FPU and MXCSR.\n\n![proof_0](img/proof_0.png)\n\nThe next diagram is actually a symmetric coroutine's running model which has an unlimited number of non-main co-s and one main co. This is fine because the asymmetric coroutine is just a special case of the symmetric coroutine. To prove the correctness of the symmetric coroutine is a little more challenging than of the asymmetric coroutine and thus more fun it would become. (libaco only implemented the API of asymmetric coroutine currently because the semantic meaning of the asymmetric coroutine API is far more easy to understand and to use than the symmetric coroutine does.)\n\n![proof_1](img/proof_1.png)\n\nSince the main co is the 1st coroutine starts to run, the 1st context switching in this OS thread must be in the form of `acosw(main_co, co)` where the 2nd argument `co` is a non-main co.\n\n## Mathematical Induction\n\nIt is easy to prove that there only exists two kinds of state transfer in the above diagram:\n\n* yielded state co → init state co\n* yielded state co → yielded state co\n\nTo prove the correctness of `void* acosw(aco_t* from_co, aco_t* to_co)` implementation is equivalent to prove all the co constantly comply to the constraints of Sys V ABI before and after the call of `acosw`. We assume that the other part of binary code (except `acosw`) in the co had already comply to the ABI (they are normally generated by the compiler correctly).\n\nHere is a summary of the registers' constraints in the Function Calling Convention of Intel386 Sys V ABI:\n\n```\nRegisters' usage in the calling convention of the Intel386 System V ABI:\n    caller saved (scratch) registers:\n        C1.0: EAX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                hold the return value for `acosw`\n        C1.1: ECX,EDX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.2: Arithmetic flags, x87 and mxcsr flags\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.3: ST(0-7)\n            At the entry of a function call:\n                the stack of FPU must be empty\n            After the return of `acosw`:\n                the stack of FPU must be empty\n        C1.4: Direction flag\n            At the entry of a function call:\n                DF must be 0\n            After the return of `acosw`:\n                DF must be 0\n        C1.5: others: xmm*,ymm*,mm*,k*...\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n    callee saved registers:\n        C2.0: EBX,ESI,EDI,EBP\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                must be the same as it is at the entry of `acosw` \n        C2.1: ESP\n            At the entry of a function call:\n                must be a valid stack pointer\n                (alignment of 16 bytes, retaddr and etc...)\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw`\n        C2.2: control word of FPU & mxcsr\n            At the entry of a function call:\n                could be any configuration\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw` \n                (unless the caller of `acosw` assume `acosw` may    \\\n                change the control words of FPU or MXCSR on purpose \\\n                like `fesetenv`)\n```\n\n(For Intel386, the register usage is defined in the \"P13 - Table 2.3: Register Usage\" of [Sys V ABI Intel386 V1.1](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI), and for AMD64 is in \"P23 - Figure 3.4: Register Usage\" of [Sys V ABI AMD64 V1.0](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI).)\n\n**Proof:**\n\n1. yielded state co -> init state co:\n\n![proof_2](img/proof_2.png)\n\nThe diagram above is for the 1st case: \"yielded state co -> init state co\".\n\nConstraints: C 1.0, 1.1, 1.2, 1.5 (*satisfied* ✓ )\n\nThe scratch registers below can hold any value at the entry of a function:\n\n```\nEAX,ECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\nConstraints: C 1.3, 1.4 (*satisfied* ✓ )\n\nSince the stack of FPU must already be empty and the DF must already be 0 before `acosw(co, to_co)` was called (the binary code of co is already complied to the ABI), the constraint 1.3 and 1.4 is complied by `acosw`.\n\nConstraints: C 2.0, 2.1, 2.2 (*satisfied* ✓ )\n\nC 2.0 & 2.1 is already satisfied. Since we already assumed that nobody will change the control words of FPU and MXCSR, C 2.2 is satisfied too.\n\n2. yielded state co -> yielded state co:\n\n![proof_3](img/proof_3.png)\n\nThe diagram above is for the 2nd case: yielded state co -> yielded state co.\n\nConstraints: C 1.0 (*satisfied* ✓ )\n\nEAX already holding the return value when `acosw` returns back to to_co (resume).\n\nConstraints: C 1.1, 1.2, 1.5 (*satisfied* ✓ )\n\nThe scratch registers below can hold any value at the entry of a function and after the return of `acosw`:\n\n```\nECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\nConstraints: C 1.3, 1.4 (*satisfied* ✓ )\n\nSince the stack of FPU must already be empty and the DF must already be 0 before `acosw(co, to_co)` was called (the binary code of co is already complied to the ABI), the constraint 1.3 and 1.4 is complied by `acosw`.\n\nConstraints: C 2.0, 2.1, 2.2 (*satisfied* ✓ )\n\nC 2.0 & 2.1 is satisfied because there is saving & restoring of the callee saved registers when `acosw` been called/returned. Since we already assumed that nobody will change the control words of FPU and MXCSR, C 2.2 is satisfied too.\n\n3. Mathematical induction:\n\nThe 1st `acosw` in the thread must be the 1st case: yielded state co -> init state co, and all the next `acosw` must be one of the 2 case above. Sequentially, we could prove that \"all the co constantly comply to the constraints of Sys V ABI before and after the call of `acosw`\". Thus, the proof is finished.\n\n## Miscellaneous\n\n### Red Zone\n\nThere is a new thing called [red zone](https://en.wikipedia.org/wiki/Red_zone_(computing)) in System V ABI x86-64:\n\n> The 128-byte area beyond the location pointed to by %rsp is considered to be reserved and shall not be modified by signal or interrupt handlers. Therefore, functions may use this area for temporary data that is not needed across function calls. In particular, leaf functions may use this area for their entire stack frame, rather than adjusting the stack pointer in the prologue and epilogue. This area is known as the red zone.\n\nSince the red zone is \"not preserved by the callee\", we just do not care about it at all in the context switching between coroutines (because the `acosw` is a leaf function).\n\n### Stack Pointer\n\n> The end of the input argument area shall be aligned on a 16 (32 or 64, if \\_\\_m256 or \\_\\_m512 is passed on stack) byte boundary. In other words, the value (%esp + 4) is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, %esp, always points to the end of the latest allocated stack frame.\n>\n> — Intel386-psABI-1.1:2.2.2 The Stack Frame\n\n> The stack pointer, %rsp, always points to the end of the latest allocated stack frame.\n>\n> — Sys V ABI AMD64 Version 1.0:3.2.2 The Stack Frame\n\nHere is a [bug example](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27) in Tencent's libco. The ABI states that the `(E|R)SP` should always point to the end of the latest allocated stack frame. But in file [coctx_swap.S](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27) of libco, the `(E|R)SP` had been used to address the memory on the heap.\n\n>**By default, the signal handler  is invoked  on  the normal process stack.**  It is possible to arrange that the signal handler uses an alternate stack; see sigalstack(2)  for  a discussion of how to do this and when it might be useful.\n>\n>— man 7 signal : Signal dispositions\n\nTerrible things may happen if the `(E|R)SP`  is pointing to the data structure on the heap when signal comes. (Using the `breakpoint` and `signal` commands of gdb could produce such bug conveniently. Although by using `sigalstack` to change the default signal stack could alleviate the problem, but still, that kind of usage of `(E|R)SP` still violates the ABI.)\n\n# Best Practice\n\nIn summary, if you want to gain the ultra performance of libaco, just keep the stack usage of the non-standalone non-main co at the point of calling `aco_yield` as small as possible. And be very careful if you want to pass the address of a local variable from one co to another co since the local variable is usually on the **share** stack. Allocating this kind of variables from the heap is always the wiser choice.\n\nIn detail, there are 5 tips:\n\n```\n       co_fp \n       /  \\\n      /    \\  \n    f1     f2\n   /  \\    / \\\n  /    \\  f4  \\\nyield  f3     f5\n```\n\n1. The stack usage of main co has no direct influence to the performance of context switching between coroutines (since it has a standalone execution stack);\n2. The stack usage of standalone non-main co has no direct influence to the performance of context switching between coroutines. But a huge amount of standalone non-main co would cost too much of virtual memory (due to the standalone stack), so it is not recommended to create huge amount of standalone non-main co in one thread;\n3. The stack usage of non-standalone (share stack with other coroutines) non-main co when it is been yielded (i.e. call `aco_yield` to yield back to main co) has a big impact to the performance of context switching between coroutines, as already indicated by the benchmark results. In the diagram above, the stack usage of function f2, f3, f4 and f5 has no direct influence over the context switching performance since there are no `aco_yield` when they are executing, whereas the stack usage of co_fp and f1 dominates the value of `co->save_stack.max_cpsz` and has a big influence over the context switching performance.\n\nThe key to keeping the stack usage of a function as low as possible is to allocate the local variables (especially the big ones) on the heap and manage their lifecycle manually instead of allocating them on the stack by default. The `-fstack-usage` option of gcc is very helpful about this.\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int ct = 0;\n    gl_ptr = &ct; // line 7\n    aco_yield();\n    check(ct);\n    int* ptr = &ct;\n    inc_p(ptr);   // line 11\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr); // line 16\n    aco_exit();\n}\n```\n\n4. In the above code snippet, we assume that co_fp0 & co_fp1 shares the same share stack (they are both non-main co) and the running sequence of them is \"co_fp0 -> co_fp1 -> co_fp0\". Since they are sharing the same stack, the address holding in `gl_ptr` in co_fp1 (line 16) has totally different semantics with the `gl_ptr` in line 7 of co_fp0, and that kind of code would probably corrupt the execution stack of co_fp1. But the line 11 is fine because variable `ct` and function `inc_p` are in the same coroutine context. Allocating that kind of variables (need to share with other coroutines) on the heap would simply solve such problems:\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int* ct_ptr = malloc(sizeof(int));\n    assert(ct_ptr != NULL);\n    *ct_ptr = 0;\n    gl_ptr = ct_ptr;\n    aco_yield();\n    check(*ct_ptr);\n    int* ptr = ct_ptr;\n    inc_p(ptr);\n    free(ct_ptr);\n    gl_ptr = NULL;\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr);\n    aco_exit();\n}\n```\n\n# TODO\n\nNew ideas are welcome!\n\n* Add a macro like `aco_mem_new` which is the combination of something like `p = malloc(sz); assertalloc_ptr(p)`.\n\n* Add a new API `aco_reset` to support the reusability of the coroutine objects.\n\n* Support other platforms (especially arm & arm64).\n\n# CHANGES\n\n```\nv1.2.4 Sun Jul 29 2018\n    Changed `asm` to `__asm__` in aco.h to support compiler's `--std=c99`\n    flag (Issue #16, proposed by Theo Schlossnagle @postwait).\nv1.2.3 Thu Jul 26 2018\n    Added support for MacOS;\n    Added support for shared library build of libaco (PR #10, proposed\n    by Theo Schlossnagle @postwait);\n    Added C macro ACO_REG_IDX_BP in aco.h (PR #15, proposed by\n    Theo Schlossnagle @postwait);\n    Added global C config macro ACO_USE_ASAN which could enable the\n    friendly support of address sanitizer (both gcc and clang) (PR #14,\n    proposed by Theo Schlossnagle @postwait);\n    Added README_zh.md.\nv1.2.2 Mon Jul 9 2018\n    Added a new option `-o <no-m32|no-valgrind>` to make.sh;\n    Correction about the value of macro ACO_VERSION_PATCH (issue #1 \n    kindly reported by Markus Elfring @elfring);\n    Adjusted some noncompliant naming of identifiers (double underscore\n    `__`) (issue #1, kindly proposed by Markus Elfring @elfring);\n    Supported the header file including by C++ (issue #4, kindly\n    proposed by Markus Elfring @elfring).\nv1.2.1 Sat Jul 7 2018\n    Fixed some noncompliant include guards in two C header files (\n    issue #1 kindly reported by Markus Elfring @elfring);\n    Removed the \"pure\" word from \"pure C\" statement since it is\n    containing assembly codes (kindly reported by Peter Cawley\n    @corsix);\n    Many updates in the README.md document.\nv1.2.0 Tue Jul 3 2018\n    Provided another header named `aco_assert_override.h` so user\n    could choose to override the default `assert` or not;\n    Added some macros about the version information.\nv1.1   Mon Jul 2 2018\n    Removed the requirement on the GCC version (>= 5.0).\nv1.0   Sun Jul 1 2018\n    The v1.0 release of libaco, cheers 🎉🎉🎉\n```\n\n# Donation\n\nI'm a full-time open source developer. Any amount of the donations will be highly appreciated and could bring me great encouragement.\n\n* Paypal\n\n  [paypal.me link](https://www.paypal.me/00hnes)\n\n* Alipay (支付(宝|寶))\n\n![qr_alipay](img/qr_alipay.png)\n\n* Wechat (微信)\n\n![qr_wechat](img/qr_wechat.png)\n\n# Thanks\n\nThe logo of libaco is generously donated by Peter Bech([Peteck](https://github.com/Peteck)). The logo is licensed under [CC BY-ND 4.0](https://creativecommons.org/licenses/by-nd/4.0/). The website of [libaco.org](https://libaco.org) is also kindly contributed by Peter Bech([Peteck](https://github.com/Peteck)).\n\n# Copyright and License\n\nCopyright (C) 2018, by Sen Han [<00hnes@gmail.com>](mailto:00hnes@gmail.com).\n\nUnder the Apache License, Version 2.0.\n\nSee the [LICENSE](LICENSE) file for details.\n"
        },
        {
          "name": "README_zh.md",
          "type": "blob",
          "size": 52.7978515625,
          "content": "# Name\n \nlibaco - 一个极速的、轻量级、C语言非对称协程库。\n\n这个项目的代号是Arkenstone 💎\n\nAsymmetric COroutine 和 Arkenstone 是 aco 的名称来源。\n\n当前支持Sys V ABI Intel386和Sys V ABI x86-64。\n\n下面是这个项目的简要介绍：\n\n- 除了一个生产级别的C协程库实现，还包含了一个详细的文档描述了如何实现一个 *最快且正确* 的协程库以及其严格的数学证明；\n- 核心实现不超过 *700* 行代码，但包含了一个协程库应该有的全部功能；\n- 在AWS c5d.large机器上的性能测试结果指出，一次协程间上下文切换仅耗时 *10 ns* （独立执行栈）；\n- 用户在创建新的协程时，可以选择其拥有一个独占的执行栈，或者是与其它任意数量的协程一起共享一个执行栈；\n- 拥有极致的内存使用效率：一千万个协程并发执行仅消耗2.8GB的物理内存（tcmalloc，每一个协程使用120B的复制栈）。\n\n上文中的\"最快\"指的是在满足Sys V ABI Intel386或者AMD64约束下最快的上下文切换实现。\n\n[![Build Status Travis](https://img.shields.io/travis/hnes/libaco.svg?style=flat-square&&branch=master)](https://travis-ci.org/hnes/libaco)\n[![Releases](https://img.shields.io/github/release/hnes/libaco/all.svg?style=flat-square)](https://github.com/hnes/libaco/releases)\n[![LICENSE](https://img.shields.io/github/license/hnes/libaco.svg?style=flat-square)](https://github.com/hnes/libaco/blob/master/LICENSE)\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=libaco+-+A+blazing+fast+and+lightweight+C+asymmetric+coroutine+library&url=https://github.com/hnes/libaco&via=00hnes)\n\n热烈欢迎Issues和PRs 🎉🎉🎉\n\n注意: 请使用Release而非Master分支进行最终的二进制程序构建。\n\n[github-release]: https://github.com/hnes/libaco/releases\n\n# Table of Contents\n\n   * [Name](#name)\n   * [Table of Contents](#table-of-contents)\n   * [Status](#status)\n   * [Synopsis](#synopsis)\n   * [Description](#description)\n   * [Build and Test](#build-and-test)\n      * [CFLAGS](#cflags)\n      * [Build](#build)\n      * [Test](#test)\n   * [Tutorials](#tutorials)\n   * [API](#api)\n      * [aco_thread_init](#aco_thread_init)\n      * [aco_share_stack_new](#aco_share_stack_new)\n      * [aco_share_stack_new2](#aco_share_stack_new2)\n      * [aco_share_stack_destroy](#aco_share_stack_destroy)\n      * [aco_create](#aco_create)\n      * [aco_resume](#aco_resume)\n      * [aco_yield](#aco_yield)\n      * [aco_get_co](#aco_get_co)\n      * [aco_get_arg](#aco_get_arg)\n      * [aco_exit](#aco_exit)\n      * [aco_destroy](#aco_destroy)\n      * [MACROS](#macros)\n   * [Benchmark](#benchmark)\n   * [Proof of Correctness](#proof-of-correctness)\n      * [Running Model](#running-model)\n      * [Mathematical Induction](#mathematical-induction)\n      * [Miscellaneous](#miscellaneous)\n         * [Red Zone](#red-zone)\n         * [Stack Pointer](#stack-pointer)\n   * [Best Practice](#best-practice)\n   * [TODO](#todo)\n   * [CHANGES](#changes)\n   * [Donation](#donation)\n* [Copyright and License](#copyright-and-license)\n\n# Status\n\n可以用于生产环境。\n\n# Synopsis\n\n```c\n#include \"aco.h\"    \n#include <stdio.h>\n\n// this header would override the default C `assert`;\n// you may refer the \"API : MACROS\" part for more details.\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct) {\n    printf(\"co: %p: yield to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_yield();\n    *((int*)(aco_get_arg())) = ct + 1;\n}\n\nvoid co_fp0() {\n    printf(\"co: %p: entry: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\"co: %p:  exit to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        ct++;\n    }\n    printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co: destroy and exit\\n\");\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n```\n```bash\n# default build\n$ gcc -g -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ ./test_aco_synopsis\nmain_co: yield to co: 0x1887120: 0\nco: 0x1887120: entry: 0\nco: 0x1887120: yield to main_co: 0\nmain_co: yield to co: 0x1887120: 1\nco: 0x1887120: yield to main_co: 1\nmain_co: yield to co: 0x1887120: 2\nco: 0x1887120: yield to main_co: 2\nmain_co: yield to co: 0x1887120: 3\nco: 0x1887120: yield to main_co: 3\nmain_co: yield to co: 0x1887120: 4\nco: 0x1887120: yield to main_co: 4\nmain_co: yield to co: 0x1887120: 5\nco: 0x1887120: yield to main_co: 5\nmain_co: yield to co: 0x1887120: 6\nco: 0x1887120:  exit to main_co: 6\nmain_co: destroy and exit\n# i386\n$ gcc -g -m32 -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n# share fpu and mxcsr env\n$ gcc -g -D ACO_CONFIG_SHARE_FPU_MXCSR_ENV -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis \n# with valgrind friendly support\n$ gcc -g -D ACO_USE_VALGRIND -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ valgrind --leak-check=full --tool=memcheck ./test_aco_synopsis\n```\n\n关于构建的更多信息请查阅\"[Build and Test](#build-and-test)\"部分。\n\n# Description\n\n![thread_model_0](img/thread_model_0.png)\n\n一个用户空间的执行状态（一般为OS线程）有四个基本要素:`{cpu_registers, code, heap, stack}`。\n\n由于二进制程序的代码执行位置信息由`({E|R})?IP`寄存器决定，且从堆中分配出的内存地址信息一般会间接或者直接的保存在运行栈中，所以，我们可以将这个四个元素最终化简为`{cpu_registers, stack}`。\n\n![thread_model_1](img/thread_model_1.png)\n\n我们定义`main co`（主协程）为独占使用当前运行线程默认执行栈的协程。由于main co是这个执行栈的唯一用户，所以，在与main co相关的协程上下文切换中，我们仅需要对main co的某些必须的寄存器进行保存和恢复即可。\n\n接着，我们定义`non-main co`（非主协程）为执行栈不是当前运行线程默认执行栈（而是它自己创建的，且有可能会与其他non-main co一起共享这个执行栈）的协程。所以，`non-main co`会有一个私有的保存栈，当它被切换进来（或者切换出去）时，会使用它的私有保存栈进行执行栈的恢复（或者保存），因为当它被切换进来（或者切换出去）时，之前的（或者之后的）运行协程可能已经使用了（或者可能将会使用）这个执行栈（在libaco实现中，私有保存栈的保存策略是惰性的最优方案，具体请参见aco_resume的源码实现细节）。\n\n![thread_model_2](img/thread_model_2.png)\n\n这是一个non-main co的特殊情况，在libaco中我们称之为`standalone non-main co`（独立非主协程），即独占一个执行栈的非主协程。在与standalone non-main co相关的上下文切换中，对其只需要进行一些必须寄存器的保存或恢复即可（因为它的执行栈是独占的，在它被切换出的时间里，它的执行栈的状态是不变的）。\n\n![thread_model_3](img/thread_model_3.png)\n\n最终，我们得到了libaco的全局鸟瞰图。\n\n如果你想要实现自己的协程库或者更加深入的了解libaco的实现，\"[Proof of Correctness](#proof-of-correctness)\" 部分将会非常有用。\n\n接下来，可以阅读[教程](#tutorials)或者性能测试部分。[性能测试的报告](#benchmark)令人印象深刻同时发人深省。\n\n# Build and Test\n\n## CFLAGS\n\n* `-m32`\n\n编译器选项`-m32`能够帮助用户在AMD64平台上构建libaco的i386二进制程序。\n\n* C macro: `ACO_CONFIG_SHARE_FPU_MXCSR_ENV`\n\n如果用户的程序在运行期间不会更改FPU和MXCSR的控制字，那么可以选择定义全局C宏 `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` 以轻微地加快协程间上下文切换的速度。如果该宏没有被定义，每一个协程将会维护一份属于自己的独立FPU和MXCSR控制字环境。由于更改FPU或者MXCSR控制字的应用代码是非常少见的，用户可以选择总是全局定义该宏，但是如果并不能保证这个约束，用户应该选择不定义该宏。\n\n* C macro:`ACO_USE_VALGRIND`\n\n如果用户想要使用valgrind的memcheck工具对libaco的应用程序进行测试，则需要在构建时定义全局C宏 `ACO_USE_VALGRIND` 以使能libaco对valgrind memcheck时的支持。 由于性能的原因，在最终的生产二进制构建中并不推荐使用此宏。在全局定义了此宏的libaco应用构建之前，用户需要安转valgrind的C头文件（以Centos为例，这个开发包的名称为\"valgrind-devel\"）。valgrind的memcheck现在只支持拥有独立运行栈的协程，memcheck在对使用共享栈的协程进行检测时会输出很多的误报。更多的信息可以查看\"[test_aco_tutorial_6.c](test_aco_tutorial_6.c)\"。\n\n## Build\n\n```bash\n$ mkdir output\n$ bash make.sh\n```\n\nmake.sh脚本中有一些更加详细的构建参数：\n\n```bash\n$bash make.sh -h\nUsage: make.sh [-o <no-m32|no-valgrind>] [-h]\n\nExample:\n    # default build\n    bash make.sh\n    # build without the i386 binary output\n    bash make.sh -o no-m32\n    # build without the valgrind supported binary output\n    bash make.sh -o no-valgrind\n    # build without the valgrind supported and i386 binary output\n    bash make.sh -o no-valgrind -o no-m32\n```\n\n简而言之，如果系统中没有valgrind的C头文件，可以选择使用参数 `-o no-valgrind `进行测试集的构建；如果系统为AMD64平台并且没有安装32位的C编译器开发工具链，可以选择使用参数 `-o no-m32` 进行测试集的构建。\n\n## Test\n\n```bash\n$ cd output\n$ bash ../test.sh\n```\n\n# Tutorials\n\n文件`test_aco_tutorial_0.c`中包含了libaco的基本使用示例。在这个示例中，只包含了一个 main co 和一个 standalone non-main co，另外，代码中的注释也很有用。\n\n文件`test_aco_tutorial_1.c`中包含了libaco协程的运行统计信息的使用示例。类型`aco_t`的定义在`aco.h`中并且清晰易懂。\n\n在文件`test_aco_tutorial_2.c`中，包含了一个standalone non-main co和两个共享同一个执行栈的non-main co。\n\n文件`test_aco_tutorial_3.c`展示了如何在多线程环境中使用libaco。从根本上讲，为了获得最好的协程间上下文切换性能，在设计时一个libaco的运行实例应该仅仅工作在一个固定的线程中。这样，如果你想在多线程中使用libaco，只需要分别在各个线程中像在单线程中那样使用libaco一样使用它即可。在libaco内部没有任何的线程间数据共享；在多线程场景下，用户需要自己处理好自己的数据竞争问题（就像此实例中`gl_race_aco_yield_ct`线程间共享变量做的那样）。\n\n在libaco中，请调用API `aco_exit()`来进行终结non-main co的执行，而不要直接使用默认的C关键字`return`进行返回（否则libaco会将这种行为当做异常事件并触发默认的protector流程：输出错误信息至stderr并立即调用`abort`来终结进程的执行）。源文件`test_aco_tutorial_4.c`中示范了一个违背了此规则的协程实例。\n\n同时，用户也可以选择定制自己想要的protector处理逻辑（比如去做一些自定义的\"last words\"即“遗嘱”任务)。但是无论如何，当protector被执行完毕后，当前进程一定会被`abort`。源文件`test_aco_tutorial_5.c`中描述了如何自定义protector。\n\n源文件`test_aco_tutorial_6.c`中示范了一个简单的协程调度器的实例。\n\n# API\n\n在阅读下面的API文档时，建议也可以同时阅读对应源码中的实现，因为源码非常的清晰易读。同时，在阅读API文档之前，推荐先阅读[教程](#tutorials)部分。\n\n另外，在开始写libaco的应用之前，强烈建议先进行阅读[最佳实践](#best-practice)章节，此章节中除了描述如何应用libaco以让其性能发挥到极致，也描述了一些libaco编程时的注意事项。\n\n注意：libaco的版本控制遵从[Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html)标准。所以，下面列出的所有API均有标准中所描述的兼容性保证（请注意，没有在下面API列表中的函数调用则没有如此的保证）。\n\n## aco_thread_init\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\nvoid aco_thread_init(aco_cofuncp_t last_word_co_fp);\n```\n\n在当前运行线程中初始化libaco的执行环境。\n\n此API会将当前FPU与MXCSR的控制字保存到一个TLS全局变量中。\n\n* 如果全局C宏 `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` 没有被定义，保存的控制字接下来会被用来初始化新协程（`aco_create`）的FPU与MXCSR的控制字，然后每一个协程都将会在以后的协程上下文切换中独立维护这一份属于自己的FPU与MXCSR的控制字配置。\n* 如果全局C宏 `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` 被定义了，所有的协程将会共享同一份FPU与MXCSR的控制字配置。如果在这方面想了解更多，请查阅 \"[Build and Test](#build-and-test)\" 部分。\n\n就像在 \"[Tutorials](#tutorials)\" 中关于 `test_aco_tutorial_5.c` 部分所陈述的那样，API的第一个入参`last_word_co_fp`为用户自定义的 \"last words\" 函数指针, 如果它的值非NULL，将会取代默认的protector handler（在进程abort之前做一些 \"last words\" 相关的事情）。在这样的 \"last word\" 函数中，用户可以调用API `aco_get_co` 以获得当前协程的指针。可以通过阅读源文件`test_aco_tutorial_5.c`以获得与此相关的更多信息。\n\n## aco_share_stack_new\n\n```c\naco_share_stack_t* aco_share_stack_new(size_t sz);\n```\n\n等价于调用`aco_share_stack_new2(sz, 1)`。\n\n## aco_share_stack_new2\n\n```c\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled);\n```\n\n创建一个新的执行栈，入参`sz`是对要创建执行栈的大小的一个建议性字节值，入参`guard_page_enabled`决定了要创建的执行栈是否会拥有一个只读的 \"guard page\" （可以用来检测执行栈的溢出）。\n\n当第一入参`sz`为0时，表示选择使用默认的大小值（2MB）。经过一系列关于内存对齐和保留的运算后，该API保证最终创建出的执行栈满足下列所有条件：\n\n* `final_valid_sz >= 4096`\n* `final_valid_sz >= sz`\n* `final_valid_sz % page_size == 0 if the guard_page_enabled != 0`\n\n并且尽可能的接近入参`sz`的值。\n\n当第二入参`guard_page_enabled`的值为1时，创建的执行栈将会拥有一个只读的用来检测执行栈溢出的 \"guard page\"，为0时则不会拥有这样的 \"guard page\" 。\n\n此函数总是成功地返回一个可用的执行栈。\n\n## aco_share_stack_destroy\n\n```c\nvoid aco_share_stack_destroy(aco_share_stack_t* sstk);\n```\n\n销毁执行栈`sstk`。\n\n在销毁执行栈`sstk`之前，请确定所有使用这个执行栈的协程已经全部被销毁。\n\n## aco_create\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\naco_t* aco_create(aco_t* main_co，aco_share_stack_t* share_stack, \n        size_t save_stack_sz, aco_cofuncp_t co_fp, void* arg);\n```\n\n创建一个新的协程。\n\n如果想创建一个main co，直接调用：`aco_create(NULL, NULL, 0, NULL, NULL)`。Main co是一个特殊的standalone coroutine，它的执行栈是当前线程默认的执行栈。在一个线程中，main co 是被第一个创建并且是在所有其他non-main coroutine之前就已经开始运行了的协程。\n\n如果想使用此API创建一个non-main co：\n\n* 第一个入参`main_co`指向当前线程中的main co，创建出的non-main co以后在调用API `aco_yield`时将会将执行流程转交给入参`main_co`指向的main co，入参`main co`必然非NULL；\n* 第二个入参`share_stack`指向要创建的non-main co以后要使用的执行栈。`share_stack` 必然非NULL。\n* 第三个入参`save_stack_sz`指定要创建的non-main co的私有保存栈的初始大小，其单位为字节。值0表示使用默认的初始大小64字节。由于在以后的non-main co执行过程中，如果其私有保存栈不够大时将会进行自动地大小调整，所以一般情况下，用户不需要担心它的值。但是，如果有巨量的协程(比如一千万个)相继的进行大小调整，将会给内存分配器带来一些性能冲击，所以一个更加明智的选择是，给入参`save_stack_sz`赋予一个协程运行期间保存栈需要的最大值（即`co->save_stack.max_cpsz`的值），查阅 \"[最佳实践](#best-practice)\" 部分以获得与此相关的更多优化信息。\n* 第四个入参`co_fp`是要创建non-main co的入口函数指针。`co_fp`必然非NULL。\n* 最后一个入参`arg`为一个指针值，将会设置为要创建non-main co的`co->arg`的值，`co->arg`一般用来作为协程的输入参数。\n\n此API将会永远地成功返回一个可用的协程。同时，我们定义`aco_create`返回的non-main co处于 \"init\" 状态。\n\n## aco_resume\n\n```c\nvoid aco_resume(aco_t* co);\n```\n\n从调用者处Yield出来并开始或者继续协程`co`的执行。\n\n此API的调用者必须是main co并且必须是`co->main_co`，入参`co`必须是non-main co。\n\n第一次Resume协程`co`时，将会开始`co`的执行（函数指针`co->fp`指向的函数）。如果协程`co`已经Yielded，`aco_resume`将会继续`co`的执行。\n\n在API `aco_resume`被调用之后，我们定义调用者 -- main co 的状态为 \"yielded\" 。\n\n## aco_yield\n\n```c\nvoid aco_yield();\n```\n\n从调用者`co`处Yield出来并且Resume `co->main_co`的执行。\n\n此API的调用者必须为non-main co，`co->main_co`必须非NULL。\n\n在API `aco_yield`被调用之后，我们定义`co`的状态为 \"yielded\" 。\n\n## aco_get_co\n\n```c\naco_t* aco_get_co();\n```\n\n返回当前non-main co的指针。此API的调用者必须是non-main co。\n\n## aco_get_arg\n\n```c\nvoid* aco_get_arg();\n```\n\n等价于`(aco_get_co()->arg)`。同样的，此API的调用者必须是non-main co。\n\n## aco_exit\n\n```c\nvoid aco_exit();\n```\n\n除了与`aco_yield()`一样的功能之外，`aco_exit()`会另外设置`co->is_end`为1，以标志`co`的状态为 \"end\" 。\n\n## aco_destroy\n\n```c\nvoid aco_destroy(aco_t* co);\n```\n\n销毁协程`co`。入参`co`必须非NULL。如果`co`是一个non-main co，此API也会同时销毁`co`的私有保存栈。\n\n## MACROS\n\n### Version\n\n```c\n#define ACO_VERSION_MAJOR 1\n#define ACO_VERSION_MINOR 2\n#define ACO_VERSION_PATCH 2\n```\n\n这三个关于libaco版本值的宏定义在头文件`aco.h`中，它们的值遵守标准：[Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html)。\n\n### aco_assert_override.h\n\n```c\n// provide the compiler with branch prediction information\n#define likely(x)               aco_likely(x)\n#define unlikely(x)             aco_unlikely(x)\n\n// override the default `assert` for convenience when coding\n#define assert(EX)              aco_assert(EX)\n\n// equal to `assert((ptr) != NULL)`\n#define assertptr(ptr)          aco_assertptr(ptr)\n\n// assert the successful return of memory allocation\n#define assertalloc_bool(b)     aco_assertalloc_bool(b)\n#define assertalloc_ptr(ptr)    aco_assertalloc_ptr(ptr)\n```\n\n像源文件[test_aco_synopsis.c](test_aco_synopsis.c) 所做的那样，用户可以选择在自己的应用源码中include头文件`\"aco_assert_override.h\"`来替换掉C默认的 \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" 以及定义除了`assert`之外的其它五个宏（如上所示）。因为C的 \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" 也是一个宏定义，所以在include头文件 `\"aco_assert_override.h\"` 时，应该将它放到源文件中所有include指令中的最后一个。如果在一个源文件中，用户想要在某个源文件中使用默认的C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\"，请不要在其中include这个头文件。\n\n阅读源文件[aco_assert_override.h](aco_assert_override.h)以获得关于此的更多信息。\n\n# Benchmark\n\nDate: Sat Jun 30 UTC 2018.\n\nMachine: [c5d.large on AWS](https://aws.amazon.com/cn/blogs/aws/now-available-compute-intensive-c5-instances-for-amazon-ec2/).\n\nOS: RHEL-7.5 (Red Hat Enterprise Linux 7.5).\n\n下面是关于性能测试部分的一个摘要描述：\n\n* 一次协程间上下文切换仅耗时 **10.29 ns** （协程拥有独立的运行栈，并且协程间共享FPU与MXCSR控制字配置的情况下）；\n* 一次协程间上下文切换仅耗时 **10.38 ns** （协程拥有独立的运行栈,并且各协程均维护一份属于各自的FPU与MXCSR控制字配置的情况下）；\n* 极致的内存使用率：一千万个协程并发执行仅消耗2.8GB的物理内存（tcmalloc，每一个协程使用120B的复制栈）。\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.shareFPUenv\n\n+build:x86_64\n+build:-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:share fpu & mxcsr control words between coroutines\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=152:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      230.00 ns/op    4347824.79 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.59 ns/op   48576413.55 op/s\n  -> acosw                                            40000000     0.412 s       10.29 ns/op   97152827.10 op/s\naco_destroy                                                  1     0.000 s      650.00 ns/op    1538461.66 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      200.00 ns/op    5000001.72 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.61 ns/op   48525164.25 op/s\n  -> acosw                                            40000000     0.412 s       10.30 ns/op   97050328.50 op/s\naco_destroy                                                  1     0.000 s      666.00 ns/op    1501501.49 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.50 ns/op   15266771.53 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.666 s       33.29 ns/op   30043022.64 op/s\naco_destroy                                            2000000     0.066 s       32.87 ns/op   30425152.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.130 s       65.22 ns/op   15332218.24 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.75 ns/op   29630018.73 op/s\naco_destroy                                            2000000     0.067 s       33.45 ns/op   29898311.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.42 ns/op   15286937.97 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.669 s       33.45 ns/op   29891277.59 op/s\naco_destroy                                            2000000     0.080 s       39.87 ns/op   25084242.29 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.224 s      111.86 ns/op    8940010.49 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.678 s       33.88 ns/op   29515473.53 op/s\naco_destroy                                            2000000     0.067 s       33.42 ns/op   29922412.68 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.74 ns/op   15211896.70 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.45 ns/op   26010724.94 op/s\naco_destroy                                            2000000     0.088 s       44.11 ns/op   22669240.25 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.240 s      123.97 ns/op    8066542.54 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.17 ns/op   30143409.55 op/s\naco_destroy                                           10000000     0.328 s       32.82 ns/op   30467658.05 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.659 s       65.94 ns/op   15165717.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.345 s       33.63 ns/op   29737708.53 op/s\naco_destroy                                           10000000     0.337 s       33.71 ns/op   29666697.09 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.654 s       65.38 ns/op   15296191.35 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.348 s       33.71 ns/op   29663992.77 op/s\naco_destroy                                           10000000     0.336 s       33.56 ns/op   29794574.96 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.653 s       65.29 ns/op   15316087.09 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.384 s       34.60 ns/op   28902221.24 op/s\naco_destroy                                           10000000     0.337 s       33.73 ns/op   29643682.93 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.652 s       65.19 ns/op   15340872.40 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.565 s       39.11 ns/op   25566255.73 op/s\naco_destroy                                           10000000     0.443 s       44.30 ns/op   22574242.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241722.94 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.947 s       47.36 ns/op   21114212.05 op/s\naco_destroy                                            2000000     0.125 s       62.35 ns/op   16039466.45 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.71 ns/op   15218784.72 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.948 s       47.39 ns/op   21101216.29 op/s\naco_destroy                                            2000000     0.125 s       62.73 ns/op   15941559.26 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.49 ns/op   15270258.18 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.069 s       53.44 ns/op   18714275.17 op/s\naco_destroy                                            2000000     0.122 s       61.05 ns/op   16378678.85 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.91 ns/op   15171336.62 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.190 s       59.48 ns/op   16813230.99 op/s\naco_destroy                                            2000000     0.123 s       61.26 ns/op   16324298.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.68 ns/op   15224361.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.828 s       91.40 ns/op   10941133.56 op/s\naco_destroy                                            2000000     0.145 s       72.56 ns/op   13781182.82 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.80 ns/op   15197461.34 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.829 s       91.47 ns/op   10932139.32 op/s\naco_destroy                                            2000000     0.149 s       74.70 ns/op   13387258.82 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.63 ns/op   15007426.35 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.224 s      211.20 ns/op    4734744.76 op/s\naco_destroy                                            1000000     0.093 s       93.36 ns/op   10711651.49 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.28 ns/op   15086953.73 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.222 s      211.12 ns/op    4736537.93 op/s\naco_destroy                                            1000000     0.094 s       94.09 ns/op   10627664.78 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.72 ns/op   14139923.59 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.191 s      209.56 ns/op    4771909.70 op/s\naco_destroy                                             100000     0.010 s      101.21 ns/op    9880747.28 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.62 ns/op   15010433.00 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.002 s      350.11 ns/op    2856228.03 op/s\naco_destroy                                             100000     0.016 s      159.69 ns/op    6262129.35 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.76 ns/op   15205994.08 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.918 s      595.90 ns/op    1678127.54 op/s\naco_destroy                                             100000     0.019 s      186.32 ns/op    5367189.85 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.03 ns/op   15865531.37 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917079.11 op/s\naco_destroy                                             100000     0.038 s      378.33 ns/op    2643225.42 op/s\n```\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.standaloneFPUenv\n\n+build:x86_64\n+build:undefined ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:each coroutine maintain each own fpu & mxcsr control words\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=160:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      273.00 ns/op    3663004.27 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.76 ns/op   48173877.75 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96347755.51 op/s\naco_destroy                                                  1     0.000 s      381.00 ns/op    2624672.26 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      212.00 ns/op    4716980.43 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.75 ns/op   48185455.26 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96370910.51 op/s\naco_destroy                                                  1     0.000 s      174.00 ns/op    5747123.38 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.63 ns/op   15237386.02 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.664 s       33.20 ns/op   30119155.82 op/s\naco_destroy                                            2000000     0.065 s       32.67 ns/op   30604542.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.33 ns/op   15305975.29 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.74 ns/op   29638360.61 op/s\naco_destroy                                            2000000     0.067 s       33.31 ns/op   30016633.42 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241767.78 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.678 s       33.88 ns/op   29518648.08 op/s\naco_destroy                                            2000000     0.079 s       39.74 ns/op   25163018.30 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.221 s      110.73 ns/op    9030660.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.684 s       34.18 ns/op   29253416.65 op/s\naco_destroy                                            2000000     0.067 s       33.40 ns/op   29938840.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.60 ns/op   15244077.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.43 ns/op   26021228.41 op/s\naco_destroy                                            2000000     0.087 s       43.74 ns/op   22863987.42 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.251 s      125.08 ns/op    7994958.59 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.19 ns/op   30133654.80 op/s\naco_destroy                                           10000000     0.329 s       32.85 ns/op   30439787.32 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.674 s       67.37 ns/op   14843796.57 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.354 s       33.84 ns/op   29548523.05 op/s\naco_destroy                                           10000000     0.339 s       33.90 ns/op   29494634.83 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.19 ns/op   14882262.88 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.361 s       34.02 ns/op   29393520.19 op/s\naco_destroy                                           10000000     0.338 s       33.77 ns/op   29609577.59 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.673 s       67.31 ns/op   14857716.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.371 s       34.27 ns/op   29181897.80 op/s\naco_destroy                                           10000000     0.339 s       33.85 ns/op   29540633.63 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.24 ns/op   14873017.10 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.548 s       38.71 ns/op   25835542.17 op/s\naco_destroy                                           10000000     0.446 s       44.61 ns/op   22415961.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.01 ns/op   15148290.52 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.22 ns/op   21177946.19 op/s\naco_destroy                                            2000000     0.124 s       61.99 ns/op   16132721.97 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.36 ns/op   15068860.85 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.20 ns/op   21187541.38 op/s\naco_destroy                                            2000000     0.124 s       62.21 ns/op   16073322.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.62 ns/op   15238955.93 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.072 s       53.61 ns/op   18652789.74 op/s\naco_destroy                                            2000000     0.121 s       60.42 ns/op   16551368.04 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.08 ns/op   15132547.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.198 s       59.88 ns/op   16699389.91 op/s\naco_destroy                                            2000000     0.121 s       60.71 ns/op   16471465.52 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.50 ns/op   15036985.95 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.853 s       92.63 ns/op   10796126.04 op/s\naco_destroy                                            2000000     0.146 s       72.87 ns/op   13723559.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.14 ns/op   15118324.13 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.855 s       92.75 ns/op   10781572.22 op/s\naco_destroy                                            2000000     0.152 s       75.79 ns/op   13194130.51 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.97 ns/op   14931921.56 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.218 s      210.90 ns/op    4741536.66 op/s\naco_destroy                                            1000000     0.093 s       93.16 ns/op   10734691.98 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.49 ns/op   15039274.31 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.216 s      210.81 ns/op    4743543.53 op/s\naco_destroy                                            1000000     0.094 s       93.97 ns/op   10641539.58 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.95 ns/op   14094724.73 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.190 s      209.52 ns/op    4772746.50 op/s\naco_destroy                                             100000     0.010 s      100.99 ns/op    9902271.51 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.49 ns/op   15040038.84 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.028 s      351.38 ns/op    2845942.55 op/s\naco_destroy                                             100000     0.016 s      159.15 ns/op    6283444.42 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.73 ns/op   15214482.36 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.879 s      593.95 ns/op    1683636.60 op/s\naco_destroy                                             100000     0.018 s      184.23 ns/op    5428119.00 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.41 ns/op   15771072.16 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917081.56 op/s\naco_destroy                                             100000     0.038 s      376.78 ns/op    2654073.13 op/s\n```\n\n# Proof of Correctness\n\n首先，在开始实现或者证明一个协程库之前，必备的条件是要对[Sys V ABI of intel386 and x86-64](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)标准非常的熟悉，以及一些基础的汇编知识。\n\n接下来的证明中并没有包含关于IP（指令指针），SP（堆栈指针）和协程的私有保存栈与共享执行栈之间的保存与恢复的直接描述，因为相比于ABI约束的保证，这些东西是相当微不足道且容易实现和理解的。\n\n## Running Model\n\n在一个OS线程中，主协程`main_co`是被第一个创建并且是在所有其他non-main coroutine之前就已经开始运行了的协程。\n\n下图是协程main co与co之间上下文切换的简单图示。\n\n在这个证明中，我们假定我们的二进制程序要满足Sys V ABI intel386标准，因为Sys V ABI intel386与Sys V ABI x86-64之间没有根本的不同。为了简化描述，我们还假定二进制程序中没有会更改FPU或MXCSR控制字的代码存在。\n\n![proof_0](img/proof_0.png)\n\n下图实际上是对称协程的运行模型图（拥有不限量个non-main co和一个main co）。因为非对称协程仅仅是对称协程的一种特殊情况，所以我们如果证明了对称协程的正确性也就等于证明了非对称协程的正确性，如此会多些挑战性同时也会多些乐趣（libaco当前只实现了非对称协程的API，因为非对称协程的API语义远远比对称协程的API语义更容易理解和掌控）。\n\n![proof_1](img/proof_1.png)\n\n因为main co是在当前OS线程中第一个开始运行的协程，那么第一次协程间上下文切换一定是以`acosw(main_co, co)`这种形式存在的（这里，`acosw`的第二个入参`co`是一个non-main co）。\n\n## Mathematical Induction\n\n容易证明，在上图中只存在两类协程间的状态迁移：\n\n* yielded state co → init state co\n* yielded state co → yielded state co\n\n要证明协程上下文切换函数`void* acosw(aco_t* from_co, aco_t* to_co)`的正确性，就等于要证明所有的协程在调用`acosw`前后都一直满足Sys V ABI规范的约束。我们假定协程中除了`acosw`之外的所有二进制均已经满足了ABI规范（它们一般是由编译器正确地生成的）。\n\n下面是Sys V ABI Intel386函数调用约定中寄存器用法的总结：\n\n```\nRegisters' usage in the calling convention of the Intel386 System V ABI:\n    caller saved (scratch) registers:\n        C1.0: EAX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                hold the return value for `acosw`\n        C1.1: ECX,EDX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.2: Arithmetic flags, x87 and mxcsr flags\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.3: ST(0-7)\n            At the entry of a function call:\n                the stack of FPU must be empty\n            After the return of `acosw`:\n                the stack of FPU must be empty\n        C1.4: Direction flag\n            At the entry of a function call:\n                DF must be 0\n            After the return of `acosw`:\n                DF must be 0\n        C1.5: others: xmm*,ymm*,mm*,k*...\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n    callee saved registers:\n        C2.0: EBX,ESI,EDI,EBP\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                must be the same as it is at the entry of `acosw` \n        C2.1: ESP\n            At the entry of a function call:\n                must be a valid stack pointer\n                (alignment of 16 bytes, retaddr and etc...)\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw`\n        C2.2: control word of FPU & mxcsr\n            At the entry of a function call:\n                could be any configuration\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw` \n                (unless the caller of `acosw` assume `acosw` may    \\\n                change the control words of FPU or MXCSR on purpose \\\n                like `fesetenv`)\n```\n\n（对于Intel386，寄存器的用途定义在[Sys V ABI Intel386 V1.1](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)的 \"P13 - Table 2.3: Register Usage\" 表中，对于AMD64则定义在[Sys V ABI AMD64 V1.0](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)的 \"P23 - Figure 3.4: Register Usage\" 的图中。）\n\n**Proof:**\n\n1. yielded state co -> init state co:\n\n![proof_2](img/proof_2.png)\n\n上图详细地描绘了第一类状态迁移的过程： \"yielded state co -> init state co\" .\n\n约束: C 1.0, 1.1, 1.2, 1.5 (*满足* ✓ )\n\n下面列出的Scratch Registers在一个函数的入口点时其值可以为任意值：\n\n```\nEAX,ECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\n约束: C 1.3, 1.4 (*满足* ✓ )\n\n由于在`acosw`被调用之前，FPU栈必然已空并且DF必然已为0（因为协程co的二进制代码已经满足ABI规范），所以，`acosw`满足约束C1.3和1.4。\n\n约束: C 2.0, 2.1, 2.2 (*满足* ✓ )\n\n约束C2.0和2.1已经被满足。由于我们已假定FPU与MXCSR的控制字在程序运行过程中不会被更改，所以约束C2.2也已经被`acosw`满足。\n\n2. yielded state co -> yielded state co:\n\n![proof_3](img/proof_3.png)\n\n上图详细地描绘了第二类状态迁移的过程： yielded state co -> yielded state co.\n\n约束: C 1.0 (*满足* ✓ )\n\n很显然，当`acosw`返回到to_co时EAX中已经保存了预期的返回值。\n\n约束: C 1.1, 1.2, 1.5 (*满足* ✓ )\n\n下面列出的Scratch Registers在一个函数的入口点时以及在`acosw`返回后其值皆可为任意值：\n\n```\nECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\n约束: C 1.3, 1.4 (*满足* ✓ )\n\n由于在`acosw`被调用之前，FPU栈必然已空并且DF必然已为0（因为协程co的二进制代码已经满足ABI规范），所以，`acosw`满足约束C1.3和1.4。\n\n约束: C 2.0, 2.1, 2.2 (*满足* ✓ )\n\n从`acosw`调用者的角度来看，由于在`acosw`被调用（或返回）时，所有的callee saved registers都做了对应的保存（或恢复）工作，则约束C2.0与2.1被`acosw`满足。由于我们已假定FPU与MXCSR的控制字在程序运行过程中不会被更改，所以约束C2.2也已经被`acosw`满足。\n\n3. Mathematical induction:\n\n显然，在当前OS线程中，第一次`acosw`必然属于第一类状态迁移：yielded state co -> init state co，并且接下来的所有`acosw`必然属于这两类状态迁移的其中一类。顺序地用上面得到两个结论依次证明，最终得到“所有的协程在调用`acosw`前后都一直满足Sys V ABI规范的约束”结论。如此，证明结束。\n\n## Miscellaneous\n\n### Red Zone\n\n在System V ABI x86-64中描述[red zone](https://en.wikipedia.org/wiki/Red_zone_(computing))的概念：\n\n> The 128-byte area beyond the location pointed to by %rsp is considered to be reserved and shall not be modified by signal or interrupt handlers. Therefore, functions may use this area for temporary data that is not needed across function calls. In particular, leaf functions may use this area for their entire stack frame, rather than adjusting the stack pointer in the prologue and epilogue. This area is known as the red zone.\n\n由于red zone \"not preserved by the callee\" ，所以我们在协程的上下文切换的实现中无需考虑它（因为`acosw`是一个叶子函数，即leaf function）。\n\n### Stack Pointer\n\n> The end of the input argument area shall be aligned on a 16 (32 or 64, if \\_\\_m256 or \\_\\_m512 is passed on stack) byte boundary. In other words, the value (%esp + 4) is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, %esp, always points to the end of the latest allocated stack frame.\n>\n> — Intel386-psABI-1.1:2.2.2 The Stack Frame\n\n> The stack pointer, %rsp, always points to the end of the latest allocated stack frame.\n>\n> — Sys V ABI AMD64 Version 1.0:3.2.2 The Stack Frame\n\n这是腾讯libco中的一个[bug](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27)。ABI规范中规定用户空间程序的栈指针必须时刻指到运行栈的[栈顶](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88#%E6%93%8D%E4%BD%9C)，而[coctx_swap.S](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27)中却使用栈指针直接对位于堆中的数据结构进行寻址内存操作，这违反了ABI约定。\n\n>**By default, the signal handler  is invoked  on  the normal process stack.**  It is possible to arrange that the signal handler uses an alternate stack; see sigalstack(2)  for  a discussion of how to do this and when it might be useful.\n>\n>— man 7 signal : Signal dispositions\n\n当coctx_swap正在用栈指针对位于堆中的数据结构进行寻址内存操作时，若此时执行线程收到了一个信号，接着内核抢占了该执行线程并开始准备接下来用户空间线程的信号处理执行环境，由于在默认情况下，内核将会选择主栈作为信号处理函数的执行栈，但此时栈已经被指向了堆中（用户空间的程序违反ABI约定在先），那么信号处理函数的执行栈就会被错误的放置到堆中，这样，堆中的数据结构在接下来就极有可能会被破坏(更详细的bug复现请参见此[issue](https://github.com/Tencent/libco/issues/90))。\n\n# Best Practice\n\n总的来说，如果你想把libaco的性能发挥到极致，一定要保证 \"non-standalone non-main co\" 在调用`aco_yield`时的执行栈使用尽可能的小。另外，当你想把一个协程的局部变量的地址传递到另一个协程时一定要非常小心，因为如果这个变量是在共享栈上时，将可能会发生内存数据混乱，因此，总是从堆中分配需要在协程间共享的内存是一个非常明智的选择。\n\n详细地说，有五点建议：\n\n```\n       co_fp \n       /  \\\n      /    \\  \n    f1     f2\n   /  \\    / \\\n  /    \\  f4  \\\nyield  f3     f5\n```\n\n1. Main co的执行栈使用大小对协程间上下文切换的性能没有直接影响（因为main co独占了线程的默认执行栈）；\n\n2. Standalone non-main co的执行栈使用大小对协程间上下文切换的性能没有直接影响（因为它独占了一个执行栈）。但是创建海量的standalone non-main co将会消耗海量的虚拟内存（因为海量执行栈的创建），因此，应用中并不推荐在一个线程中创建海量的standalone non-main co；\n\n3. Non-standalone non-main co（与其他协程共享执行栈的非主协程）在调用`aco_yield`时执行栈的使用大小将会对协程间上下文切换的性能产生直接的影响，性能测试部分已经清楚的展示了这一点。在上图中，函数f2，f3，f4与f5的栈使用量对上下文切换的性能没有影响，这是因为在它们执行的过程中并没有`aco_yield`函数的来中断它们。然而，函数co_fp与f1的栈使用量之和将会决定`co->save_stack.max_cpsz`（协程运行期间私有保存栈的最大保存大小）的值，同时会对上下文切换的性能产生直接的影响；\n\n让一个函数拥有尽可能低的栈使用量的关键是尽可能地从堆中分配局部变量（尤其是占用内存较大的变量）并手动地管理它们的生命周期（malloc/free），而非默认地从堆栈上分配和自动释放它们。C编译器gcc的选项`-fstack-usage`对此非常有用。\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int ct = 0;\n    gl_ptr = &ct; // line 7\n    aco_yield();\n    check(ct);\n    int* ptr = &ct;\n    inc_p(ptr);   // line 11\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr); // line 16\n    aco_exit();\n}\n```\n\n4. 在上面的代码片段中，我们假定协程co_fp0与co_fp1共享同一个执行栈，它们均是non-main co，它们的执行顺序为 \"co_fp0 -> co_fp1 -> co_fp0\" 。因为它们共享同一个执行栈，在代码第16行`gl_ptr`中的指针值与代码第7行`gl_ptr`中的指针值二者的语义是不同的，这样的用法很可能会破坏协程co_fp1的执行栈。而代码第11行则是正确的，因为此时局部变量`ct`与函数`inc_p`的执行是在同一个协程上下文中的。从堆中分配需要在协程间共享的内存能够很简单地解决这类问题：\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int* ct_ptr = malloc(sizeof(int));\n    assert(ct_ptr != NULL);\n    *ct_ptr = 0;\n    gl_ptr = ct_ptr;\n    aco_yield();\n    check(*ct_ptr);\n    int* ptr = ct_ptr;\n    inc_p(ptr);\n    free(ct_ptr);\n    gl_ptr = NULL;\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr);\n    aco_exit();\n}\n```\n\n# TODO\n\nNew ideas are welcome!\n\n* Add a macro `aco_new` which is the combination of something like `p = malloc(sz); assertalloc_ptr(p)`.\n\n* Add a new API `aco_reset` to support the reusability of the coroutine objects.\n\n* Support other platforms (especially arm & arm64).\n\n# CHANGES\n\n```\nv1.2.2 Mon Jul 9 2018\n    Added a new option `-o <no-m32|no-valgrind>` to make.sh;\n    Correction about the value of macro ACO_VERSION_PATCH (issue #1 \n    kindly reported by Markus Elfring @elfring);\n    Adjusted some noncompliant naming of identifiers (double underscore\n    `__`) (issue #1, kindly proposed by Markus Elfring @elfring);\n    Supported the header file including by C++ (issue #4, kindly\n    proposed by Markus Elfring @elfring).\nv1.2.1 Sat Jul 7 2018\n    Fixed some noncompliant include guards in two C header files (\n    issue #1 kindly reported by Markus Elfring @elfring);\n    Removed the \"pure\" word from \"pure C\" statement since it is\n    containing assembly codes (kindly reported by Peter Cawley\n    @corsix);\n    Many updates in the README.md document.\nv1.2.0 Tue Jul 3 2018\n    Provided another header named `aco_assert_override.h` so user\n    could choose to override the default `assert` or not;\n    Added some macros about the version information.\nv1.1   Mon Jul 2 2018\n    Removed the requirement on the GCC version (>= 5.0).\nv1.0   Sun Jul 1 2018\n    The v1.0 release of libaco, cheers 🎉🎉🎉\n```\n\n# Donation\n\n我是一位自由的全职开源项目开发者，任何数量的捐赠对我都将会是莫大的鼓励 ;-)\n\n* Paypal\n\n  [paypal.me link](https://www.paypal.me/00hnes)\n\n* Alipay (支付(宝|寶))\n\n![qr_alipay](img/qr_alipay.png)\n\n* Wechat (微信)\n\n![qr_wechat](img/qr_wechat.png)\n\n# Copyright and License\n\nCopyright (C) 2018, by Sen Han [<00hnes@gmail.com>](mailto:00hnes@gmail.com).\n\nUnder the Apache License, Version 2.0.\n\nSee the [LICENSE](LICENSE) file for details.\n"
        },
        {
          "name": "aco.c",
          "type": "blob",
          "size": 17.080078125,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#define _GNU_SOURCE\n\n#include \"aco.h\"\n#include <stdio.h>\n#include <stdint.h>\n\n// this header including should be at the last of the `include` directives list\n#include \"aco_assert_override.h\"\n\nvoid aco_runtime_test(void){\n#ifdef __i386__\n    _Static_assert(sizeof(void*) == 4, \"require 'sizeof(void*) == 4'\");\n#elif  __x86_64__\n    _Static_assert(sizeof(void*) == 8, \"require 'sizeof(void*) == 8'\");\n    _Static_assert(sizeof(__uint128_t) == 16, \"require 'sizeof(__uint128_t) == 16'\");\n#else\n    #error \"platform no support yet\"\n#endif\n    _Static_assert(sizeof(int) >= 4, \"require 'sizeof(int) >= 4'\");\n    assert(sizeof(int) >= 4);\n    _Static_assert(sizeof(int) <= sizeof(size_t),\n        \"require 'sizeof(int) <= sizeof(size_t)'\");\n    assert(sizeof(int) <= sizeof(size_t));\n}\n\n// assertptr(dst); assertptr(src);\n// assert((((uintptr_t)(src) & 0x0f) == 0) && (((uintptr_t)(dst) & 0x0f) == 0));\n// assert((((sz) & 0x0f) == 0x08) && (((sz) >> 4) >= 0) && (((sz) >> 4) <= 8));\n// sz = 16*n + 8 ( 0 <= n <= 8)\n\n// Note: dst and src must be valid address already\n#define aco_amd64_inline_short_aligned_memcpy_test_ok(dst, src, sz) \\\n    (   \\\n        (((uintptr_t)(src) & 0x0f) == 0) && (((uintptr_t)(dst) & 0x0f) == 0) \\\n        &&  \\\n        (((sz) & 0x0f) == 0x08) && (((sz) >> 4) >= 0) && (((sz) >> 4) <= 8) \\\n    )\n\n#define aco_amd64_inline_short_aligned_memcpy(dst, src, sz) do {\\\n    __uint128_t xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7; \\\n    switch((sz) >> 4){ \\\n    case 0:  \\\n        break;  \\\n    case 1:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        break;  \\\n    case 2:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        break;  \\\n    case 3:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        break;  \\\n    case 4:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        break;  \\\n    case 5:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        break;  \\\n    case 6:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        xmm5 = *((__uint128_t*)(src) + 5);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        *((__uint128_t*)(dst) + 5) = xmm5; \\\n        break;  \\\n    case 7:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        xmm5 = *((__uint128_t*)(src) + 5);  \\\n        xmm6 = *((__uint128_t*)(src) + 6);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        *((__uint128_t*)(dst) + 5) = xmm5; \\\n        *((__uint128_t*)(dst) + 6) = xmm6; \\\n        break;  \\\n    case 8:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        xmm5 = *((__uint128_t*)(src) + 5);  \\\n        xmm6 = *((__uint128_t*)(src) + 6);  \\\n        xmm7 = *((__uint128_t*)(src) + 7);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        *((__uint128_t*)(dst) + 5) = xmm5; \\\n        *((__uint128_t*)(dst) + 6) = xmm6; \\\n        *((__uint128_t*)(dst) + 7) = xmm7; \\\n        break;  \\\n    }\\\n    *((uint64_t*)((uintptr_t)(dst) + (sz) - 8)) = *((uint64_t*)((uintptr_t)(src) + (sz) - 8)); \\\n} while(0)\n\n// Note: dst and src must be valid address already\n#define aco_amd64_optimized_memcpy_drop_in(dst, src, sz) do {\\\n    if(aco_amd64_inline_short_aligned_memcpy_test_ok((dst), (src), (sz))){ \\\n        aco_amd64_inline_short_aligned_memcpy((dst), (src), (sz)); \\\n    }else{ \\\n        memcpy((dst), (src), (sz)); \\\n    } \\\n} while(0)\n\nstatic void aco_default_protector_last_word(void){\n    aco_t* co = aco_get_co();\n    // do some log about the offending `co`\n    fprintf(stderr,\"error: aco_default_protector_last_word triggered\\n\");\n    fprintf(stderr, \"error: co:%p should call `aco_exit()` instead of direct \"\n        \"`return` in co_fp:%p to finish its execution\\n\", co, (void*)co->fp);\n    assert(0);\n}\n\n// aco's Global Thread Local Storage variable `co`\n__thread aco_t* aco_gtls_co;\nstatic __thread aco_cofuncp_t aco_gtls_last_word_fp = aco_default_protector_last_word;\n\n#ifdef __i386__\n    static __thread void* aco_gtls_fpucw_mxcsr[2];\n#elif  __x86_64__\n    static __thread void* aco_gtls_fpucw_mxcsr[1];\n#else\n    #error \"platform no support yet\"\n#endif\n\nvoid aco_thread_init(aco_cofuncp_t last_word_co_fp){\n    aco_save_fpucw_mxcsr(aco_gtls_fpucw_mxcsr);\n\n    if((void*)last_word_co_fp != NULL)\n        aco_gtls_last_word_fp = last_word_co_fp;\n}\n\n// This function `aco_funcp_protector` should never be\n// called. If it's been called, that means the offending\n// `co` didn't call aco_exit(co) instead of `return` to\n// finish its execution.\nvoid aco_funcp_protector(void){\n    if((void*)(aco_gtls_last_word_fp) != NULL){\n        aco_gtls_last_word_fp();\n    }else{\n        aco_default_protector_last_word();\n    }\n    assert(0);\n}\n\naco_share_stack_t* aco_share_stack_new(size_t sz){\n    return aco_share_stack_new2(sz, 1);\n}\n\n#define aco_size_t_safe_add_assert(a,b) do {   \\\n    assert((a)+(b) >= (a)); \\\n}while(0)\n\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled){\n    if(sz == 0){\n        sz = 1024 * 1024 * 2;\n    }\n    if(sz < 4096){\n        sz = 4096;\n    }\n    assert(sz > 0);\n\n    size_t u_pgsz = 0;\n    if(guard_page_enabled != 0){\n        // although gcc's Built-in Functions to Perform Arithmetic with\n        // Overflow Checking is better, but it would require gcc >= 5.0\n        long pgsz = sysconf(_SC_PAGESIZE);\n        // pgsz must be > 0 && a power of two\n        assert(pgsz > 0 && (((pgsz - 1) & pgsz) == 0));\n        u_pgsz = (size_t)((unsigned long)pgsz);\n        // it should be always true in real life\n        assert(u_pgsz == (unsigned long)pgsz && ((u_pgsz << 1) >> 1) == u_pgsz);\n        if(sz <= u_pgsz){\n            sz = u_pgsz << 1;\n        } else {\n            size_t new_sz;\n            if((sz & (u_pgsz - 1)) != 0){\n                new_sz = (sz & (~(u_pgsz - 1)));\n                assert(new_sz >= u_pgsz);\n                aco_size_t_safe_add_assert(new_sz, (u_pgsz << 1));\n                new_sz = new_sz + (u_pgsz << 1);\n                assert(sz / u_pgsz + 2 == new_sz / u_pgsz);\n            } else {\n                aco_size_t_safe_add_assert(sz, u_pgsz);\n                new_sz = sz + u_pgsz;\n                assert(sz / u_pgsz + 1 == new_sz / u_pgsz);\n            }\n            sz = new_sz;\n            assert((sz / u_pgsz > 1) && ((sz & (u_pgsz - 1)) == 0));\n        }\n    }\n\n    aco_share_stack_t* p = (aco_share_stack_t*)malloc(sizeof(aco_share_stack_t));\n    assertalloc_ptr(p);\n    memset(p, 0, sizeof(aco_share_stack_t));\n\n    if(guard_page_enabled != 0){\n        p->real_ptr = mmap(\n            NULL, sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0\n        );\n        assertalloc_bool(p->real_ptr != MAP_FAILED);\n        p->guard_page_enabled = 1;\n        assert(0 == mprotect(p->real_ptr, u_pgsz, PROT_READ));\n\n        p->ptr = (void*)(((uintptr_t)p->real_ptr) + u_pgsz);\n        p->real_sz = sz;\n        assert(sz >= (u_pgsz << 1));\n        p->sz = sz - u_pgsz;\n    } else {\n        //p->guard_page_enabled = 0;\n        p->sz = sz;\n        p->ptr = malloc(sz);\n        assertalloc_ptr(p->ptr);\n    }\n\n    p->owner = NULL;\n#ifdef ACO_USE_VALGRIND\n    p->valgrind_stk_id = VALGRIND_STACK_REGISTER(\n        p->ptr, (void*)((uintptr_t)p->ptr + p->sz)\n    );\n#endif\n#if defined(__i386__) || defined(__x86_64__)\n    uintptr_t u_p = (uintptr_t)(p->sz - (sizeof(void*) << 1) + (uintptr_t)p->ptr);\n    u_p = (u_p >> 4) << 4;\n    p->align_highptr = (void*)u_p;\n    p->align_retptr  = (void*)(u_p - sizeof(void*));\n    *((void**)(p->align_retptr)) = (void*)(aco_funcp_protector_asm);\n    assert(p->sz > (16 + (sizeof(void*) << 1) + sizeof(void*)));\n    p->align_limit = p->sz - 16 - (sizeof(void*) << 1);\n#else\n    #error \"platform no support yet\"\n#endif\n    return p;\n}\n\nvoid aco_share_stack_destroy(aco_share_stack_t* sstk){\n    assert(sstk != NULL && sstk->ptr != NULL);\n#ifdef ACO_USE_VALGRIND\n    VALGRIND_STACK_DEREGISTER(sstk->valgrind_stk_id);\n#endif\n    if(sstk->guard_page_enabled){\n        assert(0 == munmap(sstk->real_ptr, sstk->real_sz));\n        sstk->real_ptr = NULL;\n        sstk->ptr = NULL;\n    } else {\n        free(sstk->ptr);\n        sstk->ptr = NULL;\n    }\n    free(sstk);\n}\n\naco_t* aco_create(\n        aco_t* main_co, aco_share_stack_t* share_stack,\n        size_t save_stack_sz, aco_cofuncp_t fp, void* arg\n    ){\n\n    aco_t* p = (aco_t*)malloc(sizeof(aco_t));\n    assertalloc_ptr(p);\n    memset(p, 0, sizeof(aco_t));\n\n    if(main_co != NULL){ // non-main co\n        assertptr(share_stack);\n        p->share_stack = share_stack;\n#ifdef __i386__\n        // POSIX.1-2008 (IEEE Std 1003.1-2008) - General Information - Data Types - Pointer Types\n        // http://pubs.opengroup.org/onlinepubs/9699919799.2008edition/functions/V2_chap02.html#tag_15_12_03\n        p->reg[ACO_REG_IDX_RETADDR] = (void*)fp;\n        // push retaddr\n        p->reg[ACO_REG_IDX_SP] = p->share_stack->align_retptr;\n        #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n            p->reg[ACO_REG_IDX_FPU] = aco_gtls_fpucw_mxcsr[0];\n            p->reg[ACO_REG_IDX_FPU + 1] = aco_gtls_fpucw_mxcsr[1];\n        #endif\n#elif  __x86_64__\n        p->reg[ACO_REG_IDX_RETADDR] = (void*)fp;\n        p->reg[ACO_REG_IDX_SP] = p->share_stack->align_retptr;\n        #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n            p->reg[ACO_REG_IDX_FPU] = aco_gtls_fpucw_mxcsr[0];\n        #endif\n#else\n        #error \"platform no support yet\"\n#endif\n        p->main_co = main_co;\n        p->arg = arg;\n        p->fp = fp;\n        if(save_stack_sz == 0){\n            save_stack_sz = 64;\n        }\n        p->save_stack.ptr = malloc(save_stack_sz);\n        assertalloc_ptr(p->save_stack.ptr);\n        p->save_stack.sz = save_stack_sz;\n#if defined(__i386__) || defined(__x86_64__)\n        p->save_stack.valid_sz = 0;\n#else\n        #error \"platform no support yet\"\n#endif\n        return p;\n    } else { // main co\n        p->main_co = NULL;\n        p->arg = arg;\n        p->fp = fp;\n        p->share_stack = NULL;\n        p->save_stack.ptr = NULL;\n        return p;\n    }\n    assert(0);\n}\n\naco_attr_no_asan\nvoid aco_resume(aco_t* resume_co){\n    assert(resume_co != NULL && resume_co->main_co != NULL\n        && resume_co->is_end == 0\n    );\n    if(resume_co->share_stack->owner != resume_co){\n        if(resume_co->share_stack->owner != NULL){\n            aco_t* owner_co = resume_co->share_stack->owner;\n            assert(owner_co->share_stack == resume_co->share_stack);\n#if defined(__i386__) || defined(__x86_64__)\n            assert(\n                (\n                    (uintptr_t)(owner_co->share_stack->align_retptr)\n                    >=\n                    (uintptr_t)(owner_co->reg[ACO_REG_IDX_SP])\n                )\n                &&\n                (\n                    (uintptr_t)(owner_co->share_stack->align_highptr)\n                    -\n                    (uintptr_t)(owner_co->share_stack->align_limit)\n                    <=\n                    (uintptr_t)(owner_co->reg[ACO_REG_IDX_SP])\n                )\n            );\n            owner_co->save_stack.valid_sz =\n                (uintptr_t)(owner_co->share_stack->align_retptr)\n                -\n                (uintptr_t)(owner_co->reg[ACO_REG_IDX_SP]);\n            if(owner_co->save_stack.sz < owner_co->save_stack.valid_sz){\n                free(owner_co->save_stack.ptr);\n                owner_co->save_stack.ptr = NULL;\n                while(1){\n                    owner_co->save_stack.sz = owner_co->save_stack.sz << 1;\n                    assert(owner_co->save_stack.sz > 0);\n                    if(owner_co->save_stack.sz >= owner_co->save_stack.valid_sz){\n                        break;\n                    }\n                }\n                owner_co->save_stack.ptr = malloc(owner_co->save_stack.sz);\n                assertalloc_ptr(owner_co->save_stack.ptr);\n            }\n            // TODO: optimize the performance penalty of memcpy function call\n            //   for very short memory span\n            if(owner_co->save_stack.valid_sz > 0) {\n    #ifdef __x86_64__\n                aco_amd64_optimized_memcpy_drop_in(\n                    owner_co->save_stack.ptr,\n                    owner_co->reg[ACO_REG_IDX_SP],\n                    owner_co->save_stack.valid_sz\n                );\n    #else\n                memcpy(\n                    owner_co->save_stack.ptr,\n                    owner_co->reg[ACO_REG_IDX_SP],\n                    owner_co->save_stack.valid_sz\n                );\n    #endif\n                owner_co->save_stack.ct_save++;\n            }\n            if(owner_co->save_stack.valid_sz > owner_co->save_stack.max_cpsz){\n                owner_co->save_stack.max_cpsz = owner_co->save_stack.valid_sz;\n            }\n            owner_co->share_stack->owner = NULL;\n            owner_co->share_stack->align_validsz = 0;\n#else\n            #error \"platform no support yet\"\n#endif\n        }\n        assert(resume_co->share_stack->owner == NULL);\n#if defined(__i386__) || defined(__x86_64__)\n        assert(\n            resume_co->save_stack.valid_sz\n            <=\n            resume_co->share_stack->align_limit - sizeof(void*)\n        );\n        // TODO: optimize the performance penalty of memcpy function call\n        //   for very short memory span\n        if(resume_co->save_stack.valid_sz > 0) {\n    #ifdef __x86_64__\n            aco_amd64_optimized_memcpy_drop_in(\n                (void*)(\n                    (uintptr_t)(resume_co->share_stack->align_retptr)\n                    -\n                    resume_co->save_stack.valid_sz\n                ),\n                resume_co->save_stack.ptr,\n                resume_co->save_stack.valid_sz\n            );\n    #else\n            memcpy(\n                (void*)(\n                    (uintptr_t)(resume_co->share_stack->align_retptr)\n                    -\n                    resume_co->save_stack.valid_sz\n                ),\n                resume_co->save_stack.ptr,\n                resume_co->save_stack.valid_sz\n            );\n    #endif\n            resume_co->save_stack.ct_restore++;\n        }\n        if(resume_co->save_stack.valid_sz > resume_co->save_stack.max_cpsz){\n            resume_co->save_stack.max_cpsz = resume_co->save_stack.valid_sz;\n        }\n        resume_co->share_stack->align_validsz = resume_co->save_stack.valid_sz + sizeof(void*);\n        resume_co->share_stack->owner = resume_co;\n#else\n        #error \"platform no support yet\"\n#endif\n    }\n    aco_gtls_co = resume_co;\n    acosw(resume_co->main_co, resume_co);\n    aco_gtls_co = resume_co->main_co;\n}\n\nvoid aco_destroy(aco_t* co){\n    assertptr(co);\n    if(aco_is_main_co(co)){\n        free(co);\n    } else {\n        if(co->share_stack->owner == co){\n            co->share_stack->owner = NULL;\n            co->share_stack->align_validsz = 0;\n        }\n        free(co->save_stack.ptr);\n        co->save_stack.ptr = NULL;\n        free(co);\n    }\n}\n"
        },
        {
          "name": "aco.h",
          "type": "blob",
          "size": 5.55078125,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef ACO_H\n#define ACO_H\n\n#include <string.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/mman.h>\n\n#ifdef ACO_USE_VALGRIND\n    #include <valgrind/valgrind.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ACO_VERSION_MAJOR 1\n#define ACO_VERSION_MINOR 2\n#define ACO_VERSION_PATCH 4\n\n#ifdef __i386__\n    #define ACO_REG_IDX_RETADDR 0\n    #define ACO_REG_IDX_SP 1\n    #define ACO_REG_IDX_BP 2\n    #define ACO_REG_IDX_FPU 6\n#elif __x86_64__\n    #define ACO_REG_IDX_RETADDR 4\n    #define ACO_REG_IDX_SP 5\n    #define ACO_REG_IDX_BP 7\n    #define ACO_REG_IDX_FPU 8\n#else\n    #error \"platform no support yet\"\n#endif\n\ntypedef struct {\n    void*  ptr;\n    size_t sz;\n    size_t valid_sz;\n    // max copy size in bytes\n    size_t max_cpsz;\n    // copy from share stack to this save stack\n    size_t ct_save;\n    // copy from this save stack to share stack \n    size_t ct_restore;\n} aco_save_stack_t;\n\nstruct aco_s;\ntypedef struct aco_s aco_t;\n\ntypedef struct {\n    void*  ptr;            \n    size_t sz;\n    void*  align_highptr;\n    void*  align_retptr;\n    size_t align_validsz;\n    size_t align_limit;\n    aco_t* owner;\n\n    char guard_page_enabled;\n    void* real_ptr;\n    size_t real_sz;\n\n#ifdef ACO_USE_VALGRIND\n    unsigned long valgrind_stk_id;\n#endif\n} aco_share_stack_t;\n\ntypedef void (*aco_cofuncp_t)(void);\n\nstruct aco_s{\n    // cpu registers' state\n#ifdef __i386__\n    #ifdef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n        void*  reg[6];\n    #else\n        void*  reg[8];\n    #endif\n#elif __x86_64__\n    #ifdef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n        void*  reg[8];\n    #else\n        void*  reg[9];\n    #endif\n#else\n    #error \"platform no support yet\"\n#endif\n    aco_t* main_co;\n    void*  arg;\n    char   is_end;\n\n    aco_cofuncp_t fp;\n    \n    aco_save_stack_t  save_stack;\n    aco_share_stack_t* share_stack;\n};\n\n#define aco_likely(x) (__builtin_expect(!!(x), 1))\n\n#define aco_unlikely(x) (__builtin_expect(!!(x), 0))\n\n#define aco_assert(EX)  ((aco_likely(EX))?((void)0):(abort()))\n\n#define aco_assertptr(ptr)  ((aco_likely((ptr) != NULL))?((void)0):(abort()))\n\n#define aco_assertalloc_bool(b)  do {  \\\n    if(aco_unlikely(!(b))){    \\\n        fprintf(stderr, \"Aborting: failed to allocate memory: %s:%d:%s\\n\", \\\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);    \\\n        abort();    \\\n    }   \\\n} while(0)\n\n#define aco_assertalloc_ptr(ptr)  do {  \\\n    if(aco_unlikely((ptr) == NULL)){    \\\n        fprintf(stderr, \"Aborting: failed to allocate memory: %s:%d:%s\\n\", \\\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);    \\\n        abort();    \\\n    }   \\\n} while(0)\n\n#if defined(aco_attr_no_asan)\n    #error \"aco_attr_no_asan already defined\"\n#endif\n#if defined(ACO_USE_ASAN)\n    #if defined(__has_feature)\n        #if __has_feature(__address_sanitizer__)\n            #define aco_attr_no_asan \\\n                __attribute__((__no_sanitize_address__))\n        #endif\n    #endif\n    #if defined(__SANITIZE_ADDRESS__) && !defined(aco_attr_no_asan)\n        #define aco_attr_no_asan \\\n            __attribute__((__no_sanitize_address__))\n    #endif\n#endif\n#ifndef aco_attr_no_asan\n    #define aco_attr_no_asan\n#endif\n\nextern void aco_runtime_test(void);\n\nextern void aco_thread_init(aco_cofuncp_t last_word_co_fp);\n\nextern void* acosw(aco_t* from_co, aco_t* to_co) __asm__(\"acosw\"); // asm\n\nextern void aco_save_fpucw_mxcsr(void* p) __asm__(\"aco_save_fpucw_mxcsr\");  // asm\n\nextern void aco_funcp_protector_asm(void) __asm__(\"aco_funcp_protector_asm\"); // asm\n\nextern void aco_funcp_protector(void);\n\nextern aco_share_stack_t* aco_share_stack_new(size_t sz);\n\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled);\n\nextern void aco_share_stack_destroy(aco_share_stack_t* sstk);\n\nextern aco_t* aco_create(\n        aco_t* main_co,\n        aco_share_stack_t* share_stack, \n        size_t save_stack_sz, \n        aco_cofuncp_t fp, void* arg\n    );\n\n// aco's Global Thread Local Storage variable `co`\nextern __thread aco_t* aco_gtls_co;\n\naco_attr_no_asan\nextern void aco_resume(aco_t* resume_co);\n\n//extern void aco_yield1(aco_t* yield_co);\n#define aco_yield1(yield_co) do {             \\\n    aco_assertptr((yield_co));                    \\\n    aco_assertptr((yield_co)->main_co);           \\\n    acosw((yield_co), (yield_co)->main_co);   \\\n} while(0)\n\n#define aco_yield() do {        \\\n    aco_yield1(aco_gtls_co);    \\\n} while(0)\n\n#define aco_get_arg() (aco_gtls_co->arg)\n\n#define aco_get_co() ({(void)0; aco_gtls_co;})\n\n#define aco_co() ({(void)0; aco_gtls_co;})\n\nextern void aco_destroy(aco_t* co);\n\n#define aco_is_main_co(co) ({((co)->main_co) == NULL;})\n\n#define aco_exit1(co) do {     \\\n    (co)->is_end = 1;           \\\n    aco_assert((co)->share_stack->owner == (co)); \\\n    (co)->share_stack->owner = NULL; \\\n    (co)->share_stack->align_validsz = 0; \\\n    aco_yield1((co));            \\\n    aco_assert(0);                  \\\n} while(0)\n\n#define aco_exit() do {       \\\n    aco_exit1(aco_gtls_co); \\\n} while(0)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "aco_assert_override.h",
          "type": "blob",
          "size": 1.0400390625,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef ACO_ASSERT_OVERRIDE_H\n#define ACO_ASSERT_OVERRIDE_H\n\n#include \"aco.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define likely(x)               aco_likely(x)\n#define unlikely(x)             aco_unlikely(x)\n#define assert(EX)              aco_assert(EX)\n#define assertptr(ptr)          aco_assertptr(ptr)\n#define assertalloc_bool(b)     aco_assertalloc_bool(b)\n#define assertalloc_ptr(ptr)    aco_assertalloc_ptr(ptr)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "acosw.S",
          "type": "blob",
          "size": 5.2861328125,
          "content": ".text\n.globl acosw\n#if defined(__APPLE__)\n#else\n.type  acosw, @function\n#endif\n.intel_syntax noprefix\nacosw:\n/*\n    extern void acosw(aco_t* from_co, aco_t* to_co);\n\n    struct aco_t {\n        void*  reg[X];\n        // ...\n    }\n     \n    reference:\n        https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI\n\n    pitfall:\n        http://man7.org/linux/man-pages/man7/signal.7.html\n        http://man7.org/linux/man-pages/man2/sigaltstack.2.html\n\n        > $ man 7 signal\n        > ...\n        > By default, the signal handler is invoked on the normal process \n        > stack.   It  is  possible  to arrange that the signal handler \n        > uses an alternate stack; see sigaltstack(2) for a discussion of \n        > how to do this and when it might be useful.\n        > ...\n\n        This is a BUG example: \n            https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27\n\n    proof of correctness:\n        https://github.com/hnes/libaco\n\n    mxcsr & fpu:\n        fnstcw * m2byte\n            Store FPU control word to m2byte without checking for \n            pending unmasked floating-point exceptions.\n        \n        fldcw m2byte\n            Load FPU control word from m2byte.\n\n        stmxcsr m32\n            Store contents of MXCSR register to m32\n\n        ldmxcsr m32\n            Load MXCSR register from m32.\n*/\n/*\n    0x00             -->               0xff\n    eip esp ebp edi esi ebx fpucw16 mxcsr32\n    0   4   8   c   10  14  18      1c\n*/\n#ifdef __i386__\n    mov     eax,DWORD PTR [esp+0x4]     // from_co\n    mov     edx,DWORD PTR [esp]         // retaddr\n    lea     ecx,[esp+0x4]               // esp\n    mov     DWORD PTR [eax+0x8],ebp     //<ebp\n    mov     DWORD PTR [eax+0x4],ecx     //<esp\n    mov     DWORD PTR [eax+0x0],edx     //<retaddr\n    mov     DWORD PTR [eax+0xc],edi     //<edi\n    mov     ecx,DWORD PTR [esp+0x8]     // to_co\n    mov     DWORD PTR [eax+0x10],esi    //<esi\n    mov     DWORD PTR [eax+0x14],ebx    //<ebx\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fnstcw  WORD  PTR [eax+0x18]        //<fpucw\n    stmxcsr DWORD PTR [eax+0x1c]        //<mxcsr\n#endif\n    mov     edx,DWORD PTR [ecx+0x4]     //>esp\n    mov     ebp,DWORD PTR [ecx+0x8]     //>ebp\n    mov     eax,DWORD PTR [ecx+0x0]     //>retaddr\n    mov     edi,DWORD PTR [ecx+0xc]     //>edi\n    mov     esi,DWORD PTR [ecx+0x10]    //>esi\n    mov     ebx,DWORD PTR [ecx+0x14]    //>ebx\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fldcw   WORD  PTR     [ecx+0x18]        //>fpucw\n    ldmxcsr DWORD PTR     [ecx+0x1c]        //>mxcsr\n#endif\n    xor     ecx,ecx\n    mov     esp,edx\n    xor     edx,edx\n    jmp     eax\n#elif __x86_64__\n/*\n    0x00                  -->                  0xff\n    r12 r13 r14 r15 rip rsp rbx rbp fpucw16 mxcsr32\n    0   8   10  18  20  28  30  38  40      44\n*/\n    // rdi - from_co | rsi - to_co\n    mov     rdx,QWORD PTR [rsp]      // retaddr\n    lea     rcx,[rsp+0x8]            // rsp\n    mov     QWORD PTR [rdi+0x0], r12\n    mov     QWORD PTR [rdi+0x8], r13\n    mov     QWORD PTR [rdi+0x10],r14\n    mov     QWORD PTR [rdi+0x18],r15\n    mov     QWORD PTR [rdi+0x20],rdx // retaddr\n    mov     QWORD PTR [rdi+0x28],rcx // rsp\n    mov     QWORD PTR [rdi+0x30],rbx\n    mov     QWORD PTR [rdi+0x38],rbp\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fnstcw  WORD PTR  [rdi+0x40]\n    stmxcsr DWORD PTR [rdi+0x44]\n#endif\n    mov     r12,QWORD PTR [rsi+0x0]\n    mov     r13,QWORD PTR [rsi+0x8]\n    mov     r14,QWORD PTR [rsi+0x10]\n    mov     r15,QWORD PTR [rsi+0x18]\n    mov     rax,QWORD PTR [rsi+0x20] // retaddr\n    mov     rcx,QWORD PTR [rsi+0x28] // rsp\n    mov     rbx,QWORD PTR [rsi+0x30]\n    mov     rbp,QWORD PTR [rsi+0x38]\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fldcw   WORD PTR      [rsi+0x40]\n    ldmxcsr DWORD PTR     [rsi+0x44]\n#endif\n    mov     rsp,rcx\n    jmp     rax\n#else\n    #error \"platform not support\"\n#endif\n\n.globl aco_save_fpucw_mxcsr\n#if defined(__APPLE__)\n#else\n.type  aco_save_fpucw_mxcsr, @function\n#endif\n.intel_syntax noprefix\naco_save_fpucw_mxcsr:\n#ifdef __i386__\n    mov     eax,DWORD PTR [esp+0x4]     // ptr\n    fnstcw  WORD PTR  [eax]\n    stmxcsr DWORD PTR [eax+0x4] \n    ret\n#elif __x86_64__\n    fnstcw  WORD PTR  [rdi]\n    stmxcsr DWORD PTR [rdi+0x4]\n    ret\n#else\n    #error \"platform not support\"\n#endif\n\n#if defined(__APPLE__)\n.globl _abort\n.globl _aco_funcp_protector\n#else\n.globl abort\n.globl aco_funcp_protector\n#endif\n\n.globl aco_funcp_protector_asm\n#if defined(__APPLE__)\n#else\n.type  aco_funcp_protector_asm, @function\n#endif\n.intel_syntax noprefix\naco_funcp_protector_asm:\n#ifdef __i386__\n            and     esp,0xfffffff0\n    #if defined(__APPLE__)\n            call    _aco_funcp_protector\n            call    _abort\n    #else\n        #if defined(__pic__) || defined(__PIC__)\n            call    aco_funcp_protector@PLT\n            call    abort@PLT\n        #else\n            call    aco_funcp_protector\n            call    abort\n        #endif\n    #endif\n            ret\n#elif __x86_64__\n            and     rsp,0xfffffffffffffff0\n    #if defined(__APPLE__)\n            call    _aco_funcp_protector\n            call    _abort\n    #else\n        #if defined(__pic__) || defined(__PIC__)\n            call    aco_funcp_protector@PLT\n            call    abort@PLT\n        #else\n            call    aco_funcp_protector\n            call    abort\n        #endif\n    #endif\n            ret\n#else\n    #error \"platform not support\"\n#endif\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "make.sh",
          "type": "blob",
          "size": 5.6201171875,
          "content": "# Copyright 2018 Sen Han <00hnes@gmail.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http:#www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nOUTPUT_DIR=\"./output\"\nCFLAGS=\"-g -O2 -Wall -Werror\"\n#EXTRA_CFLAGS=\"\"\nOUTPUT_SUFFIX=\"\"\nmakecc=\"cc\"\nif [ \"$CC\" ]\nthen\n    makecc=\"$CC\"\nfi\n\napp_list='''\ntest_aco_tutorial_0\ntest_aco_tutorial_1\ntest_aco_tutorial_2\ntest_aco_tutorial_3 -lpthread\ntest_aco_tutorial_4\ntest_aco_tutorial_5\ntest_aco_tutorial_6\ntest_aco_synopsis\ntest_aco_benchmark\n'''\n\ngl_opt_no_m32=\"\"\ngl_opt_no_valgrind=\"\"\n\nOUTPUT_DIR=\"$OUTPUT_DIR\"\"//file\"\nOUTPUT_DIR=`dirname \"$OUTPUT_DIR\"`\n\ngl_trap_str=\"\"\n\nfunction error(){\n    >&2 echo \"error: $*\"\n}\n\nfunction assert(){\n    if [ \"0\" -ne \"$?\" ]\n    then\n        error \"$0:\"\"$*\"\n        exit 1\n    fi\n}\n\nfunction tra(){\n    gl_trap_str=\"$gl_trap_str\"\"$1\"\n    trap \"$gl_trap_str exit 1;\" INT\n    assert \"$LINENO:trap failed:$gl_trap_str:$1\"\n}\n\nfunction untra(){\n    trap - INT\n    assert \"$LINENO:untrap failed:$gl_trap_str:$1\"\n}\n\nfunction build_f(){\n    declare file\n    declare cflags\n    declare build_cmd\n    declare tmp_ret\n    declare skip_flag\n    echo \"OUTPUT_DIR:       $OUTPUT_DIR\"\n    echo \"CFLAGS:           $CFLAGS\"\n    echo \"EXTRA_CFLAGS:     $EXTRA_CFLAGS\"\n    echo \"ACO_EXTRA_CFLAGS: $ACO_EXTRA_CFLAGS\"\n    echo \"OUTPUT_SUFFIX:    $OUTPUT_SUFFIX\"\n    echo \"$app_list\" | grep -Po '.+$' | while read read_in\n    do\n        file=`echo $read_in | grep -Po \"^[^\\s]+\"`\n        cflags=`echo $read_in | sed -r 's/^\\s*([^ ]+)(.*)$/\\2/'`\n        if [ -z \"$file\" ] \n        then\n            continue  \n        fi\n        #echo \"<$file>:<$cflags>:$OUTPUT_DIR:$CFLAGS:$EXTRA_CFLAGS:$OUTPUT_SUFFIX\"\n        build_cmd=\"$makecc $CFLAGS $ACO_EXTRA_CFLAGS $EXTRA_CFLAGS acosw.S aco.c $file.c $cflags -o $OUTPUT_DIR/$file$OUTPUT_SUFFIX\"\n        skip_flag=\"\"\n        if [ \"$gl_opt_no_m32\" ]\n        then\n            echo \"$OUTPUT_SUFFIX\" | grep -P \"\\bm32\\b\" &>/dev/null\n            tmp_ret=$?\n            if [ \"$tmp_ret\" -eq \"0\" ]\n            then\n                skip_flag=\"true\"\n            elif [ \"$tmp_ret\" -eq \"1\" ]\n            then\n                :\n            else\n                error \"grep failed: $tmp_ret\"\n                exit $tmp_ret\n            fi\n        fi\n        if [ \"$gl_opt_no_valgrind\" ]\n        then\n            echo \"$OUTPUT_SUFFIX\" | grep -P \"\\bvalgrind\\b\" &>/dev/null\n            tmp_ret=$?\n            if [ \"$tmp_ret\" -eq \"0\" ]\n            then\n                skip_flag=\"true\"\n            elif [ \"$tmp_ret\" -eq \"1\" ]\n            then\n                :\n            else\n                error \"grep failed: $tmp_ret\"\n                exit $tmp_ret\n            fi\n        fi\n        if [ \"$skip_flag\" ]\n        then\n            echo \"skip    $build_cmd\"\n        else\n            echo \"        $build_cmd\"\n            $build_cmd\n            assert \"build fail\"\n        fi\n    done\n    assert \"exit\"\n}\n\nfunction usage() {\n    echo \"Usage: $0 [-o <no-m32|no-valgrind>] [-h]\" 1>&2\n    echo '''\nExample:\n    # default build\n    bash make.sh\n    # build without the i386 binary output\n    bash make.sh -o no-m32\n    # build without the valgrind supported binary output\n    bash make.sh -o no-valgrind\n    # build without the valgrind supported and i386 binary output\n    bash make.sh -o no-valgrind -o no-m32\n''' 1>&2\n}\n\ngl_opt_value=\"\"\nwhile getopts \":o:h\" o; do\n    case \"${o}\" in\n        o)\n            gl_opt_value=${OPTARG}\n            if [ \"$gl_opt_value\" = \"no-m32\" ]\n            then\n                gl_opt_no_m32=\"true\"\n            elif [ \"$gl_opt_value\" = \"no-valgrind\" ]\n            then\n                gl_opt_no_valgrind=\"true\"\n            else\n                usage\n                error unknow option value of '-o'\n                exit 1\n            fi\n            ;;\n        h)\n            usage\n            exit 0\n            ;;\n        *)\n            usage\n            error unknow option\n            exit 1\n            ;;\n    esac\ndone\nshift $((OPTIND-1))\n\n#echo \"o = $gl_opt_value\"\n#echo \"gl_opt_no_valgrind:$gl_opt_no_valgrind\"\n#echo \"gl_opt_no_m32:$gl_opt_no_m32\"\n\nif [ -e \"$OUTPUT_DIR\" ]\nthen\n    if [ -d \"$OUTPUT_DIR\" ]\n    then\n        :\n    else\n        error \"\\\"$OUTPUT_DIR\\\" is not a directory\"\n        exit 1\n    fi\nelse\n    error \"directory \\\"$OUTPUT_DIR\\\" doesn't exist\"\n    exit 1\nfi\n\ntra \"echo;echo build has been interrupted\"\n\n# the matrix of the build config for later testing\n# -m32 -DACO_CONFIG_SHARE_FPU_MXCSR_ENV -DACO_USE_VALGRIND\n# 0 0 0\nACO_EXTRA_CFLAGS=\"\" OUTPUT_SUFFIX=\"..no_valgrind.standaloneFPUenv\" build_f\n# 0 0 1\nACO_EXTRA_CFLAGS=\"-DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..valgrind.standaloneFPUenv\" build_f\n# 0 1 0\nACO_EXTRA_CFLAGS=\"-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\" OUTPUT_SUFFIX=\"..no_valgrind.shareFPUenv\" build_f\n# 0 1 1\nACO_EXTRA_CFLAGS=\"-DACO_CONFIG_SHARE_FPU_MXCSR_ENV -DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..valgrind.shareFPUenv\" build_f\n# 1 0 0\nACO_EXTRA_CFLAGS=\"-m32\" OUTPUT_SUFFIX=\"..m32.no_valgrind.standaloneFPUenv\" build_f\n# 1 0 1\nACO_EXTRA_CFLAGS=\"-m32 -DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..m32.valgrind.standaloneFPUenv\" build_f\n# 1 1 0\nACO_EXTRA_CFLAGS=\"-m32 -DACO_CONFIG_SHARE_FPU_MXCSR_ENV\" OUTPUT_SUFFIX=\"..m32.no_valgrind.shareFPUenv\" build_f\n# 1 1 1\nACO_EXTRA_CFLAGS=\"-m32 -DACO_CONFIG_SHARE_FPU_MXCSR_ENV -DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..m32.valgrind.shareFPUenv\" build_f\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 5.58984375,
          "content": "#!/bin/bash\n\n# Copyright 2018 Sen Han <00hnes@gmail.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http:#www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#ulimit -c unlimited\n\ngl_trap_str=\"\"\n\nfunction error(){\n    >&2 echo \"$*\"\n}\n\nfunction assert(){\n    if [ \"0\" -ne \"$?\" ]\n    then\n        error \"$0:\"\"$*\"\n        exit 1\n    fi\n}\n\nfunction tra(){\n    gl_trap_str=\"$gl_trap_str\"\"$1\"\n    trap \"$gl_trap_str exit 1;\" INT\n    assert \"$LINENO:trap failed:$gl_trap_str:$1\"\n}\n\nfunction untra(){\n    trap - INT\n    assert \"$LINENO:untrap failed:$gl_trap_str:$1\"\n}\n\nfunction test_f_is_exclude_app(){\n    declare infile\n    declare main_name\n    infile=$1\n    main_name=`echo \"$infile\" | sed -r \"s|(.*)\\.\\.(.*)|\\1|\"`\n    if [ -z \"$infile\" -o -z \"$main_name\" ]\n    then\n        error \"$0:\"\"$*\"\n        exit 1\n    fi\n    if [ \"$main_name\" = \"test_aco_benchmark\" ]\n    then\n        return 0\n    else\n        return 1\n    fi  \n}\n\nfunction test_f_handle_exit_code(){\n    declare infile\n    declare errc\n    declare main_name\n    declare intended_to_abort\n    infile=$1\n    errc=$2\n    if [ -z \"$infile\" ]\n    then\n        error test_f_handle_exit_code illegal input       \n        exit 1\n    fi\n    if [ -z \"$errc\" -o \"$errc\" -lt \"0\" ]\n    then\n        error test_f_handle_exit_code illegal input\n        exit 1\n    fi\n    main_name=`echo \"$infile\" | sed -r \"s|(.*)\\.\\.(.*)|\\1|\"`\n    intended_to_abort=\"\"\n    if [ \"$main_name\" = \"test_aco_tutorial_4\" -o \"$main_name\" = \"test_aco_tutorial_5\" ]\n    then\n        intended_to_abort=\"true\"\n    fi\n    if [ \"$intended_to_abort\" -a \"$errc\" -ne \"134\" ]\n    then\n        echo \"\"\n        echo test $infile intended to abort failed:$errc\n        exit $errc\n    fi\n    if [ -z \"$intended_to_abort\" -a \"$errc\" -ne \"0\" ]\n    then\n        echo \"\"\n        echo test $infile failed:$errc\n        exit $errc\n    fi\n    if [ \"$intended_to_abort\" ] \n    then\n        echo test $infile intended to abort success:$errc\n    else\n        echo test $infile success\n    fi\n}\n\nfunction test_f(){\n    declare valgrind_support\n    declare errc\n    declare test_ct\n    declare infile\n    test_ct=`file * | grep -P \"\\bexecutable\\b\" | grep -Po '^[^:]+' | wc -l`\n    file * | grep -P \"\\bexecutable\\b\" | grep -Po '^[^:]+' | while read infile\n    do\n        test_f_is_exclude_app \"$infile\"\n        if [ \"0\" -eq \"$?\" ]\n        then\n            echo \"----\" $infile is in the exclude app list, bypass its test\n            echo\n            continue\n        fi\n        valgrind_support=`echo \"$infile\" | grep -Po '.*\\.\\.(.*)' | sed -r \"s|(.*)\\.\\.(.*)|\\2|\" | grep -Po '\\bvalgrind\\b'`\n        if [ -z \"$valgrind_support\" ]\n        then\n            echo \"----\" $infile start\":\"\n            time ./$infile\n            errc=\"$?\"\n            test_f_handle_exit_code $infile $errc\n        else\n            echo \"----\" $infile memcheck start\":\"\n            time valgrind --leak-check=full --error-exitcode=2 --tool=memcheck ./$infile\n            errc=\"$?\"\n            test_f_handle_exit_code $infile $errc\n        fi\n        echo\n    done\n    errc=\"$?\"\n    if [ \"$errc\" -ne \"0\" ]\n    then\n        exit \"$errc\"\n    fi\n    if [ \"$test_ct\" -ne \"0\" ]\n    then\n        echo all the \"$test_ct\" tests had passed, OK and cheers!\n    else\n        echo no test need to do in current directory: \"`pwd`\"\n    fi\n}\n\ntra \"echo;echo test had been interrupted;exit 0;\"\n\nversion_check_flag=`echo $1 | grep -Po \"\\bversion_check\\b=\"`\nversion_to_check=`echo $1 | grep -Po \"[0-9]+\\.[0-9]+\\.[0-9]+\" | head -1`\nversion_major=`echo $version_to_check | grep -Po \"^[0-9]+(?=\\.)\"`\nversion_minor=`echo $version_to_check | grep -Po \"(?<=\\.)[0-9]+(?=\\.)\"`\nversion_patch=`echo $version_to_check | grep -Po \"(?<=\\.)[0-9]+$\"`\necho \"$version_check_flag |$version_to_check|\"\necho \"|$version_major|$version_minor|$version_patch|\"\n\nmakecc=\"cc\"\nif [ \"$CC\" ]\nthen\n    makecc=\"$CC\"\nfi\n\nif [ \"$version_check_flag\" ]\nthen\n    if [ \"$version_major\" -lt 0 ] || [ \"$version_minor\" -lt 0 ] || [ \"$version_patch\" -lt 0 ]\n    then\n        error \"synatx error: version_to_check: $version_to_check\"\n        exit 1\n    fi\n    version_check_tmpdir=`mktemp -d`\n    version_check_tmpfile=\"$version_check_tmpdir\"/tmp.c\n    echo '''        #include \"aco.h\"\n        #include <stdio.h>\n        #include \"aco_assert_override.h\"\n\n        int main() {''' > $version_check_tmpfile\n    echo \"        assert(ACO_VERSION_MAJOR == $version_major);\" \\\n        >> $version_check_tmpfile\n    echo \"        assert(ACO_VERSION_MINOR == $version_minor);\" \\\n        >> $version_check_tmpfile\n    echo \"        assert(ACO_VERSION_PATCH == $version_patch);\" \\\n        >> $version_check_tmpfile\n    echo \"        return 0;\" >> $version_check_tmpfile\n    echo \"        }\" >> $version_check_tmpfile\n    echo \"$version_check_tmpfile:\"\n    cat $version_check_tmpfile\n    $makecc -I. -g -O2 acosw.S aco.c -o \"$version_check_tmpfile\".bin $version_check_tmpfile\n    \"$version_check_tmpfile\".bin\n    assert \"error: version_check failed: $version_to_check\"\n    rm -fr \"$version_check_tmpdir\"\n    exit 0\nfi\n\n# test loop\nwhile true\ndo\n    echo \"---- time:\"`date`\n    test_f\n    errc=\"$?\"\n    if [ \"$errc\" -ne 0 ]\n    then\n        exit $errc\n    fi   \n    if [ \"$1\" != \"loop\" ]\n    then\n        exit 0\n    fi\n    echo \"\"\n    echo \"----\" start all tests again\n    sleep 1\ndone\n"
        },
        {
          "name": "test_aco_benchmark.c",
          "type": "blob",
          "size": 8.138671875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#define _GNU_SOURCE\n\n#include \"aco.h\"    \n#include <alloca.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\naco_cofuncp_t gl_co_fp;\n\n#define PRINT_BUF_SZ 64\nchar gl_benchmark_print_str_buf[64];\n\nvoid co_fp_alloca(){\n    size_t sz = (size_t)((uintptr_t)aco_get_arg());\n    uint8_t* ptr = NULL;\n    assert(sz > 0);\n    ptr = alloca(sz);\n    assertptr(ptr);\n    memset(ptr, 0, sz);\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_128(){\n    int ip[28];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_64(){\n    int ip[12];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_40(){\n    int ip[8];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_24(){\n    int ip[4];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_8(){\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp0(){\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid benchmark_copystack(size_t co_amount,size_t stksz, size_t loopct){\n    struct timespec tstart={0,0}, tend={0,0};\n    int print_sz = 0;\n    double delta_t;\n    // create co\n    assert(co_amount > 0);\n    assertptr((void*)gl_co_fp);\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    // NOTE: size_t_safe_mul\n    aco_t** coarray = (aco_t**) malloc(sizeof(void*) * co_amount);\n    assertptr(coarray);\n    memset(coarray, 0, sizeof(void*) * co_amount);\n    size_t ct = 0;\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tstart));\n    while(ct < co_amount){\n        coarray[ct] = aco_create(\n            main_co, sstk, 0, gl_co_fp, \n            (void*)((uintptr_t)stksz)\n        );\n        ct++;\n    }\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tend));\n    delta_t = ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) -\n        ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec);\n    //aco_create/init_save_stk_sz=64B    10000000   140.43 ns/op     7126683.67 op/s\n    print_sz = snprintf(\n        gl_benchmark_print_str_buf, PRINT_BUF_SZ, \n        \"aco_create/init_save_stk_sz=64B\"\n    );\n    assert(print_sz > 0 && print_sz < PRINT_BUF_SZ);\n    printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\", \n        gl_benchmark_print_str_buf,\n        co_amount, delta_t,\n        (1.0e+9) / (co_amount / delta_t),\n        co_amount / delta_t);\n    fflush(stdout);\n    // warm-up\n    ct = 0;\n    while(ct < co_amount){\n        aco_resume(coarray[ct]);\n        ct++;\n    }\n    // copystack ctxsw\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tstart));\n    size_t glct = 0;\n    while(glct < loopct){\n        ct = 0;\n        while(ct < co_amount){\n            aco_resume(coarray[ct]);\n            ct++;\n            glct++;\n        }\n    }\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tend));    \n    delta_t = ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) -\n        ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec);\n    //aco_resume/copy_stack_size=8B      20000000    36.23 ns/op    27614644.57 op/s    \n    print_sz = snprintf(\n        gl_benchmark_print_str_buf, PRINT_BUF_SZ, \n        \"aco_resume/co_amount=%zu/copy_stack_size=%zuB\",\n        co_amount, coarray[0]->save_stack.max_cpsz\n    );\n    assert(print_sz > 0 && print_sz < PRINT_BUF_SZ);\n    printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\",\n        gl_benchmark_print_str_buf, glct, \n        delta_t, (1.0e+9) / (glct / delta_t), \n        glct / delta_t);\n    if(co_amount == 1 && coarray[0]->save_stack.max_cpsz == 0){\n        printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\",\n            \"  -> acosw\", glct*2, \n            delta_t, (1.0e+9) / (glct*2 / delta_t), \n            glct*2 / delta_t);\n    }\n    fflush(stdout);\n    // co cleaning\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tstart));\n    ct = 0;\n    while(ct < co_amount){\n        aco_destroy(coarray[ct]);\n        coarray[ct] = NULL;\n        ct++;\n    }\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tend));\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n    free(coarray);\n    delta_t = ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) -\n        ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec);\n    //aco_destroy                        20000000    21.22 ns/op    47616496.16 op/s\n    print_sz = snprintf(\n        gl_benchmark_print_str_buf, PRINT_BUF_SZ, \n        \"aco_destroy\"\n    );\n    assert(print_sz > 0 && print_sz < PRINT_BUF_SZ);\n    printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\\n\", \n        gl_benchmark_print_str_buf,\n        co_amount, delta_t, \n        (1.0e+9) / (co_amount / delta_t), \n        co_amount / delta_t);\n    fflush(stdout);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(1){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    printf(\"warm-up:\\n\");\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(200*10000, 10, 20000000);\n\n#ifdef __i386__\n    printf(\"+build:i386\\n\");\n#elif __x86_64__\n    printf(\"+build:x86_64\\n\");\n#endif\n\n#ifdef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    printf(\"+build:-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\\n\");\n    printf(\"+build:share fpu & mxcsr control words between coroutines\\n\");\n#else\n    printf(\"+build:undefined ACO_CONFIG_SHARE_FPU_MXCSR_ENV\\n\");\n    printf(\"+build:each coroutine maintain each own fpu & mxcsr control words\\n\");\n#endif\n#ifdef ACO_USE_VALGRIND\n    printf(\"+build:-DACO_USE_VALGRIND\\n\");\n    printf(\"+build:valgrind memcheck friendly support enabled\\n\");\n#else\n    printf(\"+build:undefined ACO_USE_VALGRIND\\n\");\n    printf(\"+build:without valgrind memcheck friendly support\\n\");\n#endif\n\n    printf(\"\\nsizeof(aco_t)=%zu:\\n\\n\", sizeof(aco_t));\n\n    printf(\"\\nstart-test:\\n\\n\");\n    printf(\"%-50s %15s    %15s    %15s   %15s\\n\\n\", \n        \"comment\", \"task_amount\", \"all_time_cost\", \"ns_per_op\", \"speed\"\n    );\n\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(1, 10, 20000000);\n\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(1, 10, 20000000);\n\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_24;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_40;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_64;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_128;\n    benchmark_copystack(200*10000, 10, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 150 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 158 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 166 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 256 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 512 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 512 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(100*10000, 1024 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(100*10000, 1024 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 1024 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 2048 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 4096 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 8012 - 64, 20000000);\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_synopsis.c",
          "type": "blob",
          "size": 1.8837890625,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"aco.h\"    \n#include <stdio.h>\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct) {\n    printf(\"co: %p: yield to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_yield();\n    *((int*)(aco_get_arg())) = ct + 1;\n}\n\nvoid co_fp0() {\n    printf(\"co: %p: entry: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\"co: %p:  exit to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        ct++;\n    }\n    printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co: destroy and exit\\n\");\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_0.c",
          "type": "blob",
          "size": 3.6748046875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Hello aco demo.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid co_fp0() {\n    // Get co->arg. The caller of `aco_get_arg()` must be a non-main co.\n    int *iretp = (int *)aco_get_arg();\n    // Get current co. The caller of `aco_get_co()` must be a non-main co.\n    aco_t* this_co = aco_get_co();\n    int ct = 0;\n    while(ct < 6){\n        printf(\n            \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n            this_co, this_co->save_stack.ptr,\n            this_co->share_stack->ptr, ct\n        );\n        // Yield the execution of current co and resume the execution of\n        // `co->main_co`. The caller of `aco_yield()` must be a non-main co.\n        aco_yield();\n        (*iretp)++;\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    // In addition do the same as `aco_yield()`, `aco_exit()` also set \n    // `co->is_end` to `1` thus to mark the `co` at the status of \"END\".\n    aco_exit();\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n    // Initialize the aco environment in the current thread.\n    aco_thread_init(NULL);\n\n    // Create a main coroutine whose \"share stack\" is the default stack \n    // of the current thread. And it doesn't need any private save stack \n    // since it is definitely a standalone coroutine (which coroutine \n    // monopolizes it's share stack).\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n\n    // Create a share stack with the default size of 2MB and also with a \n    // read-only guard page for the detection of stack overflow.\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    // Create a non-main coroutine whose share stack is `sstk` and has a\n    // default 64 bytes size private save stack. The entry function of the \n    // coroutine is `co_fp0`. Set `co->arg` to the address of the int \n    // variable `co_ct_arg_point_to_me`.\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        // Start or continue the execution of `co`. The caller of this function\n        // must be main_co.\n        aco_resume(co);\n        // Check whether the co has completed the job it promised.\n        assert(co_ct_arg_point_to_me == ct);\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    // The value of `co->is_end` must be `1` now since it just suspended \n    // itself by calling `aco_exit()`.\n    assert(co->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    // Destroy co and its private save stack.\n    aco_destroy(co);\n    co = NULL;\n    // Destroy the share stack sstk.\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    // Destroy the main_co.\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_1.c",
          "type": "blob",
          "size": 3.0234375,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Some statistics of the coroutine.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid co_fp0(){\n    int *iretp = (int *)aco_get_arg();\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        printf(\n            \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n            this_co, this_co->save_stack.ptr,\n            this_co->share_stack->ptr, ct\n        );\n        aco_yield();\n        (*iretp)++;\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    aco_exit();\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n    \n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_2.c",
          "type": "blob",
          "size": 4.794921875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    aco_exit();\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(1){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n    aco_share_stack_t* sstk2 = aco_share_stack_new(0);\n    assertptr(sstk2);\n\n    int co_ct_arg_point_to_me = 0;\n    int co2_ct_arg_point_to_me = 0;\n    int co3_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n    aco_t* co2 = aco_create(main_co, sstk2, 0, co_fp0, &co2_ct_arg_point_to_me);\n    aco_t* co3 = aco_create(main_co, sstk2, 0, co_fp0, &co3_ct_arg_point_to_me);\n    assertptr(co2);\n    assertptr(co3);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        assert(co2->is_end == 0);\n        aco_resume(co2);\n        assert(co2_ct_arg_point_to_me == ct);\n\n        assert(co3->is_end == 0);\n        aco_resume(co3);\n        assert(co3_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    aco_resume(co2);\n    assert(co2_ct_arg_point_to_me == ct);\n    assert(co2->is_end);\n\n    aco_resume(co3);\n    assert(co3_ct_arg_point_to_me == ct);\n    assert(co3->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    printf(\n        \"\\ncopy-stack co2:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co2, co2->save_stack.max_cpsz, \n        co2->save_stack.ct_save, \n        co2->save_stack.ct_restore\n    );\n    printf(\n        \"\\ncopy-stack co3:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co3, co3->save_stack.max_cpsz, \n        co3->save_stack.ct_save, \n        co3->save_stack.ct_restore\n    );\n\n    printf(\"\\n(The co2 & co3 share the share stack sstk2, thus it is \"\n        \"necessary to save/restore the stack every time during resume &\"\n        \" yield execution, thus it is a ordinary case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n    aco_destroy(co2);\n    co2 = NULL;\n    aco_destroy(co3);\n    co3 = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_share_stack_destroy(sstk2);\n    sstk2 = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_3.c",
          "type": "blob",
          "size": 5.982421875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Use aco in multithread.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <inttypes.h>\n#include \"aco_assert_override.h\"\n\nuint64_t gl_race_aco_yield_ct = 0;\npthread_mutex_t gl_race_aco_yield_ct_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    pthread_mutex_lock(&gl_race_aco_yield_ct_mutex);\n    gl_race_aco_yield_ct++;\n    pthread_mutex_unlock(&gl_race_aco_yield_ct_mutex);\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    pthread_mutex_lock(&gl_race_aco_yield_ct_mutex);\n    gl_race_aco_yield_ct++;\n    pthread_mutex_unlock(&gl_race_aco_yield_ct_mutex);\n    aco_exit();\n    assert(0);\n}\n\nvoid* pmain(void* pthread_in_arg) {\n    pthread_t t = pthread_self();\n    size_t idx = 0;\n    assert(sizeof(t) > 0);\n    printf(\"\\ntid:0x\");\n    while(idx < sizeof(t)){\n        printf(\"%02x\", *(((uint8_t*)(&t)) + idx));\n        idx++;\n    }\n    printf(\"\\n\");\n    \n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n    aco_share_stack_t* sstk2 = aco_share_stack_new(0);\n    assertptr(sstk2);\n\n    int co_ct_arg_point_to_me = 0;\n    int co2_ct_arg_point_to_me = 0;\n    int co3_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n    aco_t* co2 = aco_create(main_co, sstk2, 0, co_fp0, &co2_ct_arg_point_to_me);\n    aco_t* co3 = aco_create(main_co, sstk2, 0, co_fp0, &co3_ct_arg_point_to_me);\n    assertptr(co2);\n    assertptr(co3);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        assert(co2->is_end == 0);\n        aco_resume(co2);\n        assert(co2_ct_arg_point_to_me == ct);\n\n        assert(co3->is_end == 0);\n        aco_resume(co3);\n        assert(co3_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    aco_resume(co2);\n    assert(co2_ct_arg_point_to_me == ct);\n    assert(co2->is_end);\n\n    aco_resume(co3);\n    assert(co3_ct_arg_point_to_me == ct);\n    assert(co3->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    printf(\n        \"\\ncopy-stack co2:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co2, co2->save_stack.max_cpsz, \n        co2->save_stack.ct_save, \n        co2->save_stack.ct_restore\n    );\n    printf(\n        \"\\ncopy-stack co3:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co3, co3->save_stack.max_cpsz, \n        co3->save_stack.ct_save, \n        co3->save_stack.ct_restore\n    );\n\n    printf(\"\\n(The co2 & co3 share the share stack sstk2, thus it is \"\n        \"necessary to save/restore the stack every time during resume &\"\n        \" yield execution, thus it is a ordinary case of copy-stack.)\\n\");\n\n    uint64_t tmp_gl_ct;\n    pthread_mutex_lock(&gl_race_aco_yield_ct_mutex);\n    tmp_gl_ct = gl_race_aco_yield_ct;\n    pthread_mutex_unlock(&gl_race_aco_yield_ct_mutex);\n    printf(\"\\ngl_race_aco_yield_ct:%\" PRIu64\"\\n\", tmp_gl_ct);\n\n    aco_destroy(co);\n    co = NULL;\n    aco_destroy(co2);\n    co2 = NULL;\n    aco_destroy(co3);\n    co3 = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_share_stack_destroy(sstk2);\n    sstk2 = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n\nint main(){\n#ifdef ACO_USE_VALGRIND\n    if(1){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    pthread_t t1,t2;\n\n    assert(0 == pthread_create(\n        &t1, NULL, pmain, NULL\n    ));\n    assert(0 == pthread_create(\n        &t2, NULL, pmain, NULL\n    ));\n\n    assert(0 == pthread_join(t1, NULL));\n    assert(0 == pthread_join(t2, NULL));\n    \n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_4.c",
          "type": "blob",
          "size": 3.326171875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p !offending return!\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    printf(\"Intended to Abort to test the aco protector :)\\n\");\n    // the offending `return` here it is\n    // you should always call `aco_exit()` to finish the execution of a non-main co\n    // instead of call `return` in the real application\n    // this is a demo shows how protector works in libaco (intended to abort)\n    return;\n    aco_exit();\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_5.c",
          "type": "blob",
          "size": 3.4931640625,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Test the customization of aco protector.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p !offending return!\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    printf(\"Intended to Abort to test the aco protector :)\\n\");\n    return;\n    aco_exit();\n    assert(0);\n}\n\nstatic void co_protector_last_word(){\n    aco_t* co = aco_get_co();\n    // do some log about the offending `co`\n    fprintf(stderr,\"error: customized co_protector_last_word triggered \\n\");\n    fprintf(stderr, \"error: co:%p should call `aco_exit(co)` instead of direct \"\n        \"`return` in co_fp:%p to finish its execution\\n\", co, (void*)co->fp);\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(co_protector_last_word);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_6.c",
          "type": "blob",
          "size": 3.236328125,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// A naive and pretty simple scheduler demo.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid co_fp0(){\n    int ct = 0;\n    int loop_ct = (int)((uintptr_t)(aco_get_co()->arg));\n    if(loop_ct < 0){\n        loop_ct = 0;\n    }\n    while(ct < loop_ct){\n        aco_yield();\n        ct++;\n    }\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    time_t seed_t = time(NULL);\n    assert((time_t)-1 != seed_t);\n    srand(seed_t);\n\n    size_t co_amount = 100;\n\n    // create co\n    assert(co_amount > 0);\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    // NOTE: size_t_safe_mul\n    aco_t** coarray = (aco_t**) malloc(sizeof(void*) * co_amount);\n    assertptr(coarray);\n    memset(coarray, 0, sizeof(void*) * co_amount);\n    size_t ct = 0;\n    while(ct < co_amount){\n#ifdef ACO_USE_VALGRIND\n        aco_share_stack_t* private_sstk = aco_share_stack_new2(\n            0, ct % 2\n        );\n        coarray[ct] = aco_create(\n            main_co, private_sstk, 0, co_fp0,\n            (void*)((uintptr_t)rand() % 1000)\n        );\n        private_sstk = NULL;\n#else\n        coarray[ct] = aco_create(\n            main_co, sstk, 0, co_fp0,\n            (void*)((uintptr_t)rand() % 1000)\n        );\n#endif\n        ct++;\n    }\n\n    // naive scheduler with very poor performance (only for demo and testing)\n    printf(\"scheduler start: co_amount:%zu\\n\", co_amount);\n    size_t null_ct = 0;\n    while(1){\n        ct = 0;\n        while(ct < co_amount){\n            if(coarray[ct] != NULL){\n                aco_resume(coarray[ct]);\n                null_ct = 0;\n                if(coarray[ct]->is_end != 0){\n                    printf(\"aco_destroy: co:%zu\\n\", ct);\n                    #ifdef ACO_USE_VALGRIND\n                        aco_share_stack_t* private_sstk = coarray[ct]->share_stack;\n                    #endif\n                    aco_destroy(coarray[ct]);\n                    coarray[ct] = NULL;\n                    #ifdef ACO_USE_VALGRIND\n                        aco_share_stack_destroy(private_sstk);\n                        private_sstk = NULL;\n                    #endif\n                }\n            } else {\n                null_ct++;\n                if(null_ct >= co_amount){\n                    goto END;\n                }\n            }\n            ct++;\n        }\n    }\n    // co cleaning\n    END:\n    ct = 0;\n    while(ct < co_amount){\n        assert(coarray[ct] == NULL);\n        ct++;\n    }\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n    free(coarray);\n\n    printf(\"sheduler exit\");\n    \n    return 0;\n}\n"
        }
      ]
    }
  ]
}