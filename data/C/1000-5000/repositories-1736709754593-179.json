{
  "metadata": {
    "timestamp": 1736709754593,
    "page": 179,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hnes/libaco",
      "stars": 3537,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 2.6572265625,
          "content": "dist: trusty\nsudo: required\n\nnotifications:\n  email:\n    - 00hnes@gmail.com\n\nlanguage: c\n\nscript:\n    - echo $TRAVIS_EVENT_TYPE\n    - echo $TRAVIS_OS_NAME\n    - echo $CC\n    - cc --version\n    - if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] ; then brew update; brew install grep;export PATH=\"/usr/local/opt/grep/libexec/gnubin:$PATH\"; fi\n    - if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] ; then brew install gnu-sed;export PATH=\"/usr/local/opt/gnu-sed/libexec/gnubin:$PATH\"; fi\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then sudo apt-get install -qq -y libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl make build-essential valgrind gcc-multilib g++-multilib libc6-dbg libc6-dbg:i386 ; fi\n    - date\n    - grep -V\n    - sed --version\n    - export EXTRA_CFLAGS=\"\"\n    - echo \"\"\n    - bash test.sh version_check=1.2.4\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - mkdir output ; bash make.sh -o no-valgrind ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-valgrind -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - export EXTRA_CFLAGS=\"--std=c99\"\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\"\n    - mkdir output ; bash make.sh -o no-valgrind ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output\n    - echo \"\"\n    - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ] ; then mkdir output ; bash make.sh -o no-valgrind -o no-m32 ; ls output ; ls output | wc -l ; cd output ; bash ../test.sh ; cd .. ; rm -fr output; fi\n    - echo \"\" ; date\n\nmatrix:\n  include:\n    - os: linux\n      compiler: gcc-4.9\n      addons:\n        apt:\n          sources:\n            - ubuntu-toolchain-r-test\n          packages:\n            - gcc-4.9\n    - os: linux\n      compiler: clang-3.5\n      addons:\n        apt:\n          sources:\n            - ubuntu-toolchain-r-test\n            - llvm-toolchain-trusty-3.5\n          packages:\n            - clang-3.5\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 54.744140625,
          "content": "[![Logo of libaco](https://github.com/libaco/logo/blob/main/web/libaco_logo_blue.svg)](https://libaco.org)\n\nlibaco - A blazing fast and lightweight C asymmetric coroutine library.\n\nThe code name of this project is Arkenstone ðŸ’Ž\n\nAsymmetric COroutine & Arkenstone is the reason why it's been named `aco`.\n\nCurrently supports Sys V ABI of Intel386 and x86-64.\n\nHere is a brief summary of this project:\n\n- Along with the implementation of a production-ready C coroutine library, here is a detailed documentation about how to implement a *fastest* and *correct* coroutine library and also with a strict [mathematical proof](#proof-of-correctness);\n- It has no more than 700 LOC but has the full functionality which you may want from a coroutine library;\n- The [benchmark](#benchmark) part shows that a context switch between coroutines only takes about *10 ns* (in the case of standalone stack) on the AWS c5d.large machine;\n- User could choose to create a new coroutine with a *standalone stack* or with a *shared stack* (could be shared with others);\n- It is extremely memory efficient: *10,000,000* coroutines simultaneously to run cost only *2.8 GB* physical memory (run with tcmalloc, each coroutine has a *120B* copy-stack size configuration).\n\nThe phrase \"*fastest*\" in above means the fastest context switching implementation which complies to the Sys V ABI of Intel386 or AMD64.\n\n[![Build Status Travis](https://img.shields.io/travis/hnes/libaco.svg?style=flat-square&&branch=master)](https://travis-ci.org/hnes/libaco)\n[![Releases](https://img.shields.io/github/release/hnes/libaco/all.svg?style=flat-square)](https://github.com/hnes/libaco/releases)\n[![LICENSE](https://img.shields.io/github/license/hnes/libaco.svg?style=flat-square)](https://github.com/hnes/libaco/blob/master/LICENSE)\n[![ä¸­æ–‡æ–‡æ¡£](https://img.shields.io/badge/doc-en%20+%20ä¸­æ–‡-blue.svg?style=flat-square)](https://github.com/hnes/libaco/blob/master/README_zh.md)\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=libaco+-+A+blazing+fast+and+lightweight+C+asymmetric+coroutine+library&url=https://github.com/hnes/libaco&via=00hnes)\n\nIssues and PRs are welcome ðŸŽ‰ðŸŽ‰ðŸŽ‰\n\nNote: Please use [releases][github-release] instead of the `master` to build the final binary.\n\nBesides this readme, you could also visit the documentation from [https://libaco.org/docs](https://libaco.org/docs). Please follow this readme if there are any differences because the documentation on the website may be lagging behind from this readme.\n\n[github-release]: https://github.com/hnes/libaco/releases\n\n# Table of Contents\n\n   * [Status](#status)\n   * [Synopsis](#synopsis)\n   * [Description](#description)\n   * [Build and Test](#build-and-test)\n      * [CFLAGS](#cflags)\n      * [Build](#build)\n      * [Test](#test)\n   * [Tutorials](#tutorials)\n   * [API](#api)\n      * [aco_thread_init](#aco_thread_init)\n      * [aco_share_stack_new](#aco_share_stack_new)\n      * [aco_share_stack_new2](#aco_share_stack_new2)\n      * [aco_share_stack_destroy](#aco_share_stack_destroy)\n      * [aco_create](#aco_create)\n      * [aco_resume](#aco_resume)\n      * [aco_yield](#aco_yield)\n      * [aco_get_co](#aco_get_co)\n      * [aco_get_arg](#aco_get_arg)\n      * [aco_exit](#aco_exit)\n      * [aco_destroy](#aco_destroy)\n      * [MACROS](#macros)\n   * [Benchmark](#benchmark)\n   * [Proof of Correctness](#proof-of-correctness)\n      * [Running Model](#running-model)\n      * [Mathematical Induction](#mathematical-induction)\n      * [Miscellaneous](#miscellaneous)\n         * [Red Zone](#red-zone)\n         * [Stack Pointer](#stack-pointer)\n   * [Best Practice](#best-practice)\n   * [TODO](#todo)\n   * [CHANGES](#changes)\n   * [Donation](#donation)\n   * [Thanks](#thanks)\n* [Copyright and License](#copyright-and-license)\n\n# Status\n\nProduction ready.\n\n# Synopsis\n\n```c\n#include \"aco.h\"    \n#include <stdio.h>\n\n// this header would override the default C `assert`;\n// you may refer the \"API : MACROS\" part for more details.\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct) {\n    printf(\"co: %p: yield to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_yield();\n    *((int*)(aco_get_arg())) = ct + 1;\n}\n\nvoid co_fp0() {\n    printf(\"co: %p: entry: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\"co: %p:  exit to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        ct++;\n    }\n    printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co: destroy and exit\\n\");\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n```\n```bash\n# default build\n$ gcc -g -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ ./test_aco_synopsis\nmain_co: yield to co: 0x1887120: 0\nco: 0x1887120: entry: 0\nco: 0x1887120: yield to main_co: 0\nmain_co: yield to co: 0x1887120: 1\nco: 0x1887120: yield to main_co: 1\nmain_co: yield to co: 0x1887120: 2\nco: 0x1887120: yield to main_co: 2\nmain_co: yield to co: 0x1887120: 3\nco: 0x1887120: yield to main_co: 3\nmain_co: yield to co: 0x1887120: 4\nco: 0x1887120: yield to main_co: 4\nmain_co: yield to co: 0x1887120: 5\nco: 0x1887120: yield to main_co: 5\nmain_co: yield to co: 0x1887120: 6\nco: 0x1887120:  exit to main_co: 6\nmain_co: destroy and exit\n# i386\n$ gcc -g -m32 -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n# share fpu and mxcsr env\n$ gcc -g -D ACO_CONFIG_SHARE_FPU_MXCSR_ENV -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis \n# with valgrind friendly support\n$ gcc -g -D ACO_USE_VALGRIND -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ valgrind --leak-check=full --tool=memcheck ./test_aco_synopsis\n```\n\nFor more information you may refer to the \"[Build and Test](#build-and-test)\" part.\n\n# Description\n\n![thread_model_0](img/thread_model_0.png)\n\nThere are 4 basic elements of an ordinary execution state: `{cpu_registers, code, heap, stack}`.\n\nSince the code information is indicated by `({E|R})?IP` register, and the address of the memory allocated from heap is normally stored in the stack directly or indirectly, thus we could simplify the 4 elements into only 2 of them: `{cpu_registers, stack}`.\n\n![thread_model_1](img/thread_model_1.png)\n\nWe define the `main co` as the coroutine who monopolizes the default stack of the current thread. And since the main co is the only user of this stack, we only need to save/restore the necessary cpu registers' state of the main co when it's been yielded-from/resumed-to (switched-out/switched-in).\n\nNext, the definition of the `non-main co` is the coroutine whose execution stack is a stack which is not the default stack of the current thread and may be shared with the other non-main co. Thus the non-main co must have a `private save stack` memory buffer to save/restore its execution stack when it is been switched-out/switched-in (because the succeeding/preceding co may would/had use/used the share stack as its execution stack).\n\n![thread_model_2](img/thread_model_2.png)\n\nThere is a special case of non-main co, that is `standalone non-main co` what we called in libaco: the share stack of the non-main coroutine has only one co user. Thus there is no need to do saving/restoring stuff of its private save stack when it is been switched-out/switched-in since there is no other co will touch the execution stack of the standalone non-main co except itself.\n\n![thread_model_3](img/thread_model_3.png)\n\nFinally, we get the big picture of libaco.\n\nThere is a \"[Proof of Correctness](#proof-of-correctness)\" part you may find really helpful if you want to dive into the internal of libaco or want to implement your own coroutine library.\n\nIt is also highly recommended to read the source code of the tutorials and benchmark next. The [benchmark](#benchmark) result is very impressive and enlightening too.\n\n# Build and Test\n\n## CFLAGS\n\n* `-m32`\n\nThe `-m32` option of gcc could help you to build the i386 application of libaco on a x86_64 machine. \n\n* C macro: `ACO_CONFIG_SHARE_FPU_MXCSR_ENV`\n\nYou could define the global C macro `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` to speed up the performance of context switching between coroutines slightly if none of your code would change the control words of FPU and MXCSR. If the macro is not defined, all the co would maintain its own copy of the FPU and MXCSR control words. It is recommended to always define this macro globally since it is very rare that one function needs to set its own special env of FPU or MXCSR instead of using the default env defined by the ISO C. But you may not need to define this macro if you are not sure of it.\n\n* C macro:`ACO_USE_VALGRIND`\n\nIf you want to use the tool memcheck of valgrind to test the application, then you may need to define the global C macro `ACO_USE_VALGRIND` to enable the friendly support of valgrind in libaco. But it is not recommended to define this macro in the final release build for the performance reason. You may also need to install the valgrind headers (package name is \"valgrind-devel\" in centos for example) to build libaco application with C macro `ACO_USE_VALGRIND` defined. (The memcheck of valgrind only works well with the standalone co currently. In the case of the shared stack used by more than one non-main co, the memcheck of valgrind would generate many false positive reports. For more information you may refer to \"[test_aco_tutorial_6.c](test_aco_tutorial_6.c)\".)\n\n* C macro:`ACO_USE_ASAN`\n\nThe global C macro `ACO_USE_ASAN` would enable the friendly support of [Address Sanitizer](https://en.wikipedia.org/wiki/AddressSanitizer) in libaco (support both gcc and clang).\n\n## Build\n\nTo build the test suites of libaco:\n\n```bash\n$ mkdir output\n$ bash make.sh\n```\n\nThere is also some detailed options in make.sh:\n\n```bash\n$bash make.sh -h\nUsage: make.sh [-o <no-m32|no-valgrind>] [-h]\n\nExample:\n    # default build\n    bash make.sh\n    # build without the i386 binary output\n    bash make.sh -o no-m32\n    # build without the valgrind supported binary output\n    bash make.sh -o no-valgrind\n    # build without the valgrind supported and i386 binary output\n    bash make.sh -o no-valgrind -o no-m32\n```\n\nIn short, using `-o no-valgrind ` if you have no valgrind headers installed, `-o no-m32` if you have no 32-bit gcc development tools installed on a AMD64 host.\n\nOn MacOS, you need to [replace](https://apple.stackexchange.com/questions/69223/how-to-replace-mac-os-x-utilities-with-gnu-core-utilities) the default `sed` and `grep` commands of MacOS with the GNU `sed` and `grep` to run `make.sh` and `test.sh` (such requirement would be removed in the future):\n\n```bash\n$ brew install grep --with-default-names\n$ brew install gnu-sed --with-default-names\n```\n\n## Test\n\n```bash\n$ cd output\n$ bash ../test.sh\n```\n\n# Tutorials\n\nThe `test_aco_tutorial_0.c` in this repository shows the basic usage of libaco. There is only one main co and one standalone non-main co in this tutorial. The comments in the source code is also very helpful.\n\nThe `test_aco_tutorial_1.c` shows the usage of some statistics of non-main co. The data structure of `aco_t` is very clear and is defined in `aco.h`.\n\nThere are one main co, one standalone non-main co and two non-main co (pointing to the same share stack) in `test_aco_tutorial_2.c`.\n\nThe `test_aco_tutorial_3.c` shows how to use libaco in a multithreaded process. Basically, one instance of libaco is designed only to work inside one certain thread to gain the maximum performance of context switching between coroutines. If you want to use libaco in multithreaded environment, simply to create one instance of libaco in each of the threads. There is no data-sharing across threads inside the libaco, and you have to deal with the data competition among multiple threads yourself (like what `gl_race_aco_yield_ct` does in this tutorial).\n\nOne of the rules in libaco is to call `aco_exit()` to terminate the execution of the non-main co instead of the default direct C style `return`, otherwise libaco will treat such behaviour as illegal and trigger the default protector whose job is to log the error information about the offending co to stderr and abort the process immediately. The `test_aco_tutorial_4.c` shows such \"offending co\" situation.\n\nYou could also define your own protector to substitute the default one (to do some customized \"last words\" stuff). But no matter in what case, the process will be aborted after the protector was executed. The `test_aco_tutorial_5.c` shows how to define the customized last word function.\n\nThe last example is a simple coroutine scheduler in `test_aco_tutorial_6.c`.\n\n# API\n\nIt would be very helpful to read the corresponding API implementation in the source code simultaneously when you are reading the following API description of libaco since the source code is pretty clear and easy to understand. And it is also recommended to read all the [tutorials](#tutorials) before reading the API document.\n\nIt is strongly recommended to read the [Best Practice](#best-practice) part before starting to write the real application of libaco (in addition to describing how to truly release libaco's extreme performance in your application, there is also a notice about the programming of libaco).\n\nNote: The version control of libaco follows the spec: [Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html). So the API in the following list have the compatibility guarantee. (Please note that there is no such guarantee for the API no in the list.)\n\n## aco_thread_init\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\nvoid aco_thread_init(aco_cofuncp_t last_word_co_fp);\n```\n\nInitializes the libaco environment in the current thread.\n\nIt will store the current control words of FPU and MXCSR into a thread-local global variable. \n\n* If the global macro `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` is not defined, the saved control words would be used as a reference value to set up the control words of the new co's FPU and MXCSR (in `aco_create`) and each co would maintain its own copy of FPU and MXCSR control words during later context switching.\n* If the global macro `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` is defined, then all the co shares the same control words of FPU and MXCSR. You may refer the \"[Build and Test](#build-and-test)\" part of this document for more information about this.\n\nAnd as it said in the `test_aco_tutorial_5.c` of the \"[Tutorials](#tutorials)\" part, when the 1st argument `last_word_co_fp` is not NULL then the function pointed by `last_word_co_fp` will substitute the default protector to do some \"last words\" stuff about the offending co before the process is aborted. In such last word function, you could use `aco_get_co` to get the pointer of the offending co. For more information, you may read `test_aco_tutorial_5.c`.\n\n## aco_share_stack_new\n\n```c\naco_share_stack_t* aco_share_stack_new(size_t sz);\n```\n\nEqual to `aco_share_stack_new2(sz, 1)`.\n\n## aco_share_stack_new2\n\n```c\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled);\n```\n\nCreates a new share stack with a advisory memory size of `sz` in bytes and may have a guard page (read-only) for the detection of stack overflow which is depending on the 2nd argument `guard_page_enabled`.\n\nTo use the default size value (2MB) if the 1st argument `sz` equals 0. After some computation of alignment and reserve, this function will ensure the final valid length of the share stack in return:\n\n* `final_valid_sz >= 4096`\n* `final_valid_sz >= sz`\n* `final_valid_sz % page_size == 0 if the guard_page_enabled != 0`\n\nAnd as close to the value of `sz` as possible.\n\nWhen the value of the 2nd argument `guard_page_enabled` is 1, the share stack in return would have one read-only guard page for the detection of stack overflow while a value 0 of `guard_page_enabled` means without such guard page.\n\nThis function will always return a valid share stack.\n\n## aco_share_stack_destroy\n\n```c\nvoid aco_share_stack_destroy(aco_share_stack_t* sstk);\n```\n\nDestory the share stack `sstk`.\n\nBe sure that all the co whose share stack is `sstk` is already destroyed when you destroy the `sstk`.\n\n## aco_create\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\naco_t* aco_create(aco_t* main_co, aco_share_stack_t* share_stack, \n        size_t save_stack_sz, aco_cofuncp_t co_fp, void* arg);\n```\n\nCreate a new co.\n\nIf it is a main_co you want to create, just call: `aco_create(NULL, NULL, 0, NULL, NULL)`. Main co is a special standalone coroutine whose share stack is the default thread stack. In the thread, main co is the coroutine who should be created and started to execute before all the other non-main coroutine does.\n\nOtherwise it is a non-main co you want to create:\n\n* The 1st argument `main_co` is the main co the co will `aco_yield` to in the future context switching. `main_co` must not be NULL;\n* The 2nd argument `share_stack` is the address of a share stack which the non-main co you want to create will use as its executing stack in the future. `share_stack` must not be NULL;\n* The 3rd argument `save_stack_sz` specifies the init size of the private save stack of this co. The unit is in bytes. A value of 0 means to use the default size 64 bytes. Since automatical resizing would happen when the private save stack is not big enough to hold the executing stack of the co when it has to yield the share stack it is occupying to another co, you usually should not worry about the value of `sz` at all. But it will bring some performance impact to the memory allocator when a huge amount (say 10,000,000) of the co resizes their private save stack continuously, so it is very wise and highly recommended to set the `save_stack_sz` with a value equal to the maximum value of `co->save_stack.max_cpsz` when the co is running (You may refer to the \"[Best Practice](#best-practice)\" part of this document for more information about such optimization);\n* The 4th argument `co_fp` is the entry function pointer of the co. `co_fp` must not be NULL;\n* The last argument `arg` is a pointer value and will set to `co->arg` of the co to create. It could be used as a input argument for the co.\n\nThis function will always return a valid co. And we name the state of the co in return as \"init\" if it is a non-main co you want to create.\n\n## aco_resume\n\n```c\nvoid aco_resume(aco_t* co);\n```\n\nYield from the caller main co and to start or continue the execution of `co`.\n\nThe caller of this function must be a main co and must be `co->main_co`. And the 1st argument `co` must be a non-main co.\n\nThe first time you resume a `co`, it starts running the function pointing by `co->fp`. If `co` has already been yielded, `aco_resume` restarts it and continues the execution.\n\nAfter the call of `aco_resume`, we name the state of the caller â€” main co as \"yielded\". \n\n## aco_yield\n\n```c\nvoid aco_yield();\n```\n\nYield the execution of `co` and resume `co->main_co`. The caller of this function must be a non-main co. And `co->main_co` must not be NULL.\n\nAfter the call of `aco_yield`, we name the state of the caller â€” `co` as \"yielded\".\n\n## aco_get_co\n\n```c\naco_t* aco_get_co();\n```\n\nReturn the pointer of the current non-main co. The caller of this function must be a non-main co.\n\n## aco_get_arg\n\n```c\nvoid* aco_get_arg();\n```\n\nEqual to `(aco_get_co()->arg)`. And also, the caller of this function must be a non-main co.\n\n## aco_exit\n\n```c\nvoid aco_exit();\n```\n\nIn addition do the same as `aco_yield()`, `aco_exit()` also set `co->is_end` to 1 thus to mark the `co` at the status of \"end\".\n\n## aco_destroy\n\n```c\nvoid aco_destroy(aco_t* co);\n```\n\nDestroy the `co`. The argument `co` must not be NULL. The private save stack would also been destroyed if the `co` is a non-main co.\n\n## MACROS\n\n### Version\n\n```c\n#define ACO_VERSION_MAJOR 1\n#define ACO_VERSION_MINOR 2\n#define ACO_VERSION_PATCH 4\n```\n\nThese 3 macros are defined in the header `aco.h` and the value of them follows the spec: [Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html).\n\n### aco_assert_override.h\n\n```c\n// provide the compiler with branch prediction information\n#define likely(x)               aco_likely(x)\n#define unlikely(x)             aco_unlikely(x)\n\n// override the default `assert` for convenience when coding\n#define assert(EX)              aco_assert(EX)\n\n// equal to `assert((ptr) != NULL)`\n#define assertptr(ptr)          aco_assertptr(ptr)\n\n// assert the successful return of memory allocation\n#define assertalloc_bool(b)     aco_assertalloc_bool(b)\n#define assertalloc_ptr(ptr)    aco_assertalloc_ptr(ptr)\n```\n\nYou could choose to include the header `\"aco_assert_override.h\"` to override the default C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" in the libaco application like [test_aco_synopsis.c](test_aco_synopsis.c) does (this header including should be at the last of the include directives list in the source file because the C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" is a C macro definition too) and define the 5 other macros in the above. Please do not include this header in the application source file if you want to use the default C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\".\n\nFor more details you may refer to the source file [aco_assert_override.h](aco_assert_override.h).\n\n# Benchmark\n\nDate: Sat Jun 30 UTC 2018.\n\nMachine: [c5d.large on AWS](https://aws.amazon.com/cn/blogs/aws/now-available-compute-intensive-c5-instances-for-amazon-ec2/).\n\nOS: RHEL-7.5 (Red Hat Enterprise Linux 7.5).\n\nHere is a brief summary of the benchmark part:\n\n* One time of the context switching between coroutines takes only about **10.29 ns** (in the case of standalone stack, where x87 and mxcsr control words are shared between coroutines);\n* One time of the context switching between coroutines takes only about **10.38 ns** (in the case of standalone stack, where each coroutine maintains their own x87 and mxcsr control words);\n* It is extremely memory efficient: it only costs **2.8 GB** of physical memory to run **10,000,000** coroutines simultaneously (with tcmalloc, where each coroutine has a **120 bytes** copy-stack size configuration).\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.shareFPUenv\n\n+build:x86_64\n+build:-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:share fpu & mxcsr control words between coroutines\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=152:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      230.00 ns/op    4347824.79 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.59 ns/op   48576413.55 op/s\n  -> acosw                                            40000000     0.412 s       10.29 ns/op   97152827.10 op/s\naco_destroy                                                  1     0.000 s      650.00 ns/op    1538461.66 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      200.00 ns/op    5000001.72 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.61 ns/op   48525164.25 op/s\n  -> acosw                                            40000000     0.412 s       10.30 ns/op   97050328.50 op/s\naco_destroy                                                  1     0.000 s      666.00 ns/op    1501501.49 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.50 ns/op   15266771.53 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.666 s       33.29 ns/op   30043022.64 op/s\naco_destroy                                            2000000     0.066 s       32.87 ns/op   30425152.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.130 s       65.22 ns/op   15332218.24 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.75 ns/op   29630018.73 op/s\naco_destroy                                            2000000     0.067 s       33.45 ns/op   29898311.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.42 ns/op   15286937.97 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.669 s       33.45 ns/op   29891277.59 op/s\naco_destroy                                            2000000     0.080 s       39.87 ns/op   25084242.29 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.224 s      111.86 ns/op    8940010.49 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.678 s       33.88 ns/op   29515473.53 op/s\naco_destroy                                            2000000     0.067 s       33.42 ns/op   29922412.68 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.74 ns/op   15211896.70 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.45 ns/op   26010724.94 op/s\naco_destroy                                            2000000     0.088 s       44.11 ns/op   22669240.25 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.240 s      123.97 ns/op    8066542.54 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.17 ns/op   30143409.55 op/s\naco_destroy                                           10000000     0.328 s       32.82 ns/op   30467658.05 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.659 s       65.94 ns/op   15165717.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.345 s       33.63 ns/op   29737708.53 op/s\naco_destroy                                           10000000     0.337 s       33.71 ns/op   29666697.09 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.654 s       65.38 ns/op   15296191.35 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.348 s       33.71 ns/op   29663992.77 op/s\naco_destroy                                           10000000     0.336 s       33.56 ns/op   29794574.96 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.653 s       65.29 ns/op   15316087.09 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.384 s       34.60 ns/op   28902221.24 op/s\naco_destroy                                           10000000     0.337 s       33.73 ns/op   29643682.93 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.652 s       65.19 ns/op   15340872.40 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.565 s       39.11 ns/op   25566255.73 op/s\naco_destroy                                           10000000     0.443 s       44.30 ns/op   22574242.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241722.94 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.947 s       47.36 ns/op   21114212.05 op/s\naco_destroy                                            2000000     0.125 s       62.35 ns/op   16039466.45 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.71 ns/op   15218784.72 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.948 s       47.39 ns/op   21101216.29 op/s\naco_destroy                                            2000000     0.125 s       62.73 ns/op   15941559.26 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.49 ns/op   15270258.18 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.069 s       53.44 ns/op   18714275.17 op/s\naco_destroy                                            2000000     0.122 s       61.05 ns/op   16378678.85 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.91 ns/op   15171336.62 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.190 s       59.48 ns/op   16813230.99 op/s\naco_destroy                                            2000000     0.123 s       61.26 ns/op   16324298.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.68 ns/op   15224361.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.828 s       91.40 ns/op   10941133.56 op/s\naco_destroy                                            2000000     0.145 s       72.56 ns/op   13781182.82 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.80 ns/op   15197461.34 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.829 s       91.47 ns/op   10932139.32 op/s\naco_destroy                                            2000000     0.149 s       74.70 ns/op   13387258.82 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.63 ns/op   15007426.35 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.224 s      211.20 ns/op    4734744.76 op/s\naco_destroy                                            1000000     0.093 s       93.36 ns/op   10711651.49 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.28 ns/op   15086953.73 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.222 s      211.12 ns/op    4736537.93 op/s\naco_destroy                                            1000000     0.094 s       94.09 ns/op   10627664.78 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.72 ns/op   14139923.59 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.191 s      209.56 ns/op    4771909.70 op/s\naco_destroy                                             100000     0.010 s      101.21 ns/op    9880747.28 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.62 ns/op   15010433.00 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.002 s      350.11 ns/op    2856228.03 op/s\naco_destroy                                             100000     0.016 s      159.69 ns/op    6262129.35 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.76 ns/op   15205994.08 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.918 s      595.90 ns/op    1678127.54 op/s\naco_destroy                                             100000     0.019 s      186.32 ns/op    5367189.85 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.03 ns/op   15865531.37 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917079.11 op/s\naco_destroy                                             100000     0.038 s      378.33 ns/op    2643225.42 op/s\n```\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.standaloneFPUenv\n\n+build:x86_64\n+build:undefined ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:each coroutine maintain each own fpu & mxcsr control words\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=160:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      273.00 ns/op    3663004.27 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.76 ns/op   48173877.75 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96347755.51 op/s\naco_destroy                                                  1     0.000 s      381.00 ns/op    2624672.26 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      212.00 ns/op    4716980.43 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.75 ns/op   48185455.26 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96370910.51 op/s\naco_destroy                                                  1     0.000 s      174.00 ns/op    5747123.38 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.63 ns/op   15237386.02 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.664 s       33.20 ns/op   30119155.82 op/s\naco_destroy                                            2000000     0.065 s       32.67 ns/op   30604542.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.33 ns/op   15305975.29 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.74 ns/op   29638360.61 op/s\naco_destroy                                            2000000     0.067 s       33.31 ns/op   30016633.42 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241767.78 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.678 s       33.88 ns/op   29518648.08 op/s\naco_destroy                                            2000000     0.079 s       39.74 ns/op   25163018.30 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.221 s      110.73 ns/op    9030660.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.684 s       34.18 ns/op   29253416.65 op/s\naco_destroy                                            2000000     0.067 s       33.40 ns/op   29938840.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.60 ns/op   15244077.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.43 ns/op   26021228.41 op/s\naco_destroy                                            2000000     0.087 s       43.74 ns/op   22863987.42 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.251 s      125.08 ns/op    7994958.59 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.19 ns/op   30133654.80 op/s\naco_destroy                                           10000000     0.329 s       32.85 ns/op   30439787.32 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.674 s       67.37 ns/op   14843796.57 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.354 s       33.84 ns/op   29548523.05 op/s\naco_destroy                                           10000000     0.339 s       33.90 ns/op   29494634.83 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.19 ns/op   14882262.88 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.361 s       34.02 ns/op   29393520.19 op/s\naco_destroy                                           10000000     0.338 s       33.77 ns/op   29609577.59 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.673 s       67.31 ns/op   14857716.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.371 s       34.27 ns/op   29181897.80 op/s\naco_destroy                                           10000000     0.339 s       33.85 ns/op   29540633.63 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.24 ns/op   14873017.10 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.548 s       38.71 ns/op   25835542.17 op/s\naco_destroy                                           10000000     0.446 s       44.61 ns/op   22415961.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.01 ns/op   15148290.52 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.22 ns/op   21177946.19 op/s\naco_destroy                                            2000000     0.124 s       61.99 ns/op   16132721.97 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.36 ns/op   15068860.85 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.20 ns/op   21187541.38 op/s\naco_destroy                                            2000000     0.124 s       62.21 ns/op   16073322.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.62 ns/op   15238955.93 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.072 s       53.61 ns/op   18652789.74 op/s\naco_destroy                                            2000000     0.121 s       60.42 ns/op   16551368.04 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.08 ns/op   15132547.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.198 s       59.88 ns/op   16699389.91 op/s\naco_destroy                                            2000000     0.121 s       60.71 ns/op   16471465.52 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.50 ns/op   15036985.95 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.853 s       92.63 ns/op   10796126.04 op/s\naco_destroy                                            2000000     0.146 s       72.87 ns/op   13723559.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.14 ns/op   15118324.13 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.855 s       92.75 ns/op   10781572.22 op/s\naco_destroy                                            2000000     0.152 s       75.79 ns/op   13194130.51 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.97 ns/op   14931921.56 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.218 s      210.90 ns/op    4741536.66 op/s\naco_destroy                                            1000000     0.093 s       93.16 ns/op   10734691.98 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.49 ns/op   15039274.31 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.216 s      210.81 ns/op    4743543.53 op/s\naco_destroy                                            1000000     0.094 s       93.97 ns/op   10641539.58 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.95 ns/op   14094724.73 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.190 s      209.52 ns/op    4772746.50 op/s\naco_destroy                                             100000     0.010 s      100.99 ns/op    9902271.51 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.49 ns/op   15040038.84 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.028 s      351.38 ns/op    2845942.55 op/s\naco_destroy                                             100000     0.016 s      159.15 ns/op    6283444.42 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.73 ns/op   15214482.36 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.879 s      593.95 ns/op    1683636.60 op/s\naco_destroy                                             100000     0.018 s      184.23 ns/op    5428119.00 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.41 ns/op   15771072.16 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917081.56 op/s\naco_destroy                                             100000     0.038 s      376.78 ns/op    2654073.13 op/s\n```\n\n# Proof of Correctness\n\nIt is essential to be very familiar with the standard of [Sys V ABI of intel386 and x86-64](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI) before you start to implement or prove a coroutine library.\n\nThe proof below has no direct description about the IP (instruction pointer), SP (stack pointer) and the saving/restoring between the private save stack and the share stack, since these things are pretty trivial and easy to understand when they are compared with the ABI constraints stuff.\n\n## Running Model\n\nIn the OS thread, the main coroutine `main_co` is the coroutine who should be created and started to execute first, before all the other non-main coroutines do.\n\nThe next diagram is a simple example of the context switching between main_co and co.\n\nIn this proof, we just assume that we are under Sys V ABI of intel386 since there is no fundamental differences between the Sys V ABI of intel386 and x86-64. We also assume that none of the code would change the control words of FPU and MXCSR.\n\n![proof_0](img/proof_0.png)\n\nThe next diagram is actually a symmetric coroutine's running model which has an unlimited number of non-main co-s and one main co. This is fine because the asymmetric coroutine is just a special case of the symmetric coroutine. To prove the correctness of the symmetric coroutine is a little more challenging than of the asymmetric coroutine and thus more fun it would become. (libaco only implemented the API of asymmetric coroutine currently because the semantic meaning of the asymmetric coroutine API is far more easy to understand and to use than the symmetric coroutine does.)\n\n![proof_1](img/proof_1.png)\n\nSince the main co is the 1st coroutine starts to run, the 1st context switching in this OS thread must be in the form of `acosw(main_co, co)` where the 2nd argument `co` is a non-main co.\n\n## Mathematical Induction\n\nIt is easy to prove that there only exists two kinds of state transfer in the above diagram:\n\n* yielded state co â†’ init state co\n* yielded state co â†’ yielded state co\n\nTo prove the correctness of `void* acosw(aco_t* from_co, aco_t* to_co)` implementation is equivalent to prove all the co constantly comply to the constraints of Sys V ABI before and after the call of `acosw`. We assume that the other part of binary code (except `acosw`) in the co had already comply to the ABI (they are normally generated by the compiler correctly).\n\nHere is a summary of the registers' constraints in the Function Calling Convention of Intel386 Sys V ABI:\n\n```\nRegisters' usage in the calling convention of the Intel386 System V ABI:\n    caller saved (scratch) registers:\n        C1.0: EAX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                hold the return value for `acosw`\n        C1.1: ECX,EDX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.2: Arithmetic flags, x87 and mxcsr flags\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.3: ST(0-7)\n            At the entry of a function call:\n                the stack of FPU must be empty\n            After the return of `acosw`:\n                the stack of FPU must be empty\n        C1.4: Direction flag\n            At the entry of a function call:\n                DF must be 0\n            After the return of `acosw`:\n                DF must be 0\n        C1.5: others: xmm*,ymm*,mm*,k*...\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n    callee saved registers:\n        C2.0: EBX,ESI,EDI,EBP\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                must be the same as it is at the entry of `acosw` \n        C2.1: ESP\n            At the entry of a function call:\n                must be a valid stack pointer\n                (alignment of 16 bytes, retaddr and etc...)\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw`\n        C2.2: control word of FPU & mxcsr\n            At the entry of a function call:\n                could be any configuration\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw` \n                (unless the caller of `acosw` assume `acosw` may    \\\n                change the control words of FPU or MXCSR on purpose \\\n                like `fesetenv`)\n```\n\n(For Intel386, the register usage is defined in the \"P13 - Table 2.3: Register Usage\" of [Sys V ABI Intel386 V1.1](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI), and for AMD64 is in \"P23 - Figure 3.4: Register Usage\" of [Sys V ABI AMD64 V1.0](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI).)\n\n**Proof:**\n\n1. yielded state co -> init state co:\n\n![proof_2](img/proof_2.png)\n\nThe diagram above is for the 1st case: \"yielded state co -> init state co\".\n\nConstraints: C 1.0, 1.1, 1.2, 1.5 (*satisfied* âœ“ )\n\nThe scratch registers below can hold any value at the entry of a function:\n\n```\nEAX,ECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\nConstraints: C 1.3, 1.4 (*satisfied* âœ“ )\n\nSince the stack of FPU must already be empty and the DF must already be 0 before `acosw(co, to_co)` was called (the binary code of co is already complied to the ABI), the constraint 1.3 and 1.4 is complied by `acosw`.\n\nConstraints: C 2.0, 2.1, 2.2 (*satisfied* âœ“ )\n\nC 2.0 & 2.1 is already satisfied. Since we already assumed that nobody will change the control words of FPU and MXCSR, C 2.2 is satisfied too.\n\n2. yielded state co -> yielded state co:\n\n![proof_3](img/proof_3.png)\n\nThe diagram above is for the 2nd case: yielded state co -> yielded state co.\n\nConstraints: C 1.0 (*satisfied* âœ“ )\n\nEAX already holding the return value when `acosw` returns back to to_co (resume).\n\nConstraints: C 1.1, 1.2, 1.5 (*satisfied* âœ“ )\n\nThe scratch registers below can hold any value at the entry of a function and after the return of `acosw`:\n\n```\nECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\nConstraints: C 1.3, 1.4 (*satisfied* âœ“ )\n\nSince the stack of FPU must already be empty and the DF must already be 0 before `acosw(co, to_co)` was called (the binary code of co is already complied to the ABI), the constraint 1.3 and 1.4 is complied by `acosw`.\n\nConstraints: C 2.0, 2.1, 2.2 (*satisfied* âœ“ )\n\nC 2.0 & 2.1 is satisfied because there is saving & restoring of the callee saved registers when `acosw` been called/returned. Since we already assumed that nobody will change the control words of FPU and MXCSR, C 2.2 is satisfied too.\n\n3. Mathematical induction:\n\nThe 1st `acosw` in the thread must be the 1st case: yielded state co -> init state co, and all the next `acosw` must be one of the 2 case above. Sequentially, we could prove that \"all the co constantly comply to the constraints of Sys V ABI before and after the call of `acosw`\". Thus, the proof is finished.\n\n## Miscellaneous\n\n### Red Zone\n\nThere is a new thing called [red zone](https://en.wikipedia.org/wiki/Red_zone_(computing)) in System V ABI x86-64:\n\n> The 128-byte area beyond the location pointed to by %rsp is considered to be reserved and shall not be modified by signal or interrupt handlers. Therefore, functions may use this area for temporary data that is not needed across function calls. In particular, leaf functions may use this area for their entire stack frame, rather than adjusting the stack pointer in the prologue and epilogue. This area is known as the red zone.\n\nSince the red zone is \"not preserved by the callee\", we just do not care about it at all in the context switching between coroutines (because the `acosw` is a leaf function).\n\n### Stack Pointer\n\n> The end of the input argument area shall be aligned on a 16 (32 or 64, if \\_\\_m256 or \\_\\_m512 is passed on stack) byte boundary. In other words, the value (%esp + 4) is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, %esp, always points to the end of the latest allocated stack frame.\n>\n> â€” Intel386-psABI-1.1:2.2.2 The Stack Frame\n\n> The stack pointer, %rsp, always points to the end of the latest allocated stack frame.\n>\n> â€” Sys V ABI AMD64 Version 1.0:3.2.2 The Stack Frame\n\nHere is a [bug example](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27) in Tencent's libco. The ABI states that the `(E|R)SP` should always point to the end of the latest allocated stack frame. But in file [coctx_swap.S](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27) of libco, the `(E|R)SP` had been used to address the memory on the heap.\n\n>**By default, the signal handler  is invoked  on  the normal process stack.**  It is possible to arrange that the signal handler uses an alternate stack; see sigalstack(2)  for  a discussion of how to do this and when it might be useful.\n>\n>â€” man 7 signal : Signal dispositions\n\nTerrible things may happen if the `(E|R)SP`  is pointing to the data structure on the heap when signal comes. (Using the `breakpoint` and `signal` commands of gdb could produce such bug conveniently. Although by using `sigalstack` to change the default signal stack could alleviate the problem, but still, that kind of usage of `(E|R)SP` still violates the ABI.)\n\n# Best Practice\n\nIn summary, if you want to gain the ultra performance of libaco, just keep the stack usage of the non-standalone non-main co at the point of calling `aco_yield` as small as possible. And be very careful if you want to pass the address of a local variable from one co to another co since the local variable is usually on the **share** stack. Allocating this kind of variables from the heap is always the wiser choice.\n\nIn detail, there are 5 tips:\n\n```\n       co_fp \n       /  \\\n      /    \\  \n    f1     f2\n   /  \\    / \\\n  /    \\  f4  \\\nyield  f3     f5\n```\n\n1. The stack usage of main co has no direct influence to the performance of context switching between coroutines (since it has a standalone execution stack);\n2. The stack usage of standalone non-main co has no direct influence to the performance of context switching between coroutines. But a huge amount of standalone non-main co would cost too much of virtual memory (due to the standalone stack), so it is not recommended to create huge amount of standalone non-main co in one thread;\n3. The stack usage of non-standalone (share stack with other coroutines) non-main co when it is been yielded (i.e. call `aco_yield` to yield back to main co) has a big impact to the performance of context switching between coroutines, as already indicated by the benchmark results. In the diagram above, the stack usage of function f2, f3, f4 and f5 has no direct influence over the context switching performance since there are no `aco_yield` when they are executing, whereas the stack usage of co_fp and f1 dominates the value of `co->save_stack.max_cpsz` and has a big influence over the context switching performance.\n\nThe key to keeping the stack usage of a function as low as possible is to allocate the local variables (especially the big ones) on the heap and manage their lifecycle manually instead of allocating them on the stack by default. The `-fstack-usage` option of gcc is very helpful about this.\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int ct = 0;\n    gl_ptr = &ct; // line 7\n    aco_yield();\n    check(ct);\n    int* ptr = &ct;\n    inc_p(ptr);   // line 11\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr); // line 16\n    aco_exit();\n}\n```\n\n4. In the above code snippet, we assume that co_fp0 & co_fp1 shares the same share stack (they are both non-main co) and the running sequence of them is \"co_fp0 -> co_fp1 -> co_fp0\". Since they are sharing the same stack, the address holding in `gl_ptr` in co_fp1 (line 16) has totally different semantics with the `gl_ptr` in line 7 of co_fp0, and that kind of code would probably corrupt the execution stack of co_fp1. But the line 11 is fine because variable `ct` and function `inc_p` are in the same coroutine context. Allocating that kind of variables (need to share with other coroutines) on the heap would simply solve such problems:\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int* ct_ptr = malloc(sizeof(int));\n    assert(ct_ptr != NULL);\n    *ct_ptr = 0;\n    gl_ptr = ct_ptr;\n    aco_yield();\n    check(*ct_ptr);\n    int* ptr = ct_ptr;\n    inc_p(ptr);\n    free(ct_ptr);\n    gl_ptr = NULL;\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr);\n    aco_exit();\n}\n```\n\n# TODO\n\nNew ideas are welcome!\n\n* Add a macro like `aco_mem_new` which is the combination of something like `p = malloc(sz); assertalloc_ptr(p)`.\n\n* Add a new API `aco_reset` to support the reusability of the coroutine objects.\n\n* Support other platforms (especially arm & arm64).\n\n# CHANGES\n\n```\nv1.2.4 Sun Jul 29 2018\n    Changed `asm` to `__asm__` in aco.h to support compiler's `--std=c99`\n    flag (Issue #16, proposed by Theo Schlossnagle @postwait).\nv1.2.3 Thu Jul 26 2018\n    Added support for MacOS;\n    Added support for shared library build of libaco (PR #10, proposed\n    by Theo Schlossnagle @postwait);\n    Added C macro ACO_REG_IDX_BP in aco.h (PR #15, proposed by\n    Theo Schlossnagle @postwait);\n    Added global C config macro ACO_USE_ASAN which could enable the\n    friendly support of address sanitizer (both gcc and clang) (PR #14,\n    proposed by Theo Schlossnagle @postwait);\n    Added README_zh.md.\nv1.2.2 Mon Jul 9 2018\n    Added a new option `-o <no-m32|no-valgrind>` to make.sh;\n    Correction about the value of macro ACO_VERSION_PATCH (issue #1 \n    kindly reported by Markus Elfring @elfring);\n    Adjusted some noncompliant naming of identifiers (double underscore\n    `__`) (issue #1, kindly proposed by Markus Elfring @elfring);\n    Supported the header file including by C++ (issue #4, kindly\n    proposed by Markus Elfring @elfring).\nv1.2.1 Sat Jul 7 2018\n    Fixed some noncompliant include guards in two C header files (\n    issue #1 kindly reported by Markus Elfring @elfring);\n    Removed the \"pure\" word from \"pure C\" statement since it is\n    containing assembly codes (kindly reported by Peter Cawley\n    @corsix);\n    Many updates in the README.md document.\nv1.2.0 Tue Jul 3 2018\n    Provided another header named `aco_assert_override.h` so user\n    could choose to override the default `assert` or not;\n    Added some macros about the version information.\nv1.1   Mon Jul 2 2018\n    Removed the requirement on the GCC version (>= 5.0).\nv1.0   Sun Jul 1 2018\n    The v1.0 release of libaco, cheers ðŸŽ‰ðŸŽ‰ðŸŽ‰\n```\n\n# Donation\n\nI'm a full-time open source developer. Any amount of the donations will be highly appreciated and could bring me great encouragement.\n\n* Paypal\n\n  [paypal.me link](https://www.paypal.me/00hnes)\n\n* Alipay (æ”¯ä»˜(å®|å¯¶))\n\n![qr_alipay](img/qr_alipay.png)\n\n* Wechat (å¾®ä¿¡)\n\n![qr_wechat](img/qr_wechat.png)\n\n# Thanks\n\nThe logo of libaco is generously donated by Peter Bech([Peteck](https://github.com/Peteck)). The logo is licensed under [CC BY-ND 4.0](https://creativecommons.org/licenses/by-nd/4.0/). The website of [libaco.org](https://libaco.org) is also kindly contributed by Peter Bech([Peteck](https://github.com/Peteck)).\n\n# Copyright and License\n\nCopyright (C) 2018, by Sen Han [<00hnes@gmail.com>](mailto:00hnes@gmail.com).\n\nUnder the Apache License, Version 2.0.\n\nSee the [LICENSE](LICENSE) file for details.\n"
        },
        {
          "name": "README_zh.md",
          "type": "blob",
          "size": 52.7978515625,
          "content": "# Name\n \nlibaco - ä¸€ä¸ªæžé€Ÿçš„ã€è½»é‡çº§ã€Cè¯­è¨€éžå¯¹ç§°åç¨‹åº“ã€‚\n\nè¿™ä¸ªé¡¹ç›®çš„ä»£å·æ˜¯Arkenstone ðŸ’Ž\n\nAsymmetric COroutine å’Œ Arkenstone æ˜¯ aco çš„åç§°æ¥æºã€‚\n\nå½“å‰æ”¯æŒSys V ABI Intel386å’ŒSys V ABI x86-64ã€‚\n\nä¸‹é¢æ˜¯è¿™ä¸ªé¡¹ç›®çš„ç®€è¦ä»‹ç»ï¼š\n\n- é™¤äº†ä¸€ä¸ªç”Ÿäº§çº§åˆ«çš„Cåç¨‹åº“å®žçŽ°ï¼Œè¿˜åŒ…å«äº†ä¸€ä¸ªè¯¦ç»†çš„æ–‡æ¡£æè¿°äº†å¦‚ä½•å®žçŽ°ä¸€ä¸ª *æœ€å¿«ä¸”æ­£ç¡®* çš„åç¨‹åº“ä»¥åŠå…¶ä¸¥æ ¼çš„æ•°å­¦è¯æ˜Žï¼›\n- æ ¸å¿ƒå®žçŽ°ä¸è¶…è¿‡ *700* è¡Œä»£ç ï¼Œä½†åŒ…å«äº†ä¸€ä¸ªåç¨‹åº“åº”è¯¥æœ‰çš„å…¨éƒ¨åŠŸèƒ½ï¼›\n- åœ¨AWS c5d.largeæœºå™¨ä¸Šçš„æ€§èƒ½æµ‹è¯•ç»“æžœæŒ‡å‡ºï¼Œä¸€æ¬¡åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢ä»…è€—æ—¶ *10 ns* ï¼ˆç‹¬ç«‹æ‰§è¡Œæ ˆï¼‰ï¼›\n- ç”¨æˆ·åœ¨åˆ›å»ºæ–°çš„åç¨‹æ—¶ï¼Œå¯ä»¥é€‰æ‹©å…¶æ‹¥æœ‰ä¸€ä¸ªç‹¬å çš„æ‰§è¡Œæ ˆï¼Œæˆ–è€…æ˜¯ä¸Žå…¶å®ƒä»»æ„æ•°é‡çš„åç¨‹ä¸€èµ·å…±äº«ä¸€ä¸ªæ‰§è¡Œæ ˆï¼›\n- æ‹¥æœ‰æžè‡´çš„å†…å­˜ä½¿ç”¨æ•ˆçŽ‡ï¼šä¸€åƒä¸‡ä¸ªåç¨‹å¹¶å‘æ‰§è¡Œä»…æ¶ˆè€—2.8GBçš„ç‰©ç†å†…å­˜ï¼ˆtcmallocï¼Œæ¯ä¸€ä¸ªåç¨‹ä½¿ç”¨120Bçš„å¤åˆ¶æ ˆï¼‰ã€‚\n\nä¸Šæ–‡ä¸­çš„\"æœ€å¿«\"æŒ‡çš„æ˜¯åœ¨æ»¡è¶³Sys V ABI Intel386æˆ–è€…AMD64çº¦æŸä¸‹æœ€å¿«çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å®žçŽ°ã€‚\n\n[![Build Status Travis](https://img.shields.io/travis/hnes/libaco.svg?style=flat-square&&branch=master)](https://travis-ci.org/hnes/libaco)\n[![Releases](https://img.shields.io/github/release/hnes/libaco/all.svg?style=flat-square)](https://github.com/hnes/libaco/releases)\n[![LICENSE](https://img.shields.io/github/license/hnes/libaco.svg?style=flat-square)](https://github.com/hnes/libaco/blob/master/LICENSE)\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?text=libaco+-+A+blazing+fast+and+lightweight+C+asymmetric+coroutine+library&url=https://github.com/hnes/libaco&via=00hnes)\n\nçƒ­çƒˆæ¬¢è¿ŽIssueså’ŒPRs ðŸŽ‰ðŸŽ‰ðŸŽ‰\n\næ³¨æ„: è¯·ä½¿ç”¨Releaseè€ŒéžMasteråˆ†æ”¯è¿›è¡Œæœ€ç»ˆçš„äºŒè¿›åˆ¶ç¨‹åºæž„å»ºã€‚\n\n[github-release]: https://github.com/hnes/libaco/releases\n\n# Table of Contents\n\n   * [Name](#name)\n   * [Table of Contents](#table-of-contents)\n   * [Status](#status)\n   * [Synopsis](#synopsis)\n   * [Description](#description)\n   * [Build and Test](#build-and-test)\n      * [CFLAGS](#cflags)\n      * [Build](#build)\n      * [Test](#test)\n   * [Tutorials](#tutorials)\n   * [API](#api)\n      * [aco_thread_init](#aco_thread_init)\n      * [aco_share_stack_new](#aco_share_stack_new)\n      * [aco_share_stack_new2](#aco_share_stack_new2)\n      * [aco_share_stack_destroy](#aco_share_stack_destroy)\n      * [aco_create](#aco_create)\n      * [aco_resume](#aco_resume)\n      * [aco_yield](#aco_yield)\n      * [aco_get_co](#aco_get_co)\n      * [aco_get_arg](#aco_get_arg)\n      * [aco_exit](#aco_exit)\n      * [aco_destroy](#aco_destroy)\n      * [MACROS](#macros)\n   * [Benchmark](#benchmark)\n   * [Proof of Correctness](#proof-of-correctness)\n      * [Running Model](#running-model)\n      * [Mathematical Induction](#mathematical-induction)\n      * [Miscellaneous](#miscellaneous)\n         * [Red Zone](#red-zone)\n         * [Stack Pointer](#stack-pointer)\n   * [Best Practice](#best-practice)\n   * [TODO](#todo)\n   * [CHANGES](#changes)\n   * [Donation](#donation)\n* [Copyright and License](#copyright-and-license)\n\n# Status\n\nå¯ä»¥ç”¨äºŽç”Ÿäº§çŽ¯å¢ƒã€‚\n\n# Synopsis\n\n```c\n#include \"aco.h\"    \n#include <stdio.h>\n\n// this header would override the default C `assert`;\n// you may refer the \"API : MACROS\" part for more details.\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct) {\n    printf(\"co: %p: yield to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_yield();\n    *((int*)(aco_get_arg())) = ct + 1;\n}\n\nvoid co_fp0() {\n    printf(\"co: %p: entry: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\"co: %p:  exit to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        ct++;\n    }\n    printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co: destroy and exit\\n\");\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n```\n```bash\n# default build\n$ gcc -g -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ ./test_aco_synopsis\nmain_co: yield to co: 0x1887120: 0\nco: 0x1887120: entry: 0\nco: 0x1887120: yield to main_co: 0\nmain_co: yield to co: 0x1887120: 1\nco: 0x1887120: yield to main_co: 1\nmain_co: yield to co: 0x1887120: 2\nco: 0x1887120: yield to main_co: 2\nmain_co: yield to co: 0x1887120: 3\nco: 0x1887120: yield to main_co: 3\nmain_co: yield to co: 0x1887120: 4\nco: 0x1887120: yield to main_co: 4\nmain_co: yield to co: 0x1887120: 5\nco: 0x1887120: yield to main_co: 5\nmain_co: yield to co: 0x1887120: 6\nco: 0x1887120:  exit to main_co: 6\nmain_co: destroy and exit\n# i386\n$ gcc -g -m32 -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n# share fpu and mxcsr env\n$ gcc -g -D ACO_CONFIG_SHARE_FPU_MXCSR_ENV -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis \n# with valgrind friendly support\n$ gcc -g -D ACO_USE_VALGRIND -O2 acosw.S aco.c test_aco_synopsis.c -o test_aco_synopsis\n$ valgrind --leak-check=full --tool=memcheck ./test_aco_synopsis\n```\n\nå…³äºŽæž„å»ºçš„æ›´å¤šä¿¡æ¯è¯·æŸ¥é˜…\"[Build and Test](#build-and-test)\"éƒ¨åˆ†ã€‚\n\n# Description\n\n![thread_model_0](img/thread_model_0.png)\n\nä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„æ‰§è¡ŒçŠ¶æ€ï¼ˆä¸€èˆ¬ä¸ºOSçº¿ç¨‹ï¼‰æœ‰å››ä¸ªåŸºæœ¬è¦ç´ :`{cpu_registers, code, heap, stack}`ã€‚\n\nç”±äºŽäºŒè¿›åˆ¶ç¨‹åºçš„ä»£ç æ‰§è¡Œä½ç½®ä¿¡æ¯ç”±`({E|R})?IP`å¯„å­˜å™¨å†³å®šï¼Œä¸”ä»Žå †ä¸­åˆ†é…å‡ºçš„å†…å­˜åœ°å€ä¿¡æ¯ä¸€èˆ¬ä¼šé—´æŽ¥æˆ–è€…ç›´æŽ¥çš„ä¿å­˜åœ¨è¿è¡Œæ ˆä¸­ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå››ä¸ªå…ƒç´ æœ€ç»ˆåŒ–ç®€ä¸º`{cpu_registers, stack}`ã€‚\n\n![thread_model_1](img/thread_model_1.png)\n\næˆ‘ä»¬å®šä¹‰`main co`ï¼ˆä¸»åç¨‹ï¼‰ä¸ºç‹¬å ä½¿ç”¨å½“å‰è¿è¡Œçº¿ç¨‹é»˜è®¤æ‰§è¡Œæ ˆçš„åç¨‹ã€‚ç”±äºŽmain coæ˜¯è¿™ä¸ªæ‰§è¡Œæ ˆçš„å”¯ä¸€ç”¨æˆ·ï¼Œæ‰€ä»¥ï¼Œåœ¨ä¸Žmain coç›¸å…³çš„åç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸­ï¼Œæˆ‘ä»¬ä»…éœ€è¦å¯¹main coçš„æŸäº›å¿…é¡»çš„å¯„å­˜å™¨è¿›è¡Œä¿å­˜å’Œæ¢å¤å³å¯ã€‚\n\næŽ¥ç€ï¼Œæˆ‘ä»¬å®šä¹‰`non-main co`ï¼ˆéžä¸»åç¨‹ï¼‰ä¸ºæ‰§è¡Œæ ˆä¸æ˜¯å½“å‰è¿è¡Œçº¿ç¨‹é»˜è®¤æ‰§è¡Œæ ˆï¼ˆè€Œæ˜¯å®ƒè‡ªå·±åˆ›å»ºçš„ï¼Œä¸”æœ‰å¯èƒ½ä¼šä¸Žå…¶ä»–non-main coä¸€èµ·å…±äº«è¿™ä¸ªæ‰§è¡Œæ ˆï¼‰çš„åç¨‹ã€‚æ‰€ä»¥ï¼Œ`non-main co`ä¼šæœ‰ä¸€ä¸ªç§æœ‰çš„ä¿å­˜æ ˆï¼Œå½“å®ƒè¢«åˆ‡æ¢è¿›æ¥ï¼ˆæˆ–è€…åˆ‡æ¢å‡ºåŽ»ï¼‰æ—¶ï¼Œä¼šä½¿ç”¨å®ƒçš„ç§æœ‰ä¿å­˜æ ˆè¿›è¡Œæ‰§è¡Œæ ˆçš„æ¢å¤ï¼ˆæˆ–è€…ä¿å­˜ï¼‰ï¼Œå› ä¸ºå½“å®ƒè¢«åˆ‡æ¢è¿›æ¥ï¼ˆæˆ–è€…åˆ‡æ¢å‡ºåŽ»ï¼‰æ—¶ï¼Œä¹‹å‰çš„ï¼ˆæˆ–è€…ä¹‹åŽçš„ï¼‰è¿è¡Œåç¨‹å¯èƒ½å·²ç»ä½¿ç”¨äº†ï¼ˆæˆ–è€…å¯èƒ½å°†ä¼šä½¿ç”¨ï¼‰è¿™ä¸ªæ‰§è¡Œæ ˆï¼ˆåœ¨libacoå®žçŽ°ä¸­ï¼Œç§æœ‰ä¿å­˜æ ˆçš„ä¿å­˜ç­–ç•¥æ˜¯æƒ°æ€§çš„æœ€ä¼˜æ–¹æ¡ˆï¼Œå…·ä½“è¯·å‚è§aco_resumeçš„æºç å®žçŽ°ç»†èŠ‚ï¼‰ã€‚\n\n![thread_model_2](img/thread_model_2.png)\n\nè¿™æ˜¯ä¸€ä¸ªnon-main coçš„ç‰¹æ®Šæƒ…å†µï¼Œåœ¨libacoä¸­æˆ‘ä»¬ç§°ä¹‹ä¸º`standalone non-main co`ï¼ˆç‹¬ç«‹éžä¸»åç¨‹ï¼‰ï¼Œå³ç‹¬å ä¸€ä¸ªæ‰§è¡Œæ ˆçš„éžä¸»åç¨‹ã€‚åœ¨ä¸Žstandalone non-main coç›¸å…³çš„ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸­ï¼Œå¯¹å…¶åªéœ€è¦è¿›è¡Œä¸€äº›å¿…é¡»å¯„å­˜å™¨çš„ä¿å­˜æˆ–æ¢å¤å³å¯ï¼ˆå› ä¸ºå®ƒçš„æ‰§è¡Œæ ˆæ˜¯ç‹¬å çš„ï¼Œåœ¨å®ƒè¢«åˆ‡æ¢å‡ºçš„æ—¶é—´é‡Œï¼Œå®ƒçš„æ‰§è¡Œæ ˆçš„çŠ¶æ€æ˜¯ä¸å˜çš„ï¼‰ã€‚\n\n![thread_model_3](img/thread_model_3.png)\n\næœ€ç»ˆï¼Œæˆ‘ä»¬å¾—åˆ°äº†libacoçš„å…¨å±€é¸Ÿçž°å›¾ã€‚\n\nå¦‚æžœä½ æƒ³è¦å®žçŽ°è‡ªå·±çš„åç¨‹åº“æˆ–è€…æ›´åŠ æ·±å…¥çš„äº†è§£libacoçš„å®žçŽ°ï¼Œ\"[Proof of Correctness](#proof-of-correctness)\" éƒ¨åˆ†å°†ä¼šéžå¸¸æœ‰ç”¨ã€‚\n\næŽ¥ä¸‹æ¥ï¼Œå¯ä»¥é˜…è¯»[æ•™ç¨‹](#tutorials)æˆ–è€…æ€§èƒ½æµ‹è¯•éƒ¨åˆ†ã€‚[æ€§èƒ½æµ‹è¯•çš„æŠ¥å‘Š](#benchmark)ä»¤äººå°è±¡æ·±åˆ»åŒæ—¶å‘äººæ·±çœã€‚\n\n# Build and Test\n\n## CFLAGS\n\n* `-m32`\n\nç¼–è¯‘å™¨é€‰é¡¹`-m32`èƒ½å¤Ÿå¸®åŠ©ç”¨æˆ·åœ¨AMD64å¹³å°ä¸Šæž„å»ºlibacoçš„i386äºŒè¿›åˆ¶ç¨‹åºã€‚\n\n* C macro: `ACO_CONFIG_SHARE_FPU_MXCSR_ENV`\n\nå¦‚æžœç”¨æˆ·çš„ç¨‹åºåœ¨è¿è¡ŒæœŸé—´ä¸ä¼šæ›´æ”¹FPUå’ŒMXCSRçš„æŽ§åˆ¶å­—ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹©å®šä¹‰å…¨å±€Cå® `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` ä»¥è½»å¾®åœ°åŠ å¿«åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢çš„é€Ÿåº¦ã€‚å¦‚æžœè¯¥å®æ²¡æœ‰è¢«å®šä¹‰ï¼Œæ¯ä¸€ä¸ªåç¨‹å°†ä¼šç»´æŠ¤ä¸€ä»½å±žäºŽè‡ªå·±çš„ç‹¬ç«‹FPUå’ŒMXCSRæŽ§åˆ¶å­—çŽ¯å¢ƒã€‚ç”±äºŽæ›´æ”¹FPUæˆ–è€…MXCSRæŽ§åˆ¶å­—çš„åº”ç”¨ä»£ç æ˜¯éžå¸¸å°‘è§çš„ï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©æ€»æ˜¯å…¨å±€å®šä¹‰è¯¥å®ï¼Œä½†æ˜¯å¦‚æžœå¹¶ä¸èƒ½ä¿è¯è¿™ä¸ªçº¦æŸï¼Œç”¨æˆ·åº”è¯¥é€‰æ‹©ä¸å®šä¹‰è¯¥å®ã€‚\n\n* C macro:`ACO_USE_VALGRIND`\n\nå¦‚æžœç”¨æˆ·æƒ³è¦ä½¿ç”¨valgrindçš„memcheckå·¥å…·å¯¹libacoçš„åº”ç”¨ç¨‹åºè¿›è¡Œæµ‹è¯•ï¼Œåˆ™éœ€è¦åœ¨æž„å»ºæ—¶å®šä¹‰å…¨å±€Cå® `ACO_USE_VALGRIND` ä»¥ä½¿èƒ½libacoå¯¹valgrind memcheckæ—¶çš„æ”¯æŒã€‚ ç”±äºŽæ€§èƒ½çš„åŽŸå› ï¼Œåœ¨æœ€ç»ˆçš„ç”Ÿäº§äºŒè¿›åˆ¶æž„å»ºä¸­å¹¶ä¸æŽ¨èä½¿ç”¨æ­¤å®ã€‚åœ¨å…¨å±€å®šä¹‰äº†æ­¤å®çš„libacoåº”ç”¨æž„å»ºä¹‹å‰ï¼Œç”¨æˆ·éœ€è¦å®‰è½¬valgrindçš„Cå¤´æ–‡ä»¶ï¼ˆä»¥Centosä¸ºä¾‹ï¼Œè¿™ä¸ªå¼€å‘åŒ…çš„åç§°ä¸º\"valgrind-devel\"ï¼‰ã€‚valgrindçš„memcheckçŽ°åœ¨åªæ”¯æŒæ‹¥æœ‰ç‹¬ç«‹è¿è¡Œæ ˆçš„åç¨‹ï¼Œmemcheckåœ¨å¯¹ä½¿ç”¨å…±äº«æ ˆçš„åç¨‹è¿›è¡Œæ£€æµ‹æ—¶ä¼šè¾“å‡ºå¾ˆå¤šçš„è¯¯æŠ¥ã€‚æ›´å¤šçš„ä¿¡æ¯å¯ä»¥æŸ¥çœ‹\"[test_aco_tutorial_6.c](test_aco_tutorial_6.c)\"ã€‚\n\n## Build\n\n```bash\n$ mkdir output\n$ bash make.sh\n```\n\nmake.shè„šæœ¬ä¸­æœ‰ä¸€äº›æ›´åŠ è¯¦ç»†çš„æž„å»ºå‚æ•°ï¼š\n\n```bash\n$bash make.sh -h\nUsage: make.sh [-o <no-m32|no-valgrind>] [-h]\n\nExample:\n    # default build\n    bash make.sh\n    # build without the i386 binary output\n    bash make.sh -o no-m32\n    # build without the valgrind supported binary output\n    bash make.sh -o no-valgrind\n    # build without the valgrind supported and i386 binary output\n    bash make.sh -o no-valgrind -o no-m32\n```\n\nç®€è€Œè¨€ä¹‹ï¼Œå¦‚æžœç³»ç»Ÿä¸­æ²¡æœ‰valgrindçš„Cå¤´æ–‡ä»¶ï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨å‚æ•° `-o no-valgrind `è¿›è¡Œæµ‹è¯•é›†çš„æž„å»ºï¼›å¦‚æžœç³»ç»Ÿä¸ºAMD64å¹³å°å¹¶ä¸”æ²¡æœ‰å®‰è£…32ä½çš„Cç¼–è¯‘å™¨å¼€å‘å·¥å…·é“¾ï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨å‚æ•° `-o no-m32` è¿›è¡Œæµ‹è¯•é›†çš„æž„å»ºã€‚\n\n## Test\n\n```bash\n$ cd output\n$ bash ../test.sh\n```\n\n# Tutorials\n\næ–‡ä»¶`test_aco_tutorial_0.c`ä¸­åŒ…å«äº†libacoçš„åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹ã€‚åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼ŒåªåŒ…å«äº†ä¸€ä¸ª main co å’Œä¸€ä¸ª standalone non-main coï¼Œå¦å¤–ï¼Œä»£ç ä¸­çš„æ³¨é‡Šä¹Ÿå¾ˆæœ‰ç”¨ã€‚\n\næ–‡ä»¶`test_aco_tutorial_1.c`ä¸­åŒ…å«äº†libacoåç¨‹çš„è¿è¡Œç»Ÿè®¡ä¿¡æ¯çš„ä½¿ç”¨ç¤ºä¾‹ã€‚ç±»åž‹`aco_t`çš„å®šä¹‰åœ¨`aco.h`ä¸­å¹¶ä¸”æ¸…æ™°æ˜“æ‡‚ã€‚\n\nåœ¨æ–‡ä»¶`test_aco_tutorial_2.c`ä¸­ï¼ŒåŒ…å«äº†ä¸€ä¸ªstandalone non-main coå’Œä¸¤ä¸ªå…±äº«åŒä¸€ä¸ªæ‰§è¡Œæ ˆçš„non-main coã€‚\n\næ–‡ä»¶`test_aco_tutorial_3.c`å±•ç¤ºäº†å¦‚ä½•åœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸­ä½¿ç”¨libacoã€‚ä»Žæ ¹æœ¬ä¸Šè®²ï¼Œä¸ºäº†èŽ·å¾—æœ€å¥½çš„åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢æ€§èƒ½ï¼Œåœ¨è®¾è®¡æ—¶ä¸€ä¸ªlibacoçš„è¿è¡Œå®žä¾‹åº”è¯¥ä»…ä»…å·¥ä½œåœ¨ä¸€ä¸ªå›ºå®šçš„çº¿ç¨‹ä¸­ã€‚è¿™æ ·ï¼Œå¦‚æžœä½ æƒ³åœ¨å¤šçº¿ç¨‹ä¸­ä½¿ç”¨libacoï¼Œåªéœ€è¦åˆ†åˆ«åœ¨å„ä¸ªçº¿ç¨‹ä¸­åƒåœ¨å•çº¿ç¨‹ä¸­é‚£æ ·ä½¿ç”¨libacoä¸€æ ·ä½¿ç”¨å®ƒå³å¯ã€‚åœ¨libacoå†…éƒ¨æ²¡æœ‰ä»»ä½•çš„çº¿ç¨‹é—´æ•°æ®å…±äº«ï¼›åœ¨å¤šçº¿ç¨‹åœºæ™¯ä¸‹ï¼Œç”¨æˆ·éœ€è¦è‡ªå·±å¤„ç†å¥½è‡ªå·±çš„æ•°æ®ç«žäº‰é—®é¢˜ï¼ˆå°±åƒæ­¤å®žä¾‹ä¸­`gl_race_aco_yield_ct`çº¿ç¨‹é—´å…±äº«å˜é‡åšçš„é‚£æ ·ï¼‰ã€‚\n\nåœ¨libacoä¸­ï¼Œè¯·è°ƒç”¨API `aco_exit()`æ¥è¿›è¡Œç»ˆç»“non-main coçš„æ‰§è¡Œï¼Œè€Œä¸è¦ç›´æŽ¥ä½¿ç”¨é»˜è®¤çš„Cå…³é”®å­—`return`è¿›è¡Œè¿”å›žï¼ˆå¦åˆ™libacoä¼šå°†è¿™ç§è¡Œä¸ºå½“åšå¼‚å¸¸äº‹ä»¶å¹¶è§¦å‘é»˜è®¤çš„protectoræµç¨‹ï¼šè¾“å‡ºé”™è¯¯ä¿¡æ¯è‡³stderrå¹¶ç«‹å³è°ƒç”¨`abort`æ¥ç»ˆç»“è¿›ç¨‹çš„æ‰§è¡Œï¼‰ã€‚æºæ–‡ä»¶`test_aco_tutorial_4.c`ä¸­ç¤ºèŒƒäº†ä¸€ä¸ªè¿èƒŒäº†æ­¤è§„åˆ™çš„åç¨‹å®žä¾‹ã€‚\n\nåŒæ—¶ï¼Œç”¨æˆ·ä¹Ÿå¯ä»¥é€‰æ‹©å®šåˆ¶è‡ªå·±æƒ³è¦çš„protectorå¤„ç†é€»è¾‘ï¼ˆæ¯”å¦‚åŽ»åšä¸€äº›è‡ªå®šä¹‰çš„\"last words\"å³â€œé—å˜±â€ä»»åŠ¡)ã€‚ä½†æ˜¯æ— è®ºå¦‚ä½•ï¼Œå½“protectorè¢«æ‰§è¡Œå®Œæ¯•åŽï¼Œå½“å‰è¿›ç¨‹ä¸€å®šä¼šè¢«`abort`ã€‚æºæ–‡ä»¶`test_aco_tutorial_5.c`ä¸­æè¿°äº†å¦‚ä½•è‡ªå®šä¹‰protectorã€‚\n\næºæ–‡ä»¶`test_aco_tutorial_6.c`ä¸­ç¤ºèŒƒäº†ä¸€ä¸ªç®€å•çš„åç¨‹è°ƒåº¦å™¨çš„å®žä¾‹ã€‚\n\n# API\n\nåœ¨é˜…è¯»ä¸‹é¢çš„APIæ–‡æ¡£æ—¶ï¼Œå»ºè®®ä¹Ÿå¯ä»¥åŒæ—¶é˜…è¯»å¯¹åº”æºç ä¸­çš„å®žçŽ°ï¼Œå› ä¸ºæºç éžå¸¸çš„æ¸…æ™°æ˜“è¯»ã€‚åŒæ—¶ï¼Œåœ¨é˜…è¯»APIæ–‡æ¡£ä¹‹å‰ï¼ŒæŽ¨èå…ˆé˜…è¯»[æ•™ç¨‹](#tutorials)éƒ¨åˆ†ã€‚\n\nå¦å¤–ï¼Œåœ¨å¼€å§‹å†™libacoçš„åº”ç”¨ä¹‹å‰ï¼Œå¼ºçƒˆå»ºè®®å…ˆè¿›è¡Œé˜…è¯»[æœ€ä½³å®žè·µ](#best-practice)ç« èŠ‚ï¼Œæ­¤ç« èŠ‚ä¸­é™¤äº†æè¿°å¦‚ä½•åº”ç”¨libacoä»¥è®©å…¶æ€§èƒ½å‘æŒ¥åˆ°æžè‡´ï¼Œä¹Ÿæè¿°äº†ä¸€äº›libacoç¼–ç¨‹æ—¶çš„æ³¨æ„äº‹é¡¹ã€‚\n\næ³¨æ„ï¼šlibacoçš„ç‰ˆæœ¬æŽ§åˆ¶éµä»Ž[Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html)æ ‡å‡†ã€‚æ‰€ä»¥ï¼Œä¸‹é¢åˆ—å‡ºçš„æ‰€æœ‰APIå‡æœ‰æ ‡å‡†ä¸­æ‰€æè¿°çš„å…¼å®¹æ€§ä¿è¯ï¼ˆè¯·æ³¨æ„ï¼Œæ²¡æœ‰åœ¨ä¸‹é¢APIåˆ—è¡¨ä¸­çš„å‡½æ•°è°ƒç”¨åˆ™æ²¡æœ‰å¦‚æ­¤çš„ä¿è¯ï¼‰ã€‚\n\n## aco_thread_init\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\nvoid aco_thread_init(aco_cofuncp_t last_word_co_fp);\n```\n\nåœ¨å½“å‰è¿è¡Œçº¿ç¨‹ä¸­åˆå§‹åŒ–libacoçš„æ‰§è¡ŒçŽ¯å¢ƒã€‚\n\næ­¤APIä¼šå°†å½“å‰FPUä¸ŽMXCSRçš„æŽ§åˆ¶å­—ä¿å­˜åˆ°ä¸€ä¸ªTLSå…¨å±€å˜é‡ä¸­ã€‚\n\n* å¦‚æžœå…¨å±€Cå® `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` æ²¡æœ‰è¢«å®šä¹‰ï¼Œä¿å­˜çš„æŽ§åˆ¶å­—æŽ¥ä¸‹æ¥ä¼šè¢«ç”¨æ¥åˆå§‹åŒ–æ–°åç¨‹ï¼ˆ`aco_create`ï¼‰çš„FPUä¸ŽMXCSRçš„æŽ§åˆ¶å­—ï¼Œç„¶åŽæ¯ä¸€ä¸ªåç¨‹éƒ½å°†ä¼šåœ¨ä»¥åŽçš„åç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸­ç‹¬ç«‹ç»´æŠ¤è¿™ä¸€ä»½å±žäºŽè‡ªå·±çš„FPUä¸ŽMXCSRçš„æŽ§åˆ¶å­—é…ç½®ã€‚\n* å¦‚æžœå…¨å±€Cå® `ACO_CONFIG_SHARE_FPU_MXCSR_ENV` è¢«å®šä¹‰äº†ï¼Œæ‰€æœ‰çš„åç¨‹å°†ä¼šå…±äº«åŒä¸€ä»½FPUä¸ŽMXCSRçš„æŽ§åˆ¶å­—é…ç½®ã€‚å¦‚æžœåœ¨è¿™æ–¹é¢æƒ³äº†è§£æ›´å¤šï¼Œè¯·æŸ¥é˜… \"[Build and Test](#build-and-test)\" éƒ¨åˆ†ã€‚\n\nå°±åƒåœ¨ \"[Tutorials](#tutorials)\" ä¸­å…³äºŽ `test_aco_tutorial_5.c` éƒ¨åˆ†æ‰€é™ˆè¿°çš„é‚£æ ·ï¼ŒAPIçš„ç¬¬ä¸€ä¸ªå…¥å‚`last_word_co_fp`ä¸ºç”¨æˆ·è‡ªå®šä¹‰çš„ \"last words\" å‡½æ•°æŒ‡é’ˆ, å¦‚æžœå®ƒçš„å€¼éžNULLï¼Œå°†ä¼šå–ä»£é»˜è®¤çš„protector handlerï¼ˆåœ¨è¿›ç¨‹abortä¹‹å‰åšä¸€äº› \"last words\" ç›¸å…³çš„äº‹æƒ…ï¼‰ã€‚åœ¨è¿™æ ·çš„ \"last word\" å‡½æ•°ä¸­ï¼Œç”¨æˆ·å¯ä»¥è°ƒç”¨API `aco_get_co` ä»¥èŽ·å¾—å½“å‰åç¨‹çš„æŒ‡é’ˆã€‚å¯ä»¥é€šè¿‡é˜…è¯»æºæ–‡ä»¶`test_aco_tutorial_5.c`ä»¥èŽ·å¾—ä¸Žæ­¤ç›¸å…³çš„æ›´å¤šä¿¡æ¯ã€‚\n\n## aco_share_stack_new\n\n```c\naco_share_stack_t* aco_share_stack_new(size_t sz);\n```\n\nç­‰ä»·äºŽè°ƒç”¨`aco_share_stack_new2(sz, 1)`ã€‚\n\n## aco_share_stack_new2\n\n```c\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled);\n```\n\nåˆ›å»ºä¸€ä¸ªæ–°çš„æ‰§è¡Œæ ˆï¼Œå…¥å‚`sz`æ˜¯å¯¹è¦åˆ›å»ºæ‰§è¡Œæ ˆçš„å¤§å°çš„ä¸€ä¸ªå»ºè®®æ€§å­—èŠ‚å€¼ï¼Œå…¥å‚`guard_page_enabled`å†³å®šäº†è¦åˆ›å»ºçš„æ‰§è¡Œæ ˆæ˜¯å¦ä¼šæ‹¥æœ‰ä¸€ä¸ªåªè¯»çš„ \"guard page\" ï¼ˆå¯ä»¥ç”¨æ¥æ£€æµ‹æ‰§è¡Œæ ˆçš„æº¢å‡ºï¼‰ã€‚\n\nå½“ç¬¬ä¸€å…¥å‚`sz`ä¸º0æ—¶ï¼Œè¡¨ç¤ºé€‰æ‹©ä½¿ç”¨é»˜è®¤çš„å¤§å°å€¼ï¼ˆ2MBï¼‰ã€‚ç»è¿‡ä¸€ç³»åˆ—å…³äºŽå†…å­˜å¯¹é½å’Œä¿ç•™çš„è¿ç®—åŽï¼Œè¯¥APIä¿è¯æœ€ç»ˆåˆ›å»ºå‡ºçš„æ‰§è¡Œæ ˆæ»¡è¶³ä¸‹åˆ—æ‰€æœ‰æ¡ä»¶ï¼š\n\n* `final_valid_sz >= 4096`\n* `final_valid_sz >= sz`\n* `final_valid_sz % page_size == 0 if the guard_page_enabled != 0`\n\nå¹¶ä¸”å°½å¯èƒ½çš„æŽ¥è¿‘å…¥å‚`sz`çš„å€¼ã€‚\n\nå½“ç¬¬äºŒå…¥å‚`guard_page_enabled`çš„å€¼ä¸º1æ—¶ï¼Œåˆ›å»ºçš„æ‰§è¡Œæ ˆå°†ä¼šæ‹¥æœ‰ä¸€ä¸ªåªè¯»çš„ç”¨æ¥æ£€æµ‹æ‰§è¡Œæ ˆæº¢å‡ºçš„ \"guard page\"ï¼Œä¸º0æ—¶åˆ™ä¸ä¼šæ‹¥æœ‰è¿™æ ·çš„ \"guard page\" ã€‚\n\næ­¤å‡½æ•°æ€»æ˜¯æˆåŠŸåœ°è¿”å›žä¸€ä¸ªå¯ç”¨çš„æ‰§è¡Œæ ˆã€‚\n\n## aco_share_stack_destroy\n\n```c\nvoid aco_share_stack_destroy(aco_share_stack_t* sstk);\n```\n\né”€æ¯æ‰§è¡Œæ ˆ`sstk`ã€‚\n\nåœ¨é”€æ¯æ‰§è¡Œæ ˆ`sstk`ä¹‹å‰ï¼Œè¯·ç¡®å®šæ‰€æœ‰ä½¿ç”¨è¿™ä¸ªæ‰§è¡Œæ ˆçš„åç¨‹å·²ç»å…¨éƒ¨è¢«é”€æ¯ã€‚\n\n## aco_create\n\n```c\ntypedef void (*aco_cofuncp_t)(void);\naco_t* aco_create(aco_t* main_coï¼Œaco_share_stack_t* share_stack, \n        size_t save_stack_sz, aco_cofuncp_t co_fp, void* arg);\n```\n\nåˆ›å»ºä¸€ä¸ªæ–°çš„åç¨‹ã€‚\n\nå¦‚æžœæƒ³åˆ›å»ºä¸€ä¸ªmain coï¼Œç›´æŽ¥è°ƒç”¨ï¼š`aco_create(NULL, NULL, 0, NULL, NULL)`ã€‚Main coæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„standalone coroutineï¼Œå®ƒçš„æ‰§è¡Œæ ˆæ˜¯å½“å‰çº¿ç¨‹é»˜è®¤çš„æ‰§è¡Œæ ˆã€‚åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­ï¼Œmain co æ˜¯è¢«ç¬¬ä¸€ä¸ªåˆ›å»ºå¹¶ä¸”æ˜¯åœ¨æ‰€æœ‰å…¶ä»–non-main coroutineä¹‹å‰å°±å·²ç»å¼€å§‹è¿è¡Œäº†çš„åç¨‹ã€‚\n\nå¦‚æžœæƒ³ä½¿ç”¨æ­¤APIåˆ›å»ºä¸€ä¸ªnon-main coï¼š\n\n* ç¬¬ä¸€ä¸ªå…¥å‚`main_co`æŒ‡å‘å½“å‰çº¿ç¨‹ä¸­çš„main coï¼Œåˆ›å»ºå‡ºçš„non-main coä»¥åŽåœ¨è°ƒç”¨API `aco_yield`æ—¶å°†ä¼šå°†æ‰§è¡Œæµç¨‹è½¬äº¤ç»™å…¥å‚`main_co`æŒ‡å‘çš„main coï¼Œå…¥å‚`main co`å¿…ç„¶éžNULLï¼›\n* ç¬¬äºŒä¸ªå…¥å‚`share_stack`æŒ‡å‘è¦åˆ›å»ºçš„non-main coä»¥åŽè¦ä½¿ç”¨çš„æ‰§è¡Œæ ˆã€‚`share_stack` å¿…ç„¶éžNULLã€‚\n* ç¬¬ä¸‰ä¸ªå…¥å‚`save_stack_sz`æŒ‡å®šè¦åˆ›å»ºçš„non-main coçš„ç§æœ‰ä¿å­˜æ ˆçš„åˆå§‹å¤§å°ï¼Œå…¶å•ä½ä¸ºå­—èŠ‚ã€‚å€¼0è¡¨ç¤ºä½¿ç”¨é»˜è®¤çš„åˆå§‹å¤§å°64å­—èŠ‚ã€‚ç”±äºŽåœ¨ä»¥åŽçš„non-main coæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå¦‚æžœå…¶ç§æœ‰ä¿å­˜æ ˆä¸å¤Ÿå¤§æ—¶å°†ä¼šè¿›è¡Œè‡ªåŠ¨åœ°å¤§å°è°ƒæ•´ï¼Œæ‰€ä»¥ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œç”¨æˆ·ä¸éœ€è¦æ‹…å¿ƒå®ƒçš„å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æžœæœ‰å·¨é‡çš„åç¨‹(æ¯”å¦‚ä¸€åƒä¸‡ä¸ª)ç›¸ç»§çš„è¿›è¡Œå¤§å°è°ƒæ•´ï¼Œå°†ä¼šç»™å†…å­˜åˆ†é…å™¨å¸¦æ¥ä¸€äº›æ€§èƒ½å†²å‡»ï¼Œæ‰€ä»¥ä¸€ä¸ªæ›´åŠ æ˜Žæ™ºçš„é€‰æ‹©æ˜¯ï¼Œç»™å…¥å‚`save_stack_sz`èµ‹äºˆä¸€ä¸ªåç¨‹è¿è¡ŒæœŸé—´ä¿å­˜æ ˆéœ€è¦çš„æœ€å¤§å€¼ï¼ˆå³`co->save_stack.max_cpsz`çš„å€¼ï¼‰ï¼ŒæŸ¥é˜… \"[æœ€ä½³å®žè·µ](#best-practice)\" éƒ¨åˆ†ä»¥èŽ·å¾—ä¸Žæ­¤ç›¸å…³çš„æ›´å¤šä¼˜åŒ–ä¿¡æ¯ã€‚\n* ç¬¬å››ä¸ªå…¥å‚`co_fp`æ˜¯è¦åˆ›å»ºnon-main coçš„å…¥å£å‡½æ•°æŒ‡é’ˆã€‚`co_fp`å¿…ç„¶éžNULLã€‚\n* æœ€åŽä¸€ä¸ªå…¥å‚`arg`ä¸ºä¸€ä¸ªæŒ‡é’ˆå€¼ï¼Œå°†ä¼šè®¾ç½®ä¸ºè¦åˆ›å»ºnon-main coçš„`co->arg`çš„å€¼ï¼Œ`co->arg`ä¸€èˆ¬ç”¨æ¥ä½œä¸ºåç¨‹çš„è¾“å…¥å‚æ•°ã€‚\n\næ­¤APIå°†ä¼šæ°¸è¿œåœ°æˆåŠŸè¿”å›žä¸€ä¸ªå¯ç”¨çš„åç¨‹ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬å®šä¹‰`aco_create`è¿”å›žçš„non-main coå¤„äºŽ \"init\" çŠ¶æ€ã€‚\n\n## aco_resume\n\n```c\nvoid aco_resume(aco_t* co);\n```\n\nä»Žè°ƒç”¨è€…å¤„Yieldå‡ºæ¥å¹¶å¼€å§‹æˆ–è€…ç»§ç»­åç¨‹`co`çš„æ‰§è¡Œã€‚\n\næ­¤APIçš„è°ƒç”¨è€…å¿…é¡»æ˜¯main coå¹¶ä¸”å¿…é¡»æ˜¯`co->main_co`ï¼Œå…¥å‚`co`å¿…é¡»æ˜¯non-main coã€‚\n\nç¬¬ä¸€æ¬¡Resumeåç¨‹`co`æ—¶ï¼Œå°†ä¼šå¼€å§‹`co`çš„æ‰§è¡Œï¼ˆå‡½æ•°æŒ‡é’ˆ`co->fp`æŒ‡å‘çš„å‡½æ•°ï¼‰ã€‚å¦‚æžœåç¨‹`co`å·²ç»Yieldedï¼Œ`aco_resume`å°†ä¼šç»§ç»­`co`çš„æ‰§è¡Œã€‚\n\nåœ¨API `aco_resume`è¢«è°ƒç”¨ä¹‹åŽï¼Œæˆ‘ä»¬å®šä¹‰è°ƒç”¨è€… -- main co çš„çŠ¶æ€ä¸º \"yielded\" ã€‚\n\n## aco_yield\n\n```c\nvoid aco_yield();\n```\n\nä»Žè°ƒç”¨è€…`co`å¤„Yieldå‡ºæ¥å¹¶ä¸”Resume `co->main_co`çš„æ‰§è¡Œã€‚\n\næ­¤APIçš„è°ƒç”¨è€…å¿…é¡»ä¸ºnon-main coï¼Œ`co->main_co`å¿…é¡»éžNULLã€‚\n\nåœ¨API `aco_yield`è¢«è°ƒç”¨ä¹‹åŽï¼Œæˆ‘ä»¬å®šä¹‰`co`çš„çŠ¶æ€ä¸º \"yielded\" ã€‚\n\n## aco_get_co\n\n```c\naco_t* aco_get_co();\n```\n\nè¿”å›žå½“å‰non-main coçš„æŒ‡é’ˆã€‚æ­¤APIçš„è°ƒç”¨è€…å¿…é¡»æ˜¯non-main coã€‚\n\n## aco_get_arg\n\n```c\nvoid* aco_get_arg();\n```\n\nç­‰ä»·äºŽ`(aco_get_co()->arg)`ã€‚åŒæ ·çš„ï¼Œæ­¤APIçš„è°ƒç”¨è€…å¿…é¡»æ˜¯non-main coã€‚\n\n## aco_exit\n\n```c\nvoid aco_exit();\n```\n\né™¤äº†ä¸Ž`aco_yield()`ä¸€æ ·çš„åŠŸèƒ½ä¹‹å¤–ï¼Œ`aco_exit()`ä¼šå¦å¤–è®¾ç½®`co->is_end`ä¸º1ï¼Œä»¥æ ‡å¿—`co`çš„çŠ¶æ€ä¸º \"end\" ã€‚\n\n## aco_destroy\n\n```c\nvoid aco_destroy(aco_t* co);\n```\n\né”€æ¯åç¨‹`co`ã€‚å…¥å‚`co`å¿…é¡»éžNULLã€‚å¦‚æžœ`co`æ˜¯ä¸€ä¸ªnon-main coï¼Œæ­¤APIä¹Ÿä¼šåŒæ—¶é”€æ¯`co`çš„ç§æœ‰ä¿å­˜æ ˆã€‚\n\n## MACROS\n\n### Version\n\n```c\n#define ACO_VERSION_MAJOR 1\n#define ACO_VERSION_MINOR 2\n#define ACO_VERSION_PATCH 2\n```\n\nè¿™ä¸‰ä¸ªå…³äºŽlibacoç‰ˆæœ¬å€¼çš„å®å®šä¹‰åœ¨å¤´æ–‡ä»¶`aco.h`ä¸­ï¼Œå®ƒä»¬çš„å€¼éµå®ˆæ ‡å‡†ï¼š[Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html)ã€‚\n\n### aco_assert_override.h\n\n```c\n// provide the compiler with branch prediction information\n#define likely(x)               aco_likely(x)\n#define unlikely(x)             aco_unlikely(x)\n\n// override the default `assert` for convenience when coding\n#define assert(EX)              aco_assert(EX)\n\n// equal to `assert((ptr) != NULL)`\n#define assertptr(ptr)          aco_assertptr(ptr)\n\n// assert the successful return of memory allocation\n#define assertalloc_bool(b)     aco_assertalloc_bool(b)\n#define assertalloc_ptr(ptr)    aco_assertalloc_ptr(ptr)\n```\n\nåƒæºæ–‡ä»¶[test_aco_synopsis.c](test_aco_synopsis.c) æ‰€åšçš„é‚£æ ·ï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©åœ¨è‡ªå·±çš„åº”ç”¨æºç ä¸­includeå¤´æ–‡ä»¶`\"aco_assert_override.h\"`æ¥æ›¿æ¢æŽ‰Cé»˜è®¤çš„ \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" ä»¥åŠå®šä¹‰é™¤äº†`assert`ä¹‹å¤–çš„å…¶å®ƒäº”ä¸ªå®ï¼ˆå¦‚ä¸Šæ‰€ç¤ºï¼‰ã€‚å› ä¸ºCçš„ \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\" ä¹Ÿæ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œæ‰€ä»¥åœ¨includeå¤´æ–‡ä»¶ `\"aco_assert_override.h\"` æ—¶ï¼Œåº”è¯¥å°†å®ƒæ”¾åˆ°æºæ–‡ä»¶ä¸­æ‰€æœ‰includeæŒ‡ä»¤ä¸­çš„æœ€åŽä¸€ä¸ªã€‚å¦‚æžœåœ¨ä¸€ä¸ªæºæ–‡ä»¶ä¸­ï¼Œç”¨æˆ·æƒ³è¦åœ¨æŸä¸ªæºæ–‡ä»¶ä¸­ä½¿ç”¨é»˜è®¤çš„C \"[assert](http://man7.org/linux/man-pages/man3/assert.3.html)\"ï¼Œè¯·ä¸è¦åœ¨å…¶ä¸­includeè¿™ä¸ªå¤´æ–‡ä»¶ã€‚\n\né˜…è¯»æºæ–‡ä»¶[aco_assert_override.h](aco_assert_override.h)ä»¥èŽ·å¾—å…³äºŽæ­¤çš„æ›´å¤šä¿¡æ¯ã€‚\n\n# Benchmark\n\nDate: Sat Jun 30 UTC 2018.\n\nMachine: [c5d.large on AWS](https://aws.amazon.com/cn/blogs/aws/now-available-compute-intensive-c5-instances-for-amazon-ec2/).\n\nOS: RHEL-7.5 (Red Hat Enterprise Linux 7.5).\n\nä¸‹é¢æ˜¯å…³äºŽæ€§èƒ½æµ‹è¯•éƒ¨åˆ†çš„ä¸€ä¸ªæ‘˜è¦æè¿°ï¼š\n\n* ä¸€æ¬¡åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢ä»…è€—æ—¶ **10.29 ns** ï¼ˆåç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„è¿è¡Œæ ˆï¼Œå¹¶ä¸”åç¨‹é—´å…±äº«FPUä¸ŽMXCSRæŽ§åˆ¶å­—é…ç½®çš„æƒ…å†µä¸‹ï¼‰ï¼›\n* ä¸€æ¬¡åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢ä»…è€—æ—¶ **10.38 ns** ï¼ˆåç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„è¿è¡Œæ ˆ,å¹¶ä¸”å„åç¨‹å‡ç»´æŠ¤ä¸€ä»½å±žäºŽå„è‡ªçš„FPUä¸ŽMXCSRæŽ§åˆ¶å­—é…ç½®çš„æƒ…å†µä¸‹ï¼‰ï¼›\n* æžè‡´çš„å†…å­˜ä½¿ç”¨çŽ‡ï¼šä¸€åƒä¸‡ä¸ªåç¨‹å¹¶å‘æ‰§è¡Œä»…æ¶ˆè€—2.8GBçš„ç‰©ç†å†…å­˜ï¼ˆtcmallocï¼Œæ¯ä¸€ä¸ªåç¨‹ä½¿ç”¨120Bçš„å¤åˆ¶æ ˆï¼‰ã€‚\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.shareFPUenv\n\n+build:x86_64\n+build:-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:share fpu & mxcsr control words between coroutines\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=152:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      230.00 ns/op    4347824.79 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.59 ns/op   48576413.55 op/s\n  -> acosw                                            40000000     0.412 s       10.29 ns/op   97152827.10 op/s\naco_destroy                                                  1     0.000 s      650.00 ns/op    1538461.66 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      200.00 ns/op    5000001.72 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.412 s       20.61 ns/op   48525164.25 op/s\n  -> acosw                                            40000000     0.412 s       10.30 ns/op   97050328.50 op/s\naco_destroy                                                  1     0.000 s      666.00 ns/op    1501501.49 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.50 ns/op   15266771.53 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.666 s       33.29 ns/op   30043022.64 op/s\naco_destroy                                            2000000     0.066 s       32.87 ns/op   30425152.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.130 s       65.22 ns/op   15332218.24 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.75 ns/op   29630018.73 op/s\naco_destroy                                            2000000     0.067 s       33.45 ns/op   29898311.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.42 ns/op   15286937.97 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.669 s       33.45 ns/op   29891277.59 op/s\naco_destroy                                            2000000     0.080 s       39.87 ns/op   25084242.29 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.224 s      111.86 ns/op    8940010.49 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.678 s       33.88 ns/op   29515473.53 op/s\naco_destroy                                            2000000     0.067 s       33.42 ns/op   29922412.68 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.74 ns/op   15211896.70 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.45 ns/op   26010724.94 op/s\naco_destroy                                            2000000     0.088 s       44.11 ns/op   22669240.25 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.240 s      123.97 ns/op    8066542.54 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.17 ns/op   30143409.55 op/s\naco_destroy                                           10000000     0.328 s       32.82 ns/op   30467658.05 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.659 s       65.94 ns/op   15165717.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.345 s       33.63 ns/op   29737708.53 op/s\naco_destroy                                           10000000     0.337 s       33.71 ns/op   29666697.09 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.654 s       65.38 ns/op   15296191.35 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.348 s       33.71 ns/op   29663992.77 op/s\naco_destroy                                           10000000     0.336 s       33.56 ns/op   29794574.96 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.653 s       65.29 ns/op   15316087.09 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.384 s       34.60 ns/op   28902221.24 op/s\naco_destroy                                           10000000     0.337 s       33.73 ns/op   29643682.93 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.652 s       65.19 ns/op   15340872.40 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.565 s       39.11 ns/op   25566255.73 op/s\naco_destroy                                           10000000     0.443 s       44.30 ns/op   22574242.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241722.94 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.947 s       47.36 ns/op   21114212.05 op/s\naco_destroy                                            2000000     0.125 s       62.35 ns/op   16039466.45 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.71 ns/op   15218784.72 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.948 s       47.39 ns/op   21101216.29 op/s\naco_destroy                                            2000000     0.125 s       62.73 ns/op   15941559.26 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.49 ns/op   15270258.18 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.069 s       53.44 ns/op   18714275.17 op/s\naco_destroy                                            2000000     0.122 s       61.05 ns/op   16378678.85 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.91 ns/op   15171336.62 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.190 s       59.48 ns/op   16813230.99 op/s\naco_destroy                                            2000000     0.123 s       61.26 ns/op   16324298.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.68 ns/op   15224361.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.828 s       91.40 ns/op   10941133.56 op/s\naco_destroy                                            2000000     0.145 s       72.56 ns/op   13781182.82 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       65.80 ns/op   15197461.34 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.829 s       91.47 ns/op   10932139.32 op/s\naco_destroy                                            2000000     0.149 s       74.70 ns/op   13387258.82 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.63 ns/op   15007426.35 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.224 s      211.20 ns/op    4734744.76 op/s\naco_destroy                                            1000000     0.093 s       93.36 ns/op   10711651.49 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.28 ns/op   15086953.73 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.222 s      211.12 ns/op    4736537.93 op/s\naco_destroy                                            1000000     0.094 s       94.09 ns/op   10627664.78 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.72 ns/op   14139923.59 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.191 s      209.56 ns/op    4771909.70 op/s\naco_destroy                                             100000     0.010 s      101.21 ns/op    9880747.28 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.62 ns/op   15010433.00 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.002 s      350.11 ns/op    2856228.03 op/s\naco_destroy                                             100000     0.016 s      159.69 ns/op    6262129.35 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.76 ns/op   15205994.08 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.918 s      595.90 ns/op    1678127.54 op/s\naco_destroy                                             100000     0.019 s      186.32 ns/op    5367189.85 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.03 ns/op   15865531.37 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917079.11 op/s\naco_destroy                                             100000     0.038 s      378.33 ns/op    2643225.42 op/s\n```\n\n```\n$ LD_PRELOAD=/usr/lib64/libtcmalloc_minimal.so.4 ./test_aco_benchmark..no_valgrind.standaloneFPUenv\n\n+build:x86_64\n+build:undefined ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n+build:each coroutine maintain each own fpu & mxcsr control words\n+build:undefined ACO_USE_VALGRIND\n+build:without valgrind memcheck friendly support\n\nsizeof(aco_t)=160:\n\n\ncomment                                             task_amount  all_time_cost   ns_per_op          speed\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      273.00 ns/op    3663004.27 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.76 ns/op   48173877.75 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96347755.51 op/s\naco_destroy                                                  1     0.000 s      381.00 ns/op    2624672.26 op/s\n\naco_create/init_save_stk_sz=64B                              1     0.000 s      212.00 ns/op    4716980.43 op/s\naco_resume/co_amount=1/copy_stack_size=0B             20000000     0.415 s       20.75 ns/op   48185455.26 op/s\n  -> acosw                                            40000000     0.415 s       10.38 ns/op   96370910.51 op/s\naco_destroy                                                  1     0.000 s      174.00 ns/op    5747123.38 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.63 ns/op   15237386.02 op/s\naco_resume/co_amount=2000000/copy_stack_size=8B       20000000     0.664 s       33.20 ns/op   30119155.82 op/s\naco_destroy                                            2000000     0.065 s       32.67 ns/op   30604542.55 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.33 ns/op   15305975.29 op/s\naco_resume/co_amount=2000000/copy_stack_size=24B      20000000     0.675 s       33.74 ns/op   29638360.61 op/s\naco_destroy                                            2000000     0.067 s       33.31 ns/op   30016633.42 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.61 ns/op   15241767.78 op/s\naco_resume/co_amount=2000000/copy_stack_size=40B      20000000     0.678 s       33.88 ns/op   29518648.08 op/s\naco_destroy                                            2000000     0.079 s       39.74 ns/op   25163018.30 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.221 s      110.73 ns/op    9030660.30 op/s\naco_resume/co_amount=2000000/copy_stack_size=56B      20000000     0.684 s       34.18 ns/op   29253416.65 op/s\naco_destroy                                            2000000     0.067 s       33.40 ns/op   29938840.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.60 ns/op   15244077.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=120B     20000000     0.769 s       38.43 ns/op   26021228.41 op/s\naco_destroy                                            2000000     0.087 s       43.74 ns/op   22863987.42 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     1.251 s      125.08 ns/op    7994958.59 op/s\naco_resume/co_amount=10000000/copy_stack_size=8B      40000000     1.327 s       33.19 ns/op   30133654.80 op/s\naco_destroy                                           10000000     0.329 s       32.85 ns/op   30439787.32 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.674 s       67.37 ns/op   14843796.57 op/s\naco_resume/co_amount=10000000/copy_stack_size=24B     40000000     1.354 s       33.84 ns/op   29548523.05 op/s\naco_destroy                                           10000000     0.339 s       33.90 ns/op   29494634.83 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.19 ns/op   14882262.88 op/s\naco_resume/co_amount=10000000/copy_stack_size=40B     40000000     1.361 s       34.02 ns/op   29393520.19 op/s\naco_destroy                                           10000000     0.338 s       33.77 ns/op   29609577.59 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.673 s       67.31 ns/op   14857716.02 op/s\naco_resume/co_amount=10000000/copy_stack_size=56B     40000000     1.371 s       34.27 ns/op   29181897.80 op/s\naco_destroy                                           10000000     0.339 s       33.85 ns/op   29540633.63 op/s\n\naco_create/init_save_stk_sz=64B                       10000000     0.672 s       67.24 ns/op   14873017.10 op/s\naco_resume/co_amount=10000000/copy_stack_size=120B    40000000     1.548 s       38.71 ns/op   25835542.17 op/s\naco_destroy                                           10000000     0.446 s       44.61 ns/op   22415961.64 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.01 ns/op   15148290.52 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.22 ns/op   21177946.19 op/s\naco_destroy                                            2000000     0.124 s       61.99 ns/op   16132721.97 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.36 ns/op   15068860.85 op/s\naco_resume/co_amount=2000000/copy_stack_size=136B     20000000     0.944 s       47.20 ns/op   21187541.38 op/s\naco_destroy                                            2000000     0.124 s       62.21 ns/op   16073322.25 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.131 s       65.62 ns/op   15238955.93 op/s\naco_resume/co_amount=2000000/copy_stack_size=152B     20000000     1.072 s       53.61 ns/op   18652789.74 op/s\naco_destroy                                            2000000     0.121 s       60.42 ns/op   16551368.04 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.08 ns/op   15132547.65 op/s\naco_resume/co_amount=2000000/copy_stack_size=232B     20000000     1.198 s       59.88 ns/op   16699389.91 op/s\naco_destroy                                            2000000     0.121 s       60.71 ns/op   16471465.52 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.133 s       66.50 ns/op   15036985.95 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.853 s       92.63 ns/op   10796126.04 op/s\naco_destroy                                            2000000     0.146 s       72.87 ns/op   13723559.36 op/s\n\naco_create/init_save_stk_sz=64B                        2000000     0.132 s       66.14 ns/op   15118324.13 op/s\naco_resume/co_amount=2000000/copy_stack_size=488B     20000000     1.855 s       92.75 ns/op   10781572.22 op/s\naco_destroy                                            2000000     0.152 s       75.79 ns/op   13194130.51 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.067 s       66.97 ns/op   14931921.56 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.218 s      210.90 ns/op    4741536.66 op/s\naco_destroy                                            1000000     0.093 s       93.16 ns/op   10734691.98 op/s\n\naco_create/init_save_stk_sz=64B                        1000000     0.066 s       66.49 ns/op   15039274.31 op/s\naco_resume/co_amount=1000000/copy_stack_size=1000B    20000000     4.216 s      210.81 ns/op    4743543.53 op/s\naco_destroy                                            1000000     0.094 s       93.97 ns/op   10641539.58 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       70.95 ns/op   14094724.73 op/s\naco_resume/co_amount=100000/copy_stack_size=1000B     20000000     4.190 s      209.52 ns/op    4772746.50 op/s\naco_destroy                                             100000     0.010 s      100.99 ns/op    9902271.51 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       66.49 ns/op   15040038.84 op/s\naco_resume/co_amount=100000/copy_stack_size=2024B     20000000     7.028 s      351.38 ns/op    2845942.55 op/s\naco_destroy                                             100000     0.016 s      159.15 ns/op    6283444.42 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.007 s       65.73 ns/op   15214482.36 op/s\naco_resume/co_amount=100000/copy_stack_size=4072B     20000000    11.879 s      593.95 ns/op    1683636.60 op/s\naco_destroy                                             100000     0.018 s      184.23 ns/op    5428119.00 op/s\n\naco_create/init_save_stk_sz=64B                         100000     0.006 s       63.41 ns/op   15771072.16 op/s\naco_resume/co_amount=100000/copy_stack_size=7992B     20000000    21.808 s     1090.42 ns/op     917081.56 op/s\naco_destroy                                             100000     0.038 s      376.78 ns/op    2654073.13 op/s\n```\n\n# Proof of Correctness\n\né¦–å…ˆï¼Œåœ¨å¼€å§‹å®žçŽ°æˆ–è€…è¯æ˜Žä¸€ä¸ªåç¨‹åº“ä¹‹å‰ï¼Œå¿…å¤‡çš„æ¡ä»¶æ˜¯è¦å¯¹[Sys V ABI of intel386 and x86-64](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)æ ‡å‡†éžå¸¸çš„ç†Ÿæ‚‰ï¼Œä»¥åŠä¸€äº›åŸºç¡€çš„æ±‡ç¼–çŸ¥è¯†ã€‚\n\næŽ¥ä¸‹æ¥çš„è¯æ˜Žä¸­å¹¶æ²¡æœ‰åŒ…å«å…³äºŽIPï¼ˆæŒ‡ä»¤æŒ‡é’ˆï¼‰ï¼ŒSPï¼ˆå †æ ˆæŒ‡é’ˆï¼‰å’Œåç¨‹çš„ç§æœ‰ä¿å­˜æ ˆä¸Žå…±äº«æ‰§è¡Œæ ˆä¹‹é—´çš„ä¿å­˜ä¸Žæ¢å¤çš„ç›´æŽ¥æè¿°ï¼Œå› ä¸ºç›¸æ¯”äºŽABIçº¦æŸçš„ä¿è¯ï¼Œè¿™äº›ä¸œè¥¿æ˜¯ç›¸å½“å¾®ä¸è¶³é“ä¸”å®¹æ˜“å®žçŽ°å’Œç†è§£çš„ã€‚\n\n## Running Model\n\nåœ¨ä¸€ä¸ªOSçº¿ç¨‹ä¸­ï¼Œä¸»åç¨‹`main_co`æ˜¯è¢«ç¬¬ä¸€ä¸ªåˆ›å»ºå¹¶ä¸”æ˜¯åœ¨æ‰€æœ‰å…¶ä»–non-main coroutineä¹‹å‰å°±å·²ç»å¼€å§‹è¿è¡Œäº†çš„åç¨‹ã€‚\n\nä¸‹å›¾æ˜¯åç¨‹main coä¸Žcoä¹‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢çš„ç®€å•å›¾ç¤ºã€‚\n\nåœ¨è¿™ä¸ªè¯æ˜Žä¸­ï¼Œæˆ‘ä»¬å‡å®šæˆ‘ä»¬çš„äºŒè¿›åˆ¶ç¨‹åºè¦æ»¡è¶³Sys V ABI intel386æ ‡å‡†ï¼Œå› ä¸ºSys V ABI intel386ä¸ŽSys V ABI x86-64ä¹‹é—´æ²¡æœ‰æ ¹æœ¬çš„ä¸åŒã€‚ä¸ºäº†ç®€åŒ–æè¿°ï¼Œæˆ‘ä»¬è¿˜å‡å®šäºŒè¿›åˆ¶ç¨‹åºä¸­æ²¡æœ‰ä¼šæ›´æ”¹FPUæˆ–MXCSRæŽ§åˆ¶å­—çš„ä»£ç å­˜åœ¨ã€‚\n\n![proof_0](img/proof_0.png)\n\nä¸‹å›¾å®žé™…ä¸Šæ˜¯å¯¹ç§°åç¨‹çš„è¿è¡Œæ¨¡åž‹å›¾ï¼ˆæ‹¥æœ‰ä¸é™é‡ä¸ªnon-main coå’Œä¸€ä¸ªmain coï¼‰ã€‚å› ä¸ºéžå¯¹ç§°åç¨‹ä»…ä»…æ˜¯å¯¹ç§°åç¨‹çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬å¦‚æžœè¯æ˜Žäº†å¯¹ç§°åç¨‹çš„æ­£ç¡®æ€§ä¹Ÿå°±ç­‰äºŽè¯æ˜Žäº†éžå¯¹ç§°åç¨‹çš„æ­£ç¡®æ€§ï¼Œå¦‚æ­¤ä¼šå¤šäº›æŒ‘æˆ˜æ€§åŒæ—¶ä¹Ÿä¼šå¤šäº›ä¹è¶£ï¼ˆlibacoå½“å‰åªå®žçŽ°äº†éžå¯¹ç§°åç¨‹çš„APIï¼Œå› ä¸ºéžå¯¹ç§°åç¨‹çš„APIè¯­ä¹‰è¿œè¿œæ¯”å¯¹ç§°åç¨‹çš„APIè¯­ä¹‰æ›´å®¹æ˜“ç†è§£å’ŒæŽŒæŽ§ï¼‰ã€‚\n\n![proof_1](img/proof_1.png)\n\nå› ä¸ºmain coæ˜¯åœ¨å½“å‰OSçº¿ç¨‹ä¸­ç¬¬ä¸€ä¸ªå¼€å§‹è¿è¡Œçš„åç¨‹ï¼Œé‚£ä¹ˆç¬¬ä¸€æ¬¡åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢ä¸€å®šæ˜¯ä»¥`acosw(main_co, co)`è¿™ç§å½¢å¼å­˜åœ¨çš„ï¼ˆè¿™é‡Œï¼Œ`acosw`çš„ç¬¬äºŒä¸ªå…¥å‚`co`æ˜¯ä¸€ä¸ªnon-main coï¼‰ã€‚\n\n## Mathematical Induction\n\nå®¹æ˜“è¯æ˜Žï¼Œåœ¨ä¸Šå›¾ä¸­åªå­˜åœ¨ä¸¤ç±»åç¨‹é—´çš„çŠ¶æ€è¿ç§»ï¼š\n\n* yielded state co â†’ init state co\n* yielded state co â†’ yielded state co\n\nè¦è¯æ˜Žåç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢å‡½æ•°`void* acosw(aco_t* from_co, aco_t* to_co)`çš„æ­£ç¡®æ€§ï¼Œå°±ç­‰äºŽè¦è¯æ˜Žæ‰€æœ‰çš„åç¨‹åœ¨è°ƒç”¨`acosw`å‰åŽéƒ½ä¸€ç›´æ»¡è¶³Sys V ABIè§„èŒƒçš„çº¦æŸã€‚æˆ‘ä»¬å‡å®šåç¨‹ä¸­é™¤äº†`acosw`ä¹‹å¤–çš„æ‰€æœ‰äºŒè¿›åˆ¶å‡å·²ç»æ»¡è¶³äº†ABIè§„èŒƒï¼ˆå®ƒä»¬ä¸€èˆ¬æ˜¯ç”±ç¼–è¯‘å™¨æ­£ç¡®åœ°ç”Ÿæˆçš„ï¼‰ã€‚\n\nä¸‹é¢æ˜¯Sys V ABI Intel386å‡½æ•°è°ƒç”¨çº¦å®šä¸­å¯„å­˜å™¨ç”¨æ³•çš„æ€»ç»“ï¼š\n\n```\nRegisters' usage in the calling convention of the Intel386 System V ABI:\n    caller saved (scratch) registers:\n        C1.0: EAX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                hold the return value for `acosw`\n        C1.1: ECX,EDX\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.2: Arithmetic flags, x87 and mxcsr flags\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n        C1.3: ST(0-7)\n            At the entry of a function call:\n                the stack of FPU must be empty\n            After the return of `acosw`:\n                the stack of FPU must be empty\n        C1.4: Direction flag\n            At the entry of a function call:\n                DF must be 0\n            After the return of `acosw`:\n                DF must be 0\n        C1.5: others: xmm*,ymm*,mm*,k*...\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                could be any value\n    callee saved registers:\n        C2.0: EBX,ESI,EDI,EBP\n            At the entry of a function call:\n                could be any value\n            After the return of `acosw`:\n                must be the same as it is at the entry of `acosw` \n        C2.1: ESP\n            At the entry of a function call:\n                must be a valid stack pointer\n                (alignment of 16 bytes, retaddr and etc...)\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw`\n        C2.2: control word of FPU & mxcsr\n            At the entry of a function call:\n                could be any configuration\n            After the return of `acosw`:\n                must be the same as it is before the call of `acosw` \n                (unless the caller of `acosw` assume `acosw` may    \\\n                change the control words of FPU or MXCSR on purpose \\\n                like `fesetenv`)\n```\n\nï¼ˆå¯¹äºŽIntel386ï¼Œå¯„å­˜å™¨çš„ç”¨é€”å®šä¹‰åœ¨[Sys V ABI Intel386 V1.1](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)çš„ \"P13 - Table 2.3: Register Usage\" è¡¨ä¸­ï¼Œå¯¹äºŽAMD64åˆ™å®šä¹‰åœ¨[Sys V ABI AMD64 V1.0](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI)çš„ \"P23 - Figure 3.4: Register Usage\" çš„å›¾ä¸­ã€‚ï¼‰\n\n**Proof:**\n\n1. yielded state co -> init state co:\n\n![proof_2](img/proof_2.png)\n\nä¸Šå›¾è¯¦ç»†åœ°æç»˜äº†ç¬¬ä¸€ç±»çŠ¶æ€è¿ç§»çš„è¿‡ç¨‹ï¼š \"yielded state co -> init state co\" .\n\nçº¦æŸ: C 1.0, 1.1, 1.2, 1.5 (*æ»¡è¶³* âœ“ )\n\nä¸‹é¢åˆ—å‡ºçš„Scratch Registersåœ¨ä¸€ä¸ªå‡½æ•°çš„å…¥å£ç‚¹æ—¶å…¶å€¼å¯ä»¥ä¸ºä»»æ„å€¼ï¼š\n\n```\nEAX,ECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\nçº¦æŸ: C 1.3, 1.4 (*æ»¡è¶³* âœ“ )\n\nç”±äºŽåœ¨`acosw`è¢«è°ƒç”¨ä¹‹å‰ï¼ŒFPUæ ˆå¿…ç„¶å·²ç©ºå¹¶ä¸”DFå¿…ç„¶å·²ä¸º0ï¼ˆå› ä¸ºåç¨‹coçš„äºŒè¿›åˆ¶ä»£ç å·²ç»æ»¡è¶³ABIè§„èŒƒï¼‰ï¼Œæ‰€ä»¥ï¼Œ`acosw`æ»¡è¶³çº¦æŸC1.3å’Œ1.4ã€‚\n\nçº¦æŸ: C 2.0, 2.1, 2.2 (*æ»¡è¶³* âœ“ )\n\nçº¦æŸC2.0å’Œ2.1å·²ç»è¢«æ»¡è¶³ã€‚ç”±äºŽæˆ‘ä»¬å·²å‡å®šFPUä¸ŽMXCSRçš„æŽ§åˆ¶å­—åœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šè¢«æ›´æ”¹ï¼Œæ‰€ä»¥çº¦æŸC2.2ä¹Ÿå·²ç»è¢«`acosw`æ»¡è¶³ã€‚\n\n2. yielded state co -> yielded state co:\n\n![proof_3](img/proof_3.png)\n\nä¸Šå›¾è¯¦ç»†åœ°æç»˜äº†ç¬¬äºŒç±»çŠ¶æ€è¿ç§»çš„è¿‡ç¨‹ï¼š yielded state co -> yielded state co.\n\nçº¦æŸ: C 1.0 (*æ»¡è¶³* âœ“ )\n\nå¾ˆæ˜¾ç„¶ï¼Œå½“`acosw`è¿”å›žåˆ°to_coæ—¶EAXä¸­å·²ç»ä¿å­˜äº†é¢„æœŸçš„è¿”å›žå€¼ã€‚\n\nçº¦æŸ: C 1.1, 1.2, 1.5 (*æ»¡è¶³* âœ“ )\n\nä¸‹é¢åˆ—å‡ºçš„Scratch Registersåœ¨ä¸€ä¸ªå‡½æ•°çš„å…¥å£ç‚¹æ—¶ä»¥åŠåœ¨`acosw`è¿”å›žåŽå…¶å€¼çš†å¯ä¸ºä»»æ„å€¼ï¼š\n\n```\nECX,EDX\nXMM*,YMM*,MM*,K*...\nstatus bits of EFLAGS,FPU,MXCSR\n```\n\nçº¦æŸ: C 1.3, 1.4 (*æ»¡è¶³* âœ“ )\n\nç”±äºŽåœ¨`acosw`è¢«è°ƒç”¨ä¹‹å‰ï¼ŒFPUæ ˆå¿…ç„¶å·²ç©ºå¹¶ä¸”DFå¿…ç„¶å·²ä¸º0ï¼ˆå› ä¸ºåç¨‹coçš„äºŒè¿›åˆ¶ä»£ç å·²ç»æ»¡è¶³ABIè§„èŒƒï¼‰ï¼Œæ‰€ä»¥ï¼Œ`acosw`æ»¡è¶³çº¦æŸC1.3å’Œ1.4ã€‚\n\nçº¦æŸ: C 2.0, 2.1, 2.2 (*æ»¡è¶³* âœ“ )\n\nä»Ž`acosw`è°ƒç”¨è€…çš„è§’åº¦æ¥çœ‹ï¼Œç”±äºŽåœ¨`acosw`è¢«è°ƒç”¨ï¼ˆæˆ–è¿”å›žï¼‰æ—¶ï¼Œæ‰€æœ‰çš„callee saved registerséƒ½åšäº†å¯¹åº”çš„ä¿å­˜ï¼ˆæˆ–æ¢å¤ï¼‰å·¥ä½œï¼Œåˆ™çº¦æŸC2.0ä¸Ž2.1è¢«`acosw`æ»¡è¶³ã€‚ç”±äºŽæˆ‘ä»¬å·²å‡å®šFPUä¸ŽMXCSRçš„æŽ§åˆ¶å­—åœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­ä¸ä¼šè¢«æ›´æ”¹ï¼Œæ‰€ä»¥çº¦æŸC2.2ä¹Ÿå·²ç»è¢«`acosw`æ»¡è¶³ã€‚\n\n3. Mathematical induction:\n\næ˜¾ç„¶ï¼Œåœ¨å½“å‰OSçº¿ç¨‹ä¸­ï¼Œç¬¬ä¸€æ¬¡`acosw`å¿…ç„¶å±žäºŽç¬¬ä¸€ç±»çŠ¶æ€è¿ç§»ï¼šyielded state co -> init state coï¼Œå¹¶ä¸”æŽ¥ä¸‹æ¥çš„æ‰€æœ‰`acosw`å¿…ç„¶å±žäºŽè¿™ä¸¤ç±»çŠ¶æ€è¿ç§»çš„å…¶ä¸­ä¸€ç±»ã€‚é¡ºåºåœ°ç”¨ä¸Šé¢å¾—åˆ°ä¸¤ä¸ªç»“è®ºä¾æ¬¡è¯æ˜Žï¼Œæœ€ç»ˆå¾—åˆ°â€œæ‰€æœ‰çš„åç¨‹åœ¨è°ƒç”¨`acosw`å‰åŽéƒ½ä¸€ç›´æ»¡è¶³Sys V ABIè§„èŒƒçš„çº¦æŸâ€ç»“è®ºã€‚å¦‚æ­¤ï¼Œè¯æ˜Žç»“æŸã€‚\n\n## Miscellaneous\n\n### Red Zone\n\nåœ¨System V ABI x86-64ä¸­æè¿°[red zone](https://en.wikipedia.org/wiki/Red_zone_(computing))çš„æ¦‚å¿µï¼š\n\n> The 128-byte area beyond the location pointed to by %rsp is considered to be reserved and shall not be modified by signal or interrupt handlers. Therefore, functions may use this area for temporary data that is not needed across function calls. In particular, leaf functions may use this area for their entire stack frame, rather than adjusting the stack pointer in the prologue and epilogue. This area is known as the red zone.\n\nç”±äºŽred zone \"not preserved by the callee\" ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨åç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å®žçŽ°ä¸­æ— éœ€è€ƒè™‘å®ƒï¼ˆå› ä¸º`acosw`æ˜¯ä¸€ä¸ªå¶å­å‡½æ•°ï¼Œå³leaf functionï¼‰ã€‚\n\n### Stack Pointer\n\n> The end of the input argument area shall be aligned on a 16 (32 or 64, if \\_\\_m256 or \\_\\_m512 is passed on stack) byte boundary. In other words, the value (%esp + 4) is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, %esp, always points to the end of the latest allocated stack frame.\n>\n> â€” Intel386-psABI-1.1:2.2.2 The Stack Frame\n\n> The stack pointer, %rsp, always points to the end of the latest allocated stack frame.\n>\n> â€” Sys V ABI AMD64 Version 1.0:3.2.2 The Stack Frame\n\nè¿™æ˜¯è…¾è®¯libcoä¸­çš„ä¸€ä¸ª[bug](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27)ã€‚ABIè§„èŒƒä¸­è§„å®šç”¨æˆ·ç©ºé—´ç¨‹åºçš„æ ˆæŒ‡é’ˆå¿…é¡»æ—¶åˆ»æŒ‡åˆ°è¿è¡Œæ ˆçš„[æ ˆé¡¶](https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88#%E6%93%8D%E4%BD%9C)ï¼Œè€Œ[coctx_swap.S](https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27)ä¸­å´ä½¿ç”¨æ ˆæŒ‡é’ˆç›´æŽ¥å¯¹ä½äºŽå †ä¸­çš„æ•°æ®ç»“æž„è¿›è¡Œå¯»å€å†…å­˜æ“ä½œï¼Œè¿™è¿åäº†ABIçº¦å®šã€‚\n\n>**By default, the signal handler  is invoked  on  the normal process stack.**  It is possible to arrange that the signal handler uses an alternate stack; see sigalstack(2)  for  a discussion of how to do this and when it might be useful.\n>\n>â€” man 7 signal : Signal dispositions\n\nå½“coctx_swapæ­£åœ¨ç”¨æ ˆæŒ‡é’ˆå¯¹ä½äºŽå †ä¸­çš„æ•°æ®ç»“æž„è¿›è¡Œå¯»å€å†…å­˜æ“ä½œæ—¶ï¼Œè‹¥æ­¤æ—¶æ‰§è¡Œçº¿ç¨‹æ”¶åˆ°äº†ä¸€ä¸ªä¿¡å·ï¼ŒæŽ¥ç€å†…æ ¸æŠ¢å äº†è¯¥æ‰§è¡Œçº¿ç¨‹å¹¶å¼€å§‹å‡†å¤‡æŽ¥ä¸‹æ¥ç”¨æˆ·ç©ºé—´çº¿ç¨‹çš„ä¿¡å·å¤„ç†æ‰§è¡ŒçŽ¯å¢ƒï¼Œç”±äºŽåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œå†…æ ¸å°†ä¼šé€‰æ‹©ä¸»æ ˆä½œä¸ºä¿¡å·å¤„ç†å‡½æ•°çš„æ‰§è¡Œæ ˆï¼Œä½†æ­¤æ—¶æ ˆå·²ç»è¢«æŒ‡å‘äº†å †ä¸­ï¼ˆç”¨æˆ·ç©ºé—´çš„ç¨‹åºè¿åABIçº¦å®šåœ¨å…ˆï¼‰ï¼Œé‚£ä¹ˆä¿¡å·å¤„ç†å‡½æ•°çš„æ‰§è¡Œæ ˆå°±ä¼šè¢«é”™è¯¯çš„æ”¾ç½®åˆ°å †ä¸­ï¼Œè¿™æ ·ï¼Œå †ä¸­çš„æ•°æ®ç»“æž„åœ¨æŽ¥ä¸‹æ¥å°±æžæœ‰å¯èƒ½ä¼šè¢«ç ´å(æ›´è¯¦ç»†çš„bugå¤çŽ°è¯·å‚è§æ­¤[issue](https://github.com/Tencent/libco/issues/90))ã€‚\n\n# Best Practice\n\næ€»çš„æ¥è¯´ï¼Œå¦‚æžœä½ æƒ³æŠŠlibacoçš„æ€§èƒ½å‘æŒ¥åˆ°æžè‡´ï¼Œä¸€å®šè¦ä¿è¯ \"non-standalone non-main co\" åœ¨è°ƒç”¨`aco_yield`æ—¶çš„æ‰§è¡Œæ ˆä½¿ç”¨å°½å¯èƒ½çš„å°ã€‚å¦å¤–ï¼Œå½“ä½ æƒ³æŠŠä¸€ä¸ªåç¨‹çš„å±€éƒ¨å˜é‡çš„åœ°å€ä¼ é€’åˆ°å¦ä¸€ä¸ªåç¨‹æ—¶ä¸€å®šè¦éžå¸¸å°å¿ƒï¼Œå› ä¸ºå¦‚æžœè¿™ä¸ªå˜é‡æ˜¯åœ¨å…±äº«æ ˆä¸Šæ—¶ï¼Œå°†å¯èƒ½ä¼šå‘ç”Ÿå†…å­˜æ•°æ®æ··ä¹±ï¼Œå› æ­¤ï¼Œæ€»æ˜¯ä»Žå †ä¸­åˆ†é…éœ€è¦åœ¨åç¨‹é—´å…±äº«çš„å†…å­˜æ˜¯ä¸€ä¸ªéžå¸¸æ˜Žæ™ºçš„é€‰æ‹©ã€‚\n\nè¯¦ç»†åœ°è¯´ï¼Œæœ‰äº”ç‚¹å»ºè®®ï¼š\n\n```\n       co_fp \n       /  \\\n      /    \\  \n    f1     f2\n   /  \\    / \\\n  /    \\  f4  \\\nyield  f3     f5\n```\n\n1. Main coçš„æ‰§è¡Œæ ˆä½¿ç”¨å¤§å°å¯¹åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ€§èƒ½æ²¡æœ‰ç›´æŽ¥å½±å“ï¼ˆå› ä¸ºmain coç‹¬å äº†çº¿ç¨‹çš„é»˜è®¤æ‰§è¡Œæ ˆï¼‰ï¼›\n\n2. Standalone non-main coçš„æ‰§è¡Œæ ˆä½¿ç”¨å¤§å°å¯¹åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ€§èƒ½æ²¡æœ‰ç›´æŽ¥å½±å“ï¼ˆå› ä¸ºå®ƒç‹¬å äº†ä¸€ä¸ªæ‰§è¡Œæ ˆï¼‰ã€‚ä½†æ˜¯åˆ›å»ºæµ·é‡çš„standalone non-main coå°†ä¼šæ¶ˆè€—æµ·é‡çš„è™šæ‹Ÿå†…å­˜ï¼ˆå› ä¸ºæµ·é‡æ‰§è¡Œæ ˆçš„åˆ›å»ºï¼‰ï¼Œå› æ­¤ï¼Œåº”ç”¨ä¸­å¹¶ä¸æŽ¨èåœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­åˆ›å»ºæµ·é‡çš„standalone non-main coï¼›\n\n3. Non-standalone non-main coï¼ˆä¸Žå…¶ä»–åç¨‹å…±äº«æ‰§è¡Œæ ˆçš„éžä¸»åç¨‹ï¼‰åœ¨è°ƒç”¨`aco_yield`æ—¶æ‰§è¡Œæ ˆçš„ä½¿ç”¨å¤§å°å°†ä¼šå¯¹åç¨‹é—´ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ€§èƒ½äº§ç”Ÿç›´æŽ¥çš„å½±å“ï¼Œæ€§èƒ½æµ‹è¯•éƒ¨åˆ†å·²ç»æ¸…æ¥šçš„å±•ç¤ºäº†è¿™ä¸€ç‚¹ã€‚åœ¨ä¸Šå›¾ä¸­ï¼Œå‡½æ•°f2ï¼Œf3ï¼Œf4ä¸Žf5çš„æ ˆä½¿ç”¨é‡å¯¹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ€§èƒ½æ²¡æœ‰å½±å“ï¼Œè¿™æ˜¯å› ä¸ºåœ¨å®ƒä»¬æ‰§è¡Œçš„è¿‡ç¨‹ä¸­å¹¶æ²¡æœ‰`aco_yield`å‡½æ•°çš„æ¥ä¸­æ–­å®ƒä»¬ã€‚ç„¶è€Œï¼Œå‡½æ•°co_fpä¸Žf1çš„æ ˆä½¿ç”¨é‡ä¹‹å’Œå°†ä¼šå†³å®š`co->save_stack.max_cpsz`ï¼ˆåç¨‹è¿è¡ŒæœŸé—´ç§æœ‰ä¿å­˜æ ˆçš„æœ€å¤§ä¿å­˜å¤§å°ï¼‰çš„å€¼ï¼ŒåŒæ—¶ä¼šå¯¹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„æ€§èƒ½äº§ç”Ÿç›´æŽ¥çš„å½±å“ï¼›\n\nè®©ä¸€ä¸ªå‡½æ•°æ‹¥æœ‰å°½å¯èƒ½ä½Žçš„æ ˆä½¿ç”¨é‡çš„å…³é”®æ˜¯å°½å¯èƒ½åœ°ä»Žå †ä¸­åˆ†é…å±€éƒ¨å˜é‡ï¼ˆå°¤å…¶æ˜¯å ç”¨å†…å­˜è¾ƒå¤§çš„å˜é‡ï¼‰å¹¶æ‰‹åŠ¨åœ°ç®¡ç†å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸï¼ˆmalloc/freeï¼‰ï¼Œè€Œéžé»˜è®¤åœ°ä»Žå †æ ˆä¸Šåˆ†é…å’Œè‡ªåŠ¨é‡Šæ”¾å®ƒä»¬ã€‚Cç¼–è¯‘å™¨gccçš„é€‰é¡¹`-fstack-usage`å¯¹æ­¤éžå¸¸æœ‰ç”¨ã€‚\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int ct = 0;\n    gl_ptr = &ct; // line 7\n    aco_yield();\n    check(ct);\n    int* ptr = &ct;\n    inc_p(ptr);   // line 11\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr); // line 16\n    aco_exit();\n}\n```\n\n4. åœ¨ä¸Šé¢çš„ä»£ç ç‰‡æ®µä¸­ï¼Œæˆ‘ä»¬å‡å®šåç¨‹co_fp0ä¸Žco_fp1å…±äº«åŒä¸€ä¸ªæ‰§è¡Œæ ˆï¼Œå®ƒä»¬å‡æ˜¯non-main coï¼Œå®ƒä»¬çš„æ‰§è¡Œé¡ºåºä¸º \"co_fp0 -> co_fp1 -> co_fp0\" ã€‚å› ä¸ºå®ƒä»¬å…±äº«åŒä¸€ä¸ªæ‰§è¡Œæ ˆï¼Œåœ¨ä»£ç ç¬¬16è¡Œ`gl_ptr`ä¸­çš„æŒ‡é’ˆå€¼ä¸Žä»£ç ç¬¬7è¡Œ`gl_ptr`ä¸­çš„æŒ‡é’ˆå€¼äºŒè€…çš„è¯­ä¹‰æ˜¯ä¸åŒçš„ï¼Œè¿™æ ·çš„ç”¨æ³•å¾ˆå¯èƒ½ä¼šç ´ååç¨‹co_fp1çš„æ‰§è¡Œæ ˆã€‚è€Œä»£ç ç¬¬11è¡Œåˆ™æ˜¯æ­£ç¡®çš„ï¼Œå› ä¸ºæ­¤æ—¶å±€éƒ¨å˜é‡`ct`ä¸Žå‡½æ•°`inc_p`çš„æ‰§è¡Œæ˜¯åœ¨åŒä¸€ä¸ªåç¨‹ä¸Šä¸‹æ–‡ä¸­çš„ã€‚ä»Žå †ä¸­åˆ†é…éœ€è¦åœ¨åç¨‹é—´å…±äº«çš„å†…å­˜èƒ½å¤Ÿå¾ˆç®€å•åœ°è§£å†³è¿™ç±»é—®é¢˜ï¼š\n\n```c\nint* gl_ptr;\n\nvoid inc_p(int* p){ (*p)++; }\n\nvoid co_fp0() {\n    int* ct_ptr = malloc(sizeof(int));\n    assert(ct_ptr != NULL);\n    *ct_ptr = 0;\n    gl_ptr = ct_ptr;\n    aco_yield();\n    check(*ct_ptr);\n    int* ptr = ct_ptr;\n    inc_p(ptr);\n    free(ct_ptr);\n    gl_ptr = NULL;\n    aco_exit();\n}\n\nvoid co_fp1() {\n    do_sth(gl_ptr);\n    aco_exit();\n}\n```\n\n# TODO\n\nNew ideas are welcome!\n\n* Add a macro `aco_new` which is the combination of something like `p = malloc(sz); assertalloc_ptr(p)`.\n\n* Add a new API `aco_reset` to support the reusability of the coroutine objects.\n\n* Support other platforms (especially arm & arm64).\n\n# CHANGES\n\n```\nv1.2.2 Mon Jul 9 2018\n    Added a new option `-o <no-m32|no-valgrind>` to make.sh;\n    Correction about the value of macro ACO_VERSION_PATCH (issue #1 \n    kindly reported by Markus Elfring @elfring);\n    Adjusted some noncompliant naming of identifiers (double underscore\n    `__`) (issue #1, kindly proposed by Markus Elfring @elfring);\n    Supported the header file including by C++ (issue #4, kindly\n    proposed by Markus Elfring @elfring).\nv1.2.1 Sat Jul 7 2018\n    Fixed some noncompliant include guards in two C header files (\n    issue #1 kindly reported by Markus Elfring @elfring);\n    Removed the \"pure\" word from \"pure C\" statement since it is\n    containing assembly codes (kindly reported by Peter Cawley\n    @corsix);\n    Many updates in the README.md document.\nv1.2.0 Tue Jul 3 2018\n    Provided another header named `aco_assert_override.h` so user\n    could choose to override the default `assert` or not;\n    Added some macros about the version information.\nv1.1   Mon Jul 2 2018\n    Removed the requirement on the GCC version (>= 5.0).\nv1.0   Sun Jul 1 2018\n    The v1.0 release of libaco, cheers ðŸŽ‰ðŸŽ‰ðŸŽ‰\n```\n\n# Donation\n\næˆ‘æ˜¯ä¸€ä½è‡ªç”±çš„å…¨èŒå¼€æºé¡¹ç›®å¼€å‘è€…ï¼Œä»»ä½•æ•°é‡çš„æèµ å¯¹æˆ‘éƒ½å°†ä¼šæ˜¯èŽ«å¤§çš„é¼“åŠ± ;-)\n\n* Paypal\n\n  [paypal.me link](https://www.paypal.me/00hnes)\n\n* Alipay (æ”¯ä»˜(å®|å¯¶))\n\n![qr_alipay](img/qr_alipay.png)\n\n* Wechat (å¾®ä¿¡)\n\n![qr_wechat](img/qr_wechat.png)\n\n# Copyright and License\n\nCopyright (C) 2018, by Sen Han [<00hnes@gmail.com>](mailto:00hnes@gmail.com).\n\nUnder the Apache License, Version 2.0.\n\nSee the [LICENSE](LICENSE) file for details.\n"
        },
        {
          "name": "aco.c",
          "type": "blob",
          "size": 17.080078125,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#define _GNU_SOURCE\n\n#include \"aco.h\"\n#include <stdio.h>\n#include <stdint.h>\n\n// this header including should be at the last of the `include` directives list\n#include \"aco_assert_override.h\"\n\nvoid aco_runtime_test(void){\n#ifdef __i386__\n    _Static_assert(sizeof(void*) == 4, \"require 'sizeof(void*) == 4'\");\n#elif  __x86_64__\n    _Static_assert(sizeof(void*) == 8, \"require 'sizeof(void*) == 8'\");\n    _Static_assert(sizeof(__uint128_t) == 16, \"require 'sizeof(__uint128_t) == 16'\");\n#else\n    #error \"platform no support yet\"\n#endif\n    _Static_assert(sizeof(int) >= 4, \"require 'sizeof(int) >= 4'\");\n    assert(sizeof(int) >= 4);\n    _Static_assert(sizeof(int) <= sizeof(size_t),\n        \"require 'sizeof(int) <= sizeof(size_t)'\");\n    assert(sizeof(int) <= sizeof(size_t));\n}\n\n// assertptr(dst); assertptr(src);\n// assert((((uintptr_t)(src) & 0x0f) == 0) && (((uintptr_t)(dst) & 0x0f) == 0));\n// assert((((sz) & 0x0f) == 0x08) && (((sz) >> 4) >= 0) && (((sz) >> 4) <= 8));\n// sz = 16*n + 8 ( 0 <= n <= 8)\n\n// Note: dst and src must be valid address already\n#define aco_amd64_inline_short_aligned_memcpy_test_ok(dst, src, sz) \\\n    (   \\\n        (((uintptr_t)(src) & 0x0f) == 0) && (((uintptr_t)(dst) & 0x0f) == 0) \\\n        &&  \\\n        (((sz) & 0x0f) == 0x08) && (((sz) >> 4) >= 0) && (((sz) >> 4) <= 8) \\\n    )\n\n#define aco_amd64_inline_short_aligned_memcpy(dst, src, sz) do {\\\n    __uint128_t xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7; \\\n    switch((sz) >> 4){ \\\n    case 0:  \\\n        break;  \\\n    case 1:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        break;  \\\n    case 2:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        break;  \\\n    case 3:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        break;  \\\n    case 4:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        break;  \\\n    case 5:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        break;  \\\n    case 6:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        xmm5 = *((__uint128_t*)(src) + 5);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        *((__uint128_t*)(dst) + 5) = xmm5; \\\n        break;  \\\n    case 7:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        xmm5 = *((__uint128_t*)(src) + 5);  \\\n        xmm6 = *((__uint128_t*)(src) + 6);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        *((__uint128_t*)(dst) + 5) = xmm5; \\\n        *((__uint128_t*)(dst) + 6) = xmm6; \\\n        break;  \\\n    case 8:  \\\n        xmm0 = *((__uint128_t*)(src) + 0);  \\\n        xmm1 = *((__uint128_t*)(src) + 1);  \\\n        xmm2 = *((__uint128_t*)(src) + 2);  \\\n        xmm3 = *((__uint128_t*)(src) + 3);  \\\n        xmm4 = *((__uint128_t*)(src) + 4);  \\\n        xmm5 = *((__uint128_t*)(src) + 5);  \\\n        xmm6 = *((__uint128_t*)(src) + 6);  \\\n        xmm7 = *((__uint128_t*)(src) + 7);  \\\n        *((__uint128_t*)(dst) + 0) = xmm0; \\\n        *((__uint128_t*)(dst) + 1) = xmm1; \\\n        *((__uint128_t*)(dst) + 2) = xmm2; \\\n        *((__uint128_t*)(dst) + 3) = xmm3; \\\n        *((__uint128_t*)(dst) + 4) = xmm4; \\\n        *((__uint128_t*)(dst) + 5) = xmm5; \\\n        *((__uint128_t*)(dst) + 6) = xmm6; \\\n        *((__uint128_t*)(dst) + 7) = xmm7; \\\n        break;  \\\n    }\\\n    *((uint64_t*)((uintptr_t)(dst) + (sz) - 8)) = *((uint64_t*)((uintptr_t)(src) + (sz) - 8)); \\\n} while(0)\n\n// Note: dst and src must be valid address already\n#define aco_amd64_optimized_memcpy_drop_in(dst, src, sz) do {\\\n    if(aco_amd64_inline_short_aligned_memcpy_test_ok((dst), (src), (sz))){ \\\n        aco_amd64_inline_short_aligned_memcpy((dst), (src), (sz)); \\\n    }else{ \\\n        memcpy((dst), (src), (sz)); \\\n    } \\\n} while(0)\n\nstatic void aco_default_protector_last_word(void){\n    aco_t* co = aco_get_co();\n    // do some log about the offending `co`\n    fprintf(stderr,\"error: aco_default_protector_last_word triggered\\n\");\n    fprintf(stderr, \"error: co:%p should call `aco_exit()` instead of direct \"\n        \"`return` in co_fp:%p to finish its execution\\n\", co, (void*)co->fp);\n    assert(0);\n}\n\n// aco's Global Thread Local Storage variable `co`\n__thread aco_t* aco_gtls_co;\nstatic __thread aco_cofuncp_t aco_gtls_last_word_fp = aco_default_protector_last_word;\n\n#ifdef __i386__\n    static __thread void* aco_gtls_fpucw_mxcsr[2];\n#elif  __x86_64__\n    static __thread void* aco_gtls_fpucw_mxcsr[1];\n#else\n    #error \"platform no support yet\"\n#endif\n\nvoid aco_thread_init(aco_cofuncp_t last_word_co_fp){\n    aco_save_fpucw_mxcsr(aco_gtls_fpucw_mxcsr);\n\n    if((void*)last_word_co_fp != NULL)\n        aco_gtls_last_word_fp = last_word_co_fp;\n}\n\n// This function `aco_funcp_protector` should never be\n// called. If it's been called, that means the offending\n// `co` didn't call aco_exit(co) instead of `return` to\n// finish its execution.\nvoid aco_funcp_protector(void){\n    if((void*)(aco_gtls_last_word_fp) != NULL){\n        aco_gtls_last_word_fp();\n    }else{\n        aco_default_protector_last_word();\n    }\n    assert(0);\n}\n\naco_share_stack_t* aco_share_stack_new(size_t sz){\n    return aco_share_stack_new2(sz, 1);\n}\n\n#define aco_size_t_safe_add_assert(a,b) do {   \\\n    assert((a)+(b) >= (a)); \\\n}while(0)\n\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled){\n    if(sz == 0){\n        sz = 1024 * 1024 * 2;\n    }\n    if(sz < 4096){\n        sz = 4096;\n    }\n    assert(sz > 0);\n\n    size_t u_pgsz = 0;\n    if(guard_page_enabled != 0){\n        // although gcc's Built-in Functions to Perform Arithmetic with\n        // Overflow Checking is better, but it would require gcc >= 5.0\n        long pgsz = sysconf(_SC_PAGESIZE);\n        // pgsz must be > 0 && a power of two\n        assert(pgsz > 0 && (((pgsz - 1) & pgsz) == 0));\n        u_pgsz = (size_t)((unsigned long)pgsz);\n        // it should be always true in real life\n        assert(u_pgsz == (unsigned long)pgsz && ((u_pgsz << 1) >> 1) == u_pgsz);\n        if(sz <= u_pgsz){\n            sz = u_pgsz << 1;\n        } else {\n            size_t new_sz;\n            if((sz & (u_pgsz - 1)) != 0){\n                new_sz = (sz & (~(u_pgsz - 1)));\n                assert(new_sz >= u_pgsz);\n                aco_size_t_safe_add_assert(new_sz, (u_pgsz << 1));\n                new_sz = new_sz + (u_pgsz << 1);\n                assert(sz / u_pgsz + 2 == new_sz / u_pgsz);\n            } else {\n                aco_size_t_safe_add_assert(sz, u_pgsz);\n                new_sz = sz + u_pgsz;\n                assert(sz / u_pgsz + 1 == new_sz / u_pgsz);\n            }\n            sz = new_sz;\n            assert((sz / u_pgsz > 1) && ((sz & (u_pgsz - 1)) == 0));\n        }\n    }\n\n    aco_share_stack_t* p = (aco_share_stack_t*)malloc(sizeof(aco_share_stack_t));\n    assertalloc_ptr(p);\n    memset(p, 0, sizeof(aco_share_stack_t));\n\n    if(guard_page_enabled != 0){\n        p->real_ptr = mmap(\n            NULL, sz, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0\n        );\n        assertalloc_bool(p->real_ptr != MAP_FAILED);\n        p->guard_page_enabled = 1;\n        assert(0 == mprotect(p->real_ptr, u_pgsz, PROT_READ));\n\n        p->ptr = (void*)(((uintptr_t)p->real_ptr) + u_pgsz);\n        p->real_sz = sz;\n        assert(sz >= (u_pgsz << 1));\n        p->sz = sz - u_pgsz;\n    } else {\n        //p->guard_page_enabled = 0;\n        p->sz = sz;\n        p->ptr = malloc(sz);\n        assertalloc_ptr(p->ptr);\n    }\n\n    p->owner = NULL;\n#ifdef ACO_USE_VALGRIND\n    p->valgrind_stk_id = VALGRIND_STACK_REGISTER(\n        p->ptr, (void*)((uintptr_t)p->ptr + p->sz)\n    );\n#endif\n#if defined(__i386__) || defined(__x86_64__)\n    uintptr_t u_p = (uintptr_t)(p->sz - (sizeof(void*) << 1) + (uintptr_t)p->ptr);\n    u_p = (u_p >> 4) << 4;\n    p->align_highptr = (void*)u_p;\n    p->align_retptr  = (void*)(u_p - sizeof(void*));\n    *((void**)(p->align_retptr)) = (void*)(aco_funcp_protector_asm);\n    assert(p->sz > (16 + (sizeof(void*) << 1) + sizeof(void*)));\n    p->align_limit = p->sz - 16 - (sizeof(void*) << 1);\n#else\n    #error \"platform no support yet\"\n#endif\n    return p;\n}\n\nvoid aco_share_stack_destroy(aco_share_stack_t* sstk){\n    assert(sstk != NULL && sstk->ptr != NULL);\n#ifdef ACO_USE_VALGRIND\n    VALGRIND_STACK_DEREGISTER(sstk->valgrind_stk_id);\n#endif\n    if(sstk->guard_page_enabled){\n        assert(0 == munmap(sstk->real_ptr, sstk->real_sz));\n        sstk->real_ptr = NULL;\n        sstk->ptr = NULL;\n    } else {\n        free(sstk->ptr);\n        sstk->ptr = NULL;\n    }\n    free(sstk);\n}\n\naco_t* aco_create(\n        aco_t* main_co, aco_share_stack_t* share_stack,\n        size_t save_stack_sz, aco_cofuncp_t fp, void* arg\n    ){\n\n    aco_t* p = (aco_t*)malloc(sizeof(aco_t));\n    assertalloc_ptr(p);\n    memset(p, 0, sizeof(aco_t));\n\n    if(main_co != NULL){ // non-main co\n        assertptr(share_stack);\n        p->share_stack = share_stack;\n#ifdef __i386__\n        // POSIX.1-2008 (IEEE Std 1003.1-2008) - General Information - Data Types - Pointer Types\n        // http://pubs.opengroup.org/onlinepubs/9699919799.2008edition/functions/V2_chap02.html#tag_15_12_03\n        p->reg[ACO_REG_IDX_RETADDR] = (void*)fp;\n        // push retaddr\n        p->reg[ACO_REG_IDX_SP] = p->share_stack->align_retptr;\n        #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n            p->reg[ACO_REG_IDX_FPU] = aco_gtls_fpucw_mxcsr[0];\n            p->reg[ACO_REG_IDX_FPU + 1] = aco_gtls_fpucw_mxcsr[1];\n        #endif\n#elif  __x86_64__\n        p->reg[ACO_REG_IDX_RETADDR] = (void*)fp;\n        p->reg[ACO_REG_IDX_SP] = p->share_stack->align_retptr;\n        #ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n            p->reg[ACO_REG_IDX_FPU] = aco_gtls_fpucw_mxcsr[0];\n        #endif\n#else\n        #error \"platform no support yet\"\n#endif\n        p->main_co = main_co;\n        p->arg = arg;\n        p->fp = fp;\n        if(save_stack_sz == 0){\n            save_stack_sz = 64;\n        }\n        p->save_stack.ptr = malloc(save_stack_sz);\n        assertalloc_ptr(p->save_stack.ptr);\n        p->save_stack.sz = save_stack_sz;\n#if defined(__i386__) || defined(__x86_64__)\n        p->save_stack.valid_sz = 0;\n#else\n        #error \"platform no support yet\"\n#endif\n        return p;\n    } else { // main co\n        p->main_co = NULL;\n        p->arg = arg;\n        p->fp = fp;\n        p->share_stack = NULL;\n        p->save_stack.ptr = NULL;\n        return p;\n    }\n    assert(0);\n}\n\naco_attr_no_asan\nvoid aco_resume(aco_t* resume_co){\n    assert(resume_co != NULL && resume_co->main_co != NULL\n        && resume_co->is_end == 0\n    );\n    if(resume_co->share_stack->owner != resume_co){\n        if(resume_co->share_stack->owner != NULL){\n            aco_t* owner_co = resume_co->share_stack->owner;\n            assert(owner_co->share_stack == resume_co->share_stack);\n#if defined(__i386__) || defined(__x86_64__)\n            assert(\n                (\n                    (uintptr_t)(owner_co->share_stack->align_retptr)\n                    >=\n                    (uintptr_t)(owner_co->reg[ACO_REG_IDX_SP])\n                )\n                &&\n                (\n                    (uintptr_t)(owner_co->share_stack->align_highptr)\n                    -\n                    (uintptr_t)(owner_co->share_stack->align_limit)\n                    <=\n                    (uintptr_t)(owner_co->reg[ACO_REG_IDX_SP])\n                )\n            );\n            owner_co->save_stack.valid_sz =\n                (uintptr_t)(owner_co->share_stack->align_retptr)\n                -\n                (uintptr_t)(owner_co->reg[ACO_REG_IDX_SP]);\n            if(owner_co->save_stack.sz < owner_co->save_stack.valid_sz){\n                free(owner_co->save_stack.ptr);\n                owner_co->save_stack.ptr = NULL;\n                while(1){\n                    owner_co->save_stack.sz = owner_co->save_stack.sz << 1;\n                    assert(owner_co->save_stack.sz > 0);\n                    if(owner_co->save_stack.sz >= owner_co->save_stack.valid_sz){\n                        break;\n                    }\n                }\n                owner_co->save_stack.ptr = malloc(owner_co->save_stack.sz);\n                assertalloc_ptr(owner_co->save_stack.ptr);\n            }\n            // TODO: optimize the performance penalty of memcpy function call\n            //   for very short memory span\n            if(owner_co->save_stack.valid_sz > 0) {\n    #ifdef __x86_64__\n                aco_amd64_optimized_memcpy_drop_in(\n                    owner_co->save_stack.ptr,\n                    owner_co->reg[ACO_REG_IDX_SP],\n                    owner_co->save_stack.valid_sz\n                );\n    #else\n                memcpy(\n                    owner_co->save_stack.ptr,\n                    owner_co->reg[ACO_REG_IDX_SP],\n                    owner_co->save_stack.valid_sz\n                );\n    #endif\n                owner_co->save_stack.ct_save++;\n            }\n            if(owner_co->save_stack.valid_sz > owner_co->save_stack.max_cpsz){\n                owner_co->save_stack.max_cpsz = owner_co->save_stack.valid_sz;\n            }\n            owner_co->share_stack->owner = NULL;\n            owner_co->share_stack->align_validsz = 0;\n#else\n            #error \"platform no support yet\"\n#endif\n        }\n        assert(resume_co->share_stack->owner == NULL);\n#if defined(__i386__) || defined(__x86_64__)\n        assert(\n            resume_co->save_stack.valid_sz\n            <=\n            resume_co->share_stack->align_limit - sizeof(void*)\n        );\n        // TODO: optimize the performance penalty of memcpy function call\n        //   for very short memory span\n        if(resume_co->save_stack.valid_sz > 0) {\n    #ifdef __x86_64__\n            aco_amd64_optimized_memcpy_drop_in(\n                (void*)(\n                    (uintptr_t)(resume_co->share_stack->align_retptr)\n                    -\n                    resume_co->save_stack.valid_sz\n                ),\n                resume_co->save_stack.ptr,\n                resume_co->save_stack.valid_sz\n            );\n    #else\n            memcpy(\n                (void*)(\n                    (uintptr_t)(resume_co->share_stack->align_retptr)\n                    -\n                    resume_co->save_stack.valid_sz\n                ),\n                resume_co->save_stack.ptr,\n                resume_co->save_stack.valid_sz\n            );\n    #endif\n            resume_co->save_stack.ct_restore++;\n        }\n        if(resume_co->save_stack.valid_sz > resume_co->save_stack.max_cpsz){\n            resume_co->save_stack.max_cpsz = resume_co->save_stack.valid_sz;\n        }\n        resume_co->share_stack->align_validsz = resume_co->save_stack.valid_sz + sizeof(void*);\n        resume_co->share_stack->owner = resume_co;\n#else\n        #error \"platform no support yet\"\n#endif\n    }\n    aco_gtls_co = resume_co;\n    acosw(resume_co->main_co, resume_co);\n    aco_gtls_co = resume_co->main_co;\n}\n\nvoid aco_destroy(aco_t* co){\n    assertptr(co);\n    if(aco_is_main_co(co)){\n        free(co);\n    } else {\n        if(co->share_stack->owner == co){\n            co->share_stack->owner = NULL;\n            co->share_stack->align_validsz = 0;\n        }\n        free(co->save_stack.ptr);\n        co->save_stack.ptr = NULL;\n        free(co);\n    }\n}\n"
        },
        {
          "name": "aco.h",
          "type": "blob",
          "size": 5.55078125,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef ACO_H\n#define ACO_H\n\n#include <string.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/mman.h>\n\n#ifdef ACO_USE_VALGRIND\n    #include <valgrind/valgrind.h>\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ACO_VERSION_MAJOR 1\n#define ACO_VERSION_MINOR 2\n#define ACO_VERSION_PATCH 4\n\n#ifdef __i386__\n    #define ACO_REG_IDX_RETADDR 0\n    #define ACO_REG_IDX_SP 1\n    #define ACO_REG_IDX_BP 2\n    #define ACO_REG_IDX_FPU 6\n#elif __x86_64__\n    #define ACO_REG_IDX_RETADDR 4\n    #define ACO_REG_IDX_SP 5\n    #define ACO_REG_IDX_BP 7\n    #define ACO_REG_IDX_FPU 8\n#else\n    #error \"platform no support yet\"\n#endif\n\ntypedef struct {\n    void*  ptr;\n    size_t sz;\n    size_t valid_sz;\n    // max copy size in bytes\n    size_t max_cpsz;\n    // copy from share stack to this save stack\n    size_t ct_save;\n    // copy from this save stack to share stack \n    size_t ct_restore;\n} aco_save_stack_t;\n\nstruct aco_s;\ntypedef struct aco_s aco_t;\n\ntypedef struct {\n    void*  ptr;            \n    size_t sz;\n    void*  align_highptr;\n    void*  align_retptr;\n    size_t align_validsz;\n    size_t align_limit;\n    aco_t* owner;\n\n    char guard_page_enabled;\n    void* real_ptr;\n    size_t real_sz;\n\n#ifdef ACO_USE_VALGRIND\n    unsigned long valgrind_stk_id;\n#endif\n} aco_share_stack_t;\n\ntypedef void (*aco_cofuncp_t)(void);\n\nstruct aco_s{\n    // cpu registers' state\n#ifdef __i386__\n    #ifdef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n        void*  reg[6];\n    #else\n        void*  reg[8];\n    #endif\n#elif __x86_64__\n    #ifdef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n        void*  reg[8];\n    #else\n        void*  reg[9];\n    #endif\n#else\n    #error \"platform no support yet\"\n#endif\n    aco_t* main_co;\n    void*  arg;\n    char   is_end;\n\n    aco_cofuncp_t fp;\n    \n    aco_save_stack_t  save_stack;\n    aco_share_stack_t* share_stack;\n};\n\n#define aco_likely(x) (__builtin_expect(!!(x), 1))\n\n#define aco_unlikely(x) (__builtin_expect(!!(x), 0))\n\n#define aco_assert(EX)  ((aco_likely(EX))?((void)0):(abort()))\n\n#define aco_assertptr(ptr)  ((aco_likely((ptr) != NULL))?((void)0):(abort()))\n\n#define aco_assertalloc_bool(b)  do {  \\\n    if(aco_unlikely(!(b))){    \\\n        fprintf(stderr, \"Aborting: failed to allocate memory: %s:%d:%s\\n\", \\\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);    \\\n        abort();    \\\n    }   \\\n} while(0)\n\n#define aco_assertalloc_ptr(ptr)  do {  \\\n    if(aco_unlikely((ptr) == NULL)){    \\\n        fprintf(stderr, \"Aborting: failed to allocate memory: %s:%d:%s\\n\", \\\n            __FILE__, __LINE__, __PRETTY_FUNCTION__);    \\\n        abort();    \\\n    }   \\\n} while(0)\n\n#if defined(aco_attr_no_asan)\n    #error \"aco_attr_no_asan already defined\"\n#endif\n#if defined(ACO_USE_ASAN)\n    #if defined(__has_feature)\n        #if __has_feature(__address_sanitizer__)\n            #define aco_attr_no_asan \\\n                __attribute__((__no_sanitize_address__))\n        #endif\n    #endif\n    #if defined(__SANITIZE_ADDRESS__) && !defined(aco_attr_no_asan)\n        #define aco_attr_no_asan \\\n            __attribute__((__no_sanitize_address__))\n    #endif\n#endif\n#ifndef aco_attr_no_asan\n    #define aco_attr_no_asan\n#endif\n\nextern void aco_runtime_test(void);\n\nextern void aco_thread_init(aco_cofuncp_t last_word_co_fp);\n\nextern void* acosw(aco_t* from_co, aco_t* to_co) __asm__(\"acosw\"); // asm\n\nextern void aco_save_fpucw_mxcsr(void* p) __asm__(\"aco_save_fpucw_mxcsr\");  // asm\n\nextern void aco_funcp_protector_asm(void) __asm__(\"aco_funcp_protector_asm\"); // asm\n\nextern void aco_funcp_protector(void);\n\nextern aco_share_stack_t* aco_share_stack_new(size_t sz);\n\naco_share_stack_t* aco_share_stack_new2(size_t sz, char guard_page_enabled);\n\nextern void aco_share_stack_destroy(aco_share_stack_t* sstk);\n\nextern aco_t* aco_create(\n        aco_t* main_co,\n        aco_share_stack_t* share_stack, \n        size_t save_stack_sz, \n        aco_cofuncp_t fp, void* arg\n    );\n\n// aco's Global Thread Local Storage variable `co`\nextern __thread aco_t* aco_gtls_co;\n\naco_attr_no_asan\nextern void aco_resume(aco_t* resume_co);\n\n//extern void aco_yield1(aco_t* yield_co);\n#define aco_yield1(yield_co) do {             \\\n    aco_assertptr((yield_co));                    \\\n    aco_assertptr((yield_co)->main_co);           \\\n    acosw((yield_co), (yield_co)->main_co);   \\\n} while(0)\n\n#define aco_yield() do {        \\\n    aco_yield1(aco_gtls_co);    \\\n} while(0)\n\n#define aco_get_arg() (aco_gtls_co->arg)\n\n#define aco_get_co() ({(void)0; aco_gtls_co;})\n\n#define aco_co() ({(void)0; aco_gtls_co;})\n\nextern void aco_destroy(aco_t* co);\n\n#define aco_is_main_co(co) ({((co)->main_co) == NULL;})\n\n#define aco_exit1(co) do {     \\\n    (co)->is_end = 1;           \\\n    aco_assert((co)->share_stack->owner == (co)); \\\n    (co)->share_stack->owner = NULL; \\\n    (co)->share_stack->align_validsz = 0; \\\n    aco_yield1((co));            \\\n    aco_assert(0);                  \\\n} while(0)\n\n#define aco_exit() do {       \\\n    aco_exit1(aco_gtls_co); \\\n} while(0)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "aco_assert_override.h",
          "type": "blob",
          "size": 1.0400390625,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef ACO_ASSERT_OVERRIDE_H\n#define ACO_ASSERT_OVERRIDE_H\n\n#include \"aco.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define likely(x)               aco_likely(x)\n#define unlikely(x)             aco_unlikely(x)\n#define assert(EX)              aco_assert(EX)\n#define assertptr(ptr)          aco_assertptr(ptr)\n#define assertalloc_bool(b)     aco_assertalloc_bool(b)\n#define assertalloc_ptr(ptr)    aco_assertalloc_ptr(ptr)\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "acosw.S",
          "type": "blob",
          "size": 5.2861328125,
          "content": ".text\n.globl acosw\n#if defined(__APPLE__)\n#else\n.type  acosw, @function\n#endif\n.intel_syntax noprefix\nacosw:\n/*\n    extern void acosw(aco_t* from_co, aco_t* to_co);\n\n    struct aco_t {\n        void*  reg[X];\n        // ...\n    }\n     \n    reference:\n        https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI\n\n    pitfall:\n        http://man7.org/linux/man-pages/man7/signal.7.html\n        http://man7.org/linux/man-pages/man2/sigaltstack.2.html\n\n        > $ man 7 signal\n        > ...\n        > By default, the signal handler is invoked on the normal process \n        > stack.   It  is  possible  to arrange that the signal handler \n        > uses an alternate stack; see sigaltstack(2) for a discussion of \n        > how to do this and when it might be useful.\n        > ...\n\n        This is a BUG example: \n            https://github.com/Tencent/libco/blob/v1.0/coctx_swap.S#L27\n\n    proof of correctness:\n        https://github.com/hnes/libaco\n\n    mxcsr & fpu:\n        fnstcw * m2byte\n            Store FPU control word to m2byte without checking for \n            pending unmasked floating-point exceptions.\n        \n        fldcw m2byte\n            Load FPU control word from m2byte.\n\n        stmxcsr m32\n            Store contents of MXCSR register to m32\n\n        ldmxcsr m32\n            Load MXCSR register from m32.\n*/\n/*\n    0x00             -->               0xff\n    eip esp ebp edi esi ebx fpucw16 mxcsr32\n    0   4   8   c   10  14  18      1c\n*/\n#ifdef __i386__\n    mov     eax,DWORD PTR [esp+0x4]     // from_co\n    mov     edx,DWORD PTR [esp]         // retaddr\n    lea     ecx,[esp+0x4]               // esp\n    mov     DWORD PTR [eax+0x8],ebp     //<ebp\n    mov     DWORD PTR [eax+0x4],ecx     //<esp\n    mov     DWORD PTR [eax+0x0],edx     //<retaddr\n    mov     DWORD PTR [eax+0xc],edi     //<edi\n    mov     ecx,DWORD PTR [esp+0x8]     // to_co\n    mov     DWORD PTR [eax+0x10],esi    //<esi\n    mov     DWORD PTR [eax+0x14],ebx    //<ebx\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fnstcw  WORD  PTR [eax+0x18]        //<fpucw\n    stmxcsr DWORD PTR [eax+0x1c]        //<mxcsr\n#endif\n    mov     edx,DWORD PTR [ecx+0x4]     //>esp\n    mov     ebp,DWORD PTR [ecx+0x8]     //>ebp\n    mov     eax,DWORD PTR [ecx+0x0]     //>retaddr\n    mov     edi,DWORD PTR [ecx+0xc]     //>edi\n    mov     esi,DWORD PTR [ecx+0x10]    //>esi\n    mov     ebx,DWORD PTR [ecx+0x14]    //>ebx\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fldcw   WORD  PTR     [ecx+0x18]        //>fpucw\n    ldmxcsr DWORD PTR     [ecx+0x1c]        //>mxcsr\n#endif\n    xor     ecx,ecx\n    mov     esp,edx\n    xor     edx,edx\n    jmp     eax\n#elif __x86_64__\n/*\n    0x00                  -->                  0xff\n    r12 r13 r14 r15 rip rsp rbx rbp fpucw16 mxcsr32\n    0   8   10  18  20  28  30  38  40      44\n*/\n    // rdi - from_co | rsi - to_co\n    mov     rdx,QWORD PTR [rsp]      // retaddr\n    lea     rcx,[rsp+0x8]            // rsp\n    mov     QWORD PTR [rdi+0x0], r12\n    mov     QWORD PTR [rdi+0x8], r13\n    mov     QWORD PTR [rdi+0x10],r14\n    mov     QWORD PTR [rdi+0x18],r15\n    mov     QWORD PTR [rdi+0x20],rdx // retaddr\n    mov     QWORD PTR [rdi+0x28],rcx // rsp\n    mov     QWORD PTR [rdi+0x30],rbx\n    mov     QWORD PTR [rdi+0x38],rbp\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fnstcw  WORD PTR  [rdi+0x40]\n    stmxcsr DWORD PTR [rdi+0x44]\n#endif\n    mov     r12,QWORD PTR [rsi+0x0]\n    mov     r13,QWORD PTR [rsi+0x8]\n    mov     r14,QWORD PTR [rsi+0x10]\n    mov     r15,QWORD PTR [rsi+0x18]\n    mov     rax,QWORD PTR [rsi+0x20] // retaddr\n    mov     rcx,QWORD PTR [rsi+0x28] // rsp\n    mov     rbx,QWORD PTR [rsi+0x30]\n    mov     rbp,QWORD PTR [rsi+0x38]\n#ifndef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    fldcw   WORD PTR      [rsi+0x40]\n    ldmxcsr DWORD PTR     [rsi+0x44]\n#endif\n    mov     rsp,rcx\n    jmp     rax\n#else\n    #error \"platform not support\"\n#endif\n\n.globl aco_save_fpucw_mxcsr\n#if defined(__APPLE__)\n#else\n.type  aco_save_fpucw_mxcsr, @function\n#endif\n.intel_syntax noprefix\naco_save_fpucw_mxcsr:\n#ifdef __i386__\n    mov     eax,DWORD PTR [esp+0x4]     // ptr\n    fnstcw  WORD PTR  [eax]\n    stmxcsr DWORD PTR [eax+0x4] \n    ret\n#elif __x86_64__\n    fnstcw  WORD PTR  [rdi]\n    stmxcsr DWORD PTR [rdi+0x4]\n    ret\n#else\n    #error \"platform not support\"\n#endif\n\n#if defined(__APPLE__)\n.globl _abort\n.globl _aco_funcp_protector\n#else\n.globl abort\n.globl aco_funcp_protector\n#endif\n\n.globl aco_funcp_protector_asm\n#if defined(__APPLE__)\n#else\n.type  aco_funcp_protector_asm, @function\n#endif\n.intel_syntax noprefix\naco_funcp_protector_asm:\n#ifdef __i386__\n            and     esp,0xfffffff0\n    #if defined(__APPLE__)\n            call    _aco_funcp_protector\n            call    _abort\n    #else\n        #if defined(__pic__) || defined(__PIC__)\n            call    aco_funcp_protector@PLT\n            call    abort@PLT\n        #else\n            call    aco_funcp_protector\n            call    abort\n        #endif\n    #endif\n            ret\n#elif __x86_64__\n            and     rsp,0xfffffffffffffff0\n    #if defined(__APPLE__)\n            call    _aco_funcp_protector\n            call    _abort\n    #else\n        #if defined(__pic__) || defined(__PIC__)\n            call    aco_funcp_protector@PLT\n            call    abort@PLT\n        #else\n            call    aco_funcp_protector\n            call    abort\n        #endif\n    #endif\n            ret\n#else\n    #error \"platform not support\"\n#endif\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "make.sh",
          "type": "blob",
          "size": 5.6201171875,
          "content": "# Copyright 2018 Sen Han <00hnes@gmail.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http:#www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nOUTPUT_DIR=\"./output\"\nCFLAGS=\"-g -O2 -Wall -Werror\"\n#EXTRA_CFLAGS=\"\"\nOUTPUT_SUFFIX=\"\"\nmakecc=\"cc\"\nif [ \"$CC\" ]\nthen\n    makecc=\"$CC\"\nfi\n\napp_list='''\ntest_aco_tutorial_0\ntest_aco_tutorial_1\ntest_aco_tutorial_2\ntest_aco_tutorial_3 -lpthread\ntest_aco_tutorial_4\ntest_aco_tutorial_5\ntest_aco_tutorial_6\ntest_aco_synopsis\ntest_aco_benchmark\n'''\n\ngl_opt_no_m32=\"\"\ngl_opt_no_valgrind=\"\"\n\nOUTPUT_DIR=\"$OUTPUT_DIR\"\"//file\"\nOUTPUT_DIR=`dirname \"$OUTPUT_DIR\"`\n\ngl_trap_str=\"\"\n\nfunction error(){\n    >&2 echo \"error: $*\"\n}\n\nfunction assert(){\n    if [ \"0\" -ne \"$?\" ]\n    then\n        error \"$0:\"\"$*\"\n        exit 1\n    fi\n}\n\nfunction tra(){\n    gl_trap_str=\"$gl_trap_str\"\"$1\"\n    trap \"$gl_trap_str exit 1;\" INT\n    assert \"$LINENO:trap failed:$gl_trap_str:$1\"\n}\n\nfunction untra(){\n    trap - INT\n    assert \"$LINENO:untrap failed:$gl_trap_str:$1\"\n}\n\nfunction build_f(){\n    declare file\n    declare cflags\n    declare build_cmd\n    declare tmp_ret\n    declare skip_flag\n    echo \"OUTPUT_DIR:       $OUTPUT_DIR\"\n    echo \"CFLAGS:           $CFLAGS\"\n    echo \"EXTRA_CFLAGS:     $EXTRA_CFLAGS\"\n    echo \"ACO_EXTRA_CFLAGS: $ACO_EXTRA_CFLAGS\"\n    echo \"OUTPUT_SUFFIX:    $OUTPUT_SUFFIX\"\n    echo \"$app_list\" | grep -Po '.+$' | while read read_in\n    do\n        file=`echo $read_in | grep -Po \"^[^\\s]+\"`\n        cflags=`echo $read_in | sed -r 's/^\\s*([^ ]+)(.*)$/\\2/'`\n        if [ -z \"$file\" ] \n        then\n            continue  \n        fi\n        #echo \"<$file>:<$cflags>:$OUTPUT_DIR:$CFLAGS:$EXTRA_CFLAGS:$OUTPUT_SUFFIX\"\n        build_cmd=\"$makecc $CFLAGS $ACO_EXTRA_CFLAGS $EXTRA_CFLAGS acosw.S aco.c $file.c $cflags -o $OUTPUT_DIR/$file$OUTPUT_SUFFIX\"\n        skip_flag=\"\"\n        if [ \"$gl_opt_no_m32\" ]\n        then\n            echo \"$OUTPUT_SUFFIX\" | grep -P \"\\bm32\\b\" &>/dev/null\n            tmp_ret=$?\n            if [ \"$tmp_ret\" -eq \"0\" ]\n            then\n                skip_flag=\"true\"\n            elif [ \"$tmp_ret\" -eq \"1\" ]\n            then\n                :\n            else\n                error \"grep failed: $tmp_ret\"\n                exit $tmp_ret\n            fi\n        fi\n        if [ \"$gl_opt_no_valgrind\" ]\n        then\n            echo \"$OUTPUT_SUFFIX\" | grep -P \"\\bvalgrind\\b\" &>/dev/null\n            tmp_ret=$?\n            if [ \"$tmp_ret\" -eq \"0\" ]\n            then\n                skip_flag=\"true\"\n            elif [ \"$tmp_ret\" -eq \"1\" ]\n            then\n                :\n            else\n                error \"grep failed: $tmp_ret\"\n                exit $tmp_ret\n            fi\n        fi\n        if [ \"$skip_flag\" ]\n        then\n            echo \"skip    $build_cmd\"\n        else\n            echo \"        $build_cmd\"\n            $build_cmd\n            assert \"build fail\"\n        fi\n    done\n    assert \"exit\"\n}\n\nfunction usage() {\n    echo \"Usage: $0 [-o <no-m32|no-valgrind>] [-h]\" 1>&2\n    echo '''\nExample:\n    # default build\n    bash make.sh\n    # build without the i386 binary output\n    bash make.sh -o no-m32\n    # build without the valgrind supported binary output\n    bash make.sh -o no-valgrind\n    # build without the valgrind supported and i386 binary output\n    bash make.sh -o no-valgrind -o no-m32\n''' 1>&2\n}\n\ngl_opt_value=\"\"\nwhile getopts \":o:h\" o; do\n    case \"${o}\" in\n        o)\n            gl_opt_value=${OPTARG}\n            if [ \"$gl_opt_value\" = \"no-m32\" ]\n            then\n                gl_opt_no_m32=\"true\"\n            elif [ \"$gl_opt_value\" = \"no-valgrind\" ]\n            then\n                gl_opt_no_valgrind=\"true\"\n            else\n                usage\n                error unknow option value of '-o'\n                exit 1\n            fi\n            ;;\n        h)\n            usage\n            exit 0\n            ;;\n        *)\n            usage\n            error unknow option\n            exit 1\n            ;;\n    esac\ndone\nshift $((OPTIND-1))\n\n#echo \"o = $gl_opt_value\"\n#echo \"gl_opt_no_valgrind:$gl_opt_no_valgrind\"\n#echo \"gl_opt_no_m32:$gl_opt_no_m32\"\n\nif [ -e \"$OUTPUT_DIR\" ]\nthen\n    if [ -d \"$OUTPUT_DIR\" ]\n    then\n        :\n    else\n        error \"\\\"$OUTPUT_DIR\\\" is not a directory\"\n        exit 1\n    fi\nelse\n    error \"directory \\\"$OUTPUT_DIR\\\" doesn't exist\"\n    exit 1\nfi\n\ntra \"echo;echo build has been interrupted\"\n\n# the matrix of the build config for later testing\n# -m32 -DACO_CONFIG_SHARE_FPU_MXCSR_ENV -DACO_USE_VALGRIND\n# 0 0 0\nACO_EXTRA_CFLAGS=\"\" OUTPUT_SUFFIX=\"..no_valgrind.standaloneFPUenv\" build_f\n# 0 0 1\nACO_EXTRA_CFLAGS=\"-DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..valgrind.standaloneFPUenv\" build_f\n# 0 1 0\nACO_EXTRA_CFLAGS=\"-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\" OUTPUT_SUFFIX=\"..no_valgrind.shareFPUenv\" build_f\n# 0 1 1\nACO_EXTRA_CFLAGS=\"-DACO_CONFIG_SHARE_FPU_MXCSR_ENV -DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..valgrind.shareFPUenv\" build_f\n# 1 0 0\nACO_EXTRA_CFLAGS=\"-m32\" OUTPUT_SUFFIX=\"..m32.no_valgrind.standaloneFPUenv\" build_f\n# 1 0 1\nACO_EXTRA_CFLAGS=\"-m32 -DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..m32.valgrind.standaloneFPUenv\" build_f\n# 1 1 0\nACO_EXTRA_CFLAGS=\"-m32 -DACO_CONFIG_SHARE_FPU_MXCSR_ENV\" OUTPUT_SUFFIX=\"..m32.no_valgrind.shareFPUenv\" build_f\n# 1 1 1\nACO_EXTRA_CFLAGS=\"-m32 -DACO_CONFIG_SHARE_FPU_MXCSR_ENV -DACO_USE_VALGRIND\" OUTPUT_SUFFIX=\"..m32.valgrind.shareFPUenv\" build_f\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 5.58984375,
          "content": "#!/bin/bash\n\n# Copyright 2018 Sen Han <00hnes@gmail.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http:#www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n#ulimit -c unlimited\n\ngl_trap_str=\"\"\n\nfunction error(){\n    >&2 echo \"$*\"\n}\n\nfunction assert(){\n    if [ \"0\" -ne \"$?\" ]\n    then\n        error \"$0:\"\"$*\"\n        exit 1\n    fi\n}\n\nfunction tra(){\n    gl_trap_str=\"$gl_trap_str\"\"$1\"\n    trap \"$gl_trap_str exit 1;\" INT\n    assert \"$LINENO:trap failed:$gl_trap_str:$1\"\n}\n\nfunction untra(){\n    trap - INT\n    assert \"$LINENO:untrap failed:$gl_trap_str:$1\"\n}\n\nfunction test_f_is_exclude_app(){\n    declare infile\n    declare main_name\n    infile=$1\n    main_name=`echo \"$infile\" | sed -r \"s|(.*)\\.\\.(.*)|\\1|\"`\n    if [ -z \"$infile\" -o -z \"$main_name\" ]\n    then\n        error \"$0:\"\"$*\"\n        exit 1\n    fi\n    if [ \"$main_name\" = \"test_aco_benchmark\" ]\n    then\n        return 0\n    else\n        return 1\n    fi  \n}\n\nfunction test_f_handle_exit_code(){\n    declare infile\n    declare errc\n    declare main_name\n    declare intended_to_abort\n    infile=$1\n    errc=$2\n    if [ -z \"$infile\" ]\n    then\n        error test_f_handle_exit_code illegal input       \n        exit 1\n    fi\n    if [ -z \"$errc\" -o \"$errc\" -lt \"0\" ]\n    then\n        error test_f_handle_exit_code illegal input\n        exit 1\n    fi\n    main_name=`echo \"$infile\" | sed -r \"s|(.*)\\.\\.(.*)|\\1|\"`\n    intended_to_abort=\"\"\n    if [ \"$main_name\" = \"test_aco_tutorial_4\" -o \"$main_name\" = \"test_aco_tutorial_5\" ]\n    then\n        intended_to_abort=\"true\"\n    fi\n    if [ \"$intended_to_abort\" -a \"$errc\" -ne \"134\" ]\n    then\n        echo \"\"\n        echo test $infile intended to abort failed:$errc\n        exit $errc\n    fi\n    if [ -z \"$intended_to_abort\" -a \"$errc\" -ne \"0\" ]\n    then\n        echo \"\"\n        echo test $infile failed:$errc\n        exit $errc\n    fi\n    if [ \"$intended_to_abort\" ] \n    then\n        echo test $infile intended to abort success:$errc\n    else\n        echo test $infile success\n    fi\n}\n\nfunction test_f(){\n    declare valgrind_support\n    declare errc\n    declare test_ct\n    declare infile\n    test_ct=`file * | grep -P \"\\bexecutable\\b\" | grep -Po '^[^:]+' | wc -l`\n    file * | grep -P \"\\bexecutable\\b\" | grep -Po '^[^:]+' | while read infile\n    do\n        test_f_is_exclude_app \"$infile\"\n        if [ \"0\" -eq \"$?\" ]\n        then\n            echo \"----\" $infile is in the exclude app list, bypass its test\n            echo\n            continue\n        fi\n        valgrind_support=`echo \"$infile\" | grep -Po '.*\\.\\.(.*)' | sed -r \"s|(.*)\\.\\.(.*)|\\2|\" | grep -Po '\\bvalgrind\\b'`\n        if [ -z \"$valgrind_support\" ]\n        then\n            echo \"----\" $infile start\":\"\n            time ./$infile\n            errc=\"$?\"\n            test_f_handle_exit_code $infile $errc\n        else\n            echo \"----\" $infile memcheck start\":\"\n            time valgrind --leak-check=full --error-exitcode=2 --tool=memcheck ./$infile\n            errc=\"$?\"\n            test_f_handle_exit_code $infile $errc\n        fi\n        echo\n    done\n    errc=\"$?\"\n    if [ \"$errc\" -ne \"0\" ]\n    then\n        exit \"$errc\"\n    fi\n    if [ \"$test_ct\" -ne \"0\" ]\n    then\n        echo all the \"$test_ct\" tests had passed, OK and cheers!\n    else\n        echo no test need to do in current directory: \"`pwd`\"\n    fi\n}\n\ntra \"echo;echo test had been interrupted;exit 0;\"\n\nversion_check_flag=`echo $1 | grep -Po \"\\bversion_check\\b=\"`\nversion_to_check=`echo $1 | grep -Po \"[0-9]+\\.[0-9]+\\.[0-9]+\" | head -1`\nversion_major=`echo $version_to_check | grep -Po \"^[0-9]+(?=\\.)\"`\nversion_minor=`echo $version_to_check | grep -Po \"(?<=\\.)[0-9]+(?=\\.)\"`\nversion_patch=`echo $version_to_check | grep -Po \"(?<=\\.)[0-9]+$\"`\necho \"$version_check_flag |$version_to_check|\"\necho \"|$version_major|$version_minor|$version_patch|\"\n\nmakecc=\"cc\"\nif [ \"$CC\" ]\nthen\n    makecc=\"$CC\"\nfi\n\nif [ \"$version_check_flag\" ]\nthen\n    if [ \"$version_major\" -lt 0 ] || [ \"$version_minor\" -lt 0 ] || [ \"$version_patch\" -lt 0 ]\n    then\n        error \"synatx error: version_to_check: $version_to_check\"\n        exit 1\n    fi\n    version_check_tmpdir=`mktemp -d`\n    version_check_tmpfile=\"$version_check_tmpdir\"/tmp.c\n    echo '''        #include \"aco.h\"\n        #include <stdio.h>\n        #include \"aco_assert_override.h\"\n\n        int main() {''' > $version_check_tmpfile\n    echo \"        assert(ACO_VERSION_MAJOR == $version_major);\" \\\n        >> $version_check_tmpfile\n    echo \"        assert(ACO_VERSION_MINOR == $version_minor);\" \\\n        >> $version_check_tmpfile\n    echo \"        assert(ACO_VERSION_PATCH == $version_patch);\" \\\n        >> $version_check_tmpfile\n    echo \"        return 0;\" >> $version_check_tmpfile\n    echo \"        }\" >> $version_check_tmpfile\n    echo \"$version_check_tmpfile:\"\n    cat $version_check_tmpfile\n    $makecc -I. -g -O2 acosw.S aco.c -o \"$version_check_tmpfile\".bin $version_check_tmpfile\n    \"$version_check_tmpfile\".bin\n    assert \"error: version_check failed: $version_to_check\"\n    rm -fr \"$version_check_tmpdir\"\n    exit 0\nfi\n\n# test loop\nwhile true\ndo\n    echo \"---- time:\"`date`\n    test_f\n    errc=\"$?\"\n    if [ \"$errc\" -ne 0 ]\n    then\n        exit $errc\n    fi   \n    if [ \"$1\" != \"loop\" ]\n    then\n        exit 0\n    fi\n    echo \"\"\n    echo \"----\" start all tests again\n    sleep 1\ndone\n"
        },
        {
          "name": "test_aco_benchmark.c",
          "type": "blob",
          "size": 8.138671875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#define _GNU_SOURCE\n\n#include \"aco.h\"    \n#include <alloca.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\naco_cofuncp_t gl_co_fp;\n\n#define PRINT_BUF_SZ 64\nchar gl_benchmark_print_str_buf[64];\n\nvoid co_fp_alloca(){\n    size_t sz = (size_t)((uintptr_t)aco_get_arg());\n    uint8_t* ptr = NULL;\n    assert(sz > 0);\n    ptr = alloca(sz);\n    assertptr(ptr);\n    memset(ptr, 0, sz);\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_128(){\n    int ip[28];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_64(){\n    int ip[12];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_40(){\n    int ip[8];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_24(){\n    int ip[4];\n    memset(ip, 1, sizeof(ip));\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp_stksz_8(){\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid co_fp0(){\n    while(1){\n        aco_yield();\n    }\n    aco_exit();\n}\n\nvoid benchmark_copystack(size_t co_amount,size_t stksz, size_t loopct){\n    struct timespec tstart={0,0}, tend={0,0};\n    int print_sz = 0;\n    double delta_t;\n    // create co\n    assert(co_amount > 0);\n    assertptr((void*)gl_co_fp);\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    // NOTE: size_t_safe_mul\n    aco_t** coarray = (aco_t**) malloc(sizeof(void*) * co_amount);\n    assertptr(coarray);\n    memset(coarray, 0, sizeof(void*) * co_amount);\n    size_t ct = 0;\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tstart));\n    while(ct < co_amount){\n        coarray[ct] = aco_create(\n            main_co, sstk, 0, gl_co_fp, \n            (void*)((uintptr_t)stksz)\n        );\n        ct++;\n    }\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tend));\n    delta_t = ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) -\n        ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec);\n    //aco_create/init_save_stk_sz=64B    10000000   140.43 ns/op     7126683.67 op/s\n    print_sz = snprintf(\n        gl_benchmark_print_str_buf, PRINT_BUF_SZ, \n        \"aco_create/init_save_stk_sz=64B\"\n    );\n    assert(print_sz > 0 && print_sz < PRINT_BUF_SZ);\n    printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\", \n        gl_benchmark_print_str_buf,\n        co_amount, delta_t,\n        (1.0e+9) / (co_amount / delta_t),\n        co_amount / delta_t);\n    fflush(stdout);\n    // warm-up\n    ct = 0;\n    while(ct < co_amount){\n        aco_resume(coarray[ct]);\n        ct++;\n    }\n    // copystack ctxsw\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tstart));\n    size_t glct = 0;\n    while(glct < loopct){\n        ct = 0;\n        while(ct < co_amount){\n            aco_resume(coarray[ct]);\n            ct++;\n            glct++;\n        }\n    }\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tend));    \n    delta_t = ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) -\n        ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec);\n    //aco_resume/copy_stack_size=8B      20000000    36.23 ns/op    27614644.57 op/s    \n    print_sz = snprintf(\n        gl_benchmark_print_str_buf, PRINT_BUF_SZ, \n        \"aco_resume/co_amount=%zu/copy_stack_size=%zuB\",\n        co_amount, coarray[0]->save_stack.max_cpsz\n    );\n    assert(print_sz > 0 && print_sz < PRINT_BUF_SZ);\n    printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\",\n        gl_benchmark_print_str_buf, glct, \n        delta_t, (1.0e+9) / (glct / delta_t), \n        glct / delta_t);\n    if(co_amount == 1 && coarray[0]->save_stack.max_cpsz == 0){\n        printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\",\n            \"  -> acosw\", glct*2, \n            delta_t, (1.0e+9) / (glct*2 / delta_t), \n            glct*2 / delta_t);\n    }\n    fflush(stdout);\n    // co cleaning\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tstart));\n    ct = 0;\n    while(ct < co_amount){\n        aco_destroy(coarray[ct]);\n        coarray[ct] = NULL;\n        ct++;\n    }\n    assert(0 == clock_gettime(CLOCK_MONOTONIC, &tend));\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n    free(coarray);\n    delta_t = ((double)tend.tv_sec + 1.0e-9*tend.tv_nsec) -\n        ((double)tstart.tv_sec + 1.0e-9*tstart.tv_nsec);\n    //aco_destroy                        20000000    21.22 ns/op    47616496.16 op/s\n    print_sz = snprintf(\n        gl_benchmark_print_str_buf, PRINT_BUF_SZ, \n        \"aco_destroy\"\n    );\n    assert(print_sz > 0 && print_sz < PRINT_BUF_SZ);\n    printf(\"%-50s %11zu %9.3f s %11.2f ns/op %13.2f op/s\\n\\n\", \n        gl_benchmark_print_str_buf,\n        co_amount, delta_t, \n        (1.0e+9) / (co_amount / delta_t), \n        co_amount / delta_t);\n    fflush(stdout);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(1){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    printf(\"warm-up:\\n\");\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(200*10000, 10, 20000000);\n\n#ifdef __i386__\n    printf(\"+build:i386\\n\");\n#elif __x86_64__\n    printf(\"+build:x86_64\\n\");\n#endif\n\n#ifdef ACO_CONFIG_SHARE_FPU_MXCSR_ENV\n    printf(\"+build:-DACO_CONFIG_SHARE_FPU_MXCSR_ENV\\n\");\n    printf(\"+build:share fpu & mxcsr control words between coroutines\\n\");\n#else\n    printf(\"+build:undefined ACO_CONFIG_SHARE_FPU_MXCSR_ENV\\n\");\n    printf(\"+build:each coroutine maintain each own fpu & mxcsr control words\\n\");\n#endif\n#ifdef ACO_USE_VALGRIND\n    printf(\"+build:-DACO_USE_VALGRIND\\n\");\n    printf(\"+build:valgrind memcheck friendly support enabled\\n\");\n#else\n    printf(\"+build:undefined ACO_USE_VALGRIND\\n\");\n    printf(\"+build:without valgrind memcheck friendly support\\n\");\n#endif\n\n    printf(\"\\nsizeof(aco_t)=%zu:\\n\\n\", sizeof(aco_t));\n\n    printf(\"\\nstart-test:\\n\\n\");\n    printf(\"%-50s %15s    %15s    %15s   %15s\\n\\n\", \n        \"comment\", \"task_amount\", \"all_time_cost\", \"ns_per_op\", \"speed\"\n    );\n\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(1, 10, 20000000);\n\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(1, 10, 20000000);\n\n    gl_co_fp = co_fp_stksz_8;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_24;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_40;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_64;\n    benchmark_copystack(200*10000, 10, 20000000);\n    gl_co_fp = co_fp_stksz_128;\n    benchmark_copystack(200*10000, 10, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 150 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 158 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 166 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 256 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 512 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(200*10000, 512 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(100*10000, 1024 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(100*10000, 1024 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 1024 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 2048 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 4096 - 64, 20000000);\n\n    gl_co_fp = co_fp_alloca;\n    benchmark_copystack(10*10000, 8012 - 64, 20000000);\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_synopsis.c",
          "type": "blob",
          "size": 1.8837890625,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"aco.h\"    \n#include <stdio.h>\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct) {\n    printf(\"co: %p: yield to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_yield();\n    *((int*)(aco_get_arg())) = ct + 1;\n}\n\nvoid co_fp0() {\n    printf(\"co: %p: entry: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\"co: %p:  exit to main_co: %d\\n\", aco_get_co(), *((int*)(aco_get_arg())));\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        ct++;\n    }\n    printf(\"main_co: yield to co: %p: %d\\n\", co, ct);\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co: destroy and exit\\n\");\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_0.c",
          "type": "blob",
          "size": 3.6748046875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Hello aco demo.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid co_fp0() {\n    // Get co->arg. The caller of `aco_get_arg()` must be a non-main co.\n    int *iretp = (int *)aco_get_arg();\n    // Get current co. The caller of `aco_get_co()` must be a non-main co.\n    aco_t* this_co = aco_get_co();\n    int ct = 0;\n    while(ct < 6){\n        printf(\n            \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n            this_co, this_co->save_stack.ptr,\n            this_co->share_stack->ptr, ct\n        );\n        // Yield the execution of current co and resume the execution of\n        // `co->main_co`. The caller of `aco_yield()` must be a non-main co.\n        aco_yield();\n        (*iretp)++;\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    // In addition do the same as `aco_yield()`, `aco_exit()` also set \n    // `co->is_end` to `1` thus to mark the `co` at the status of \"END\".\n    aco_exit();\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n    // Initialize the aco environment in the current thread.\n    aco_thread_init(NULL);\n\n    // Create a main coroutine whose \"share stack\" is the default stack \n    // of the current thread. And it doesn't need any private save stack \n    // since it is definitely a standalone coroutine (which coroutine \n    // monopolizes it's share stack).\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n\n    // Create a share stack with the default size of 2MB and also with a \n    // read-only guard page for the detection of stack overflow.\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n\n    int co_ct_arg_point_to_me = 0;\n    // Create a non-main coroutine whose share stack is `sstk` and has a\n    // default 64 bytes size private save stack. The entry function of the \n    // coroutine is `co_fp0`. Set `co->arg` to the address of the int \n    // variable `co_ct_arg_point_to_me`.\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        // Start or continue the execution of `co`. The caller of this function\n        // must be main_co.\n        aco_resume(co);\n        // Check whether the co has completed the job it promised.\n        assert(co_ct_arg_point_to_me == ct);\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    // The value of `co->is_end` must be `1` now since it just suspended \n    // itself by calling `aco_exit()`.\n    assert(co->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    // Destroy co and its private save stack.\n    aco_destroy(co);\n    co = NULL;\n    // Destroy the share stack sstk.\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    // Destroy the main_co.\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_1.c",
          "type": "blob",
          "size": 3.0234375,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Some statistics of the coroutine.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid co_fp0(){\n    int *iretp = (int *)aco_get_arg();\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        printf(\n            \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n            this_co, this_co->save_stack.ptr,\n            this_co->share_stack->ptr, ct\n        );\n        aco_yield();\n        (*iretp)++;\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    aco_exit();\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n    \n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_2.c",
          "type": "blob",
          "size": 4.794921875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    aco_exit();\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(1){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n    aco_share_stack_t* sstk2 = aco_share_stack_new(0);\n    assertptr(sstk2);\n\n    int co_ct_arg_point_to_me = 0;\n    int co2_ct_arg_point_to_me = 0;\n    int co3_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n    aco_t* co2 = aco_create(main_co, sstk2, 0, co_fp0, &co2_ct_arg_point_to_me);\n    aco_t* co3 = aco_create(main_co, sstk2, 0, co_fp0, &co3_ct_arg_point_to_me);\n    assertptr(co2);\n    assertptr(co3);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        assert(co2->is_end == 0);\n        aco_resume(co2);\n        assert(co2_ct_arg_point_to_me == ct);\n\n        assert(co3->is_end == 0);\n        aco_resume(co3);\n        assert(co3_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    aco_resume(co2);\n    assert(co2_ct_arg_point_to_me == ct);\n    assert(co2->is_end);\n\n    aco_resume(co3);\n    assert(co3_ct_arg_point_to_me == ct);\n    assert(co3->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    printf(\n        \"\\ncopy-stack co2:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co2, co2->save_stack.max_cpsz, \n        co2->save_stack.ct_save, \n        co2->save_stack.ct_restore\n    );\n    printf(\n        \"\\ncopy-stack co3:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co3, co3->save_stack.max_cpsz, \n        co3->save_stack.ct_save, \n        co3->save_stack.ct_restore\n    );\n\n    printf(\"\\n(The co2 & co3 share the share stack sstk2, thus it is \"\n        \"necessary to save/restore the stack every time during resume &\"\n        \" yield execution, thus it is a ordinary case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n    aco_destroy(co2);\n    co2 = NULL;\n    aco_destroy(co3);\n    co3 = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_share_stack_destroy(sstk2);\n    sstk2 = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_3.c",
          "type": "blob",
          "size": 5.982421875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Use aco in multithread.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <inttypes.h>\n#include \"aco_assert_override.h\"\n\nuint64_t gl_race_aco_yield_ct = 0;\npthread_mutex_t gl_race_aco_yield_ct_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    pthread_mutex_lock(&gl_race_aco_yield_ct_mutex);\n    gl_race_aco_yield_ct++;\n    pthread_mutex_unlock(&gl_race_aco_yield_ct_mutex);\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p co_exit()\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    pthread_mutex_lock(&gl_race_aco_yield_ct_mutex);\n    gl_race_aco_yield_ct++;\n    pthread_mutex_unlock(&gl_race_aco_yield_ct_mutex);\n    aco_exit();\n    assert(0);\n}\n\nvoid* pmain(void* pthread_in_arg) {\n    pthread_t t = pthread_self();\n    size_t idx = 0;\n    assert(sizeof(t) > 0);\n    printf(\"\\ntid:0x\");\n    while(idx < sizeof(t)){\n        printf(\"%02x\", *(((uint8_t*)(&t)) + idx));\n        idx++;\n    }\n    printf(\"\\n\");\n    \n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n    aco_share_stack_t* sstk2 = aco_share_stack_new(0);\n    assertptr(sstk2);\n\n    int co_ct_arg_point_to_me = 0;\n    int co2_ct_arg_point_to_me = 0;\n    int co3_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n    aco_t* co2 = aco_create(main_co, sstk2, 0, co_fp0, &co2_ct_arg_point_to_me);\n    aco_t* co3 = aco_create(main_co, sstk2, 0, co_fp0, &co3_ct_arg_point_to_me);\n    assertptr(co2);\n    assertptr(co3);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        assert(co2->is_end == 0);\n        aco_resume(co2);\n        assert(co2_ct_arg_point_to_me == ct);\n\n        assert(co3->is_end == 0);\n        aco_resume(co3);\n        assert(co3_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    aco_resume(co2);\n    assert(co2_ct_arg_point_to_me == ct);\n    assert(co2->is_end);\n\n    aco_resume(co3);\n    assert(co3_ct_arg_point_to_me == ct);\n    assert(co3->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    printf(\n        \"\\ncopy-stack co2:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co2, co2->save_stack.max_cpsz, \n        co2->save_stack.ct_save, \n        co2->save_stack.ct_restore\n    );\n    printf(\n        \"\\ncopy-stack co3:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co3, co3->save_stack.max_cpsz, \n        co3->save_stack.ct_save, \n        co3->save_stack.ct_restore\n    );\n\n    printf(\"\\n(The co2 & co3 share the share stack sstk2, thus it is \"\n        \"necessary to save/restore the stack every time during resume &\"\n        \" yield execution, thus it is a ordinary case of copy-stack.)\\n\");\n\n    uint64_t tmp_gl_ct;\n    pthread_mutex_lock(&gl_race_aco_yield_ct_mutex);\n    tmp_gl_ct = gl_race_aco_yield_ct;\n    pthread_mutex_unlock(&gl_race_aco_yield_ct_mutex);\n    printf(\"\\ngl_race_aco_yield_ct:%\" PRIu64\"\\n\", tmp_gl_ct);\n\n    aco_destroy(co);\n    co = NULL;\n    aco_destroy(co2);\n    co2 = NULL;\n    aco_destroy(co3);\n    co3 = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_share_stack_destroy(sstk2);\n    sstk2 = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n\nint main(){\n#ifdef ACO_USE_VALGRIND\n    if(1){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    pthread_t t1,t2;\n\n    assert(0 == pthread_create(\n        &t1, NULL, pmain, NULL\n    ));\n    assert(0 == pthread_create(\n        &t2, NULL, pmain, NULL\n    ));\n\n    assert(0 == pthread_join(t1, NULL));\n    assert(0 == pthread_join(t2, NULL));\n    \n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_4.c",
          "type": "blob",
          "size": 3.326171875,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p !offending return!\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    printf(\"Intended to Abort to test the aco protector :)\\n\");\n    // the offending `return` here it is\n    // you should always call `aco_exit()` to finish the execution of a non-main co\n    // instead of call `return` in the real application\n    // this is a demo shows how protector works in libaco (intended to abort)\n    return;\n    aco_exit();\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(NULL);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_5.c",
          "type": "blob",
          "size": 3.4931640625,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Test the customization of aco protector.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"aco_assert_override.h\"\n\nvoid foo(int ct){\n    printf(\n        \"co:%p save_stack:%p share_stack:%p yield_ct:%d\\n\",\n        aco_get_co(), aco_get_co()->save_stack.ptr,\n        aco_get_co()->share_stack->ptr, ct\n    );\n    aco_yield();\n    (*((int*)(aco_get_arg())))++;\n}\n\nvoid co_fp0()\n{\n    aco_t* this_co = aco_get_co();\n    assert(!aco_is_main_co(this_co));\n    assert(this_co->fp == (void*)co_fp0);\n    assert(this_co->is_end == 0);\n    int ct = 0;\n    while(ct < 6){\n        foo(ct);\n        ct++;\n    }\n    printf(\n        \"co:%p save_stack:%p share_stack:%p !offending return!\\n\",\n        this_co, this_co->save_stack.ptr,\n        this_co->share_stack->ptr\n    );\n    printf(\"Intended to Abort to test the aco protector :)\\n\");\n    return;\n    aco_exit();\n    assert(0);\n}\n\nstatic void co_protector_last_word(){\n    aco_t* co = aco_get_co();\n    // do some log about the offending `co`\n    fprintf(stderr,\"error: customized co_protector_last_word triggered \\n\");\n    fprintf(stderr, \"error: co:%p should call `aco_exit(co)` instead of direct \"\n        \"`return` in co_fp:%p to finish its execution\\n\", co, (void*)co->fp);\n    assert(0);\n}\n\nint main() {\n#ifdef ACO_USE_VALGRIND\n    if(0){\n        printf(\"%s doesn't have valgrind test yet, \"\n            \"so bypass this test right now.\\n\",__FILE__\n        );\n        exit(0);\n    }\n#endif\n\n    aco_thread_init(co_protector_last_word);\n\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    assertptr(main_co);\n\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    assertptr(sstk);\n\n    int co_ct_arg_point_to_me = 0;\n    aco_t* co = aco_create(main_co, sstk, 0, co_fp0, &co_ct_arg_point_to_me);\n    assertptr(co);\n\n    int ct = 0;\n    while(ct < 6){\n        assert(co->is_end == 0);\n        aco_resume(co);\n        assert(co_ct_arg_point_to_me == ct);\n\n        printf(\"main_co:%p\\n\", main_co);\n        ct++;\n    }\n    aco_resume(co);\n    assert(co_ct_arg_point_to_me == ct);\n    assert(co->is_end);\n\n    printf(\"main_co:%p\\n\", main_co);\n\n    printf(\n        \"\\ncopy-stack co:%p:\\n    max stack copy size:%zu\\n\"\n        \"    save (from share stack to save stack) counter of the private save stack:%zu\\n\"\n        \"    restore (from save stack to share stack) counter of the private save stack:%zu\\n\",\n        co, co->save_stack.max_cpsz, \n        co->save_stack.ct_save, \n        co->save_stack.ct_restore\n    );\n    printf(\"\\n(Since the share stack used by the co has only one user `co`, \"\n        \"so there is no need to save/restore the stack every time during resume &\"\n        \" yield execution, thus you can call it a co has 'standalone stack' \"\n        \"which just is a very special case of copy-stack.)\\n\");\n\n    aco_destroy(co);\n    co = NULL;\n\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n\n    aco_destroy(main_co);\n    main_co = NULL;\n\n    return 0;\n}\n"
        },
        {
          "name": "test_aco_tutorial_6.c",
          "type": "blob",
          "size": 3.236328125,
          "content": "// Copyright 2018 Sen Han <00hnes@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// A naive and pretty simple scheduler demo.\n\n#include \"aco.h\"    \n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include \"aco_assert_override.h\"\n\nvoid co_fp0(){\n    int ct = 0;\n    int loop_ct = (int)((uintptr_t)(aco_get_co()->arg));\n    if(loop_ct < 0){\n        loop_ct = 0;\n    }\n    while(ct < loop_ct){\n        aco_yield();\n        ct++;\n    }\n    aco_exit();\n}\n\nint main() {\n    aco_thread_init(NULL);\n\n    time_t seed_t = time(NULL);\n    assert((time_t)-1 != seed_t);\n    srand(seed_t);\n\n    size_t co_amount = 100;\n\n    // create co\n    assert(co_amount > 0);\n    aco_t* main_co = aco_create(NULL, NULL, 0, NULL, NULL);\n    aco_share_stack_t* sstk = aco_share_stack_new(0);\n    // NOTE: size_t_safe_mul\n    aco_t** coarray = (aco_t**) malloc(sizeof(void*) * co_amount);\n    assertptr(coarray);\n    memset(coarray, 0, sizeof(void*) * co_amount);\n    size_t ct = 0;\n    while(ct < co_amount){\n#ifdef ACO_USE_VALGRIND\n        aco_share_stack_t* private_sstk = aco_share_stack_new2(\n            0, ct % 2\n        );\n        coarray[ct] = aco_create(\n            main_co, private_sstk, 0, co_fp0,\n            (void*)((uintptr_t)rand() % 1000)\n        );\n        private_sstk = NULL;\n#else\n        coarray[ct] = aco_create(\n            main_co, sstk, 0, co_fp0,\n            (void*)((uintptr_t)rand() % 1000)\n        );\n#endif\n        ct++;\n    }\n\n    // naive scheduler with very poor performance (only for demo and testing)\n    printf(\"scheduler start: co_amount:%zu\\n\", co_amount);\n    size_t null_ct = 0;\n    while(1){\n        ct = 0;\n        while(ct < co_amount){\n            if(coarray[ct] != NULL){\n                aco_resume(coarray[ct]);\n                null_ct = 0;\n                if(coarray[ct]->is_end != 0){\n                    printf(\"aco_destroy: co:%zu\\n\", ct);\n                    #ifdef ACO_USE_VALGRIND\n                        aco_share_stack_t* private_sstk = coarray[ct]->share_stack;\n                    #endif\n                    aco_destroy(coarray[ct]);\n                    coarray[ct] = NULL;\n                    #ifdef ACO_USE_VALGRIND\n                        aco_share_stack_destroy(private_sstk);\n                        private_sstk = NULL;\n                    #endif\n                }\n            } else {\n                null_ct++;\n                if(null_ct >= co_amount){\n                    goto END;\n                }\n            }\n            ct++;\n        }\n    }\n    // co cleaning\n    END:\n    ct = 0;\n    while(ct < co_amount){\n        assert(coarray[ct] == NULL);\n        ct++;\n    }\n    aco_share_stack_destroy(sstk);\n    sstk = NULL;\n    aco_destroy(main_co);\n    main_co = NULL;\n    free(coarray);\n\n    printf(\"sheduler exit\");\n    \n    return 0;\n}\n"
        }
      ]
    }
  ]
}