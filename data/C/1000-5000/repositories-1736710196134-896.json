{
  "metadata": {
    "timestamp": 1736710196134,
    "page": 896,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xorvoid/sectorc",
      "stars": 1637,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.009765625,
          "content": "build/\n*~\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 6.4013671875,
          "content": "CC0 1.0 Universal\n\nStatement of Purpose\n\nThe laws of most jurisdictions throughout the world automatically confer\nexclusive Copyright and Related Rights (defined below) upon the creator and\nsubsequent owner(s) (each and all, an \"owner\") of an original work of\nauthorship and/or a database (each, a \"Work\").\n\nCertain owners wish to permanently relinquish those rights to a Work for the\npurpose of contributing to a commons of creative, cultural and scientific\nworks (\"Commons\") that the public can reliably and without fear of later\nclaims of infringement build upon, modify, incorporate in other works, reuse\nand redistribute as freely as possible in any form whatsoever and for any\npurposes, including without limitation commercial purposes. These owners may\ncontribute to the Commons to promote the ideal of a free culture and the\nfurther production of creative, cultural and scientific works, or to gain\nreputation or greater distribution for their Work in part through the use and\nefforts of others.\n\nFor these and/or other purposes and motivations, and without any expectation\nof additional consideration or compensation, the person associating CC0 with a\nWork (the \"Affirmer\"), to the extent that he or she is an owner of Copyright\nand Related Rights in the Work, voluntarily elects to apply CC0 to the Work\nand publicly distribute the Work under its terms, with knowledge of his or her\nCopyright and Related Rights in the Work and the meaning and intended legal\neffect of CC0 on those rights.\n\n1. Copyright and Related Rights. A Work made available under CC0 may be\nprotected by copyright and related or neighboring rights (\"Copyright and\nRelated Rights\"). Copyright and Related Rights include, but are not limited\nto, the following:\n\n  i. the right to reproduce, adapt, distribute, perform, display, communicate,\n  and translate a Work;\n\n  ii. moral rights retained by the original author(s) and/or performer(s);\n\n  iii. publicity and privacy rights pertaining to a person's image or likeness\n  depicted in a Work;\n\n  iv. rights protecting against unfair competition in regards to a Work,\n  subject to the limitations in paragraph 4(a), below;\n\n  v. rights protecting the extraction, dissemination, use and reuse of data in\n  a Work;\n\n  vi. database rights (such as those arising under Directive 96/9/EC of the\n  European Parliament and of the Council of 11 March 1996 on the legal\n  protection of databases, and under any national implementation thereof,\n  including any amended or successor version of such directive); and\n\n  vii. other similar, equivalent or corresponding rights throughout the world\n  based on applicable law or treaty, and any national implementations thereof.\n\n2. Waiver. To the greatest extent permitted by, but not in contravention of,\napplicable law, Affirmer hereby overtly, fully, permanently, irrevocably and\nunconditionally waives, abandons, and surrenders all of Affirmer's Copyright\nand Related Rights and associated claims and causes of action, whether now\nknown or unknown (including existing as well as future claims and causes of\naction), in the Work (i) in all territories worldwide, (ii) for the maximum\nduration provided by applicable law or treaty (including future time\nextensions), (iii) in any current or future medium and for any number of\ncopies, and (iv) for any purpose whatsoever, including without limitation\ncommercial, advertising or promotional purposes (the \"Waiver\"). Affirmer makes\nthe Waiver for the benefit of each member of the public at large and to the\ndetriment of Affirmer's heirs and successors, fully intending that such Waiver\nshall not be subject to revocation, rescission, cancellation, termination, or\nany other legal or equitable action to disrupt the quiet enjoyment of the Work\nby the public as contemplated by Affirmer's express Statement of Purpose.\n\n3. Public License Fallback. Should any part of the Waiver for any reason be\njudged legally invalid or ineffective under applicable law, then the Waiver\nshall be preserved to the maximum extent permitted taking into account\nAffirmer's express Statement of Purpose. In addition, to the extent the Waiver\nis so judged Affirmer hereby grants to each affected person a royalty-free,\nnon transferable, non sublicensable, non exclusive, irrevocable and\nunconditional license to exercise Affirmer's Copyright and Related Rights in\nthe Work (i) in all territories worldwide, (ii) for the maximum duration\nprovided by applicable law or treaty (including future time extensions), (iii)\nin any current or future medium and for any number of copies, and (iv) for any\npurpose whatsoever, including without limitation commercial, advertising or\npromotional purposes (the \"License\"). The License shall be deemed effective as\nof the date CC0 was applied by Affirmer to the Work. Should any part of the\nLicense for any reason be judged legally invalid or ineffective under\napplicable law, such partial invalidity or ineffectiveness shall not\ninvalidate the remainder of the License, and in such case Affirmer hereby\naffirms that he or she will not (i) exercise any of his or her remaining\nCopyright and Related Rights in the Work or (ii) assert any associated claims\nand causes of action with respect to the Work, in either case contrary to\nAffirmer's express Statement of Purpose.\n\n4. Limitations and Disclaimers.\n\n  a. No trademark or patent rights held by Affirmer are waived, abandoned,\n  surrendered, licensed or otherwise affected by this document.\n\n  b. Affirmer offers the Work as-is and makes no representations or warranties\n  of any kind concerning the Work, express, implied, statutory or otherwise,\n  including without limitation warranties of title, merchantability, fitness\n  for a particular purpose, non infringement, or the absence of latent or\n  other defects, accuracy, or the present or absence of errors, whether or not\n  discoverable, all to the greatest extent permissible under applicable law.\n\n  c. Affirmer disclaims responsibility for clearing rights of other persons\n  that may apply to the Work or any use thereof, including without limitation\n  any person's Copyright and Related Rights in the Work. Further, Affirmer\n  disclaims responsibility for obtaining any necessary consents, permissions\n  or other rights required for any use of the Work.\n\n  d. Affirmer understands and acknowledges that Creative Commons is not a\n  party to this document and has no duty or obligation with respect to this\n  CC0 or use of the Work.\n\nFor more information, please see\n<http://creativecommons.org/publicdomain/zero/1.0/>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6806640625,
          "content": "# SectorC\nSectorC is a C compiler written in x86-16 assembly that fits within the 512 byte boot sector of an x86 machine. It supports a\nsubset of C that is large enough to write real and interesting programs. It is quite likely the smallest C compiler ever written.\n\nIn a base64 encoding, it looks like this:\n\n```\n6gUAwAdoADAfaAAgBzH/6DABPfQYdQXoJQHr8+gjAVOJP+gSALDDqluB+9lQdeAG/zdoAEAfy+gI\nAegFAYnYg/hNdFuE9nQNsOiqiwcp+IPoAqvr4j3/FXUG6OUAquvXPVgYdQXoJgDrGj0C2nUGV+gb\nAOsF6CgA68Ow6apYKfiD6AKrifgp8CaJRP7rrOg4ALiFwKu4D4Srq1fonP9ewz2N/HUV6JoA6BkA\nieu4iQRQuIs26IAAWKvD6AcAieu4iQbrc4nd6HkA6HYA6DgAHg4fvq8Bra052HQGhcB19h/DrVCw\nUKroWQDoGwC4WZGrW4D/wHUMuDnIq7i4AKu4AA+ridirH8M9jfx1COgzALiLBOucg/j4dQXorf/r\nJIP49nUI6BwAuI0G6wyE0nQFsLiq6wa4iwarAduJ2KvrA+gAAOhLADwgfvkx2zHJPDkPnsI8IH4S\nweEIiMFr2wqD6DABw+gqAOvqicg9Ly90Dj0qL3QSPSkoD5TGidjD6BAAPAp1+eu86Ln/g/jDdfjr\nslIx9osEMQQ8O3QUuAACMdLNFIDkgHX0PDt1BIkEMcBaw/v/A8H9/yvB+v/34fb/I8FMAAvBLgAz\nwYQA0+CaANP4jwCUwHf/lcAMAJzADgCfwIUAnsCZAJ3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAVao=\n```\n\n## Supported language\n\nA fairly large subset is supported: global variables, functions, if statements, while statements, lots of operators, pointer dereference, inline machine-code, comments, etc.\nAll of these features make it quite capable.\n\nFor example, the following program animates a moving sine-wave:\n\n```\nint y;\nint x;\nint x_0;\nvoid sin_positive_approx()\n{\n  y = ( x_0 * ( 157 - x_0 ) ) >> 7;\n}\nvoid sin()\n{\n  x_0 = x;\n  while( x_0 > 314 ){\n    x_0 = x_0 - 314;\n  }\n  if( x_0 <= 157 ){\n    sin_positive_approx();\n  }\n  if( x_0 > 157 ){\n    x_0 = x_0 - 157;\n    sin_positive_approx();\n    y = 0 - y;\n  }\n  y = 100 + y;\n}\n\n\nint offset;\nint x_end;\nvoid draw_sine_wave()\n{\n  x = offset;\n  x_end = x + 314;\n  while( x <= x_end ){\n    sin();\n    pixel_x = x - offset;\n    pixel_y = y;\n    vga_set_pixel();\n    x = x + 1;\n  }\n}\n\nint v_1;\nint v_2;\nvoid delay()\n{\n  v_1 = 0;\n  while( v_1 < 50 ){\n    v_2 = 0;\n    while( v_2 < 10000 ){\n      v_2 = v_2 + 1;\n    }\n    v_1 = v_1 + 1;\n  }\n}\n\nvoid main()\n{\n  vga_init();\n\n  offset = 0;\n  while( 1 ){\n    vga_clear();\n    draw_sine_wave();\n\n    delay();\n    offset = offset + 1;\n    if( offset >= 314 ){ // mod the value to avoid 2^16 integer overflow\n      offset = offset - 314;\n    }\n  }\n}\n```\n\n### Screenshot\n\n![Moving Sinwave](img/sinwave.png)\n\n## Provided Example Code\n\nA few examples are provided that leverage the unique hardware aspects of the x86-16 IBM PC:\n- `examples/hello.c:` Print a text greeting on the screen writing to memory at 0xB8000\n- `examples/sinwave.c:` Draw a moving sine wave animation with VGA Mode 0x13 using an appropriately bad approximation of sin(x)\n- `examples/twinkle.c:` Play “Twinkle Twinkle Little Star” through the PC Speaker (Warning: LOUD)\n\n## Grammar\n  \nThe following grammar is accepted and compiled by sectorc:\n\n```\nprogram     = (var_decl | func_decl)+\nvar_decl    = \"int\" identifier \";\"\nfunc_decl   = \"void\" func_name \"{\" statement* \"}\"\nfunc_name   = <identifier that ends in \"()\" with no space>\nstatement   = \"if(\" expr \"){\" statement* \"}\"\n            | \"while(\" expr \"){\" statement* \"}\"\n            | \"asm\" integer \";\"\n            | func_name \";\"\n            | assign_expr \";\"\nassign_expr = deref? identifier \"=\" expr\nderef       = \"*(int*)\"\nexpr        = unary (op unary)?\nunary       = deref identifier\n            | \"&\" identifier\n            | \"(\" expr \")\"\n            | identifier\n            | integer\nop          = \"+\" | \"-\" | \"&\" | \"|\" | \"^\" | \"<<\" | \">>\"\n            | \"==\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\"\n```\n\nIn addition, both `// comment` and `/* multi-line comment */` styles are supported.\n\n(NOTE: This grammar is 704 bytes in ascii, 38% larger than its implementation!)\n\n## How?\n\nSee blog post: [SectorC: A C Compiler in 512 bytes](https://xorvoid.com/sectorc.html)\n\n## Why?\n\nIn 2020, cesarblum wrote a Forth that fits in a bootsector: ([sectorforth](https://github.com/cesarblum/sectorforth))\n\nIn 2021, jart et. al. wrote a Lisp that fits in the bootsector: ([sectorlisp](https://github.com/jart/sectorlisp))\n\nNaturally, C always needs to come and crash (literally) every low-level systems party regardless of whether it was even invited.\n\n## Running\n\nDependencies:\n  - `nasm` for assembling (I used v2.16.01)\n  - `qemu-system-i386` for emulating x86-16 (I used v8.0.0)\n\nBuild: `./build.sh`\n\nRun: `./run.sh your_source.c`\n\nNOTE: Tested only on a MacBook M1\n\n## What is this useful for?\n\nProbably Nothing.\n\nOr at least that's what I thought when starting out. But, I didn't think I'd get such a feature set. Now, I'd say that it **might** be\nuseful for someone that wants to explore x86-16 bios functions and machine model w/o having to learn lots of x86 assembly first. But, then again, you\nshould just use a proper C compiler and write a tiny bootloader to execute it.\n"
        },
        {
          "name": "build.sh",
          "type": "blob",
          "size": 0.2783203125,
          "content": "#!/bin/bash\nset -e\nTHISDIR=$(dirname $(realpath $0))\ncd $THISDIR\n\nSRC=sectorc.s\nBIN=build/sectorc.bin\n\n## output dir for build artifacts\nmkdir -p build\n\n## assemble sectorc\nnasm -f bin -o $BIN $SRC\n\n## build a helpful linter\ngcc -std=c11 -Wall -Werror -O2 -g -o build/lint lint/lint.c\n"
        },
        {
          "name": "dis.sh",
          "type": "blob",
          "size": 0.076171875,
          "content": "#!/bin/bash\nset -e\nobjdump -D -b binary -m i386 -Maddr16,data16 -M intel \"$1\"\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "lint",
          "type": "tree",
          "content": null
        },
        {
          "name": "rt",
          "type": "tree",
          "content": null
        },
        {
          "name": "run.sh",
          "type": "blob",
          "size": 0.2119140625,
          "content": "#!/bin/bash\nset -e\nTHISDIR=$(dirname $(realpath $0))\ncd $THISDIR\n\nif [ \"$#\" != 1 ]; then\n    echo \"usage: $0 <main-source-file>\"\n    exit 1\nfi\n\ninput=\"rt/lib.c $1 rt/_start.c\"\n\n./build/lint $input\n./run_raw.sh $input\n"
        },
        {
          "name": "run_raw.sh",
          "type": "blob",
          "size": 0.263671875,
          "content": "#!/bin/bash\nset -e\nTHISDIR=$(dirname $(realpath $0))\ncd $THISDIR\n\nif [ \"$#\" -lt 1 ]; then\n    echo \"usage: $0 [<source-file> ...]\"\n    exit 1\nfi\n\ncat $@ | qemu-system-i386 -hda build/sectorc.bin -serial stdio -audiodev coreaudio,id=audio0 -machine pcspk-audiodev=audio0\n"
        },
        {
          "name": "sectorc.s",
          "type": "blob",
          "size": 14.1162109375,
          "content": "  bits 16\n  cpu 386\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Token values as computed by the tokenizer's\n;;; atoi() calculation\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n%define TOK_INT         6388\n%define TOK_VOID        11386\n%define TOK_ASM         5631\n%define TOK_COMM        65532\n%define TOK_SEMI        11\n%define TOK_LPAREN      65528\n%define TOK_RPAREN      65529\n%define TOK_START       20697\n%define TOK_DEREF       64653\n%define TOK_WHILE_BEGIN 55810\n%define TOK_IF_BEGIN    6232\n%define TOK_BODY_BEGIN  5\n%define TOK_BLK_BEGIN   75\n%define TOK_BLK_END     77\n%define TOK_ASSIGN      13\n%define TOK_ADDR        65526\n%define TOK_SUB         65533\n%define TOK_ADD         65531\n%define TOK_MUL         65530\n%define TOK_AND         65526\n%define TOK_OR          76\n%define TOK_XOR         46\n%define TOK_SHL         132\n%define TOK_SHR         154\n%define TOK_EQ          143\n%define TOK_NE          65399\n%define TOK_LT          12\n%define TOK_GT          14\n%define TOK_LE          133\n%define TOK_GE          153\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; Common register uses\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; ax: current token / scratch register / emit val for stosw\n;;; bx: current token\n;;; cx: used by tok_next for trailing 2 bytes\n;;; dl: flag for \"tok_is_num\"\n;;; dh: flags for \"tok_is_call\", trailing \"()\"\n;;; bp: saved token for assigned variable\n;;; sp: stack pointer, we don't mess with this\n;;; si: used with lodsw for table scans\n;;; ds: fn symbol table segment (occasionally set to \"cs\" to access binary_oper_tbl)\n;;; di: codegen destination offset\n;;; es: codegen destination segment\n;;; cs: always 0x07c0\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n  jmp 0x07c0:entry\nentry:\n  push 0x3000                   ; segment 0x3000 is used for fn symbol table\n  pop  ds\n  push 0x2000                   ; segment 0x2000 is used for codegen output buffer\n  pop  es\n  xor di,di                     ; codegen index, zero'd\n  ;; [fall-through]\n\n  ;; main loop for parsing all decls\ncompile:\n  ;; advance to either \"int\" or \"void\"\n  call tok_next\n\n  ;; if \"int\" then skip a variable\n  cmp ax,TOK_INT\n  jne compile_function\n  call tok_next2                ; consume \"int\" and <ident>\n  jmp compile\n\ncompile_function:               ; parse and compile a function decl\n  call tok_next                 ; consume \"void\"\n  push bx                       ; save function name token\n  mov [bx],di                   ; record function address in symtbl\n  call compile_stmts_tok_next2  ; compile function body\n\n  mov al,0xc3                   ; emit \"ret\" instruction\n  stosb\n\n  pop bx                        ; if the function is _start(), we're done\n  cmp bx,TOK_START\n  jne compile                   ; otherwise, loop and compile another declaration\n  ;; [fall-through]\n\n  ;; done compiling, execute the binary\nexecute:\n  push es                       ; push the codegen segment\n  push word [bx]                ; push the offset to \"_start()\"\n  push 0x4000                   ; load new segment for variable data\n  pop ds\n  retf                          ; jump into it via \"retf\"\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; compile statements (optionally advancing tokens beforehand)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\ncompile_stmts_tok_next2:\n  call tok_next\ncompile_stmts_tok_next:\n  call tok_next\ncompile_stmts:\n  mov ax,bx\n  cmp ax,TOK_BLK_END            ; if we reach '}' then return\n  je return\n\n  test dh,dh                    ; if dh is 0, it's not a call\n  je _not_call\n  mov al,0xe8                   ; emit \"call\" instruction\n  stosb\n\n  mov ax,[bx]                   ; load function offset from symbol-table\n  sub ax,di                     ; compute relative to this location: \"dest - cur - 2\"\n  sub ax,2\n  stosw                         ;  emit target\n\n  jmp compile_stmts_tok_next2   ; loop to compile next statement\n\n_not_call:\n  cmp ax,TOK_ASM                ; check for \"asm\"\n  jne _not_asm\n  call tok_next                 ; tok_next to get literal byte\n  stosb                         ; emit the literal\n  jmp compile_stmts_tok_next2   ; loop to compile next statement\n\n_not_asm:\n  cmp ax,TOK_IF_BEGIN           ; check for \"if\"\n  jne _not_if\n  call _control_flow_block      ; compile control-flow block\n  jmp _patch_fwd                ; patch up forward jump of if-stmt\n\n_not_if:\n  cmp ax,TOK_WHILE_BEGIN        ; check for \"while\"\n  jne _not_while\n  push di                       ; save loop start location\n  call _control_flow_block      ; compile control-flow block\n  jmp _patch_back               ; patch up backward and forward jumps of while-stmt\n\n_not_while:\n  call compile_assign           ; handle an assignment statement\n  jmp compile_stmts             ; loop to compile next statement\n\n_patch_back:\n  mov al,0xe9                   ; emit \"jmp\" instruction (backwards)\n  stosb\n  pop ax                        ; restore loop start location\n  sub ax,di                     ; compute relative to this location: \"dest - cur - 2\"\n  sub ax,2\n  stosw                         ; emit target\n  ;; [fall-through]\n_patch_fwd:\n  mov ax,di                     ; compute relative fwd jump to this location: \"dest - src\"\n  sub ax,si\n  mov es:[si-2],ax              ; patch \"src - 2\"\n  jmp compile_stmts_tok_next    ; loop to compile next statement\n\n_control_flow_block:\n  call compile_expr_tok_next    ; compile loop or if condition expr\n\n  ;; emit forward jump\n  mov ax,0xc085                 ; emit \"test ax,ax\"\n  stosw\n  mov ax,0x840f                 ; emit \"je\" instruction\n  stosw\n  stosw                         ; emit placeholder for target\n\n  push di                       ; save forward patch location\n  call compile_stmts_tok_next   ; compile a block of statements\n  pop si                        ; restore forward patch location\n\nreturn:                         ; this label gives us a way to do conditional returns\n  ret                           ; (e.g. \"jne return\")\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; compile assignment statement\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\ncompile_assign:\n  cmp ax,TOK_DEREF              ; check for \"*(int*)\"\n  jne _not_deref_store\n  call tok_next                 ; consume \"*(int*)\"\n  call save_var_and_compile_expr ; compile rhs first\n  ;; [fall-through]\n\ncompile_store_deref:\n  mov bx,bp                     ; restore dest var token\n  mov ax,0x0489                 ; code for \"mov [si],ax\"\n  ;; [fall-through]\n\nemit_common_ptr_op:\n  push ax\n  mov ax,0x368b                 ; emit \"mov si,[imm]\"\n  call emit_var\n  pop ax\n  stosw                         ; emit\n  ret\n\n_not_deref_store:\n  call save_var_and_compile_expr ; compile rhs first\n  ;; [fall-through]\n\ncompile_store:\n  mov bx,bp                     ; restore dest var token\n  mov ax,0x0689                 ; code for \"mov [imm],ax\"\n  jmp emit_var                  ; [tail-call]\n\nsave_var_and_compile_expr:\n  mov bp,bx                     ; save dest to bp\n  call tok_next                 ; consume dest\n  ;; [fall-through]             ; fall-through will consume \"=\" before compiling expr\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; compile expression\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\ncompile_expr_tok_next:\n  call tok_next\ncompile_expr:\n  call compile_unary            ; compile left-hand side\n\n  push ds                       ; need to swap out 'ds' to scan the table with lodsw\n  push cs\n  pop ds\n\n  mov si,binary_oper_tbl - 2    ; load ptr to operator table (biased backwards)\n_check_next:\n  lodsw                         ; discard 16-bit of machine-code\n  lodsw                         ; load 16-bit token value\n  cmp ax,bx                     ; matches token?\n  je _found\n  test ax,ax                    ; end of table?\n  jne _check_next\n\n  pop ds\n  ret                           ; all-done, not found\n\n_found:\n  lodsw                         ; load 16-bit of machine-code\n  push ax                       ; save it to the stack\n  mov al,0x50                   ; code for \"push ax\"\n  stosb                         ; emit\n  call tok_next                 ; consume operator token\n  call compile_unary            ; compile right-hand side\n  mov ax,0x9159                 ; code for \"pop cx; xchg ax,cx\"\n  stosw                         ; emit\n\n  pop bx                        ; restore 16-bit of machine-code\n  cmp bh,0xc0                   ; detect the special case for comparison ops\n  jne emit_op\nemit_cmp_op:\n  mov ax,0xc839                 ; code for \"cmp ax,cx\"\n  stosw                         ; emit\n  mov ax,0x00b8                 ; code for \"mov ax,0x00\"\n  stosw                         ; emit\n  mov ax,0x0f00                 ; code for the rest of imm and prefix for \"setX\" instrs\n  stosw                         ; emit\n  ;; [fall-through]\n\nemit_op:\n  mov ax,bx\n  stosw                         ; emit machine code for op\n  pop ds\n  ret\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; compile unary\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\ncompile_unary:\n  cmp ax,TOK_DEREF              ; check for \"*(int*)\"\n  jne _not_deref\n  ;; compile deref (load)\n  call tok_next                 ; consume \"*(int*)\"\n  mov ax,0x048b                 ; code for \"mov ax,[si]\"\n  jmp emit_common_ptr_op        ; [tail-call]\n\n_not_deref:\n  cmp ax,TOK_LPAREN             ; check for \"*(int*)\"\n  jne _not_paren\n  call compile_expr_tok_next    ; consume \"(\" and compile expr\n  jmp tok_next                  ; [tail-call] to consume \")\"\n\n_not_paren:\n  cmp ax,TOK_ADDR               ; check for \"&\"\n  jne _not_addr\n  call tok_next                 ; consume \"&\"\n  mov ax,0x068d                 ; code for \"lea ax,[imm]\"\n  jmp emit_var                  ; [tail-call] to emit code\n\n_not_addr:\n  test dl,dl                    ; check for tok_is_num\n  je _not_int\n  mov al,0xb8                   ; code for \"mov ax,imm\"\n  stosb                         ; emit\n  jmp emit_tok                  ; [tail-call] to emit imm\n\n_not_int:\n  ;; compile var\n  mov ax,0x068b                 ; code for \"mov ax,[imm]\"\n  ;; [fall-through]\n\nemit_var:\n  stosw                         ; emit\n  add bx,bx                     ; bx = 2*bx (scale up for 16-bit)\n  ;; [fall-through]\n\nemit_tok:\n  mov ax,bx\n  stosw                         ; emit token value\n  jmp tok_next                  ; [tail-call]\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; get next token, setting the following:\n;;;   ax: token\n;;;   bx: token\n;;;   dl: tok_is_num\n;;;   dh: tok_is_call\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\ntok_next2:\n  call tok_next\n  ;; [fall-through]\ntok_next:\n  call getch\n  cmp al,32                     ; skip spaces (anything <= ' ' is considered space)\n  jle tok_next\n\n  xor bx,bx                     ; zero token reg\n  xor cx,cx                     ; zero last-two chars reg\n\n  cmp al,57\n  setle dl                      ; tok_is_num = (al <= '9')\n\n_nextch:\n  cmp al,32\n  jle _done                     ; if char is space then break\n\n  shl cx,8\n  mov cl,al                     ; shift this char into cx\n\n  imul bx,10\n  sub ax,48\n  add bx,ax                     ; atoi computation: bx = 10 * bx + (ax - '0')\n\n  call getch\n  jmp _nextch                   ; [loop]\n\n_done:\n  mov ax,cx\n  cmp ax,0x2f2f                 ; check for single-line comment \"//\"\n  je _comment_double_slash\n  cmp ax,0x2f2a                 ; check for multi-line comment \"/*\"\n  je _comment_multi_line\n  cmp ax,0x2829                 ; check for call parens \"()\"\n  sete dh\n\n  mov ax,bx                     ; return token in ax also\n  ret\n\n_comment_double_slash:\n  call getch                    ; get next char\n  cmp al,10                     ; check for newline '\\n'\n  jne _comment_double_slash     ; [loop]\n  jmp tok_next                  ; [tail-call]\n\n_comment_multi_line:\n  call tok_next                 ; get next token\n  cmp ax,65475                  ; check for token \"*/\"\n  jne _comment_multi_line       ; [loop]\n  jmp tok_next                  ; [tail-call]\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; get next char: returned in ax (ah == 0, al == ch)\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\ngetch:\n  push dx                       ; need to save dx because tok_next uses it for flags\n  xor si,si                     ; use ds:0 as a semi-colon buffer, encodes smaller via si\n  mov ax,[si]                   ; load the semi-colon buffer\n  xor [si],ax                   ; zero the buffer\n  cmp al,59                     ; check for ';'\n  je getch_done                 ; if ';' return it\n\ngetch_tryagain:\n  mov ax,0x0200\n  xor dx,dx\n  int 0x14                      ; get a char from serial (bios function)\n\n  and ah,0x80                   ; check for failure and clear ah as a side-effect\n  jne getch_tryagain            ; failed, try again later\n\n  cmp al,59                     ; check for ';'\n  jne getch_done                ; if not ';' return it\n  mov [si],ax                   ; save the ';'\n  xor ax,ax                     ; return 0 instead, treated as whitespcae\n\ngetch_done:\n  pop dx\n  ret\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; binary operator table\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nbinary_oper_tbl:\n  dw TOK_ADD,0xc103             ; add ax,cx\n  dw TOK_SUB,0xc12b             ; sub ax,cx\n  dw TOK_MUL,0xe1f7             ; mul ax,cx\n  dw TOK_AND,0xc123             ; and ax,cx\n  dw TOK_OR,0xc10b              ; or ax,cx\n  dw TOK_XOR,0xc133             ; xor ax,cx\n  dw TOK_SHL,0xe0d3             ; shl ax,cx\n  dw TOK_SHR,0xf8d3             ; shr ax,cx\n  dw TOK_EQ,0xc094              ; sete al\n  dw TOK_NE,0xc095              ; setne al\n  dw TOK_LT,0xc09c              ; setl al\n  dw TOK_GT,0xc09f              ; setg al\n  dw TOK_LE,0xc09e              ; setle al\n  dw TOK_GE,0xc09d              ; setge al\n  dw 0                          ; [sentinel]\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;; boot signature\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  times 510-($-$$) db 0\n  db 0x55, 0xaa\n"
        }
      ]
    }
  ]
}