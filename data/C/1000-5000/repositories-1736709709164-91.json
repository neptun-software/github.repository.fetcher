{
  "metadata": {
    "timestamp": 1736709709164,
    "page": 91,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ptitSeb/box64",
      "stars": 4127,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.51171875,
          "content": "---\nBasedOnStyle: WebKit\nAlignTrailingComments: true\nAllowShortBlocksOnASingleLine: true\nAllowShortCaseLabelsOnASingleLine: true\nAllowShortFunctionsOnASingleLine: true\nAllowShortIfStatementsOnASingleLine: true\nColumnLimit: 0\nIndentWidth: 4\nSortIncludes: false\nMaxEmptyLinesToKeep: 2\nIndentCaseLabels: true\nAlignConsecutiveMacros: true\nWhitespaceSensitiveMacros: ['QUOTE']\nIfMacros: ['IFX', 'IFXORNAT', 'IFX2', 'IFXA', 'IFX_PENDOR0', 'IFXX', 'IFX2X', 'IFXN', 'UFLAG_IF', 'PASS2IF']\nUseTab: Never\nIndentPPDirectives: None\n---\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.748046875,
          "content": "# Prerequisites\n*.d\n\n# Object files\n*.o\n*.ko\n*.obj\n*.elf\n\n# Linker output\n*.ilk\n*.map\n*.exp\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Libraries\n*.lib\n*.a\n*.la\n*.lo\n\n# Shared objects (inc. Windows DLLs)\n*.dll\n*.so\n*.so.*\n*.dylib\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex\n\n# Debug files\n*.dSYM/\n*.su\n*.idb\n*.pdb\n\n# Kernel Module Compile Results\n*.mod*\n*.cmd\n.tmp_versions/\nmodules.order\nModule.symvers\nMkfile.old\ndkms.conf\n\n# from box86\nbuild/\nbuild*/\n.vscode\n.cache\n.gdb_history\nsrc/git_head.h\nbackup/\n\n# Wrapper helper\n/wrapperhelper/bin\n/wrapperhelper/makedir\n/wrapperhelper/obj\n/wrapperhelper/sanaddress\n/wrapperhelper/sanleak\n/wrapperhelper/sanundefined\n/wrapperhelper/src/machine.gen\n/wrapperhelper/*.h\n!/wrapperhelper/example-libc.h\n\n# macOS\n.DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4521484375,
          "content": "language: c\r\narch:\r\n  - amd64\r\n  - arm64-graviton2\r\nos: linux\r\ndist: focal\r\n\r\ncompiler:\r\n    - gcc\r\n\r\naddons:\r\n  apt:\r\n    packages:\r\n      - python3\r\n\r\n      #Build steps\r\nbefore_script:\r\n    - mkdir build\r\n    - cd build\r\n    - if [ \"$TRAVIS_CPU_ARCH\" = \"arm64\" ]; then cmake .. -DRK3399=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ; else cmake .. -DLD80BITS=1 -DNOALIGN=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo ; fi\r\n\r\nscript:\r\n    - make\r\n    - ctest --output-on-failure\r\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 83.9287109375,
          "content": "cmake_minimum_required(VERSION 3.13)\n\ncmake_policy(SET CMP0065 NEW)\n\nSET(CMAKE_C_FLAGS_DEBUG  \"-O0 -g\")\nSET(CMAKE_CXX_FLAGS_DEBUG  \"-O0 -g\")\n\noption(RPI3ARM64 \"Set to ON if targeting an RaspberryPI3 device with multiarch arm64 and armhf\" ${RPI3ARM64})\noption(RPI4ARM64 \"Set to ON if targeting an RaspberryPI4 device with multiarch arm64 and armhf\" ${RPI4ARM64})\noption(RPI5ARM64 \"Set to ON if targeting an RaspberryPi5 device with multiarch arm64 and armhf\" ${RPI5ARM64})\noption(RK3326 \"Set to ON if targeting an Rockchip RK3326 based device\" ${RK3326})\noption(RK3399 \"Set to ON if targeting an Rockchip RK3399 based device\" ${RK3399})\noption(RK3588 \"Set to ON if targeting an Rockchip RK3588(S) based device\" ${RK3588})\noption(ODROIDN2 \"Set to ON if targeting an Odroid-N2 device\" ${ODROIDN2})\noption(TEGRAX1 \"Set to ON if targeting an Tegra X1 based device\" ${TEGRAX1})\noption(TEGRA_T194 \"Set to ON if targeting an Tegra Xavier based device\" ${TEGRA_T194})\noption(TEGRA_T234 \"Set to ON if targeting an Tegra Orin based device\" ${TEGRA_T234})\noption(PHYTIUM \"Set to ON if targeting an Phytium (D2000 or FT2000/4) based device\" ${PHYTIUM})\noption(SD845 \"Set to ON if targeting a Snapragon 845 based device\" ${SD845})\noption(SD865 \"Set to ON if targeting a Snapragon 865 based device\" ${SD865})\noption(SD888 \"Set to ON if targeting a Snapragon 888 based device\" ${SD888})\noption(SD8G2 \"Set to ON if targeting a Snapragon 8 Gen 2 based device\" ${SD8G2})\noption(SDORYON1 \"Set to ON if targeting a Snapdragon Oryon 1 (X1E80100/X1E78100) based device\" ${SDORYON1})\noption(ADLINK \"Set to ON if targeting an ADLink AmpereAltra based device\" ${ADLINK})\noption(M1 \"Set to ON if targeting a AppleM1 running on Asahi computer\" ${M1})\noption(LARCH64 \"Set to ON if targeting an Loongarch64 based device\" ${LARCH64})\noption(RV64 \"Set to ON if targeting an RISC-V RV64GC based device\" ${RV64})\noption(PPC64LE \"Set to ON if targeting an PowerPC 64 LE based device\" ${PPC64LE})\noption(LX2160A \"Set to ON if targeting an LX2160A based device\" ${LX2160A})\noption(ARM64 \"Set to ON if targeting a generic ARM64 based device\" ${ARM64})\noption(ANDROID \"Set to ON if targeting an Android device\" ${ANDROID})\noption(TERMUX \"Set to ON if targeting an Android device with Termux\" ${TERMUX})\noption(USE_CCACHE \"Set to ON to use ccache if present in the system\" ${USE_CCACHE})\noption(HAVE_TRACE \"Set to ON to have Trace ability (needs ZydisInfo library)\" ${HAVE_TRACE})\noption(SAVE_MEM \"Set to ON to build dynarec with some slower memory saving optimizations\" ${SAVE_MEM})\noption(NOLOADADDR \"Set to ON to avoid fixing the load address of Box64\" OFF)\noption(NOGIT \"Set to ON if not building from a git clone repo (like when building from a zip download from github)\" ${NOGIT})\noption(BAD_SIGNAL \"Set to ON to activate the workaround for incoherent si_info on SIGSEGV\" ${BAD_SIGNAL})\noption(SW64 \"Set ON if targeting an SW64 based device\" ${SW64})\noption(CI \"Set to ON if running in CI\" ${CI})\noption(WITH_MOLD \"Set to ON to use with mold\" ${WITH_MOLD})\noption(BOX32 \"Set to ON to add Linux 32bits support (experimental, do not use)\" ${BOX32})\noption(BOX32_BINFMT \"Also setup binfmt integration for box32\" ${BOX32_BINFMT})\noption(LARCH64_ABI_1 \"Set to ON if building for Loongarch64 ABI 1.0 system\" ${LARCH64_ABI_1})\noption(GDBJIT \"Set to ON to enable GDB JIT support\" ${GDBJIT})\n\nif(TERMUX)\n    set(TERMUX_PATH \"/data/data/com.termux/files\")\n    set(ANDROID ON CACHE BOOL \"\")\nendif()\nif(LARCH64)\n    set(LD80BITS OFF CACHE BOOL \"\")\n    set(NOALIGN OFF CACHE BOOL \"\")\n    set(ARM_DYNAREC OFF CACHE BOOL \"\")\n    set(RV64_DYNAREC OFF CACHE BOOL \"\")\n    set(LARCH64_DYNAREC ON CACHE BOOL \"\")\n    if(LARCH64_ABI_1)\n        message(STATUS \"Build for Loongarch64 ABI 1.0 system\")\n        add_definitions(-DLA64_ABI_1)\n    endif()\nendif()\nif(RV64)\n    set(LD80BITS OFF CACHE BOOL \"\")\n    set(NOALIGN OFF CACHE BOOL \"\")\n    set(ARM_DYNAREC OFF CACHE BOOL \"\")\n    set(RV64_DYNAREC ON CACHE BOOL \"\")\n    set(LARCH64_DYNAREC OFF CACHE BOOL \"\")\nendif()\nif(PPC64LE)\n    set(LD80BITS OFF CACHE BOOL \"\")\n    set(NOALIGN OFF CACHE BOOL \"\")\n    set(ARM_DYNAREC OFF CACHE BOOL \"\")\n    set(RV64_DYNAREC OFF CACHE BOOL \"\")\n    set(LARCH64_DYNAREC OFF CACHE BOOL \"\")\nendif()\nif(RK3399 OR RK3588 OR ODROIDN2 OR RPI3ARM64 OR RPI4ARM64 OR RPI5ARM64 OR RK3326 OR TEGRAX1 OR TEGRA_T194 OR TEGRA_T234 OR PHYTIUM OR SD845 OR SD865 OR SD888 OR SD8G2 OR SDORYON1 OR LX2160A OR M1 OR ARM64 OR ADLINK)\n    set(LD80BITS OFF CACHE BOOL \"\")\n    set(NOALIGN OFF CACHE BOOL \"\")\n    set(ARM_DYNAREC ON CACHE BOOL \"\")\n    set(RV64_DYNAREC OFF CACHE BOOL \"\")\n    set(LARCH64_DYNAREC OFF CACHE BOOL \"\")\nendif()\nif(RK3399 OR ODROIDN2 OR RPI3ARM64 OR RPI4ARM64 OR RPI5ARM64)\n    set(SAVE_MEM ON CACHE BOOL \"\")\nendif()\nif(RK3588)\n    set(BAD_SIGNAL ON CACHE BOOL \"\")\nendif()\nif(SW64)\n    set(LD80BITS OFF CACHE BOOL \"\")\n    set(NOALIGN OFF CACHE BOOL \"\")\nendif()\nif(ANDROID)\n    set(TERMUX_PATH \"/data/data/com.termux/files\")\n    set(NOLOADADDR ON CACHE BOOL \"\")\n    set(BAD_SIGNAL ON CACHE BOOL \"\")\nendif()\n\nif(GDBJIT)\n    message(STATUS \"Build with GDBJIT support\")\n    add_definitions(-DGDBJIT)\nendif()\n\noption(LD80BITS \"Set to ON if host device have 80bits long double (i.e. i386)\" ${LD80BITS})\noption(NOALIGN \"Set to ON if host device doesn't need re-align (i.e. i386)\" ${NOALIGN})\noption(ARM_DYNAREC \"Set to ON to use ARM Dynamic Recompilation\" ${ARM_DYNAREC})\noption(RV64_DYNAREC \"Set to ON to use RISC-V Dynamic Recompilation\" ${RV64_DYNAREC})\noption(LARCH64_DYNAREC \"Set to ON to use LOONGARCH64 Dynamic Recompilation\" ${LARCH64_DYNAREC})\noption(STATICBUILD \"Set to ON to have a static build (Warning, not working)\" ${STATICBUILD})\noption(NO_LIB_INSTALL \"Set ON to not install a few x86_64 libs that are used by many program\" ${NO_LIB_INSTALL})\noption(NO_CONF_INSTALL \"Set ON to not install config files\" ${NO_CONF_INSTALL})\n\nif(${CMAKE_VERSION} VERSION_LESS \"3.12.2\")\n    find_package(PythonInterp 3)\n    if(NOT PYTHONINTERP_FOUND)\n        message( FATAL_ERROR \"You need a Python interpreter, CMake will exit.\" )\n    endif()\n    if(${PYTHON_VERSION_MAJOR} LESS 3)\n        message( FATAL_ERROR \"You need a Python 3 interpreter, CMake will exit.\" )\n    endif()\nelse()\n    find_package(Python3)\n    if(NOT Python3_Interpreter_FOUND)\n        message( FATAL_ERROR \"You need a Python interpreter, CMake will exit.\" )\n    endif()\n    set(PYTHON_EXECUTABLE ${Python3_EXECUTABLE} CACHE INTERNAL \"The Python3 executable\" FORCE)\nendif()\n\nproject(box64 C ASM)\n\nenable_testing()\n\nset(default_build_type \"RelWithDebInfo\")\nif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  message(STATUS \"Setting build type to '${default_build_type}' as none was specified.\")\n  set(CMAKE_BUILD_TYPE \"${default_build_type}\" CACHE STRING \"Choose the type of build.\" FORCE)\n  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\")\nendif()\n\nif(RPI3ARM64)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI3ARM64)\n    add_definitions(-pipe -march=armv8-a+crc -mtune=cortex-a53)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc -mtune=cortex-a53\")\nelseif(RPI4ARM64)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI4ARM64)\n    add_definitions(-pipe -march=armv8-a+crc -mtune=cortex-a72)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc -mtune=cortex-a72\")\nelseif(RPI5ARM64)\n    add_definitions(-DRPI)\n    add_definitions(-DRPI5ARM64)\n    add_definitions(-pipe -march=armv8.2-a+crc+crypto+fp16+rcpc+dotprod -mtune=cortex-a76)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.2-a+crc+crypto+fp16+rcpc+dotprod -mtune=cortex-a76\")\nelseif(RK3326)\n    add_definitions(-DRK3326)\n    add_definitions(-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a35+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a35+crypto\")\nelseif(RK3399)\n    add_definitions(-DRK3399)\n    add_definitions(-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a72.cortex-a53+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a72.cortex-a53+crypto\")\nelseif(RK3588)\n    add_definitions(-DRK3588)\n    add_definitions(-pipe -mcpu=cortex-a76.cortex-a55+crypto)\n    add_definitions(-DBAD_SIGNAL)\n    set(CMAKE_ASM_FLAGS  \"-pipe -mcpu=cortex-a76.cortex-a55+crypto\")\nelseif(ODROIDN2)\n    add_definitions(-DODROIDN2)\n    add_definitions(-march=armv8-a+crc+simd+crypto -mcpu=cortex-a73.cortex-a53+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a73.cortex-a53+crypto\")\nelseif(TEGRAX1)\n    add_definitions(-DTEGRAX1)\n    add_definitions(-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a57+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto -mcpu=cortex-a57+crypto\")\nelseif(TEGRA_T194)\n    add_definitions(-DTEGRA_T194)\n    add_definitions(-pipe -march=armv8.2-a+fp16+simd+crypto+predres -mcpu=cortex-a76+crypto -mtune=cortex-a76)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.2-a+fp16+simd+crypto+predres -mcpu=cortex-a76+crypto -mtune=cortex-a76\")\nelseif(TEGRA_T234)\n    add_definitions(-DTEGRA_T234)\n    add_definitions(-pipe -march=armv8.2-a+fp16+simd+crypto+predres -mcpu=cortex-a78ae+crypto -mtune=cortex-a78ae)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.2-a+fp16+simd+crypto+predres -mcpu=cortex-a78ae+crypto -mtune=cortex-a78ae\")\nelseif(PHYTIUM)\n    add_definitions(-DPHYTIUM)\n    add_definitions(-pipe -march=armv8.1-a+crc+simd+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.1-a+crc+simd+crypto+aes\")\nelseif(SD845)\n    add_definitions(-DSD845)\n    add_definitions(-pipe -march=armv8.2-a+simd+crypto -mtune=cortex-a75.cortex-a55)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.2-a+simd+crypto -mtune=cortex-a75.cortex-a55\")\nelseif(SD865)\n    add_definitions(-DSD865)\n    #note that cortex-a77.cortex-a55 is not supported, so fall back to a76 instead\n    add_definitions(-pipe -march=armv8.2-a+simd+crypto -mtune=cortex-a76.cortex-a55)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.2-a+simd+crypto -mtune=cortex-a76.cortex-a55\")\nelseif(SD888)\n    add_definitions(-DSD888)\n    add_definitions(-pipe -march=armv8.4-a+simd+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.4-a+simd+crypto\")\nelseif(SD8G2)\n    add_definitions(-DSD8G2)\n    add_definitions(-pipe -march=armv9-a+i8mm+sm4+sha3+rcpc+crypto+nosve+nosve2)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv9-a+i8mm+sm4+sha3+rcpc+crypto+nosve+nosve2\")\nelseif(SDORYON1)\n    add_definitions(-DSDORYON1)\n    # NOTE\n    #\n    # 1.\n    # GCC 14 and Clang 19 support oryon-1 as a -mcpu/-mtune argument,\n    # however it seems like fedora (the system I tested this on) does not work.\n    # see https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/AArch64-Options.html if you're interested\n    #\n    # 2.\n    # gcc/gcc/config/aarch64/aarch64-cores.def:157 defines oryon1 as\n    # AARCH64_CORE(\"oryon-1\", oryon1, cortexa57, V8_6A, (CRYPTO, SM4, SHA3, F16), cortexa72,   0x51, 0x001, -1)\n    # where\n    #  * the 3rd positional argument is represented as the \"scheduler\"\n    #  * the 6th positional argument is represented as the \"cost\"\n    #  I've chosen the a57 because I don't know if I should choose the a72\n    add_definitions(-pipe -march=armv8.6-a+crypto+sm4+sha3+fp16 -mtune=cortex-a57)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.6-a+crypto+sm4+sha3+fp16 -mtune=cortex-a57\")\nelseif(ADLINK)\n    add_definitions(-DADLINK)\n    add_definitions(-pipe -mcpu=neoverse-n1 -fuse-ld=gold -fuse-linker-plugin)\n    set(CMAKE_ASM_FLAGS  \"-pipe -mcpu=neoverse-n1\")\nelseif(M1)\n    add_definitions(-DM1)\n    add_definitions(-pipe -march=armv8.5-a+simd+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8.5-a+simd+crypto\")\nelseif(LARCH64)\n    add_definitions(-DLA64)\n    add_definitions(-pipe -march=loongarch64)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=loongarch64\")\nelseif(RV64)\n    add_definitions(-DRV64)\n    add_definitions(-pipe -march=rv64gc)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=rv64gc\")\nelseif(PPC64LE)\n    add_definitions(-DPPC64LE)\nelseif(LX2160A)\n    add_definitions(-DLX2160A)\n    add_definitions(-pipe -march=armv8-a+crypto+crc -mcpu=cortex-a72+crypto)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crypto+crc -mcpu=cortex-a72+crypto\")\nelseif(SW64)\n    add_definitions(-DSW64)\nelseif(ARM64)\n    #add_definitions(-pipe -march=native)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+simd\")\nelseif(ARM_DYNAREC)\n    set(CMAKE_ASM_FLAGS  \"-pipe -march=armv8-a+crc+simd+crypto\")\nendif()\nif(ANDROID)\n    add_definitions(-DANDROID)\nendif()\nif(TERMUX)\n    add_definitions(-DTERMUX)\nendif()\nif(BAD_SIGNAL)\n    add_definitions(-DBAD_SIGNAL)\nendif()\nif(SAVE_MEM)\n    add_definitions(-DSAVE_MEM)\nendif()\nif(STATICBUILD)\n    #-fno-pic -mcmodel=large\n    add_definitions(-DSTATICBUILD)\n    add_definitions(-Wno-deprecated-declarations)   #by-design, deprecated function can be used\n    set(BUILD_SHARED_LIBS OFF)\n    set(CMAKE_EXE_LINKER_FLAGS \"-static\")\n    set(HAVE_TRACE OFF)\nendif()\nif(BOX32)\n    add_definitions(-DBOX32)\n    add_definitions(-Wno-address-of-packed-member)  #32bits might generated unaligned pointers\nendif()\n\nif(NOGIT)\n    add_definitions(-DNOGIT)\nendif()\nif(CI)\n    add_definitions(-Wno-pointer-type-mismatch)\nendif()\n\nif(HAVE_TRACE)\n    set(BOX64 box64)\nelse()\n    set(BOX64 box64)\nendif()\n\n#set(BOX64_ELF_ADDRESS \"0x500062800000\")  #random load address...\nset(BOX64_ELF_ADDRESS \"0x34800000\")  #low address\n\nif(LD80BITS)\n    add_definitions(-DHAVE_LD80BITS)\nendif()\n\nif(NOALIGN)\n    add_definitions(-DNOALIGN)\nendif()\n\nif(HAVE_TRACE)\n    add_definitions(-DHAVE_TRACE)\nendif()\n\nif(ARM_DYNAREC)\n    add_definitions(-DDYNAREC)\n    add_definitions(-DARM64)\n    enable_language(ASM)\n    include_directories(\"${BOX64_ROOT}/src/dynarec/arm64\")\n    set(DYNAREC ON)\nelseif(RV64_DYNAREC)\n    add_definitions(-DDYNAREC)\n    add_definitions(-DRV64)\n    enable_language(ASM)\n    include_directories(\"${BOX64_ROOT}/src/dynarec/rv64\")\n    set(DYNAREC ON)\nelseif(LARCH64_DYNAREC)\n    add_definitions(-DDYNAREC)\n    add_definitions(-DLA64)\n    enable_language(ASM)\n    include_directories(\"${BOX64_ROOT}/src/dynarec/la64\")\n    set(DYNAREC ON)\nelse()\n    set(DYNAREC OFF)\nendif()\n\nset(BOX64_ROOT ${CMAKE_SOURCE_DIR})\n\nadd_definitions(-std=gnu11 -funwind-tables -fvisibility=hidden)\n\nif(USE_CCACHE)\n    find_program(CCACHE_FOUND ccache)\n    if(CCACHE_FOUND)\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)\n        set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)\n    else()\n        message(SEND_ERROR \"ccache not found!\")\n    endif()\nendif()\n\ninclude_directories(\n    \"${BOX64_ROOT}/src/include\"\n    \"${BOX64_ROOT}/src\"\n    \"${BOX64_ROOT}/src/wrapped/generated\"\n)\nif(BOX32)\n    include_directories(\n        \"${BOX64_ROOT}/src/wrapped32/generated\"\n    )\nendif()\n\n# git_head.h is a generated file\nset_source_files_properties(\n    \"${BOX64_ROOT}/src/git_head.h\"\n    PROPERTIES GENERATED TRUE\n    HEADER_FILE_ONLY TRUE)\n\nset(ELFLOADER_SRC\n    \"${BOX64_ROOT}/src/main.c\"\n    \"${BOX64_ROOT}/src/core.c\"\n    \"${BOX64_ROOT}/src/box64context.c\"\n    \"${BOX64_ROOT}/src/build_info.c\"\n    \"${BOX64_ROOT}/src/custommem.c\"\n    \"${BOX64_ROOT}/src/custommmap.c\"\n    \"${BOX64_ROOT}/src/dynarec/dynarec.c\"\n    \"${BOX64_ROOT}/src/elfs/elfloader.c\"\n    \"${BOX64_ROOT}/src/elfs/elfparser.c\"\n    \"${BOX64_ROOT}/src/elfs/elfhash.c\"\n    \"${BOX64_ROOT}/src/elfs/elfload_dump.c\"\n    \"${BOX64_ROOT}/src/elfs/elfdwarf_private.c\"\n    \"${BOX64_ROOT}/src/emu/x64compstrings.c\"\n    \"${BOX64_ROOT}/src/emu/x64emu.c\"\n    \"${BOX64_ROOT}/src/emu/x64int3.c\"\n    \"${BOX64_ROOT}/src/emu/x87emu_private.c\"\n    \"${BOX64_ROOT}/src/emu/x64primop.c\"\n    \"${BOX64_ROOT}/src/emu/x64run_private.c\"\n    \"${BOX64_ROOT}/src/emu/x64shaext.c\"\n    \"${BOX64_ROOT}/src/emu/x64syscall.c\"\n    \"${BOX64_ROOT}/src/emu/x64tls.c\"\n    \"${BOX64_ROOT}/src/emu/x64trace.c\"\n    \"${BOX64_ROOT}/src/librarian/librarian.c\"\n    \"${BOX64_ROOT}/src/librarian/library.c\"\n    \"${BOX64_ROOT}/src/librarian/dictionnary.c\"\n    \"${BOX64_ROOT}/src/librarian/symbols.c\"\n    \"${BOX64_ROOT}/src/libtools/auxval.c\"\n    \"${BOX64_ROOT}/src/libtools/myalign.c\"\n    \"${BOX64_ROOT}/src/libtools/signals.c\"\n    \"${BOX64_ROOT}/src/libtools/decopcode.c\"\n    \"${BOX64_ROOT}/src/libtools/threads.c\"\n    \"${BOX64_ROOT}/src/tools/bitutils.c\"\n    \"${BOX64_ROOT}/src/tools/box64stack.c\"\n    \"${BOX64_ROOT}/src/tools/bridge.c\"\n    \"${BOX64_ROOT}/src/tools/callback.c\"\n    \"${BOX64_ROOT}/src/tools/gdbjit.c\"\n    \"${BOX64_ROOT}/src/tools/my_cpuid.c\"\n    \"${BOX64_ROOT}/src/tools/fileutils.c\"\n    \"${BOX64_ROOT}/src/tools/pathcoll.c\"\n    \"${BOX64_ROOT}/src/tools/rbtree.c\"\n    \"${BOX64_ROOT}/src/tools/rcfile.c\"\n    \"${BOX64_ROOT}/src/tools/wine_tools.c\"\n    \"${BOX64_ROOT}/src/wrapped/generated/wrapper.c\"\n)\nif(NOT STATICBUILD)\n    list(APPEND ELFLOADER_SRC\n        \"${BOX64_ROOT}/src/mallochook.c\"\n        \"${BOX64_ROOT}/src/steam.c\"\n        \"${BOX64_ROOT}/src/libtools/sdl1rwops.c\"\n        \"${BOX64_ROOT}/src/libtools/sdl2rwops.c\"\n        \"${BOX64_ROOT}/src/tools/gtkclass.c\"\n        \"${BOX64_ROOT}/src/librarian/globalsymbols.c\"\n        )\nendif()\nif(BOX32)\n    list(APPEND ELFLOADER_SRC\n        \"${BOX64_ROOT}/src/box32.c\"\n        \"${BOX64_ROOT}/src/elfs/elfhash32.c\"\n        \"${BOX64_ROOT}/src/elfs/elfloader32.c\"\n        \"${BOX64_ROOT}/src/elfs/elfparser32.c\"\n        \"${BOX64_ROOT}/src/elfs/elfload_dump32.c\"\n        \"${BOX64_ROOT}/src/tools/box32stack.c\"\n        \"${BOX64_ROOT}/src/emu/x86int3.c\"\n        \"${BOX64_ROOT}/src/librarian/globalsymbols32.c\"\n        \"${BOX64_ROOT}/src/libtools/myalign32.c\"\n        \"${BOX64_ROOT}/src/libtools/myalign64_32.c\"\n        \"${BOX64_ROOT}/src/libtools/myalignxcb32.c\"\n        \"${BOX64_ROOT}/src/libtools/signal32.c\"\n        \"${BOX64_ROOT}/src/libtools/threads32.c\"\n        \"${BOX64_ROOT}/src/libtools/libc_net32.c\"\n        \"${BOX64_ROOT}/src/libtools/sdl1align32.c\"\n        \"${BOX64_ROOT}/src/libtools/sdl2align32.c\"\n        \"${BOX64_ROOT}/src/libtools/my_x11_conv.c\"\n        \"${BOX64_ROOT}/src/libtools/my_x11_xevent.c\"\n        \"${BOX64_ROOT}/src/emu/x86syscall_32.c\"\n        \"${BOX64_ROOT}/src/wrapped32/generated/wrapper32.c\"\n        \"${BOX64_ROOT}/src/wrapped32/generated/converter32.c\"\n    )\nelse()\n    list(APPEND ELFLOADER_SRC\n        \"${BOX64_ROOT}/src/emu/x86syscall.c\"\n    )\nendif()\nif(NOT ANDROID)\n    list(APPEND ELFLOADER_SRC\n        \"${BOX64_ROOT}/src/libtools/obstack.c\"\n    )\nendif()\n\nset(INTERPRETER\n    \"${BOX64_ROOT}/src/emu/x64run.c\"\n    \"${BOX64_ROOT}/src/emu/x64run0f.c\"\n    \"${BOX64_ROOT}/src/emu/x64run64.c\"\n    \"${BOX64_ROOT}/src/emu/x64run66.c\"\n    \"${BOX64_ROOT}/src/emu/x64run660f.c\"\n    \"${BOX64_ROOT}/src/emu/x64run66f20f.c\"\n    \"${BOX64_ROOT}/src/emu/x64run66f30f.c\"\n    \"${BOX64_ROOT}/src/emu/x64run6664.c\"\n    \"${BOX64_ROOT}/src/emu/x64run66d9.c\"\n    \"${BOX64_ROOT}/src/emu/x64run66dd.c\"\n    \"${BOX64_ROOT}/src/emu/x64run66f0.c\"\n    \"${BOX64_ROOT}/src/emu/x64run67.c\"\n    \"${BOX64_ROOT}/src/emu/x64run67avx.c\"\n    \"${BOX64_ROOT}/src/emu/x64run67_32.c\"\n    \"${BOX64_ROOT}/src/emu/x64run6764_32.c\"\n    \"${BOX64_ROOT}/src/emu/x64run670f.c\"\n    \"${BOX64_ROOT}/src/emu/x64run6766.c\"\n    \"${BOX64_ROOT}/src/emu/x64run67660f.c\"\n    \"${BOX64_ROOT}/src/emu/x64rund8.c\"\n    \"${BOX64_ROOT}/src/emu/x64rund9.c\"\n    \"${BOX64_ROOT}/src/emu/x64runda.c\"\n    \"${BOX64_ROOT}/src/emu/x64rundb.c\"\n    \"${BOX64_ROOT}/src/emu/x64rundc.c\"\n    \"${BOX64_ROOT}/src/emu/x64rundd.c\"\n    \"${BOX64_ROOT}/src/emu/x64runde.c\"\n    \"${BOX64_ROOT}/src/emu/x64rundf.c\"\n    \"${BOX64_ROOT}/src/emu/x64runf0.c\"\n    \"${BOX64_ROOT}/src/emu/x64runf20f.c\"\n    \"${BOX64_ROOT}/src/emu/x64runf30f.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavx.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavx0f.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavx0f38.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavx660f.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavxf20f.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavxf30f.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavx660f38.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavx660f3a.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavxf20f38.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavxf30f38.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavxf20f3a.c\"\n    \"${BOX64_ROOT}/src/emu/x64runavxf30f3a.c\"\n)\n\nif(STATICBUILD)\nset(WRAPPEDS\n    \"${BOX64_ROOT}/src/wrapped/wrappedldlinux.c\"\n    #\"${BOX64_ROOT}/src/wrapped/wrappedlibbsd.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibc.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibcmusl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibdl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedutil.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibresolv.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibrt.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibpthread.c\"\n)\nelse()\nset(WRAPPEDS\n    \"${BOX64_ROOT}/src/wrapped/wrappedalure.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedalut.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedatk.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedatkbridge.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedatomic.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedatspi.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedayatanaappindicator3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedbz2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcap.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcairo.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcairogobject.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcrashhandler.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcrypto.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcrypto3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedcurl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappeddbus.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappeddbusglib1.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappeddbusmenuglib.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappeddecor0.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedevent21.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedexpat.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedfaudio.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedflac.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedfontconfig.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedfreebl3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedfreetype.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgbm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgconf2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgcrypt.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgdk3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgdkpixbuf2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgdkx112.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgio2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedglesv2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedglib2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgmodule2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgmp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgnutls.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgobject2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgomp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgssapi.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgssapikrb5.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstallocators.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstapp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstaudio.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstbase.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstcheck.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstcontroller.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstfft.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstgl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstnet.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstpbutils.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstreamer.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstriff.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstrtp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstrtsp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstsdp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgsttag.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgstvideo.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgthread2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgtk3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedgtkx112.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedkrb5.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlcms2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedldlinux.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibasound.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibbsd.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibc.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibcmusl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibcrypt.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibcups.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibdl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibdrm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibdrmamdgpu.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibegl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibform.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibformw.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibformw6.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibfuse.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibgl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibglu.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibglx.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibharfbuzz.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibibus.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibice.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibncurses.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibncurses6.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibncursesw.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibncursesw6.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibnuma.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibogg.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibpanel.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibpci.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibpcre.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibpthread.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibresolv.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibrt.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibsm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibsndfile.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibssl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibssl3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibtinfo.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibtinfo6.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibusb1.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibuuid.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibva.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibvadrm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibvawayland.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibvax11.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibvdpau.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibvorbis.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibx11.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibx11xcb.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxau.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxaw.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcb.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbcursor.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbdri2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbdri3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbglx.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbkeysyms.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbicccm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbimage.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbpresent.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbrandr.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbrender.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbrenderutil.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbres.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbshape.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbshm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbsync.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbutil.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbxinerama.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbxinput.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbxfixes.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbxkb.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcbxtest.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcomposite.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxcursor.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxdamage.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxdmcp.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxext.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxfixes.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxft.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxi.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxmu.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxpm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxpresent.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxrandr.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxrender.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxss.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxt.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxtst.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibxxf86vm.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibz.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlzma.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedmpg123.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappednotify.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappednsl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappednspr4.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappednss3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappednssutil3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedopenal.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedopencl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpango.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpangocairo.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpangoft2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpam.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedplc4.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedplds4.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpng16.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpulse.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpulsemainloopglib.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpulsesimple.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl1.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl1image.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl1mixer.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl1net.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl1sound.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl1ttf.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsecret1.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsoftokn3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsmpeg.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl2image.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl2mixer.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl2net.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsdl2ttf.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedselinux.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsmime3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedsmpeg2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedssl3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedtbbbind.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedtbbmalloc.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedtbbmallocproxy.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedtcmallocminimal.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedudev0.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedudev1.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedunwind.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedutil.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedvorbisfile.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedwaylandclient.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedwaylandcursor.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedwaylandegl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxinerama.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxkbcommon.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxkbcommonx11.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxkbregistry.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxml2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxslt.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedldapr.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlber.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedvulkan.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedxshmfence.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedd3dadapter9.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc64.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n64.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc66.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n66.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc67.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n67.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc72.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n72.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc73.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n73.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc74.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n74.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicuuc75.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedicui18n75.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedidn2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedanl.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedpsl5.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibssh2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedp11kit.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibtasn1.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibnettle8.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibunistring2.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibhogweed6.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibsqlite3.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedlibtiff5.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedbrotlidec.c\"\n    \"${BOX64_ROOT}/src/wrapped/wrappedzstd.c\"\n)\nendif()\nif(ANDROID)\n    list(APPEND WRAPPEDS\n        \"${BOX64_ROOT}/src/wrapped/wrappedandroidshmem.c\"\n    )\nendif()\nif(TERMUX)\n    list(APPEND WRAPPEDS\n        \"${BOX64_ROOT}/src/wrapped/wrappediconv.c\"\n        \"${BOX64_ROOT}/src/wrapped/wrappedtermuxexec.c\"\n        \"${BOX64_ROOT}/src/wrapped/wrappedandroidsupport.c\"\n    )\nendif()\n\n# If BOX64_ROOT contains a \".c\", the build breaks...\nstring(REPLACE \".c\" \"_private.h\" MODROOT ${BOX64_ROOT})\nset(WRAPPEDS_HEAD \"${BOX64_ROOT}/src/wrapped/wrappedd3dadapter9_genvate.h\")\nforeach(A ${WRAPPEDS})\n    string(REPLACE \".c\" \"_private.h\" C ${A})\n    string(REPLACE \"${MODROOT}\" \"${BOX64_ROOT}\" B ${C})\n    set(WRAPPEDS_HEAD ${WRAPPEDS_HEAD} ${B})\n    set_source_files_properties(${A} PROPERTIES OBJECT_DEPENDS ${B})\nendforeach()\n\n\nset(WRAPPER \"${BOX64_ROOT}/src/wrapped/generated/wrapper.c\" \"${BOX64_ROOT}/src/wrapped/generated/wrapper.h\")\n\nif(NOT CI)\n    add_custom_command(\n        OUTPUT \"${BOX64_ROOT}/src/wrapped/generated/functions_list.txt\"\n        COMMAND \"${PYTHON_EXECUTABLE}\" \"${BOX64_ROOT}/rebuild_wrappers.py\"\n        \"${BOX64_ROOT}\"\n        \"PANDORA\" \"HAVE_LD80BITS\" \"NOALIGN\" \"HAVE_TRACE\" \"ANDROID\" \"TERMUX\" \"STATICBUILD\" \"LA64\" \"--\"\n        ${WRAPPEDS_HEAD}\n        MAIN_DEPENDENCY \"${BOX64_ROOT}/rebuild_wrappers.py\"\n        DEPENDS ${WRAPPEDS} ${WRAPPEDS_HEAD}\n        BYPRODUCTS ${WRAPPER}\n    )\nendif ()\n\n#add_custom_command(\n#    OUTPUT \"${BOX64_ROOT}/src/dynarec/last_run.txt\"\n#    COMMAND \"${PYTHON_EXECUTABLE}\" \"${BOX64_ROOT}/rebuild_printer.py\" \"${BOX64_ROOT}\"\n#    MAIN_DEPENDENCY \"${BOX64_ROOT}/rebuild_printer.py\"\n#    DEPENDS \"${BOX64_ROOT}/src/dynarec/arm64_instructions.txt\"\n#    BYPRODUCTS \"${BOX64_ROOT}/src/dynarec/arm64_printer.c\"\n#)\n\nadd_custom_target(WRAPPERS DEPENDS \"${BOX64_ROOT}/src/wrapped/generated/functions_list.txt\")\n#add_custom_target(PRINTER DEPENDS \"${BOX64_ROOT}/src/dynarec/last_run.txt\")\n\nif(BOX32)\n    if(STATICBUILD)\n    set(WRAPPEDS32\n        \"${BOX64_ROOT}/src/wrapped32/wrappedldlinux.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibc.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibdl.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibm.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibpthread.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibrt.c\"\n    )\n    else()\n    set(WRAPPEDS32\n        \"${BOX64_ROOT}/src/wrapped32/wrappedldlinux.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibc.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibdl.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibm.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibpthread.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibrt.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibresolv.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedcrashhandler.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibgl.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibglu.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedsdl1.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedsdl2.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedsdl2image.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibasound.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedopenal.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedfreetype.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedfontconfig.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibx11.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxdamage.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxext.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxfixes.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxrender.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxi.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxcomposite.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxcursor.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxrandr.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxss.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxxf86vm.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedxinerama.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedexpat.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibx11xcb.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxcb.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibxcbres.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedudev0.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedudev1.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibuuid.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedtcmallocminimal.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedcairo.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibdrm.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappedlibvdpau.c\"\n        \"${BOX64_ROOT}/src/wrapped32/wrappednsl.c\"\n    )\n    endif()\n    string(REPLACE \".c\" \"_private.h\" MODROOT ${BOX64_ROOT})\n    #set(WRAPPEDS32_HEAD \"${BOX64_ROOT}/src/wrapped/wrappedd3dadapter9_genvate.h\")\n    foreach(A ${WRAPPEDS32})\n        string(REPLACE \".c\" \"_private.h\" C ${A})\n        string(REPLACE \"${MODROOT}\" \"${BOX64_ROOT}\" B ${C})\n        set(WRAPPEDS32_HEAD ${WRAPPEDS32_HEAD} ${B})\n        set_source_files_properties(${A} PROPERTIES OBJECT_DEPENDS ${B})\n    endforeach()\n    \n    set(WRAPPER32 \"${BOX64_ROOT}/src/wrapped32/generated/wrapper32.c\" \"${BOX64_ROOT}/src/wrapped32/generated/wrapper32.h\")\n\n    if(NOT CI)\n        add_custom_command(\n            OUTPUT \"${BOX64_ROOT}/src/wrapped32/generated/functions_list.txt\"\n            COMMAND \"${PYTHON_EXECUTABLE}\" \"${BOX64_ROOT}/rebuild_wrappers_32.py\"\n            \"${BOX64_ROOT}\"\n            \"PANDORA\" \"HAVE_LD80BITS\" \"NOALIGN\" \"HAVE_TRACE\" \"ANDROID\" \"TERMUX\" \"STATICBUILD\" \"--\"\n            ${WRAPPEDS32_HEAD}\n            MAIN_DEPENDENCY \"${BOX64_ROOT}/rebuild_wrappers_32.py\"\n            DEPENDS ${WRAPPEDS32} ${WRAPPEDS32_HEAD}\n            BYPRODUCTS ${WRAPPER32}\n        )\n    endif()\n\n    add_custom_target(WRAPPERS32 DEPENDS \"${BOX64_ROOT}/src/wrapped32/generated/functions_list.txt\")\nelse()\n    set(WRAPPEDS32)\nendif()\n\n\nif(DYNAREC)\n    set(DYNAREC_SRC\n        \"${BOX64_ROOT}/src/dynarec/dynablock.c\"\n        \"${BOX64_ROOT}/src/dynarec/dynarec_native.c\"\n        \"${BOX64_ROOT}/src/dynarec/dynarec_native_functions.c\"\n        \"${BOX64_ROOT}/src/emu/x64test.c\"\n    )\nendif()\n\nif(ARM_DYNAREC)\n    set(DYNAREC_SRC\n        ${DYNAREC_SRC}\n\n        \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_functions.c\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_arch.c\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/arm64_immenc.c\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/arm64_printer.c\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_jmpnext.c\"\n\n        \"${BOX64_ROOT}/src/dynarec/arm64/arm64_prolog.S\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/arm64_epilog.S\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/arm64_next.S\"\n        \"${BOX64_ROOT}/src/dynarec/arm64/arm64_lock.S\"\n    )\n\n    set(DYNAREC_PASS\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_helper.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_emit_tests.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_emit_math.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_emit_logic.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_emit_shift.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_00.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_64.c\"\n    #\"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_65.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_66.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_67.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_67_32.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_67_avx.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_6764_32.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_d8.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_d9.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_da.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_db.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_dc.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_dd.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_de.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_df.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_f0.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_660f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_66f20f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_66f30f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_6664.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_66f0.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_f20f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_f30f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_0f38.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_66_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_f2_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_f3_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_66_0f38.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_66_0f3a.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_f2_0f38.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_f2_0f3a.c\"\n    \"${BOX64_ROOT}/src/dynarec/arm64/dynarec_arm64_avx_f3_0f38.c\"\n    )\nendif()\n\nif(RV64_DYNAREC)\n    set(DYNAREC_SRC\n        ${DYNAREC_SRC}\n\n        \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_functions.c\"\n        \"${BOX64_ROOT}/src/dynarec/rv64/rv64_printer.c\"\n        \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_jmpnext.c\"\n        \"${BOX64_ROOT}/src/rv64detect.c\"\n\n        \"${BOX64_ROOT}/src/dynarec/rv64/rv64_prolog.S\"\n        \"${BOX64_ROOT}/src/dynarec/rv64/rv64_epilog.S\"\n        \"${BOX64_ROOT}/src/dynarec/rv64/rv64_next.S\"\n        \"${BOX64_ROOT}/src/dynarec/rv64/rv64_lock.S\"\n    )\n\n    set(DYNAREC_PASS\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_helper.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_emit_tests.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_emit_math.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_emit_logic.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_emit_shift.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_00.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_00_0.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_00_1.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_00_2.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_00_3.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_0f_vector.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_64.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_64_vector.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_66.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_67.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_67_vector.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_67_32.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_d8.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_d9.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_da.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_db.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_dc.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_dd.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_de.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_df.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_f0.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_660f.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_660f38.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_660f_vector.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_66f20f.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_66f30f.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_6664.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_66f0.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_f20f.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_f20f_vector.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_f30f.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_f30f_vector.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_avx.c\"\n    \"${BOX64_ROOT}/src/dynarec/rv64/dynarec_rv64_avx_f3_0f.c\"\n    )\nendif()\n\nif(LARCH64_DYNAREC)\n    set(DYNAREC_SRC\n        ${DYNAREC_SRC}\n\n        \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_functions.c\"\n        \"${BOX64_ROOT}/src/dynarec/la64/la64_printer.c\"\n        \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_jmpnext.c\"\n\n        \"${BOX64_ROOT}/src/dynarec/la64/la64_prolog.S\"\n        \"${BOX64_ROOT}/src/dynarec/la64/la64_epilog.S\"\n        \"${BOX64_ROOT}/src/dynarec/la64/la64_next.S\"\n        \"${BOX64_ROOT}/src/dynarec/la64/la64_lock.S\"\n    )\n\n    set(DYNAREC_PASS\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_helper.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_emit_tests.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_emit_math.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_emit_shift.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_emit_logic.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_00.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_0f.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_64.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_66.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_6664.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_67.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_f30f.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_660f.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_f0.c\"\n    \"${BOX64_ROOT}/src/dynarec/la64/dynarec_la64_f20f.c\"\n    )\nendif()\n\n\nif(GDBJIT)\nset(GDBJITREADER \"${BOX64_ROOT}/gdbjit/reader.c\")\nendif()\n\nif(DYNAREC)\n    set(DYNAREC_PASS\n        \"${BOX64_ROOT}/src/wrapped/generated/wrapper.h\"\n        ${DYNAREC_PASS}\n        \"${BOX64_ROOT}/src/dynarec/dynarec_native_pass.c\"\n    )\n    if(BOX32)\n        list(APPEND DYNAREC_PASS\n            \"${BOX64_ROOT}/src/wrapped32/generated/wrapper32.h\"\n        )\n    endif()\n\n    add_library(dynarec_native OBJECT ${DYNAREC_SRC})\n\n    add_library(native_pass0 OBJECT ${DYNAREC_PASS})\n    set_target_properties(native_pass0 PROPERTIES COMPILE_FLAGS \"-DSTEP=0\")\n    add_library(native_pass1 OBJECT ${DYNAREC_PASS})\n    set_target_properties(native_pass1 PROPERTIES COMPILE_FLAGS \"-DSTEP=1\")\n    add_library(native_pass2 OBJECT ${DYNAREC_PASS})\n    set_target_properties(native_pass2 PROPERTIES COMPILE_FLAGS \"-DSTEP=2\")\n    add_library(native_pass3 OBJECT ${DYNAREC_PASS})\n    set_target_properties(native_pass3 PROPERTIES COMPILE_FLAGS \"-DSTEP=3\")\n    add_library(test_interpreter OBJECT ${INTERPRETER})\n    set_target_properties(test_interpreter PROPERTIES COMPILE_FLAGS \"-DTEST_INTERPRETER\")\n    add_dependencies(native_pass0 WRAPPERS)\n    add_dependencies(native_pass1 WRAPPERS)\n    add_dependencies(native_pass2 WRAPPERS)\n    add_dependencies(native_pass3 WRAPPERS)\n    if(BOX32)\n        add_dependencies(native_pass0 WRAPPERS32)\n        add_dependencies(native_pass1 WRAPPERS32)\n        add_dependencies(native_pass2 WRAPPERS32)\n        add_dependencies(native_pass3 WRAPPERS32)\n    endif()\n\n    add_library(dynarec STATIC\n        $<TARGET_OBJECTS:dynarec_native>\n        $<TARGET_OBJECTS:native_pass0>\n        $<TARGET_OBJECTS:native_pass1>\n        $<TARGET_OBJECTS:native_pass2>\n        $<TARGET_OBJECTS:native_pass3>\n        $<TARGET_OBJECTS:test_interpreter>\n    )\n\n    if(GDBJIT)\n        add_library(box64gdbjitreader SHARED ${GDBJITREADER})\n    endif()\nendif()\n\n# creates git_head.h\nif(DYNAREC)\n    add_custom_command(\n        OUTPUT \"${BOX64_ROOT}/src/git_head.h\"\n        COMMAND sh -c \"echo \\\\\\#define GITREV \\\\\\\"$(git rev-parse --short HEAD)\\\\\\\">\\\"${BOX64_ROOT}/src/git_head.h\\\"\"\n        DEPENDS dynarec ${ELFLOADER_SRC} ${INTERPRETER} ${WRAPPEDS} ${WRAPPEDS32}\n        VERBATIM)\nelse()\n    add_custom_command(\n        OUTPUT \"${BOX64_ROOT}/src/git_head.h\"\n        COMMAND sh -c \"echo \\\\\\#define GITREV \\\\\\\"$(git rev-parse --short HEAD)\\\\\\\">\\\"${BOX64_ROOT}/src/git_head.h\\\"\"\n        DEPENDS ${ELFLOADER_SRC} ${INTERPRETER} ${WRAPPEDS} ${WRAPPEDS32}\n        VERBATIM)\nendif()\n\nadd_library(interpreter OBJECT ${INTERPRETER})\n\nadd_executable(${BOX64} ${ELFLOADER_SRC} ${WRAPPEDS} ${WRAPPEDS32} \"${BOX64_ROOT}/src/git_head.h\")\nset_target_properties(${BOX64} PROPERTIES ENABLE_EXPORTS ON)\nadd_dependencies(${BOX64} WRAPPERS)\nif(BOX32)\n    add_dependencies(${BOX64} WRAPPERS32)\nendif()\n#add_dependencies(${BOX64} PRINTER)\n#target_link_libraries(${BOX64} c m dl rt pthread resolv)\nif(STATICBUILD)\n    #set_target_properties(${BOX64} PROPERTIES LINK_FLAGS \"-fuse-ld=gold -static -Wl,--no-relax -Wl,--allow-multiple-definition -ldl -lrt -lpthread -lresolv -lc -lutil -lm -Wl,-defsym,_DYNAMIC=0 -pthread\")\n    target_link_libraries(${BOX64} c m dl pthread resolv util c)\nelse()\n    if(ANDROID)\n        if(TERMUX)\n        target_link_libraries(${BOX64} c m dl android-sysv-semaphore)\n        else()\n        target_link_libraries(${BOX64} c m dl)\n        endif()\n    else()\n\t    set_property(TARGET ${BOX64} APPEND_STRING PROPERTY LINK_FLAGS \"-Wl,--no-as-needed -lc -lm -ldl -lrt -lpthread -lresolv -lutil -Wl,--as-needed -pthread \")\n    endif()\nendif()\nif(DYNAREC)\n    target_link_libraries(${BOX64} dynarec)\nendif()\ntarget_link_libraries(${BOX64} interpreter)\n\nif(${CMAKE_VERSION} VERSION_LESS \"3.13\")\n    if(NOT NOLOADADDR)\n        if(CMAKE_C_COMPILER_ID STREQUAL \"Clang\" OR WITH_MOLD)\n            set_property(TARGET ${BOX64} APPEND_STRING PROPERTY LINK_FLAGS \"-no-pie -Wl,--image-base=${BOX64_ELF_ADDRESS} \")\n        else()\n            set_property(TARGET ${BOX64} APPEND_STRING PROPERTY LINK_FLAGS \"-Wl,-Ttext-segment,${BOX64_ELF_ADDRESS} \")\n        endif()\n    endif()\nelse()\n    # If symbols are missing, try this: target_link_options(${BOX64} PUBLIC -rdynamic)\n    if(NOT NOLOADADDR)\n        if(CMAKE_C_COMPILER_ID STREQUAL \"Clang\" OR WITH_MOLD)\n            if(WITH_MOLD) # --image-base requires -no-pie in mold!\n                set_property(TARGET ${BOX64} APPEND_STRING PROPERTY LINK_FLAGS \"-no-pie -lm \")\n            endif()\n            target_link_options(${BOX64} PUBLIC LINKER:--image-base=${BOX64_ELF_ADDRESS})\n        else()\n            target_link_options(${BOX64} PUBLIC LINKER:-Ttext-segment,${BOX64_ELF_ADDRESS})\n        endif()\n    endif()\nendif()\n\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"i686\"  _x86)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"x86_64\"  _x86_64)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"aarch64\"  _aarch64)\nstring(COMPARE EQUAL \"${CMAKE_SYSTEM_PROCESSOR}\" \"riscv64\"  _riscv64)\n\nif(_x86_64 OR _aarch64)\n  add_definitions(-DCONFIG_64BIT)\nendif()\n\nif(NOT _x86 AND NOT _x86_64)\n  if(NOT TERMUX)\n   install(TARGETS ${BOX64} RUNTIME DESTINATION bin)\n   if(NOT NO_LIB_INSTALL)\n    install(PROGRAMS ${CMAKE_SOURCE_DIR}/tests/box64-bash DESTINATION bin)\n   endif()\n  else()\n   install(TARGETS ${BOX64} RUNTIME DESTINATION ${TERMUX_PATH}/usr/bin)\n   if(NOT NO_LIB_INSTALL)\n    install(PROGRAMS ${CMAKE_SOURCE_DIR}/tests/box64-bash DESTINATION ${TERMUX_PATH}/usr/bin)\n   endif()\n  endif()\n  if (GDBJIT)\n    install(TARGETS box64gdbjitreader RUNTIME DESTINATION lib)\n  endif()\n  if(NOT NO_CONF_INSTALL)\n    configure_file(system/box64.conf.cmake system/box64.conf)\n\t  if(NOT TERMUX)\n        install(FILES ${CMAKE_BINARY_DIR}/system/box64.conf DESTINATION /etc/binfmt.d/)\n        install(FILES ${CMAKE_SOURCE_DIR}/system/box64.box64rc DESTINATION /etc/)\n        if(BOX32_BINFMT)\n            configure_file(system/box32.conf.cmake system/box32.conf)\n            install(FILES ${CMAKE_BINARY_DIR}/system/box32.conf DESTINATION /etc/binfmt.d/)\n        endif()\n      else()\n        install(FILES ${CMAKE_BINARY_DIR}/system/box64.conf DESTINATION ${TERMUX_PATH}/usr/etc/binfmt.d/)\n        install(FILES ${CMAKE_SOURCE_DIR}/system/box64.box64rc DESTINATION ${TERMUX_PATH}/usr/etc/)\n        if(BOX32_BINFMT)\n            configure_file(system/box32.conf.cmake system/box32.conf)\n            install(FILES ${CMAKE_BINARY_DIR}/system/box32.conf DESTINATION ${TERMUX_PATH}/usr/etc/binfmt.d/)\n        endif()\n\t  endif()\n\n  endif()\n  set(INSTALL_PATH \"/usr/lib/box64-x86_64-linux-gnu/\")\n  if(NOT NO_LIB_INSTALL)\n\tif(NOT TERMUX AND NOT ANDROID)\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libstdc++.so.5 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libstdc++.so.6 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libgcc_s.so.1 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libpng12.so.0 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libcrypto.so.1.1 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libcrypto.so.1.0.0 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libssl.so.1.1 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libssl.so.1.0.0 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libunwind.so.8 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedx509.so.1 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedx509.so.0 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedtls.so.14 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedtls.so.12 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedcrypto.so.7 DESTINATION ${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedcrypto.so.3 DESTINATION ${INSTALL_PATH})\n\telseif(TERMUX)\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libstdc++.so.5 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libstdc++.so.6 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libgcc_s.so.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libpng12.so.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libcrypto.so.1.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libcrypto.so.1.0.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libssl.so.1.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libssl.so.1.0.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libunwind.so.8 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedx509.so.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedx509.so.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedtls.so.14 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedtls.so.12 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedcrypto.so.7 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        install(FILES ${CMAKE_SOURCE_DIR}/x64lib/libmbedcrypto.so.3 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n    elseif(ANDROID)\n    install(FILES ${CMAKE_SOURCE_DIR}/x64android/libc++_shared.so DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n\tendif()\n   endif()\n   if(BOX32)\n    set(INSTALL_PATH \"/usr/lib/box64-i386-linux-gnu/\")\n    if(NOT NO_LIB_INSTALL)\n    \tif(NOT TERMUX AND NOT ANDROID)\n    \t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.5 DESTINATION ${INSTALL_PATH})\n    \t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.6 DESTINATION ${INSTALL_PATH})\n    \t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libgcc_s.so.1 DESTINATION ${INSTALL_PATH})\n    \t\tinstall(FILES ${CMAKE_SOURCE_DIR}/x86lib/libpng12.so.0 DESTINATION ${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libunwind.so.8 DESTINATION ${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libcrypto.so.1.0.0 DESTINATION ${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libssl.so.1.0.0 DESTINATION ${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libz.so.1 DESTINATION ${INSTALL_PATH})\n        elseif(TERMUX)\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.5 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libstdc++.so.6 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libgcc_s.so.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libpng12.so.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libunwind.so.8 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libcrypto.so.1.0.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libssl.so.1.0.0 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n            install(FILES ${CMAKE_SOURCE_DIR}/x86lib/libz.so.1 DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n        elseif(ANDROID)\n            install(FILES ${CMAKE_SOURCE_DIR}/x86android/libc++_shared.so DESTINATION ${TERMUX_PATH}${INSTALL_PATH})\n       endif()\n    endif()\n  endif()\nendif()\n\nif(NOT TARGET uninstall)\n    configure_file(\n        \"${CMAKE_CURRENT_SOURCE_DIR}/cmake_uninstall.cmake.in\"\n        \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n        IMMEDIATE @ONLY)\n\n    add_custom_target(uninstall\n        COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\nendif()\n\nset(CPACK_GENERATOR \"DEB\")\nset(CPACK_DEBIAN_PACKAGE_MAINTAINER \"ptitSeb\")\nset(CPACK_PACKAGE_CONTACT \"ptitSeb@box86.org\")\nset(CPACK_PACKAGE_DESCRIPTION \"Box64 - Linux Userspace x86_64 Emulator with a twist\")\nif(NOT TERMUX)\n\tset(CPACK_DEBIAN_PACKAGE_DEPENDS \"libc6\")\nelse()\n\tset(CPACK_DEBIAN_PACKAGE_DEPENDS \"libandroid-sysv-semaphore\")\nendif()\nset(CPACK_PACKAGE_HOMEPAGE_URL, \"https://box86.org\")\nfile(STRINGS \"${BOX64_ROOT}/src/box64version.h\" TEMP_STRING REGEX \"BOX64_MAJOR\\\\s*\")\nstring(REGEX REPLACE \"BOX64_MAJOR\" \"\" TEMP_STRING ${TEMP_STRING})\nstring(REGEX MATCH \"[0-9]\" BOX64_MAJOR ${TEMP_STRING})\nfile(STRINGS \"${BOX64_ROOT}/src/box64version.h\" TEMP_STRING REGEX \"BOX64_MINOR\\\\s*\")\nstring(REGEX REPLACE \"BOX64_MINOR\" \"\" TEMP_STRING ${TEMP_STRING})\nstring(REGEX MATCH \"[0-9]\" BOX64_MINOR ${TEMP_STRING})\nfile(STRINGS \"${BOX64_ROOT}/src/box64version.h\" TEMP_STRING REGEX \"BOX64_REVISION\\\\s*\")\nstring(REGEX REPLACE \"BOX64_REVISION\" \"\" TEMP_STRING ${TEMP_STRING})\nstring(REGEX MATCH \"[0-9]\" BOX64_REVISION ${TEMP_STRING})\nset(CPACK_PACKAGE_VERSION_MAJOR ${BOX64_MAJOR})\nset(CPACK_PACKAGE_VERSION_MINOR ${BOX64_MINOR})\nset(CPACK_PACKAGE_VERSION_PATCH ${BOX64_REVISION})\nif(NOT TERMUX)\nset(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA \"${CMAKE_CURRENT_SOURCE_DIR}/postinst\")\nendif()\nif(_aarch64)\n\tif(TERMUX)\n\t\tset(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"aarch64\")\n\telse()\n    \t\tset(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"arm64\")\n\tendif()\nelseif(__riscv64)\n    set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"riscv64\")\nelseif(_x86_64)\n    set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE \"x86_64\")\nelse()\n    #probably wrong...\n    execute_process(COMMAND \"dpkg --print-architecture\" OUTPUT_VARIABLE CPACK_DEBIAN_PACKAGE_ARCHITECTURE)\nendif()\nif(TERMUX)\nset(CPACK_PACKAGING_INSTALL_PREFIX \"${TERMUX_PATH}/usr\")\nendif()\nif(NOT TERMUX)\nset(CPACK_DEBIAN_FILE_NAME \"${BOX64}-${BOX64_MAJOR}.${BOX64_MINOR}.${BOX64_REVISION}_${CMAKE_SYSTEM_NAME}-${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}.deb\")\nelse()\nset(CPACK_DEBIAN_FILE_NAME \"${BOX64}-${BOX64_MAJOR}.${BOX64_MINOR}.${BOX64_REVISION}_Termux-${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}.deb\")\nendif()\nINCLUDE(CPack)\n\nif(NOT ANDROID)\nadd_test(bootSyscall ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test01 -D TEST_OUTPUT=tmpfile01.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref01.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(bootSyscallC ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test02 -D TEST_OUTPUT=tmpfile02.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref02.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(printf ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test03 -D TEST_OUTPUT=tmpfile03.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref03.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(args ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test04 -D TEST_ARGS2=yeah -D TEST_OUTPUT=tmpfile04.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref04.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(maths1 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test05 -D TEST_ARGS2=7 -D TEST_OUTPUT=tmpfile05.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref05.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(threadsStart ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test06 -D TEST_OUTPUT=tmpfile06.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref06.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(trig ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test07 -D TEST_OUTPUT=tmpfile07.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref07.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(pi ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test08 -D TEST_OUTPUT=tmpfile08.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref08.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(fork ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test09 -D TEST_OUTPUT=tmpfile09.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref09.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(cppThreads_nocosim ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test10 -D TEST_OUTPUT=tmpfile10.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref10.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(cppThreads_nocosim PROPERTIES ENVIRONMENT \"BOX64_LD_LIBRARY_PATH=${CMAKE_SOURCE_DIR}/x64lib\")\n\nadd_test(tlsData ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test11 -D TEST_OUTPUT=tmpfile11.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref11.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(fpu ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test12 -D TEST_OUTPUT=tmpfile12.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref12.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(contexts ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test13 -D TEST_OUTPUT=tmpfile13.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref13.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n#add_test(conditionalThreads ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n#    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test14 -D TEST_OUTPUT=tmpfile14.txt\n#    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref14.txt\n#    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(linkingIndirectNoversion ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test15 -D TEST_OUTPUT=tmpfile15.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref15.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(sse_asm ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test16 -D TEST_OUTPUT=tmpfile16.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref16.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(sse_asm PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTROUND=0\")\n\nadd_test(sse_intrinsics ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test17 -D TEST_OUTPUT=tmpfile17.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref17.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(sse_intrinsics PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTNAN=0;BOX64_DYNAREC_FASTROUND=0\")\n\nadd_test(aes ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test18 -D TEST_OUTPUT=tmpfile18.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref18.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(backtrace ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test19 -D TEST_OUTPUT=tmpfile19.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref19.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(irelative_reloc ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test20 -D TEST_OUTPUT=tmpfile20.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref20.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(longjumpInSignals ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test21 -D TEST_OUTPUT=tmpfile21.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref21.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(x87 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test22 -D TEST_OUTPUT=tmpfile22.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref22.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(x87 PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTROUND=0\")\n\nadd_test(pshufb ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test23 -D TEST_OUTPUT=tmpfile23.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref23.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(bswap ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test24 -D TEST_OUTPUT=tmpfile24.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref24.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(x87cache ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test25 -D TEST_OUTPUT=tmpfile25.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref25.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(feround ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test26 -D TEST_OUTPUT=tmpfile26.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref26.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\nset_tests_properties(feround PROPERTIES ENVIRONMENT \"BOX64_SYNC_ROUNDING=1\")\n\nadd_test(sse4_2 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test27 -D TEST_OUTPUT=tmpfile27.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref27.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(shaext ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test28 -D TEST_OUTPUT=tmpfile28.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref28.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(lock ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test29 -D TEST_OUTPUT=tmpfile29.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref29.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(avx_intrinsics ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test30 -D TEST_OUTPUT=tmpfile30.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref30.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(avx_intrinsics PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTNAN=0;BOX64_DYNAREC_FASTROUND=0;BOX64_AVX=2\")\n\nadd_test(fpu_rounding ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test31 -D TEST_OUTPUT=tmpfile31.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref31.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nif(ARM_DYNAREC)\nset_tests_properties(fpu_rounding PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTROUND=0;BOX64_DYNAREC_TEST=1\")\nelse()\nset_tests_properties(fpu_rounding PROPERTIES ENVIRONMENT \"BOX64_DYNAREC=0\")\nendif()\n\nelse()\n\nadd_test(bootSyscall ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test01_android -D TEST_OUTPUT=tmpfile01.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref01.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(bootSyscallC ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test02_android -D TEST_OUTPUT=tmpfile02.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref02.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(printf ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test03_android -D TEST_OUTPUT=tmpfile03.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref03.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(args ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test04_android -D TEST_ARGS2=yeah -D TEST_OUTPUT=tmpfile04.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref04.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(maths1 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test05_android -D TEST_ARGS2=7 -D TEST_OUTPUT=tmpfile05.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref05.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(threadsStart ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test06_android -D TEST_OUTPUT=tmpfile06.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref06.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(trig ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test07_android -D TEST_OUTPUT=tmpfile07.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref07.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(pi ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test08_android -D TEST_OUTPUT=tmpfile08.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref08.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(fork ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test09_android -D TEST_OUTPUT=tmpfile09.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref09.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(fpu ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test12_android -D TEST_OUTPUT=tmpfile12.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref12_android.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(linkingIndirectNoversion ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test15_android -D TEST_OUTPUT=tmpfile15.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref15.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n# Box64 for Android now have problems with test16, then disable it for now\n\n#add_test(sse_asm ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n#    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test16_android -D TEST_OUTPUT=tmpfile16.txt\n#    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref16.txt\n#    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n# Box64 for Android now have problems with test17, then disable it for now\n\n#set_tests_properties(sse_asm PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTROUND=0\")\n\n#add_test(sse_intrinsics ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n#    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test17_android -D TEST_OUTPUT=tmpfile17.txt\n#    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref17_android.txt\n#    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n#set_tests_properties(sse_intrinsics PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTNAN=0;BOX64_DYNAREC_FASTROUND=0\")\n\nadd_test(aes ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test18_android -D TEST_OUTPUT=tmpfile18.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref18.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n# Android don't have backtrace symbols\n\nadd_test(irelative_reloc ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test20_android -D TEST_OUTPUT=tmpfile20.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref20.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n# add_test(longjumpInSignals ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n#     -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test21_android -D TEST_OUTPUT=tmpfile21.txt\n#     -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref21.txt\n#     -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(x87 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test22_android -D TEST_OUTPUT=tmpfile22.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref22_android.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nset_tests_properties(x87 PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTROUND=0\")\n\nadd_test(pshufb ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test23_android -D TEST_OUTPUT=tmpfile23.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref23.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(bswap ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test24_android -D TEST_OUTPUT=tmpfile24.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref24.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(x87cache ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test25_android -D TEST_OUTPUT=tmpfile25.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref25.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(feround ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test26_android -D TEST_OUTPUT=tmpfile26.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref26.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\nset_tests_properties(feround PROPERTIES ENVIRONMENT \"BOX64_SYNC_ROUNDING=1\")\n\n# TODO: need to regen test with latest test27.c sources\n\n#add_test(sse4_2 ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n#    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test27_android -D TEST_OUTPUT=tmpfile27.txt\n#    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref27.txt\n#    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(shaext ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test28_android -D TEST_OUTPUT=tmpfile28.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref28.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\nadd_test(lock ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test29_android -D TEST_OUTPUT=tmpfile29.txt\n    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref29.txt\n    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n#add_test(avx_intrinsics ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n#    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/test30_android -D TEST_OUTPUT=tmpfile30.txt\n#    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/ref30.txt\n#    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n#\n#set_tests_properties(avx_intrinsics PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTNAN=0;BOX64_DYNAREC_FASTROUND=0 BOX64_AVX=2\")\n\n\nendif()\n\nif(NOT ANDROID)\nfile(GLOB extension_tests \"${CMAKE_SOURCE_DIR}/tests/extensions/*.c\")\nforeach(file ${extension_tests})\n    get_filename_component(testname \"${file}\" NAME_WE)\n    add_test(NAME \"${testname}\" COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/extensions/${testname} -D TEST_OUTPUT=tmpfile-${testname}.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/extensions/${testname}.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake)\nendforeach()\nelse()\n\nfile(GLOB extension_tests \"${CMAKE_SOURCE_DIR}/tests/extensions/*.c\")\nforeach(file ${extension_tests})\n    get_filename_component(testname \"${file}\" NAME_WE)\n    add_test(NAME \"${testname}\" COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests/extensions/${testname}_android -D TEST_OUTPUT=tmpfile-${testname}.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests/extensions/${testname}.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake)\nendforeach()\nendif()\n\nif(BOX32)\n    add_test(NAME bootSyscall_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test01 -D TEST_OUTPUT=tmpfile32_01.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref01.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME bootSyscallC_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test02 -D TEST_OUTPUT=tmpfile32_02.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref02.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME printf_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test03 -D TEST_OUTPUT=tmpfile32_03.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref03.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME args_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test04 -D TEST_ARGS2=yeah -D TEST_OUTPUT=tmpfile32_04.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref04.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME maths1_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test05 -D TEST_ARGS2=7 -D TEST_OUTPUT=tmpfile32_05.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref05.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME threadsStart_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test06 -D TEST_OUTPUT=tmpfile32_06.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref06.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME trig_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test07 -D TEST_OUTPUT=tmpfile32_07.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref07.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME pi_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test08 -D TEST_OUTPUT=tmpfile32_08.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref08.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME fork_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test09 -D TEST_OUTPUT=tmpfile32_09.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref09.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    if(NOT CI)\n    add_test(NAME cppThreads_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test10 -D TEST_OUTPUT=tmpfile32_10.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref10.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n    \n    set_tests_properties(cppThreads_32bits PROPERTIES ENVIRONMENT \"BOX64_LD_LIBRARY_PATH=${CMAKE_SOURCE_DIR}/x86lib\")\n    endif()\n\n    add_test(NAME tlsData_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test11 -D TEST_OUTPUT=tmpfile32_11.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref11.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME fpu_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test12 -D TEST_OUTPUT=tmpfile32_12.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref12.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME contexts_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test13 -D TEST_OUTPUT=tmpfile32_13.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref13.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    if(NOT LD80BITS)\n        add_test(NAME conditionalThreads_32bits_nocosim COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n            -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test14 -D TEST_OUTPUT=tmpfile32_14.txt\n            -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref14.txt\n            -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n    endif()\n\n    add_test(NAME linkingIndirectNoversion_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test15 -D TEST_OUTPUT=tmpfile32_15.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref15.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME linkingIndirectVersion_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test16 -D TEST_OUTPUT=tmpfile32_16.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref16.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME sse_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test17 -D TEST_OUTPUT=tmpfile32_17.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref17.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    set_tests_properties(sse_32bits PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTNAN=0;BOX64_DYNAREC_FASTROUND=0\")\n\n    add_test(NAME longjumpInSignals_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test18 -D TEST_OUTPUT=tmpfile32_18.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref18.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME x87_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test19 -D TEST_OUTPUT=tmpfile32_19.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref19.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    set_tests_properties(x87_32bits PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTROUND=0\")\n\n    add_test(NAME idiv_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test20 -D TEST_OUTPUT=tmpfile32_20.txt\n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref20.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    add_test(NAME multiple_dlopen_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64} \n        -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test21 -D TEST_OUTPUT=tmpfile32_21.txt \n        -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref21.txt\n        -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    file(GLOB extension_tests \"${CMAKE_SOURCE_DIR}/tests32/extensions/*.c\")\n    foreach(file ${extension_tests})\n        get_filename_component(testname \"${file}\" NAME_WE)\n        add_test(NAME \"${testname}_32bits\" COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n            -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/extensions/${testname} -D TEST_OUTPUT=tmpfile32_-${testname}.txt\n            -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/extensions/${testname}.txt\n            -P ${CMAKE_SOURCE_DIR}/runTest.cmake)\n    endforeach()\n\n    #add_test(NAME sse_optimized_32bits COMMAND ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64} \n    #    -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test17_o2 -D TEST_OUTPUT=tmpfile32_17_o2.txt \n    #    -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref17_o2.txt\n    #    -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\n\n    #set_tests_properties(sse_optimized_32bits PROPERTIES ENVIRONMENT \"BOX64_DYNAREC_FASTNAN=0;BOX64_DYNAREC_FASTROUND=0\")    \n        \n    add_test(bswap_32bits ${CMAKE_COMMAND} -D TEST_PROGRAM=${CMAKE_BINARY_DIR}/${BOX64}\n            -D TEST_ARGS=${CMAKE_SOURCE_DIR}/tests32/test23 -D TEST_OUTPUT=tmpfile32_23.txt\n            -D TEST_REFERENCE=${CMAKE_SOURCE_DIR}/tests32/ref23.txt\n            -P ${CMAKE_SOURCE_DIR}/runTest.cmake )\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0390625,
          "content": "MIT License\n\nCopyright (c) 2020 ptitSeb\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.0830078125,
          "content": "![Official logo](docs/img/Box64Logo.png \"Official Logo\")\r\n\r\n# Box64: Linux Userspace x86-64 Emulator with a Twist\r\n\r\n[Changelog](https://github.com/ptitSeb/box64/blob/main/docs/CHANGELOG.md) | [中文](https://github.com/ptitSeb/box64/blob/main/README_CN.md) | [Українська](https://github.com/ptitSeb/box64/blob/main/README_UK.md) | [Report an Error](https://github.com/ptitSeb/box64/issues/new)\r\n\r\n![Build Status](https://app.travis-ci.com/ptitSeb/box64.svg?branch=main) ![Stars](https://img.shields.io/github/stars/ptitSeb/box64) ![Forks](https://img.shields.io/github/forks/ptitSeb/box64) ![Contributors](https://img.shields.io/github/contributors/ptitSeb/box64) ![Pull Requests](https://img.shields.io/github/issues-pr/ptitSeb/box64) ![Issues](https://img.shields.io/github/issues/ptitSeb/box64)\r\n\r\n---\r\n\r\nBox64 enables running x86_64 Linux programs, including games, on non-x86_64 Linux systems such as Arm (64-bit little-endian host system required).\r\n\r\nCheck out Box64 in action on YouTube:\r\n- [MicroLinux](https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ)\r\n- [Pi Labs](https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g)\r\n- [The Byteman](https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA)\r\n\r\nBox64 leverages native system libraries (libc, libm, SDL, OpenGL), offering ease of integration and surprising performance in many applications. For performance benchmarks, check [this analysis](https://box86.org/index.php/2021/06/game-performances/).\r\n\r\nWith DynaRec for ARM64, RV64 and LA64 platforms, Box64 achieves a speed boost 5-10x faster than the interpreter alone. For a deeper look at DynaRec, see [Inner workings](https://box86.org/2021/07/inner-workings-a-high%e2%80%91level-view-of-box86-and-a-low%e2%80%91level-view-of-the-dynarec/).\r\n\r\n<img src=\"docs/img/Box64Icon.png\" width=\"96\" height=\"96\" alt=\"Box64 Icon\">\r\n\r\n_Logo and icon by @grayduck - Thank you!_\r\n\r\n---\r\n\r\n## 📖 Usage\r\n\r\nBox64 offers environment variables to control its behavior. For details, see [Usage Documentation](docs/USAGE.md).\r\n\r\n---\r\n\r\n## 🚀 Compiling and Installation\r\n\r\n- [Compilation Instructions](https://github.com/ptitSeb/box64/blob/main/docs/COMPILE.md)\r\n- [Wine Installation for Box64](https://github.com/ptitSeb/box64/blob/main/docs/X64WINE.md)\r\n\r\n---\r\n\r\n## 🔄 Version History\r\n\r\nSee the [Changelog](docs/CHANGELOG.md) for version updates.\r\n\r\n---\r\n\r\n## 🖥️ Platform Compatibility Notes\r\n\r\nBox64 requires 64-bit libraries on the host system, as it directly translates x86_64 function calls. For 32-bit binaries, use Box86.\r\n\r\n**Notes** \r\n\r\n1. Box32 mode is in the making, which aims to support 32-bit binaries on Box64, you can enable it at build time, but do not expect everything to work. There is actually a few things that work, many that don't. It's a known issue, no need to create tickets about it for now.\r\n2. Some installers may default to x86 on 64-bit host OSes, causing compatibility issues. Workaround: Use a fake `uname` that returns \"x86_64\" for `-m`.\r\n\r\n---\r\n\r\n## ⚙️ Configuration\r\n\r\nBox64 has configuration files located in `/etc/box64.box64rc` and `~/.box64rc`, both formatted as `.ini` files. If you don’t want to use the default `/etc/box64.box64rc` file, copy it to `~/.box64rc` to ensure compatibility.\r\n\r\nSettings priority: `~/.box64rc` > `/etc/box64.box64rc` > Command line.\r\n\r\n---\r\n\r\n## 📄 Additional Platform-Specific Notes\r\n\r\n### Unity Game Emulation\r\n\r\n- Many Unity games require OpenGL 3+, which may be challenging on ARM/RISC-V SBCs.\r\n- **Tip for Pi4 and Pi5 Users**: Set `MESA_GL_VERSION_OVERRIDE=3.2` with `BOX64_DYNAREC_STRONGMEM=1` to prevent freezes and enable strong memory mode.\r\n- **Using Panfrost**: For better compatibility on ARM, enable `PAN_MESA_DEBUG=gl3` to force higher OpenGL profiles. This can help if a game starts but quits unexpectedly before showing any content.\r\n\r\n### GTK Programs\r\n\r\nBox64 wraps GTK libraries, supporting both gtk2 and gtk3.\r\n\r\n### Steam\r\n\r\nSteam requires Box86 due to its 32-bit client app, but uses 64-bit local server binaries. Systems with less than 6GB RAM may need a swap file for optimal performance.\r\n\r\n### Wine\r\n\r\nBox64 supports Wine64 and Proton. For 32-bit components, Box86 is required. Systems with both Box64 and Box86 can run 32- and 64-bit Windows programs.\r\n\r\n**Note**: You can use Wine WOW64 build to run x86 Windows programs in Box64-only environments, this is still experimental, but it works in most cases.\r\n\r\n### Vulkan\r\n\r\nBox64 wraps Vulkan libraries.\r\n\r\n----\r\nFinal word\r\n----\r\n\r\nI want to thank everyone who has contributed to box64 development.\r\nThere are many ways to contribute: code contribution, financial, hardware and advertisement!\r\nSo, in no particular order, I want to thank:\r\n * For their major code contribution: rajdakin, mogery, ksco, xctan\r\n * For their major financial contribution: [Playtron](https://playtron.one), tohodakilla, FlyingFathead, stormchaser3000, dennis1248, sll00, [libre-computer-project](https://libre.computer/), [CubeCoders Limited](http://cubecoders.com/)\r\n * For hardware contribution and LoongArch migration: [xiaoji](https://www.linuxgame.cn/), Deepin Beijing Develop Team\r\n * For their hardware contribution: [ADLINK](https://www.adlinktech.com/Products/Computer_on_Modules/COM-HPC-Server-Carrier-and-Starter-Kit/Ampere_Altra_Developer_Platform?lang=en) with [Ampere](https://amperecomputing.com/home/edge), [SOPHGO](https://www.sophon.ai/), [Radxa](https://rockpi.org/), [StarFive](https://rvspace.org/), [Pine64](https://www.pine64.org/), [AYN](https://www.ayntec.com/), [AYANEO](https://ayaneo.com/), [jiangcuo](https://github.com/jiangcuo)\r\n * For their continuous advertisements for the box64 project: salva ([microLinux](https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ)), [PILab](https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g)/[TwisterOS](https://twisteros.com/) team, [The Byteman](https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA), [NicoD](https://www.youtube.com/channel/UCpv7NFr0-9AB5xoklh3Snhg), ekianjo ([Boilingsteam](https://boilingsteam.com/))\r\n\r\nAnd I also thank the many other people who participated even once in this project.\r\n\r\n(If you use Box64 in your project, please don't forget to mention it!)\r\n\r\n"
        },
        {
          "name": "README_CN.md",
          "type": "blob",
          "size": 5.7587890625,
          "content": "![图标](docs/img/Box64Logo.png \"图标\")\n\n# Box64：Linux 用户空间 x86-64 模拟器（支持原生库）\n\n[更新日志](https://github.com/ptitSeb/box64/blob/main/docs/CHANGELOG.md) | [English](https://github.com/ptitSeb/box64/blob/main/README.md) | [Українська](https://github.com/ptitSeb/box64/blob/main/README_UK.md) | [Report an Error](https://github.com/ptitSeb/box64/issues/new)\n\n![Build Status](https://app.travis-ci.com/ptitSeb/box64.svg?branch=main) ![Stars](https://img.shields.io/github/stars/ptitSeb/box64) ![Forks](https://img.shields.io/github/forks/ptitSeb/box64) ![Contributors](https://img.shields.io/github/contributors/ptitSeb/box64) ![Pull Requests](https://img.shields.io/github/issues-pr/ptitSeb/box64) ![Issues](https://img.shields.io/github/issues/ptitSeb/box64)\n\n---\n\nBox64 可以在非 x86_64 Linux 主机系统（比如 Arm）上运行 x86_64 Linux 程序（比如游戏），目前仅支持 64 位小端主机系统。\n\n在 YouTube 上查看 Box64 的运行效果:\n- [MicroLinux](https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ)\n- [Pi Labs](https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g)\n- [The Byteman](https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA)\n\nBox64 可以使用本机原生的系统库（libc、libm、SDL、OpenGL），有着易于集成的特性和令人惊讶的性能。如需性能基准测试，请查看[此分析](https://box86.org/index.php/2021/06/game-performances/)。\n\n借助适用于 ARM64，RV64 以及 LA64 平台的 DynaRec，Box64 的速度比单独使用解释器快 5-10 倍。如需深入了解 DynaRec，请参考[此文章](https://box86.org/2021/07/inner-workings-a-high%e2%80%91level-view-of-box86-and-a-low%e2%80%91level-view-of-the-dynarec/)。\n\n<img src=\"docs/img/Box64Icon.png\" width=\"96\" height=\"96\" alt=\"Box64 Icon\">\n\n_Logo 由 @grayduck 制作，感谢！_\n\n---\n\n## 📖 使用方法\n\nBox64 提供了环境变量来控制其行为。有关详细信息请参阅[使用文档](docs/USAGE.md)。\n\n---\n\n## 🚀 编译和安装\n\n- [编译说明](https://github.com/ptitSeb/box64/blob/main/docs/COMPILE.md)\n- [安装 Wine](https://github.com/ptitSeb/box64/blob/main/docs/X64WINE.md)\n\n---\n\n## 🔄 版本历史\n\n请参阅[变更日志](docs/CHANGELOG.md)了解版本更新说明。\n\n---\n\n## 🖥️ 平台兼容性说明\n\nBox64 直接转换 x86_64 函数调用到本机原生库，因此需要主机系统上的 64 位库。对于 32 位二进制文​​件，请使用 Box86。\n\n**注意事项**\n\n1. Box32 模式正在制作中，旨在支持 Box64 上运行 32 位二进制文​​件，敬请期待！\n2. 某些安装程序可能会将 64 位的主机操作系统判定为 x86 导致兼容性问题。解决方法：使用假的 `uname` ，并使它在运行参数为 `-m` 时返回 `x86_64`。\n\n---\n\n## ⚙️ 配置\n\nBox64 的配置文件位于 `/etc/box64.box64rc` 和 `~/.box64rc`，均为 `.ini` 格式的文件。如果您不想使用默认的 `/etc/box64.box64rc` 文件，请将其复制到 `~/.box64rc` 以确保兼容性。\n\n配置项的优先级：`~/.box64rc` > `/etc/box64.box64rc` > 命令行。\n\n---\n\n## 📄 特定平台的其他说明\n\n### Unity 游戏\n- 许多 Unity 游戏需要 OpenGL 3+，这对 ARM/RISC-V SBC 来说可能具有挑战性。\n- **对 Pi4 和 Pi5 用户的提示**：设置 `MESA_GL_VERSION_OVERRIDE=3.2` 和 `BOX64_DYNAREC_STRONGMEM=1` 以防止卡死并启用强内存模式。\n- **Panfrost**：为了在 ARM 上实现更好的兼容性，启用 `PAN_MESA_DEBUG=gl3` 以强制更高的 OpenGL Profile。如果游戏可以启动但在显示任何内容之前意外退出，这个设置可能会有所帮助。\n\n### GTK 程序\n\nBox64 包装了 GTK 库，支持 gtk2 和 gtk3。\n\n### Steam\n\n由于 Steam 客户端应用是 32 位的，需要使用 Box86，但其本地服务器是 64 位的二进制文件。对于内存少于 6GB 的系统，可能需要使用交换文件以获得最佳性能。\n\n### Wine\n\nBox64 支持 Wine64 和 Proton。对于 32 位组件，需要 Box86。配备 Box64 和 Box86 的系统可以运行 32 位和 64 位的 Windows 程序。\n\n**提示**：您可以使用 Wine WOW64 版本在仅限 Box64 的环境中运行 x86 Windows 程序，这项支持仍处于实验阶段，但在大多数情况下都可以工作。\n\n### Vulkan\n\nBox64 包装了 Vulkan 库。\n\n----\n\n结语\n----\n\n我要感谢所有为 box64 开发做出贡献的人。\n贡献方式有很多种：代码贡献、财务帮助、捐赠捐赠和广告合作！\n以下感谢不分先后： \n\n * 代码贡献：rajdakin, mogery, ksco, xctan\n * 财务支持：[Playtron](https://playtron.one), tohodakilla, FlyingFathead, stormchaser3000, dennis1248, sll00, [libre-computer-project](https://libre.computer/), [CubeCoders Limited](http://cubecoders.com/)\n * 硬件捐赠和 LoongArch 迁移：[xiaoji](https://www.linuxgame.cn/), Deepin Beijing Develop Team\n * 硬件捐赠：[ADLINK](https://www.adlinktech.com/Products/Computer_on_Modules/COM-HPC-Server-Carrier-and-Starter-Kit/Ampere_Altra_Developer_Platform?lang=en) with [Ampere](https://amperecomputing.com/home/edge), [SOPHGO](https://www.sophon.ai/), [Radxa](https://rockpi.org/), [StarFive](https://rvspace.org/), [Pine64](https://www.pine64.org/), [AYN](https://www.ayntec.com/), [AYANEO](https://ayaneo.com/), [jiangcuo](https://github.com/jiangcuo)\n * 为本项目持续的宣传：salva ([microLinux](https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ)), [PILab](https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g)/[TwisterOS](https://twisteros.com/) team, [The Byteman](https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA), [NicoD](https://www.youtube.com/channel/UCpv7NFr0-9AB5xoklh3Snhg), ekianjo ([Boilingsteam](https://boilingsteam.com/))\n\n我还要感谢很多人，即使他们只参与了一次本项目。\n\n(如果你的项目中使用了Box64，请不要忘记提及！)\n"
        },
        {
          "name": "README_UK.md",
          "type": "blob",
          "size": 12.66015625,
          "content": "![Official logo](docs/img/Box64Logo.png \"Official Logo\")\n\nЕмулятор простіра користувача x86_64 із родзинкою\n\n[Дивитись журнал змін](https://github.com/ptitSeb/box64/blob/main/docs/CHANGELOG.md) | [中文](https://github.com/ptitSeb/box64/blob/main/README_CN.md) | [English](https://github.com/ptitSeb/box64/blob/main/README.md) | [Повідомити про помилку](https://github.com/ptitSeb/box64/issues/new)\n\n![build](https://app.travis-ci.com/ptitSeb/box64.svg?branch=main) ![stars](https://img.shields.io/github/stars/ptitSeb/box64) ![forks](https://img.shields.io/github/forks/ptitSeb/box64) ![contributors](https://img.shields.io/github/contributors/ptitSeb/box64) ![prs](https://img.shields.io/github/issues-pr/ptitSeb/box64) ![issues](https://img.shields.io/github/issues/ptitSeb/box64)\n\n----\n\nBox64 дозволяє запускати x86_64 Linux програми (наприклад, ігри) на системах Linux відмінних від x86_64, наприклад ARM (хост-система має мати 64-розрядний порядок редагування).\n\nВи можете знайти багато відео про Box64 в YouTube каналах [MicroLinux](https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ), [Pi Labs](https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g) або [The Byteman](https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA)\n\nОскільки Box64 використовує рідні версії деяких «системних» бібліотек, таких як libc, libm, SDL і OpenGL, його легко інтегрувати та використовувати з більшістю програм, а продуктивність у багатьох випадках може бути напрочуд високою. Подивіться на цей стендовий аналіз для прикладу [тут](https://box86.org/index.php/2021/06/game-performances/).\n\nBox64 інтегрується з DynaRec (динамічний рекомпілятор) для платформ ARM64 і RV64 забезпечуючи підвищення швидкості в 5-10 разів, ніж використання лише інтерпретатора. Деякі високорівневі відомості про те, як працює DynaRec, можна знайти [тут](https://box86.org/2021/07/inner-workings-a-high%e2%80%91level-view-of-box86-and-a-low%e2%80%91level-view-of-the-dynarec/).\n\nДеякі внутрішні коди операцій x64 використовують частини «Бібліотеки емулятора Realmode X86», дивіться [x64primop.c](src/emu/x64primop.c) для детальної інформації про авторські права.\n\n<img src=\"docs/img/Box64Icon.png\" width=\"96\" height=\"96\">\n\nЛоготип і піктограма зроблені @grayduck, дякую!\n\n----\n\nВикористання\n----\n\nЄ кілька змінних середовища для керування поведінкою Box64.\n\nДивіться [тут](docs/USAGE.md) для перегляду всіх змінних середовища та того, що вони роблять.\n\nПримітка: Dynarec від Box64 використовує механізм із захистом пам’яті та обробником сигналу помилки сегментів для обробки JIT коду. Простіше кажучи, якщо ви хочете використовувати GDB для налагодження запущеної програми, яка використовує JIT-код (наприклад, mono/Unity3D), ви все одно матимете багато «звичайних» помилок сегментів. Пропонується використовувати щось на зразок `handle SIGSEGV nostop` в GDB, щоб не зупинятися на кожній помилці сегмента, і, можливо, поставити точку зупину всередині `my_memprotectionhandler` в `signals.c`, якщо ви хочете перехопити помилки сегментів.\n\n----\nКомпіляція/Встановлення\n----\n> Інструкцію зі складання Box64 можна знайти [тут](docs/COMPILE.md).\\\n> Інструкцію з встановлення Wine для Box64 можна знайти [тут](docs/X64WINE.md).\n\n----\nІсторія версій/Журнал змін\n----\n\nІсторія версій доступна [тут](docs/CHANGELOG.md).\n\n----\n\nПримітки щодо 32 бітних платформ\n----\nОскільки Box64 працює шляхом прямого перекладу викликів функцій з x86_64 на хост-систему, хост-система (та, на якій працює Box64) повинна мати 64-розрядні бібліотеки. Box64 не містить 64-біт <-> 32-біт перекладу.\n\nТакож розумійте що Box64 запускатиме лише 64-розрядні двійкові Linux файли. Для 32-розрядних двійкових файлів вам потрібен Box86 (з усіма хитрощами з мультиархітектурною системою або корінними правами). Зауважте, що багато інсталяторів (на основі mojo) повертаються до \"x86\" при виявленні ОС ARM64, і тому намагатимуться використовувати Box86 для налаштування, навіть якщо існує версія x86_64. Ви можете зламати свій шлях за допомогою фальшивого \"uname\", який повертає \"x86_64\", коли аргумент \"-m\"\n\n----\n\nПримітки щодо конфігурації Box64\n----\n\nОбидва файли мають однаковий синтаксис і в основному є файлами ini. Розділ у квадратних дужках визначає назву процесу, а решта — встановлють змінну середовища. Подивіться [використання](USAGE.md), щоб дізнатися, які параметри можна завдати. Box64 поставляється з файлом за замовчуванням, який слід встановити для кращої стабільності. Файл знаходиться в `system/box64.box64rc` і має бути встановлен в `/etc/box64.box64rc`. Якщо з певних причин ви не хочете встановлювати цей файл у `/etc`, принаймні скопіюйте його в `~/.box64rc` або гра може не працювати належним чином. Зауважте, що пріоритетом є: `~/.bashrc` > `/etc/box64.box64rc` > командний рядок\nТаким чином, ваші налаштування в `~/.bashrc` можуть замінити налаштування з вашого командного рядка...\n\n----\n\nПримітки щодо емуляції ігор Unity\n----\n\nЗапуск ігор Unity має працювати, але ви також повинні зауважити, що для багатьох ігор Unity3D потрібен OpenGL 3+, який може бути складно забезпечити на ARM SBC (одноплатних комп’ютерах). Крім того, багато нових ігор Unity3D (наприклад, KSP) використовують стиснуті текстури BC7, які не підтримуються багатьма інтегрованими GPU ARM.\nПідказка: на Pi4 і Pi5 використовуйте `MESA_GL_VERSION_OVERRIDE=3.2` з `BOX64_DYNAREC_STRONGMEM=1`, щоб запобігти зависанням і ввімкнути режим сильної пам’яті, і використовуйте Panfrost `PAN_MESA_DEBUG=gl3`, щоб використовувати вищий профіль, якщо гра починається, а потім завершується, перш ніж щось показати.\n\n----\n\nПримітки щодо програм GTK\n----\n\nБібліотеки GTK2 і GTK3 тепер використовуються в Box64.\n\n----\n\nПримітки щодо Steam\n----\n\nЗауважте, що Steam є гібридом 32-біт / 64-біт. Вам ПОТРІБЕН box86, щоб запустити Steam, оскільки клієнта є 32-розрядною двійковою програмою. Він також використовує 64-розрядні двійкові файли локального сервера, і цей процес steamwebhelper тепер є обов’язковим навіть у «малому режимі». І цей процес з’їсть багато оперативної пам’яті, таким чином машині з 6 Гб оперативної пам’яті знадобиться файл підкачки для використання Steam.\n\n----\n\nПримітки щодо Wine\n----\n\nWine64 підтримується Box64, Proton теж. Майте на увазі, що 64-розрядний Wine також містить 32-розрядні компоненти щоб мати можливість запускати 32-розрядні програми Windows. Для 32-розрядних програм потрібен Box86, і вони не працюватимуть без нього. У системі, де присутні і працюють Box64, і Box86, 64-розрядне встановлення Wine може запускати як 32-розрядні, так і 64-розрядні програми Windows (просто використовуйте `wine` і `wine64` відповідно).\nЗауважте, що новий 32-бітний PE в 64-бітному процесі, який Wine зараз реалізує у Wine 7+ тепер підтримується, але підтримка є досить молодою тому можуть виникнути деякі проблеми.\n\n----\n\nПримітки щодо Vulkan\n----\n\nBox64 використовує бібліотеки Vulkan, але зауважте що він тестувався з картою AMD Radeon RX550 і драйвером Freedreno, тому деякі розширення можуть бути відсутні залежно від вашої відеокарти.\n\n----\n\nОстаннє слово\n----\n\nЯ хочу подякувати всім, хто зробив внесок у розвиток box64.\nЄ багато способів зробити внесок: внесок коду, фінансовий внесок, апаратне забезпечення та реклама!\nОтже, без особливого порядку, я хочу подякувати:\n* За основний внесок у код: rajdakin, mogery, ksco, xctan\n* За великий фінансовий внесок: [Playtron](https://playtron.one), tohodakilla, FlyingFathead, stormchaser3000, dennis1248, sll00, [libre-computer-project](https://libre.computer/)\n* За апаратне забезпечення та міграцію LoongArch: [xiaoji](https://www.linuxgame.cn/), команда розробників Deepin Beijing\n* За внесок у апаратне забезпечення: [ADLINK](https://www.adlinktech.com/Products/Computer_on_Modules/COM-HPC-Server-Carrier-and-Starter-Kit/Ampere_Altra_Developer_Platform?lang=en) with [Ampere](https://amperecomputing.com/home/edge), [SOPHGO](https://www.sophon.ai/), [Radxa](https://rockpi.org/), [StarFive](https://rvspace.org/), [Pine64](https://www.pine64.org/), [AYN](https://www.ayntec.com/), [AYANEO](https://ayaneo.com/), [jiangcuo](https://github.com/jiangcuo)\n* За безперервну рекламу Box64: salva ([microLinux](https://www.youtube.com/channel/UCwFQAEj1lp3out4n7BeBatQ)), [PILab](https://www.youtube.com/channel/UCgfQjdc5RceRlTGfuthBs7g)/Команда [TwisterOS](https://twisteros.com/), [The Byteman](https://www.youtube.com/channel/UCEr8lpIJ3B5Ctc5BvcOHSnA), [NicoD](https://www.youtube.com/channel/UCpv7NFr0-9AB5xoklh3Snhg), ekianjo ([Boilingsteam](https://boilingsteam.com/))\n\nІ я також дякую багатьом іншим людям, які хоч раз брали участь у цьому проекті.\n\n(Якщо ви використовуєте Box64 у своєму проекті, будь ласка, не забудьте згадати про це!)\n"
        },
        {
          "name": "cmake_uninstall.cmake.in",
          "type": "blob",
          "size": 0.9794921875,
          "content": "if(NOT EXISTS \"@CMAKE_BINARY_DIR@/install_manifest.txt\")\n  message(FATAL_ERROR \"Cannot find install manifest: @CMAKE_BINARY_DIR@/install_manifest.txt\")\nendif(NOT EXISTS \"@CMAKE_BINARY_DIR@/install_manifest.txt\")\n\nfile(READ \"@CMAKE_BINARY_DIR@/install_manifest.txt\" files)\nstring(REGEX REPLACE \"\\n\" \";\" files \"${files}\")\nforeach(file ${files})\n  message(STATUS \"Uninstalling $ENV{DESTDIR}${file}\")\n  if(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    exec_program(\n      \"@CMAKE_COMMAND@\" ARGS \"-E remove \\\"$ENV{DESTDIR}${file}\\\"\"\n      OUTPUT_VARIABLE rm_out\n      RETURN_VALUE rm_retval\n      )\n    if(NOT \"${rm_retval}\" STREQUAL 0)\n      message(FATAL_ERROR \"Problem when removing $ENV{DESTDIR}${file}\")\n    endif(NOT \"${rm_retval}\" STREQUAL 0)\n  else(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\n    message(STATUS \"File $ENV{DESTDIR}${file} does not exist.\")\n  endif(IS_SYMLINK \"$ENV{DESTDIR}${file}\" OR EXISTS \"$ENV{DESTDIR}${file}\")\nendforeach(file)\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "gdbjit",
          "type": "tree",
          "content": null
        },
        {
          "name": "install_steam.sh",
          "type": "blob",
          "size": 0.609375,
          "content": "#!/bin/bash\n\n# create necessary directories\nmkdir -p ~/steam\nmkdir -p ~/steam/tmp\ncd ~/steam/tmp\n\n# download latest deb and unpack\nwget https://cdn.cloudflare.steamstatic.com/client/installer/steam.deb\nar x steam.deb\ntar xf data.tar.xz\n\n# remove deb archives, not needed anymore\nrm ./*.tar.xz ./steam.deb\n\n# move deb contents to steam folder\nmv ./usr/* ../\ncd ../ && rm -rf ./tmp/\n\n# create run script\necho '#!/bin/bash\nexport STEAMOS=1\nexport STEAM_RUNTIME=1\nexport DBUS_FATAL_WARNINGS=0\n~/steam/bin/steam $@' > steam\n\n# make script executable and move\nchmod +x steam\nsudo mv steam /usr/local/bin/\n\necho \"Script complete.\"\n"
        },
        {
          "name": "pkgbuilds",
          "type": "tree",
          "content": null
        },
        {
          "name": "postinst",
          "type": "blob",
          "size": 0.0419921875,
          "content": "#!/bin/sh\nsystemctl restart systemd-binfmt\n"
        },
        {
          "name": "rebuild_wrappers.py",
          "type": "blob",
          "size": 67.9072265625,
          "content": "#!/usr/bin/env python3\n\nimport os\nimport sys\n\ntry:\n\tassert(sys.version_info.major == 3)\n\tif sys.version_info.minor >= 9:\n\t\t# Python 3.9+\n\t\tfrom typing import Generic, NewType, Optional, TypeVar, Union, final\n\t\tfrom collections.abc import Iterable\n\t\tDict = dict\n\t\tList = list\n\t\tTuple = tuple\n\telif sys.version_info.minor >= 8:\n\t\t# Python [3.8, 3.9)\n\t\tfrom typing import Dict, List, Tuple, Generic, Iterable, NewType, Optional, TypeVar, Union, final\n\telif (sys.version_info.minor >= 5) and (sys.version_info.micro >= 2):\n\t\t# Python [3.5.2, 3.8)\n\t\tfrom typing import Dict, List, Tuple, Generic, Iterable, NewType, Optional, TypeVar, Union\n\t\tfinal = lambda fun: fun # type: ignore\n\telif sys.version_info.minor >= 5:\n\t\t# Python [3.5, 3.5.2)\n\t\tfrom typing import Dict, List, Tuple, Generic, Iterable, Optional, TypeVar, Union\n\t\tclass GTDummy:\n\t\t\tdef __getitem__(self, _): return self\n\t\tfinal = lambda fun: fun # type: ignore\n\t\tdef NewType(_, b): return b # type: ignore\n\telse:\n\t\t# Python < 3.5\n\t\t#print(\"Your Python version does not have the typing module, fallback to empty 'types'\")\n\t\t# Dummies\n\t\tclass GTDummy:\n\t\t\tdef __getitem__(self, _):\n\t\t\t\treturn self\n\t\tDict = GTDummy() # type: ignore\n\t\tList = GTDummy() # type: ignore\n\t\tGeneric = GTDummy() # type: ignore\n\t\tIterable = GTDummy() # type: ignore\n\t\tOptional = GTDummy() # type: ignore\n\t\tdef NewType(_, b): return b # type: ignore\n\t\tTuple = GTDummy() # type: ignore\n\t\tdef TypeVar(T): return object # type: ignore\n\t\tUnion = GTDummy() # type: ignore\nexcept ImportError:\n\tprint(\"It seems your Python version is quite broken...\")\n\tassert(False)\n\n\"\"\"\nGenerates all files in src/wrapped/generated\n===\n\nTL;DR: Automagically creates type definitions (/.F.+/ functions/typedefs...).\n       All '//%' in the headers are used by the script.\n\nReads each lines of each \"_private.h\" headers.\nFor each of them:\n- If if starts with a #ifdef, #else, #ifndef, #endif, it memorizes which definition is required\n- If it starts with a \"GO\", it will do multiple things:\n  - It memorizes the type used by the function (second macro argument)\n  - It memorizes the type it is mapped to, if needed (eg, iFEvp is mapped to iFEp: the first \"real\" argument is dropped)\n  - It checks if the type given (both original and mapped to) are valid\n  - If the signature contains a 'E' but it is not a \"GOM\" command, it will throw an error\n- If the line starts with a '//%S', it will memorize a structure declaration.\n  The structure of it is: \"//%S <letter> <structure name> <signature equivalent>\"\n  NOTE: Those structure letters are \"fake types\" that are accepted in the macros.\n\nAfter sorting the data, it generates:\n\nwrapper.c\n---------\n(Private) type definitions (/.F.+_t/)\nFunction definitions (/.F.+/ functions, that actually execute the function given as argument)\nisSimpleWrapper definition\n\nwrapper.h\n---------\nGeneric \"wrapper_t\" type definition\nFunction declarations (/.F.+/ functions)\n\n*types.h\n--------\nLocal types definition, for the original signatures\nThe SUPER() macro definition, used to generate and initialize the `*_my_t` library structure\n(TODO: also automate this declaration/definition? It would require more metadata,\n and may break sometime in the future due to the system changing...)\n\n*defs.h\n-------\nLocal `#define`s, for signature mapping\n\n*undefs.h\n---------\nLocal `#undefine`s, for signature mapping\n\n\nExample:\n========\nIn wrappedtest_private.h:\n   ----------------------\n//%S X TestLibStructure ppu\n\nGO(superfunction, pFX)\nGOM(superFunction2, pFpX)\n\nGenerated files:\nwrapper.c: [snippet]\n----------\ntypedef void *(*pFppu_t)(void*, void*, uint32_t);\ntypedef void *(*pFpppu_t)(void*, void*, void*, uint32_t);\n\nvoid pFppu(x64emu_t *emu, uintptr_t fcn) { pFppu_t *fn = (pFppu_t)fn; R_RAX=...; }\nvoid pFpppu(x64emu_t *emu, uintptr_t fcn) { pFpppu_t *fn = (pFpppu_t)fn; R_RAX=...; }\n\nint isSimpleWrapper(wrapper_t fun) {\n\tif (fcn == pFppu) return 1;\n\tif (fcn == pFpppu) return 1;\n\treturn 0;\n}\n\nwrapper.h: [snippet]\n----------\nvoid pFppu(x64emu_t *emu, uintptr_t fcn);\nvoid pFpppu(x64emu_t *emu, uintptr_t fcn);\n\nint isSimpleWrapper(wrapper_t fun);\n\nwrappedtesttypes.h:\n-------------------\ntypedef void *(*pFpX_t)(void*, TestLibStructure);\n\n#define SUPER() \\\\\n\tGO(superFunction2, pFpX)\n\nwrappedtestdefs.h:\n------------------\n#define pFX pFppu\n#define pFpX pFpppu\n\nwrappedtestundefs.h:\n--------------------\n#undef pFX\n#undef pFpX\n\"\"\"\n\n# TODO: Add /.F.*A/ automatic generation (and suppression)\n\nclass FunctionConvention(object):\n\tdef __init__(self, ident: str, convname: str, valid_chars: List[str]) -> None:\n\t\tself.ident = ident\n\t\tself.name = convname\n\t\tself.values = valid_chars\n# Free letters:  B   FG  JK     QR T    YZa   e gh jk mno qrst   yz\nconventions = {\n\t'F': FunctionConvention('F', \"System V\", ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'l', 'L', 'p', 'V', 'O', 'S', 'N', 'H', 'P', 'A', 'x', 'X', 'Y', 'b']),\n\t'W': FunctionConvention('W', \"Windows\",  ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd',      'l', 'L', 'p', 'V', 'O', 'S', 'N',      'P', 'A'])\n}\nsortedvalues = ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'l', 'L', 'p', 'V', 'O', 'S', 'N', 'H', 'P', 'A', 'x', 'X', 'Y', 'b', '0', '1']\nassert(all(all(c not in conv.values[:i] and c in sortedvalues for i, c in enumerate(conv.values)) for conv in conventions.values()))\n\n# Some type depend on HAVE_LD80BITS; define this here so we can use it in readFiles and main\ndepends_on_ld: str = \"DY\"\nassert(all(c in sortedvalues for c in depends_on_ld))\n\nclass FunctionType(str):\n\t@staticmethod\n\tdef validate(s: str, post: str) -> bool:\n\t\tif len(s) < 3:\n\t\t\traise NotImplementedError(\"Type {0} too short{1}\".format(s, post))\n\t\tchk_type = s[0] + s[2:]\n\t\tif \"E\" in s:\n\t\t\tif (\"E\" in s[:2]) or (\"E\" in s[3:]):\n\t\t\t\traise NotImplementedError(\n\t\t\t\t\t\"emu64_t* not as the first parameter{0}\".format(post))\n\t\t\tif len(s) < 4:\n\t\t\t\traise NotImplementedError(\"Type {0} too short{1}\".format(s, post))\n\t\t\t# TODO: change *FEv into true functions (right now they are redirected to *FE)\n\t\t\t#chk_type = s[0] + s[3:]\n\t\t\n\t\tif s[1] not in conventions:\n\t\t\traise NotImplementedError(\"Bad middle letter {0}{1}\".format(s[1], post))\n\t\t\n\t\treturn all(c in conventions[s[1]].values for c in chk_type) and (('v' not in chk_type[1:]) or (len(chk_type) == 2))\n\t\n\tdef get_convention(self) -> FunctionConvention:\n\t\treturn conventions[self[1]]\n\t\n\tdef splitchar(self) -> List[int]:\n\t\t\"\"\"\n\t\tsplitchar -- Sorting key function for function signatures\n\t\t\n\t\tThe longest strings are at the end, and for identical length, the string\n\t\tare sorted using a pseudo-lexicographic sort, where characters have a value\n\t\tof `values.index`.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tret = [len(self), ord(self.get_convention().ident), self.get_convention().values.index(self[0])]\n\t\t\tfor c in self[2:]:\n\t\t\t\tret.append(self.get_convention().values.index(c))\n\t\t\treturn ret\n\t\texcept ValueError as e:\n\t\t\traise ValueError(\"Value is \" + self) from e\n\t\n\tdef __getitem__(self, i: Union[int, slice]) -> 'FunctionType': # type: ignore [override]\n\t\treturn FunctionType(super().__getitem__(i))\n\nRedirectType = NewType('RedirectType', FunctionType)\nDefineType = NewType('DefineType', str)\n\nStructType = NewType('StructType', str)\n\nT = TypeVar('T')\nU = TypeVar('U')\n\n# TODO: simplify construction of this (add an 'insert' method?...)\nclass CustOrderedDict(Generic[T, U], Iterable[T]):\n\tdef __init__(self, dict: Dict[T, U], keys: List[T]):\n\t\tself.__indict__ = dict\n\t\tself.__inkeys__ = keys\n\t\n\tdef __iter__(self):\n\t\treturn iter(self.__inkeys__)\n\t\n\tdef __getitem__(self, k: T) -> U:\n\t\treturn self.__indict__[k]\n\nFilename = str\nClausesStr = str\n\n@final\nclass Define:\n\tname: DefineType\n\tinverted_: bool\n\t\n\tdefines: List[DefineType] = []\n\t\n\tdef __init__(self, name: str, inverted_: bool):\n\t\t# All values of \"name\" are included in defines (throw otherwise)\n\t\tif DefineType(name) not in self.defines:\n\t\t\traise KeyError(name)\n\t\tself.name = DefineType(name)\n\t\tself.inverted_ = inverted_\n\tdef copy(self) -> \"Define\":\n\t\treturn Define(self.name, self.inverted_)\n\t\n\tdef value(self) -> int:\n\t\treturn self.defines.index(self.name)*2 + (1 if self.inverted_ else 0)\n\t\n\tdef invert(self) -> None:\n\t\t\"\"\"\n\t\tinvert -- Transform a `defined()` into a `!defined()` and vice-versa, in place.\n\t\t\"\"\"\n\t\tself.inverted_ = not self.inverted_\n\tdef inverted(self) -> \"Define\":\n\t\t\"\"\"\n\t\tinverted -- Transform a `defined()` into a `!defined()` and vice-versa, out-of-place.\n\t\t\"\"\"\n\t\treturn Define(self.name, not self.inverted_)\n\t\n\tdef __str__(self) -> str:\n\t\tif self.inverted_:\n\t\t\treturn \"!defined(\" + self.name + \")\"\n\t\telse:\n\t\t\treturn \"defined(\" + self.name + \")\"\n@final\nclass Clause:\n\tdefines: List[Define]\n\t\n\tdef __init__(self, defines: Union[List[Define], str] = []):\n\t\tif isinstance(defines, str):\n\t\t\tif defines == \"\":\n\t\t\t\tself.defines = []\n\t\t\telse:\n\t\t\t\tself.defines = list(\n\t\t\t\t\tmap(\n\t\t\t\t\t\tlambda x:\n\t\t\t\t\t\t\tDefine(x[9:-1] if x[0] == '!' else x[8:-1], x[0] == '!')\n\t\t\t\t\t\t, defines.split(\" && \")\n\t\t\t\t\t)\n\t\t\t\t)\n\t\telse:\n\t\t\tself.defines = [d.copy() for d in defines]\n\tdef copy(self) -> \"Clause\":\n\t\treturn Clause(self.defines)\n\t\n\tdef append(self, define: Define) -> None:\n\t\tself.defines.append(define)\n\tdef invert_last(self) -> None:\n\t\tself.defines[-1].invert()\n\tdef pop_last(self) -> None:\n\t\tif len(self.defines) > 0: self.defines.pop()\n\t\n\tdef __str__(self) -> str:\n\t\treturn \" && \".join(map(str, self.defines))\n@final\nclass Clauses:\n\t\"\"\"\n\tRepresent a list of clauses, aka a list of or-ed together and-ed \"defined\"\n\tconditions\n\t\"\"\"\n\tdefiness: List[Clause]\n\t\n\tdef __init__(self, definess: Union[List[Clause], str] = []):\n\t\tif isinstance(definess, str):\n\t\t\tif definess == \"()\":\n\t\t\t\tself.definess = []\n\t\t\telif \") || (\" in definess:\n\t\t\t\tself.definess = list(map(Clause, definess[1:-1].split(\") || (\")))\n\t\t\telse:\n\t\t\t\tself.definess = [Clause(definess)]\n\t\telse:\n\t\t\tself.definess = definess[:]\n\tdef copy(self) -> \"Clauses\":\n\t\treturn Clauses(self.definess[:])\n\t\n\tdef add(self, defines: Clause) -> None:\n\t\tself.definess.append(defines)\n\t\n\tdef splitdef(self) -> List[int]:\n\t\t\"\"\"\n\t\tsplitdef -- Sorting key function for #ifdefs\n\t\t\n\t\tAll #if defined(...) are sorted first by the number of clauses, then by the\n\t\tnumber of '&&' in each clause and then by the \"key\" of the tested names\n\t\t(left to right, inverted placed after non-inverted).\n\t\t\"\"\"\n\t\t\n\t\tret = [len(self.definess)]\n\t\tfor cunj in self.definess:\n\t\t\tret.append(len(cunj.defines))\n\t\tfor cunj in self.definess:\n\t\t\tfor d in cunj.defines:\n\t\t\t\tret.append(d.value())\n\t\treturn ret\n\t\n\tdef __str__(self) -> ClausesStr:\n\t\tif len(self.definess) == 1:\n\t\t\treturn str(self.definess[0])\n\t\telse:\n\t\t\treturn \"(\" + \") || (\".join(map(str, self.definess)) + \")\"\n\nJumbledGlobals       = Dict[ClausesStr, List[FunctionType]]\nJumbledRedirects     = Dict[ClausesStr, Dict[RedirectType, FunctionType]]\nJumbledTypedefs      = Dict[RedirectType, List[str]]\nJumbledStructures    = Dict[str, Tuple[StructType, str]]\nJumbledStructUses    = Dict[RedirectType, FunctionType]\nJumbledFilesSpecific = Dict[Filename, Tuple[JumbledTypedefs, JumbledStructures, JumbledStructUses]]\nSortedGlobals       = CustOrderedDict[ClausesStr, List[FunctionType]]\nSortedRedirects     = CustOrderedDict[ClausesStr, List[Tuple[RedirectType, FunctionType]]]\nSortedTypedefs      = CustOrderedDict[RedirectType, List[str]]\nSortedStructUses    = CustOrderedDict[RedirectType, FunctionType]\nSortedFilesSpecific = Dict[Filename, Tuple[SortedTypedefs, SortedStructUses]]\n\ndef readFiles(files: Iterable[Filename]) -> Tuple[JumbledGlobals, JumbledRedirects, JumbledFilesSpecific]:\n\t\"\"\"\n\treadFiles\n\t\n\tThis function is the one that parses the files.\n\tIt returns the jumbled (gbl, redirects, {file: (typedefs, mystructs)}) tuple.\n\t\"\"\"\n\t\n\t# Initialize variables: gbl for all values, redirects for redirections\n\tgbl      : JumbledGlobals       = {}\n\tredirects: JumbledRedirects     = {}\n\tfilespec : JumbledFilesSpecific = {}\n\t\n\tfunctions: Dict[str, Filename] = {}\n\thalt_required = False # Is there a GO(*, .FE*) or similar in-batch error(s)?\n\t# First read the files inside the headers\n\tfor filepath in files:\n\t\tfilename: Filename = filepath.split(\"/\")[-1]\n\t\tdependants: Clause = Clause()\n\t\t\n\t\t# typedefs is a list of all \"*FE*\" types for the current file\n\t\t# mystructs  is a map  of all char -> (structure C name, replacement) for structures\n\t\ttypedefs    : JumbledTypedefs   = {}\n\t\tmystructs   : JumbledStructures = {}\n\t\tmystructuses: JumbledStructUses = {}\n\t\tfilespec[filename[:-10]] = (typedefs, mystructs, mystructuses)\n\t\t\n\t\tdef add_symbol_name(funname: Union[str, None], funsname: Dict[ClausesStr, List[str]] = {\"\": []}):\n\t\t\t# Optional arguments are evaluated only once!\n\t\t\tnonlocal halt_required\n\t\t\tif funname is None:\n\t\t\t\tfor k in funsname:\n\t\t\t\t\tif (k != \"\") and (len(funsname[k]) != 0):\n\t\t\t\t\t\t# Note: if this condition ever raises, check the wrapper pointed by it.\n\t\t\t\t\t\t# If you find no problem, comment the error below, add a \"pass\" line (so python is happy)\n\t\t\t\t\t\t# and open a ticket so I can fix this.\n\t\t\t\t\t\traise NotImplementedError(\"Some functions are only implemented under one condition (probably) ({0}:{1})\"\n\t\t\t\t\t\t\t.format(k, filename) + \" [extra note in the script]\\nProblematic function{}: {}\".format((\"\" if len(funsname[k]) == 1 else \"s\"), funsname[k]))\n\t\t\t\t\tfor f in funsname[k]:\n\t\t\t\t\t\tif f in ['_fini', '_init', '__bss_start', '__data_start', '_edata', '_end']:\n\t\t\t\t\t\t\tcontinue # Always allow those symbols [TODO: check if OK]\n\t\t\t\t\t\tif f in functions:\n\t\t\t\t\t\t\t# Check for resemblances between functions[f] and filename\n\t\t\t\t\t\t\tif filename.startswith(functions[f][:-12]) or functions[f].startswith(filename[:-12]):\n\t\t\t\t\t\t\t\t# Probably OK\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t# Manual compatible libs detection\n\t\t\t\t\t\t\tmatch = lambda l, r: (filename[7:-10], functions[f][7:-10]) in [(l, r), (r, l)]\n\t\t\t\t\t\t\tif match(\"sdl1image\", \"sdl2image\") \\\n\t\t\t\t\t\t\t or match(\"sdl1mixer\", \"sdl2mixer\") \\\n\t\t\t\t\t\t\t or match(\"sdl1net\", \"sdl2net\") \\\n\t\t\t\t\t\t\t or match(\"sdl1ttf\", \"sdl2ttf\") \\\n\t\t\t\t\t\t\t or match(\"libgl\", \"libegl\") \\\n\t\t\t\t\t\t\t or match(\"libgl\", \"glesv2\") \\\n\t\t\t\t\t\t\t or match(\"libegl\", \"glesv2\") \\\n\t\t\t\t\t\t\t or match(\"softokn3\", \"p11kit\") \\\n\t\t\t\t\t\t\t or match(\"libc\", \"tcmallocminimal\") \\\n\t\t\t\t\t\t\t or match(\"libc\", \"tbbmallocproxy\") \\\n\t\t\t\t\t\t\t or match(\"libc\", \"androidshmem\") \\\n\t\t\t\t\t\t\t or match(\"crypto\", \"libssl3\") \\\n\t\t\t\t\t\t\t or match(\"tcmallocminimal\", \"tbbmallocproxy\"):\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Note: this test is very (too) simple. If it ever raises, comment\n\t\t\t\t\t\t\t# `halt_required = True` and open an issue.\n\t\t\t\t\t\t\tprint(\"The function or data {0} is declared in multiple files ({1}/{2})\"\n\t\t\t\t\t\t\t\t.format(f, functions[f], filename) + \" [extra note in the script]\")\n\t\t\t\t\t\t\thalt_required = True\n\t\t\t\t\t\tfunctions[f] = filename\n\t\t\telse:\n\t\t\t\tif funname == \"\":\n\t\t\t\t\traise NotImplementedError(\"This function name (\\\"\\\") is suspicious... ({0})\".format(filename))\n\t\t\t\tl = len(dependants.defines)\n\t\t\t\talready_pst = funname in funsname[\"\"]\n\t\t\t\tif l > 1:\n\t\t\t\t\treturn\n\t\t\t\telif l == 1:\n\t\t\t\t\tfunsname.setdefault(str(dependants), [])\n\t\t\t\t\talready_pst = already_pst or (funname in funsname[str(dependants)])\n\t\t\t\tif already_pst:\n\t\t\t\t\tprint(\"Function or data {0} is duplicated! ({1})\".format(funname, filename))\n\t\t\t\t\thalt_required = True\n\t\t\t\t\treturn\n\t\t\t\tif l == 1:\n\t\t\t\t\ts = str(dependants.defines[0].inverted())\n\t\t\t\t\tif (s in funsname) and (funname in funsname[s]):\n\t\t\t\t\t\tfunsname[s].remove(funname)\n\t\t\t\t\t\tfunsname[\"\"].append(funname)\n\t\t\t\t\telse:\n\t\t\t\t\t\tfunsname[str(dependants)].append(funname)\n\t\t\t\telse:\n\t\t\t\t\tfunsname[\"\"].append(funname)\n\t\t\n\t\twith open(filepath, 'r') as file:\n\t\t\tline: str # Because VSCode really struggles with files\n\t\t\tfor line in file:\n\t\t\t\tln = line.strip()\n\t\t\t\t# If the line is a `#' line (#ifdef LD80BITS/#ifndef LD80BITS/header)\n\t\t\t\tif ln.startswith(\"#\"):\n\t\t\t\t\tpreproc_cmd = ln[1:].strip()\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif preproc_cmd.startswith(\"if defined(GO)\"):\n\t\t\t\t\t\t\tcontinue #if defined(GO) && defined(GOM)...\n\t\t\t\t\t\telif preproc_cmd.startswith(\"if !(defined(GO)\"):\n\t\t\t\t\t\t\tcontinue #if !(defined(GO) && defined(GOM)...)\n\t\t\t\t\t\telif preproc_cmd.startswith(\"error\"):\n\t\t\t\t\t\t\tcontinue #error meh!\n\t\t\t\t\t\telif preproc_cmd.startswith(\"endif\"):\n\t\t\t\t\t\t\tdependants.pop_last()\n\t\t\t\t\t\telif preproc_cmd.startswith(\"ifdef\"):\n\t\t\t\t\t\t\tdependants.append(Define(preproc_cmd[5:].strip(), False))\n\t\t\t\t\t\telif preproc_cmd.startswith(\"ifndef\"):\n\t\t\t\t\t\t\tdependants.append(Define(preproc_cmd[6:].strip(), True))\n\t\t\t\t\t\telif preproc_cmd.startswith(\"else\"):\n\t\t\t\t\t\t\tdependants.invert_last()\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\traise NotImplementedError(\"Unknown preprocessor directive: {0} ({1}:{2})\".format(\n\t\t\t\t\t\t\t\tpreproc_cmd.split(\" \")[0], filename, line[:-1]\n\t\t\t\t\t\t\t))\n\t\t\t\t\texcept KeyError as k:\n\t\t\t\t\t\traise NotImplementedError(\"Unknown key: {0} ({1}:{2})\".format(\n\t\t\t\t\t\t\tk.args[0], filename, line[:-1]\n\t\t\t\t\t\t)) from k\n\t\t\t\t\n\t\t\t\t# If the line is a `GO...' line (GO/GOM/GO2/...)...\n\t\t\t\telif ln.startswith(\"GO\"):\n\t\t\t\t\t# ... then look at the second parameter of the line\n\t\t\t\t\ttry:\n\t\t\t\t\t\tgotype = ln.split(\"(\")[0].strip()\n\t\t\t\t\t\tfunname = ln.split(\",\")[0].split(\"(\")[1].strip()\n\t\t\t\t\t\tln = ln.split(\",\")[1].split(\")\")[0].strip()\n\t\t\t\t\t\tif not filename.endswith(\"_genvate.h\"):\n\t\t\t\t\t\t\tadd_symbol_name(funname)\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\traise NotImplementedError(\"Invalid GO command: {0}:{1}\".format(\n\t\t\t\t\t\t\tfilename, line[:-1]\n\t\t\t\t\t\t))\n\t\t\t\t\t\n\t\t\t\t\thasFlatStructure = False\n\t\t\t\t\torigLine = ln\n\t\t\t\t\tif not FunctionType.validate(ln, \" ({0}:{1})\".format(filename, line[:-1])):\n\t\t\t\t\t\t# This needs more work\n\t\t\t\t\t\told = RedirectType(FunctionType(ln))\n\t\t\t\t\t\tif (ln[0] in old.get_convention().values) \\\n\t\t\t\t\t\t and ('v' not in ln[2:]) \\\n\t\t\t\t\t\t and all((c in old.get_convention().values) or (c in mystructs) for c in ln[2:]):\n\t\t\t\t\t\t\thasFlatStructure = True\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor sn in mystructs:\n\t\t\t\t\t\t\t\tln = ln.replace(sn, mystructs[sn][1])\n\t\t\t\t\t\t\tln = ln[0] + 'F' + ln[2:] # In case a structure named 'F' is used\n\t\t\t\t\t\t\tmystructuses[RedirectType(FunctionType(origLine))] = FunctionType(ln)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tif old.get_convention().name == \"System V\":\n\t\t\t\t\t\t\t\tacceptables = ['0', '1'] + old.get_convention().values\n\t\t\t\t\t\t\t\tif any(c not in acceptables for c in ln[2:]):\n\t\t\t\t\t\t\t\t\traise NotImplementedError(\"{0} ({1}:{2})\".format(ln[2:], filename, line[:-1]))\n\t\t\t\t\t\t\t\t# Ok, this is acceptable: there is 0, 1 and/or void\n\t\t\t\t\t\t\t\tln = ln[:2] + (ln[2:]\n\t\t\t\t\t\t\t\t\t.replace(\"v\", \"\")   # void   -> nothing\n\t\t\t\t\t\t\t\t\t.replace(\"0\", \"i\")  # 0      -> integer\n\t\t\t\t\t\t\t\t\t.replace(\"1\", \"i\")) # 1      -> integer\n\t\t\t\t\t\t\t\tassert(len(ln) >= 3)\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tacceptables = ['0', '1', 'D', 'H'] + old.get_convention().values\n\t\t\t\t\t\t\t\tif any(c not in acceptables for c in ln[2:]):\n\t\t\t\t\t\t\t\t\traise NotImplementedError(\"{0} ({1}:{2})\".format(ln[2:], filename, line[:-1]))\n\t\t\t\t\t\t\t\t# Ok, this is acceptable: there is 0, 1 and/or void\n\t\t\t\t\t\t\t\tln = ln[:2] + (ln[2:]\n\t\t\t\t\t\t\t\t\t.replace(\"v\", \"\")   # void              -> nothing\n\t\t\t\t\t\t\t\t\t.replace(\"D\", \"p\")  # long double       -> pointer\n\t\t\t\t\t\t\t\t\t.replace(\"H\", \"p\")  # unsigned __int128 -> pointer\n\t\t\t\t\t\t\t\t\t.replace(\"0\", \"i\")  # 0                 -> integer\n\t\t\t\t\t\t\t\t\t.replace(\"1\", \"i\")) # 1                 -> integer\n\t\t\t\t\t\t\t\tassert(len(ln) >= 3)\n\t\t\t\t\t\t\tredirects.setdefault(str(dependants), {})\n\t\t\t\t\t\t\tredirects[str(dependants)][old] = FunctionType(ln)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\torigLine = ln\n\t\t\t\t\t\n\t\t\t\t\t# Simply append the function type if it's not yet existing\n\t\t\t\t\tgbl.setdefault(str(dependants), [])\n\t\t\t\t\tif ln not in gbl[str(dependants)]:\n\t\t\t\t\t\tgbl[str(dependants)].append(FunctionType(ln))\n\t\t\t\t\t\n\t\t\t\t\tif any(c in origLine for c in depends_on_ld):\n\t\t\t\t\t\tif (gotype != \"GOM\") and (gotype != \"GOWM\") and (gotype != \"GOD\") and (gotype != \"GOWD\"):\n\t\t\t\t\t\t\tprint(\"\\033[91mError:\\033[m type depends on HAVE_LD80BITS but the GO type doesn't support that ({0}:{1})\"\n\t\t\t \t\t\t\t\t.format(filename, line[:-1]))\n\t\t\t\t\t\t\thalt_required = True\n\t\t\t\t\tif (gotype == \"GO2\") or (gotype == \"GOW2\") or (gotype == \"GOD\") or (gotype == \"GODW\"):\n\t\t\t\t\t\taltfun = line.split(',')[2].split(')')[0].strip()\n\t\t\t\t\t\tif altfun == \"\":\n\t\t\t\t\t\t\tprint(\"\\033[91mError:\\033[m empty alt function ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\t\t\thalt_required = True\n\t\t\t\t\t\telif altfun == funname:\n\t\t\t\t\t\t\tprint(\"\\033[91mError:\\033[m alt function is the original function ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\t\t\thalt_required = True\n\t\t\t\t\tif origLine[2] == \"E\":\n\t\t\t\t\t\tif (gotype != \"GOM\") and (gotype != \"GOWM\"):\n\t\t\t\t\t\t\tif ((gotype != \"GO2\") and (gotype != \"GOW2\")) or not (line.split(',')[2].split(')')[0].strip().startswith('my_')):\n\t\t\t\t\t\t\t\tprint(\"\\033[91mThis is probably not what you meant!\\033[m ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\t\t\t\thalt_required = True\n\t\t\t\t\t\tif len(origLine) > 3:\n\t\t\t\t\t\t\tfuntype = RedirectType(FunctionType(origLine[:2] + origLine[3:]))\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tfuntype = RedirectType(FunctionType(origLine[:2] + \"v\"))\n\t\t\t\t\t\t# filename isn't stored with the '_private.h' part\n\t\t\t\t\t\ttypedefs.setdefault(funtype, [])\n\t\t\t\t\t\ttypedefs[funtype].append(funname)\n\t\t\t\t\telif (gotype == \"GOM\") or (gotype == \"GOWM\"):\n\t\t\t\t\t\t# OK on box64 for a GOM to not have emu...\n\t\t\t\t\t\tfuntype = RedirectType(FunctionType(origLine))\n\t\t\t\t\t\ttypedefs.setdefault(funtype, [])\n\t\t\t\t\t\ttypedefs[funtype].append(funname)\n\t\t\t\t\t\t# print(\"\\033[94mAre you sure of this?\\033[m ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\t\t# halt_required = True\n\t\t\t\t\telif hasFlatStructure:\n\t\t\t\t\t\t# Still put the type in typedefs, but don't add the function name\n\t\t\t\t\t\ttypedefs.setdefault(RedirectType(FunctionType(origLine)), [])\n\t\t\t\t\n\t\t\t\t# If the line is a structure metadata information...\n\t\t\t\t# FIXME: what happens with e.g. a Windows function?\n\t\t\t\telif ln.startswith(\"//%S\"):\n\t\t\t\t\tmetadata = [e for e in ln.split() if e]\n\t\t\t\t\tif len(metadata) != 4:\n\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (too many fields) ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\tif metadata[0] != \"//%S\":\n\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (invalid signature) ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\tif len(metadata[1]) != 1:\n\t\t\t\t\t\t# If you REALLY need it, consider opening a ticket\n\t\t\t\t\t\t# Before you do, consider that everything that is a valid in a C token is valid here too\n\t\t\t\t\t\traise NotImplementedError(\"Structure names cannot be of length greater than 1 ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\tif metadata[3] == \"\":\n\t\t\t\t\t\t# If you need this, please open an issue (this is never actually called, empty strings are removed)\n\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (empty replacement) ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\tif any(c not in conventions['F'].values for c in metadata[3]):\n\t\t\t\t\t\t# Note that replacement cannot be another structure type\n\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (invalid replacement) ({0}:{1})\".format(filename, line[:-1]))\n\t\t\t\t\tif metadata[1] in mystructs:\n\t\t\t\t\t\traise NotImplementedError(\"Invalid structure nickname {0} (duplicate) ({1}/{2})\".format(metadata[1], filename, line[:-1]))\n\t\t\t\t\tif (metadata[1] in conventions['F'].values) or (metadata[1] in ['0', '1']):\n\t\t\t\t\t\traise NotImplementedError(\"Invalid structure nickname {0} (reserved) ({1}/{2})\".format(metadata[1], filename, line[:-1]))\n\t\t\t\t\t\n\t\t\t\t\t# OK, add into the database\n\t\t\t\t\tmystructs[metadata[1]] = (StructType(metadata[2]), metadata[3])\n\t\t\t\t\n\t\t\t\t# If the line contains any symbol name...\n\t\t\t\telif (\"GO\" in ln) or (\"DATA\" in ln):\n\t\t\t\t\t# Probably \"//GO(..., \" or \"DATA(...,\" at least\n\t\t\t\t\ttry:\n\t\t\t\t\t\tfunname = ln.split('(')[1].split(',')[0].strip()\n\t\t\t\t\t\tadd_symbol_name(funname)\n\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t# Oops, it wasn't...\n\t\t\t\t\t\tpass\n\t\t\n\t\tadd_symbol_name(None)\n\t\n\tif halt_required:\n\t\traise ValueError(\"Fix all previous errors before proceeding\")\n\t\n\tif (\"\" not in gbl) or (\"\" not in redirects):\n\t\tprint(\"\\033[1;31mThere is suspiciously not many types...\\033[m\")\n\t\tprint(\"Check the CMakeLists.txt file. If you are SURE there is nothing wrong\"\n\t\t      \" (as a random example, `set()` resets the variable...), then comment out the following exit.\")\n\t\tprint(\"(Also, the program WILL crash later if you proceed.)\")\n\t\tsys.exit(2) # Check what you did, not proceeding\n\t\n\treturn gbl, redirects, filespec\n\ndef sortArrays(gbl_tmp : JumbledGlobals, red_tmp : JumbledRedirects, filespec: JumbledFilesSpecific) \\\n -> Tuple[SortedGlobals, SortedRedirects, SortedFilesSpecific]:\n\t# Now, take all function types, and make a new table gbl_vals\n\t# This table contains all #if conditions for when a function type needs to\n\t# be generated. There is also a filter to avoid duplicate/opposite clauses.\n\tgbl_vals: Dict[FunctionType, Clauses] = {}\n\tfor k1 in gbl_tmp:\n\t\tks = Clause(k1)\n\t\tfor v in gbl_tmp[k1]:\n\t\t\tif k1 == \"\":\n\t\t\t\t# Unconditionally define v\n\t\t\t\tgbl_vals[v] = Clauses()\n\t\t\t\t\n\t\t\telif v in gbl_vals:\n\t\t\t\tif gbl_vals[v].definess == []:\n\t\t\t\t\t# v already unconditionally defined\n\t\t\t\t\tcontinue\n\t\t\t\t\n\t\t\t\tfor other_key in gbl_vals[v].definess:\n\t\t\t\t\tfor other_key_val in other_key.defines:\n\t\t\t\t\t\tif other_key_val not in ks.defines:\n\t\t\t\t\t\t\t# Not a duplicate or more specific case\n\t\t\t\t\t\t\t# (could be a less specific one though)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tgbl_vals[v].add(ks)\n\t\t\t\t\n\t\t\telse:\n\t\t\t\tgbl_vals[v] = Clauses([Clause(k1)])\n\t\n\tfor v in gbl_vals:\n\t\tstrdefines = list(map(str, gbl_vals[v].definess))\n\t\tfor k2 in gbl_vals[v].definess:\n\t\t\tfor i in range(len(k2.defines)):\n\t\t\t\tif \" && \".join(map(str, k2.defines[:i] + [k2.defines[i].inverted()] + k2.defines[i+1:])) in strdefines:\n\t\t\t\t\t# Opposite clauses detected\n\t\t\t\t\tgbl_vals[v] = Clauses()\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tcontinue\n\t\t\tbreak\n\t\n\t# Now create a new gbl and gbl_idxs\n\t# gbl will contain the final version of gbl (without duplicates, based on\n\t# gbl_vals)\n\t# gbl_idxs will contain all #if clauses\n\tgbl: Dict[ClausesStr, List[FunctionType]] = {}\n\tgbl_idxs: List[ClausesStr] = []\n\tfor k1 in gbl_vals:\n\t\tclauses = gbl_vals[k1]\n\t\tkey = str(clauses)\n\t\tgbl.setdefault(key, [])\n\t\tgbl[key].append(k1)\n\t\tif key not in gbl_idxs:\n\t\t\tgbl_idxs.append(key)\n\t# Sort the #if clauses as defined in `splitdef`\n\tgbl_idxs.sort(key=lambda c: Clauses(c).splitdef())\n\t\n\t# This map will contain all additional function types that are \"redirected\"\n\t# to an already defined type (with some remapping).\n\tredirects_vals: Dict[Tuple[RedirectType, FunctionType], Clauses] = {}\n\tfor k1 in red_tmp:\n\t\tks = Clause(k1)\n\t\tfor v in red_tmp[k1]:\n\t\t\tif k1 == \"\":\n\t\t\t\t# Unconditionally define v\n\t\t\t\tredirects_vals[(v, red_tmp[k1][v])] = Clauses()\n\t\t\t\n\t\t\telif (v, red_tmp[k1][v]) in redirects_vals:\n\t\t\t\tif redirects_vals[(v, red_tmp[k1][v])].definess == []:\n\t\t\t\t\t# v already unconditionally defined\n\t\t\t\t\tcontinue\n\t\t\t\t\n\t\t\t\tfor other_key in redirects_vals[(v, red_tmp[k1][v])].definess:\n\t\t\t\t\tfor other_key_val in other_key.defines:\n\t\t\t\t\t\tif other_key_val not in ks.defines:\n\t\t\t\t\t\t\t# Not a duplicate or more specific case\n\t\t\t\t\t\t\t# (could be a less specific one though)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tredirects_vals[(v, red_tmp[k1][v])].add(ks)\n\t\t\t\n\t\t\telse:\n\t\t\t\tredirects_vals[(v, red_tmp[k1][v])] = Clauses([Clause(k1)])\n\t# Also do the same trick as before (it also helps keep the order\n\t# in the file deterministic)\n\tredirects: Dict[ClausesStr, List[Tuple[RedirectType, FunctionType]]] = {}\n\tredirects_idxs: List[ClausesStr] = []\n\tfor k1, v in redirects_vals:\n\t\tclauses = redirects_vals[(k1, v)]\n\t\tkey = str(clauses)\n\t\tredirects.setdefault(key, [])\n\t\tredirects[key].append((k1, v))\n\t\tif key not in redirects_idxs:\n\t\t\tredirects_idxs.append(key)\n\tredirects_idxs.sort(key=lambda c: Clauses(c).splitdef())\n\t\n\t# Sort the function types as defined in `splitchar`\n\tfor k3 in gbl:\n\t\tgbl[k3].sort(key=FunctionType.splitchar)\n\t\n\toldvals = { k: conventions[k].values for k in conventions }\n\tfor k in conventions:\n\t\tconventions[k].values = sortedvalues\n\tfor k3 in redirects:\n\t\tredirects[k3].sort(key=lambda v: v[0].splitchar() + v[1].splitchar())\n\tfor k in conventions:\n\t\tconventions[k].values = oldvals[k]\n\t\n\tsortedfilespec: SortedFilesSpecific = {}\n\tfor fn in filespec:\n\t\t# Maybe do better?\n\t\tmystructs_vals: List[str] = sorted(filespec[fn][1].keys())\n\t\tif mystructs_vals != []:\n\t\t\tfor k in conventions:\n\t\t\t\tconventions[k].values = conventions[k].values + list(mystructs_vals)\n\t\t\n\t\tmytypedefs_vals: List[RedirectType] = sorted(filespec[fn][0].keys(), key=FunctionType.splitchar)\n\t\tsortedfilespec[fn] = (\n\t\t\tCustOrderedDict(dict((v, sorted(filespec[fn][0][v])) for v in mytypedefs_vals), mytypedefs_vals),\n\t\t\tCustOrderedDict(filespec[fn][2], sorted(filespec[fn][2], key=FunctionType.splitchar))\n\t\t)\n\t\t\n\t\tif mystructs_vals != []:\n\t\t\tfor k in conventions:\n\t\t\t\tconventions[k].values = conventions[k].values[:-len(mystructs_vals)]\n\t\n\treturn CustOrderedDict(gbl, gbl_idxs), CustOrderedDict(redirects, redirects_idxs), sortedfilespec\n\ndef checkRun(root: str, jumbled: JumbledFilesSpecific, \\\n  gbls: SortedGlobals, redirects: SortedRedirects, filesspec: SortedFilesSpecific) -> Optional[str]:\n\t# Check if there was any new functions compared to last run\n\tfunctions_list: str = \"\"\n\tfor k in gbls:\n\t\tfor v in gbls[k]:\n\t\t\tfunctions_list = functions_list + \"#\" + k + \" \" + v + \"\\n\"\n\tfor k in redirects:\n\t\tfor vr, vf in redirects[k]:\n\t\t\tfunctions_list = functions_list + \"#\" + k + \" \" + vr + \" -> \" + vf + \"\\n\"\n\tfor filename in sorted(filesspec.keys()):\n\t\tfunctions_list = functions_list + filename + \":\\n\"\n\t\tfor st in sorted(jumbled[filename][1].keys()):\n\t\t\tfunctions_list = functions_list + \\\n\t\t\t\t\"% \" + st + \" \" + jumbled[filename][1][st][0] + \" \" + jumbled[filename][1][st][1] + \"\\n\"\n\t\tfor vr in filesspec[filename][0]:\n\t\t\tfunctions_list = functions_list + \"- \" + vr + \":\\n\"\n\t\t\tfor fn in filesspec[filename][0][vr]:\n\t\t\t\tfunctions_list = functions_list + \"  - \" + fn + \"\\n\"\n\t\tfor defined in filesspec[filename][1]:\n\t\t\tfunctions_list = functions_list + \"% \" + defined + \"\\n\"\n\t\n\t# functions_list is a unique string, compare it with the last run\n\ttry:\n\t\tlast_run = \"\"\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"functions_list.txt\"), 'r') as file:\n\t\t\tlast_run = file.read()\n\t\tif last_run == functions_list:\n\t\t\t# Mark as OK for CMake\n\t\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"functions_list.txt\"), 'w') as file:\n\t\t\t\tfile.write(functions_list)\n\t\t\treturn None\n\texcept IOError:\n\t\t# The file does not exist yet, first run\n\t\tpass\n\t\n\treturn functions_list\n\ndef main(root: str, files: Iterable[Filename], ver: str):\n\t\"\"\"\n\tmain -- The main function\n\t\n\troot: the root path (where the CMakeLists.txt is located)\n\tfiles: a list of files to parse (wrapped*.h)\n\tver: version number\n\t\"\"\"\n\t\n\t# gbl_tmp:\n\t#  \"defined() && ...\" -> [vFv, ...]\n\t# red_tmp:\n\t#  \"defined() && ...\" -> [vFEv -> vFv, ...]\n\t# fsp_tmp:\n\t#  \"filename\" -> (\n\t#   [vFEv -> fopen, ...],\n\t#   [G -> (\"SDL_J...\", UU), ...],\n\t#   [vFGppp -> vFUUppp, ...]\n\t#  )\n\tgbl_tmp: JumbledGlobals\n\tred_tmp: JumbledRedirects\n\tfsp_tmp: JumbledFilesSpecific\n\t\n\tgbl_tmp, red_tmp, fsp_tmp = readFiles(files)\n\t\n\t# gbls: sorted gbl_tmp\n\t# redirects: sorted red_tmp\n\t# filesspec:\n\t#  \"filename\" -> (\n\t#   sorted [vFEv -> fopen, ...],\n\t#   sorted [vFGppp -> vFUUppp, ...]\n\t#  )\n\tgbls     : SortedGlobals\n\tredirects: SortedRedirects\n\tfilesspec: SortedFilesSpecific\n\t\n\tgbls, redirects, filesspec = sortArrays(gbl_tmp, red_tmp, fsp_tmp)\n\t\n\tfunctions_list = checkRun(root, fsp_tmp, gbls, redirects, filesspec)\n\tif functions_list is None:\n\t\tprint(\"Detected same build as last run, skipping\")\n\t\treturn 0\n\t\n\t# Detect simple wrappings\n\tallowed_conv_ident = \"F\"\n\tallowed_conv = conventions[allowed_conv_ident]\n\t\n\t# H could be allowed maybe?\n\tallowed_simply: Dict[str, str] = {\"ARM64\": \"v\", \"RV64\": \"v\"}\n\tallowed_regs  : Dict[str, str] = {\"ARM64\": \"cCwWiuIUlLp\", \"RV64\": \"CWIUlLp\"}\n\tallowed_fpr   : Dict[str, str] = {\"ARM64\": \"fd\", \"RV64\": \"fd\"}\n\tallowed_sextw : Dict[str, str] = {\"ARM64\": \"\", \"RV64\": \"cwiu\"}\n\t\n\t# Detect functions which return in an x87 register\n\tretx87_wraps: Dict[ClausesStr, List[FunctionType]] = {}\n\treturn_x87: str = \"D\"\n\t\n\t# Sanity checks\n\tforbidden_simple: Dict[str, str] = {\"ARM64\": \"EDVOSNHPAxXYb\", \"RV64\": \"EDVOSNHPAxXYb\"}\n\tassert(all(k in allowed_simply for k in forbidden_simple))\n\tassert(all(k in allowed_regs for k in forbidden_simple))\n\tassert(all(k in allowed_fpr for k in forbidden_simple))\n\tfor k1 in forbidden_simple:\n\t\tassert(len(allowed_simply[k1]) + len(allowed_regs[k1]) + len(allowed_fpr[k1]) + len(allowed_sextw[k1]) + len(forbidden_simple[k1]) == len(allowed_conv.values))\n\t\tassert(all(c not in allowed_regs[k1] for c in allowed_simply[k1]))\n\t\tassert(all(c not in allowed_simply[k1] + allowed_regs[k1] for c in allowed_fpr[k1]))\n\t\tassert(all(c not in allowed_simply[k1] + allowed_regs[k1] + allowed_fpr[k1] for c in forbidden_simple[k1]))\n\t\tassert(all(c in allowed_simply[k1] + allowed_regs[k1] + allowed_fpr[k1] + allowed_sextw[k1] + forbidden_simple[k1] for c in allowed_conv.values))\n\tassert(all(c in allowed_conv.values for c in return_x87))\n\tassert(all(c in forbidden_simple[k] for c in depends_on_ld for k in forbidden_simple))\n\t\n\tsimple_wraps: Dict[str, Dict[ClausesStr, List[Tuple[FunctionType, int]]]] = {\n\t\tk1: {} for k1 in forbidden_simple\n\t}\n\t\n\tdef check_simple(v: FunctionType) -> Dict[str, int]:\n\t\tret: Dict[str, int] = {}\n\t\tfor k in forbidden_simple:\n\t\t\tregs_count: int = 0\n\t\t\tfpr_count : int = 0\n\t\t\tsextw_mask: int = 0\n    \t\t\n\t\t\tif v.get_convention() is not allowed_conv:\n\t\t\t\tcontinue\n\t\t\tif v[0] in forbidden_simple[k]:\n\t\t\t\tcontinue\n\t\t\tfor c in v[2:]:\n\t\t\t\tif c in allowed_regs[k]:\n\t\t\t\t\tregs_count = regs_count + 1\n\t\t\t\telif c in allowed_fpr[k]:\n\t\t\t\t\tfpr_count = fpr_count + 1\n\t\t\t\telif c in allowed_simply[k]:\n\t\t\t\t\tcontinue\n\t\t\t\telif c in allowed_sextw[k]:\n\t\t\t\t\tsextw_mask |= 1 << regs_count\n\t\t\t\t\tregs_count += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\t# No character in forbidden_simply\n\t\t\t\tif (regs_count <= 6) and (fpr_count <= 8):\n\t\t\t\t\t# All checks passed!\n\t\t\t\t\tret_val = 1 + fpr_count\n\t\t\t\t\tret_val |= sextw_mask << 4\n\t\t\t\t\tif v[0] in allowed_fpr[k]:\n\t\t\t\t\t\tret_val = -ret_val\n\t\t\t\t\tret[k] = ret_val\n\t\t\t\t# Else, too many arguments\n\t\treturn ret\n\t\n\t# Only search in real wrappers (mapped ones are nearly always not simple)\n\tfor k in gbls:\n\t\tfor v in gbls[k]:\n\t\t\tsimples = check_simple(v)\n\t\t\tfor k1, i in simples.items():\n\t\t\t\tif k in simple_wraps[k1]:\n\t\t\t\t\tsimple_wraps[k1][k].append((v, i))\n\t\t\t\telse:\n\t\t\t\t\tsimple_wraps[k1][k] = [(v, i)]\n\tsimple_idxs = { k1: sorted(v1.keys(), key=lambda x: Clauses(x).splitdef()) for k1, v1 in simple_wraps.items() }\n\t\n\tdef check_return_x87(v: FunctionType) -> bool:\n\t\treturn v[0] in return_x87\n    \n\tfor k in gbls:\n\t\ttmp = [v for v in gbls[k] if check_return_x87(v)]\n\t\tif tmp:\n\t\t\tretx87_wraps[k] = tmp\n\tretx87_idxs = sorted(retx87_wraps.keys(), key=lambda x: Clauses(x).splitdef())\n\t\n\t# Now the files rebuilding part\n\t# File headers and guards\n\tfiles_header = {\n\t\t\"wrapper.c\": \"\"\"\n\t\t#include <stdio.h>\n\t\t#include <stdlib.h>\n\t\t#include <stdint.h>\n\t\t\n\t\t#include \"wrapper.h\"\n\t\t#include \"emu/x64emu_private.h\"\n\t\t#include \"emu/x87emu_private.h\"\n\t\t#include \"regs.h\"\n\t\t#include \"x64emu.h\"\n\t\t#define COMPLEX_IMPL\n\t\t#include \"complext.h\"\n\t\t\n\t\textern void* my__IO_2_1_stdin_ ;\n\t\textern void* my__IO_2_1_stdout_;\n\t\textern void* my__IO_2_1_stderr_;\n\t\t\n\t\tstatic void* io_convert(void* v)\n\t\t{lbr}\n\t\t\tif(!v)\n\t\t\t\treturn v;\n\t\t\tif(v == my__IO_2_1_stdin_)\n\t\t\t\treturn stdin;\n\t\t\tif(v == my__IO_2_1_stdout_)\n\t\t\t\treturn stdout;\n\t\t\tif(v == my__IO_2_1_stderr_)\n\t\t\t\treturn stderr;\n\t\t\treturn v;\n\t\t{rbr}\n\t\t\n\t\tstatic void* io_convert_back(void* v)\n\t\t{lbr}\n\t\t\tif(!v)\n\t\t\t\treturn v;\n\t\t\tif(v == stdin)\n\t\t\t\treturn my__IO_2_1_stdin_;\n\t\t\tif(v == stdout)\n\t\t\t\treturn my__IO_2_1_stdout_;\n\t\t\tif(v == stderr)\n\t\t\t\treturn my__IO_2_1_stderr_;\n\t\t\treturn v;\n\t\t{rbr}\n\t\t\n\t\t#define ST0val ST0.d\n\t\t\n\t\tint of_convert(int);\n\t\tvoid* align_xcb_connection(void* src);\n\t\tvoid unalign_xcb_connection(void* src, void* dst);\n\t\t\n\t\t\"\"\",\n\t\t\"wrapper.h\": \"\"\"\n\t\t#ifndef __WRAPPER_H_\n\t\t#define __WRAPPER_H_\n\t\t#include <stdint.h>\n\t\t#include <string.h>\n\t\t#include \"complext.h\"\n\t\t\n\t\ttypedef struct x64emu_s x64emu_t;\n\t\t\n\t\t// the generic wrapper pointer functions\n\t\ttypedef void (*wrapper_t)(x64emu_t* emu, uintptr_t fnc);\n\n\t\n\t\t// list of defined wrapper\n\t\t// E = current x86emu struct\n\t\t// v = void\n\t\t// C = unsigned byte c = char\n\t\t// W = unsigned short w = short\n\t\t// u = uint32, i = int32\n\t\t// U = uint64, I = int64\n\t\t// L = unsigned long, l = signed long (long is an int with the size of a pointer)\n\t\t// H = Huge 128bits value/struct\n\t\t// p = pointer, P = void* on the stack\n\t\t// f = float, d = double, D = long double, K = fake long double\n\t\t// V = vaargs\n\t\t// O = libc O_ flags bitfield\n\t\t// o = stdout\n\t\t// S = _IO_2_1_stdXXX_ pointer (or FILE*)\n\t\t// N = ... automatically sending 1 arg\n\t\t// A = va_list\n\t\t// 0 = constant 0, 1 = constant 1\n\t\t// x = float complex\n\t\t// X = double complex\n\t\t// b = xcb_connection_t*\n\t\t\n\t\t\"\"\",\n\t\t\"fntypes.h\": \"\"\"\n\t\t#ifndef __{filename}TYPES_H_\n\t\t#define __{filename}TYPES_H_\n\t\t\n\t\t#ifndef LIBNAME\n\t\t#error You should only #include this file inside a wrapped*.c file\n\t\t#endif\n\t\t#ifndef ADDED_FUNCTIONS\n\t\t#define ADDED_FUNCTIONS() \n\t\t#endif\n\t\t\n\t\t\"\"\",\n\t\t\"fndefs.h\": \"\"\"\n\t\t#ifndef __{filename}DEFS_H_\n\t\t#define __{filename}DEFS_H_\n\t\t\n\t\t\"\"\",\n\t\t\"fnundefs.h\": \"\"\"\n\t\t#ifndef __{filename}UNDEFS_H_\n\t\t#define __{filename}UNDEFS_H_\n\t\t\n\t\t\"\"\"\n\t}\n\tfiles_guard = {\n\t\t\"wrapper.c\": \"\"\"\n\t\t\"\"\",\n\t\t\"wrapper.h\": \"\"\"\n\t\t\n\t\tint isSimpleWrapper(wrapper_t fun);\n\t\t\n\t\t#endif // __WRAPPER_H_\n\t\t\"\"\",\n\t\t\"fntypes.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}TYPES_H_\n\t\t\"\"\",\n\t\t\"fndefs.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}DEFS_H_\n\t\t\"\"\",\n\t\t\"fnundefs.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}UNDEFS_H_\n\t\t\"\"\"\n\t}\n\t\n\tbanner = \"/********************************************************\" + ('*'*len(ver)) + \"***\\n\" \\\n\t         \" * File automatically generated by rebuild_wrappers.py (v\" + ver + \") *\\n\" \\\n\t         \" ********************************************************\" + ('*'*len(ver)) + \"***/\\n\"\n\ttrim = lambda string: '\\n'.join(line[2:] for line in string.splitlines())[1:]\n\t# Yes, the for loops are inversed. This is because both dicts should have the same keys.\n\tfor fhdr in files_guard:\n\t\tfiles_header[fhdr] = banner + trim(files_header[fhdr])\n\tfor fhdr in files_header:\n\t\tfiles_guard[fhdr] = trim(files_guard[fhdr])\n\t\n\t# Rewrite the wrapper.c file:\n\t# i and u should only be 32 bits\n\ttd_types = {\n\t\t#      E            v       c         w          i          I          C          W           u           U           f        d         D              l           L            p        V        O          S        N      H                    P        A        x             X            Y             b\n\t\t'F': [\"x64emu_t*\", \"void\", \"int8_t\", \"int16_t\", \"int32_t\", \"int64_t\", \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\", \"float\", \"double\", \"long double\", \"intptr_t\", \"uintptr_t\", \"void*\", \"void*\", \"int32_t\", \"void*\", \"...\", \"unsigned __int128\", \"void*\", \"void*\", \"complexf_t\", \"complex_t\", \"complexl_t\", \"void*\"],\n\t\t#      E            v       c         w          i          I          C          W           u           U           f        d                        l           L            p        V        O          S        N                           P        A\n\t\t'W': [\"x64emu_t*\", \"void\", \"int8_t\", \"int16_t\", \"int32_t\", \"int64_t\", \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\", \"float\", \"double\",                \"intptr_t\", \"uintptr_t\", \"void*\", \"void*\", \"int32_t\", \"void*\", \"...\",                      \"void*\", \"void*\"]\n\t}\n\ttd_types_nold = {\n\t\t'F': {'D': \"double\", 'Y': \"complex_t\"},\n\t\t'W': {}\n\t}\n\ttd_types_ld = {\n\t\tk: {t: td_types[k][conventions[k].values.index(t)] for t in td_types_nold[k]} for k in td_types_nold\n\t}\n\tassert(all(k in conventions for k in td_types))\n\tassert(all(k in conventions for k in td_types_nold))\n\tassert(all(t in depends_on_ld for k in td_types_nold for t in td_types_nold[k]))\n\tfor k in conventions:\n\t\tif len(conventions[k].values) != len(td_types[k]):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(td_types) = {lentypes}\".format(lenval=len(conventions[k].values), lentypes=len(td_types[k])))\n\t\n\tdef generate_typedefs(arr: Iterable[FunctionType], file) -> None:\n\t\tany_depends_on_ld = False\n\t\tfor v in arr:\n\t\t\tif any(c in v for c in depends_on_ld):\n\t\t\t\tany_depends_on_ld = True\n\t\t\t\tcontinue\n\t\t\tname = v + \"_t\"\n\t\t\tv = v[:-1] if v.endswith('NN') else v # FIXME\n\t\t\tfile.write(\"typedef \" + td_types[v.get_convention().ident][v.get_convention().values.index(v[0])] + \" (*\" + name + \")\"\n\t\t\t\t+ \"(\" + ', '.join(td_types[v.get_convention().ident][v.get_convention().values.index(t)] for t in v[2:]) + \");\\n\")\n\t\tif any_depends_on_ld:\n\t\t\tfile.write(\"\\n#if defined(HAVE_LD80BITS) || defined(ANDROID)\\n\")\n\t\t\tfor v in arr:\n\t\t\t\tif all(c not in v for c in depends_on_ld):\n\t\t\t\t\tcontinue\n\t\t\t\tname = v + \"_t\"\n\t\t\t\tv = v[:-1] if v.endswith('NN') else v # FIXME\n\t\t\t\tfile.write(\"typedef \" + td_types[v.get_convention().ident][v.get_convention().values.index(v[0])] + \" (*\" + name + \")\"\n\t\t\t\t\t+ \"(\" + ', '.join(td_types[v.get_convention().ident][v.get_convention().values.index(t)] for t in v[2:]) + \");\\n\")\n\t\t\tfile.write(\"#else // !HAVE_LD80BITS && !ANDROID\\n\")\n\t\t\tfor k in td_types_nold:\n\t\t\t\tfor t in td_types_nold[k]:\n\t\t\t\t\ttd_types[k][conventions[k].values.index(t)] = td_types_nold[k][t]\n\t\t\tfor v in arr:\n\t\t\t\tif all(c not in v for c in depends_on_ld):\n\t\t\t\t\tcontinue\n\t\t\t\tname = v + \"_t\"\n\t\t\t\tv = v[:-1] if v.endswith('NN') else v # FIXME\n\t\t\t\tfile.write(\"typedef \" + td_types[v.get_convention().ident][v.get_convention().values.index(v[0])] + \" (*\" + name + \")\"\n\t\t\t\t\t+ \"(\" + ', '.join(td_types[v.get_convention().ident][v.get_convention().values.index(t)] for t in v[2:]) + \");\\n\")\n\t\t\tfor k in td_types_nold:\n\t\t\t\tfor t in td_types_ld[k]:\n\t\t\t\t\ttd_types[k][conventions[k].values.index(t)] = td_types_ld[k][t]\n\t\t\tfile.write(\"#endif\\n\")\n\t\n\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"wrapper.c\"), 'w') as file:\n\t\tfile.write(files_header[\"wrapper.c\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\t\n\t\t# First part: typedefs\n\t\tfor k in gbls:\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"\\n#if \" + k + \"\\n\")\n\t\t\tgenerate_typedefs(gbls[k], file)\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\n\t\tfile.write(\"\\n\")\n\t\t\n\t\t# Next part: function definitions\n\t\t\n\t\t# Helper variables\n\t\t# Return type template\n\t\tvals = {\n\t\t\tconventions['F']: [\n\t\t\t\t\"\\n#error Invalid return type: emulator\\n\",                # E\n\t\t\t\t\"fn({0});\",                                                # v\n\t\t\t\t\"R_RAX=(uint8_t)fn({0});\",                                 # c\n\t\t\t\t\"R_RAX=(uint16_t)fn({0});\",                                # w\n\t\t\t\t\"R_RAX=(uint32_t)fn({0});\",                                # i\n\t\t\t\t\"S_RAX=(int64_t)fn({0});\",                                 # I\n\t\t\t\t\"R_RAX=(unsigned char)fn({0});\",                           # C\n\t\t\t\t\"R_RAX=(unsigned short)fn({0});\",                          # W\n\t\t\t\t\"R_RAX=(uint32_t)fn({0});\",                                # u\n\t\t\t\t\"R_RAX=fn({0});\",                                          # U\n\t\t\t\t\"emu->xmm[0].f[0]=fn({0});\",                               # f\n\t\t\t\t\"emu->xmm[0].d[0]=fn({0});\",                               # d\n\t\t\t\t\"long double ld=fn({0}); fpu_do_push(emu); ST0val = ld;\",  # D\n\t\t\t\t\"R_RAX=(intptr_t)fn({0});\",                                # l\n\t\t\t\t\"R_RAX=(uintptr_t)fn({0});\",                               # L\n\t\t\t\t\"R_RAX=(uintptr_t)fn({0});\",                               # p\n\t\t\t\t\"\\n#error Invalid return type: va_list\\n\",                 # V\n\t\t\t\t\"\\n#error Invalid return type: at_flags\\n\",                # O\n\t\t\t\t\"R_RAX=(uintptr_t)io_convert_back(fn({0}));\",              # S\n\t\t\t\t\"\\n#error Invalid return type: ... with 1 arg\\n\",          # N\n\t\t\t\t\"unsigned __int128 u128 = fn({0}); R_RAX=(u128&0xFFFFFFFFFFFFFFFFL); R_RDX=(u128>>64)&0xFFFFFFFFFFFFFFFFL;\", # H\n\t\t\t\t\"\\n#error Invalid return type: pointer in the stack\\n\",    # P\n\t\t\t\t\"\\n#error Invalid return type: va_list\\n\",                 # A\n\t\t\t\t\"from_complexf(emu, fn({0}));\",                            # x\n\t\t\t\t\"from_complex(emu, fn({0}));\",                             # X\n\t\t\t\t\"from_complexl(emu, fn({0}));\",                            # Y\n\t\t\t\t\"\\n#error Invalid return type: xcb_connection_t*\\n\",       # b\n\t\t\t],\n\t\t\tconventions['W']: [\n\t\t\t\t\"\\n#error Invalid return type: emulator\\n\",                # E\n\t\t\t\t\"fn({0});\",                                                # v\n\t\t\t\t\"R_RAX=fn({0});\",                                          # c\n\t\t\t\t\"R_RAX=fn({0});\",                                          # w\n\t\t\t\t\"R_RAX=(int32_t)fn({0});\",                                 # i\n\t\t\t\t\"R_RAX=(int64_t)fn({0});\",                                 # I\n\t\t\t\t\"R_RAX=(unsigned char)fn({0});\",                           # C\n\t\t\t\t\"R_RAX=(unsigned short)fn({0});\",                          # W\n\t\t\t\t\"R_RAX=(uint32_t)fn({0});\",                                # u\n\t\t\t\t\"R_RAX=fn({0});\",                                          # U\n\t\t\t\t\"emu->xmm[0].f[0]=fn({0});\",                               # f\n\t\t\t\t\"emu->xmm[0].d[0]=fn({0});\",                               # d\n\t\t\t\t\"R_RAX=(intptr_t)fn({0});\",                                # l\n\t\t\t\t\"R_RAX=(uintptr_t)fn({0});\",                               # L\n\t\t\t\t\"R_RAX=(uintptr_t)fn({0});\",                               # p\n\t\t\t\t\"\\n#error Invalid return type: va_list\\n\",                 # V\n\t\t\t\t\"\\n#error Invalid return type: at_flags\\n\",                # O\n\t\t\t\t\"R_RAX=io_convert_back(fn({0}));\",                         # S\n\t\t\t\t\"\\n#error Invalid return type: ... with 1 arg\\n\",          # N\n\t\t\t\t\"\\n#error Invalid return type: pointer in the stack\\n\",    # P\n\t\t\t\t\"\\n#error Invalid return type: va_list\\n\",                 # A\n\t\t\t]\n\t\t}\n\t\tvals_nold = {\n\t\t\tconventions['F']: {\n\t\t\t\t'D': \"double db=fn({0}); fpu_do_push(emu); ST0val = db;\",\n\t\t\t\t'Y': \"from_complexk(emu, fn({0}));\",\n\t\t\t},\n\t\t\tconventions['W']: {}\n\t\t}\n\t\tvals_android = {\n\t\t\tconventions['F']: {\n\t\t\t\t\"D\": \"long double ld=fn({0}); emu->xmm[0].u128=*(__uint128_t*)&ld;\",\n\t\t\t\t\"Y\": \"from_complexl(emu, fn({0}));\",\n\t\t\t},\n\t\t\tconventions['W']: {}\n\t\t}\n\t\tvals_ld = {\n\t\t\tk: {t: vals[k][k.values.index(t)] for t in vals_nold[k]} for k in vals_nold\n\t\t}\n\t\t\n\t\t# vreg: value is in a general register\n\t\t#         E  v  c  w  i  I  C  W  u  U  f  d  D  l  L  p  V  O  S  N  H  P  A  x  X  Y  b\n\t\tvreg   = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 2, 0, 1, 0, 0, 0, 1]\n\t\t# vxmm: value is in a XMM register\n\t\t#         E  v  c  w  i  I  C  W  u  U  f  d  D  l  L  p  V  O  S  N  H  P  A  x  X  Y  b\n\t\tvxmm   = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0]\n\t\t# vother: value is elsewere\n\t\t#         E  v  c  w  i  I  C  W  u  U  f  d  D  l  L  p  V  O  S  N  H  P  A  x  X  Y  b\n\t\tvother = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\t\t# vstack: value is on the stack (or out of register)\n\t\t#         E  v  c  w  i  I  C  W  u  U  f  d  D  l  L  p  V  O  S  N  H  P  A  x  X  Y  b\n\t\tvstack = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1, 2, 4, 1]\n\t\targ_r = [\n\t\t\t\"\",                            # E\n\t\t\t\"\",                            # v\n\t\t\t\"(int8_t){p}, \",               # c\n\t\t\t\"(int16_t){p}, \",              # w\n\t\t\t\"(int32_t){p}, \",              # i\n\t\t\t\"(int64_t){p}, \",              # I\n\t\t\t\"(uint8_t){p}, \",              # C\n\t\t\t\"(uint16_t){p}, \",             # W\n\t\t\t\"(uint32_t){p}, \",             # u\n\t\t\t\"(uint64_t){p}, \",             # U\n\t\t\t\"\",                            # f\n\t\t\t\"\",                            # d\n\t\t\t\"\",                            # D\n\t\t\t\"(intptr_t){p}, \",             # l\n\t\t\t\"(uintptr_t){p}, \",            # L\n\t\t\t\"(void*){p}, \",                # p\n\t\t\t\"\",                            # V\n\t\t\t\"of_convert((int32_t){p}), \",  # O\n\t\t\t\"io_convert((void*){p}), \",    # S\n\t\t\t\"(void*){p}, \",                # N\n\t\t\t\"(unsigned __int128){p} + ((unsigned __int128){p2} << 64), \", # H\n\t\t\t\"\",                            # P\n\t\t\t\"(void*){p}, \",                # A\n\t\t\t\"\",                            # x\n\t\t\t\"\",                            # X\n\t\t\t\"\",                            # Y\n\t\t\t\"aligned_xcb, \",               # b\n\t\t]\n\t\targ_x = [\n\t\t\t\"\",                       # E\n\t\t\t\"\",                       # v\n\t\t\t\"\",                       # c\n\t\t\t\"\",                       # w\n\t\t\t\"\",                       # i\n\t\t\t\"\",                       # I\n\t\t\t\"\",                       # C\n\t\t\t\"\",                       # W\n\t\t\t\"\",                       # u\n\t\t\t\"\",                       # U\n\t\t\t\"emu->xmm[{p}].f[0], \",   # f\n\t\t\t\"emu->xmm[{p}].d[0], \",   # d\n\t\t\t\"\",                       # D\n\t\t\t\"\",                       # l\n\t\t\t\"\",                       # L\n\t\t\t\"\",                       # p\n\t\t\t\"\",                       # V\n\t\t\t\"\",                       # O\n\t\t\t\"\",                       # S\n\t\t\t\"\",                       # N\n\t\t\t\"\",                       # H\n\t\t\t\"\",                       # P\n\t\t\t\"\",                       # A\n\t\t\t\"to_complexf(emu, {p}), \", # x\n\t\t\t\"to_complex(emu, {p}), \",  # X\n\t\t\t\"\",                       # Y\n\t\t\t\"\",                       # b\n\t\t]\n\t\targ_o = [\n\t\t\t\"emu, \",                  # E\n\t\t\t\"\",                       # v\n\t\t\t\"\",                       # c\n\t\t\t\"\",                       # w\n\t\t\t\"\",                       # i\n\t\t\t\"\",                       # I\n\t\t\t\"\",                       # C\n\t\t\t\"\",                       # W\n\t\t\t\"\",                       # u\n\t\t\t\"\",                       # U\n\t\t\t\"\",                       # f\n\t\t\t\"\",                       # d\n\t\t\t\"\",                       # D\n\t\t\t\"\",                       # l\n\t\t\t\"\",                       # L\n\t\t\t\"\",                       # p\n\t\t\t\"(void*)(R_RSP + {p}), \", # V\n\t\t\t\"\",                       # O\n\t\t\t\"\",                       # S\n\t\t\t\"\",                       # N\n\t\t\t\"\",                       # H\n\t\t\t\"\",                       # P\n\t\t\t\"\",                       # A\n\t\t\t\"\",                       # x\n\t\t\t\"\",                       # X\n\t\t\t\"\",                       # Y\n\t\t\t\"\",                       # b\n\t\t]\n\t\targ_s = [\n\t\t\t\"\",                                         # E\n\t\t\t\"\",                                         # v\n\t\t\t\"*(int8_t*)(R_RSP + {p}), \",                # c\n\t\t\t\"*(int16_t*)(R_RSP + {p}), \",               # w\n\t\t\t\"*(int32_t*)(R_RSP + {p}), \",               # i\n\t\t\t\"*(int64_t*)(R_RSP + {p}), \",               # I\n\t\t\t\"*(uint8_t*)(R_RSP + {p}), \",               # C\n\t\t\t\"*(uint16_t*)(R_RSP + {p}), \",              # W\n\t\t\t\"*(uint32_t*)(R_RSP + {p}), \",              # u\n\t\t\t\"*(uint64_t*)(R_RSP + {p}), \",              # U\n\t\t\t\"*(float*)(R_RSP + {p}), \",                 # f\n\t\t\t\"*(double*)(R_RSP + {p}), \",                # d\n\t\t\t\"LD2localLD((void*)(R_RSP + {p})), \",       # D\n\t\t\t\"*(intptr_t*)(R_RSP + {p}), \",              # l\n\t\t\t\"*(uintptr_t*)(R_RSP + {p}), \",             # L\n\t\t\t\"*(void**)(R_RSP + {p}), \",                 # p\n\t\t\t\"\",                                         # V\n\t\t\t\"of_convert(*(int32_t*)(R_RSP + {p})), \",   # O\n\t\t\t\"io_convert(*(void**)(R_RSP + {p})), \",     # S\n\t\t\t\"*(void**)(R_RSP + {p}), \",                 # N\n\t\t\t\"*(unsigned __int128*)(R_RSP + {p}), \",     # H\n\t\t\t\"*(void**)(R_RSP + {p}), \",                 # P\n\t\t\t\"*(void**)(R_RSP + {p}), \",                 # A\n\t\t\t\"*(complexf_t*)(R_RSP + {p}), \",            # x\n\t\t\t\"*(complex_t*)(R_RSP + {p}), \",             # X\n\t\t\t\"to_complexl(emu, R_RSP + {p}), \",          # Y\n\t\t\t\"aligned_xcb, \",                            # b\n\t\t]\n\t\targ_s_nold = {\n\t\t\t'D': \"FromLD((void*)(R_RSP + {p})), \",      # K\n\t\t\t'Y': \"to_complexk(emu, R_RSP + {p}), \",     # y\n\t\t}\n\t\targ_s_android = {\n\t\t\t'D': \"*(long double*)(R_RSP + {p})], \",\n\t\t\t'Y': \"to_complexl(emu, R_RSP + {p}), \",\n\t\t}\n\t\targ_s_ld = {\n\t\t\tt: arg_s[conventions['F'].values.index(t)] for t in arg_s_nold\n\t\t}\n\t\tvxmm_noandroid = vxmm[:]\n\t\tvxmm_android = vxmm[:]\n\t\tvxmm_android[conventions['F'].values.index('D')] = 1\n\t\tvxmm_android[conventions['F'].values.index('Y')] = 1\n\t\targ_x_android = {\n\t\t\t'D': \"*(long double*)&emu->xmm[{p}], \",\n\t\t\t'Y': \"to_complexl(emu, (uintptr_t)&emu->xmm[{p}]), \",\n\t\t}\n\t\targ_x_ld = {\n\t\t\tt: arg_x[conventions['F'].values.index(t)] for t in arg_x_android\n\t\t}\n\t\t\n\t\t# Asserts\n\t\tfor k in conventions:\n\t\t\tassert all(v in conventions['F'].values for v in conventions[k].values), \"a convention is not a subset of System V\"\n\t\tassert all(vr == vs for (vr, vs) in zip(vreg, vstack) if vr != 0), \"vreg and vstack are inconsistent\"\n\t\tassert all(vx == vs for (vx, vs) in zip(vxmm, vstack) if vx != 0), \"vxmm and vstack are inconsistent\"\n\t\tassert all((vo == 0) == (vs != 0) for (vo, vs) in zip(vother, vstack)), \"vother and vstack are inconsistent\"\n\t\tif len(conventions['F'].values) != len(vstack):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(vstack) = {lenvstack}\".format(lenval=len(conventions['F'].values), lenvstack=len(vstack)))\n\t\tif len(conventions['F'].values) != len(vreg):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(vreg) = {lenvreg}\".format(lenval=len(conventions['F'].values), lenvreg=len(vreg)))\n\t\tif len(conventions['F'].values) != len(vxmm):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(vxmm) = {lenvxmm}\".format(lenval=len(conventions['F'].values), lenvxmm=len(vxmm)))\n\t\tif len(conventions['F'].values) != len(vother):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(vother) = {lenvother}\".format(lenval=len(conventions['F'].values), lenvother=len(vother)))\n\t\tif len(conventions['F'].values) != len(arg_s):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(arg_s) = {lenargs}\".format(lenval=len(conventions['F'].values), lenargs=len(arg_s)))\n\t\tif len(conventions['F'].values) != len(arg_r):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(arg_r) = {lenargr}\".format(lenval=len(conventions['F'].values), lenargr=len(arg_r)))\n\t\tif len(conventions['F'].values) != len(arg_x):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(arg_x) = {lenargx}\".format(lenval=len(conventions['F'].values), lenargx=len(arg_x)))\n\t\tif len(conventions['F'].values) != len(arg_o):\n\t\t\traise NotImplementedError(\"len(values) = {lenval} != len(arg_o) = {lenargo}\".format(lenval=len(conventions['F'].values), lenargo=len(arg_o)))\n\t\tfor k in conventions:\n\t\t\tc = conventions[k]\n\t\t\tif c not in vals:\n\t\t\t\traise NotImplementedError(\"convention {k} not in vals\".format(k=k))\n\t\t\tif len(c.values) != len(vals[c]):\n\t\t\t\traise NotImplementedError(\"len([{k}]values) = {lenval} != len(vals[...]) = {lenvals}\".format(k=k, lenval=len(c.values), lenvals=len(vals[c])))\n\t\t# When arg_* is not empty, v* should not be 0\n\t\tif any(map(lambda v, a: (a != \"\") and (v == 0), vstack, arg_s)):\n\t\t\traise NotImplementedError(\"Something in the stack has a null offset and a non-empty arg string\")\n\t\tif any(map(lambda v, a: (a != \"\") and (v == 0), vreg, arg_r)):\n\t\t\traise NotImplementedError(\"Something in the stack has a null offset and a non-empty arg string\")\n\t\tif any(map(lambda v, a: (a != \"\") and (v == 0), vxmm, arg_x)):\n\t\t\traise NotImplementedError(\"Something in the stack has a null offset and a non-empty arg string\")\n\t\tif any(map(lambda v, a: (a != \"\") and (v == 0), vother, arg_o)):\n\t\t\traise NotImplementedError(\"Something in the stack has a null offset and a non-empty arg string\")\n\t\t# Everything is either in the stack or somewhere else, it cannot be in a GPr and in an XMMr, etc\n\t\tif any(map(lambda o, s: (o == 0) == (s == 0), vother, vstack)):\n\t\t\traise NotImplementedError(\"Something cannot be in exactly one of the stack and somewhere else\")\n\t\tif any(map(lambda r, x: (r > 0) and (x > 0), vreg, vxmm)):\n\t\t\traise NotImplementedError(\"Something can be in both a general purpose register and in an XMM register\")\n\t\tif any(map(lambda r, s: (r > 0) and (s == 0), vreg, vstack)):\n\t\t\traise NotImplementedError(\"Something can be in a general purpose register but not in the stack\")\n\t\tif any(map(lambda x, s: (x > 0) and (s == 0), vxmm, vstack)):\n\t\t\traise NotImplementedError(\"Something can be in an XMM register but not in the stack\")\n\t\t\n\t\t# Helper functions to write the function definitions\n\t\tsystemVconv = conventions['F']\n\t\tdef function_pre_systemV(args: FunctionType, d: int = 8, r: int = 0, x: int = 0) -> Tuple[Optional[str], str]:\n\t\t\t# args: string of argument types\n\t\t\t# d: delta (in the stack)\n\t\t\t# r: general register no\n\t\t\t# x: XMM register no\n\t\t\tif len(args) == 0:\n\t\t\t\treturn None, \"\"\n\t\t\t\n\t\t\t# Redirections\n\t\t\tif args[0] == \"0\":\n\t\t\t\treturn function_pre_systemV(args[1:], d, r, x)\n\t\t\telif args[0] == \"1\":\n\t\t\t\treturn function_pre_systemV(args[1:], d, r, x)\n\t\t\t\n\t\t\tidx = systemVconv.values.index(args[0])\n\t\t\t# Name of the registers\n\t\t\treg_arg = [\"R_RDI\", \"R_RSI\", \"R_RDX\", \"R_RCX\", \"R_R8\", \"R_R9\"]\n\t\t\tif args[0] == \"b\":\n\t\t\t\tif 'b' in args[1:]:\n\t\t\t\t\traise NotImplementedError(\"Multiple XCB connections unsupported\")\n\t\t\t\tcontent = \"\"\n\t\t\t\tif r < len(reg_arg):\n\t\t\t\t\tcontent = reg_arg[r]\n\t\t\t\telse:\n\t\t\t\t\tcontent = \"(R_RSP + \" + str(d) + \")\"\n\t\t\t\treturn \"(void*)\" + content, f\"void *aligned_xcb = align_xcb_connection((void*){content}); \"\n\t\t\telif (r < len(reg_arg)) and (vreg[idx] > 0):\n\t\t\t\tfor _ in range(vreg[idx]):\n\t\t\t\t\tif r < len(reg_arg):\n\t\t\t\t\t\tr = r + 1\n\t\t\t\t\telse:\n\t\t\t\t\t\td = d + 8\n\t\t\t\treturn function_pre_systemV(args[1:], d, r, x)\n\t\t\telif (x < 8) and (vxmm[idx] > 0):\n\t\t\t\treturn function_pre_systemV(args[1:], d, r, x+1)\n\t\t\telif vstack[idx] > 0:\n\t\t\t\treturn function_pre_systemV(args[1:], d+8*vstack[idx], r, x)\n\t\t\telse:\n\t\t\t\treturn function_pre_systemV(args[1:], d, r, x)\n\t\tdef function_post_systemV(content: Optional[str]) -> str:\n\t\t\tif content is not None:\n\t\t\t\treturn f\" unalign_xcb_connection(aligned_xcb, {content});\"\n\t\t\telse:\n\t\t\t\treturn \"\"\n\t\tdef function_args_systemV(args: FunctionType, d: int = 8, r: int = 0, x: int = 0) -> str:\n\t\t\t# args: string of argument types\n\t\t\t# d: delta (in the stack)\n\t\t\t# r: general register no\n\t\t\t# x: XMM register no\n\t\t\tif len(args) == 0:\n\t\t\t\treturn \"\"\n\t\t\t\n\t\t\t# Redirections\n\t\t\tif args[0] == \"0\":\n\t\t\t\treturn \"0, \" + function_args_systemV(args[1:], d, r, x)\n\t\t\telif args[0] == \"1\":\n\t\t\t\treturn \"1, \" + function_args_systemV(args[1:], d, r, x)\n\t\t\t\n\t\t\tidx = systemVconv.values.index(args[0])\n\t\t\t# Name of the registers\n\t\t\treg_arg = [\"R_RDI\", \"R_RSI\", \"R_RDX\", \"R_RCX\", \"R_R8\", \"R_R9\"]\n\t\t\tif (r < len(reg_arg)) and (vreg[idx] > 0):\n\t\t\t\tret = \"\"\n\t\t\t\tif (vreg[idx] == 2) and (\"{p2}\" in arg_r[idx]):\n\t\t\t\t\tif r < len(reg_arg):\n\t\t\t\t\t\t# Value is in a general register\n\t\t\t\t\t\tret = ret + arg_r[idx].format(p=reg_arg[r], p2=reg_arg[r+1])\n\t\t\t\t\t\tr = r + 2\n\t\t\t\t\telse:\n\t\t\t\t\t\t# Remaining is in the stack\n\t\t\t\t\t\tret = ret + arg_s[idx].format(p=d)\n\t\t\t\t\t\td = d + 8\n\t\t\t\telse:\n\t\t\t\t\tfor _ in range(vreg[idx]):\n\t\t\t\t\t\t# There may be values in multiple registers\n\t\t\t\t\t\tif r < len(reg_arg):\n\t\t\t\t\t\t\t# Value is in a general register\n\t\t\t\t\t\t\tret = ret + arg_r[idx].format(p=reg_arg[r])\n\t\t\t\t\t\t\tr = r + 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t# Remaining is in the stack\n\t\t\t\t\t\t\tret = ret + arg_s[idx].format(p=d)\n\t\t\t\t\t\t\td = d + 8\n\t\t\t\treturn ret + function_args_systemV(args[1:], d, r, x)\n\t\t\telif (x < 8) and (vxmm[idx] > 0):\n\t\t\t\t# Value is in an XMM register\n\t\t\t\treturn arg_x[idx].format(p=x) + function_args_systemV(args[1:], d, r, x+vxmm[idx])\n\t\t\telif vstack[idx] > 0:\n\t\t\t\t# Value is in the stack\n\t\t\t\treturn arg_s[idx].format(p=d) + function_args_systemV(args[1:], d+8*vstack[idx], r, x)\n\t\t\telse:\n\t\t\t\t# Value is somewhere else\n\t\t\t\treturn arg_o[idx].format(p=d) + function_args_systemV(args[1:], d, r, x)\n\t\t# windowsconv = conventions['W']\n\t\tdef function_args_windows(args: FunctionType, d: int = 40, r: int = 0) -> str:\n\t\t\t# args: string of argument types\n\t\t\t# d: delta (in the stack)\n\t\t\t# r: general register no\n\t\t\t# We can re-use vstack to know if we need to put a pointer or the value\n\t\t\tif len(args) == 0:\n\t\t\t\treturn \"\"\n\t\t\t\n\t\t\t# Redirections\n\t\t\tif args[0] == \"0\":\n\t\t\t\treturn \"0, \" + function_args_windows(args[1:], d, r)\n\t\t\telif args[0] == \"1\":\n\t\t\t\treturn \"1, \" + function_args_windows(args[1:], d, r)\n\t\t\t\n\t\t\tidx = systemVconv.values.index(args[0]) # Little hack to be able to re-use\n\t\t\t# Name of the registers\n\t\t\treg_arg = [\"R_RCX\", \"R_RDX\", \"R_R8\", \"R_R9\"]\n\t\t\tif (r < len(reg_arg)) and (vstack[idx] == 1):\n\t\t\t\t# We use a register\n\t\t\t\tif vreg[idx] == 1:\n\t\t\t\t\t# Value is in a general register\n\t\t\t\t\treturn arg_r[idx].format(p=reg_arg[r]) + function_args_windows(args[1:], d, r+1)\n\t\t\t\telse:\n\t\t\t\t\t# Remaining is in an XMM register\n\t\t\t\t\treturn arg_x[idx].format(p=r) + function_args_windows(args[1:], d, r+1)\n\t\t\telif vstack[idx] > 0:\n\t\t\t\t# Value is in the stack\n\t\t\t\treturn arg_s[idx].format(p=d) + function_args_windows(args[1:], d+8*vstack[idx], r)\n\t\t\telse:\n\t\t\t\t# Value is somewhere else\n\t\t\t\treturn arg_o[idx].format(p=d) + function_args_windows(args[1:], d, r)\n\t\t\n\t\tdef function_writer(f, N: FunctionType, W: str) -> None:\n\t\t\t# Write to f the function type N (real type W)\n\t\t\t\n\t\t\tf.write(\"void {0}(x64emu_t *emu, uintptr_t fcn) {2} {1} fn = ({1})fcn; \".format(N, W, \"{\"))\n\t\t\t# Generic function\n\t\t\tconv = N.get_convention()\n\t\t\tif conv is systemVconv:\n\t\t\t\tprepost, pre = function_pre_systemV(N[2:])\n\t\t\t\tf.write(pre + vals[conv][conv.values.index(N[0])].format(function_args_systemV(N[2:])[:-2]) + function_post_systemV(prepost))\n\t\t\telse:\n\t\t\t\tf.write(vals[conv][conv.values.index(N[0])].format(function_args_windows(N[2:])[:-2]))\n\t\t\tf.write(\" }\\n\")\n\t\t\n\t\tfor k in gbls:\n\t\t\tany_depends_on_ld = False\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"\\n#if \" + k + \"\\n\")\n\t\t\tfor v in gbls[k]:\n\t\t\t\tif any(c in v for c in depends_on_ld):\n\t\t\t\t\tany_depends_on_ld = True\n\t\t\t\t\tcontinue\n\t\t\t\tif v == FunctionType(\"vFv\"):\n\t\t\t\t\t# Suppress all warnings...\n\t\t\t\t\tfile.write(\"void vFv(x64emu_t *emu, uintptr_t fcn) { vFv_t fn = (vFv_t)fcn; fn(); (void)emu; }\\n\")\n\t\t\t\telse:\n\t\t\t\t\tfunction_writer(file, v, v + \"_t\")\n\t\t\tif any_depends_on_ld:\n\t\t\t\tfile.write(\"\\n#if defined(ANDROID)\\n\")\n\t\t\t\tfor c in vals_android:\n\t\t\t\t\tfor t in vals_android[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_android[c][t]\n\t\t\t\tfor t in arg_s_android:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_android[t]\n\t\t\t\tfor t in arg_x_android:\n\t\t\t\t\targ_x[conventions['F'].values.index(t)] = arg_x_android[t]\n\t\t\t\tvxmm = vxmm_android\n\t\t\t\tfor v in gbls[k]:\n\t\t\t\t\tif all(c not in v for c in depends_on_ld):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif v == FunctionType(\"vFv\"):\n\t\t\t\t\t\t# Suppress all warnings...\n\t\t\t\t\t\tfile.write(\"void vFv(x64emu_t *emu, uintptr_t fcn) { vFv_t fn = (vFv_t)fcn; fn(); (void)emu; }\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tfunction_writer(file, v, v + \"_t\")\n\t\t\t\tfile.write(\"#elif !defined(HAVE_LD80BITS)\\n\")\n\t\t\t\tfor c in vals_android:\n\t\t\t\t\tfor t in vals_ld[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_ld[c][t]\n\t\t\t\tfor c in vals_nold:\n\t\t\t\t\tfor t in vals_nold[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_nold[c][t]\n\t\t\t\tfor t in arg_s_android:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_ld[t]\n\t\t\t\tfor t in arg_s_nold:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_nold[t]\n\t\t\t\tfor t in arg_x_android:\n\t\t\t\t\targ_x[conventions['F'].values.index(t)] = arg_x_ld[t]\n\t\t\t\tvxmm = vxmm_noandroid\n\t\t\t\tfor v in gbls[k]:\n\t\t\t\t\tif all(c not in v for c in depends_on_ld):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif v == FunctionType(\"vFv\"):\n\t\t\t\t\t\t# Suppress all warnings...\n\t\t\t\t\t\tfile.write(\"void vFv(x64emu_t *emu, uintptr_t fcn) { vFv_t fn = (vFv_t)fcn; fn(); (void)emu; }\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tfunction_writer(file, v, v + \"_t\")\n\t\t\t\tfor c in vals_nold:\n\t\t\t\t\tfor t in vals_nold[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_ld[c][t]\n\t\t\t\tfor t in arg_s_nold:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_ld[t]\n\t\t\t\tfile.write(\"#else // defined(HAVE_LD80BITS) && !defined(ANDROID)\\n\")\n\t\t\t\tfor v in gbls[k]:\n\t\t\t\t\tif all(c not in v for c in depends_on_ld):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tif v == FunctionType(\"vFv\"):\n\t\t\t\t\t\t# Suppress all warnings...\n\t\t\t\t\t\tfile.write(\"void vFv(x64emu_t *emu, uintptr_t fcn) { vFv_t fn = (vFv_t)fcn; fn(); (void)emu; }\\n\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tfunction_writer(file, v, v + \"_t\")\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\n\")\n\t\tfor k in redirects:\n\t\t\tany_depends_on_ld = False\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"\\n#if \" + k + \"\\n\")\n\t\t\tfor vr, vf in redirects[k]:\n\t\t\t\tif any(c in vr for c in depends_on_ld):\n\t\t\t\t\tany_depends_on_ld = True\n\t\t\t\t\tcontinue\n\t\t\t\tfunction_writer(file, vr, vf + \"_t\")\n\t\t\tif any_depends_on_ld:\n\t\t\t\tfile.write(\"\\n#if defined(ANDROID)\\n\")\n\t\t\t\tfor c in vals_android:\n\t\t\t\t\tfor t in vals_android[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_android[c][t]\n\t\t\t\tfor t in arg_s_android:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_android[t]\n\t\t\t\tfor t in arg_x_android:\n\t\t\t\t\targ_x[conventions['F'].values.index(t)] = arg_x_android[t]\n\t\t\t\tvxmm = vxmm_android\n\t\t\t\tfor vr, vf in redirects[k]:\n\t\t\t\t\tif all(c not in vr for c in depends_on_ld):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfunction_writer(file, vr, vf + \"_t\")\n\t\t\t\tfile.write(\"#elif !defined(HAVE_LD80BITS)\\n\")\n\t\t\t\tfor c in vals_android:\n\t\t\t\t\tfor t in vals_ld[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_ld[c][t]\n\t\t\t\tfor c in vals_nold:\n\t\t\t\t\tfor t in vals_nold[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_nold[c][t]\n\t\t\t\tfor t in arg_s_android:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_ld[t]\n\t\t\t\tfor t in arg_s_nold:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_nold[t]\n\t\t\t\tfor t in arg_x_android:\n\t\t\t\t\targ_x[conventions['F'].values.index(t)] = arg_x_ld[t]\n\t\t\t\tvxmm = vxmm_noandroid\n\t\t\t\tfor vr, vf in redirects[k]:\n\t\t\t\t\tif all(c not in vr for c in depends_on_ld):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfunction_writer(file, vr, vf + \"_t\")\n\t\t\t\tfor c in vals_nold:\n\t\t\t\t\tfor t in vals_nold[c]:\n\t\t\t\t\t\tvals[c][c.values.index(t)] = vals_ld[c][t]\n\t\t\t\tfor t in arg_s_nold:\n\t\t\t\t\targ_s[conventions['F'].values.index(t)] = arg_s_ld[t]\n\t\t\t\tfile.write(\"#else // defined(HAVE_LD80BITS) && !defined(ANDROID)\\n\")\n\t\t\t\tfor vr, vf in redirects[k]:\n\t\t\t\t\tif all(c not in vr for c in depends_on_ld):\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tfunction_writer(file, vr, vf + \"_t\")\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\n\t\t# Write the isSimpleWrapper function\n\t\tinttext = \"\"\n\t\tfile.write(\"\\n\")\n\t\tfor k1 in simple_idxs:\n\t\t\tfile.write(\"#{inttext}if defined({k1})\\nint isSimpleWrapper(wrapper_t fun) {{\\n\\tif (box64_is32bits) return 0;\\n\".format(inttext=inttext, k1=k1))\n\t\t\tinttext = \"el\"\n\t\t\tfor k in simple_idxs[k1]:\n\t\t\t\tif k != str(Clauses()):\n\t\t\t\t\tfile.write(\"#if \" + k + \"\\n\")\n\t\t\t\tfor vf, val in simple_wraps[k1][k]:\n\t\t\t\t\tfile.write(\"\\tif (fun == &\" + vf + \") return \" + str(val) + \";\\n\")\n\t\t\t\tif k != str(Clauses()):\n\t\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\tfile.write(\"\\treturn 0;\\n}\\n\")\n\t\tfile.write(\"#else\\nint isSimpleWrapper(wrapper_t fun) {\\n\\treturn 0;\\n}\\n#endif\\n\")\n\t\t\n\t\t# Write the isRetX87Wrapper function\n\t\tfile.write(\"\\nint isRetX87Wrapper32(wrapper_t fun)\\n#ifndef BOX32\\n{ return 0; }\\n#else\\n ;\\n#endif\\n\")\n\t\tfile.write(\"\\nint isRetX87Wrapper(wrapper_t fun) {\\n\")\n\t\tfor k in retx87_idxs:\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#if \" + k + \"\\n\")\n\t\t\tfor vf in retx87_wraps[k]:\n\t\t\t\tfile.write(\"\\tif (fun == &\" + vf + \") return 1;\\n\")\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\treturn 0;\\n}\\n\")\n\t\t\n\t\tfile.write(files_guard[\"wrapper.c\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\n\t# Rewrite the wrapper.h file:\n\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"wrapper.h\"), 'w') as file:\n\t\tfile.write(files_header[\"wrapper.h\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\t# Normal function types\n\t\tfor k in gbls:\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"\\n#if \" + k + \"\\n\")\n\t\t\tfor v in gbls[k]:\n\t\t\t\tfile.write(\"void \" + v + \"(x64emu_t *emu, uintptr_t fnc);\\n\")\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\n\")\n\t\t# Redirects\n\t\tfor k in redirects:\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"\\n#if \" + k + \"\\n\")\n\t\t\tfor vr, _ in redirects[k]:\n\t\t\t\tfile.write(\"void \" + vr + \"(x64emu_t *emu, uintptr_t fnc);\\n\")\n\t\t\tif k != str(Clauses()):\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(files_guard[\"wrapper.h\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\n\t# Rewrite the *types.h files:\n\tfor k in conventions:\n\t\ttd_types[k][conventions[k].values.index('A')] = \"va_list\"\n\t\ttd_types[k][conventions[k].values.index('V')] = \"...\"\n\torig_val_len = {k: len(conventions[k].values) for k in conventions}\n\tfor fn in filesspec:\n\t\tfor strc in fsp_tmp[fn][1]:\n\t\t\tfor k in conventions:\n\t\t\t\tconventions[k].values.append(strc)\n\t\t\t\ttd_types[k].append(fsp_tmp[fn][1][strc][0])\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", fn + \"types.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fntypes.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tgenerate_typedefs(filesspec[fn][0], file)\n\t\t\tfile.write(\"\\n#define SUPER() ADDED_FUNCTIONS()\")\n\t\t\tfor r in filesspec[fn][0]:\n\t\t\t\tfor f in filesspec[fn][0][r]:\n\t\t\t\t\tfile.write(\" \\\\\\n\\tGO({0}, {1}_t)\".format(f, r))\n\t\t\tfile.write(\"\\n\")\n\t\t\tfile.write(files_guard[\"fntypes.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", fn + \"defs.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fndefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tfor defined in filesspec[fn][1]:\n\t\t\t\tfile.write(\"#define {defined} {define}\\n\".format(defined=defined, define=filesspec[fn][1][defined]))\n\t\t\tfile.write(files_guard[\"fndefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", fn + \"undefs.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fnundefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tfor defined in filesspec[fn][1]:\n\t\t\t\tfile.write(\"#undef {defined}\\n\".format(defined=defined))\n\t\t\tfile.write(files_guard[\"fnundefs.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\tfor k in conventions:\n\t\t\tconventions[k].values = conventions[k].values[:orig_val_len[k]]\n\t\t\ttd_types[k] = td_types[k][:orig_val_len[k]]\n\t\n\t# Save the string for the next iteration, writing was successful\n\twith open(os.path.join(root, \"src\", \"wrapped\", \"generated\", \"functions_list.txt\"), 'w') as file:\n\t\tfile.write(functions_list)\n\t\n\treturn 0\n\nif __name__ == '__main__':\n\tlimit: List[int] = []\n\tfor i, v in enumerate(sys.argv):\n\t\tif v == \"--\":\n\t\t\tlimit.append(i)\n\tDefine.defines = list(map(DefineType, sys.argv[2:limit[0]]))\n\tif main(sys.argv[1], sys.argv[limit[0]+1:], \"2.5.0.24\") != 0:\n\t\texit(2)\n\texit(0)\n"
        },
        {
          "name": "rebuild_wrappers_32.py",
          "type": "blob",
          "size": 63.8603515625,
          "content": "#!/usr/bin/env python3\n\nimport os\nimport sys\n\ntry:\n\tassert(sys.version_info.major == 3)\n\tif sys.version_info.minor >= 9:\n\t\t# Python 3.9+\n\t\tfrom typing import Any, Generic, NewType, Optional, TypeVar, Union, final\n\t\tfrom collections.abc import Callable, Iterable, Sequence\n\t\tDict = dict\n\t\tList = list\n\t\tType = type\n\t\tTuple = tuple\n\telif sys.version_info.minor >= 8:\n\t\t# Python [3.8, 3.9)\n\t\tfrom typing import Any, Callable, Dict, Generic, Iterable, List, NewType, Optional, Sequence, Tuple, Type, TypeVar, Union, final\n\telif (sys.version_info.minor >= 5) and (sys.version_info.micro >= 2):\n\t\t# Python [3.5.2, 3.8)\n\t\tfrom typing import Any, Callable, Dict, Generic, Iterable, List, NewType, Optional, Sequence, Tuple, Type, TypeVar, Union\n\t\tfinal = lambda fun: fun # type: ignore\n\telif sys.version_info.minor >= 5:\n\t\t# Python [3.5, 3.5.2)\n\t\tfrom typing import Any, Callable, Dict, Generic, Iterable, List, Optional, Sequence, Tuple, Type, TypeVar, Union\n\t\tdef NewType(_, b): return b # type: ignore\n\t\tfinal = lambda fun: fun # type: ignore\n\telse:\n\t\t# Python < 3.5\n\t\t#print(\"Your Python version does not have the typing module, fallback to empty 'types'\")\n\t\t# Dummies\n\t\tclass GTDummy:\n\t\t\tdef __getitem__(self, _):\n\t\t\t\treturn self\n\t\tAny = GTDummy() # type: ignore\n\t\tCallable = GTDummy() # type: ignore\n\t\tDict = GTDummy() # type: ignore\n\t\tGeneric = GTDummy() # type: ignore\n\t\tIterable = GTDummy() # type: ignore\n\t\tList = GTDummy() # type: ignore\n\t\tdef NewType(_, b): return b # type: ignore\n\t\tOptional = GTDummy() # type: ignore\n\t\tSequence = GTDummy() # type: ignore\n\t\tTuple = GTDummy() # type: ignore\n\t\tType = GTDummy() # type: ignore\n\t\tdef TypeVar(T): return object # type: ignore\n\t\tUnion = GTDummy() # type: ignore\n\t\tfinal = lambda fun: fun # type: ignore\nexcept ImportError:\n\tprint(\"It seems your Python version is quite broken...\")\n\tassert(False)\n\n\"\"\"\nGenerates all files in src/wrapped/generated\n===\n\nTL;DR: Automagically creates type definitions (/.F.+/ functions/typedefs...).\n       All '//%' in the headers are used by the script.\n\nReads each lines of each \"_private.h\" headers (plus wrappedd3dadapter9_genvate.h, derived from wrappedd3dadapter9_gen.h).\nFor each of them:\n- If if starts with a #ifdef, #else, #ifndef, #endif, it memorizes which definition is required\n- If it starts with a \"GO\", it will do multiple things:\n  - It memorizes the type used by the function (second macro argument)\n  - It memorizes the type it is mapped to, if needed (eg, iFvp is mapped to iFp: the first argument is dropped)\n  - It checks if the type given (both original and mapped to) are valid\n  - If the signature contains a 'E' but it is not a \"GOM\" command, it will throw an error* (and vice-versa)\n  - If the line also contains '//%', the script will parse what's attached to this comment start:\n    - If it is attached to a '%', the function will be skipped when generating the 'SUPER' macro in the *types.h\n\t- *If it is attached to a 'noE' or attached to something that ends with ',noE', it will ignore functions that\n\t  don't have the emulator as an argument but are still GOM functions\n  To know more about the signatures, see also box86.org's article (TODO FOR NOW).\n- If the line starts with a '//%S', it will memorize a structure declaration.\n  The structure of it is: \"//%S <letter> <structure name> <signature equivalent>\"\n  NOTE: Those structure letters are \"fake types\" that are accepted in the macros.\n\n`gbl` contains the first list, `redirects` the second and\n `filespec` constains file specific informations (eg, structures, typedefs required...).\n\nAfter sorting the data, it generates:\n\nwrapper32.c\n---------\n(Private) type definitions (/.F.+_t/)\nFunction definitions (/.F.+/ functions, that actually execute the function given as argument)\n\nwrapper32.h\n---------\nGeneric \"wrapper32_t\" type definition\nFunction declarations (/.F._32+/ functions)\n\n*types32.h\n--------\nLocal types definition, for the original signatures\nThe SUPER() macro definition, used to generate and initialize the `*_my_t` library structure\n(TODO: also automate this declaration/definition? It would require more metadata,\n and may break sometime in the future due to the system changing...)\n\n*defs32.h\n-------\nLocal `#define`s, for signature mapping\n\n*undefs32.h\n---------\nLocal `#undefine`s, for signature mapping\n\n\nExample:\n========\nIn wrappedtest_private.h:\n   ----------------------\n//%S X TestLibStructure ppu\n\nGO(superfunction, pFX)\nGOM(superFunction2, pFEpX)\nGOM(functionWithoutE, pFppu) //%noE\nGOM(functionWithoutEAndNotInTypes, pFpppu) //%%,noE\nGOM(functionNotInTypes, pFEpppu) //%%\n\n[No output]\nGenerated files:\nwrapper32.c: [snippet]\n----------\ntypedef void *(*pFppu_t)(void*, void*, uint32_t);\ntypedef void *(*pFpppu_t)(void*, void*, void*, uint32_t);\ntypedef void *(*pFEpppu_t)(x64emu_t*, void*, void*, void*, uint32_t);\n\nvoid pFppu_32(x64emu_t *emu, uintptr_t fcn) { pFppu_t *fn = (pFppu_t)fn; R_RAX=...; }\nvoid pFpppu_32(x64emu_t *emu, uintptr_t fcn) { pFpppu_t *fn = (pFpppu_t)fn; R_RAX=...; }\nvoid pFEpppu_32(x64emu_t *emu, uintptr_t fcn) { pFpppu_t *fn = (pFpppu_t)fn; R_RAX=...; }\n\nwrapper32.h: [snippet]\n----------\ntypedef void (*wrapper_t)(x64emu_t*, uintptr_t);\n\nvoid pFppu_32(x64emu_t *emu, uintptr_t fcn);\nvoid pFpppu_32(x64emu_t *emu, uintptr_t fcn);\nvoid pFEpppu_32(x64emu_t *emu, uintptr_t fcn);\n\nwrappedtesttypes32.h:\n-------------------\ntypedef void *(*pFpX_32_t)(void*, TestLibStructure);\ntypedef void *(*pFppu_32_t)(void*, void*, uint32_t);\ntypedef void *(*pFpppu_32_t)(void*, void*, void*, uint32_t);\n\n#define SUPER() ADDED_FUNCTIONS() \\\\\n\tGO(superFunction2, pFpX) \\\\\n\tGO(functionWithoutE, pFppu)\n\nwrappedtestdefs32.h:\n------------------\n#define pFX pFppu\n#define pFpX pFpppu\n\nwrappedtestundefs32.h:\n--------------------\n#undef pFX\n#undef pFpX\n\"\"\"\n\n# Free characters:\n#      FG  J      QR T   XYZ    e g  jk mno q      xyz01 3456789\n\nT = TypeVar('T')\nU = TypeVar('U')\n\nFilename = str\n\nclass CustOrderedDict(Generic[T, U], Iterable[T]):\n\t__keys__: List[T]\n\t__actdict__: Dict[T, U]\n\t\n\tdef __init__(self, src: Optional[Dict[T, U]] = None) -> None:\n\t\tif src is None:\n\t\t\tself.__keys__ = []\n\t\t\tself.__actdict__ = {}\n\t\telse:\n\t\t\tself.__keys__ = list(src.keys())\n\t\t\tself.__actdict__ = src\n\t\n\tdef sort(self, key: Callable[[T], Any] = lambda x: x) -> None:\n\t\tself.__keys__.sort(key=key)\n\t\n\tdef __iter__(self):\n\t\treturn iter(self.__keys__)\n\tdef __contains__(self, k: T) -> bool:\n\t\treturn k in self.__actdict__\n\tdef __getitem__(self, k: T) -> U:\n\t\treturn self.__actdict__[k]\n\tdef __setitem__(self, k: T, v: U) -> None:\n\t\tif k not in self.__keys__: self.__keys__.append(k)\n\t\tself.__actdict__[k] = v\nclass CustOrderedDictList(CustOrderedDict[T, List[U]]):\n\tdef __getitem__(self, k: T) -> List[U]:\n\t\tif k not in self: self[k] = []\n\t\treturn super().__getitem__(k)\n\nclass FirstArgumentSingletonMeta(Generic[T], type):\n\t_singletons: Dict[T, Type['FirstArgumentSingletonMeta']]\n\t\n\t@classmethod\n\tdef __prepare__(metacls, __name: str, __bases: Tuple[type, ...], **kwds: Any) -> Dict[str, Any]:\n\t\treturn { \"_singletons\": {} }\n\t\n\tdef __contains__(cls, k):\n\t\treturn k in cls._singletons\n\t\n\tdef getSingletons(cls):\n\t\treturn cls._singletons\n\tdef __getitem__(cls, k):\n\t\treturn cls._singletons[k]\n\t\n\tdef __call__(cls, fstarg, *largs, **kwargs):\n\t\tif fstarg not in cls._singletons:\n\t\t\tcls._singletons[fstarg] = super().__call__(fstarg, *largs, **kwargs)\n\t\treturn cls._singletons[fstarg]\n\nDefineType = NewType('DefineType', str)\n@final\nclass Define:\n\tname: DefineType\n\tinverted_: bool\n\t\n\tdefines: List[DefineType] = []\n\t\n\tdef __init__(self, name: DefineType, inverted_: bool) -> None:\n\t\t# All values for \"name\" are in defines (throw otherwise)\n\t\tif name not in Define.defines:\n\t\t\traise KeyError(name)\n\t\t\n\t\tself.name = name\n\t\tself.inverted_ = inverted_\n\tdef copy(self) -> \"Define\":\n\t\treturn Define(self.name, self.inverted_)\n\t\n\tdef value(self) -> int:\n\t\treturn Define.defines.index(self.name)*2 + (1 if self.inverted_ else 0)\n\t\n\tdef invert(self) -> \"Define\":\n\t\t\"\"\"\n\t\tinvert -- Transform a `defined()` into a `!defined()` and vice-versa, in place.\n\t\t\"\"\"\n\t\tself.inverted_ = not self.inverted_\n\t\treturn self\n\tdef inverted(self) -> \"Define\":\n\t\t\"\"\"\n\t\tinverted -- Transform a `defined()` into a `!defined()` and vice-versa, out-of-place.\n\t\t\"\"\"\n\t\treturn Define(self.name, not self.inverted_)\n\t\n\tdef __str__(self) -> str:\n\t\tif self.inverted_:\n\t\t\treturn \"!defined(\" + self.name + \")\"\n\t\telse:\n\t\t\treturn \"defined(\" + self.name + \")\"\n\tdef __eq__(self, o) -> bool:\n\t\treturn isinstance(o, Define) and (self.name == o.name) and (self.inverted_ == o.inverted_)\n@final\nclass Clause:\n\tdefines: List[Define]\n\t\n\tdef __init__(self, defines: Union[List[Define], str] = []) -> None:\n\t\tif isinstance(defines, str):\n\t\t\tif defines == \"\":\n\t\t\t\tself.defines = []\n\t\t\telse:\n\t\t\t\tself.defines = list(\n\t\t\t\t\tmap(\n\t\t\t\t\t\tlambda x:\n\t\t\t\t\t\t\tDefine(DefineType(x[9:-1] if x[0] == '!' else x[8:-1]), x[0] == '!')\n\t\t\t\t\t\t, defines.split(\" && \")\n\t\t\t\t\t)\n\t\t\t\t)\n\t\telse:\n\t\t\tself.defines = [d.copy() for d in defines]\n\tdef copy(self) -> \"Clause\":\n\t\treturn Clause(self.defines)\n\t\n\tdef append(self, define: Define) -> \"Clause\":\n\t\tif any((define2.name == define.name) and (define2.inverted_ != define.inverted_) for define2 in self.defines):\n\t\t\traise ValueError(\"Tried to append an incompatible clause\")\n\t\t\n\t\tself.defines.append(define)\n\t\treturn self\n\tdef invert_last(self) -> \"Clause\":\n\t\tself.defines[-1].invert()\n\t\treturn self\n\tdef pop_last(self) -> \"Clause\":\n\t\tif len(self.defines) > 0: self.defines.pop()\n\t\treturn self\n\t\n\tdef empty(self) -> bool:\n\t\treturn self.defines == []\n\t\n\tdef __str__(self) -> str:\n\t\treturn \" && \".join(map(str, self.defines))\n\tdef __hash__(self):\n\t\treturn hash(str(self))\n\tdef __eq__(self, o) -> bool:\n\t\treturn isinstance(o, Clause) and (self.defines == o.defines)\nClausesStr = str\n@final\nclass Clauses:\n\t\"\"\"\n\tRepresent a list of clauses, aka a list of or-ed together and-ed \"defined()\"\n\tconditions\n\t\"\"\"\n\tclauses: List[Clause]\n\t\n\tdef __init__(self, clauses: Union[List[Clause], str] = []) -> None:\n\t\tif isinstance(clauses, str):\n\t\t\tif clauses == \"()\":\n\t\t\t\tself.clauses = []\n\t\t\telif \") || (\" in clauses:\n\t\t\t\tself.clauses = list(map(Clause, clauses[1:-1].split(\") || (\")))\n\t\t\telse:\n\t\t\t\tself.clauses = [Clause(clauses)]\n\t\telse:\n\t\t\tself.clauses = clauses[:]\n\tdef copy(self) -> \"Clauses\":\n\t\treturn Clauses(self.clauses[:])\n\t\n\tdef add(self, defines: Clause) -> \"Clauses\":\n\t\tself.clauses.append(defines)\n\t\treturn self\n\t\n\tdef empty(self) -> bool:\n\t\treturn self.clauses == []\n\t\n\tdef splitdef(self) -> Sequence[int]:\n\t\t\"\"\"\n\t\tsplitdef -- Sorting key function for #ifdefs\n\t\t\n\t\tAll #if defined(...) are sorted first by the length of its string\n\t\trepresentation, then by the number of clauses, then by the number of\n\t\t'&&' in each clause and then by the \"key\" of the tested names (left to\n\t\tright, inverted placed after non-inverted).\n\t\t\"\"\"\n\t\t\n\t\tret = [len(str(self)), len(self.clauses)] if len(self.clauses) > 0 else [-1]\n\t\tfor cunj in self.clauses:\n\t\t\tret.append(len(cunj.defines))\n\t\tfor cunj in self.clauses:\n\t\t\tfor d in cunj.defines:\n\t\t\t\tret.append(d.value())\n\t\treturn ret\n\t\n\tdef reduce(self) -> None:\n\t\t\"\"\"\n\t\treduce -- Reduces the number of clauses in-place\n\t\t\n\t\tRemoves the most possible number of conditions, both by removing\n\t\tconditions and by removing entire clauses.\n\t\t\n\t\tAs a side effect, sorts itself.\n\t\t\"\"\"\n\t\t# Early breaks\n\t\tif any(c.empty() for c in self.clauses):\n\t\t\tself.clauses = []\n\t\t\treturn\n\t\tif len(self.clauses) == 0:\n\t\t\treturn\n\t\telif len(self.clauses) == 1:\n\t\t\tclause = Clause()\n\t\t\tfor define in self.clauses[0].defines:\n\t\t\t\tif define in clause.defines:\n\t\t\t\t\tcontinue\n\t\t\t\telif define.inverted() in clause.defines:\n\t\t\t\t\tclause = Clause(',') # This should never happen (and never happens without breaking encapsulation)\n\t\t\t\telse:\n\t\t\t\t\tclause.append(define)\n\t\t\tclause.defines.sort(key=lambda d: Define.defines.index(d.name))\n\t\t\tself.clauses = [clause]\n\t\t\treturn\n\t\telif len(self.clauses) == 2:\n\t\t\tif len(self.clauses[0].defines) == len(self.clauses[1].defines) == 1:\n\t\t\t\tif self.clauses[0].defines[0].inverted() == self.clauses[1].defines[0]:\n\t\t\t\t\tself.clauses = []\n\t\t\t\t\treturn\n\t\t\n\t\t# Quine-McCluskey algorithm\n\t\t# matches: list of (matches, inverted_mask)\n\t\tneeded: List[Tuple[int, int]] = [\n\t\t\t(i, 0)\n\t\t\tfor i in range(1<<len(Define.defines))\n\t\t\tif any( # i matches any clause\n\t\t\t\tall( # i matches all conditions in the clause\n\t\t\t\t\t(i & (1<<Define.defines.index(define.name)) == 0) == define.inverted_\n\t\t\t\t\tfor define in clause.defines)\n\t\t\t\tfor clause in self.clauses)\n\t\t]\n\t\t\n\t\tlast_combined = needed[:]\n\t\tuncombinable: List[Tuple[int, int]] = []\n\t\twhile len(last_combined) > 0:\n\t\t\tcombined: List[Tuple[int, int]] = []\n\t\t\tcombinable: List[bool] = [False] * len(last_combined)\n\t\t\twhile len(last_combined) > 0:\n\t\t\t\tattempt = last_combined[-1]\n\t\t\t\tfor idx, (i, m) in enumerate(last_combined):\n\t\t\t\t\tif idx == len(last_combined) - 1:\n\t\t\t\t\t\tif not combinable[idx]:\n\t\t\t\t\t\t\tuncombinable.append(attempt)\n\t\t\t\t\telif m == attempt[1]:\n\t\t\t\t\t\tif (i ^ attempt[0]) & ((i ^ attempt[0]) - 1) != 0:\n\t\t\t\t\t\t\tcontinue # More than 1 bit of difference\n\t\t\t\t\t\t\n\t\t\t\t\t\tcombinable[idx] = True\n\t\t\t\t\t\tcombinable[len(last_combined) - 1] = True\n\t\t\t\t\t\tadd = (i | attempt[0], m | (i ^ attempt[0]))\n\t\t\t\t\t\tif add in combined:\n\t\t\t\t\t\t\tcontinue # Aleady added\n\t\t\t\t\t\tcombined.append(add)\n\t\t\t\tlast_combined.pop()\n\t\t\tlast_combined = combined\n\t\t\n\t\tmatches: Dict[int, List[Tuple[int, int]]] = {\n\t\t\ti: [combination for combination in uncombinable if (i | combination[1]) == combination[0]] for i, _ in needed\n\t\t}\n\t\tself.clauses = []\n\t\tmatches_size: int = 1\n\t\twhile len(matches) != 0:\n\t\t\tmatch_found = True\n\t\t\twhile match_found:\n\t\t\t\tmatch_found = False\n\t\t\t\tfor i in matches:\n\t\t\t\t\tif len(matches[i]) < matches_size:\n\t\t\t\t\t\traise NotImplementedError(\"There seems to be an error in the algorithm\")\n\t\t\t\t\telif len(matches[i]) == matches_size:\n\t\t\t\t\t\tmatch_found = True\n\t\t\t\t\t\tself.clauses.append(\n\t\t\t\t\t\t\tClause([\n\t\t\t\t\t\t\t\tDefine(\n\t\t\t\t\t\t\t\t\tn,\n\t\t\t\t\t\t\t\t\tmatches[i][0][0] & (1 << j) == 0\n\t\t\t\t\t\t\t\t) for j, n in enumerate(Define.defines) if matches[i][0][1] & (1 << j) == 0\n\t\t\t\t\t\t\t]))\n\t\t\t\t\t\tself.clauses[-1].defines.sort(key=lambda d: Define.defines.index(d.name))\n\t\t\t\t\t\tto_erase: List[int] = []\n\t\t\t\t\t\tfor j in matches:\n\t\t\t\t\t\t\tif matches[i][0] in matches[j]:\n\t\t\t\t\t\t\t\tto_erase.append(j)\n\t\t\t\t\t\tfor j in to_erase:\n\t\t\t\t\t\t\tdel matches[j]\n\t\t\t\t\t\tbreak\n\t\t\tmatches_size = matches_size + 1\n\t\tself.clauses.sort(key=lambda c: (len(c.defines), [Define.defines.index(d.name) for d in c.defines]))\n\t\n\tdef __str__(self) -> ClausesStr:\n\t\tif len(self.clauses) == 1:\n\t\t\treturn str(self.clauses[0])\n\t\telse:\n\t\t\treturn \"(\" + \") || (\".join(map(str, self.clauses)) + \")\"\n\tdef __hash__(self):\n\t\treturn hash(str(self))\n\tdef __eq__(self, o) -> bool:\n\t\treturn isinstance(o, Clauses) and (self.clauses == o.clauses)\n\nclass CType(metaclass=FirstArgumentSingletonMeta):\n\tclass ReadWrite:\n\t\tnone: 'CType.ReadWrite'\n\t\treadonly: 'CType.ReadWrite'\n\t\twriteonly: 'CType.ReadWrite'\n\t\treadwrite: 'CType.ReadWrite'\n\t\tdef __init__(self, pre: bool, post: bool) -> None:\n\t\t\t# pre is \"need to convert before the call\", post is \"need to convert after the call\"\n\t\t\tself.pre = pre\n\t\t\tself.post = post\n\t\n\t@staticmethod\n\tdef find_next(name: str) -> Tuple[str, Optional[Tuple['CType.ReadWrite', str, str]]]:\n\t\t\"\"\"\n\t\tReturns (pre, (type, str, post))\n\t\t where name == pre.('r' if type is readonly, 'b' if type is writeonly else 'B').str.'_'.post\n\t\tAka, pre contains no structure; type, str is the structure characterization (b fo writeonly).\n\t\tIf it returns (pre, None), it is guaranteed to have no structure in pre === name.\n\t\t\"\"\"\n\t\tbeg: Optional[int] = None\n\t\tt: Optional[CType.ReadWrite] = None\n\t\tdepth = 0\n\t\t\n\t\tfor i in range(len(name)):\n\t\t\tif (name[i] == 'r') or (name[i] == 'b') or (name[i] == 'B'):\n\t\t\t\tif beg is None:\n\t\t\t\t\tbeg = i\n\t\t\t\t\tt = CType.ReadWrite.readonly  if name[i] == 'r' else \\\n\t\t\t\t\t    CType.ReadWrite.writeonly if name[i] == 'B' else CType.ReadWrite.readwrite\n\t\t\t\tdepth = depth + 1\n\t\t\telif name[i] == '_':\n\t\t\t\tif depth == 0:\n\t\t\t\t\traise ValueError(f\"Invalid type {name}\")\n\t\t\t\telif depth == 1:\n\t\t\t\t\tassert beg is not None, \"Unreachable\"\n\t\t\t\t\tassert t is not None, \"Unreachable\"\n\t\t\t\t\treturn name[:beg], (t, name[beg+1:i], name[i+1:])\n\t\t\t\tdepth = depth - 1\n\t\t\n\t\treturn name, None\n\t\n\tdef __init__(self, name_t: Tuple[str, 'CType.ReadWrite'], clause: Clause, filespec: 'FileSpec') -> None:\n\t\tself.name = name_t[0]\n\t\tself.type = name_t[1]\n\t\tif self.type is CType.ReadWrite.none:\n\t\t\tself.structname = self.name\n\t\t\tself.structname2 = self.name\n\t\telif self.type is CType.ReadWrite.readonly:\n\t\t\tself.structname = \"r\" + self.name + \"_\"\n\t\t\tself.structname2 = \"struct_\" + self.name\n\t\telif self.type is CType.ReadWrite.writeonly:\n\t\t\tself.structname = \"B\" + self.name + \"_\"\n\t\t\tself.structname2 = \"struct_\" + self.name\n\t\telif self.type is CType.ReadWrite.readwrite:\n\t\t\tself.structname = \"b\" + self.name + \"_\"\n\t\t\tself.structname2 = \"struct_\" + self.name\n\t\telse:\n\t\t\tself.structname = \"//\" + self.name\n\t\t\tself.structname2 = \"//\" + self.name\n\t\tself.recursive: List[CType] = []\n\t\tself.replaced = self.name\n\t\t\n\t\tif len(name_t[0]) != 1:\n\t\t\treplaced = []\n\t\t\tpre, tmp = CType.find_next(self.name)\n\t\t\twhile tmp is not None:\n\t\t\t\tself.recursive.extend(CType((c, CType.ReadWrite.none), clause, filespec) for c in pre)\n\t\t\t\tself.recursive.append(CType((tmp[1], tmp[0]), clause, filespec))\n\t\t\t\treplaced.append(pre)\n\t\t\t\tpre, tmp = CType.find_next(tmp[2])\n\t\t\tself.recursive.extend(CType((c, CType.ReadWrite.none), clause, filespec) for c in pre)\n\t\t\treplaced.append(pre)\n\t\t\tself.replaced = 'B'.join(replaced)\n\t\t\n\t\tself.asret: Optional[str] = None\n\t\tself.aspre: Optional[str] = None\n\t\tself.asarg: Optional[str] = None\n\t\tself.aspost: Optional[str] = None\n\t\n\tdef describe(self, spacer=\"\"):\n\t\tnl = \"\" if len(self.recursive) == 0 else f\"\\n{spacer}+-> \"\n\t\tif self.type is CType.ReadWrite.none:\n\t\t\tt = \"\"\n\t\telif self.type is CType.ReadWrite.readonly:\n\t\t\tt = \" (r-)\"\n\t\telif self.type is CType.ReadWrite.writeonly:\n\t\t\tt = \" (-w)\"\n\t\telif self.type is CType.ReadWrite.readwrite:\n\t\t\tt = \" (rw)\"\n\t\telse:\n\t\t\tt = \" ?!?!\"\n\t\treturn f\"{self.structname} => {self.replaced}+{len(self.recursive)}{t}{nl}\" + \\\n\t\t\tf\"\\n{spacer}+-> \".join(r.describe(spacer + \"    \") for r in self.recursive)\n\t\n\tdef generate_converters(self) -> None:\n\t\tif self.asret is not None:\n\t\t\treturn # Already done: probably a base type\n\t\t\n\t\tself.asret = \"\\n#error TODO? Cannot return custom structure\\n\"\n\t\tself.aspre = f\"struct_{self.name}_t arg_{{p}}={{{{0}}}}; \" + (\"\" if not self.type.pre else \\\n\t\t\tf\"if (*(ptr_t*)(from_ptr((R_ESP + {{p}})))) from_{self.structname2}(&arg_{{p}}, *(ptr_t*)(from_ptr((R_ESP + {{p}})))); \")\n\t\tself.asarg = \"*(ptr_t*)(from_ptr((R_ESP + {p}))) ? &arg_{p} : NULL, \"\n\t\tself.aspost = \"\" if not self.type.post else \\\n\t\t\t(\" if (*(ptr_t*)(from_ptr((R_ESP + {p})))) to_\" + self.structname2 + \\\n\t\t\t\t\"(*(ptr_t*)(from_ptr((R_ESP + {p}))), &arg_{p});\")\n\t\t\n\t\tfor rec in self.recursive:\n\t\t\trec.generate_converters()\nclass CTypeNone(CType, metaclass=FirstArgumentSingletonMeta):\n\tdef __init__(self, name: str, clause: Clause, filespec: 'FileSpec') -> None:\n\t\tsuper().__init__((name, CType.ReadWrite.none), clause, filespec)\n\nCType.ReadWrite.none = CType.ReadWrite(False, False) # Uppermost type\nCType.ReadWrite.readonly = CType.ReadWrite(True, False)\nCType.ReadWrite.writeonly = CType.ReadWrite(False, True)\nCType.ReadWrite.readwrite = CType.ReadWrite(True, True)\n\nclass FileSpec:\n\tclass Struct:\n\t\tdef __init__(self, name: str, repl: str) -> None:\n\t\t\tself.name = name\n\t\t\tself.repl = repl\n\t\n\t# CONSTANT- values: original set\n\t# CONSTANT- rvalues: valid replacement values (outside of structures)\n\t# CONSTANT- validrepl: valid replacement values (for structures)\n\t#           structs: structure ids and additional data\n\tvalues:    Sequence[str] = ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'K', 'l', 'L', 'p', 'h', 'H', 'a', 'A', 'V', 'O', 'S', '2', 'P', 'N', 'M', 's', 'r', 'b', 'B', '_', 't', 'X', 'n']\n\trvalues:   Sequence[str] = ['E', 'v', 'c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'K', 'l', 'L', 'p', 'h', 'H', 'a', 'A', 'V', 'O', 'S', '2', 'P', 'N', 'M', 's', 'r', 'b', 'B', '_', 't', 'X', 'n']\n\tvalidrepl: Sequence[str] = ['c', 'w', 'i', 'I', 'C', 'W', 'u', 'U', 'f', 'd', 'D', 'K', 'l', 'L', 'p', 'h', 'H', 'a', 'A', 'V', 'O', 'S', '2', 'P', 'N', 'M', 's', 'r', 'b', 'B', '_']\n\t\n\tdef __init__(self) -> None:\n\t\tself.structs: CustOrderedDict[str, FileSpec.Struct] = CustOrderedDict()\n\t\t\n\t\tself.typedefs: CustOrderedDictList[_BareFunctionType, Function] = CustOrderedDictList()\n\t\tself.structsuses: List[FunctionType] = []\n\t\n\tdef registerStruct(self, id: str, name: str, repl: str) -> None:\n\t\tif len(id) != 1:\n\t\t\t# If you REALLY need it, consider opening a ticket\n\t\t\t# Before you do, consider that everything that is a valid in a C token is valid here too\n\t\t\traise ValueError(\"Type ID \\\"\" + id + \"\\\" is too long!\")\n\t\tif id in self.rvalues:\n\t\t\traise ValueError(\"Type \" + id + \" is already reserved!\")\n\t\tif id in self.structs:\n\t\t\traise ValueError(\"Type \" + id + \" is already used!\")\n\t\tif any(c not in self.validrepl for c in repl):\n\t\t\traise ValueError(\"Invalid structure replacement value \\\"\" + repl + \"\\\" (note: recursive replacements are not supported)\")\n\t\tif repl == \"\":\n\t\t\t# If you need this, please open an issue (also, this is never actually called, empty strings are removed at the calling site)\n\t\t\traise NotImplementedError(\"Invalid structure metadata supply (empty replacement)\")\n\t\t\n\t\tself.structs[id] = FileSpec.Struct(name, repl)\n\nclass FunctionType(metaclass=FirstArgumentSingletonMeta):\n\tdef __new__(cls, string: str, clause: Clause, filespec: FileSpec) -> 'FunctionType':\n\t\tif ((string[0] not in FileSpec.values) or any(c not in FileSpec.values for c in string[2:])) \\\n\t\t and ((string[0] in FileSpec.values) or (string[0] in filespec.structs)) \\\n\t\t and all((c != 'v') and (c in FileSpec.values) or (c in filespec.structs) for c in string[2:]):\n\t\t\treturn super().__new__(StructFunctionType)\n\t\telse:\n\t\t\treturn super().__new__(cls)\n\t\n\tdef __init__(self, string: str, clause: Clause, filespec: FileSpec) -> None:\n\t\t# Early fail\n\t\tif 'VV' in string:\n\t\t\traise ValueError(\"'V' can only be at the end of the type (use 's' instead)\")\n\t\t\n\t\tself.orig = CTypeNone(string, clause, filespec)\n\t\t\n\t\tself.hasemu = 'E' in self.orig.replaced and (\n\t\t\t(self.orig.recursive[1].structname != 'E') or ('E' in self.orig.recursive[0].name) or any('E' in ct.name for ct in self.orig.recursive[2:]))\n\t\tif self.hasemu:\n\t\t\tif (\"E\" in self.orig.recursive[0].name) or any(\"E\" in ct.name for ct in self.orig.recursive[3:]):\n\t\t\t\traise NotImplementedError(\"x64emu_t* not as the first parameter\")\n\t\t\tif len(self.orig.replaced) < 4:\n\t\t\t\traise NotImplementedError(\"Type {0} too short\".format(self.orig.replaced))\n\t\t\tchk_type = self.orig.recursive[0].structname + ''.join(map(lambda ct: ct.structname, self.orig.recursive[3:]))\n\t\telse:\n\t\t\tif len(self.orig.replaced) < 3:\n\t\t\t\traise NotImplementedError(\"Type {0} too short\".format(self.orig.replaced))\n\t\t\tchk_type = self.orig.recursive[0].structname + ''.join(map(lambda ct: ct.structname, self.orig.recursive[2:]))\n\t\tself.withoutE = _BareFunctionType(string[0:2] + chk_type[1:], clause, filespec, isinstance(self, StructFunctionType))\n\t\tself._bare = _BareFunctionType(self.orig.name, clause, filespec, isinstance(self, StructFunctionType))\n\t\tif len(chk_type) < 2:\n\t\t\traise NotImplementedError(\"Type {0} too short\".format(string))\n\t\t\n\t\tif self.orig.recursive[1].structname not in ['E', 'F']:\n\t\t\traise NotImplementedError(\"Bad middle letter {0}\".format(self.orig.recursive[1].structname))\n\t\t\n\t\tself.redirect = any(c not in FileSpec.values for c in chk_type) or (('v' in chk_type[1:]) and (len(chk_type) > 2))\n\t\tself.usestruct: bool = False\n\t\tself.redirected: Optional[FunctionType] = None\n\t\tif self.redirect:\n\t\t\tif all(((i == 0) or (c != 'v')) and (c in FileSpec.values) or (c in filespec.structs) for i, c in enumerate(chk_type)):\n\t\t\t\t# 'v' is never allowed here\n\t\t\t\tself.redirect = False\n\t\t\t\tself.usestruct = True\n\t\t\t\treturn\n\t\t\telse:\n\t\t\t\tif any(c not in FileSpec.rvalues for c in chk_type):\n\t\t\t\t\traise NotImplementedError(\"Invalid type {0}\".format(string))\n\t\t\t\t\n\t\t\t\t# Ok, this is acceptable: there is void\n\t\t\t\tstring = string[:2] + (string[2:]\n\t\t\t\t\t.replace(\"v\", \"\")) # void -> nothing\n\t\t\t\tassert(len(string) >= 3) # If this raises, don't use 'vFvvvvvv' as a signature...\n\t\t\t\tself.redirected = FunctionType(string, clause, filespec)\n\t\t\t\tassert(not self.redirected.redirect and not self.redirected.usestruct)\n\t\n\tdef getchar(self, c: str) -> int:\n\t\treturn self._bare.getchar(c)\n\tdef getcharidx(self, i: int) -> int:\n\t\treturn self._bare.getcharidx(i)\n\tdef splitchar(self) -> List[int]:\n\t\treturn self._bare.splitchar()\n\t\n\tdef __hash__(self) -> int:\n\t\treturn str.__hash__(self.orig.name)\n\tdef __eq__(self, o: object):\n\t\treturn isinstance(o, FunctionType) and ((self.orig.name == o.orig.name) and (o is self or not isinstance(self, StructFunctionType)))\nclass StructFunctionType(FunctionType):\n\tdef __init__(self, string: str, clause: Clause, filespec: FileSpec) -> None:\n\t\tsuper().__init__(string, clause, filespec)\n\t\tassert(self.usestruct)\n\t\tself.filespec = filespec\n\t\tself.filespec.structsuses.append(self)\n\t\t\n\t\tself.returnsstruct = string[0] in self.filespec.structs\n\t\tif self.returnsstruct:\n\t\t\tif self.hasemu:\n\t\t\t\tstring = \"pFEp\" + string[3:]\n\t\t\telse:\n\t\t\t\tstring = \"pFp\" + string[2:]\n\t\t\n\t\tfor struct in self.filespec.structs:\n\t\t\tstring = string.replace(struct, self.filespec.structs[struct].repl)\n\t\tself.redirected = FunctionType(string, clause, self.filespec)\n\nclass _BareFunctionType(FunctionType): # Fake derived\n\tdef __new__(cls, *largs, **kwargs):\n\t\treturn object.__new__(cls)\n\tdef __init__(self, string: str, clause: Clause, filespec: FileSpec, isstruct: bool) -> None:\n\t\tself.orig = CTypeNone(string, clause, filespec)\n\t\tself.filespec = filespec\n\t\tself.isstruct = isstruct\n\t\n\tdef getchar(self, c: str) -> int:\n\t\tif c in FileSpec.rvalues:\n\t\t\treturn FileSpec.rvalues.index(c)\n\t\telse:\n\t\t\tassert(self.isstruct)\n\t\t\treturn self.filespec.structs.__keys__.index(c) + len(FileSpec.rvalues)\n\tdef getcharidx(self, i: int) -> int:\n\t\treturn self.getchar(self.orig.replaced[i])\n\t\n\tdef splitchar(self) -> List[int]:\n\t\ttry:\n\t\t\tret = [\n\t\t\t\tlen(self.orig.replaced), len(self.orig.name), self.getcharidx(0),\n\t\t\t\t*map(self.getcharidx, range(2, len(self.orig.replaced)))\n\t\t\t]\n\t\t\treturn ret\n\t\texcept ValueError as e:\n\t\t\traise ValueError(\"Value is \" + self.orig.replaced + \":\\n\" + self.orig.describe()) from e\n\t\texcept AssertionError as e:\n\t\t\traise ValueError(\"Value is \" + self.orig.replaced + \":\\n\" + self.orig.describe()) from e\n\n# Allowed GOs: GO,GOM,GO2,GOS,GOW,GOWM,GOW2,GO2S\nclass Function:\n\tdef __init__(self, name: str, funtype: FunctionType, gotype: str, filespec: FileSpec, filename: Filename, line: str) -> None:\n\t\tself._noE = False\n\t\t\n\t\tself.no_dlsym: bool = False\n\t\tif \"//%\" in line:\n\t\t\tadditional_meta = line.split(\"//%\")[1].split(\" \")[0].strip()\n\t\t\t\n\t\t\tif additional_meta.endswith(\",noE\"):\n\t\t\t\tself._noE = True\n\t\t\t\tadditional_meta = additional_meta[:-4]\n\t\t\t\n\t\t\tif additional_meta == 'noE':\n\t\t\t\tassert not self._noE, \"Duplicated 'noE'\"\n\t\t\t\tself._noE = True\n\t\t\telif additional_meta == '%':\n\t\t\t\tself.no_dlsym = True\n\t\t\telse:\n\t\t\t\traise NotImplementedError(\"Changing the function type 'on the fly' is not supported\")\n\t\t\n\t\tfuntypeerr = ValueError(\"Invalid function type \" + gotype)\n\t\tif not gotype.startswith(\"GO\"):\n\t\t\traise funtypeerr\n\t\tgotype = gotype[2:]\n\t\tself.isweak = (len(gotype) > 0) and (gotype[0] == \"W\")\n\t\tif self.isweak:\n\t\t\tgotype = gotype[1:]\n\t\tself.ismy = (len(gotype) > 0) and (gotype[0] == \"M\")\n\t\tself.is2 = (len(gotype) > 0) and (gotype[0] == \"2\")\n\t\tself.retS = (len(gotype) > 0) and (gotype[0] == \"S\")\n\t\tif self.ismy or self.is2 or self.retS:\n\t\t\tgotype = gotype[1:]\n\t\tif self.retS:\n\t\t\tself.ismy = True\n\t\t\tassert((self.no_dlsym and (funtype.orig.name.startswith(\"pFp\") or funtype.orig.name.startswith(\"pFEp\") or funtype.orig.name.startswith(\"pEp\") or funtype.orig.name.startswith(\"pEEp\")))\n\t\t\t or (isinstance(funtype, StructFunctionType) and funtype.returnsstruct)), \\\n\t\t\t\t\"Maybe TODO? (Returns unregistered structure)\"\n\t\t\tself._noE = self._noE or self.no_dlsym\n\t\tif isinstance(funtype, StructFunctionType) and funtype.returnsstruct and not self.retS:\n\t\t\tgotype = \"GO\" + \\\n\t\t\t\t(\"W\" if self.isweak else \"\") + \\\n\t\t\t\t(\"M\" if self.ismy else \"\") + (\"2\" if self.is2 else \"\")\n\t\t\traise ValueError(\"Function \" + name + \" of type \" + funtype.orig.name + \\\n\t\t\t\t\" needs to return a structure, but doesn't (currently \" + gotype + \")\")\n\t\tif gotype != \"\":\n\t\t\traise funtypeerr\n\t\t\n\t\tself.name = name\n\t\tself.type = funtype\n\t\tself.filespec = filespec\n\t\tassert(not isinstance(funtype, StructFunctionType) or filespec is funtype.filespec) # No reason why not, so assert()\n\t\t\n\t\tif self.is2:\n\t\t\tself.fun2 = line.split(',')[2].split(')')[0].strip()\n\t\t\tif (self.type.hasemu != self.fun2.startswith(\"my32_\") and self.type.hasemu != self.fun2.startswith(\"my_\")) and not self._noE:\n\t\t\t\t# If this raises because of a different prefix, open a pull request\n\t\t\t\tprint(\"\\033[91mThis is probably not what you meant!\\033[m ({0}:{1})\".format(filename, line[:-1]), file=sys.stderr)\n\t\t\t\tself.invalid = True\n\t\t\n\t\tif (self.ismy and not self.type.hasemu and not self.is2) and not self._noE:\n\t\t\t# Probably invalid on box86; if not so, remove/comment this whole 'if' (and also open an issue)\n\t\t\tprint(\"\\033[94mAre you sure of this?\\033[m ({0}:{1})\".format(filename, line[:-1]), file=sys.stderr)\n\t\t\tself.invalid = True\n\t\t\treturn\n\t\tif self.type.hasemu and not self.ismy and not self.is2:\n\t\t\t# Certified invalid\n\t\t\tprint(\"\\033[91mThis is probably not what you meant!\\033[m ({0}:{1})\".format(filename, line[:-1]), file=sys.stderr)\n\t\t\tself.invalid = True\n\t\t\treturn\n\t\tif self._noE and not self.ismy and not self.is2:\n\t\t\traise ValueError(\"Invalid meta: 'no E' provided but function is not a GOM\")\n\t\t\n\t\tif self.ismy or self.is2:\n\t\t\t# Add this to the typedefs\n\t\t\tself.filespec.typedefs[self.type.withoutE].append(self)\n\nJumbledFunctions = CustOrderedDictList[Clause, Function]\nFilesSpecific    = Dict[Filename, FileSpec]\n\nSortedGlobals    = CustOrderedDictList[Clauses, FunctionType]\nSortedRedirects  = CustOrderedDictList[Clauses, FunctionType]\n\ndef readFiles(files: Iterable[str]) -> Tuple[JumbledFunctions, JumbledFunctions, FilesSpecific]:\n\t\"\"\"\n\treadFiles\n\t\n\tThis function is the one that parses the files.\n\t\"\"\"\n\t\n\tgbls:      JumbledFunctions = CustOrderedDictList()\n\tredirects: JumbledFunctions = CustOrderedDictList()\n\tfilespecs: FilesSpecific    = {}\n\t\n\tsymbols: Dict[str, Filename] = {}\n\tneed_halt: bool = False\n\t\n\tfor filepath in files:\n\t\tfilename: Filename = filepath.split(\"/\")[-1]\n\t\tdependants: Clause = Clause()\n\t\t\n\t\tfilespec = FileSpec()\n\t\tfilespecs[filename[:-10]] = filespec\n\t\t\n\t\tdef add_symbol_name(symname: Optional[str], weak: bool = False, symsname: Dict[str, List[Tuple[str, bool]]] = {\"\": []}):\n\t\t\t# Optional arguments are evaluated only once!\n\t\t\tnonlocal need_halt\n\t\t\tif symname is None:\n\t\t\t\tfor c in symsname:\n\t\t\t\t\tif (c != \"\") and (len(symsname[c]) != 0):\n\t\t\t\t\t\t# Note: if this condition ever raises, check the wrapper pointed by it.\n\t\t\t\t\t\t# If you find no problem, comment the error below, add a \"pass\" below (so python is happy)\n\t\t\t\t\t\t# and open a ticket so I can fix this.\n\t\t\t\t\t\traise NotImplementedError(\"Some symbols are only implemented under one condition '{0}' (probably) ({1}/{2})\"\n\t\t\t\t\t\t\t\t.format(c, symsname[c][0][0], filename) + \" [extra note in the script]\")\n\t\t\t\t\tfor s, w in symsname[c]:\n\t\t\t\t\t\tif w: continue # Weak symbols never conflict with others in different libraries\n\t\t\t\t\t\t\n\t\t\t\t\t\tif s in (\n\t\t\t\t\t\t  '_init', '_fini',\n\t\t\t\t\t\t  '__bss_start', '__bss_start__', '__bss_end__', '_bss_end__',\n\t\t\t\t\t\t  '__data_start', '_edata',\n\t\t\t\t\t\t  '_end', '__end__'):\n\t\t\t\t\t\t\tcontinue # Always allow those symbols [TODO: check if OK]\n\t\t\t\t\t\tif s in symbols:\n\t\t\t\t\t\t\t# Check for resemblances between symbols[s] and filename\n\t\t\t\t\t\t\t# if filename.startswith(symbols[s][:-12]) or symbols[s].startswith(filename[:-12]):\n\t\t\t\t\t\t\t# \t# Probably OK\n\t\t\t\t\t\t\t# \tcontinue\n\t\t\t\t\t\t\t# Manual incompatible libs detection\n\t\t\t\t\t\t\tmatch = lambda l, r: (filename[7:-10], symbols[s][7:-10]) in [(l, r), (r, l)]\n\t\t\t\t\t\t\tif  match(\"gdkx112\",     \"gdk3\")        \\\n\t\t\t\t\t\t\t or match(\"gtkx112\",     \"gtk3\")        \\\n\t\t\t\t\t\t\t or match(\"libjpeg\",     \"libjpeg62\")   \\\n\t\t\t\t\t\t\t or match(\"libncurses\",  \"libncurses6\") \\\n\t\t\t\t\t\t\t or match(\"libncurses\",  \"libncursesw\") \\\n\t\t\t\t\t\t\t or match(\"libncurses6\", \"libncursesw\") \\\n\t\t\t\t\t\t\t or match(\"libtinfo6\",   \"libtinfo\")    \\\n\t\t\t\t\t\t\t or match(\"png12\",       \"png16\")       \\\n\t\t\t\t\t\t\t or match(\"sdl1\",        \"sdl2\")        \\\n\t\t\t\t\t\t\t or match(\"sdl1image\",   \"sdl2image\")   \\\n\t\t\t\t\t\t\t or match(\"sdl1mixer\",   \"sdl2mixer\")   \\\n\t\t\t\t\t\t\t or match(\"sdl1net\",     \"sdl2net\")     \\\n\t\t\t\t\t\t\t or match(\"sdl1ttf\",     \"sdl2ttf\")     \\\n\t\t\t\t\t\t\t or match(\"smpeg\",       \"smpeg2\")      \\\n\t\t\t\t\t\t\t or match(\"udev0\",       \"udev1\")       \\\n\t\t\t\t\t\t\t or match(\"gstinterfaces010\",\"gstvideo\")\\\n\t\t\t\t\t\t\t or match(\"gstinterfaces010\",\"gstaudio\")\\\n\t\t\t\t\t\t\t or match(\"gstreamer010\",\"gstreamer\")\t\\\n\t\t\t\t\t\t\t or match(\"appindicator\",\"appindicator3\")\\\n\t\t\t\t\t\t\t \\\n\t\t\t\t\t\t\t or match(\"libc\",        \"tcmallocminimal\") \\\n\t\t\t\t\t\t\t or match(\"libc\",        \"ldlinux\") \t\\\n\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t# libc and ldlinux have some \"__libc_\" data symbols in common... TODO check if ok\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t# Note: this test is very (too) simple. If it ever raises, comment\n\t\t\t\t\t\t\t# `need_halt = True` and open an issue.\n\t\t\t\t\t\t\tprint(\"The symbol {0} is declared in multiple files ({1}/{2})\"\n\t\t\t\t\t\t\t\t.format(s, symbols[s], filename) + \" [extra note in the script]\", file=sys.stderr)\n\t\t\t\t\t\t\tneed_halt = True\n\t\t\t\t\t\tsymbols[s] = filename\n\t\t\telse:\n\t\t\t\tsymname = symname.strip()\n\t\t\t\tif symname == \"\":\n\t\t\t\t\traise ValueError(\"This symbol name (\\\"\\\") is suspicious... ({0})\".format(filename))\n\t\t\t\t\n\t\t\t\tl = len(dependants.defines)\n\t\t\t\talready_pst = any(s == symname for s, _ in symsname[\"\"])\n\t\t\t\tif l == 1:\n\t\t\t\t\tsymsname.setdefault(str(dependants), [])\n\t\t\t\t\talready_pst = already_pst or any(s == symname for s, _ in symsname[str(dependants)])\n\t\t\t\tif already_pst:\n\t\t\t\t\tprint(\"The symbol {0} is duplicated! ({1})\".format(symname, filename), file=sys.stderr)\n\t\t\t\t\tneed_halt = True\n\t\t\t\t\treturn\n\t\t\t\tif l == 1:\n\t\t\t\t\ts = str(dependants.defines[0].inverted())\n\t\t\t\t\tif (s in symsname) and ((symname, weak) in symsname[s]):\n\t\t\t\t\t\tsymsname[s].remove((symname, weak))\n\t\t\t\t\t\tsymsname[\"\"].append((symname, weak))\n\t\t\t\t\telif (s in symsname) and ((symname, not weak) in symsname[s]):\n\t\t\t\t\t\tprint(\"The symbol {0} doesn't have the same 'weakness' in different conditions! ({1})\"\n\t\t\t\t\t\t\t.format(symname, filename), file=sys.stderr)\n\t\t\t\t\t\tneed_halt = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tsymsname[str(dependants)].append((symname, weak))\n\t\t\t\telif l == 0:\n\t\t\t\t\tsymsname[\"\"].append((symname, weak))\n\t\t\n\t\twith open(filepath, 'r') as file:\n\t\t\tfor line in file:\n\t\t\t\tln = line.strip()\n\t\t\t\t\n\t\t\t\ttry:\n\t\t\t\t\t# If the line is a `#' line (#ifdef LD80BITS/#ifndef LD80BITS/header)\n\t\t\t\t\tif ln.startswith(\"#\"):\n\t\t\t\t\t\tpreproc_cmd = ln[1:].strip()\n\t\t\t\t\t\tif preproc_cmd.startswith(\"if defined(GO)\"):\n\t\t\t\t\t\t\tcontinue #if defined(GO) && defined(GOM)...\n\t\t\t\t\t\telif preproc_cmd.startswith(\"if !(defined(GO)\"):\n\t\t\t\t\t\t\tcontinue #if !(defined(GO) && defined(GOM)...)\n\t\t\t\t\t\telif preproc_cmd.startswith(\"error\"):\n\t\t\t\t\t\t\tcontinue #error meh!\n\t\t\t\t\t\telif preproc_cmd.startswith(\"include\"):\n\t\t\t\t\t\t\tcontinue #inherit other library\n\t\t\t\t\t\telif preproc_cmd.startswith(\"endif\"):\n\t\t\t\t\t\t\tdependants.pop_last()\n\t\t\t\t\t\telif preproc_cmd.startswith(\"ifdef\"):\n\t\t\t\t\t\t\tdependants.append(Define(DefineType(preproc_cmd[5:].strip()), False))\n\t\t\t\t\t\telif preproc_cmd.startswith(\"ifndef\"):\n\t\t\t\t\t\t\tdependants.append(Define(DefineType(preproc_cmd[6:].strip()), True))\n\t\t\t\t\t\telif preproc_cmd.startswith(\"else\"):\n\t\t\t\t\t\t\tdependants.invert_last()\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\traise NotImplementedError(\"Unknown preprocessor directive: {0}\".format(preproc_cmd.split(\" \")[0]))\n\t\t\t\t\t\n\t\t\t\t\t# If the line is a `GO...' line (GO/GOM/GO2/...)...\n\t\t\t\t\telif ln.startswith(\"GO\"):\n\t\t\t\t\t\t# ... then look at the second parameter of the line\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tgotype = ln.split(\"(\")[0].strip()\n\t\t\t\t\t\t\tfunname = ln.split(\",\")[0].split(\"(\")[1].strip()\n\t\t\t\t\t\t\tln = ln.split(\",\")[1].split(\")\")[0].strip()\n\t\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t\traise NotImplementedError(\"Invalid GO command\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tfun = Function(funname, FunctionType(ln, dependants, filespec), gotype, filespec, filename, line)\n\t\t\t\t\t\tif not filename.endswith(\"_genvate.h\"):\n\t\t\t\t\t\t\tadd_symbol_name(fun.name, fun.isweak)\n\t\t\t\t\t\t\n\t\t\t\t\t\tif hasattr(fun, 'invalid'):\n\t\t\t\t\t\t\tneed_halt = True\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\n\t\t\t\t\t\tif fun.type.redirect or fun.type.usestruct:\n\t\t\t\t\t\t\tredirects[dependants.copy()].append(fun)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tgbls[dependants.copy()].append(fun)\n\t\t\t\t\t\n\t\t\t\t\t# If the line is a structure metadata information...\n\t\t\t\t\telif ln.startswith(\"//%S\"):\n\t\t\t\t\t\tmetadata = [e for e in ln.split() if e]\n\t\t\t\t\t\tif len(metadata) != 4:\n\t\t\t\t\t\t\t# If you need an empty replacement, please open a PR\n\t\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (too many/not enough fields)\")\n\t\t\t\t\t\tif metadata[0] != \"//%S\":\n\t\t\t\t\t\t\traise NotImplementedError(\"Invalid structure metadata supply (invalid signature)\")\n\t\t\t\t\t\t\n\t\t\t\t\t\tfilespec.registerStruct(metadata[1], metadata[2], metadata[3])\n\t\t\t\t\t\n\t\t\t\t\t# If the line contains any symbol name...\n\t\t\t\t\telif (\"GO\" in ln) or (\"DATA\" in ln):\n\t\t\t\t\t\tif filename.endswith(\"_genvate.h\"):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# Probably \"//GO(..., \" or \"DATA(...,\" at least\n\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\tsymname = ln.split('(')[1].split(',')[0].strip()\n\t\t\t\t\t\t\tadd_symbol_name(symname)\n\t\t\t\t\t\texcept IndexError:\n\t\t\t\t\t\t\t# Oops, it wasn't...\n\t\t\t\t\t\t\tpass\n\t\t\t\texcept Exception as e:\n\t\t\t\t\traise NotImplementedError(\"{0}:{1}\".format(filename, line[:-1])) from e\n\t\t\n\t\tif filename.endswith(\"_genvate.h\"):\n\t\t\tdel filespecs[filename[:-10]]\n\t\t\n\t\tadd_symbol_name(None)\n\t\tFunctionType.getSingletons().clear()\n\t\n\tif need_halt:\n\t\traise ValueError(\"Fix all previous errors before proceeding\")\n\t\n\treturn gbls, redirects, filespecs\n\ndef sortArrays(gbl_funcs: JumbledFunctions, red_funcs: JumbledFunctions, filespecs: FilesSpecific) \\\n -> Tuple[SortedGlobals, SortedRedirects]:\n\t# First sort file specific stuff\n\tfor fn in filespecs:\n\t\tfilespecs[fn].typedefs.sort(key=_BareFunctionType.splitchar)\n\t\tfor funtype in filespecs[fn].typedefs:\n\t\t\tfilespecs[fn].typedefs[funtype].sort(key=lambda f: f.name)\n\t\t\n\t\tfilespecs[fn].structs.sort()\n\t\tfilespecs[fn].structsuses.sort(key=FunctionType.splitchar)\n\t\n\t# Now, take all function types, and make a new table gbl_vals\n\t# This table contains all #if conditions for when a function type needs to\n\t# be generated.\n\tdef add_to_vals(vals: Dict[FunctionType, Clauses], t: FunctionType, clause: Clause) -> None:\n\t\tvals.setdefault(t, Clauses())\n\t\tif clause in vals[t].clauses: return\n\t\tvals[t].add(clause)\n\t\n\tgbl_vals: Dict[FunctionType, Clauses] = {}\n\tfor clause in gbl_funcs:\n\t\tfor f in gbl_funcs[clause]:\n\t\t\tadd_to_vals(gbl_vals, f.type, clause)\n\tfor clause in red_funcs:\n\t\tfor f in red_funcs[clause]:\n\t\t\tassert(f.type.redirected is not None)\n\t\t\tadd_to_vals(gbl_vals, f.type.redirected, clause)\n\t\n\t# Remove duplicate/useless conditions (and sort)\n\tfor t in gbl_vals:\n\t\tgbl_vals[t].reduce()\n\t\n\t# Now create a new gbls\n\t# gbls will contain the final version of gbls (without duplicates, based on\n\t# gbl_vals), meaning, a dict from clauses to function types to implement\n\tgbls: SortedGlobals = CustOrderedDictList()\n\tfor funtype in gbl_vals:\n\t\tgbls[gbl_vals[funtype]].append(funtype)\n\t# Sort the #if clauses as defined in `splitdef`\n\tgbls.sort(key=Clauses.splitdef)\n\t\n\t# Sort the function types as defined in `splitchar`\n\tfor clauses in gbls:\n\t\tgbls[clauses].sort(key=FunctionType.splitchar)\n\t\n\t# This map will contain all additional function types that are \"redirected\"\n\t# to an already defined type (with some remapping).\n\tred_vals: Dict[FunctionType, Clauses] = {}\n\tfor clause in red_funcs:\n\t\tfor f in red_funcs[clause]:\n\t\t\tif isinstance(f.type, StructFunctionType): continue\n\t\t\tassert(f.type.redirected is not None)\n\t\t\tadd_to_vals(red_vals, f.type, clause)\n\t\n\t# Also do the same sorting as before (it also helps keep the order\n\t# in the file deterministic)\n\tfor t in red_vals:\n\t\tred_vals[t].reduce()\n\t\n\tredirects: SortedRedirects = CustOrderedDictList()\n\tfor funtype in red_vals:\n\t\tredirects[red_vals[funtype]].append(funtype)\n\tredirects.sort(key=Clauses.splitdef)\n\t\n\tdef fail(): assert False, \"value has no redirect\"\n\tfor clauses in redirects:\n\t\tredirects[clauses].sort(key=lambda v: fail() if v.redirected is None else v.splitchar() + v.redirected.splitchar())\n\t\n\treturn gbls, redirects\n\ndef checkRun(root: str, gbls: SortedGlobals, redirects: SortedRedirects, filesspec: FilesSpecific) -> Optional[str]:\n\t# Check if there was any new functions compared to last run\n\tfunctions_list: str = \"\"\n\tfor clauses in gbls:\n\t\tfor v in gbls[clauses]:\n\t\t\tfunctions_list = functions_list + \"#\" + str(clauses) + \" \" + v.orig.name + \" -> \" + v.orig.replaced + \"\\n\"\n\tfor clauses in redirects:\n\t\tfor v in redirects[clauses]:\n\t\t\tassert(v.redirected is not None)\n\t\t\tfunctions_list = functions_list + \"#\" + str(clauses) + \" \" + v.orig.name + \" -> \" + v.redirected.orig.name + \"\\n\"\n\tfor filename in sorted(filesspec.keys()):\n\t\tfunctions_list = functions_list + filename + \":\\n\"\n\t\tfor st in filesspec[filename].structs:\n\t\t\tstruct = filesspec[filename].structs[st]\n\t\t\tfunctions_list = functions_list + \\\n\t\t\t\t\"% \" + st + \" \" + struct.name + \" \" + struct.repl + \"\\n\"\n\t\tfor _bare in filesspec[filename].typedefs:\n\t\t\tfunctions_list = functions_list + \"- \" + _bare.orig.name + \":\\n\"\n\t\t\tfor fn in filesspec[filename].typedefs[_bare]:\n\t\t\t\tif fn.no_dlsym: continue\n\t\t\t\tfunctions_list = functions_list + \"  - \" + fn.name + \"\\n\"\n\t\tfor funtype in filesspec[filename].structsuses:\n\t\t\tassert(funtype.redirected is not None)\n\t\t\tfunctions_list = functions_list + \"% \" + funtype.orig.name + \" -> \" + funtype.redirected.orig.name + \"\\n\"\n\t\n\t# functions_list is a unique string, compare it with the last run\n\ttry:\n\t\tlast_run = \"\"\n\t\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", \"functions_list.txt\"), 'r') as file:\n\t\t\tlast_run = file.read()\n\t\tif last_run == functions_list:\n\t\t\t# Mark as OK for CMake\n\t\t\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", \"functions_list.txt\"), 'w') as file:\n\t\t\t\tfile.write(functions_list)\n\t\t\treturn None\n\texcept IOError:\n\t\t# The file does not exist yet, first run\n\t\tpass\n\t\n\treturn functions_list\n\ndef generate_files(root: str, files: Iterable[str], ver: str, gbls: SortedGlobals, redirects: SortedRedirects, \\\n filespecs: FilesSpecific) -> None:\n\t# Generate converters\n\tasreturns = [\n\t\t\"\\n#error Invalid return type: emulator\\n\",                           # E\n\t\t\"fn({0});\",                                                           # v\n\t\t\"R_EAX = fn({0});\",                                                   # c\n\t\t\"R_EAX = fn({0});\",                                                   # w\n\t\t\"R_EAX = fn({0});\",                                                   # i\n\t\t\"ui64_t r; r.i = fn({0}); R_EAX = r.d[0]; R_EDX = r.d[1];\",           # I\n\t\t\"R_EAX = (unsigned char)fn({0});\",                                    # C\n\t\t\"R_EAX = (unsigned short)fn({0});\",                                   # W\n\t\t\"R_EAX = (uint32_t)fn({0});\",                                         # u\n\t\t\"ui64_t r; r.u = (uint64_t)fn({0}); R_EAX = r.d[0]; R_EDX = r.d[1];\", # U\n\t\t\"float fl = fn({0}); fpu_do_push(emu); ST0val = fl;\",                 # f\n\t\t\"double db = fn({0}); fpu_do_push(emu); ST0val = db;\",                # d\n\t\t\"long double ld = fn({0}); fpu_do_push(emu); ST0val = ld;\",           # D\n\t\t\"double db = fn({0}); fpu_do_push(emu); ST0val = db;\",                # K\n\t\t\"R_EAX = to_long(fn({0}));\",                                          # l\n\t\t\"R_EAX = to_ulong(fn({0}));\",                                         # L\n\t\t\"R_EAX = to_ptrv(fn({0}));\",                                          # p\n\t\t\"R_EAX = to_hash(fn({0}));\",                                          # h\n\t\t\"R_EAX = to_hash_d(fn({0}));\",                                        # H\n\t\t\"R_EAX = to_locale(fn({0}));\",                                        # a\n\t\t\"R_EAX = to_locale_d(fn({0}));\",                                      # A\n\t\t\"\\n#error Invalid return type: va_list\\n\",                            # V\n\t\t\"\\n#error Invalid return type: at_flags\\n\",                           # O\n\t\t\"R_EAX = to_ptrv(io_convert_from(fn({0})));\",                         # S\n\t\t\"\\n#error Invalid return type: _2uint_struct\\n\",                      # 2\n\t\t\"\\n#error Invalid return type: Vulkan Struct\\n\",                      # P\n\t\t\"\\n#error Invalid return type: ... with 1 arg\\n\",                     # N\n\t\t\"\\n#error Invalid return type: ... with 2 args\\n\",                    # M\n\t\t\"\\n#error Invalid return type: address on the stack\\n\",               # s\n\t\t\"\\n#error Invalid return type: ro structure declaration\\n\",           # r\n\t\t\"\\n#error Invalid return type: rw structure declaration\\n\",           # b\n\t\t\"\\n#error Invalid return type: wo structure declaration\\n\",           # B\n\t\t\"\\n#error Invalid return type: end of structure declaration\\n\",       # _\n\t\t\"R_EAX = to_cstring(fn({0}));\",                                       # t\n\t\t\"R_EAX = to_ptrv(addDisplay(fn({0})));\",           \t  \t\t\t  \t  # X\n\t\t\"\\n#error Invalid return type: xcb_connection_t*\\n\",       \t\t\t  # n\n\t]\n\tasargs = [\n\t\t\"emu, \",                                              # E\n\t\t\"\",                                                   # v\n\t\t\"from_ptri(int8_t, R_ESP + {p}), \",                   # c\n\t\t\"from_ptri(int16_t, R_ESP + {p}), \",                  # w\n\t\t\"from_ptri(int32_t, R_ESP + {p}), \",                  # i\n\t\t\"from_ptri(int64_t, R_ESP + {p}), \",                  # I\n\t\t\"from_ptri(uint8_t, R_ESP + {p}), \",                  # C\n\t\t\"from_ptri(uint16_t, R_ESP + {p}), \",                 # W\n\t\t\"from_ptri(uint32_t, R_ESP + {p}), \",                 # u\n\t\t\"from_ptri(uint64_t, R_ESP + {p}), \",                 # U\n\t\t\"from_ptri(float, R_ESP + {p}), \",                    # f\n\t\t\"from_ptri(double, R_ESP + {p}), \",                   # d\n\t\t\"LD2localLD(from_ptrv(R_ESP + {p})), \",       \t\t  # D\n\t\t\"FromLD(from_ptrv(R_ESP + {p})), \",           \t\t  # K\n\t\t\"from_long(from_ptri(long_t, R_ESP + {p})), \",        # l\n\t\t\"from_ulong(from_ptri(ulong_t, R_ESP + {p})), \",      # L\n\t\t\"from_ptriv(R_ESP + {p}), \",      \t\t\t\t\t  # p\n\t\t\"from_hash(from_ptri(ptr_t, R_ESP + {p})), \",         # h\n\t\t\"from_hash_d(from_ptri(ptr_t, R_ESP + {p})), \",       # H\n\t\t\"from_locale(from_ptri(ptr_t, R_ESP + {p})), \",       # a\n\t\t\"from_locale_d(from_ptri(ptr_t, R_ESP + {p})), \",     # A\n\t\t\"from_ptrv(R_ESP + {p}), \",                   \t\t  # V\n\t\t\"of_convert32(from_ptri(int32_t, R_ESP + {p})), \",    # O\n\t\t\"io_convert32(from_ptriv(R_ESP + {p})), \",     \t\t  # S\n\t\t\"(_2uint_struct_t){{from_ptri(uint32_t, R_ESP + {p}),from_ptri(uint32_t, R_ESP + {p} + 4)}}, \", # 2\n\t\t\"arg_{p}, \",                                          # P\n\t\t\"from_ptriv(R_ESP + {p}), \",                 \t\t  # N\n\t\t\"from_ptriv(R_ESP + {p}),from_ptriv(R_ESP + {p} + 4), \", # M\n\t\t\"from_ptrv(R_ESP + {p}), \",                   \t\t  # s\n\t\t\"\\n#error Invalid argument type: ro structure declaration\\n\",     # r\n\t\t\"\\n#error Invalid argument type: rw structure declaration\\n\",     # b\n\t\t\"\\n#error Invalid argument type: wo structure declaration\\n\",     # B\n\t\t\"\\n#error Invalid argument type: end of structure declaration\\n\", # _\n\t\t\"\\n#error Invalid argument type: maybe-high string\\n\",# t\n\t\t\"getDisplay(from_ptriv(R_ESP + {p})), \", \t\t      # X\n\t\t\"aligned_xcb, \", \t\t      \t\t\t\t\t\t  # n\n\t]\n\tif len(FileSpec.values) != len(asreturns):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(asreturns) = {lenvals}\".format(lenval=len(FileSpec.values), lenvals=len(asreturns)))\n\tif len(FileSpec.values) != len(asargs):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(asargs) = {lenarg}\".format(lenval=len(FileSpec.values), lenarg=len(asargs)))\n\tfor value, asret, asarg in zip(FileSpec.values, asreturns, asargs):\n\t\tfor ctrw in (CType.ReadWrite.none, CType.ReadWrite.readonly, CType.ReadWrite.writeonly, CType.ReadWrite.readwrite):\n\t\t\tif (value, CType.ReadWrite.none) not in CType:\n\t\t\t\tcontinue # TODO: remove this and fail if one base type is missing?\n\t\t\tCType[(value, CType.ReadWrite.none)].asret = asret\n\t\t\tCType[(value, CType.ReadWrite.none)].aspre = \"\"\n\t\t\tCType[(value, CType.ReadWrite.none)].asarg = asarg\n\t\t\tCType[(value, CType.ReadWrite.none)].aspost = \"\"\n\t\t\tif value == 'n':\n\t\t\t\tCType[(value, CType.ReadWrite.none)].aspre = f\"void *aligned_xcb = align_xcb_connection32(from_ptriv(R_ESP + {{p}})); \"\n\t\t\t\tCType[(value, CType.ReadWrite.none)].aspost = f\" unalign_xcb_connection32(aligned_xcb, from_ptriv(R_ESP + {{p}}));\"\n\tfor ctn in CType.getSingletons():\n\t\tCType[ctn].generate_converters()\n\t\n\t# Detect functions which return in an x87 register\n\treturn_x87: str = \"DKdf\"\n\tif any(c not in FileSpec.values for c in return_x87):\n\t\traise NotImplementedError(\"Invalid character\")\n\t\n\t# Files header and guard\n\tfiles_header = {\n\t\t\"wrapper32.c\": \"\"\"\n\t\t#include <errno.h>\n\t\t#include <stdio.h>\n\t\t#include <stdlib.h>\n\t\t#include <stdint.h>\n\t\t\n\t\t#include \"wrapper32.h\"\n\t\t#include \"emu/x64emu_private.h\"\n\t\t#include \"emu/x87emu_private.h\"\n\t\t#include \"regs.h\"\n\t\t#include \"x64emu.h\"\n\t\t#include \"box32.h\"\n\t\t#include \"converter32.h\"\n\t\t\n\t\ttypedef union ui64_s {lbr}\n\t\t    int64_t     i;\n\t\t    uint64_t    u;\n\t\t    uint32_t    d[2];\n\t\t{rbr} ui64_t;\n\t\t\n\t\ttypedef struct _2uint_struct_s {lbr}\n\t\t\tuint32_t\ta;\n\t\t\tuint32_t\tb;\n\t\t{rbr} _2uint_struct_t;\n\t\t\n\t\textern void* my__IO_2_1_stderr_;\n\t\textern void* my__IO_2_1_stdin_ ;\n\t\textern void* my__IO_2_1_stdout_;\n\t\t\n\t\tstatic void* io_convert32(void* v)\n\t\t{lbr}\n\t\t\tif(!v)\n\t\t\t\treturn v;\n\t\t\tif(v==my__IO_2_1_stderr_)\n\t\t\t\treturn stderr;\n\t\t\tif(v==my__IO_2_1_stdin_)\n\t\t\t\treturn stdin;\n\t\t\tif(v==my__IO_2_1_stdout_)\n\t\t\t\treturn stdout;\n\t\t\treturn v;\n\t\t{rbr}\n\n\t\tstatic void* io_convert_from(void* v)\n\t\t{lbr}\n\t\t\tif(!v)\n\t\t\t\treturn v;\n\t\t\tif(v==stderr)\n\t\t\t\treturn my__IO_2_1_stderr_;\n\t\t\tif(v==stdin)\n\t\t\t\treturn my__IO_2_1_stdin_;\n\t\t\tif(v==stdout)\n\t\t\t\treturn my__IO_2_1_stdout_;\n\t\t\treturn v;\n\t\t{rbr}\n\t\t\n\t\ttypedef struct my_GValue_s\n\t\t{lbr}\n\t\t  int         g_type;\n\t\t  union {lbr}\n\t\t    int        v_int;\n\t\t    int64_t    v_int64;\n\t\t    uint64_t   v_uint64;\n\t\t    float      v_float;\n\t\t    double     v_double;\n\t\t    void*      v_pointer;\n\t\t  {rbr} data[2];\n\t\t{rbr} my_GValue_t;\n\t\t\n\t\tstatic void alignGValue(my_GValue_t* v, void* value)\n\t\t{lbr}\n\t\t    v->g_type = *(int*)value;\n\t\t    memcpy(v->data, value+4, 2*sizeof(double));\n\t\t{rbr}\n\t\tstatic void unalignGValue(void* value, my_GValue_t* v)\n\t\t{lbr}\n\t\t    *(int*)value = v->g_type;\n\t\t    memcpy(value+4, v->data, 2*sizeof(double));\n\t\t{rbr}\n\t\t\n\t\tvoid* VulkanFromx86(void* src, void** save);\n\t\tvoid VulkanTox86(void* src, void* save);\n\t\t\n\t\t#define ST0val ST0.d\n\t\t\n\t\tint of_convert32(int);\n\n\t\tvoid* getDisplay(void*);\n\t\tvoid* addDisplay(void*);\n\t\t\n\t\tvoid* align_xcb_connection32(void* src);\n\t\tvoid unalign_xcb_connection32(void* src, void* dst);\n\n\t\t\"\"\",\n\t\t\"wrapper32.h\": \"\"\"\n\t\t#ifndef __WRAPPER32_H_\n\t\t#define __WRAPPER32_H_\n\t\t#include <stdint.h>\n\t\t#include <string.h>\n\t\t\n\t\ttypedef struct x64emu_s x64emu_t;\n\t\t\n\t\t// the generic wrapper pointer functions\n\t\ttypedef void (*wrapper_t)(x64emu_t* emu, uintptr_t fnc);\n\t\t\n\t\t// list of defined wrappers\n\t\t// E = current x64emu struct\n\t\t// v = void\n\t\t// C = unsigned byte c = char\n\t\t// W = unsigned short w = short\n\t\t// u = uint32, i = int32\n\t\t// U = uint64, I = int64\n\t\t// L = unsigned long, l = signed long (long is an int with the size of a pointer)\n\t\t// p = pointer\n\t\t// h = hash (32<->64bits)\n\t\t// H = hash (32<->64bits) that will be deleted from hashmaps\n\t\t// a = locale\n\t\t// A = locale that will be deleted from hashmaps\n\t\t// f = float, d = double, D = long double, K = fake long double\n\t\t// V = vaargs, s = address on the stack (doesn't move forward the pointer)\n\t\t// O = libc O_ flags bitfield\n\t\t// o = stdout\n\t\t// S = _IO_2_1_stdXXX_ pointer (or FILE*)\n\t\t// 2 = struct of 2 uint\n\t\t// N = ... automatically sending 1 arg\n\t\t// M = ... automatically sending 2 args\n\t\t// P = Vulkan struct pointer\n\t\t// r..._ = pointer to read-only structure\n\t\t// B..._ = pointer to write-only structure\n\t\t// b..._ = pointer to read-write structure\n\t\t// t = char* as a return value (copies to a lower address if the return address is too high)\n\t\t// X = Display*\n\t\t\n\t\t\"\"\",\n\t\t\"converter32.c\": \"\"\"\n\t\t#include \"converter32.h\"\n\t\t\"\"\",\n\t\t\"converter32.h\": \"\"\"\n\t\t#ifndef __CONVERTER32_H_\n\t\t#define __CONVERTER32_H_\n\t\t\"\"\",\n\t\t\"fntypes32.h\": \"\"\"\n\t\t#ifndef __{filename}TYPES32_H_\n\t\t#define __{filename}TYPES32_H_\n\t\t\n\t\t#ifndef LIBNAME\n\t\t#error You should only #include this file inside a wrapped*.c file\n\t\t#endif\n\t\t#ifndef ADDED_FUNCTIONS\n\t\t#define ADDED_FUNCTIONS() \n\t\t#endif\n\t\t\n\t\t\"\"\",\n\t\t\"fndefs32.h\": \"\"\"\n\t\t#ifndef __{filename}DEFS32_H_\n\t\t#define __{filename}DEFS32_H_\n\t\t\n\t\t\"\"\",\n\t\t\"fnundefs32.h\": \"\"\"\n\t\t#ifndef __{filename}UNDEFS32_H_\n\t\t#define __{filename}UNDEFS32_H_\n\t\t\n\t\t\"\"\"\n\t}\n\tfiles_guard = {\n\t\t\"wrapper32.c\": \"\"\"\n\t\t\"\"\",\n\t\t\"wrapper32.h\": \"\"\"\n\t\t#endif // __WRAPPER32_H_\n\t\t\"\"\",\n\t\t\"converter32.c\": \"\"\"\n\t\t\"\"\",\n\t\t\"converter32.h\": \"\"\"\n\t\t#endif // __CONVERTER32_H_\n\t\t\"\"\",\n\t\t\"fntypes32.h\": \"\"\"\n\t\t#endif // __{filename}TYPES32_H_\n\t\t\"\"\",\n\t\t\"fndefs32.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}DEFS32_H_\n\t\t\"\"\",\n\t\t\"fnundefs32.h\": \"\"\"\n\t\t\n\t\t#endif // __{filename}UNDEFS32_H_\n\t\t\"\"\"\n\t}\n\tbanner = \"/***********************************************************\" + ('*'*len(ver)) + \"***\\n\" \\\n\t         \" * File automatically generated by rebuild_wrappers_32.py (v\" + ver + \") *\\n\" \\\n\t         \" ***********************************************************\" + ('*'*len(ver)) + \"***/\\n\"\n\ttrim: Callable[[str], str] = lambda string: '\\n'.join(line[2:] for line in string.splitlines())[1:]\n\t# Yes, the for loops are inverted. This is because both dicts should have the same keys.\n\tfor fhdr in files_guard:\n\t\tfiles_header[fhdr] = banner + trim(files_header[fhdr])\n\tfor fhdr in files_header:\n\t\tfiles_guard[fhdr] = trim(files_guard[fhdr])\n\t\n\t# Typedefs\n\t#           E            v       c         w          i          I          C          W           u           U           f        d         D              K         l           L            p        h            H            a        A        V        O          S        2                  P        N      M      s        r               b               B               _               t          X       n\n\ttdtypes = [\"x64emu_t*\", \"void\", \"int8_t\", \"int16_t\", \"int32_t\", \"int64_t\", \"uint8_t\", \"uint16_t\", \"uint32_t\", \"uint64_t\", \"float\", \"double\", \"long double\", \"double\", \"intptr_t\", \"uintptr_t\", \"void*\", \"uintptr_t\", \"uintptr_t\", \"void*\", \"void*\", \"void*\", \"int32_t\", \"void*\", \"_2uint_struct_t\", \"void*\", \"...\", \"...\", \"void*\", \"\\n#error _\\n\", \"\\n#error _\\n\", \"\\n#error _\\n\", \"\\n#error _\\n\", \"char*\", \"void*\", \"void*\"]\n\tif len(FileSpec.values) != len(tdtypes):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(tdtypes) = {lentypes}\".format(lenval=len(FileSpec.values), lentypes=len(tdtypes)))\n\tdef generate_typedefs(funs: Iterable[FunctionType], file):\n\t\tfor funtype in funs:\n\t\t\tdef getstr(i: int, ct: CType) -> str:\n\t\t\t\tif ct.type != CType.ReadWrite.none:\n\t\t\t\t\treturn ct.structname2 + \"_t*\"\n\t\t\t\telif i < len(tdtypes):\n\t\t\t\t\treturn tdtypes[i]\n\t\t\t\telse:\n\t\t\t\t\t# We are in a *types.h file\n\t\t\t\t\tassert(isinstance(funtype, _BareFunctionType) and funtype.isstruct)\n\t\t\t\t\treturn funtype.filespec.structs[funtype.filespec.structs.__keys__[i - len(tdtypes)]].name\n\t\t\tif funtype.orig.name.endswith(\"Ev\"):\n\t\t\t\tfile.write(\"typedef \" + getstr(funtype.getcharidx(0), funtype.orig.recursive[0])\n\t\t\t\t            + \" (*\" + funtype.orig.name + \"_t)\" + \"(\"\n\t\t\t\t            + getstr(funtype.getcharidx(2), funtype.orig.recursive[2]) + \");\\n\")\n\t\t\telse:\n\t\t\t\tfile.write(\"typedef \" + getstr(funtype.getcharidx(0), funtype.orig.recursive[0])\n\t\t\t\t            + \" (*\" + funtype.orig.name + \"_t)\" + \"(\"\n\t\t\t\t            + ', '.join(getstr(funtype.getcharidx(i), funtype.orig.recursive[i])\n\t\t\t\t                                   for i in range(2, len(funtype.orig.replaced))) + \");\\n\")\n\t\n\t# Wrappers\n\t#         E  v  c  w  i  I  C  W  u  U  f  d  D   K   l  L  p  h  H  a  A  V  O  S  2  P  N  M  s  r  b  B  _  t  X  n\n\tdeltas = [0, 4, 4, 4, 4, 8, 4, 4, 4, 8, 4, 8, 12, 12, 4, 4, 4, 4, 4, 4, 4, 1, 4, 4, 8, 4, 0, 0, 0, 1, 1, 4, 1, 4, 4, 4]\n\t# Asserts\n\tif len(FileSpec.values) != len(deltas):\n\t\traise NotImplementedError(\"len(values) = {lenval} != len(deltas) = {lendeltas}\".format(lenval=len(FileSpec.values), lendeltas=len(deltas)))\n\t\n\t# Helper functions to write the function definitions\n\tdef function_args(args: Iterable[Tuple[CType, str]], map: Callable[[CType], str], d: int = 4) -> str:\n\t\td = 4\n\t\tret = \"\"\n\t\tfor arg, c in args:\n\t\t\tif d % 4 != 0:\n\t\t\t\traise ValueError(\"{d} is not a multiple of 4. Did you try passing a V then something else?\".format(d=d))\n\t\t\t\n\t\t\ttry:\n\t\t\t\tret = ret + map(arg).format(p=d)\n\t\t\t\td = d + deltas[FileSpec.values.index(c)]\n\t\t\texcept KeyError as e:\n\t\t\t\traise ValueError(arg.describe()) from e\n\t\treturn ret\n\t\n\tdef function_writer(f, N: FunctionType, W: str) -> None:\n\t\tf.write(\"void {0}_32(x64emu_t *emu, uintptr_t fcn) {2} {1} fn = ({1})fcn; \".format(N.orig.name, W, \"{\"))\n\t\t\n\t\targs = (N.orig.recursive[2:], N.orig.replaced[2:])\n\t\tif len(args[0]) == 0:\n\t\t\traise ValueError(\"Failed to properly parse {0}:\\n{1}\\nrecursive has length {2} < 3\"\n\t\t\t\t.format(N.orig.name, N.orig.describe(), len(N.orig.recursive)))\n\t\tif len(args[1]) == 0:\n\t\t\traise ValueError(\"Failed to properly parse {0}:\\n{1}\\nreplaced ({2}) has length {3} < 3\"\n\t\t\t\t.format(N.orig.name, N.orig.describe(), N.orig.replaced, len(N.orig.replaced)))\n\t\tif len(args[0]) != len(args[1]):\n\t\t\traise ValueError(\"Failed to properly parse {0}:\\n{1}\\nrecursive has length {2}, replaced has length {3}\"\n\t\t\t\t.format(N.orig.name, N.orig.describe(), len(args[0])+2, len(args[1])+2))\n\t\tif (len(args[0]) == 2) and (args[0][0].name == 'E') and (args[0][1].name == 'v'): args = ([args[0][0]], args[1][0])\n\t\t\n\t\t#if any(c in 'PG' for c in args):\n\t\t#\t# Vulkan struct or GValue pointer, need to unwrap functions at the end\n\t\t#\tdelta = 4\n\t\t#\tfor c in args:\n\t\t#\t\tif c == 'P':\n\t\t#\t\t\tf.write(\"void* save{d} = NULL; void *arg{d} = VulkanFromx86(*(void**)(R_ESP + {d}), &save{d}); \".format(d=delta))\n\t\t#\t\tif c == 'G':\n\t\t#\t\t\tf.write(\"my_GValue_t arg{d}; alignGValue(&arg{d}, *(void**)(R_ESP + {d})); \".format(d=delta))\n\t\t#\t\tdelta = delta + deltas[FileSpec.values.index(c)]\n\t\t#\tf.write(vals[FileSpec.values.index(N.orig[0])].format(function_args(args)[:-2]))\n\t\t#\tdelta = 4\n\t\t#\tfor c in args:\n\t\t#\t\tif c == 'P':\n\t\t#\t\t\tf.write(\" VulkanTox86(arg{d}, save{d});\".format(d=delta))\n\t\t#\t\tif c == 'G':\n\t\t#\t\t\tf.write(\" unalignGValue(*(void**)(R_ESP + {d}), &arg{d});\".format(d=delta))\n\t\t#\t\tdelta = delta + deltas[FileSpec.values.index(c)]\n\t\t#\tf.write(\" }\\n\")\n\t\t#else:\n\t\t#\t# Generic function\n\t\t#\tf.write(vals[FileSpec.values.index(N.orig[0])].format(function_args(args)[:-2]) + \" }\\n\")\n\t\tassert 'P' not in N.orig.name, \"TODO: add back Vulkan compatibility\"\n\t\tdef assertex(v: Optional[T]) -> T:\n\t\t\tassert v is not None, \"Value is None\"\n\t\t\treturn v\n\t\tif N.orig.recursive[1].structname == 'E':\n\t\t\tf.write(\"errno = emu->libc_err; \")\n\t\tf.write(function_args(zip(args[0], args[1]), lambda ct: assertex(ct.aspre)))\n\t\tf.write(assertex(N.orig.recursive[0].asret).format(function_args(zip(args[0], args[1]), lambda ct: assertex(ct.asarg))[:-2]))\n\t\tf.write(function_args(zip(args[0], args[1]), lambda ct: assertex(ct.aspost)))\n\t\tif N.orig.recursive[1].structname == 'E':\n\t\t\tf.write(\" emu->libc_err = errno;\")\n\t\tf.write(\" }\\n\")\n\t\n\t# TODO: src/wrapped/generated32/converter32.c&h\n\t# Rewrite the wrapper.c file:\n\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", \"wrapper32.c\"), 'w') as file:\n\t\tfile.write(files_header[\"wrapper32.c\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\t\n\t\t# First part: typedefs\n\t\tfor clauses in gbls:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tgenerate_typedefs(gbls[clauses], file)\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\n\t\tfile.write(\"\\n\")\n\t\t\n\t\t# Next part: function definitions\n\t\t\n\t\tfor clauses in gbls:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in gbls[clauses]:\n\t\t\t\tfunction_writer(file, funtype, funtype.orig.name + \"_t\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\n\")\n\t\tfor clauses in redirects:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in redirects[clauses]:\n\t\t\t\tassert(funtype.redirected is not None)\n\t\t\t\tfunction_writer(file, funtype, funtype.redirected.orig.name + \"_t\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\t\n\t\t# Write the isRetX87Wrapper function\n\t\t# isRetX87Wrapper\n\t\tfile.write(\"\\nint isRetX87Wrapper32(wrapper_t fun) {\\n\")\n\t\tfor clauses in gbls:\n\t\t\tempty = True\n\t\t\tfor funtype in gbls[clauses]:\n\t\t\t\tif funtype.orig.name[0] in return_x87: # TODO: put this in a function (functions would request the ABI for more info)\n\t\t\t\t\tif empty and (not clauses.empty()):\n\t\t\t\t\t\tfile.write(\"#if \" + str(clauses) + \"\\n\")\n\t\t\t\t\t\tempty = False\n\t\t\t\t\tfile.write(\"\\tif (fun == &\" + funtype.orig.name + \"_32) return 1;\\n\")\n\t\t\tif not empty:\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\treturn 0;\\n}\\n\")\n\t\t\n\t\tfile.write(files_guard[\"wrapper32.c\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\n\t# Rewrite the wrapper32.h file:\n\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", \"wrapper32.h\"), 'w') as file:\n\t\tfile.write(files_header[\"wrapper32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\tfor clauses in gbls:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in gbls[clauses]:\n\t\t\t\tfile.write(\"void \" + funtype.orig.name + \"_32(x64emu_t *emu, uintptr_t fnc);\\n\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(\"\\n\")\n\t\tfor clauses in redirects:\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"\\n#if \" + str(clauses) + \"\\n\")\n\t\t\tfor funtype in redirects[clauses]:\n\t\t\t\tfile.write(\"void \" + funtype.orig.name + \"_32(x64emu_t *emu, uintptr_t fnc);\\n\")\n\t\t\tif not clauses.empty():\n\t\t\t\tfile.write(\"#endif\\n\")\n\t\tfile.write(files_guard[\"wrapper32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver))\n\t\n\tfor fn in filespecs:\n\t\ttdtypes[FileSpec.values.index('V')] = \"...\"\n\t\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", fn + \"types32.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fntypes32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tgenerate_typedefs(filespecs[fn].typedefs, file)\n\t\t\tfile.write(\"\\n#define SUPER() ADDED_FUNCTIONS()\")\n\t\t\tfor _bare in filespecs[fn].typedefs:\n\t\t\t\tfor fun in filespecs[fn].typedefs[_bare]:\n\t\t\t\t\tif fun.no_dlsym: continue\n\t\t\t\t\tfile.write(\" \\\\\\n\\tGO({0}, {1}_t)\".format(fun.name, _bare.orig.name))\n\t\t\tfile.write(\"\\n\\n\")\n\t\t\tfile.write(files_guard[\"fntypes32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", fn + \"defs32.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fndefs32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tfor defined in filespecs[fn].structsuses:\n\t\t\t\tassert defined.redirected is not None, \"Unreachable?\"\n\t\t\t\tfile.write(\"#define {defined} {define}\\n\".format(defined=defined.orig.name, define=defined.redirected.orig.name))\n\t\t\t\tfile.write(\"#define {defined}_32 {define}_32\\n\".format(defined=defined.orig.name, define=defined.redirected.orig.name))\n\t\t\tfile.write(files_guard[\"fndefs32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\n\t\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", fn + \"undefs32.h\"), 'w') as file:\n\t\t\tfile.write(files_header[\"fnundefs32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\t\t\tfor defined in filespecs[fn].structsuses:\n\t\t\t\tfile.write(\"#undef {defined}\\n\".format(defined=defined.orig.name))\n\t\t\t\tfile.write(\"#undef {defined}_32\\n\".format(defined=defined.orig.name))\n\t\t\tfile.write(files_guard[\"fnundefs32.h\"].format(lbr=\"{\", rbr=\"}\", version=ver, filename=fn))\n\ndef main(root: str, files: Iterable[str], ver: str):\n\t\"\"\"\n\tmain -- The main function\n\t\n\troot: the root path (where the CMakeLists.txt is located)\n\tfiles: a list of files to parse (wrapped*.h)\n\tver: version number\n\t\"\"\"\n\t\n\t# First read the files inside the headers\n\tgbl_funcs, red_funcs, filespecs = readFiles(files)\n\t\n\tif all(not c.empty() for c in gbl_funcs) or all(not c.empty() for c in red_funcs):\n\t\tprint(\"\\033[1;31mThere is suspiciously not many types...\\033[m\", file=sys.stderr)\n\t\tprint(\"Check the CMakeLists.txt file. If you are SURE there is nothing wrong\"\n\t\t\t  \" (as a random example, `set()` resets the variable...), then comment out the following return.\", file=sys.stderr)\n\t\tprint(\"(Also, the program WILL crash later if you proceed.)\", file=sys.stderr)\n\t\treturn 2 # Check what you did, not proceeding\n\t\n\tgbls, redirects = sortArrays(gbl_funcs, red_funcs, filespecs)\n\t\n\t# Check if there was any new functions\n\tfunctions_list = checkRun(root, gbls, redirects, filespecs)\n\tif functions_list is None:\n\t\tprint(\"Detected same build as last run, skipping\")\n\t\treturn 0\n\t\n\t# Now the files rebuilding part\n\tgenerate_files(root, files, ver, gbls, redirects, filespecs)\n\t\n\t# Save the string for the next iteration, writing was successful\n\twith open(os.path.join(root, \"src\", \"wrapped32\", \"generated\", \"functions_list.txt\"), 'w') as file:\n\t\tfile.write(functions_list)\n\t\n\treturn 0\n\nif __name__ == '__main__':\n\tlimit = []\n\tfor i, v in enumerate(sys.argv):\n\t\tif v == \"--\":\n\t\t\tlimit.append(i)\n\tDefine.defines = list(map(DefineType, sys.argv[2:limit[0]]))\n\tif main(sys.argv[1], sys.argv[limit[0]+1:], \"0.0.2.2\") != 0:\n\t\texit(2)\n\texit(0)\n"
        },
        {
          "name": "runTest.cmake",
          "type": "blob",
          "size": 2.1806640625,
          "content": "# arguments checking\nif( NOT TEST_PROGRAM )\n  message( FATAL_ERROR \"Require TEST_PROGRAM to be defined\" )\nendif( NOT TEST_PROGRAM )\nif( NOT TEST_ARGS )\n  message( FATAL_ERROR \"Require TEST_ARGS to be defined\" )\nendif( NOT TEST_ARGS )\nif( NOT TEST_OUTPUT )\n  message( FATAL_ERROR \"Require TEST_OUTPUT to be defined\" )\nendif( NOT TEST_OUTPUT )\nif( NOT TEST_REFERENCE )\n  message( FATAL_ERROR \"Require TEST_REFERENCE to be defined\" )\nendif( NOT TEST_REFERENCE )\nif(NOT DEFINED ENV{INTERPRETER})\n    set(ENV{INTERPRETER} \"\")\nendif()\n\nset(ENV{BOX64_LOG} 0)\nset(ENV{BOX64_NOBANNER} 1)\nif( EXISTS ${CMAKE_SOURCE_DIR}/x64lib )\n  # we are inside box64 folder\n  set(ENV{BOX64_LD_LIBRARY_PATH} ${CMAKE_SOURCE_DIR}/x64lib)\nelse()\n  # we are inside build folder\n  set(ENV{BOX64_LD_LIBRARY_PATH} ${CMAKE_SOURCE_DIR}/../x64lib)\nendif( EXISTS ${CMAKE_SOURCE_DIR}/x64lib )\n\n# run the test program, capture the stdout/stderr and the result var\nexecute_process(\n  COMMAND $ENV{INTERPRETER} ${TEST_PROGRAM} ${TEST_ARGS} ${TEST_ARGS2}\n  OUTPUT_FILE ${TEST_OUTPUT}\n  ERROR_VARIABLE TEST_ERROR\n  RESULT_VARIABLE TEST_RESULT\n  )\n\n# if the return value is !=0 bail out\nif( TEST_RESULT )\n  get_filename_component(TESTNAME \"${TEST_ARGS}\" NAME)\n  file(RENAME \"${TEST_OUTPUT}\" \"${CMAKE_BINARY_DIR}/${TESTNAME}.out\")\n  file(WRITE  \"${CMAKE_BINARY_DIR}/${TESTNAME}.err\" ${TEST_ERROR})\n  message( FATAL_ERROR \"Failed: Test program ${TEST_PROGRAM} exited != 0.\\n${TEST_ERROR}\" )\nendif( TEST_RESULT )\n\n# now compare the output with the reference\nexecute_process(\n  COMMAND ${CMAKE_COMMAND} -E compare_files ${TEST_OUTPUT} ${TEST_REFERENCE}\n  RESULT_VARIABLE TEST_RESULT\n  )\n\n# again, if return value is !=0 scream and shout\nif( TEST_RESULT )\n  get_filename_component(TESTNAME \"${TEST_ARGS}\" NAME)\n  file(RENAME \"${TEST_OUTPUT}\" \"${CMAKE_BINARY_DIR}/${TESTNAME}.out\")\n  file(WRITE  \"${CMAKE_BINARY_DIR}/${TESTNAME}.err\" ${TEST_ERROR})\n  message( FATAL_ERROR \"Failed: The output of ${TEST_PROGRAM} did not match ${TEST_REFERENCE}\")\nendif( TEST_RESULT )\n\n# remove the temporary files if they exist\nif( EXISTS ${TEST_OUTPUT} )\n  file(REMOVE \"${TEST_OUTPUT}\")\nendif()\n\n# everything went fine...\nmessage( \"Passed: The output of ${TEST_PROGRAM} matches ${TEST_REFERENCE}\" )\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "system",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests32",
          "type": "tree",
          "content": null
        },
        {
          "name": "wrapperhelper",
          "type": "tree",
          "content": null
        },
        {
          "name": "x64android",
          "type": "tree",
          "content": null
        },
        {
          "name": "x64lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "x86android",
          "type": "tree",
          "content": null
        },
        {
          "name": "x86lib",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}