{
  "metadata": {
    "timestamp": 1736709732456,
    "page": 135,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "umlaeute/v4l2loopback",
      "stars": 3771,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2236328125,
          "content": "root = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\n[*.[ch]]\nindent_style = tab\nindent_size = 8\ntrim_trailing_whitespace = true\n[*.sym]\nindent_style = tab\nindent_size = 4\ntrim_trailing_whitespace = true\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.05078125,
          "content": ".git*      \texport-ignore\n.travis.yml\texport-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2021484375,
          "content": "*~\n.tmp_versions/\n*.cmd\n*.yuv\nModule.symvers\nmodules.order\nutils/v4l2loopback-ctl.o\nutils/v4l2loopback-ctl\nv4l2loopback.ko\nv4l2loopback.mod\nv4l2loopback.mod.c\nv4l2loopback.mod.o\nv4l2loopback.o\n.clang-format\n"
        },
        {
          "name": ".gitversion",
          "type": "blob",
          "size": 0.1904296875,
          "content": "this file is a dummy marker to notify the build-process\nthat we are building from a development version of v4l2loopback.\n(that is: directly from a git-clone, rather than from a released tarball)\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 1.7041015625,
          "content": "Aidan Thornton <makosoft AT gmail DOT com>\nAlex Hu <alex_y_xu AT yahoo DOT ca>\nAlienmaster <github AT crpykng DOT de>\nAnatolij Gutschin <agust AT denx DOT de>\nAndrii Danyleiko <DefteZ @ github>\nAngus McInnes <angus AT amcinnes DOT info>\nAnton Novikov <random.plant AT gmail DOT com>\nAttila Tőkés <tokes_atti AT yahoo DOT com>\nBenny Baumann <BenBE AT geshi DOT org>\nDmitry Eremin <dmitry.eremin AT intel DOT com>\nGavin Qiu <yongchengq AT gmail DOT com>\nGeorge Chriss <gschriss AT gmail DOT com>\nGorinich Zmey\nIOhannes m zmoelnig <zmoelnig AT iem DOT at>\nJan-Ralf Meier <jan-ralf.meier AT gmx DOT de>\nJavier Infante <jabiinfante AT gmail DOT com>\nJon Morley <jmorley AT pixsystem DOT com>\nJoan Bruguera <joanbrugueram AT gmail DOT com>\nKai Kang <kai.kang AT windriver DOT com>\nKurt Kiefer <kekiefer AT gmail DOT com>\nMichel Promonet <michel.promonet AT free DOT fr>\nNick Sarnie <commendsarnex AT gmail DOT com>\nOleksandr Natalenko <oleksandr AT natalenko DOT name>\nPaul Brook <paul.brook AT cocoon DOT life>\nRicardo Ribalda Delgado <ricardo AT ribalda DOT com>\nScott Maines <smaines AT alaya DOT com>\nStefan Diewald <stefan.diewald AT mytum DOT de>\nTasos Sahanidis <tasos AT tasossah DOT com>\nTed Mielczarek <ted AT mielczarek DOT org>\nTheodore Cipicchio <okready AT github>\nThomas Hutterer <thutterer AT suse DOT de>\nTim Gardner <tim.gardner AT canonical DOT com>\nTobias Stoeckmann <tobias AT stoeckmann DOT org>\nTodor Minchev <todor.minchev AT linux DOT intel DOT com>\ntongdaxu <matonglidewazi AT qq DOT com>\ntz\nVasily Levin\nWaleedTageldeen <waleed.tageldeen AT gmail DOT com>\nWren Turkal <wt AT penguintechs DOT org>\nwuweixin <wuweixin AT gmail DOT com>\nYou-Sheng Yang <vicamo.yang AT canonical DOT com>\nYusuke Ohshima <git AT yukke DOT org>\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 38.783203125,
          "content": "v4l2loopback (0.13.2) unstable; urgency=medium\n\n  * Fix compilation on 32bit architectures (i386, armhf,...)\n    * Replace (s64 % u32) with our own v4l2l_mod64() wrapper\n    * Fix mod64 warnings on arm\n  * utils buildsystem\n    + Don't fail 'clean' target if 'make -C utils clean' fails\n    + clean objectfiles\n  * v4l2loopback-ctl\n    + mention the special caps 'any' in help\n    + improve error-reporting and return errcodes where appropriate\n    + avoid unused variable warning\n    + explicitly return the fd from open_controldevice()\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Fri, 24 May 2024 11:30:51 +0200\n\nv4l2loopback (0.13.1) unstable; urgency=medium\n\n  [ Max Harmathy ]\n  * Avoid building utils with dkms\n\n  [ IOhannes m zmölnig ]\n  * 'release.sh' script\n    + shellchecked\n    + write back new version to v4l2loopback.h (if necessary)\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Tue, 19 Mar 2024 22:15:34 +0100\n\nv4l2loopback (0.13.0) unstable; urgency=medium\n\n  [ IOhannes m zmölnig ]\n  * Set device_caps in init_vdev() for all kernel-versions (not just >4.7.0)\n  * Don't set the V4L2_CAP_DEVICE_CAPS on device_caps\n  * only set (struct video_device).device_caps on linux>=4.7.0\n  * pre-processor directives should be left-aligned\n  * tabify\n  * Drop obsolete ISSUE_TEMPLATE\n  * Mention that people should do research before creating a new ticket\n  * document that we expect people to do some research before creating a ticket\n  * document that people must have a proper bulid-environment\n\n  [ mpromonet ]\n  * reset ready_for_capture flag processing VIDIOC_STREAMOFF\n\n  [ IOhannes m zmölnig ]\n  * redirect people for StackOverflow for general help.\n  * rule to get the latest&greatest .clang-format for the linux-kernel\n  * clang-format -i *.c *.h\n  * fixed whitespace in comments and strings\n  * use $() rather than ``\n  * use more frames for setting caps.\n  * document that GStreamer-1.0 is required (rather than GStreamer-0.10)\n  * rename _SIZE_MAX_WIDTH to _SIZE_DEFAULT_MAX_WIDTH (same for HEIGHT)\n  * Add clang-format target\n  * comment formatting\n  * switched v4l2_loopback_init() for a more complete v4l2_loopback_add()\n  * per-device max_width/max_height\n  * store card-label per device\n  * copy newly created video-device back\n  * indentation\n  * use per-device name rather than the global ones\n  * switching free_devices() to idr-iterator\n  * getting rid of static number of devices...\n  * limit card_label to 32 chars (like v4l2_capability->card)\n  * make sure to neither exceed size of cap->card nor dev->card_label\n  * prevent out-of-bounds access to exclusive_caps[]\n  * less ambiguous wording when MAX_DEVICES is exceeded\n  * allow device_nr > MAX_DEVICES\n  * less verbose output\n  * use video_nr for initial devices\n  * macro for the default value of EXLCUSIVE_CAPS\n  * reordered card_label calculation\n  * fill default-values\n  * return the used device number\n  * move v4l2_loopback_config to a separate header\n  * move IDR declaration to a better place.\n  * drop devptr from v4l2_loopback_add\n  * use \"int\" instead of \"bool\" for the public interface\n  * now that exclusive_caps are int and can be negative, use that to ask for the default\n  * use \"err\" instead of \"ret\"\n  * implement /dev/v4l2loopback to dynamically create/remove devices\n  * use a mutex to prevent concurrent access to the /dev/v4l2loopback device\n  * check whether the device is currently open before closing it\n  * v4l2_loopback_config.card_label now has a fixed size (32 bytes)\n  * only return the device-number if device_add was successfull\n  * added QUERY ioctl\n  * sample application to add/delete/query devices on the fly\n  * indentation\n  * moved DEFINE_IDR/MUTEX *again*\n  * \"every\" -> \"each\"\n  * show default values in \"modinfo\"\n  * Makefile for utils/\n  * don't assume that IDR matches the device-number\n  * less verbose\n  * print perror() if query fails\n  * explicitely return ENOSYS for invalid ioctls\n  * use \"break\" instead of \"goto\"\n  * return EINVAL by default for valid ioctls\n  * copy data from userspace instead of casting away\n  * note that we need two device numbers\n  * Add example udev rules.\n    Thanks to Norman Rasmussen <norman@rasmussen.co.za>\n  * formatting\n  * perror() if query-after-add fails\n  * only set device is the pointer is valid\n  * (struct v4l2_loopback_config) now has both output_nr and capture_nr\n  * adjust utility to (currently defunct) split CAPTURE/OUTPUT devices\n  * document how to call /dev/v4l2loopback ioctls\n  * gitignore .clang-format\n  * don't export repo-configuration\n  * mention that v4l2_loopback_config.announce_all_caps is to be going away\n  * more specific rule for creating persistent names\n  * rule to allow members of 'video' to change device-properties via sysfs\n  * restructed usage() a bit\n  * implement \"set-fps\"\n  * also format code in utils/\n  * moved v4l2loopback version to header file\n  * capitalize command enums\n  * added \"-h\" and \"-v\" commands\n  * SETFPS -> SET_FPS\n  * dropped unused \"fd\" from set_fps call\n\n  [ You-Sheng Yang ]\n  * utils: respect CPPFLAGS from env vars\n\n  [ Sakari Tanskanen ]\n  * Allow reading buffered frames\n\n  [ You-Sheng Yang ]\n  * dev: initialize per opener v4l2_fh\n  * event: install event (un)subscribe hook\n  * event: support polling for events\n\n  [ IOhannes m zmölnig ]\n  * control more thingies\n  * whitespace\n  * Add documentation about using dkms.\n    Thanks to Toon Verstraelen\n\n  [ Toon Verstraelen ]\n  * Document how to load the module at boot\n\n  [ IOhannes m zmölnig ]\n  * lower-case readme\n  * Usde \"If\" rather than \"When\"\n\n  [ IOhannes m zmoelnig ]\n  * note that you cannot just load an old module into a new kernel (even if you built the module yourself).\n\n  [ ilsi ]\n  * Fix DKMS typos in README\n\n  [ IOhannes m zmölnig ]\n  * use a helper for showing short descriptions of commands\n  * announce 'set-caps' and 'set-timeout-image'\n  * re-formatted\n  * allow some commands without a /dev/v4l2loopback device\n  * \"not implemented\" is not the same as \"unknown command\"\n  * announce the not-yet-implemented \"get-fps\" and \"get-caps\" commands\n  * make commands static when possible\n  * helper-function to get sysfs files\n  * specify mode when opening a sysfs-file\n  * close fd on error\n  * implement get_fps\n  * basic get_caps implementation\n  * store fourcc as uint32_t\n  * fixed help-display\n  * rename get_<file> to open_<file>\n  * properly display FOURCC when printing caps\n  * re-factored caps-parsing into separate function\n  * implement set_caps\n  * less verbose\n  * query default values before setting those we want to\n  * clang-format\n  * reverse arguments for set-* commands\n  * draft implementation of set-timeout-image\n  * proper ordering of arguments in help\n  * remove printout\n  * search for executable in PATH\n  * comments\n  * clang-format\n  * v4l2loopback-ctl: support for adding split-devices\n  * fixed spelling errors\n  * v4l2loopback_private.devicenr -> .device_nr\n  * remove debugging output\n  * function to check for deprecated calls\n  * wrap launching of external programs into separate function\n  * TERM the child-process on receiving SIGINT; wait for child-process to cleanup\n  * move helpers to top of file\n  * TODO: we want to be able to set the timeout directly\n  * helpers for getting/setting controls by name\n  * have \"set-timeout-image\" set the 'timeout' and 'timeout_image_io' controls\n  * allow setting of the timeout (TODO: parse args for timeout)\n  * fix(?) GStreamer-pipeline for setting the timeout image\n  * added 'default' clause to switch-statement\n  * clang-format\n  * build utils from master-makefile\n  * factored device-opening into helper-function\n  * handle \"any\" caps and set \"keep_format\" and \"sustain_framerate\"\n  * resolve timeout-image to full path (and allow 4096 chars in paths)\n  * track how many producers have opened the device\n  * reformatting\n  * close video-device before trying to set timeout-image\n\n  [ You-Sheng Yang ]\n  * event: fix backward compatibility to 3.16\n  * add GitHub Actions yaml\n  * utils: use VIDIOC_QUERYCTRL for control name resolution\n  * utils: fix error: 'for' loop initial declarations are only allowed in C99 mode\n\n  [ IOhannes m zmölnig ]\n  * improve parse-device to deal with /dev/v4l/by-*/* symlinks\n  * keep alignment when running clang-format\n  * moved fallback defines for V4L2_PIX_FMT_* to v4l2loopback_formats.h\n  * modular help\n  * set-timeout-image subcommand now takes a \"-t <timeout>\" flag\n  * less verbose\n  * optional argument-check for called_deprecated()\n  * check framerate-argument for \"set_fps\"\n  * return success of subcommands\n  * catch empty /sysfs/.../format (but don't complain loudly)\n  * simplified caps-parsing\n  * get-fps now falls back to querying the video-device's PARMs\n  * use C-style comments for documentation\n  * print error when GStreamer-style caps are detected\n  * renamed \"utils/v4l2loopback\" to \"utils/v4l2loopback-ctl\"\n  * replaced placeholder file with .gitignore\n  * fixed help2man invocation\n  * clean-target for utils\n  * call utils' \"clean\" target when running \"make clean\"\n  * use /dev/video0 throughough\n  * update to new v4l2loopback-ctl syntax\n  * Fixed upper-casing to standard English\n  * note on changing module options\n  * note on dynamic device management\n  * make \"changing options\" a sub-item in the \"options\" chapter\n  * grouping into chapters\n  * more upper-casing\n\n  [ You-Sheng Yang ]\n  * ci: match known failures to kernel versions\n\n  [ IOhannes m zmölnig ]\n  * comment fixes\n  * ctrl_handler_init/setup\n  * note on why try_free_buffers() doesn't do harm if keep_format is true\n  * dropped double \"sudo\"\n\n  [ You-Sheng Yang ]\n  * gitignore: add utils/v4l2loopback-ctl and v4l2loopback.mod\n\n  [ IOhannes m zmölnig ]\n  * automatically assign new-bugreports a default label/assignee\n  * disable blank issues and redirect people to U&L resp the wiki\n  * stackoverflow -> unix.stackexchange\n  * also mention stackoverflow\n  * use an imperative rather than a noun as the bug-report name.\n  * pass number of args to help-functions\n  * print known fourcc flags when calling 'set-caps' without arguments\n  * clang-format\n  * editorconfig\n\n  [ Luigi Baldoni ]\n  * Include header outside of struct definition\n\n  [ Oleksandr Natalenko ]\n  * confine v4l2loopback_cleanup_module\n\n  [ IOhannes m zmölnig ]\n  * fixed building of v4l2loopback-ctl in the aftermath of #389\n  * doc on how to develop with vagrant\n  * slight re-ordering of struct-init\n  * use module_init()/module_exit() rather than '#ifdef MODULE'\n  * note on what to do if the VM freezes\n  * drop MODULE_ALIAS(\"devname\")\n  * add args to vbox-restart\n  * [ci] don't bail out on the first kernel that unexpectedly fails\n  * [ci] if a build failed, accept that 'make clean' might fail as well...\n  * [ci] mark all trusty kernels as known-bad\n\n  [ Piotr Orzechowski ]\n  * Fix the dkms install instructions in README.md\n\n  [ IOhannes m zmölnig ]\n  * [ci] renamed 'master' branch to 'main'\n  * embrace Kbuild\n  * fixed typo\n  * use KBUILD_MODULES to detect Kbuild\n  * [gh] fixes errors in the issue template\n  * bumped copyright-dates in README\n  * mention \"SSL\" in the troubleshooting section\n  * fixed typos\n  * more english style fixes\n  * Fix scanf/printf formatting\n\n  [ Tadayuki Okada ]\n  * try to set requested colorspace\n\n  [ You-Sheng Yang ]\n  * coverity: fix unchecked return value\n  * coverity: fix null pointer dereference\n\n  [ IOhannes m zmölnig ]\n  * don't fail if allocating 0-sized buffers\n\n  [ a1346054 ]\n  * use apt-get instead of aptitude\n  * master branch was renamed to main\n  * fix shellcheck warnings\n  * unify codestyle\n  * fix spelling\n  * add missing final newline\n  * trim excess whitespace\n  * trim trailing whitespace\n\n  [ Emil Velikov ]\n  * dkms.conf: remove REMAKE_INITRD option\n\n  [ bakedpotato191 ]\n  * Add module_version macro\n\n  [ Bechir Mghirbi ]\n  * Adding support for RGBA32 (AB24)\n\n  [ Jim Scarborough ]\n  * Fix currentversion.sh to return the value\n\n  [ IOhannes m zmölnig ]\n  * made \"currentversion.sh\" script POSIX conformant\n  * [ci] drop 'groovy'; add 'hirsuite' and 'impish'\n  * [ci] dynamically generate Debian/Ubuntu releases to test\n  * on Debian kernel-header packages have a different suffix...\n  * guard V4L2_PIX_FMT_RGBA32 definition...\n  * [ci] better check for installed kernel headers\n  * clang format\n  * [ci] show successfull builds\n\n  [ Anatoli Babenia ]\n  * README.md Add info how to check the device number\n\n  [ IOhannes m zmölnig ]\n  * inject snapshot-version in banner\n\n  [ Benny Baumann ]\n  * Limit v4l2_loopback_write calls to (streaming) writers\n  * Simplify code by using upstream video_drvdata helper\n  * Free module data on error\n  * Initialize max_width/max_height relative to defaults\n  * Off-by-one condition when retrieving defaults\n\n  [ IOhannes m zmölnig ]\n  * Make sure that only the boolean state of announce_all_caps is used.\n\n  [ He1nMueck ]\n  * Make free_buffers() return void.\n\n  [ Benny Baumann ]\n  * Reintroduce previous behavior for write call\n\n  [ Jan-Ralf Meier ]\n  * Check for negative index before proceeding\n\n  [ Benny Baumann ]\n  * Free module data on error\n\n  [ Robert Geislinger ]\n  * fixed possible bufferoverflow\n\n  [ Alienmaster ]\n  * simplify bufferoverflow checks\n\n  [ IOhannes m zmölnig ]\n  * indentation\n\n  [ Alienmaster ]\n  * added explicit cleanup on error\n\n  [ IOhannes m zmölnig ]\n  * removed superfluous check\n  * only allocate_buffers() if buffer_size>0\n\n  [ Benny Baumann ]\n  * Release memory on error in v4l2_loopback_open\n  * Only reset timeout_image_io when open succeeds\n  * Avoid redundant/conflicting casts\n\n  [ Tobias Stoeckmann ]\n  * attr_store_maxopener: Handle integer truncation\n\n  [ Benny Baumann ]\n  * Properly snprintf the device card label string into the capability query buffer\n  * Avoid format string issue\n\n  [ umläute ]\n  * Create SECURITY.md\n\n  [ IOhannes m zmölnig ]\n  * add explicit format specifier to printf() invocations\n\n  [ Sludge ]\n  * Support `V4L2_PIX_FMT_ABGR32` format\n\n  [ Tobias Stoeckmann ]\n  * Fix warning with gcc 12\n\n  [ Jan-Ralf Meier ]\n  * Fix return condition, due to EINVAL memory offset.\n\n  [ IOhannes m zmölnig ]\n  * Update release-script to work with any branch\n  * Exclude repository config in source-tarballs\n  * Backported dkms-patch from Ubuntu\n\n  [ Oleksandr Natalenko ]\n  * v4l2loopback: un-confine v4l2loopback_cleanup_module()\n\n  [ IOhannes m zmölnig ]\n  * quote FOURCC-codes to show the space\n\n  [ Jianhui Dai ]\n  * Reset V4L2_BUF_FLAG_MAPPED if use_count <= 0\n  * log pid for debug\n\n  [ tudor ]\n  * DKMS section clarification\n  * too many empty lines\n\n  [ You-Sheng Yang ]\n  * Track active readers\n  * Support V4L2_EVENT_PRI_CLIENT_USAGE\n\n  [ Tobias Stoeckmann ]\n  * Fix signed integer overflows in increments.\n\n  [ Kate Hsuan ]\n  * v4l2loopback: a new offset for V4L2_EVENT_PRI_CLIENT_USAGE\n\n  [ IOhannes m zmölnig ]\n  * Allow a minimum of 0 fps\n  * clang-format\n  * Propagate snapshot version to v4l2loopback-ctl\n  * strip leading 'v' from git snapshot version\n  * v4l2loopback-ctl: compat flag \"--version\"\n  * calculate MODULE_VERSION from V4L2LOOPBACK_VERSION\n  * use linux' __stringify\n  * re-ordered 'struct v4l2_loopback_config' so \"announce_all_caps\" comes last\n  * logging: move \"pid(%d)\" after the v4l2-loopback identifier\n  * [ci] use Environment-File rather than set-output\n  * Drop support for Linux<2.6.37\n  * v4l2loopback-ctl: print module version as well\n  * [ci] Job for code-linting\n  * [ci] Fixup lint-job\n  * Re-formatted code with updated .clang-format\n  * [ci] hardcode Debian's supported releases to their rolling names\n\n  [ sanbrother ]\n  * Fix compilation issues under AOSP\n\n  [ mzihlmann ]\n  * mutex lock access to outbufs_list in vidioc_dqbuf\n\n  [ Asahi Lina ]\n  * Revert \"Fix signed integer overflows in increments.\"\n  * Change the type of read_position and write_position to 64-bit\n\n  [ IOhannes m zmölnig ]\n  * Use separate spinlocks for protecting list access\n  * Make VIDIOC_ENUMINPUT return V4L2_IN_ST_NO_SIGNAL if there's no producer\n  * code formatting\n  * Always protect access to dev->outbufs_list with the list_lock mutex\n  * v4l2loopback-ctl help: use 'detail' level rather than 'brief' flag\n  * help: reverse general form and example\n  * codespell fixes\n  * fix typo\n  * add 'install' target for utils\n  * clang-format\n  * more gitignores\n  * Bump copyright dates\n  * simple test application for producing/consuming buffers\n  * more debugging and a global buffer\n  * set bufsize/bytesused when initializing buffers for MMAP\n  * fix random; optionally set timestamp\n  * try more...\n  * stuff...\n  * use DEFAULT colorspace\n  * set V4L2_BUF_FLAG_TIMESTAMP_COPY flag when copying the buffer timestamp\n  * more diagnostic output\n  * refactor the TRY/S_FMT code\n  * fix formatting warnings when printing timestamps\n  * compat for older kernels\n  * more clang-format\n  * reversed compat logic\n  * yikes, yet another typo\n  * tests/consumer: make S_FMT errors non-fatal\n  * prevent multiple output streams\n  * set TIMESTAMP flags\n  * G_FMT_CAP: only report failure if the format has not been fixated\n  * script to check the output/capture formats of a device\n  * V4L2LOOBACK_IS_FIXED_FMT() to check if the format is changeable\n  * unify the output of vidioc_enum_fmt_*\n  * set default framesize\n  * allow setting of minimum width/height as well\n  * v4l2loopback-ctl: allow setting of minimum framesize\n  * clang-format\n  * tests/producer: fix description of \"-c\" flag and linefeed\n  * long-options for v4l2loopback-ctl\n  * indentation\n  * unset the timeout_image_io flag if allocating the timeout-image fails\n  * only unset the timeout_image_io flag when requesting buffers for the timeout image\n  * turn the \"timeout_image_io\" ctrl into a button\n  * whitespace\n  * fixate format with \"keep_format\"\n  * report format via /sys if it is somehow FIXED\n  * run timeout-image gst-pipeline through \"tee\"\n  * add \"--verbose\" flag to \"set-timeout-image\"\n  * prevent multiple readers to start streaming\n  * indentation...\n  * add /sys/devices/virtual/video4linux/video*/type interface\n  * fix device_nr checks in V4L2LOOPBACK_CTL_QUERY\n  * v4l2loopback-ctl: add \"list\" verb\n  * v4l2loopback-ctl: escape special chars in device-names\n  * refactored raw-string printout into helper function\n  * v4l2loopback-ctl: align help\n  * v4l2loopback-ctl: more escaping for device-name\n  * v4l2loopback-ctl: add flags to \"query\" verb\n  * v4l2loopback-ctl: streamline help\n\n  [ Hans de Goede ]\n  * v4l2loopback: Fixup bytesused field when writer sends a too large value\n\n  [ IOhannes m zmölnig ]\n  * fallback to dprintkrw() if dev_warn_ratelimited() is not available\n  * rename sysfs-attribute \"type\" to \"state\"\n  * make the code less-dependant on the \"capture_nr\" member of the config-struct\n  * swap output/capture device when adding new devices\n  * Remove the 'capture_nr' member from the v4l2_looback_config struct\n  * build-fixes: install and utils\n  * force timestamp.tv_sec to (long long int)\n\n  [ Wren Turkal ]\n  * Remove support for pre-3.6.1 Linux kernels.\n  * Remove support for pre-4.0.0 kernels.\n\n  [ IOhannes m zmölnig ]\n  * [github] Mention \"discussions\" in the issue landing-page\n\n  [ rdbo ]\n  * fixed utils build for musl (missing GLOB_ONLYDIR)\n\n  [ IOhannes m zmölnig ]\n  * note that GLOB_ONLYDIR is indeed not requried by POSIX\n\n  [ rdbo ]\n  * added v4l2loopback-ctl.o to gitignore\n\n  [ IOhannes m zmölnig ]\n  * Fix formatting\n\n  [ Fufu Fang ]\n  * Update README.md\n\n  [ IOhannes m zmölnig ]\n  * [ci] skip failures on kernels without v4l2 support\n  * [ci] install all available kernel headers\n  * [ci] show skipped builds\n  * [ci] Fix testing for v4l2 capabilities\n  * [ci] bump actions/checkout to v4\n  * [ci] lower actions/checkout to v3\n  * [ci] only install latest packageversion of each kernel-flavour\n  * [ci] install 'dkms' to get some more building prerequisites\n  * some minor typos\n  * use 'sudo' to change the permissions of the module\n  * use $< instead of hardcoding the module name\n  * 'sign' target to sign the generated module for use with secure boot\n\n  [ Joaquim Monteiro ]\n  * Use strscpy instead of strlcpy if available\n\n  [ IOhannes m zmölnig ]\n  * redefine strscpy() as strlcpy() if needed\n  * Lower minimum width/height to extreme values\n  * allocate_buffers: fix check whether we can re-allocate\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Tue, 19 Mar 2024 17:11:08 +0100\n\nv4l2loopback (0.12.7) unstable; urgency=medium\n\n  [ IOhannes m zmölnig ]\n  * Add explicit format specifier to printf() invocations\n\n  [ Andreas Beckmann ]\n  * REMAKE_INITRD is deprecated in dkms 3\n  * Do not attempt to build modules for kernels without CONFIG_VIDEO_V4L2\n\n  [ Dimitri John Ledkov ]\n  * Fixup obsolete module init/exit\n\n  [ You-Sheng Yang ]\n  * dev: initialize per opener v4l2_fh\n  * event: install event (un)subscribe hook\n  * compliance: fix enum frame sizes/intervals errors\n  * compliance: fix \"fmtdesc.type was modified\" error\n  * UBUNTU: SAUCE: coverity: fix null pointer dereference\n\n  [ Tim Gardner ]\n  * Fix unchecked return value in vidioc_s_fmt_out()\n  * Fix resource leak in v4l2_loopback_open()\n  * Fix NULL dereference in free_buffers()\n\n  [ Erich Eickmeyer ]\n  * Don't fail if allocating 0-sized buffers\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Wed, 05 Aug 2022 00:24:03 +0200\n\nv4l2loopback (0.12.6) unstable; urgency=medium\n\n  * Add explicit format specifier to printf() invocations\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Sun, 03 Aug 2020 13:15:02 +0200\n\nv4l2loopback (0.12.5) unstable; urgency=medium\n\n  [ Joan Bruguera ]\n  * Fix build in Linux 5.7-rc1 due to symbol name changes\n\n  [ IOhannes m zmölnig ]\n  * Simplify set/clear of V4L2_CAP_DEVICE_CAPS in querycaps\n  * Use temp-var for capabilities\n  * Also set vdev->device_caps\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Sun, 19 Apr 2020 19:06:09 +0200\n\nv4l2loopback (0.12.4) unstable; urgency=medium\n\n  [ Alex Xu (Hello71) ]\n  * Use v4l2_buffer ptr instead of timeval (Compat with linux-5.6)\n\n  [ tongdaxu ]\n  * Add example that loops over YUV frames infinitely\n\n  [ Thomas Hutterer ]\n  * Document 'exclusive_caps' mode option (and some markdown fixes)\n\n  [ IOhannes m zmölnig ]\n  * Set the default number of buffers to 2\n  * Print \"SUCCESS\" message on installation success\n  * Drop cast to (time_t)\n  * Document 'exclusive_caps' mode option (and some more markdown fixes)\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Thu, 09 Apr 2020 22:09:28 +0200\n\nv4l2loopback (0.12.3) unstable; urgency=medium\n\n  [ Ricardo Ribalda Delgado ]\n  * v4l2lookback: Port to kernel 5.4+\n\n  [ IOhannes m zmölnig ]\n  * Set video_device->device_caps for linux>4.7.0\n  * Set some more device_caps\n  * Update issue templates\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Fri, 06 Dec 2019 18:27:25 +0100\n\nv4l2loopback (0.12.2) unstable; urgency=medium\n\n  [ wuweixin ]\n  * Update README.md\n\n  [ Theodore Cipicchio ]\n  * Replace v4l2_get_timestamp with ktime_get_ts(64)\n\n  [ IOhannes m zmölnig ]\n  * Mention support for 5.0.0\n  * Fix typo\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Mon, 27 May 2019 20:32:08 +0200\n\nv4l2loopback (0.12.1) unstable; urgency=medium\n\n  [ IOhannes m zmölnig ]\n  * Fix permission of source code files\n  * Initialize variables\n  * Use %u to print size_t\n  * Improve coding style by removing unused variables\n  * More coding style fixes\n  * Use GStreamer-1.0 caps in the documentation\n  * Gst1.0 compat for example-script\n  * Protect VP9 and HEVC by #ifdef guards\n\n  [ Andrii Danyleiko ]\n  * Fix typo\n\n  [ Kai Kang ]\n  * Replace do_gettimeofday with v4l2_get_timestamp for linux-5 compat\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Wed, 23 Jan 2019 21:59:29 +0100\n\nv4l2loopback (0.12.0) unstable; urgency=medium\n\n  [ WaleedTageldeen ]\n  * Adding support for NV12 as per umlaeute/v4l2loopback#169\n\n  [ Jon Morley ]\n  * v4l2loopback.c: Update error message in buf read to reflect actual copy call.\n\n  [ IOhannes m zmölnig ]\n  * Use kernel-version to determine whether we should set vfl_dir\n  * sign releases and add a message\n  * Support for 8bit bayer\n  * moved bayer-formats into \"packed formats\" section\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Mon, 02 Jul 2018 12:27:29 +0200\n\nv4l2loopback (0.11.0) unstable; urgency=medium\n\n  [ Nick Sarnie ]\n  * Adapted to new kernel timer API\n\n  [ Attila Tőkés ]\n  * Avoid setting dev->ready_for_output and opener->type on get/try calls\n  * Allow input enumeration, even when exclusive_caps=1 and no input provided yet\n\n  [ Todor Minchev ]\n  * Makefile: remove depmod call in modules_install target\n\n  [ Michel Promonet ]\n  * Added format VP9 & HEVC\n\n  [ IOhannes m zmölnig ]\n  * Simplified HAVE_TIMER_SETUP clauses\n  * Fixed format output to sysfs\n  * Removed trailing whitespace\n  * Updated README\n    * Added `depmod -a` calls to the documentation\n    * Fixed omitted word\n  * [github] Added issue template for new reports\n    * please don't post images in the issue-tracker\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Tue, 06 Mar 2018 10:05:11 +0100\n\nv4l2loopback (0.10.0) unstable; urgency=medium\n\n  [ Paul Brook ]\n  * Use consistent device names\n\n  [ Michel Promonet ]\n  * Initialize bytesused in buffer processing write and use it processing read\n\n  [ Kurt Kiefer ]\n  * Initialize bytesused also on output VIDIOC_QBUF.\n  * Preserve output VIDIOC_QBUF timestamp if present\n\n  [ IOhannes m zmölnig ]\n  * switch ctl-script to GStreamer-1.0\n  * move braces into #ifdef block\n  * use late_initcall() when not built as module\n  * Disable exclusive_caps by *default*\n  * Removed deprecated current_norm\n\n  [ George Chriss ]\n  * Directly set v4l2 buffer flags as v4l2 documentation (note difference vs. internal v4l2l buffers) Hopefully closes: https://github.com/umlaeute/v4l2loopback/issues/60\n  * Build typo: change b->flags to buf->flags\n\n  [ Gavin.Qiu ]\n  * Fix bug that return wrong buffer index when dequeue\n\n  [ IOhannes m zmölnig ]\n  * Added more AUTHORS\n  * Updated README (compat, copyright and cosmetics)\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Fri, 02 Dec 2016 22:00:27 +0100\n\nv4l2loopback (0.9.1) unstable; urgency=medium\n\n  * Fixed module version\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Wed, 03 Jun 2015 19:47:23 +0200\n\nv4l2loopback (0.9.0) unstable; urgency=medium\n\n  [ IOhannes m zmölnig ]\n  * formats\n    * support more formats\n    * support compressed formats\n    * move formats-enumeration to separate file\n    * tools to implement missing formats\n  * controls\n    * disable deprecated vidioc_*ctrl callbacks\n    * register custom-controls\n    * use ctrl_config information in (deprecated) queryctrl\n  * fixed bugs\n    * used static code analysis to find more bugs\n    * more error checking\n    * check timeperframe before setting it (Closes: #61)\n    * make MAX_DEVICES/TIMEOUT/BUFFERS settable during build-process (Closes: #55)\n    * check for errors returned by get_capture_buffer()\n    * check whether there is at least 1 requestbuffer\n    * unsigned comparision against <0\n    * avoid setting b->count to negative/null\n    * ...\n  * fixed typos\n  * code formatting\n  * standards compliancy\n    * standard-conformant bus_info\n    * pretend to not support {G,S,ENUM}_{IN,OUT}PUT depending on state\n    * only pretend to not support IN/OUTPUT enumeration in exclusive-caps mode\n  * test programs\n    * for (de)queuing buffers\n    * for writing interlaced video\n  * compatibility with newer kernels\n  * compatibility with older kernels\n  * Updated documentation\n  * Removed GFDL document\n    * note where to get API documentation\n\n  [ tatokis ]\n  * Updated v4l2loopback.c to compile on >= 3.18 kernel\n\n  [ tz ]\n  * add ondemandcam\n\n  [ Yusuke Ohshima ]\n  * Fix issue #79\n\n  [ Tasos Sahanidis ]\n  * Fix for kernel 4.0\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Tue, 02 Jun 2015 19:58:39 +0200\n\nv4l2loopback (0.8.0) unstable; urgency=medium\n\n  [ Dmitry Eremin ]\n  * Add DKMS support.\n\n  [ Angus McInnes ]\n  * Make vidioc_g_fmt_out not change the format\n  * Set correct output buffer type in vidioc_dqbuf\n\n  [ Javier Infante ]\n  * Added card_labels option when loading module.\n\n  [ IOhannes m zmölnig ]\n  * renamed 'card_labels' to 'card_label'\n  * removed '-e' flag from call to 'depmod' (needs '-E' or '-F')\n  * auto-detect new version\n  * auto-update dkms.conf to new version\n\n -- IOhannes m zmölnig <zmoelnig@iem.at>  Tue, 10 Dec 2013 18:12:15 +0100\n\nv4l2loopback (0.7.1) unstable; urgency=low\n\n  [ Aidan Thornton ]\n  * Linux 3.11 compatibility fix\n\n  [ IOhannes m zmölnig ]\n  * trying to keep pre-2.6.29 compatibility\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Mon, 16 Sep 2013 09:55:51 +0200\n\nv4l2loopback (0.7.0) unstable; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * don't implement STD-ioctls\n  * Revert \"dummy audio ioctl's that return EINVAL\"\n  * disable more STD-stuff based on V4L2LOOPBACK_WITH_STD\n  * don't announce all caps capabilities\n  * only announce capture/output capabilities if possible\n  * 'exclusive_caps' parameter to control caps announcment\n  * avoid duplicate setting of cardname\n  * break lines\n  * remove commented out code\n  * updated AUTHORS information\n  * fixed ChangeLog for 0.6.1\n  * updated NEWS for last releases\n\n  [ Anatolij Gustschin ]\n  * fix missing spin lock init\n  * add newlines to debug statements\n\n  [ Hans Verkuil ]\n  * reformatting to kernel-standards\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Fri, 07 Jun 2013 11:24:34 +0200\n\nv4l2loopback (0.6.3) unstable; urgency=low\n\n  [ Ted Mielczarek ]\n  * Fill in the \"v4l2_capability::bus_info\" field (Closes: #30)\n\n  [ IOhannes m zmölnig ]\n  * make \"v4l2_capability::card\" unique per device (Closes: #37)\n  * fill in \"video_device::vfl_dir\" field on newer kernels (Closes: #35)\n  * always provide format-string when using printf()\n  * fixing update-changelog script\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Tue, 05 Feb 2013 10:03:28 +0100\n\nv4l2loopback (0.6.2) unstable; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * provide our own v4l2l_vzalloc\n  * added missing includes\n  * create unique names for the various devices\n  * more verbose debugging output when capture DQBUF fails\n\n  [ Anton Novikov ]\n  * make v4l2loopback.ko a PHONY target\n  * restarting-writer.sh runs on Ubuntu 11.10\n  * warning about disabled timeout when setting image\n  * readpos2index -> bufpos2index\n  * test different queue-sizes in restarting-writer.sh\n  * fix buffer indices before dev->used_buffers update\n  * fix ctl script (was hardcoded /dev/video0)\n\n  [ yukkeorg ]\n  * Fix error on compile in Linux kernel 3.6.1.\n\n -- IOhannes m zmoelnig <zmoelnig@umlaeute.mur.at>  Tue, 23 Oct 2012 14:38:02 +0200\n\nv4l2loopback (0.6.1) UNRELEASED; urgency=low\n\n  [ IOhannes m zmoelnig ]\n  * Makefile fixes for debian\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Fri, 27 Apr 2012 17:22:25 +0200\n\nv4l2loopback (0.6.0) UNRELEASED; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * added direct link to wiki\n  * fixed typos\n  * check for (devices<0) rather than (devices==-1)\n\n  [ Anton Novikov ]\n  * add .gitignore files\n  * add 'format' sysfs attr\n  * remove 'fourcc' sysfs attr\n  * 'keep_format' ctrl\n  * set_timeperframe(), dev->frame_jiffies\n  * 'sustain_framerate' ctrl\n  * add examples/restarting-writer.sh\n  * reset write_position only when !ready_for_capture\n  * handle arbitrary output QBUF index order\n  * 'timeout' ctrl\n  * add ability to do i/o on placeholder picture buf\n  * add v4l2loopback-ctl script\n  * installing v4l2loopback-ctl\n  * fix dequeuing unused buffers\n  * timeout_image_io cleaner memory handling\n  * some documentation on controls\n  * some v4l2loopback-ctl syntax&doc tweaks\n\n  [ IOhannes m zmölnig ]\n  * moved utility into utils/\n  * Updated copyright notice\n  * use max image size to prevent insane allocations\n  * in-code documentation of the format string\n  * fixed description of 'debug' option\n  * fixed closing comment\n  * allow to set the max.framesize via module parameters\n  * renamed 'v4l2loopback' target to 'v4l2loopback.ko'\n  * added install-utils target\n\n  [ Anton Novikov ]\n  * script bugfix\n  * v4l2loopback-ctl set-fps\n  * more README\n\n  [ IOhannes m zmölnig ]\n  * initialize list in all cases\n  * notes on how to do kernel-debugging\n  * when dying, write to stderr\n  * check for applications before using them\n  * fix usage/version to make it fit for help2man\n  * manpage for v4l2loopback-ctl\n  * placeholder\n  * simplified description\n  * build and install manpages\n  * deleted manage (it's generated automatically)\n  * updated in-module AUTHORs\n  * debugging printout\n  * don't try to force a given format\n  * clarify README about default device in ./test\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Fri, 27 Apr 2012 09:29:52 +0200\n\nv4l2loopback (0.5.0) UNRELEASED; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * more (and better) debugging output\n  * stefan diewald's ENUM_FRAMESIZES fix\n  * simplifified framesize enumeration\n  * stefan diewald's ENUM_FRAMEINTERVAL implementations\n  * stefan diewald's buffer request logic\n  * added Stefan Diewald to the authors\n  * use sudo to rmmod/insmod kernel modules in Makefile\n  * use unlocked_ioctl as suggested by salsaman\n  * provide macros to simplify sysfs attrfile creation\n  * added deviceattributes\n  * implemented \"video_nr\" parameter to manually force device IDs\n  * dummy audio ioctl's that return EINVAL\n  * better output enumeration/format handling\n  * trying to improve handling of std's\n  * improve readability of vidioc_g_output\n  * added note about video_nr param\n  * fixed memleaks\n  * allow per-device \"max_openers\" settings\n  * warn if illegal number of max_openers is requested\n  * prefix posts with \"v4l2loopback\"\n\n  [ IOhannes m zmoelnig ]\n  * simplistic ChangeLog generator\n\n -- zmoelnig <zmoelnig@umlautO.umlaeute>  Tue, 27 Dec 2011 19:01:25 +0100\n\nv4l2loopback (0.4.1) UNRELEASED; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * yuv4mpeg producer to be used in conjunction with mplayer\n  * added yuv4mpeg_to_v4l2 to the build targets\n  * simplified Makefile; added clean target\n  * protect newer pixel formats\n  * fixed preprocessor expansion on linux<2.6.32\n  * made it compile on 2.6.28 and 2.6.27\n  * <=2.6.27 definitely won't work\n  * allow S_PARM for fps\n  * renamed opener->position to opener->read_position\n  * added dummy VIDIOC_QUERYCTRL implementation (fix for linux-3.1)\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Thu, 24 Nov 2011 18:11:01 +0100\n\nv4l2loopback (0.4.0) UNRELEASED; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * default debug-level should be 0\n  * cleanup version confusion\n  * changed version to 0.3.0\n  * updated README to mention Debian packages\n  * better internal format representation (as found in bttv-drivers) - still unused\n  * trying to support I420 --- might be very unstable right now\n  * dummy Makefile to allow \"make\"\n  * allow to set device from cmdline\n  * en/disable the readback test using defines\n  * use FRAME_SIZE throughout\n  * more experiments\n  * more debugging messages\n  * added rule to autoload the new v4l2loopback device\n  * rewrote most of the mmap part in order to support I420\n  * cleanup to make it C90 compliant again\n  * reordered formats a bit to make better default choices...\n  * replace vloopback by v4l2loopback to avoid confusion\n  * cleaned up code\n  * properly initialize the timestampe in order to guarantee a monotic series\n  * updated copyright\n  * bumped to version 0.4.0\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Tue, 29 Mar 2011 12:54:23 +0200\n\nv4l2loopback (0.3) UNRELEASED; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * note on why gstreamer v4l2sink fails to write to such a device\n  * enum_framesizes and enum_fmt_caps\n  * hmm, this makes it more crashy than better\n  * enable additional ioctls (eg. enum_output)\n  * fixed typo: USAGE instead of USEAGE\n  * remove stray #error\n  * gcode reorganization; uniform comments\n  * experiments with returning 0-size\n  * offline documentation for v4l2\n  * allow all kinds of formats during negotiation\n  * comment on which fields to set\n  * better support for setting formats\n  * add note about using application's bytesperline\n  * set type to WRITER when caller calls enum_fmt_out\n  * removed TODO as it has been done already\n  * indentation\n  * hopefully a bit more intelligent buffer-reallocation strategy\n  * extra safety checks\n  * print fourcc in fmt-enum\n  * fallback formats for try_fmt_out\n  * nicer format descriptions\n  * use defines for size-limits\n  * return EBUSY when trying to set fmt in CAPTURE mode when not ready\n  * properly implement querycap\n  * bytes_used in the mmap may be smaller than the page-size\n  * some dummy functions for video-std settings\n  * debug-level: 1\n  * terminate function call with \";\"\n  * getting rid of MEMLEAK warning (should be fixed now)\n  * calculate bytesperline\n  * only return dummy-format with G_FMT[out] when none has been set\n  * nicer debugging\n  * disable OVERLAY dummy\n  * return 0-sized image by default\n  * default max_buffers_number is 8\n  * getting rid of my prefix\n  * pushed to version 0.0.2\n  * pumped to version 0.3\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Sun, 10 Oct 2010 21:12:38 +0200\n\nv4l2loopback (0.2) UNRELEASED; urgency=low\n\n  [ IOhannes m zmölnig ]\n  * acces /dev/video0\n  * variable number of pipes\n  * nicer printout\n  * proper cleanup\n  * renamed \"pipes\" to \"devices\"\n  * bumped version; added meself as co-author\n  * removed files removed by \"debian/rules clean\"\n  * removed examples\n  * fixed debian/control debian/rules\n  * postinst stuff\n  * moved example into separate folder\n  * MakefileS need not be executable\n  * README, COPYING, AUTHORS\n  * re-version to 0.2\n  * updated README\n  * added Vasily Levin to the authors\n  * removed debian stuff\n  * added a README for the test\n  * added vasily.levin to the authors\n  * included linux/slab.h\n  * license issues: this module is GPLv2\n  * added meself into the copyright header\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Sun, 10 Oct 2010 21:09:43 +0200\n\nv4l2loopback (0.1) UNRELEASED; urgency=low\n\n  [ gorinich.zmey ]\n  * initial\n  * first approach\n  * removed autogenerated file\n  * temproraly removed fps control and input from stdin handling\n  * removed irrelevant changelog, changed readme\n  * forgotten changes applued\n  * modules.order delete\n  * cleaned the mess with git-svn\n  * added test file\n  * added VIDIOC_G_PARM call\n  * format handling improvment, current solution is a stub\n  * temporarly removed mmap to keep code simple\n  * compile fix\n  * poll added, streaming started\n  * small test refine\n  * enum_input added\n  * basic streaming, polish needed\n  * first streaming working, mplayer gots a picture, yet crappy\n  * readme add\n  * readme rewrite\n  * readme additions\n  * mutex add\n  * skype working\n  * queue introduction, next step queue remove\n  * first run is OK already\n  * queues debugged\n  * halfway of massive inner structure changes\n  * compiles\n  * pre multireader\n  * style for linux kernel\n  * indent\n  * 80 width\n  * module name changed and debianize start\n  * debian\n  * 2.6.28 support\n  * almost works, just one bug left\n  * debian\n  * bug with two and more openers fixed\n  * redebianized\n  * removed files\n  * license header add\n  * freeing of unitialized pointer fixed, added nonblocking IO\n  * sync with v4l-dvb tree\n  * review responce\n  * hans review\n  * test improvments by Antonio Ospite\n  * removed header\n  * more small fixes\n\n  [ Scott Maines ]\n  * missing header for Fedora\n\n -- IOhannes m zmoelnig (gpg-key at iem) <zmoelnig@iem.at>  Sun, 10 Oct 2010 21:01:50 +0200\n"
        },
        {
          "name": "Kbuild",
          "type": "blob",
          "size": 0.0244140625,
          "content": "obj-m\t\t:= v4l2loopback.o\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.3720703125,
          "content": "ifneq ($(wildcard .gitversion),)\n# building a snapshot version\nV4L2LOOPBACK_SNAPSHOT_VERSION=$(patsubst v%,%,$(shell git describe --always --dirty 2>/dev/null || shell git describe --always 2>/dev/null || echo snapshot))\noverride KCPPFLAGS += -DSNAPSHOT_VERSION='\"$(V4L2LOOPBACK_SNAPSHOT_VERSION)\"'\nendif\n\ninclude Kbuild\nifeq ($(KBUILD_MODULES),)\n\nKERNELRELEASE\t?= `uname -r`\nKERNEL_DIR\t?= /lib/modules/$(KERNELRELEASE)/build\nPWD\t\t:= $(shell pwd)\n\nPREFIX ?= /usr/local\nBINDIR  = $(PREFIX)/bin\nINCLUDEDIR = $(PREFIX)/include\nMANDIR  = $(PREFIX)/share/man\nMAN1DIR = $(MANDIR)/man1\nINSTALL = install\nINSTALL_PROGRAM = $(INSTALL) -p -m 755\nINSTALL_DIR     = $(INSTALL) -p -m 755 -d\nINSTALL_DATA    = $(INSTALL) -m 644\n\nMODULE_OPTIONS = devices=2\n\n##########################################\n# note on build targets\n#\n# module-assistant makes some assumptions about targets, namely\n#  <modulename>: must be present and build the module <modulename>\n#                <modulename>.ko is not enough\n# install: must be present (and should only install the module)\n#\n# we therefore make <modulename> a .PHONY alias to <modulename>.ko\n# and remove utils-installation from 'install'\n# call 'make install-all' if you want to install everything\n##########################################\n\n\n.PHONY: all install clean distclean\n.PHONY: install-all install-extra install-utils install-man install-headers\n.PHONY: modprobe v4l2loopback\n\n# we don't control the .ko file dependencies, as it is done by kernel\n# makefiles. therefore v4l2loopback.ko is a phony target actually\n.PHONY: v4l2loopback.ko utils\n\nall: v4l2loopback.ko utils\n\nv4l2loopback: v4l2loopback.ko\nv4l2loopback.ko:\n\t@echo \"Building v4l2-loopback driver...\"\n\t$(MAKE) -C $(KERNEL_DIR) M=$(PWD) KCPPFLAGS=\"$(KCPPFLAGS)\" modules\n\ninstall-all: install install-extra\ninstall:\n\t$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules_install\n\t@echo \"\"\n\t@echo \"SUCCESS (if you got 'SSL errors' above, you can safely ignore them)\"\n\t@echo \"\"\n\ninstall-extra: install-utils install-man install-headers\ninstall-utils: utils/v4l2loopback-ctl\n\t$(INSTALL_DIR) \"$(DESTDIR)$(BINDIR)\"\n\t$(INSTALL_PROGRAM) $< \"$(DESTDIR)$(BINDIR)\"\n\ninstall-man: man/v4l2loopback-ctl.1\n\t$(INSTALL_DIR) \"$(DESTDIR)$(MAN1DIR)\"\n\t$(INSTALL_DATA) $< \"$(DESTDIR)$(MAN1DIR)\"\n\ninstall-headers: v4l2loopback.h\n\t$(INSTALL_DIR) \"$(DESTDIR)$(INCLUDEDIR)/linux\"\n\t$(INSTALL_DATA) $< \"$(DESTDIR)$(INCLUDEDIR)/linux\"\n\nclean:\n\trm -f *~\n\trm -f Module.symvers Module.markers modules.order\n\t$(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean\n\t-$(MAKE) -C utils clean\n\ndistclean: clean\n\trm -f man/v4l2loopback-ctl.1\n\nmodprobe: v4l2loopback.ko\n\t-sudo chmod a+r $<\n\t-sudo modprobe videodev\n\t-sudo rmmod $<\n\tsudo insmod ./$< $(MODULE_OPTIONS)\n\nman/v4l2loopback-ctl.1: utils/v4l2loopback-ctl\n\thelp2man -N --name \"control v4l2 loopback devices\" \\\n\t\t--no-discard-stderr --help-option=-h --version-option=-v \\\n\t\t$^ > $@\n\nutils: utils/v4l2loopback-ctl\nutils/v4l2loopback-ctl: utils/v4l2loopback-ctl.c v4l2loopback.h\n\t$(MAKE) -C utils V4L2LOOPBACK_SNAPSHOT_VERSION=$(V4L2LOOPBACK_SNAPSHOT_VERSION)\n\n.clang-format:\n\tcurl \"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/.clang-format\" > $@\n\n.PHONY: clang-format\nclang-format: .clang-format\n\tclang-format -i *.c *.h utils/*.c\n\n.PHONY: sign\n# try to read the default certificate/key from the dkms config\ndkms_framework=/etc/dkms/framework.conf\n-include $(dkms_framework)\nKBUILD_SIGN_KEY=$(mok_signing_key)\nKBUILD_SIGN_CERT=$(mok_certificate)\n\nifeq ($(KBUILD_SIGN_PIN),)\ndefine usage_kbuildsignpin\n$(info )\n$(info ++++++ If your certificate requires a password, pass it via the KBUILD_SIGN_PIN env-var!)\n$(info ++++++ E.g. using 'export KBUILD_SIGN_PIN; read -s -p \"Passphrase for signing key $(KBUILD_SIGN_KEY): \" KBUILD_SIGN_PIN; sudo --preserve-env=KBUILD_SIGN_PIN make sign')\n$(info )\nendef\nendif\n\ndefine usage_kbuildsign\nsign: v4l2loopback.ko\n\t$(info )\n\t$(info ++++++ To sign the $< module, you must set KBUILD_SIGN_KEY/KBUILD_SIGN_CERT to point to the signing key/certificate!)\n\t$(info ++++++ For your convenience, we try to read these variables as 'mok_signing_key' resp. 'mok_certificate' from $(dkms_framework))\n\t$(call usage_kbuildsignpin)\nendef\n\nifeq ($(wildcard $(KBUILD_SIGN_KEY)),)\n$(call usage_kbuildsign)\nelse ifeq ($(wildcard $(KBUILD_SIGN_CERT)),)\n$(call usage_kbuildsign)\nelse\nsign: v4l2loopback.ko\n\t$(call usage_kbuildsignpin)\n\t\"$(KERNEL_DIR)\"/scripts/sign-file sha256 $(KBUILD_SIGN_KEY) $(KBUILD_SIGN_CERT) $<\nendif\n\nendif # !kbuild\n"
        },
        {
          "name": "Makefile.manual",
          "type": "blob",
          "size": 2.12890625,
          "content": "## DO NOT USE THIS MAKEFILE!\n### this is created based on `make V=1 > make.log` and is used solely\n### for creating build for static code analysis\n.PHONY: default\n\nKERNELRELEASE\t?= `uname -r`\nKERNEL_SOURCE\t?= /lib/modules/$(KERNELRELEASE)/build\nKERNEL_SOURCE_COMMON ?= /lib/modules/$(KERNELRELEASE)/source\n\nCFLAGS=-nostdinc -isystem /usr/lib/gcc/x86_64-linux-gnu/4.8/include -I$(KERNEL_SOURCE_COMMON)/arch/x86/include -I$(KERNEL_SOURCE)/arch/x86/include/generated  -I$(KERNEL_SOURCE_COMMON)/include -I$(KERNEL_SOURCE)/include -I$(KERNEL_SOURCE_COMMON)/arch/x86/include/uapi -I$(KERNEL_SOURCE)/arch/x86/include/generated/uapi -I$(KERNEL_SOURCE_COMMON)/include/uapi -I$(KERNEL_SOURCE)/include/generated/uapi -include $(KERNEL_SOURCE_COMMON)/include/linux/kconfig.h -I.  -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Werror-implicit-function-declaration -Wno-format-security -fno-delete-null-pointer-checks -O2 -m64 -mno-mmx -mno-sse -mpreferred-stack-boundary=3 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args -fstack-protector -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -DCONFIG_AS_FXSAVEQ=1 -DCONFIG_AS_AVX=1 -DCONFIG_AS_AVX2=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -Wframe-larger-than=2048 -Wno-unused-but-set-variable -fomit-frame-pointer -g -Wdeclaration-after-statement -Wno-pointer-sign -fno-strict-overflow -fconserve-stack -Werror=implicit-int -Werror=strict-prototypes -DCC_HAVE_ASM_GOTO\n\n\ndefault:\n\t$(CC) -Wp,-MD,./.v4l2loopback.o.d  $(CFLAGS) -DMODULE  -D\"KBUILD_STR(s)=#s\" -D\"KBUILD_BASENAME=KBUILD_STR(v4l2loopback)\"  -D\"KBUILD_MODNAME=KBUILD_STR(v4l2loopback)\" -c -o ./.tmp_v4l2loopback.o ./v4l2loopback.c\n\t$(CC) -Wp,-MD,./.v4l2loopback.mod.o.d  $(CFLAGS) -D\"KBUILD_STR(s)=#s\" -D\"KBUILD_BASENAME=KBUILD_STR(v4l2loopback.mod)\"  -D\"KBUILD_MODNAME=KBUILD_STR(v4l2loopback)\" -DMODULE  -c -o ./v4l2loopback.mod.o ./v4l2loopback.mod.c\n\t$(LD) -r -m elf_x86_64 -T $(KERNEL_SOURCE_COMMON)/scripts/module-common.lds --build-id  -o ./v4l2loopback.ko ./v4l2loopback.o ./v4l2loopback.mod.o\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 5.7265625,
          "content": "v4l2loopback-0.13.2\n\n  * Fix compilation on 32bit architectures (i386, armhf,...)\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Fri, 24 May 2024 11:30:51 +0200\n\nv4l2loopback-0.13.1\n\n  * Avoid building utils with dkms\n  * Fix version number in module\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Tue, 19 Mar 2024 22:15:34 +0100\n\nv4l2loopback-0.13.0\n\n  * Dynamic device management\n\n -- IOhannes m zmölnig (Debian/GNU) <umlaeute@debian.org>  Tue, 19 Mar 2024 17:11:08 +0100\n\nv4l2loopback-0.12.3\n\n  * Fixed compat with kernel 5.4\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Fri, 06 Dec 2019 18:28:29 +0100\n\nv4l2loopback-0.12.1\n\n  * Fixed compat with kernel 5.0\n  * Replace v4l2_get_timestamp with ktime_get_ts(64) for linux-5.1 compat\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Mon, 02 Jul 2018 12:27:29 +0200\n\n\nv4l2loopback-0.12.0\n\n  * Fixed compat with kernel 4.16\n  * NV12 support\n  * 8bit Bayer support\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Mon, 02 Jul 2018 12:27:29 +0200\n\nv4l2loopback-0.11.0\n\n  * Adapted to new kernel timer API\n  * VP9 & HEVC support\n  * Hacks to work around issues with Google Chrome and GStreamer-0.10\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Tue, 06 Mar 2018 10:05:11 +0100\n\nv4l2loopback-0.10.0\n\n  * More consistent device names\n  * Disabled exclusive_caps by *default*\n  * Removed deprecated current_norm\n  * Fixed a number of bugs (esp. when working with GStreamer-1.0)\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Fri, 02 Dec 2016 22:00:27 +0100\n\nv4l2loopback-0.9.1\n\n  - Fixed module version\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Wed, 03 Jun 2015 19:47:23 +0200\n\nv4l2loopback-0.9.0\n\n  - more formats\n  - kernel compatibility\n        fixed issues with kernel up to 4.0\n\n -- IOhannes m zmölnig <zmoelnig@umlaeute.mur.at>  Tue, 02 Jun 2015 19:58:39 +0200\n\nv4l2loopback-0.8.0\n\n  - DKMS config\n  - 'card_label' option to manually set device names\n  - fixes in format handling\n\n -- IOhannes m zmölnig <zmoelnig@iem.at>  Tue, 10 Dec 2013 18:12:15 +0100\n\nv4l2loopback-0.7.1\n\n  - kernel compatibility\n        fixed issues with kernel-3.11\n        fixed regression with kernel<2.6.29\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Mon, 16 Sep 2013 09:55:51 +0200\n\nv4l2loopback-0.7.0\n\n  - experimental'exclusive_caps' mode that only reports CAPTURE/OUTPUT\n    capabilities exclusively (support for Chromium/WebRTC)\n  - disabled fake STDs (e.g. ffmpeg support)\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Fri, 07 Jun 2013 11:08:10 +0200\n\nv4l2loopback-0.6.3\n\n  - kernel compatibility\n\tfixed issues with kernel-3.7\n  - unique \"Card Type\" Names (fixes broken clients like flash)\n  - create unique ID in \"bus_info\" field (fixes Firefox/WebRTC support)\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at> 2013-02-05\n\nv4l2loopback-0.6.2\n\n  - kernel compatibility\n\tfixed issues with older kernels (<2.6.37)\n\tfixed issues with kernel-3.6.1\n  - distinct device names (fixes broken clients like google+)\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at> 2012-10-23\n\nv4l2loopback-0.6.1\n\n  - Debian specific build-fixes\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at> 2012-04-27\n\nv4l2loopback-0.6.0\n\n  - support fallback images (in case there is no live-stream)\n  - utilities to interact with v4l2loopback devices\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at> 2012-04-27\n\nv4l2loopback-0.5.0\n\n  - module parameters\n               'video_nr' manually sets device id(s)\n  - device attributes\n               via sysfs: /sys/devices/virtual/video4linux/video*/\n               'max_openers' per device\n               'fourcc' queries currently selected format\n  - ioctl fixes\n               avoid the BIG KERNEL LOCK\n               ENUM_FRAMEINTERVAL implementation\n               fixed ENUM_FRAMESIZES (fixes skype compatibilitiy)\n               fixes to buffer queue with multiple consumers\n               minor fixes to handling of standards, output enumeration and output formats\n  - more (and better) debugging output\n  - fixed memleaks in the examples\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Tue, 27 Dec 2011 19:01:25 +0100\n\nv4l2loopback-0.4.1\n\n - yuv4mpeg producer example\n - kernel compatibility\n\t\tfixed issues with kernels<2.6.32\n\t\tfixed issues with kernel-3.1\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Thu, 24 Nov 2011 18:11:01 +0100\n\nv4l2loopback-0.4\n\n - fixed issues with non-trivial colorspaces (e.g. I420)\n\t\tthis should allow for more clients to work out-of-the-box\n\t\t(e.g. no more caps-tweak with gstreamer)\n - fixed timestamps\n\t\tthis allows playback with players that need monotonous\n\t\ttimestamps (e.g. ffmpeg)\n - cleaned up code\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Tue, 29 Mar 2011 14:26:10 +0200\n\nv4l2loopback-0.3\n\n  - tested writers:\n\t\tGStreamer's normal \"v4l2sink\" element (from plugins-good)\n\t\tGStreamer's \"v4l2loopback\" (deprecated by v4l2sink)\n\t\tpd/Gem(0.93svn)\n  - tested readers:\n\t\tGStreamer's \"v4l2src\"\n\t\tpd/Gem(0.92)\n\t\tvlc\n\t\txawtv (depending on image format)\n\t\tmplayer (with correct image format, e.g. rgb32)\n  - code documentation\n  - added v4l2-documentation for easier offline programming\n  - added a lot of ioctls to meet the v4l2 standard\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Sun, 10 Oct 2010 21:18:22 +0200\n\nv4l2loopback-0.2\n\n  - Linux 2.6.32 & 2.6.35\n  - tested with pd/Gem(0.93svn) and GStreamer's \"v4l2loopback\"\n  - add support for multiple video devices\n  - README, COPYING, AUTHORS\n  - re-organized file layout\n\n -- IOhannes m zmoelnig <zmoelnig@iem.at>  Tue Sep 28 09:46:47 CEST 2010\n\nv4l2loopback-0.1\n\n  - Linux 2.6.28\n  - Skype support\n  - support for GStreamer's \"v4l2loopback\" element\n  - test application\n  - README\n  - dev: nonblocking I/O\n  - dev: VIDIOC_G_PARM\n\n -- Gorinich Zmey <gorinich.zmey> Wed Jun 16 12:19:59 CEST 2010\n\nv4l2loopback-0.0\n\n  - initial\n\n -- Vasily Levin <vasaka@gmail.com>  Tue Feb  3 10:56:28 CET 2009\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.873046875,
          "content": "v4l2loopback - a kernel module to create V4L2 loopback devices\n==============================================================\n\nThis module allows you to create \"virtual video devices\".\nNormal (v4l2) applications will read these devices as if they were ordinary\nvideo devices, but the video will not be read from e.g. a capture card but\ninstead it is generated by another application.\nThis allows you for instance to apply some nifty video effects on your\nSkype video...\nIt also allows some more serious things (e.g. I've been using it to add\nstreaming capabilities to an application by the means of hooking GStreamer into\nthe loopback devices).\n\n# NEWS\nTo get the main features of each new release, see the NEWS file.\nYou could also have a look at the ChangeLog (which gets automatically generated and might\nonly be of limited use...\n\n# ISSUES\nFor current issues, checkout https://github.com/umlaeute/v4l2loopback/issues\nPlease use the issue-tracker for reporting any problems.\n\nBefore you create a new ticket in our issue tracker, please make sure that you have read\n*this* document and followed any instructions found within.\n\nAlso, please search the issue-tracker *before* reporting any problems: it's much better\nto add your information to an existing ticket than to create a new ticket with essentially\nthe same information.\n\n## SEEKING HELP\nThe issue tracker is meant to track specific bugs in the code (and new features).\nHowever, it is ill-suited as a user support forum.\n\nIf you have general questions or problems, please use the `v4l2loopback` tag\non [Unix & Linux](https://unix.stackexchange.com/questions/tagged/v4l2loopback) instead:\nhttps://unix.stackexchange.com/questions/tagged/v4l2loopback\n\n\n# DEPENDENCIES\nIn order to build (compile,...) anything, you must have a *working* build-environment\n(compiler, GNU make,...).\nThe kernel can be somewhat picky if you try to load a module that was compiled with\na different compiler as was used to compile the kernel itself.\nSo make sure to have the right compiler in place.\n\nThe v4l2loopback module is a *kernel module*.\nIn order to build it, you *must have* the kernel headers installed that match\nthe linux kernel with which you want to use the module (in most cases this will\nbe the kernel that you are currently running).\nPlease note, that kernel headers and kernel image must have *exactly the same* version.\nFor example, `3.18.0-trunk-rpi` is a different version than `3.18.7-v7+`, even though\nthe first few numbers are the same.\n(Modules will be incompatible if the versions don't match. If you are lucky, the module will\nsimply refuse to load. If you are unlucky, your computer will spit in your eye or do worse.)\n\nThere are distribution-specific differences on how to get the correct kernel headers\n(or to install a compilation toolchain).\nDocumenting all those possibilities would go far beyond the scope of `v4l2loopback`.\nPlease understand that we cannot provide support for questions regarding dependencies.\n\n\n# BUILD\nTo build the kernel module, run:\n\n    $ make\n\nThis should give you a file named \"v4l2loopback.ko\", which is the kernel module\n\n## Build again\nYou cannot load a module built for a specific version of the kernel into another version of the kernel.\nSo, if you have successfully built the module previously and have updated your kernel (and the matching headers)\nIn the meantime, you really must clean the build before re-compiling the module.\nSo run this *before* starting the build again:\n\n    $ make clean\n\nAfterwards re-run `make` to do the actual build.\n\n## Build for a different kernel\nBy default a simple `make` will (try to) build the module for the currently active kernel (as determined by `uname -r`).\nIf you want to build for a different kernel, youcan do so by providing the kernel version via the `KERNELRELEASE` variable:\n\n    $ make KERNELRELEASE=6.11.7-amd64\n\n(Of course you must have the kernel-headers for the specified kernel available in the `/lib/modules/${KERNELRELEASE}/build/` directory.)\n\n\n# INSTALL\nTo install the module, run \"make install\" (you might have to be 'root' to have\nall necessary permissions to install the module).\n\nIf your system has \"sudo\", do:\n\n    $ make && sudo make install\n    $ sudo depmod -a\n\nIf your system lacks \"sudo\", do:\n\n    $ make\n    $ su\n    (enter root password)\n    # make install\n    # depmod -a\n    # exit\n\n\n(The `depmod -a` call will re-calculate module dependencies, in order to\nautomatically load additional kernel modules required by v4l2loopback.\nThe call may not be necessary on modern systems.)\n\nSee below for [distribution-specific build instructions](#DISTRIBUTIONS)\nor when using frameworks like [`DKMS`](#DKMS).\n\n\n# RUN\nLoad the v4l2loopback module as root :\n\n    # modprobe v4l2loopback\n\nUsing `sudo` use:\n\n    $ sudo modprobe v4l2loopback\n\nYou can check which loopback devices are created by listing contents of\n`/sys/devices/virtual/video4linux` directory. E.g. if there are two\n`v4l2loopback` devices `/dev/video0` and `/dev/video3` you would get:\n\n    $ ls -1 /sys/devices/virtual/video4linux\n    video0\n    video3\n\nThese devices are ready to accept contents to show.\n\nTested feeders:\n- GStreamer-1.0: using the  \"v4l2sink\" element\n- Gem(>=0.93) using the \"recordV4L2\" plugin\n\nIn theory most programs capable of _writing to_ a v4l2 device should work.\n\nThe data sent to the v4l2loopback device can then be read by any v4l2-capable\napplication.\n\nYou can find a number of scenarios on the wiki at\n\thttp://github.com/umlaeute/v4l2loopback/wiki\n\n## Troubleshooting\nIf you have a secure-boot enabled kernel, you might not be able to simply build a kernel module and insert it.\n(You will get **SSL error**s when building the module.)\nThis is actually a security feature (as it prevents malicious code to be inserted into kernel-space).\n\nIf you are not allowed to insert the kernel module (running `modprobe`, or `insmod`), you have a few options\n(consult your distribution's documentation on how to perform any of these steps):\n- disable secure-boot and reboot\n- sign the module binary with a whitelisted key (this probably only applies if you are creating a distribution)\n\nYou could also just try building the module [via `DKMS`](#DKMS), and hope that it does all the magic for you.\n\n# OPTIONS\nIf you need several independent loopback devices, you can pass the \"devices\"\noption, when loading the module; e.g.\n\n    # modprobe v4l2loopback devices=4\n\nWill give you 4 loopback devices (e.g. `/dev/video1` ... `/dev/video5`)\n\nYou can also specify the device IDs manually; e.g.\n\n    # modprobe v4l2loopback video_nr=3,4,7\n\nWill create 3 devices (`/dev/video3`, `/dev/video4` & `/dev/video7`)\n\n    # modprobe v4l2loopback video_nr=3,4,7 card_label=\"device number 3\",\"the number four\",\"the last one\"\n\nWill create 3 devices with the card names passed as the second parameter:\n- `/dev/video3` -> *device number 3*\n- `/dev/video4` -> *the number four*\n- `/dev/video7` -> *the last one*\n\n\nIf you encounter problems detecting your device with Chrome/WebRTC you can try 'exclusive_caps' mode:\n\n    # modprobe v4l2loopback exclusive_caps=1\n\nThis will enable 'exclusive_caps' mode that only reports CAPTURE/OUTPUT capabilities exclusively.\nThe newly created device will announce OUTPUT capabilities only (so ordinary webcam applications\n(including Chrome) won't see it). As soon as you have attached a producer to the device, it will\nstart announcing CAPTURE capabilities only (so applications that refuse to open devices that have\nother capabilities apart from capturing can open it too.)\n\n## CHANGING OPTIONS\nOptions that you provided when loading the module (e.g. via `modprobe`) cannot be easily changed\non the fly.\nIn order to change these options, you must first unload the module with `rmmod`\n(which will only work if no application is any longer accessing one of the loopback devices)\nand then load it again (with the new options).\n\nSee also the section about [DYNAMIC DEVICE MANAGEMENT](#dynamic-device-management).\n\n\n\n# ATTRIBUTES\nyou can set and/or query some per-device attributes via sysfs, in a human\nreadable format. See `/sys/devices/virtual/video4linux/video*/`\n\nalso there are some V4L2 controls that you can list with\n\n    $ v4l2-ctl -d /dev/video0 -l\n\n- `keep_format(0/1)`: while set to 1, once negotiated format will be fixed forever,\n                  until the setting is set back to 0\n- `sustain_framerate(0/1)`: if set to 1, nominal device fps will be ensured by means\n                        of frame duplication when needed\n- `timeout(integer)`: if >0, will cause a timeout picture (a null frame, by default)\n                  to be displayed after (value) msecs of missing input\n- `timeout_image_io(0/1)`: if set to 1, the next opener will write to timeout frame\n                       buffer\n\n# CHANGING THE RUNTIME BEHAVIOUR\n## FORCING FPS\n\n    $ v4l2loopback-ctl set-fps /dev/video0 25\n\nor\n\n    $ echo '@100' | sudo tee /sys/devices/virtual/video4linux/video0/format\n\n## FORCING FORMAT\n\n    $ v4l2loopback-ctl set-caps /dev/video0 \"UYVY:640x480\"\n\nPlease note that *GStreamer-style caps* (e.g. `video/x-raw,format=UYVY,width=640,height=480`) or no longer supported!\n\n## SETTING STREAM TIMEOUT\n\nYou can define a timeout (in milliseconds), after which the loopback device will start outputting NULL frames,\nif the producer suddenly stopped.\n\n~~~\n$ v4l2-ctl -d /dev/video0 -c timeout=3000\n~~~\n\nAlternatively, you can calso provide a timeout-image, which will be displayed (instead of the NULL frames),\nif the producer doesn't send any new frames for a given period:\n\n~~~\n$ v4l2loopback-ctl set-timeout-image -t 3000 /dev/video0 service-unavailable.png\n(this currently requires GStreamer 1.0 installed)\n~~~\n\n## DYNAMIC DEVICE MANAGEMENT\nYou can create (and delete) loopback devices on the fly, using the `add` (resp. `delete`) commands of the `v4l2loopback-ctl` utility.\n\nWhen creating a new device, module options might be ignored. So you must specify them explicitly.\n\nTo create a new device `/dev/video7` that has a label \"loopy doopy\", use:\n\n~~~\n$ sudo v4l2loopback-ctl add -n \"loopy doopy\" /dev/video7\n~~~\n\nDeleting devices is as simple as:\n\n~~~\n$ sudo v4l2loopback-ctl delete /dev/video7\n~~~\n\n# KERNELs\nThe original module has been developed for linux-2.6.28;\nI don't have a system with such an old kernel anymore, so I don't know whether\nit still works.\nFurther development has been done mainly on linux-2.6.32 and linux-2.6.35, with\nnewer kernels being continually tested as they enter Debian.\n\nSupport:\n- >= <kbd>5.0.0</kbd>\t\tshould work\n- >= <kbd>4.0.0</kbd>\t\tshould work\n- >= <kbd>3.0.0</kbd>\t\tmight work\n- << <kbd>3.0.0</kbd>\t\tmay work (has not been tested in ages)\n- <= <kbd>2.6.37</kbd>\t\twill definitely NOT work\n\n# DISTRIBUTIONS\nv4l2loopack is now (since 2010-10-13) available as a Debian-package.\nhttps://packages.debian.org/source/stable/v4l2loopback\n\nThis means, that it is also part of Debian-derived distributions, including\nUbuntu (starting with natty).\nThe most convenient way is to install the package \"v4l2loopback-dkms\":\n\n    # apt-get install v4l2loopback-dkms\n\nThis should automatically build and install the module for your current kernel\n(provided you have the matching kernel-headers installed).\nAnother option is to install the \"v4l2loopback-source\" package.\nIn this case you should be able to simply do (as root):\n\n    # apt-get install v4l2loopback-source module-assistant\n    # module-assistant auto-install v4l2loopback-source\n\n# DKMS\nThe *Dynamic Kernel Module Support framework* (DKMS) is designed to allow\nindividual kernel modules to be upgraded without changing the whole kernel.\nIt is also very easy to rebuild modules as you upgrade kernels.\n\nIf your distribution doesn't provide `v4l2loopback`-packages (or they are too old)\nand you are experiencing troubles with code-signing, you probably should try this.\n\nE.g. to build the v4l2loopback-v0.12.5 (but check the webpage for newer releases first!),\nuse something like the following (you might need to run the `dkms` commands as superuser/root):\n\n~~~\nversion=0.12.5\n# download and extract the tarball (tar requires superuser privileges)\ncurl -L https://github.com/umlaeute/v4l2loopback/archive/v${version}.tar.gz | tar xvz -C /usr/src\n# build and install the DKMS-module (requires superuser privileges)\ndkms add -m v4l2loopback -v ${version}\ndkms build -m v4l2loopback -v ${version}\ndkms install -m v4l2loopback -v ${version}\n~~~~\n\n| distribution       | dependencies          |\n|--------------------|-----------------------|\n| Fedora,...         | gcc kernel-devel dkms |\n| Debian, Ubuntu,... | dkms                  |\n\n\nNote that using this method will NOT install the v4l2loopback-ctl tool, you will have to do it yourself!\n\n# LOAD THE MODULE AT BOOT\n\nOne can avoid manually loading the module by letting systemd load the module\nat boot, by creating a file `/etc/modules-load.d/v4l2loopback.conf` with just\nthe name of the module. This is especially convenient when `v4l2loopback` is installed with DKMS or with\na package provided by your Linux distribution:\n\n~~~\nv4l2loopback\n~~~\n\nIf needed, one can specify default module options by creating\n`/etc/modprobe.d/v4l2loopback.conf` in the following form instead:\n\n~~~\noptions v4l2loopback video_nr=3,4,7 card_label=\"device number 3,the number four,the last one\"\n~~~\n\nThese options also become the defaults when manually calling\n`modprobe v4l2loopback`. Note that the double quotes can only be used at the\nbeginning and the end of the option's value, as opposed to when they are\nspecified on the command line.\n\nIf your system boots with an initial ramdisk, which is the case for most\nmodern distributions, you need to update this ramdisk with the settings above,\nbefore they take effect at boot time. In Ubuntu, this image is updated with\n`sudo update-initramfs`. The equivalent on Fedora is `sudo dracut -f`.\n\n\n# DOWNLOAD\nThe most up-to-date version of this module can be found at\nhttp://github.com/umlaeute/v4l2loopback/.\n\n# LICENSE/COPYING\n\n- Copyright (c) 2010-2023 IOhannes m zmoelnig\n- Copyright (c) 2016 Gavin Qiu\n- Copyright (c) 2016 George Chriss\n- Copyright (c) 2014-2015 Tasos Sahanidis\n- Copyright (c) 2012-2015 Yusuke Ohshima\n- Copyright (c) 2015 Kurt Kiefer\n- Copyright (c) 2015 Michel Promonet\n- Copyright (c) 2015 Paul Brook\n- Copyright (c) 2015 Tom Zerucha\n- Copyright (c) 2013 Aidan Thornton\n- Copyright (c) 2013 Anatolij Gustschin\n- Copyright (c) 2012 Ted Mielczarek\n- Copyright (c) 2012 Anton Novikov\n- Copyright (c) 2011 Stefan Diewald\n- Copyright (c) 2010 Scott Maines\n- Copyright (c) 2009 Gorinich Zmey\n- Copyright (c) 2005-2009 Vasily Levin\n\n    This package is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This package is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. If not, see <http://www.gnu.org/licenses/>.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.16015625,
          "content": "# Security Policy\n\n## Reporting a Vulnerability\n\nYou can report vulnerability issues by opening a *confidential issue* on https://git.iem.at/zmoelnig/v4l2loopback/\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.728515625,
          "content": "TODO for v4l2loopback in no specific order\n\n- fix all bugs :-)\n\n- improve buffering (salsaman)\n\n- allow USERPTR buffers\n\n- allow to use the device without streaming i/o\n\n- pass 'v4l2-compliance' tests\n  currently failing are:\n\tVIDIOC_G/S_PRIORITY\n\tVIDIOC_LOG_STATUS\n\tVIDIOC_ENUMAUDIO\n\tVIDIOC_G/S_AUDIO\n\tVIDIOC_ENUMAUDOUT\n\tVIDIOC_G/S/ENUMOUTPUT\n\tVIDIOC_G/S_CTRL\n\tVIDIOC_G/S/TRY_EXT_CTRLS\n\tVIDIOC_ENUM/G/S/QUERY_STD\n\tVIDIOC_ENUM/G/S/QUERY_DV_PRESETS\n\tVIDIOC_ENUM_FMT/FRAMESIZES/FRAMEINTERVALS\n\tVIDIOC_G_FBUF\n\tVIDIOC_G_FMT\n\tVIDIOC_G_SLICED_VBI_CAP\n\n- it would be nice to have a way to communicate format requests from the\n  consumer to the producer (though i see no way how to do that)\n\n- provide more producers for more colorspaces in the examples\n"
        },
        {
          "name": "currentversion.sh",
          "type": "blob",
          "size": 0.1396484375,
          "content": "#!/bin/sh\n\nnum() {\n\tgrep \"^#define V4L2LOOPBACK_VERSION_$1 \" v4l2loopback.h | awk '{print $3}'\n}\n\necho $(num MAJOR).$(num MINOR).$(num BUGFIX)\n"
        },
        {
          "name": "dkms.conf",
          "type": "blob",
          "size": 0.7685546875,
          "content": "PACKAGE_NAME=\"v4l2loopback\"\nPACKAGE_VERSION=\"0.13.2\"\n\nif [ -f $kernel_source_dir/.config ]; then\n    . $kernel_source_dir/.config\n    if ! { echo \"$kernelver\"; echo 5.18; } | sort -V -C; then\n        # for linux>=5.18, CONFIG_VIDEO_V4L2 has been renamed to CONFIG_VIDEO_DEV\n        if [ \"${CONFIG_VIDEO_DEV:-n}\" = \"n\" ]; then\n            BUILD_EXCLUSIVE_KERNEL=\"REQUIRES CONFIG_VIDEO_DEV\"\n        fi\n    else\n        if [ \"${CONFIG_VIDEO_V4L2:-n}\" = \"n\" ]; then\n            BUILD_EXCLUSIVE_KERNEL=\"REQUIRES CONFIG_VIDEO_V4L2\"\n        fi\n    fi\nfi\n\n# Items below here should not have to change with each driver version\nMAKE[0]=\"make KERNEL_DIR=${kernel_source_dir} v4l2loopback\"\nCLEAN=\"make clean\"\n\nBUILT_MODULE_NAME[0]=\"$PACKAGE_NAME\"\nDEST_MODULE_LOCATION[0]=\"/extra\"\n\nAUTOINSTALL=\"yes\"\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 3.298828125,
          "content": "#!/bin/sh\n####################################\n# prepare package for release\n\n# DONE: get current version from module source\n# DONE: ChangeLog generator using git-dch\n# DONE: update dkms.conf\n# TODO: automatically update AUTHORS\n# TODO: automatically prepare NEWS (from ChangeLog)\n# TODO: automatically launch editors for ChangeLog/NEWS/AUTHORS\n# TODO: automatically tag (if all went well)\n\nCHANGELOG=ChangeLog\nAUTHORS=AUTHORS\nNEWS=NEWS\n: \"${mainbranch:=main}\"\n\nerror() {\n  echo \"$@\" 1>&2\n}\nfatal() {\n  error \"$@\"\n  exit 1\n}\nusage() {\n fatal \"usage: $0 [<LASTVERSION>] <CURVERSION>\" 1>&2\n}\n\ngetoldversion() {\n  dpkg-parsechangelog --count 1 -l${CHANGELOG} | grep -E \"^Version:\" | head -1 | cut -f2 -d' '\n}\ngetmoduleversion0() {\n  grep \"^#define V4L2LOOPBACK_VERSION_CODE KERNEL_VERSION\" v4l2loopback.c \\\n  | sed -e 's|^#define V4L2LOOPBACK_VERSION_CODE KERNEL_VERSION||' \\\n        -e 's|^[^0-9]*||' -e 's|[^0-9]*$||' \\\n        -e 's|[^0-9][^0-9]*|.|g'\n}\ngetmoduleversion_() {\n  grep \"^[[:space:]]*#[[:space:]]*define[[:space:]]*V4L2LOOPBACK_VERSION_$1[[:space:]]\" v4l2loopback.h | awk '{print $NF}'\n}\ngetmoduleversion() {\n  echo \"$(getmoduleversion_ MAJOR).$(getmoduleversion_ MINOR).$(getmoduleversion_ BUGFIX)\"\n}\ngetgitbranch() {\n  git rev-parse --abbrev-ref HEAD\n}\n\nif [ \"$(getgitbranch)\" != \"${mainbranch}\" ]; then\n fatal \"current branch '$(getgitbranch)' is not '${mainbranch}'\"\nfi\n\nmoduleversion=$(getmoduleversion)\n\nif [ -z \"$2\" ]; then\n## guess current version\n NEWVERSION=$1\n OLDVERSION=$(getoldversion)\nelse\n OLDVERSION=$1\n NEWVERSION=$2\nfi\n\nif [ -z \"${NEWVERSION}\" ]; then\n  NEWVERSION=\"${moduleversion}\"\nfi\n\necho \"module version: ${moduleversion}\"\n\necho \"updating from: ${OLDVERSION}\"\nif git tag -l \"v${OLDVERSION}\" | grep . >/dev/null\nthen\n :\nelse\n fatal \"it seems like there is no tag 'v${OLDVERSION}'\"\nfi\n\nif [ -z \"${OLDVERSION}\" ]; then\n usage\nfi\n\n\nif [ -z \"${NEWVERSION}\" ]; then\n usage\nfi\n\necho \"updating to: ${NEWVERSION}\"\nif dpkg --compare-versions \"${OLDVERSION}\" ge \"${NEWVERSION}\"\nthen\n fatal \"version mismatch: ${NEWVERSION} is not newer than ${OLDVERSION}\"\nfi\n\n\nif [ \"${NEWVERSION}\" != \"${moduleversion}\" ]; then\n  echo \"${NEWVERSION}\" | sed -e 's|\\.| |g' | while read -r major minor bugfix; do\n    major=$((major+0))\n    minor=$((minor+0))\n    bugfix=$((bugfix+0))\n    sed -e \"s|^\\([[:space:]]*#[[:space:]]*define[[:space:]]*V4L2LOOPBACK_VERSION_MAJOR[[:space:]]\\).*|\\1${major}|\"   -i v4l2loopback.h\n    sed -e \"s|^\\([[:space:]]*#[[:space:]]*define[[:space:]]*V4L2LOOPBACK_VERSION_MINOR[[:space:]]\\).*|\\1${minor}|\"   -i v4l2loopback.h\n    sed -e \"s|^\\([[:space:]]*#[[:space:]]*define[[:space:]]*V4L2LOOPBACK_VERSION_BUGFIX[[:space:]]\\).*|\\1${bugfix}|\" -i v4l2loopback.h\n    break\n  done\nfi\n\nOK=false\nmkdir debian\ncp \"${CHANGELOG}\" debian/changelog\ngbp dch -R --since \"v${OLDVERSION}\" -N \"${NEWVERSION}\" --debian-branch=\"${mainbranch}\" && cat debian/changelog > \"${CHANGELOG}\" && OK=true\nrm -rf debian\n\nif [ \"${OK}\" = \"true\" ]; then\n  sed -e \"s|^PACKAGE_VERSION=\\\".*\\\"$|PACKAGE_VERSION=\\\"${NEWVERSION}\\\"|\" -i dkms.conf\nfi\n\n\n\n\nif [ \"${OK}\" = \"true\" ]; then\n echo \"all went well\"\n echo \"\"\n echo \"- please check your ${CHANGELOG}\"\n echo \"- please check&edit your ${NEWS}\"\n echo \"- please check&edit your ${AUTHORS}\"\n echo \"- and don't forget to git-tag the new version as v${NEWVERSION}\"\n echo \" git tag v${NEWVERSION} -s -m \\\"Released ${NEWVERSION}\\\"\"\nfi\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "udev",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "v4l2loopback.c",
          "type": "blob",
          "size": 83.775390625,
          "content": "/* -*- c-file-style: \"linux\" -*- */\n/*\n * v4l2loopback.c  --  video4linux2 loopback driver\n *\n * Copyright (C) 2005-2009 Vasily Levin (vasaka@gmail.com)\n * Copyright (C) 2010-2023 IOhannes m zmoelnig (zmoelnig@iem.at)\n * Copyright (C) 2011 Stefan Diewald (stefan.diewald@mytum.de)\n * Copyright (C) 2012 Anton Novikov (random.plant@gmail.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n */\n#include <linux/version.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/module.h>\n#include <linux/videodev2.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/eventpoll.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-common.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n\n#include <linux/miscdevice.h>\n#include \"v4l2loopback.h\"\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)\n#error This module is not supported on kernels before 4.0.0.\n#endif\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)\n#define strscpy strlcpy\n#endif\n\n#if defined(timer_setup) && defined(from_timer)\n#define HAVE_TIMER_SETUP\n#endif\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 7, 0)\n#define VFL_TYPE_VIDEO VFL_TYPE_GRABBER\n#endif\n\n#define V4L2LOOPBACK_VERSION_CODE                                              \\\n\tKERNEL_VERSION(V4L2LOOPBACK_VERSION_MAJOR, V4L2LOOPBACK_VERSION_MINOR, \\\n\t\t       V4L2LOOPBACK_VERSION_BUGFIX)\n\nMODULE_DESCRIPTION(\"V4L2 loopback video device\");\nMODULE_AUTHOR(\"Vasily Levin, \"\n\t      \"IOhannes m zmoelnig <zmoelnig@iem.at>,\"\n\t      \"Stefan Diewald,\"\n\t      \"Anton Novikov\"\n\t      \"et al.\");\n#ifdef SNAPSHOT_VERSION\nMODULE_VERSION(__stringify(SNAPSHOT_VERSION));\n#else\nMODULE_VERSION(\"\" __stringify(V4L2LOOPBACK_VERSION_MAJOR) \".\" __stringify(\n\tV4L2LOOPBACK_VERSION_MINOR) \".\" __stringify(V4L2LOOPBACK_VERSION_BUGFIX));\n#endif\nMODULE_LICENSE(\"GPL\");\n\n/*\n * helpers\n */\n#define dprintk(fmt, args...)                                          \\\n\tdo {                                                           \\\n\t\tif (debug > 0) {                                       \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" __stringify( \\\n\t\t\t\t       __LINE__) \"], pid(%d):  \" fmt,  \\\n\t\t\t       task_pid_nr(current), ##args);          \\\n\t\t}                                                      \\\n\t} while (0)\n\n#define MARK()                                                             \\\n\tdo {                                                               \\\n\t\tif (debug > 1) {                                           \\\n\t\t\tprintk(KERN_INFO \"%s:%d[%s], pid(%d)\\n\", __FILE__, \\\n\t\t\t       __LINE__, __func__, task_pid_nr(current));  \\\n\t\t}                                                          \\\n\t} while (0)\n\n#define dprintkrw(fmt, args...)                                        \\\n\tdo {                                                           \\\n\t\tif (debug > 2) {                                       \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" __stringify( \\\n\t\t\t\t       __LINE__) \"], pid(%d): \" fmt,   \\\n\t\t\t       task_pid_nr(current), ##args);          \\\n\t\t}                                                      \\\n\t} while (0)\n\nstatic inline void v4l2l_get_timestamp(struct v4l2_buffer *b)\n{\n\tstruct timespec64 ts;\n\tktime_get_ts64(&ts);\n\n\tb->timestamp.tv_sec = ts.tv_sec;\n\tb->timestamp.tv_usec = (ts.tv_nsec / NSEC_PER_USEC);\n\tb->flags |= V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n}\n\n#if BITS_PER_LONG == 32\n#include <asm/div64.h> /* do_div() for 64bit division */\nstatic inline int v4l2l_mod64(const s64 A, const u32 B)\n{\n\tu64 a = (u64)A;\n\tu32 b = B;\n\n\tif (A > 0)\n\t\treturn do_div(a, b);\n\ta = -A;\n\treturn -do_div(a, b);\n}\n#else\nstatic inline int v4l2l_mod64(const s64 A, const u32 B)\n{\n\treturn A % B;\n}\n#endif\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0)\ntypedef unsigned __poll_t;\n#endif\n\n/* module constants\n *  can be overridden during he build process using something like\n *\tmake KCPPFLAGS=\"-DMAX_DEVICES=100\"\n */\n\n/* maximum number of v4l2loopback devices that can be created */\n#ifndef MAX_DEVICES\n#define MAX_DEVICES 8\n#endif\n\n/* whether the default is to announce capabilities exclusively or not */\n#ifndef V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS\n#define V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS 0\n#endif\n\n/* when a producer is considered to have gone stale */\n#ifndef MAX_TIMEOUT\n#define MAX_TIMEOUT (100 * 1000) /* in msecs */\n#endif\n\n/* max buffers that can be mapped, actually they\n * are all mapped to max_buffers buffers */\n#ifndef MAX_BUFFERS\n#define MAX_BUFFERS 32\n#endif\n\n/* module parameters */\nstatic int debug = 0;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"debugging level (higher values == more verbose)\");\n\n#define V4L2LOOPBACK_DEFAULT_MAX_BUFFERS 2\nstatic int max_buffers = V4L2LOOPBACK_DEFAULT_MAX_BUFFERS;\nmodule_param(max_buffers, int, S_IRUGO);\nMODULE_PARM_DESC(max_buffers,\n\t\t \"how many buffers should be allocated [DEFAULT: \" __stringify(\n\t\t\t V4L2LOOPBACK_DEFAULT_MAX_BUFFERS) \"]\");\n\n/* how many times a device can be opened\n * the per-module default value can be overridden on a per-device basis using\n * the /sys/devices interface\n *\n * note that max_openers should be at least 2 in order to get a working system:\n *   one opener for the producer and one opener for the consumer\n *   however, we leave that to the user\n */\n#define V4L2LOOPBACK_DEFAULT_MAX_OPENERS 10\nstatic int max_openers = V4L2LOOPBACK_DEFAULT_MAX_OPENERS;\nmodule_param(max_openers, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(\n\tmax_openers,\n\t\"how many users can open the loopback device [DEFAULT: \" __stringify(\n\t\tV4L2LOOPBACK_DEFAULT_MAX_OPENERS) \"]\");\n\nstatic int devices = -1;\nmodule_param(devices, int, 0);\nMODULE_PARM_DESC(devices, \"how many devices should be created\");\n\nstatic int video_nr[MAX_DEVICES] = { [0 ...(MAX_DEVICES - 1)] = -1 };\nmodule_param_array(video_nr, int, NULL, 0444);\nMODULE_PARM_DESC(video_nr,\n\t\t \"video device numbers (-1=auto, 0=/dev/video0, etc.)\");\n\nstatic char *card_label[MAX_DEVICES];\nmodule_param_array(card_label, charp, NULL, 0000);\nMODULE_PARM_DESC(card_label, \"card labels for each device\");\n\nstatic bool exclusive_caps[MAX_DEVICES] = {\n\t[0 ...(MAX_DEVICES - 1)] = V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS\n};\nmodule_param_array(exclusive_caps, bool, NULL, 0444);\n/* FIXXME: wording */\nMODULE_PARM_DESC(\n\texclusive_caps,\n\t\"whether to announce OUTPUT/CAPTURE capabilities exclusively or not  [DEFAULT: \" __stringify(\n\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS) \"]\");\n\n/* format specifications */\n#define V4L2LOOPBACK_SIZE_MIN_WIDTH 2\n#define V4L2LOOPBACK_SIZE_MIN_HEIGHT 1\n#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH 8192\n#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT 8192\n\n#define V4L2LOOPBACK_SIZE_DEFAULT_WIDTH 640\n#define V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT 480\n\nstatic int max_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;\nmodule_param(max_width, int, S_IRUGO);\nMODULE_PARM_DESC(max_width,\n\t\t \"maximum allowed frame width [DEFAULT: \" __stringify(\n\t\t\t V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH) \"]\");\nstatic int max_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;\nmodule_param(max_height, int, S_IRUGO);\nMODULE_PARM_DESC(max_height,\n\t\t \"maximum allowed frame height [DEFAULT: \" __stringify(\n\t\t\t V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT) \"]\");\n\nstatic DEFINE_IDR(v4l2loopback_index_idr);\nstatic DEFINE_MUTEX(v4l2loopback_ctl_mutex);\n\n/* frame intervals */\n#define V4L2LOOPBACK_FPS_MIN 0\n#define V4L2LOOPBACK_FPS_MAX 1000\n\n/* control IDs */\n#define V4L2LOOPBACK_CID_BASE (V4L2_CID_USER_BASE | 0xf000)\n#define CID_KEEP_FORMAT (V4L2LOOPBACK_CID_BASE + 0)\n#define CID_SUSTAIN_FRAMERATE (V4L2LOOPBACK_CID_BASE + 1)\n#define CID_TIMEOUT (V4L2LOOPBACK_CID_BASE + 2)\n#define CID_TIMEOUT_IMAGE_IO (V4L2LOOPBACK_CID_BASE + 3)\n\nstatic int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl);\nstatic const struct v4l2_ctrl_ops v4l2loopback_ctrl_ops = {\n\t.s_ctrl = v4l2loopback_s_ctrl,\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_keepformat = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_KEEP_FORMAT,\n\t.name\t= \"keep_format\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_sustainframerate = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_SUSTAIN_FRAMERATE,\n\t.name\t= \"sustain_framerate\",\n\t.type\t= V4L2_CTRL_TYPE_BOOLEAN,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_timeout = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_TIMEOUT,\n\t.name\t= \"timeout\",\n\t.type\t= V4L2_CTRL_TYPE_INTEGER,\n\t.min\t= 0,\n\t.max\t= MAX_TIMEOUT,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\nstatic const struct v4l2_ctrl_config v4l2loopback_ctrl_timeoutimageio = {\n\t// clang-format off\n\t.ops\t= &v4l2loopback_ctrl_ops,\n\t.id\t= CID_TIMEOUT_IMAGE_IO,\n\t.name\t= \"timeout_image_io\",\n\t.type\t= V4L2_CTRL_TYPE_BUTTON,\n\t.min\t= 0,\n\t.max\t= 1,\n\t.step\t= 1,\n\t.def\t= 0,\n\t// clang-format on\n};\n\n/* module structures */\nstruct v4l2loopback_private {\n\tint device_nr;\n};\n\n/* TODO(vasaka) use typenames which are common to kernel, but first find out if\n * it is needed */\n/* struct keeping state and settings of loopback device */\n\nstruct v4l2l_buffer {\n\tstruct v4l2_buffer buffer;\n\tstruct list_head list_head;\n\tint use_count;\n};\n\nstruct v4l2_loopback_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct video_device *vdev;\n\t/* pixel and stream format */\n\tstruct v4l2_pix_format pix_format;\n\tbool pix_format_has_valid_sizeimage;\n\tstruct v4l2_captureparm capture_param;\n\tunsigned long frame_jiffies;\n\n\t/* ctrls */\n\tint keep_format; /* CID_KEEP_FORMAT; stay ready_for_capture even when all\n\t\t\t    openers close() the device */\n\tint sustain_framerate; /* CID_SUSTAIN_FRAMERATE; duplicate frames to maintain\n\t\t\t\t  (close to) nominal framerate */\n\n\t/* buffers stuff */\n\tu8 *image; /* pointer to actual buffers data */\n\tunsigned long int imagesize; /* size of buffers data */\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tstruct v4l2l_buffer buffers[MAX_BUFFERS]; /* inner driver buffers */\n\tint used_buffers; /* number of the actually used buffers */\n\tint max_openers; /* how many times can this device be opened */\n\n\ts64 write_position; /* number of last written frame + 1 */\n\tstruct list_head outbufs_list; /* buffers in output DQBUF order */\n\tint bufpos2index\n\t\t[MAX_BUFFERS]; /* mapping of (read/write_position % used_buffers)\n                        * to inner buffer index */\n\tlong buffer_size;\n\n\t/* sustain_framerate stuff */\n\tstruct timer_list sustain_timer;\n\tunsigned int reread_count;\n\n\t/* timeout stuff */\n\tunsigned long timeout_jiffies; /* CID_TIMEOUT; 0 means disabled */\n\tint timeout_image_io; /* CID_TIMEOUT_IMAGE_IO; next opener will\n\t\t\t       * read/write to timeout_image */\n\tu8 *timeout_image; /* copy of it will be captured when timeout passes */\n\tstruct v4l2l_buffer timeout_image_buffer;\n\tstruct timer_list timeout_timer;\n\tint timeout_happened;\n\n\t/* sync stuff */\n\tatomic_t open_count;\n\n\tint ready_for_capture; /* set to the number of writers that opened the\n                                * device and negotiated format. */\n\tint ready_for_output; /* set to true when no writer is currently attached\n\t\t\t       * this differs slightly from !ready_for_capture,\n\t\t\t       * e.g. when using fallback images */\n\tint active_readers; /* increase if any reader starts streaming */\n\tint announce_all_caps; /* set to false, if device caps (OUTPUT/CAPTURE)\n                                * should only be announced if the resp. \"ready\"\n                                * flag is set; default=TRUE */\n\n\tint min_width, max_width;\n\tint min_height, max_height;\n\n\tchar card_label[32];\n\n\twait_queue_head_t read_event;\n\tspinlock_t lock, list_lock;\n};\n\n/* types of opener shows what opener wants to do with loopback */\nenum opener_type {\n\t// clang-format off\n\tUNNEGOTIATED\t= 0,\n\tREADER\t\t= 1,\n\tWRITER\t\t= 2,\n\t// clang-format on\n};\n\n/* struct keeping state and type of opener */\nstruct v4l2_loopback_opener {\n\tenum opener_type type;\n\ts64 read_position; /* number of last processed frame + 1 or\n\t\t\t    * write_position - 1 if reader went out of sync */\n\tunsigned int reread_count;\n\tstruct v4l2_buffer *buffers;\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tint timeout_image_io;\n\n\tstruct v4l2_fh fh;\n};\n\n#define fh_to_opener(ptr) container_of((ptr), struct v4l2_loopback_opener, fh)\n\n/* this is heavily inspired by the bttv driver found in the linux kernel */\nstruct v4l2l_format {\n\tchar *name;\n\tint fourcc; /* video4linux 2 */\n\tint depth; /* bit/pixel */\n\tint flags;\n};\n/* set the v4l2l_format.flags to PLANAR for non-packed formats */\n#define FORMAT_FLAGS_PLANAR 0x01\n#define FORMAT_FLAGS_COMPRESSED 0x02\n\n#include \"v4l2loopback_formats.h\"\n\n#ifndef V4L2_TYPE_IS_CAPTURE\n#define V4L2_TYPE_IS_CAPTURE(type)                \\\n\t((type) == V4L2_BUF_TYPE_VIDEO_CAPTURE || \\\n\t (type) == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n#endif /* V4L2_TYPE_IS_CAPTURE */\n#ifndef V4L2_TYPE_IS_OUTPUT\n#define V4L2_TYPE_IS_OUTPUT(type)                \\\n\t((type) == V4L2_BUF_TYPE_VIDEO_OUTPUT || \\\n\t (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n#endif /* V4L2_TYPE_IS_OUTPUT */\n\n/* whether the format can be changed */\n/* the format is fixated if we\n   - have writers (ready_for_capture>0)\n   - and/or have readers (active_readers>0)\n*/\n#define V4L2LOOPBACK_IS_FIXED_FMT(device)                               \\\n\t(device->ready_for_capture > 0 || device->active_readers > 0 || \\\n\t device->keep_format)\n\nstatic const unsigned int FORMATS = ARRAY_SIZE(formats);\n\nstatic char *fourcc2str(unsigned int fourcc, char buf[4])\n{\n\tbuf[0] = (fourcc >> 0) & 0xFF;\n\tbuf[1] = (fourcc >> 8) & 0xFF;\n\tbuf[2] = (fourcc >> 16) & 0xFF;\n\tbuf[3] = (fourcc >> 24) & 0xFF;\n\n\treturn buf;\n}\n\nstatic const struct v4l2l_format *format_by_fourcc(int fourcc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < FORMATS; i++) {\n\t\tif (formats[i].fourcc == fourcc)\n\t\t\treturn formats + i;\n\t}\n\n\tdprintk(\"unsupported format '%c%c%c%c'\\n\", (fourcc >> 0) & 0xFF,\n\t\t(fourcc >> 8) & 0xFF, (fourcc >> 16) & 0xFF,\n\t\t(fourcc >> 24) & 0xFF);\n\treturn NULL;\n}\n\nstatic void pix_format_set_size(struct v4l2_pix_format *f,\n\t\t\t\tconst struct v4l2l_format *fmt,\n\t\t\t\tunsigned int width, unsigned int height)\n{\n\tf->width = width;\n\tf->height = height;\n\n\tif (fmt->flags & FORMAT_FLAGS_PLANAR) {\n\t\tf->bytesperline = width; /* Y plane */\n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else if (fmt->flags & FORMAT_FLAGS_COMPRESSED) {\n\t\t/* doesn't make sense for compressed formats */\n\t\tf->bytesperline = 0;\n\t\tf->sizeimage = (width * height * fmt->depth) >> 3;\n\t} else {\n\t\tf->bytesperline = (width * fmt->depth) >> 3;\n\t\tf->sizeimage = height * f->bytesperline;\n\t}\n}\n\nstatic int v4l2l_fill_format(struct v4l2_format *fmt, int capture,\n\t\t\t     const u32 minwidth, const u32 maxwidth,\n\t\t\t     const u32 minheight, const u32 maxheight)\n{\n\tu32 width = fmt->fmt.pix.width, height = fmt->fmt.pix.height;\n\tu32 pixelformat = fmt->fmt.pix.pixelformat;\n\tstruct v4l2_format fmt0 = *fmt;\n\tu32 bytesperline = 0, sizeimage = 0;\n\tif (!width)\n\t\twidth = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\tif (!height)\n\t\theight = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\tif (width < minwidth)\n\t\twidth = minwidth;\n\tif (width > maxwidth)\n\t\twidth = maxwidth;\n\tif (height < minheight)\n\t\theight = minheight;\n\tif (height > maxheight)\n\t\theight = maxheight;\n\n\t/* sets: width,height,pixelformat,bytesperline,sizeimage */\n\tif (!(V4L2_TYPE_IS_MULTIPLANAR(fmt0.type))) {\n\t\tfmt0.fmt.pix.bytesperline = 0;\n\t\tfmt0.fmt.pix.sizeimage = 0;\n\t}\n\n\tif (0) {\n\t\t;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)\n\t} else if (!v4l2_fill_pixfmt(&fmt0.fmt.pix, pixelformat, width,\n\t\t\t\t     height)) {\n\t\t;\n\t} else if (!v4l2_fill_pixfmt_mp(&fmt0.fmt.pix_mp, pixelformat, width,\n\t\t\t\t\theight)) {\n\t\t;\n#endif\n\t} else {\n\t\tconst struct v4l2l_format *format =\n\t\t\tformat_by_fourcc(pixelformat);\n\t\tif (!format)\n\t\t\treturn -EINVAL;\n\t\tpix_format_set_size(&fmt0.fmt.pix, format, width, height);\n\t\tfmt0.fmt.pix.pixelformat = format->fourcc;\n\t}\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(fmt0.type)) {\n\t\t*fmt = fmt0;\n\n\t\tif ((fmt->fmt.pix_mp.colorspace == V4L2_COLORSPACE_DEFAULT) ||\n\t\t    (fmt->fmt.pix_mp.colorspace > V4L2_COLORSPACE_DCI_P3))\n\t\t\tfmt->fmt.pix_mp.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix_mp.field)\n\t\t\tfmt->fmt.pix_mp.field = V4L2_FIELD_NONE;\n\t\tif (capture)\n\t\t\tfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\t\telse\n\t\t\tfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\t} else {\n\t\tbytesperline = fmt->fmt.pix.bytesperline;\n\t\tsizeimage = fmt->fmt.pix.sizeimage;\n\n\t\t*fmt = fmt0;\n\n\t\tif (!fmt->fmt.pix.bytesperline)\n\t\t\tfmt->fmt.pix.bytesperline = bytesperline;\n\t\tif (!fmt->fmt.pix.sizeimage)\n\t\t\tfmt->fmt.pix.sizeimage = sizeimage;\n\n\t\tif ((fmt->fmt.pix.colorspace == V4L2_COLORSPACE_DEFAULT) ||\n\t\t    (fmt->fmt.pix.colorspace > V4L2_COLORSPACE_DCI_P3))\n\t\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tif (capture)\n\t\t\tfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\telse\n\t\t\tfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\t}\n\n\treturn 0;\n}\n\n/* Checks if v4l2l_fill_format() has set a valid, fixed sizeimage val. */\nstatic bool v4l2l_pix_format_has_valid_sizeimage(struct v4l2_format *fmt)\n{\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)\n\tconst struct v4l2_format_info *info;\n\n\tinfo = v4l2_format_info(fmt->fmt.pix.pixelformat);\n\tif (info && info->mem_planes == 1)\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\nstatic int pix_format_eq(const struct v4l2_pix_format *ref,\n\t\t\t const struct v4l2_pix_format *tgt, int strict)\n{\n\t/* check if the two formats are equivalent.\n\t * ANY fields are handled gracefully\n\t */\n#define _pix_format_eq0(x)    \\\n\tif (ref->x != tgt->x) \\\n\tresult = 0\n#define _pix_format_eq1(x, def)                              \\\n\tdo {                                                 \\\n\t\tif ((def != tgt->x) && (ref->x != tgt->x)) { \\\n\t\t\tprintk(KERN_INFO #x \" failed\");      \\\n\t\t\tresult = 0;                          \\\n\t\t}                                            \\\n\t} while (0)\n\tint result = 1;\n\t_pix_format_eq0(width);\n\t_pix_format_eq0(height);\n\t_pix_format_eq0(pixelformat);\n\tif (!strict)\n\t\treturn result;\n\t_pix_format_eq1(field, V4L2_FIELD_ANY);\n\t_pix_format_eq0(bytesperline);\n\t_pix_format_eq0(sizeimage);\n\t_pix_format_eq1(colorspace, V4L2_COLORSPACE_DEFAULT);\n\treturn result;\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f);\nstatic int inner_try_setfmt(struct file *file, struct v4l2_format *fmt)\n{\n\tint capture = V4L2_TYPE_IS_CAPTURE(fmt->type);\n\tstruct v4l2_loopback_device *dev;\n\tint needschange = 0;\n\tchar buf[5];\n\tbuf[4] = 0;\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tneedschange = !(pix_format_eq(&dev->pix_format, &fmt->fmt.pix, 0));\n\tif (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t\tif (needschange) {\n\t\t\tif (dev->active_readers > 0 && capture) {\n\t\t\t\t/* cannot call fmt_cap while there are readers */\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tif (dev->ready_for_capture > 0 && !capture) {\n\t\t\t\t/* cannot call fmt_out while there are writers */\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\tif (v4l2l_fill_format(fmt, capture, dev->min_width, dev->max_width,\n\t\t\t      dev->min_height, dev->max_height) != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (1) {\n\t\tchar buf[5];\n\t\tbuf[4] = 0;\n\t\tdprintk(\"capFOURCC=%s\\n\",\n\t\t\tfourcc2str(dev->pix_format.pixelformat, buf));\n\t}\n\treturn 0;\n}\n\nstatic int set_timeperframe(struct v4l2_loopback_device *dev,\n\t\t\t    struct v4l2_fract *tpf)\n{\n\tif ((tpf->denominator < 1) || (tpf->numerator < 1)) {\n\t\treturn -EINVAL;\n\t}\n\tdev->capture_param.timeperframe = *tpf;\n\tdev->frame_jiffies = max(1UL, msecs_to_jiffies(1000) * tpf->numerator /\n\t\t\t\t\t      tpf->denominator);\n\treturn 0;\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd);\n\n/* device attributes */\n/* available via sysfs: /sys/devices/virtual/video4linux/video* */\n\nstatic ssize_t attr_show_format(struct device *cd,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\t/* gets the current format as \"FOURCC:WxH@f/s\", e.g. \"YUYV:320x240@1000/30\" */\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\tconst struct v4l2_fract *tpf;\n\tchar buf4cc[5], buf_fps[32];\n\n\tif (!dev || !V4L2LOOPBACK_IS_FIXED_FMT(dev))\n\t\treturn 0;\n\ttpf = &dev->capture_param.timeperframe;\n\n\tfourcc2str(dev->pix_format.pixelformat, buf4cc);\n\tbuf4cc[4] = 0;\n\tif (tpf->numerator == 1)\n\t\tsnprintf(buf_fps, sizeof(buf_fps), \"%d\", tpf->denominator);\n\telse\n\t\tsnprintf(buf_fps, sizeof(buf_fps), \"%d/%d\", tpf->denominator,\n\t\t\t tpf->numerator);\n\treturn sprintf(buf, \"%4s:%dx%d@%s\\n\", buf4cc, dev->pix_format.width,\n\t\t       dev->pix_format.height, buf_fps);\n}\n\nstatic ssize_t attr_store_format(struct device *cd,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t len)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\tint fps_num = 0, fps_den = 1;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t/* only fps changing is supported */\n\tif (sscanf(buf, \"@%d/%d\", &fps_num, &fps_den) > 0) {\n\t\tstruct v4l2_fract f = { .numerator = fps_den,\n\t\t\t\t\t.denominator = fps_num };\n\t\tint err = 0;\n\t\tif ((err = set_timeperframe(dev, &f)) < 0)\n\t\t\treturn err;\n\t\treturn len;\n\t}\n\treturn -EINVAL;\n}\n\nstatic DEVICE_ATTR(format, S_IRUGO | S_IWUSR, attr_show_format,\n\t\t   attr_store_format);\n\nstatic ssize_t attr_show_buffers(struct device *cd,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%d\\n\", dev->used_buffers);\n}\n\nstatic DEVICE_ATTR(buffers, S_IRUGO, attr_show_buffers, NULL);\n\nstatic ssize_t attr_show_maxopeners(struct device *cd,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%d\\n\", dev->max_openers);\n}\n\nstatic ssize_t attr_store_maxopeners(struct device *cd,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tstruct v4l2_loopback_device *dev = NULL;\n\tunsigned long curr = 0;\n\n\tif (kstrtoul(buf, 0, &curr))\n\t\treturn -EINVAL;\n\n\tdev = v4l2loopback_cd2dev(cd);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (dev->max_openers == curr)\n\t\treturn len;\n\n\tif (curr > __INT_MAX__ || dev->open_count.counter > curr) {\n\t\t/* request to limit to less openers as are currently attached to us */\n\t\treturn -EINVAL;\n\t}\n\n\tdev->max_openers = (int)curr;\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR(max_openers, S_IRUGO | S_IWUSR, attr_show_maxopeners,\n\t\t   attr_store_maxopeners);\n\nstatic ssize_t attr_show_state(struct device *cd, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (dev->ready_for_capture)\n\t\treturn sprintf(buf, \"capture\\n\");\n\tif (dev->ready_for_output)\n\t\treturn sprintf(buf, \"output\\n\");\n\n\treturn -EAGAIN;\n}\n\nstatic DEVICE_ATTR(state, S_IRUGO, attr_show_state, NULL);\n\nstatic void v4l2loopback_remove_sysfs(struct video_device *vdev)\n{\n#define V4L2_SYSFS_DESTROY(x) device_remove_file(&vdev->dev, &dev_attr_##x)\n\n\tif (vdev) {\n\t\tV4L2_SYSFS_DESTROY(format);\n\t\tV4L2_SYSFS_DESTROY(buffers);\n\t\tV4L2_SYSFS_DESTROY(max_openers);\n\t\tV4L2_SYSFS_DESTROY(state);\n\t\t/* ... */\n\t}\n}\n\nstatic void v4l2loopback_create_sysfs(struct video_device *vdev)\n{\n\tint res = 0;\n\n#define V4L2_SYSFS_CREATE(x)                                 \\\n\tres = device_create_file(&vdev->dev, &dev_attr_##x); \\\n\tif (res < 0)                                         \\\n\tbreak\n\tif (!vdev)\n\t\treturn;\n\tdo {\n\t\tV4L2_SYSFS_CREATE(format);\n\t\tV4L2_SYSFS_CREATE(buffers);\n\t\tV4L2_SYSFS_CREATE(max_openers);\n\t\tV4L2_SYSFS_CREATE(state);\n\t\t/* ... */\n\t} while (0);\n\n\tif (res >= 0)\n\t\treturn;\n\tdev_err(&vdev->dev, \"%s error: %d\\n\", __func__, res);\n}\n\n/* Event APIs */\n\n#define V4L2LOOPBACK_EVENT_BASE (V4L2_EVENT_PRIVATE_START)\n#define V4L2LOOPBACK_EVENT_OFFSET 0x08E00000\n#define V4L2_EVENT_PRI_CLIENT_USAGE \\\n\t(V4L2LOOPBACK_EVENT_BASE + V4L2LOOPBACK_EVENT_OFFSET + 1)\n\nstruct v4l2_event_client_usage {\n\t__u32 count;\n};\n\n/* global module data */\n/* find a device based on it's device-number (e.g. '3' for /dev/video3) */\nstruct v4l2loopback_lookup_cb_data {\n\tint device_nr;\n\tstruct v4l2_loopback_device *device;\n};\nstatic int v4l2loopback_lookup_cb(int id, void *ptr, void *data)\n{\n\tstruct v4l2_loopback_device *device = ptr;\n\tstruct v4l2loopback_lookup_cb_data *cbdata = data;\n\tif (cbdata && device && device->vdev) {\n\t\tif (device->vdev->num == cbdata->device_nr) {\n\t\t\tcbdata->device = device;\n\t\t\tcbdata->device_nr = id;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nstatic int v4l2loopback_lookup(int device_nr,\n\t\t\t       struct v4l2_loopback_device **device)\n{\n\tstruct v4l2loopback_lookup_cb_data data = {\n\t\t.device_nr = device_nr,\n\t\t.device = NULL,\n\t};\n\tint err = idr_for_each(&v4l2loopback_index_idr, &v4l2loopback_lookup_cb,\n\t\t\t       &data);\n\tif (1 == err) {\n\t\tif (device)\n\t\t\t*device = data.device;\n\t\treturn data.device_nr;\n\t}\n\treturn -ENODEV;\n}\nstatic struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd)\n{\n\tstruct video_device *loopdev = to_video_device(cd);\n\tstruct v4l2loopback_private *ptr =\n\t\t(struct v4l2loopback_private *)video_get_drvdata(loopdev);\n\tint nr = ptr->device_nr;\n\n\treturn idr_find(&v4l2loopback_index_idr, nr);\n}\n\nstatic struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)\n{\n\tstruct v4l2loopback_private *ptr = video_drvdata(f);\n\tint nr = ptr->device_nr;\n\n\treturn idr_find(&v4l2loopback_index_idr, nr);\n}\n\n/* forward declarations */\nstatic void client_usage_queue_event(struct video_device *vdev);\nstatic void init_buffers(struct v4l2_loopback_device *dev);\nstatic int allocate_buffers(struct v4l2_loopback_device *dev);\nstatic void free_buffers(struct v4l2_loopback_device *dev);\nstatic void try_free_buffers(struct v4l2_loopback_device *dev);\nstatic int allocate_timeout_image(struct v4l2_loopback_device *dev);\nstatic void check_timers(struct v4l2_loopback_device *dev);\nstatic const struct v4l2_file_operations v4l2_loopback_fops;\nstatic const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops;\n\n/* Queue helpers */\n/* next functions sets buffer flags and adjusts counters accordingly */\nstatic inline void set_done(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_DONE;\n}\n\nstatic inline void set_queued(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;\n\tbuffer->buffer.flags |= V4L2_BUF_FLAG_QUEUED;\n}\n\nstatic inline void unset_flags(struct v4l2l_buffer *buffer)\n{\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;\n\tbuffer->buffer.flags &= ~V4L2_BUF_FLAG_DONE;\n}\n\n/* V4L2 ioctl caps and params calls */\n/* returns device capabilities\n * called on VIDIOC_QUERYCAP\n */\nstatic int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrscpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, sizeof(cap->card), \"%s\", dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}\n\nstatic int vidioc_enum_framesizes(struct file *file, void *fh,\n\t\t\t\t  struct v4l2_frmsizeenum *argp)\n{\n\tstruct v4l2_loopback_device *dev;\n\n\t/* there can be only one... */\n\tif (argp->index)\n\t\treturn -EINVAL;\n\n\tdev = v4l2loopback_getdevice(file);\n\tif (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {\n\t\t/* format has already been negotiated\n\t\t * cannot change during runtime\n\t\t */\n\t\tif (argp->pixel_format != dev->pix_format.pixelformat)\n\t\t\treturn -EINVAL;\n\n\t\targp->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\n\t\targp->discrete.width = dev->pix_format.width;\n\t\targp->discrete.height = dev->pix_format.height;\n\t} else {\n\t\t/* if the format has not been negotiated yet, we accept anything\n\t\t */\n\t\tif (NULL == format_by_fourcc(argp->pixel_format))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->min_width == dev->max_width &&\n\t\t    dev->min_height == dev->max_height) {\n\t\t\targp->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\n\t\t\targp->discrete.width = dev->min_width;\n\t\t\targp->discrete.height = dev->min_height;\n\t\t} else {\n\t\t\targp->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\n\n\t\t\targp->stepwise.min_width = dev->min_width;\n\t\t\targp->stepwise.min_height = dev->min_height;\n\n\t\t\targp->stepwise.max_width = dev->max_width;\n\t\t\targp->stepwise.max_height = dev->max_height;\n\n\t\t\targp->stepwise.step_width = 1;\n\t\t\targp->stepwise.step_height = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* returns frameinterval (fps) for the set resolution\n * called on VIDIOC_ENUM_FRAMEINTERVALS\n */\nstatic int vidioc_enum_frameintervals(struct file *file, void *fh,\n\t\t\t\t      struct v4l2_frmivalenum *argp)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\n\t/* there can be only one... */\n\tif (argp->index)\n\t\treturn -EINVAL;\n\n\tif (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {\n\t\tif (argp->width != dev->pix_format.width ||\n\t\t    argp->height != dev->pix_format.height ||\n\t\t    argp->pixel_format != dev->pix_format.pixelformat)\n\t\t\treturn -EINVAL;\n\n\t\targp->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\t\targp->discrete = dev->capture_param.timeperframe;\n\t} else {\n\t\tif (argp->width < dev->min_width ||\n\t\t    argp->width > dev->max_width ||\n\t\t    argp->height < dev->min_height ||\n\t\t    argp->height > dev->max_height ||\n\t\t    NULL == format_by_fourcc(argp->pixel_format))\n\t\t\treturn -EINVAL;\n\n\t\targp->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;\n\t\targp->stepwise.min.numerator = 1;\n\t\targp->stepwise.min.denominator = V4L2LOOPBACK_FPS_MAX;\n\t\targp->stepwise.max.numerator = 1;\n\t\targp->stepwise.max.denominator = V4L2LOOPBACK_FPS_MIN;\n\t\targp->stepwise.step.numerator = 1;\n\t\targp->stepwise.step.denominator = 1;\n\t}\n\n\treturn 0;\n}\n\n/* ------------------ CAPTURE ----------------------- */\n\n/* returns device formats\n * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_enum_fmt_cap(struct file *file, void *fh,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_loopback_device *dev;\n\tconst struct v4l2l_format *fmt;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (f->index)\n\t\treturn -EINVAL;\n\n\tif (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {\n\t\t/* format has been fixed, so only one single format is supported */\n\t\tconst __u32 format = dev->pix_format.pixelformat;\n\n\t\tif ((fmt = format_by_fourcc(format))) {\n\t\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t\t fmt->name);\n\t\t} else {\n\t\t\tsnprintf(f->description, sizeof(f->description),\n\t\t\t\t \"[%c%c%c%c]\", (format >> 0) & 0xFF,\n\t\t\t\t (format >> 8) & 0xFF, (format >> 16) & 0xFF,\n\t\t\t\t (format >> 24) & 0xFF);\n\t\t}\n\n\t\tf->pixelformat = dev->pix_format.pixelformat;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tf->flags = 0;\n\tMARK();\n\treturn 0;\n}\n\n/* returns current video format\n * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_g_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tif (!dev->ready_for_capture && !dev->ready_for_output)\n\t\treturn -EINVAL;\n\n\tfmt->fmt.pix = dev->pix_format;\n\tMARK();\n\treturn 0;\n}\n\n/* checks if it is OK to change to format fmt;\n * actual check is done by inner_try_setfmt\n * just checking that pixelformat is OK and set other parameters, app should\n * obey this decision\n * called on VIDIOC_TRY_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_try_fmt_cap(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tint ret = 0;\n\tif (!V4L2_TYPE_IS_CAPTURE(fmt->type))\n\t\treturn -EINVAL;\n\tret = inner_try_setfmt(file, fmt);\n\tif (-EBUSY == ret)\n\t\treturn 0;\n\treturn ret;\n}\n\n/* sets new output format, if possible\n * actually format is set  by input and we even do not check it, just return\n * current one, but it is possible to set subregions of input TODO(vasaka)\n * called on VIDIOC_S_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_CAPTURE\n */\nstatic int vidioc_s_fmt_cap(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tint ret;\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!V4L2_TYPE_IS_CAPTURE(fmt->type))\n\t\treturn -EINVAL;\n\tret = inner_try_setfmt(file, fmt);\n\tif (!ret) {\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn ret;\n}\n\n/* ------------------ OUTPUT ----------------------- */\n\n/* returns device formats;\n * LATER: allow all formats\n * called on VIDIOC_ENUM_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_enum_fmt_out(struct file *file, void *fh,\n\t\t\t       struct v4l2_fmtdesc *f)\n{\n\tstruct v4l2_loopback_device *dev;\n\tconst struct v4l2l_format *fmt;\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (V4L2LOOPBACK_IS_FIXED_FMT(dev)) {\n\t\t/* format has been fixed, so only one single format is supported */\n\t\tconst __u32 format = dev->pix_format.pixelformat;\n\n\t\tif (f->index)\n\t\t\treturn -EINVAL;\n\n\t\tif ((fmt = format_by_fourcc(format))) {\n\t\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t\t fmt->name);\n\t\t} else {\n\t\t\tsnprintf(f->description, sizeof(f->description),\n\t\t\t\t \"[%c%c%c%c]\", (format >> 0) & 0xFF,\n\t\t\t\t (format >> 8) & 0xFF, (format >> 16) & 0xFF,\n\t\t\t\t (format >> 24) & 0xFF);\n\t\t}\n\n\t\tf->pixelformat = dev->pix_format.pixelformat;\n\t} else {\n\t\t/* fill in a dummy format */\n\t\t/* coverity[unsigned_compare] */\n\t\tif (f->index < 0 || f->index >= FORMATS)\n\t\t\treturn -EINVAL;\n\n\t\tfmt = &formats[f->index];\n\n\t\tf->pixelformat = fmt->fourcc;\n\t\tsnprintf(f->description, sizeof(f->description), \"%s\",\n\t\t\t fmt->name);\n\t}\n\tf->flags = 0;\n\n\treturn 0;\n}\n\n/* returns current video format fmt */\n/* NOTE: this is called from the producer\n * so if format has not been negotiated yet,\n * it should return ALL of available formats,\n * called on VIDIOC_G_FMT, with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_g_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\t/*\n\t * LATER: this should return the currently valid format\n\t * gstreamer doesn't like it, if this returns -EINVAL, as it\n\t * then concludes that there is _no_ valid format\n\t * CHECK whether this assumption is wrong,\n\t * or whether we have to always provide a valid format\n\t */\n\n\tfmt->fmt.pix = dev->pix_format;\n\treturn 0;\n}\n\n/* checks if it is OK to change to format fmt;\n * if format is negotiated do not change it\n * called on VIDIOC_TRY_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_try_fmt_out(struct file *file, void *priv,\n\t\t\t      struct v4l2_format *fmt)\n{\n\tint ret = 0;\n\tif (!V4L2_TYPE_IS_OUTPUT(fmt->type))\n\t\treturn -EINVAL;\n\tret = inner_try_setfmt(file, fmt);\n\tif (-EBUSY == ret)\n\t\treturn 0;\n\treturn ret;\n}\n\n/* sets new output format, if possible;\n * allocate data here because we do not know if it will be streaming or\n * read/write IO\n * called on VIDIOC_S_FMT with v4l2_buf_type set to V4L2_BUF_TYPE_VIDEO_OUTPUT\n */\nstatic int vidioc_s_fmt_out(struct file *file, void *priv,\n\t\t\t    struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tint ret;\n\tchar buf[5];\n\tbuf[4] = 0;\n\tif (!V4L2_TYPE_IS_OUTPUT(fmt->type))\n\t\treturn -EINVAL;\n\tdev = v4l2loopback_getdevice(file);\n\n\tret = inner_try_setfmt(file, fmt);\n\tif (!ret) {\n\t\tdev->pix_format = fmt->fmt.pix;\n\t\tdev->pix_format_has_valid_sizeimage =\n\t\t\tv4l2l_pix_format_has_valid_sizeimage(fmt);\n\t\tdprintk(\"s_fmt_out(%d) %d...%d\\n\", ret, dev->ready_for_capture,\n\t\t\tdev->pix_format.sizeimage);\n\t\tdprintk(\"outFOURCC=%s\\n\",\n\t\t\tfourcc2str(dev->pix_format.pixelformat, buf));\n\n\t\tif (!dev->ready_for_capture) {\n\t\t\tdev->buffer_size =\n\t\t\t\tPAGE_ALIGN(dev->pix_format.sizeimage);\n\t\t\t// JMZ: TODO get rid of the next line\n\t\t\tfmt->fmt.pix.sizeimage = dev->buffer_size;\n\t\t\tret = allocate_buffers(dev);\n\t\t}\n\t}\n\treturn ret;\n}\n\n// #define V4L2L_OVERLAY\n#ifdef V4L2L_OVERLAY\n/* ------------------ OVERLAY ----------------------- */\n/* currently unsupported */\n/* GSTreamer's v4l2sink is buggy, as it requires the overlay to work\n * while it should only require it, if overlay is requested\n * once the gstreamer element is fixed, remove the overlay dummies\n */\n#warning OVERLAY dummies\nstatic int vidioc_g_fmt_overlay(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn 0;\n}\n\nstatic int vidioc_s_fmt_overlay(struct file *file, void *priv,\n\t\t\t\tstruct v4l2_format *fmt)\n{\n\treturn 0;\n}\n#endif /* V4L2L_OVERLAY */\n\n/* ------------------ PARAMs ----------------------- */\n\n/* get some data flow parameters, only capability, fps and readbuffers has\n * effect on this driver\n * called on VIDIOC_G_PARM\n */\nstatic int vidioc_g_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\t/* do not care about type of opener, hope these enums would always be\n\t * compatible */\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tparm->parm.capture = dev->capture_param;\n\treturn 0;\n}\n\n/* get some data flow parameters, only capability, fps and readbuffers has\n * effect on this driver\n * called on VIDIOC_S_PARM\n */\nstatic int vidioc_s_parm(struct file *file, void *priv,\n\t\t\t struct v4l2_streamparm *parm)\n{\n\tstruct v4l2_loopback_device *dev;\n\tint err = 0;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tdprintk(\"vidioc_s_parm called frate=%d/%d\\n\",\n\t\tparm->parm.capture.timeperframe.numerator,\n\t\tparm->parm.capture.timeperframe.denominator);\n\n\tswitch (parm->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif ((err = set_timeperframe(\n\t\t\t     dev, &parm->parm.capture.timeperframe)) < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif ((err = set_timeperframe(\n\t\t\t     dev, &parm->parm.capture.timeperframe)) < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tparm->parm.capture = dev->capture_param;\n\treturn 0;\n}\n\n#ifdef V4L2LOOPBACK_WITH_STD\n/* sets a tv standard, actually we do not need to handle this any special way\n * added to support effecttv\n * called on VIDIOC_S_STD\n */\nstatic int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\n\t/* we support everything in V4L2_STD_ALL, but not more... */\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* gets a fake video standard\n * called on VIDIOC_G_STD\n */\nstatic int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tif (norm)\n\t\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n/* gets a fake video standard\n * called on VIDIOC_QUERYSTD\n */\nstatic int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)\n{\n\tif (norm)\n\t\t*norm = V4L2_STD_ALL;\n\treturn 0;\n}\n#endif /* V4L2LOOPBACK_WITH_STD */\n\nstatic int v4l2loopback_set_ctrl(struct v4l2_loopback_device *dev, u32 id,\n\t\t\t\t s64 val)\n{\n\tswitch (id) {\n\tcase CID_KEEP_FORMAT:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tdev->keep_format = val;\n\t\ttry_free_buffers(\n\t\t\tdev); /* will only free buffers if !keep_format */\n\t\tbreak;\n\tcase CID_SUSTAIN_FRAMERATE:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&dev->lock);\n\t\tdev->sustain_framerate = val;\n\t\tcheck_timers(dev);\n\t\tspin_unlock_bh(&dev->lock);\n\t\tbreak;\n\tcase CID_TIMEOUT:\n\t\tif (val < 0 || val > MAX_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_bh(&dev->lock);\n\t\tdev->timeout_jiffies = msecs_to_jiffies(val);\n\t\tcheck_timers(dev);\n\t\tspin_unlock_bh(&dev->lock);\n\t\tallocate_timeout_image(dev);\n\t\tbreak;\n\tcase CID_TIMEOUT_IMAGE_IO:\n\t\tdev->timeout_image_io = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_loopback_device *dev = container_of(\n\t\tctrl->handler, struct v4l2_loopback_device, ctrl_handler);\n\treturn v4l2loopback_set_ctrl(dev, ctrl->id, ctrl->val);\n}\n\n/* returns set of device outputs, in our case there is only one\n * called on VIDIOC_ENUMOUTPUT\n */\nstatic int vidioc_enum_output(struct file *file, void *fh,\n\t\t\t      struct v4l2_output *outp)\n{\n\t__u32 index = outp->index;\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tMARK();\n\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\n\tif (0 != index)\n\t\treturn -EINVAL;\n\n\t/* clear all data (including the reserved fields) */\n\tmemset(outp, 0, sizeof(*outp));\n\n\toutp->index = index;\n\tstrscpy(outp->name, \"loopback in\", sizeof(outp->name));\n\toutp->type = V4L2_OUTPUT_TYPE_ANALOG;\n\toutp->audioset = 0;\n\toutp->modulator = 0;\n#ifdef V4L2LOOPBACK_WITH_STD\n\toutp->std = V4L2_STD_ALL;\n#ifdef V4L2_OUT_CAP_STD\n\toutp->capabilities |= V4L2_OUT_CAP_STD;\n#endif /*  V4L2_OUT_CAP_STD */\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\treturn 0;\n}\n\n/* which output is currently active,\n * called on VIDIOC_G_OUTPUT\n */\nstatic int vidioc_g_output(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\tif (i)\n\t\t*i = 0;\n\treturn 0;\n}\n\n/* set output, can make sense if we have more than one video src,\n * called on VIDIOC_S_OUTPUT\n */\nstatic int vidioc_s_output(struct file *file, void *fh, unsigned int i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_output)\n\t\treturn -ENOTTY;\n\n\tif (i)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* returns set of device inputs, in our case there is only one,\n * but later I may add more\n * called on VIDIOC_ENUMINPUT\n */\nstatic int vidioc_enum_input(struct file *file, void *fh,\n\t\t\t     struct v4l2_input *inp)\n{\n\tstruct v4l2_loopback_device *dev;\n\t__u32 index = inp->index;\n\tMARK();\n\n\tif (0 != index)\n\t\treturn -EINVAL;\n\n\t/* clear all data (including the reserved fields) */\n\tmemset(inp, 0, sizeof(*inp));\n\n\tinp->index = index;\n\tstrscpy(inp->name, \"loopback\", sizeof(inp->name));\n\tinp->type = V4L2_INPUT_TYPE_CAMERA;\n\tinp->audioset = 0;\n\tinp->tuner = 0;\n\tinp->status = 0;\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tinp->std = V4L2_STD_ALL;\n#ifdef V4L2_IN_CAP_STD\n\tinp->capabilities |= V4L2_IN_CAP_STD;\n#endif\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\tdev = v4l2loopback_getdevice(file);\n\tif (!dev->ready_for_capture) {\n\t\tinp->status |= V4L2_IN_ST_NO_SIGNAL;\n\t}\n\n\treturn 0;\n}\n\n/* which input is currently active,\n * called on VIDIOC_G_INPUT\n */\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_capture)\n\t\treturn -ENOTTY;\n\tif (i)\n\t\t*i = 0;\n\treturn 0;\n}\n\n/* set input, can make sense if we have more than one video src,\n * called on VIDIOC_S_INPUT\n */\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int i)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tif (!dev->announce_all_caps && !dev->ready_for_capture)\n\t\treturn -ENOTTY;\n\tif (i == 0)\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\n/* --------------- V4L2 ioctl buffer related calls ----------------- */\n\n/* negotiate buffer type\n * only mmap streaming supported\n * called on VIDIOC_REQBUFS\n */\nstatic int vidioc_reqbufs(struct file *file, void *fh,\n\t\t\t  struct v4l2_requestbuffers *b)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tint i;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tdprintk(\"reqbufs: %d\\t%d=%d\\n\", b->memory, b->count,\n\t\tdev->buffers_number);\n\n\tif (opener->timeout_image_io) {\n\t\tdev->timeout_image_io = 0;\n\t\tif (b->memory != V4L2_MEMORY_MMAP)\n\t\t\treturn -EINVAL;\n\t\tb->count = 2;\n\t\treturn 0;\n\t}\n\n\tif (V4L2_TYPE_IS_OUTPUT(b->type) && (!dev->ready_for_output)) {\n\t\treturn -EBUSY;\n\t}\n\n\tinit_buffers(dev);\n\tswitch (b->memory) {\n\tcase V4L2_MEMORY_MMAP:\n\t\t/* do nothing here, buffers are always allocated */\n\t\tif (b->count < 1 || dev->buffers_number < 1)\n\t\t\treturn 0;\n\n\t\tif (b->count > dev->buffers_number)\n\t\t\tb->count = dev->buffers_number;\n\n\t\t/* make sure that outbufs_list contains buffers from 0 to used_buffers-1\n\t\t * actually, it will have been already populated via v4l2_loopback_init()\n\t\t * at this point */\n\t\tif (list_empty(&dev->outbufs_list)) {\n\t\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t\t      &dev->outbufs_list);\n\t\t}\n\n\t\t/* also, if dev->used_buffers is going to be decreased, we should remove\n\t\t * out-of-range buffers from outbufs_list, and fix bufpos2index mapping */\n\t\tif (b->count < dev->used_buffers) {\n\t\t\tstruct v4l2l_buffer *pos, *n;\n\n\t\t\tlist_for_each_entry_safe(pos, n, &dev->outbufs_list,\n\t\t\t\t\t\t list_head) {\n\t\t\t\tif (pos->buffer.index >= b->count)\n\t\t\t\t\tlist_del(&pos->list_head);\n\t\t\t}\n\n\t\t\t/* after we update dev->used_buffers, buffers in outbufs_list will\n\t\t\t * correspond to dev->write_position + [0;b->count-1] range */\n\t\t\ti = v4l2l_mod64(dev->write_position, b->count);\n\t\t\tlist_for_each_entry(pos, &dev->outbufs_list,\n\t\t\t\t\t    list_head) {\n\t\t\t\tdev->bufpos2index[i % b->count] =\n\t\t\t\t\tpos->buffer.index;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\n\t\topener->buffers_number = b->count;\n\t\tif (opener->buffers_number < dev->used_buffers)\n\t\t\tdev->used_buffers = opener->buffers_number;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* returns buffer asked for;\n * give app as many buffers as it wants, if it less than MAX,\n * but map them in our inner buffers\n * called on VIDIOC_QUERYBUF\n */\nstatic int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tenum v4l2_buf_type type;\n\tint index;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\n\tMARK();\n\n\ttype = b->type;\n\tindex = b->index;\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tif ((b->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\n\t    (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)) {\n\t\treturn -EINVAL;\n\t}\n\tif (b->index > max_buffers)\n\t\treturn -EINVAL;\n\n\tif (opener->timeout_image_io)\n\t\t*b = dev->timeout_image_buffer.buffer;\n\telse\n\t\t*b = dev->buffers[b->index % dev->used_buffers].buffer;\n\n\tb->type = type;\n\tb->index = index;\n\tdprintkrw(\"buffer type: %d (of %d with size=%ld)\\n\", b->memory,\n\t\t  dev->buffers_number, dev->buffer_size);\n\n\t/* Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'\n\t * https://github.com/umlaeute/v4l2loopback/issues/60 */\n\tb->flags &= ~V4L2_BUF_FLAG_DONE;\n\tb->flags |= V4L2_BUF_FLAG_QUEUED;\n\n\treturn 0;\n}\n\nstatic void buffer_written(struct v4l2_loopback_device *dev,\n\t\t\t   struct v4l2l_buffer *buf)\n{\n\tdel_timer_sync(&dev->sustain_timer);\n\tdel_timer_sync(&dev->timeout_timer);\n\n\tspin_lock_bh(&dev->list_lock);\n\tlist_move_tail(&buf->list_head, &dev->outbufs_list);\n\tspin_unlock_bh(&dev->list_lock);\n\n\tspin_lock_bh(&dev->lock);\n\tdev->bufpos2index[v4l2l_mod64(dev->write_position, dev->used_buffers)] =\n\t\tbuf->buffer.index;\n\t++dev->write_position;\n\tdev->reread_count = 0;\n\n\tcheck_timers(dev);\n\tspin_unlock_bh(&dev->lock);\n}\n\n/* put buffer to queue\n * called on VIDIOC_QBUF\n */\nstatic int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2l_buffer *b;\n\tint index;\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tif (buf->index > max_buffers)\n\t\treturn -EINVAL;\n\tif (opener->timeout_image_io)\n\t\treturn 0;\n\n\tindex = buf->index % dev->used_buffers;\n\tb = &dev->buffers[index];\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tdprintkrw(\n\t\t\t\"qbuf(CAPTURE)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\\n\",\n\t\t\tindex, buf->index, buf, buf->type, buf->bytesused,\n\t\t\tbuf->length, buf->flags, buf->field,\n\t\t\t(long long)buf->timestamp.tv_sec,\n\t\t\t(long int)buf->timestamp.tv_usec, buf->sequence);\n\t\tset_queued(b);\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tdprintkrw(\n\t\t\t\"qbuf(OUTPUT)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\\n\",\n\t\t\tindex, buf->index, buf, buf->type, buf->bytesused,\n\t\t\tbuf->length, buf->flags, buf->field,\n\t\t\t(long long)buf->timestamp.tv_sec,\n\t\t\t(long int)buf->timestamp.tv_usec, buf->sequence);\n\t\tif ((!(b->buffer.flags & V4L2_BUF_FLAG_TIMESTAMP_COPY)) &&\n\t\t    (buf->timestamp.tv_sec == 0 && buf->timestamp.tv_usec == 0))\n\t\t\tv4l2l_get_timestamp(&b->buffer);\n\t\telse {\n\t\t\tb->buffer.timestamp = buf->timestamp;\n\t\t\tb->buffer.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;\n\t\t}\n\t\tif (dev->pix_format_has_valid_sizeimage) {\n\t\t\tif (buf->bytesused >= dev->pix_format.sizeimage) {\n\t\t\t\tb->buffer.bytesused = dev->pix_format.sizeimage;\n\t\t\t} else {\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)\n\t\t\t\tdev_warn_ratelimited(\n\t\t\t\t\t&dev->vdev->dev,\n#else\n\t\t\t\tdprintkrw(\n#endif\n\t\t\t\t\t\"warning queued output buffer bytesused too small %d < %d\\n\",\n\t\t\t\t\tbuf->bytesused,\n\t\t\t\t\tdev->pix_format.sizeimage);\n\t\t\t\tb->buffer.bytesused = buf->bytesused;\n\t\t\t}\n\t\t} else {\n\t\t\tb->buffer.bytesused = buf->bytesused;\n\t\t}\n\n\t\tset_done(b);\n\t\tbuffer_written(dev, b);\n\n\t\t/* Hopefully fix 'DQBUF return bad index if queue bigger then 2 for capture'\n\t\t * https://github.com/umlaeute/v4l2loopback/issues/60 */\n\t\tbuf->flags &= ~V4L2_BUF_FLAG_DONE;\n\t\tbuf->flags |= V4L2_BUF_FLAG_QUEUED;\n\n\t\twake_up_all(&dev->read_event);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int can_read(struct v4l2_loopback_device *dev,\n\t\t    struct v4l2_loopback_opener *opener)\n{\n\tint ret;\n\n\tspin_lock_bh(&dev->lock);\n\tcheck_timers(dev);\n\tret = dev->write_position > opener->read_position ||\n\t      dev->reread_count > opener->reread_count || dev->timeout_happened;\n\tspin_unlock_bh(&dev->lock);\n\treturn ret;\n}\n\nstatic int get_capture_buffer(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);\n\tint pos, ret;\n\tint timeout_happened;\n\n\tif ((file->f_flags & O_NONBLOCK) &&\n\t    (dev->write_position <= opener->read_position &&\n\t     dev->reread_count <= opener->reread_count &&\n\t     !dev->timeout_happened))\n\t\treturn -EAGAIN;\n\twait_event_interruptible(dev->read_event, can_read(dev, opener));\n\n\tspin_lock_bh(&dev->lock);\n\tif (dev->write_position == opener->read_position) {\n\t\tif (dev->reread_count > opener->reread_count + 2)\n\t\t\topener->reread_count = dev->reread_count - 1;\n\t\t++opener->reread_count;\n\t\tpos = v4l2l_mod64(opener->read_position + dev->used_buffers - 1,\n\t\t\t\t  dev->used_buffers);\n\t} else {\n\t\topener->reread_count = 0;\n\t\tif (dev->write_position >\n\t\t    opener->read_position + dev->used_buffers)\n\t\t\topener->read_position = dev->write_position - 1;\n\t\tpos = v4l2l_mod64(opener->read_position, dev->used_buffers);\n\t\t++opener->read_position;\n\t}\n\ttimeout_happened = dev->timeout_happened;\n\tdev->timeout_happened = 0;\n\tspin_unlock_bh(&dev->lock);\n\n\tret = dev->bufpos2index[pos];\n\tif (timeout_happened) {\n\t\tif (ret < 0) {\n\t\t\tdprintk(\"trying to return not mapped buf[%d]\\n\", ret);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t/* although allocated on-demand, timeout_image is freed only\n\t\t * in free_buffers(), so we don't need to worry about it being\n\t\t * deallocated suddenly */\n\t\tmemcpy(dev->image + dev->buffers[ret].buffer.m.offset,\n\t\t       dev->timeout_image, dev->buffer_size);\n\t}\n\treturn ret;\n}\n\n/* put buffer to dequeue\n * called on VIDIOC_DQBUF\n */\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tint index;\n\tstruct v4l2l_buffer *b;\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\tif (opener->timeout_image_io) {\n\t\t*buf = dev->timeout_image_buffer.buffer;\n\t\treturn 0;\n\t}\n\n\tswitch (buf->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tindex = get_capture_buffer(file);\n\t\tif (index < 0)\n\t\t\treturn index;\n\t\tdprintkrw(\"capture DQBUF pos: %lld index: %d\\n\",\n\t\t\t  (long long)(opener->read_position - 1), index);\n\t\tif (!(dev->buffers[index].buffer.flags &\n\t\t      V4L2_BUF_FLAG_MAPPED)) {\n\t\t\tdprintk(\"trying to return not mapped buf[%d]\\n\", index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tunset_flags(&dev->buffers[index]);\n\t\t*buf = dev->buffers[index].buffer;\n\t\tdprintkrw(\n\t\t\t\"dqbuf(CAPTURE)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\\n\",\n\t\t\tindex, buf->index, buf, buf->type, buf->bytesused,\n\t\t\tbuf->length, buf->flags, buf->field,\n\t\t\t(long long)buf->timestamp.tv_sec,\n\t\t\t(long int)buf->timestamp.tv_usec, buf->sequence);\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tspin_lock_bh(&dev->list_lock);\n\n\t\tb = list_entry(dev->outbufs_list.prev, struct v4l2l_buffer,\n\t\t\t       list_head);\n\t\tlist_move_tail(&b->list_head, &dev->outbufs_list);\n\n\t\tspin_unlock_bh(&dev->list_lock);\n\t\tdprintkrw(\"output DQBUF index: %d\\n\", b->buffer.index);\n\t\tunset_flags(b);\n\t\t*buf = b->buffer;\n\t\tbuf->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\t\tdprintkrw(\n\t\t\t\"dqbuf(OUTPUT)#%d: buffer#%d @ %p type=%d bytesused=%d length=%d flags=%x field=%d timestamp=%lld.%06ld sequence=%d\\n\",\n\t\t\tindex, buf->index, buf, buf->type, buf->bytesused,\n\t\t\tbuf->length, buf->flags, buf->field,\n\t\t\t(long long)buf->timestamp.tv_sec,\n\t\t\t(long int)buf->timestamp.tv_usec, buf->sequence);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* ------------- STREAMING ------------------- */\n\n/* start streaming\n * called on VIDIOC_STREAMON\n */\nstatic int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (!dev->ready_for_capture) {\n\t\t\tint ret = allocate_buffers(dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\topener->type = WRITER;\n\t\tdev->ready_for_output = 0;\n\t\tdev->ready_for_capture++;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (!dev->ready_for_capture)\n\t\t\treturn -EIO;\n\t\tif (dev->active_readers > 0)\n\t\t\treturn -EBUSY;\n\t\topener->type = READER;\n\t\tdev->active_readers++;\n\t\tclient_usage_queue_event(dev->vdev);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n/* stop streaming\n * called on VIDIOC_STREAMOFF\n */\nstatic int vidioc_streamoff(struct file *file, void *fh,\n\t\t\t    enum v4l2_buf_type type)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\n\tMARK();\n\tdprintk(\"%d\\n\", type);\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(fh);\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (dev->ready_for_capture > 0)\n\t\t\tdev->ready_for_capture--;\n\t\treturn 0;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (opener->type == READER) {\n\t\t\topener->type = 0;\n\t\t\tdev->active_readers--;\n\t\t\tclient_usage_queue_event(dev->vdev);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_VIDEO_V4L1_COMPAT\nstatic int vidiocgmbuf(struct file *file, void *fh, struct video_mbuf *p)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\tp->frames = dev->buffers_number;\n\tp->offsets[0] = 0;\n\tp->offsets[1] = 0;\n\tp->size = dev->buffer_size;\n\treturn 0;\n}\n#endif\n\nstatic void client_usage_queue_event(struct video_device *vdev)\n{\n\tstruct v4l2_event ev;\n\tstruct v4l2_loopback_device *dev;\n\n\tdev = container_of(vdev->v4l2_dev, struct v4l2_loopback_device,\n\t\t\t   v4l2_dev);\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = V4L2_EVENT_PRI_CLIENT_USAGE;\n\t((struct v4l2_event_client_usage *)&ev.u)->count = dev->active_readers;\n\n\tv4l2_event_queue(vdev, &ev);\n}\n\nstatic int client_usage_ops_add(struct v4l2_subscribed_event *sev,\n\t\t\t\tunsigned elems)\n{\n\tif (!(sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL))\n\t\treturn 0;\n\n\tclient_usage_queue_event(sev->fh->vdev);\n\treturn 0;\n}\n\nstatic void client_usage_ops_replace(struct v4l2_event *old,\n\t\t\t\t     const struct v4l2_event *new)\n{\n\t*((struct v4l2_event_client_usage *)&old->u) =\n\t\t*((struct v4l2_event_client_usage *)&new->u);\n}\n\nstatic void client_usage_ops_merge(const struct v4l2_event *old,\n\t\t\t\t   struct v4l2_event *new)\n{\n\t*((struct v4l2_event_client_usage *)&new->u) =\n\t\t*((struct v4l2_event_client_usage *)&old->u);\n}\n\nconst struct v4l2_subscribed_event_ops client_usage_ops = {\n\t.add = client_usage_ops_add,\n\t.replace = client_usage_ops_replace,\n\t.merge = client_usage_ops_merge,\n};\n\nstatic int vidioc_subscribe_event(struct v4l2_fh *fh,\n\t\t\t\t  const struct v4l2_event_subscription *sub)\n{\n\tswitch (sub->type) {\n\tcase V4L2_EVENT_CTRL:\n\t\treturn v4l2_ctrl_subscribe_event(fh, sub);\n\tcase V4L2_EVENT_PRI_CLIENT_USAGE:\n\t\treturn v4l2_event_subscribe(fh, sub, 0, &client_usage_ops);\n\t}\n\n\treturn -EINVAL;\n}\n\n/* file operations */\nstatic void vm_open(struct vm_area_struct *vma)\n{\n\tstruct v4l2l_buffer *buf;\n\tMARK();\n\n\tbuf = vma->vm_private_data;\n\tbuf->use_count++;\n\n\tbuf->buffer.flags |= V4L2_BUF_FLAG_MAPPED;\n}\n\nstatic void vm_close(struct vm_area_struct *vma)\n{\n\tstruct v4l2l_buffer *buf;\n\tMARK();\n\n\tbuf = vma->vm_private_data;\n\tbuf->use_count--;\n\n\tif (buf->use_count <= 0)\n\t\tbuf->buffer.flags &= ~V4L2_BUF_FLAG_MAPPED;\n}\n\nstatic struct vm_operations_struct vm_ops = {\n\t.open = vm_open,\n\t.close = vm_close,\n};\n\nstatic int v4l2_loopback_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tu8 *addr;\n\tunsigned long start;\n\tunsigned long size;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2l_buffer *buffer = NULL;\n\tMARK();\n\n\tstart = (unsigned long)vma->vm_start;\n\tsize = (unsigned long)(vma->vm_end - vma->vm_start);\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(file->private_data);\n\n\tif (size > dev->buffer_size) {\n\t\tdprintk(\"userspace tries to mmap too much, fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (opener->timeout_image_io) {\n\t\t/* we are going to map the timeout_image_buffer */\n\t\tif ((vma->vm_pgoff << PAGE_SHIFT) !=\n\t\t    dev->buffer_size * MAX_BUFFERS) {\n\t\t\tdprintk(\"invalid mmap offset for timeout_image_io mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if ((vma->vm_pgoff << PAGE_SHIFT) >\n\t\t   dev->buffer_size * (dev->buffers_number - 1)) {\n\t\tdprintk(\"userspace tries to mmap too far, fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXXXXXME: allocation should not happen here! */\n\tif (NULL == dev->image)\n\t\tif (allocate_buffers(dev) < 0)\n\t\t\treturn -EINVAL;\n\n\tif (opener->timeout_image_io) {\n\t\tbuffer = &dev->timeout_image_buffer;\n\t\taddr = dev->timeout_image;\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < dev->buffers_number; ++i) {\n\t\t\tbuffer = &dev->buffers[i];\n\t\t\tif ((buffer->buffer.m.offset >> PAGE_SHIFT) ==\n\t\t\t    vma->vm_pgoff)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= dev->buffers_number)\n\t\t\treturn -EINVAL;\n\n\t\taddr = dev->image + (vma->vm_pgoff << PAGE_SHIFT);\n\t}\n\n\twhile (size > 0) {\n\t\tstruct page *page;\n\n\t\tpage = vmalloc_to_page(addr);\n\n\t\tif (vm_insert_page(vma, start, page) < 0)\n\t\t\treturn -EAGAIN;\n\n\t\tstart += PAGE_SIZE;\n\t\taddr += PAGE_SIZE;\n\t\tsize -= PAGE_SIZE;\n\t}\n\n\tvma->vm_ops = &vm_ops;\n\tvma->vm_private_data = buffer;\n\n\tvm_open(vma);\n\n\tMARK();\n\treturn 0;\n}\n\nstatic unsigned int v4l2_loopback_poll(struct file *file,\n\t\t\t\t       struct poll_table_struct *pts)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\t__poll_t req_events = poll_requested_events(pts);\n\tint ret_mask = 0;\n\tMARK();\n\n\topener = fh_to_opener(file->private_data);\n\tdev = v4l2loopback_getdevice(file);\n\n\t/* call poll_wait in first call, regardless, to ensure that the wait-queue\n\t * is not null */\n\tpoll_wait(file, &dev->read_event, pts);\n\tpoll_wait(file, &opener->fh.wait, pts);\n\n\tif (req_events & POLLPRI) {\n\t\tif (v4l2_event_pending(&opener->fh)) {\n\t\t\tret_mask |= POLLPRI;\n\t\t\tif (!(req_events & DEFAULT_POLLMASK))\n\t\t\t\treturn ret_mask;\n\t\t}\n\t}\n\n\tswitch (opener->type) {\n\tcase WRITER:\n\t\tret_mask |= POLLOUT | POLLWRNORM;\n\t\tbreak;\n\tcase READER:\n\t\tif (can_read(dev, opener))\n\t\t\tret_mask |= POLLIN | POLLRDNORM;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tMARK();\n\treturn ret_mask;\n}\n\n/* do not want to limit device opens, it can be as many readers as user want,\n * writers are limited by means of setting writer field */\nstatic int v4l2_loopback_open(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_opener *opener;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->open_count.counter >= dev->max_openers)\n\t\treturn -EBUSY;\n\t/* kfree on close */\n\topener = kzalloc(sizeof(*opener), GFP_KERNEL);\n\tif (opener == NULL)\n\t\treturn -ENOMEM;\n\n\tatomic_inc(&dev->open_count);\n\n\topener->timeout_image_io = dev->timeout_image_io;\n\tif (opener->timeout_image_io) {\n\t\tint r = allocate_timeout_image(dev);\n\n\t\tif (r < 0) {\n\t\t\tdprintk(\"timeout image allocation failed\\n\");\n\n\t\t\tatomic_dec(&dev->open_count);\n\n\t\t\tkfree(opener);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tv4l2_fh_init(&opener->fh, video_devdata(file));\n\tfile->private_data = &opener->fh;\n\n\tv4l2_fh_add(&opener->fh);\n\tdprintk(\"opened dev:%p with image:%p\\n\", dev, dev ? dev->image : NULL);\n\tMARK();\n\treturn 0;\n}\n\nstatic int v4l2_loopback_close(struct file *file)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\tint is_writer = 0, is_reader = 0;\n\tMARK();\n\n\topener = fh_to_opener(file->private_data);\n\tdev = v4l2loopback_getdevice(file);\n\n\tif (WRITER == opener->type)\n\t\tis_writer = 1;\n\tif (READER == opener->type)\n\t\tis_reader = 1;\n\n\tatomic_dec(&dev->open_count);\n\tif (dev->open_count.counter == 0) {\n\t\tdel_timer_sync(&dev->sustain_timer);\n\t\tdel_timer_sync(&dev->timeout_timer);\n\t}\n\ttry_free_buffers(dev);\n\n\tv4l2_fh_del(&opener->fh);\n\tv4l2_fh_exit(&opener->fh);\n\n\tkfree(opener);\n\tif (is_writer)\n\t\tdev->ready_for_output = 1;\n\tif (is_reader) {\n\t\tdev->active_readers--;\n\t\tclient_usage_queue_event(dev->vdev);\n\t}\n\tMARK();\n\treturn 0;\n}\n\nstatic ssize_t v4l2_loopback_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tint read_index;\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_buffer *b;\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\n\tread_index = get_capture_buffer(file);\n\tif (read_index < 0)\n\t\treturn read_index;\n\tif (count > dev->buffer_size)\n\t\tcount = dev->buffer_size;\n\tb = &dev->buffers[read_index].buffer;\n\tif (count > b->bytesused)\n\t\tcount = b->bytesused;\n\tif (copy_to_user((void *)buf, (void *)(dev->image + b->m.offset),\n\t\t\t count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2-loopback: failed copy_to_user() in read buf\\n\");\n\t\treturn -EFAULT;\n\t}\n\tdprintkrw(\"leave v4l2_loopback_read()\\n\");\n\treturn count;\n}\n\nstatic ssize_t v4l2_loopback_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct v4l2_loopback_opener *opener;\n\tstruct v4l2_loopback_device *dev;\n\tint write_index;\n\tstruct v4l2_buffer *b;\n\tint err = 0;\n\n\tMARK();\n\n\tdev = v4l2loopback_getdevice(file);\n\topener = fh_to_opener(file->private_data);\n\n\tif (UNNEGOTIATED == opener->type) {\n\t\tspin_lock(&dev->lock);\n\n\t\tif (dev->ready_for_output) {\n\t\t\terr = vidioc_streamon(file, file->private_data,\n\t\t\t\t\t      V4L2_BUF_TYPE_VIDEO_OUTPUT);\n\t\t}\n\n\t\tspin_unlock(&dev->lock);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (WRITER != opener->type)\n\t\treturn -EINVAL;\n\n\tif (!dev->ready_for_capture) {\n\t\tint ret = allocate_buffers(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdev->ready_for_capture = 1;\n\t}\n\tdprintkrw(\"v4l2_loopback_write() trying to write %zu bytes\\n\", count);\n\tif (count > dev->buffer_size)\n\t\tcount = dev->buffer_size;\n\n\twrite_index = v4l2l_mod64(dev->write_position, dev->used_buffers);\n\tb = &dev->buffers[write_index].buffer;\n\n\tif (copy_from_user((void *)(dev->image + b->m.offset), (void *)buf,\n\t\t\t   count)) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2-loopback: failed copy_from_user() in write buf, could not write %zu\\n\",\n\t\t       count);\n\t\treturn -EFAULT;\n\t}\n\tv4l2l_get_timestamp(b);\n\tb->bytesused = count;\n\tb->sequence = dev->write_position;\n\tbuffer_written(dev, &dev->buffers[write_index]);\n\twake_up_all(&dev->read_event);\n\tdprintkrw(\"leave v4l2_loopback_write()\\n\");\n\treturn count;\n}\n\n/* init functions */\n/* frees buffers, if already allocated */\nstatic void free_buffers(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tdprintk(\"freeing image@%p for dev:%p\\n\", dev ? dev->image : NULL, dev);\n\tif (!dev)\n\t\treturn;\n\tif (dev->image) {\n\t\tvfree(dev->image);\n\t\tdev->image = NULL;\n\t}\n\tif (dev->timeout_image) {\n\t\tvfree(dev->timeout_image);\n\t\tdev->timeout_image = NULL;\n\t}\n\tdev->imagesize = 0;\n}\n/* frees buffers, if they are no longer needed */\nstatic void try_free_buffers(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tif (0 == dev->open_count.counter && !dev->keep_format) {\n\t\tfree_buffers(dev);\n\t\tdev->ready_for_capture = 0;\n\t\tdev->buffer_size = 0;\n\t\tdev->write_position = 0;\n\t}\n}\n/* allocates buffers, if buffer_size is set */\nstatic int allocate_buffers(struct v4l2_loopback_device *dev)\n{\n\tint err;\n\n\tMARK();\n\t/* vfree on close file operation in case no open handles left */\n\n\tif (dev->buffer_size < 1 || dev->buffers_number < 1)\n\t\treturn -EINVAL;\n\n\tif ((__LONG_MAX__ / dev->buffer_size) < dev->buffers_number)\n\t\treturn -ENOSPC;\n\n\tif (dev->image) {\n\t\tdprintk(\"allocating buffers again: %ld %ld\\n\",\n\t\t\tdev->buffer_size * dev->buffers_number, dev->imagesize);\n\t\t/* FIXME: prevent double allocation more intelligently! */\n\t\tif (dev->buffer_size * dev->buffers_number == dev->imagesize)\n\t\t\treturn 0;\n\n\t\t/* check whether the total number of readers/writers is <=1 */\n\t\tif ((dev->ready_for_capture + dev->active_readers) <= 1)\n\t\t\tfree_buffers(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev->imagesize = (unsigned long)dev->buffer_size *\n\t\t\t (unsigned long)dev->buffers_number;\n\n\tdprintk(\"allocating %ld = %ldx%d\\n\", dev->imagesize, dev->buffer_size,\n\t\tdev->buffers_number);\n\terr = -ENOMEM;\n\n\tif (dev->timeout_jiffies > 0) {\n\t\terr = allocate_timeout_image(dev);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tdev->image = vmalloc(dev->imagesize);\n\tif (dev->image == NULL)\n\t\tgoto error;\n\n\tdprintk(\"vmallocated %ld bytes\\n\", dev->imagesize);\n\tMARK();\n\n\tinit_buffers(dev);\n\treturn 0;\n\nerror:\n\tfree_buffers(dev);\n\treturn err;\n}\n\n/* init inner buffers, they are capture mode and flags are set as\n * for capture mod buffers */\nstatic void init_buffers(struct v4l2_loopback_device *dev)\n{\n\tint i;\n\tint buffer_size;\n\tint bytesused;\n\tMARK();\n\n\tbuffer_size = dev->buffer_size;\n\tbytesused = dev->pix_format.sizeimage;\n\tfor (i = 0; i < dev->buffers_number; ++i) {\n\t\tstruct v4l2_buffer *b = &dev->buffers[i].buffer;\n\t\tb->index = i;\n\t\tb->bytesused = bytesused;\n\t\tb->length = buffer_size;\n\t\tb->field = V4L2_FIELD_NONE;\n\t\tb->flags = 0;\n\t\tb->m.offset = i * buffer_size;\n\t\tb->memory = V4L2_MEMORY_MMAP;\n\t\tb->sequence = 0;\n\t\tb->timestamp.tv_sec = 0;\n\t\tb->timestamp.tv_usec = 0;\n\t\tb->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n\t\tv4l2l_get_timestamp(b);\n\t}\n\tdev->timeout_image_buffer = dev->buffers[0];\n\tdev->timeout_image_buffer.buffer.m.offset = MAX_BUFFERS * buffer_size;\n\tMARK();\n}\n\nstatic int allocate_timeout_image(struct v4l2_loopback_device *dev)\n{\n\tMARK();\n\tif (dev->buffer_size <= 0) {\n\t\tdev->timeout_image_io = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->timeout_image == NULL) {\n\t\tdev->timeout_image = vzalloc(dev->buffer_size);\n\t\tif (dev->timeout_image == NULL) {\n\t\t\tdev->timeout_image_io = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* fills and register video device */\nstatic void init_vdev(struct video_device *vdev, int nr)\n{\n\tMARK();\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tvdev->tvnorms = V4L2_STD_ALL;\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\tvdev->vfl_type = VFL_TYPE_VIDEO;\n\tvdev->fops = &v4l2_loopback_fops;\n\tvdev->ioctl_ops = &v4l2_loopback_ioctl_ops;\n\tvdev->release = &video_device_release;\n\tvdev->minor = -1;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tvdev->device_caps = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n#endif\n\n\tif (debug > 1)\n\t\tvdev->dev_debug = V4L2_DEV_DEBUG_IOCTL |\n\t\t\t\t  V4L2_DEV_DEBUG_IOCTL_ARG;\n\n\tvdev->vfl_dir = VFL_DIR_M2M;\n\n\tMARK();\n}\n\n/* init default capture parameters, only fps may be changed in future */\nstatic void init_capture_param(struct v4l2_captureparm *capture_param)\n{\n\tMARK();\n\tcapture_param->capability = 0;\n\tcapture_param->capturemode = 0;\n\tcapture_param->extendedmode = 0;\n\tcapture_param->readbuffers = max_buffers;\n\tcapture_param->timeperframe.numerator = 1;\n\tcapture_param->timeperframe.denominator = 30;\n}\n\nstatic void check_timers(struct v4l2_loopback_device *dev)\n{\n\tif (!dev->ready_for_capture)\n\t\treturn;\n\n\tif (dev->timeout_jiffies > 0 && !timer_pending(&dev->timeout_timer))\n\t\tmod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);\n\tif (dev->sustain_framerate && !timer_pending(&dev->sustain_timer))\n\t\tmod_timer(&dev->sustain_timer,\n\t\t\t  jiffies + dev->frame_jiffies * 3 / 2);\n}\n#ifdef HAVE_TIMER_SETUP\nstatic void sustain_timer_clb(struct timer_list *t)\n{\n\tstruct v4l2_loopback_device *dev = from_timer(dev, t, sustain_timer);\n#else\nstatic void sustain_timer_clb(unsigned long nr)\n{\n\tstruct v4l2_loopback_device *dev =\n\t\tidr_find(&v4l2loopback_index_idr, nr);\n#endif\n\tspin_lock(&dev->lock);\n\tif (dev->sustain_framerate) {\n\t\tdev->reread_count++;\n\t\tdprintkrw(\"reread: %lld %d\\n\", (long long)dev->write_position,\n\t\t\t  dev->reread_count);\n\t\tif (dev->reread_count == 1)\n\t\t\tmod_timer(&dev->sustain_timer,\n\t\t\t\t  jiffies + max(1UL, dev->frame_jiffies / 2));\n\t\telse\n\t\t\tmod_timer(&dev->sustain_timer,\n\t\t\t\t  jiffies + dev->frame_jiffies);\n\t\twake_up_all(&dev->read_event);\n\t}\n\tspin_unlock(&dev->lock);\n}\n#ifdef HAVE_TIMER_SETUP\nstatic void timeout_timer_clb(struct timer_list *t)\n{\n\tstruct v4l2_loopback_device *dev = from_timer(dev, t, timeout_timer);\n#else\nstatic void timeout_timer_clb(unsigned long nr)\n{\n\tstruct v4l2_loopback_device *dev =\n\t\tidr_find(&v4l2loopback_index_idr, nr);\n#endif\n\tspin_lock(&dev->lock);\n\tif (dev->timeout_jiffies > 0) {\n\t\tdev->timeout_happened = 1;\n\t\tmod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);\n\t\twake_up_all(&dev->read_event);\n\t}\n\tspin_unlock(&dev->lock);\n}\n\n/* init loopback main structure */\n#define DEFAULT_FROM_CONF(confmember, default_condition, default_value)        \\\n\t((conf) ?                                                              \\\n\t\t ((conf->confmember default_condition) ? (default_value) :     \\\n\t\t\t\t\t\t\t (conf->confmember)) : \\\n\t\t default_value)\n\nstatic int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2loopback_private *vdev_priv = NULL;\n\n\tint err = -ENOMEM;\n\n\tu32 _width = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\tu32 _height = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\n\tu32 _min_width = DEFAULT_FROM_CONF(min_width,\n\t\t\t\t\t   < V4L2LOOPBACK_SIZE_MIN_WIDTH,\n\t\t\t\t\t   V4L2LOOPBACK_SIZE_MIN_WIDTH);\n\tu32 _min_height = DEFAULT_FROM_CONF(min_height,\n\t\t\t\t\t    < V4L2LOOPBACK_SIZE_MIN_HEIGHT,\n\t\t\t\t\t    V4L2LOOPBACK_SIZE_MIN_HEIGHT);\n\tu32 _max_width = DEFAULT_FROM_CONF(max_width, < _min_width, max_width);\n\tu32 _max_height =\n\t\tDEFAULT_FROM_CONF(max_height, < _min_height, max_height);\n\tbool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?\n\t\t\t\t\t  (conf->announce_all_caps) :\n\t\t\t\t\t  V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;\n\tint _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);\n\tint _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);\n\n\tint nr = -1;\n\n\t_announce_all_caps = (!!_announce_all_caps);\n\n\tif (conf) {\n\t\tconst int output_nr = conf->output_nr;\n#ifdef SPLIT_DEVICES\n\t\tconst int capture_nr = conf->capture_nr;\n#else\n\t\tconst int capture_nr = output_nr;\n#endif\n\t\tif (capture_nr >= 0 && output_nr == capture_nr) {\n\t\t\tnr = output_nr;\n\t\t} else if (capture_nr < 0 && output_nr < 0) {\n\t\t\tnr = -1;\n\t\t} else if (capture_nr < 0) {\n\t\t\tnr = output_nr;\n\t\t} else if (output_nr < 0) {\n\t\t\tnr = capture_nr;\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"split OUTPUT and CAPTURE devices not yet supported.\");\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"both devices must have the same number (%d != %d).\",\n\t\t\t       output_nr, capture_nr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (idr_find(&v4l2loopback_index_idr, nr))\n\t\treturn -EEXIST;\n\n\tdprintk(\"creating v4l2loopback-device #%d\\n\", nr);\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* allocate id, if @id >= 0, we're requesting that specific id */\n\tif (nr >= 0) {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,\n\t\t\t\tGFP_KERNEL);\n\t\tif (err == -ENOSPC)\n\t\t\terr = -EEXIST;\n\t} else {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);\n\t}\n\tif (err < 0)\n\t\tgoto out_free_dev;\n\tnr = err;\n\terr = -ENOMEM;\n\n\tif (conf && conf->card_label[0]) {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label), \"%s\",\n\t\t\t conf->card_label);\n\t} else {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label),\n\t\t\t \"Dummy video device (0x%04X)\", nr);\n\t}\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t \"v4l2loopback-%03d\", nr);\n\n\terr = v4l2_device_register(NULL, &dev->v4l2_dev);\n\tif (err)\n\t\tgoto out_free_idr;\n\tMARK();\n\n\tdev->vdev = video_device_alloc();\n\tif (dev->vdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);\n\tif (vdev_priv == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvideo_set_drvdata(dev->vdev, vdev_priv);\n\tif (video_get_drvdata(dev->vdev) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tMARK();\n\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), \"%s\",\n\t\t dev->card_label);\n\n\tvdev_priv->device_nr = nr;\n\n\tinit_vdev(dev->vdev, nr);\n\tdev->vdev->v4l2_dev = &dev->v4l2_dev;\n\tinit_capture_param(&dev->capture_param);\n\terr = set_timeperframe(dev, &dev->capture_param.timeperframe);\n\tif (err)\n\t\tgoto out_unregister;\n\tdev->keep_format = 0;\n\tdev->sustain_framerate = 0;\n\n\tdev->announce_all_caps = _announce_all_caps;\n\tdev->min_width = _min_width;\n\tdev->min_height = _min_height;\n\tdev->max_width = _max_width;\n\tdev->max_height = _max_height;\n\tdev->max_openers = _max_openers;\n\tdev->buffers_number = dev->used_buffers = _max_buffers;\n\n\tdev->write_position = 0;\n\n\tMARK();\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&dev->list_lock);\n\tINIT_LIST_HEAD(&dev->outbufs_list);\n\tif (list_empty(&dev->outbufs_list)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t      &dev->outbufs_list);\n\t}\n\tmemset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));\n\tatomic_set(&dev->open_count, 0);\n\tdev->ready_for_capture = 0;\n\tdev->ready_for_output = 1;\n\n\tdev->buffer_size = 0;\n\tdev->image = NULL;\n\tdev->imagesize = 0;\n#ifdef HAVE_TIMER_SETUP\n\ttimer_setup(&dev->sustain_timer, sustain_timer_clb, 0);\n\ttimer_setup(&dev->timeout_timer, timeout_timer_clb, 0);\n#else\n\tsetup_timer(&dev->sustain_timer, sustain_timer_clb, nr);\n\tsetup_timer(&dev->timeout_timer, timeout_timer_clb, nr);\n#endif\n\tdev->reread_count = 0;\n\tdev->timeout_jiffies = 0;\n\tdev->timeout_image = NULL;\n\tdev->timeout_happened = 0;\n\n\thdl = &dev->ctrl_handler;\n\terr = v4l2_ctrl_handler_init(hdl, 4);\n\tif (err)\n\t\tgoto out_unregister;\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto out_free_handler;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\terr = v4l2_ctrl_handler_setup(hdl);\n\tif (err)\n\t\tgoto out_free_handler;\n\n\t/* FIXME set buffers to 0 */\n\n\t/* Set initial format */\n\tif (_width < _min_width)\n\t\t_width = _min_width;\n\tif (_width > _max_width)\n\t\t_width = _max_width;\n\tif (_height < _min_height)\n\t\t_height = _min_height;\n\tif (_height > _max_height)\n\t\t_height = _max_height;\n\n\tdev->pix_format.width = _width;\n\tdev->pix_format.height = _height;\n\tdev->pix_format.pixelformat = formats[0].fourcc;\n\tdev->pix_format.colorspace =\n\t\tV4L2_COLORSPACE_DEFAULT; /* do we need to set this ? */\n\tdev->pix_format.field = V4L2_FIELD_NONE;\n\n\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\tdprintk(\"buffer_size = %ld (=%d)\\n\", dev->buffer_size,\n\t\tdev->pix_format.sizeimage);\n\n\tif (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))\n\t\tgoto out_free_handler;\n\n\tinit_waitqueue_head(&dev->read_event);\n\n\t/* register the device -> it creates /dev/video* */\n\tif (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2loopback: failed video_register_device()\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out_free_device;\n\t}\n\tv4l2loopback_create_sysfs(dev->vdev);\n\n\tMARK();\n\tif (ret_nr)\n\t\t*ret_nr = dev->vdev->num;\n\treturn 0;\n\nout_free_device:\n\tvideo_device_release(dev->vdev);\nout_free_handler:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\nout_unregister:\n\tvideo_set_drvdata(dev->vdev, NULL);\n\tif (vdev_priv != NULL)\n\t\tkfree(vdev_priv);\n\tv4l2_device_unregister(&dev->v4l2_dev);\nout_free_idr:\n\tidr_remove(&v4l2loopback_index_idr, nr);\nout_free_dev:\n\tkfree(dev);\n\treturn err;\n}\n\nstatic void v4l2_loopback_remove(struct v4l2_loopback_device *dev)\n{\n\tfree_buffers(dev);\n\tv4l2loopback_remove_sysfs(dev->vdev);\n\tkfree(video_get_drvdata(dev->vdev));\n\tvideo_unregister_device(dev->vdev);\n\tv4l2_device_unregister(&dev->v4l2_dev);\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\n\tkfree(dev);\n}\n\nstatic long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t       unsigned long parm)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_loopback_config conf;\n\tstruct v4l2_loopback_config *confptr = &conf;\n\tint device_nr, capture_nr, output_nr;\n\tint ret;\n\n\tret = mutex_lock_killable(&v4l2loopback_ctl_mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -EINVAL;\n\tswitch (cmd) {\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t\t/* add a v4l2loopback device (pair), based on the user-provided specs */\n\tcase V4L2LOOPBACK_CTL_ADD:\n\t\tif (parm) {\n\t\t\tif ((ret = copy_from_user(&conf, (void *)parm,\n\t\t\t\t\t\t  sizeof(conf))) < 0)\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tconfptr = NULL;\n\t\tret = v4l2_loopback_add(confptr, &device_nr);\n\t\tif (ret >= 0)\n\t\t\tret = device_nr;\n\t\tbreak;\n\t\t/* remove a v4l2loopback device (both capture and output) */\n\tcase V4L2LOOPBACK_CTL_REMOVE:\n\t\tret = v4l2loopback_lookup((int)parm, &dev);\n\t\tif (ret >= 0 && dev) {\n\t\t\tint nr = ret;\n\t\t\tret = -EBUSY;\n\t\t\tif (dev->open_count.counter > 0)\n\t\t\t\tbreak;\n\t\t\tidr_remove(&v4l2loopback_index_idr, nr);\n\t\t\tv4l2_loopback_remove(dev);\n\t\t\tret = 0;\n\t\t};\n\t\tbreak;\n\t\t/* get information for a loopback device.\n\t\t * this is mostly about limits (which cannot be queried directly with  VIDIOC_G_FMT and friends\n\t\t */\n\tcase V4L2LOOPBACK_CTL_QUERY:\n\t\tif (!parm)\n\t\t\tbreak;\n\t\tif ((ret = copy_from_user(&conf, (void *)parm, sizeof(conf))) <\n\t\t    0)\n\t\t\tbreak;\n\t\tcapture_nr = output_nr = conf.output_nr;\n#ifdef SPLIT_DEVICES\n\t\tcapture_nr = conf.capture_nr;\n#endif\n\t\tdevice_nr = (output_nr < 0) ? capture_nr : output_nr;\n\t\tMARK();\n\t\t/* get the device from either capture_nr or output_nr (whatever is valid) */\n\t\tif ((ret = v4l2loopback_lookup(device_nr, &dev)) < 0)\n\t\t\tbreak;\n\t\tMARK();\n\t\t/* if we got the device from output_nr and there is a valid capture_nr,\n\t\t * make sure that both refer to the same device (or bail out)\n\t\t */\n\t\tif ((device_nr != capture_nr) && (capture_nr >= 0) &&\n\t\t    ((ret = v4l2loopback_lookup(capture_nr, 0)) < 0))\n\t\t\tbreak;\n\t\tMARK();\n\t\t/* if otoh, we got the device from capture_nr and there is a valid output_nr,\n\t\t * make sure that both refer to the same device (or bail out)\n\t\t */\n\t\tif ((device_nr != output_nr) && (output_nr >= 0) &&\n\t\t    ((ret = v4l2loopback_lookup(output_nr, 0)) < 0))\n\t\t\tbreak;\n\t\tMARK();\n\n\t\t/* v4l2_loopback_config identified a single device, so fetch the data */\n\t\tsnprintf(conf.card_label, sizeof(conf.card_label), \"%s\",\n\t\t\t dev->card_label);\n\t\tMARK();\n\t\tconf.output_nr = dev->vdev->num;\n#ifdef SPLIT_DEVICES\n\t\tconf.capture_nr = dev->vdev->num;\n#endif\n\t\tconf.min_width = dev->min_width;\n\t\tconf.min_height = dev->min_height;\n\t\tconf.max_width = dev->max_width;\n\t\tconf.max_height = dev->max_height;\n\t\tconf.announce_all_caps = dev->announce_all_caps;\n\t\tconf.max_buffers = dev->buffers_number;\n\t\tconf.max_openers = dev->max_openers;\n\t\tconf.debug = debug;\n\t\tMARK();\n\t\tif (copy_to_user((void *)parm, &conf, sizeof(conf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tMARK();\n\t\tret = 0;\n\t\t;\n\t\tbreak;\n\t}\n\n\tMARK();\n\tmutex_unlock(&v4l2loopback_ctl_mutex);\n\tMARK();\n\treturn ret;\n}\n\n/* LINUX KERNEL */\n\nstatic const struct file_operations v4l2loopback_ctl_fops = {\n\t// clang-format off\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nonseekable_open,\n\t.unlocked_ioctl\t= v4l2loopback_control_ioctl,\n\t.compat_ioctl\t= v4l2loopback_control_ioctl,\n\t.llseek\t\t= noop_llseek,\n\t// clang-format on\n};\n\nstatic struct miscdevice v4l2loopback_misc = {\n\t// clang-format off\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"v4l2loopback\",\n\t.fops\t\t= &v4l2loopback_ctl_fops,\n\t// clang-format on\n};\n\nstatic const struct v4l2_file_operations v4l2_loopback_fops = {\n\t// clang-format off\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= v4l2_loopback_open,\n\t.release\t= v4l2_loopback_close,\n\t.read\t\t= v4l2_loopback_read,\n\t.write\t\t= v4l2_loopback_write,\n\t.poll\t\t= v4l2_loopback_poll,\n\t.mmap\t\t= v4l2_loopback_mmap,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t// clang-format on\n};\n\nstatic const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops = {\n\t// clang-format off\n\t.vidioc_querycap\t\t= &vidioc_querycap,\n\t.vidioc_enum_framesizes\t\t= &vidioc_enum_framesizes,\n\t.vidioc_enum_frameintervals\t= &vidioc_enum_frameintervals,\n\n\t.vidioc_enum_output\t\t= &vidioc_enum_output,\n\t.vidioc_g_output\t\t= &vidioc_g_output,\n\t.vidioc_s_output\t\t= &vidioc_s_output,\n\n\t.vidioc_enum_input\t\t= &vidioc_enum_input,\n\t.vidioc_g_input\t\t\t= &vidioc_g_input,\n\t.vidioc_s_input\t\t\t= &vidioc_s_input,\n\n\t.vidioc_enum_fmt_vid_cap\t= &vidioc_enum_fmt_cap,\n\t.vidioc_g_fmt_vid_cap\t\t= &vidioc_g_fmt_cap,\n\t.vidioc_s_fmt_vid_cap\t\t= &vidioc_s_fmt_cap,\n\t.vidioc_try_fmt_vid_cap\t\t= &vidioc_try_fmt_cap,\n\n\t.vidioc_enum_fmt_vid_out\t= &vidioc_enum_fmt_out,\n\t.vidioc_s_fmt_vid_out\t\t= &vidioc_s_fmt_out,\n\t.vidioc_g_fmt_vid_out\t\t= &vidioc_g_fmt_out,\n\t.vidioc_try_fmt_vid_out\t\t= &vidioc_try_fmt_out,\n\n#ifdef V4L2L_OVERLAY\n\t.vidioc_s_fmt_vid_overlay\t= &vidioc_s_fmt_overlay,\n\t.vidioc_g_fmt_vid_overlay\t= &vidioc_g_fmt_overlay,\n#endif\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\t.vidioc_s_std\t\t\t= &vidioc_s_std,\n\t.vidioc_g_std\t\t\t= &vidioc_g_std,\n\t.vidioc_querystd\t\t= &vidioc_querystd,\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\t.vidioc_g_parm\t\t\t= &vidioc_g_parm,\n\t.vidioc_s_parm\t\t\t= &vidioc_s_parm,\n\n\t.vidioc_reqbufs\t\t\t= &vidioc_reqbufs,\n\t.vidioc_querybuf\t\t= &vidioc_querybuf,\n\t.vidioc_qbuf\t\t\t= &vidioc_qbuf,\n\t.vidioc_dqbuf\t\t\t= &vidioc_dqbuf,\n\n\t.vidioc_streamon\t\t= &vidioc_streamon,\n\t.vidioc_streamoff\t\t= &vidioc_streamoff,\n\n#ifdef CONFIG_VIDEO_V4L1_COMPAT\n\t.vidiocgmbuf\t\t\t= &vidiocgmbuf,\n#endif\n\n\t.vidioc_subscribe_event\t\t= &vidioc_subscribe_event,\n\t.vidioc_unsubscribe_event\t= &v4l2_event_unsubscribe,\n\t// clang-format on\n};\n\nstatic int free_device_cb(int id, void *ptr, void *data)\n{\n\tstruct v4l2_loopback_device *dev = ptr;\n\tv4l2_loopback_remove(dev);\n\treturn 0;\n}\nstatic void free_devices(void)\n{\n\tidr_for_each(&v4l2loopback_index_idr, &free_device_cb, NULL);\n\tidr_destroy(&v4l2loopback_index_idr);\n}\n\nstatic int __init v4l2loopback_init_module(void)\n{\n\tconst u32 min_width = V4L2LOOPBACK_SIZE_MIN_WIDTH;\n\tconst u32 min_height = V4L2LOOPBACK_SIZE_MIN_HEIGHT;\n\tint err;\n\tint i;\n\tMARK();\n\n\terr = misc_register(&v4l2loopback_misc);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (devices < 0) {\n\t\tdevices = 1;\n\n\t\t/* try guessing the devices from the \"video_nr\" parameter */\n\t\tfor (i = MAX_DEVICES - 1; i >= 0; i--) {\n\t\t\tif (video_nr[i] >= 0) {\n\t\t\t\tdevices = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (devices > MAX_DEVICES) {\n\t\tdevices = MAX_DEVICES;\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: number of initial devices is limited to: %d\\n\",\n\t\t       MAX_DEVICES);\n\t}\n\n\tif (max_buffers > MAX_BUFFERS) {\n\t\tmax_buffers = MAX_BUFFERS;\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: number of buffers is limited to: %d\\n\",\n\t\t       MAX_BUFFERS);\n\t}\n\n\tif (max_openers < 0) {\n\t\tprintk(KERN_INFO\n\t\t       \"v4l2loopback: allowing %d openers rather than %d\\n\",\n\t\t       2, max_openers);\n\t\tmax_openers = 2;\n\t}\n\n\tif (max_width < min_width) {\n\t\tmax_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;\n\t\tprintk(KERN_INFO \"v4l2loopback: using max_width %d\\n\",\n\t\t       max_width);\n\t}\n\tif (max_height < min_height) {\n\t\tmax_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;\n\t\tprintk(KERN_INFO \"v4l2loopback: using max_height %d\\n\",\n\t\t       max_height);\n\t}\n\n\tfor (i = 0; i < devices; i++) {\n\t\tstruct v4l2_loopback_config cfg = {\n\t\t\t// clang-format off\n\t\t\t.output_nr\t\t= video_nr[i],\n#ifdef SPLIT_DEVICES\n\t\t\t.capture_nr\t\t= video_nr[i],\n#endif\n\t\t\t.min_width\t\t= min_width,\n\t\t\t.min_height\t\t= min_height,\n\t\t\t.max_width\t\t= max_width,\n\t\t\t.max_height\t\t= max_height,\n\t\t\t.announce_all_caps\t= (!exclusive_caps[i]),\n\t\t\t.max_buffers\t\t= max_buffers,\n\t\t\t.max_openers\t\t= max_openers,\n\t\t\t.debug\t\t\t= debug,\n\t\t\t// clang-format on\n\t\t};\n\t\tcfg.card_label[0] = 0;\n\t\tif (card_label[i])\n\t\t\tsnprintf(cfg.card_label, sizeof(cfg.card_label), \"%s\",\n\t\t\t\t card_label[i]);\n\t\terr = v4l2_loopback_add(&cfg, 0);\n\t\tif (err) {\n\t\t\tfree_devices();\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdprintk(\"module installed\\n\");\n\n\tprintk(KERN_INFO \"v4l2loopback driver version %d.%d.%d%s loaded\\n\",\n\t       // clang-format off\n\t       (V4L2LOOPBACK_VERSION_CODE >> 16) & 0xff,\n\t       (V4L2LOOPBACK_VERSION_CODE >>  8) & 0xff,\n\t       (V4L2LOOPBACK_VERSION_CODE      ) & 0xff,\n#ifdef SNAPSHOT_VERSION\n\t       \" (\" __stringify(SNAPSHOT_VERSION) \")\"\n#else\n\t       \"\"\n#endif\n\t       );\n\t// clang-format on\n\n\treturn 0;\nerror:\n\tmisc_deregister(&v4l2loopback_misc);\n\treturn err;\n}\n\nstatic void v4l2loopback_cleanup_module(void)\n{\n\tMARK();\n\t/* unregister the device -> it deletes /dev/video* */\n\tfree_devices();\n\t/* and get rid of /dev/v4l2loopback */\n\tmisc_deregister(&v4l2loopback_misc);\n\tdprintk(\"module removed\\n\");\n}\n\nMODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);\n\nmodule_init(v4l2loopback_init_module);\nmodule_exit(v4l2loopback_cleanup_module);\n"
        },
        {
          "name": "v4l2loopback.h",
          "type": "blob",
          "size": 2.9814453125,
          "content": "/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n * v4l2loopback.h\n *\n * Written by IOhannes m zmölnig, 7/1/20.\n *\n * Copyright 2020 by IOhannes m zmölnig.  Redistribution of this file is\n * permitted under the GNU General Public License.\n */\n#ifndef _V4L2LOOPBACK_H\n#define _V4L2LOOPBACK_H\n\n#define V4L2LOOPBACK_VERSION_MAJOR 0\n#define V4L2LOOPBACK_VERSION_MINOR 13\n#define V4L2LOOPBACK_VERSION_BUGFIX 2\n\n/* /dev/v4l2loopback interface */\n\nstruct v4l2_loopback_config {\n\t/**\n         * the device-number (/dev/video<nr>)\n         * V4L2LOOPBACK_CTL_ADD:\n         * setting this to a value<0, will allocate an available one\n         * if nr>=0 and the device already exists, the ioctl will EEXIST\n         * if output_nr and capture_nr are the same, only a single device will be created\n\t * NOTE: currently split-devices (where output_nr and capture_nr differ)\n\t *   are not implemented yet.\n\t *   until then, requesting different device-IDs will result in EINVAL.\n         *\n         * V4L2LOOPBACK_CTL_QUERY:\n         * either both output_nr and capture_nr must refer to the same loopback,\n         * or one (and only one) of them must be -1\n         *\n         */\n\tint output_nr;\n\tint unused; /*capture_nr;*/\n\n\t/**\n         * a nice name for your device\n         * if (*card_label)==0, an automatic name is assigned\n         */\n\tchar card_label[32];\n\n\t/**\n         * allowed frame size\n         * if too low, default values are used\n         */\n\tunsigned int min_width;\n\tunsigned int max_width;\n\tunsigned int min_height;\n\tunsigned int max_height;\n\n\t/**\n         * number of buffers to allocate for the queue\n         * if set to <=0, default values are used\n         */\n\tint max_buffers;\n\n\t/**\n         * how many consumers are allowed to open this device concurrently\n         * if set to <=0, default values are used\n         */\n\tint max_openers;\n\n\t/**\n         * set the debugging level for this device\n         */\n\tint debug;\n\n\t/**\n         * whether to announce OUTPUT/CAPTURE capabilities exclusively\n         * for this device or not\n         * (!exclusive_caps)\n\t * NOTE: this is going to be removed once separate output/capture\n\t *       devices are implemented\n         */\n\tint announce_all_caps;\n};\n\n/* a pointer to a (struct v4l2_loopback_config) that has all values you wish to impose on the\n * to-be-created device set.\n * if the ptr is NULL, a new device is created with default values at the driver's discretion.\n *\n * returns the device_nr of the OUTPUT device (which can be used with V4L2LOOPBACK_CTL_QUERY,\n * to get more information on the device)\n */\n#define V4L2LOOPBACK_CTL_ADD 0x4C80\n\n/* a pointer to a (struct v4l2_loopback_config) that has output_nr and/or capture_nr set\n * (the two values must either refer to video-devices associated with the same loopback device\n *  or exactly one of them must be <0\n */\n#define V4L2LOOPBACK_CTL_QUERY 0x4C82\n\n/* the device-number (either CAPTURE or OUTPUT) associated with the loopback-device */\n#define V4L2LOOPBACK_CTL_REMOVE 0x4C81\n\n#endif /* _V4L2LOOPBACK_H */\n"
        },
        {
          "name": "v4l2loopback_formats.h",
          "type": "blob",
          "size": 8.6904296875,
          "content": "static const struct v4l2l_format formats[] = {\n#ifndef V4L2_PIX_FMT_VP9\n#define V4L2_PIX_FMT_VP9 v4l2_fourcc('V', 'P', '9', '0')\n#endif\n#ifndef V4L2_PIX_FMT_HEVC\n#define V4L2_PIX_FMT_HEVC v4l2_fourcc('H', 'E', 'V', 'C')\n#endif\n\n\t/* here come the packed formats */\n\t{\n\t\t.name = \"32 bpp RGB, le\",\n\t\t.fourcc = V4L2_PIX_FMT_BGR32,\n\t\t.depth = 32,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"32 bpp RGB, be\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB32,\n\t\t.depth = 32,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"24 bpp RGB, le\",\n\t\t.fourcc = V4L2_PIX_FMT_BGR24,\n\t\t.depth = 24,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"24 bpp RGB, be\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB24,\n\t\t.depth = 24,\n\t\t.flags = 0,\n\t},\n#ifdef V4L2_PIX_FMT_ABGR32\n\t{\n\t\t.name = \"32 bpp RGBA, le\",\n\t\t.fourcc = V4L2_PIX_FMT_ABGR32,\n\t\t.depth = 32,\n\t\t.flags = 0,\n\t},\n#endif\n#ifdef V4L2_PIX_FMT_RGBA32\n\t{\n\t\t.name = \"32 bpp RGBA\",\n\t\t.fourcc = V4L2_PIX_FMT_RGBA32,\n\t\t.depth = 32,\n\t\t.flags = 0,\n\t},\n#endif\n#ifdef V4L2_PIX_FMT_RGB332\n\t{\n\t\t.name = \"8 bpp RGB-3-3-2\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB332,\n\t\t.depth = 8,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_RGB332 */\n#ifdef V4L2_PIX_FMT_RGB444\n\t{\n\t\t.name = \"16 bpp RGB (xxxxrrrr ggggbbbb)\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB444,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_RGB444 */\n#ifdef V4L2_PIX_FMT_RGB555\n\t{\n\t\t.name = \"16 bpp RGB-5-5-5\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB555,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_RGB555 */\n#ifdef V4L2_PIX_FMT_RGB565\n\t{\n\t\t.name = \"16 bpp RGB-5-6-5\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB565,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_RGB565 */\n#ifdef V4L2_PIX_FMT_RGB555X\n\t{\n\t\t.name = \"16 bpp RGB-5-5-5 BE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB555X,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_RGB555X */\n#ifdef V4L2_PIX_FMT_RGB565X\n\t{\n\t\t.name = \"16 bpp RGB-5-6-5 BE\",\n\t\t.fourcc = V4L2_PIX_FMT_RGB565X,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_RGB565X */\n#ifdef V4L2_PIX_FMT_BGR666\n\t{\n\t\t.name = \"18 bpp BGR-6-6-6\",\n\t\t.fourcc = V4L2_PIX_FMT_BGR666,\n\t\t.depth = 18,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_BGR666 */\n\t{\n\t\t.name = \"4:2:2, packed, YUYV\",\n\t\t.fourcc = V4L2_PIX_FMT_YUYV,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"4:2:2, packed, UYVY\",\n\t\t.fourcc = V4L2_PIX_FMT_UYVY,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#ifdef V4L2_PIX_FMT_YVYU\n\t{\n\t\t.name = \"4:2:2, packed YVYU\",\n\t\t.fourcc = V4L2_PIX_FMT_YVYU,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif\n#ifdef V4L2_PIX_FMT_VYUY\n\t{\n\t\t.name = \"4:2:2, packed VYUY\",\n\t\t.fourcc = V4L2_PIX_FMT_VYUY,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif\n\t{\n\t\t.name = \"4:2:2, packed YYUV\",\n\t\t.fourcc = V4L2_PIX_FMT_YYUV,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"YUV-8-8-8-8\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV32,\n\t\t.depth = 32,\n\t\t.flags = 0,\n\t},\n\t{\n\t\t.name = \"8 bpp, Greyscale\",\n\t\t.fourcc = V4L2_PIX_FMT_GREY,\n\t\t.depth = 8,\n\t\t.flags = 0,\n\t},\n#ifdef V4L2_PIX_FMT_Y4\n\t{\n\t\t.name = \"4 bpp Greyscale\",\n\t\t.fourcc = V4L2_PIX_FMT_Y4,\n\t\t.depth = 4,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_Y4 */\n#ifdef V4L2_PIX_FMT_Y6\n\t{\n\t\t.name = \"6 bpp Greyscale\",\n\t\t.fourcc = V4L2_PIX_FMT_Y6,\n\t\t.depth = 6,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_Y6 */\n#ifdef V4L2_PIX_FMT_Y10\n\t{\n\t\t.name = \"10 bpp Greyscale\",\n\t\t.fourcc = V4L2_PIX_FMT_Y10,\n\t\t.depth = 10,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_Y10 */\n#ifdef V4L2_PIX_FMT_Y12\n\t{\n\t\t.name = \"12 bpp Greyscale\",\n\t\t.fourcc = V4L2_PIX_FMT_Y12,\n\t\t.depth = 12,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_Y12 */\n\t{\n\t\t.name = \"16 bpp, Greyscale\",\n\t\t.fourcc = V4L2_PIX_FMT_Y16,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#ifdef V4L2_PIX_FMT_YUV444\n\t{\n\t\t.name = \"16 bpp xxxxyyyy uuuuvvvv\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV444,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_YUV444 */\n#ifdef V4L2_PIX_FMT_YUV555\n\t{\n\t\t.name = \"16 bpp YUV-5-5-5\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV555,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_YUV555 */\n#ifdef V4L2_PIX_FMT_YUV565\n\t{\n\t\t.name = \"16 bpp YUV-5-6-5\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV565,\n\t\t.depth = 16,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_YUV565 */\n\n/* bayer formats */\n#ifdef V4L2_PIX_FMT_SRGGB8\n\t{\n\t\t.name = \"Bayer RGGB 8bit\",\n\t\t.fourcc = V4L2_PIX_FMT_SRGGB8,\n\t\t.depth = 8,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_SRGGB8 */\n#ifdef V4L2_PIX_FMT_SGRBG8\n\t{\n\t\t.name = \"Bayer GRBG 8bit\",\n\t\t.fourcc = V4L2_PIX_FMT_SGRBG8,\n\t\t.depth = 8,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_SGRBG8 */\n#ifdef V4L2_PIX_FMT_SGBRG8\n\t{\n\t\t.name = \"Bayer GBRG 8bit\",\n\t\t.fourcc = V4L2_PIX_FMT_SGBRG8,\n\t\t.depth = 8,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_SGBRG8 */\n#ifdef V4L2_PIX_FMT_SBGGR8\n\t{\n\t\t.name = \"Bayer BA81 8bit\",\n\t\t.fourcc = V4L2_PIX_FMT_SBGGR8,\n\t\t.depth = 8,\n\t\t.flags = 0,\n\t},\n#endif /* V4L2_PIX_FMT_SBGGR8 */\n\n\t/* here come the planar formats */\n\t{\n\t\t.name = \"4:1:0, planar, Y-Cr-Cb\",\n\t\t.fourcc = V4L2_PIX_FMT_YVU410,\n\t\t.depth = 9,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n\t{\n\t\t.name = \"4:2:0, planar, Y-Cr-Cb\",\n\t\t.fourcc = V4L2_PIX_FMT_YVU420,\n\t\t.depth = 12,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n\t{\n\t\t.name = \"4:1:0, planar, Y-Cb-Cr\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV410,\n\t\t.depth = 9,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n\t{\n\t\t.name = \"4:2:0, planar, Y-Cb-Cr\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV420,\n\t\t.depth = 12,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n#ifdef V4L2_PIX_FMT_YUV422P\n\t{\n\t\t.name = \"16 bpp YVU422 planar\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV422P,\n\t\t.depth = 16,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n#endif /* V4L2_PIX_FMT_YUV422P */\n#ifdef V4L2_PIX_FMT_YUV411P\n\t{\n\t\t.name = \"16 bpp YVU411 planar\",\n\t\t.fourcc = V4L2_PIX_FMT_YUV411P,\n\t\t.depth = 16,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n#endif /* V4L2_PIX_FMT_YUV411P */\n#ifdef V4L2_PIX_FMT_Y41P\n\t{\n\t\t.name = \"12 bpp YUV 4:1:1\",\n\t\t.fourcc = V4L2_PIX_FMT_Y41P,\n\t\t.depth = 12,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n#endif /* V4L2_PIX_FMT_Y41P */\n#ifdef V4L2_PIX_FMT_NV12\n\t{\n\t\t.name = \"12 bpp Y/CbCr 4:2:0 \",\n\t\t.fourcc = V4L2_PIX_FMT_NV12,\n\t\t.depth = 12,\n\t\t.flags = FORMAT_FLAGS_PLANAR,\n\t},\n#endif /* V4L2_PIX_FMT_NV12 */\n\n/* here come the compressed formats */\n\n#ifdef V4L2_PIX_FMT_MJPEG\n\t{\n\t\t.name = \"Motion-JPEG\",\n\t\t.fourcc = V4L2_PIX_FMT_MJPEG,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_MJPEG */\n#ifdef V4L2_PIX_FMT_JPEG\n\t{\n\t\t.name = \"JFIF JPEG\",\n\t\t.fourcc = V4L2_PIX_FMT_JPEG,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_JPEG */\n#ifdef V4L2_PIX_FMT_DV\n\t{\n\t\t.name = \"DV1394\",\n\t\t.fourcc = V4L2_PIX_FMT_DV,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_DV */\n#ifdef V4L2_PIX_FMT_MPEG\n\t{\n\t\t.name = \"MPEG-1/2/4 Multiplexed\",\n\t\t.fourcc = V4L2_PIX_FMT_MPEG,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_MPEG */\n#ifdef V4L2_PIX_FMT_H264\n\t{\n\t\t.name = \"H264 with start codes\",\n\t\t.fourcc = V4L2_PIX_FMT_H264,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_H264 */\n#ifdef V4L2_PIX_FMT_H264_NO_SC\n\t{\n\t\t.name = \"H264 without start codes\",\n\t\t.fourcc = V4L2_PIX_FMT_H264_NO_SC,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_H264_NO_SC */\n#ifdef V4L2_PIX_FMT_H264_MVC\n\t{\n\t\t.name = \"H264 MVC\",\n\t\t.fourcc = V4L2_PIX_FMT_H264_MVC,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_H264_MVC */\n#ifdef V4L2_PIX_FMT_H263\n\t{\n\t\t.name = \"H263\",\n\t\t.fourcc = V4L2_PIX_FMT_H263,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_H263 */\n#ifdef V4L2_PIX_FMT_MPEG1\n\t{\n\t\t.name = \"MPEG-1 ES\",\n\t\t.fourcc = V4L2_PIX_FMT_MPEG1,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_MPEG1 */\n#ifdef V4L2_PIX_FMT_MPEG2\n\t{\n\t\t.name = \"MPEG-2 ES\",\n\t\t.fourcc = V4L2_PIX_FMT_MPEG2,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_MPEG2 */\n#ifdef V4L2_PIX_FMT_MPEG4\n\t{\n\t\t.name = \"MPEG-4 part 2 ES\",\n\t\t.fourcc = V4L2_PIX_FMT_MPEG4,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_MPEG4 */\n#ifdef V4L2_PIX_FMT_XVID\n\t{\n\t\t.name = \"Xvid\",\n\t\t.fourcc = V4L2_PIX_FMT_XVID,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_XVID */\n#ifdef V4L2_PIX_FMT_VC1_ANNEX_G\n\t{\n\t\t.name = \"SMPTE 421M Annex G compliant stream\",\n\t\t.fourcc = V4L2_PIX_FMT_VC1_ANNEX_G,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_VC1_ANNEX_G */\n#ifdef V4L2_PIX_FMT_VC1_ANNEX_L\n\t{\n\t\t.name = \"SMPTE 421M Annex L compliant stream\",\n\t\t.fourcc = V4L2_PIX_FMT_VC1_ANNEX_L,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_VC1_ANNEX_L */\n#ifdef V4L2_PIX_FMT_VP8\n\t{\n\t\t.name = \"VP8\",\n\t\t.fourcc = V4L2_PIX_FMT_VP8,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_VP8 */\n#ifdef V4L2_PIX_FMT_VP9\n\t{\n\t\t.name = \"VP9\",\n\t\t.fourcc = V4L2_PIX_FMT_VP9,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_VP9 */\n#ifdef V4L2_PIX_FMT_HEVC\n\t{\n\t\t.name = \"HEVC\",\n\t\t.fourcc = V4L2_PIX_FMT_HEVC,\n\t\t.depth = 32,\n\t\t.flags = FORMAT_FLAGS_COMPRESSED,\n\t},\n#endif /* V4L2_PIX_FMT_HEVC */\n};\n"
        },
        {
          "name": "vagrant",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}