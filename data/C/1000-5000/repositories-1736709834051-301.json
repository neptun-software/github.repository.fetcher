{
  "metadata": {
    "timestamp": 1736709834051,
    "page": 301,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "json-c/json-c",
      "stars": 3005,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 1.7041015625,
          "content": "BasedOnStyle:  LLVM\n# If true, clang-format will attempt to re-flow comments\nReflowComments: false\n# The column limit.\nColumnLimit: 100\n# Indent width for line continuations.\nContinuationIndentWidth: 4\n# The number of columns to use for indentation.\nIndentWidth: 8\n# The number of columns used for tab stops.\nTabWidth: 8\nUseTab: ForIndentation\n\n# Options for aligning backslashes in escaped newlines.\nAlignEscapedNewlines: Left\n# Short Block Style\nAllowShortBlocksOnASingleLine:  true\n# If true, short case labels will be contracted to a single line.\nAllowShortCaseLabelsOnASingleLine: true\n# Dependent on the value, int f() { return 0; } can be put on a single line.\nAllowShortFunctionsOnASingleLine:  Empty\n# The brace breaking style to use.\nBreakBeforeBraces: Custom\n# Control of individual brace wrapping cases.\nBraceWrapping:\n  # Wrap brackets inside of a case\n  AfterCaseLabel: true\n  # Wrap class definition.\n  AfterClass: true\n  # Wrap control statements\n  AfterControlStatement: true\n  # Wrap enum definitions.\n  AfterEnum: true\n  # Wrap function definitions.\n  AfterFunction: true\n  # Wrap namespace definitions.\n  AfterNamespace: true\n  # Wrap struct definitions.\n  AfterStruct: true\n  # Wrap union definitions.\n  AfterUnion: true\n  # Wrap extern blocks.\n  AfterExternBlock: false\n  # Wrap before catch.\n  BeforeCatch: true\n  # Wrap before else.\n  BeforeElse: true\n  # Indent the wrapped braces themselves.\n  IndentBraces:  false\n  # If false, empty function body can be put on a single line.\n  SplitEmptyFunction:  false\n  # If false, empty record (e.g. class, struct or union) body can be put on a single line.\n  SplitEmptyRecord:  false\n  # If false, empty namespace body can be put on a single line.\n  SplitEmptyNamespace:  false\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.2548828125,
          "content": "# EditorConfig\n# https://EditorConfig.org\n\n# top-most EditorConfig file\nroot = true\n\n# LF end-of-line, insert an empty new line and UTF-8\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\n\n# Tab indentation\n[makefile,Makefile]\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.2412109375,
          "content": "# Temp files\n*~\n*.swp\n*.bak\n*.backup\n\\#*\n.\\#*\n*\\#\n*.sav\n*.save\n*.autosav\n*.autosave\n.DS_Store\n\n# Tests\n/tests/Makefile\n/tests/test1\n/tests/test1Formatted\n/tests/test2\n/tests/test2Formatted\n/tests/test4\n/tests/testReplaceExisting\n/tests/testSubDir\n/tests/test_cast\n/tests/test_charcase\n/tests/test_compare\n/tests/test_deep_copy\n/tests/test_double_serializer\n/tests/test_float\n/tests/test_int_add\n/tests/test_int_get\n/tests/test_json_pointer\n/tests/test_locale\n/tests/test_null\n/tests/test_parse\n/tests/test_parse_int64\n/tests/test_printbuf\n/tests/test_set_serializer\n/tests/test_set_value\n/tests/test_util_file\n/tests/test_visit\n/tests/*.vg.out\n/tests/*.log\n/tests/*.trs\n\n# Generated folders\n/build\n/Debug\n/Release\n/*/Debug\n/*/Release\n\n# Archives\n*.zip\n*.tar.*\n*.tgz\n*.gz\n*.bz2\n*.xz\n*.lz\n*.lzma\n*.7z\n*.dll\n*.deb\n*.rpm\n*.apk\n*.exe\n*.msi\n*.dmg\n*.ipa\n\n# It's not good practice to build directly in the source tree\n# but ignore cmake auto-generated files anyway:\n/json_config.h\n/json.h\n/config.h\n/json-c.pc\n/Makefile\n/CMakeCache.txt\n/CMakeFiles\n/CMakeDoxyfile.in\n/*.cmake\n/DartConfiguration.tcl\n/tests/CMakeFiles/\n/tests/*.cmake\n/Testing/\n\n# ...and build artifacts.\n/doc/html\n/libjson-c.a\n/libjson-c.so\n/libjson-c.so.*\n\n# Benchmarking input and output\n/bench/data\n/bench/work\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 3.4345703125,
          "content": "language: cpp\nmatrix:\n  include:\n\n#   ubuntu xenial 16.04\n#   gcc 5 is the default on xenial\n    - os: linux\n      dist: xenial\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - valgrind\n            - cppcheck\n            - doxygen\n            - cmake\n      env: CHECK=\"true\"\n\n#   ubuntu bionic 18.04\n#   gcc 7 is the default on bionic\n    - os: linux\n      dist: bionic\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - valgrind\n            - cppcheck\n            - doxygen\n            - cmake\n      env: CHECK=\"true\"\n\n#   ubuntu focal fossa 20.04\n#   gcc 9 is the default on bionic\n    - os: linux\n      dist: focal\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - valgrind\n            - cppcheck\n            - doxygen\n            - cmake\n      env: CHECK=\"true\"\n\n# clang\n#   xenial\n    - os: linux\n      dist: xenial\n      compiler: clang\n      addons:\n        apt:\n          sources:\n            - llvm-toolchain-xenial-6.0\n          packages:\n            - clang-6.0\n            - cmake\n      env: MATRIX_EVAL=\"CC=clang-6.0 && CXX=clang++-6.0\"\n\n    # clang-7 is the default on focal, xenial and bionic\n    - os: linux\n      dist: focal\n      compiler: clang\n      addons:\n        apt:\n          packages:\n            - valgrind\n            - cppcheck\n            - doxygen\n            - cmake\n      env: CHECK=\"true\"\n\n# osx\n    - os: osx\n      osx_image: xcode13.4\n      env: XCODE=\"true\" CHECK=\"true\"\n\n# run coveralls\n    - os: linux\n      dist: xenial\n      compiler: gcc\n      addons:\n        apt:\n          packages:\n            - lcov\n      env: CHECK=\"true\"\n      before_install:\n        - sudo gem install coveralls-lcov\n        - echo $CC\n        - echo $LANG\n        - echo $LC_ALL\n        - set -e\n        - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then\n            eval \"${MATRIX_EVAL}\";\n            if [ -n \"$MATRIX_EVAL\" ] && [ \"$TRAVIS_COMPILER\" != \"clang\" ]; then\n              sudo apt-get install -y $CC;\n            fi;\n          fi\n      before_script:\n        - export CFLAGS=\"-fprofile-arcs -ftest-coverage\"\n        - mkdir build && cd build && cmake ..\n      script:\n        - make\n        - make test\n      after_success:\n        - cd ..\n        - lcov -d build/ -b . -c -o build/all_coverage.info\n        - lcov -r build/all_coverage.info '/usr/*' '*CMakeFiles*' '*fuzz*' '*test*' -o build/coverage.info\n        - coveralls-lcov --verbose build/coverage.info\n\n#  allow_failures:\n#    - os: osx\n\nbefore_install:\n  - echo $CC\n  - echo $LANG\n  - echo $LC_ALL\n  - set -e\n  - if [ \"$TRAVIS_OS_NAME\" = \"linux\" ]; then\n      eval \"${MATRIX_EVAL}\";\n      if [ -n \"$MATRIX_EVAL\" ] && [ \"$TRAVIS_COMPILER\" != \"clang\" ]; then\n        sudo apt-get install -y $CC;\n      fi;\n    fi\n\nbefore_script:\n  # XXX osx on travis doesn't work w/ set -e, so turn it off :(\n  - set +e\n  - mkdir -p build || echo \"Failed to mkdir build\"\n  - cd build || echo \"Failed to cd build\"\n  - cmake .. || echo \"Failed to run cmake\"\n\nscript:\n  - make\n  # when using bionic, Travis seems to ignore the \"addons\" section, so installing the packages with apt-get...\n  - if [ -n \"$CHECK\" ]; then\n      if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n        brew install doxygen;\n      else\n        if [ \"$TRAVIS_DIST\" = \"bionic\" ]; then\n          sudo apt-get install -y valgrind cppcheck doxygen;\n        fi;\n      fi;\n      make distcheck;\n      if type cppcheck &> /dev/null ; then cppcheck --error-exitcode=1 --quiet *.h *.c tests/ ; fi;\n    fi\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 2.9560546875,
          "content": "Alan Coopersmith <alan.coopersmith@oracle.com>\nAlan Urmancheev <108410815+alurm@users.noreply.github.com>\nAlexander Dahl <post@lespocky.de>\nAlexandru Ardelean <ardeleanalex@gmail.com>\nAn7ar35 <eadavison@protonmail.com>\nandy5995 <andy400-dev@yahoo.com>\nAram Poghosyan <Aram.Poghosyan@teamviewer.com>\nBjörn Esser <besser82@fedoraproject.org>\nBonsaY <bonsay@posteo.de>\nBruno Haible <bruno@clisp.org>\nchangyong guo <guo1487@163.com>\nchenguoping <chenguopingdota@163.com>\nChris Lamb <lamby@debian.org>\nChristopher Head <chead@chead.ca>\nChris Wolfe <chriswwolfe@gmail.com>\nC. Watford (christopher.watford@gmail.com)\nDaniel Danzberger <daniel@dd-wrt.com>\nDarjan Krijan <darjan_krijan@gmx.de>\nDavid McCann <mccannd@uk.ibm.com>\nDeX77 <dex@dragonslave.de>\nDimitri Papadopoulos <3234522+DimitriPapadopoulos@users.noreply.github.com>\ndota17 <chenguopingdota@163.com>\nEric Haszlakiewicz <erh+git@nimenees.com>\nEric Hawicz <erh+git@nimenees.com>\nEven Rouault <even.rouault@spatialys.com>\nevo <149657734+evo-i@users.noreply.github.com>\nFabrice Fontaine <fontaine.fabrice@gmail.com>\nFederico Francescon <federico.francescon@higeco.com>\nGianluigi Tiesi <sherpya@netfarm.it>\ngrdowns <grdowns@microsoft.com>\nHansolChoe <hansol614@gmail.com>\nHex052 <elijahiff@gmail.com>\nhofnarr <hofnarr@hofnarr.fi>\nihsinme <61293369+ihsinme@users.noreply.github.com>\nIvan Romanov <drizt@land.ru>\nJaap Keuter <jaap.keuter@xs4all.nl>\nJakov Smolic <jakov.smolic@sartura.hr>\njanczer <menshikov.ivn@gmail.com>\nJC (Jonathan Chen) <jc@dijonkitchen.org>\nJehan <jehan@girinstud.io>\nJehiah Czebotar <jehiah@gmail.com>\nJonathan Wiens <j.wiens@teles.com>\nJose Bollo <jose.bollo@iot.bzh>\nJosé Bollo <jose.bollo@iot.bzh>\nJuuso Alasuutari <juuso.alasuutari@gmail.com>\nKeith Holman <keith.holman@windriver.com>\nKhem Raj <raj.khem@gmail.com>\nKizuna-Meraki <z9@kizunameraki.de>\nLeon Gross <leon.gross@rub.de>\nLiang, Gao <liang.gao@intel.com>\nLuca Mannella <luca.mannella@studenti.polito.it>\nMarc <34656315+MarcT512@users.noreply.github.com>\nMatthias Gatto <matthias.gatto@protonmail.com>\nmax <mpano91@gmail.com>\nMicah Snyder <micasnyd@cisco.com>\nMichael Clark <michael@metaparadigm.com>\nmyd7349 <myd7349@gmail.com>\nPascal Cuoq <cuoq@trust-in-soft.com>\nPavel Zwerschke <pavelzw@gmail.com>\nPawday <pawday@mail.ru>\nPhilosoph228 <philosoph228@gmail.com>\nPierce Lopez <pierce.lopez@gmail.com>\nPo-Chuan Hsieh <sunpoet@sunpoet.net>\nRamiro Polla <ramiro.polla@gmail.com>\nRikard Falkeborn <rikard.falkeborn@gmail.com>\nRobert Bielik <robert.bielik@dirac.com>\nRobert Pang <robertpang@google.com>\nRobert <roby_p97@yahoo.com>\nRolf Eike Beer <eb@emlix.com>\nRosen Penev <rosenp@gmail.com>\nRubasri Kalidas <rubasri.kalidas@intel.com>\nSergey Sharshunov <s.sharshunov@gmail.com>\nSimon McVittie <smcv@collabora.com>\nssrlive <30760636+ssrlive@users.noreply.github.com>\nTobias Nießen <tniessen@users.noreply.github.com>\nTobias Stoeckmann <tobias@stoeckmann.org>\nTudor Brindus <me@tbrindus.ca>\nUnmanned Player <36690541+unmanned-player@users.noreply.github.com>\nYurii Rashkovskii <yrashk@gmail.com>\n"
        },
        {
          "name": "Android.configure.mk",
          "type": "blob",
          "size": 1.4501953125,
          "content": "# This file is the top android makefile for all sub-modules.\n#\n# Suggested settings to build for Android:\n#\n# export PATH=$PATH:/opt/android-ndk/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/\n# export SYSROOT=/opt/android-ndk/platforms/android-9/arch-arm/usr/\n# export LD=arm-linux-androideabi-ld\n# export CC=\"arm-linux-androideabi-gcc --sysroot=/opt/android-ndk/platforms/android-9/arch-arm\"\n#\n# Then run autogen.sh, configure and make.\n#\n\nLOCAL_PATH := $(call my-dir)\ninclude $(CLEAR_VARS)\n\njson_c_TOP := $(LOCAL_PATH)\n\nJSON_C_BUILT_SOURCES := Android.mk\n\nJSON_C_BUILT_SOURCES := $(patsubst %, $(abspath $(json_c_TOP))/%, $(JSON_C_BUILT_SOURCES))\n\n.PHONY: json-c-configure json-c-configure-real\njson-c-configure-real:\n\techo $(JSON_C_BUILT_SOURCES)\n\tcd $(json_c_TOP) ; \\\n\t$(abspath $(json_c_TOP))/autogen.sh && \\\n\tCC=\"$(CONFIGURE_CC)\" \\\n\tCFLAGS=\"$(CONFIGURE_CFLAGS)\" \\\n\tLD=$(TARGET_LD) \\\n\tLDFLAGS=\"$(CONFIGURE_LDFLAGS)\" \\\n\tCPP=$(CONFIGURE_CPP) \\\n\tCPPFLAGS=\"$(CONFIGURE_CPPFLAGS)\" \\\n\tPKG_CONFIG_LIBDIR=$(CONFIGURE_PKG_CONFIG_LIBDIR) \\\n\tPKG_CONFIG_TOP_BUILD_DIR=/ \\\n\tac_cv_func_malloc_0_nonnull=yes \\\n\tac_cv_func_realloc_0_nonnull=yes \\\n\t$(abspath $(json_c_TOP))/$(CONFIGURE) --host=$(CONFIGURE_HOST) \\\n\t--prefix=/system \\\n\t&& \\\n\tfor file in $(JSON_C_BUILT_SOURCES); do \\\n\t\trm -f $$file && \\\n\t\tmake -C $$(dirname $$file) $$(basename $$file) ; \\\n\tdone\n\njson-c-configure: json-c-configure-real\n\nPA_CONFIGURE_TARGETS += json-c-configure\n\n-include $(json_c_TOP)/Android.mk\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 23.0400390625,
          "content": "# CMake 3.9 was released in 2017/07\n#  As of 2023, many versions of Linux, NetBSD and FreeBSD provide,\n#   and many OpenWRT packages require, much newer CMake packages.\n#  We're stopping before 3.10 because that version starts requiring\n#   c++11, which isn't available on e.g HPUX.\ncmake_minimum_required(VERSION 3.9...3.12)\n\n# JSON-C library is C only project.\n# PROJECT_VERSION{,_MAJOR,_MINOR,_PATCH} set by project():\nproject(json-c LANGUAGES C VERSION 0.18.99)\n\n# set default build type if not specified by user\nif(NOT CMAKE_BUILD_TYPE)\n\tset(CMAKE_BUILD_TYPE debug)\nendif()\n\nset(CMAKE_C_FLAGS_RELEASE   \"${CMAKE_C_FLAGS_RELEASE} -O2\")\n\ninclude(CTest)\n\n# Set some packaging variables.\nset(CPACK_PACKAGE_NAME              \"${PROJECT_NAME}\")\nset(CPACK_PACKAGE_VERSION_MAJOR     \"${PROJECT_VERSION_MAJOR}\")\nset(CPACK_PACKAGE_VERSION_MINOR     \"${PROJECT_VERSION_MINOR}\")\nset(CPACK_PACKAGE_VERSION_PATCH     \"${PROJECT_VERSION_PATCH}\")\nset(JSON_C_BUGREPORT                \"json-c@googlegroups.com\")\nset(CPACK_SOURCE_IGNORE_FILES\n        ${PROJECT_SOURCE_DIR}/build\n        ${PROJECT_SOURCE_DIR}/cmake-build-debug\n        ${PROJECT_SOURCE_DIR}/pack\n        ${PROJECT_SOURCE_DIR}/.idea\n        ${PROJECT_SOURCE_DIR}/.DS_Store\n        ${PROJECT_SOURCE_DIR}/.git\n        ${PROJECT_SOURCE_DIR}/.vscode)\n\ninclude(CheckSymbolExists)\ninclude(CheckIncludeFile)\ninclude(CheckIncludeFiles)\ninclude(CheckCSourceCompiles)\ninclude(CheckTypeSize)\ninclude(CPack)\ninclude(GNUInstallDirs)\ninclude(CMakePackageConfigHelpers)\n\noption(BUILD_SHARED_LIBS  \"Default to building shared libraries\" ON)\noption(BUILD_STATIC_LIBS  \"Default to building static libraries\" ON)\n\n# Generate a release merge and test it to verify the correctness of republishing the package.\nADD_CUSTOM_TARGET(distcheck\nCOMMAND make package_source\n    COMMAND tar -xvf \"${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source.tar.gz\"\n    COMMAND mkdir \"${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source/build\"\n    COMMAND cmake \"${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source/\" -B\"./${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source/build/\"\n    COMMAND make -C \"${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source/build\"\n    COMMAND make test -C \"${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source/build\"\n    COMMAND rm -rf \"${PROJECT_NAME}-${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}-Source\"\n)\n\n# Enable or disable features. By default, all features are turned off.\noption(DISABLE_BSYMBOLIC              \"Avoid linking with -Bsymbolic-function.\"               OFF)\noption(DISABLE_THREAD_LOCAL_STORAGE   \"Disable using Thread-Local Storage (HAVE___THREAD).\"   OFF)\noption(DISABLE_WERROR                 \"Avoid treating compiler warnings as fatal errors.\"     OFF)\noption(ENABLE_RDRAND                  \"Enable RDRAND Hardware RNG Hash Seed.\"                 OFF)\noption(ENABLE_THREADING               \"Enable partial threading support.\"                     OFF)\noption(OVERRIDE_GET_RANDOM_SEED       \"Override json_c_get_random_seed() with custom code.\"   OFF)\noption(DISABLE_EXTRA_LIBS             \"Avoid linking against extra libraries, such as libbsd.\" OFF)\noption(DISABLE_JSON_POINTER           \"Disable JSON pointer (RFC6901) and JSON patch support.\" OFF)\noption(DISABLE_JSON_PATCH             \"Disable JSON patch (RFC6902) support.\"                 OFF)\noption(NEWLOCALE_NEEDS_FREELOCALE     \"Work around newlocale bugs in old FreeBSD by calling freelocale\"  OFF)\noption(BUILD_APPS                     \"Default to building apps\" ON)\n\nif (AMIGA)\n    set(DISABLE_THREAD_LOCAL_STORAGE ON)\n    set(ENABLE_THREADING OFF)\n    set(BUILD_SHARED_LIBS OFF)\n    set(BUILD_APPS OFF)\n    set(DISABLE_STATIC_FPIC ON)\n    if ($ENV{CROSS_PFX} STREQUAL \"m68k-amigaos\")\n        set(AMIGA_M68K ON)\n        set(BUILD_TESTING OFF)\n        if (${M68K_CRT} STREQUAL \"newlib\")\n            set(NEWLIB ON)\n        elseif(${M68K_CRT} STREQUAL \"clib2\")\n            set(CLIB2 ON)\n        elseif(${M68K_CRT} STREQUAL \"ixemul\")\n            set(IXEMUL ON)\n        elseif(${M68K_CRT} STREQUAL \"nix20\")\n            set(NIX20 ON)\n        elseif(${M68K_CRT} STREQUAL \"nix13\")\n            set(NIX13 ON)\n        else()\n            set(NEWLIB ON)\n        endif()\n        message(STATUS \"Building for Motorola 68k AmigaOS using CRT: ${M68K_CRT}\")\n    elseif ($ENV{CROSS_PFX} STREQUAL \"ppc-amigaos\")\n        set(AMIGA_PPC ON)\n        message(STATUS \"Building for PowerPC AmigaOS\")\n    elseif($ENV{CROSS_PFX} STREQUAL \"ppc-morphos\")\n        set(MORPHOS ON)\n        if (NOIXEMUL)\n            message(STATUS \"Building for PowerPC MorphOS without ixemul\")\n            set(DISABLE_WERROR ON)\n            set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -noixemul\")\n        else()\n            message(STATUS \"Building for PowerPC MorphOS with ixemul\")\n        endif()\n    else()\n        message(FATAL_ERROR \"Unsupported AmigaOS target\")\n    endif()\nelse()\n    message(STATUS \"Building for ${CMAKE_SYSTEM_NAME}\")\nendif()\n\nif (UNIX OR MINGW OR CYGWIN OR AMIGA)\n    list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)\nendif()\n\nif (BUILD_SHARED_LIBS)\n    add_definitions(-D JSON_C_DLL)\nendif()\n\nif (UNIX OR AMIGA)\n    list(APPEND CMAKE_REQUIRED_LIBRARIES   m)\nendif()\n\nif (MSVC)\n    list(APPEND CMAKE_REQUIRED_DEFINITIONS /D_CRT_SECURE_NO_DEPRECATE)\n    list(APPEND CMAKE_REQUIRED_FLAGS /wd4996)\nendif()\n\nif (NOT DISABLE_STATIC_FPIC)\n    # Use '-fPIC'/'-fPIE' option.\n    # This will allow other libraries to statically link in libjson-c.a\n    # which in turn prevents crashes in downstream apps that may use\n    # a different JSON library with identical symbol names.\n    set(CMAKE_POSITION_INDEPENDENT_CODE ON)\nendif()\n\ncheck_include_file(\"fcntl.h\"        HAVE_FCNTL_H)\ncheck_include_file(\"inttypes.h\"     HAVE_INTTYPES_H)\ncheck_include_file(stdarg.h         HAVE_STDARG_H)\ncheck_include_file(strings.h        HAVE_STRINGS_H)\ncheck_include_file(string.h         HAVE_STRING_H)\ncheck_include_file(syslog.h         HAVE_SYSLOG_H)\n\n\ncheck_include_files(\"stdlib.h;stdarg.h;string.h;float.h\" STDC_HEADERS)\n\ncheck_include_file(unistd.h         HAVE_UNISTD_H)\ncheck_include_file(sys/types.h      HAVE_SYS_TYPES_H)\ncheck_include_file(sys/resource.h   HAVE_SYS_RESOURCE_H) # for getrusage\n\ncheck_include_file(\"dlfcn.h\"        HAVE_DLFCN_H)\ncheck_include_file(\"endian.h\"       HAVE_ENDIAN_H)\ncheck_include_file(\"limits.h\"       HAVE_LIMITS_H)\ncheck_include_file(\"locale.h\"       HAVE_LOCALE_H)\ncheck_include_file(\"memory.h\"       HAVE_MEMORY_H)\n\ncheck_include_file(stdint.h         HAVE_STDINT_H)\ncheck_include_file(stdlib.h         HAVE_STDLIB_H)\ncheck_include_file(sys/cdefs.h      HAVE_SYS_CDEFS_H)\ncheck_include_file(sys/param.h      HAVE_SYS_PARAM_H)\ncheck_include_file(sys/random.h     HAVE_SYS_RANDOM_H)\ncheck_include_file(sys/stat.h       HAVE_SYS_STAT_H)\ncheck_include_file(xlocale.h        HAVE_XLOCALE_H)\n\n# Set json-c specific vars to stamp into json_config.h\n# in a way that hopefully won't conflict with other\n# projects that use json-c.\nif (HAVE_INTTYPES_H)\n\tset(JSON_C_HAVE_INTTYPES_H 1)\nendif()\nif (HAVE_STDINT_H)\n\tset(JSON_C_HAVE_STDINT_H 1)\nendif()\n\ncheck_symbol_exists(_isnan          \"float.h\" HAVE_DECL__ISNAN)\ncheck_symbol_exists(_finite         \"float.h\" HAVE_DECL__FINITE)\n\nif ((MSVC AND NOT (MSVC_VERSION LESS 1800)) OR MINGW OR CYGWIN OR UNIX OR AMIGA)\n    check_symbol_exists(INFINITY    \"math.h\" HAVE_DECL_INFINITY)\n    check_symbol_exists(isinf       \"math.h\" HAVE_DECL_ISINF)\n    check_symbol_exists(isnan       \"math.h\" HAVE_DECL_ISNAN)\n    check_symbol_exists(nan         \"math.h\" HAVE_DECL_NAN)\nendif()\n\ncheck_symbol_exists(_doprnt         \"stdio.h\" HAVE_DOPRNT)\nif (UNIX OR MINGW OR CYGWIN OR AMIGA)\n    check_symbol_exists(snprintf    \"stdio.h\" HAVE_SNPRINTF)\nendif()\ncheck_symbol_exists(vasprintf       \"stdio.h\" HAVE_VASPRINTF)\ncheck_symbol_exists(vsnprintf       \"stdio.h\" HAVE_VSNPRINTF)\ncheck_symbol_exists(vprintf         \"stdio.h\" HAVE_VPRINTF)\nif (NOT AMIGA_M68K)\n    check_symbol_exists(arc4random      \"stdlib.h\" HAVE_ARC4RANDOM)\nendif()\nif (NOT HAVE_ARC4RANDOM AND DISABLE_EXTRA_LIBS STREQUAL \"OFF\")\n    check_include_file(bsd/stdlib.h HAVE_BSD_STDLIB_H)\n    if (HAVE_BSD_STDLIB_H)\n        list(APPEND CMAKE_REQUIRED_LIBRARIES \"bsd\")\n        unset(HAVE_ARC4RANDOM CACHE)\n        check_symbol_exists(arc4random   \"bsd/stdlib.h\" HAVE_ARC4RANDOM)\n        if (NOT HAVE_ARC4RANDOM)\n            list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES \"bsd\")\n        endif()\n    endif()\nendif()\n\nif (HAVE_FCNTL_H)\n    check_symbol_exists(open        \"fcntl.h\" HAVE_OPEN)\nendif()\nif (HAVE_STDLIB_H)\n    check_symbol_exists(realloc     \"stdlib.h\" HAVE_REALLOC)\nendif()\nif (HAVE_LOCALE_H)\n    check_symbol_exists(setlocale   \"locale.h\" HAVE_SETLOCALE)\n    check_symbol_exists(uselocale   \"locale.h\" HAVE_USELOCALE)\n    if (NOT NIX20 AND NOT NIX13)\n        # libnix does not fully support this yet\n        check_symbol_exists(duplocale   \"locale.h\" HAVE_DUPLOCALE)\n    endif()\nendif()\n\n# uClibc *intentionally* crashes in duplocale(), at least as of:\n# https://github.com/ffainelli/uClibc/blob/266bdc1/libc/misc/locale/locale.c#L1322\n# So, if it looks like we're compiling for a system like that just disable\n# locale handling entirely.\nexecute_process (COMMAND ${CMAKE_C_COMPILER} -dumpmachine ERROR_QUIET OUTPUT_VARIABLE CMAKE_GNU_C_MACHINE)\n\nif (CMAKE_GNU_C_MACHINE MATCHES \"uclibc\")\n\tmessage(STATUS \"Detected uClibc compiler, disabling locale handling\")\n\tset(HAVE_SETLOCALE 0)\n\tset(HAVE_USELOCALE 0)\nendif()\n\nif (HAVE_STRINGS_H)\n    check_symbol_exists(strcasecmp  \"strings.h\" HAVE_STRCASECMP)\n    check_symbol_exists(strncasecmp \"strings.h\" HAVE_STRNCASECMP)\nendif()\nif (HAVE_STRING_H)\n    check_symbol_exists(strdup      \"string.h\" HAVE_STRDUP)\n    check_symbol_exists(strerror    \"string.h\" HAVE_STRERROR)\nendif()\nif (HAVE_SYSLOG_H)\n    check_symbol_exists(vsyslog     \"syslog.h\" HAVE_VSYSLOG)\nendif()\nif (HAVE_SYS_RANDOM_H)\n    check_symbol_exists(getrandom   \"sys/random.h\" HAVE_GETRANDOM)\nendif()\nif (HAVE_SYS_RESOURCE_H)\n    check_symbol_exists(getrusage   \"sys/resource.h\" HAVE_GETRUSAGE)\nendif()\n\ncheck_symbol_exists(strtoll     \"stdlib.h\" HAVE_STRTOLL)\ncheck_symbol_exists(strtoull    \"stdlib.h\" HAVE_STRTOULL)\n\nset(json_c_strtoll \"strtoll\")\nif (NOT HAVE_STRTOLL)\n# Use _strtoi64 if strtoll is not available.\ncheck_symbol_exists(_strtoi64 \"stdlib.h\" __have_strtoi64)\nif (__have_strtoi64)\n    #set(HAVE_STRTOLL 1)\n    set(json_c_strtoll \"_strtoi64\")\nendif()\nendif()\n\nset(json_c_strtoull \"strtoull\")\nif (NOT HAVE_STRTOULL)\n# Use _strtoui64 if strtoull is not available.\ncheck_symbol_exists(_strtoui64 \"stdlib.h\" __have_strtoui64)\nif (__have_strtoui64)\n    #set(HAVE_STRTOULL 1)\n    set(json_c_strtoull \"_strtoui64\")\nendif()\nendif()\n\n\ncheck_type_size(int                 SIZEOF_INT)\ncheck_type_size(int64_t             SIZEOF_INT64_T)\ncheck_type_size(long                SIZEOF_LONG)\ncheck_type_size(\"long long\"         SIZEOF_LONG_LONG)\ncheck_type_size(\"size_t\"            SIZEOF_SIZE_T)\nif (MSVC)\nlist(APPEND CMAKE_EXTRA_INCLUDE_FILES BaseTsd.h)\ncheck_type_size(\"SSIZE_T\"           SIZEOF_SSIZE_T)\nelse()\ncheck_type_size(\"ssize_t\"           SIZEOF_SSIZE_T)\nendif()\n\ncheck_c_source_compiles(\n\"\nextern void json_object_get();\n__asm__(\\\".section .gnu.json_object_get\\\\n\\\\t.ascii \\\\\\\"Please link against libjson-c instead of libjson\\\\\\\"\\\\n\\\\t.text\\\");\nint main(int c, char *v) { return 0;}\n\"\nHAS_GNU_WARNING_LONG)\n\ncheck_c_source_compiles(\n  \"int main() { int i, x = 0; i = __sync_add_and_fetch(&x,1); return x; }\"\n  HAVE_ATOMIC_BUILTINS)\n\nif (NOT DISABLE_THREAD_LOCAL_STORAGE)\n  check_c_source_compiles(\n    \"__thread int x = 0; int main() { return 0; }\"\n    HAVE___THREAD)\n\n  if (HAVE___THREAD)\n      set(SPEC___THREAD __thread)\n  elseif (MSVC)\n      set(SPEC___THREAD __declspec(thread))\n  endif()\nendif()\n\n# Hardware random number is not available on Windows? Says, config.h.win32. Best to preserve compatibility.\nif (WIN32)\n    set(ENABLE_RDRAND 0)\nendif()\n\n# Once we've done basic symbol/header searches let's add them in.\nconfigure_file(${PROJECT_SOURCE_DIR}/cmake/config.h.in        ${PROJECT_BINARY_DIR}/config.h)\nmessage(STATUS \"Wrote ${PROJECT_BINARY_DIR}/config.h\")\nconfigure_file(${PROJECT_SOURCE_DIR}/cmake/json_config.h.in   ${PROJECT_BINARY_DIR}/json_config.h)\nmessage(STATUS \"Wrote ${PROJECT_BINARY_DIR}/json_config.h\")\n\nif (NOT DEFINED CMAKE_C_COMPILER_FRONTEND_VARIANT OR \"${CMAKE_C_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"\")  # only available in cmake 3.14+\n\tif (\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"MSVC\")\n\t\tset(CMAKE_C_COMPILER_FRONTEND_VARIANT \"MSVC\")\n\telseif (\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"GNU\")\n\t\tset(CMAKE_C_COMPILER_FRONTEND_VARIANT \"GNU\")\n\telseif (\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"Clang\")\n\t\t# Detect clang-cl.exe, it is Clang but with MSVC compatible command line arguments\n\t\texecute_process (COMMAND ${CMAKE_C_COMPILER} -? ERROR_QUIET OUTPUT_QUIET RESULT_VARIABLE _clang_result)\n\t\tif (_clang_result EQUAL 0)\n\t\t\tset(CMAKE_C_COMPILER_FRONTEND_VARIANT \"MSVC\")\n\t\telse()\n\t\t\tset(CMAKE_C_COMPILER_FRONTEND_VARIANT \"GNU\")\n\t\t\tmessage(STATUS, \"clang result is NOT 0\")\n\t\tendif()\n\tendif()\nendif()\n\nif (\"${CMAKE_C_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"GNU\" OR \"${CMAKE_C_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"Clang\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -ffunction-sections -fdata-sections\")\n\tif (\"${DISABLE_WERROR}\" STREQUAL \"OFF\")\n\t    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Werror\")\n\tendif()\n    if (AMIGA_M68K)\n        set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -fbaserel\")\n    endif()\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wall\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wcast-qual\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wno-error=deprecated-declarations\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wextra\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wwrite-strings\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wno-unused-parameter\")\n    if (NOT WIN32)\n        set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wstrict-prototypes\")\n    endif()\n\n    add_definitions(-D_GNU_SOURCE)\n\n    if (\"${CMAKE_C_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"Clang\")\n        # Remove this for 1.0 when we can bump the ABI and actually fix these warnings.\n        set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} -Wno-shorten-64-to-32\")\n    endif()\nelseif (\"${CMAKE_C_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"MSVC\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /DEBUG\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4100\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4996\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4244\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4706\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4702\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4127\")\n    set(CMAKE_C_FLAGS           \"${CMAKE_C_FLAGS} /wd4701\")\nendif()\n\nif (NOT (\"${CMAKE_C_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"MSVC\"))\n\tcheck_c_source_compiles(\n\t\"\n\t/* uClibc toolchains without threading barf when _REENTRANT is defined */\n\t#define _REENTRANT 1\n\t#include <sys/types.h>\n\tint main (void)\n\t{\n\t  return 0;\n\t}\n\t\"\n\tREENTRANT_WORKS\n\t)\n\tif (REENTRANT_WORKS)\n\t\tadd_compile_options(\"-D_REENTRANT\")\n\tendif()\n\n\t# OSX Mach-O doesn't support linking with '-Bsymbolic-functions'.\n\t# Others may not support it, too.\n\tlist(APPEND CMAKE_REQUIRED_LIBRARIES \"-Wl,-Bsymbolic-functions\")\n\tcheck_c_source_compiles(\n\t\"\n\tint main (void)\n\t{\n\t  return 0;\n\t}\n\t\"\n\tBSYMBOLIC_WORKS\n\t)\n\tlist(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES \"-Wl,-Bsymbolic-functions\")\n\tif (DISABLE_BSYMBOLIC STREQUAL \"OFF\" AND BSYMBOLIC_WORKS)\n\t\tset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -Wl,-Bsymbolic-functions\")\n\t\t# XXX need cmake>=3.13 for this:\n\t\t#add_link_options(\"-Wl,-Bsymbolic-functions\")\n\tendif()\n\n\tfile(WRITE \"${CMAKE_CURRENT_BINARY_DIR}/check-version-script.sym\" \"TEST { global: *; };\")\n\tlist(APPEND CMAKE_REQUIRED_LIBRARIES \"-Wl,--version-script,${CMAKE_CURRENT_BINARY_DIR}/check-version-script.sym\")\n\tcheck_c_source_compiles(\n\t\"\n\tint main (void)\n\t{\n\t  return 0;\n\t}\n\t\"\n\tVERSION_SCRIPT_WORKS\n\t)\n\tlist(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES \"-Wl,--version-script,${CMAKE_CURRENT_BINARY_DIR}/check-version-script.sym\")\n\tif (VERSION_SCRIPT_WORKS)\n\t\tset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -Wl,--version-script,${CMAKE_CURRENT_SOURCE_DIR}/json-c.sym\")\n\tendif()\nendif()\n\nif ($ENV{VALGRIND})\n\t# Build so that valgrind doesn't complain about linkhash.c\n    add_definitions(-DVALGRIND=1)\nendif()\n\nset(JSON_C_PUBLIC_HEADERS\n    # Note: config.h is _not_ included here\n    ${PROJECT_BINARY_DIR}/json_config.h\n\n    ${PROJECT_BINARY_DIR}/json.h\n    ${PROJECT_SOURCE_DIR}/arraylist.h\n    ${PROJECT_SOURCE_DIR}/debug.h\n    ${PROJECT_SOURCE_DIR}/json_c_version.h\n    ${PROJECT_SOURCE_DIR}/json_inttypes.h\n    ${PROJECT_SOURCE_DIR}/json_object.h\n    ${PROJECT_SOURCE_DIR}/json_object_iterator.h\n    ${PROJECT_SOURCE_DIR}/json_tokener.h\n    ${PROJECT_SOURCE_DIR}/json_types.h\n    ${PROJECT_SOURCE_DIR}/json_util.h\n    ${PROJECT_SOURCE_DIR}/json_visit.h\n    ${PROJECT_SOURCE_DIR}/linkhash.h\n    ${PROJECT_SOURCE_DIR}/printbuf.h\n)\n\nset(JSON_C_HEADERS\n    ${JSON_C_PUBLIC_HEADERS}\n    ${PROJECT_SOURCE_DIR}/json_object_private.h\n    ${PROJECT_SOURCE_DIR}/json_pointer_private.h\n    ${PROJECT_SOURCE_DIR}/random_seed.h\n    ${PROJECT_SOURCE_DIR}/strerror_override.h\n    ${PROJECT_SOURCE_DIR}/math_compat.h\n    ${PROJECT_SOURCE_DIR}/snprintf_compat.h\n    ${PROJECT_SOURCE_DIR}/strdup_compat.h\n    ${PROJECT_SOURCE_DIR}/vasprintf_compat.h\n)\n\nset(JSON_C_SOURCES\n    ${PROJECT_SOURCE_DIR}/arraylist.c\n    ${PROJECT_SOURCE_DIR}/debug.c\n    ${PROJECT_SOURCE_DIR}/json_c_version.c\n    ${PROJECT_SOURCE_DIR}/json_object.c\n    ${PROJECT_SOURCE_DIR}/json_object_iterator.c\n    ${PROJECT_SOURCE_DIR}/json_tokener.c\n    ${PROJECT_SOURCE_DIR}/json_util.c\n    ${PROJECT_SOURCE_DIR}/json_visit.c\n    ${PROJECT_SOURCE_DIR}/linkhash.c\n    ${PROJECT_SOURCE_DIR}/printbuf.c\n    ${PROJECT_SOURCE_DIR}/random_seed.c\n    ${PROJECT_SOURCE_DIR}/strerror_override.c\n)\n\nif (NOT DISABLE_JSON_POINTER)\n    set(JSON_C_PUBLIC_HEADERS   ${JSON_C_PUBLIC_HEADERS}  ${PROJECT_SOURCE_DIR}/json_pointer.h)\n    set(JSON_C_SOURCES          ${JSON_C_SOURCES}         ${PROJECT_SOURCE_DIR}/json_pointer.c)\n    set(JSON_H_JSON_POINTER \"#include \\\"json_pointer.h\\\"\")\n\n    if (NOT DISABLE_JSON_PATCH)\n        set(JSON_C_PUBLIC_HEADERS   ${JSON_C_PUBLIC_HEADERS}  ${PROJECT_SOURCE_DIR}/json_patch.h)\n        set(JSON_C_SOURCES          ${JSON_C_SOURCES}         ${PROJECT_SOURCE_DIR}/json_patch.c)\n\tset(JSON_H_JSON_PATCH \"#include \\\"json_patch.h\\\"\")\n    endif()\nelse()\n    set(JSON_H_JSON_POINTER \"\")\n    set(JSON_H_JSON_PATCH \"\")\nendif()\n\nconfigure_file(json.h.cmakein ${PROJECT_BINARY_DIR}/json.h @ONLY)\n\ninclude_directories(${PROJECT_SOURCE_DIR})\ninclude_directories(${PROJECT_BINARY_DIR})\n\nadd_subdirectory(doc)\n\n# \"uninstall\" custom target for make generators in unix like operating systems\n# and if that target is not present\nif (CMAKE_GENERATOR STREQUAL \"Unix Makefiles\")\n    if(NOT TARGET uninstall)\n        add_custom_target(uninstall\n                COMMAND cat ${PROJECT_BINARY_DIR}/install_manifest.txt | xargs rm\n                WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n                )\n    endif()\nendif()\n\n# XXX for a normal full distribution we'll need to figure out\n# XXX how to build both shared and static libraries.\n# Probably leverage that to build a local VALGRIND=1 library for testing too.\nadd_library(${PROJECT_NAME}\n    ${JSON_C_SOURCES}\n    ${JSON_C_HEADERS}\n)\nset_target_properties(${PROJECT_NAME} PROPERTIES\n    VERSION 5.4.0\n    SOVERSION 5)\nlist(APPEND CMAKE_TARGETS ${PROJECT_NAME})\n# If json-c is used as subroject it set to target correct interface -I flags and allow\n# to build external target without extra include_directories(...)\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n        $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n        $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>\n)\n\ntarget_link_libraries(${PROJECT_NAME} PUBLIC ${CMAKE_REQUIRED_LIBRARIES})\n\n# Allow to build static and shared libraries at the same time\nif (BUILD_STATIC_LIBS AND BUILD_SHARED_LIBS)\n    set(STATIC_LIB ${PROJECT_NAME}-static)\n    add_library(${STATIC_LIB} STATIC\n        ${JSON_C_SOURCES}\n        ${JSON_C_HEADERS}\n    )\n    target_include_directories(${PROJECT_NAME}-static\n        PUBLIC\n            $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>\n            $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>\n    )\n\n\ttarget_link_libraries(${PROJECT_NAME}-static PUBLIC ${CMAKE_REQUIRED_LIBRARIES})\n\n    # rename the static library\n    if (NOT MSVC)\n    set_target_properties(${STATIC_LIB} PROPERTIES\n        OUTPUT_NAME ${PROJECT_NAME}\n    )\n    endif()\n    list(APPEND CMAKE_TARGETS ${STATIC_LIB})\nendif ()\n\n# Always create new install dirs with 0755 permissions, regardless of umask\nset(CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS\n\tOWNER_READ\n\tOWNER_WRITE\n\tOWNER_EXECUTE\n\tGROUP_READ\n\tGROUP_EXECUTE\n\tWORLD_READ\n\tWORLD_EXECUTE\n   )\n\ninstall(TARGETS ${CMAKE_TARGETS}\n    EXPORT ${PROJECT_NAME}-targets\n    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n    INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} ${CMAKE_INSTALL_INCLUDEDIR}/json-c\n)\n\ninstall(EXPORT ${PROJECT_NAME}-targets\n    FILE ${PROJECT_NAME}-targets.cmake\n    NAMESPACE ${PROJECT_NAME}::\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\n)\n\nconfigure_package_config_file(\n    \"cmake/Config.cmake.in\"\n    ${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake\n    INSTALL_DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\"\n)\n\ninstall(\n    FILES ${PROJECT_BINARY_DIR}/${PROJECT_NAME}-config.cmake\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\n)\n\n    SET(prefix ${CMAKE_INSTALL_PREFIX})\n    # exec_prefix is prefix by default and CMake does not have the\n    # concept.\n    SET(exec_prefix ${CMAKE_INSTALL_PREFIX})\n    SET(libdir ${CMAKE_INSTALL_FULL_LIBDIR})\n    SET(includedir ${CMAKE_INSTALL_FULL_INCLUDEDIR})\n    SET(VERSION ${PROJECT_VERSION})\n\n\t# Linking against the static json-c requires\n\t# dependent packages to include additional libs:\n\tSET(LIBS_LIST ${CMAKE_REQUIRED_LIBRARIES})\n\n\t# Note: We would need cmake >= 3.12 in order to use list(TRANSFORM ...)\n\tfunction(list_transform_prepend var prefix)\n\t\tset(temp \"\")\n\t\tforeach(f ${${var}})\n\t\t\tlist(APPEND temp \"${prefix}${f}\")\n\t\tendforeach()\n\t\tset(${var} \"${temp}\" PARENT_SCOPE)\n\tendfunction()\n\tlist_transform_prepend(LIBS_LIST \"-l\")\n\n\tstring(REPLACE \";\" \" \" LIBS \"${LIBS_LIST}\")\n\n    configure_file(json-c.pc.in json-c.pc @ONLY)\n    set(INSTALL_PKGCONFIG_DIR \"${CMAKE_INSTALL_LIBDIR}/pkgconfig\" CACHE PATH \"Installation directory for pkgconfig (.pc) files\")\n    install(FILES ${PROJECT_BINARY_DIR}/json-c.pc DESTINATION \"${INSTALL_PKGCONFIG_DIR}\")\n\ninstall(FILES ${JSON_C_PUBLIC_HEADERS} DESTINATION ${CMAKE_INSTALL_FULL_INCLUDEDIR}/json-c)\n\nif (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND BUILD_TESTING AND\n   (NOT MSVC OR NOT (MSVC_VERSION LESS 1800)) # Tests need at least VS2013\n   )\nadd_subdirectory(tests)\nendif()\n\nif (CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND BUILD_APPS)\n# skip apps when we're included in someone else's build\nif (NOT MSVC)  # cmd line apps don't built on Windows currently.\nadd_subdirectory(apps)\nendif()\nendif()\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 2.1533203125,
          "content": "\nCopyright (c) 2009-2012 Eric Haszlakiewicz\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n----------------------------------------------------------------\n\nCopyright (c) 2004, 2005 Metaparadigm Pte Ltd\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 29.90625,
          "content": "0.18.99 (future release)\n========================================\n\nDeprecated and removed features:\n--------------------------------\n* none yet\n\nNew features\n------------\n* none yet\n\nSignificant changes and bug fixes\n---------------------------------\n* none yet\n\n0.18 (up to commit 6bfab90, 2024-09-15)\n========================================\n\nDeprecated and removed features:\n--------------------------------\n* Clean up pre-3.9 CMake support in CMakeLists.txt\n\nNew features\n------------\n* Build pkg-config for msvc as well\n\nSignificant changes and bug fixes\n---------------------------------\n* Critical fix for binary compatibility with 0.16: Move the\n  json_tokener_error_memory entry to the end of enum json_tokener_error.\n* Issue #829: attempt to detect clang-cl.exe and pass MSVC-compatile command\n  line arguments.\n* PR #831 - rename WIN32 to _WIN32\n* PR #839 - Fix gcc 5 \"may be used uninitialized\" failure in json_pointer.c\n* PR #849 - random_seed.c: add a Coverity Scan suppression\n* Issue #854: Set error=json_tokener_error_memory in\n  json_tokener_parser_verbose() when allocating the tokener fails.\n* Issue #857: fix a few places where json_tokener should have been returning\n  json_tokener_error_memory but wasn't.\n* Handle yet another out-of-memory condition in json_tokener, duplocate can \n  return NULL.\n* Various fixes in the fuzzers\n* A few minor doc fixes\n\n***\n\n0.17 (up to commit 077661f, 2023-08-08)\n========================================\n\nKnown Bugs\n----------\n* DO NOT USE THE 0.17 RELEASE: json_tokener_error_memory in misplaced in the\n  json_tokener_error enum, leading to binary compatibility issues.\n\nDeprecated and removed features:\n--------------------------------\n* None\n\nNew features\n------------\n* json_patch: add first implementation only with patch application\n* Add --disable-static and --disable-dynamic options to the cmake-configure script.\n* Add -DBUILD_APPS=NO option to disable app build\n* Minimum cmake version is now 3.9\n\nSignificant changes and bug fixes\n---------------------------------\n* When serializing with JSON_C_TO_STRING_PRETTY set, keep the opening and \n  closing curly or square braces on same line for empty objects or arrays.\n* Disable locale handling when targeting a uClibc system due to problems\n  with its duplocale() function.\n* When parsing with JSON_TOKENER_STRICT set, integer overflow/underflow\n  now result in a json_tokener_error_parse_number.  Without that flag\n  values are capped at INT64_MIN/UINT64_MAX.\n* Fix memory leak with emtpy strings in json_object_set_string\n* json_object_from_fd_ex: fail if file is too large (>=INT_MAX bytes)\n* Add back json_number_chars, but only because it's part of the public API.\n* Entirely drop mode bits from open(O_RDONLY) to avoid warnings on certain\n  platforms.\n* Specify dependent libraries, including -lbsd, in a more consistent way so\n  linking against a static json-c works better\n* Fix a variety of build problems and add & improve tests\n* Update RFC reference to https://www.rfc-editor.org/rfc/rfc8259\n\n***\n\n0.16 (up to commit 66dcdf5, 2022-04-13)\n========================================\n\nDeprecated and removed features:\n--------------------------------\n* JSON_C_OBJECT_KEY_IS_CONSTANT is deprecated in favor of\n  JSON_C_OBJECT_ADD_CONSTANT_KEY\n* Direct access to lh_table and lh_entry structure members is deprecated.  \n  Use access functions instead, lh_table_head(), lh_entry_next(), etc...\n* Drop REFCOUNT_DEBUG code.\n\nNew features\n------------\n* The 0.16 release introduces no new features\n\nBuild changes\n-------------\n* Add a DISABLE_EXTRA_LIBS option to skip using libbsd\n* Add a DISABLE_JSON_POINTER option to skip compiling in json_pointer support.\n\nSignificant changes and bug fixes\n---------------------------------\n* Cap string length at INT_MAX to avoid various issues with very long strings.\n* json_object_deep_copy: fix deep copy of strings containing '\\0'\n* Fix read past end of buffer in the \"json_parse\" command\n* Avoid out of memory accesses in the locally provided vasprintf() function\n  (for those platforms that use it)\n* Handle allocation failure in json_tokener_new_ex\n* Fix use-after-free in json_tokener_new_ex() in the event of printbuf_new() returning NULL\n* printbuf_memset(): set gaps to zero - areas within the print buffer which\n  have not been initialized by using printbuf_memset\n* printbuf: return -1 on invalid arguments (len < 0 or total buffer > INT_MAX)\n* sprintbuf(): propagate printbuf_memappend errors back to the caller\n\nOptimizations\n--------------\n* Speed up parsing by replacing ctype functions with simplified, faster \n  non-locale-sensitive ones in json_tokener and json_object_to_json_string.\n* Neither vertical tab nor formfeed are considered whitespace per the JSON spec\n* json_object: speed up creation of objects, calloc() -> malloc() + set fields\n* Avoid needless extra strlen() call in json_c_shallow_copy_default() and\n  json_object_equal() when the object is known to be a json_type_string.\n\nOther changes\n-------------\n* Validate size arguments in arraylist functions.\n* Use getrandom() if available; with GRND_NONBLOCK to allow use of json-c\n  very early during boot, such as part of cryptsetup.\n* Use arc4random() if it's available.\n* random_seed: on error, continue to next method instead of exiting the process\n* Close file when unable to read from /dev/urandom in get_dev_random_seed()\n\n***\n\n0.15 (up to commit 870965e, 2020/07/26)\n========================================\n\nDeprecated and removed features:\n--------------------------------\n* Deprecate `array_list_new()` in favor of `array_list_new2()`\n* Remove the THIS_FUNCTION_IS_DEPRECATED define.\n* Remove config.h.win32\n\nNew features\n------------\n* Add a `JSON_TOKENER_ALLOW_TRAILING_CHARS` flag to allow multiple objects\n  to be parsed even when `JSON_TOKENER_STRICT` is set.\n* Add `json_object_new_array_ext(int)` and `array_list_new_2(int)` to allow\n   arrays to be allocated with the exact size needed, when known.\n* Add `json_object_array_shrink()` (and `array_list_shrink()`) and use it in \n   json_tokener to minimize the amount of memory used.\n* Add a json_parse binary, for use in testing changes (not installed, but \n   available in the apps directory).\n\nBuild changes\n-------------\n* #639/#621 - Add symbol versions to all exported symbols\n* #508/#634 - Always enable -fPIC to allow use of the json-c static library in\n   other libraries\n* Build both static and shared libraries at the same time.\n* #626 - Restore compatibility with cmake 2.8 \n* #471 - Always create directories with mode 0755, regardless of umask.\n* #606/#604 - Improve support for OSes like AIX and IBM i, as well as for\n   MINGW32 and old versions of MSVC\n* #451/#617 - Add a DISABLE_THREAD_LOCAL_STORAGE cmake option to disable \n   the use of thread-local storage.\n\nSignificant changes and bug fixes\n---------------------------------\n* Split the internal json_object structure into several sub-types, one for\n   each json_type (json_object_object, json_object_string, etc...).\n  This improves memory usage and speed, with the benchmark under\n   bench/ report 5.8% faster test time and 6%(max RSS)-12%(peak heap)\n   less memory usage.\n  Memory used just for json_object structures decreased 27%, so use cases\n   with fewer arrays and/or strings would benefit more.\n* Minimize memory usage in array handling in json_tokener by shrinking\n   arrays to the exact number of elements parsed.  On bench/ benchmark:\n   9% faster test time, 39%(max RSS)-50%(peak heap) less memory usage.\n   Add json_object_array_shrink() and array_list_shrink() functions.\n* #616 - Parsing of surrogate pairs in unicode escapes now properly handles\n   incremental parsing.\n* Fix incremental parsing of numbers, especially those with exponents, e.g.\n   so parsing \"[0\", \"e+\", \"-]\" now properly returns an error.\n  Strict mode now rejects missing exponents (\"0e\").\n* Successfully return number objects at the top level even when they are\n   followed by a \"-\", \".\" or \"e\".  This makes parsing things like \"123-45\"\n   behave consistently with things like \"123xyz\".\n\nOther changes\n-------------\n* #589 - Detect broken RDRAND during initialization; also, fix segfault\n    in the CPUID check.\n* #592 - Fix integer overflows to prevert out of bounds write on large input.\n* Protect against division by zero in linkhash, when created with zero size.\n* #602 - Fix json_parse_uint64() internal error checking, leaving the retval\n    untouched in more failure cases.\n* #614 - Prevent truncation when custom double formatters insert extra \\0's\n\n\n***\n\n0.14 (up to commit 9ed00a6, 2020/04/14)\n=========================================\n\nDeprecated and removed features:\n--------------------------------\n* bits.h has been removed\n* lh_abort() has been removed\n* lh_table_lookup() has been removed, use lh_table_lookup_ex() instead.\n* Remove TRUE and FALSE defines, use 1 and 0 instead.\n\nBuild changes:\n--------------\n## Deprecated and removed features:\n* bits.h has been removed\n* lh_abort() has been removed\n* lh_table_lookup() has been removed, use lh_table_lookup_ex() instead.\n* Remove TRUE and FALSE defines, use 1 and 0 instead.\n* autoconf support, including autogen.sh, has been removed.  See details about cmake, below.\n* With the addition of json_tokener_get_parse_end(), access to internal fields of json_tokener, as well as use of many other symbols and types in json_tokener.h, is deprecated now.\n* The use of Android.configure.mk to build for Android no longer works, and it is unknown how (or if) the new cmake-based build machinery can be used.\n    * Reports of success, or pull requests to correct issues are welcome.\n\n## Notable improvements and new features\n\n### Builds and documentation\n* Build machinery has been switched to CMake.  See README.md for details about how to build.\n    * TL;DR: `mkdir build ; cd build ; cmake -DCMAKE_INSTALL_PREFIX=/some/path ../json-c ; make all test install`\n    * To ease the transition, there is a `cmake-configure` wrapper that emulates the old autoconf-based configure script.\n    * This has enabled improvements to the build on Windows system; also all public functions have been fixed to be properly exported.  For best results, use Visual Studio 2015 or newer.\n* The json-c style guide has been updated to specify the use of clang-format, and all code has been reformatted.\n    * Since many lines of code have trivial changes now, when using git blame, be sure to specify -w\n* Numerous improvements have been made to the documentation including function effects on refcounts, when passing a NULL is safe, and so on.\n\n### json_tokener changes\n* Added a json_tokener_get_parse_end() function to replace direct access of tok->char_offset.\n    * The char_offset field, and the rest of the json_tokener structure remain exposed for now, but expect a future release to hide it like is done with json_object_private.h\n* json_tokener_parse_ex() now accepts a new JSON_TOKENER_VALIDATE_UTF8 flag to validate that input is UTF8.\n    * If validation fails, json_tokener_get_error(tok) will return json_tokener_error_parse_utf8_string (see enum json_tokener_error).\n\n### Other changes and additions\n* Add support for unsigned 64-bit integers, uint64_t, to gain one extra bit of magnitude for positive ints.\n    * json_tokener will now parse values up to UINT64_MAX (18446744073709551615)\n    * Existing methods returning int32_t or int64_t will cap out-of-range values at INT32_MAX or INT64_MAX, preserving existing behavior.\n    * The implementation includes the possibility of easily extending this to larger sizes in the future.\n* A total of 7 new functions were added:\n    * json_object_get_uint64 ( struct json_object const* jso )\n    * json_object_new_uint64 ( uint64_t i )\n    * json_object_set_uint64 ( struct json_object* jso, uint64_t new_value )\n    * json_parse_uint64 ( char const* buf, uint64_t* retval )\n        * See description of uint64 support, above.\n    * json_tokener_get_parse_end ( struct json_tokener* tok )\n        * See details under \"json_tokener changes\", above.\n    * json_object_from_fd_ex ( int fd, int in_depth )\n        * Allows the max nesting depth to be specified.\n    * json_object_new_null ( )\n        * Simply returns NULL.  Its use is not recommended.\n* The size of struct json_object has decreased from 96 bytes to 88 bytes.\n\n### Testing\n* Many updates were made to test cases, increasing code coverage.\n* There is now a quick way (JSONC_TEST_TRACE=1) to turn on shell tracing in tests.\n* To run tests, use `make test`; the old \"check\" target no longer exists.\n\n## Significant bug fixes\nFor the full list of issues and pull requests since the previous release, please see issues_closed_for_0.14.md\n\n* [Issue #389](https://github.com/json-c/json-c/issues/389): Add an assert to explicitly crash when _ref_count is corrupted, instead of a later \"double free\" error.\n* [Issue #407](https://github.com/json-c/json-c/issues/407): fix incorrect casts in calls to ctype functions (isdigit and isspace) so we don't crash when asserts are enabled on certain platforms and characters > 128 are parsed.\n* [Issue #418](https://github.com/json-c/json-c/issues/418): Fix docs for json_util_from_fd and json_util_from_file to say that they return NULL on failures.\n* [Issue #422](https://github.com/json-c/json-c/issues/422): json_object.c:set errno in json_object_get_double() when called on a json_type_string object with bad content.\n* [Issue #453](https://github.com/json-c/json-c/issues/453): Fixed misalignment in JSON serialization when JSON_C_TO_STRING_SPACED and JSON_C_TO_STRING_PRETTY are used together.\n* [Issue #463](https://github.com/json-c/json-c/issues/463): fix newlocale() call to use LC_NUMERIC_MASK instead of LC_NUMERIC, and remove incorrect comment.\n* [Issue #486](https://github.com/json-c/json-c/issues/486): append a missing \".0\" to negative double values to ensure they are serialized as floating point numbers.\n* [Issue #488](https://github.com/json-c/json-c/issues/488): use JSON_EXPORT on functions so they are properly exported on Windows.\n* [Issue #539](https://github.com/json-c/json-c/issues/539): use an internal-only serializer function in json_object_new_double_s() to avoid potential conflicts with user code that uses the json_object_userdata_to_json_string serializer.\n\n***\n\n0.13.1 (up to commit 0f814e5, 2018/03/04)\n=========================================\n\n* Bump the major version of the .so library generated up to 4.0 to avoid\n  conflicts because some downstream packagers of json-c had already done\n  their own bump to \".so.3\" for a much older 0.12 release.\n* Add const size_t json_c_object_sizeof()\n* Avoid invalid free (and thus a segfault) when ref_count gets < 0\n* PR#394: fix handling of custom double formats that include a \".0\"\n* Avoid uninitialized variable warnings in json_object_object_foreach\n* Issue #396: fix build for certain uClibc based systems.\n* Add a top level fuzz directory for fuzzers run by OSS-Fuzz\n\n\n0.13 (up to commit 5dae561, 2017/11/29)\n=================================\n\nThis release, being three and a half years after the 0.12 branch (f84d9c),\n   has quite a number of changes included.  The following is a sampling of\n   the most significant ones.\n\nSince the 0.12 release, 250 issues and pull requests have been closed.\nSee issues_closed_for_0.13.md for a complete list.\n\n\nDeprecated and removed features:\n--------------------------------\n* All internal use of bits.h has been eliminated.  The file will be removed.\n\tDo not use: hexdigit(), error_ptr(), error_descrition() and it_error()\n* lh_abort() is deprecated.  It will be removed.\n\nBehavior changes:\n-----------------\n* Tighten the number parsing algorithm to raise errors instead of truncating\n     the results.  For example 12.3.4 or 2015-01-15, which now return null.\n\t See commit 99d8fc\n\n* Use size_t for array length and size.  Platforms where sizeof(size_t) != sizeof(int) may not be backwards compatible\n\tSee commits 45c56b, 92e9a5 and others.\n\n* Check for failure when allocating memory, returning NULL and errno=ENOMEM.\n\t See commit 2149a04.\n\n* Change json_object_object_add() return type from void to int, and will return -1 on failures, instead of exiting. (Note: this is not an ABI change)\n\nNew features:\n-------------\n* We're aiming to follow RFC 7159 now.\n\n* Add a couple of additional option to json_object_to_json_string_ext:\n\tJSON_C_TO_STRING_PRETTY_TAB\n\tJSON_C_TO_STRING_NOSLASHESCAPE\n\n* Add a json_object_object_add_ex() function to allow for performance\n\timprovements when certain constraints are known to be true.\n\n* Make serialization format of doubles configurable, in two different ways:\n\tCall json_object_set_serializer with json_object_double_to_json_string and a custom\n\t format on each double object, or\n\tCall json_c_set_serialization_double_format() to set a global or thread-wide format.\n\n* Add utility function for comparing json_objects - json_object_equal()\n\n* Add a way to copy entire object trees: json_object_deep_copy()\n* Add json_object_set_<type> function to modify the value of existing json_object's\n without the need to recreate them.  Also add a json_object_int_inc function to\n adjust an int's value.\n* Add support for JSON pointer, RFC 6901.  See json_pointer.h\n* Add a json_util_get_last_err() function to retrieve the string describing the\n cause of errors, instead of printing to stderr.\n* Add perllike hash function for strings, and json_global_set_string_hash() 8f8d03d\n* Add a json_c_visit() function to provide a way to iterate over a tree of json-c objects.\n\nNotable bug fixes and other improvements:\n-----------------------------------------\n* Make reference increment and decrement atomic to allow passing json objects between threads.\n* Fix json_object_object_foreach to avoid uninitialized variable warnings.\n* Improve performance by removing unneeded data items from hashtable code and reducing duplicate hash computation.\n* Improve performance by storing small strings inside json_object\n* Improve performance of json_object_to_json_string by removing variadic printf. commit 9ff0f49\n* Issue #371: fix parsing of \"-Infinity\", and avoid needlessly copying the input when doing so.\n* Fix stack buffer overflow in json_object_double_to_json_string_format() - commit 2c2deb87\n* Fix various potential null ptr deref and int32 overflows\n* Issue #332: fix a long-standing bug in array_list_put_idx() where it would attempt to free previously free'd entries due to not checking the current array length.\n* Issue #195: use uselocale() instead of setlocale() in json_tokener to behave better in threaded environments.\n* Issue #275: fix out of bounds read when handling unicode surrogate pairs.\n* Ensure doubles that happen to be a whole number are emitted with \".0\" - commit ca7a19\n* PR#331: for Visual Studio, use a snprintf/vsnprintf wrapper that ensures the string is terminated.\n* Fix double to int cast overflow in json_object_get_int64.\n* Clamp double to int32 when narrowing in json_object_get_int.\n* Use strtoll() to parse ints - instead of sscanf\n* Miscellaneous smaller changes, including removing unused variables, fixing warning\n about uninitialized variables adding const qualifiers, reformatting code, etc...\n\nBuild changes:\n--------------\n* Add Appveyor and Travis build support\n* Switch to using CMake when building on Windows with Visual Studio.\n\tA dynamic .dll is generated instead of a .lib\n\tconfig.h is now generated, config.h.win32 should no longer be manually copied\n* Add support for MacOS through CMake too.\n* Enable silent build by default\n* Link against libm when needed\n* Add support for building with AddressSanitizer\n* Add support for building with Clang\n* Add a --enable-threading configure option, and only use the (slower) __sync_add_and_fetch()/__sync_sub_and_fetch() function when it is specified.\n\nList of new functions added:\n----------------------------\n### json_object.h\n* array_list_bsearch()\n* array_list_del_idx()\n* json_object_to_json_string_length()\n* json_object_get_userdata()\n* json_object_set_userdata()\n* json_object_object_add_ex()\n* json_object_array_bsearch()\n* json_object_array_del_idx()\n* json_object_set_boolean()\n* json_object_set_int()\n* json_object_int_inc()\n* json_object_set_int64()\n* json_c_set_serialization_double_format()\n* json_object_double_to_json_string()\n* json_object_set_double()\n* json_object_set_string()\n* json_object_set_string_len()\n* json_object_equal()\n* json_object_deep_copy()\n\n### json_pointer.h\n* json_pointer_get()\n* json_pointer_getf()\n* json_pointer_set()\n* json_pointer_setf()\n\n### json_util.h\n* json_object_from_fd()\n* json_object_to_fd()\n* json_util_get_last_err()\n\n### json_visit.h\n* json_c_visit()\n\n### linkhash.h\n* json_global_set_string_hash()\n* lh_table_resize()\n\n### printbuf.h\n* printbuf_strappend()\n\n\n0.12.1\n======\n\n  * Minimal changes to address compile issues.\n\n0.12\n====\n\n  * Address security issues:\n    * CVE-2013-6371: hash collision denial of service\n    * CVE-2013-6370: buffer overflow if size_t is larger than int\n\n  * Avoid potential overflow in json_object_get_double\n\n  * Eliminate the mc_abort() function and MC_ABORT macro.\n\n  * Make the json_tokener_errors array local.  It has been deprecated for\n     a while, and json_tokener_error_desc() should be used instead.\n\n  * change the floating point output format to %.17g so values with\n     more than 6 digits show up in the output.\n\n  * Remove the old libjson.so name compatibility support.  The library is\n      only created as libjson-c.so now and headers are only installed\n      into the ${prefix}/json-c directory.\n\n  * When supported by the linker, add the -Bsymbolic-functions flag.\n\n  * Various changes to fix the build on MSVC.\n\n  * Make strict mode more strict:\n    * number must not start with 0\n    * no single-quote strings\n    * no comments\n    * trailing char not allowed\n    * only allow lowercase literals\n\n  * Added a json_object_new_double_s() convenience function to allow\n    an exact string representation of a double to be specified when\n    creating the object and use it in json_tokener_parse_ex() so\n    a re-serialized object more exactly matches the input.\n\n  * Add support NaN and Infinity\n\n\n0.11\n====\n\n  * IMPORTANT: the name of the library has changed to libjson-c.so and\n     the header files are now in include/json-c.\n     The pkgconfig name has also changed from json to json-c.\n     You should change your build to use appropriate -I and -l options.\n     A compatibility shim is in place so builds using the old name will\n     continue to work, but that will be removed in the next release.\n  * Maximum recursion depth is now a runtime option.\n     json_tokener_new() is provided for compatibility.\n     json_tokener_new_ex(depth)\n  * Include json_object_iterator.h in the installed headers.\n  * Add support for building on Android.\n  * Rewrite json_object_object_add to replace just the value if the key already exists so keys remain valid.\n  * Make it safe to delete keys while iterating with the json_object_object_foreach macro.\n  * Add a json_set_serializer() function to allow the string output of a json_object to be customized.\n  * Make float parsing locale independent.\n  * Add a json_tokener_set_flags() function and a JSON_TOKENER_STRICT flag.\n  * Enable -Werror when building.\n  * speed improvements to parsing 64-bit integers on systems with working sscanf\n  * Add a json_object_object_length function.\n  * Fix a bug (buffer overrun) when expanding arrays to more than 64 entries.\n\n0.10\n====\n\n  * Add a json_object_to_json_string_ext() function to allow output to be\n     formatted in a more human readable form.\n  * Add json_object_object_get_ex(), a NULL-safe get object method, to be able\n     to distinguish between a key not present and the value being NULL.\n  * Add an alternative iterator implementation, see json_object_iterator.h\n  * Make json_object_iter public to enable external use of the\n     json_object_object_foreachC macro.\n  * Add a printbuf_memset() function to provide an efficient way to set and\n     append things like whitespace indentation.\n  * Adjust json_object_is_type and json_object_get_type so they return\n      json_type_null for NULL objects and handle NULL passed to\n      json_objct_object_get().\n  * Rename boolean type to json_bool.\n  * Fix various compile issues for Visual Studio and MinGW.\n  * Allow json_tokener_parse_ex() to be re-used to parse multiple object.\n     Also, fix some parsing issues with capitalized hexadecimal numbers and\n     number in E notation.\n  * Add json_tokener_get_error() and json_tokener_error_desc() to better\n     encapsulate the process of retrieving errors while parsing.\n  * Various improvements to the documentation of many functions.\n  * Add new json_object_array_sort() function.\n  * Fix a bug in json_object_get_int(), which would incorrectly return 0\n    when called on a string type object.\n    Eric Haszlakiewicz\n  * Add a json_type_to_name() function.\n    Eric Haszlakiewicz\n  * Add a json_tokener_parse_verbose() function.\n    Jehiah Czebotar\n  * Improve support for null bytes within JSON strings.\n    Jehiah Czebotar\n  * Fix file descriptor leak if memory allocation fails in json_util\n    Zachary Blair, zack_blair at hotmail dot com\n  * Add int64 support. Two new functions json_object_net_int64 and\n    json_object_get_int64. Binary compatibility preserved.\n    Eric Haszlakiewicz, EHASZLA at transunion com\n    Rui Miguel Silva Seabra, rms at 1407 dot org\n  * Fix subtle bug in linkhash where lookup could hang after all slots\n    were filled then successively freed.\n    Spotted by Jean-Marc Naud, j dash m at newtraxtech dot com\n  * Make json_object_from_file take const char *filename\n    Spotted by Vikram Raj V, vsagar at attinteractive dot com\n  * Add handling of surrogate pairs (json_tokener.c, test4.c, Makefile.am)\n    Brent Miller, bdmiller at yahoo dash inc dot com\n  * Correction to comment describing printbuf_memappend in printbuf.h\n    Brent Miller, bdmiller at yahoo dash inc dot com\n\n0.9\n===\n  * Add README.html README-WIN32.html config.h.win32 to Makefile.am\n    Michael Clark, <michael@metaparadigm.com>\n  * Add const qualifier to the json_tokener_parse functions\n    Eric Haszlakiewicz, EHASZLA at transunion dot com\n  * Rename min and max so we can never clash with C or C++ std library\n    Ian Atha, thatha at yahoo dash inc dot com\n  * Fix any noticeable spelling or grammar errors.\n  * Make sure every va_start has a va_end.\n  * Check all pointers for validity.\n    Erik Hovland, erik at hovland dot org\n  * Fix json_object_get_boolean to return false for empty string\n    Spotted by Vitaly Kruglikov, Vitaly dot Kruglikov at palm dot com\n  * optimizations to json_tokener_parse_ex(), printbuf_memappend()\n    Brent Miller, bdmiller at yahoo dash inc dot com\n  * Disable REFCOUNT_DEBUG by default in json_object.c\n  * Don't use this as a variable, so we can compile with a C++ compiler\n  * Add casts from void* to type of assignment when using malloc\n  * Add #ifdef __cplusplus guards to all of the headers\n  * Add typedefs for json_object, json_tokener, array_list, printbuf, lh_table\n    Michael Clark, <michael@metaparadigm.com>\n  * Null pointer dereference fix. Fix json_object_get_boolean strlen test\n    to not return TRUE for zero length string. Remove redundant includes.\n    Erik Hovland, erik at hovland dot org\n  * Fixed warning reported by adding -Wstrict-prototypes\n    -Wold-style-definition to the compilatin flags.\n    Dotan Barak, dotanba at gmail dot com\n  * Add const correctness to public interfaces\n    Gerard Krol, g dot c dot krol at student dot tudelft dot nl\n\n0.8\n===\n  * Add va_end for every va_start\n    Dotan Barak, dotanba at gmail dot com\n  * Add macros to enable compiling out debug code\n    Geoffrey Young, geoff at modperlcookbook dot org\n  * Fix bug with use of capital E in numbers with exponents\n    Mateusz Loskot, mateusz at loskot dot net\n  * Add stddef.h include\n  * Patch allows for json-c compile with -Werror and not fail due to\n    -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations\n    Geoffrey Young, geoff at modperlcookbook dot org\n\n0.7\n===\n  * Add escaping of backslash to json output\n  * Add escaping of forward slash on tokenizing and output\n  * Changes to internal tokenizer from using recursion to\n    using a depth state structure to allow incremental parsing\n\n0.6\n===\n  * Fix bug in escaping of control characters\n    Johan Björklund, johbjo09 at kth dot se\n  * Remove include \"config.h\" from headers (should only\n    be included from .c files)\n    Michael Clark <michael@metaparadigm.com>\n\n0.5\n===\n  * Make headers C++ compatible by change *this to *obj\n  * Add ifdef C++ extern \"C\" to headers\n  * Use simpler definition of min and max in bits.h\n    Larry Lansing, llansing at fuzzynerd dot com\n\n  * Remove automake 1.6 requirement\n  * Move autogen commands into autogen.sh. Update README\n  * Remove error pointer special case for Windows\n  * Change license from LGPL to MIT\n    Michael Clark <michael@metaparadigm.com>\n\n0.4\n===\n  * Fix additional error case in object parsing\n  * Add back sign reversal in nested object parse as error pointer\n    value is negative, while error value is positive.\n    Michael Clark <michael@metaparadigm.com>\n\n0.3\n===\n  * fix pointer arithmetic bug for error pointer check in is_error() macro\n  * fix type passed to printbuf_memappend in json_tokener\n  * update autotools bootstrap instructions in README\n    Michael Clark <michael@metaparadigm.com>\n\n0.2\n===\n  * printbuf.c - C. Watford (christopher.watford@gmail.com)\n    Added a Win32/Win64 compliant implementation of vasprintf\n  * debug.c - C. Watford (christopher.watford@gmail.com)\n    Removed usage of vsyslog on Win32/Win64 systems, needs to be handled\n    by a configure script\n  * json_object.c - C. Watford (christopher.watford@gmail.com)\n    Added scope operator to wrap usage of json_object_object_foreach, this\n    needs to be rethought to be more ANSI C friendly\n  * json_object.h - C. Watford (christopher.watford@gmail.com)\n    Added Microsoft C friendly version of json_object_object_foreach\n  * json_tokener.c - C. Watford (christopher.watford@gmail.com)\n    Added a Win32/Win64 compliant implementation of strndup\n  * json_util.c - C. Watford (christopher.watford@gmail.com)\n    Added cast and mask to suffice size_t v. unsigned int conversion\n    correctness\n  * json_tokener.c - sign reversal issue on error info for nested object parse\n    spotted by Johan Björklund (johbjo09 at kth.se)\n  * json_object.c - escape \" in json_escape_str\n  * Change to automake and libtool to build shared and static library\n    Michael Clark <michael@metaparadigm.com>\n\n0.1\n===\n  * initial release\n"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 0.044921875,
          "content": "\nSee README.md for installation instructions.\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 0.017578125,
          "content": "See the git repo.\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.0283203125,
          "content": "See README.md or README.html\n"
        },
        {
          "name": "README.html",
          "type": "blob",
          "size": 1.740234375,
          "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\t<head>\n\t\t<title>JSON-C - A JSON implementation in C</title>\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n\t</head>\n\t<body>\n\t\t<h2>JSON-C - A JSON implementation in C</h2>\n\n\t\t<h3>Overview</h3>\n\t\t<p>JSON-C implements a reference counting object model that allows you to easily\n\t\tconstruct JSON objects in C, output them as JSON formatted strings and parse\n\t\tJSON formatted strings back into the C representation of JSON objects.\n\t\tIt aims to conform to <a href=\"https://tools.ietf.org/html/rfc7159\">RFC 7159</a>.\n\t\t</p>\n\n\t\t<h3>Building</h3>\n\t\t<p>To setup JSON-C to build on your system please run <tt>configure</tt> and <tt>make</tt>.</p>\n\t\t<p>If you are on Win32 cmake is required, generally:</p>\n\t\t<ul>\n\t\t<li>mkdir build</li>\n\t\t<li>cd build</li>\n\t\t<li>cmake ..</li>\n\t\t<li>msbuild \"json-c.vcxproj\" /m /verbosity:normal /p:OutDir=lib\\</li>\n\t\t<li>Or, open the project in Visual Studio</li>\n\t\t</ul>\n\n\t\t<h3>Documentation</h3>\n\t\t<P>Doxygen generated documentation exists <a href=\"https://json-c.github.io/json-c/\">here</a>.</P>\n\n\t\t<h3><a href=\"https://github.com/json-c/json-c\">GIT Reposository</a></h3>\n\t\t<p><strong><code>git clone https://github.com/json-c/json-c.git</code></strong></p>\n\n\t\t<h3><a href=\"https://groups.google.com/group/json-c\">Mailing List</a></h3>\n                <pi>Send email to <strong><code>json-c <i>&lt;at&gt;</i> googlegroups <i>&lt;dot&gt;</i> com</code></strong></p>\n\n\t\t<h3><a href=\"COPYING\">License</a></h3>\n\t\t<p>This program is free software; you can redistribute it and/or modify it under the terms of the MIT License.</p>\n\t\t<hr/>\n\t</body>\n</html>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.125,
          "content": "\\mainpage\n\njson-c\n========\n\n1. [Overview and Build Status](#overview)\n2. [Getting Help](#gettinghelp)\n3. [Building on Unix](#buildunix)\n    * [Prerequisites](#installprereq)\n    * [Build commands](#buildcmds)\n4. [CMake options](#CMake)\n5. [Testing](#testing)\n6. [Building with `vcpkg`](#buildvcpkg)\n7. [Building for Android](#android)\n8. [Building for Commodore Amiga or MorphOS](#amiga)\n9. [Linking to libjson-c](#linking)\n10. [Using json-c](#using)\n\n<a name=\"overview\"></a>\nJSON-C - A JSON implementation in C\n-----------------------------------\n\nJSON-C implements a reference counting object model that allows you to easily\nconstruct JSON objects in C, output them as JSON formatted strings and parse\nJSON formatted strings back into the C representation of JSON objects.\nIt aims to conform to [RFC 8259](https://www.rfc-editor.org/rfc/rfc8259).\n\nSkip down to [Using json-c](#using)\nor check out the [API docs](https://json-c.github.io/json-c/),\nif you already have json-c installed and ready to use.\n\nHome page for json-c: https://github.com/json-c/json-c/wiki\n\n<a name=\"gettinghelp\"></a>\nGetting Help\n------------\n\nIf you have questions about using json-c, please start a thread on\nour forums at: https://groups.google.com/forum/#!forum/json-c\n\nIf you believe you've discovered a bug, report it at \n(https://github.com/json-c/json-c/issues).  Please be sure to include\nthe version of json-c you're using, the OS you're running on, and any\nother relevant details.  Fully reproducible test cases and/or patches\nto fix problems are greatly appreciated.\n\nFixes for bugs, or small new features can be directly submitted as a \n[pull request](https://github.com/json-c/json-c/pulls).  For major new\nfeatures or large changes of any kind, please first start a discussion\non the [forums](https://groups.google.com/forum/#!forum/json-c).\n\n\n<a name=\"buildunix\"></a>\nBuilding on Unix with `git`, `gcc` and `cmake`\n--------------------------------------------------\n\nIf you already have json-c installed, see [Linking to `libjson-c`](#linking)\nfor how to build and link your program against it.\n\nBuild Status\n* [AppVeyor Build](https://ci.appveyor.com/project/hawicz/json-c) ![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/json-c/json-c?branch=master&svg=true)\n* [Travis Build](https://app.travis-ci.com/github/json-c/json-c) ![Travis Build Status](https://api.travis-ci.com/json-c/json-c.svg?branch=master)\n\nTest Status\n* [Coveralls](https://coveralls.io/github/json-c/json-c?branch=master) [![Coverage Status](https://coveralls.io/repos/github/json-c/json-c/badge.svg?branch=master)](https://coveralls.io/github/json-c/json-c?branch=master)\n\n<a name=\"installprereq\"></a>\n### Prerequisites:\n\n - `gcc`, `clang`, or another C compiler\n\n - `cmake>=2.8`, `>=3.16` recommended, `cmake=>3.1` for tests\n\nTo generate docs you'll also need:\n - `doxygen>=1.8.13`\n\nIf you are on a relatively modern system, you'll likely be able to install\nthe prerequisites using your OS's packaging system.\n\n### Install using apt (e.g. Ubuntu 16.04.2 LTS)\n```sh\nsudo apt install git\nsudo apt install cmake\nsudo apt install doxygen  # optional\nsudo apt install valgrind # optional\n```\n\n<a name=\"buildcmds\"></a>\n### Build instructions:\n\n`json-c` GitHub repo: https://github.com/json-c/json-c\n\n```sh\n$ git clone https://github.com/json-c/json-c.git\n$ mkdir json-c-build\n$ cd json-c-build\n$ cmake ../json-c   # See CMake section below for custom arguments\n```\n\nNote: it's also possible to put your build directory inside the json-c\nsource directory, or even not use a separate build directory at all, but\ncertain things might not work quite right (notably, `make distcheck`)\n\nThen:\n\n```sh\n$ make\n$ make test\n$ make USE_VALGRIND=0 test   # optionally skip using valgrind\n$ sudo make install          # it could be necessary to execute make install\n```\n\n\n### Generating documentation with Doxygen:\n\nThe library documentation can be generated directly from the source code using Doxygen tool:\n\n```sh\n# in build directory\nmake doc\ngoogle-chrome doc/html/index.html\n```\n\n\n<a name=\"CMake\"></a>\nCMake Options\n--------------------\n\nThe json-c library is built with [CMake](https://cmake.org/cmake-tutorial/),\nwhich can take a few options.\n\nVariable                     | Type   | Description\n-----------------------------|--------|--------------\nCMAKE_INSTALL_PREFIX         | String | The install location.\nCMAKE_BUILD_TYPE             | String | Defaults to \"debug\".\nBUILD_SHARED_LIBS            | Bool   | The default build generates a dynamic (dll/so) library.  Set this to OFF to create a static library only.\nBUILD_STATIC_LIBS            | Bool   | The default build generates a static (lib/a) library.  Set this to OFF to create a shared library only.\nDISABLE_STATIC_FPIC          | Bool   | The default builds position independent code.  Set this to OFF to create a shared library only.\nDISABLE_BSYMBOLIC            | Bool   | Disable use of -Bsymbolic-functions.\nDISABLE_THREAD_LOCAL_STORAGE | Bool   | Disable use of Thread-Local Storage (HAVE___THREAD).\nDISABLE_WERROR               | Bool   | Disable use of -Werror.\nDISABLE_EXTRA_LIBS           | Bool   | Disable use of extra libraries, libbsd\nDISABLE_JSON_POINTER         | Bool   | Omit json_pointer support from the build.\nENABLE_RDRAND                | Bool   | Enable RDRAND Hardware RNG Hash Seed.\nENABLE_THREADING             | Bool   | Enable partial threading support.\nOVERRIDE_GET_RANDOM_SEED     | String | A block of code to use instead of the default implementation of json_c_get_random_seed(), e.g. on embedded platforms where not even the fallback to time() works.  Must be a single line.\n\nPass these options as `-D` on CMake's command-line.\n\n```sh\n# build a static library only\ncmake -DBUILD_SHARED_LIBS=OFF ..\n```\n\n### Building with partial threading support\n\nAlthough json-c does not support fully multi-threaded access to\nobject trees, it has some code to help make its use in threaded programs\na bit safer.  Currently, this is limited to using atomic operations for\njson_object_get() and json_object_put().\n\nSince this may have a performance impact, of at least 3x slower\naccording to https://stackoverflow.com/a/11609063, it is disabled by\ndefault.  You may turn it on by adjusting your cmake command with:\n   -DENABLE_THREADING=ON\n\nSeparately, the default hash function used for object field keys,\nlh_char_hash, uses a compare-and-swap operation to ensure the random\nseed is only generated once.  Because this is a one-time operation, it\nis always compiled in when the compare-and-swap operation is available.\n\n\n### cmake-configure wrapper script\n\nFor those familiar with the old autoconf/autogen.sh/configure method,\nthere is a `cmake-configure` wrapper script to ease the transition to cmake.\n\n```sh\nmkdir build\ncd build\n../cmake-configure --prefix=/some/install/path\nmake\n```\n\ncmake-configure can take a few options.\n\n| options | Description|\n| ---- | ---- |\n| prefix=PREFIX |  install architecture-independent files in PREFIX |\n| enable-threading |  Enable code to support partly multi-threaded use |\n| enable-rdrand | Enable RDRAND Hardware RNG Hash Seed generation on supported x86/x64 platforms. |\n| enable-shared  |  build shared libraries [default=yes] |\n| enable-static  |  build static libraries [default=yes] |\n| disable-Bsymbolic |  Avoid linking with -Bsymbolic-function |\n| disable-werror |  Avoid treating compiler warnings as fatal errors |\n\n\n<a name=\"testing\"></a>\nTesting:\n----------\n\nBy default, if valgrind is available running tests uses it.\nThat can slow the tests down considerably, so to disable it use:\n```sh\nexport USE_VALGRIND=0\n```\n\nTo run tests a separate build directory is recommended:\n```sh\nmkdir build-test\ncd build-test\n# VALGRIND=1 causes -DVALGRIND=1 to be passed when compiling code\n# which uses slightly slower, but valgrind-safe code.\nVALGRIND=1 cmake ..\nmake\n\nmake test\n# By default, if valgrind is available running tests uses it.\nmake USE_VALGRIND=0 test   # optionally skip using valgrind\n```\n\nIf a test fails, check `Testing/Temporary/LastTest.log`,\n`tests/testSubDir/${testname}/${testname}.vg.out`, and other similar files.\nIf there is insufficient output try:\n```sh\nVERBOSE=1 CTEST_OUTPUT_ON_FAILURE=1 make test\n```\nor\n```sh\nJSONC_TEST_TRACE=1 make test\n```\nand check the log files again.\n\n\n<a name=\"buildvcpkg\"></a>\nBuilding on Unix and Windows with `vcpkg`\n--------------------------------------------------\n\nYou can download and install JSON-C using the [vcpkg](https://github.com/Microsoft/vcpkg/) dependency manager:\n\n    git clone https://github.com/Microsoft/vcpkg.git\n    cd vcpkg\n    ./bootstrap-vcpkg.sh\n    ./vcpkg integrate install\n    vcpkg install json-c\n\nThe JSON-C port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n<a name=\"android\"></a>\nBuilding for Android\n----------------------\n\nBuilding on Android is now particularly well supported, but there\nhave been some reports of success using\nhttps://developer.android.com/ndk/guides/cmake\n\n```\nmkdir json-c-build\ncd json-c-build/\nexport NDK_HOME=~/Library/Android/sdk/ndk/22.1.7171670/\ncmake \\\n    --toolchain=$NDK_HOME/build/cmake/android.toolchain.cmake \\\n    -DANDROID_STL=none \\\n    -DANDROID_ABI=arm64-v8a \\\n    -DANDROID_PLATFORM=android-29 \\\n    -DANDROID_LD=lld \\\n    -DCMAKE_BUILD_TYPE=MinSizeRel \\\n    -DCMAKE_INSTALL_PREFIX=<install prefix> \\\n    -DENABLE_THREADING=true \\\n    ..\nmake install\n```\n\n<a name=\"amiga\"></a>\nBuilding for Commodore Amiga or MorphOS\n----------------------\n\nBuilding for Commodore Amiga is supported for both Motorola 68k (AmigaOS 3) and PowerPC (AmigaOS 4) architectures. MorphOS on compatible PowerPC hardware is also supported. You can set up a cross compiler locally, however it is much easier to use the already preconfigured Amiga development environment wtthin a Docker container.\n\nInstall Docker on your machine if you don't already have it. You can download Docker Desktop for Windows/macOS/Linux [here](https://www.docker.com/products/docker-desktop/).\n\n### To build for Motorola 68k Amiga:\n\n```\nmkdir build\ndocker run --rm \\\n    -v ${PWD}:/work \\\n    -e USER=$( id -u ) -e GROUP=$( id -g ) \\\n    -it  sacredbanana/amiga-compiler:m68k-amigaos bash\ncd build\ncmake -DM68K_CRT=newlib ..\nmake\n```\n\nlibjson-c.a will get created in the build directory.\n\nYou can change newlib to nix20, nix13, ixemul or clib2 if you would like to build the library suited for libnix or clib2 instead. Newlib is default.\n\n### To build for PowerPC Amiga:\n\n```\nmkdir build\ndocker run --rm \\\n    -v ${PWD}:/work \\\n    -e USER=$( id -u ) -e GROUP=$( id -g ) \\\n    -it  sacredbanana/amiga-compiler:ppc-amigaos bash\ncd build\ncmake ..\nmake\n```\n\nlibjson-c.a will get created in the build directory.\n\n### To build for PowerPC MorphOS:\n\n```\nmkdir build\ndocker run --rm \\\n    -v ${PWD}:/work \\\n    -e USER=$( id -u ) -e GROUP=$( id -g ) \\\n    -it  sacredbanana/amiga-compiler:ppc-morphos bash\ncd build\ncmake -DNOIXEMUL=1 ..\nmake\n```\n\nIf you are making an application that absolutely requires ixemul, then remove the `-DNOIXEMUL=1`.\n\nlibjson-c.a will get created in the build directory.\n\n<a name=\"linking\"></a>\nLinking to `libjson-c`\n----------------------\n\nIf your system has `pkgconfig`,\nthen you can just add this to your `makefile`:\n\n```make\nCFLAGS += $(shell pkg-config --cflags json-c)\nLDFLAGS += $(shell pkg-config --libs json-c)\n```\n\nWithout `pkgconfig`, you might do something like this:\n\n```make\nJSON_C_DIR=/path/to/json_c/install\nCFLAGS += -I$(JSON_C_DIR)/include/json-c\n# Or to use lines like: #include <json-c/json_object.h>\n#CFLAGS += -I$(JSON_C_DIR)/include\nLDFLAGS+= -L$(JSON_C_DIR)/lib -ljson-c\n```\n\nIf your project uses cmake:\n\n* Add to your CMakeLists.txt file:\n\n```cmake\nfind_package(json-c CONFIG)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE json-c::json-c)\n```\n\n* Then you might run in your project:\n\n```sh\ncd build\ncmake -DCMAKE_PREFIX_PATH=/path/to/json_c/install/lib64/cmake ..\n```\n\n<a name=\"using\"></a>\nUsing json-c\n------------\n\nTo use json-c you can either include json.h, or preferably, one of the\nfollowing more specific header files:\n\n* json_object.h  - Core types and methods.\n* json_tokener.h - Methods for parsing and serializing json-c object trees.\n* json_pointer.h - JSON Pointer (RFC 6901) implementation for retrieving\n                   objects from a json-c object tree.\n* json_object_iterator.h - Methods for iterating over single json_object instances.  (See also `json_object_object_foreach()` in json_object.h)\n* json_visit.h   - Methods for walking a tree of json-c objects.\n* json_util.h    - Miscellaneous utility functions.\n\nFor a full list of headers see [files.html](https://json-c.github.io/json-c/json-c-current-release/doc/html/files.html)\n\nThe primary type in json-c is json_object.  It describes a reference counted\ntree of json objects which are created by either parsing text with a\njson_tokener (i.e. `json_tokener_parse_ex()`), or by creating\n(with `json_object_new_object()`, `json_object_new_int()`, etc...) and adding\n(with `json_object_object_add()`, `json_object_array_add()`, etc...) them \nindividually.\nTypically, every object in the tree will have one reference, from its parent.\nWhen you are done with the tree of objects, you call json_object_put() on just\nthe root object to free it, which recurses down through any child objects\ncalling json_object_put() on each one of those in turn.\n\nYou can get a reference to a single child \n(`json_object_object_get()` or `json_object_array_get_idx()`)\nand use that object as long as its parent is valid.  \nIf you need a child object to live longer than its parent, you can\nincrement the child's refcount (`json_object_get()`) to allow it to survive\nthe parent being freed or it being removed from its parent\n(`json_object_object_del()` or `json_object_array_del_idx()`)\n\nWhen parsing text, the json_tokener object is independent from the json_object\nthat it returns.  It can be allocated (`json_tokener_new()`)\nused one or multiple times (`json_tokener_parse_ex()`, and\nfreed (`json_tokener_free()`) while the json_object objects live on.\n\nA json_object tree can be serialized back into a string with \n`json_object_to_json_string_ext()`.  The string that is returned \nis only valid until the next \"to_json_string\" call on that same object.\nAlso, it is freed when the json_object is freed.\n\n"
        },
        {
          "name": "RELEASE_CHECKLIST.txt",
          "type": "blob",
          "size": 5.5146484375,
          "content": "\n# Release checklist:\n\n## Pre-release tasks\n\n* Figure out whether a release is worthwhile to do.\n* Analyze the previous release branch to see if anything should have been\n  applied to master.\n* Collect changes and assemble tentative release notes.\n    * Identify previous release branch point\n    * Check commit logs between previous branch point and now for\n       notable changes worth mentioning\n    * Create a new issues_closed_for_X.Y.md file\n        * Include notable entries from here in the release notes.\n    * Analyze APIs between previous release branch and master to produce list of\n      changes (added/removed/updated funcs, etc...), and detect backwards compat\n      issues.\n        * https://github.com/lvc/abi-compliance-checker\n        * See also `abi-check.sh`\n        * If the new release is not backwards compatible, then this is a MAJOR release.\n        * Mention removed features in ChangeLog\n\t\t* Consider re-adding backwards compatible support, through symbol\n\t\t  aliases and appropriate entries in json-c.sym\n\t\t* Be sure any new symbols are listed in json-c.sym as part of\n\t\t  the _new_ release version.\n    * Update the AUTHORS file\n\n        PREV=$(git tag | tail -1)\n        ( git log -r ${PREV}..HEAD | grep Author: | sed -e's/Author: //' ; cat AUTHORS ) | sort -u > A1\n        mv A1 AUTHORS\n\n    * Exclude mentioning changes that have already been included in a point \n      release of the previous release branch.\n\n* Update ChangeLog with relevant notes before branching.\n\n* Check that the compile works on Linux - automatic through Travis\n* Check that the compile works on NetBSD\n* Check that the compile works on Windows - automatic through AppVeyor\n\n## Release creation\n\nStart creating the new release:\n\n    PREV=$(git tag | tail -1)\n    PREV=${PREV#json-c-}\n    PREV=${PREV%-*}\n    release=0.$((${PREV#*.} + 1))\n    cd ~\n    git clone https://github.com/json-c/json-c json-c-${release}\n\n    rm -rf distcheck\n    mkdir distcheck\n    cd distcheck\n    # Note, the build directory *must* be entirely separate from\n    # the source tree for distcheck to work properly.\n    cmake -DCMAKE_BUILD_TYPE=Release ../json-c-${release}\n    make distcheck\n    cd ..\n\nMake any fixes/changes *before* branching.\n\n    cd json-c-${release}\n    git checkout -b json-c-${release}\n\n------------\n\nUsing ${release}:\n\tUpdate the version in json_c_version.h\n\tUpdate the version in CMakeLists.txt (VERSION in the project(...) line)\n\nUpdate the set_target_properties() line in CmakeLists.txt to set the shared\nlibrary version.  Generally, unless we're doing a major release, change:\n\tVERSION x.y.z\nto\n\tVERSION x.y+1.z\n\n    git commit -a -m \"Bump version to ${release}\"\n\nIf we're doing a major release (SONAME bump), also bump the version\n of ALL symbols in json-c.sym.\n See explanation at https://github.com/json-c/json-c/issues/621\n More info at: https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf\n\n------------\n\nGenerate the doxygen documentation:\n\n    (cd ../distcheck && make doc)\n    cp -r -p ../distcheck/doc/{html,Doxyfile} doc/.\n\trm doc/Doxyfile   # Remove generated file w/ hardcoded paths\n    git add -f doc\n    git commit doc -m \"Generate docs for the ${release} release\"\n\n------------\n\nCreate the release tarballs:\n\n    cd ..\n    echo .git > excludes\n    tar -czf json-c-${release}.tar.gz -X excludes json-c-${release}\n\n    echo 'doc/*.cmake' >> excludes\n    echo 'doc/CMakeFiles' >> excludes\n    echo 'doc/Makefile' >> excludes\n    echo 'doc/Doxyfile' >> excludes\n    echo 'doc/html' >> excludes\n    tar -czf json-c-${release}-nodoc.tar.gz -X excludes json-c-${release}\n\n------------\n\nTag the branch:\n\n    cd json-c-${release}\n    git tag -a json-c-${release}-$(date +%Y%m%d) -m \"Release json-c-${release}\"\n\n    git push origin json-c-${release}\n    git push --tags\n\n------------\n\nGo to Amazon S3 service at:\n    https://console.aws.amazon.com/s3/\n\nUpload the two tarballs in the json-c_releases/releases folder.\n* Expand \"Permissions\", pick \"Grant public-read access\"\n* Expand \"Properties\", ensure \"Standard\" storage class is picked.\n\nLogout of Amazon S3, and verify that the files are visible.\n    https://s3.amazonaws.com/json-c_releases/releases/index.html\n\n===================================\n\nPost-release checklist:\n\n    git checkout master\n\nAdd new section to ChangeLog for ${release}+1\n\nUse ${release}.99 to indicate a version \"newer\" than anything on the branch:\n\tUpdate the version in json_c_version.h\n\tUpdate the version in CMakeLists.txt\n\nUpdate the set_target_properties() line in CmakeLists.txt to match the release branch.\n\nAdd a new empty section to the json-c.sym file, for ${release}+1\n\n    git commit -a -m \"Update the master branch to version ${release}.99\"\n    git push\n\n------------\n\nUpdate the gh-pages branch with new docs:\n\n    cd json-c-${release}\n    git checkout json-c-${release}\n    cd ..\n\n    git clone -b gh-pages https://github.com/json-c/json-c json-c-pages\n    cd json-c-pages\n    mkdir json-c-${release}\n    cp -R ../json-c-${release}/doc json-c-${release}/.\n    git add json-c-${release}\n    rm json-c-current-release\n    ln -s json-c-${release} json-c-current-release\n    git commit -a -m \"Add the ${release} docs.\"\n\n    vi index.html\n    # Add/change links to current release.\n\n    git commit -a -m \"Update the doc links to point at ${release}\"\n\n    git push\n\n------------\n\nUpdate checksums on wiki page.\n\n    cd ..\n    openssl sha1 -sha256 json-c*gz\n    openssl md5 json-c*gz\n\nCopy and paste this output into the wiki page at:\n* https://github.com/json-c/json-c/wiki\n* https://github.com/json-c/json-c/wiki/Old-Releases\n\n------------\n\nSend an email to the mailing list.\n"
        },
        {
          "name": "STYLE.txt",
          "type": "blob",
          "size": 1.1455078125,
          "content": "In general:\nFor minor changes to a function, copy the existing formatting.\nWhen changing the style, commit that separately from other changes.\nFor new code and major changes to a function, switch to the official json-c style.\n\nOfficial json-c style:\n\nAim for readability, not strict conformance to fixed style rules.\nFormatting is tab based; previous attempts at proper alignment with\nspaces for continuation lines have been abandoned in favor of the\nconvenience of using clang-format.\nRefer to the .clang-format file for details, and run the tool before commit:\n\n    clang-format -i somefile.c foo.h\n\nFor sections of code that would be significantly negatively impacted, surround\nthem with magic comments to disable formatting:\n\n    /* clang-format off */\n    ...code...\n    /* clang-format on */\n\n\nNaming:\nWords within function and variable names are separated with underscores.  Avoid camel case.\nPrefer longer, more descriptive names, but not excessively so.  No single letter variable names.\n\nOther:\nVariables should be defined for the smallest scope needed.\nFunctions should be defined static when possible.\nWhen possible, avoid exposing internals in the public API.\n"
        },
        {
          "name": "abi-check.sh",
          "type": "blob",
          "size": 0.9658203125,
          "content": "#!/bin/sh\n\n# The 0.17 release is broken\n#prev=0.17\nprev=0.16\nrelease=0.18\n\n# ... clone json-c, abi-compliance-checker, abi-dumper\n\nif [ \"$1\" != \"--skip-build\" ] ; then\n\tmkdir build\n\tcd build\n\tCFLAGS=-Og cmake -DCMAKE_INSTALL_PREFIX=~/json-c-installs/json-c-${release} ..\n\tmake && make test && make install\nfi\n\n# Assume the old version has already been built\n\ncd ~/abi-compliance-checker\nmkxml()\n{\n\tver=\"$1\"\ncat <<EOF > json-c-${ver}.xml\n<foo>\n<version>\n   ${ver}\n</version>\n\n<headers>\n../json-c-installs/json-c-${ver}/include/json-c\n</headers>\n\n<libs>\n../json-c-installs/json-c-${ver}/lib64/libjson-c.so\n</libs>\n</foo>\nEOF\n}\nmkxml ${release}\nmkxml ${prev}\n\nperl abi-compliance-checker.pl -lib json-c -dump json-c-${prev}.xml -dump-path ./ABI-${prev}.dump\nperl abi-compliance-checker.pl -lib json-c -dump json-c-${release}.xml -dump-path ./ABI-${release}.dump\nperl abi-compliance-checker.pl -l json-c -old ABI-${prev}.dump -new ABI-${release}.dump\n\necho \"look in compat_reports/json-c/...\"\n"
        },
        {
          "name": "apps",
          "type": "tree",
          "content": null
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 2.3115234375,
          "content": "version: '{branch}.{build}'\n\nimage:\n# b_toolset: v143\n  - Visual Studio 2022\n\n  # VS2015 also used for earlier VS builds\n  # aka os: Windows Server 2012 R2\n  - Visual Studio 2015\n\n  # aka os: Windows Server 2016\n# b_toolset: v141\n  - Visual Studio 2017\n\n  # aka os: Windows Server 2019\n# b_toolset: v142\n  - Visual Studio 2019\n\nplatform: x64\n\nenvironment:\n  matrix:\n    - b_toolset: Windows7.1SDK\n\n    - b_toolset: v120\n\n    - b_toolset: v140\n\n    - b_toolset: v141\n\n    - b_toolset: v142\n\n    - b_toolset: v143\n\nconfiguration:\n  - Debug\n  - Release\n\nbuild_script:\n- cmake -T %b_toolset% -DCMAKE_BUILD_TYPE=%CONFIGURATION% -DCMAKE_INSTALL_PREFIX=t_install .\n- cmake --build . --target install\n\nmatrix:\n  exclude:\n    #  Skip release builds for all except the newest image\n    - image: Visual Studio 2015\n      configuration: Release\n\n    # In the \"old\" image, new toolsets aren't available:\n    - image: Visual Studio 2015\n      b_toolset: v141\n\n    - image: Visual Studio 2015\n      b_toolset: v142\n\n    - image: Visual Studio 2015\n      b_toolset: v143\n\n    # ----\n\n    - image: Visual Studio 2017\n      configuration: Release\n\n    # In the \"new\" images, exclude all toolsets except the relevant\n    #  one for that image:\n\n    - image: Visual Studio 2017\n      b_toolset: Windows7.1SDK\n\n    - image: Visual Studio 2017\n      b_toolset: v120\n\n    - image: Visual Studio 2017\n      b_toolset: v140\n\n    - image: Visual Studio 2017\n      b_toolset: v142\n\n    - image: Visual Studio 2017\n      b_toolset: v143\n\n    # ----\n\n    - image: Visual Studio 2019\n      configuration: Release\n\n    - image: Visual Studio 2019\n      b_toolset: Windows7.1SDK\n\n    - image: Visual Studio 2019\n      b_toolset: v120\n\n    - image: Visual Studio 2019\n      b_toolset: v140\n\n    - image: Visual Studio 2019\n      b_toolset: v141\n\n    - image: Visual Studio 2019\n      b_toolset: v143\n\n    # ----\n\n    - image: Visual Studio 2022\n      b_toolset: Windows7.1SDK\n\n    - image: Visual Studio 2022\n      b_toolset: v120\n\n    - image: Visual Studio 2022\n      b_toolset: v140\n\n    - image: Visual Studio 2022\n      b_toolset: v141\n\n    - image: Visual Studio 2022\n      b_toolset: v142\n\nafter_build:\n- cd t_install\n- 7z a ../json-c.win32.%b_toolset%.%CONFIGURATION%.zip *\n\nartifacts:\n- path: json-c.win32.%b_toolset%.%CONFIGURATION%.zip\n  name: json-c.win32.%b_toolset%.%CONFIGURATION%.zip\n"
        },
        {
          "name": "arraylist.c",
          "type": "blob",
          "size": 5.41796875,
          "content": "/*\n * $Id: arraylist.c,v 1.4 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"config.h\"\n\n#include <limits.h>\n\n#ifdef STDC_HEADERS\n#include <stdlib.h>\n#include <string.h>\n#endif /* STDC_HEADERS */\n\n#if defined(HAVE_STRINGS_H) && !defined(_STRING_H) && !defined(__USE_BSD)\n#include <strings.h>\n#endif /* HAVE_STRINGS_H */\n\n#ifndef SIZE_T_MAX\n#if SIZEOF_SIZE_T == SIZEOF_INT\n#define SIZE_T_MAX UINT_MAX\n#elif SIZEOF_SIZE_T == SIZEOF_LONG\n#define SIZE_T_MAX ULONG_MAX\n#elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG\n#define SIZE_T_MAX ULLONG_MAX\n#else\n#error Unable to determine size of size_t\n#endif\n#endif\n\n#include \"arraylist.h\"\n\nstruct array_list *array_list_new(array_list_free_fn *free_fn)\n{\n\treturn array_list_new2(free_fn, ARRAY_LIST_DEFAULT_SIZE);\n}\n\nstruct array_list *array_list_new2(array_list_free_fn *free_fn, int initial_size)\n{\n\tstruct array_list *arr;\n\n\tif (initial_size < 0 || (size_t)initial_size >= SIZE_T_MAX / sizeof(void *))\n\t\treturn NULL;\n\tarr = (struct array_list *)malloc(sizeof(struct array_list));\n\tif (!arr)\n\t\treturn NULL;\n\tarr->size = initial_size;\n\tarr->length = 0;\n\tarr->free_fn = free_fn;\n\tif (!(arr->array = (void **)malloc(arr->size * sizeof(void *))))\n\t{\n\t\tfree(arr);\n\t\treturn NULL;\n\t}\n\treturn arr;\n}\n\nextern void array_list_free(struct array_list *arr)\n{\n\tsize_t i;\n\tfor (i = 0; i < arr->length; i++)\n\t\tif (arr->array[i])\n\t\t\tarr->free_fn(arr->array[i]);\n\tfree(arr->array);\n\tfree(arr);\n}\n\nvoid *array_list_get_idx(struct array_list *arr, size_t i)\n{\n\tif (i >= arr->length)\n\t\treturn NULL;\n\treturn arr->array[i];\n}\n\nstatic int array_list_expand_internal(struct array_list *arr, size_t max)\n{\n\tvoid *t;\n\tsize_t new_size;\n\n\tif (max < arr->size)\n\t\treturn 0;\n\t/* Avoid undefined behaviour on size_t overflow */\n\tif (arr->size >= SIZE_T_MAX / 2)\n\t\tnew_size = max;\n\telse\n\t{\n\t\tnew_size = arr->size << 1;\n\t\tif (new_size < max)\n\t\t\tnew_size = max;\n\t}\n\tif (new_size > (~((size_t)0)) / sizeof(void *))\n\t\treturn -1;\n\tif (!(t = realloc(arr->array, new_size * sizeof(void *))))\n\t\treturn -1;\n\tarr->array = (void **)t;\n\tarr->size = new_size;\n\treturn 0;\n}\n\nint array_list_shrink(struct array_list *arr, size_t empty_slots)\n{\n\tvoid *t;\n\tsize_t new_size;\n\n\tif (empty_slots >= SIZE_T_MAX / sizeof(void *) - arr->length)\n\t\treturn -1;\n\tnew_size = arr->length + empty_slots;\n\tif (new_size == arr->size)\n\t\treturn 0;\n\tif (new_size > arr->size)\n\t\treturn array_list_expand_internal(arr, new_size);\n\tif (new_size == 0)\n\t\tnew_size = 1;\n\n\tif (!(t = realloc(arr->array, new_size * sizeof(void *))))\n\t\treturn -1;\n\tarr->array = (void **)t;\n\tarr->size = new_size;\n\treturn 0;\n}\n\nint array_list_insert_idx(struct array_list *arr, size_t idx, void *data)\n{\n\tsize_t move_amount;\n\n\tif (idx >= arr->length)\n\t\treturn array_list_put_idx(arr, idx, data);\n\n\t/* we're at full size, what size_t can support */\n\tif (arr->length == SIZE_T_MAX)\n\t\treturn -1;\n\n\tif (array_list_expand_internal(arr, arr->length + 1))\n\t\treturn -1;\n\n\tmove_amount = (arr->length - idx) * sizeof(void *);\n\tmemmove(arr->array + idx + 1, arr->array + idx, move_amount);\n\tarr->array[idx] = data;\n\tarr->length++;\n\treturn 0;\n}\n\n//static inline int _array_list_put_idx(struct array_list *arr, size_t idx, void *data)\nint array_list_put_idx(struct array_list *arr, size_t idx, void *data)\n{\n\tif (idx > SIZE_T_MAX - 1)\n\t\treturn -1;\n\tif (array_list_expand_internal(arr, idx + 1))\n\t\treturn -1;\n\tif (idx < arr->length && arr->array[idx])\n\t\tarr->free_fn(arr->array[idx]);\n\tarr->array[idx] = data;\n\tif (idx > arr->length)\n\t{\n\t\t/* Zero out the arraylist slots in between the old length\n\t\t   and the newly added entry so we know those entries are\n\t\t   empty.\n\t\t   e.g. when setting array[7] in an array that used to be \n\t\t   only 5 elements longs, array[5] and array[6] need to be\n\t\t   set to 0.\n\t\t */\n\t\tmemset(arr->array + arr->length, 0, (idx - arr->length) * sizeof(void *));\n\t}\n\tif (arr->length <= idx)\n\t\tarr->length = idx + 1;\n\treturn 0;\n}\n\nint array_list_add(struct array_list *arr, void *data)\n{\n\t/* Repeat some of array_list_put_idx() so we can skip several\n\t   checks that we know are unnecessary when appending at the end\n\t */\n\tsize_t idx = arr->length;\n\tif (idx > SIZE_T_MAX - 1)\n\t\treturn -1;\n\tif (array_list_expand_internal(arr, idx + 1))\n\t\treturn -1;\n\tarr->array[idx] = data;\n\tarr->length++;\n\treturn 0;\n}\n\nvoid array_list_sort(struct array_list *arr, int (*compar)(const void *, const void *))\n{\n\tqsort(arr->array, arr->length, sizeof(arr->array[0]), compar);\n}\n\nvoid *array_list_bsearch(const void **key, struct array_list *arr,\n                         int (*compar)(const void *, const void *))\n{\n\treturn bsearch(key, arr->array, arr->length, sizeof(arr->array[0]), compar);\n}\n\nsize_t array_list_length(struct array_list *arr)\n{\n\treturn arr->length;\n}\n\nint array_list_del_idx(struct array_list *arr, size_t idx, size_t count)\n{\n\tsize_t i, stop;\n\n\t/* Avoid overflow in calculation with large indices. */\n\tif (idx > SIZE_T_MAX - count)\n\t\treturn -1;\n\tstop = idx + count;\n\tif (idx >= arr->length || stop > arr->length)\n\t\treturn -1;\n\tfor (i = idx; i < stop; ++i)\n\t{\n\t\t// Because put_idx can skip entries, we need to check if\n\t\t// there's actually anything in each slot we're erasing.\n\t\tif (arr->array[i])\n\t\t\tarr->free_fn(arr->array[i]);\n\t}\n\tmemmove(arr->array + idx, arr->array + stop, (arr->length - stop) * sizeof(void *));\n\tarr->length -= count;\n\treturn 0;\n}\n"
        },
        {
          "name": "arraylist.h",
          "type": "blob",
          "size": 2.53125,
          "content": "/*\n * $Id: arraylist.h,v 1.4 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Internal methods for working with json_type_array objects.\n *        Although this is exposed by the json_object_get_array() method,\n *        it is not recommended for direct use.\n */\n#ifndef _json_c_arraylist_h_\n#define _json_c_arraylist_h_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stddef.h>\n\n#define ARRAY_LIST_DEFAULT_SIZE 32\n\ntypedef void(array_list_free_fn)(void *data);\n\nstruct array_list\n{\n\tvoid **array;\n\tsize_t length;\n\tsize_t size;\n\tarray_list_free_fn *free_fn;\n};\ntypedef struct array_list array_list;\n\n/**\n * Allocate an array_list of the default size (32).\n * @deprecated Use array_list_new2() instead.\n */\nextern struct array_list *array_list_new(array_list_free_fn *free_fn);\n\n/**\n * Allocate an array_list of the desired size.\n *\n * If possible, the size should be chosen to closely match\n * the actual number of elements expected to be used.\n * If the exact size is unknown, there are tradeoffs to be made:\n * - too small - the array_list code will need to call realloc() more\n *   often (which might incur an additional memory copy).\n * - too large - will waste memory, but that can be mitigated\n *   by calling array_list_shrink() once the final size is known.\n *\n * @see array_list_shrink\n */\nextern struct array_list *array_list_new2(array_list_free_fn *free_fn, int initial_size);\n\nextern void array_list_free(struct array_list *al);\n\nextern void *array_list_get_idx(struct array_list *al, size_t i);\n\nextern int array_list_insert_idx(struct array_list *al, size_t i, void *data);\n\nextern int array_list_put_idx(struct array_list *al, size_t i, void *data);\n\nextern int array_list_add(struct array_list *al, void *data);\n\nextern size_t array_list_length(struct array_list *al);\n\nextern void array_list_sort(struct array_list *arr, int (*compar)(const void *, const void *));\n\nextern void *array_list_bsearch(const void **key, struct array_list *arr,\n                                int (*compar)(const void *, const void *));\n\nextern int array_list_del_idx(struct array_list *arr, size_t idx, size_t count);\n\n/**\n * Shrink the array list to just enough to fit the number of elements in it,\n * plus empty_slots.\n */\nextern int array_list_shrink(struct array_list *arr, size_t empty_slots);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake-configure",
          "type": "blob",
          "size": 2.11328125,
          "content": "#!/bin/bash\n\n# Wrapper around cmake to emulate useful options\n# from the previous autoconf-based configure script.\n\nRUNDIR=$(dirname \"$0\")\nRUNDIR=$(cd \"$RUNDIR\" && pwd)\nCURDIR=$(pwd)\n\nFLAGS=()\n\nusage()\n{\n\texitval=\"$1\"\n\terrmsg=\"$2\"\n\n\tif [ $exitval -ne 0 ] ; then\n\t\texec 1>&2\n\tfi\n\tif [ ! -z \"$errmsg\" ] ; then\n\t\techo \"ERROR: $errmsg\" 1>&2\n\tfi\n\tcat <<EOF\n$0 [<configure_options>] [-- [<cmake options>]]\n  --prefix=PREFIX         install architecture-independent files in PREFIX\n  --enable-threading      Enable code to support partly multi-threaded use\n  --enable-rdrand         Enable RDRAND Hardware RNG Hash Seed generation on\n                          supported x86/x64 platforms.\n  --enable-shared         build shared libraries [default=yes]\n  --enable-static         build static libraries [default=yes]\n  --disable-Bsymbolic     Avoid linking with -Bsymbolic-function\n  --disable-werror        Avoid treating compiler warnings as fatal errors\n  --disable-extra-libs    Avoid linking against extra libraries, such as libbsd\n\nEOF\n\texit\n}\n\nif [ \"$CURDIR\" = \"$RUNDIR\" ] ; then\n\tusage 1 \"Please mkdir some other build directory, and run this script from there.\"\nfi\n\nif ! cmake --version ; then\n\tusage 1 \"Unable to find a working cmake, please be sure you have it installed and on your PATH\"\nfi\n\nwhile [ $# -gt 0 ] ; do\n\tcase \"$1\" in\n\t-h|--help)\n\t\tusage 0\n\t\t;;\n\t--prefix)\n\t\tFLAGS+=(-DCMAKE_INSTALL_PREFIX=\"$2\")\n\t\tshift\n\t\t;;\n\t--prefix=*)\n\t\tFLAGS+=(-DCMAKE_INSTALL_PREFIX=\"${1##--prefix=}\")\n\t\t;;\n\t--enable-threading)\n\t\tFLAGS+=(-DENABLE_THREADING=ON)\n\t\t;;\n\t--enable-rdrand)\n\t\tFLAGS+=(-DENABLE_RDRAND=ON)\n\t\t;;\n\t--enable-shared)\n\t\tFLAGS+=(-DBUILD_SHARED_LIBS=ON)\n\t\t;;\n\t--disable-shared)\n\t\tFLAGS+=(-DBUILD_SHARED_LIBS=OFF)\n\t\t;;\n\t--enable-static)\n\t\tFLAGS+=(-DBUILD_STATIC_LIBS=ON)\n\t\t;;\n\t--disable-static)\n\t\tFLAGS+=(-DBUILD_STATIC_LIBS=OFF)\n\t\t;;\n\t--disable-Bsymbolic)\n\t\tFLAGS+=(-DDISABLE_BSYMBOLIC=ON)\n\t\t;;\n\t--disable-werror)\n\t\tFLAGS+=(-DDISABLE_WERROR=ON)\n\t\t;;\n\t--disable-extra-libs)\n\t\tFLAGS+=(-DDISABLE_EXTRA_LIBS=ON)\n\t\t;;\n\t--)\n\t\tshift\n\t\tbreak\n\t\t;;\n\t-*)\n\t\tusage 1 \"Unknown arguments: $*\"\n\t\t;;\n\t*)\n\t\tbreak\n\t\t;;\n\tesac\n\tshift\ndone\n\nexec cmake \"${FLAGS[@]}\" \"$@\" \"${RUNDIR}\"\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "debug.c",
          "type": "blob",
          "size": 1.408203125,
          "content": "/*\n * $Id: debug.c,v 1.5 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"config.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if HAVE_SYSLOG_H\n#include <syslog.h>\n#endif /* HAVE_SYSLOG_H */\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif /* HAVE_UNISTD_H */\n\n#if HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif /* HAVE_SYS_PARAM_H */\n\n#include \"debug.h\"\n\nstatic int _syslog = 0;\nstatic int _debug = 0;\n\nvoid mc_set_debug(int debug)\n{\n\t_debug = debug;\n}\nint mc_get_debug(void)\n{\n\treturn _debug;\n}\n\nextern void mc_set_syslog(int syslog)\n{\n\t_syslog = syslog;\n}\n\nvoid mc_debug(const char *msg, ...)\n{\n\tva_list ap;\n\tif (_debug)\n\t{\n\t\tva_start(ap, msg);\n#if HAVE_VSYSLOG\n\t\tif (_syslog)\n\t\t{\n\t\t\tvsyslog(LOG_DEBUG, msg, ap);\n\t\t}\n\t\telse\n#endif\n\t\t\tvprintf(msg, ap);\n\t\tva_end(ap);\n\t}\n}\n\nvoid mc_error(const char *msg, ...)\n{\n\tva_list ap;\n\tva_start(ap, msg);\n#if HAVE_VSYSLOG\n\tif (_syslog)\n\t{\n\t\tvsyslog(LOG_ERR, msg, ap);\n\t}\n\telse\n#endif\n\t\tvfprintf(stderr, msg, ap);\n\tva_end(ap);\n}\n\nvoid mc_info(const char *msg, ...)\n{\n\tva_list ap;\n\tva_start(ap, msg);\n#if HAVE_VSYSLOG\n\tif (_syslog)\n\t{\n\t\tvsyslog(LOG_INFO, msg, ap);\n\t}\n\telse\n#endif\n\t\tvfprintf(stderr, msg, ap);\n\tva_end(ap);\n}\n"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 2.6396484375,
          "content": "/*\n * $Id: debug.h,v 1.5 2006/01/30 23:07:57 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n * Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n#ifndef _JSON_C_DEBUG_H_\n#define _JSON_C_DEBUG_H_\n\n#include <stdlib.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef JSON_EXPORT\n#if defined(_MSC_VER) && defined(JSON_C_DLL)\n#define JSON_EXPORT __declspec(dllexport)\n#else\n#define JSON_EXPORT extern\n#endif\n#endif\n\nJSON_EXPORT void mc_set_debug(int debug);\nJSON_EXPORT int mc_get_debug(void);\n\nJSON_EXPORT void mc_set_syslog(int syslog);\n\nJSON_EXPORT void mc_debug(const char *msg, ...);\nJSON_EXPORT void mc_error(const char *msg, ...);\nJSON_EXPORT void mc_info(const char *msg, ...);\n\n#ifndef __STRING\n#define __STRING(x) #x\n#endif\n\n#ifndef PARSER_BROKEN_FIXED\n\n#define JASSERT(cond) \\\n\tdo            \\\n\t{             \\\n\t} while (0)\n\n#else\n\n#define JASSERT(cond)                                                                              \\\n\tdo                                                                                         \\\n\t{                                                                                          \\\n\t\tif (!(cond))                                                                       \\\n\t\t{                                                                                  \\\n\t\t\tmc_error(\"cjson assert failure %s:%d : cond \\\"\" __STRING(cond) \"failed\\n\", \\\n\t\t\t         __FILE__, __LINE__);                                              \\\n\t\t\t*(int *)0 = 1;                                                             \\\n\t\t\tabort();                                                                   \\\n\t\t}                                                                                  \\\n\t} while (0)\n\n#endif\n\n#define MC_ERROR(x, ...) mc_error(x, ##__VA_ARGS__)\n\n#ifdef MC_MAINTAINER_MODE\n#define MC_SET_DEBUG(x) mc_set_debug(x)\n#define MC_GET_DEBUG() mc_get_debug()\n#define MC_SET_SYSLOG(x) mc_set_syslog(x)\n#define MC_DEBUG(x, ...) mc_debug(x, ##__VA_ARGS__)\n#define MC_INFO(x, ...) mc_info(x, ##__VA_ARGS__)\n#else\n#define MC_SET_DEBUG(x) \\\n\tif (0)          \\\n\tmc_set_debug(x)\n#define MC_GET_DEBUG() (0)\n#define MC_SET_SYSLOG(x) \\\n\tif (0)           \\\n\tmc_set_syslog(x)\n#define MC_DEBUG(x, ...) \\\n\tif (0)           \\\n\tmc_debug(x, ##__VA_ARGS__)\n#define MC_INFO(x, ...) \\\n\tif (0)          \\\n\tmc_info(x, ##__VA_ARGS__)\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "issues_closed_for_0.13.md",
          "type": "blob",
          "size": 27.1220703125,
          "content": "\nThis list was created with:\n\n```\ncurl https://api.github.com/search/issues?q=\"repo%3Ajson-c%2Fjson-c+closed%3A>2014-04-10+created%3A<2017-12-01&sort=created&order=asc&per_page=400&page=1\" > issues1.out\ncurl https://api.github.com/search/issues?q=\"repo%3Ajson-c%2Fjson-c+closed%3A>2014-04-10+created%3A<2017-12-01&sort=created&order=asc&per_page=400&page=2\" > issues2.out\ncurl https://api.github.com/search/issues?q=\"repo%3Ajson-c%2Fjson-c+closed%3A>2014-04-10+created%3A<2017-12-01&sort=created&order=asc&per_page=400&page=3\" > issues3.out\njq -r '.items[] | \"[\" + .title + \"](\" + .url + \")\" | tostring' issues?.out  > issues.md\nsed -e's,^\\[ *\\(.*\\)\\](https://api.github.com/.*/\\([0-9].*\\)),[Issue #\\2](https://github.com/json-c/json-c/issues/\\2) - \\1,' -i issues.md\n#... manual editing ...\n```\n\n----\n\nIssues and Pull Requests closed for the 0.13 release\n(since commit f84d9c, the 0.12 branch point, 2014-04-10)\n\n\n* [Issue #61](https://github.com/json-c/json-c/issues/61) - Make json_object_object_add() indicate success or failure, test fix \\\n* [Issue #113](https://github.com/json-c/json-c/issues/113) - Build fixes (make dist and make distcheck) \\\n* [Issue #124](https://github.com/json-c/json-c/issues/124) - Fixing build \\\n* [Issue #125](https://github.com/json-c/json-c/issues/125) - Fix compile error(variable size set but not used) on g++4.6 \\\n* [Issue #126](https://github.com/json-c/json-c/issues/126) - Removed unused size variable. \\\n* [Issue #127](https://github.com/json-c/json-c/issues/127) - remove unused `size` variable \\\n* [Issue #128](https://github.com/json-c/json-c/issues/128) - Remove unused variable from json_tokenizer.c \\\n* [Issue #130](https://github.com/json-c/json-c/issues/130) - Failed to compile under Ubuntu 13.10 32bit \\\n* [Issue #131](https://github.com/json-c/json-c/issues/131) - undefined symbol: __sync_val_compare_and_swap_4 \\\n* [Issue #132](https://github.com/json-c/json-c/issues/132) - Remove unused variable 'size' \\\n* [Issue #133](https://github.com/json-c/json-c/issues/133) - Update and rename README to README.md \\\n* [Issue #134](https://github.com/json-c/json-c/issues/134) - Must remove variable size... \\\n* [Issue #135](https://github.com/json-c/json-c/issues/135) - bits.h uses removed json_tokener_errors\\[error\\] \\\n* [Issue #136](https://github.com/json-c/json-c/issues/136) - Error when running make check \\\n* [Issue #137](https://github.com/json-c/json-c/issues/137) - config.h.in should not be in git \\\n* [Issue #138](https://github.com/json-c/json-c/issues/138) - Can't build on RHEL 6.5 due to dependency on automake-1.14 \\\n* [Issue #140](https://github.com/json-c/json-c/issues/140) - Code bug in random_test.c evaluating same expression twice \\\n* [Issue #141](https://github.com/json-c/json-c/issues/141) - Removed duplicate check in random_seed test - bug #140 \\\n* [Issue #142](https://github.com/json-c/json-c/issues/142) - Please undeprecate json_object_object_get \\\n* [Issue #144](https://github.com/json-c/json-c/issues/144) - Introduce json_object_from_fd \\\n* [Issue #145](https://github.com/json-c/json-c/issues/145) - Handle % character properly \\\n* [Issue #146](https://github.com/json-c/json-c/issues/146) - TAGS rename \\\n* [Issue #148](https://github.com/json-c/json-c/issues/148) - Bump the soname \\\n* [Issue #149](https://github.com/json-c/json-c/issues/149) - SONAME bump \\\n* [Issue #150](https://github.com/json-c/json-c/issues/150) - Fix build using MinGW. \\\n* [Issue #151](https://github.com/json-c/json-c/issues/151) - Remove json_type enum trailing comma \\\n* [Issue #152](https://github.com/json-c/json-c/issues/152) - error while compiling json-c library version 0.11 \\\n* [Issue #153](https://github.com/json-c/json-c/issues/153) - improve doc for json_object_to_json_string() \\\n* [Issue #154](https://github.com/json-c/json-c/issues/154) - double precision \\\n* [Issue #155](https://github.com/json-c/json-c/issues/155) - add bsearch for arrays \\\n* [Issue #156](https://github.com/json-c/json-c/issues/156) - Remove trailing whitespaces \\\n* [Issue #157](https://github.com/json-c/json-c/issues/157) - JSON-C shall not exit on calloc fail. \\\n* [Issue #158](https://github.com/json-c/json-c/issues/158) - while using json-c 0.11, I am facing strange crash issue in json_object_put. \\\n* [Issue #159](https://github.com/json-c/json-c/issues/159) - json_tokener.c compile error \\\n* [Issue #160](https://github.com/json-c/json-c/issues/160) - missing header file on windows?? \\\n* [Issue #161](https://github.com/json-c/json-c/issues/161) - Is there a way to append to file? \\\n* [Issue #162](https://github.com/json-c/json-c/issues/162) - json_util: add directory check for POSIX distros \\\n* [Issue #163](https://github.com/json-c/json-c/issues/163) - Fix Win32 build problems \\\n* [Issue #164](https://github.com/json-c/json-c/issues/164) - made it compile and link on Widnows (as static library) \\\n* [Issue #165](https://github.com/json-c/json-c/issues/165) - json_object_to_json_string_ext length \\\n* [Issue #167](https://github.com/json-c/json-c/issues/167) - Can't build on Windows with Visual Studio 2010 \\\n* [Issue #168](https://github.com/json-c/json-c/issues/168) - Tightening the number parsing algorithm \\\n* [Issue #169](https://github.com/json-c/json-c/issues/169) - Doesn't compile on ubuntu 14.04, 64bit \\\n* [Issue #170](https://github.com/json-c/json-c/issues/170) - Generated files in repository \\\n* [Issue #171](https://github.com/json-c/json-c/issues/171) - Update configuration for VS2010 and win64 \\\n* [Issue #172](https://github.com/json-c/json-c/issues/172) - Adding support for parsing octal numbers \\\n* [Issue #173](https://github.com/json-c/json-c/issues/173) - json_parse_int64 doesn't work correctly at illumos \\\n* [Issue #174](https://github.com/json-c/json-c/issues/174) - Adding JSON_C_TO_STRING_PRETTY_TAB flag \\\n* [Issue #175](https://github.com/json-c/json-c/issues/175) - make check fails 4 tests with overflows when built with ASAN \\\n* [Issue #176](https://github.com/json-c/json-c/issues/176) - Possible to delete an array element at a given idx ? \\\n* [Issue #177](https://github.com/json-c/json-c/issues/177) - Fix compiler warnings \\\n* [Issue #178](https://github.com/json-c/json-c/issues/178) - Unable to compile on CentOS5 \\\n* [Issue #179](https://github.com/json-c/json-c/issues/179) - Added array_list_del_idx and json_object_array_del_idx \\\n* [Issue #180](https://github.com/json-c/json-c/issues/180) - Enable silent build by default \\\n* [Issue #181](https://github.com/json-c/json-c/issues/181) - json_tokener_parse_ex accepts invalid JSON \\\n* [Issue #182](https://github.com/json-c/json-c/issues/182) - Link against libm when needed \\\n* [Issue #183](https://github.com/json-c/json-c/issues/183) - Apply compile warning fix to master branch \\\n* [Issue #184](https://github.com/json-c/json-c/issues/184) - Use only GCC-specific flags when compiling with GCC \\\n* [Issue #185](https://github.com/json-c/json-c/issues/185) - compile error \\\n* [Issue #186](https://github.com/json-c/json-c/issues/186) - Syntax error \\\n* [Issue #187](https://github.com/json-c/json-c/issues/187) - array_list_get_idx and negative indexes. \\\n* [Issue #188](https://github.com/json-c/json-c/issues/188) - json_object_object_foreach warnings \\\n* [Issue #189](https://github.com/json-c/json-c/issues/189) - noisy json_object_from_file: error opening file \\\n* [Issue #190](https://github.com/json-c/json-c/issues/190) - warning: initialization discards const qualifier from pointer target type \\[enabled by default\\] \\\n* [Issue #192](https://github.com/json-c/json-c/issues/192) - json_tokener_parse  accepts invalid JSON {\"key\": \"value\" ,  } \\\n* [Issue #193](https://github.com/json-c/json-c/issues/193) - Make serialization format of doubles configurable \\\n* [Issue #194](https://github.com/json-c/json-c/issues/194) - Add utility function for comparing json_objects \\\n* [Issue #195](https://github.com/json-c/json-c/issues/195) - Call uselocale instead of setlocale \\\n* [Issue #196](https://github.com/json-c/json-c/issues/196) - Performance improvements \\\n* [Issue #197](https://github.com/json-c/json-c/issues/197) - Time for a new release? \\\n* [Issue #198](https://github.com/json-c/json-c/issues/198) - Fix possible memory leak and remove superfluous NULL checks before free() \\\n* [Issue #199](https://github.com/json-c/json-c/issues/199) - Fix build in Visual Studio \\\n* [Issue #200](https://github.com/json-c/json-c/issues/200) - Add build scripts for CI platforms \\\n* [Issue #201](https://github.com/json-c/json-c/issues/201) - disable forward-slash escaping? \\\n* [Issue #202](https://github.com/json-c/json-c/issues/202) - Array with objects support \\\n* [Issue #203](https://github.com/json-c/json-c/issues/203) - Add source position/coordinates to API \\\n* [Issue #204](https://github.com/json-c/json-c/issues/204) - json-c/json.h not found \\\n* [Issue #205](https://github.com/json-c/json-c/issues/205) - json-c Compiled with Visual Studios \\\n* [Issue #206](https://github.com/json-c/json-c/issues/206) - what do i use in place of json_object_object_get? \\\n* [Issue #207](https://github.com/json-c/json-c/issues/207) - Add support for property pairs directly added to arrays \\\n* [Issue #208](https://github.com/json-c/json-c/issues/208) - Performance enhancements (mainly) to json_object_to_json_string() \\\n* [Issue #209](https://github.com/json-c/json-c/issues/209) - fix regression from 2d549662be832da838aa063da2efa78ee3b99668 \\\n* [Issue #210](https://github.com/json-c/json-c/issues/210) - Use size_t for arrays \\\n* [Issue #211](https://github.com/json-c/json-c/issues/211) - Atomic updates for the refcount \\\n* [Issue #212](https://github.com/json-c/json-c/issues/212) - Refcount doesn't work between threads \\\n* [Issue #213](https://github.com/json-c/json-c/issues/213) - fix to compile with microsoft visual c++ 2010 \\\n* [Issue #214](https://github.com/json-c/json-c/issues/214) - Some non-GNU systems support __sync_val_compare_and_swap \\\n* [Issue #215](https://github.com/json-c/json-c/issues/215) - Build json-c for window 64 bit. \\\n* [Issue #216](https://github.com/json-c/json-c/issues/216) - configure: check realloc with AC_CHECK_FUNCS() to fix cross-compilation. \\\n* [Issue #217](https://github.com/json-c/json-c/issues/217) - Checking for functions in float.h \\\n* [Issue #218](https://github.com/json-c/json-c/issues/218) - Use a macro to indicate C99 to the compiler \\\n* [Issue #219](https://github.com/json-c/json-c/issues/219) - Fix various potential null ptr deref and int32 overflows \\\n* [Issue #220](https://github.com/json-c/json-c/issues/220) - Add utility function for comparing json_objects \\\n* [Issue #221](https://github.com/json-c/json-c/issues/221) - JSON_C_TO_STRING_NOSLASHESCAPE works incorrectly \\\n* [Issue #222](https://github.com/json-c/json-c/issues/222) - Fix issue #221: JSON_C_TO_STRING_NOSLASHESCAPE works incorrectly \\\n* [Issue #223](https://github.com/json-c/json-c/issues/223) - Clarify json_object_get_string documentation of NULL handling & return \\\n* [Issue #224](https://github.com/json-c/json-c/issues/224) - json_tokener.c - all warnings being treated as errors \\\n* [Issue #225](https://github.com/json-c/json-c/issues/225) - Hi, will you support clib as a \"registry\"? \\\n* [Issue #227](https://github.com/json-c/json-c/issues/227) - Bump SOVERSION to 3 \\\n* [Issue #228](https://github.com/json-c/json-c/issues/228) - avoid double slashes from json \\\n* [Issue #229](https://github.com/json-c/json-c/issues/229) - configure fails: checking size of size_t... configure: error: cannot determine a size for size_t \\\n* [Issue #230](https://github.com/json-c/json-c/issues/230) - Use stdint.h to check for size_t size \\\n* [Issue #231](https://github.com/json-c/json-c/issues/231) - Fix size_t size check for first-time builds \\\n* [Issue #232](https://github.com/json-c/json-c/issues/232) - tests/tests1: fix printf format for size_t arguments \\\n* [Issue #233](https://github.com/json-c/json-c/issues/233) - Include stddef.h in json_object.h \\\n* [Issue #234](https://github.com/json-c/json-c/issues/234) - Add public API to use userdata independently of custom serializer \\\n* [Issue #235](https://github.com/json-c/json-c/issues/235) - Undefined symbols Error for architecture x86_64 on Mac \\\n* [Issue #236](https://github.com/json-c/json-c/issues/236) - Building a project which uses json-c with flag -Wcast-qual causes compilation errors \\\n* [Issue #237](https://github.com/json-c/json-c/issues/237) - handle escaped utf-8 \\\n* [Issue #238](https://github.com/json-c/json-c/issues/238) - linkhash.c: optimised the table_free path \\\n* [Issue #239](https://github.com/json-c/json-c/issues/239) - initialize null terminator of new printbuf \\\n* [Issue #240](https://github.com/json-c/json-c/issues/240) - Compile error: Variable set but not used \\\n* [Issue #241](https://github.com/json-c/json-c/issues/241) - getting error in date string 19\\/07\\/2016, fixed for error 19/07/2016 \\\n* [Issue #242](https://github.com/json-c/json-c/issues/242) - json_tokener_parse error \\\n* [Issue #243](https://github.com/json-c/json-c/issues/243) - Fix #165 \\\n* [Issue #244](https://github.com/json-c/json-c/issues/244) - Error while compiling source from RHEL5, could you please help me to fix this \\\n* [Issue #245](https://github.com/json-c/json-c/issues/245) - json-c compile in window xp \\\n* [Issue #246](https://github.com/json-c/json-c/issues/246) - Mac: uselocale failed to build \\\n* [Issue #247](https://github.com/json-c/json-c/issues/247) - json_object_array_del_idx function has segment fault error? \\\n* [Issue #248](https://github.com/json-c/json-c/issues/248) - Minor changes in C source code \\\n* [Issue #249](https://github.com/json-c/json-c/issues/249) - Improving README \\\n* [Issue #250](https://github.com/json-c/json-c/issues/250) - Improving .gitignore \\\n* [Issue #251](https://github.com/json-c/json-c/issues/251) - Adding a file for EditorConfig \\\n* [Issue #252](https://github.com/json-c/json-c/issues/252) - Very minor changes not related to C source code \\\n* [Issue #253](https://github.com/json-c/json-c/issues/253) - Adding a test with cppcheck for Travis CI \\\n* [Issue #254](https://github.com/json-c/json-c/issues/254) - Very minor changes to some tests \\\n* [Issue #255](https://github.com/json-c/json-c/issues/255) - Minor changes in C source code \\\n* [Issue #256](https://github.com/json-c/json-c/issues/256) - Mailing list dead? \\\n* [Issue #257](https://github.com/json-c/json-c/issues/257) - Defining a coding style \\\n* [Issue #258](https://github.com/json-c/json-c/issues/258) - Enable CI services \\\n* [Issue #259](https://github.com/json-c/json-c/issues/259) - Fails to parse valid json \\\n* [Issue #260](https://github.com/json-c/json-c/issues/260) - Adding an object to itself \\\n* [Issue #261](https://github.com/json-c/json-c/issues/261) - Lack of proper documentation \\\n* [Issue #262](https://github.com/json-c/json-c/issues/262) - Add Cmakefile and fix compiler warning. \\\n* [Issue #263](https://github.com/json-c/json-c/issues/263) - Compiler Warnings with VS2015 \\\n* [Issue #264](https://github.com/json-c/json-c/issues/264) - successed in simple test   while failed in my project \\\n* [Issue #265](https://github.com/json-c/json-c/issues/265) - Conformance report for reference \\\n* [Issue #266](https://github.com/json-c/json-c/issues/266) - crash perhaps related to reference counting \\\n* [Issue #267](https://github.com/json-c/json-c/issues/267) - Removes me as Win32 maintainer, because I'm not. \\\n* [Issue #268](https://github.com/json-c/json-c/issues/268) - Documentation of json_object_to_json_string gives no information about memory management \\\n* [Issue #269](https://github.com/json-c/json-c/issues/269) - json_object_<type>_set(json_object *o,<type> value) API for value setting in json object private structure \\\n* [Issue #270](https://github.com/json-c/json-c/issues/270) - new API json_object_new_double_f(doubel d,const char * fmt); \\\n* [Issue #271](https://github.com/json-c/json-c/issues/271) - Cannot compile using CMake on macOS \\\n* [Issue #273](https://github.com/json-c/json-c/issues/273) - fixed wrong object name in json_object_all_values_equal \\\n* [Issue #274](https://github.com/json-c/json-c/issues/274) - Support for 64 bit pointers on Windows \\\n* [Issue #275](https://github.com/json-c/json-c/issues/275) - Out-of-bounds read in json_tokener_parse_ex \\\n* [Issue #276](https://github.com/json-c/json-c/issues/276) - ./configure for centos release 6.7(final) failure \\\n* [Issue #277](https://github.com/json-c/json-c/issues/277) - Json object set xxx \\\n* [Issue #278](https://github.com/json-c/json-c/issues/278) - Serialization of double with no fractional component drops trailing zero \\\n* [Issue #279](https://github.com/json-c/json-c/issues/279) - Segmentation fault in array_list_length() \\\n* [Issue #280](https://github.com/json-c/json-c/issues/280) - Should json_object_array_get_idx  check whether input obj is array? \\\n* [Issue #281](https://github.com/json-c/json-c/issues/281) - how to pretty print json-c? \\\n* [Issue #282](https://github.com/json-c/json-c/issues/282) - ignore temporary files \\\n* [Issue #283](https://github.com/json-c/json-c/issues/283) - json_pointer: add first revision based on RFC 6901 \\\n* [Issue #284](https://github.com/json-c/json-c/issues/284) - Resusing  json_tokener object \\\n* [Issue #285](https://github.com/json-c/json-c/issues/285) - Revert \"compat/strdup.h: move common compat check for strdup() to own \\\n* [Issue #286](https://github.com/json-c/json-c/issues/286) - json_tokener_parse_ex() returns json_tokener_continue on zero-length string \\\n* [Issue #287](https://github.com/json-c/json-c/issues/287) - json_pointer: extend setter & getter with printf() style arguments \\\n* [Issue #288](https://github.com/json-c/json-c/issues/288) - Fix _GNU_SOURCE define for vasprintf \\\n* [Issue #289](https://github.com/json-c/json-c/issues/289) - bugfix: floating point representaion without fractional part \\\n* [Issue #290](https://github.com/json-c/json-c/issues/290) - duplicate an json_object \\\n* [Issue #291](https://github.com/json-c/json-c/issues/291) - isspace assert error \\\n* [Issue #292](https://github.com/json-c/json-c/issues/292) - configure error  \"./configure: line 13121: syntax error near unexpected token `-Wall'\" \\\n* [Issue #293](https://github.com/json-c/json-c/issues/293) - how to make with bitcode for ios \\\n* [Issue #294](https://github.com/json-c/json-c/issues/294) - Adding UTF-8 validation.  Fixes #122 \\\n* [Issue #295](https://github.com/json-c/json-c/issues/295) - cross compile w/ mingw \\\n* [Issue #296](https://github.com/json-c/json-c/issues/296) - Missing functions header in json_object.h \\\n* [Issue #297](https://github.com/json-c/json-c/issues/297) - could not parse string to Json object? Like string str=\\\"helloworld;E\\\\test\\\\log\\\\;end\\\" \\\n* [Issue #298](https://github.com/json-c/json-c/issues/298) - Building using CMake doesn't work \\\n* [Issue #299](https://github.com/json-c/json-c/issues/299) - Improve json_object -> string performance \\\n* [Issue #300](https://github.com/json-c/json-c/issues/300) - Running tests with MinGW build \\\n* [Issue #301](https://github.com/json-c/json-c/issues/301) - How to deep copy  json_object in C++ ? \\\n* [Issue #302](https://github.com/json-c/json-c/issues/302) - json_tokener_parse_ex doesn't parse JSON values \\\n* [Issue #303](https://github.com/json-c/json-c/issues/303) - fix doc in tokener header file \\\n* [Issue #304](https://github.com/json-c/json-c/issues/304) - (.text+0x72846): undefined reference to `is_error' \\\n* [Issue #305](https://github.com/json-c/json-c/issues/305) - Fix compilation without C-99 option \\\n* [Issue #306](https://github.com/json-c/json-c/issues/306) - ./configure: line 12748 -error=deprecated-declarations \\\n* [Issue #307](https://github.com/json-c/json-c/issues/307) - Memory leak in json_tokener_parse \\\n* [Issue #308](https://github.com/json-c/json-c/issues/308) - AM_PROG_LIBTOOL not found on Linux \\\n* [Issue #309](https://github.com/json-c/json-c/issues/309) - GCC 7 reports various -Wimplicit-fallthrough= errors \\\n* [Issue #310](https://github.com/json-c/json-c/issues/310) - Add FALLTHRU comment to handle GCC7 warnings. \\\n* [Issue #311](https://github.com/json-c/json-c/issues/311) - Fix error C3688 when compiling on Visual Studio 2015 \\\n* [Issue #312](https://github.com/json-c/json-c/issues/312) - Fix CMake Build process improved for MinGW and MSYS2 \\\n* [Issue #313](https://github.com/json-c/json-c/issues/313) - VERBOSE=1 make check; tests/test_util_file.test.c and tests/test_util_file.expected out of sync \\\n* [Issue #315](https://github.com/json-c/json-c/issues/315) - Passing -1 to json_tokener_parse_ex is possibly unsafe \\\n* [Issue #316](https://github.com/json-c/json-c/issues/316) - Memory Returned by json_object_to_json_string not freed \\\n* [Issue #317](https://github.com/json-c/json-c/issues/317) - json_object_get_string gives segmentation error \\\n* [Issue #318](https://github.com/json-c/json-c/issues/318) - PVS-Studio static analyzer analyze results \\\n* [Issue #319](https://github.com/json-c/json-c/issues/319) - Windows: Fix dynamic library build with Visual Studio \\\n* [Issue #320](https://github.com/json-c/json-c/issues/320) - Can't compile in Mac OS X El Capitan \\\n* [Issue #321](https://github.com/json-c/json-c/issues/321) - build,cmake: fix vasprintf implicit definition and generate both static & shared libs \\\n* [Issue #322](https://github.com/json-c/json-c/issues/322) - can not link with libjson-c.a \\\n* [Issue #323](https://github.com/json-c/json-c/issues/323) - implicit fallthrough detected by gcc 7.1 \\\n* [Issue #324](https://github.com/json-c/json-c/issues/324) - JsonPath like function? \\\n* [Issue #325](https://github.com/json-c/json-c/issues/325) - Fix stack buffer overflow in json_object_double_to_json_string_format() \\\n* [Issue #327](https://github.com/json-c/json-c/issues/327) - why json-c so hard to compile \\\n* [Issue #328](https://github.com/json-c/json-c/issues/328) - json_object: implement json_object_deep_copy() function \\\n* [Issue #329](https://github.com/json-c/json-c/issues/329) - build,cmake: build,cmake: rename libjson-c-static.a to libjson-c.a \\\n* [Issue #330](https://github.com/json-c/json-c/issues/330) - tests: symlink basic tests to a single file that has the common code \\\n* [Issue #331](https://github.com/json-c/json-c/issues/331) - Safe use of snprintf() / vsnprintf() for Visual studio, and thread-safety fix \\\n* [Issue #332](https://github.com/json-c/json-c/issues/332) - Valgrind: invalid read after json_object_array_del_idx. \\\n* [Issue #333](https://github.com/json-c/json-c/issues/333) - Replace obsolete AM_PROG_LIBTOOL \\\n* [Issue #335](https://github.com/json-c/json-c/issues/335) - README.md: show build status tag from travis-ci.org \\\n* [Issue #336](https://github.com/json-c/json-c/issues/336) - tests: fix tests in travis-ci.org \\\n* [Issue #337](https://github.com/json-c/json-c/issues/337) - Synchronize \"potentially racy\" random seed in lh_char_hash() \\\n* [Issue #338](https://github.com/json-c/json-c/issues/338) - implement json_object_int_inc(json_object *, int64_t) \\\n* [Issue #339](https://github.com/json-c/json-c/issues/339) - Json schema validation \\\n* [Issue #340](https://github.com/json-c/json-c/issues/340) - strerror_override: add extern \"C\" and JSON_EXPORT specifiers for Visual C++ compilers \\\n* [Issue #341](https://github.com/json-c/json-c/issues/341) - character \"/\" parse as \"\\/\" \\\n* [Issue #342](https://github.com/json-c/json-c/issues/342) - No such file or directory \"/usr/include/json.h\" \\\n* [Issue #343](https://github.com/json-c/json-c/issues/343) - Can't parse json \\\n* [Issue #344](https://github.com/json-c/json-c/issues/344) - Fix Mingw build \\\n* [Issue #345](https://github.com/json-c/json-c/issues/345) - Fix make dist and make distcheck \\\n* [Issue #346](https://github.com/json-c/json-c/issues/346) - Clamp double to int32 when narrowing in json_object_get_int. \\\n* [Issue #347](https://github.com/json-c/json-c/issues/347) - MSVC linker error json_c_strerror \\\n* [Issue #348](https://github.com/json-c/json-c/issues/348) - why \\\n* [Issue #349](https://github.com/json-c/json-c/issues/349) - `missing` is missing? \\\n* [Issue #350](https://github.com/json-c/json-c/issues/350) - stderror-override and disable-shared \\\n* [Issue #351](https://github.com/json-c/json-c/issues/351) - SIZE_T_MAX redefined from limits.h \\\n* [Issue #352](https://github.com/json-c/json-c/issues/352) - `INSTALL` overrides an automake script. \\\n* [Issue #353](https://github.com/json-c/json-c/issues/353) - Documentation issues \\\n* [Issue #354](https://github.com/json-c/json-c/issues/354) - Fixes #351 #352 #353 \\\n* [Issue #355](https://github.com/json-c/json-c/issues/355) - 1.make it can been compiled with Visual Studio 2010 by modify the CMakeList.txt and others \\\n* [Issue #356](https://github.com/json-c/json-c/issues/356) - VS2008 test  test_util_file.cpp err! \\\n* [Issue #357](https://github.com/json-c/json-c/issues/357) - __json_c_strerror incompatibility with link-time optimization \\\n* [Issue #358](https://github.com/json-c/json-c/issues/358) - make issue \\\n* [Issue #359](https://github.com/json-c/json-c/issues/359) - update CMakeLists.txt for compile with visual studio at least 2010 \\\n* [Issue #360](https://github.com/json-c/json-c/issues/360) - Use strtoll() to parse ints \\\n* [Issue #361](https://github.com/json-c/json-c/issues/361) - Fix double to int cast overflow in json_object_get_int64. \\\n* [Issue #362](https://github.com/json-c/json-c/issues/362) - CMake Package Config \\\n* [Issue #363](https://github.com/json-c/json-c/issues/363) - Issue #338, add json_object_add_int functions \\\n* [Issue #364](https://github.com/json-c/json-c/issues/364) - Cmake is Errir \\\n* [Issue #365](https://github.com/json-c/json-c/issues/365) - added fallthrough for gcc7 \\\n* [Issue #366](https://github.com/json-c/json-c/issues/366) - how to check  the json string,crash! \\\n* [Issue #367](https://github.com/json-c/json-c/issues/367) - Is json-c support \"redirect\" semantic? \\\n* [Issue #368](https://github.com/json-c/json-c/issues/368) - Add examples \\\n* [Issue #369](https://github.com/json-c/json-c/issues/369) - How to build json-c library for android? \\\n* [Issue #370](https://github.com/json-c/json-c/issues/370) - Compiling using clang-cl \\\n* [Issue #371](https://github.com/json-c/json-c/issues/371) - Invalid parsing for Infinity with json-c 0.12 \\\n* [Issue #372](https://github.com/json-c/json-c/issues/372) - Json-c 0.12: Fixed Infinity bug \\\n* [Issue #373](https://github.com/json-c/json-c/issues/373) - build: fix build on appveyor CI \\\n* [Issue #374](https://github.com/json-c/json-c/issues/374) - Undefined symbols for architecture x86_64: \\\n* [Issue #375](https://github.com/json-c/json-c/issues/375) - what would happened when json_object_object_add add the same key \\\n* [Issue #376](https://github.com/json-c/json-c/issues/376) - Eclipse error \\\n* [Issue #377](https://github.com/json-c/json-c/issues/377) - on gcc 7.2.0 on my linux distribution with json-c  2013-04-02 source \\\n* [Issue #378](https://github.com/json-c/json-c/issues/378) - Eclipse: library (libjson-c) not found, but configured \\\n* [Issue #379](https://github.com/json-c/json-c/issues/379) - error: this statement may fall through \\[-Werror=implicit-fallthrough=\\] \\\n* [Issue #380](https://github.com/json-c/json-c/issues/380) - Build on Windows \\\n* [Issue #381](https://github.com/json-c/json-c/issues/381) - Fix makedist \\\n* [Issue #382](https://github.com/json-c/json-c/issues/382) - Memory leak for json_tokener_parse_ex for version 0.12.1 \\\n* [Issue #383](https://github.com/json-c/json-c/issues/383) - Fix a compiler warning. \\\n* [Issue #384](https://github.com/json-c/json-c/issues/384) - Fix a VS 2015 compiler warnings. \\\n"
        },
        {
          "name": "issues_closed_for_0.14.md",
          "type": "blob",
          "size": 19.93359375,
          "content": "This list was created with:\n\n```\ncurl https://api.github.com/search/issues?q=\"repo%3Ajson-c%2Fjson-c+closed%3A>2017-12-07+created%3A<2020-04-17&sort=created&order=asc&per_page=400&page=1\" > issues1.out\ncurl https://api.github.com/search/issues?q=\"repo%3Ajson-c%2Fjson-c+closed%3A>2017-12-07+created%3A<2020-04-17&sort=created&order=asc&per_page=400&page=2\" > issues2.out\ncurl https://api.github.com/search/issues?q=\"repo%3Ajson-c%2Fjson-c+closed%3A>2017-12-07+created%3A<2020-04-17&sort=created&order=asc&per_page=400&page=3\" > issues3.out\njq -r '.items[] | \"[\" + .title + \"](\" + .url + \")\" | tostring' issues?.out > issues.md\nsed -e's,^\\[ *\\(.*\\)\\](https://api.github.com/.*/\\([0-9].*\\)),[Issue #\\2](https://github.com/json-c/json-c/issues/\\2) - \\1,' -i issues.md\n#... manual editing ...\n```\n\n----\n\nIssues and Pull Requests closed for the 0.14 release (since commit d582d3a(2017-12-07) to a911439(2020-04-17))\n\n\n* [Issue #122](https://github.com/json-c/json-c/issues/122) - Add utf-8 validation when parsing strings. \\\n* [Issue #139](https://github.com/json-c/json-c/issues/139) - json_object_from_file cannot accept max_depth \\\n* [Issue #143](https://github.com/json-c/json-c/issues/143) - RFE / enhancement for full 64-bit signed/unsigned support \\\n* [Issue #147](https://github.com/json-c/json-c/issues/147) - Please introduce soname bump if API changed \\\n* [Issue #166](https://github.com/json-c/json-c/issues/166) - Need a way to specify nesting depth when opening JSON file \\\n* [Issue #226](https://github.com/json-c/json-c/issues/226) - There is no json_object_new_null() \\\n* [Issue #314](https://github.com/json-c/json-c/issues/314) - new release ? \\\n* [Issue #326](https://github.com/json-c/json-c/issues/326) - Please extend api json_object_get_uint64 \\\n* [Issue #334](https://github.com/json-c/json-c/issues/334) - Switch json-c builds to use CMake \\\n* [Issue #386](https://github.com/json-c/json-c/issues/386) - Makefile: Add ACLOCAL_AMFLAGS \\\n* [Issue #387](https://github.com/json-c/json-c/issues/387) - doc: Use other doxygen feature to specify mainpage \\\n* [Issue #388](https://github.com/json-c/json-c/issues/388) - json_object: Add size_t json_object_sizeof() \\\n* [Issue #389](https://github.com/json-c/json-c/issues/389) - json_object: Avoid double free (and thus a segfault) when ref_count gets < 0 \\\n* [Issue #390](https://github.com/json-c/json-c/issues/390) - json_object: Add const size_t json_c_object_sizeof() \\\n* [Issue #391](https://github.com/json-c/json-c/issues/391) - Fix non-GNUC define for JSON_C_CONST_FUNCTION \\\n* [Issue #392](https://github.com/json-c/json-c/issues/392) - json_object: Avoid invalid free (and thus a segfault) when ref_count gets < 0 \\\n* [Issue #393](https://github.com/json-c/json-c/issues/393) - json_object_private: Use unsigned 32-bit integer type for refcount \\\n* [Issue #394](https://github.com/json-c/json-c/issues/394) - Problem serializing double \\\n* [Issue #395](https://github.com/json-c/json-c/issues/395) - Key gets modified if it contains \"\\\" \\\n* [Issue #396](https://github.com/json-c/json-c/issues/396) - Build failure with no threads uClibc toolchain \\\n* [Issue #397](https://github.com/json-c/json-c/issues/397) - update json object with key. \\\n* [Issue #398](https://github.com/json-c/json-c/issues/398) - Build failed. \\\n* [Issue #399](https://github.com/json-c/json-c/issues/399) - Avoid uninitialized variable warnings \\\n* [Issue #400](https://github.com/json-c/json-c/issues/400) - How to generate static lib (.a) \\\n* [Issue #401](https://github.com/json-c/json-c/issues/401) - Warnings with Valgrind \\\n* [Issue #402](https://github.com/json-c/json-c/issues/402) - Add fuzzers from OSS-Fuzz \\\n* [Issue #403](https://github.com/json-c/json-c/issues/403) - Segmentation fault when double quotes is used \\\n* [Issue #404](https://github.com/json-c/json-c/issues/404) - valgrind: memory leak \\\n* [Issue #405](https://github.com/json-c/json-c/issues/405) - Missing API to determine an object is empty \\\n* [Issue #406](https://github.com/json-c/json-c/issues/406) - Undefine NDEBUG for tests \\\n* [Issue #407](https://github.com/json-c/json-c/issues/407) - json_tokener_parse is crash \\\n* [Issue #408](https://github.com/json-c/json-c/issues/408) - bug in array_list_del_idx when array_list_length()==1 \\\n* [Issue #410](https://github.com/json-c/json-c/issues/410) - Fixed typos \\\n* [Issue #411](https://github.com/json-c/json-c/issues/411) - Crash- signal SIGSEGV, Segmentation fault. ../sysdeps/x86_64/strlen.S: No such file or directory. \\\n* [Issue #412](https://github.com/json-c/json-c/issues/412) - json_type changes during inter process communication. \\\n* [Issue #413](https://github.com/json-c/json-c/issues/413) - how to read object of type `json_object *` in c++ \\\n* [Issue #414](https://github.com/json-c/json-c/issues/414) - [Question] How JSON-c stores the serialized data in memory? \\\n* [Issue #415](https://github.com/json-c/json-c/issues/415) - Resolve windows name conflict \\\n* [Issue #416](https://github.com/json-c/json-c/issues/416) - segmentation fault  in json_tokener_parse \\\n* [Issue #417](https://github.com/json-c/json-c/issues/417) - json_tokener_parse  json_object_object_get_ex with string value which is json string \\\n* [Issue #418](https://github.com/json-c/json-c/issues/418) - json_object_from_* return value documented incorrectly \\\n* [Issue #419](https://github.com/json-c/json-c/issues/419) - Suggestion: document (and define) that json_object_put() accepts NULL pointer to object \\\n* [Issue #420](https://github.com/json-c/json-c/issues/420) - arraylist: Fixed names of parameters for callback function \\\n* [Issue #421](https://github.com/json-c/json-c/issues/421) - install json_object_iterator.h header file \\\n* [Issue #422](https://github.com/json-c/json-c/issues/422) - json_object_get_double() does not set errno when there is no valid conversion \\\n* [Issue #423](https://github.com/json-c/json-c/issues/423) - memory leak \\\n* [Issue #424](https://github.com/json-c/json-c/issues/424) - Parse string contains \"\\\" or \"/\" errors \\\n* [Issue #425](https://github.com/json-c/json-c/issues/425) - what this is? \\\n* [Issue #426](https://github.com/json-c/json-c/issues/426) - __deprecated not supported on clang. \\\n* [Issue #427](https://github.com/json-c/json-c/issues/427) - CMake: builds involving this target will not be correct \\\n* [Issue #430](https://github.com/json-c/json-c/issues/430) - json_object_object_del() and Segmentation fault \\\n* [Issue #431](https://github.com/json-c/json-c/issues/431) - cmake: Bump required version \\\n* [Issue #432](https://github.com/json-c/json-c/issues/432) - The real CMake support. \\\n* [Issue #433](https://github.com/json-c/json-c/issues/433) - The real CMake support. \\\n* [Issue #434](https://github.com/json-c/json-c/issues/434) - The real CMake support \\\n* [Issue #435](https://github.com/json-c/json-c/issues/435) - json_object_object_del() segmentation fault \\\n* [Issue #436](https://github.com/json-c/json-c/issues/436) - Improve pkgconfig setting \\\n* [Issue #437](https://github.com/json-c/json-c/issues/437) - Bad link in README.md \\\n* [Issue #438](https://github.com/json-c/json-c/issues/438) - Bad link in README.html \\\n* [Issue #439](https://github.com/json-c/json-c/issues/439) - reserved identifier violation \\\n* [Issue #440](https://github.com/json-c/json-c/issues/440) - Use of angle brackets around file names for include statements \\\n* [Issue #441](https://github.com/json-c/json-c/issues/441) - fix c flag loss during cmake building \\\n* [Issue #442](https://github.com/json-c/json-c/issues/442) - error  in configure file \\\n* [Issue #443](https://github.com/json-c/json-c/issues/443) - remove pretty spaces when using pretty tabs \\\n* [Issue #444](https://github.com/json-c/json-c/issues/444) - Document refcount of json_tokener_parse_ex return \\\n* [Issue #445](https://github.com/json-c/json-c/issues/445) - Add missing \"make check\" target to cmake config \\\n* [Issue #446](https://github.com/json-c/json-c/issues/446) - Forward slashes get escaped \\\n* [Issue #448](https://github.com/json-c/json-c/issues/448) - Buffer overflow in json-c \\\n* [Issue #449](https://github.com/json-c/json-c/issues/449) - Need of json_type_int64 returned by json_object_get_type() \\\n* [Issue #450](https://github.com/json-c/json-c/issues/450) - Allow use json-c cmake as subproject \\\n* [Issue #452](https://github.com/json-c/json-c/issues/452) - Update README.md \\\n* [Issue #453](https://github.com/json-c/json-c/issues/453) - Fixed misalignment in JSON string due to space after \\n being printed... \\\n* [Issue #454](https://github.com/json-c/json-c/issues/454) - json_object_private: save 8 bytes in struct json_object in 64-bit arc… \\\n* [Issue #455](https://github.com/json-c/json-c/issues/455) - index.html:fix dead link \\\n* [Issue #456](https://github.com/json-c/json-c/issues/456) - STYLE.txt:remove executable permissions \\\n* [Issue #457](https://github.com/json-c/json-c/issues/457) - .gitignore:add build directory \\\n* [Issue #458](https://github.com/json-c/json-c/issues/458) - README.md:fix dead \"file.html\" link \\\n* [Issue #459](https://github.com/json-c/json-c/issues/459) - README.html:fix link to Doxygen docs, remove WIN32 link \\\n* [Issue #460](https://github.com/json-c/json-c/issues/460) - No docs for json_object_new_string_len() \\\n* [Issue #461](https://github.com/json-c/json-c/issues/461) - json_object.c:set errno in json_object_get_double() \\\n* [Issue #462](https://github.com/json-c/json-c/issues/462) - json_object.h:document json_object_new_string_len() \\\n* [Issue #463](https://github.com/json-c/json-c/issues/463) - please check newlocale api first argument valuse. \\\n* [Issue #465](https://github.com/json-c/json-c/issues/465) - CMakeLists.txt doesn't contain json_object_iterator.h which json.h includes \\\n* [Issue #466](https://github.com/json-c/json-c/issues/466) - configure:3610: error: C compiler cannot create executables \\\n* [Issue #467](https://github.com/json-c/json-c/issues/467) - Fix compiler warnings \\\n* [Issue #468](https://github.com/json-c/json-c/issues/468) - Fix compiler warnings \\\n* [Issue #469](https://github.com/json-c/json-c/issues/469) - Build under alpine with pecl install & docker-php-ext-enable? \\\n* [Issue #470](https://github.com/json-c/json-c/issues/470) - cfuhash_foreach_remove doesn't upate cfuhash_num_entries \\\n* [Issue #472](https://github.com/json-c/json-c/issues/472) - Segmentation fault in json_object_iter_begin \\\n* [Issue #473](https://github.com/json-c/json-c/issues/473) - Convert ChangeLog to valid UTF-8 encoding. \\\n* [Issue #474](https://github.com/json-c/json-c/issues/474) - Installation directories empty with CMake in pkg-config. \\\n* [Issue #475](https://github.com/json-c/json-c/issues/475) - improvement proposal for json_object_object_foreach \\\n* [Issue #477](https://github.com/json-c/json-c/issues/477) - Hang/Crash with large strings \\\n* [Issue #478](https://github.com/json-c/json-c/issues/478) - json_object_get_string_len returns 0 when value is number \\\n* [Issue #479](https://github.com/json-c/json-c/issues/479) - I want to use it in iOS or Android but I can't compile \\\n* [Issue #480](https://github.com/json-c/json-c/issues/480) - json-c-0.12.1  failed making from source code \\\n* [Issue #481](https://github.com/json-c/json-c/issues/481) - error while loading shared libraries: libjson-c.so.4 \\\n* [Issue #482](https://github.com/json-c/json-c/issues/482) - Error \"double free or corruption\" after free() \\\n* [Issue #483](https://github.com/json-c/json-c/issues/483) - compatible with rarely-used Chinese characters in GBK charset \\\n* [Issue #485](https://github.com/json-c/json-c/issues/485) - Install CMake module files \\\n* [Issue #486](https://github.com/json-c/json-c/issues/486) - In the case of negative double value, it is formatted without including \".0\" \\\n* [Issue #488](https://github.com/json-c/json-c/issues/488) - Some APIs are not exported when built as shared lib on Win32 \\\n* [Issue #489](https://github.com/json-c/json-c/issues/489) - Don't use -Werror by default \\\n* [Issue #490](https://github.com/json-c/json-c/issues/490) - do not compile with -Werror by default \\\n* [Issue #491](https://github.com/json-c/json-c/issues/491) - build: add option --disable-werror to configure \\\n* [Issue #492](https://github.com/json-c/json-c/issues/492) - lack some quick usage in readme \\\n* [Issue #494](https://github.com/json-c/json-c/issues/494) - Code generator? \\\n* [Issue #495](https://github.com/json-c/json-c/issues/495) - README.md:fix 2 typos \\\n* [Issue #496](https://github.com/json-c/json-c/issues/496) - json_pointer.h:suggest minor grammar improvement for pointer doc \\\n* [Issue #497](https://github.com/json-c/json-c/issues/497) - add common header for all tests \\\n* [Issue #498](https://github.com/json-c/json-c/issues/498) - double_serializer_test fails (with valgrind) \\\n* [Issue #499](https://github.com/json-c/json-c/issues/499) - .travis.yml:test on more recent clang and gcc versions \\\n* [Issue #500](https://github.com/json-c/json-c/issues/500) - test/Makefile.am:add missing deps for test1 and test2 \\\n* [Issue #501](https://github.com/json-c/json-c/issues/501) - undefine NDEBUG for tests \\\n* [Issue #502](https://github.com/json-c/json-c/issues/502) - configure error \\\n* [Issue #503](https://github.com/json-c/json-c/issues/503) - json-c retuns OK when Invalid json string is passed \\\n* [Issue #504](https://github.com/json-c/json-c/issues/504) - json_object_put coredump \\\n* [Issue #505](https://github.com/json-c/json-c/issues/505) - Add vcpkg installation instructions \\\n* [Issue #506](https://github.com/json-c/json-c/issues/506) - Cannot parse more than one object \\\n* [Issue #509](https://github.com/json-c/json-c/issues/509) - Sometimes a double value is not serialized \\\n* [Issue #510](https://github.com/json-c/json-c/issues/510) - Bump so-name and improve CMake \\\n* [Issue #511](https://github.com/json-c/json-c/issues/511) - Reduce lines for better optimization \\\n* [Issue #512](https://github.com/json-c/json-c/issues/512) - Properly append to CMAKE_C_FLAGS string \\\n* [Issue #513](https://github.com/json-c/json-c/issues/513) - What does `userdata` means?And what is the case we can use it? \\\n* [Issue #514](https://github.com/json-c/json-c/issues/514) - Json c 0.13 \\\n* [Issue #515](https://github.com/json-c/json-c/issues/515) - Mies suomesta fixes segfaults and logic errors \\\n* [Issue #516](https://github.com/json-c/json-c/issues/516) - Lja slight mods \\\n* [Issue #518](https://github.com/json-c/json-c/issues/518) - Escape character  \"\\\\003\\\", get unexpected value \\\n* [Issue #519](https://github.com/json-c/json-c/issues/519) - Add test case obj token \\\n* [Issue #520](https://github.com/json-c/json-c/issues/520) - Adding type uint64 \\\n* [Issue #521](https://github.com/json-c/json-c/issues/521) - build cmake windows 10 \\\n* [Issue #522](https://github.com/json-c/json-c/issues/522) - update json_visit testcase \\\n* [Issue #523](https://github.com/json-c/json-c/issues/523) - update tsetcase for tokener_c \\\n* [Issue #524](https://github.com/json-c/json-c/issues/524) - Increase coverage \\\n* [Issue #525](https://github.com/json-c/json-c/issues/525) - update pointer test case \\\n* [Issue #526](https://github.com/json-c/json-c/issues/526) - Increased the test coverage of printbuf.c 82% to 92%. \\\n* [Issue #527](https://github.com/json-c/json-c/issues/527) - Arraylist testcase \\\n* [Issue #528](https://github.com/json-c/json-c/issues/528) - Solve issue #108. Skip \\u0000 while parsing. \\\n* [Issue #529](https://github.com/json-c/json-c/issues/529) - Increased the test coverage of json_c_version.c 0% to 100%. \\\n* [Issue #530](https://github.com/json-c/json-c/issues/530) - validate utf-8 string before parse \\\n* [Issue #531](https://github.com/json-c/json-c/issues/531) - validate utf-8 string \\\n* [Issue #532](https://github.com/json-c/json-c/issues/532) - json_object_object_get_ex returning the original object \\\n* [Issue #533](https://github.com/json-c/json-c/issues/533) - Fix \"make check\" \\\n* [Issue #535](https://github.com/json-c/json-c/issues/535) - short string optimization: excessive array length \\\n* [Issue #536](https://github.com/json-c/json-c/issues/536) - add json_object_new_null() \\\n* [Issue #538](https://github.com/json-c/json-c/issues/538) - update shortstring and arraylist parameters \\\n* [Issue #539](https://github.com/json-c/json-c/issues/539) - double serializes to the old value after set_double \\\n* [Issue #541](https://github.com/json-c/json-c/issues/541) - add coveralls auto tool to json-c \\\n* [Issue #542](https://github.com/json-c/json-c/issues/542) - add uint64 data to json-c \\\n* [Issue #543](https://github.com/json-c/json-c/issues/543) - Readme \\\n* [Issue #544](https://github.com/json-c/json-c/issues/544) - Increase distcheck target in cmake \\\n* [Issue #545](https://github.com/json-c/json-c/issues/545) - add doc target in cmake \\\n* [Issue #546](https://github.com/json-c/json-c/issues/546) - Add uninstall target in cmake \\\n* [Issue #547](https://github.com/json-c/json-c/issues/547) - modify json-c default build type, and fix up the assert() errors in t… \\\n* [Issue #548](https://github.com/json-c/json-c/issues/548) - Solve some problems about cmake build type (debug/release) \\\n* [Issue #549](https://github.com/json-c/json-c/issues/549) - lib installation issues \\\n* [Issue #550](https://github.com/json-c/json-c/issues/550) - Format codes with clang-format tool? \\\n* [Issue #551](https://github.com/json-c/json-c/issues/551) - Allow hexadecimal number format convention parsing \\\n* [Issue #553](https://github.com/json-c/json-c/issues/553) - Fix/clang ubsan \\\n* [Issue #554](https://github.com/json-c/json-c/issues/554) - RFC 8259 compatibility mode \\\n* [Issue #555](https://github.com/json-c/json-c/issues/555) - Format json-c with clang-format tool \\\n* [Issue #556](https://github.com/json-c/json-c/issues/556) - Fixes various Wreturn-type and Wimplicit-fallthrough errors on Mingw-w64 \\\n* [Issue #557](https://github.com/json-c/json-c/issues/557) - Add option in CMAKE to not build documentation \\\n* [Issue #558](https://github.com/json-c/json-c/issues/558) - modify the doc target message \\\n* [Issue #559](https://github.com/json-c/json-c/issues/559) - json_c_visit() not exported on Windows \\\n* [Issue #560](https://github.com/json-c/json-c/issues/560) - error: implicit declaration of function '_strtoi64' \\\n* [Issue #561](https://github.com/json-c/json-c/issues/561) - add the badge in README.md and test the coveralls \\\n* [Issue #562](https://github.com/json-c/json-c/issues/562) - Bugfix and testcases supplements \\\n* [Issue #563](https://github.com/json-c/json-c/issues/563) - Changed order of calloc args to match stdlib \\\n* [Issue #564](https://github.com/json-c/json-c/issues/564) - Remove autogenerated files \\\n* [Issue #565](https://github.com/json-c/json-c/issues/565) - test the CI and ignore this PR \\\n* [Issue #566](https://github.com/json-c/json-c/issues/566) - add the json_types.h to Makefile.am \\\n* [Issue #567](https://github.com/json-c/json-c/issues/567) - Install json_types.h with autotools build as well. \\\n* [Issue #568](https://github.com/json-c/json-c/issues/568) - Adding better support to MinGW \\\n* [Issue #569](https://github.com/json-c/json-c/issues/569) - Handling of -Bsymbolic-function in CMakeLists.txt is deficient \\\n* [Issue #571](https://github.com/json-c/json-c/issues/571) - CMake: Bump SONAME to 5. \\\n* [Issue #572](https://github.com/json-c/json-c/issues/572) - Small fixes to CMakeLists \\\n* [Issue #573](https://github.com/json-c/json-c/issues/573) - Fix coveralls submission. \\\n* [Issue #574](https://github.com/json-c/json-c/issues/574) - autogen.sh missing from repository \\\n* [Issue #575](https://github.com/json-c/json-c/issues/575) - Small cosmetics. \\\n* [Issue #576](https://github.com/json-c/json-c/issues/576) - Test coverage for json_c_version. \\\n* [Issue #577](https://github.com/json-c/json-c/issues/577) - Be verbose on failing json_c_version test. \\\n* [Issue #578](https://github.com/json-c/json-c/issues/578) - CMake: Install pkgconfig file in proper location by default \\\n* [Issue #579](https://github.com/json-c/json-c/issues/579) - Enforce strict prototypes. \\\n* [Issue #580](https://github.com/json-c/json-c/issues/580) - Fix CMake tests for enforced strict prototypes. \\\n* [Issue #581](https://github.com/json-c/json-c/issues/581) - CMakeLists: do not enforce strict prototypes on Windows. \\\n"
        },
        {
          "name": "issues_closed_for_0.15.md",
          "type": "blob",
          "size": 8.1728515625,
          "content": "This list was created with:\n\n```\ncurl \"https://api.github.com/search/issues?q=repo%3Ajson-c%2Fjson-c+closed%3A>2020-04-18+created%3A<2020-07-23&sort=created&order=asc&per_page=100&page=1\" > issues1.out\njq -r '.items[] | \"[\" + .title + \"](\" + .url + \")\" | tostring' issues?.out > issues.md\nsed -e's,^\\[ *\\(.*\\)\\](https://api.github.com/.*/\\([0-9].*\\)),* [Issue #\\2](https://github.com/json-c/json-c/issues/\\2) - \\1,' -i issues.md\n#... manual editing ...\n\n```\n\n----\n\nIssues and Pull Requests closed for the 0.15 release\n(since commit 31ab57ca, the 0.14 branch point, 2020-04-19)\n\n* [Issue #428](https://github.com/json-c/json-c/issues/428) - Added new_null() function\n* [Issue #429](https://github.com/json-c/json-c/issues/429) - Conflict of interest between JSON_C_TO_STRING_SPACED and JSON_C_TO_STRING_PRETTY\n* [Issue #451](https://github.com/json-c/json-c/issues/451) - Add option to disable HAVE___THREAD\n* [Issue #471](https://github.com/json-c/json-c/issues/471) - create folders with mode 0755 when building\n* [Issue #476](https://github.com/json-c/json-c/issues/476) - Add new function named json_object_new_string_noalloc\n* [Issue #484](https://github.com/json-c/json-c/issues/484) - Add support for uint64\n* [Issue #487](https://github.com/json-c/json-c/issues/487) - Any plans to make new release? (0.14)\n* [Issue #493](https://github.com/json-c/json-c/issues/493) - Kdopen rename library\n* [Issue #507](https://github.com/json-c/json-c/issues/507) - Double value -1.0 converts to integer in json_object_to_json_string()\n* [Issue #508](https://github.com/json-c/json-c/issues/508) - Recommend enabling the `-fPIC` compiler flag by default\n* [Issue #517](https://github.com/json-c/json-c/issues/517) - Lja mods\n* [Issue #534](https://github.com/json-c/json-c/issues/534) - Both json-c and json-glib have json_object_get_type()\n* [Issue #584](https://github.com/json-c/json-c/issues/584) - CMake: SOVERSION and the major library VERSION need to be in lockstep.\n* [Issue #585](https://github.com/json-c/json-c/issues/585) - CMake: Do not install config.h, as it is not a public header file.\n* [Issue #586](https://github.com/json-c/json-c/issues/586) - 10796 Segmentation fault\n* [Issue #588](https://github.com/json-c/json-c/issues/588) - Broken RDRAND causes infinite looping\n* [Issue #589](https://github.com/json-c/json-c/issues/589) - Detect broken RDRAND during initialization\n* [Issue #590](https://github.com/json-c/json-c/issues/590) - Fix segmentation fault in CPUID check\n* [Issue #591](https://github.com/json-c/json-c/issues/591) - Update README.md\n* [Issue #592](https://github.com/json-c/json-c/issues/592) - Prevent out of boundary write on malicious input\n* [Issue #593](https://github.com/json-c/json-c/issues/593) - Building both static and shared libraries\n* [Issue #594](https://github.com/json-c/json-c/issues/594) - Some subsequent call of lh_get_hash not working\n* [Issue #595](https://github.com/json-c/json-c/issues/595) - Support to build both static and shared libraries\n* [Issue #596](https://github.com/json-c/json-c/issues/596) - QA Notice: Package triggers severe warnings\n* [Issue #597](https://github.com/json-c/json-c/issues/597) - json_parse demo: fix and use usage() function\n* [Issue #598](https://github.com/json-c/json-c/issues/598) - Turning off shared libs causes target duplication or build error\n* [Issue #599](https://github.com/json-c/json-c/issues/599) - cannot add more than 11 objects. Is this a known issue?\n* [Issue #600](https://github.com/json-c/json-c/issues/600) - Library name conflicts on Windows are back again\n* [Issue #601](https://github.com/json-c/json-c/issues/601) - json_tokener_parse() in master sets errno=1 \"Operation not permitted\"\n* [Issue #602](https://github.com/json-c/json-c/issues/602) - fix json_parse_uint64() internal error checking with errno\n* [Issue #603](https://github.com/json-c/json-c/issues/603) - Backport of fixes from master branch.\n* [Issue #604](https://github.com/json-c/json-c/issues/604) - commit f2e991a3419ee4078e8915e840b1a0d9003b349e breaks cross-compilation with mingw\n* [Issue #605](https://github.com/json-c/json-c/issues/605) - Update to 0.15 release\n* [Issue #606](https://github.com/json-c/json-c/issues/606) - Improved support for IBM operating systems\n* [Issue #607](https://github.com/json-c/json-c/issues/607) - json-c-0.13.x: Fix CVE-2020-12762 - json-c through 0.14 has an integer overflow and out-of-bounds write ...\n* [Issue #608](https://github.com/json-c/json-c/issues/608) - json-c-0.14: Fix CVE-2020-12762 - json-c through 0.14 has an integer overflow and out-of-bounds write ...\n* [Issue #609](https://github.com/json-c/json-c/issues/609) - use unsigned types for sizes in lh_table and entries\n* [Issue #610](https://github.com/json-c/json-c/issues/610) - let's not call lh_table_resize with INT_MAX\n* [Issue #611](https://github.com/json-c/json-c/issues/611) - json-c-0.12.x: Fix CVE-2020-12762 - json-c through 0.14 has an integer overflow and out-of-bounds write ...\n* [Issue #613](https://github.com/json-c/json-c/issues/613) - json-c-0.10: Fix CVE-2020-12762 - json-c through 0.14 has an integer overflow and out-of-bounds write ...\n* [Issue #614](https://github.com/json-c/json-c/issues/614) - Prevent truncation on custom double formatters.\n* [Issue #615](https://github.com/json-c/json-c/issues/615) - New release with security fix\n* [Issue #616](https://github.com/json-c/json-c/issues/616) - Parsing fails if UTF-16 low surrogate pair is not in same chunk is the high pair\n* [Issue #617](https://github.com/json-c/json-c/issues/617) - Add an option to disable the use of thread-local storage.\n* [Issue #618](https://github.com/json-c/json-c/issues/618) - test_deep_copy: Fix assertion value.\n* [Issue #619](https://github.com/json-c/json-c/issues/619) - CMake: Fix out-of-tree build for Doxygen documentation.\n* [Issue #621](https://github.com/json-c/json-c/issues/621) - json-c and jansson libraries have symbol conflicts\n* [Issue #622](https://github.com/json-c/json-c/issues/622) - doc: Move Doxyfile into doc subdir.\n* [Issue #623](https://github.com/json-c/json-c/issues/623) - json_tokener_parse : Segmentation fault\n* [Issue #626](https://github.com/json-c/json-c/issues/626) - Fixes for cmake 2.8.12 + link issue on AIX 6.1/cc 11.01\n* [Issue #627](https://github.com/json-c/json-c/issues/627) - Compat fixes\n* [Issue #628](https://github.com/json-c/json-c/issues/628) - get_cryptgenrandom_seed: compat with old windows + fallback\n* [Issue #629](https://github.com/json-c/json-c/issues/629) - [0.12] Remove the Visual Studio project file\n* [Issue #630](https://github.com/json-c/json-c/issues/630) - Linking with Windows MINGW not working\n* [Issue #632](https://github.com/json-c/json-c/issues/632) - Json object split\n* [Issue #633](https://github.com/json-c/json-c/issues/633) - fix issue 616: support the surrogate pair in split file.\n* [Issue #634](https://github.com/json-c/json-c/issues/634) - Issue #508: `-fPIC` to link libjson-c.a with libs\n* [Issue #635](https://github.com/json-c/json-c/issues/635) - expression has no effect warning in json_tokener.c\n* [Issue #636](https://github.com/json-c/json-c/issues/636) - json_object_get_string free str memory\n* [Issue #637](https://github.com/json-c/json-c/issues/637) - json_object_put()  has 'double free or corruption (out) '\n* [Issue #638](https://github.com/json-c/json-c/issues/638) - json-c/json_object.c:50:2: error: #error Unable to determine size of ssize_t\n* [Issue #639](https://github.com/json-c/json-c/issues/639) - build: Add a symbol version to all exported symbols\n* [Issue #640](https://github.com/json-c/json-c/issues/640) - Fix build issues with SSIZE_MAX on 64bit Linux\n* [Issue #641](https://github.com/json-c/json-c/issues/641) - Formal verification of your test suite\n* [Issue #642](https://github.com/json-c/json-c/issues/642) - Please provide more precise informations about when to call json_object_put\n* [Issue #643](https://github.com/json-c/json-c/issues/643) - not able to compare with string\n* [Issue #644](https://github.com/json-c/json-c/issues/644) - Why src->_userdata not checked before calling strdup?\n* [Issue #645](https://github.com/json-c/json-c/issues/645) - Misuse of tolower() in json_tokener.c\n* [Issue #646](https://github.com/json-c/json-c/issues/646) - Cast to unsigned char instead of int when calling tolower (Fixes #645)\n\n"
        },
        {
          "name": "issues_closed_for_0.16.md",
          "type": "blob",
          "size": 10.0859375,
          "content": "This list was created with:\n\n```\nPREV=2020-07-23\nNOW=2022-04-13\ncurl \"https://api.github.com/search/issues?q=repo%3Ajson-c%2Fjson-c+closed%3A>${PREV}+created%3A<${NOW}&sort=created&order=asc&per_page=100&page=1\" > issues1.out\njq -r '.items[] | \"[\" + .title + \"](\" + .url + \")\" | tostring' issues?.out > issues.md\nsed -e's,^\\[ *\\(.*\\)\\](https://api.github.com/.*/\\([0-9].*\\)),* [Issue #\\2](https://github.com/json-c/json-c/issues/\\2) - \\1,' -i issues.md\ncat issues.md >> issues_closed_for_0.16.md\n```\n\n* [Issue #464](https://github.com/json-c/json-c/issues/464) - Speed up parsing and object creation\n* [Issue #540](https://github.com/json-c/json-c/issues/540) - request: json_init_library\n* [Issue #631](https://github.com/json-c/json-c/issues/631) - New 0.14 release requests\n* [Issue #647](https://github.com/json-c/json-c/issues/647) - \"cmake -DCMAKE_BUILD_TYPE=Release\" fails with error: 'cint64' may be used uninitialized\n* [Issue #648](https://github.com/json-c/json-c/issues/648) - Fix \"may be used uninitialized\" Release build failure\n* [Issue #649](https://github.com/json-c/json-c/issues/649) - json-c tag 0.15 tarball contains a file doc/Doxyfile and generated doxygen files in doc/html\n* [Issue #650](https://github.com/json-c/json-c/issues/650) - README: fix spelling errors\n* [Issue #651](https://github.com/json-c/json-c/issues/651) - Getrandom\n* [Issue #652](https://github.com/json-c/json-c/issues/652) - Waste memory\n* [Issue #653](https://github.com/json-c/json-c/issues/653) - Make the documentation build reproducibly\n* [Issue #654](https://github.com/json-c/json-c/issues/654) - A stack-buffer-overflow in json_parse.c:89:44\n* [Issue #655](https://github.com/json-c/json-c/issues/655) - json_parse: Fix read past end of buffer\n* [Issue #656](https://github.com/json-c/json-c/issues/656) - Fixed warnings\n* [Issue #657](https://github.com/json-c/json-c/issues/657) - Use GRND_NONBLOCK with getrandom.\n* [Issue #658](https://github.com/json-c/json-c/issues/658) - json_object_get_boolean() returns wrong result for objects and arrays\n* [Issue #659](https://github.com/json-c/json-c/issues/659) - fix json_object_get_boolean() to behave like documented\n* [Issue #660](https://github.com/json-c/json-c/issues/660) - Validate size arguments in arraylist functions.\n* [Issue #661](https://github.com/json-c/json-c/issues/661) - Cleanup of some code parts\n* [Issue #662](https://github.com/json-c/json-c/issues/662) - Prevent signed overflow in get_time_seed\n* [Issue #663](https://github.com/json-c/json-c/issues/663) - Properly format errnos in _json_c_strerror\n* [Issue #664](https://github.com/json-c/json-c/issues/664) - Limit strings at INT_MAX length\n* [Issue #665](https://github.com/json-c/json-c/issues/665) - Handle more allocation failures in json_tokener* functions\n* [Issue #666](https://github.com/json-c/json-c/issues/666) - test1 json_object_new_array_ext test is failing\n* [Issue #667](https://github.com/json-c/json-c/issues/667) - Fixed test1 regression.\n* [Issue #670](https://github.com/json-c/json-c/issues/670) - Created Stone-Paper-Scissor Game by C language\n* [Issue #672](https://github.com/json-c/json-c/issues/672) - Calling exit() after failure to generate random seed\n* [Issue #673](https://github.com/json-c/json-c/issues/673) - switchcasemenuproject\n* [Issue #674](https://github.com/json-c/json-c/issues/674) - random_seed: on error, continue to next method\n* [Issue #682](https://github.com/json-c/json-c/issues/682) - libjson-c-dev vs libjson-c3\n* [Issue #683](https://github.com/json-c/json-c/issues/683) - [Question] Is it possible to clear a ptr of json_object?\n* [Issue #684](https://github.com/json-c/json-c/issues/684) - json_tokener_parse_verbose failed with core dump\n* [Issue #685](https://github.com/json-c/json-c/issues/685) - json_tokener_parse memory leak?\n* [Issue #689](https://github.com/json-c/json-c/issues/689) - fix compilation with clang\n* [Issue #690](https://github.com/json-c/json-c/issues/690) - \"1,\" produces an object with int 1; \"1\" produces a null object\n* [Issue #691](https://github.com/json-c/json-c/issues/691) - failed tests\n* [Issue #692](https://github.com/json-c/json-c/issues/692) - patch to add arc4random\n* [Issue #693](https://github.com/json-c/json-c/issues/693) - Optional parameter for packing as array\n* [Issue #694](https://github.com/json-c/json-c/issues/694) - fix invalid unsigned arithmetic.\n* [Issue #695](https://github.com/json-c/json-c/issues/695) - /tmp/json-c/random_seed.c:327:6: error\n* [Issue #696](https://github.com/json-c/json-c/issues/696) - To avoid target exe file export JSON functions.\n* [Issue #697](https://github.com/json-c/json-c/issues/697) - json_object_get_string() return value truncated when assigning it to a pointer type in Win32 App\n* [Issue #698](https://github.com/json-c/json-c/issues/698) - Feature request: set allocator\n* [Issue #699](https://github.com/json-c/json-c/issues/699) - Linking to libjson-c Issue\n* [Issue #700](https://github.com/json-c/json-c/issues/700) - Fix unused variable for Win32 build in random_seed.c\n* [Issue #701](https://github.com/json-c/json-c/issues/701) - [RFC] json_pointer: allow the feature to be disabled\n* [Issue #703](https://github.com/json-c/json-c/issues/703) - Fix vasprintf fallback\n* [Issue #706](https://github.com/json-c/json-c/issues/706) - Check __STDC_VERSION__ is defined before checking its value\n* [Issue #707](https://github.com/json-c/json-c/issues/707) - How to build json-c-0.15 for arm arch\n* [Issue #708](https://github.com/json-c/json-c/issues/708) - direct access to elements\n* [Issue #709](https://github.com/json-c/json-c/issues/709) - Include guards not namespaced / build errors for debug.h with openNDS\n* [Issue #710](https://github.com/json-c/json-c/issues/710) - 'file system sandbox blocked mmap()' error on iOS\n* [Issue #711](https://github.com/json-c/json-c/issues/711) - creating a json object \n* [Issue #712](https://github.com/json-c/json-c/issues/712) - building json-c using cmake for ESP32\n* [Issue #713](https://github.com/json-c/json-c/issues/713) - When value converted to char* can not compare it with another value\n* [Issue #714](https://github.com/json-c/json-c/issues/714) - Add AfterCaseLabel to .clang-format\n* [Issue #716](https://github.com/json-c/json-c/issues/716) - Fixed cmake command\n* [Issue #717](https://github.com/json-c/json-c/issues/717) - Cmake is able delete all files by \"clean\" target\n* [Issue #718](https://github.com/json-c/json-c/issues/718) - CMake create uninstall target if unix generator is used\n* [Issue #719](https://github.com/json-c/json-c/issues/719) - Parsing multiple JSON strings\n* [Issue #722](https://github.com/json-c/json-c/issues/722) - Fix use-after-free in json_tokener_new_ex()\n* [Issue #723](https://github.com/json-c/json-c/issues/723) - if set __stdcall (/Gz)\n* [Issue #724](https://github.com/json-c/json-c/issues/724) - #723\n* [Issue #725](https://github.com/json-c/json-c/issues/725) - json_object_from_file()  execution segment error\n* [Issue #726](https://github.com/json-c/json-c/issues/726) - fix cmake version for tests\n* [Issue #727](https://github.com/json-c/json-c/issues/727) - Really use prefix JSON_C_OBJECT_ADD_\n* [Issue #728](https://github.com/json-c/json-c/issues/728) - DRAFT PROPOSAL - Add option JSON_C_OBJECT_ADD_IF_NOT_NULL\n* [Issue #729](https://github.com/json-c/json-c/issues/729) - * don't assume includedir\n* [Issue #731](https://github.com/json-c/json-c/issues/731) - Json-c Error\n* [Issue #732](https://github.com/json-c/json-c/issues/732) - Fix/static include dirs\n* [Issue #734](https://github.com/json-c/json-c/issues/734) - Newer appveyor config for VS2022 etc...\n* [Issue #735](https://github.com/json-c/json-c/issues/735) - Add policy_max to minimum required cmake version\n* [Issue #736](https://github.com/json-c/json-c/issues/736) - json_object.c:308: json_object_put: Assertion `jso->_ref_count > 0' failed\n* [Issue #737](https://github.com/json-c/json-c/issues/737) - Fix typo in README\n* [Issue #738](https://github.com/json-c/json-c/issues/738) - General question - Is there an SLA for handling newly detected security issues?\n* [Issue #739](https://github.com/json-c/json-c/issues/739) - json_escape_str(): avoid harmless unsigned integer overflow\n* [Issue #741](https://github.com/json-c/json-c/issues/741) - json_type_to_name(): use correct printf() formatter\n* [Issue #742](https://github.com/json-c/json-c/issues/742) - json_object_copy_serializer_data(): add assertion\n* [Issue #743](https://github.com/json-c/json-c/issues/743) - Cmd adb root\n* [Issue #744](https://github.com/json-c/json-c/issues/744) - Close file on error path.\n* [Issue #745](https://github.com/json-c/json-c/issues/745) - vasprintf(): avoid out of memory accesses\n* [Issue #746](https://github.com/json-c/json-c/issues/746) - Fix typos in code comments and ChangeLog\n* [Issue #747](https://github.com/json-c/json-c/issues/747) - json_object_put: Assertion `jso->_ref_count > 0' failed\n* [Issue #748](https://github.com/json-c/json-c/issues/748) - sprintbuf(): test for all vsnprintf error values\n* [Issue #749](https://github.com/json-c/json-c/issues/749) - sprintbuf(): handle printbuf_memappend errors\n* [Issue #750](https://github.com/json-c/json-c/issues/750) - printbuf_memset(): set gaps to zero\n* [Issue #751](https://github.com/json-c/json-c/issues/751) - printbuf: do not allow invalid arguments\n* [Issue #752](https://github.com/json-c/json-c/issues/752) - Fix typos\n* [Issue #753](https://github.com/json-c/json-c/issues/753) - CTest failed in MSVC build\n* [Issue #754](https://github.com/json-c/json-c/issues/754) - Minor improvements to documentation\n* [Issue #755](https://github.com/json-c/json-c/issues/755) - Fix error messages\n* [Issue #758](https://github.com/json-c/json-c/issues/758) - Preserve context if out of memory\n* [Issue #760](https://github.com/json-c/json-c/issues/760) - Code style: removed unneeded double-quotes\n* [Issue #761](https://github.com/json-c/json-c/issues/761) - Last commit merged to master breaks compilation\n* [Issue #762](https://github.com/json-c/json-c/issues/762) - how to merge two jsons by json-c\n* [Issue #763](https://github.com/json-c/json-c/issues/763) - Question: sort_fn arguments\n* [Issue #764](https://github.com/json-c/json-c/issues/764) - Make test fail on test case test_util_file\n"
        },
        {
          "name": "issues_closed_for_0.17.md",
          "type": "blob",
          "size": 8.9677734375,
          "content": "This list was created with:\n\n```\nPREV=2022-04-13\nNOW=2023-08-12\ncurl \"https://api.github.com/search/issues?q=repo%3Ajson-c%2Fjson-c+closed%3A>${PREV}+created%3A<${NOW}&sort=created&order=asc&per_page=100&page=1\" > issues1.out\njq -r '.items[] | \"[\" + .title + \"](\" + .url + \")\" | tostring' issues?.out > issues.md\nsed -e's,^\\[ *\\(.*\\)\\](https://api.github.com/.*/\\([0-9].*\\)),* [Issue #\\2](https://github.com/json-c/json-c/issues/\\2) - \\1,' -i issues.md\ncat issues.md >> issues_closed_for_0.17.md\n```\n\n* [Issue #191](https://github.com/json-c/json-c/issues/191) - Override int64 to only display uint64 strings\n* [Issue #537](https://github.com/json-c/json-c/issues/537) - Replace '\\0' only when parsing key, not change data in value.\n* [Issue #570](https://github.com/json-c/json-c/issues/570) - Figure out what needs to be done with Android.configure.mk\n* [Issue #587](https://github.com/json-c/json-c/issues/587) - Store the hashValue to avoid repeating the hash calculation during the hash resize.\n* [Issue #612](https://github.com/json-c/json-c/issues/612) - json-c-0.11: Fix CVE-2020-12762 - json-c through 0.14 has an integer overflow and out-of-bounds write ...\n* [Issue #620](https://github.com/json-c/json-c/issues/620) - Introduce json_object_new_string_{ext,noalloc}().\n* [Issue #624](https://github.com/json-c/json-c/issues/624) - json-c-0.14: Detect broken RDRAND during initialization.\n* [Issue #625](https://github.com/json-c/json-c/issues/625) - json-c-0.13.x: Detect broken RDRAND during initialization.\n* [Issue #668](https://github.com/json-c/json-c/issues/668) - Memory usage regression due to newlocal() on older FreeBSD releases\n* [Issue #676](https://github.com/json-c/json-c/issues/676) - dereferencing type-punned pointer might break strict-aliasing rules [-Werror=strict-aliasing]\n* [Issue #677](https://github.com/json-c/json-c/issues/677) - Naming conflict when using both json-c and jansson\n* [Issue #679](https://github.com/json-c/json-c/issues/679) - Let json-c be used with obsolete compilers\n* [Issue #681](https://github.com/json-c/json-c/issues/681) - json_tokener_parse_ex: `null` (4 bytes) only parses as valid JSON when passed with null terminator (5 bytes). Documentation issue?\n* [Issue #686](https://github.com/json-c/json-c/issues/686) - Remove dependency on libM::getrandom\n* [Issue #687](https://github.com/json-c/json-c/issues/687) - Does not build on Apple Silicon M1\n* [Issue #688](https://github.com/json-c/json-c/issues/688) - json-c-0.15-nodoc.tar.gz build fails\n* [Issue #702](https://github.com/json-c/json-c/issues/702) - json_patch: add first implementation only with patch application\n* [Issue #704](https://github.com/json-c/json-c/issues/704) - add json_object_array_insert_idx() + test-cases + fix json_pointer doc-strings\n* [Issue #705](https://github.com/json-c/json-c/issues/705) - segmentation fault on json-c parsing methods in cross compiled target\n* [Issue #721](https://github.com/json-c/json-c/issues/721) - cmake test fails with building json-c with icc\n* [Issue #730](https://github.com/json-c/json-c/issues/730) - Need a comparison with other JSON libraries in C\n* [Issue #733](https://github.com/json-c/json-c/issues/733) - Official release? 1.0?\n* [Issue #756](https://github.com/json-c/json-c/issues/756) - Question: Is there any way to build this with Gnu Make?\n* [Issue #757](https://github.com/json-c/json-c/issues/757) - json_object_from_fd_ex: fail if file is too large\n* [Issue #759](https://github.com/json-c/json-c/issues/759) - json_tokener_parse_ex: handle out of memory errors\n* [Issue #766](https://github.com/json-c/json-c/issues/766) - Some people have trouble with undefined references to arc4random \n* [Issue #767](https://github.com/json-c/json-c/issues/767) - How to create a character array using json-c\n* [Issue #768](https://github.com/json-c/json-c/issues/768) - commits from May 30, 2022 killed my docker build process\n* [Issue #769](https://github.com/json-c/json-c/issues/769) - Issue #768\n* [Issue #770](https://github.com/json-c/json-c/issues/770) - json_parse.c:170:13: error: this statement may fall through\n* [Issue #771](https://github.com/json-c/json-c/issues/771) - fix fallthough warning\n* [Issue #772](https://github.com/json-c/json-c/issues/772) - add JSON_C_TO_STRING_COLOR option\n* [Issue #773](https://github.com/json-c/json-c/issues/773) - problem with u_int64_t\n* [Issue #774](https://github.com/json-c/json-c/issues/774) - The function add_compile_options was added to CMake version 2.8.12 and later but your minimum is 2.8 which will not work\n* [Issue #775](https://github.com/json-c/json-c/issues/775) - list(TRANSFORM ...) is not available prior to CMake 3.12.\n* [Issue #776](https://github.com/json-c/json-c/issues/776) - Fix typo\n* [Issue #777](https://github.com/json-c/json-c/issues/777) - Don't try to change locale when libc only supports the C locale\n* [Issue #778](https://github.com/json-c/json-c/issues/778) - Do not insert newlines when converting empty arrays to json string and JSON_C_TO_STRING_PRETTY is used\n* [Issue #779](https://github.com/json-c/json-c/issues/779) - Fix compiling for Android\n* [Issue #780](https://github.com/json-c/json-c/issues/780) - Memory Leak when setting empty strings when c_string.pdata is used\n* [Issue #781](https://github.com/json-c/json-c/issues/781) - Fix memory leak with emtpy strings in json_object_set_string\n* [Issue #782](https://github.com/json-c/json-c/issues/782) - Fix typos found by codespell\n* [Issue #783](https://github.com/json-c/json-c/issues/783) - Fix build with clang-15+\n* [Issue #784](https://github.com/json-c/json-c/issues/784) - get_time_seed(): silence warning emitted by Coverity Scan static analyzer\n* [Issue #786](https://github.com/json-c/json-c/issues/786) - ghpages update was not published for json-c-0.16\n* [Issue #787](https://github.com/json-c/json-c/issues/787) - -static linker flag result in building failed\n* [Issue #788](https://github.com/json-c/json-c/issues/788) - Clear sensitive information.\n* [Issue #789](https://github.com/json-c/json-c/issues/789) - Unnecessary struct declaration and unsafe function usage\n* [Issue #790](https://github.com/json-c/json-c/issues/790) - Small update to README file\n* [Issue #791](https://github.com/json-c/json-c/issues/791) - json_object_object_foreach not ISO-C compliant\n* [Issue #792](https://github.com/json-c/json-c/issues/792) - ` json_object_get_int` does not set `EINVAL` on invalid string\n* [Issue #794](https://github.com/json-c/json-c/issues/794) - replaced\n* [Issue #796](https://github.com/json-c/json-c/issues/796) - Added Test for get int functions\n* [Issue #797](https://github.com/json-c/json-c/issues/797) - make uninstall\n* [Issue #798](https://github.com/json-c/json-c/issues/798) - API to deal with enums is missing\n* [Issue #799](https://github.com/json-c/json-c/issues/799) - json_object_put: Assertion `jso->_ref_count > 0' failed.\n* [Issue #800](https://github.com/json-c/json-c/issues/800) - String converted to scientific notation\n* [Issue #801](https://github.com/json-c/json-c/issues/801) - #error You do not have strncasecmp on your system.\n* [Issue #802](https://github.com/json-c/json-c/issues/802) - Problem: modern CMake warns about version 2.8\n* [Issue #803](https://github.com/json-c/json-c/issues/803) - Problem: confusing error message in snprintf_compat.h\n* [Issue #804](https://github.com/json-c/json-c/issues/804) - Problem: cmake 3.25.1 warns about CMP0042 not being set\n* [Issue #806](https://github.com/json-c/json-c/issues/806) - The problem is libjson-c.dylib incompatible with OS version\n* [Issue #807](https://github.com/json-c/json-c/issues/807) - json simple parse syntax\n* [Issue #808](https://github.com/json-c/json-c/issues/808) - iOS Build using cmake fails due to 64 to 32bits conversion precision loss\n* [Issue #809](https://github.com/json-c/json-c/issues/809) - Feature request json_object_new_uint() \n* [Issue #810](https://github.com/json-c/json-c/issues/810) - docs: update to Internet Standard reference\n* [Issue #811](https://github.com/json-c/json-c/issues/811) - dependence on execution character set\n* [Issue #812](https://github.com/json-c/json-c/issues/812) - Duplicate symbol when compiling with clang-cl\n* [Issue #813](https://github.com/json-c/json-c/issues/813) - Build apps only in project itself.\n* [Issue #814](https://github.com/json-c/json-c/issues/814) - Code execution order\n* [Issue #816](https://github.com/json-c/json-c/issues/816) - Hi I need to generate libjson-c.so.3 and libjson-c.so.3.0.1, please help with steps\n* [Issue #818](https://github.com/json-c/json-c/issues/818) - error: a function declaration without a prototype is deprecated in all versions of C\n* [Issue #819](https://github.com/json-c/json-c/issues/819) - build with intel 2023 fails on vasprintf\n* [Issue #820](https://github.com/json-c/json-c/issues/820) - ISO C forbids in \n* [Issue #821](https://github.com/json-c/json-c/issues/821) - Any release planing for 0.17?\n* [Issue #822](https://github.com/json-c/json-c/issues/822) - Added option to disable app build\n* [Issue #823](https://github.com/json-c/json-c/issues/823) - Symbol not found during linking stage of libjson-c.so\n"
        },
        {
          "name": "issues_closed_for_0.18.md",
          "type": "blob",
          "size": 4.890625,
          "content": "This list was created with:\n\n```\nPREV=2023-08-12\nNOW=2024-09-15\ncurl \"https://api.github.com/search/issues?q=repo%3Ajson-c%2Fjson-c+closed%3A>${PREV}+created%3A<${NOW}&sort=created&order=asc&per_page=100&page=1\" > issues1.out\njq -r '.items[] | \"[\" + .title + \"](\" + .url + \")\" | tostring' issues?.out > issues.md\nsed -e's,^\\[ *\\(.*\\)\\](https://api.github.com/.*/\\([0-9].*\\)),* [Issue #\\2](https://github.com/json-c/json-c/issues/\\2) - \\1,' -i issues.md\ncat issues.md >> issues_closed_for_0.18.md\n```\n\n* [Issue #826](https://github.com/json-c/json-c/issues/826) - CMake: remove needless policy setting\n* [Issue #827](https://github.com/json-c/json-c/issues/827) - Resolve build issue in tokener_parse_ex_fuzzer.c\n* [Issue #828](https://github.com/json-c/json-c/issues/828) - Put arc4random check under DISABLE_EXTRA_LIBS=OFF in CMakeLists.txt.\n* [Issue #829](https://github.com/json-c/json-c/issues/829) - Cannot build with clang-cl\n* [Issue #830](https://github.com/json-c/json-c/issues/830) - I am looking whether this CVE - CVE-2021-32292 is impacted by json-c version v0.13.1or not ?\n* [Issue #831](https://github.com/json-c/json-c/issues/831) - rename WIN32 to _WIN32\n* [Issue #833](https://github.com/json-c/json-c/issues/833) - memory leak issue in 0.13\n* [Issue #834](https://github.com/json-c/json-c/issues/834) - fix error des of 'error_memory'\n* [Issue #835](https://github.com/json-c/json-c/issues/835) - fix error des of 'error_memory'\n* [Issue #836](https://github.com/json-c/json-c/issues/836) - Null pointer dereference in tokener_parse_ex_fuzzer.cc\n* [Issue #837](https://github.com/json-c/json-c/issues/837) - Add type checking for parsed objects in tokener_parse_ex_fuzzer\n* [Issue #838](https://github.com/json-c/json-c/issues/838) - Cannot link properly using cmake\n* [Issue #839](https://github.com/json-c/json-c/issues/839) - json_pointer.c: initialize idx\n* [Issue #840](https://github.com/json-c/json-c/issues/840) - Memory leak when enable HAVE_SETLOCALE and HAVE_USELOCALE\n* [Issue #841](https://github.com/json-c/json-c/issues/841) - Random crash in json_tokener_parse\n* [Issue #842](https://github.com/json-c/json-c/issues/842) - Assignment bug in json_pointer.c\n* [Issue #843](https://github.com/json-c/json-c/issues/843) - _WIN32 should be used, not WIN32 in source code ifdefs.\n* [Issue #844](https://github.com/json-c/json-c/issues/844) - Doxygen: mis-wording in `json_object_put`\n* [Issue #845](https://github.com/json-c/json-c/issues/845) - [CMP0153](https://cmake.org/cmake/help/latest/policy/CMP0153.html)\n* [Issue #846](https://github.com/json-c/json-c/issues/846) - CMP0153\n* [Issue #848](https://github.com/json-c/json-c/issues/848) - json_object_from_file caused calloc SIGSEGV\n* [Issue #849](https://github.com/json-c/json-c/issues/849) - random_seed.c: add a Coverity Scan suppression\n* [Issue #850](https://github.com/json-c/json-c/issues/850) - Missing return description\n* [Issue #851](https://github.com/json-c/json-c/issues/851) - Allow NULL in json_object_new_string() and json_object_new_string_len()\n* [Issue #852](https://github.com/json-c/json-c/issues/852) - docs: micro typo in json_object_put doc\n* [Issue #853](https://github.com/json-c/json-c/issues/853) - json_tokener_parse_verbose does not set the error indicator when it fails to allocate the tokener\n* [Issue #854](https://github.com/json-c/json-c/issues/854) - json_tokener_parse_verbose sets the error indicator to a wrong value when there is a memory allocation failure\n* [Issue #856](https://github.com/json-c/json-c/issues/856) - Using libjson-c.so or compiling from source seg faults on json_tokener_parse_ex in alpine docker container\n* [Issue #857](https://github.com/json-c/json-c/issues/857) - json_tokener_parse_verbose sets the error indicator to a wrong value when there is a memory allocation failure\n* [Issue #858](https://github.com/json-c/json-c/issues/858) - json_tokener.h: json_tokener_parse_verbose: fix typo\n* [Issue #859](https://github.com/json-c/json-c/issues/859) - Develop\n* [Issue #860](https://github.com/json-c/json-c/issues/860) - Develop\n* [Issue #861](https://github.com/json-c/json-c/issues/861) - Handle yet another out-of-memory condition.\n* [Issue #862](https://github.com/json-c/json-c/issues/862) - Missing `json-c-targets.cmake` during build cmake build step\n* [Issue #863](https://github.com/json-c/json-c/issues/863) - build ios simulator error\n* [Issue #864](https://github.com/json-c/json-c/issues/864) - Build pkg-config for msvc as well\n* [Issue #865](https://github.com/json-c/json-c/issues/865) - Assertion usage\n* [Issue #866](https://github.com/json-c/json-c/issues/866) - Added github actions\n* [Issue #868](https://github.com/json-c/json-c/issues/868) - I meet compile error in harmony  \n* [Issue #869](https://github.com/json-c/json-c/issues/869) - At a high level how are jsons parses? Are they terminated by the new line?\n* [Issue #870](https://github.com/json-c/json-c/issues/870) - Non-Compliant features should be optional (and disabled)\n"
        },
        {
          "name": "json-c.pc.in",
          "type": "blob",
          "size": 0.25390625,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nincludedir=@includedir@\n\nName: json-c\nDescription: A JSON implementation in C\nVersion: @VERSION@\nRequires:\nLibs.private: @LIBS@\nLibs: -L${libdir} -ljson-c\nCflags: -I${includedir} -I${includedir}/json-c\n"
        },
        {
          "name": "json-c.sym",
          "type": "blob",
          "size": 4.23828125,
          "content": "\n/*\n * Symbol versioning for libjson-c.\n * All exported symbols must be listed here.\n *\n * See \n *   https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf\n */\n\n/*\n * Symbols in JSONC_PRIVATE are exported for historical\n * reasons, but should not be used outside of json-c.\n */\nJSONC_PRIVATE {\n    array_list_add;\n    array_list_del_idx;\n    array_list_free;\n    array_list_new;\n    array_list_put_idx;\n    array_list_sort;\n    json_hex_chars;\n    json_parse_double;\n    json_parse_int64;\n    json_parse_uint64;\n    lh_table_delete;\n    lh_table_delete_entry;\n    lh_table_free;\n    lh_table_insert;\n    lh_table_insert_w_hash;\n    lh_table_new;\n    lh_table_resize;\n    mc_debug;\n    mc_error;\n    mc_get_debug;\n    mc_info;\n    mc_set_debug;\n    mc_set_syslog;\n    printbuf_free;\n    printbuf_memappend;\n    printbuf_memset;\n    printbuf_new;\n    printbuf_reset;\n    sprintbuf;\n    # Used by tests:\n    _json_c_strerror;\n};\n\nJSONC_0.14 {\n  global:\n    array_list_bsearch;\n    array_list_get_idx;\n    array_list_length;\n    json_c_get_random_seed;\n    json_c_object_sizeof;\n    json_c_set_serialization_double_format;\n    json_c_shallow_copy_default;\n    json_c_version;\n    json_c_version_num;\n    json_c_visit;\n    json_global_set_string_hash;\n    json_number_chars;\n    json_object_array_add;\n    json_object_array_bsearch;\n    json_object_array_del_idx;\n    json_object_array_get_idx;\n    json_object_array_length;\n    json_object_array_put_idx;\n    json_object_array_sort;\n    json_object_deep_copy;\n    json_object_double_to_json_string;\n    json_object_equal;\n    json_object_free_userdata;\n    json_object_from_fd;\n    json_object_from_fd_ex;\n    json_object_from_file;\n    json_object_get;\n    json_object_get_array;\n    json_object_get_boolean;\n    json_object_get_double;\n    json_object_get_int64;\n    json_object_get_int;\n    json_object_get_object;\n    json_object_get_string;\n    json_object_get_string_len;\n    json_object_get_type;\n    json_object_get_uint64;\n    json_object_get_userdata;\n    json_object_int_inc;\n    json_object_is_type;\n    json_object_iter_begin;\n    json_object_iter_end;\n    json_object_iter_equal;\n    json_object_iter_init_default;\n    json_object_iter_next;\n    json_object_iter_peek_name;\n    json_object_iter_peek_value;\n    json_object_new_array;\n    json_object_new_boolean;\n    json_object_new_double;\n    json_object_new_double_s;\n    json_object_new_int64;\n    json_object_new_int;\n    json_object_new_null;\n    json_object_new_object;\n    json_object_new_string;\n    json_object_new_string_len;\n    json_object_new_uint64;\n    json_object_object_add;\n    json_object_object_add_ex;\n    json_object_object_del;\n    json_object_object_get;\n    json_object_object_get_ex;\n    json_object_object_length;\n    json_object_put;\n    json_object_set_boolean;\n    json_object_set_double;\n    json_object_set_int64;\n    json_object_set_int;\n    json_object_set_serializer;\n    json_object_set_string;\n    json_object_set_string_len;\n    json_object_set_uint64;\n    json_object_set_userdata;\n    json_object_to_fd;\n    json_object_to_file;\n    json_object_to_file_ext;\n    json_object_to_json_string;\n    json_object_to_json_string_ext;\n    json_object_to_json_string_length;\n    json_object_userdata_to_json_string;\n    json_pointer_get;\n    json_pointer_getf;\n    json_pointer_set;\n    json_pointer_setf;\n    json_tokener_error_desc;\n    json_tokener_free;\n    json_tokener_get_error;\n    json_tokener_get_parse_end;\n    json_tokener_new;\n    json_tokener_new_ex;\n    json_tokener_parse;\n    json_tokener_parse_ex;\n    json_tokener_parse_verbose;\n    json_tokener_reset;\n    json_tokener_set_flags;\n    json_type_to_name;\n    json_util_get_last_err;\n    lh_char_equal;\n    lh_kchar_table_new;\n    lh_kptr_table_new;\n    lh_ptr_equal;\n    lh_table_length;\n    lh_table_lookup_entry;\n    lh_table_lookup_entry_w_hash;\n    lh_table_lookup_ex;\n\n  local:\n    *;\n};\n\nJSONC_0.15 {\n  global:\n    array_list_new2;\n    array_list_shrink;\n    json_object_array_shrink;\n    json_object_new_array_ext;\n} JSONC_0.14;\n\nJSONC_0.16 {\n# No new symbols in 0.16\n} JSONC_0.15;\n\nJSONC_0.17 {\n  global:\n    json_object_array_insert_idx;\n    json_patch_apply;\n#    array_list_insert_idx is intentionally not exported\n} JSONC_0.16;\n\nJSONC_0.18 {\n#  global:\n} JSONC_0.17;\n\nJSONC_0.19 {\n#  global:\n} JSONC_0.18;\n"
        },
        {
          "name": "json.h.cmakein",
          "type": "blob",
          "size": 0.806640625,
          "content": "/*\n * $Id: json.h,v 1.6 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n * Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief A convenience header that may be included instead of other individual ones.\n */\n#ifndef _json_h_\n#define _json_h_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"arraylist.h\"\n#include \"debug.h\"\n#include \"json_c_version.h\"\n#include \"json_object.h\"\n#include \"json_object_iterator.h\"\n@JSON_H_JSON_PATCH@\n@JSON_H_JSON_POINTER@\n#include \"json_tokener.h\"\n#include \"json_util.h\"\n#include \"linkhash.h\"\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_c_version.c",
          "type": "blob",
          "size": 0.3544921875,
          "content": "/*\n * Copyright (c) 2012 Eric Haszlakiewicz\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n */\n#include \"config.h\"\n\n#include \"json_c_version.h\"\n\nconst char *json_c_version(void)\n{\n\treturn JSON_C_VERSION;\n}\n\nint json_c_version_num(void)\n{\n\treturn JSON_C_VERSION_NUM;\n}\n"
        },
        {
          "name": "json_c_version.h",
          "type": "blob",
          "size": 1.33984375,
          "content": "/*\n * Copyright (c) 2012,2017 Eric Haszlakiewicz\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n */\n\n/**\n * @file\n * @brief Methods for retrieving the json-c version.\n */\n#ifndef _json_c_version_h_\n#define _json_c_version_h_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define JSON_C_MAJOR_VERSION 0\n#define JSON_C_MINOR_VERSION 18\n#define JSON_C_MICRO_VERSION 99\n#define JSON_C_VERSION_NUM \\\n\t((JSON_C_MAJOR_VERSION << 16) | (JSON_C_MINOR_VERSION << 8) | JSON_C_MICRO_VERSION)\n#define JSON_C_VERSION \"0.18.99\"\n\n#ifndef JSON_EXPORT\n#if defined(_MSC_VER) && defined(JSON_C_DLL)\n#define JSON_EXPORT __declspec(dllexport)\n#else\n#define JSON_EXPORT extern\n#endif\n#endif\n\n/**\n * @see JSON_C_VERSION\n * @return the version of the json-c library as a string\n */\nJSON_EXPORT const char *json_c_version(void); /* Returns JSON_C_VERSION */\n\n/**\n * The json-c version encoded into an int, with the low order 8 bits\n * being the micro version, the next higher 8 bits being the minor version\n * and the next higher 8 bits being the major version.\n * For example, 7.12.99 would be 0x00070B63.\n *\n * @see JSON_C_VERSION_NUM\n * @return the version of the json-c library as an int\n */\nJSON_EXPORT int json_c_version_num(void); /* Returns JSON_C_VERSION_NUM */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_config.h.in",
          "type": "blob",
          "size": 0.0888671875,
          "content": "\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef JSON_C_HAVE_INTTYPES_H\n"
        },
        {
          "name": "json_config.h.win32",
          "type": "blob",
          "size": 0.1396484375,
          "content": "\n/* Define to 1 if you have the <inttypes.h> header file. */\n#if defined(_MSC_VER) && _MSC_VER >= 1800\n#define JSON_C_HAVE_INTTYPES_H 1\n#endif\n"
        },
        {
          "name": "json_inttypes.h",
          "type": "blob",
          "size": 0.6591796875,
          "content": "\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n#ifndef _json_inttypes_h_\n#define _json_inttypes_h_\n\n#include \"json_config.h\"\n\n#ifdef JSON_C_HAVE_INTTYPES_H\n/* inttypes.h includes stdint.h */\n#include <inttypes.h>\n\n#else\n#ifdef JSON_C_HAVE_STDINT_H\n#include <stdint.h>\n#else\n/* Really only valid for old MS compilers, VS2008 and earlier: */\ntypedef __int32 int32_t;\ntypedef unsigned __int32 uint32_t;\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#endif\n\n#define PRId64 \"I64d\"\n#define SCNd64 \"I64d\"\n#define PRIu64 \"I64u\"\n\n#endif\n\n#if defined(_MSC_VER)\n#include <BaseTsd.h>\ntypedef SSIZE_T ssize_t;\n#endif\n\n#endif\n"
        },
        {
          "name": "json_object.c",
          "type": "blob",
          "size": 49.1748046875,
          "content": "/*\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n * Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"config.h\"\n\n#include \"strerror_override.h\"\n\n#include <assert.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#include <math.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"arraylist.h\"\n#include \"debug.h\"\n#include \"json_inttypes.h\"\n#include \"json_object.h\"\n#include \"json_object_private.h\"\n#include \"json_util.h\"\n#include \"linkhash.h\"\n#include \"math_compat.h\"\n#include \"printbuf.h\"\n#include \"snprintf_compat.h\"\n#include \"strdup_compat.h\"\n\n/* Avoid ctype.h and locale overhead */\n#define is_plain_digit(c) ((c) >= '0' && (c) <= '9')\n\n#if SIZEOF_LONG_LONG != SIZEOF_INT64_T\n#error The long long type is not 64-bits\n#endif\n\n#ifndef SSIZE_T_MAX\n#if SIZEOF_SSIZE_T == SIZEOF_INT\n#define SSIZE_T_MAX INT_MAX\n#elif SIZEOF_SSIZE_T == SIZEOF_LONG\n#define SSIZE_T_MAX LONG_MAX\n#elif SIZEOF_SSIZE_T == SIZEOF_LONG_LONG\n#define SSIZE_T_MAX LLONG_MAX\n#else\n#error Unable to determine size of ssize_t\n#endif\n#endif\n\nconst char *json_number_chars = \"0123456789.+-eE\"; /* Unused, but part of public API, drop for 1.0 */\nconst char *json_hex_chars = \"0123456789abcdefABCDEF\";\n\nstatic void json_object_generic_delete(struct json_object *jso);\n\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\n/* VS2013 doesn't know about \"inline\" */\n#define inline __inline\n#elif defined(AIX_CC)\n#define inline\n#endif\n\n/* define colors */\n#define ANSI_COLOR_RESET \"\\033[0m\"\n#define ANSI_COLOR_FG_GREEN \"\\033[0;32m\"\n#define ANSI_COLOR_FG_BLUE \"\\033[0;34m\"\n#define ANSI_COLOR_FG_MAGENTA \"\\033[0;35m\"\n\n/*\n * Helper functions to more safely cast to a particular type of json_object\n */\nstatic inline struct json_object_object *JC_OBJECT(struct json_object *jso)\n{\n\treturn (void *)jso;\n}\nstatic inline const struct json_object_object *JC_OBJECT_C(const struct json_object *jso)\n{\n\treturn (const void *)jso;\n}\nstatic inline struct json_object_array *JC_ARRAY(struct json_object *jso)\n{\n\treturn (void *)jso;\n}\nstatic inline const struct json_object_array *JC_ARRAY_C(const struct json_object *jso)\n{\n\treturn (const void *)jso;\n}\nstatic inline struct json_object_boolean *JC_BOOL(struct json_object *jso)\n{\n\treturn (void *)jso;\n}\nstatic inline const struct json_object_boolean *JC_BOOL_C(const struct json_object *jso)\n{\n\treturn (const void *)jso;\n}\nstatic inline struct json_object_double *JC_DOUBLE(struct json_object *jso)\n{\n\treturn (void *)jso;\n}\nstatic inline const struct json_object_double *JC_DOUBLE_C(const struct json_object *jso)\n{\n\treturn (const void *)jso;\n}\nstatic inline struct json_object_int *JC_INT(struct json_object *jso)\n{\n\treturn (void *)jso;\n}\nstatic inline const struct json_object_int *JC_INT_C(const struct json_object *jso)\n{\n\treturn (const void *)jso;\n}\nstatic inline struct json_object_string *JC_STRING(struct json_object *jso)\n{\n\treturn (void *)jso;\n}\nstatic inline const struct json_object_string *JC_STRING_C(const struct json_object *jso)\n{\n\treturn (const void *)jso;\n}\n\n#define JC_CONCAT(a, b) a##b\n#define JC_CONCAT3(a, b, c) a##b##c\n\n#define JSON_OBJECT_NEW(jtype)                                                           \\\n\t(struct JC_CONCAT(json_object_, jtype) *)json_object_new(                        \\\n\t    JC_CONCAT(json_type_, jtype), sizeof(struct JC_CONCAT(json_object_, jtype)), \\\n\t    &JC_CONCAT3(json_object_, jtype, _to_json_string))\n\nstatic inline struct json_object *json_object_new(enum json_type o_type, size_t alloc_size,\n                                                  json_object_to_json_string_fn *to_json_string);\n\nstatic void json_object_object_delete(struct json_object *jso_base);\nstatic void json_object_string_delete(struct json_object *jso);\nstatic void json_object_array_delete(struct json_object *jso);\n\nstatic json_object_to_json_string_fn json_object_object_to_json_string;\nstatic json_object_to_json_string_fn json_object_boolean_to_json_string;\nstatic json_object_to_json_string_fn json_object_double_to_json_string_default;\nstatic json_object_to_json_string_fn json_object_int_to_json_string;\nstatic json_object_to_json_string_fn json_object_string_to_json_string;\nstatic json_object_to_json_string_fn json_object_array_to_json_string;\nstatic json_object_to_json_string_fn _json_object_userdata_to_json_string;\n\n#ifndef JSON_NORETURN\n#if defined(_MSC_VER)\n#define JSON_NORETURN __declspec(noreturn)\n#elif defined(__OS400__)\n#define JSON_NORETURN\n#else\n/* 'cold' attribute is for optimization, telling the computer this code\n * path is unlikely.\n */\n#define JSON_NORETURN __attribute__((noreturn, cold))\n#endif\n#endif\n/**\n * Abort and optionally print a message on standard error.\n * This should be used rather than assert() for unconditional abortion\n * (in particular for code paths which are never supposed to be run).\n * */\nJSON_NORETURN static void json_abort(const char *message);\n\n/* helper for accessing the optimized string data component in json_object\n */\nstatic inline char *get_string_component_mutable(struct json_object *jso)\n{\n\tif (JC_STRING_C(jso)->len < 0)\n\t{\n\t\t/* Due to json_object_set_string(), we might have a pointer */\n\t\treturn JC_STRING(jso)->c_string.pdata;\n\t}\n\treturn JC_STRING(jso)->c_string.idata;\n}\nstatic inline const char *get_string_component(const struct json_object *jso)\n{\n\treturn get_string_component_mutable((void *)(uintptr_t)(const void *)jso);\n}\n\n/* string escaping */\n\nstatic int json_escape_str(struct printbuf *pb, const char *str, size_t len, int flags)\n{\n\tsize_t pos = 0, start_offset = 0;\n\tunsigned char c;\n\twhile (len)\n\t{\n\t\t--len;\n\t\tc = str[pos];\n\t\tswitch (c)\n\t\t{\n\t\tcase '\\b':\n\t\tcase '\\n':\n\t\tcase '\\r':\n\t\tcase '\\t':\n\t\tcase '\\f':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '/':\n\t\t\tif ((flags & JSON_C_TO_STRING_NOSLASHESCAPE) && c == '/')\n\t\t\t{\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos > start_offset)\n\t\t\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\n\t\t\tif (c == '\\b')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\b\", 2);\n\t\t\telse if (c == '\\n')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\n\", 2);\n\t\t\telse if (c == '\\r')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\r\", 2);\n\t\t\telse if (c == '\\t')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\t\", 2);\n\t\t\telse if (c == '\\f')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\f\", 2);\n\t\t\telse if (c == '\"')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\\\\"\", 2);\n\t\t\telse if (c == '\\\\')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\\\\\\", 2);\n\t\t\telse if (c == '/')\n\t\t\t\tprintbuf_memappend(pb, \"\\\\/\", 2);\n\n\t\t\tstart_offset = ++pos;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (c < ' ')\n\t\t\t{\n\t\t\t\tchar sbuf[7];\n\t\t\t\tif (pos > start_offset)\n\t\t\t\t\tprintbuf_memappend(pb, str + start_offset,\n\t\t\t\t\t                   pos - start_offset);\n\t\t\t\tsnprintf(sbuf, sizeof(sbuf), \"\\\\u00%c%c\", json_hex_chars[c >> 4],\n\t\t\t\t         json_hex_chars[c & 0xf]);\n\t\t\t\tprintbuf_memappend_fast(pb, sbuf, (int)sizeof(sbuf) - 1);\n\t\t\t\tstart_offset = ++pos;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpos++;\n\t\t}\n\t}\n\tif (pos > start_offset)\n\t\tprintbuf_memappend(pb, str + start_offset, pos - start_offset);\n\treturn 0;\n}\n\n/* reference counting */\n\nstruct json_object *json_object_get(struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn jso;\n\n\t// Don't overflow the refcounter.\n\tassert(jso->_ref_count < UINT32_MAX);\n\n#if defined(HAVE_ATOMIC_BUILTINS) && defined(ENABLE_THREADING)\n\t__sync_add_and_fetch(&jso->_ref_count, 1);\n#else\n\t++jso->_ref_count;\n#endif\n\n\treturn jso;\n}\n\nint json_object_put(struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn 0;\n\n\t/* Avoid invalid free and crash explicitly instead of (silently)\n\t * segfaulting.\n\t */\n\tassert(jso->_ref_count > 0);\n\n#if defined(HAVE_ATOMIC_BUILTINS) && defined(ENABLE_THREADING)\n\t/* Note: this only allow the refcount to remain correct\n\t * when multiple threads are adjusting it.  It is still an error\n\t * for a thread to decrement the refcount if it doesn't \"own\" it,\n\t * as that can result in the thread that loses the race to 0\n\t * operating on an already-freed object.\n\t */\n\tif (__sync_sub_and_fetch(&jso->_ref_count, 1) > 0)\n\t\treturn 0;\n#else\n\tif (--jso->_ref_count > 0)\n\t\treturn 0;\n#endif\n\n\tif (jso->_user_delete)\n\t\tjso->_user_delete(jso, jso->_userdata);\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_object: json_object_object_delete(jso); break;\n\tcase json_type_array: json_object_array_delete(jso); break;\n\tcase json_type_string: json_object_string_delete(jso); break;\n\tdefault: json_object_generic_delete(jso); break;\n\t}\n\treturn 1;\n}\n\n/* generic object construction and destruction parts */\n\nstatic void json_object_generic_delete(struct json_object *jso)\n{\n\tprintbuf_free(jso->_pb);\n\tfree(jso);\n}\n\nstatic inline struct json_object *json_object_new(enum json_type o_type, size_t alloc_size,\n                                                  json_object_to_json_string_fn *to_json_string)\n{\n\tstruct json_object *jso;\n\n\tjso = (struct json_object *)malloc(alloc_size);\n\tif (!jso)\n\t\treturn NULL;\n\n\tjso->o_type = o_type;\n\tjso->_ref_count = 1;\n\tjso->_to_json_string = to_json_string;\n\tjso->_pb = NULL;\n\tjso->_user_delete = NULL;\n\tjso->_userdata = NULL;\n\t//jso->...   // Type-specific fields must be set by caller\n\n\treturn jso;\n}\n\n/* type checking functions */\n\nint json_object_is_type(const struct json_object *jso, enum json_type type)\n{\n\tif (!jso)\n\t\treturn (type == json_type_null);\n\treturn (jso->o_type == type);\n}\n\nenum json_type json_object_get_type(const struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn json_type_null;\n\treturn jso->o_type;\n}\n\nvoid *json_object_get_userdata(json_object *jso)\n{\n\treturn jso ? jso->_userdata : NULL;\n}\n\nvoid json_object_set_userdata(json_object *jso, void *userdata, json_object_delete_fn *user_delete)\n{\n\t// Can't return failure, so abort if we can't perform the operation.\n\tassert(jso != NULL);\n\n\t// First, clean up any previously existing user info\n\tif (jso->_user_delete)\n\t\tjso->_user_delete(jso, jso->_userdata);\n\n\tjso->_userdata = userdata;\n\tjso->_user_delete = user_delete;\n}\n\n/* set a custom conversion to string */\n\nvoid json_object_set_serializer(json_object *jso, json_object_to_json_string_fn *to_string_func,\n                                void *userdata, json_object_delete_fn *user_delete)\n{\n\tjson_object_set_userdata(jso, userdata, user_delete);\n\n\tif (to_string_func == NULL)\n\t{\n\t\t// Reset to the standard serialization function\n\t\tswitch (jso->o_type)\n\t\t{\n\t\tcase json_type_null: jso->_to_json_string = NULL; break;\n\t\tcase json_type_boolean:\n\t\t\tjso->_to_json_string = &json_object_boolean_to_json_string;\n\t\t\tbreak;\n\t\tcase json_type_double:\n\t\t\tjso->_to_json_string = &json_object_double_to_json_string_default;\n\t\t\tbreak;\n\t\tcase json_type_int: jso->_to_json_string = &json_object_int_to_json_string; break;\n\t\tcase json_type_object:\n\t\t\tjso->_to_json_string = &json_object_object_to_json_string;\n\t\t\tbreak;\n\t\tcase json_type_array:\n\t\t\tjso->_to_json_string = &json_object_array_to_json_string;\n\t\t\tbreak;\n\t\tcase json_type_string:\n\t\t\tjso->_to_json_string = &json_object_string_to_json_string;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tjso->_to_json_string = to_string_func;\n}\n\n/* extended conversion to string */\n\nconst char *json_object_to_json_string_length(struct json_object *jso, int flags, size_t *length)\n{\n\tconst char *r = NULL;\n\tsize_t s = 0;\n\n\tif (!jso)\n\t{\n\t\ts = 4;\n\t\tr = \"null\";\n\t}\n\telse if ((jso->_pb) || (jso->_pb = printbuf_new()))\n\t{\n\t\tprintbuf_reset(jso->_pb);\n\n\t\tif (jso->_to_json_string(jso, jso->_pb, 0, flags) >= 0)\n\t\t{\n\t\t\ts = (size_t)jso->_pb->bpos;\n\t\t\tr = jso->_pb->buf;\n\t\t}\n\t}\n\n\tif (length)\n\t\t*length = s;\n\treturn r;\n}\n\nconst char *json_object_to_json_string_ext(struct json_object *jso, int flags)\n{\n\treturn json_object_to_json_string_length(jso, flags, NULL);\n}\n\n/* backwards-compatible conversion to string */\n\nconst char *json_object_to_json_string(struct json_object *jso)\n{\n\treturn json_object_to_json_string_ext(jso, JSON_C_TO_STRING_SPACED);\n}\n\nstatic void indent(struct printbuf *pb, int level, int flags)\n{\n\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t{\n\t\tif (flags & JSON_C_TO_STRING_PRETTY_TAB)\n\t\t{\n\t\t\tprintbuf_memset(pb, -1, '\\t', level);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintbuf_memset(pb, -1, ' ', level * 2);\n\t\t}\n\t}\n}\n\n/* json_object_object */\n\nstatic int json_object_object_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                             int level, int flags)\n{\n\tint had_children = 0;\n\tstruct json_object_iter iter;\n\n\tprintbuf_strappend(pb, \"{\" /*}*/);\n\tjson_object_object_foreachC(jso, iter)\n\t{\n\t\tif (had_children)\n\t\t{\n\t\t\tprintbuf_strappend(pb, \",\");\n\t\t}\n\t\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t\t\tprintbuf_strappend(pb, \"\\n\");\n\t\thad_children = 1;\n\t\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\t\tprintbuf_strappend(pb, \" \");\n\t\tindent(pb, level + 1, flags);\n\t\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\t\tprintbuf_strappend(pb, ANSI_COLOR_FG_BLUE);\n\n\t\tprintbuf_strappend(pb, \"\\\"\");\n\t\tjson_escape_str(pb, iter.key, strlen(iter.key), flags);\n\t\tprintbuf_strappend(pb, \"\\\"\");\n\n\t\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\t\tprintbuf_strappend(pb, ANSI_COLOR_RESET);\n\n\t\tif (flags & JSON_C_TO_STRING_SPACED)\n\t\t\tprintbuf_strappend(pb, \": \");\n\t\telse\n\t\t\tprintbuf_strappend(pb, \":\");\n\n\t\tif (iter.val == NULL) {\n\t\t\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\t\t\tprintbuf_strappend(pb, ANSI_COLOR_FG_MAGENTA);\n\t\t\tprintbuf_strappend(pb, \"null\");\n\t\t\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\t\t\tprintbuf_strappend(pb, ANSI_COLOR_RESET);\n\t\t} else if (iter.val->_to_json_string(iter.val, pb, level + 1, flags) < 0)\n\t\t\treturn -1;\n\t}\n\tif ((flags & JSON_C_TO_STRING_PRETTY) && had_children)\n\t{\n\t\tprintbuf_strappend(pb, \"\\n\");\n\t\tindent(pb, level, flags);\n\t}\n\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\treturn printbuf_strappend(pb, /*{*/ \" }\");\n\telse\n\t\treturn printbuf_strappend(pb, /*{*/ \"}\");\n}\n\nstatic void json_object_lh_entry_free(struct lh_entry *ent)\n{\n\tif (!lh_entry_k_is_constant(ent))\n\t\tfree(lh_entry_k(ent));\n\tjson_object_put((struct json_object *)lh_entry_v(ent));\n}\n\nstatic void json_object_object_delete(struct json_object *jso_base)\n{\n\tlh_table_free(JC_OBJECT(jso_base)->c_object);\n\tjson_object_generic_delete(jso_base);\n}\n\nstruct json_object *json_object_new_object(void)\n{\n\tstruct json_object_object *jso = JSON_OBJECT_NEW(object);\n\tif (!jso)\n\t\treturn NULL;\n\tjso->c_object =\n\t    lh_kchar_table_new(JSON_OBJECT_DEF_HASH_ENTRIES, &json_object_lh_entry_free);\n\tif (!jso->c_object)\n\t{\n\t\tjson_object_generic_delete(&jso->base);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\treturn &jso->base;\n}\n\nstruct lh_table *json_object_get_object(const struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn NULL;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_object: return JC_OBJECT_C(jso)->c_object;\n\tdefault: return NULL;\n\t}\n}\n\nint json_object_object_add_ex(struct json_object *jso, const char *const key,\n                              struct json_object *const val, const unsigned opts)\n{\n\tstruct json_object *existing_value = NULL;\n\tstruct lh_entry *existing_entry;\n\tunsigned long hash;\n\n\tassert(json_object_get_type(jso) == json_type_object);\n\n\t// We lookup the entry and replace the value, rather than just deleting\n\t// and re-adding it, so the existing key remains valid.\n\thash = lh_get_hash(JC_OBJECT(jso)->c_object, (const void *)key);\n\texisting_entry =\n\t    (opts & JSON_C_OBJECT_ADD_KEY_IS_NEW)\n\t        ? NULL\n\t        : lh_table_lookup_entry_w_hash(JC_OBJECT(jso)->c_object, (const void *)key, hash);\n\n\t// The caller must avoid creating loops in the object tree, but do a\n\t// quick check anyway to make sure we're not creating a trivial loop.\n\tif (jso == val)\n\t\treturn -1;\n\n\tif (!existing_entry)\n\t{\n\t\tconst void *const k =\n\t\t    (opts & JSON_C_OBJECT_ADD_CONSTANT_KEY) ? (const void *)key : strdup(key);\n\t\tif (k == NULL)\n\t\t\treturn -1;\n\t\treturn lh_table_insert_w_hash(JC_OBJECT(jso)->c_object, k, val, hash, opts);\n\t}\n\texisting_value = (json_object *)lh_entry_v(existing_entry);\n\tif (existing_value)\n\t\tjson_object_put(existing_value);\n\tlh_entry_set_val(existing_entry, val);\n\treturn 0;\n}\n\nint json_object_object_add(struct json_object *jso, const char *key, struct json_object *val)\n{\n\treturn json_object_object_add_ex(jso, key, val, 0);\n}\n\nint json_object_object_length(const struct json_object *jso)\n{\n\tassert(json_object_get_type(jso) == json_type_object);\n\treturn lh_table_length(JC_OBJECT_C(jso)->c_object);\n}\n\nsize_t json_c_object_sizeof(void)\n{\n\treturn sizeof(struct json_object);\n}\n\nstruct json_object *json_object_object_get(const struct json_object *jso, const char *key)\n{\n\tstruct json_object *result = NULL;\n\tjson_object_object_get_ex(jso, key, &result);\n\treturn result;\n}\n\njson_bool json_object_object_get_ex(const struct json_object *jso, const char *key,\n                                    struct json_object **value)\n{\n\tif (value != NULL)\n\t\t*value = NULL;\n\n\tif (NULL == jso)\n\t\treturn 0;\n\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_object:\n\t\treturn lh_table_lookup_ex(JC_OBJECT_C(jso)->c_object, (const void *)key,\n\t\t                          (void **)value);\n\tdefault:\n\t\tif (value != NULL)\n\t\t\t*value = NULL;\n\t\treturn 0;\n\t}\n}\n\nvoid json_object_object_del(struct json_object *jso, const char *key)\n{\n\tassert(json_object_get_type(jso) == json_type_object);\n\tlh_table_delete(JC_OBJECT(jso)->c_object, key);\n}\n\n/* json_object_boolean */\n\nstatic int json_object_boolean_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                              int level, int flags)\n{\n\tint ret;\n\n\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\tprintbuf_strappend(pb, ANSI_COLOR_FG_MAGENTA);\n\n\tif (JC_BOOL(jso)->c_boolean)\n\t\tret = printbuf_strappend(pb, \"true\");\n\telse\n\t\tret = printbuf_strappend(pb, \"false\");\n\tif (ret > -1 && flags & JSON_C_TO_STRING_COLOR)\n\t\treturn printbuf_strappend(pb, ANSI_COLOR_RESET);\n\treturn ret;\n}\n\nstruct json_object *json_object_new_boolean(json_bool b)\n{\n\tstruct json_object_boolean *jso = JSON_OBJECT_NEW(boolean);\n\tif (!jso)\n\t\treturn NULL;\n\tjso->c_boolean = b;\n\treturn &jso->base;\n}\n\njson_bool json_object_get_boolean(const struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn 0;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_boolean: return JC_BOOL_C(jso)->c_boolean;\n\tcase json_type_int:\n\t\tswitch (JC_INT_C(jso)->cint_type)\n\t\t{\n\t\tcase json_object_int_type_int64: return (JC_INT_C(jso)->cint.c_int64 != 0);\n\t\tcase json_object_int_type_uint64: return (JC_INT_C(jso)->cint.c_uint64 != 0);\n\t\tdefault: json_abort(\"invalid cint_type\");\n\t\t}\n\tcase json_type_double: return (JC_DOUBLE_C(jso)->c_double != 0);\n\tcase json_type_string: return (JC_STRING_C(jso)->len != 0);\n\tdefault: return 0;\n\t}\n}\n\nint json_object_set_boolean(struct json_object *jso, json_bool new_value)\n{\n\tif (!jso || jso->o_type != json_type_boolean)\n\t\treturn 0;\n\tJC_BOOL(jso)->c_boolean = new_value;\n\treturn 1;\n}\n\n/* json_object_int */\n\nstatic int json_object_int_to_json_string(struct json_object *jso, struct printbuf *pb, int level,\n                                          int flags)\n{\n\t/* room for 19 digits, the sign char, and a null term */\n\tchar sbuf[21];\n\tif (JC_INT(jso)->cint_type == json_object_int_type_int64)\n\t\tsnprintf(sbuf, sizeof(sbuf), \"%\" PRId64, JC_INT(jso)->cint.c_int64);\n\telse\n\t\tsnprintf(sbuf, sizeof(sbuf), \"%\" PRIu64, JC_INT(jso)->cint.c_uint64);\n\treturn printbuf_memappend(pb, sbuf, strlen(sbuf));\n}\n\nstruct json_object *json_object_new_int(int32_t i)\n{\n\treturn json_object_new_int64(i);\n}\n\nint32_t json_object_get_int(const struct json_object *jso)\n{\n\tint64_t cint64 = 0;\n\tdouble cdouble;\n\tenum json_type o_type;\n\terrno = 0;\n\n\tif (!jso)\n\t\treturn 0;\n\n\to_type = jso->o_type;\n\tif (o_type == json_type_int)\n\t{\n\t\tconst struct json_object_int *jsoint = JC_INT_C(jso);\n\t\tif (jsoint->cint_type == json_object_int_type_int64)\n\t\t{\n\t\t\tcint64 = jsoint->cint.c_int64;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (jsoint->cint.c_uint64 >= INT64_MAX)\n\t\t\t\tcint64 = INT64_MAX;\n\t\t\telse\n\t\t\t\tcint64 = (int64_t)jsoint->cint.c_uint64;\n\t\t}\n\t}\n\telse if (o_type == json_type_string)\n\t{\n\t\t/*\n\t\t * Parse strings into 64-bit numbers, then use the\n\t\t * 64-to-32-bit number handling below.\n\t\t */\n\t\tif (json_parse_int64(get_string_component(jso), &cint64) != 0)\n\t\t\treturn 0; /* whoops, it didn't work. */\n\t\to_type = json_type_int;\n\t}\n\n\tswitch (o_type)\n\t{\n\tcase json_type_int:\n\t\t/* Make sure we return the correct values for out of range numbers. */\n\t\tif (cint64 < INT32_MIN)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn INT32_MIN;\n\t\t}\n\t\tif (cint64 > INT32_MAX)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn INT32_MAX;\n\t\t}\n\t\treturn (int32_t)cint64;\n\tcase json_type_double:\n\t\tcdouble = JC_DOUBLE_C(jso)->c_double;\n\t\tif (cdouble < INT32_MIN)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn INT32_MIN;\n\t\t}\n\t\tif (cdouble > INT32_MAX)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn INT32_MAX;\n\t\t}\n\t\tif (isnan(cdouble))\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn INT32_MIN;\n\t\t}\n\t\treturn (int32_t)cdouble;\n\tcase json_type_boolean: return JC_BOOL_C(jso)->c_boolean;\n\tdefault: return 0;\n\t}\n}\n\nint json_object_set_int(struct json_object *jso, int new_value)\n{\n\treturn json_object_set_int64(jso, (int64_t)new_value);\n}\n\nstruct json_object *json_object_new_int64(int64_t i)\n{\n\tstruct json_object_int *jso = JSON_OBJECT_NEW(int);\n\tif (!jso)\n\t\treturn NULL;\n\tjso->cint.c_int64 = i;\n\tjso->cint_type = json_object_int_type_int64;\n\treturn &jso->base;\n}\n\nstruct json_object *json_object_new_uint64(uint64_t i)\n{\n\tstruct json_object_int *jso = JSON_OBJECT_NEW(int);\n\tif (!jso)\n\t\treturn NULL;\n\tjso->cint.c_uint64 = i;\n\tjso->cint_type = json_object_int_type_uint64;\n\treturn &jso->base;\n}\n\nint64_t json_object_get_int64(const struct json_object *jso)\n{\n\tint64_t cint;\n\terrno = 0;\n\n\tif (!jso)\n\t\treturn 0;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_int:\n\t{\n\t\tconst struct json_object_int *jsoint = JC_INT_C(jso);\n\t\tswitch (jsoint->cint_type)\n\t\t{\n\t\tcase json_object_int_type_int64: return jsoint->cint.c_int64;\n\t\tcase json_object_int_type_uint64:\n\t\t\tif (jsoint->cint.c_uint64 > INT64_MAX)\n\t\t\t{\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn INT64_MAX;\n\t\t\t}\n\t\t\treturn (int64_t)jsoint->cint.c_uint64;\n\t\tdefault: json_abort(\"invalid cint_type\");\n\t\t}\n\t}\n\tcase json_type_double:\n\t\t// INT64_MAX can't be exactly represented as a double\n\t\t// so cast to tell the compiler it's ok to round up.\n\t\tif (JC_DOUBLE_C(jso)->c_double > (double)INT64_MAX)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn INT64_MAX;\n\t\t}\n\t\tif (JC_DOUBLE_C(jso)->c_double < (double)INT64_MIN)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn INT64_MIN;\n\t\t}\n\t\tif (isnan(JC_DOUBLE_C(jso)->c_double))\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn INT64_MIN;\n\t\t}\n\t\treturn (int64_t)JC_DOUBLE_C(jso)->c_double;\n\tcase json_type_boolean: return JC_BOOL_C(jso)->c_boolean;\n\tcase json_type_string:\n\t\tif (json_parse_int64(get_string_component(jso), &cint) == 0)\n\t\t\treturn cint;\n\t\t/* FALLTHRU */\n\tdefault: return 0;\n\t}\n}\n\nuint64_t json_object_get_uint64(const struct json_object *jso)\n{\n\tuint64_t cuint;\n\terrno = 0;\n\n\tif (!jso)\n\t\treturn 0;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_int:\n\t{\n\t\tconst struct json_object_int *jsoint = JC_INT_C(jso);\n\t\tswitch (jsoint->cint_type)\n\t\t{\n\t\tcase json_object_int_type_int64:\n\t\t\tif (jsoint->cint.c_int64 < 0)\n\t\t\t{\n\t\t\t\terrno = ERANGE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (uint64_t)jsoint->cint.c_int64;\n\t\tcase json_object_int_type_uint64: return jsoint->cint.c_uint64;\n\t\tdefault: json_abort(\"invalid cint_type\");\n\t\t}\n\t}\n\tcase json_type_double:\n\t\t// UINT64_MAX can't be exactly represented as a double\n\t\t// so cast to tell the compiler it's ok to round up.\n\t\tif (JC_DOUBLE_C(jso)->c_double > (double)UINT64_MAX)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn UINT64_MAX;\n\t\t}\n\t\tif (JC_DOUBLE_C(jso)->c_double < 0)\n\t\t{\n\t\t\terrno = ERANGE;\n\t\t\treturn 0;\n\t\t}\n\t\tif (isnan(JC_DOUBLE_C(jso)->c_double))\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n\t\treturn (uint64_t)JC_DOUBLE_C(jso)->c_double;\n\tcase json_type_boolean: return JC_BOOL_C(jso)->c_boolean;\n\tcase json_type_string:\n\t\tif (json_parse_uint64(get_string_component(jso), &cuint) == 0)\n\t\t\treturn cuint;\n\t\t/* FALLTHRU */\n\tdefault: return 0;\n\t}\n}\n\nint json_object_set_int64(struct json_object *jso, int64_t new_value)\n{\n\tif (!jso || jso->o_type != json_type_int)\n\t\treturn 0;\n\tJC_INT(jso)->cint.c_int64 = new_value;\n\tJC_INT(jso)->cint_type = json_object_int_type_int64;\n\treturn 1;\n}\n\nint json_object_set_uint64(struct json_object *jso, uint64_t new_value)\n{\n\tif (!jso || jso->o_type != json_type_int)\n\t\treturn 0;\n\tJC_INT(jso)->cint.c_uint64 = new_value;\n\tJC_INT(jso)->cint_type = json_object_int_type_uint64;\n\treturn 1;\n}\n\nint json_object_int_inc(struct json_object *jso, int64_t val)\n{\n\tstruct json_object_int *jsoint;\n\tif (!jso || jso->o_type != json_type_int)\n\t\treturn 0;\n\tjsoint = JC_INT(jso);\n\tswitch (jsoint->cint_type)\n\t{\n\tcase json_object_int_type_int64:\n\t\tif (val > 0 && jsoint->cint.c_int64 > INT64_MAX - val)\n\t\t{\n\t\t\tjsoint->cint.c_uint64 = (uint64_t)jsoint->cint.c_int64 + (uint64_t)val;\n\t\t\tjsoint->cint_type = json_object_int_type_uint64;\n\t\t}\n\t\telse if (val < 0 && jsoint->cint.c_int64 < INT64_MIN - val)\n\t\t{\n\t\t\tjsoint->cint.c_int64 = INT64_MIN;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjsoint->cint.c_int64 += val;\n\t\t}\n\t\treturn 1;\n\tcase json_object_int_type_uint64:\n\t\tif (val > 0 && jsoint->cint.c_uint64 > UINT64_MAX - (uint64_t)val)\n\t\t{\n\t\t\tjsoint->cint.c_uint64 = UINT64_MAX;\n\t\t}\n\t\telse if (val < 0 && jsoint->cint.c_uint64 < (uint64_t)(-val))\n\t\t{\n\t\t\tjsoint->cint.c_int64 = (int64_t)jsoint->cint.c_uint64 + val;\n\t\t\tjsoint->cint_type = json_object_int_type_int64;\n\t\t}\n\t\telse if (val < 0 && jsoint->cint.c_uint64 >= (uint64_t)(-val))\n\t\t{\n\t\t\tjsoint->cint.c_uint64 -= (uint64_t)(-val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjsoint->cint.c_uint64 += val;\n\t\t}\n\t\treturn 1;\n\tdefault: json_abort(\"invalid cint_type\");\n\t}\n}\n\n/* json_object_double */\n\n#if defined(HAVE___THREAD)\n// i.e. __thread or __declspec(thread)\nstatic SPEC___THREAD char *tls_serialization_float_format = NULL;\n#endif\nstatic char *global_serialization_float_format = NULL;\n\nint json_c_set_serialization_double_format(const char *double_format, int global_or_thread)\n{\n\tif (global_or_thread == JSON_C_OPTION_GLOBAL)\n\t{\n#if defined(HAVE___THREAD)\n\t\tif (tls_serialization_float_format)\n\t\t{\n\t\t\tfree(tls_serialization_float_format);\n\t\t\ttls_serialization_float_format = NULL;\n\t\t}\n#endif\n\t\tif (global_serialization_float_format)\n\t\t\tfree(global_serialization_float_format);\n\t\tif (double_format)\n\t\t{\n\t\t\tchar *p = strdup(double_format);\n\t\t\tif (p == NULL)\n\t\t\t{\n\t\t\t\t_json_c_set_last_err(\"json_c_set_serialization_double_format: \"\n\t\t\t\t                     \"out of memory\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tglobal_serialization_float_format = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tglobal_serialization_float_format = NULL;\n\t\t}\n\t}\n\telse if (global_or_thread == JSON_C_OPTION_THREAD)\n\t{\n#if defined(HAVE___THREAD)\n\t\tif (tls_serialization_float_format)\n\t\t{\n\t\t\tfree(tls_serialization_float_format);\n\t\t\ttls_serialization_float_format = NULL;\n\t\t}\n\t\tif (double_format)\n\t\t{\n\t\t\tchar *p = strdup(double_format);\n\t\t\tif (p == NULL)\n\t\t\t{\n\t\t\t\t_json_c_set_last_err(\"json_c_set_serialization_double_format: \"\n\t\t\t\t                     \"out of memory\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\ttls_serialization_float_format = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttls_serialization_float_format = NULL;\n\t\t}\n#else\n\t\t_json_c_set_last_err(\"json_c_set_serialization_double_format: not compiled \"\n\t\t                     \"with __thread support\\n\");\n\t\treturn -1;\n#endif\n\t}\n\telse\n\t{\n\t\t_json_c_set_last_err(\"json_c_set_serialization_double_format: invalid \"\n\t\t                     \"global_or_thread value: %d\\n\", global_or_thread);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int json_object_double_to_json_string_format(struct json_object *jso, struct printbuf *pb,\n                                                    int level, int flags, const char *format)\n{\n\tstruct json_object_double *jsodbl = JC_DOUBLE(jso);\n\tchar buf[128], *p, *q;\n\tint size;\n\t/* Although JSON RFC does not support\n\t * NaN or Infinity as numeric values\n\t * ECMA 262 section 9.8.1 defines\n\t * how to handle these cases as strings\n\t */\n\tif (isnan(jsodbl->c_double))\n\t{\n\t\tsize = snprintf(buf, sizeof(buf), \"NaN\");\n\t}\n\telse if (isinf(jsodbl->c_double))\n\t{\n\t\tif (jsodbl->c_double > 0)\n\t\t\tsize = snprintf(buf, sizeof(buf), \"Infinity\");\n\t\telse\n\t\t\tsize = snprintf(buf, sizeof(buf), \"-Infinity\");\n\t}\n\telse\n\t{\n\t\tconst char *std_format = \"%.17g\";\n\t\tint format_drops_decimals = 0;\n\t\tint looks_numeric = 0;\n\n\t\tif (!format)\n\t\t{\n#if defined(HAVE___THREAD)\n\t\t\tif (tls_serialization_float_format)\n\t\t\t\tformat = tls_serialization_float_format;\n\t\t\telse\n#endif\n\t\t\t    if (global_serialization_float_format)\n\t\t\t\tformat = global_serialization_float_format;\n\t\t\telse\n\t\t\t\tformat = std_format;\n\t\t}\n\t\tsize = snprintf(buf, sizeof(buf), format, jsodbl->c_double);\n\n\t\tif (size < 0)\n\t\t\treturn -1;\n\n\t\tp = strchr(buf, ',');\n\t\tif (p)\n\t\t\t*p = '.';\n\t\telse\n\t\t\tp = strchr(buf, '.');\n\n\t\tif (format == std_format || strstr(format, \".0f\") == NULL)\n\t\t\tformat_drops_decimals = 1;\n\n\t\tlooks_numeric = /* Looks like *some* kind of number */\n\t\t    is_plain_digit(buf[0]) || (size > 1 && buf[0] == '-' && is_plain_digit(buf[1]));\n\n\t\tif (size < (int)sizeof(buf) - 2 && looks_numeric && !p && /* Has no decimal point */\n\t\t    strchr(buf, 'e') == NULL && /* Not scientific notation */\n\t\t    format_drops_decimals)\n\t\t{\n\t\t\t// Ensure it looks like a float, even if snprintf didn't,\n\t\t\t//  unless a custom format is set to omit the decimal.\n\t\t\tstrcat(buf, \".0\");\n\t\t\tsize += 2;\n\t\t}\n\t\tif (p && (flags & JSON_C_TO_STRING_NOZERO))\n\t\t{\n\t\t\t/* last useful digit, always keep 1 zero */\n\t\t\tp++;\n\t\t\tfor (q = p; *q; q++)\n\t\t\t{\n\t\t\t\tif (*q != '0')\n\t\t\t\t\tp = q;\n\t\t\t}\n\t\t\t/* drop trailing zeroes */\n\t\t\tif (*p != 0)\n\t\t\t\t*(++p) = 0;\n\t\t\tsize = p - buf;\n\t\t}\n\t}\n\t// although unlikely, snprintf can fail\n\tif (size < 0)\n\t\treturn -1;\n\n\tif (size >= (int)sizeof(buf))\n\t\t// The standard formats are guaranteed not to overrun the buffer,\n\t\t// but if a custom one happens to do so, just silently truncate.\n\t\tsize = sizeof(buf) - 1;\n\tprintbuf_memappend(pb, buf, size);\n\treturn size;\n}\n\nstatic int json_object_double_to_json_string_default(struct json_object *jso, struct printbuf *pb,\n                                                     int level, int flags)\n{\n\treturn json_object_double_to_json_string_format(jso, pb, level, flags, NULL);\n}\n\nint json_object_double_to_json_string(struct json_object *jso, struct printbuf *pb, int level,\n                                      int flags)\n{\n\treturn json_object_double_to_json_string_format(jso, pb, level, flags,\n\t                                                (const char *)jso->_userdata);\n}\n\nstruct json_object *json_object_new_double(double d)\n{\n\tstruct json_object_double *jso = JSON_OBJECT_NEW(double);\n\tif (!jso)\n\t\treturn NULL;\n\tjso->base._to_json_string = &json_object_double_to_json_string_default;\n\tjso->c_double = d;\n\treturn &jso->base;\n}\n\nstruct json_object *json_object_new_double_s(double d, const char *ds)\n{\n\tchar *new_ds;\n\tstruct json_object *jso = json_object_new_double(d);\n\tif (!jso)\n\t\treturn NULL;\n\n\tnew_ds = strdup(ds);\n\tif (!new_ds)\n\t{\n\t\tjson_object_generic_delete(jso);\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tjson_object_set_serializer(jso, _json_object_userdata_to_json_string, new_ds,\n\t                           json_object_free_userdata);\n\treturn jso;\n}\n\n/*\n * A wrapper around json_object_userdata_to_json_string() used only\n * by json_object_new_double_s() just so json_object_set_double() can\n * detect when it needs to reset the serializer to the default.\n */\nstatic int _json_object_userdata_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                                int level, int flags)\n{\n\treturn json_object_userdata_to_json_string(jso, pb, level, flags);\n}\n\nint json_object_userdata_to_json_string(struct json_object *jso, struct printbuf *pb, int level,\n                                        int flags)\n{\n\tint userdata_len = strlen((const char *)jso->_userdata);\n\tprintbuf_memappend(pb, (const char *)jso->_userdata, userdata_len);\n\treturn userdata_len;\n}\n\nvoid json_object_free_userdata(struct json_object *jso, void *userdata)\n{\n\tfree(userdata);\n}\n\ndouble json_object_get_double(const struct json_object *jso)\n{\n\tdouble cdouble;\n\tchar *errPtr = NULL;\n\n\tif (!jso)\n\t\treturn 0.0;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_double: return JC_DOUBLE_C(jso)->c_double;\n\tcase json_type_int:\n\t\tswitch (JC_INT_C(jso)->cint_type)\n\t\t{\n\t\tcase json_object_int_type_int64: return JC_INT_C(jso)->cint.c_int64;\n\t\tcase json_object_int_type_uint64: return JC_INT_C(jso)->cint.c_uint64;\n\t\tdefault: json_abort(\"invalid cint_type\");\n\t\t}\n\tcase json_type_boolean: return JC_BOOL_C(jso)->c_boolean;\n\tcase json_type_string:\n\t\terrno = 0;\n\t\tcdouble = strtod(get_string_component(jso), &errPtr);\n\n\t\t/* if conversion stopped at the first character, return 0.0 */\n\t\tif (errPtr == get_string_component(jso))\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn 0.0;\n\t\t}\n\n\t\t/*\n\t\t * Check that the conversion terminated on something sensible\n\t\t *\n\t\t * For example, { \"pay\" : 123AB } would parse as 123.\n\t\t */\n\t\tif (*errPtr != '\\0')\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn 0.0;\n\t\t}\n\n\t\t/*\n\t\t * If strtod encounters a string which would exceed the\n\t\t * capacity of a double, it returns +/- HUGE_VAL and sets\n\t\t * errno to ERANGE. But +/- HUGE_VAL is also a valid result\n\t\t * from a conversion, so we need to check errno.\n\t\t *\n\t\t * Underflow also sets errno to ERANGE, but it returns 0 in\n\t\t * that case, which is what we will return anyway.\n\t\t *\n\t\t * See CERT guideline ERR30-C\n\t\t */\n\t\tif ((HUGE_VAL == cdouble || -HUGE_VAL == cdouble) && (ERANGE == errno))\n\t\t\tcdouble = 0.0;\n\t\treturn cdouble;\n\tdefault: errno = EINVAL; return 0.0;\n\t}\n}\n\nint json_object_set_double(struct json_object *jso, double new_value)\n{\n\tif (!jso || jso->o_type != json_type_double)\n\t\treturn 0;\n\tJC_DOUBLE(jso)->c_double = new_value;\n\tif (jso->_to_json_string == &_json_object_userdata_to_json_string)\n\t\tjson_object_set_serializer(jso, NULL, NULL, NULL);\n\treturn 1;\n}\n\n/* json_object_string */\n\nstatic int json_object_string_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                             int level, int flags)\n{\n\tssize_t len = JC_STRING(jso)->len;\n\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\tprintbuf_strappend(pb, ANSI_COLOR_FG_GREEN);\n\tprintbuf_strappend(pb, \"\\\"\");\n\tjson_escape_str(pb, get_string_component(jso), len < 0 ? -(ssize_t)len : len, flags);\n\tprintbuf_strappend(pb, \"\\\"\");\n\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\tprintbuf_strappend(pb, ANSI_COLOR_RESET);\n\treturn 0;\n}\n\nstatic void json_object_string_delete(struct json_object *jso)\n{\n\tif (JC_STRING(jso)->len < 0)\n\t\tfree(JC_STRING(jso)->c_string.pdata);\n\tjson_object_generic_delete(jso);\n}\n\nstatic struct json_object *_json_object_new_string(const char *s, const size_t len)\n{\n\tsize_t objsize;\n\tstruct json_object_string *jso;\n\n\t/*\n\t * Structures           Actual memory layout\n\t * -------------------  --------------------\n\t * [json_object_string  [json_object_string\n\t *  [json_object]        [json_object]\n\t *  ...other fields...   ...other fields...\n\t *  c_string]            len\n\t *                       bytes\n\t *                       of\n\t *                       string\n\t *                       data\n\t *                       \\0]\n\t */\n\tif (len > (SSIZE_T_MAX - (sizeof(*jso) - sizeof(jso->c_string)) - 1))\n\t\treturn NULL;\n\tobjsize = (sizeof(*jso) - sizeof(jso->c_string)) + len + 1;\n\tif (len < sizeof(void *))\n\t\t// We need a minimum size to support json_object_set_string() mutability\n\t\t// so we can stuff a pointer into pdata :(\n\t\tobjsize += sizeof(void *) - len;\n\n\tjso = (struct json_object_string *)json_object_new(json_type_string, objsize,\n\t                                                   &json_object_string_to_json_string);\n\n\tif (!jso)\n\t\treturn NULL;\n\tjso->len = len;\n\tmemcpy(jso->c_string.idata, s, len);\n\t// Cast below needed for Clang UB sanitizer\n\t((char *)jso->c_string.idata)[len] = '\\0';\n\treturn &jso->base;\n}\n\nstruct json_object *json_object_new_string(const char *s)\n{\n\treturn _json_object_new_string(s, strlen(s));\n}\n\nstruct json_object *json_object_new_string_len(const char *s, const int len)\n{\n\treturn _json_object_new_string(s, len);\n}\n\nconst char *json_object_get_string(struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn NULL;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_string: return get_string_component(jso);\n\tdefault: return json_object_to_json_string(jso);\n\t}\n}\n\nstatic inline ssize_t _json_object_get_string_len(const struct json_object_string *jso)\n{\n\tssize_t len;\n\tlen = jso->len;\n\treturn (len < 0) ? -(ssize_t)len : len;\n}\nint json_object_get_string_len(const struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn 0;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_string: return _json_object_get_string_len(JC_STRING_C(jso));\n\tdefault: return 0;\n\t}\n}\n\nstatic int _json_object_set_string_len(json_object *jso, const char *s, size_t len)\n{\n\tchar *dstbuf;\n\tssize_t curlen;\n\tssize_t newlen;\n\tif (jso == NULL || jso->o_type != json_type_string)\n\t\treturn 0;\n\n\tif (len >= INT_MAX - 1)\n\t\t// jso->len is a signed ssize_t, so it can't hold the\n\t\t// full size_t range. json_object_get_string_len returns\n\t\t// length as int, cap length at INT_MAX.\n\t\treturn 0;\n\n\tcurlen = JC_STRING(jso)->len;\n\tif (curlen < 0) {\n\t\tif (len == 0) {\n\t\t\tfree(JC_STRING(jso)->c_string.pdata);\n\t\t\tJC_STRING(jso)->len = curlen = 0;\n\t\t} else {\n\t\t\tcurlen = -curlen;\n\t\t}\n\t}\n\n\tnewlen = len;\n\tdstbuf = get_string_component_mutable(jso);\n\n\tif ((ssize_t)len > curlen)\n\t{\n\t\t// We have no way to return the new ptr from realloc(jso, newlen)\n\t\t// and we have no way of knowing whether there's extra room available\n\t\t// so we need to stuff a pointer in to pdata :(\n\t\tdstbuf = (char *)malloc(len + 1);\n\t\tif (dstbuf == NULL)\n\t\t\treturn 0;\n\t\tif (JC_STRING(jso)->len < 0)\n\t\t\tfree(JC_STRING(jso)->c_string.pdata);\n\t\tJC_STRING(jso)->c_string.pdata = dstbuf;\n\t\tnewlen = -(ssize_t)len;\n\t}\n\telse if (JC_STRING(jso)->len < 0)\n\t{\n\t\t// We've got enough room in the separate allocated buffer,\n\t\t// so use it as-is and continue to indicate that pdata is used.\n\t\tnewlen = -(ssize_t)len;\n\t}\n\n\tmemcpy(dstbuf, (const void *)s, len);\n\tdstbuf[len] = '\\0';\n\tJC_STRING(jso)->len = newlen;\n\treturn 1;\n}\n\nint json_object_set_string(json_object *jso, const char *s)\n{\n\treturn _json_object_set_string_len(jso, s, strlen(s));\n}\n\nint json_object_set_string_len(json_object *jso, const char *s, int len)\n{\n\treturn _json_object_set_string_len(jso, s, len);\n}\n\n/* json_object_array */\n\nstatic int json_object_array_to_json_string(struct json_object *jso, struct printbuf *pb, int level,\n                                            int flags)\n{\n\tint had_children = 0;\n\tsize_t ii;\n\n\tprintbuf_strappend(pb, \"[\");\n\tfor (ii = 0; ii < json_object_array_length(jso); ii++)\n\t{\n\t\tstruct json_object *val;\n\t\tif (had_children)\n\t\t{\n\t\t\tprintbuf_strappend(pb, \",\");\n\t\t}\n\t\tif (flags & JSON_C_TO_STRING_PRETTY)\n\t\t\tprintbuf_strappend(pb, \"\\n\");\n\t\thad_children = 1;\n\t\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\t\tprintbuf_strappend(pb, \" \");\n\t\tindent(pb, level + 1, flags);\n\t\tval = json_object_array_get_idx(jso, ii);\n\t\tif (val == NULL) {\n\n\t\t\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\t\t\tprintbuf_strappend(pb, ANSI_COLOR_FG_MAGENTA);\n\t\t\tprintbuf_strappend(pb, \"null\");\n\t\t\tif (flags & JSON_C_TO_STRING_COLOR)\n\t\t\t\tprintbuf_strappend(pb, ANSI_COLOR_RESET);\n\n\t\t} else if (val->_to_json_string(val, pb, level + 1, flags) < 0)\n\t\t\treturn -1;\n\t}\n\tif ((flags & JSON_C_TO_STRING_PRETTY) && had_children)\n\t{\n\t\tprintbuf_strappend(pb, \"\\n\");\n\t\tindent(pb, level, flags);\n\t}\n\n\tif (flags & JSON_C_TO_STRING_SPACED && !(flags & JSON_C_TO_STRING_PRETTY))\n\t\treturn printbuf_strappend(pb, \" ]\");\n\treturn printbuf_strappend(pb, \"]\");\n}\n\nstatic void json_object_array_entry_free(void *data)\n{\n\tjson_object_put((struct json_object *)data);\n}\n\nstatic void json_object_array_delete(struct json_object *jso)\n{\n\tarray_list_free(JC_ARRAY(jso)->c_array);\n\tjson_object_generic_delete(jso);\n}\n\nstruct json_object *json_object_new_array(void)\n{\n\treturn json_object_new_array_ext(ARRAY_LIST_DEFAULT_SIZE);\n}\nstruct json_object *json_object_new_array_ext(int initial_size)\n{\n\tstruct json_object_array *jso = JSON_OBJECT_NEW(array);\n\tif (!jso)\n\t\treturn NULL;\n\tjso->c_array = array_list_new2(&json_object_array_entry_free, initial_size);\n\tif (jso->c_array == NULL)\n\t{\n\t\tfree(jso);\n\t\treturn NULL;\n\t}\n\treturn &jso->base;\n}\n\nstruct array_list *json_object_get_array(const struct json_object *jso)\n{\n\tif (!jso)\n\t\treturn NULL;\n\tswitch (jso->o_type)\n\t{\n\tcase json_type_array: return JC_ARRAY_C(jso)->c_array;\n\tdefault: return NULL;\n\t}\n}\n\nvoid json_object_array_sort(struct json_object *jso, int (*sort_fn)(const void *, const void *))\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\tarray_list_sort(JC_ARRAY(jso)->c_array, sort_fn);\n}\n\nstruct json_object *json_object_array_bsearch(const struct json_object *key,\n                                              const struct json_object *jso,\n                                              int (*sort_fn)(const void *, const void *))\n{\n\tstruct json_object **result;\n\n\tassert(json_object_get_type(jso) == json_type_array);\n\tresult = (struct json_object **)array_list_bsearch((const void **)(void *)&key,\n\t                                                   JC_ARRAY_C(jso)->c_array, sort_fn);\n\n\tif (!result)\n\t\treturn NULL;\n\treturn *result;\n}\n\nsize_t json_object_array_length(const struct json_object *jso)\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\treturn array_list_length(JC_ARRAY_C(jso)->c_array);\n}\n\nint json_object_array_add(struct json_object *jso, struct json_object *val)\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\treturn array_list_add(JC_ARRAY(jso)->c_array, val);\n}\n\nint json_object_array_insert_idx(struct json_object *jso, size_t idx, struct json_object *val)\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\treturn array_list_insert_idx(JC_ARRAY(jso)->c_array, idx, val);\n}\n\nint json_object_array_put_idx(struct json_object *jso, size_t idx, struct json_object *val)\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\treturn array_list_put_idx(JC_ARRAY(jso)->c_array, idx, val);\n}\n\nint json_object_array_del_idx(struct json_object *jso, size_t idx, size_t count)\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\treturn array_list_del_idx(JC_ARRAY(jso)->c_array, idx, count);\n}\n\nstruct json_object *json_object_array_get_idx(const struct json_object *jso, size_t idx)\n{\n\tassert(json_object_get_type(jso) == json_type_array);\n\treturn (struct json_object *)array_list_get_idx(JC_ARRAY_C(jso)->c_array, idx);\n}\n\nstatic int json_array_equal(struct json_object *jso1, struct json_object *jso2)\n{\n\tsize_t len, i;\n\n\tlen = json_object_array_length(jso1);\n\tif (len != json_object_array_length(jso2))\n\t\treturn 0;\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tif (!json_object_equal(json_object_array_get_idx(jso1, i),\n\t\t                       json_object_array_get_idx(jso2, i)))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint json_object_array_shrink(struct json_object *jso, int empty_slots)\n{\n\tif (empty_slots < 0)\n\t\tjson_abort(\"json_object_array_shrink called with negative empty_slots\");\n\treturn array_list_shrink(JC_ARRAY(jso)->c_array, empty_slots);\n}\n\nstruct json_object *json_object_new_null(void)\n{\n\treturn NULL;\n}\n\nstatic int json_object_all_values_equal(struct json_object *jso1, struct json_object *jso2)\n{\n\tstruct json_object_iter iter;\n\tstruct json_object *sub;\n\n\tassert(json_object_get_type(jso1) == json_type_object);\n\tassert(json_object_get_type(jso2) == json_type_object);\n\t/* Iterate over jso1 keys and see if they exist and are equal in jso2 */\n\tjson_object_object_foreachC(jso1, iter)\n\t{\n\t\tif (!lh_table_lookup_ex(JC_OBJECT(jso2)->c_object, (void *)iter.key,\n\t\t                        (void **)(void *)&sub))\n\t\t\treturn 0;\n\t\tif (!json_object_equal(iter.val, sub))\n\t\t\treturn 0;\n\t}\n\n\t/* Iterate over jso2 keys to see if any exist that are not in jso1 */\n\tjson_object_object_foreachC(jso2, iter)\n\t{\n\t\tif (!lh_table_lookup_ex(JC_OBJECT(jso1)->c_object, (void *)iter.key,\n\t\t                        (void **)(void *)&sub))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nint json_object_equal(struct json_object *jso1, struct json_object *jso2)\n{\n\tif (jso1 == jso2)\n\t\treturn 1;\n\n\tif (!jso1 || !jso2)\n\t\treturn 0;\n\n\tif (jso1->o_type != jso2->o_type)\n\t\treturn 0;\n\n\tswitch (jso1->o_type)\n\t{\n\tcase json_type_boolean: return (JC_BOOL(jso1)->c_boolean == JC_BOOL(jso2)->c_boolean);\n\n\tcase json_type_double: return (JC_DOUBLE(jso1)->c_double == JC_DOUBLE(jso2)->c_double);\n\n\tcase json_type_int:\n\t{\n\t\tstruct json_object_int *int1 = JC_INT(jso1);\n\t\tstruct json_object_int *int2 = JC_INT(jso2);\n\t\tif (int1->cint_type == json_object_int_type_int64)\n\t\t{\n\t\t\tif (int2->cint_type == json_object_int_type_int64)\n\t\t\t\treturn (int1->cint.c_int64 == int2->cint.c_int64);\n\t\t\tif (int1->cint.c_int64 < 0)\n\t\t\t\treturn 0;\n\t\t\treturn ((uint64_t)int1->cint.c_int64 == int2->cint.c_uint64);\n\t\t}\n\t\t// else jso1 is a uint64\n\t\tif (int2->cint_type == json_object_int_type_uint64)\n\t\t\treturn (int1->cint.c_uint64 == int2->cint.c_uint64);\n\t\tif (int2->cint.c_int64 < 0)\n\t\t\treturn 0;\n\t\treturn (int1->cint.c_uint64 == (uint64_t)int2->cint.c_int64);\n\t}\n\n\tcase json_type_string:\n\t{\n\t\treturn (_json_object_get_string_len(JC_STRING(jso1)) ==\n\t\t            _json_object_get_string_len(JC_STRING(jso2)) &&\n\t\t        memcmp(get_string_component(jso1), get_string_component(jso2),\n\t\t               _json_object_get_string_len(JC_STRING(jso1))) == 0);\n\t}\n\n\tcase json_type_object: return json_object_all_values_equal(jso1, jso2);\n\n\tcase json_type_array: return json_array_equal(jso1, jso2);\n\n\tcase json_type_null: return 1;\n\t};\n\n\treturn 0;\n}\n\nstatic int json_object_copy_serializer_data(struct json_object *src, struct json_object *dst)\n{\n\tif (!src->_userdata && !src->_user_delete)\n\t\treturn 0;\n\n\tif (dst->_to_json_string == json_object_userdata_to_json_string ||\n\t    dst->_to_json_string == _json_object_userdata_to_json_string)\n\t{\n\t\tchar *p;\n\t\tassert(src->_userdata);\n\t\tp = strdup(src->_userdata);\n\t\tif (p == NULL)\n\t\t{\n\t\t\t_json_c_set_last_err(\"json_object_copy_serializer_data: out of memory\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tdst->_userdata = p;\n\t}\n\t// else if ... other supported serializers ...\n\telse\n\t{\n\t\t_json_c_set_last_err(\n\t\t    \"json_object_copy_serializer_data: unable to copy unknown serializer data: \"\n\t\t    \"%p\\n\", (void *)dst->_to_json_string);\n\t\treturn -1;\n\t}\n\tdst->_user_delete = src->_user_delete;\n\treturn 0;\n}\n\n/**\n * The default shallow copy implementation.  Simply creates a new object of the same\n * type but does *not* copy over _userdata nor retain any custom serializer.\n * If custom serializers are in use, json_object_deep_copy() must be passed a shallow copy\n * implementation that is aware of how to copy them.\n *\n * This always returns -1 or 1.  It will never return 2 since it does not copy the serializer.\n */\nint json_c_shallow_copy_default(json_object *src, json_object *parent, const char *key,\n                                size_t index, json_object **dst)\n{\n\tswitch (src->o_type)\n\t{\n\tcase json_type_boolean: *dst = json_object_new_boolean(JC_BOOL(src)->c_boolean); break;\n\n\tcase json_type_double: *dst = json_object_new_double(JC_DOUBLE(src)->c_double); break;\n\n\tcase json_type_int:\n\t\tswitch (JC_INT(src)->cint_type)\n\t\t{\n\t\tcase json_object_int_type_int64:\n\t\t\t*dst = json_object_new_int64(JC_INT(src)->cint.c_int64);\n\t\t\tbreak;\n\t\tcase json_object_int_type_uint64:\n\t\t\t*dst = json_object_new_uint64(JC_INT(src)->cint.c_uint64);\n\t\t\tbreak;\n\t\tdefault: json_abort(\"invalid cint_type\");\n\t\t}\n\t\tbreak;\n\n\tcase json_type_string:\n\t\t*dst = json_object_new_string_len(get_string_component(src),\n\t\t                                  _json_object_get_string_len(JC_STRING(src)));\n\t\tbreak;\n\n\tcase json_type_object: *dst = json_object_new_object(); break;\n\n\tcase json_type_array: *dst = json_object_new_array(); break;\n\n\tdefault: errno = EINVAL; return -1;\n\t}\n\n\tif (!*dst)\n\t{\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\t(*dst)->_to_json_string = src->_to_json_string;\n\t// _userdata and _user_delete are copied later\n\treturn 1;\n}\n\n/*\n * The actual guts of json_object_deep_copy(), with a few additional args\n * needed so we can keep track of where we are within the object tree.\n *\n * Note: caller is responsible for freeing *dst if this fails and returns -1.\n */\nstatic int json_object_deep_copy_recursive(struct json_object *src, struct json_object *parent,\n                                           const char *key_in_parent, size_t index_in_parent,\n                                           struct json_object **dst,\n                                           json_c_shallow_copy_fn *shallow_copy)\n{\n\tstruct json_object_iter iter;\n\tsize_t src_array_len, ii;\n\n\tint shallow_copy_rc = 0;\n\tshallow_copy_rc = shallow_copy(src, parent, key_in_parent, index_in_parent, dst);\n\t/* -1=error, 1=object created ok, 2=userdata set */\n\tif (shallow_copy_rc < 1)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tassert(*dst != NULL);\n\n\tswitch (src->o_type)\n\t{\n\tcase json_type_object:\n\t\tjson_object_object_foreachC(src, iter)\n\t\t{\n\t\t\tstruct json_object *jso = NULL;\n\t\t\t/* This handles the `json_type_null` case */\n\t\t\tif (!iter.val)\n\t\t\t\tjso = NULL;\n\t\t\telse if (json_object_deep_copy_recursive(iter.val, src, iter.key, UINT_MAX,\n\t\t\t                                         &jso, shallow_copy) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (json_object_object_add(*dst, iter.key, jso) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase json_type_array:\n\t\tsrc_array_len = json_object_array_length(src);\n\t\tfor (ii = 0; ii < src_array_len; ii++)\n\t\t{\n\t\t\tstruct json_object *jso = NULL;\n\t\t\tstruct json_object *jso1 = json_object_array_get_idx(src, ii);\n\t\t\t/* This handles the `json_type_null` case */\n\t\t\tif (!jso1)\n\t\t\t\tjso = NULL;\n\t\t\telse if (json_object_deep_copy_recursive(jso1, src, NULL, ii, &jso,\n\t\t\t                                         shallow_copy) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (json_object_array_add(*dst, jso) < 0)\n\t\t\t{\n\t\t\t\tjson_object_put(jso);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t\t/* else, nothing to do, shallow_copy already did. */\n\t}\n\n\tif (shallow_copy_rc != 2)\n\t\treturn json_object_copy_serializer_data(src, *dst);\n\n\treturn 0;\n}\n\nint json_object_deep_copy(struct json_object *src, struct json_object **dst,\n                          json_c_shallow_copy_fn *shallow_copy)\n{\n\tint rc;\n\n\t/* Check if arguments are sane ; *dst must not point to a non-NULL object */\n\tif (!src || !dst || *dst)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (shallow_copy == NULL)\n\t\tshallow_copy = json_c_shallow_copy_default;\n\n\trc = json_object_deep_copy_recursive(src, NULL, NULL, UINT_MAX, dst, shallow_copy);\n\tif (rc < 0)\n\t{\n\t\tjson_object_put(*dst);\n\t\t*dst = NULL;\n\t}\n\n\treturn rc;\n}\n\nstatic void json_abort(const char *message)\n{\n\tif (message != NULL)\n\t\tfprintf(stderr, \"json-c aborts with error: %s\\n\", message);\n\tabort();\n}\n"
        },
        {
          "name": "json_object.h",
          "type": "blob",
          "size": 44.1611328125,
          "content": "/*\n * $Id: json_object.h,v 1.12 2006/01/30 23:07:57 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n * Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Core json-c API.  Start here, or with json_tokener.h\n */\n#ifndef _json_object_h_\n#define _json_object_h_\n\n#ifdef __GNUC__\n#define JSON_C_CONST_FUNCTION(func) func __attribute__((const))\n#else\n#define JSON_C_CONST_FUNCTION(func) func\n#endif\n\n#include \"json_inttypes.h\"\n#include \"json_types.h\"\n#include \"printbuf.h\"\n\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define JSON_OBJECT_DEF_HASH_ENTRIES 16\n\n/**\n * A flag for the json_object_to_json_string_ext() and\n * json_object_to_file_ext() functions which causes the output\n * to have no extra whitespace or formatting applied.\n */\n#define JSON_C_TO_STRING_PLAIN 0\n/**\n * A flag for the json_object_to_json_string_ext() and\n * json_object_to_file_ext() functions which causes the output to have\n * minimal whitespace inserted to make things slightly more readable.\n */\n#define JSON_C_TO_STRING_SPACED (1 << 0)\n/**\n * A flag for the json_object_to_json_string_ext() and\n * json_object_to_file_ext() functions which causes\n * the output to be formatted.\n *\n * See the \"Two Space Tab\" option at https://jsonformatter.curiousconcept.com/\n * for an example of the format.\n */\n#define JSON_C_TO_STRING_PRETTY (1 << 1)\n/**\n * A flag for the json_object_to_json_string_ext() and\n * json_object_to_file_ext() functions which causes\n * the output to be formatted.\n *\n * Instead of a \"Two Space Tab\" this gives a single tab character.\n */\n#define JSON_C_TO_STRING_PRETTY_TAB (1 << 3)\n/**\n * A flag to drop trailing zero for float values\n */\n#define JSON_C_TO_STRING_NOZERO (1 << 2)\n\n/**\n * Don't escape forward slashes.\n */\n#define JSON_C_TO_STRING_NOSLASHESCAPE (1 << 4)\n\n/**\n * A flag for the json_object_to_json_string_ext() and\n * json_object_to_file_ext() functions which causes\n * the output to be formatted.\n *\n * Use color for printing json.\n */\n#define JSON_C_TO_STRING_COLOR (1 << 5)\n\n/**\n * A flag for the json_object_object_add_ex function which\n * causes the value to be added without a check if it already exists.\n * Note: it is the responsibility of the caller to ensure that no\n * key is added multiple times. If this is done, results are\n * unpredictable. While this option is somewhat dangerous, it\n * permits potentially large performance savings in code that\n * knows for sure the key values are unique (e.g. because the\n * code adds a well-known set of constant key values).\n */\n#define JSON_C_OBJECT_ADD_KEY_IS_NEW (1 << 1)\n/**\n * A flag for the json_object_object_add_ex function which\n * flags the key as being constant memory. This means that\n * the key will NOT be copied via strdup(), resulting in a\n * potentially huge performance win (malloc, strdup and\n * free are usually performance hogs). It is acceptable to\n * use this flag for keys in non-constant memory blocks if\n * the caller ensure that the memory holding the key lives\n * longer than the corresponding json object. However, this\n * is somewhat dangerous and should only be done if really\n * justified.\n * The general use-case for this flag is cases where the\n * key is given as a real constant value in the function\n * call, e.g. as in\n *   json_object_object_add_ex(obj, \"ip\", json,\n *       JSON_C_OBJECT_ADD_CONSTANT_KEY);\n */\n#define JSON_C_OBJECT_ADD_CONSTANT_KEY (1 << 2)\n/**\n * This flag is an alias to JSON_C_OBJECT_ADD_CONSTANT_KEY.\n * Historically, this flag was used first and the new name\n * JSON_C_OBJECT_ADD_CONSTANT_KEY was introduced for version\n * 0.16.00 in order to have regular naming.\n * Use of this flag is now legacy.\n */\n#define JSON_C_OBJECT_KEY_IS_CONSTANT  JSON_C_OBJECT_ADD_CONSTANT_KEY\n\n/**\n * Set the global value of an option, which will apply to all\n * current and future threads that have not set a thread-local value.\n *\n * @see json_c_set_serialization_double_format\n */\n#define JSON_C_OPTION_GLOBAL (0)\n/**\n * Set a thread-local value of an option, overriding the global value.\n * This will fail if json-c is not compiled with threading enabled, and\n * with the __thread specifier (or equivalent) available.\n *\n * @see json_c_set_serialization_double_format\n */\n#define JSON_C_OPTION_THREAD (1)\n\n/* reference counting functions */\n\n/**\n * Increment the reference count of json_object, thereby taking ownership of it.\n *\n * Cases where you might need to increase the refcount include:\n * - Using an object field or array index (retrieved through\n *    `json_object_object_get()` or `json_object_array_get_idx()`)\n *    beyond the lifetime of the parent object.\n * - Detaching an object field or array index from its parent object\n *    (using `json_object_object_del()` or `json_object_array_del_idx()`)\n * - Sharing a json_object with multiple (not necessarily parallel) threads\n *    of execution that all expect to free it (with `json_object_put()`) when\n *    they're done.\n *\n * @param obj the json_object instance\n * @see json_object_put()\n * @see json_object_object_get()\n * @see json_object_array_get_idx()\n */\nJSON_EXPORT struct json_object *json_object_get(struct json_object *obj);\n\n/**\n * Decrement the reference count of json_object and free if it reaches zero.\n *\n * You must have ownership of obj prior to doing this or you will cause an\n * imbalance in the reference count, leading to a classic use-after-free bug.\n * In particular, you normally do not need to call `json_object_put()` on the\n * json_object returned by `json_object_object_get()` or `json_object_array_get_idx()`.\n *\n * Just like after calling `free()` on a block of memory, you must not use\n * `obj` after calling `json_object_put()` on it or any object that it\n * is a member of (unless you know you've called `json_object_get(obj)` to\n * explicitly increment the refcount).\n *\n * NULL may be passed, in which case this is a no-op.\n *\n * @param obj the json_object instance\n * @returns 1 if the object was freed, 0 if only the refcount was decremented\n * @see json_object_get()\n */\nJSON_EXPORT int json_object_put(struct json_object *obj);\n\n/**\n * Check if the json_object is of a given type\n * @param obj the json_object instance\n * @param type one of:\n     json_type_null (i.e. obj == NULL),\n     json_type_boolean,\n     json_type_double,\n     json_type_int,\n     json_type_object,\n     json_type_array,\n     json_type_string\n * @returns 1 if the object is of the specified type, 0 otherwise\n */\nJSON_EXPORT int json_object_is_type(const struct json_object *obj, enum json_type type);\n\n/**\n * Get the type of the json_object.  See also json_type_to_name() to turn this\n * into a string suitable, for instance, for logging.\n *\n * @param obj the json_object instance\n * @returns type being one of:\n     json_type_null (i.e. obj == NULL),\n     json_type_boolean,\n     json_type_double,\n     json_type_int,\n     json_type_object,\n     json_type_array,\n     json_type_string\n */\nJSON_EXPORT enum json_type json_object_get_type(const struct json_object *obj);\n\n/** Stringify object to json format.\n * Equivalent to json_object_to_json_string_ext(obj, JSON_C_TO_STRING_SPACED)\n * The pointer you get is an internal of your json object. You don't\n * have to free it, later use of json_object_put() should be sufficient.\n * If you can not ensure there's no concurrent access to *obj use\n * strdup().\n * @param obj the json_object instance\n * @returns a string in JSON format\n */\nJSON_EXPORT const char *json_object_to_json_string(struct json_object *obj);\n\n/** Stringify object to json format\n * @see json_object_to_json_string() for details on how to free string.\n * @param obj the json_object instance\n * @param flags formatting options, see JSON_C_TO_STRING_PRETTY and other constants\n * @returns a string in JSON format\n */\nJSON_EXPORT const char *json_object_to_json_string_ext(struct json_object *obj, int flags);\n\n/** Stringify object to json format\n * @see json_object_to_json_string() for details on how to free string.\n * @param obj the json_object instance\n * @param flags formatting options, see JSON_C_TO_STRING_PRETTY and other constants\n * @param length a pointer where, if not NULL, the length (without null) is stored\n * @returns a string in JSON format and the length if not NULL\n */\nJSON_EXPORT const char *json_object_to_json_string_length(struct json_object *obj, int flags,\n                                                          size_t *length);\n\n/**\n * Returns the userdata set by json_object_set_userdata() or\n * json_object_set_serializer()\n *\n * @param jso the object to return the userdata for\n */\nJSON_EXPORT void *json_object_get_userdata(json_object *jso);\n\n/**\n * Set an opaque userdata value for an object\n *\n * The userdata can be retrieved using json_object_get_userdata().\n *\n * If custom userdata is already set on this object, any existing user_delete\n * function is called before the new one is set.\n *\n * The user_delete parameter is optional and may be passed as NULL, even if\n * the userdata parameter is non-NULL.  It will be called just before the\n * json_object is deleted, after it's reference count goes to zero\n * (see json_object_put()).\n * If this is not provided, it is up to the caller to free the userdata at\n * an appropriate time. (i.e. after the json_object is deleted)\n *\n * Note: Objects created by parsing strings may have custom serializers set\n * which expect the userdata to contain specific data (due to use of\n * json_object_new_double_s()). In this case, json_object_set_serialiser() with\n * NULL as to_string_func should be used instead to set the userdata and reset\n * the serializer to its default value.\n *\n * @param jso the object to set the userdata for\n * @param userdata an optional opaque cookie\n * @param user_delete an optional function from freeing userdata\n */\nJSON_EXPORT void json_object_set_userdata(json_object *jso, void *userdata,\n                                          json_object_delete_fn *user_delete);\n\n/**\n * Set a custom serialization function to be used when this particular object\n * is converted to a string by json_object_to_json_string.\n *\n * If custom userdata is already set on this object, any existing user_delete\n * function is called before the new one is set.\n *\n * If to_string_func is NULL the default behaviour is reset (but the userdata\n * and user_delete fields are still set).\n *\n * The userdata parameter is optional and may be passed as NULL. It can be used\n * to provide additional data for to_string_func to use. This parameter may\n * be NULL even if user_delete is non-NULL.\n *\n * The user_delete parameter is optional and may be passed as NULL, even if\n * the userdata parameter is non-NULL.  It will be called just before the\n * json_object is deleted, after it's reference count goes to zero\n * (see json_object_put()).\n * If this is not provided, it is up to the caller to free the userdata at\n * an appropriate time. (i.e. after the json_object is deleted)\n *\n * Note that the userdata is the same as set by json_object_set_userdata(), so\n * care must be taken not to overwrite the value when both a custom serializer\n * and json_object_set_userdata() are used.\n *\n * @param jso the object to customize\n * @param to_string_func the custom serialization function\n * @param userdata an optional opaque cookie\n * @param user_delete an optional function from freeing userdata\n */\nJSON_EXPORT void json_object_set_serializer(json_object *jso,\n                                            json_object_to_json_string_fn *to_string_func,\n                                            void *userdata, json_object_delete_fn *user_delete);\n\n#ifdef __clang__\n/*\n * Clang doesn't pay attention to the parameters defined in the\n * function typedefs used here, so turn off spurious doc warnings.\n * {\n */\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n\n/**\n * Simply call free on the userdata pointer.\n * Can be used with json_object_set_serializer().\n *\n * @param jso unused\n * @param userdata the pointer that is passed to free().\n */\nJSON_EXPORT json_object_delete_fn json_object_free_userdata;\n\n/**\n * Copy the jso->_userdata string over to pb as-is.\n * Can be used with json_object_set_serializer().\n *\n * @param jso The object whose _userdata is used.\n * @param pb The destination buffer.\n * @param level Ignored.\n * @param flags Ignored.\n */\nJSON_EXPORT json_object_to_json_string_fn json_object_userdata_to_json_string;\n\n#ifdef __clang__\n/* } */\n#pragma clang diagnostic pop\n#endif\n\n/* object type methods */\n\n/** Create a new empty object with a reference count of 1.  The caller of\n * this object initially has sole ownership.  Remember, when using\n * json_object_object_add or json_object_array_put_idx, ownership will\n * transfer to the object/array.  Call json_object_get if you want to maintain\n * shared ownership or also add this object as a child of multiple objects or\n * arrays.  Any ownerships you acquired but did not transfer must be released\n * through json_object_put.\n *\n * @returns a json_object of type json_type_object\n */\nJSON_EXPORT struct json_object *json_object_new_object(void);\n\n/** Get the hashtable of a json_object of type json_type_object\n * @param obj the json_object instance\n * @returns a linkhash\n */\nJSON_EXPORT struct lh_table *json_object_get_object(const struct json_object *obj);\n\n/** Get the size of an object in terms of the number of fields it has.\n * @param obj the json_object whose length to return\n */\nJSON_EXPORT int json_object_object_length(const struct json_object *obj);\n\n/** Get the sizeof (struct json_object).\n * @returns a size_t with the sizeof (struct json_object)\n */\nJSON_C_CONST_FUNCTION(JSON_EXPORT size_t json_c_object_sizeof(void));\n\n/** Add an object field to a json_object of type json_type_object\n *\n * The reference count of `val` will *not* be incremented, in effect\n * transferring ownership that object to `obj`, and thus `val` will be\n * freed when `obj` is.  (i.e. through `json_object_put(obj)`)\n *\n * If you want to retain a reference to the added object, independent\n * of the lifetime of obj, you must increment the refcount with\n * `json_object_get(val)` (and later release it with json_object_put()).\n *\n * Since ownership transfers to `obj`, you must make sure\n * that you do in fact have ownership over `val`.  For instance,\n * json_object_new_object() will give you ownership until you transfer it,\n * whereas json_object_object_get() does not.\n *\n * Any previous object stored under `key` in `obj` will have its refcount\n * decremented, and be freed normally if that drops to zero.\n *\n * @param obj the json_object instance\n * @param key the object field name (a private copy will be duplicated)\n * @param val a json_object or NULL member to associate with the given field\n *\n * @return On success, <code>0</code> is returned.\n * \tOn error, a negative value is returned.\n */\nJSON_EXPORT int json_object_object_add(struct json_object *obj, const char *key,\n                                       struct json_object *val);\n\n/** Add an object field to a json_object of type json_type_object\n *\n * The semantics are identical to json_object_object_add, except that an\n * additional flag fields gives you more control over some detail aspects\n * of processing. See the description of JSON_C_OBJECT_ADD_* flags for more\n * details.\n *\n * @param obj the json_object instance\n * @param key the object field name (a private copy will be duplicated)\n * @param val a json_object or NULL member to associate with the given field\n * @param opts process-modifying options. To specify multiple options, use\n *             (OPT1|OPT2)\n */\nJSON_EXPORT int json_object_object_add_ex(struct json_object *obj, const char *const key,\n                                          struct json_object *const val, const unsigned opts);\n\n/** Get the json_object associate with a given object field.\n * Deprecated/discouraged: used json_object_object_get_ex instead.\n *\n * This returns NULL if the field is found but its value is null, or if\n *  the field is not found, or if obj is not a json_type_object.  If you\n *  need to distinguish between these cases, use json_object_object_get_ex().\n *\n * *No* reference counts will be changed.  There is no need to manually adjust\n * reference counts through the json_object_put/json_object_get methods unless\n * you need to have the child (value) reference maintain a different lifetime\n * than the owning parent (obj). Ownership of the returned value is retained\n * by obj (do not do json_object_put unless you have done a json_object_get).\n * If you delete the value from obj (json_object_object_del) and wish to access\n * the returned reference afterwards, make sure you have first gotten shared\n * ownership through json_object_get (& don't forget to do a json_object_put\n * or transfer ownership to prevent a memory leak).\n *\n * @param obj the json_object instance\n * @param key the object field name\n * @returns the json_object associated with the given field name\n */\nJSON_EXPORT struct json_object *json_object_object_get(const struct json_object *obj,\n                                                       const char *key);\n\n/** Get the json_object associated with a given object field.\n *\n * This returns true if the key is found, false in all other cases (including\n * if obj isn't a json_type_object).\n *\n * *No* reference counts will be changed.  There is no need to manually adjust\n * reference counts through the json_object_put/json_object_get methods unless\n * you need to have the child (value) reference maintain a different lifetime\n * than the owning parent (obj).  Ownership of value is retained by obj.\n *\n * @param obj the json_object instance\n * @param key the object field name\n * @param value a pointer where to store a reference to the json_object\n *              associated with the given field name.\n *\n *              It is safe to pass a NULL value.\n * @returns 1 if the key exists, 0 otherwise\n */\nJSON_EXPORT int json_object_object_get_ex(const struct json_object *obj, const char *key,\n                                                struct json_object **value);\n\n/** Delete the given json_object field\n *\n * The reference count will be decremented for the deleted object.  If there\n * are no more owners of the value represented by this key, then the value is\n * freed.  Otherwise, the reference to the value will remain in memory.\n *\n * @param obj the json_object instance\n * @param key the object field name\n */\nJSON_EXPORT void json_object_object_del(struct json_object *obj, const char *key);\n\n/**\n * Iterate through all keys and values of an object.\n *\n * Adding keys to the object while iterating is NOT allowed.\n *\n * Deleting an existing key, or replacing an existing key with a\n * new value IS allowed.\n *\n * @param obj the json_object instance\n * @param key the local name for the char* key variable defined in the body\n * @param val the local name for the json_object* object variable defined in\n *            the body\n */\n#if defined(__GNUC__) && !defined(__STRICT_ANSI__) && (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)\n\n#define json_object_object_foreach(obj, key, val)                                \\\n\tchar *key = NULL;                                                        \\\n\tstruct json_object *val __attribute__((__unused__)) = NULL;              \\\n\tfor (struct lh_entry *entry##key = lh_table_head(json_object_get_object(obj)),    \\\n\t                     *entry_next##key = NULL;                            \\\n\t     ({                                                                  \\\n\t\t     if (entry##key)                                             \\\n\t\t     {                                                           \\\n\t\t\t     key = (char *)lh_entry_k(entry##key);               \\\n\t\t\t     val = (struct json_object *)lh_entry_v(entry##key); \\\n\t\t\t     entry_next##key = lh_entry_next(entry##key);        \\\n\t\t     };                                                          \\\n\t\t     entry##key;                                                 \\\n\t     });                                                                 \\\n\t     entry##key = entry_next##key)\n\n#else /* ANSI C or MSC */\n\n#define json_object_object_foreach(obj, key, val)                              \\\n\tchar *key = NULL;                                                      \\\n\tstruct json_object *val = NULL;                                        \\\n\tstruct lh_entry *entry##key;                                           \\\n\tstruct lh_entry *entry_next##key = NULL;                               \\\n\tfor (entry##key = lh_table_head(json_object_get_object(obj));          \\\n\t     (entry##key ? (key = (char *)lh_entry_k(entry##key),              \\\n\t                   val = (struct json_object *)lh_entry_v(entry##key), \\\n\t                   entry_next##key = lh_entry_next(entry##key), entry##key)     \\\n\t                 : 0);                                                 \\\n\t     entry##key = entry_next##key)\n\n#endif /* defined(__GNUC__) && !defined(__STRICT_ANSI__) && (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) */\n\n/** Iterate through all keys and values of an object (ANSI C Safe)\n * @param obj the json_object instance\n * @param iter the object iterator, use type json_object_iter\n */\n#define json_object_object_foreachC(obj, iter)                                                  \\\n\tfor (iter.entry = lh_table_head(json_object_get_object(obj));                                    \\\n\t     (iter.entry ? (iter.key = (char *)lh_entry_k(iter.entry),                          \\\n\t                   iter.val = (struct json_object *)lh_entry_v(iter.entry), iter.entry) \\\n\t                 : 0);                                                                  \\\n\t     iter.entry = lh_entry_next(iter.entry))\n\n/* Array type methods */\n\n/** Create a new empty json_object of type json_type_array\n * with 32 slots allocated.\n * If you know the array size you'll need ahead of time, use\n * json_object_new_array_ext() instead.\n * @see json_object_new_array_ext()\n * @see json_object_array_shrink()\n * @returns a json_object of type json_type_array\n */\nJSON_EXPORT struct json_object *json_object_new_array(void);\n\n/** Create a new empty json_object of type json_type_array\n * with the desired number of slots allocated.\n * @see json_object_array_shrink()\n * @param initial_size the number of slots to allocate\n * @returns a json_object of type json_type_array\n */\nJSON_EXPORT struct json_object *json_object_new_array_ext(int initial_size);\n\n/** Get the arraylist of a json_object of type json_type_array\n * @param obj the json_object instance\n * @returns an arraylist\n */\nJSON_EXPORT struct array_list *json_object_get_array(const struct json_object *obj);\n\n/** Get the length of a json_object of type json_type_array\n * @param obj the json_object instance\n * @returns the length of the array\n */\nJSON_EXPORT size_t json_object_array_length(const struct json_object *obj);\n\n/** Sorts the elements of jso of type json_type_array\n*\n* Pointers to the json_object pointers will be passed as the two arguments\n* to sort_fn\n*\n* @param jso the json_object instance\n* @param sort_fn a sorting function\n*/\nJSON_EXPORT void json_object_array_sort(struct json_object *jso,\n                                        int (*sort_fn)(const void *, const void *));\n\n/** Binary search a sorted array for a specified key object.\n *\n * It depends on your compare function what's sufficient as a key.\n * Usually you create some dummy object with the parameter compared in\n * it, to identify the right item you're actually looking for.\n *\n * @see json_object_array_sort() for hints on the compare function.\n *\n * @param key a dummy json_object with the right key\n * @param jso the array object we're searching\n * @param sort_fn the sort/compare function\n *\n * @return the wanted json_object instance\n */\nJSON_EXPORT struct json_object *\njson_object_array_bsearch(const struct json_object *key, const struct json_object *jso,\n                          int (*sort_fn)(const void *, const void *));\n\n/** Add an element to the end of a json_object of type json_type_array\n *\n * The reference count will *not* be incremented. This is to make adding\n * fields to objects in code more compact. If you want to retain a reference\n * to an added object you must wrap the passed object with json_object_get\n *\n * @param obj the json_object instance\n * @param val the json_object to be added\n */\nJSON_EXPORT int json_object_array_add(struct json_object *obj, struct json_object *val);\n\n/** Insert or replace an element at a specified index in an array (a json_object of type json_type_array)\n *\n * The reference count will *not* be incremented. This is to make adding\n * fields to objects in code more compact. If you want to retain a reference\n * to an added object you must wrap the passed object with json_object_get\n *\n * The reference count of a replaced object will be decremented.\n *\n * The array size will be automatically be expanded to the size of the\n * index if the index is larger than the current size.\n *\n * @param obj the json_object instance\n * @param idx the index to insert the element at\n * @param val the json_object to be added\n */\nJSON_EXPORT int json_object_array_put_idx(struct json_object *obj, size_t idx,\n                                          struct json_object *val);\n\n/** Insert an element at a specified index in an array (a json_object of type json_type_array)\n *\n * The reference count will *not* be incremented. This is to make adding\n * fields to objects in code more compact. If you want to retain a reference\n * to an added object you must wrap the passed object with json_object_get\n *\n * The array size will be automatically be expanded to the size of the\n * index if the index is larger than the current size.\n * If the index is within the existing array limits, then the element will be\n * inserted and all elements will be shifted. This is the only difference between\n * this function and json_object_array_put_idx().\n *\n * @param obj the json_object instance\n * @param idx the index to insert the element at\n * @param val the json_object to be added\n */\nJSON_EXPORT int json_object_array_insert_idx(struct json_object *obj, size_t idx,\n                                             struct json_object *val);\n\n/** Get the element at specified index of array `obj` (which must be a json_object of type json_type_array)\n *\n * *No* reference counts will be changed, and ownership of the returned\n * object remains with `obj`.  See json_object_object_get() for additional\n * implications of this behavior.\n *\n * Calling this with anything other than a json_type_array will trigger\n * an assert.\n *\n * @param obj the json_object instance\n * @param idx the index to get the element at\n * @returns the json_object at the specified index (or NULL)\n */\nJSON_EXPORT struct json_object *json_object_array_get_idx(const struct json_object *obj,\n                                                          size_t idx);\n\n/** Delete an elements from a specified index in an array (a json_object of type json_type_array)\n *\n * The reference count will be decremented for each of the deleted objects.  If there\n * are no more owners of an element that is being deleted, then the value is\n * freed.  Otherwise, the reference to the value will remain in memory.\n *\n * @param obj the json_object instance\n * @param idx the index to start deleting elements at\n * @param count the number of elements to delete\n * @returns 0 if the elements were successfully deleted\n */\nJSON_EXPORT int json_object_array_del_idx(struct json_object *obj, size_t idx, size_t count);\n\n/**\n * Shrink the internal memory allocation of the array to just\n * enough to fit the number of elements in it, plus empty_slots.\n *\n * @param jso the json_object instance, must be json_type_array\n * @param empty_slots the number of empty slots to leave allocated\n */\nJSON_EXPORT int json_object_array_shrink(struct json_object *jso, int empty_slots);\n\n/* json_bool type methods */\n\n/** Create a new empty json_object of type json_type_boolean\n * @param b a json_bool 1 or 0\n * @returns a json_object of type json_type_boolean\n */\nJSON_EXPORT struct json_object *json_object_new_boolean(json_bool b);\n\n/** Get the json_bool value of a json_object\n *\n * The type is coerced to a json_bool if the passed object is not a json_bool.\n * integer and double objects will return 0 if there value is zero\n * or 1 otherwise. If the passed object is a string it will return\n * 1 if it has a non zero length.\n * If any other object type is passed 0 will be returned, even non-empty\n *  json_type_array and json_type_object objects.\n *\n * @param obj the json_object instance\n * @returns a json_bool\n */\nJSON_EXPORT json_bool json_object_get_boolean(const struct json_object *obj);\n\n/** Set the json_bool value of a json_object\n *\n * The type of obj is checked to be a json_type_boolean and 0 is returned\n * if it is not without any further actions. If type of obj is json_type_boolean\n * the object value is changed to new_value\n *\n * @param obj the json_object instance\n * @param new_value the value to be set\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_boolean(struct json_object *obj, json_bool new_value);\n\n/* int type methods */\n\n/** Create a new empty json_object of type json_type_int\n * Note that values are stored as 64-bit values internally.\n * To ensure the full range is maintained, use json_object_new_int64 instead.\n * @param i the integer\n * @returns a json_object of type json_type_int\n */\nJSON_EXPORT struct json_object *json_object_new_int(int32_t i);\n\n/** Create a new empty json_object of type json_type_int\n * @param i the integer\n * @returns a json_object of type json_type_int\n */\nJSON_EXPORT struct json_object *json_object_new_int64(int64_t i);\n\n/** Create a new empty json_object of type json_type_uint\n * @param i the integer\n * @returns a json_object of type json_type_uint\n */\nJSON_EXPORT struct json_object *json_object_new_uint64(uint64_t i);\n\n/** Get the int value of a json_object\n *\n * The type is coerced to a int if the passed object is not a int.\n * double objects will return their integer conversion except for NaN values\n * which return INT32_MIN and the errno is set to EINVAL.\n * Strings will be parsed as an integer. If no conversion exists then 0 is\n * returned and errno is set to EINVAL. null is equivalent to 0 (no error values\n * set).\n * Sets errno to ERANGE if the value exceeds the range of int.\n *\n * Note that integers are stored internally as 64-bit values.\n * If the value of too big or too small to fit into 32-bit, INT32_MAX or\n * INT32_MIN are returned, respectively.\n *\n * @param obj the json_object instance\n * @returns an int\n */\nJSON_EXPORT int32_t json_object_get_int(const struct json_object *obj);\n\n/** Set the int value of a json_object\n *\n * The type of obj is checked to be a json_type_int and 0 is returned\n * if it is not without any further actions. If type of obj is json_type_int\n * the object value is changed to new_value\n *\n * @param obj the json_object instance\n * @param new_value the value to be set\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_int(struct json_object *obj, int new_value);\n\n/** Increment a json_type_int object by the given amount, which may be negative.\n *\n * If the type of obj is not json_type_int then 0 is returned with no further\n * action taken.\n * If the addition would result in a overflow, the object value\n * is set to INT64_MAX.\n * If the addition would result in a underflow, the object value\n * is set to INT64_MIN.\n * Neither overflow nor underflow affect the return value.\n *\n * @param obj the json_object instance\n * @param val the value to add\n * @returns 1 if the increment succeeded, 0 otherwise\n */\nJSON_EXPORT int json_object_int_inc(struct json_object *obj, int64_t val);\n\n/** Get the int value of a json_object\n *\n * The type is coerced to a int64 if the passed object is not a int64.\n * double objects will return their int64 conversion except for NaN values\n * which return INT64_MIN and the errno is set to EINVAL.\n * Strings will be parsed as an int64. If no conversion exists then 0 is\n * returned and errno is set to EINVAL. null is equivalent to 0 (no error values\n * set).\n * Sets errno to ERANGE if the value exceeds the range of int64.\n *\n * NOTE: Set errno to 0 directly before a call to this function to determine\n * whether or not conversion was successful (it does not clear the value for\n * you).\n *\n * @param obj the json_object instance\n * @returns an int64\n */\nJSON_EXPORT int64_t json_object_get_int64(const struct json_object *obj);\n\n/** Get the uint value of a json_object\n *\n * The type is coerced to a uint64 if the passed object is not a uint64.\n * double objects will return their uint64 conversion except for NaN values\n * which return 0 and the errno is set to EINVAL.\n * Strings will be parsed as an uint64. If no conversion exists then 0 is\n * returned and errno is set to EINVAL. null is equivalent to 0 (no error values\n * set).\n * Sets errno to ERANGE if the value exceeds the range of uint64.\n *\n * NOTE: Set errno to 0 directly before a call to this function to determine\n * whether or not conversion was successful (it does not clear the value for\n * you).\n *\n * @param obj the json_object instance\n * @returns an uint64\n */\nJSON_EXPORT uint64_t json_object_get_uint64(const struct json_object *obj);\n\n/** Set the int64_t value of a json_object\n *\n * The type of obj is checked to be a json_type_int and 0 is returned\n * if it is not without any further actions. If type of obj is json_type_int\n * the object value is changed to new_value\n *\n * @param obj the json_object instance\n * @param new_value the value to be set\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_int64(struct json_object *obj, int64_t new_value);\n\n/** Set the uint64_t value of a json_object\n *\n * The type of obj is checked to be a json_type_uint and 0 is returned\n * if it is not without any further actions. If type of obj is json_type_uint\n * the object value is changed to new_value\n *\n * @param obj the json_object instance\n * @param new_value the value to be set\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_uint64(struct json_object *obj, uint64_t new_value);\n\n/* double type methods */\n\n/** Create a new empty json_object of type json_type_double\n *\n * @see json_object_double_to_json_string() for how to set a custom format string.\n *\n * @param d the double\n * @returns a json_object of type json_type_double\n */\nJSON_EXPORT struct json_object *json_object_new_double(double d);\n\n/**\n * Create a new json_object of type json_type_double, using\n * the exact serialized representation of the value.\n *\n * This allows for numbers that would otherwise get displayed\n * inefficiently (e.g. 12.3 => \"12.300000000000001\") to be\n * serialized with the more convenient form.\n *\n * Notes:\n *\n * This is used by json_tokener_parse_ex() to allow for\n * an exact re-serialization of a parsed object.\n *\n * The userdata field is used to store the string representation, so it\n * can't be used for other data if this function is used.\n *\n * A roughly equivalent sequence of calls, with the difference being that\n *  the serialization function won't be reset by json_object_set_double(), is:\n * @code\n *   jso = json_object_new_double(d);\n *   json_object_set_serializer(jso, json_object_userdata_to_json_string,\n *       strdup(ds), json_object_free_userdata);\n * @endcode\n *\n * @param d the numeric value of the double.\n * @param ds the string representation of the double.  This will be copied.\n */\nJSON_EXPORT struct json_object *json_object_new_double_s(double d, const char *ds);\n\n/**\n * Set a global or thread-local json-c option, depending on whether\n *  JSON_C_OPTION_GLOBAL or JSON_C_OPTION_THREAD is passed.\n * Thread-local options default to undefined, and inherit from the global\n *  value, even if the global value is changed after the thread is created.\n * Attempting to set thread-local options when threading is not compiled in\n *  will result in an error.  Be sure to check the return value.\n *\n * double_format is a \"%g\" printf format, such as \"%.20g\"\n *\n * @return -1 on errors, 0 on success.\n */\nJSON_EXPORT int json_c_set_serialization_double_format(const char *double_format,\n                                                       int global_or_thread);\n\n/** Serialize a json_object of type json_type_double to a string.\n *\n * This function isn't meant to be called directly. Instead, you can set a\n * custom format string for the serialization of this double using the\n * following call (where \"%.17g\" actually is the default):\n *\n * @code\n *   jso = json_object_new_double(d);\n *   json_object_set_serializer(jso, json_object_double_to_json_string,\n *       \"%.17g\", NULL);\n * @endcode\n *\n * @see printf(3) man page for format strings\n *\n * @param jso The json_type_double object that is serialized.\n * @param pb The destination buffer.\n * @param level Ignored.\n * @param flags Ignored.\n */\nJSON_EXPORT int json_object_double_to_json_string(struct json_object *jso, struct printbuf *pb,\n                                                  int level, int flags);\n\n/** Get the double floating point value of a json_object\n *\n * The type is coerced to a double if the passed object is not a double.\n * integer objects will return their double conversion. Strings will be\n * parsed as a double. If no conversion exists then 0.0 is returned and\n * errno is set to EINVAL. null is equivalent to 0 (no error values set)\n *\n * If the value is too big to fit in a double, then the value is set to\n * the closest infinity with errno set to ERANGE. If strings cannot be\n * converted to their double value, then EINVAL is set & NaN is returned.\n *\n * Arrays of length 0 are interpreted as 0 (with no error flags set).\n * Arrays of length 1 are effectively cast to the equivalent object and\n * converted using the above rules.  All other arrays set the error to\n * EINVAL & return NaN.\n *\n * NOTE: Set errno to 0 directly before a call to this function to\n * determine whether or not conversion was successful (it does not clear\n * the value for you).\n *\n * @param obj the json_object instance\n * @returns a double floating point number\n */\nJSON_EXPORT double json_object_get_double(const struct json_object *obj);\n\n/** Set the double value of a json_object\n *\n * The type of obj is checked to be a json_type_double and 0 is returned\n * if it is not without any further actions. If type of obj is json_type_double\n * the object value is changed to new_value\n *\n * If the object was created with json_object_new_double_s(), the serialization\n * function is reset to the default and the cached serialized value is cleared.\n *\n * @param obj the json_object instance\n * @param new_value the value to be set\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_double(struct json_object *obj, double new_value);\n\n/* string type methods */\n\n/** Create a new empty json_object of type json_type_string\n *\n * A copy of the string is made and the memory is managed by the json_object\n *\n * @param s the string\n * @returns a json_object of type json_type_string\n * @see json_object_new_string_len()\n */\nJSON_EXPORT struct json_object *json_object_new_string(const char *s);\n\n/** Create a new empty json_object of type json_type_string and allocate\n * len characters for the new string.\n *\n * A copy of the string is made and the memory is managed by the json_object\n *\n * @param s the string\n * @param len max length of the new string\n * @returns a json_object of type json_type_string\n * @see json_object_new_string()\n */\nJSON_EXPORT struct json_object *json_object_new_string_len(const char *s, const int len);\n\n/** Get the string value of a json_object\n *\n * If the passed object is of type json_type_null (i.e. obj == NULL),\n * NULL is returned.\n *\n * If the passed object of type json_type_string, the string contents\n * are returned.\n *\n * Otherwise the JSON representation of the object is returned.\n *\n * The returned string memory is managed by the json_object and will\n * be freed when the reference count of the json_object drops to zero.\n *\n * @param obj the json_object instance\n * @returns a string or NULL\n */\nJSON_EXPORT const char *json_object_get_string(struct json_object *obj);\n\n/** Get the string length of a json_object\n *\n * If the passed object is not of type json_type_string then zero\n * will be returned.\n *\n * @param obj the json_object instance\n * @returns int\n */\nJSON_EXPORT int json_object_get_string_len(const struct json_object *obj);\n\n/** Set the string value of a json_object with zero terminated strings\n * equivalent to json_object_set_string_len (obj, new_value, strlen(new_value))\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_string(json_object *obj, const char *new_value);\n\n/** Set the string value of a json_object str\n *\n * The type of obj is checked to be a json_type_string and 0 is returned\n * if it is not without any further actions. If type of obj is json_type_string\n * the object value is changed to new_value\n *\n * @param obj the json_object instance\n * @param new_value the value to be set; Since string length is given in len this need not be zero terminated\n * @param len the length of new_value\n * @returns 1 if value is set correctly, 0 otherwise\n */\nJSON_EXPORT int json_object_set_string_len(json_object *obj, const char *new_value, int len);\n\n/** This method exists only to provide a complementary function\n * along the lines of the other json_object_new_* functions.\n * It always returns NULL, and it is entirely acceptable to simply use NULL directly.\n */\nJSON_EXPORT struct json_object *json_object_new_null(void);\n\n/** Check if two json_object's are equal\n *\n * If the passed objects are equal 1 will be returned.\n * Equality is defined as follows:\n * - json_objects of different types are never equal\n * - json_objects of the same primitive type are equal if the\n *   c-representation of their value is equal\n * - json-arrays are considered equal if all values at the same\n *   indices are equal (same order)\n * - Complex json_objects are considered equal if all\n *   contained objects referenced by their key are equal,\n *   regardless their order.\n *\n * @param obj1 the first json_object instance\n * @param obj2 the second json_object instance\n * @returns 1 if both objects are equal, 0 otherwise\n */\nJSON_EXPORT int json_object_equal(struct json_object *obj1, struct json_object *obj2);\n\n/**\n * Perform a shallow copy of src into *dst as part of an overall json_object_deep_copy().\n *\n * If src is part of a containing object or array, parent will be non-NULL,\n * and key or index will be provided.\n * When shallow_copy is called *dst will be NULL, and must be non-NULL when it returns.\n * src will never be NULL.\n *\n * If shallow_copy sets the serializer on an object, return 2 to indicate to\n *  json_object_deep_copy that it should not attempt to use the standard userdata\n *  copy function.\n *\n * @return On success 1 or 2, -1 on errors\n */\ntypedef int(json_c_shallow_copy_fn)(json_object *src, json_object *parent, const char *key,\n                                    size_t index, json_object **dst);\n\n/**\n * The default shallow copy implementation for use with json_object_deep_copy().\n * This simply calls the appropriate json_object_new_<type>() function and\n * copies over the serializer function (_to_json_string internal field of\n * the json_object structure) but not any _userdata or _user_delete values.\n *\n * If you're writing a custom shallow_copy function, perhaps because you're using\n * your own custom serializer, you can call this first to create the new object\n * before customizing it with json_object_set_serializer().\n *\n * @return 1 on success, -1 on errors, but never 2.\n */\nJSON_EXPORT json_c_shallow_copy_fn json_c_shallow_copy_default;\n\n/**\n * Copy the contents of the JSON object.\n * The destination object must be initialized to NULL,\n * to make sure this function won't overwrite an existing JSON object.\n *\n * This does roughly the same thing as\n * `json_tokener_parse(json_object_get_string(src))`.\n *\n * @param src source JSON object whose contents will be copied\n * @param dst pointer to the destination object where the contents of `src`;\n *            make sure this pointer is initialized to NULL\n * @param shallow_copy an optional function to copy individual objects, needed\n *                     when custom serializers are in use.  See also\n *                     json_object set_serializer.\n *\n * @returns 0 if the copy went well, -1 if an error occurred during copy\n *          or if the destination pointer is non-NULL\n */\n\nJSON_EXPORT int json_object_deep_copy(struct json_object *src, struct json_object **dst,\n                                      json_c_shallow_copy_fn *shallow_copy);\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_object_iterator.c",
          "type": "blob",
          "size": 4.470703125,
          "content": "/**\n*******************************************************************************\n* @file json_object_iterator.c\n*\n* Copyright (c) 2009-2012 Hewlett-Packard Development Company, L.P.\n*\n* This library is free software; you can redistribute it and/or modify\n* it under the terms of the MIT license. See COPYING for details.\n*\n*******************************************************************************\n*/\n#include \"config.h\"\n\n#include <stddef.h>\n\n#include \"json.h\"\n#include \"json_object_private.h\"\n\n#include \"json_object_iterator.h\"\n\n/**\n * How It Works\n *\n * For each JSON Object, json-c maintains a linked list of zero\n * or more lh_entry (link-hash entry) structures inside the\n * Object's link-hash table (lh_table).\n *\n * Each lh_entry structure on the JSON Object's linked list\n * represents a single name/value pair.  The \"next\" field of the\n * last lh_entry in the list is set to NULL, which terminates\n * the list.\n *\n * We represent a valid iterator that refers to an actual\n * name/value pair via a pointer to the pair's lh_entry\n * structure set as the iterator's opaque_ field.\n *\n * We follow json-c's current pair list representation by\n * representing a valid \"end\" iterator (one that refers past the\n * last pair) with a NULL value in the iterator's opaque_ field.\n *\n * A JSON Object without any pairs in it will have the \"head\"\n * field of its lh_table structure set to NULL.  For such an\n * object, json_object_iter_begin will return an iterator with\n * the opaque_ field set to NULL, which is equivalent to the\n * \"end\" iterator.\n *\n * When iterating, we simply update the iterator's opaque_ field\n * to point to the next lh_entry structure in the linked list.\n * opaque_ will become NULL once we iterate past the last pair\n * in the list, which makes the iterator equivalent to the \"end\"\n * iterator.\n */\n\n/// Our current representation of the \"end\" iterator;\n///\n/// @note May not always be NULL\nstatic const void *kObjectEndIterValue = NULL;\n\n/**\n * ****************************************************************************\n */\nstruct json_object_iterator json_object_iter_begin(struct json_object *obj)\n{\n\tstruct json_object_iterator iter;\n\tstruct lh_table *pTable;\n\n\t/// @note json_object_get_object will return NULL if passed NULL\n\t///       or a non-json_type_object instance\n\tpTable = json_object_get_object(obj);\n\tJASSERT(NULL != pTable);\n\n\t/// @note For a pair-less Object, head is NULL, which matches our\n\t///       definition of the \"end\" iterator\n\titer.opaque_ = lh_table_head(pTable);\n\treturn iter;\n}\n\n/**\n * ****************************************************************************\n */\nstruct json_object_iterator json_object_iter_end(const struct json_object *obj)\n{\n\tstruct json_object_iterator iter;\n\n\tJASSERT(NULL != obj);\n\tJASSERT(json_object_is_type(obj, json_type_object));\n\n\titer.opaque_ = kObjectEndIterValue;\n\n\treturn iter;\n}\n\n/**\n * ****************************************************************************\n */\nvoid json_object_iter_next(struct json_object_iterator *iter)\n{\n\tJASSERT(NULL != iter);\n\tJASSERT(kObjectEndIterValue != iter->opaque_);\n\n\titer->opaque_ = lh_entry_next(((const struct lh_entry *)iter->opaque_));\n}\n\n/**\n * ****************************************************************************\n */\nconst char *json_object_iter_peek_name(const struct json_object_iterator *iter)\n{\n\tJASSERT(NULL != iter);\n\tJASSERT(kObjectEndIterValue != iter->opaque_);\n\n\treturn (const char *)(((const struct lh_entry *)iter->opaque_)->k);\n}\n\n/**\n * ****************************************************************************\n */\nstruct json_object *json_object_iter_peek_value(const struct json_object_iterator *iter)\n{\n\tJASSERT(NULL != iter);\n\tJASSERT(kObjectEndIterValue != iter->opaque_);\n\n\treturn (struct json_object *)lh_entry_v((const struct lh_entry *)iter->opaque_);\n}\n\n/**\n * ****************************************************************************\n */\njson_bool json_object_iter_equal(const struct json_object_iterator *iter1,\n                                 const struct json_object_iterator *iter2)\n{\n\tJASSERT(NULL != iter1);\n\tJASSERT(NULL != iter2);\n\n\treturn (iter1->opaque_ == iter2->opaque_);\n}\n\n/**\n * ****************************************************************************\n */\nstruct json_object_iterator json_object_iter_init_default(void)\n{\n\tstruct json_object_iterator iter;\n\n\t/**\n\t * @note Make this a negative, invalid value, such that\n\t *       accidental access to it would likely be trapped by the\n\t *       hardware as an invalid address.\n\t */\n\titer.opaque_ = NULL;\n\n\treturn iter;\n}\n"
        },
        {
          "name": "json_object_iterator.h",
          "type": "blob",
          "size": 8.197265625,
          "content": "/**\n*******************************************************************************\n* @file json_object_iterator.h\n*\n* Copyright (c) 2009-2012 Hewlett-Packard Development Company, L.P.\n*\n* This library is free software; you can redistribute it and/or modify\n* it under the terms of the MIT license. See COPYING for details.\n*\n* @brief  An API for iterating over json_type_object objects,\n*         styled to be familiar to C++ programmers.\n*         Unlike json_object_object_foreach() and\n*         json_object_object_foreachC(), this avoids the need to expose\n*         json-c internals like lh_entry.\n*\n* API attributes: <br>\n*   * Thread-safe: NO<br>\n*   * Reentrant: NO\n*\n*******************************************************************************\n*/\n\n#ifndef JSON_OBJECT_ITERATOR_H\n#define JSON_OBJECT_ITERATOR_H\n\n#include \"json_types.h\"\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * Forward declaration for the opaque iterator information.\n */\nstruct json_object_iter_info_;\n\n/**\n * The opaque iterator that references a name/value pair within\n * a JSON Object instance or the \"end\" iterator value.\n */\nstruct json_object_iterator\n{\n\tconst void *opaque_;\n};\n\n/**\n * forward declaration of json-c's JSON value instance structure\n */\nstruct json_object;\n\n/**\n * Initializes an iterator structure to a \"default\" value that\n * is convenient for initializing an iterator variable to a\n * default state (e.g., initialization list in a class'\n * constructor).\n *\n * @code\n * struct json_object_iterator iter = json_object_iter_init_default();\n * MyClass() : iter_(json_object_iter_init_default())\n * @endcode\n *\n * @note The initialized value doesn't reference any specific\n *       pair, is considered an invalid iterator, and MUST NOT\n *       be passed to any json-c API that expects a valid\n *       iterator.\n *\n * @note User and internal code MUST NOT make any assumptions\n *       about and dependencies on the value of the \"default\"\n *       iterator value.\n *\n * @return json_object_iterator\n */\nJSON_EXPORT struct json_object_iterator json_object_iter_init_default(void);\n\n/** Retrieves an iterator to the first pair of the JSON Object.\n *\n * @warning \tAny modification of the underlying pair invalidates all\n * \t\titerators to that pair.\n *\n * @param obj\tJSON Object instance (MUST be of type json_object)\n *\n * @return json_object_iterator If the JSON Object has at\n *              least one pair, on return, the iterator refers\n *              to the first pair. If the JSON Object doesn't\n *              have any pairs, the returned iterator is\n *              equivalent to the \"end\" iterator for the same\n *              JSON Object instance.\n *\n * @code\n * struct json_object_iterator it;\n * struct json_object_iterator itEnd;\n * struct json_object* obj;\n *\n * obj = json_tokener_parse(\"{'first':'george', 'age':100}\");\n * it = json_object_iter_begin(obj);\n * itEnd = json_object_iter_end(obj);\n *\n * while (!json_object_iter_equal(&it, &itEnd)) {\n *     printf(\"%s\\n\",\n *            json_object_iter_peek_name(&it));\n *     json_object_iter_next(&it);\n * }\n *\n * @endcode\n */\nJSON_EXPORT struct json_object_iterator json_object_iter_begin(struct json_object *obj);\n\n/** Retrieves the iterator that represents the position beyond the\n *  last pair of the given JSON Object instance.\n *\n *  @warning Do NOT write code that assumes that the \"end\"\n *        iterator value is NULL, even if it is so in a\n *        particular instance of the implementation.\n *\n *  @note The reason we do not (and MUST NOT) provide\n *        \"json_object_iter_is_end(json_object_iterator* iter)\"\n *        type of API is because it would limit the underlying\n *        representation of name/value containment (or force us\n *        to add additional, otherwise unnecessary, fields to\n *        the iterator structure). The \"end\" iterator and the\n *        equality test method, on the other hand, permit us to\n *        cleanly abstract pretty much any reasonable underlying\n *        representation without burdening the iterator\n *        structure with unnecessary data.\n *\n *  @note For performance reasons, memorize the \"end\" iterator prior\n *        to any loop.\n *\n * @param obj JSON Object instance (MUST be of type json_object)\n *\n * @return json_object_iterator On return, the iterator refers\n *              to the \"end\" of the Object instance's pairs\n *              (i.e., NOT the last pair, but \"beyond the last\n *              pair\" value)\n */\nJSON_EXPORT struct json_object_iterator json_object_iter_end(const struct json_object *obj);\n\n/** Returns an iterator to the next pair, if any\n *\n * @warning\tAny modification of the underlying pair\n *       \tinvalidates all iterators to that pair.\n *\n * @param iter [IN/OUT] Pointer to iterator that references a\n *         name/value pair; MUST be a valid, non-end iterator.\n *         WARNING: bad things will happen if invalid or \"end\"\n *         iterator is passed. Upon return will contain the\n *         reference to the next pair if there is one; if there\n *         are no more pairs, will contain the \"end\" iterator\n *         value, which may be compared against the return value\n *         of json_object_iter_end() for the same JSON Object\n *         instance.\n */\nJSON_EXPORT void json_object_iter_next(struct json_object_iterator *iter);\n\n/** Returns a const pointer to the name of the pair referenced\n *  by the given iterator.\n *\n * @param iter pointer to iterator that references a name/value\n *             pair; MUST be a valid, non-end iterator.\n *\n * @warning\tbad things will happen if an invalid or\n *             \t\"end\" iterator is passed.\n *\n * @return const char* Pointer to the name of the referenced\n *         name/value pair.  The name memory belongs to the\n *         name/value pair, will be freed when the pair is\n *         deleted or modified, and MUST NOT be modified or\n *         freed by the user.\n */\nJSON_EXPORT const char *json_object_iter_peek_name(const struct json_object_iterator *iter);\n\n/** Returns a pointer to the json-c instance representing the\n *  value of the referenced name/value pair, without altering\n *  the instance's reference count.\n *\n * @param iter \tpointer to iterator that references a name/value\n *             \tpair; MUST be a valid, non-end iterator.\n *\n * @warning\tbad things will happen if invalid or\n *             \"end\" iterator is passed.\n *\n * @return struct json_object* Pointer to the json-c value\n *         instance of the referenced name/value pair;  the\n *         value's reference count is not changed by this\n *         function: if you plan to hold on to this json-c node,\n *         take a look at json_object_get() and\n *         json_object_put(). IMPORTANT: json-c API represents\n *         the JSON Null value as a NULL json_object instance\n *         pointer.\n */\nJSON_EXPORT struct json_object *\njson_object_iter_peek_value(const struct json_object_iterator *iter);\n\n/** Tests two iterators for equality.  Typically used to test\n *  for end of iteration by comparing an iterator to the\n *  corresponding \"end\" iterator (that was derived from the same\n *  JSON Object instance).\n *\n *  @note The reason we do not (and MUST NOT) provide\n *        \"json_object_iter_is_end(json_object_iterator* iter)\"\n *        type of API is because it would limit the underlying\n *        representation of name/value containment (or force us\n *        to add additional, otherwise unnecessary, fields to\n *        the iterator structure). The equality test method, on\n *        the other hand, permits us to cleanly abstract pretty\n *        much any reasonable underlying representation.\n *\n * @param iter1 Pointer to first valid, non-NULL iterator\n * @param iter2 POinter to second valid, non-NULL iterator\n *\n * @warning\tif a NULL iterator pointer or an uninitialized\n *       \tor invalid iterator, or iterators derived from\n *       \tdifferent JSON Object instances are passed, bad things\n *       \twill happen!\n *\n * @return json_bool non-zero if iterators are equal (i.e., both\n *         reference the same name/value pair or are both at\n *         \"end\"); zero if they are not equal.\n */\nJSON_EXPORT json_bool json_object_iter_equal(const struct json_object_iterator *iter1,\n                                             const struct json_object_iterator *iter2);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* JSON_OBJECT_ITERATOR_H */\n"
        },
        {
          "name": "json_object_private.h",
          "type": "blob",
          "size": 2.1552734375,
          "content": "/*\n * $Id: json_object_private.h,v 1.4 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n#ifndef _json_object_private_h_\n#define _json_object_private_h_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct json_object;\n#include \"json_inttypes.h\"\n#include \"json_types.h\"\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif /* HAVE_UNISTD_H */\n\n#ifdef _MSC_VER\n#include <BaseTsd.h>\ntypedef SSIZE_T ssize_t;\n#endif\n\n/* json object int type, support extension*/\ntypedef enum json_object_int_type\n{\n\tjson_object_int_type_int64,\n\tjson_object_int_type_uint64\n} json_object_int_type;\n\nstruct json_object\n{\n\tenum json_type o_type;\n\tuint32_t _ref_count;\n\tjson_object_to_json_string_fn *_to_json_string;\n\tstruct printbuf *_pb;\n\tjson_object_delete_fn *_user_delete;\n\tvoid *_userdata;\n\t// Actually longer, always malloc'd as some more-specific type.\n\t// The rest of a struct json_object_${o_type} follows\n};\n\nstruct json_object_object\n{\n\tstruct json_object base;\n\tstruct lh_table *c_object;\n};\nstruct json_object_array\n{\n\tstruct json_object base;\n\tstruct array_list *c_array;\n};\n\nstruct json_object_boolean\n{\n\tstruct json_object base;\n\tjson_bool c_boolean;\n};\nstruct json_object_double\n{\n\tstruct json_object base;\n\tdouble c_double;\n};\nstruct json_object_int\n{\n\tstruct json_object base;\n\tenum json_object_int_type cint_type;\n\tunion\n\t{\n\t\tint64_t c_int64;\n\t\tuint64_t c_uint64;\n\t} cint;\n};\nstruct json_object_string\n{\n\tstruct json_object base;\n\tssize_t len; // Signed b/c negative lengths indicate data is a pointer\n\t// Consider adding an \"alloc\" field here, if json_object_set_string calls\n\t// to expand the length of a string are common operations to perform.\n\tunion\n\t{\n\t\tchar idata[1]; // Immediate data.  Actually longer\n\t\tchar *pdata;   // Only when len < 0\n\t} c_string;\n};\n\nvoid _json_c_set_last_err(const char *err_fmt, ...);\n\nextern const char *json_hex_chars;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_patch.c",
          "type": "blob",
          "size": 9.162109375,
          "content": "/*\n * Copyright (c) 2021 Alexandru Ardelean.\n * Copyright (c) 2023 Eric Hawicz\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"json_patch.h\"\n#include \"json_object_private.h\"\n#include \"json_pointer_private.h\"\n\n#include <limits.h>\n#ifndef SIZE_T_MAX\n#if SIZEOF_SIZE_T == SIZEOF_INT\n#define SIZE_T_MAX UINT_MAX\n#elif SIZEOF_SIZE_T == SIZEOF_LONG\n#define SIZE_T_MAX ULONG_MAX\n#elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG\n#define SIZE_T_MAX ULLONG_MAX\n#else\n#error Unable to determine size of size_t\n#endif\n#endif\n\n#define _set_err(_errval, _errmsg) do { \\\n\tpatch_error->errno_code = (_errval); \\\n\tpatch_error->errmsg = (_errmsg); \\\n\terrno = 0;  /* To avoid confusion */ \\\n} while (0)\n\n#define _set_err_from_ptrget(_errval, _fieldname) do { \\\n\tpatch_error->errno_code = (_errval); \\\n\tpatch_error->errmsg = (_errval) == ENOENT ? \\\n\t\t\"Did not find element referenced by \" _fieldname \" field\" : \\\n\t\t\"Invalid \" _fieldname \" field\"; \\\n\terrno = 0;  /* To avoid confusion */ \\\n} while(0)\n\n/**\n * JavaScript Object Notation (JSON) Patch\n *   RFC 6902 - https://tools.ietf.org/html/rfc6902\n */\n\nstatic int json_patch_apply_test(struct json_object **res,\n                                 struct json_object *patch_elem,\n                                 const char *path, struct json_patch_error *patch_error)\n{\n\tstruct json_object *value1, *value2;\n\n\tif (!json_object_object_get_ex(patch_elem, \"value\", &value1)) {\n\t\t_set_err(EINVAL, \"Patch object does not contain a 'value' field\");\n\t\treturn -1;\n\t}\n\n\tif (json_pointer_get(*res, path, &value2))\n\t{\n\t\t_set_err_from_ptrget(errno, \"path\");\n\t\treturn -1;\n\t}\n\n\tif (!json_object_equal(value1, value2)) {\n\t\t_set_err(ENOENT, \"Value of element referenced by 'path' field did not match 'value' field\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int __json_patch_apply_remove(struct json_pointer_get_result *jpres)\n{\n\tif (json_object_is_type(jpres->parent, json_type_array)) {\n\t\treturn json_object_array_del_idx(jpres->parent, jpres->index_in_parent, 1);\n\t} else if (jpres->parent && jpres->key_in_parent) {\n\t\tjson_object_object_del(jpres->parent, jpres->key_in_parent);\n\t\treturn 0;\n\t} else {\n\t\t// We're removing the root object\n\t\t(void)json_object_put(jpres->obj);\n\t\tjpres->obj = NULL;\n\t\treturn 0;\n\t}\n}\n\nstatic int json_patch_apply_remove(struct json_object **res, const char *path, struct json_patch_error *patch_error)\n{\n\tstruct json_pointer_get_result jpres;\n\tint rc;\n\n\tif (json_pointer_get_internal(*res, path, &jpres))\n\t{\n\t\t_set_err_from_ptrget(errno, \"path\");\n\t\treturn -1;\n\t}\n\n\trc = __json_patch_apply_remove(&jpres);\n\tif (rc < 0)\n\t\t_set_err(EINVAL, \"Unable to remove path referenced by 'path' field\");\n\t// This means we removed and freed the root object, i.e. *res\n\tif (jpres.parent == NULL)\n\t\t*res = NULL;\n\treturn rc;\n}\n\n// callback for json_pointer_set_with_array_cb()\nstatic int json_object_array_insert_idx_cb(struct json_object *parent, size_t idx,\n                                           struct json_object *value, void *priv)\n{\n\tint rc;\n\tint *add = priv;\n\n\tif (idx > json_object_array_length(parent))\n\t{\n\t\t// Note: will propagate back out through json_pointer_set_with_array_cb()\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (*add)\n\t\trc = json_object_array_insert_idx(parent, idx, value);\n\telse\n\t\trc = json_object_array_put_idx(parent, idx, value);\n\tif (rc < 0)\n\t\terrno = EINVAL;\n\treturn rc;\n}\n\nstatic int json_patch_apply_add_replace(struct json_object **res,\n                                        struct json_object *patch_elem,\n                                        const char *path, int add, struct json_patch_error *patch_error)\n{\n\tstruct json_object *value;\n\tint rc;\n\n\tif (!json_object_object_get_ex(patch_elem, \"value\", &value)) {\n\t\t_set_err(EINVAL, \"Patch object does not contain a 'value' field\");\n\t\treturn -1;\n\t}\n\t/* if this is a replace op, then we need to make sure it exists before replacing */\n\tif (!add && json_pointer_get(*res, path, NULL)) {\n\t\t_set_err_from_ptrget(errno, \"path\");\n\t\treturn -1;\n\t}\n\n\trc = json_pointer_set_with_array_cb(res, path, json_object_get(value),\n\t\t\t\t\t    json_object_array_insert_idx_cb, &add);\n\tif (rc)\n\t{\n\t\t_set_err(errno, \"Failed to set value at path referenced by 'path' field\");\n\t\tjson_object_put(value);\n\t}\n\n\treturn rc;\n}\n\n// callback for json_pointer_set_with_array_cb()\nstatic int json_object_array_move_cb(struct json_object *parent, size_t idx,\n                                     struct json_object *value, void *priv)\n{\n\tint rc;\n\tstruct json_pointer_get_result *from = priv;\n\tsize_t len = json_object_array_length(parent);\n\n\t/**\n\t * If it's the same array parent, it means that we removed\n\t * and element from it, so the length is temporarily reduced\n\t * by 1, which means that if we try to move an element to\n\t * the last position, we need to check the current length + 1\n\t */\n\tif (parent == from->parent)\n\t\tlen++;\n\n\tif (idx > len)\n\t{\n\t\t// Note: will propagate back out through json_pointer_set_with_array_cb()\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\trc = json_object_array_insert_idx(parent, idx, value);\n\tif (rc < 0)\n\t\terrno = EINVAL;\n\treturn rc;\n}\n\nstatic int json_patch_apply_move_copy(struct json_object **res,\n                                      struct json_object *patch_elem,\n                                      const char *path, int move, struct json_patch_error *patch_error)\n{\n\tjson_pointer_array_set_cb array_set_cb;\n\tstruct json_pointer_get_result from;\n\tstruct json_object *jfrom;\n\tconst char *from_s;\n\tsize_t from_s_len;\n\tint rc;\n\n\tif (!json_object_object_get_ex(patch_elem, \"from\", &jfrom)) {\n\t\t_set_err(EINVAL, \"Patch does not contain a 'from' field\");\n\t\treturn -1;\n\t}\n\n\tfrom_s = json_object_get_string(jfrom);\n\n\tfrom_s_len = strlen(from_s);\n\tif (strncmp(from_s, path, from_s_len) == 0) {\n\t\t/**\n\t\t * If lengths match, it's a noop, if they don't,\n\t\t * then we're trying to move a parent under a child\n\t\t * which is not allowed as per RFC 6902 section 4.4\n\t\t *   The \"from\" location MUST NOT be a proper prefix of the \"path\"\n\t\t *   location; i.e., a location cannot be moved into one of its children.\n\t\t */\n\t\tif (from_s_len == strlen(path))\n\t\t\treturn 0;\n\t\t_set_err(EINVAL, \"Invalid attempt to move parent under a child\");\n\t\treturn -1;\n\t}\n\n\trc = json_pointer_get_internal(*res, from_s, &from);\n\tif (rc)\n\t{\n\t\t_set_err_from_ptrget(errno, \"from\");\n\t\treturn rc;\n\t}\n\n\t// Note: it's impossible for json_pointer to find the root obj, due\n\t// to the path check above, so from.parent is guaranteed non-NULL\n\tjson_object_get(from.obj);\n\n\tif (!move) {\n\t\tarray_set_cb = json_object_array_insert_idx_cb;\n\t} else {\n\t\trc = __json_patch_apply_remove(&from);\n\t\tif (rc < 0) {\n\t\t\tjson_object_put(from.obj);\n\t\t\treturn rc;\n\t\t}\n\t\tarray_set_cb = json_object_array_move_cb;\n\t}\n\n\trc = json_pointer_set_with_array_cb(res, path, from.obj, array_set_cb, &from);\n\tif (rc)\n\t{\n\t\t_set_err(errno, \"Failed to set value at path referenced by 'path' field\");\n\t\tjson_object_put(from.obj);\n\t}\n\n\treturn rc;\n}\n\nint json_patch_apply(struct json_object *copy_from, struct json_object *patch,\n                     struct json_object **base, struct json_patch_error *patch_error)\n{\n\tsize_t ii;\n\tint rc = 0;\n\tstruct json_patch_error placeholder;\n\n\tif (!patch_error)\n\t\tpatch_error = &placeholder;\n\n\tpatch_error->patch_failure_idx = SIZE_T_MAX;\n\tpatch_error->errno_code = 0;\n\n\tif (base == NULL|| \n\t    (*base == NULL && copy_from == NULL) ||\n\t    (*base != NULL && copy_from != NULL))\n\t{\n\t\t_set_err(EFAULT, \"Exactly one of *base or copy_from must be non-NULL\");\n\t\treturn -1;\n\t}\n\t    \n\tif (!json_object_is_type(patch, json_type_array)) {\n\t\t_set_err(EFAULT, \"Patch object is not of type json_type_array\");\n\t\treturn -1;\n\t}\n\n\tif (copy_from != NULL)\n\t{\n\t\tif (json_object_deep_copy(copy_from, base, NULL) < 0)\n\t\t{\n\t\t\t_set_err(ENOMEM, \"Unable to copy copy_from using json_object_deep_copy()\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Go through all operations ; apply them on res */\n\tfor (ii = 0; ii < json_object_array_length(patch); ii++) {\n\t\tstruct json_object *jop, *jpath;\n\t\tstruct json_object *patch_elem = json_object_array_get_idx(patch, ii);\n\t\tconst char *op, *path;\n\n\t\tpatch_error->patch_failure_idx = ii;\n\n\t\tif (!json_object_object_get_ex(patch_elem, \"op\", &jop)) {\n\t\t\t_set_err(EINVAL, \"Patch object does not contain 'op' field\");\n\t\t\treturn -1;\n\t\t}\n\t\top = json_object_get_string(jop);\n\t\tif (!json_object_object_get_ex(patch_elem, \"path\", &jpath)) {\n\t\t\t_set_err(EINVAL, \"Patch object does not contain 'path' field\");\n\t\t\treturn -1;\n\t\t}\n\t\tpath = json_object_get_string(jpath); // Note: empty string is ok!\n\n\t\tif (!strcmp(op, \"test\"))\n\t\t\trc = json_patch_apply_test(base, patch_elem, path, patch_error);\n\t\telse if (!strcmp(op, \"remove\"))\n\t\t\trc = json_patch_apply_remove(base, path, patch_error);\n\t\telse if (!strcmp(op, \"add\"))\n\t\t\trc = json_patch_apply_add_replace(base, patch_elem, path, 1, patch_error);\n\t\telse if (!strcmp(op, \"replace\"))\n\t\t\trc = json_patch_apply_add_replace(base, patch_elem, path, 0, patch_error);\n\t\telse if (!strcmp(op, \"move\"))\n\t\t\trc = json_patch_apply_move_copy(base, patch_elem, path, 1, patch_error);\n\t\telse if (!strcmp(op, \"copy\"))\n\t\t\trc = json_patch_apply_move_copy(base, patch_elem, path, 0, patch_error);\n\t\telse {\n\t\t\t_set_err(EINVAL, \"Patch object has invalid 'op' field\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n"
        },
        {
          "name": "json_patch.h",
          "type": "blob",
          "size": 2.3974609375,
          "content": "/*\n * Copyright (c) 2021 Alexadru Ardelean.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief JSON Patch (RFC 6902) implementation for manipulating JSON objects\n */\n#ifndef _json_patch_h_\n#define _json_patch_h_\n\n#include \"json_pointer.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * Details of an error that occurred during json_patch_apply()\n */\nstruct json_patch_error {\n\t/**\n\t * An errno value indicating what kind of error occurred.\n\t * Possible values include:\n\t * - ENOENT - A path referenced in the operation does not exist.\n\t * - EINVAL - An invalid operation or with invalid path was attempted\n\t * - ENOMEM - Unable to allocate memory\n\t * - EFAULT - Invalid arguments were passed to json_patch_apply()\n\t *             (i.e. a C API error, vs. a data error like EINVAL)\n\t */\n\tint errno_code;\n\n\t/**\n\t * The index into the patch array of the operation that failed,\n\t * or SIZE_T_MAX for overall errors.\n\t */\n\tsize_t patch_failure_idx;\n\n\t/**\n\t * A human readable error message.\n\t * Allocated from static storage, does not need to be freed.\n\t */\n\tconst char *errmsg;\n};\n\n/**\n * Apply the JSON patch to the base object.\n * The patch object must be formatted as per RFC 6902, i.e.\n * a json_type_array containing patch operations.\n * If the patch is not correctly formatted, an error will\n * be returned.\n *\n * The json_object at *base will be modified in place.\n * Exactly one of *base or copy_from must be non-NULL.\n * If *base is NULL, a new copy of copy_from will allocated and populated\n * using json_object_deep_copy().  In this case json_object_put() _must_ be \n * used to free *base even if the overall patching operation fails.\n *\n * If anything fails during patching a negative value will be returned,\n * and patch_error (if non-NULL) will be populated with error details.\n *\n * @param base a pointer to the JSON object which to patch\n * @param patch the JSON object that describes the patch to be applied\n * @param copy_from a JSON object to copy to *base\n * @param patch_error optional, details about errors\n *\n * @return negative if an error (or not found), or 0 if patch completely applied\n */\nJSON_EXPORT int json_patch_apply(struct json_object *copy_from, struct json_object *patch,\n                                 struct json_object **base, struct json_patch_error *patch_error);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_pointer.c",
          "type": "blob",
          "size": 8.673828125,
          "content": "/*\n * Copyright (c) 2016 Alexandru Ardelean.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"config.h\"\n\n#include \"strerror_override.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"json_object_private.h\"\n#include \"json_pointer.h\"\n#include \"json_pointer_private.h\"\n#include \"strdup_compat.h\"\n#include \"vasprintf_compat.h\"\n\n/* Avoid ctype.h and locale overhead */\n#define is_plain_digit(c) ((c) >= '0' && (c) <= '9')\n\n/**\n * JavaScript Object Notation (JSON) Pointer\n *   RFC 6901 - https://tools.ietf.org/html/rfc6901\n */\n\nstatic void string_replace_all_occurrences_with_char(char *s, const char *occur, char repl_char)\n{\n\tsize_t slen = strlen(s);\n\tsize_t skip = strlen(occur) - 1; /* length of the occurrence, minus the char we're replacing */\n\tchar *p = s;\n\twhile ((p = strstr(p, occur)))\n\t{\n\t\t*p = repl_char;\n\t\tp++;\n\t\tslen -= skip;\n\t\tmemmove(p, (p + skip), slen - (p - s) + 1); /* includes null char too */\n\t}\n}\n\nstatic int is_valid_index(const char *path, size_t *idx)\n{\n\tsize_t i, len = strlen(path);\n\t/* this code-path optimizes a bit, for when we reference the 0-9 index range\n\t * in a JSON array and because leading zeros not allowed\n\t */\n\tif (len == 1)\n\t{\n\t\tif (is_plain_digit(path[0]))\n\t\t{\n\t\t\t*idx = (path[0] - '0');\n\t\t\treturn 1;\n\t\t}\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* leading zeros not allowed per RFC */\n\tif (path[0] == '0')\n\t{\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\t/* RFC states base-10 decimals */\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tif (!is_plain_digit(path[i]))\n\t\t{\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// We know it's all digits, so the only error case here is overflow,\n\t// but ULLONG_MAX will be longer than any array length so that's ok.\n\t*idx = strtoull(path, NULL, 10);\n\n\treturn 1;\n}\n\nstatic int json_pointer_get_single_path(struct json_object *obj, char *path,\n                                        struct json_object **value, size_t *idx)\n{\n\tif (json_object_is_type(obj, json_type_array))\n\t{\n\t\tif (!is_valid_index(path, idx))\n\t\t\treturn -1;\n\t\tif (*idx >= json_object_array_length(obj))\n\t\t{\n\t\t\terrno = ENOENT;\n\t\t\treturn -1;\n\t\t}\n\n\t\tobj = json_object_array_get_idx(obj, *idx);\n\t\tif (obj)\n\t\t{\n\t\t\tif (value)\n\t\t\t\t*value = obj;\n\t\t\treturn 0;\n\t\t}\n\t\t/* Entry not found */\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\t/* RFC states that we first must eval all ~1 then all ~0 */\n\tstring_replace_all_occurrences_with_char(path, \"~1\", '/');\n\tstring_replace_all_occurrences_with_char(path, \"~0\", '~');\n\n\tif (!json_object_object_get_ex(obj, path, value))\n\t{\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int json_object_array_put_idx_cb(struct json_object *parent, size_t idx,\n\t\t\t\t\tstruct json_object *value, void *priv)\n{\n\treturn json_object_array_put_idx(parent, idx, value);\n}\n\nstatic int json_pointer_set_single_path(struct json_object *parent, const char *path,\n                                        struct json_object *value,\n\t\t\t\t\tjson_pointer_array_set_cb array_set_cb, void *priv)\n{\n\tif (json_object_is_type(parent, json_type_array))\n\t{\n\t\tsize_t idx;\n\t\t/* RFC (Chapter 4) states that '-' may be used to add new elements to an array */\n\t\tif (path[0] == '-' && path[1] == '\\0')\n\t\t\treturn json_object_array_add(parent, value);\n\t\tif (!is_valid_index(path, &idx))\n\t\t\treturn -1;\n\t\treturn array_set_cb(parent, idx, value, priv);\n\t}\n\n\t/* path replacements should have been done in json_pointer_get_single_path(),\n\t * and we should still be good here\n\t */\n\tif (json_object_is_type(parent, json_type_object))\n\t\treturn json_object_object_add(parent, path, value);\n\n\t/* Getting here means that we tried to \"dereference\" a primitive JSON type\n\t * (like string, int, bool).i.e. add a sub-object to it\n\t */\n\terrno = ENOENT;\n\treturn -1;\n}\n\nstatic int json_pointer_result_get_recursive(struct json_object *obj, char *path,\n                                             struct json_pointer_get_result *res)\n{\n\tstruct json_object *parent_obj = obj;\n\tsize_t idx = 0;\n\tchar *endp;\n\tint rc;\n\n\t/* All paths (on each recursion level must have a leading '/' */\n\tif (path[0] != '/')\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tpath++;\n\n\tendp = strchr(path, '/');\n\tif (endp)\n\t\t*endp = '\\0';\n\n\t/* If we err-ed here, return here */\n\tif ((rc = json_pointer_get_single_path(obj, path, &obj, &idx)))\n\t\treturn rc;\n\n\tif (endp)\n\t{\n\t\t/* Put the slash back, so that the sanity check passes on next recursion level */\n\t\t*endp = '/';\n\t\treturn json_pointer_result_get_recursive(obj, endp, res);\n\t}\n\n\t/* We should be at the end of the recursion here */\n\tif (res) {\n\t\tres->parent = parent_obj;\n\t\tres->obj = obj;\n\t\tif (json_object_is_type(res->parent, json_type_array))\n\t\t\tres->index_in_parent = idx;\n\t\telse\n\t\t\tres->key_in_parent = path;\n\t}\n\n\treturn 0;\n}\n\nstatic int json_pointer_object_get_recursive(struct json_object *obj, char *path,\n                                             struct json_object **value)\n{\n\tstruct json_pointer_get_result res;\n\tint rc;\n\n\trc = json_pointer_result_get_recursive(obj, path, &res);\n\tif (rc)\n\t\treturn rc;\n\n\tif (value)\n\t\t*value = res.obj;\n\n\treturn 0;\n}\n\nint json_pointer_get_internal(struct json_object *obj, const char *path,\n                              struct json_pointer_get_result *res)\n{\n\tchar *path_copy = NULL;\n\tint rc;\n\n\tif (!obj || !path)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (path[0] == '\\0')\n\t{\n\t\tres->parent = NULL;\n\t\tres->obj = obj;\n\t\tres->key_in_parent = NULL;\n\t\tres->index_in_parent = UINT32_MAX;\n\t\treturn 0;\n\t}\n\n\t/* pass a working copy to the recursive call */\n\tif (!(path_copy = strdup(path)))\n\t{\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\trc = json_pointer_result_get_recursive(obj, path_copy, res);\n\t/* re-map the path string to the const-path string */\n\tif (rc == 0 && json_object_is_type(res->parent, json_type_object) && res->key_in_parent)\n\t\tres->key_in_parent = path + (res->key_in_parent - path_copy);\n\tfree(path_copy);\n\n\treturn rc;\n}\n\nint json_pointer_get(struct json_object *obj, const char *path, struct json_object **res)\n{\n\tstruct json_pointer_get_result jpres;\n\tint rc;\n\n\trc = json_pointer_get_internal(obj, path, &jpres);\n\tif (rc)\n\t\treturn rc;\n\n\tif (res)\n\t\t*res = jpres.obj;\n\n\treturn 0;\n}\n\nint json_pointer_getf(struct json_object *obj, struct json_object **res, const char *path_fmt, ...)\n{\n\tchar *path_copy = NULL;\n\tint rc = 0;\n\tva_list args;\n\n\tif (!obj || !path_fmt)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tva_start(args, path_fmt);\n\trc = vasprintf(&path_copy, path_fmt, args);\n\tva_end(args);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (path_copy[0] == '\\0')\n\t{\n\t\tif (res)\n\t\t\t*res = obj;\n\t\tgoto out;\n\t}\n\n\trc = json_pointer_object_get_recursive(obj, path_copy, res);\nout:\n\tfree(path_copy);\n\n\treturn rc;\n}\n\nint json_pointer_set_with_array_cb(struct json_object **obj, const char *path,\n\t\t\t\t   struct json_object *value,\n\t\t\t\t   json_pointer_array_set_cb array_set_cb, void *priv)\n{\n\tconst char *endp;\n\tchar *path_copy = NULL;\n\tstruct json_object *set = NULL;\n\tint rc;\n\n\tif (!obj || !path)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (path[0] == '\\0')\n\t{\n\t\tjson_object_put(*obj);\n\t\t*obj = value;\n\t\treturn 0;\n\t}\n\n\tif (path[0] != '/')\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* If there's only 1 level to set, stop here */\n\tif ((endp = strrchr(path, '/')) == path)\n\t{\n\t\tpath++;\n\t\treturn json_pointer_set_single_path(*obj, path, value, array_set_cb, priv);\n\t}\n\n\t/* pass a working copy to the recursive call */\n\tif (!(path_copy = strdup(path)))\n\t{\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tpath_copy[endp - path] = '\\0';\n\trc = json_pointer_object_get_recursive(*obj, path_copy, &set);\n\tfree(path_copy);\n\n\tif (rc)\n\t\treturn rc;\n\n\tendp++;\n\treturn json_pointer_set_single_path(set, endp, value, array_set_cb, priv);\n}\n\nint json_pointer_set(struct json_object **obj, const char *path, struct json_object *value)\n{\n\treturn json_pointer_set_with_array_cb(obj, path, value, json_object_array_put_idx_cb, NULL);\n}\n\nint json_pointer_setf(struct json_object **obj, struct json_object *value, const char *path_fmt,\n                      ...)\n{\n\tchar *endp;\n\tchar *path_copy = NULL;\n\tstruct json_object *set = NULL;\n\tva_list args;\n\tint rc = 0;\n\n\tif (!obj || !path_fmt)\n\t{\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* pass a working copy to the recursive call */\n\tva_start(args, path_fmt);\n\trc = vasprintf(&path_copy, path_fmt, args);\n\tva_end(args);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (path_copy[0] == '\\0')\n\t{\n\t\tjson_object_put(*obj);\n\t\t*obj = value;\n\t\tgoto out;\n\t}\n\n\tif (path_copy[0] != '/')\n\t{\n\t\terrno = EINVAL;\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\n\t/* If there's only 1 level to set, stop here */\n\tif ((endp = strrchr(path_copy, '/')) == path_copy)\n\t{\n\t\tset = *obj;\n\t\tgoto set_single_path;\n\t}\n\n\t*endp = '\\0';\n\trc = json_pointer_object_get_recursive(*obj, path_copy, &set);\n\n\tif (rc)\n\t\tgoto out;\n\nset_single_path:\n\tendp++;\n\trc = json_pointer_set_single_path(set, endp, value,\n\t\t\t\t\t  json_object_array_put_idx_cb, NULL);\nout:\n\tfree(path_copy);\n\treturn rc;\n}\n"
        },
        {
          "name": "json_pointer.h",
          "type": "blob",
          "size": 4.42578125,
          "content": "/*\n * Copyright (c) 2016 Alexadru Ardelean.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief JSON Pointer (RFC 6901) implementation for retrieving\n *        objects from a json-c object tree.\n */\n#ifndef _json_pointer_h_\n#define _json_pointer_h_\n\n#include \"json_object.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * Retrieves a JSON sub-object from inside another JSON object\n * using the JSON pointer notation as defined in RFC 6901\n *   https://tools.ietf.org/html/rfc6901\n *\n * The returned JSON sub-object is equivalent to parsing manually the\n * 'obj' JSON tree ; i.e. it's not a new object that is created, but rather\n * a pointer inside the JSON tree.\n *\n * Internally, this is equivalent to doing a series of 'json_object_object_get()'\n * and 'json_object_array_get_idx()' along the given 'path'.\n *\n * @param obj the json_object instance/tree from where to retrieve sub-objects\n * @param path a (RFC6901) string notation for the sub-object to retrieve\n * @param res a pointer that stores a reference to the json_object\n *              associated with the given path\n *\n * @return negative if an error (or not found), or 0 if succeeded\n */\nJSON_EXPORT int json_pointer_get(struct json_object *obj, const char *path,\n                                 struct json_object **res);\n\n/**\n * This is a variant of 'json_pointer_get()' that supports printf() style arguments.\n *\n * Variable arguments go after the 'path_fmt' parameter.\n *\n * Example: json_pointer_getf(obj, res, \"/foo/%d/%s\", 0, \"bar\")\n * This also means that you need to escape '%' with '%%' (just like in printf())\n *\n * Please take into consideration all recommended 'printf()' format security\n * aspects when using this function.\n *\n * @param obj the json_object instance/tree to which to add a sub-object\n * @param res a pointer that stores a reference to the json_object\n *              associated with the given path\n * @param path_fmt a printf() style format for the path\n *\n * @return negative if an error (or not found), or 0 if succeeded\n */\nJSON_EXPORT int json_pointer_getf(struct json_object *obj, struct json_object **res,\n                                  const char *path_fmt, ...);\n\n/**\n * Sets JSON object 'value' in the 'obj' tree at the location specified\n * by the 'path'. 'path' is JSON pointer notation as defined in RFC 6901\n *   https://tools.ietf.org/html/rfc6901\n *\n * Note that 'obj' is a double pointer, mostly for the \"\" (empty string)\n * case, where the entire JSON object would be replaced by 'value'.\n * In the case of the \"\" path, the object at '*obj' will have it's refcount\n * decremented with 'json_object_put()' and the 'value' object will be assigned to it.\n *\n * For other cases (JSON sub-objects) ownership of 'value' will be transferred into\n * '*obj' via 'json_object_object_add()' & 'json_object_array_put_idx()', so the\n * only time the refcount should be decremented for 'value' is when the return value of\n * 'json_pointer_set()' is negative (meaning the 'value' object did not get set into '*obj').\n *\n * That also implies that 'json_pointer_set()' does not do any refcount incrementing.\n * (Just that single decrement that was mentioned above).\n *\n * @param obj the json_object instance/tree to which to add a sub-object\n * @param path a (RFC6901) string notation for the sub-object to set in the tree\n * @param value object to set at path\n *\n * @return negative if an error (or not found), or 0 if succeeded\n */\nJSON_EXPORT int json_pointer_set(struct json_object **obj, const char *path,\n                                 struct json_object *value);\n\n/**\n * This is a variant of 'json_pointer_set()' that supports printf() style arguments.\n *\n * Variable arguments go after the 'path_fmt' parameter.\n *\n * Example: json_pointer_setf(obj, value, \"/foo/%d/%s\", 0, \"bar\")\n * This also means that you need to escape '%' with '%%' (just like in printf())\n *\n * Please take into consideration all recommended 'printf()' format security\n * aspects when using this function.\n *\n * @param obj the json_object instance/tree to which to add a sub-object\n * @param value object to set at path\n * @param path_fmt a printf() style format for the path\n *\n * @return negative if an error (or not found), or 0 if succeeded\n */\nJSON_EXPORT int json_pointer_setf(struct json_object **obj, struct json_object *value,\n                                  const char *path_fmt, ...);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_pointer_private.h",
          "type": "blob",
          "size": 1.2919921875,
          "content": "/*\n * Copyright (c) 2023 Eric Hawicz\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n */\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n#ifndef _json_pointer_private_h_\n#define _json_pointer_private_h_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct json_pointer_get_result {\n\tstruct json_object *parent;\n\tstruct json_object *obj;\n\t// The key of the found object; only valid when parent is json_type_object\n\t// Caution: re-uses tail end of the `path` argument to json_pointer_get_internal\n\tconst char *key_in_parent;\n\t// the index of the found object; only valid when parent is json_type_array\n\tuint32_t index_in_parent;\n};\n\nint json_pointer_get_internal(struct json_object *obj, const char *path,\n                              struct json_pointer_get_result *res);\n\ntypedef int(*json_pointer_array_set_cb)(json_object *parent, size_t idx,\n                                        json_object *value, void *priv);\n\nint json_pointer_set_with_array_cb(struct json_object **obj, const char *path,\n                                   struct json_object *value,\n                                   json_pointer_array_set_cb array_set_cb, void *priv);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_tokener.c",
          "type": "blob",
          "size": 37.0849609375,
          "content": "/*\n * $Id: json_tokener.c,v 1.20 2006/07/25 03:24:50 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n *\n * Copyright (c) 2008-2009 Yahoo! Inc.  All rights reserved.\n * The copyrights to the contents of this file are licensed under the MIT License\n * (https://www.opensource.org/licenses/mit-license.php)\n */\n\n#include \"config.h\"\n\n#include \"math_compat.h\"\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"debug.h\"\n#include \"json_inttypes.h\"\n#include \"json_object.h\"\n#include \"json_object_private.h\"\n#include \"json_tokener.h\"\n#include \"json_util.h\"\n#include \"printbuf.h\"\n#include \"strdup_compat.h\"\n\n#ifdef HAVE_LOCALE_H\n#include <locale.h>\n#endif /* HAVE_LOCALE_H */\n#ifdef HAVE_XLOCALE_H\n#include <xlocale.h>\n#endif\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif /* HAVE_STRINGS_H */\n\n#define jt_hexdigit(x) (((x) <= '9') ? (x) - '0' : ((x)&7) + 9)\n\n#if !HAVE_STRNCASECMP && defined(_MSC_VER)\n/* MSC has the version as _strnicmp */\n#define strncasecmp _strnicmp\n#elif !HAVE_STRNCASECMP\n#error You do not have strncasecmp on your system.\n#endif /* HAVE_STRNCASECMP */\n\n#if defined(_MSC_VER) && (_MSC_VER <= 1800)\n/* VS2013 doesn't know about \"inline\" */\n#define inline __inline\n#elif defined(AIX_CC)\n#define inline\n#endif\n\n/* The following helper functions are used to speed up parsing. They\n * are faster than their ctype counterparts because they assume that\n * the input is in ASCII and that the locale is set to \"C\". The\n * compiler will also inline these functions, providing an additional\n * speedup by saving on function calls.\n */\nstatic inline int is_ws_char(char c)\n{\n\treturn c == ' '\n\t    || c == '\\t'\n\t    || c == '\\n'\n\t    || c == '\\r';\n}\n\nstatic inline int is_hex_char(char c)\n{\n\treturn (c >= '0' && c <= '9')\n\t    || (c >= 'A' && c <= 'F')\n\t    || (c >= 'a' && c <= 'f');\n}\n\n/* Use C99 NAN by default; if not available, nan(\"\") should work too. */\n#ifndef NAN\n#define NAN nan(\"\")\n#endif /* !NAN */\n\nstatic const char json_null_str[] = \"null\";\nstatic const int json_null_str_len = sizeof(json_null_str) - 1;\nstatic const char json_inf_str[] = \"Infinity\";\n/* Swapped case \"Infinity\" to avoid need to call tolower() on input chars: */\nstatic const char json_inf_str_invert[] = \"iNFINITY\";\nstatic const unsigned int json_inf_str_len = sizeof(json_inf_str) - 1;\nstatic const char json_nan_str[] = \"NaN\";\nstatic const int json_nan_str_len = sizeof(json_nan_str) - 1;\nstatic const char json_true_str[] = \"true\";\nstatic const int json_true_str_len = sizeof(json_true_str) - 1;\nstatic const char json_false_str[] = \"false\";\nstatic const int json_false_str_len = sizeof(json_false_str) - 1;\n\n/* clang-format off */\nstatic const char *json_tokener_errors[] = {\n\t\"success\",\n\t\"continue\",\n\t\"nesting too deep\",\n\t\"unexpected end of data\",\n\t\"unexpected character\",\n\t\"null expected\",\n\t\"boolean expected\",\n\t\"number expected\",\n\t\"array value separator ',' expected\",\n\t\"quoted object property name expected\",\n\t\"object property name separator ':' expected\",\n\t\"object value separator ',' expected\",\n\t\"invalid string sequence\",\n\t\"expected comment\",\n\t\"invalid utf-8 string\",\n\t\"buffer size overflow\",\n\t\"out of memory\"\n};\n/* clang-format on */\n\n/**\n * validete the utf-8 string in strict model.\n * if not utf-8 format, return err.\n */\nstatic json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes);\n\nstatic int json_tokener_parse_double(const char *buf, int len, double *retval);\n\nconst char *json_tokener_error_desc(enum json_tokener_error jerr)\n{\n\tint jerr_int = (int)jerr;\n\tif (jerr_int < 0 ||\n\t    jerr_int >= (int)(sizeof(json_tokener_errors) / sizeof(json_tokener_errors[0])))\n\t\treturn \"Unknown error, \"\n\t\t       \"invalid json_tokener_error value passed to json_tokener_error_desc()\";\n\treturn json_tokener_errors[jerr];\n}\n\nenum json_tokener_error json_tokener_get_error(struct json_tokener *tok)\n{\n\treturn tok->err;\n}\n\n/* Stuff for decoding unicode sequences */\n#define IS_HIGH_SURROGATE(uc) (((uc)&0xFC00) == 0xD800)\n#define IS_LOW_SURROGATE(uc) (((uc)&0xFC00) == 0xDC00)\n#define DECODE_SURROGATE_PAIR(hi, lo) ((((hi)&0x3FF) << 10) + ((lo)&0x3FF) + 0x10000)\nstatic unsigned char utf8_replacement_char[3] = {0xEF, 0xBF, 0xBD};\n\nstruct json_tokener *json_tokener_new_ex(int depth)\n{\n\tstruct json_tokener *tok;\n\n\tif (depth < 1)\n\t\treturn NULL;\n\n\ttok = (struct json_tokener *)calloc(1, sizeof(struct json_tokener));\n\tif (!tok)\n\t\treturn NULL;\n\ttok->stack = (struct json_tokener_srec *)calloc(depth, sizeof(struct json_tokener_srec));\n\tif (!tok->stack)\n\t{\n\t\tfree(tok);\n\t\treturn NULL;\n\t}\n\ttok->pb = printbuf_new();\n\tif (!tok->pb)\n\t{\n\t\tfree(tok->stack);\n\t\tfree(tok);\n\t\treturn NULL;\n\t}\n\ttok->max_depth = depth;\n\tjson_tokener_reset(tok);\n\treturn tok;\n}\n\nstruct json_tokener *json_tokener_new(void)\n{\n\treturn json_tokener_new_ex(JSON_TOKENER_DEFAULT_DEPTH);\n}\n\nvoid json_tokener_free(struct json_tokener *tok)\n{\n\tif (!tok)\n\t\treturn;\n\tjson_tokener_reset(tok);\n\tif (tok->pb)\n\t\tprintbuf_free(tok->pb);\n\tfree(tok->stack);\n\tfree(tok);\n}\n\nstatic void json_tokener_reset_level(struct json_tokener *tok, int depth)\n{\n\ttok->stack[depth].state = json_tokener_state_eatws;\n\ttok->stack[depth].saved_state = json_tokener_state_start;\n\tjson_object_put(tok->stack[depth].current);\n\ttok->stack[depth].current = NULL;\n\tfree(tok->stack[depth].obj_field_name);\n\ttok->stack[depth].obj_field_name = NULL;\n}\n\nvoid json_tokener_reset(struct json_tokener *tok)\n{\n\tint i;\n\tif (!tok)\n\t\treturn;\n\n\tfor (i = tok->depth; i >= 0; i--)\n\t\tjson_tokener_reset_level(tok, i);\n\ttok->depth = 0;\n\ttok->err = json_tokener_success;\n}\n\nstruct json_object *json_tokener_parse(const char *str)\n{\n\tenum json_tokener_error jerr_ignored;\n\tstruct json_object *obj;\n\tobj = json_tokener_parse_verbose(str, &jerr_ignored);\n\treturn obj;\n}\n\nstruct json_object *json_tokener_parse_verbose(const char *str, enum json_tokener_error *error)\n{\n\tstruct json_tokener *tok;\n\tstruct json_object *obj;\n\n\ttok = json_tokener_new();\n\tif (!tok)\n\t{\n\t\t*error = json_tokener_error_memory;\n\t\treturn NULL;\n\t}\n\tobj = json_tokener_parse_ex(tok, str, -1);\n\t*error = tok->err;\n\tif (tok->err != json_tokener_success\n#if 0\n\t\t/* This would be a more sensible default, and cause parsing\n\t\t * things like \"null123\" to fail when the caller can't know\n\t\t * where the parsing left off, but starting to fail would\n\t\t * be a notable behaviour change.  Save for a 1.0 release.\n\t\t */\n\t    || json_tokener_get_parse_end(tok) != strlen(str)\n#endif\n\t)\n\n\t{\n\t\tif (obj != NULL)\n\t\t\tjson_object_put(obj);\n\t\tobj = NULL;\n\t}\n\n\tjson_tokener_free(tok);\n\treturn obj;\n}\n\n#define state tok->stack[tok->depth].state\n#define saved_state tok->stack[tok->depth].saved_state\n#define current tok->stack[tok->depth].current\n#define obj_field_name tok->stack[tok->depth].obj_field_name\n\n/* Optimization:\n * json_tokener_parse_ex() consumed a lot of CPU in its main loop,\n * iterating character-by character.  A large performance boost is\n * achieved by using tighter loops to locally handle units such as\n * comments and strings.  Loops that handle an entire token within\n * their scope also gather entire strings and pass them to\n * printbuf_memappend() in a single call, rather than calling\n * printbuf_memappend() one char at a time.\n *\n * PEEK_CHAR() and ADVANCE_CHAR() macros are used for code that is\n * common to both the main loop and the tighter loops.\n */\n\n/* PEEK_CHAR(dest, tok) macro:\n *   Peeks at the current char and stores it in dest.\n *   Returns 1 on success, sets tok->err and returns 0 if no more chars.\n *   Implicit inputs:  str, len, nBytesp vars\n */\n#define PEEK_CHAR(dest, tok)                                                 \\\n\t(((tok)->char_offset == len)                                         \\\n\t     ? (((tok)->depth == 0 && state == json_tokener_state_eatws &&   \\\n\t         saved_state == json_tokener_state_finish)                   \\\n\t            ? (((tok)->err = json_tokener_success), 0)               \\\n\t            : (((tok)->err = json_tokener_continue), 0))             \\\n\t     : (((tok->flags & JSON_TOKENER_VALIDATE_UTF8) &&                \\\n\t         (!json_tokener_validate_utf8(*str, nBytesp)))               \\\n\t            ? ((tok->err = json_tokener_error_parse_utf8_string), 0) \\\n\t            : (((dest) = *str), 1)))\n\n/* ADVANCE_CHAR() macro:\n *   Increments str & tok->char_offset.\n *   For convenience of existing conditionals, returns the old value of c (0 on eof).\n *   Implicit inputs:  c var\n */\n#define ADVANCE_CHAR(str, tok) (++(str), ((tok)->char_offset)++, c)\n\n/* printbuf_memappend_checked(p, s, l) macro:\n *   Add string s of length l to printbuffer p.\n *   If operation fails abort parse operation with memory error.\n */\n#define printbuf_memappend_checked(p, s, l)                   \\\n\tdo {                                                  \\\n\t\tif (printbuf_memappend((p), (s), (l)) < 0)    \\\n\t\t{                                             \\\n\t\t\ttok->err = json_tokener_error_memory; \\\n\t\t\tgoto out;                             \\\n\t\t}                                             \\\n\t} while (0)\n\n/* End optimization macro defs */\n\nstruct json_object *json_tokener_parse_ex(struct json_tokener *tok, const char *str, int len)\n{\n\tstruct json_object *obj = NULL;\n\tchar c = '\\1';\n\tunsigned int nBytes = 0;\n\tunsigned int *nBytesp = &nBytes;\n\n#ifdef HAVE_USELOCALE\n\tlocale_t oldlocale = uselocale(NULL);\n\tlocale_t newloc;\n#elif defined(HAVE_SETLOCALE)\n\tchar *oldlocale = NULL;\n#endif\n\n\ttok->char_offset = 0;\n\ttok->err = json_tokener_success;\n\n\t/* this interface is presently not 64-bit clean due to the int len argument\n\t * and the internal printbuf interface that takes 32-bit int len arguments\n\t * so the function limits the maximum string size to INT32_MAX (2GB).\n\t * If the function is called with len == -1 then strlen is called to check\n\t * the string length is less than INT32_MAX (2GB)\n\t */\n\tif ((len < -1) || (len == -1 && strlen(str) > INT32_MAX))\n\t{\n\t\ttok->err = json_tokener_error_size;\n\t\treturn NULL;\n\t}\n\n#ifdef HAVE_USELOCALE\n\t{\n#ifdef HAVE_DUPLOCALE\n\t\tlocale_t duploc = duplocale(oldlocale);\n\t\tif (duploc == NULL && errno == ENOMEM)\n\t\t{\n\t\t\ttok->err = json_tokener_error_memory;\n\t\t\treturn NULL;\n\t\t}\n\t\tnewloc = newlocale(LC_NUMERIC_MASK, \"C\", duploc);\n#else\n\t\tnewloc = newlocale(LC_NUMERIC_MASK, \"C\", oldlocale);\n#endif\n\t\tif (newloc == NULL)\n\t\t{\n\t\t\ttok->err = json_tokener_error_memory;\n#ifdef HAVE_DUPLOCALE\n\t\t\tfreelocale(duploc);\n#endif\n\t\t\treturn NULL;\n\t\t}\n#ifdef NEWLOCALE_NEEDS_FREELOCALE\n#ifdef HAVE_DUPLOCALE\n\t\t// Older versions of FreeBSD (<12.4) don't free the locale\n\t\t// passed to newlocale(), so do it here\n\t\tfreelocale(duploc);\n#endif\n#endif\n\t\tuselocale(newloc);\n\t}\n#elif defined(HAVE_SETLOCALE)\n\t{\n\t\tchar *tmplocale;\n\t\ttmplocale = setlocale(LC_NUMERIC, NULL);\n\t\tif (tmplocale)\n\t\t{\n\t\t\toldlocale = strdup(tmplocale);\n\t\t\tif (oldlocale == NULL)\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tsetlocale(LC_NUMERIC, \"C\");\n\t}\n#endif\n\n\twhile (PEEK_CHAR(c, tok)) // Note: c might be '\\0' !\n\t{\n\n\tredo_char:\n\t\tswitch (state)\n\t\t{\n\n\t\tcase json_tokener_state_eatws:\n\t\t\t/* Advance until we change state */\n\t\t\twhile (is_ws_char(c))\n\t\t\t{\n\t\t\t\tif ((!ADVANCE_CHAR(str, tok)) || (!PEEK_CHAR(c, tok)))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (c == '/' && !(tok->flags & JSON_TOKENER_STRICT))\n\t\t\t{\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\tprintbuf_memappend_checked(tok->pb, &c, 1);\n\t\t\t\tstate = json_tokener_state_comment_start;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate = saved_state;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_start:\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase '{':\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tsaved_state = json_tokener_state_object_field_start;\n\t\t\t\tcurrent = json_object_new_object();\n\t\t\t\tif (current == NULL)\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tsaved_state = json_tokener_state_array;\n\t\t\t\tcurrent = json_object_new_array();\n\t\t\t\tif (current == NULL)\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\tcase 'i':\n\t\t\t\tstate = json_tokener_state_inf;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase 'N':\n\t\t\tcase 'n':\n\t\t\t\tstate = json_tokener_state_null; // or NaN\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase '\\'':\n\t\t\t\tif (tok->flags & JSON_TOKENER_STRICT)\n\t\t\t\t{\n\t\t\t\t\t/* in STRICT mode only double-quote are allowed */\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/* FALLTHRU */\n\t\t\tcase '\"':\n\t\t\t\tstate = json_tokener_state_string;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->quote_char = c;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\tcase 't':\n\t\t\tcase 'F':\n\t\t\tcase 'f':\n\t\t\t\tstate = json_tokener_state_boolean;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\tcase '-':\n\t\t\t\tstate = json_tokener_state_number;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\ttok->is_double = 0;\n\t\t\t\tgoto redo_char;\n\t\t\tdefault: tok->err = json_tokener_error_parse_unexpected; goto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_finish:\n\t\t\tif (tok->depth == 0)\n\t\t\t\tgoto out;\n\t\t\tobj = json_object_get(current);\n\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\ttok->depth--;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_inf: /* aka starts with 'i' (or 'I', or \"-i\", or \"-I\") */\n\t\t{\n\t\t\t/* If we were guaranteed to have len set, then we could (usually) handle\n\t\t\t * the entire \"Infinity\" check in a single strncmp (strncasecmp), but\n\t\t\t * since len might be -1 (i.e. \"read until \\0\"), we need to check it\n\t\t\t * a character at a time.\n\t\t\t * Trying to handle it both ways would make this code considerably more\n\t\t\t * complicated with likely little performance benefit.\n\t\t\t */\n\t\t\tint is_negative = 0;\n\n\t\t\t/* Note: tok->st_pos must be 0 when state is set to json_tokener_state_inf */\n\t\t\twhile (tok->st_pos < (int)json_inf_str_len)\n\t\t\t{\n\t\t\t\tchar inf_char = *str;\n\t\t\t\tif (inf_char != json_inf_str[tok->st_pos] &&\n\t\t\t\t    ((tok->flags & JSON_TOKENER_STRICT) ||\n\t\t\t\t      inf_char != json_inf_str_invert[tok->st_pos])\n\t\t\t\t   )\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttok->st_pos++;\n\t\t\t\t(void)ADVANCE_CHAR(str, tok);\n\t\t\t\tif (!PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\t/* out of input chars, for now at least */\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We checked the full length of \"Infinity\", so create the object.\n\t\t\t * When handling -Infinity, the number parsing code will have dropped\n\t\t\t * the \"-\" into tok->pb for us, so check it now.\n\t\t\t */\n\t\t\tif (printbuf_length(tok->pb) > 0 && *(tok->pb->buf) == '-')\n\t\t\t{\n\t\t\t\tis_negative = 1;\n\t\t\t}\n\t\t\tcurrent = json_object_new_double(is_negative ? -INFINITY : INFINITY);\n\t\t\tif (current == NULL)\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\t\t}\n\t\tbreak;\n\t\tcase json_tokener_state_null: /* aka starts with 'n' */\n\t\t{\n\t\t\tint size;\n\t\t\tint size_nan;\n\t\t\tprintbuf_memappend_checked(tok->pb, &c, 1);\n\t\t\tsize = json_min(tok->st_pos + 1, json_null_str_len);\n\t\t\tsize_nan = json_min(tok->st_pos + 1, json_nan_str_len);\n\t\t\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t     strncasecmp(json_null_str, tok->pb->buf, size) == 0) ||\n\t\t\t    (strncmp(json_null_str, tok->pb->buf, size) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_null_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = NULL;\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t          strncasecmp(json_nan_str, tok->pb->buf, size_nan) == 0) ||\n\t\t\t         (strncmp(json_nan_str, tok->pb->buf, size_nan) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_nan_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_double(NAN);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_null;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttok->st_pos++;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_comment_start:\n\t\t\tif (c == '*')\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_comment;\n\t\t\t}\n\t\t\telse if (c == '/')\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_comment_eol;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_comment;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tprintbuf_memappend_checked(tok->pb, &c, 1);\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_comment:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (c != '*')\n\t\t\t{\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintbuf_memappend_checked(tok->pb, case_start, 1 + str - case_start);\n\t\t\tstate = json_tokener_state_comment_end;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_comment_eol:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (c != '\\n')\n\t\t\t{\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintbuf_memappend_checked(tok->pb, case_start, str - case_start);\n\t\t\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\t\t\tstate = json_tokener_state_eatws;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_comment_end:\n\t\t\tprintbuf_memappend_checked(tok->pb, &c, 1);\n\t\t\tif (c == '/')\n\t\t\t{\n\t\t\t\tMC_DEBUG(\"json_tokener_comment: %s\\n\", tok->pb->buf);\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_comment;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_string:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (c == tok->quote_char)\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tcurrent =\n\t\t\t\t\t    json_object_new_string_len(tok->pb->buf, tok->pb->bpos);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (c == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tsaved_state = json_tokener_state_string;\n\t\t\t\t\tstate = json_tokener_state_string_escape;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if ((tok->flags & JSON_TOKENER_STRICT) && (unsigned char)c <= 0x1f)\n\t\t\t\t{\n\t\t\t\t\t// Disallow control characters in strict mode\n\t\t\t\t\ttok->err = json_tokener_error_parse_string;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_string_escape:\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase '\"':\n\t\t\tcase '\\\\':\n\t\t\tcase '/':\n\t\t\t\tprintbuf_memappend_checked(tok->pb, &c, 1);\n\t\t\t\tstate = saved_state;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\tcase 'n':\n\t\t\tcase 'r':\n\t\t\tcase 't':\n\t\t\tcase 'f':\n\t\t\t\tif (c == 'b')\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, \"\\b\", 1);\n\t\t\t\telse if (c == 'n')\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, \"\\n\", 1);\n\t\t\t\telse if (c == 'r')\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, \"\\r\", 1);\n\t\t\t\telse if (c == 't')\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, \"\\t\", 1);\n\t\t\t\telse if (c == 'f')\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, \"\\f\", 1);\n\t\t\t\tstate = saved_state;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\ttok->ucs_char = 0;\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tstate = json_tokener_state_escape_unicode;\n\t\t\t\tbreak;\n\t\t\tdefault: tok->err = json_tokener_error_parse_string; goto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t// ===================================================\n\n\t\tcase json_tokener_state_escape_unicode:\n\t\t{\n\t\t\t/* Handle a 4-byte \\uNNNN sequence, or two sequences if a surrogate pair */\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (!c || !is_hex_char(c))\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_string;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\ttok->ucs_char |=\n\t\t\t\t    ((unsigned int)jt_hexdigit(c) << ((3 - tok->st_pos) * 4));\n\t\t\t\ttok->st_pos++;\n\t\t\t\tif (tok->st_pos >= 4)\n\t\t\t\t\tbreak;\n\n\t\t\t\t(void)ADVANCE_CHAR(str, tok);\n\t\t\t\tif (!PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We're out of characters in the current call to\n\t\t\t\t\t * json_tokener_parse(), but a subsequent call might\n\t\t\t\t\t * provide us with more, so leave our current state\n\t\t\t\t\t * as-is (including tok->high_surrogate) and return.\n\t\t\t\t\t */\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttok->st_pos = 0;\n\n\t\t\t/* Now, we have a full \\uNNNN sequence in tok->ucs_char */\n\n\t\t\t/* If the *previous* sequence was a high surrogate ... */\n\t\t\tif (tok->high_surrogate)\n\t\t\t{\n\t\t\t\tif (IS_LOW_SURROGATE(tok->ucs_char))\n\t\t\t\t{\n\t\t\t\t\t/* Recalculate the ucs_char, then fall thru to process normally */\n\t\t\t\t\ttok->ucs_char = DECODE_SURROGATE_PAIR(tok->high_surrogate,\n\t\t\t\t\t                                      tok->ucs_char);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* High surrogate was not followed by a low surrogate\n\t\t\t\t\t * Replace the high and process the rest normally\n\t\t\t\t\t */\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb,\n\t\t\t\t\t                           (char *)utf8_replacement_char, 3);\n\t\t\t\t}\n\t\t\t\ttok->high_surrogate = 0;\n\t\t\t}\n\n\t\t\tif (tok->ucs_char < 0x80)\n\t\t\t{\n\t\t\t\tunsigned char unescaped_utf[1];\n\t\t\t\tunescaped_utf[0] = tok->ucs_char;\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)unescaped_utf, 1);\n\t\t\t}\n\t\t\telse if (tok->ucs_char < 0x800)\n\t\t\t{\n\t\t\t\tunsigned char unescaped_utf[2];\n\t\t\t\tunescaped_utf[0] = 0xc0 | (tok->ucs_char >> 6);\n\t\t\t\tunescaped_utf[1] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)unescaped_utf, 2);\n\t\t\t}\n\t\t\telse if (IS_HIGH_SURROGATE(tok->ucs_char))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The next two characters should be \\u, HOWEVER,\n\t\t\t\t * we can't simply peek ahead here, because the\n\t\t\t\t * characters we need might not be passed to us\n\t\t\t\t * until a subsequent call to json_tokener_parse.\n\t\t\t\t * Instead, transition through a couple of states.\n\t\t\t\t * (now):\n\t\t\t\t *   _escape_unicode => _unicode_need_escape\n\t\t\t\t * (see a '\\\\' char):\n\t\t\t\t *   _unicode_need_escape => _unicode_need_u\n\t\t\t\t * (see a 'u' char):\n\t\t\t\t *   _unicode_need_u => _escape_unicode\n\t\t\t\t *      ...and we'll end up back around here.\n\t\t\t\t */\n\t\t\t\ttok->high_surrogate = tok->ucs_char;\n\t\t\t\ttok->ucs_char = 0;\n\t\t\t\tstate = json_tokener_state_escape_unicode_need_escape;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (IS_LOW_SURROGATE(tok->ucs_char))\n\t\t\t{\n\t\t\t\t/* Got a low surrogate not preceded by a high */\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)utf8_replacement_char, 3);\n\t\t\t}\n\t\t\telse if (tok->ucs_char < 0x10000)\n\t\t\t{\n\t\t\t\tunsigned char unescaped_utf[3];\n\t\t\t\tunescaped_utf[0] = 0xe0 | (tok->ucs_char >> 12);\n\t\t\t\tunescaped_utf[1] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t\t\tunescaped_utf[2] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)unescaped_utf, 3);\n\t\t\t}\n\t\t\telse if (tok->ucs_char < 0x110000)\n\t\t\t{\n\t\t\t\tunsigned char unescaped_utf[4];\n\t\t\t\tunescaped_utf[0] = 0xf0 | ((tok->ucs_char >> 18) & 0x07);\n\t\t\t\tunescaped_utf[1] = 0x80 | ((tok->ucs_char >> 12) & 0x3f);\n\t\t\t\tunescaped_utf[2] = 0x80 | ((tok->ucs_char >> 6) & 0x3f);\n\t\t\t\tunescaped_utf[3] = 0x80 | (tok->ucs_char & 0x3f);\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)unescaped_utf, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Don't know what we got--insert the replacement char */\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)utf8_replacement_char, 3);\n\t\t\t}\n\t\t\tstate = saved_state; // i.e. _state_string or _state_object_field\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_escape_unicode_need_escape:\n\t\t\t// We get here after processing a high_surrogate\n\t\t\t// require a '\\\\' char\n\t\t\tif (!c || c != '\\\\')\n\t\t\t{\n\t\t\t\t/* Got a high surrogate without another sequence following\n\t\t\t\t * it.  Put a replacement char in for the high surrogate\n\t\t\t\t * and pop back up to _state_string or _state_object_field.\n\t\t\t\t */\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)utf8_replacement_char, 3);\n\t\t\t\ttok->high_surrogate = 0;\n\t\t\t\ttok->ucs_char = 0;\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tstate = saved_state;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tstate = json_tokener_state_escape_unicode_need_u;\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_escape_unicode_need_u:\n\t\t\t/* We already had a \\ char, check that it's \\u */\n\t\t\tif (!c || c != 'u')\n\t\t\t{\n\t\t\t\t/* Got a high surrogate with some non-unicode escape\n\t\t\t\t * sequence following it.\n\t\t\t\t * Put a replacement char in for the high surrogate\n\t\t\t\t * and handle the escape sequence normally.\n\t\t\t\t */\n\t\t\t\tprintbuf_memappend_checked(tok->pb, (char *)utf8_replacement_char, 3);\n\t\t\t\ttok->high_surrogate = 0;\n\t\t\t\ttok->ucs_char = 0;\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tstate = json_tokener_state_string_escape;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tstate = json_tokener_state_escape_unicode;\n\t\t\tbreak;\n\n\t\t\t// ===================================================\n\n\t\tcase json_tokener_state_boolean:\n\t\t{\n\t\t\tint size1, size2;\n\t\t\tprintbuf_memappend_checked(tok->pb, &c, 1);\n\t\t\tsize1 = json_min(tok->st_pos + 1, json_true_str_len);\n\t\t\tsize2 = json_min(tok->st_pos + 1, json_false_str_len);\n\t\t\tif ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t     strncasecmp(json_true_str, tok->pb->buf, size1) == 0) ||\n\t\t\t    (strncmp(json_true_str, tok->pb->buf, size1) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_true_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_boolean(1);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((!(tok->flags & JSON_TOKENER_STRICT) &&\n\t\t\t          strncasecmp(json_false_str, tok->pb->buf, size2) == 0) ||\n\t\t\t         (strncmp(json_false_str, tok->pb->buf, size2) == 0))\n\t\t\t{\n\t\t\t\tif (tok->st_pos == json_false_str_len)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_boolean(0);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tgoto redo_char;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_boolean;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttok->st_pos++;\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_number:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\tint case_len = 0;\n\t\t\tint is_exponent = 0;\n\t\t\tint neg_sign_ok = 1;\n\t\t\tint pos_sign_ok = 0;\n\t\t\tif (printbuf_length(tok->pb) > 0)\n\t\t\t{\n\t\t\t\t/* We don't save all state from the previous incremental parse\n\t\t\t\t   so we need to re-generate it based on the saved string so far.\n\t\t\t\t */\n\t\t\t\tchar *e_loc = strchr(tok->pb->buf, 'e');\n\t\t\t\tif (!e_loc)\n\t\t\t\t\te_loc = strchr(tok->pb->buf, 'E');\n\t\t\t\tif (e_loc)\n\t\t\t\t{\n\t\t\t\t\tchar *last_saved_char =\n\t\t\t\t\t    &tok->pb->buf[printbuf_length(tok->pb) - 1];\n\t\t\t\t\tis_exponent = 1;\n\t\t\t\t\tpos_sign_ok = neg_sign_ok = 1;\n\t\t\t\t\t/* If the \"e\" isn't at the end, we can't start with a '-' */\n\t\t\t\t\tif (e_loc != last_saved_char)\n\t\t\t\t\t{\n\t\t\t\t\t\tneg_sign_ok = 0;\n\t\t\t\t\t\tpos_sign_ok = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// else leave it set to 1, i.e. start of the new input\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (c && ((c >= '0' && c <= '9') ||\n\t\t\t             (!is_exponent && (c == 'e' || c == 'E')) ||\n\t\t\t             (neg_sign_ok && c == '-') || (pos_sign_ok && c == '+') ||\n\t\t\t             (!tok->is_double && c == '.')))\n\t\t\t{\n\t\t\t\tpos_sign_ok = neg_sign_ok = 0;\n\t\t\t\t++case_len;\n\n\t\t\t\t/* non-digit characters checks */\n\t\t\t\t/* note: since the main loop condition to get here was\n\t\t\t\t * an input starting with 0-9 or '-', we are\n\t\t\t\t * protected from input starting with '.' or\n\t\t\t\t * e/E.\n\t\t\t\t */\n\t\t\t\tswitch (c)\n\t\t\t\t{\n\t\t\t\tcase '.':\n\t\t\t\t\ttok->is_double = 1;\n\t\t\t\t\tpos_sign_ok = 1;\n\t\t\t\t\tneg_sign_ok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e': /* FALLTHRU */\n\t\t\t\tcase 'E':\n\t\t\t\t\tis_exponent = 1;\n\t\t\t\t\ttok->is_double = 1;\n\t\t\t\t\t/* the exponent part can begin with a negative sign */\n\t\t\t\t\tpos_sign_ok = neg_sign_ok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t}\n\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start, case_len);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t\tNow we know c isn't a valid number char, but check whether\n\t\t\t\tit might have been intended to be, and return a potentially\n\t\t\t\tmore understandable error right away.\n\t\t\t\tHowever, if we're at the top-level, use the number as-is\n\t\t\t\tbecause c can be part of a new object to parse on the\n\t\t\t\tnext call to json_tokener_parse().\n\t\t\t */\n\t\t\tif (tok->depth > 0 && c != ',' && c != ']' && c != '}' && c != '/' &&\n\t\t\t    c != 'I' && c != 'i' && !is_ws_char(c))\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (case_len > 0)\n\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start, case_len);\n\n\t\t\t// Check for -Infinity\n\t\t\tif (tok->pb->buf[0] == '-' && case_len <= 1 && (c == 'i' || c == 'I'))\n\t\t\t{\n\t\t\t\tstate = json_tokener_state_inf;\n\t\t\t\ttok->st_pos = 0;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tif (tok->is_double && !(tok->flags & JSON_TOKENER_STRICT))\n\t\t\t{\n\t\t\t\t/* Trim some chars off the end, to allow things\n\t\t\t\t   like \"123e+\" to parse ok. */\n\t\t\t\twhile (printbuf_length(tok->pb) > 1)\n\t\t\t\t{\n\t\t\t\t\tchar last_char = tok->pb->buf[printbuf_length(tok->pb) - 1];\n\t\t\t\t\tif (last_char != 'e' && last_char != 'E' &&\n\t\t\t\t\t    last_char != '-' && last_char != '+')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttok->pb->buf[printbuf_length(tok->pb) - 1] = '\\0';\n\t\t\t\t\tprintbuf_length(tok->pb)--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t{\n\t\t\t\tint64_t num64;\n\t\t\t\tuint64_t numuint64;\n\t\t\t\tdouble numd;\n\t\t\t\tif (!tok->is_double && tok->pb->buf[0] == '-' &&\n\t\t\t\t    json_parse_int64(tok->pb->buf, &num64) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (errno == ERANGE && (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tcurrent = json_object_new_int64(num64);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!tok->is_double && tok->pb->buf[0] != '-' &&\n\t\t\t\t         json_parse_uint64(tok->pb->buf, &numuint64) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (errno == ERANGE && (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (numuint64 && tok->pb->buf[0] == '0' &&\n\t\t\t\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (numuint64 <= INT64_MAX)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum64 = (uint64_t)numuint64;\n\t\t\t\t\t\tcurrent = json_object_new_int64(num64);\n\t\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrent = json_object_new_uint64(numuint64);\n\t\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tok->is_double &&\n\t\t\t\t         json_tokener_parse_double(\n\t\t\t\t             tok->pb->buf, printbuf_length(tok->pb), &numd) == 0)\n\t\t\t\t{\n\t\t\t\t\tcurrent = json_object_new_double_s(numd, tok->pb->buf);\n\t\t\t\t\tif (current == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_number;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_array_after_sep:\n\t\tcase json_tokener_state_array:\n\t\t\tif (c == ']')\n\t\t\t{\n\t\t\t\t// Minimize memory usage; assume parsed objs are unlikely to be changed\n\t\t\t\tjson_object_array_shrink(current, 0);\n\n\t\t\t\tif (state == json_tokener_state_array_after_sep &&\n\t\t\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tok->depth >= tok->max_depth - 1)\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_depth;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tstate = json_tokener_state_array_add;\n\t\t\t\ttok->depth++;\n\t\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\t\tgoto redo_char;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_array_add:\n\t\t\tif (json_object_array_add(current, obj) != 0)\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsaved_state = json_tokener_state_array_sep;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_array_sep:\n\t\t\tif (c == ']')\n\t\t\t{\n\t\t\t\t// Minimize memory usage; assume parsed objs are unlikely to be changed\n\t\t\t\tjson_object_array_shrink(current, 0);\n\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse if (c == ',')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_array_after_sep;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_array;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_object_field_start:\n\t\tcase json_tokener_state_object_field_start_after_sep:\n\t\t\tif (c == '}')\n\t\t\t{\n\t\t\t\tif (state == json_tokener_state_object_field_start_after_sep &&\n\t\t\t\t    (tok->flags & JSON_TOKENER_STRICT))\n\t\t\t\t{\n\t\t\t\t\ttok->err = json_tokener_error_parse_unexpected;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse if (c == '\"' || c == '\\'')\n\t\t\t{\n\t\t\t\ttok->quote_char = c;\n\t\t\t\tprintbuf_reset(tok->pb);\n\t\t\t\tstate = json_tokener_state_object_field;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_object_key_name;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_object_field:\n\t\t{\n\t\t\t/* Advance until we change state */\n\t\t\tconst char *case_start = str;\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tif (c == tok->quote_char)\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tobj_field_name = strdup(tok->pb->buf);\n\t\t\t\t\tif (obj_field_name == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_state = json_tokener_state_object_field_end;\n\t\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (c == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tsaved_state = json_tokener_state_object_field;\n\t\t\t\t\tstate = json_tokener_state_string_escape;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ADVANCE_CHAR(str, tok) || !PEEK_CHAR(c, tok))\n\t\t\t\t{\n\t\t\t\t\tprintbuf_memappend_checked(tok->pb, case_start,\n\t\t\t\t\t                           str - case_start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase json_tokener_state_object_field_end:\n\t\t\tif (c == ':')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_object_value;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_object_key_sep;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase json_tokener_state_object_value:\n\t\t\tif (tok->depth >= tok->max_depth - 1)\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_depth;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstate = json_tokener_state_object_value_add;\n\t\t\ttok->depth++;\n\t\t\tjson_tokener_reset_level(tok, tok->depth);\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_object_value_add:\n\t\t\tif (json_object_object_add(current, obj_field_name, obj) != 0)\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_memory;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfree(obj_field_name);\n\t\t\tobj_field_name = NULL;\n\t\t\tsaved_state = json_tokener_state_object_sep;\n\t\t\tstate = json_tokener_state_eatws;\n\t\t\tgoto redo_char;\n\n\t\tcase json_tokener_state_object_sep:\n\t\t\t/* { */\n\t\t\tif (c == '}')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_finish;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse if (c == ',')\n\t\t\t{\n\t\t\t\tsaved_state = json_tokener_state_object_field_start_after_sep;\n\t\t\t\tstate = json_tokener_state_eatws;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttok->err = json_tokener_error_parse_object_value_sep;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t(void)ADVANCE_CHAR(str, tok);\n\t\tif (!c) // This is the char *before* advancing\n\t\t\tbreak;\n\t} /* while(PEEK_CHAR) */\n\nout:\n\tif ((tok->flags & JSON_TOKENER_VALIDATE_UTF8) && (nBytes != 0))\n\t{\n\t\ttok->err = json_tokener_error_parse_utf8_string;\n\t}\n\tif (c && (state == json_tokener_state_finish) && (tok->depth == 0) &&\n\t    (tok->flags & (JSON_TOKENER_STRICT | JSON_TOKENER_ALLOW_TRAILING_CHARS)) ==\n\t        JSON_TOKENER_STRICT)\n\t{\n\t\t/* unexpected char after JSON data */\n\t\ttok->err = json_tokener_error_parse_unexpected;\n\t}\n\tif (!c)\n\t{\n\t\t/* We hit an eof char (0) */\n\t\tif (state != json_tokener_state_finish && saved_state != json_tokener_state_finish)\n\t\t\ttok->err = json_tokener_error_parse_eof;\n\t}\n\n#ifdef HAVE_USELOCALE\n\tuselocale(oldlocale);\n\tfreelocale(newloc);\n#elif defined(HAVE_SETLOCALE)\n\tsetlocale(LC_NUMERIC, oldlocale);\n\tfree(oldlocale);\n#endif\n\n\tif (tok->err == json_tokener_success)\n\t{\n\t\tjson_object *ret = json_object_get(current);\n\t\tint ii;\n\n\t\t/* Partially reset, so we parse additional objects on subsequent calls. */\n\t\tfor (ii = tok->depth; ii >= 0; ii--)\n\t\t\tjson_tokener_reset_level(tok, ii);\n\t\treturn ret;\n\t}\n\n\tMC_DEBUG(\"json_tokener_parse_ex: error %s at offset %d\\n\", json_tokener_errors[tok->err],\n\t         tok->char_offset);\n\treturn NULL;\n}\n\nstatic json_bool json_tokener_validate_utf8(const char c, unsigned int *nBytes)\n{\n\tunsigned char chr = c;\n\tif (*nBytes == 0)\n\t{\n\t\tif (chr >= 0x80)\n\t\t{\n\t\t\tif ((chr & 0xe0) == 0xc0)\n\t\t\t\t*nBytes = 1;\n\t\t\telse if ((chr & 0xf0) == 0xe0)\n\t\t\t\t*nBytes = 2;\n\t\t\telse if ((chr & 0xf8) == 0xf0)\n\t\t\t\t*nBytes = 3;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif ((chr & 0xC0) != 0x80)\n\t\t\treturn 0;\n\t\t(*nBytes)--;\n\t}\n\treturn 1;\n}\n\nvoid json_tokener_set_flags(struct json_tokener *tok, int flags)\n{\n\ttok->flags = flags;\n}\n\nsize_t json_tokener_get_parse_end(struct json_tokener *tok)\n{\n\tassert(tok->char_offset >= 0); /* Drop this line when char_offset becomes a size_t */\n\treturn (size_t)tok->char_offset;\n}\n\nstatic int json_tokener_parse_double(const char *buf, int len, double *retval)\n{\n\tchar *end;\n\t*retval = strtod(buf, &end);\n\tif (buf + len == end)\n\t\treturn 0; // It worked\n\treturn 1;\n}\n"
        },
        {
          "name": "json_tokener.h",
          "type": "blob",
          "size": 10.396484375,
          "content": "/*\n * $Id: json_tokener.h,v 1.10 2006/07/25 03:24:50 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Methods to parse an input string into a tree of json_object objects.\n */\n#ifndef _json_tokener_h_\n#define _json_tokener_h_\n\n#include \"json_object.h\"\n#include <stddef.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nenum json_tokener_error\n{\n\tjson_tokener_success,\n\tjson_tokener_continue,\n\tjson_tokener_error_depth,\n\tjson_tokener_error_parse_eof,\n\tjson_tokener_error_parse_unexpected,\n\tjson_tokener_error_parse_null,\n\tjson_tokener_error_parse_boolean,\n\tjson_tokener_error_parse_number,\n\tjson_tokener_error_parse_array,\n\tjson_tokener_error_parse_object_key_name,\n\tjson_tokener_error_parse_object_key_sep,\n\tjson_tokener_error_parse_object_value_sep,\n\tjson_tokener_error_parse_string,\n\tjson_tokener_error_parse_comment,\n\tjson_tokener_error_parse_utf8_string,\n\tjson_tokener_error_size,   /* A string longer than INT32_MAX was passed as input */\n\tjson_tokener_error_memory  /* Failed to allocate memory */\n};\n\n/**\n * @deprecated Don't use this outside of json_tokener.c, it will be made private in a future release.\n */\nenum json_tokener_state\n{\n\tjson_tokener_state_eatws,\n\tjson_tokener_state_start,\n\tjson_tokener_state_finish,\n\tjson_tokener_state_null,\n\tjson_tokener_state_comment_start,\n\tjson_tokener_state_comment,\n\tjson_tokener_state_comment_eol,\n\tjson_tokener_state_comment_end,\n\tjson_tokener_state_string,\n\tjson_tokener_state_string_escape,\n\tjson_tokener_state_escape_unicode,\n\tjson_tokener_state_escape_unicode_need_escape,\n\tjson_tokener_state_escape_unicode_need_u,\n\tjson_tokener_state_boolean,\n\tjson_tokener_state_number,\n\tjson_tokener_state_array,\n\tjson_tokener_state_array_add,\n\tjson_tokener_state_array_sep,\n\tjson_tokener_state_object_field_start,\n\tjson_tokener_state_object_field,\n\tjson_tokener_state_object_field_end,\n\tjson_tokener_state_object_value,\n\tjson_tokener_state_object_value_add,\n\tjson_tokener_state_object_sep,\n\tjson_tokener_state_array_after_sep,\n\tjson_tokener_state_object_field_start_after_sep,\n\tjson_tokener_state_inf\n};\n\n/**\n * @deprecated Don't use this outside of json_tokener.c, it will be made private in a future release.\n */\nstruct json_tokener_srec\n{\n\tenum json_tokener_state state, saved_state;\n\tstruct json_object *obj;\n\tstruct json_object *current;\n\tchar *obj_field_name;\n};\n\n#define JSON_TOKENER_DEFAULT_DEPTH 32\n\n/**\n * Internal state of the json parser.\n * Do not access any fields of this structure directly.\n * Its definition is published due to historical limitations\n * in the json tokener API, and will be changed to be an opaque\n * type in the future.\n */\nstruct json_tokener\n{\n\t/**\n\t * @deprecated Do not access any of these fields outside of json_tokener.c\n\t */\n\tchar *str;\n\tstruct printbuf *pb;\n\tint max_depth, depth, is_double, st_pos;\n\t/**\n\t * @deprecated See json_tokener_get_parse_end() instead.\n\t */\n\tint char_offset;\n\t/**\n\t * @deprecated See json_tokener_get_error() instead.\n\t */\n\tenum json_tokener_error err;\n\tunsigned int ucs_char, high_surrogate;\n\tchar quote_char;\n\tstruct json_tokener_srec *stack;\n\tint flags;\n};\n\n/**\n * Return the offset of the byte after the last byte parsed\n * relative to the start of the most recent string passed in\n * to json_tokener_parse_ex().  i.e. this is where parsing\n * would start again if the input contains another JSON object\n * after the currently parsed one.\n *\n * Note that when multiple parse calls are issued, this is *not* the\n * total number of characters parsed.\n *\n * In the past this would have been accessed as tok->char_offset.\n *\n * See json_tokener_parse_ex() for an example of how to use this.\n */\nJSON_EXPORT size_t json_tokener_get_parse_end(struct json_tokener *tok);\n\n/**\n * @deprecated Unused in json-c code\n */\ntypedef struct json_tokener json_tokener;\n\n/**\n * Be strict when parsing JSON input.  Use caution with\n * this flag as what is considered valid may become more\n * restrictive from one release to the next, causing your\n * code to fail on previously working input.\n *\n * Note that setting this will also effectively disable parsing\n * of multiple json objects in a single character stream\n * (e.g. {\"foo\":123}{\"bar\":234}); if you want to allow that\n * also set JSON_TOKENER_ALLOW_TRAILING_CHARS\n *\n * This flag is not set by default.\n *\n * @see json_tokener_set_flags()\n */\n#define JSON_TOKENER_STRICT 0x01\n\n/**\n * Use with JSON_TOKENER_STRICT to allow trailing characters after the\n * first parsed object.\n *\n * @see json_tokener_set_flags()\n */\n#define JSON_TOKENER_ALLOW_TRAILING_CHARS 0x02\n\n/**\n * Cause json_tokener_parse_ex() to validate that input is UTF8.\n * If this flag is specified and validation fails, then\n * json_tokener_get_error(tok) will return\n * json_tokener_error_parse_utf8_string\n *\n * This flag is not set by default.\n *\n * @see json_tokener_set_flags()\n */\n#define JSON_TOKENER_VALIDATE_UTF8 0x10\n\n/**\n * Given an error previously returned by json_tokener_get_error(),\n * return a human readable description of the error.\n *\n * @return a generic error message is returned if an invalid error value is provided.\n */\nJSON_EXPORT const char *json_tokener_error_desc(enum json_tokener_error jerr);\n\n/**\n * Retrieve the error caused by the last call to json_tokener_parse_ex(),\n * or json_tokener_success if there is no error.\n *\n * When parsing a JSON string in pieces, if the tokener is in the middle\n * of parsing this will return json_tokener_continue.\n *\n * @see json_tokener_error_desc().\n */\nJSON_EXPORT enum json_tokener_error json_tokener_get_error(struct json_tokener *tok);\n\n/**\n * Allocate a new json_tokener.\n * When done using that to parse objects, free it with json_tokener_free().\n * See json_tokener_parse_ex() for usage details.\n */\nJSON_EXPORT struct json_tokener *json_tokener_new(void);\n\n/**\n * Allocate a new json_tokener with a custom max nesting depth.\n * The depth must be at least 1.\n * @see JSON_TOKENER_DEFAULT_DEPTH\n */\nJSON_EXPORT struct json_tokener *json_tokener_new_ex(int depth);\n\n/**\n * Free a json_tokener previously allocated with json_tokener_new().\n */\nJSON_EXPORT void json_tokener_free(struct json_tokener *tok);\n\n/**\n * Reset the state of a json_tokener, to prepare to parse a \n * brand new JSON object.\n */\nJSON_EXPORT void json_tokener_reset(struct json_tokener *tok);\n\n/**\n * Parse a json_object out of the string `str`.\n *\n * If you need more control over how the parsing occurs,\n * see json_tokener_parse_ex().\n */\nJSON_EXPORT struct json_object *json_tokener_parse(const char *str);\n\n/**\n * Parse a json_object out of the string `str`, but if it fails\n * return the error in `*error`.\n * @see json_tokener_parse()\n * @see json_tokener_parse_ex()\n */\nJSON_EXPORT struct json_object *json_tokener_parse_verbose(const char *str,\n                                                           enum json_tokener_error *error);\n\n/**\n * Set flags that control how parsing will be done.\n */\nJSON_EXPORT void json_tokener_set_flags(struct json_tokener *tok, int flags);\n\n/**\n * Parse a string and return a non-NULL json_object if a valid JSON value\n * is found.  The string does not need to be a JSON object or array;\n * it can also be a string, number or boolean value.\n *\n * A partial JSON string can be parsed.  If the parsing is incomplete,\n * NULL will be returned and json_tokener_get_error() will return\n * json_tokener_continue.\n * json_tokener_parse_ex() can then be called with additional bytes in str\n * to continue the parsing.\n *\n * If json_tokener_parse_ex() returns NULL and the error is anything other than\n * json_tokener_continue, a fatal error has occurred and parsing must be\n * halted.  Then, the tok object must not be reused until json_tokener_reset()\n * is called.\n *\n * When a valid JSON value is parsed, a non-NULL json_object will be\n * returned, with a reference count of one which belongs to the caller.  Also,\n * json_tokener_get_error() will return json_tokener_success. Be sure to check\n * the type with json_object_is_type() or json_object_get_type() before using\n * the object.\n *\n * Trailing characters after the parsed value do not automatically cause an\n * error.  It is up to the caller to decide whether to treat this as an\n * error or to handle the additional characters, perhaps by parsing another\n * json value starting from that point.\n *\n * If the caller knows that they are at the end of their input, the length\n * passed MUST include the final '\\0' character, so values with no inherent\n * end (i.e. numbers) can be properly parsed, rather than just returning\n * json_tokener_continue.\n *\n * Extra characters can be detected by comparing the value returned by\n * json_tokener_get_parse_end() against\n * the length of the last len parameter passed in.\n *\n * The tokener does \\b not maintain an internal buffer so the caller is\n * responsible for a subsequent call to json_tokener_parse_ex with an \n * appropriate str parameter starting with the extra characters.\n *\n * This interface is presently not 64-bit clean due to the int len argument\n * so the function limits the maximum string size to INT32_MAX (2GB).\n * If the function is called with len == -1 then strlen is called to check\n * the string length is less than INT32_MAX (2GB)\n *\n * Example:\n * @code\njson_object *jobj = NULL;\nconst char *mystring = NULL;\nint stringlen = 0;\nenum json_tokener_error jerr;\ndo {\n\tmystring = ...  // get JSON string, e.g. read from file, etc...\n\tstringlen = strlen(mystring);\n\tif (end_of_input)\n\t\tstringlen++;  // Include the '\\0' if we know we're at the end of input\n\tjobj = json_tokener_parse_ex(tok, mystring, stringlen);\n} while ((jerr = json_tokener_get_error(tok)) == json_tokener_continue);\nif (jerr != json_tokener_success)\n{\n\tfprintf(stderr, \"Error: %s\\n\", json_tokener_error_desc(jerr));\n\t// Handle errors, as appropriate for your application.\n}\nif (json_tokener_get_parse_end(tok) < stringlen)\n{\n\t// Handle extra characters after parsed object as desired.\n\t// e.g. issue an error, parse another object from that point, etc...\n}\n// Success, use jobj here.\n\n@endcode\n *\n * @param tok a json_tokener previously allocated with json_tokener_new()\n * @param str an string with any valid JSON expression, or portion of.  This does not need to be null terminated.\n * @param len the length of str\n */\nJSON_EXPORT struct json_object *json_tokener_parse_ex(struct json_tokener *tok, const char *str,\n                                                      int len);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_types.h",
          "type": "blob",
          "size": 1.626953125,
          "content": "/*\n * Copyright (c) 2020 Eric Hawicz\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n */\n\n#ifndef _json_types_h_\n#define _json_types_h_\n\n/**\n * @file\n * @brief Basic types used in a few places in json-c, but you should include \"json_object.h\" instead.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef JSON_EXPORT\n#if defined(_MSC_VER) && defined(JSON_C_DLL)\n#define JSON_EXPORT __declspec(dllexport)\n#else\n#define JSON_EXPORT extern\n#endif\n#endif\n\nstruct printbuf;\n\n/**\n * A structure to use with json_object_object_foreachC() loops.\n * Contains key, val and entry members.\n */\nstruct json_object_iter\n{\n\tchar *key;\n\tstruct json_object *val;\n\tstruct lh_entry *entry;\n};\ntypedef struct json_object_iter json_object_iter;\n\ntypedef int json_bool;\n\n/**\n * @brief The core type for all type of JSON objects handled by json-c\n */\ntypedef struct json_object json_object;\n\n/**\n * Type of custom user delete functions.  See json_object_set_serializer.\n */\ntypedef void(json_object_delete_fn)(struct json_object *jso, void *userdata);\n\n/**\n * Type of a custom serialization function.  See json_object_set_serializer.\n */\ntypedef int(json_object_to_json_string_fn)(struct json_object *jso, struct printbuf *pb, int level,\n                                           int flags);\n\n/* supported object types */\n\ntypedef enum json_type\n{\n\t/* If you change this, be sure to update json_type_to_name() too */\n\tjson_type_null,\n\tjson_type_boolean,\n\tjson_type_double,\n\tjson_type_int,\n\tjson_type_object,\n\tjson_type_array,\n\tjson_type_string\n} json_type;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_util.c",
          "type": "blob",
          "size": 6.7763671875,
          "content": "/*\n * $Id: json_util.c,v 1.4 2006/01/30 23:07:57 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"config.h\"\n#undef realloc\n\n#include \"strerror_override.h\"\n\n#include <limits.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif /* HAVE_SYS_TYPES_H */\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif /* HAVE_SYS_STAT_H */\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif /* HAVE_FCNTL_H */\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif /* HAVE_UNISTD_H */\n\n#ifdef _WIN32\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <io.h>\n#include <windows.h>\n#endif /* defined(_WIN32) */\n\n#if !defined(HAVE_OPEN) && defined(_WIN32)\n#define open _open\n#endif\n\n#include \"snprintf_compat.h\"\n\n#include \"debug.h\"\n#include \"json_inttypes.h\"\n#include \"json_object.h\"\n#include \"json_tokener.h\"\n#include \"json_util.h\"\n#include \"printbuf.h\"\n\nstatic int _json_object_to_fd(int fd, struct json_object *obj, int flags, const char *filename);\n\nstatic char _last_err[256] = \"\";\n\nconst char *json_util_get_last_err(void)\n{\n\tif (_last_err[0] == '\\0')\n\t\treturn NULL;\n\treturn _last_err;\n}\n\nvoid _json_c_set_last_err(const char *err_fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, err_fmt);\n\t// Ignore (attempted) overruns from snprintf\n\t(void)vsnprintf(_last_err, sizeof(_last_err), err_fmt, ap);\n\tva_end(ap);\n}\n\nstruct json_object *json_object_from_fd(int fd)\n{\n\treturn json_object_from_fd_ex(fd, -1);\n}\nstruct json_object *json_object_from_fd_ex(int fd, int in_depth)\n{\n\tstruct printbuf *pb;\n\tstruct json_object *obj;\n\tchar buf[JSON_FILE_BUF_SIZE];\n\tssize_t ret;\n\tint depth = JSON_TOKENER_DEFAULT_DEPTH;\n\tjson_tokener *tok;\n\n\tif (!(pb = printbuf_new()))\n\t{\n\t\t_json_c_set_last_err(\"json_object_from_fd_ex: printbuf_new failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (in_depth != -1)\n\t\tdepth = in_depth;\n\ttok = json_tokener_new_ex(depth);\n\tif (!tok)\n\t{\n\t\t_json_c_set_last_err(\n\t\t    \"json_object_from_fd_ex: unable to allocate json_tokener(depth=%d): %s\\n\",\n\t\t    depth, strerror(errno));\n\t\tprintbuf_free(pb);\n\t\treturn NULL;\n\t}\n\n\twhile ((ret = read(fd, buf, sizeof(buf))) > 0)\n\t{\n\t\tif (printbuf_memappend(pb, buf, ret) < 0)\n\t\t{\n#if JSON_FILE_BUF_SIZE > INT_MAX\n#error \"Can't append more than INT_MAX bytes at a time\"\n#endif\n\t\t\t_json_c_set_last_err(\n\t\t    \t\"json_object_from_fd_ex: failed to printbuf_memappend after reading %d+%d bytes: %s\", printbuf_length(pb), (int)ret, strerror(errno));\n\t\t\tjson_tokener_free(tok);\n\t\t\tprintbuf_free(pb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (ret < 0)\n\t{\n\t\t_json_c_set_last_err(\"json_object_from_fd_ex: error reading fd %d: %s\\n\", fd,\n\t\t                     strerror(errno));\n\t\tjson_tokener_free(tok);\n\t\tprintbuf_free(pb);\n\t\treturn NULL;\n\t}\n\n\tobj = json_tokener_parse_ex(tok, pb->buf, printbuf_length(pb));\n\tif (obj == NULL)\n\t\t_json_c_set_last_err(\"json_tokener_parse_ex failed: %s\\n\",\n\t\t                     json_tokener_error_desc(json_tokener_get_error(tok)));\n\n\tjson_tokener_free(tok);\n\tprintbuf_free(pb);\n\treturn obj;\n}\n\nstruct json_object *json_object_from_file(const char *filename)\n{\n\tstruct json_object *obj;\n\tint fd;\n\n\tif ((fd = open(filename, O_RDONLY)) < 0)\n\t{\n\t\t_json_c_set_last_err(\"json_object_from_file: error opening file %s: %s\\n\",\n\t\t                     filename, strerror(errno));\n\t\treturn NULL;\n\t}\n\tobj = json_object_from_fd(fd);\n\tclose(fd);\n\treturn obj;\n}\n\n/* extended \"format and write to file\" function */\n\nint json_object_to_file_ext(const char *filename, struct json_object *obj, int flags)\n{\n\tint fd, ret;\n\tint saved_errno;\n\n\tif (!obj)\n\t{\n\t\t_json_c_set_last_err(\"json_object_to_file_ext: object is null\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((fd = open(filename, O_WRONLY | O_TRUNC | O_CREAT, 0644)) < 0)\n\t{\n\t\t_json_c_set_last_err(\"json_object_to_file_ext: error opening file %s: %s\\n\",\n\t\t                     filename, strerror(errno));\n\t\treturn -1;\n\t}\n\tret = _json_object_to_fd(fd, obj, flags, filename);\n\tsaved_errno = errno;\n\tclose(fd);\n\terrno = saved_errno;\n\treturn ret;\n}\n\nint json_object_to_fd(int fd, struct json_object *obj, int flags)\n{\n\tif (!obj)\n\t{\n\t\t_json_c_set_last_err(\"json_object_to_fd: object is null\\n\");\n\t\treturn -1;\n\t}\n\n\treturn _json_object_to_fd(fd, obj, flags, NULL);\n}\nstatic int _json_object_to_fd(int fd, struct json_object *obj, int flags, const char *filename)\n{\n\tssize_t ret;\n\tconst char *json_str;\n\tsize_t wpos, wsize;\n\n\tfilename = filename ? filename : \"(fd)\";\n\n\tif (!(json_str = json_object_to_json_string_ext(obj, flags)))\n\t{\n\t\treturn -1;\n\t}\n\n\twsize = strlen(json_str);\n\twpos = 0;\n\twhile (wpos < wsize)\n\t{\n\t\tif ((ret = write(fd, json_str + wpos, wsize - wpos)) < 0)\n\t\t{\n\t\t\t_json_c_set_last_err(\"json_object_to_fd: error writing file %s: %s\\n\",\n\t\t\t                     filename, strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* because of the above check for ret < 0, we can safely cast and add */\n\t\twpos += (size_t)ret;\n\t}\n\n\treturn 0;\n}\n\n// backwards compatible \"format and write to file\" function\n\nint json_object_to_file(const char *filename, struct json_object *obj)\n{\n\treturn json_object_to_file_ext(filename, obj, JSON_C_TO_STRING_PLAIN);\n}\n\n// Deprecated json_parse_double function.  See json_tokener_parse_double instead.\nint json_parse_double(const char *buf, double *retval)\n{\n\tchar *end;\n\t*retval = strtod(buf, &end);\n\treturn end == buf ? 1 : 0;\n}\n\nint json_parse_int64(const char *buf, int64_t *retval)\n{\n\tchar *end = NULL;\n\tint64_t val;\n\n\terrno = 0;\n\tval = strtoll(buf, &end, 10);\n\tif (end != buf)\n\t\t*retval = val;\n\tif ((val == 0 && errno != 0) || (end == buf))\n\t{\n\t\terrno = EINVAL;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint json_parse_uint64(const char *buf, uint64_t *retval)\n{\n\tchar *end = NULL;\n\tuint64_t val;\n\n\terrno = 0;\n\twhile (*buf == ' ')\n\t\tbuf++;\n\tif (*buf == '-')\n\t\treturn 1; /* error: uint cannot be negative */\n\n\tval = strtoull(buf, &end, 10);\n\tif (end != buf)\n\t\t*retval = val;\n\tif ((val == 0 && errno != 0) || (end == buf))\n\t{\n\t\terrno = EINVAL;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#ifndef HAVE_REALLOC\nvoid *rpl_realloc(void *p, size_t n)\n{\n\tif (n == 0)\n\t\tn = 1;\n\tif (p == 0)\n\t\treturn malloc(n);\n\treturn realloc(p, n);\n}\n#endif\n\n#define NELEM(a) (sizeof(a) / sizeof(a[0]))\n/* clang-format off */\nstatic const char *json_type_name[] = {\n\t/* If you change this, be sure to update the enum json_type definition too */\n\t\"null\",\n\t\"boolean\",\n\t\"double\",\n\t\"int\",\n\t\"object\",\n\t\"array\",\n\t\"string\",\n};\n/* clang-format on */\n\nconst char *json_type_to_name(enum json_type o_type)\n{\n\tint o_type_int = (int)o_type;\n\tif (o_type_int < 0 || o_type_int >= (int)NELEM(json_type_name))\n\t{\n\t\t_json_c_set_last_err(\"json_type_to_name: type %d is out of range [0,%u]\\n\", o_type,\n\t\t                     (unsigned)NELEM(json_type_name));\n\t\treturn NULL;\n\t}\n\treturn json_type_name[o_type];\n}\n"
        },
        {
          "name": "json_util.h",
          "type": "blob",
          "size": 3.828125,
          "content": "/*\n * $Id: json_util.h,v 1.4 2006/01/30 23:07:57 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Miscllaneous utility functions and macros.\n */\n#ifndef _json_util_h_\n#define _json_util_h_\n\n#include \"json_object.h\"\n\n#ifndef json_min\n#define json_min(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#ifndef json_max\n#define json_max(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define JSON_FILE_BUF_SIZE 4096\n\n/* utility functions */\n/**\n * Read the full contents of the given file, then convert it to a\n * json_object using json_tokener_parse().\n *\n * Returns NULL on failure.  See json_util_get_last_err() for details.\n */\nJSON_EXPORT struct json_object *json_object_from_file(const char *filename);\n\n/**\n * Create a JSON object from already opened file descriptor.\n *\n * This function can be helpful, when you opened the file already,\n * e.g. when you have a temp file.\n * Note, that the fd must be readable at the actual position, i.e.\n * use lseek(fd, 0, SEEK_SET) before.\n *\n * The depth argument specifies the maximum object depth to pass to\n * json_tokener_new_ex().  When depth == -1, JSON_TOKENER_DEFAULT_DEPTH\n * is used instead.\n *\n * Returns NULL on failure.  See json_util_get_last_err() for details.\n */\nJSON_EXPORT struct json_object *json_object_from_fd_ex(int fd, int depth);\n\n/**\n * Create a JSON object from an already opened file descriptor, using\n * the default maximum object depth. (JSON_TOKENER_DEFAULT_DEPTH)\n *\n * See json_object_from_fd_ex() for details.\n */\nJSON_EXPORT struct json_object *json_object_from_fd(int fd);\n\n/**\n * Equivalent to:\n *   json_object_to_file_ext(filename, obj, JSON_C_TO_STRING_PLAIN);\n *\n * Returns -1 if something fails.  See json_util_get_last_err() for details.\n */\nJSON_EXPORT int json_object_to_file(const char *filename, struct json_object *obj);\n\n/**\n * Open and truncate the given file, creating it if necessary, then\n * convert the json_object to a string and write it to the file.\n *\n * Returns -1 if something fails.  See json_util_get_last_err() for details.\n */\nJSON_EXPORT int json_object_to_file_ext(const char *filename, struct json_object *obj, int flags);\n\n/**\n * Convert the json_object to a string and write it to the file descriptor.\n * Handles partial writes and will keep writing until done, or an error\n * occurs.\n *\n * @param fd an open, writable file descriptor to write to\n * @param obj the object to serializer and write\n * @param flags flags to pass to json_object_to_json_string_ext()\n * @return -1 if something fails.  See json_util_get_last_err() for details.\n */\nJSON_EXPORT int json_object_to_fd(int fd, struct json_object *obj, int flags);\n\n/**\n * Return the last error from various json-c functions, including:\n * json_object_to_file{,_ext}, json_object_to_fd() or\n * json_object_from_{file,fd}, or NULL if there is none.\n */\nJSON_EXPORT const char *json_util_get_last_err(void);\n\n/**\n * A parsing helper for integer values.  Returns 0 on success,\n * with the parsed value assigned to *retval.  Overflow/underflow\n * are NOT considered errors, but errno will be set to ERANGE,\n * just like the strtol/strtoll functions do.\n */\nJSON_EXPORT int json_parse_int64(const char *buf, int64_t *retval);\n/**\n * A parsing help for integer values, providing one extra bit of \n * magnitude beyond json_parse_int64().\n */\nJSON_EXPORT int json_parse_uint64(const char *buf, uint64_t *retval);\n/**\n * @deprecated\n */\nJSON_EXPORT int json_parse_double(const char *buf, double *retval);\n\n/**\n * Return a string describing the type of the object.\n * e.g. \"int\", or \"object\", etc...\n */\nJSON_EXPORT const char *json_type_to_name(enum json_type o_type);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "json_visit.c",
          "type": "blob",
          "size": 3.8876953125,
          "content": "/*\n * Copyright (c) 2016 Eric Haszlakiewicz\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n */\n\n#include <stdio.h>\n\n#include \"config.h\"\n#include \"json_inttypes.h\"\n#include \"json_object.h\"\n#include \"json_visit.h\"\n#include \"linkhash.h\"\n\nstatic int _json_c_visit(json_object *jso, json_object *parent_jso, const char *jso_key,\n                         size_t *jso_index, json_c_visit_userfunc *userfunc, void *userarg);\n\nint json_c_visit(json_object *jso, int future_flags, json_c_visit_userfunc *userfunc, void *userarg)\n{\n\tint ret = _json_c_visit(jso, NULL, NULL, NULL, userfunc, userarg);\n\tswitch (ret)\n\t{\n\tcase JSON_C_VISIT_RETURN_CONTINUE:\n\tcase JSON_C_VISIT_RETURN_SKIP:\n\tcase JSON_C_VISIT_RETURN_POP:\n\tcase JSON_C_VISIT_RETURN_STOP: return 0;\n\tdefault: return JSON_C_VISIT_RETURN_ERROR;\n\t}\n}\nstatic int _json_c_visit(json_object *jso, json_object *parent_jso, const char *jso_key,\n                         size_t *jso_index, json_c_visit_userfunc *userfunc, void *userarg)\n{\n\tint userret = userfunc(jso, 0, parent_jso, jso_key, jso_index, userarg);\n\tswitch (userret)\n\t{\n\tcase JSON_C_VISIT_RETURN_CONTINUE: break;\n\tcase JSON_C_VISIT_RETURN_SKIP:\n\tcase JSON_C_VISIT_RETURN_POP:\n\tcase JSON_C_VISIT_RETURN_STOP:\n\tcase JSON_C_VISIT_RETURN_ERROR: return userret;\n\tdefault:\n\t\tfprintf(stderr, \"ERROR: invalid return value from json_c_visit userfunc: %d\\n\",\n\t\t        userret);\n\t\treturn JSON_C_VISIT_RETURN_ERROR;\n\t}\n\n\tswitch (json_object_get_type(jso))\n\t{\n\tcase json_type_null:\n\tcase json_type_boolean:\n\tcase json_type_double:\n\tcase json_type_int:\n\tcase json_type_string:\n\t\t// we already called userfunc above, move on to the next object\n\t\treturn JSON_C_VISIT_RETURN_CONTINUE;\n\n\tcase json_type_object:\n\t{\n\t\tjson_object_object_foreach(jso, key, child)\n\t\t{\n\t\t\tuserret = _json_c_visit(child, jso, key, NULL, userfunc, userarg);\n\t\t\tif (userret == JSON_C_VISIT_RETURN_POP)\n\t\t\t\tbreak;\n\t\t\tif (userret == JSON_C_VISIT_RETURN_STOP ||\n\t\t\t    userret == JSON_C_VISIT_RETURN_ERROR)\n\t\t\t\treturn userret;\n\t\t\tif (userret != JSON_C_VISIT_RETURN_CONTINUE &&\n\t\t\t    userret != JSON_C_VISIT_RETURN_SKIP)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"INTERNAL ERROR: _json_c_visit returned %d\\n\",\n\t\t\t\t        userret);\n\t\t\t\treturn JSON_C_VISIT_RETURN_ERROR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase json_type_array:\n\t{\n\t\tsize_t array_len = json_object_array_length(jso);\n\t\tsize_t ii;\n\t\tfor (ii = 0; ii < array_len; ii++)\n\t\t{\n\t\t\tjson_object *child = json_object_array_get_idx(jso, ii);\n\t\t\tuserret = _json_c_visit(child, jso, NULL, &ii, userfunc, userarg);\n\t\t\tif (userret == JSON_C_VISIT_RETURN_POP)\n\t\t\t\tbreak;\n\t\t\tif (userret == JSON_C_VISIT_RETURN_STOP ||\n\t\t\t    userret == JSON_C_VISIT_RETURN_ERROR)\n\t\t\t\treturn userret;\n\t\t\tif (userret != JSON_C_VISIT_RETURN_CONTINUE &&\n\t\t\t    userret != JSON_C_VISIT_RETURN_SKIP)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"INTERNAL ERROR: _json_c_visit returned %d\\n\",\n\t\t\t\t        userret);\n\t\t\t\treturn JSON_C_VISIT_RETURN_ERROR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tfprintf(stderr, \"INTERNAL ERROR: _json_c_visit found object of unknown type: %d\\n\",\n\t\t        json_object_get_type(jso));\n\t\treturn JSON_C_VISIT_RETURN_ERROR;\n\t}\n\n\t// Call userfunc for the second type on container types, after all\n\t//  members of the container have been visited.\n\t// Non-container types will have already returned before this point.\n\n\tuserret = userfunc(jso, JSON_C_VISIT_SECOND, parent_jso, jso_key, jso_index, userarg);\n\tswitch (userret)\n\t{\n\tcase JSON_C_VISIT_RETURN_SKIP:\n\tcase JSON_C_VISIT_RETURN_POP:\n\t\t// These are not really sensible during JSON_C_VISIT_SECOND,\n\t\t// but map them to JSON_C_VISIT_CONTINUE anyway.\n\t\t// FALLTHROUGH\n\tcase JSON_C_VISIT_RETURN_CONTINUE: return JSON_C_VISIT_RETURN_CONTINUE;\n\tcase JSON_C_VISIT_RETURN_STOP:\n\tcase JSON_C_VISIT_RETURN_ERROR: return userret;\n\tdefault:\n\t\tfprintf(stderr, \"ERROR: invalid return value from json_c_visit userfunc: %d\\n\",\n\t\t        userret);\n\t\treturn JSON_C_VISIT_RETURN_ERROR;\n\t}\n\t// NOTREACHED\n}\n"
        },
        {
          "name": "json_visit.h",
          "type": "blob",
          "size": 3.1005859375,
          "content": "\n#ifndef _json_c_json_visit_h_\n#define _json_c_json_visit_h_\n\n/**\n * @file\n * @brief Methods for walking a tree of objects.\n */\n#include \"json_object.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef int(json_c_visit_userfunc)(json_object *jso, int flags, json_object *parent_jso,\n                                   const char *jso_key, size_t *jso_index, void *userarg);\n\n/**\n * Visit each object in the JSON hierarchy starting at jso.\n * For each object, userfunc is called, passing the object and userarg.\n * If the object has a parent (i.e. anything other than jso itself)\n * its parent will be passed as parent_jso, and either jso_key or jso_index\n * will be set, depending on whether the parent is an object or an array.\n *\n * Nodes will be visited depth first, but containers (arrays and objects)\n * will be visited twice, the second time with JSON_C_VISIT_SECOND set in\n * flags.\n *\n * userfunc must return one of the defined return values, to indicate\n * whether and how to continue visiting nodes, or one of various ways to stop.\n *\n * Returns 0 if nodes were visited successfully, even if some were\n *  intentionally skipped due to what userfunc returned.\n * Returns <0 if an error occurred during iteration, including if\n *  userfunc returned JSON_C_VISIT_RETURN_ERROR.\n */\nJSON_EXPORT int json_c_visit(json_object *jso, int future_flags, json_c_visit_userfunc *userfunc,\n                             void *userarg);\n\n/**\n * Passed to json_c_visit_userfunc as one of the flags values to indicate\n * that this is the second time a container (array or object) is being\n * called, after all of it's members have been iterated over.\n */\n#define JSON_C_VISIT_SECOND 0x02\n\n/**\n * This json_c_visit_userfunc return value indicates that iteration\n * should proceed normally.\n */\n#define JSON_C_VISIT_RETURN_CONTINUE 0\n\n/**\n * This json_c_visit_userfunc return value indicates that iteration\n * over the members of the current object should be skipped.\n * If the current object isn't a container (array or object), this\n * is no different than JSON_C_VISIT_RETURN_CONTINUE.\n */\n#define JSON_C_VISIT_RETURN_SKIP 7547\n\n/**\n * This json_c_visit_userfunc return value indicates that iteration\n * of the fields/elements of the <b>containing</b> object should stop\n * and continue \"popped up\" a level of the object hierarchy.\n * For example, returning this when handling arg will result in\n * arg3 and any other fields being skipped.   The next call to userfunc\n * will be the JSON_C_VISIT_SECOND call on \"foo\", followed by a userfunc\n * call on \"bar\".\n * <pre>\n * {\n *   \"foo\": {\n *     \"arg1\": 1,\n *     \"arg2\": 2,\n *     \"arg3\": 3,\n *     ...\n *   },\n *   \"bar\": {\n *     ...\n *   }\n * }\n * </pre>\n */\n#define JSON_C_VISIT_RETURN_POP 767\n\n/**\n * This json_c_visit_userfunc return value indicates that iteration\n * should stop immediately, and cause json_c_visit to return success.\n */\n#define JSON_C_VISIT_RETURN_STOP 7867\n\n/**\n * This json_c_visit_userfunc return value indicates that iteration\n * should stop immediately, and cause json_c_visit to return an error.\n */\n#define JSON_C_VISIT_RETURN_ERROR -1\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _json_c_json_visit_h_ */\n"
        },
        {
          "name": "libjson.c",
          "type": "blob",
          "size": 0.5888671875,
          "content": "\n/* dummy source file for compatibility purposes */\n\n#if defined(HAVE_CDEFS_H)\n#include <sys/cdefs.h>\n#endif\n\n#ifndef __warn_references\n\n#if defined(__GNUC__) && defined(HAS_GNU_WARNING_LONG)\n\n#define __warn_references(sym, msg) \\\n\t__asm__(\".section .gnu\" #sym \",\\n\\t.ascii \\\"\" msg \"\\\"\\n\\t.text\");\n\n#else\n#define __warn_references(sym, msg) /* nothing */\n#endif\n\n#endif\n\n#include \"json_object.h\"\n\n__warn_references(json_object_get, \"Warning: please link against libjson-c instead of libjson\");\n\n/*        __asm__(\".section .gnu.warning.\" __STRING(sym)  \\\n            \" ; .ascii \\\"\" msg \"\\\" ; .text\") */\n"
        },
        {
          "name": "linkhash.c",
          "type": "blob",
          "size": 20.826171875,
          "content": "/*\n * $Id: linkhash.c,v 1.4 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n * Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_ENDIAN_H\n#include <endian.h> /* attempt to define endianness */\n#endif\n\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h> /* Get InterlockedCompareExchange */\n#endif\n\n#include \"linkhash.h\"\n#include \"random_seed.h\"\n\n/* hash functions */\nstatic unsigned long lh_char_hash(const void *k);\nstatic unsigned long lh_perllike_str_hash(const void *k);\nstatic lh_hash_fn *char_hash_fn = lh_char_hash;\n\n/* comparison functions */\nint lh_char_equal(const void *k1, const void *k2);\nint lh_ptr_equal(const void *k1, const void *k2);\n\nint json_global_set_string_hash(const int h)\n{\n\tswitch (h)\n\t{\n\tcase JSON_C_STR_HASH_DFLT: char_hash_fn = lh_char_hash; break;\n\tcase JSON_C_STR_HASH_PERLLIKE: char_hash_fn = lh_perllike_str_hash; break;\n\tdefault: return -1;\n\t}\n\treturn 0;\n}\n\nstatic unsigned long lh_ptr_hash(const void *k)\n{\n\t/* CAW: refactored to be 64bit nice */\n\treturn (unsigned long)((((ptrdiff_t)k * LH_PRIME) >> 4) & ULONG_MAX);\n}\n\nint lh_ptr_equal(const void *k1, const void *k2)\n{\n\treturn (k1 == k2);\n}\n\n/*\n * hashlittle from lookup3.c, by Bob Jenkins, May 2006, Public Domain.\n * https://burtleburtle.net/bob/c/lookup3.c\n * minor modifications to make functions static so no symbols are exported\n * minor modifications to compile with -Werror\n */\n\n/*\n-------------------------------------------------------------------------------\nlookup3.c, by Bob Jenkins, May 2006, Public Domain.\n\nThese are functions for producing 32-bit hashes for hash table lookup.\nhashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()\nare externally useful functions.  Routines to test the hash are included\nif SELF_TEST is defined.  You can use this free for any purpose.  It's in\nthe public domain.  It has no warranty.\n\nYou probably want to use hashlittle().  hashlittle() and hashbig()\nhash byte arrays.  hashlittle() is faster than hashbig() on\nlittle-endian machines.  Intel and AMD are little-endian machines.\nOn second thought, you probably want hashlittle2(), which is identical to\nhashlittle() except it returns two 32-bit hashes for the price of one.\nYou could implement hashbig2() if you wanted but I haven't bothered here.\n\nIf you want to find a hash of, say, exactly 7 integers, do\n  a = i1;  b = i2;  c = i3;\n  mix(a,b,c);\n  a += i4; b += i5; c += i6;\n  mix(a,b,c);\n  a += i7;\n  final(a,b,c);\nthen use c as the hash value.  If you have a variable length array of\n4-byte integers to hash, use hashword().  If you have a byte array (like\na character string), use hashlittle().  If you have several byte arrays, or\na mix of things, see the comments above hashlittle().\n\nWhy is this so big?  I read 12 bytes at a time into 3 4-byte integers,\nthen mix those integers.  This is fast (you can do a lot more thorough\nmixing with 12*3 instructions on 3 integers than you can with 3 instructions\non 1 byte), but shoehorning those bytes into integers efficiently is messy.\n-------------------------------------------------------------------------------\n*/\n\n/*\n * My best guess at if you are big-endian or little-endian.  This may\n * need adjustment.\n */\n#if (defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && __BYTE_ORDER == __LITTLE_ENDIAN) || \\\n    (defined(i386) || defined(__i386__) || defined(__i486__) || defined(__i586__) ||          \\\n     defined(__i686__) || defined(vax) || defined(MIPSEL))\n#define HASH_LITTLE_ENDIAN 1\n#define HASH_BIG_ENDIAN 0\n#elif (defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && __BYTE_ORDER == __BIG_ENDIAN) || \\\n    (defined(sparc) || defined(POWERPC) || defined(mc68000) || defined(sel))\n#define HASH_LITTLE_ENDIAN 0\n#define HASH_BIG_ENDIAN 1\n#else\n#define HASH_LITTLE_ENDIAN 0\n#define HASH_BIG_ENDIAN 0\n#endif\n\n#define hashsize(n) ((uint32_t)1 << (n))\n#define hashmask(n) (hashsize(n) - 1)\n#define rot(x, k) (((x) << (k)) | ((x) >> (32 - (k))))\n\n/*\n-------------------------------------------------------------------------------\nmix -- mix 3 32-bit values reversibly.\n\nThis is reversible, so any information in (a,b,c) before mix() is\nstill in (a,b,c) after mix().\n\nIf four pairs of (a,b,c) inputs are run through mix(), or through\nmix() in reverse, there are at least 32 bits of the output that\nare sometimes the same for one pair and different for another pair.\nThis was tested for:\n* pairs that differed by one bit, by two bits, in any combination\n  of top bits of (a,b,c), or in any combination of bottom bits of\n  (a,b,c).\n* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n  is commonly produced by subtraction) look like a single 1-bit\n  difference.\n* the base values were pseudorandom, all zero but one bit set, or\n  all zero plus a counter that starts at zero.\n\nSome k values for my \"a-=c; a^=rot(c,k); c+=b;\" arrangement that\nsatisfy this are\n    4  6  8 16 19  4\n    9 15  3 18 27 15\n   14  9  3  7 17  3\nWell, \"9 15 3 18 27 15\" didn't quite get 32 bits diffing\nfor \"differ\" defined as + with a one-bit base and a two-bit delta.  I\nused https://burtleburtle.net/bob/hash/avalanche.html to choose\nthe operations, constants, and arrangements of the variables.\n\nThis does not achieve avalanche.  There are input bits of (a,b,c)\nthat fail to affect some output bits of (a,b,c), especially of a.  The\nmost thoroughly mixed value is c, but it doesn't really even achieve\navalanche in c.\n\nThis allows some parallelism.  Read-after-writes are good at doubling\nthe number of bits affected, so the goal of mixing pulls in the opposite\ndirection as the goal of parallelism.  I did what I could.  Rotates\nseem to cost as much as shifts on every machine I could lay my hands\non, and rotates are much kinder to the top and bottom bits, so I used\nrotates.\n-------------------------------------------------------------------------------\n*/\n/* clang-format off */\n#define mix(a,b,c) \\\n{ \\\n\ta -= c;  a ^= rot(c, 4);  c += b; \\\n\tb -= a;  b ^= rot(a, 6);  a += c; \\\n\tc -= b;  c ^= rot(b, 8);  b += a; \\\n\ta -= c;  a ^= rot(c,16);  c += b; \\\n\tb -= a;  b ^= rot(a,19);  a += c; \\\n\tc -= b;  c ^= rot(b, 4);  b += a; \\\n}\n/* clang-format on */\n\n/*\n-------------------------------------------------------------------------------\nfinal -- final mixing of 3 32-bit values (a,b,c) into c\n\nPairs of (a,b,c) values differing in only a few bits will usually\nproduce values of c that look totally different.  This was tested for\n* pairs that differed by one bit, by two bits, in any combination\n  of top bits of (a,b,c), or in any combination of bottom bits of\n  (a,b,c).\n* \"differ\" is defined as +, -, ^, or ~^.  For + and -, I transformed\n  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as\n  is commonly produced by subtraction) look like a single 1-bit\n  difference.\n* the base values were pseudorandom, all zero but one bit set, or\n  all zero plus a counter that starts at zero.\n\nThese constants passed:\n 14 11 25 16 4 14 24\n 12 14 25 16 4 14 24\nand these came close:\n  4  8 15 26 3 22 24\n 10  8 15 26 3 22 24\n 11  8 15 26 3 22 24\n-------------------------------------------------------------------------------\n*/\n/* clang-format off */\n#define final(a,b,c) \\\n{ \\\n\tc ^= b; c -= rot(b,14); \\\n\ta ^= c; a -= rot(c,11); \\\n\tb ^= a; b -= rot(a,25); \\\n\tc ^= b; c -= rot(b,16); \\\n\ta ^= c; a -= rot(c,4);  \\\n\tb ^= a; b -= rot(a,14); \\\n\tc ^= b; c -= rot(b,24); \\\n}\n/* clang-format on */\n\n/*\n-------------------------------------------------------------------------------\nhashlittle() -- hash a variable-length key into a 32-bit value\n  k       : the key (the unaligned variable-length array of bytes)\n  length  : the length of the key, counting by bytes\n  initval : can be any 4-byte value\nReturns a 32-bit value.  Every bit of the key affects every bit of\nthe return value.  Two keys differing by one or two bits will have\ntotally different hash values.\n\nThe best hash table sizes are powers of 2.  There is no need to do\nmod a prime (mod is sooo slow!).  If you need less than 32 bits,\nuse a bitmask.  For example, if you need only 10 bits, do\n  h = (h & hashmask(10));\nIn which case, the hash table should have hashsize(10) elements.\n\nIf you are hashing n strings (uint8_t **)k, do it like this:\n  for (i=0, h=0; i<n; ++i) h = hashlittle( k[i], len[i], h);\n\nBy Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this\ncode any way you wish, private, educational, or commercial.  It's free.\n\nUse for hash table lookup, or anything where one collision in 2^^32 is\nacceptable.  Do NOT use for cryptographic purposes.\n-------------------------------------------------------------------------------\n*/\n\n/* clang-format off */\nstatic uint32_t hashlittle(const void *key, size_t length, uint32_t initval)\n{\n\tuint32_t a,b,c; /* internal state */\n\tunion\n\t{\n\t\tconst void *ptr;\n\t\tsize_t i;\n\t} u; /* needed for Mac Powerbook G4 */\n\n\t/* Set up the internal state */\n\ta = b = c = 0xdeadbeef + ((uint32_t)length) + initval;\n\n\tu.ptr = key;\n\tif (HASH_LITTLE_ENDIAN && ((u.i & 0x3) == 0)) {\n\t\tconst uint32_t *k = (const uint32_t *)key; /* read 32-bit chunks */\n\n\t\t/*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */\n\t\twhile (length > 12)\n\t\t{\n\t\t\ta += k[0];\n\t\t\tb += k[1];\n\t\t\tc += k[2];\n\t\t\tmix(a,b,c);\n\t\t\tlength -= 12;\n\t\t\tk += 3;\n\t\t}\n\n\t\t/*----------------------------- handle the last (probably partial) block */\n\t\t/*\n\t\t * \"k[2]&0xffffff\" actually reads beyond the end of the string, but\n\t\t * then masks off the part it's not allowed to read.  Because the\n\t\t * string is aligned, the masked-off tail is in the same word as the\n\t\t * rest of the string.  Every machine with memory protection I've seen\n\t\t * does it on word boundaries, so is OK with this.  But VALGRIND will\n\t\t * still catch it and complain.  The masking trick does make the hash\n\t\t * noticeably faster for short strings (like English words).\n\t\t * AddressSanitizer is similarly picky about overrunning\n\t\t * the buffer. (https://clang.llvm.org/docs/AddressSanitizer.html)\n\t\t */\n#ifdef VALGRIND\n#define PRECISE_MEMORY_ACCESS 1\n#elif defined(__SANITIZE_ADDRESS__) /* GCC's ASAN */\n#define PRECISE_MEMORY_ACCESS 1\n#elif defined(__has_feature)\n#if __has_feature(address_sanitizer) /* Clang's ASAN */\n#define PRECISE_MEMORY_ACCESS 1\n#endif\n#endif\n#ifndef PRECISE_MEMORY_ACCESS\n\n\t\tswitch(length)\n\t\t{\n\t\tcase 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n\t\tcase 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n\t\tcase 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n\t\tcase 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n\t\tcase 8 : b+=k[1]; a+=k[0]; break;\n\t\tcase 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n\t\tcase 6 : b+=k[1]&0xffff; a+=k[0]; break;\n\t\tcase 5 : b+=k[1]&0xff; a+=k[0]; break;\n\t\tcase 4 : a+=k[0]; break;\n\t\tcase 3 : a+=k[0]&0xffffff; break;\n\t\tcase 2 : a+=k[0]&0xffff; break;\n\t\tcase 1 : a+=k[0]&0xff; break;\n\t\tcase 0 : return c; /* zero length strings require no mixing */\n\t\t}\n\n#else /* make valgrind happy */\n\n\t\tconst uint8_t  *k8 = (const uint8_t *)k;\n\t\tswitch(length)\n\t\t{\n\t\tcase 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n\t\tcase 11: c+=((uint32_t)k8[10])<<16;  /* fall through */\n\t\tcase 10: c+=((uint32_t)k8[9])<<8;    /* fall through */\n\t\tcase 9 : c+=k8[8];                   /* fall through */\n\t\tcase 8 : b+=k[1]; a+=k[0]; break;\n\t\tcase 7 : b+=((uint32_t)k8[6])<<16;   /* fall through */\n\t\tcase 6 : b+=((uint32_t)k8[5])<<8;    /* fall through */\n\t\tcase 5 : b+=k8[4];                   /* fall through */\n\t\tcase 4 : a+=k[0]; break;\n\t\tcase 3 : a+=((uint32_t)k8[2])<<16;   /* fall through */\n\t\tcase 2 : a+=((uint32_t)k8[1])<<8;    /* fall through */\n\t\tcase 1 : a+=k8[0]; break;\n\t\tcase 0 : return c;\n\t\t}\n\n#endif /* !valgrind */\n\n\t}\n\telse if (HASH_LITTLE_ENDIAN && ((u.i & 0x1) == 0))\n\t{\n\t\tconst uint16_t *k = (const uint16_t *)key; /* read 16-bit chunks */\n\t\tconst uint8_t  *k8;\n\n\t\t/*--------------- all but last block: aligned reads and different mixing */\n\t\twhile (length > 12)\n\t\t{\n\t\t\ta += k[0] + (((uint32_t)k[1])<<16);\n\t\t\tb += k[2] + (((uint32_t)k[3])<<16);\n\t\t\tc += k[4] + (((uint32_t)k[5])<<16);\n\t\t\tmix(a,b,c);\n\t\t\tlength -= 12;\n\t\t\tk += 6;\n\t\t}\n\n\t\t/*----------------------------- handle the last (probably partial) block */\n\t\tk8 = (const uint8_t *)k;\n\t\tswitch(length)\n\t\t{\n\t\tcase 12: c+=k[4]+(((uint32_t)k[5])<<16);\n\t\t\t b+=k[2]+(((uint32_t)k[3])<<16);\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 11: c+=((uint32_t)k8[10])<<16;     /* fall through */\n\t\tcase 10: c+=k[4];\n\t\t\t b+=k[2]+(((uint32_t)k[3])<<16);\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 9 : c+=k8[8];                      /* fall through */\n\t\tcase 8 : b+=k[2]+(((uint32_t)k[3])<<16);\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 7 : b+=((uint32_t)k8[6])<<16;      /* fall through */\n\t\tcase 6 : b+=k[2];\n\t\t\t a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 5 : b+=k8[4];                      /* fall through */\n\t\tcase 4 : a+=k[0]+(((uint32_t)k[1])<<16);\n\t\t\t break;\n\t\tcase 3 : a+=((uint32_t)k8[2])<<16;      /* fall through */\n\t\tcase 2 : a+=k[0];\n\t\t\t break;\n\t\tcase 1 : a+=k8[0];\n\t\t\t break;\n\t\tcase 0 : return c;                     /* zero length requires no mixing */\n\t\t}\n\n\t}\n\telse\n\t{\n\t\t/* need to read the key one byte at a time */\n\t\tconst uint8_t *k = (const uint8_t *)key;\n\n\t\t/*--------------- all but the last block: affect some 32 bits of (a,b,c) */\n\t\twhile (length > 12)\n\t\t{\n\t\t\ta += k[0];\n\t\t\ta += ((uint32_t)k[1])<<8;\n\t\t\ta += ((uint32_t)k[2])<<16;\n\t\t\ta += ((uint32_t)k[3])<<24;\n\t\t\tb += k[4];\n\t\t\tb += ((uint32_t)k[5])<<8;\n\t\t\tb += ((uint32_t)k[6])<<16;\n\t\t\tb += ((uint32_t)k[7])<<24;\n\t\t\tc += k[8];\n\t\t\tc += ((uint32_t)k[9])<<8;\n\t\t\tc += ((uint32_t)k[10])<<16;\n\t\t\tc += ((uint32_t)k[11])<<24;\n\t\t\tmix(a,b,c);\n\t\t\tlength -= 12;\n\t\t\tk += 12;\n\t\t}\n\n\t\t/*-------------------------------- last block: affect all 32 bits of (c) */\n\t\tswitch(length) /* all the case statements fall through */\n\t\t{\n\t\tcase 12: c+=((uint32_t)k[11])<<24; /* FALLTHRU */\n\t\tcase 11: c+=((uint32_t)k[10])<<16; /* FALLTHRU */\n\t\tcase 10: c+=((uint32_t)k[9])<<8; /* FALLTHRU */\n\t\tcase 9 : c+=k[8]; /* FALLTHRU */\n\t\tcase 8 : b+=((uint32_t)k[7])<<24; /* FALLTHRU */\n\t\tcase 7 : b+=((uint32_t)k[6])<<16; /* FALLTHRU */\n\t\tcase 6 : b+=((uint32_t)k[5])<<8; /* FALLTHRU */\n\t\tcase 5 : b+=k[4]; /* FALLTHRU */\n\t\tcase 4 : a+=((uint32_t)k[3])<<24; /* FALLTHRU */\n\t\tcase 3 : a+=((uint32_t)k[2])<<16; /* FALLTHRU */\n\t\tcase 2 : a+=((uint32_t)k[1])<<8; /* FALLTHRU */\n\t\tcase 1 : a+=k[0];\n\t\t\t break;\n\t\tcase 0 : return c;\n\t\t}\n\t}\n\n\tfinal(a,b,c);\n\treturn c;\n}\n/* clang-format on */\n\n/* a simple hash function similar to what perl does for strings.\n * for good results, the string should not be excessively large.\n */\nstatic unsigned long lh_perllike_str_hash(const void *k)\n{\n\tconst char *rkey = (const char *)k;\n\tunsigned hashval = 1;\n\n\twhile (*rkey)\n\t\thashval = hashval * 33 + *rkey++;\n\n\treturn hashval;\n}\n\nstatic unsigned long lh_char_hash(const void *k)\n{\n#if defined _MSC_VER || defined __MINGW32__\n#define RANDOM_SEED_TYPE LONG\n#else\n#define RANDOM_SEED_TYPE int\n#endif\n\tstatic volatile RANDOM_SEED_TYPE random_seed = -1;\n\n\tif (random_seed == -1)\n\t{\n\t\tRANDOM_SEED_TYPE seed;\n\t\t/* we can't use -1 as it is the uninitialized sentinel */\n\t\twhile ((seed = json_c_get_random_seed()) == -1) {}\n#if SIZEOF_INT == 8 && defined __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8\n#define USE_SYNC_COMPARE_AND_SWAP 1\n#endif\n#if SIZEOF_INT == 4 && defined __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\n#define USE_SYNC_COMPARE_AND_SWAP 1\n#endif\n#if SIZEOF_INT == 2 && defined __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2\n#define USE_SYNC_COMPARE_AND_SWAP 1\n#endif\n#if defined USE_SYNC_COMPARE_AND_SWAP\n\t\t(void)__sync_val_compare_and_swap(&random_seed, -1, seed);\n#elif defined _MSC_VER || defined __MINGW32__\n\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n#else\n\t\t//#warning \"racy random seed initialization if used by multiple threads\"\n\t\trandom_seed = seed; /* potentially racy */\n#endif\n\t}\n\n\treturn hashlittle((const char *)k, strlen((const char *)k), (uint32_t)random_seed);\n}\n\nint lh_char_equal(const void *k1, const void *k2)\n{\n\treturn (strcmp((const char *)k1, (const char *)k2) == 0);\n}\n\nstruct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,\n                              lh_equal_fn *equal_fn)\n{\n\tint i;\n\tstruct lh_table *t;\n\n\t/* Allocate space for elements to avoid divisions by zero. */\n\tassert(size > 0);\n\tt = (struct lh_table *)calloc(1, sizeof(struct lh_table));\n\tif (!t)\n\t\treturn NULL;\n\n\tt->count = 0;\n\tt->size = size;\n\tt->table = (struct lh_entry *)calloc(size, sizeof(struct lh_entry));\n\tif (!t->table)\n\t{\n\t\tfree(t);\n\t\treturn NULL;\n\t}\n\tt->free_fn = free_fn;\n\tt->hash_fn = hash_fn;\n\tt->equal_fn = equal_fn;\n\tfor (i = 0; i < size; i++)\n\t\tt->table[i].k = LH_EMPTY;\n\treturn t;\n}\n\nstruct lh_table *lh_kchar_table_new(int size, lh_entry_free_fn *free_fn)\n{\n\treturn lh_table_new(size, free_fn, char_hash_fn, lh_char_equal);\n}\n\nstruct lh_table *lh_kptr_table_new(int size, lh_entry_free_fn *free_fn)\n{\n\treturn lh_table_new(size, free_fn, lh_ptr_hash, lh_ptr_equal);\n}\n\nint lh_table_resize(struct lh_table *t, int new_size)\n{\n\tstruct lh_table *new_t;\n\tstruct lh_entry *ent;\n\n\tnew_t = lh_table_new(new_size, NULL, t->hash_fn, t->equal_fn);\n\tif (new_t == NULL)\n\t\treturn -1;\n\n\tfor (ent = t->head; ent != NULL; ent = ent->next)\n\t{\n\t\tunsigned long h = lh_get_hash(new_t, ent->k);\n\t\tunsigned int opts = 0;\n\t\tif (ent->k_is_constant)\n\t\t\topts = JSON_C_OBJECT_ADD_CONSTANT_KEY;\n\t\tif (lh_table_insert_w_hash(new_t, ent->k, ent->v, h, opts) != 0)\n\t\t{\n\t\t\tlh_table_free(new_t);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfree(t->table);\n\tt->table = new_t->table;\n\tt->size = new_size;\n\tt->head = new_t->head;\n\tt->tail = new_t->tail;\n\tfree(new_t);\n\n\treturn 0;\n}\n\nvoid lh_table_free(struct lh_table *t)\n{\n\tstruct lh_entry *c;\n\tif (t->free_fn)\n\t{\n\t\tfor (c = t->head; c != NULL; c = c->next)\n\t\t\tt->free_fn(c);\n\t}\n\tfree(t->table);\n\tfree(t);\n}\n\nint lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v, const unsigned long h,\n                           const unsigned opts)\n{\n\tunsigned long n;\n\n\tif (t->count >= t->size * LH_LOAD_FACTOR)\n\t{\n\t\t/* Avoid signed integer overflow with large tables. */\n\t\tint new_size = (t->size > INT_MAX / 2) ? INT_MAX : (t->size * 2);\n\t\tif (t->size == INT_MAX || lh_table_resize(t, new_size) != 0)\n\t\t\treturn -1;\n\t}\n\n\tn = h % t->size;\n\n\twhile (1)\n\t{\n\t\tif (t->table[n].k == LH_EMPTY || t->table[n].k == LH_FREED)\n\t\t\tbreak;\n\t\tif ((int)++n == t->size)\n\t\t\tn = 0;\n\t}\n\n\tt->table[n].k = k;\n\tt->table[n].k_is_constant = (opts & JSON_C_OBJECT_ADD_CONSTANT_KEY);\n\tt->table[n].v = v;\n\tt->count++;\n\n\tif (t->head == NULL)\n\t{\n\t\tt->head = t->tail = &t->table[n];\n\t\tt->table[n].next = t->table[n].prev = NULL;\n\t}\n\telse\n\t{\n\t\tt->tail->next = &t->table[n];\n\t\tt->table[n].prev = t->tail;\n\t\tt->table[n].next = NULL;\n\t\tt->tail = &t->table[n];\n\t}\n\n\treturn 0;\n}\nint lh_table_insert(struct lh_table *t, const void *k, const void *v)\n{\n\treturn lh_table_insert_w_hash(t, k, v, lh_get_hash(t, k), 0);\n}\n\nstruct lh_entry *lh_table_lookup_entry_w_hash(struct lh_table *t, const void *k,\n                                              const unsigned long h)\n{\n\tunsigned long n = h % t->size;\n\tint count = 0;\n\n\twhile (count < t->size)\n\t{\n\t\tif (t->table[n].k == LH_EMPTY)\n\t\t\treturn NULL;\n\t\tif (t->table[n].k != LH_FREED && t->equal_fn(t->table[n].k, k))\n\t\t\treturn &t->table[n];\n\t\tif ((int)++n == t->size)\n\t\t\tn = 0;\n\t\tcount++;\n\t}\n\treturn NULL;\n}\n\nstruct lh_entry *lh_table_lookup_entry(struct lh_table *t, const void *k)\n{\n\treturn lh_table_lookup_entry_w_hash(t, k, lh_get_hash(t, k));\n}\n\njson_bool lh_table_lookup_ex(struct lh_table *t, const void *k, void **v)\n{\n\tstruct lh_entry *e = lh_table_lookup_entry(t, k);\n\tif (e != NULL)\n\t{\n\t\tif (v != NULL)\n\t\t\t*v = lh_entry_v(e);\n\t\treturn 1; /* key found */\n\t}\n\tif (v != NULL)\n\t\t*v = NULL;\n\treturn 0; /* key not found */\n}\n\nint lh_table_delete_entry(struct lh_table *t, struct lh_entry *e)\n{\n\t/* CAW: fixed to be 64bit nice, still need the crazy negative case... */\n\tptrdiff_t n = (ptrdiff_t)(e - t->table);\n\n\t/* CAW: this is bad, really bad, maybe stack goes other direction on this machine... */\n\tif (n < 0)\n\t{\n\t\treturn -2;\n\t}\n\n\tif (t->table[n].k == LH_EMPTY || t->table[n].k == LH_FREED)\n\t\treturn -1;\n\tt->count--;\n\tif (t->free_fn)\n\t\tt->free_fn(e);\n\tt->table[n].v = NULL;\n\tt->table[n].k = LH_FREED;\n\tif (t->tail == &t->table[n] && t->head == &t->table[n])\n\t{\n\t\tt->head = t->tail = NULL;\n\t}\n\telse if (t->head == &t->table[n])\n\t{\n\t\tt->head->next->prev = NULL;\n\t\tt->head = t->head->next;\n\t}\n\telse if (t->tail == &t->table[n])\n\t{\n\t\tt->tail->prev->next = NULL;\n\t\tt->tail = t->tail->prev;\n\t}\n\telse\n\t{\n\t\tt->table[n].prev->next = t->table[n].next;\n\t\tt->table[n].next->prev = t->table[n].prev;\n\t}\n\tt->table[n].next = t->table[n].prev = NULL;\n\treturn 0;\n}\n\nint lh_table_delete(struct lh_table *t, const void *k)\n{\n\tstruct lh_entry *e = lh_table_lookup_entry(t, k);\n\tif (!e)\n\t\treturn -1;\n\treturn lh_table_delete_entry(t, e);\n}\n\nint lh_table_length(struct lh_table *t)\n{\n\treturn t->count;\n}\n"
        },
        {
          "name": "linkhash.h",
          "type": "blob",
          "size": 12.1513671875,
          "content": "/*\n * $Id: linkhash.h,v 1.6 2006/01/30 23:07:57 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n * Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Internal methods for working with json_type_object objects.  Although\n *        this is exposed by the json_object_get_object() function and within the\n *        json_object_iter type, it is not recommended for direct use.\n */\n#ifndef _json_c_linkhash_h_\n#define _json_c_linkhash_h_\n\n#include \"json_object.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * golden prime used in hash functions\n */\n#define LH_PRIME 0x9e370001UL\n\n/**\n * The fraction of filled hash buckets until an insert will cause the table\n * to be resized.\n * This can range from just above 0 up to 1.0.\n */\n#define LH_LOAD_FACTOR 0.66\n\n/**\n * sentinel pointer value for empty slots\n */\n#define LH_EMPTY (void *)-1\n\n/**\n * sentinel pointer value for freed slots\n */\n#define LH_FREED (void *)-2\n\n/**\n * default string hash function\n */\n#define JSON_C_STR_HASH_DFLT 0\n\n/**\n * perl-like string hash function\n */\n#define JSON_C_STR_HASH_PERLLIKE 1\n\n/**\n * This function sets the hash function to be used for strings.\n * Must be one of the JSON_C_STR_HASH_* values.\n * @returns 0 - ok, -1 if parameter was invalid\n */\nint json_global_set_string_hash(const int h);\n\nstruct lh_entry;\n\n/**\n * callback function prototypes\n */\ntypedef void(lh_entry_free_fn)(struct lh_entry *e);\n/**\n * callback function prototypes\n */\ntypedef unsigned long(lh_hash_fn)(const void *k);\n/**\n * callback function prototypes\n */\ntypedef int(lh_equal_fn)(const void *k1, const void *k2);\n\n/**\n * An entry in the hash table.  Outside of linkhash.c, treat this as opaque.\n */\nstruct lh_entry\n{\n\t/**\n\t * The key.\n\t * @deprecated Use lh_entry_k() instead of accessing this directly.\n\t */\n\tconst void *k;\n\t/**\n\t * A flag for users of linkhash to know whether or not they\n\t * need to free k.\n\t * @deprecated use lh_entry_k_is_constant() instead.\n\t */\n\tint k_is_constant;\n\t/**\n\t * The value.\n\t * @deprecated Use lh_entry_v() instead of accessing this directly.\n\t */\n\tconst void *v;\n\t/**\n\t * The next entry.\n\t * @deprecated Use lh_entry_next() instead of accessing this directly.\n\t */\n\tstruct lh_entry *next;\n\t/**\n\t * The previous entry.\n\t * @deprecated Use lh_entry_prev() instead of accessing this directly.\n\t */\n\tstruct lh_entry *prev;\n};\n\n/**\n * The hash table structure.  Outside of linkhash.c, treat this as opaque.\n */\nstruct lh_table\n{\n\t/**\n\t * Size of our hash.\n\t * @deprecated do not use outside of linkhash.c\n\t */\n\tint size;\n\t/**\n\t * Numbers of entries.\n\t * @deprecated Use lh_table_length() instead.\n\t */\n\tint count;\n\n\t/**\n\t * The first entry.\n\t * @deprecated Use lh_table_head() instead.\n\t */\n\tstruct lh_entry *head;\n\n\t/**\n\t * The last entry.\n\t * @deprecated Do not use, may be removed in a future release.\n\t */\n\tstruct lh_entry *tail;\n\n\t/**\n\t * Internal storage of the actual table of entries.\n\t * @deprecated do not use outside of linkhash.c\n\t */\n\tstruct lh_entry *table;\n\n\t/**\n\t * A pointer to the function responsible for freeing an entry.\n\t * @deprecated do not use outside of linkhash.c\n\t */\n\tlh_entry_free_fn *free_fn;\n\t/**\n\t * @deprecated do not use outside of linkhash.c\n\t */\n\tlh_hash_fn *hash_fn;\n\t/**\n\t * @deprecated do not use outside of linkhash.c\n\t */\n\tlh_equal_fn *equal_fn;\n};\ntypedef struct lh_table lh_table;\n\n/**\n * Convenience list iterator.\n */\n#define lh_foreach(table, entry) for (entry = lh_table_head(table); entry; entry = lh_entry_next(entry))\n\n/**\n * lh_foreach_safe allows calling of deletion routine while iterating.\n *\n * @param table a struct lh_table * to iterate over\n * @param entry a struct lh_entry * variable to hold each element\n * @param tmp a struct lh_entry * variable to hold a temporary pointer to the next element\n */\n#define lh_foreach_safe(table, entry, tmp) \\\n\tfor (entry = lh_table_head(table); entry && ((tmp = lh_entry_next(entry)) || 1); entry = tmp)\n\n/**\n * Create a new linkhash table.\n *\n * @param size initial table size. The table is automatically resized\n * although this incurs a performance penalty.\n * @param free_fn callback function used to free memory for entries\n * when lh_table_free or lh_table_delete is called.\n * If NULL is provided, then memory for keys and values\n * must be freed by the caller.\n * @param hash_fn  function used to hash keys. 2 standard ones are defined:\n * lh_ptr_hash and lh_char_hash for hashing pointer values\n * and C strings respectively.\n * @param equal_fn comparison function to compare keys. 2 standard ones defined:\n * lh_ptr_hash and lh_char_hash for comparing pointer values\n * and C strings respectively.\n * @return On success, a pointer to the new linkhash table is returned.\n * \tOn error, a null pointer is returned.\n */\nextern struct lh_table *lh_table_new(int size, lh_entry_free_fn *free_fn, lh_hash_fn *hash_fn,\n                                     lh_equal_fn *equal_fn);\n\n/**\n * Convenience function to create a new linkhash table with char keys.\n *\n * @param size initial table size.\n * @param free_fn callback function used to free memory for entries.\n * @return On success, a pointer to the new linkhash table is returned.\n * \tOn error, a null pointer is returned.\n */\nextern struct lh_table *lh_kchar_table_new(int size, lh_entry_free_fn *free_fn);\n\n/**\n * Convenience function to create a new linkhash table with ptr keys.\n *\n * @param size initial table size.\n * @param free_fn callback function used to free memory for entries.\n * @return On success, a pointer to the new linkhash table is returned.\n * \tOn error, a null pointer is returned.\n */\nextern struct lh_table *lh_kptr_table_new(int size, lh_entry_free_fn *free_fn);\n\n/**\n * Free a linkhash table.\n *\n * If a lh_entry_free_fn callback free function was provided then it is\n * called for all entries in the table.\n *\n * @param t table to free.\n */\nextern void lh_table_free(struct lh_table *t);\n\n/**\n * Insert a record into the table.\n *\n * @param t the table to insert into.\n * @param k a pointer to the key to insert.\n * @param v a pointer to the value to insert.\n *\n * @return On success, <code>0</code> is returned.\n * \tOn error, a negative value is returned.\n */\nextern int lh_table_insert(struct lh_table *t, const void *k, const void *v);\n\n/**\n * Insert a record into the table using a precalculated key hash.\n *\n * The hash h, which should be calculated with lh_get_hash() on k, is provided by\n *  the caller, to allow for optimization when multiple operations with the same\n *  key are known to be needed.\n *\n * @param t the table to insert into.\n * @param k a pointer to the key to insert.\n * @param v a pointer to the value to insert.\n * @param h hash value of the key to insert\n * @param opts if set to JSON_C_OBJECT_ADD_CONSTANT_KEY, sets lh_entry.k_is_constant\n *             so t's free function knows to avoid freeing the key.\n */\nextern int lh_table_insert_w_hash(struct lh_table *t, const void *k, const void *v,\n                                  const unsigned long h, const unsigned opts);\n\n/**\n * Lookup a record in the table.\n *\n * @param t the table to lookup\n * @param k a pointer to the key to lookup\n * @return a pointer to the record structure of the value or NULL if it does not exist.\n */\nextern struct lh_entry *lh_table_lookup_entry(struct lh_table *t, const void *k);\n\n/**\n * Lookup a record in the table using a precalculated key hash.\n *\n * The hash h, which should be calculated with lh_get_hash() on k, is provided by\n *  the caller, to allow for optimization when multiple operations with the same\n *  key are known to be needed.\n *\n * @param t the table to lookup\n * @param k a pointer to the key to lookup\n * @param h hash value of the key to lookup\n * @return a pointer to the record structure of the value or NULL if it does not exist.\n */\nextern struct lh_entry *lh_table_lookup_entry_w_hash(struct lh_table *t, const void *k,\n                                                     const unsigned long h);\n\n/**\n * Lookup a record in the table.\n *\n * @param t the table to lookup\n * @param k a pointer to the key to lookup\n * @param v a pointer to a where to store the found value (set to NULL if it doesn't exist).\n * @return whether or not the key was found\n */\nextern json_bool lh_table_lookup_ex(struct lh_table *t, const void *k, void **v);\n\n/**\n * Delete a record from the table.\n *\n * If a callback free function is provided then it is called for the\n * for the item being deleted.\n * @param t the table to delete from.\n * @param e a pointer to the entry to delete.\n * @return 0 if the item was deleted.\n * @return -1 if it was not found.\n */\nextern int lh_table_delete_entry(struct lh_table *t, struct lh_entry *e);\n\n/**\n * Delete a record from the table.\n *\n * If a callback free function is provided then it is called for the\n * for the item being deleted.\n * @param t the table to delete from.\n * @param k a pointer to the key to delete.\n * @return 0 if the item was deleted.\n * @return -1 if it was not found.\n */\nextern int lh_table_delete(struct lh_table *t, const void *k);\n\n/**\n * Return the number of entries in the table.\n */\nextern int lh_table_length(struct lh_table *t);\n\n/**\n * Resizes the specified table.\n *\n * @param t Pointer to table to resize.\n * @param new_size New table size. Must be positive.\n *\n * @return On success, <code>0</code> is returned.\n * \tOn error, a negative value is returned.\n */\nint lh_table_resize(struct lh_table *t, int new_size);\n\n/**\n * @deprecated Don't use this outside of linkhash.h:\n */\n#if !defined (__STDC_VERSION__) || (__STDC_VERSION__ < 199901L)\n/* C89 compilers like VS2010 can't handle inline funcs, so skip it there,\n   note: this also applies to -std=c89 in GCC! */\n#define _LH_INLINE\n#else\n#define _LH_INLINE inline\n#endif\n\n/**\n * Return the first entry in the lh_table.\n * @see lh_entry_next()\n */\nstatic _LH_INLINE struct lh_entry *lh_table_head(const lh_table *t)\n{\n\treturn t->head;\n}\n\n/**\n * Calculate the hash of a key for a given table.\n *\n * This is an extension to support functions that need to calculate\n * the hash several times and allows them to do it just once and then pass\n * in the hash to all utility functions. Depending on use case, this can be a\n * considerable performance improvement.\n * @param t the table (used to obtain hash function)\n * @param k a pointer to the key to lookup\n * @return the key's hash\n */\nstatic _LH_INLINE unsigned long lh_get_hash(const struct lh_table *t, const void *k)\n{\n\treturn t->hash_fn(k);\n}\n\n\n/**\n * @deprecated Don't use this outside of linkhash.h:\n */\n#ifdef __UNCONST\n#define _LH_UNCONST(a) __UNCONST(a)\n#else\n#define _LH_UNCONST(a) ((void *)(uintptr_t)(const void *)(a))\n#endif\n\n/**\n * Return a non-const version of lh_entry.k.\n *\n * lh_entry.k is const to indicate and help ensure that linkhash itself doesn't modify\n * it, but callers are allowed to do what they want with it.\n * @see lh_entry_k_is_constant()\n */\nstatic _LH_INLINE void *lh_entry_k(const struct lh_entry *e)\n{\n\treturn _LH_UNCONST(e->k);\n}\n\n/**\n * Returns 1 if the key for the given entry is constant, and thus\n *  does not need to be freed when the lh_entry is freed.\n * @see lh_table_insert_w_hash()\n */\nstatic _LH_INLINE int lh_entry_k_is_constant(const struct lh_entry *e)\n{\n\treturn e->k_is_constant;\n}\n\n/**\n * Return a non-const version of lh_entry.v.\n *\n * v is const to indicate and help ensure that linkhash itself doesn't modify\n * it, but callers are allowed to do what they want with it.\n */\nstatic _LH_INLINE void *lh_entry_v(const struct lh_entry *e)\n{\n\treturn _LH_UNCONST(e->v);\n}\n\n/**\n * Change the value for an entry.  The caller is responsible for freeing\n *  the previous value.\n */\nstatic _LH_INLINE void lh_entry_set_val(struct lh_entry *e, void *newval)\n{\n\te->v = newval;\n}\n\n/**\n * Return the next element, or NULL if there is no next element.\n * @see lh_table_head()\n * @see lh_entry_prev()\n */\nstatic _LH_INLINE struct lh_entry *lh_entry_next(const struct lh_entry *e)\n{\n\treturn e->next;\n}\n\n/**\n * Return the previous element, or NULL if there is no previous element.\n * @see lh_table_head()\n * @see lh_entry_next()\n */\nstatic _LH_INLINE struct lh_entry *lh_entry_prev(const struct lh_entry *e)\n{\n\treturn e->prev;\n}\n\n#undef _LH_INLINE\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "math_compat.h",
          "type": "blob",
          "size": 0.876953125,
          "content": "#ifndef __math_compat_h\n#define __math_compat_h\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n\n/* Define isnan, isinf, infinity and nan on Windows/MSVC */\n\n#ifndef HAVE_DECL_ISNAN\n#ifdef HAVE_DECL__ISNAN\n#include <float.h>\n#define isnan(x) _isnan(x)\n#else\n/* On platforms like AIX and \"IBM i\" we need to provide our own isnan */\n#define isnan(x) ((x) != (x))\n#endif\n#endif\n\n#ifndef HAVE_DECL_ISINF\n#ifdef HAVE_DECL__FINITE\n#include <float.h>\n#define isinf(x) (!_finite(x))\n#else\n#include <float.h>\n/* On platforms like AIX and \"IBM i\" we need to provide our own isinf */\n#define isinf(x) ((x) < -DBL_MAX || (x) > DBL_MAX)\n#endif\n#endif\n\n#ifndef HAVE_DECL_INFINITY\n#include <float.h>\n#define INFINITY (DBL_MAX + DBL_MAX)\n#define HAVE_DECL_INFINITY\n#endif\n\n#ifndef HAVE_DECL_NAN\n#define NAN (INFINITY - INFINITY)\n#define HAVE_DECL_NAN\n#endif\n\n#endif\n"
        },
        {
          "name": "printbuf.c",
          "type": "blob",
          "size": 4.076171875,
          "content": "/*\n * $Id: printbuf.c,v 1.5 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n *\n * Copyright (c) 2008-2009 Yahoo! Inc.  All rights reserved.\n * The copyrights to the contents of this file are licensed under the MIT License\n * (https://www.opensource.org/licenses/mit-license.php)\n */\n\n#include \"config.h\"\n\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_STDARG_H\n#include <stdarg.h>\n#else /* !HAVE_STDARG_H */\n#error Not enough var arg support!\n#endif /* HAVE_STDARG_H */\n\n#include \"debug.h\"\n#include \"printbuf.h\"\n#include \"snprintf_compat.h\"\n#include \"vasprintf_compat.h\"\n\nstatic int printbuf_extend(struct printbuf *p, int min_size);\n\nstruct printbuf *printbuf_new(void)\n{\n\tstruct printbuf *p;\n\n\tp = (struct printbuf *)calloc(1, sizeof(struct printbuf));\n\tif (!p)\n\t\treturn NULL;\n\tp->size = 32;\n\tp->bpos = 0;\n\tif (!(p->buf = (char *)malloc(p->size)))\n\t{\n\t\tfree(p);\n\t\treturn NULL;\n\t}\n\tp->buf[0] = '\\0';\n\treturn p;\n}\n\n/**\n * Extend the buffer p so it has a size of at least min_size.\n *\n * If the current size is large enough, nothing is changed.\n *\n * If extension failed, errno is set to indicate the error.\n *\n * Note: this does not check the available space!  The caller\n *  is responsible for performing those calculations.\n */\nstatic int printbuf_extend(struct printbuf *p, int min_size)\n{\n\tchar *t;\n\tint new_size;\n\n\tif (p->size >= min_size)\n\t\treturn 0;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (min_size > INT_MAX - 8)\n\t{\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (p->size > INT_MAX / 2)\n\t\tnew_size = min_size + 8;\n\telse {\n\t\tnew_size = p->size * 2;\n\t\tif (new_size < min_size + 8)\n\t\t\tnew_size = min_size + 8;\n\t}\n#ifdef PRINTBUF_DEBUG\n\tMC_DEBUG(\"printbuf_extend: realloc \"\n\t         \"bpos=%d min_size=%d old_size=%d new_size=%d\\n\",\n\t         p->bpos, min_size, p->size, new_size);\n#endif /* PRINTBUF_DEBUG */\n\tif (!(t = (char *)realloc(p->buf, new_size)))\n\t\treturn -1;\n\tp->size = new_size;\n\tp->buf = t;\n\treturn 0;\n}\n\nint printbuf_memappend(struct printbuf *p, const char *buf, int size)\n{\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (size < 0 || size > INT_MAX - p->bpos - 1)\n\t{\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tif (p->size <= p->bpos + size + 1)\n\t{\n\t\tif (printbuf_extend(p, p->bpos + size + 1) < 0)\n\t\t\treturn -1;\n\t}\n\tmemcpy(p->buf + p->bpos, buf, size);\n\tp->bpos += size;\n\tp->buf[p->bpos] = '\\0';\n\treturn size;\n}\n\nint printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len)\n{\n\tint size_needed;\n\n\tif (offset == -1)\n\t\toffset = pb->bpos;\n\t/* Prevent signed integer overflows with large buffers. */\n\tif (len < 0 || offset < -1 || len > INT_MAX - offset)\n\t{\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\tsize_needed = offset + len;\n\tif (pb->size < size_needed)\n\t{\n\t\tif (printbuf_extend(pb, size_needed) < 0)\n\t\t\treturn -1;\n\t}\n\n\tif (pb->bpos < offset)\n\t\tmemset(pb->buf + pb->bpos, '\\0', offset - pb->bpos);\n\tmemset(pb->buf + offset, charvalue, len);\n\tif (pb->bpos < size_needed)\n\t\tpb->bpos = size_needed;\n\n\treturn 0;\n}\n\nint sprintbuf(struct printbuf *p, const char *msg, ...)\n{\n\tva_list ap;\n\tchar *t;\n\tint size;\n\tchar buf[128];\n\n\t/* use stack buffer first */\n\tva_start(ap, msg);\n\tsize = vsnprintf(buf, 128, msg, ap);\n\tva_end(ap);\n\t/* if string is greater than stack buffer, then use dynamic string\n\t * with vasprintf.  Note: some implementations of vsnprintf return -1\n\t * if output is truncated whereas some return the number of bytes that\n\t * would have been written - this code handles both cases.\n\t */\n\tif (size < 0 || size > 127)\n\t{\n\t\tva_start(ap, msg);\n\t\tif ((size = vasprintf(&t, msg, ap)) < 0)\n\t\t{\n\t\t\tva_end(ap);\n\t\t\treturn -1;\n\t\t}\n\t\tva_end(ap);\n\t\tsize = printbuf_memappend(p, t, size);\n\t\tfree(t);\n\t}\n\telse\n\t{\n\t\tsize = printbuf_memappend(p, buf, size);\n\t}\n\treturn size;\n}\n\nvoid printbuf_reset(struct printbuf *p)\n{\n\tp->buf[0] = '\\0';\n\tp->bpos = 0;\n}\n\nvoid printbuf_free(struct printbuf *p)\n{\n\tif (p)\n\t{\n\t\tfree(p->buf);\n\t\tfree(p);\n\t}\n}\n"
        },
        {
          "name": "printbuf.h",
          "type": "blob",
          "size": 4.2509765625,
          "content": "/*\n * $Id: printbuf.h,v 1.4 2006/01/26 02:16:28 mclark Exp $\n *\n * Copyright (c) 2004, 2005 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n *\n * Copyright (c) 2008-2009 Yahoo! Inc.  All rights reserved.\n * The copyrights to the contents of this file are licensed under the MIT License\n * (https://www.opensource.org/licenses/mit-license.php)\n */\n\n/**\n * @file\n * @brief Internal string buffer handling.  Unless you're writing a\n *        json_object_to_json_string_fn implementation for use with\n *        json_object_set_serializer() direct use of this is not\n *        recommended.\n */\n#ifndef _json_c_printbuf_h_\n#define _json_c_printbuf_h_\n\n#ifndef JSON_EXPORT\n#if defined(_MSC_VER) && defined(JSON_C_DLL)\n#define JSON_EXPORT __declspec(dllexport)\n#else\n#define JSON_EXPORT extern\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct printbuf\n{\n\tchar *buf;\n\tint bpos;\n\tint size;\n};\ntypedef struct printbuf printbuf;\n\nJSON_EXPORT struct printbuf *printbuf_new(void);\n\n/* As an optimization, printbuf_memappend_fast() is defined as a macro\n * that handles copying data if the buffer is large enough; otherwise\n * it invokes printbuf_memappend() which performs the heavy\n * lifting of realloc()ing the buffer and copying data.\n *\n * Your code should not use printbuf_memappend() directly unless it\n * checks the return code. Use printbuf_memappend_fast() instead.\n */\nJSON_EXPORT int printbuf_memappend(struct printbuf *p, const char *buf, int size);\n\n#define printbuf_memappend_fast(p, bufptr, bufsize)                  \\\n\tdo                                                           \\\n\t{                                                            \\\n\t\tif ((p->size - p->bpos) > bufsize)                   \\\n\t\t{                                                    \\\n\t\t\tmemcpy(p->buf + p->bpos, (bufptr), bufsize); \\\n\t\t\tp->bpos += bufsize;                          \\\n\t\t\tp->buf[p->bpos] = '\\0';                      \\\n\t\t}                                                    \\\n\t\telse                                                 \\\n\t\t{                                                    \\\n\t\t\tprintbuf_memappend(p, (bufptr), bufsize);    \\\n\t\t}                                                    \\\n\t} while (0)\n\n#define printbuf_length(p) ((p)->bpos)\n\n/**\n * Results in a compile error if the argument is not a string literal.\n */\n#define _printbuf_check_literal(mystr) (\"\" mystr)\n\n/**\n * This is an optimization wrapper around printbuf_memappend() that is useful\n * for appending string literals. Since the size of string constants is known\n * at compile time, using this macro can avoid a costly strlen() call. This is\n * especially helpful when a constant string must be appended many times. If\n * you got here because of a compilation error caused by passing something\n * other than a string literal, use printbuf_memappend_fast() in conjunction\n * with strlen().\n *\n * See also:\n *   printbuf_memappend_fast()\n *   printbuf_memappend()\n *   sprintbuf()\n */\n#define printbuf_strappend(pb, str) \\\n\tprintbuf_memappend((pb), _printbuf_check_literal(str), sizeof(str) - 1)\n\n/**\n * Set len bytes of the buffer to charvalue, starting at offset offset.\n * Similar to calling memset(x, charvalue, len);\n *\n * The memory allocated for the buffer is extended as necessary.\n *\n * If offset is -1, this starts at the end of the current data in the buffer.\n */\nJSON_EXPORT int printbuf_memset(struct printbuf *pb, int offset, int charvalue, int len);\n\n/**\n * Formatted print to printbuf.\n *\n * This function is the most expensive of the available functions for appending\n * string data to a printbuf and should be used only where convenience is more\n * important than speed. Avoid using this function in high performance code or\n * tight loops; in these scenarios, consider using snprintf() with a static\n * buffer in conjunction with one of the printbuf_*append() functions.\n *\n * See also:\n *   printbuf_memappend_fast()\n *   printbuf_memappend()\n *   printbuf_strappend()\n */\nJSON_EXPORT int sprintbuf(struct printbuf *p, const char *msg, ...);\n\nJSON_EXPORT void printbuf_reset(struct printbuf *p);\n\nJSON_EXPORT void printbuf_free(struct printbuf *p);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "random_seed.c",
          "type": "blob",
          "size": 6.68359375,
          "content": "/*\n * random_seed.c\n *\n * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n#include \"random_seed.h\"\n#include \"config.h\"\n#include \"strerror_override.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef HAVE_BSD_STDLIB_H\n#include <bsd/stdlib.h>\n#endif\n\n#define DEBUG_SEED(s)\n\n#if defined(__APPLE__) || defined(__unix__) || defined(__linux__)\n#define HAVE_DEV_RANDOM 1\n#endif\n\n#ifdef HAVE_ARC4RANDOM\n#undef HAVE_GETRANDOM\n#undef HAVE_DEV_RANDOM\n#undef HAVE_CRYPTGENRANDOM\n#endif\n\n#if defined ENABLE_RDRAND\n\n/* cpuid */\n\n#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n#define HAS_X86_CPUID 1\n\nstatic void do_cpuid(int regs[], int h)\n{\n\t/* clang-format off */\n    __asm__ __volatile__(\"cpuid\"\n                         : \"=a\"(regs[0]), \"=b\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n                         : \"a\"(h));\n\t/* clang-format on */\n}\n\n#elif defined _MSC_VER\n\n#define HAS_X86_CPUID 1\n#define do_cpuid __cpuid\n\n#endif\n\n/* has_rdrand */\n\n#if HAS_X86_CPUID\n\nstatic int get_rdrand_seed(void);\n\n/* Valid values are -1 (haven't tested), 0 (no), and 1 (yes). */\nstatic int _has_rdrand = -1;\n\nstatic int has_rdrand(void)\n{\n\tif (_has_rdrand != -1)\n\t{\n\t\treturn _has_rdrand;\n\t}\n\n\t/* CPUID.01H:ECX.RDRAND[bit 30] == 1 */\n\tint regs[4];\n\tdo_cpuid(regs, 1);\n\tif (!(regs[2] & (1 << 30)))\n\t{\n\t\t_has_rdrand = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Some CPUs advertise RDRAND in CPUID, but return 0xFFFFFFFF\n\t * unconditionally. To avoid locking up later, test RDRAND here. If over\n\t * 3 trials RDRAND has returned the same value, declare it broken.\n\t * Example CPUs are AMD Ryzen 3000 series\n\t * and much older AMD APUs, such as the E1-1500\n\t * https://github.com/systemd/systemd/issues/11810\n\t * https://linuxreviews.org/RDRAND_stops_returning_random_values_on_older_AMD_CPUs_after_suspend\n\t */\n\t_has_rdrand = 0;\n\tint prev = get_rdrand_seed();\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint temp = get_rdrand_seed();\n\t\tif (temp != prev)\n\t\t{\n\t\t\t_has_rdrand = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev = temp;\n\t}\n\n\treturn _has_rdrand;\n}\n\n#endif\n\n/* get_rdrand_seed - GCC x86 and X64 */\n\n#if defined __GNUC__ && (defined __i386__ || defined __x86_64__)\n\n#define HAVE_RDRAND 1\n\nstatic int get_rdrand_seed(void)\n{\n\tDEBUG_SEED(\"get_rdrand_seed\");\n\tint _eax;\n\t/* rdrand eax */\n\t/* clang-format off */\n\t__asm__ __volatile__(\"1: .byte 0x0F\\n\"\n\t                     \"   .byte 0xC7\\n\"\n\t                     \"   .byte 0xF0\\n\"\n\t                     \"   jnc 1b;\\n\"\n\t                     : \"=a\" (_eax));\n\t/* clang-format on */\n\treturn _eax;\n}\n\n#endif\n\n#if defined _MSC_VER\n\n#if _MSC_VER >= 1700\n#define HAVE_RDRAND 1\n\n/* get_rdrand_seed - Visual Studio 2012 and above */\n\nstatic int get_rdrand_seed(void)\n{\n\tDEBUG_SEED(\"get_rdrand_seed\");\n\tint r;\n\twhile (_rdrand32_step(&r) == 0)\n\t\t;\n\treturn r;\n}\n\n#elif defined _M_IX86\n#define HAVE_RDRAND 1\n\n/* get_rdrand_seed - Visual Studio 2010 and below - x86 only */\n\n/* clang-format off */\nstatic int get_rdrand_seed(void)\n{\n\tDEBUG_SEED(\"get_rdrand_seed\");\n\tint _eax;\nretry:\n\t/* rdrand eax */\n\t__asm _emit 0x0F __asm _emit 0xC7 __asm _emit 0xF0\n\t__asm jnc retry\n\t__asm mov _eax, eax\n\treturn _eax;\n}\n/* clang-format on */\n\n#endif\n#endif\n\n#endif /* defined ENABLE_RDRAND */\n\n#ifdef HAVE_GETRANDOM\n\n#include <stdlib.h>\n#ifdef HAVE_SYS_RANDOM_H\n#include <sys/random.h>\n#endif\n\nstatic int get_getrandom_seed(int *seed)\n{\n\tDEBUG_SEED(\"get_getrandom_seed\");\n\n\tssize_t ret;\n\n\tdo\n\t{\n\t\tret = getrandom(seed, sizeof(*seed), GRND_NONBLOCK);\n\t} while ((ret == -1) && (errno == EINTR));\n\n\tif (ret == -1)\n\t{\n\t\tif (errno == ENOSYS) /* syscall not available in kernel */\n\t\t\treturn -1;\n\t\tif (errno == EAGAIN) /* entropy not yet initialized */\n\t\t\treturn -1;\n\n\t\tfprintf(stderr, \"error from getrandom(): %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tif (ret != sizeof(*seed))\n\t\treturn -1;\n\n\treturn 0;\n}\n#endif /* defined HAVE_GETRANDOM */\n\n/* get_dev_random_seed */\n\n#ifdef HAVE_DEV_RANDOM\n\n#include <fcntl.h>\n#include <string.h>\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif /* HAVE_UNISTD_H */\n#include <stdlib.h>\n#include <sys/stat.h>\n\nstatic const char *dev_random_file = \"/dev/urandom\";\n\nstatic int get_dev_random_seed(int *seed)\n{\n\tDEBUG_SEED(\"get_dev_random_seed\");\n\n\tstruct stat buf;\n\tif (stat(dev_random_file, &buf))\n\t\treturn -1;\n\tif ((buf.st_mode & S_IFCHR) == 0)\n\t\treturn -1;\n\n\t/* coverity[toctou] */\n\tint fd = open(dev_random_file, O_RDONLY);\n\tif (fd < 0)\n\t{\n\t\tfprintf(stderr, \"error opening %s: %s\", dev_random_file, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tssize_t nread = read(fd, seed, sizeof(*seed));\n\n\tclose(fd);\n\n\tif (nread != sizeof(*seed))\n\t{\n\t\tfprintf(stderr, \"error short read %s: %s\", dev_random_file, strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\n/* get_cryptgenrandom_seed */\n\n#ifdef _WIN32\n\n#define HAVE_CRYPTGENRANDOM 1\n\n/* clang-format off */\n#include <windows.h>\n\n/* Caution: these blank lines must remain so clang-format doesn't reorder\n   includes to put windows.h after wincrypt.h */\n\n#include <wincrypt.h>\n/* clang-format on */\n#ifndef __GNUC__\n#pragma comment(lib, \"advapi32.lib\")\n#endif\n\nstatic int get_cryptgenrandom_seed(int *seed)\n{\n\tHCRYPTPROV hProvider = 0;\n\tDWORD dwFlags = CRYPT_VERIFYCONTEXT;\n\n\tDEBUG_SEED(\"get_cryptgenrandom_seed\");\n\n\t/* WinNT 4 and Win98 do no support CRYPT_SILENT */\n\tif (LOBYTE(LOWORD(GetVersion())) > 4)\n\t\tdwFlags |= CRYPT_SILENT;\n\n\tif (!CryptAcquireContextA(&hProvider, 0, 0, PROV_RSA_FULL, dwFlags))\n\t{\n\t\tfprintf(stderr, \"error CryptAcquireContextA 0x%08lx\", GetLastError());\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tBOOL ret = CryptGenRandom(hProvider, sizeof(*seed), (BYTE *)seed);\n\t\tCryptReleaseContext(hProvider, 0);\n\t\tif (!ret)\n\t\t{\n\t\t\tfprintf(stderr, \"error CryptGenRandom 0x%08lx\", GetLastError());\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#endif\n\n/* get_time_seed */\n\n#ifndef HAVE_ARC4RANDOM\n#include <time.h>\n\nstatic int get_time_seed(void)\n{\n\tDEBUG_SEED(\"get_time_seed\");\n\n\t/* coverity[store_truncates_time_t] */\n\treturn (unsigned)time(NULL) * 433494437;\n}\n#endif\n\n/* json_c_get_random_seed */\n\nint json_c_get_random_seed(void)\n{\n#ifdef OVERRIDE_GET_RANDOM_SEED\n\tOVERRIDE_GET_RANDOM_SEED;\n#endif\n#if defined HAVE_RDRAND && HAVE_RDRAND\n\tif (has_rdrand())\n\t\treturn get_rdrand_seed();\n#endif\n#ifdef HAVE_ARC4RANDOM\n\t/* arc4random never fails, so use it if it's available */\n\treturn arc4random();\n#else\n#ifdef HAVE_GETRANDOM\n\t{\n\t\tint seed = 0;\n\t\tif (get_getrandom_seed(&seed) == 0)\n\t\t\treturn seed;\n\t}\n#endif\n#if defined HAVE_DEV_RANDOM && HAVE_DEV_RANDOM\n\t{\n\t\tint seed = 0;\n\t\tif (get_dev_random_seed(&seed) == 0)\n\t\t\treturn seed;\n\t}\n#endif\n#if defined HAVE_CRYPTGENRANDOM && HAVE_CRYPTGENRANDOM\n\t{\n\t\tint seed = 0;\n\t\tif (get_cryptgenrandom_seed(&seed) == 0)\n\t\t\treturn seed;\n\t}\n#endif\n\treturn get_time_seed();\n#endif /* !HAVE_ARC4RANDOM */\n}\n"
        },
        {
          "name": "random_seed.h",
          "type": "blob",
          "size": 0.494140625,
          "content": "/*\n * random_seed.h\n *\n * Copyright (c) 2013 Metaparadigm Pte. Ltd.\n * Michael Clark <michael@metaparadigm.com>\n *\n * This library is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See COPYING for details.\n *\n */\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n#ifndef seed_h\n#define seed_h\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern int json_c_get_random_seed(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "snprintf_compat.h",
          "type": "blob",
          "size": 0.9501953125,
          "content": "#ifndef __snprintf_compat_h\n#define __snprintf_compat_h\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n\n/*\n * Microsoft's _vsnprintf and _snprint don't always terminate\n * the string, so use wrappers that ensure that.\n */\n\n#include <stdarg.h>\n\n#if !defined(HAVE_SNPRINTF) && (defined(_MSC_VER) || defined(__MINGW32__))\nstatic int json_c_vsnprintf(char *str, size_t size, const char *format, va_list ap)\n{\n\tint ret;\n\tret = _vsnprintf(str, size, format, ap);\n\tstr[size - 1] = '\\0';\n\treturn ret;\n}\n#define vsnprintf json_c_vsnprintf\n\nstatic int json_c_snprintf(char *str, size_t size, const char *format, ...)\n{\n\tva_list ap;\n\tint ret;\n\tva_start(ap, format);\n\tret = json_c_vsnprintf(str, size, format, ap);\n\tva_end(ap);\n\treturn ret;\n}\n#define snprintf json_c_snprintf\n\n#elif !defined(HAVE_SNPRINTF) /* !HAVE_SNPRINTF */\n#error snprintf is required but was not found\n#endif /* !HAVE_SNPRINTF */\n\n#endif /* __snprintf_compat_h */\n"
        },
        {
          "name": "strdup_compat.h",
          "type": "blob",
          "size": 0.3544921875,
          "content": "#ifndef __strdup_compat_h\n#define __strdup_compat_h\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n\n#if !defined(HAVE_STRDUP) && defined(_MSC_VER)\n/* MSC has the version as _strdup */\n#define strdup _strdup\n#elif !defined(HAVE_STRDUP)\n#error You do not have strdup on your system.\n#endif /* HAVE_STRDUP */\n\n#endif\n"
        },
        {
          "name": "strerror_override.c",
          "type": "blob",
          "size": 2.2529296875,
          "content": "#define STRERROR_OVERRIDE_IMPL 1\n#include \"strerror_override.h\"\n\n/*\n * Override strerror() to get consistent output across platforms.\n */\n\nstatic struct\n{\n\tint errno_value;\n\tconst char *errno_str;\n} errno_list[] = {\n/* clang-format off */\n#define STRINGIFY(x) #x\n#define ENTRY(x) {x, &STRINGIFY(undef_ ## x)[6]}\n\tENTRY(EPERM),\n\tENTRY(ENOENT),\n\tENTRY(ESRCH),\n\tENTRY(EINTR),\n\tENTRY(EIO),\n\tENTRY(ENXIO),\n\tENTRY(E2BIG),\n#ifdef ENOEXEC\n\tENTRY(ENOEXEC),\n#endif\n\tENTRY(EBADF),\n\tENTRY(ECHILD),\n\tENTRY(EDEADLK),\n\tENTRY(ENOMEM),\n\tENTRY(EACCES),\n\tENTRY(EFAULT),\n#ifdef ENOTBLK\n\tENTRY(ENOTBLK),\n#endif\n\tENTRY(EBUSY),\n\tENTRY(EEXIST),\n\tENTRY(EXDEV),\n\tENTRY(ENODEV),\n\tENTRY(ENOTDIR),\n\tENTRY(EISDIR),\n\tENTRY(EINVAL),\n\tENTRY(ENFILE),\n\tENTRY(EMFILE),\n\tENTRY(ENOTTY),\n#ifdef ETXTBSY\n\tENTRY(ETXTBSY),\n#endif\n\tENTRY(EFBIG),\n\tENTRY(ENOSPC),\n\tENTRY(ESPIPE),\n\tENTRY(EROFS),\n\tENTRY(EMLINK),\n\tENTRY(EPIPE),\n\tENTRY(EDOM),\n\tENTRY(ERANGE),\n\tENTRY(EAGAIN),\n\t{ 0, (char *)0 }\n};\n/* clang-format on */\n\n// Enabled during tests\nstatic int _json_c_strerror_enable = 0;\nextern char *getenv(const char *name); // Avoid including stdlib.h\n\n#define PREFIX \"ERRNO=\"\nstatic char errno_buf[128] = PREFIX;\nchar *_json_c_strerror(int errno_in)\n{\n\tint start_idx;\n\tchar digbuf[20];\n\tint ii, jj;\n\n\tif (!_json_c_strerror_enable)\n\t\t_json_c_strerror_enable = (getenv(\"_JSON_C_STRERROR_ENABLE\") == NULL) ? -1 : 1;\n\tif (_json_c_strerror_enable == -1)\n\t\treturn strerror(errno_in);\n\n\t// Avoid standard functions, so we don't need to include any\n\t// headers, or guess at signatures.\n\n\tfor (ii = 0; errno_list[ii].errno_str != (char *)0; ii++)\n\t{\n\t\tconst char *errno_str = errno_list[ii].errno_str;\n\t\tif (errno_list[ii].errno_value != errno_in)\n\t\t\tcontinue;\n\n\t\tfor (start_idx = sizeof(PREFIX) - 1, jj = 0; errno_str[jj] != '\\0';\n\t\t     jj++, start_idx++)\n\t\t{\n\t\t\terrno_buf[start_idx] = errno_str[jj];\n\t\t}\n\t\terrno_buf[start_idx] = '\\0';\n\t\treturn errno_buf;\n\t}\n\n\t// It's not one of the known errno values, return the numeric value.\n\tfor (ii = 0; errno_in >= 10; errno_in /= 10, ii++)\n\t{\n\t\tdigbuf[ii] = \"0123456789\"[(errno_in % 10)];\n\t}\n\tdigbuf[ii] = \"0123456789\"[(errno_in % 10)];\n\n\t// Reverse the digits\n\tfor (start_idx = sizeof(PREFIX) - 1; ii >= 0; ii--, start_idx++)\n\t{\n\t\terrno_buf[start_idx] = digbuf[ii];\n\t}\n\terrno_buf[start_idx] = '\\0';\n\treturn errno_buf;\n}\n"
        },
        {
          "name": "strerror_override.h",
          "type": "blob",
          "size": 0.4970703125,
          "content": "#ifndef _json_strerror_override_h_\n#define _json_strerror_override_h_\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n\n#include \"config.h\"\n#include <errno.h>\n\n#include \"json_object.h\" /* for JSON_EXPORT */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <string.h>\n\nJSON_EXPORT char *_json_c_strerror(int errno_in);\n\n#ifndef STRERROR_OVERRIDE_IMPL\n#define strerror _json_c_strerror\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _json_strerror_override_h_ */\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "vasprintf_compat.h",
          "type": "blob",
          "size": 1.224609375,
          "content": "#ifndef __vasprintf_compat_h\n#define __vasprintf_compat_h\n\n/**\n * @file\n * @brief Do not use, json-c internal, may be changed or removed at any time.\n */\n\n#include \"snprintf_compat.h\"\n\n#ifndef _WIN32\n#include <stdarg.h>\n#endif /* !defined(_WIN32) */\n#include <stdint.h>\n#include <stdlib.h>\n\n#if !defined(HAVE_VASPRINTF)\n/* CAW: compliant version of vasprintf */\nstatic int vasprintf(char **buf, const char *fmt, va_list ap)\n{\n#ifndef _WIN32\n\tstatic char _T_emptybuffer = '\\0';\n\tva_list ap2;\n#endif /* !defined(_WIN32) */\n\tint chars;\n\tchar *b;\n\n\tif (!buf)\n\t{\n\t\treturn -1;\n\t}\n\n#ifdef _WIN32\n\tchars = _vscprintf(fmt, ap);\n#else  /* !defined(_WIN32) */\n\t/* CAW: RAWR! We have to hope to god here that vsnprintf doesn't overwrite\n\t * our buffer like on some 64bit sun systems... but hey, it's time to move on\n\t */\n\tva_copy(ap2, ap);\n\tchars = vsnprintf(&_T_emptybuffer, 0, fmt, ap2);\n\tva_end(ap2);\n#endif /* defined(_WIN32) */\n\tif (chars < 0 || (size_t)chars + 1 > SIZE_MAX / sizeof(char))\n\t{\n\t\treturn -1;\n\t}\n\n\tb = (char *)malloc(sizeof(char) * ((size_t)chars + 1));\n\tif (!b)\n\t{\n\t\treturn -1;\n\t}\n\n\tif ((chars = vsprintf(b, fmt, ap)) < 0)\n\t{\n\t\tfree(b);\n\t}\n\telse\n\t{\n\t\t*buf = b;\n\t}\n\n\treturn chars;\n}\n#endif /* !HAVE_VASPRINTF */\n\n#endif /* __vasprintf_compat_h */\n"
        }
      ]
    }
  ]
}