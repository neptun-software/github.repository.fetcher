{
  "metadata": {
    "timestamp": 1736710195280,
    "page": 894,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yaoweibin/nginx_tcp_proxy_module",
      "stars": 1641,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0390625,
          "content": "*.swp\n*.sh\n*.[oa]\nMakefile\ncscope*\nobjs\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 20.041015625,
          "content": "Name\n    nginx_tcp_proxy_module - support TCP proxy with Nginx\n\nInstallation\n    Download the latest stable version of the release tarball of this module\n    from github (<http://github.com/yaoweibin/nginx_tcp_proxy_module>)\n\n    Grab the nginx source code from nginx.org (<http://nginx.org/>), for\n    example, the version 1.20.2 (see nginx compatibility), and then build\n    the source with this module:\n\n        $ wget 'http://nginx.org/download/nginx-1.20.2.tar.gz'\n        $ tar -xzvf nginx-1.20.2.tar.gz\n        $ cd nginx-1.20.2/\n        $ patch -p1 < /path/to/nginx_tcp_proxy_module/tcp.patch\n\n        $ ./configure --add-module=/path/to/nginx_tcp_proxy_module\n\n        $ make\n        $ make install\n\nSynopsis\n    http {\n\n        server {\n            listen 80;\n\n            location /status {\n                tcp_check_status;\n            }\n        }\n    }\n\n    #You can also include tcp_proxy.conf file individually\n\n    #include /path/to/tcp_proxy.conf;\n\n    tcp {\n\n        upstream cluster {\n            # simple round-robin\n            server 192.168.0.1:80;\n            server 192.168.0.2:80;\n\n            check interval=3000 rise=2 fall=5 timeout=1000;\n\n            #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;\n\n            #check interval=3000 rise=2 fall=5 timeout=1000 type=http;\n            #check_http_send \"GET / HTTP/1.0\\r\\n\\r\\n\";\n            #check_http_expect_alive http_2xx http_3xx;\n        }\n\n        server {\n            listen 8888;\n\n            proxy_pass cluster;\n        }\n    }\n\nDescription\n    This module actually include many modules: ngx_tcp_module,\n    ngx_tcp_core_module, ngx_tcp_upstream_module, ngx_tcp_proxy_module,\n    ngx_tcp_websocket_module, ngx_tcp_ssl_module,\n    ngx_tcp_upstream_ip_hash_module. All these modules work together to\n    support TCP proxy with Nginx. I also added other features: ip_hash,\n    upstream server health check, status monitor.\n\n    The motivation of writing these modules is Nginx's high performance and\n    robustness. At first, I developed this module just for general TCP\n    proxy. And now, this module is frequently used in websocket reverse\n    proxying.\n\n    Note, You can't use the same listening port with HTTP modules.\n\nDirectives\n  ngx_tcp_module\n   tcp\n    syntax: *tcp {...}*\n\n    default: *none*\n\n    context: *main*\n\n    description: All the tcp related directives are contained in the tcp\n    block.\n\n    ngx_tcp_core_module\n\n   server\n    syntax: *server {...}*\n\n    default: *none*\n\n    context: *tcp*\n\n    description: All the specific server directives are contained in the\n    server block.\n\n   listen\n    syntax: *listen address:port [ bind | ssl | default]*\n\n    default: *none*\n\n    context: *server*\n\n    description: The same as listen\n    (<http://wiki.nginx.org/NginxMailCoreModule#listen>). The parameter of\n    default means the default server if you have several server blocks with\n    the same port.\n\n   access_log\n    syntax: *access_log path [buffer=size] | off*\n\n    default: *access_log logs/tcp_access.log*\n\n    context: *tcp, server*\n\n    description: Set the access.log. Each record's format is like this:\n\n    log_time worker_process_pid client_ip host_ip accept_time upstream_ip\n    bytes_read bytes_write\n\n    2011/08/02 06:19:07 [5972] 127.0.0.1 0.0.0.0:1982 2011/08/02 06:18:19\n    172.19.0.129:80 80 236305\n\n    *   *log_time*: The current time when writing this log. The log action\n        is called when the proxy session is closed.\n\n    *   *worker_process_pid*: the pid of worker process\n\n    *   *client_ip*: the client ip\n\n    *   *host_ip*: the server ip and port\n\n    *   *accept_time*: the time when the server accepts client's connection\n\n    *   *upstream_ip*: the upstream server's ip\n\n    *   *bytes_read*: the bytes read from client\n\n    *   *bytes_write*: the bytes written to client\n\n   allow\n    syntax: *allow [ address | CIDR | all ]*\n\n    default: *none*\n\n    context: *server*\n\n    description: Directive grants access for the network or addresses\n    indicated.\n\n   deny\n    syntax: *deny [ address | CIDR | all ]*\n\n    default: *none*\n\n    context: *server*\n\n    description: Directive grants access for the network or addresses\n    indicated.\n\n   so_keepalive\n    syntax: *so_keepalive on|off*\n\n    default: *off*\n\n    context: *main, server*\n\n    description: The same as so_keepalive\n    (<http://wiki.nginx.org/NginxMailCoreModule#so_keepalive>).\n\n   tcp_nodelay\n    syntax: *tcp_nodelay on|off*\n\n    default: *on*\n\n    context: *main, server*\n\n    description: The same as tcp_nodelay\n    (<http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay>).\n\n   timeout\n    syntax: *timeout milliseconds*\n\n    default: *60000*\n\n    context: *main, server*\n\n    description: set the timeout value with clients.\n\n   server_name\n    syntax: *server_name name*\n\n    default: *The name of the host, obtained through gethostname()*\n\n    context: *tcp, server*\n\n    description: The same as server_name\n    (<http://wiki.nginx.org/NginxMailCoreModule#server_name>). You can\n    specify several server name in different server block with the same\n    port. They can be used in websocket module.\n\n   resolver\n    syntax: *resolver address*\n\n    default: *none*\n\n    context: *tcp, server*\n\n    description: DNS server\n\n   resolver_timeout\n    syntax: *resolver_timeout time*\n\n    default: *30s*\n\n    context: *tcp, server*\n\n    description: Resolver timeout in seconds.\n\n  ngx_tcp_upstream_module\n   upstream\n    syntax: *upstream {...}*\n\n    default: *none*\n\n    context: *tcp*\n\n    description: All the upstream directives are contained in this block.\n    The upstream server will be dispatched with round robin by default.\n\n   server\n    syntax: *server name [parameters]*\n\n    default: *none*\n\n    context: *upstream*\n\n    description: Most of the parameters are the same as server\n    (<http://wiki.nginx.org/NginxHttpUpstreamModule#server>). Default port\n    is 80.\n\n   check\n    syntax: *check interval=milliseconds [fall=count] [rise=count]\n    [timeout=milliseconds] [type=tcp|ssl_hello|smtp|mysql|pop3|imap]*\n\n    default: *none, if parameters omitted, default parameters are\n    interval=30000 fall=5 rise=2 timeout=1000*\n\n    context: *upstream*\n\n    description: Add the health check for the upstream servers. At present,\n    the check method is a simple tcp connect.\n\n    The parameters' meanings are:\n\n    *   *interval*: the check request's interval time.\n\n    *   *fall*(fall_count): After fall_count check failures, the server is\n        marked down.\n\n    *   *rise*(rise_count): After rise_count check success, the server is\n        marked up.\n\n    *   *timeout*: the check request's timeout.\n\n    *   *type*: the check protocol type:\n\n        1.  *tcp* is a simple tcp socket connect and peek one byte.\n\n        2.  *ssl_hello* sends a client ssl hello packet and receives the\n            server ssl hello packet.\n\n        3.  *http* sends a http request packet, receives and parses the http\n            response to diagnose if the upstream server is alive.\n\n        4.  *smtp* sends a smtp request packet, receives and parses the smtp\n            response to diagnose if the upstream server is alive. The\n            response begins with '2' should be an OK response.\n\n        5.  *mysql* connects to the mysql server, receives the greeting\n            response to diagnose if the upstream server is alive.\n\n        6.  *pop3* receives and parses the pop3 response to diagnose if the\n            upstream server is alive. The response begins with '+' should be\n            an OK response.\n\n        7.  *imap* connects to the imap server, receives the greeting\n            response to diagnose if the upstream server is alive.\n\n   check_http_send\n    syntax: *check_http_send http_packet*\n\n    default: *\"GET / HTTP/1.0\\r\\n\\r\\n\"*\n\n    context: *upstream*\n\n    description: If you set the check type is http, then the check function\n    will sends this http packet to check the upstream server.\n\n   check_http_expect_alive\n    syntax: *check_http_expect_alive [ http_2xx | http_3xx | http_4xx |\n    http_5xx ]*\n\n    default: *http_2xx | http_3xx*\n\n    context: *upstream*\n\n    description: These status codes indicate the upstream server's http\n    response is OK, the backend is alive.\n\n   check_smtp_send\n    syntax: *check_smtp_send smtp_packet*\n\n    default: *\"HELO smtp.localdomain\\r\\n\"*\n\n    context: *upstream*\n\n    description: If you set the check type is smtp, then the check function\n    will sends this smtp packet to check the upstream server.\n\n   check_smtp_expect_alive\n    syntax: *check_smtp_expect_alive [smtp_2xx | smtp_3xx | smtp_4xx |\n    smtp_5xx]*\n\n    default: *smtp_2xx*\n\n    context: *upstream*\n\n    description: These status codes indicate the upstream server's smtp\n    response is OK, the backend is alive.\n\n   check_shm_size\n    syntax: *check_shm_size size*\n\n    default: *(number_of_checked_upstream_blocks + 1) * pagesize*\n\n    context: *tcp*\n\n    description: If you store hundreds of servers in one upstream block, the\n    shared memory for health check may be not enough, you can enlarged it by\n    this directive.\n\n   tcp_check_status\n    syntax: *tcp_check_status*\n\n    default: *none*\n\n    context: *location*\n\n    description: Display the health checking servers' status by HTTP. This\n    directive is set in the http block.\n\n    The table field meanings are:\n\n    *   *Index*: The server index in the check table\n\n    *   *Name* : The upstream server name\n\n    *   *Status*: The marked status of the server.\n\n    *   *Busyness*: The number of connections which are connecting to the\n        server.\n\n    *   *Rise counts*: Count the successful checking\n\n    *   *Fall counts*: Count the unsuccessful checking\n\n    *   *Access counts*: Count the times accessing to this server\n\n    *   *Check type*: The type of the check packet\n\n    ngx_tcp_upstream_busyness_module\n\n   busyness\n    syntax: *busyness*\n\n    default: *none*\n\n    context: *upstream*\n\n    description: the upstream server will be dispatched by backend servers'\n    busyness.\n\n    ngx_tcp_upstream_ip_hash_module\n\n   ip_hash\n    syntax: *ip_hash*\n\n    default: *none*\n\n    context: *upstream*\n\n    description: the upstream server will be dispatched by ip_hash.\n\n  ngx_tcp_proxy_module\n   proxy_pass\n    syntax: *proxy_pass host:port*\n\n    default: *none*\n\n    context: *server*\n\n    description: proxy the request to the backend server. Default port is\n    80.\n\n   proxy_buffer\n    syntax: *proxy_buffer size*\n\n    default: *4k*\n\n    context: *tcp, server*\n\n    description: set the size of proxy buffer.\n\n   proxy_connect_timeout\n    syntax: *proxy_connect_timeout miliseconds*\n\n    default: *60000*\n\n    context: *tcp, server*\n\n    description: set the timeout value of connection to backends.\n\n   proxy_read_timeout\n    syntax: *proxy_read_timeout miliseconds*\n\n    default: *60000*\n\n    context: *tcp, server*\n\n    description: set the timeout value of reading from backends.\n\n   proxy_send_timeout\n    syntax: *proxy_send_timeout miliseconds*\n\n    default: *60000*\n\n    context: *tcp, server*\n\n    description: set the timeout value of sending to backends.\n\n  ngx_tcp_websocket_module\n   websocket_pass\n    syntax: *websocket_pass [path] host:port*\n\n    default: *none*\n\n    context: *server*\n\n    description: proxy the websocket request to the backend server. Default\n    port is 80. You can specify several different paths in the same server\n    block.\n\n   websocket_buffer\n    syntax: *websocket_buffer size*\n\n    default: *4k*\n\n    context: *tcp, server*\n\n    description: set the size of proxy buffer.\n\n   websocket_connect_timeout\n    syntax: *websocket_connect_timeout miliseconds*\n\n    default: *60000*\n\n    context: *tcp, server*\n\n    description: set the timeout value of connection to backends.\n\n   websocket_read_timeout\n    syntax: *websocket_read_timeout miliseconds*\n\n    default: *60000*\n\n    context: *tcp, server*\n\n    description: set the timeout value of reading from backends. Your\n    timeout will be the minimum of this and the *timeout* parameter, so if\n    you want a long timeout for your websockets, make sure to set both\n    parameters.\n\n   websocket_send_timeout\n    syntax: *websocket_send_timeout miliseconds*\n\n    default: *60000*\n\n    context: *tcp, server*\n\n    description: set the timeout value of sending to backends.\n\n  ngx_tcp_ssl_module\n    The default config file includes this ngx_tcp_ssl_module. If you want to\n    just compile nginx without ngx_tcp_ssl_module, copy the\n    ngx_tcp_proxy_module/config_without_ssl to ngx_tcp_proxy_module/config,\n    reconfigrure and compile nginx.\n\n   ssl\n    syntax: *ssl [on|off] *\n\n    default: *ssl off*\n\n    context: *tcp, server*\n\n    Enables SSL for a server.\n\n   ssl_certificate\n    syntax: *ssl_certificate file*\n\n    default: *ssl_certificate cert.pem*\n\n    context: *tcp, server*\n\n    This directive specifies the file containing the certificate, in PEM\n    format. This file can contain also other certificates and the server\n    private key.\n\n   ssl_certificate_key\n    syntax: *ssl_certificate_key file*\n\n    default: *ssl_certificate_key cert.pem*\n\n    context: *tcp, server*\n\n    This directive specifies the file containing the private key, in PEM\n    format.\n\n   ssl_client_certificate\n    syntax: *ssl_client_certificate file*\n\n    default: *none*\n\n    context: *tcp, server*\n\n    This directive specifies the file containing the CA (root) certificate,\n    in PEM format, that is used for validating client certificates.\n\n   ssl_dhparam\n    syntax: *ssl_dhparam file*\n\n    default: *none*\n\n    context: *tcp, server*\n\n    This directive specifies a file containing Diffie-Hellman key agreement\n    protocol cryptographic parameters, in PEM format, utilized for\n    exchanging session keys between server and client.\n\n   ssl_ciphers\n    syntax: *ssl_ciphers openssl_cipherlist_spec*\n\n    default: *ssl_ciphers HIGH:!aNULL:!MD5*\n\n    context: *tcp, server*\n\n    This directive describes the list of cipher suites the server supports\n    for establishing a secure connection. Cipher suites are specified in the\n    OpenSSL (<http://openssl.org/docs/apps/ciphers.html>) cipherlist format,\n    for example:\n\n    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\n\n    The complete cipherlist supported by the currently installed version of\n    OpenSSL in your platform can be obtained by issuing the command: openssl\n    ciphers\n\n   ssl_crl\n    syntax: *ssl_crl file*\n\n    default: *none*\n\n    context: *tcp, server*\n\n    This directive specifies the filename of a Certificate Revocation List,\n    in PEM format, which is used to check the revocation status of\n    certificates.\n\n   ssl_prefer_server_ciphers\n    syntax: *ssl_prefer_server_ciphers [on|off] *\n\n    default: *ssl_prefer_server_ciphers off*\n\n    context: *tcp, server*\n\n    The server requires that the cipher suite list for protocols SSLv3 and\n    TLSv1 are to be preferred over the client supported cipher suite list.\n\n   ssl_protocols\n    syntax: *ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]*\n\n    default: *ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2*\n\n    context: *tcp, server*\n\n    This directive enables the protocol versions specified.\n\n   ssl_verify_client\n    syntax: *ssl_verify_client on|off|optional*\n\n    default: *ssl_verify_client off*\n\n    context: *tcp, server*\n\n    This directive enables the verification of the client identity.\n    Parameter 'optional' checks the client identity using its certificate in\n    case it was made available to the server.\n\n   ssl_verify_depth\n    syntax: *ssl_verify_depth number*\n\n    default: *ssl_verify_depth 1*\n\n    context: *tcp, server*\n\n    This directive sets how deep the server should go in the client provided\n    certificate chain in order to verify the client identity.\n\n   ssl_session_cache\n    syntax: *ssl_session_cache off|none|builtin:size and/or\n    shared:name:size*\n\n    default: *ssl_session_cache off*\n\n    context: *tcp, server*\n\n    The directive sets the types and sizes of caches to store the SSL\n    sessions.\n\n    The cache types are:\n\n    *   off -- Hard off: nginx says explicitly to a client that sessions can\n        not reused.\n\n    *   none -- Soft off: nginx says to a client that session can be reused,\n        but nginx actually never reuses them. This is workaround for some\n        mail clients as ssl_session_cache may be used in mail proxy as well\n        as in HTTP server.\n\n    *   builtin -- the OpenSSL builtin cache, is used inside one worker\n        process only. The cache size is assigned in the number of the\n        sessions. Note: there appears to be a memory fragmentation issue\n        using this method, please take that into consideration when using\n        this. See \"References\" below.\n\n    *   shared -- the cache is shared between all worker processes. The size\n        of the cache is assigned in bytes: 1 MB cache can contain roughly\n        4000 sessions. Each shared cache must be given an arbitrary name. A\n        shared cache with a given name can be used in several virtual hosts.\n\n    It's possible to use both types of cache &mdash; builtin and shared\n    &mdash; simultaneously, for example:\n\n    ssl_session_cache builtin:1000 shared:SSL:10m;\n\n    Bear in mind however, that using only shared cache, i.e., without\n    builtin, should be more effective.\n\n   ssl_session_timeout\n    syntax: *ssl_session_timeout time*\n\n    default: *ssl_session_timeout 5m*\n\n    context: *tcp, server*\n\n    This directive defines the maximum time during which the client can\n    re-use the previously negotiated cryptographic parameters of the secure\n    session that is stored in the SSL cache.\n\nCompatibility\n    *   My test bed is 0.7.65+\n\nNotes\n    The http_response_parse.rl and smtp_response_parse.rl are ragel\n    (<http://www.complang.org/ragel/>) scripts , you can edit the script and\n    compile it like this:\n\n        $ ragel -G2 http_response_parse.rl\n        $ ragel -G2 smtp_response_parse.rl\n\nTODO\n    *   refact this module, make it more extendable for adding third-party\n        modules\n\n    *   manipulate header like http module's proxy_set_header\n\n    *   built-in variable support\n\n    *   custom log format\n\n    *   syslog support\n\n    *   FTP/IRC proxying\n\nKnown Issues\n    *   This module can't use the same listening port with the HTTP module.\n\nChangelogs\n  v0.2.0\n    *   add ssl proxy module\n\n    *   add websocket proxy module\n\n    *   add upstream busyness module\n\n    *   add tcp access log module\n\n  v0.19\n    *   add many check methods\n\n  v0.1\n    *   first release\n\nAuthors\n    Weibin Yao(姚伟斌) *yaoweibin at gmail dot com*\n\nCopyright & License\n    This README template copy from agentzh (<http://github.com/agentzh>).\n\n    I borrowed a lot of code from upstream and mail module from the nginx\n    0.7.* core. This part of code is copyrighted by Igor Sysoev. And the\n    health check part is borrowed the design of Jack Lindamood's healthcheck\n    module healthcheck_nginx_upstreams\n    (<http://github.com/cep21/healthcheck_nginx_upstreams>);\n\n    This module is licensed under the BSD license.\n\n    Copyright (C) 2013 by Weibin Yao <yaoweibin@gmail.com>.\n\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are\n    met:\n\n    *   Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n    *   Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n    IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.9033203125,
          "content": "##  Name\n\nnginx_tcp_proxy_module - support TCP proxy with Nginx\n\n##  Installation\n\nDownload the latest stable version of the release tarball of this module from github (<http://github.com/yaoweibin/nginx_tcp_proxy_module>)\n\nGrab the nginx source code from nginx.org (<http://nginx.org/>), for example, the version 1.20.2 (see nginx compatibility), and then build the source with this module:\n\n```bash\n$ wget 'http://nginx.org/download/nginx-1.20.2.tar.gz'\n$ tar -xzvf nginx-1.20.2.tar.gz\n$ cd nginx-1.20.2/\n$ patch -p1 < /path/to/nginx_tcp_proxy_module/tcp.patch\n\n$ ./configure --add-module=/path/to/nginx_tcp_proxy_module\n\n$ make\n$ make install\n```\n\n###  Synopsis\n\n```bash\n    http {\n        server {\n            listen 80;\n    \n            location /status {\n                tcp_check_status;\n            }\n        }\n    }\n    #You can also include tcp_proxy.conf file individually\n    #include /path/to/tcp_proxy.conf;\n    tcp {\n        upstream cluster {\n            # simple round-robin\n            server 192.168.0.1:80;\n            server 192.168.0.2:80;\n    \t\t\n            check interval=3000 rise=2 fall=5 timeout=1000;\n    \t\t\n            #check interval=3000 rise=2 fall=5 timeout=1000 type=ssl_hello;\n    \n            #check interval=3000 rise=2 fall=5 timeout=1000 type=http;\n            #check_http_send \"GET / HTTP/1.0\\r\\n\\r\\n\";\n            #check_http_expect_alive http_2xx http_3xx;\n        }\n    \n        server {\n            listen 8888;\n            ...\n            proxy_pass cluster;\n        }\n    }\n```\n###  Description\nThis module actually include many modules: \n\n```bash\nngx_tcp_module,\nngx_tcp_core_module, \nngx_tcp_upstream_module, \nngx_tcp_proxy_module,\nngx_tcp_websocket_module, \nngx_tcp_ssl_module,\nngx_tcp_upstream_ip_hash_module\n```\nAll these modules work together to support TCP proxy with Nginx. I also added other features: \n\n```bash\nip_hash,\nupstream server health check,\nstatus monitor\n```\nThe motivation of writing these modules is Nginx's high performance and robustness. At first, I developed this module just for general TCP proxy. And now, this module is frequently used in websocket reverse proxying.\n\nNote, You can't use the same listening port with HTTP modules.\n\n##  Directives\n###  ngx_tcp_module\n####  tcp\n\nsyntax: `tcp {...}`   \ndefault: none  \ncontext: main  \ndescription: All the tcp related directives are contained in the tcp\nblock.  \n\n###  ngx_tcp_core_module\n####  server\nsyntax: `server {...}`  \ndefault: none  \ncontext: tcp  \ndescription: All the specific server directives are contained in the\nserver block.  \n\n####  listen\nsyntax: `listen address:port [ bind | ssl | default]`  \ndefault: none  \ncontext: server  \ndescription: The same as listen (<http://wiki.nginx.org/NginxMailCoreModule#listen>). The parameter of  \ndefault means the default server if you have several server blocks with\nthe same port.  \n\n####  access_log\nsyntax: `access_log path [buffer=size] | off`  \ndefault: access_log logs/tcp_access.log  \ncontext: tcp, server  \ndescription: Set the access.log. Each record's format is like this:  \n\n```bash\nlog_time worker_process_pid client_ip host_ip accept_time upstream_ip\nbytes_read bytes_write\n\n2011/08/02 06:19:07 [5972] 127.0.0.1 0.0.0.0:1982 2011/08/02 06:18:19\n172.19.0.129:80 80 236305\n```\n\n* `log_time` - The current time when writing this log. The log action is called when the proxy session is closed.  \n* `worker_process_pid` - the pid of worker process  \n* `client_ip` - the client ip  \n* `host_ip` - the server ip and port  \n* `accept_time` - the time when the server accepts client's connection  \n* `upstream_ip` - the upstream server's ip  \n* `bytes_read` - the bytes read from client  \n* `bytes_write` - the bytes written to client  \n\n####  allow\nsyntax: `allow [ address | CIDR | all ]`  \ndefault: none  \ncontext: server  \ndescription: Directive grants access for the network or addresses indicated.  \n\n####  deny\nsyntax: `deny [ address | CIDR | all ]`  \ndefault: none  \ncontext: server  \ndescription: Directive grants access for the network or addresses indicated.  \n\n####  so_keepalive\nsyntax: `so_keepalive on|off`  \ndefault: off  \ncontext: main, server  \ndescription: The same as so_keepalive\n(<http://wiki.nginx.org/NginxMailCoreModule#so_keepalive>).  \n\n####  tcp_nodelay\nsyntax: `tcp_nodelay on|off`  \ndefault: on  \ncontext: main, server  \ndescription: The same as tcp_nodelay\n(<http://wiki.nginx.org/NginxHttpCoreModule#tcp_nodelay>).  \n\n####  timeout\nsyntax: `timeout milliseconds`  \ndefault: 60000  \ncontext: main, server  \ndescription: set the timeout value with clients.  \n\n####  server_name\nsyntax: `server_name name`  \ndefault: The name of the host, obtained through gethostname()`  \ncontext: tcp, server  \ndescription: The same as server_name  \n(<http://wiki.nginx.org/NginxMailCoreModule#server_name>). You can\nspecify several server name in different server block with the same\nport. They can be used in websocket module.  \n\n####  resolver\nsyntax: `resolver address`  \ndefault: none  \ncontext: tcp,  server  \ndescription: DNS server  \n\n####  resolver_timeout\nsyntax: `resolver_timeout time`  \ndefault: `30s`  \ncontext: tcp, server  \ndescription: Resolver timeout in seconds.  \n\n###  ngx_tcp_upstream_module\n####  upstream\nsyntax: `upstream {...}`  \ndefault: none  \ncontext: tcp  \ndescription: All the upstream directives are contained in this block. The upstream server will be dispatched with round robin by default.  \n\n####  server\nsyntax: `server name [parameters]`  \ndefault: none  \ncontext: upstream  \ndescription: Most of the parameters are the same as server\n(<http://wiki.nginx.org/NginxHttpUpstreamModule#server>). Default port is 80.  \n\n####  check\nsyntax: \n\n```bash \ncheck interval=milliseconds [fall=count][rise=count]\n[timeout=milliseconds] [type=tcp|ssl_hello|smtp|mysql|pop3|imap]\n```  \ndefault: none, if parameters omitted, default parameters are\ninterval=30000 fall=5 rise=2 timeout=1000  \ncontext: upstream  \ndescription: Add the health check for the upstream servers. At present,the check method is a simple tcp connect.  \nThe parameters' meanings are:  \n* `interval:` the check request's interval time.  \n* `fall(fall_count):` After fall_count check failures, the server is marked down.  \n* `rise(rise_count):` After rise_count check success, the server is  marked up.  \n* `timeout:` the check request's timeout.  \n* `type:` the check protocol type:  \n  1.`tcp` is a simple tcp socket connect and peek one byte.  \n  2.`ssl_hello` sends a client ssl hello packet and receives the server ssl hello packet.  \n  3.`http` sends a http request packet, receives and parses the http response to diagnose if the upstream server is alive.  \n  4.`smtp` sends a smtp request packet, receives and parses the smtp response to diagnose if the upstream server is alive. The response begins with '2' should be an OK response.  \n  5.`mysql` connects to the mysql server, receives the greeting response to diagnose if the upstream server is alive.  \n  6.`pop3` receives and parses the pop3 response to diagnose if the upstream server is alive. The response begins with '+' should bean OK response.  \n  7.`imap` connects to the imap server, receives the greeting response to diagnose if the upstream server is alive.  \n\n####  check_http_send\nsyntax: `check_http_send http_packet`  \ndefault: \"GET / HTTP/1.0\\r\\n\\r\\n\"  \ncontext: upstream  \ndescription: If you set the check type is http, then the check function will sends this http packet to check the upstream server.  \n\n####  check_http_expect_alive\nsyntax: `check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]`  \ndefault: http_2xx | http_3xx  \ncontext: upstream  \ndescription: These status codes indicate the upstream server's http response is OK, the backend is alive.  \n\n####  check_smtp_send\nsyntax: `check_smtp_send smtp_packet`  \ndefault: \"HELO smtp.localdomain\\r\\n\"  \ncontext: upstream  \ndescription: If you set the check type is smtp, then the check function will sends this smtp packet to check the upstream server.  \n\n####  check_smtp_expect_alive\nsyntax: `check_smtp_expect_alive [smtp_2xx | smtp_3xx | smtp_4xx | smtp_5xx]`   \ndefault: smtp_2xx  \ncontext: upstream  \ndescription: These status codes indicate the upstream server's smtp response is OK, the backend is alive.  \n\n####  check_shm_size\nsyntax: `check_shm_size size`  \ndefault: (number_of_checked_upstream_blocks + 1)  * pagesize  \ncontext: tcp  \ndescription: If you store hundreds of servers in one upstream block, the shared memory for health check may be not enough, you can enlarged it by this directive.  \n\n####  tcp_check_status\nsyntax: `tcp_check_status`  \ndefault: none  \ncontext: location  \ndescription: Display the health checking servers' status by HTTP. This directive is set in the http block.  \n\nThe table field meanings are:  \n* `Index`: The server index in the check table  \n* `Name` : The upstream server name  \n* `Status`: The marked status of the server.  \n* `Busyness`: The number of connections which are connecting to the server.  \n* `Rise counts`: Count the successful checking  \n* `Fall counts`: Count the unsuccessful checking  \n* `Access counts`: Count the times accessing to this server  \n* `Check type`: The type of the check packet  \n\n###  ngx_tcp_upstream_busyness_module\n####  busyness\nsyntax: `busyness`  \ndefault: none  \ncontext: upstream  \ndescription: the upstream server will be dispatched by backend servers busyness.  \n\n###  ngx_tcp_upstream_ip_hash_module\n\n####  ip_hash\nsyntax: `ip_hash`  \ndefault: none  \ncontext: upstream  \ndescription: the upstream server will be dispatched by ip_hash.  \n\n###  ngx_tcp_proxy_module\n####  proxy_pass\nsyntax: `proxy_pass host:port`  \ndefault: `none`  \ncontext: `server`  \ndescription: proxy the request to the backend server. Default port is 80.  \n\n####  proxy_buffer\nsyntax: `proxy_buffer size`  \ndefault: `4k`  \ncontext: `tcp, server`  \ndescription: set the size of proxy buffer.  \n\n####  proxy_connect_timeout\nsyntax: `proxy_connect_timeout miliseconds`  \ndefault: `60000`  \ncontext: `tcp, server`  \ndescription: set the timeout value of connection to backends.  \n\n####  proxy_read_timeout\nsyntax: `proxy_read_timeout miliseconds`  \ndefault: `60000`  \ncontext: `tcp, server`  \ndescription: set the timeout value of reading from backends.  \n\n####  proxy_send_timeout\nsyntax: `proxy_send_timeout miliseconds`  \ndefault: `60000`  \ncontext: `tcp, server`  \ndescription: set the timeout value of sending to backends.  \n\n###  ngx_tcp_websocket_module\n####  websocket_pass\nsyntax: `websocket_pass [path] host:port`  \ndefault: `none`  \ncontext: `server`  \ndescription: proxy the websocket request to the backend server. Default port is 80. You can specify several different paths in the same server block.  \n\n####  websocket_buffer\nsyntax: `websocket_buffer size`  \ndefault: `4k`  \ncontext: `tcp, server`  \ndescription: set the size of proxy buffer.  \n\n####  websocket_connect_timeout\nsyntax: `websocket_connect_timeout miliseconds`  \ndefault: `60000`  \ncontext: `tcp, server`  \ndescription: set the timeout value of connection to backends.  \n\n####  websocket_read_timeout\nsyntax: `websocket_read_timeout miliseconds`  \ndefault: `60000`  \ncontext: `tcp, server`  \ndescription: set the timeout value of reading from backends. Your timeout will be the minimum of this and the `timeout` parameter, so if you want a long timeout for your websockets, make sure to set both parameters.  \n\n#### websocket_send_timeout\nsyntax: `websocket_send_timeout miliseconds`  \ndefault: `60000`  \ncontext: `tcp, server`  \ndescription: set the timeout value of sending to backends.  \n\n###  ngx_tcp_ssl_module\nThe default config file includes this ngx_tcp_ssl_module. If you want to just compile nginx without ngx_tcp_ssl_module, copy the ngx_tcp_proxy_module/config_without_ssl to ngx_tcp_proxy_module/config, reconfigrure and compile nginx.  \n\n####  ssl\nsyntax: `ssl [on|off]`  \ndefault: `ssl off`  \ncontext: `tcp, server`  \nEnables SSL for a server.  \n\n####  ssl_certificate\nsyntax: `ssl_certificate file`  \ndefault: `ssl_certificate cert.pem`  \ncontext: `tcp, server`  \nThis directive specifies the file containing the certificate, in PEM format. This file can contain also other certificates and the server private key.  \n\n####  ssl_certificate_key\nsyntax: `ssl_certificate_key file`  \ndefault: `ssl_certificate_key cert.pem`  \ncontext: `tcp, server`  \nThis directive specifies the file containing the private key, in PEM format.  \n\n####  ssl_client_certificate\nsyntax: `ssl_client_certificate file`  \ndefault: `none`  \ncontext: `tcp, server`  \nThis directive specifies the file containing the CA (root) certificate, in PEM format, that is used for validating client certificates.  \n\n####  ssl_dhparam\nsyntax: `ssl_dhparam file`  \ndefault: `none`  \ncontext: `tcp, server`  \nThis directive specifies a file containing Diffie-Hellman key agreement protocol cryptographic parameters, in PEM format, utilized for exchanging session keys between server and client.  \n\n####  ssl_ciphers\nsyntax: `ssl_ciphers openssl_cipherlist_spec`  \ndefault: `ssl_ciphers HIGH:!aNULL:!MD5`  \ncontext: `tcp, server`  \nThis directive describes the list of cipher suites the server supports for establishing a secure connection. Cipher suites are specified in the OpenSSL (<http://openssl.org/docs/apps/ciphers.html>) cipherlist format,  \nfor example:  \n```bash\nssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\n```  \nThe complete cipherlist supported by the currently installed version of OpenSSL in your platform can be obtained by issuing the command: openssl ciphers  \n\n####  ssl_crl\nsyntax: `ssl_crl file`  \ndefault: `none`  \ncontext: `tcp, server`  \nThis directive specifies the filename of a Certificate Revocation List, in PEM format, which is used to check the revocation status of certificates.  \n\n####  ssl_prefer_server_ciphers\nsyntax: `ssl_prefer_server_ciphers [on|off]`  \ndefault: `ssl_prefer_server_ciphers off`  \nThe server requires that the cipher suite list for protocols SSLv3 and TLSv1 are to be preferred over the client supported cipher suite list.  \n\n####  ssl_protocols\nsyntax: `ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]`  \ndefault: `ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2`  \ncontext: `tcp, server`  \nThis directive enables the protocol versions specified.  \n\n####  ssl_verify_client\nsyntax: `ssl_verify_client on|off|optional`  \ndefault: `ssl_verify_client off`  \ncontext: `tcp, server`  \nThis directive enables the verification of the client identity.Parameter 'optional' checks the client identity using its certificate in case it was made available to the server.  \n\n####  ssl_verify_depth\nsyntax: `ssl_verify_depth number`  \ndefault: `ssl_verify_depth 1`  \ncontext: `tcp, server`  \nThis directive sets how deep the server should go in the client provided certificate chain in order to verify the client identity.  \n\n####  ssl_session_cache\nsyntax: `ssl_session_cache off|none|builtin:size and/or shared:name:size`  \ndefault: `ssl_session_cache off`  \ncontext: `tcp, server`  \nThe directive sets the types and sizes of caches to store the SSL sessions.  \nThe cache types are:  \n* `off` -- Hard off: nginx says explicitly to a client that sessions can not reused.  \n* `none` -- Soft off: nginx says to a client that session can be reused,but nginx actually never reuses them. This is workaround for some mail clients as ssl_session_cache may be used in mail proxy as well as in HTTP server.  \n* `builtin` -- the OpenSSL builtin cache, is used inside one worker process only. The cache size is assigned in the number of the sessions. Note: there appears to be a memory fragmentation issue using this method, please take that into consideration when using this. See \"References\" below.  \n* `shared` -- the cache is shared between all worker processes. The sizeof the cache is assigned in bytes: 1 MB cache can contain roughly4000 sessions. Each shared cache must be given an arbitrary name. Ashared cache with a given name can be used in several virtual hosts.  \nIt's possible to use both types of cache &mdash; builtin and shared &mdash; simultaneously, for example:  \n```bash\nssl_session_cache builtin:1000 shared:SSL:10m;\n```  \nBear in mind however, that using only shared cache, i.e., without builtin, should be more effective.  \n\n####  ssl_session_timeout\nsyntax: `ssl_session_timeout time`  \ndefault: `ssl_session_timeout 5m`  \ncontext: `tcp, server`  \nThis directive defines the maximum time during which the client can re-use the previously negotiated cryptographic parameters of the secure session that is stored in the SSL cache.  \n\n##   Compatibility\n* My test bed is 0.7.65+  \n##  Notes\nThe http_response_parse.rl and smtp_response_parse.rl are ragel\n(<http://www.complang.org/ragel/>) scripts , you can edit the script and compile it like this:  \n```bash\n$ ragel -G2 http_response_parse.rl\n$ ragel -G2 smtp_response_parse.rl\n```  \n##  TODO\n* refact this module, make it more extendable for adding third-party modules  \n* manipulate header like http module's proxy_set_header  \n* built-in variable support  \n* custom log format  \n* syslog support  \n* FTP/IRC proxying  \n\n##  Known Issues\n* This module can't use the same listening port with the HTTP module.  \n##  Changelogs\n###  v0.2.0\n* add ssl proxy module  \n* add websocket proxy module  \n* add upstream busyness module  \n* add tcp access log module  \n###  v0.19\n* add many check methods  \n##  v0.1\n* first release  \n##  Authors\nWeibin Yao(姚伟斌) `yaoweibin at gmail dot com`  \n## Copyright & License\nThis README template copy from agentzh (<http://github.com/agentzh>),I borrowed a lot of code from upstream and mail module from the nginx 0.7 core. This part of code is copyrighted by Igor Sysoev. And the health check part is borrowed the design of Jack Lindamood's healthcheck module healthcheck_nginx_upstreams (<http://github.com/cep21/healthcheck_nginx_upstreams>);  \nThis module is licensed under the BSD license.  \n```bash\n    Copyright (C) 2013 by Weibin Yao <yaoweibin@gmail.com>.\n    \n    All rights reserved.\n    \n    Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are\n    met:\n    \n    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n    \n    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n    \n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n    IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 2.2451171875,
          "content": "ngx_feature=\"nginx_tcp_module\"\nngx_feature_name=\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\"$ngx_addon_dir/modules $ngx_addon_dir/parsers $ngx_addon_dir\"\nngx_feature_deps=\"$ngx_addon_dir/ngx_tcp.h $ngx_addon_dir/ngx_tcp_session.h $ngx_addon_dir/ngx_tcp_upstream.h $ngx_addon_dir/ngx_tcp_upstream_check.h $ngx_addon_dir/ngx_tcp_upstream_round_robin.h\"\nngx_tcp_src=\"$ngx_addon_dir/ngx_tcp.c $ngx_addon_dir/ngx_tcp_core_module.c $ngx_addon_dir/ngx_tcp_session.c $ngx_addon_dir/ngx_tcp_access.c $ngx_addon_dir/ngx_tcp_log.c $ngx_addon_dir/ngx_tcp_upstream.c $ngx_addon_dir/ngx_tcp_upstream_round_robin.c $ngx_addon_dir/modules/ngx_tcp_generic_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_websocket_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_ip_hash_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_busyness_module.c $ngx_addon_dir/ngx_tcp_upstream_check.c \"\nngx_tcp_ssl_deps=\"$ngx_addon_dir/modules/ngx_tcp_ssl_module.h\"\nngx_tcp_ssl_src=\"$ngx_addon_dir/modules/ngx_tcp_ssl_module.c\"\nngx_tcp_parser_deps=\"$ngx_addon_dir/parsers/parser.h $ngx_addon_dir/parsers/http_request_parser.h $ngx_addon_dir/parsers/http_response_parser.h $ngx_addon_dir/parsers/smtp_response_parser.h\"\nngx_tcp_parser_src=\"$ngx_addon_dir/parsers/http_request_parser.c $ngx_addon_dir/parsers/http_response_parser.c $ngx_addon_dir/parsers/smtp_response_parser.c\"\nngx_feature_test=\"int a;\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n    ngx_addon_name=ngx_tcp_module\n\n    TCP_CORE_MODULES=\"ngx_tcp_module ngx_tcp_core_module ngx_tcp_upstream_module\"\n    TCP_MODULES=\"ngx_tcp_proxy_module ngx_tcp_websocket_module ngx_tcp_upstream_ip_hash_module ngx_tcp_upstream_busyness_module\"\n\n    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_feature_deps $ngx_tcp_parser_deps\"\n    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_tcp_src $ngx_tcp_parser_src\"\n\n    have=NGX_TCP_SSL . auto/have\n    USE_OPENSSL=YES\n    TCP_MODULES=\"$TCP_MODULES ngx_tcp_ssl_module\"\n    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_tcp_ssl_deps\"\n    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_tcp_ssl_src\"\n\n    EVENT_MODULES=\"$EVENT_MODULES $TCP_CORE_MODULES $TCP_MODULES\"\n    HTTP_MODULES=\"$HTTP_MODULES ngx_tcp_upstream_check_status_module\"\nelse \n    cat << END\n    $0: error: the ngx_tcp_module addon error.\nEND\n    exit 1\nfi\n"
        },
        {
          "name": "config_without_ssl",
          "type": "blob",
          "size": 2.25,
          "content": "ngx_feature=\"nginx_tcp_module\"\nngx_feature_name=\nngx_feature_run=no\nngx_feature_incs=\nngx_feature_path=\"$ngx_addon_dir/modules $ngx_addon_dir/parsers $ngx_addon_dir\"\nngx_feature_deps=\"$ngx_addon_dir/ngx_tcp.h $ngx_addon_dir/ngx_tcp_session.h $ngx_addon_dir/ngx_tcp_upstream.h $ngx_addon_dir/ngx_tcp_upstream_check.h $ngx_addon_dir/ngx_tcp_upstream_round_robin.h\"\nngx_tcp_src=\"$ngx_addon_dir/ngx_tcp.c $ngx_addon_dir/ngx_tcp_core_module.c $ngx_addon_dir/ngx_tcp_session.c $ngx_addon_dir/ngx_tcp_access.c $ngx_addon_dir/ngx_tcp_log.c $ngx_addon_dir/ngx_tcp_upstream.c $ngx_addon_dir/ngx_tcp_upstream_round_robin.c $ngx_addon_dir/modules/ngx_tcp_generic_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_websocket_proxy_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_ip_hash_module.c $ngx_addon_dir/modules/ngx_tcp_upstream_busyness_module.c $ngx_addon_dir/ngx_tcp_upstream_check.c \"\nngx_tcp_ssl_deps=\"$ngx_addon_dir/modules/ngx_tcp_ssl_module.h\"\nngx_tcp_ssl_src=\"$ngx_addon_dir/modules/ngx_tcp_ssl_module.c\"\nngx_tcp_parser_deps=\"$ngx_addon_dir/parsers/parser.h $ngx_addon_dir/parsers/http_request_parser.h $ngx_addon_dir/parsers/http_response_parser.h $ngx_addon_dir/parsers/smtp_response_parser.h\"\nngx_tcp_parser_src=\"$ngx_addon_dir/parsers/http_request_parser.c $ngx_addon_dir/parsers/http_response_parser.c $ngx_addon_dir/parsers/smtp_response_parser.c\"\nngx_feature_test=\"int a;\"\n. auto/feature\n\nif [ $ngx_found = yes ]; then\n    CORE_INCS=\"$CORE_INCS $ngx_feature_path\"\n    ngx_addon_name=ngx_tcp_module\n\n    TCP_CORE_MODULES=\"ngx_tcp_module ngx_tcp_core_module ngx_tcp_upstream_module\"\n    TCP_MODULES=\"ngx_tcp_proxy_module ngx_tcp_websocket_module ngx_tcp_upstream_ip_hash_module ngx_tcp_upstream_busyness_module\"\n\n    NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_feature_deps $ngx_tcp_parser_deps\"\n    NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_tcp_src $ngx_tcp_parser_src\"\n\n    #have=NGX_TCP_SSL . auto/have\n    #USE_OPENSSL=YES\n    #TCP_MODULES=\"$TCP_MODULES ngx_tcp_ssl_module\"\n    #NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_tcp_ssl_deps\"\n    #NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_tcp_ssl_src\"\n\n    EVENT_MODULES=\"$EVENT_MODULES $TCP_CORE_MODULES $TCP_MODULES\"\n    HTTP_MODULES=\"$HTTP_MODULES ngx_tcp_upstream_check_status_module\"\nelse \n    cat << END\n    $0: error: the ngx_tcp_module addon error.\nEND\n    exit 1\nfi\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "modules",
          "type": "tree",
          "content": null
        },
        {
          "name": "ngx_tcp.c",
          "type": "blob",
          "size": 14.513671875,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_tcp.h>\n\n\nstatic char *ngx_tcp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic ngx_int_t ngx_tcp_add_ports(ngx_conf_t *cf, ngx_array_t *ports,\n    ngx_tcp_listen_t *listen);\nstatic ngx_int_t ngx_tcp_add_virtual_servers(ngx_conf_t *cf, \n        ngx_tcp_core_main_conf_t *cmcf, ngx_tcp_listen_t *listen);\nstatic char * ngx_tcp_optimize_servers(ngx_conf_t *cf, \n        ngx_tcp_core_main_conf_t *cmcf, ngx_array_t *ports);\nstatic ngx_int_t ngx_tcp_add_addrs(ngx_conf_t *cf, ngx_tcp_port_t *mport,\n    ngx_tcp_conf_addr_t *addr);\n#if (NGX_HAVE_INET6)\nstatic ngx_int_t ngx_tcp_add_addrs6(ngx_conf_t *cf, ngx_tcp_port_t *mport,\n    ngx_tcp_conf_addr_t *addr);\n#endif\nstatic ngx_int_t ngx_tcp_cmp_conf_addrs(const void *one, const void *two);\n\n\nngx_uint_t  ngx_tcp_max_module;\n\n\nstatic ngx_command_t  ngx_tcp_commands[] = {\n\n    { ngx_string(\"tcp\"),\n      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,\n      ngx_tcp_block,\n      0,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_core_module_t  ngx_tcp_module_ctx = {\n    ngx_string(\"tcp\"),\n    NULL,\n    NULL\n};\n\n\nngx_module_t  ngx_tcp_module = {\n    NGX_MODULE_V1,\n    &ngx_tcp_module_ctx,                   /* module context */\n    ngx_tcp_commands,                      /* module directives */\n    NGX_CORE_MODULE,                       /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic char *\nngx_tcp_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                        *rv;\n    ngx_uint_t                   i, m, mi, s;\n    ngx_conf_t                   pcf;\n    ngx_array_t                  ports;\n    ngx_tcp_listen_t           *listen;\n    ngx_tcp_module_t           *module;\n    ngx_tcp_conf_ctx_t         *ctx;\n    ngx_tcp_core_srv_conf_t   **cscfp;\n    ngx_tcp_core_main_conf_t   *cmcf;\n\n\n    /* the main tcp context */\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *(ngx_tcp_conf_ctx_t **) conf = ctx;\n\n    /* count the number of the tcp modules and set up their indices */\n\n    ngx_tcp_max_module = 0;\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n            continue;\n        }\n\n        ngx_modules[m]->ctx_index = ngx_tcp_max_module++;\n    }\n\n\n    /* the tcp main_conf context, it is the same in the all tcp contexts */\n\n    ctx->main_conf = ngx_pcalloc(cf->pool,\n                                 sizeof(void *) * ngx_tcp_max_module);\n    if (ctx->main_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * the tcp null srv_conf context, it is used to merge\n     * the server{}s' srv_conf's\n     */\n\n    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_tcp_max_module);\n    if (ctx->srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    /*\n     * create the main_conf's, the null srv_conf's, and the null loc_conf's\n     * of the all tcp modules\n     */\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]->ctx;\n        mi = ngx_modules[m]->ctx_index;\n\n        if (module->create_main_conf) {\n            ctx->main_conf[mi] = module->create_main_conf(cf);\n            if (ctx->main_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module->create_srv_conf) {\n            ctx->srv_conf[mi] = module->create_srv_conf(cf);\n            if (ctx->srv_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n\n    /* parse inside the tcp{} block */\n\n    pcf = *cf;\n    cf->ctx = ctx;\n\n    cf->module_type = NGX_TCP_MODULE;\n    cf->cmd_type = NGX_TCP_MAIN_CONF;\n    rv = ngx_conf_parse(cf, NULL);\n\n    if (rv != NGX_CONF_OK) {\n        *cf = pcf;\n        return rv;\n    }\n\n\n    /* init tcp{} main_conf's, merge the server{}s' srv_conf's */\n\n    cmcf = ctx->main_conf[ngx_tcp_core_module.ctx_index];\n    cscfp = cmcf->servers.elts;\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]->ctx;\n        mi = ngx_modules[m]->ctx_index;\n\n        /* init tcp{} main_conf's */\n\n        cf->ctx = ctx;\n\n        if (module->init_main_conf) {\n            rv = module->init_main_conf(cf, ctx->main_conf[mi]);\n            if (rv != NGX_CONF_OK) {\n                *cf = pcf;\n                return rv;\n            }\n        }\n\n        for (s = 0; s < cmcf->servers.nelts; s++) {\n\n            /* merge the server{}s' srv_conf's */\n\n            cf->ctx = cscfp[s]->ctx;\n\n            if (module->merge_srv_conf) {\n                rv = module->merge_srv_conf(cf, ctx->srv_conf[mi],\n                                            cscfp[s]->ctx->srv_conf[mi]);\n                if (rv != NGX_CONF_OK) {\n                    *cf = pcf;\n                    return rv;\n                }\n            }\n        }\n    }\n\n    *cf = pcf;\n\n    if (ngx_array_init(&ports, cf->temp_pool, 4, sizeof(ngx_tcp_conf_port_t))\n        != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    listen = cmcf->listen.elts;\n\n    for (i = 0; i < cmcf->listen.nelts; i++) {\n        if (ngx_tcp_add_ports(cf, &ports, &listen[i]) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        if (ngx_tcp_add_virtual_servers(cf, cmcf, &listen[i]) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return ngx_tcp_optimize_servers(cf, cmcf, &ports);\n}\n\n\nstatic ngx_int_t\nngx_tcp_add_ports(ngx_conf_t *cf, ngx_array_t *ports, ngx_tcp_listen_t *listen)\n{\n    in_port_t              p;\n    ngx_uint_t             i;\n    struct sockaddr       *sa;\n    struct sockaddr_in    *sin;\n    ngx_tcp_conf_port_t   *port;\n    ngx_tcp_conf_addr_t   *addr;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6   *sin6;\n#endif\n\n    sa = (struct sockaddr *) &listen->sockaddr;\n\n    switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n    case AF_INET6:\n        sin6 = (struct sockaddr_in6 *) sa;\n        p = sin6->sin6_port;\n        break;\n#endif\n\n    default: /* AF_INET */\n        sin = (struct sockaddr_in *) sa;\n        p = sin->sin_port;\n        break;\n    }\n\n    port = ports->elts;\n    for (i = 0; i < ports->nelts; i++) {\n        if (p == port[i].port && sa->sa_family == port[i].family) {\n\n            /* a port is already in the port list */\n\n            port = &port[i];\n            goto found;\n        }\n    }\n\n    /* add a port to the port list */\n\n    port = ngx_array_push(ports);\n    if (port == NULL) {\n        return NGX_ERROR;\n    }\n\n    port->family = sa->sa_family;\n    port->port = p;\n\n    if (ngx_array_init(&port->addrs, cf->temp_pool, 2,\n                       sizeof(ngx_tcp_conf_addr_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\nfound:\n\n    addr = ngx_array_push(&port->addrs);\n    if (addr == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(addr, sizeof(ngx_tcp_conf_addr_t));\n\n    addr->sockaddr = (struct sockaddr *) &listen->sockaddr;\n    addr->socklen = listen->socklen;\n    addr->ctx = listen->ctx;\n    addr->bind = listen->bind;\n    addr->wildcard = listen->wildcard;\n    if (listen->default_port) {\n        addr->default_ctx = listen->ctx;\n    }\n#if (NGX_TCP_SSL)\n    addr->ssl = listen->ssl;\n#endif\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n    addr->ipv6only = listen->ipv6only;\n#endif\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_add_virtual_servers(ngx_conf_t *cf, ngx_tcp_core_main_conf_t *cmcf,\n    ngx_tcp_listen_t *listen)\n{\n    ngx_tcp_core_srv_conf_t   *cscf;\n    ngx_tcp_virtual_server_t  *vs;\n\n    cscf = listen->conf;\n    if (cscf == NULL || cscf->server_name.len == 0) {\n        return NGX_OK;\n    }\n\n    vs = ngx_array_push(&cmcf->virtual_servers);\n    if (vs == NULL) {\n        return NGX_ERROR;\n    }\n\n    vs->name.len = cscf->server_name.len;\n    vs->name.data = cscf->server_name.data;\n    vs->hash = ngx_hash_key(vs->name.data, vs->name.len);\n    vs->listen = listen;\n    vs->ctx = listen->ctx;\n\n    return NGX_OK;\n}\n\n\nstatic char *\nngx_tcp_optimize_servers(ngx_conf_t *cf, ngx_tcp_core_main_conf_t *cmcf,\n    ngx_array_t *ports)\n{\n    ngx_uint_t             i, p, last, bind_wildcard;\n    ngx_listening_t       *ls;\n    ngx_tcp_port_t        *mport;\n    ngx_tcp_conf_port_t   *port;\n    ngx_tcp_conf_addr_t   *addr;\n\n    port = ports->elts;\n    for (p = 0; p < ports->nelts; p++) {\n\n        ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts,\n                 sizeof(ngx_tcp_conf_addr_t), ngx_tcp_cmp_conf_addrs);\n\n        addr = port[p].addrs.elts;\n        last = port[p].addrs.nelts;\n\n        /*\n         * if there is the binding to the \"*:port\" then we need to bind()\n         * to the \"*:port\" only and ignore the other bindings\n         */\n\n        if (addr[last - 1].wildcard) {\n            addr[last - 1].bind = 1;\n            bind_wildcard = 1;\n\n        } else {\n            bind_wildcard = 0;\n        }\n\n        i = 0;\n\n        while (i < last) {\n\n            if (bind_wildcard && !addr[i].bind) {\n                i++;\n                continue;\n            }\n\n            ls = ngx_create_listening(cf, addr[i].sockaddr, addr[i].socklen);\n            if (ls == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ls->addr_ntop = 1;\n            ls->handler = ngx_tcp_init_connection;\n            ls->pool_size = 256;\n\n            /* TODO: error_log directive */\n            ls->logp = &cf->cycle->new_log;\n            ls->log.data = &ls->addr_text;\n            ls->log.handler = ngx_accept_log_error;\n\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n            ls->ipv6only = addr[i].ipv6only;\n#endif\n\n            mport = ngx_palloc(cf->pool, sizeof(ngx_tcp_port_t));\n            if (mport == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ls->servers = mport;\n\n            if (i == last - 1) {\n                mport->naddrs = last;\n\n            } else {\n                mport->naddrs = 1;\n                i = 0;\n            }\n\n            switch (ls->sockaddr->sa_family) {\n#if (NGX_HAVE_INET6)\n            case AF_INET6:\n                if (ngx_tcp_add_addrs6(cf, mport, addr) != NGX_OK) {\n                    return NGX_CONF_ERROR;\n                }\n                break;\n#endif\n            default: /* AF_INET */\n                if (ngx_tcp_add_addrs(cf, mport, addr) != NGX_OK) {\n                    return NGX_CONF_ERROR;\n                }\n                break;\n            }\n\n            addr++;\n            last--;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic ngx_int_t\nngx_tcp_add_addrs(ngx_conf_t *cf, ngx_tcp_port_t *mport,\n    ngx_tcp_conf_addr_t *addr)\n{\n    u_char              *p;\n    size_t               len;\n    ngx_uint_t           i, j;\n    ngx_tcp_in_addr_t   *addrs;\n    struct sockaddr_in  *sin, *sin_b;\n    u_char               buf[NGX_SOCKADDR_STRLEN];\n\n    mport->addrs = ngx_pcalloc(cf->pool,\n                               mport->naddrs * sizeof(ngx_tcp_in_addr_t));\n    if (mport->addrs == NULL) {\n        return NGX_ERROR;\n    }\n\n    addrs = mport->addrs;\n\n    for (i = 0; i < mport->naddrs; i++) {\n\n        sin = (struct sockaddr_in *) addr[i].sockaddr;\n        addrs[i].addr = sin->sin_addr.s_addr;\n\n        addrs[i].conf.ctx = addr[i].ctx;\n\n        for (j = 0; j < mport->naddrs; j++) {\n            sin_b = (struct sockaddr_in *) addr[j].sockaddr;\n            if ((sin->sin_addr.s_addr == sin_b->sin_addr.s_addr) && addr[j].default_ctx) {\n                addrs[i].conf.default_ctx = addr[j].default_ctx;\n            }\n        }\n\n#if (NGX_TCP_SSL)\n        addrs[i].conf.ssl = addr[i].ssl;\n#endif\n\n#if defined(nginx_version) && nginx_version >= 1005003\n        len = ngx_sock_ntop(addr[i].sockaddr, addr[i].socklen, buf, NGX_SOCKADDR_STRLEN, 1);\n#else\n        len = ngx_sock_ntop(addr[i].sockaddr, buf, NGX_SOCKADDR_STRLEN, 1);\n#endif\n\n        p = ngx_pnalloc(cf->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(p, buf, len);\n\n        addrs[i].conf.addr_text.len = len;\n        addrs[i].conf.addr_text.data = p;\n    }\n\n    return NGX_OK;\n}\n\n\n#if (NGX_HAVE_INET6)\n\nstatic ngx_int_t\nngx_tcp_add_addrs6(ngx_conf_t *cf, ngx_tcp_port_t *mport,\n    ngx_tcp_conf_addr_t *addr)\n{\n    u_char               *p;\n    size_t                len;\n    ngx_uint_t            i, j;\n    ngx_tcp_in6_addr_t   *addrs6;\n    struct sockaddr_in6  *sin6, *sin6_b;\n    u_char                buf[NGX_SOCKADDR_STRLEN];\n\n    mport->addrs = ngx_pcalloc(cf->pool,\n                               mport->naddrs * sizeof(ngx_tcp_in6_addr_t));\n    if (mport->addrs == NULL) {\n        return NGX_ERROR;\n    }\n\n    addrs6 = mport->addrs;\n\n    for (i = 0; i < mport->naddrs; i++) {\n\n        sin6 = (struct sockaddr_in6 *) addr[i].sockaddr;\n        addrs6[i].addr6 = sin6->sin6_addr;\n\n        addrs6[i].conf.ctx = addr[i].ctx;\n\n        for (j = 0; j < mport->naddrs; j++) {\n            sin6_b = (struct sockaddr_in6 *) addr[j].sockaddr;\n\n            if ((ngx_memcmp(&sin6->sin6_addr, &sin6_b->sin6_addr, 16) == 0) && \n                    addr[j].default_ctx) {\n                addrs6[i].conf.default_ctx = addr[j].default_ctx;\n            }\n        }\n\n#if (NGX_TCP_SSL)\n        addrs6[i].conf.ssl = addr[i].ssl;\n#endif\n\n#if defined(nginx_version) && nginx_version >= 1005003\n        len = ngx_sock_ntop(addr[i].sockaddr, addr[i].socklen, buf, NGX_SOCKADDR_STRLEN, 1);\n#else\n        len = ngx_sock_ntop(addr[i].sockaddr, buf, NGX_SOCKADDR_STRLEN, 1);\n#endif\n\n        p = ngx_pnalloc(cf->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy(p, buf, len);\n\n        addrs6[i].conf.addr_text.len = len;\n        addrs6[i].conf.addr_text.data = p;\n    }\n\n    return NGX_OK;\n}\n\n#endif\n\n\nstatic ngx_int_t\nngx_tcp_cmp_conf_addrs(const void *one, const void *two)\n{\n    ngx_tcp_conf_addr_t  *first, *second;\n\n    first = (ngx_tcp_conf_addr_t *) one;\n    second = (ngx_tcp_conf_addr_t *) two;\n\n    if (first->wildcard) {\n        /* a wildcard must be the last resort, shift it to the end */\n        return 1;\n    }\n\n    if (first->bind && !second->bind) {\n        /* shift explicit bind()ed addresses to the start */\n        return -1;\n    }\n\n    if (!first->bind && second->bind) {\n        /* shift explicit bind()ed addresses to the start */\n        return 1;\n    }\n\n    /* do not sort by default */\n\n    return 0;\n}\n"
        },
        {
          "name": "ngx_tcp.h",
          "type": "blob",
          "size": 7.6953125,
          "content": "\n#ifndef _NGX_TCP_H_INCLUDED_\n#define _NGX_TCP_H_INCLUDED_\n\n\n#include <nginx.h>\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_event_connect.h>\n\n\ntypedef struct ngx_tcp_protocol_s  ngx_tcp_protocol_t;\ntypedef struct ngx_tcp_upstream_s  ngx_tcp_upstream_t;\ntypedef struct ngx_tcp_cleanup_s  ngx_tcp_cleanup_t;\n\ntypedef struct ngx_tcp_core_srv_conf_s ngx_tcp_core_srv_conf_t;\n\ntypedef struct ngx_tcp_upstream_srv_conf_s  ngx_tcp_upstream_srv_conf_t;\ntypedef struct ngx_tcp_upstream_resolved_s  ngx_tcp_upstream_resolved_t;\n\ntypedef struct ngx_tcp_check_peer_conf_s ngx_tcp_check_peer_conf_t;\ntypedef struct ngx_tcp_check_peers_conf_s ngx_tcp_check_peers_conf_t;\ntypedef struct check_conf_s check_conf_t;\n\n/* make nginx-0.8.22+ happy */\n#if defined(nginx_version) && nginx_version >= 8022\ntypedef ngx_addr_t ngx_peer_addr_t; \n#endif\n\n#include <ngx_tcp_session.h>\n#include <ngx_tcp_upstream.h>\n#include <ngx_tcp_upstream_check.h>\n#include <ngx_tcp_upstream_round_robin.h>\n\n#if (NGX_TCP_SSL)\n#include <ngx_tcp_ssl_module.h>\n#endif\n\n\ntypedef struct {\n    void                  **main_conf;\n    void                  **srv_conf;\n} ngx_tcp_conf_ctx_t;\n\n\ntypedef struct {\n    u_char                  sockaddr[NGX_SOCKADDRLEN];\n    socklen_t               socklen;\n\n    /* server ctx */\n    ngx_tcp_conf_ctx_t     *ctx;\n\n    unsigned                default_port:1;\n    unsigned                bind:1;\n    unsigned                wildcard:1;\n#if (NGX_TCP_SSL)\n    unsigned                ssl:1;\n#endif\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n    unsigned                ipv6only:2;\n#endif\n    ngx_tcp_core_srv_conf_t *conf;\n} ngx_tcp_listen_t;\n\n\ntypedef struct {\n    ngx_str_t                name;\n} ngx_tcp_server_name_t;\n\n\ntypedef struct {\n    ngx_uint_t               hash;\n    ngx_str_t                name;\n    ngx_tcp_listen_t        *listen;\n    ngx_tcp_conf_ctx_t      *ctx;\n} ngx_tcp_virtual_server_t;\n\n\ntypedef struct {\n    ngx_str_t                name;\n} ngx_tcp_core_loc_t;\n\n\ntypedef struct {\n    ngx_tcp_conf_ctx_t      *ctx;\n    ngx_tcp_conf_ctx_t      *default_ctx;\n    ngx_str_t                addr_text;\n#if (NGX_TCP_SSL)\n    ngx_uint_t               ssl;    /* unsigned   ssl:1; */\n#endif\n} ngx_tcp_addr_conf_t;\n\ntypedef struct {\n    in_addr_t                addr;\n    ngx_tcp_addr_conf_t      conf;\n} ngx_tcp_in_addr_t;\n\n\n#if (NGX_HAVE_INET6)\n\ntypedef struct {\n    struct in6_addr          addr6;\n    ngx_tcp_addr_conf_t      conf;\n} ngx_tcp_in6_addr_t;\n\n#endif\n\n\ntypedef struct {\n    /* ngx_tcp_in_addr_t or ngx_tcp_in6_addr_t */\n    void                    *addrs;\n    ngx_uint_t               naddrs;\n} ngx_tcp_port_t;\n\n\ntypedef struct {\n    int                      family;\n    in_port_t                port;\n    ngx_array_t              addrs;       /* array of ngx_tcp_conf_addr_t */\n} ngx_tcp_conf_port_t;\n\n\ntypedef struct {\n    struct sockaddr         *sockaddr;\n    socklen_t                socklen;\n\n    ngx_tcp_conf_ctx_t      *ctx;\n    ngx_tcp_conf_ctx_t      *default_ctx;\n\n    unsigned                 bind:1;\n    unsigned                 wildcard:1;\n#if (NGX_TCP_SSL)\n    unsigned                 ssl:1;\n#endif\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n    unsigned                 ipv6only:2;\n#endif\n} ngx_tcp_conf_addr_t;\n\ntypedef struct {\n    in_addr_t                mask;\n    in_addr_t                addr;\n    ngx_uint_t               deny;      /* unsigned  deny:1; */\n} ngx_tcp_access_rule_t;\n\ntypedef struct {\n    ngx_array_t              servers;         /* ngx_tcp_core_srv_conf_t */\n    ngx_array_t              listen;          /* ngx_tcp_listen_t */\n    ngx_array_t              virtual_servers; /* ngx_tcp_virtual_server_t */\n} ngx_tcp_core_main_conf_t;\n\ntypedef struct {\n    ngx_open_file_t         *file;\n    time_t                   disk_full_time;\n    time_t                   error_log_time;\n} ngx_tcp_log_t;\n\ntypedef struct {\n    u_char                  *start;\n    u_char                  *pos;\n    u_char                  *last;\n} ngx_tcp_log_buf_t;\n\ntypedef struct {\n    ngx_array_t             *logs;       /* array of ngx_tcp_log_t */\n\n    ngx_open_file_cache_t   *open_file_cache;\n    time_t                   open_file_cache_valid;\n    ngx_uint_t               open_file_cache_min_uses;\n\n    ngx_uint_t               off;        /* unsigned  off:1 */\n} ngx_tcp_log_srv_conf_t;\n\n\n#define NGX_TCP_GENERIC_PROTOCOL    0\n#define NGX_TCP_WEBSOCKET_PROTOCOL  1\n\n\nstruct ngx_tcp_core_srv_conf_s {\n    /* array of the ngx_tcp_server_name_t, \"server_name\" directive */\n    ngx_array_t              server_names;\n\n    /* array of the ngx_tcp_core_loc_t, \"location\" directive */\n    ngx_array_t              locations;\n\n    ngx_tcp_protocol_t      *protocol;\n\n    ngx_msec_t               timeout;\n    ngx_msec_t               resolver_timeout;\n\n    ngx_flag_t               so_keepalive;\n    ngx_flag_t               tcp_nodelay;\n\n    ngx_str_t                server_name;\n\n    u_char                  *file_name;\n    ngx_int_t                line;\n\n    ngx_resolver_t          *resolver;\n\n    /*ACL rules*/\n    ngx_array_t             *rules;\n\n    ngx_tcp_log_srv_conf_t  *access_log;\n\n    /* server ctx */\n    ngx_tcp_conf_ctx_t      *ctx;\n};\n\n\ntypedef struct {\n    ngx_str_t              *client;\n    ngx_tcp_session_t      *session;\n} ngx_tcp_log_ctx_t;\n\n\ntypedef void (*ngx_tcp_init_session_pt)(ngx_tcp_session_t *s);\ntypedef void (*ngx_tcp_init_protocol_pt)(ngx_event_t *rev);\ntypedef void (*ngx_tcp_parse_protocol_pt)(ngx_event_t *rev);\n\n\nstruct ngx_tcp_protocol_s {\n    ngx_str_t                   name;\n    in_port_t                   port[4];\n    ngx_uint_t                  type;\n\n    ngx_tcp_init_session_pt     init_session;\n    ngx_tcp_init_protocol_pt    init_protocol;\n    ngx_tcp_parse_protocol_pt   parse_protocol;\n\n    ngx_str_t                   internal_server_error;\n};\n\n\ntypedef struct {\n    ngx_tcp_protocol_t         *protocol;\n\n    void                       *(*create_main_conf)(ngx_conf_t *cf);\n    char                       *(*init_main_conf)(ngx_conf_t *cf, void *conf);\n\n    void                       *(*create_srv_conf)(ngx_conf_t *cf);\n    char                       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev,\n                                      void *conf);\n} ngx_tcp_module_t;\n\n\n#define NGX_TCP_MODULE         0x00504354     /* \"TCP\" */\n\n#define NGX_TCP_MAIN_CONF      0x02000000\n#define NGX_TCP_SRV_CONF       0x04000000\n#define NGX_TCP_LOC_CONF       0x08000000\n#define NGX_TCP_UPS_CONF       0x10000000\n\n\n#define NGX_TCP_MAIN_CONF_OFFSET  offsetof(ngx_tcp_conf_ctx_t, main_conf)\n#define NGX_TCP_SRV_CONF_OFFSET   offsetof(ngx_tcp_conf_ctx_t, srv_conf)\n\n\n#define ngx_tcp_get_module_ctx(s, module)     (s)->ctx[module.ctx_index]\n#define ngx_tcp_set_ctx(s, c, module)         s->ctx[module.ctx_index] = c;\n#define ngx_tcp_delete_ctx(s, module)         s->ctx[module.ctx_index] = NULL;\n\n\n#define ngx_tcp_get_module_main_conf(s, module)                             \\\n    (s)->main_conf[module.ctx_index]\n#define ngx_tcp_get_module_srv_conf(s, module)  (s)->srv_conf[module.ctx_index]\n\n#define ngx_tcp_conf_get_module_main_conf(cf, module)                       \\\n    ((ngx_tcp_conf_ctx_t *) cf->ctx)->main_conf[module.ctx_index]\n#define ngx_tcp_conf_get_module_srv_conf(cf, module)                        \\\n    ((ngx_tcp_conf_ctx_t *) cf->ctx)->srv_conf[module.ctx_index]\n\n#define ngx_tcp_cycle_get_module_main_conf(cycle, module)                   \\\n    (cycle->conf_ctx[ngx_tcp_module.index] ?                                \\\n        ((ngx_tcp_conf_ctx_t *) cycle->conf_ctx[ngx_tcp_module.index])      \\\n            ->main_conf[module.ctx_index]:                                  \\\n        NULL)\n\nextern ngx_uint_t    ngx_tcp_max_module;\nextern ngx_module_t  ngx_tcp_core_module;\nextern ngx_module_t  ngx_tcp_module;\n\n#endif /* _NGX_TCP_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_tcp_access.c",
          "type": "blob",
          "size": 1.1806640625,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_tcp.h>\n\n\nngx_int_t\nngx_tcp_access_handler(ngx_tcp_session_t *s) \n{\n    ngx_uint_t                   i;\n    struct sockaddr_in          *sin;\n    ngx_tcp_access_rule_t       *rule;\n    ngx_tcp_core_srv_conf_t     *cscf;\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    if (cscf->rules == NULL) {\n        return NGX_DECLINED;\n    }\n\n    /* AF_INET only */\n\n    if (s->connection->sockaddr->sa_family != AF_INET) {\n        return NGX_DECLINED;\n    }\n\n    sin = (struct sockaddr_in *) s->connection->sockaddr;\n\n    rule = cscf->rules->elts;\n    for (i = 0; i < cscf->rules->nelts; i++) {\n\n        ngx_log_debug3(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                       \"access: %08XD %08XD %08XD\",\n                       sin->sin_addr.s_addr, rule[i].mask, rule[i].addr);\n\n        if ((sin->sin_addr.s_addr & rule[i].mask) == rule[i].addr) {\n            if (rule[i].deny) {\n                ngx_log_error(NGX_LOG_NOTICE, s->connection->log, 0,\n                              \"access forbidden by rule\");\n\n                return NGX_ERROR;\n            }\n\n            return NGX_OK;\n        }\n    }\n\n    return NGX_DECLINED;\n}\n"
        },
        {
          "name": "ngx_tcp_core_module.c",
          "type": "blob",
          "size": 23.47265625,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_tcp.h>\n#include <nginx.h>\n\n#ifndef NGX_CONF_MULTI\n#define NGX_CONF_MULTI 0\n#endif\n\n\nstatic void *ngx_tcp_core_create_main_conf(ngx_conf_t *cf);\nstatic void *ngx_tcp_core_create_srv_conf(ngx_conf_t *cf);\nstatic char *ngx_tcp_core_merge_srv_conf(ngx_conf_t *cf, void *parent,\n    void *child);\nstatic char *ngx_tcp_core_server(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_core_location(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_access_rule(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_log_set_access_log(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\n\nstatic ngx_command_t  ngx_tcp_core_commands[] = {\n\n    { ngx_string(\"server\"),\n      NGX_TCP_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_MULTI|NGX_CONF_NOARGS,\n      ngx_tcp_core_server,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"listen\"),\n      NGX_TCP_SRV_CONF|NGX_CONF_1MORE,\n      ngx_tcp_core_listen,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"server_names\"),\n      NGX_TCP_SRV_CONF|NGX_CONF_1MORE,\n      ngx_tcp_core_server_name,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"location\"),\n      NGX_TCP_SRV_CONF|NGX_TCP_LOC_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE1,\n      ngx_tcp_core_location,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"protocol\"),\n      NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_tcp_core_protocol,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"so_keepalive\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_core_srv_conf_t, so_keepalive),\n      NULL },\n\n    { ngx_string(\"tcp_nodelay\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_core_srv_conf_t, tcp_nodelay),\n      NULL },\n\n    { ngx_string(\"timeout\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_core_srv_conf_t, timeout),\n      NULL },\n\n    { ngx_string(\"server_name\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_core_srv_conf_t, server_name),\n      NULL },\n\n    { ngx_string(\"resolver\"),\n#if defined(nginx_version) && nginx_version >= 1001007\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_1MORE,\n#else\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n#endif\n      ngx_tcp_core_resolver,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"resolver_timeout\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_core_srv_conf_t, resolver_timeout),\n      NULL },\n\n    { ngx_string(\"allow\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_tcp_access_rule,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"deny\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE1,\n      ngx_tcp_access_rule,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"access_log\"),\n      NGX_TCP_MAIN_CONF|NGX_TCP_SRV_CONF|NGX_CONF_TAKE12,\n      ngx_tcp_log_set_access_log,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    ngx_null_command\n};\n\n\nstatic ngx_tcp_module_t  ngx_tcp_core_module_ctx = {\n    NULL,                                  /* protocol */\n\n    ngx_tcp_core_create_main_conf,         /* create main configuration */\n    NULL,                                  /* init main configuration */\n\n    ngx_tcp_core_create_srv_conf,          /* create server configuration */\n    ngx_tcp_core_merge_srv_conf            /* merge server configuration */\n};\n\n\nngx_module_t  ngx_tcp_core_module = {\n    NGX_MODULE_V1,\n    &ngx_tcp_core_module_ctx,              /* module context */\n    ngx_tcp_core_commands,                 /* module directives */\n    NGX_TCP_MODULE,                        /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_str_t  ngx_tcp_access_log = ngx_string(\"logs/tcp_access.log\");\n\n\nstatic void *\nngx_tcp_core_create_main_conf(ngx_conf_t *cf) \n{\n    ngx_tcp_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_core_main_conf_t));\n    if (cmcf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&cmcf->servers, cf->pool, 4,\n                       sizeof(ngx_tcp_core_srv_conf_t *))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    if (ngx_array_init(&cmcf->listen, cf->pool, 4, sizeof(ngx_tcp_listen_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    if (ngx_array_init(&cmcf->virtual_servers, cf->pool, 4, \n                       sizeof(ngx_tcp_virtual_server_t)) != NGX_OK)\n    {\n        return NULL;\n    }\n\n\n    return cmcf;\n}\n\n\nstatic void *\nngx_tcp_core_create_srv_conf(ngx_conf_t *cf) \n{\n    ngx_tcp_core_srv_conf_t  *cscf;\n    ngx_tcp_log_srv_conf_t   *lscf;\n\n    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_core_srv_conf_t));\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * set by ngx_pcalloc():\n     *\n     *     cscf->protocol = NULL;\n     */\n\n    if (ngx_array_init(&cscf->server_names, cf->pool, 4,\n                       sizeof(ngx_tcp_server_name_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    if (ngx_array_init(&cscf->locations, cf->pool, 4,\n                       sizeof(ngx_tcp_core_loc_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    cscf->timeout = NGX_CONF_UNSET_MSEC;\n    cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;\n    cscf->so_keepalive = NGX_CONF_UNSET;\n    cscf->tcp_nodelay = NGX_CONF_UNSET;\n\n    cscf->resolver = NGX_CONF_UNSET_PTR;\n\n    cscf->file_name = cf->conf_file->file.name.data;\n    cscf->line = cf->conf_file->line;\n\n    lscf = cscf->access_log = ngx_pcalloc(cf->pool, \n                                          sizeof(ngx_tcp_log_srv_conf_t));\n    if (lscf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * set by ngx_pcalloc():\n     *\n     *     lscf->logs = NULL;\n     */\n\n    lscf->open_file_cache = NGX_CONF_UNSET_PTR;\n\n    return cscf;\n}\n\n\nstatic char *\nngx_tcp_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child) \n{\n    ngx_uint_t               m;\n    ngx_tcp_log_t           *log;\n    ngx_tcp_module_t        *module;\n    ngx_tcp_core_srv_conf_t *prev = parent;\n    ngx_tcp_core_srv_conf_t *conf = child;\n    ngx_tcp_log_srv_conf_t  *plscf = prev->access_log;\n    ngx_tcp_log_srv_conf_t  *lscf = conf->access_log;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n    ngx_conf_merge_msec_value(conf->resolver_timeout,\n                              prev->resolver_timeout, 30000);\n\n    ngx_conf_merge_value(conf->so_keepalive, prev->so_keepalive, 0);\n    ngx_conf_merge_value(conf->tcp_nodelay, prev->tcp_nodelay, 1);\n\n    ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n\n    if (conf->protocol == NULL) {\n        for (m = 0; ngx_modules[m]; m++) {\n            if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n                continue;\n            }\n\n            module = ngx_modules[m]->ctx;\n\n            /* TODO: use a function */\n            if (module->protocol \n                    && (ngx_strcmp(module->protocol->name.data, \"tcp_generic\")) == 0)\n            {\n                conf->protocol = module->protocol;\n            }\n        }\n    }\n\n    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);\n\n    if (conf->rules == NULL) {\n        conf->rules = prev->rules;\n    }\n\n    if (lscf->open_file_cache == NGX_CONF_UNSET_PTR) {\n\n        lscf->open_file_cache = plscf->open_file_cache;\n        lscf->open_file_cache_valid = plscf->open_file_cache_valid;\n        lscf->open_file_cache_min_uses = plscf->open_file_cache_min_uses;\n\n        if (lscf->open_file_cache == NGX_CONF_UNSET_PTR) {\n            lscf->open_file_cache = NULL;\n        }\n    }\n\n    if (lscf->logs || lscf->off) {\n        return NGX_CONF_OK;\n    }\n\n    lscf->logs = plscf->logs;\n    lscf->off = plscf->off;\n\n    if (lscf->logs || lscf->off) {\n        return NGX_CONF_OK;\n    }\n\n    lscf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_tcp_log_t));\n    if (lscf->logs == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    log = ngx_array_push(lscf->logs);\n    if (log == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    log->file = ngx_conf_open_file(cf->cycle, &ngx_tcp_access_log);\n    if (log->file == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    log->disk_full_time = 0;\n    log->error_log_time = 0;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_tcp_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                       *rv;\n    void                       *mconf;\n    ngx_uint_t                  m;\n    ngx_conf_t                  pcf;\n    ngx_tcp_module_t           *module;\n    ngx_tcp_conf_ctx_t         *ctx, *tcp_ctx;\n    ngx_tcp_core_srv_conf_t    *cscf, **cscfp;\n    ngx_tcp_core_main_conf_t   *cmcf;\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    tcp_ctx = cf->ctx;\n    ctx->main_conf = tcp_ctx->main_conf;\n\n    /* the server{}'s srv_conf */\n\n    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_tcp_max_module);\n    if (ctx->srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]->ctx;\n\n        if (module->create_srv_conf) {\n            mconf = module->create_srv_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;\n        }\n    }\n\n    /* the server configuration context */\n\n    cscf = ctx->srv_conf[ngx_tcp_core_module.ctx_index];\n    cscf->ctx = ctx;\n\n    cmcf = ctx->main_conf[ngx_tcp_core_module.ctx_index];\n\n    cscfp = ngx_array_push(&cmcf->servers);\n    if (cscfp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *cscfp = cscf;\n\n    /* parse inside server{} */\n\n    pcf = *cf;\n    cf->ctx = ctx;\n    cf->cmd_type = NGX_TCP_SRV_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf = pcf;\n\n    return rv;\n}\n\n\nstatic char *\nngx_tcp_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) \n{\n    size_t                      len, off;\n    in_port_t                   port;\n    ngx_str_t                  *value;\n    ngx_url_t                   u;\n    ngx_uint_t                  i;\n    struct sockaddr            *sa;\n    ngx_tcp_listen_t           *ls;\n    struct sockaddr_in         *sin;\n    ngx_tcp_core_main_conf_t   *cmcf;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6        *sin6;\n#endif\n\n    value = cf->args->elts;\n\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    u.url = value[1];\n    u.listen = 1;\n\n    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n        if (u.err) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"%s in \\\"%V\\\" of the \\\"listen\\\" directive\",\n                               u.err, &u.url);\n        }\n\n        return NGX_CONF_ERROR;\n    }\n\n    cmcf = ngx_tcp_conf_get_module_main_conf(cf, ngx_tcp_core_module);\n\n    ls = cmcf->listen.elts;\n\n    for (i = 0; i < cmcf->listen.nelts; i++) {\n\n        sa = (struct sockaddr *) ls[i].sockaddr;\n\n        if (sa->sa_family != u.family) {\n            continue;\n        }\n\n        switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n            case AF_INET6:\n                off = offsetof(struct sockaddr_in6, sin6_addr);\n                len = 16;\n                sin6 = (struct sockaddr_in6 *) sa;\n                port = sin6->sin6_port;\n                break;\n#endif\n\n            default: /* AF_INET */\n                off = offsetof(struct sockaddr_in, sin_addr);\n                len = 4;\n                sin = (struct sockaddr_in *) sa;\n                port = sin->sin_port;\n                break;\n        }\n#if defined(nginx_version) && nginx_version >= 1014002\n        if (ngx_memcmp(ls[i].sockaddr + off, ((char*)&u.sockaddr) + off, len) != 0) {\n#else\n        if (ngx_memcmp(ls[i].sockaddr + off, u.sockaddr + off, len) != 0) {\n#endif\n            continue;\n        }\n\n        if (port != u.port) {\n            continue;\n        }\n\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                \"duplicate \\\"%V\\\" address and port pair\", &u.url);\n        return NGX_CONF_ERROR;\n    }\n\n    ls = ngx_array_push(&cmcf->listen);\n    if (ls == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(ls, sizeof(ngx_tcp_listen_t));\n\n#if defined(nginx_version) && nginx_version >= 1014002\n    ngx_memcpy(ls->sockaddr, &u.sockaddr, u.socklen);\n#else\n    ngx_memcpy(ls->sockaddr, u.sockaddr, u.socklen);\n#endif\n    ls->socklen = u.socklen;\n    ls->wildcard = u.wildcard;\n    ls->ctx = cf->ctx;\n    ls->conf = conf;\n\n    for (i = 2; i < cf->args->nelts; i++) {\n\n        if (ngx_strcmp(value[i].data, \"bind\") == 0) {\n            ls->bind = 1;\n            continue;\n        }\n\n        if (ngx_strcmp(value[i].data, \"default\") == 0) {\n            ls->default_port = 1;\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"ipv6only=o\", 10) == 0) {\n#if (NGX_HAVE_INET6 && defined IPV6_V6ONLY)\n            struct sockaddr  *sa;\n            u_char            buf[NGX_SOCKADDR_STRLEN];\n\n            sa = (struct sockaddr *) ls->sockaddr;\n\n            if (sa->sa_family == AF_INET6) {\n\n                if (ngx_strcmp(&value[i].data[10], \"n\") == 0) {\n                    ls->ipv6only = 1;\n\n                } else if (ngx_strcmp(&value[i].data[10], \"ff\") == 0) {\n                    ls->ipv6only = 2;\n\n                } else {\n                    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                            \"invalid ipv6only flags \\\"%s\\\"\",\n                            &value[i].data[9]);\n                    return NGX_CONF_ERROR;\n                }\n\n                ls->bind = 1;\n\n            } else {\n#if defined(nginx_version) && nginx_version >= 1005003\n                len = ngx_sock_ntop(sa, ls->socklen, buf, NGX_SOCKADDR_STRLEN, 1);\n#else\n                len = ngx_sock_ntop(sa, buf, NGX_SOCKADDR_STRLEN, 1);\n#endif\n\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                        \"ipv6only is not supported \"\n                        \"on addr \\\"%*s\\\", ignored\", len, buf);\n            }\n\n            continue;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                    \"bind ipv6only is not supported \"\n                    \"on this platform\");\n            return NGX_CONF_ERROR;\n#endif\n        }\n\n        if (ngx_strcmp(value[i].data, \"ssl\") == 0) {\n#if (NGX_TCP_SSL)\n            ls->ssl = 1;\n            continue;\n#else\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"the \\\"ssl\\\" parameter requires \"\n                               \"ngx_tcp_ssl_module\");\n            return NGX_CONF_ERROR;\n#endif\n        }\n\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                \"the invalid \\\"%V\\\" parameter\", &value[i]);\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_tcp_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_tcp_core_srv_conf_t *cscf = conf;\n\n    ngx_str_t               *value;\n    ngx_uint_t               i;\n    ngx_tcp_server_name_t   *sn;\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        sn = ngx_array_push(&cscf->server_names);\n        if (sn == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        if (ngx_strcasecmp(value[i].data, (u_char *) \"$hostname\") == 0) {\n            sn->name = cf->cycle->hostname;\n\n        } else {\n            sn->name = value[i];\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_tcp_core_location(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_tcp_core_srv_conf_t   *cscf = conf;\n\n    char                      *rv;\n    ngx_str_t                 *value;\n    ngx_conf_t                 save;\n    ngx_tcp_core_loc_t        *clcf;\n\n    clcf = ngx_array_push(&cscf->locations);\n    if (clcf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    clcf->name = value[1];\n\n    save = *cf;\n    cf->cmd_type = NGX_TCP_LOC_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf = save;\n\n    return rv;\n}\n\n\nstatic char *\nngx_tcp_core_protocol(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_tcp_core_srv_conf_t  *cscf = conf;\n\n    ngx_str_t          *value;\n    ngx_uint_t          m;\n    ngx_tcp_module_t   *module;\n\n    value = cf->args->elts;\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]->ctx;\n\n        if (module->protocol\n            && ngx_strcmp(module->protocol->name.data, value[1].data) == 0)\n        {\n            cscf->protocol = module->protocol;\n\n            return NGX_CONF_OK;\n        }\n    }\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"unknown protocol \\\"%V\\\"\", &value[1]);\n\n    return NGX_CONF_ERROR;\n}\n\n\nstatic char *\nngx_tcp_core_resolver(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) \n{\n    ngx_tcp_core_srv_conf_t  *cscf = conf;\n\n#if defined(nginx_version) && nginx_version < 1001007\n    ngx_url_t   u;\n#endif\n    ngx_str_t  *value;\n\n    value = cf->args->elts;\n\n    if (cscf->resolver != NGX_CONF_UNSET_PTR) {\n        return \"is duplicate\";\n    }\n\n    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n        cscf->resolver = NULL;\n        return NGX_CONF_OK;\n    }\n\n#if defined(nginx_version) && nginx_version < 1001007\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    u.host = value[1];\n    u.port = 53;\n\n    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"%V: %s\", &u.host, u.err);\n        return NGX_CONF_ERROR;\n    }\n    cscf->resolver = ngx_resolver_create(cf, &u.addrs[0]);\n    if (cscf->resolver == NULL) {\n        return NGX_CONF_OK;\n    }\n#else\n\n    cscf->resolver = ngx_resolver_create(cf, &value[1], cf->args->nelts - 1);\n    if (cscf->resolver == NULL) {\n        return NGX_CONF_ERROR;\n    }\n#endif\n\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_tcp_access_rule(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) \n{\n    ngx_tcp_core_srv_conf_t *cscf = conf;\n\n    ngx_int_t                rc;\n    ngx_str_t               *value;\n    ngx_cidr_t               cidr;\n    ngx_tcp_access_rule_t   *rule;\n\n    if (cscf->rules == NULL) {\n        cscf->rules = ngx_array_create(cf->pool, 4,\n                                       sizeof(ngx_tcp_access_rule_t));\n        if (cscf->rules == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    rule = ngx_array_push(cscf->rules);\n    if (rule == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n\n    rule->deny = (value[0].data[0] == 'd') ? 1 : 0;\n\n    if (value[1].len == 3 && ngx_strcmp(value[1].data, \"all\") == 0) {\n        rule->mask = 0;\n        rule->addr = 0;\n\n        return NGX_CONF_OK;\n    }\n\n    rc = ngx_ptocidr(&value[1], &cidr);\n\n    if (rc == NGX_ERROR) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\",\n                           &value[1]);\n        return NGX_CONF_ERROR;\n    }\n\n    if (cidr.family != AF_INET) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"\\\"allow\\\" supports IPv4 only\");\n        return NGX_CONF_ERROR;\n    }\n\n    if (rc == NGX_DONE) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"low address bits of %V are meaningless\", &value[1]);\n    }\n\n    rule->mask = cidr.u.in.mask;\n    rule->addr = cidr.u.in.addr;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_tcp_log_set_access_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_tcp_core_srv_conf_t *cscf = conf;\n    ngx_tcp_log_srv_conf_t  *lscf = cscf->access_log;\n\n    ssize_t                     size;\n    ngx_str_t                  *value, name;\n    ngx_tcp_log_t              *log;\n#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000\n    ngx_tcp_log_buf_t         *buffer;\n#endif\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"off\") == 0) {\n        lscf->off = 1;\n        if (cf->args->nelts == 2) {\n            return NGX_CONF_OK;\n        }\n\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid parameter \\\"%V\\\"\", &value[2]);\n        return NGX_CONF_ERROR;\n    }\n\n    if (lscf->logs == NULL) {\n        lscf->logs = ngx_array_create(cf->pool, 2, sizeof(ngx_tcp_log_t));\n        if (lscf->logs == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    log = ngx_array_push(lscf->logs);\n    if (log == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(log, sizeof(ngx_tcp_log_t));\n\n    log->file = ngx_conf_open_file(cf->cycle, &value[1]);\n    if (log->file == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (cf->args->nelts == 3) {\n        if (ngx_strncmp(value[2].data, \"buffer=\", 7) != 0) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid parameter \\\"%V\\\"\", &value[2]);\n            return NGX_CONF_ERROR;\n        }\n\n        name.len = value[2].len - 7;\n        name.data = value[2].data + 7;\n\n        size = ngx_parse_size(&name);\n\n        if (size == NGX_ERROR) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid parameter \\\"%V\\\"\", &value[2]);\n            return NGX_CONF_ERROR;\n        }\n\n#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000\n        if (log->file->data) {\n\n            buffer = log->file->data;\n\n            if (buffer->last - buffer->pos != size) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                        \"access_log \\\"%V\\\" already defined \"\n                        \"with different buffer size\", &value[1]);\n                return NGX_CONF_ERROR;\n            }\n\n            return NGX_CONF_OK;\n        }\n\n        buffer = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_log_buf_t));\n        if (buffer == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        buffer->start = ngx_palloc(cf->pool, size);\n        if (buffer->start == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        buffer->pos = buffer->start;\n        buffer->last = buffer->start + size;\n\n        log->file->data = buffer;\n#else\n        if (log->file->buffer) {\n            if (log->file->last - log->file->pos != size) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"access_log \\\"%V\\\" already defined \"\n                                   \"with different buffer size\", &value[1]);\n                return NGX_CONF_ERROR;\n            }\n\n            return NGX_CONF_OK;\n        }\n\n        log->file->buffer = ngx_palloc(cf->pool, size);\n        if (log->file->buffer == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        log->file->pos = log->file->buffer;\n        log->file->last = log->file->buffer + size;\n#endif\n    }\n\n    return NGX_CONF_OK;\n}\n"
        },
        {
          "name": "ngx_tcp_log.c",
          "type": "blob",
          "size": 5.6943359375,
          "content": "\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_tcp.h>\n\n\nstatic u_char * ngx_tcp_time(u_char *buf, time_t t);\nstatic u_char *ngx_tcp_log_fill(ngx_tcp_session_t *s, u_char *buf);\nstatic void ngx_tcp_log_write(ngx_tcp_session_t *s, ngx_tcp_log_t *log,\n    u_char *buf, size_t len);\n\n\nngx_int_t\nngx_tcp_log_handler(ngx_tcp_session_t *s)\n{\n    u_char                   *line, *p;\n    size_t                    len;\n    ngx_uint_t                l;\n    ngx_connection_t         *c;\n    ngx_tcp_log_t            *log;\n    ngx_open_file_t          *file;\n#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000\n    ngx_tcp_log_buf_t        *buffer;\n#endif\n   ngx_tcp_log_srv_conf_t    *lscf;\n    ngx_tcp_core_srv_conf_t  *cscf;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                   \"tcp access log handler\");\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n    lscf = cscf->access_log;\n\n    if (lscf->off) {\n        return NGX_OK;\n    }\n\n    c = s->connection;\n    log = lscf->logs->elts;\n    for (l = 0; l < lscf->logs->nelts; l++) {\n\n        if (ngx_time() == log[l].disk_full_time) {\n\n            /*\n             * on FreeBSD writing to a full filesystem with enabled softupdates\n             * may block process for much longer time than writing to non-full\n             * filesystem, so we skip writing to a log for one second\n             */\n\n            continue;\n        }\n\n        len = 0;\n\n        /* Calculate the length */\n        len += sizeof(\"1970/09/28 12:00:00\");   /* log time */\n        len += NGX_INT64_LEN + 2;               /* [ngx_pid] */\n        len += c->addr_text.len + 1;            /* client address */\n        len += s->addr_text->len + 1;           /* this session address */\n        len += sizeof(\"1970/09/28 12:00:00\");   /* accept time */\n        len += sizeof(\"255.255.255.255:65536\"); /* upstream address */\n        len += NGX_OFF_T_LEN + 1;               /* read bytes from client */\n        len += NGX_OFF_T_LEN + 1;               /* write bytes to client */\n        len += NGX_LINEFEED_SIZE;\n\n        file = log[l].file;\n\n#if (nginx_version) >= 1003010 || (nginx_version) >= 1002007 && (nginx_version) < 1003000\n        if (file && file->data) {\n\n            buffer = file->data;\n\n            if (len > (size_t) (buffer->last - buffer->pos)) {\n\n                ngx_tcp_log_write(s, &log[l], buffer->start,\n                                  buffer->pos - buffer->start);\n\n                buffer->pos = buffer->start;\n            }\n\n            if (len <= (size_t) (buffer->last - buffer->pos)) {\n\n                p = buffer->pos;\n\n                p = ngx_tcp_log_fill(s, p);\n\n                buffer->pos = p;\n\n                continue;\n            }\n        }\n#else\n        if (file && file->buffer) {\n\n            if (len > (size_t) (file->last - file->pos)) {\n\n                ngx_tcp_log_write(s, &log[l], file->buffer,\n                                  file->pos - file->buffer);\n\n                file->pos = file->buffer;\n            }\n\n            if (len <= (size_t) (file->last - file->pos)) {\n\n                p = file->pos;\n\n                p = ngx_tcp_log_fill(s, p);\n\n                file->pos = p;\n\n                continue;\n            }\n        }\n#endif\n\n        line = ngx_pnalloc(s->pool, len);\n        if (line == NULL) {\n            return NGX_ERROR;\n        }\n\n        p = line;\n\n        p = ngx_tcp_log_fill(s, p);\n\n        ngx_tcp_log_write(s, &log[l], line, p - line);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic u_char *\nngx_tcp_time(u_char *buf, time_t t)\n{\n    ngx_tm_t    tm;\n\n    ngx_localtime(t, &tm);\n\n    return ngx_sprintf(buf, \"%4d/%02d/%02d %02d:%02d:%02d\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec);\n}\n\n\nstatic u_char *\nngx_tcp_log_fill(ngx_tcp_session_t *s, u_char *buf) \n{\n    u_char              *last;\n    ngx_str_t           *name;\n    ngx_connection_t    *c;\n    ngx_tcp_upstream_t  *u;\n\n    c = s->connection;\n\n    last = ngx_cpymem(buf, ngx_cached_err_log_time.data,\n            ngx_cached_err_log_time.len);\n\n    last = ngx_sprintf(last, \" [%P]\", ngx_pid);\n    last = ngx_sprintf(last, \" %V\", &c->addr_text);\n    last = ngx_sprintf(last, \" %V \", s->addr_text);\n    last = ngx_tcp_time(last, s->start_sec);\n    \n    name = NULL;\n    if (s->upstream) {\n        u = s->upstream;\n        if (u->peer.connection) {\n            name = u->peer.name;\n        }\n    }\n\n    if (name) {\n        last = ngx_sprintf(last, \" %V\", name);\n    }\n    else {\n        last = ngx_sprintf(last, \" -\");\n    }\n\n    last = ngx_sprintf(last, \" %O\", s->bytes_read);\n    last = ngx_sprintf(last, \" %O\", s->bytes_write);\n\n    ngx_linefeed(last);\n\n    return last;\n}\n\n\nstatic void\nngx_tcp_log_write(ngx_tcp_session_t *s, ngx_tcp_log_t *log, u_char *buf,\n    size_t len)\n{\n    u_char     *name;\n    time_t      now;\n    ssize_t     n;\n    ngx_err_t   err;\n\n    if(len == 0) return;\n\n    name = log->file->name.data;\n    n = ngx_write_fd(log->file->fd, buf, len);\n\n    if (n == (ssize_t) len) {\n        return;\n    }\n\n    now = ngx_time();\n\n    if (n == -1) {\n        err = ngx_errno;\n\n        if (err == NGX_ENOSPC) {\n            log->disk_full_time = now;\n        }\n\n        if (now - log->error_log_time > 59) {\n            ngx_log_error(NGX_LOG_ALERT, s->connection->log, err,\n                          ngx_write_fd_n \" to \\\"%s\\\" failed\", name);\n\n            log->error_log_time = now;\n        }\n\n        return;\n    }\n\n    if (now - log->error_log_time > 59) {\n        ngx_log_error(NGX_LOG_ALERT, s->connection->log, 0,\n                      ngx_write_fd_n \" to \\\"%s\\\" was incomplete: %z of %uz\",\n                      name, n, len);\n\n        log->error_log_time = now;\n    }\n}\n"
        },
        {
          "name": "ngx_tcp_session.c",
          "type": "blob",
          "size": 11.0009765625,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_tcp.h>\n\n\nstatic void ngx_tcp_init_session(ngx_connection_t *c);\nstatic void ngx_tcp_set_session_socket(ngx_tcp_session_t *s);\nstatic void ngx_tcp_process_session(ngx_connection_t *c);\n\n#if (NGX_TCP_SSL)\nstatic void ngx_tcp_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c);\nstatic void ngx_tcp_ssl_handshake_handler(ngx_connection_t *c);\n#endif\n\n\nvoid\nngx_tcp_init_connection(ngx_connection_t *c)\n{\n    ngx_uint_t            i;\n    ngx_tcp_port_t       *port;\n    struct sockaddr      *sa;\n    struct sockaddr_in   *sin;\n    ngx_tcp_log_ctx_t    *ctx;\n    ngx_tcp_in_addr_t    *addr;\n    ngx_tcp_session_t    *s;\n    ngx_tcp_addr_conf_t  *addr_conf;\n#if (NGX_HAVE_INET6)\n    struct sockaddr_in6  *sin6;\n    ngx_tcp_in6_addr_t   *addr6;\n#endif\n\n\n    /* find the server configuration for the address:port */\n\n    /* AF_INET only */\n\n    port = c->listening->servers;\n\n    if (port->naddrs > 1) {\n\n        /*\n         * There are several addresses on this port and one of them\n         * is the \"*:port\" wildcard so getsockname() is needed to determine\n         * the server address.\n         *\n         * AcceptEx() already gave this address.\n         */\n\n        if (ngx_connection_local_sockaddr(c, NULL, 0) != NGX_OK) {\n            ngx_tcp_close_connection(c);\n            return;\n        }\n\n        sa = c->local_sockaddr;\n\n        switch (sa->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            sin6 = (struct sockaddr_in6 *) sa;\n\n            addr6 = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (ngx_memcmp(&addr6[i].addr6, &sin6->sin6_addr, 16) == 0) {\n                    break;\n                }\n            }\n\n            addr_conf = &addr6[i].conf;\n\n            break;\n#endif\n\n        default: /* AF_INET */\n            sin = (struct sockaddr_in *) sa;\n\n            addr = port->addrs;\n\n            /* the last address is \"*\" */\n\n            for (i = 0; i < port->naddrs - 1; i++) {\n                if (addr[i].addr == sin->sin_addr.s_addr) {\n                    break;\n                }\n            }\n\n            addr_conf = &addr[i].conf;\n\n            break;\n        }\n\n    } else {\n        switch (c->local_sockaddr->sa_family) {\n\n#if (NGX_HAVE_INET6)\n        case AF_INET6:\n            addr6 = port->addrs;\n            addr_conf = &addr6[0].conf;\n            break;\n#endif\n\n        default: /* AF_INET */\n            addr = port->addrs;\n            addr_conf = &addr[0].conf;\n            break;\n        }\n    }\n\n    s = ngx_pcalloc(c->pool, sizeof(ngx_tcp_session_t));\n    if (s == NULL) {\n        ngx_tcp_close_connection(c);\n        return;\n    }\n\n    if (addr_conf->default_ctx) {\n        s->main_conf = addr_conf->default_ctx->main_conf;\n        s->srv_conf = addr_conf->default_ctx->srv_conf;\n    }\n    else {\n        s->main_conf = addr_conf->ctx->main_conf;\n        s->srv_conf = addr_conf->ctx->srv_conf;\n    }\n\n    s->addr_text = &addr_conf->addr_text;\n\n    c->data = s;\n    s->connection = c;\n\n    ngx_log_error(NGX_LOG_INFO, c->log, 0, \"*%ui client %V connected to %V\",\n                  c->number, &c->addr_text, s->addr_text);\n\n    ctx = ngx_palloc(c->pool, sizeof(ngx_tcp_log_ctx_t));\n    if (ctx == NULL) {\n        ngx_tcp_close_connection(c);\n        return;\n    }\n\n    ctx->client = &c->addr_text;\n    ctx->session = s;\n\n    c->log->connection = c->number;\n    c->log->handler = ngx_tcp_log_error;\n    c->log->data = ctx;\n    c->log->action = \"nginx tcp module init connection\";\n\n    c->log_error = NGX_ERROR_INFO;\n\n#if (NGX_TCP_SSL)\n\n    {\n    ngx_tcp_ssl_srv_conf_t  *sscf;\n\n    sscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_ssl_module);\n    if (sscf->enable || addr_conf->ssl) {\n\n        if (c->ssl == NULL) {\n\n            c->log->action = \"SSL handshaking\";\n\n            if (addr_conf->ssl && sscf->ssl.ctx == NULL) {\n                ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                              \"no \\\"ssl_certificate\\\" is defined \"\n                              \"in server listening on SSL port\");\n                ngx_tcp_close_connection(c);\n                return;\n            }\n\n            ngx_tcp_ssl_init_connection(&sscf->ssl, c);\n            return;\n        }\n    }\n    }\n\n#endif\n\n    ngx_tcp_init_session(c);\n}\n\n\n#if (NGX_TCP_SSL)\n\nstatic void\nngx_tcp_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)\n{\n    ngx_tcp_session_t        *s;\n    ngx_tcp_core_srv_conf_t  *cscf;\n\n    if (ngx_ssl_create_connection(ssl, c, NGX_SSL_BUFFER) == NGX_ERROR) {\n        ngx_tcp_close_connection(c);\n        return;\n    }\n\n    if (ngx_ssl_handshake(c) == NGX_AGAIN) {\n\n        s = c->data;\n\n        cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n        ngx_add_timer(c->read, cscf->timeout);\n\n        c->ssl->handler = ngx_tcp_ssl_handshake_handler;\n\n        return;\n    }\n\n    ngx_tcp_ssl_handshake_handler(c);\n}\n\n\nstatic void\nngx_tcp_ssl_handshake_handler(ngx_connection_t *c)\n{\n    if (c->ssl->handshaked) {\n\n        c->read->ready = 0;\n\n        ngx_tcp_init_session(c);\n        return;\n    }\n\n    ngx_tcp_close_connection(c);\n}\n\n#endif\n\n\nstatic void\nngx_tcp_init_session(ngx_connection_t *c)\n{\n    ngx_time_t               *tp;\n    ngx_tcp_session_t        *s;\n    ngx_tcp_core_srv_conf_t  *cscf;\n\n    s = c->data;\n\n    s->signature = NGX_TCP_MODULE;\n    s->pool = c->pool;\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n    if (cscf == NULL) {\n        ngx_tcp_finalize_session(s);\n        return;\n    }\n\n    s->ctx = ngx_pcalloc(s->pool, sizeof(void *) * ngx_tcp_max_module);\n    if (s->ctx == NULL) {\n        ngx_tcp_finalize_session(s);\n        return;\n    }\n\n    tp = ngx_timeofday();\n    s->start_sec = tp->sec;\n    s->start_msec = tp->msec;\n\n    s->bytes_read = 0;\n    s->bytes_write = 0;\n\n    ngx_tcp_set_session_socket(s);\n\n    ngx_tcp_process_session(c);\n}\n\n\nstatic void \nngx_tcp_set_session_socket(ngx_tcp_session_t *s) \n{\n    int                       keepalive;\n    int                       tcp_nodelay;\n    ngx_tcp_core_srv_conf_t  *cscf;\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    if (cscf->so_keepalive) {\n        keepalive = 1;\n\n        if (setsockopt(s->connection->fd, SOL_SOCKET, SO_KEEPALIVE,\n                       (const void *) &keepalive, sizeof(int)) == -1)\n        {\n            ngx_log_error(NGX_LOG_ALERT, s->connection->log, ngx_socket_errno,\n                          \"setsockopt(SO_KEEPALIVE) failed\");\n        }\n    }\n\n    if (cscf->tcp_nodelay) {\n        tcp_nodelay = 1;\n        if (setsockopt(s->connection->fd, IPPROTO_TCP, TCP_NODELAY,\n                       (const void *) &tcp_nodelay, sizeof(int))\n            == -1)\n        {\n            ngx_log_error(NGX_LOG_ALERT, s->connection->log, ngx_socket_errno,\n                          \"setsockopt(TCP_NODELAY) failed\");\n        }\n\n        s->connection->tcp_nodelay = NGX_TCP_NODELAY_SET;\n    }\n}\n\n\nstatic void\nngx_tcp_process_session(ngx_connection_t *c)\n{\n    ngx_tcp_session_t         *s;\n    ngx_tcp_core_srv_conf_t   *cscf;\n\n    s = c->data;\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    /* process the ACL */\n    if (ngx_tcp_access_handler(s) == NGX_ERROR) {\n        ngx_tcp_finalize_session(s);\n        return;\n    }\n\n    cscf->protocol->init_session(s);\n}\n\n\nvoid\nngx_tcp_send(ngx_event_t *wev)\n{\n    ngx_int_t                  n;\n    ngx_connection_t          *c;\n    ngx_tcp_session_t         *s;\n    ngx_tcp_core_srv_conf_t   *cscf;\n\n    c = wev->data;\n    s = c->data;\n\n    if (wev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n        c->timedout = 1;\n        ngx_tcp_close_connection(c);\n        return;\n    }\n\n    if (s->out.len == 0) {\n        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n            ngx_tcp_close_connection(c);\n        }\n\n        return;\n    }\n\n    n = c->send(c, s->out.data, s->out.len);\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, wev->log, 0, \"nginx tcp send:%d\", n);\n\n    if (n > 0) {\n        s->out.len -= n;\n\n        if (wev->timer_set) {\n            ngx_del_timer(wev);\n        }\n\n        if (s->quit) {\n            ngx_tcp_close_connection(c);\n            return;\n        }\n\n        return;\n    }\n\n    if (n == NGX_ERROR) {\n        ngx_tcp_close_connection(c);\n        return;\n    }\n\n    /* n == NGX_AGAIN */\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    ngx_add_timer(c->write, cscf->timeout);\n\n    if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n        ngx_tcp_close_connection(c);\n        return;\n    }\n}\n\n\nvoid\nngx_tcp_session_internal_server_error(ngx_tcp_session_t *s)\n{\n    ngx_tcp_core_srv_conf_t  *cscf;\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    s->out = cscf->protocol->internal_server_error;\n    s->quit = 1;\n\n    ngx_tcp_send(s->connection->write);\n}\n\n\nvoid \nngx_tcp_finalize_session(ngx_tcp_session_t *s)\n{\n    ngx_connection_t *c;\n    ngx_tcp_cleanup_t *cln;\n\n    c = s->connection;\n\n    ngx_tcp_log_handler(s);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,\n                   \"close tcp session: %d\", c->fd);\n\n    for (cln = s->cleanup; cln; cln = cln->next) {\n        if (cln->handler) {\n            cln->handler(cln->data);\n            cln->handler = NULL;\n        }\n    }\n\n    ngx_tcp_close_connection(c);\n\n    return;\n}\n\n\nvoid\nngx_tcp_close_connection(ngx_connection_t *c)\n{\n    ngx_pool_t  *pool;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,\n                   \"close tcp connection: %d\", c->fd);\n\n#if (NGX_TCP_SSL)\n\n    if (c->ssl) {\n        if (ngx_ssl_shutdown(c) == NGX_AGAIN) {\n            c->ssl->handler = ngx_tcp_close_connection;\n            return;\n        }\n    }\n\n#endif\n\n#if (NGX_STAT_STUB)\n    (void) ngx_atomic_fetch_add(ngx_stat_active, -1);\n#endif\n\n    c->destroyed = 1;\n\n    pool = c->pool;\n\n    ngx_close_connection(c);\n\n    ngx_destroy_pool(pool);\n}\n\n\nu_char *\nngx_tcp_log_error(ngx_log_t *log, u_char *buf, size_t len)\n{\n    u_char              *p;\n    ngx_tcp_session_t   *s;\n    ngx_tcp_log_ctx_t   *ctx;\n\n    p = buf;\n\n    if (log->action) {\n        p = ngx_snprintf(p, len + (buf - p), \" while %s\", log->action);\n    }\n\n    ctx = log->data;\n\n    p = ngx_snprintf(p, len + (buf - p), \", client: %V\", ctx->client);\n\n    s = ctx->session;\n\n    if (s == NULL) {\n        return p;\n    }\n\n    p = ngx_snprintf(p, len + (buf - p), \", server: %V\", s->addr_text);\n\n    if (s->upstream) {\n        if (s->upstream->peer.connection) {\n            p = ngx_snprintf(p, len + (buf - p), \", upstream: %V\", s->upstream->peer.name);\n        }\n    }\n\n    return p;\n}\n\n\nngx_tcp_cleanup_t *\nngx_tcp_cleanup_add(ngx_tcp_session_t *s, size_t size)\n{\n    ngx_tcp_cleanup_t  *cln;\n\n    cln = ngx_palloc(s->pool, sizeof(ngx_tcp_cleanup_t));\n    if (cln == NULL) {\n        return NULL;\n    }\n\n    if (size) {\n        cln->data = ngx_palloc(s->pool, size);\n        if (cln->data == NULL) {\n            return NULL;\n        }\n\n    } else {\n        cln->data = NULL;\n    }\n\n    cln->handler = NULL;\n    cln->next = s->cleanup;\n\n    s->cleanup = cln;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                   \"tcp cleanup add: %p\", cln);\n\n    return cln;\n}\n"
        },
        {
          "name": "ngx_tcp_session.h",
          "type": "blob",
          "size": 1.771484375,
          "content": "\n#ifndef _NGX_TCP_SESSION_H_INCLUDED_\n#define _NGX_TCP_SESSION_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_event_connect.h>\n#include <ngx_tcp.h>\n\n\ntypedef struct ngx_tcp_session_s {\n    uint32_t                signature;         /* \"TCP\" */\n\n    ngx_pool_t             *pool;\n\n    ngx_connection_t       *connection;\n    ngx_tcp_upstream_t     *upstream;\n\n    ngx_str_t               out;\n    ngx_buf_t              *buffer;\n\n    void                  **ctx;\n    void                  **main_conf;\n    void                  **srv_conf;\n\n    ngx_resolver_ctx_t     *resolver_ctx;\n\n    ngx_tcp_cleanup_t      *cleanup;\n\n    time_t                  start_sec;\n    ngx_msec_t              start_msec;\n\n    off_t                   bytes_read;\n    off_t                   bytes_write;\n\n    unsigned                quit:1;\n    ngx_str_t              *addr_text;\n    ngx_str_t               host;\n\n} ngx_tcp_session_t;\n\n\ntypedef void (*ngx_tcp_cleanup_pt)(void *data);\n\n\nstruct ngx_tcp_cleanup_s {\n    ngx_tcp_cleanup_pt      handler;\n    void                   *data;\n    ngx_tcp_cleanup_t      *next;\n};\n\nvoid ngx_tcp_init_connection(ngx_connection_t *c);\n\nvoid ngx_tcp_send(ngx_event_t *wev);\nngx_int_t ngx_tcp_read_command(ngx_tcp_session_t *s, ngx_connection_t *c);\nvoid ngx_tcp_auth(ngx_tcp_session_t *s, ngx_connection_t *c);\nvoid ngx_tcp_close_connection(ngx_connection_t *c);\nvoid ngx_tcp_session_internal_server_error(ngx_tcp_session_t *s);\n\nu_char *ngx_tcp_log_error(ngx_log_t *log, u_char *buf, size_t len);\n\nvoid ngx_tcp_finalize_session(ngx_tcp_session_t *s);\n\nngx_tcp_cleanup_t * ngx_tcp_cleanup_add(ngx_tcp_session_t *s, size_t size);\n\nngx_int_t ngx_tcp_access_handler(ngx_tcp_session_t *s);\nngx_int_t ngx_tcp_log_handler(ngx_tcp_session_t *s);\n\n#endif\n"
        },
        {
          "name": "ngx_tcp_upstream.c",
          "type": "blob",
          "size": 28.759765625,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_tcp.h>\n#include <ngx_tcp_upstream.h>\n\n\nstatic void ngx_tcp_upstream_cleanup(void *data);\n\nstatic void ngx_tcp_upstream_handler(ngx_event_t *ev); \nstatic void ngx_tcp_upstream_connect(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_t *u);\nstatic void ngx_tcp_upstream_resolve_handler(ngx_resolver_ctx_t *ctx);\nstatic void ngx_tcp_upstream_finalize_session(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_t *u, ngx_int_t rc);\n\nstatic char *ngx_tcp_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy);\nstatic char *ngx_tcp_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_tcp_upstream_check(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\n\nstatic void *ngx_tcp_upstream_create_main_conf(ngx_conf_t *cf);\nstatic char *ngx_tcp_upstream_init_main_conf(ngx_conf_t *cf, void *conf);\n\n\nstatic ngx_conf_bitmask_t  ngx_check_http_expect_alive_masks[] = {\n    { ngx_string(\"http_2xx\"), NGX_CHECK_HTTP_2XX },\n    { ngx_string(\"http_3xx\"), NGX_CHECK_HTTP_3XX },\n    { ngx_string(\"http_4xx\"), NGX_CHECK_HTTP_4XX },\n    { ngx_string(\"http_5xx\"), NGX_CHECK_HTTP_5XX },\n    { ngx_null_string, 0 }\n};\n\nstatic ngx_conf_bitmask_t  ngx_check_smtp_expect_alive_masks[] = {\n    { ngx_string(\"smtp_2xx\"), NGX_CHECK_SMTP_2XX },\n    { ngx_string(\"smtp_3xx\"), NGX_CHECK_SMTP_3XX },\n    { ngx_string(\"smtp_4xx\"), NGX_CHECK_SMTP_4XX },\n    { ngx_string(\"smtp_5xx\"), NGX_CHECK_SMTP_5XX },\n    { ngx_null_string, 0 }\n};\n\nstatic ngx_command_t  ngx_tcp_upstream_commands[] = {\n\n    { ngx_string(\"upstream\"),\n      NGX_TCP_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_TAKE1,\n      ngx_tcp_upstream,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"server\"),\n      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,\n      ngx_tcp_upstream_server,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"check\"),\n      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,\n      ngx_tcp_upstream_check,\n      NGX_TCP_SRV_CONF_OFFSET,\n      0,\n      NULL },\n\n    { ngx_string(\"check_http_send\"),\n      NGX_TCP_UPS_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_upstream_srv_conf_t, send),\n      NULL },\n\n    { ngx_string(\"check_smtp_send\"),\n      NGX_TCP_UPS_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_upstream_srv_conf_t, send),\n      NULL },\n\n    { ngx_string(\"check_http_expect_alive\"),\n      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,\n      ngx_conf_set_bitmask_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_upstream_srv_conf_t, code.status_alive),\n      &ngx_check_http_expect_alive_masks },\n\n    { ngx_string(\"check_smtp_expect_alive\"),\n      NGX_TCP_UPS_CONF|NGX_CONF_1MORE,\n      ngx_conf_set_bitmask_slot,\n      NGX_TCP_SRV_CONF_OFFSET,\n      offsetof(ngx_tcp_upstream_srv_conf_t, code.status_alive),\n      &ngx_check_smtp_expect_alive_masks },\n\n    { ngx_string(\"check_shm_size\"),\n      NGX_TCP_MAIN_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_size_slot,\n      NGX_TCP_MAIN_CONF_OFFSET,\n      offsetof(ngx_tcp_upstream_main_conf_t, check_shm_size),\n      NULL },\n\n    ngx_null_command\n};\n\n\nstatic ngx_tcp_module_t  ngx_tcp_upstream_module_ctx = {\n    NULL,\n\n    ngx_tcp_upstream_create_main_conf,     /* create main configuration */\n    ngx_tcp_upstream_init_main_conf,       /* init main configuration */\n\n    NULL,                                  /* create server configuration */\n    NULL,                                  /* merge server configuration */\n};\n\n\nngx_module_t  ngx_tcp_upstream_module = {\n    NGX_MODULE_V1,\n    &ngx_tcp_upstream_module_ctx,          /* module context */\n    ngx_tcp_upstream_commands,             /* module directives */\n    NGX_TCP_MODULE,                        /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nngx_int_t\nngx_tcp_upstream_create(ngx_tcp_session_t *s) \n{\n    ngx_tcp_upstream_t  *u;\n\n    u = s->upstream;\n\n    if (u && u->cleanup) {\n        ngx_tcp_upstream_cleanup(s);\n    }\n\n    u = ngx_pcalloc(s->pool, sizeof(ngx_tcp_upstream_t));\n    if (u == NULL) {\n        return NGX_ERROR;\n    }\n\n    s->upstream = u;\n\n    u->peer.log = s->connection->log;\n    u->peer.log_error = NGX_ERROR_ERR;\n\n    return NGX_OK;\n}\n\n\nvoid\nngx_tcp_upstream_init(ngx_tcp_session_t *s)\n{\n    ngx_str_t                      *host;\n    ngx_uint_t                      i;\n    ngx_connection_t               *c;\n    ngx_tcp_cleanup_t              *cln;\n    ngx_resolver_ctx_t             *ctx, temp;\n    ngx_tcp_upstream_t             *u;\n    ngx_tcp_core_srv_conf_t        *cscf;\n    ngx_tcp_upstream_srv_conf_t    *uscf, **uscfp;\n    ngx_tcp_upstream_main_conf_t   *umcf;\n\n    c = s->connection;\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,\n                   \"tcp init upstream, client timer: %d\", c->read->timer_set);\n\n    if (c->read->timer_set) {\n        ngx_del_timer(c->read);\n    }\n\n    u = s->upstream;\n\n    cln = ngx_tcp_cleanup_add(s, 0);\n\n    cln->handler = ngx_tcp_upstream_cleanup;\n    cln->data = s;\n    u->cleanup = &cln->handler;\n\n    if (u->resolved == NULL) {\n\n        uscf = u->conf->upstream;\n\n    } else {\n\n        /*TODO: support variable in the proxy_pass*/\n        if (u->resolved->sockaddr) {\n\n            if (ngx_tcp_upstream_create_round_robin_peer(s, u->resolved)\n                != NGX_OK)\n            {\n                ngx_tcp_finalize_session(s);\n                return;\n            }\n\n            ngx_tcp_upstream_connect(s, u);\n\n            return;\n        }\n\n        host = &u->resolved->host;\n\n        umcf = ngx_tcp_get_module_main_conf(s, ngx_tcp_upstream_module);\n\n        uscfp = umcf->upstreams.elts;\n\n        for (i = 0; i < umcf->upstreams.nelts; i++) {\n\n            uscf = uscfp[i];\n\n            if (uscf->host.len == host->len\n                && ((uscf->port == 0 && u->resolved->no_port)\n                    || uscf->port == u->resolved->port)\n                && ngx_memcmp(uscf->host.data, host->data, host->len) == 0)\n            {\n                goto found;\n            }\n        }\n\n        temp.name = *host;\n\n        ctx = ngx_resolve_start(cscf->resolver, &temp);\n        if (ctx == NULL) {\n            ngx_tcp_finalize_session(s);\n            return;\n        }\n\n        if (ctx == NGX_NO_RESOLVER) {\n            ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                         \"no resolver defined to resolve %V\", host);\n            ngx_tcp_finalize_session(s);\n            return;\n        }\n\n        ctx->name = *host;\n#if (nginx_version) < 1005008\n        ctx->type = NGX_RESOLVE_A;\n#endif\n        ctx->handler = ngx_tcp_upstream_resolve_handler;\n        ctx->data = s;\n        ctx->timeout = cscf->resolver_timeout;\n\n        u->resolved->ctx = ctx;\n\n        if (ngx_resolve_name(ctx) != NGX_OK) {\n            u->resolved->ctx = NULL;\n            ngx_tcp_finalize_session(s);\n            return;\n        }\n\n        return;\n    }\n\nfound:\n\n    if (uscf->peer.init(s, uscf) != NGX_OK) {\n        ngx_tcp_finalize_session(s);\n        return;\n    }\n\n    ngx_tcp_upstream_connect(s, u);\n}\n\n\nstatic void\nngx_tcp_upstream_resolve_handler(ngx_resolver_ctx_t *ctx) \n{\n    ngx_tcp_session_t            *s;\n    ngx_tcp_upstream_resolved_t  *ur;\n\n    s = ctx->data;\n\n    s->upstream->resolved->ctx = NULL;\n\n    if (ctx->state) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0,\n                      \"%V could not be resolved (%i: %s)\",\n                      &ctx->name, ctx->state,\n                      ngx_resolver_strerror(ctx->state));\n\n        ngx_resolve_name_done(ctx);\n        ngx_tcp_finalize_session(s);\n        return;\n    }\n\n    ur = s->upstream->resolved;\n    ur->naddrs = ctx->naddrs;\n    ur->addrs = ctx->addrs;\n\n#if (NGX_DEBUG)\n    {\n#if (nginx_version) >= 1005008\n        u_char      text[NGX_SOCKADDR_STRLEN];\n        ngx_str_t   addr;\n#else\n        in_addr_t   addr;\n#endif\n        ngx_uint_t  i;\n\n#if (nginx_version) >= 1005008\n        addr.data = text;\n#endif\n\n        for (i = 0; i < ctx->naddrs; i++) {\n#if (nginx_version) >= 1005008\n            addr.len = ngx_sock_ntop(ur->addrs[i].sockaddr, ur->addrs[i].socklen,\n                                     text, NGX_SOCKADDR_STRLEN, 0);\n\n            ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                           \"name was resolved to %V\", &addr);\n#else\n            addr = ntohl(ur->addrs[i]);\n\n            ngx_log_debug4(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                           \"name was resolved to %ud.%ud.%ud.%ud\",\n                           (addr >> 24) & 0xff, (addr >> 16) & 0xff,\n                           (addr >> 8) & 0xff, addr & 0xff);\n#endif\n        }\n    }\n#endif\n\n    if (ngx_tcp_upstream_create_round_robin_peer(s, ur) != NGX_OK) {\n        ngx_resolve_name_done(ctx);\n        ngx_tcp_finalize_session(s);\n        return;\n    }\n\n    ngx_resolve_name_done(ctx);\n\n    ngx_tcp_upstream_connect(s, s->upstream);\n}\n\n\nstatic void\nngx_tcp_upstream_connect(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u) \n{\n    int                       tcp_nodelay;\n    ngx_int_t                 rc;\n    ngx_connection_t         *c;\n    ngx_tcp_core_srv_conf_t  *cscf;\n\n    s->connection->log->action = \"connecting to upstream\";\n\n    cscf = ngx_tcp_get_module_srv_conf(s, ngx_tcp_core_module);\n\n    rc = ngx_event_connect_peer(&u->peer);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                   \"tcp upstream connect: %d\", rc);\n\n    if (rc != NGX_OK && rc != NGX_AGAIN) {\n\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, 0, \n                      \"upstream servers are busy or encounter error!\");\n\n        /* TODO: check this function */\n        ngx_tcp_upstream_finalize_session(s, u, 0);\n\n        return;\n    }\n\n    /* rc == NGX_OK or rc == NGX_AGAIN */\n\n    if (u->peer.check_index != NGX_INVALID_CHECK_INDEX) {\n        ngx_tcp_check_get_peer(u->peer.check_index);\n    }\n\n    c = u->peer.connection;\n\n    c->data = s;\n    c->pool = s->connection->pool;\n    c->log = s->connection->log;\n    c->read->log = c->log;\n    c->write->log = c->log;\n\n    c->write->handler = ngx_tcp_upstream_handler;\n    c->read->handler = ngx_tcp_upstream_handler;\n\n    if (cscf->tcp_nodelay) {\n        tcp_nodelay = 1;\n\n        if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY,\n                       (const void *) &tcp_nodelay, sizeof(int)) == -1)\n        {\n            ngx_connection_error(c, ngx_socket_errno,\n                                 \"setsockopt(TCP_NODELAY) failed\");\n            ngx_tcp_upstream_finalize_session(s, u, 0);\n            return;\n        }\n\n        c->tcp_nodelay = NGX_TCP_NODELAY_SET;\n    }\n\n    if (rc == NGX_AGAIN) {\n        ngx_add_timer(c->write, u->conf->connect_timeout);\n        return;\n    }\n    else {\n        ngx_add_timer(c->read, u->conf->read_timeout);\n        ngx_add_timer(c->write, u->conf->send_timeout);\n\n        c->write->handler(c->write);\n    }\n}\n\n\nstatic void\nngx_tcp_upstream_handler(ngx_event_t *ev) \n{\n    ngx_connection_t     *c;\n    ngx_tcp_session_t    *s;\n    ngx_tcp_upstream_t   *u;\n\n    c = ev->data;\n    s = c->data;\n\n    u = s->upstream;\n    c = s->connection;\n\n    if (ev->write) {\n        if (u->write_event_handler) {\n            u->write_event_handler(s, u);\n        }\n\n    } else {\n\n        if (u->read_event_handler) {\n            u->read_event_handler(s, u);\n        }\n    }\n}\n\n\nngx_int_t \nngx_tcp_upstream_check_broken_connection(ngx_tcp_session_t *s) \n{\n    int                  n;\n    char                 buf[1];\n    ngx_err_t            err;\n    ngx_connection_t    *c;\n    ngx_tcp_upstream_t  *u;\n\n    u = s->upstream;\n    c = u->peer.connection;\n\n    if (u->peer.connection == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, 0,\n                   \"tcp upstream check upstream, fd: %d\", c->fd);\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n\n    err = ngx_socket_errno;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, c->log, err,\n                   \"tcp check upstream recv(): %d\", n);\n\n    if (n >= 0 || err == NGX_EAGAIN) {\n        return NGX_OK;\n    }\n\n    c->error = 1;\n\n    return NGX_ERROR;\n}\n\n\nvoid\nngx_tcp_upstream_next(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u,\n    ngx_uint_t ft_type) \n{\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                   \"tcp next upstream, fail_type: %xi\", ft_type);\n\n    if (ft_type != NGX_TCP_UPSTREAM_FT_NOLIVE) {\n        u->peer.free(&u->peer, u->peer.data, NGX_PEER_FAILED);\n    }\n\n    if (ft_type == NGX_TCP_UPSTREAM_FT_TIMEOUT) {\n        ngx_log_error(NGX_LOG_ERR, s->connection->log, NGX_ETIMEDOUT,\n                      \"upstream timed out\");\n    }\n\n    if (s->connection->error) {\n        ngx_tcp_upstream_finalize_session(s, u, 0);\n        return;\n    }\n\n    if (u->peer.tries == 0) {\n        ngx_tcp_upstream_finalize_session(s, u, 0);\n        return;\n    }\n\n    if (u->peer.connection) {\n        ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                       \"close tcp upstream connection: %d\",\n                       u->peer.connection->fd);\n#if (NGX_TCP_SSL)\n\n        if (u->peer.connection->ssl) {\n            u->peer.connection->ssl->no_wait_shutdown = 1;\n            u->peer.connection->ssl->no_send_shutdown = 1;\n\n            (void) ngx_ssl_shutdown(u->peer.connection);\n        }\n#endif\n        \n        if (u->peer.check_index != NGX_INVALID_CHECK_INDEX) {\n            ngx_tcp_check_free_peer(u->peer.check_index);\n            u->peer.check_index = NGX_INVALID_CHECK_INDEX;\n        }\n\n        ngx_close_connection(u->peer.connection);\n    }\n\n    ngx_tcp_upstream_connect(s, u);\n}\n\n\nstatic void\nngx_tcp_upstream_cleanup(void *data) \n{\n    ngx_tcp_session_t *s = data;\n\n    ngx_tcp_upstream_t  *u;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                   \"cleanup tcp upstream session: fd: %d\", s->connection->fd);\n\n    u = s->upstream;\n\n    if (u->resolved && u->resolved->ctx) {\n        ngx_resolve_name_done(u->resolved->ctx);\n    }\n\n    ngx_tcp_upstream_finalize_session(s, u, NGX_DONE);\n}\n\n\nstatic void\nngx_tcp_upstream_finalize_session(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_t *u, ngx_int_t rc) \n{\n    ngx_time_t  *tp;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                   \"finalize tcp upstream session: %i\", rc);\n\n    if (u->cleanup) {\n        *u->cleanup = NULL;\n        u->cleanup = NULL;\n    }\n\n    if (u->state && u->state->response_sec) {\n        tp = ngx_timeofday();\n        u->state->response_sec = tp->sec - u->state->response_sec;\n        u->state->response_msec = tp->msec - u->state->response_msec;\n    }\n\n    if (u->peer.free) {\n        u->peer.free(&u->peer, u->peer.data, 0);\n    }\n\n    if (u->peer.check_index != NGX_INVALID_CHECK_INDEX) {\n        ngx_tcp_check_free_peer(u->peer.check_index);\n        u->peer.check_index = NGX_INVALID_CHECK_INDEX;\n    }\n\n    if (u->peer.connection) {\n\n        ngx_log_debug1(NGX_LOG_DEBUG_TCP, s->connection->log, 0,\n                       \"close tcp upstream connection: %d\",\n                       u->peer.connection->fd);\n\n        ngx_close_connection(u->peer.connection);\n    }\n\n    u->peer.connection = NULL;\n\n    if (rc == NGX_DECLINED || rc == NGX_DONE) {\n        return;\n    }\n\n    s->connection->log->action = \"sending to client\";\n\n    ngx_tcp_finalize_session(s);\n}\n\n\nngx_tcp_upstream_srv_conf_t *\nngx_tcp_upstream_add(ngx_conf_t *cf, ngx_url_t *u, ngx_uint_t flags) \n{\n    ngx_uint_t                     i;\n    ngx_tcp_upstream_server_t     *us;\n    ngx_tcp_upstream_srv_conf_t   *uscf, **uscfp;\n    ngx_tcp_upstream_main_conf_t  *umcf;\n\n    if (!(flags & NGX_TCP_UPSTREAM_CREATE)) {\n\n        if (ngx_parse_url(cf->pool, u) != NGX_OK) {\n            if (u->err) {\n                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                                   \"%s in upstream \\\"%V\\\"\", u->err, &u->url);\n            }\n\n            return NULL;\n        }\n    }\n\n    umcf = ngx_tcp_conf_get_module_main_conf(cf, ngx_tcp_upstream_module);\n\n    uscfp = umcf->upstreams.elts;\n\n    for (i = 0; i < umcf->upstreams.nelts; i++) {\n\n        if (uscfp[i]->host.len != u->host.len || \n                ngx_strncasecmp(uscfp[i]->host.data,\n                                u->host.data, u->host.len) != 0)\n        {\n            continue;\n        }\n\n        if ((flags & NGX_TCP_UPSTREAM_CREATE)\n             && (uscfp[i]->flags & NGX_TCP_UPSTREAM_CREATE))\n        {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"duplicate upstream \\\"%V\\\"\", &u->host);\n            return NULL;\n        }\n\n#if (nginx_version) >= 1003011\n        if ((uscfp[i]->flags & NGX_TCP_UPSTREAM_CREATE) && !u->no_port) {\n#else\n        if ((uscfp[i]->flags & NGX_TCP_UPSTREAM_CREATE) && u->port) {\n#endif\n            ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                               \"upstream \\\"%V\\\" may not have port %d\",\n                               &u->host, u->port);\n            return NULL;\n        }\n\n#if (nginx_version) >= 1003011\n        if ((flags & NGX_TCP_UPSTREAM_CREATE) && !uscfp[i]->no_port) {\n#else\n        if ((flags & NGX_TCP_UPSTREAM_CREATE) && uscfp[i]->port) {\n#endif\n            ngx_log_error(NGX_LOG_WARN, cf->log, 0,\n                          \"upstream \\\"%V\\\" may not have port %d in %s:%ui\",\n                          &u->host, uscfp[i]->port,\n                          uscfp[i]->file_name, uscfp[i]->line);\n            return NULL;\n        }\n\n#if (nginx_version) >= 1003011\n        if (uscfp[i]->port && u->port && uscfp[i]->port != u->port) {\n#else\n        if (uscfp[i]->port != u->port) {\n#endif\n            continue;\n        }\n\n        if (uscfp[i]->default_port && u->default_port\n            && uscfp[i]->default_port != u->default_port)\n        {\n            continue;\n        }\n\n        return uscfp[i];\n    }\n\n    uscf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_srv_conf_t));\n    if (uscf == NULL) {\n        return NULL;\n    }\n\n    uscf->flags = flags;\n    uscf->host = u->host;\n    uscf->file_name = cf->conf_file->file.name.data;\n    uscf->line = cf->conf_file->line;\n    uscf->port = u->port;\n    uscf->default_port = u->default_port;\n#if (nginx_version) >= 1003011\n    uscf->no_port = u->no_port;\n#endif\n    uscf->code.status_alive = 0;\n\n    if (u->naddrs == 1) {\n        uscf->servers = ngx_array_create(cf->pool, 1,\n                                         sizeof(ngx_tcp_upstream_server_t));\n        if (uscf->servers == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        us = ngx_array_push(uscf->servers);\n        if (us == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_memzero(us, sizeof(ngx_tcp_upstream_server_t));\n\n        us->addrs = u->addrs;\n        us->naddrs = u->naddrs;\n    }\n\n    uscfp = ngx_array_push(&umcf->upstreams);\n    if (uscfp == NULL) {\n        return NULL;\n    }\n\n    *uscfp = uscf;\n\n    return uscf;\n}\n\n\nstatic char *\nngx_tcp_upstream(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy) \n{\n    char                          *rv;\n    void                          *mconf;\n    ngx_str_t                     *value;\n    ngx_url_t                      u;\n    ngx_uint_t                     m;\n    ngx_conf_t                     pcf;\n    ngx_tcp_module_t              *module;\n    ngx_tcp_conf_ctx_t            *ctx, *tcp_ctx;\n    ngx_tcp_upstream_srv_conf_t   *uscf;\n\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    value = cf->args->elts;\n    u.host = value[1];\n    u.no_resolve = 1;\n    u.no_port = 1;\n\n    uscf = ngx_tcp_upstream_add(cf, &u, \n                                NGX_TCP_UPSTREAM_CREATE\n                               |NGX_TCP_UPSTREAM_WEIGHT\n                               |NGX_TCP_UPSTREAM_MAX_FAILS\n                               |NGX_TCP_UPSTREAM_FAIL_TIMEOUT\n                               |NGX_TCP_UPSTREAM_MAX_BUSY\n                               |NGX_TCP_UPSTREAM_DOWN\n                               |NGX_TCP_UPSTREAM_BACKUP);\n    if (uscf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    tcp_ctx = cf->ctx;\n    ctx->main_conf = tcp_ctx->main_conf;\n\n    /* the upstream{}'s srv_conf */\n\n    ctx->srv_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_tcp_max_module);\n    if (ctx->srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx->srv_conf[ngx_tcp_upstream_module.ctx_index] = uscf;\n\n    uscf->srv_conf = ctx->srv_conf;\n\n\n    for (m = 0; ngx_modules[m]; m++) {\n        if (ngx_modules[m]->type != NGX_TCP_MODULE) {\n            continue;\n        }\n\n        module = ngx_modules[m]->ctx;\n\n        if (module->create_srv_conf) {\n            mconf = module->create_srv_conf(cf);\n            if (mconf == NULL) {\n                return NGX_CONF_ERROR;\n            }\n\n            ctx->srv_conf[ngx_modules[m]->ctx_index] = mconf;\n        }\n\n    }\n\n    /* parse inside upstream{} */\n\n    pcf = *cf;\n    cf->ctx = ctx;\n    cf->cmd_type = NGX_TCP_UPS_CONF;\n\n    rv = ngx_conf_parse(cf, NULL);\n\n    *cf = pcf;\n\n    if (rv != NGX_CONF_OK) {\n        return rv;\n    }\n\n    if (uscf->servers == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"no servers are inside upstream\");\n        return NGX_CONF_ERROR;\n    }\n\n    return rv;\n}\n\n\nstatic char *\nngx_tcp_upstream_server(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) \n{\n    ngx_tcp_upstream_srv_conf_t  *uscf = conf;\n\n    time_t                       fail_timeout;\n    ngx_str_t                   *value, s;\n    ngx_url_t                    u;\n    ngx_int_t                    weight, max_fails, max_busy;\n    ngx_uint_t                   i;\n    ngx_tcp_upstream_server_t   *us;\n\n    if (uscf->servers == NULL) {\n        uscf->servers = ngx_array_create(cf->pool, 4,\n                                         sizeof(ngx_tcp_upstream_server_t));\n        if (uscf->servers == NULL) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    us = ngx_array_push(uscf->servers);\n    if (us == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memzero(us, sizeof(ngx_tcp_upstream_server_t));\n\n    value = cf->args->elts;\n\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    u.url = value[1];\n    u.default_port = 80;\n\n    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {\n        if (u.err) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"%s in upstream \\\"%V\\\"\", u.err, &u.url);\n        }\n\n        return NGX_CONF_ERROR;\n    }\n\n    weight = 1;\n    max_fails = 1;\n    max_busy = (ngx_uint_t)-1;\n    fail_timeout = 10;\n\n    for (i = 2; i < cf->args->nelts; i++) {\n\n        if (ngx_strncmp(value[i].data, \"weight=\", 7) == 0) {\n\n            if (!(uscf->flags & NGX_TCP_UPSTREAM_WEIGHT)) {\n                goto invalid;\n            }\n\n            weight = ngx_atoi(&value[i].data[7], value[i].len - 7);\n\n            if (weight == NGX_ERROR || weight == 0) {\n                goto invalid;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"max_fails=\", 10) == 0) {\n\n            if (!(uscf->flags & NGX_TCP_UPSTREAM_MAX_FAILS)) {\n                goto invalid;\n            }\n\n            max_fails = ngx_atoi(&value[i].data[10], value[i].len - 10);\n\n            if (max_fails == NGX_ERROR) {\n                goto invalid;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"max_busy=\", 9) == 0) {\n\n            if (!(uscf->flags & NGX_TCP_UPSTREAM_MAX_BUSY)) {\n                goto invalid;\n            }\n\n            max_busy = ngx_atoi(&value[i].data[9], value[i].len - 9);\n\n            if (max_busy == NGX_ERROR) {\n                goto invalid;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"fail_timeout=\", 13) == 0) {\n\n            if (!(uscf->flags & NGX_TCP_UPSTREAM_FAIL_TIMEOUT)) {\n                goto invalid;\n            }\n\n            s.len = value[i].len - 13;\n            s.data = &value[i].data[13];\n\n            fail_timeout = ngx_parse_time(&s, 1);\n\n            if (fail_timeout == NGX_ERROR) {\n                goto invalid;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"backup\", 6) == 0) {\n\n            if (!(uscf->flags & NGX_TCP_UPSTREAM_BACKUP)) {\n                goto invalid;\n            }\n\n            us->backup = 1;\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"down\", 4) == 0) {\n\n            if (!(uscf->flags & NGX_TCP_UPSTREAM_DOWN)) {\n                goto invalid;\n            }\n\n            us->down = 1;\n\n            continue;\n        }\n\n        goto invalid;\n    }\n\n    us->addrs = u.addrs;\n    us->naddrs = u.naddrs;\n    us->weight = weight;\n    us->max_fails = max_fails;\n    us->max_busy = max_busy;\n    us->fail_timeout = fail_timeout;\n\n    return NGX_CONF_OK;\n\ninvalid:\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"invalid parameter \\\"%V\\\"\", &value[i]);\n\n    return NGX_CONF_ERROR;\n}\n\n\nstatic char *\nngx_tcp_upstream_check(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) \n{\n    ngx_tcp_upstream_srv_conf_t  *uscf = conf;\n\n    ngx_str_t   *value, s;\n    ngx_uint_t   i, rise, fall;\n    ngx_msec_t   interval, timeout;\n\n    /*set default*/\n    rise = 2;\n    fall = 5;\n    interval = 30000;\n    timeout = 1000;\n\n    value = cf->args->elts;\n\n    for (i = 1; i < cf->args->nelts; i++) {\n\n        if (ngx_strncmp(value[i].data, \"type=\", 5) == 0) {\n            s.len = value[i].len - 5;\n            s.data = value[i].data + 5;\n\n            uscf->check_type_conf = ngx_tcp_get_check_type_conf(&s);\n\n            if ( uscf->check_type_conf == NULL) {\n                goto invalid_check_parameter;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"interval=\", 9) == 0) {\n            s.len = value[i].len - 9;\n            s.data = value[i].data + 9;\n\n            interval = ngx_atoi(s.data, s.len);\n            if (interval == (ngx_msec_t) NGX_ERROR) {\n                goto invalid_check_parameter;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"timeout=\", 8) == 0) {\n            s.len = value[i].len - 8;\n            s.data = value[i].data + 8;\n\n            timeout = ngx_atoi(s.data, s.len);\n            if (timeout == (ngx_msec_t) NGX_ERROR) {\n                goto invalid_check_parameter;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"rise=\", 5) == 0) {\n            s.len = value[i].len - 5;\n            s.data = value[i].data + 5;\n\n            rise = ngx_atoi(s.data, s.len);\n            if (rise == (ngx_uint_t) NGX_ERROR) {\n                goto invalid_check_parameter;\n            }\n\n            continue;\n        }\n\n        if (ngx_strncmp(value[i].data, \"fall=\", 5) == 0) {\n            s.len = value[i].len - 5;\n            s.data = value[i].data + 5;\n\n            fall = ngx_atoi(s.data, s.len);\n            if (fall == (ngx_uint_t) NGX_ERROR) {\n                goto invalid_check_parameter;\n            }\n\n            continue;\n        }\n\n        goto invalid_check_parameter;\n    }\n\n    uscf->check_interval = interval;\n    uscf->check_timeout = timeout;\n    uscf->fall_count = fall;\n    uscf->rise_count = rise;\n\n    if (uscf->check_type_conf == NULL) {\n        s.len = sizeof(\"tcp\") - 1;\n        s.data =(u_char *) \"tcp\";\n\n        uscf->check_type_conf = ngx_tcp_get_check_type_conf(&s);\n    }\n\n    return NGX_CONF_OK;\n\ninvalid_check_parameter:\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"invalid parameter \\\"%V\\\"\", &value[i]);\n\n    return NGX_CONF_ERROR;\n}\n\n\nstatic void *\nngx_tcp_upstream_create_main_conf(ngx_conf_t *cf) \n{\n    ngx_tcp_upstream_main_conf_t  *umcf;\n\n    umcf = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_main_conf_t));\n    if (umcf == NULL) {\n        return NULL;\n    }\n\n    umcf->peers_conf = ngx_pcalloc(cf->pool,\n                                   sizeof(ngx_tcp_check_peers_conf_t));\n    if (umcf->peers_conf == NULL) {\n        return NULL;\n    }\n\n    if (ngx_array_init(&umcf->upstreams, cf->pool, 4,\n                       sizeof(ngx_tcp_upstream_srv_conf_t *)) != NGX_OK)\n    {\n        return NULL;\n    }\n\n    if (ngx_array_init(&umcf->peers_conf->peers, cf->pool, 16,\n                       sizeof(ngx_tcp_check_peer_conf_t)) != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return umcf;\n}\n\n\nstatic char *\nngx_tcp_upstream_init_main_conf(ngx_conf_t *cf, void *conf) \n{\n    ngx_tcp_upstream_main_conf_t   *umcf = conf;\n\n    ngx_uint_t                      i;\n    ngx_tcp_upstream_init_pt        init;\n    ngx_tcp_upstream_srv_conf_t   **uscfp;\n\n    uscfp = umcf->upstreams.elts;\n\n    if (ngx_tcp_upstream_init_main_check_conf(cf, conf) != NGX_OK) {\n            return NGX_CONF_ERROR;\n    }\n\n    for (i = 0; i < umcf->upstreams.nelts; i++) {\n\n        init = uscfp[i]->peer.init_upstream ? uscfp[i]->peer.init_upstream:\n                                              ngx_tcp_upstream_init_round_robin;\n\n        if (init(cf, uscfp[i]) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n"
        },
        {
          "name": "ngx_tcp_upstream.h",
          "type": "blob",
          "size": 6.3076171875,
          "content": "\n#ifndef _NGX_TCP_UPSTREAM_H_INCLUDED_\n#define _NGX_TCP_UPSTREAM_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_event_connect.h>\n#include <ngx_event_pipe.h>\n#include <ngx_tcp.h>\n\n\n#define NGX_TCP_UPSTREAM_FT_ERROR           0x00000002\n#define NGX_TCP_UPSTREAM_FT_TIMEOUT         0x00000004\n#define NGX_TCP_UPSTREAM_FT_INVALID_HEADER  0x00000008\n#define NGX_TCP_UPSTREAM_FT_TCP_500         0x00000010\n#define NGX_TCP_UPSTREAM_FT_TCP_502         0x00000020\n#define NGX_TCP_UPSTREAM_FT_TCP_503         0x00000040\n#define NGX_TCP_UPSTREAM_FT_TCP_504         0x00000080\n#define NGX_TCP_UPSTREAM_FT_TCP_404         0x00000100\n#define NGX_TCP_UPSTREAM_FT_UPDATING        0x00000200\n#define NGX_TCP_UPSTREAM_FT_BUSY_LOCK       0x00000400\n#define NGX_TCP_UPSTREAM_FT_MAX_WAITING     0x00000800\n#define NGX_TCP_UPSTREAM_FT_NOLIVE          0x40000000\n#define NGX_TCP_UPSTREAM_FT_OFF             0x80000000\n\n#define NGX_TCP_UPSTREAM_FT_STATUS          (NGX_TCP_UPSTREAM_FT_TCP_500  \\\n                                             |NGX_TCP_UPSTREAM_FT_TCP_502  \\\n                                             |NGX_TCP_UPSTREAM_FT_TCP_503  \\\n                                             |NGX_TCP_UPSTREAM_FT_TCP_504  \\\n                                             |NGX_TCP_UPSTREAM_FT_TCP_404)\n\n#define NGX_TCP_UPSTREAM_INVALID_HEADER     40\n\n\n#define NGX_TCP_UPSTREAM_IGN_XA_REDIRECT    0x00000002\n#define NGX_TCP_UPSTREAM_IGN_XA_EXPIRES     0x00000004\n#define NGX_TCP_UPSTREAM_IGN_EXPIRES        0x00000008\n#define NGX_TCP_UPSTREAM_IGN_CACHE_CONTROL  0x00000010\n\ntypedef struct {\n    ngx_msec_t                       bl_time;\n    ngx_uint_t                       bl_state;\n\n    ngx_uint_t                       status;\n    time_t                           response_sec;\n    ngx_uint_t                       response_msec;\n\n    ngx_str_t                       *peer;\n} ngx_tcp_upstream_state_t;\n\n\ntypedef struct {\n    ngx_uint_t                       check_shm_size;\n    ngx_tcp_check_peers_conf_t      *peers_conf;\n    ngx_array_t                      upstreams; /* ngx_tcp_upstream_srv_conf_t */\n} ngx_tcp_upstream_main_conf_t;\n\n\ntypedef ngx_int_t (*ngx_tcp_upstream_init_pt)(ngx_conf_t *cf,\n        ngx_tcp_upstream_srv_conf_t *us);\ntypedef ngx_int_t (*ngx_tcp_upstream_init_peer_pt)(ngx_tcp_session_t *s,\n        ngx_tcp_upstream_srv_conf_t *us);\n\ntypedef struct {\n    ngx_tcp_upstream_init_pt         init_upstream;\n    ngx_tcp_upstream_init_peer_pt    init;\n    void                            *data;\n} ngx_tcp_upstream_peer_t;\n\ntypedef struct {\n    ngx_peer_addr_t                 *addrs;\n    ngx_uint_t                       naddrs;\n    ngx_uint_t                       weight;\n    ngx_uint_t                       max_fails;\n    time_t                           fail_timeout;\n    ngx_uint_t                       max_busy;\n\n    unsigned                         down:1;\n    unsigned                         backup:1;\n} ngx_tcp_upstream_server_t;\n\n\n#define NGX_TCP_UPSTREAM_CREATE        0x0001\n#define NGX_TCP_UPSTREAM_WEIGHT        0x0002\n#define NGX_TCP_UPSTREAM_MAX_FAILS     0x0004\n#define NGX_TCP_UPSTREAM_FAIL_TIMEOUT  0x0008\n#define NGX_TCP_UPSTREAM_DOWN          0x0010\n#define NGX_TCP_UPSTREAM_BACKUP        0x0020\n#define NGX_TCP_UPSTREAM_SRUN_ID       0x0040\n#define NGX_TCP_UPSTREAM_MAX_BUSY      0x0080\n\nstruct ngx_tcp_upstream_srv_conf_s {\n\n    ngx_tcp_upstream_peer_t          peer;\n    void                           **srv_conf;\n\n    ngx_array_t                     *servers;  /* ngx_tcp_upstream_server_t */\n\n    ngx_uint_t                       flags;\n    ngx_str_t                        host;\n    u_char                          *file_name;\n    ngx_uint_t                       line;\n    in_port_t                        port;\n    in_port_t                        default_port;\n#if (nginx_version) >= 1003011\n    ngx_uint_t                       no_port;  /* unsigned no_port:1 */\n#endif\n\n    ngx_uint_t                       fall_count;\n    ngx_uint_t                       rise_count;\n    ngx_msec_t                       check_interval;\n    ngx_msec_t                       check_timeout;\n\n    check_conf_t                    *check_type_conf;\n    ngx_str_t                        send;\n\n    union {\n        ngx_uint_t                   return_code;\n        ngx_uint_t                   status_alive;\n    } code;\n};\n\n\ntypedef struct {\n    ngx_tcp_upstream_srv_conf_t     *upstream;\n\n    ngx_msec_t                       connect_timeout;\n    ngx_msec_t                       send_timeout;\n    ngx_msec_t                       read_timeout;\n    ngx_msec_t                       timeout;\n} ngx_tcp_upstream_conf_t;\n\n\nstruct ngx_tcp_upstream_resolved_s {\n    ngx_str_t                        host;\n    in_port_t                        port;\n    ngx_uint_t                       no_port; /* unsigned no_port:1 */\n\n    ngx_uint_t                       naddrs;\n#if (nginx_version) >= 1005008\n    #if (nginx_version) >= 1009001\n        ngx_resolver_addr_t *addrs;\n    #else\n        ngx_addr_t *addrs;\n    #endif\n    #else\n        in_addr_t *addrs;\n#endif\n\n    struct sockaddr                 *sockaddr;\n    socklen_t                        socklen;\n\n    ngx_resolver_ctx_t              *ctx;\n};\n\n\ntypedef void (*ngx_tcp_upstream_handler_pt)(ngx_tcp_session_t *s,\n        ngx_tcp_upstream_t *u);\n\nstruct ngx_tcp_upstream_s {\n    ngx_tcp_upstream_handler_pt      read_event_handler;\n    ngx_tcp_upstream_handler_pt      write_event_handler;\n\n    ngx_peer_connection_t            peer;\n    ngx_tcp_upstream_conf_t         *conf;\n    ngx_tcp_upstream_resolved_t     *resolved;\n    ngx_tcp_upstream_state_t        *state;\n    ngx_tcp_cleanup_pt              *cleanup;\n};\n\n\ntypedef struct {\n    ngx_uint_t                       status;\n    ngx_uint_t                       mask;\n} ngx_tcp_upstream_next_t;\n\n\nngx_int_t ngx_tcp_upstream_create(ngx_tcp_session_t *s);\nvoid ngx_tcp_upstream_init(ngx_tcp_session_t *s);\nngx_tcp_upstream_srv_conf_t *ngx_tcp_upstream_add(ngx_conf_t *cf,\n    ngx_url_t *u, ngx_uint_t flags);\n\nngx_int_t ngx_tcp_upstream_check_broken_connection(ngx_tcp_session_t *s);\nvoid ngx_tcp_upstream_next(ngx_tcp_session_t *s, ngx_tcp_upstream_t *u,\n     ngx_uint_t ft_type);\n\n#define ngx_tcp_conf_upstream_srv_conf(uscf, module)                         \\\n    uscf->srv_conf[module.ctx_index]\n\n\nextern ngx_module_t        ngx_tcp_upstream_module;\n\n\n#endif /* _NGX_TCP_UPSTREAM_H_INCLUDED_ */\n"
        },
        {
          "name": "ngx_tcp_upstream_check.c",
          "type": "blob",
          "size": 50.5703125,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_tcp.h>\n#include <ngx_http.h>\n\n\n/* ngx_spinlock is defined without a matching unlock primitive */\n#define ngx_spinlock_unlock(lock)      \\\n    (void) ngx_atomic_cmp_set(lock, ngx_pid, 0)\n\nstatic ngx_int_t ngx_tcp_check_get_shm_name(ngx_str_t *shm_name,\n    ngx_pool_t *pool);\nstatic ngx_int_t ngx_tcp_upstream_check_init_shm_zone(ngx_shm_zone_t *shm_zone,\n    void *data);\nstatic ngx_int_t ngx_tcp_check_init_process(ngx_cycle_t *cycle);\n\nstatic void ngx_tcp_check_peek_handler(ngx_event_t *event);\n\nstatic void ngx_tcp_check_send_handler(ngx_event_t *event);\nstatic void ngx_tcp_check_recv_handler(ngx_event_t *event);\n\nstatic ngx_int_t ngx_tcp_check_http_init(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic ngx_int_t ngx_tcp_check_http_parse(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic void ngx_tcp_check_http_reinit(ngx_tcp_check_peer_conf_t *peer_conf);\n\nstatic ngx_int_t ngx_tcp_check_ssl_hello_init(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic ngx_int_t ngx_tcp_check_ssl_hello_parse(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic void ngx_tcp_check_ssl_hello_reinit(ngx_tcp_check_peer_conf_t *peer_conf);\n\nstatic ngx_int_t ngx_tcp_check_smtp_init(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic ngx_int_t ngx_tcp_check_smtp_parse(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic void ngx_tcp_check_smtp_reinit(ngx_tcp_check_peer_conf_t *peer_conf);\n\nstatic ngx_int_t ngx_tcp_check_mysql_init(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic ngx_int_t ngx_tcp_check_mysql_parse(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic void ngx_tcp_check_mysql_reinit(ngx_tcp_check_peer_conf_t *peer_conf);\n\nstatic ngx_int_t ngx_tcp_check_pop3_init(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic ngx_int_t ngx_tcp_check_pop3_parse(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic void ngx_tcp_check_pop3_reinit(ngx_tcp_check_peer_conf_t *peer_conf);\n\nstatic ngx_int_t ngx_tcp_check_imap_init(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic ngx_int_t ngx_tcp_check_imap_parse(ngx_tcp_check_peer_conf_t *peer_conf);\nstatic void ngx_tcp_check_imap_reinit(ngx_tcp_check_peer_conf_t *peer_conf);\n\nstatic char * ngx_tcp_upstream_check_status_set_status(ngx_conf_t *cf, \n        ngx_command_t *cmd, void *conf);\nstatic char * ngx_tcp_upstream_check_status(ngx_conf_t *cf, \n        ngx_command_t *cmd, void *conf);\n\n\n#define RANDOM \"NGX_TCP_CHECK_SSL_HELLO\\n\\n\\n\\n\\n\"\n\n/* This is the SSLv3 CLIENT HELLO packet used in conjunction with the\n * check type of ssl_hello to ensure that the remote server speaks SSL.\n *\n * Check RFC 2246 (TLSv1.0) sections A.3 and A.4 for details.\n *\n * Some codes copy from HAProxy 1.4.1\n */\nstatic const char sslv3_client_hello_pkt[] = {\n\t\"\\x16\"                /* ContentType         : 0x16 = Handshake          */\n\t\"\\x03\\x00\"            /* ProtocolVersion     : 0x0300 = SSLv3            */\n\t\"\\x00\\x79\"            /* ContentLength       : 0x79 bytes after this one */\n\t\"\\x01\"                /* HandshakeType       : 0x01 = CLIENT HELLO       */\n\t\"\\x00\\x00\\x75\"        /* HandshakeLength     : 0x75 bytes after this one */\n\t\"\\x03\\x00\"            /* Hello Version       : 0x0300 = v3               */\n\t\"\\x00\\x00\\x00\\x00\"    /* Unix GMT Time (s)   : filled with <now> (@0x0B) */\n\tRANDOM                /* Random   : must be exactly 28 bytes  */\n\t\"\\x00\"                /* Session ID length   : empty (no session ID)     */\n\t\"\\x00\\x4E\"            /* Cipher Suite Length : 78 bytes after this one   */\n\t\"\\x00\\x01\" \"\\x00\\x02\" \"\\x00\\x03\" \"\\x00\\x04\" /* 39 most common ciphers :  */\n\t\"\\x00\\x05\" \"\\x00\\x06\" \"\\x00\\x07\" \"\\x00\\x08\" /* 0x01...0x1B, 0x2F...0x3A  */\n\t\"\\x00\\x09\" \"\\x00\\x0A\" \"\\x00\\x0B\" \"\\x00\\x0C\" /* This covers RSA/DH,       */\n\t\"\\x00\\x0D\" \"\\x00\\x0E\" \"\\x00\\x0F\" \"\\x00\\x10\" /* various bit lengths,      */\n\t\"\\x00\\x11\" \"\\x00\\x12\" \"\\x00\\x13\" \"\\x00\\x14\" /* SHA1/MD5, DES/3DES/AES... */\n\t\"\\x00\\x15\" \"\\x00\\x16\" \"\\x00\\x17\" \"\\x00\\x18\"\n\t\"\\x00\\x19\" \"\\x00\\x1A\" \"\\x00\\x1B\" \"\\x00\\x2F\"\n\t\"\\x00\\x30\" \"\\x00\\x31\" \"\\x00\\x32\" \"\\x00\\x33\"\n\t\"\\x00\\x34\" \"\\x00\\x35\" \"\\x00\\x36\" \"\\x00\\x37\"\n\t\"\\x00\\x38\" \"\\x00\\x39\" \"\\x00\\x3A\"\n\t\"\\x01\"                /* Compression Length  : 0x01 = 1 byte for types   */\n\t\"\\x00\"                /* Compression Type    : 0x00 = NULL compression   */\n};\n\n\n#define HANDSHAKE    0x16\n#define SERVER_HELLO 0x02\n\nstatic check_conf_t  ngx_check_types[] = {\n\n    { NGX_TCP_CHECK_TCP,\n      \"tcp\",\n      ngx_null_string,\n      0,\n      ngx_tcp_check_peek_handler,\n      ngx_tcp_check_peek_handler,\n      NULL,\n      NULL,\n      NULL,\n      0 },\n\n    { NGX_TCP_CHECK_HTTP,\n      \"http\",\n      ngx_string(\"GET / HTTP/1.0\\r\\n\\r\\n\"),\n      NGX_CONF_BITMASK_SET | NGX_CHECK_HTTP_2XX | NGX_CHECK_HTTP_3XX,\n      ngx_tcp_check_send_handler,\n      ngx_tcp_check_recv_handler,\n      ngx_tcp_check_http_init,\n      ngx_tcp_check_http_parse,\n      ngx_tcp_check_http_reinit,\n      1 },\n\n    { NGX_TCP_CHECK_SSL_HELLO,\n      \"ssl_hello\",\n      ngx_string(sslv3_client_hello_pkt),\n      0,\n      ngx_tcp_check_send_handler,\n      ngx_tcp_check_recv_handler,\n      ngx_tcp_check_ssl_hello_init,\n      ngx_tcp_check_ssl_hello_parse,\n      ngx_tcp_check_ssl_hello_reinit,\n      1 },\n\n    { NGX_TCP_CHECK_SMTP,\n      \"smtp\",\n      ngx_string(\"HELO smtp.localdomain\\r\\n\"),\n      NGX_CONF_BITMASK_SET | NGX_CHECK_SMTP_2XX,\n      ngx_tcp_check_send_handler,\n      ngx_tcp_check_recv_handler,\n      ngx_tcp_check_smtp_init,\n      ngx_tcp_check_smtp_parse,\n      ngx_tcp_check_smtp_reinit,\n      1 },\n\n    { NGX_TCP_CHECK_MYSQL,\n      \"mysql\",\n      ngx_null_string,\n      0,\n      ngx_tcp_check_send_handler,\n      ngx_tcp_check_recv_handler,\n      ngx_tcp_check_mysql_init,\n      ngx_tcp_check_mysql_parse,\n      ngx_tcp_check_mysql_reinit,\n      1 },\n\n    { NGX_TCP_CHECK_POP3,\n      \"pop3\",\n      ngx_null_string,\n      0,\n      ngx_tcp_check_send_handler,\n      ngx_tcp_check_recv_handler,\n      ngx_tcp_check_pop3_init,\n      ngx_tcp_check_pop3_parse,\n      ngx_tcp_check_pop3_reinit,\n      1 },\n\n    { NGX_TCP_CHECK_IMAP,\n      \"imap\",\n      ngx_null_string,\n      0,\n      ngx_tcp_check_send_handler,\n      ngx_tcp_check_recv_handler,\n      ngx_tcp_check_imap_init,\n      ngx_tcp_check_imap_parse,\n      ngx_tcp_check_imap_reinit,\n      1 },\n\n    {0, \"\", ngx_null_string, 0, NULL, NULL, NULL, NULL, NULL, 0}\n};\n\n\nstatic ngx_conf_deprecated_t  ngx_conf_deprecated_check_status = {\n    ngx_conf_deprecated, \"check_status\", \"tcp_check_status\"\n};\n\nstatic ngx_command_t  ngx_tcp_upstream_check_status_commands[] = {\n\n    { ngx_string(\"check_status\"),\n      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,\n      ngx_tcp_upstream_check_status_set_status,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"tcp_check_status\"),\n      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,\n      ngx_tcp_upstream_check_status,\n      0,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_http_module_t  ngx_tcp_upstream_check_status_module_ctx = {\n    NULL,                                  /* preconfiguration */\n    NULL,                                  /* postconfiguration */\n\n    NULL,                                  /* create main configuration */\n    NULL,                                  /* init main configuration */\n\n    NULL,                                  /* create server configuration */\n    NULL,                                  /* merge server configuration */\n\n    NULL,                                  /* create location configuration */\n    NULL                                   /* merge location configuration */\n};\n\n\nngx_module_t  ngx_tcp_upstream_check_status_module = {\n    NGX_MODULE_V1,\n    &ngx_tcp_upstream_check_status_module_ctx, /* module context */\n    ngx_tcp_upstream_check_status_commands,    /* module directives */\n    NGX_HTTP_MODULE,                           /* module type */\n    NULL,                                      /* init master */\n    NULL,                                      /* init module */\n    ngx_tcp_check_init_process,                /* init process */\n    NULL,                                      /* init thread */\n    NULL,                                      /* exit thread */\n    NULL,                                      /* exit process */\n    NULL,                                      /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_uint_t ngx_tcp_check_shm_generation = 0;\nstatic ngx_tcp_check_peers_conf_t *check_peers_ctx = NULL;\n\n\ncheck_conf_t *\nngx_tcp_get_check_type_conf(ngx_str_t *str) \n{\n    ngx_uint_t i;\n\n    for (i = 0; ;i++) {\n\n        if (ngx_check_types[i].type == 0) {\n            break;\n        }\n\n        if (ngx_strncmp(str->data, (u_char *)ngx_check_types[i].name,\n                        str->len) == 0) {\n            return &ngx_check_types[i];\n        }\n    }\n\n    return NULL;\n}\n\n\nngx_uint_t\nngx_tcp_check_add_peer(ngx_conf_t *cf, ngx_tcp_upstream_srv_conf_t *uscf,\n    ngx_peer_addr_t *peer, ngx_uint_t max_busy) \n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_check_peers_conf_t    *peers_conf;\n    ngx_tcp_upstream_main_conf_t  *umcf; \n\n    umcf = ngx_tcp_conf_get_module_main_conf(cf, ngx_tcp_upstream_module);\n\n    peers_conf = umcf->peers_conf;\n\n    peer_conf = ngx_array_push(&peers_conf->peers);\n    if (peer_conf == NULL) {\n        return NGX_INVALID_CHECK_INDEX;\n    }\n\n    ngx_memzero(peer_conf, sizeof(ngx_tcp_check_peer_conf_t));\n\n    peer_conf->index = peers_conf->peers.nelts - 1;\n    peer_conf->max_busy = max_busy;\n    peer_conf->conf = uscf;\n    peer_conf->peer = peer;\n\n    return peer_conf->index;\n}\n\n\nngx_uint_t \nngx_tcp_check_peer_down(ngx_uint_t index)\n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n\n    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {\n        return 0;\n    }\n\n    peer_conf = check_peers_ctx->peers.elts;\n\n    return (peer_conf[index].shm->down || \n            (peer_conf[index].shm->busyness > peer_conf[index].max_busy));\n}\n\n\nngx_uint_t \nngx_tcp_check_get_peer_busyness(ngx_uint_t index)\n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n\n    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {\n        return (ngx_uint_t) (-1);\n    }\n\n    peer_conf = check_peers_ctx->peers.elts;\n\n    return peer_conf[index].shm->busyness;\n}\n\n\nvoid \nngx_tcp_check_get_peer(ngx_uint_t index) \n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n\n    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {\n        return;\n    }\n\n    peer_conf = check_peers_ctx->peers.elts;\n\n    ngx_spinlock(&peer_conf[index].shm->lock, ngx_pid, 1024);\n\n    peer_conf[index].shm->busyness++;\n    peer_conf[index].shm->access_count++;\n\n    ngx_spinlock_unlock(&peer_conf[index].shm->lock);\n}\n\n\nvoid \nngx_tcp_check_free_peer(ngx_uint_t index) \n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n\n    if (check_peers_ctx == NULL || index >= check_peers_ctx->peers.nelts) {\n        return;\n    }\n\n    peer_conf = check_peers_ctx->peers.elts;\n\n    ngx_spinlock(&peer_conf[index].shm->lock, ngx_pid, 1024);\n\n    if (peer_conf[index].shm->busyness > 0) {\n        peer_conf[index].shm->busyness--;\n    }\n\n    ngx_spinlock_unlock(&peer_conf[index].shm->lock);\n}\n\n\n#define SHM_NAME_LEN 256\n\nstatic ngx_int_t\nngx_tcp_upstream_check_init_shm_zone(ngx_shm_zone_t *shm_zone, void *data) \n{\n    ngx_uint_t                      i;\n    ngx_slab_pool_t                *shpool;\n    ngx_tcp_check_peer_shm_t       *peer_shm;\n    ngx_tcp_check_peers_shm_t      *peers_shm;\n    ngx_tcp_check_peers_conf_t     *peers_conf;\n\n    peers_conf = shm_zone->data;\n\n    if (peers_conf == NULL || peers_conf->peers.nelts == 0) {\n        return NGX_OK;\n    }\n\n    if (data) {\n        peers_shm = data;\n    } else {\n        shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;\n\n        peers_shm = ngx_slab_alloc(shpool, sizeof(*peers_shm) +\n            (peers_conf->peers.nelts - 1) * sizeof(ngx_tcp_check_peer_shm_t));\n\n        if (peers_shm == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, shm_zone->shm.log, 0,\n                          \"tcp upstream check_shm_size is too small, \"\n                          \"you should set a larger size.\");\n            return NGX_ERROR;\n        }\n    }\n\n    peers_shm->generation = ngx_tcp_check_shm_generation;\n\n    for (i = 0; i < peers_conf->peers.nelts; i++) {\n        peer_shm = &peers_shm->peers[i];\n\n        peer_shm->owner = NGX_INVALID_PID;\n\n        peer_shm->access_time = 0;\n        peer_shm->access_count = 0;\n\n        peer_shm->fall_count = 0;\n        peer_shm->rise_count = 0;\n\n        peer_shm->busyness = 0;\n        peer_shm->down = 1;\n    }\n\n    peers_conf->peers_shm = peers_shm;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_get_shm_name(ngx_str_t *shm_name, ngx_pool_t *pool) \n{\n    u_char    *last;\n\n    shm_name->data = ngx_palloc(pool, SHM_NAME_LEN);\n    if (shm_name->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    last = ngx_snprintf(shm_name->data, SHM_NAME_LEN, \"%s#%ui\",\n                        \"ngx_tcp_upstream\", ngx_tcp_check_shm_generation);\n\n    shm_name->len = last - shm_name->data;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_shm_zone_t *\nngx_shared_memory_find(ngx_cycle_t *cycle, ngx_str_t *name, void *tag)\n{\n    ngx_uint_t        i;\n    ngx_shm_zone_t   *shm_zone;\n    ngx_list_part_t  *part;\n\n    part = (ngx_list_part_t *) & (cycle->shared_memory.part);\n    shm_zone = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            shm_zone = part->elts;\n            i = 0;\n        }\n\n        if (name->len != shm_zone[i].shm.name.len) {\n            continue;\n        }\n\n        if (ngx_strncmp(name->data, shm_zone[i].shm.name.data, name->len)\n            != 0)\n        {\n            continue;\n        }\n\n        if (tag != shm_zone[i].tag) {\n            continue;\n        }\n\n        return &shm_zone[i];\n    }\n\n    return NULL;\n}\n\n\nstatic void \nngx_tcp_check_clean_event(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_connection_t            *c;\n\n    c = peer_conf->pc.connection;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, 0, \n                   \"tcp check clean event: index:%d, fd: %d\", \n                   peer_conf->index, c->fd);\n\n    ngx_close_connection(c);\n\n    if (peer_conf->check_timeout_ev.timer_set) {\n        ngx_del_timer(&peer_conf->check_timeout_ev);\n    }\n\n    peer_conf->state = NGX_TCP_CHECK_ALL_DONE;\n\n    if (peer_conf->check_data != NULL && peer_conf->reinit) {\n        peer_conf->reinit(peer_conf);\n    }\n\n    ngx_spinlock(&peer_conf->shm->lock, ngx_pid, 1024);\n\n    peer_conf->shm->owner = NGX_INVALID_PID;\n\n    ngx_spinlock_unlock(&peer_conf->shm->lock);\n}\n\n\nstatic void \nngx_tcp_check_clear_all_events() \n{\n    ngx_uint_t                     i;\n    static ngx_flag_t              has_cleared = 0;\n    ngx_tcp_check_peer_shm_t      *peer_shm;\n    ngx_tcp_check_peers_shm_t     *peers_shm;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_check_peers_conf_t    *peers_conf;\n\n    if (has_cleared || check_peers_ctx == NULL) {\n        return;\n    }\n\n    has_cleared = 1;\n\n    peers_conf = check_peers_ctx;\n    peers_shm = peers_conf->peers_shm;\n\n    peer_conf = peers_conf->peers.elts;\n    peer_shm = peers_shm->peers;\n    for (i = 0; i < peers_conf->peers.nelts; i++) {\n        if (peer_conf[i].check_ev.timer_set) {\n            ngx_del_timer(&peer_conf[i].check_ev);\n        }\n        if (peer_shm[i].owner == ngx_pid) {\n            ngx_tcp_check_clean_event(&peer_conf[i]);\n        }\n        if (peer_conf[i].pool != NULL) {\n            ngx_destroy_pool(peer_conf[i].pool);\n        }\n    }\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_need_exit() \n{\n    if (ngx_terminate || ngx_exiting || ngx_quit) {\n        ngx_tcp_check_clear_all_events();\n        return 1;\n    }\n\n    return 0;\n}\n\n\nstatic void \nngx_tcp_check_finish_handler(ngx_event_t *event) \n{\n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n}\n\n\nstatic void \nngx_tcp_check_status_update(ngx_tcp_check_peer_conf_t *peer_conf,\n    ngx_int_t result) \n{\n    ngx_tcp_upstream_srv_conf_t   *uscf;\n\n    uscf = peer_conf->conf;\n\n    if (result) {\n        peer_conf->shm->rise_count++; \n        peer_conf->shm->fall_count = 0; \n        if (peer_conf->shm->down\n            && (peer_conf->shm->rise_count >= uscf->rise_count)) {\n\n            peer_conf->shm->down = 0; \n        } \n    } else {\n        peer_conf->shm->rise_count = 0; \n        peer_conf->shm->fall_count++; \n        if (!peer_conf->shm->down\n             && (peer_conf->shm->fall_count >= uscf->fall_count)) {\n            peer_conf->shm->down = 1; \n        }\n    }\n\n    peer_conf->shm->access_time = ngx_current_msec; \n}\n\n\nstatic void \nngx_tcp_check_timeout_handler(ngx_event_t *event) \n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    \n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n\n    peer_conf = event->data;\n\n    ngx_log_error(NGX_LOG_ERR, event->log, 0,\n                  \"check time out with peer: %V \", &peer_conf->peer->name);\n\n    ngx_tcp_check_status_update(peer_conf, 0);\n    ngx_tcp_check_clean_event(peer_conf);\n}\n\n\nstatic void \nngx_tcp_check_peek_handler(ngx_event_t *event) \n{\n    char                           buf[1];\n    ngx_int_t                      n;\n    ngx_err_t                      err;\n    ngx_connection_t              *c;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n\n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n\n    c = event->data;\n    peer_conf = c->data;\n\n    n = recv(c->fd, buf, 1, MSG_PEEK);\n\n    err = ngx_socket_errno;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err, \n                   \"tcp check upstream recv(): %d, fd: %d\",\n                   n, c->fd);\n\n    if (n >= 0 || err == NGX_EAGAIN) {\n        ngx_tcp_check_status_update(peer_conf, 1);\n    } else {\n        c->error = 1;\n        ngx_tcp_check_status_update(peer_conf, 0);\n    }\n\n    ngx_tcp_check_clean_event(peer_conf);\n\n    /* dummy */\n    ngx_tcp_check_finish_handler(event);\n}\n\n\nvoid\nhttp_field(void *data, const signed char *field, \n    size_t flen, const signed char *value, size_t vlen)\n{\n#if (NGX_DEBUG)\n    ngx_str_t str_field, str_value;\n\n    str_field.data = (u_char *) field;\n    str_field.len = flen;\n\n    str_value.data = (u_char *) value;\n    str_value.len = vlen;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"%V: %V\", &str_field, &str_value);\n#endif\n}\n\n\nvoid\nhttp_version(void *data, const signed char *at, size_t length)\n{\n#if (NGX_DEBUG)\n    ngx_str_t str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"VERSION: \\\"%V\\\"\", &str);\n#endif\n}\n\n\nvoid\nstatus_code(void *data, const signed char *at, size_t length)\n{\n    int                        code;\n    ngx_tcp_check_ctx         *ctx;\n    http_response_parser      *hp;\n    ngx_tcp_check_peer_conf_t *peer_conf = data;\n\n#if (NGX_DEBUG)\n    ngx_str_t                  str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"STATUS_CODE: \\\"%V\\\"\", &str);\n#endif\n\n    ctx = peer_conf->check_data;\n    hp = ctx->parser;\n\n    code = ngx_atoi((u_char*)at, length);\n\n    if (code >= 200 && code < 300) {\n        hp->status_code_n = NGX_CHECK_HTTP_2XX;\n\n    } else if (code >= 300 && code < 400) {\n        hp->status_code_n = NGX_CHECK_HTTP_3XX;\n\n    } else if (code >= 400 && code < 500) {\n        hp->status_code_n = NGX_CHECK_HTTP_4XX;\n\n    } else if (code >= 500 && code < 600) {\n        hp->status_code_n = NGX_CHECK_HTTP_5XX;\n\n    } else {\n        hp->status_code_n = NGX_CHECK_HTTP_ERR;\n    }\n}\n\n\nvoid\nreason_phrase(void *data, const signed char *at, size_t length)\n{\n#if (NGX_DEBUG)\n    ngx_str_t str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"REASON_PHRASE: \\\"%V\\\"\", &str);\n#endif\n}\n\n\nvoid\nheader_done(void *data, const signed char *at, size_t length)\n{\n\n}\n\n\nstatic void\ncheck_http_response_parser_init(http_response_parser *hp, \n    void *data) \n{\n    hp->data = data;\n    hp->http_field = http_field;\n    hp->http_version = http_version;\n    hp->status_code = status_code;\n    hp->status_code_n = 0;\n    hp->reason_phrase = reason_phrase;\n    hp->header_done = header_done;\n    \n    http_response_parser_init(hp);\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_http_init(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n    \n    ctx = peer_conf->check_data;\n    uscf = peer_conf->conf;\n\n    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;\n    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;\n\n    ctx->recv.start = ctx->recv.pos = NULL;\n    ctx->recv.end = ctx->recv.last = NULL;\n\n    ctx->parser = ngx_pcalloc(peer_conf->pool, sizeof(http_response_parser));\n    if (ctx->parser == NULL) {\n        return NGX_ERROR;\n    }\n\n    check_http_response_parser_init(ctx->parser, peer_conf);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_http_parse(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ssize_t                       n, offset, length;\n    ngx_tcp_check_ctx            *ctx;\n    http_response_parser         *hp;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n\n    uscf = peer_conf->conf;\n    ctx = peer_conf->check_data;\n    hp = ctx->parser;\n\n    if ((ctx->recv.last - ctx->recv.pos) > 0) {\n        offset = ctx->recv.pos - ctx->recv.start;\n        length = ctx->recv.last - ctx->recv.start;\n\n        n = http_response_parser_execute(hp, (signed char *)ctx->recv.start,\n                                         length, offset);\n        ctx->recv.pos = ctx->recv.start + n;\n\n        if (http_response_parser_finish(hp) == -1) {\n            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,\n                          \"http parse error with peer: %V, recv data: %s\", \n                          &peer_conf->peer->name, ctx->recv.start);\n            return NGX_ERROR;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                       \"http_parse: hp->status_code_n: %d, conf: %d\",\n                       hp->status_code_n, uscf->code.status_alive);\n\n        if (hp->status_code_n == 0) {\n            return NGX_AGAIN;\n\n        } else if (hp->status_code_n & uscf->code.status_alive) {\n            return NGX_OK;\n\n        } else {\n            return NGX_ERROR;\n        }\n\n    } else {\n        return NGX_AGAIN;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void \nngx_tcp_check_http_reinit(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx *ctx;\n\n    ctx = peer_conf->check_data;\n\n    ctx->send.pos = ctx->send.start;\n    ctx->send.last = ctx->send.end;\n\n    ctx->recv.pos = ctx->recv.last = ctx->recv.start;\n\n    check_http_response_parser_init(ctx->parser, peer_conf);\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_ssl_hello_init(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n    \n    ctx = peer_conf->check_data;\n    uscf = peer_conf->conf;\n\n    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;\n    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;\n\n    ctx->recv.start = ctx->recv.pos = NULL;\n    ctx->recv.end = ctx->recv.last = NULL;\n\n    return NGX_OK;\n}\n\n\n/* a rough check of server ssl_hello responses */\nstatic ngx_int_t \nngx_tcp_check_ssl_hello_parse(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    size_t                        size;\n    server_ssl_hello_t           *resp;\n    ngx_tcp_check_ctx            *ctx;\n\n    ctx = peer_conf->check_data;\n\n    size = ctx->recv.last - ctx->recv.pos;\n    if (size < sizeof(server_ssl_hello_t)) {\n        return NGX_AGAIN;\n    } \n\n    resp = (server_ssl_hello_t *) ctx->recv.pos;\n\n    ngx_log_debug7(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"tcp check ssl_parse, type: %d, version: %d.%d, \"\n                   \"length: %d, handshake_type: %d, \"\n                   \"hello_version: %d.%d\", \n                   resp->msg_type, resp->version.major, resp->version.minor, \n                   ntohs(resp->length), resp->handshake_type, \n                   resp->hello_version.major, resp->hello_version.minor);\n\n    if (resp->msg_type != HANDSHAKE) {\n        return NGX_ERROR;\n    }\n\n    if (resp->handshake_type != SERVER_HELLO) {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void \nngx_tcp_check_ssl_hello_reinit(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx *ctx;\n\n    ctx = peer_conf->check_data;\n\n    ctx->send.pos = ctx->send.start;\n    ctx->send.last = ctx->send.end;\n\n    ctx->recv.pos = ctx->recv.last = ctx->recv.start;\n}\n\n\nstatic void \ndomain(void *data, const signed char *at, size_t length)\n{\n#if (NGX_DEBUG)\n    ngx_str_t str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"DOMAIN: \\\"%V\\\"\", &str);\n#endif\n}\n\n\nstatic void \ngreeting_text(void *data, const signed char *at, size_t length)\n{\n#if (NGX_DEBUG)\n    ngx_str_t str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"GREETING_TEXT: \\\"%V\\\"\", &str);\n#endif\n}\n\n\nstatic void \nreply_code(void *data, const signed char *at, size_t length)\n{\n    int                        code;\n    smtp_parser               *sp;\n    ngx_tcp_check_ctx         *ctx;\n    ngx_tcp_check_peer_conf_t *peer_conf = data;\n\n#if (NGX_DEBUG)\n    ngx_str_t                  str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"REPLY_CODE: \\\"%V\\\"\", &str);\n#endif\n\n    ctx = peer_conf->check_data;\n    sp = ctx->parser;\n\n    code = ngx_atoi((u_char*)at, length);\n\n    if (code >= 200 && code < 300) {\n        sp->hello_reply_code = NGX_CHECK_SMTP_2XX;\n\n    } else if (code >= 300 && code < 400) {\n        sp->hello_reply_code = NGX_CHECK_SMTP_3XX;\n\n    } else if (code >= 400 && code < 500) {\n        sp->hello_reply_code = NGX_CHECK_SMTP_4XX;\n\n    } else if (code >= 500 && code < 600) {\n        sp->hello_reply_code = NGX_CHECK_SMTP_5XX;\n\n    } else {\n        sp->hello_reply_code = NGX_CHECK_SMTP_ERR;\n    }\n}\n\n\nstatic void \nreply_text(void *data, const signed char *at, size_t length)\n{\n#if (NGX_DEBUG)\n    ngx_str_t str;\n\n    str.data = (u_char *) at;\n    str.len = length;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"REPLY_TEXT: \\\"%V\\\"\", &str);\n#endif\n}\n\n\nstatic void \nsmtp_done(void *data, const signed char *at, size_t length)\n{\n\n}\n\n\nstatic void \ncheck_smtp_parser_init(smtp_parser *sp, void *data) \n{\n    sp->data = data;\n    sp->hello_reply_code = 0;\n\n    sp->domain = domain;\n    sp->greeting_text = greeting_text;\n    sp->reply_code = reply_code;\n    sp->reply_text = reply_text;\n    sp->smtp_done = smtp_done;\n\n    smtp_parser_init(sp);\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_smtp_init(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n    \n    ctx = peer_conf->check_data;\n    uscf = peer_conf->conf;\n\n    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;\n    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;\n\n    ctx->recv.start = ctx->recv.pos = NULL;\n    ctx->recv.end = ctx->recv.last = NULL;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"smtp_init: send:%V\", &uscf->send);\n\n    ctx->parser = ngx_pcalloc(peer_conf->pool, sizeof(smtp_parser));\n    if (ctx->parser == NULL) {\n        return NGX_ERROR;\n    }\n\n    check_smtp_parser_init(ctx->parser, peer_conf);\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_smtp_parse(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ssize_t                       n, offset, length;\n    smtp_parser                  *sp;\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n\n    uscf = peer_conf->conf;\n    ctx = peer_conf->check_data;\n    sp = ctx->parser;\n\n    if (ctx->recv.last - ctx->recv.pos <= 0 ) {\n        return NGX_AGAIN;\n    }\n\n    offset = ctx->recv.pos - ctx->recv.start;\n    length = ctx->recv.last - ctx->recv.start;\n\n    n = smtp_parser_execute(sp, (signed char *)ctx->recv.start, length, offset);\n    ctx->recv.pos = ctx->recv.start + n;\n\n    if (smtp_parser_finish(sp) == -1) {\n        ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,\n                      \"smtp parse error with peer: %V, recv data: %s\", \n                      &peer_conf->peer->name, ctx->recv.pos);\n\n        /* \n         * Some SMTP servers are not strictly designed with the RFC2821, \n         * but it does work\n         * */\n        if (*ctx->recv.start == '2') {\n            return NGX_OK;\n        }\n\n        return NGX_ERROR;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"smtp_parse: sp->hello_reply_code: %d, conf: %d\",\n                   sp->hello_reply_code, uscf->code.status_alive);\n\n    if (sp->hello_reply_code == 0) {\n        return NGX_AGAIN;\n\n    } else if (sp->hello_reply_code & uscf->code.status_alive) {\n        return NGX_OK;\n\n    } else {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_tcp_check_smtp_reinit(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx *ctx;\n\n    ctx = peer_conf->check_data;\n\n    ctx->send.pos = ctx->send.start;\n    ctx->send.last = ctx->send.end;\n\n    ctx->recv.pos = ctx->recv.last = ctx->recv.start;\n\n    check_smtp_parser_init(ctx->parser, peer_conf);\n}\n   \n\nstatic ngx_int_t \nngx_tcp_check_mysql_init(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n    \n    ctx = peer_conf->check_data;\n    uscf = peer_conf->conf;\n\n    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;\n    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;\n\n    ctx->recv.start = ctx->recv.pos = NULL;\n    ctx->recv.end = ctx->recv.last = NULL;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_mysql_parse(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    mysql_handshake_init_t       *handshake;\n\n    ctx = peer_conf->check_data;\n\n    if (ctx->recv.last - ctx->recv.pos <= 0 ) {\n        return NGX_AGAIN;\n    }\n\n    handshake = (mysql_handshake_init_t *) ctx->recv.pos;\n\n    ngx_log_debug3(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"mysql_parse: packet_number=%d, protocol=%d, server=%s\", \n                   handshake->packet_number,\n                   handshake->protocol_version,\n                   handshake->others);\n\n    /* The mysql greeting packet's serial number always begin with 0. */\n    if (handshake->packet_number != 0x00) {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_tcp_check_mysql_reinit(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx *ctx;\n\n    ctx = peer_conf->check_data;\n\n    ctx->send.pos = ctx->send.start;\n    ctx->send.last = ctx->send.end;\n\n    ctx->recv.pos = ctx->recv.last = ctx->recv.start;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_pop3_init(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n    \n    ctx = peer_conf->check_data;\n    uscf = peer_conf->conf;\n\n    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;\n    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;\n\n    ctx->recv.start = ctx->recv.pos = NULL;\n    ctx->recv.end = ctx->recv.last = NULL;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_pop3_parse(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    u_char                        ch;\n    ngx_tcp_check_ctx            *ctx;\n\n    ctx = peer_conf->check_data;\n\n    if (ctx->recv.last - ctx->recv.pos <= 0 ) {\n        return NGX_AGAIN;\n    }\n\n    ch = *(ctx->recv.start);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"pop3_parse: packet_greeting \\\"%s\\\"\", ctx->recv.start);\n\n    /*\n     * RFC 1939\n     * There are currently two status indicators: positive (\"+OK\") and \n     * negative (\"-ERR\").  Servers MUST send the \"+OK\" and \"-ERR\" in upper case.\n     */\n    if (ch != '+') {\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void\nngx_tcp_check_pop3_reinit(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx *ctx;\n\n    ctx = peer_conf->check_data;\n\n    ctx->send.pos = ctx->send.start;\n    ctx->send.last = ctx->send.end;\n\n    ctx->recv.pos = ctx->recv.last = ctx->recv.start;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_imap_init(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx            *ctx;\n    ngx_tcp_upstream_srv_conf_t  *uscf;\n    \n    ctx = peer_conf->check_data;\n    uscf = peer_conf->conf;\n\n    ctx->send.start = ctx->send.pos = (u_char *)uscf->send.data;\n    ctx->send.end = ctx->send.last = ctx->send.start + uscf->send.len;\n\n    ctx->recv.start = ctx->recv.pos = NULL;\n    ctx->recv.end = ctx->recv.last = NULL;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_imap_parse(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    u_char                       *p;\n    ngx_tcp_check_ctx            *ctx;\n\n    ctx = peer_conf->check_data;\n\n    if (ctx->recv.last - ctx->recv.pos <= 0 ) {\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, ngx_cycle->log, 0, \n                   \"imap_parse: packet_greeting \\\"%s\\\"\", ctx->recv.start);\n\n    /* RFC 3501\n     * command         = tag SP (command-any / command-auth / command-nonauth /\n     * command-select) CRLF\n     */\n\n    p = ctx->recv.start;\n    while (p < ctx->recv.last) {\n\n        if (*p == ' ') {\n            if ((p + 2) >= ctx->recv.last) {\n                return NGX_AGAIN;\n            }\n            else if (*(p + 1) == 'O' && *(p + 2) == 'K') {\n                return NGX_OK;\n            }\n            else {\n                return NGX_ERROR;\n            }\n        }\n\n        p++;\n    }\n\n    return NGX_AGAIN;\n}\n\n\nstatic void\nngx_tcp_check_imap_reinit(ngx_tcp_check_peer_conf_t *peer_conf) \n{\n    ngx_tcp_check_ctx *ctx;\n\n    ctx = peer_conf->check_data;\n\n    ctx->send.pos = ctx->send.start;\n    ctx->send.last = ctx->send.end;\n\n    ctx->recv.pos = ctx->recv.last = ctx->recv.start;\n}\n\n\nstatic void \nngx_tcp_check_send_handler(ngx_event_t *event) \n{\n    ssize_t                        size;\n    ngx_connection_t              *c;\n    ngx_tcp_check_ctx             *ctx;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n\n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n\n    c = event->data;\n    peer_conf = c->data;\n\n    if (c->pool == NULL) {\n        ngx_log_error(NGX_LOG_ERR, event->log, 0,\n                      \"check pool NULL with peer: %V \", &peer_conf->peer->name);\n\n        goto check_send_fail;\n    }\n\n    if (peer_conf->state != NGX_TCP_CHECK_CONNECT_DONE) {\n        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {\n                goto check_send_fail;\n        }\n\n        return;\n    }\n\n    if (peer_conf->check_data == NULL) {\n\n        peer_conf->check_data = ngx_pcalloc(c->pool, sizeof(ngx_tcp_check_ctx));\n        if (peer_conf->check_data == NULL) {\n            goto check_send_fail;\n        }\n\n        if (peer_conf->init == NULL || peer_conf->init(peer_conf) != NGX_OK) {\n\n            ngx_log_error(NGX_LOG_ERR, event->log, 0,\n                          \"check init error with peer: %V \",\n                          &peer_conf->peer->name);\n\n            goto check_send_fail;\n        }\n    }\n\n    ctx = peer_conf->check_data;\n\n    while (ctx->send.pos < ctx->send.last) {\n\n        size = c->send(c, ctx->send.pos, ctx->send.last - ctx->send.pos);\n\n#if (NGX_DEBUG)\n        ngx_err_t                      err;\n\n        err = (size >=0) ? 0 : ngx_socket_errno;\n        ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err, \n                       \"tcp check send size: %d, total: %d\",\n                       size, ctx->send.last - ctx->send.pos);\n#endif\n\n        if (size >= 0) {\n            ctx->send.pos += size;\n\n        } else if (size == NGX_AGAIN) {\n            return;\n\n        } else {\n            c->error = 1;\n            goto check_send_fail;\n        }\n    }\n\n    if (ctx->send.pos == ctx->send.last) {\n        ngx_log_debug0(NGX_LOG_DEBUG_TCP, c->log, 0, \"tcp check send done.\");\n        peer_conf->state = NGX_TCP_CHECK_SEND_DONE;\n    }\n\n    return;\n\ncheck_send_fail:\n    ngx_tcp_check_status_update(peer_conf, 0);\n    ngx_tcp_check_clean_event(peer_conf);\n    return;\n}\n\n\nstatic void \nngx_tcp_check_recv_handler(ngx_event_t *event) \n{\n    ssize_t                        size, n, rc;\n    u_char                        *new_buf;\n    ngx_connection_t              *c;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_check_ctx             *ctx;\n\n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n\n    c = event->data;\n    peer_conf = c->data;\n\n    if (peer_conf->state != NGX_TCP_CHECK_SEND_DONE) {\n\n        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {\n            goto check_recv_fail;\n        }\n\n        return;\n    }\n\n    ctx = peer_conf->check_data;\n\n    if (ctx->recv.start == NULL) {\n        /* 2048, is it enough? */\n        ctx->recv.start = ngx_palloc(c->pool, ngx_pagesize/2);\n        if (ctx->recv.start == NULL) {\n            goto check_recv_fail;\n        }\n\n        ctx->recv.last = ctx->recv.pos = ctx->recv.start;\n        ctx->recv.end = ctx->recv.start + ngx_pagesize/2;\n    }\n\n    while (1) {\n        n = ctx->recv.end - ctx->recv.last;\n        /* Not enough buffer? Enlarge twice */\n        if (n == 0) {\n            size = ctx->recv.end - ctx->recv.start;\n            new_buf = ngx_palloc(c->pool, size * 2);\n            if (new_buf == NULL) {\n                goto check_recv_fail;\n            }\n\n            ngx_memcpy(new_buf, ctx->recv.start, size);\n\n            ctx->recv.pos = ctx->recv.start = new_buf;\n            ctx->recv.last = new_buf + size;\n            ctx->recv.end = new_buf + size * 2;\n\n            n = ctx->recv.end - ctx->recv.last;\n        }\n\n        size = c->recv(c, ctx->recv.last, n);\n\n#if (NGX_DEBUG)\n        ngx_err_t                      err;\n\n        err = (size >= 0) ? 0 : ngx_socket_errno;\n        ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, err, \n                       \"tcp check recv size: %d, peer: %V\",\n                       size, &peer_conf->peer->name);\n#endif\n\n        if (size > 0) {\n            ctx->recv.last += size;\n            continue;\n\n        } else if (size == 0 || size == NGX_AGAIN) {\n            break;\n\n        } else {\n            c->error = 1;\n            goto check_recv_fail;\n        }\n    }\n\n    rc = peer_conf->parse(peer_conf); \n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, c->log, 0, \n                   \"tcp check parse rc: %d, peer: %V\",\n                   rc, &peer_conf->peer->name);\n\n    switch (rc) {\n\n    case NGX_AGAIN:\n        return;\n\n    case NGX_ERROR:\n        ngx_log_error(NGX_LOG_ERR, event->log, 0,\n                      \"check protocol %s error with peer: %V \", \n                      peer_conf->conf->check_type_conf->name,\n                      &peer_conf->peer->name);\n\n        ngx_tcp_check_status_update(peer_conf, 0);\n        break;\n\n    case NGX_OK:\n        /* pass through */\n\n    default:\n        ngx_tcp_check_status_update(peer_conf, 1);\n    }\n\n    peer_conf->state = NGX_TCP_CHECK_RECV_DONE;\n    ngx_tcp_check_clean_event(peer_conf);\n\n    return;\n\ncheck_recv_fail:\n\n    ngx_tcp_check_status_update(peer_conf, 0);\n    ngx_tcp_check_clean_event(peer_conf);\n\n    return;\n}\n\n\nstatic void \nngx_tcp_check_connect_handler(ngx_event_t *event) \n{\n    ngx_int_t                      rc;\n    ngx_connection_t              *c;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_upstream_srv_conf_t   *uscf;\n\n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n\n    peer_conf = event->data;\n    uscf = peer_conf->conf;\n\n    ngx_memzero(&peer_conf->pc, sizeof(ngx_peer_connection_t));\n\n    peer_conf->pc.sockaddr = peer_conf->peer->sockaddr;\n    peer_conf->pc.socklen = peer_conf->peer->socklen;\n    peer_conf->pc.name = &peer_conf->peer->name;\n\n    peer_conf->pc.get = ngx_event_get_peer;\n    peer_conf->pc.log = event->log;\n    peer_conf->pc.log_error = NGX_ERROR_ERR; \n\n    peer_conf->pc.cached = 0;\n    peer_conf->pc.connection = NULL;\n\n    rc = ngx_event_connect_peer(&peer_conf->pc);\n\n    if (rc == NGX_ERROR || rc == NGX_DECLINED) {\n        ngx_tcp_check_status_update(peer_conf, 0);\n        return;\n    }\n\n    /* NGX_OK or NGX_AGAIN */\n    c = peer_conf->pc.connection;\n    c->data = peer_conf;\n    c->log = peer_conf->pc.log;\n    c->sendfile = 0;\n    c->read->log = c->log;\n    c->write->log = c->log;\n    c->pool = peer_conf->pool;\n\n    peer_conf->state = NGX_TCP_CHECK_CONNECT_DONE;\n\n    c->write->handler = peer_conf->send_handler;\n    c->read->handler = peer_conf->recv_handler;\n\n    ngx_add_timer(&peer_conf->check_timeout_ev, uscf->check_timeout);\n\n    /* The kqueue's loop interface need it. */\n    if (rc == NGX_OK) {\n        c->write->handler(c->write);\n    }\n}\n\n\nstatic void \nngx_tcp_check_begin_handler(ngx_event_t *event) \n{\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_upstream_srv_conf_t   *uscf;\n\n    if (ngx_tcp_check_need_exit()) {\n        return;\n    }\n\n    peer_conf = event->data;\n    uscf = peer_conf->conf;\n\n    ngx_add_timer(event, uscf->check_interval/2);\n\n    /* This process are processing the event now. */\n    if (peer_conf->shm->owner == ngx_pid) {\n        return;\n    }\n\n    ngx_log_debug4(NGX_LOG_DEBUG_TCP, event->log, 0, \n                   \"tcp check begin handler index:%ud, owner: %d, \"\n                   \"ngx_pid: %ud, time:%d\", \n                   peer_conf->index, peer_conf->shm->owner, ngx_pid, \n                   (ngx_current_msec - peer_conf->shm->access_time));\n\n    ngx_spinlock(&peer_conf->shm->lock, ngx_pid, 1024);\n\n    if (((ngx_current_msec - peer_conf->shm->access_time) >= uscf->check_interval) && \n            peer_conf->shm->owner == NGX_INVALID_PID)\n    {\n        peer_conf->shm->owner = ngx_pid;\n    }\n\n    ngx_spinlock_unlock(&peer_conf->shm->lock);\n\n    if (peer_conf->shm->owner == ngx_pid) {\n        ngx_tcp_check_connect_handler(event);\n    }\n}\n\n\nstatic void \nngx_tcp_upstream_init_check_conf(ngx_tcp_upstream_srv_conf_t *uscf) \n{\n    check_conf_t *cf;\n\n    cf = uscf->check_type_conf;\n\n    if (uscf->send.len == 0) {\n        uscf->send.data = cf->default_send.data;\n        uscf->send.len = cf->default_send.len;\n    }\n\n    if (uscf->code.status_alive == 0) { \n        uscf->code.status_alive = cf->default_status_alive;\n    }\n}\n\n\nngx_int_t \nngx_tcp_upstream_init_main_check_conf(ngx_conf_t *cf, void*conf) \n{\n    ngx_tcp_upstream_main_conf_t   *umcf = conf;\n\n    ngx_uint_t                      i, shm_size, need_check;\n    ngx_str_t                      *shm_name;\n    ngx_shm_zone_t                 *shm_zone;\n    ngx_tcp_upstream_srv_conf_t   **uscfp;\n\n    uscfp = umcf->upstreams.elts;\n\n    need_check = 0;\n    for (i = 0; i < umcf->upstreams.nelts; i++) {\n        if (uscfp[i]->check_interval) {\n\n            ngx_tcp_upstream_init_check_conf(uscfp[i]);\n            \n            need_check = 1;\n        }\n    }\n\n    if (need_check) {\n        ngx_tcp_check_shm_generation++;\n\n        shm_name = &umcf->peers_conf->check_shm_name;\n\n        if (ngx_tcp_check_get_shm_name(shm_name, cf->pool) == NGX_ERROR) {\n            return NGX_ERROR;\n        }\n\n        /*the default check shmare memory size*/\n        shm_size = (umcf->upstreams.nelts + 1 )* ngx_pagesize;\n\n        shm_size = shm_size < umcf->check_shm_size \n                   ? umcf->check_shm_size : shm_size;\n\n        shm_zone = ngx_shared_memory_add(cf, shm_name, shm_size,\n                                         &ngx_tcp_upstream_module);\n\n        ngx_log_debug2(NGX_LOG_DEBUG_TCP, cf->log, 0,\n                       \"[tcp_upstream] upsteam:%V, shm_zone size:%ui\",\n                       shm_name, shm_size);\n\n        shm_zone->data = umcf->peers_conf;\n        check_peers_ctx = umcf->peers_conf;\n\n        shm_zone->init = ngx_tcp_upstream_check_init_shm_zone;\n\n    } else {\n        check_peers_ctx = NULL;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_check_init_process(ngx_cycle_t *cycle) \n{\n    ngx_str_t                      shm_name;\n    ngx_uint_t                     i;\n    ngx_msec_t                     t, delay;\n    check_conf_t                  *cf;\n    ngx_shm_zone_t                *shm_zone;\n    ngx_tcp_check_peer_shm_t      *peer_shm;\n    ngx_tcp_check_peers_shm_t     *peers_shm;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_check_peers_conf_t    *peers_conf;\n    ngx_tcp_upstream_srv_conf_t   *uscf;\n\n    if (ngx_tcp_check_get_shm_name(&shm_name, cycle->pool) == NGX_ERROR) {\n        return NGX_ERROR;\n    }\n\n    shm_zone = ngx_shared_memory_find(cycle, &shm_name, \n                                      &ngx_tcp_upstream_module);\n\n    if (shm_zone == NULL || shm_zone->data == NULL) {\n        return NGX_OK;\n    }\n\n    peers_conf = shm_zone->data;\n    peers_shm = peers_conf->peers_shm;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, cycle->log, 0, \n                   \"tcp check upstream init_process, shm_name: %V, \"\n                   \"peer number: %ud\",\n                   &shm_name, peers_conf->peers.nelts);\n\n    srandom(ngx_pid);\n\n    peer_conf = peers_conf->peers.elts;\n    peer_shm = peers_shm->peers;\n\n    for (i = 0; i < peers_conf->peers.nelts; i++) {\n        peer_conf[i].shm = &peer_shm[i];\n\n        peer_conf[i].check_ev.handler = ngx_tcp_check_begin_handler;\n        peer_conf[i].check_ev.log = cycle->log;\n        peer_conf[i].check_ev.data = &peer_conf[i];\n        peer_conf[i].check_ev.timer_set = 0;\n\n        peer_conf[i].check_timeout_ev.handler = ngx_tcp_check_timeout_handler;\n        peer_conf[i].check_timeout_ev.log = cycle->log;\n        peer_conf[i].check_timeout_ev.data = &peer_conf[i];\n        peer_conf[i].check_timeout_ev.timer_set = 0;\n\n        uscf = peer_conf[i].conf;\n        cf = uscf->check_type_conf;\n\n        if (cf->need_pool) {\n            peer_conf[i].pool = ngx_create_pool(ngx_pagesize, cycle->log);\n            if (peer_conf[i].pool == NULL) {\n                return NGX_ERROR;\n            }\n        }\n\n        peer_conf[i].send_handler = cf->send_handler;\n        peer_conf[i].recv_handler = cf->recv_handler;\n\n        peer_conf[i].init = cf->init;\n        peer_conf[i].parse = cf->parse;\n        peer_conf[i].reinit = cf->reinit;\n\n        /* Default delay interval is 1 second. \n           I don't want to trigger the check event too close. */\n        delay = uscf->check_interval > 1000 ? uscf->check_interval : 1000;\n        t = ngx_random() % delay;\n\n        ngx_add_timer(&peer_conf[i].check_ev, t);\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t \nngx_tcp_upstream_check_status_handler(ngx_http_request_t *r) \n{\n    size_t                         buffer_size;\n    ngx_buf_t                     *b;\n    ngx_str_t                      shm_name;\n    ngx_int_t                      rc;\n    ngx_uint_t                     i;\n    ngx_chain_t                    out;\n    ngx_shm_zone_t                *shm_zone;\n    ngx_tcp_check_peer_shm_t      *peer_shm;\n    ngx_tcp_check_peers_shm_t     *peers_shm;\n    ngx_tcp_check_peer_conf_t     *peer_conf;\n    ngx_tcp_check_peers_conf_t    *peers_conf;\n\n\n    if (r->method != NGX_HTTP_GET && r->method != NGX_HTTP_HEAD) {\n        return NGX_HTTP_NOT_ALLOWED;\n    }\n\n    rc = ngx_http_discard_request_body(r);\n\n    if (rc != NGX_OK) {\n        return rc;\n    }\n\n    r->headers_out.content_type.len = sizeof(\"text/html; charset=utf-8\") - 1;\n    r->headers_out.content_type.data = (u_char *) \"text/html; charset=utf-8\";\n\n    if (r->method == NGX_HTTP_HEAD) {\n        r->headers_out.status = NGX_HTTP_OK;\n\n        rc = ngx_http_send_header(r);\n\n        if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n            return rc;\n        }\n    }\n\n    if (ngx_tcp_check_get_shm_name(&shm_name, r->pool) == NGX_ERROR) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    shm_zone = ngx_shared_memory_find((ngx_cycle_t *)ngx_cycle, &shm_name, \n            &ngx_tcp_upstream_module);\n\n    if (shm_zone == NULL || shm_zone->data == NULL) {\n\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"[tcp upstream check] can not find the \"\n                      \"shared memory zone \\\"%V\\\" \", &shm_name);\n\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    peers_conf = shm_zone->data;\n    peers_shm = peers_conf->peers_shm;\n\n    peer_conf = peers_conf->peers.elts;\n    peer_shm = peers_shm->peers;\n\n    /* 1/4 pagesize for each record */\n    buffer_size = peers_conf->peers.nelts * ngx_pagesize / 4;\n    buffer_size = ngx_align(buffer_size, ngx_pagesize) + ngx_pagesize;\n\n    b = ngx_create_temp_buf(r->pool, buffer_size);\n    if (b == NULL) {\n        return NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    out.buf = b;\n    out.next = NULL;\n\n    b->last = ngx_sprintf(b->last, \n            \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\n\"\n            \"\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\\n\"\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\\n\"\n            \"<head>\\n\"\n            \"  <title>Nginx tcp upstream check status</title>\\n\"\n            \"</head>\\n\"\n            \"<body>\\n\"\n            \"<h1>Nginx tcp upstream check status</h1>\\n\"\n            \"<h2>Check upstream server number: %ui, shm_name: %V</h2>\\n\"\n            \"<table style=\\\"background-color:white\\\" cellspacing=\\\"0\\\" cellpadding=\\\"3\\\" border=\\\"1\\\">\\n\"\n            \"  <tr bgcolor=\\\"#C0C0C0\\\">\\n\"\n            \"    <th>Index</th>\\n\"\n            \"    <th>Name</th>\\n\"\n            \"    <th>Status</th>\\n\"\n            \"    <th>Busyness</th>\\n\"\n            \"    <th>Rise counts</th>\\n\"\n            \"    <th>Fall counts</th>\\n\"\n            \"    <th>Access counts</th>\\n\"\n            \"    <th>Check type</th>\\n\"\n            \"  </tr>\\n\",\n            peers_conf->peers.nelts, &shm_name);\n\n    for (i = 0; i < peers_conf->peers.nelts; i++) {\n        b->last = ngx_sprintf(b->last, \n                \"  <tr%s>\\n\"\n                \"    <td>%ui</td>\\n\" \n                \"    <td>%V</td>\\n\" \n                \"    <td>%s</td>\\n\" \n                \"    <td>%ui</td>\\n\" \n                \"    <td>%ui</td>\\n\" \n                \"    <td>%ui</td>\\n\" \n                \"    <td>%ui</td>\\n\" \n                \"    <td>%s</td>\\n\" \n                \"  </tr>\\n\",\n                peer_shm[i].down ? \" bgcolor=\\\"#FF0000\\\"\" : \"\",\n                i, \n                &peer_conf[i].peer->name, \n                peer_shm[i].down ? \"down\" : \"up\",\n                peer_shm[i].busyness,\n                peer_shm[i].rise_count, \n                peer_shm[i].fall_count, \n                peer_shm[i].access_count, \n                peer_conf[i].conf->check_type_conf->name);\n    }\n\n    b->last = ngx_sprintf(b->last, \n            \"</table>\\n\"\n            \"</body>\\n\"\n            \"</html>\\n\");\n\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = b->last - b->pos;\n\n    b->last_buf = 1;\n\n    rc = ngx_http_send_header(r);\n\n    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n        return rc;\n    }\n\n    return ngx_http_output_filter(r, &out);\n}\n\n\nstatic char *\nngx_tcp_upstream_check_status_set_status(ngx_conf_t *cf, \n    ngx_command_t *cmd, void *conf) \n{\n    ngx_http_core_loc_conf_t                *clcf;\n\n    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n\n    ngx_conf_deprecated(cf, &ngx_conf_deprecated_check_status, NULL);\n\n    clcf->handler = ngx_tcp_upstream_check_status_handler;\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_tcp_upstream_check_status(ngx_conf_t *cf, \n    ngx_command_t *cmd, void *conf) \n{\n    ngx_http_core_loc_conf_t                *clcf;\n\n    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);\n\n    clcf->handler = ngx_tcp_upstream_check_status_handler;\n\n    return NGX_CONF_OK;\n}\n"
        },
        {
          "name": "ngx_tcp_upstream_check.h",
          "type": "blob",
          "size": 5.076171875,
          "content": "#ifndef _NGX_TCP_UPSTREAM_CHECK_H_INCLUDED_\n#define _NGX_TCP_UPSTREAM_CHECK_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_event.h>\n#include <ngx_event_connect.h>\n#include <ngx_event_pipe.h>\n#include <ngx_tcp.h>\n\n#include <http_request_parser.h>\n#include <http_response_parser.h>\n#include <smtp_response_parser.h>\n\n\ntypedef struct {\n    u_char                 major;\n    u_char                 minor;\n} ssl_protocol_version_t;\n\ntypedef struct {\n    u_char                 msg_type;\n    ssl_protocol_version_t version;\n    uint16_t               length;\n\n    u_char                 handshake_type;\n    u_char                 handshake_length[3];\n    ssl_protocol_version_t hello_version;\n\n    time_t                 time;\n    u_char                 random[28];\n\n    u_char                 others[0];\n} __attribute__((packed)) server_ssl_hello_t;\n\ntypedef struct {\n    u_char                 packet_length[3];\n    u_char                 packet_number;\n\n    u_char                 protocol_version;\n    u_char                 others[0];\n} __attribute__((packed)) mysql_handshake_init_t;\n\ntypedef struct {\n    ngx_buf_t              send;\n    ngx_buf_t              recv;\n\n    void                  *parser;\n} ngx_tcp_check_ctx;\n\n/*state*/\n#define NGX_TCP_CHECK_CONNECT_DONE     0x0001\n#define NGX_TCP_CHECK_SEND_DONE        0x0002\n#define NGX_TCP_CHECK_RECV_DONE        0x0004\n#define NGX_TCP_CHECK_ALL_DONE         0x0008\n\ntypedef struct {\n    ngx_pid_t              owner;\n\n    ngx_msec_t             access_time;\n\n    ngx_uint_t             fall_count;\n    ngx_uint_t             rise_count;\n\n    ngx_atomic_t           lock;\n    ngx_atomic_t           busyness;\n    ngx_atomic_t           down;\n\n    ngx_uint_t             access_count;\n} ngx_tcp_check_peer_shm_t;\n\ntypedef struct {\n    ngx_uint_t             generation;\n\n    ngx_uint_t             state;\n    ngx_atomic_t           lock;\n\n    /*store the ngx_tcp_check_status_peer_t*/\n    ngx_tcp_check_peer_shm_t peers[1];\n} ngx_tcp_check_peers_shm_t;\n\ntypedef ngx_int_t (*ngx_tcp_check_packet_init_pt)\n    (ngx_tcp_check_peer_conf_t *peer_conf); \ntypedef ngx_int_t (*ngx_tcp_check_packet_parse_pt)\n    (ngx_tcp_check_peer_conf_t *peer_conf); \ntypedef void (*ngx_tcp_check_packet_clean_pt)\n    (ngx_tcp_check_peer_conf_t *peer_conf); \n\n#define NGX_TCP_CHECK_TCP              0x0001\n#define NGX_TCP_CHECK_HTTP             0x0002\n#define NGX_TCP_CHECK_SSL_HELLO        0x0004\n#define NGX_TCP_CHECK_SMTP             0x0008\n#define NGX_TCP_CHECK_MYSQL            0x0010\n#define NGX_TCP_CHECK_POP3             0x0020\n#define NGX_TCP_CHECK_IMAP             0x0040\n\n#define NGX_CHECK_HTTP_2XX             0x0002\n#define NGX_CHECK_HTTP_3XX             0x0004\n#define NGX_CHECK_HTTP_4XX             0x0008\n#define NGX_CHECK_HTTP_5XX             0x0010\n#define NGX_CHECK_HTTP_6XX             0x0020\n#define NGX_CHECK_HTTP_ERR             0x8000\n\n#define NGX_CHECK_SMTP_2XX             0x0002\n#define NGX_CHECK_SMTP_3XX             0x0004\n#define NGX_CHECK_SMTP_4XX             0x0008\n#define NGX_CHECK_SMTP_5XX             0x0010\n#define NGX_CHECK_SMTP_6XX             0x0020\n#define NGX_CHECK_SMTP_ERR             0x8000\n\n\nstruct check_conf_s {\n    ngx_uint_t                      type;\n\n    char                            *name;\n\n    ngx_str_t                        default_send;\n    \n    /* HTTP */\n    ngx_uint_t                       default_status_alive;\n\n    ngx_event_handler_pt             send_handler;\n    ngx_event_handler_pt             recv_handler;\n\n    ngx_tcp_check_packet_init_pt     init;\n    ngx_tcp_check_packet_parse_pt    parse;\n    ngx_tcp_check_packet_clean_pt    reinit;\n\n    unsigned need_pool;\n};\n\nstruct ngx_tcp_check_peer_conf_s {\n\n    ngx_flag_t                       state;\n    ngx_pool_t                      *pool;\n    ngx_uint_t                       index;\n    ngx_uint_t                       max_busy;\n    ngx_tcp_upstream_srv_conf_t     *conf;\n    ngx_peer_addr_t                 *peer;\n    ngx_event_t                      check_ev;\n    ngx_event_t                      check_timeout_ev;\n    ngx_peer_connection_t            pc;\n\n    void *                           check_data;\n    ngx_event_handler_pt             send_handler;\n    ngx_event_handler_pt             recv_handler;\n\n    ngx_tcp_check_packet_init_pt     init;\n    ngx_tcp_check_packet_parse_pt    parse;\n    ngx_tcp_check_packet_clean_pt    reinit;\n\n    ngx_tcp_check_peer_shm_t         *shm;\n};\n\nstruct ngx_tcp_check_peers_conf_s {\n    ngx_str_t                        check_shm_name;\n    ngx_array_t                      peers;\n\n    ngx_tcp_check_peers_shm_t       *peers_shm;\n};\n\n\nngx_int_t ngx_tcp_upstream_init_main_check_conf(ngx_conf_t *cf, void*conf);\n\nngx_uint_t ngx_tcp_check_add_peer(ngx_conf_t *cf,\n    ngx_tcp_upstream_srv_conf_t *uscf,\n    ngx_peer_addr_t *peer, ngx_uint_t max_busy);\n\nngx_uint_t ngx_tcp_check_peer_down(ngx_uint_t index);\n\nngx_uint_t ngx_tcp_check_get_peer_busyness(ngx_uint_t index);\n\nvoid ngx_tcp_check_get_peer(ngx_uint_t index);\nvoid ngx_tcp_check_free_peer(ngx_uint_t index);\n\ncheck_conf_t *ngx_tcp_get_check_type_conf(ngx_str_t *str);\n\n#endif //_NGX_TCP_UPSTREAM_CHECK_H_INCLUDED_\n\n"
        },
        {
          "name": "ngx_tcp_upstream_round_robin.c",
          "type": "blob",
          "size": 23.060546875,
          "content": "\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_tcp.h>\n\n\nstatic ngx_int_t ngx_tcp_upstream_cmp_servers(const void *one, const void *two);\nstatic ngx_uint_t ngx_tcp_upstream_get_peer(ngx_tcp_upstream_rr_peers_t *peers);\n\n\nngx_int_t\nngx_tcp_upstream_init_round_robin(ngx_conf_t *cf,\n    ngx_tcp_upstream_srv_conf_t *us)\n{\n    ngx_url_t                      u;\n    ngx_uint_t                     i, j, n;\n    ngx_tcp_upstream_server_t     *server;\n    ngx_tcp_upstream_rr_peers_t   *peers, *backup;\n\n    us->peer.init = ngx_tcp_upstream_init_round_robin_peer;\n\n    if (us->servers) {\n        server = us->servers->elts;\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            if (server[i].backup) {\n                continue;\n            }\n\n            n += server[i].naddrs;\n        }\n\n        peers = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_rr_peers_t)\n                              + sizeof(ngx_tcp_upstream_rr_peer_t) * (n - 1));\n        if (peers == NULL) {\n            return NGX_ERROR;\n        }\n\n        peers->single = (n == 1);\n        peers->number = n;\n        peers->name = &us->host;\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            for (j = 0; j < server[i].naddrs; j++) {\n                if (server[i].backup) {\n                    continue;\n                }\n\n                peers->peer[n].sockaddr = server[i].addrs[j].sockaddr;\n                peers->peer[n].socklen = server[i].addrs[j].socklen;\n                peers->peer[n].name = server[i].addrs[j].name;\n                peers->peer[n].max_fails = server[i].max_fails;\n                peers->peer[n].fail_timeout = server[i].fail_timeout;\n                peers->peer[n].down = server[i].down;\n                peers->peer[n].weight = server[i].down ? 0 : server[i].weight;\n                peers->peer[n].current_weight = peers->peer[n].weight;\n\n                if (!server[i].down && us->check_interval) {\n                    peers->peer[n].check_index = \n                        ngx_tcp_check_add_peer(cf, us, &server[i].addrs[j],\n                                               server[i].max_busy);\n\n                    if (peers->peer[n].check_index\n                                     == (ngx_uint_t) NGX_INVALID_CHECK_INDEX) {\n                        return NGX_ERROR;\n                    }\n                }\n                else {\n                    peers->peer[n].check_index\n                                       = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;\n                }\n\n                n++;\n            }\n        }\n\n        us->peer.data = peers;\n\n        ngx_sort(&peers->peer[0], (size_t) n,\n                 sizeof(ngx_tcp_upstream_rr_peer_t),\n                 ngx_tcp_upstream_cmp_servers);\n\n        /* backup servers */\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            if (!server[i].backup) {\n                continue;\n            }\n\n            n += server[i].naddrs;\n        }\n\n        if (n == 0) {\n            return NGX_OK;\n        }\n\n        backup = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_rr_peers_t)\n                              + sizeof(ngx_tcp_upstream_rr_peer_t) * (n - 1));\n        if (backup == NULL) {\n            return NGX_ERROR;\n        }\n\n        peers->single = 0;\n        backup->single = 0;\n        backup->number = n;\n        backup->name = &us->host;\n\n        n = 0;\n\n        for (i = 0; i < us->servers->nelts; i++) {\n            for (j = 0; j < server[i].naddrs; j++) {\n                if (!server[i].backup) {\n                    continue;\n                }\n\n                backup->peer[n].sockaddr = server[i].addrs[j].sockaddr;\n                backup->peer[n].socklen = server[i].addrs[j].socklen;\n                backup->peer[n].name = server[i].addrs[j].name;\n                backup->peer[n].weight = server[i].weight;\n                backup->peer[n].current_weight = server[i].weight;\n                backup->peer[n].max_fails = server[i].max_fails;\n                backup->peer[n].fail_timeout = server[i].fail_timeout;\n                backup->peer[n].down = server[i].down;\n                if (!server[i].down && us->check_interval) {\n                    backup->peer[n].check_index = \n                        ngx_tcp_check_add_peer(cf, us, &server[i].addrs[j],\n                                               server[i].max_busy);\n\n                    if (backup->peer[n].check_index\n                                     == (ngx_uint_t) NGX_INVALID_CHECK_INDEX) {\n                        return NGX_ERROR;\n                    }\n                }\n                else {\n                    backup->peer[n].check_index\n                                     = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;\n                }\n\n                n++;\n            }\n        }\n\n        peers->next = backup;\n\n        ngx_sort(&backup->peer[0], (size_t) n,\n                 sizeof(ngx_tcp_upstream_rr_peer_t),\n                 ngx_tcp_upstream_cmp_servers);\n\n        return NGX_OK;\n    }\n\n\n    /* an upstream implicitly defined by proxy_pass, etc. */\n \n#if (nginx_version) >= 1003011\n    if (us->port == 0) {\n#else\n    if (us->port == 0 && us->default_port == 0) {\n#endif\n        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                      \"no port in upstream \\\"%V\\\" in %s:%ui\",\n                      &us->host, us->file_name, us->line);\n        return NGX_ERROR;\n    }\n\n    ngx_memzero(&u, sizeof(ngx_url_t));\n\n    u.host = us->host;\n#if (nginx_version) >= 1003011\n    u.port = us->port;\n#else\n    u.port = (in_port_t) (us->port ? us->port : us->default_port);\n#endif\n\n    if (ngx_inet_resolve_host(cf->pool, &u) != NGX_OK) {\n        if (u.err) {\n            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                          \"%s in upstream \\\"%V\\\" in %s:%ui\",\n                          u.err, &us->host, us->file_name, us->line);\n        }\n\n        return NGX_ERROR;\n    }\n\n    n = u.naddrs;\n\n    peers = ngx_pcalloc(cf->pool, sizeof(ngx_tcp_upstream_rr_peers_t)\n                              + sizeof(ngx_tcp_upstream_rr_peer_t) * (n - 1));\n    if (peers == NULL) {\n        return NGX_ERROR;\n    }\n\n    peers->single = (n == 1);\n    peers->number = n;\n    peers->name = &us->host;\n\n    for (i = 0; i < u.naddrs; i++) {\n        peers->peer[i].sockaddr = u.addrs[i].sockaddr;\n        peers->peer[i].socklen = u.addrs[i].socklen;\n        peers->peer[i].name = u.addrs[i].name;\n        peers->peer[i].weight = 1;\n        peers->peer[i].current_weight = 1;\n        peers->peer[i].max_fails = 1;\n        peers->peer[i].fail_timeout = 10;\n        peers->peer[i].check_index = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;\n    }\n\n    us->peer.data = peers;\n\n    /* implicitly defined upstream has no backup servers */\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_tcp_upstream_cmp_servers(const void *one, const void *two)\n{\n    ngx_tcp_upstream_rr_peer_t  *first, *second;\n\n    first = (ngx_tcp_upstream_rr_peer_t *) one;\n    second = (ngx_tcp_upstream_rr_peer_t *) two;\n\n    return (first->weight < second->weight);\n}\n\n\nngx_int_t\nngx_tcp_upstream_init_round_robin_peer(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_srv_conf_t *us)\n{\n    ngx_uint_t                         n;\n    ngx_tcp_upstream_rr_peer_data_t  *rrp;\n\n    rrp = s->upstream->peer.data;\n\n    if (rrp == NULL) {\n        rrp = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_rr_peer_data_t));\n        if (rrp == NULL) {\n            return NGX_ERROR;\n        }\n\n        s->upstream->peer.data = rrp;\n    }\n\n    rrp->peers = us->peer.data;\n    rrp->current = 0;\n\n    if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {\n        rrp->tried = &rrp->data;\n        rrp->data = 0;\n\n    } else {\n        n = (rrp->peers->number + (8 * sizeof(uintptr_t) - 1))\n                / (8 * sizeof(uintptr_t));\n\n        rrp->tried = ngx_pcalloc(s->pool, n * sizeof(uintptr_t));\n        if (rrp->tried == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    s->upstream->peer.get = ngx_tcp_upstream_get_round_robin_peer;\n    s->upstream->peer.free = ngx_tcp_upstream_free_round_robin_peer;\n    s->upstream->peer.tries = rrp->peers->number;\n    s->upstream->peer.check_index = NGX_INVALID_CHECK_INDEX;\n    s->upstream->peer.name = NULL;\n#if (NGX_TCP_SSL)\n    s->upstream->peer.set_session =\n                               ngx_tcp_upstream_set_round_robin_peer_session;\n    s->upstream->peer.save_session =\n                               ngx_tcp_upstream_save_round_robin_peer_session;\n#endif\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_tcp_upstream_create_round_robin_peer(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_resolved_t *ur)\n{\n    u_char                            *p;\n    size_t                             len;\n#if (nginx_version) >= 1005008\n    socklen_t                          socklen;\n    struct sockaddr                   *sockaddr;\n#else\n    struct sockaddr_in                *sin;\n#endif\n    ngx_uint_t                         i, n;\n    ngx_tcp_upstream_rr_peers_t       *peers;\n    ngx_tcp_upstream_rr_peer_data_t   *rrp;\n\n    rrp = s->upstream->peer.data;\n\n    if (rrp == NULL) {\n        rrp = ngx_palloc(s->pool, sizeof(ngx_tcp_upstream_rr_peer_data_t));\n        if (rrp == NULL) {\n            return NGX_ERROR;\n        }\n\n        s->upstream->peer.data = rrp;\n    }\n\n    peers = ngx_pcalloc(s->pool, sizeof(ngx_tcp_upstream_rr_peers_t)\n                     + sizeof(ngx_tcp_upstream_rr_peer_t) * (ur->naddrs - 1));\n    if (peers == NULL) {\n        return NGX_ERROR;\n    }\n\n    peers->single = (ur->naddrs == 1);\n    peers->number = ur->naddrs;\n    peers->name = &ur->host;\n\n    if (ur->sockaddr) {\n        peers->peer[0].sockaddr = ur->sockaddr;\n        peers->peer[0].socklen = ur->socklen;\n        peers->peer[0].name = ur->host;\n        peers->peer[0].weight = 1;\n        peers->peer[0].current_weight = 1;\n        peers->peer[0].max_fails = 1;\n        peers->peer[0].fail_timeout = 10;\n        peers->peer[0].check_index = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;\n\n    } else {\n\n        for (i = 0; i < ur->naddrs; i++) {\n\n#if (nginx_version) >= 1005008\n            socklen = ur->addrs[i].socklen;\n\n            sockaddr = ngx_palloc(s->pool, socklen);\n            if (sockaddr == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sockaddr, ur->addrs[i].sockaddr, socklen);\n\n            switch (sockaddr->sa_family) {\n#if (NGX_HAVE_INET6)\n            case AF_INET6:\n                ((struct sockaddr_in6 *) sockaddr)->sin6_port = htons(ur->port);\n                break;\n#endif\n            default: /* AF_INET */\n                ((struct sockaddr_in *) sockaddr)->sin_port = htons(ur->port);\n            }\n\n            p = ngx_pnalloc(s->pool, NGX_SOCKADDR_STRLEN);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            len = ngx_sock_ntop(sockaddr, socklen, p, NGX_SOCKADDR_STRLEN, 1);\n\n            peers->peer[i].sockaddr = sockaddr;\n            peers->peer[i].socklen = socklen;\n#else\n            len = NGX_INET_ADDRSTRLEN + sizeof(\":65536\") - 1;\n\n            p = ngx_pnalloc(s->pool, len);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            len = ngx_inet_ntop(AF_INET, &ur->addrs[i], p, NGX_INET_ADDRSTRLEN);\n            len = ngx_sprintf(&p[len], \":%d\", ur->port) - p;\n\n            sin = ngx_pcalloc(s->pool, sizeof(struct sockaddr_in));\n            if (sin == NULL) {\n                return NGX_ERROR;\n            }\n\n            sin->sin_family = AF_INET;\n            sin->sin_port = htons(ur->port);\n            sin->sin_addr.s_addr = ur->addrs[i];\n\n            peers->peer[i].sockaddr = (struct sockaddr *) sin;\n            peers->peer[i].socklen = sizeof(struct sockaddr_in);\n#endif\n            peers->peer[i].name.len = len;\n            peers->peer[i].name.data = p;\n            peers->peer[i].weight = 1;\n            peers->peer[i].current_weight = 1;\n            peers->peer[i].max_fails = 1;\n            peers->peer[i].fail_timeout = 10;\n            peers->peer[i].check_index = (ngx_uint_t) NGX_INVALID_CHECK_INDEX;\n        }\n    }\n\n    rrp->peers = peers;\n    rrp->current = 0;\n\n    if (rrp->peers->number <= 8 * sizeof(uintptr_t)) {\n        rrp->tried = &rrp->data;\n        rrp->data = 0;\n\n    } else {\n        n = (rrp->peers->number + (8 * sizeof(uintptr_t) - 1))\n                / (8 * sizeof(uintptr_t));\n\n        rrp->tried = ngx_pcalloc(s->pool, n * sizeof(uintptr_t));\n        if (rrp->tried == NULL) {\n            return NGX_ERROR;\n        }\n    }\n\n    s->upstream->peer.get = ngx_tcp_upstream_get_round_robin_peer;\n    s->upstream->peer.free = ngx_tcp_upstream_free_round_robin_peer;\n    s->upstream->peer.tries = rrp->peers->number;\n#if (NGX_TCP_SSL)\n    s->upstream->peer.set_session =\n                               ngx_tcp_upstream_set_round_robin_peer_session;\n    s->upstream->peer.save_session =\n                               ngx_tcp_upstream_save_round_robin_peer_session;\n#endif\n\n    return NGX_OK;\n}\n\n\nngx_int_t\nngx_tcp_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)\n{\n    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;\n\n    time_t                         now;\n    uintptr_t                      m;\n    ngx_int_t                      rc;\n    ngx_uint_t                     i, n;\n    ngx_connection_t              *c;\n    ngx_tcp_upstream_rr_peer_t    *peer;\n    ngx_tcp_upstream_rr_peers_t   *peers;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                   \"get rr peer, try: %ui\", pc->tries);\n\n    now = ngx_time();\n\n    /* ngx_lock_mutex(rrp->peers->mutex); */\n\n    if (rrp->peers->last_cached) {\n\n        /* cached connection */\n\n        c = rrp->peers->cached[rrp->peers->last_cached];\n        rrp->peers->last_cached--;\n\n        /* ngx_unlock_mutex(ppr->peers->mutex); */\n\n#if (NGX_THREADS)\n        c->read->lock = c->read->own_lock;\n        c->write->lock = c->write->own_lock;\n#endif\n\n        pc->connection = c;\n        pc->cached = 1;\n\n        return NGX_OK;\n    }\n\n    pc->cached = 0;\n    pc->connection = NULL;\n\n    if (rrp->peers->single) {\n        peer = &rrp->peers->peer[0];\n        if (ngx_tcp_check_peer_down(peer->check_index)) {\n            return NGX_BUSY;\n        }\n    } else {\n\n        /* there are several peers */\n\n        if (pc->tries == rrp->peers->number) {\n\n            /* it's a first try - get a current peer */\n\n            i = pc->tries;\n\n            for ( ;; ) {\n                rrp->current = ngx_tcp_upstream_get_peer(rrp->peers);\n\n                ngx_log_debug3(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                               \"get rr peer, current: %ui %i, tries: %ui\",\n                               rrp->current,\n                               rrp->peers->peer[rrp->current].current_weight,\n                               pc->tries);\n\n                n = rrp->current / (8 * sizeof(uintptr_t));\n                m = (uintptr_t) 1 << rrp->current % (8 * sizeof(uintptr_t));\n\n                if (!(rrp->tried[n] & m)) {\n                    peer = &rrp->peers->peer[rrp->current];\n\n                    if (!peer->down) {\n\n                        ngx_log_debug1(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                                \"get rr peer, down: %ui\", \n                                ngx_tcp_check_peer_down(peer->check_index));\n\n                        if (!ngx_tcp_check_peer_down(peer->check_index)) {\n                            if (peer->max_fails == 0\n                                    || peer->fails < peer->max_fails)\n                            {\n                                break;\n                            }\n\n                            if (now - peer->accessed > peer->fail_timeout) {\n                                peer->fails = 0;\n                                break;\n                            }\n                        }\n\n                        peer->current_weight = 0;\n\n                    } else {\n                        rrp->tried[n] |= m;\n                    }\n\n                    pc->tries--;\n                }\n\n                if (pc->tries == 0) {\n                    goto failed;\n                }\n\n                if (--i == 0) {\n                    ngx_log_error(NGX_LOG_ALERT, pc->log, 0,\n                                  \"round robin upstream stuck on %ui tries\",\n                                  pc->tries);\n                    goto failed;\n                }\n            }\n\n            peer->current_weight--;\n\n        } else {\n\n            i = pc->tries;\n\n            for ( ;; ) {\n                n = rrp->current / (8 * sizeof(uintptr_t));\n                m = (uintptr_t) 1 << rrp->current % (8 * sizeof(uintptr_t));\n\n                if (!(rrp->tried[n] & m)) {\n\n                    peer = &rrp->peers->peer[rrp->current];\n\n                    if (!peer->down) {\n\n                        if (!ngx_tcp_check_peer_down(peer->check_index)) {\n                            \n                            if (peer->max_fails == 0\n                                    || peer->fails < peer->max_fails)\n                            {\n                                break;\n                            }\n\n                            if (now - peer->accessed > peer->fail_timeout) {\n                                peer->fails = 0;\n                                break;\n                            }\n                        }\n\n                        peer->current_weight = 0;\n\n                    } else {\n                        rrp->tried[n] |= m;\n                    }\n\n                    pc->tries--;\n                }\n\n                rrp->current++;\n\n                if (rrp->current >= rrp->peers->number) {\n                    rrp->current = 0;\n                }\n\n                if (pc->tries == 0) {\n                    goto failed;\n                }\n\n                if (--i == 0) {\n                    ngx_log_error(NGX_LOG_ALERT, pc->log, 0,\n                                  \"round robin upstream stuck on %ui tries\",\n                                  pc->tries);\n                    goto failed;\n                }\n            }\n\n            peer->current_weight--;\n        }\n\n        rrp->tried[n] |= m;\n    }\n\n    pc->sockaddr = peer->sockaddr;\n    pc->socklen = peer->socklen;\n    pc->name = &peer->name;\n    pc->check_index = peer->check_index;\n\n    /* ngx_unlock_mutex(rrp->peers->mutex); */\n\n    if (pc->tries == 1 && rrp->peers->next) {\n        pc->tries += rrp->peers->next->number;\n\n        n = rrp->peers->next->number / (8 * sizeof(uintptr_t)) + 1;\n        for (i = 0; i < n; i++) {\n             rrp->tried[i] = 0;\n        }\n    }\n\n    return NGX_OK;\n\nfailed:\n\n    peers = rrp->peers;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_TCP, pc->log, 0, \"backup servers1\");\n\n    if (peers->next) {\n\n        /* ngx_unlock_mutex(peers->mutex); */\n\n        ngx_log_debug0(NGX_LOG_DEBUG_TCP, pc->log, 0, \"backup servers\");\n\n        rrp->peers = peers->next;\n        pc->tries = rrp->peers->number;\n\n        n = rrp->peers->number / (8 * sizeof(uintptr_t)) + 1;\n        for (i = 0; i < n; i++) {\n             rrp->tried[i] = 0;\n        }\n\n        rc = ngx_tcp_upstream_get_round_robin_peer(pc, rrp);\n\n        if (rc != NGX_BUSY) {\n            return rc;\n        }\n\n        /* ngx_lock_mutex(peers->mutex); */\n    }\n\n    /* all peers failed, mark them as live for quick recovery */\n\n    for (i = 0; i < peers->number; i++) {\n        peers->peer[i].fails = 0;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_TCP, pc->log, 0, \"backup servers2\");\n\n    /* ngx_unlock_mutex(peers->mutex); */\n\n    pc->name = peers->name;\n\n    return NGX_BUSY;\n}\n\n\nstatic ngx_uint_t\nngx_tcp_upstream_get_peer(ngx_tcp_upstream_rr_peers_t *peers)\n{\n    ngx_uint_t                    i, n;\n    ngx_tcp_upstream_rr_peer_t   *peer;\n\n    peer = &peers->peer[0];\n\n    for ( ;; ) {\n\n        for (i = 0; i < peers->number; i++) {\n\n            if (peer[i].current_weight <= 0) {\n                continue;\n            }\n\n            n = i;\n\n            while (i < peers->number - 1) {\n\n                i++;\n\n                if (peer[i].current_weight <= 0) {\n                    continue;\n                }\n\n                if (peer[n].current_weight * 1000 / peer[i].current_weight\n                    > peer[n].weight * 1000 / peer[i].weight)\n                {\n                    return n;\n                }\n\n                n = i;\n            }\n\n            if (peer[i].current_weight > 0) {\n                n = i;\n            }\n\n            return n;\n        }\n\n        for (i = 0; i < peers->number; i++) {\n            peer[i].current_weight = peer[i].weight;\n        }\n    }\n}\n\n\nvoid\nngx_tcp_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,\n    ngx_uint_t state)\n{\n    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;\n\n    time_t                       now;\n    ngx_tcp_upstream_rr_peer_t  *peer;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                   \"free rr peer %ui %ui\", pc->tries, state);\n\n    if (state == 0 && pc->tries == 0) {\n        return;\n    }\n\n    /* TODO: NGX_PEER_KEEPALIVE */\n\n    if (rrp->peers->single) {\n        pc->tries = 0;\n        return;\n    }\n\n    if (state & NGX_PEER_FAILED) {\n        now = ngx_time();\n\n        /* ngx_lock_mutex(rrp->peers->mutex); */\n        peer = &rrp->peers->peer[rrp->current];\n\n        peer->fails++;\n        peer->accessed = now;\n\n        if (peer->max_fails) {\n            peer->current_weight -= peer->weight / peer->max_fails;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                       \"free rr peer failed: %ui %i\",\n                       rrp->current, peer->current_weight);\n\n        if (peer->current_weight < 0) {\n            peer->current_weight = 0;\n        }\n\n        /* ngx_unlock_mutex(rrp->peers->mutex); */\n    }\n\n    rrp->current++;\n\n    if (rrp->current >= rrp->peers->number) {\n        rrp->current = 0;\n    }\n\n    if (pc->tries) {\n        pc->tries--;\n    }\n\n    /* ngx_unlock_mutex(rrp->peers->mutex); */\n}\n\n\n#if (NGX_TCP_SSL)\n\nngx_int_t\nngx_tcp_upstream_set_round_robin_peer_session(ngx_peer_connection_t *pc,\n    void *data)\n{\n    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;\n\n    ngx_int_t                     rc;\n    ngx_ssl_session_t            *ssl_session;\n    ngx_tcp_upstream_rr_peer_t   *peer;\n\n    peer = &rrp->peers->peer[rrp->current];\n\n    /* TODO: threads only mutex */\n    /* ngx_lock_mutex(rrp->peers->mutex); */\n\n    ssl_session = peer->ssl_session;\n\n    rc = ngx_ssl_set_session(pc->connection, ssl_session);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                   \"set session: %p:%d\",\n                   ssl_session, ssl_session ? ssl_session->references : 0);\n\n    /* ngx_unlock_mutex(rrp->peers->mutex); */\n\n    return rc;\n}\n\n\nvoid\nngx_tcp_upstream_save_round_robin_peer_session(ngx_peer_connection_t *pc,\n    void *data)\n{\n    ngx_tcp_upstream_rr_peer_data_t  *rrp = data;\n\n    ngx_ssl_session_t            *old_ssl_session, *ssl_session;\n    ngx_tcp_upstream_rr_peer_t  *peer;\n\n    ssl_session = ngx_ssl_get_session(pc->connection);\n\n    if (ssl_session == NULL) {\n        return;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                   \"save session: %p:%d\", ssl_session, ssl_session->references);\n\n    peer = &rrp->peers->peer[rrp->current];\n\n    /* TODO: threads only mutex */\n    /* ngx_lock_mutex(rrp->peers->mutex); */\n\n    old_ssl_session = peer->ssl_session;\n    peer->ssl_session = ssl_session;\n\n    /* ngx_unlock_mutex(rrp->peers->mutex); */\n\n    if (old_ssl_session) {\n\n        ngx_log_debug2(NGX_LOG_DEBUG_TCP, pc->log, 0,\n                       \"old session: %p:%d\",\n                       old_ssl_session, old_ssl_session->references);\n\n        /* TODO: may block */\n\n        ngx_ssl_free_session(old_ssl_session);\n    }\n}\n\n#endif\n"
        },
        {
          "name": "ngx_tcp_upstream_round_robin.h",
          "type": "blob",
          "size": 2.3427734375,
          "content": "\n#ifndef _NGX_TCP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_\n#define _NGX_TCP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_tcp.h>\n\n\ntypedef struct {\n    struct sockaddr                *sockaddr;\n    socklen_t                       socklen;\n    ngx_str_t                       name;\n\n    ngx_int_t                       current_weight;\n    ngx_int_t                       weight;\n\n    ngx_uint_t                      fails;\n    time_t                          accessed;\n\n    ngx_uint_t                      max_fails;\n    time_t                          fail_timeout;\n\n    ngx_uint_t                      check_index;\n\n    ngx_uint_t                      down;          /* unsigned  down:1; */\n\n#if (NGX_TCP_SSL)\n    ngx_ssl_session_t              *ssl_session;   /* local to a process */\n#endif\n} ngx_tcp_upstream_rr_peer_t;\n\n\ntypedef struct ngx_tcp_upstream_rr_peers_s  ngx_tcp_upstream_rr_peers_t;\n\nstruct ngx_tcp_upstream_rr_peers_s {\n    ngx_uint_t                      single;        /* unsigned  single:1; */\n    ngx_uint_t                      number;\n    ngx_uint_t                      last_cached;\n\n /* ngx_mutex_t                    *mutex; */\n    ngx_connection_t              **cached;\n\n    ngx_str_t                      *name;\n\n    ngx_tcp_upstream_rr_peers_t    *next;\n\n    ngx_tcp_upstream_rr_peer_t     peer[1];\n};\n\n\ntypedef struct {\n    ngx_tcp_upstream_rr_peers_t    *peers;\n    ngx_uint_t                      current;\n    uintptr_t                      *tried;\n    uintptr_t                       data;\n} ngx_tcp_upstream_rr_peer_data_t;\n\n\nngx_int_t ngx_tcp_upstream_init_round_robin(ngx_conf_t *cf,\n    ngx_tcp_upstream_srv_conf_t *us);\nngx_int_t ngx_tcp_upstream_init_round_robin_peer(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_srv_conf_t *us);\nngx_int_t ngx_tcp_upstream_create_round_robin_peer(ngx_tcp_session_t *s,\n    ngx_tcp_upstream_resolved_t *ur);\nngx_int_t ngx_tcp_upstream_get_round_robin_peer(ngx_peer_connection_t *pc,\n    void *data);\nvoid ngx_tcp_upstream_free_round_robin_peer(ngx_peer_connection_t *pc,\n    void *data, ngx_uint_t state);\n\n#if (NGX_TCP_SSL)\nngx_int_t ngx_tcp_upstream_set_round_robin_peer_session(\n    ngx_peer_connection_t *pc, void *data);\nvoid ngx_tcp_upstream_save_round_robin_peer_session(ngx_peer_connection_t *pc,\n     void *data);\n#endif\n\n\n#endif /* _NGX_TCP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_ */\n"
        },
        {
          "name": "parsers",
          "type": "tree",
          "content": null
        },
        {
          "name": "tcp.patch",
          "type": "blob",
          "size": 2.1279296875,
          "content": "From c30ac038b33e16890291f8dd5b7c8b2cc87b42a3 Mon Sep 17 00:00:00 2001\nFrom: medzeus2 <root@s53.dev>\nDate: Fri, 19 Aug 2016 18:06:53 +0800\nSubject: [PATCH] create patch fro nginx_tcp_proxy_module\n\n---\n src/core/ngx_log.c            |    2 +-\n src/core/ngx_log.h            |    3 ++-\n src/event/ngx_event_connect.h |    2 ++\n 3 files changed, 5 insertions(+), 2 deletions(-)\n\ndiff --git a/src/core/ngx_log.c b/src/core/ngx_log.c\nindex 8e9408d..b511284 100644\n--- a/src/core/ngx_log.c\n+++ b/src/core/ngx_log.c\n@@ -86,7 +86,7 @@ static ngx_str_t err_levels[] = {\n \n static const char *debug_levels[] = {\n     \"debug_core\", \"debug_alloc\", \"debug_mutex\", \"debug_event\",\n-    \"debug_http\", \"debug_mail\", \"debug_stream\"\n+    \"debug_http\", \"debug_mail\", \"debug_stream\", \"debug_tcp\"\n };\n \n \ndiff --git a/src/core/ngx_log.h b/src/core/ngx_log.h\nindex afb73bf..28b1aff 100644\n--- a/src/core/ngx_log.h\n+++ b/src/core/ngx_log.h\n@@ -30,6 +30,7 @@\n #define NGX_LOG_DEBUG_HTTP        0x100\n #define NGX_LOG_DEBUG_MAIL        0x200\n #define NGX_LOG_DEBUG_STREAM      0x400\n+#define NGX_LOG_DEBUG_TCP         0x800\n \n /*\n  * do not forget to update debug_levels[] in src/core/ngx_log.c\n@@ -37,7 +38,7 @@\n  */\n \n #define NGX_LOG_DEBUG_FIRST       NGX_LOG_DEBUG_CORE\n-#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_STREAM\n+#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_TCP\n #define NGX_LOG_DEBUG_CONNECTION  0x80000000\n #define NGX_LOG_DEBUG_ALL         0x7ffffff0\n \ndiff --git a/src/event/ngx_event_connect.h b/src/event/ngx_event_connect.h\nindex 10b72a1..384586b 100644\n--- a/src/event/ngx_event_connect.h\n+++ b/src/event/ngx_event_connect.h\n@@ -33,6 +33,7 @@ typedef void (*ngx_event_save_peer_session_pt)(ngx_peer_connection_t *pc,\n     void *data);\n #endif\n \n+#define NGX_INVALID_CHECK_INDEX (ngx_uint_t)(-1)\n \n struct ngx_peer_connection_s {\n     ngx_connection_t                *connection;\n@@ -42,6 +43,7 @@ struct ngx_peer_connection_s {\n     ngx_str_t                       *name;\n \n     ngx_uint_t                       tries;\n+    ngx_uint_t                       check_index;\n     ngx_msec_t                       start_time;\n \n     ngx_event_get_peer_pt            get;\n-- \n1.7.1\n\n"
        },
        {
          "name": "tcp_1_8.patch",
          "type": "blob",
          "size": 2.1279296875,
          "content": "From c30ac038b33e16890291f8dd5b7c8b2cc87b42a3 Mon Sep 17 00:00:00 2001\nFrom: medzeus2 <root@s53.dev>\nDate: Fri, 19 Aug 2016 18:06:53 +0800\nSubject: [PATCH] create patch fro nginx_tcp_proxy_module\n\n---\n src/core/ngx_log.c            |    2 +-\n src/core/ngx_log.h            |    3 ++-\n src/event/ngx_event_connect.h |    2 ++\n 3 files changed, 5 insertions(+), 2 deletions(-)\n\ndiff --git a/src/core/ngx_log.c b/src/core/ngx_log.c\nindex 8e9408d..b511284 100644\n--- a/src/core/ngx_log.c\n+++ b/src/core/ngx_log.c\n@@ -86,7 +86,7 @@ static ngx_str_t err_levels[] = {\n \n static const char *debug_levels[] = {\n     \"debug_core\", \"debug_alloc\", \"debug_mutex\", \"debug_event\",\n-    \"debug_http\", \"debug_mail\", \"debug_stream\"\n+    \"debug_http\", \"debug_mail\", \"debug_stream\", \"debug_tcp\"\n };\n \n \ndiff --git a/src/core/ngx_log.h b/src/core/ngx_log.h\nindex afb73bf..28b1aff 100644\n--- a/src/core/ngx_log.h\n+++ b/src/core/ngx_log.h\n@@ -30,6 +30,7 @@\n #define NGX_LOG_DEBUG_HTTP        0x100\n #define NGX_LOG_DEBUG_MAIL        0x200\n #define NGX_LOG_DEBUG_STREAM      0x400\n+#define NGX_LOG_DEBUG_TCP         0x800\n \n /*\n  * do not forget to update debug_levels[] in src/core/ngx_log.c\n@@ -37,7 +38,7 @@\n  */\n \n #define NGX_LOG_DEBUG_FIRST       NGX_LOG_DEBUG_CORE\n-#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_STREAM\n+#define NGX_LOG_DEBUG_LAST        NGX_LOG_DEBUG_TCP\n #define NGX_LOG_DEBUG_CONNECTION  0x80000000\n #define NGX_LOG_DEBUG_ALL         0x7ffffff0\n \ndiff --git a/src/event/ngx_event_connect.h b/src/event/ngx_event_connect.h\nindex 10b72a1..384586b 100644\n--- a/src/event/ngx_event_connect.h\n+++ b/src/event/ngx_event_connect.h\n@@ -33,6 +33,7 @@ typedef void (*ngx_event_save_peer_session_pt)(ngx_peer_connection_t *pc,\n     void *data);\n #endif\n \n+#define NGX_INVALID_CHECK_INDEX (ngx_uint_t)(-1)\n \n struct ngx_peer_connection_s {\n     ngx_connection_t                *connection;\n@@ -42,6 +43,7 @@ struct ngx_peer_connection_s {\n     ngx_str_t                       *name;\n \n     ngx_uint_t                       tries;\n+    ngx_uint_t                       check_index;\n     ngx_msec_t                       start_time;\n \n     ngx_event_get_peer_pt            get;\n-- \n1.7.1\n\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}